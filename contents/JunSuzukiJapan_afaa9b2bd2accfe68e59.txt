{"context": " More than 1 year has passed since last update.\n\n\u69cb\u6587\u89e3\u6790\u5668\n\u6b21\u306f\u3001\u69cb\u6587\u89e3\u6790\u5668\u3067\u3059\u3002\n\u300cScala\u306b\u4ee3\u6570\u578b(datatype\uff09\u3092\u5b9f\u88c5\u3059\u308b\u3000\u305d\u306e\uff11\u300d\u3067\u66f8\u3044\u305f\u3088\u3046\u306b\u3001\n\u30c8\u30c3\u30d7\u30ec\u30d9\u30eb\u3068\u305d\u308c\u4ee5\u5916\u306b\u308f\u3051\u3066\u8003\u3048\u3066\u3044\u304d\u307e\u3059\u3002\n\u305d\u306e\u524d\u306b\u3001datatype\u6587\u3092\u89e3\u6790\u3059\u308b\u30e1\u30bd\u30c3\u30c9datatypeDef()\u306b\u3064\u3044\u3066\u3001\n\u3061\u3087\u3063\u3068\u8003\u3048\u3066\u307f\u307e\u3057\u3087\u3046\u3002\ndatatypeDef()\u306f\u3001\n datatype Week = Mon | Tue | Wed | Thi | Fri | Sat | Sun\n\n\u306e\u3088\u3046\u306a\u6587\u3092\u89e3\u6790\u3057\u3066\u3001\nsealed abstract class Week()\ncase class Mon() extends Week\ncase class Tue() extends Week\ncase class Wed() extends Week\ncase class Thi() extends Week\ncase class Fri() extends Week\ncase class Sat() extends Week\ncase class Sun() extends Week\n\n\u306e\u3088\u3046\u306b\u5185\u90e8\u3067\u5909\u63db\u3059\u308b\u65b9\u91dd\u3067\u3059\u3002\n\u3067\u3059\u306e\u3067\u3001\u30e1\u30bd\u30c3\u30c9datatypeDef()\u306e\u8fd4\u308a\u5024\u306f\u8907\u6570\u306eclass\u5b9a\u7fa9\u306e\u30ea\u30b9\u30c8\u306b\u306a\u308a\u307e\u3059\u3002\nclass\u5b9a\u7fa9\u3092\u89e3\u6790\u3059\u308b\u30e1\u30bd\u30c3\u30c9classDef()\u306a\u3069\u306f\u3001\u8fd4\u308a\u5024\u306e\u578b\u306fTree\u3067\u3059\u304c\u3001datatypeDef()\u306e\u8fd4\u308a\u5024\u306e\u578b\u306fList[Tree]\u306b\u306a\u308b\u3067\u3057\u3087\u3046\u3002\n\u305f\u3060\u3057\u3001List[Tree]\u3092\u8fd4\u3059\u306e\u3060\u3068\u3001classDef()\u3068\u540c\u3058\u5834\u6240\u3067\u4f7f\u3046\u308f\u3051\u306b\u306f\u3044\u304b\u306a\u304f\u306a\u308a\u307e\u3059\u3002\n\u3082\u3061\u308d\u3093\u3001\u30af\u30e9\u30b9DatatypeDef()\u307f\u305f\u3044\u306aTree\u578b\u306e\u5b50\u30af\u30e9\u30b9\u3092\u4f5c\u3063\u3066\u8fd4\u3057\u3066\u3084\u308c\u3070\u3044\u3044\u306e\u3067\u3059\u304c\uff08\u610f\u5473\u89e3\u6790\u3084\u30d0\u30c3\u30af\u30a8\u30f3\u30c9\u3082\u4f5c\u308a\u8fbc\u3080\u306a\u3089\u3053\u306e\u65b9\u6cd5\u304c\u30d9\u30b9\u30c8\u3067\u3057\u3087\u3046\uff09\u3001\u4eca\u56de\u306f\u697d\u3092\u3059\u308b\u305f\u3081\u3001List[Tree]\u3092\u8fd4\u3059\u3053\u3068\u306b\u3057\u307e\u3059\u3002\n\u3067\u306f\u3001\u3069\u3046\u3059\u308c\u3070\u3044\u3044\u306e\u304b\u3068\u3044\u3046\u3068\u3001\u518d\u5e30\u964d\u4e0b\u6cd5\u3067\u69cb\u6587\u89e3\u6790\u3092\u3057\u3066\u3044\u308b\u9014\u4e2d\u3067\u3001List[Tree]\u3092\u8fd4\u3059\u30e1\u30bd\u30c3\u30c9\u304c\u3042\u308b\u306f\u305a\u3067\u3059\u306e\u3067\u3001\u305d\u3053\u306b\u5909\u66f4\u3092\u52a0\u3048\u3066\u3044\u304d\u307e\u3059\u3002\n\n\u30c8\u30fc\u30af\u30f3\u306e\u30bf\u30a4\u30d7\n\u6700\u521d\u306b\u3001\u30c8\u30fc\u30af\u30f3'datatype'\u304c\u304d\u3061\u3093\u3068\u8a8d\u8b58\u3055\u308c\u308b\u3088\u3046\u306b\u3001\n\u30e1\u30bd\u30c3\u30c9isDclIntro\u306b\u5909\u66f4\u3092\u52a0\u3048\u307e\u3059\u3002\n\nisTemplateIntro\u306e\u307b\u3046\u306b\u3057\u306a\u304b\u3063\u305f\u306e\u306f\u306a\u3093\u3068\u306a\u304f\u9055\u3046\u6c17\u304c\u3057\u305f\u304b\u3089\u3002\n\n\nParsers.scala\n    def isDclIntro: Boolean = in.token match {\n      case VAL | VAR | DEF | TYPE | DATATYPE => true\n      case _ => false\n    }\n\n\ncase\u6587\u306b\u3001DATATYPE \u3092\u8ffd\u52a0\u3057\u3066\u3044\u307e\u3059\u3002\n\n\u30c8\u30c3\u30d7\u30ec\u30d9\u30eb\n\u30c8\u30c3\u30d7\u30ec\u30d9\u30eb\u306e\u51e6\u7406\u306f\u3001\u30e1\u30bd\u30c3\u30c9topStatSeq()\u304b\u3089\u30e1\u30bd\u30c3\u30c9topLevelTmplDef\u3092\u547c\u3073\u51fa\u3057\u3066\u51e6\u7406\u3055\u308c\u3066\u3044\u308b\u3093\u3067\u3057\u305f\u306d\u3002\n\u30fbtopStatSeq()\u306e\u8fd4\u308a\u5024\u306e\u578b\u304c\u3001List[Tree]\u3002\n\u30fbtopLevelTmplDef\u306e\u8fd4\u308a\u5024\u306e\u578b\u304c\u3001Tree\u3002\n\u3067\u3059\u306e\u3067\u3001\u524d\u8ff0\u306e\u65b9\u91dd\u306b\u3057\u305f\u304c\u3063\u3066\u3001datatypeDef()\u306f\u3001topStatSeq()\u304b\u3089\u547c\u3073\u51fa\u3059\u3088\u3046\u306b\u3057\u3066\u3084\u308c\u3070\u3044\u3044\u3067\u3057\u3087\u3046\u3002\n\nParsers.scala\n    def topStatSeq(): List[Tree] = {\n      val stats = new ListBuffer[Tree]\n      while (!isStatSeqEnd) {\n        stats ++= (in.token match {\n          case PACKAGE  =>\n            packageOrPackageObject(in.skipToken()) :: Nil\n          case IMPORT =>\n            in.flushDoc\n            importClause()\n          case x if x == AT || isTemplateIntro || isModifier =>\n            joinComment(topLevelTmplDef :: Nil)\n          case DATATYPE =>\n            val annots = annotations(skipNewLines = true)\n            val pos    = caseAwareTokenOffset\n            val mods   = modifiers() withAnnotations annots\n            datatypeDef(pos, mods)\n          case _ =>\n            if (isStatSep) Nil\n            else syntaxErrorOrIncompleteAnd(\"expected class or object definition\", skipIt = true)(Nil)\n        })\n        acceptStatSepOpt()\n      }\n      stats.toList\n    }\n\n\ncase DATATYPE\u3000\u3042\u305f\u308a\u3092\u8ffd\u52a0\u3057\u3066\u3044\u307e\u3059\u3002\n\n\u305d\u308c\u4ee5\u5916\u306e\u30ec\u30d9\u30eb\n\u4e00\u65b9\u3001\u305d\u308c\u4ee5\u5916\u306e\u5834\u5408\u306b\u306f\u3001\u30e1\u30bd\u30c3\u30c9defOrDcl()\u304b\u3089\u30e1\u30bd\u30c3\u30c9tmplDef()\u3092\u547c\u3073\u51fa\u3057\u3066\u3044\u308b\u306e\u3067\u3057\u305f\u3002\n\u3053\u3061\u3089\u306f\u3001\n\u30fbdefOrDcl()\u306e\u8fd4\u308a\u5024\u306e\u578b\u304c\u3001List[Tree]\u3002\n\u30fbtmplDef()\u306e\u8fd4\u308a\u5024\u306e\u578b\u304c\u3001Tree\u3002\n\u3067\u3059\u306e\u3067\u3001defOrDcl()\u306e\u307b\u3046\u306b\u5909\u66f4\u3092\u52a0\u3048\u307e\u3059\u3002\n\nParsers.scala\n    def defOrDcl(pos: Int, mods: Modifiers): List[Tree] = {\n      if (mods.isLazy && in.token != VAL)\n        syntaxError(\"lazy not allowed here. Only vals can be lazy\", skipIt = false)\n      in.token match {\n        case VAL =>\n          patDefOrDcl(pos, mods withPosition(VAL, tokenRange(in)))\n        case VAR =>\n          patDefOrDcl(pos, (mods | Flags.MUTABLE) withPosition (VAR, tokenRange(in)))\n        case DEF =>\n          List(funDefOrDcl(pos, mods withPosition(DEF, tokenRange(in))))\n        case TYPE =>\n          List(typeDefOrDcl(pos, mods withPosition(TYPE, tokenRange(in))))\n        case DATATYPE =>\n          datatypeDef(pos, mods)\n        case _ =>\n          List(tmplDef(pos, mods))\n      }\n    }\n\n\ncase DATATYPE\u3042\u305f\u308a\u304c\u8ffd\u52a0\u3057\u305f\u3068\u3053\u308d\u3067\u3059\u3002\n\ndatatype\u69cb\u6587\u306e\u89e3\u6790\n\u3067\u306f\u3001\u5b9f\u969b\u306b\u30e1\u30bd\u30c3\u30c9datatypeDef()\u3068\u95a2\u9023\u3059\u308b\u30e1\u30bd\u30c3\u30c9\u3092\u5b9a\u7fa9\u3057\u307e\u3059\u3002\n\nParser.scala\n    /** {{{\n      *  DatatypeDef     ::= Id ClassParamClauses [ClassTemplateOpt] '=' DatatypeParamClauses\n      *  }}}\n      */\n    def datatypeDef(start: Int, mods: Modifiers): List[Tree] = {\n      // Id: get datatype name\n      in.nextToken()\n      val name = identForType()\n\n      //\n      savingClassContextBounds {\n        classContextBounds = List()\n        val tstart = (in.offset :: classContextBounds.map(_.pos.startOrPoint)).min\n\n        val constrAnnots = constructorAnnotations()\n        // ClassParamClauses\n        val (constrMods, vparamss) = (accessModifierOpt(), paramClauses(name, classContextBounds, ofCaseClass = false))\n        var mods1 = mods\n\n        // [ClassTemplateOpt]\n        val vpara = vparamss match {\n          case List() => List(List())\n          case _ => vparamss\n        }\n        val template = templateOpt(mods1, name, constrMods withAnnotations constrAnnots, vpara, tstart)\n\n        val abstractParentClass = ClassDef(mods1 | Flags.ABSTRACT | Flags.SEALED, name, List(), template)\n\n        // Context bounds generate implicit parameters (part of the template) with types\n        // from tparams: we need to ensure these don't overlap\n        if (!classContextBounds.isEmpty)\n          ensureNonOverlapping(template, Nil)\n\n        // check '='\n        if(in.token != EQUALS){\n          syntaxError(\"no '=' after datatype name.\", skipIt = false)\n        }\n        in.nextToken()\n\n        val result = abstractParentClass :: datatypeParamClauses(Ident(name), mods)\n        result\n      }\n    }\n\n    /** {{{\n      *  DatatypeParamClauses  ::= DatatypeParamClause ['|' DatatypeParamClause]\n      *  }}}\n      */\n    def datatypeParamClauses(superclass: Tree, mods: Modifiers): List[Tree] = {\n      val clauses = new ListBuffer[Tree]\n      val clause = datatypeParamClause(superclass, mods)\n      clauses.append(clause)\n      if ((in.token == NEWLINE || in.token == NEWLINES) && in.next.name == raw.BAR){\n        in.nextToken()\n      }\n      while (isRawBar) {\n        in.nextToken();\n        val node = datatypeParamClause(superclass, mods)\n        clauses.append(node)\n\n        if ((in.token == NEWLINE || in.token == NEWLINES) && in.next.name == raw.BAR){\n          in.nextToken()\n        }\n      }\n      clauses.toList\n    }\n\n    /** {{{\n      *  DatatypeParamClause  ::= Id ClassParamClauses [ClassTemplateOpt]\n      *  }}}\n      */\n    def datatypeParamClause(superclass: Tree, mods: Modifiers): Tree = {\n      // Id: get datatype name\n      val nameOffset = in.offset\n      val name = identForType()\n\n      classContextBounds = List()\n      val tstart = (in.offset :: classContextBounds.map(_.pos.startOrPoint)).min\n\n      // ClassParamClauses\n      val vparamss = paramClauses(name, classContextBounds, ofCaseClass = false)\n      var mods1 = mods\n\n      val constrAnnots = constructorAnnotations()\n      val constrMods = accessModifierOpt()\n\n      // [ClassTemplateOpt]\n      val vpara = vparamss match {\n        case List() => List(List())\n        case _ => vparamss\n      }\n      val template = datatypeTemplateOpt(mods1, name, constrMods withAnnotations constrAnnots, vpara, tstart, superclass)\n\n      val result = ClassDef(mods1 | Flags.CASE, name, List(), template)\n      result\n    }\n\n    /** {{{\n      *  DatatypeTemplateOpt ::= [TemplateBody]\n      *  }}}\n      */\n    def datatypeTemplateOpt(mods: Modifiers, name: Name, constrMods: Modifiers, vparamss: List[List[ValDef]], tstart: Int, superclass: Tree): Template = {\n      newLineOptWhenFollowedBy(LBRACE)\n      val (self, body) = templateBodyOpt(parenMeansSyntaxError = mods.isTrait || name.isTermName)\n      val parents: List[Tree] = superclass :: List(productConstr, serializableConstr)\n      val tstart0 = if (body.isEmpty && in.lastOffset < tstart) in.lastOffset else tstart\n\n      atPos(tstart0) {\n        // Exclude only the 9 primitives plus AnyVal.\n        Template(parents, self, constrMods, vparamss, body, o2p(tstart0))\n      }\n    }\n\n\n\n\u4e0a\u8a18\u30b3\u30fc\u30c9\u306e\u4e0b\u304b\u3089\uff13\u884c\u76ee\u306e\n       Template(parents, self, constrMods, vparamss, body, o2p(tstart0))\n\u306f\u3001\u6700\u65b0\u306e\u30bd\u30fc\u30b9\u3060\u3068\u4ee5\u4e0b\u306e\u8a18\u8ff0\u306b\u5909\u3048\u308b\u5fc5\u8981\u304c\u3042\u308b\u304b\u3082\u3057\u308c\u307e\u305b\u3093\u3002\n       gen.mkTemplate(parents, self, constrMods, vparamss, body, o2p(tstart0))\n\n\n\u4f7f\u3044\u65b9\n\n\u4f8b\u6587\n// datatype\u5b9a\u7fa9\ndatatype Week = Mon | Tue | Wed | Thu | Fri | Sat | Sun\n// \u30b3\u30f3\u30b9\u30c8\u30e9\u30af\u30bf\u547c\u3073\u51fa\u3057\n// \u3000\u30fbSun\u3060\u3051\u3060\u3068\u578b\u3092\u3042\u3089\u308f\u3059\u306e\u3067\u3001\u5fc5\u305a\u30ab\u30c3\u30b3\u304c\u5fc5\u8981\nval day: Week = Sun()\n// \u30d1\u30bf\u30fc\u30f3\u30de\u30c3\u30c1\nday match {\n  case Sun() => println(\"Sunday!\")\n  case _ => println(\"not Sunday.\")\n}\n\n\n\u3060\u3044\u305f\u3044\u3001\u4e0a\u8a18\u306e\u3088\u3046\u306b\u4f7f\u3044\u307e\u3059\u3002\n\u5b9f\u969b\u306b\u52d5\u304f\u30b3\u30fc\u30c9\u3082\u51fa\u3057\u3066\u307f\u307e\u3059\u3002\n\ndatatypeSample.scala\nobject datatypeSample {\n\n  datatype Week = Mon | Tue | Wed | Thi | Fri | Sat | Sun\n\n  val day: Week = Wed()\n  val result = day match {\n    case Mon() => \"\u6708\u66dc\u65e5\"\n    case Tue() => \"\u706b\u66dc\u65e5\"\n    case Wed() => \"\u6c34\u66dc\u65e5\"\n    case Thi() => \"\u6728\u66dc\u65e5\"\n    case Fri() => \"\u91d1\u66dc\u65e5\"\n    case Sat() => \"\u571f\u66dc\u65e5\"\n    case Sun() => \"\u65e5\u66dc\u65e5\"\n  }\n\n  datatype Week2 {\n    def isWorkday: Boolean = true\n    def isHolyday: Boolean = ! isWorkday\n  }\n  = Mon2 | Tue2 | Wed2 | Thi2 | Fri2 | Sat2 {\n      override def isWorkday = false\n    }\n  | Sun2 {\n      override def isWorkday = false\n    }\n\n  datatype Fig =\n    Rect(val x: Double, val y: Double){\n      def area(): Double = x * y\n    }\n  | Circle(val r: Double){\n      val pi = 3.14\n      def area(): Double = r * r * pi\n  }\n\n  def main(args: Array[String]): Unit = {\n    println(\"result = \" + result)\n\n    val day2: Week2 = Sun2()\n    println(\"Sun2.isWorkday = \" + day2.isWorkday)\n    println(\"Sun2.isHolyday = \" + day2.isHolyday)\n\n    val rect = Rect(3.0, 5.0)\n    val area1 = rect.area()\n    val circle = Circle(10.0)\n    val area2 = circle.area()\n    println(\"rect area = \" + area1)\n    println(\"circle area = \" + area2)\n  }\n}\n\n\n\u3053\u308c\u3092\u3001\u3042\u3089\u305f\u306b\u30b3\u30f3\u30d1\u30a4\u30eb\u3057\u305fscala\u3092\u4e0b\u8a18\u306e\u30b3\u30de\u30f3\u30c9\u3067\u5b9f\u884c\u3059\u308b\u3068\u3001\n\nScala\u306e\u30b3\u30f3\u30d1\u30a4\u30eb\u306fScala\u306e\u30bd\u30fc\u30b9\u30b3\u30fc\u30c9\u3092\u8aad\u3093\u3067\u307f\u308b\u3000\u305d\u306e\uff11\u3092\u53c2\u7167\n\n$ build/pack/bin/scala datatypeSample.scala\n\n\u4ee5\u4e0b\u306e\u51fa\u529b\u304c\u5f97\u3089\u308c\u307e\u3059\u3002\nresult = \u6c34\u66dc\u65e5\nSun2.isWorkday = false\nSun2.isHolyday = true\nrect area = 15.0\ncircle area = 314.0\n\n\n\u554f\u984c\u70b9\uff1a\u89e3\u6c7a\u6e08\u307f\uff01\uff01\n\u300cdatatype\u5ba3\u8a00\u4e2d\u306b'|'\u304c\u884c\u306e\u5148\u982d\u306b\u304f\u308b\u3053\u3068\u304c\u51fa\u6765\u306a\u3044\u300d\u3068\u3044\u3046\u554f\u984c\u306f\u3001\u89e3\u6c7a\u3057\u307e\u3057\u305f\u3002\n\u30e1\u30bd\u30c3\u30c9datatypeParamClauses\u3092\u3061\u3087\u3063\u3068\u66f8\u304d\u63db\u3048\u3066\u3042\u308a\u307e\u3059\u3002\n# \u69cb\u6587\u89e3\u6790\u5668\n\n\u6b21\u306f\u3001\u69cb\u6587\u89e3\u6790\u5668\u3067\u3059\u3002\n\n\u300cScala\u306b\u4ee3\u6570\u578b(datatype\uff09\u3092\u5b9f\u88c5\u3059\u308b\u3000\u305d\u306e\uff11\u300d\u3067\u66f8\u3044\u305f\u3088\u3046\u306b\u3001\n\u30c8\u30c3\u30d7\u30ec\u30d9\u30eb\u3068\u305d\u308c\u4ee5\u5916\u306b\u308f\u3051\u3066\u8003\u3048\u3066\u3044\u304d\u307e\u3059\u3002\n\n\u305d\u306e\u524d\u306b\u3001datatype\u6587\u3092\u89e3\u6790\u3059\u308b\u30e1\u30bd\u30c3\u30c9datatypeDef()\u306b\u3064\u3044\u3066\u3001\n\u3061\u3087\u3063\u3068\u8003\u3048\u3066\u307f\u307e\u3057\u3087\u3046\u3002\n\ndatatypeDef()\u306f\u3001\n\n```text:\n datatype Week = Mon | Tue | Wed | Thi | Fri | Sat | Sun\n```\n\n\u306e\u3088\u3046\u306a\u6587\u3092\u89e3\u6790\u3057\u3066\u3001\n\n```scala:\nsealed abstract class Week()\ncase class Mon() extends Week\ncase class Tue() extends Week\ncase class Wed() extends Week\ncase class Thi() extends Week\ncase class Fri() extends Week\ncase class Sat() extends Week\ncase class Sun() extends Week\n```\n\n\u306e\u3088\u3046\u306b\u5185\u90e8\u3067\u5909\u63db\u3059\u308b\u65b9\u91dd\u3067\u3059\u3002\n\u3067\u3059\u306e\u3067\u3001\u30e1\u30bd\u30c3\u30c9datatypeDef()\u306e\u8fd4\u308a\u5024\u306f\u8907\u6570\u306eclass\u5b9a\u7fa9\u306e\u30ea\u30b9\u30c8\u306b\u306a\u308a\u307e\u3059\u3002\n\nclass\u5b9a\u7fa9\u3092\u89e3\u6790\u3059\u308b\u30e1\u30bd\u30c3\u30c9classDef()\u306a\u3069\u306f\u3001\u8fd4\u308a\u5024\u306e\u578b\u306fTree\u3067\u3059\u304c\u3001datatypeDef()\u306e\u8fd4\u308a\u5024\u306e\u578b\u306fList[Tree]\u306b\u306a\u308b\u3067\u3057\u3087\u3046\u3002\n\u305f\u3060\u3057\u3001List[Tree]\u3092\u8fd4\u3059\u306e\u3060\u3068\u3001classDef()\u3068\u540c\u3058\u5834\u6240\u3067\u4f7f\u3046\u308f\u3051\u306b\u306f\u3044\u304b\u306a\u304f\u306a\u308a\u307e\u3059\u3002\n\n\u3082\u3061\u308d\u3093\u3001\u30af\u30e9\u30b9DatatypeDef()\u307f\u305f\u3044\u306aTree\u578b\u306e\u5b50\u30af\u30e9\u30b9\u3092\u4f5c\u3063\u3066\u8fd4\u3057\u3066\u3084\u308c\u3070\u3044\u3044\u306e\u3067\u3059\u304c\uff08\u610f\u5473\u89e3\u6790\u3084\u30d0\u30c3\u30af\u30a8\u30f3\u30c9\u3082\u4f5c\u308a\u8fbc\u3080\u306a\u3089\u3053\u306e\u65b9\u6cd5\u304c\u30d9\u30b9\u30c8\u3067\u3057\u3087\u3046\uff09\u3001\u4eca\u56de\u306f\u697d\u3092\u3059\u308b\u305f\u3081\u3001List[Tree]\u3092\u8fd4\u3059\u3053\u3068\u306b\u3057\u307e\u3059\u3002\n\n\u3067\u306f\u3001\u3069\u3046\u3059\u308c\u3070\u3044\u3044\u306e\u304b\u3068\u3044\u3046\u3068\u3001\u518d\u5e30\u964d\u4e0b\u6cd5\u3067\u69cb\u6587\u89e3\u6790\u3092\u3057\u3066\u3044\u308b\u9014\u4e2d\u3067\u3001List[Tree]\u3092\u8fd4\u3059\u30e1\u30bd\u30c3\u30c9\u304c\u3042\u308b\u306f\u305a\u3067\u3059\u306e\u3067\u3001\u305d\u3053\u306b\u5909\u66f4\u3092\u52a0\u3048\u3066\u3044\u304d\u307e\u3059\u3002\n\n# \u30c8\u30fc\u30af\u30f3\u306e\u30bf\u30a4\u30d7\n\n\u6700\u521d\u306b\u3001\u30c8\u30fc\u30af\u30f3'datatype'\u304c\u304d\u3061\u3093\u3068\u8a8d\u8b58\u3055\u308c\u308b\u3088\u3046\u306b\u3001\n\u30e1\u30bd\u30c3\u30c9isDclIntro\u306b\u5909\u66f4\u3092\u52a0\u3048\u307e\u3059\u3002\n\n>isTemplateIntro\u306e\u307b\u3046\u306b\u3057\u306a\u304b\u3063\u305f\u306e\u306f\u306a\u3093\u3068\u306a\u304f\u9055\u3046\u6c17\u304c\u3057\u305f\u304b\u3089\u3002\n\n```scala:Parsers.scala\n    def isDclIntro: Boolean = in.token match {\n      case VAL | VAR | DEF | TYPE | DATATYPE => true\n      case _ => false\n    }\n```\n\ncase\u6587\u306b\u3001DATATYPE \u3092\u8ffd\u52a0\u3057\u3066\u3044\u307e\u3059\u3002\n\n# \u30c8\u30c3\u30d7\u30ec\u30d9\u30eb\n\n\u30c8\u30c3\u30d7\u30ec\u30d9\u30eb\u306e\u51e6\u7406\u306f\u3001\u30e1\u30bd\u30c3\u30c9topStatSeq()\u304b\u3089\u30e1\u30bd\u30c3\u30c9topLevelTmplDef\u3092\u547c\u3073\u51fa\u3057\u3066\u51e6\u7406\u3055\u308c\u3066\u3044\u308b\u3093\u3067\u3057\u305f\u306d\u3002\n\n\u30fbtopStatSeq()\u306e\u8fd4\u308a\u5024\u306e\u578b\u304c\u3001List[Tree]\u3002\n\u30fbtopLevelTmplDef\u306e\u8fd4\u308a\u5024\u306e\u578b\u304c\u3001Tree\u3002\n\n\u3067\u3059\u306e\u3067\u3001\u524d\u8ff0\u306e\u65b9\u91dd\u306b\u3057\u305f\u304c\u3063\u3066\u3001datatypeDef()\u306f\u3001topStatSeq()\u304b\u3089\u547c\u3073\u51fa\u3059\u3088\u3046\u306b\u3057\u3066\u3084\u308c\u3070\u3044\u3044\u3067\u3057\u3087\u3046\u3002\n\n```scala:Parsers.scala\n    def topStatSeq(): List[Tree] = {\n      val stats = new ListBuffer[Tree]\n      while (!isStatSeqEnd) {\n        stats ++= (in.token match {\n          case PACKAGE  =>\n            packageOrPackageObject(in.skipToken()) :: Nil\n          case IMPORT =>\n            in.flushDoc\n            importClause()\n          case x if x == AT || isTemplateIntro || isModifier =>\n            joinComment(topLevelTmplDef :: Nil)\n          case DATATYPE =>\n            val annots = annotations(skipNewLines = true)\n            val pos    = caseAwareTokenOffset\n            val mods   = modifiers() withAnnotations annots\n            datatypeDef(pos, mods)\n          case _ =>\n            if (isStatSep) Nil\n            else syntaxErrorOrIncompleteAnd(\"expected class or object definition\", skipIt = true)(Nil)\n        })\n        acceptStatSepOpt()\n      }\n      stats.toList\n    }\n```\n\ncase DATATYPE\u3000\u3042\u305f\u308a\u3092\u8ffd\u52a0\u3057\u3066\u3044\u307e\u3059\u3002\n\n\n# \u305d\u308c\u4ee5\u5916\u306e\u30ec\u30d9\u30eb\n\n\u4e00\u65b9\u3001\u305d\u308c\u4ee5\u5916\u306e\u5834\u5408\u306b\u306f\u3001\u30e1\u30bd\u30c3\u30c9defOrDcl()\u304b\u3089\u30e1\u30bd\u30c3\u30c9tmplDef()\u3092\u547c\u3073\u51fa\u3057\u3066\u3044\u308b\u306e\u3067\u3057\u305f\u3002\n\n\u3053\u3061\u3089\u306f\u3001\n\n\u30fbdefOrDcl()\u306e\u8fd4\u308a\u5024\u306e\u578b\u304c\u3001List[Tree]\u3002\n\u30fbtmplDef()\u306e\u8fd4\u308a\u5024\u306e\u578b\u304c\u3001Tree\u3002\n\n\u3067\u3059\u306e\u3067\u3001defOrDcl()\u306e\u307b\u3046\u306b\u5909\u66f4\u3092\u52a0\u3048\u307e\u3059\u3002\n\n```scala:Parsers.scala\n    def defOrDcl(pos: Int, mods: Modifiers): List[Tree] = {\n      if (mods.isLazy && in.token != VAL)\n        syntaxError(\"lazy not allowed here. Only vals can be lazy\", skipIt = false)\n      in.token match {\n        case VAL =>\n          patDefOrDcl(pos, mods withPosition(VAL, tokenRange(in)))\n        case VAR =>\n          patDefOrDcl(pos, (mods | Flags.MUTABLE) withPosition (VAR, tokenRange(in)))\n        case DEF =>\n          List(funDefOrDcl(pos, mods withPosition(DEF, tokenRange(in))))\n        case TYPE =>\n          List(typeDefOrDcl(pos, mods withPosition(TYPE, tokenRange(in))))\n        case DATATYPE =>\n          datatypeDef(pos, mods)\n        case _ =>\n          List(tmplDef(pos, mods))\n      }\n    }\n```\n\ncase DATATYPE\u3042\u305f\u308a\u304c\u8ffd\u52a0\u3057\u305f\u3068\u3053\u308d\u3067\u3059\u3002\n\n# datatype\u69cb\u6587\u306e\u89e3\u6790\n\n\u3067\u306f\u3001\u5b9f\u969b\u306b\u30e1\u30bd\u30c3\u30c9datatypeDef()\u3068\u95a2\u9023\u3059\u308b\u30e1\u30bd\u30c3\u30c9\u3092\u5b9a\u7fa9\u3057\u307e\u3059\u3002\n\n```scala:Parser.scala\n    /** {{{\n      *  DatatypeDef     ::= Id ClassParamClauses [ClassTemplateOpt] '=' DatatypeParamClauses\n      *  }}}\n      */\n    def datatypeDef(start: Int, mods: Modifiers): List[Tree] = {\n      // Id: get datatype name\n      in.nextToken()\n      val name = identForType()\n\n      //\n      savingClassContextBounds {\n        classContextBounds = List()\n        val tstart = (in.offset :: classContextBounds.map(_.pos.startOrPoint)).min\n\n        val constrAnnots = constructorAnnotations()\n        // ClassParamClauses\n        val (constrMods, vparamss) = (accessModifierOpt(), paramClauses(name, classContextBounds, ofCaseClass = false))\n        var mods1 = mods\n\n        // [ClassTemplateOpt]\n        val vpara = vparamss match {\n          case List() => List(List())\n          case _ => vparamss\n        }\n        val template = templateOpt(mods1, name, constrMods withAnnotations constrAnnots, vpara, tstart)\n\n        val abstractParentClass = ClassDef(mods1 | Flags.ABSTRACT | Flags.SEALED, name, List(), template)\n\n        // Context bounds generate implicit parameters (part of the template) with types\n        // from tparams: we need to ensure these don't overlap\n        if (!classContextBounds.isEmpty)\n          ensureNonOverlapping(template, Nil)\n\n        // check '='\n        if(in.token != EQUALS){\n          syntaxError(\"no '=' after datatype name.\", skipIt = false)\n        }\n        in.nextToken()\n\n        val result = abstractParentClass :: datatypeParamClauses(Ident(name), mods)\n        result\n      }\n    }\n\n    /** {{{\n      *  DatatypeParamClauses  ::= DatatypeParamClause ['|' DatatypeParamClause]\n      *  }}}\n      */\n    def datatypeParamClauses(superclass: Tree, mods: Modifiers): List[Tree] = {\n      val clauses = new ListBuffer[Tree]\n      val clause = datatypeParamClause(superclass, mods)\n      clauses.append(clause)\n      if ((in.token == NEWLINE || in.token == NEWLINES) && in.next.name == raw.BAR){\n        in.nextToken()\n      }\n      while (isRawBar) {\n        in.nextToken();\n        val node = datatypeParamClause(superclass, mods)\n        clauses.append(node)\n\n        if ((in.token == NEWLINE || in.token == NEWLINES) && in.next.name == raw.BAR){\n          in.nextToken()\n        }\n      }\n      clauses.toList\n    }\n\n    /** {{{\n      *  DatatypeParamClause  ::= Id ClassParamClauses [ClassTemplateOpt]\n      *  }}}\n      */\n    def datatypeParamClause(superclass: Tree, mods: Modifiers): Tree = {\n      // Id: get datatype name\n      val nameOffset = in.offset\n      val name = identForType()\n\n      classContextBounds = List()\n      val tstart = (in.offset :: classContextBounds.map(_.pos.startOrPoint)).min\n\n      // ClassParamClauses\n      val vparamss = paramClauses(name, classContextBounds, ofCaseClass = false)\n      var mods1 = mods\n\n      val constrAnnots = constructorAnnotations()\n      val constrMods = accessModifierOpt()\n\n      // [ClassTemplateOpt]\n      val vpara = vparamss match {\n        case List() => List(List())\n        case _ => vparamss\n      }\n      val template = datatypeTemplateOpt(mods1, name, constrMods withAnnotations constrAnnots, vpara, tstart, superclass)\n\n      val result = ClassDef(mods1 | Flags.CASE, name, List(), template)\n      result\n    }\n\n    /** {{{\n      *  DatatypeTemplateOpt ::= [TemplateBody]\n      *  }}}\n      */\n    def datatypeTemplateOpt(mods: Modifiers, name: Name, constrMods: Modifiers, vparamss: List[List[ValDef]], tstart: Int, superclass: Tree): Template = {\n      newLineOptWhenFollowedBy(LBRACE)\n      val (self, body) = templateBodyOpt(parenMeansSyntaxError = mods.isTrait || name.isTermName)\n      val parents: List[Tree] = superclass :: List(productConstr, serializableConstr)\n      val tstart0 = if (body.isEmpty && in.lastOffset < tstart) in.lastOffset else tstart\n\n      atPos(tstart0) {\n        // Exclude only the 9 primitives plus AnyVal.\n        Template(parents, self, constrMods, vparamss, body, o2p(tstart0))\n      }\n    }\n```\n\n>\u4e0a\u8a18\u30b3\u30fc\u30c9\u306e\u4e0b\u304b\u3089\uff13\u884c\u76ee\u306e\n>        Template(parents, self, constrMods, vparamss, body, o2p(tstart0))\n> \u306f\u3001\u6700\u65b0\u306e\u30bd\u30fc\u30b9\u3060\u3068\u4ee5\u4e0b\u306e\u8a18\u8ff0\u306b\u5909\u3048\u308b\u5fc5\u8981\u304c\u3042\u308b\u304b\u3082\u3057\u308c\u307e\u305b\u3093\u3002\n>        gen.mkTemplate(parents, self, constrMods, vparamss, body, o2p(tstart0))\n\n# \u4f7f\u3044\u65b9\n\n```scala:\u4f8b\u6587\n// datatype\u5b9a\u7fa9\ndatatype Week = Mon | Tue | Wed | Thu | Fri | Sat | Sun\n// \u30b3\u30f3\u30b9\u30c8\u30e9\u30af\u30bf\u547c\u3073\u51fa\u3057\n// \u3000\u30fbSun\u3060\u3051\u3060\u3068\u578b\u3092\u3042\u3089\u308f\u3059\u306e\u3067\u3001\u5fc5\u305a\u30ab\u30c3\u30b3\u304c\u5fc5\u8981\nval day: Week = Sun()\n// \u30d1\u30bf\u30fc\u30f3\u30de\u30c3\u30c1\nday match {\n  case Sun() => println(\"Sunday!\")\n  case _ => println(\"not Sunday.\")\n}\n```\n\n\u3060\u3044\u305f\u3044\u3001\u4e0a\u8a18\u306e\u3088\u3046\u306b\u4f7f\u3044\u307e\u3059\u3002\n\u5b9f\u969b\u306b\u52d5\u304f\u30b3\u30fc\u30c9\u3082\u51fa\u3057\u3066\u307f\u307e\u3059\u3002\n\n```scala:datatypeSample.scala\nobject datatypeSample {\n\n  datatype Week = Mon | Tue | Wed | Thi | Fri | Sat | Sun\n\n  val day: Week = Wed()\n  val result = day match {\n    case Mon() => \"\u6708\u66dc\u65e5\"\n    case Tue() => \"\u706b\u66dc\u65e5\"\n    case Wed() => \"\u6c34\u66dc\u65e5\"\n    case Thi() => \"\u6728\u66dc\u65e5\"\n    case Fri() => \"\u91d1\u66dc\u65e5\"\n    case Sat() => \"\u571f\u66dc\u65e5\"\n    case Sun() => \"\u65e5\u66dc\u65e5\"\n  }\n\n  datatype Week2 {\n    def isWorkday: Boolean = true\n    def isHolyday: Boolean = ! isWorkday\n  }\n  = Mon2 | Tue2 | Wed2 | Thi2 | Fri2 | Sat2 {\n      override def isWorkday = false\n    }\n  | Sun2 {\n      override def isWorkday = false\n    }\n\n  datatype Fig =\n    Rect(val x: Double, val y: Double){\n      def area(): Double = x * y\n    }\n  | Circle(val r: Double){\n      val pi = 3.14\n      def area(): Double = r * r * pi\n  }\n\n  def main(args: Array[String]): Unit = {\n    println(\"result = \" + result)\n\n    val day2: Week2 = Sun2()\n    println(\"Sun2.isWorkday = \" + day2.isWorkday)\n    println(\"Sun2.isHolyday = \" + day2.isHolyday)\n\n    val rect = Rect(3.0, 5.0)\n    val area1 = rect.area()\n    val circle = Circle(10.0)\n    val area2 = circle.area()\n    println(\"rect area = \" + area1)\n    println(\"circle area = \" + area2)\n  }\n}\n```\n\n\u3053\u308c\u3092\u3001\u3042\u3089\u305f\u306b\u30b3\u30f3\u30d1\u30a4\u30eb\u3057\u305fscala\u3092\u4e0b\u8a18\u306e\u30b3\u30de\u30f3\u30c9\u3067\u5b9f\u884c\u3059\u308b\u3068\u3001\n\n>Scala\u306e\u30b3\u30f3\u30d1\u30a4\u30eb\u306f[Scala\u306e\u30bd\u30fc\u30b9\u30b3\u30fc\u30c9\u3092\u8aad\u3093\u3067\u307f\u308b\u3000\u305d\u306e\uff11](http://qiita.com/JunSuzukiJapan@github/items/8811dc4caefd2a311cce)\u3092\u53c2\u7167\n\n```bash:\n$ build/pack/bin/scala datatypeSample.scala\n```\n\u4ee5\u4e0b\u306e\u51fa\u529b\u304c\u5f97\u3089\u308c\u307e\u3059\u3002\n\n```text:\nresult = \u6c34\u66dc\u65e5\nSun2.isWorkday = false\nSun2.isHolyday = true\nrect area = 15.0\ncircle area = 314.0\n```\n\n# \u554f\u984c\u70b9\uff1a\u89e3\u6c7a\u6e08\u307f\uff01\uff01\n\n\u300cdatatype\u5ba3\u8a00\u4e2d\u306b'|'\u304c\u884c\u306e\u5148\u982d\u306b\u304f\u308b\u3053\u3068\u304c\u51fa\u6765\u306a\u3044\u300d\u3068\u3044\u3046\u554f\u984c\u306f\u3001\u89e3\u6c7a\u3057\u307e\u3057\u305f\u3002\n\u30e1\u30bd\u30c3\u30c9datatypeParamClauses\u3092\u3061\u3087\u3063\u3068\u66f8\u304d\u63db\u3048\u3066\u3042\u308a\u307e\u3059\u3002\n\n", "tags": ["\u4ee3\u6570\u578b", "Scala", "\u30bd\u30fc\u30b9\u30b3\u30fc\u30c9", "datatype"]}