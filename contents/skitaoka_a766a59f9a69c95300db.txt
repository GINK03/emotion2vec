{"context": " More than 1 year has passed since last update.\u30d7\u30ec\u30a4\u30a2\u30a6\u30c8\u306e\u30b5\u30f3\u30d7\u30ea\u30f3\u30b0\u5206\u5e03\u3092\u52d5\u7684\u306b\u8abf\u6574\u3059\u308b\u3088\u3046\u306b NMCS \u3092\u62e1\u5f35\u3057\u305f NRPA (Nested Rollout Policy Adaptation) \u3092\u7d39\u4ecb\u3059\u308b\u3002\n\u30d7\u30ec\u30a4\u30a2\u30a6\u30c8\u306b\u304a\u3044\u3066\u3001\u72b6\u614b\u30ce\u30fc\u30c9 $\\textrm{node}$ \u3067\u884c\u52d5 $a$ \u3092\u8d77\u3053\u3059\u78ba\u7387\u3092 $\\exp(p_{\\textrm{node},a})$ \u306b\u6bd4\u4f8b\u3055\u305b\u308b\u3002\u305d\u3057\u3066\u305d\u306e\u5024\u3092\u3001\u30d7\u30ec\u30a4\u30a2\u30a6\u30c8\u3054\u3068\u306b\u66f4\u65b0\u3059\u308b\u3002\n\n\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0\n\u91cd\u307f\u4ed8\u3051\u3092\u8003\u3048\u305f\u30d7\u30ec\u30a4\u30a2\u30a6\u30c8\u306f\u4e0b\u8a18\u306e\u3088\u3046\u306b\u306a\u308b\u3002\n\nplayout\nauto playout(node_t node)\n{\n  using std::begin;\n  using std::end;\n\n  assert(node);\n\n  std::vector<int> seq;\n  while (!node.empty()) {\n    // \u7d2f\u7a4d\u78ba\u7387\u8cea\u91cf\u95a2\u6570\u3092\u3064\u304f\u308b\n    std::vector<double> w(node.size());\n    w[0] = 0;\n    for (auto const a : node.children()) {\n      w[a+1] = w[a] + std::exp(p[node,a]);\n    }\n\n    // random() \u306f [0,1) \u306e\u4e71\u6570\u3092\u8fd4\u3059\u95a2\u6570\n    auto const a = std::distance(begin(w)+1,\n      std::lower_bound(begin(w), end(w), w.back() * random()));\n    node = node[a];\n    seq.push_back(a);\n  }\n\n   // return score and sequence\n  return std::move(std::make_pair(evaluate(node), seq));\n}\n\n\n\nnrpa\nauto nrpa(int const level, node_t const node, policy_t & p)\n{\n  auto best_score = -std::numeric_limits<double>::infinity();\n  auto best_seq   =  std::vector<int>();\n\n  for (int i = 0; i < N; ++i) {\n    auto const r\n      = (level == 0)\n      ? playout(node)\n      : nrpa(level - 1, node, p);\n    if (best_score < r.first) {\n      best_score = std::move(r.first );\n      best_seq   = std::move(r.second);\n    }\n\n    // update policy by current best-seq\n    adapt(node, p, best_seq);\n  }\n\n  return std::move(std::make_pair(best_score, best_seq));\n}\n\n\n\u3053\u308c\u3060\u3068 nexted \u306b\u306a\u3063\u3066\u3044\u306a\u3044\u6c17\u304c\u3059\u308b\u2026\u2026\n\nadapt\n// \u65b9\u7b56\u3092\u66f4\u65b0\nauto adapt(node_t node, policy_t & p, std::vector<int> const seq)\n{\n  auto const q = p;\n  for (auto const a : seq) {\n    p[node, a] += Alpha;\n\n    auto rcpz = 0.0;\n    for (auto const i : node) {\n      rcpz = std::exp(q[node, i]);\n    }\n    rcpz = 1.0 / rcpz;\n\n    for (auto const i : node) {\n      p[node, i] -= Alpha * rcp * std::exp(q[node, i]);\n    }\n\n    node = node[a];\n  }\n}\n\n\n\u3053\u3053\u3067\u3001N \u3068 Alpha \u306f\u9069\u5f53\u306a\u5b9a\u6570\u3002\n\n\u53c2\u8003\u6587\u732e\n\nChris Rosin, \"Nested rollout policy adaptation for Monte Carlo tree search,\" International Joint Conferences on Artificial Intelligence 2011 (IJCAI 2011), pp. 649-654, 2011.\nTristan Cazenave, and Fabien Teytaud, \"Application of the nested rollout policy adaptation algorithm to the traveling salesman problem with time windows,\" Learning and Intelligent Optimization, Lecture Notes in Computer Science 2012, pp 42-54, 2012.\n\n\u30d7\u30ec\u30a4\u30a2\u30a6\u30c8\u306e\u30b5\u30f3\u30d7\u30ea\u30f3\u30b0\u5206\u5e03\u3092\u52d5\u7684\u306b\u8abf\u6574\u3059\u308b\u3088\u3046\u306b NMCS \u3092\u62e1\u5f35\u3057\u305f NRPA (Nested Rollout Policy Adaptation) \u3092\u7d39\u4ecb\u3059\u308b\u3002\n\n\u30d7\u30ec\u30a4\u30a2\u30a6\u30c8\u306b\u304a\u3044\u3066\u3001\u72b6\u614b\u30ce\u30fc\u30c9 $\\textrm{node}$ \u3067\u884c\u52d5 $a$ \u3092\u8d77\u3053\u3059\u78ba\u7387\u3092 $\\exp(p_{\\textrm{node},a})$ \u306b\u6bd4\u4f8b\u3055\u305b\u308b\u3002\u305d\u3057\u3066\u305d\u306e\u5024\u3092\u3001\u30d7\u30ec\u30a4\u30a2\u30a6\u30c8\u3054\u3068\u306b\u66f4\u65b0\u3059\u308b\u3002\n\n# \u30a2\u30eb\u30b4\u30ea\u30ba\u30e0\n\n\u91cd\u307f\u4ed8\u3051\u3092\u8003\u3048\u305f\u30d7\u30ec\u30a4\u30a2\u30a6\u30c8\u306f\u4e0b\u8a18\u306e\u3088\u3046\u306b\u306a\u308b\u3002\n\n~~~cpp:playout\nauto playout(node_t node)\n{\n  using std::begin;\n  using std::end;\n\n  assert(node);\n\n  std::vector<int> seq;\n  while (!node.empty()) {\n    // \u7d2f\u7a4d\u78ba\u7387\u8cea\u91cf\u95a2\u6570\u3092\u3064\u304f\u308b\n    std::vector<double> w(node.size());\n    w[0] = 0;\n    for (auto const a : node.children()) {\n      w[a+1] = w[a] + std::exp(p[node,a]);\n    }\n\n    // random() \u306f [0,1) \u306e\u4e71\u6570\u3092\u8fd4\u3059\u95a2\u6570\n    auto const a = std::distance(begin(w)+1,\n      std::lower_bound(begin(w), end(w), w.back() * random()));\n    node = node[a];\n    seq.push_back(a);\n  }\n\n   // return score and sequence\n  return std::move(std::make_pair(evaluate(node), seq));\n}\n~~~\n\n~~~cpp:nrpa\nauto nrpa(int const level, node_t const node, policy_t & p)\n{\n  auto best_score = -std::numeric_limits<double>::infinity();\n  auto best_seq   =  std::vector<int>();\n\n  for (int i = 0; i < N; ++i) {\n    auto const r\n      = (level == 0)\n      ? playout(node)\n      : nrpa(level - 1, node, p);\n    if (best_score < r.first) {\n      best_score = std::move(r.first );\n      best_seq   = std::move(r.second);\n    }\n\n    // update policy by current best-seq\n    adapt(node, p, best_seq);\n  }\n\n  return std::move(std::make_pair(best_score, best_seq));\n}\n~~~\n\n\u3053\u308c\u3060\u3068 nexted \u306b\u306a\u3063\u3066\u3044\u306a\u3044\u6c17\u304c\u3059\u308b\u2026\u2026\n\n~~~cpp:adapt\n// \u65b9\u7b56\u3092\u66f4\u65b0\nauto adapt(node_t node, policy_t & p, std::vector<int> const seq)\n{\n  auto const q = p;\n  for (auto const a : seq) {\n    p[node, a] += Alpha;\n\n    auto rcpz = 0.0;\n    for (auto const i : node) {\n      rcpz = std::exp(q[node, i]);\n    }\n    rcpz = 1.0 / rcpz;\n\n    for (auto const i : node) {\n      p[node, i] -= Alpha * rcp * std::exp(q[node, i]);\n    }\n\n    node = node[a];\n  }\n}\n~~~\n\n\u3053\u3053\u3067\u3001N \u3068 Alpha \u306f\u9069\u5f53\u306a\u5b9a\u6570\u3002\n\n# \u53c2\u8003\u6587\u732e\n\n0. Chris Rosin, \"[Nested rollout policy adaptation for Monte Carlo tree search](http://www.morpionsolitaire.com/English/Papers.htm),\" International Joint Conferences on Artificial Intelligence 2011 (IJCAI 2011), pp. 649-654, 2011.\n0. Tristan Cazenave, and Fabien Teytaud, \"[Application of the nested rollout policy adaptation algorithm to the traveling salesman problem with time windows](http://www.morpionsolitaire.com/English/Papers.htm),\" Learning and Intelligent Optimization, Lecture Notes in Computer Science 2012, pp 42-54, 2012.\n", "tags": ["\u5f37\u5316\u5b66\u7fd2", "\u6a5f\u68b0\u5b66\u7fd2"]}