{"context": "\n\u52d5\u4f5c\u74b0\u5883\nESP-WROOM-02 (\u4ee5\u4e0b ESP8266)\nMPU-9250\n\n\n\u63a5\u7d9a\u306b\u95a2\u3057\u3066\u306f\u3053\u3061\u3089\u3068\u540c\u3058\nhttp://qiita.com/7of9/items/b8a31f470555fb845cb5\n\ncode\nv0.2 @ github\n\u30b5\u30f3\u30d7\u30eb\u30b9\u30b1\u30c3\u30c1MPU6050_DMP6\u3092\u53c2\u8003\u306b\u81ea\u5206\u306a\u308a\u306b\u5b9f\u88c5\u3057\u305f\u3002\n\u3068\u3044\u3063\u3066\u3082\u307b\u3068\u3093\u3069\u540c\u3058\u3088\u3046\u306a\u3082\u306e\u3002\u95a2\u6570\u5207\u308a\u5206\u3051\u3057\u305f\u308a\u3001\u5909\u6570\u306e\u5ba3\u8a00\u5834\u6240\u3092\u5909\u3048\u305f\u308aWiFi.disconnect()\u3092\u8ffd\u52a0\u3057\u305f\u308a\u3057\u305f\u3002\n\nesp8266_160701_MPU9250\n/*\n * v0.2 2016 Jul. 01\n *   - based on MPU6050_DMP6 (6/21/2012 by Jeff Rowberg <jeff@rowberg.net>)\n */\n\n#include \"I2Cdev.h\"\n#include \"MPU9150_9Axis_MotionApps41.h\"\n#include \"Wire.h\"\n#include <ESP8266WiFi.h>\nMPU9150 mpu;\n\n#define INTERRUPT_PIN 14  // ESP8266\n\nbool dmpReady = false;  // set true if DMP init was successful\nuint16_t packetSize;\nuint16_t fifoCount;\n\nvolatile bool mpuInterrupt = false;     // indicates whether MPU interrupt pin has gone high\nvoid dmpDataReady() {\n    mpuInterrupt = true;\n}\n\nvoid MPU_setup() {\n  Wire.begin();\n  Wire.setClock(400000L); // 400kHz\n\n  mpu.initialize();\n  pinMode(INTERRUPT_PIN, INPUT);\n\n  if (mpu.testConnection()) { // TODO: NG occurred\n    Serial.println( F(\"MPU connect OK\") );\n  } else {\n    Serial.println( F(\"MPU connect NG\") );\n  }\n\n  uint8_t devStatus = mpu.dmpInitialize();\n\n  // for calibration\n//  mpu.setXGyroOffset(0);\n//  mpu.setYGyroOffset(0);\n//  mpu.setZGyroOffset(0);\n//  mpu.setZAccelOffset(0);\n\n  if (devStatus == 0) { // OK\n    mpu.setDMPEnabled(true);\n    attachInterrupt(digitalPinToInterrupt(INTERRUPT_PIN), dmpDataReady, RISING); \n//    uint8_t mpuIntStatus = mpu.getIntStatus();\n    dmpReady = true;\n    packetSize = mpu.dmpGetFIFOPacketSize();\n    Serial.println( F(\"DMP initialize: OK\") );\n  } else {\n    // error\n    Serial.println( F(\"DMP initialize: NG\") );\n  }\n}\n\nvoid setup() {\n  WiFi.disconnect();\n  Serial.begin(115200);\n  MPU_setup();\n}\n\nvoid loop() {\n  uint8_t mpuIntStatus;\n  uint8_t fifoBuffer[64];\n// uint16_t fifoCount; // declaring fifoCount here causes FIFO overflow\n\n  if (!dmpReady) {\n    return;\n  }\n\n  while(!mpuInterrupt && fifoCount < packetSize) \n    ;\n\n  mpuInterrupt = false;\n  mpuIntStatus = mpu.getIntStatus();\n  fifoCount = mpu.getFIFOCount();\n\n  if ( (mpuIntStatus & 0x10) || (fifoCount == 1024) ) {\n    mpu.resetFIFO();\n    Serial.println( F(\"FIFO overflow!\") );\n  } else if (mpuIntStatus & 0x02) {\n      while(fifoCount < packetSize) {\n        fifoCount = mpu.getFIFOCount();\n      }\n\n      mpu.getFIFOBytes(fifoBuffer, packetSize);\n\n      fifoCount -= packetSize;\n\n      Quaternion qtn; // [w, x, y, z]\n      mpu.dmpGetQuaternion(&qtn, fifoBuffer);\n      Serial.print(\"quat\\t\");\n      Serial.print(qtn.w);      \n      Serial.print(\"\\t\");\n      Serial.print(qtn.x);      \n      Serial.print(\"\\t\");\n      Serial.print(qtn.y);      \n      Serial.print(\"\\t\");\n      Serial.println(qtn.z);      \n  }\n}\n\n\n\n\u5f15\u3063\u304b\u304b\u3063\u305f\u70b9\n\nFIFO overflow\nfifoCount\u3068\u3044\u3046\u5909\u6570\u306f\u307b\u3068\u3093\u3069loop()\u5185\u3067\u3057\u304b\u4f7f\u7528\u3057\u3066\u3044\u306a\u3044\u306e\u3067\u3001loop()\u5185\u3067\u306e\u5ba3\u8a00\u3092\u8a66\u3057\u305f\u3002\nvoid loop() {\n  uint8_t mpuIntStatus;\n  uint8_t fifoBuffer[64];\n  uint16_t fifoCount; // \n\n\u3059\u308b\u3068\u3001FIFO overflow\u304c\u767a\u751f\u3059\u308b\u3088\u3046\u306b\u306a\u3063\u3066\u3057\u307e\u3063\u305f\u306e\u3067\u3001\u30d5\u30a1\u30a4\u30eb\u30b9\u30b3\u30fc\u30d7\u3067\u306e\u5ba3\u8a00\u306b\u623b\u3057\u305f\u3002\nFIFO overflow\u767a\u751f\u6642\u306efifoCount\u306f512\u3060\u3063\u305f\u3002mpuIntStatus\u306e0x10\u304c\u7acb\u3063\u3066\u3044\u308b\u3088\u3046\u3060\u304c\u3001\u3088\u304f\u5206\u304b\u3089\u306a\u3044\u72b6\u6cc1\u3060\u3002\n\nmpu.testConnection() Fail\nmpu.testConnection()\u306e\u7d50\u679c\u304cFail\u3068\u306a\u308b\u3002\n\u5143\u306e\u30b5\u30f3\u30d7\u30eb\u30b9\u30b1\u30c3\u30c1\u3067\u3082Fail\u3068\u306a\u3063\u3066\u3044\u308b\u3002\n```txt:\u52d5\u4f5c\u74b0\u5883\nESP-WROOM-02 (\u4ee5\u4e0b ESP8266)\nMPU-9250\n```\n\n\u63a5\u7d9a\u306b\u95a2\u3057\u3066\u306f\u3053\u3061\u3089\u3068\u540c\u3058\nhttp://qiita.com/7of9/items/b8a31f470555fb845cb5\n\n## code \n\n[v0.2 @ github](https://github.com/yasokada/esp8266_160701_MPU9250/releases/tag/v0.2)\n\n\u30b5\u30f3\u30d7\u30eb\u30b9\u30b1\u30c3\u30c1MPU6050_DMP6\u3092\u53c2\u8003\u306b\u81ea\u5206\u306a\u308a\u306b\u5b9f\u88c5\u3057\u305f\u3002\n\u3068\u3044\u3063\u3066\u3082\u307b\u3068\u3093\u3069\u540c\u3058\u3088\u3046\u306a\u3082\u306e\u3002\u95a2\u6570\u5207\u308a\u5206\u3051\u3057\u305f\u308a\u3001\u5909\u6570\u306e\u5ba3\u8a00\u5834\u6240\u3092\u5909\u3048\u305f\u308aWiFi.disconnect()\u3092\u8ffd\u52a0\u3057\u305f\u308a\u3057\u305f\u3002\n\n```c:esp8266_160701_MPU9250\n/*\n * v0.2 2016 Jul. 01\n *   - based on MPU6050_DMP6 (6/21/2012 by Jeff Rowberg <jeff@rowberg.net>)\n */\n\n#include \"I2Cdev.h\"\n#include \"MPU9150_9Axis_MotionApps41.h\"\n#include \"Wire.h\"\n#include <ESP8266WiFi.h>\nMPU9150 mpu;\n\n#define INTERRUPT_PIN 14  // ESP8266\n\nbool dmpReady = false;  // set true if DMP init was successful\nuint16_t packetSize;\nuint16_t fifoCount;\n\nvolatile bool mpuInterrupt = false;     // indicates whether MPU interrupt pin has gone high\nvoid dmpDataReady() {\n    mpuInterrupt = true;\n}\n\nvoid MPU_setup() {\n  Wire.begin();\n  Wire.setClock(400000L); // 400kHz\n  \n  mpu.initialize();\n  pinMode(INTERRUPT_PIN, INPUT);\n\n  if (mpu.testConnection()) { // TODO: NG occurred\n    Serial.println( F(\"MPU connect OK\") );\n  } else {\n    Serial.println( F(\"MPU connect NG\") );\n  }\n\n  uint8_t devStatus = mpu.dmpInitialize();\n\n  // for calibration\n//  mpu.setXGyroOffset(0);\n//  mpu.setYGyroOffset(0);\n//  mpu.setZGyroOffset(0);\n//  mpu.setZAccelOffset(0);\n\n  if (devStatus == 0) { // OK\n    mpu.setDMPEnabled(true);\n    attachInterrupt(digitalPinToInterrupt(INTERRUPT_PIN), dmpDataReady, RISING); \n//    uint8_t mpuIntStatus = mpu.getIntStatus();\n    dmpReady = true;\n    packetSize = mpu.dmpGetFIFOPacketSize();\n    Serial.println( F(\"DMP initialize: OK\") );\n  } else {\n    // error\n    Serial.println( F(\"DMP initialize: NG\") );\n  }\n}\n\nvoid setup() {\n  WiFi.disconnect();\n  Serial.begin(115200);\n  MPU_setup();\n}\n\nvoid loop() {\n  uint8_t mpuIntStatus;\n  uint8_t fifoBuffer[64];\n// uint16_t fifoCount; // declaring fifoCount here causes FIFO overflow\n\n  if (!dmpReady) {\n    return;\n  }\n\n  while(!mpuInterrupt && fifoCount < packetSize) \n    ;\n\n  mpuInterrupt = false;\n  mpuIntStatus = mpu.getIntStatus();\n  fifoCount = mpu.getFIFOCount();\n\n  if ( (mpuIntStatus & 0x10) || (fifoCount == 1024) ) {\n    mpu.resetFIFO();\n    Serial.println( F(\"FIFO overflow!\") );\n  } else if (mpuIntStatus & 0x02) {\n      while(fifoCount < packetSize) {\n        fifoCount = mpu.getFIFOCount();\n      }\n\n      mpu.getFIFOBytes(fifoBuffer, packetSize);\n\n      fifoCount -= packetSize;\n\n      Quaternion qtn; // [w, x, y, z]\n      mpu.dmpGetQuaternion(&qtn, fifoBuffer);\n      Serial.print(\"quat\\t\");\n      Serial.print(qtn.w);      \n      Serial.print(\"\\t\");\n      Serial.print(qtn.x);      \n      Serial.print(\"\\t\");\n      Serial.print(qtn.y);      \n      Serial.print(\"\\t\");\n      Serial.println(qtn.z);      \n  }\n}\n```\n\n## \u5f15\u3063\u304b\u304b\u3063\u305f\u70b9\n\n### FIFO overflow\nfifoCount\u3068\u3044\u3046\u5909\u6570\u306f\u307b\u3068\u3093\u3069loop()\u5185\u3067\u3057\u304b\u4f7f\u7528\u3057\u3066\u3044\u306a\u3044\u306e\u3067\u3001loop()\u5185\u3067\u306e\u5ba3\u8a00\u3092\u8a66\u3057\u305f\u3002\n\n```c\nvoid loop() {\n  uint8_t mpuIntStatus;\n  uint8_t fifoBuffer[64];\n  uint16_t fifoCount; // \n```\n\n\u3059\u308b\u3068\u3001FIFO overflow\u304c\u767a\u751f\u3059\u308b\u3088\u3046\u306b\u306a\u3063\u3066\u3057\u307e\u3063\u305f\u306e\u3067\u3001\u30d5\u30a1\u30a4\u30eb\u30b9\u30b3\u30fc\u30d7\u3067\u306e\u5ba3\u8a00\u306b\u623b\u3057\u305f\u3002\n\nFIFO overflow\u767a\u751f\u6642\u306efifoCount\u306f512\u3060\u3063\u305f\u3002mpuIntStatus\u306e0x10\u304c\u7acb\u3063\u3066\u3044\u308b\u3088\u3046\u3060\u304c\u3001\u3088\u304f\u5206\u304b\u3089\u306a\u3044\u72b6\u6cc1\u3060\u3002\n\n### mpu.testConnection() Fail\n\nmpu.testConnection()\u306e\u7d50\u679c\u304cFail\u3068\u306a\u308b\u3002\n\u5143\u306e\u30b5\u30f3\u30d7\u30eb\u30b9\u30b1\u30c3\u30c1\u3067\u3082Fail\u3068\u306a\u3063\u3066\u3044\u308b\u3002\n\n\n\n", "tags": ["borgSensorSystem1", "DMP", "todo"]}