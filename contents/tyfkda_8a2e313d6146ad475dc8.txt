{"context": " More than 1 year has passed since last update.Lisp/Scheme\u306e\u6e96\u30af\u30a9\u30fc\u30c8\u306e\u5c55\u958b\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0\u306f Quasiquotation in Lisp \u306eAppendix A \u306b\u66f8\u304b\u308c\u3066\u3044\u308b\u3002\u3067\u751f\u6210\u3055\u308c\u308b\u5c55\u958b\u30b3\u30fc\u30c9\u306f\u52b9\u679c\u7684\u3058\u3083\u306a\u3044\u3001\u6700\u9069\u5316\u3055\u308c\u305f\u3082\u306e\u304c \"Common Lisp the Language, 2nd Edition\" \u306e Appendix C. Backquote \u306b\u8f09\u3063\u3066\u3044\u308b\u3001\u3068\u3082\u66f8\u304b\u308c\u3066\u3044\u308b\u3002\n\u3053\u308c\u3092Scheme(Gauche)\u3067\u52d5\u304b\u3057\u3066\u307f\u308b\u3002\n;;; Common Lisp backquote implementation, written in Common Lisp.\n;;; Author: Guy L. Steele Jr.  Date: 27 December 1985\n;;; Tested under Symbolics Common Lisp and Lucid Common Lisp.\n;;; This software is in the public domain.\n\n;;; $ is pseudo-backquote and % is pseudo-comma. This makes it\n;;; possible to test this code without interfering with normal\n;;; Common Lisp syntax.\n\n;;; The following are unique tokens used during processing.\n;;; They need not be symbols; they need not even be atoms.\n\n(define *bq-clobberable* (gensym))\n(define *bq-quote-nil* (list 'quote ()))\n\n;;; Reader macro characters:\n;;;   $foo is read in as (BACKQUOTE foo)\n;;;   %foo is read in as (#:COMMA foo)\n;;;   %@foo is read in as (#:COMMA-ATSIGN foo)\n;;;   %.foo is read in as (#:COMMA-DOT foo)\n;;; where #:COMMA is the value of the variable *COMMA*, etc.\n\n;;; BACKQUOTE is an ordinary macro (not a read-macro) that\n;;; processes the expression foo, looking for occurrences of\n;;; #:COMMA, #:COMMA-ATSIGN, and #:COMMA-DOT. It constructs code\n;;; in strict accordance with the rules on pages 349-350 of\n;;; the first edition (pages 528-529 of this second edition).\n;;; It then optionally applies a code simplifier.\n\n;(set-macro-character #\\`\n;  (lambda (stream char)\n;     ;(declare (ignore char))\n;     (list 'quasiquote (read stream))))\n;\n;(set-macro-character #\\,\n;  (lambda (stream char)\n;     ;(declare (ignore char))\n;     (let1 c (read-char stream)\n;       (case c\n;         (#\\@\n;          (list 'unquote-splicing (read stream)))\n;         (#\\.\n;          (list 'unquote-dot (read stream)))\n;         (t (unread-char c stream)\n;            (list 'unquote (read stream)))))))\n\n;;; If the value of *BQ-SIMPLIFY* is non-NIL, then BACKQUOTE\n;;; processing applies the code simplifier. If the value is NIL,\n;;; then the code resulting from BACKQUOTE is exactly that\n;;; specified by the official rules.\n\n(define-macro (quasiquote x)\n  (bq-completely-process x))\n\n;;; Backquote processing proceeds in three stages:\n;;;\n;;; (1) BQ-PROCESS applies the rules to remove occurrences of\n;;; #:COMMA, #:COMMA-ATSIGN, and #:COMMA-DOT corresponding to\n;;; this level of BACKQUOTE. (It also causes embedded calls to\n;;; BACKQUOTE to be expanded so that nesting is properly handled.)\n;;; Code is produced that is expressed in terms of functions\n;;; #:BQ-LIST, #:BQ-APPEND, and #:BQ-CLOBBERABLE. This is done\n;;; so that the simplifier will simplify only list construction\n;;; functions actually generated by BACKQUOTE and will not involve\n;;; any user code in the simplification. #:BQ-LIST means LIST,\n;;; #:BQ-APPEND means APPEND, and #:BQ-CLOBBERABLE means IDENTITY\n;;; but indicates places where \"%.\" was used and where NCONC may\n;;; therefore be introduced by the simplifier for efficiency.\n;;;\n;;; (2) BQ-SIMPLIFY, if used, rewrites the code produced by\n;;; BQ-PROCESS to produce equivalent but faster code. The\n;;; additional functions #:BQ-LIST* and #:BQ-NCONC may be\n;;; introduced into the code.\n;;;\n;;; (3) BQ-REMOVE-TOKENS goes through the code and replaces\n;;; #:BQ-LIST with LIST, #:BQ-APPEND with APPEND, and so on.\n;;; #:BQ-CLOBBERABLE is simply eliminated (a call to it being\n;;; replaced by its argument). #:BQ-LIST* is replaced by either\n;;; LIST* or CONS (the latter is used in the two-argument case,\n;;; purely to make the resulting code a tad more readable).\n\n(define (bq-completely-process x)\n  (bq-simplify (bq-process x)))\n\n(define (bq-process x)\n  (cond ((not (pair? x))\n         (list 'quote x))\n        ((eq? (car x) 'quasiquote)\n         (bq-process (bq-completely-process (cadr x))))\n        ((eq? (car x) 'unquote) (cadr x))\n        ((eq? (car x) 'unquote-splicing)\n         (error \",@~S after `\" (cadr x)))\n        ((eq? (car x) 'unquote-dot)\n         (error \",.~S after `\" (cadr x)))\n        (else (let loop ((p x)\n                         (q '()))\n             (if (not (pair? p))\n                 (cons 'append\n                       (nreconc q (list (list 'quote p))))\n               (if (eq? (car p) 'unquote)\n                   (begin (unless (null? (cddr p)) (error \"Malformed ,~S\" p))\n                          (cons 'append\n                                (nreconc q (list (cadr p)))))\n                 (begin (when (eq? (car p) 'unquote-splicing)\n                          (error \"Dotted ,@~S\" p))\n                        (when (eq? (car p) 'unquote-dot)\n                          (error \"Dotted ,.~S\" p))\n                        (loop (cdr p)\n                              (cons (bracket (car p)) q)))))))))\n\n;;; This implements the bracket operator of the formal rules.\n\n(define (bracket x)\n  (cond ((not (pair? x))\n         (list 'list (bq-process x)))\n        ((eq? (car x) 'unquote)\n         (list 'list (cadr x)))\n        ((eq? (car x) 'unquote-splicing)\n         (cadr x))\n        ((eq? (car x) 'unquote-dot)\n         (list *bq-clobberable* (cadr x)))\n        (else (list 'list (bq-process x)))))\n\n;;; This auxiliary function is like MAPCAR but has two extra\n;;; purposes: (1) it handles dotted lists; (2) it tries to make\n;;; the result share with the argument x as much as possible.\n\n(define (maptree fn x)\n  (if (not (pair? x))\n      (fn x)\n    (let ((a (fn (car x)))\n          (d (maptree fn (cdr x))))\n      (if (and (equal? a (car x)) (equal? d (cdr x)))\n          x\n        (cons a d)))))\n\n;;; This predicate is true of a form that when read looked\n;;; like %@foo or %.foo.\n\n(define (bq-splicing-frob x)\n  (and (pair? x)\n       (or (eq? (car x) 'unquote-splicing)\n           (eq? (car x) 'unquote-dot))))\n\n;;; This predicate is true of a form that when read\n;;; loocked like %@foo or %.foo or just place %foo.\n\n(define (bq-frob x)\n  (and (pair? x)\n       (or (eq? (car x) 'unquote)\n           (eq? (car x) 'unquote-splicing)\n           (eq? (car x) 'unquote-dot))))\n\n;;; The simplifier essentially looks for calls to #:BQ-APPEND and\n;;; tries to simplify them. The arguments to #:BQ-APPEND are\n;;; processed from right to left, building up a replacement form.\n;;; At each step a number of special cases are handled that,\n;;; loosely speaking, look like this:\n;;;\n;;; (APPEND (LIST a b c) foo) U> (LIST* a b c foo)\n;;;     provided a, b, c are not splicing frobs\n;;; (APPEND (LIST* a b c) foo) U> (LIST* a b (APPEND c foo))\n;;;     provided a, b, c are not splicing frobs\n;;; (APPEND (QUOTE (x)) foo) U> (LIST* (QUOTE x) foo)\n;;; (APPEND (CLOBBERABLE x) foo) U> (NCONC x foo)\n\n(define (bq-simplify x)\n  (if (pair? x)\n      (let ((x (if (eq? (car x) 'quote)\n                   x\n                 (maptree bq-simplify x))))\n        (if (not (eq? (car x) 'append))\n            x\n          (bq-simplify-args x)))\n    x))\n\n(define (bq-simplify-args x)\n  (let loop ((args (reverse (cdr x)))\n             (result '()))\n    (if (not (null? args))\n        (loop (cdr args)\n              (cond ((not (pair? (car args)))\n                     (bq-attach-append 'append (car args) result))\n                    ((and (eq? (caar args) 'list)\n                          (not (any bq-splicing-frob (cdar args))))\n                     (bq-attach-conses (cdar args) result))\n                    ((and (eq? (caar args) 'list*)\n                          (not (any bq-splicing-frob (cdar args))))\n                     (bq-attach-conses\n                      (reverse (cdr (reverse (cdar args))))\n                      (bq-attach-append 'append\n                                        (car (last (car args)))\n                                        result)))\n                    ((and (eq? (caar args) 'quote)\n                          (pair? (cadar args))\n                          (not (bq-frob (cadar args)))\n                          (not (cddar args)))\n                     (bq-attach-conses (list (list 'quote\n                                                   (caadar args)))\n                                       result))\n                    ((eq? (caar args) *bq-clobberable*)\n                     (bq-attach-append 'append! (cadar args) result))\n                    (else (bq-attach-append 'append\n                                            (car args)\n                                            result))))\n      result)))\n\n(define (null-or-quoted x)\n  (or (null? x) (and (pair? x) (eq? (car x) 'quote))))\n\n;;; When BQ-ATTACH-APPEND is called, the OP should be #:BQ-APPEND\n;;; or #:BQ-NCONC. This produces a form (op item result) but\n;;; some simplifications are done on the fly:\n;;;\n;;; (op '(a b c) '(d e f g)) U> '(a b c d e f g)\n;;; (op item 'nil) U> item, provided item is not a splicable frob\n;;; (op item \u2019nil) U>(op item), if item is a splicable frob\n;;; (op item (op a b c)) U> (op item a b c)\n\n(define (bq-attach-append op item result)\n  (cond ((and (null-or-quoted item) (null-or-quoted result))\n         (list 'quote (append (safe-cadr item) (safe-cadr result))))\n        ((or (null? result) (equal? result *bq-quote-nil*))\n         (if (bq-splicing-frob item) (list op item) item))\n        ((and (pair? result) (eq? (car result) op))\n         (list* (car result) item (cdr result)))\n        (else (list op item result))))\n\n;;; The effect of BQ-ATTACH-CONSES is to produce a form as if by\n;;; `(LIST* ,@items ,result) but some simplifications are done\n;;; on the fly.\n;;;\n;;; (LIST* 'a 'b 'c 'd) U> '(a b c . d)\n;;; (LIST* a b c 'nil) U> (LIST a b c)\n;;; (LIST* a b c (list* d e f g)) U> (LIST* a b c d e f g)\n;;; (LIST* a b c (list d e f g)) U> (LIST a b c d e f g)\n\n(define (bq-attach-conses items result)\n  (cond ((and (every null-or-quoted items)\n              (null-or-quoted result))\n         (list 'quote\n               (append (map cadr items) (cadr result))))\n        ((or (null? result) (equal? result *bq-quote-nil*))\n         (cons 'list items))\n        ((and (pair? result)\n              (or (eq? (car result) 'list)\n                  (eq? (car result) 'list*)))\n         (cons (car result) (append items (cdr result))))\n        (else (cons 'list* (append items (list result))))))\n\n\n\u30ea\u30fc\u30c0\u30fc\u30de\u30af\u30ed\u306e\u8fba\u308a\u306f\u30b3\u30e1\u30f3\u30c8\u30a2\u30a6\u30c8\u3057\u305f\n\u5143\u306e\u30b3\u30fc\u30c9\u3067\u306f backquote, comma, comma-atsign, comma-dot \u3068\u3044\u3046\u540d\u524d\u3060\u304c\u3001Scheme\u98a8\u306b quasiquote, unquote, unquote-splicing, unquote-dot \u3068\u5909\u66f4\u3057\u305f\n\u5143\u306e\u30b3\u30fc\u30c9\u3067\u306f\u3044\u3063\u305f\u3093\u8b58\u5225\u7528\u306e\u30b7\u30f3\u30dc\u30eb\u3092\u57cb\u3081\u8fbc\u3093\u3067\u5f8c\u3067\u5909\u63db\u3057\u3066\u3044\u308b\u304c\u3001\u6700\u521d\u304b\u3089\u57cb\u3081\u8fbc\u3080\u3088\u3046\u306b\u3057\u305f\n\ndo \u30eb\u30fc\u30d7\u3092\u4f7f\u7528\u3057\u3066\u3044\u305f\u3068\u3053\u308d\u3092named-let\u306b\u3088\u308b\u30eb\u30fc\u30d7\u306b\u5909\u66f4\nCommon Lisp\u3067\u306f\u5f53\u7136\u306a\u304c\u3089 nil \u3092\u30ea\u30b9\u30c8\u306e\u7d42\u7aef\u3068 false \u306e\u4e21\u65b9\u306e\u610f\u5473\u3067\u4f7f\u3046\u3051\u3069\u3001Scheme\u3067\u306f\u4f7f\u3044\u5206\u3051\u306a\u3044\u3068\u3044\u3051\u306a\u3044\n\n\u5fc5\u8981\u306a\u30d8\u30eb\u30d1\u30fc\u95a2\u6570\uff1a\n;; Reverse list and concatenate tail destructively.\n(define (nreconc ls tail)\n  (let1 top (reverse! ls)\n    (set-cdr! ls tail)\n    top))\n\n(define (safe-car x)\n  (if (null? x)\n      '()\n    (car x)))\n(define (safe-cdr x)\n  (if (null? x)\n      '()\n    (cdr x)))\n(define (safe-cadr x)  (safe-car (safe-cdr x)))\n\n\n\nnreconc \u306f\u30ea\u30b9\u30c8\u3092\u3072\u3063\u304f\u308a\u8fd4\u3057\u3066\u3001\u305d\u306e\u672b\u5c3e\u306b\u8ffd\u52a0\u3059\u308b\u95a2\u6570\n\n\n\u3053\u3093\u306a\u95a2\u6570\u304c\u3042\u308b\u3053\u3068\u304c\u9a5a\u304d\u3060\u2026\n\n\nCommon Lisp\u3067\u306f car \u3084 cdr \u306b nil \u3092\u6e21\u3059\u3068 nil \u304c\u8fd4\u308b\u3051\u3069\u3001Scheme\u3067\u306f\u30a8\u30e9\u30fc\u304c\u767a\u751f\u3059\u308b\u306e\u3067\u3001nil \u30c1\u30a7\u30c3\u30af\u3092\u3059\u308b\u3082\u306e\u3092\u7528\u610f\u3057\u3066\u3084\u308b\n\n\u52d5\u4f5c\u3092\u8a66\u3057\u3066\u307f\u308b\u306b\u306f\n(print (bq-completely-process '(x ,y ,@z)))\n;; => (list* 'x y z)\n\n\u306a\u3069\u3002\nLisp/Scheme\u306e\u6e96\u30af\u30a9\u30fc\u30c8\u306e\u5c55\u958b\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0\u306f [Quasiquotation in Lisp](http://repository.readscheme.org/ftp/papers/pepm99/bawden.pdf) \u306eAppendix A \u306b\u66f8\u304b\u308c\u3066\u3044\u308b\u3002\u3067\u751f\u6210\u3055\u308c\u308b\u5c55\u958b\u30b3\u30fc\u30c9\u306f\u52b9\u679c\u7684\u3058\u3083\u306a\u3044\u3001\u6700\u9069\u5316\u3055\u308c\u305f\u3082\u306e\u304c \"Common Lisp the Language, 2nd Edition\" \u306e [Appendix C. Backquote](http://www.cs.cmu.edu/Groups/AI/html/cltl/clm/node367.html) \u306b\u8f09\u3063\u3066\u3044\u308b\u3001\u3068\u3082\u66f8\u304b\u308c\u3066\u3044\u308b\u3002\n\n\u3053\u308c\u3092Scheme(Gauche)\u3067\u52d5\u304b\u3057\u3066\u307f\u308b\u3002\n\n```scm\n;;; Common Lisp backquote implementation, written in Common Lisp.\n;;; Author: Guy L. Steele Jr.  Date: 27 December 1985\n;;; Tested under Symbolics Common Lisp and Lucid Common Lisp.\n;;; This software is in the public domain.\n\n;;; $ is pseudo-backquote and % is pseudo-comma. This makes it\n;;; possible to test this code without interfering with normal\n;;; Common Lisp syntax.\n\n;;; The following are unique tokens used during processing.\n;;; They need not be symbols; they need not even be atoms.\n\n(define *bq-clobberable* (gensym))\n(define *bq-quote-nil* (list 'quote ()))\n\n;;; Reader macro characters:\n;;;   $foo is read in as (BACKQUOTE foo)\n;;;   %foo is read in as (#:COMMA foo)\n;;;   %@foo is read in as (#:COMMA-ATSIGN foo)\n;;;   %.foo is read in as (#:COMMA-DOT foo)\n;;; where #:COMMA is the value of the variable *COMMA*, etc.\n\n;;; BACKQUOTE is an ordinary macro (not a read-macro) that\n;;; processes the expression foo, looking for occurrences of\n;;; #:COMMA, #:COMMA-ATSIGN, and #:COMMA-DOT. It constructs code\n;;; in strict accordance with the rules on pages 349-350 of\n;;; the first edition (pages 528-529 of this second edition).\n;;; It then optionally applies a code simplifier.\n\n;(set-macro-character #\\`\n;  (lambda (stream char)\n;     ;(declare (ignore char))\n;     (list 'quasiquote (read stream))))\n;\n;(set-macro-character #\\,\n;  (lambda (stream char)\n;     ;(declare (ignore char))\n;     (let1 c (read-char stream)\n;       (case c\n;         (#\\@\n;          (list 'unquote-splicing (read stream)))\n;         (#\\.\n;          (list 'unquote-dot (read stream)))\n;         (t (unread-char c stream)\n;            (list 'unquote (read stream)))))))\n\n;;; If the value of *BQ-SIMPLIFY* is non-NIL, then BACKQUOTE\n;;; processing applies the code simplifier. If the value is NIL,\n;;; then the code resulting from BACKQUOTE is exactly that\n;;; specified by the official rules.\n\n(define-macro (quasiquote x)\n  (bq-completely-process x))\n\n;;; Backquote processing proceeds in three stages:\n;;;\n;;; (1) BQ-PROCESS applies the rules to remove occurrences of\n;;; #:COMMA, #:COMMA-ATSIGN, and #:COMMA-DOT corresponding to\n;;; this level of BACKQUOTE. (It also causes embedded calls to\n;;; BACKQUOTE to be expanded so that nesting is properly handled.)\n;;; Code is produced that is expressed in terms of functions\n;;; #:BQ-LIST, #:BQ-APPEND, and #:BQ-CLOBBERABLE. This is done\n;;; so that the simplifier will simplify only list construction\n;;; functions actually generated by BACKQUOTE and will not involve\n;;; any user code in the simplification. #:BQ-LIST means LIST,\n;;; #:BQ-APPEND means APPEND, and #:BQ-CLOBBERABLE means IDENTITY\n;;; but indicates places where \"%.\" was used and where NCONC may\n;;; therefore be introduced by the simplifier for efficiency.\n;;;\n;;; (2) BQ-SIMPLIFY, if used, rewrites the code produced by\n;;; BQ-PROCESS to produce equivalent but faster code. The\n;;; additional functions #:BQ-LIST* and #:BQ-NCONC may be\n;;; introduced into the code.\n;;;\n;;; (3) BQ-REMOVE-TOKENS goes through the code and replaces\n;;; #:BQ-LIST with LIST, #:BQ-APPEND with APPEND, and so on.\n;;; #:BQ-CLOBBERABLE is simply eliminated (a call to it being\n;;; replaced by its argument). #:BQ-LIST* is replaced by either\n;;; LIST* or CONS (the latter is used in the two-argument case,\n;;; purely to make the resulting code a tad more readable).\n\n(define (bq-completely-process x)\n  (bq-simplify (bq-process x)))\n\n(define (bq-process x)\n  (cond ((not (pair? x))\n         (list 'quote x))\n        ((eq? (car x) 'quasiquote)\n         (bq-process (bq-completely-process (cadr x))))\n        ((eq? (car x) 'unquote) (cadr x))\n        ((eq? (car x) 'unquote-splicing)\n         (error \",@~S after `\" (cadr x)))\n        ((eq? (car x) 'unquote-dot)\n         (error \",.~S after `\" (cadr x)))\n        (else (let loop ((p x)\n                         (q '()))\n             (if (not (pair? p))\n                 (cons 'append\n                       (nreconc q (list (list 'quote p))))\n               (if (eq? (car p) 'unquote)\n                   (begin (unless (null? (cddr p)) (error \"Malformed ,~S\" p))\n                          (cons 'append\n                                (nreconc q (list (cadr p)))))\n                 (begin (when (eq? (car p) 'unquote-splicing)\n                          (error \"Dotted ,@~S\" p))\n                        (when (eq? (car p) 'unquote-dot)\n                          (error \"Dotted ,.~S\" p))\n                        (loop (cdr p)\n                              (cons (bracket (car p)) q)))))))))\n\n;;; This implements the bracket operator of the formal rules.\n\n(define (bracket x)\n  (cond ((not (pair? x))\n         (list 'list (bq-process x)))\n        ((eq? (car x) 'unquote)\n         (list 'list (cadr x)))\n        ((eq? (car x) 'unquote-splicing)\n         (cadr x))\n        ((eq? (car x) 'unquote-dot)\n         (list *bq-clobberable* (cadr x)))\n        (else (list 'list (bq-process x)))))\n\n;;; This auxiliary function is like MAPCAR but has two extra\n;;; purposes: (1) it handles dotted lists; (2) it tries to make\n;;; the result share with the argument x as much as possible.\n\n(define (maptree fn x)\n  (if (not (pair? x))\n      (fn x)\n    (let ((a (fn (car x)))\n          (d (maptree fn (cdr x))))\n      (if (and (equal? a (car x)) (equal? d (cdr x)))\n          x\n        (cons a d)))))\n\n;;; This predicate is true of a form that when read looked\n;;; like %@foo or %.foo.\n\n(define (bq-splicing-frob x)\n  (and (pair? x)\n       (or (eq? (car x) 'unquote-splicing)\n           (eq? (car x) 'unquote-dot))))\n\n;;; This predicate is true of a form that when read\n;;; loocked like %@foo or %.foo or just place %foo.\n\n(define (bq-frob x)\n  (and (pair? x)\n       (or (eq? (car x) 'unquote)\n           (eq? (car x) 'unquote-splicing)\n           (eq? (car x) 'unquote-dot))))\n\n;;; The simplifier essentially looks for calls to #:BQ-APPEND and\n;;; tries to simplify them. The arguments to #:BQ-APPEND are\n;;; processed from right to left, building up a replacement form.\n;;; At each step a number of special cases are handled that,\n;;; loosely speaking, look like this:\n;;;\n;;; (APPEND (LIST a b c) foo) U> (LIST* a b c foo)\n;;;     provided a, b, c are not splicing frobs\n;;; (APPEND (LIST* a b c) foo) U> (LIST* a b (APPEND c foo))\n;;;     provided a, b, c are not splicing frobs\n;;; (APPEND (QUOTE (x)) foo) U> (LIST* (QUOTE x) foo)\n;;; (APPEND (CLOBBERABLE x) foo) U> (NCONC x foo)\n\n(define (bq-simplify x)\n  (if (pair? x)\n      (let ((x (if (eq? (car x) 'quote)\n                   x\n                 (maptree bq-simplify x))))\n        (if (not (eq? (car x) 'append))\n            x\n          (bq-simplify-args x)))\n    x))\n\n(define (bq-simplify-args x)\n  (let loop ((args (reverse (cdr x)))\n             (result '()))\n    (if (not (null? args))\n        (loop (cdr args)\n              (cond ((not (pair? (car args)))\n                     (bq-attach-append 'append (car args) result))\n                    ((and (eq? (caar args) 'list)\n                          (not (any bq-splicing-frob (cdar args))))\n                     (bq-attach-conses (cdar args) result))\n                    ((and (eq? (caar args) 'list*)\n                          (not (any bq-splicing-frob (cdar args))))\n                     (bq-attach-conses\n                      (reverse (cdr (reverse (cdar args))))\n                      (bq-attach-append 'append\n                                        (car (last (car args)))\n                                        result)))\n                    ((and (eq? (caar args) 'quote)\n                          (pair? (cadar args))\n                          (not (bq-frob (cadar args)))\n                          (not (cddar args)))\n                     (bq-attach-conses (list (list 'quote\n                                                   (caadar args)))\n                                       result))\n                    ((eq? (caar args) *bq-clobberable*)\n                     (bq-attach-append 'append! (cadar args) result))\n                    (else (bq-attach-append 'append\n                                            (car args)\n                                            result))))\n      result)))\n\n(define (null-or-quoted x)\n  (or (null? x) (and (pair? x) (eq? (car x) 'quote))))\n\n;;; When BQ-ATTACH-APPEND is called, the OP should be #:BQ-APPEND\n;;; or #:BQ-NCONC. This produces a form (op item result) but\n;;; some simplifications are done on the fly:\n;;;\n;;; (op '(a b c) '(d e f g)) U> '(a b c d e f g)\n;;; (op item 'nil) U> item, provided item is not a splicable frob\n;;; (op item \u2019nil) U>(op item), if item is a splicable frob\n;;; (op item (op a b c)) U> (op item a b c)\n\n(define (bq-attach-append op item result)\n  (cond ((and (null-or-quoted item) (null-or-quoted result))\n         (list 'quote (append (safe-cadr item) (safe-cadr result))))\n        ((or (null? result) (equal? result *bq-quote-nil*))\n         (if (bq-splicing-frob item) (list op item) item))\n        ((and (pair? result) (eq? (car result) op))\n         (list* (car result) item (cdr result)))\n        (else (list op item result))))\n\n;;; The effect of BQ-ATTACH-CONSES is to produce a form as if by\n;;; `(LIST* ,@items ,result) but some simplifications are done\n;;; on the fly.\n;;;\n;;; (LIST* 'a 'b 'c 'd) U> '(a b c . d)\n;;; (LIST* a b c 'nil) U> (LIST a b c)\n;;; (LIST* a b c (list* d e f g)) U> (LIST* a b c d e f g)\n;;; (LIST* a b c (list d e f g)) U> (LIST a b c d e f g)\n\n(define (bq-attach-conses items result)\n  (cond ((and (every null-or-quoted items)\n              (null-or-quoted result))\n         (list 'quote\n               (append (map cadr items) (cadr result))))\n        ((or (null? result) (equal? result *bq-quote-nil*))\n         (cons 'list items))\n        ((and (pair? result)\n              (or (eq? (car result) 'list)\n                  (eq? (car result) 'list*)))\n         (cons (car result) (append items (cdr result))))\n        (else (cons 'list* (append items (list result))))))\n```\n\n* \u30ea\u30fc\u30c0\u30fc\u30de\u30af\u30ed\u306e\u8fba\u308a\u306f\u30b3\u30e1\u30f3\u30c8\u30a2\u30a6\u30c8\u3057\u305f\n* \u5143\u306e\u30b3\u30fc\u30c9\u3067\u306f `backquote`, `comma`, `comma-atsign`, `comma-dot` \u3068\u3044\u3046\u540d\u524d\u3060\u304c\u3001Scheme\u98a8\u306b `quasiquote`, `unquote`, `unquote-splicing`, `unquote-dot` \u3068\u5909\u66f4\u3057\u305f\n* \u5143\u306e\u30b3\u30fc\u30c9\u3067\u306f\u3044\u3063\u305f\u3093\u8b58\u5225\u7528\u306e\u30b7\u30f3\u30dc\u30eb\u3092\u57cb\u3081\u8fbc\u3093\u3067\u5f8c\u3067\u5909\u63db\u3057\u3066\u3044\u308b\u304c\u3001\u6700\u521d\u304b\u3089\u57cb\u3081\u8fbc\u3080\u3088\u3046\u306b\u3057\u305f\n* `do` \u30eb\u30fc\u30d7\u3092\u4f7f\u7528\u3057\u3066\u3044\u305f\u3068\u3053\u308d\u3092named-let\u306b\u3088\u308b\u30eb\u30fc\u30d7\u306b\u5909\u66f4\n* Common Lisp\u3067\u306f\u5f53\u7136\u306a\u304c\u3089 `nil` \u3092\u30ea\u30b9\u30c8\u306e\u7d42\u7aef\u3068 `false` \u306e\u4e21\u65b9\u306e\u610f\u5473\u3067\u4f7f\u3046\u3051\u3069\u3001Scheme\u3067\u306f\u4f7f\u3044\u5206\u3051\u306a\u3044\u3068\u3044\u3051\u306a\u3044\n\n\n\u5fc5\u8981\u306a\u30d8\u30eb\u30d1\u30fc\u95a2\u6570\uff1a\n\n```scm\n;; Reverse list and concatenate tail destructively.\n(define (nreconc ls tail)\n  (let1 top (reverse! ls)\n    (set-cdr! ls tail)\n    top))\n\n(define (safe-car x)\n  (if (null? x)\n      '()\n    (car x)))\n(define (safe-cdr x)\n  (if (null? x)\n      '()\n    (cdr x)))\n(define (safe-cadr x)  (safe-car (safe-cdr x)))\n```\n\n* [nreconc](http://clhs.lisp.se/Body/f_revapp.htm#nreconc) \u306f\u30ea\u30b9\u30c8\u3092\u3072\u3063\u304f\u308a\u8fd4\u3057\u3066\u3001\u305d\u306e\u672b\u5c3e\u306b\u8ffd\u52a0\u3059\u308b\u95a2\u6570\n  * \u3053\u3093\u306a\u95a2\u6570\u304c\u3042\u308b\u3053\u3068\u304c\u9a5a\u304d\u3060\u2026\n* Common Lisp\u3067\u306f `car` \u3084 `cdr` \u306b `nil` \u3092\u6e21\u3059\u3068 `nil` \u304c\u8fd4\u308b\u3051\u3069\u3001Scheme\u3067\u306f\u30a8\u30e9\u30fc\u304c\u767a\u751f\u3059\u308b\u306e\u3067\u3001`nil` \u30c1\u30a7\u30c3\u30af\u3092\u3059\u308b\u3082\u306e\u3092\u7528\u610f\u3057\u3066\u3084\u308b\n\n\n\u52d5\u4f5c\u3092\u8a66\u3057\u3066\u307f\u308b\u306b\u306f\n\n```scm\n(print (bq-completely-process '(x ,y ,@z)))\n;; => (list* 'x y z)\n```\n\n\u306a\u3069\u3002\n", "tags": ["Scheme"]}