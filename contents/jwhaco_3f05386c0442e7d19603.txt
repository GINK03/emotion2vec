{"tags": ["Scala", "sbt0.13.13"], "context": "\n\n\u3053\u306e\u8a18\u4e8b\u3092\u8aad\u3080\u3068\u5206\u304b\u308b\u3053\u3068\n\n\u8907\u6570\u500b\u306e\u5165\u529b\u3092\u53d7\u3051\u4ed8\u3051\u308b sbt \u30bf\u30b9\u30af\u306e\u4f5c\u308a\u65b9\n\u9078\u629e\u6e08\u307f\u306e\u5019\u88dc\u304c\u88dc\u5b8c\u304b\u3089\u9664\u304b\u308c\u3066\u3044\u304f sbt \u30d1\u30fc\u30b5\u306e\u4f5c\u308a\u65b9\n\u88dc\u5b8c\u306e\u4e00\u89a7\u304b\u3089\u6b63\u898f\u8868\u73fe\u3067\u5019\u88dc\u3092\u9078\u629e\u3067\u304d\u308b sbt \u30d1\u30fc\u30b5\u306e\u4f5c\u308a\u65b9\n\n\n\u5c0e\u5165\n\u307e\u305a\u306f\u6700\u5c0f\u69cb\u6210\u306e\u30d7\u30ed\u30b8\u30a7\u30af\u30c8\u3092\u7528\u610f\n\nbuild.sbt\nlazy val root = project.settings(HelloSettings.task)\n\n\n\u30bf\u30d6\u88dc\u5b8c\u3092\u8a66\u3059\u305f\u3081\u306e\u30e2\u30b8\u30e5\u30fc\u30eb\u3082\u5b9a\u7fa9\n\nproject/HelloSettings.scala\nimport sbt.Def\nimport sbt.Def.inputKey\nimport sbt.Keys.streams\n\nobject HelloSettings {\n  lazy val hello = inputKey[Unit](\"hello, parser\")\n\n  def task = hello := {\n    println(\"selected items..\")\n\n    val items = Def.setting(sampleParser).parsed\n    items foreach println\n  }\n  private def sampleParser: Parser[Seq[String]] = ???\n}\n\n\n\u3053\u306e Parser[Seq[String]] = ??? \u3092\u3044\u3044\u611f\u3058\u306b\u4f5c\u308a\u4e0a\u3052\u308b\u306e\u304c\u4eca\u56de\u306e\u4e3b\u65e8\u3067\u3059\n\n\u516c\u5f0f\u30c9\u30ad\u30e5\u30e1\u30f3\u30c8\u306e\u8aad\u89e3\n\u82e5\u5e72\u4e0d\u89aa\u5207\u306a\u304c\u3089\u3082\u3001\u76ee\u7684\u306e\u30d1\u30fc\u30b5\u306b\u8fd1\u3044\u30b3\u30fc\u30c9 (Dependent parsers) \u304c\u7533\u3057\u308f\u3051\u7a0b\u5ea6\u306b\u8a18\u8f09\u3055\u308c\u3066\u3044\u307e\u3059\n\u307b\u307c\u305d\u306e\u307e\u307e\u629c\u7c8b :\n\nproject/SampleParser.scala\nimport sbt.complete.DefaultParsers._\nimport sbt.complete.{FixedSetExamples, Parser}\n\nobject SampleParser {\n  def select1(items: Iterable[String]) =\n    token(Space ~> StringBasic.examples(FixedSetExamples(items)))\n\n  def selectSome(items: Seq[String]): Parser[Seq[String]] = {\n    select1(items).flatMap { v \u21d2\n      val remaining = items filter {\n        _ != v\n      }\n      if (remaining.size == 0)\n        success(v :: Nil)\n      else\n        selectSome(remaining).?.map(v +: _.getOrElse(Seq()))\n    }\n  }\n}\n\n\n\u5148\u306e\u5b9f\u88c5\u3092\u57cb\u3081\u308b\u3068\u3053\u3093\u306a\u611f\u3058\u3067\u3059\n\nproject/HelloSettings.scala\nprivate def sampleParser =\n  SampleParser selectSome Seq(\n    \"foo1.xml\",\n    \"foo2.xml\",\n    \"foo3.txt\",\n    \"bar1.yml\"\n  )\n\n\n\u8a66\u3057\u3066\u307f\u307e\u3057\u3087\u3046\n> hello\nbar1.yml   foo1.xml   foo2.xml   foo3.txt   \n> hello foo\nfoo1.xml   foo2.xml   foo3.txt   \n> hello foo1.xml foo\nfoo2.xml   foo3.txt   \n> hello foo1.xml foo2.xml\nselected items..\nfoo1.xml\nfoo2.xml\n\n\u3053\u306e\u307e\u307e\u3067\u3082\u4e00\u5fdc\n\n\u6307\u5b9a\u3057\u305f\u6587\u5b57\u5217\u306e\u307f\u304c\u5019\u88dc\u306b\u8868\u793a\u3055\u308c\u3066\n\u6700\u521d\u306b foo \u3092\u5165\u529b\u3059\u308b\u3068 foo \u3067\u59cb\u307e\u308b\u5019\u88dc\u306b\u7d5e\u3089\u308c\u3066\nfoo1.xml \u3092\u9078\u629e\u3059\u308b\u3068\u6b21\u304b\u3089\u306f foo1.xml \u304c\u5019\u88dc\u304b\u3089\u9664\u304b\u308c\u308b\n\n\u306e\u3067\u3001\u52d5\u4f5c\u306f\u6982\u306d\u554f\u984c\u306a\u3044\u3088\u3046\u306b\u3082\u898b\u3048\u307e\u3059\u304c\u2026\n> hello bazbazbaz\nselected items..\nbazbazbaz\n> hello .*xml\nselected items..\n.*xml\n\n\n\u4e00\u89a7\u306b\u306a\u3044\u4e0d\u6b63\u306a\u6587\u5b57\u5217\u3082\u8a31\u53ef\u3057\u3066\u3057\u307e\u3046\n\u8907\u6570\u500b\u306e .xml \u3092\u4e00\u5ea6\u306b\u9078\u629e\u3059\u308b\u3088\u3046\u306a\u3053\u3068\u306f\u3067\u304d\u306a\u3044\n\n\u3068\u3044\u3046\u70b9\u3067\u6b8b\u5ff5\u306a\u304c\u3089\u4f7f\u3044\u52dd\u624b\u306f\u30a4\u30de\u30a4\u30c1\u3067\u3059\n\n\u6307\u5b9a\u3057\u305f\u5019\u88dc\u306e\u307f\u3092\u8a31\u53ef\u3057\u305f\u3044\n\u3053\u3053\u307e\u3067\u3067\u5224\u660e\u3057\u3066\u3044\u308b\u3053\u3068 :\n\n\nflatMap \u306b\u3088\u3063\u3066\u300c\u9078\u629e\u3057\u305f\u6587\u5b57\u5217\u306b\u5fdc\u3058\u3066\u6b21\u306b\u30de\u30c3\u30c1\u3059\u308b\u6587\u5b57\u5217\u304c\u5909\u308f\u308b\u300d\u30d1\u30fc\u30b5\u3092\u5b9f\u73fe\u3067\u304d\u308b\n\ntoken \u3092 | \u3067\u3064\u306a\u3052\u308c\u3070\u8907\u6570\u306e\u5019\u88dc\u306b\u30de\u30c3\u30c1\u3059\u308b Parser[String] \u3092\u4f5c\u308c\u308b\n\n\nrf. Controlling tab completion\n\n\n\n\n\u3092\u62bc\u3055\u3048\u3066\u3042\u308c\u3070\u3042\u3068\u306f\u30b7\u30f3\u30d7\u30eb\u3067\u3059\n\nStrictParser.scala\nimport sbt.complete.DefaultParsers.{Space, failure, token}\nimport sbt.complete.Parser\n\nobject StrictParser {\n  def from(items: Seq[String]): Parser[Seq[String]] = {\n    new StrictParser(items).parser\n  }\n}\nclass StrictParser private (items: Seq[String]) {\n  private type Filter = String => Boolean\n\n  def parser: Parser[Seq[String]] = {\n    val fixed: Parser[Filter] = {\n      val base = items map (token(_)) reduceOption (_ | _)\n      base getOrElse failure(\"none\") map (item => _ == item)\n    }\n    (Space ~> fixed flatMap next) ?? Nil\n  }\n  private def next(filter: Filter): Parser[Seq[String]] = {\n    val (consumed, remains) = items partition filter\n    if (consumed.nonEmpty){\n      StrictParser from remains map (consumed ++ _)\n    } else {\n      failure(\"input not matched\")\n    }\n  }\n}\n\n\n\u4f7f\u3044\u65b9\u306f\u3055\u3063\u304d\u3068\u307b\u3068\u3093\u3069\u540c\u3058\u3067\u3059\n\nproject/HelloSettings.scala\nprivate def strictParser: Parser[Seq[String]] =\n  StrictParser from Seq(\n    \"foo1.xml\",\n    \"foo2.xml\",\n    \"foo3.txt\",\n    \"bar1.yml\"\n  )\n\n\n\u8a66\u3057\u3066\u307f\u307e\u3057\u3087\u3046\n> hello\nbar1.yml   foo1.xml   foo2.xml   foo3.txt   \n> hello foo\nfoo1.xml   foo2.xml   foo3.txt   \n> hello foo1.xml\nbar1.yml   foo2.xml   foo3.txt   \n> hello foo1.xml foo\nfoo2.xml   foo3.txt   \n> hello foo1.xml foo2.xml\nselected items..\nfoo1.xml\nfoo2.xml\n\n> hello foo1.xml foo2.xml bazbazbaz\n[error] Expected 'bar1.yml'\n[error] hello foo1.xml foo2.xml bazbazbaz\n[error]                           ^\n\n\u4e0d\u6b63\u306a\u6587\u5b57\u5217\u3092\u7121\u4e8b\u306b\u5f3e\u304f\u3053\u3068\u304c\u3067\u304d\u308b\u3088\u3046\u306b\u306a\u308a\u307e\u3057\u305f\n\n\u6b63\u898f\u8868\u73fe\u3067\u5019\u88dc\u3092\u9078\u629e\u3057\u305f\u3044\n\u4e0a\u8a18\u306e StrictParser \u306b\n\n\u6b63\u898f\u8868\u73fe\u3092\u53d7\u3051\u4ed8\u3051\u308b\u305f\u3081\u306b String#matches \u306b\u3088\u308b\u5224\u5b9a\u3092\u8ffd\u52a0\n\u305f\u3060\u3057\u4e0d\u6b63\u306a\u5165\u529b\u306b\u5bfe\u3057\u3066\u306f\u4f8b\u5916\u304c\u5410\u304b\u308c\u308b\u306e\u3067 Try \u3067\u6355\u6349\n\n\u3068\u3044\u3046\u5909\u66f4\u3092\u52a0\u3048\u308b\u3060\u3051\u3067\u6e08\u307f\u307e\u3059\n\nReductiveParser.scala\nimport sbt.complete.DefaultParsers.{NotSpace, Space, failure, token}\nimport sbt.complete.Parser\nimport scala.util.{Failure, Success, Try}\n\nobject ReductiveParser {\n  def from(items: Seq[String]): Parser[Seq[String]] = {\n    new ReductiveParser(items).parser\n  }\n}\nclass ReductiveParser private (items: Seq[String]) {\n  private type Filter = String => Boolean\n\n  def parser: Parser[Seq[String]] = {\n    val fixed: Parser[Filter] = {\n      val base = items map (token(_)) reduceOption (_ | _)\n      base getOrElse failure(\"none\") map (item => _ == item)\n    }\n    val manually: Parser[Filter] = {\n      val base = NotSpace\n      base map (input => _ matches input)\n    }\n    (Space ~> (fixed | manually) flatMap next) ?? Nil\n  }\n  private def next(filter: Filter): Parser[Seq[String]] =\n    Try(items partition filter) match {\n      case Success((consumed, remains)) if consumed.nonEmpty =>\n        ReductiveParser from remains map (consumed ++ _)\n      case Success(_) =>\n        failure(\"input not matched\")\n      case Failure(e) =>\n        failure(s\"invalid input: ${e.getMessage}\")\n    }\n}\n\n\n\u8a66\u3057\u3066\u307f\u307e\u3057\u3087\u3046\n> hello .*xml\nbar1.yml   foo3.txt   \n> hello .*xml bar1.yml\nselected items..\nfoo1.xml\nfoo2.xml\nbar1.yml\n\n> hello .*1.* foo\nfoo2.xml   foo3.txt   \n> hello .*1.* foo2.xml\nselected items..\nfoo1.xml\nbar1.yml\nfoo2.xml\n\n\u6b63\u898f\u8868\u73fe\u306b\u3088\u3063\u3066\u9078\u629e\u3067\u304d\u308b\u3088\u3046\u306b\u306a\u308a\u307e\u3057\u305f\n> hello .*conf\n[error] input not matched\n[error] hello .*conf\n[error]             ^\n\n> hello (*)\n[error] invalid input: Dangling meta character '*' near index 1\n[error] (*)\n[error]  ^\n\n\u4e0d\u6b63\u306a\u5165\u529b\u3082\u554f\u984c\u306a\u304f\u691c\u51fa\u3067\u304d\u3066\u3044\u307e\u3059\n\u3081\u3067\u305f\u3057\u3081\u3067\u305f\u3057\n\n\u7d42\u308f\u308a\n\u5099\u8003\n\n\u52d5\u4f5c\u78ba\u8a8d\u30b3\u30fc\u30c9\u306e\u7f6e\u304d\u5834\u6240 : github.com - Cliche/scala/sbt-teal\n\n\n## \u3053\u306e\u8a18\u4e8b\u3092\u8aad\u3080\u3068\u5206\u304b\u308b\u3053\u3068\n\n* \u8907\u6570\u500b\u306e\u5165\u529b\u3092\u53d7\u3051\u4ed8\u3051\u308b sbt \u30bf\u30b9\u30af\u306e\u4f5c\u308a\u65b9\n* \u9078\u629e\u6e08\u307f\u306e\u5019\u88dc\u304c\u88dc\u5b8c\u304b\u3089\u9664\u304b\u308c\u3066\u3044\u304f sbt \u30d1\u30fc\u30b5\u306e\u4f5c\u308a\u65b9\n* \u88dc\u5b8c\u306e\u4e00\u89a7\u304b\u3089\u6b63\u898f\u8868\u73fe\u3067\u5019\u88dc\u3092\u9078\u629e\u3067\u304d\u308b sbt \u30d1\u30fc\u30b5\u306e\u4f5c\u308a\u65b9\n\n## \u5c0e\u5165\n\n\u307e\u305a\u306f\u6700\u5c0f\u69cb\u6210\u306e\u30d7\u30ed\u30b8\u30a7\u30af\u30c8\u3092\u7528\u610f\n\n```build.sbt\nlazy val root = project.settings(HelloSettings.task)\n```\n\n\u30bf\u30d6\u88dc\u5b8c\u3092\u8a66\u3059\u305f\u3081\u306e\u30e2\u30b8\u30e5\u30fc\u30eb\u3082\u5b9a\u7fa9\n\n```project/HelloSettings.scala\nimport sbt.Def\nimport sbt.Def.inputKey\nimport sbt.Keys.streams\n\nobject HelloSettings {\n  lazy val hello = inputKey[Unit](\"hello, parser\")\n\n  def task = hello := {\n    println(\"selected items..\")\n\n    val items = Def.setting(sampleParser).parsed\n    items foreach println\n  }\n  private def sampleParser: Parser[Seq[String]] = ???\n}\n``` \n\n\u3053\u306e `Parser[Seq[String]] = ???` \u3092\u3044\u3044\u611f\u3058\u306b\u4f5c\u308a\u4e0a\u3052\u308b\u306e\u304c\u4eca\u56de\u306e\u4e3b\u65e8\u3067\u3059\n\n## \u516c\u5f0f\u30c9\u30ad\u30e5\u30e1\u30f3\u30c8\u306e\u8aad\u89e3\n\n\u82e5\u5e72\u4e0d\u89aa\u5207\u306a\u304c\u3089\u3082\u3001\u76ee\u7684\u306e\u30d1\u30fc\u30b5\u306b\u8fd1\u3044\u30b3\u30fc\u30c9 ([Dependent parsers](http://www.scala-sbt.org/0.13/docs/Parsing-Input.html#Dependent+parsers)) \u304c\u7533\u3057\u308f\u3051\u7a0b\u5ea6\u306b\u8a18\u8f09\u3055\u308c\u3066\u3044\u307e\u3059\n\n\u307b\u307c\u305d\u306e\u307e\u307e\u629c\u7c8b :\n\n```project/SampleParser.scala\nimport sbt.complete.DefaultParsers._\nimport sbt.complete.{FixedSetExamples, Parser}\n\nobject SampleParser {\n  def select1(items: Iterable[String]) =\n    token(Space ~> StringBasic.examples(FixedSetExamples(items)))\n\n  def selectSome(items: Seq[String]): Parser[Seq[String]] = {\n    select1(items).flatMap { v \u21d2\n      val remaining = items filter {\n        _ != v\n      }\n      if (remaining.size == 0)\n        success(v :: Nil)\n      else\n        selectSome(remaining).?.map(v +: _.getOrElse(Seq()))\n    }\n  }\n}\n``` \n\n\u5148\u306e\u5b9f\u88c5\u3092\u57cb\u3081\u308b\u3068\u3053\u3093\u306a\u611f\u3058\u3067\u3059\n\n```project/HelloSettings.scala\nprivate def sampleParser =\n  SampleParser selectSome Seq(\n    \"foo1.xml\",\n    \"foo2.xml\",\n    \"foo3.txt\",\n    \"bar1.yml\"\n  )\n```\n\n\u8a66\u3057\u3066\u307f\u307e\u3057\u3087\u3046\n\n```\n> hello\nbar1.yml   foo1.xml   foo2.xml   foo3.txt   \n> hello foo\nfoo1.xml   foo2.xml   foo3.txt   \n> hello foo1.xml foo\nfoo2.xml   foo3.txt   \n> hello foo1.xml foo2.xml\nselected items..\nfoo1.xml\nfoo2.xml\n```\n\n\u3053\u306e\u307e\u307e\u3067\u3082\u4e00\u5fdc\n\n* \u6307\u5b9a\u3057\u305f\u6587\u5b57\u5217\u306e\u307f\u304c\u5019\u88dc\u306b\u8868\u793a\u3055\u308c\u3066\n* \u6700\u521d\u306b foo \u3092\u5165\u529b\u3059\u308b\u3068 foo \u3067\u59cb\u307e\u308b\u5019\u88dc\u306b\u7d5e\u3089\u308c\u3066\n* foo1.xml \u3092\u9078\u629e\u3059\u308b\u3068\u6b21\u304b\u3089\u306f foo1.xml \u304c\u5019\u88dc\u304b\u3089\u9664\u304b\u308c\u308b\n\n\u306e\u3067\u3001\u52d5\u4f5c\u306f\u6982\u306d\u554f\u984c\u306a\u3044\u3088\u3046\u306b\u3082\u898b\u3048\u307e\u3059\u304c\u2026\n\n```\n> hello bazbazbaz\nselected items..\nbazbazbaz\n> hello .*xml\nselected items..\n.*xml\n```\n\n* \u4e00\u89a7\u306b\u306a\u3044\u4e0d\u6b63\u306a\u6587\u5b57\u5217\u3082\u8a31\u53ef\u3057\u3066\u3057\u307e\u3046\n* \u8907\u6570\u500b\u306e .xml \u3092\u4e00\u5ea6\u306b\u9078\u629e\u3059\u308b\u3088\u3046\u306a\u3053\u3068\u306f\u3067\u304d\u306a\u3044\n\n\u3068\u3044\u3046\u70b9\u3067\u6b8b\u5ff5\u306a\u304c\u3089\u4f7f\u3044\u52dd\u624b\u306f\u30a4\u30de\u30a4\u30c1\u3067\u3059\n\n## \u6307\u5b9a\u3057\u305f\u5019\u88dc\u306e\u307f\u3092\u8a31\u53ef\u3057\u305f\u3044\n\n\u3053\u3053\u307e\u3067\u3067\u5224\u660e\u3057\u3066\u3044\u308b\u3053\u3068 :\n\n* `flatMap` \u306b\u3088\u3063\u3066\u300c\u9078\u629e\u3057\u305f\u6587\u5b57\u5217\u306b\u5fdc\u3058\u3066\u6b21\u306b\u30de\u30c3\u30c1\u3059\u308b\u6587\u5b57\u5217\u304c\u5909\u308f\u308b\u300d\u30d1\u30fc\u30b5\u3092\u5b9f\u73fe\u3067\u304d\u308b\n* `token` \u3092 ` | ` \u3067\u3064\u306a\u3052\u308c\u3070\u8907\u6570\u306e\u5019\u88dc\u306b\u30de\u30c3\u30c1\u3059\u308b `Parser[String]` \u3092\u4f5c\u308c\u308b\n  * rf. [Controlling tab completion](http://www.scala-sbt.org/0.13/docs/Parsing-Input.html#Controlling+tab+completion)\n\n\u3092\u62bc\u3055\u3048\u3066\u3042\u308c\u3070\u3042\u3068\u306f\u30b7\u30f3\u30d7\u30eb\u3067\u3059\n\n```StrictParser.scala\nimport sbt.complete.DefaultParsers.{Space, failure, token}\nimport sbt.complete.Parser\n\nobject StrictParser {\n  def from(items: Seq[String]): Parser[Seq[String]] = {\n    new StrictParser(items).parser\n  }\n}\nclass StrictParser private (items: Seq[String]) {\n  private type Filter = String => Boolean\n\n  def parser: Parser[Seq[String]] = {\n    val fixed: Parser[Filter] = {\n      val base = items map (token(_)) reduceOption (_ | _)\n      base getOrElse failure(\"none\") map (item => _ == item)\n    }\n    (Space ~> fixed flatMap next) ?? Nil\n  }\n  private def next(filter: Filter): Parser[Seq[String]] = {\n    val (consumed, remains) = items partition filter\n    if (consumed.nonEmpty){\n      StrictParser from remains map (consumed ++ _)\n    } else {\n      failure(\"input not matched\")\n    }\n  }\n}\n```\n\n\u4f7f\u3044\u65b9\u306f\u3055\u3063\u304d\u3068\u307b\u3068\u3093\u3069\u540c\u3058\u3067\u3059\n\n```project/HelloSettings.scala\nprivate def strictParser: Parser[Seq[String]] =\n  StrictParser from Seq(\n    \"foo1.xml\",\n    \"foo2.xml\",\n    \"foo3.txt\",\n    \"bar1.yml\"\n  )\n```\n\n\u8a66\u3057\u3066\u307f\u307e\u3057\u3087\u3046\n\n```\n> hello\nbar1.yml   foo1.xml   foo2.xml   foo3.txt   \n> hello foo\nfoo1.xml   foo2.xml   foo3.txt   \n> hello foo1.xml\nbar1.yml   foo2.xml   foo3.txt   \n> hello foo1.xml foo\nfoo2.xml   foo3.txt   \n> hello foo1.xml foo2.xml\nselected items..\nfoo1.xml\nfoo2.xml\n\n> hello foo1.xml foo2.xml bazbazbaz\n[error] Expected 'bar1.yml'\n[error] hello foo1.xml foo2.xml bazbazbaz\n[error]                           ^\n```\n\n\u4e0d\u6b63\u306a\u6587\u5b57\u5217\u3092\u7121\u4e8b\u306b\u5f3e\u304f\u3053\u3068\u304c\u3067\u304d\u308b\u3088\u3046\u306b\u306a\u308a\u307e\u3057\u305f\n\n## \u6b63\u898f\u8868\u73fe\u3067\u5019\u88dc\u3092\u9078\u629e\u3057\u305f\u3044\n\n\u4e0a\u8a18\u306e `StrictParser` \u306b\n\n* \u6b63\u898f\u8868\u73fe\u3092\u53d7\u3051\u4ed8\u3051\u308b\u305f\u3081\u306b `String#matches` \u306b\u3088\u308b\u5224\u5b9a\u3092\u8ffd\u52a0\n* \u305f\u3060\u3057\u4e0d\u6b63\u306a\u5165\u529b\u306b\u5bfe\u3057\u3066\u306f\u4f8b\u5916\u304c\u5410\u304b\u308c\u308b\u306e\u3067 `Try` \u3067\u6355\u6349\n\n\u3068\u3044\u3046\u5909\u66f4\u3092\u52a0\u3048\u308b\u3060\u3051\u3067\u6e08\u307f\u307e\u3059\n\n```ReductiveParser.scala\nimport sbt.complete.DefaultParsers.{NotSpace, Space, failure, token}\nimport sbt.complete.Parser\nimport scala.util.{Failure, Success, Try}\n\nobject ReductiveParser {\n  def from(items: Seq[String]): Parser[Seq[String]] = {\n    new ReductiveParser(items).parser\n  }\n}\nclass ReductiveParser private (items: Seq[String]) {\n  private type Filter = String => Boolean\n\n  def parser: Parser[Seq[String]] = {\n    val fixed: Parser[Filter] = {\n      val base = items map (token(_)) reduceOption (_ | _)\n      base getOrElse failure(\"none\") map (item => _ == item)\n    }\n    val manually: Parser[Filter] = {\n      val base = NotSpace\n      base map (input => _ matches input)\n    }\n    (Space ~> (fixed | manually) flatMap next) ?? Nil\n  }\n  private def next(filter: Filter): Parser[Seq[String]] =\n    Try(items partition filter) match {\n      case Success((consumed, remains)) if consumed.nonEmpty =>\n        ReductiveParser from remains map (consumed ++ _)\n      case Success(_) =>\n        failure(\"input not matched\")\n      case Failure(e) =>\n        failure(s\"invalid input: ${e.getMessage}\")\n    }\n}\n```\n\n\u8a66\u3057\u3066\u307f\u307e\u3057\u3087\u3046\n\n```\n> hello .*xml\nbar1.yml   foo3.txt   \n> hello .*xml bar1.yml\nselected items..\nfoo1.xml\nfoo2.xml\nbar1.yml\n\n> hello .*1.* foo\nfoo2.xml   foo3.txt   \n> hello .*1.* foo2.xml\nselected items..\nfoo1.xml\nbar1.yml\nfoo2.xml\n```\n\n\u6b63\u898f\u8868\u73fe\u306b\u3088\u3063\u3066\u9078\u629e\u3067\u304d\u308b\u3088\u3046\u306b\u306a\u308a\u307e\u3057\u305f\n\n```\n> hello .*conf\n[error] input not matched\n[error] hello .*conf\n[error]             ^\n\n> hello (*)\n[error] invalid input: Dangling meta character '*' near index 1\n[error] (*)\n[error]  ^\n```\n\n\u4e0d\u6b63\u306a\u5165\u529b\u3082\u554f\u984c\u306a\u304f\u691c\u51fa\u3067\u304d\u3066\u3044\u307e\u3059\n\u3081\u3067\u305f\u3057\u3081\u3067\u305f\u3057\n\n## \u7d42\u308f\u308a\n\n\u5099\u8003\n\n* \u52d5\u4f5c\u78ba\u8a8d\u30b3\u30fc\u30c9\u306e\u7f6e\u304d\u5834\u6240 : [github.com - Cliche/scala/sbt-teal](https://github.com/x7c1/Cliche/tree/master/scala/sbt-teal)\n"}