{"context": " More than 1 year has passed since last update.Gauche \u306e CLOS, MOP, define-macro \u3092\u4f7f\u3063\u3066 Perl \u306e moose \u7684 TypeSafe Scheme OOP \u3092\u3084\u3063\u3066\u307f\u308b\nSee also\nhttp://voqn.blogspot.com/2011/09/type-safe-metaclass-for-gauche-mop.html\n\nmop.scm\n(define-class <type-safe-meta> (<class>) (()))\n\n(define-method compute-get-n-set ((class <type-safe-meta>) slot)\n  (let* ((has? (cut slot-definition-option slot <> #f))\n      (acc (compute-slot-accessor class slot (next-method)))\n      (type-error\n       (^ (value type)\n         (error\n          #`\"Type Error : require type ,|type| but ,(class-of value)\"\n          value)))\n      (validate-type\n       (^v (if-let1 t (has? :is-a)\n        (if (is-a? v t) v (type-error v t))\n        v)))\n      (validate-value\n       (^v (if-let1 validate (has? :validate) (validate v) v)))\n      (filter-value\n       (^v (if-let1 f (has? :filter) (f v) v))))\n    (if (or (has? :is-a) (has? :validate) (has? :filter))\n    (let1 filter/validate (.$ filter-value validate-value validate-type)\n      (list (^ (o) (slot-ref-using-accessor o acc))\n        (^ (o v) (slot-set-using-accessor! o acc (filter/validate v)))\n        (^ (o) (slot-bound-using-accessor? o acc))\n        #t))\n    (next-method))))\n\n\n\nmacro.scm\n(define-macro (define-class* name supers slots . options)\n  `(define-class ,name ,supers\n     ,(map (^s (let ((has? (cut get-keyword <> <> #f))\n             (key (car s))\n             (accessor (^ (k a) (string->symbol #`\",|k|-,|a|\")))\n             (rest (cdr s)))\n         (let1 compl (^ (k i)\n                   (if (has? k rest) '()\n                   (list k i)))\n           `(,key\n             ,@(compl :init-value (make-init-value rest))\n             ,@(compl :init-keyword (make-keyword key))\n             ,@(compl :getter (accessor key 'of))\n             ,@(if (or (has? :setter rest)\n                   (has? :read-only rest)) '()\n                   (list :setter (accessor key 'set!)))\n             ,@rest))))\n       slots)\n     ,@options))\n\n(define (make-init-value key-list)\n  (let1 has? (cut get-keyword <> key-list #f)\n    (if-let1 t\n         (has? :is-a)\n         (case t\n           ((<number> <complex> <real> <integer>) 0)\n           ((<string>) \"\")\n           ((<boolean>) #f)\n           ((<list>) '())\n           ((<vector>) '#())\n           (else (make t)))\n         (undefined))))\n\n\n\nexample.scm\n(define (loop-mod$ max) \n  (^x ((^v (if (= v (floor v)) (x->integer v) v))\n       (cond ((<= max x) (fmod x max))\n             ((> 0 x) (fmod (+ x max) max))\n             (else x)))))\n\n(define (inner$ min max) (cut clamp min <> max))\n\n(define-class* <hsl> (<color>)\n  ((hue :is-a <real> :filter (loop-mod$ 360))\n   (saturation :is-a <real> :filter (inner$ 0 1))\n   (luminance :is-a <real> :filter (inner$ 0 1))))\n\n\nGauche \u306e CLOS, MOP, define-macro \u3092\u4f7f\u3063\u3066 Perl \u306e moose \u7684 TypeSafe Scheme OOP \u3092\u3084\u3063\u3066\u307f\u308b\nSee also\nhttp://voqn.blogspot.com/2011/09/type-safe-metaclass-for-gauche-mop.html\n\n``` scheme:mop.scm\n(define-class <type-safe-meta> (<class>) (()))\n\n(define-method compute-get-n-set ((class <type-safe-meta>) slot)\n  (let* ((has? (cut slot-definition-option slot <> #f))\n\t  (acc (compute-slot-accessor class slot (next-method)))\n\t  (type-error\n\t   (^ (value type)\n\t     (error\n\t      #`\"Type Error : require type ,|type| but ,(class-of value)\"\n\t      value)))\n\t  (validate-type\n\t   (^v (if-let1 t (has? :is-a)\n\t\t(if (is-a? v t) v (type-error v t))\n\t\tv)))\n\t  (validate-value\n\t   (^v (if-let1 validate (has? :validate) (validate v) v)))\n\t  (filter-value\n\t   (^v (if-let1 f (has? :filter) (f v) v))))\n    (if (or (has? :is-a) (has? :validate) (has? :filter))\n\t(let1 filter/validate (.$ filter-value validate-value validate-type)\n\t  (list (^ (o) (slot-ref-using-accessor o acc))\n\t\t(^ (o v) (slot-set-using-accessor! o acc (filter/validate v)))\n\t\t(^ (o) (slot-bound-using-accessor? o acc))\n\t\t#t))\n\t(next-method))))\n```\n\n``` scheme:macro.scm\n(define-macro (define-class* name supers slots . options)\n  `(define-class ,name ,supers\n     ,(map (^s (let ((has? (cut get-keyword <> <> #f))\n\t\t     (key (car s))\n\t\t     (accessor (^ (k a) (string->symbol #`\",|k|-,|a|\")))\n\t\t     (rest (cdr s)))\n\t\t (let1 compl (^ (k i)\n\t\t\t       (if (has? k rest) '()\n\t\t\t\t   (list k i)))\n\t\t   `(,key\n\t\t     ,@(compl :init-value (make-init-value rest))\n\t\t     ,@(compl :init-keyword (make-keyword key))\n\t\t     ,@(compl :getter (accessor key 'of))\n\t\t     ,@(if (or (has? :setter rest)\n\t\t\t       (has? :read-only rest)) '()\n\t\t\t       (list :setter (accessor key 'set!)))\n\t\t     ,@rest))))\n\t   slots)\n     ,@options))\n\n(define (make-init-value key-list)\n  (let1 has? (cut get-keyword <> key-list #f)\n    (if-let1 t\n\t     (has? :is-a)\n\t     (case t\n\t       ((<number> <complex> <real> <integer>) 0)\n\t       ((<string>) \"\")\n\t       ((<boolean>) #f)\n\t       ((<list>) '())\n\t       ((<vector>) '#())\n\t       (else (make t)))\n\t     (undefined))))\n```\n\n\n``` scheme:example.scm\n(define (loop-mod$ max) \n  (^x ((^v (if (= v (floor v)) (x->integer v) v))\n       (cond ((<= max x) (fmod x max))\n\t         ((> 0 x) (fmod (+ x max) max))\n\t         (else x)))))\n\n(define (inner$ min max) (cut clamp min <> max))\n\n(define-class* <hsl> (<color>)\n  ((hue :is-a <real> :filter (loop-mod$ 360))\n   (saturation :is-a <real> :filter (inner$ 0 1))\n   (luminance :is-a <real> :filter (inner$ 0 1))))\n```", "tags": ["Scheme"]}