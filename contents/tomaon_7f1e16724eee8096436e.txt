{"context": " More than 1 year has passed since last update.\u4ee5\u524d\u8a66\u3057\u305f\u969b\u3001\u4f7f\u3044\u65b9\u304c\u308f\u304b\u3089\u305a\u653e\u7f6e\u3057\u305fenif_open_resource_type/6\u3092eleveldb\u306b\u767a\u898b\u3001\u8a66\u3057\u3066\u307f\u305f\u3002\n\u3067\u3082\u3001\u3001\u306a\u306b\u304b\u304a\u304b\u3057\u3044\u3002\n\nnif.erl\n-module(nif).\n\n%% -- public --\n-export([on_load/0]).\n-export([open/1, close/1]).\n\n%% == public ==\n\n-on_load(on_load/0).\n\n-spec on_load() -> ok|{error,_}.\non_load() ->\n    Path = filename:join([lib_dir(?MODULE), ?MODULE_STRING]),\n    LoadInfo = [],\n    erlang:load_nif(Path, LoadInfo).\n\n\n-spec open(integer()) -> {ok,binary()}|{error,_}.\nopen(Id)\n  when is_integer(Id) ->\n    erlang:nif_error(not_loaded).\n\n-spec close(binary()) -> ok|{error,_}.\nclose(Resource)\n  when is_binary(Resource) ->\n    erlang:nif_error(not_loaded).\n\n%% == private ==\n\nlib_dir(Application) ->\n    filename:join(lib_dir(Application,priv), \"lib\").\n\nlib_dir(Application, SubDir) ->\n    case code:lib_dir(Application, SubDir) of\n        {error, bad_name} ->\n            {ok, Dir} = file:get_cwd(),\n            filename:join(Dir, atom_to_list(SubDir));\n        Dir ->\n            Dir\n    end.\n\n\n\nnif.c\n#include <stdio.h>\n#include <errno.h>\n\n#include \"erl_nif.h\"\n\n#define UNUSED(p) (void)(p)\n\n// -- --\n\ntypedef struct {\n  int id;\n} nif_t;\n\n// -- --\n\nstatic ERL_NIF_TERM open(ErlNifEnv *env, int argc, const ERL_NIF_TERM *argv) {\n\n  ErlNifResourceType *resource_type = (ErlNifResourceType *)enif_priv_data(env);\n\n  if (1 == argc &&\n      enif_is_number(env, argv[0])) {\n\n    int id = 0;\n    enif_get_int(env, argv[0], &id);\n\n    nif_t *resource = (nif_t *)enif_alloc_resource(resource_type, sizeof(nif_t));\n\n    if (NULL != resource) {\n\n      resource->id = id;\n\n      printf(\"open, resource=%ld, id=%d\\r\\n\", (long)resource, resource->id);\n\n      return enif_make_tuple2(env,\n                              enif_make_atom(env, \"ok\"),\n                              enif_make_resource(env, resource));\n    } else {\n\n      return enif_make_tuple2(env,\n                              enif_make_atom(env, \"error\"),\n                              enif_make_string(env, \"enomem\", ERL_NIF_LATIN1));\n    }\n  }\n\n  return enif_make_badarg(env);\n}\n\nstatic ERL_NIF_TERM close(ErlNifEnv *env, int argc, const ERL_NIF_TERM *argv) {\n\n  ErlNifResourceType *resource_type = (ErlNifResourceType *)enif_priv_data(env);\n\n  if (1 == argc) {\n\n    nif_t *resource = NULL;\n\n    if (enif_get_resource(env, argv[0], resource_type, (void **)&resource)) {\n\n      printf(\"close, resource=%ld, id=%d\\r\\n\", (long)resource, resource->id);\n\n      enif_release_resource(resource);\n      resource = NULL;\n\n      return enif_make_atom(env, \"ok\");\n    }\n  }\n\n  return enif_make_badarg(env);\n}\n\n// -- --\n\nvoid dtor(ErlNifEnv* env, void* obj) {\n\n  UNUSED(env);\n\n  nif_t *resource = (nif_t *)obj;\n\n  printf(\"dtor, resource=%ld, id=%d\\r\\n\", (long)resource, resource->id);\n}\n\n// -- --\n\nstatic ErlNifFunc funcs[] = {\n  {\"open\", 1, open},\n  {\"close\", 1, close},\n};\n\nstatic int load(ErlNifEnv *env, void **priv_data, ERL_NIF_TERM load_info) {\n\n  UNUSED(env), UNUSED(load_info);\n\n  ErlNifResourceType *resource_type =\n    enif_open_resource_type(env, NULL, \"nif_t\", dtor, ERL_NIF_RT_CREATE, NULL);\n\n  if (NULL == resource_type) {\n    return ENOMEM;\n  }\n\n  *priv_data = resource_type;\n\n  return 0;\n}\n\n/*\n */\nERL_NIF_INIT(nif, funcs, load, NULL, NULL, NULL);\n\n\nErlang R16B03-1 (erts-5.10.4) [source] [64-bit] [smp:4:4] [async-threads:10] [hipe] [kernel-poll:false] [dtrace]\n\nEshell V5.10.4  (abort with ^G)\n1> {ok,B1} = nif:open(123).\nopen, resource=487329320, id=123\n{ok,<<>>}\n2> nif:close(B1).\nclose, resource=487329320, id=123\nok\n3> {ok,B2} = nif:open(456).\nopen, resource=487326352, id=456\n{ok,<<>>}\n4> nif:close(B2).\nclose, resource=487326352, id=456\nok\n5> garbage_collect().\ntrue\n6> q(). \nok\n7> dtor, resource=487326352, id=456\ndtor, resource=487329320, id=123\n\nenif_make_resource/2\u3057\u3066\u3057\u307e\u3046\u3068 dtor \u306f\u547c\u3070\u308c\u306a\u3044\u3002\nnif \u3092 unload \u3059\u308b\u4ed5\u7d44\u307f\u306f\u306a\u3044\uff1f\u304b\u3089\u3001\u3001\n\u3069\u3046\u3059\u308c\u3070\u3044\u3044\u306e\u3084\u3089\u3002\n\n\u8ffd\u8a18\uff1a shell \u3067\u306e binding \u3092\u5fd8\u308c\u3066\u307e\u3057\u305f\u3002\u3002 \nErlang R16B03-1 (erts-5.10.4) [source] [64-bit] [smp:4:4] [async-threads:10] [hipe] [kernel-poll:false] [dtrace]\n\nEshell V5.10.4  (abort with ^G)\n1> F = fun() -> {ok,B} = nif:open(123), nif:close(B) end,\n1> F().\nopen, resource=520883752, id=123\nclose, resource=520883752, id=123\nok\n2> erlang:garbage_collect().\ndtor, resource=520883752, id=123\ntrue\n3> q().\nok\n\n\n\n\u4ee5\u524d[\u8a66\u3057\u305f\u969b](https://github.com/tomaon/embstring)\u3001\u4f7f\u3044\u65b9\u304c\u308f\u304b\u3089\u305a\u653e\u7f6e\u3057\u305f[enif_open_resource_type/6](http://www.erlang.org/doc/man/erl_nif.html#enif_open_resource_type)\u3092[eleveldb](https://github.com/basho/eleveldb/blob/develop/c_src/workitems.cc)\u306b\u767a\u898b\u3001\u8a66\u3057\u3066\u307f\u305f\u3002\n\n\u3067\u3082\u3001\u3001\u306a\u306b\u304b\u304a\u304b\u3057\u3044\u3002\n\n```erlang:nif.erl\n-module(nif).\n\n%% -- public --\n-export([on_load/0]).\n-export([open/1, close/1]).\n\n%% == public ==\n\n-on_load(on_load/0).\n\n-spec on_load() -> ok|{error,_}.\non_load() ->\n    Path = filename:join([lib_dir(?MODULE), ?MODULE_STRING]),\n    LoadInfo = [],\n    erlang:load_nif(Path, LoadInfo).\n\n\n-spec open(integer()) -> {ok,binary()}|{error,_}.\nopen(Id)\n  when is_integer(Id) ->\n    erlang:nif_error(not_loaded).\n\n-spec close(binary()) -> ok|{error,_}.\nclose(Resource)\n  when is_binary(Resource) ->\n    erlang:nif_error(not_loaded).\n\n%% == private ==\n\nlib_dir(Application) ->\n    filename:join(lib_dir(Application,priv), \"lib\").\n\nlib_dir(Application, SubDir) ->\n    case code:lib_dir(Application, SubDir) of\n        {error, bad_name} ->\n            {ok, Dir} = file:get_cwd(),\n            filename:join(Dir, atom_to_list(SubDir));\n        Dir ->\n            Dir\n    end.\n```\n\n```cpp:nif.c\n#include <stdio.h>\n#include <errno.h>\n\n#include \"erl_nif.h\"\n\n#define UNUSED(p) (void)(p)\n\n// -- --\n\ntypedef struct {\n  int id;\n} nif_t;\n\n// -- --\n\nstatic ERL_NIF_TERM open(ErlNifEnv *env, int argc, const ERL_NIF_TERM *argv) {\n\n  ErlNifResourceType *resource_type = (ErlNifResourceType *)enif_priv_data(env);\n\n  if (1 == argc &&\n      enif_is_number(env, argv[0])) {\n\n    int id = 0;\n    enif_get_int(env, argv[0], &id);\n\n    nif_t *resource = (nif_t *)enif_alloc_resource(resource_type, sizeof(nif_t));\n\n    if (NULL != resource) {\n\n      resource->id = id;\n\n      printf(\"open, resource=%ld, id=%d\\r\\n\", (long)resource, resource->id);\n\n      return enif_make_tuple2(env,\n                              enif_make_atom(env, \"ok\"),\n                              enif_make_resource(env, resource));\n    } else {\n\n      return enif_make_tuple2(env,\n                              enif_make_atom(env, \"error\"),\n                              enif_make_string(env, \"enomem\", ERL_NIF_LATIN1));\n    }\n  }\n\n  return enif_make_badarg(env);\n}\n\nstatic ERL_NIF_TERM close(ErlNifEnv *env, int argc, const ERL_NIF_TERM *argv) {\n\n  ErlNifResourceType *resource_type = (ErlNifResourceType *)enif_priv_data(env);\n\n  if (1 == argc) {\n\n    nif_t *resource = NULL;\n\n    if (enif_get_resource(env, argv[0], resource_type, (void **)&resource)) {\n\n      printf(\"close, resource=%ld, id=%d\\r\\n\", (long)resource, resource->id);\n\n      enif_release_resource(resource);\n      resource = NULL;\n\n      return enif_make_atom(env, \"ok\");\n    }\n  }\n\n  return enif_make_badarg(env);\n}\n\n// -- --\n\nvoid dtor(ErlNifEnv* env, void* obj) {\n\n  UNUSED(env);\n\n  nif_t *resource = (nif_t *)obj;\n\n  printf(\"dtor, resource=%ld, id=%d\\r\\n\", (long)resource, resource->id);\n}\n\n// -- --\n\nstatic ErlNifFunc funcs[] = {\n  {\"open\", 1, open},\n  {\"close\", 1, close},\n};\n\nstatic int load(ErlNifEnv *env, void **priv_data, ERL_NIF_TERM load_info) {\n\n  UNUSED(env), UNUSED(load_info);\n\n  ErlNifResourceType *resource_type =\n    enif_open_resource_type(env, NULL, \"nif_t\", dtor, ERL_NIF_RT_CREATE, NULL);\n\n  if (NULL == resource_type) {\n    return ENOMEM;\n  }\n\n  *priv_data = resource_type;\n\n  return 0;\n}\n\n/*\n */\nERL_NIF_INIT(nif, funcs, load, NULL, NULL, NULL);\n```\n\n```erlang\nErlang R16B03-1 (erts-5.10.4) [source] [64-bit] [smp:4:4] [async-threads:10] [hipe] [kernel-poll:false] [dtrace]\n\nEshell V5.10.4  (abort with ^G)\n1> {ok,B1} = nif:open(123).\nopen, resource=487329320, id=123\n{ok,<<>>}\n2> nif:close(B1).\nclose, resource=487329320, id=123\nok\n3> {ok,B2} = nif:open(456).\nopen, resource=487326352, id=456\n{ok,<<>>}\n4> nif:close(B2).\nclose, resource=487326352, id=456\nok\n5> garbage_collect().\ntrue\n6> q(). \nok\n7> dtor, resource=487326352, id=456\ndtor, resource=487329320, id=123\n```\n[enif_make_resource/2](http://www.erlang.org/doc/man/erl_nif.html#enif_make_resource)\u3057\u3066\u3057\u307e\u3046\u3068 dtor \u306f\u547c\u3070\u308c\u306a\u3044\u3002\nnif \u3092 unload \u3059\u308b\u4ed5\u7d44\u307f\u306f\u306a\u3044\uff1f\u304b\u3089\u3001\u3001\n\n<s>\u3069\u3046\u3059\u308c\u3070\u3044\u3044\u306e\u3084\u3089\u3002</s>\n\n- - -\n\n\u8ffd\u8a18\uff1a shell \u3067\u306e binding \u3092\u5fd8\u308c\u3066\u307e\u3057\u305f\u3002\u3002 \n\n```erlang\nErlang R16B03-1 (erts-5.10.4) [source] [64-bit] [smp:4:4] [async-threads:10] [hipe] [kernel-poll:false] [dtrace]\n\nEshell V5.10.4  (abort with ^G)\n1> F = fun() -> {ok,B} = nif:open(123), nif:close(B) end,\n1> F().\nopen, resource=520883752, id=123\nclose, resource=520883752, id=123\nok\n2> erlang:garbage_collect().\ndtor, resource=520883752, id=123\ntrue\n3> q().\nok\n\n```\n", "tags": ["Erlang"]}