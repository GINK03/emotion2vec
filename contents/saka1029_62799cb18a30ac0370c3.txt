{"context": " More than 1 year has passed since last update.Dependency Algorithm - find a minimum set of packages to install\nRepresent the constraints.\nX : A&(E|C)\nA : E&(Y|N)\nE : B&(Z|Y)\nC : A|K\n\nPrepare two list target and result.\nAdd the node X to target.\ntarget = X, result=[]\n\nAdd single node X to the result.\nReplace node X with its dependent in the target.\ntarget = A&(E|C), result=[X]\n\nAdd single node A to result.\nReplace node A with its dependent in the target.\ntarget = E&(Y|N)&(E|C), result=[X, A]\n\nSingle node E must be true.\nSo (E|C) is always true.\nRemove it from the target.\ntarget = E&(Y|N), result=[X, A]\n\nAdd single node E to result.\nReplace node E with its dependent in the target.\ntarget = B&(Z|Y)&(Y|N), result=[X, A, E]\n\nAdd single node B to result.\nReplace node B with its dependent in the target.\ntarget = (Z|Y)&(Y|N), result=[X, A, E, B]\n\nThere are no single node any more.\nThen expand the target expression.\nexpanded = Z&Y|Z&N|Y&Y|Y&N\nY&Y equals to Y.\nexpanded = Z&Y|Z&N|Y|Y&N\n\nChoose the term that has smallest number of nodes.\nAdd all nodes in the term to the target.\ntarget = , result=[X, A, E, B, Y]\n\npackage stackoverflow.dependency;\n\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\n\npublic class Dependency {\n\n    public static class Node {\n        final String name;\n        final List<String> and = new ArrayList<>();\n        final List<String> or = new ArrayList<>();\n\n        Node(String name) {\n            this.name = name;\n        }\n\n        public Node and(String... and) {\n            for (String e : and)\n                this.and.add(e);\n            return this;\n        }\n\n        public Node or(String... or) {\n            for (String e : or)\n                this.or.add(e);\n            return this;\n        }\n\n        @Override\n        public String toString() {\n            return name + \" and\" + and + \" or\" + or;\n        }\n    }\n\n    final Map<String, Node> map = new HashMap<>();\n\n    public Node node(String name) {\n        Node node = map.get(name);\n        if (node == null)\n            map.put(name, node = new Node(name));\n        return node;\n    }\n\n    @Override\n    public String toString() {\n        StringBuilder sb = new StringBuilder();\n        for (Node e : map.values())\n            sb.append(e).append(\"\\n\");\n        return sb.toString();\n    }\n\n    public Node get(String name) {\n        return map.get(name);\n    }\n\n    static void expand(List<List<String>> targetOr, int index, List<String> set, List<Set<String>> expanded) {\n        int size = targetOr.size();\n        if (index >= size)\n            expanded.add(new HashSet<>(set));\n        else\n            for (String s : targetOr.get(index)) {\n                set.add(s);\n                expand(targetOr, index + 1, set, expanded);\n                set.remove(set.size() - 1);\n            }\n    }\n\n    public List<String> dependents(String start) {\n        List<String> targetAnd = new ArrayList<>();\n        List<List<String>> targetOr = new ArrayList<>();\n        List<String> result = new ArrayList<>();\n        targetAnd.add(start);\n        while (!targetAnd.isEmpty()) {\n            System.out.println(\"target=AND\" + targetAnd + \" OR\" + targetOr + \", result=\" + result);\n            String single = targetAnd.remove(0);\n            Node singleNode = get(single);\n            result.add(single);\n            for (Iterator<List<String>> i = targetOr.iterator(); i.hasNext(); )\n                if (i.next().contains(single))\n                    i.remove();\n            System.out.println(\"target=AND\" + targetAnd + \" OR\" + targetOr + \", result=\" + result);\n            targetAnd.addAll(singleNode.and);\n            if (singleNode.or.size() > 0)\n                targetOr.add(singleNode.or);\n        }\n        if (!targetOr.isEmpty()) {\n            List<Set<String>> expanded = new ArrayList<>();\n            expand(targetOr, 0, new ArrayList<>(), expanded);\n            System.out.println(\"expanded=OR\" + expanded);\n            int min = Integer.MAX_VALUE;\n            Set<String> minSet = null;\n            for (Set<String> set : expanded)\n                if (set.size() < min) {\n                    min = set.size();\n                    minSet = set;\n                }\n            result.addAll(minSet);\n        }\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Dependency d = new Dependency();\n        d.node(\"X\").and(\"A\").or(\"E\", \"C\");\n        d.node(\"E\").and(\"B\").or(\"Y\", \"Z\");\n        d.node(\"A\").and(\"E\").or(\"H\", \"Y\");\n        d.node(\"C\").or(\"A\", \"K\");\n        d.node(\"Z\");\n        d.node(\"B\");\n        d.node(\"H\");\n        d.node(\"K\");\n        System.out.println(d);\n        List<String> result = d.dependents(\"X\");\n        System.out.println(result);\n    }\n}\n\n\n\n[Dependency Algorithm - find a minimum set of packages to install](http://stackoverflow.com/questions/30429786/dependency-algorithm-find-a-minimum-set-of-packages-to-install/30565843#30565843)\n\nRepresent the constraints.\n\n```\nX : A&(E|C)\nA : E&(Y|N)\nE : B&(Z|Y)\nC : A|K\n```\n\nPrepare two list target and result.\nAdd the node X to target.\n\n```\ntarget = X, result=[]\n```\n\nAdd single node X to the result.\nReplace node X with its dependent in the target.\n\n```\ntarget = A&(E|C), result=[X]\n```\n\nAdd single node A to result.\nReplace node A with its dependent in the target.\n\n```\ntarget = E&(Y|N)&(E|C), result=[X, A]\n```\n\nSingle node E must be true.\nSo (E|C) is always true.\nRemove it from the target.\n\n```\ntarget = E&(Y|N), result=[X, A]\n```\n\nAdd single node E to result.\nReplace node E with its dependent in the target.\n\n```\ntarget = B&(Z|Y)&(Y|N), result=[X, A, E]\n```\n\nAdd single node B to result.\nReplace node B with its dependent in the target.\n\n```\ntarget = (Z|Y)&(Y|N), result=[X, A, E, B]\n```\n\nThere are no single node any more.\nThen expand the target expression.\n\nexpanded = Z&Y|Z&N|Y&Y|Y&N\n\nY&Y equals to Y.\n\n```\nexpanded = Z&Y|Z&N|Y|Y&N\n```\n\nChoose the term that has smallest number of nodes.\nAdd all nodes in the term to the target.\n\n```\ntarget = , result=[X, A, E, B, Y]\n```\n\n\n```java\npackage stackoverflow.dependency;\n\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\n\npublic class Dependency {\n\n\tpublic static class Node {\n\t\tfinal String name;\n\t\tfinal List<String> and = new ArrayList<>();\n\t\tfinal List<String> or = new ArrayList<>();\n\n\t\tNode(String name) {\n\t\t\tthis.name = name;\n\t\t}\n\n\t\tpublic Node and(String... and) {\n\t\t\tfor (String e : and)\n\t\t\t\tthis.and.add(e);\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic Node or(String... or) {\n\t\t\tfor (String e : or)\n\t\t\t\tthis.or.add(e);\n\t\t\treturn this;\n\t\t}\n\t\t\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn name + \" and\" + and + \" or\" + or;\n\t\t}\n\t}\n\n\tfinal Map<String, Node> map = new HashMap<>();\n\t\n\tpublic Node node(String name) {\n\t\tNode node = map.get(name);\n\t\tif (node == null)\n\t\t\tmap.put(name, node = new Node(name));\n\t\treturn node;\n\t}\n\t\n\t@Override\n\tpublic String toString() {\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor (Node e : map.values())\n\t\t\tsb.append(e).append(\"\\n\");\n\t\treturn sb.toString();\n\t}\n\n\tpublic Node get(String name) {\n\t\treturn map.get(name);\n\t}\n\n\tstatic void expand(List<List<String>> targetOr, int index, List<String> set, List<Set<String>> expanded) {\n\t\tint size = targetOr.size();\n\t\tif (index >= size)\n\t\t\texpanded.add(new HashSet<>(set));\n\t\telse\n\t\t\tfor (String s : targetOr.get(index)) {\n\t\t\t\tset.add(s);\n\t\t\t\texpand(targetOr, index + 1, set, expanded);\n\t\t\t\tset.remove(set.size() - 1);\n\t\t\t}\n\t}\n\n\tpublic List<String> dependents(String start) {\n\t\tList<String> targetAnd = new ArrayList<>();\n\t\tList<List<String>> targetOr = new ArrayList<>();\n\t\tList<String> result = new ArrayList<>();\n\t\ttargetAnd.add(start);\n        while (!targetAnd.isEmpty()) {\n            System.out.println(\"target=AND\" + targetAnd + \" OR\" + targetOr + \", result=\" + result);\n            String single = targetAnd.remove(0);\n            Node singleNode = get(single);\n            result.add(single);\n            for (Iterator<List<String>> i = targetOr.iterator(); i.hasNext(); )\n                if (i.next().contains(single))\n                    i.remove();\n            System.out.println(\"target=AND\" + targetAnd + \" OR\" + targetOr + \", result=\" + result);\n            targetAnd.addAll(singleNode.and);\n            if (singleNode.or.size() > 0)\n                targetOr.add(singleNode.or);\n        }\n        if (!targetOr.isEmpty()) {\n        \tList<Set<String>> expanded = new ArrayList<>();\n        \texpand(targetOr, 0, new ArrayList<>(), expanded);\n        \tSystem.out.println(\"expanded=OR\" + expanded);\n        \tint min = Integer.MAX_VALUE;\n        \tSet<String> minSet = null;\n        \tfor (Set<String> set : expanded)\n        \t\tif (set.size() < min) {\n        \t\t\tmin = set.size();\n        \t\t\tminSet = set;\n        \t\t}\n        \tresult.addAll(minSet);\n        }\n\t\treturn result;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tDependency d = new Dependency();\n\t\td.node(\"X\").and(\"A\").or(\"E\", \"C\");\n\t\td.node(\"E\").and(\"B\").or(\"Y\", \"Z\");\n\t\td.node(\"A\").and(\"E\").or(\"H\", \"Y\");\n\t\td.node(\"C\").or(\"A\", \"K\");\n\t\td.node(\"Z\");\n\t\td.node(\"B\");\n\t\td.node(\"H\");\n\t\td.node(\"K\");\n\t\tSystem.out.println(d);\n\t\tList<String> result = d.dependents(\"X\");\n\t\tSystem.out.println(result);\n\t}\n}\n\n```\n", "tags": ["Java", "StackOverflow"]}