{"context": " More than 1 year has passed since last update.Redis\u306e\u30ec\u30d7\u30ea\u30b1\u30fc\u30b7\u30e7\u30f3\u304c\u4f55\u3084\u3063\u3066\u308b\u306e\u304b\u8abf\u3079\u305f\u304b\u3063\u305f\u306e\u3067\u30bd\u30fc\u30b9\u8aad\u307f\u306a\u304c\u3089\u7ffb\u8a33\u3002\ndiff --git a/src/replication.c b/src/replication.c\nindex 9c1e1f0..b9812e7 100644\n--- a/src/replication.c\n+++ b/src/replication.c\n@@ -412,20 +412,20 @@ need_full_resync:\n\n /* SYNC ad PSYNC command implemenation. */\n void syncCommand(redisClient *c) {\n-    /* ignore SYNC if already slave or in monitor mode */\n+    /* \u3059\u3067\u306b\u30b9\u30ec\u30fc\u30d6\u307e\u305f\u306f\u30e2\u30cb\u30bf\u30e2\u30fc\u30c9\u306e\u5834\u5408\u306b\u306f\u3001SYNC\u3092\u7121\u8996\u3057\u307e\u3059\u3002 */\n     if (c->flags & REDIS_SLAVE) return;\n\n-    /* Refuse SYNC requests if we are a slave but the link with our master\n-     * is not ok... */\n+    /* \u3053\u306e\u30b5\u30fc\u30d0\u304c\u30b9\u30ec\u30fc\u30d6\u3067\u3001\u30de\u30b9\u30bf\u30fc\u3068\u306e\u30ea\u30f3\u30af\u304c\u51fa\u6765\u306a\u3044\u5834\u5408\u306f\u3001\n+     * SYNC\u306e\u8981\u6c42\u3092\u62d2\u5426\u3057\u307e\u3059\u3002*/\n     if (server.masterhost && server.repl_state != REDIS_REPL_CONNECTED) {\n         addReplyError(c,\"Can't SYNC while not connected with my master\");\n         return;\n     }\n\n-    /* SYNC can't be issued when the server has pending data to send to\n-     * the client about already issued commands. We need a fresh reply\n-     * buffer registering the differences between the BGSAVE and the current\n-     * dataset, so that we can copy to other slaves if needed. */\n+    /* \u30b5\u30fc\u30d0\u304c\u65e2\u306b\u767a\u884c\u3057\u305f\u30b3\u30de\u30f3\u30c9\u5185\u306b\u3001\u9001\u4fe1\u304c\u4fdd\u7559\u3055\u308c\u305f\u30c7\u30fc\u30bf\u304c\u3042\u308b\u5834\u5408\u306f\n+     * SYNC\u304c\u3067\u304d\u307e\u305b\u3093\u3002\u5fc5\u8981\u306b\u5fdc\u3058\u3066\u3001\u4ed6\u306e\u30b9\u30ec\u30fc\u30d6\u306b\u30b3\u30d4\u30fc\u3059\u308b\u3053\u3068\u304c\u3067\u304d\u308b\n+     * \u3088\u3046\u306b\u3001BGSAVE\u3068\u73fe\u5728\u306e\u30c7\u30fc\u30bf\u30bb\u30c3\u30c8\u306e\u9055\u3044\u3092\u3001\u65b0\u3057\u3044\u30ea\u30d7\u30e9\u30a4\u30d0\u30c3\u30d5\u30a1\u306b\n+     * \u767b\u9332\u3059\u308b\u5fc5\u8981\u304c\u3042\u308a\u307e\u3059\u3002*/\n     if (listLength(c->reply) != 0 || c->bufpos != 0) {\n         addReplyError(c,\"SYNC and PSYNC are invalid with pending output\");\n         return;\n@@ -433,44 +433,40 @@ void syncCommand(redisClient *c) {\n\n     redisLog(REDIS_NOTICE,\"Slave asks for synchronization\");\n\n-    /* Try a partial resynchronization if this is a PSYNC command.\n-     * If it fails, we continue with usual full resynchronization, however\n-     * when this happens masterTryPartialResynchronization() already\n-     * replied with:\n-     *\n-     * +FULLRESYNC <runid> <offset>\n-     *\n-     * So the slave knows the new runid and offset to try a PSYNC later\n-     * if the connection with the master is lost. */\n+    /* PSYNC\u30b3\u30de\u30f3\u30c9\u306e\u5834\u5408\u3001\u90e8\u5206\u7684\u306a\u540c\u671f\u3092\u8a66\u3057\u307e\u3059\u3002\u5931\u6557\u3057\u305f\u5834\u5408\u306f\u3001\u901a\u5e38\u5b8c\u5168\n+     * \u306a\u540c\u671f\u3092\u5b9f\u884c\u3057\u307e\u3059\u3002\u3057\u304b\u3057\u3001masterTryPartialResynchronization() \u304c\n+     *   FULLRESYNC <runid> <offset>``\n+     * \u3092\u8fd4\u3059\u305f\u3081\u3001\u30b9\u30ec\u30fc\u30d6\u306f\u30de\u30b9\u30bf\u30fc\u3068\u306e\u63a5\u7d9a\u304c\u5931\u308f\u308c\u305f\u5834\u5408\u3067\u3082\u5f8c\u3067\u65b0\u3057\u3044\n+     * runid\u3068\u30aa\u30d5\u30bb\u30c3\u30c8\u3092\u4fdd\u6301\u3057\u3066\u3044\u308b\u305f\u3081PSYNC\u3092\u5b9f\u884c\u3059\u308b\u3053\u3068\u304c\u51fa\u6765\u307e\u3059\u3002*/\n     if (!strcasecmp(c->argv[0]->ptr,\"psync\")) {\n         if (masterTryPartialResynchronization(c) == REDIS_OK) {\n             server.stat_sync_partial_ok++;\n-            return; /* No full resync needed, return. */\n+            return; /* \u5b8c\u5168\u540c\u671f\u3092\u3059\u308b\u5fc5\u8981\u306f\u3042\u308a\u307e\u305b\u3093\u3002 */\n         } else {\n             char *master_runid = c->argv[1]->ptr;\n\n-            /* Increment stats for failed PSYNCs, but only if the\n-             * runid is not \"?\", as this is used by slaves to force a full\n-             * resync on purpose when they are not albe to partially\n-             * resync. */\n+            /* runid \u304c`?`\u3067\u306a\u3044\u5834\u5408\u306bPSYNC\u304c\u5931\u6557\u3057\u305f\u56de\u6570\u3092\u30a4\u30f3\u30af\u30ea\u30e1\u30f3\u30c8\u3057\u307e\u3059\u3002\n+             * \u3053\u308c\u306f\u3001\u30b9\u30ec\u30fc\u30d6\u90e8\u5206\u7684\u306a\u540c\u671f\u3092\u884c\u3048\u306a\u3044\u5834\u5408\u306b\u3001\u5f37\u5236\u7684\u306b\u5b8c\u5168\u306a\u540c\u671f\n+             * \u3092\u3059\u308b\u305f\u3081\u306b\u4f7f\u7528\u3055\u308c\u307e\u3059\u3002*/\n             if (master_runid[0] != '?') server.stat_sync_partial_err++;\n         }\n     } else {\n-        /* If a slave uses SYNC, we are dealing with an old implementation\n-         * of the replication protocol (like redis-cli --slave). Flag the client\n-         * so that we don't expect to receive REPLCONF ACK feedbacks. */\n+        /* \u30b9\u30ec\u30fc\u30d6\u304cSYNC\u3092\u5b9f\u884c\u3057\u3066\u3044\u308b\u5834\u5408\u3001redis-cli --salve \u306e\u69d8\u306a\u30ec\u30ac\u30b7\u30fc\u306a\n+         * \u540c\u671f\u51e6\u7406\u5b9f\u88c5\u3092\u5229\u7528\u3057\u307e\u3059\u3002REDIS_PRE_PSYNC\u30d5\u30e9\u30b0\u304c\u3042\u308b\u30af\u30e9\u30a4\u30a2\u30f3\u30c8\u306f\n+         * REPLCONF ACK\u304c\u8fd4\u3089\u306a\u3044\u5834\u5408\u304c\u3042\u308a\u307e\u3059\u3002*/\n         c->flags |= REDIS_PRE_PSYNC;\n     }\n\n-    /* Full resynchronization. */\n+    /* \u5b8c\u5168\u540c\u671f\u3092\u5b9f\u884c\u3002 */\n     server.stat_sync_full++;\n\n-    /* Here we need to check if there is a background saving operation\n-     * in progress, or if it is required to start one */\n+    /* \u3053\u3053\u3067\u306f\u3001\u5b9f\u884c\u4e2d\u306b\u975e\u540c\u671f\u4fdd\u5b58\u51e6\u7406\u304c\u884c\u3048\u308b\u304b\u3001\u307e\u305f\u975e\u540c\u671f\u4fdd\u5b58\u51e6\u7406\u3092\u958b\u59cb\u3059\u308b\n+     * \u5fc5\u8981\u304c\u3042\u308b\u304b\u3092\u5224\u5b9a\u3057\u306a\u3051\u308c\u3070\u306a\u308a\u307e\u305b\u3093\u3002*/\n     if (server.rdb_child_pid != -1) {\n-        /* Ok a background save is in progress. Let's check if it is a good\n-         * one for replication, i.e. if there is another slave that is\n-         * registering differences since the server forked to save */\n+        /* \u5b9f\u884c\u4e2d\u306b\u975e\u540c\u671f\u4fdd\u5b58\u304c\u884c\u3048\u308b\u5834\u5408\u3001\u30ec\u30d7\u30ea\u30b1\u30fc\u30b7\u30e7\u30f3\u3092\u884c\u3046\u305f\u3081\u306e\u6761\u4ef6\u3092\u6e80\n+         * \u305f\u3057\u3066\u3044\u308b\u304b\u30c1\u30a7\u30c3\u30af\u3057\u307e\u3059\u3002\n+         * \u4f8b\uff09\u4ed6\u306e\u30b9\u30ec\u30fc\u30d6\u304c\u3001\u4fdd\u5b58\u306e\u305f\u3081\u306b\u30d5\u30a9\u30fc\u30af\u3055\u308c\u3066\u304b\u3089\u306e\u5dee\u5206\u3092\u767b\u9332\u3057\u3066\u3044\n+         *     \u308b\u304b\u3002 */\n         redisClient *slave;\n         listNode *ln;\n         listIter li;\n@@ -481,19 +477,20 @@ void syncCommand(redisClient *c) {\n             if (slave->replstate == REDIS_REPL_WAIT_BGSAVE_END) break;\n         }\n         if (ln) {\n-            /* Perfect, the server is already registering differences for\n-             * another slave. Set the right state, and copy the buffer. */\n+            /* \u5b8c\u74a7\uff01 \u30b5\u30fc\u30d0\u306f\u65e2\u306b\u4ed6\u306e\u30b9\u30ec\u30fc\u30d6\u3068\u306e\u5dee\u5206\u3092\u767b\u9332\u3057\u3066\u3044\u308b\u3002\n+             * \u30d0\u30c3\u30d5\u30a1\u3092\u30b3\u30d4\u30fc\u3057\u3066\u3001\u30b9\u30c6\u30fc\u30bf\u30b9\u306bREDIS_REPL_WAIT_BGSAVE_END\u3092\n+             * \u30bb\u30c3\u30c8\u3057\u307e\u3057\u3087\u3046\u3002*/\n             copyClientOutputBuffer(c,slave);\n             c->replstate = REDIS_REPL_WAIT_BGSAVE_END;\n             redisLog(REDIS_NOTICE,\"Waiting for end of BGSAVE for SYNC\");\n         } else {\n-            /* No way, we need to wait for the next BGSAVE in order to\n-             * register differences */\n+            /* \u305d\u3093\u306a\u30d0\u30ab\u306a\uff01 \u30b5\u30fc\u30d0\u306f\u5dee\u5206\u3092\u767b\u9332\u3059\u308b\u305f\u3081\u306b\u3001\u6b21\u306eBGSAVE\u3092\u5f85\u3064\n+             * \u5fc5\u8981\u304c\u3042\u308a\u307e\u3059\u3002 */\n             c->replstate = REDIS_REPL_WAIT_BGSAVE_START;\n             redisLog(REDIS_NOTICE,\"Waiting for next BGSAVE for SYNC\");\n         }\n     } else {\n-        /* Ok we don't have a BGSAVE in progress, let's start one */\n+        /* \u51e6\u7406\u4e2d\u306eBGSAVE\u304c\u7121\u3044\u5834\u5408\u3001BGSAVE\u3092\u958b\u59cb\u3057\u307e\u3059\u3002*/\n         redisLog(REDIS_NOTICE,\"Starting BGSAVE for SYNC\");\n         if (rdbSaveBackground(server.rdb_filename) != REDIS_OK) {\n             redisLog(REDIS_NOTICE,\"Replication failed, can't BGSAVE\");\n@@ -501,15 +498,15 @@ void syncCommand(redisClient *c) {\n             return;\n         }\n         c->replstate = REDIS_REPL_WAIT_BGSAVE_END;\n-        /* Flush the script cache for the new slave. */\n+        /* \u65b0\u3057\u3044\u30b9\u30ec\u30fc\u30d6\u7528\u306e\u30b9\u30af\u30ea\u30d7\u30c8\u3092\u30d5\u30e9\u30c3\u30b7\u30e5\u3057\u307e\u3059\u3002 */\n         replicationScriptCacheFlush();\n     }\n\n     if (server.repl_disable_tcp_nodelay)\n-        anetDisableTcpNoDelay(NULL, c->fd); /* Non critical if it fails. */\n+        anetDisableTcpNoDelay(NULL, c->fd); /* \u30af\u30ea\u30c6\u30a3\u30ab\u30eb\u306a\u30a8\u30e9\u30fc\u3067\u306f\u7121\u3044\u3002 */\n     c->repldbfd = -1;\n     c->flags |= REDIS_SLAVE;\n-    server.slaveseldb = -1; /* Force to re-emit the SELECT command. */\n+    server.slaveseldb = -1; /* \u5f37\u5236\u7684\u306bSELECT\u30b3\u30de\u30f3\u30c9\u3092\u5b9f\u884c\u3059\u308b\u3002 */\n     listAddNodeTail(server.slaves,c);\n     if (listLength(server.slaves) == 1 && server.repl_backlog == NULL)\n         createReplicationBacklog();\n\nBGSAVE\u51e6\u7406\u306e\u30e1\u30e2\u30ea\u6d88\u8cbb\u6291\u3048\u306a\u3044\u3068\u7269\u7406\u30e1\u30e2\u30ea\u6709\u52b9\u306b\u4f7f\u3048\u306a\u3044\u3067\u3059\u306d\u3002\nRedis\u306e\u30ec\u30d7\u30ea\u30b1\u30fc\u30b7\u30e7\u30f3\u304c\u4f55\u3084\u3063\u3066\u308b\u306e\u304b\u8abf\u3079\u305f\u304b\u3063\u305f\u306e\u3067\u30bd\u30fc\u30b9\u8aad\u307f\u306a\u304c\u3089\u7ffb\u8a33\u3002\n\n```diff\ndiff --git a/src/replication.c b/src/replication.c\nindex 9c1e1f0..b9812e7 100644\n--- a/src/replication.c\n+++ b/src/replication.c\n@@ -412,20 +412,20 @@ need_full_resync:\n\n /* SYNC ad PSYNC command implemenation. */\n void syncCommand(redisClient *c) {\n-    /* ignore SYNC if already slave or in monitor mode */\n+    /* \u3059\u3067\u306b\u30b9\u30ec\u30fc\u30d6\u307e\u305f\u306f\u30e2\u30cb\u30bf\u30e2\u30fc\u30c9\u306e\u5834\u5408\u306b\u306f\u3001SYNC\u3092\u7121\u8996\u3057\u307e\u3059\u3002 */\n     if (c->flags & REDIS_SLAVE) return;\n\n-    /* Refuse SYNC requests if we are a slave but the link with our master\n-     * is not ok... */\n+    /* \u3053\u306e\u30b5\u30fc\u30d0\u304c\u30b9\u30ec\u30fc\u30d6\u3067\u3001\u30de\u30b9\u30bf\u30fc\u3068\u306e\u30ea\u30f3\u30af\u304c\u51fa\u6765\u306a\u3044\u5834\u5408\u306f\u3001\n+     * SYNC\u306e\u8981\u6c42\u3092\u62d2\u5426\u3057\u307e\u3059\u3002*/\n     if (server.masterhost && server.repl_state != REDIS_REPL_CONNECTED) {\n         addReplyError(c,\"Can't SYNC while not connected with my master\");\n         return;\n     }\n\n-    /* SYNC can't be issued when the server has pending data to send to\n-     * the client about already issued commands. We need a fresh reply\n-     * buffer registering the differences between the BGSAVE and the current\n-     * dataset, so that we can copy to other slaves if needed. */\n+    /* \u30b5\u30fc\u30d0\u304c\u65e2\u306b\u767a\u884c\u3057\u305f\u30b3\u30de\u30f3\u30c9\u5185\u306b\u3001\u9001\u4fe1\u304c\u4fdd\u7559\u3055\u308c\u305f\u30c7\u30fc\u30bf\u304c\u3042\u308b\u5834\u5408\u306f\n+     * SYNC\u304c\u3067\u304d\u307e\u305b\u3093\u3002\u5fc5\u8981\u306b\u5fdc\u3058\u3066\u3001\u4ed6\u306e\u30b9\u30ec\u30fc\u30d6\u306b\u30b3\u30d4\u30fc\u3059\u308b\u3053\u3068\u304c\u3067\u304d\u308b\n+     * \u3088\u3046\u306b\u3001BGSAVE\u3068\u73fe\u5728\u306e\u30c7\u30fc\u30bf\u30bb\u30c3\u30c8\u306e\u9055\u3044\u3092\u3001\u65b0\u3057\u3044\u30ea\u30d7\u30e9\u30a4\u30d0\u30c3\u30d5\u30a1\u306b\n+     * \u767b\u9332\u3059\u308b\u5fc5\u8981\u304c\u3042\u308a\u307e\u3059\u3002*/\n     if (listLength(c->reply) != 0 || c->bufpos != 0) {\n         addReplyError(c,\"SYNC and PSYNC are invalid with pending output\");\n         return;\n@@ -433,44 +433,40 @@ void syncCommand(redisClient *c) {\n\n     redisLog(REDIS_NOTICE,\"Slave asks for synchronization\");\n\n-    /* Try a partial resynchronization if this is a PSYNC command.\n-     * If it fails, we continue with usual full resynchronization, however\n-     * when this happens masterTryPartialResynchronization() already\n-     * replied with:\n-     *\n-     * +FULLRESYNC <runid> <offset>\n-     *\n-     * So the slave knows the new runid and offset to try a PSYNC later\n-     * if the connection with the master is lost. */\n+    /* PSYNC\u30b3\u30de\u30f3\u30c9\u306e\u5834\u5408\u3001\u90e8\u5206\u7684\u306a\u540c\u671f\u3092\u8a66\u3057\u307e\u3059\u3002\u5931\u6557\u3057\u305f\u5834\u5408\u306f\u3001\u901a\u5e38\u5b8c\u5168\n+     * \u306a\u540c\u671f\u3092\u5b9f\u884c\u3057\u307e\u3059\u3002\u3057\u304b\u3057\u3001masterTryPartialResynchronization() \u304c\n+     *   FULLRESYNC <runid> <offset>``\n+     * \u3092\u8fd4\u3059\u305f\u3081\u3001\u30b9\u30ec\u30fc\u30d6\u306f\u30de\u30b9\u30bf\u30fc\u3068\u306e\u63a5\u7d9a\u304c\u5931\u308f\u308c\u305f\u5834\u5408\u3067\u3082\u5f8c\u3067\u65b0\u3057\u3044\n+     * runid\u3068\u30aa\u30d5\u30bb\u30c3\u30c8\u3092\u4fdd\u6301\u3057\u3066\u3044\u308b\u305f\u3081PSYNC\u3092\u5b9f\u884c\u3059\u308b\u3053\u3068\u304c\u51fa\u6765\u307e\u3059\u3002*/\n     if (!strcasecmp(c->argv[0]->ptr,\"psync\")) {\n         if (masterTryPartialResynchronization(c) == REDIS_OK) {\n             server.stat_sync_partial_ok++;\n-            return; /* No full resync needed, return. */\n+            return; /* \u5b8c\u5168\u540c\u671f\u3092\u3059\u308b\u5fc5\u8981\u306f\u3042\u308a\u307e\u305b\u3093\u3002 */\n         } else {\n             char *master_runid = c->argv[1]->ptr;\n\n-            /* Increment stats for failed PSYNCs, but only if the\n-             * runid is not \"?\", as this is used by slaves to force a full\n-             * resync on purpose when they are not albe to partially\n-             * resync. */\n+            /* runid \u304c`?`\u3067\u306a\u3044\u5834\u5408\u306bPSYNC\u304c\u5931\u6557\u3057\u305f\u56de\u6570\u3092\u30a4\u30f3\u30af\u30ea\u30e1\u30f3\u30c8\u3057\u307e\u3059\u3002\n+             * \u3053\u308c\u306f\u3001\u30b9\u30ec\u30fc\u30d6\u90e8\u5206\u7684\u306a\u540c\u671f\u3092\u884c\u3048\u306a\u3044\u5834\u5408\u306b\u3001\u5f37\u5236\u7684\u306b\u5b8c\u5168\u306a\u540c\u671f\n+             * \u3092\u3059\u308b\u305f\u3081\u306b\u4f7f\u7528\u3055\u308c\u307e\u3059\u3002*/\n             if (master_runid[0] != '?') server.stat_sync_partial_err++;\n         }\n     } else {\n-        /* If a slave uses SYNC, we are dealing with an old implementation\n-         * of the replication protocol (like redis-cli --slave). Flag the client\n-         * so that we don't expect to receive REPLCONF ACK feedbacks. */\n+        /* \u30b9\u30ec\u30fc\u30d6\u304cSYNC\u3092\u5b9f\u884c\u3057\u3066\u3044\u308b\u5834\u5408\u3001redis-cli --salve \u306e\u69d8\u306a\u30ec\u30ac\u30b7\u30fc\u306a\n+         * \u540c\u671f\u51e6\u7406\u5b9f\u88c5\u3092\u5229\u7528\u3057\u307e\u3059\u3002REDIS_PRE_PSYNC\u30d5\u30e9\u30b0\u304c\u3042\u308b\u30af\u30e9\u30a4\u30a2\u30f3\u30c8\u306f\n+         * REPLCONF ACK\u304c\u8fd4\u3089\u306a\u3044\u5834\u5408\u304c\u3042\u308a\u307e\u3059\u3002*/\n         c->flags |= REDIS_PRE_PSYNC;\n     }\n\n-    /* Full resynchronization. */\n+    /* \u5b8c\u5168\u540c\u671f\u3092\u5b9f\u884c\u3002 */\n     server.stat_sync_full++;\n\n-    /* Here we need to check if there is a background saving operation\n-     * in progress, or if it is required to start one */\n+    /* \u3053\u3053\u3067\u306f\u3001\u5b9f\u884c\u4e2d\u306b\u975e\u540c\u671f\u4fdd\u5b58\u51e6\u7406\u304c\u884c\u3048\u308b\u304b\u3001\u307e\u305f\u975e\u540c\u671f\u4fdd\u5b58\u51e6\u7406\u3092\u958b\u59cb\u3059\u308b\n+     * \u5fc5\u8981\u304c\u3042\u308b\u304b\u3092\u5224\u5b9a\u3057\u306a\u3051\u308c\u3070\u306a\u308a\u307e\u305b\u3093\u3002*/\n     if (server.rdb_child_pid != -1) {\n-        /* Ok a background save is in progress. Let's check if it is a good\n-         * one for replication, i.e. if there is another slave that is\n-         * registering differences since the server forked to save */\n+        /* \u5b9f\u884c\u4e2d\u306b\u975e\u540c\u671f\u4fdd\u5b58\u304c\u884c\u3048\u308b\u5834\u5408\u3001\u30ec\u30d7\u30ea\u30b1\u30fc\u30b7\u30e7\u30f3\u3092\u884c\u3046\u305f\u3081\u306e\u6761\u4ef6\u3092\u6e80\n+         * \u305f\u3057\u3066\u3044\u308b\u304b\u30c1\u30a7\u30c3\u30af\u3057\u307e\u3059\u3002\n+         * \u4f8b\uff09\u4ed6\u306e\u30b9\u30ec\u30fc\u30d6\u304c\u3001\u4fdd\u5b58\u306e\u305f\u3081\u306b\u30d5\u30a9\u30fc\u30af\u3055\u308c\u3066\u304b\u3089\u306e\u5dee\u5206\u3092\u767b\u9332\u3057\u3066\u3044\n+         *     \u308b\u304b\u3002 */\n         redisClient *slave;\n         listNode *ln;\n         listIter li;\n@@ -481,19 +477,20 @@ void syncCommand(redisClient *c) {\n             if (slave->replstate == REDIS_REPL_WAIT_BGSAVE_END) break;\n         }\n         if (ln) {\n-            /* Perfect, the server is already registering differences for\n-             * another slave. Set the right state, and copy the buffer. */\n+            /* \u5b8c\u74a7\uff01 \u30b5\u30fc\u30d0\u306f\u65e2\u306b\u4ed6\u306e\u30b9\u30ec\u30fc\u30d6\u3068\u306e\u5dee\u5206\u3092\u767b\u9332\u3057\u3066\u3044\u308b\u3002\n+             * \u30d0\u30c3\u30d5\u30a1\u3092\u30b3\u30d4\u30fc\u3057\u3066\u3001\u30b9\u30c6\u30fc\u30bf\u30b9\u306bREDIS_REPL_WAIT_BGSAVE_END\u3092\n+             * \u30bb\u30c3\u30c8\u3057\u307e\u3057\u3087\u3046\u3002*/\n             copyClientOutputBuffer(c,slave);\n             c->replstate = REDIS_REPL_WAIT_BGSAVE_END;\n             redisLog(REDIS_NOTICE,\"Waiting for end of BGSAVE for SYNC\");\n         } else {\n-            /* No way, we need to wait for the next BGSAVE in order to\n-             * register differences */\n+            /* \u305d\u3093\u306a\u30d0\u30ab\u306a\uff01 \u30b5\u30fc\u30d0\u306f\u5dee\u5206\u3092\u767b\u9332\u3059\u308b\u305f\u3081\u306b\u3001\u6b21\u306eBGSAVE\u3092\u5f85\u3064\n+             * \u5fc5\u8981\u304c\u3042\u308a\u307e\u3059\u3002 */\n             c->replstate = REDIS_REPL_WAIT_BGSAVE_START;\n             redisLog(REDIS_NOTICE,\"Waiting for next BGSAVE for SYNC\");\n         }\n     } else {\n-        /* Ok we don't have a BGSAVE in progress, let's start one */\n+        /* \u51e6\u7406\u4e2d\u306eBGSAVE\u304c\u7121\u3044\u5834\u5408\u3001BGSAVE\u3092\u958b\u59cb\u3057\u307e\u3059\u3002*/\n         redisLog(REDIS_NOTICE,\"Starting BGSAVE for SYNC\");\n         if (rdbSaveBackground(server.rdb_filename) != REDIS_OK) {\n             redisLog(REDIS_NOTICE,\"Replication failed, can't BGSAVE\");\n@@ -501,15 +498,15 @@ void syncCommand(redisClient *c) {\n             return;\n         }\n         c->replstate = REDIS_REPL_WAIT_BGSAVE_END;\n-        /* Flush the script cache for the new slave. */\n+        /* \u65b0\u3057\u3044\u30b9\u30ec\u30fc\u30d6\u7528\u306e\u30b9\u30af\u30ea\u30d7\u30c8\u3092\u30d5\u30e9\u30c3\u30b7\u30e5\u3057\u307e\u3059\u3002 */\n         replicationScriptCacheFlush();\n     }\n\n     if (server.repl_disable_tcp_nodelay)\n-        anetDisableTcpNoDelay(NULL, c->fd); /* Non critical if it fails. */\n+        anetDisableTcpNoDelay(NULL, c->fd); /* \u30af\u30ea\u30c6\u30a3\u30ab\u30eb\u306a\u30a8\u30e9\u30fc\u3067\u306f\u7121\u3044\u3002 */\n     c->repldbfd = -1;\n     c->flags |= REDIS_SLAVE;\n-    server.slaveseldb = -1; /* Force to re-emit the SELECT command. */\n+    server.slaveseldb = -1; /* \u5f37\u5236\u7684\u306bSELECT\u30b3\u30de\u30f3\u30c9\u3092\u5b9f\u884c\u3059\u308b\u3002 */\n     listAddNodeTail(server.slaves,c);\n     if (listLength(server.slaves) == 1 && server.repl_backlog == NULL)\n         createReplicationBacklog();\n```\n\n``BGSAVE``\u51e6\u7406\u306e\u30e1\u30e2\u30ea\u6d88\u8cbb\u6291\u3048\u306a\u3044\u3068\u7269\u7406\u30e1\u30e2\u30ea\u6709\u52b9\u306b\u4f7f\u3048\u306a\u3044\u3067\u3059\u306d\u3002", "tags": ["Redis"]}