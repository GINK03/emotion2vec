{"context": " More than 1 year has passed since last update.\u524d\u56de\u306fTCP\u30af\u30e9\u30a4\u30a2\u30f3\u30c8\u5074\u3092\u66f8\u3044\u305f\u306e\u3067\u6b21\u306f\u30b5\u30fc\u30d0\u30fc\u5074\u3092\uff0e\n\n\u8981\u70b9\n\n\nbind\u306b\u6210\u529f\u3057\u305f\u3089 Bound(localAddress) \u30e1\u30c3\u30bb\u30fc\u30b8\u304c\u6765\u308b\n\u65b0\u3057\u3044\u63a5\u7d9a\u3092 accept \u3057\u305f\u3089 Connected(remote, local) \u30e1\u30c3\u30bb\u30fc\u30b8\u304c\u6765\u308b\n\nConnected\u5f8c\u306f sender()\u3067\u63a5\u7d9a\u4e3b\u306e\u30a2\u30af\u30bf\u30fc\u304c\u53d6\u308c\u308b\n\u63a5\u7d9a\u4e3b\u306e\u30a2\u30af\u30bf\u30fc\u306b Register\u30e1\u30c3\u30bb\u30fc\u30b8\u3092\u9001\u3063\u3066 \u30c7\u30fc\u30bf\u306e\u3084\u308a\u53d6\u308a\u3092\u884c\u3046 Handler \u3092\u767b\u9332\u3059\u308b\n\u30c7\u30fc\u30bf\u53d7\u4fe1\u3059\u308b\u3068 Handler\u306bReceived(data) \u30e1\u30c3\u30bb\u30fc\u30b8\u304c\u6765\u308b\n\n\n\u53d7\u3051\u53d6\u3063\u305f\u30c7\u30fc\u30bf\u3092\u305d\u306e\u307e\u307e\u8fd4\u3059\u3060\u3051\u306e\u30b5\u30fc\u30d0\u30fc\n\nEchoServer.scala\nimport java.net.InetSocketAddress\n\nimport akka.actor.{ActorSystem, Props, ActorLogging, Actor}\nimport akka.io.{IO, Tcp}\n\n/**\n * \u63a5\u7d9a\u3055\u308c\u305f\u30af\u30e9\u30a4\u30a2\u30f3\u30c8\u3068\u30c7\u30fc\u30bf\u306e\u3084\u308a\u53d6\u308a\u3092\u884c\u3046Handler \n */\nclass Handler extends Actor {\n  import Tcp._\n\n  def receive = {\n    // \u53d7\u3051\u53d6\u3063\u305f\u30c7\u30fc\u30bf\u3092\u305d\u306e\u307e\u307e\u9001\u4fe1\u4e3b\u306b\u8fd4\u3059\n    case Received(data) => sender() ! Write(data)\n    case PeerClosed => context stop self\n  }\n}\n\n/**\n * \u30af\u30e9\u30a4\u30a2\u30f3\u30c8\u306e\u63a5\u7d9a\u3092\u53d7\u3051\u5165\u308c\u308b\u30b5\u30fc\u30d0\u30fc\n */\nclass Server(bindAddress: InetSocketAddress) extends Actor with ActorLogging {\n  import Tcp._\n  import context.system\n\n  IO(Tcp) ! Bind(self, bindAddress)\n\n  def receive = {\n    case Bound(localAddress) =>\n      log.info(\"bound on {}...\", localAddress)\n\n    case Connected(remote, local) =>\n      log.info(\"accepted peer: {}\", remote)\n      val handler = context.actorOf(Props[Handler])\n      sender() ! Register(handler)\n\n    case CommandFailed(_: Bind) =>\n      log.error(\"bind failed\")\n      context stop self\n  }\n}\n\n/**\n * \u30e1\u30a4\u30f3\u95a2\u6570\n */\nobject EchoServer {\n  def main(args: Array[String]): Unit = {\n    val system = ActorSystem(\"MySystem\")\n    val bindAddress = new InetSocketAddress(\"localhost\", 12345)\n    system.actorOf(Props(classOf[Server], bindAddress))\n  }\n}\n\n\n[\u524d\u56de\u306fTCP\u30af\u30e9\u30a4\u30a2\u30f3\u30c8\u5074\u3092\u66f8\u3044\u305f](http://qiita.com/castaneai/items/d2746523d51cd73d6aaf)\u306e\u3067\u6b21\u306f\u30b5\u30fc\u30d0\u30fc\u5074\u3092\uff0e\n\n## \u8981\u70b9\n\n- `bind`\u306b\u6210\u529f\u3057\u305f\u3089 `Bound(localAddress)` \u30e1\u30c3\u30bb\u30fc\u30b8\u304c\u6765\u308b\n- \u65b0\u3057\u3044\u63a5\u7d9a\u3092 `accept` \u3057\u305f\u3089 `Connected(remote, local)` \u30e1\u30c3\u30bb\u30fc\u30b8\u304c\u6765\u308b\n- `Connected`\u5f8c\u306f `sender()`\u3067\u63a5\u7d9a\u4e3b\u306e\u30a2\u30af\u30bf\u30fc\u304c\u53d6\u308c\u308b\n- \u63a5\u7d9a\u4e3b\u306e\u30a2\u30af\u30bf\u30fc\u306b `Register`\u30e1\u30c3\u30bb\u30fc\u30b8\u3092\u9001\u3063\u3066 \u30c7\u30fc\u30bf\u306e\u3084\u308a\u53d6\u308a\u3092\u884c\u3046 `Handler` \u3092\u767b\u9332\u3059\u308b\n- \u30c7\u30fc\u30bf\u53d7\u4fe1\u3059\u308b\u3068 `Handler`\u306b`Received(data)` \u30e1\u30c3\u30bb\u30fc\u30b8\u304c\u6765\u308b\n\n## \u53d7\u3051\u53d6\u3063\u305f\u30c7\u30fc\u30bf\u3092\u305d\u306e\u307e\u307e\u8fd4\u3059\u3060\u3051\u306e\u30b5\u30fc\u30d0\u30fc\n\n```scala:EchoServer.scala\nimport java.net.InetSocketAddress\n\nimport akka.actor.{ActorSystem, Props, ActorLogging, Actor}\nimport akka.io.{IO, Tcp}\n\n/**\n * \u63a5\u7d9a\u3055\u308c\u305f\u30af\u30e9\u30a4\u30a2\u30f3\u30c8\u3068\u30c7\u30fc\u30bf\u306e\u3084\u308a\u53d6\u308a\u3092\u884c\u3046Handler \n */\nclass Handler extends Actor {\n  import Tcp._\n\n  def receive = {\n    // \u53d7\u3051\u53d6\u3063\u305f\u30c7\u30fc\u30bf\u3092\u305d\u306e\u307e\u307e\u9001\u4fe1\u4e3b\u306b\u8fd4\u3059\n    case Received(data) => sender() ! Write(data)\n    case PeerClosed => context stop self\n  }\n}\n\n/**\n * \u30af\u30e9\u30a4\u30a2\u30f3\u30c8\u306e\u63a5\u7d9a\u3092\u53d7\u3051\u5165\u308c\u308b\u30b5\u30fc\u30d0\u30fc\n */\nclass Server(bindAddress: InetSocketAddress) extends Actor with ActorLogging {\n  import Tcp._\n  import context.system\n\n  IO(Tcp) ! Bind(self, bindAddress)\n\n  def receive = {\n    case Bound(localAddress) =>\n      log.info(\"bound on {}...\", localAddress)\n\n    case Connected(remote, local) =>\n      log.info(\"accepted peer: {}\", remote)\n      val handler = context.actorOf(Props[Handler])\n      sender() ! Register(handler)\n\n    case CommandFailed(_: Bind) =>\n      log.error(\"bind failed\")\n      context stop self\n  }\n}\n\n/**\n * \u30e1\u30a4\u30f3\u95a2\u6570\n */\nobject EchoServer {\n  def main(args: Array[String]): Unit = {\n    val system = ActorSystem(\"MySystem\")\n    val bindAddress = new InetSocketAddress(\"localhost\", 12345)\n    system.actorOf(Props(classOf[Server], bindAddress))\n  }\n}\n```\n", "tags": ["Akka2.3.11", "Scala2.11.6"]}