{"context": " More than 1 year has passed since last update.\n\nRuby\u3067word2vec\u4f7f\u3048\u305f\u3089\u826f\u3044\u306e\u306b\u3068\u3044\u3046\u3053\u3068\u3067\n\n\u53c2\u8003\u306b\u66f8\u3044\u3066\u3042\u308bC\u62e1\u5f35\u306e\u30c1\u30e5\u30fc\u30c8\u30ea\u30a2\u30eb\u3092\u53c2\u8003\u306b\u3055\u305b\u3066\u9802\u304d\u306a\u304c\u3089distance.c\u3092\u66f8\u304d\u63db\u3048\u30b3\u30f3\u30d1\u30a4\u30eb\nirb\u3067\u547c\u3073\u51fa\u3057\u3066\u307f\u307e\u3059\n\n\n\u307e\u305a\u306f, \u6e96\u5099\u3067\u3059.\n\ndistance.c\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <math.h>\n#include <malloc/malloc.h>\n#include <ruby.h>\n\nconst long long max_size = 2000;\nconst long long N = 50;\nconst long long max_w = 50;\n\nFILE *f;\nchar st1[max_size];\nchar *bestw[N];\nchar file_name[max_size], st[100][max_size];\nfloat dist, len, bestd[N], vec[max_size];\nlong long words, size, a, b, c, d, cn, bi[100];\nchar ch;\nfloat *M;\nchar *vocab;\n\nVALUE cDistance;\n\nVALUE open_func(VALUE self)\n{\n  f = fopen(\"vectors.bin\", \"rb\");// \u30d5\u30a1\u30a4\u30eb\u8aad\u307f\u8fbc\u307f\n  fscanf(f, \"%lld\", &words);\n  fscanf(f, \"%lld\", &size);\n\n  vocab = (char *)malloc((long long)words * max_w * sizeof(char));\n\n  for (a = 0; a < N; a++) bestw[a] = (char *)malloc(max_size * sizeof(char));\n  M = (float *)malloc((long long)words * (long long)size * sizeof(float));\n  if (M == NULL) {\n    return -1;\n  }\n  for (b = 0; b < words; b++) {\n    a = 0;\n    while (1) {\n      vocab[b * max_w + a] = fgetc(f);\n      if (feof(f) || (vocab[b * max_w + a] == ' ')) break;\n      if ((a < max_w) && (vocab[b * max_w + a] != '\\n')) a++;\n    }\n    vocab[b * max_w + a] = 0;\n    for (a = 0; a < size; a++) fread(&M[a + b * size], sizeof(float), 1, f);\n    len = 0;\n    for (a = 0; a < size; a++) len += M[a + b * size] * M[a + b * size];\n    len = sqrt(len);\n    for (a = 0; a < size; a++) M[a + b * size] /= len;\n  }\n  fclose(f);\n  return self;\n}\n\nVALUE caliculate_func(VALUE self, VALUE s_val)\n{\n  char* s = StringValuePtr(s_val);\n\n  for (a = 0; a < N; a++) bestd[a] = 0;\n  for (a = 0; a < N; a++) bestw[a][0] = 0;\n\n  strcpy(st1, s);\n\n  cn = 0;\n  b = 0;\n  c = 0;\n  while (1) {\n    st[cn][b] = st1[c];\n    b++;\n    c++;\n    st[cn][b] = 0;\n    if (st1[c] == 0) break;\n    if (st1[c] == ' ') {\n      cn++;\n      b = 0;\n      c++;\n    }\n  }\n  cn++;\n  for (a = 0; a < cn; a++) {\n    for (b = 0; b < words; b++) if (!strcmp(&vocab[b * max_w], st[a])) break;\n    if (b == words) b = -1;\n    bi[a] = b;\n    if (b == -1) {\n      break;\n    }\n  }\n\n  for (a = 0; a < size; a++) vec[a] = 0;\n  for (b = 0; b < cn; b++) {\n    if (bi[b] == -1) continue;\n    for (a = 0; a < size; a++) vec[a] += M[a + bi[b] * size];\n  }\n  len = 0;\n  for (a = 0; a < size; a++) len += vec[a] * vec[a];\n  len = sqrt(len);\n  for (a = 0; a < size; a++) vec[a] /= len;\n  for (a = 0; a < N; a++) bestd[a] = -1;\n  for (a = 0; a < N; a++) bestw[a][0] = 0;\n  for (c = 0; c < words; c++) {\n    a = 0;\n    for (b = 0; b < cn; b++) if (bi[b] == c) a = 1;\n    if (a == 1) continue;\n    dist = 0;\n    for (a = 0; a < size; a++) dist += vec[a] * M[a + c * size];\n    for (a = 0; a < N; a++) {\n      if (dist > bestd[a]) {\n        for (d = N - 1; d > a; d--) {\n          bestd[d] = bestd[d - 1];\n          strcpy(bestw[d], bestw[d - 1]);\n        }\n        bestd[a] = dist;\n        strcpy(bestw[a], &vocab[c * max_w]);\n        break;\n      }\n    }\n  }\n\n  for (a = 1; a < N; a++) {\n    strcat(bestw[0], \" \");\n    strcat(bestw[0], bestw[a]);\n  }\n\n  return rb_str_new2(bestw[0]); //bestw\u3092\u30b9\u30da\u30fc\u30b9\u533a\u5207\u308a\u306b\u3057\u3066String\u306b\u578b\u5909\u63db\n}\n\nvoid Init_distance()\n{\n  cDistance = rb_define_class(\"Distance\", rb_cObject);\n  rb_define_method(cDistance, \"open\", RUBY_METHOD_FUNC(open_func), 0);\n  rb_define_method(cDistance, \"caliculate\", RUBY_METHOD_FUNC(caliculate_func), 1);\n}\n\n\nMakefile\u3092\u751f\u6210\u3057\u307e\u3059. extconf.rb\u3092\u4f5c\u6210\u3057\u3066ruby extconf.rb\u3057\u307e\u3059.\n\n# extconf.rb\nrequire 'mkmf'\ncreate_makefile('distance')\n\n\nMakefile\u304c\u751f\u6210\u3055\u308c\u305f\u3089, make\u3057\u307e\u3059.\ndistance.o, distance.bundle\u3068\u3044\u3046\u30d5\u30a1\u30a4\u30eb\u304c\u751f\u6210\u3055\u308c\u3066\u3044\u308b\u3068\u601d\u3044\u307e\u3059. \n\u30b3\u30fc\u30d1\u30b9\u3092\u30d9\u30af\u30c8\u30eb\u306b\u5909\u63db\u3057\u305f\u30d5\u30a1\u30a4\u30ebvectors.bin\u3092\u7528\u610f\u3057\u3066\u4e0b\u3055\u3044.\n\u4eca\u56de\u306fDemo\u7528\u306e\u30b3\u30fc\u30d1\u30b9\u3092\u4ed5\u69d8\u3057\u3066\u3044\u307e\u3059. \n\n\u3053\u308c\u3067\u6e96\u5099\u5b8c\u4e86\u3067\u3059. \n\nrequire\u3057\u3066\u307f\u308b\n\nrequire './distance'\n\ndistance = Distance.new\ndistance.open\ndistance.caliculate(\"emacs\")\n#=> \"vim xemacs wysiwyg posix scripting debugging debuggers bash lisp extensible bcpl csh toolkit editors unix cvs gnu interpreter debugger ircii matlab compile programmer perl tcl kylix fortran ide gtk jre intercal frontend installer preprocessor lgpl glibc runtime postscript executable figlet usemodwiki cli rexx awk gdb edlin gcc authoring assembler tex\"\n\n\u3067\u304d\u305f\uff01\n\n\u6ce8\u610f\n\n\u65e5\u672c\u8a9e\u3092\u6271\u3046\u6642, distance.caliculate(\"str\")\u3057\u305f\u51fa\u529b\u7d50\u679c\u3092\ndistance.caliculate(\"\u3053\u3093\u306b\u3061\u306f\").force_encoding(\"UTF-8\")\n\n\u3068\u304b\u3059\u308b\u5fc5\u8981\u304c\u3042\u308a\u307e\u3059...\n\n\u3072\u3068\u3053\u3068\n\nC\u62e1\u5f35\u3092\u66f8\u304f\u306e\u521d\u3081\u3066\u3060\u3063\u305f\u308a, \u8272\u3005\u3068\u554f\u984c\u70b9\u304c\u5c71\u7a4d\u307f\u306a\u306e\u3067\u3059\u304c, \u4e00\u5fdc\u52d5\u304b\u3059\u307e\u3067\u306f\u3067\u304d\u307e\u3057\u305f. \n\u81ea\u5206\u306e\u30a2\u30d7\u30ea\u30b1\u30fc\u30b7\u30e7\u30f3\u3092\u52d5\u304b\u3059\u305f\u3081\u306b\u5fc5\u8981\u3060\u3063\u305f\u985e\u8a9e\u62bd\u51fa\u3060\u3051\u884c\u3048\u308b\u3088\u3046\u306b\u3057\u307e\u3057\u305f.\n\u307e\u305f, \u6587\u5b57\u5217\u3092UTF-8\u3067,cos\u985e\u4f3c\u5ea6\u3082\u53d7\u3051\u53d6\u308c\u308b\u3088\u3046\u306b, \u7d50\u679c\u3092\u914d\u5217\u3067\u51fa\u529b\u3059\u308b\u3088\u3046\u4f5c\u308a\u76f4\u3057\u307e\u3059.\n\u30d5\u30a1\u30a4\u30eb\u6307\u5b9a\u3082\u307e\u3060\u3067\u304d\u307e\u305b\u3093. open_func\u306e\u6700\u521d\u306e\u65b9\u306e f = fopen(\"vectors.bin\", \"rb\");// \u30d5\u30a1\u30a4\u30eb\u8aad\u307f\u8fbc\u307f \u3067\u90fd\u5ea6\u540d\u524d\u3092\u5909\u3048\u308b\u4ed5\u69d8\u306b\u306a\u3063\u3066\u3044\u307e\u3059...\n\n\n\u53c2\u8003\nRuby\u62e1\u5f35\u30e9\u30a4\u30d6\u30e9\u30ea\u4f5c\u6210\u30c1\u30e5\u30fc\u30c8\u30ea\u30a2\u30eb\n# Ruby\u3067word2vec\u4f7f\u3048\u305f\u3089\u826f\u3044\u306e\u306b\u3068\u3044\u3046\u3053\u3068\u3067\n* \u53c2\u8003\u306b\u66f8\u3044\u3066\u3042\u308bC\u62e1\u5f35\u306e\u30c1\u30e5\u30fc\u30c8\u30ea\u30a2\u30eb\u3092\u53c2\u8003\u306b\u3055\u305b\u3066\u9802\u304d\u306a\u304c\u3089distance.c\u3092\u66f8\u304d\u63db\u3048\u30b3\u30f3\u30d1\u30a4\u30eb\n* irb\u3067\u547c\u3073\u51fa\u3057\u3066\u307f\u307e\u3059\n\n***\n\n\u307e\u305a\u306f, \u6e96\u5099\u3067\u3059.\n\n- distance.c\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <math.h>\n#include <malloc/malloc.h>\n#include <ruby.h>\n\nconst long long max_size = 2000;\nconst long long N = 50;\nconst long long max_w = 50;\n\nFILE *f;\nchar st1[max_size];\nchar *bestw[N];\nchar file_name[max_size], st[100][max_size];\nfloat dist, len, bestd[N], vec[max_size];\nlong long words, size, a, b, c, d, cn, bi[100];\nchar ch;\nfloat *M;\nchar *vocab;\n\nVALUE cDistance;\n\nVALUE open_func(VALUE self)\n{\n  f = fopen(\"vectors.bin\", \"rb\");// \u30d5\u30a1\u30a4\u30eb\u8aad\u307f\u8fbc\u307f\n  fscanf(f, \"%lld\", &words);\n  fscanf(f, \"%lld\", &size);\n\n  vocab = (char *)malloc((long long)words * max_w * sizeof(char));\n\n  for (a = 0; a < N; a++) bestw[a] = (char *)malloc(max_size * sizeof(char));\n  M = (float *)malloc((long long)words * (long long)size * sizeof(float));\n  if (M == NULL) {\n    return -1;\n  }\n  for (b = 0; b < words; b++) {\n    a = 0;\n    while (1) {\n      vocab[b * max_w + a] = fgetc(f);\n      if (feof(f) || (vocab[b * max_w + a] == ' ')) break;\n      if ((a < max_w) && (vocab[b * max_w + a] != '\\n')) a++;\n    }\n    vocab[b * max_w + a] = 0;\n    for (a = 0; a < size; a++) fread(&M[a + b * size], sizeof(float), 1, f);\n    len = 0;\n    for (a = 0; a < size; a++) len += M[a + b * size] * M[a + b * size];\n    len = sqrt(len);\n    for (a = 0; a < size; a++) M[a + b * size] /= len;\n  }\n  fclose(f);\n  return self;\n}\n\nVALUE caliculate_func(VALUE self, VALUE s_val)\n{\n  char* s = StringValuePtr(s_val);\n\n  for (a = 0; a < N; a++) bestd[a] = 0;\n  for (a = 0; a < N; a++) bestw[a][0] = 0;\n\n  strcpy(st1, s);\n\n  cn = 0;\n  b = 0;\n  c = 0;\n  while (1) {\n    st[cn][b] = st1[c];\n    b++;\n    c++;\n    st[cn][b] = 0;\n    if (st1[c] == 0) break;\n    if (st1[c] == ' ') {\n      cn++;\n      b = 0;\n      c++;\n    }\n  }\n  cn++;\n  for (a = 0; a < cn; a++) {\n    for (b = 0; b < words; b++) if (!strcmp(&vocab[b * max_w], st[a])) break;\n    if (b == words) b = -1;\n    bi[a] = b;\n    if (b == -1) {\n      break;\n    }\n  }\n\n  for (a = 0; a < size; a++) vec[a] = 0;\n  for (b = 0; b < cn; b++) {\n    if (bi[b] == -1) continue;\n    for (a = 0; a < size; a++) vec[a] += M[a + bi[b] * size];\n  }\n  len = 0;\n  for (a = 0; a < size; a++) len += vec[a] * vec[a];\n  len = sqrt(len);\n  for (a = 0; a < size; a++) vec[a] /= len;\n  for (a = 0; a < N; a++) bestd[a] = -1;\n  for (a = 0; a < N; a++) bestw[a][0] = 0;\n  for (c = 0; c < words; c++) {\n    a = 0;\n    for (b = 0; b < cn; b++) if (bi[b] == c) a = 1;\n    if (a == 1) continue;\n    dist = 0;\n    for (a = 0; a < size; a++) dist += vec[a] * M[a + c * size];\n    for (a = 0; a < N; a++) {\n      if (dist > bestd[a]) {\n        for (d = N - 1; d > a; d--) {\n          bestd[d] = bestd[d - 1];\n          strcpy(bestw[d], bestw[d - 1]);\n        }\n        bestd[a] = dist;\n        strcpy(bestw[a], &vocab[c * max_w]);\n        break;\n      }\n    }\n  }\n\n  for (a = 1; a < N; a++) {\n    strcat(bestw[0], \" \");\n    strcat(bestw[0], bestw[a]);\n  }\n\n  return rb_str_new2(bestw[0]); //bestw\u3092\u30b9\u30da\u30fc\u30b9\u533a\u5207\u308a\u306b\u3057\u3066String\u306b\u578b\u5909\u63db\n}\n\nvoid Init_distance()\n{\n  cDistance = rb_define_class(\"Distance\", rb_cObject);\n  rb_define_method(cDistance, \"open\", RUBY_METHOD_FUNC(open_func), 0);\n  rb_define_method(cDistance, \"caliculate\", RUBY_METHOD_FUNC(caliculate_func), 1);\n}\n```\n\n- Makefile\u3092\u751f\u6210\u3057\u307e\u3059. ```extconf.rb```\u3092\u4f5c\u6210\u3057\u3066```ruby extconf.rb```\u3057\u307e\u3059.\n\n```rb\n# extconf.rb\nrequire 'mkmf'\ncreate_makefile('distance')\n```\n\n- Makefile\u304c\u751f\u6210\u3055\u308c\u305f\u3089, ```make```\u3057\u307e\u3059.\n```distance.o```, ```distance.bundle```\u3068\u3044\u3046\u30d5\u30a1\u30a4\u30eb\u304c\u751f\u6210\u3055\u308c\u3066\u3044\u308b\u3068\u601d\u3044\u307e\u3059. \n\n- \u30b3\u30fc\u30d1\u30b9\u3092\u30d9\u30af\u30c8\u30eb\u306b\u5909\u63db\u3057\u305f\u30d5\u30a1\u30a4\u30eb```vectors.bin```\u3092\u7528\u610f\u3057\u3066\u4e0b\u3055\u3044.\n- \u4eca\u56de\u306fDemo\u7528\u306e\u30b3\u30fc\u30d1\u30b9\u3092\u4ed5\u69d8\u3057\u3066\u3044\u307e\u3059. \n\n\n\u3053\u308c\u3067\u6e96\u5099\u5b8c\u4e86\u3067\u3059. \n\n- require\u3057\u3066\u307f\u308b\n\n```rb\nrequire './distance'\n\ndistance = Distance.new\ndistance.open\ndistance.caliculate(\"emacs\")\n#=> \"vim xemacs wysiwyg posix scripting debugging debuggers bash lisp extensible bcpl csh toolkit editors unix cvs gnu interpreter debugger ircii matlab compile programmer perl tcl kylix fortran ide gtk jre intercal frontend installer preprocessor lgpl glibc runtime postscript executable figlet usemodwiki cli rexx awk gdb edlin gcc authoring assembler tex\"\n```\n\u3067\u304d\u305f\uff01\n\n- \u6ce8\u610f\n\n\u65e5\u672c\u8a9e\u3092\u6271\u3046\u6642, distance.caliculate(\"str\")\u3057\u305f\u51fa\u529b\u7d50\u679c\u3092\n\n```rb\ndistance.caliculate(\"\u3053\u3093\u306b\u3061\u306f\").force_encoding(\"UTF-8\")\n```\n\u3068\u304b\u3059\u308b\u5fc5\u8981\u304c\u3042\u308a\u307e\u3059...\n\n## \u3072\u3068\u3053\u3068\n\n* C\u62e1\u5f35\u3092\u66f8\u304f\u306e\u521d\u3081\u3066\u3060\u3063\u305f\u308a, \u8272\u3005\u3068\u554f\u984c\u70b9\u304c\u5c71\u7a4d\u307f\u306a\u306e\u3067\u3059\u304c, \u4e00\u5fdc\u52d5\u304b\u3059\u307e\u3067\u306f\u3067\u304d\u307e\u3057\u305f. \n* \u81ea\u5206\u306e\u30a2\u30d7\u30ea\u30b1\u30fc\u30b7\u30e7\u30f3\u3092\u52d5\u304b\u3059\u305f\u3081\u306b\u5fc5\u8981\u3060\u3063\u305f\u985e\u8a9e\u62bd\u51fa\u3060\u3051\u884c\u3048\u308b\u3088\u3046\u306b\u3057\u307e\u3057\u305f.\n* \u307e\u305f, \u6587\u5b57\u5217\u3092UTF-8\u3067,cos\u985e\u4f3c\u5ea6\u3082\u53d7\u3051\u53d6\u308c\u308b\u3088\u3046\u306b, \u7d50\u679c\u3092\u914d\u5217\u3067\u51fa\u529b\u3059\u308b\u3088\u3046\u4f5c\u308a\u76f4\u3057\u307e\u3059.\n* \u30d5\u30a1\u30a4\u30eb\u6307\u5b9a\u3082\u307e\u3060\u3067\u304d\u307e\u305b\u3093. open_func\u306e\u6700\u521d\u306e\u65b9\u306e ```f = fopen(\"vectors.bin\", \"rb\");// \u30d5\u30a1\u30a4\u30eb\u8aad\u307f\u8fbc\u307f``` \u3067\u90fd\u5ea6\u540d\u524d\u3092\u5909\u3048\u308b\u4ed5\u69d8\u306b\u306a\u3063\u3066\u3044\u307e\u3059...\n\n## \u53c2\u8003\n[Ruby\u62e1\u5f35\u30e9\u30a4\u30d6\u30e9\u30ea\u4f5c\u6210\u30c1\u30e5\u30fc\u30c8\u30ea\u30a2\u30eb](http://ruby.gfd-dennou.org/tutorial/ruby-ext/)\n", "tags": ["Ruby", "word2vec"]}