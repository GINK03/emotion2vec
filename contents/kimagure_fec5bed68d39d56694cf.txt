{"context": " More than 1 year has passed since last update.This is something a lot of people still do in the name of simplicity or not requiring tooling on everyone's machines. A lot of projects still either add dist/ to .gitignore or just prohibit users from checking in their changes to dist/ (that might arise from normal development or running a dist/ building script).\nIn other cases, built assets are checked in because some developers on your team might not have the necessary tooling installed on their machines. Why should Java developers have Node/IO.js installed on their machines? (i.e. if you're developing \"monolithic\" applications)\nThe main arguments I have against this:\n\nWhy check in things that are generated anyway?\nMerge conflicts for minified/compressed files are stupid to resolve when rebasing/merging, because often you will just get blocked having to rebuild assets for no good reason.\nIf you have normal merge conflicts to resolve, your effort to resolve them also includes building these assets and testing them again to see if they work.\n\nEnough with the stupid intro, time to get to the how.\n\nHow\n\nAdd configuration for your CI tool\nI use Travis on Github, so I add a .travis.yml:\n+script: bash build_helpers/buildDistFromTravis.sh\n+env:\n  global:\n  - GH_REF: github.com/{{myusername}}/{{my-repo}}\n  - secure: {{encrypted key goes here}}\nlanguage: node_js\nnode_js:\n- \"0.10\"\n\nIn Travis, you specify what script needs to be run by using the script property. In this case, I am telling to run bash build_helpers/buildDistFromTravis.sh.\nSee the Travis docs about adding encrypted keys\n\nAdd your shell script for what to do\nIn my case, I would be adding build_helpers/buildDistFromTravis.sh, let's do that:\n#!/bin/bash\nset -e #Set errors to fail explicitly\n\n# in Travis, the git version is 1.8.5, so we need to use rev-parse to get the name of the branch\nbranch_name=\"$(git rev-parse --abbrev-ref HEAD)\"\n\n# I only want to build and commit if I'm on master\nif [ \"$branch_name\" == \"master\" ]\nthen\n  # build dist\n  npm run build-dist\n\n  # initialize and commit everything in pages\n  cd dist\n  git init\n  git config user.name \"Travis\"\n  git config user.email \"Travis\"\n  git add .\n  git commit -m \"build dist assets and commit to dist\"\n\n  # hide my output for security reasons\n  # force it because we want this to just actually work\n  # note, I'm pushing to a remote branch for the dist assets from master\n  git push --force --quiet \"https://${GH_TOKEN}@${GH_REF}\" master:dist > /dev/null 2>&1\nelse\n  echo \"Current branch is not master and dist will not be built or committed.\"\nfi\n\n\nResult\nSimple enough, right? You can see how it worked out here:\nMy master branch: https://github.com/justinwoo/fixed-data-table/tree/master\nMy built dist branch: https://github.com/justinwoo/fixed-data-table/tree/dist\nMy Travis build logs: https://travis-ci.org/justinwoo/fixed-data-table/builds/49274669\nWith less than 10 minutes of work, we can get Travis to start building assets for our Github projects, and we can stop worrying about troubles we might run into with built asset conflicts and committing. Yay~\nFor tagged releases, you will probably want to still force adding your assets or publish them elsewhere, but this will work for our development process and for our edge asset users.\n\nReferences\nDomenic Denicola's original gist on auto-deploying to gh-pages with Travis: https://gist.github.com/domenic/ec8b0fc8ab45f39403dd\nTravis docs about adding encrypted keys http://docs.travis-ci.com/user/encryption-keys/\nTravis docs about customizing your builds: http://docs.travis-ci.com/user/customizing-the-build/\n\nThis is something a lot of people still do in the name of simplicity or not requiring tooling on everyone's machines. A lot of projects still either add `dist/` to `.gitignore` or just prohibit users from checking in their changes to `dist/` (that might arise from normal development or running a `dist/` building script).\n\nIn other cases, built assets are checked in because some developers on your team might not have the necessary tooling installed on their machines. Why should Java developers have Node/IO.js installed on their machines? (i.e. if you're developing \"monolithic\" applications)\n\nThe main arguments I have against this:\n\n1. Why check in things that are generated anyway?\n2. Merge conflicts for minified/compressed files are stupid to resolve when rebasing/merging, because often you will just get blocked having to rebuild assets for no good reason.\n3. If you have normal merge conflicts to resolve, your effort to resolve them also includes building these assets and testing them again to see if they work.\n\nEnough with the stupid intro, time to get to the how.\n\n# How\n\n## Add configuration for your CI tool\n\nI use [Travis](http://docs.travis-ci.com/) on Github, so I add a `.travis.yml`:\n\n```yml\n+script: bash build_helpers/buildDistFromTravis.sh\n+env:\n  global:\n  - GH_REF: github.com/{{myusername}}/{{my-repo}}\n  - secure: {{encrypted key goes here}}\nlanguage: node_js\nnode_js:\n- \"0.10\"\n```\n\nIn Travis, you specify what script needs to be run by using the `script` property. In this case, I am telling to run `bash build_helpers/buildDistFromTravis.sh`.\n\nSee the [Travis docs about adding encrypted keys](http://docs.travis-ci.com/user/encryption-keys/)\n\n## Add your shell script for what to do\n\nIn my case, I would be adding `build_helpers/buildDistFromTravis.sh`, let's do that:\n\n```sh\n#!/bin/bash\nset -e #Set errors to fail explicitly\n\n# in Travis, the git version is 1.8.5, so we need to use rev-parse to get the name of the branch\nbranch_name=\"$(git rev-parse --abbrev-ref HEAD)\"\n\n# I only want to build and commit if I'm on master\nif [ \"$branch_name\" == \"master\" ]\nthen\n  # build dist\n  npm run build-dist\n\n  # initialize and commit everything in pages\n  cd dist\n  git init\n  git config user.name \"Travis\"\n  git config user.email \"Travis\"\n  git add .\n  git commit -m \"build dist assets and commit to dist\"\n\n  # hide my output for security reasons\n  # force it because we want this to just actually work\n  # note, I'm pushing to a remote branch for the dist assets from master\n  git push --force --quiet \"https://${GH_TOKEN}@${GH_REF}\" master:dist > /dev/null 2>&1\nelse\n  echo \"Current branch is not master and dist will not be built or committed.\"\nfi\n```\n\n# Result\n\nSimple enough, right? You can see how it worked out here:\n\nMy master branch: https://github.com/justinwoo/fixed-data-table/tree/master\n\nMy built dist branch: https://github.com/justinwoo/fixed-data-table/tree/dist\n\nMy Travis build logs: https://travis-ci.org/justinwoo/fixed-data-table/builds/49274669\n\nWith less than 10 minutes of work, we can get Travis to start building assets for our Github projects, and we can stop worrying about troubles we might run into with built asset conflicts and committing. Yay~\n\nFor tagged releases, you will probably want to still force adding your assets or publish them elsewhere, but this will work for our development process and for our edge asset users.\n\n# References\n\nDomenic Denicola's original gist on auto-deploying to gh-pages with Travis: https://gist.github.com/domenic/ec8b0fc8ab45f39403dd\n\nTravis docs about adding encrypted keys http://docs.travis-ci.com/user/encryption-keys/\n\nTravis docs about customizing your builds: http://docs.travis-ci.com/user/customizing-the-build/\n\n\n", "tags": ["assets", "Git", "CI", "travis", "dist"]}