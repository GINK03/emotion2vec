{"context": "\n\n\u306f\u3058\u3081\u306b\nFFmpeg\u3067\u306fAAC\u306esample_fmt\u304c\u30c7\u30d5\u30a9\u30eb\u30c8\u3067fltp\u306b\u306a\u3063\u3066\u3044\u307e\u3059\u3002\n\u30bd\u30fc\u30b9\u30b3\u30fc\u30c9\u3084\u30e1\u30fc\u30ea\u30f3\u30b0\u30ea\u30b9\u30c8\u3092\u8abf\u3079\u3066\u307f\u307e\u3057\u305f\u3002\n\nffmpeg-3.0.3\nffmpeg-3.0.3\u306e\u30bd\u30fc\u30b9\u30b3\u30fc\u30c9\u3092\u898b\u3066\u307f\u307e\u3059\u3002\n\nlibavcodec/aacdec.c\n\naacdec.c\nAVCodec ff_aac_decoder = {\n    .name            = \"aac\",\n    .long_name       = NULL_IF_CONFIG_SMALL(\"AAC (Advanced Audio Coding)\"),\n    .type            = AVMEDIA_TYPE_AUDIO,\n    .id              = AV_CODEC_ID_AAC,\n    .priv_data_size  = sizeof(AACContext),\n    .init            = aac_decode_init,\n    .close           = aac_decode_close,\n    .decode          = aac_decode_frame,\n    .sample_fmts     = (const enum AVSampleFormat[]) {\n        AV_SAMPLE_FMT_FLTP, AV_SAMPLE_FMT_NONE\n    },\n    .capabilities    = AV_CODEC_CAP_CHANNEL_CONF | AV_CODEC_CAP_DR1,\n    .caps_internal   = FF_CODEC_CAP_INIT_THREADSAFE,\n    .channel_layouts = aac_channel_layout,\n    .flush = flush,\n    .priv_class      = &aac_decoder_class,\n    .profiles        = NULL_IF_CONFIG_SMALL(ff_aac_profiles),\n};\n\n\n\u4ee5\u4e0b\u306e\u901a\u308a\u3001AV_SAMPLE_FMT_FLTP\u3057\u304b\u53d7\u3051\u4ed8\u3051\u3089\u308c\u306a\u304f\u306a\u3063\u3066\u3044\u307e\u3057\u305f\u3002\n    .sample_fmts     = (const enum AVSampleFormat[]) {\n        AV_SAMPLE_FMT_FLTP, AV_SAMPLE_FMT_NONE\n    },\n\n\naacdec_template.c\n\u30c7\u30b3\u30fc\u30c9\u521d\u671f\u5316aac_decode_init\u306faacdec_template.c\u306b\u3042\u308a\u307e\u3059\u3002\n\naacdec_template.c\nstatic av_cold int aac_decode_init(AVCodecContext *avctx)\n{\n    AACContext *ac = avctx->priv_data;\n    int ret;\n\n    ret = ff_thread_once(&aac_table_init, &aac_static_table_init);\n    if (ret != 0)\n        return AVERROR_UNKNOWN;\n\n    ac->avctx = avctx;\n    ac->oc[1].m4ac.sample_rate = avctx->sample_rate;\n\n    aacdec_init(ac);\n#if USE_FIXED\n    avctx->sample_fmt = AV_SAMPLE_FMT_S32P;\n#else\n    avctx->sample_fmt = AV_SAMPLE_FMT_FLTP;\n#endif /* USE_FIXED */\n\n\n\u4ee5\u4e0b\u306e\u901a\u308a\u3001USE_FIXED\u304cdefine\u3055\u308c\u3066\u3044\u306a\u3051\u308c\u3070\u56fa\u5b9a\u3067AV_SAMPLE_FMT_FLTP\u306b\u306a\u308a\u307e\u3059\u3002\n#if USE_FIXED\n    avctx->sample_fmt = AV_SAMPLE_FMT_S32P;\n#else\n    avctx->sample_fmt = AV_SAMPLE_FMT_FLTP;\n#endif /* USE_FIXED */\n\n\u30aa\u30d7\u30b7\u30e7\u30f3\u6307\u5b9a\u3067s16\u306b\u3067\u304d\u306a\u3044\u3082\u306e\u304b\u3068\u601d\u3063\u3066\u3044\u307e\u3057\u305f\u304c\u30bd\u30fc\u30b9\u30b3\u30fc\u30c9\u4e0a\u3067\u56fa\u5b9a\u3067fltp\u306b\u306a\u3063\u3066\u3044\u308b\u3053\u3068\u304c\u5206\u304b\u308a\u307e\u3057\u305f\u3002\n\ngit\u4e0a\u306e\u4fee\u6b63\nfltp\u56fa\u5b9a\u306b\u5909\u66f4\u3057\u305f\u3068\u304d\u306e\u4fee\u6b63\u306f\u4ee5\u4e0b\u3067\u3059\u3002\n\naacdec: use float planar sample format for output\nhttps://github.com/FFmpeg/FFmpeg/commit/3d3cf6745e2a5dc9c377244454c3186d75b177fa\n\n\n\u5909\u66f4\u3057\u305f\u7406\u7531\n[FFmpeg-user] what is \"fltp\" for audio when using ffmpeg\n\u30e1\u30fc\u30ea\u30f3\u30b0\u30ea\u30b9\u30c8\u306e\u8a18\u8f09\u306b\u3088\u308b\u3068fltp\u306b\u3057\u305f\u76ee\u7684\u306f\u4ee5\u4e0b\u3068\u306e\u3053\u3068\u3002\n\nThe main target is to eliminate extra processing in audio decoders and move\nout it to dedicated re-sampling library.\n\n# \u306f\u3058\u3081\u306b\nFFmpeg\u3067\u306fAAC\u306esample_fmt\u304c\u30c7\u30d5\u30a9\u30eb\u30c8\u3067fltp\u306b\u306a\u3063\u3066\u3044\u307e\u3059\u3002\n\u30bd\u30fc\u30b9\u30b3\u30fc\u30c9\u3084\u30e1\u30fc\u30ea\u30f3\u30b0\u30ea\u30b9\u30c8\u3092\u8abf\u3079\u3066\u307f\u307e\u3057\u305f\u3002\n\n# ffmpeg-3.0.3\n[ffmpeg-3.0.3](https://ffmpeg.org/releases/)\u306e\u30bd\u30fc\u30b9\u30b3\u30fc\u30c9\u3092\u898b\u3066\u307f\u307e\u3059\u3002\n\n## libavcodec/aacdec.c\n\n```c:aacdec.c\nAVCodec ff_aac_decoder = {\n    .name            = \"aac\",\n    .long_name       = NULL_IF_CONFIG_SMALL(\"AAC (Advanced Audio Coding)\"),\n    .type            = AVMEDIA_TYPE_AUDIO,\n    .id              = AV_CODEC_ID_AAC,\n    .priv_data_size  = sizeof(AACContext),\n    .init            = aac_decode_init,\n    .close           = aac_decode_close,\n    .decode          = aac_decode_frame,\n    .sample_fmts     = (const enum AVSampleFormat[]) {\n        AV_SAMPLE_FMT_FLTP, AV_SAMPLE_FMT_NONE\n    },\n    .capabilities    = AV_CODEC_CAP_CHANNEL_CONF | AV_CODEC_CAP_DR1,\n    .caps_internal   = FF_CODEC_CAP_INIT_THREADSAFE,\n    .channel_layouts = aac_channel_layout,\n    .flush = flush,\n    .priv_class      = &aac_decoder_class,\n    .profiles        = NULL_IF_CONFIG_SMALL(ff_aac_profiles),\n};\n```\n\n\u4ee5\u4e0b\u306e\u901a\u308a\u3001AV_SAMPLE_FMT_FLTP\u3057\u304b\u53d7\u3051\u4ed8\u3051\u3089\u308c\u306a\u304f\u306a\u3063\u3066\u3044\u307e\u3057\u305f\u3002\n\n```c\n    .sample_fmts     = (const enum AVSampleFormat[]) {\n        AV_SAMPLE_FMT_FLTP, AV_SAMPLE_FMT_NONE\n    },\n```\n\n## aacdec_template.c\n\u30c7\u30b3\u30fc\u30c9\u521d\u671f\u5316aac_decode_init\u306faacdec_template.c\u306b\u3042\u308a\u307e\u3059\u3002\n\n```c:aacdec_template.c\nstatic av_cold int aac_decode_init(AVCodecContext *avctx)\n{\n    AACContext *ac = avctx->priv_data;\n    int ret;\n\n    ret = ff_thread_once(&aac_table_init, &aac_static_table_init);\n    if (ret != 0)\n        return AVERROR_UNKNOWN;\n\n    ac->avctx = avctx;\n    ac->oc[1].m4ac.sample_rate = avctx->sample_rate;\n\n    aacdec_init(ac);\n#if USE_FIXED\n    avctx->sample_fmt = AV_SAMPLE_FMT_S32P;\n#else\n    avctx->sample_fmt = AV_SAMPLE_FMT_FLTP;\n#endif /* USE_FIXED */\n```\n\n\u4ee5\u4e0b\u306e\u901a\u308a\u3001USE_FIXED\u304cdefine\u3055\u308c\u3066\u3044\u306a\u3051\u308c\u3070\u56fa\u5b9a\u3067AV_SAMPLE_FMT_FLTP\u306b\u306a\u308a\u307e\u3059\u3002\n\n```c:\n#if USE_FIXED\n    avctx->sample_fmt = AV_SAMPLE_FMT_S32P;\n#else\n    avctx->sample_fmt = AV_SAMPLE_FMT_FLTP;\n#endif /* USE_FIXED */\n```\n\n\u30aa\u30d7\u30b7\u30e7\u30f3\u6307\u5b9a\u3067s16\u306b\u3067\u304d\u306a\u3044\u3082\u306e\u304b\u3068\u601d\u3063\u3066\u3044\u307e\u3057\u305f\u304c\u30bd\u30fc\u30b9\u30b3\u30fc\u30c9\u4e0a\u3067\u56fa\u5b9a\u3067fltp\u306b\u306a\u3063\u3066\u3044\u308b\u3053\u3068\u304c\u5206\u304b\u308a\u307e\u3057\u305f\u3002\n\n# git\u4e0a\u306e\u4fee\u6b63\nfltp\u56fa\u5b9a\u306b\u5909\u66f4\u3057\u305f\u3068\u304d\u306e\u4fee\u6b63\u306f\u4ee5\u4e0b\u3067\u3059\u3002\n\n> aacdec: use float planar sample format for output\n> https://github.com/FFmpeg/FFmpeg/commit/3d3cf6745e2a5dc9c377244454c3186d75b177fa\n\n# \u5909\u66f4\u3057\u305f\u7406\u7531\n\n[[FFmpeg-user] what is \"fltp\" for audio when using ffmpeg](https://lists.ffmpeg.org/pipermail/ffmpeg-user/2013-July/016540.html)\n\n\u30e1\u30fc\u30ea\u30f3\u30b0\u30ea\u30b9\u30c8\u306e\u8a18\u8f09\u306b\u3088\u308b\u3068fltp\u306b\u3057\u305f\u76ee\u7684\u306f\u4ee5\u4e0b\u3068\u306e\u3053\u3068\u3002\n> The main target is to eliminate extra processing in audio decoders and move\n> out it to dedicated re-sampling library.\n", "tags": ["ffmpeg", "aac", "32bit-float", "PCM", "libavcodec"]}