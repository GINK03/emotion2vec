{"context": "\n\n\u306f\u3058\u3081\u306b\n\u524d\u56de\u307e\u3067\u306fsin\u304b\u3089\u89d2\u5ea6(theta)\u306e\u3088\u3046\u306b1\u5165\u529b1\u51fa\u529b\u3057\u304b\u5b66\u7fd2\u3057\u3066\u3044\u307e\u305b\u3093\u3067\u3057\u305f\u304c\u3001\u4eca\u56de\u306fsin\u3068cos\u304b\u3089\u89d2\u5ea6\u306e\u3088\u3046\u306b2\u5165\u529b1\u51fa\u529b\u3092\u5b66\u7fd2\u3057\u3088\u3046\u3068\u601d\u3044\u307e\u3059\u3002\n\n\u74b0\u5883\n\npython: 2.7.6\nchainer: 1.8.0\n\n\n\u5b66\u7fd2\u5185\u5bb9\nsin\u3068cos(0\u301c2\u03c0)\u304b\u3089\u89d2\u5ea6(theta)\u3092\u5b66\u7fd2\u3059\u308b\u3002\n[training data]\n\ninput: sin, cos(0~2\u03c0, 1000\u5206\u5272)\noutput: theta\n\n\n\u5b66\u7fd2\u30c7\u30fc\u30bf\ndef get_dataset(N):\n    theta = np.linspace(0, 2 * np.pi, N)\n    sin = np.sin(theta)\n    cos = np.cos(theta)\n\n    x = np.c_[sin, cos]\n    y = theta\n\n    return x, y\n\n\n\n\u5b9f\u88c5\n\n\u30e6\u30cb\u30c3\u30c8\u6570\u306e\u8a2d\u5b9a\n\u5165\u529b\u5c64(in_units)\u3068\u51fa\u529b\u5c64(out_units)\u306e\u30e6\u30cb\u30c3\u30c8\u6570\u3092\u8a2d\u5b9a\u3059\u308b\u3088\u3046\u306b\u3057\u305f\u305f\u3081\u524d\u56de\u307e\u3067\u306e\u30b3\u30fc\u30c9\u3088\u308a\u5c11\u3057\u3060\u3051\u6c4e\u7528\u6027\u304c\u5897\u3048\u307e\u3057\u305f\u3002\n\n\u30d0\u30c3\u30c1\u5b66\u7fd2\nclass MyChain(Chain):\n    def __init__(self, in_units=1, n_units=10, out_units=1):\n        super(MyChain, self).__init__(\n             l1=L.Linear(in_units, n_units),\n             l2=L.Linear(n_units, n_units),\n             l3=L.Linear(n_units, out_units))\n        self.in_units = in_units\n        self.out_units = out_units\n\n\n\n\u5b66\u7fd2\u30d1\u30e9\u30e1\u30fc\u30bf\n\n\u30df\u30cb\u30d0\u30c3\u30c1\u30b5\u30a4\u30ba(batchsize): 20\n\u30a8\u30dd\u30c3\u30af(n_epoch): 500\n\u96a0\u308c\u5c64\u306e\u6570: 2\n\u5165\u529b\u5c64\u306e\u30e6\u30cb\u30c3\u30c8\u6570(in_units): 2\n\u96a0\u308c\u5c64\u306e\u30e6\u30cb\u30c3\u30c8\u6570(n_units): 100\n\u51fa\u529b\u5c64\u306e\u30e6\u30cb\u30c3\u30c8\u6570(out_units): 1\n\u6d3b\u6027\u5316\u95a2\u6570: \u6b63\u898f\u5316\u7dda\u5f62\u95a2\u6570(relu)\n\u30c9\u30ed\u30c3\u30d7\u30a2\u30a6\u30c8(dropout): \u306a\u3057(0%)\n\u6700\u9069\u5316: Adam\n\u640d\u5931\u8aa4\u5dee\u95a2\u6570: \u5e73\u5747\u4e8c\u4e57\u8aa4\u5dee\u95a2\u6570(mean_squared_error)\n\n\u30d1\u30e9\u30e1\u30fc\u30bf\u306f\u5168\u3066\u9069\u5f53\u3002\n\n\u30b3\u30fc\u30c9\u5168\u4f53\n\n\u5168\u4f53\n# -*- coding: utf-8 -*-\n\n# \u3068\u308a\u3042\u3048\u305a\u7247\u3063\u7aef\u304b\u3089import\nimport numpy as np\nimport chainer\nfrom chainer import cuda, Function, gradient_check, Variable, optimizers, serializers, utils\nfrom chainer import Link, Chain, ChainList\nimport chainer.functions as F\nimport chainer.links as L\nimport time\nfrom matplotlib import pyplot as plt\n\n# \u30c7\u30fc\u30bf\ndef get_dataset(N):\n    theta = np.linspace(0, 2 * np.pi, N)\n    sin = np.sin(theta)\n    cos = np.cos(theta)\n\n    x = np.c_[sin, cos]\n    y = theta\n\n    return x, y\n\n# \u30cb\u30e5\u30fc\u30e9\u30eb\u30cd\u30c3\u30c8\u30ef\u30fc\u30af\nclass MyChain(Chain):\n    def __init__(self, in_units=1, n_units=10, out_units=1):\n        super(MyChain, self).__init__(\n             l1=L.Linear(in_units, n_units),\n             l2=L.Linear(n_units, n_units),\n             l3=L.Linear(n_units, out_units))\n        self.in_units = in_units\n        self.out_units = out_units\n\n    def __call__(self, x_data, y_data):\n        x = Variable(x_data.astype(np.float32).reshape(len(x_data),self.in_units)) # Variable\u30aa\u30d6\u30b8\u30a7\u30af\u30c8\u306b\u5909\u63db\n        y = Variable(y_data.astype(np.float32).reshape(len(y_data),self.out_units)) # Variable\u30aa\u30d6\u30b8\u30a7\u30af\u30c8\u306b\u5909\u63db\n        return F.mean_squared_error(self.predict(x), y)\n\n    def  predict(self, x):\n        h1 = F.relu(self.l1(x))\n        h2 = F.relu(self.l2(h1))\n        h3 = self.l3(h2)\n        return h3\n\n    def get_predata(self, x):\n        return self.predict(Variable(x.astype(np.float32).reshape(len(x),self.in_units))).data\n\n# main\nif __name__ == \"__main__\":\n\n    # \u5b66\u7fd2\u30c7\u30fc\u30bf\n    N = 1000\n    x_train, y_train = get_dataset(N)\n\n    # \u30c6\u30b9\u30c8\u30c7\u30fc\u30bf\n    N_test = 900\n    x_test, y_test = get_dataset(N_test)\n\n    # \u5b66\u7fd2\u30d1\u30e9\u30e1\u30fc\u30bf\n    batchsize = 10\n    n_epoch = 500\n    in_units = 2\n    n_units = 100\n    out_units = 1\n\n    # \u30e2\u30c7\u30eb\u4f5c\u6210\n    model = MyChain(in_units, n_units, out_units)\n    optimizer = optimizers.Adam()\n    optimizer.setup(model)\n\n    # \u5b66\u7fd2\u30eb\u30fc\u30d7\n    print \"start...\"\n    train_losses =[]\n    test_losses =[]\n    start_time = time.time()\n    for epoch in range(1, n_epoch + 1):\n\n        # training\n        perm = np.random.permutation(N)\n        sum_loss = 0\n        for i in range(0, N, batchsize):\n            x_batch = x_train[perm[i:i + batchsize]]\n            y_batch = y_train[perm[i:i + batchsize]]\n            model.zerograds()\n            loss = model(x_batch,y_batch)\n            sum_loss += loss.data * batchsize\n            loss.backward()\n            optimizer.update()\n\n        average_loss = sum_loss / N\n        train_losses.append(average_loss)\n\n        # test\n        loss = model(x_test, y_test)\n        test_losses.append(loss.data)\n\n        # \u5b66\u7fd2\u904e\u7a0b\u3092\u51fa\u529b\n        if epoch % 10 == 0:\n            print \"epoch: {}/{} train loss: {} test loss: {}\".format(epoch, n_epoch, average_loss, loss.data)\n\n    interval = int(time.time() - start_time)\n    print \"\u5b9f\u884c\u6642\u9593(normal): {}sec\".format(interval)\n    print \"end\"\n\n    # \u8aa4\u5dee\u306e\u30b0\u30e9\u30d5\u4f5c\u6210\n    plt.plot(train_losses, label = \"train_loss\")\n    plt.plot(test_losses, label = \"test_loss\")\n    plt.yscale('log')\n    plt.legend()\n    plt.grid(True)\n    plt.title(\"loss\")\n    plt.xlabel(\"epoch\")\n    plt.ylabel(\"loss\")\n    plt.show()\n\n    # \u5b66\u7fd2\u7d50\u679c\u306e\u30b0\u30e9\u30d5\u4f5c\u6210\n    sin, cos = np.hsplit(x_test ,in_units)\n    theta = y_test\n    test = model.get_predata(x_test)\n\n    plt.subplot(3, 1, 1)\n    plt.plot(theta, sin, \"b\", label = \"sin\")\n    plt.legend(loc = \"upper left\")\n    plt.grid(True)\n    plt.xlim(0, 2 * np.pi)\n    plt.ylim(-1.2, 1.2)\n\n    plt.subplot(3, 1, 2)\n    plt.plot(theta, cos, \"g\", label = \"cos\")\n    plt.legend(loc = \"upper left\")\n    plt.grid(True)\n    plt.xlim(0, 2 * np.pi)\n    plt.ylim(-1.2, 1.2)\n\n    plt.subplot(3, 1, 3)\n    plt.plot(theta, theta, \"r\", label = \"theta\")\n    plt.plot(theta, test, \"c\", label = \"test\")\n    plt.legend(loc = \"upper left\")\n    plt.grid(True)\n    plt.xlim(0, 2 * np.pi)\n    plt.ylim(-0.5, 7)\n\n    plt.tight_layout()\n    plt.show()\n\n\n\n\u5b9f\u884c\u7d50\u679c\n\n\u8aa4\u5dee\n\u30a8\u30dd\u30c3\u30af\u6570\u304c500\u56de\u3067\u306f\u8aa4\u5dee\u304c\u5927\u304d\u3044\u3067\u3059\u3002\u3057\u304b\u3082\u8aa4\u5dee\u306e\u4f4e\u4e0b\u5177\u5408\u304c\u98fd\u548c\u3057\u3066\u304d\u3066\u3044\u308b\u306e\u3067\u5927\u5e45\u306b\u30a8\u30dd\u30c3\u30af\u6570\u3092\u5897\u3084\u3055\u306a\u3044\u3068\u3053\u308c\u4ee5\u4e0a\u306e\u4f4e\u4e0b\u306f\u671b\u3081\u305d\u3046\u306b\u3042\u308a\u307e\u305b\u3093\u3002\n\n\n\u5b66\u7fd2\u7d50\u679c\n\u51fa\u529b\u304c\u7dda\u5f62\u306a\u3053\u3068\u3082\u3042\u308a\u305d\u308c\u307b\u3069\u8aa4\u5dee\u304c\u5927\u304d\u3044\u3088\u3046\u306b\u306f\u898b\u3048\u307e\u305b\u3093\u3002\n\n\n\u5165\u529b\u306b\u642c\u9001\u6ce2\u3092\u639b\u3051\u5408\u308f\u305b\u305f\u5834\u5408\n\u5165\u529b\u306esin\u3068cos\u306b\u642c\u9001\u6ce2\u3092\u639b\u3051\u5408\u308f\u305b\u305f\u5834\u5408\u3082\u78ba\u8a8d\u3057\u307e\u3057\u305f\u3002(\u642c\u9001\u6ce2\u3082\u5165\u529b\u3057\u30663\u5165\u529b1\u51fa\u529b)\n\u3053\u308c\u306f\u30e2\u30fc\u30bf\u306e\u89d2\u5ea6\u3092\u691c\u51fa\u3059\u308b\u30ec\u30be\u30eb\u30d0\u3068\u540c\u3058\u539f\u7406\u3067\u3059\u3002\n\n\u642c\u9001\u6ce2\u3042\u308a\u306e\u5b66\u7fd2\u30c7\u30fc\u30bf\ndef get_dataset(N):\n    theta = np.linspace(0, 2 * np.pi, N)\n    ref = np.sin(40 * theta) # \u642c\u9001\u6ce2\n    sin = np.sin(theta) * ref\n    cos = np.cos(theta) * ref\n\n    x = np.c_[sin, cos, ref]\n    y = theta\n\n    return x, y\n\n# in_units\u30923\u306b\u5909\u66f4\n\n\n\u5165\u529b\u304c\u8907\u96d1\u306b\u306a\u3063\u305f\u305f\u3081\u898b\u305f\u76ee\u3067\u3082\u8aa4\u5dee\u304c\u5927\u304d\u3044\u3053\u3068\u304c\u78ba\u8a8d\u3067\u304d\u307e\u3059\u3002\u9ad8\u8abf\u6ce2\u6210\u5206\u304c\u6b8b\u3063\u3066\u3044\u307e\u3059\u3002\n\n\n\u307e\u3068\u3081\n\u8aa4\u5dee\u306f\u5927\u304d\u3044\u3082\u306e\u306esin\u3068cos\u304b\u3089\u89d2\u5ea6\u3092\u5b66\u7fd2\u3059\u308b\u3053\u3068\u304c\u3067\u304d\u307e\u3057\u305f\u3002(2\u5165\u529b1\u51fa\u529b)\n\u642c\u9001\u6ce2\u3092\u639b\u3051\u5408\u308f\u3057\u305f\u30ec\u30be\u30eb\u30d0\u306e\u6ce2\u5f62\u304b\u3089\u3082\u89d2\u5ea6\u3092\u5b66\u7fd2\u3059\u308b\u3053\u3068\u304c\u3067\u304d\u307e\u3057\u305f\u3002\u305f\u3060\u3057\u9ad8\u8abf\u6ce2\u6210\u5206\u304c\u767a\u751f\u3057\u307e\u3057\u305f\u3002\n\u5927\u3057\u305f\u3053\u3068\u304c\u306a\u3044\u5b66\u7fd2\u5185\u5bb9\u3060\u3063\u305f\u306e\u3067\u3001\u3082\u3063\u3068\u7cbe\u5ea6\u3088\u304f\u5b66\u7fd2\u3067\u304d\u308b\u3068\u601d\u3063\u3066\u3044\u305f\u306e\u3067\u3059\u304c\u8aa4\u5dee\u304c\u5927\u304d\u304f\u3066\u9a5a\u3044\u3066\u3044\u307e\u3059\u3002\u4eca\u5f8c\u306f\u3082\u3063\u3068\u8907\u96d1\u306a\u5185\u5bb9\u3092\u5b66\u7fd2\u3055\u305b\u305f\u3044\u3068\u601d\u3063\u3066\u3044\u308b\u306e\u3067\u3053\u306e\u5148\u304c\u601d\u3044\u3084\u308c\u307e\u3059\u2026\n# \u306f\u3058\u3081\u306b\n[\u524d\u56de](http://qiita.com/hikobotch/items/78b53de44069fb19d311)\u307e\u3067\u306fsin\u304b\u3089\u89d2\u5ea6(theta)\u306e\u3088\u3046\u306b1\u5165\u529b1\u51fa\u529b\u3057\u304b\u5b66\u7fd2\u3057\u3066\u3044\u307e\u305b\u3093\u3067\u3057\u305f\u304c\u3001\u4eca\u56de\u306fsin\u3068cos\u304b\u3089\u89d2\u5ea6\u306e\u3088\u3046\u306b2\u5165\u529b1\u51fa\u529b\u3092\u5b66\u7fd2\u3057\u3088\u3046\u3068\u601d\u3044\u307e\u3059\u3002\n\n# \u74b0\u5883\n+ python: 2.7.6\n+ chainer: 1.8.0\n\n# \u5b66\u7fd2\u5185\u5bb9\nsin\u3068cos(0\u301c2\u03c0)\u304b\u3089\u89d2\u5ea6(theta)\u3092\u5b66\u7fd2\u3059\u308b\u3002\n\n[training data]\n\n+ input: sin, cos(0~2\u03c0, 1000\u5206\u5272)\n+ output: theta\n\n```python:\u5b66\u7fd2\u30c7\u30fc\u30bf\ndef get_dataset(N):\n    theta = np.linspace(0, 2 * np.pi, N)\n    sin = np.sin(theta)\n    cos = np.cos(theta)\n\n    x = np.c_[sin, cos]\n    y = theta\n\n    return x, y\n```\n\n# \u5b9f\u88c5\n## \u30e6\u30cb\u30c3\u30c8\u6570\u306e\u8a2d\u5b9a\n\u5165\u529b\u5c64(in_units)\u3068\u51fa\u529b\u5c64(out_units)\u306e\u30e6\u30cb\u30c3\u30c8\u6570\u3092\u8a2d\u5b9a\u3059\u308b\u3088\u3046\u306b\u3057\u305f\u305f\u3081\u524d\u56de\u307e\u3067\u306e\u30b3\u30fc\u30c9\u3088\u308a\u5c11\u3057\u3060\u3051\u6c4e\u7528\u6027\u304c\u5897\u3048\u307e\u3057\u305f\u3002\n\n```python:\u30d0\u30c3\u30c1\u5b66\u7fd2\nclass MyChain(Chain):\n    def __init__(self, in_units=1, n_units=10, out_units=1):\n        super(MyChain, self).__init__(\n             l1=L.Linear(in_units, n_units),\n             l2=L.Linear(n_units, n_units),\n             l3=L.Linear(n_units, out_units))\n        self.in_units = in_units\n        self.out_units = out_units\n```\n\n## \u5b66\u7fd2\u30d1\u30e9\u30e1\u30fc\u30bf\n\n+ \u30df\u30cb\u30d0\u30c3\u30c1\u30b5\u30a4\u30ba(batchsize): 20\n+ \u30a8\u30dd\u30c3\u30af(n_epoch): 500\n+ \u96a0\u308c\u5c64\u306e\u6570: 2\n+ \u5165\u529b\u5c64\u306e\u30e6\u30cb\u30c3\u30c8\u6570(in_units): 2\n+ \u96a0\u308c\u5c64\u306e\u30e6\u30cb\u30c3\u30c8\u6570(n_units): 100\n+ \u51fa\u529b\u5c64\u306e\u30e6\u30cb\u30c3\u30c8\u6570(out_units): 1\n+ \u6d3b\u6027\u5316\u95a2\u6570: \u6b63\u898f\u5316\u7dda\u5f62\u95a2\u6570(relu)\n+ \u30c9\u30ed\u30c3\u30d7\u30a2\u30a6\u30c8(dropout): \u306a\u3057(0%)\n+ \u6700\u9069\u5316: Adam\n+ \u640d\u5931\u8aa4\u5dee\u95a2\u6570: \u5e73\u5747\u4e8c\u4e57\u8aa4\u5dee\u95a2\u6570(mean_squared_error)\n\n\u30d1\u30e9\u30e1\u30fc\u30bf\u306f\u5168\u3066\u9069\u5f53\u3002\n\n## \u30b3\u30fc\u30c9\u5168\u4f53\n\n```python:\u5168\u4f53\n# -*- coding: utf-8 -*-\n\n# \u3068\u308a\u3042\u3048\u305a\u7247\u3063\u7aef\u304b\u3089import\nimport numpy as np\nimport chainer\nfrom chainer import cuda, Function, gradient_check, Variable, optimizers, serializers, utils\nfrom chainer import Link, Chain, ChainList\nimport chainer.functions as F\nimport chainer.links as L\nimport time\nfrom matplotlib import pyplot as plt\n\n# \u30c7\u30fc\u30bf\ndef get_dataset(N):\n    theta = np.linspace(0, 2 * np.pi, N)\n    sin = np.sin(theta)\n    cos = np.cos(theta)\n\n    x = np.c_[sin, cos]\n    y = theta\n\n    return x, y\n\n# \u30cb\u30e5\u30fc\u30e9\u30eb\u30cd\u30c3\u30c8\u30ef\u30fc\u30af\nclass MyChain(Chain):\n    def __init__(self, in_units=1, n_units=10, out_units=1):\n        super(MyChain, self).__init__(\n             l1=L.Linear(in_units, n_units),\n             l2=L.Linear(n_units, n_units),\n             l3=L.Linear(n_units, out_units))\n        self.in_units = in_units\n        self.out_units = out_units\n\n    def __call__(self, x_data, y_data):\n        x = Variable(x_data.astype(np.float32).reshape(len(x_data),self.in_units)) # Variable\u30aa\u30d6\u30b8\u30a7\u30af\u30c8\u306b\u5909\u63db\n        y = Variable(y_data.astype(np.float32).reshape(len(y_data),self.out_units)) # Variable\u30aa\u30d6\u30b8\u30a7\u30af\u30c8\u306b\u5909\u63db\n        return F.mean_squared_error(self.predict(x), y)\n\n    def  predict(self, x):\n        h1 = F.relu(self.l1(x))\n        h2 = F.relu(self.l2(h1))\n        h3 = self.l3(h2)\n        return h3\n\n    def get_predata(self, x):\n        return self.predict(Variable(x.astype(np.float32).reshape(len(x),self.in_units))).data\n\n# main\nif __name__ == \"__main__\":\n\n    # \u5b66\u7fd2\u30c7\u30fc\u30bf\n    N = 1000\n    x_train, y_train = get_dataset(N)\n\n    # \u30c6\u30b9\u30c8\u30c7\u30fc\u30bf\n    N_test = 900\n    x_test, y_test = get_dataset(N_test)\n\n    # \u5b66\u7fd2\u30d1\u30e9\u30e1\u30fc\u30bf\n    batchsize = 10\n    n_epoch = 500\n    in_units = 2\n    n_units = 100\n    out_units = 1\n\n    # \u30e2\u30c7\u30eb\u4f5c\u6210\n    model = MyChain(in_units, n_units, out_units)\n    optimizer = optimizers.Adam()\n    optimizer.setup(model)\n\n    # \u5b66\u7fd2\u30eb\u30fc\u30d7\n    print \"start...\"\n    train_losses =[]\n    test_losses =[]\n    start_time = time.time()\n    for epoch in range(1, n_epoch + 1):\n\n        # training\n        perm = np.random.permutation(N)\n        sum_loss = 0\n        for i in range(0, N, batchsize):\n            x_batch = x_train[perm[i:i + batchsize]]\n            y_batch = y_train[perm[i:i + batchsize]]\n            model.zerograds()\n            loss = model(x_batch,y_batch)\n            sum_loss += loss.data * batchsize\n            loss.backward()\n            optimizer.update()\n\n        average_loss = sum_loss / N\n        train_losses.append(average_loss)\n\n        # test\n        loss = model(x_test, y_test)\n        test_losses.append(loss.data)\n\n        # \u5b66\u7fd2\u904e\u7a0b\u3092\u51fa\u529b\n        if epoch % 10 == 0:\n            print \"epoch: {}/{} train loss: {} test loss: {}\".format(epoch, n_epoch, average_loss, loss.data)\n\n    interval = int(time.time() - start_time)\n    print \"\u5b9f\u884c\u6642\u9593(normal): {}sec\".format(interval)\n    print \"end\"\n\n    # \u8aa4\u5dee\u306e\u30b0\u30e9\u30d5\u4f5c\u6210\n    plt.plot(train_losses, label = \"train_loss\")\n    plt.plot(test_losses, label = \"test_loss\")\n    plt.yscale('log')\n    plt.legend()\n    plt.grid(True)\n    plt.title(\"loss\")\n    plt.xlabel(\"epoch\")\n    plt.ylabel(\"loss\")\n    plt.show()\n\n    # \u5b66\u7fd2\u7d50\u679c\u306e\u30b0\u30e9\u30d5\u4f5c\u6210\n    sin, cos = np.hsplit(x_test ,in_units)\n    theta = y_test\n    test = model.get_predata(x_test)\n\n    plt.subplot(3, 1, 1)\n    plt.plot(theta, sin, \"b\", label = \"sin\")\n    plt.legend(loc = \"upper left\")\n    plt.grid(True)\n    plt.xlim(0, 2 * np.pi)\n    plt.ylim(-1.2, 1.2)\n\n    plt.subplot(3, 1, 2)\n    plt.plot(theta, cos, \"g\", label = \"cos\")\n    plt.legend(loc = \"upper left\")\n    plt.grid(True)\n    plt.xlim(0, 2 * np.pi)\n    plt.ylim(-1.2, 1.2)\n\n    plt.subplot(3, 1, 3)\n    plt.plot(theta, theta, \"r\", label = \"theta\")\n    plt.plot(theta, test, \"c\", label = \"test\")\n    plt.legend(loc = \"upper left\")\n    plt.grid(True)\n    plt.xlim(0, 2 * np.pi)\n    plt.ylim(-0.5, 7)\n\n    plt.tight_layout()\n    plt.show()\n```\n\n# \u5b9f\u884c\u7d50\u679c\n## \u8aa4\u5dee\n\u30a8\u30dd\u30c3\u30af\u6570\u304c500\u56de\u3067\u306f\u8aa4\u5dee\u304c\u5927\u304d\u3044\u3067\u3059\u3002\u3057\u304b\u3082\u8aa4\u5dee\u306e\u4f4e\u4e0b\u5177\u5408\u304c\u98fd\u548c\u3057\u3066\u304d\u3066\u3044\u308b\u306e\u3067\u5927\u5e45\u306b\u30a8\u30dd\u30c3\u30af\u6570\u3092\u5897\u3084\u3055\u306a\u3044\u3068\u3053\u308c\u4ee5\u4e0a\u306e\u4f4e\u4e0b\u306f\u671b\u3081\u305d\u3046\u306b\u3042\u308a\u307e\u305b\u3093\u3002\n\n![resolver_simple_loss.png](https://qiita-image-store.s3.amazonaws.com/0/79218/503cddd9-1748-cbf2-9df5-2784d7dc1e62.png)\n\n## \u5b66\u7fd2\u7d50\u679c\n\u51fa\u529b\u304c\u7dda\u5f62\u306a\u3053\u3068\u3082\u3042\u308a\u305d\u308c\u307b\u3069\u8aa4\u5dee\u304c\u5927\u304d\u3044\u3088\u3046\u306b\u306f\u898b\u3048\u307e\u305b\u3093\u3002\n\n![resolver_simple_test.png](https://qiita-image-store.s3.amazonaws.com/0/79218/7d4e404b-f475-a780-a981-0f394a8d537b.png)\n\n## \u5165\u529b\u306b\u642c\u9001\u6ce2\u3092\u639b\u3051\u5408\u308f\u305b\u305f\u5834\u5408\n\u5165\u529b\u306esin\u3068cos\u306b\u642c\u9001\u6ce2\u3092\u639b\u3051\u5408\u308f\u305b\u305f\u5834\u5408\u3082\u78ba\u8a8d\u3057\u307e\u3057\u305f\u3002(\u642c\u9001\u6ce2\u3082\u5165\u529b\u3057\u30663\u5165\u529b1\u51fa\u529b)\n\u3053\u308c\u306f\u30e2\u30fc\u30bf\u306e\u89d2\u5ea6\u3092\u691c\u51fa\u3059\u308b\u30ec\u30be\u30eb\u30d0\u3068\u540c\u3058\u539f\u7406\u3067\u3059\u3002\n\n```python:\u642c\u9001\u6ce2\u3042\u308a\u306e\u5b66\u7fd2\u30c7\u30fc\u30bf\ndef get_dataset(N):\n    theta = np.linspace(0, 2 * np.pi, N)\n    ref = np.sin(40 * theta) # \u642c\u9001\u6ce2\n    sin = np.sin(theta) * ref\n    cos = np.cos(theta) * ref\n\n    x = np.c_[sin, cos, ref]\n    y = theta\n\n    return x, y\n\n# in_units\u30923\u306b\u5909\u66f4\n```\n\n\u5165\u529b\u304c\u8907\u96d1\u306b\u306a\u3063\u305f\u305f\u3081\u898b\u305f\u76ee\u3067\u3082\u8aa4\u5dee\u304c\u5927\u304d\u3044\u3053\u3068\u304c\u78ba\u8a8d\u3067\u304d\u307e\u3059\u3002\u9ad8\u8abf\u6ce2\u6210\u5206\u304c\u6b8b\u3063\u3066\u3044\u307e\u3059\u3002\n\n![resolver_real_test.png](https://qiita-image-store.s3.amazonaws.com/0/79218/7fffc53e-c09a-e22d-970b-5629b77470c7.png)\n\n# \u307e\u3068\u3081\n\u8aa4\u5dee\u306f\u5927\u304d\u3044\u3082\u306e\u306esin\u3068cos\u304b\u3089\u89d2\u5ea6\u3092\u5b66\u7fd2\u3059\u308b\u3053\u3068\u304c\u3067\u304d\u307e\u3057\u305f\u3002(2\u5165\u529b1\u51fa\u529b)\n\u642c\u9001\u6ce2\u3092\u639b\u3051\u5408\u308f\u3057\u305f\u30ec\u30be\u30eb\u30d0\u306e\u6ce2\u5f62\u304b\u3089\u3082\u89d2\u5ea6\u3092\u5b66\u7fd2\u3059\u308b\u3053\u3068\u304c\u3067\u304d\u307e\u3057\u305f\u3002\u305f\u3060\u3057\u9ad8\u8abf\u6ce2\u6210\u5206\u304c\u767a\u751f\u3057\u307e\u3057\u305f\u3002\n\u5927\u3057\u305f\u3053\u3068\u304c\u306a\u3044\u5b66\u7fd2\u5185\u5bb9\u3060\u3063\u305f\u306e\u3067\u3001\u3082\u3063\u3068\u7cbe\u5ea6\u3088\u304f\u5b66\u7fd2\u3067\u304d\u308b\u3068\u601d\u3063\u3066\u3044\u305f\u306e\u3067\u3059\u304c\u8aa4\u5dee\u304c\u5927\u304d\u304f\u3066\u9a5a\u3044\u3066\u3044\u307e\u3059\u3002\u4eca\u5f8c\u306f\u3082\u3063\u3068\u8907\u96d1\u306a\u5185\u5bb9\u3092\u5b66\u7fd2\u3055\u305b\u305f\u3044\u3068\u601d\u3063\u3066\u3044\u308b\u306e\u3067\u3053\u306e\u5148\u304c\u601d\u3044\u3084\u308c\u307e\u3059\u2026\n\n\n", "tags": ["Chainer", "Python", "DeepLearning", "\u6a5f\u68b0\u5b66\u7fd2"]}