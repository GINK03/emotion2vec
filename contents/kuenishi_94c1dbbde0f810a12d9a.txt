{"context": " More than 1 year has passed since last update.When you want to do something \"after N seconds\" in Erlang, the best way to do it is said to be erlang:send_after/3 . But how many memory does it take? How many computation cost does it take?\n\nEntry point\nerlang:send_after/3 can be found as bif at bif.tab . The entry point is at erl_bif_timer.c . This function just calls setup_bif_timer(), which is in the same file. This allocates ErtsBifTimer \n    btm = (ErtsBifTimer *) erts_alloc(ERTS_ALC_T_LL_BIF_TIMER,\n                     sizeof(ErtsBifTimer));\n\nwhich is defined in the same file . This does not include such a big struct other than ErlTimer tm; ( defined in erl_time.h ). Given the struct size is 256B, then registering 10^6 timers costs about 256MB (re-calculate it, please!) . Needs calculation, but and, it is put into timer wheel.\n    tab_insert(btm);\n    ASSERT(btm == tab_find(ref));\n    btm->tm.active = 0; /* MUST be initalized */\n    erts_set_timer(&btm->tm,\n          (ErlTimeoutProc) bif_timer_timeout,\n          (ErlCancelProc) bif_timer_cleanup,\n          (void *) btm,\n          timeout);\n\nbif_timer_timeout is a callback of timeout, and btm->tm is ErlTimer struct.\n\nBefore/After setting timer\nerts_set_timer in time.c is very interesting. Just before setting timer, it moves clock forward by calling erts_deliver_time() .\nvoid\nerts_set_timer(ErlTimer* p, ErlTimeoutProc timeout, ErlCancelProc cancel,\n          void* arg, Uint t)\n{\n\n    erts_deliver_time();\n    erts_smp_mtx_lock(&tiw_lock);\n    if (p->active) { /* XXX assert ? */\n    erts_smp_mtx_unlock(&tiw_lock);\n    return;\n    }\n    p->timeout = timeout;\n    p->cancel = cancel;\n    p->arg = arg;\n    p->active = 1;\n    insert_timer(p, t);\n    erts_smp_mtx_unlock(&tiw_lock);\n#if defined(ERTS_SMP)\n    if (t <= (Uint) ERTS_SHORT_TIME_T_MAX)\n    erts_sys_schedule_interrupt_timed(1, (erts_short_time_t) t);\n#endif\n}\n\nIn insert_timer(p, t); actually timer is registered, but right after it the erts scheduler is interrupted by writing \"!\" write(2) with into scheduler interruption pipe.\n\nSetting timer actually\ninsert_timer is in time.c . tiw might be read as \"timer wheel\" ? maybe. It's actually timer wheel, which has 65536 slots (actually TIW_SLOTS ) . Each slot is for single millisecond and keeps all timers that should be invoked in the single milliseconds. Each slot is just a linked list via pointer and generic prev/next pointer linking.\n   /* calculate slot */\n    tm = (ticks + tiw_pos) % TIW_SIZE;\n    p->slot = (Uint) tm;\n    p->count = (Uint) (ticks / TIW_SIZE);\n\n    /* insert at head of list at slot */\n    p->next = tiw[tm];\n    p->prev = NULL;\n    if (p->next != NULL)\n    p->next->prev = p;\n    tiw[tm] = p;\n\n\n\nInvoking the timer\nerts_bump_timer is the function where these timers are triggered. This function is called by several scheduling logic incling schedule() like here:\n        dt = erts_do_time_read_and_reset();\n    if (dt) erts_bump_timer(dt);\n\nerts_bump_timer_internal is the core part of popping out timed out timers from the timer wheel slot timer.c. Popping out all timer entries to timeout_head and calls all callbacks.\n    /* Call timedout timers callbacks */\n    while (timeout_head) {\n    p = timeout_head;\n    timeout_head = p->next;\n    /* Here comes hairy use of the timer fields!\n     * They are reset without having the lock.\n     * It is assumed that no code but this will\n     * accesses any field until the ->timeout\n     * callback is called.\n     */\n    p->next = NULL;\n    p->prev = NULL;\n    p->slot = 0;\n    (*p->timeout)(p->arg);\n    }\n\nFor erlang:send_after/3 the callback is bif_timer_timeout . This function calls erts_queue_message, which finally stacks the message into target process's msg_q.\n\nConclusion\nThe memory consumption is in order of ~100Bytes per timer. The computation cost is in order of traversing the linked list, whose length is in the same order with Timers stored in each milliseconds.\nSuppose 10K timers continuously stored on memory then the length of each queue is 10K / 65536 by average. This is because each timer slot can be accessed by offset.\n\nNote\nIn *nix gettimeofday(2) is used for clock. This clock cannot be trusted so much because it leaps back but Erlang remembers the former answer of it and if the time diff is negative, the wrong time is ignored and nothing changes.\nWhen you want to do something \"after N seconds\" in Erlang, the best way to do it is said to be `erlang:send_after/3` . But how many memory does it take? How many computation cost does it take?\n\n# Entry point\n\n`erlang:send_after/3` can be found as bif at [bif.tab](https://github.com/erlang/otp/blob/OTP-17.0/erts/emulator/beam/bif.tab#L203) . The entry point is at [erl_bif_timer.c](https://github.com/erlang/otp/blob/OTP-17.0/erts/emulator/beam/erl_bif_timer.c#L493) . This function just calls `setup_bif_timer()`, which is [in the same file](https://github.com/erlang/otp/blob/OTP-17.0/erts/emulator/beam/erl_bif_timer.c#L390). This allocates `ErtsBifTimer` \n\n```c\n\tbtm = (ErtsBifTimer *) erts_alloc(ERTS_ALC_T_LL_BIF_TIMER,\n\t\t\t\t\t sizeof(ErtsBifTimer));\n```\n\nwhich is defined in [the same file](https://github.com/erlang/otp/blob/OTP-17.0/erts/emulator/beam/erl_bif_timer.c#L41) . This does not include such a big struct other than `ErlTimer tm;` ( [defined in erl_time.h](https://github.com/erlang/otp/blob/OTP-17.0/erts/emulator/beam/erl_time.h#L33) ). Given the struct size is 256B, then registering 10^6 timers costs about 256MB (re-calculate it, please!) . Needs calculation, but and, it is put into timer wheel.\n\n```c\n    tab_insert(btm);\n    ASSERT(btm == tab_find(ref));\n    btm->tm.active = 0; /* MUST be initalized */\n    erts_set_timer(&btm->tm,\n\t\t  (ErlTimeoutProc) bif_timer_timeout,\n\t\t  (ErlCancelProc) bif_timer_cleanup,\n\t\t  (void *) btm,\n\t\t  timeout);\n```\n\n`bif_timer_timeout` is a callback of timeout, and `btm->tm` is `ErlTimer` struct.\n\n# Before/After setting timer\n\n[erts_set_timer in time.c](https://github.com/erlang/otp/blob/OTP-17.0/erts/emulator/beam/time.c#L397) is very interesting. Just before setting timer, it moves clock forward by calling `erts_deliver_time()` .\n\n```c\nvoid\nerts_set_timer(ErlTimer* p, ErlTimeoutProc timeout, ErlCancelProc cancel,\n\t      void* arg, Uint t)\n{\n\n    erts_deliver_time();\n    erts_smp_mtx_lock(&tiw_lock);\n    if (p->active) { /* XXX assert ? */\n\terts_smp_mtx_unlock(&tiw_lock);\n\treturn;\n    }\n    p->timeout = timeout;\n    p->cancel = cancel;\n    p->arg = arg;\n    p->active = 1;\n    insert_timer(p, t);\n    erts_smp_mtx_unlock(&tiw_lock);\n#if defined(ERTS_SMP)\n    if (t <= (Uint) ERTS_SHORT_TIME_T_MAX)\n\terts_sys_schedule_interrupt_timed(1, (erts_short_time_t) t);\n#endif\n}\n```\n\nIn `insert_timer(p, t);` actually timer is registered, but right after it the erts scheduler is interrupted by [writing \"!\"](https://github.com/erlang/otp/blob/OTP-17.0/erts/emulator/sys/common/erl_poll.c#L472) `write(2)` with into scheduler interruption pipe.\n\n# Setting timer actually\n\n`insert_timer` is in [time.c](https://github.com/erlang/otp/blob/OTP-17.0/erts/emulator/beam/time.c#L347) . `tiw` might be read as \"timer wheel\" ? maybe. It's actually timer wheel, which has 65536 slots (actually `TIW_SLOTS` ) . Each slot is for single millisecond and keeps all timers that should be invoked in the single milliseconds. Each slot is just a linked list via pointer and generic prev/next pointer linking.\n\n```c\n   /* calculate slot */\n    tm = (ticks + tiw_pos) % TIW_SIZE;\n    p->slot = (Uint) tm;\n    p->count = (Uint) (ticks / TIW_SIZE);\n\n    /* insert at head of list at slot */\n    p->next = tiw[tm];\n    p->prev = NULL;\n    if (p->next != NULL)\n\tp->next->prev = p;\n    tiw[tm] = p;\n\n```\n\n# Invoking the timer\n\n`erts_bump_timer` is the function where these timers are triggered. This function is called by several scheduling logic incling `schedule()` like [here](https://github.com/erlang/otp/blob/OTP-17.0/erts/emulator/beam/erl_process.c#L3012):\n\n```c\n        dt = erts_do_time_read_and_reset();\n\tif (dt) erts_bump_timer(dt);\n```\n\n`erts_bump_timer_internal` is the core part of popping out timed out timers from the timer wheel slot [timer.c](https://github.com/erlang/otp/blob/OTP-17.0/erts/emulator/beam/time.c#L227). Popping out all timer entries to `timeout_head` and calls all callbacks.\n\n```c\n    /* Call timedout timers callbacks */\n    while (timeout_head) {\n\tp = timeout_head;\n\ttimeout_head = p->next;\n\t/* Here comes hairy use of the timer fields!\n\t * They are reset without having the lock.\n\t * It is assumed that no code but this will\n\t * accesses any field until the ->timeout\n\t * callback is called.\n\t */\n\tp->next = NULL;\n\tp->prev = NULL;\n\tp->slot = 0;\n\t(*p->timeout)(p->arg);\n    }\n```\n\nFor `erlang:send_after/3` the callback is [bif_timer_timeout](https://github.com/erlang/otp/blob/OTP-17.0/erts/emulator/beam/erl_bif_timer.c#L302) . This function calls `erts_queue_message`, which finally stacks the message into target process's msg_q.\n\n\n\n# Conclusion\n\nThe memory consumption is in order of ~100Bytes per timer. The computation cost is in order of traversing the linked list, whose length is in the same order with Timers stored in each milliseconds.\n\nSuppose 10K timers continuously stored on memory then the length of each queue is 10K / 65536 by average. This is because each timer slot can be accessed by offset.\n\n\n## Note\n\nIn *nix [gettimeofday(2) is used for clock.] (https://github.com/erlang/otp/blob/OTP-17.0/erts/emulator/sys/unix/erl_unix_sys.h#L162) This clock cannot be trusted so much because it leaps back but Erlang remembers the former answer of it and if the time diff is negative, the wrong time is ignored and nothing changes.\n", "tags": ["Erlang17.0"]}