{"tags": ["Node.js", "Elm", "elmlang", "JavaScript", "webpack"], "context": "Edit2: With the changes in Elm 0.17, it's no longer possible to use a signal-based approach to write applications. As a result, some of the core logic used in the original version is no longer possible. You might be interested in my other post about Node applications written in Purescript (here) or my slides on converting this Elm app into a Purescript app (here)\nEdit: I realize the code blocks can be annoying to read here, so here's a gist version: https://gist.github.com/justinwoo/4fe645643886948cd896\nThis isn't necessarily how you should go about writing an Elm application, or even that great of an idea, but it's one you could take ideas from and transform into something actually viable or useful to you.\nThis won't even really be a tutorial, though the parts are simple enough that you could just rip a lot of what I have and reassemble it. (Kind of like some kind of Danish toy or something)\n\nWhy?\nElm is pretty fun, but there are a lot of things that are just more comfortable to do in Javascript with the huge ecosystem that you can take advantage of. Plus, you can just run Elm as a worker that processes inputs, so why not? Not to mention, if your Elm program compiles, then you know that even if the process produces the wrong result, it's not going to have any runtime errors (from the Elm side) and all your types are abided by.\nAlso because the Node program that I had written before was a mess, so I was going to have to rewrite it anyway.\n\nHow?\n\nSetup\nI went with my same old tooling with webpack and elm-simple-loader (which is a loader for webpack that I wrote to simplify putting my built Elm JS into my bundle), but just slightly modified it for what I needed to work with Node. I really did copy my webpack config over from a browser Elm/JS project: webpack.config.js\n\nElm side source\n\nI figured an Elm program is always valid if it compiles, so I might as well write this part first. For the most part, it was easy (with some warty stupid logic):\n\nI defined what a \"File\" was (just a String representing the filename)\nI defined what a \"Target\" was (a record of File and url where that File existed remotely)\nI tried to think of what features exist now that I wanted to keep:\n\n\nI wanted to ban some files on partial name matches and have a list for these. List File, I guess.\nI didn't want to download files that I already had. Another List File, I guess.\n\n\nI then tried to boil down what my crappy app even does:\n\n\nI needed to get a list of targets from my favorite tracker website. List Target!\nI needed to get back this list of targets that actually needed to be downloaded. Another List Target!\n\n\nAnd then I needed what ports I needed for IO from JS:\n\n\ninputs:\n\n\nbannedWordsSignal\ndownloadedFilesSignal\nfetchedTargetsSignal\n\n\noutputs:\n\n\nrequestDownloadsSignal\n\n\n\n\n\nSo then the main bit of my program is quite simple:\nisBlacklisted : BannedWords -> File -> Bool\nisBlacklisted bannedFiles file =\n  List.any (\\x -> String.contains x file) bannedFiles\n\nisDownloaded : DownloadedFiles -> File -> Bool\nisDownloaded downloadedFiles file =\n  List.any (\\x -> String.contains file x) downloadedFiles\n\nprocessFile : BannedWords -> DownloadedFiles -> Target -> List Target -> List Target\nprocessFile bannedWords downloadedFiles target targets =\n  let\n    name = target.name\n    blacklisted = isBlacklisted bannedWords name\n    downloaded = isDownloaded downloadedFiles name\n  in\n    if | blacklisted || downloaded -> targets\n       | otherwise -> target :: targets\n\n...and then I fold over a list of fetched targets, so I return either targets or targets with a new target.\n\nJavascript side source\n\nOkay, here things are easy enough, I guess. The program flow is like so:\n\nI read my config file to figure out where I'm getting information and what files are banned.\nThen, in parallel, I do the following:\n\n\nI check my downloaded files to fill up my list of what I already have.    * I go fetch my potential targets for downloading.\n\n\nI combine the values retrieved and then I instantiate an Elm worker with the banned words from the config, the downloaded files, and the fetched targets.\nI then subscribe to the requestDownloadSignal port from the worker and download away at the requested targets.\n\nSounds good right? Yeah, it was pretty good, for the most part...\n\nUgly stuff\nSo if you looked at the code and compared it to the description I gave, you might've noticed that I didn't mention this ugly getDownloadsSignal thing. I sure didn't! That's something I spent a bit looking into being annoyed.\nYou know how I'm kind of a RxJS guy? What happens when you have a stream with an initial value and you subscribe to it in Rx? Yeah, you get the initial value sent to you! Well, in Elm Signal land, this is not the case. An initial value can be pulled from and consumed, but is not considered an event to be emitted. I posted about this on the mailing list and didn't really get much of a response: https://groups.google.com/forum/#!topic/elm-discuss/T3PLvJs4ZTo (though, thanks to Max for providing an explanation that people might find useful).\nSo what happens when I instantiate a worker with initial signal values and subscribe to a signal that maps over those values? ...nothing! What does this mean for me? Well, either I need to delay sending one of those values after ensuring the other two have initial values set (eh...), send all three afterwards but have my subscription get send three different items (eh...), or use another signal where I send an undefined that I can just ignore the true value of using Json.Decode.Value as the signal type (eh...). Well, you can see that I chose the third option, and so my code contains bits like this:\nworker.ports.getDownloadsSignal.send();\n\nimport Json.Decode exposing (Value)\n\nport getDownloadsSignal : Signal Value\n\ngetDownloadRequests : BannedWords -> DownloadedFiles -> FetchedTargets -> a -> DownloadRequest\ngetDownloadRequests bannedWords downloadedFiles fetchedTargets _ =\n  List.foldl\n    (processFile bannedWords downloadedFiles)\n    []\n    fetchedTargets\n\nport requestDownloadsSignal : Signal DownloadRequest\nport requestDownloadsSignal =\n  Signal.map4\n    getDownloadRequests\n    bannedWordsSignal\n    downloadedFilesSignal\n    fetchedTargetsSignal\n    getDownloadsSignal\n\nCheck out that last bit where I map over 4 signals, which means that on a new value from any of these signals, I will take the latest/initial value of all of the signals and call the first operand function with all these applied in order. So when I do worker.ports.getDownloadedSignal.send() from JS, it kicks off this mapping and sends a new value to requestDownloadSignal. Works?\n\nRepo\nRepository is here on Github: https://github.com/justinwoo/torscraper\n\nConclusion\nSo I've written a hybrid Elm/JS Node app that I actually use every day now. Was it fun? Yeah, pretty fun. Would I do it again? I'm not really sure. What a stupid thing to say in an article that's supposed to show how this kind of thing can be done, right? Yeah, probably. Sorry.\nAnyway, if you made it this far, thanks! Please let me know if you thought this was amusing or useful or just terrible or something on twitter (@jusrin00) or something!\n\nReferences\n\nElm interop, ports - http://elm-lang.org/guide/interop#ports\n\nSignal.elm - https://github.com/elm-lang/core/blob/master/src/Signal.elm\n\n\nEdit2: With the changes in Elm 0.17, it's no longer possible to use a signal-based approach to write applications. As a result, some of the core logic used in the original version is no longer possible. You might be interested in my other post about Node applications written in Purescript ([here](http://qiita.com/kimagure/items/5674e3ae9c87262af762)) or my slides on converting this Elm app into a Purescript app ([here](https://speakerdeck.com/justinwoo/making-a-simple-purescript-application))\n\nEdit: I realize the code blocks can be annoying to read here, so here's a gist version: https://gist.github.com/justinwoo/4fe645643886948cd896\n\nThis isn't necessarily how you *should* go about writing an Elm application, or even that great of an idea, but it's one you could take ideas from and transform into something actually viable or useful to you.\n\nThis won't even really be a tutorial, though the parts are simple enough that you could just rip a lot of what I have and reassemble it. (Kind of like some kind of Danish toy or something)\n\n# Why?\n\nElm is pretty fun, but there are a lot of things that are just more comfortable to do in Javascript with the huge ecosystem that you can take advantage of. Plus, you can just run Elm as a worker that processes inputs, so why not? Not to mention, if your Elm program compiles, then you know that even if the process produces the wrong result, it's not going to have any runtime errors (from the Elm side) and all your types are abided by.\n\nAlso because the Node program that I had written before was a mess, so I was going to have to rewrite it anyway.\n\n# How?\n\n## Setup\n\nI went with my same old tooling with webpack and elm-simple-loader (which is a loader for webpack that I wrote to simplify putting my built Elm JS into my bundle), but just slightly modified it for what I needed to work with Node. I really did copy my webpack config over from a browser Elm/JS project: [webpack.config.js](https://github.com/justinwoo/torscraper/blob/c3d18e07b3277c7b31aef8a0f619aab7170f7d35/webpack.config.js)\n\n## Elm side [source](https://github.com/justinwoo/torscraper/blob/c3d18e07b3277c7b31aef8a0f619aab7170f7d35/src/Main.elm)\n\nI figured an Elm program is always valid if it compiles, so I might as well write this part first. For the most part, it was easy (with some warty stupid logic):\n\n* I defined what a \"File\" was (just a `String` representing the filename)\n* I defined what a \"Target\" was (a record of `File` and url where that File existed remotely)\n* I tried to think of what features exist now that I wanted to keep:\n\t* I wanted to ban some files on partial name matches and have a list for these. `List File`, I guess.\n\t* I didn't want to download files that I already had. Another `List File`, I guess.\n* I then tried to boil down what my crappy app even does:\n\t* I needed to get a list of targets from my favorite ~~tracker~~ website. `List Target`!\n\t* I needed to get back this list of targets that actually needed to be downloaded. Another `List Target`!\n* And then I needed what ports I needed for IO from JS:\n\t* inputs:\n\t\t* bannedWordsSignal\n\t\t* downloadedFilesSignal\n\t\t* fetchedTargetsSignal\n\t* outputs:\n\t\t* requestDownloadsSignal\n\nSo then the main bit of my program is quite simple:\n\n```elm\nisBlacklisted : BannedWords -> File -> Bool\nisBlacklisted bannedFiles file =\n  List.any (\\x -> String.contains x file) bannedFiles\n\nisDownloaded : DownloadedFiles -> File -> Bool\nisDownloaded downloadedFiles file =\n  List.any (\\x -> String.contains file x) downloadedFiles\n\nprocessFile : BannedWords -> DownloadedFiles -> Target -> List Target -> List Target\nprocessFile bannedWords downloadedFiles target targets =\n  let\n    name = target.name\n    blacklisted = isBlacklisted bannedWords name\n    downloaded = isDownloaded downloadedFiles name\n  in\n    if | blacklisted || downloaded -> targets\n       | otherwise -> target :: targets\n```\n\n...and then I fold over a list of fetched targets, so I return either targets or targets with a new target.\n\n## Javascript side [source](https://github.com/justinwoo/torscraper/blob/c3d18e07b3277c7b31aef8a0f619aab7170f7d35/src/index.js)\n\nOkay, here things are easy enough, I guess. The program flow is like so:\n\n* I read my config file to figure out where I'm getting information and what files are banned.\n* Then, in parallel, I do the following:\n\t* I check my downloaded files to fill up my list of what I already have.\t* I go fetch my potential targets for downloading.\n* I combine the values retrieved and then I instantiate an Elm worker with the banned words from the config, the downloaded files, and the fetched targets.\n* I then subscribe to the requestDownloadSignal port from the worker and download away at the requested targets.\n\nSounds good right? Yeah, it was pretty good, for the most part...\n\n## Ugly stuff\n\nSo if you looked at the code and compared it to the description I gave, you might've noticed that I didn't mention this ugly `getDownloadsSignal` thing. I sure didn't! That's something I spent a bit looking into being annoyed.\n\nYou know how I'm kind of a RxJS guy? What happens when you have a stream with an initial value and you subscribe to it in Rx? Yeah, you get the initial value sent to you! Well, in Elm Signal land, this is not the case. An initial value can be pulled from and consumed, but is not considered an event to be emitted. I posted about this on the mailing list and didn't really get much of a response: https://groups.google.com/forum/#!topic/elm-discuss/T3PLvJs4ZTo (though, thanks to Max for providing an explanation that people might find useful).\n\nSo what happens when I instantiate a worker with initial signal values and subscribe to a signal that maps over those values? ...nothing! What does this mean for me? Well, either I need to delay sending one of those values after ensuring the other two have initial values set (eh...), send all three afterwards but have my subscription get send three different items (eh...), or use another signal where I send an `undefined` that I can just ignore the true value of using `Json.Decode.Value` as the signal type (eh...). Well, you can see that I chose the third option, and so my code contains bits like this:\n\n```js\nworker.ports.getDownloadsSignal.send();\n```\n\n```elm\nimport Json.Decode exposing (Value)\n\nport getDownloadsSignal : Signal Value\n\ngetDownloadRequests : BannedWords -> DownloadedFiles -> FetchedTargets -> a -> DownloadRequest\ngetDownloadRequests bannedWords downloadedFiles fetchedTargets _ =\n  List.foldl\n    (processFile bannedWords downloadedFiles)\n    []\n    fetchedTargets\n    \nport requestDownloadsSignal : Signal DownloadRequest\nport requestDownloadsSignal =\n  Signal.map4\n    getDownloadRequests\n    bannedWordsSignal\n    downloadedFilesSignal\n    fetchedTargetsSignal\n    getDownloadsSignal\n```\n\nCheck out that last bit where I map over 4 signals, which means that on a new value from any of these signals, I will take the latest/initial value of all of the signals and call the first operand function with all these applied in order. So when I do `worker.ports.getDownloadedSignal.send()` from JS, it kicks off this mapping and sends a new value to `requestDownloadSignal`. Works?\n\n## Repo\n\nRepository is here on Github: https://github.com/justinwoo/torscraper\n\n# Conclusion\n\nSo I've written a hybrid Elm/JS Node app that I actually use every day now. Was it fun? Yeah, pretty fun. Would I do it again? I'm not really sure. What a stupid thing to say in an article that's supposed to show how this kind of thing can be done, right? Yeah, probably. Sorry.\n\nAnyway, if you made it this far, thanks! Please let me know if you thought this was amusing or useful or just terrible or something on twitter ([@jusrin00](https://twitter.com/jusrin00)) or something!\n\n# References\n\n* Elm interop, ports - http://elm-lang.org/guide/interop#ports\n* Signal.elm - https://github.com/elm-lang/core/blob/master/src/Signal.elm\n"}