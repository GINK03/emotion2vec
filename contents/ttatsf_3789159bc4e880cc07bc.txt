{"context": "\u5143\u8a18\u4e8b:\u7d44\u5408\u305b\u6700\u9069\u5316\u3067\u30b0\u30eb\u30fc\u30d7\u5206\u3051\n\u5143\u3005\u8a18\u4e8b:\u3010\u65e5\u5e38\u306b\u6f5c\u3080\u6700\u9069\u5316\u554f\u984c\u3011\u53d7\u9a13\u8005\u3092\u306a\u308b\u3079\u304f\u5747\u7b49\u306b\u8a66\u9a13\u4f1a\u5834\u306b\u5272\u308a\u632f\u308b\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0\n\u304c\u52c9\u5f37\u306b\u306a\u3063\u305f\u306e\u3067\u3001Haskell\u3067\u3084\u3063\u3066\u307f\u305f\u30e1\u30e2\u3002\n\n\u4e16\u306e\u4e2d\u306b\u306f\u52d5\u7684\u8a08\u753b\u6cd5\u3068\u3044\u3046\u306e\u304c\u3042\u3063\u3066\u3001\u5358\u7d14\u306b\u6761\u4ef6\u3067\u30d5\u30a3\u30eb\u30bf\u30fc\u3059\u308b\u3060\u3051\u3088\u308a\u3060\u3044\u3076\u52b9\u7387\u304c\u3044\u3044\u305d\u3046\u306a\u3002\n\u3067\u3082\u3001\u96e3\u3057\u305d\u3046...\n\u8a18\u4e8b\u3092\u8aad\u3093\u3060\u3068\u304d\u3001\u3059\u3054\u3044H\u672c\u306b\u3042\u3063\u305f\u7d4c\u8def\u63a2\u7d22\u306b\u4f3c\u3066\u308b!\u3067\u304d\u308b\u304b\u3082...\u3068\u601d\u3063\u3066\u3057\u307e\u3063\u305f\u306e\u304c\u904b\u306e\u3064\u304d\u3002\n\u5168\u7136\u9055\u3063\u305f\u3002\u3081\u3063\u3061\u3083\u96e3\u3057\u3044\u3058\u3083\u3093\u3002\n\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0\u306f\u307b\u307c\u5143\u3005\u8a18\u4e8b\u3068\u540c\u3058\u3067\u3059\u3002\n\u305f\u3060\u3001Haskell\u3067\u3069\u3046\u3084\u308b\u306e?\u3068\u3044\u3046\u3068\u3053\u308d\u3067\u81ea\u5206\u306a\u308a\u306b\u5de5\u592b\u3057\u3066\u307f\u307e\u3057\u305f\u3002\n\nRoomVal.hs \u30c7\u30fc\u30bf\u306e\u578b\u3068\u95a2\u6570\n\u90e8\u5c4b\u306e\u5024\u3068\u305d\u3053\u306b\u81f3\u308b\u307e\u3067\u306e\u90e8\u5c4b\u306e\u5c65\u6b74\u3092\u30bb\u30c3\u30c8\u306b\u3057\u307e\u3057\u305f\u3002\n\u5024\u306f\u90e8\u5c4b\u304c\u5909\u308f\u308b\u3068\u304d\u306b\u56fa\u5b9a\u5316\u3055\u308c\u308b\u90e8\u5206\u3068\u540c\u3058\u90e8\u5c4b\u3067\u307e\u3060\u78ba\u5b9a\u3057\u3066\u3044\u306a\u3044\u90e8\u5206\u306e\u30da\u30a2\u3067\u3059\u3002\n\u5c65\u6b74\u306f\u90e8\u5c4b\u306e\u756a\u53f7\u3068\u30b0\u30eb\u30fc\u30d7\u306e\u756a\u53f7\u306e\u30da\u30a2\u306e\u30ea\u30b9\u30c8\u3067\u3059\u3002\n\u5024\u3068\u5c65\u6b74\u306b\u95a2\u3059\u308b\u95a2\u6570\u3092\u5fc5\u8981\u306b\u306a\u308b\u305f\u3073\u306b\u3053\u3053\u306b\u52a0\u3048\u3066\u3044\u304d\u307e\u3057\u305f\u3002\n\nRoomVal.hs\n\nmodule RoomVal (\n  RoomVal(..)\n  , calcRmVal\n  , fixRmVal\n  , addHistStay\n  , addHistChange\n  , addVal\n  ) where\n\n    data RoomVal = RoomVal{\n    rmVal::(Int , Int)   --(fixed value from former histories,not fixed value for this place) \n    ,rmHist::[(Int,Int)]  -- a list of history(room, group)\n    } deriving (Show)\n\n    calcRmVal :: RoomVal -> Int\n    --Returns an actual room value = (fixed) + (not fixed)^2\n    --From a RoomVal\n    calcRmVal aRmVal = fst x + (snd x ^ 2)\n      where\n        x = rmVal aRmVal\n\n    fixRmVal :: RoomVal -> RoomVal\n    --Returns fixed RoomVal\n    --From a RoomVal not fixed\n    fixRmVal aRmVal = aRmVal{rmVal = (calcRmVal aRmVal, 0)}\n\n    addHistStay :: RoomVal -> RoomVal\n    --Returns a RoomVal a history(to stay the same room) added\n    --From a RoomVal\n    addHistStay aRmVal = aRmVal{ rmHist = (fst x, succ $ snd x) : (x : xs) }\n      where\n        (x : xs) = rmHist aRmVal\n\n    addHistChange :: RoomVal -> RoomVal\n    --Returns a RoomVal a history(to change room to the next) added\n    --From aRoomVal\n    addHistChange aRmVal = aRmVal{ rmHist = (succ $ fst x, succ $ snd x) : (x : xs) }\n      where\n        (x : xs) = rmHist aRmVal\n\n    addVal :: RoomVal -> Int ->  RoomVal\n    --Returns a RoomVal a number added\n    --From a RoomVal \n    --  and a number a group contains \n    addVal aRmVal aGroup  = aRmVal{ rmVal = (fst x, snd x + aGroup)} \n      where\n        x = rmVal aRmVal\n\n\n\n\nMyFunc.hs \u88dc\u52a9\u7684\u306a\u95a2\u6570\n\u8a08\u7b97\u304c\u8907\u96d1\u3067\u81ea\u5206\u3067\u3082\u3088\u304f\u308f\u304b\u3089\u306a\u304f\u306a\u3063\u3066\u304d\u305f\u306e\u3067\u3001\u6a19\u6e96\u306e\u95a2\u6570\u306b\u4f3c\u305f\u3082\u306e\u3092\u4f5c\u3063\u3066\u4f7f\u3044\u307e\u3057\u305f\u3002\nminimumF\u306f\u3001minimum\u3068\u540c\u3058\u3067\u3059\u304c\u3001\u95a2\u6570\u3092\u3068\u3063\u3066\u95a2\u6570\u3092\u9069\u7528\u3057\u305f\u7d50\u679c\u3067minimum\u3092\u9078\u3073\u307e\u3059\u3002\nscanwl\u306f\u3001scanl\u3068\u540c\u3058\u3067\u3059\u304c\u30013\u5f15\u6570\u306e\u95a2\u6570\u3068\u521d\u671f\u5024\u3068\u30ea\u30b9\u30c8\u3092\u4e8c\u3064\u3068\u3063\u3066\u30b9\u30ad\u30e3\u30f3\u3057\u307e\u3059\u3002\n\u3082\u3063\u3068\u826f\u3044\u65b9\u6cd5\u304c\u3042\u308b\u306e\u3067\u3057\u3087\u3046\u304c\u3001\u308f\u304b\u3089\u306a\u304b\u3063\u305f\u306e\u3067\u3002\n\nMyFunc.hs\nmodule MyFunc (\n  scanwl\n  , minimumF\n  ) where\n\nminimumF :: Ord b => (a -> b) -> [a] -> a\nminimumF f [x] = x\nminimumF f (x:y:xs)\n  | f x < f y = minimumF f (x:xs)\n  | otherwise = minimumF f (y:xs)\n\nscanwl :: (a -> b -> c -> a) -> a -> [b] -> [c] -> [a]\nscanwl f x [] _ = [x]\nscanwl f x _ [] = [x]\nscanwl f x (y:ys) (z:zs) = x : scanwl f (f x y z) ys zs\n\n\n\n\n\nMain.hs\n\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0\u306f\u307b\u307c\u5143\u3005\u8a18\u4e8b\u3068\u540c\u3058\u3067\u3059\u3002\n\u90e8\u5c4b\u304c\u5909\u308f\u308b\u3054\u3068\u306b\u3001\n\n\u305d\u306e\u90e8\u5c4b\u306b\u6709\u52b9\u306a\u30b0\u30eb\u30fc\u30d7\u3068\u524d\u306e\u90e8\u5c4b\u306e\u78ba\u5b9a\u3057\u305f\u5024\u304b\u3089\n\u3059\u3079\u3066\u306e\u53ef\u80fd\u306a\u5024\u3092\u8a08\u7b97\u3057\u3001\n\u305d\u306e\u4e2d\u304b\u3089\u6700\u9069\u306a\u5024\u3092\u9078\u3093\u3067\u78ba\u5b9a\u3059\u308b\n\n\u3068\u3044\u3046\u306e\u3092\u7e70\u308a\u8fd4\u3057\u3066\u3001\n\n\u6700\u5f8c\u306e\u90e8\u5c4b\u306e\u6700\u5f8c\u306e\u30b0\u30eb\u30fc\u30d7\u306e\u5c65\u6b74\u3092\u5f97\u308b\u3001\n\n\u3068\u3044\u3046\u3082\u306e\u3067\u3059\u3002\n\u7573\u307f\u8fbc\u307f\u90e8\u5206\u306f\u3001\u30ea\u30b9\u30c8\u306ehead\u3067\u521d\u671f\u5024\u3092\u4f5c\u3063\u3066\u3001\u30ea\u30b9\u30c8\u306etail\u3067foldl\u3084scanl\u3001scanwl\u3092\u7573\u307f\u8fbc\u3080\u3088\u3046\u306b\u3057\u307e\u3057\u305f\u3002\n\nMain.hs\nimport qualified RoomVal as RV\nimport qualified MyFunc as MF\n\n\nplanRoom :: [Int] -> Int -> [(Int,Int)]\n-- Returns optimal histories\n-- From numbers each group contains\n--  and a number of rooms\nplanRoom grpsList rmsNum =\n  reverse . RV.rmHist . last $ foldl fixeds (initFixeds xs) xss\n    where\n     (xs:xss) = validGrpss grpsList rmsNum\n\nvalidGrpss ::[Int] -> Int -> [[Int]]\n--Returns a list of numbers each group contains, valid for each room\n--From numbers each group contains\n--  and a number of rooms\nvalidGrpss grpsList rmsNum = \n filter (isLengthGE validLength) . map (take validLength)\n  $ tails grpsList\n  where\n    isLengthGE n xs = length xs >= n\n    validLength = length grpsList - rmsNum + 1\n    tails xs = take (length xs + 1) $ iterate tail xs\n\nfixeds :: [RV.RoomVal] -> [Int] -> [RV.RoomVal]\n--Returns new fixed RoomVals\n--From former fixed RoomVals\n--  and numbers each group contains, valid for this room\nfixeds formerFixeds groups =\n  map (RV.fixRmVal . MF.minimumF RV.calcRmVal)\n  $ possiblesList formerFixeds groups\n\npossiblesList :: [RV.RoomVal] -> [Int] -> [[RV.RoomVal]]\n--Returns a list of candidates for each new fixed RoomVal\n--From former fixed RoomVals\n--  and numbers each group contains, valid for this room\npossiblesList formerFixeds@(x : xs) groups@(y : ys) =\n  MF.scanwl possibles [possibleFromChange x y] xs ys\n\npossibles :: [RV.RoomVal] -> RV.RoomVal -> Int -> [RV.RoomVal]\n--Returns candidates for new fixed RoomVal\n--From previous RoomVals\n--  , a former fixed RoomVal\n--  and a number a group contains, valid for this place\npossibles prevPossibles aFormerFixed aGroup =\n  possibleFromChange aFormerFixed aGroup\n   : possiblesFromStay prevPossibles aGroup\n\npossibleFromChange :: RV.RoomVal -> Int -> RV.RoomVal\n--Returns a candidate for new fixed RoomVal\n--From a former fixed RoomVal\n--  and a number a group contains, valid for this place\npossibleFromChange aRmVal aGroup =\n  RV.addHistChange $ RV.addVal aRmVal aGroup\n\npossiblesFromStay ::[RV.RoomVal] -> Int -> [RV.RoomVal]\n--Returns candidates for new fixed RoomVal\n--From previous RoomVals\n--  and a number a group contains, valid for this place\npossiblesFromStay rmVals aGroup =\n  map (RV.addHistStay . flip RV.addVal aGroup) rmVals\n\ninitFixeds :: [Int] -> [RV.RoomVal]\n--Returns fixed RoomVals of the first room\n--From numbers each group contains, valid for the first room\ninitFixeds groups@(x : xs) =\n  map (RV.fixRmVal . head)\n  $ scanl possiblesFromStay [initPossible x]  xs\n  where\n    initPossible :: Int -> RV.RoomVal\n    --Returns a candidate for the first fixed RoomVal of the first room\n    --From a number the first group contains\n    initPossible n = RV.RoomVal (0, n) [(1,1)] \n\nconvertToIndex::String -> [(Int,Int)] -> String\n--Returns a String to show\n--From a String of group indexes\n--  and optimal histories\nconvertToIndex indexes hists@(y : ys) =\n  concatMap snd $ MF.scanwl insertWall (fst y, xs) xss ys\n  where\n    (xs:xss) = map (: []) indexes  -- String -> [String]\n\n    insertWall ::(Int,String) -> String -> (Int,Int) -> (Int,String)\n    --Returns new (the first of a history (=room), a String)\n    --From previous (the first of a history (=room), a String)\n    --  , a String\n    --  and a history\n    insertWall (a, _) bs (c, _ )\n      | a == c    = (c, bs)\n      | otherwise = ( c, \" | \" ++ bs)\n\n\nmain = putStrLn\n   . convertToIndex \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n  $ planRoom\n  [19,10,11,17,11,17,12\n  ,18,10,10,14,12,11,15\n  ,15,17,14,11,18,18,11\n  ,13,16,12,12,10] 6\n\n\n--\u51fa\u529b\nABCD | EFGH | IJKLM | NOPQ | RSTU | VWXYZ\n\n\u5165\u529b\u30c7\u30fc\u30bf\u306f\u5143\u8a18\u4e8b\u306e\u3082\u306e\u3067\u3059\u3002\n(\u6ce8\uff1a\u5b9f\u969b\u306e\u51fa\u529b\u3092\u898b\u6613\u3044\u3088\u3046\u306b\u9069\u5b9c\u3001\u6539\u884c\u3057\u3066\u3044\u307e\u3059\u3002)\n\u751f\u306e\u5c65\u6b74\u306a\u306e\u3067\u898b\u305f\u76ee\u304c\u3060\u3044\u3076\u9055\u3044\u307e\u3059\u304c\u3001 \u624b\u8a08\u7b97\u3067\u78ba\u8a8d\u3057\u305f\u3089\u5143\u8a18\u4e8b\u306e\u7d50\u679c\u3068\u540c\u3058\u3067\u3057\u305f\u3002\u305f\u3076\u3093\u5408\u3063\u3066\u3044\u308b\u306e\u3067\u3057\u3087\u3046\u3002\n\u57fa\u672c\u624b\u7d9a\u304d\u8133\u306e\u81ea\u5206\u306b\u306f\u3053\u308c\u304c\u7cbe\u4e00\u676f\u3067\u3057\u305f\u3002\n\u304a\u304b\u3057\u3044\u3088\u3001\u3082\u3063\u3068\u8ce2\u3044\u65b9\u6cd5\u304c\u3042\u308b\u3088\u3001\u3068\u3044\u3046\u306e\u304c\u3042\u308c\u3070\u30b3\u30e1\u30f3\u30c8\u304a\u306d\u304c\u3044\u3057\u307e\u3059\u3002\n\n\u5143\u8a18\u4e8b:[\u7d44\u5408\u305b\u6700\u9069\u5316\u3067\u30b0\u30eb\u30fc\u30d7\u5206\u3051](http://qiita.com/Tsutomu-KKE@github/items/9218e39a6604b2e0be14)\n\u5143\u3005\u8a18\u4e8b:[\u3010\u65e5\u5e38\u306b\u6f5c\u3080\u6700\u9069\u5316\u554f\u984c\u3011\u53d7\u9a13\u8005\u3092\u306a\u308b\u3079\u304f\u5747\u7b49\u306b\u8a66\u9a13\u4f1a\u5834\u306b\u5272\u308a\u632f\u308b\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0](https://codeiq.jp/magazine/2014/06/10973/)\n\u304c\u52c9\u5f37\u306b\u306a\u3063\u305f\u306e\u3067\u3001Haskell\u3067\u3084\u3063\u3066\u307f\u305f\u30e1\u30e2\u3002\n\n#\u4e16\u306e\u4e2d\u306b\u306f\u52d5\u7684\u8a08\u753b\u6cd5\u3068\u3044\u3046\u306e\u304c\u3042\u3063\u3066\u3001\u5358\u7d14\u306b\u6761\u4ef6\u3067\u30d5\u30a3\u30eb\u30bf\u30fc\u3059\u308b\u3060\u3051\u3088\u308a\u3060\u3044\u3076\u52b9\u7387\u304c\u3044\u3044\u305d\u3046\u306a\u3002\n\u3067\u3082\u3001\u96e3\u3057\u305d\u3046...\n\u8a18\u4e8b\u3092\u8aad\u3093\u3060\u3068\u304d\u3001\u3059\u3054\u3044H\u672c\u306b\u3042\u3063\u305f\u7d4c\u8def\u63a2\u7d22\u306b\u4f3c\u3066\u308b!\u3067\u304d\u308b\u304b\u3082...\u3068\u601d\u3063\u3066\u3057\u307e\u3063\u305f\u306e\u304c\u904b\u306e\u3064\u304d\u3002\n\u5168\u7136\u9055\u3063\u305f\u3002\u3081\u3063\u3061\u3083\u96e3\u3057\u3044\u3058\u3083\u3093\u3002\n\n\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0\u306f\u307b\u307c\u5143\u3005\u8a18\u4e8b\u3068\u540c\u3058\u3067\u3059\u3002\n\u305f\u3060\u3001Haskell\u3067\u3069\u3046\u3084\u308b\u306e?\u3068\u3044\u3046\u3068\u3053\u308d\u3067\u81ea\u5206\u306a\u308a\u306b\u5de5\u592b\u3057\u3066\u307f\u307e\u3057\u305f\u3002\n\n#RoomVal.hs \u30c7\u30fc\u30bf\u306e\u578b\u3068\u95a2\u6570\n\u90e8\u5c4b\u306e\u5024\u3068\u305d\u3053\u306b\u81f3\u308b\u307e\u3067\u306e\u90e8\u5c4b\u306e\u5c65\u6b74\u3092\u30bb\u30c3\u30c8\u306b\u3057\u307e\u3057\u305f\u3002\n\u5024\u306f\u90e8\u5c4b\u304c\u5909\u308f\u308b\u3068\u304d\u306b\u56fa\u5b9a\u5316\u3055\u308c\u308b\u90e8\u5206\u3068\u540c\u3058\u90e8\u5c4b\u3067\u307e\u3060\u78ba\u5b9a\u3057\u3066\u3044\u306a\u3044\u90e8\u5206\u306e\u30da\u30a2\u3067\u3059\u3002\n\u5c65\u6b74\u306f\u90e8\u5c4b\u306e\u756a\u53f7\u3068\u30b0\u30eb\u30fc\u30d7\u306e\u756a\u53f7\u306e\u30da\u30a2\u306e\u30ea\u30b9\u30c8\u3067\u3059\u3002\n\u5024\u3068\u5c65\u6b74\u306b\u95a2\u3059\u308b\u95a2\u6570\u3092\u5fc5\u8981\u306b\u306a\u308b\u305f\u3073\u306b\u3053\u3053\u306b\u52a0\u3048\u3066\u3044\u304d\u307e\u3057\u305f\u3002\n\n```haskell:RoomVal.hs\n\nmodule RoomVal (\n  RoomVal(..)\n  , calcRmVal\n  , fixRmVal\n  , addHistStay\n  , addHistChange\n  , addVal\n  ) where\n    \n    data RoomVal = RoomVal{\n    rmVal::(Int , Int)   --(fixed value from former histories,not fixed value for this place) \n    ,rmHist::[(Int,Int)]  -- a list of history(room, group)\n    } deriving (Show)\n\n    calcRmVal :: RoomVal -> Int\n    --Returns an actual room value = (fixed) + (not fixed)^2\n    --From a RoomVal\n    calcRmVal aRmVal = fst x + (snd x ^ 2)\n      where\n        x = rmVal aRmVal\n\n    fixRmVal :: RoomVal -> RoomVal\n    --Returns fixed RoomVal\n    --From a RoomVal not fixed\n    fixRmVal aRmVal = aRmVal{rmVal = (calcRmVal aRmVal, 0)}\n\n    addHistStay :: RoomVal -> RoomVal\n    --Returns a RoomVal a history(to stay the same room) added\n    --From a RoomVal\n    addHistStay aRmVal = aRmVal{ rmHist = (fst x, succ $ snd x) : (x : xs) }\n      where\n        (x : xs) = rmHist aRmVal\n    \n    addHistChange :: RoomVal -> RoomVal\n    --Returns a RoomVal a history(to change room to the next) added\n    --From aRoomVal\n    addHistChange aRmVal = aRmVal{ rmHist = (succ $ fst x, succ $ snd x) : (x : xs) }\n      where\n        (x : xs) = rmHist aRmVal\n\n    addVal :: RoomVal -> Int ->  RoomVal\n    --Returns a RoomVal a number added\n    --From a RoomVal \n    --  and a number a group contains \n    addVal aRmVal aGroup  = aRmVal{ rmVal = (fst x, snd x + aGroup)} \n      where\n        x = rmVal aRmVal\n\n```\n\n#MyFunc.hs \u88dc\u52a9\u7684\u306a\u95a2\u6570\n\u8a08\u7b97\u304c\u8907\u96d1\u3067\u81ea\u5206\u3067\u3082\u3088\u304f\u308f\u304b\u3089\u306a\u304f\u306a\u3063\u3066\u304d\u305f\u306e\u3067\u3001\u6a19\u6e96\u306e\u95a2\u6570\u306b\u4f3c\u305f\u3082\u306e\u3092\u4f5c\u3063\u3066\u4f7f\u3044\u307e\u3057\u305f\u3002\nminimumF\u306f\u3001minimum\u3068\u540c\u3058\u3067\u3059\u304c\u3001\u95a2\u6570\u3092\u3068\u3063\u3066\u95a2\u6570\u3092\u9069\u7528\u3057\u305f\u7d50\u679c\u3067minimum\u3092\u9078\u3073\u307e\u3059\u3002\nscanwl\u306f\u3001scanl\u3068\u540c\u3058\u3067\u3059\u304c\u30013\u5f15\u6570\u306e\u95a2\u6570\u3068\u521d\u671f\u5024\u3068\u30ea\u30b9\u30c8\u3092\u4e8c\u3064\u3068\u3063\u3066\u30b9\u30ad\u30e3\u30f3\u3057\u307e\u3059\u3002\n\u3082\u3063\u3068\u826f\u3044\u65b9\u6cd5\u304c\u3042\u308b\u306e\u3067\u3057\u3087\u3046\u304c\u3001\u308f\u304b\u3089\u306a\u304b\u3063\u305f\u306e\u3067\u3002\n\n```haskell:MyFunc.hs\nmodule MyFunc (\n  scanwl\n  , minimumF\n  ) where\n\nminimumF :: Ord b => (a -> b) -> [a] -> a\nminimumF f [x] = x\nminimumF f (x:y:xs)\n  | f x < f y = minimumF f (x:xs)\n  | otherwise = minimumF f (y:xs)\n\nscanwl :: (a -> b -> c -> a) -> a -> [b] -> [c] -> [a]\nscanwl f x [] _ = [x]\nscanwl f x _ [] = [x]\nscanwl f x (y:ys) (z:zs) = x : scanwl f (f x y z) ys zs\n\n\n```\n\n#Main.hs\n\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0\u306f\u307b\u307c\u5143\u3005\u8a18\u4e8b\u3068\u540c\u3058\u3067\u3059\u3002\n\n\u90e8\u5c4b\u304c\u5909\u308f\u308b\u3054\u3068\u306b\u3001\n\n+ \u305d\u306e\u90e8\u5c4b\u306b\u6709\u52b9\u306a\u30b0\u30eb\u30fc\u30d7\u3068\u524d\u306e\u90e8\u5c4b\u306e\u78ba\u5b9a\u3057\u305f\u5024\u304b\u3089\n+ \u3059\u3079\u3066\u306e\u53ef\u80fd\u306a\u5024\u3092\u8a08\u7b97\u3057\u3001\n+ \u305d\u306e\u4e2d\u304b\u3089\u6700\u9069\u306a\u5024\u3092\u9078\u3093\u3067\u78ba\u5b9a\u3059\u308b\n\n\u3068\u3044\u3046\u306e\u3092\u7e70\u308a\u8fd4\u3057\u3066\u3001\n\n+ \u6700\u5f8c\u306e\u90e8\u5c4b\u306e\u6700\u5f8c\u306e\u30b0\u30eb\u30fc\u30d7\u306e\u5c65\u6b74\u3092\u5f97\u308b\u3001\n\n\u3068\u3044\u3046\u3082\u306e\u3067\u3059\u3002\n\n\u7573\u307f\u8fbc\u307f\u90e8\u5206\u306f\u3001\u30ea\u30b9\u30c8\u306ehead\u3067\u521d\u671f\u5024\u3092\u4f5c\u3063\u3066\u3001\u30ea\u30b9\u30c8\u306etail\u3067foldl\u3084scanl\u3001scanwl\u3092\u7573\u307f\u8fbc\u3080\u3088\u3046\u306b\u3057\u307e\u3057\u305f\u3002\n\n```haskell:Main.hs\nimport qualified RoomVal as RV\nimport qualified MyFunc as MF\n\n\nplanRoom :: [Int] -> Int -> [(Int,Int)]\n-- Returns optimal histories\n-- From numbers each group contains\n--  and a number of rooms\nplanRoom grpsList rmsNum =\n  reverse . RV.rmHist . last $ foldl fixeds (initFixeds xs) xss\n    where\n     (xs:xss) = validGrpss grpsList rmsNum\n\nvalidGrpss ::[Int] -> Int -> [[Int]]\n--Returns a list of numbers each group contains, valid for each room\n--From numbers each group contains\n--  and a number of rooms\nvalidGrpss grpsList rmsNum = \n filter (isLengthGE validLength) . map (take validLength)\n  $ tails grpsList\n  where\n    isLengthGE n xs = length xs >= n\n    validLength = length grpsList - rmsNum + 1\n    tails xs = take (length xs + 1) $ iterate tail xs\n\nfixeds :: [RV.RoomVal] -> [Int] -> [RV.RoomVal]\n--Returns new fixed RoomVals\n--From former fixed RoomVals\n--  and numbers each group contains, valid for this room\nfixeds formerFixeds groups =\n  map (RV.fixRmVal . MF.minimumF RV.calcRmVal)\n  $ possiblesList formerFixeds groups\n\npossiblesList :: [RV.RoomVal] -> [Int] -> [[RV.RoomVal]]\n--Returns a list of candidates for each new fixed RoomVal\n--From former fixed RoomVals\n--  and numbers each group contains, valid for this room\npossiblesList formerFixeds@(x : xs) groups@(y : ys) =\n  MF.scanwl possibles [possibleFromChange x y] xs ys\n\npossibles :: [RV.RoomVal] -> RV.RoomVal -> Int -> [RV.RoomVal]\n--Returns candidates for new fixed RoomVal\n--From previous RoomVals\n--  , a former fixed RoomVal\n--  and a number a group contains, valid for this place\npossibles prevPossibles aFormerFixed aGroup =\n  possibleFromChange aFormerFixed aGroup\n   : possiblesFromStay prevPossibles aGroup\n\npossibleFromChange :: RV.RoomVal -> Int -> RV.RoomVal\n--Returns a candidate for new fixed RoomVal\n--From a former fixed RoomVal\n--  and a number a group contains, valid for this place\npossibleFromChange aRmVal aGroup =\n  RV.addHistChange $ RV.addVal aRmVal aGroup\n\npossiblesFromStay ::[RV.RoomVal] -> Int -> [RV.RoomVal]\n--Returns candidates for new fixed RoomVal\n--From previous RoomVals\n--  and a number a group contains, valid for this place\npossiblesFromStay rmVals aGroup =\n  map (RV.addHistStay . flip RV.addVal aGroup) rmVals\n\ninitFixeds :: [Int] -> [RV.RoomVal]\n--Returns fixed RoomVals of the first room\n--From numbers each group contains, valid for the first room\ninitFixeds groups@(x : xs) =\n  map (RV.fixRmVal . head)\n  $ scanl possiblesFromStay [initPossible x]  xs\n  where\n    initPossible :: Int -> RV.RoomVal\n    --Returns a candidate for the first fixed RoomVal of the first room\n    --From a number the first group contains\n    initPossible n = RV.RoomVal (0, n) [(1,1)] \n\nconvertToIndex::String -> [(Int,Int)] -> String\n--Returns a String to show\n--From a String of group indexes\n--  and optimal histories\nconvertToIndex indexes hists@(y : ys) =\n  concatMap snd $ MF.scanwl insertWall (fst y, xs) xss ys\n  where\n    (xs:xss) = map (: []) indexes  -- String -> [String]\n    \n    insertWall ::(Int,String) -> String -> (Int,Int) -> (Int,String)\n    --Returns new (the first of a history (=room), a String)\n    --From previous (the first of a history (=room), a String)\n    --  , a String\n    --  and a history\n    insertWall (a, _) bs (c, _ )\n      | a == c    = (c, bs)\n      | otherwise = ( c, \" | \" ++ bs)\n\n\nmain = putStrLn\n   . convertToIndex \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n  $ planRoom\n  [19,10,11,17,11,17,12\n  ,18,10,10,14,12,11,15\n  ,15,17,14,11,18,18,11\n  ,13,16,12,12,10] 6\n```\n\n```haskell:\n--\u51fa\u529b\nABCD | EFGH | IJKLM | NOPQ | RSTU | VWXYZ\n```\n\n\u5165\u529b\u30c7\u30fc\u30bf\u306f[\u5143\u8a18\u4e8b](http://qiita.com/Tsutomu-KKE@github/items/9218e39a6604b2e0be14)\u306e\u3082\u306e\u3067\u3059\u3002\n\n~~(\u6ce8\uff1a\u5b9f\u969b\u306e\u51fa\u529b\u3092\u898b\u6613\u3044\u3088\u3046\u306b\u9069\u5b9c\u3001\u6539\u884c\u3057\u3066\u3044\u307e\u3059\u3002)~~\n~~\u751f\u306e\u5c65\u6b74\u306a\u306e\u3067\u898b\u305f\u76ee\u304c\u3060\u3044\u3076\u9055\u3044\u307e\u3059\u304c\u3001~~ \u624b\u8a08\u7b97\u3067\u78ba\u8a8d\u3057\u305f\u3089\u5143\u8a18\u4e8b\u306e\u7d50\u679c\u3068\u540c\u3058\u3067\u3057\u305f\u3002\u305f\u3076\u3093\u5408\u3063\u3066\u3044\u308b\u306e\u3067\u3057\u3087\u3046\u3002\n\n\u57fa\u672c\u624b\u7d9a\u304d\u8133\u306e\u81ea\u5206\u306b\u306f\u3053\u308c\u304c\u7cbe\u4e00\u676f\u3067\u3057\u305f\u3002\n\u304a\u304b\u3057\u3044\u3088\u3001\u3082\u3063\u3068\u8ce2\u3044\u65b9\u6cd5\u304c\u3042\u308b\u3088\u3001\u3068\u3044\u3046\u306e\u304c\u3042\u308c\u3070\u30b3\u30e1\u30f3\u30c8\u304a\u306d\u304c\u3044\u3057\u307e\u3059\u3002\n", "tags": ["\u95a2\u6570\u578b\u30d7\u30ed\u30b0\u30e9\u30df\u30f3\u30b0", "\u52d5\u7684\u8a08\u753b\u6cd5", "Haskell"]}