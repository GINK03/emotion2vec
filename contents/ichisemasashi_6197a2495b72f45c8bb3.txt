{"context": " More than 1 year has passed since last update.\u521d\u3081\u307e\u3057\u3066\u4e00\u702c\u3067\u3059\u3002\n\u79c1\u304c\u4eca\u56de\u30a2\u30c9\u30d9\u30f3\u30c8\u30fb\u30ab\u30ec\u30f3\u30c0\u30fc\u306b\u53c2\u52a0\u3057\u305f\u306e\u306f \u5b9f\u7528 Common Lisp\u306e\u7b2c2\u7ae0\u3067\u6c17\u306b\u306a\u308b\u7b87\u6240\u304c\u3042\u3063\u305f\u305f\u3081\u3067\u3059\u3002\n\u305d\u308c\u306fCommon Lisp\u306e\u8a71\u306a\u306e\u3067\u3059\u304c\u3001\u3053\u3053\u3067\u306fClojure\u306b\u8aad\u307f\u5909\u3048\u3066\u8a71\u3092\u3059\u3059\u3081\u3055\u305b\u3066\u3082\u3089\u3044\u307e\u3059\u3002\n\u6c17\u306b\u306a\u3063\u3066\u3044\u308b\u306e\u306f\u3001\u30c6\u30ad\u30b9\u30c8p.41\u306e\u95a2\u6570combine-all\u306e\u52d5\u4f5c\u304c\u5b9a\u7fa9\u3068\u30c6\u30ad\u30b9\u30c8\u4e0a\u306e\u52d5\u4f5c\u306b\u9055\u3044\u304c\u3042\u308b\u70b9\u3067\u3059\u3002\n\u30c6\u30ad\u30b9\u30c8\u306e\u5b9a\u7fa9 : \n(combine-all '((a) (b)) '((1) (2))) \n=> ((A 1) (B 1) (A 2) (B 2))\n\n\u95a2\u6570\u306e\u5b9f\u88c5\u306f\u3001\u5b9a\u7fa9\u306b\u306e\u3063\u3068\u3063\u3066\u304a\u308a\u3001\u5b9f\u969b\u306b\u305f\u3081\u3057\u305f\u3068\u3053\u308d\u5b9a\u7fa9\u901a\u308a\u306e\u52d5\u4f5c\u306b\u306a\u308a\u307e\u3057\u305f\u3002\n\u3057\u304b\u3057\u3001\u30c6\u30ad\u30b9\u30c8\u4e0a\u306e\u52d5\u4f5c\u306f\u6b21\u306e\u3088\u3046\u306b\u306a\u3063\u3066\u3044\u307e\u3059\u3002\n(combine-all '((a) (b)) '((1) (2))) \n=> ((A 1) (A 2) (B 1) (B 2))\n\n\u3064\u307e\u308a\u3001\u5b9a\u7fa9\u3068\u52d5\u4f5c\u304c\u4e0d\u4e00\u81f4\u3092\u8d77\u3057\u3066\u3044\u308b\u306e\u3067\u3059\u3002\u3068\u3066\u3082\u6c17\u306b\u306a\u308a\u307e\u3059\u3002\n\u5b9a\u7fa9\u306e\u5b9f\u88c5\u306f\u30c6\u30ad\u30b9\u30c8\u4e0a\u306b\u3042\u308a\u6b63\u5e38\u306b\u52d5\u4f5c\u3057\u3066\u3044\u307e\u3059\u304c\u3001\u52d5\u4f5c\u304c\u6b63\u3057\u3044\u3068\u3057\u3066\u8003\u3048\u305f\u5834\u5408\u306e\u95a2\u6570\u306e\u5b9f\u88c5\u304c\u306a\u3044\u306e\u3067\u3001\u3053\u3053\u3067\u306f\u3001\u305d\u308c\u3092\u8003\u3048\u3066\u3086\u304d\u307e\u3059\u3002\n\u307e\u305a\u3001Common Lisp\u306ecombine-all\u306e\u5b9f\u88c5 :\n(defun combine-all (xlist ylist)\n  \"Return a list of lists formed by appending a y to an x.\n   E.g., (combine-all '((a) (b)) '((1) (2))) -> ((A 1) (B 1) (A 2) (B 2)).\"\n  (mappend #'(lambda (y)\n           (mapcar #'(lambda (x) (append x y)) xlist))\n       ylist))\n(defun mappend (fn the-list)\n  \"Apply fn to each element of list and append the results.\"\n  (apply #'append (mapcar fn the-list)))\n\n\u3053\u308c\u3092Clojure\u306b\u66f8\u304d\u76f4\u3057\u3066\u3001\n(defn combine-all [xlist ylist]\n  (mappend (fn [y]\n                  (map (fn [x] (concat x y)) xlist))\n                ylist))\n(defn mappend [fn the-list]\n  (apply concat (map fn the-list)))\n\n\u5b9f\u884c\u7d50\u679c\u306f\u3001\u4ee5\u4e0b\u306e\u901a\u308a\u3001\u5b9a\u7fa9\u901a\u308a\u306b\u306a\u308a\u307e\u3059\u3002\nuser=> (combine-all '((a) (b)) '((1) (2)))\n((a 1) (b 1) (a 2) (b 2))\n\n\u3068\u3053\u308d\u3067\u3001\u30c6\u30ad\u30b9\u30c8\u4e0a\u306e\u52d5\u4f5c\u3092\u518d\u73fe\u3059\u308b\u5b9f\u88c5\u306f\u4ee5\u4e0b\u306e\u3088\u3046\u306b\u306a\u308a\u307e\u3059\u3002\n(defn combine-all [xlist ylist]\n  (mappend (fn [x]\n                  (map (fn [y] (concat x y)) ylist))\n                xlist))\n\n\u5b9f\u884c\u7d50\u679c\u306f\u3001\u4ee5\u4e0b\u306e\u3088\u3046\u306b\u3001\u30c6\u30ad\u30b9\u30c8\u4e0a\u306e\u52d5\u4f5c\u3068\u540c\u3058\u306b\u306a\u308a\u307e\u3057\u305f\u3002\nuser=> (combine-all '((a) (b)) '((1) (2)))\n((a 1) (a 2) (b 1) (b 2))\n\n\u7c21\u5358\u306a\u4fee\u6b63\u3067\u6c17\u306b\u306a\u308b\u70b9\u3092\u89e3\u6d88\u3067\u304d\u307e\u3057\u305f\u3002\n\u305d\u308c\u3067\u306f\u7686\u69d8\u30e9\u30d6&\u30d4\u30fc\u30b9\u306a\u5e74\u8d8a\u3057\u3092\n\u8ffd\u8a18\n\u95a2\u6570combine-all\u3092\u4f7f\u3063\u3066\u3044\u308b\u30d7\u30ed\u30b0\u30e9\u30e0\u306e\u5168\u4f53\u50cf\u306fClojure\u3067\u4ee5\u4e0b\u306e\u3088\u3046\u306b\u306a\u308a\u307e\u3059\u3002\n\n(def *simple-grammar*\n  \"A grammar for a trivial subset of English.\"\n  '((sentence -> (noun-phrase verb-phrase))\n    (noun-phrase -> (Article Noun))\n    (verb-phrase -> (Verb noun-phrase))\n    (Article -> the a)\n    (Noun -> man ball woman table)\n    (Verb -> hit took saw liked))\n)\n(def *grammar*\n  \"The grammar used by generate. Initially, this is *simple-grammar*, but we can switch to other grammars.\"\n   *simple-grammar*)\n\n(defn rule-lhs [rule]\n  \"The left-hand side of a rule.\"\n  (first rule))\n(defn rule-rhs [rule]\n  \"The right-hand side of a rule.\"\n  (rest (rest rule)))\n(defn my-assoc [category grammar]\n     (cond (empty? grammar) '()\n               (= category (first (first grammar))) (first grammar)\n               :else (my-assoc category (rest grammar))))\n(defn rewrites [category]\n  \"Return a list of the possible rewrites for this category.\"\n  (rule-rhs (my-assoc category *grammar*)))\n(defn combine-all [xlist ylist]\n  (mappend (fn [y]\n                  (map (fn [x] (concat x y)) xlist))\n                ylist))\n(defn mappend [fn the-list]\n  (apply concat (map fn the-list)))\n\n(defn generate-all [phrase]\n  \"Generate a list of all possible expansions of this phrase.\"\n  (cond (empty? phrase) (list '())\n        (list? phrase) (combine-all (generate-all (first phrase))\n                                      (generate-all (rest phrase)))\n        (not (empty? (rewrites phrase))) (mappend generate-all (rewrites phrase))\n        :else (list (list phrase))))\n\n\u3053\u308c\u306f\u3001\u7c21\u5358\u306a\u82f1\u6587\u306e\u7d44\u307f\u5408\u308f\u305b\u3092\u751f\u6210\u3059\u308b\u30d7\u30ed\u30b0\u30e9\u30e0\u3067\u3059\u3002\n\u60f3\u5b9a\u52d5\u4f5c\u306f\u3001\u4ee5\u4e0b\u306e\u3088\u3046\u306a\u611f\u3058\u3067\u3059\u3002\n(generate-all 'Article)\n->((the) (a))\n(generate-all 'Noun)\n->((man) (ball) (woman) (table))\n(generate-all 'noun-phrase)\n->((a man) (the man) (a ball) (the ball) (a woman) (the woman) (a table) (the table))\n(count (generate-all 'sentence))\n->256\n\n\u3068\u3053\u308d\u304c\u3001\u3053\u306e\u30d7\u30ed\u30b0\u30e9\u30e0\u306b\u306f\u30d0\u30b0\u304c\u3042\u3063\u3066\u3001\u5b9f\u969b\u306e\u52d5\u4f5c\u306f\u4ee5\u4e0b\u306e\u3088\u3046\u306b\u306a\u308a\u307e\u3059\u3002\nuser=> (generate-all 'Article)\nIllegalArgumentException Don't know how to create ISeq from: clojure.lang.Symbol  clojure.lang.RT.seqFrom (RT.java:505)\n\n\n\u3060\u308c\u304b\u304a\u6687\u306a\u4eba\u304c\u3044\u307e\u3057\u305f\u3089\u30c7\u30d0\u30c3\u30b0\u3068\u304b\u3057\u3066\u307b\u3057\u3044\u3067\u3059\u3002\n\u521d\u3081\u307e\u3057\u3066\u4e00\u702c\u3067\u3059\u3002\n\u79c1\u304c\u4eca\u56de\u30a2\u30c9\u30d9\u30f3\u30c8\u30fb\u30ab\u30ec\u30f3\u30c0\u30fc\u306b\u53c2\u52a0\u3057\u305f\u306e\u306f **\u5b9f\u7528** Common Lisp\u306e\u7b2c2\u7ae0\u3067\u6c17\u306b\u306a\u308b\u7b87\u6240\u304c\u3042\u3063\u305f\u305f\u3081\u3067\u3059\u3002\n\u305d\u308c\u306fCommon Lisp\u306e\u8a71\u306a\u306e\u3067\u3059\u304c\u3001\u3053\u3053\u3067\u306fClojure\u306b\u8aad\u307f\u5909\u3048\u3066\u8a71\u3092\u3059\u3059\u3081\u3055\u305b\u3066\u3082\u3089\u3044\u307e\u3059\u3002\n\n\u6c17\u306b\u306a\u3063\u3066\u3044\u308b\u306e\u306f\u3001\u30c6\u30ad\u30b9\u30c8p.41\u306e\u95a2\u6570combine-all\u306e\u52d5\u4f5c\u304c\u5b9a\u7fa9\u3068\u30c6\u30ad\u30b9\u30c8\u4e0a\u306e\u52d5\u4f5c\u306b\u9055\u3044\u304c\u3042\u308b\u70b9\u3067\u3059\u3002\n\u30c6\u30ad\u30b9\u30c8\u306e\u5b9a\u7fa9 : \n\n```\n(combine-all '((a) (b)) '((1) (2))) \n=> ((A 1) (B 1) (A 2) (B 2))\n```\n\n\u95a2\u6570\u306e\u5b9f\u88c5\u306f\u3001\u5b9a\u7fa9\u306b\u306e\u3063\u3068\u3063\u3066\u304a\u308a\u3001\u5b9f\u969b\u306b\u305f\u3081\u3057\u305f\u3068\u3053\u308d\u5b9a\u7fa9\u901a\u308a\u306e\u52d5\u4f5c\u306b\u306a\u308a\u307e\u3057\u305f\u3002\n\n\u3057\u304b\u3057\u3001\u30c6\u30ad\u30b9\u30c8\u4e0a\u306e\u52d5\u4f5c\u306f\u6b21\u306e\u3088\u3046\u306b\u306a\u3063\u3066\u3044\u307e\u3059\u3002\n\n```\n(combine-all '((a) (b)) '((1) (2))) \n=> ((A 1) (A 2) (B 1) (B 2))\n```\n\n\u3064\u307e\u308a\u3001\u5b9a\u7fa9\u3068\u52d5\u4f5c\u304c\u4e0d\u4e00\u81f4\u3092\u8d77\u3057\u3066\u3044\u308b\u306e\u3067\u3059\u3002\u3068\u3066\u3082\u6c17\u306b\u306a\u308a\u307e\u3059\u3002\n\u5b9a\u7fa9\u306e\u5b9f\u88c5\u306f\u30c6\u30ad\u30b9\u30c8\u4e0a\u306b\u3042\u308a\u6b63\u5e38\u306b\u52d5\u4f5c\u3057\u3066\u3044\u307e\u3059\u304c\u3001\u52d5\u4f5c\u304c\u6b63\u3057\u3044\u3068\u3057\u3066\u8003\u3048\u305f\u5834\u5408\u306e\u95a2\u6570\u306e\u5b9f\u88c5\u304c\u306a\u3044\u306e\u3067\u3001\u3053\u3053\u3067\u306f\u3001\u305d\u308c\u3092\u8003\u3048\u3066\u3086\u304d\u307e\u3059\u3002\n\n\u307e\u305a\u3001Common Lisp\u306ecombine-all\u306e\u5b9f\u88c5 :\n\n```\n(defun combine-all (xlist ylist)\n  \"Return a list of lists formed by appending a y to an x.\n   E.g., (combine-all '((a) (b)) '((1) (2))) -> ((A 1) (B 1) (A 2) (B 2)).\"\n  (mappend #'(lambda (y)\n\t       (mapcar #'(lambda (x) (append x y)) xlist))\n\t   ylist))\n(defun mappend (fn the-list)\n  \"Apply fn to each element of list and append the results.\"\n  (apply #'append (mapcar fn the-list)))\n```\n\n\u3053\u308c\u3092Clojure\u306b\u66f8\u304d\u76f4\u3057\u3066\u3001\n\n```\n(defn combine-all [xlist ylist]\n  (mappend (fn [y]\n\t              (map (fn [x] (concat x y)) xlist))\n\t            ylist))\n(defn mappend [fn the-list]\n  (apply concat (map fn the-list)))\n```\n\n\u5b9f\u884c\u7d50\u679c\u306f\u3001\u4ee5\u4e0b\u306e\u901a\u308a\u3001\u5b9a\u7fa9\u901a\u308a\u306b\u306a\u308a\u307e\u3059\u3002\n\n```\nuser=> (combine-all '((a) (b)) '((1) (2)))\n((a 1) (b 1) (a 2) (b 2))\n```\n\n\u3068\u3053\u308d\u3067\u3001\u30c6\u30ad\u30b9\u30c8\u4e0a\u306e\u52d5\u4f5c\u3092\u518d\u73fe\u3059\u308b\u5b9f\u88c5\u306f\u4ee5\u4e0b\u306e\u3088\u3046\u306b\u306a\u308a\u307e\u3059\u3002\n\n```\n(defn combine-all [xlist ylist]\n  (mappend (fn [x]\n\t              (map (fn [y] (concat x y)) ylist))\n\t            xlist))\n```\n\n\u5b9f\u884c\u7d50\u679c\u306f\u3001\u4ee5\u4e0b\u306e\u3088\u3046\u306b\u3001\u30c6\u30ad\u30b9\u30c8\u4e0a\u306e\u52d5\u4f5c\u3068\u540c\u3058\u306b\u306a\u308a\u307e\u3057\u305f\u3002\n\n```\nuser=> (combine-all '((a) (b)) '((1) (2)))\n((a 1) (a 2) (b 1) (b 2))\n```\n\n\u7c21\u5358\u306a\u4fee\u6b63\u3067\u6c17\u306b\u306a\u308b\u70b9\u3092\u89e3\u6d88\u3067\u304d\u307e\u3057\u305f\u3002\n\u305d\u308c\u3067\u306f\u7686\u69d8\u30e9\u30d6&\u30d4\u30fc\u30b9\u306a\u5e74\u8d8a\u3057\u3092\n\n\u8ffd\u8a18\n\u95a2\u6570combine-all\u3092\u4f7f\u3063\u3066\u3044\u308b\u30d7\u30ed\u30b0\u30e9\u30e0\u306e\u5168\u4f53\u50cf\u306fClojure\u3067\u4ee5\u4e0b\u306e\u3088\u3046\u306b\u306a\u308a\u307e\u3059\u3002\n\n```\n\n(def *simple-grammar*\n  \"A grammar for a trivial subset of English.\"\n  '((sentence -> (noun-phrase verb-phrase))\n    (noun-phrase -> (Article Noun))\n    (verb-phrase -> (Verb noun-phrase))\n    (Article -> the a)\n    (Noun -> man ball woman table)\n    (Verb -> hit took saw liked))\n)\n(def *grammar*\n  \"The grammar used by generate. Initially, this is *simple-grammar*, but we can switch to other grammars.\"\n   *simple-grammar*)\n\n(defn rule-lhs [rule]\n  \"The left-hand side of a rule.\"\n  (first rule))\n(defn rule-rhs [rule]\n  \"The right-hand side of a rule.\"\n  (rest (rest rule)))\n(defn my-assoc [category grammar]\n     (cond (empty? grammar) '()\n               (= category (first (first grammar))) (first grammar)\n               :else (my-assoc category (rest grammar))))\n(defn rewrites [category]\n  \"Return a list of the possible rewrites for this category.\"\n  (rule-rhs (my-assoc category *grammar*)))\n(defn combine-all [xlist ylist]\n  (mappend (fn [y]\n\t              (map (fn [x] (concat x y)) xlist))\n\t            ylist))\n(defn mappend [fn the-list]\n  (apply concat (map fn the-list)))\n\n(defn generate-all [phrase]\n  \"Generate a list of all possible expansions of this phrase.\"\n  (cond (empty? phrase) (list '())\n \t    (list? phrase) (combine-all (generate-all (first phrase))\n\t\t\t\t                      (generate-all (rest phrase)))\n\t    (not (empty? (rewrites phrase))) (mappend generate-all (rewrites phrase))\n\t    :else (list (list phrase))))\n```\n\n\u3053\u308c\u306f\u3001\u7c21\u5358\u306a\u82f1\u6587\u306e\u7d44\u307f\u5408\u308f\u305b\u3092\u751f\u6210\u3059\u308b\u30d7\u30ed\u30b0\u30e9\u30e0\u3067\u3059\u3002\n\u60f3\u5b9a\u52d5\u4f5c\u306f\u3001\u4ee5\u4e0b\u306e\u3088\u3046\u306a\u611f\u3058\u3067\u3059\u3002\n\n```\n(generate-all 'Article)\n->((the) (a))\n(generate-all 'Noun)\n->((man) (ball) (woman) (table))\n(generate-all 'noun-phrase)\n->((a man) (the man) (a ball) (the ball) (a woman) (the woman) (a table) (the table))\n(count (generate-all 'sentence))\n->256\n```\n\n\u3068\u3053\u308d\u304c\u3001\u3053\u306e\u30d7\u30ed\u30b0\u30e9\u30e0\u306b\u306f\u30d0\u30b0\u304c\u3042\u3063\u3066\u3001\u5b9f\u969b\u306e\u52d5\u4f5c\u306f\u4ee5\u4e0b\u306e\u3088\u3046\u306b\u306a\u308a\u307e\u3059\u3002\n\n```\nuser=> (generate-all 'Article)\nIllegalArgumentException Don't know how to create ISeq from: clojure.lang.Symbol  clojure.lang.RT.seqFrom (RT.java:505)\n\n```\n\n\u3060\u308c\u304b\u304a\u6687\u306a\u4eba\u304c\u3044\u307e\u3057\u305f\u3089\u30c7\u30d0\u30c3\u30b0\u3068\u304b\u3057\u3066\u307b\u3057\u3044\u3067\u3059\u3002", "tags": ["PAIP", "Clojure"]}