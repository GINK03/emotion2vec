{"tags": ["C", "C++", "IC\u30ab\u30fc\u30c9", "\u6697\u53f7", "\u30b5\u30f3\u30d7\u30eb"], "context": "\n\n\u306f\u3058\u3081\u306b\n\u682a\u5f0f\u4f1a\u793eiCanal\u306e\u30b5\u30a4\u30c8\u3067\u516c\u958b\u3057\u3066\u3044\u305fIC\u30ab\u30fc\u30c9\u3092\u4f7f\u3063\u305f\u30d5\u30a1\u30a4\u30eb\u6697\u53f7\u30bd\u30d5\u30c8\u306e\u6295\u7a3f\u3067\u3059\u3002\n2013\uff5e2015\u5e74\u9803\u306b\u516c\u958b\u3057\u3066\u3044\u305f\u306e\u3067\u3059\u304c\u81ea\u793e(\u682a\u5f0f\u4f1a\u793eiCanal)\u306e\u30d5\u30a1\u30a4\u30eb\u6697\u53f7\u30bd\u30d5\u30c8ToraTora\u3068\u7af6\u5408\u3057\u3066\u3057\u307e\u3046\u305f\u3081\u516c\u958b\u3092\u505c\u6b62\u3057\u3066\u3044\u307e\u3057\u305f\u3002\n\u6700\u65b0\u7248\u306eToraTora\u3067\u306f\u3001\u3053\u308c\u3088\u308a\u3082\u82e5\u5e72\u5f37\u5ea6\u304c\u9ad8\u3044RSA\u6697\u53f7\u3092\u4f7f\u3046\u3088\u3046\u306b\u30d0\u30fc\u30b8\u30e7\u30f3\u30a2\u30c3\u30d7\u3057\u305f\u306e\u3067\u3001\u518d\u3073Qiita\u3067\u516c\u958b\u3059\u308b\u3053\u3068\u306b\u3057\u307e\u3057\u305f\u3002\n\n\u3053\u306e\u30d5\u30a1\u30a4\u30eb\u6697\u53f7\u30bd\u30d5\u30c8\u306e\u7279\u5fb4\n\u30d1\u30b9\u30ef\u30fc\u30c9\u3068IC\u30ab\u30fc\u30c9\u306e\u4f75\u7528\u306b\u3088\u3063\u3066\u30d1\u30b9\u30ef\u30fc\u30c9\u30af\u30e9\u30c3\u30af\u306b\u5f37\u3044AES\u6697\u53f7 256bit\u306e\u6697\u53f7\u5316\u304c\u3067\u304d\u307e\u3059\u3002\n\n\u4f7f\u3048\u308bIC\u30ab\u30fc\u30c9\nBaseCSP\u306b\u5bfe\u5fdc\u3057\u305fIC\u30ab\u30fc\u30c9\u3067\u3042\u308c\u3070\u5e02\u8ca9\u306eIC\u30ab\u30fc\u30c9\u3067\u3082\u5229\u7528\u53ef\u80fd\u3067\u3059\u3002IC\u30ab\u30fc\u30c9\u304c\u306a\u3044\u5834\u5408\u306f\u7121\u6599\u306e\u30a8\u30df\u30e5\u30ec\u30fc\u30bfmyuToken\u3092\u4f7f\u3044\u307e\u3059\u3002\u958b\u767a\u3060\u3051\u306a\u3089USB\u30e1\u30e2\u30ea\u3092\u4f7f\u3063\u305f\u30a8\u30df\u30e5\u30ec\u30fc\u30bf\u3088\u308a\u3082SiMyuCard\u3092\u4f7f\u3063\u305f\u307b\u3046\u304c\u4fbf\u5229\u304b\u3082\u3057\u308c\u307e\u305b\u3093\u3002SiMyuCard\u306e\u30c7\u30d0\u30a4\u30b9\u30c9\u30e9\u30a4\u30d0\u306f\u30b3\u30fc\u30c9\u7f72\u540d\u304c\u3064\u3044\u3066\u3044\u308b\u306e\u3067\u30a4\u30f3\u30b9\u30c8\u30fc\u30eb\u304c\u7c21\u5358\u3067\u3059\u3002\n\u96fb\u5b50\u8a3c\u660e\u66f8\u306eRSA\u6697\u53f7\u306e\u79d8\u5bc6\u9375\u3092\u4f7f\u3063\u3066\u6697\u53f7\u5316\u3057\u307e\u3059\u3002\u3042\u3089\u304b\u3058\u3081\u96fb\u5b50\u8a3c\u660e\u66f8\u3092\u30a4\u30f3\u30dd\u30fc\u30c8\u3057\u3066\u304a\u304f\u5fc5\u8981\u304c\u3042\u308a\u307e\u3059\u3002\n\n\u52d5\u4f5cOS\u3068\u958b\u767a\u74b0\u5883\nWindows XP SP3\u4ee5\u964d\u306ePC\u3067\u52d5\u4f5c\u3059\u308b\u3053\u3068\u304c\u8003\u3048\u3089\u308c\u305f\u30bd\u30fc\u30b9\u3067\u3059\u3002 Visual Studio 2008 C++\u3068Visual Studio 2010 C++\u3068Visual Studio 2013 C++\u3067\u30b3\u30f3\u30d1\u30a4\u30eb\u3067\u304d\u308b\u3053\u3068\u3092\u78ba\u8a8d\u3057\u3066\u3044\u307e\u3059\u3002\n\n\u514d\u8cac\n\u3053\u306e\u65b9\u6cd5\u3067\u640d\u5bb3\u3092\u88ab\u3063\u3066\u3082\u8cac\u4efb\u3092\u8ca0\u3044\u307e\u305b\u3093\u3001\u3042\u3089\u304b\u3058\u3081\u3054\u4e86\u627f\u306d\u304c\u3044\u307e\u3059\u3002\n\n\u30bd\u30fc\u30b9\u30b3\u30fc\u30c9\n\nicenc.cpp\n/* File Encrypt Sample\n2013/12/24 Ver1.1\nRSA 2048bit\u5c02\u7528\nWindows XP\u306b\u5bfe\u5fdc\u3059\u308b\u5834\u5408\u3001\n\u30d7\u30e9\u30c3\u30c8\u30d5\u30a9\u30fc\u30e0\u30c4\u30fc\u30eb\u30bb\u30c3\u30c8 Visual Studio 2013 - WindowsXP\u3092\u9078\u629e\u3057\u3066\u304f\u3060\u3055\u3044\u3002\n*/\n#define _WIN32_WINNT 0x0501 // Windows XPSP3\u4ee5\u964d\n#include <SDKDDKVer.h>\n#include <stdio.h>\n#include <Windows.h>\n#include <Cryptuiapi.h>\n\n#if 0 // \u30d7\u30e9\u30c3\u30c8\u30d5\u30a9\u30fc\u30e0\u30c4\u30fc\u30eb\u30bb\u30c3\u30c8 Visual Studio 2013 - WindowsXP\u3092\u9078\u629e\u3057\u305f\u5834\u5408\u306f 0\n#include <VersionHelpers.h>\n#else\nBOOL IsWindowsVersionOrGreater(WORD dwMajor, WORD dwMinor, WORD dwSPMajor)\n{\n    DWORDLONG dwlConditionMask = 0;\n    OSVERSIONINFOEX osvi;\n    ZeroMemory(&osvi, sizeof(OSVERSIONINFOEX));\n\n    osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);\n    osvi.dwMajorVersion = dwMajor;\n    osvi.dwMinorVersion = dwMinor;\n    osvi.wServicePackMajor = dwSPMajor;// Set up the condition mask.\n\n    VER_SET_CONDITION(dwlConditionMask, VER_MAJORVERSION, VER_GREATER_EQUAL);\n    VER_SET_CONDITION(dwlConditionMask, VER_MINORVERSION, VER_GREATER_EQUAL);\n    VER_SET_CONDITION(dwlConditionMask, VER_SERVICEPACKMAJOR, VER_GREATER_EQUAL);\n\n    // Perform the test.\n    return VerifyVersionInfo(&osvi, VER_MAJORVERSION\n        | VER_MINORVERSION\n        | VER_SERVICEPACKMAJOR,\n        dwlConditionMask);\n}\n\nBOOL IsWindowsXPSP3OrGreater() {\n    return IsWindowsVersionOrGreater(5, 1, 3);\n}\n#endif\n\n#pragma comment(lib,\"crypt32.lib\")\n#pragma comment(lib,\"cryptui.lib\")\n\n#define MSCSP51 \"Microsoft Enhanced RSA and AES Cryptographic Provider (Prototype)\"\n#define MSCSP52 \"Microsoft Enhanced RSA and AES Cryptographic Provider\"\n#ifndef CALG_SHA_256\n#define CALG_SHA_256 0x0000800c\n#endif\n\nBYTE g_pbKey[44] = {\n    0x08, 0x02, 0x00, 0x00,\n    0x10, 0x66, 0x00, 0x00, // CALG_AES_256\n    0x20, 0x00, 0x00, 0x00, // 32BYTE\n    0x00, 0x00, 0x00, 0x00, // AES 256bit Key 32Byte\n    0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00\n};\n\nHCRYPTPROV g_hProv;\n\nBOOL password_key(char *p) {\n    // \u7c21\u5358\u306e\u305f\u3081SHA-256\u3067\u4ee3\u7528\u3002PKCS#5\u306a\u3069\u3092\u53c2\u8003\u306b\u3002\n    int i;\n    HCRYPTHASH hHash;\n    BYTE pbPK[32];\n    DWORD cbPK = sizeof(pbPK);\n    if (!CryptCreateHash(g_hProv, CALG_SHA_256, NULL, 0, &hHash)) {\n        printf(\"CryptCreateHash() FAIL %08\\n\", GetLastError());\n        return FALSE;\n    }\n    if (!CryptHashData(hHash, (BYTE*)p, (DWORD)strlen(p), 0)) {\n        printf(\"CryptHashData() FAIL %08X\\n\", GetLastError());\n        CryptDestroyHash(hHash);\n        return FALSE;\n    }\n    if (!CryptGetHashParam(hHash, HP_HASHVAL, pbPK, &cbPK, 0)) {\n        printf(\"CryptGetHashParam() FAIL %08X\", GetLastError());\n        CryptDestroyHash(hHash);\n        return FALSE;\n    }\n    CryptDestroyHash(hHash);\n    for (i = 0; i<32; i++) g_pbKey[12 + i] ^= pbPK[i];\n    return TRUE;\n}\n\nBOOL CertView(HCRYPTKEY hKey) {\n    BYTE pbCert[8192];\n    DWORD cbCert = sizeof(pbCert);\n    if (!CryptGetKeyParam(hKey, KP_CERTIFICATE, pbCert, &cbCert, 0)) {\n        printf(\"CryptGetKeyParam() FAIL %08X\\n\", GetLastError());\n        return FALSE;\n    }\n    PCCERT_CONTEXT pCertContext = CertCreateCertificateContext(X509_ASN_ENCODING, pbCert, cbCert);\n    if (pCertContext == NULL) {\n        printf(\"CertCreateCertificateContext() FAIL %08X\\n\", GetLastError());\n        return FALSE;\n    }\n    if (!CryptUIDlgViewContext(CERT_STORE_CERTIFICATE_CONTEXT, pCertContext, NULL, L\"icenc\", 0, NULL)) {\n        printf(\"CryptUIDlgViewContext() FAIL %08X\\n\", GetLastError());\n        CertFreeCertificateContext(pCertContext);\n        return FALSE;\n    }\n    CertFreeCertificateContext(pCertContext);\n    return TRUE;\n}\n\n\nBOOL rsaenc(BYTE *pbKey) {\n    HCRYPTPROV hProv;\n    if (!CryptAcquireContext(&hProv, NULL, MS_SCARD_PROV, PROV_RSA_FULL, 0)) {\n        DWORD dwError = GetLastError();\n        if (dwError == NTE_BAD_KEYSET) {\n            printf(\"IC\u30ab\u30fc\u30c9\u3092\u633f\u5165\u3057\u3066\u304f\u3060\u3055\u3044\");\n            return FALSE;\n        }\n        printf(\"CryptAcquireContext() FAIL %08X\\n\", GetLastError());\n        return FALSE;\n    }\n    HCRYPTKEY hKey;\n    if (!CryptGetUserKey(hProv, AT_KEYEXCHANGE, &hKey)) {\n        printf(\"CryptGetUserKey() FAIL %08X\\n\", GetLastError());\n        CryptReleaseContext(hProv, 0);\n        return FALSE;\n    }\n\n    if (!CertView(hKey)) return FALSE;\n\n    DWORD dwKeySize;\n    DWORD cbKeySize = sizeof(DWORD);\n    if (!CryptGetKeyParam(hKey, KP_BLOCKLEN, (BYTE*)&dwKeySize, &cbKeySize, 0)) {\n        printf(\"CryptGetKeyParam() FAIL %08X\\n\", GetLastError());\n        CryptReleaseContext(hProv, 0);\n        return FALSE;\n    }\n    if (dwKeySize != 2048) {\n        printf(\"RSA KeySize Error\\n\");\n        CryptReleaseContext(hProv, 0);\n        return FALSE;\n    }\n    DWORD dwKey = 32;\n    if (!CryptEncrypt(hKey, NULL, TRUE, 0, pbKey, &dwKey, 256)) {\n        printf(\"CryptEncrypt() FAIL %08X\\n\", GetLastError());\n        CryptReleaseContext(hProv, 0);\n        return FALSE;\n    }\n    CryptReleaseContext(hProv, 0);\n    return TRUE;\n}\n\nBOOL rsadec(BYTE *pbKey) {\n    HCRYPTPROV hProv;\n    if (!CryptAcquireContext(&hProv, NULL, MS_SCARD_PROV, PROV_RSA_FULL, 0)) {\n        DWORD dwError = GetLastError();\n        if (dwError == NTE_BAD_KEYSET) {\n            printf(\"IC\u30ab\u30fc\u30c9\u3092\u633f\u5165\u3057\u3066\u304f\u3060\u3055\u3044\");\n            return FALSE;\n        }\n        printf(\"CryptAcquireContext() FAIL %08X\\n\", GetLastError());\n        return FALSE;\n    }\n    HCRYPTKEY hKey;\n    if (!CryptGetUserKey(hProv, AT_KEYEXCHANGE, &hKey)) {\n        printf(\"CryptGetUserKey() FAIL %08X\\n\", GetLastError());\n        CryptReleaseContext(hProv, 0);\n        return FALSE;\n    }\n\n    if (!CertView(hKey)) return FALSE;\n\n    DWORD dwKeySize;\n    DWORD cbKeySize = sizeof(DWORD);\n    if (!CryptGetKeyParam(hKey, KP_BLOCKLEN, (BYTE*)&dwKeySize, &cbKeySize, 0)) {\n        printf(\"CryptGetKeyParam() FAIL %08X\\n\", GetLastError());\n        CryptReleaseContext(hProv, 0);\n        return FALSE;\n    }\n    if (dwKeySize != 2048) {\n        printf(\"RSA KeySize Error\\n\");\n        CryptReleaseContext(hProv, 0);\n        return FALSE;\n    }\n    DWORD dwKey = 256;\n    if (!CryptDecrypt(hKey, NULL, TRUE, 0, pbKey, &dwKey)) {\n        if (GetLastError() == SCARD_W_CANCELLED_BY_USER) {\n            printf(\"\u30e6\u30fc\u30b6\u30fc\u306b\u3088\u3063\u3066\u30ad\u30e3\u30f3\u30bb\u30eb\u3055\u308c\u307e\u3057\u305f\\n\");\n            CryptReleaseContext(hProv, 0);\n            return FALSE;\n        }\n        printf(\"CryptDecrypt() FAIL %08X\\n\", GetLastError());\n        CryptReleaseContext(hProv, 0);\n        return FALSE;\n    }\n    CryptReleaseContext(hProv, 0);\n    return TRUE;\n}\n\n\nint enc(char *s, char *d, char *p) {\n    HANDLE hFile;\n    hFile = CreateFileA(s, GENERIC_READ, 0, NULL, OPEN_EXISTING, 0, 0);\n    if (hFile == INVALID_HANDLE_VALUE) {\n        printf(\"CreateFile() %08X\\n\", GetLastError());\n        return -1;\n    }\n    DWORD dwFile = GetFileSize(hFile, NULL);\n    if (dwFile == INVALID_FILE_SIZE) {\n        printf(\"GetFileSize() %08X\\n\", GetLastError());\n        CloseHandle(hFile);\n        return -1;\n    }\n    BYTE *x = (BYTE*)malloc(256 + dwFile + 16);\n    if (x == NULL) {\n        printf(\"out of memory\\n\");\n        CloseHandle(hFile);\n        return -1;\n    }\n    if (!CryptGenRandom(g_hProv, 32, x)) {\n        printf(\"CryptGenRandom() FAIL %08X\\n\", GetLastError());\n        free(x);\n        CloseHandle(hFile);\n        return -1;\n    }\n    CopyMemory(g_pbKey + 12, x, 32);\n    if (!password_key(p)) {\n        free(x);\n        CloseHandle(hFile);\n        return -1;\n    }\n    if (!rsaenc(x)) {\n        free(x);\n        CloseHandle(hFile);\n        return -1;\n    }\n    DWORD dwRead;\n    if (!ReadFile(hFile, x + 256, dwFile, &dwRead, NULL)) {\n        printf(\"ReadFile() FAIL %08X\\n\", GetLastError());\n        free(x);\n        CloseHandle(hFile);\n        return -1;\n    }\n    if (dwFile != dwRead) {\n        printf(\"ReadFile() ERROR\\n\");\n        free(x);\n        CloseHandle(hFile);\n        return -1;\n    }\n    CloseHandle(hFile);\n\n    HCRYPTKEY hKey;\n    if (!CryptImportKey(g_hProv, g_pbKey, 44, NULL, 0, &hKey)) {\n        printf(\"CryptImportKey() FAIL %08X\\n\", GetLastError());\n        free(x);\n        return -1;\n    }\n    DWORD dwParam = CRYPT_MODE_CBC;\n    if (!CryptSetKeyParam(hKey, KP_MODE, (BYTE*)&dwParam, 0)) {\n        printf(\"CryptSetKeyParam() FAIL %08X\", GetLastError());\n        free(x);\n        CryptDestroyKey(hKey);\n        return -1;\n    }\n    dwParam = PKCS5_PADDING;\n    if (!CryptSetKeyParam(hKey, KP_PADDING, (BYTE*)&dwParam, 0)) {\n        printf(\"CryptSetKeyParam() FAIL %08X\", GetLastError());\n        free(x);\n        CryptDestroyKey(hKey);\n        return -1;\n    }\n    BYTE pbIV[16];\n    ZeroMemory(pbIV, 16);\n    if (!CryptSetKeyParam(hKey, KP_IV, pbIV, 0)) {\n        printf(\"CryptSetKeyParam() FAIL %08X\", GetLastError());\n        free(x);\n        CryptDestroyKey(hKey);\n        return -1;\n    }\n    if (!CryptEncrypt(hKey, 0, TRUE, 0, x + 256, &dwFile, dwFile + 16)) {\n        printf(\"CryptEncrypt() FAIL %08X\\n\", GetLastError());\n        free(x);\n        CryptDestroyKey(hKey);\n        return -1;\n    }\n    CryptDestroyKey(hKey);\n\n    hFile = CreateFileA(d, GENERIC_WRITE, 0, NULL, CREATE_NEW, FILE_ATTRIBUTE_NORMAL, 0);\n    if (hFile == INVALID_HANDLE_VALUE) {\n        printf(\"CreateFile() %08X\\n\", GetLastError());\n        free(x);\n        return -1;\n    }\n\n    DWORD dwWrite;\n    if (!WriteFile(hFile, x, 256 + dwFile, &dwWrite, NULL)) {\n        printf(\"WriteFile() FAIL %08X\\n\", GetLastError());\n        free(x);\n        CloseHandle(hFile);\n        return -1;\n    }\n    if (256 + dwFile != dwWrite) {\n        printf(\"WriteFile() ERROR\\n\");\n        free(x);\n        CloseHandle(hFile);\n        return -1;\n    }\n    free(x);\n    CloseHandle(hFile);\n    return 0;\n}\n\n\nint dec(char *s, char *d, char *p) {\n    HANDLE hFile;\n    hFile = CreateFileA(s, GENERIC_READ, 0, NULL, OPEN_EXISTING, 0, 0);\n    if (hFile == INVALID_HANDLE_VALUE) {\n        printf(\"CreateFile() %08X\\n\", GetLastError());\n        return -1;\n    }\n    DWORD dwFile = GetFileSize(hFile, NULL);\n    if (dwFile == INVALID_FILE_SIZE) {\n        printf(\"GetFileSize() %08X\\n\", GetLastError());\n        CloseHandle(hFile);\n        return -1;\n    }\n    BYTE *x = (BYTE*)malloc(dwFile);\n    if (x == NULL) {\n        printf(\"out of memory\\n\");\n        CloseHandle(hFile);\n        return -1;\n    }\n\n    DWORD dwRead;\n    if (!ReadFile(hFile, x, dwFile, &dwRead, NULL)) {\n        printf(\"ReadFile() FAIL %08X\\n\", GetLastError());\n        free(x);\n        CloseHandle(hFile);\n        return -1;\n    }\n    if (dwFile != dwRead) {\n        printf(\"ReadFile() ERROR\\n\");\n        free(x);\n        CloseHandle(hFile);\n        return -1;\n    }\n    CloseHandle(hFile);\n\n    if (!rsadec(x)) {\n        free(x);\n        return -1;\n    }\n    CopyMemory(g_pbKey + 12, x, 32);\n    if (!password_key(p)) {\n        free(x);\n        return -1;\n    }\n\n    HCRYPTKEY hKey;\n    if (!CryptImportKey(g_hProv, g_pbKey, 44, NULL, 0, &hKey)) {\n        printf(\"CryptImportKey() FAIL %08X\\n\", GetLastError());\n        free(x);\n        return -1;\n    }\n    DWORD dwParam = CRYPT_MODE_CBC;\n    if (!CryptSetKeyParam(hKey, KP_MODE, (BYTE*)&dwParam, 0)) {\n        printf(\"CryptSetKeyParam() FAIL %08X\", GetLastError());\n        free(x);\n        CryptDestroyKey(hKey);\n        return -1;\n    }\n    dwParam = PKCS5_PADDING;\n    if (!CryptSetKeyParam(hKey, KP_PADDING, (BYTE*)&dwParam, 0)) {\n        printf(\"CryptSetKeyParam() FAIL %08X\", GetLastError());\n        free(x);\n        CryptDestroyKey(hKey);\n        return -1;\n    }\n    BYTE pbIV[16];\n    ZeroMemory(pbIV, 16);\n    if (!CryptSetKeyParam(hKey, KP_IV, pbIV, 0)) {\n        printf(\"CryptSetKeyParam() FAIL %08X\", GetLastError());\n        free(x);\n        CryptDestroyKey(hKey);\n        return -1;\n    }\n    DWORD dwLen = dwFile - 256;\n    if (!CryptDecrypt(hKey, 0, TRUE, 0, x + 256, &dwLen)) {\n        printf(\"CryptDecrypt() FAIL %08X\", GetLastError());\n        free(x);\n        CryptDestroyKey(hKey);\n        return -1;\n    }\n    CryptDestroyKey(hKey);\n\n    hFile = CreateFileA(d, GENERIC_WRITE, 0, NULL, CREATE_NEW, FILE_ATTRIBUTE_NORMAL, 0);\n    if (hFile == INVALID_HANDLE_VALUE) {\n        printf(\"CreateFile() %08X\\n\", GetLastError());\n        free(x);\n        return -1;\n    }\n\n    DWORD dwWrite;\n    if (!WriteFile(hFile, x + 256, dwLen, &dwWrite, NULL)) {\n        printf(\"WriteFile() FAIL %08X\\n\", GetLastError());\n        free(x);\n        CloseHandle(hFile);\n        return -1;\n    }\n    if (dwLen != dwWrite) {\n        printf(\"WriteFile() ERROR\\n\");\n        free(x);\n        CloseHandle(hFile);\n        return -1;\n    }\n    free(x);\n    CloseHandle(hFile);\n    return 0;\n}\n\n\nint main(int argc, char *argv[]) {\n    if (argc != 5) {\n        printf(\"Usage: icenc e <source filename> <destination filename> <password>\\n\"\n            \"       icenc d <source filename> <destination filename> <password>\\n\");\n        return -1;\n    }\n\n    if (!IsWindowsXPSP3OrGreater()) {\n        printf(\"You need at least Windows XP with SP3\");\n        return -1;\n    }\n\n    char *szCSP = MSCSP51;\n    if (IsWindowsVersionOrGreater(5, 2, 0)) szCSP = MSCSP52;\n\n    if (!CryptAcquireContextA(&g_hProv, NULL, szCSP, PROV_RSA_AES, 0)) {\n        if (!CryptAcquireContextA(&g_hProv, NULL, szCSP, PROV_RSA_AES, CRYPT_NEWKEYSET)) {\n            printf(\"CryptAcquireContext() FAIL %08X\\n\", GetLastError());\n            return -1;\n        }\n    }\n\n    if (argv[1][0] != 'e' && argv[1][0] != 'd') {\n        CryptReleaseContext(g_hProv, 0);\n        printf(\"Invalid argument\\n\");\n        return -1;\n    }\n    int ret = -1;\n    if (argv[1][0] == 'e') ret = enc(argv[2], argv[3], argv[4]);\n    if (argv[1][0] == 'd') ret = dec(argv[2], argv[3], argv[4]);\n    CryptReleaseContext(g_hProv, 0);\n    if (ret == 0) printf(\"Success!\\n\");\n    return ret;\n}\n\n\n\n#\u306f\u3058\u3081\u306b\n[\u682a\u5f0f\u4f1a\u793eiCanal](http://icanal.idletime.tokyo/)\u306e\u30b5\u30a4\u30c8\u3067\u516c\u958b\u3057\u3066\u3044\u305fIC\u30ab\u30fc\u30c9\u3092\u4f7f\u3063\u305f\u30d5\u30a1\u30a4\u30eb\u6697\u53f7\u30bd\u30d5\u30c8\u306e\u6295\u7a3f\u3067\u3059\u3002\n2013\uff5e2015\u5e74\u9803\u306b\u516c\u958b\u3057\u3066\u3044\u305f\u306e\u3067\u3059\u304c\u81ea\u793e(\u682a\u5f0f\u4f1a\u793eiCanal)\u306e[\u30d5\u30a1\u30a4\u30eb\u6697\u53f7\u30bd\u30d5\u30c8ToraTora](http://icanal.idletime.tokyo/toratora/)\u3068\u7af6\u5408\u3057\u3066\u3057\u307e\u3046\u305f\u3081\u516c\u958b\u3092\u505c\u6b62\u3057\u3066\u3044\u307e\u3057\u305f\u3002\n\u6700\u65b0\u7248\u306eToraTora\u3067\u306f\u3001\u3053\u308c\u3088\u308a\u3082\u82e5\u5e72\u5f37\u5ea6\u304c\u9ad8\u3044RSA\u6697\u53f7\u3092\u4f7f\u3046\u3088\u3046\u306b\u30d0\u30fc\u30b8\u30e7\u30f3\u30a2\u30c3\u30d7\u3057\u305f\u306e\u3067\u3001\u518d\u3073Qiita\u3067\u516c\u958b\u3059\u308b\u3053\u3068\u306b\u3057\u307e\u3057\u305f\u3002\n\n#\u3053\u306e\u30d5\u30a1\u30a4\u30eb\u6697\u53f7\u30bd\u30d5\u30c8\u306e\u7279\u5fb4\n\u30d1\u30b9\u30ef\u30fc\u30c9\u3068IC\u30ab\u30fc\u30c9\u306e\u4f75\u7528\u306b\u3088\u3063\u3066\u30d1\u30b9\u30ef\u30fc\u30c9\u30af\u30e9\u30c3\u30af\u306b\u5f37\u3044AES\u6697\u53f7 256bit\u306e\u6697\u53f7\u5316\u304c\u3067\u304d\u307e\u3059\u3002\n\n#\u4f7f\u3048\u308bIC\u30ab\u30fc\u30c9\nBaseCSP\u306b\u5bfe\u5fdc\u3057\u305fIC\u30ab\u30fc\u30c9\u3067\u3042\u308c\u3070\u5e02\u8ca9\u306eIC\u30ab\u30fc\u30c9\u3067\u3082\u5229\u7528\u53ef\u80fd\u3067\u3059\u3002IC\u30ab\u30fc\u30c9\u304c\u306a\u3044\u5834\u5408\u306f\u7121\u6599\u306e\u30a8\u30df\u30e5\u30ec\u30fc\u30bf[myuToken](http://icanal.idletime.tokyo/myutoken/)\u3092\u4f7f\u3044\u307e\u3059\u3002\u958b\u767a\u3060\u3051\u306a\u3089USB\u30e1\u30e2\u30ea\u3092\u4f7f\u3063\u305f\u30a8\u30df\u30e5\u30ec\u30fc\u30bf\u3088\u308a\u3082[SiMyuCard](http://icanal.idletime.tokyo/SiMyuCard/)\u3092\u4f7f\u3063\u305f\u307b\u3046\u304c\u4fbf\u5229\u304b\u3082\u3057\u308c\u307e\u305b\u3093\u3002SiMyuCard\u306e\u30c7\u30d0\u30a4\u30b9\u30c9\u30e9\u30a4\u30d0\u306f\u30b3\u30fc\u30c9\u7f72\u540d\u304c\u3064\u3044\u3066\u3044\u308b\u306e\u3067\u30a4\u30f3\u30b9\u30c8\u30fc\u30eb\u304c\u7c21\u5358\u3067\u3059\u3002\n\n\u96fb\u5b50\u8a3c\u660e\u66f8\u306eRSA\u6697\u53f7\u306e\u79d8\u5bc6\u9375\u3092\u4f7f\u3063\u3066\u6697\u53f7\u5316\u3057\u307e\u3059\u3002\u3042\u3089\u304b\u3058\u3081\u96fb\u5b50\u8a3c\u660e\u66f8\u3092\u30a4\u30f3\u30dd\u30fc\u30c8\u3057\u3066\u304a\u304f\u5fc5\u8981\u304c\u3042\u308a\u307e\u3059\u3002\n\n#\u52d5\u4f5cOS\u3068\u958b\u767a\u74b0\u5883\nWindows XP SP3\u4ee5\u964d\u306ePC\u3067\u52d5\u4f5c\u3059\u308b\u3053\u3068\u304c\u8003\u3048\u3089\u308c\u305f\u30bd\u30fc\u30b9\u3067\u3059\u3002 Visual Studio 2008 C++\u3068Visual Studio 2010 C++\u3068Visual Studio 2013 C++\u3067\u30b3\u30f3\u30d1\u30a4\u30eb\u3067\u304d\u308b\u3053\u3068\u3092\u78ba\u8a8d\u3057\u3066\u3044\u307e\u3059\u3002\n\n#\u514d\u8cac\n\u3053\u306e\u65b9\u6cd5\u3067\u640d\u5bb3\u3092\u88ab\u3063\u3066\u3082\u8cac\u4efb\u3092\u8ca0\u3044\u307e\u305b\u3093\u3001\u3042\u3089\u304b\u3058\u3081\u3054\u4e86\u627f\u306d\u304c\u3044\u307e\u3059\u3002\n\n#\u30bd\u30fc\u30b9\u30b3\u30fc\u30c9\n```icenc.cpp\n/* File Encrypt Sample\n2013/12/24 Ver1.1\nRSA 2048bit\u5c02\u7528\nWindows XP\u306b\u5bfe\u5fdc\u3059\u308b\u5834\u5408\u3001\n\u30d7\u30e9\u30c3\u30c8\u30d5\u30a9\u30fc\u30e0\u30c4\u30fc\u30eb\u30bb\u30c3\u30c8 Visual Studio 2013 - WindowsXP\u3092\u9078\u629e\u3057\u3066\u304f\u3060\u3055\u3044\u3002\n*/\n#define _WIN32_WINNT 0x0501 // Windows XPSP3\u4ee5\u964d\n#include <SDKDDKVer.h>\n#include <stdio.h>\n#include <Windows.h>\n#include <Cryptuiapi.h>\n\n#if 0 // \u30d7\u30e9\u30c3\u30c8\u30d5\u30a9\u30fc\u30e0\u30c4\u30fc\u30eb\u30bb\u30c3\u30c8 Visual Studio 2013 - WindowsXP\u3092\u9078\u629e\u3057\u305f\u5834\u5408\u306f 0\n#include <VersionHelpers.h>\n#else\nBOOL IsWindowsVersionOrGreater(WORD dwMajor, WORD dwMinor, WORD dwSPMajor)\n{\n\tDWORDLONG dwlConditionMask = 0;\n\tOSVERSIONINFOEX osvi;\n\tZeroMemory(&osvi, sizeof(OSVERSIONINFOEX));\n\n\tosvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);\n\tosvi.dwMajorVersion = dwMajor;\n\tosvi.dwMinorVersion = dwMinor;\n\tosvi.wServicePackMajor = dwSPMajor;// Set up the condition mask.\n\n\tVER_SET_CONDITION(dwlConditionMask, VER_MAJORVERSION, VER_GREATER_EQUAL);\n\tVER_SET_CONDITION(dwlConditionMask, VER_MINORVERSION, VER_GREATER_EQUAL);\n\tVER_SET_CONDITION(dwlConditionMask, VER_SERVICEPACKMAJOR, VER_GREATER_EQUAL);\n\n\t// Perform the test.\n\treturn VerifyVersionInfo(&osvi, VER_MAJORVERSION\n\t\t| VER_MINORVERSION\n\t\t| VER_SERVICEPACKMAJOR,\n\t\tdwlConditionMask);\n}\n\nBOOL IsWindowsXPSP3OrGreater() {\n\treturn IsWindowsVersionOrGreater(5, 1, 3);\n}\n#endif\n\n#pragma comment(lib,\"crypt32.lib\")\n#pragma comment(lib,\"cryptui.lib\")\n\n#define MSCSP51 \"Microsoft Enhanced RSA and AES Cryptographic Provider (Prototype)\"\n#define MSCSP52 \"Microsoft Enhanced RSA and AES Cryptographic Provider\"\n#ifndef CALG_SHA_256\n#define CALG_SHA_256 0x0000800c\n#endif\n\nBYTE g_pbKey[44] = {\n\t0x08, 0x02, 0x00, 0x00,\n\t0x10, 0x66, 0x00, 0x00, // CALG_AES_256\n\t0x20, 0x00, 0x00, 0x00, // 32BYTE\n\t0x00, 0x00, 0x00, 0x00, // AES 256bit Key 32Byte\n\t0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00\n};\n\nHCRYPTPROV g_hProv;\n\nBOOL password_key(char *p) {\n\t// \u7c21\u5358\u306e\u305f\u3081SHA-256\u3067\u4ee3\u7528\u3002PKCS#5\u306a\u3069\u3092\u53c2\u8003\u306b\u3002\n\tint i;\n\tHCRYPTHASH hHash;\n\tBYTE pbPK[32];\n\tDWORD cbPK = sizeof(pbPK);\n\tif (!CryptCreateHash(g_hProv, CALG_SHA_256, NULL, 0, &hHash)) {\n\t\tprintf(\"CryptCreateHash() FAIL %08\\n\", GetLastError());\n\t\treturn FALSE;\n\t}\n\tif (!CryptHashData(hHash, (BYTE*)p, (DWORD)strlen(p), 0)) {\n\t\tprintf(\"CryptHashData() FAIL %08X\\n\", GetLastError());\n\t\tCryptDestroyHash(hHash);\n\t\treturn FALSE;\n\t}\n\tif (!CryptGetHashParam(hHash, HP_HASHVAL, pbPK, &cbPK, 0)) {\n\t\tprintf(\"CryptGetHashParam() FAIL %08X\", GetLastError());\n\t\tCryptDestroyHash(hHash);\n\t\treturn FALSE;\n\t}\n\tCryptDestroyHash(hHash);\n\tfor (i = 0; i<32; i++) g_pbKey[12 + i] ^= pbPK[i];\n\treturn TRUE;\n}\n\nBOOL CertView(HCRYPTKEY hKey) {\n\tBYTE pbCert[8192];\n\tDWORD cbCert = sizeof(pbCert);\n\tif (!CryptGetKeyParam(hKey, KP_CERTIFICATE, pbCert, &cbCert, 0)) {\n\t\tprintf(\"CryptGetKeyParam() FAIL %08X\\n\", GetLastError());\n\t\treturn FALSE;\n\t}\n\tPCCERT_CONTEXT pCertContext = CertCreateCertificateContext(X509_ASN_ENCODING, pbCert, cbCert);\n\tif (pCertContext == NULL) {\n\t\tprintf(\"CertCreateCertificateContext() FAIL %08X\\n\", GetLastError());\n\t\treturn FALSE;\n\t}\n\tif (!CryptUIDlgViewContext(CERT_STORE_CERTIFICATE_CONTEXT, pCertContext, NULL, L\"icenc\", 0, NULL)) {\n\t\tprintf(\"CryptUIDlgViewContext() FAIL %08X\\n\", GetLastError());\n\t\tCertFreeCertificateContext(pCertContext);\n\t\treturn FALSE;\n\t}\n\tCertFreeCertificateContext(pCertContext);\n\treturn TRUE;\n}\n\n\nBOOL rsaenc(BYTE *pbKey) {\n\tHCRYPTPROV hProv;\n\tif (!CryptAcquireContext(&hProv, NULL, MS_SCARD_PROV, PROV_RSA_FULL, 0)) {\n\t\tDWORD dwError = GetLastError();\n\t\tif (dwError == NTE_BAD_KEYSET) {\n\t\t\tprintf(\"IC\u30ab\u30fc\u30c9\u3092\u633f\u5165\u3057\u3066\u304f\u3060\u3055\u3044\");\n\t\t\treturn FALSE;\n\t\t}\n\t\tprintf(\"CryptAcquireContext() FAIL %08X\\n\", GetLastError());\n\t\treturn FALSE;\n\t}\n\tHCRYPTKEY hKey;\n\tif (!CryptGetUserKey(hProv, AT_KEYEXCHANGE, &hKey)) {\n\t\tprintf(\"CryptGetUserKey() FAIL %08X\\n\", GetLastError());\n\t\tCryptReleaseContext(hProv, 0);\n\t\treturn FALSE;\n\t}\n\n\tif (!CertView(hKey)) return FALSE;\n\n\tDWORD dwKeySize;\n\tDWORD cbKeySize = sizeof(DWORD);\n\tif (!CryptGetKeyParam(hKey, KP_BLOCKLEN, (BYTE*)&dwKeySize, &cbKeySize, 0)) {\n\t\tprintf(\"CryptGetKeyParam() FAIL %08X\\n\", GetLastError());\n\t\tCryptReleaseContext(hProv, 0);\n\t\treturn FALSE;\n\t}\n\tif (dwKeySize != 2048) {\n\t\tprintf(\"RSA KeySize Error\\n\");\n\t\tCryptReleaseContext(hProv, 0);\n\t\treturn FALSE;\n\t}\n\tDWORD dwKey = 32;\n\tif (!CryptEncrypt(hKey, NULL, TRUE, 0, pbKey, &dwKey, 256)) {\n\t\tprintf(\"CryptEncrypt() FAIL %08X\\n\", GetLastError());\n\t\tCryptReleaseContext(hProv, 0);\n\t\treturn FALSE;\n\t}\n\tCryptReleaseContext(hProv, 0);\n\treturn TRUE;\n}\n\nBOOL rsadec(BYTE *pbKey) {\n\tHCRYPTPROV hProv;\n\tif (!CryptAcquireContext(&hProv, NULL, MS_SCARD_PROV, PROV_RSA_FULL, 0)) {\n\t\tDWORD dwError = GetLastError();\n\t\tif (dwError == NTE_BAD_KEYSET) {\n\t\t\tprintf(\"IC\u30ab\u30fc\u30c9\u3092\u633f\u5165\u3057\u3066\u304f\u3060\u3055\u3044\");\n\t\t\treturn FALSE;\n\t\t}\n\t\tprintf(\"CryptAcquireContext() FAIL %08X\\n\", GetLastError());\n\t\treturn FALSE;\n\t}\n\tHCRYPTKEY hKey;\n\tif (!CryptGetUserKey(hProv, AT_KEYEXCHANGE, &hKey)) {\n\t\tprintf(\"CryptGetUserKey() FAIL %08X\\n\", GetLastError());\n\t\tCryptReleaseContext(hProv, 0);\n\t\treturn FALSE;\n\t}\n\n\tif (!CertView(hKey)) return FALSE;\n\n\tDWORD dwKeySize;\n\tDWORD cbKeySize = sizeof(DWORD);\n\tif (!CryptGetKeyParam(hKey, KP_BLOCKLEN, (BYTE*)&dwKeySize, &cbKeySize, 0)) {\n\t\tprintf(\"CryptGetKeyParam() FAIL %08X\\n\", GetLastError());\n\t\tCryptReleaseContext(hProv, 0);\n\t\treturn FALSE;\n\t}\n\tif (dwKeySize != 2048) {\n\t\tprintf(\"RSA KeySize Error\\n\");\n\t\tCryptReleaseContext(hProv, 0);\n\t\treturn FALSE;\n\t}\n\tDWORD dwKey = 256;\n\tif (!CryptDecrypt(hKey, NULL, TRUE, 0, pbKey, &dwKey)) {\n\t\tif (GetLastError() == SCARD_W_CANCELLED_BY_USER) {\n\t\t\tprintf(\"\u30e6\u30fc\u30b6\u30fc\u306b\u3088\u3063\u3066\u30ad\u30e3\u30f3\u30bb\u30eb\u3055\u308c\u307e\u3057\u305f\\n\");\n\t\t\tCryptReleaseContext(hProv, 0);\n\t\t\treturn FALSE;\n\t\t}\n\t\tprintf(\"CryptDecrypt() FAIL %08X\\n\", GetLastError());\n\t\tCryptReleaseContext(hProv, 0);\n\t\treturn FALSE;\n\t}\n\tCryptReleaseContext(hProv, 0);\n\treturn TRUE;\n}\n\n\nint enc(char *s, char *d, char *p) {\n\tHANDLE hFile;\n\thFile = CreateFileA(s, GENERIC_READ, 0, NULL, OPEN_EXISTING, 0, 0);\n\tif (hFile == INVALID_HANDLE_VALUE) {\n\t\tprintf(\"CreateFile() %08X\\n\", GetLastError());\n\t\treturn -1;\n\t}\n\tDWORD dwFile = GetFileSize(hFile, NULL);\n\tif (dwFile == INVALID_FILE_SIZE) {\n\t\tprintf(\"GetFileSize() %08X\\n\", GetLastError());\n\t\tCloseHandle(hFile);\n\t\treturn -1;\n\t}\n\tBYTE *x = (BYTE*)malloc(256 + dwFile + 16);\n\tif (x == NULL) {\n\t\tprintf(\"out of memory\\n\");\n\t\tCloseHandle(hFile);\n\t\treturn -1;\n\t}\n\tif (!CryptGenRandom(g_hProv, 32, x)) {\n\t\tprintf(\"CryptGenRandom() FAIL %08X\\n\", GetLastError());\n\t\tfree(x);\n\t\tCloseHandle(hFile);\n\t\treturn -1;\n\t}\n\tCopyMemory(g_pbKey + 12, x, 32);\n\tif (!password_key(p)) {\n\t\tfree(x);\n\t\tCloseHandle(hFile);\n\t\treturn -1;\n\t}\n\tif (!rsaenc(x)) {\n\t\tfree(x);\n\t\tCloseHandle(hFile);\n\t\treturn -1;\n\t}\n\tDWORD dwRead;\n\tif (!ReadFile(hFile, x + 256, dwFile, &dwRead, NULL)) {\n\t\tprintf(\"ReadFile() FAIL %08X\\n\", GetLastError());\n\t\tfree(x);\n\t\tCloseHandle(hFile);\n\t\treturn -1;\n\t}\n\tif (dwFile != dwRead) {\n\t\tprintf(\"ReadFile() ERROR\\n\");\n\t\tfree(x);\n\t\tCloseHandle(hFile);\n\t\treturn -1;\n\t}\n\tCloseHandle(hFile);\n\n\tHCRYPTKEY hKey;\n\tif (!CryptImportKey(g_hProv, g_pbKey, 44, NULL, 0, &hKey)) {\n\t\tprintf(\"CryptImportKey() FAIL %08X\\n\", GetLastError());\n\t\tfree(x);\n\t\treturn -1;\n\t}\n\tDWORD dwParam = CRYPT_MODE_CBC;\n\tif (!CryptSetKeyParam(hKey, KP_MODE, (BYTE*)&dwParam, 0)) {\n\t\tprintf(\"CryptSetKeyParam() FAIL %08X\", GetLastError());\n\t\tfree(x);\n\t\tCryptDestroyKey(hKey);\n\t\treturn -1;\n\t}\n\tdwParam = PKCS5_PADDING;\n\tif (!CryptSetKeyParam(hKey, KP_PADDING, (BYTE*)&dwParam, 0)) {\n\t\tprintf(\"CryptSetKeyParam() FAIL %08X\", GetLastError());\n\t\tfree(x);\n\t\tCryptDestroyKey(hKey);\n\t\treturn -1;\n\t}\n\tBYTE pbIV[16];\n\tZeroMemory(pbIV, 16);\n\tif (!CryptSetKeyParam(hKey, KP_IV, pbIV, 0)) {\n\t\tprintf(\"CryptSetKeyParam() FAIL %08X\", GetLastError());\n\t\tfree(x);\n\t\tCryptDestroyKey(hKey);\n\t\treturn -1;\n\t}\n\tif (!CryptEncrypt(hKey, 0, TRUE, 0, x + 256, &dwFile, dwFile + 16)) {\n\t\tprintf(\"CryptEncrypt() FAIL %08X\\n\", GetLastError());\n\t\tfree(x);\n\t\tCryptDestroyKey(hKey);\n\t\treturn -1;\n\t}\n\tCryptDestroyKey(hKey);\n\n\thFile = CreateFileA(d, GENERIC_WRITE, 0, NULL, CREATE_NEW, FILE_ATTRIBUTE_NORMAL, 0);\n\tif (hFile == INVALID_HANDLE_VALUE) {\n\t\tprintf(\"CreateFile() %08X\\n\", GetLastError());\n\t\tfree(x);\n\t\treturn -1;\n\t}\n\n\tDWORD dwWrite;\n\tif (!WriteFile(hFile, x, 256 + dwFile, &dwWrite, NULL)) {\n\t\tprintf(\"WriteFile() FAIL %08X\\n\", GetLastError());\n\t\tfree(x);\n\t\tCloseHandle(hFile);\n\t\treturn -1;\n\t}\n\tif (256 + dwFile != dwWrite) {\n\t\tprintf(\"WriteFile() ERROR\\n\");\n\t\tfree(x);\n\t\tCloseHandle(hFile);\n\t\treturn -1;\n\t}\n\tfree(x);\n\tCloseHandle(hFile);\n\treturn 0;\n}\n\n\nint dec(char *s, char *d, char *p) {\n\tHANDLE hFile;\n\thFile = CreateFileA(s, GENERIC_READ, 0, NULL, OPEN_EXISTING, 0, 0);\n\tif (hFile == INVALID_HANDLE_VALUE) {\n\t\tprintf(\"CreateFile() %08X\\n\", GetLastError());\n\t\treturn -1;\n\t}\n\tDWORD dwFile = GetFileSize(hFile, NULL);\n\tif (dwFile == INVALID_FILE_SIZE) {\n\t\tprintf(\"GetFileSize() %08X\\n\", GetLastError());\n\t\tCloseHandle(hFile);\n\t\treturn -1;\n\t}\n\tBYTE *x = (BYTE*)malloc(dwFile);\n\tif (x == NULL) {\n\t\tprintf(\"out of memory\\n\");\n\t\tCloseHandle(hFile);\n\t\treturn -1;\n\t}\n\n\tDWORD dwRead;\n\tif (!ReadFile(hFile, x, dwFile, &dwRead, NULL)) {\n\t\tprintf(\"ReadFile() FAIL %08X\\n\", GetLastError());\n\t\tfree(x);\n\t\tCloseHandle(hFile);\n\t\treturn -1;\n\t}\n\tif (dwFile != dwRead) {\n\t\tprintf(\"ReadFile() ERROR\\n\");\n\t\tfree(x);\n\t\tCloseHandle(hFile);\n\t\treturn -1;\n\t}\n\tCloseHandle(hFile);\n\n\tif (!rsadec(x)) {\n\t\tfree(x);\n\t\treturn -1;\n\t}\n\tCopyMemory(g_pbKey + 12, x, 32);\n\tif (!password_key(p)) {\n\t\tfree(x);\n\t\treturn -1;\n\t}\n\n\tHCRYPTKEY hKey;\n\tif (!CryptImportKey(g_hProv, g_pbKey, 44, NULL, 0, &hKey)) {\n\t\tprintf(\"CryptImportKey() FAIL %08X\\n\", GetLastError());\n\t\tfree(x);\n\t\treturn -1;\n\t}\n\tDWORD dwParam = CRYPT_MODE_CBC;\n\tif (!CryptSetKeyParam(hKey, KP_MODE, (BYTE*)&dwParam, 0)) {\n\t\tprintf(\"CryptSetKeyParam() FAIL %08X\", GetLastError());\n\t\tfree(x);\n\t\tCryptDestroyKey(hKey);\n\t\treturn -1;\n\t}\n\tdwParam = PKCS5_PADDING;\n\tif (!CryptSetKeyParam(hKey, KP_PADDING, (BYTE*)&dwParam, 0)) {\n\t\tprintf(\"CryptSetKeyParam() FAIL %08X\", GetLastError());\n\t\tfree(x);\n\t\tCryptDestroyKey(hKey);\n\t\treturn -1;\n\t}\n\tBYTE pbIV[16];\n\tZeroMemory(pbIV, 16);\n\tif (!CryptSetKeyParam(hKey, KP_IV, pbIV, 0)) {\n\t\tprintf(\"CryptSetKeyParam() FAIL %08X\", GetLastError());\n\t\tfree(x);\n\t\tCryptDestroyKey(hKey);\n\t\treturn -1;\n\t}\n\tDWORD dwLen = dwFile - 256;\n\tif (!CryptDecrypt(hKey, 0, TRUE, 0, x + 256, &dwLen)) {\n\t\tprintf(\"CryptDecrypt() FAIL %08X\", GetLastError());\n\t\tfree(x);\n\t\tCryptDestroyKey(hKey);\n\t\treturn -1;\n\t}\n\tCryptDestroyKey(hKey);\n\n\thFile = CreateFileA(d, GENERIC_WRITE, 0, NULL, CREATE_NEW, FILE_ATTRIBUTE_NORMAL, 0);\n\tif (hFile == INVALID_HANDLE_VALUE) {\n\t\tprintf(\"CreateFile() %08X\\n\", GetLastError());\n\t\tfree(x);\n\t\treturn -1;\n\t}\n\n\tDWORD dwWrite;\n\tif (!WriteFile(hFile, x + 256, dwLen, &dwWrite, NULL)) {\n\t\tprintf(\"WriteFile() FAIL %08X\\n\", GetLastError());\n\t\tfree(x);\n\t\tCloseHandle(hFile);\n\t\treturn -1;\n\t}\n\tif (dwLen != dwWrite) {\n\t\tprintf(\"WriteFile() ERROR\\n\");\n\t\tfree(x);\n\t\tCloseHandle(hFile);\n\t\treturn -1;\n\t}\n\tfree(x);\n\tCloseHandle(hFile);\n\treturn 0;\n}\n\n\nint main(int argc, char *argv[]) {\n\tif (argc != 5) {\n\t\tprintf(\"Usage: icenc e <source filename> <destination filename> <password>\\n\"\n\t\t\t\"       icenc d <source filename> <destination filename> <password>\\n\");\n\t\treturn -1;\n\t}\n\n\tif (!IsWindowsXPSP3OrGreater()) {\n\t\tprintf(\"You need at least Windows XP with SP3\");\n\t\treturn -1;\n\t}\n\n\tchar *szCSP = MSCSP51;\n\tif (IsWindowsVersionOrGreater(5, 2, 0)) szCSP = MSCSP52;\n\n\tif (!CryptAcquireContextA(&g_hProv, NULL, szCSP, PROV_RSA_AES, 0)) {\n\t\tif (!CryptAcquireContextA(&g_hProv, NULL, szCSP, PROV_RSA_AES, CRYPT_NEWKEYSET)) {\n\t\t\tprintf(\"CryptAcquireContext() FAIL %08X\\n\", GetLastError());\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tif (argv[1][0] != 'e' && argv[1][0] != 'd') {\n\t\tCryptReleaseContext(g_hProv, 0);\n\t\tprintf(\"Invalid argument\\n\");\n\t\treturn -1;\n\t}\n\tint ret = -1;\n\tif (argv[1][0] == 'e') ret = enc(argv[2], argv[3], argv[4]);\n\tif (argv[1][0] == 'd') ret = dec(argv[2], argv[3], argv[4]);\n\tCryptReleaseContext(g_hProv, 0);\n\tif (ret == 0) printf(\"Success!\\n\");\n\treturn ret;\n}\n\n```\n"}