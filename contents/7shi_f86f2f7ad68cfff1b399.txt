{"tags": ["C++11"], "context": "C++11\u3067\u4f5c\u3063\u305f\u7c21\u5358\u306a\u30d1\u30fc\u30b5\u30b3\u30f3\u30d3\u30cd\u30fc\u30bf\u3092\u4f7f\u3063\u3066\u56db\u5247\u6f14\u7b97\u5668\u3092\u4f5c\u6210\u3057\u307e\u3059\u3002\n\u3053\u306e\u8a18\u4e8b\u306f\u6b21\u306e\u7d9a\u7de8\u3067\u3059\u3002\n\n\nC++11 \u30d1\u30fc\u30b5\u30b3\u30f3\u30d3\u30cd\u30fc\u30bf \u8d85\u5165\u9580 2015.11.27\n\n\u3053\u306e\u8a18\u4e8b\u306fHaskell\u306e\u8a18\u4e8b\u3092C++11\u3067\u66f8\u304d\u76f4\u3057\u305f\u3082\u306e\u3067\u3059\u3002\n\n\nHaskell \u69cb\u6587\u89e3\u6790 \u8d85\u5165\u9580 2015.07.31\n\n\u3053\u306e\u8a18\u4e8b\u306b\u306fJava\u7248\u304c\u3042\u308a\u307e\u3059\u3002\n\n\nJava \u30d1\u30fc\u30b5\u30b3\u30f3\u30d3\u30cd\u30fc\u30bf \u8d85\u5165\u9580 2016.05.12\n\nJava \u30d1\u30fc\u30b5\u30b3\u30f3\u30d3\u30cd\u30fc\u30bf \u8d85\u5165\u9580 2 2016.05.14\n\n\u3053\u306e\u8a18\u4e8b\u306b\u306f\u95a2\u9023\u8a18\u4e8b\u304c\u3042\u308a\u307e\u3059\u3002\n\n\nJSON\u30d1\u30fc\u30b5\u30fc\u3092\u4f5c\u308b 2016.12.26\n\n\u3053\u306e\u8a18\u4e8b\u3092\u66f8\u304f\u305f\u3081\u306e\u5b9f\u9a13\u7528\u30ea\u30dd\u30b8\u30c8\u30ea\u3067\u3059\u3002\u8a18\u4e8b\u5316\u306b\u969b\u3057\u3066\u30b3\u30fc\u30c9\u306b\u624b\u3092\u52a0\u3048\u305f\u305f\u3081\u4e00\u90e8\u7570\u306a\u308b\u5834\u5408\u304c\u3042\u308a\u307e\u3059\u3002\n\nhttps://bitbucket.org/7shi/parsecpp\n\n\n\u56db\u5247\u6f14\u7b97\u5668\n\u30d1\u30fc\u30b5\u30b3\u30f3\u30d3\u30cd\u30fc\u30bf\u306e\u7df4\u7fd2\u3068\u3057\u3066\u3001\u7c21\u5358\u306a\u56db\u5247\u6f14\u7b97\u5668\u3092\u4f5c\u308a\u307e\u3059\u3002\u6587\u5b57\u5217\u3067\u5f0f\u3092\u4e0e\u3048\u308b\u3068\u8a08\u7b97\u3057\u3066\u7b54\u3048\u3092\u8fd4\u3057\u307e\u3059\u3002\n\u4f8b: \"1+2*3\" \u2192 7\n\u524d\u56de\u4f5c\u3063\u305f\u30d1\u30fc\u30b5\u30b3\u30f3\u30d3\u30cd\u30fc\u30bf\u3092\u6539\u9020\u3057\u306a\u304c\u3089\u9032\u3081\u307e\u3059\u3002\n\n\u524d\u56de\u307e\u3067\u306e parsecpp.cpp\n\n\n\u6570\u5b57\n\u6570\u5b57\u3092\u8aad\u307f\u8fbc\u3080\u30d1\u30fc\u30b5\u3092\u5b9f\u88c5\u3057\u307e\u3059\u3002\u6700\u4f4e\u3067\u30821\u6587\u5b57\u306f\u5fc5\u8981\u306a\u305f\u3081many\uff080\u56de\u4ee5\u4e0a\u306e\u7e70\u308a\u8fd4\u3057\uff09\u3067\u306f\u306a\u304fmany1\uff081\u56de\u4ee5\u4e0a\u306e\u7e70\u308a\u8fd4\u3057\uff09\u3092\u5b9f\u88c5\u3057\u307e\u3059\u3002\n\nparsecpp.cpp\uff08\u8ffd\u52a0\uff09\ntemplate <typename T>\nParser<std::string> many1(const Parser<T> &p) {\n    return p + many(p);\n}\n\n\n\u3053\u308c\u3092\u4f7f\u3063\u3066\u6570\u5b57\u3092\u8aad\u307f\u8fbc\u307f\u307e\u3059\u3002\n#include \"parsecpp.cpp\"\n\nauto number = many1(digit);\n\nint main() {\n    parseTest(number, \"123\");\n}\n\n\n\u5b9f\u884c\u7d50\u679c\n123\n\n\n\n\u6570\u5024\n\u7d50\u679c\u3092\u6570\u5024\u3067\u8fd4\u3059\u3088\u3046\u306b\u4fee\u6b63\u3057\u307e\u3059\u3002\n#include \"parsecpp.cpp\"\n\nint toInt(const std::string &s) {  // \u8ffd\u52a0\n    int ret;\n    std::istringstream(s) >> ret;\n    return ret;\n}\n\nParser<int> number = [](Source *s) {  // \u4fee\u6b63\n    return toInt(many1(digit)(s));\n};\n\nint main() {\n    parseTest(number, \"123\");\n}\n\n\n\u5b9f\u884c\u7d50\u679c\n123\n\n\n\u3053\u306e\u3088\u3046\u306b\u30d1\u30fc\u30b5\u306f\u6587\u5b57\u4ee5\u5916\u3092\u8fd4\u3059\u3088\u3046\u306b\u69cb\u6210\u3067\u304d\u307e\u3059\u3002\n\n\u8db3\u3057\u7b97\n\u8db3\u3057\u7b97\u3092\u8a08\u7b97\u3059\u308b\u30d1\u30fc\u30b5\u3092\u5b9f\u88c5\u3057\u307e\u3059\u3002\u6f14\u7b97\u306e\u5bfe\u8c61\uff08\u30aa\u30da\u30e9\u30f3\u30c9\uff09\u304c2\u3064\u3042\u308b\u305f\u3081\u3001\u30ea\u30b9\u30c8\u3092\u4f7f\u3044\u307e\u3059\u3002\n\u7d50\u679c\u3092\u78ba\u8a8d\u3059\u308b\u305f\u3081\u30ea\u30b9\u30c8\u306e\u8868\u793a\u3092\u5b9f\u88c5\u3057\u307e\u3059\u3002\n\nparsecpp.cpp\uff08\u8ffd\u52a0\uff09\n#include <list>\n\ntemplate <typename T>\nstd::string toString(const std::list<T> &list) {\n    std::stringstream ss;\n    ss << \"[\";\n    for (auto it = list.begin();\n            it != list.end(); ++it) {\n        if (it != list.begin()) ss << \",\";\n        ss << *it;\n    }\n    ss << \"]\";\n    return ss.str();\n}\ntemplate <typename T>\nstd::ostream &operator<<(std::ostream &cout, const std::list<T> &list) {\n    return cout << toString(list);\n}\n\n\n'+'\u3067\u533a\u5207\u3063\u3066\u9805\u3092\u500b\u5225\u306b\u53d6\u308a\u51fa\u3057\u307e\u3059\u3002\n#include \"parsecpp.cpp\"\n\nint toInt(const std::string &s) {\n    int ret;\n    std::istringstream(s) >> ret;\n    return ret;\n}\n\nParser<int> number = [](Source *s) {\n    return toInt(many1(digit)(s));\n};\n\nParser<std::list<int>> expr = [](Source *s) {  // \u8ffd\u52a0\n    int x = number(s);\n    char1('+')(s);\n    int y = number(s);\n    return std::list<int>({x, y});\n};\n\nint main() {\n    parseTest(number, \"123\");\n    parseTest(expr  , \"1+2\");  // \u8ffd\u52a0\n}\n\n\n\u5b9f\u884c\u7d50\u679c\n123\n[1,2]\n\n\n\nmany\n+\u6570\u5024\u3092many\u306b\u3088\u308a0\u56de\u4ee5\u4e0a\u306e\u7e70\u308a\u8fd4\u3057\u3068\u3057\u3066\u6271\u3044\u307e\u3059\u3002\nmany\u304c\u6587\u5b57\u5217\u306b\u7279\u5316\u3057\u305f\u5b9f\u88c5\u3068\u306a\u3063\u3066\u3044\u308b\u305f\u3081\u3001\u591a\u76f8\u5316\u3057\u305f\u4e0a\u3067\u7279\u6b8a\u5316\u3057\u307e\u3059\u3002\n\u5dee\u5206\u3092\u793a\u3057\u307e\u3059\u3002\n--- parsecpp.cpp.orig\n+++ parsecpp.cpp\n@@ -104,7 +104,7 @@\n }\n\n template <typename T>\n-Parser<std::string> many(const Parser<T> &p) {\n+Parser<std::string> many_(const Parser<T> &p) {\n     return [=](Source *s) {\n         std::string ret;\n         try {\n@@ -112,6 +112,22 @@\n         } catch (const std::string &) {}\n         return ret;\n     };\n+}\n+Parser<std::string> many(const Parser<char> &p) {\n+    return many_(p);\n+}\n+Parser<std::string> many(const Parser<std::string> &p) {\n+    return many_(p);\n+}\n+template <typename T>\n+Parser<std::list<T>> many(const Parser<T> &p) {\n+    return [=](Source *s) {\n+        std::list<T> ret;\n+        try {\n+            for (;;) ret.push_back(p(s));\n+        } catch (const std::string &) {}\n+        return ret;\n+    };\n }\n\n template <typename T>\n\n\n\u4fee\u6b63\u5f8c\u306e parsecpp.cpp\n\nmany\u306b\u6e21\u3059\u30d1\u30fc\u30b5\u306f\u30b3\u30fc\u30c9\u3067\u5b9a\u7fa9\u3059\u308b\u305f\u3081\u3001\u578b\u3092\u660e\u793a\u3057\u305f\u30e9\u30e0\u30c0\u5f0f\u3092\u4f7f\u3044\u307e\u3059\u3002\n#include \"parsecpp.cpp\"\n\nint toInt(const std::string &s) {\n    int ret;\n    std::istringstream(s) >> ret;\n    return ret;\n}\n\nParser<int> number = [](Source *s) {\n    return toInt(many1(digit)(s));\n};\n\nParser<std::list<int>> expr = [](Source *s) {\n    int x = number(s);\n    auto xs = many(Parser<int>([](Source *s) {  // \u7e70\u308a\u8fd4\u3057\n        char1('+')(s);\n        return number(s);\n    }))(s);\n    xs.push_front(x);  // \u9023\u7d50\n    return xs;\n};\n\nint main() {\n    parseTest(number, \"123\"  );\n    parseTest(expr  , \"1+2\"  );  // '+'\u304c1\u500b\n    parseTest(expr  , \"123\"  );  // '+'\u304c0\u500b\n    parseTest(expr  , \"1+2+3\");  // '+'\u304c2\u500b\n}\n\n\n\u5b9f\u884c\u7d50\u679c\n123\n[1,2]\n[123]\n[1,2,3]\n\n\n\n\u7d50\u679c\u3092\u9078\u629e\u3059\u308b\u6f14\u7b97\u5b50\n\u30b3\u30fc\u30c9\u3092\u6574\u7406\u3059\u308b\u306e\u306b\u4fbf\u5229\u306a\u6f14\u7b97\u5b50\u3092\u5c0e\u5165\u3057\u307e\u3059\u3002\na + b\u306fa\u3068b\u306e\u7d50\u679c\u3092\u7d50\u5408\u3057\u3066\u8fd4\u3057\u307e\u3059\u304c\u3001\u3044\u305a\u308c\u304b\u7247\u65b9\u3060\u3051\u3092\u8fd4\u3059\u6f14\u7b97\u5b50\u3092\u8003\u3048\u307e\u3059\u3002\n\n\na << b: a\u3068b\u3092\u51e6\u7406\u3057\u305f\u5f8c\u3001\u623b\u308a\u5024\u3068\u3057\u3066a\u306e\u7d50\u679c\u3092\u8fd4\u3057\u307e\u3059\u3002\n\na >> b: a\u3068b\u3092\u51e6\u7406\u3057\u305f\u5f8c\u3001\u623b\u308a\u5024\u3068\u3057\u3066b\u306e\u7d50\u679c\u3092\u8fd4\u3057\u307e\u3059\u3002\n\n\u305d\u308c\u305e\u308c\u4e0d\u7b49\u53f7\u3092\u77e2\u5370\u306b\u898b\u7acb\u3066\u308b\u3068\u3001\u8fd4\u3059\u5024\u3092\u6307\u793a\u3057\u3066\u3044\u308b\u3068\u89e3\u91c8\u3067\u304d\u307e\u3059\u3002\u51e6\u7406\u306e\u9806\u756a\u3092\u8a18\u53f7\u5316\u3057\u305f\u308f\u3051\u3067\u306f\u306a\u304f\u3001\u3069\u3061\u3089\u3082\u51e6\u7406\u9806\u306fa\u2192b\u3067\u3059\u3002\n\u5b9f\u88c5\u3092\u793a\u3057\u307e\u3059\u3002\n\nparsecpp.cpp\uff08\u8ffd\u52a0\uff09\ntemplate <typename T1, typename T2>\nParser<T1> operator<<(const Parser<T1> &p1, const Parser<T2> &p2) {\n    return [=](Source *s) {\n        T1 ret = p1(s);\n        p2(s);\n        return ret;\n    };\n}\n\ntemplate <typename T1, typename T2>\nParser<T2> operator>>(const Parser<T1> &p1, const Parser<T2> &p2) {\n    return [=](Source *s) {\n        p1(s);\n        return p2(s);\n    };\n}\n\n\n\u52d5\u4f5c\u3092\u78ba\u8a8d\u3057\u307e\u3059\u3002\n#include \"parsecpp.cpp\"\n\nint main() {\n    parseTest(letter +  digit, \"a1\");\n    parseTest(letter << digit, \"a1\");\n    parseTest(letter >> digit, \"a1\");\n}\n\n\n\u5b9f\u884c\u7d50\u679c\na1\na\n1\n\n\n\n\u30b3\u30fc\u30c9\u306e\u6574\u7406\n\u6f14\u7b97\u5b50>>\u3092\u4f7f\u3048\u3070many\u306e\u5f15\u6570\u304c\u7c21\u5358\u306b\u306a\u308a\u307e\u3059\u3002\n#include \"parsecpp.cpp\"\n\nint toInt(const std::string &s) {\n    int ret;\n    std::istringstream(s) >> ret;\n    return ret;\n}\n\nParser<int> number = [](Source *s) {\n    return toInt(many1(digit)(s));\n};\n\nParser<std::list<int>> expr = [](Source *s) {\n    int x = number(s);\n    auto xs = many(char1('+') >> number)(s); // \u7c21\u7565\u5316\n    xs.push_front(x);\n    return xs;\n};\n\nint main() {\n    parseTest(number, \"123\"  );\n    parseTest(expr  , \"1+2\"  );\n    parseTest(expr  , \"123\"  );\n    parseTest(expr  , \"1+2+3\");\n}\n\n\n\u5b9f\u884c\u7d50\u679c\n123\n[1,2]\n[123]\n[1,2,3]\n\n\n\u30e9\u30e0\u30c0\u5f0f\u3067\u66f8\u3044\u3066\u3044\u305f\u90e8\u5206\u304c\u9a5a\u304f\u307b\u3069\u7c21\u5358\u306b\u306a\u3063\u3066\u3044\u308b\u306e\u306b\u6ce8\u76ee\u3057\u3066\u304f\u3060\u3055\u3044\u3002\n\u3053\u306e\u3088\u3046\u306b\u30b3\u30f3\u30d3\u30cd\u30fc\u30bf\u3067\u3067\u304d\u306a\u3044\u51e6\u7406\u306f\u3068\u308a\u3042\u3048\u305a\u30e9\u30e0\u30c0\u5f0f\u3067\u66f8\u3044\u3066\u304b\u3089\u3001\u65b0\u3057\u3044\u30b3\u30f3\u30d3\u30cd\u30fc\u30bf\u3092\u5c0e\u5165\u3057\u3066\u5358\u7d14\u5316\u3067\u304d\u306a\u3044\u304b\u3092\u8003\u3048\u308b\u308f\u3051\u3067\u3059\u3002\u3053\u306e\u611f\u899a\u304c\u3064\u304b\u3081\u308c\u3070\u3001\u30d1\u30fc\u30b5\u30b3\u30f3\u30d3\u30cd\u30fc\u30bf\u304c\u3050\u3063\u3068\u8eab\u8fd1\u306b\u611f\u3058\u3089\u308c\u308b\u3067\u3057\u3087\u3046\u3002\n\n\u8a08\u7b97\n\u30ea\u30b9\u30c8\u3092\u5408\u8a08\u3059\u308c\u3070\u8a08\u7b97\u3067\u304d\u307e\u3059\u3002\n#include \"parsecpp.cpp\"\n#include <numeric>  // \u8ffd\u52a0\n\nint toInt(const std::string &s) {\n    int ret;\n    std::istringstream(s) >> ret;\n    return ret;\n}\n\nParser<int> number = [](Source *s) {\n    return toInt(many1(digit)(s));\n};\n\nParser<int> expr = [](Source *s) {  // \u623b\u308a\u5024\u306e\u578b -> int\n    int x = number(s);\n    auto xs = many(char1('+') >> number)(s);\n    return std::accumulate(xs.begin(), xs.end(), x);  // \u5408\u8a08\n};\n\nint main() {\n    parseTest(number, \"123\"  );\n    parseTest(expr  , \"1+2\"  );  // OK\n    parseTest(expr  , \"123\"  );  // OK\n    parseTest(expr  , \"1+2+3\");  // OK\n}\n\n\n\u5b9f\u884c\u7d50\u679c\n123\n3\n123\n6\n\n\n\u69cb\u6587\u89e3\u6790\u3068\u8a08\u7b97\u3092\u5206\u96e2\u305b\u305a\u306bexpr\u3067\u51e6\u7406\u3057\u3066\u3044\u308b\u306e\u304c\u30dd\u30a4\u30f3\u30c8\u3067\u3059\u3002\n\n\u5f15\u304d\u7b97\n\u30de\u30a4\u30ca\u30b9\u306e\u9805\u3092\u8db3\u3059\u3068\u3057\u3066\u51e6\u7406\u3057\u307e\u3059\u3002\n#include \"parsecpp.cpp\"\n#include <numeric>\n\nint toInt(const std::string &s) {\n    int ret;\n    std::istringstream(s) >> ret;\n    return ret;\n}\n\nParser<int> number = [](Source *s) {\n    return toInt(many1(digit)(s));\n};\n\nParser<int> expr = [](Source *s) {\n    int x = number(s);\n    auto xs = many(\n           char1('+') >> number\n        || Parser<int>([](Source *s) {  // \u8ffd\u52a0\n            char1('-')(s);\n            return -number(s);  // \u30de\u30a4\u30ca\u30b9\u306e\u9805\n        })\n    )(s);\n    return std::accumulate(xs.begin(), xs.end(), x);\n};\n\nint main() {\n    parseTest(number, \"123\"  );\n    parseTest(expr  , \"1+2\"  );\n    parseTest(expr  , \"123\"  );\n    parseTest(expr  , \"1+2+3\");\n    parseTest(expr  , \"1-2-3\");  // OK\n    parseTest(expr  , \"1-2+3\");  // OK\n}\n\n\n\u5b9f\u884c\u7d50\u679c\n123\n3\n123\n6\n-4\n2\n\n\n\u7b26\u53f7\u3092\u53cd\u8ee2\u3059\u308b\u51e6\u7406\u3092\u30e9\u30e0\u30c0\u5f0f\u3067\u66f8\u3044\u3066\u3044\u307e\u3059\u3002\u3053\u308c\u3092\u5358\u7d14\u5316\u3059\u308b\u30b3\u30f3\u30d3\u30cd\u30fc\u30bf\u306b\u3064\u3044\u3066\u8003\u3048\u3066\u307f\u307e\u3059\u3002\n\n\u95a2\u6570\u9069\u7528\u30b3\u30f3\u30d3\u30cd\u30fc\u30bf\n\u30d1\u30fc\u30b5\u304c\u8fd4\u3057\u305f\u5024\u306b\u4f55\u3089\u304b\u306e\u51e6\u7406\u3092\u52a0\u3048\u308b\u5834\u5408\u3001\u51e6\u7406\u3092\u95a2\u6570\u306b\u5206\u96e2\u3059\u308b\u3053\u3068\u3092\u8003\u3048\u307e\u3059\u3002\n\u30d1\u30fc\u30b5\u3068\u95a2\u6570\u3092\u3064\u306a\u3050\u30b3\u30f3\u30d3\u30cd\u30fc\u30bfapply\u3092\u5b9f\u88c5\u3057\u307e\u3059\u3002\n\nparsecpp.cpp\uff08\u8ffd\u52a0\uff09\ntemplate <typename T1, typename T2>\nParser<T1> apply(const std::function <T1 (const T2 &)> &f, const Parser<T2> &p) {\n    return [=](Source *s) {\n        return f(p(s));\n    };\n}\n\n\n\u52d5\u4f5c\u3092\u78ba\u8a8d\u3057\u307e\u3059\u3002\n#include \"parsecpp.cpp\"\n\nint main() {\n    parseTest(                                                  letter , \"a\");\n    parseTest(apply<char, char>([](char ch) { return ch + 1; }, letter), \"a\");\n}\n\n\n\u5b9f\u884c\u7d50\u679c\na\nb\n\n\n2\u756a\u76ee\u306fletter\u3067\u53d6\u5f97\u3057\u305f\u6587\u5b57\u306b1\u3092\u8db3\u3057\u3066\u6b21\u306e\u6587\u5b57\u3092\u8fd4\u3057\u3066\u3044\u307e\u3059\u3002\n\n\u7b26\u53f7\u53cd\u8ee2\u30b3\u30f3\u30d3\u30cd\u30fc\u30bf\napply\u3092\u4f7f\u3063\u3066\u7b26\u53f7\u53cd\u8ee2\u30b3\u30f3\u30d3\u30cd\u30fc\u30bf\u3092\u5b9f\u88c5\u3057\u307e\u3059\u3002\n\nparsecpp.cpp\uff08\u8ffd\u52a0\uff09\ntemplate <typename T>\nParser<T> operator-(const Parser<T> &p) {\n    return apply<T, T>([=](T x) { return -x; }, p);\n}\n\n\n\u3053\u308c\u3092\u4f7f\u3063\u3066\u6f14\u7b97\u5668\u3092\u66f8\u304d\u63db\u3048\u307e\u3059\u3002\n#include \"parsecpp.cpp\"\n#include <numeric>\n\nint toInt(const std::string &s) {\n    int ret;\n    std::istringstream(s) >> ret;\n    return ret;\n}\n\nParser<int> number = [](Source *s) {\n    return toInt(many1(digit)(s));\n};\n\nParser<int> expr = [](Source *s) {\n    int x = number(s);\n    auto xs = many(\n           char1('+') >>  number\n        || char1('-') >> -number  // \u9069\u7528\n    )(s);\n    return std::accumulate(xs.begin(), xs.end(), x);\n};\n\nint main() {\n    parseTest(number, \"123\"  );\n    parseTest(expr  , \"1+2\"  );\n    parseTest(expr  , \"123\"  );\n    parseTest(expr  , \"1+2+3\");\n    parseTest(expr  , \"1-2-3\");\n    parseTest(expr  , \"1-2+3\");\n}\n\n\n\u5b9f\u884c\u7d50\u679c\n123\n3\n123\n6\n-4\n2\n\n\n\u8907\u96d1\u306a\u90e8\u5206\u306f\u30b3\u30f3\u30d3\u30cd\u30fc\u30bf\u306b\u62bc\u3057\u8fbc\u3093\u3060\u306e\u3067\u3001\u305d\u308c\u3092\u4f7f\u3046\u30b3\u30fc\u30c9\u304c\u30b7\u30f3\u30d7\u30eb\u306b\u306a\u308a\u307e\u3057\u305f\u3002\n\n\u6574\u6570\u5316\nnumber\u3082apply\u3067\u66f8\u304d\u63db\u3048\u3066\u307f\u307e\u3059\u3002\n#include \"parsecpp.cpp\"\n#include <numeric>\n\nint toInt(const std::string &s) {\n    int ret;\n    std::istringstream(s) >> ret;\n    return ret;\n}\n\nauto number = apply<int, std::string>(toInt, many1(digit));  // \u9069\u7528\n\nParser<int> expr = [](Source *s) {\n    int x = number(s);\n    auto xs = many(\n           char1('+') >>  number\n        || char1('-') >> -number\n    )(s);\n    return std::accumulate(xs.begin(), xs.end(), x);\n};\n\nint main() {\n    parseTest(number, \"123\"  );\n    parseTest(expr  , \"1+2\"  );\n    parseTest(expr  , \"123\"  );\n    parseTest(expr  , \"1+2+3\");\n    parseTest(expr  , \"1-2-3\");\n    parseTest(expr  , \"1-2+3\");\n}\n\n\n\u5b9f\u884c\u7d50\u679c\n123\n3\n123\n6\n-4\n2\n\n\n\u5206\u304b\u308a\u3084\u3059\u304f\u306a\u3063\u305f\u304b\u306f\u5fae\u5999\u3067\u3059\u304c\u3001\u3068\u308a\u3042\u3048\u305a\u3053\u306e\u307e\u307e\u9032\u3081\u307e\u3059\u3002\n\n\u56db\u5247\u6f14\u7b97\n\u639b\u3051\u7b97\u3084\u5272\u308a\u7b97\u306f\u5408\u8a08\u3067\u306f\u51e6\u7406\u3067\u304d\u306a\u3044\u305f\u3081\u3001many\u3067\u30af\u30ed\u30fc\u30b8\u30e3\u306e\u30ea\u30b9\u30c8\u3092\u8fd4\u3057\u3066\u3001\u5f8c\u3067\u307e\u3068\u3081\u3066\u8a08\u7b97\u3057\u307e\u3059\u3002\n#include \"parsecpp.cpp\"\n#include <numeric>\n\nint toInt(const std::string &s) {\n    int ret;\n    std::istringstream(s) >> ret;\n    return ret;\n}\n\nauto number = apply<int, std::string>(toInt, many1(digit));\n\nParser<int> expr = [](Source *s) {\n    int x = number(s);\n    auto xs = many(\n        Parser<std::function<int (int)>>([](Source *s) {        // \u578b\u3092\u4fee\u6b63\n            char1('+')(s);\n            int x = number(s);                                  // \u30ad\u30e3\u30d7\u30c1\u30e3\u3055\u308c\u308b\u5909\u6570\n            return [=](int y) { return y + x; };                // \u30af\u30ed\u30fc\u30b8\u30e3\u3092\u8fd4\u3059\n        }) || Parser<std::function<int (int)>>([](Source *s) {\n            char1('-')(s);\n            int x = number(s);                                  // \u30ad\u30e3\u30d7\u30c1\u30e3\u3055\u308c\u308b\u5909\u6570\n            return [=](int y) { return y - x; };                // \u30af\u30ed\u30fc\u30b8\u30e3\u3092\u8fd4\u3059\n        }) || Parser<std::function<int (int)>>([](Source *s) {  // \u8ffd\u52a0: \u639b\u3051\u7b97\n            char1('*')(s);\n            int x = number(s);                                  // \u30ad\u30e3\u30d7\u30c1\u30e3\u3055\u308c\u308b\u5909\u6570\n            return [=](int y) { return y * x; };                // \u30af\u30ed\u30fc\u30b8\u30e3\u3092\u8fd4\u3059\n        }) || Parser<std::function<int (int)>>([](Source *s) {  // \u8ffd\u52a0: \u5272\u308a\u7b97\n            char1('/')(s);\n            int x = number(s);                                  // \u30ad\u30e3\u30d7\u30c1\u30e3\u3055\u308c\u308b\u5909\u6570\n            return [=](int y) { return y / x; };                // \u30af\u30ed\u30fc\u30b8\u30e3\u3092\u8fd4\u3059\n        })\n    )(s);\n    return std::accumulate(xs.begin(), xs.end(), x,             // \u307e\u3068\u3081\u3066\u8a08\u7b97\n        [](int x, const std::function<int (int)> &f) { return f(x); });\n};\n\nint main() {\n    parseTest(number, \"123\"     );\n    parseTest(expr  , \"1+2\"     );\n    parseTest(expr  , \"123\"     );\n    parseTest(expr  , \"1+2+3\"   );\n    parseTest(expr  , \"1-2-3\"   );\n    parseTest(expr  , \"1-2+3\"   );\n    parseTest(expr  , \"2*3+4\"   );  // OK\n    parseTest(expr  , \"2+3*4\"   );  // NG\n    parseTest(expr  , \"100/10/2\");  // OK\n}\n\n\n\u5b9f\u884c\u7d50\u679c\n123\n3\n123\n6\n-4\n2\n10\n20\n5\n\n\n\u6f14\u7b97\u5b50\u306e\u512a\u5148\u9806\u4f4d\u304c\u51e6\u7406\u3067\u304d\u3066\u3044\u307e\u305b\u3093\u3002\n\n\u6f14\u7b97\u5b50\u306e\u512a\u5148\u9806\u4f4d\n\u8db3\u3057\u7b97\u304b\u3089\u898b\u308b\u3068\u30011\u3064\u306e\u6570\u5b57\u3068\u639b\u3051\u7b97\u306e\u30d6\u30ed\u30c3\u30af\u306f\u9805\uff08term\uff09\u3068\u3057\u3066\u5bfe\u7b49\u3067\u3059\u3002\u6570\u5f0f\u3067\u4f8b\u3048\u308b\u3068 2x+12x+12x+1 \u306b\u304a\u3044\u3066 2x2x2x \u3068 111 \u304c\u9805\u3068\u3044\u3046\u5358\u4f4d\u3068\u3057\u3066 +++ \u304b\u3089\u4e26\u5217\u306b\u6271\u308f\u308c\u3066\u3044\u308b\u3053\u3068\u306b\u76f8\u5f53\u3057\u307e\u3059\u3002\n\u9805\u5358\u4f4d\u3067\u8a08\u7b97\u3059\u308b\u3088\u3046\u306b\u5206\u96e2\u3059\u308c\u3070\u6f14\u7b97\u5b50\u306e\u512a\u5148\u9806\u4f4d\u304c\u8868\u73fe\u3067\u304d\u307e\u3059\u3002\n#include \"parsecpp.cpp\"\n#include <numeric>\n\nint toInt(const std::string &s) {\n    int ret;\n    std::istringstream(s) >> ret;\n    return ret;\n}\n\nauto number = apply<int, std::string>(toInt, many1(digit));\n\nParser<int> term = [](Source *s) {  // \u9805\u306e\u8a08\u7b97\u3001expr\u3068\u540c\u3058\u69cb\u9020\n    int x = number(s);\n    auto xs = many(\n        Parser<std::function<int (int)>>([](Source *s) {\n            char1('*')(s);\n            int x = number(s);\n            return [=](int y) { return y * x; };\n        }) || Parser<std::function<int (int)>>([](Source *s) {\n            char1('/')(s);\n            int x = number(s);\n            return [=](int y) { return y / x; };\n        })\n    )(s);\n    return std::accumulate(xs.begin(), xs.end(), x,\n        [](int x, const std::function<int (int)> &f) { return f(x); });\n};\n\nParser<int> expr = [](Source *s) {\n    int x = term(s);          // \u9805\u3092\u53d6\u5f97\n    auto xs = many(\n        Parser<std::function<int (int)>>([](Source *s) {\n            char1('+')(s);\n            int x = term(s);  // \u9805\u3092\u53d6\u5f97\n            return [=](int y) { return y + x; };\n        }) || Parser<std::function<int (int)>>([](Source *s) {\n            char1('-')(s);\n            int x = term(s);  // \u9805\u3092\u53d6\u5f97\n            return [=](int y) { return y - x; };\n        })\n    )(s);\n    return std::accumulate(xs.begin(), xs.end(), x,\n        [](int x, const std::function<int (int)> &f) { return f(x); });\n};\n\nint main() {\n    parseTest(number, \"123\"     );\n    parseTest(expr  , \"1+2\"     );\n    parseTest(expr  , \"123\"     );\n    parseTest(expr  , \"1+2+3\"   );\n    parseTest(expr  , \"1-2-3\"   );\n    parseTest(expr  , \"1-2+3\"   );\n    parseTest(expr  , \"2*3+4\"   );\n    parseTest(expr  , \"2+3*4\"   );  // OK\n    parseTest(expr  , \"100/10/2\");\n}\n\n\n\u5b9f\u884c\u7d50\u679c\n123\n3\n123\n6\n-4\n2\n10\n14\n5\n\n\n\u6f14\u7b97\u5b50\u306e\u512a\u5148\u9806\u4f4d\u304c\u51e6\u7406\u3055\u308c\u308b\u3088\u3046\u306b\u306a\u308a\u307e\u3057\u305f\u3002\n\n\u6574\u7406\n\u8a18\u8ff0\u304c\u8907\u96d1\u306a\u305f\u3081\u3001\u4eca\u307e\u3067\u5b9a\u7fa9\u3057\u305f\u6f14\u7b97\u5b50\u3092\u99c6\u4f7f\u3057\u3066\u6574\u7406\u3092\u8a66\u307f\u307e\u3059\u3002\n\n2\u5f15\u6570\u306e\u95a2\u6570\u9069\u7528\n\u500b\u5225\u306e\u6f14\u7b97\u3067\u30af\u30ed\u30fc\u30b8\u30e3\u3092\u8fd4\u3057\u3066\u3044\u308b\u90e8\u5206\u304c\u5197\u9577\u3067\u3059\u3002+\u3092\u4f8b\u306b\u8003\u3048\u307e\u3059\u3002\n\n\u629c\u7c8b\n        Parser<std::function<int (int)>>([](Source *s) {\n            char1('+')(s);\n            int y = term(s);\n            return [=](int x) { return x + y; };\n        })\n\n\ny\u306b\u8aad\u307f\u53d6\u3063\u305f\u9805\u3092\u4ee3\u5165\u3057\u3066\u3001\u6b21\u306e\u884c\u306e\u30af\u30ed\u30fc\u30b8\u30e3\u3067\u30ad\u30e3\u30d7\u30c1\u30e3\u3057\u3066\u3044\u307e\u3059\u3002\u30ad\u30e3\u30d7\u30c1\u30e3\u3057\u305f\u5909\u6570\u306f\u5f15\u6570\u3092\u7573\u307f\u8fbc\u3093\u3067\u3044\u308b\u3068\u898b\u306a\u305b\u308b\u305f\u3081\u3001\u672c\u8cea\u7684\u306b\u306f2\u5f15\u6570\u306e\u30e9\u30e0\u30c0\u5f0f\u3067\u3059\u3002\n\u203b \u5f15\u6570\u3092\u7573\u307f\u8fbc\u3093\u3067\u5f15\u6570\u3092\u6e1b\u3089\u3057\u305f\u65b0\u3057\u3044\u95a2\u6570\u3092\u751f\u6210\u3059\u308b\u3053\u3068\u3092\u90e8\u5206\u9069\u7528\u3068\u547c\u3073\u307e\u3059\u3002\u8a73\u7d30\u306f\u6b21\u306e\u8a18\u4e8b\u3092\u53c2\u7167\u3057\u3066\u304f\u3060\u3055\u3044\u3002\n\n\n\u30ab\u30ea\u30fc\u5316\u3068\u90e8\u5206\u9069\u7528\uff08JavaScript\u3068Haskell\uff09 2014.10.15\n\napply\u306b\u30aa\u30fc\u30d0\u30fc\u30ed\u30fc\u30c9\u3092\u8ffd\u52a0\u3057\u3066\u30012\u5f15\u6570\u306e\u95a2\u6570\u3092\u6e21\u3057\u3066\u7b2c1\u5f15\u6570\u3092\u30ad\u30e3\u30d7\u30c1\u30e3\u3057\u305f1\u5f15\u6570\u306e\u30af\u30ed\u30fc\u30b8\u30e3\u3092\u8fd4\u3057\u307e\u3059\u3002\n\nparsecpp.cpp\uff08\u8ffd\u52a0\uff09\ntemplate <typename T1, typename T2, typename T3>\nParser<std::function<T1 (const T2 &)>> apply(\n        const std::function <T1 (const T2 &, const T3 &)> &f, const Parser<T2> &p) {\n    return [=](Source *s) {\n        T2 x = p(s);\n        return [=](const T3 &y) {\n            return f(x, y);\n        };\n    };\n}\n\n\n\u3053\u306e\u307e\u307e\u3067\u306f\u578b\u5f15\u6570\u304c\u7169\u96d1\u306b\u306a\u308b\u306e\u3067\u3001\u7279\u6b8a\u5316\u3057\u305fapply\u3092\u7528\u610f\u3057\u3066\u4f7f\u3044\u307e\u3059\u3002\n#include \"parsecpp.cpp\"\n#include <numeric>\n\nint toInt(const std::string &s) {\n    int ret;\n    std::istringstream(s) >> ret;\n    return ret;\n}\n\nParser<std::function<int (int)>> apply(  // \u7279\u6b8a\u5316\n        const std::function<int (int, int)> &f, const Parser<int> &p) {\n    return apply<int, int, int>(f, p);\n}\n\nauto number = apply<int, std::string>(toInt, many1(digit));\n\nParser<int> term = [](Source *s) {\n    int x = number(s);\n    auto xs = many(\n        Parser<std::function<int (int)>>([](Source *s) {\n            char1('*')(s);\n            return apply([](int x, int y) { return y * x; }, number)(s);  // \u9069\u7528\n        }) || Parser<std::function<int (int)>>([](Source *s) {\n            char1('/')(s);\n            return apply([](int x, int y) { return y / x; }, number)(s);  // \u9069\u7528\n        })\n    )(s);\n    return std::accumulate(xs.begin(), xs.end(), x,\n        [](int x, const std::function<int (int)> &f) { return f(x); });\n};\n\nParser<int> expr = [](Source *s) {\n    int x = term(s);\n    auto xs = many(\n        Parser<std::function<int (int)>>([](Source *s) {\n            char1('+')(s);\n            return apply([](int x, int y) { return y + x; }, term)(s);  // \u9069\u7528\n        }) || Parser<std::function<int (int)>>([](Source *s) {\n            char1('-')(s);\n            return apply([](int x, int y) { return y - x; }, term)(s);  // \u9069\u7528\n        })\n    )(s);\n    return std::accumulate(xs.begin(), xs.end(), x,\n        [](int x, const std::function<int (int)> &f) { return f(x); });\n};\n\nint main() {\n    parseTest(number, \"123\"     );\n    parseTest(expr  , \"1+2\"     );\n    parseTest(expr  , \"123\"     );\n    parseTest(expr  , \"1+2+3\"   );\n    parseTest(expr  , \"1-2-3\"   );\n    parseTest(expr  , \"1-2+3\"   );\n    parseTest(expr  , \"2*3+4\"   );\n    parseTest(expr  , \"2+3*4\"   );\n    parseTest(expr  , \"100/10/2\");\n}\n\n\n\u5b9f\u884c\u7d50\u679c\n123\n3\n123\n6\n-4\n2\n10\n14\n5\n\n\n\u30d1\u30fc\u30b5\u3092\u9023\u7d9a\u3055\u305b\u308b\u5f62\u306b\u6301\u3061\u8fbc\u3081\u307e\u3057\u305f\u3002\n\n\u975e\u30e9\u30e0\u30c0\u5f0f\u5316\n\u6f14\u7b97\u5b50>>\u3092\u4f7f\u3048\u3070\u30e9\u30e0\u30c0\u5f0f\u304c\u306a\u304f\u306a\u308a\u307e\u3059\u3002\n#include \"parsecpp.cpp\"\n#include <numeric>\n\nint toInt(const std::string &s) {\n    int ret;\n    std::istringstream(s) >> ret;\n    return ret;\n}\n\nParser<std::function<int (int)>> apply(\n        const std::function<int (int, int)> &f, const Parser<int> &p) {\n    return apply<int, int, int>(f, p);\n}\n\nauto number = apply<int, std::string>(toInt, many1(digit));\n\nParser<int> term = [](Source *s) {\n    int x = number(s);\n    auto xs = many(\n           char1('*') >> apply([](int x, int y) { return y * x; }, number)  // \u4fee\u6b63\n        || char1('/') >> apply([](int x, int y) { return y / x; }, number)  // \u4fee\u6b63\n    )(s);\n    return std::accumulate(xs.begin(), xs.end(), x,\n        [](int x, const std::function<int (int)> &f) { return f(x); });\n};\n\nParser<int> expr = [](Source *s) {\n    int x = term(s);\n    auto xs = many(\n           char1('+') >> apply([](int x, int y) { return y + x; }, term)  // \u4fee\u6b63\n        || char1('-') >> apply([](int x, int y) { return y - x; }, term)  // \u4fee\u6b63\n    )(s);\n    return std::accumulate(xs.begin(), xs.end(), x,\n        [](int x, const std::function<int (int)> &f) { return f(x); });\n};\n\nint main() {\n    parseTest(number, \"123\"     );\n    parseTest(expr  , \"1+2\"     );\n    parseTest(expr  , \"123\"     );\n    parseTest(expr  , \"1+2+3\"   );\n    parseTest(expr  , \"1-2-3\"   );\n    parseTest(expr  , \"1-2+3\"   );\n    parseTest(expr  , \"2*3+4\"   );\n    parseTest(expr  , \"2+3*4\"   );\n    parseTest(expr  , \"100/10/2\");\n}\n\n\n\u5b9f\u884c\u7d50\u679c\n123\n3\n123\n6\n-4\n2\n10\n14\n5\n\n\n\u304b\u306a\u308a\u7c21\u6f54\u306b\u306a\u308a\u307e\u3057\u305f\u3002\u3057\u304b\u3057\u307e\u3060\u91cd\u8907\u3059\u308b\u8a18\u8ff0\u304c\u6b8b\u3063\u3066\u3044\u307e\u3059\u3002\n\n\u5171\u901a\u90e8\u5206\u306e\u95a2\u6570\u5316\n\u5024\u3092\u8a55\u4fa1\u3059\u308b\u90e8\u5206\u304cterm\u3068expr\u3067\u540c\u3058\u306a\u306e\u3067\u95a2\u6570\u5316\u3057\u307e\u3059\u3002\n#include \"parsecpp.cpp\"\n#include <numeric>\n\nint toInt(const std::string &s) {\n    int ret;\n    std::istringstream(s) >> ret;\n    return ret;\n}\n\nParser<int> eval(\n        const Parser<int> &m,\n        const Parser<std::list<std::function<int (int)>>> &fs) {\n    return [=](Source *s) {\n        int x = m(s);\n        auto xs = fs(s);\n        return std::accumulate(xs.begin(), xs.end(), x,\n            [](int x, const std::function<int (int)> &f) { return f(x); });\n    };\n}\n\nParser<std::function<int (int)>> apply(\n        const std::function<int (int, int)> &f, const Parser<int> &p) {\n    return apply<int, int, int>(f, p);\n}\n\nauto number = apply<int, std::string>(toInt, many1(digit));\n\nauto term = eval(number, many(\n       char1('*') >> apply([](int x, int y) { return y * x; }, number)  // \u4fee\u6b63\n    || char1('/') >> apply([](int x, int y) { return y / x; }, number)  // \u4fee\u6b63\n));\n\nauto expr = eval(term, many(\n       char1('+') >> apply([](int x, int y) { return y + x; }, term)  // \u4fee\u6b63\n    || char1('-') >> apply([](int x, int y) { return y - x; }, term)  // \u4fee\u6b63\n));\n\nint main() {\n    parseTest(number, \"123\"     );\n    parseTest(expr  , \"1+2\"     );\n    parseTest(expr  , \"123\"     );\n    parseTest(expr  , \"1+2+3\"   );\n    parseTest(expr  , \"1-2-3\"   );\n    parseTest(expr  , \"1-2+3\"   );\n    parseTest(expr  , \"2*3+4\"   );\n    parseTest(expr  , \"2+3*4\"   );\n    parseTest(expr  , \"100/10/2\");\n}\n\n\n\u5b9f\u884c\u7d50\u679c\n123\n3\n123\n6\n-4\n2\n10\n14\n5\n\n\n\u9762\u5012\u306a\u90e8\u5206\u306feval\u3068apply\u306b\u62bc\u3057\u4ed8\u3051\u308b\u3053\u3068\u3067\u3001term\u3068expr\u306f\u7c21\u6f54\u3067\u5f62\u5f0f\u7684\u306a\u8a18\u8ff0\u306b\u306a\u308a\u307e\u3057\u305f\u3002\u3044\u304d\u306a\u308a\u3053\u306e\u30b3\u30fc\u30c9\u3092\u898b\u3066\u3082\u5f62\u5f0f\u7684\u904e\u304e\u3066\u7406\u89e3\u3057\u306b\u304f\u3044\u304b\u3082\u3057\u308c\u307e\u305b\u3093\u304c\u3001\u30b3\u30fc\u30c9\u306e\u5909\u5f62\u904e\u7a0b\u3092\u8ffd\u3063\u3066\u307f\u3066\u304f\u3060\u3055\u3044\u3002\n\nBNF\n\u3053\u3053\u307e\u3067\u5b9f\u88c5\u3057\u305f\u3088\u3046\u306a\u51e6\u7406\u306fBNF\uff08\u30d0\u30c3\u30ab\u30b9\u30fb\u30ca\u30a6\u30a2\u8a18\u6cd5\uff09\u3068\u547c\u3070\u308c\u308b\u5f62\u5f0f\u8a00\u8a9e\u3067\u8a18\u8ff0\u3067\u304d\u307e\u3059\u3002\n\u62e1\u5f35\u7248\u306eEBNF\u3067\u793a\u3057\u307e\u3059\u3002\n\nEBNF\nterm = number, {\"*\"|\"/\", number}\nexpr = term  , {\"+\"|\"-\", term  }\n\n\n\u4eca\u56de\u306e\u30b3\u30fc\u30c9\u306b\u5408\u308f\u305b\u3066EBNF\u3092\u5909\u5f62\u3059\u308b\u305f\u3081\u3001\u6f14\u7b97\u5b50\u305d\u308c\u305e\u308c\u306b\u51e6\u7406\u3092\u8a18\u8ff0\u3057\u307e\u3059\u3002\n\nEBNF\nterm = number, {(\"*\", number) | (\"/\", number)}\nexpr = term  , {(\"+\", term  ) | (\"-\", term  )}\n\n\n\n\u6bd4\u8f03\n\u30b3\u30fc\u30c9\u306b\u30b3\u30e1\u30f3\u30c8\u3068\u3057\u3066\u8ffd\u8a18\u3059\u308b\u306e\u3067\u6bd4\u8f03\u3057\u3066\u304f\u3060\u3055\u3044\u3002\u6163\u308c\u3066\u6765\u308c\u3070\u3001\u5148\u306bBNF\u3067\u5b9a\u7fa9\u3057\u3066\u304b\u3089\u30b3\u30fc\u30c9\u3092\u66f8\u3044\u305f\u65b9\u304c\u52b9\u7387\u7684\u3060\u3068\u611f\u3058\u308b\u3067\u3057\u3087\u3046\u3002\n\n\u6bd4\u8f03\n// term = number, {(\"*\", number) | (\"/\", number)}\nauto term = eval(number, many(\n       char1('*') >> apply([](int x, int y) { return y * x; }, number)\n    || char1('/') >> apply([](int x, int y) { return y / x; }, number)\n));\n\n// expr = term, {(\"+\", term) | (\"-\", term)}\nauto expr = eval(term, many(\n       char1('+') >> apply([](int x, int y) { return y + x; }, term)\n    || char1('-') >> apply([](int x, int y) { return y - x; }, term)\n));\n\n\n\u3053\u306e\u30b3\u30fc\u30c9\u306f\u306a\u308b\u3079\u304fBNF\u306b\u8fd1\u4ed8\u3051\u308b\u3088\u3046\u610f\u8b58\u3057\u3066\u3044\u307e\u3059\u3002\u3053\u306e\u3088\u3046\u306a\u4f7f\u3044\u65b9\u306f\u30c9\u30e1\u30a4\u30f3\u56fa\u6709\u8a00\u8a9e\uff08DSL\uff09\u306b\u898b\u7acb\u3066\u3089\u308c\u307e\u3059\u3002\n\n\u62ec\u5f27\n\u62ec\u5f27\u3092\u30b5\u30dd\u30fc\u30c8\u305f\u3081\u3001\u9805\u306e\u4e0b\u4f4d\u306b\u56e0\u5b50\uff08factor\uff09\u3068\u3044\u3046\u5c64\u3092\u8ffd\u52a0\u3057\u307e\u3059\u3002\n\u62ec\u5f27\u306e\u4e2d\u306fexpr\u306e\u305f\u3081\u6b21\u306e\u3088\u3046\u306b\u518d\u5e30\u304c\u5faa\u74b0\u3057\u307e\u3059\u3002\n\n\nexpr \u2192 term \u2192 factor \u2192 expr \u2192 ...\n\n\u3053\u306e\u3088\u3046\u306a\u518d\u5e30\u3092\u5b9a\u7fa9\u3059\u308b\u306b\u306f\u524d\u65b9\u5ba3\u8a00\u304c\u5fc5\u9808\u3067\u3059\u304c\u3001\u30dd\u30a4\u30f3\u30bf\u3067\u306f\u306a\u304f\u5b9f\u4f53\u3067\u5b9a\u7fa9\u3059\u308b\u30a4\u30f3\u30b9\u30bf\u30f3\u30b9\u306f\u8a18\u8ff0\u9806\u306b\u521d\u671f\u5316\u3055\u308c\u308b\u305f\u3081\u3001\u524d\u65b9\u53c2\u7167\u3057\u305f\u5148\u306e\u30a4\u30f3\u30b9\u30bf\u30f3\u30b9\u304c\u751f\u6210\u3055\u308c\u308b\u524d\u306b\u4f7f\u7528\u3059\u308b\u3053\u3068\u306b\u306a\u308a\u304a\u304b\u3057\u306a\u3053\u3068\u306b\u306a\u308a\u307e\u3059\u3002\n\u521d\u671f\u5316\u3092\u9045\u5ef6\u3055\u305b\u308b\u305f\u3081\u30c0\u30df\u30fc\u306e\u30e9\u30e0\u30c0\u5f0f\u3092\u631f\u307f\u307e\u3059\u3002\u30c0\u30df\u30fc\u306e\u65b9\u3092\u4ed6\u304b\u3089\u4f7f\u3046\u305f\u3081\u3001\u5b9f\u4f53\u306e\u65b9\u3092\u540d\u524d\u5909\u66f4\u3057\u307e\u3059\u3002\u524d\u65b9\u5ba3\u8a00\u3067\u306fauto\u304c\u4f7f\u3048\u307e\u305b\u3093\u304c\u3001\u524d\u65b9\u5ba3\u8a00\u304c\u3042\u308b\u3068\u5b9f\u4f53\u306e\u65b9\u306b\u3082auto\u304c\u4f7f\u3048\u306a\u304f\u306a\u308a\u307e\u3059\u3002\n#include \"parsecpp.cpp\"\n#include <numeric>\n\nint toInt(const std::string &s) {\n    int ret;\n    std::istringstream(s) >> ret;\n    return ret;\n}\n\nParser<int> eval(\n        const Parser<int> &m,\n        const Parser<std::list<std::function<int (int)>>> &fs) {\n    return [=](Source *s) {\n        int x = m(s);\n        auto xs = fs(s);\n        return std::accumulate(xs.begin(), xs.end(), x,\n            [](int x, const std::function<int (int)> &f) { return f(x); });\n    };\n}\n\nParser<std::function<int (int)>> apply(\n        const std::function<int (int, int)> &f, const Parser<int> &p) {\n    return apply<int, int, int>(f, p);\n}\n\nauto number = apply<int, std::string>(toInt, many1(digit));\n\nextern Parser<int> factor_;  // \u524d\u65b9\u5ba3\u8a00\nParser<int> factor = [](Source *s) { return factor_(s); };  // \u30c0\u30df\u30fc\u306e\u30e9\u30c3\u30d1\u30fc\n\n// term = factor, {(\"*\", factor) | (\"/\", factor)}\nauto term = eval(factor, many(\n       char1('*') >> apply([](int x, int y) { return y * x; }, factor)\n    || char1('/') >> apply([](int x, int y) { return y / x; }, factor)\n));\n\n// expr = term, {(\"+\", term) | (\"-\", term)}\nauto expr = eval(term, many(\n       char1('+') >> apply([](int x, int y) { return y + x; }, term)\n    || char1('-') >> apply([](int x, int y) { return y - x; }, term)\n));\n\n// factor = (\"(\", expr, \")\") | number\nParser<int> factor_ = char1('(') >> expr << char1(')') || number;  // \u5b9f\u4f53\n\nint main() {\n    parseTest(number, \"123\"     );\n    parseTest(expr  , \"1+2\"     );\n    parseTest(expr  , \"123\"     );\n    parseTest(expr  , \"1+2+3\"   );\n    parseTest(expr  , \"1-2-3\"   );\n    parseTest(expr  , \"1-2+3\"   );\n    parseTest(expr  , \"2*3+4\"   );\n    parseTest(expr  , \"2+3*4\"   );\n    parseTest(expr  , \"100/10/2\");\n    parseTest(expr  , \"(2+3)*4\" );  // OK\n}\n\n\n\u5b9f\u884c\u7d50\u679c\n123\n3\n123\n6\n-4\n2\n10\n14\n5\n20\n\n\n\u5f0f\u3092\u5faa\u74b0\u53c2\u7167\u3055\u305b\u308b\u90e8\u5206\u304c\u96e3\u3057\u3044\u3067\u3059\u304c\u3001\u30c6\u30af\u30cb\u30c3\u30af\u3068\u3057\u3066\u5272\u308a\u5207\u308b\u3057\u304b\u3042\u308a\u307e\u305b\u3093\u3002\n\n\u30b9\u30da\u30fc\u30b9\n\u5f0f\u306b\u30b9\u30da\u30fc\u30b9\u304c\u5165\u3063\u3066\u3044\u3066\u3082\u8a55\u4fa1\u3067\u304d\u308b\u3088\u3046\u306b\u3057\u307e\u3059\u3002\n\u30b9\u30da\u30fc\u30b9\u95a2\u4fc2\u306e\u30d1\u30fc\u30b5\u3092\u6c4e\u7528\u90e8\u54c1\u3068\u3057\u3066\u8ffd\u52a0\u3057\u307e\u3059\u3002\n\nparsecpp.cpp\uff08\u8ffd\u52a0\uff09\nbool isSpace(char ch) { return ch == '\\t' || ch == ' '; }\nauto space  = satisfy(isSpace) || left(\"not space\");\nauto spaces = many(space);\n\n\nfactor\u3092\u4fee\u6b63\u3057\u307e\u3059\u3002\n\n\u4fee\u6b63\n// factor = factor = [spaces], (\"(\", expr, \")\") | number, [spaces]\nParser<int> factor_ = spaces\n                   >> (char1('(') >> expr << char1(')') || number)\n                   << spaces;\n\n\n\u6b21\u306e\u3088\u3046\u306a\u30c6\u30b9\u30c8\u304c\u52d5\u304f\u3088\u3046\u306b\u306a\u308a\u307e\u3059\u3002\nint main() {\n    parseTest(number, \"123\"          );\n    parseTest(expr  , \"1 + 2\"        );\n    parseTest(expr  , \"123\"          );\n    parseTest(expr  , \"1 + 2 + 3\"    );\n    parseTest(expr  , \"1 - 2 - 3\"    );\n    parseTest(expr  , \"1 - 2 + 3\"    );\n    parseTest(expr  , \"2 * 3 + 4\"    );\n    parseTest(expr  , \"2 + 3 * 4\"    );\n    parseTest(expr  , \"100 / 10 / 2\" );\n    parseTest(expr  , \"( 2 + 3 ) * 4\");\n}\n\n\n\u5b9f\u884c\u7d50\u679c\n123\n3\n123\n6\n-4\n2\n10\n14\n5\n20\n\n\n\u4ee5\u4e0a\u3067\u56db\u5247\u6f14\u7b97\u5668\u306e\u5b9f\u88c5\u306f\u5b8c\u4e86\u3067\u3059\u3002\n\u3053\u3053\u307e\u3067\u306e\u30b3\u30fc\u30c9\u5168\u4f53\u3067\u3059\u3002\n\nparsecpp.cpp, calc.cpp\n\n\u30d1\u30fc\u30b5\u30b3\u30f3\u30d3\u30cd\u30fc\u30bf\u306b\u3088\u308b\u30d7\u30ed\u30b0\u30e9\u30df\u30f3\u30b0\u304c\u4f55\u3068\u306a\u304f\u898b\u3048\u3066\u6765\u308c\u3070\u3057\u3081\u305f\u3082\u306e\u3067\u3059\u3002\nC++11\u3067\u4f5c\u3063\u305f\u7c21\u5358\u306a\u30d1\u30fc\u30b5\u30b3\u30f3\u30d3\u30cd\u30fc\u30bf\u3092\u4f7f\u3063\u3066\u56db\u5247\u6f14\u7b97\u5668\u3092\u4f5c\u6210\u3057\u307e\u3059\u3002\n\n\u3053\u306e\u8a18\u4e8b\u306f\u6b21\u306e\u7d9a\u7de8\u3067\u3059\u3002\n\n* [C++11 \u30d1\u30fc\u30b5\u30b3\u30f3\u30d3\u30cd\u30fc\u30bf \u8d85\u5165\u9580](http://qiita.com/7shi/items/6a12160276a8db358e34) 2015.11.27\n\n\u3053\u306e\u8a18\u4e8b\u306fHaskell\u306e\u8a18\u4e8b\u3092C++11\u3067\u66f8\u304d\u76f4\u3057\u305f\u3082\u306e\u3067\u3059\u3002\n\n* [Haskell \u69cb\u6587\u89e3\u6790 \u8d85\u5165\u9580](http://qiita.com/7shi/items/b8c741e78a96ea2c10fe) 2015.07.31\n\n\u3053\u306e\u8a18\u4e8b\u306b\u306fJava\u7248\u304c\u3042\u308a\u307e\u3059\u3002\n\n* [Java \u30d1\u30fc\u30b5\u30b3\u30f3\u30d3\u30cd\u30fc\u30bf \u8d85\u5165\u9580](http://qiita.com/7shi/items/68228e19552c271bea81) 2016.05.12\n* [Java \u30d1\u30fc\u30b5\u30b3\u30f3\u30d3\u30cd\u30fc\u30bf \u8d85\u5165\u9580 2](http://qiita.com/7shi/items/39a9ddffcc5bdf2c0142) 2016.05.14\n\n\u3053\u306e\u8a18\u4e8b\u306b\u306f\u95a2\u9023\u8a18\u4e8b\u304c\u3042\u308a\u307e\u3059\u3002\n\n* [JSON\u30d1\u30fc\u30b5\u30fc\u3092\u4f5c\u308b](http://qiita.com/7shi/items/04c2991239894687ef2f) 2016.12.26\n\n\u3053\u306e\u8a18\u4e8b\u3092\u66f8\u304f\u305f\u3081\u306e\u5b9f\u9a13\u7528\u30ea\u30dd\u30b8\u30c8\u30ea\u3067\u3059\u3002\u8a18\u4e8b\u5316\u306b\u969b\u3057\u3066\u30b3\u30fc\u30c9\u306b\u624b\u3092\u52a0\u3048\u305f\u305f\u3081\u4e00\u90e8\u7570\u306a\u308b\u5834\u5408\u304c\u3042\u308a\u307e\u3059\u3002\n\n* https://bitbucket.org/7shi/parsecpp\n\n# \u56db\u5247\u6f14\u7b97\u5668\n\n\u30d1\u30fc\u30b5\u30b3\u30f3\u30d3\u30cd\u30fc\u30bf\u306e\u7df4\u7fd2\u3068\u3057\u3066\u3001\u7c21\u5358\u306a\u56db\u5247\u6f14\u7b97\u5668\u3092\u4f5c\u308a\u307e\u3059\u3002\u6587\u5b57\u5217\u3067\u5f0f\u3092\u4e0e\u3048\u308b\u3068\u8a08\u7b97\u3057\u3066\u7b54\u3048\u3092\u8fd4\u3057\u307e\u3059\u3002\n\n\u4f8b: `\"1+2*3\"` \u2192 `7`\n\n\u524d\u56de\u4f5c\u3063\u305f\u30d1\u30fc\u30b5\u30b3\u30f3\u30d3\u30cd\u30fc\u30bf\u3092\u6539\u9020\u3057\u306a\u304c\u3089\u9032\u3081\u307e\u3059\u3002\n\n* [\u524d\u56de\u307e\u3067\u306e parsecpp.cpp](https://bitbucket.org/snippets/7shi/o9dep/revisions/4282afab8b71b96924335c39f8433358ec9c33a4)\n\n## \u6570\u5b57\n\n\u6570\u5b57\u3092\u8aad\u307f\u8fbc\u3080\u30d1\u30fc\u30b5\u3092\u5b9f\u88c5\u3057\u307e\u3059\u3002\u6700\u4f4e\u3067\u30821\u6587\u5b57\u306f\u5fc5\u8981\u306a\u305f\u3081`many`\uff080\u56de\u4ee5\u4e0a\u306e\u7e70\u308a\u8fd4\u3057\uff09\u3067\u306f\u306a\u304f`many1`\uff081\u56de\u4ee5\u4e0a\u306e\u7e70\u308a\u8fd4\u3057\uff09\u3092\u5b9f\u88c5\u3057\u307e\u3059\u3002\n\n```cpp:parsecpp.cpp\uff08\u8ffd\u52a0\uff09\ntemplate <typename T>\nParser<std::string> many1(const Parser<T> &p) {\n    return p + many(p);\n}\n```\n\n\u3053\u308c\u3092\u4f7f\u3063\u3066\u6570\u5b57\u3092\u8aad\u307f\u8fbc\u307f\u307e\u3059\u3002\n\n```cpp\n#include \"parsecpp.cpp\"\n\nauto number = many1(digit);\n\nint main() {\n    parseTest(number, \"123\");\n}\n```\n```text:\u5b9f\u884c\u7d50\u679c\n123\n```\n\n### \u6570\u5024\n\n\u7d50\u679c\u3092\u6570\u5024\u3067\u8fd4\u3059\u3088\u3046\u306b\u4fee\u6b63\u3057\u307e\u3059\u3002\n\n```cpp\n#include \"parsecpp.cpp\"\n\nint toInt(const std::string &s) {  // \u8ffd\u52a0\n    int ret;\n    std::istringstream(s) >> ret;\n    return ret;\n}\n\nParser<int> number = [](Source *s) {  // \u4fee\u6b63\n    return toInt(many1(digit)(s));\n};\n\nint main() {\n    parseTest(number, \"123\");\n}\n```\n```text:\u5b9f\u884c\u7d50\u679c\n123\n```\n\n\u3053\u306e\u3088\u3046\u306b\u30d1\u30fc\u30b5\u306f\u6587\u5b57\u4ee5\u5916\u3092\u8fd4\u3059\u3088\u3046\u306b\u69cb\u6210\u3067\u304d\u307e\u3059\u3002\n\n## \u8db3\u3057\u7b97\n\n\u8db3\u3057\u7b97\u3092\u8a08\u7b97\u3059\u308b\u30d1\u30fc\u30b5\u3092\u5b9f\u88c5\u3057\u307e\u3059\u3002\u6f14\u7b97\u306e\u5bfe\u8c61\uff08\u30aa\u30da\u30e9\u30f3\u30c9\uff09\u304c2\u3064\u3042\u308b\u305f\u3081\u3001\u30ea\u30b9\u30c8\u3092\u4f7f\u3044\u307e\u3059\u3002\n\n\u7d50\u679c\u3092\u78ba\u8a8d\u3059\u308b\u305f\u3081\u30ea\u30b9\u30c8\u306e\u8868\u793a\u3092\u5b9f\u88c5\u3057\u307e\u3059\u3002\n\n```cpp:parsecpp.cpp\uff08\u8ffd\u52a0\uff09\n#include <list>\n\ntemplate <typename T>\nstd::string toString(const std::list<T> &list) {\n    std::stringstream ss;\n    ss << \"[\";\n    for (auto it = list.begin();\n            it != list.end(); ++it) {\n        if (it != list.begin()) ss << \",\";\n        ss << *it;\n    }\n    ss << \"]\";\n    return ss.str();\n}\ntemplate <typename T>\nstd::ostream &operator<<(std::ostream &cout, const std::list<T> &list) {\n    return cout << toString(list);\n}\n```\n\n`'+'`\u3067\u533a\u5207\u3063\u3066\u9805\u3092\u500b\u5225\u306b\u53d6\u308a\u51fa\u3057\u307e\u3059\u3002\n\n```cpp\n#include \"parsecpp.cpp\"\n\nint toInt(const std::string &s) {\n    int ret;\n    std::istringstream(s) >> ret;\n    return ret;\n}\n\nParser<int> number = [](Source *s) {\n    return toInt(many1(digit)(s));\n};\n\nParser<std::list<int>> expr = [](Source *s) {  // \u8ffd\u52a0\n    int x = number(s);\n    char1('+')(s);\n    int y = number(s);\n    return std::list<int>({x, y});\n};\n\nint main() {\n    parseTest(number, \"123\");\n    parseTest(expr  , \"1+2\");  // \u8ffd\u52a0\n}\n```\n```text:\u5b9f\u884c\u7d50\u679c\n123\n[1,2]\n```\n\n### many\n\n`+\u6570\u5024`\u3092`many`\u306b\u3088\u308a0\u56de\u4ee5\u4e0a\u306e\u7e70\u308a\u8fd4\u3057\u3068\u3057\u3066\u6271\u3044\u307e\u3059\u3002\n\n`many`\u304c\u6587\u5b57\u5217\u306b\u7279\u5316\u3057\u305f\u5b9f\u88c5\u3068\u306a\u3063\u3066\u3044\u308b\u305f\u3081\u3001\u591a\u76f8\u5316\u3057\u305f\u4e0a\u3067\u7279\u6b8a\u5316\u3057\u307e\u3059\u3002\n\n\u5dee\u5206\u3092\u793a\u3057\u307e\u3059\u3002\n\n```diff\n--- parsecpp.cpp.orig\n+++ parsecpp.cpp\n@@ -104,7 +104,7 @@\n }\n \n template <typename T>\n-Parser<std::string> many(const Parser<T> &p) {\n+Parser<std::string> many_(const Parser<T> &p) {\n     return [=](Source *s) {\n         std::string ret;\n         try {\n@@ -112,6 +112,22 @@\n         } catch (const std::string &) {}\n         return ret;\n     };\n+}\n+Parser<std::string> many(const Parser<char> &p) {\n+    return many_(p);\n+}\n+Parser<std::string> many(const Parser<std::string> &p) {\n+    return many_(p);\n+}\n+template <typename T>\n+Parser<std::list<T>> many(const Parser<T> &p) {\n+    return [=](Source *s) {\n+        std::list<T> ret;\n+        try {\n+            for (;;) ret.push_back(p(s));\n+        } catch (const std::string &) {}\n+        return ret;\n+    };\n }\n \n template <typename T>\n```\n\n* [\u4fee\u6b63\u5f8c\u306e parsecpp.cpp](https://bitbucket.org/snippets/7shi/o9dep/revisions/924196829e5f08614272b1982ec88a81b6014eac)\n\n`many`\u306b\u6e21\u3059\u30d1\u30fc\u30b5\u306f\u30b3\u30fc\u30c9\u3067\u5b9a\u7fa9\u3059\u308b\u305f\u3081\u3001\u578b\u3092\u660e\u793a\u3057\u305f\u30e9\u30e0\u30c0\u5f0f\u3092\u4f7f\u3044\u307e\u3059\u3002\n\n```cpp\n#include \"parsecpp.cpp\"\n\nint toInt(const std::string &s) {\n    int ret;\n    std::istringstream(s) >> ret;\n    return ret;\n}\n\nParser<int> number = [](Source *s) {\n    return toInt(many1(digit)(s));\n};\n\nParser<std::list<int>> expr = [](Source *s) {\n    int x = number(s);\n    auto xs = many(Parser<int>([](Source *s) {  // \u7e70\u308a\u8fd4\u3057\n        char1('+')(s);\n        return number(s);\n    }))(s);\n    xs.push_front(x);  // \u9023\u7d50\n    return xs;\n};\n\nint main() {\n    parseTest(number, \"123\"  );\n    parseTest(expr  , \"1+2\"  );  // '+'\u304c1\u500b\n    parseTest(expr  , \"123\"  );  // '+'\u304c0\u500b\n    parseTest(expr  , \"1+2+3\");  // '+'\u304c2\u500b\n}\n```\n```text:\u5b9f\u884c\u7d50\u679c\n123\n[1,2]\n[123]\n[1,2,3]\n```\n\n## \u7d50\u679c\u3092\u9078\u629e\u3059\u308b\u6f14\u7b97\u5b50\n\n\u30b3\u30fc\u30c9\u3092\u6574\u7406\u3059\u308b\u306e\u306b\u4fbf\u5229\u306a\u6f14\u7b97\u5b50\u3092\u5c0e\u5165\u3057\u307e\u3059\u3002\n\n`a + b`\u306f`a`\u3068`b`\u306e\u7d50\u679c\u3092\u7d50\u5408\u3057\u3066\u8fd4\u3057\u307e\u3059\u304c\u3001\u3044\u305a\u308c\u304b\u7247\u65b9\u3060\u3051\u3092\u8fd4\u3059\u6f14\u7b97\u5b50\u3092\u8003\u3048\u307e\u3059\u3002\n\n* `a << b`: `a`\u3068`b`\u3092\u51e6\u7406\u3057\u305f\u5f8c\u3001\u623b\u308a\u5024\u3068\u3057\u3066`a`\u306e\u7d50\u679c\u3092\u8fd4\u3057\u307e\u3059\u3002\n* `a >> b`: `a`\u3068`b`\u3092\u51e6\u7406\u3057\u305f\u5f8c\u3001\u623b\u308a\u5024\u3068\u3057\u3066`b`\u306e\u7d50\u679c\u3092\u8fd4\u3057\u307e\u3059\u3002\n\n\u305d\u308c\u305e\u308c\u4e0d\u7b49\u53f7\u3092\u77e2\u5370\u306b\u898b\u7acb\u3066\u308b\u3068\u3001\u8fd4\u3059\u5024\u3092\u6307\u793a\u3057\u3066\u3044\u308b\u3068\u89e3\u91c8\u3067\u304d\u307e\u3059\u3002\u51e6\u7406\u306e\u9806\u756a\u3092\u8a18\u53f7\u5316\u3057\u305f\u308f\u3051\u3067\u306f\u306a\u304f\u3001\u3069\u3061\u3089\u3082\u51e6\u7406\u9806\u306f`a`\u2192`b`\u3067\u3059\u3002\n\n\u5b9f\u88c5\u3092\u793a\u3057\u307e\u3059\u3002\n\n```cpp:parsecpp.cpp\uff08\u8ffd\u52a0\uff09\ntemplate <typename T1, typename T2>\nParser<T1> operator<<(const Parser<T1> &p1, const Parser<T2> &p2) {\n    return [=](Source *s) {\n        T1 ret = p1(s);\n        p2(s);\n        return ret;\n    };\n}\n\ntemplate <typename T1, typename T2>\nParser<T2> operator>>(const Parser<T1> &p1, const Parser<T2> &p2) {\n    return [=](Source *s) {\n        p1(s);\n        return p2(s);\n    };\n}\n```\n\n\u52d5\u4f5c\u3092\u78ba\u8a8d\u3057\u307e\u3059\u3002\n\n```cpp\n#include \"parsecpp.cpp\"\n\nint main() {\n    parseTest(letter +  digit, \"a1\");\n    parseTest(letter << digit, \"a1\");\n    parseTest(letter >> digit, \"a1\");\n}\n```\n```text:\u5b9f\u884c\u7d50\u679c\na1\na\n1\n```\n\n### \u30b3\u30fc\u30c9\u306e\u6574\u7406\n\n\u6f14\u7b97\u5b50`>>`\u3092\u4f7f\u3048\u3070`many`\u306e\u5f15\u6570\u304c\u7c21\u5358\u306b\u306a\u308a\u307e\u3059\u3002\n\n```cpp\n#include \"parsecpp.cpp\"\n\nint toInt(const std::string &s) {\n    int ret;\n    std::istringstream(s) >> ret;\n    return ret;\n}\n\nParser<int> number = [](Source *s) {\n    return toInt(many1(digit)(s));\n};\n\nParser<std::list<int>> expr = [](Source *s) {\n    int x = number(s);\n    auto xs = many(char1('+') >> number)(s); // \u7c21\u7565\u5316\n    xs.push_front(x);\n    return xs;\n};\n\nint main() {\n    parseTest(number, \"123\"  );\n    parseTest(expr  , \"1+2\"  );\n    parseTest(expr  , \"123\"  );\n    parseTest(expr  , \"1+2+3\");\n}\n```\n```text:\u5b9f\u884c\u7d50\u679c\n123\n[1,2]\n[123]\n[1,2,3]\n```\n\n\u30e9\u30e0\u30c0\u5f0f\u3067\u66f8\u3044\u3066\u3044\u305f\u90e8\u5206\u304c\u9a5a\u304f\u307b\u3069\u7c21\u5358\u306b\u306a\u3063\u3066\u3044\u308b\u306e\u306b\u6ce8\u76ee\u3057\u3066\u304f\u3060\u3055\u3044\u3002\n\n\u3053\u306e\u3088\u3046\u306b\u30b3\u30f3\u30d3\u30cd\u30fc\u30bf\u3067\u3067\u304d\u306a\u3044\u51e6\u7406\u306f\u3068\u308a\u3042\u3048\u305a\u30e9\u30e0\u30c0\u5f0f\u3067\u66f8\u3044\u3066\u304b\u3089\u3001\u65b0\u3057\u3044\u30b3\u30f3\u30d3\u30cd\u30fc\u30bf\u3092\u5c0e\u5165\u3057\u3066\u5358\u7d14\u5316\u3067\u304d\u306a\u3044\u304b\u3092\u8003\u3048\u308b\u308f\u3051\u3067\u3059\u3002\u3053\u306e\u611f\u899a\u304c\u3064\u304b\u3081\u308c\u3070\u3001\u30d1\u30fc\u30b5\u30b3\u30f3\u30d3\u30cd\u30fc\u30bf\u304c\u3050\u3063\u3068\u8eab\u8fd1\u306b\u611f\u3058\u3089\u308c\u308b\u3067\u3057\u3087\u3046\u3002\n\n## \u8a08\u7b97\n\n\u30ea\u30b9\u30c8\u3092\u5408\u8a08\u3059\u308c\u3070\u8a08\u7b97\u3067\u304d\u307e\u3059\u3002\n\n```cpp\n#include \"parsecpp.cpp\"\n#include <numeric>  // \u8ffd\u52a0\n\nint toInt(const std::string &s) {\n    int ret;\n    std::istringstream(s) >> ret;\n    return ret;\n}\n\nParser<int> number = [](Source *s) {\n    return toInt(many1(digit)(s));\n};\n\nParser<int> expr = [](Source *s) {  // \u623b\u308a\u5024\u306e\u578b -> int\n    int x = number(s);\n    auto xs = many(char1('+') >> number)(s);\n    return std::accumulate(xs.begin(), xs.end(), x);  // \u5408\u8a08\n};\n\nint main() {\n    parseTest(number, \"123\"  );\n    parseTest(expr  , \"1+2\"  );  // OK\n    parseTest(expr  , \"123\"  );  // OK\n    parseTest(expr  , \"1+2+3\");  // OK\n}\n```\n```text:\u5b9f\u884c\u7d50\u679c\n123\n3\n123\n6\n```\n\n\u69cb\u6587\u89e3\u6790\u3068\u8a08\u7b97\u3092\u5206\u96e2\u305b\u305a\u306b`expr`\u3067\u51e6\u7406\u3057\u3066\u3044\u308b\u306e\u304c\u30dd\u30a4\u30f3\u30c8\u3067\u3059\u3002\n\n## \u5f15\u304d\u7b97\n\n\u30de\u30a4\u30ca\u30b9\u306e\u9805\u3092\u8db3\u3059\u3068\u3057\u3066\u51e6\u7406\u3057\u307e\u3059\u3002\n\n```cpp\n#include \"parsecpp.cpp\"\n#include <numeric>\n\nint toInt(const std::string &s) {\n    int ret;\n    std::istringstream(s) >> ret;\n    return ret;\n}\n\nParser<int> number = [](Source *s) {\n    return toInt(many1(digit)(s));\n};\n\nParser<int> expr = [](Source *s) {\n    int x = number(s);\n    auto xs = many(\n           char1('+') >> number\n        || Parser<int>([](Source *s) {  // \u8ffd\u52a0\n            char1('-')(s);\n            return -number(s);  // \u30de\u30a4\u30ca\u30b9\u306e\u9805\n        })\n    )(s);\n    return std::accumulate(xs.begin(), xs.end(), x);\n};\n\nint main() {\n    parseTest(number, \"123\"  );\n    parseTest(expr  , \"1+2\"  );\n    parseTest(expr  , \"123\"  );\n    parseTest(expr  , \"1+2+3\");\n    parseTest(expr  , \"1-2-3\");  // OK\n    parseTest(expr  , \"1-2+3\");  // OK\n}\n```\n```text:\u5b9f\u884c\u7d50\u679c\n123\n3\n123\n6\n-4\n2\n```\n\n\u7b26\u53f7\u3092\u53cd\u8ee2\u3059\u308b\u51e6\u7406\u3092\u30e9\u30e0\u30c0\u5f0f\u3067\u66f8\u3044\u3066\u3044\u307e\u3059\u3002\u3053\u308c\u3092\u5358\u7d14\u5316\u3059\u308b\u30b3\u30f3\u30d3\u30cd\u30fc\u30bf\u306b\u3064\u3044\u3066\u8003\u3048\u3066\u307f\u307e\u3059\u3002\n\n## \u95a2\u6570\u9069\u7528\u30b3\u30f3\u30d3\u30cd\u30fc\u30bf\n\n\u30d1\u30fc\u30b5\u304c\u8fd4\u3057\u305f\u5024\u306b\u4f55\u3089\u304b\u306e\u51e6\u7406\u3092\u52a0\u3048\u308b\u5834\u5408\u3001\u51e6\u7406\u3092\u95a2\u6570\u306b\u5206\u96e2\u3059\u308b\u3053\u3068\u3092\u8003\u3048\u307e\u3059\u3002\n\n\u30d1\u30fc\u30b5\u3068\u95a2\u6570\u3092\u3064\u306a\u3050\u30b3\u30f3\u30d3\u30cd\u30fc\u30bf`apply`\u3092\u5b9f\u88c5\u3057\u307e\u3059\u3002\n\n```cpp:parsecpp.cpp\uff08\u8ffd\u52a0\uff09\ntemplate <typename T1, typename T2>\nParser<T1> apply(const std::function <T1 (const T2 &)> &f, const Parser<T2> &p) {\n    return [=](Source *s) {\n        return f(p(s));\n    };\n}\n```\n\n\u52d5\u4f5c\u3092\u78ba\u8a8d\u3057\u307e\u3059\u3002\n\n```cpp\n#include \"parsecpp.cpp\"\n\nint main() {\n    parseTest(                                                  letter , \"a\");\n    parseTest(apply<char, char>([](char ch) { return ch + 1; }, letter), \"a\");\n}\n```\n```text:\u5b9f\u884c\u7d50\u679c\na\nb\n```\n\n2\u756a\u76ee\u306f`letter`\u3067\u53d6\u5f97\u3057\u305f\u6587\u5b57\u306b1\u3092\u8db3\u3057\u3066\u6b21\u306e\u6587\u5b57\u3092\u8fd4\u3057\u3066\u3044\u307e\u3059\u3002\n\n### \u7b26\u53f7\u53cd\u8ee2\u30b3\u30f3\u30d3\u30cd\u30fc\u30bf\n\n`apply`\u3092\u4f7f\u3063\u3066\u7b26\u53f7\u53cd\u8ee2\u30b3\u30f3\u30d3\u30cd\u30fc\u30bf\u3092\u5b9f\u88c5\u3057\u307e\u3059\u3002\n\n```cpp:parsecpp.cpp\uff08\u8ffd\u52a0\uff09\ntemplate <typename T>\nParser<T> operator-(const Parser<T> &p) {\n    return apply<T, T>([=](T x) { return -x; }, p);\n}\n```\n\n\u3053\u308c\u3092\u4f7f\u3063\u3066\u6f14\u7b97\u5668\u3092\u66f8\u304d\u63db\u3048\u307e\u3059\u3002\n\n```cpp\n#include \"parsecpp.cpp\"\n#include <numeric>\n\nint toInt(const std::string &s) {\n    int ret;\n    std::istringstream(s) >> ret;\n    return ret;\n}\n\nParser<int> number = [](Source *s) {\n    return toInt(many1(digit)(s));\n};\n\nParser<int> expr = [](Source *s) {\n    int x = number(s);\n    auto xs = many(\n           char1('+') >>  number\n        || char1('-') >> -number  // \u9069\u7528\n    )(s);\n    return std::accumulate(xs.begin(), xs.end(), x);\n};\n\nint main() {\n    parseTest(number, \"123\"  );\n    parseTest(expr  , \"1+2\"  );\n    parseTest(expr  , \"123\"  );\n    parseTest(expr  , \"1+2+3\");\n    parseTest(expr  , \"1-2-3\");\n    parseTest(expr  , \"1-2+3\");\n}\n```\n```text:\u5b9f\u884c\u7d50\u679c\n123\n3\n123\n6\n-4\n2\n```\n\n\u8907\u96d1\u306a\u90e8\u5206\u306f\u30b3\u30f3\u30d3\u30cd\u30fc\u30bf\u306b\u62bc\u3057\u8fbc\u3093\u3060\u306e\u3067\u3001\u305d\u308c\u3092\u4f7f\u3046\u30b3\u30fc\u30c9\u304c\u30b7\u30f3\u30d7\u30eb\u306b\u306a\u308a\u307e\u3057\u305f\u3002\n\n### \u6574\u6570\u5316\n\n`number`\u3082`apply`\u3067\u66f8\u304d\u63db\u3048\u3066\u307f\u307e\u3059\u3002\n\n```cpp\n#include \"parsecpp.cpp\"\n#include <numeric>\n\nint toInt(const std::string &s) {\n    int ret;\n    std::istringstream(s) >> ret;\n    return ret;\n}\n\nauto number = apply<int, std::string>(toInt, many1(digit));  // \u9069\u7528\n\nParser<int> expr = [](Source *s) {\n    int x = number(s);\n    auto xs = many(\n           char1('+') >>  number\n        || char1('-') >> -number\n    )(s);\n    return std::accumulate(xs.begin(), xs.end(), x);\n};\n\nint main() {\n    parseTest(number, \"123\"  );\n    parseTest(expr  , \"1+2\"  );\n    parseTest(expr  , \"123\"  );\n    parseTest(expr  , \"1+2+3\");\n    parseTest(expr  , \"1-2-3\");\n    parseTest(expr  , \"1-2+3\");\n}\n```\n```text:\u5b9f\u884c\u7d50\u679c\n123\n3\n123\n6\n-4\n2\n```\n\n\u5206\u304b\u308a\u3084\u3059\u304f\u306a\u3063\u305f\u304b\u306f\u5fae\u5999\u3067\u3059\u304c\u3001\u3068\u308a\u3042\u3048\u305a\u3053\u306e\u307e\u307e\u9032\u3081\u307e\u3059\u3002\n\n## \u56db\u5247\u6f14\u7b97\n\n\u639b\u3051\u7b97\u3084\u5272\u308a\u7b97\u306f\u5408\u8a08\u3067\u306f\u51e6\u7406\u3067\u304d\u306a\u3044\u305f\u3081\u3001`many`\u3067\u30af\u30ed\u30fc\u30b8\u30e3\u306e\u30ea\u30b9\u30c8\u3092\u8fd4\u3057\u3066\u3001\u5f8c\u3067\u307e\u3068\u3081\u3066\u8a08\u7b97\u3057\u307e\u3059\u3002\n\n```cpp\n#include \"parsecpp.cpp\"\n#include <numeric>\n\nint toInt(const std::string &s) {\n    int ret;\n    std::istringstream(s) >> ret;\n    return ret;\n}\n\nauto number = apply<int, std::string>(toInt, many1(digit));\n\nParser<int> expr = [](Source *s) {\n    int x = number(s);\n    auto xs = many(\n        Parser<std::function<int (int)>>([](Source *s) {        // \u578b\u3092\u4fee\u6b63\n            char1('+')(s);\n            int x = number(s);                                  // \u30ad\u30e3\u30d7\u30c1\u30e3\u3055\u308c\u308b\u5909\u6570\n            return [=](int y) { return y + x; };                // \u30af\u30ed\u30fc\u30b8\u30e3\u3092\u8fd4\u3059\n        }) || Parser<std::function<int (int)>>([](Source *s) {\n            char1('-')(s);\n            int x = number(s);                                  // \u30ad\u30e3\u30d7\u30c1\u30e3\u3055\u308c\u308b\u5909\u6570\n            return [=](int y) { return y - x; };                // \u30af\u30ed\u30fc\u30b8\u30e3\u3092\u8fd4\u3059\n        }) || Parser<std::function<int (int)>>([](Source *s) {  // \u8ffd\u52a0: \u639b\u3051\u7b97\n            char1('*')(s);\n            int x = number(s);                                  // \u30ad\u30e3\u30d7\u30c1\u30e3\u3055\u308c\u308b\u5909\u6570\n            return [=](int y) { return y * x; };                // \u30af\u30ed\u30fc\u30b8\u30e3\u3092\u8fd4\u3059\n        }) || Parser<std::function<int (int)>>([](Source *s) {  // \u8ffd\u52a0: \u5272\u308a\u7b97\n            char1('/')(s);\n            int x = number(s);                                  // \u30ad\u30e3\u30d7\u30c1\u30e3\u3055\u308c\u308b\u5909\u6570\n            return [=](int y) { return y / x; };                // \u30af\u30ed\u30fc\u30b8\u30e3\u3092\u8fd4\u3059\n        })\n    )(s);\n    return std::accumulate(xs.begin(), xs.end(), x,             // \u307e\u3068\u3081\u3066\u8a08\u7b97\n        [](int x, const std::function<int (int)> &f) { return f(x); });\n};\n\nint main() {\n    parseTest(number, \"123\"     );\n    parseTest(expr  , \"1+2\"     );\n    parseTest(expr  , \"123\"     );\n    parseTest(expr  , \"1+2+3\"   );\n    parseTest(expr  , \"1-2-3\"   );\n    parseTest(expr  , \"1-2+3\"   );\n    parseTest(expr  , \"2*3+4\"   );  // OK\n    parseTest(expr  , \"2+3*4\"   );  // NG\n    parseTest(expr  , \"100/10/2\");  // OK\n}\n```\n```text:\u5b9f\u884c\u7d50\u679c\n123\n3\n123\n6\n-4\n2\n10\n20\n5\n```\n\n\u6f14\u7b97\u5b50\u306e\u512a\u5148\u9806\u4f4d\u304c\u51e6\u7406\u3067\u304d\u3066\u3044\u307e\u305b\u3093\u3002\n\n### \u6f14\u7b97\u5b50\u306e\u512a\u5148\u9806\u4f4d\n\n\u8db3\u3057\u7b97\u304b\u3089\u898b\u308b\u3068\u30011\u3064\u306e\u6570\u5b57\u3068\u639b\u3051\u7b97\u306e\u30d6\u30ed\u30c3\u30af\u306f\u9805\uff08term\uff09\u3068\u3057\u3066\u5bfe\u7b49\u3067\u3059\u3002\u6570\u5f0f\u3067\u4f8b\u3048\u308b\u3068 $2x+1$ \u306b\u304a\u3044\u3066 $2x$ \u3068 $1$ \u304c\u9805\u3068\u3044\u3046\u5358\u4f4d\u3068\u3057\u3066 $+$ \u304b\u3089\u4e26\u5217\u306b\u6271\u308f\u308c\u3066\u3044\u308b\u3053\u3068\u306b\u76f8\u5f53\u3057\u307e\u3059\u3002\n\n\u9805\u5358\u4f4d\u3067\u8a08\u7b97\u3059\u308b\u3088\u3046\u306b\u5206\u96e2\u3059\u308c\u3070\u6f14\u7b97\u5b50\u306e\u512a\u5148\u9806\u4f4d\u304c\u8868\u73fe\u3067\u304d\u307e\u3059\u3002\n\n```cpp\n#include \"parsecpp.cpp\"\n#include <numeric>\n\nint toInt(const std::string &s) {\n    int ret;\n    std::istringstream(s) >> ret;\n    return ret;\n}\n\nauto number = apply<int, std::string>(toInt, many1(digit));\n\nParser<int> term = [](Source *s) {  // \u9805\u306e\u8a08\u7b97\u3001expr\u3068\u540c\u3058\u69cb\u9020\n    int x = number(s);\n    auto xs = many(\n        Parser<std::function<int (int)>>([](Source *s) {\n            char1('*')(s);\n            int x = number(s);\n            return [=](int y) { return y * x; };\n        }) || Parser<std::function<int (int)>>([](Source *s) {\n            char1('/')(s);\n            int x = number(s);\n            return [=](int y) { return y / x; };\n        })\n    )(s);\n    return std::accumulate(xs.begin(), xs.end(), x,\n        [](int x, const std::function<int (int)> &f) { return f(x); });\n};\n\nParser<int> expr = [](Source *s) {\n    int x = term(s);          // \u9805\u3092\u53d6\u5f97\n    auto xs = many(\n        Parser<std::function<int (int)>>([](Source *s) {\n            char1('+')(s);\n            int x = term(s);  // \u9805\u3092\u53d6\u5f97\n            return [=](int y) { return y + x; };\n        }) || Parser<std::function<int (int)>>([](Source *s) {\n            char1('-')(s);\n            int x = term(s);  // \u9805\u3092\u53d6\u5f97\n            return [=](int y) { return y - x; };\n        })\n    )(s);\n    return std::accumulate(xs.begin(), xs.end(), x,\n        [](int x, const std::function<int (int)> &f) { return f(x); });\n};\n\nint main() {\n    parseTest(number, \"123\"     );\n    parseTest(expr  , \"1+2\"     );\n    parseTest(expr  , \"123\"     );\n    parseTest(expr  , \"1+2+3\"   );\n    parseTest(expr  , \"1-2-3\"   );\n    parseTest(expr  , \"1-2+3\"   );\n    parseTest(expr  , \"2*3+4\"   );\n    parseTest(expr  , \"2+3*4\"   );  // OK\n    parseTest(expr  , \"100/10/2\");\n}\n```\n```text:\u5b9f\u884c\u7d50\u679c\n123\n3\n123\n6\n-4\n2\n10\n14\n5\n```\n\n\u6f14\u7b97\u5b50\u306e\u512a\u5148\u9806\u4f4d\u304c\u51e6\u7406\u3055\u308c\u308b\u3088\u3046\u306b\u306a\u308a\u307e\u3057\u305f\u3002\n\n## \u6574\u7406\n\n\u8a18\u8ff0\u304c\u8907\u96d1\u306a\u305f\u3081\u3001\u4eca\u307e\u3067\u5b9a\u7fa9\u3057\u305f\u6f14\u7b97\u5b50\u3092\u99c6\u4f7f\u3057\u3066\u6574\u7406\u3092\u8a66\u307f\u307e\u3059\u3002\n\n### 2\u5f15\u6570\u306e\u95a2\u6570\u9069\u7528\n\n\u500b\u5225\u306e\u6f14\u7b97\u3067\u30af\u30ed\u30fc\u30b8\u30e3\u3092\u8fd4\u3057\u3066\u3044\u308b\u90e8\u5206\u304c\u5197\u9577\u3067\u3059\u3002`+`\u3092\u4f8b\u306b\u8003\u3048\u307e\u3059\u3002\n\n```cpp:\u629c\u7c8b\n        Parser<std::function<int (int)>>([](Source *s) {\n            char1('+')(s);\n            int y = term(s);\n            return [=](int x) { return x + y; };\n        })\n```\n\n`y`\u306b\u8aad\u307f\u53d6\u3063\u305f\u9805\u3092\u4ee3\u5165\u3057\u3066\u3001\u6b21\u306e\u884c\u306e\u30af\u30ed\u30fc\u30b8\u30e3\u3067\u30ad\u30e3\u30d7\u30c1\u30e3\u3057\u3066\u3044\u307e\u3059\u3002\u30ad\u30e3\u30d7\u30c1\u30e3\u3057\u305f\u5909\u6570\u306f\u5f15\u6570\u3092\u7573\u307f\u8fbc\u3093\u3067\u3044\u308b\u3068\u898b\u306a\u305b\u308b\u305f\u3081\u3001\u672c\u8cea\u7684\u306b\u306f2\u5f15\u6570\u306e\u30e9\u30e0\u30c0\u5f0f\u3067\u3059\u3002\n\n\u203b \u5f15\u6570\u3092\u7573\u307f\u8fbc\u3093\u3067\u5f15\u6570\u3092\u6e1b\u3089\u3057\u305f\u65b0\u3057\u3044\u95a2\u6570\u3092\u751f\u6210\u3059\u308b\u3053\u3068\u3092\u90e8\u5206\u9069\u7528\u3068\u547c\u3073\u307e\u3059\u3002\u8a73\u7d30\u306f\u6b21\u306e\u8a18\u4e8b\u3092\u53c2\u7167\u3057\u3066\u304f\u3060\u3055\u3044\u3002\n\n* [\u30ab\u30ea\u30fc\u5316\u3068\u90e8\u5206\u9069\u7528\uff08JavaScript\u3068Haskell\uff09](http://qiita.com/7shi/items/a0143daac77a205e7962) 2014.10.15\n\n`apply`\u306b\u30aa\u30fc\u30d0\u30fc\u30ed\u30fc\u30c9\u3092\u8ffd\u52a0\u3057\u3066\u30012\u5f15\u6570\u306e\u95a2\u6570\u3092\u6e21\u3057\u3066\u7b2c1\u5f15\u6570\u3092\u30ad\u30e3\u30d7\u30c1\u30e3\u3057\u305f1\u5f15\u6570\u306e\u30af\u30ed\u30fc\u30b8\u30e3\u3092\u8fd4\u3057\u307e\u3059\u3002\n\n```cpp:parsecpp.cpp\uff08\u8ffd\u52a0\uff09\ntemplate <typename T1, typename T2, typename T3>\nParser<std::function<T1 (const T2 &)>> apply(\n        const std::function <T1 (const T2 &, const T3 &)> &f, const Parser<T2> &p) {\n    return [=](Source *s) {\n        T2 x = p(s);\n        return [=](const T3 &y) {\n            return f(x, y);\n        };\n    };\n}\n```\n\n\u3053\u306e\u307e\u307e\u3067\u306f\u578b\u5f15\u6570\u304c\u7169\u96d1\u306b\u306a\u308b\u306e\u3067\u3001\u7279\u6b8a\u5316\u3057\u305f`apply`\u3092\u7528\u610f\u3057\u3066\u4f7f\u3044\u307e\u3059\u3002\n\n```cpp\n#include \"parsecpp.cpp\"\n#include <numeric>\n\nint toInt(const std::string &s) {\n    int ret;\n    std::istringstream(s) >> ret;\n    return ret;\n}\n\nParser<std::function<int (int)>> apply(  // \u7279\u6b8a\u5316\n        const std::function<int (int, int)> &f, const Parser<int> &p) {\n    return apply<int, int, int>(f, p);\n}\n\nauto number = apply<int, std::string>(toInt, many1(digit));\n\nParser<int> term = [](Source *s) {\n    int x = number(s);\n    auto xs = many(\n        Parser<std::function<int (int)>>([](Source *s) {\n            char1('*')(s);\n            return apply([](int x, int y) { return y * x; }, number)(s);  // \u9069\u7528\n        }) || Parser<std::function<int (int)>>([](Source *s) {\n            char1('/')(s);\n            return apply([](int x, int y) { return y / x; }, number)(s);  // \u9069\u7528\n        })\n    )(s);\n    return std::accumulate(xs.begin(), xs.end(), x,\n        [](int x, const std::function<int (int)> &f) { return f(x); });\n};\n\nParser<int> expr = [](Source *s) {\n    int x = term(s);\n    auto xs = many(\n        Parser<std::function<int (int)>>([](Source *s) {\n            char1('+')(s);\n            return apply([](int x, int y) { return y + x; }, term)(s);  // \u9069\u7528\n        }) || Parser<std::function<int (int)>>([](Source *s) {\n            char1('-')(s);\n            return apply([](int x, int y) { return y - x; }, term)(s);  // \u9069\u7528\n        })\n    )(s);\n    return std::accumulate(xs.begin(), xs.end(), x,\n        [](int x, const std::function<int (int)> &f) { return f(x); });\n};\n\nint main() {\n    parseTest(number, \"123\"     );\n    parseTest(expr  , \"1+2\"     );\n    parseTest(expr  , \"123\"     );\n    parseTest(expr  , \"1+2+3\"   );\n    parseTest(expr  , \"1-2-3\"   );\n    parseTest(expr  , \"1-2+3\"   );\n    parseTest(expr  , \"2*3+4\"   );\n    parseTest(expr  , \"2+3*4\"   );\n    parseTest(expr  , \"100/10/2\");\n}\n```\n```text:\u5b9f\u884c\u7d50\u679c\n123\n3\n123\n6\n-4\n2\n10\n14\n5\n```\n\n\u30d1\u30fc\u30b5\u3092\u9023\u7d9a\u3055\u305b\u308b\u5f62\u306b\u6301\u3061\u8fbc\u3081\u307e\u3057\u305f\u3002\n\n### \u975e\u30e9\u30e0\u30c0\u5f0f\u5316\n\n\u6f14\u7b97\u5b50`>>`\u3092\u4f7f\u3048\u3070\u30e9\u30e0\u30c0\u5f0f\u304c\u306a\u304f\u306a\u308a\u307e\u3059\u3002\n\n```cpp\n#include \"parsecpp.cpp\"\n#include <numeric>\n\nint toInt(const std::string &s) {\n    int ret;\n    std::istringstream(s) >> ret;\n    return ret;\n}\n\nParser<std::function<int (int)>> apply(\n        const std::function<int (int, int)> &f, const Parser<int> &p) {\n    return apply<int, int, int>(f, p);\n}\n\nauto number = apply<int, std::string>(toInt, many1(digit));\n\nParser<int> term = [](Source *s) {\n    int x = number(s);\n    auto xs = many(\n           char1('*') >> apply([](int x, int y) { return y * x; }, number)  // \u4fee\u6b63\n        || char1('/') >> apply([](int x, int y) { return y / x; }, number)  // \u4fee\u6b63\n    )(s);\n    return std::accumulate(xs.begin(), xs.end(), x,\n        [](int x, const std::function<int (int)> &f) { return f(x); });\n};\n\nParser<int> expr = [](Source *s) {\n    int x = term(s);\n    auto xs = many(\n           char1('+') >> apply([](int x, int y) { return y + x; }, term)  // \u4fee\u6b63\n        || char1('-') >> apply([](int x, int y) { return y - x; }, term)  // \u4fee\u6b63\n    )(s);\n    return std::accumulate(xs.begin(), xs.end(), x,\n        [](int x, const std::function<int (int)> &f) { return f(x); });\n};\n\nint main() {\n    parseTest(number, \"123\"     );\n    parseTest(expr  , \"1+2\"     );\n    parseTest(expr  , \"123\"     );\n    parseTest(expr  , \"1+2+3\"   );\n    parseTest(expr  , \"1-2-3\"   );\n    parseTest(expr  , \"1-2+3\"   );\n    parseTest(expr  , \"2*3+4\"   );\n    parseTest(expr  , \"2+3*4\"   );\n    parseTest(expr  , \"100/10/2\");\n}\n```\n```text:\u5b9f\u884c\u7d50\u679c\n123\n3\n123\n6\n-4\n2\n10\n14\n5\n```\n\n\u304b\u306a\u308a\u7c21\u6f54\u306b\u306a\u308a\u307e\u3057\u305f\u3002\u3057\u304b\u3057\u307e\u3060\u91cd\u8907\u3059\u308b\u8a18\u8ff0\u304c\u6b8b\u3063\u3066\u3044\u307e\u3059\u3002\n\n### \u5171\u901a\u90e8\u5206\u306e\u95a2\u6570\u5316\n\n\u5024\u3092\u8a55\u4fa1\u3059\u308b\u90e8\u5206\u304c`term`\u3068`expr`\u3067\u540c\u3058\u306a\u306e\u3067\u95a2\u6570\u5316\u3057\u307e\u3059\u3002\n\n```cpp\n#include \"parsecpp.cpp\"\n#include <numeric>\n\nint toInt(const std::string &s) {\n    int ret;\n    std::istringstream(s) >> ret;\n    return ret;\n}\n\nParser<int> eval(\n        const Parser<int> &m,\n        const Parser<std::list<std::function<int (int)>>> &fs) {\n    return [=](Source *s) {\n        int x = m(s);\n        auto xs = fs(s);\n        return std::accumulate(xs.begin(), xs.end(), x,\n            [](int x, const std::function<int (int)> &f) { return f(x); });\n    };\n}\n\nParser<std::function<int (int)>> apply(\n        const std::function<int (int, int)> &f, const Parser<int> &p) {\n    return apply<int, int, int>(f, p);\n}\n\nauto number = apply<int, std::string>(toInt, many1(digit));\n\nauto term = eval(number, many(\n       char1('*') >> apply([](int x, int y) { return y * x; }, number)  // \u4fee\u6b63\n    || char1('/') >> apply([](int x, int y) { return y / x; }, number)  // \u4fee\u6b63\n));\n\nauto expr = eval(term, many(\n       char1('+') >> apply([](int x, int y) { return y + x; }, term)  // \u4fee\u6b63\n    || char1('-') >> apply([](int x, int y) { return y - x; }, term)  // \u4fee\u6b63\n));\n\nint main() {\n    parseTest(number, \"123\"     );\n    parseTest(expr  , \"1+2\"     );\n    parseTest(expr  , \"123\"     );\n    parseTest(expr  , \"1+2+3\"   );\n    parseTest(expr  , \"1-2-3\"   );\n    parseTest(expr  , \"1-2+3\"   );\n    parseTest(expr  , \"2*3+4\"   );\n    parseTest(expr  , \"2+3*4\"   );\n    parseTest(expr  , \"100/10/2\");\n}\n```\n```text:\u5b9f\u884c\u7d50\u679c\n123\n3\n123\n6\n-4\n2\n10\n14\n5\n```\n\n\u9762\u5012\u306a\u90e8\u5206\u306f`eval`\u3068`apply`\u306b\u62bc\u3057\u4ed8\u3051\u308b\u3053\u3068\u3067\u3001`term`\u3068`expr`\u306f\u7c21\u6f54\u3067\u5f62\u5f0f\u7684\u306a\u8a18\u8ff0\u306b\u306a\u308a\u307e\u3057\u305f\u3002\u3044\u304d\u306a\u308a\u3053\u306e\u30b3\u30fc\u30c9\u3092\u898b\u3066\u3082\u5f62\u5f0f\u7684\u904e\u304e\u3066\u7406\u89e3\u3057\u306b\u304f\u3044\u304b\u3082\u3057\u308c\u307e\u305b\u3093\u304c\u3001\u30b3\u30fc\u30c9\u306e\u5909\u5f62\u904e\u7a0b\u3092\u8ffd\u3063\u3066\u307f\u3066\u304f\u3060\u3055\u3044\u3002\n\n## BNF\n\n\u3053\u3053\u307e\u3067\u5b9f\u88c5\u3057\u305f\u3088\u3046\u306a\u51e6\u7406\u306fBNF\uff08[\u30d0\u30c3\u30ab\u30b9\u30fb\u30ca\u30a6\u30a2\u8a18\u6cd5](https://ja.wikipedia.org/wiki/%E3%83%90%E3%83%83%E3%82%AB%E3%82%B9%E3%83%BB%E3%83%8A%E3%82%A6%E3%82%A2%E8%A8%98%E6%B3%95)\uff09\u3068\u547c\u3070\u308c\u308b\u5f62\u5f0f\u8a00\u8a9e\u3067\u8a18\u8ff0\u3067\u304d\u307e\u3059\u3002\n\n\u62e1\u5f35\u7248\u306e[EBNF](https://ja.wikipedia.org/wiki/EBNF)\u3067\u793a\u3057\u307e\u3059\u3002\n\n```text:EBNF\nterm = number, {\"*\"|\"/\", number}\nexpr = term  , {\"+\"|\"-\", term  }\n```\n\n\u4eca\u56de\u306e\u30b3\u30fc\u30c9\u306b\u5408\u308f\u305b\u3066EBNF\u3092\u5909\u5f62\u3059\u308b\u305f\u3081\u3001\u6f14\u7b97\u5b50\u305d\u308c\u305e\u308c\u306b\u51e6\u7406\u3092\u8a18\u8ff0\u3057\u307e\u3059\u3002\n\n```text:EBNF\nterm = number, {(\"*\", number) | (\"/\", number)}\nexpr = term  , {(\"+\", term  ) | (\"-\", term  )}\n```\n\n### \u6bd4\u8f03\n\n\u30b3\u30fc\u30c9\u306b\u30b3\u30e1\u30f3\u30c8\u3068\u3057\u3066\u8ffd\u8a18\u3059\u308b\u306e\u3067\u6bd4\u8f03\u3057\u3066\u304f\u3060\u3055\u3044\u3002\u6163\u308c\u3066\u6765\u308c\u3070\u3001\u5148\u306bBNF\u3067\u5b9a\u7fa9\u3057\u3066\u304b\u3089\u30b3\u30fc\u30c9\u3092\u66f8\u3044\u305f\u65b9\u304c\u52b9\u7387\u7684\u3060\u3068\u611f\u3058\u308b\u3067\u3057\u3087\u3046\u3002\n\n```hs:\u6bd4\u8f03\n// term = number, {(\"*\", number) | (\"/\", number)}\nauto term = eval(number, many(\n       char1('*') >> apply([](int x, int y) { return y * x; }, number)\n    || char1('/') >> apply([](int x, int y) { return y / x; }, number)\n));\n\n// expr = term, {(\"+\", term) | (\"-\", term)}\nauto expr = eval(term, many(\n       char1('+') >> apply([](int x, int y) { return y + x; }, term)\n    || char1('-') >> apply([](int x, int y) { return y - x; }, term)\n));\n```\n\n\u3053\u306e\u30b3\u30fc\u30c9\u306f\u306a\u308b\u3079\u304fBNF\u306b\u8fd1\u4ed8\u3051\u308b\u3088\u3046\u610f\u8b58\u3057\u3066\u3044\u307e\u3059\u3002\u3053\u306e\u3088\u3046\u306a\u4f7f\u3044\u65b9\u306f[\u30c9\u30e1\u30a4\u30f3\u56fa\u6709\u8a00\u8a9e](https://ja.wikipedia.org/wiki/%E3%83%89%E3%83%A1%E3%82%A4%E3%83%B3%E5%9B%BA%E6%9C%89%E8%A8%80%E8%AA%9E)\uff08DSL\uff09\u306b\u898b\u7acb\u3066\u3089\u308c\u307e\u3059\u3002\n\n## \u62ec\u5f27\n\n\u62ec\u5f27\u3092\u30b5\u30dd\u30fc\u30c8\u305f\u3081\u3001\u9805\u306e\u4e0b\u4f4d\u306b\u56e0\u5b50\uff08factor\uff09\u3068\u3044\u3046\u5c64\u3092\u8ffd\u52a0\u3057\u307e\u3059\u3002\n\n\u62ec\u5f27\u306e\u4e2d\u306f`expr`\u306e\u305f\u3081\u6b21\u306e\u3088\u3046\u306b\u518d\u5e30\u304c\u5faa\u74b0\u3057\u307e\u3059\u3002\n\n* `expr` \u2192 `term` \u2192 `factor` \u2192 `expr` \u2192 ...\n\n\u3053\u306e\u3088\u3046\u306a\u518d\u5e30\u3092\u5b9a\u7fa9\u3059\u308b\u306b\u306f\u524d\u65b9\u5ba3\u8a00\u304c\u5fc5\u9808\u3067\u3059\u304c\u3001\u30dd\u30a4\u30f3\u30bf\u3067\u306f\u306a\u304f\u5b9f\u4f53\u3067\u5b9a\u7fa9\u3059\u308b\u30a4\u30f3\u30b9\u30bf\u30f3\u30b9\u306f\u8a18\u8ff0\u9806\u306b\u521d\u671f\u5316\u3055\u308c\u308b\u305f\u3081\u3001\u524d\u65b9\u53c2\u7167\u3057\u305f\u5148\u306e\u30a4\u30f3\u30b9\u30bf\u30f3\u30b9\u304c\u751f\u6210\u3055\u308c\u308b\u524d\u306b\u4f7f\u7528\u3059\u308b\u3053\u3068\u306b\u306a\u308a\u304a\u304b\u3057\u306a\u3053\u3068\u306b\u306a\u308a\u307e\u3059\u3002\n\n\u521d\u671f\u5316\u3092\u9045\u5ef6\u3055\u305b\u308b\u305f\u3081\u30c0\u30df\u30fc\u306e\u30e9\u30e0\u30c0\u5f0f\u3092\u631f\u307f\u307e\u3059\u3002\u30c0\u30df\u30fc\u306e\u65b9\u3092\u4ed6\u304b\u3089\u4f7f\u3046\u305f\u3081\u3001\u5b9f\u4f53\u306e\u65b9\u3092\u540d\u524d\u5909\u66f4\u3057\u307e\u3059\u3002\u524d\u65b9\u5ba3\u8a00\u3067\u306f`auto`\u304c\u4f7f\u3048\u307e\u305b\u3093\u304c\u3001\u524d\u65b9\u5ba3\u8a00\u304c\u3042\u308b\u3068\u5b9f\u4f53\u306e\u65b9\u306b\u3082`auto`\u304c\u4f7f\u3048\u306a\u304f\u306a\u308a\u307e\u3059\u3002\n\n```cpp\n#include \"parsecpp.cpp\"\n#include <numeric>\n\nint toInt(const std::string &s) {\n    int ret;\n    std::istringstream(s) >> ret;\n    return ret;\n}\n\nParser<int> eval(\n        const Parser<int> &m,\n        const Parser<std::list<std::function<int (int)>>> &fs) {\n    return [=](Source *s) {\n        int x = m(s);\n        auto xs = fs(s);\n        return std::accumulate(xs.begin(), xs.end(), x,\n            [](int x, const std::function<int (int)> &f) { return f(x); });\n    };\n}\n\nParser<std::function<int (int)>> apply(\n        const std::function<int (int, int)> &f, const Parser<int> &p) {\n    return apply<int, int, int>(f, p);\n}\n\nauto number = apply<int, std::string>(toInt, many1(digit));\n\nextern Parser<int> factor_;  // \u524d\u65b9\u5ba3\u8a00\nParser<int> factor = [](Source *s) { return factor_(s); };  // \u30c0\u30df\u30fc\u306e\u30e9\u30c3\u30d1\u30fc\n\n// term = factor, {(\"*\", factor) | (\"/\", factor)}\nauto term = eval(factor, many(\n       char1('*') >> apply([](int x, int y) { return y * x; }, factor)\n    || char1('/') >> apply([](int x, int y) { return y / x; }, factor)\n));\n\n// expr = term, {(\"+\", term) | (\"-\", term)}\nauto expr = eval(term, many(\n       char1('+') >> apply([](int x, int y) { return y + x; }, term)\n    || char1('-') >> apply([](int x, int y) { return y - x; }, term)\n));\n\n// factor = (\"(\", expr, \")\") | number\nParser<int> factor_ = char1('(') >> expr << char1(')') || number;  // \u5b9f\u4f53\n\nint main() {\n    parseTest(number, \"123\"     );\n    parseTest(expr  , \"1+2\"     );\n    parseTest(expr  , \"123\"     );\n    parseTest(expr  , \"1+2+3\"   );\n    parseTest(expr  , \"1-2-3\"   );\n    parseTest(expr  , \"1-2+3\"   );\n    parseTest(expr  , \"2*3+4\"   );\n    parseTest(expr  , \"2+3*4\"   );\n    parseTest(expr  , \"100/10/2\");\n    parseTest(expr  , \"(2+3)*4\" );  // OK\n}\n```\n```text:\u5b9f\u884c\u7d50\u679c\n123\n3\n123\n6\n-4\n2\n10\n14\n5\n20\n```\n\n\u5f0f\u3092\u5faa\u74b0\u53c2\u7167\u3055\u305b\u308b\u90e8\u5206\u304c\u96e3\u3057\u3044\u3067\u3059\u304c\u3001\u30c6\u30af\u30cb\u30c3\u30af\u3068\u3057\u3066\u5272\u308a\u5207\u308b\u3057\u304b\u3042\u308a\u307e\u305b\u3093\u3002\n\n## \u30b9\u30da\u30fc\u30b9\n\n\u5f0f\u306b\u30b9\u30da\u30fc\u30b9\u304c\u5165\u3063\u3066\u3044\u3066\u3082\u8a55\u4fa1\u3067\u304d\u308b\u3088\u3046\u306b\u3057\u307e\u3059\u3002\n\n\u30b9\u30da\u30fc\u30b9\u95a2\u4fc2\u306e\u30d1\u30fc\u30b5\u3092\u6c4e\u7528\u90e8\u54c1\u3068\u3057\u3066\u8ffd\u52a0\u3057\u307e\u3059\u3002\n\n```cpp:parsecpp.cpp\uff08\u8ffd\u52a0\uff09\nbool isSpace(char ch) { return ch == '\\t' || ch == ' '; }\nauto space  = satisfy(isSpace) || left(\"not space\");\nauto spaces = many(space);\n```\n\n`factor`\u3092\u4fee\u6b63\u3057\u307e\u3059\u3002\n\n```cpp:\u4fee\u6b63\n// factor = factor = [spaces], (\"(\", expr, \")\") | number, [spaces]\nParser<int> factor_ = spaces\n                   >> (char1('(') >> expr << char1(')') || number)\n                   << spaces;\n```\n\n\u6b21\u306e\u3088\u3046\u306a\u30c6\u30b9\u30c8\u304c\u52d5\u304f\u3088\u3046\u306b\u306a\u308a\u307e\u3059\u3002\n\n```cpp\nint main() {\n    parseTest(number, \"123\"          );\n    parseTest(expr  , \"1 + 2\"        );\n    parseTest(expr  , \"123\"          );\n    parseTest(expr  , \"1 + 2 + 3\"    );\n    parseTest(expr  , \"1 - 2 - 3\"    );\n    parseTest(expr  , \"1 - 2 + 3\"    );\n    parseTest(expr  , \"2 * 3 + 4\"    );\n    parseTest(expr  , \"2 + 3 * 4\"    );\n    parseTest(expr  , \"100 / 10 / 2\" );\n    parseTest(expr  , \"( 2 + 3 ) * 4\");\n}\n```\n```text:\u5b9f\u884c\u7d50\u679c\n123\n3\n123\n6\n-4\n2\n10\n14\n5\n20\n```\n\n\u4ee5\u4e0a\u3067\u56db\u5247\u6f14\u7b97\u5668\u306e\u5b9f\u88c5\u306f\u5b8c\u4e86\u3067\u3059\u3002\n\n\u3053\u3053\u307e\u3067\u306e\u30b3\u30fc\u30c9\u5168\u4f53\u3067\u3059\u3002\n\n* [parsecpp.cpp, calc.cpp](https://bitbucket.org/snippets/7shi/o9dep)\n\n\u30d1\u30fc\u30b5\u30b3\u30f3\u30d3\u30cd\u30fc\u30bf\u306b\u3088\u308b\u30d7\u30ed\u30b0\u30e9\u30df\u30f3\u30b0\u304c\u4f55\u3068\u306a\u304f\u898b\u3048\u3066\u6765\u308c\u3070\u3057\u3081\u305f\u3082\u306e\u3067\u3059\u3002\n"}