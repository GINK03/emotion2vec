{"tags": ["ImageEffect", "Shader", "Unity"], "context": "\n\n\u5bfe\u8c61\nShader\u3084\u3063\u3066\u307f\u305f\u3044\u3051\u3069,\u3069\u3046\u52c9\u5f37\u3059\u308c\u3070\u3088\u3044\u304b\u5206\u304b\u3089\u306a\u3044\u4eba\n\n\u5c0e\u5165\n\u3068\u308a\u3042\u3048\u305a\u52d5\u304b\u3057\u3066\u307f\u308b\n\nCreate -> Shader -> ImageEffectShader\u9078\u629e\n\u30c0\u30d6\u30eb\u30af\u30ea\u30c3\u30af\u3067\u958b\u304d\uff0c\u4e00\u884c\u76ee\u3092Shader \"ShaderTutorial/Tutorial1\"\u306b\u3059\u308b\uff0e\nMaterial\u3092\u4f5c\u6210\u3057\uff0cShader\u3092ShaderTutorial -> Tutorial1\u306b\u3059\u308b\uff0e\nC#\u30b9\u30af\u30ea\u30d7\u30c8\u3092\u4f5c\u6210\uff0c\u5f8c\u8ff0\u3059\u308b\u30b9\u30af\u30ea\u30d7\u30c8\u3092\u8a18\u5165\n\u30b9\u30af\u30ea\u30d7\u30c8\u3092MainCamera\u306b\u30a2\u30bf\u30c3\u30c1\nMaterial\u304c\u306a\u3044!\u3063\u3066\u30a8\u30e9\u30fc\u304c\u51fa\u308b\u306e\u3067\uff0cmaterial\u3092\u30a2\u30bf\u30c3\u30c1\n\u7d42\u4e86\n\n\u624b\u98062\n\n\u624b\u98063\n\n\u624b\u98064\n\nTutorial1.cs\nusing UnityEngine;\nusing System.Collections;\n\n[ExecuteInEditMode]\npublic class Tutorial1 : MonoBehaviour {\n\n    public Material mat;\n\n    void OnRenderImage(RenderTexture src, RenderTexture dest){\n        Graphics.Blit (src, dest, mat);\n    }\n}\n\n\n\u7d50\u679c\n\u8272\u304c\u53cd\u8ee2\u3057\u307e\u3059\uff0e\n\n\u4ee5\u4e0b\u306e\u30c1\u30e5\u30fc\u30c8\u30ea\u30a2\u30eb\u306fShaderToy\u306e\nhttps://www.shadertoy.com/view/Md23DV\n\u3053\u306e\u6295\u7a3f\u3092Unity\u3067\u5b9f\u88c5\u3057\u305f\u3082\u306e\u306b\u306a\u308a\u307e\u3059\uff0e\n\n\u6570\u5024\u306b\u95a2\u3057\u3066\u306f\uff0cfloat, half, fixed\u306e3\u7a2e\u985e\u304c\u3042\u308a\u307e\u3059\u304c\uff0c\n\u3053\u306e\u30c1\u30e5\u30fc\u30c8\u30ea\u30a2\u30eb\u3067\u306ffixed\u3068float\u306e\u307f\u3092\u4f7f\u7528\u3057\u3066\u3044\u307e\u3059\uff0e\n\n\nGithub\nhttps://github.com/teach310/ShaderTutorial2D\n\nTutorial1\n\n\nTutorial1.shader\nShader \"ShaderTutorial/Tutorial1\"\n{\n    SubShader\n    {\n        // No culling or depth\n        Cull Off ZWrite Off ZTest Always\n\n        Pass\n        {\n            CGPROGRAM\n            #pragma vertex vert\n            #pragma fragment frag\n\n            #include \"UnityCG.cginc\"\n\n            struct appdata\n            {\n                float4 vertex : POSITION;\n                float2 uv : TEXCOORD0;\n            };\n\n            struct v2f\n            {\n                float2 uv : TEXCOORD0;\n                float4 vertex : SV_POSITION;\n            };\n\n            v2f vert (appdata v)\n            {\n                v2f o;\n                o.vertex = mul(UNITY_MATRIX_MVP, v.vertex);\n                o.uv = v.uv;\n                return o;\n            }\n\n\n            fixed4 frag (v2f i) : SV_Target\n            {\n                return fixed4(1.0, 1.0, 0.0, 1.0);\n            }\n            ENDCG\n        }\n    }\n}\n\n\n\nfrag\u306e\u4e2d\u8eab\u306b\u6ce8\u76ee\u3057\u3066\u304f\u3060\u3055\u3044.\nfixed4(1.0, 1.0, 0.0, 1.0)\u304c\u9ec4\u8272\u3092\u793a\u3057\u3066\u3044\u307e\u3059\uff0e\n\u30d1\u30e9\u30e1\u30fc\u30bf\u306f\u305d\u308c\u305e\u308c(Red, Green, Blue, Alpha(\u900f\u660e\u5ea6))\u3092\u793a\u3057\u3066\u3044\u307e\u3059\uff0e\n\u5024\u306f0~1.0\u3067\u3059\uff0e\n\n\nPoint\nfrag\u306e\u4e2d\u3067\u8272\u3092return\u3059\u308b\u3053\u3068\u3067\u7d75\u304c\u51fa\u308b\n\n\nTutorial2\n\n\u3053\u3053\u304b\u3089\u306f\u30d5\u30e9\u30b0\u30e1\u30f3\u30c8\u30b7\u30a7\u30fc\u30c0\u306e\u307f\u30b9\u30af\u30ea\u30d7\u30c8\u3092\u793a\u3057\u307e\u3059\uff0e\n\nTutorial2.shader\nfixed4 frag (v2f i) : SV_Target\n{\n    fixed3 color = fixed3(0.0, 1.0, 1.0);\n    fixed alpha = 1.0;\n\n    fixed4 pixel = fixed4(color, alpha);\n    return pixel;\n}\n\n\n\n\nPoint\nfixed3\u578b\u306ecolor\u3068fixed\u578b\u306ealpha\u3092\u5408\u4f53\u3057\u3066fixed4\u578b\u306b\u3067\u304d\u308b\uff0e\n\n\nTutorial3\n\n\nTutorial3.shader\nfixed4 frag (v2f i) : SV_Target\n{\n    fixed redAmount = 0.6;\n    fixed greenAmount = 0.2;\n    fixed blueAmount = 0.9;\n\n    fixed3 color = fixed3(0.0, 0.0, 0.0);\n    color.x = redAmount;\n    color.y = greenAmount;\n    color.z = blueAmount;\n\n    fixed alpha = 1.0;\n    fixed4 pixel = fixed4(color, alpha);\n    return pixel;\n}\n\n\n\n\nPoint\nfixed3\u306e3\u8981\u7d20\u306b\u306f\uff0ccolor.x\u306e\u3088\u3046\u306b\uff0cxyz\u3067\u30a2\u30af\u30bb\u30b9\u3067\u304d\u308b\uff0e\n\n\nTutorial4\n\n\nTutorial4.shader\nfixed4 frag (v2f i) : SV_Target\n{\n    fixed3 color1 = fixed3(0.886, 0.576, 0.898);\n    fixed3 color2 = fixed3(0.537, 0.741, 0.408);\n    fixed3 pixel;\n\n    if(i.uv.x > 0.5){\n        pixel = color2;\n    } else {\n        pixel = color1;\n    }\n\n    return fixed4(pixel, 1.0);\n}\n\n\n\n\nPoint\n\u5f15\u6570\u3067\u3042\u308bi\u3092\u4f7f\u3046\u3053\u3068\u306b\u3088\u308a\uff0c\u73fe\u5728\u51e6\u7406\u3057\u3066\u3044\u308b\u30d4\u30af\u30bb\u30eb\u306euv\u5ea7\u6a19\u3092i.uv\u3067\u53d6\u5f97\u3059\u308b\u3053\u3068\u304c\u3067\u304d\u308b\uff0e\n\u4eca\u56de\u306fi.uv.x > 0.5\u3059\u306a\u308f\u3061\uff0c\u753b\u9762\u3092\u6a2a\u306b\u5206\u65ad\u3059\u308b\u3088\u3046\u306b\u8272\u3092\u5206\u3051\u305f\uff0e\nuv\u5ea7\u6a19\u306ex\u8ef8\u306f\u753b\u9762\u306e\u5de6\u304b\u3089\u4e00\u756a\u53f3\u7aef\u30780~1.0\u3067\u3042\u308b\uff0e\n\n\nTutorial5\n\n\nTutorial5.shader\nfixed4 frag (v2f i) : SV_Target\n{\n    fixed3 color1 = fixed3(0.886, 0.576, 0.898);\n    fixed3 color2 = fixed3(0.537, 0.741, 0.408);\n    fixed3 pixel;\n\n    float dis = 50;\n\n    if(i.uv.x * _ScreenParams.x > dis){\n        pixel = color2;\n    } else {\n        pixel = color1;\n    }\n\n    return fixed4(pixel, 1.0);\n}\n\n\n\n\nPoint\nuv\u5ea7\u6a19\u306b\uff0c\u30b9\u30af\u30ea\u30fc\u30f3\u306e\u89e3\u50cf\u5ea6(_ScreenParams)\u3092\u639b\u3051\u7b97\u3059\u308b\u3053\u3068\u3067\uff0c\u73fe\u5728\u51e6\u7406\u3057\u3066\u3044\u308b\u30d4\u30af\u30bb\u30eb\u306e\u4f4d\u7f6e\u3092\u53d6\u5f97\u3067\u304d\u308b\uff0e\n\n\nTutorial6 \u7dda\u306e\u5f15\u304d\u65b9\n\n\nTutorial6.shader\n// HORIZONTAL AND VERTICAL LINES\nfixed4 frag (v2f i) : SV_Target\n{\n    fixed3 backgroundColor = fixed3(1.0, 1.0, 1.0);\n    fixed3 color1 = fixed3(0.216, 0.471, 0.698); // blue\n    fixed3 color2 = fixed3(1.00, 0.329, 0.298); // red\n    fixed3 color3 = fixed3(0.867, 0.910, 0.247); // yellow\n\n    fixed3 pixel = backgroundColor;\n\n    // line1\n    float leftCoord = 0.54;\n    float rightCoord = 0.55;\n    if(i.uv.x < rightCoord && i.uv.x > leftCoord) pixel = color1;\n\n    // line2\n    float lineCoordinate = 0.4;\n    float lineThickness = 0.003;\n    if(abs(i.uv.x - lineCoordinate) < lineThickness ) pixel = color2;\n\n    // line3\n    if(abs(i.uv.y - 0.6) < 0.01) pixel = color3;\n\n    return fixed4(pixel, 1.0);\n}\n\n\n\n\nPoint\n\u7dda\u306e\u5f15\u304d\u65b9\u306b\u306f2\u7a2e\u985e\u3042\u308a\uff0c\u4e00\u3064\u76ee\u306f\u7dda\u306e\u7aef\u306e\u5ea7\u6a19\u3092\u793a\u3059\u65b9\u6cd5(line1)\uff0e\u4e8c\u3064\u76ee\u306f\u7dda\u306e\u4e2d\u5fc3\u306e\u5ea7\u6a19\u3068\u539a\u3055\u3092\u793a\u3059\u65b9\u6cd5\u3067\u3042\u308b(line2,3)\n\u5f8c\u8005\u306e\u5834\u5408\u306b\u306fif(abs(i.uv.x - lineCoordinate) < lineThickness )\u3067\u8868\u305b\u308b\uff0e\n\n\n\u3082\u3057\u4e0a\u4e0b\u304c\u53cd\u8ee2\u3057\u3066\u3044\u305f\u3089\nv2f vert(appdata v)\n{\n    v2f o;\n    o.vertex = mul(UNITY_MATRIX_MVP, v.vertex);\n    o.uv = v.uv;\n    o.uv.y = 1-o.uv.y; //\u3053\u306e\u884c\u3092\u52a0\u3048\u308b\uff0e\n    return o;\n}\n\n\nTutorial7  \u5ea7\u6a19\u306e\u8996\u899a\u5316\n\n\nTutorial7.shader\n// VISUALISING THE COORDINATE SYSTEM\nfixed4 frag (v2f i) : SV_Target\n{\n    fixed3 backgroundColor = fixed3(1.0, 1.0, 1.0);\n    fixed3 axesColor = fixed3(0.0, 0.0, 1.0);\n    fixed3 gridColor = fixed3(0.5, 0.5, 0.5);\n\n    fixed3 pixel = backgroundColor;\n\n    const float tickWidth = 0.1;\n    for(float lc=0.0; lc< 1.0; lc+=tickWidth){\n        if(abs(i.uv.x - lc) < 0.002) pixel = gridColor;\n        if(abs(i.uv.y - lc) < 0.002) pixel = gridColor;\n    }\n\n    // Draw the axes\n    if(abs(i.uv.x)<0.005) pixel = axesColor;\n    if(abs(i.uv.y)<0.006) pixel = axesColor;\n\n    return fixed4(pixel, 1.0);\n}\n\n\n\n\nPoint\nfor\u6587\u3067\u7dda\u3092\u5f15\u304f\u5ea7\u6a19\u3092\u5909\u3048\u308b\u3053\u3068\u3067\uff0c\u7b49\u9593\u9694\u306b\u7dda\u3092\u5f15\u304f\u3053\u3068\u304c\u3067\u304d\u308b\uff0e\n\n\nTutorial8 \u5ea7\u6a19\u3000\u8ef8\u4e2d\u5fc3\n\nfrag\u306e\u5916\u306b\u3082\u8a18\u5165\u3057\u305f\u305f\u3081\uff0c\u5168\u6587\n```Tutorial8.shader\nShader \"ShaderTutorial/Tutorial8\"\n{\n    SubShader\n    {\n        // No culling or depth\n        Cull Off ZWrite Off ZTest Always\n    // \u8ffd\u52a0\n    CGINCLUDE\n    float mod(float  a, float  b) { return a-b*floor(a/b); } \n    ENDCG\n\n\n    Pass\n    {\n        CGPROGRAM\n        #pragma vertex vert\n        #pragma fragment frag\n\n        #include \"UnityCG.cginc\"\n\n        struct appdata\n        {\n            float4 vertex : POSITION;\n            float2 uv : TEXCOORD0;\n        };\n\n        struct v2f\n        {\n            float2 uv : TEXCOORD0;\n            float4 vertex : SV_POSITION;\n        };\n\n        v2f vert (appdata v)\n        {\n            v2f o;\n            o.vertex = mul(UNITY_MATRIX_MVP, v.vertex);\n            o.uv = v.uv;\n            return o;\n        }\n\n        // MOVING THE COORDINATE CENTER TO THE CENTER OF THE FRAME\n        fixed4 frag (v2f i) : SV_Target\n        {\n            fixed2 r = 2.0 * fixed2(i.uv.x - 0.5, i.uv.y - 0.5);\n            fixed3 backgroundColor = fixed3(1.0, 1.0, 1.0);\n            fixed3 axesColor = fixed3(0.0, 0.0, 1.0);\n            fixed3 gridColor = fixed3(0.5, 0.5, 0.5);\n\n            fixed3 pixel = backgroundColor;\n\n            const float tickWidth = 0.1;\n            if( mod(r.x, tickWidth) < 0.008 ) pixel = gridColor;\n            if( mod(r.y, tickWidth) < 0.008 ) pixel = gridColor;\n\n            // Draw the axes\n            if(abs(r.x)<0.006) pixel = axesColor;\n            if(abs(r.y)<0.007) pixel = axesColor;\n\n            return fixed4(pixel, 1.0);\n        }\n\n\n        ENDCG\n    }\n}\n\n}\n```\n\n\nPoint\n\u81ea\u524d\u306e\u95a2\u6570\u3092Pass\u306e\u5916\u5074\u306b\uff0cCGINCLUDE ~ ENDCG \u306e\u9593\u306b\u8a18\u8ff0\u3057\u3066\u3044\u308b\uff0e\n\u3053\u306emod\u95a2\u6570\u306fa\u3092b\u3067\u5272\u3063\u305f\u4f59\u308a\u3092\u8fd4\u3059\u95a2\u6570\u3067\u3042\u308b\uff0e\n\u3053\u308c\u3092\u4f7f\u3046\u3053\u3068\u3067\uff0c\nif(r.x\u3092tickWidth\u3067\u5272\u3063\u305f\u4f59\u308a < 0.008) \u30b0\u30ea\u30c3\u30c9\u306e\u8272\u306b\u3059\u308b\uff0e\n\u3068\u3059\u308b\u3053\u3068\u304c\u3067\u304d\u3066\u3044\u308b\uff0e\n\n\u307e\u305f\uff0ci.uv.x\u304c0~1\u306e\u5024\u3092\u3068\u308b\u306e\u306b\u5bfe\u3057\uff0c-0.5\u3057\u305f\u3082\u306e\u30922\u500d\u3059\u308b\u3053\u3068\u306b\u3088\u3063\u3066\nr\uff0c\u753b\u9762\u306e\u9818\u57df\u3092-1 ~ 1\u3067\u8868\u3059\u3053\u3068\u304c\u3067\u304d\u308b\uff0e\n\nTutorial9 \u7e26\u6a2a\u6bd4\u306b\u3042\u308f\u305b\u308b\n\n\nTutorial9.shader\n// MAKING THE ASPECT RATIO OF THE COORDINATE SYSTEM 1.0\nfixed4 frag (v2f i) : SV_Target\n{\n    float2 r = 2.0 * (i.uv - 0.5);\n    float aspectRatio = _ScreenParams.x / _ScreenParams.y;\n    r.x *= aspectRatio;\n\n    fixed3 backgroundColor = fixed3(1.0, 1.0, 1.0);\n    fixed3 axesColor = fixed3(0.0, 0.0, 1.0);\n    fixed3 gridColor = fixed3(0.5, 0.5, 0.5);\n\n    fixed3 pixel = backgroundColor;\n\n    const float tickWidth = 0.2;\n    if( mod(r.x, tickWidth) < 0.008 ) pixel = gridColor;\n    if( mod(r.y, tickWidth) < 0.008 ) pixel = gridColor;\n\n    // Draw the axes\n    if(abs(r.x)<0.006) pixel = axesColor;\n    if(abs(r.y)<0.007) pixel = axesColor;\n\n    return fixed4(pixel, 1.0);\n}\n\n\n\n\nPoint\nr.x\u306b_ScreenParams\u304b\u3089\u6c42\u3081\u305faspectRatio\u3092\u639b\u3051\u7b97\u3059\u308b\u3053\u3068\u3067\uff0c\u7e26\u6a2a\u306e\u76ee\u76db\u308a\u304c\u540c\u3058\u9577\u3055\u306b\u306a\u308b\uff0e\n\n\nTutorial10 DISK\n\n\nTutorial10.shader\n// Draw Disks\nfixed4 frag (v2f i) : SV_Target\n{\n    float2 r = 2.0 * (i.uv - 0.5);\n    float aspectRatio = _ScreenParams.x / _ScreenParams.y;\n    r.x *= aspectRatio;\n\n    fixed3 backgroundColor = fixed3(1.0, 1.0, 1.0);\n    fixed3 col1 = fixed3(0.216, 0.471, 0.698); // blue\n    fixed3 col2 = fixed3(1.00, 0.329, 0.298); // red\n    fixed3 col3 = fixed3(0.867, 0.910, 0.247); // yellow\n\n    fixed3 pixel = backgroundColor;\n\n    //Disk1 blue\n    float radius = 0.8;\n    if(r.x*r.x + r.y*r.y < radius*radius){\n        pixel = col1;\n    }\n\n    //Disk2 red\n    if(length(r) < 0.3){\n        pixel = col3;\n    }\n\n    //Disk3 yellow\n    float2 center = fixed2(0.9, -0.4);\n    float2 d = r - center;\n    if( length(d) < 0.6){\n        pixel = col2;\n    }\n\n    return fixed4(pixel, 1.0);\n}\n\n\n\n\nPoint\nDisk1\u3067\u306f\uff0c2\u70b9\u9593\u306e\u8ddd\u96e2\u6c42\u3081\u308b\u516c\u5f0f\u30922\u4e57\u3059\u308b\u3053\u3068\u3067\uff0c\u534a\u5f840.8\u4ee5\u5185\u3092\u5857\u308b\u3068\u3044\u3046\u51e6\u7406\u3092\u884c\u3063\u3066\u3044\u308b\uff0e\nDisk2\u3067\u306f\uff0c\u30d9\u30af\u30c8\u30eb\u306e\u8ddd\u96e2\u3092\u6c42\u3081\u308blength\u95a2\u6570\u3092\u7528\u3044\u308b\u3053\u3068\u3067\uff0c\u77ed\u304f\u66f8\u3044\u3066\u3044\u308b\uff0e\nDisk3\u3067\u306f\uff0c\u79fb\u52d5\u3055\u305b\u305f\u3044\u5206\u3060\u3051\u5f15\u304d\u7b97\u3059\u308b\u3053\u3068\u306b\u3088\u3063\u3066\u5186\u306e\u4e2d\u5fc3\u4f4d\u7f6e\u3092\u79fb\u52d5\u3057\u3066\u3044\u308b\uff0e\n\u4f8b\uff1a\u3000\nmath\ny = (x-3)^2\n\n\u3060\u3068\uff0c\u7dda\u304cx\u8ef8\u6b63\u306e\u65b9\u5411\u306b3\u79fb\u52d5\u3059\u308b\uff0e\n\n\nTutorial11 Function\u3092\u4f5c\u308b\n\n\nTutorial11.shader\nShader \"ShaderTutorial/Tutorial11\"\n{\n    SubShader\n    {\n        // No culling or depth\n        Cull Off ZWrite Off ZTest Always\n\n        // \u8ffd\u52a0\n        CGINCLUDE\n        fixed3 disk(fixed2 r, fixed2 center, fixed radius, fixed3 color, fixed3 pixel){\n            fixed3 col = pixel;\n            if(length(r - center) < radius){\n                col = color;\n            }\n            return col;\n        }\n        ENDCG\n\n\n        Pass\n        {\n            CGPROGRAM\n            #pragma vertex vert\n            #pragma fragment frag\n\n            #include \"UnityCG.cginc\"\n\n            struct appdata\n            {\n                float4 vertex : POSITION;\n                float2 uv : TEXCOORD0;\n            };\n\n            struct v2f\n            {\n                float2 uv : TEXCOORD0;\n                float4 vertex : SV_POSITION;\n            };\n\n            v2f vert (appdata v)\n            {\n                v2f o;\n                o.vertex = mul(UNITY_MATRIX_MVP, v.vertex);\n                o.uv = v.uv;\n                o.uv.y = 1-o.uv.y;\n                return o;\n            }\n\n            // Functions\n            fixed4 frag (v2f i) : SV_Target\n            {\n                float2 r = 2.0 * (i.uv - 0.5);\n                float aspectRatio = _ScreenParams.x / _ScreenParams.y;\n                r.x *= aspectRatio;\n\n                fixed3 backgroundColor = fixed3(0.3, 0.3, 0.3);\n                fixed3 col1 = fixed3(0.216, 0.471, 0.698); // blue\n                fixed3 col2 = fixed3(1.00, 0.329, 0.298); // red\n                fixed3 col3 = fixed3(0.867, 0.910, 0.247); // yellow\n\n                fixed3 pixel = backgroundColor;\n\n                pixel = disk(r, fixed2(0.1, 0.3), 0.5, col3, pixel);\n                pixel = disk(r, fixed2(-0.8, -0.6), 1.5, col1, pixel);\n                pixel = disk(r, fixed2(0.8, 0.0), 0.15, col2, pixel);\n\n\n                return fixed4(pixel, 1.0);\n            }\n\n\n            ENDCG\n        }\n    }\n}\n\n\n\n\nPoint\n\u95a2\u6570\u306fCGINCLUDE ~ ENDCG\u5185\u306b\u8a18\u8ff0\uff0e\nreturn\u6587\u304c\u4f7f\u3048\u308b\uff0e\n\n\nTutorial12 STEP\n\n\nTutorial12.shader\n// BUILT-IN FUNCTION: STEP\nfixed4 frag (v2f i) : SV_Target\n{\n    float2 r = 2.0 * (i.uv - 0.5);\n    float aspectRatio = _ScreenParams.x / _ScreenParams.y;\n    r.x *= aspectRatio;\n\n    fixed3 backgroundColor = fixed3(0.0, 0.0, 0.0); // black\n    fixed3 col1 = fixed3(0.216, 0.471, 0.698); // blue\n    fixed3 col2 = fixed3(1.00, 0.329, 0.298); // red\n    fixed3 col3 = fixed3(0.867, 0.910, 0.247); // yellow\n\n    fixed3 pixel = backgroundColor;\n\n    float edge, variable, ret;\n\n    // divide the screen into five parts horizontally\n    // for different examples\n    if(r.x < -0.6 * aspectRatio){ // part1\n        variable = r.y;\n        edge = 0.2;\n        if( variable > edge ){\n            ret = 1.0;\n        }else{\n            ret = 0.0;\n        }\n    }\n    else if(r.x < -0.2 * aspectRatio){ //part2\n        variable = r.y;\n        edge = -0.2;\n        // part1\u3068\u540c\u3058\u3053\u3068\n        ret = step(edge, variable); \n    }\n    else if(r.x < 0.2 * aspectRatio){\n        // 1.0 - step(a,b) \u3067\u53cd\u8ee2\n        ret = 1.0 - step(0.5, r.y); \n    }\n    else if(r.x < 0.6 * aspectRatio){\n        // r.y\u304c-0.4\u4ee5\u4e0a\u3067ret\u306f0.3 + 0.5 = 0.8\n        ret = 0.3 + 0.5 * step(-0.4, r.y);  \n    }\n    else{\n        // step\u3092\u4e8c\u3064\u4f7f\u3046\u3053\u3068\u3067gap\u3092\u751f\u307f\u51fa\u3059\u3053\u3068\u304c\u3067\u304d\u308b\n        ret = step(-0.3, r.y) * (1.0 - step(0.2, r.y)); \n    }\n\n    pixel = fixed3 (ret, ret, ret);\n    return fixed4(pixel, 1.0);\n}\n\n\n\n\nPoint\n\n\n\n\u540d\u524d\n\u8aac\u660e\n\n\n\n\nstep(a,b)\nb\u304ca\u3092\u3088\u308a\u5927\u304d\u3051\u308c\u30701, \u305d\u3046\u3067\u306a\u3051\u308c\u30700\n\n\n\n\n\nTutorial13\n\n\nTutorial13.shader\nShader \"ShaderTutorial/Tutorial13\"\n{\n    SubShader\n    {\n        // No culling or depth\n        Cull Off ZWrite Off ZTest Always\n\n        // \u8ffd\u52a0\n        CGINCLUDE\n        #define PI 3.14159\n        ENDCG\n\n\n        Pass\n        {\n            CGPROGRAM\n            #pragma vertex vert\n            #pragma fragment frag\n\n            #include \"UnityCG.cginc\"\n\n            struct appdata\n            {\n                float4 vertex : POSITION;\n                float2 uv : TEXCOORD0;\n            };\n\n            struct v2f\n            {\n                float2 uv : TEXCOORD0;\n                float4 vertex : SV_POSITION;\n            };\n\n            v2f vert (appdata v)\n            {\n                v2f o;\n                o.vertex = mul(UNITY_MATRIX_MVP, v.vertex);\n                o.uv = v.uv;\n                o.uv.y = 1-o.uv.y;\n                return o;\n            }\n\n            // BUILT-IN FUNCTION: CLAMP\n            fixed4 frag (v2f i) : SV_Target\n            {\n                float2 r = 2.0 * (i.uv - 0.5);\n                float aspectRatio = _ScreenParams.x / _ScreenParams.y;\n                r.x *= aspectRatio;\n\n                fixed3 backgroundColor = fixed3(0.0, 0.0, 0.0); // black\n                fixed3 col1 = fixed3(0.216, 0.471, 0.698); // blue\n                fixed3 col2 = fixed3(1.00, 0.329, 0.298); // red\n                fixed3 col3 = fixed3(0.867, 0.910, 0.247); // yellow\n\n                fixed3 pixel = backgroundColor;\n\n                float edge, variable, ret;\n\n                // divide the screen into four parts horizontally\n                // for different examples\n                if(i.uv.x < 0.25){ // part1\n                    ret = i.uv.y;\n                }\n                else if(i.uv.x < 0.5){ // part2\n                    float minVal = 0.3;\n                    float maxVal = 0.6;\n                    variable = i.uv.y;\n                    if (variable < minVal){\n                        ret = minVal;\n                    }\n                    if( variable > minVal && variable < maxVal){\n                        ret = variable;\n                    }\n                    if( variable > maxVal ){\n                        ret = maxVal;\n                    }\n                }\n                else if(i.uv.x < 0.75){ // part3\n                    float minVal = 0.6;\n                    float maxVal = 0.8;\n                    variable = i.uv.y;\n                    ret = clamp(variable, minVal, maxVal);\n                }\n                else { // part4\n                    float y = cos(5.0 * 2.0 * PI *i.uv.y);\n                    y = (y+1.0)*0.5; // map [-1,1] to [0,1]\n                    ret = clamp(y, 0.2, 0.8);\n                }\n\n                pixel = fixed3 (ret, ret, ret);\n                return fixed4(pixel, 1.0);\n            }\n\n\n            ENDCG\n        }\n    }\n}\n\n\n\n\nPoint\n\n\n\n\u540d\u524d\n\u8aac\u660e\n\n\n\n\nfloat Clamp(float a,float min,float max)\na\u304cmin\u3088\u308a\u3082\u5c0f\u3055\u3051\u308c\u3070min, a\u304cmax\u3088\u308a\u3082\u5927\u304d\u3051\u308c\u3070max, \u305d\u308c\u4ee5\u5916\u3067\u3042\u308c\u3070a\u3092\u8fd4\u3059\n\n\n\n\n\nTutorial14 smoothstep\n\n\nTutorial14.shader\n// BUILT-IN FUNCTION: SMOOTHSTEP\nfixed4 frag (v2f i) : SV_Target\n{\n    fixed3 backgroundColor = fixed3(0.0, 0.0, 0.0); // black\n    fixed3 col1 = fixed3(0.216, 0.471, 0.698); // blue\n    fixed3 col2 = fixed3(1.00, 0.329, 0.298); // red\n    fixed3 col3 = fixed3(0.867, 0.910, 0.247); // yellow\n\n    fixed3 pixel = backgroundColor;\n\n    float edge, variable, ret;\n\n    // divide the screen into five parts horizontally\n    // for different examples\n    if(i.uv.x < 1.0/5.0){ // part1\n        edge = 0.5;\n        ret = step(edge, i.uv.y);\n    }\n    else if(i.uv.x < 2.0/5.0){ // part2\n        float edge0 = 0.45;\n        float edge1 = 0.55;\n        float t = (i.uv.y - edge0) / (edge1 - edge0);\n        //when i.uv.y == edge0 => t = 0.0\n        //when i.uv.y == edge1 => t = 1.0\n        //0\u304b\u30891\u306b\u7dda\u5f62\u306b\u9077\u79fb\u3059\u308b\n        float t1 = clamp(t, 0.0, 1.0);\n        //edge0 \u672a\u6e80\u306e\u6642\u306f \u30de\u30a4\u30ca\u30b9\u306e\u5024\u3092\u3068\u308a\uff0c\n        //edge1 \u3088\u308a\u5927\u304d\u3044\u6642\u306f1.0\u3088\u308a\u5927\u304d\u3044\u5024\u3092\u3068\u308b\uff0e\n        //\u3057\u304b\u3057\uff0c0~1\u306e\u5024\u304c\u307b\u3057\u3044\u306e\u3067clamp\u3092\u4f7f\u3044\u307e\u3059\n        ret = t1;\n    }\n    else if(i.uv.x < 3.0/ 5.0){ // part3\n        float edge0 = 0.45;\n        float edge1 = 0.55;\n        float t = clamp((i.uv.y - edge0)/(edge1 - edge0), 0.0, 1.0);\n        float t1 = 3.0*t*t - 2.0*t*t*t;\n        //\u7dda\u5f62\u3067\u306a\u304f\u306a\u3081\u3089\u304b\u306b\u3059\u308b\uff0e\n        ret = t1;\n    }\n    else if(i.uv.x < 4.0/5.0){ // part4\n        ret = smoothstep(0.45, 0.55, i.uv.y);\n    }\n    else if(i.uv.x < 5.0/5.0){\n        float edge0 = 0.45;\n        float edge1 = 0.55;\n        float t = clamp((i.uv.y - edge0)/(edge1 - edge0), 0.0, 1.0);\n        float t1 = t*t*t*(t*(t*6.0 - 15.0) + 10.0);\n        ret = t1;\n    }\n\n\n    pixel = fixed3 (ret, ret, ret);\n    return fixed4(pixel, 1.0);\n}\n\n\n\n\nPoint\n\n\n\n\u540d\u524d\n\u8aac\u660e\n\n\n\n\nfloat smoothstep(float min, float max, float a)\na\u304cmin\u3068max\u306e\u9593\u306e\u6642\u306b\uff0c\u7dda\u5f62\u3067\u306a\u304f\uff0c\u306a\u3081\u3089\u304b\u306b\u88dc\u5b8c\u3059\u308b\u3088\u3046\u306a\u5024\u3092\u8fd4\u3059\uff0emin\u4ee5\u4e0b\u3067\u3042\u308c\u30700,max\u4ee5\u4e0a\u30671\n\n\n\n\n\nTutorial15 lerp\n\n\nTutorial15.shader\n// BUILT-IN FUNCTION: LERP\nfixed4 frag (v2f i) : SV_Target\n{\n\n    fixed3 backgroundColor = fixed3(0.0, 0.0, 0.0); // black\n    fixed3 col1 = fixed3(0.216, 0.471, 0.698); // blue\n    fixed3 col2 = fixed3(1.00, 0.329, 0.298); // red\n    fixed3 col3 = fixed3(0.867, 0.910, 0.247); // yellow\n\n    fixed3 pixel = backgroundColor;\n\n    fixed3 ret;\n\n    // divide the screen into five parts horizontally\n    // for different examples\n    if(i.uv.x < 1.0/5.0){ // part1\n        float x0 = 0.2;\n        float x1 = 0.7;\n        float m = 0.1;\n        float val = x0 * (1.0-m) + x1*m;\n        ret = fixed3(val, val, val);\n    }\n    else if(i.uv.x < 2.0/5.0){ // part2\n        float x0 = 0.2;\n        float x1 = 0.7;\n        float m = i.uv.y;\n        float val = x0*(1.0-m) + x1*m;\n        ret = fixed3(val, val, val);\n    }\n    else if(i.uv.x < 3.0/ 5.0){ // part3\n        float x0 = 0.2;\n        float x1 = 0.7;\n        float m = i.uv.y;\n        float val = lerp(x0, x1, m);\n        ret = fixed3(val, val, val);\n\n    }\n    else if(i.uv.x < 4.0/5.0){ // part4\n        float m = i.uv.y;\n        ret = lerp(col1, col2, m);\n    }\n    else if(i.uv.x < 5.0/5.0){\n        //smoothstep\u3068lerp\u3092\u4f7f\u3063\u305f\u8272\u306e\u9077\u79fb\n        float m = smoothstep(0.5, 0.6, i.uv.y);\n        ret = lerp(col1, col2, m);\n    }\n\n\n    pixel = ret;\n    return fixed4(pixel, 1.0);\n}\n\n\n\n\nPoint\n\n\n\n\u540d\u524d\n\u8aac\u660e\n\n\n\n\nfloat lerp(a,b,s)\na+s(b-a)\u3092\u8fd4\u3059\uff0ea\u304b\u3089b\u3078\u306e\u7dda\u5f62\u88dc\u5b8c s\u306f\u57fa\u672c0~1\u3067\u4f7f\u3046\n\n\n\n\n\nTutorial16 COLOR ADDITION AND SUBSTRCTION\n\n\nTutorial16.shader\nShader \"ShaderTutorial/Tutorial18\"\n{\n    SubShader\n    {\n        // No culling or depth\n        Cull Off ZWrite Off ZTest Always\n\n        // \u8ffd\u52a0\n        CGINCLUDE\n        // \u306a\u3081\u3089\u304b\u306aDISK\n        float disk(float2 r, float2 center, float radius){\n            float distanceFromCenter = length(r - center);\n            float outsideOfDisk = smoothstep(radius - 0.005, radius + 0.005, distanceFromCenter);\n            float insideOfDisk = 1.0 - outsideOfDisk;\n            return insideOfDisk;\n\n        }\n        ENDCG\n\n\n        Pass\n        {\n            CGPROGRAM\n            #pragma vertex vert\n            #pragma fragment frag\n\n            #include \"UnityCG.cginc\"\n\n            struct appdata\n            {\n                float4 vertex : POSITION;\n                float2 uv : TEXCOORD0;\n            };\n\n            struct v2f\n            {\n                float2 uv : TEXCOORD0;\n                float4 vertex : SV_POSITION;\n            };\n\n            v2f vert (appdata v)\n            {\n                v2f o;\n                o.vertex = mul(UNITY_MATRIX_MVP, v.vertex);\n                o.uv = v.uv;\n                o.uv.y = 1-o.uv.y;\n                return o;\n            }\n\n            // ANTI-ALIASING WITH SMOOTHSTEP\n            fixed4 frag (v2f i) : SV_Target\n            {\n                float2 r = 2.0 * (i.uv - 0.5);\n                float aspectRatio = _ScreenParams.x / _ScreenParams.y;\n                r.x *= aspectRatio;\n\n                fixed3 black = float3(0.0, 0.0, 0.0); // black\n                fixed3 white = float3(1.0, 1.0, 1.0);\n                fixed3 gray = float3(0.3, 0.3, 0.3);\n                fixed3 col1 = float3(0.216, 0.471, 0.698); // blue\n                fixed3 col2 = float3(1.00, 0.329, 0.298); // red\n                fixed3 col3 = float3(0.867, 0.910, 0.247); // yellow\n\n                fixed3 ret;\n                fixed3 pixel;\n                float d;\n\n\n                if(i.uv.x < 1.0/3.0){ // part1\n                    ret = gray;\n                    d = disk(r, float2(-1.1, 0.3), 0.4);\n                    ret = lerp(ret, col1, d);\n                    d = disk(r, float2(-1.3, 0.0), 0.4);\n                    ret = lerp(ret, col2, d);\n                    d = disk(r, float2(-1.05, -0.3), 0.4);\n                    ret = lerp(ret, col3, d);\n                }\n                else if(i.uv.x < 2.0/3.0){ // part2\n                    // Color addition\n                    ret = black;\n                    ret += disk(r, float2(0.1, 0.3), 0.4) * col1;\n                    ret += disk(r, float2(-0.1, 0.0), 0.4) * col2;\n                    ret += disk(r, float2(0.15, -0.3), 0.4) * col3;\n                }\n                else if(i.uv.x < 3.0/ 3.0){ // part3\n                    // Color substraction\n                    ret = white;\n                    ret -= disk(r, float2(1.1, 0.3), 0.4) * col1;\n                    ret -= disk(r, float2(1.05, 0.0), 0.4) * col2;\n                    ret -= disk(r, float2(1.35, -0.25), 0.4) * col3;\n\n                }\n\n\n\n                pixel = ret;\n                return fixed4(pixel, 1.0);\n            }\n\n\n            ENDCG\n        }\n    }\n}\n\n\n\n\nPoint\n\u5186\u306e\u5883\u754c\u3092\u306a\u3081\u3089\u304b\u306b\u3057\u3066\u3044\u308b\uff0e\nret \u306b\u52a0\u7b97\u6e1b\u7b97\u3059\u308b\u3053\u3068\u3067\u8272\u3092\u5909\u5316\u3055\u305b\u3066\u3044\u308b\uff0e\n\n\nTutorial17 \u56de\u8ee2\n\n\nTutorial17.shader\nShader \"ShaderTutorial/Tutorial17\"\n{\n    SubShader\n    {\n        // No culling or depth\n        Cull Off ZWrite Off ZTest Always\n\n        // \u8ffd\u52a0\n        CGINCLUDE\n\n        #define PI 3.14159\n\n        // (anti-aliased)Grid\u3092\u4f5c\u308b\u95a2\u6570\n        float coordinateGrid(float2 r){\n            float3 axisCol = float3(0.0, 0.0, 1.0);\n            float3 gridCol = float3(0.5, 0.5, 0.5);\n            float ret = 0.0;\n\n            // Draw grid lines\n            const float tickWidth = 0.1;\n            for(float i= -2.0;i<2.0; i+= tickWidth){\n                ret += 1.0 - smoothstep(0.0, 0.008, abs (r.x - i));\n                ret += 1.0 - smoothstep(0.0, 0.008, abs (r.y - i));\n            }\n\n            // Draw the axis\n            ret += 1.0-smoothstep(0.001, 0.015, abs(r.x));\n            ret += 1.0-smoothstep(0.001, 0.015, abs(r.y));\n            return ret;\n        }\n\n        // returns 1.0 if inside circle\n        float disk(float2 r, float2 center, float radius){\n            return 1.0 - smoothstep( radius - 0.005, radius + 0.005, length(r - center));\n        }\n\n        // returns 1.0 if inside the disk\n        float rectangle(float2 r, float2 bottomLeft, float2 topRight){\n            float ret;\n            float d = 0.005;\n            ret = smoothstep(bottomLeft.x - d, bottomLeft.x + d, r.x);\n            ret *= smoothstep(bottomLeft.y - d, bottomLeft.y + d, r.y);\n            ret *= 1.0 - smoothstep(topRight.y - d, topRight.y + d, r.y);\n            ret *= 1.0 - smoothstep(topRight.x - d, topRight.x + d, r.x);\n            return ret;\n        }\n        ENDCG\n\n\n        Pass\n        {\n            CGPROGRAM\n            #pragma vertex vert\n            #pragma fragment frag\n\n            #include \"UnityCG.cginc\"\n\n            struct appdata\n            {\n                float4 vertex : POSITION;\n                float2 uv : TEXCOORD0;\n            };\n\n            struct v2f\n            {\n                float2 uv : TEXCOORD0;\n                float4 vertex : SV_POSITION;\n            };\n\n            v2f vert (appdata v)\n            {\n                v2f o;\n                o.vertex = mul(UNITY_MATRIX_MVP, v.vertex);\n                o.uv = v.uv;\n                o.uv.y = 1-o.uv.y;\n                return o;\n            }\n\n            //COORDINATE TRANSFORMATIONS: ROTATION\n            fixed4 frag (v2f i) : SV_Target\n            {\n                float2 r = 2.0 * (i.uv - 0.5);\n                float aspectRatio = _ScreenParams.x / _ScreenParams.y;\n                r.x *= aspectRatio;\n\n                fixed3 bgCol = float3(1.0, 1.0, 1.0); // white\n\n                fixed3 col1 = float3(0.216, 0.471, 0.698); // blue\n                fixed3 col2 = float3(1.00, 0.329, 0.298); // red\n                fixed3 col3 = float3(0.867, 0.910, 0.247); // yellow\n\n                fixed3 ret;\n                float2 q;\n                float angle;\n                angle = 0.2*PI; // \u5358\u4f4d\u306f\u30e9\u30b8\u30a2\u30f3\n                // 2\u6b21\u5143\u306e\u56de\u8ee2\n                q.x = cos(angle)*r.x + sin(angle)*r.y;\n                q.y = -sin(angle)*r.x + cos(angle)*r.y;\n\n                ret = bgCol;\n                // draw the old and new coordinate systems\n                ret = lerp(ret, col1, coordinateGrid(r)*0.4);\n                ret = lerp(ret, col2, coordinateGrid(q));\n\n                // draw shapes\n                ret = lerp(ret, col1, disk(r, float2(1.0, 0.0), 0.2));\n                ret = lerp(ret, col2, disk(q, float2(1.0, 0.0), 0.2));\n                ret = lerp(ret, col1, rectangle(r, float2(-0.8, 0.2),float2(-0.5, 0.4)));\n                ret = lerp(ret, col2, rectangle(q, float2(-0.8, 0.2),float2(-0.5, 0.4)));\n\n\n\n                fixed3 pixel = ret;\n                return fixed4(pixel, 1.0);\n            }\n\n\n            ENDCG\n        }\n    }\n}\n\n\n\n\nPoint\n\u56de\u8ee2\u884c\u5217\u3092r\u306b\u639b\u3051\u7b97\u3059\u308b\u3053\u3068\u3067\uff0c\u5ea7\u6a19\u3092\u56de\u8ee2\u3055\u305b\uff0c\u305d\u306e\u5ea7\u6a19\u4e0a\u306e\u56f3\u5f62\u3082\u56de\u8ee2\u3055\u305b\u3066\u3044\u308b\uff0e\n\n\nTutorial18 \u30b9\u30b1\u30fc\u30ea\u30f3\u30b0\n\nShader \"ShaderTutorial/Tutorial18\"\n{\n    SubShader\n    {\n        // No culling or depth\n        Cull Off ZWrite Off ZTest Always\n\n        // \u8ffd\u52a0\n        CGINCLUDE\n\n        #define PI 3.14159\n\n        // (anti-aliased)Grid\u3092\u4f5c\u308b\u95a2\u6570\n        float coordinateGrid(float2 r){\n            float3 axisCol = float3(0.0, 0.0, 1.0);\n            float3 gridCol = float3(0.5, 0.5, 0.5);\n            float ret = 0.0;\n\n            // Draw grid lines\n            const float tickWidth = 0.1;\n            for(float i= -2.0;i<2.0; i+= tickWidth){\n                ret += 1.0 - smoothstep(0.0, 0.008, abs (r.x - i));\n                ret += 1.0 - smoothstep(0.0, 0.008, abs (r.y - i));\n            }\n\n            // Draw the axis\n            ret += 1.0-smoothstep(0.001, 0.015, abs(r.x));\n            ret += 1.0-smoothstep(0.001, 0.015, abs(r.y));\n            return ret;\n        }\n\n        // returns 1.0 if inside circle\n        float disk(float2 r, float2 center, float radius){\n            return 1.0 - smoothstep( radius - 0.005, radius + 0.005, length(r - center));\n        }\n\n        // returns 1.0 if inside the disk\n        float rectangle(float2 r, float2 bottomLeft, float2 topRight){\n            float ret;\n            float d = 0.005;\n            ret = smoothstep(bottomLeft.x - d, bottomLeft.x + d, r.x);\n            ret *= smoothstep(bottomLeft.y - d, bottomLeft.y + d, r.y);\n            ret *= 1.0 - smoothstep(topRight.y - d, topRight.y + d, r.y);\n            ret *= 1.0 - smoothstep(topRight.x - d, topRight.x + d, r.x);\n            return ret;\n        }\n        ENDCG\n\n\n        Pass\n        {\n            CGPROGRAM\n            #pragma vertex vert\n            #pragma fragment frag\n\n            #include \"UnityCG.cginc\"\n\n            struct appdata\n            {\n                float4 vertex : POSITION;\n                float2 uv : TEXCOORD0;\n            };\n\n            struct v2f\n            {\n                float2 uv : TEXCOORD0;\n                float4 vertex : SV_POSITION;\n            };\n\n            v2f vert (appdata v)\n            {\n                v2f o;\n                o.vertex = mul(UNITY_MATRIX_MVP, v.vertex);\n                o.uv = v.uv;\n                o.uv.y = 1-o.uv.y;\n                return o;\n            }\n\n            //COORDINATE TRANSFORMATIONS: SCALING\n            fixed4 frag (v2f i) : SV_Target\n            {\n                float2 r = 2.0 * (i.uv - 0.5);\n                float aspectRatio = _ScreenParams.x / _ScreenParams.y;\n                r.x *= aspectRatio;\n\n                fixed3 bgCol = float3(1.0, 1.0, 1.0); // white\n\n                fixed3 col1 = float3(0.216, 0.471, 0.698); // blue\n                fixed3 col2 = float3(1.00, 0.329, 0.298); // red\n                fixed3 col3 = float3(0.867, 0.910, 0.247); // yellow\n\n                fixed3 ret;\n                ret = bgCol;\n\n                // original\n                ret = lerp(ret, col1, coordinateGrid(r)/2.0);\n\n                // scaled\n                float2 q = 0.3*r;\n                ret = lerp(ret, col2, coordinateGrid(q));\n\n                // draw shapes\n                ret = lerp(ret, col2, disk(q, float2(0.0, 0.0), 0.1)); //\u5927\n                ret = lerp(ret, col1, disk(r, float2(0.0, 0.0), 0.1));\n\n                ret = lerp(ret, col1, rectangle(r, float2(-0.5, 0.0),float2(-0.2, 0.2)));\n                ret = lerp(ret, col2, rectangle(q, float2(-0.5, 0.0),float2(-0.2, 0.2))); //\u5927\n\n\n\n                fixed3 pixel = ret;\n                return fixed4(pixel, 1.0);\n            }\n\n\n            ENDCG\n        }\n    }\n}\n\n\n\nPoint\nr\u306b\u4fc2\u6570\u3092\u304b\u3051\u308b\u3053\u3068\u3067\uff0c\u62e1\u5927\u30fb\u7e2e\u5c0f\u3067\u304d\u308b\uff0e(0.3\u3092\u304b\u3051\u308b\u3053\u3068\u3067\uff0c\u5927\u304d\u304f\u306a\u3063\u3066\u3044\u308b\uff0e)\n\n\nTutorial19 Transform\n\nShader \"ShaderTutorial/Tutorial19\"\n{\n    SubShader\n    {\n        // No culling or depth\n        Cull Off ZWrite Off ZTest Always\n\n        // \u8ffd\u52a0\n        CGINCLUDE\n\n        #define PI 3.14159\n\n        // (anti-aliased)Grid\u3092\u4f5c\u308b\u95a2\u6570\n        float coordinateGrid(float2 r){\n            float3 axisCol = float3(0.0, 0.0, 1.0);\n            float3 gridCol = float3(0.5, 0.5, 0.5);\n            float ret = 0.0;\n\n            // Draw grid lines\n            const float tickWidth = 0.1;\n            for(float i= -2.0;i<2.0; i+= tickWidth){\n                ret += 1.0 - smoothstep(0.0, 0.008, abs (r.x - i));\n                ret += 1.0 - smoothstep(0.0, 0.008, abs (r.y - i));\n            }\n\n            // Draw the axis\n            ret += 1.0-smoothstep(0.001, 0.015, abs(r.x));\n            ret += 1.0-smoothstep(0.001, 0.015, abs(r.y));\n            return ret;\n        }\n\n        // returns 1.0 if inside circle\n        float disk(float2 r, float2 center, float radius){\n            return 1.0 - smoothstep( radius - 0.005, radius + 0.005, length(r - center));\n        }\n\n        // returns 1.0 if inside the disk\n        float rectangle(float2 r, float2 bottomLeft, float2 topRight){\n            float ret;\n            float d = 0.005;\n            ret = smoothstep(bottomLeft.x - d, bottomLeft.x + d, r.x);\n            ret *= smoothstep(bottomLeft.y - d, bottomLeft.y + d, r.y);\n            ret *= 1.0 - smoothstep(topRight.y - d, topRight.y + d, r.y);\n            ret *= 1.0 - smoothstep(topRight.x - d, topRight.x + d, r.x);\n            return ret;\n        }\n        ENDCG\n\n\n        Pass\n        {\n            CGPROGRAM\n            #pragma vertex vert\n            #pragma fragment frag\n\n            #include \"UnityCG.cginc\"\n\n            struct appdata\n            {\n                float4 vertex : POSITION;\n                float2 uv : TEXCOORD0;\n            };\n\n            struct v2f\n            {\n                float2 uv : TEXCOORD0;\n                float4 vertex : SV_POSITION;\n            };\n\n            v2f vert (appdata v)\n            {\n                v2f o;\n                o.vertex = mul(UNITY_MATRIX_MVP, v.vertex);\n                o.uv = v.uv;\n                o.uv.y = 1-o.uv.y;\n                return o;\n            }\n\n            //COORDINATE TRANSFORMATIONS\n            fixed4 frag (v2f i) : SV_Target\n            {\n                float2 r = 2.0 * (i.uv - 0.5);\n                float aspectRatio = _ScreenParams.x / _ScreenParams.y;\n                r.x *= aspectRatio;\n\n                fixed3 bgCol = float3(1.0, 1.0, 1.0); // white\n\n                fixed3 col1 = float3(0.216, 0.471, 0.698); // blue\n                fixed3 col2 = float3(1.00, 0.329, 0.298); // red\n                fixed3 col3 = float3(0.867, 0.910, 0.247); // yellow\n\n                fixed3 ret;\n                ret = bgCol;\n\n                float angle = -0.6;\n                float2x2 rotationMatrix = float2x2(cos(angle), -sin(angle),\n                                                sin(angle), cos(angle));\n\n\n                if(i.uv.x < 1.0/2.0) //part1\n                {\n                    //\u5ea7\u6a19\u306e\u4e2d\u5fc3\u3092uv.x: 1/4\u306e\u4f4d\u7f6e\u306b\u3059\u308b\u3002\n                    r = r - float2(-aspectRatio/2.0, 0);\n                    float2 rotated = mul(rotationMatrix, r);\n                    float2 rotatedTranslated = rotated - float2(0.4, 0.5);\n                    ret = lerp(ret, col1, coordinateGrid(r) * 0.3);\n                    ret = lerp(ret, col2, coordinateGrid(rotated)*0.3);\n                    ret = lerp(ret, col3, coordinateGrid(rotatedTranslated)*0.3);\n\n                    ret = lerp(ret, col1, rectangle(r, float2(-0.1, -0.2), float2(0.1, 0.2)));\n                    ret = lerp(ret, col2, rectangle(rotated, float2(-0.1, -0.2), float2(0.1, 0.2)));\n                    ret = lerp(ret, col3, rectangle(rotatedTranslated, float2(-0.1, -0.2), float2(0.1, 0.2)));\n                }\n                else if(i.uv.x < 2.0/2.0){ //part2\n                    //\u5ea7\u6a19\u306e\u4e2d\u5fc3\u3092uv.x: 1/4\u306e\u4f4d\u7f6e\u306b\u3059\u308b\u3002\n                    r = r - float2(aspectRatio/2.0, 0);\n                    float2 translated = r - float2(0.4, 0.5);\n                    float2 translatedRotated = mul(rotationMatrix, translated);\n\n                    ret = lerp(ret, col1, coordinateGrid(r) * 0.3);\n                    ret = lerp(ret, col2, coordinateGrid(translated)*0.3);\n                    ret = lerp(ret, col3, coordinateGrid(translatedRotated)*0.3);\n\n                    ret = lerp(ret, col1, rectangle(r, float2(-0.1, -0.2), float2(0.1, 0.2)));\n                    ret = lerp(ret, col2, rectangle(translated, float2(-0.1, -0.2), float2(0.1, 0.2)));\n                    ret = lerp(ret, col3, rectangle(translatedRotated, float2(-0.1, -0.2), float2(0.1, 0.2)));\n                }\n\n\n\n\n                fixed3 pixel = ret;\n                return fixed4(pixel, 1.0);\n            }\n\n\n            ENDCG\n        }\n    }\n}\n\n\n\nPoint\nfloat2x2\u3067\uff0c2\u304b\u3051\u308b2\u306e\u6b63\u65b9\u884c\u5217\u3092\u793a\u3059\uff0e\u3053\u308c\u306b\u3088\u3063\u3066\u56de\u8ee2\u884c\u5217\u3092\u8868\u73fe\u3057\uff0cmul\u95a2\u6570\u306b\u3088\u3063\u3066\u884c\u5217\u306e\u639b\u3051\u7b97\u3092\u884c\u3063\u3066\u3044\u308b\uff0e\n\n\nTutorial20 Animations\n\nShader \"ShaderTutorial/Tutorial20\"\n{\n    SubShader\n    {\n        // No culling or depth\n        Cull Off ZWrite Off ZTest Always\n\n        // \u8ffd\u52a0\n        CGINCLUDE\n\n        #define PI 3.14159\n\n        // (anti-aliased)Grid\u3092\u4f5c\u308b\u95a2\u6570\n        float coordinateGrid(float2 r){\n            float3 axisCol = float3(0.0, 0.0, 1.0);\n            float3 gridCol = float3(0.5, 0.5, 0.5);\n            float ret = 0.0;\n\n            // Draw grid lines\n            const float tickWidth = 0.1;\n            for(float i= -2.0;i<2.0; i+= tickWidth){\n                ret += 1.0 - smoothstep(0.0, 0.008, abs (r.x - i));\n                ret += 1.0 - smoothstep(0.0, 0.008, abs (r.y - i));\n            }\n\n            // Draw the axis\n            ret += 1.0-smoothstep(0.001, 0.015, abs(r.x));\n            ret += 1.0-smoothstep(0.001, 0.015, abs(r.y));\n            return ret;\n        }\n\n        // returns 1.0 if inside circle\n        float disk(float2 r, float2 center, float radius){\n            return 1.0 - smoothstep( radius - 0.005, radius + 0.005, length(r - center));\n        }\n\n        // returns 1.0 if inside the rect\n        float rectangle(float2 r, float2 bottomLeft, float2 topRight){\n            float ret;\n            float d = 0.005;\n            ret = smoothstep(bottomLeft.x - d, bottomLeft.x + d, r.x);\n            ret *= smoothstep(bottomLeft.y - d, bottomLeft.y + d, r.y);\n            ret *= 1.0 - smoothstep(topRight.y - d, topRight.y + d, r.y);\n            ret *= 1.0 - smoothstep(topRight.x - d, topRight.x + d, r.x);\n            return ret;\n        }\n\n        float mod(float  a, float  b) { return a-b*floor(a/b); } \n        ENDCG\n\n\n        Pass\n        {\n            CGPROGRAM\n            #pragma vertex vert\n            #pragma fragment frag\n\n            #include \"UnityCG.cginc\"\n\n            struct appdata\n            {\n                float4 vertex : POSITION;\n                float2 uv : TEXCOORD0;\n            };\n\n            struct v2f\n            {\n                float2 uv : TEXCOORD0;\n                float4 vertex : SV_POSITION;\n            };\n\n            v2f vert (appdata v)\n            {\n                v2f o;\n                o.vertex = mul(UNITY_MATRIX_MVP, v.vertex);\n                o.uv = v.uv;\n                o.uv.y = 1-o.uv.y;\n                return o;\n            }\n\n            //ANIMATION\n            fixed4 frag (v2f i) : SV_Target\n            {\n                float2 r = 2.0 * (i.uv - 0.5);\n                float aspectRatio = _ScreenParams.x / _ScreenParams.y;\n                r.x *= aspectRatio;\n\n                fixed3 bgCol = float3(1.0, 1.0, 1.0); // white\n\n                fixed3 col1 = float3(0.216, 0.471, 0.698); // blue\n                fixed3 col2 = float3(1.00, 0.329, 0.298); // red\n                fixed3 col3 = float3(0.867, 0.910, 0.247); // yellow\n\n                fixed3 ret;\n                ret = bgCol;\n\n                float angle = -0.6;\n                float2x2 rotationMatrix = float2x2(cos(angle), -sin(angle),\n                                                sin(angle), cos(angle));\n\n\n                if(i.uv.x < 1.0/5.0) // part1\n                {\n                    float2 q = r + float2(aspectRatio*4.0/5.0, 0);\n\n                    ret = fixed3(0.3, 0.3, 0.3);\n                    //\u6642\u9593\u306f_Time.y\u3067\u53d6\u5f97\u3067\u304d\u308b\n                    float y = _Time.y;\n\n                    //y\u3092-1 ~ 1\u306e\u5024\u306b\u3059\u308b\n                    y = mod(y,2.0) -1.0;\n                    ret = lerp(ret, col1, disk(q, float2(0.0, y), 0.1));\n                }\n                else if(i.uv.x < 2.0/5.0) //part2\n                {\n                    float2 q = r + float2(aspectRatio*2.0/5.0, 0);\n                    ret = fixed3(0.4, 0.4, 0.4);\n                    //\u632f\u5e45\n                    float amplitude = 0.8;\n                    float y = 0.8 * sin(0.5*_Time.y* 2.0 * PI);\n                    float radius = 0.15 + 0.05 * sin(_Time.y * 8.0);\n                    ret = lerp(ret, col1, disk(q, float2(0.0, y), radius));\n                }\n                else if(i.uv.x < 3.0/5.0) //part3\n                {\n                    float2 q = r + float2(aspectRatio*0/5.0, 0);\n                    ret = float3(0.5, 0.5, 0.5);\n\n                    float x = 0.2*cos(_Time.y*5.0);\n                    float y = 0.3*sin(_Time.y*5.0);\n                    float radius = 0.2 + 0.1*sin(_Time.y*2.0);\n                    fixed3 color = lerp(col1, col2, sin(_Time.y)*0.5 + 0.5);\n                    ret = lerp(ret, color, rectangle(q, float2(x-0.1, y-0.1), float2(x+0.1, y+0.1)));\n                }\n                else if(i.uv.x < 4.0/5.0) //part4\n                {\n                    float2 q = r + float2(-aspectRatio*2.0/5.0, 0);\n                    ret = float3(0.4, 0.4, 0.4);\n\n                    for(float i=-1.0; i<1.0; i+= 0.2)\n                    {\n                        float x = 0.2 * cos(_Time.y*5.0 + i*PI);\n                        float y = i;\n\n                        float2 s = q - float2(x, y);\n                        float angle = _Time.y * 3.0 + i;\n                        float2x2 rot = float2x2(cos(angle), -sin(angle),\n                                                sin(angle),  cos(angle));\n                        s = mul(rot, s);\n                        ret = lerp(ret, col1, rectangle(s, float2(-0.06, -0.06), float2(0.06, 0.06)));\n                    }\n                }\n                else if(i.uv.x < 5.0/5.0) //part5\n                {\n                    float2 q = r + float2(-aspectRatio*4.0/5.0, 0);\n                    ret = float3(0.3, 0.3, 0.3);\n\n                    float speed = 2.0;\n                    float t = _Time.y * speed;\n                    float stopEveryAngle = PI / 2.0;\n                    float stopRatio = 0.5;\n                    //0.5<frac(t)<1\u306e\u6642,t1\u306f\u4e00\u5b9a\u3068\u306a\u308b\u3002\u305d\u3053\u3067\u6b62\u307e\u3063\u3066\u3044\u308b\u3002\n                    float t1 = (floor(t) + smoothstep(0.0, 1.0 - stopRatio, frac(t)))*stopEveryAngle;\n\n                    float x = -0.2*cos(t1);\n                    float y = 0.3 * sin(t1);\n                    float dx = 0.1 + 0.03 * sin(t*10.0);\n                    float dy = 0.1 + 0.03 * sin(t*10.0+PI);\n                    ret = lerp(ret, col1, rectangle(q, float2(x-dx, y-dy), float2(x+dx, y+dy)));\n\n\n                }\n\n\n                fixed3 pixel = ret;\n                return fixed4(pixel, 1.0);\n            }\n\n\n            ENDCG\n        }\n    }\n}\n\n\n\n\nPoint\n_Time.y\u3067\u6642\u9593\u3092\u53d6\u5f97\u3067\u304d\u308b\uff0e\n\n\nTutorial21 Plasma\n\n//Plasma\nfixed4 frag (v2f i) : SV_Target\n{\n    float2 r = 2.0 * (i.uv - 0.5);\n    float aspectRatio = _ScreenParams.x / _ScreenParams.y;\n    r.x *= aspectRatio;\n    float t = _Time.y;\n    r = r*8.0;\n\n    float v1 = sin(r.x + t);\n    float v2 = sin(r.y + t);\n    float v3 = sin(r.x + r.y + t);\n    float v4 = sin(sqrt(r.x*r.x + r.y*r.y) + 1.7*t);\n    float v = v1 + v2 + v3 + v4;\n    fixed3 ret;\n\n    if(i.uv.x < 1.0 / 10.0) // part1\n    {\n        //vertical waves\n        ret = float3(v1, v1, v1);\n    }\n    else if(i.uv.x < 2.0/10.0) // part2\n    {\n        // horizontal waves;\n        ret = float3(v2, v2, v2);\n    }\n    else if(i.uv.x < 3.0/10.0) // part3\n    {\n        // diagonal waves\n        ret = float3(v3, v3, v3);\n    }\n    else if(i.uv.x < 4.0/10.0) // part4\n    {\n        // circular waves\n        ret = float3(v4, v4, v4);\n    }\n    else if(i.uv.x < 5.0/10.0) // part5\n    {\n        // the sum of all waves\n        ret = float3(v, v, v);\n    }\n    else if(i.uv.x < 6.0/10.0) // part6\n    {\n        // Add periodicity to the gradients\n        ret = float3(sin(2.0 * v), sin(2.0 * v), sin(2.0 * v));\n    }\n    else if(i.uv.x < 10.0/10.0) // part7\n    {\n        // mix colors\n        v *= 1.0;\n        ret = float3(sin(v), sin(v+0.5*PI), sin(v+1.0*PI));\n    }\n\n    ret = 0.5 + 0.5 * ret;\n\n    fixed3 pixel = ret;\n    return fixed4(pixel, 1.0);\n}\n\n\n\nPoint\nsin,cos\u3068_Time.y\u3092\u7d44\u307f\u5408\u308f\u305b\u308b\u3068\u5468\u671f\u7684\u306a\u6a21\u69d8\u304c\u3067\u304d\u308b\uff0e\n\n\n# \u5bfe\u8c61\nShader\u3084\u3063\u3066\u307f\u305f\u3044\u3051\u3069,\u3069\u3046\u52c9\u5f37\u3059\u308c\u3070\u3088\u3044\u304b\u5206\u304b\u3089\u306a\u3044\u4eba\n\n# \u5c0e\u5165\n\u3068\u308a\u3042\u3048\u305a\u52d5\u304b\u3057\u3066\u307f\u308b\n\n1. Create -> Shader -> ImageEffectShader\u9078\u629e\n2. \u30c0\u30d6\u30eb\u30af\u30ea\u30c3\u30af\u3067\u958b\u304d\uff0c\u4e00\u884c\u76ee\u3092`Shader \"ShaderTutorial/Tutorial1\"`\u306b\u3059\u308b\uff0e\n3. Material\u3092\u4f5c\u6210\u3057\uff0cShader\u3092ShaderTutorial -> Tutorial1\u306b\u3059\u308b\uff0e\n4. C#\u30b9\u30af\u30ea\u30d7\u30c8\u3092\u4f5c\u6210\uff0c\u5f8c\u8ff0\u3059\u308b\u30b9\u30af\u30ea\u30d7\u30c8\u3092\u8a18\u5165\n5. \u30b9\u30af\u30ea\u30d7\u30c8\u3092MainCamera\u306b\u30a2\u30bf\u30c3\u30c1\n6. Material\u304c\u306a\u3044!\u3063\u3066\u30a8\u30e9\u30fc\u304c\u51fa\u308b\u306e\u3067\uff0cmaterial\u3092\u30a2\u30bf\u30c3\u30c1\n7. \u7d42\u4e86\n\n\u624b\u98062\n![Create.png](https://qiita-image-store.s3.amazonaws.com/0/113504/518d9c9e-477d-3fe3-ad2a-cc8ddcca404c.png \"Create.png\")\n\n\u624b\u98063\n![MaterialShader.png](https://qiita-image-store.s3.amazonaws.com/0/113504/493f2d71-ca5d-efbf-b5f4-0bcb391337e9.png \"MaterialShader.png\")\n\n\u624b\u98064\n\n```Tutorial1.cs\nusing UnityEngine;\nusing System.Collections;\n\n[ExecuteInEditMode]\npublic class Tutorial1 : MonoBehaviour {\n\n\tpublic Material mat;\n\n\tvoid OnRenderImage(RenderTexture src, RenderTexture dest){\n\t\tGraphics.Blit (src, dest, mat);\n\t}\n}\n```\n\n\u7d50\u679c\n\n\u8272\u304c\u53cd\u8ee2\u3057\u307e\u3059\uff0e\n\n![\u30cd\u30ab\u3099.png](https://qiita-image-store.s3.amazonaws.com/0/113504/58a9dea6-da41-9365-a808-33a8a312d3a3.png \"\u30cd\u30ab\u3099.png\")\n\n\n\u4ee5\u4e0b\u306e\u30c1\u30e5\u30fc\u30c8\u30ea\u30a2\u30eb\u306fShaderToy\u306e\nhttps://www.shadertoy.com/view/Md23DV\n\n\u3053\u306e\u6295\u7a3f\u3092Unity\u3067\u5b9f\u88c5\u3057\u305f\u3082\u306e\u306b\u306a\u308a\u307e\u3059\uff0e\n> \u6570\u5024\u306b\u95a2\u3057\u3066\u306f\uff0cfloat, half, fixed\u306e3\u7a2e\u985e\u304c\u3042\u308a\u307e\u3059\u304c\uff0c\n\u3053\u306e\u30c1\u30e5\u30fc\u30c8\u30ea\u30a2\u30eb\u3067\u306ffixed\u3068float\u306e\u307f\u3092\u4f7f\u7528\u3057\u3066\u3044\u307e\u3059\uff0e\n\n# Github\nhttps://github.com/teach310/ShaderTutorial2D\n\n\n\n\n# Tutorial1\n\n![Tutorial1.png](https://qiita-image-store.s3.amazonaws.com/0/113504/c806ad92-967a-6072-49b7-bdeb15067b14.png \"Tutorial1.png\")\n\n\n```Tutorial1.shader\nShader \"ShaderTutorial/Tutorial1\"\n{\n\tSubShader\n\t{\n\t\t// No culling or depth\n\t\tCull Off ZWrite Off ZTest Always\n\n\t\tPass\n\t\t{\n\t\t\tCGPROGRAM\n\t\t\t#pragma vertex vert\n\t\t\t#pragma fragment frag\n\t\t\t\n\t\t\t#include \"UnityCG.cginc\"\n\n\t\t\tstruct appdata\n\t\t\t{\n\t\t\t\tfloat4 vertex : POSITION;\n\t\t\t\tfloat2 uv : TEXCOORD0;\n\t\t\t};\n\n\t\t\tstruct v2f\n\t\t\t{\n\t\t\t\tfloat2 uv : TEXCOORD0;\n\t\t\t\tfloat4 vertex : SV_POSITION;\n\t\t\t};\n\n\t\t\tv2f vert (appdata v)\n\t\t\t{\n\t\t\t\tv2f o;\n\t\t\t\to.vertex = mul(UNITY_MATRIX_MVP, v.vertex);\n\t\t\t\to.uv = v.uv;\n\t\t\t\treturn o;\n\t\t\t}\n\n\n\t\t\tfixed4 frag (v2f i) : SV_Target\n\t\t\t{\n\t\t\t\treturn fixed4(1.0, 1.0, 0.0, 1.0);\n\t\t\t}\n\t\t\tENDCG\n\t\t}\n\t}\n}\n\n```\n\nfrag\u306e\u4e2d\u8eab\u306b\u6ce8\u76ee\u3057\u3066\u304f\u3060\u3055\u3044.\n\n`fixed4(1.0, 1.0, 0.0, 1.0)`\u304c\u9ec4\u8272\u3092\u793a\u3057\u3066\u3044\u307e\u3059\uff0e\n\u30d1\u30e9\u30e1\u30fc\u30bf\u306f\u305d\u308c\u305e\u308c(Red, Green, Blue, Alpha(\u900f\u660e\u5ea6))\u3092\u793a\u3057\u3066\u3044\u307e\u3059\uff0e\n\n\u5024\u306f0~1.0\u3067\u3059\uff0e\n\n> ## Point\nfrag\u306e\u4e2d\u3067\u8272\u3092return\u3059\u308b\u3053\u3068\u3067\u7d75\u304c\u51fa\u308b\n\n# Tutorial2\n\n![result_tutorial2.png](https://qiita-image-store.s3.amazonaws.com/0/113504/84a9971a-439c-c8f3-5015-6484710e09d3.png \"result_tutorial2.png\")\n\n\u3053\u3053\u304b\u3089\u306f\u30d5\u30e9\u30b0\u30e1\u30f3\u30c8\u30b7\u30a7\u30fc\u30c0\u306e\u307f\u30b9\u30af\u30ea\u30d7\u30c8\u3092\u793a\u3057\u307e\u3059\uff0e\n\n```Tutorial2.shader\nfixed4 frag (v2f i) : SV_Target\n{\n\tfixed3 color = fixed3(0.0, 1.0, 1.0);\n\tfixed alpha = 1.0;\n\n\tfixed4 pixel = fixed4(color, alpha);\n\treturn pixel;\n}\n```\n\n> ## Point\nfixed3\u578b\u306ecolor\u3068fixed\u578b\u306ealpha\u3092\u5408\u4f53\u3057\u3066fixed4\u578b\u306b\u3067\u304d\u308b\uff0e\n\n\n# Tutorial3\n\n![result_tutorial3.png](https://qiita-image-store.s3.amazonaws.com/0/113504/d2bf0b37-2240-54ce-1ca9-9814ff99a7cb.png \"result_tutorial3.png\")\n\n```Tutorial3.shader\nfixed4 frag (v2f i) : SV_Target\n{\n\tfixed redAmount = 0.6;\n\tfixed greenAmount = 0.2;\n\tfixed blueAmount = 0.9;\n\n\tfixed3 color = fixed3(0.0, 0.0, 0.0);\n\tcolor.x = redAmount;\n\tcolor.y = greenAmount;\n\tcolor.z = blueAmount;\n\n\tfixed alpha = 1.0;\n\tfixed4 pixel = fixed4(color, alpha);\n\treturn pixel;\n}\n```\n> ## Point\nfixed3\u306e3\u8981\u7d20\u306b\u306f\uff0ccolor.x\u306e\u3088\u3046\u306b\uff0cxyz\u3067\u30a2\u30af\u30bb\u30b9\u3067\u304d\u308b\uff0e\n\n# Tutorial4\n\n![result_tutorial4.png](https://qiita-image-store.s3.amazonaws.com/0/113504/b279e7fe-1bd6-29c7-c32c-de5b3321ea47.png \"result_tutorial4.png\")\n\n\n\n```Tutorial4.shader\nfixed4 frag (v2f i) : SV_Target\n{\n\tfixed3 color1 = fixed3(0.886, 0.576, 0.898);\n\tfixed3 color2 = fixed3(0.537, 0.741, 0.408);\n\tfixed3 pixel;\n\n\tif(i.uv.x > 0.5){\n\t\tpixel = color2;\n\t} else {\n\t\tpixel = color1;\n\t}\n\n\treturn fixed4(pixel, 1.0);\n}\n```\n\n> ## Point\n\u5f15\u6570\u3067\u3042\u308bi\u3092\u4f7f\u3046\u3053\u3068\u306b\u3088\u308a\uff0c\u73fe\u5728\u51e6\u7406\u3057\u3066\u3044\u308b\u30d4\u30af\u30bb\u30eb\u306euv\u5ea7\u6a19\u3092i.uv\u3067\u53d6\u5f97\u3059\u308b\u3053\u3068\u304c\u3067\u304d\u308b\uff0e\n\u4eca\u56de\u306fi.uv.x > 0.5\u3059\u306a\u308f\u3061\uff0c\u753b\u9762\u3092\u6a2a\u306b\u5206\u65ad\u3059\u308b\u3088\u3046\u306b\u8272\u3092\u5206\u3051\u305f\uff0e\nuv\u5ea7\u6a19\u306ex\u8ef8\u306f\u753b\u9762\u306e\u5de6\u304b\u3089\u4e00\u756a\u53f3\u7aef\u30780~1.0\u3067\u3042\u308b\uff0e\n\n# Tutorial5\n\n![result_Tutorial5.png](https://qiita-image-store.s3.amazonaws.com/0/113504/369ac26e-0c06-ae15-7fbb-538466d0ac98.png \"result_Tutorial5.png\")\n\n```Tutorial5.shader\nfixed4 frag (v2f i) : SV_Target\n{\n\tfixed3 color1 = fixed3(0.886, 0.576, 0.898);\n\tfixed3 color2 = fixed3(0.537, 0.741, 0.408);\n\tfixed3 pixel;\n\n\tfloat dis = 50;\n\n\tif(i.uv.x * _ScreenParams.x > dis){\n\t\tpixel = color2;\n\t} else {\n\t\tpixel = color1;\n\t}\n\n\treturn fixed4(pixel, 1.0);\n}\n```\n\n> ## Point\nuv\u5ea7\u6a19\u306b\uff0c\u30b9\u30af\u30ea\u30fc\u30f3\u306e\u89e3\u50cf\u5ea6(_ScreenParams)\u3092\u639b\u3051\u7b97\u3059\u308b\u3053\u3068\u3067\uff0c\u73fe\u5728\u51e6\u7406\u3057\u3066\u3044\u308b\u30d4\u30af\u30bb\u30eb\u306e\u4f4d\u7f6e\u3092\u53d6\u5f97\u3067\u304d\u308b\uff0e\n\n# Tutorial6 \u7dda\u306e\u5f15\u304d\u65b9\n![result_tutorial6.png](https://qiita-image-store.s3.amazonaws.com/0/113504/ca0123df-c167-f64a-0423-d16c4e642d24.png \"result_tutorial6.png\")\n\n\n```Tutorial6.shader\n// HORIZONTAL AND VERTICAL LINES\nfixed4 frag (v2f i) : SV_Target\n{\n\tfixed3 backgroundColor = fixed3(1.0, 1.0, 1.0);\n\tfixed3 color1 = fixed3(0.216, 0.471, 0.698); // blue\n\tfixed3 color2 = fixed3(1.00, 0.329, 0.298); // red\n\tfixed3 color3 = fixed3(0.867, 0.910, 0.247); // yellow\n\n\tfixed3 pixel = backgroundColor;\n\n\t// line1\n\tfloat leftCoord = 0.54;\n\tfloat rightCoord = 0.55;\n\tif(i.uv.x < rightCoord && i.uv.x > leftCoord) pixel = color1;\n\n\t// line2\n\tfloat lineCoordinate = 0.4;\n\tfloat lineThickness = 0.003;\n\tif(abs(i.uv.x - lineCoordinate) < lineThickness ) pixel = color2;\n\n\t// line3\n\tif(abs(i.uv.y - 0.6) < 0.01) pixel = color3;\n\n\treturn fixed4(pixel, 1.0);\n}\n```\n\n> ## Point\n\u7dda\u306e\u5f15\u304d\u65b9\u306b\u306f2\u7a2e\u985e\u3042\u308a\uff0c\u4e00\u3064\u76ee\u306f\u7dda\u306e\u7aef\u306e\u5ea7\u6a19\u3092\u793a\u3059\u65b9\u6cd5(line1)\uff0e\u4e8c\u3064\u76ee\u306f\u7dda\u306e\u4e2d\u5fc3\u306e\u5ea7\u6a19\u3068\u539a\u3055\u3092\u793a\u3059\u65b9\u6cd5\u3067\u3042\u308b(line2,3)\n\u5f8c\u8005\u306e\u5834\u5408\u306b\u306f`if(abs(i.uv.x - lineCoordinate) < lineThickness )`\u3067\u8868\u305b\u308b\uff0e\n\n# \u3082\u3057\u4e0a\u4e0b\u304c\u53cd\u8ee2\u3057\u3066\u3044\u305f\u3089\n```\nv2f vert(appdata v)\n{\n\tv2f o;\n\to.vertex = mul(UNITY_MATRIX_MVP, v.vertex);\n\to.uv = v.uv;\n\to.uv.y = 1-o.uv.y; //\u3053\u306e\u884c\u3092\u52a0\u3048\u308b\uff0e\n\treturn o;\n}\n```\n\n# Tutorial7  \u5ea7\u6a19\u306e\u8996\u899a\u5316\n\n![result_tutorial7.png](https://qiita-image-store.s3.amazonaws.com/0/113504/0478a1b4-08aa-01ae-56df-92b375067471.png \"result_tutorial7.png\")\n\n\n```Tutorial7.shader\n// VISUALISING THE COORDINATE SYSTEM\nfixed4 frag (v2f i) : SV_Target\n{\n\tfixed3 backgroundColor = fixed3(1.0, 1.0, 1.0);\n\tfixed3 axesColor = fixed3(0.0, 0.0, 1.0);\n\tfixed3 gridColor = fixed3(0.5, 0.5, 0.5);\n\n\tfixed3 pixel = backgroundColor;\n\n\tconst float tickWidth = 0.1;\n\tfor(float lc=0.0; lc< 1.0; lc+=tickWidth){\n\t\tif(abs(i.uv.x - lc) < 0.002) pixel = gridColor;\n\t\tif(abs(i.uv.y - lc) < 0.002) pixel = gridColor;\n\t}\n\n\t// Draw the axes\n\tif(abs(i.uv.x)<0.005) pixel = axesColor;\n\tif(abs(i.uv.y)<0.006) pixel = axesColor;\n\n\treturn fixed4(pixel, 1.0);\n}\n```\n\n> ## Point\nfor\u6587\u3067\u7dda\u3092\u5f15\u304f\u5ea7\u6a19\u3092\u5909\u3048\u308b\u3053\u3068\u3067\uff0c\u7b49\u9593\u9694\u306b\u7dda\u3092\u5f15\u304f\u3053\u3068\u304c\u3067\u304d\u308b\uff0e\n\n# Tutorial8 \u5ea7\u6a19\u3000\u8ef8\u4e2d\u5fc3\n\n![result_tutorial8.png](https://qiita-image-store.s3.amazonaws.com/0/113504/06b94e07-ab11-1f84-8dc9-3784d694b21d.png \"result_tutorial8.png\")\n\n\nfrag\u306e\u5916\u306b\u3082\u8a18\u5165\u3057\u305f\u305f\u3081\uff0c\u5168\u6587\n```Tutorial8.shader\nShader \"ShaderTutorial/Tutorial8\"\n{\n\tSubShader\n\t{\n\t\t// No culling or depth\n\t\tCull Off ZWrite Off ZTest Always\n\n\t\t// \u8ffd\u52a0\n\t\tCGINCLUDE\n\t\tfloat mod(float  a, float  b) { return a-b*floor(a/b); } \n\t\tENDCG\n\n\n\t\tPass\n\t\t{\n\t\t\tCGPROGRAM\n\t\t\t#pragma vertex vert\n\t\t\t#pragma fragment frag\n\t\t\t\n\t\t\t#include \"UnityCG.cginc\"\n\n\t\t\tstruct appdata\n\t\t\t{\n\t\t\t\tfloat4 vertex : POSITION;\n\t\t\t\tfloat2 uv : TEXCOORD0;\n\t\t\t};\n\n\t\t\tstruct v2f\n\t\t\t{\n\t\t\t\tfloat2 uv : TEXCOORD0;\n\t\t\t\tfloat4 vertex : SV_POSITION;\n\t\t\t};\n\n\t\t\tv2f vert (appdata v)\n\t\t\t{\n\t\t\t\tv2f o;\n\t\t\t\to.vertex = mul(UNITY_MATRIX_MVP, v.vertex);\n\t\t\t\to.uv = v.uv;\n\t\t\t\treturn o;\n\t\t\t}\n\n\t\t\t// MOVING THE COORDINATE CENTER TO THE CENTER OF THE FRAME\n\t\t\tfixed4 frag (v2f i) : SV_Target\n\t\t\t{\n\t\t\t\tfixed2 r = 2.0 * fixed2(i.uv.x - 0.5, i.uv.y - 0.5);\n\t\t\t\tfixed3 backgroundColor = fixed3(1.0, 1.0, 1.0);\n\t\t\t\tfixed3 axesColor = fixed3(0.0, 0.0, 1.0);\n\t\t\t\tfixed3 gridColor = fixed3(0.5, 0.5, 0.5);\n\n\t\t\t\tfixed3 pixel = backgroundColor;\n\n\t\t\t\tconst float tickWidth = 0.1;\n\t\t\t\tif( mod(r.x, tickWidth) < 0.008 ) pixel = gridColor;\n\t\t\t\tif( mod(r.y, tickWidth) < 0.008 ) pixel = gridColor;\n\n\t\t\t\t// Draw the axes\n\t\t\t\tif(abs(r.x)<0.006) pixel = axesColor;\n\t\t\t\tif(abs(r.y)<0.007) pixel = axesColor;\n\n\t\t\t\treturn fixed4(pixel, 1.0);\n\t\t\t}\n\n\n\t\t\tENDCG\n\t\t}\n\t}\n}\n```\n\n> ## Point\n\u81ea\u524d\u306e\u95a2\u6570\u3092Pass\u306e\u5916\u5074\u306b\uff0cCGINCLUDE ~ ENDCG \u306e\u9593\u306b\u8a18\u8ff0\u3057\u3066\u3044\u308b\uff0e\n\u3053\u306emod\u95a2\u6570\u306fa\u3092b\u3067\u5272\u3063\u305f\u4f59\u308a\u3092\u8fd4\u3059\u95a2\u6570\u3067\u3042\u308b\uff0e\n\u3053\u308c\u3092\u4f7f\u3046\u3053\u3068\u3067\uff0c\nif(r.x\u3092tickWidth\u3067\u5272\u3063\u305f\u4f59\u308a < 0.008) \u30b0\u30ea\u30c3\u30c9\u306e\u8272\u306b\u3059\u308b\uff0e\n\u3068\u3059\u308b\u3053\u3068\u304c\u3067\u304d\u3066\u3044\u308b\uff0e\n\n\u307e\u305f\uff0ci.uv.x\u304c0~1\u306e\u5024\u3092\u3068\u308b\u306e\u306b\u5bfe\u3057\uff0c-0.5\u3057\u305f\u3082\u306e\u30922\u500d\u3059\u308b\u3053\u3068\u306b\u3088\u3063\u3066\nr\uff0c\u753b\u9762\u306e\u9818\u57df\u3092-1 ~ 1\u3067\u8868\u3059\u3053\u3068\u304c\u3067\u304d\u308b\uff0e\n\n# Tutorial9 \u7e26\u6a2a\u6bd4\u306b\u3042\u308f\u305b\u308b\n![result_tutorial9.png](https://qiita-image-store.s3.amazonaws.com/0/113504/530687a9-96a3-f1fd-0654-f72732861dd1.png \"result_tutorial9.png\")\n\n```Tutorial9.shader\n// MAKING THE ASPECT RATIO OF THE COORDINATE SYSTEM 1.0\nfixed4 frag (v2f i) : SV_Target\n{\n\tfloat2 r = 2.0 * (i.uv - 0.5);\n\tfloat aspectRatio = _ScreenParams.x / _ScreenParams.y;\n\tr.x *= aspectRatio;\n\n\tfixed3 backgroundColor = fixed3(1.0, 1.0, 1.0);\n\tfixed3 axesColor = fixed3(0.0, 0.0, 1.0);\n\tfixed3 gridColor = fixed3(0.5, 0.5, 0.5);\n\n\tfixed3 pixel = backgroundColor;\n\n\tconst float tickWidth = 0.2;\n\tif( mod(r.x, tickWidth) < 0.008 ) pixel = gridColor;\n\tif( mod(r.y, tickWidth) < 0.008 ) pixel = gridColor;\n\n\t// Draw the axes\n\tif(abs(r.x)<0.006) pixel = axesColor;\n\tif(abs(r.y)<0.007) pixel = axesColor;\n\n\treturn fixed4(pixel, 1.0);\n}\n```\n\n> ## Point\nr.x\u306b_ScreenParams\u304b\u3089\u6c42\u3081\u305faspectRatio\u3092\u639b\u3051\u7b97\u3059\u308b\u3053\u3068\u3067\uff0c\u7e26\u6a2a\u306e\u76ee\u76db\u308a\u304c\u540c\u3058\u9577\u3055\u306b\u306a\u308b\uff0e\n\n# Tutorial10 DISK\n![result_tutorial10.PNG](https://qiita-image-store.s3.amazonaws.com/0/113504/1d9f10fe-7402-87d2-a7f3-e108dba2acc7.png \"result_tutorial10.PNG\")\n\n```Tutorial10.shader\n// Draw Disks\nfixed4 frag (v2f i) : SV_Target\n{\n\tfloat2 r = 2.0 * (i.uv - 0.5);\n\tfloat aspectRatio = _ScreenParams.x / _ScreenParams.y;\n\tr.x *= aspectRatio;\n\n\tfixed3 backgroundColor = fixed3(1.0, 1.0, 1.0);\n\tfixed3 col1 = fixed3(0.216, 0.471, 0.698); // blue\n\tfixed3 col2 = fixed3(1.00, 0.329, 0.298); // red\n\tfixed3 col3 = fixed3(0.867, 0.910, 0.247); // yellow\n\n\tfixed3 pixel = backgroundColor;\n\t\n\t//Disk1 blue\n\tfloat radius = 0.8;\n\tif(r.x*r.x + r.y*r.y < radius*radius){\n\t\tpixel = col1;\n\t}\n\t\n\t//Disk2 red\n\tif(length(r) < 0.3){\n\t\tpixel = col3;\n\t}\n\t\n\t//Disk3 yellow\n\tfloat2 center = fixed2(0.9, -0.4);\n\tfloat2 d = r - center;\n\tif( length(d) < 0.6){\n\t\tpixel = col2;\n\t}\n\n\treturn fixed4(pixel, 1.0);\n}\n```\n\n> ## Point\nDisk1\u3067\u306f\uff0c2\u70b9\u9593\u306e\u8ddd\u96e2\u6c42\u3081\u308b\u516c\u5f0f\u30922\u4e57\u3059\u308b\u3053\u3068\u3067\uff0c\u534a\u5f840.8\u4ee5\u5185\u3092\u5857\u308b\u3068\u3044\u3046\u51e6\u7406\u3092\u884c\u3063\u3066\u3044\u308b\uff0e\nDisk2\u3067\u306f\uff0c\u30d9\u30af\u30c8\u30eb\u306e\u8ddd\u96e2\u3092\u6c42\u3081\u308blength\u95a2\u6570\u3092\u7528\u3044\u308b\u3053\u3068\u3067\uff0c\u77ed\u304f\u66f8\u3044\u3066\u3044\u308b\uff0e\nDisk3\u3067\u306f\uff0c\u79fb\u52d5\u3055\u305b\u305f\u3044\u5206\u3060\u3051\u5f15\u304d\u7b97\u3059\u308b\u3053\u3068\u306b\u3088\u3063\u3066\u5186\u306e\u4e2d\u5fc3\u4f4d\u7f6e\u3092\u79fb\u52d5\u3057\u3066\u3044\u308b\uff0e\n\u4f8b\uff1a\u3000\n```math\ny = (x-3)^2\n```\n\u3060\u3068\uff0c\u7dda\u304cx\u8ef8\u6b63\u306e\u65b9\u5411\u306b3\u79fb\u52d5\u3059\u308b\uff0e\n\n\n# Tutorial11 Function\u3092\u4f5c\u308b\n\n![result_tutorial11.PNG](https://qiita-image-store.s3.amazonaws.com/0/113504/eb6cb3d0-31be-e884-baf1-2d6875741976.png \"result_tutorial11.PNG\")\n\n```Tutorial11.shader\nShader \"ShaderTutorial/Tutorial11\"\n{\n\tSubShader\n\t{\n\t\t// No culling or depth\n\t\tCull Off ZWrite Off ZTest Always\n\n\t\t// \u8ffd\u52a0\n\t\tCGINCLUDE\n\t\tfixed3 disk(fixed2 r, fixed2 center, fixed radius, fixed3 color, fixed3 pixel){\n\t\t\tfixed3 col = pixel;\n\t\t\tif(length(r - center) < radius){\n\t\t\t\tcol = color;\n\t\t\t}\n\t\t\treturn col;\n\t\t}\n\t\tENDCG\n\n\n\t\tPass\n\t\t{\n\t\t\tCGPROGRAM\n\t\t\t#pragma vertex vert\n\t\t\t#pragma fragment frag\n\t\t\t\n\t\t\t#include \"UnityCG.cginc\"\n\n\t\t\tstruct appdata\n\t\t\t{\n\t\t\t\tfloat4 vertex : POSITION;\n\t\t\t\tfloat2 uv : TEXCOORD0;\n\t\t\t};\n\n\t\t\tstruct v2f\n\t\t\t{\n\t\t\t\tfloat2 uv : TEXCOORD0;\n\t\t\t\tfloat4 vertex : SV_POSITION;\n\t\t\t};\n\n\t\t\tv2f vert (appdata v)\n\t\t\t{\n\t\t\t\tv2f o;\n\t\t\t\to.vertex = mul(UNITY_MATRIX_MVP, v.vertex);\n\t\t\t\to.uv = v.uv;\n\t\t\t\to.uv.y = 1-o.uv.y;\n\t\t\t\treturn o;\n\t\t\t}\n\n\t\t\t// Functions\n\t\t\tfixed4 frag (v2f i) : SV_Target\n\t\t\t{\n\t\t\t\tfloat2 r = 2.0 * (i.uv - 0.5);\n\t\t\t\tfloat aspectRatio = _ScreenParams.x / _ScreenParams.y;\n\t\t\t\tr.x *= aspectRatio;\n\n\t\t\t\tfixed3 backgroundColor = fixed3(0.3, 0.3, 0.3);\n\t\t\t\tfixed3 col1 = fixed3(0.216, 0.471, 0.698); // blue\n\t\t\t\tfixed3 col2 = fixed3(1.00, 0.329, 0.298); // red\n\t\t\t\tfixed3 col3 = fixed3(0.867, 0.910, 0.247); // yellow\n\n\t\t\t\tfixed3 pixel = backgroundColor;\n\t\t\t\t\n\t\t\t\tpixel = disk(r, fixed2(0.1, 0.3), 0.5, col3, pixel);\n\t\t\t\tpixel = disk(r, fixed2(-0.8, -0.6), 1.5, col1, pixel);\n\t\t\t\tpixel = disk(r, fixed2(0.8, 0.0), 0.15, col2, pixel);\n\n\n\t\t\t\treturn fixed4(pixel, 1.0);\n\t\t\t}\n\n\n\t\t\tENDCG\n\t\t}\n\t}\n}\n```\n\n> ## Point\n\u95a2\u6570\u306fCGINCLUDE ~ ENDCG\u5185\u306b\u8a18\u8ff0\uff0e\nreturn\u6587\u304c\u4f7f\u3048\u308b\uff0e\n\n\n# Tutorial12 STEP\n\n![result_tutorial12.PNG](https://qiita-image-store.s3.amazonaws.com/0/113504/fbc6a499-86b3-aacc-3019-cdb600ea1664.png \"result_tutorial12.PNG\")\n\n```Tutorial12.shader\n// BUILT-IN FUNCTION: STEP\nfixed4 frag (v2f i) : SV_Target\n{\n\tfloat2 r = 2.0 * (i.uv - 0.5);\n\tfloat aspectRatio = _ScreenParams.x / _ScreenParams.y;\n\tr.x *= aspectRatio;\n\n\tfixed3 backgroundColor = fixed3(0.0, 0.0, 0.0); // black\n\tfixed3 col1 = fixed3(0.216, 0.471, 0.698); // blue\n\tfixed3 col2 = fixed3(1.00, 0.329, 0.298); // red\n\tfixed3 col3 = fixed3(0.867, 0.910, 0.247); // yellow\n\n\tfixed3 pixel = backgroundColor;\n\t\n\tfloat edge, variable, ret;\n\n\t// divide the screen into five parts horizontally\n\t// for different examples\n\tif(r.x < -0.6 * aspectRatio){ // part1\n\t\tvariable = r.y;\n\t\tedge = 0.2;\n\t\tif( variable > edge ){\n\t\t\tret = 1.0;\n\t\t}else{\n\t\t\tret = 0.0;\n\t\t}\n\t}\n\telse if(r.x < -0.2 * aspectRatio){ //part2\n\t\tvariable = r.y;\n\t\tedge = -0.2;\n\t\t// part1\u3068\u540c\u3058\u3053\u3068\n\t\tret = step(edge, variable); \n\t}\n\telse if(r.x < 0.2 * aspectRatio){\n\t\t// 1.0 - step(a,b) \u3067\u53cd\u8ee2\n\t\tret = 1.0 - step(0.5, r.y); \n\t}\n\telse if(r.x < 0.6 * aspectRatio){\n\t\t// r.y\u304c-0.4\u4ee5\u4e0a\u3067ret\u306f0.3 + 0.5 = 0.8\n\t\tret = 0.3 + 0.5 * step(-0.4, r.y);  \n\t}\n\telse{\n\t\t// step\u3092\u4e8c\u3064\u4f7f\u3046\u3053\u3068\u3067gap\u3092\u751f\u307f\u51fa\u3059\u3053\u3068\u304c\u3067\u304d\u308b\n\t\tret = step(-0.3, r.y) * (1.0 - step(0.2, r.y)); \n\t}\n\n\tpixel = fixed3 (ret, ret, ret);\n\treturn fixed4(pixel, 1.0);\n}\n```\n\n> ## Point\n|\u540d\u524d|\u8aac\u660e|\n|:--|:--|\n|step(a,b)|b\u304ca\u3092\u3088\u308a\u5927\u304d\u3051\u308c\u30701, \u305d\u3046\u3067\u306a\u3051\u308c\u30700|\n\n# Tutorial13\n\n![result_tutorial13.png](https://qiita-image-store.s3.amazonaws.com/0/113504/e262df80-9da0-a707-2882-1babea68178a.png \"result_tutorial13.png\")\n\n\n```Tutorial13.shader\nShader \"ShaderTutorial/Tutorial13\"\n{\n\tSubShader\n\t{\n\t\t// No culling or depth\n\t\tCull Off ZWrite Off ZTest Always\n\n\t\t// \u8ffd\u52a0\n\t\tCGINCLUDE\n\t\t#define PI 3.14159\n\t\tENDCG\n\n\n\t\tPass\n\t\t{\n\t\t\tCGPROGRAM\n\t\t\t#pragma vertex vert\n\t\t\t#pragma fragment frag\n\t\t\t\n\t\t\t#include \"UnityCG.cginc\"\n\n\t\t\tstruct appdata\n\t\t\t{\n\t\t\t\tfloat4 vertex : POSITION;\n\t\t\t\tfloat2 uv : TEXCOORD0;\n\t\t\t};\n\n\t\t\tstruct v2f\n\t\t\t{\n\t\t\t\tfloat2 uv : TEXCOORD0;\n\t\t\t\tfloat4 vertex : SV_POSITION;\n\t\t\t};\n\n\t\t\tv2f vert (appdata v)\n\t\t\t{\n\t\t\t\tv2f o;\n\t\t\t\to.vertex = mul(UNITY_MATRIX_MVP, v.vertex);\n\t\t\t\to.uv = v.uv;\n\t\t\t\to.uv.y = 1-o.uv.y;\n\t\t\t\treturn o;\n\t\t\t}\n\n\t\t\t// BUILT-IN FUNCTION: CLAMP\n\t\t\tfixed4 frag (v2f i) : SV_Target\n\t\t\t{\n\t\t\t\tfloat2 r = 2.0 * (i.uv - 0.5);\n\t\t\t\tfloat aspectRatio = _ScreenParams.x / _ScreenParams.y;\n\t\t\t\tr.x *= aspectRatio;\n\n\t\t\t\tfixed3 backgroundColor = fixed3(0.0, 0.0, 0.0); // black\n\t\t\t\tfixed3 col1 = fixed3(0.216, 0.471, 0.698); // blue\n\t\t\t\tfixed3 col2 = fixed3(1.00, 0.329, 0.298); // red\n\t\t\t\tfixed3 col3 = fixed3(0.867, 0.910, 0.247); // yellow\n\n\t\t\t\tfixed3 pixel = backgroundColor;\n\t\t\t\t\n\t\t\t\tfloat edge, variable, ret;\n\n\t\t\t\t// divide the screen into four parts horizontally\n\t\t\t\t// for different examples\n\t\t\t\tif(i.uv.x < 0.25){ // part1\n\t\t\t\t\tret = i.uv.y;\n\t\t\t\t}\n\t\t\t\telse if(i.uv.x < 0.5){ // part2\n\t\t\t\t\tfloat minVal = 0.3;\n\t\t\t\t\tfloat maxVal = 0.6;\n\t\t\t\t\tvariable = i.uv.y;\n\t\t\t\t\tif (variable < minVal){\n\t\t\t\t\t\tret = minVal;\n\t\t\t\t\t}\n\t\t\t\t\tif( variable > minVal && variable < maxVal){\n\t\t\t\t\t\tret = variable;\n\t\t\t\t\t}\n\t\t\t\t\tif( variable > maxVal ){\n\t\t\t\t\t\tret = maxVal;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if(i.uv.x < 0.75){ // part3\n\t\t\t\t\tfloat minVal = 0.6;\n\t\t\t\t\tfloat maxVal = 0.8;\n\t\t\t\t\tvariable = i.uv.y;\n\t\t\t\t\tret = clamp(variable, minVal, maxVal);\n\t\t\t\t}\n\t\t\t\telse { // part4\n\t\t\t\t\tfloat y = cos(5.0 * 2.0 * PI *i.uv.y);\n\t\t\t\t\ty = (y+1.0)*0.5; // map [-1,1] to [0,1]\n\t\t\t\t\tret = clamp(y, 0.2, 0.8);\n\t\t\t\t}\n\n\t\t\t\tpixel = fixed3 (ret, ret, ret);\n\t\t\t\treturn fixed4(pixel, 1.0);\n\t\t\t}\n\n\n\t\t\tENDCG\n\t\t}\n\t}\n}\n```\n\n> ## Point\n|\u540d\u524d|\u8aac\u660e|\n|:--|:--|\n|float Clamp(float a,float min,float max)|a\u304cmin\u3088\u308a\u3082\u5c0f\u3055\u3051\u308c\u3070min, a\u304cmax\u3088\u308a\u3082\u5927\u304d\u3051\u308c\u3070max, \u305d\u308c\u4ee5\u5916\u3067\u3042\u308c\u3070a\u3092\u8fd4\u3059|\n\n# Tutorial14 smoothstep\n\n![result_tutorial14.png](https://qiita-image-store.s3.amazonaws.com/0/113504/e87f15a5-4324-1477-bfdc-0f4de98ab4ee.png \"result_tutorial14.png\")\n\n\n```Tutorial14.shader\n// BUILT-IN FUNCTION: SMOOTHSTEP\nfixed4 frag (v2f i) : SV_Target\n{\n\tfixed3 backgroundColor = fixed3(0.0, 0.0, 0.0); // black\n\tfixed3 col1 = fixed3(0.216, 0.471, 0.698); // blue\n\tfixed3 col2 = fixed3(1.00, 0.329, 0.298); // red\n\tfixed3 col3 = fixed3(0.867, 0.910, 0.247); // yellow\n\n\tfixed3 pixel = backgroundColor;\n\t\n\tfloat edge, variable, ret;\n\n\t// divide the screen into five parts horizontally\n\t// for different examples\n\tif(i.uv.x < 1.0/5.0){ // part1\n\t\tedge = 0.5;\n\t\tret = step(edge, i.uv.y);\n\t}\n\telse if(i.uv.x < 2.0/5.0){ // part2\n\t\tfloat edge0 = 0.45;\n\t\tfloat edge1 = 0.55;\n\t\tfloat t = (i.uv.y - edge0) / (edge1 - edge0);\n\t\t//when i.uv.y == edge0 => t = 0.0\n\t\t//when i.uv.y == edge1 => t = 1.0\n\t\t//0\u304b\u30891\u306b\u7dda\u5f62\u306b\u9077\u79fb\u3059\u308b\n\t\tfloat t1 = clamp(t, 0.0, 1.0);\n\t\t//edge0 \u672a\u6e80\u306e\u6642\u306f \u30de\u30a4\u30ca\u30b9\u306e\u5024\u3092\u3068\u308a\uff0c\n\t\t//edge1 \u3088\u308a\u5927\u304d\u3044\u6642\u306f1.0\u3088\u308a\u5927\u304d\u3044\u5024\u3092\u3068\u308b\uff0e\n\t\t//\u3057\u304b\u3057\uff0c0~1\u306e\u5024\u304c\u307b\u3057\u3044\u306e\u3067clamp\u3092\u4f7f\u3044\u307e\u3059\n\t\tret = t1;\n\t}\n\telse if(i.uv.x < 3.0/ 5.0){ // part3\n\t\tfloat edge0 = 0.45;\n\t\tfloat edge1 = 0.55;\n\t\tfloat t = clamp((i.uv.y - edge0)/(edge1 - edge0), 0.0, 1.0);\n\t\tfloat t1 = 3.0*t*t - 2.0*t*t*t;\n\t\t//\u7dda\u5f62\u3067\u306a\u304f\u306a\u3081\u3089\u304b\u306b\u3059\u308b\uff0e\n\t\tret = t1;\n\t}\n\telse if(i.uv.x < 4.0/5.0){ // part4\n\t\tret = smoothstep(0.45, 0.55, i.uv.y);\n\t}\n\telse if(i.uv.x < 5.0/5.0){\n\t\tfloat edge0 = 0.45;\n\t\tfloat edge1 = 0.55;\n\t\tfloat t = clamp((i.uv.y - edge0)/(edge1 - edge0), 0.0, 1.0);\n\t\tfloat t1 = t*t*t*(t*(t*6.0 - 15.0) + 10.0);\n\t\tret = t1;\n\t}\n\n\n\tpixel = fixed3 (ret, ret, ret);\n\treturn fixed4(pixel, 1.0);\n}\n```\n\n> ## Point\n|\u540d\u524d|\u8aac\u660e|\n|:--|:--|\n|float smoothstep(float min, float max, float a)|a\u304cmin\u3068max\u306e\u9593\u306e\u6642\u306b\uff0c\u7dda\u5f62\u3067\u306a\u304f\uff0c\u306a\u3081\u3089\u304b\u306b\u88dc\u5b8c\u3059\u308b\u3088\u3046\u306a\u5024\u3092\u8fd4\u3059\uff0emin\u4ee5\u4e0b\u3067\u3042\u308c\u30700,max\u4ee5\u4e0a\u30671|\n\n# Tutorial15 lerp\n\n![result_tutorial15.png](https://qiita-image-store.s3.amazonaws.com/0/113504/c50753ee-40d0-51f7-9b58-3c665500de58.png \"result_tutorial15.png\")\n\n```Tutorial15.shader\n// BUILT-IN FUNCTION: LERP\nfixed4 frag (v2f i) : SV_Target\n{\n\n\tfixed3 backgroundColor = fixed3(0.0, 0.0, 0.0); // black\n\tfixed3 col1 = fixed3(0.216, 0.471, 0.698); // blue\n\tfixed3 col2 = fixed3(1.00, 0.329, 0.298); // red\n\tfixed3 col3 = fixed3(0.867, 0.910, 0.247); // yellow\n\n\tfixed3 pixel = backgroundColor;\n\t\n\tfixed3 ret;\n\n\t// divide the screen into five parts horizontally\n\t// for different examples\n\tif(i.uv.x < 1.0/5.0){ // part1\n\t\tfloat x0 = 0.2;\n\t\tfloat x1 = 0.7;\n\t\tfloat m = 0.1;\n\t\tfloat val = x0 * (1.0-m) + x1*m;\n\t\tret = fixed3(val, val, val);\n\t}\n\telse if(i.uv.x < 2.0/5.0){ // part2\n\t\tfloat x0 = 0.2;\n\t\tfloat x1 = 0.7;\n\t\tfloat m = i.uv.y;\n\t\tfloat val = x0*(1.0-m) + x1*m;\n\t\tret = fixed3(val, val, val);\n\t}\n\telse if(i.uv.x < 3.0/ 5.0){ // part3\n\t\tfloat x0 = 0.2;\n\t\tfloat x1 = 0.7;\n\t\tfloat m = i.uv.y;\n\t\tfloat val = lerp(x0, x1, m);\n\t\tret = fixed3(val, val, val);\n\n\t}\n\telse if(i.uv.x < 4.0/5.0){ // part4\n\t\tfloat m = i.uv.y;\n\t\tret = lerp(col1, col2, m);\n\t}\n\telse if(i.uv.x < 5.0/5.0){\n\t\t//smoothstep\u3068lerp\u3092\u4f7f\u3063\u305f\u8272\u306e\u9077\u79fb\n\t\tfloat m = smoothstep(0.5, 0.6, i.uv.y);\n\t\tret = lerp(col1, col2, m);\n\t}\n\n\n\tpixel = ret;\n\treturn fixed4(pixel, 1.0);\n}\n```\n> ## Point\n|\u540d\u524d|\u8aac\u660e|\n|:--|:--|\n|float lerp(a,b,s)|a+s(b-a)\u3092\u8fd4\u3059\uff0ea\u304b\u3089b\u3078\u306e\u7dda\u5f62\u88dc\u5b8c s\u306f\u57fa\u672c0~1\u3067\u4f7f\u3046|\n\n# Tutorial16 COLOR ADDITION AND SUBSTRCTION\n![result_tutorial16.png](https://qiita-image-store.s3.amazonaws.com/0/113504/2c725327-8411-1ce5-b068-83ca30277ad9.png \"result_tutorial16.png\")\n\n```Tutorial16.shader\nShader \"ShaderTutorial/Tutorial18\"\n{\n\tSubShader\n\t{\n\t\t// No culling or depth\n\t\tCull Off ZWrite Off ZTest Always\n\n\t\t// \u8ffd\u52a0\n\t\tCGINCLUDE\n\t\t// \u306a\u3081\u3089\u304b\u306aDISK\n\t\tfloat disk(float2 r, float2 center, float radius){\n\t\t\tfloat distanceFromCenter = length(r - center);\n\t\t\tfloat outsideOfDisk = smoothstep(radius - 0.005, radius + 0.005, distanceFromCenter);\n\t\t\tfloat insideOfDisk = 1.0 - outsideOfDisk;\n\t\t\treturn insideOfDisk;\n\n\t\t}\n\t\tENDCG\n\n\n\t\tPass\n\t\t{\n\t\t\tCGPROGRAM\n\t\t\t#pragma vertex vert\n\t\t\t#pragma fragment frag\n\t\t\t\n\t\t\t#include \"UnityCG.cginc\"\n\n\t\t\tstruct appdata\n\t\t\t{\n\t\t\t\tfloat4 vertex : POSITION;\n\t\t\t\tfloat2 uv : TEXCOORD0;\n\t\t\t};\n\n\t\t\tstruct v2f\n\t\t\t{\n\t\t\t\tfloat2 uv : TEXCOORD0;\n\t\t\t\tfloat4 vertex : SV_POSITION;\n\t\t\t};\n\n\t\t\tv2f vert (appdata v)\n\t\t\t{\n\t\t\t\tv2f o;\n\t\t\t\to.vertex = mul(UNITY_MATRIX_MVP, v.vertex);\n\t\t\t\to.uv = v.uv;\n\t\t\t\to.uv.y = 1-o.uv.y;\n\t\t\t\treturn o;\n\t\t\t}\n\n\t\t\t// ANTI-ALIASING WITH SMOOTHSTEP\n\t\t\tfixed4 frag (v2f i) : SV_Target\n\t\t\t{\n\t\t\t\tfloat2 r = 2.0 * (i.uv - 0.5);\n\t\t\t\tfloat aspectRatio = _ScreenParams.x / _ScreenParams.y;\n\t\t\t\tr.x *= aspectRatio;\n\n\t\t\t\tfixed3 black = float3(0.0, 0.0, 0.0); // black\n\t\t\t\tfixed3 white = float3(1.0, 1.0, 1.0);\n\t\t\t\tfixed3 gray = float3(0.3, 0.3, 0.3);\n\t\t\t\tfixed3 col1 = float3(0.216, 0.471, 0.698); // blue\n\t\t\t\tfixed3 col2 = float3(1.00, 0.329, 0.298); // red\n\t\t\t\tfixed3 col3 = float3(0.867, 0.910, 0.247); // yellow\n\n\t\t\t\tfixed3 ret;\n\t\t\t\tfixed3 pixel;\n\t\t\t\tfloat d;\n\n\n\t\t\t\tif(i.uv.x < 1.0/3.0){ // part1\n\t\t\t\t\tret = gray;\n\t\t\t\t\td = disk(r, float2(-1.1, 0.3), 0.4);\n\t\t\t\t\tret = lerp(ret, col1, d);\n\t\t\t\t\td = disk(r, float2(-1.3, 0.0), 0.4);\n\t\t\t\t\tret = lerp(ret, col2, d);\n\t\t\t\t\td = disk(r, float2(-1.05, -0.3), 0.4);\n\t\t\t\t\tret = lerp(ret, col3, d);\n\t\t\t\t}\n\t\t\t\telse if(i.uv.x < 2.0/3.0){ // part2\n\t\t\t\t\t// Color addition\n\t\t\t\t\tret = black;\n\t\t\t\t\tret += disk(r, float2(0.1, 0.3), 0.4) * col1;\n\t\t\t\t\tret += disk(r, float2(-0.1, 0.0), 0.4) * col2;\n\t\t\t\t\tret += disk(r, float2(0.15, -0.3), 0.4) * col3;\n \t\t\t\t}\n\t\t\t\telse if(i.uv.x < 3.0/ 3.0){ // part3\n\t\t\t\t\t// Color substraction\n\t\t\t\t\tret = white;\n\t\t\t\t\tret -= disk(r, float2(1.1, 0.3), 0.4) * col1;\n\t\t\t\t\tret -= disk(r, float2(1.05, 0.0), 0.4) * col2;\n\t\t\t\t\tret -= disk(r, float2(1.35, -0.25), 0.4) * col3;\n\n\t\t\t\t}\n\n\n\n\t\t\t\tpixel = ret;\n\t\t\t\treturn fixed4(pixel, 1.0);\n\t\t\t}\n\n\n\t\t\tENDCG\n\t\t}\n\t}\n}\n```\n\n> ## Point\n\u5186\u306e\u5883\u754c\u3092\u306a\u3081\u3089\u304b\u306b\u3057\u3066\u3044\u308b\uff0e\nret \u306b\u52a0\u7b97\u6e1b\u7b97\u3059\u308b\u3053\u3068\u3067\u8272\u3092\u5909\u5316\u3055\u305b\u3066\u3044\u308b\uff0e\n\n# Tutorial17 \u56de\u8ee2\n\n![result_tutorial17.PNG](https://qiita-image-store.s3.amazonaws.com/0/113504/78a34857-d850-4b51-010d-de6b9a617e68.png \"result_tutorial17.PNG\")\n\n\n```Tutorial17.shader\nShader \"ShaderTutorial/Tutorial17\"\n{\n\tSubShader\n\t{\n\t\t// No culling or depth\n\t\tCull Off ZWrite Off ZTest Always\n\n\t\t// \u8ffd\u52a0\n\t\tCGINCLUDE\n\n\t\t#define PI 3.14159\n\n\t\t// (anti-aliased)Grid\u3092\u4f5c\u308b\u95a2\u6570\n\t\tfloat coordinateGrid(float2 r){\n\t\t\tfloat3 axisCol = float3(0.0, 0.0, 1.0);\n\t\t\tfloat3 gridCol = float3(0.5, 0.5, 0.5);\n\t\t\tfloat ret = 0.0;\n\n\t\t\t// Draw grid lines\n\t\t\tconst float tickWidth = 0.1;\n\t\t\tfor(float i= -2.0;i<2.0; i+= tickWidth){\n\t\t\t\tret += 1.0 - smoothstep(0.0, 0.008, abs (r.x - i));\n\t\t\t\tret += 1.0 - smoothstep(0.0, 0.008, abs (r.y - i));\n\t\t\t}\n\n\t\t\t// Draw the axis\n\t\t\tret += 1.0-smoothstep(0.001, 0.015, abs(r.x));\n\t\t\tret += 1.0-smoothstep(0.001, 0.015, abs(r.y));\n\t\t\treturn ret;\n\t\t}\n\n\t\t// returns 1.0 if inside circle\n\t\tfloat disk(float2 r, float2 center, float radius){\n\t\t\treturn 1.0 - smoothstep( radius - 0.005, radius + 0.005, length(r - center));\n\t\t}\n\n\t\t// returns 1.0 if inside the disk\n\t\tfloat rectangle(float2 r, float2 bottomLeft, float2 topRight){\n\t\t\tfloat ret;\n\t\t\tfloat d = 0.005;\n\t\t\tret = smoothstep(bottomLeft.x - d, bottomLeft.x + d, r.x);\n\t\t\tret *= smoothstep(bottomLeft.y - d, bottomLeft.y + d, r.y);\n\t\t\tret *= 1.0 - smoothstep(topRight.y - d, topRight.y + d, r.y);\n\t\t\tret *= 1.0 - smoothstep(topRight.x - d, topRight.x + d, r.x);\n\t\t\treturn ret;\n\t\t}\n\t\tENDCG\n\n\n\t\tPass\n\t\t{\n\t\t\tCGPROGRAM\n\t\t\t#pragma vertex vert\n\t\t\t#pragma fragment frag\n\t\t\t\n\t\t\t#include \"UnityCG.cginc\"\n\n\t\t\tstruct appdata\n\t\t\t{\n\t\t\t\tfloat4 vertex : POSITION;\n\t\t\t\tfloat2 uv : TEXCOORD0;\n\t\t\t};\n\n\t\t\tstruct v2f\n\t\t\t{\n\t\t\t\tfloat2 uv : TEXCOORD0;\n\t\t\t\tfloat4 vertex : SV_POSITION;\n\t\t\t};\n\n\t\t\tv2f vert (appdata v)\n\t\t\t{\n\t\t\t\tv2f o;\n\t\t\t\to.vertex = mul(UNITY_MATRIX_MVP, v.vertex);\n\t\t\t\to.uv = v.uv;\n\t\t\t\to.uv.y = 1-o.uv.y;\n\t\t\t\treturn o;\n\t\t\t}\n\n\t\t\t//COORDINATE TRANSFORMATIONS: ROTATION\n\t\t\tfixed4 frag (v2f i) : SV_Target\n\t\t\t{\n\t\t\t\tfloat2 r = 2.0 * (i.uv - 0.5);\n\t\t\t\tfloat aspectRatio = _ScreenParams.x / _ScreenParams.y;\n\t\t\t\tr.x *= aspectRatio;\n\n\t\t\t\tfixed3 bgCol = float3(1.0, 1.0, 1.0); // white\n\t\t\n\t\t\t\tfixed3 col1 = float3(0.216, 0.471, 0.698); // blue\n\t\t\t\tfixed3 col2 = float3(1.00, 0.329, 0.298); // red\n\t\t\t\tfixed3 col3 = float3(0.867, 0.910, 0.247); // yellow\n\n\t\t\t\tfixed3 ret;\n\t\t\t\tfloat2 q;\n\t\t\t\tfloat angle;\n\t\t\t\tangle = 0.2*PI; // \u5358\u4f4d\u306f\u30e9\u30b8\u30a2\u30f3\n\t\t\t\t// 2\u6b21\u5143\u306e\u56de\u8ee2\n\t\t\t\tq.x = cos(angle)*r.x + sin(angle)*r.y;\n\t\t\t\tq.y = -sin(angle)*r.x + cos(angle)*r.y;\n\n\t\t\t\tret = bgCol;\n\t\t\t\t// draw the old and new coordinate systems\n\t\t\t\tret = lerp(ret, col1, coordinateGrid(r)*0.4);\n\t\t\t\tret = lerp(ret, col2, coordinateGrid(q));\n\n\t\t\t\t// draw shapes\n\t\t\t\tret = lerp(ret, col1, disk(r, float2(1.0, 0.0), 0.2));\n\t\t\t\tret = lerp(ret, col2, disk(q, float2(1.0, 0.0), 0.2));\n\t\t\t\tret = lerp(ret, col1, rectangle(r, float2(-0.8, 0.2),float2(-0.5, 0.4)));\n\t\t\t\tret = lerp(ret, col2, rectangle(q, float2(-0.8, 0.2),float2(-0.5, 0.4)));\n\n\n\n\t\t\t\tfixed3 pixel = ret;\n\t\t\t\treturn fixed4(pixel, 1.0);\n\t\t\t}\n\n\n\t\t\tENDCG\n\t\t}\n\t}\n}\n```\n\n> ## Point\n\u56de\u8ee2\u884c\u5217\u3092r\u306b\u639b\u3051\u7b97\u3059\u308b\u3053\u3068\u3067\uff0c\u5ea7\u6a19\u3092\u56de\u8ee2\u3055\u305b\uff0c\u305d\u306e\u5ea7\u6a19\u4e0a\u306e\u56f3\u5f62\u3082\u56de\u8ee2\u3055\u305b\u3066\u3044\u308b\uff0e\n\n# Tutorial18 \u30b9\u30b1\u30fc\u30ea\u30f3\u30b0\n\n![result_tutorial18.PNG](https://qiita-image-store.s3.amazonaws.com/0/113504/331dd0c1-cf98-bbf9-d2df-1809b276f70c.png \"result_tutorial18.PNG\")\n\n\n```Tutorial18\nShader \"ShaderTutorial/Tutorial18\"\n{\n\tSubShader\n\t{\n\t\t// No culling or depth\n\t\tCull Off ZWrite Off ZTest Always\n\n\t\t// \u8ffd\u52a0\n\t\tCGINCLUDE\n\n\t\t#define PI 3.14159\n\n\t\t// (anti-aliased)Grid\u3092\u4f5c\u308b\u95a2\u6570\n\t\tfloat coordinateGrid(float2 r){\n\t\t\tfloat3 axisCol = float3(0.0, 0.0, 1.0);\n\t\t\tfloat3 gridCol = float3(0.5, 0.5, 0.5);\n\t\t\tfloat ret = 0.0;\n\n\t\t\t// Draw grid lines\n\t\t\tconst float tickWidth = 0.1;\n\t\t\tfor(float i= -2.0;i<2.0; i+= tickWidth){\n\t\t\t\tret += 1.0 - smoothstep(0.0, 0.008, abs (r.x - i));\n\t\t\t\tret += 1.0 - smoothstep(0.0, 0.008, abs (r.y - i));\n\t\t\t}\n\n\t\t\t// Draw the axis\n\t\t\tret += 1.0-smoothstep(0.001, 0.015, abs(r.x));\n\t\t\tret += 1.0-smoothstep(0.001, 0.015, abs(r.y));\n\t\t\treturn ret;\n\t\t}\n\n\t\t// returns 1.0 if inside circle\n\t\tfloat disk(float2 r, float2 center, float radius){\n\t\t\treturn 1.0 - smoothstep( radius - 0.005, radius + 0.005, length(r - center));\n\t\t}\n\n\t\t// returns 1.0 if inside the disk\n\t\tfloat rectangle(float2 r, float2 bottomLeft, float2 topRight){\n\t\t\tfloat ret;\n\t\t\tfloat d = 0.005;\n\t\t\tret = smoothstep(bottomLeft.x - d, bottomLeft.x + d, r.x);\n\t\t\tret *= smoothstep(bottomLeft.y - d, bottomLeft.y + d, r.y);\n\t\t\tret *= 1.0 - smoothstep(topRight.y - d, topRight.y + d, r.y);\n\t\t\tret *= 1.0 - smoothstep(topRight.x - d, topRight.x + d, r.x);\n\t\t\treturn ret;\n\t\t}\n\t\tENDCG\n\n\n\t\tPass\n\t\t{\n\t\t\tCGPROGRAM\n\t\t\t#pragma vertex vert\n\t\t\t#pragma fragment frag\n\t\t\t\n\t\t\t#include \"UnityCG.cginc\"\n\n\t\t\tstruct appdata\n\t\t\t{\n\t\t\t\tfloat4 vertex : POSITION;\n\t\t\t\tfloat2 uv : TEXCOORD0;\n\t\t\t};\n\n\t\t\tstruct v2f\n\t\t\t{\n\t\t\t\tfloat2 uv : TEXCOORD0;\n\t\t\t\tfloat4 vertex : SV_POSITION;\n\t\t\t};\n\n\t\t\tv2f vert (appdata v)\n\t\t\t{\n\t\t\t\tv2f o;\n\t\t\t\to.vertex = mul(UNITY_MATRIX_MVP, v.vertex);\n\t\t\t\to.uv = v.uv;\n\t\t\t\to.uv.y = 1-o.uv.y;\n\t\t\t\treturn o;\n\t\t\t}\n\n\t\t\t//COORDINATE TRANSFORMATIONS: SCALING\n\t\t\tfixed4 frag (v2f i) : SV_Target\n\t\t\t{\n\t\t\t\tfloat2 r = 2.0 * (i.uv - 0.5);\n\t\t\t\tfloat aspectRatio = _ScreenParams.x / _ScreenParams.y;\n\t\t\t\tr.x *= aspectRatio;\n\n\t\t\t\tfixed3 bgCol = float3(1.0, 1.0, 1.0); // white\n\t\t\n\t\t\t\tfixed3 col1 = float3(0.216, 0.471, 0.698); // blue\n\t\t\t\tfixed3 col2 = float3(1.00, 0.329, 0.298); // red\n\t\t\t\tfixed3 col3 = float3(0.867, 0.910, 0.247); // yellow\n\n\t\t\t\tfixed3 ret;\n\t\t\t\tret = bgCol;\n\n\t\t\t\t// original\n\t\t\t\tret = lerp(ret, col1, coordinateGrid(r)/2.0);\n\n\t\t\t\t// scaled\n\t\t\t\tfloat2 q = 0.3*r;\n\t\t\t\tret = lerp(ret, col2, coordinateGrid(q));\n\n\t\t\t\t// draw shapes\n\t\t\t\tret = lerp(ret, col2, disk(q, float2(0.0, 0.0), 0.1)); //\u5927\n\t\t\t\tret = lerp(ret, col1, disk(r, float2(0.0, 0.0), 0.1));\n\n\t\t\t\tret = lerp(ret, col1, rectangle(r, float2(-0.5, 0.0),float2(-0.2, 0.2)));\n\t\t\t\tret = lerp(ret, col2, rectangle(q, float2(-0.5, 0.0),float2(-0.2, 0.2))); //\u5927\n\n\n\n\t\t\t\tfixed3 pixel = ret;\n\t\t\t\treturn fixed4(pixel, 1.0);\n\t\t\t}\n\n\n\t\t\tENDCG\n\t\t}\n\t}\n}\n```\n\n> ## Point\nr\u306b\u4fc2\u6570\u3092\u304b\u3051\u308b\u3053\u3068\u3067\uff0c\u62e1\u5927\u30fb\u7e2e\u5c0f\u3067\u304d\u308b\uff0e(0.3\u3092\u304b\u3051\u308b\u3053\u3068\u3067\uff0c\u5927\u304d\u304f\u306a\u3063\u3066\u3044\u308b\uff0e)\n\n# Tutorial19 Transform\n\n![result_tutorial19.PNG](https://qiita-image-store.s3.amazonaws.com/0/113504/7d2a9ce4-8e31-750e-27c4-9acbfd28062b.png \"result_tutorial19.PNG\")\n\n\n```Tutorial19\nShader \"ShaderTutorial/Tutorial19\"\n{\n\tSubShader\n\t{\n\t\t// No culling or depth\n\t\tCull Off ZWrite Off ZTest Always\n\n\t\t// \u8ffd\u52a0\n\t\tCGINCLUDE\n\n\t\t#define PI 3.14159\n\n\t\t// (anti-aliased)Grid\u3092\u4f5c\u308b\u95a2\u6570\n\t\tfloat coordinateGrid(float2 r){\n\t\t\tfloat3 axisCol = float3(0.0, 0.0, 1.0);\n\t\t\tfloat3 gridCol = float3(0.5, 0.5, 0.5);\n\t\t\tfloat ret = 0.0;\n\n\t\t\t// Draw grid lines\n\t\t\tconst float tickWidth = 0.1;\n\t\t\tfor(float i= -2.0;i<2.0; i+= tickWidth){\n\t\t\t\tret += 1.0 - smoothstep(0.0, 0.008, abs (r.x - i));\n\t\t\t\tret += 1.0 - smoothstep(0.0, 0.008, abs (r.y - i));\n\t\t\t}\n\n\t\t\t// Draw the axis\n\t\t\tret += 1.0-smoothstep(0.001, 0.015, abs(r.x));\n\t\t\tret += 1.0-smoothstep(0.001, 0.015, abs(r.y));\n\t\t\treturn ret;\n\t\t}\n\n\t\t// returns 1.0 if inside circle\n\t\tfloat disk(float2 r, float2 center, float radius){\n\t\t\treturn 1.0 - smoothstep( radius - 0.005, radius + 0.005, length(r - center));\n\t\t}\n\n\t\t// returns 1.0 if inside the disk\n\t\tfloat rectangle(float2 r, float2 bottomLeft, float2 topRight){\n\t\t\tfloat ret;\n\t\t\tfloat d = 0.005;\n\t\t\tret = smoothstep(bottomLeft.x - d, bottomLeft.x + d, r.x);\n\t\t\tret *= smoothstep(bottomLeft.y - d, bottomLeft.y + d, r.y);\n\t\t\tret *= 1.0 - smoothstep(topRight.y - d, topRight.y + d, r.y);\n\t\t\tret *= 1.0 - smoothstep(topRight.x - d, topRight.x + d, r.x);\n\t\t\treturn ret;\n\t\t}\n\t\tENDCG\n\n\n\t\tPass\n\t\t{\n\t\t\tCGPROGRAM\n\t\t\t#pragma vertex vert\n\t\t\t#pragma fragment frag\n\t\t\t\n\t\t\t#include \"UnityCG.cginc\"\n\n\t\t\tstruct appdata\n\t\t\t{\n\t\t\t\tfloat4 vertex : POSITION;\n\t\t\t\tfloat2 uv : TEXCOORD0;\n\t\t\t};\n\n\t\t\tstruct v2f\n\t\t\t{\n\t\t\t\tfloat2 uv : TEXCOORD0;\n\t\t\t\tfloat4 vertex : SV_POSITION;\n\t\t\t};\n\n\t\t\tv2f vert (appdata v)\n\t\t\t{\n\t\t\t\tv2f o;\n\t\t\t\to.vertex = mul(UNITY_MATRIX_MVP, v.vertex);\n\t\t\t\to.uv = v.uv;\n\t\t\t\to.uv.y = 1-o.uv.y;\n\t\t\t\treturn o;\n\t\t\t}\n\n\t\t\t//COORDINATE TRANSFORMATIONS\n\t\t\tfixed4 frag (v2f i) : SV_Target\n\t\t\t{\n\t\t\t\tfloat2 r = 2.0 * (i.uv - 0.5);\n\t\t\t\tfloat aspectRatio = _ScreenParams.x / _ScreenParams.y;\n\t\t\t\tr.x *= aspectRatio;\n\n\t\t\t\tfixed3 bgCol = float3(1.0, 1.0, 1.0); // white\n\t\t\n\t\t\t\tfixed3 col1 = float3(0.216, 0.471, 0.698); // blue\n\t\t\t\tfixed3 col2 = float3(1.00, 0.329, 0.298); // red\n\t\t\t\tfixed3 col3 = float3(0.867, 0.910, 0.247); // yellow\n\n\t\t\t\tfixed3 ret;\n\t\t\t\tret = bgCol;\n\n\t\t\t\tfloat angle = -0.6;\n\t\t\t\tfloat2x2 rotationMatrix = float2x2(cos(angle), -sin(angle),\n\t\t\t\t\t\t\t\t\t\t\t\tsin(angle), cos(angle));\n\n\t\t\t\t\n\t\t\t\tif(i.uv.x < 1.0/2.0) //part1\n\t\t\t\t{\n\t\t\t\t\t//\u5ea7\u6a19\u306e\u4e2d\u5fc3\u3092uv.x: 1/4\u306e\u4f4d\u7f6e\u306b\u3059\u308b\u3002\n\t\t\t\t\tr = r - float2(-aspectRatio/2.0, 0);\n\t\t\t\t\tfloat2 rotated = mul(rotationMatrix, r);\n\t\t\t\t\tfloat2 rotatedTranslated = rotated - float2(0.4, 0.5);\n\t\t\t\t\tret = lerp(ret, col1, coordinateGrid(r) * 0.3);\n\t\t\t\t\tret = lerp(ret, col2, coordinateGrid(rotated)*0.3);\n\t\t\t\t\tret = lerp(ret, col3, coordinateGrid(rotatedTranslated)*0.3);\n\n\t\t\t\t\tret = lerp(ret, col1, rectangle(r, float2(-0.1, -0.2), float2(0.1, 0.2)));\n\t\t\t\t\tret = lerp(ret, col2, rectangle(rotated, float2(-0.1, -0.2), float2(0.1, 0.2)));\n\t\t\t\t\tret = lerp(ret, col3, rectangle(rotatedTranslated, float2(-0.1, -0.2), float2(0.1, 0.2)));\n\t\t\t\t}\n\t\t\t\telse if(i.uv.x < 2.0/2.0){ //part2\n\t\t\t\t\t//\u5ea7\u6a19\u306e\u4e2d\u5fc3\u3092uv.x: 1/4\u306e\u4f4d\u7f6e\u306b\u3059\u308b\u3002\n\t\t\t\t\tr = r - float2(aspectRatio/2.0, 0);\n\t\t\t\t\tfloat2 translated = r - float2(0.4, 0.5);\n\t\t\t\t\tfloat2 translatedRotated = mul(rotationMatrix, translated);\n\t\t\t\t\t\n\t\t\t\t\tret = lerp(ret, col1, coordinateGrid(r) * 0.3);\n\t\t\t\t\tret = lerp(ret, col2, coordinateGrid(translated)*0.3);\n\t\t\t\t\tret = lerp(ret, col3, coordinateGrid(translatedRotated)*0.3);\n\n\t\t\t\t\tret = lerp(ret, col1, rectangle(r, float2(-0.1, -0.2), float2(0.1, 0.2)));\n\t\t\t\t\tret = lerp(ret, col2, rectangle(translated, float2(-0.1, -0.2), float2(0.1, 0.2)));\n\t\t\t\t\tret = lerp(ret, col3, rectangle(translatedRotated, float2(-0.1, -0.2), float2(0.1, 0.2)));\n\t\t\t\t}\n\n\n\n\n\t\t\t\tfixed3 pixel = ret;\n\t\t\t\treturn fixed4(pixel, 1.0);\n\t\t\t}\n\n\n\t\t\tENDCG\n\t\t}\n\t}\n}\n```\n\n> ## Point\nfloat2x2\u3067\uff0c2\u304b\u3051\u308b2\u306e\u6b63\u65b9\u884c\u5217\u3092\u793a\u3059\uff0e\u3053\u308c\u306b\u3088\u3063\u3066\u56de\u8ee2\u884c\u5217\u3092\u8868\u73fe\u3057\uff0cmul\u95a2\u6570\u306b\u3088\u3063\u3066\u884c\u5217\u306e\u639b\u3051\u7b97\u3092\u884c\u3063\u3066\u3044\u308b\uff0e\n\n\n## Tutorial20 Animations\n\n![result_tutorial21.gif](https://qiita-image-store.s3.amazonaws.com/0/113504/fc3d4d6c-6b09-2703-778a-93dcea221d83.gif \"result_tutorial21.gif\")\n\n\n```Tutorial20\nShader \"ShaderTutorial/Tutorial20\"\n{\n\tSubShader\n\t{\n\t\t// No culling or depth\n\t\tCull Off ZWrite Off ZTest Always\n\n\t\t// \u8ffd\u52a0\n\t\tCGINCLUDE\n\n\t\t#define PI 3.14159\n\n\t\t// (anti-aliased)Grid\u3092\u4f5c\u308b\u95a2\u6570\n\t\tfloat coordinateGrid(float2 r){\n\t\t\tfloat3 axisCol = float3(0.0, 0.0, 1.0);\n\t\t\tfloat3 gridCol = float3(0.5, 0.5, 0.5);\n\t\t\tfloat ret = 0.0;\n\n\t\t\t// Draw grid lines\n\t\t\tconst float tickWidth = 0.1;\n\t\t\tfor(float i= -2.0;i<2.0; i+= tickWidth){\n\t\t\t\tret += 1.0 - smoothstep(0.0, 0.008, abs (r.x - i));\n\t\t\t\tret += 1.0 - smoothstep(0.0, 0.008, abs (r.y - i));\n\t\t\t}\n\n\t\t\t// Draw the axis\n\t\t\tret += 1.0-smoothstep(0.001, 0.015, abs(r.x));\n\t\t\tret += 1.0-smoothstep(0.001, 0.015, abs(r.y));\n\t\t\treturn ret;\n\t\t}\n\n\t\t// returns 1.0 if inside circle\n\t\tfloat disk(float2 r, float2 center, float radius){\n\t\t\treturn 1.0 - smoothstep( radius - 0.005, radius + 0.005, length(r - center));\n\t\t}\n\n\t\t// returns 1.0 if inside the rect\n\t\tfloat rectangle(float2 r, float2 bottomLeft, float2 topRight){\n\t\t\tfloat ret;\n\t\t\tfloat d = 0.005;\n\t\t\tret = smoothstep(bottomLeft.x - d, bottomLeft.x + d, r.x);\n\t\t\tret *= smoothstep(bottomLeft.y - d, bottomLeft.y + d, r.y);\n\t\t\tret *= 1.0 - smoothstep(topRight.y - d, topRight.y + d, r.y);\n\t\t\tret *= 1.0 - smoothstep(topRight.x - d, topRight.x + d, r.x);\n\t\t\treturn ret;\n\t\t}\n\n\t\tfloat mod(float  a, float  b) { return a-b*floor(a/b); } \n\t\tENDCG\n\n\n\t\tPass\n\t\t{\n\t\t\tCGPROGRAM\n\t\t\t#pragma vertex vert\n\t\t\t#pragma fragment frag\n\t\t\t\n\t\t\t#include \"UnityCG.cginc\"\n\n\t\t\tstruct appdata\n\t\t\t{\n\t\t\t\tfloat4 vertex : POSITION;\n\t\t\t\tfloat2 uv : TEXCOORD0;\n\t\t\t};\n\n\t\t\tstruct v2f\n\t\t\t{\n\t\t\t\tfloat2 uv : TEXCOORD0;\n\t\t\t\tfloat4 vertex : SV_POSITION;\n\t\t\t};\n\n\t\t\tv2f vert (appdata v)\n\t\t\t{\n\t\t\t\tv2f o;\n\t\t\t\to.vertex = mul(UNITY_MATRIX_MVP, v.vertex);\n\t\t\t\to.uv = v.uv;\n\t\t\t\to.uv.y = 1-o.uv.y;\n\t\t\t\treturn o;\n\t\t\t}\n\n\t\t\t//ANIMATION\n\t\t\tfixed4 frag (v2f i) : SV_Target\n\t\t\t{\n\t\t\t\tfloat2 r = 2.0 * (i.uv - 0.5);\n\t\t\t\tfloat aspectRatio = _ScreenParams.x / _ScreenParams.y;\n\t\t\t\tr.x *= aspectRatio;\n\n\t\t\t\tfixed3 bgCol = float3(1.0, 1.0, 1.0); // white\n\t\t\n\t\t\t\tfixed3 col1 = float3(0.216, 0.471, 0.698); // blue\n\t\t\t\tfixed3 col2 = float3(1.00, 0.329, 0.298); // red\n\t\t\t\tfixed3 col3 = float3(0.867, 0.910, 0.247); // yellow\n\n\t\t\t\tfixed3 ret;\n\t\t\t\tret = bgCol;\n\n\t\t\t\tfloat angle = -0.6;\n\t\t\t\tfloat2x2 rotationMatrix = float2x2(cos(angle), -sin(angle),\n\t\t\t\t\t\t\t\t\t\t\t\tsin(angle), cos(angle));\n\n\t\t\t\t\n\t\t\t\tif(i.uv.x < 1.0/5.0) // part1\n\t\t\t\t{\n\t\t\t\t\tfloat2 q = r + float2(aspectRatio*4.0/5.0, 0);\n\n\t\t\t\t\tret = fixed3(0.3, 0.3, 0.3);\n\t\t\t\t\t//\u6642\u9593\u306f_Time.y\u3067\u53d6\u5f97\u3067\u304d\u308b\n\t\t\t\t\tfloat y = _Time.y;\n\n\t\t\t\t\t//y\u3092-1 ~ 1\u306e\u5024\u306b\u3059\u308b\n\t\t\t\t\ty = mod(y,2.0) -1.0;\n\t\t\t\t\tret = lerp(ret, col1, disk(q, float2(0.0, y), 0.1));\n\t\t\t\t}\n\t\t\t\telse if(i.uv.x < 2.0/5.0) //part2\n\t\t\t\t{\n\t\t\t\t\tfloat2 q = r + float2(aspectRatio*2.0/5.0, 0);\n\t\t\t\t\tret = fixed3(0.4, 0.4, 0.4);\n\t\t\t\t\t//\u632f\u5e45\n\t\t\t\t\tfloat amplitude = 0.8;\n\t\t\t\t\tfloat y = 0.8 * sin(0.5*_Time.y* 2.0 * PI);\n\t\t\t\t\tfloat radius = 0.15 + 0.05 * sin(_Time.y * 8.0);\n\t\t\t\t\tret = lerp(ret, col1, disk(q, float2(0.0, y), radius));\n\t\t\t\t}\n\t\t\t\telse if(i.uv.x < 3.0/5.0) //part3\n\t\t\t\t{\n\t\t\t\t\tfloat2 q = r + float2(aspectRatio*0/5.0, 0);\n\t\t\t\t\tret = float3(0.5, 0.5, 0.5);\n\n\t\t\t\t\tfloat x = 0.2*cos(_Time.y*5.0);\n\t\t\t\t\tfloat y = 0.3*sin(_Time.y*5.0);\n\t\t\t\t\tfloat radius = 0.2 + 0.1*sin(_Time.y*2.0);\n\t\t\t\t\tfixed3 color = lerp(col1, col2, sin(_Time.y)*0.5 + 0.5);\n\t\t\t\t\tret = lerp(ret, color, rectangle(q, float2(x-0.1, y-0.1), float2(x+0.1, y+0.1)));\n\t\t\t\t}\n\t\t\t\telse if(i.uv.x < 4.0/5.0) //part4\n\t\t\t\t{\n\t\t\t\t\tfloat2 q = r + float2(-aspectRatio*2.0/5.0, 0);\n\t\t\t\t\tret = float3(0.4, 0.4, 0.4);\n\n\t\t\t\t\tfor(float i=-1.0; i<1.0; i+= 0.2)\n\t\t\t\t\t{\n\t\t\t\t\t\tfloat x = 0.2 * cos(_Time.y*5.0 + i*PI);\n\t\t\t\t\t\tfloat y = i;\n\n\t\t\t\t\t\tfloat2 s = q - float2(x, y);\n\t\t\t\t\t\tfloat angle = _Time.y * 3.0 + i;\n\t\t\t\t\t\tfloat2x2 rot = float2x2(cos(angle), -sin(angle),\n\t\t\t\t\t\t\t\t\t\t\t\tsin(angle),  cos(angle));\n\t\t\t\t\t\ts = mul(rot, s);\n\t\t\t\t\t\tret = lerp(ret, col1, rectangle(s, float2(-0.06, -0.06), float2(0.06, 0.06)));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if(i.uv.x < 5.0/5.0) //part5\n\t\t\t\t{\n\t\t\t\t\tfloat2 q = r + float2(-aspectRatio*4.0/5.0, 0);\n\t\t\t\t\tret = float3(0.3, 0.3, 0.3);\n\n\t\t\t\t\tfloat speed = 2.0;\n\t\t\t\t\tfloat t = _Time.y * speed;\n\t\t\t\t\tfloat stopEveryAngle = PI / 2.0;\n\t\t\t\t\tfloat stopRatio = 0.5;\n\t\t\t\t\t//0.5<frac(t)<1\u306e\u6642,t1\u306f\u4e00\u5b9a\u3068\u306a\u308b\u3002\u305d\u3053\u3067\u6b62\u307e\u3063\u3066\u3044\u308b\u3002\n\t\t\t\t\tfloat t1 = (floor(t) + smoothstep(0.0, 1.0 - stopRatio, frac(t)))*stopEveryAngle;\n\n\t\t\t\t\tfloat x = -0.2*cos(t1);\n\t\t\t\t\tfloat y = 0.3 * sin(t1);\n\t\t\t\t\tfloat dx = 0.1 + 0.03 * sin(t*10.0);\n\t\t\t\t\tfloat dy = 0.1 + 0.03 * sin(t*10.0+PI);\n\t\t\t\t\tret = lerp(ret, col1, rectangle(q, float2(x-dx, y-dy), float2(x+dx, y+dy)));\n\n\t\t\t\t\n\t\t\t\t}\n\n\n\t\t\t\tfixed3 pixel = ret;\n\t\t\t\treturn fixed4(pixel, 1.0);\n\t\t\t}\n\n\n\t\t\tENDCG\n\t\t}\n\t}\n}\n\n```\n\n> ## Point\n_Time.y\u3067\u6642\u9593\u3092\u53d6\u5f97\u3067\u304d\u308b\uff0e\n\n\n# Tutorial21 Plasma\n\n![result_tutorial21.PNG](https://qiita-image-store.s3.amazonaws.com/0/113504/eed86669-60f2-44c2-0628-9daad72ed081.png \"result_tutorial21.PNG\")\n\n\n```Tutorial21\n//Plasma\nfixed4 frag (v2f i) : SV_Target\n{\n\tfloat2 r = 2.0 * (i.uv - 0.5);\n\tfloat aspectRatio = _ScreenParams.x / _ScreenParams.y;\n\tr.x *= aspectRatio;\n\tfloat t = _Time.y;\n\tr = r*8.0;\n\n\tfloat v1 = sin(r.x + t);\n\tfloat v2 = sin(r.y + t);\n\tfloat v3 = sin(r.x + r.y + t);\n\tfloat v4 = sin(sqrt(r.x*r.x + r.y*r.y) + 1.7*t);\n\tfloat v = v1 + v2 + v3 + v4;\n\tfixed3 ret;\n\n\tif(i.uv.x < 1.0 / 10.0) // part1\n\t{\n\t\t//vertical waves\n\t\tret = float3(v1, v1, v1);\n\t}\n\telse if(i.uv.x < 2.0/10.0) // part2\n\t{\n\t\t// horizontal waves;\n\t\tret = float3(v2, v2, v2);\n\t}\n\telse if(i.uv.x < 3.0/10.0) // part3\n\t{\n\t\t// diagonal waves\n\t\tret = float3(v3, v3, v3);\n\t}\n\telse if(i.uv.x < 4.0/10.0) // part4\n\t{\n\t\t// circular waves\n\t\tret = float3(v4, v4, v4);\n\t}\n\telse if(i.uv.x < 5.0/10.0) // part5\n\t{\n\t\t// the sum of all waves\n\t\tret = float3(v, v, v);\n\t}\n\telse if(i.uv.x < 6.0/10.0) // part6\n\t{\n\t\t// Add periodicity to the gradients\n\t\tret = float3(sin(2.0 * v), sin(2.0 * v), sin(2.0 * v));\n\t}\n\telse if(i.uv.x < 10.0/10.0) // part7\n\t{\n\t\t// mix colors\n\t\tv *= 1.0;\n\t\tret = float3(sin(v), sin(v+0.5*PI), sin(v+1.0*PI));\n\t}\n\n\tret = 0.5 + 0.5 * ret;\n\n\tfixed3 pixel = ret;\n\treturn fixed4(pixel, 1.0);\n}\n```\n\n> ## Point\nsin,cos\u3068_Time.y\u3092\u7d44\u307f\u5408\u308f\u305b\u308b\u3068\u5468\u671f\u7684\u306a\u6a21\u69d8\u304c\u3067\u304d\u308b\uff0e\n\n\n\n\n\n\n"}