{"context": " More than 1 year has passed since last update.(use-package :trivial-lazy)\n(use-package :optima)\n\n;; (delay x) ~~ (lambda () x)\n\n(defmacro lcons (a b)\n  \"cons whose car and cdr is lazy\"\n  `(cons (delay ,a)\n         (delay ,b)))\n\n(defpattern lazy (pattern)\n  (with-gensyms (thunk)\n    `(guard ,thunk (match (force ,thunk) (,pattern t)))))\n\n(defpattern lcons (lcar lcdr)\n  (with-gensyms (thunk1 thunk2)\n    `(cons (lazy ,lcar)\n           (lazy ,lcdr))))\n\n;; This is OK\n(match (lcons 1 2)\n  ((lcons 1 2)\n   t))\n\n;; but this is not\n(match (lcons 1 2)\n  ((lcons a b)\n   (+ a b)))\n\nAny ideas?\nRE: use the accessor functions (evaluated):\n(defun lazy-consp (x)\n  (consp x))\n(defun lazy-conscar (x)\n  (force (car x)))\n(defun lazy-conscdr (x)\n  (force (cdr x)))\n\n(defpattern lcons (lcar lcdr)\n  `(lazy-cons (car ,lcar) (cdr ,lcdr)))\n\n;; then this works\n(match (lcons 1 2)\n  ((lcons a b)\n   (+ a b)))\n;; -> 3\n\nAccessor functions accept only one argument.\nConsider x in the above example. --- x is the object being accessed.\nIn order to specify how to get the value to be stored in the variable in the matching context (in the example above, a and b) we need additional arguments.\n  x = (lcons 1 2)    --(lazy-conscar x)-->    1\n (accessed object)        (accessor)       (value)\n                              ^\n                              |\n                              | this is specified by the constructor-pattern\n\n\n\n  x   --(funcall #'(lambda (x) ...)  x)-->    value\n                       ^\n                       |                                \n                       | we want to specify arbitrary accessor\n                       | in the pattern matching clause.\n\nThe relationship between a pattern clause and the accessor-function is\ncurrently hard-coded (in constructor-pattern) or require additional layer\n(defpattern and gritchy lazy-consp/lazy-conscar/lazy-conscdr).\nI sometimes think there are only two clauses needed in order to implement a\npattern matcher. They are type and access .\nIf everything is built on those clauses and defpattern, things should\nbe simpler. Imagine if cons pattern is not hard-coded and\nimplemented with type, access and defpattern.\n\n(defpattern cons (car cdr)\n  `(and (type cons)\n        (access #'car ,car)\n        (access #'cdr ,cdr)))\n\n(match a\n  ((cons b c)\n   (some-op b c)))\n\n;; is equivalent to\n\n(match a\n  ((and (type cons)\n        (access #'car b)\n        (access #'cdr c))\n   (some-op b c)))\n\nthen the optima's compiler would be simple.\nAny comments are welcome.\nNote: I ignored not , or and guard clause.\n```cl\n(use-package :trivial-lazy)\n(use-package :optima)\n\n;; (delay x) ~~ (lambda () x)\n\n(defmacro lcons (a b)\n  \"cons whose car and cdr is lazy\"\n  `(cons (delay ,a)\n         (delay ,b)))\n\n(defpattern lazy (pattern)\n  (with-gensyms (thunk)\n    `(guard ,thunk (match (force ,thunk) (,pattern t)))))\n\n(defpattern lcons (lcar lcdr)\n  (with-gensyms (thunk1 thunk2)\n    `(cons (lazy ,lcar)\n           (lazy ,lcdr))))\n\n;; This is OK\n(match (lcons 1 2)\n  ((lcons 1 2)\n   t))\n\n;; but this is not\n(match (lcons 1 2)\n  ((lcons a b)\n   (+ a b)))\n```\n\nAny ideas?\n\nRE: use the accessor functions (evaluated):\n\n```cl\n(defun lazy-consp (x)\n  (consp x))\n(defun lazy-conscar (x)\n  (force (car x)))\n(defun lazy-conscdr (x)\n  (force (cdr x)))\n\n(defpattern lcons (lcar lcdr)\n  `(lazy-cons (car ,lcar) (cdr ,lcdr)))\n  \n;; then this works\n(match (lcons 1 2)\n  ((lcons a b)\n   (+ a b)))\n;; -> 3\n```\n\nAccessor functions accept only one argument.\nConsider `x` in the above example. --- `x` is the object being accessed.\n\nIn order to specify how to get the value to be stored in the variable in the matching context (in the example above, `a` and `b`) we need additional arguments.\n\n```\n  x = (lcons 1 2)    --(lazy-conscar x)-->    1\n (accessed object)        (accessor)       (value)\n                              ^\n                              |\n                              | this is specified by the constructor-pattern\n\n\n\n  x   --(funcall #'(lambda (x) ...)  x)-->    value\n                       ^\n                       |                                \n                       | we want to specify arbitrary accessor\n                       | in the pattern matching clause.\n```\n\nThe relationship between a `pattern clause` and the `accessor-function` is\ncurrently hard-coded (in constructor-pattern) or require additional layer\n(defpattern and gritchy lazy-consp/lazy-conscar/lazy-conscdr).\n\n\nI sometimes think there are only two clauses needed in order to implement a\npattern matcher. They are `type` and `access` .\nIf everything is built on those clauses and `defpattern`, things should\nbe simpler. Imagine if `cons` pattern is not hard-coded and\nimplemented with `type`, `access` and `defpattern`.\n\n\n```cl\n\n(defpattern cons (car cdr)\n  `(and (type cons)\n        (access #'car ,car)\n        (access #'cdr ,cdr)))\n        \n(match a\n  ((cons b c)\n   (some-op b c)))\n\n;; is equivalent to\n\n(match a\n  ((and (type cons)\n        (access #'car b)\n        (access #'cdr c))\n   (some-op b c)))\n```\n\nthen the optima's compiler would be simple.\nAny comments are welcome.\n\nNote: I ignored `not` , `or` and `guard` clause.\n", "tags": ["common-lisp"]}