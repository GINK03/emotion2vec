{"context": " More than 1 year has passed since last update.\u524d\u56de\u306f\u3001\u03b1\u5909\u63db\u3092\u4f5c\u3063\u305f\u306e\u3067\u3001\u4eca\u56de\u3053\u305d\u672c\u5f53\u306b\u30d1\u30bf\u30fc\u30f3\u30de\u30c3\u30c1\u69cb\u6587\u3092\u4f5c\u308b\u3093\u3060\u3088\u3002\u4f55\u56de\u8a00\u3063\u3066\u3093\u3060\u3088\u3002\u4ffa\u3002\n\n\u5f0f\ncase class EMatch(t:T, d:E, cases:List[(ETag,E)]) extends E\n\n\n\u4f8b\n\u4ee5\u4e0b\u306b\u30de\u30c3\u30c1\u69cb\u6587\u306e\u4f8b\u3092\u793a\u3057\u307e\u3059\u3002\n// match\u69cb\u6587\nEMatch(t, \"data2\", List(\n  ETag(t, \"A\", List(EId(\"x\"))) -> EBlock(Tv,List(EPrint(x))),\n  ETag(t, \"B\", List(EId(\"x\"),EId(\"y\"))) -> EBlock(Tv,List(EPrint(x),EPrint(y)))\n))\n\n\n\u5b9f\u88c5\n\u30c6\u30b9\u30c8\u3092\u5b9f\u88c5\u3057\u3066\u3001\u52d5\u304b\u3057\u3066\u3051\u3070\u305d\u306e\u3046\u3061\u51fa\u6765\u308b\u3088\u3002switch\u6587\u306e\u5b9f\u88c5\u3092\u53c2\u8003\u306b\u3057\u3064\u3064\u3001\u6700\u521d\u306b\u30bf\u30b0\u3092\u53d6\u308a\u51fa\u3057\u3066\u3001switch\u3067\u5206\u5c90\u3057\u3001\u5206\u5c90\u5148\u3067\u306f\u4f55\u3082\u3057\u306a\u3044\u72b6\u614b\u306b\u307e\u305a\u3057\u307e\u3057\u305f\u3002\n\u6b21\u306b\u3001\u30d0\u30a4\u30f3\u30c7\u30a3\u30f3\u30b0\u3092\u4f5c\u308a\u307e\u3059\u3002\u03b1\u5909\u63db\u3055\u308c\u3066\u3044\u308b\u306e\u3067\u7279\u306b\u60a9\u307e\u305a\u306b\u3001\u30d0\u30a4\u30f3\u30c7\u30a3\u30f3\u30b0\u306e\u30ed\u30b8\u30c3\u30af\u3092\u66f8\u304d\u307e\u3057\u305f\u3002\u305d\u3057\u3066\u3001\u305d\u308c\u305e\u308c\u306ecase\u306e\u51e6\u7406\u3092\u30b3\u30f3\u30d1\u30a4\u30eb\u3059\u308c\u3070\u51fa\u6765\u4e0a\u304c\u308a\u3067\u3059\u3002switch\u6587\u3088\u308a\u9577\u304f\u306f\u306a\u308a\u307e\u3057\u305f\u304c\u3001\u306a\u3093\u3068\u304b\u4f5c\u308b\u4e8b\u304c\u51fa\u6765\u307e\u3057\u305f\u3002\n\u305d\u3046\uff01\u3064\u3044\u306b\u51fa\u6765\u305f\u306e\u3067\u3059\uff01\u3064\u3044\u306b\uff01\u3084\u3063\u305f\uff01\npackage chapter11\n\nimport java.io._\nimport util.parsing.input.Positional\n\nsealed trait E extends Positional {\n  def t:T\n}\ncase class ELdc(t:T, i:Long) extends E\ncase class EBin(t:T, s:String, l:E, r:E) extends E\ncase class EPrint(t:T, a:E) extends E\ncase class EBlock(t: T, ls: List[E]) extends E\ncase class EVal(t: T, id: String, a: E) extends E\ncase class EId(t: T, id: String) extends E\ncase class EAssign(t: T, a: E, b: E) extends E\ncase class EField(t: T, id: String, idx: String) extends E\ncase class ETuple(t:T,ls:List[E]) extends E\ncase class ETag(t:T,id:String,ls:List[E]) extends E\ncase class ESwitch(t: T, a: E, cases:List[(E,E)] ) extends E\ncase object EUnit extends E { def t = Tv }\ncase class EType(t:T, id:String) extends E\ncase class ECase(t:T, e:E) extends E\n\nsealed trait T extends Positional\ncase class Ti(i:Int) extends T\ncase object Tv extends T\ncase object Tn extends T\ncase class TFun(t: T, prms: List[T]) extends T\ncase class TStr(types: List[(String, T)]) extends T\ncase class TVariant(ls:List[(String,TStr)]) extends T\ncase class Tp(t:T) extends T\ncase class TDef(id:String) extends T\n\nobject T {\n  def find(t:TStr, a: String): (Int, T) = {\n    def f(i: Int, xs: List[(String, T)]): (Int, T) = {\n      xs match {\n        case List() => (-1, Tv)\n        case (x, t) :: xs => if (a == x) (i, t) else f(i + 1, xs)\n      }\n    }\n    f(0, t.types)\n  }\n}\n\ncase class Op(s: String) {\n  def apply(t: T, a: E, b: E): E = {\n    EBin(t, s, a, b)\n  }\n}\nobject EAdd extends Op(\"add\")\nobject EMul extends Op(\"mul\")\n\nsealed trait R {\n  def t:T\n  def id:String\n}\ncase class RG(t:T, id: String) extends R\ncase class RL(t:T, id: String) extends R\ncase class RR(t:T, id: String) extends R\ncase class RN(t:T, id: String) extends R\n\nobject test {\n  def main(argv: Array[String]) {\n    try {\n      val t = TVariant(List(\n          \"A\"->TStr(List(\"a\"->Ti(32))),\n          \"B\"->TStr(List(\"a\"->Ti(32), \"b\"->Ti(32)))\n        ))\n      val ast = EBlock(Tv, List(\n        EPrint(Ti(32), ELdc(Ti(32), 11)),\n        EPrint(Ti(32), EAdd(Ti(32), ELdc(Ti(32), 11), ELdc(Ti(32), 22))),\n        // \u5909\u6570 a \u5b9a\u6570\n        EVal(Ti(32), \"a\", ELdc(Ti(32), 11)),\n        EPrint(Ti(32), EId(Ti(32), \"a\")),\n        // \u5909\u6570 b \u8db3\u3057\u7b97\n        EVal(Ti(32), \"b\", EAdd(Ti(32), ELdc(Ti(32), 11), ELdc(Ti(32), 22))),\n        EPrint(Ti(32), EId(Ti(32), \"b\")),\n        // \u5909\u6570 c \u5909\u6570\u306e\u5024\n        EVal(Ti(32), \"c\", EId(Ti(32), \"a\")),\n        EPrint(Ti(32), EId(Ti(32), \"c\")),\n        // \u69cb\u9020\u4f53\n        EVal(TStr(List((\"a\", Ti(32)), (\"b\", Ti(32)))), \"aa\", null),\n        EAssign(Ti(32), EField(Ti(32), \"aa\", \"a\"), ELdc(Ti(32), 9)),\n        EAssign(Ti(32), EField(Ti(32), \"aa\", \"b\"), EId(Ti(32), \"c\")),\n        EPrint(Ti(32), EField(Ti(32), \"aa\", \"a\")),\n        EPrint(Ti(32), EField(Ti(32), \"aa\", \"b\")),\n        // \u69cb\u9020\u4f53\u521d\u671f\u5316\u30ea\u30c6\u30e9\u30eb\n        EVal(TStr(List((\"a\", Ti(32)), (\"b\", Ti(32)))), \"ab\",\n          ETuple(TStr(List((\"a\", Ti(32)), (\"b\", Ti(32)))),\n            List(ELdc(Ti(32),123),ELdc(Ti(32),456)))),\n        EPrint(Ti(32), EField(Ti(32), \"ab\", \"a\")),\n        EPrint(Ti(32), EField(Ti(32), \"ab\", \"b\")),\n\n        // \u30f4\u30a1\u30ea\u30a2\u30f3\u30c8\n        EVal(TVariant(List(\n          \"A\"->TStr(List(\"a\"->Ti(32))),\n          \"B\"->TStr(List(\"a\"->Ti(32), \"b\"->Ti(32)))\n        )),\"data\", null),\n\n        EVal(TVariant(List(\n            \"A\"->TStr(List(\"a\"->Ti(32))),\n            \"B\"->TStr(List(\"a\"->Ti(32), \"b\"->Ti(32)))\n          )),\n          \"data2\",\n          ETag(TVariant(List(\n            \"A\"->TStr(List(\"a\"->Ti(32))),\n            \"B\"->TStr(List(\"a\"->Ti(32), \"b\"->Ti(32)))\n            )),\n            \"B\",\n            List(\n              ELdc(Ti(32), 555),\n              ELdc(Ti(32), 777)\n          ))\n        ),\n        // switch\n        ESwitch(Ti(32), ELdc(Ti(32), 2), List(\n          ELdc(Ti(32), 1) -> EPrint(Ti(32), ELdc(Ti(32), 10001)),\n          ELdc(Ti(32), 2) -> EPrint(Ti(32), ELdc(Ti(32), 10002)),\n          ELdc(Ti(32), 3) -> EPrint(Ti(32), ELdc(Ti(32), 10003))\n        )),\n        ESwitch(Ti(32), ELdc(Ti(32), 0), List(\n          ELdc(Ti(32), 1) -> EPrint(Ti(32), ELdc(Ti(32), 10001)),\n          ELdc(Ti(32), 2) -> EPrint(Ti(32), ELdc(Ti(32), 10002)),\n          ELdc(Ti(32), 3) -> EPrint(Ti(32), ELdc(Ti(32), 10003))\n        )),\n\n        // alpha test\n        EVal(Ti(32), \"a\", ELdc(Ti(32), 1000)),\n        EPrint(Ti(32), EId(Ti(32), \"a\")),\n        EVal(Ti(32), \"a\", EAdd(Ti(32), EId(Ti(32),\"a\"), ELdc(Ti(32),2000))),\n        EPrint(Ti(32), EId(Ti(32), \"a\")),\n        // alpha block test\n        EBlock(Tv, List(\n          EVal(Ti(32), \"a\", ELdc(Ti(32), 5000)),\n          EPrint(Ti(32), EId(Ti(32), \"a\"))\n        )),\n        EPrint(Ti(32), EId(Ti(32), \"a\")),\n\n        // match\u69cb\u6587\n        ESwitch(t, EId(t,\"data2\"), List(\n          ETag(t, \"A\", List(EVal(Ti(32),\"x\",null))) -> EBlock(Tv,List(EPrint(Ti(32),EId(Ti(32),\"x\")))),\n          ETag(t, \"B\", List(EVal(Ti(32),\"x\",null),EVal(Ti(32),\"y\",null))) -> EBlock(Tv,List(EPrint(Ti(32),EId(Ti(32),\"x\")),EPrint(Ti(32),EId(Ti(32),\"y\"))))\n        )),\n\n        EVal(t, \"data3\",\n          ETag(t, \"A\", List(\n              ELdc(Ti(32), 333)\n          ))\n        ),\n        ESwitch(t, EId(t,\"data3\"), List(\n          ETag(t, \"A\", List(EVal(Ti(32),\"x\",null))) -> EBlock(Tv,List(\n              EPrint(Ti(32),EId(Ti(32),\"x\")))),\n          ETag(t, \"B\", List(EVal(Ti(32),\"x\",null),EVal(Ti(32),\"y\",null))) -> EBlock(Tv,List(\n              EPrint(Ti(32),EId(Ti(32),\"x\")),\n              EPrint(Ti(32),EId(Ti(32),\"y\"))))\n        )),\n        EVal(Ti(32),\"x\",ELdc(Ti(32),10)),\n        EPrint(Ti(32),EId(Ti(32),\"x\")),\n        EType(TStr(List((\"a\", Ti(32)), (\"b\", Ti(32)))), \"Dt\"),\n        EVal(TDef(\"Dt\"), \"a2\", null),\n        EAssign(Ti(32), EField(Ti(32), \"a2\", \"a\"), ELdc(Ti(32), 9)),\n        EPrint(Ti(32), EField(Ti(32), \"a2\", \"a\"))\n\n      ))\n      println(\"ast=\" + ast)\n      val ast2 = alpha(ast)\n      println(\"ast2=\" + ast2)\n      val ll = kNormal(ast2)\n      println(\"ll=\" + ll)\n      val ll2 = constFold(ll)\n      emit(\"e.ll\", ll2)\n      println(exec(\"llc e.ll -o e.s\"))\n      println(exec(\"llvm-gcc -m64 e.s -o e\"))\n      println(exec(\"./e\"))\n    } catch {\n      case e:Throwable => e.printStackTrace()\n    }\n  }\n}\n\nobject alpha {\n\n  def find(id: String, env: Map[String, String]): String = {\n    if (env.contains(id)) env(id) else id\n  }\n\n  def apply(e: E): E = {\n    f(e, Map()) match { case(e, _) => e }\n  }\n  def l(ls:List[E],env:Map[String,String]):(List[E],Map[String, String]) = {\n    val (ls2,env2) = ls.foldLeft(List[E](), env) {\n      case ((ls, env), a) =>\n        val (a1, env1) = f(a, env)\n        ((a1 :: ls), env1)\n    }\n    (ls2.reverse,env2)\n  }\n  def l2(ls:List[(E,E)],env:Map[String,String]):(List[(E,E)],Map[String, String]) = {\n    val (cases1, env2) = ls.foldLeft(List[(E,E)](), env) {\n      case ((ls, env), (a,b)) =>\n        val (a1, env1) = f(a, env)\n        val (b1, env2) = f(b, env1)\n        (((a1,b1) :: ls), env)\n    }\n    (cases1.reverse, env2)\n  }\n  def f(e: E, env: Map[String, String]): (E, Map[String, String]) = {\n    e match {\n      case e @ EBin(t: T, i: String, a: E, b: E) =>\n        val (a1, env1) = f(a, env)\n        val (b1, env2) = f(b, env1)\n        (e.copy(t, i, a1, b1), env2)\n      case e @ ELdc(t: T, i: Long) => (e.copy(t, i), env)\n      case e @ EBlock(t: T, ls: List[E]) =>\n        val (ls1, env1) = l(ls, env)\n        (e.copy(t, ls1), env)\n      case e @ EPrint(t: T, a: E) =>\n        val (a1, env1)  = f(a, env)\n        (e.copy(t, a1), env1)\n      case e @ EVal(t: T, id: String, a) =>\n        val (a1,env1) = if (a == null) (null, env) else f(a, env)\n        val id2 = if (env.contains(id)) genid(\".\") else id\n        (e.copy(t, id2, a1), env1 + (id -> id2))\n      case e @ EId(t: T, id: String) => (e.copy(t, find(id, env)), env)\n      case e @ EField(t: T, id: String, idx: String) =>\n        (e.copy(t, find(id, env), idx), env)\n      case e @ EAssign(t: T, a: E, b: E) =>\n        val (a1, env1) = f(a, env)\n        val (b1, env2) = f(b, env1)\n        (e.copy(t, a1, b1), env2)\n      case e @ ESwitch(t: T, a: E, cases:List[(E,E)]) =>\n        val (a1, env1) = f(a, env)\n        val (cases1, _) = l2(cases, env1)\n        (e.copy(t, a1, cases1), env)\n      case e @ EUnit => (e, env)\n      case e @ ETag(t: T, id:String, ls: List[E]) =>\n        val (ls1, env1) = l(ls, env)\n        (e.copy(t, id, ls1), env1)\n      case e @ ETuple(t:T,ls:List[E]) =>\n        val (ls1, env1) = l(ls, env)\n        (e.copy(t, ls1), env1)\n      case e @ EType(t:T, id:String) => (e.copy(t, id), env)\n      case e : ECase => throw new Exception(\"error\")\n    }\n  }\n}\n\nobject kNormal {\n  def gid(t:T): R = {\n    RR(t,genid(\"\"))\n  }\n  var ls: List[LL] = null\n  def add(l: LL) {\n    ls = l :: ls\n  }\n\n  def arr(e: E): R = {\n    e match {\n      case EField(t, id, idx) =>\n        env.map(id) match {\n          case i:R =>\n            val ((n, nt), reg1) = (T.find(i.t.asInstanceOf[TStr],idx), gid(t))\n            add(LLField(reg1, i, RN(Ti(64),\"0\"), RN(nt,\"\"+n)))\n            reg1\n          case t => throw new Exception(\"type mismatch \" + t)\n        }\n      case EId(t, id) => env.map(id)\n      case _ => throw new Exception(\"error\")\n    }\n  }\n\n  def findTag(tagId:String, n:Int, ls:List[(String, TStr)]):(Int, TStr) = ls match {\n    case List() => throw new Exception(\"not found \"+tagId)\n    case (stId,stT:TStr)::ls => if (stId == tagId) (n,stT) else findTag(tagId, n + 1, ls)\n  }\n\n  def f(a: E): R = {\n    a match {\n      case EBin(t, op, a1, b1) =>\n        (f(a1), f(b1), gid(t)) match {\n          case (a, b, id) =>\n            if (t != a.t || t != b.t) throw new Exception(\"type mismatch \" + t)\n            add(LLBin(id, op, a, b))\n            id\n        }\n      case ELdc(t, i) => RN(t, \"\"+i)\n      case EPrint(t, a) =>\n        f(a) match {\n          case a =>\n            if (t != a.t) throw new Exception(\"type mismatch t=\" + t + \" ta=\" + a.t)\n            add(LLCall(null, RG(TFun(Tv, List(t)), \"print_\" + emit.llt(t)), List((a.t, a))))\n            a\n        }\n      case EBlock(t, ls) =>\n        ls.foldLeft(null: R) {\n          case (tid, l) => f(l)\n        }\n      case EVal(t: TStr, id, tpl) =>\n        emit.llstruct(t)\n        env.add(RL(t,id))\n        add(LLAlloca(RL(t,id)))\n        tpl match {\n          case ETuple(_, ls) =>\n            for ((e, (name, t)) <- ls.zip(t.types)) {\n              f(EAssign(t, EField(t, id, name), e))\n            }\n          case null =>\n          case _ => throw new Exception(\"error\")\n        }\n        RL(t,id)\n      case EVal(t: TVariant, id, tpl) =>\n        val (_, valT, maxT, _) = emit.llvariantInfo(t)\n        env.add(RL(t,id))\n        add(LLAlloca(RL(t,id)))\n        tpl match {\n          case ETag(_, tagId, ls) =>\n            val (tagIdx, stT) = findTag(tagId, 0, t.ls)\n            val tagR = gid(stT)\n            // tag id \u306e\u30a2\u30c9\u30ec\u30b9\u53d6\u5f97\n            add(LLField(tagR, RL(valT, id), RN(Ti(64), \"0\"), RN(Ti(32), \"0\")))\n            // tag id\u4fdd\u5b58\n            add(LLStore(RN(Ti(32),\"\"+tagIdx), tagR))\n\n            // \u5185\u90e8\u306e\u69cb\u9020\u4f53\u306e\u30a2\u30c9\u30ec\u30b9\u3092\u53d6\u5f97\n            val maxAdrR = gid(Tp(maxT))\n            add(LLField(maxAdrR, RL(valT, id), RN(Ti(64), \"0\"), RN(Ti(32), \"1\")))\n\n            // \u30ad\u30e3\u30b9\u30c8\u3059\u308b\n            val stId = genid(\"st\")\n            val stR = RL(Tp(stT), stId)\n            add(LLBitCast(stR, maxAdrR))\n\n            // \u767b\u9332\u3059\u308b\n            env.add(RL(stT, stId))\n\n            // \u5404\u30d5\u30a3\u30fc\u30eb\u30c9\u5024\u3092\u8a2d\u5b9a\u3059\u308b\n            for ((e, (id, t)) <- ls.zip(stT.types)) {\n              f(EAssign(t, EField(t, stId, id), e))\n            }\n          case null =>\n          case _ => throw new Exception(\"error\")\n        }\n        RL(t,id)\n      case e @ EVal(t, id, a) =>\n        val t2 = env.stripT(t)\n        t2 match {\n          case t: TStr => f(e.copy(t = t))\n          case t: TVariant => f(e.copy(t = t))\n          case _ =>\n            env.add(RL(t, id))\n            f(a) match {\n              case a =>\n                add(LLAssign(RL(a.t, id), a))\n                RL(a.t, id)\n            }\n        }\n      case EId(t, id) => env.map(id)\n      case EAssign(t, a, b) =>\n        (arr(a), f(b)) match {\n          case (a, b) =>\n            if (env.stripT(t) != env.stripT(b.t)) throw new Exception(\"type mismatch \" + t + \" \" + b.t)\n            add(LLStore(b, a))\n            b\n        }\n      case a: EField =>\n        val a2 = arr(a)\n        val b = gid(a2.t)\n        add(LLLoad(b, a2))\n        b\n      case ESwitch(t: TVariant, a: E, cases: List[(E, E)]) =>\n        val valR = f(a)\n        val tagAdrR = gid(valR.t)\n        add(LLField(tagAdrR, valR, RN(Ti(64), \"0\"), RN(Ti(32), \"0\")))\n\n        val tagR = gid(Ti(32))\n        add(LLLoad(tagR, tagAdrR))\n\n        // \u30c6\u30fc\u30d6\u30eb\u30b8\u30e3\u30f3\u30d7\n        val lbl = genid(\"match\")\n        val ls = for ((ETag(tl: TVariant, id, vs), _) <- cases) yield {\n          val (tagIdx,stT) = findTag(id, 0, tl.ls)\n          (tagIdx.asInstanceOf[Long], lbl + \".\" + tagIdx)\n        }\n        add(LLSwitch(tagR, lbl, ls))\n\n        // \u5404\u30b1\u30fc\u30b9\n        val (_, _, maxT, _) = emit.llvariantInfo(env.stripT(a.t).asInstanceOf[TVariant])\n        for ((ETag(tl: TVariant, id, vs), e) <- cases) {\n          val (tagIdx,stT) = findTag(id, 0, tl.ls)\n          add(LLLabel(lbl + \".\" + tagIdx))\n\n          val maxAdrR = gid(Tp(maxT))\n          add(LLField(maxAdrR, valR, RN(Ti(64), \"0\"), RN(Ti(32), \"1\")))\n\n          val stId = genid(\"st\")\n          val stR = RL(stT, stId)\n          add(LLBitCast(RL(Tp(stT), stId), maxAdrR))\n          env.add(stR)\n\n          for ((e: EVal, (id, t)) <- vs.zip(stT.types)) {\n            f(e.copy(e.t, e.id, EField(t, stId, id)))\n          }\n          f(e)\n          add(LLGoto(lbl))\n        }\n        add(LLLabel(lbl))\n        null\n      case e @ ESwitch(t: T, a: E, cases: List[(E, E)]) =>\n        env.stripT(a.t) match {\n          case t:TVariant => return f(e.copy(t=t))\n          case _ =>\n        }\n        val ra = f(a)\n        val lbl = genid(\"switch\")\n        val (length, ls) = cases.foldLeft(0, List[(Long, String)]()) {\n          case ((n, ls), (ELdc(tl, a), _)) => (n + 1, (a, lbl + n) :: ls)\n          case ((n, ls), (EUnit, _)) => (n + 1, (-1L, lbl + n) :: ls)\n        }\n        add(LLSwitch(ra, lbl, ls.reverse))\n        for((n, (_, e)) <- (0 until cases.length).zip(cases)) {\n          add(LLLabel(lbl + n)); f(e); add(LLGoto(lbl))\n        }\n        add(LLLabel(lbl))\n        null\n      case EType(t: T, id: String) =>\n        env.map = env.map + (id -> RR(t, null))\n        null\n    }\n  }\n\n  def apply(a: E): List[LL] = {\n    ls = List[LL]()\n    f(a)\n    ls.reverse\n  }\n}\n\nobject env {\n  var map = Map[String, R]()\n  def add(r: R) {\n    map = map + (r.id -> r)\n  }\n  def add(id:String, r:R) {\n    map = map + (id -> r)\n  }\n  def findTag(t:TVariant, id:String):TStr = {\n    for((tag,t) <- t.ls) {\n      if(tag==id) return t\n    }\n    throw new Exception(\"not found tag \"+id)\n  }\n  def stripT(t:T):T = {\n    t match {\n      case TDef(id) =>\n        val r = env.map(id)\n        if(r.id != null) throw new Exception(id + \" is not type\")\n        stripT(r.t)\n      case t => t\n    }\n  }\n}\n\nsealed trait LL\ncase class LLCall(id: R, op: R, prms: List[(T, R)]) extends LL\ncase class LLBin(id: R, op: String, a: R, b: R) extends LL\ncase class LLAssign(s: R, d: R) extends LL\ncase class LLField(id1: R, aid: R, z: R, b: R) extends LL\ncase class LLAlloca(id: R) extends LL\ncase class LLLoad(id1: R, id2: R) extends LL\ncase class LLStore(id1: R, id2: R) extends LL\ncase class LLBitCast(did: R, sid:R) extends LL\ncase class LLSwitch(reg:R, label:String, cases:List[(Long,String)]) extends LL\ncase class LLGoto(label:String) extends LL\ncase class LLLabel(s: String) extends LL\n\nobject constFold {\n  var map: Map[R, R] = null\n  def m(v: R): R = {\n    if (map.contains(v)) m(map(v)) else v\n  }\n  def fs(prms: List[(T, R)]): List[(T, R)] = {\n    prms.map {\n      case (t, v) => (t, m(v))\n    }\n  }\n  def apply(ls: List[LL]): List[LL] = {\n    map = Map()\n    ls.foldLeft(List[LL]()) {\n      case (ls, l @ LLCall(id, op, prms)) => l.copy(prms = fs(prms)) :: ls\n      case (ls, l @ LLBin(id, op, a, b)) => l.copy(a = m(a), b = m(b)) :: ls\n      case (ls, l @ LLAssign(s, d)) => map = map + (s -> d); ls\n      case (ls, l @ LLAlloca(id: R)) => l.copy(m(id)) :: ls\n      case (ls, l @ LLField(id, id2, id3, id4)) => l.copy(id, m(id2), m(id3), m(id4)) :: ls\n      case (ls, l @ LLStore(id1, id2)) => l.copy(m(id1), m(id2)) :: ls\n      case (ls, l @ LLLoad(id1, id2)) => l.copy(m(id1), m(id2)) :: ls\n      case (ls, l @ LLBitCast(did, sid)) => l.copy(m(did),m(sid)) :: ls\n      case (ls, l @ LLSwitch(n, lbl, cases)) => l.copy(m(n), lbl, cases)::ls\n      case (ls, l @ LLLabel(_)) => l::ls\n      case (ls, l @ LLGoto(_)) => l::ls\n      case (ls, l) => throw new Exception(\"error no implementation \"+l)\n    }.reverse\n  }\n}\n\nobject emit {\n\n  def llt(t:T):String = {\n    t match {\n      case Ti(i) => \"i\" + i\n      case Tv => \"void\"\n      case TFun(t, ls) => llt(t) + \"(\" + ls.map(llt).mkString(\", \") + \")*\"\n      case t:TStr => llstruct(t)\n      case t:TVariant => llvariant(t)\n      case Tp(t) => llt(t) + \"*\"\n      case t:TDef => llt(env.stripT(t))\n      case Tn => throw new Exception(\"error\")\n    }\n  }\n  // \u30b5\u30a4\u30ba\u8a08\u7b97\n  def size(t:T):Int = {\n    env.stripT(t) match {\n      case t@TStr(ls) =>\n        llstruct(t) // \u69cb\u9020\u4f53\u306e\u767b\u9332\n        ls.foldLeft(0) { case (s,(n,t)) => s + size(t) }\n      case Ti(n) => n / 8\n      case Tv => 0\n      case t:TFun => 8\n      case t:TVariant =>\n        val (_, _, m, _) = llvariantInfo(t)\n        size(m) + 4\n      case Tp(n) => 8\n      case Tn => throw new Exception(\"error\")\n      case t:TDef => throw new Exception(\"error\")\n    }\n  }\n  /**\n   * \u30f4\u30a1\u30ea\u30a2\u30f3\u30c8\u578b\u306e\u60c5\u5831\u3092\u53d6\u5f97\n   * (\u578b\u306e\u540d\u524d, \u69cb\u9020\u4f53, \u6700\u5927\u30b5\u30a4\u30ba\u69cb\u9020\u4f53, \u5185\u90e8\u306e\u69cb\u9020\u4f53\u30ea\u30b9\u30c8)\n   */\n  def llvariantInfo(v:TVariant):(String,TStr,TStr,List[TStr]) = {\n    val (maxsize, maxt, tys) = v.ls.foldLeft((0, null:TStr, List[TStr]())) {\n      case ((n:Int,t,ls),(name:String,vt:T)) =>\n        val sizevt = size(vt)\n        if (sizevt > n) (sizevt, vt,vt::ls) else (n, t,vt::ls)\n    }\n    val t = TStr(List(\"tag\"->Ti(32),\"data\"->maxt))\n    (llstruct(t), t, maxt, tys)\n  }\n\n  def llvariant(v:TVariant):String = {\n    llvariantInfo(v) match {\n      case (s,_,_,_) => s\n    }\n  }\n\n  def llr(r:R): String = {\n    r match {\n      case RG(t,id) => \"@\" + id\n      case RL(t,id) => \"%\" + id\n      case RR(t,id) => \"%.\" + id\n      case RN(t,id) => \"\" + id\n    }\n  }\n\n  def o(id: R, out: String) {\n    if (id != null) asm(llr(id) + \" = \" + out)\n    else asm(out)\n  }\n  def f(l: LL) {\n    l match {\n      case LLCall(id, op, prms) =>\n        val ps = prms.map { case (a, b) => llt(a) + \" \" + llr(b) }.mkString(\", \")\n        o(id, \"call \" + llt(op.t) + \" \" + llr(op) + \"(\" + ps + \") nounwind\")\n      case LLBin(id, op, a, b) =>\n        o(id, op + \" \" + llt(id.t) + \" \" + llr(a) + \", \" + llr(b))\n      case _:LLAssign => throw new Exception(\"error\")\n      case LLField(reg1: R, addr: R, zero: R, a: R) =>\n        o(reg1, \"getelementptr inbounds \" + llt(addr.t) + \"* \" + llr(addr) + \", \" + llt(zero.t) + \" \" + llr(zero) + \", \" + llt(a.t) + \" \" + llr(a))\n      case LLLoad(reg1: R, reg2: R) =>\n        o(reg1, \"load \" + llt(reg1.t) + \"* \" + llr(reg2))\n      case LLStore(reg1: R, reg2: R) =>\n        asm(\"store \" + llt(reg1.t) + \" \" + llr(reg1) + \", \" + llt(reg1.t) + \"* \" + llr(reg2))\n      case LLAlloca(reg: R) =>\n        o(reg, \"alloca \" + llt(reg.t))\n      case LLBitCast(d: R, s:R) =>\n        o(d, \"bitcast \" + llt(s.t) + \" \" + llr(s) + \" to \" + llt(d.t))  \n      case LLSwitch(n, lbl, cases) =>\n        asm(\"switch \"+llt(n.t)+\" \"+llr(n)+\", label %\"+lbl+ \" [\")\n        for((a,b) <- cases) {\n          asm(\"  i32 \" + a + \", label %\"+b)\n        }\n        asm(\"]\")\n      case LLLabel(l) =>\n        asm.label(l+\":\")\n      case LLGoto(l) =>\n        asm(\"br label %\"+l)\n    }\n  }\n\n  var structs: Map[TStr, String] = Map()\n  def llstruct(t: TStr): String = {\n    if (structs.contains(t)) return structs(t)\n    val name = genid(\"%.struct\")\n    structs = structs + (t -> name)\n    name\n  }\n\n  def apply(file: String, ls: List[LL]) {\n    asm.open(file)\n    structs.foreach { case (t, n) =>\n        asm(n + \" = type {\" + t.types.map { case (a, b) => llt(b) }.mkString(\", \") + \"}\")\n    }\n    asm.label(\"@.str = private constant [4 x i8] c\\\"%d\\\\0A\\\\00\\\"\")\n    asm.label(\"define void @print_i32(i32 %a) nounwind ssp {\")\n    asm.label(\"entry:\")\n    asm(\"call i32 (i8*, ...)* @printf(i8* getelementptr inbounds ([4 x i8]* @.str, i64 0, i64 0), i32 %a) nounwind\")\n    asm(\"ret void\")\n    asm.label(\"}\")\n    asm.label(\"define void @print_i8(i8 %a) nounwind ssp {\")\n    asm.label(\"entry:\")\n    asm(\"call i32 (i8*, ...)* @printf(i8* getelementptr inbounds ([4 x i8]* @.str, i64 0, i64 0), i8 %a) nounwind\")\n    asm(\"ret void\")\n    asm.label(\"}\")\n\n    asm.label(\"declare i32 @printf(i8*, ...) nounwind\")\n\n    asm.label(\"define i32 @main() nounwind ssp {\")\n    asm.label(\"entry:\")\n    ls.foreach(f)\n    asm(\"ret i32 0\")\n    asm.label(\"}\")\n    asm.close()\n  }\n}\n\nobject genid {\n  var id = 0\n  def apply(s: String): String = {\n    id += 1\n    s + id\n  }\n}\nobject asm {\n  var p: PrintWriter = null\n  def open(file: String) {\n    p = new PrintWriter(new BufferedWriter(new FileWriter(file)))\n  }\n\n  var indent: String = \"\"\n\n  def apply(s: String, n: String = \"\") {\n    val v = indent + s + \"\\t\" + n + \"\\n\"\n    p.print(v)\n  }\n  def label(s: String) {\n    asm.indent = \"\";\n    apply(s)\n    asm.indent = \"\\t\";\n  }\n  def close() {\n    p.close()\n  }\n}\n\nobject exec {\n  def apply(cmd: String): (Int, String, String) = {\n    val p = Runtime.getRuntime().exec(cmd)\n    val stdin = (readAll(p.getInputStream()))\n    val stderr = (readAll(p.getErrorStream()))\n    (p.waitFor(), stdin, stderr)\n  }\n\n  def readAll(p: InputStream): String = {\n    def f(s: String, i: BufferedReader): String = {\n      i.readLine() match {\n        case null => s\n        case a => f(s + a + \"\\n\", i)\n      }\n    }\n    f(\"\", new BufferedReader(new InputStreamReader(p)))\n  }\n}\n\n\n\u307e\u3068\u3081\n\u7d50\u69cb\u3001\u9577\u3044\u6226\u3044\u3067\u3057\u305f\u3002\u6700\u521d\u306f\u7c21\u5358\u3060\u3068\u601d\u3063\u3066\u59cb\u3081\u305f\u306e\u3067\u3059\u304c\u3001\u30a2\u30ec\u304c\u8db3\u308a\u306a\u3044\u3001\u30b3\u30ec\u304c\u8db3\u308a\u306a\u3044\u3068\u3001\u7d50\u69cb\u8db3\u308a\u306a\u3044\u4e8b\u304c\u591a\u304f\u3066\u3001\u305d\u306e\u8db3\u308a\u306a\u3044\u8981\u7d20\u4e00\u3064\u4e00\u3064\u304c\u7d50\u69cb\u96e3\u3057\u304b\u3063\u305f\u308a\u3057\u307e\u3057\u305f\u3002\u3057\u304b\u3057\u3001\u305d\u308c\u3067\u3082\u30b3\u30c4\u30b3\u30c4\u3068\u8981\u7d20\u3092\u6f70\u3057\u3066\u884c\u304f\u4e8b\u3067\u306a\u3093\u3068\u304b\u304b\u3093\u3068\u304b\u3001\u30d1\u30bf\u30fc\u30f3\u30de\u30c3\u30c1\u3092\u5b9f\u88c5\u51fa\u6765\u307e\u3057\u305f\u3002\n\u3068\u3044\u3046\u3053\u3068\u3067\u3001\u3053\u306e\u8a71\u306f\u3053\u3053\u307e\u3067\u306b\u3057\u3066\u3082\u826f\u3044\u3068\u601d\u3046\u306e\u3067\u3059\u304c\u3001\u30d1\u30fc\u30b5\u3068\u304b\u578b\u30c1\u30a7\u30c3\u30af\u304c\u306a\u3044\u3058\u3083\u306a\u3044\u304b\uff1f\u3063\u3066\u8a00\u3046\u554f\u984c\u304c\u3042\u308b\u306e\u3067\u3001\u3053\u306e\u8a71\u3092\u3082\u3046\u5c11\u3057\u9032\u3081\u3066\u884c\u3063\u3066\u307f\u3088\u3046\u3068\u601d\u3044\u307e\u3059\u3002\n\u3068\u308a\u3042\u3048\u305a\u3001\u30d1\u30fc\u30b5\u3092\u4f5c\u3063\u3066\u3001\u5fc5\u8981\u306a\u3089\u578b\u30c1\u30a7\u30c3\u30af\u3092\u3059\u308b\u3002\u305d\u3046\u3059\u308b\u3053\u3068\u3067\u3001\u304a\u304a\u3001\u30db\u30f3\u30c8\u306b\u30d1\u30bf\u30fc\u30f3\u30de\u30c3\u30c1\u3067\u304d\u308b\u306a\u3068\u5b9f\u611f\u51fa\u6765\u308b\u306f\u305a\u3067\u3059\u3002\n\n\u53c2\u8003\u6587\u732e\n\nM.Hiroi: Common Lisp \u5165\u9580 \u8a18\u53f7\u306e\u30d1\u30bf\u30fc\u30f3\u30de\u30c3\u30c1\u30f3\u30b0\n\u5927\u5800 \u6df3\u3000\u7e93\u5742 \u667a: \u8868\u793a\u7684\u610f\u5473\u8ad6\u306b\u57fa\u3065\u304f\u30d1\u30bf\u30fc\u30f3\u30de\u30c3\u30c1 \u30b3\u30f3\u30d1\u30a4\u30eb\u65b9\u5f0f\u306e\u69cb\u7bc9\u3068\u5b9f\u8df5\n\u5927\u548c\u8c37 \u6f54: \u30d1\u30bf\u30fc\u30f3\u30de\u30c3\u30c1\n\n\u524d\u56de\u306f\u3001\u03b1\u5909\u63db\u3092\u4f5c\u3063\u305f\u306e\u3067\u3001\u4eca\u56de\u3053\u305d\u672c\u5f53\u306b\u30d1\u30bf\u30fc\u30f3\u30de\u30c3\u30c1\u69cb\u6587\u3092\u4f5c\u308b\u3093\u3060\u3088\u3002\u4f55\u56de\u8a00\u3063\u3066\u3093\u3060\u3088\u3002\u4ffa\u3002\n\n## \u5f0f\n\n```Scala\ncase class EMatch(t:T, d:E, cases:List[(ETag,E)]) extends E\n```\n\n## \u4f8b\n\n\u4ee5\u4e0b\u306b\u30de\u30c3\u30c1\u69cb\u6587\u306e\u4f8b\u3092\u793a\u3057\u307e\u3059\u3002\n\n```Scala\n// match\u69cb\u6587\nEMatch(t, \"data2\", List(\n  ETag(t, \"A\", List(EId(\"x\"))) -> EBlock(Tv,List(EPrint(x))),\n  ETag(t, \"B\", List(EId(\"x\"),EId(\"y\"))) -> EBlock(Tv,List(EPrint(x),EPrint(y)))\n))\n```\n\n## \u5b9f\u88c5\n\n\u30c6\u30b9\u30c8\u3092\u5b9f\u88c5\u3057\u3066\u3001\u52d5\u304b\u3057\u3066\u3051\u3070\u305d\u306e\u3046\u3061\u51fa\u6765\u308b\u3088\u3002switch\u6587\u306e\u5b9f\u88c5\u3092\u53c2\u8003\u306b\u3057\u3064\u3064\u3001\u6700\u521d\u306b\u30bf\u30b0\u3092\u53d6\u308a\u51fa\u3057\u3066\u3001switch\u3067\u5206\u5c90\u3057\u3001\u5206\u5c90\u5148\u3067\u306f\u4f55\u3082\u3057\u306a\u3044\u72b6\u614b\u306b\u307e\u305a\u3057\u307e\u3057\u305f\u3002\n\n\u6b21\u306b\u3001\u30d0\u30a4\u30f3\u30c7\u30a3\u30f3\u30b0\u3092\u4f5c\u308a\u307e\u3059\u3002\u03b1\u5909\u63db\u3055\u308c\u3066\u3044\u308b\u306e\u3067\u7279\u306b\u60a9\u307e\u305a\u306b\u3001\u30d0\u30a4\u30f3\u30c7\u30a3\u30f3\u30b0\u306e\u30ed\u30b8\u30c3\u30af\u3092\u66f8\u304d\u307e\u3057\u305f\u3002\u305d\u3057\u3066\u3001\u305d\u308c\u305e\u308c\u306ecase\u306e\u51e6\u7406\u3092\u30b3\u30f3\u30d1\u30a4\u30eb\u3059\u308c\u3070\u51fa\u6765\u4e0a\u304c\u308a\u3067\u3059\u3002switch\u6587\u3088\u308a\u9577\u304f\u306f\u306a\u308a\u307e\u3057\u305f\u304c\u3001\u306a\u3093\u3068\u304b\u4f5c\u308b\u4e8b\u304c\u51fa\u6765\u307e\u3057\u305f\u3002\n\n\u305d\u3046\uff01\u3064\u3044\u306b\u51fa\u6765\u305f\u306e\u3067\u3059\uff01\u3064\u3044\u306b\uff01\u3084\u3063\u305f\uff01\n\n```Scala\npackage chapter11\n\nimport java.io._\nimport util.parsing.input.Positional\n\nsealed trait E extends Positional {\n  def t:T\n}\ncase class ELdc(t:T, i:Long) extends E\ncase class EBin(t:T, s:String, l:E, r:E) extends E\ncase class EPrint(t:T, a:E) extends E\ncase class EBlock(t: T, ls: List[E]) extends E\ncase class EVal(t: T, id: String, a: E) extends E\ncase class EId(t: T, id: String) extends E\ncase class EAssign(t: T, a: E, b: E) extends E\ncase class EField(t: T, id: String, idx: String) extends E\ncase class ETuple(t:T,ls:List[E]) extends E\ncase class ETag(t:T,id:String,ls:List[E]) extends E\ncase class ESwitch(t: T, a: E, cases:List[(E,E)] ) extends E\ncase object EUnit extends E { def t = Tv }\ncase class EType(t:T, id:String) extends E\ncase class ECase(t:T, e:E) extends E\n\nsealed trait T extends Positional\ncase class Ti(i:Int) extends T\ncase object Tv extends T\ncase object Tn extends T\ncase class TFun(t: T, prms: List[T]) extends T\ncase class TStr(types: List[(String, T)]) extends T\ncase class TVariant(ls:List[(String,TStr)]) extends T\ncase class Tp(t:T) extends T\ncase class TDef(id:String) extends T\n\nobject T {\n  def find(t:TStr, a: String): (Int, T) = {\n    def f(i: Int, xs: List[(String, T)]): (Int, T) = {\n      xs match {\n        case List() => (-1, Tv)\n        case (x, t) :: xs => if (a == x) (i, t) else f(i + 1, xs)\n      }\n    }\n    f(0, t.types)\n  }\n}\n\ncase class Op(s: String) {\n  def apply(t: T, a: E, b: E): E = {\n    EBin(t, s, a, b)\n  }\n}\nobject EAdd extends Op(\"add\")\nobject EMul extends Op(\"mul\")\n\nsealed trait R {\n  def t:T\n  def id:String\n}\ncase class RG(t:T, id: String) extends R\ncase class RL(t:T, id: String) extends R\ncase class RR(t:T, id: String) extends R\ncase class RN(t:T, id: String) extends R\n\nobject test {\n  def main(argv: Array[String]) {\n    try {\n      val t = TVariant(List(\n          \"A\"->TStr(List(\"a\"->Ti(32))),\n          \"B\"->TStr(List(\"a\"->Ti(32), \"b\"->Ti(32)))\n        ))\n      val ast = EBlock(Tv, List(\n        EPrint(Ti(32), ELdc(Ti(32), 11)),\n        EPrint(Ti(32), EAdd(Ti(32), ELdc(Ti(32), 11), ELdc(Ti(32), 22))),\n        // \u5909\u6570 a \u5b9a\u6570\n        EVal(Ti(32), \"a\", ELdc(Ti(32), 11)),\n        EPrint(Ti(32), EId(Ti(32), \"a\")),\n        // \u5909\u6570 b \u8db3\u3057\u7b97\n        EVal(Ti(32), \"b\", EAdd(Ti(32), ELdc(Ti(32), 11), ELdc(Ti(32), 22))),\n        EPrint(Ti(32), EId(Ti(32), \"b\")),\n        // \u5909\u6570 c \u5909\u6570\u306e\u5024\n        EVal(Ti(32), \"c\", EId(Ti(32), \"a\")),\n        EPrint(Ti(32), EId(Ti(32), \"c\")),\n        // \u69cb\u9020\u4f53\n        EVal(TStr(List((\"a\", Ti(32)), (\"b\", Ti(32)))), \"aa\", null),\n        EAssign(Ti(32), EField(Ti(32), \"aa\", \"a\"), ELdc(Ti(32), 9)),\n        EAssign(Ti(32), EField(Ti(32), \"aa\", \"b\"), EId(Ti(32), \"c\")),\n        EPrint(Ti(32), EField(Ti(32), \"aa\", \"a\")),\n        EPrint(Ti(32), EField(Ti(32), \"aa\", \"b\")),\n        // \u69cb\u9020\u4f53\u521d\u671f\u5316\u30ea\u30c6\u30e9\u30eb\n        EVal(TStr(List((\"a\", Ti(32)), (\"b\", Ti(32)))), \"ab\",\n          ETuple(TStr(List((\"a\", Ti(32)), (\"b\", Ti(32)))),\n            List(ELdc(Ti(32),123),ELdc(Ti(32),456)))),\n        EPrint(Ti(32), EField(Ti(32), \"ab\", \"a\")),\n        EPrint(Ti(32), EField(Ti(32), \"ab\", \"b\")),\n\n        // \u30f4\u30a1\u30ea\u30a2\u30f3\u30c8\n        EVal(TVariant(List(\n          \"A\"->TStr(List(\"a\"->Ti(32))),\n          \"B\"->TStr(List(\"a\"->Ti(32), \"b\"->Ti(32)))\n        )),\"data\", null),\n\n        EVal(TVariant(List(\n            \"A\"->TStr(List(\"a\"->Ti(32))),\n            \"B\"->TStr(List(\"a\"->Ti(32), \"b\"->Ti(32)))\n          )),\n          \"data2\",\n          ETag(TVariant(List(\n            \"A\"->TStr(List(\"a\"->Ti(32))),\n            \"B\"->TStr(List(\"a\"->Ti(32), \"b\"->Ti(32)))\n            )),\n            \"B\",\n            List(\n              ELdc(Ti(32), 555),\n              ELdc(Ti(32), 777)\n          ))\n        ),\n        // switch\n        ESwitch(Ti(32), ELdc(Ti(32), 2), List(\n          ELdc(Ti(32), 1) -> EPrint(Ti(32), ELdc(Ti(32), 10001)),\n          ELdc(Ti(32), 2) -> EPrint(Ti(32), ELdc(Ti(32), 10002)),\n          ELdc(Ti(32), 3) -> EPrint(Ti(32), ELdc(Ti(32), 10003))\n        )),\n        ESwitch(Ti(32), ELdc(Ti(32), 0), List(\n          ELdc(Ti(32), 1) -> EPrint(Ti(32), ELdc(Ti(32), 10001)),\n          ELdc(Ti(32), 2) -> EPrint(Ti(32), ELdc(Ti(32), 10002)),\n          ELdc(Ti(32), 3) -> EPrint(Ti(32), ELdc(Ti(32), 10003))\n        )),\n        \n        // alpha test\n        EVal(Ti(32), \"a\", ELdc(Ti(32), 1000)),\n        EPrint(Ti(32), EId(Ti(32), \"a\")),\n        EVal(Ti(32), \"a\", EAdd(Ti(32), EId(Ti(32),\"a\"), ELdc(Ti(32),2000))),\n        EPrint(Ti(32), EId(Ti(32), \"a\")),\n        // alpha block test\n        EBlock(Tv, List(\n          EVal(Ti(32), \"a\", ELdc(Ti(32), 5000)),\n          EPrint(Ti(32), EId(Ti(32), \"a\"))\n        )),\n        EPrint(Ti(32), EId(Ti(32), \"a\")),\n\n        // match\u69cb\u6587\n        ESwitch(t, EId(t,\"data2\"), List(\n          ETag(t, \"A\", List(EVal(Ti(32),\"x\",null))) -> EBlock(Tv,List(EPrint(Ti(32),EId(Ti(32),\"x\")))),\n          ETag(t, \"B\", List(EVal(Ti(32),\"x\",null),EVal(Ti(32),\"y\",null))) -> EBlock(Tv,List(EPrint(Ti(32),EId(Ti(32),\"x\")),EPrint(Ti(32),EId(Ti(32),\"y\"))))\n        )),\n\n        EVal(t, \"data3\",\n          ETag(t, \"A\", List(\n              ELdc(Ti(32), 333)\n          ))\n        ),\n        ESwitch(t, EId(t,\"data3\"), List(\n          ETag(t, \"A\", List(EVal(Ti(32),\"x\",null))) -> EBlock(Tv,List(\n              EPrint(Ti(32),EId(Ti(32),\"x\")))),\n          ETag(t, \"B\", List(EVal(Ti(32),\"x\",null),EVal(Ti(32),\"y\",null))) -> EBlock(Tv,List(\n              EPrint(Ti(32),EId(Ti(32),\"x\")),\n              EPrint(Ti(32),EId(Ti(32),\"y\"))))\n        )),\n        EVal(Ti(32),\"x\",ELdc(Ti(32),10)),\n        EPrint(Ti(32),EId(Ti(32),\"x\")),\n        EType(TStr(List((\"a\", Ti(32)), (\"b\", Ti(32)))), \"Dt\"),\n        EVal(TDef(\"Dt\"), \"a2\", null),\n        EAssign(Ti(32), EField(Ti(32), \"a2\", \"a\"), ELdc(Ti(32), 9)),\n        EPrint(Ti(32), EField(Ti(32), \"a2\", \"a\"))\n        \n      ))\n      println(\"ast=\" + ast)\n      val ast2 = alpha(ast)\n      println(\"ast2=\" + ast2)\n      val ll = kNormal(ast2)\n      println(\"ll=\" + ll)\n      val ll2 = constFold(ll)\n      emit(\"e.ll\", ll2)\n      println(exec(\"llc e.ll -o e.s\"))\n      println(exec(\"llvm-gcc -m64 e.s -o e\"))\n      println(exec(\"./e\"))\n    } catch {\n      case e:Throwable => e.printStackTrace()\n    }\n  }\n}\n\nobject alpha {\n\n  def find(id: String, env: Map[String, String]): String = {\n    if (env.contains(id)) env(id) else id\n  }\n\n  def apply(e: E): E = {\n    f(e, Map()) match { case(e, _) => e }\n  }\n  def l(ls:List[E],env:Map[String,String]):(List[E],Map[String, String]) = {\n    val (ls2,env2) = ls.foldLeft(List[E](), env) {\n      case ((ls, env), a) =>\n        val (a1, env1) = f(a, env)\n        ((a1 :: ls), env1)\n    }\n    (ls2.reverse,env2)\n  }\n  def l2(ls:List[(E,E)],env:Map[String,String]):(List[(E,E)],Map[String, String]) = {\n    val (cases1, env2) = ls.foldLeft(List[(E,E)](), env) {\n      case ((ls, env), (a,b)) =>\n        val (a1, env1) = f(a, env)\n        val (b1, env2) = f(b, env1)\n        (((a1,b1) :: ls), env)\n    }\n    (cases1.reverse, env2)\n  }\n  def f(e: E, env: Map[String, String]): (E, Map[String, String]) = {\n    e match {\n      case e @ EBin(t: T, i: String, a: E, b: E) =>\n        val (a1, env1) = f(a, env)\n        val (b1, env2) = f(b, env1)\n        (e.copy(t, i, a1, b1), env2)\n      case e @ ELdc(t: T, i: Long) => (e.copy(t, i), env)\n      case e @ EBlock(t: T, ls: List[E]) =>\n        val (ls1, env1) = l(ls, env)\n        (e.copy(t, ls1), env)\n      case e @ EPrint(t: T, a: E) =>\n        val (a1, env1)  = f(a, env)\n        (e.copy(t, a1), env1)\n      case e @ EVal(t: T, id: String, a) =>\n        val (a1,env1) = if (a == null) (null, env) else f(a, env)\n        val id2 = if (env.contains(id)) genid(\".\") else id\n        (e.copy(t, id2, a1), env1 + (id -> id2))\n      case e @ EId(t: T, id: String) => (e.copy(t, find(id, env)), env)\n      case e @ EField(t: T, id: String, idx: String) =>\n        (e.copy(t, find(id, env), idx), env)\n      case e @ EAssign(t: T, a: E, b: E) =>\n        val (a1, env1) = f(a, env)\n        val (b1, env2) = f(b, env1)\n        (e.copy(t, a1, b1), env2)\n      case e @ ESwitch(t: T, a: E, cases:List[(E,E)]) =>\n        val (a1, env1) = f(a, env)\n        val (cases1, _) = l2(cases, env1)\n        (e.copy(t, a1, cases1), env)\n      case e @ EUnit => (e, env)\n      case e @ ETag(t: T, id:String, ls: List[E]) =>\n        val (ls1, env1) = l(ls, env)\n        (e.copy(t, id, ls1), env1)\n      case e @ ETuple(t:T,ls:List[E]) =>\n        val (ls1, env1) = l(ls, env)\n        (e.copy(t, ls1), env1)\n      case e @ EType(t:T, id:String) => (e.copy(t, id), env)\n      case e : ECase => throw new Exception(\"error\")\n    }\n  }\n}\n\nobject kNormal {\n  def gid(t:T): R = {\n    RR(t,genid(\"\"))\n  }\n  var ls: List[LL] = null\n  def add(l: LL) {\n    ls = l :: ls\n  }\n\n  def arr(e: E): R = {\n    e match {\n      case EField(t, id, idx) =>\n        env.map(id) match {\n          case i:R =>\n            val ((n, nt), reg1) = (T.find(i.t.asInstanceOf[TStr],idx), gid(t))\n            add(LLField(reg1, i, RN(Ti(64),\"0\"), RN(nt,\"\"+n)))\n            reg1\n          case t => throw new Exception(\"type mismatch \" + t)\n        }\n      case EId(t, id) => env.map(id)\n      case _ => throw new Exception(\"error\")\n    }\n  }\n\n  def findTag(tagId:String, n:Int, ls:List[(String, TStr)]):(Int, TStr) = ls match {\n    case List() => throw new Exception(\"not found \"+tagId)\n    case (stId,stT:TStr)::ls => if (stId == tagId) (n,stT) else findTag(tagId, n + 1, ls)\n  }\n\n  def f(a: E): R = {\n    a match {\n      case EBin(t, op, a1, b1) =>\n        (f(a1), f(b1), gid(t)) match {\n          case (a, b, id) =>\n            if (t != a.t || t != b.t) throw new Exception(\"type mismatch \" + t)\n            add(LLBin(id, op, a, b))\n            id\n        }\n      case ELdc(t, i) => RN(t, \"\"+i)\n      case EPrint(t, a) =>\n        f(a) match {\n          case a =>\n            if (t != a.t) throw new Exception(\"type mismatch t=\" + t + \" ta=\" + a.t)\n            add(LLCall(null, RG(TFun(Tv, List(t)), \"print_\" + emit.llt(t)), List((a.t, a))))\n            a\n        }\n      case EBlock(t, ls) =>\n        ls.foldLeft(null: R) {\n          case (tid, l) => f(l)\n        }\n      case EVal(t: TStr, id, tpl) =>\n        emit.llstruct(t)\n        env.add(RL(t,id))\n        add(LLAlloca(RL(t,id)))\n        tpl match {\n          case ETuple(_, ls) =>\n            for ((e, (name, t)) <- ls.zip(t.types)) {\n              f(EAssign(t, EField(t, id, name), e))\n            }\n          case null =>\n          case _ => throw new Exception(\"error\")\n        }\n        RL(t,id)\n      case EVal(t: TVariant, id, tpl) =>\n        val (_, valT, maxT, _) = emit.llvariantInfo(t)\n        env.add(RL(t,id))\n        add(LLAlloca(RL(t,id)))\n        tpl match {\n          case ETag(_, tagId, ls) =>\n            val (tagIdx, stT) = findTag(tagId, 0, t.ls)\n            val tagR = gid(stT)\n            // tag id \u306e\u30a2\u30c9\u30ec\u30b9\u53d6\u5f97\n            add(LLField(tagR, RL(valT, id), RN(Ti(64), \"0\"), RN(Ti(32), \"0\")))\n            // tag id\u4fdd\u5b58\n            add(LLStore(RN(Ti(32),\"\"+tagIdx), tagR))\n\n            // \u5185\u90e8\u306e\u69cb\u9020\u4f53\u306e\u30a2\u30c9\u30ec\u30b9\u3092\u53d6\u5f97\n            val maxAdrR = gid(Tp(maxT))\n            add(LLField(maxAdrR, RL(valT, id), RN(Ti(64), \"0\"), RN(Ti(32), \"1\")))\n\n            // \u30ad\u30e3\u30b9\u30c8\u3059\u308b\n            val stId = genid(\"st\")\n            val stR = RL(Tp(stT), stId)\n            add(LLBitCast(stR, maxAdrR))\n\n            // \u767b\u9332\u3059\u308b\n            env.add(RL(stT, stId))\n\n            // \u5404\u30d5\u30a3\u30fc\u30eb\u30c9\u5024\u3092\u8a2d\u5b9a\u3059\u308b\n            for ((e, (id, t)) <- ls.zip(stT.types)) {\n              f(EAssign(t, EField(t, stId, id), e))\n            }\n          case null =>\n          case _ => throw new Exception(\"error\")\n        }\n        RL(t,id)\n      case e @ EVal(t, id, a) =>\n        val t2 = env.stripT(t)\n        t2 match {\n          case t: TStr => f(e.copy(t = t))\n          case t: TVariant => f(e.copy(t = t))\n          case _ =>\n            env.add(RL(t, id))\n            f(a) match {\n              case a =>\n                add(LLAssign(RL(a.t, id), a))\n                RL(a.t, id)\n            }\n        }\n      case EId(t, id) => env.map(id)\n      case EAssign(t, a, b) =>\n        (arr(a), f(b)) match {\n          case (a, b) =>\n            if (env.stripT(t) != env.stripT(b.t)) throw new Exception(\"type mismatch \" + t + \" \" + b.t)\n            add(LLStore(b, a))\n            b\n        }\n      case a: EField =>\n        val a2 = arr(a)\n        val b = gid(a2.t)\n        add(LLLoad(b, a2))\n        b\n      case ESwitch(t: TVariant, a: E, cases: List[(E, E)]) =>\n        val valR = f(a)\n        val tagAdrR = gid(valR.t)\n        add(LLField(tagAdrR, valR, RN(Ti(64), \"0\"), RN(Ti(32), \"0\")))\n\n        val tagR = gid(Ti(32))\n        add(LLLoad(tagR, tagAdrR))\n\n        // \u30c6\u30fc\u30d6\u30eb\u30b8\u30e3\u30f3\u30d7\n        val lbl = genid(\"match\")\n        val ls = for ((ETag(tl: TVariant, id, vs), _) <- cases) yield {\n          val (tagIdx,stT) = findTag(id, 0, tl.ls)\n          (tagIdx.asInstanceOf[Long], lbl + \".\" + tagIdx)\n        }\n        add(LLSwitch(tagR, lbl, ls))\n\n        // \u5404\u30b1\u30fc\u30b9\n        val (_, _, maxT, _) = emit.llvariantInfo(env.stripT(a.t).asInstanceOf[TVariant])\n        for ((ETag(tl: TVariant, id, vs), e) <- cases) {\n          val (tagIdx,stT) = findTag(id, 0, tl.ls)\n          add(LLLabel(lbl + \".\" + tagIdx))\n\n          val maxAdrR = gid(Tp(maxT))\n          add(LLField(maxAdrR, valR, RN(Ti(64), \"0\"), RN(Ti(32), \"1\")))\n\n          val stId = genid(\"st\")\n          val stR = RL(stT, stId)\n          add(LLBitCast(RL(Tp(stT), stId), maxAdrR))\n          env.add(stR)\n\n          for ((e: EVal, (id, t)) <- vs.zip(stT.types)) {\n            f(e.copy(e.t, e.id, EField(t, stId, id)))\n          }\n          f(e)\n          add(LLGoto(lbl))\n        }\n        add(LLLabel(lbl))\n        null\n      case e @ ESwitch(t: T, a: E, cases: List[(E, E)]) =>\n        env.stripT(a.t) match {\n          case t:TVariant => return f(e.copy(t=t))\n          case _ =>\n        }\n        val ra = f(a)\n        val lbl = genid(\"switch\")\n        val (length, ls) = cases.foldLeft(0, List[(Long, String)]()) {\n          case ((n, ls), (ELdc(tl, a), _)) => (n + 1, (a, lbl + n) :: ls)\n          case ((n, ls), (EUnit, _)) => (n + 1, (-1L, lbl + n) :: ls)\n        }\n        add(LLSwitch(ra, lbl, ls.reverse))\n        for((n, (_, e)) <- (0 until cases.length).zip(cases)) {\n          add(LLLabel(lbl + n)); f(e); add(LLGoto(lbl))\n        }\n        add(LLLabel(lbl))\n        null\n      case EType(t: T, id: String) =>\n        env.map = env.map + (id -> RR(t, null))\n        null\n    }\n  }\n\n  def apply(a: E): List[LL] = {\n    ls = List[LL]()\n    f(a)\n    ls.reverse\n  }\n}\n\nobject env {\n  var map = Map[String, R]()\n  def add(r: R) {\n    map = map + (r.id -> r)\n  }\n  def add(id:String, r:R) {\n    map = map + (id -> r)\n  }\n  def findTag(t:TVariant, id:String):TStr = {\n    for((tag,t) <- t.ls) {\n      if(tag==id) return t\n    }\n    throw new Exception(\"not found tag \"+id)\n  }\n  def stripT(t:T):T = {\n    t match {\n      case TDef(id) =>\n        val r = env.map(id)\n        if(r.id != null) throw new Exception(id + \" is not type\")\n        stripT(r.t)\n      case t => t\n    }\n  }\n}\n\nsealed trait LL\ncase class LLCall(id: R, op: R, prms: List[(T, R)]) extends LL\ncase class LLBin(id: R, op: String, a: R, b: R) extends LL\ncase class LLAssign(s: R, d: R) extends LL\ncase class LLField(id1: R, aid: R, z: R, b: R) extends LL\ncase class LLAlloca(id: R) extends LL\ncase class LLLoad(id1: R, id2: R) extends LL\ncase class LLStore(id1: R, id2: R) extends LL\ncase class LLBitCast(did: R, sid:R) extends LL\ncase class LLSwitch(reg:R, label:String, cases:List[(Long,String)]) extends LL\ncase class LLGoto(label:String) extends LL\ncase class LLLabel(s: String) extends LL\n\nobject constFold {\n  var map: Map[R, R] = null\n  def m(v: R): R = {\n    if (map.contains(v)) m(map(v)) else v\n  }\n  def fs(prms: List[(T, R)]): List[(T, R)] = {\n    prms.map {\n      case (t, v) => (t, m(v))\n    }\n  }\n  def apply(ls: List[LL]): List[LL] = {\n    map = Map()\n    ls.foldLeft(List[LL]()) {\n      case (ls, l @ LLCall(id, op, prms)) => l.copy(prms = fs(prms)) :: ls\n      case (ls, l @ LLBin(id, op, a, b)) => l.copy(a = m(a), b = m(b)) :: ls\n      case (ls, l @ LLAssign(s, d)) => map = map + (s -> d); ls\n      case (ls, l @ LLAlloca(id: R)) => l.copy(m(id)) :: ls\n      case (ls, l @ LLField(id, id2, id3, id4)) => l.copy(id, m(id2), m(id3), m(id4)) :: ls\n      case (ls, l @ LLStore(id1, id2)) => l.copy(m(id1), m(id2)) :: ls\n      case (ls, l @ LLLoad(id1, id2)) => l.copy(m(id1), m(id2)) :: ls\n      case (ls, l @ LLBitCast(did, sid)) => l.copy(m(did),m(sid)) :: ls\n      case (ls, l @ LLSwitch(n, lbl, cases)) => l.copy(m(n), lbl, cases)::ls\n      case (ls, l @ LLLabel(_)) => l::ls\n      case (ls, l @ LLGoto(_)) => l::ls\n      case (ls, l) => throw new Exception(\"error no implementation \"+l)\n    }.reverse\n  }\n}\n\nobject emit {\n\n  def llt(t:T):String = {\n    t match {\n      case Ti(i) => \"i\" + i\n      case Tv => \"void\"\n      case TFun(t, ls) => llt(t) + \"(\" + ls.map(llt).mkString(\", \") + \")*\"\n      case t:TStr => llstruct(t)\n      case t:TVariant => llvariant(t)\n      case Tp(t) => llt(t) + \"*\"\n      case t:TDef => llt(env.stripT(t))\n      case Tn => throw new Exception(\"error\")\n    }\n  }\n  // \u30b5\u30a4\u30ba\u8a08\u7b97\n  def size(t:T):Int = {\n    env.stripT(t) match {\n      case t@TStr(ls) =>\n        llstruct(t) // \u69cb\u9020\u4f53\u306e\u767b\u9332\n        ls.foldLeft(0) { case (s,(n,t)) => s + size(t) }\n      case Ti(n) => n / 8\n      case Tv => 0\n      case t:TFun => 8\n      case t:TVariant =>\n        val (_, _, m, _) = llvariantInfo(t)\n        size(m) + 4\n      case Tp(n) => 8\n      case Tn => throw new Exception(\"error\")\n      case t:TDef => throw new Exception(\"error\")\n    }\n  }\n  /**\n   * \u30f4\u30a1\u30ea\u30a2\u30f3\u30c8\u578b\u306e\u60c5\u5831\u3092\u53d6\u5f97\n   * (\u578b\u306e\u540d\u524d, \u69cb\u9020\u4f53, \u6700\u5927\u30b5\u30a4\u30ba\u69cb\u9020\u4f53, \u5185\u90e8\u306e\u69cb\u9020\u4f53\u30ea\u30b9\u30c8)\n   */\n  def llvariantInfo(v:TVariant):(String,TStr,TStr,List[TStr]) = {\n    val (maxsize, maxt, tys) = v.ls.foldLeft((0, null:TStr, List[TStr]())) {\n      case ((n:Int,t,ls),(name:String,vt:T)) =>\n        val sizevt = size(vt)\n        if (sizevt > n) (sizevt, vt,vt::ls) else (n, t,vt::ls)\n    }\n    val t = TStr(List(\"tag\"->Ti(32),\"data\"->maxt))\n    (llstruct(t), t, maxt, tys)\n  }\n\n  def llvariant(v:TVariant):String = {\n    llvariantInfo(v) match {\n      case (s,_,_,_) => s\n    }\n  }\n\n  def llr(r:R): String = {\n    r match {\n      case RG(t,id) => \"@\" + id\n      case RL(t,id) => \"%\" + id\n      case RR(t,id) => \"%.\" + id\n      case RN(t,id) => \"\" + id\n    }\n  }\n  \n  def o(id: R, out: String) {\n    if (id != null) asm(llr(id) + \" = \" + out)\n    else asm(out)\n  }\n  def f(l: LL) {\n    l match {\n      case LLCall(id, op, prms) =>\n        val ps = prms.map { case (a, b) => llt(a) + \" \" + llr(b) }.mkString(\", \")\n        o(id, \"call \" + llt(op.t) + \" \" + llr(op) + \"(\" + ps + \") nounwind\")\n      case LLBin(id, op, a, b) =>\n        o(id, op + \" \" + llt(id.t) + \" \" + llr(a) + \", \" + llr(b))\n      case _:LLAssign => throw new Exception(\"error\")\n      case LLField(reg1: R, addr: R, zero: R, a: R) =>\n        o(reg1, \"getelementptr inbounds \" + llt(addr.t) + \"* \" + llr(addr) + \", \" + llt(zero.t) + \" \" + llr(zero) + \", \" + llt(a.t) + \" \" + llr(a))\n      case LLLoad(reg1: R, reg2: R) =>\n        o(reg1, \"load \" + llt(reg1.t) + \"* \" + llr(reg2))\n      case LLStore(reg1: R, reg2: R) =>\n        asm(\"store \" + llt(reg1.t) + \" \" + llr(reg1) + \", \" + llt(reg1.t) + \"* \" + llr(reg2))\n      case LLAlloca(reg: R) =>\n        o(reg, \"alloca \" + llt(reg.t))\n      case LLBitCast(d: R, s:R) =>\n        o(d, \"bitcast \" + llt(s.t) + \" \" + llr(s) + \" to \" + llt(d.t))  \n      case LLSwitch(n, lbl, cases) =>\n        asm(\"switch \"+llt(n.t)+\" \"+llr(n)+\", label %\"+lbl+ \" [\")\n        for((a,b) <- cases) {\n          asm(\"  i32 \" + a + \", label %\"+b)\n        }\n        asm(\"]\")\n      case LLLabel(l) =>\n        asm.label(l+\":\")\n      case LLGoto(l) =>\n        asm(\"br label %\"+l)\n    }\n  }\n\n  var structs: Map[TStr, String] = Map()\n  def llstruct(t: TStr): String = {\n    if (structs.contains(t)) return structs(t)\n    val name = genid(\"%.struct\")\n    structs = structs + (t -> name)\n    name\n  }\n\n  def apply(file: String, ls: List[LL]) {\n    asm.open(file)\n    structs.foreach { case (t, n) =>\n        asm(n + \" = type {\" + t.types.map { case (a, b) => llt(b) }.mkString(\", \") + \"}\")\n    }\n    asm.label(\"@.str = private constant [4 x i8] c\\\"%d\\\\0A\\\\00\\\"\")\n    asm.label(\"define void @print_i32(i32 %a) nounwind ssp {\")\n    asm.label(\"entry:\")\n    asm(\"call i32 (i8*, ...)* @printf(i8* getelementptr inbounds ([4 x i8]* @.str, i64 0, i64 0), i32 %a) nounwind\")\n    asm(\"ret void\")\n    asm.label(\"}\")\n    asm.label(\"define void @print_i8(i8 %a) nounwind ssp {\")\n    asm.label(\"entry:\")\n    asm(\"call i32 (i8*, ...)* @printf(i8* getelementptr inbounds ([4 x i8]* @.str, i64 0, i64 0), i8 %a) nounwind\")\n    asm(\"ret void\")\n    asm.label(\"}\")\n\n    asm.label(\"declare i32 @printf(i8*, ...) nounwind\")\n\n    asm.label(\"define i32 @main() nounwind ssp {\")\n    asm.label(\"entry:\")\n    ls.foreach(f)\n    asm(\"ret i32 0\")\n    asm.label(\"}\")\n    asm.close()\n  }\n}\n\nobject genid {\n  var id = 0\n  def apply(s: String): String = {\n    id += 1\n    s + id\n  }\n}\nobject asm {\n  var p: PrintWriter = null\n  def open(file: String) {\n    p = new PrintWriter(new BufferedWriter(new FileWriter(file)))\n  }\n\n  var indent: String = \"\"\n\n  def apply(s: String, n: String = \"\") {\n    val v = indent + s + \"\\t\" + n + \"\\n\"\n    p.print(v)\n  }\n  def label(s: String) {\n    asm.indent = \"\";\n    apply(s)\n    asm.indent = \"\\t\";\n  }\n  def close() {\n    p.close()\n  }\n}\n\nobject exec {\n  def apply(cmd: String): (Int, String, String) = {\n    val p = Runtime.getRuntime().exec(cmd)\n    val stdin = (readAll(p.getInputStream()))\n    val stderr = (readAll(p.getErrorStream()))\n    (p.waitFor(), stdin, stderr)\n  }\n\n  def readAll(p: InputStream): String = {\n    def f(s: String, i: BufferedReader): String = {\n      i.readLine() match {\n        case null => s\n        case a => f(s + a + \"\\n\", i)\n      }\n    }\n    f(\"\", new BufferedReader(new InputStreamReader(p)))\n  }\n}\n```\n\n## \u307e\u3068\u3081\n\n\u7d50\u69cb\u3001\u9577\u3044\u6226\u3044\u3067\u3057\u305f\u3002\u6700\u521d\u306f\u7c21\u5358\u3060\u3068\u601d\u3063\u3066\u59cb\u3081\u305f\u306e\u3067\u3059\u304c\u3001\u30a2\u30ec\u304c\u8db3\u308a\u306a\u3044\u3001\u30b3\u30ec\u304c\u8db3\u308a\u306a\u3044\u3068\u3001\u7d50\u69cb\u8db3\u308a\u306a\u3044\u4e8b\u304c\u591a\u304f\u3066\u3001\u305d\u306e\u8db3\u308a\u306a\u3044\u8981\u7d20\u4e00\u3064\u4e00\u3064\u304c\u7d50\u69cb\u96e3\u3057\u304b\u3063\u305f\u308a\u3057\u307e\u3057\u305f\u3002\u3057\u304b\u3057\u3001\u305d\u308c\u3067\u3082\u30b3\u30c4\u30b3\u30c4\u3068\u8981\u7d20\u3092\u6f70\u3057\u3066\u884c\u304f\u4e8b\u3067\u306a\u3093\u3068\u304b\u304b\u3093\u3068\u304b\u3001\u30d1\u30bf\u30fc\u30f3\u30de\u30c3\u30c1\u3092\u5b9f\u88c5\u51fa\u6765\u307e\u3057\u305f\u3002\n\n\u3068\u3044\u3046\u3053\u3068\u3067\u3001\u3053\u306e\u8a71\u306f\u3053\u3053\u307e\u3067\u306b\u3057\u3066\u3082\u826f\u3044\u3068\u601d\u3046\u306e\u3067\u3059\u304c\u3001\u30d1\u30fc\u30b5\u3068\u304b\u578b\u30c1\u30a7\u30c3\u30af\u304c\u306a\u3044\u3058\u3083\u306a\u3044\u304b\uff1f\u3063\u3066\u8a00\u3046\u554f\u984c\u304c\u3042\u308b\u306e\u3067\u3001\u3053\u306e\u8a71\u3092\u3082\u3046\u5c11\u3057\u9032\u3081\u3066\u884c\u3063\u3066\u307f\u3088\u3046\u3068\u601d\u3044\u307e\u3059\u3002\n\n\u3068\u308a\u3042\u3048\u305a\u3001\u30d1\u30fc\u30b5\u3092\u4f5c\u3063\u3066\u3001\u5fc5\u8981\u306a\u3089\u578b\u30c1\u30a7\u30c3\u30af\u3092\u3059\u308b\u3002\u305d\u3046\u3059\u308b\u3053\u3068\u3067\u3001\u304a\u304a\u3001\u30db\u30f3\u30c8\u306b\u30d1\u30bf\u30fc\u30f3\u30de\u30c3\u30c1\u3067\u304d\u308b\u306a\u3068\u5b9f\u611f\u51fa\u6765\u308b\u306f\u305a\u3067\u3059\u3002\n\n\n## \u53c2\u8003\u6587\u732e\n\n- [M.Hiroi: Common Lisp \u5165\u9580 \u8a18\u53f7\u306e\u30d1\u30bf\u30fc\u30f3\u30de\u30c3\u30c1\u30f3\u30b0](http://www.geocities.jp/m_hiroi/xyzzy_lisp/abclisp22.html)\n- [\u5927\u5800 \u6df3\u3000\u7e93\u5742 \u667a: \u8868\u793a\u7684\u610f\u5473\u8ad6\u306b\u57fa\u3065\u304f\u30d1\u30bf\u30fc\u30f3\u30de\u30c3\u30c1 \u30b3\u30f3\u30d1\u30a4\u30eb\u65b9\u5f0f\u306e\u69cb\u7bc9\u3068\u5b9f\u8df5](https://www.jstage.jst.go.jp/article/jssst/24/2/24_2_2_113/_pdf)\n- [\u5927\u548c\u8c37 \u6f54: \u30d1\u30bf\u30fc\u30f3\u30de\u30c3\u30c1](http://www.geocities.jp/sanpukoubou/SanpuKouron/pattern.pdf)\n", "tags": ["\u30d1\u30bf\u30fc\u30f3\u30de\u30c3\u30c1", "\u30b3\u30f3\u30d1\u30a4\u30e9", "Scala"]}