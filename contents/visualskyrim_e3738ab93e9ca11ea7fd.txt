{"tags": ["Scala", "spray"], "context": " More than 1 year has passed since last update.Spray is an elegant Framework in many ways. Here is my opinion on how to arrange your controllers(actions) in your projects, so that you can easily maintain them and test them.\nProject structure\n\nControllers\nYou will find that I didn't use class to extend Actor. I only use trait in these files.\n\nPreferenceService.scala\npackage com.yours.services\n\nimport spray.routing._\nimport spray.http._\n\ntrait PreferenceService extends HttpService {\n  val preferenceRoute =\n    path(\"prefer\") {\n      get {\n        complete(\"ok\")\n      }\n    }\n}\n\n\n\nFeedService.scala\npackage com.yours.services\n\nimport spray.routing._\nimport spray.http._\n\ntrait PreferenceService extends HttpService {\n  val preferenceRoute =\n    path(\"prefer\") {\n      get {\n        complete(\"ok\")\n      }\n    }\n}\n\n\nRoutes\nHere is your route actor, which will combine all the controller traits.\n\nRoutes.scala\npackage com.yours\n\nimport akka.actor.{ActorRefFactory, Actor}\nimport com.yours.services.{UserService, FeedService, PreferenceService}\n\n/**\n * Created by visualskyrim on 12/25/14.\n */\nclass RoutesActor extends Actor with Routes {\n  override val actorRefFactory: ActorRefFactory = context\n  def receive = runRoute(routes)\n}\n\ntrait Routes extends UserService with FeedService with PreferenceService {\n  val routes = {\n    userRoute ~\n    feedRoute ~\n    preferenceRoute\n  }\n}\n\n\nBoot\nThis part is like Global in Play framework, used to start your application. We launch our route actor here.\nimport akka.actor.{ActorSystem, Props}\nimport akka.io.IO\nimport com.yours.utils.db.DbSupport\nimport com.yours.RoutesActor\nimport spray.can.Http\nimport akka.pattern.ask\nimport akka.util.Timeout\nimport scala.concurrent.duration._\n\nimport com.yours.utils.DynamodbSupport\n\nobject Boot extends App with DbSupport with DynamodbSupport {\n  implicit val system = ActorSystem(\"your-api\")\n\n  val service = system.actorOf(Props[RoutesActor], \"your-service\")\n\n  implicit val timeout = Timeout(5.seconds)\n  IO(Http) ? Http.Bind(service, interface = \"localhost\", port = 8080)\n  // initialize the helpers\n  // initialize the Db\n  initTables()\n  initDynamoDbTables()\n}\n\n\nBenefits\nI believe this arrangement fits most cases. \n\nMost people would like request handler to be separated in several files, grouping the controllers according to the related features. If people want to change anything or add anything, they can easily locate the place.\nIt's clean. There will be no association with the Akka system in the middle of your real logic.\nYou might have noticed that since we use trait to build controllers, we can test our controllers without getting hands dirty with Akka.\n\n[Spray](http://spray.io/) is an elegant Framework in many ways. Here is my opinion on how to arrange your controllers(actions) in your projects, so that you can easily maintain them and test them.\n\n***Project structure***\n\n![UserService_scala_-__badboy-api__-_badboy-api_-____Documents_projects_badboy-api_.png](https://qiita-image-store.s3.amazonaws.com/0/39824/109076a7-1c37-5c0c-0ee9-c40d034c86ef.png)\n\n\n***Controllers***\n\nYou will find that I didn't use `class` to extend `Actor`. I only use `trait` in these files.\n\n```scala:PreferenceService.scala\npackage com.yours.services\n\nimport spray.routing._\nimport spray.http._\n\ntrait PreferenceService extends HttpService {\n  val preferenceRoute =\n    path(\"prefer\") {\n      get {\n        complete(\"ok\")\n      }\n    }\n}\n```\n\n```scala:FeedService.scala\npackage com.yours.services\n\nimport spray.routing._\nimport spray.http._\n\ntrait PreferenceService extends HttpService {\n  val preferenceRoute =\n    path(\"prefer\") {\n      get {\n        complete(\"ok\")\n      }\n    }\n}\n```\n\n***Routes***\n\nHere is your **route actor**, which will combine all the controller traits.\n\n```scala:Routes.scala\npackage com.yours\n\nimport akka.actor.{ActorRefFactory, Actor}\nimport com.yours.services.{UserService, FeedService, PreferenceService}\n\n/**\n * Created by visualskyrim on 12/25/14.\n */\nclass RoutesActor extends Actor with Routes {\n  override val actorRefFactory: ActorRefFactory = context\n  def receive = runRoute(routes)\n}\n\ntrait Routes extends UserService with FeedService with PreferenceService {\n  val routes = {\n    userRoute ~\n    feedRoute ~\n    preferenceRoute\n  }\n}\n```\n\n***Boot***\n\nThis part is like `Global` in Play framework, used to start your application. We launch our route actor here.\n\n```scala\nimport akka.actor.{ActorSystem, Props}\nimport akka.io.IO\nimport com.yours.utils.db.DbSupport\nimport com.yours.RoutesActor\nimport spray.can.Http\nimport akka.pattern.ask\nimport akka.util.Timeout\nimport scala.concurrent.duration._\n\nimport com.yours.utils.DynamodbSupport\n\nobject Boot extends App with DbSupport with DynamodbSupport {\n  implicit val system = ActorSystem(\"your-api\")\n\n  val service = system.actorOf(Props[RoutesActor], \"your-service\")\n\n  implicit val timeout = Timeout(5.seconds)\n  IO(Http) ? Http.Bind(service, interface = \"localhost\", port = 8080)\n  // initialize the helpers\n  // initialize the Db\n  initTables()\n  initDynamoDbTables()\n}\n```\n\n# Benefits\n\nI believe this arrangement fits most cases. \n\n- Most people would like request handler to be separated in several files, grouping the controllers according to the related features. If people want to change anything or add anything, they can easily locate the place.\n- It's clean. There will be no association with the Akka system in the middle of your real logic.\n- You might have noticed that since we use trait to build controllers, we can test our controllers without getting hands dirty with Akka.\n"}