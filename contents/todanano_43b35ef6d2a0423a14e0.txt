{"context": " More than 1 year has passed since last update.\na.cpp\n#include <sys/types.h>\n#include <sys/wait.h>\n#include <unistd.h>\n\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <string>\n\nvoid dummy_handler(int) {\n}\n\nvoid set_sigaction(int sig) {\n    struct sigaction sa;\n    memset(&sa, 0, sizeof(struct sigaction));\n    sa.sa_handler = &dummy_handler;\n    sigemptyset(&sa.sa_mask);\n    errno = 0;\n    if (sigaction(sig, &sa, nullptr)) {\n        printf(\"sigaction fail. %s\\n\", strerror(errno));\n        exit(1);\n    }\n}\n\nint main(int argc, char **argv) {\n\n    set_sigaction(SIGHUP);\n    set_sigaction(SIGINT);\n    set_sigaction(SIGQUIT);\n    set_sigaction(SIGTERM);\n\n    sigset_t newss;\n    sigemptyset(&newss);\n    sigaddset(&newss, SIGCHLD);\n    sigaddset(&newss, SIGUSR1);\n    sigaddset(&newss, SIGALRM);\n    sigaddset(&newss, SIGHUP);\n    sigaddset(&newss, SIGINT);\n    sigaddset(&newss, SIGQUIT);\n    sigaddset(&newss, SIGTERM);\n    sigprocmask(SIG_BLOCK, &newss, nullptr);\n\n    int status = 0;\n    int stdout_fd[2];\n    int stderr_fd[2];\n\n    if (pipe(stdout_fd) < 0) {\n        printf(\"pipe fail. %s\\n\", strerror(errno));\n        return 1;\n    }\n    if (pipe(stderr_fd) < 0) {\n        printf(\"pipe fail. %s\\n\", strerror(errno));\n        close(stdout_fd[0]);\n        close(stdout_fd[1]);\n        return 1;\n    }\n\n    pid_t pid = fork();\n    if (pid < 0) {\n        printf(\"fork fail. %s\\n\", strerror(errno));\n        close(stdout_fd[0]);\n        close(stdout_fd[1]);\n        close(stderr_fd[0]);\n        close(stderr_fd[1]);\n        return 1;\n    } else if (pid == 0) {\n        // \u5b50\u306e\u8aad\u307f\u8fbc\u307f\u5074\u3092\u30af\u30ed\u30fc\u30ba\u3002\u5b50\u306f\u66f8\u304f\u3060\u3051\u3002\n        close(stdout_fd[0]);\n        close(stderr_fd[0]);\n\n        // 2\u672c\u3042\u308b\u30d1\u30a4\u30d7\u306e\u3046\u3061\u3001\u3069\u3061\u3089\u304b\uff08\u3042\u308b\u3044\u306f\u4e21\u65b9\uff09\u304c\u3001STDOUT\u304bSTDERR\u3092\u3059\u3067\u306b\u4f7f\u3063\u3066\u3044\u308b\u5834\u5408\u3001\n        // \u7247\u65b9\u3092dup2\u3067\u3064\u306a\u304e\u306a\u304a\u3059\u3068\u3001\u3082\u3046\u7247\u65b9\u306e\u89aa\u30d7\u30ed\u30bb\u30b9\u3068\u3064\u306a\u304c\u3063\u3066\u3044\u308b\u30d1\u30a4\u30d7\u3092\u9589\u3058\u3066\u3057\u307e\u3046\u53ef\u80fd\u6027\u304c\u3042\u308b\u3002\n        // \u306a\u306e\u3067\u3001\u73fe\u72b6\u30d1\u30a4\u30d7\u3067\u3064\u306a\u304c\u3063\u3066\u3044\u308b\u5185\u5bb9\u3092\u3001STDOUT\u3001STDERR\u4ee5\u5916\u306e\u5024\u306b\u306a\u308b\u3088\u3046\u306b\u3057\u3066\u304b\u3089\u3001\n        // \u6539\u3081\u3066\u3001STDOUT\u3068STDERR\u306b\u3064\u306a\u304e\u306a\u304a\u3059\u3002\n        int basefd = stdout_fd[1] > stderr_fd[1] ? stdout_fd[1] : stderr_fd[1];\n        int outfd = basefd + 3;\n        int errfd = basefd + 4;\n        dup2(stdout_fd[1], outfd); // outfd\u304c\u958b\u3044\u3066\u3044\u305f\u3068\u3057\u3066\u3082\u3001\u4e00\u65e6\u9589\u3058\u3066stdout_fd[1]\u306e\u5185\u5bb9\u3092\u6307\u3059\u3088\u3046\u306bopen\u3059\u308b\u3002\n        dup2(stderr_fd[1], errfd); // errfd\u304c\u958b\u3044\u3066\u3044\u305f\u3068\u3057\u3066\u3082\u3001\u4e00\u65e6\u9589\u3058\u3066stderr_fd[1]\u306e\u5185\u5bb9\u3092\u6307\u3059\u3088\u3046\u306bopen\u3059\u308b\u3002\n        close(stdout_fd[1]); // stdout_fd[1]\u306f\u3001\u3053\u308c\u3067\u4e0d\u8981\u3002\n        close(stderr_fd[1]); // stderr_fd[1]\u306f\u3001\u3053\u308c\u3067\u4e0d\u8981\u3002\n        dup2(outfd, 1); // 1\u304c\u958b\u3044\u3066\u3044\u305f\u3068\u3057\u3066\u3082\u3001\u4e00\u65e6\u9589\u3058\u3066outfd\u306e\u5185\u5bb9\u3092\u6307\u3059\u3088\u3046\u306bopen\u3059\u308b\u3002\n        dup2(errfd, 2); // 2\u304c\u958b\u3044\u3066\u3044\u305f\u3068\u3057\u3066\u3082\u3001\u4e00\u65e6\u9589\u3058\u3066errfd\u306e\u5185\u5bb9\u3092\u6307\u3059\u3088\u3046\u306bopen\u3059\u308b\u3002\n        close(outfd); // outfd\u306f\u3001\u3053\u308c\u3067\u4e0d\u8981\u3002\n        close(errfd); // errfd\u306f\u3001\u3053\u308c\u3067\u4e0d\u8981\u3002\n\n        // \u4e0a\u8a18\u306e\u3064\u306a\u304e\u5909\u3048\u306e\u6d41\u308c\n        // \u5b50\u30d7\u30ed\u30bb\u30b9\u8d77\u52d5\u6642\u306b\u3001stdout_fd[1]\u304c1\u3001stderr_fd[1]\u304c3\u3068\u3057\u305f\u5834\u5408\u3002\n        // stdout_fd[1] = 1 -> outfd = 6 -> dup2(6, 1) ... \u89aa\u306e\u30d1\u30a4\u30d7(stdout)\u3092\u6307\u3059fd\u304c\u30011 -> 6 -> 1\u3068\u3044\u3046\u3088\u3046\u306b\u5909\u5316\u3059\u308b\u3002\n        // stderr_fd[1] = 3 -> errfd = 7 -> dup2(7, 2) ... \u89aa\u306e\u30d1\u30a4\u30d7\uff08stderr\uff09\u3092\u6307\u3059fd\u304c\u30013 -> 7 -> 2\u3068\u3044\u3046\u3088\u3046\u306b\u5909\u5316\u3059\u308b\u3002\n        // \u89aa\u30d7\u30ed\u30bb\u30b9\u5074\u3067\u3001fork\u524d\u306bfd6\u3001fd7\u3092\u4f55\u304b\u958b\u3044\u3066\u3044\u305f\u5834\u5408\u3067\u3082\u3001\u5b50\u30d7\u30ed\u30bb\u30b9\u5074\u3067\u9589\u3058\u3066\u3082\u89aa\u30d7\u30ed\u30bb\u30b9\u5074\u306b\u5f71\u97ff\u306f\u7121\u3044\u3002\n\n        // \u89aa\u304b\u3089\u901a\u77e5\u3055\u308c\u308bUSER1\u30b7\u30b0\u30ca\u30eb\u3092\u30c1\u30a7\u30c3\u30af\u3002USER1\u30b7\u30b0\u30ca\u30eb\u304c\u6765\u308b\u307e\u3067\u5f85\u6a5f\u3002\n        // \u4e0d\u6e2c\u306e\u4e8b\u614b\u304c\u591a\u767a\u3059\u308b\u5834\u5408\u3001sigwait\u3067\u306f\u7121\u304f\u3001sigtimedwait\u3092\u4f7f\u3063\u3066\u4e00\u5b9a\u6642\u9593\u3067\u629c\u3051\u305f\u307b\u3046\u304c\u826f\u3044\u304b\u3082\u77e5\u308c\u306a\u3044\u3002\n        sigset_t ss;\n        sigemptyset(&ss);\n        sigaddset(&ss, SIGUSR1);\n        int sig;\n        sigwait(&ss, &sig);\n\n        // \u9069\u5f53\u306a\u6587\u5b57\u5217\u3092\u89aa\u30d7\u30ed\u30bb\u30b9\u306b\u9001\u308b\u3002\n        for (int i = 0; i < 3; ++i) {\n            for (int ii = 0; ii < 5; ++ii) {\n                write(1, \"abcabcabc\\n\", 10);\n                write(2, \"123123123\\n\", 10);\n            }\n        }\n\n        // \u3053\u3053\u3067exec\u3057\u3066\u3082\u3001\u554f\u984c\u306a\u304f\u5185\u5bb9\u3092\u53d7\u3051\u53d6\u308c\u308b\u3001\u306f\u305a\u3002\n        execlp(\"ps\", \"ps\", \"aux\" , nullptr); \n        perror(\"execlp\");\n        _exit(1);\n    }\n\n    // \u89aa\u306e\u66f8\u304d\u8fbc\u307f\u5074\u3092\u30af\u30ed\u30fc\u30ba\u3002\u89aa\u306f\u8aad\u3080\u3060\u3051\u3002\n    close(stdout_fd[1]);\n    close(stderr_fd[1]);\n\n    // \u89aa\u5074\u6e96\u5099\u5b8c\u4e86\u3002\u5b50\u306b\u901a\u77e5\u3059\u308b\u3002\n    kill(pid, SIGUSR1);\n\n    fd_set read_set_master;\n    FD_ZERO(&read_set_master);\n    FD_SET(stdout_fd[0], &read_set_master);\n    FD_SET(stderr_fd[0], &read_set_master);\n    struct timespec waitval;\n    waitval.tv_sec = 10;\n    waitval.tv_nsec = 0;\n    fd_set read_set;\n    int basefd = stdout_fd[0] > stderr_fd[0] ? stdout_fd[0] : stderr_fd[0];\n    char buf[4096];\n\n    std::string out;\n    std::string err;\n\n    // \u7d42\u4e86\u7528\u306e\u30b7\u30b0\u30ca\u30eb\u3092\u53d7\u3051\u305f\u5834\u5408\u306f\u3001pselect\u3092\u629c\u3051\u305f\u3044\u3002\n    // SIGCHILD\u3001SIGUSER1\u3001SIGALRM\u306e\u30d6\u30ed\u30c3\u30af\u306f\u7d99\u7d9a\u3057\u3064\u3064\u3001\n    // SIGHUP\u3001SIGINT\u3001SIGQUIT\u3001SIGTERM\u3092\u53d7\u3051\u4ed8\u3051\u305f\u3044\u3002\n    sigset_t ss;\n    sigemptyset(&ss);\n    sigaddset(&newss, SIGCHLD);\n    sigaddset(&newss, SIGUSR1);\n    sigaddset(&newss, SIGALRM);\n\n    // \u5b50\u304b\u3089\u306e\u5fdc\u7b54\u3092\u5f85\u3064\u3002\n    while (1) {\n        memcpy(&read_set, &read_set_master, sizeof(read_set_master));\n        int r = pselect(basefd + 1, &read_set, nullptr, nullptr, &waitval, &ss);\n        if (r == 0) {\n            printf(\"select timeout.\\n\");\n            printf(\"kill. pid=%d, sig=%d\\n\", pid, SIGTERM);\n            kill(pid, SIGTERM);\n            break;\n        } else if (r < 0) {\n            printf(\"select fail. %s\\n\", strerror(errno));\n            printf(\"kill. pid=%d, sig=%d\\n\", pid, SIGTERM);\n            kill(pid, SIGTERM);\n            break;\n        }\n        // \u7d50\u69cb\u5358\u7d14\u306b\u3001\u3001\u3001\n        // stdout\u3001stderr\u304c\u4e21\u65b90\u306b\u306a\u3063\u305f\u3089\u3001\u3082\u3046\u8aad\u3080\u3082\u306e\u306a\u3057\u3001\u3001\u3067\u826f\u3055\u305d\u3046?\n        bool end_flag = true;\n        if (FD_ISSET(stdout_fd[0], &read_set)) {\n            ssize_t ret = read(stdout_fd[0], buf, 4096);\n            if(ret > 0) {\n                end_flag = false;\n                buf[ret] = '\\0';\n                out += buf;\n            }\n        }\n        if (FD_ISSET(stderr_fd[0], &read_set)) {\n            ssize_t ret = read(stderr_fd[0], buf, 4096);\n            if(ret > 0) {\n                end_flag = false;\n                buf[ret] = '\\0';\n                err += buf;\n            }\n        }\n        if (end_flag) {\n            break;\n        }\n    }\n    close(stdout_fd[0]);\n    close(stderr_fd[0]);\n\n    // \u5b50\u306e\u7d42\u4e86\u3092\u5f85\u3064\u3002\n    int limit = 10;\n    while (1) {\n        pid_t p = waitpid(pid, &status, WNOHANG);\n        if (p < 0) {\n            status = -1;\n            break;\n        } else if (p == pid) {\n            break;\n        }\n        if (limit-- == 0) {\n            printf(\"kill. pid=%d, sig=%d\\n\", pid, SIGKILL);\n            kill(pid, SIGKILL);\n            continue;\n        }\n        sleep(1);\n    }\n\n    printf(\"%s\\n\", out.c_str());\n    printf(\"%s\\n\", err.c_str());\n\n    printf(\"out.size=%lu, err.size=%lu, status=%d\\n\", out.size(), err.size(), WIFEXITED(status) ? WEXITSTATUS(status) : -1);\n    return 0;\n}\n\n\n\nstdout\u3068stderr\u306e\u5185\u5bb9\u3092\u5f97\u308b\u305f\u3081\u306b\u3001\n2\u672c\u30d1\u30a4\u30d7\u3092\u4f5c\u3063\u3066\u3001\u826f\u3044\u611f\u3058\u306bdup\u3067\u3064\u306a\u304e\u304b\u3048\u308b\u3002\n\u89aa\u5074\u306f\u3001\u5b50\u304c\u4f55\u304b\u8fd4\u3057\u3066\u304f\u308b\u307e\u3067select\u3067\u505c\u6b62\u3059\u308b\u3002\uff08\u30ce\u30f3\u30d6\u30ed\u30c3\u30ad\u30f3\u30b0\u3067\u30eb\u30fc\u30d7\u306f\u3057\u305f\u304f\u306a\u3044\uff09\n\u7121\u9650\u306b\u505c\u6b62\u3057\u305f\u304f\u306a\u3044\u306e\u3067\u3001timeout\u3067\u629c\u3051\u3089\u308c\u308b\u3088\u3046\u306b\u3059\u308b\u3002\nselect\u4e2d\u306f\u30b7\u30b0\u30ca\u30eb\u3092\u53d7\u3051\u4ed8\u3051\u305f\u3044\u306e\u3067\u3001pselect\u3067\u5f85\u3064\u3002\n\n```cpp:a.cpp\n#include <sys/types.h>\n#include <sys/wait.h>\n#include <unistd.h>\n\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <string>\n\nvoid dummy_handler(int) {\n}\n\nvoid set_sigaction(int sig) {\n    struct sigaction sa;\n    memset(&sa, 0, sizeof(struct sigaction));\n    sa.sa_handler = &dummy_handler;\n    sigemptyset(&sa.sa_mask);\n    errno = 0;\n    if (sigaction(sig, &sa, nullptr)) {\n        printf(\"sigaction fail. %s\\n\", strerror(errno));\n        exit(1);\n    }\n}\n\nint main(int argc, char **argv) {\n    \n    set_sigaction(SIGHUP);\n    set_sigaction(SIGINT);\n    set_sigaction(SIGQUIT);\n    set_sigaction(SIGTERM);\n    \n    sigset_t newss;\n    sigemptyset(&newss);\n    sigaddset(&newss, SIGCHLD);\n    sigaddset(&newss, SIGUSR1);\n    sigaddset(&newss, SIGALRM);\n    sigaddset(&newss, SIGHUP);\n    sigaddset(&newss, SIGINT);\n    sigaddset(&newss, SIGQUIT);\n    sigaddset(&newss, SIGTERM);\n    sigprocmask(SIG_BLOCK, &newss, nullptr);\n    \n    int status = 0;\n    int stdout_fd[2];\n    int stderr_fd[2];\n    \n    if (pipe(stdout_fd) < 0) {\n        printf(\"pipe fail. %s\\n\", strerror(errno));\n        return 1;\n    }\n    if (pipe(stderr_fd) < 0) {\n        printf(\"pipe fail. %s\\n\", strerror(errno));\n        close(stdout_fd[0]);\n        close(stdout_fd[1]);\n        return 1;\n    }\n    \n    pid_t pid = fork();\n    if (pid < 0) {\n        printf(\"fork fail. %s\\n\", strerror(errno));\n        close(stdout_fd[0]);\n        close(stdout_fd[1]);\n        close(stderr_fd[0]);\n        close(stderr_fd[1]);\n        return 1;\n    } else if (pid == 0) {\n        // \u5b50\u306e\u8aad\u307f\u8fbc\u307f\u5074\u3092\u30af\u30ed\u30fc\u30ba\u3002\u5b50\u306f\u66f8\u304f\u3060\u3051\u3002\n        close(stdout_fd[0]);\n        close(stderr_fd[0]);\n        \n        // 2\u672c\u3042\u308b\u30d1\u30a4\u30d7\u306e\u3046\u3061\u3001\u3069\u3061\u3089\u304b\uff08\u3042\u308b\u3044\u306f\u4e21\u65b9\uff09\u304c\u3001STDOUT\u304bSTDERR\u3092\u3059\u3067\u306b\u4f7f\u3063\u3066\u3044\u308b\u5834\u5408\u3001\n        // \u7247\u65b9\u3092dup2\u3067\u3064\u306a\u304e\u306a\u304a\u3059\u3068\u3001\u3082\u3046\u7247\u65b9\u306e\u89aa\u30d7\u30ed\u30bb\u30b9\u3068\u3064\u306a\u304c\u3063\u3066\u3044\u308b\u30d1\u30a4\u30d7\u3092\u9589\u3058\u3066\u3057\u307e\u3046\u53ef\u80fd\u6027\u304c\u3042\u308b\u3002\n        // \u306a\u306e\u3067\u3001\u73fe\u72b6\u30d1\u30a4\u30d7\u3067\u3064\u306a\u304c\u3063\u3066\u3044\u308b\u5185\u5bb9\u3092\u3001STDOUT\u3001STDERR\u4ee5\u5916\u306e\u5024\u306b\u306a\u308b\u3088\u3046\u306b\u3057\u3066\u304b\u3089\u3001\n        // \u6539\u3081\u3066\u3001STDOUT\u3068STDERR\u306b\u3064\u306a\u304e\u306a\u304a\u3059\u3002\n        int basefd = stdout_fd[1] > stderr_fd[1] ? stdout_fd[1] : stderr_fd[1];\n        int outfd = basefd + 3;\n        int errfd = basefd + 4;\n        dup2(stdout_fd[1], outfd); // outfd\u304c\u958b\u3044\u3066\u3044\u305f\u3068\u3057\u3066\u3082\u3001\u4e00\u65e6\u9589\u3058\u3066stdout_fd[1]\u306e\u5185\u5bb9\u3092\u6307\u3059\u3088\u3046\u306bopen\u3059\u308b\u3002\n        dup2(stderr_fd[1], errfd); // errfd\u304c\u958b\u3044\u3066\u3044\u305f\u3068\u3057\u3066\u3082\u3001\u4e00\u65e6\u9589\u3058\u3066stderr_fd[1]\u306e\u5185\u5bb9\u3092\u6307\u3059\u3088\u3046\u306bopen\u3059\u308b\u3002\n        close(stdout_fd[1]); // stdout_fd[1]\u306f\u3001\u3053\u308c\u3067\u4e0d\u8981\u3002\n        close(stderr_fd[1]); // stderr_fd[1]\u306f\u3001\u3053\u308c\u3067\u4e0d\u8981\u3002\n        dup2(outfd, 1); // 1\u304c\u958b\u3044\u3066\u3044\u305f\u3068\u3057\u3066\u3082\u3001\u4e00\u65e6\u9589\u3058\u3066outfd\u306e\u5185\u5bb9\u3092\u6307\u3059\u3088\u3046\u306bopen\u3059\u308b\u3002\n        dup2(errfd, 2); // 2\u304c\u958b\u3044\u3066\u3044\u305f\u3068\u3057\u3066\u3082\u3001\u4e00\u65e6\u9589\u3058\u3066errfd\u306e\u5185\u5bb9\u3092\u6307\u3059\u3088\u3046\u306bopen\u3059\u308b\u3002\n        close(outfd); // outfd\u306f\u3001\u3053\u308c\u3067\u4e0d\u8981\u3002\n        close(errfd); // errfd\u306f\u3001\u3053\u308c\u3067\u4e0d\u8981\u3002\n        \n        // \u4e0a\u8a18\u306e\u3064\u306a\u304e\u5909\u3048\u306e\u6d41\u308c\n        // \u5b50\u30d7\u30ed\u30bb\u30b9\u8d77\u52d5\u6642\u306b\u3001stdout_fd[1]\u304c1\u3001stderr_fd[1]\u304c3\u3068\u3057\u305f\u5834\u5408\u3002\n        // stdout_fd[1] = 1 -> outfd = 6 -> dup2(6, 1) ... \u89aa\u306e\u30d1\u30a4\u30d7(stdout)\u3092\u6307\u3059fd\u304c\u30011 -> 6 -> 1\u3068\u3044\u3046\u3088\u3046\u306b\u5909\u5316\u3059\u308b\u3002\n        // stderr_fd[1] = 3 -> errfd = 7 -> dup2(7, 2) ... \u89aa\u306e\u30d1\u30a4\u30d7\uff08stderr\uff09\u3092\u6307\u3059fd\u304c\u30013 -> 7 -> 2\u3068\u3044\u3046\u3088\u3046\u306b\u5909\u5316\u3059\u308b\u3002\n        // \u89aa\u30d7\u30ed\u30bb\u30b9\u5074\u3067\u3001fork\u524d\u306bfd6\u3001fd7\u3092\u4f55\u304b\u958b\u3044\u3066\u3044\u305f\u5834\u5408\u3067\u3082\u3001\u5b50\u30d7\u30ed\u30bb\u30b9\u5074\u3067\u9589\u3058\u3066\u3082\u89aa\u30d7\u30ed\u30bb\u30b9\u5074\u306b\u5f71\u97ff\u306f\u7121\u3044\u3002\n        \n        // \u89aa\u304b\u3089\u901a\u77e5\u3055\u308c\u308bUSER1\u30b7\u30b0\u30ca\u30eb\u3092\u30c1\u30a7\u30c3\u30af\u3002USER1\u30b7\u30b0\u30ca\u30eb\u304c\u6765\u308b\u307e\u3067\u5f85\u6a5f\u3002\n        // \u4e0d\u6e2c\u306e\u4e8b\u614b\u304c\u591a\u767a\u3059\u308b\u5834\u5408\u3001sigwait\u3067\u306f\u7121\u304f\u3001sigtimedwait\u3092\u4f7f\u3063\u3066\u4e00\u5b9a\u6642\u9593\u3067\u629c\u3051\u305f\u307b\u3046\u304c\u826f\u3044\u304b\u3082\u77e5\u308c\u306a\u3044\u3002\n        sigset_t ss;\n        sigemptyset(&ss);\n        sigaddset(&ss, SIGUSR1);\n        int sig;\n        sigwait(&ss, &sig);\n        \n        // \u9069\u5f53\u306a\u6587\u5b57\u5217\u3092\u89aa\u30d7\u30ed\u30bb\u30b9\u306b\u9001\u308b\u3002\n        for (int i = 0; i < 3; ++i) {\n            for (int ii = 0; ii < 5; ++ii) {\n                write(1, \"abcabcabc\\n\", 10);\n                write(2, \"123123123\\n\", 10);\n            }\n        }\n        \n        // \u3053\u3053\u3067exec\u3057\u3066\u3082\u3001\u554f\u984c\u306a\u304f\u5185\u5bb9\u3092\u53d7\u3051\u53d6\u308c\u308b\u3001\u306f\u305a\u3002\n        execlp(\"ps\", \"ps\", \"aux\" , nullptr); \n        perror(\"execlp\");\n        _exit(1);\n    }\n    \n    // \u89aa\u306e\u66f8\u304d\u8fbc\u307f\u5074\u3092\u30af\u30ed\u30fc\u30ba\u3002\u89aa\u306f\u8aad\u3080\u3060\u3051\u3002\n    close(stdout_fd[1]);\n    close(stderr_fd[1]);\n    \n    // \u89aa\u5074\u6e96\u5099\u5b8c\u4e86\u3002\u5b50\u306b\u901a\u77e5\u3059\u308b\u3002\n    kill(pid, SIGUSR1);\n    \n    fd_set read_set_master;\n    FD_ZERO(&read_set_master);\n    FD_SET(stdout_fd[0], &read_set_master);\n    FD_SET(stderr_fd[0], &read_set_master);\n    struct timespec waitval;\n    waitval.tv_sec = 10;\n    waitval.tv_nsec = 0;\n    fd_set read_set;\n    int basefd = stdout_fd[0] > stderr_fd[0] ? stdout_fd[0] : stderr_fd[0];\n    char buf[4096];\n    \n    std::string out;\n    std::string err;\n    \n    // \u7d42\u4e86\u7528\u306e\u30b7\u30b0\u30ca\u30eb\u3092\u53d7\u3051\u305f\u5834\u5408\u306f\u3001pselect\u3092\u629c\u3051\u305f\u3044\u3002\n    // SIGCHILD\u3001SIGUSER1\u3001SIGALRM\u306e\u30d6\u30ed\u30c3\u30af\u306f\u7d99\u7d9a\u3057\u3064\u3064\u3001\n    // SIGHUP\u3001SIGINT\u3001SIGQUIT\u3001SIGTERM\u3092\u53d7\u3051\u4ed8\u3051\u305f\u3044\u3002\n    sigset_t ss;\n    sigemptyset(&ss);\n    sigaddset(&newss, SIGCHLD);\n    sigaddset(&newss, SIGUSR1);\n    sigaddset(&newss, SIGALRM);\n    \n    // \u5b50\u304b\u3089\u306e\u5fdc\u7b54\u3092\u5f85\u3064\u3002\n    while (1) {\n        memcpy(&read_set, &read_set_master, sizeof(read_set_master));\n        int r = pselect(basefd + 1, &read_set, nullptr, nullptr, &waitval, &ss);\n        if (r == 0) {\n            printf(\"select timeout.\\n\");\n            printf(\"kill. pid=%d, sig=%d\\n\", pid, SIGTERM);\n            kill(pid, SIGTERM);\n            break;\n        } else if (r < 0) {\n            printf(\"select fail. %s\\n\", strerror(errno));\n            printf(\"kill. pid=%d, sig=%d\\n\", pid, SIGTERM);\n            kill(pid, SIGTERM);\n            break;\n        }\n        // \u7d50\u69cb\u5358\u7d14\u306b\u3001\u3001\u3001\n        // stdout\u3001stderr\u304c\u4e21\u65b90\u306b\u306a\u3063\u305f\u3089\u3001\u3082\u3046\u8aad\u3080\u3082\u306e\u306a\u3057\u3001\u3001\u3067\u826f\u3055\u305d\u3046?\n        bool end_flag = true;\n        if (FD_ISSET(stdout_fd[0], &read_set)) {\n            ssize_t ret = read(stdout_fd[0], buf, 4096);\n            if(ret > 0) {\n                end_flag = false;\n                buf[ret] = '\\0';\n                out += buf;\n            }\n        }\n        if (FD_ISSET(stderr_fd[0], &read_set)) {\n            ssize_t ret = read(stderr_fd[0], buf, 4096);\n            if(ret > 0) {\n                end_flag = false;\n                buf[ret] = '\\0';\n                err += buf;\n            }\n        }\n        if (end_flag) {\n            break;\n        }\n    }\n    close(stdout_fd[0]);\n    close(stderr_fd[0]);\n    \n    // \u5b50\u306e\u7d42\u4e86\u3092\u5f85\u3064\u3002\n    int limit = 10;\n    while (1) {\n        pid_t p = waitpid(pid, &status, WNOHANG);\n        if (p < 0) {\n            status = -1;\n            break;\n        } else if (p == pid) {\n            break;\n        }\n        if (limit-- == 0) {\n            printf(\"kill. pid=%d, sig=%d\\n\", pid, SIGKILL);\n            kill(pid, SIGKILL);\n            continue;\n        }\n        sleep(1);\n    }\n    \n    printf(\"%s\\n\", out.c_str());\n    printf(\"%s\\n\", err.c_str());\n    \n    printf(\"out.size=%lu, err.size=%lu, status=%d\\n\", out.size(), err.size(), WIFEXITED(status) ? WEXITSTATUS(status) : -1);\n    return 0;\n}\n\n```\n\nstdout\u3068stderr\u306e\u5185\u5bb9\u3092\u5f97\u308b\u305f\u3081\u306b\u3001\n2\u672c\u30d1\u30a4\u30d7\u3092\u4f5c\u3063\u3066\u3001\u826f\u3044\u611f\u3058\u306bdup\u3067\u3064\u306a\u304e\u304b\u3048\u308b\u3002\n\n\u89aa\u5074\u306f\u3001\u5b50\u304c\u4f55\u304b\u8fd4\u3057\u3066\u304f\u308b\u307e\u3067select\u3067\u505c\u6b62\u3059\u308b\u3002\uff08\u30ce\u30f3\u30d6\u30ed\u30c3\u30ad\u30f3\u30b0\u3067\u30eb\u30fc\u30d7\u306f\u3057\u305f\u304f\u306a\u3044\uff09\n\u7121\u9650\u306b\u505c\u6b62\u3057\u305f\u304f\u306a\u3044\u306e\u3067\u3001timeout\u3067\u629c\u3051\u3089\u308c\u308b\u3088\u3046\u306b\u3059\u308b\u3002\nselect\u4e2d\u306f\u30b7\u30b0\u30ca\u30eb\u3092\u53d7\u3051\u4ed8\u3051\u305f\u3044\u306e\u3067\u3001pselect\u3067\u5f85\u3064\u3002\n\n", "tags": ["C\u8a00\u8a9e", "C++", "C"]}