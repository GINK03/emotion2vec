{"context": " More than 1 year has passed since last update.\n\n\u3084\u308a\u305f\u3044\u3053\u3068\nbacklog\u306b\u65b0\u898f\u30bf\u30b9\u30af\u304c\u8ffd\u52a0\u3055\u308c\u305f\u3089\u3001slack\u306b\u901a\u77e5\u30dd\u30b9\u30c8\u3059\u308b\n\n\u4f7f\u3063\u305f\u3082\u306e\nxmlrpc\nslack-notify\nslack\u306fclient\u306f\u305f\u304f\u3055\u3093\u3042\u308a\u307e\u3059\u304c\u3001\u3069\u308c\u3067\u3084\u3063\u3066\u3082\u540c\u3058\u3088\u3046\u306a\u611f\u3058\u3060\u3068\u601d\u3044\u307e\u3059\n\n\u30b5\u30f3\u30d7\u30eb\u30b3\u30fc\u30c9\nrequire 'xmlrpc/client'\nrequire \"slack-notify\"\n\nclass BacklogClient\n  BACKLOG_HOST = 'xxxxxxxx'\n  BACKLOG_USER = 'user'\n  BACKLOG_PASS = 'pass'\n\n  def initialize\n    @client = XMLRPC::Client.new(BACKLOG_HOST, '/XML-RPC', 443, nil, nil, BACKLOG_USER, BACKLOG_PASS, true, 60)\n  end\n\n  def projectlist\n    @client.call('backlog.getProjects')\n  end\n\n  def issuelist(project_id)\n    @client.call('backlog.findIssue', {\"projectId\" => project_id})\n  end\n\nend\n\nclass SlackClient\n  SLACK_TEAM  = 'test'\n  SLACK_ROOM  = '#hoge'\n  SLACK_NAME  = 'backlog'\n  SLACK_TOKEN = 'xxxxxxxxxxx'\n\n  def initialize\n    @client = SlackNotify::Client.new(SLACK_TEAM, SLACK_TOKEN, {\n      channel: SLACK_ROOM,\n      username: SLACK_NAME,\n    })\n  end\n\n  def message(msg, room = nil)\n    @client.notify(msg, room)\n  end\nend\n\nlast_sent_date = Time.now.strftime(\"%Y%m%d%H%M%S\").to_i\n\nbacklog = BacklogClient.new\nslack = SlackClient.new\nwhile true\n  begin\n    projects = backlog.projectlist\n    projects.each{|project|\n      issues = backlog.issuelist(project[\"id\"])\n      issues.each{|issue|\n        if last_sent_date < issue[\"updated_on\"].to_i\n          action = (issue[\"created_on\"] == issue[\"updated_on\"]) ? \"created\" : \"updated\"\n          mes = \"[\" + project[\"name\"] + \"]\" + issue['summary'] + \"(\" + issue['url'] + \") \" + action\n          slack.message(mes)\n          last_sent_date = issue[\"updated_on\"].to_i\n        end\n      }\n    }\n  rescue => e\n    puts e.message\n  end\n  sleep(10.0)\nend\n\n\u3042\u304f\u307e\u3067\u3082\u30b5\u30f3\u30d7\u30eb\u3067\u3059\u3002\n\n\u53c2\u7167\n\u3053\u3061\u3089\u306b\u7d9a\u304d\u307e\u3059\n# \u3084\u308a\u305f\u3044\u3053\u3068\nbacklog\u306b\u65b0\u898f\u30bf\u30b9\u30af\u304c\u8ffd\u52a0\u3055\u308c\u305f\u3089\u3001slack\u306b\u901a\u77e5\u30dd\u30b9\u30c8\u3059\u308b\n\n# \u4f7f\u3063\u305f\u3082\u306e\nxmlrpc\nslack-notify\n\nslack\u306fclient\u306f\u305f\u304f\u3055\u3093\u3042\u308a\u307e\u3059\u304c\u3001\u3069\u308c\u3067\u3084\u3063\u3066\u3082\u540c\u3058\u3088\u3046\u306a\u611f\u3058\u3060\u3068\u601d\u3044\u307e\u3059\n\n# \u30b5\u30f3\u30d7\u30eb\u30b3\u30fc\u30c9\n\n```rb\nrequire 'xmlrpc/client'\nrequire \"slack-notify\"\n\nclass BacklogClient\n  BACKLOG_HOST = 'xxxxxxxx'\n  BACKLOG_USER = 'user'\n  BACKLOG_PASS = 'pass'\n\n  def initialize\n    @client = XMLRPC::Client.new(BACKLOG_HOST, '/XML-RPC', 443, nil, nil, BACKLOG_USER, BACKLOG_PASS, true, 60)\n  end\n\n  def projectlist\n    @client.call('backlog.getProjects')\n  end\n\n  def issuelist(project_id)\n    @client.call('backlog.findIssue', {\"projectId\" => project_id})\n  end\n\nend\n\nclass SlackClient\n  SLACK_TEAM  = 'test'\n  SLACK_ROOM  = '#hoge'\n  SLACK_NAME  = 'backlog'\n  SLACK_TOKEN = 'xxxxxxxxxxx'\n\n  def initialize\n    @client = SlackNotify::Client.new(SLACK_TEAM, SLACK_TOKEN, {\n      channel: SLACK_ROOM,\n      username: SLACK_NAME,\n    })\n  end\n\n  def message(msg, room = nil)\n    @client.notify(msg, room)\n  end\nend\n\nlast_sent_date = Time.now.strftime(\"%Y%m%d%H%M%S\").to_i\n\nbacklog = BacklogClient.new\nslack = SlackClient.new\nwhile true\n  begin\n    projects = backlog.projectlist\n    projects.each{|project|\n      issues = backlog.issuelist(project[\"id\"])\n      issues.each{|issue|\n        if last_sent_date < issue[\"updated_on\"].to_i\n          action = (issue[\"created_on\"] == issue[\"updated_on\"]) ? \"created\" : \"updated\"\n          mes = \"[\" + project[\"name\"] + \"]\" + issue['summary'] + \"(\" + issue['url'] + \") \" + action\n          slack.message(mes)\n          last_sent_date = issue[\"updated_on\"].to_i\n        end\n      }\n    }\n  rescue => e\n    puts e.message\n  end\n  sleep(10.0)\nend\n```\n\n\u3042\u304f\u307e\u3067\u3082\u30b5\u30f3\u30d7\u30eb\u3067\u3059\u3002\n\n# \u53c2\u7167\n\n[\u3053\u3061\u3089\u306b\u7d9a\u304d\u307e\u3059](http://qiita.com/masuyama/items/72160c496bb0f7edf471)\n", "tags": ["backlog", "Slack", "Ruby"]}