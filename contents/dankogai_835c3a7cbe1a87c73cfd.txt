{"context": " More than 1 year has passed since last update.PONS\u306bUInt128\u3092\u52a0\u3048\u3066\u307f\u307e\u3057\u305f\u3002\n\n\u4efb\u610f\u7cbe\u5ea6\u3092\u30b5\u30dd\u30fc\u30c8\u3057\u3066\u3044\u308b\u306e\u306b\u3001\u306a\u305c?\n\u305d\u3053\u306bAccelerate\u304c\u3042\u3063\u305f\u304b\u3089\u3002\nAccelerate\u306f\u672c\u6765\u30f4\u30a7\u30af\u30bf\u30fc\u6f14\u7b97\u306b\u7528\u3044\u3089\u308c\u308b\u30e9\u30a4\u30d6\u30e9\u30ea\u3002\u3068\u306f\u8a00\u3063\u3066\u3082\u88f8\u306b\u8fd1\u3044\u30e9\u30a4\u30d6\u30e9\u30ea\u3067\u3001\u751f\u3067\u98df\u3059\u3068\u8179\u304c\u58ca\u308c\u304b\u306d\u306a\u3044\u306e\u3067(\u4e0b\u8a18\u30b3\u30fc\u30c9\u3067\u751f\u3063\u3077\u308a\u306e\u7247\u9c57\u3092\u898b\u308b\u3053\u3068\u304c\u3067\u304d\u307e\u3059)\u3001Swift\u3067\u3082Surge\u3068\u304b\u6709\u540d\u306a\u30e9\u30c3\u30d1\u30fc\u304c\u51fa\u3066\u307e\u3059\u3002\n\u3053\u306eAccelerate\u3001\u5b9f\u306f\u5c0f\u3055\u306a\u6570\u3092\u307e\u3068\u3081\u3066\u51e6\u7406\u3059\u308b\u3060\u3051\u3067\u306f\u306a\u304f\u3001\u5927\u304d\u306a\u6570\u3092\u51e6\u7406\u3059\u308b\u6a5f\u80fd\u3082\u5165\u3063\u3066\u305f\u308a\u3057\u307e\u3059\u3002\u305f\u3060\u3057\u73fe\u6642\u70b9\u3067 OS X \u306e\u307f\u3002\n\u306a\u3089\u3070\u2026\n\nOS X \u3067\u306f Accelerate \u3092\u4f7f\u3063\u3066\n\u305d\u308c\u4ee5\u5916\u3067\u306f BigInt \u306b\u8a08\u7b97\u4ee3\u884c\u3057\u3066\u3082\u3089\u3048\u3070\n\n\u5b89\u4fa1\u306b(128|256|512)bit\u56fa\u5b9a\u9577\u6574\u6570\u304c\u624b\u306b\u5165\u308b\u3093\u3058\u3083\u306d?\n\u3068\u5148\u307b\u3069\u601d\u3044\u7acb\u3063\u3066\u3084\u3063\u3066\u307f\u305f\u3089\u5b9f\u306b\u5b89\u4e0a\u304c\u308a\u306b\u51fa\u6765\u307e\u3057\u305f\u3002\u3068\u308a\u3042\u3048\u305aUInt128\u304b\u3089\u3002\n\n\u5171\u901a\u90e8\u5206\npublic struct UInt128 : POUInt {\n    public typealias IntType = BigInt\n    public static let precision = 128\n    public static let allZeros = UInt128(0)\n    public typealias DigitType = BigUInt.DigitType\n    public var value:(DigitType, DigitType, DigitType, DigitType) = (0, 0, 0, 0)\n    public init(_ d0:DigitType, _ d1:DigitType, _ d2:DigitType, _ d3:DigitType) {\n        self.value = (d0, d1, d2, d3)\n    }\n    public init(_ u128:UInt128) {\n        self.value = u128.value\n    }\n    public init(_ bu:BigUInt) {\n        let d  = bu.digits\n        switch d.count {\n        case 1: value = (d[0],    0,    0,    0)\n        case 2: value = (d[0], d[1],    0,    0)\n        case 3: value = (d[0], d[1], d[2],    0)\n        default:value = (d[0], d[1], d[2], d[3])\n        }\n    }\n    public init(_ u:UIntMax) {\n        value.0 = DigitType(u & 0xffff_ffff)\n        value.1 = DigitType(u >> 32)\n    }\n    public init(_ u:UInt) {\n        self.init(BigUInt(u))\n    }\n    public init(_ i:Int) {\n        if i < 0 {\n            fatalError(\"\\(i) < 0\")\n        }\n        self.init(BigUInt(i.abs))\n    }\n    public var inBigUInt:BigUInt {\n        return BigUInt(rawValue:[value.0, value.1, value.2, value.3])\n    }\n    public var asBigUInt:BigUInt? {\n        return self.inBigUInt\n    }\n    public func toUIntMax()->UIntMax {\n        if value.2 != 0 || value.3 != 0 {\n            fatalError(\"\\(self) > UIntMax.max = \\(UIntMax.max)\")\n        }\n        return UIntMax(value.1)<<32 | UIntMax(value.0)\n    }\n    public func toIntMax()->IntMax {\n        return IntMax(self.toUIntMax())\n    }\n    public var asUInt32:UInt32? {\n        if value.1 != 0 || value.2 != 0 || value.3 != 0 {\n            return nil\n        }\n        return value.0\n    }\n    public var msbAt:Int {\n        return value.3 != 0 ? 96 + value.3.msbAt\n            :  value.2 != 0 ? 64 + value.2.msbAt\n            :  value.1 != 0 ? 32 + value.1.msbAt\n            :                      value.0.msbAt\n    }\n    public var asSigned:IntType? {\n        return self.inBigUInt.asSigned\n    }\n    public static let min = UInt128(0)\n    public static let max = UInt128(BigUInt(1)<<128-1)\n    public static func divideWithOverflow(lhs:UInt128, _ rhs:UInt128)->(UInt128, overflow:Bool) {\n        return (divmod(lhs, rhs).0, false)\n    }\n    public static func remainderWithOverflow(lhs:UInt128, _ rhs:UInt128)->(UInt128, overflow:Bool) {\n        return (divmod(lhs, rhs).1, false)\n    }\n}\npublic func ==(lhs:UInt128, rhs:UInt128)->Bool {\n    let lv = lhs.value\n    let rv = rhs.value\n    return lv.0 == rv.0 && lv.1 == rv.1 && lv.2 == rv.2 && lv.3 == rv.3\n}\npublic func <(lhs:UInt128, rhs:UInt128)->Bool {\n    return UInt128.subtractWithOverflow(lhs, rhs).1\n}\npublic prefix func ~(u128:UInt128)->UInt128 {\n    return UInt128(~u128.value.0, ~u128.value.1, ~u128.value.2, ~u128.value.3)\n}\npublic func &(lhs:UInt128, rhs:UInt128)->UInt128 {\n    return UInt128(\n        lhs.value.0 & rhs.value.0,\n        lhs.value.1 & rhs.value.1,\n        lhs.value.2 & rhs.value.2,\n        lhs.value.3 & rhs.value.3\n    )\n}\npublic func |(lhs:UInt128, rhs:UInt128)->UInt128 {\n    return UInt128(\n        lhs.value.0 | rhs.value.0,\n        lhs.value.1 | rhs.value.1,\n        lhs.value.2 | rhs.value.2,\n        lhs.value.3 | rhs.value.3\n    )\n}\npublic func ^(lhs:UInt128, rhs:UInt128)->UInt128 {\n    return UInt128(\n        lhs.value.0 ^ rhs.value.0,\n        lhs.value.1 ^ rhs.value.1,\n        lhs.value.2 ^ rhs.value.2,\n        lhs.value.3 ^ rhs.value.3\n    )\n}\n\n\n\u898b\u3066\u306e\u901a\u308a\u3001BigUInt\u304c[UInt32]\u3067\u6301\u3063\u3066\u3044\u308b\u6570\u5024\u306e\u5185\u90e8\u8868\u73fe(\u5358\u306a\u308b(2**32)\u9032\u6cd5\u306e\u6570\u5024)\u3092(UInt32, UInt32, UInt32, UInt32)\u3067\u6301\u305f\u305b\u3066\u3044\u308b\u3060\u3051\u3067\u3059\u3002\n\u3042\u3068\u306f\u3001\u96e3\u3057\u305d\u3046\u306a\u6f14\u7b97\u306fBigUInt\u304b\u2026\n\nAccelerate\u306a\u3057\n#if !os(OSX)    // slow but steady BigInt arithmetics\npublic extension UInt128 {\n    public static func addWithOverflow(lhs:UInt128, _ rhs:UInt128)->(UInt128, overflow:Bool) {\n        let (bu, overflow) = BigUInt.addWithOverflow(lhs.inBigUInt, rhs.inBigUInt)\n        return (UInt128(bu), overflow || bu.digits.count > 4)\n    }\n    public static func subtractWithOverflow(lhs:UInt128, _ rhs:UInt128)->(UInt128, overflow:Bool) {\n        let (bu, overflow) = BigUInt.subtractWithOverflow(lhs.inBigUInt, rhs.inBigUInt)\n        return (UInt128(bu), overflow || bu.digits.count > 4)\n    }\n    public static func multiplyWithOverflow(lhs:UInt128, _ rhs:UInt128)->(UInt128, overflow:Bool) {\n        let (bu, overflow) = BigUInt.multiplyWithOverflow(lhs.inBigUInt, rhs.inBigUInt)\n        return (UInt128(bu), overflow || bu.digits.count > 4)\n    }\n    public static func divmod(lhs:UInt128, _ rhs:UInt128)->(UInt128, UInt128) {\n        let (q, r) = BigUInt.divmod(lhs.inBigUInt, rhs.inBigUInt)\n        return (UInt128(q), UInt128(r))\n    }\n}\npublic func <<(lhs:UInt128, rhs:UInt128)->UInt128 {\n    return UInt128( lhs.inBigUInt << rhs.inBigUInt )\n}\npublic func >>(lhs:UInt128, rhs:UInt128)->UInt128 {\n    return UInt128( lhs.inBigUInt >> rhs.inBigUInt )\n}\n\n\nAccelerate\u306b\u6295\u3052\u308b\u3060\u3051\u3002\n\nAccelerate\u3042\u308a\n#else   // fast arithmetics via Accelerate.  OS X only\nimport Accelerate\npublic extension UInt128 {\n    public static func addWithOverflow(lhs:UInt128, _ rhs:UInt128)->(UInt128, overflow:Bool) {\n        var a = unsafeBitCast((lhs, vU128()), vU256.self)\n        var b = unsafeBitCast((rhs, vU128()), vU256.self)\n        var ab = vU256()\n        vU256Add(&a, &b, &ab)\n        let (r, o) =  unsafeBitCast(ab, (UInt128, UInt128).self)\n        return (r, o != 0)\n    }\n    public static func subtractWithOverflow(lhs:UInt128, _ rhs:UInt128)->(UInt128, overflow:Bool) {\n        var a = unsafeBitCast((lhs, vU128()), vU256.self)\n        var b = unsafeBitCast((rhs, vU128()), vU256.self)\n        var ab = vU256()\n        vU256Sub(&a, &b, &ab)\n        let (r, o) =  unsafeBitCast(ab, (UInt128, UInt128).self)\n        return (r, o != 0)\n    }\n    public static func multiplyWithOverflow(lhs:UInt128, _ rhs:UInt128)->(UInt128, overflow:Bool) {\n        var a = unsafeBitCast(lhs, vU128.self)\n        var b = unsafeBitCast(rhs, vU128.self)\n        var ab = vU256()\n        vU128FullMultiply(&a, &b, &ab)\n        let (r, o) =  unsafeBitCast(ab, (UInt128, UInt128).self)\n        return (r, o != 0)\n    }\n    public static func divmod(lhs:UInt128, _ rhs:UInt128)->(UInt128, UInt128) {\n        var a = unsafeBitCast((lhs, vU128()), vU256.self)\n        var b = unsafeBitCast((rhs, vU128()), vU256.self)\n        var (q, r) = (vU256(), vU256())\n        vU256Divide(&a, &b, &q, &r)\n        return (unsafeBitCast(q, (UInt128, UInt128).self).0, unsafeBitCast(r, (UInt128, UInt128).self).0)\n    }\n}\npublic func <<(lhs:UInt128, rhs:UInt128)->UInt128 {\n    var a = unsafeBitCast((lhs, vU128()), vU256.self)\n    var r = vU256()\n    vLL256Shift(&a, rhs.asUInt32!, &r)\n    return unsafeBitCast(r, (UInt128, UInt128).self).0\n}\npublic func >>(lhs:UInt128, rhs:UInt128)->UInt128 {\n    var a = unsafeBitCast((lhs, vU128()), vU256.self)\n    var r = vU256()\n    vLR256Shift(&a, rhs.asUInt32!, &r)\n    return unsafeBitCast(r, (UInt128, UInt128).self).0\n}\n#endif\n\n\n\u3053\u308c\u3067\u3082\u3046128bit\u7b26\u53f7\u306a\u3057\u6574\u6570\u304c\u624b\u306b\u5165\u308a\u307e\u3057\u305f\u3002\u6f14\u7b97\u5b50\u306f\u3082\u3061\u308d\u3093\u306e\u3053\u3068\u3001POUInt\u306b\u3042\u308b\u95a2\u6570\u3084\u30e1\u30bd\u30c3\u30c9\u306f\u5168\u3066\u4f7f\u3048\u307e\u3059\u3057\u3001POUInt\u4ee5\u4e0a\u306eProtocol\u3092\u62e1\u5f35\u3059\u308c\u3070\u3001\u305d\u306e\u6069\u6075\u304c\u5373\u5ea7\u306b\u964d\u308a\u3066\u304d\u307e\u3059\u3002\n  6> (UInt128(1)<<127 - UInt128(1)).isPrime\n$R2: Bool = true\n\n  1> import PONS\n  2> func fib<T:POInteger>(n:T)->T { // with a little better algorithm \n  3.     if n < T(2) { return n } \n  4.     var (a, b) = (T(0), T(1)) \n  5.     for _ in 2...n { \n  6.         (a, b) = (b, a+b) \n  7.     } \n  8.     return b \n  9. } \n 10> fib(94 as UInt128).description \n$R0: String = \"19740274219868223167\"\n 11> fib(186 as UInt128).description \n$R1: String = \"332825110087067562321196029789634457848\"\n 12> fib(187 as UInt128).description \nfatal error: overflow: 205697230343233228174223751303346572685 + 332825110087067562321196029789634457848: file pons/pointeger.swift, line 55\nExecution interrupted. Enter Swift code to recover and continue.\nEnter LLDB commands to investigate (type :help for assistance.)\n\n\u3067\u3001\u6c17\u306b\u306a\u308b\u901f\u5ea6\u306e\u65b9\u306f\u2026\n\n2.1.1@OSX\nfact(34 as UInt128) == 295232799039604140847618609643520000000\nUInt128: 22692.6435500538 ops/s (0.0440671443939209s for 1000ops)\nBigUInt: 3997.31625495578 ops/s (0.250167846679688s for 1000ops)\nUInt128/BigUInt == 5.67696977238667\n\n\nUInt128\u3067\u884c\u3051\u308b\u6700\u5927\u306e\u968e\u4e5734!\u309233!\u3067\u5272\u3089\u305b\u308b\u3068\u3044\u3046\u6f14\u7b97\u3067\u3001BigUInt\u306e6\u500d\u5f31\u307b\u3069\u901f\u304f\u306a\u3063\u3066\u307e\u3059\u3002\nAccelerate\u306e\u6069\u6075\u3092\u53d7\u3051\u3089\u308c\u306a\u3044\u5834\u5408\u3067\u3082\u2026\n\n2.2-dev@Linux\nfact(34 as BigUInt) == 295232799039604140847618609643520000000\nUInt128: 6954.48244758816 ops/s (0.143792152404785s for 1000ops)\nBigUInt: 8128.55913611733 ops/s (0.12302303314209s for 1000ops)\nUInt128/BigUInt == 0.85556152463572\n\n\n\u3068\u6975\u7aef\u306b\u306f\u9045\u304f\u306a\u308a\u307e\u305b\u3093\u3002\u3064\u3046\u304b\u901a\u5e38\u306eBigUInt(\u540c\u4e00\u30de\u30b7\u30f3\u306eVM\u4e0a\u306e)Linux\u306e\u65b9\u304c\u901f\u3044\u3093\u3067\u3084\u3093\u306e\u3002\u307e\u3042Swift\u306e\u30d0\u30fc\u30b8\u30e7\u30f3\u81ea\u4f53\u898b\u3066\u306e\u901a\u308aXcode\u3088\u308a\u65b0\u3057\u3044\u3093\u3067\u3059\u304c\u3002\nPONS\u306e\u9762\u76ee\u8e8d\u5982\u3002\u307e\u3055\u306b\u3053\u3046\u3044\u3046\u3053\u3068\u3092\u3059\u308b\u305f\u3081\u306b\u4f5c\u3063\u305f\u3093\u3067\u3059\u3088\u3002\nEnjoy!\nDan the Protocol-Oriented Swift Programmer\n[PONS]\u306b`UInt128`\u3092\u52a0\u3048\u3066\u307f\u307e\u3057\u305f\u3002\n\n![typetree](https://raw.githubusercontent.com/dankogai/swift-pons/master/graph/typetree.png)\n\n\u4efb\u610f\u7cbe\u5ea6\u3092\u30b5\u30dd\u30fc\u30c8\u3057\u3066\u3044\u308b\u306e\u306b\u3001\u306a\u305c?\n\n\u305d\u3053\u306b[Accelerate]\u304c\u3042\u3063\u305f\u304b\u3089\u3002\n\n[Accelerate]: https://developer.apple.com/library/mac/documentation/Performance/Conceptual/vecLib/\n\nAccelerate\u306f\u672c\u6765\u30f4\u30a7\u30af\u30bf\u30fc\u6f14\u7b97\u306b\u7528\u3044\u3089\u308c\u308b\u30e9\u30a4\u30d6\u30e9\u30ea\u3002\u3068\u306f\u8a00\u3063\u3066\u3082\u88f8\u306b\u8fd1\u3044\u30e9\u30a4\u30d6\u30e9\u30ea\u3067\u3001\u751f\u3067\u98df\u3059\u3068\u8179\u304c\u58ca\u308c\u304b\u306d\u306a\u3044\u306e\u3067(\u4e0b\u8a18\u30b3\u30fc\u30c9\u3067\u751f\u3063\u3077\u308a\u306e\u7247\u9c57\u3092\u898b\u308b\u3053\u3068\u304c\u3067\u304d\u307e\u3059)\u3001Swift\u3067\u3082[Surge]\u3068\u304b\u6709\u540d\u306a\u30e9\u30c3\u30d1\u30fc\u304c\u51fa\u3066\u307e\u3059\u3002\n\n\u3053\u306e[Accelerate]\u3001\u5b9f\u306f\u5c0f\u3055\u306a\u6570\u3092\u307e\u3068\u3081\u3066\u51e6\u7406\u3059\u308b\u3060\u3051\u3067\u306f\u306a\u304f\u3001\u5927\u304d\u306a\u6570\u3092\u51e6\u7406\u3059\u308b\u6a5f\u80fd\u3082\u5165\u3063\u3066\u305f\u308a\u3057\u307e\u3059\u3002\u305f\u3060\u3057\u73fe\u6642\u70b9\u3067 OS X \u306e\u307f\u3002\n\n\u306a\u3089\u3070\u2026\n\n* OS X \u3067\u306f Accelerate \u3092\u4f7f\u3063\u3066\n* \u305d\u308c\u4ee5\u5916\u3067\u306f BigInt \u306b\u8a08\u7b97\u4ee3\u884c\u3057\u3066\u3082\u3089\u3048\u3070\n\n\u5b89\u4fa1\u306b(128|256|512)bit\u56fa\u5b9a\u9577\u6574\u6570\u304c\u624b\u306b\u5165\u308b\u3093\u3058\u3083\u306d?\n\n\u3068\u5148\u307b\u3069\u601d\u3044\u7acb\u3063\u3066\u3084\u3063\u3066\u307f\u305f\u3089\u5b9f\u306b\u5b89\u4e0a\u304c\u308a\u306b\u51fa\u6765\u307e\u3057\u305f\u3002\u3068\u308a\u3042\u3048\u305a`UInt128`\u304b\u3089\u3002\n\n[PONS]: http://qiita.com/dankogai/items/7af3565d7657785211dc\n[Surge]: https://github.com/mattt/Surge\n\n\n````swift:\u5171\u901a\u90e8\u5206\npublic struct UInt128 : POUInt {\n    public typealias IntType = BigInt\n    public static let precision = 128\n    public static let allZeros = UInt128(0)\n    public typealias DigitType = BigUInt.DigitType\n    public var value:(DigitType, DigitType, DigitType, DigitType) = (0, 0, 0, 0)\n    public init(_ d0:DigitType, _ d1:DigitType, _ d2:DigitType, _ d3:DigitType) {\n        self.value = (d0, d1, d2, d3)\n    }\n    public init(_ u128:UInt128) {\n        self.value = u128.value\n    }\n    public init(_ bu:BigUInt) {\n        let d  = bu.digits\n        switch d.count {\n        case 1: value = (d[0],    0,    0,    0)\n        case 2: value = (d[0], d[1],    0,    0)\n        case 3: value = (d[0], d[1], d[2],    0)\n        default:value = (d[0], d[1], d[2], d[3])\n        }\n    }\n    public init(_ u:UIntMax) {\n        value.0 = DigitType(u & 0xffff_ffff)\n        value.1 = DigitType(u >> 32)\n    }\n    public init(_ u:UInt) {\n        self.init(BigUInt(u))\n    }\n    public init(_ i:Int) {\n        if i < 0 {\n            fatalError(\"\\(i) < 0\")\n        }\n        self.init(BigUInt(i.abs))\n    }\n    public var inBigUInt:BigUInt {\n        return BigUInt(rawValue:[value.0, value.1, value.2, value.3])\n    }\n    public var asBigUInt:BigUInt? {\n        return self.inBigUInt\n    }\n    public func toUIntMax()->UIntMax {\n        if value.2 != 0 || value.3 != 0 {\n            fatalError(\"\\(self) > UIntMax.max = \\(UIntMax.max)\")\n        }\n        return UIntMax(value.1)<<32 | UIntMax(value.0)\n    }\n    public func toIntMax()->IntMax {\n        return IntMax(self.toUIntMax())\n    }\n    public var asUInt32:UInt32? {\n        if value.1 != 0 || value.2 != 0 || value.3 != 0 {\n            return nil\n        }\n        return value.0\n    }\n    public var msbAt:Int {\n        return value.3 != 0 ? 96 + value.3.msbAt\n            :  value.2 != 0 ? 64 + value.2.msbAt\n            :  value.1 != 0 ? 32 + value.1.msbAt\n            :                      value.0.msbAt\n    }\n    public var asSigned:IntType? {\n        return self.inBigUInt.asSigned\n    }\n    public static let min = UInt128(0)\n    public static let max = UInt128(BigUInt(1)<<128-1)\n    public static func divideWithOverflow(lhs:UInt128, _ rhs:UInt128)->(UInt128, overflow:Bool) {\n        return (divmod(lhs, rhs).0, false)\n    }\n    public static func remainderWithOverflow(lhs:UInt128, _ rhs:UInt128)->(UInt128, overflow:Bool) {\n        return (divmod(lhs, rhs).1, false)\n    }\n}\npublic func ==(lhs:UInt128, rhs:UInt128)->Bool {\n    let lv = lhs.value\n    let rv = rhs.value\n    return lv.0 == rv.0 && lv.1 == rv.1 && lv.2 == rv.2 && lv.3 == rv.3\n}\npublic func <(lhs:UInt128, rhs:UInt128)->Bool {\n    return UInt128.subtractWithOverflow(lhs, rhs).1\n}\npublic prefix func ~(u128:UInt128)->UInt128 {\n    return UInt128(~u128.value.0, ~u128.value.1, ~u128.value.2, ~u128.value.3)\n}\npublic func &(lhs:UInt128, rhs:UInt128)->UInt128 {\n    return UInt128(\n        lhs.value.0 & rhs.value.0,\n        lhs.value.1 & rhs.value.1,\n        lhs.value.2 & rhs.value.2,\n        lhs.value.3 & rhs.value.3\n    )\n}\npublic func |(lhs:UInt128, rhs:UInt128)->UInt128 {\n    return UInt128(\n        lhs.value.0 | rhs.value.0,\n        lhs.value.1 | rhs.value.1,\n        lhs.value.2 | rhs.value.2,\n        lhs.value.3 | rhs.value.3\n    )\n}\npublic func ^(lhs:UInt128, rhs:UInt128)->UInt128 {\n    return UInt128(\n        lhs.value.0 ^ rhs.value.0,\n        lhs.value.1 ^ rhs.value.1,\n        lhs.value.2 ^ rhs.value.2,\n        lhs.value.3 ^ rhs.value.3\n    )\n}\n````\n\n\u898b\u3066\u306e\u901a\u308a\u3001`BigUInt`\u304c`[UInt32]`\u3067\u6301\u3063\u3066\u3044\u308b\u6570\u5024\u306e\u5185\u90e8\u8868\u73fe(\u5358\u306a\u308b(2**32)\u9032\u6cd5\u306e\u6570\u5024)\u3092`(UInt32, UInt32, UInt32, UInt32)`\u3067\u6301\u305f\u305b\u3066\u3044\u308b\u3060\u3051\u3067\u3059\u3002\n\n\u3042\u3068\u306f\u3001\u96e3\u3057\u305d\u3046\u306a\u6f14\u7b97\u306f`BigUInt`\u304b\u2026\n\n````swift:Accelerate\u306a\u3057\n#if !os(OSX)    // slow but steady BigInt arithmetics\npublic extension UInt128 {\n    public static func addWithOverflow(lhs:UInt128, _ rhs:UInt128)->(UInt128, overflow:Bool) {\n        let (bu, overflow) = BigUInt.addWithOverflow(lhs.inBigUInt, rhs.inBigUInt)\n        return (UInt128(bu), overflow || bu.digits.count > 4)\n    }\n    public static func subtractWithOverflow(lhs:UInt128, _ rhs:UInt128)->(UInt128, overflow:Bool) {\n        let (bu, overflow) = BigUInt.subtractWithOverflow(lhs.inBigUInt, rhs.inBigUInt)\n        return (UInt128(bu), overflow || bu.digits.count > 4)\n    }\n    public static func multiplyWithOverflow(lhs:UInt128, _ rhs:UInt128)->(UInt128, overflow:Bool) {\n        let (bu, overflow) = BigUInt.multiplyWithOverflow(lhs.inBigUInt, rhs.inBigUInt)\n        return (UInt128(bu), overflow || bu.digits.count > 4)\n    }\n    public static func divmod(lhs:UInt128, _ rhs:UInt128)->(UInt128, UInt128) {\n        let (q, r) = BigUInt.divmod(lhs.inBigUInt, rhs.inBigUInt)\n        return (UInt128(q), UInt128(r))\n    }\n}\npublic func <<(lhs:UInt128, rhs:UInt128)->UInt128 {\n    return UInt128( lhs.inBigUInt << rhs.inBigUInt )\n}\npublic func >>(lhs:UInt128, rhs:UInt128)->UInt128 {\n    return UInt128( lhs.inBigUInt >> rhs.inBigUInt )\n}\n````\n\nAccelerate\u306b\u6295\u3052\u308b\u3060\u3051\u3002\n\n````swift:Accelerate\u3042\u308a\n#else   // fast arithmetics via Accelerate.  OS X only\nimport Accelerate\npublic extension UInt128 {\n    public static func addWithOverflow(lhs:UInt128, _ rhs:UInt128)->(UInt128, overflow:Bool) {\n        var a = unsafeBitCast((lhs, vU128()), vU256.self)\n        var b = unsafeBitCast((rhs, vU128()), vU256.self)\n        var ab = vU256()\n        vU256Add(&a, &b, &ab)\n        let (r, o) =  unsafeBitCast(ab, (UInt128, UInt128).self)\n        return (r, o != 0)\n    }\n    public static func subtractWithOverflow(lhs:UInt128, _ rhs:UInt128)->(UInt128, overflow:Bool) {\n        var a = unsafeBitCast((lhs, vU128()), vU256.self)\n        var b = unsafeBitCast((rhs, vU128()), vU256.self)\n        var ab = vU256()\n        vU256Sub(&a, &b, &ab)\n        let (r, o) =  unsafeBitCast(ab, (UInt128, UInt128).self)\n        return (r, o != 0)\n    }\n    public static func multiplyWithOverflow(lhs:UInt128, _ rhs:UInt128)->(UInt128, overflow:Bool) {\n        var a = unsafeBitCast(lhs, vU128.self)\n        var b = unsafeBitCast(rhs, vU128.self)\n        var ab = vU256()\n        vU128FullMultiply(&a, &b, &ab)\n        let (r, o) =  unsafeBitCast(ab, (UInt128, UInt128).self)\n        return (r, o != 0)\n    }\n    public static func divmod(lhs:UInt128, _ rhs:UInt128)->(UInt128, UInt128) {\n        var a = unsafeBitCast((lhs, vU128()), vU256.self)\n        var b = unsafeBitCast((rhs, vU128()), vU256.self)\n        var (q, r) = (vU256(), vU256())\n        vU256Divide(&a, &b, &q, &r)\n        return (unsafeBitCast(q, (UInt128, UInt128).self).0, unsafeBitCast(r, (UInt128, UInt128).self).0)\n    }\n}\npublic func <<(lhs:UInt128, rhs:UInt128)->UInt128 {\n    var a = unsafeBitCast((lhs, vU128()), vU256.self)\n    var r = vU256()\n    vLL256Shift(&a, rhs.asUInt32!, &r)\n    return unsafeBitCast(r, (UInt128, UInt128).self).0\n}\npublic func >>(lhs:UInt128, rhs:UInt128)->UInt128 {\n    var a = unsafeBitCast((lhs, vU128()), vU256.self)\n    var r = vU256()\n    vLR256Shift(&a, rhs.asUInt32!, &r)\n    return unsafeBitCast(r, (UInt128, UInt128).self).0\n}\n#endif\n````\n\n\u3053\u308c\u3067\u3082\u3046128bit\u7b26\u53f7\u306a\u3057\u6574\u6570\u304c\u624b\u306b\u5165\u308a\u307e\u3057\u305f\u3002\u6f14\u7b97\u5b50\u306f\u3082\u3061\u308d\u3093\u306e\u3053\u3068\u3001`POUInt`\u306b\u3042\u308b\u95a2\u6570\u3084\u30e1\u30bd\u30c3\u30c9\u306f\u5168\u3066\u4f7f\u3048\u307e\u3059\u3057\u3001POUInt\u4ee5\u4e0a\u306eProtocol\u3092\u62e1\u5f35\u3059\u308c\u3070\u3001\u305d\u306e\u6069\u6075\u304c\u5373\u5ea7\u306b\u964d\u308a\u3066\u304d\u307e\u3059\u3002\n\n````\n  6> (UInt128(1)<<127 - UInt128(1)).isPrime\n$R2: Bool = true\n````\n\n````\n  1> import PONS\n  2> func fib<T:POInteger>(n:T)->T { // with a little better algorithm \n  3.     if n < T(2) { return n } \n  4.     var (a, b) = (T(0), T(1)) \n  5.     for _ in 2...n { \n  6.         (a, b) = (b, a+b) \n  7.     } \n  8.     return b \n  9. } \n 10> fib(94 as UInt128).description \n$R0: String = \"19740274219868223167\"\n 11> fib(186 as UInt128).description \n$R1: String = \"332825110087067562321196029789634457848\"\n 12> fib(187 as UInt128).description \nfatal error: overflow: 205697230343233228174223751303346572685 + 332825110087067562321196029789634457848: file pons/pointeger.swift, line 55\nExecution interrupted. Enter Swift code to recover and continue.\nEnter LLDB commands to investigate (type :help for assistance.)\n````\n\n\n\u3067\u3001\u6c17\u306b\u306a\u308b\u901f\u5ea6\u306e\u65b9\u306f\u2026\n\n````text:2.1.1@OSX\nfact(34 as UInt128) == 295232799039604140847618609643520000000\nUInt128: 22692.6435500538 ops/s (0.0440671443939209s for 1000ops)\nBigUInt: 3997.31625495578 ops/s (0.250167846679688s for 1000ops)\nUInt128/BigUInt == 5.67696977238667\n````\n\n`UInt128`\u3067\u884c\u3051\u308b\u6700\u5927\u306e\u968e\u4e57`34!`\u3092`33!`\u3067\u5272\u3089\u305b\u308b\u3068\u3044\u3046\u6f14\u7b97\u3067\u3001`BigUInt`\u306e6\u500d\u5f31\u307b\u3069\u901f\u304f\u306a\u3063\u3066\u307e\u3059\u3002\n\nAccelerate\u306e\u6069\u6075\u3092\u53d7\u3051\u3089\u308c\u306a\u3044\u5834\u5408\u3067\u3082\u2026\n\n````text:2.2-dev@Linux\nfact(34 as BigUInt) == 295232799039604140847618609643520000000\nUInt128: 6954.48244758816 ops/s (0.143792152404785s for 1000ops)\nBigUInt: 8128.55913611733 ops/s (0.12302303314209s for 1000ops)\nUInt128/BigUInt == 0.85556152463572\n````\n\n\u3068\u6975\u7aef\u306b\u306f\u9045\u304f\u306a\u308a\u307e\u305b\u3093\u3002\u3064\u3046\u304b\u901a\u5e38\u306e`BigUInt`(\u540c\u4e00\u30de\u30b7\u30f3\u306eVM\u4e0a\u306e)Linux\u306e\u65b9\u304c\u901f\u3044\u3093\u3067\u3084\u3093\u306e\u3002\u307e\u3042Swift\u306e\u30d0\u30fc\u30b8\u30e7\u30f3\u81ea\u4f53\u898b\u3066\u306e\u901a\u308aXcode\u3088\u308a\u65b0\u3057\u3044\u3093\u3067\u3059\u304c\u3002\n\nPONS\u306e\u9762\u76ee\u8e8d\u5982\u3002\u307e\u3055\u306b\u3053\u3046\u3044\u3046\u3053\u3068\u3092\u3059\u308b\u305f\u3081\u306b\u4f5c\u3063\u305f\u3093\u3067\u3059\u3088\u3002\n\nEnjoy!\n\nDan the Protocol-Oriented Swift Programmer\n", "tags": ["PONS", "Swift", "math", "Protocol"]}