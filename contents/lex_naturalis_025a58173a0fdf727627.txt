{"context": " More than 1 year has passed since last update.\uff08\u5143\u30cd\u30bf\u306f http://nabetani.sakura.ne.jp/hena/ord16boseg/ \uff09\n\u3053\u308c\u3082\u57fa\u790e\u7684\u306a\u30ea\u30b9\u30c8\u64cd\u4f5c\u3067\u697d\u306b\u66f8\u3051\u308b\u3002\n\u809d\u5fc3\u306e\u6570\u3048\u4e0a\u3052\u90e8\u5206\u306f\u84c4\u7a4d\u5f15\u65702\u3064\u4f7f\u3063\u3066\u518d\u5e30\u3057\u3066\u308b\u306e\u304c\u30c0\u30b5\u3044\u306e\u3067\n\u6c17\u306b\u5165\u3089\u306a\u3044\u3068\u3044\u3048\u3070\u6c17\u306b\u5165\u3089\u306a\u3044\uff08\u30eb\u30fc\u30d7\u306b\u7b49\u4fa1\u306a\u306e\u306f\u671b\u307e\u3057\u3044\u3068\u3057\u3066\u3082\uff09\u3002\n\u4e8c\u9032\u8868\u73fe\u306b\u76f4\u3057\u3066\u51e6\u7406\u3059\u308b\u7b87\u6240\u3082\u7b4b\u60aa\u306e\u3084\u308a\u65b9\u3060\u304c\u3001\nNumeric\u306f\u4f7f\u3044\u306b\u304f\u3044\u3057\u304b\u3068\u3044\u3063\u3066Lens\u4f7f\u3046\u306e\u3082\u766a\u3002\n\nBorderline.hs\nmodule Main where\n\nimport Data.List\nimport Control.Applicative\nimport System.Environment (getArgs)\n\ndata Cell = B | W deriving (Eq, Show)\ntype Field = [[Cell]]\n\ncountpath :: Field -> [[Int]]\ncountpath [] = []\ncountpath [x] = []\ncountpath (x:y:xs) = cp x y 0 [] : countpath (y:xs)\n  where\n    cp [] [] num list = num:list\n    cp (a:as) (b:bs) num list = case a==b of\n      True -> cp as bs 0 (num:list)\n      False -> cp as bs (num+1) list\n    cp _ _ _ _ = undefined\n\naggregate :: Field -> [Int]\naggregate f = count $ filter (/=0) $ concat $ (countpath f)++(countpath $ transpose f) \n  where count xs = [\\n -> length.filter (==n)] <*> [1..6] <*> [xs]\n\n\n-- \u500b\u4eba\u7684\u30e1\u30e2\uff1a\u81ea\u5206\u3067chunks\u3068\u304b\u66f8\u304b\u305a\u306bData.List.Split (chunksOf)\u3092\u4f7f\u3046\u3053\u3068\u3002\n\nconstruct :: String -> Field\nconstruct = take 6 . chunks 6 . concat . map oct . parse\n  where \n    parse  str = map read $ transpose [str]\n    chunks n xs = take n xs : chunks n (drop n xs)\n    oct n = (if elem rem [4,5,6,7] then B else W):\n            (if elem rem [2,3,6,7] then B else W):\n            (if elem rem [1,3,5,7] then B else W):[]\n      where rem = mod n 8\n\nsolve = aggregate.construct\n\nmain = solve<$>concat<$>getArgs >>= print\n\n\n\n\uff08\u5143\u30cd\u30bf\u306f http://nabetani.sakura.ne.jp/hena/ord16boseg/ \uff09\n\n\u3053\u308c\u3082\u57fa\u790e\u7684\u306a\u30ea\u30b9\u30c8\u64cd\u4f5c\u3067\u697d\u306b\u66f8\u3051\u308b\u3002\n\u809d\u5fc3\u306e\u6570\u3048\u4e0a\u3052\u90e8\u5206\u306f\u84c4\u7a4d\u5f15\u65702\u3064\u4f7f\u3063\u3066\u518d\u5e30\u3057\u3066\u308b\u306e\u304c\u30c0\u30b5\u3044\u306e\u3067\n\u6c17\u306b\u5165\u3089\u306a\u3044\u3068\u3044\u3048\u3070\u6c17\u306b\u5165\u3089\u306a\u3044\uff08\u30eb\u30fc\u30d7\u306b\u7b49\u4fa1\u306a\u306e\u306f\u671b\u307e\u3057\u3044\u3068\u3057\u3066\u3082\uff09\u3002\n\u4e8c\u9032\u8868\u73fe\u306b\u76f4\u3057\u3066\u51e6\u7406\u3059\u308b\u7b87\u6240\u3082\u7b4b\u60aa\u306e\u3084\u308a\u65b9\u3060\u304c\u3001\nNumeric\u306f\u4f7f\u3044\u306b\u304f\u3044\u3057\u304b\u3068\u3044\u3063\u3066Lens\u4f7f\u3046\u306e\u3082\u766a\u3002\n\n\n```hs:Borderline.hs\nmodule Main where\n\nimport Data.List\nimport Control.Applicative\nimport System.Environment (getArgs)\n\ndata Cell = B | W deriving (Eq, Show)\ntype Field = [[Cell]]\n\ncountpath :: Field -> [[Int]]\ncountpath [] = []\ncountpath [x] = []\ncountpath (x:y:xs) = cp x y 0 [] : countpath (y:xs)\n  where\n  \tcp [] [] num list = num:list\n  \tcp (a:as) (b:bs) num list = case a==b of\n  \t  True -> cp as bs 0 (num:list)\n  \t  False -> cp as bs (num+1) list\n  \tcp _ _ _ _ = undefined\n\naggregate :: Field -> [Int]\naggregate f = count $ filter (/=0) $ concat $ (countpath f)++(countpath $ transpose f) \n  where count xs = [\\n -> length.filter (==n)] <*> [1..6] <*> [xs]\n \n\n-- \u500b\u4eba\u7684\u30e1\u30e2\uff1a\u81ea\u5206\u3067chunks\u3068\u304b\u66f8\u304b\u305a\u306bData.List.Split (chunksOf)\u3092\u4f7f\u3046\u3053\u3068\u3002\n\nconstruct :: String -> Field\nconstruct = take 6 . chunks 6 . concat . map oct . parse\n  where \n    parse  str = map read $ transpose [str]\n    chunks n xs = take n xs : chunks n (drop n xs)\n    oct n = (if elem rem [4,5,6,7] then B else W):\n            (if elem rem [2,3,6,7] then B else W):\n            (if elem rem [1,3,5,7] then B else W):[]\n      where rem = mod n 8\n\nsolve = aggregate.construct\n\nmain = solve<$>concat<$>getArgs >>= print\n```\n", "tags": ["\u60c5\u5f31", "Haskell"]}