{"tags": ["Haskell", "Heroku", "Elm"], "context": "This won't be a very in-depth tutorial or anything, but should serve to provide an updated reference for how to make a simple Haskell web app using Scotty that connects to Redis and serves out some static assets (in this case, my Elm app).\nThis project uses stack and requires little more than haskell-stack on homebrew and npm.\n\nConfig\n\nHaskell\nOnce the stack project init has run, you'll have to add some dependencies to [your-proj].cabal:\nbuild-depends:       base\n                   , scotty <- scotty and some deps\n                   , clay\n                   , text\n                   , blaze-html <- blaze for html\n                   , blaze-markup\n                   , wai-extra <- stuff for the web app interface\n                   , wai-middleware-static\n                   , hedis <- redis lib for haskell\n                   , directory <- system directory info stuff\n                   , regex-base <- regex packages\n                   , regex-tdfa\n                   , regex-compat-tdfa\n                   , bytestring <- because many libs use bytestrings\n                   , transformers <- monad transformers, e.g. liftIO\n                   , aeson <- aeson for JSON\n\nIn addition, I've found I've had to declare my other modules like so: (please correct me if I've messed it up)\nother-modules:       Database\n                   , Routes\n                   , Views.Index\n                   , Views.Layout\n\n\nWeb\nI also have a front-end project within in a directory called \"web\". Probably the config can live in your main project folder, I just made it this way out of laziness.\nweb/\n  src/\n    Main.elm\n    index.js\n  package.json\n  webpack.config.js\n\nin project.json:\n  \"devDependencies\": {\n    \"elm-webpack-loader\": \"^3.0.3\",\n    \"webpack\": \"^1.13.1\"\n  },\n\nwebpack.config.js:\n  module.exports = {\n    entry: [\n      './src/index.js'\n    ],\n    output: {\n      filename: 'dist/index.js'\n    },\n    module: {\n      loaders: [{\n        test: /\\.elm$/,\n        exclude: [/elm-stuff/, /node_modules/],\n        loader: 'elm-webpack'\n      }]\n    }\n  };\n\nWe'll come back to Heroku set up at the very end.\n\nCode\n\nHaskell\nI don't necessarily want to go into everything, but I'll try to have the important bits included.\nMain:\nimport Database (connectInfo, getDBConnection, seedDB)\nimport Routes (routes)\n\nmain :: IO ()\nmain = do\n  -- get the list of my show files, extract the show name, and then remove duplicates\n  myShows <- nub . getNames <$> getShows\n\n  -- read in environment vars\n  port <- read <$> getEnv \"PORT\"\n  host <- getEnv \"REDIS_HOST\"\n  redisPort <- getEnv \"REDIS_PORT\"\n  auth <- getEnv \"REDIS_AUTH\"\n\n  -- get a connection to my DB using my own connectInfo constructor helper\n  -- also make sure my auth key has been packed into a bytestring\n  conn <- getDBConnection $ connectInfo host redisPort $ pack auth\n\n  -- run the seeding of my DB\n  _ <- seedDB conn myShows\n\n  -- start up scotty now\n  scotty port $ do\n    -- apply static asset delivery using the provided path\n    middleware $ staticPolicy $ addBase \"web/dist\"\n\n    -- apply my routes function\n    routes conn myShows\n\nRoutes:\nroutes :: Connection -> [String] -> ScottyM ()\nroutes conn myShows = do\n  get \"/\" $ do\n    -- lift the IO operation from the standard ScottyM action\n    -- where I'm encoding data I get and showing it as a String\n    -- mapped to the result of fetching my shows data\n    myShows' <- liftIO $ show . encode <$> fetchShowsData conn myShows\n\n    -- build html with blaze using that string input\n    indexView myShows'\n\n  post \"/increment\" $ do\n    -- get \"name\" from the form data params\n    name <- param \"name\"\n\n    -- do an incrementShow operation\n    result <- liftIO $ incrementShow conn name\n\n    -- handle the result\n    case result of\n      -- when it works, we can build html packing the string showing of the result\n      Right int -> html $ pack $ show int\n\n      -- very lazy error case handling\n      _ -> html \"u suck\"\n\nDatabase:\n-- declare the MyShow type and its fields\ndata MyShow = MyShow\n  { name :: String\n  , count :: String\n  }\n\n-- then instance Data.Aeson.ToJSON accordingly for how to serialize MyShow\n-- (this can be generically derived though, I did it for verbosity)\ninstance ToJSON MyShow where\n  toJSON (MyShow name' count') = object [\"name\" .= name', \"count\" .= count']\n\n-- fetchShowsData looks like this: (it's not actually *as* shitty as it looks at first)\nfetchShowsData :: Connection -> [String] -> IO [MyShow]\nfetchShowsData conn xs =\n  -- map my extract method to the inner functor (my list of shows)\n  -- and map that to the result of getting each show from the list xs\n  -- traverse lets me do all the IO operations and return the result\n  (<$>) extract <$> getShow `traverse` xs\n\n  where\n    -- run the redis command using the connection\n    -- and map the result with a tuple of (x, result)\n    -- using the command GET with my key prefixed appropriately\n    getShow x = runRedis conn $ (x,) <$> get (prefix x)\n\n    -- extract the tuple information to a MyShow\n    extract (x, y) =\n      MyShow\n        { name = x\n        , count = case y of\n            Right (Just a) -> unpack a\n            _ -> \"N/A\"\n        }\n\n-- updateShow (and inc, dec) are much simpler:\ndata UpdateShow = INCREMENT | DECREMENT\n\nupdateShow :: UpdateShow -> Connection -> String -> IO (Either Reply Integer)\nupdateShow update conn =\n  -- run the command specified and prefix the provided key accordingly\n  runRedis conn . command . prefix\n\n  where\n    -- the ADT argument breaks down to two operations we support here\n    command = case update of\n      INCREMENT -> incr\n      DECREMENT -> decr\n\n-- create an incrementing updateShow function\nincrementShow = updateShow INCREMENT\n\n-- vice versa\ndecrementShow = updateShow DECREMENT\n\nViews.Index:\ninjectScript :: String -> Html\ninjectScript = script . toHtml\n\n-- it's HTML. not too much involved.\nindexView showData = html . renderHtml $ layout \"tracker\" $ do\n  div ! class_ \"container-fluid\" $\n    div ! id \"app\" $ mempty\n  injectScript $ printf \"showData = JSON.parse(%s);\" showData\n  script ! src \"index.js\" $ mempty\n\nAnd that's about it, really, for my Haskell code.\n\nElm\nIt's a pretty normal Elm application now that you don't have a lot of flexibility in 0.17. I do take the show updates and shove them in ports though, as the normal HTTP solutions provided in other user libs don't have enough for what I need.\nmain : Program { showData : List Show }\nmain =\n  programWithFlags\n    { init = \\x -> ( { initModel | showData = x.showData }, Cmd.none )\n    , view = view\n    , update = update\n    , subscriptions = subscriptions\n    }\n\nport showDataUpdates : (Show -> msg) -> Sub msg\n\nsubscriptions : Model -> Sub Msg\nsubscriptions _ =\n  Sub.batch\n    [ downs handleKeyDown\n    , ups handleKeyUp\n    , showDataUpdates ShowDataUpdate\n    ]\n\nport updateRequests : { target : String, name : String } -> Cmd msg\n\nupdateShow : String -> Model -> Cmd msg\nupdateShow target { showData, cursor } =\n  let name =\n    case showData !! cursor of\n      Just x -> x.name\n      Nothing -> \"\"\n  in\n    updateRequests\n      { target = target\n      , name = name\n      }\n\nincrementShow = updateShow \"increment\"\ndecrementShow = updateShow \"decrement\"\n\nAnd so for the JS code that uses this:\nvar Elm = require('./Main.elm');\n\nvar app = Elm.Main.embed(document.getElementById('app'), {\n  showData: window.showData\n});\n\napp.ports.updateRequests.subscribe(function (x) {\n  console.log(x)\n  const xhr = new XMLHttpRequest();\n  xhr.open('POST', x.target, true);\n  xhr.setRequestHeader('Content-type', 'application/x-www-form-urlencoded');\n  xhr.send('name=' + x.name);\n  xhr.onload = function (e) {\n    app.ports.showDataUpdates.send({\n      name: x.name,\n      count: e.target.response\n    });\n  };\n});\n\nAnd that's it for my front-end code.\n\nDeployment on Heroku\nThere's a few things we need to deploy to Heroku.\n\nEnvironment\nI went through and made a Heroku app and used the Heroku Redis add-on. I then linked my Github project, set the buildpack to https://github.com/mfine/heroku-buildpack-stack, and set my environment variables needed for this project (REDIS_HOST, etc).\n\nCode\nYou'll have to make a Procfile in your repo, so I did so with web: .local/bin/tracker-hs. Note that you'll have to match your executable target's name in your cabal file and make sure the path to the binary is correct. Otherwise, you can start digging with heroku run bash.\nAfter all this, you should be able to deploy a branch and have it all work. Note that for my front-end, I'm choosing to build the front-end and push a prepared-dist branch, since I'm too lazy to do that correctly (you might use Travis to do that kind of thing, maybe).\n\nLinks\n\nMy Project: https://github.com/justinwoo/tracker-hs\n\nStack - haskellstack.org\nScotty - https://hackage.haskell.org/package/scotty\n\nHedis - https://hackage.haskell.org/package/hedis\n\nHeroku Stack Buildpack - https://github.com/mfine/heroku-buildpack-stack\n\n\nThis won't be a very in-depth tutorial or anything, but should serve to provide an updated reference for how to make a simple Haskell web app using Scotty that connects to Redis and serves out some static assets (in this case, my Elm app).\n\nThis project uses [stack](haskellstack.org) and requires little more than `haskell-stack` on homebrew and npm.\n\n## Config\n\n### Haskell\n\nOnce the stack project init has run, you'll have to add some dependencies to `[your-proj].cabal`:\n\n```\nbuild-depends:       base\n                   , scotty <- scotty and some deps\n                   , clay\n                   , text\n                   , blaze-html <- blaze for html\n                   , blaze-markup\n                   , wai-extra <- stuff for the web app interface\n                   , wai-middleware-static\n                   , hedis <- redis lib for haskell\n                   , directory <- system directory info stuff\n                   , regex-base <- regex packages\n                   , regex-tdfa\n                   , regex-compat-tdfa\n                   , bytestring <- because many libs use bytestrings\n                   , transformers <- monad transformers, e.g. liftIO\n                   , aeson <- aeson for JSON\n```\n\nIn addition, I've found I've had to declare my other modules like so: (please correct me if I've messed it up)\n\n```\nother-modules:       Database\n                   , Routes\n                   , Views.Index\n                   , Views.Layout\n```\n\n### Web\n\nI also have a front-end project within in a directory called \"web\". Probably the config can live in your main project folder, I just made it this way out of laziness.\n\n```\nweb/\n  src/\n    Main.elm\n    index.js\n  package.json\n  webpack.config.js\n```\n\n```\nin project.json:\n  \"devDependencies\": {\n    \"elm-webpack-loader\": \"^3.0.3\",\n    \"webpack\": \"^1.13.1\"\n  },\n\nwebpack.config.js:\n  module.exports = {\n    entry: [\n      './src/index.js'\n    ],\n    output: {\n      filename: 'dist/index.js'\n    },\n    module: {\n      loaders: [{\n        test: /\\.elm$/,\n        exclude: [/elm-stuff/, /node_modules/],\n        loader: 'elm-webpack'\n      }]\n    }\n  };\n```\n\nWe'll come back to Heroku set up at the very end.\n\n## Code\n\n### Haskell\n\nI don't necessarily want to go into everything, but I'll try to have the important bits included.\n\nMain:\n\n```haskell\nimport Database (connectInfo, getDBConnection, seedDB)\nimport Routes (routes)\n\nmain :: IO ()\nmain = do\n  -- get the list of my show files, extract the show name, and then remove duplicates\n  myShows <- nub . getNames <$> getShows\n\n  -- read in environment vars\n  port <- read <$> getEnv \"PORT\"\n  host <- getEnv \"REDIS_HOST\"\n  redisPort <- getEnv \"REDIS_PORT\"\n  auth <- getEnv \"REDIS_AUTH\"\n\n  -- get a connection to my DB using my own connectInfo constructor helper\n  -- also make sure my auth key has been packed into a bytestring\n  conn <- getDBConnection $ connectInfo host redisPort $ pack auth\n\n  -- run the seeding of my DB\n  _ <- seedDB conn myShows\n\n  -- start up scotty now\n  scotty port $ do\n    -- apply static asset delivery using the provided path\n    middleware $ staticPolicy $ addBase \"web/dist\"\n\n    -- apply my routes function\n    routes conn myShows\n```\n\nRoutes:\n\n```haskell\nroutes :: Connection -> [String] -> ScottyM ()\nroutes conn myShows = do\n  get \"/\" $ do\n    -- lift the IO operation from the standard ScottyM action\n    -- where I'm encoding data I get and showing it as a String\n    -- mapped to the result of fetching my shows data\n    myShows' <- liftIO $ show . encode <$> fetchShowsData conn myShows\n\n    -- build html with blaze using that string input\n    indexView myShows'\n\n  post \"/increment\" $ do\n    -- get \"name\" from the form data params\n    name <- param \"name\"\n\n    -- do an incrementShow operation\n    result <- liftIO $ incrementShow conn name\n\n    -- handle the result\n    case result of\n      -- when it works, we can build html packing the string showing of the result\n      Right int -> html $ pack $ show int\n\n      -- very lazy error case handling\n      _ -> html \"u suck\"\n```\n\nDatabase:\n\n```haskell\n-- declare the MyShow type and its fields\ndata MyShow = MyShow\n  { name :: String\n  , count :: String\n  }\n\n-- then instance Data.Aeson.ToJSON accordingly for how to serialize MyShow\n-- (this can be generically derived though, I did it for verbosity)\ninstance ToJSON MyShow where\n  toJSON (MyShow name' count') = object [\"name\" .= name', \"count\" .= count']\n\n-- fetchShowsData looks like this: (it's not actually *as* shitty as it looks at first)\nfetchShowsData :: Connection -> [String] -> IO [MyShow]\nfetchShowsData conn xs =\n  -- map my extract method to the inner functor (my list of shows)\n  -- and map that to the result of getting each show from the list xs\n  -- traverse lets me do all the IO operations and return the result\n  (<$>) extract <$> getShow `traverse` xs\n\n  where\n    -- run the redis command using the connection\n    -- and map the result with a tuple of (x, result)\n    -- using the command GET with my key prefixed appropriately\n    getShow x = runRedis conn $ (x,) <$> get (prefix x)\n\n    -- extract the tuple information to a MyShow\n    extract (x, y) =\n      MyShow\n        { name = x\n        , count = case y of\n            Right (Just a) -> unpack a\n            _ -> \"N/A\"\n        }\n\n-- updateShow (and inc, dec) are much simpler:\ndata UpdateShow = INCREMENT | DECREMENT\n\nupdateShow :: UpdateShow -> Connection -> String -> IO (Either Reply Integer)\nupdateShow update conn =\n  -- run the command specified and prefix the provided key accordingly\n  runRedis conn . command . prefix\n\n  where\n    -- the ADT argument breaks down to two operations we support here\n    command = case update of\n      INCREMENT -> incr\n      DECREMENT -> decr\n\n-- create an incrementing updateShow function\nincrementShow = updateShow INCREMENT\n\n-- vice versa\ndecrementShow = updateShow DECREMENT\n```\n\nViews.Index:\n\n```haskell\ninjectScript :: String -> Html\ninjectScript = script . toHtml\n\n-- it's HTML. not too much involved.\nindexView showData = html . renderHtml $ layout \"tracker\" $ do\n  div ! class_ \"container-fluid\" $\n    div ! id \"app\" $ mempty\n  injectScript $ printf \"showData = JSON.parse(%s);\" showData\n  script ! src \"index.js\" $ mempty\n```\n\nAnd that's about it, really, for my Haskell code.\n\n### Elm\n\nIt's a pretty normal Elm application now that you don't have a lot of flexibility in 0.17. I do take the show updates and shove them in ports though, as the normal HTTP solutions provided in other user libs don't have enough for what I need.\n\n```haskell\nmain : Program { showData : List Show }\nmain =\n  programWithFlags\n    { init = \\x -> ( { initModel | showData = x.showData }, Cmd.none )\n    , view = view\n    , update = update\n    , subscriptions = subscriptions\n    }\n\nport showDataUpdates : (Show -> msg) -> Sub msg\n\nsubscriptions : Model -> Sub Msg\nsubscriptions _ =\n  Sub.batch\n    [ downs handleKeyDown\n    , ups handleKeyUp\n    , showDataUpdates ShowDataUpdate\n    ]\n\nport updateRequests : { target : String, name : String } -> Cmd msg\n\nupdateShow : String -> Model -> Cmd msg\nupdateShow target { showData, cursor } =\n  let name =\n    case showData !! cursor of\n      Just x -> x.name\n      Nothing -> \"\"\n  in\n    updateRequests\n      { target = target\n      , name = name\n      }\n\nincrementShow = updateShow \"increment\"\ndecrementShow = updateShow \"decrement\"\n```\n\nAnd so for the JS code that uses this:\n\n```js\nvar Elm = require('./Main.elm');\n\nvar app = Elm.Main.embed(document.getElementById('app'), {\n  showData: window.showData\n});\n\napp.ports.updateRequests.subscribe(function (x) {\n  console.log(x)\n  const xhr = new XMLHttpRequest();\n  xhr.open('POST', x.target, true);\n  xhr.setRequestHeader('Content-type', 'application/x-www-form-urlencoded');\n  xhr.send('name=' + x.name);\n  xhr.onload = function (e) {\n    app.ports.showDataUpdates.send({\n      name: x.name,\n      count: e.target.response\n    });\n  };\n});\n```\n\nAnd that's it for my front-end code.\n\n## Deployment on Heroku\n\nThere's a few things we need to deploy to Heroku.\n\n### Environment\n\nI went through and made a Heroku app and used the Heroku Redis add-on. I then linked my Github project, set the buildpack to `https://github.com/mfine/heroku-buildpack-stack`, and set my environment variables needed for this project (`REDIS_HOST`, etc).\n\n### Code\n\nYou'll have to make a Procfile in your repo, so I did so with `web: .local/bin/tracker-hs`. Note that you'll have to match your executable target's name in your cabal file and make sure the path to the binary is correct. Otherwise, you can start digging with `heroku run bash`.\n\nAfter all this, you should be able to deploy a branch and have it all work. Note that for my front-end, I'm choosing to build the front-end and push a `prepared-dist` branch, since I'm too lazy to do that correctly (you might use Travis to do that kind of thing, maybe).\n\n## Links\n\n* My Project: https://github.com/justinwoo/tracker-hs\n* Stack - haskellstack.org\n* Scotty - https://hackage.haskell.org/package/scotty\n* Hedis - https://hackage.haskell.org/package/hedis\n* Heroku Stack Buildpack - https://github.com/mfine/heroku-buildpack-stack\n"}