{"tags": ["Python", "rust"], "context": " \u3053\u306e\u8a18\u4e8b\u306f\u6700\u7d42\u66f4\u65b0\u65e5\u304b\u30891\u5e74\u4ee5\u4e0a\u304c\u7d4c\u904e\u3057\u3066\u3044\u307e\u3059\u3002Rust 1.0 \u3067\u52d5\u4f5c\u3092\u78ba\u8a8d\u3057\u3066\u3044\u307e\u3059\n1.0\u306b\u304a\u3044\u3066\u3082\u7d50\u69cb\u306a\u6570\u306eAPI\u304cunstable\u306e\u307e\u307e\u306a\u306e\u3067\u6ce8\u610f\u3057\u3066\u304f\u3060\u3055\u3044\u3002\n\nabs\nfn abs() {\n    println!(\"abs(-1.5f32)={}\", -1.5f32.abs());\n    println!(\"abs(-2i32)={}\", -2i32.abs());\n}\n\n\nall\nfn all() {\n    // range\u306fint\u578b\n    (0..10).all(|x| x % 2 == 0);\n    // \u901a\u5e38\u306eiterator\u306f&int\u578b\n    [2, 4].iter().all(|&x| x % 2 == 0);\n    // range\u3068iterator\u3067\u8fd4\u3059\u578b\u304c\u9055\u3046\u306e\u306f\u6c17\u6301\u3061\u60aa\u3044\u306e\u3067\u3001\u5e38\u306b\u53c2\u7167\u3092\u8fd4\u3059\u3088\u3046\u306b\n    // \u3057\u3066\u6b32\u3057\u3044\n}\n\n\nany\nfn any() {\n    (0..10).any(|x| x == 9);\n    [0, 1].iter().all(|x| *x == 1);\n}\n\n\nascii\n\u6b8b\u5ff5\u306a\u304c\u3089\u7c21\u5358\u306b\u3084\u308b\u65b9\u6cd5\u306funstable\nfn ascii() {\n    // unstable feature\n    // println!(\"unicode escape is [{}]\", \"\u3042\u3044\u3046\u3048\u304aabcde\".escape_unicode());\n    // println!(\"default escape is [{}]\", \"\u3042\u3044\u3046\u3048\u304aabcde\\n\\t\\r\".escape_default());\n}\n\n\nbin\nfn bin() {\n    // \uff12\u9032\u6570\u30ea\u30c6\u30e9\u30eb\u306f0b0011\u307f\u305f\u3044\u306b\u5b9a\u7fa9\u3067\u304d\u308b\n    let a = 0b1010; // == 10\n    let b = format!(\"0b{:b}\", 10);\n    println!(\"{}\", b);\n}\n\n\nbytearray, bytes\nfn bytearray() {\n    // 1\n    let x: Vec<char> = vec!['\\x20', 'a'];\n    // 2\n    let mut y = Vec::new();\n    write!(&mut y, \"abcde\u3042\u3044\u3046\");\n    // 3\n    let z = \"\u3042\u3044\u3046\".bytes().collect::<Vec<u8>>();\n}\n\n\nchr\nfn chr() {\n    println!(\"{:?}\", std::char::from_u32(0x61));\n}\n\n\ndict\nfn dict() {\n   let mut a = std::collections::HashMap::<&str, &str>::new();\n   a.insert(\"a\", \"A\");\n}\n\n\ndivmod\nfn divmod() {\n    let a = 5;\n    let (b, c) = (a / 2, a % 2);\n    println!(\"divmod: {}, {}\", b, c);\n}\n\n\nenumerate\nfn enumerate() {\n    // enumerate(start=1)\u306e\u3088\u3046\u306a\u30aa\u30d7\u30b7\u30e7\u30f3\u306f\u7121\u3044\n    for (idx, x) in (1..3).enumerate() {\n        println!(\"enumerate: {}, {}\", idx, x);\n    }\n}\n\n\nfilter\nfn filter() {\n    let x = [1, 2, 3, 4, 5];\n    println!(\"filter: {:?}\", x.iter().filter_map(|&x| if x % 2 == 0 {Some(x)} else {None}).collect::<Vec<i32>>());\n    // Filter \u30aa\u30d6\u30b8\u30a7\u30af\u30c8\n    let y = x.iter().filter(|&x| *x % 2 == 0);\n}\n\n\nfloat\nfn float() {\n    // from string\n   let x = \"-1.5e-1\".parse::<f32>();\n   // from integer\n   let y = 100i32 as f32;\n   let z = \"inf\".parse::<f32>();\n   println!(\"float: {:?}, {:?}, {:?}\", x, y, z);\n}\n\n\nformat\nfn format() {\n    let x = format!(\"{}, {}\", \"hello\", \"world!\");\n    println!(\"{}\", x);\n}\n\n\nfrozenset, set\nfn frozenset() {\n    let mut x = std::collections::HashSet::<i32>::new();\n    x.insert(0);\n    x.insert(1);\n    let y = x.clone();  // immutable\n    let z: std::collections::HashSet<i32> = [1, 2, 3].iter().map(|&x| x).collect();\n}\n\n\nhash\n\u307e\u3060unstable\nfn hash() {\n    // unstable feature\n    // println!(\"hash: {}\", std::hash::hash::<_, std::hash::SipHasher>(&0));\n}\n\n\nhex\nfn hex() {\n    let x = format!(\"0x{:x}, {}\", 0x20, 0x20);\n    println!(\"hex: {}\", x);\n}\n\n\nid\n\u540c\u4e00\u30aa\u30d6\u30b8\u30a7\u30af\u30c8\u304b\u3069\u3046\u304b\u8abf\u3079\u308b\u306b\u306f\u3001\u30a2\u30c9\u30ec\u30b9\u3092\u8abf\u3079\u308b\u307b\u304b\u306a\u3044\uff1f\nfn id() {\n    let x = 1;\n    let y = format!(\"{:p}\", &x);  // address\u3092\u6587\u5b57\u5217\u3067\u53d6\u5f97\n    println!(\"id: x={}\", y);\n    let z = x;\n    println!(\"id: x is z?: {}\", (&z as *const _) == (&x as *const _));\n}\n\n\ninput\nfn input() {\n    print!(\"Please input any:\");\n    let mut x = String::new();\n    std::io::stdin().read_line(&mut x).ok().expect(\"Failed\");\n    println!(\"input: {}\", x);\n}\n\n\nint\nfn int() {\n    let x: i32 = \"123\".parse().ok().except(\"not int\");\n    assert_eq!(x, 123);\n    let y = 123.456f32 as i32;\n    assert_eq!(x, y);\n}\n\n\niter\nfn iter() {\n    let x = [1, 2];\n    let y = x.iter();\n}\n\n\nlen\nfn len() {\n    let x = [1, 2];\n    println!(\"len: {}\", x.len());\n}\n\n\nlist\nfn list() {\n    // Fixed size\n    let x = [1, 2];\n    // Variable size\n    let mut y = vec![1, 2];\n    y.push(3);\n}\n\n\nmap\nfn map() {\n    let x = [1, 2];\n    let y = x.iter().map(|&x| x * 2);\n    println!(\"map: {:?}\", y.collect::<Vec<i32>>());\n}\n\n\nmax\nmin_max\u306f\u307e\u3060unstable\nfn max() {\n    let x = [1, 3, 2];\n    let y = x.iter().max();\n    println!(\"max: {:?}\", y);\n    println!(\"max: min_max: {:?}\", x.iter().min_max());\n    println!(\"max: number: {}\", std::cmp::max(5, 3));\n}\n\n\nmin\nmin_max\u306f\u307e\u3060unstable\nfn min() {\n    let x = [1, 3, 2];\n    let y = x.iter().min();\n    println!(\"min: {:?}\", y);\n    // println!(\"min: min_max: {:?}\", x.iter().min_max());\n    println!(\"min: number: {}\", std::cmp::min(5, 3));\n}\n\n\nnext\nfn next() {\n    let x = [1, 2, 3];\n    let mut y = x.iter();\n    println!(\"next: {:?}\", y.next());  // iterator\u81ea\u4f53\u3092mutable\u306b\u3059\u308b\u5fc5\u8981\u3042\u308a\n    println!(\"next: {:?}\", y.next());\n}\n\n\noct\nfn oct() {\n    let x = format!(\"{:o}\", 10);\n    println!(\"oct: {}\", x);\n}\n\n\nopen\nfn open() {\n    let x = std::fs::File::open(\"hoge.txt\");\n}\n\n\nord\nfn ord() {\n    // cast\u3059\u308b\u3068\u5f97\u3089\u308c\u308b\n    let x = '\u3042' as u32;\n    println!(\"ord: 0x{:x}, {}\", x, x);\n}\n\n\npow\nfn pow() {\n    use std::num::{Int, Float};\n    println!(\"pow: {}\", 2.pow(3));\n    println!(\"powf: {}, powi: {}\", 2.0f32.powf(3.0f32), 2.0f32.powi(-1));\n}\n\n\nprint\nfn print() {\n    print!(\"print!\");\n    println!(\"println!\");\n}\n\n\nrange\nrange notation\u3092\u4f7f\u3046\u3002step_by\u306b\u3088\u308b\u98db\u3073\u98db\u3073\u306erange\u306f\u307e\u3060unstable\nfn _range() {\n    println!(\"range: {:?}\", (0..2).collect::<Vec<i32>>());\n    // unstable\n    // println!(\"range_step: {:?}\", (0..4).step_by(2).collect::<Vec<i32>>());\n    // println!(\"range_step(negative): {:?}\", (4..0).step_by(-2).collect::<Vec<i32>>());\n\n\nreverse\nfn reverse() {\n    let x = [1, 2];\n    for i in x.iter().rev() {println!(\"reverse: {}\", i);}  // reverse iterator\n    let mut y = x.clone();\n    y.reverse();  // \u76f4\u63a5\u9006\u9806\u306b\u3059\u308b\n}\n\n\nround\nfn round() {\n    // Python\u306eround\u3068\u306f\u6319\u52d5\u304c\u9055\u3046\n    use std::num::Float;\n    println!(\"round 0.5 = {}\", 0.5f32.round());\n    println!(\"round -0.5 = {}\", -0.5f32.round());\n    println!(\"round 1.5 = {}\", 1.5f32.round());\n    println!(\"round -1.5 = {}\", -1.5f32.round());\n}\n\n\nslice\nslice notation\u306b\u4e00\u672c\u5316\u3055\u308c\u308b\u898b\u901a\u3057\uff1f\n\u9589\u533a\u9593\u306f\u4f5c\u308c\u306a\u304f\u306a\u3063\u305f\u3002\u4eca\u5f8c\u3069\u3046\u306a\u308b\u306e\u304b\u306a\uff1f\nfn slice() {\n    let x = [1, 2, 3, 4, 5];\n    println!(\"slice of {:?}: {:?}\", x, &x[1..3]);\n    println!(\"slice_from of {:?}: {:?}\", x, &x[1..]);\n    println!(\"slice_to of {:?}: {:?}\", x, &x[..3]);\n    println!(\"full_slice of {:?}: {:?}\", x, &x[..]);\n}\n\n\nsorted\nfn sorted() {\n    // in-place\u306e\u307f\n    let x = [1, 4, 2, 3];\n    let mut y = x.clone();\n    y.sort();\n    println!(\"sort: {:?}\", y);\n}\n\n\nsum\n\u30ba\u30d0\u30easum()\u306f\u307e\u3060unstable\u306a\u306e\u3067\u3001fold\u3067\u4ee3\u7528\u3059\u308b\nfn sum() {\n    let x = (1..11).fold(0, |n, x| n + x);\n    println!(\"sum from 1 to 10 = {}\", x);\n    // unstable\n    // println!(\"sum: {}\", (1..11).sum::<i32>());\n}\n\n\nsuper\nRust\u306esuper\u30ad\u30fc\u30ef\u30fc\u30c9\u306f\u3001\u89aa\u30e2\u30b8\u30e5\u30fc\u30eb\u3092\u6307\u3059\u70ba\u306b\u7528\u3044\u3089\u308c\u308b\nuse super::child_module;\n\n\ntuple\nfn tuple() {\n    let x = (1, \"string\");\n}\n\n\ntype\nstd::intrinsics\u306b\u3042\u308b\u306e\u304b\uff1f\u3088\u304f\u308f\u304b\u3089\u3093\n\nzip\nfn zip() {\n    let x = [1, 2];\n    let y = [\"one\", \"two\"];\n    // \uff13\u3064\u4ee5\u4e0a\u306e\u8981\u7d20\u3092\u6c17\u8efd\u306b\u307e\u3068\u3081\u308b\u306e\u306f\u7121\u7406\u3063\u307d\u3044\u3002\u81ea\u5206\u3067flat_map\u4f7f\u3063\u3066\u95a2\u6570\u66f8\u3051\u3070\u51fa\u6765\u308b\n    let z: Vec<(&i32, &&str)> = x.iter().zip(y.iter()).collect();\n    println!(\"{:?}\", z);\n}\n\n\nRust 1.0 \u3067\u52d5\u4f5c\u3092\u78ba\u8a8d\u3057\u3066\u3044\u307e\u3059\n\n1.0\u306b\u304a\u3044\u3066\u3082\u7d50\u69cb\u306a\u6570\u306eAPI\u304cunstable\u306e\u307e\u307e\u306a\u306e\u3067\u6ce8\u610f\u3057\u3066\u304f\u3060\u3055\u3044\u3002\n\n\n\n## abs\n```rust\nfn abs() {\n    println!(\"abs(-1.5f32)={}\", -1.5f32.abs());\n    println!(\"abs(-2i32)={}\", -2i32.abs());\n}\n```\n\n## all\n```rust\nfn all() {\n    // range\u306fint\u578b\n    (0..10).all(|x| x % 2 == 0);\n    // \u901a\u5e38\u306eiterator\u306f&int\u578b\n    [2, 4].iter().all(|&x| x % 2 == 0);\n    // range\u3068iterator\u3067\u8fd4\u3059\u578b\u304c\u9055\u3046\u306e\u306f\u6c17\u6301\u3061\u60aa\u3044\u306e\u3067\u3001\u5e38\u306b\u53c2\u7167\u3092\u8fd4\u3059\u3088\u3046\u306b\n    // \u3057\u3066\u6b32\u3057\u3044\n}\n```\n\n## any\n```rust\nfn any() {\n    (0..10).any(|x| x == 9);\n    [0, 1].iter().all(|x| *x == 1);\n}\n```\n\n## ascii\n\u6b8b\u5ff5\u306a\u304c\u3089\u7c21\u5358\u306b\u3084\u308b\u65b9\u6cd5\u306funstable\n\n```rust\nfn ascii() {\n    // unstable feature\n    // println!(\"unicode escape is [{}]\", \"\u3042\u3044\u3046\u3048\u304aabcde\".escape_unicode());\n    // println!(\"default escape is [{}]\", \"\u3042\u3044\u3046\u3048\u304aabcde\\n\\t\\r\".escape_default());\n}\n```\n\n## bin\n```rust\nfn bin() {\n    // \uff12\u9032\u6570\u30ea\u30c6\u30e9\u30eb\u306f0b0011\u307f\u305f\u3044\u306b\u5b9a\u7fa9\u3067\u304d\u308b\n    let a = 0b1010; // == 10\n    let b = format!(\"0b{:b}\", 10);\n    println!(\"{}\", b);\n}\n```\n\n## bytearray, bytes\n```rust\nfn bytearray() {\n    // 1\n    let x: Vec<char> = vec!['\\x20', 'a'];\n    // 2\n    let mut y = Vec::new();\n    write!(&mut y, \"abcde\u3042\u3044\u3046\");\n    // 3\n    let z = \"\u3042\u3044\u3046\".bytes().collect::<Vec<u8>>();\n}\n```\n\n## chr\n```rust\nfn chr() {\n    println!(\"{:?}\", std::char::from_u32(0x61));\n}\n```\n\n## dict\n```rust\nfn dict() {\n   let mut a = std::collections::HashMap::<&str, &str>::new();\n   a.insert(\"a\", \"A\");\n}\n```\n\n## divmod\n```rust\nfn divmod() {\n    let a = 5;\n    let (b, c) = (a / 2, a % 2);\n    println!(\"divmod: {}, {}\", b, c);\n}\n```\n\n## enumerate\n```rust\nfn enumerate() {\n    // enumerate(start=1)\u306e\u3088\u3046\u306a\u30aa\u30d7\u30b7\u30e7\u30f3\u306f\u7121\u3044\n    for (idx, x) in (1..3).enumerate() {\n        println!(\"enumerate: {}, {}\", idx, x);\n    }\n}\n```\n\n## filter\n```rust\nfn filter() {\n    let x = [1, 2, 3, 4, 5];\n    println!(\"filter: {:?}\", x.iter().filter_map(|&x| if x % 2 == 0 {Some(x)} else {None}).collect::<Vec<i32>>());\n    // Filter \u30aa\u30d6\u30b8\u30a7\u30af\u30c8\n    let y = x.iter().filter(|&x| *x % 2 == 0);\n}\n```\n\n## float\n```rust\nfn float() {\n    // from string\n   let x = \"-1.5e-1\".parse::<f32>();\n   // from integer\n   let y = 100i32 as f32;\n   let z = \"inf\".parse::<f32>();\n   println!(\"float: {:?}, {:?}, {:?}\", x, y, z);\n}\n```\n\n## format\n```rust\nfn format() {\n    let x = format!(\"{}, {}\", \"hello\", \"world!\");\n    println!(\"{}\", x);\n}\n```\n\n## frozenset, set\n```rust\nfn frozenset() {\n    let mut x = std::collections::HashSet::<i32>::new();\n    x.insert(0);\n    x.insert(1);\n    let y = x.clone();  // immutable\n    let z: std::collections::HashSet<i32> = [1, 2, 3].iter().map(|&x| x).collect();\n}\n```\n\n## hash\n\u307e\u3060unstable\n\n```rust\nfn hash() {\n    // unstable feature\n    // println!(\"hash: {}\", std::hash::hash::<_, std::hash::SipHasher>(&0));\n}\n```\n\n## hex\n```rust\nfn hex() {\n    let x = format!(\"0x{:x}, {}\", 0x20, 0x20);\n    println!(\"hex: {}\", x);\n}\n```\n\n## id\n\u540c\u4e00\u30aa\u30d6\u30b8\u30a7\u30af\u30c8\u304b\u3069\u3046\u304b\u8abf\u3079\u308b\u306b\u306f\u3001\u30a2\u30c9\u30ec\u30b9\u3092\u8abf\u3079\u308b\u307b\u304b\u306a\u3044\uff1f\n\n```rust\nfn id() {\n    let x = 1;\n    let y = format!(\"{:p}\", &x);  // address\u3092\u6587\u5b57\u5217\u3067\u53d6\u5f97\n    println!(\"id: x={}\", y);\n    let z = x;\n    println!(\"id: x is z?: {}\", (&z as *const _) == (&x as *const _));\n}\n```\n\n## input\n```rust\nfn input() {\n    print!(\"Please input any:\");\n    let mut x = String::new();\n    std::io::stdin().read_line(&mut x).ok().expect(\"Failed\");\n    println!(\"input: {}\", x);\n}\n```\n\n## int\n```rust\nfn int() {\n    let x: i32 = \"123\".parse().ok().except(\"not int\");\n    assert_eq!(x, 123);\n    let y = 123.456f32 as i32;\n    assert_eq!(x, y);\n}\n```\n\n## iter\n```rust\nfn iter() {\n    let x = [1, 2];\n    let y = x.iter();\n}\n```\n\n## len\n```rust\nfn len() {\n    let x = [1, 2];\n    println!(\"len: {}\", x.len());\n}\n```\n\n## list\n```rust\nfn list() {\n    // Fixed size\n    let x = [1, 2];\n    // Variable size\n    let mut y = vec![1, 2];\n    y.push(3);\n}\n```\n\n## map\n```rust\nfn map() {\n    let x = [1, 2];\n    let y = x.iter().map(|&x| x * 2);\n    println!(\"map: {:?}\", y.collect::<Vec<i32>>());\n}\n```\n\n## max\nmin_max\u306f\u307e\u3060unstable\n\n```rust\nfn max() {\n    let x = [1, 3, 2];\n    let y = x.iter().max();\n    println!(\"max: {:?}\", y);\n    println!(\"max: min_max: {:?}\", x.iter().min_max());\n    println!(\"max: number: {}\", std::cmp::max(5, 3));\n}\n```\n\n## min\nmin_max\u306f\u307e\u3060unstable\n\n```rust\nfn min() {\n    let x = [1, 3, 2];\n    let y = x.iter().min();\n    println!(\"min: {:?}\", y);\n    // println!(\"min: min_max: {:?}\", x.iter().min_max());\n    println!(\"min: number: {}\", std::cmp::min(5, 3));\n}\n```\n\n## next\n```rust\nfn next() {\n    let x = [1, 2, 3];\n    let mut y = x.iter();\n    println!(\"next: {:?}\", y.next());  // iterator\u81ea\u4f53\u3092mutable\u306b\u3059\u308b\u5fc5\u8981\u3042\u308a\n    println!(\"next: {:?}\", y.next());\n}\n```\n\n## oct\n```rust\nfn oct() {\n    let x = format!(\"{:o}\", 10);\n    println!(\"oct: {}\", x);\n}\n```\n\n## open\n```rust\nfn open() {\n    let x = std::fs::File::open(\"hoge.txt\");\n}\n```\n\n## ord\n```rust\nfn ord() {\n    // cast\u3059\u308b\u3068\u5f97\u3089\u308c\u308b\n    let x = '\u3042' as u32;\n    println!(\"ord: 0x{:x}, {}\", x, x);\n}\n```\n\n## pow\n```rust\nfn pow() {\n    use std::num::{Int, Float};\n    println!(\"pow: {}\", 2.pow(3));\n    println!(\"powf: {}, powi: {}\", 2.0f32.powf(3.0f32), 2.0f32.powi(-1));\n}\n```\n\n## print\n```rust\nfn print() {\n    print!(\"print!\");\n    println!(\"println!\");\n}\n```\n\n## range\nrange notation\u3092\u4f7f\u3046\u3002step_by\u306b\u3088\u308b\u98db\u3073\u98db\u3073\u306erange\u306f\u307e\u3060unstable\n\n```rust\nfn _range() {\n    println!(\"range: {:?}\", (0..2).collect::<Vec<i32>>());\n    // unstable\n    // println!(\"range_step: {:?}\", (0..4).step_by(2).collect::<Vec<i32>>());\n    // println!(\"range_step(negative): {:?}\", (4..0).step_by(-2).collect::<Vec<i32>>());\n```\n\n## reverse\n```rust\nfn reverse() {\n    let x = [1, 2];\n    for i in x.iter().rev() {println!(\"reverse: {}\", i);}  // reverse iterator\n    let mut y = x.clone();\n    y.reverse();  // \u76f4\u63a5\u9006\u9806\u306b\u3059\u308b\n}\n```\n\n## round\n```rust\nfn round() {\n    // Python\u306eround\u3068\u306f\u6319\u52d5\u304c\u9055\u3046\n    use std::num::Float;\n    println!(\"round 0.5 = {}\", 0.5f32.round());\n    println!(\"round -0.5 = {}\", -0.5f32.round());\n    println!(\"round 1.5 = {}\", 1.5f32.round());\n    println!(\"round -1.5 = {}\", -1.5f32.round());\n}\n```\n\n\n## slice\nslice notation\u306b\u4e00\u672c\u5316\u3055\u308c\u308b\u898b\u901a\u3057\uff1f\n\u9589\u533a\u9593\u306f\u4f5c\u308c\u306a\u304f\u306a\u3063\u305f\u3002\u4eca\u5f8c\u3069\u3046\u306a\u308b\u306e\u304b\u306a\uff1f\n\n```rust\nfn slice() {\n    let x = [1, 2, 3, 4, 5];\n    println!(\"slice of {:?}: {:?}\", x, &x[1..3]);\n    println!(\"slice_from of {:?}: {:?}\", x, &x[1..]);\n    println!(\"slice_to of {:?}: {:?}\", x, &x[..3]);\n    println!(\"full_slice of {:?}: {:?}\", x, &x[..]);\n}\n```\n\n## sorted\n```rust\nfn sorted() {\n    // in-place\u306e\u307f\n    let x = [1, 4, 2, 3];\n    let mut y = x.clone();\n    y.sort();\n    println!(\"sort: {:?}\", y);\n}\n```\n\n## sum\n\u30ba\u30d0\u30easum()\u306f\u307e\u3060unstable\u306a\u306e\u3067\u3001fold\u3067\u4ee3\u7528\u3059\u308b\n\n```rust\nfn sum() {\n    let x = (1..11).fold(0, |n, x| n + x);\n    println!(\"sum from 1 to 10 = {}\", x);\n    // unstable\n    // println!(\"sum: {}\", (1..11).sum::<i32>());\n}\n```\n\n## super\nRust\u306esuper\u30ad\u30fc\u30ef\u30fc\u30c9\u306f\u3001\u89aa\u30e2\u30b8\u30e5\u30fc\u30eb\u3092\u6307\u3059\u70ba\u306b\u7528\u3044\u3089\u308c\u308b\n\n```rust\nuse super::child_module;\n```\n\n## tuple\n```rust\nfn tuple() {\n    let x = (1, \"string\");\n}\n```\n\n## type\n\nstd::intrinsics\u306b\u3042\u308b\u306e\u304b\uff1f\u3088\u304f\u308f\u304b\u3089\u3093\n\n## zip\n```rust\nfn zip() {\n    let x = [1, 2];\n    let y = [\"one\", \"two\"];\n    // \uff13\u3064\u4ee5\u4e0a\u306e\u8981\u7d20\u3092\u6c17\u8efd\u306b\u307e\u3068\u3081\u308b\u306e\u306f\u7121\u7406\u3063\u307d\u3044\u3002\u81ea\u5206\u3067flat_map\u4f7f\u3063\u3066\u95a2\u6570\u66f8\u3051\u3070\u51fa\u6765\u308b\n    let z: Vec<(&i32, &&str)> = x.iter().zip(y.iter()).collect();\n    println!(\"{:?}\", z);\n}\n"}