{"context": " More than 1 year has passed since last update.(4/20)\u5f79\u306e\u5224\u5b9a\u3092\u30a2\u30af\u30c6\u30a3\u30d6\u30d1\u30bf\u30fc\u30f3\u306b\u5909\u3048\u305f\u3002\n(4/21)\u6c17\u306b\u5165\u3089\u306a\u3044\u95a2\u6570\u540d\u3092\u5909\u3048\u305f\u3002\nparse\u95a2\u6570\u306f\u524d\u304b\u3089\u30d1\u30fc\u30b9\u305b\u305a\u306b\u5f8c\u308d\u304b\u3089\u30d1\u30fc\u30b9\u3057\u305f\u65b9\u304c\u77ed\u304f\u306a\u3063\u305f\u304b\u3082\u3002\n\npoker.fs\ntype Suit = Spade | Heart | Diamond | Club\ntype Rank = R2 | R3 | R4 | R5 | R6 | R7 | R8 | R9 | R10 | RJ | RQ | RK | RA\ntype Card = Rank * Suit\ntype Hand = Card * Card * Card * Card * Card\n\nlet toList (c0,c1,c2,c3,c4) = [c0;c1;c2;c3;c4]\n\nlet cardToNums (c:Card) =\n  match fst c with\n  | R2  -> [2]\n  | R3  -> [3]\n  | R4  -> [4]\n  | R5  -> [5]\n  | R6  -> [6]\n  | R7  -> [7]\n  | R8  -> [8]\n  | R9  -> [9]\n  | R10 -> [10]\n  | RJ  -> [11]\n  | RQ  -> [12]\n  | RK  -> [13]\n  | RA  -> [1;14]\n\nlet areSameSuit (xs:Card list) =\n  match xs with\n  | []    -> false\n  | c::cs -> List.forall (fun x -> snd x = snd c) cs\n\nlet areSequential (xs:int list) =\n  List.sort xs\n  |> Seq.pairwise\n  |> Seq.forall (fun (x,y) -> x + 1 = y)\n\nlet product (xss:'a list list) =\n  let folder (xs:'a list) (xss:'a list list)=\n    let (>>=) xs f = List.collect f xs\n    xs >>= fun y ->\n      xss >>= fun ys ->\n        [y::ys]\n  List.foldBack folder xss [[]]\n\nlet areSequentialNum (xs:Card list) =\n  List.map cardToNums xs\n  |> product\n  |> List.exists areSequential\n\nlet (|Straight|_|) (h:Hand) =\n  if h |> toList |> areSequentialNum then Some Straight else None\n\nlet (|Flush|_|) (h:Hand) =\n  if h |> toList |> areSameSuit then Some Flush else None\n\nlet (|StraightFlush|_|) (h:Hand) =\n  let l = toList h\n  if areSameSuit l && areSequentialNum l then Some StraightFlush else None\n\nlet (|RoyalFlush|_|) (h:Hand) =\n  let l = toList h\n  let areRoyal = List.map fst >> List.sort >> (=) [R10; RJ; RQ; RK; RA]\n  if areSameSuit l && areRoyal l then Some RoyalFlush else None\n\nlet removeAt i xs =\n  Seq.append (Seq.take i xs) (Seq.skip (i+1) xs)\n  |> Seq.toList\n\nlet removeOne xs =\n  List.map (fun i -> removeAt i xs) [0..(List.length xs - 1)]\n\nlet allExceptOne pred  =\n  toList >> removeOne >> List.exists pred\n\nlet (|FourFlush|_|) (h:Hand) =\n  if allExceptOne areSameSuit h then Some FourFlush else None\n\nlet (|FourStraight|_|) (h:Hand) =\n  if allExceptOne areSequentialNum h then Some FourStraight else None\n\nlet (|FourStraightFlush|_|) (h:Hand) =\n  let areStraightFlush l = areSameSuit l && areSequentialNum l\n  if allExceptOne areStraightFlush h then Some FourStraightFlush else None\n\nlet show (h:Hand) =\n  match h with\n  | RoyalFlush        -> \"RF\"\n  | StraightFlush     -> \"SF\"\n  | Flush             -> \"FL\"\n  | Straight          -> \"ST\"\n  | FourStraightFlush -> \"4SF\"\n  | FourFlush         -> \"4F\"\n  | FourStraight      -> \"4S\"\n  | _                 -> \"-\"\n\nlet parse (s:string) : Hand option =\n  let parseSuit r xs =\n    match xs with\n    | 's' :: ys -> Some ((r,Spade)  ,ys)\n    | 'h' :: ys -> Some ((r,Heart)  ,ys)\n    | 'd' :: ys -> Some ((r,Diamond),ys)\n    | 'c' :: ys -> Some ((r,Club)   ,ys)\n    | _         -> None\n  let parseCard xs =\n    match xs with\n    | '2' :: ys        -> parseSuit R2 ys\n    | '3' :: ys        -> parseSuit R3 ys\n    | '4' :: ys        -> parseSuit R4 ys\n    | '5' :: ys        -> parseSuit R5 ys\n    | '6' :: ys        -> parseSuit R6 ys\n    | '7' :: ys        -> parseSuit R7 ys\n    | '8' :: ys        -> parseSuit R8 ys\n    | '9' :: ys        -> parseSuit R9 ys\n    | '1' :: '0' :: ys -> parseSuit R10 ys\n    | 'J' :: ys        -> parseSuit RJ ys\n    | 'Q' :: ys        -> parseSuit RQ ys\n    | 'K' :: ys        -> parseSuit RK ys\n    | 'A' :: ys        -> parseSuit RA ys\n    | _ -> None\n  let rec parseCards cs xs =\n    match xs with\n    | [] -> cs\n    | _  -> match parseCard xs with\n            | Some (c,ys) -> parseCards (c::cs) ys\n            | None        -> []\n\n  match parseCards [] (Seq.toList s) with\n  | c4::c3::c2::c1::c0::[] -> Some (c0,c1,c2,c3,c4)\n  | _                      -> None\n\n(* for test *)\n\ntype TestResult = Success | Failure\n\nlet test target expected =\n  let areSame expected actual =\n    if expected = actual then Success else Failure\n  let result =\n    match parse target with\n    | Some h -> show h |> areSame expected\n    | None   -> Failure\n  printfn \"%A\" result\n\n[<EntryPoint>]\nlet main args =\n  (*  0 *) test \"Qs9s3dJd10h\" \"4S\"\n  (*  1 *) test \"KdAdJd10dQd\" \"RF\"\n  (*  2 *) test \"QhJhKhAh10h\" \"RF\"\n  (*  3 *) test \"10dAdJsQdKd\" \"ST\"\n  (*  4 *) test \"Kd10dAdJd3d\" \"FL\"\n  (*  5 *) test \"4d3d2dAd5d\" \"SF\"\n  (*  6 *) test \"5d5d2d3dAd\" \"FL\"\n  (*  7 *) test \"4d2sAd5d3d\" \"ST\"\n  (*  8 *) test \"As10dJdQdKd\" \"ST\"\n  (*  9 *) test \"10d10dQdAsJd\" \"4F\"\n  (* 10 *) test \"AcJd10dQdKd\" \"ST\"\n  (* 11 *) test \"Kd2sJdAdQd\" \"4SF\"\n  (* 12 *) test \"JdAdQcKd2s\" \"4S\"\n  (* 13 *) test \"KdAdKdJd2s\" \"4F\"\n  (* 14 *) test \"As2dKdQdJd\" \"4F\"\n  (* 15 *) test \"AsKdQd2dJh\" \"4S\"\n  (* 16 *) test \"QhAd2s3dKd\" \"-\"\n  (* 17 *) test \"Ad4dKh3s2d\" \"4S\"\n  (* 18 *) test \"3d2dAh5d4s\" \"ST\"\n  (* 19 *) test \"QcKdAs2dJd\" \"4S\"\n  (* 20 *) test \"2dQcJdAs10d\" \"-\"\n  (* 21 *) test \"4d7d5s3c2d\" \"4S\"\n  (* 22 *) test \"7d5s4dAd3c\" \"-\"\n  (* 23 *) test \"3s8s10sQs6s\" \"FL\"\n  (* 24 *) test \"6hAh3h2h8h\" \"FL\"\n  (* 25 *) test \"3h4hJh9hQh\" \"FL\"\n  (* 26 *) test \"3s6s5s2sQs\" \"FL\"\n  (* 27 *) test \"9d3cKdQc2c\" \"-\"\n  (* 28 *) test \"5sKs7hQcKh\" \"-\"\n  (* 29 *) test \"Ad6d7h7c9h\" \"-\"\n  (* 30 *) test \"10h4cAh6s10c\" \"-\"\n  (* 31 *) test \"9sKsJcQs10d\" \"ST\"\n  (* 32 *) test \"5d3c2cAs4c\" \"ST\"\n  (* 33 *) test \"KcQs9c10sJs\" \"ST\"\n  (* 34 *) test \"9d8s10hJdQd\" \"ST\"\n  (* 35 *) test \"6c5s10h7d4c\" \"4S\"\n  (* 36 *) test \"QhJcKsAh8c\" \"4S\"\n  (* 37 *) test \"JsQc3h10cKs\" \"4S\"\n  (* 38 *) test \"10c9h7hAd8d\" \"4S\"\n  (* 39 *) test \"3d4dKd8d5c\" \"4F\"\n  (* 40 *) test \"10h3hQh9h2s\" \"4F\"\n  (* 41 *) test \"Qh5h7h9h6c\" \"4F\"\n  (* 42 *) test \"6s8s7s3sKc\" \"4F\"\n  (* 43 *) test \"10h8h9hJhQh\" \"SF\"\n  (* 44 *) test \"10h9hQhKhJh\" \"SF\"\n  (* 45 *) test \"6d4d7d5d3d\" \"SF\"\n  (* 46 *) test \"6h9h7h5h8h\" \"SF\"\n  (* 47 *) test \"Ac6s4s3s5s\" \"4SF\"\n  (* 48 *) test \"3c9d2c5c4c\" \"4SF\"\n  (* 49 *) test \"Kh2sQh10hJh\" \"4SF\"\n  (* 50 *) test \"4h5h2h3h4s\" \"4SF\"\n  (* 51 *) test \"Js10sAsQsKs\" \"RF\"\n  (* 52 *) test \"10dKdQdAdJd\" \"RF\"\n           0\n\n\n(4/20)\u5f79\u306e\u5224\u5b9a\u3092\u30a2\u30af\u30c6\u30a3\u30d6\u30d1\u30bf\u30fc\u30f3\u306b\u5909\u3048\u305f\u3002\n(4/21)\u6c17\u306b\u5165\u3089\u306a\u3044\u95a2\u6570\u540d\u3092\u5909\u3048\u305f\u3002\nparse\u95a2\u6570\u306f\u524d\u304b\u3089\u30d1\u30fc\u30b9\u305b\u305a\u306b\u5f8c\u308d\u304b\u3089\u30d1\u30fc\u30b9\u3057\u305f\u65b9\u304c\u77ed\u304f\u306a\u3063\u305f\u304b\u3082\u3002\n\n```fsharp:poker.fs\ntype Suit = Spade | Heart | Diamond | Club\ntype Rank = R2 | R3 | R4 | R5 | R6 | R7 | R8 | R9 | R10 | RJ | RQ | RK | RA\ntype Card = Rank * Suit\ntype Hand = Card * Card * Card * Card * Card\n\nlet toList (c0,c1,c2,c3,c4) = [c0;c1;c2;c3;c4]\n\nlet cardToNums (c:Card) =\n  match fst c with\n  | R2  -> [2]\n  | R3  -> [3]\n  | R4  -> [4]\n  | R5  -> [5]\n  | R6  -> [6]\n  | R7  -> [7]\n  | R8  -> [8]\n  | R9  -> [9]\n  | R10 -> [10]\n  | RJ  -> [11]\n  | RQ  -> [12]\n  | RK  -> [13]\n  | RA  -> [1;14]\n\nlet areSameSuit (xs:Card list) =\n  match xs with\n  | []    -> false\n  | c::cs -> List.forall (fun x -> snd x = snd c) cs\n\nlet areSequential (xs:int list) =\n  List.sort xs\n  |> Seq.pairwise\n  |> Seq.forall (fun (x,y) -> x + 1 = y)\n\nlet product (xss:'a list list) =\n  let folder (xs:'a list) (xss:'a list list)=\n    let (>>=) xs f = List.collect f xs\n    xs >>= fun y ->\n      xss >>= fun ys ->\n        [y::ys]\n  List.foldBack folder xss [[]]\n\nlet areSequentialNum (xs:Card list) =\n  List.map cardToNums xs\n  |> product\n  |> List.exists areSequential\n\nlet (|Straight|_|) (h:Hand) =\n  if h |> toList |> areSequentialNum then Some Straight else None\n\nlet (|Flush|_|) (h:Hand) =\n  if h |> toList |> areSameSuit then Some Flush else None\n\nlet (|StraightFlush|_|) (h:Hand) =\n  let l = toList h\n  if areSameSuit l && areSequentialNum l then Some StraightFlush else None\n\nlet (|RoyalFlush|_|) (h:Hand) =\n  let l = toList h\n  let areRoyal = List.map fst >> List.sort >> (=) [R10; RJ; RQ; RK; RA]\n  if areSameSuit l && areRoyal l then Some RoyalFlush else None\n\nlet removeAt i xs =\n  Seq.append (Seq.take i xs) (Seq.skip (i+1) xs)\n  |> Seq.toList\n\nlet removeOne xs =\n  List.map (fun i -> removeAt i xs) [0..(List.length xs - 1)]\n\nlet allExceptOne pred  =\n  toList >> removeOne >> List.exists pred\n\nlet (|FourFlush|_|) (h:Hand) =\n  if allExceptOne areSameSuit h then Some FourFlush else None\n\nlet (|FourStraight|_|) (h:Hand) =\n  if allExceptOne areSequentialNum h then Some FourStraight else None\n\nlet (|FourStraightFlush|_|) (h:Hand) =\n  let areStraightFlush l = areSameSuit l && areSequentialNum l\n  if allExceptOne areStraightFlush h then Some FourStraightFlush else None\n\nlet show (h:Hand) =\n  match h with\n  | RoyalFlush        -> \"RF\"\n  | StraightFlush     -> \"SF\"\n  | Flush             -> \"FL\"\n  | Straight          -> \"ST\"\n  | FourStraightFlush -> \"4SF\"\n  | FourFlush         -> \"4F\"\n  | FourStraight      -> \"4S\"\n  | _                 -> \"-\"\n\nlet parse (s:string) : Hand option =\n  let parseSuit r xs =\n    match xs with\n    | 's' :: ys -> Some ((r,Spade)  ,ys)\n    | 'h' :: ys -> Some ((r,Heart)  ,ys)\n    | 'd' :: ys -> Some ((r,Diamond),ys)\n    | 'c' :: ys -> Some ((r,Club)   ,ys)\n    | _         -> None\n  let parseCard xs =\n    match xs with\n    | '2' :: ys        -> parseSuit R2 ys\n    | '3' :: ys        -> parseSuit R3 ys\n    | '4' :: ys        -> parseSuit R4 ys\n    | '5' :: ys        -> parseSuit R5 ys\n    | '6' :: ys        -> parseSuit R6 ys\n    | '7' :: ys        -> parseSuit R7 ys\n    | '8' :: ys        -> parseSuit R8 ys\n    | '9' :: ys        -> parseSuit R9 ys\n    | '1' :: '0' :: ys -> parseSuit R10 ys\n    | 'J' :: ys        -> parseSuit RJ ys\n    | 'Q' :: ys        -> parseSuit RQ ys\n    | 'K' :: ys        -> parseSuit RK ys\n    | 'A' :: ys        -> parseSuit RA ys\n    | _ -> None\n  let rec parseCards cs xs =\n    match xs with\n    | [] -> cs\n    | _  -> match parseCard xs with\n            | Some (c,ys) -> parseCards (c::cs) ys\n            | None        -> []\n\n  match parseCards [] (Seq.toList s) with\n  | c4::c3::c2::c1::c0::[] -> Some (c0,c1,c2,c3,c4)\n  | _                      -> None\n\n(* for test *)\n\ntype TestResult = Success | Failure\n\nlet test target expected =\n  let areSame expected actual =\n    if expected = actual then Success else Failure\n  let result =\n    match parse target with\n    | Some h -> show h |> areSame expected\n    | None   -> Failure\n  printfn \"%A\" result\n\n[<EntryPoint>]\nlet main args =\n  (*  0 *) test \"Qs9s3dJd10h\" \"4S\"\n  (*  1 *) test \"KdAdJd10dQd\" \"RF\"\n  (*  2 *) test \"QhJhKhAh10h\" \"RF\"\n  (*  3 *) test \"10dAdJsQdKd\" \"ST\"\n  (*  4 *) test \"Kd10dAdJd3d\" \"FL\"\n  (*  5 *) test \"4d3d2dAd5d\" \"SF\"\n  (*  6 *) test \"5d5d2d3dAd\" \"FL\"\n  (*  7 *) test \"4d2sAd5d3d\" \"ST\"\n  (*  8 *) test \"As10dJdQdKd\" \"ST\"\n  (*  9 *) test \"10d10dQdAsJd\" \"4F\"\n  (* 10 *) test \"AcJd10dQdKd\" \"ST\"\n  (* 11 *) test \"Kd2sJdAdQd\" \"4SF\"\n  (* 12 *) test \"JdAdQcKd2s\" \"4S\"\n  (* 13 *) test \"KdAdKdJd2s\" \"4F\"\n  (* 14 *) test \"As2dKdQdJd\" \"4F\"\n  (* 15 *) test \"AsKdQd2dJh\" \"4S\"\n  (* 16 *) test \"QhAd2s3dKd\" \"-\"\n  (* 17 *) test \"Ad4dKh3s2d\" \"4S\"\n  (* 18 *) test \"3d2dAh5d4s\" \"ST\"\n  (* 19 *) test \"QcKdAs2dJd\" \"4S\"\n  (* 20 *) test \"2dQcJdAs10d\" \"-\"\n  (* 21 *) test \"4d7d5s3c2d\" \"4S\"\n  (* 22 *) test \"7d5s4dAd3c\" \"-\"\n  (* 23 *) test \"3s8s10sQs6s\" \"FL\"\n  (* 24 *) test \"6hAh3h2h8h\" \"FL\"\n  (* 25 *) test \"3h4hJh9hQh\" \"FL\"\n  (* 26 *) test \"3s6s5s2sQs\" \"FL\"\n  (* 27 *) test \"9d3cKdQc2c\" \"-\"\n  (* 28 *) test \"5sKs7hQcKh\" \"-\"\n  (* 29 *) test \"Ad6d7h7c9h\" \"-\"\n  (* 30 *) test \"10h4cAh6s10c\" \"-\"\n  (* 31 *) test \"9sKsJcQs10d\" \"ST\"\n  (* 32 *) test \"5d3c2cAs4c\" \"ST\"\n  (* 33 *) test \"KcQs9c10sJs\" \"ST\"\n  (* 34 *) test \"9d8s10hJdQd\" \"ST\"\n  (* 35 *) test \"6c5s10h7d4c\" \"4S\"\n  (* 36 *) test \"QhJcKsAh8c\" \"4S\"\n  (* 37 *) test \"JsQc3h10cKs\" \"4S\"\n  (* 38 *) test \"10c9h7hAd8d\" \"4S\"\n  (* 39 *) test \"3d4dKd8d5c\" \"4F\"\n  (* 40 *) test \"10h3hQh9h2s\" \"4F\"\n  (* 41 *) test \"Qh5h7h9h6c\" \"4F\"\n  (* 42 *) test \"6s8s7s3sKc\" \"4F\"\n  (* 43 *) test \"10h8h9hJhQh\" \"SF\"\n  (* 44 *) test \"10h9hQhKhJh\" \"SF\"\n  (* 45 *) test \"6d4d7d5d3d\" \"SF\"\n  (* 46 *) test \"6h9h7h5h8h\" \"SF\"\n  (* 47 *) test \"Ac6s4s3s5s\" \"4SF\"\n  (* 48 *) test \"3c9d2c5c4c\" \"4SF\"\n  (* 49 *) test \"Kh2sQh10hJh\" \"4SF\"\n  (* 50 *) test \"4h5h2h3h4s\" \"4SF\"\n  (* 51 *) test \"Js10sAsQsKs\" \"RF\"\n  (* 52 *) test \"10dKdQdAdJd\" \"RF\"\n           0\n```", "tags": ["F#", "\u3069\u3046\u66f8\u304f", "yhpg"]}