{"context": "\nMy_Environment\nUbuntu 14.04 LTS Japanese Remix\non VMWare Fusion v8.5.2 (4635224)\non OS X El Captian v10.11.4\n\nGNU bash, version 4.3.11(1)-release\n\ngcc (Ubuntu 4.8.4-2ubuntu1~14.04.3) 4.8.4 \n(also for g++)\nADDA v.1.3b6\n\n\nThis article is related to ADDA (light scattering simulator based on the discrete dipole approximation).\nRelated: http://qiita.com/7of9/items/9537252c79f5318d8f55\nRelated: http://qiita.com/7of9/items/4966f131d405cd89ee07\n\nv0.1\nWork in progress.\n\nread_chpoint.c\n#include <stdio.h>\n#include <stdlib.h>\n\n/*\nv0.1 Nov. 30, 2016\n    - add read_chpoint_file();\n*/\n\nstatic void read_chpoint_file(char *filename)\n{\n    int ind_m;\n    size_t local_nRows;\n    FILE *rdfp;\n\n    rdfp = fopen(filename, \"rb\");\n    if (rdfp == NULL) {\n        printf(\"ERROR: file is not found\\r\\n\");\n        return;\n    }\n    fread(&ind_m,sizeof(int),1,rdfp);\n    fread(&local_nRows, sizeof(size_t), 1, rdfp);\n    fclose(rdfp);\n\n    printf(\"ind_m:%d\\r\\n\", ind_m);\n    printf(\"local_nRows:%zu\\r\\n\", local_nRows);\n}\n\nint main(int argc, char *argv[])\n{\n//  printf(\"argc=%d\\n\", argc);\n    char *filename;\n\n    if (argc < 2) {\n        printf(\"ERROR: chpoint file is not specified\\r\\n\");\n        printf(\"   [cmd] [chpoint file]\\r\\n\");\n        exit(1);\n    }\n\n    read_chpoint_file(argv[1]);\n}\n\n\n\nrun\n$ gcc read_chpoint.c\n$ ./a.out  LN-CHP \nind_m:5\nlocal_nRows:27984\n\n\n\nv0.3\n\nread_chpoint.c\n#include <stdio.h>\n#include <stdlib.h>\n\n/*\nv0.3 Dec. 14, 2016\n    - read [sc_N],[sc_size],[vec_N],[vec_size]\n    - add [auxiliary] file read option\nv0.2 Dec. 14, 2016\n    - read [niter],[counter],[inprodR],[prev_err],[resid_scale]\nv0.1 Nov. 30, 2016\n    - add read_chpoint_file();\n*/\n\nstatic void read_chpoint_file(char *chpFilename, char *auxFilename)\n{\n    int ind_m; // index of iterative method\n    size_t local_nRows; // number of local rows of decomposition (only real dipoles)\n    int niter; // iteration count\n    int counter; // number of successive iterations without residual decrease\n    double inprodR; // used as |r_0|^2 and best squared norm of residual up to some iteration\n    double prev_err; // previous relative error; used in ProgressReport, initialized in IterativeSolver\n    double resid_scale; // scale to get square of relative error\n    //\n    #define MAX_SIZE (20) // 20: arbitrary\n    int sc_N; // \n    int sc_size[MAX_SIZE]; //\n    int vec_N; // \n    int vec_size[MAX_SIZE]; // \n    //\n    FILE *chpfp; // checkpoint file\n    FILE *auxfp; // auxiliary file\n    // \n    int idx; // for loop\n\n    chpfp = fopen(chpFilename, \"r\");\n    if (chpfp == NULL) {\n        printf(\"ERROR: checkpoint file is not found\\r\\n\");\n        return;\n    }\n    auxfp = fopen(auxFilename, \"r\");\n    if (auxfp == NULL) {\n        printf(\"ERROR: auxiliary file is not found\\r\\n\");\n        return;\n    }\n\n    fread(&ind_m,sizeof(int),1,chpfp);\n    fread(&local_nRows, sizeof(size_t), 1, chpfp);\n    fread(&niter,sizeof(int),1,chpfp);\n    fread(&counter,sizeof(int),1,chpfp);\n    fread(&inprodR,sizeof(double),1,chpfp);\n    fread(&prev_err,sizeof(double),1,chpfp);\n    fread(&resid_scale,sizeof(double),1,chpfp);\n    //\n    fread(&sc_N, sizeof(int), 1, auxfp);\n    fread(&sc_size[0], sizeof(int), sc_N, auxfp);\n    fread(&vec_N, sizeof(int), 1, auxfp);\n    fread(&vec_size[0], sizeof(int), vec_N, auxfp);\n    //\n    fclose(chpfp);\n    fclose(auxfp);\n\n    printf(\"ind_m:%d\\r\\n\", ind_m);\n    printf(\"local_nRows:%zu\\r\\n\", local_nRows);\n    printf(\"niter:%d\\r\\n\", niter);\n    printf(\"counter:%d\\r\\n\", counter);\n    printf(\"inprodR:%.3f\\r\\n\", inprodR);\n    printf(\"prev_err:%.3f\\r\\n\", prev_err);\n    printf(\"resid_scale:%.3f\\r\\n\", resid_scale);\n    //\n    printf(\"sc_N:%d\\r\\n\", sc_N);\n    for(idx=0; idx<sc_N; idx++) {\n        printf(\"sc_size[]:%d\\r\\n\", sc_size[idx]);\n    }\n    printf(\"vec_N:%d\\r\\n\", vec_N);\n    for(idx=0; idx<vec_N; idx++) {\n        printf(\"vec_size[]:%d\\r\\n\", vec_size[idx]);\n    }   \n}\n\nint main(int argc, char *argv[])\n{\n//  printf(\"argc=%d\\n\", argc);\n    char *filename;\n\n    if (argc < 3) {\n        printf(\"ERROR: chpoint file is not specified\\r\\n\");\n        printf(\"   [cmd] [chpoint file] [auxiliary file]\\r\\n\");\n        exit(1);\n    }\n\n    read_chpoint_file(/*chpFilename=*/argv[1], /*auxFilename=*/argv[2]);\n}\n\n\n\nrun\n$ ln -fs seq/chpoint/chp.0 LN-CHP\n$ ln -fs seq/chpoint/aux.0 LN-AUX\n\n$ gcc read_chpoint.c\n\n$ ./a.out  LN-CHP LN-AUX\nind_m:5\nlocal_nRows:27984\nniter:187\ncounter:117\ninprodR:4.317\nprev_err:0.321\nresid_scale:0.020\nsc_N:8\nsc_size[]:8\nsc_size[]:8\nsc_size[]:8\nsc_size[]:8\nsc_size[]:16\nsc_size[]:16\nsc_size[]:16\nsc_size[]:16\nvec_N:3\nvec_size[]:16\nvec_size[]:16\nvec_size[]:16\n\n\nwhere, the size 8 means [double] type while the 16 means [double complex] type based on the ADDA source code.\n\nv0.4\n\nread_chpoint.c\n#include <stdio.h>\n#include <stdlib.h>\n#include <complex.h>\n\n/*\nv0.4 Dec. 17, 2016\n    - read vectors[]\n    - read [xvec],[rvec],[pvec]\n    - read scalars[]\nv0.3 Dec. 14, 2016\n    - read [sc_N],[sc_sizes],[vec_N],[vec_sizes]\n    - add [auxiliary] file read option\nv0.2 Dec. 14, 2016\n    - read [niter],[counter],[inprodR],[prev_err],[resid_scale]\nv0.1 Nov. 30, 2016\n    - add read_chpoint_file();\n*/\n\n#define SIZE_DOUBLE (8)\n#define SIZE_DCOMPLEX (16)\n\nstatic void read_chpoint_file(char *chpFilename, char *auxFilename)\n{\n    int ind_m; // index of iterative method\n    size_t local_nRows; // number of local rows of decomposition (only real dipoles)\n    int niter; // iteration count\n    int counter; // number of successive iterations without residual decrease\n    double inprodR; // used as |r_0|^2 and best squared norm of residual up to some iteration\n    double prev_err; // previous relative error; used in ProgressReport, initialized in IterativeSolver\n    double resid_scale; // scale to get square of relative error\n    //\n    #define MAXNUM_SIZEINFO (20) // 20: arbitrary\n    int sc_N; // the number of scalars' sizes\n    int sc_sizes[MAXNUM_SIZEINFO]; // scalars' sizes\n    int vec_N; // the number of vercotrs' sizes\n    int vec_sizes[MAXNUM_SIZEINFO]; // vectors' sizes\n    //\n    #define MAXNUM_SCALARS (20) // 20: arbitrary\n    double complex scalars[MAXNUM_SCALARS];\n    //\n    #define MAXNUM_XRP_VECTORS (30000) // 30000: arbitrary\n    double complex xvec[MAXNUM_XRP_VECTORS]; // total electric field on the dipoles\n    double complex rvec[MAXNUM_XRP_VECTORS]; // current residual\n    double complex pvec[MAXNUM_XRP_VECTORS]; // polarization of dipoles, also an auxiliary vector in iterative solvers\n    #define MAXNUM_VECTORS (20) // 20: arbitrary\n    double complex vectors[MAXNUM_VECTORS][MAXNUM_XRP_VECTORS];\n    //\n    FILE *chpfp; // checkpoint file\n    FILE *auxfp; // auxiliary file\n    // \n    int idx; // for loop (for C89)\n\n    // 1. read from files\n    chpfp = fopen(chpFilename, \"r\");\n    if (chpfp == NULL) {\n        printf(\"ERROR: checkpoint file is not found\\r\\n\");\n        return;\n    }\n    auxfp = fopen(auxFilename, \"r\");\n    if (auxfp == NULL) {\n        printf(\"ERROR: auxiliary file is not found\\r\\n\");\n        return;\n    }\n\n    fread(&ind_m,sizeof(int),1,chpfp);\n    fread(&local_nRows, sizeof(size_t), 1, chpfp);\n    fread(&niter,sizeof(int),1,chpfp);\n    fread(&counter,sizeof(int),1,chpfp);\n    fread(&inprodR,sizeof(double),1,chpfp);\n    fread(&prev_err,sizeof(double),1,chpfp);\n    fread(&resid_scale,sizeof(double),1,chpfp);\n    //\n    fread(&sc_N, sizeof(int), 1, auxfp);\n    fread(&sc_sizes[0], sizeof(int), sc_N, auxfp);\n    fread(&vec_N, sizeof(int), 1, auxfp);\n    fread(&vec_sizes[0], sizeof(int), vec_N, auxfp);\n    for(idx=0; idx<sc_N; idx++) {\n        fread(&(scalars[idx]), sc_sizes[idx], 1, chpfp);\n    }\n    fread(xvec,sizeof(double complex),local_nRows,chpfp);\n    fread(rvec,sizeof(double complex),local_nRows,chpfp);\n    fread(pvec,sizeof(double complex),local_nRows,chpfp);\n    for(idx=0; idx<vec_N; idx++) {\n        fread(&(vectors[idx][0]), vec_sizes[idx], local_nRows, chpfp);\n    }    \n    //\n    fclose(chpfp);\n    fclose(auxfp);\n\n    // 2. debug print\n    printf(\"ind_m:%d\\n\", ind_m);\n    printf(\"local_nRows:%zu\\n\", local_nRows);\n    printf(\"niter:%d\\n\", niter);\n    printf(\"counter:%d\\n\", counter);\n    printf(\"inprodR:%.3f\\n\", inprodR);\n    printf(\"prev_err:%.3f\\n\", prev_err);\n    printf(\"resid_scale:%.3f\\n\", resid_scale);\n    //\n    printf(\"sc_N:%d\\n\", sc_N);\n    for(idx=0; idx<sc_N; idx++) {\n        printf(\"sc_sizes[]:%d\\n\", sc_sizes[idx]);\n    }\n    printf(\"vec_N:%d\\n\", vec_N);\n    for(idx=0; idx<vec_N; idx++) {\n        printf(\"vec_sizes[]:%d\\n\", vec_sizes[idx]);\n    }   \n\n    for(idx=0; idx<sc_N; idx++) {\n        // debug print\n        if (sc_sizes[idx] == SIZE_DCOMPLEX) {\n            printf( \"scalars:(%f,%f)\\n\", creal(scalars[idx]), cimag(scalars[idx]) );\n        } else if (sc_sizes[idx] == SIZE_DOUBLE) {\n            printf( \"scalars:%f\\n\", creal(scalars[idx]) );\n        } else {\n            printf( \"scalars: in other type\\n\" );\n        }\n    }\n\n    for(idx=0; idx<5; idx++) { // only first 5 among 30000\n        printf( \"xvec:(%f,%f), rvec:(%f,%f), pvec:(%f,%f)\\n\", \n            creal(xvec[idx]), cimag(xvec[idx]),\n            creal(rvec[idx]), cimag(rvec[idx]),\n            creal(pvec[idx]), cimag(pvec[idx])\n        );\n    }\n\n    for(idx=0; idx<vec_N; idx++) { // only first 3 among local_nRows\n        printf( \"vectors 1:(%f,%f), 2:(%f,%f), 3:(%f,%f)\\n\",\n            creal(vectors[idx][0]), cimag(vectors[idx][0]),\n            creal(vectors[idx][1]), cimag(vectors[idx][1]),\n            creal(vectors[idx][2]), cimag(vectors[idx][2])\n        );\n    }\n}\n\nint main(int argc, char *argv[])\n{\n//  printf(\"argc=%d\\n\", argc);\n    char *filename;\n\n    if (argc < 3) {\n        printf(\"ERROR: chpoint file is not specified\\r\\n\");\n        printf(\"   [cmd] [chpoint file] [auxiliary file]\\r\\n\");\n        exit(1);\n    }\n\n    read_chpoint_file(/*chpFilename=*/argv[1], /*auxFilename=*/argv[2]);\n}\n\n\n\nsetting(to_avoid_core_dump)\n$ ulimit -s unlimited\n\n\n$ ln -fs seq/chpoint/chp.0 LN-CHP\n$ ln -fs seq/chpoint/aux.0 LN-AUX\n\nwhere aux.0 is created using \nhttp://qiita.com/7of9/items/4e5b299ad405819af5f0\n\nrun\n$ gcc read_chpoint.c && ./a.out LN-CHP LN-AUX \nind_m:5\nlocal_nRows:27984\nniter:230\ncounter:160\ninprodR:4.317\nprev_err:0.316\nresid_scale:0.020\nsc_N:8\nsc_sizes[]:8\nsc_sizes[]:8\nsc_sizes[]:8\nsc_sizes[]:8\nsc_sizes[]:16\nsc_sizes[]:16\nsc_sizes[]:16\nsc_sizes[]:16\nvec_N:3\nvec_sizes[]:16\nvec_sizes[]:16\nvec_sizes[]:16\nscalars:7.159807\nscalars:12.236596\nscalars:0.052110\nscalars:0.038853\nscalars:(2.581055,2.848436)\nscalars:(-0.281006,0.239659)\nscalars:(-0.800018,-0.597709)\nscalars:(0.966484,-0.253771)\nxvec:(0.000856,-0.000519), rvec:(-0.001961,0.001694), pvec:(-0.005346,0.005240)\nxvec:(0.034051,0.088220), rvec:(0.004734,-0.019609), pvec:(0.021339,-0.016807)\nxvec:(-0.004780,-0.003816), rvec:(0.005126,-0.004015), pvec:(0.015493,-0.013204)\nxvec:(-0.000856,0.000519), rvec:(0.001961,-0.001694), pvec:(0.005346,-0.005240)\nxvec:(0.034051,0.088220), rvec:(0.004734,-0.019609), pvec:(0.021339,-0.016807)\nvectors 1:(-0.001543,-0.012333), 2:(0.076928,-0.018896), 3:(0.042558,0.058127)\nvectors 1:(-0.085713,0.030229), 2:(0.307545,-0.248557), 3:(0.244432,-0.029081)\nvectors 1:(-0.000710,0.000439), 2:(-0.005362,0.000514), 3:(0.003159,-0.007757)\n\n\n```txt:My_Environment\nUbuntu 14.04 LTS Japanese Remix\non VMWare Fusion v8.5.2 (4635224)\non OS X El Captian v10.11.4\n\nGNU bash, version 4.3.11(1)-release\n\ngcc (Ubuntu 4.8.4-2ubuntu1~14.04.3) 4.8.4 \n(also for g++)\nADDA v.1.3b6\n```\n\nThis article is related to [ADDA (light scattering simulator based on the discrete dipole approximation)](https://github.com/adda-team/adda/).\n\nRelated: http://qiita.com/7of9/items/9537252c79f5318d8f55\nRelated: http://qiita.com/7of9/items/4966f131d405cd89ee07\n\n### v0.1\n\nWork in progress.\n\n```read_chpoint.c\n#include <stdio.h>\n#include <stdlib.h>\n\n/*\nv0.1 Nov. 30, 2016\n\t- add read_chpoint_file();\n*/\n\nstatic void read_chpoint_file(char *filename)\n{\n\tint ind_m;\n\tsize_t local_nRows;\n\tFILE *rdfp;\n\n\trdfp = fopen(filename, \"rb\");\n\tif (rdfp == NULL) {\n\t\tprintf(\"ERROR: file is not found\\r\\n\");\n\t\treturn;\n\t}\n\tfread(&ind_m,sizeof(int),1,rdfp);\n\tfread(&local_nRows, sizeof(size_t), 1, rdfp);\n\tfclose(rdfp);\n\n\tprintf(\"ind_m:%d\\r\\n\", ind_m);\n\tprintf(\"local_nRows:%zu\\r\\n\", local_nRows);\n}\n\nint main(int argc, char *argv[])\n{\n//\tprintf(\"argc=%d\\n\", argc);\n\tchar *filename;\n\n\tif (argc < 2) {\n\t\tprintf(\"ERROR: chpoint file is not specified\\r\\n\");\n\t\tprintf(\"   [cmd] [chpoint file]\\r\\n\");\n\t\texit(1);\n\t}\n\n\tread_chpoint_file(argv[1]);\n}\n```\n\n```txt:run\n$ gcc read_chpoint.c\n$ ./a.out  LN-CHP \nind_m:5\nlocal_nRows:27984\n```\n\n### v0.3\n\n```read_chpoint.c\n#include <stdio.h>\n#include <stdlib.h>\n\n/*\nv0.3 Dec. 14, 2016\n    - read [sc_N],[sc_size],[vec_N],[vec_size]\n    - add [auxiliary] file read option\nv0.2 Dec. 14, 2016\n    - read [niter],[counter],[inprodR],[prev_err],[resid_scale]\nv0.1 Nov. 30, 2016\n    - add read_chpoint_file();\n*/\n\nstatic void read_chpoint_file(char *chpFilename, char *auxFilename)\n{\n    int ind_m; // index of iterative method\n    size_t local_nRows; // number of local rows of decomposition (only real dipoles)\n    int niter; // iteration count\n    int counter; // number of successive iterations without residual decrease\n    double inprodR; // used as |r_0|^2 and best squared norm of residual up to some iteration\n    double prev_err; // previous relative error; used in ProgressReport, initialized in IterativeSolver\n    double resid_scale; // scale to get square of relative error\n    //\n    #define MAX_SIZE (20) // 20: arbitrary\n    int sc_N; // \n    int sc_size[MAX_SIZE]; //\n    int vec_N; // \n    int vec_size[MAX_SIZE]; // \n    //\n    FILE *chpfp; // checkpoint file\n    FILE *auxfp; // auxiliary file\n    // \n    int idx; // for loop\n\n    chpfp = fopen(chpFilename, \"r\");\n    if (chpfp == NULL) {\n        printf(\"ERROR: checkpoint file is not found\\r\\n\");\n        return;\n    }\n    auxfp = fopen(auxFilename, \"r\");\n    if (auxfp == NULL) {\n        printf(\"ERROR: auxiliary file is not found\\r\\n\");\n        return;\n    }\n\n    fread(&ind_m,sizeof(int),1,chpfp);\n    fread(&local_nRows, sizeof(size_t), 1, chpfp);\n    fread(&niter,sizeof(int),1,chpfp);\n    fread(&counter,sizeof(int),1,chpfp);\n    fread(&inprodR,sizeof(double),1,chpfp);\n    fread(&prev_err,sizeof(double),1,chpfp);\n    fread(&resid_scale,sizeof(double),1,chpfp);\n    //\n    fread(&sc_N, sizeof(int), 1, auxfp);\n    fread(&sc_size[0], sizeof(int), sc_N, auxfp);\n    fread(&vec_N, sizeof(int), 1, auxfp);\n    fread(&vec_size[0], sizeof(int), vec_N, auxfp);\n    //\n    fclose(chpfp);\n    fclose(auxfp);\n\n    printf(\"ind_m:%d\\r\\n\", ind_m);\n    printf(\"local_nRows:%zu\\r\\n\", local_nRows);\n    printf(\"niter:%d\\r\\n\", niter);\n    printf(\"counter:%d\\r\\n\", counter);\n    printf(\"inprodR:%.3f\\r\\n\", inprodR);\n    printf(\"prev_err:%.3f\\r\\n\", prev_err);\n    printf(\"resid_scale:%.3f\\r\\n\", resid_scale);\n    //\n    printf(\"sc_N:%d\\r\\n\", sc_N);\n    for(idx=0; idx<sc_N; idx++) {\n        printf(\"sc_size[]:%d\\r\\n\", sc_size[idx]);\n    }\n    printf(\"vec_N:%d\\r\\n\", vec_N);\n    for(idx=0; idx<vec_N; idx++) {\n        printf(\"vec_size[]:%d\\r\\n\", vec_size[idx]);\n    }   \n}\n\nint main(int argc, char *argv[])\n{\n//  printf(\"argc=%d\\n\", argc);\n    char *filename;\n\n    if (argc < 3) {\n        printf(\"ERROR: chpoint file is not specified\\r\\n\");\n        printf(\"   [cmd] [chpoint file] [auxiliary file]\\r\\n\");\n        exit(1);\n    }\n\n    read_chpoint_file(/*chpFilename=*/argv[1], /*auxFilename=*/argv[2]);\n}\n```\n\n```txt:run\n$ ln -fs seq/chpoint/chp.0 LN-CHP\n$ ln -fs seq/chpoint/aux.0 LN-AUX\n\n$ gcc read_chpoint.c\n\n$ ./a.out  LN-CHP LN-AUX\nind_m:5\nlocal_nRows:27984\nniter:187\ncounter:117\ninprodR:4.317\nprev_err:0.321\nresid_scale:0.020\nsc_N:8\nsc_size[]:8\nsc_size[]:8\nsc_size[]:8\nsc_size[]:8\nsc_size[]:16\nsc_size[]:16\nsc_size[]:16\nsc_size[]:16\nvec_N:3\nvec_size[]:16\nvec_size[]:16\nvec_size[]:16\n```\n\nwhere, the size 8 means [double] type while the 16 means [double complex] type based on the ADDA source code.\n\n### v0.4\n\n```read_chpoint.c\n#include <stdio.h>\n#include <stdlib.h>\n#include <complex.h>\n\n/*\nv0.4 Dec. 17, 2016\n    - read vectors[]\n    - read [xvec],[rvec],[pvec]\n    - read scalars[]\nv0.3 Dec. 14, 2016\n    - read [sc_N],[sc_sizes],[vec_N],[vec_sizes]\n    - add [auxiliary] file read option\nv0.2 Dec. 14, 2016\n    - read [niter],[counter],[inprodR],[prev_err],[resid_scale]\nv0.1 Nov. 30, 2016\n    - add read_chpoint_file();\n*/\n\n#define SIZE_DOUBLE (8)\n#define SIZE_DCOMPLEX (16)\n\nstatic void read_chpoint_file(char *chpFilename, char *auxFilename)\n{\n    int ind_m; // index of iterative method\n    size_t local_nRows; // number of local rows of decomposition (only real dipoles)\n    int niter; // iteration count\n    int counter; // number of successive iterations without residual decrease\n    double inprodR; // used as |r_0|^2 and best squared norm of residual up to some iteration\n    double prev_err; // previous relative error; used in ProgressReport, initialized in IterativeSolver\n    double resid_scale; // scale to get square of relative error\n    //\n    #define MAXNUM_SIZEINFO (20) // 20: arbitrary\n    int sc_N; // the number of scalars' sizes\n    int sc_sizes[MAXNUM_SIZEINFO]; // scalars' sizes\n    int vec_N; // the number of vercotrs' sizes\n    int vec_sizes[MAXNUM_SIZEINFO]; // vectors' sizes\n    //\n    #define MAXNUM_SCALARS (20) // 20: arbitrary\n    double complex scalars[MAXNUM_SCALARS];\n    //\n    #define MAXNUM_XRP_VECTORS (30000) // 30000: arbitrary\n    double complex xvec[MAXNUM_XRP_VECTORS]; // total electric field on the dipoles\n    double complex rvec[MAXNUM_XRP_VECTORS]; // current residual\n    double complex pvec[MAXNUM_XRP_VECTORS]; // polarization of dipoles, also an auxiliary vector in iterative solvers\n    #define MAXNUM_VECTORS (20) // 20: arbitrary\n    double complex vectors[MAXNUM_VECTORS][MAXNUM_XRP_VECTORS];\n    //\n    FILE *chpfp; // checkpoint file\n    FILE *auxfp; // auxiliary file\n    // \n    int idx; // for loop (for C89)\n\n    // 1. read from files\n    chpfp = fopen(chpFilename, \"r\");\n    if (chpfp == NULL) {\n        printf(\"ERROR: checkpoint file is not found\\r\\n\");\n        return;\n    }\n    auxfp = fopen(auxFilename, \"r\");\n    if (auxfp == NULL) {\n        printf(\"ERROR: auxiliary file is not found\\r\\n\");\n        return;\n    }\n\n    fread(&ind_m,sizeof(int),1,chpfp);\n    fread(&local_nRows, sizeof(size_t), 1, chpfp);\n    fread(&niter,sizeof(int),1,chpfp);\n    fread(&counter,sizeof(int),1,chpfp);\n    fread(&inprodR,sizeof(double),1,chpfp);\n    fread(&prev_err,sizeof(double),1,chpfp);\n    fread(&resid_scale,sizeof(double),1,chpfp);\n    //\n    fread(&sc_N, sizeof(int), 1, auxfp);\n    fread(&sc_sizes[0], sizeof(int), sc_N, auxfp);\n    fread(&vec_N, sizeof(int), 1, auxfp);\n    fread(&vec_sizes[0], sizeof(int), vec_N, auxfp);\n    for(idx=0; idx<sc_N; idx++) {\n        fread(&(scalars[idx]), sc_sizes[idx], 1, chpfp);\n    }\n    fread(xvec,sizeof(double complex),local_nRows,chpfp);\n    fread(rvec,sizeof(double complex),local_nRows,chpfp);\n    fread(pvec,sizeof(double complex),local_nRows,chpfp);\n    for(idx=0; idx<vec_N; idx++) {\n        fread(&(vectors[idx][0]), vec_sizes[idx], local_nRows, chpfp);\n    }    \n    //\n    fclose(chpfp);\n    fclose(auxfp);\n\n    // 2. debug print\n    printf(\"ind_m:%d\\n\", ind_m);\n    printf(\"local_nRows:%zu\\n\", local_nRows);\n    printf(\"niter:%d\\n\", niter);\n    printf(\"counter:%d\\n\", counter);\n    printf(\"inprodR:%.3f\\n\", inprodR);\n    printf(\"prev_err:%.3f\\n\", prev_err);\n    printf(\"resid_scale:%.3f\\n\", resid_scale);\n    //\n    printf(\"sc_N:%d\\n\", sc_N);\n    for(idx=0; idx<sc_N; idx++) {\n        printf(\"sc_sizes[]:%d\\n\", sc_sizes[idx]);\n    }\n    printf(\"vec_N:%d\\n\", vec_N);\n    for(idx=0; idx<vec_N; idx++) {\n        printf(\"vec_sizes[]:%d\\n\", vec_sizes[idx]);\n    }   \n\n    for(idx=0; idx<sc_N; idx++) {\n        // debug print\n        if (sc_sizes[idx] == SIZE_DCOMPLEX) {\n            printf( \"scalars:(%f,%f)\\n\", creal(scalars[idx]), cimag(scalars[idx]) );\n        } else if (sc_sizes[idx] == SIZE_DOUBLE) {\n            printf( \"scalars:%f\\n\", creal(scalars[idx]) );\n        } else {\n            printf( \"scalars: in other type\\n\" );\n        }\n    }\n\n    for(idx=0; idx<5; idx++) { // only first 5 among 30000\n        printf( \"xvec:(%f,%f), rvec:(%f,%f), pvec:(%f,%f)\\n\", \n            creal(xvec[idx]), cimag(xvec[idx]),\n            creal(rvec[idx]), cimag(rvec[idx]),\n            creal(pvec[idx]), cimag(pvec[idx])\n        );\n    }\n\n    for(idx=0; idx<vec_N; idx++) { // only first 3 among local_nRows\n        printf( \"vectors 1:(%f,%f), 2:(%f,%f), 3:(%f,%f)\\n\",\n            creal(vectors[idx][0]), cimag(vectors[idx][0]),\n            creal(vectors[idx][1]), cimag(vectors[idx][1]),\n            creal(vectors[idx][2]), cimag(vectors[idx][2])\n        );\n    }\n}\n\nint main(int argc, char *argv[])\n{\n//  printf(\"argc=%d\\n\", argc);\n    char *filename;\n\n    if (argc < 3) {\n        printf(\"ERROR: chpoint file is not specified\\r\\n\");\n        printf(\"   [cmd] [chpoint file] [auxiliary file]\\r\\n\");\n        exit(1);\n    }\n\n    read_chpoint_file(/*chpFilename=*/argv[1], /*auxFilename=*/argv[2]);\n}\n```\n\n```txt:setting(to_avoid_core_dump)\n$ ulimit -s unlimited\n```\n\n```\n$ ln -fs seq/chpoint/chp.0 LN-CHP\n$ ln -fs seq/chpoint/aux.0 LN-AUX\n```\nwhere `aux.0` is created using \nhttp://qiita.com/7of9/items/4e5b299ad405819af5f0\n\n```txt:run\n$ gcc read_chpoint.c && ./a.out LN-CHP LN-AUX \nind_m:5\nlocal_nRows:27984\nniter:230\ncounter:160\ninprodR:4.317\nprev_err:0.316\nresid_scale:0.020\nsc_N:8\nsc_sizes[]:8\nsc_sizes[]:8\nsc_sizes[]:8\nsc_sizes[]:8\nsc_sizes[]:16\nsc_sizes[]:16\nsc_sizes[]:16\nsc_sizes[]:16\nvec_N:3\nvec_sizes[]:16\nvec_sizes[]:16\nvec_sizes[]:16\nscalars:7.159807\nscalars:12.236596\nscalars:0.052110\nscalars:0.038853\nscalars:(2.581055,2.848436)\nscalars:(-0.281006,0.239659)\nscalars:(-0.800018,-0.597709)\nscalars:(0.966484,-0.253771)\nxvec:(0.000856,-0.000519), rvec:(-0.001961,0.001694), pvec:(-0.005346,0.005240)\nxvec:(0.034051,0.088220), rvec:(0.004734,-0.019609), pvec:(0.021339,-0.016807)\nxvec:(-0.004780,-0.003816), rvec:(0.005126,-0.004015), pvec:(0.015493,-0.013204)\nxvec:(-0.000856,0.000519), rvec:(0.001961,-0.001694), pvec:(0.005346,-0.005240)\nxvec:(0.034051,0.088220), rvec:(0.004734,-0.019609), pvec:(0.021339,-0.016807)\nvectors 1:(-0.001543,-0.012333), 2:(0.076928,-0.018896), 3:(0.042558,0.058127)\nvectors 1:(-0.085713,0.030229), 2:(0.307545,-0.248557), 3:(0.244432,-0.029081)\nvectors 1:(-0.000710,0.000439), 2:(-0.005362,0.000514), 3:(0.003159,-0.007757)\n```\n\n\n\n\n", "tags": ["ADDA", "tool"]}