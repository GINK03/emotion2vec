{"tags": ["Haskell", "\u30ac\u30e9\u30af\u30bf", "\u60c5\u5f31"], "context": " More than 1 year has passed since last update.IArray\u306b\u4e00\u756a\u5411\u3044\u3066\u306a\u3044\u914d\u5217\u5168\u4f53\u306e\u66f4\u65b0\u3092\u3084\u3063\u3066\u307f\u308b\u3068\u3069\u3046\u306a\u308b\u306e\u304b\u3068\u601d\u3063\u3066\u3001\u30e9\u30a4\u30d5\u30fb\u30b2\u30fc\u30e0\u3092IArray\u3067\u66f8\u3044\u3066\u307f\u305f\u3002\u5f53\u305f\u308a\u524d\u3060\u304c\u4e88\u60f3\u901a\u308a\u3068\u3066\u3082\u9045\u3044\u3002immutable\u306a\u914d\u5217\u3063\u3066\u3084\u3063\u3071\u308a\u3053\u3046\u3044\u3046\u3082\u3093\u3060\u3088\u306a\u3002\u5b9f\u969b\u306e\u3068\u3053\u308d\u3001IOArray\u3068\u304b\u4f7f\u3063\u3066\u3082IO \u30e2\u30ca\u30c9\u306e\u4e2d\u3067\u64cd\u4f5c\u3059\u308b\u306e\u3068\u30b3\u30fc\u30c9\u306e\u898b\u305f\u76ee\u304c\u3084\u305f\u3089\u3068\u30b4\u30c1\u30e3\u30b4\u30c1\u30e3\u3059\u308b\u306e\u3092\u9664\u3051\u3070\u624b\u9593\u306f\u307b\u307c\u5909\u308f\u3089\u306a\u3044\u306e\u3067\u3001\u3053\u306e\u7a2e\u306e\u3082\u306e\u3092\u66f8\u304f\u3068\u304d\u306bIArray\u3092\u4f7f\u3046\u7406\u7531\u306f\u5168\u7136\u306a\u3044\u3053\u3068\u304c\u308f\u304b\u3063\u305f\u3002\u5f8c\u3067\u6687\u306a\u6642\u306bRepa\u3068\u304bData.Vector.Mutable\u3068\u304b\u4f7f\u3063\u3066\u66f8\u304d\u63db\u3048\u3066\u307f\u3088\u3046\u3068\u601d\u3063\u3066\u3044\u308b\u3002\n\u8ffd\u8a18\uff1a\u6d41\u77f3\u306b\u624b\u629c\u304d\u904e\u304e\u308b\u3068\u601d\u3063\u305f\u306e\u3067\u3001\u3082\u3046\u5c11\u3057\u30de\u30c8\u30e2\u306b\u3057\u3088\u3046\u3068\u8a66\u3057\u306bNCurses\u3092\u4f7f\u3063\u3066\u307f\u305f\n\uff08\u4e00\u5fdc\u3001NCurses\u3092\u4f7f\u308f\u306a\u3044\u3067\u3082\u3044\u3044\u5143\u3005\u306e\u30f4\u30a1\u30fc\u30b8\u30e7\u30f3\u3082\u4e0b\u306e\u65b9\u306b\u3042\u308b\uff09\u3002\u30d5\u30a3\u30fc\u30eb\u30c9\u306e\u5927\u304d\u3055\u306f\u30bf\u30fc\u30df\u30ca\u30eb\u5168\u753b\u9762\u306a\u306e\u3067\u9069\u5b9c\u30bf\u30fc\u30df\u30ca\u30eb\u306e\u30a6\u30a3\u30f3\u30c9\u30a6\u30b5\u30a4\u30ba\u3092\u5909\u66f4\u306e\u3053\u3068\u3002\u30b3\u30de\u30f3\u30c9\u30e9\u30a4\u30f3\u5f15\u6570\u306f\u30b9\u30ea\u30fc\u30d7\u9593\u9694\uff08\u30df\u30ea\u79d2\uff09\u3002\u5b9f\u884c\u4e2d\u306bENTER\u30ad\u30fc\u62bc\u4e0b\u3067\u7d42\u4e86\u3002\n\u518d\u8ffd\u8a18\uff1a\u914d\u5217\u306e\u4e2d\u8eab\u3092\u5168\u9762\u7684\u306b\u66f4\u65b0\u3059\u308b\u306e\u3067\u3054\u5229\u76ca\u304c\u306a\u3044\u3060\u308d\u3046\u3068\u601d\u3063\u3066\u3044\u305f\u304c\u3001UArray\u304b\u3089DiffUArray\u306b\u3057\u3066\u307f\u305f\u3089\u3001\u305d\u308c\u306a\u308a\u306b\u6539\u5584\u3055\u308c\u305f\uff08\u3082\u3061\u308d\u3093\u672c\u8cea\u7684\u306b\u306f\u9045\u3044\u307e\u307e\u3060\u3051\u3069\uff09\u3002IArray\u30af\u30e9\u30b9\u304c\u63d0\u4f9b\u3059\u308b\u30a4\u30f3\u30bf\u30fc\u30d5\u30a7\u30fc\u30b9\u306f\u5171\u901a\u306a\u306e\u3067\u3001\u5192\u982d\u306etype\u5ba3\u8a00\u306e\u3068\u3053\u308d\u306b\u6570\u6587\u5b57\u66f8\u304d\u52a0\u3048\u308b\u3060\u3051\u3060\u3002\u3068\u3044\u3046\u3053\u3068\u3067\u3001\u307e\u3059\u307e\u3059\u7d20\u306e(U)Array\u3092\u4f7f\u3046\u7406\u7531\u304c\u306a\u3044\u306a\u3042\u3002\n./LifeGame 500\n\n\u3053\u3093\u306a\u611f\u3058\u3002\n\nLifeGame_IArray_NCurses.hs\nmodule Main where\n\nimport Control.Monad (mapM_,forM_,sequence_,replicateM)\nimport Control.Monad.IO.Class (liftIO)\nimport Control.Concurrent (killThread, myThreadId)\nimport System.Random (getStdRandom,random)\nimport System.Environment (getArgs)\nimport UI.NCurses\nimport Data.Array.Diff\n\ntype Field = DiffUArray (Int,Int) Bool \ntype Counts = DiffUArray (Int,Int) Int\ntype Characters = DiffUArray (Int,Int) Char\n\ninitialize :: (Int,Int) -> IO Field\ninitialize (x,y) = do\n  r <- replicateM (x*y) $ getStdRandom random\n  return $ listArray ((0,0),(x-1,y-1)) r\n\naggregate :: Field -> Counts\naggregate f = foldl count (listArray ((0,0),(xmax,ymax)) []) (indices f)\n  where\n    (xmax,ymax) = snd $ bounds f\n    count c (i,j) = c // [((i,j),n)]\n      where \n        n = length $ filter (f!) \n            [(x,y)|x<-[i-1,i,i+1],y<-[j-1,j,j+1],0<=x,x<=xmax,0<=y,y<=ymax] \n\nupdate :: Field -> Field\nupdate f = f // map life_or_death (indices f)\n  where\n    c = aggregate f\n    life_or_death i = if f!i \n      then case c!i of {3 -> (i,True); 4 -> (i,True); _ -> (i,False);}\n      else case c!i of {3 -> (i,True); _ -> (i,False);}\n\nformat :: Field -> Characters\nformat f = amap (\\b -> if b then 'o' else ' ') f\n\ndrawScreen :: Characters -> Update ()\ndrawScreen c = do\n  forM_ (indices c) $ \\(x,y) -> do\n    moveCursor (fromIntegral x) (fromIntegral y)\n    drawString $ [c!(x,y)]\n\n\nmain :: IO ()\nmain = do\n  [arg] <- getArgs -- \u5f15\u6570\u306f\u753b\u9762\u306e\u66f4\u65b0\u9593\u9694(\u30df\u30ea\u79d2)\n  let delaytime = read arg\n  runCurses $ do\n    (x,y) <- screenSize\n    f <- liftIO $ initialize (fromIntegral (x-1), fromIntegral y)\n    let series = map format $iterate update f\n    setEcho False\n    setCursorMode CursorInvisible\n    w <- defaultWindow\n    cid <- newColorID ColorGreen ColorBlack 1\n    updateWindow w $ setColor cid\n    forM_ series $ \\c -> do \n      updateWindow w $ drawScreen c\n      render\n      listenTo w delaytime \n        (\\ev -> ev == EventCharacter '\\n') -- Enter\u30ad\u30fc\u62bc\u4e0b\u3067\u7d42\u4e86\n\nlistenTo :: Window -> Int -> (Event -> Bool) -> Curses ()\nlistenTo w n p = do\n  ev <- getEvent w (Just $ fromIntegral n)\n  case ev of\n    Nothing -> return ()\n    Just ev' -> if p ev' then liftIO (killThread =<< myThreadId) else return ()\n\n\n\n\nLifeGame_IArray.hs\nmodule Main where\n\nimport Control.Monad (mapM_,forM_,sequence_,replicateM)\nimport Control.Concurrent (threadDelay)\nimport System.Random (getStdRandom,random)\nimport System.Environment (getArgs)\nimport Data.List\nimport Data.List.Split\nimport Data.Array.Unboxed\n\ntype Field = UArray (Int,Int) Bool \ntype Counts = UArray (Int,Int) Int\n\ninitialize :: (Int,Int) -> IO Field\ninitialize (x,y) = do\n  r <- replicateM (x*y) $ getStdRandom random\n  return $ listArray ((0,0),(x-1,y-1)) r\n\naggregate :: Field -> Counts\naggregate f = foldl count (listArray ((0,0),(xmax,ymax)) []) (indices f)\n  where\n    (xmax,ymax) = snd $ bounds f\n    count c (i,j) = c // [((i,j),n)]\n      where \n        n = length $ filter (f!) \n            [(x,y)|x<-[i-1,i,i+1],y<-[j-1,j,j+1],0<=x,x<=xmax,0<=y,y<=ymax] \n\nupdate :: Field -> Field\nupdate f = f // map life_or_death (indices f)\n  where\n    c = aggregate f\n    life_or_death i = if f!i \n      then case c!i of {3 -> (i,True); 4 -> (i,True); _ -> (i,False);}\n      else case c!i of {3 -> (i,True); _ -> (i,False);}\n\nformat :: Field -> [String]\nformat f = [take (ymax+3) $ repeat '#'] ++\n            map mark clist ++\n           [take (ymax+3) $ repeat '#']\n  where\n    clist = chunksOf (ymax+1) $ elems f\n    (xmax,ymax) = snd $ bounds f\n    mark bs = \"#\" ++ map (\\b -> if b then 'o' else ' ') bs ++ \"#\"\n\n\nmain = do\n [a1,a2,a3] <- getArgs -- a1:width, a2:height, a3:sleep (in mil. sec.) \n f <- initialize (read a2, read a1)\n let series = iterate update f\n     pField = mapM_ putStrLn . format\n     pFields = sequence_ . intersperse (threadDelay $ (read a3)*10^3) . map pField\n pFields series\n\n\n\nIArray\u306b\u4e00\u756a\u5411\u3044\u3066\u306a\u3044\u914d\u5217\u5168\u4f53\u306e\u66f4\u65b0\u3092\u3084\u3063\u3066\u307f\u308b\u3068\u3069\u3046\u306a\u308b\u306e\u304b\u3068\u601d\u3063\u3066\u3001\u30e9\u30a4\u30d5\u30fb\u30b2\u30fc\u30e0\u3092IArray\u3067\u66f8\u3044\u3066\u307f\u305f\u3002\u5f53\u305f\u308a\u524d\u3060\u304c\u4e88\u60f3\u901a\u308a\u3068\u3066\u3082\u9045\u3044\u3002immutable\u306a\u914d\u5217\u3063\u3066\u3084\u3063\u3071\u308a\u3053\u3046\u3044\u3046\u3082\u3093\u3060\u3088\u306a\u3002\u5b9f\u969b\u306e\u3068\u3053\u308d\u3001IOArray\u3068\u304b\u4f7f\u3063\u3066\u3082IO \u30e2\u30ca\u30c9\u306e\u4e2d\u3067\u64cd\u4f5c\u3059\u308b\u306e\u3068\u30b3\u30fc\u30c9\u306e\u898b\u305f\u76ee\u304c\u3084\u305f\u3089\u3068\u30b4\u30c1\u30e3\u30b4\u30c1\u30e3\u3059\u308b\u306e\u3092\u9664\u3051\u3070\u624b\u9593\u306f\u307b\u307c\u5909\u308f\u3089\u306a\u3044\u306e\u3067\u3001\u3053\u306e\u7a2e\u306e\u3082\u306e\u3092\u66f8\u304f\u3068\u304d\u306bIArray\u3092\u4f7f\u3046\u7406\u7531\u306f\u5168\u7136\u306a\u3044\u3053\u3068\u304c\u308f\u304b\u3063\u305f\u3002\u5f8c\u3067\u6687\u306a\u6642\u306bRepa\u3068\u304bData.Vector.Mutable\u3068\u304b\u4f7f\u3063\u3066\u66f8\u304d\u63db\u3048\u3066\u307f\u3088\u3046\u3068\u601d\u3063\u3066\u3044\u308b\u3002\n\n\u8ffd\u8a18\uff1a\u6d41\u77f3\u306b\u624b\u629c\u304d\u904e\u304e\u308b\u3068\u601d\u3063\u305f\u306e\u3067\u3001\u3082\u3046\u5c11\u3057\u30de\u30c8\u30e2\u306b\u3057\u3088\u3046\u3068\u8a66\u3057\u306bNCurses\u3092\u4f7f\u3063\u3066\u307f\u305f\n\uff08\u4e00\u5fdc\u3001NCurses\u3092\u4f7f\u308f\u306a\u3044\u3067\u3082\u3044\u3044\u5143\u3005\u306e\u30f4\u30a1\u30fc\u30b8\u30e7\u30f3\u3082\u4e0b\u306e\u65b9\u306b\u3042\u308b\uff09\u3002\u30d5\u30a3\u30fc\u30eb\u30c9\u306e\u5927\u304d\u3055\u306f\u30bf\u30fc\u30df\u30ca\u30eb\u5168\u753b\u9762\u306a\u306e\u3067\u9069\u5b9c\u30bf\u30fc\u30df\u30ca\u30eb\u306e\u30a6\u30a3\u30f3\u30c9\u30a6\u30b5\u30a4\u30ba\u3092\u5909\u66f4\u306e\u3053\u3068\u3002\u30b3\u30de\u30f3\u30c9\u30e9\u30a4\u30f3\u5f15\u6570\u306f\u30b9\u30ea\u30fc\u30d7\u9593\u9694\uff08\u30df\u30ea\u79d2\uff09\u3002\u5b9f\u884c\u4e2d\u306bENTER\u30ad\u30fc\u62bc\u4e0b\u3067\u7d42\u4e86\u3002\n\n\u518d\u8ffd\u8a18\uff1a\u914d\u5217\u306e\u4e2d\u8eab\u3092\u5168\u9762\u7684\u306b\u66f4\u65b0\u3059\u308b\u306e\u3067\u3054\u5229\u76ca\u304c\u306a\u3044\u3060\u308d\u3046\u3068\u601d\u3063\u3066\u3044\u305f\u304c\u3001UArray\u304b\u3089DiffUArray\u306b\u3057\u3066\u307f\u305f\u3089\u3001\u305d\u308c\u306a\u308a\u306b\u6539\u5584\u3055\u308c\u305f\uff08\u3082\u3061\u308d\u3093\u672c\u8cea\u7684\u306b\u306f\u9045\u3044\u307e\u307e\u3060\u3051\u3069\uff09\u3002IArray\u30af\u30e9\u30b9\u304c\u63d0\u4f9b\u3059\u308b\u30a4\u30f3\u30bf\u30fc\u30d5\u30a7\u30fc\u30b9\u306f\u5171\u901a\u306a\u306e\u3067\u3001\u5192\u982d\u306etype\u5ba3\u8a00\u306e\u3068\u3053\u308d\u306b\u6570\u6587\u5b57\u66f8\u304d\u52a0\u3048\u308b\u3060\u3051\u3060\u3002\u3068\u3044\u3046\u3053\u3068\u3067\u3001\u307e\u3059\u307e\u3059\u7d20\u306e(U)Array\u3092\u4f7f\u3046\u7406\u7531\u304c\u306a\u3044\u306a\u3042\u3002\n\n```\n./LifeGame 500\n```\n\n\u3053\u3093\u306a\u611f\u3058\u3002\n\n```hs:LifeGame_IArray_NCurses.hs\nmodule Main where\n\nimport Control.Monad (mapM_,forM_,sequence_,replicateM)\nimport Control.Monad.IO.Class (liftIO)\nimport Control.Concurrent (killThread, myThreadId)\nimport System.Random (getStdRandom,random)\nimport System.Environment (getArgs)\nimport UI.NCurses\nimport Data.Array.Diff\n\ntype Field = DiffUArray (Int,Int) Bool \ntype Counts = DiffUArray (Int,Int) Int\ntype Characters = DiffUArray (Int,Int) Char\n\ninitialize :: (Int,Int) -> IO Field\ninitialize (x,y) = do\n  r <- replicateM (x*y) $ getStdRandom random\n  return $ listArray ((0,0),(x-1,y-1)) r\n\naggregate :: Field -> Counts\naggregate f = foldl count (listArray ((0,0),(xmax,ymax)) []) (indices f)\n  where\n    (xmax,ymax) = snd $ bounds f\n    count c (i,j) = c // [((i,j),n)]\n      where \n        n = length $ filter (f!) \n            [(x,y)|x<-[i-1,i,i+1],y<-[j-1,j,j+1],0<=x,x<=xmax,0<=y,y<=ymax] \n\nupdate :: Field -> Field\nupdate f = f // map life_or_death (indices f)\n  where\n    c = aggregate f\n    life_or_death i = if f!i \n      then case c!i of {3 -> (i,True); 4 -> (i,True); _ -> (i,False);}\n      else case c!i of {3 -> (i,True); _ -> (i,False);}\n\nformat :: Field -> Characters\nformat f = amap (\\b -> if b then 'o' else ' ') f\n\ndrawScreen :: Characters -> Update ()\ndrawScreen c = do\n  forM_ (indices c) $ \\(x,y) -> do\n    moveCursor (fromIntegral x) (fromIntegral y)\n    drawString $ [c!(x,y)]\n\n\nmain :: IO ()\nmain = do\n  [arg] <- getArgs -- \u5f15\u6570\u306f\u753b\u9762\u306e\u66f4\u65b0\u9593\u9694(\u30df\u30ea\u79d2)\n  let delaytime = read arg\n  runCurses $ do\n    (x,y) <- screenSize\n    f <- liftIO $ initialize (fromIntegral (x-1), fromIntegral y)\n    let series = map format $iterate update f\n    setEcho False\n    setCursorMode CursorInvisible\n    w <- defaultWindow\n    cid <- newColorID ColorGreen ColorBlack 1\n    updateWindow w $ setColor cid\n    forM_ series $ \\c -> do \n      updateWindow w $ drawScreen c\n      render\n      listenTo w delaytime \n        (\\ev -> ev == EventCharacter '\\n') -- Enter\u30ad\u30fc\u62bc\u4e0b\u3067\u7d42\u4e86\n\nlistenTo :: Window -> Int -> (Event -> Bool) -> Curses ()\nlistenTo w n p = do\n  ev <- getEvent w (Just $ fromIntegral n)\n  case ev of\n    Nothing -> return ()\n    Just ev' -> if p ev' then liftIO (killThread =<< myThreadId) else return ()\n\n```\n\n```hs:LifeGame_IArray.hs\nmodule Main where\n\nimport Control.Monad (mapM_,forM_,sequence_,replicateM)\nimport Control.Concurrent (threadDelay)\nimport System.Random (getStdRandom,random)\nimport System.Environment (getArgs)\nimport Data.List\nimport Data.List.Split\nimport Data.Array.Unboxed\n\ntype Field = UArray (Int,Int) Bool \ntype Counts = UArray (Int,Int) Int\n\ninitialize :: (Int,Int) -> IO Field\ninitialize (x,y) = do\n  r <- replicateM (x*y) $ getStdRandom random\n  return $ listArray ((0,0),(x-1,y-1)) r\n\naggregate :: Field -> Counts\naggregate f = foldl count (listArray ((0,0),(xmax,ymax)) []) (indices f)\n  where\n    (xmax,ymax) = snd $ bounds f\n    count c (i,j) = c // [((i,j),n)]\n      where \n      \tn = length $ filter (f!) \n            [(x,y)|x<-[i-1,i,i+1],y<-[j-1,j,j+1],0<=x,x<=xmax,0<=y,y<=ymax] \n\nupdate :: Field -> Field\nupdate f = f // map life_or_death (indices f)\n  where\n  \tc = aggregate f\n  \tlife_or_death i = if f!i \n  \t  then case c!i of {3 -> (i,True); 4 -> (i,True); _ -> (i,False);}\n  \t  else case c!i of {3 -> (i,True); _ -> (i,False);}\n\nformat :: Field -> [String]\nformat f = [take (ymax+3) $ repeat '#'] ++\n            map mark clist ++\n           [take (ymax+3) $ repeat '#']\n  where\n  \tclist = chunksOf (ymax+1) $ elems f\n  \t(xmax,ymax) = snd $ bounds f\n  \tmark bs = \"#\" ++ map (\\b -> if b then 'o' else ' ') bs ++ \"#\"\n\n\nmain = do\n [a1,a2,a3] <- getArgs -- a1:width, a2:height, a3:sleep (in mil. sec.) \n f <- initialize (read a2, read a1)\n let series = iterate update f\n     pField = mapM_ putStrLn . format\n     pFields = sequence_ . intersperse (threadDelay $ (read a3)*10^3) . map pField\n pFields series\n\n```\n"}