{"context": "\n\n\u3084\u3063\u305f\u4e8b\n\u3000OV7670\u306e\u521d\u671f\u5316\u30d1\u30e1\u30fc\u30bf\u30fc\u306b\u8ffd\u52a0\u3092\u884c\u3044\u3001VAG\u3068QQVGA\u306e\u64ae\u5f71\u3092\u53ef\u80fd\u3068\u3057\u305f\u3002\n\u3000\u3053\u308c\u306b\u5408\u308f\u305b\u3066\u8868\u793a\u30bd\u30d5\u30c8\u3082\u5909\u66f4\u3092\u52a0\u3048\u305f\u3002\n\n\u64ae\u5f71\u4f8b\n\u3000(1)\uff36\uff27\uff21(640x480)\u30ab\u30e9\u30fc\n\n\u3000 (2)\uff31\uff31\uff36\uff27\uff21(160x120)\u30e2\u30ce\u30af\u30ed\n\n\n\u64ae\u5f71\u901f\u5ea6\n\u3000(1)\uff36\uff27\uff21\n\u3000\u3000\u901a\u5e38\u30e2\u30fc\u30c9\u3000\u30e2\u30ce\u30af\u30ed\u3000\uff14\uff0e\uff11\u79d2\u3001\u30ab\u30e9\u30fc\u3000\uff17\uff0e\uff19\u79d2\n\u3000(2)\uff31\uff36\uff27\uff21\n\u3000\u3000\u901a\u5e38\u30e2\u30fc\u30c9\u3000\u30e2\u30ce\u30af\u30ed\u3000\uff12\uff0e\uff11\u79d2\u3000\u30ab\u30e9\u30fc\u3000\uff14\uff0e\uff11\u79d2\n\u3000\u3000\u9ad8\u901f\u30e2\u30fc\u30c9\u3000\u3000\u3000\u3000\u3000\u3000\uff11\uff0e\uff12\u79d2\u3000\u3000\u3000\u3000\u3000\uff12\uff0e\uff11\u79d2\n\u3000(3)\uff31\uff31\uff36\uff27\uff21\n\u3000\u3000\u901a\u5e38\u30e2\u30fc\u30c9\u3000\u30e2\u30ce\u30af\u30ed\u3000\uff11\uff0e\uff12\u79d2\u3000\u30ab\u30e9\u30fc\u3000\uff12\uff0e\uff11\u79d2\n\u3000\u3000\u9ad8\u901f\u30e2\u30fc\u30c9\u3000\u3000\u3000\u3000\u3000\u3000\uff10\uff0e\uff14\u79d2\u3000\u30ab\u30e9\u30fc\u3000\uff10\uff0e\uff16\u79d2\n\n\u8a55\u4fa1\n\u3000Arduino\u3067\u3053\u3053\u307e\u3067\u51fa\u6765\u308b\u4e8b\u306f\u6280\u8853\u7684\u306b\u306f\u9762\u767d\u3044\u304c\u3001\uff36\uff27\uff21\u30ab\u30e9\u30fc\u3067\u306f\uff18\u79d2\u8981\u3057\u3066\u304a\u308a\u3001\u7528\u9014\u3068\u3057\u3066\u5fae\u901f\u5ea6\u64ae\u5f71\u3050\u3089\u3044\u3057\u304b\u601d\u3044\u3064\u304b\u306a\u3044\u3002\n\u3000\uff31\uff31\uff36\uff27\uff21\u9ad8\u901f\u30e2\u30fc\u30c9\u30e2\u30ce\u30af\u30ed\u3067\u306f\uff10\uff0e\uff14\u79d2(2.5fps)\u3067\u64ae\u5f71\u3067\u304d\u3066\u304a\u308a\u3001\u7c21\u6613\u306a\u753b\u50cf\u30bb\u30f3\u30b5\u30fc\u3068\u3057\u3066\u4f7f\u3048\u308b\u304b\u3082\u77e5\u308c\u306a\u3044\u3002\n\u3000\u3044\u305a\u308c\u306b\u305b\u3088\u3001\u9ad8\u901f(\u9ad8\u4fa1)\u306a\u30c1\u30c3\u30d7\u3092\u4f7f\u3048\u3070\u51fa\u6765\u308b\u306e\u306f\u5f53\u305f\u308a\u524d\u3067\u3042\u308a\u3001Arduino\u306e\u7bc4\u7587\u3067\u4f55\u304b\u51fa\u6765\u306a\u3044\u304b\u8003\u3048\u305f\u3044\u3002\n\n\u30bd\u30d5\u30c8\n\u300cuno_ov7670.ino\u300dver1.2\n\u3000\u8868\u793a\u30bd\u30d5\u30c8\u306f\u3000\uff3b\u305d\u306e\uff12\u3000\u753b\u50cf\u306e\u8868\u793a\uff3d\n// Source code for application to transmit image from ov7670 to PC via USB\n// By Siarhei Charkes in 2015\n// http://privateblog.info \n\n#include <stdint.h>\n#include <avr/io.h>\n#include <util/twi.h>\n#include <util/delay.h>\n#include <avr/pgmspace.h>\n\n#define camAddr_WR  0x42\n#define camAddr_RD  0x43\n#define REG_COM7  0x12\n#define REG_COM10 0x15  // Control 10 //\n#define REG_COM14 0x3e  // Control 14 //\n#define REG_COM15 0x40  // Control 15 //\n\nuint8_t cammd0=0, cammd1=0, cammd2=0;\nstruct regval_list{ uint8_t reg_num; uint16_t value; };\nconst struct regval_list ov7670_default_regs[] PROGMEM = {\n  {0x3a,0x04},{0x40,0xd0},{0x12,0x14},{0x32,0x80},{0x17,0x16},{0x18,0x04},{0x19,0x02},{0x1a,0x7b},\n  {0x03,0x06},{0x0c,0x00},{0x3e,0x00},{0x70,0x00},{0x71,0x00},{0x72,0x11},{0x73,0x00},{0xa2,0x02},\n  {0x11,0x81},{0x7a,0x20},{0x7b,0x1c},{0x7c,0x28},{0x7d,0x3c},{0x7e,0x55},{0x7f,0x68},{0x80,0x76},\n  {0x81,0x80},{0x82,0x88},{0x83,0x8f},{0x84,0x96},{0x85,0xa3},{0x86,0xaf},{0x87,0xc4},{0x88,0xd7},\n  {0x89,0xe8},{0x13,0xe0},{0x00,0x00},{0x10,0x00},{0x0d,0x00},{0x14,0x28},{0xa5,0x05},{0xab,0x07},\n  {0x24,0x75},{0x25,0x63},{0x26,0xA5},{0x9f,0x78},{0xa0,0x68},{0xa1,0x03},{0xa6,0xdf},{0xa7,0xdf},\n  {0xa8,0xf0},{0xa9,0x90},{0xaa,0x94},{0x13,0xe5},{0x0e,0x61},{0x0f,0x4b},{0x16,0x02},{0x1e,0x37}, //{0x1e,0x17}\n  {0x21,0x02},{0x22,0x91},{0x29,0x07},{0x33,0x0b},{0x35,0x0b},{0x37,0x1d},{0x38,0x71},{0x39,0x2a},\n  {0x3c,0x78},{0x4d,0x40},{0x4e,0x20},{0x69,0x00},{0x6b,0x00},{0x74,0x19},{0x8d,0x4f},{0x8e,0x00},\n  {0x8f,0x00},{0x90,0x00},{0x91,0x00},{0x92,0x00},{0x96,0x00},{0x9a,0x80},{0xb0,0x84},{0xb1,0x0c},\n  {0xb2,0x0e},{0xb3,0x82},{0xb8,0x0a},{0x43,0x14},{0x44,0xf0},{0x45,0x34},{0x46,0x58},{0x47,0x28},\n  {0x48,0x3a},{0x59,0x88},{0x5a,0x88},{0x5b,0x44},{0x5c,0x67},{0x5d,0x49},{0x5e,0x0e},{0x64,0x04},\n  {0x65,0x20},{0x66,0x05},{0x94,0x04},{0x95,0x08},{0x6c,0x0a},{0x6d,0x55},{0x6e,0x11},{0x6f,0x9f},\n  {0x6a,0x40},{0x01,0x40},{0x02,0x40},{0x13,0xe7},{0x15,0x02},{0x4f,0x80},{0x50,0x80},{0x51,0x00},\n  {0x52,0x22},{0x53,0x5e},{0x54,0x80},{0x58,0x9e},{0x41,0x08},{0x3f,0x00},{0x75,0x05},{0x76,0xe1},\n  {0x4c,0x00},{0x77,0x01},{0x3d,0xc2},{0x4b,0x09},{0xc9,0x60},{0x41,0x38},{0x56,0x40},{0x34,0x11},\n  {0x3b,0x02},{0xa4,0x89},{0x96,0x00},{0x97,0x30},{0x98,0x20},{0x99,0x30},{0x9a,0x84},{0x9b,0x29},\n  {0x9c,0x03},{0x9d,0x4c},{0x9e,0x3f},{0x78,0x04},{0x79,0x01},{0xc8,0xf0},{0x79,0x0f},{0xc8,0x00},\n  {0x79,0x10},{0xc8,0x7e},{0x79,0x0a},{0xc8,0x80},{0x79,0x0b},{0xc8,0x01},{0x79,0x0c},{0xc8,0x0f},\n  {0x79,0x0d},{0xc8,0x20},{0x79,0x09},{0xc8,0x80},{0x79,0x02},{0xc8,0xc0},{0x79,0x03},{0xc8,0x40},\n  {0x79,0x05},{0xc8,0x30},{0x79,0x26},{0x09,0x03},{0x3b,0x42},{0xff,0xff},\n};        \n\nvoid error_led(void){\n  DDRB |= 32;//make sure led is output\n  while (1){//wait for reset\n    PORTB ^= 32;// toggle led\n    _delay_ms(100);\n  }\n}\n\nvoid twiStart(void){\n  TWCR = _BV(TWINT) | _BV(TWSTA) | _BV(TWEN);//send start\n  while (!(TWCR & (1 << TWINT)));//wait for start to be transmitted\n  if ((TWSR & 0xF8) != TW_START)\n    error_led();\n}\n\nvoid twiWriteByte(uint8_t DATA, uint8_t type){\n  TWDR = DATA;\n  TWCR = _BV(TWINT) | _BV(TWEN);\n  while (!(TWCR & (1 << TWINT))) {}\n  if ((TWSR & 0xF8) != type)\n    error_led();\n}\n\nvoid twiAddr(uint8_t addr, uint8_t typeTWI){\n  TWDR = addr;//send address\n  TWCR = _BV(TWINT) | _BV(TWEN);    /* clear interrupt to start transmission */\n  while ((TWCR & _BV(TWINT)) == 0); /* wait for transmission */\n  if ((TWSR & 0xF8) != typeTWI)\n    error_led();\n}\n\nvoid wrReg(uint8_t reg, uint8_t dat){\n  //send start condition\n  twiStart();\n  twiAddr(camAddr_WR, TW_MT_SLA_ACK);\n  twiWriteByte(reg, TW_MT_DATA_ACK);\n  twiWriteByte(dat, TW_MT_DATA_ACK);\n  TWCR = (1 << TWINT) | (1 << TWEN) | (1 << TWSTO);//send stop\n  _delay_ms(1);\n}\n\nstatic uint8_t twiRd(uint8_t nack){\n  if (nack){\n    TWCR = _BV(TWINT) | _BV(TWEN);\n    while ((TWCR & _BV(TWINT)) == 0); /* wait for transmission */\n    if ((TWSR & 0xF8) != TW_MR_DATA_NACK)\n      error_led();\n    return TWDR;\n  }\n  else{\n    TWCR = _BV(TWINT) | _BV(TWEN) | _BV(TWEA);\n    while ((TWCR & _BV(TWINT)) == 0); /* wait for transmission */\n    if ((TWSR & 0xF8) != TW_MR_DATA_ACK)\n      error_led();\n    return TWDR;\n  }\n}\n\nuint8_t rdReg(uint8_t reg){\n  uint8_t dat;\n  twiStart();\n  twiAddr(camAddr_WR, TW_MT_SLA_ACK);\n  twiWriteByte(reg, TW_MT_DATA_ACK);\n  TWCR = (1 << TWINT) | (1 << TWEN) | (1 << TWSTO);//send stop\n  _delay_ms(1);\n  twiStart();\n  twiAddr(camAddr_RD, TW_MR_SLA_ACK);\n  dat = twiRd(1);\n  TWCR = (1 << TWINT) | (1 << TWEN) | (1 << TWSTO);//send stop\n  _delay_ms(1);\n  return dat;\n}\n\nvoid wrSensorRegs8_8(const struct regval_list reglist[]){\n  uint8_t reg_addr, reg_val;\n  const struct regval_list *next = reglist;\n  while ((reg_addr != 0xff) | (reg_val != 0xff)){\n    reg_addr = pgm_read_byte(&next->reg_num);\n    reg_val = pgm_read_byte(&next->value);\n    wrReg(reg_addr, reg_val);\n    next++;\n  }\n}\n\nvoid arduinoUnoInut(void) {\n  //cli();//disable interrupts\n\n  /* Setup the 8mhz PWM clock  * This will be on pin 11*/\n  DDRB |= (1 << 3);//pin 11\n  ASSR &= ~(_BV(EXCLK) | _BV(AS2));\n  TCCR2A = (1 << COM2A0) | (1 << WGM21) | (1 << WGM20);\n  TCCR2B = (1 << WGM22) | (1 << CS20);\n  OCR2A = 0;//(F_CPU)/(2*(X+1))\n  DDRC &= ~15;//low d0-d3 camera\n  DDRD &= ~252;//d7-d4 and interrupt pins\n\n  //set up twi for 100khz\n  TWSR &= ~3;//disable prescaler for TWI\n  TWBR = 72;//set to 100khz\n\n  //enable serial\n  UBRR0H  = 0;\n  UBRR0L  = 1; // 0 = 2M baud rate. 1 = 1M baud. 3 = 0.5M. 7 = 250k 207 is 9600 baud rate.\n  UCSR0A |= 2;//double speed aysnc\n  UCSR0B  = (1 << RXEN0) | (1 << TXEN0);//Enable receiver and transmitter\n  UCSR0C  = 6;//async 1 stop bit 8bit char no parity bits\n}\n\nvoid camInit(void){\n  wrReg(0x12, 0x80); delay(100);\n  wrSensorRegs8_8(ov7670_default_regs);\n  wrReg(REG_COM10, 32);//PCLK does not toggle on HBLANK.\n  wrReg(0x13, 0x8f); // Set ACE \n}\n\nvoid cammode_select(){\n  uint8_t clkspm,clkspc,com7s;\n  if(cammd2==2){ // QQVGA\n      com7s = 0x00;\n      wrReg(0x70, 0x3a); wrReg(0x71, 0x35); wrReg(0x72, 0x22); wrReg(0x73, 0xf2); \n      wrReg(0x0c, 0x04); wrReg(0x3e, 0x1a); wrReg(0xa2, 0x02);\n  } else {\n    if(cammd2==1){ // VGA\n      com7s = 0x00;\n      wrReg(0x70, 0x3a); wrReg(0x71, 0x35); wrReg(0x72, 0x11); wrReg(0x73, 0xf0); \n      wrReg(0x0c, 0x00);  wrReg(0x3e, 0x00); wrReg(0xa2, 0x02);\n    } else { // QVGA\n      com7s = 0x10;\n      wrReg(0x70, 0x3a); wrReg(0x71, 0x35); wrReg(0x72, 0x11); wrReg(0x73, 0xf1); \n      wrReg(0x0c, 0x04);  wrReg(0x3e, 0x19); wrReg(0xa2, 0x02);\n    }\n  }\n\n  if(cammd2==2) \n    if(cammd1) { clkspm = 1; clkspc =  2;}\n    else       { clkspm = 5; clkspc = 10;}\n  else {\n    if(cammd1) { clkspm = 5; clkspc = 10;}// Speedup \n    else       { clkspm = 10; clkspc = 20;}// Normal\n    if(cammd2 & 1) { clkspm = clkspm * 2; clkspc = clkspc * 2;} // if VGA\n  }\n\n  if(cammd0){ // Color \n    com7s = com7s + 4; // RGB565\n    wrReg(REG_COM15, 0xd0); \n    wrReg(0x11, clkspc); // Coloe Mode & Slow Speed\n  } else { // Mono\n    com7s = com7s + 0; // YUYV\n    wrReg(REG_COM15, 0xc0); \n    wrReg(0x11, clkspm); //Earlier it had the value: wrReg(0x11, 12); New version works better for me :) !!!!\n  } \n  wrReg(REG_COM7 , com7s); \n  //wrReg(0x71, 0xB5); // color bar\n}\n\nuint8_t imgbf[320];\nstatic void captureImg( uint16_t wg, uint16_t hg){\n  uint16_t y, x;\n  uint8_t rm0,rm1,*imgwp,*imgrp;\n  uint8_t s0s,s0b,s1s,s1b,s2s,s2b,s3s,s3b,qqvm; \n  while (!(PIND & 8)); while ((PIND & 8)); // VSYNC Falling edge\n\n  if(cammd2==2 && cammd1==1){ // QQVGA + SPD\n    if(cammd0){ // Color\n      s0b = 0; s1b = 1; s2b = 1;\n      s0s = 1; s1s = 0; s2s = 0;\n      qqvm = 0;\n    } else{ // mono\n      s0b = 1; s1b = 0; s2b = 1;\n      s0s = 0; s1s = 0; s2s = 0;\n      qqvm = 1;     \n    }\n  } else { \n    qqvm = 0;\n    s0b = 0; s0s = 1;\n    if(cammd0){\n      if(cammd1) {s1b = 1; s1s = 0; }\n      else       {s1b = 0; s1s = 1; }\n    } else       {s1b = 0; s1s = 0; }\n    if(cammd0 || !cammd1) {s2s = 1; s2b = 0;}\n    else                  {s2s = 0; s2b = 1;}\n  }\n\n  UDR0 = 0xff; // Start Mark\n  cli();\n  y = hg;\n  do{\n    x = wg / 2;\n    imgwp = &imgbf[0]; imgrp = &imgbf[0];\n    do{\n      while (!(PIND & 4)); while ((PIND & 4)); // PCLK Falling edge\n        if(qqvm) {\n          if((x & 1)==0) UDR0 = (PINC & 15) | (PIND & 240);\n          else           *imgwp++ = (PINC & 15) | (PIND & 240);\n        } else {\n          if(s0s) UDR0 = (PINC & 15) | (PIND & 240);\n          if(s0b) *imgwp++ = (PINC & 15) | (PIND & 240);\n        }\n      while (!(PIND & 4)); while ((PIND & 4)); // Falling edge\n        if(s1s) UDR0 = (PINC & 15) | (PIND & 240);\n        if(s1b) *imgwp++ = (PINC & 15) | (PIND & 240);\n      while (!(PIND & 4)); while ((PIND & 4)); // Falling edge\n        if(s2s) UDR0 = (PINC & 15) | (PIND & 240);\n        if(s2b) *imgwp++ = (PINC & 15) | (PIND & 240);\n      while (!(PIND & 4)); while ((PIND & 4)); // Falling edge\n        if(s1s) UDR0 = (PINC & 15) | (PIND & 240);\n        if(s1b) *imgwp++ = (PINC & 15) | (PIND & 240);\n    yield();\n    } while (--x);\n    while(imgrp!=imgwp) {\n      while (!(UCSR0A & (1 << UDRE0)));//wait for byte to transmit\n      UDR0 = *imgrp++;\n    yield();\n    }\n  } while (--y);\n\n  for( x=0; x<8; x++){ // End Mark\n    while (!(UCSR0A & (1 << UDRE0)));//wait for byte to transmit\n      UDR0 = 0;\n  }\n  sei();\n  //_delay_ms(100);\n}\n\nvoid wrOV7670Reg(unsigned char adr, unsigned char  dat){\n  wrReg( adr, dat);\n}\n\nvoid setup(){\n  arduinoUnoInut();\n  camInit(); \n  cammode_select();\n}\n\nint s22hex(char * ha){\n  int rc = 0,hi;\n  for(int i=0; i<2; i++){\n    char ch = *ha++;\n    if(ch>'9') hi = (ch & 0xdf)-0x37; else hi = ch-0x30;\n    rc = rc*16+hi;\n  }\n  return rc;\n}\nint rct = 0,repf = 0;\nchar rbf[16];\nbyte inChar = 0;\nchar * rbfp;\nvoid docmd(){\n  inChar = ' ';\n  if(UCSR0A & (1<<RXC0)){\n    byte kd = UDR0;\n    if(kd>=0x20) { rbf[rct++] = kd; return;\n    } else {\n      if(kd==0x08 && rct!=0) { rct--; return; } \n      else{ rbf[rct] = 0; inChar = rbf[0]; rbfp = &rbf[2]; rct = 0;}\n    }\n  } else if(repf==1) inChar = 'c';\n\n  if (inChar == 'c') {\n    if(rbf[1]==0){ \n      if(cammd2==2)   captureImg( 160, 120); // QQVGA\n      else\n        if(cammd2==1) captureImg( 640, 480); // VGA\n        else          captureImg( 320, 240); // QVGA\n    } else { \n      //camcolor = rbf[1]; \n      cammd0 = rbf[1] & 1;\n      cammd1 = (rbf[1]  >> 1) & 1;\n      cammd2 = (rbf[1]  >> 2) & 3;\n      cammode_select();  \n    }\n  }\n  if (inChar == 'r') repf = 1-repf;\n  if (inChar == 's') { // Setup ov7670 Regs\n    byte adr = s22hex(&rbf[1]);\n    byte dat = s22hex(&rbf[3]);\n    if(adr==0xff) setup();\n    else wrReg( adr, dat);\n  }\n}\nvoid loop(){\n  docmd();\n}\n\n\n\n\n\n\n\u305d\u306e\u4ed6\n\u3000\u4e0a\u8a18\u8a18\u8f09\u306e\u30cf\u30fc\u30c9\u3001\u30bd\u30d5\u30c8\u306f\u7121\u4fdd\u8a3c\u3067\u3042\u308a\u3001\u5404\u81ea\u306e\u8cac\u4efb\u306b\u304a\u3044\u3066\u3054\u5229\u7528\u9858\u3044\u307e\u3059\u3002\n\u3000\u3000\n\u3000\u3000\u3000\n\u3000\u3000\n\u3000\n#\u3084\u3063\u305f\u4e8b\n\u3000OV7670\u306e\u521d\u671f\u5316\u30d1\u30e1\u30fc\u30bf\u30fc\u306b\u8ffd\u52a0\u3092\u884c\u3044\u3001VAG\u3068QQVGA\u306e\u64ae\u5f71\u3092\u53ef\u80fd\u3068\u3057\u305f\u3002\n\u3000\u3053\u308c\u306b\u5408\u308f\u305b\u3066\u8868\u793a\u30bd\u30d5\u30c8\u3082\u5909\u66f4\u3092\u52a0\u3048\u305f\u3002\n#\u64ae\u5f71\u4f8b\n\u3000(1)\uff36\uff27\uff21(640x480)\u30ab\u30e9\u30fc\n![VGA_Color.jpg](https://qiita-image-store.s3.amazonaws.com/0/159764/b3b05e30-10b2-0c15-4fdd-7d9797f8bba0.jpeg)\n\u3000 (2)\uff31\uff31\uff36\uff27\uff21(160x120)\u30e2\u30ce\u30af\u30ed\n![QQVGA_Mono.jpg](https://qiita-image-store.s3.amazonaws.com/0/159764/74657fa0-ea1d-f74c-7071-111ef28ac84e.jpeg)\n\n#\u64ae\u5f71\u901f\u5ea6\n\u3000(1)\uff36\uff27\uff21\n\u3000\u3000\u901a\u5e38\u30e2\u30fc\u30c9\u3000\u30e2\u30ce\u30af\u30ed\u3000\uff14\uff0e\uff11\u79d2\u3001\u30ab\u30e9\u30fc\u3000\uff17\uff0e\uff19\u79d2\n\u3000(2)\uff31\uff36\uff27\uff21\n\u3000\u3000\u901a\u5e38\u30e2\u30fc\u30c9\u3000\u30e2\u30ce\u30af\u30ed\u3000\uff12\uff0e\uff11\u79d2\u3000\u30ab\u30e9\u30fc\u3000\uff14\uff0e\uff11\u79d2\n\u3000\u3000\u9ad8\u901f\u30e2\u30fc\u30c9\u3000\u3000\u3000\u3000\u3000\u3000\uff11\uff0e\uff12\u79d2\u3000\u3000\u3000\u3000\u3000\uff12\uff0e\uff11\u79d2\n\u3000(3)\uff31\uff31\uff36\uff27\uff21\n\u3000\u3000\u901a\u5e38\u30e2\u30fc\u30c9\u3000\u30e2\u30ce\u30af\u30ed\u3000\uff11\uff0e\uff12\u79d2\u3000\u30ab\u30e9\u30fc\u3000\uff12\uff0e\uff11\u79d2\n\u3000\u3000\u9ad8\u901f\u30e2\u30fc\u30c9\u3000\u3000\u3000\u3000\u3000\u3000\uff10\uff0e\uff14\u79d2\u3000\u30ab\u30e9\u30fc\u3000\uff10\uff0e\uff16\u79d2\n#\u8a55\u4fa1\n\u3000Arduino\u3067\u3053\u3053\u307e\u3067\u51fa\u6765\u308b\u4e8b\u306f\u6280\u8853\u7684\u306b\u306f\u9762\u767d\u3044\u304c\u3001\uff36\uff27\uff21\u30ab\u30e9\u30fc\u3067\u306f\uff18\u79d2\u8981\u3057\u3066\u304a\u308a\u3001\u7528\u9014\u3068\u3057\u3066\u5fae\u901f\u5ea6\u64ae\u5f71\u3050\u3089\u3044\u3057\u304b\u601d\u3044\u3064\u304b\u306a\u3044\u3002\n\u3000\uff31\uff31\uff36\uff27\uff21\u9ad8\u901f\u30e2\u30fc\u30c9\u30e2\u30ce\u30af\u30ed\u3067\u306f\uff10\uff0e\uff14\u79d2(2.5fps)\u3067\u64ae\u5f71\u3067\u304d\u3066\u304a\u308a\u3001\u7c21\u6613\u306a\u753b\u50cf\u30bb\u30f3\u30b5\u30fc\u3068\u3057\u3066\u4f7f\u3048\u308b\u304b\u3082\u77e5\u308c\u306a\u3044\u3002\n\u3000\u3044\u305a\u308c\u306b\u305b\u3088\u3001\u9ad8\u901f(\u9ad8\u4fa1)\u306a\u30c1\u30c3\u30d7\u3092\u4f7f\u3048\u3070\u51fa\u6765\u308b\u306e\u306f\u5f53\u305f\u308a\u524d\u3067\u3042\u308a\u3001Arduino\u306e\u7bc4\u7587\u3067\u4f55\u304b\u51fa\u6765\u306a\u3044\u304b\u8003\u3048\u305f\u3044\u3002\n\n#\u30bd\u30d5\u30c8\n\u300cuno_ov7670.ino\u300dver1.2\n\n\u3000\u8868\u793a\u30bd\u30d5\u30c8\u306f\u3000[\uff3b\u305d\u306e\uff12\u3000\u753b\u50cf\u306e\u8868\u793a\uff3d](http://qiita.com/hi631/items/94fa041a13714377332f)\n\n```\n// Source code for application to transmit image from ov7670 to PC via USB\n// By Siarhei Charkes in 2015\n// http://privateblog.info \n\n#include <stdint.h>\n#include <avr/io.h>\n#include <util/twi.h>\n#include <util/delay.h>\n#include <avr/pgmspace.h>\n\n#define camAddr_WR  0x42\n#define camAddr_RD  0x43\n#define REG_COM7  0x12\n#define REG_COM10 0x15  // Control 10 //\n#define REG_COM14 0x3e  // Control 14 //\n#define REG_COM15 0x40  // Control 15 //\n\nuint8_t cammd0=0, cammd1=0, cammd2=0;\nstruct regval_list{ uint8_t reg_num; uint16_t value; };\nconst struct regval_list ov7670_default_regs[] PROGMEM = {\n  {0x3a,0x04},{0x40,0xd0},{0x12,0x14},{0x32,0x80},{0x17,0x16},{0x18,0x04},{0x19,0x02},{0x1a,0x7b},\n  {0x03,0x06},{0x0c,0x00},{0x3e,0x00},{0x70,0x00},{0x71,0x00},{0x72,0x11},{0x73,0x00},{0xa2,0x02},\n  {0x11,0x81},{0x7a,0x20},{0x7b,0x1c},{0x7c,0x28},{0x7d,0x3c},{0x7e,0x55},{0x7f,0x68},{0x80,0x76},\n  {0x81,0x80},{0x82,0x88},{0x83,0x8f},{0x84,0x96},{0x85,0xa3},{0x86,0xaf},{0x87,0xc4},{0x88,0xd7},\n  {0x89,0xe8},{0x13,0xe0},{0x00,0x00},{0x10,0x00},{0x0d,0x00},{0x14,0x28},{0xa5,0x05},{0xab,0x07},\n  {0x24,0x75},{0x25,0x63},{0x26,0xA5},{0x9f,0x78},{0xa0,0x68},{0xa1,0x03},{0xa6,0xdf},{0xa7,0xdf},\n  {0xa8,0xf0},{0xa9,0x90},{0xaa,0x94},{0x13,0xe5},{0x0e,0x61},{0x0f,0x4b},{0x16,0x02},{0x1e,0x37}, //{0x1e,0x17}\n  {0x21,0x02},{0x22,0x91},{0x29,0x07},{0x33,0x0b},{0x35,0x0b},{0x37,0x1d},{0x38,0x71},{0x39,0x2a},\n  {0x3c,0x78},{0x4d,0x40},{0x4e,0x20},{0x69,0x00},{0x6b,0x00},{0x74,0x19},{0x8d,0x4f},{0x8e,0x00},\n  {0x8f,0x00},{0x90,0x00},{0x91,0x00},{0x92,0x00},{0x96,0x00},{0x9a,0x80},{0xb0,0x84},{0xb1,0x0c},\n  {0xb2,0x0e},{0xb3,0x82},{0xb8,0x0a},{0x43,0x14},{0x44,0xf0},{0x45,0x34},{0x46,0x58},{0x47,0x28},\n  {0x48,0x3a},{0x59,0x88},{0x5a,0x88},{0x5b,0x44},{0x5c,0x67},{0x5d,0x49},{0x5e,0x0e},{0x64,0x04},\n  {0x65,0x20},{0x66,0x05},{0x94,0x04},{0x95,0x08},{0x6c,0x0a},{0x6d,0x55},{0x6e,0x11},{0x6f,0x9f},\n  {0x6a,0x40},{0x01,0x40},{0x02,0x40},{0x13,0xe7},{0x15,0x02},{0x4f,0x80},{0x50,0x80},{0x51,0x00},\n  {0x52,0x22},{0x53,0x5e},{0x54,0x80},{0x58,0x9e},{0x41,0x08},{0x3f,0x00},{0x75,0x05},{0x76,0xe1},\n  {0x4c,0x00},{0x77,0x01},{0x3d,0xc2},{0x4b,0x09},{0xc9,0x60},{0x41,0x38},{0x56,0x40},{0x34,0x11},\n  {0x3b,0x02},{0xa4,0x89},{0x96,0x00},{0x97,0x30},{0x98,0x20},{0x99,0x30},{0x9a,0x84},{0x9b,0x29},\n  {0x9c,0x03},{0x9d,0x4c},{0x9e,0x3f},{0x78,0x04},{0x79,0x01},{0xc8,0xf0},{0x79,0x0f},{0xc8,0x00},\n  {0x79,0x10},{0xc8,0x7e},{0x79,0x0a},{0xc8,0x80},{0x79,0x0b},{0xc8,0x01},{0x79,0x0c},{0xc8,0x0f},\n  {0x79,0x0d},{0xc8,0x20},{0x79,0x09},{0xc8,0x80},{0x79,0x02},{0xc8,0xc0},{0x79,0x03},{0xc8,0x40},\n  {0x79,0x05},{0xc8,0x30},{0x79,0x26},{0x09,0x03},{0x3b,0x42},{0xff,0xff},\n};        \n\nvoid error_led(void){\n  DDRB |= 32;//make sure led is output\n  while (1){//wait for reset\n    PORTB ^= 32;// toggle led\n    _delay_ms(100);\n  }\n}\n\nvoid twiStart(void){\n  TWCR = _BV(TWINT) | _BV(TWSTA) | _BV(TWEN);//send start\n  while (!(TWCR & (1 << TWINT)));//wait for start to be transmitted\n  if ((TWSR & 0xF8) != TW_START)\n    error_led();\n}\n\nvoid twiWriteByte(uint8_t DATA, uint8_t type){\n  TWDR = DATA;\n  TWCR = _BV(TWINT) | _BV(TWEN);\n  while (!(TWCR & (1 << TWINT))) {}\n  if ((TWSR & 0xF8) != type)\n    error_led();\n}\n\nvoid twiAddr(uint8_t addr, uint8_t typeTWI){\n  TWDR = addr;//send address\n  TWCR = _BV(TWINT) | _BV(TWEN);    /* clear interrupt to start transmission */\n  while ((TWCR & _BV(TWINT)) == 0); /* wait for transmission */\n  if ((TWSR & 0xF8) != typeTWI)\n    error_led();\n}\n\nvoid wrReg(uint8_t reg, uint8_t dat){\n  //send start condition\n  twiStart();\n  twiAddr(camAddr_WR, TW_MT_SLA_ACK);\n  twiWriteByte(reg, TW_MT_DATA_ACK);\n  twiWriteByte(dat, TW_MT_DATA_ACK);\n  TWCR = (1 << TWINT) | (1 << TWEN) | (1 << TWSTO);//send stop\n  _delay_ms(1);\n}\n\nstatic uint8_t twiRd(uint8_t nack){\n  if (nack){\n    TWCR = _BV(TWINT) | _BV(TWEN);\n    while ((TWCR & _BV(TWINT)) == 0); /* wait for transmission */\n    if ((TWSR & 0xF8) != TW_MR_DATA_NACK)\n      error_led();\n    return TWDR;\n  }\n  else{\n    TWCR = _BV(TWINT) | _BV(TWEN) | _BV(TWEA);\n    while ((TWCR & _BV(TWINT)) == 0); /* wait for transmission */\n    if ((TWSR & 0xF8) != TW_MR_DATA_ACK)\n      error_led();\n    return TWDR;\n  }\n}\n\nuint8_t rdReg(uint8_t reg){\n  uint8_t dat;\n  twiStart();\n  twiAddr(camAddr_WR, TW_MT_SLA_ACK);\n  twiWriteByte(reg, TW_MT_DATA_ACK);\n  TWCR = (1 << TWINT) | (1 << TWEN) | (1 << TWSTO);//send stop\n  _delay_ms(1);\n  twiStart();\n  twiAddr(camAddr_RD, TW_MR_SLA_ACK);\n  dat = twiRd(1);\n  TWCR = (1 << TWINT) | (1 << TWEN) | (1 << TWSTO);//send stop\n  _delay_ms(1);\n  return dat;\n}\n\nvoid wrSensorRegs8_8(const struct regval_list reglist[]){\n  uint8_t reg_addr, reg_val;\n  const struct regval_list *next = reglist;\n  while ((reg_addr != 0xff) | (reg_val != 0xff)){\n    reg_addr = pgm_read_byte(&next->reg_num);\n    reg_val = pgm_read_byte(&next->value);\n    wrReg(reg_addr, reg_val);\n    next++;\n  }\n}\n\nvoid arduinoUnoInut(void) {\n  //cli();//disable interrupts\n  \n  /* Setup the 8mhz PWM clock  * This will be on pin 11*/\n  DDRB |= (1 << 3);//pin 11\n  ASSR &= ~(_BV(EXCLK) | _BV(AS2));\n  TCCR2A = (1 << COM2A0) | (1 << WGM21) | (1 << WGM20);\n  TCCR2B = (1 << WGM22) | (1 << CS20);\n  OCR2A = 0;//(F_CPU)/(2*(X+1))\n  DDRC &= ~15;//low d0-d3 camera\n  DDRD &= ~252;//d7-d4 and interrupt pins\n  \n  //set up twi for 100khz\n  TWSR &= ~3;//disable prescaler for TWI\n  TWBR = 72;//set to 100khz\n  \n  //enable serial\n  UBRR0H  = 0;\n  UBRR0L  = 1; // 0 = 2M baud rate. 1 = 1M baud. 3 = 0.5M. 7 = 250k 207 is 9600 baud rate.\n  UCSR0A |= 2;//double speed aysnc\n  UCSR0B  = (1 << RXEN0) | (1 << TXEN0);//Enable receiver and transmitter\n  UCSR0C  = 6;//async 1 stop bit 8bit char no parity bits\n}\n\nvoid camInit(void){\n  wrReg(0x12, 0x80); delay(100);\n  wrSensorRegs8_8(ov7670_default_regs);\n  wrReg(REG_COM10, 32);//PCLK does not toggle on HBLANK.\n  wrReg(0x13, 0x8f); // Set ACE \n}\n\nvoid cammode_select(){\n  uint8_t clkspm,clkspc,com7s;\n  if(cammd2==2){ // QQVGA\n      com7s = 0x00;\n      wrReg(0x70, 0x3a); wrReg(0x71, 0x35); wrReg(0x72, 0x22); wrReg(0x73, 0xf2); \n      wrReg(0x0c, 0x04); wrReg(0x3e, 0x1a); wrReg(0xa2, 0x02);\n  } else {\n    if(cammd2==1){ // VGA\n      com7s = 0x00;\n      wrReg(0x70, 0x3a); wrReg(0x71, 0x35); wrReg(0x72, 0x11); wrReg(0x73, 0xf0); \n      wrReg(0x0c, 0x00);  wrReg(0x3e, 0x00); wrReg(0xa2, 0x02);\n    } else { // QVGA\n      com7s = 0x10;\n      wrReg(0x70, 0x3a); wrReg(0x71, 0x35); wrReg(0x72, 0x11); wrReg(0x73, 0xf1); \n      wrReg(0x0c, 0x04);  wrReg(0x3e, 0x19); wrReg(0xa2, 0x02);\n    }\n  }\n\n  if(cammd2==2) \n    if(cammd1) { clkspm = 1; clkspc =  2;}\n    else       { clkspm = 5; clkspc = 10;}\n  else {\n    if(cammd1) { clkspm = 5; clkspc = 10;}// Speedup \n    else       { clkspm = 10; clkspc = 20;}// Normal\n    if(cammd2 & 1) { clkspm = clkspm * 2; clkspc = clkspc * 2;} // if VGA\n  }\n  \n  if(cammd0){ // Color \n    com7s = com7s + 4; // RGB565\n    wrReg(REG_COM15, 0xd0); \n    wrReg(0x11, clkspc); // Coloe Mode & Slow Speed\n  } else { // Mono\n    com7s = com7s + 0; // YUYV\n    wrReg(REG_COM15, 0xc0); \n    wrReg(0x11, clkspm); //Earlier it had the value: wrReg(0x11, 12); New version works better for me :) !!!!\n  } \n  wrReg(REG_COM7 , com7s); \n  //wrReg(0x71, 0xB5); // color bar\n}\n\nuint8_t imgbf[320];\nstatic void captureImg( uint16_t wg, uint16_t hg){\n  uint16_t y, x;\n  uint8_t rm0,rm1,*imgwp,*imgrp;\n  uint8_t s0s,s0b,s1s,s1b,s2s,s2b,s3s,s3b,qqvm; \n  while (!(PIND & 8)); while ((PIND & 8)); // VSYNC Falling edge\n\n  if(cammd2==2 && cammd1==1){ // QQVGA + SPD\n    if(cammd0){ // Color\n      s0b = 0; s1b = 1; s2b = 1;\n      s0s = 1; s1s = 0; s2s = 0;\n      qqvm = 0;\n    } else{ // mono\n      s0b = 1; s1b = 0; s2b = 1;\n      s0s = 0; s1s = 0; s2s = 0;\n      qqvm = 1;     \n    }\n  } else { \n    qqvm = 0;\n    s0b = 0; s0s = 1;\n    if(cammd0){\n      if(cammd1) {s1b = 1; s1s = 0; }\n      else       {s1b = 0; s1s = 1; }\n    } else       {s1b = 0; s1s = 0; }\n    if(cammd0 || !cammd1) {s2s = 1; s2b = 0;}\n    else                  {s2s = 0; s2b = 1;}\n  }\n\n  UDR0 = 0xff; // Start Mark\n  cli();\n  y = hg;\n  do{\n    x = wg / 2;\n    imgwp = &imgbf[0]; imgrp = &imgbf[0];\n    do{\n      while (!(PIND & 4)); while ((PIND & 4)); // PCLK Falling edge\n        if(qqvm) {\n          if((x & 1)==0) UDR0 = (PINC & 15) | (PIND & 240);\n          else           *imgwp++ = (PINC & 15) | (PIND & 240);\n        } else {\n          if(s0s) UDR0 = (PINC & 15) | (PIND & 240);\n          if(s0b) *imgwp++ = (PINC & 15) | (PIND & 240);\n        }\n      while (!(PIND & 4)); while ((PIND & 4)); // Falling edge\n        if(s1s) UDR0 = (PINC & 15) | (PIND & 240);\n        if(s1b) *imgwp++ = (PINC & 15) | (PIND & 240);\n      while (!(PIND & 4)); while ((PIND & 4)); // Falling edge\n        if(s2s) UDR0 = (PINC & 15) | (PIND & 240);\n        if(s2b) *imgwp++ = (PINC & 15) | (PIND & 240);\n      while (!(PIND & 4)); while ((PIND & 4)); // Falling edge\n        if(s1s) UDR0 = (PINC & 15) | (PIND & 240);\n        if(s1b) *imgwp++ = (PINC & 15) | (PIND & 240);\n    yield();\n    } while (--x);\n    while(imgrp!=imgwp) {\n      while (!(UCSR0A & (1 << UDRE0)));//wait for byte to transmit\n      UDR0 = *imgrp++;\n    yield();\n    }\n  } while (--y);\n\n  for( x=0; x<8; x++){ // End Mark\n    while (!(UCSR0A & (1 << UDRE0)));//wait for byte to transmit\n      UDR0 = 0;\n  }\n  sei();\n  //_delay_ms(100);\n}\n\nvoid wrOV7670Reg(unsigned char adr, unsigned char  dat){\n  wrReg( adr, dat);\n}\n\nvoid setup(){\n  arduinoUnoInut();\n  camInit(); \n  cammode_select();\n}\n\nint s22hex(char * ha){\n  int rc = 0,hi;\n  for(int i=0; i<2; i++){\n    char ch = *ha++;\n    if(ch>'9') hi = (ch & 0xdf)-0x37; else hi = ch-0x30;\n    rc = rc*16+hi;\n  }\n  return rc;\n}\nint rct = 0,repf = 0;\nchar rbf[16];\nbyte inChar = 0;\nchar * rbfp;\nvoid docmd(){\n  inChar = ' ';\n  if(UCSR0A & (1<<RXC0)){\n    byte kd = UDR0;\n    if(kd>=0x20) { rbf[rct++] = kd; return;\n    } else {\n      if(kd==0x08 && rct!=0) { rct--; return; } \n      else{ rbf[rct] = 0; inChar = rbf[0]; rbfp = &rbf[2]; rct = 0;}\n    }\n  } else if(repf==1) inChar = 'c';\n\n  if (inChar == 'c') {\n    if(rbf[1]==0){ \n      if(cammd2==2)   captureImg( 160, 120); // QQVGA\n      else\n        if(cammd2==1) captureImg( 640, 480); // VGA\n        else          captureImg( 320, 240); // QVGA\n    } else { \n      //camcolor = rbf[1]; \n      cammd0 = rbf[1] & 1;\n      cammd1 = (rbf[1]  >> 1) & 1;\n      cammd2 = (rbf[1]  >> 2) & 3;\n      cammode_select();  \n    }\n  }\n  if (inChar == 'r') repf = 1-repf;\n  if (inChar == 's') { // Setup ov7670 Regs\n    byte adr = s22hex(&rbf[1]);\n    byte dat = s22hex(&rbf[3]);\n    if(adr==0xff) setup();\n    else wrReg( adr, dat);\n  }\n}\nvoid loop(){\n  docmd();\n}\n\n\n\n\n```\n## \u305d\u306e\u4ed6\n\u3000\u4e0a\u8a18\u8a18\u8f09\u306e\u30cf\u30fc\u30c9\u3001\u30bd\u30d5\u30c8\u306f\u7121\u4fdd\u8a3c\u3067\u3042\u308a\u3001\u5404\u81ea\u306e\u8cac\u4efb\u306b\u304a\u3044\u3066\u3054\u5229\u7528\u9858\u3044\u307e\u3059\u3002\n\n\n\u3000\u3000\n\u3000\u3000\u3000\n\u3000\u3000\n\u3000\n", "tags": ["Arduino", "camera", "ov7670"]}