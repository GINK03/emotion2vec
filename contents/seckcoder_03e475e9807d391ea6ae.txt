{"context": " More than 1 year has passed since last update.I have started this post since reading \"Pearls of Functional Algorithm Design\" by Richard Bird. It contains my random thoughts about programming puzzles(some from that book). Most of the algorithms are implemented in Haskell. Most of the code in Haskell can run in fpcomplete's online IDE.\n\nBinary Search, the easy way\n\nBasic case\nDescription:\n\nGiven a list of sorted values, find the position of some given value. \nIf there are multiple values in the list, return any one of them\n\nThe basic case of binary search is very easy. \n\n\nimport Data.Vector\nimport Data.Maybe\n\nbinSearch :: (Int -> Ordering) -> (Int, Int) -> Maybe Int\nbinSearch f (p,r) | p > r = Nothing\n                  | otherwise = case f m of\n                                    EQ -> Just m\n                                    LT -> binSearch f (m+1,r)\n                                    GT -> binSearch f (p,m-1)\n                                  where m = (p+r) `div` 2\n\n-- special case for vector\nbinSearchInVec :: (Ord a) => Vector a -> a -> (Int,Int) -> Maybe Int\nbinSearchInVec vec val = binSearch (\\ m -> vec!m `compare` val)\n\n\n\nmain = print $ fromJust $ binSearchInVec (fromList [1,2,3,4]) 2 (0,3)\n\n\n\nExtended case1: find the smallest/largest index\nThe base case is easy since the terminating condition is clear. But for some extended cases, it's harder to get it right.\nThe most important questions one should ask when implementing binary search is\n\nWhen to return the result\nWhen to go to upper/lower range\nHow to change the range\n\nIf we can't find a good solution for above questions, we will get trapped in \"infinite loops\", \"out of bound error\", etc.\nSome claims that after changing the range from [p,r] to (p-1,r+1) or [p,r+1) or (p-1, r] will make it easier. However, I think a much better\nmethod is:\n\nAdd a variable mark to help decide when to return.\nChange the range aggressively. For every loop, we should decrease the range. \n\nDescription:\n\nGiven a list of sorted values, find the position of some given value.\nIf there are multiple values in the list, return the smallest index.\n\nimport Data.Vector\nimport Data.Maybe\n\nbinSearch :: (Int -> Ordering) -> (Int, Int) -> Maybe Int\nbinSearch f (p,r) = go (p,r) Nothing\n    where go (p,r) mark | p > r = mark\n                        | otherwise = case f m of\n                                        EQ -> go (p,m-1) (Just m)\n                                        LT -> go (m+1,r) mark\n                                        GT -> go (p,m-1) mark\n\n-- special case for vector\nbinSearchInVec :: (Ord a) => Vector a -> a -> (Int,Int) -> Maybe Int\nbinSearchInVec vec val = binSearch (\\ m -> vec!m `compare` val)\n\n\n\nmain = print $ fromJust $ binSearchInVec (fromList [1,2,2,3,4]) 2 (0,4)\n\nmark stores the most recent EQ value found. We can prove the above program will surely get the smallest index based on the following\ninductive rule:\n\nSuppose initial search range is [first, last], current search range is [p,r], then, mark = Nothing || Just min{x | first<=x<p || r < x <= last, f x == EQ }\n\nProof:\n\nInitially, p=first,r=lastp=first,r=last p = first , r = last , mark = Nothing.\nFor [p,r][p,r] [p,r] , suppose for x\u2208[first,p)\u222a(r,last]x\u2208[first,p)\u222a(r,last] x \\in [first,p) \\cup (r, last]  there exists fx=EQfx=EQ f x = EQ , then mark = Just x, otherwise mark = Nothing.\nWhen p > r, mark = Nothing || Just min {first<=x<=last, f x == EQ}.\n\nExercise: How to find the largest index? \n\nExtended case 2: find turning point.\nDescription:\n\nAt a given point: x, we break a strictly sorted list with length >= 3 into two parts: a and b, then append a to the end of b and get another list c. Now, the question is, given c, find the index of the smallest element in c(which is the head of original sorted list\n\nAgain, we will implement it with the help of mark variable.\n\nimport Data.Vector\nimport Data.Maybe\n\nbinSearch :: (Int -> Ordering) -> (Int, Int) -> Maybe Int\nbinSearch f (p,r) = go (p,r) Nothing\n    where go (p,r) mark | p > r = mark\n                        | otherwise = case f m of\n                                        EQ -> Nothing\n                                        LT -> go (p, m-1) (Just m)\n                                        GT -> go (m+1, r) mark\n                                       where m = (p+r) `div` 2\n\n-- special case for vector\nbinSearchInVec :: (Ord a) => Vector a -> (Int,Int) -> Maybe Int\nbinSearchInVec vec (p,r) = binSearch (\\ m -> (vec!m) `compare` (vec!p)) (p,r)\n\n\n\nmain = case binSearchInVec (fromList [2,3,1]) (0,2) of\n            Nothing -> print \"the list is not strictly increasing\"\n            Just i -> print i\n\n\n\nWhen to return the result?\n\nWhen p>r, we have considered all elements, so we should return the mark.\nWhen f m == EQ, we know that either m == first or there exists i\u2208[first,last]i\u2208[first,last] i \\in [first, last]  and fi=flastfi=flast f i = f last , both of which contradict with our question assumption (list should be strictly sorted and have a size >= 3). So we return Nothing.\n\n\nWhen to go to upper/lower range?\n\neasy question\n\nHow to change the range?\n\nAs I have always advocated, change the range aggressively to avoid infinite recursion.\n\nExtended case 3\nPoj has an interesting problem. My haskell implementation is as follows:\nMy solution:\n\n-- lower bound binary search.\nbinSearch :: (Int -> Bool) -> (Int,Int) -> Maybe Int\nbinSearch f (p,r) = go (p,r) Nothing\n  where go (p,r) mark | p > r = mark\n                      | otherwise = if f m then go (m+1,r) (Just m) else go (p,m-1) mark\n                                      where m = (p+r) `div` 2\n\n-- Note I didn't follow the format requested by the problem. \ncabalLength :: [Double] -> Int -> Double\ncabalLength cables num_pieces = case binSearch validLength (1, 10000000) of\n                                     Nothing -> fromIntegral 0\n                                     Just v -> (fromIntegral v) / 100\n    where cabal_ints = map (floor . (*100)) cables\n          validLength len = (foldr (+) 0 (map (`div` len) cabal_ints)) >= num_pieces\n\nmain = print $ cabalLength [8.02,7.43,4.57,5.39] 11\n\n\n\nTree traversal\nTree traversal is good example for recursive program design since it's intuitive. But the non-recursive version is not easy to understand, especially if it's implemented in some imperative programming languages like C. In this chapter, I will give the tail-recursive implementation(not in continuation passing style) of tree traversal in Haskell, which is easy to reimplement in C.\nFirst, I will provide the recursive implementation, which will be used by quick check to test the tail-recursive version.\ndata BinTree a = EmptyTree\n               | Branch a (BinTree a) (BinTree a) deriving (Show)\n\npreOrder :: BinTree a -> [a]\npreOrder (EmptyTree) = []\npreOrder (Branch a left right) = [a] ++ preOrder left ++ preOrder right\n\ninOrder :: BinTree a -> [a]\ninOrder (EmptyTree) = []\ninOrder (Branch a left right) = inOrder left ++ [a] ++ inOrder right\n\npostOrder :: BinTree a -> [a]\npostOrder (EmptyTree) = []\npostOrder (Branch a left right) = postOrder left ++ postOrder right ++ [a]\n\ndata BinTree a = EmptyTree\n               | Branch a (BinTree a) (BinTree a) deriving (Show)\n\npreOrder :: BinTree a -> [a]\npreOrder (EmptyTree) = []\npreOrder (Branch a left right) = [a] ++ preOrder left ++ preOrder right\n\ninOrder :: BinTree a -> [a]\ninOrder (EmptyTree) = []\ninOrder (Branch a left right) = inOrder left ++ [a] ++ inOrder right\n\npostOrder :: BinTree a -> [a]\npostOrder (EmptyTree) = []\npostOrder (Branch a left right) = postOrder left ++ postOrder right ++ [a]\n\nsampleTree :: BinTree Int\nsampleTree = Branch 4 (Branch 2 (Branch 1 EmptyTree EmptyTree) (Branch 3 EmptyTree EmptyTree)) (Branch 6 (Branch 5 EmptyTree EmptyTree) (Branch 7 EmptyTree EmptyTree))\n\nmain = putStr (\n         \"preorder: \" ++ (show $ preOrder sampleTree) ++ \"\\n\" ++\n         \"inorder: \" ++ (show $ inOrder sampleTree) ++ \"\\n\" ++\n         \"postorder: \" ++ (show $ postOrder sampleTree) ++ \"\\n\")\n\n\nTail-recursive version:\ndata BinTree a = EmptyTree\n               | Branch a (BinTree a) (BinTree a) deriving (Show)\n\n\npreOrderT :: BinTree a -> [a]\npreOrderT bt = go [bt] []\n  where go [] xs = reverse xs\n        go (EmptyTree:ts) xs = go ts xs\n        go (Branch v left right:ts) xs = go (left:right:ts) (v:xs)\n\ninOrderT :: BinTree a -> [a]\ninOrderT bt = go [bt] [] []\n  where go [] [] xs = reverse xs\n        go (EmptyTree:ts) [] xs = go ts [] xs\n        go (EmptyTree:ts) (v:left_acc) xs = go ts left_acc (v:xs)\n        go (Branch v left right:ts) left_acc xs = go (left:right:ts) (v:left_acc) xs\n\n-- tail recursive post order traversal\npostOrderT :: BinTree a -> [a]\npostOrderT bt = go [bt] []\n  where go [] xs = xs\n        go (EmptyTree:ts) xs = go ts xs\n        go (Branch v left right:ts) xs = go (right:left:ts) (v:xs)\n\nsampleTree :: BinTree Int\nsampleTree = Branch 4 (Branch 2 (Branch 1 EmptyTree EmptyTree) (Branch 3 EmptyTree EmptyTree)) (Branch 6 (Branch 5 EmptyTree EmptyTree) (Branch 7 EmptyTree EmptyTree))\n\nmain = putStr (\n         \"preorder: \" ++ (show $ preOrderT sampleTree) ++ \"\\n\" ++\n         \"inorder: \" ++ (show $ inOrderT sampleTree) ++ \"\\n\" ++\n         \"postorder: \" ++ (show $ postOrderT sampleTree) ++ \"\\n\")\n\n\n\nThe key point of tree traversal lies in visit order. For pre-order traversal, we should visit in the order of v -> left -> right. For in-order, it's left -> v -> right. For post-order, it should be left -> right -> v. The recursive version clearly shows the relationship. That's also why it's intuitive.\nFor the tail-recursive version, can we make it that clear? We know that stack can be used to implement function call. So we just need to use stack to store the context for visit order. Here, we use list to represent stack. \nFor preOrderT's local function go trees xs:\n  * trees: list of trees to visit. Suppose trees = (t:ts), i.e, t is in the left of ts. We maintain the order that t should always be visited before ts.\n  * xs: values of nodes that has already been visited. Suppose xs = (v:vs). We maintain that v was visited before vs, i.e., when the program terminated, we should return xs in reverse order. Also, as xs keeps values of nodes visited, we know nodes of values in xs are visited before nodes in trees.\nTherfore:\n\n\ngo [] xs : we have no trees to visit, we return xs in reverse order.\n\ngo (EmptyTree:ts) xs : currently on the top of the stack is an empty tree. We have nothing to record for it, so we continue with ts.\n\ngo (Branch v left right:ts) xs : according to our definition, the visit order for a branch is v -> left -> right. Therefore, we put v in the visited nodes xs and continue the process with left:right:ts, which means left is visited before right, which is also in front ofts`. Everything is Clear!\n\npostOrderT looks similar to preOrderT. Note that, the reverse visit order of post-order traversal is v->right->left.  So we only need to adapt the pre-order algorithm so that right is visited before left, then the reverse of the result of pre-order should be the result of post-order. Clear!\nFor inOrderT, go trees xs_acc xs:\n\n\ntrees and xs has the same meaning as preOrderT\n\nxs_acc: keeps values of nodes that we will visit. xs_acc is constructed during in-order traversal, it records the visiting context of node for the recursive definition. Suppose xs_acc = (x:acc). Then x should be visited before acc. Also, for trees = (t:ts), at the entry of function go, we should maintain t -> v -> (ts join acc). Here, join means keep the order t->v->... for ts and acc. To simplify, we need to make sure that t is visited before v while v should be visited before all other nodes. \n\nTherefore:\n\n\ngo [] [] xs : nothing to visit, return xs in reverse order\n\ngo (EmptyTree:ts) [] xs : this case happens when ts = []. As we have nothing to record for EmptyTree, we go with ts. \n\ngo (EmptyTree:ts) (v:left_acc) xs : remember that we need to maintain order t->v->rest. Therefore, we first visit EmptyTree(nothing to do), then visit v by adding it to xs.\n\ngo (Branch v left right:ts) left_acc xs: according to definition of in-order traversal, we need to make sure left->v->right. Therefore, we transfer it to go (left:right:ts) (v:left_acc) xs, which perfectly maintains our order t -> v -> rest. Clear!\n\nThe quick check property to help verify our implementation:\n-- Note the following code can't be run independently. \nrandomTree :: [a] -> Gen (BinTree a)\nrandomTree [] = return EmptyTree\nrandomTree (x:xs) = do\n  k <- choose (0, (length xs)-1)\n  let (ls,rs) = splitAt k xs\n  left <- randomTree ls\n  right <- randomTree rs\n  return $ Branch x left right\n\ninstance Arbitrary a => Arbitrary (BinTree a) where\n  arbitrary = do\n    n <- choose (0, 10000)\n    lst <- vector n\n    randomTree lst\n\nprop_postOrder bt = postOrder bt == postOrderT bt\n  where types = [bt :: BinTree Int]\n\nprop_preOrder bt = preOrder bt == preOrderT bt\n  where types = [bt :: BinTree Int]\n\nprop_inOrder bt = inOrder bt == inOrderT bt\n  where types = [bt :: BinTree Int]\n\n\nBased on the tail-recursive implementation, it's easy to implement an iterative version in C/C++:\n#include <iostream>\n#include <vector>\n#include <deque>\n\nusing namespace std;\n\nclass BinTree {\n  public:\n    BinTree() { v = 0; left = right = NULL; }\n    BinTree(int hv) { v = hv; left = right = NULL; }\n    int v;\n    BinTree *left;\n    BinTree *right;\n};\n\n\nvoid preOrder(BinTree *rt, deque<int> &xs) {\n  vector<BinTree *> stack;\n  stack.push_back(rt);\n  while (!stack.empty()) {\n    BinTree *cur = stack.back();\n    stack.pop_back();\n    if (cur != NULL) {\n      xs.push_back(cur -> v);\n      stack.push_back(cur->right);\n      stack.push_back(cur->left);\n    }\n  }\n}\n\nvoid inOrder(BinTree *rt, deque<int> &xs) {\n  vector<BinTree *> stack;\n  stack.push_back(rt);\n  vector<int> acc_xs;\n\n  while (!stack.empty()) {\n    BinTree *cur = stack.back();\n    stack.pop_back();\n    if (cur == NULL && acc_xs.empty()) {\n      // Nothing to do\n    } else if (cur == NULL) {\n      int x = acc_xs.back();\n      acc_xs.pop_back();\n      xs.push_back(x);\n    } else {\n      acc_xs.push_back(cur->v);\n      stack.push_back(cur->right);\n      stack.push_back(cur->left);\n    }\n  }\n}\n\n\nvoid postOrder(BinTree *rt, deque<int> &xs) {\n  vector<BinTree *> stack;\n  stack.push_back(rt);\n\n  while (!stack.empty()) {\n    BinTree *cur = stack.back();\n    stack.pop_back();\n    if (cur != NULL) {\n      xs.push_front(cur->v);\n      stack.push_back(cur->left);\n      stack.push_back(cur->right);\n    }\n  }\n}\n\n\nint main() {\n  BinTree n1(1);\n  BinTree n2(2);\n  BinTree n3(3);\n  n2.left = &n1;\n  n2.right = &n3;\n\n  cout << \"pre order:\" << endl;\n  {\n    deque<int> res;\n    preOrder(&n2, res);\n    for (int i = 0; i < res.size(); i++) {\n      cout << res[i] << endl;\n    }\n  }\n\n  cout << \"in order: \" << endl;\n  {\n    deque<int> res;\n    inOrder(&n2, res);\n    for (int i = 0; i < res.size(); i++) {\n      cout << res[i] << endl;\n    }\n  }\n\n  cout << \"post order: \" << endl;\n  {\n    deque<int> res;\n    postOrder(&n2, res);\n    for (int i = 0; i < res.size(); i++) {\n      cout << res[i] << endl;\n    }\n  }\n  return 0;\n}\n\n\nApparently, Haskell version looks much clearer than C version.\n\nExtende case1 : Binary Tree Iterator\n\nDescription: Construct a binary search tree iterator such that getting an element from the iterator should run in average O(1) time and O(h) memory.\n\nIt's trivial to implement this in Haskell since Haskell has native support for lazy evaluation. Actually, the above algorithm already fulfills the requirement.\nWhat about implementing this in C/C++?\nActually, what we want is in order tree traversal.\n\n#include <cstdio>\n#include <vector>\n#include <deque>\n#include <iostream>\nusing namespace std;\n\nstruct TreeNode {\n  int val;\n  TreeNode *left;\n  TreeNode *right;\n  TreeNode (int x) : val(x), left(NULL), right(NULL) {}\n};\n\nclass BSTIterator {\n  public:\n    TreeNode *rt;\n    vector<TreeNode*> trees;\n    deque<int> xs;\n    vector<int> xs_acc;\n    BSTIterator(TreeNode *root) {\n      rt = root;\n      trees.push_back(root);\n    }\n\n    /** @return whether we have a next smallest number */\n    bool hasNext() {\n      if (trees.size() == 1 && trees[0] == NULL && xs.empty() && xs_acc.empty()) return false;\n      return true;\n    }\n\n    /** @return the next smallest number */\n    int next() {\n      //preOrder();\n      inOrder();\n      int v = xs.front();\n      xs.pop_front();\n      return v;\n    }\n    void inOrder() {\n      while (!trees.empty() && xs.empty()) {\n        TreeNode *cur = trees.back();\n        trees.pop_back();\n        if (cur == NULL && xs_acc.empty()) {\n          // pass\n        } else if (cur == NULL) {\n          xs.push_back(xs_acc.back());\n          xs_acc.pop_back();\n        } else {\n          xs_acc.push_back(cur->val);\n          trees.push_back(cur->right);\n          trees.push_back(cur->left);\n        }\n      }\n    }\n};\n\n\nint main() {\n  TreeNode n1(1);\n  TreeNode n2(2);\n  TreeNode n3(3);\n  n2.left = &n1;\n  n2.right = &n3;\n  BSTIterator i = BSTIterator(&n2);\n  while (i.hasNext()) {\n    cout << i.next() << endl;\n  }\n  return 0;\n}\n\n\nHere, I changed the in-order tree traversal according to the requirement. xs can be used to keep the visited elements. A corner case for our algorithm is the terminating condition(when hasNext return false). We know this happens when go (EmptyTree:ts) [] xs is evaluated.\n\nBacktracking\nTODO...\n\nFinger Tree\nTODO...\n\nLexer and Parser\nTODO...\nI have started this post since reading \"Pearls of Functional Algorithm Design\" by Richard Bird. It contains my random thoughts about programming puzzles(some from that book). Most of the algorithms are implemented in Haskell. Most of the code in Haskell can run in [fpcomplete's online IDE][fpide].\n\n\n\n# Binary Search, the easy way\n\n## Basic case\n\nDescription:\n\n> Given a list of sorted values, find the position of some given value. \n> If there are multiple values in the list, return any one of them\n\nThe basic case of binary search is very easy. \n\n\n``` haskell\n\n\nimport Data.Vector\nimport Data.Maybe\n\nbinSearch :: (Int -> Ordering) -> (Int, Int) -> Maybe Int\nbinSearch f (p,r) | p > r = Nothing\n                  | otherwise = case f m of\n                                    EQ -> Just m\n                                    LT -> binSearch f (m+1,r)\n                                    GT -> binSearch f (p,m-1)\n                                  where m = (p+r) `div` 2\n\n-- special case for vector\nbinSearchInVec :: (Ord a) => Vector a -> a -> (Int,Int) -> Maybe Int\nbinSearchInVec vec val = binSearch (\\ m -> vec!m `compare` val)\n\n\n\nmain = print $ fromJust $ binSearchInVec (fromList [1,2,3,4]) 2 (0,3)\n\n```\n\n## Extended case1: find the smallest/largest index\n\nThe base case is easy since the terminating condition is clear. But for some extended cases, it's harder to get it right.\nThe most important questions one should ask when implementing binary search is\n\n- When to return the result\n\n- When to go to upper/lower range\n\n- How to change the range\n\nIf we can't find a good solution for above questions, we will get trapped in \"infinite loops\", \"out of bound error\", etc.\n\nSome claims that after changing the range from [p,r] to (p-1,r+1) or [p,r+1) or (p-1, r] will make it easier. However, I think a much better\nmethod is:\n\n1. Add a variable `mark` to help decide when to return.\n2. Change the range aggressively. For every loop, we should decrease the range. \n\nDescription:\n\n> Given a list of sorted values, find the position of some given value.\n> If there are multiple values in the list, return the **smallest** index.\n\n\n```haskell\nimport Data.Vector\nimport Data.Maybe\n\nbinSearch :: (Int -> Ordering) -> (Int, Int) -> Maybe Int\nbinSearch f (p,r) = go (p,r) Nothing\n    where go (p,r) mark | p > r = mark\n                        | otherwise = case f m of\n                                        EQ -> go (p,m-1) (Just m)\n                                        LT -> go (m+1,r) mark\n                                        GT -> go (p,m-1) mark\n    \n-- special case for vector\nbinSearchInVec :: (Ord a) => Vector a -> a -> (Int,Int) -> Maybe Int\nbinSearchInVec vec val = binSearch (\\ m -> vec!m `compare` val)\n\n\n\nmain = print $ fromJust $ binSearchInVec (fromList [1,2,2,3,4]) 2 (0,4)\n```\n\n`mark` stores the most recent EQ value found. We can prove the above program will surely get the smallest index based on the following\ninductive rule:\n\n> Suppose initial search range is [first, last], current search range is [p,r], then, mark = Nothing || Just min{x | first<=x<p || r < x <= last, f x == EQ }\n\nProof:\n\n- Initially, $ p = first , r = last $, `mark = Nothing`.\n\n- For $ [p,r] $, suppose for $ x \\in [first,p) \\cup (r, last] $ there exists $ f x = EQ $, then `mark = Just x`, otherwise `mark = Nothing`.\n\n- When p > r, `mark = Nothing || Just min {first<=x<=last, f x == EQ}`.\n\n\nExercise: How to find the largest index? \n\n\n## Extended case 2: find turning point.\n\nDescription:\n\n> At a given point: x, we break a strictly sorted list with length >= 3 into two parts: a and b, then append a to the end of b and get another list c. Now, the question is, given c, find the index of the smallest element in c(which is the head of original sorted list\n\n\nAgain, we will implement it with the help of `mark` variable.\n\n```hs\n\nimport Data.Vector\nimport Data.Maybe\n\nbinSearch :: (Int -> Ordering) -> (Int, Int) -> Maybe Int\nbinSearch f (p,r) = go (p,r) Nothing\n    where go (p,r) mark | p > r = mark\n                        | otherwise = case f m of\n                                        EQ -> Nothing\n                                        LT -> go (p, m-1) (Just m)\n                                        GT -> go (m+1, r) mark\n                                       where m = (p+r) `div` 2\n    \n-- special case for vector\nbinSearchInVec :: (Ord a) => Vector a -> (Int,Int) -> Maybe Int\nbinSearchInVec vec (p,r) = binSearch (\\ m -> (vec!m) `compare` (vec!p)) (p,r)\n\n\n\nmain = case binSearchInVec (fromList [2,3,1]) (0,2) of\n            Nothing -> print \"the list is not strictly increasing\"\n            Just i -> print i\n```\n\n\n- When to return the result?\n\n  * When `p>r`, we have considered all elements, so we should return the `mark`.\n  * When `f m == EQ`, we know that either `m == first` or there exists $ i \\in [first, last] $ and $ f i = f last $, both of which contradict with our question assumption (list should be strictly sorted and have a size >= 3). So we return Nothing.\n\n- When to go to upper/lower range?\n  \n  easy question\n\n- How to change the range?\n  \n  As I have always advocated, change the range aggressively to avoid infinite recursion.\n\n## Extended case 3\n\nPoj has an interesting [problem][poj1064]. My haskell implementation is as follows:\n\nMy solution:\n\n```hs\n\n-- lower bound binary search.\nbinSearch :: (Int -> Bool) -> (Int,Int) -> Maybe Int\nbinSearch f (p,r) = go (p,r) Nothing\n  where go (p,r) mark | p > r = mark\n                      | otherwise = if f m then go (m+1,r) (Just m) else go (p,m-1) mark\n                                      where m = (p+r) `div` 2\n\n-- Note I didn't follow the format requested by the problem. \ncabalLength :: [Double] -> Int -> Double\ncabalLength cables num_pieces = case binSearch validLength (1, 10000000) of\n                                     Nothing -> fromIntegral 0\n                                     Just v -> (fromIntegral v) / 100\n    where cabal_ints = map (floor . (*100)) cables\n          validLength len = (foldr (+) 0 (map (`div` len) cabal_ints)) >= num_pieces\n\nmain = print $ cabalLength [8.02,7.43,4.57,5.39] 11\n\n```\n\n\n# Tree traversal\n\nTree traversal is good example for recursive program design since it's intuitive. But the non-recursive version is not easy to understand, especially if it's implemented in some imperative programming languages like C. In this chapter, I will give the tail-recursive implementation(not in continuation passing style) of tree traversal in Haskell, which is easy to reimplement in C.\n\nFirst, I will provide the recursive implementation, which will be used by quick check to test the tail-recursive version.\n\n``` haskell\ndata BinTree a = EmptyTree\n               | Branch a (BinTree a) (BinTree a) deriving (Show)\n\npreOrder :: BinTree a -> [a]\npreOrder (EmptyTree) = []\npreOrder (Branch a left right) = [a] ++ preOrder left ++ preOrder right\n\ninOrder :: BinTree a -> [a]\ninOrder (EmptyTree) = []\ninOrder (Branch a left right) = inOrder left ++ [a] ++ inOrder right\n\npostOrder :: BinTree a -> [a]\npostOrder (EmptyTree) = []\npostOrder (Branch a left right) = postOrder left ++ postOrder right ++ [a]\n\ndata BinTree a = EmptyTree\n               | Branch a (BinTree a) (BinTree a) deriving (Show)\n\npreOrder :: BinTree a -> [a]\npreOrder (EmptyTree) = []\npreOrder (Branch a left right) = [a] ++ preOrder left ++ preOrder right\n\ninOrder :: BinTree a -> [a]\ninOrder (EmptyTree) = []\ninOrder (Branch a left right) = inOrder left ++ [a] ++ inOrder right\n\npostOrder :: BinTree a -> [a]\npostOrder (EmptyTree) = []\npostOrder (Branch a left right) = postOrder left ++ postOrder right ++ [a]\n\nsampleTree :: BinTree Int\nsampleTree = Branch 4 (Branch 2 (Branch 1 EmptyTree EmptyTree) (Branch 3 EmptyTree EmptyTree)) (Branch 6 (Branch 5 EmptyTree EmptyTree) (Branch 7 EmptyTree EmptyTree))\n\nmain = putStr (\n         \"preorder: \" ++ (show $ preOrder sampleTree) ++ \"\\n\" ++\n         \"inorder: \" ++ (show $ inOrder sampleTree) ++ \"\\n\" ++\n         \"postorder: \" ++ (show $ postOrder sampleTree) ++ \"\\n\")\n\n```\n\nTail-recursive version:\n\n```hs\ndata BinTree a = EmptyTree\n               | Branch a (BinTree a) (BinTree a) deriving (Show)\n\n\npreOrderT :: BinTree a -> [a]\npreOrderT bt = go [bt] []\n  where go [] xs = reverse xs\n        go (EmptyTree:ts) xs = go ts xs\n        go (Branch v left right:ts) xs = go (left:right:ts) (v:xs)\n\ninOrderT :: BinTree a -> [a]\ninOrderT bt = go [bt] [] []\n  where go [] [] xs = reverse xs\n        go (EmptyTree:ts) [] xs = go ts [] xs\n        go (EmptyTree:ts) (v:left_acc) xs = go ts left_acc (v:xs)\n        go (Branch v left right:ts) left_acc xs = go (left:right:ts) (v:left_acc) xs\n\n-- tail recursive post order traversal\npostOrderT :: BinTree a -> [a]\npostOrderT bt = go [bt] []\n  where go [] xs = xs\n        go (EmptyTree:ts) xs = go ts xs\n        go (Branch v left right:ts) xs = go (right:left:ts) (v:xs)\n\nsampleTree :: BinTree Int\nsampleTree = Branch 4 (Branch 2 (Branch 1 EmptyTree EmptyTree) (Branch 3 EmptyTree EmptyTree)) (Branch 6 (Branch 5 EmptyTree EmptyTree) (Branch 7 EmptyTree EmptyTree))\n\nmain = putStr (\n         \"preorder: \" ++ (show $ preOrderT sampleTree) ++ \"\\n\" ++\n         \"inorder: \" ++ (show $ inOrderT sampleTree) ++ \"\\n\" ++\n         \"postorder: \" ++ (show $ postOrderT sampleTree) ++ \"\\n\")\n\n\n```\n\nThe key point of tree traversal lies in visit order. For pre-order traversal, we should visit in the order of v -> left -> right. For in-order, it's left -> v -> right. For post-order, it should be left -> right -> v. The recursive version clearly shows the relationship. That's also why it's intuitive.\n\nFor the tail-recursive version, can we make it that clear? We know that stack can be used to implement function call. So we just need to use stack to store the context for visit order. Here, we use list to represent stack. \n\nFor `preOrderT`'s local function `go trees xs`:\n  * `trees`: list of trees to visit. Suppose `trees = (t:ts)`, i.e, `t` is in the left of `ts`. We maintain the order that `t` should always be visited before `ts`.\n  * `xs`: values of nodes that has already been visited. Suppose `xs = (v:vs)`. We maintain that `v` was visited before `vs`, i.e., when the program terminated, we should return `xs` in reverse order. Also, as `xs` keeps values of nodes visited, we know nodes of values in `xs` are visited before nodes in `trees`.\n\n\nTherfore:\n\n- `go [] xs` : we have no trees to visit, we return `xs` in reverse order.\n- `go (EmptyTree:ts) xs` : currently on the top of the stack is an empty tree. We have nothing to record for it, so we continue with `ts`.\n- `go (Branch v left right:ts) xs` : according to our definition, the visit order for a branch is `v -> left -> right`. Therefore, we put `v` in the visited nodes `xs` and continue the process with `left:right:ts`, which means `left` is visited before `right, which is also in front of `ts`. Everything is Clear!\n\npostOrderT looks similar to preOrderT. Note that, the reverse visit order of post-order traversal is `v->right->left`.  So we only need to adapt the pre-order algorithm so that right is visited before left, then the reverse of the result of pre-order should be the result of post-order. Clear!\n\nFor inOrderT, `go trees xs_acc xs`:\n\n- `trees` and `xs` has the same meaning as preOrderT\n- `xs_acc`: keeps values of nodes that we **will** visit. `xs_acc` is constructed during in-order traversal, it records the visiting context of node for the recursive definition. Suppose `xs_acc = (x:acc)`. Then `x` should be visited before `acc`. Also, for `trees = (t:ts)`, at the entry of function go, we should maintain `t -> v -> (ts join acc)`. Here, join means keep the order `t->v->...` for `ts` and `acc`. To simplify, we need to make sure that `t` is visited before `v` while `v` should be visited before all other nodes. \n\nTherefore:\n\n- `go [] [] xs` : nothing to visit, return `xs` in reverse order\n- `go (EmptyTree:ts) [] xs` : this case happens when `ts = []`. As we have nothing to record for EmptyTree, we go with `ts`. \n- `go (EmptyTree:ts) (v:left_acc) xs` : remember that we need to maintain order `t->v->rest`. Therefore, we first visit `EmptyTree`(nothing to do), then visit `v` by adding it to `xs`.\n- `go (Branch v left right:ts) left_acc xs`: according to definition of in-order traversal, we need to make sure `left->v->right`. Therefore, we transfer it to `go (left:right:ts) (v:left_acc) xs`, which perfectly maintains our order `t -> v -> rest`. Clear!\n\n\nThe quick check property to help verify our implementation:\n\n```hs\n-- Note the following code can't be run independently. \nrandomTree :: [a] -> Gen (BinTree a)\nrandomTree [] = return EmptyTree\nrandomTree (x:xs) = do\n  k <- choose (0, (length xs)-1)\n  let (ls,rs) = splitAt k xs\n  left <- randomTree ls\n  right <- randomTree rs\n  return $ Branch x left right\n\ninstance Arbitrary a => Arbitrary (BinTree a) where\n  arbitrary = do\n    n <- choose (0, 10000)\n    lst <- vector n\n    randomTree lst\n\nprop_postOrder bt = postOrder bt == postOrderT bt\n  where types = [bt :: BinTree Int]\n\nprop_preOrder bt = preOrder bt == preOrderT bt\n  where types = [bt :: BinTree Int]\n\nprop_inOrder bt = inOrder bt == inOrderT bt\n  where types = [bt :: BinTree Int]\n\n```\n\nBased on the tail-recursive implementation, it's easy to implement an iterative version in C/C++:\n\n```cpp\n#include <iostream>\n#include <vector>\n#include <deque>\n\nusing namespace std;\n\nclass BinTree {\n  public:\n    BinTree() { v = 0; left = right = NULL; }\n    BinTree(int hv) { v = hv; left = right = NULL; }\n    int v;\n    BinTree *left;\n    BinTree *right;\n};\n\n\nvoid preOrder(BinTree *rt, deque<int> &xs) {\n  vector<BinTree *> stack;\n  stack.push_back(rt);\n  while (!stack.empty()) {\n    BinTree *cur = stack.back();\n    stack.pop_back();\n    if (cur != NULL) {\n      xs.push_back(cur -> v);\n      stack.push_back(cur->right);\n      stack.push_back(cur->left);\n    }\n  }\n}\n\nvoid inOrder(BinTree *rt, deque<int> &xs) {\n  vector<BinTree *> stack;\n  stack.push_back(rt);\n  vector<int> acc_xs;\n\n  while (!stack.empty()) {\n    BinTree *cur = stack.back();\n    stack.pop_back();\n    if (cur == NULL && acc_xs.empty()) {\n      // Nothing to do\n    } else if (cur == NULL) {\n      int x = acc_xs.back();\n      acc_xs.pop_back();\n      xs.push_back(x);\n    } else {\n      acc_xs.push_back(cur->v);\n      stack.push_back(cur->right);\n      stack.push_back(cur->left);\n    }\n  }\n}\n\n\nvoid postOrder(BinTree *rt, deque<int> &xs) {\n  vector<BinTree *> stack;\n  stack.push_back(rt);\n\n  while (!stack.empty()) {\n    BinTree *cur = stack.back();\n    stack.pop_back();\n    if (cur != NULL) {\n      xs.push_front(cur->v);\n      stack.push_back(cur->left);\n      stack.push_back(cur->right);\n    }\n  }\n}\n\n\nint main() {\n  BinTree n1(1);\n  BinTree n2(2);\n  BinTree n3(3);\n  n2.left = &n1;\n  n2.right = &n3;\n\n  cout << \"pre order:\" << endl;\n  {\n    deque<int> res;\n    preOrder(&n2, res);\n    for (int i = 0; i < res.size(); i++) {\n      cout << res[i] << endl;\n    }\n  }\n  \n  cout << \"in order: \" << endl;\n  {\n    deque<int> res;\n    inOrder(&n2, res);\n    for (int i = 0; i < res.size(); i++) {\n      cout << res[i] << endl;\n    }\n  }\n  \n  cout << \"post order: \" << endl;\n  {\n    deque<int> res;\n    postOrder(&n2, res);\n    for (int i = 0; i < res.size(); i++) {\n      cout << res[i] << endl;\n    }\n  }\n  return 0;\n}\n\n```\n\nApparently, Haskell version looks much clearer than C version.\n\n\n## Extende case1 : Binary Tree Iterator\n\n> Description: Construct a binary search tree iterator such that getting an element from the iterator should run in average O(1) time and O(h) memory.\n\nIt's trivial to implement this in Haskell since Haskell has native support for lazy evaluation. Actually, the above algorithm already fulfills the requirement.\n\nWhat about implementing this in C/C++?\n\nActually, what we want is in order tree traversal.\n\n```cpp\n\n#include <cstdio>\n#include <vector>\n#include <deque>\n#include <iostream>\nusing namespace std;\n\nstruct TreeNode {\n  int val;\n  TreeNode *left;\n  TreeNode *right;\n  TreeNode (int x) : val(x), left(NULL), right(NULL) {}\n};\n\nclass BSTIterator {\n  public:\n    TreeNode *rt;\n    vector<TreeNode*> trees;\n    deque<int> xs;\n    vector<int> xs_acc;\n    BSTIterator(TreeNode *root) {\n      rt = root;\n      trees.push_back(root);\n    }\n\n    /** @return whether we have a next smallest number */\n    bool hasNext() {\n      if (trees.size() == 1 && trees[0] == NULL && xs.empty() && xs_acc.empty()) return false;\n      return true;\n    }\n\n    /** @return the next smallest number */\n    int next() {\n      //preOrder();\n      inOrder();\n      int v = xs.front();\n      xs.pop_front();\n      return v;\n    }\n    void inOrder() {\n      while (!trees.empty() && xs.empty()) {\n        TreeNode *cur = trees.back();\n        trees.pop_back();\n        if (cur == NULL && xs_acc.empty()) {\n          // pass\n        } else if (cur == NULL) {\n          xs.push_back(xs_acc.back());\n          xs_acc.pop_back();\n        } else {\n          xs_acc.push_back(cur->val);\n          trees.push_back(cur->right);\n          trees.push_back(cur->left);\n        }\n      }\n    }\n};\n\n\nint main() {\n  TreeNode n1(1);\n  TreeNode n2(2);\n  TreeNode n3(3);\n  n2.left = &n1;\n  n2.right = &n3;\n  BSTIterator i = BSTIterator(&n2);\n  while (i.hasNext()) {\n    cout << i.next() << endl;\n  }\n  return 0;\n}\n\n```\n\nHere, I changed the in-order tree traversal according to the requirement. `xs` can be used to keep the visited elements. A corner case for our algorithm is the terminating condition(when `hasNext` return false). We know this happens when `go (EmptyTree:ts) [] xs` is evaluated.\n\n\n\n# Backtracking\n\nTODO...\n\n# Finger Tree\n\nTODO...\n\n# Lexer and Parser\n\nTODO...\n\n\n\n[poj1064]: http://poj.org/problem?id=1064\n[fpide]: https://www.fpcomplete.com/business/developer-tools/\n", "tags": ["Haskell", "algorithm"]}