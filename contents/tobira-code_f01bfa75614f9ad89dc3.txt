{"context": "\n\n\u306f\u3058\u3081\u306b\nAAC\u30c7\u30fc\u30bf\u3092\u518d\u751f\u3059\u308b\u65b9\u6cd5\u3092\u8a18\u8f09\u3057\u307e\u3059\u3002\nOS\u306fWindows10\u3067\u3059\u3002\u958b\u767a\u74b0\u5883\u306fVisual Studio2015\u3092\u4f7f\u3044\u307e\u3057\u305f\u3002\n\u30c7\u30fc\u30bf\u30d5\u30ed\u30fc\u306f\u6b21\u306e\u901a\u308a\u3067\u3059\u3002\nTS file -> demux -> (AAC) -> decode -> (fltp PCM) -> (s16 PCM) -> Speaker out\n\u30d5\u30ed\u30fc\u306eStep\u3092\u8aac\u660e\u3057\u307e\u3059\u3002\n\nFFmpeg\u3067TS file\u304b\u3089AAC\u30c7\u30fc\u30bf\u3092\u53d6\u308a\u51fa\u3057\u307e\u3059(demux)\u3002\nFFmpeg\u3067AAC\u30c7\u30fc\u30bf\u3092decode\u3057\u3066fltp PCM\u30c7\u30fc\u30bf\u306b\u3057\u307e\u3059\u3002\nFFmpeg\u3067fltp PCM\u30c7\u30fc\u30bf\u3092s16 PCM\u30c7\u30fc\u30bf\u306b\u5909\u63db\u3057\u307e\u3059\u3002\nXaudio2\u3067s16 PCM\u30c7\u30fc\u30bf\u3092Speaker out\u3057\u307e\u3059\u3002\n\n\nPCM\u30d5\u30a9\u30fc\u30de\u30c3\u30c8\nPCM\u306e\u30d5\u30a9\u30fc\u30de\u30c3\u30c8\u3092\u8aac\u660e\u3057\u307e\u3059\u3002\nFFmpeg\u3067AAC\u3092\u30c7\u30b3\u30fc\u30c9\u3059\u308b\u3068AV_SAMPLE_FMT_FLTP(fltp)\u306b\u306a\u308a\u307e\u3059\u3002\n1sample\u304c32bit-float\u306eplanar\u5f62\u5f0f\u3067\u3059\u3002\n\nLR\u304c\u5225\u3005\u306e\u30a8\u30ea\u30a2;L1,L2,...,Ln:R1,R2,...,Rn\n\nXaudio2\u3067\u306fAV_SAMPLE_FMT_S16(s16)\u306b\u3059\u308b\u5fc5\u8981\u304c\u3042\u308a\u307e\u3059\u3002\n1sample 16bit-integer\u306einterleave\u5f62\u5f0f\u3067\u3059\u3002\n\nLR\u304c\u4ea4\u4e92\u306b\u73fe\u308c\u308b;L1,R1,L2,R2,...,Ln,Rn\n\n\nfltp\u3092s16\u306b\u5909\u63db\u3059\u308b\nswresample\u3092\u4f7f\u3063\u3066fltp\u3092s16\u306b\u5909\u63db\u3057\u307e\u3059\u3002\n(snip)\nif (swr == NULL) {\n    swr = swr_alloc();\n    if (swr == NULL) {\n        printf(\"swr_alloc error.\\n\");\n        break;\n    }\n    av_opt_set_int(swr, \"in_channel_layout\", frame->channel_layout, 0);\n    av_opt_set_int(swr, \"out_channel_layout\", frame->channel_layout, 0);\n    av_opt_set_int(swr, \"in_sample_rate\", frame->sample_rate, 0);\n    av_opt_set_int(swr, \"out_sample_rate\", frame->sample_rate, 0);\n    av_opt_set_sample_fmt(swr, \"in_sample_fmt\", (AVSampleFormat)frame->format, 0);\n    av_opt_set_sample_fmt(swr, \"out_sample_fmt\", AV_SAMPLE_FMT_S16, 0);\n    ret = swr_init(swr);\n    if (ret < 0) {\n        printf(\"swr_init error ret=%08x.\\n\", AVERROR(ret));\n        break;\n    }\n    int buf_size = frame->nb_samples*frame->channels * 2; /* the 2 means S16 */\n    swr_buf = new BYTE[buf_size];\n    swr_buf_len = buf_size;\n}\n\nret = swr_convert(swr, &swr_buf, frame->nb_samples, (const uint8_t**)frame->extended_data, frame->nb_samples);\nif (ret < 0) {\n    printf(\"swr_convert error ret=%08x.\\n\", AVERROR(ret));\n}\n(snip)\n\n\nsample code\nWin32 Console \u30a2\u30d7\u30ea\u30b1\u30fc\u30b7\u30e7\u30f3\u3092\u4f5c\u6210\u3057\u307e\u3059\u3002\nFFmpeg\u306eAPI\u3092\u4f7f\u3046\uff5e\u30d3\u30eb\u30c9\u74b0\u5883\u69cb\u7bc9\u3092\u53c2\u7167\u3057\u3066\u304f\u3060\u3055\u3044\u3002\n[\u69cb\u6210\u30d7\u30ed\u30d1\u30c6\u30a3]-[\u30ea\u30f3\u30ab\u30fc]-[\u5165\u529b]-[\u8ffd\u52a0\u306e\u4f9d\u5b58\u30d5\u30a1\u30a4\u30eb]\u306b\u6b21\u3092\u8ffd\u52a0\u3057\u307e\u3059\u3002\navcodec.lib\navdevice.lib\navfilter.lib\navformat.lib\navutil.lib\npostproc.lib\nswresample.lib\nswscale.lib\nxaudio2.lib\n\nTS file \"test.mpg\"\u3092FFmpeg\u3067demux\u3057\u3066AAC\u30c7\u30fc\u30bf\u3092\u53d6\u308a\u51fa\u3057\u307e\u3059\u3002\n\u53d6\u308a\u51fa\u3057\u305fAAC\u30c7\u30fc\u30bf\u3092\u30c7\u30b3\u30fc\u30c9\u3057\u3066fltp\u306b\u3057\u307e\u3059\u3002\nfltp\u3092s16\u306b\u5909\u63db\u3057\u307e\u3059\u3002s16\u3092Xaudio2\u3067Speaker out\u3057\u307e\u3059\u3002\n#include \"stdafx.h\"\n#include <xaudio2.h>\nextern \"C\" {\n#include <libavcodec/avcodec.h>\n#include <libavformat/avformat.h>\n#include <libavutil/opt.h>\n#include <libswresample/swresample.h>\n}\n\nclass VoiceCallback : public IXAudio2VoiceCallback\n{\npublic:\n    HANDLE event;\n    VoiceCallback() : event(CreateEvent(NULL, FALSE, FALSE, NULL)) {}\n    ~VoiceCallback() { CloseHandle(event); }\n    void STDMETHODCALLTYPE OnStreamEnd() {}\n    void STDMETHODCALLTYPE OnVoiceProcessingPassEnd() {}\n    void STDMETHODCALLTYPE OnVoiceProcessingPassStart(UINT32 samples) {}\n    void STDMETHODCALLTYPE OnBufferEnd(void * context) { SetEvent(event); }\n    void STDMETHODCALLTYPE OnBufferStart(void * context) {}\n    void STDMETHODCALLTYPE OnLoopEnd(void * context) {}\n    void STDMETHODCALLTYPE OnVoiceError(void * context, HRESULT Error) {}\n};\n\nint main()\n{\n    int ret = -1;\n\n    ret = CoInitializeEx(NULL, COINIT_MULTITHREADED);\n    if (FAILED(ret)) {\n        printf(\"error CoInitializeEx ret=%d\\n\", ret);\n        return -1;\n    }\n\n    IXAudio2 *audio = NULL;\n    ret = XAudio2Create(&audio);\n    if (FAILED(ret)) {\n        printf(\"error XAudio2Create ret=%d\\n\", ret);\n        return -1;\n    }\n\n    IXAudio2MasteringVoice *master = NULL;\n    ret = audio->CreateMasteringVoice(&master);\n    if (FAILED(ret)) {\n        printf(\"error CreateMasteringVoice ret=%d\\n\", ret);\n        return -1;\n    }\n\n    av_register_all();\n\n    const char *filename = \"test.mpg\";\n    AVFormatContext *format_context = NULL;\n    ret = avformat_open_input(&format_context, filename, NULL, NULL);\n    if (ret < 0) {\n        printf(\"cannot open file. filename=%s, ret=%08x\\n\", filename, AVERROR(ret));\n        return -1;\n    }\n\n    ret = avformat_find_stream_info(format_context, NULL);\n    if (ret < 0) {\n        printf(\"avformat_find_stream_info error. ret=%08x\\n\", AVERROR(ret));\n        return -1;\n    }\n\n    AVStream *audio_stream = NULL;\n    for (unsigned int i = 0; i < format_context->nb_streams; i++) {\n        if (format_context->streams[i]->codecpar->codec_type == AVMediaType::AVMEDIA_TYPE_AUDIO) {\n            audio_stream = format_context->streams[i];\n            break;\n        }\n    }\n    if (audio_stream == NULL) {\n        printf(\"stream not found\\n\");\n        return -1;\n    }\n\n    AVCodec *codec = avcodec_find_decoder(audio_stream->codecpar->codec_id);\n    if (codec == NULL) {\n        printf(\"avcodec_find_decoder codec not found. codec_id=%d\\n\", audio_stream->codecpar->codec_id);\n        return -1;\n    }\n\n    AVCodecContext *codec_context = avcodec_alloc_context3(codec);\n    if (codec_context == NULL) {\n        printf(\"avcodec_alloc_context3 error.\\n\");\n        return -1;\n    }\n\n    ret = avcodec_open2(codec_context, codec, NULL);\n    if (ret < 0) {\n        printf(\"avcodec_open2 error. ret=%08x\\n\", AVERROR(ret));\n        return -1;\n    }\n\n    AVFrame *frame = av_frame_alloc();\n    AVPacket packet;\n    int frame_number = 0;\n    SwrContext *swr = NULL;\n    BYTE* swr_buf = 0;\n    int swr_buf_len = 0;\n    IXAudio2SourceVoice *voice = NULL;\n    bool first_submit = true;\n    BYTE** buf = NULL;\n    int buf_cnt = 0;\n    VoiceCallback callback;\n    WAVEFORMATEX format = { 0 };\n\n    while (1) {\n        // read ES\n        if ((ret = av_read_frame(format_context, &packet)) < 0) {\n            printf(\"av_read_frame eof or error. ret=%08x\\n\", AVERROR(ret));\n            break; // eof or error\n        }\n        if (packet.stream_index == audio_stream->index) {\n            // decode ES\n            if ((ret = avcodec_send_packet(codec_context, &packet)) < 0) {\n                printf(\"avcodec_send_packet error. ret=%08x\\n\", AVERROR(ret));\n            }\n            if ((ret = avcodec_receive_frame(codec_context, frame)) < 0) {\n                if (ret != AVERROR(EAGAIN)) {\n                    printf(\"avcodec_receive_frame error. ret=%08x\\n\", AVERROR(ret));\n                    break;\n                }\n            }\n            else {\n                printf(\"frame_number=%d\\n\", ++frame_number);\n                if (swr == NULL) {\n                    swr = swr_alloc();\n                    if (swr == NULL) {\n                        printf(\"swr_alloc error.\\n\");\n                        break;\n                    }\n                    av_opt_set_int(swr, \"in_channel_layout\", frame->channel_layout, 0);\n                    av_opt_set_int(swr, \"out_channel_layout\", frame->channel_layout, 0);\n                    av_opt_set_int(swr, \"in_sample_rate\", frame->sample_rate, 0);\n                    av_opt_set_int(swr, \"out_sample_rate\", frame->sample_rate, 0);\n                    av_opt_set_sample_fmt(swr, \"in_sample_fmt\", (AVSampleFormat)frame->format, 0);\n                    av_opt_set_sample_fmt(swr, \"out_sample_fmt\", AV_SAMPLE_FMT_S16, 0);\n                    ret = swr_init(swr);\n                    if (ret < 0) {\n                        printf(\"swr_init error ret=%08x.\\n\", AVERROR(ret));\n                        break;\n                    }\n                    int buf_size = frame->nb_samples*frame->channels * 2; /* the 2 means S16 */\n                    swr_buf = new BYTE[buf_size];\n                    swr_buf_len = buf_size;\n                }\n\n                ret = swr_convert(swr, &swr_buf, frame->nb_samples, (const uint8_t**)frame->extended_data, frame->nb_samples);\n                if (ret < 0) {\n                    printf(\"swr_convert error ret=%08x.\\n\", AVERROR(ret));\n                }\n                if (voice == NULL) {\n                    format.wFormatTag = WAVE_FORMAT_PCM;\n                    format.nChannels = frame->channels;\n                    format.wBitsPerSample = 16;\n                    format.nSamplesPerSec = frame->sample_rate;\n                    format.nBlockAlign = format.wBitsPerSample / 8 * format.nChannels;\n                    format.nAvgBytesPerSec = format.nSamplesPerSec * format.nBlockAlign;\n                    ret = audio->CreateSourceVoice(\n                        &voice,\n                        &format,\n                        0,                          // UINT32 Flags = 0,\n                        XAUDIO2_DEFAULT_FREQ_RATIO, // float MaxFrequencyRatio = XAUDIO2_DEFAULT_FREQ_RATIO,\n                        &callback                   // IXAudio2VoiceCallback *pCallback = NULL,\n                    );\n                    if (FAILED(ret)) {\n                        printf(\"error CreateSourceVoice ret=%d\\n\", ret);\n                    }\n                    voice->Start();\n                }\n                if (buf == NULL) {\n                    buf = new BYTE*[2];\n                    buf[0] = new BYTE[swr_buf_len];\n                    buf[1] = new BYTE[swr_buf_len];\n                }\n                memcpy(buf[buf_cnt], swr_buf, swr_buf_len);\n                XAUDIO2_BUFFER buffer = { 0 };\n                buffer.AudioBytes = swr_buf_len;\n                buffer.pAudioData = buf[buf_cnt];\n                ret = voice->SubmitSourceBuffer(&buffer);\n                if (FAILED(ret)) {\n                    printf(\"error SubmitSourceBuffer ret=%d\\n\", ret);\n                }\n\n                if (first_submit) {\n                    first_submit = false;\n                }\n                else {\n                    if (WaitForSingleObject(callback.event, INFINITE) != WAIT_OBJECT_0) {\n                        printf(\"error WaitForSingleObject\\n\");\n                    }\n                }\n                if (2 <= ++buf_cnt)\n                    buf_cnt = 0;\n            }\n        }\n        else {\n            // does not audio ES.\n        }\n        av_packet_unref(&packet);\n    }\n\n    if (WaitForSingleObject(callback.event, INFINITE) != WAIT_OBJECT_0) {\n        printf(\"error WaitForSingleObject\\n\");\n    }\n\n    if (voice)\n        voice->Stop();\n\n    getchar(); // wait user input\n\n    // omit cleanup for simplify. (free/release etc...)\n\n    return 0;\n}\n\n\nreferences\nXaudio2\u3092\u4f7f\u3046\nFFmpeg\u306eAPI\u3092\u4f7f\u3046\uff5e\u30d3\u30eb\u30c9\u74b0\u5883\u69cb\u7bc9\nFFmpeg\u306eAPI\u3092\u4f7f\u3046\uff5eAAC\u30c7\u30b3\u30fc\u30c0\u51fa\u529b\u30d5\u30a9\u30fc\u30de\u30c3\u30c8fltp\u3092\u8abf\u3079\u3066\u307f\u308b\n# \u306f\u3058\u3081\u306b\nAAC\u30c7\u30fc\u30bf\u3092\u518d\u751f\u3059\u308b\u65b9\u6cd5\u3092\u8a18\u8f09\u3057\u307e\u3059\u3002\nOS\u306fWindows10\u3067\u3059\u3002\u958b\u767a\u74b0\u5883\u306fVisual Studio2015\u3092\u4f7f\u3044\u307e\u3057\u305f\u3002\n\n\u30c7\u30fc\u30bf\u30d5\u30ed\u30fc\u306f\u6b21\u306e\u901a\u308a\u3067\u3059\u3002\nTS file -> demux -> (AAC) -> decode -> (fltp PCM) -> (s16 PCM) -> Speaker out\n\n\u30d5\u30ed\u30fc\u306eStep\u3092\u8aac\u660e\u3057\u307e\u3059\u3002\n\n- FFmpeg\u3067TS file\u304b\u3089AAC\u30c7\u30fc\u30bf\u3092\u53d6\u308a\u51fa\u3057\u307e\u3059(demux)\u3002\n- FFmpeg\u3067AAC\u30c7\u30fc\u30bf\u3092decode\u3057\u3066fltp PCM\u30c7\u30fc\u30bf\u306b\u3057\u307e\u3059\u3002\n- FFmpeg\u3067fltp PCM\u30c7\u30fc\u30bf\u3092s16 PCM\u30c7\u30fc\u30bf\u306b\u5909\u63db\u3057\u307e\u3059\u3002\n- Xaudio2\u3067s16 PCM\u30c7\u30fc\u30bf\u3092Speaker out\u3057\u307e\u3059\u3002\n\n# PCM\u30d5\u30a9\u30fc\u30de\u30c3\u30c8\nPCM\u306e\u30d5\u30a9\u30fc\u30de\u30c3\u30c8\u3092\u8aac\u660e\u3057\u307e\u3059\u3002\n\nFFmpeg\u3067AAC\u3092\u30c7\u30b3\u30fc\u30c9\u3059\u308b\u3068AV_SAMPLE_FMT_FLTP(fltp)\u306b\u306a\u308a\u307e\u3059\u3002\n1sample\u304c32bit-float\u306eplanar\u5f62\u5f0f\u3067\u3059\u3002\n> LR\u304c\u5225\u3005\u306e\u30a8\u30ea\u30a2;L1,L2,...,Ln:R1,R2,...,Rn\n\nXaudio2\u3067\u306fAV_SAMPLE_FMT_S16(s16)\u306b\u3059\u308b\u5fc5\u8981\u304c\u3042\u308a\u307e\u3059\u3002\n1sample 16bit-integer\u306einterleave\u5f62\u5f0f\u3067\u3059\u3002\n> LR\u304c\u4ea4\u4e92\u306b\u73fe\u308c\u308b;L1,R1,L2,R2,...,Ln,Rn\n\n# fltp\u3092s16\u306b\u5909\u63db\u3059\u308b\n\nswresample\u3092\u4f7f\u3063\u3066fltp\u3092s16\u306b\u5909\u63db\u3057\u307e\u3059\u3002\n\n```cpp\n(snip)\nif (swr == NULL) {\n    swr = swr_alloc();\n    if (swr == NULL) {\n        printf(\"swr_alloc error.\\n\");\n        break;\n    }\n    av_opt_set_int(swr, \"in_channel_layout\", frame->channel_layout, 0);\n    av_opt_set_int(swr, \"out_channel_layout\", frame->channel_layout, 0);\n    av_opt_set_int(swr, \"in_sample_rate\", frame->sample_rate, 0);\n    av_opt_set_int(swr, \"out_sample_rate\", frame->sample_rate, 0);\n    av_opt_set_sample_fmt(swr, \"in_sample_fmt\", (AVSampleFormat)frame->format, 0);\n    av_opt_set_sample_fmt(swr, \"out_sample_fmt\", AV_SAMPLE_FMT_S16, 0);\n    ret = swr_init(swr);\n    if (ret < 0) {\n        printf(\"swr_init error ret=%08x.\\n\", AVERROR(ret));\n        break;\n    }\n    int buf_size = frame->nb_samples*frame->channels * 2; /* the 2 means S16 */\n    swr_buf = new BYTE[buf_size];\n    swr_buf_len = buf_size;\n}\n\nret = swr_convert(swr, &swr_buf, frame->nb_samples, (const uint8_t**)frame->extended_data, frame->nb_samples);\nif (ret < 0) {\n    printf(\"swr_convert error ret=%08x.\\n\", AVERROR(ret));\n}\n(snip)\n```\n\n# sample code\nWin32 Console \u30a2\u30d7\u30ea\u30b1\u30fc\u30b7\u30e7\u30f3\u3092\u4f5c\u6210\u3057\u307e\u3059\u3002\n[FFmpeg\u306eAPI\u3092\u4f7f\u3046\uff5e\u30d3\u30eb\u30c9\u74b0\u5883\u69cb\u7bc9](http://qiita.com/tobira-code/items/28df143014b606a53889)\u3092\u53c2\u7167\u3057\u3066\u304f\u3060\u3055\u3044\u3002\n[\u69cb\u6210\u30d7\u30ed\u30d1\u30c6\u30a3]-[\u30ea\u30f3\u30ab\u30fc]-[\u5165\u529b]-[\u8ffd\u52a0\u306e\u4f9d\u5b58\u30d5\u30a1\u30a4\u30eb]\u306b\u6b21\u3092\u8ffd\u52a0\u3057\u307e\u3059\u3002\n\n```\navcodec.lib\navdevice.lib\navfilter.lib\navformat.lib\navutil.lib\npostproc.lib\nswresample.lib\nswscale.lib\nxaudio2.lib\n```\n\nTS file \"test.mpg\"\u3092FFmpeg\u3067demux\u3057\u3066AAC\u30c7\u30fc\u30bf\u3092\u53d6\u308a\u51fa\u3057\u307e\u3059\u3002\n\u53d6\u308a\u51fa\u3057\u305fAAC\u30c7\u30fc\u30bf\u3092\u30c7\u30b3\u30fc\u30c9\u3057\u3066fltp\u306b\u3057\u307e\u3059\u3002\nfltp\u3092s16\u306b\u5909\u63db\u3057\u307e\u3059\u3002s16\u3092Xaudio2\u3067Speaker out\u3057\u307e\u3059\u3002\n\n```cpp\n#include \"stdafx.h\"\n#include <xaudio2.h>\nextern \"C\" {\n#include <libavcodec/avcodec.h>\n#include <libavformat/avformat.h>\n#include <libavutil/opt.h>\n#include <libswresample/swresample.h>\n}\n\nclass VoiceCallback : public IXAudio2VoiceCallback\n{\npublic:\n\tHANDLE event;\n\tVoiceCallback() : event(CreateEvent(NULL, FALSE, FALSE, NULL)) {}\n\t~VoiceCallback() { CloseHandle(event); }\n\tvoid STDMETHODCALLTYPE OnStreamEnd() {}\n\tvoid STDMETHODCALLTYPE OnVoiceProcessingPassEnd() {}\n\tvoid STDMETHODCALLTYPE OnVoiceProcessingPassStart(UINT32 samples) {}\n\tvoid STDMETHODCALLTYPE OnBufferEnd(void * context) { SetEvent(event); }\n\tvoid STDMETHODCALLTYPE OnBufferStart(void * context) {}\n\tvoid STDMETHODCALLTYPE OnLoopEnd(void * context) {}\n\tvoid STDMETHODCALLTYPE OnVoiceError(void * context, HRESULT Error) {}\n};\n\nint main()\n{\n\tint ret = -1;\n\n\tret = CoInitializeEx(NULL, COINIT_MULTITHREADED);\n\tif (FAILED(ret)) {\n\t\tprintf(\"error CoInitializeEx ret=%d\\n\", ret);\n\t\treturn -1;\n\t}\n\n\tIXAudio2 *audio = NULL;\n\tret = XAudio2Create(&audio);\n\tif (FAILED(ret)) {\n\t\tprintf(\"error XAudio2Create ret=%d\\n\", ret);\n\t\treturn -1;\n\t}\n\n\tIXAudio2MasteringVoice *master = NULL;\n\tret = audio->CreateMasteringVoice(&master);\n\tif (FAILED(ret)) {\n\t\tprintf(\"error CreateMasteringVoice ret=%d\\n\", ret);\n\t\treturn -1;\n\t}\n\n\tav_register_all();\n\n\tconst char *filename = \"test.mpg\";\n\tAVFormatContext *format_context = NULL;\n\tret = avformat_open_input(&format_context, filename, NULL, NULL);\n\tif (ret < 0) {\n\t\tprintf(\"cannot open file. filename=%s, ret=%08x\\n\", filename, AVERROR(ret));\n\t\treturn -1;\n\t}\n\n\tret = avformat_find_stream_info(format_context, NULL);\n\tif (ret < 0) {\n\t\tprintf(\"avformat_find_stream_info error. ret=%08x\\n\", AVERROR(ret));\n\t\treturn -1;\n\t}\n\n\tAVStream *audio_stream = NULL;\n\tfor (unsigned int i = 0; i < format_context->nb_streams; i++) {\n\t\tif (format_context->streams[i]->codecpar->codec_type == AVMediaType::AVMEDIA_TYPE_AUDIO) {\n\t\t\taudio_stream = format_context->streams[i];\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (audio_stream == NULL) {\n\t\tprintf(\"stream not found\\n\");\n\t\treturn -1;\n\t}\n\n\tAVCodec *codec = avcodec_find_decoder(audio_stream->codecpar->codec_id);\n\tif (codec == NULL) {\n\t\tprintf(\"avcodec_find_decoder codec not found. codec_id=%d\\n\", audio_stream->codecpar->codec_id);\n\t\treturn -1;\n\t}\n\n\tAVCodecContext *codec_context = avcodec_alloc_context3(codec);\n\tif (codec_context == NULL) {\n\t\tprintf(\"avcodec_alloc_context3 error.\\n\");\n\t\treturn -1;\n\t}\n\n\tret = avcodec_open2(codec_context, codec, NULL);\n\tif (ret < 0) {\n\t\tprintf(\"avcodec_open2 error. ret=%08x\\n\", AVERROR(ret));\n\t\treturn -1;\n\t}\n\n\tAVFrame *frame = av_frame_alloc();\n\tAVPacket packet;\n\tint frame_number = 0;\n\tSwrContext *swr = NULL;\n\tBYTE* swr_buf = 0;\n\tint swr_buf_len = 0;\n\tIXAudio2SourceVoice *voice = NULL;\n\tbool first_submit = true;\n\tBYTE** buf = NULL;\n\tint buf_cnt = 0;\n\tVoiceCallback callback;\n\tWAVEFORMATEX format = { 0 };\n\n\twhile (1) {\n\t\t// read ES\n\t\tif ((ret = av_read_frame(format_context, &packet)) < 0) {\n\t\t\tprintf(\"av_read_frame eof or error. ret=%08x\\n\", AVERROR(ret));\n\t\t\tbreak; // eof or error\n\t\t}\n\t\tif (packet.stream_index == audio_stream->index) {\n\t\t\t// decode ES\n\t\t\tif ((ret = avcodec_send_packet(codec_context, &packet)) < 0) {\n\t\t\t\tprintf(\"avcodec_send_packet error. ret=%08x\\n\", AVERROR(ret));\n\t\t\t}\n\t\t\tif ((ret = avcodec_receive_frame(codec_context, frame)) < 0) {\n\t\t\t\tif (ret != AVERROR(EAGAIN)) {\n\t\t\t\t\tprintf(\"avcodec_receive_frame error. ret=%08x\\n\", AVERROR(ret));\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tprintf(\"frame_number=%d\\n\", ++frame_number);\n\t\t\t\tif (swr == NULL) {\n\t\t\t\t\tswr = swr_alloc();\n\t\t\t\t\tif (swr == NULL) {\n\t\t\t\t\t\tprintf(\"swr_alloc error.\\n\");\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tav_opt_set_int(swr, \"in_channel_layout\", frame->channel_layout, 0);\n\t\t\t\t\tav_opt_set_int(swr, \"out_channel_layout\", frame->channel_layout, 0);\n\t\t\t\t\tav_opt_set_int(swr, \"in_sample_rate\", frame->sample_rate, 0);\n\t\t\t\t\tav_opt_set_int(swr, \"out_sample_rate\", frame->sample_rate, 0);\n\t\t\t\t\tav_opt_set_sample_fmt(swr, \"in_sample_fmt\", (AVSampleFormat)frame->format, 0);\n\t\t\t\t\tav_opt_set_sample_fmt(swr, \"out_sample_fmt\", AV_SAMPLE_FMT_S16, 0);\n\t\t\t\t\tret = swr_init(swr);\n\t\t\t\t\tif (ret < 0) {\n\t\t\t\t\t\tprintf(\"swr_init error ret=%08x.\\n\", AVERROR(ret));\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tint buf_size = frame->nb_samples*frame->channels * 2; /* the 2 means S16 */\n\t\t\t\t\tswr_buf = new BYTE[buf_size];\n\t\t\t\t\tswr_buf_len = buf_size;\n\t\t\t\t}\n\n\t\t\t\tret = swr_convert(swr, &swr_buf, frame->nb_samples, (const uint8_t**)frame->extended_data, frame->nb_samples);\n\t\t\t\tif (ret < 0) {\n\t\t\t\t\tprintf(\"swr_convert error ret=%08x.\\n\", AVERROR(ret));\n\t\t\t\t}\n\t\t\t\tif (voice == NULL) {\n\t\t\t\t\tformat.wFormatTag = WAVE_FORMAT_PCM;\n\t\t\t\t\tformat.nChannels = frame->channels;\n\t\t\t\t\tformat.wBitsPerSample = 16;\n\t\t\t\t\tformat.nSamplesPerSec = frame->sample_rate;\n\t\t\t\t\tformat.nBlockAlign = format.wBitsPerSample / 8 * format.nChannels;\n\t\t\t\t\tformat.nAvgBytesPerSec = format.nSamplesPerSec * format.nBlockAlign;\n\t\t\t\t\tret = audio->CreateSourceVoice(\n\t\t\t\t\t\t&voice,\n\t\t\t\t\t\t&format,\n\t\t\t\t\t\t0,                          // UINT32 Flags = 0,\n\t\t\t\t\t\tXAUDIO2_DEFAULT_FREQ_RATIO, // float MaxFrequencyRatio = XAUDIO2_DEFAULT_FREQ_RATIO,\n\t\t\t\t\t\t&callback                   // IXAudio2VoiceCallback *pCallback = NULL,\n\t\t\t\t\t);\n\t\t\t\t\tif (FAILED(ret)) {\n\t\t\t\t\t\tprintf(\"error CreateSourceVoice ret=%d\\n\", ret);\n\t\t\t\t\t}\n\t\t\t\t\tvoice->Start();\n\t\t\t\t}\n\t\t\t\tif (buf == NULL) {\n\t\t\t\t\tbuf = new BYTE*[2];\n\t\t\t\t\tbuf[0] = new BYTE[swr_buf_len];\n\t\t\t\t\tbuf[1] = new BYTE[swr_buf_len];\n\t\t\t\t}\n\t\t\t\tmemcpy(buf[buf_cnt], swr_buf, swr_buf_len);\n\t\t\t\tXAUDIO2_BUFFER buffer = { 0 };\n\t\t\t\tbuffer.AudioBytes = swr_buf_len;\n\t\t\t\tbuffer.pAudioData = buf[buf_cnt];\n\t\t\t\tret = voice->SubmitSourceBuffer(&buffer);\n\t\t\t\tif (FAILED(ret)) {\n\t\t\t\t\tprintf(\"error SubmitSourceBuffer ret=%d\\n\", ret);\n\t\t\t\t}\n\n\t\t\t\tif (first_submit) {\n\t\t\t\t\tfirst_submit = false;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (WaitForSingleObject(callback.event, INFINITE) != WAIT_OBJECT_0) {\n\t\t\t\t\t\tprintf(\"error WaitForSingleObject\\n\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (2 <= ++buf_cnt)\n\t\t\t\t\tbuf_cnt = 0;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t// does not audio ES.\n\t\t}\n\t\tav_packet_unref(&packet);\n\t}\n\n\tif (WaitForSingleObject(callback.event, INFINITE) != WAIT_OBJECT_0) {\n\t\tprintf(\"error WaitForSingleObject\\n\");\n\t}\n\n\tif (voice)\n\t\tvoice->Stop();\n\n\tgetchar(); // wait user input\n\n\t// omit cleanup for simplify. (free/release etc...)\n\n\treturn 0;\n}\n```\n\n# references\n[Xaudio2\u3092\u4f7f\u3046](http://qiita.com/tobira-code/items/39936c4e2b1168fb79ce)\n[FFmpeg\u306eAPI\u3092\u4f7f\u3046\uff5e\u30d3\u30eb\u30c9\u74b0\u5883\u69cb\u7bc9](http://qiita.com/tobira-code/items/28df143014b606a53889)\n[FFmpeg\u306eAPI\u3092\u4f7f\u3046\uff5eAAC\u30c7\u30b3\u30fc\u30c0\u51fa\u529b\u30d5\u30a9\u30fc\u30de\u30c3\u30c8fltp\u3092\u8abf\u3079\u3066\u307f\u308b](http://qiita.com/tobira-code/items/00f138d41602787e2441)\n", "tags": ["ffmpeg", "aac", "audio", "Xaudio2", "VisualStudio"]}