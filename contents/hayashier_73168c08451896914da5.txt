{"tags": ["HTTP", "http2", "Web", "C++"], "context": "\u524d\u534a\u3067HTTP\u306b\u3088\u308bWeb\u30b5\u30fc\u30d0\u306e\u52d5\u4f5c\u3092\u7406\u89e3\u3059\u308b\u305f\u3081\u306e\u57fa\u672c\u7684\u306a\u4e8b\u524d\u77e5\u8b58\u3092\u6574\u7406\u3057\u3066\u7406\u89e3\u3057\u307e\u3059\u3002\u305d\u3057\u3066\u3001\u5f8c\u534a\u306b\u305d\u308c\u3089\u306e\u77e5\u8b58\u3092\u5143\u306bC++\u306b\u3088\u308b\u7c21\u6613\u306aHTTP\u30b5\u30fc\u30d0\u3092\u30d5\u30eb\u30b9\u30af\u30e9\u30c3\u30c1\u3067\u5b9f\u88c5\u3057\u3066\u7406\u89e3\u3057\u307e\u3059\u3002\n\u4eca\u56de\u306f\u30ea\u30af\u30a8\u30b9\u30c8\u3055\u308c\u305f\u30c6\u30ad\u30b9\u30c8\u5f62\u5f0f\u306eHTML\u3092\u8fd4\u3059\u3060\u3051\u306e\u30b5\u30fc\u30d0\u3092\u5b9f\u88c5\u3057\u307e\u3059\u3002\n\u30d6\u30e9\u30a6\u30b6\u304b\u3089http://127.0.0.1:5000\u3068\u30a2\u30af\u30bb\u30b9\u3059\u308b\u3068\u7528\u610f\u3055\u308c\u305f\u30c6\u30ad\u30b9\u30c8\u306eHTML\u30d5\u30a1\u30a4\u30eb\u3092\u30d1\u30fc\u30b9\u3057\u3066Hello, world!\u3068\u3060\u3051\u51fa\u529b\u3059\u308b\u4ee5\u4e0b\u306e\u3088\u3046\u306a\u753b\u9762\u304c\u8868\u793a\u3055\u308c\u308b\u30b5\u30fc\u30d0\u3068\u306a\u308a\u307e\u3059\u3002\n\n\n\u4e8b\u524d\u77e5\u8b58\n\nHTTP\nHTTP\u306b\u306f\u3053\u308c\u307e\u3067\u4ee5\u4e0b\u306e\u3088\u3046\u306a\u30d0\u30fc\u30b8\u30e7\u30f3\u304c\u5b58\u5728\u3057\u3066\u3044\u307e\u3059\u3002\n\nHTTP 0.9\nHTTP 1.0\nHTTP 1.1\nHTTP 2\n\n\u6700\u8fd1\u3067\u306fHTTP2\u306e\u666e\u53ca\u304c\u9032\u3093\u3066\u3044\u3063\u3066\u3044\u307e\u3059\u304c\u3001\u73fe\u5728\u306fHTTP 1.1\u304c\u5e83\u304f\u4f7f\u308f\u308c\u3066\u3044\u307e\u3059\u3002\n\n\u4ed5\u7d44\u307f\nWeb\u3067\u306f\u3001\u30af\u30e9\u30a4\u30a2\u30f3\u30c8/\u30b5\u30fc\u30d0\u306e\u30a2\u30fc\u30ad\u30c6\u30af\u30c1\u30e3\u3092\u53d6\u3063\u3066\u304a\u308a\u3001\u30af\u30e9\u30a4\u30a2\u30f3\u30c8\u304c\u30ea\u30af\u30a8\u30b9\u30c8\u3092\u9001\u308a\u3001\u30b5\u30fc\u30d0\u304c\u30ec\u30b9\u30dd\u30f3\u30b9\u3092\u8fd4\u3059\u3068\u3044\u3046\u4ed5\u7d44\u307f\u3068\u306a\u3063\u3066\u3044\u307e\u3059\u3002\n\u4f8b\u3048\u3070\u3001Chrome\u304b\u3089google.com\u3078\u30a2\u30af\u30bb\u30b9\u3059\u308b\u3068\u304d\u3001\u30d6\u30e9\u30a6\u30b6\u306f\u4ee5\u4e0b\u306e\u3088\u3046\u306a\u30ea\u30af\u30a8\u30b9\u30c8\u3092\u30b5\u30fc\u30d0\u306b\u5bfe\u3057\u3066\u9001\u308a\u307e\u3059\u3002\nGET / HTTP/1.1\naccept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8\naccept-encoding: gzip, deflate, sdch, br\naccept-language: ja-JP,ja;q=0.8,en-US;q=0.6,en;q=0.4\ncookie: [1057 bytes were stripped]\nupgrade-insecure-requests: 1\nuser-agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36\nx-client-data: xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\n\n\u30b5\u30fc\u30d0\u304b\u3089\u4ee5\u4e0b\u306e\u3088\u3046\u306a\u30ec\u30b9\u30dd\u30f3\u30b9\u304c\u8fd4\u3055\u308c\u308b\u3002\u30ec\u30b9\u30dd\u30f3\u30b9\u3092\u53d7\u3051\u53d6\u3063\u305f\u30af\u30e9\u30a4\u30a2\u30f3\u30c8\u306f\u30d1\u30fc\u30b9\u3057\u305f\u7d50\u679c\u3092\u30ec\u30f3\u30c0\u30ea\u30f3\u30b0\u3057\u3066\u7d50\u679c\u3092\u51fa\u529b\u3057\u307e\u3059\u3002\nHTTP/1.1 200\nstatus: 200\ndate: Sat, 18 Feb 2017 17:48:01 GMT\nexpires: -1\ncache-control: private, max-age=0\ncontent-type: text/html; charset=UTF-8\ncontent-encoding: gzip\nserver: gws\nx-xss-protection: 1; mode=block\nx-frame-options: SAMEORIGIN\nalt-svc: quic=\":443\"; ma=2592000; v=\"35,34\"\n\n\n\u6d41\u308c\n\n\u30af\u30e9\u30a4\u30a2\u30f3\u30c8\n\n\u30ea\u30af\u30a8\u30b9\u30c8\u30e1\u30c3\u30bb\u30fc\u30b8\u306e\u4f5c\u6210\u30fb\u9001\u4fe1\n\u30ec\u30b9\u30dd\u30f3\u30b9\u306e\u5f85\u6a5f\n\u30ec\u30b9\u30dd\u30f3\u30b9\u30e1\u30c3\u30bb\u30fc\u30b8\u306e\u53d7\u4fe1\u30fb\u89e3\u6790\u30fb\u51e6\u7406\n\n\n\u30b5\u30fc\u30d0\n\n\u30ea\u30af\u30a8\u30b9\u30c8\u306e\u5f85\u6a5f\n\u30ea\u30af\u30a8\u30b9\u30c8\u30e1\u30c3\u30bb\u30fc\u30b8\u306e\u5f85\u6a5f\u30fb\u89e3\u6790\n\u89e3\u6790\u7d50\u679c\u3092\u5143\u306b\u5404\u30a2\u30d7\u30ea\u30b1\u30fc\u30b7\u30e7\u30f3\u306b\u3088\u308b\u51e6\u7406\u3068\u7d50\u679c\u306e\u53d6\u5f97\n\u30ec\u30b9\u30dd\u30f3\u30b9\u30e1\u30c3\u30bb\u30fc\u30b8\u306e\u69cb\u7bc9\u30fb\u9001\u4fe1\n\n\nHTTP\u30e1\u30c3\u30bb\u30fc\u30b8\nHTTP\u3067\u306f\u4ee5\u4e0b\u306e\u3088\u3046\u306a\u30ea\u30af\u30a8\u30b9\u30c8\u3068\u30ec\u30b9\u30dd\u30f3\u30b9\u3067\u306e\u30e1\u30c3\u30bb\u30fc\u30b8\u306b\u3088\u308a\u30b9\u30c6\u30fc\u30c8\u30ec\u30b9\u3067\u30b7\u30f3\u30d7\u30eb\u306a\u901a\u4fe1\u3092\u884c\u3063\u3066\u3044\u307e\u3059\u3002\n\u30e1\u30c3\u30bb\u30fc\u30b8\u306fRFC7230\u4e2d\u3067\u306f\u4ee5\u4e0b\u306e\u3088\u3046\u306b\u5b9a\u7fa9\u3055\u308c\u3066\u3044\u307e\u3059\u3002\n HTTP-message   = start-line\n                      *( header-field CRLF )\n                      CRLF\n                      [ message-body ]\n\nstart-line     = request-line / status-line\nheader-field   = field-name \":\" OWS field-value OWS\nmessage-body = *OCTET\n\u3053\u308c\u306f\u30ea\u30af\u30a8\u30b9\u30c8\u3001\u30ec\u30b9\u30dd\u30f3\u30b9\u3067\u4ee5\u4e0b\u306e\u3088\u3046\u306b\u7c21\u5358\u306b\u8868\u3055\u308c\u307e\u3059\u3002\n\n\u30ea\u30af\u30a8\u30b9\u30c8\u30e1\u30c3\u30bb\u30fc\u30b8\n\n\u30ea\u30af\u30a8\u30b9\u30c8\u30e9\u30a4\u30f3\n\u30d8\u30c3\u30c0\n\u30dc\u30c7\u30a3\n\n\n\u30ec\u30b9\u30dd\u30f3\u30b9\u30e1\u30c3\u30bb\u30fc\u30b8\n\n\u30b9\u30c6\u30fc\u30bf\u30b9\u30e9\u30a4\u30f3\n\u30d8\u30c3\u30c0\n\u30dc\u30c7\u30a3\n\n\n\u30ea\u30af\u30a8\u30b9\u30c8\u30e9\u30a4\u30f3/\u30b9\u30c6\u30fc\u30bf\u30b9\u30e9\u30a4\u30f3\n\u5148\u7a0b\u306eChrome\u304b\u3089\u30a2\u30af\u30bb\u30b9\u3057\u305f\u969b\u306b\u9001\u3089\u308c\u305f\u30ea\u30af\u30a8\u30b9\u30c8\u4e2d\u306e1\u884c\u76ee\u306e\nGET / HTTP/1.1\u304c\u30b9\u30c6\u30fc\u30bf\u30b9\u30e9\u30a4\u30f3\u3068\u306a\u308a\u307e\u3059\u3002\n\u4e00\u65b9\u3067\u3001\u30b5\u30fc\u30d0\u304b\u3089\u9001\u3089\u308c\u3066\u304d\u305f\u30ec\u30b9\u30dd\u30f3\u30b9\u4e2d\u306e1\u884c\u76ee\u306e\nHTTP/1.1 200\u304c\u30b9\u30c6\u30fc\u30bf\u30b9\u30e9\u30a4\u30f3\u3068\u306a\u308a\u307e\u3059\u3002\n\n\u30ea\u30af\u30a8\u30b9\u30c8\u30e9\u30a4\u30f3\nrequest-line   = method SP request-target SP HTTP-version CRLF\n\u4e0a\u8a18\u306e\u3088\u3046\u306b\u5b9a\u7fa9\u3055\u308c\u308b\u3002method\u306fHTTP\u30e1\u30bd\u30c3\u30c9\u3002request-target\u306f\u30ea\u30af\u30a8\u30b9\u30c8\u3059\u308b\u30ea\u30bd\u30fc\u30b9\u3002HTTP-version\u306fHTTP\u306e\u30d0\u30fc\u30b8\u30e7\u30f3\u3092\u6307\u5b9a\u3059\u308b\u3002SP\u306f\u30b9\u30da\u30fc\u30b9\u3067\u3001CRLF\u306f\u6539\u884c\u3092\u3059\u308b\u3002\n\n\u30b9\u30c6\u30fc\u30bf\u30b9\u30e9\u30a4\u30f3\nstatus-line = HTTP-version SP status-code SP reason-phrase CRLF\n\u4e0a\u8a18\u306e\u3088\u3046\u306b\u5b9a\u7fa9\u3055\u308c\u308b\u3002HTTP-version\u306fHTTP\u306e\u30d0\u30fc\u30b8\u30e7\u30f3\u3002status-code\u306f\u30b9\u30c6\u30fc\u30bf\u30b9\u30b3\u30fc\u30c9\u3002reason-phrease\u306f\u30b9\u30c6\u30fc\u30bf\u30b9\u30b3\u30fc\u30c9\u306b\u5bfe\u5fdc\u3059\u308b\u30c7\u30a3\u30b9\u30af\u30ea\u30d7\u30b7\u30e7\u30f3\u306b\u5bfe\u5fdc\u3059\u308b\u3002\n\nHTTP\u30e1\u30bd\u30c3\u30c9\nHTTP 1.1\u306b\u306f\u4ee5\u4e0b\u306e\u30e1\u30bd\u30c3\u30c9\u304c\u5b9a\u7fa9\u3055\u308c\u3066\u3044\u307e\u3059\u3002\n\nOPTIONS\nGET\nHEAD\nPOST\nPUT\nDELETE\nTRACE\nCONNECT\nPATCH\n\n\n\u30b9\u30c6\u30fc\u30bf\u30b9\u30b3\u30fc\u30c9\n\n\u5206\u985e\n\n1xx\n\n\n\u51e6\u7406\u4e2d\n\n\n2xx\n\n\n\u6210\u529f\n\n\n3xx\n\n\n\u30ea\u30c0\u30a4\u30ec\u30af\u30c8\n\n\n4xx\n\n\n\u30af\u30e9\u30a4\u30a2\u30f3\u30c8\u30a8\u30e9\u30fc\n\n\n5xx\n\n\n\u30b5\u30fc\u30d0\u30a8\u30e9\u30fc\n\n\n\n\u4ee5\u4e0b\u306e\u3088\u304f\u7528\u3044\u3089\u308c\u308b\u30b9\u30c6\u30fc\u30bf\u30b9\u30b3\u30fc\u30c9\u3092\u3044\u304f\u3064\u304b\u4e0a\u3052\u3066\u307f\u307e\u3059\u3002\n\n200 OK\n302 Found\n400 Bad Request\n401 Unauthorized\n403 Forbidden\n404 Not Found\n500 Internal Server Error\n502 Bad Gateway\n503 Service Unavailable\n504 Gateway Timeout\n\n\u6b8b\u308a\u306e\u30b9\u30c6\u30fc\u30bf\u30b9\u30b3\u30fc\u30c9\u306eAppendix\u3092\u53c2\u7167\u3002\n\nHTTP\u30d8\u30c3\u30c0\nHTTP\u30d8\u30c3\u30c0\u306b\u306f\u30dc\u30c7\u30a3\u306b\u5bfe\u3059\u308b\u30e1\u30bf\u30c7\u30fc\u30bf\u3092\u5b9a\u7fa9\u3057\u307e\u3059\u3002\u4f8b\u3048\u3070\u30ea\u30af\u30a8\u30b9\u30c8\u3067\u306f\u4ee5\u4e0b\u306e\u3088\u3046\u306a\u8907\u6570\u306e\u30e1\u30bf\u30c7\u30fc\u30bf\u304b\u3089HTTP\u30d8\u30c3\u30c0\u3092\u69cb\u6210\u3057\u307e\u3059\u3002\n\nHost\nUser-Agent\nAccept\nAccept-Language\nAccept-Encoding\nAccept-Charset\nKeep-Alive\nConnection\n\nHTTP\u30d8\u30c3\u30c0\u306f\u3001\u30ea\u30af\u30a8\u30b9\u30c8\u306f\u3001\u30ea\u30af\u30a8\u30b9\u30c8\u30d8\u30c3\u30c0\u30fc\u30d5\u30a3\u30fc\u30eb\u30c9\u3001\u6c4e\u7528\u30d8\u30c3\u30c0\u30fc\u30d5\u30a3\u30fc\u30eb\u30c9\u3001\u30a8\u30f3\u30c6\u30a3\u30c6\u30a3\u30d8\u30c3\u30c0\u30fc\u30d5\u30a3\u30fc\u30eb\u30c9\u304b\u3089\u3001\u30ec\u30b9\u30dd\u30f3\u30b9\u306f\u30ec\u30b9\u30dd\u30f3\u30b9\u30d8\u30c3\u30c0\u30fc\u30d5\u30a3\u30fc\u30eb\u30c9\u3001\u6c4e\u7528\u30d8\u30c3\u30c0\u30fc\u30d5\u30a3\u30fc\u30eb\u30c9\u3001\u30a8\u30f3\u30c6\u30a3\u30c6\u30a3\u30d8\u30c3\u30c0\u30fc\u30d5\u30a3\u30fc\u30eb\u30c9\u304b\u3089\u6210\u308a\u307e\u3059\u3002\n\u6b8b\u308a\u306e\u30d8\u30c3\u30c0\u306fAppendix\u3092\u53c2\u7167\u3002\n\nSocket\u901a\u4fe1\n\u30b5\u30fc\u30d0\u5074\u3067\u4f7f\u7528\u3059\u308b\u4e3b\u306aSocket\u901a\u4fe1\u306e\u95a2\u6570\u3068\u6d41\u308c\u306f\u4ee5\u4e0b\u306e\u901a\u308a\u3068\u306a\u308a\u307e\u3059\u3002\n\n1. socket()\n\u30bd\u30b1\u30c3\u30c8\u751f\u6210\n\n2. bind()\n\u30bd\u30b1\u30c3\u30c8\u767b\u9332\n\n3.listen()\n\u30bd\u30b1\u30c3\u30c8\u63a5\u7d9a\u6e96\u5099\n\n4.accept()\n\u30bd\u30b1\u30c3\u30c8\u63a5\u7d9a\u5f85\u6a5f\n\n5.recv()/send()\n\u30d1\u30b1\u30c3\u30c8\u306e\u9001\u53d7\u4fe1\n\n6.close()\n\u30bd\u30b1\u30c3\u30c8\u5207\u65ad  \n\n\u5b9f\u88c5\nint listenfd = socket(AF_INET, SOCK_STREAM, 0);\nif(listenfd == -1) {\n    std::cout << \"socket() failed.\" << std::endl;\n    exit(1);\n}\n\nint optval = 1;\nif(setsockopt(listenfd, SOL_SOCKET, SO_REUSEADDR, &optval, sizeof(optval)) == -1) {\n    std::cout << \"setsockopt() failed.\" << std::endl;\n    close(listenfd);\n    return -1;\n}\n\nint port = 5000;\nstruct sockaddr_in serv_addr;\n\nmemset(&serv_addr, 0, sizeof(serv_addr));\n\nserv_addr.sin_family = AF_INET;\nserv_addr.sin_addr.s_addr = htonl(INADDR_ANY);\nserv_addr.sin_port = htons(port);\n\n\nif(bind(listenfd, (struct sockaddr*)&serv_addr, sizeof(serv_addr)) == -1) {\n    std::cout << \"bind() failed.(\" << errno << \")\" << std::endl;\n    close(listenfd);\n    return -1;\n}\n\nif(listen(listenfd, SOMAXCONN) == -1) {\n    std::cout << \"listen() failed.\" << std::endl;\n    close(this->listenfd);\n    return -1;\n}\n\n\u30bd\u30b1\u30c3\u30c8\u63a5\u7d9a\u5f85\u6a5f\u304b\u3089\u306f\u30eb\u30fc\u30d7\u5185\u3067\u51e6\u7406\u3059\u308b\u3002\nint accfd = accept(sock->get_listenfd(), (struct sockaddr*)NULL, NULL);\n\nif(accfd == -1) {\n    std::cout << \"No acceptance\" << std::endl;\n}\n\nchar buf[BUF_SIZE];\nmemset(buf, 0, sizeof(buf));\nstd::string recv_str = \"\";\nssize_t read_size = 0;\n\nread_size = recv(accfd, buf, sizeof(buf)-1, 0);\nif(read_size == -1) {\n    std::cout << \"ERROR: \" << errno << std::endl;\n    close(accfd);\n    accfd = -1;\n    break;\n}\nif(read_size > 0) {\n    recv_str.append(buf);\n}\n\nif(write(accfd, server_response.c_str(), server_response.length()) == -1){\n    std::cout << \"write() failed.\" << std::endl;\n}\n\n\nHTTP\u30b5\u30fc\u30d0\u3092C++\u306b\u3088\u308b\u30d5\u30eb\u30b9\u30af\u30e9\u30c3\u30c1\u3067\u5b9f\u88c5\n\u4e0a\u8a18\u306e\u77e5\u8b58\u3092\u5143\u306bC++\u3067\u7c21\u6613\u306aHTTP\u30b5\u30fc\u30d0\u3092\u5b9f\u88c5\u3057\u3066\u7406\u89e3\u3092\u6df1\u3081\u3066\u307f\u307e\u3057\u3087\u3046\u3002\n\u305d\u306e\u5f8c\u3001\u540c\u6642\u30a2\u30af\u30bb\u30b9\u6570\u3092\u5897\u3084\u3057\u3066\u3082\u634c\u3051\u308b\u5b9f\u88c5\u3082\u884c\u3044\u307e\u3059\u3002\n(\u5b9f\u88c5\u306f\u6700\u4f4e\u9650\u306e\u52d5\u4f5c\u78ba\u8a8d\u306e\u305f\u3081\u306e\u3082\u306e\u3067\u8a2d\u8a08\u306a\u3069\u7d30\u304b\u3044\u70b9\u306f\u5bb9\u8d66\u304f\u3060\u3055\u3044^^;)\n\n\u5b9f\u88c5\u306e\u6d41\u308c\n1.\u521d\u671f\u5316\n2.\u30ea\u30af\u30a8\u30b9\u30c8\u304b\u3089\u30d8\u30c3\u30c0\u30fc\u90e8\u5206\u3092\u8aad\u307f\u8fbc\u3080\n3.\u30ea\u30af\u30a8\u30b9\u30c8\u3092\u30d1\u30fc\u30b9\u3057\u3066\u30ea\u30bd\u30fc\u30b9\u306e\u30d1\u30b9\u3092\u53d6\u5f97\u3059\u308b\n4.\u53d6\u5f97\u3057\u305f\u30d1\u30b9\u306e\u30d5\u30a1\u30a4\u30eb\u306e\u5185\u5bb9\u3092\u53d6\u5f97\u3059\u308b\n5.HTTP\u30ec\u30b9\u30dd\u30f3\u30b9\u306e\u30e1\u30c3\u30bb\u30fc\u30b8\u3092\u4f5c\u6210\u3059\u308b\n6.\u30bd\u30b1\u30c3\u30c8\u306b\u30ec\u30b9\u30dd\u30f3\u30b9\u3092\u66f8\u304d\u8fbc\u3080\n7.\u4f7f\u3044\u7d42\u308f\u3063\u305f\u30d5\u30a1\u30a4\u30eb\u306e\u30af\u30ed\u30fc\u30ba\n\n1.\u521d\u671f\u5316\n\u59cb\u3081\u306b\u5fc5\u8981\u306a\u5909\u6570\u306e\u5ba3\u8a00\u3068Socket\u901a\u4fe1\u306e\u6e96\u5099\u3092\u884c\u3044\u307e\u3059\u3002\nstd::string executive_file = HTML_FILE;\nSocket *sock = new Socket(HTTP1_PORT);\nsock->set_socket();\n\nint body_length = 0;\nint is_file_exist;\n\nint accfd = -1;\n\n\u4ee5\u964d\u3001Socket\u901a\u4fe1\u306eClose\u307e\u3067\u306fwhile(1){}\u306e\u30eb\u30fc\u30d7\u5185\u3067\u306e\u51e6\u7406\u3068\u306a\u308a\u307e\u3059\u3002\nwhile(1) {\n    accfd = accept(sock->get_listenfd(), (struct sockaddr*)NULL, NULL);\n\n    //\u521d\u671f\u5316\n    if(accfd == -1) {\n        continue;\n    }\n    char buf[BUF_SIZE];\n    memset(buf, 0, sizeof(buf));\n    std::string recv_str = \"\";\n    ssize_t read_size = 0;\n}\n\n\u5b9a\u6570\u3068Socket\u901a\u4fe1\u306e\u6e96\u5099\u306e\u969b\u306b\u5229\u7528\u3057\u305f\u30af\u30e9\u30b9\u306e\u5b9a\u7fa9\u306f\u4ee5\u4e0b\u306e\u901a\u308a\u3068\u306a\u308a\u307e\u3059\u3002\n\nconfigure.h\n#ifndef _CONFHET_H_\n#define _CONFHET_H_\n\nconst int BUF_SIZE = 1024;\nconst int HTTP1_PORT = 5000;\nconst int HTTP_VERSION = 1;\nconst std::string HTML_FILE = \"www\";\n\n#endif\n\n\n\nsocket.h\n#ifndef _SOCHET_H_\n#define _SOCHET_H_\n\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <string.h>\n#include <iostream>\n#include \"configure.h\"\n\nclass Socket {\n    int listenfd;\n    int port;\n    struct sockaddr_in serv_addr;\npublic:\n    explicit Socket(int port_): port{port_} {}\n    void set_listenfd();\n    void set_sockaddr_in();\n    int set_socket();\n\n    int get_listenfd() const { return this->listenfd; }\n};\n\n#endif\n\n\n\nsocket.cpp\n#include \"socket.h\"\n\nvoid Socket::set_listenfd() {\n    this->listenfd = socket(AF_INET, SOCK_STREAM, 0);\n    if(this->listenfd == -1) {\n        std::cout << \"socket() failed.\" << std::endl;\n        exit(1);\n    }\n}\n\nvoid Socket::set_sockaddr_in() {\n    memset(&this->serv_addr, 0, sizeof(this->serv_addr));\n\n    this->serv_addr.sin_family = AF_INET;\n    this->serv_addr.sin_addr.s_addr = htonl(INADDR_ANY);\n    this->serv_addr.sin_port = htons(this->port);\n\n}\n\nint Socket::set_socket() {\n    Socket::set_listenfd();\n    int optval = 1;\n    if(setsockopt(listenfd, SOL_SOCKET, SO_REUSEADDR, &optval, sizeof(optval)) == -1) {\n        std::cout << \"setsockopt() failed.\" << std::endl;\n        close(listenfd);\n        return -1;\n    }\n\n    Socket::set_sockaddr_in();\n    if(bind(this->listenfd, (struct sockaddr*)&this->serv_addr, sizeof(this->serv_addr)) == -1) {\n        std::cout << \"bind() failed.(\" << errno << \")\" << std::endl;\n        close(this->listenfd);\n        return -1;\n    }\n\n    if(listen(this->listenfd, SOMAXCONN) == -1) {\n        std::cout << \"listen() failed.\" << std::endl;\n        close(this->listenfd);\n        return -1;\n    }\n\n    return 0;\n}\n\n\n\n2.\u30ea\u30af\u30a8\u30b9\u30c8\u304b\u3089\u30d8\u30c3\u30c0\u30fc\u90e8\u5206\u3092\u8aad\u307f\u8fbc\u3080\n\u30eb\u30fc\u30d7\u5185\u3067\u5148\u7a0b\u306e\u51e6\u7406\u306e\u7d9a\u304d\u306b\u30d8\u30c3\u30c0\u30fc\u90e8\u5206\u3092\u6700\u5f8c\u307e\u3067\u8aad\u307f\u8fbc\u3080\u51e6\u7406\u3092\u8a18\u8ff0\u3057\u307e\u3059\u3002\n\u30d8\u30c3\u30c0\u30fc\u90e8\u5206\u306e\u6700\u5f8c\u306fCRLFCRLF\u3067\u7d42\u308f\u308b\u306e\u3067ASCII\u30b3\u30fc\u30c9\u3067\u3053\u308c\u306b\u76f8\u5f53\u3059\u308b\u6587\u5b57\u5217\u307e\u3067\u8aad\u307f\u8fbc\u3080\u3002\ndo {\n    read_size = recv(accfd, buf, sizeof(buf)-1, 0);\n    if(read_size == -1) {\n        std::cout << \"read() failed.\" << std::endl;\n        std::cout << \"ERROR: \" << errno << std::endl;\n        close(accfd);\n        accfd = -1;\n        break;\n    }\n    if(read_size > 0) {\n        recv_str.append(buf);\n    }\n    if( (recv_str[recv_str.length()-4] == 0x0d) &&\n    (recv_str[recv_str.length()-3] == 0x0a) &&\n    (recv_str[recv_str.length()-2] == 0x0d) &&\n    (recv_str[recv_str.length()-1] == 0x0a)\n    ){\n        break;\n    }\n} while (read_size > 0); \n\n\n3.\u30ea\u30af\u30a8\u30b9\u30c8\u3092\u30d1\u30fc\u30b9\u3057\u3066\u30ea\u30bd\u30fc\u30b9\u306e\u30d1\u30b9\u3092\u53d6\u5f97\u3059\u308b\nstd::string path = \"\", path_string = \"\";\nstd::string exe = executive_file;\nstd::size_t pos = exe.rfind('/');\nif (pos != std::string::npos) {\n    exe = exe.substr(pos + 1);\n}\npath_string.clear();\npath = HTTP1_Parser::get_requestline_path(buf);\npath_string = HTTP1_Parser::argv_path_analyzer(path, executive_file.c_str(), exe.c_str());\nstd::cout << \"path_string : \" << path_string << std::endl;\n\n\u4e0a\u8a18\u3067\u4f7f\u7528\u3057\u305f\u30d8\u30c3\u30c0\u30fc\u306e\u30d1\u30fc\u30b5\u30af\u30e9\u30b9\u306e\u5b9a\u7fa9\u306f\u4ee5\u4e0b\u306e\u901a\u308a\u3068\u306a\u308a\u307e\u3059\u3002\n\nhttp1parser.h\n#ifndef _HTTP1_PARSER_H_\n#define _HTTP1_PARSER_H_\n\n#include <string>\n#include <cstring>\n#include <unistd.h>\n#include \"configure.h\"\n\nclass HTTP1_Parser {\npublic:\n    static char *get_filename(const char *excutive_file);\n    static std::string argv_path_analyzer(std::string request_path, const char *path, const char *executive_file);\n    static std::string get_requestline_path(char _pbuf[BUF_SIZE]);\n};\n\n#endif\n\n\n\nhttp1parser.cpp\n#include \"http1parser.h\"\n#include <iostream>\nchar *HTTP1_Parser::get_filename(const char *excutive_file)\n{\n    int length = strlen(excutive_file);\n    static char buf[1024]={};\n    readlink( \"/proc/self/exe\", buf, sizeof(buf)-1 );\n    int buf_length = strlen(buf);\n    for(int i = 0; i <= length; i++){\n       buf[buf_length-i-1] = 0;\n    }\n    return buf;\n}\n\nstd::string HTTP1_Parser::argv_path_analyzer(std::string request_path, const char *path, const char *executive_file) {\n    std::string path_string;\n    if(strcmp(path,\"\") == 0){\n        if (request_path == std::string(\"/\")) {\n           path_string = std::string(HTTP1_Parser::get_filename(executive_file)) + std::string(\"/index.html\");\n        }\n        else {\n            int judge = request_path.rfind(\".\",20);\n            if (judge >= 0 ) {\n                path_string = std::string(HTTP1_Parser::get_filename(executive_file)) + request_path;\n            } else {\n                path_string = std::string(HTTP1_Parser::get_filename(executive_file)) + request_path + std::string(\"/index.html\");\n            }\n        }\n    }\n    else {\n         int judge = request_path.rfind(\".\",20);\n            if (judge >= 0 ) {\n                path_string = std::string(path) + request_path;\n            } else {\n                path_string = std::string(path) + request_path + std::string(\"/index.html\");\n            }\n\n    }\n    return path_string;\n}\n\nstd::string HTTP1_Parser::get_requestline_path(char _pbuf[BUF_SIZE]) {\n    int space_num = 0;\n    char path_buffer[32];\n    int current_point = 0;\n    std::string path_string;\n    for (int i = 0; i < BUF_SIZE; i++) {\n        if(space_num == 2){\n            path_buffer[current_point] = 0;\n            path_string = std::string(path_buffer);\n            return path_string;\n        }\n        if(space_num == 1){\n            if(_pbuf[i] != ' '){\n                path_buffer[current_point++] = _pbuf[i];\n            }\n        }\n        if(_pbuf[i] == ' '){\n            ++space_num;\n        }\n    }\n    return \"\";\n}\n\n\n\n4.\u53d6\u5f97\u3057\u305f\u30d1\u30b9\u306e\u30d5\u30a1\u30a4\u30eb\u306e\u5185\u5bb9\u3092\u53d6\u5f97\u3059\u308b\nstd::ifstream output_file(path_string.c_str());\nchar line[256];\nis_file_exist = output_file.fail();\nbody_length = 0;\nstd::vector<std::string> message_body;\nwhile (output_file.getline(line, 256-1)) {\n    body_length += strlen(line);\n    message_body.push_back(std::string(line));\n}\n\n\n5.HTTP\u30ec\u30b9\u30dd\u30f3\u30b9\u306e\u30e1\u30c3\u30bb\u30fc\u30b8\u3092\u4f5c\u6210\u3059\u308b\nstd::string server_response;\nstd::vector<std::string> header = HTTP1_Response::make_header(3, body_length, is_file_exist, path);\nserver_response = HTTP1_Response::make_response(header, message_body);\nstd::cout << server_response << std::endl;\n\n\nhttp1response.h\n#ifndef _HTTP1_RESHET_H_\n#define _HTTP1_RESHET_H_\n\n#include <string>\n#include <cstring>\n#include <vector>\n#include <fstream>\n#include \"configure.h\"\n\nclass HTTP1_Response {\npublic:\n    static std::string make_response(std::vector<std::string> &header, std::vector<std::string> &message_body);\n    static std::vector<std::string>& make_header(int version, int body_length, int is_file_exist, std::string path);\n    static void make_body (std::vector<std::string> &body_content, int &body_content_length, std::ifstream &output_file);\n};\n\n#endif\n\n\n\nhttp1response.cpp\n#include \"http1response.h\"\n#include \"http1header.h\"\n#include <iostream>\n#include <iterator>\n\nstd::string HTTP1_Response::make_response(std::vector<std::string> &header, std::vector<std::string> &message_body) {\n    std::string server_response;\n    int header_size = header.size();\n    int body_size = message_body.size();\n\n    for (int i = 0; i < header_size; i++){\n        server_response.append(header[i].c_str());\n    }\n\n    for (int i = 0; i < body_size; i++){\n        server_response.append(message_body[i].c_str());\n    }\n    return server_response;\n}\n\nstd::vector<std::string>& HTTP1_Response::make_header(int version, int body_length, int is_file_exist, std::string path) {\n    if (HTTP_VERSION == 1 && path != \"\") {\n        return HTTP1_Header::make_response302(path);\n    }\n    else if (HTTP_VERSION == 2) {\n        return HTTP1_Header::make_responseUpgrade();\n    }\n    else if (is_file_exist == 1) {\n        return HTTP1_Header::make_response404();\n    }\n    else {\n        return HTTP1_Header::make_response200(body_length);\n    }\n\n    static std::vector<std::string> response_header;\n    return response_header;\n}\n\nvoid HTTP1_Response::make_body(std::vector<std::string> &body_content, int &body_content_length, std::ifstream &output_file){\n\n    if (output_file.fail() != 0) {\n        std::cout << \"File was not found.\" << std::endl;\n        return;\n    }\n\n    char read_file_buf[BUF_SIZE];\n    output_file.read(read_file_buf, BUF_SIZE);\n    body_content.push_back(read_file_buf);\n    body_content_length = output_file.gcount();    \n}\n\n\n\n6.\u30bd\u30b1\u30c3\u30c8\u30c7\u30a3\u30b9\u30af\u30ea\u30d7\u30bf\u306b\u30ec\u30b9\u30dd\u30f3\u30b9\u5185\u5bb9\u3092\u66f8\u304d\u8fbc\u3080\nwhile(1){}\u306e\u30eb\u30fc\u30d7\u5185\u306e\u51e6\u7406\u3067\u306e\u6700\u5f8c\u306b\u30bd\u30b1\u30c3\u30c8\u306b\u30ec\u30b9\u30dd\u30f3\u30b9\u5185\u5bb9\u3092\u6e21\u3057\u307e\u3059\u3002\nif(send(accfd, server_response.c_str(), server_response.length(), 0) == -1){\n    std::cout << \"write() failed.\" << std::endl;\n}\n\n\u4e0a\u8a18\u306e\u51e6\u7406\u304c\u7d42\u308f\u3063\u305f\u3089\u307e\u305f\u30eb\u30fc\u30d7\u306e\u6700\u521d\u306b\u623b\u308a\u3001\u30ea\u30af\u30a8\u30b9\u30c8\u3092\u5f85\u6a5f\u3059\u308b\u3002\n\n7.\u4f7f\u3044\u7d42\u308f\u3063\u305f\u30d5\u30a1\u30a4\u30eb\u306e\u30af\u30ed\u30fc\u30ba\nwhile(1){}\u306e\u30eb\u30fc\u30d7\u304b\u3089\u51fa\u305f\u3042\u3068\u306b\u6700\u5f8c\u306bSocket\u306e\u30d5\u30a1\u30a4\u30eb\u30c7\u30a3\u30b9\u30af\u30ea\u30d7\u30bf\u3092Close\u3057\u3066\u304a\u304d\u307e\u3059\u3002\nclose(sock->get_listenfd());\n\n\u4ee5\u4e0a\u3067\u7d42\u4e86\u3067\u3059\u3002\u540c\u30c7\u30a3\u30ec\u30af\u30c8\u30ea\u306bwww\u3068\u3044\u3046\u30c7\u30a3\u30ec\u30af\u30c8\u30ea\u3092\u4f5c\u6210\u3057\u3001index.html\u3068\u3044\u3046\u30d5\u30a1\u30a4\u30eb\u540d\u3067\u4ee5\u4e0b\u306e\u5185\u5bb9\u3067\u4fdd\u5b58\u3057\u307e\u3059\u3002\n./server\u3092\u5b9f\u884c\u3057\u3066\u3001\u30d6\u30e9\u30a6\u30b6\u304b\u3089http://127.0.0.1:5000\u306b\u30a2\u30af\u30bb\u30b9\u3057\u3066\u6700\u521d\u306b\u8f09\u305b\u305f\u753b\u50cf\u306e\u3088\u3046\u306a\u753b\u9762\u306b\u306a\u308c\u3070OK\u3002\n\nindex.html\n<html>\n    <body>\n        Hello, world!\n    </body>\n</html>\n\n\n\u3053\u308c\u307e\u3067\u306e\u30d5\u30a1\u30a4\u30eb\u306e\u5168\u4f53\u306f\u6b21\u7ae0\u306b\u8f09\u305b\u307e\u3059\u3002\n\n\u5168\u4f53\n\u5148\u7a0b\u307e\u3067\u306e\u30d7\u30ed\u30b0\u30e9\u30e0\u5168\u4f53\u306f\u4ee5\u4e0b\u306e\u901a\u308a\u3068\u306a\u308a\u307e\u3059\u3002\nMakefile\u304c\u3042\u308b\u540c\u968e\u5c64\u306e\u30c7\u30a3\u30ec\u30af\u30c8\u30ea\u3067make\u3092\u5b9f\u884c\u3057\u3066./server\u3092\u5b9f\u884c\u3059\u308b\u3068\u30b5\u30fc\u30d0\u304c\u7acb\u3061\u4e0a\u304c\u308a\u307e\u3059\u3002\u3042\u3068\u306f\u3001www/\u4ee5\u4e0b\u306bindex.html\u3092\u7f6e\u3044\u3066\u3001\u30d6\u30e9\u30a6\u30b6\u304b\u3089http://127.0.0.1:5000\u306b\u30a2\u30af\u30bb\u30b9\u3059\u308b\u3068\u3001HTML\u306e\u5185\u5bb9\u304c\u8868\u793a\u3055\u308c\u308b\u3002\nCC = g++\nHTTP1 = server\nHTTP1_SOURCE = server.cpp socket.cpp http1header.cpp http1parser.cpp http1response.cpp\n\n.PHONY: all clean\n\nall: $(HTTP1)\n\n$(HTTP1): $(HTTP1_SOURCE)\n    g++ $(HTTP1_SOURCE) -o $(HTTP1) -g -std=c++11 -O0 -Wall\n\n\nclean:\n    rm -rf *.o $(HTTP1)\n\n\nconfigure.h\n#ifndef _CONFHET_H_\n#define _CONFHET_H_\n\nconst int BUF_SIZE = 1024;\nconst int HTTP1_PORT = 5000;\nconst int HTTP_VERSION = 1;\nconst std::string HTML_FILE = \"www\";\n\n#endif\n\n\n\nserver.cpp\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <errno.h>\n#include <string.h>\n#include <iostream>\n#include <algorithm>\n#include <errno.h>\n#include <sstream>\n#include <string>\n#include <iomanip>\n#include <fstream>\n#include <vector>\n#include <future>\n#include <thread>\n\n#include \"socket.h\"\n\n#include \"http1response.h\"\n#include \"http1header.h\"\n#include \"http1parser.h\"\n\n\n\nint http1()\n{\n    std::string executive_file = HTTP1_FILE;\n    Socket *sock = new Socket(HTTP1_PORT);\n    sock->set_socket();\n\n    int body_length = 0;\n    int is_file_exist;\n\n    int accfd = -1;\n\n    while(1) {\n        accfd = accept(sock->get_listenfd(), (struct sockaddr*)NULL, NULL);\n\n        //\u521d\u671f\u5316\n        if(accfd == -1) {\n            continue;\n        }\n        char buf[BUF_SIZE];\n        memset(buf, 0, sizeof(buf));\n        std::string recv_str = \"\";\n        ssize_t read_size = 0;\n\n        // \\r\\n\\r\\n\u304c\u6765\u308b\u307e\u3067\u30e1\u30c3\u30bb\u30fc\u30b8\u53d7\u4fe1\n        do {\n            read_size = recv(accfd, buf, sizeof(buf)-1, 0);\n            if(read_size == -1) {\n                std::cout << \"read() failed.\" << std::endl;\n                std::cout << \"ERROR: \" << errno << std::endl;\n                close(accfd);\n                accfd = -1;\n                break;\n            }\n            if(read_size > 0) {\n                recv_str.append(buf);\n            }\n            if( (recv_str[recv_str.length()-4] == 0x0d) &&\n            (recv_str[recv_str.length()-3] == 0x0a) &&\n            (recv_str[recv_str.length()-2] == 0x0d) &&\n            (recv_str[recv_str.length()-1] == 0x0a)\n            ){\n                break;\n            }\n        } while (read_size > 0); \n\n        //\u30ea\u30af\u30a8\u30b9\u30c8\u3055\u308c\u305f\u30d1\u30b9\u3092\u53d6\u5f97\u3059\u308b\n        std::string path = \"\", path_string = \"\";\n        std::string exe = executive_file;\n        std::size_t pos = exe.rfind('/');\n        if (pos != std::string::npos) {\n            exe = exe.substr(pos + 1);\n        }\n        path_string.clear();\n        path = HTTP1_Parser::get_requestline_path(buf);\n        path_string = HTTP1_Parser::argv_path_analyzer(path, executive_file.c_str(), exe.c_str());\n        std::cout << \"path_string : \" << path_string << std::endl;\n\n        //\u53d6\u5f97\u3057\u305f\u30d1\u30b9\u306e\u30d5\u30a1\u30a4\u30eb\u3092\u958b\u3044\u3066\u5185\u5bb9\u3092\u53d6\u5f97\u3059\u308b\n        std::ifstream output_file(path_string.c_str());\n        char line[256];\n        is_file_exist = output_file.fail();\n        body_length = 0;\n        std::vector<std::string> message_body;\n        while (output_file.getline(line, 256-1)) {\n            body_length += strlen(line);\n            message_body.push_back(std::string(line));\n        }\n\n        //HTTP\u30ec\u30b9\u30dd\u30f3\u30b9\u3092\u4f5c\u6210\u3059\u308b\n        std::string server_response;\n        std::vector<std::string> header = HTTP1_Response::make_header(3, body_length, is_file_exist, path);\n        server_response = HTTP1_Response::make_response(header, message_body);\n        std::cout << server_response << std::endl;\n\n        //\u30bd\u30b1\u30c3\u30c8\u30c7\u30a3\u30b9\u30af\u30ea\u30d7\u30bf\u306b\u30ec\u30b9\u30dd\u30f3\u30b9\u5185\u5bb9\u3092\u66f8\u304d\u8fbc\u3080\n        if(send(accfd, server_response.c_str(), server_response.length(), 0) == -1){\n            std::cout << \"write() failed.\" << std::endl;\n        }\n\n        //\u4f7f\u3044\u7d42\u308f\u3063\u305f\u30d5\u30a1\u30a4\u30eb\u306e\u30af\u30ed\u30fc\u30ba\n        output_file.close();\n        close(accfd);\n        accfd = -1;\n   }\n    close(sock->get_listenfd());\n    return 0;\n}\n\nint main(int argc, char *argv[])\n{\n    http1();\n    return 0;\n}\n\n\n\nsocket.h\n#ifndef _SOCHET_H_\n#define _SOCHET_H_\n\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <string.h>\n#include <iostream>\n#include \"configure.h\"\n\nclass Socket {\n    int listenfd;\n    int port;\n    struct sockaddr_in serv_addr;\npublic:\n    explicit Socket(int port_): port{port_} {}\n    void set_listenfd();\n    void set_sockaddr_in();\n    int set_socket();\n\n    int get_listenfd() const { return this->listenfd; }\n};\n\n#endif\n\n\n\nsocket.cpp\n#include \"socket.h\"\n\nvoid Socket::set_listenfd() {\n    this->listenfd = socket(AF_INET, SOCK_STREAM, 0);\n    if(this->listenfd == -1) {\n        std::cout << \"socket() failed.\" << std::endl;\n        exit(1);\n    }\n}\n\nvoid Socket::set_sockaddr_in() {\n    memset(&this->serv_addr, 0, sizeof(this->serv_addr));\n\n    this->serv_addr.sin_family = AF_INET;\n    this->serv_addr.sin_addr.s_addr = htonl(INADDR_ANY);\n    this->serv_addr.sin_port = htons(this->port);\n\n}\n\nint Socket::set_socket() {\n    Socket::set_listenfd();\n    int optval = 1;\n    if(setsockopt(listenfd, SOL_SOCKET, SO_REUSEADDR, &optval, sizeof(optval)) == -1) {\n        std::cout << \"setsockopt() failed.\" << std::endl;\n        close(listenfd);\n        return -1;\n    }\n\n    Socket::set_sockaddr_in();\n    if(bind(this->listenfd, (struct sockaddr*)&this->serv_addr, sizeof(this->serv_addr)) == -1) {\n        std::cout << \"bind() failed.(\" << errno << \")\" << std::endl;\n        close(this->listenfd);\n        return -1;\n    }\n\n    if(listen(this->listenfd, SOMAXCONN) == -1) {\n        std::cout << \"listen() failed.\" << std::endl;\n        close(this->listenfd);\n        return -1;\n    }\n\n    return 0;\n}\n\n\n\nhttp1parse.h\n#ifndef _HTTP1_PARSER_H_\n#define _HTTP1_PARSER_H_\n\n#include <string>\n#include <cstring>\n#include <unistd.h>\n#include \"configure.h\"\n\nclass HTTP1_Parser {\npublic:\n    static char *get_filename(const char *excutive_file);\n    static std::string argv_path_analyzer(std::string request_path, const char *path, const char *executive_file);\n    static std::string get_requestline_path(char _pbuf[BUF_SIZE]);\n};\n\n#endif\n\n\n\nhttp1parse.cpp\n#include \"http1parser.h\"\n#include <iostream>\nchar *HTTP1_Parser::get_filename(const char *excutive_file)\n{\n    int length = strlen(excutive_file);\n    static char buf[1024]={};\n    readlink( \"/proc/self/exe\", buf, sizeof(buf)-1 );\n    int buf_length = strlen(buf);\n    for(int i = 0; i <= length; i++){\n       buf[buf_length-i-1] = 0;\n    }\n    return buf;\n}\n\nstd::string HTTP1_Parser::argv_path_analyzer(std::string request_path, const char *path, const char *executive_file) {\n    std::string path_string;\n    if(strcmp(path,\"\") == 0){\n        if (request_path == std::string(\"/\")) {\n           path_string = std::string(HTTP1_Parser::get_filename(executive_file)) + std::string(\"index.html\");\n        }\n        else {\n            int judge = request_path.rfind(\".\",20);\n            if (judge >= 0 ) {\n                path_string = std::string(HTTP1_Parser::get_filename(executive_file)) + request_path;\n            } else {\n                path_string = std::string(HTTP1_Parser::get_filename(executive_file)) + request_path + std::string(\"index.html\");\n            }\n        }\n    }\n    else {\n         int judge = request_path.rfind(\".\",20);\n            if (judge >= 0 ) {\n                path_string = std::string(path) + request_path;\n            } else {\n                path_string = std::string(path) + request_path + std::string(\"index.html\");\n            }\n\n    }\n    return path_string;\n}\n\nstd::string HTTP1_Parser::get_requestline_path(char _pbuf[BUF_SIZE]) {\n    int space_num = 0;\n    char path_buffer[32];\n    int current_point = 0;\n    std::string path_string;\n    for (int i = 0; i < BUF_SIZE; i++) {\n        if(space_num == 2){\n            path_buffer[current_point] = 0;\n            path_string = std::string(path_buffer);\n            return path_string;\n        }\n        if(space_num == 1){\n            if(_pbuf[i] != ' '){\n                path_buffer[current_point++] = _pbuf[i];\n            }\n        }\n        if(_pbuf[i] == ' '){\n            ++space_num;\n        }\n    }\n    return \"\";\n}\n\n\n\nhttp1header.h\n#ifndef _HTTP1_HEAD_H_\n#define _HTTP1_HEAD_H_\n\n#include <vector>\n#include <string>\n#include <map>\n#include <sstream>\n\n\nclass HTTP1_Header {\npublic:\n    static std::vector<std::string>& make_response404();\n    static std::vector<std::string>& make_response200(int body_length);\n    static std::vector<std::string>& make_response302(std::string path);\n    static std::vector<std::string>& make_responseUpgrade();\n};\n\n#endif\n\n\n\nhttp1header.cpp\n#include \"http1header.h\"\n#include <iostream>\nstd::vector<std::string>& HTTP1_Header::make_response404() {\n    static std::vector<std::string> header ={ \n        \"HTTP/1.1 404 Not Found\\r\\n\", \n        \"Content-Type: text/html; charset=UTF-8\\r\\n\",\n        \"Connection: close\\r\\n\",\n        \"\\r\\n\",\n        \"<html><body><h1>404 Not found</h1><p>The requested URL was not found on this server.</p><hr><address>Original Server</address></body></html>\\r\\n\"\n    };\n\n    return header;\n}\n\nstd::vector<std::string>& HTTP1_Header::make_response200(int body_length) {\n    std::ostringstream oss;\n    oss << \"Content-Length: \" << body_length << \"\\r\\n\";\n\n    static std::vector<std::string> header = {\n        \"HTTP/1.1 200 OK\\r\\n\",\n        \"Content-Type: text/html; charset=UTF-8\\r\\n\",\n        oss.str(),\n        \"Connection: Keep-Alive\\r\\n\",\n        \"\\r\\n\"\n    };\n\n    return header;\n}\n\nstd::vector<std::string>& HTTP1_Header::make_response302(std::string path) {\n    std::ostringstream oss;\n    if (path != \"\") {\n        oss << \"Location: https://127.0.0.1:5001\" << path.c_str() << \"\\r\\n\";\n    }\n    else {\n        oss << \"Location: https://127.0.0.1:5001\\r\\n\";\n    }\n    static std::vector<std::string> header = {\n        \"HTTP/1.1 302 Found\\r\\n\",\n        oss.str(),\n        \"\\r\\n\"\n    };\n    return header;\n}\n\nstd::vector<std::string>& HTTP1_Header::make_responseUpgrade() {\n    static std::vector<std::string> header = {\n        \"HTTP/1.1 101 Switching Protocols\\r\\n\",\n        \"Connection: Upgrade\\r\\n\",\n        \"Upgrade: h2c\\r\\n\",\n        \"\\r\\n\"\n    };\n\n    return header;\n}\n\n\n\nhttp1response.h\n#ifndef _HTTP1_RESHET_H_\n#define _HTTP1_RESHET_H_\n\n#include <string>\n#include <cstring>\n#include <vector>\n#include <fstream>\n#include \"configure.h\"\n\nclass HTTP1_Response {\npublic:\n    static std::string make_response(std::vector<std::string> &header, std::vector<std::string> &message_body);\n    //static std::vector<std::string>& make_header(int version, int body_length, std::ifstream &output_file);\n    static std::vector<std::string>& make_header(int version, int body_length, int is_file_exist, std::string path);\n    static void make_body (std::vector<std::string> &body_content, int &body_content_length, std::ifstream &output_file);\n};\n\n#endif\n\n\n\nhttp1response.cpp\n#include \"http1response.h\"\n#include \"http1header.h\"\n#include <iostream>\n#include <iterator>\n\nstd::string HTTP1_Response::make_response(std::vector<std::string> &header, std::vector<std::string> &message_body) {\n    std::string server_response;\n    int header_size = header.size();\n    int body_size = message_body.size();\n\n    std::string tmp;\n\n    for (int i = 0; i < header_size; i++){\n        server_response.append(header[i].c_str());\n    }\n\n    for (int i = 0; i < body_size; i++){\n        server_response.append(message_body[i].c_str());\n    }\n    return server_response;\n}\n\nstd::vector<std::string>& HTTP1_Response::make_header(int version, int body_length, int is_file_exist, std::string path) {\n    if (HTTP_VERSION == 1 && path != \"\") {\n        return HTTP1_Header::make_response302(path);\n    }\n    else if (HTTP_VERSION == 2) {\n        return HTTP1_Header::make_responseUpgrade();\n    }\n    else if (is_file_exist == 1) {\n        return HTTP1_Header::make_response404();\n    }\n    else {\n        return HTTP1_Header::make_response200(body_length);\n    }\n\n    static std::vector<std::string> response_header;\n    return response_header;\n}\n\nvoid HTTP1_Response::make_body(std::vector<std::string> &body_content, int &body_content_length, std::ifstream &output_file){\n\n    if (output_file.fail() != 0) {\n        std::cout << \"File was not found.\" << std::endl;\n        return;\n    }\n\n    char read_file_buf[BUF_SIZE];\n    output_file.read(read_file_buf, BUF_SIZE);\n    body_content.push_back(read_file_buf);\n    body_content_length = output_file.gcount();    \n}\n\n\n\n\u540c\u6642\u30a2\u30af\u30bb\u30b9\u6570\u306e\u5897\u52a0\u306b\u5bfe\u5fdc\u3059\u308b\nint accfd = -1;\n\n\u3060\u3063\u305f\u3068\u3053\u308d\u3092\u4e0b\u306e\u3088\u3046\u306bint\u578b\u304b\u3089int\u578b\u306e\u914d\u5217\u306b\u4fee\u6b63\u3057\u307e\u3059\u3002\nconst int MAX_SESSION = 10;\n\nint accfd[MAX_SESSION];\nfor(int i=0; i < MAX_SESSION; i++){\n    accfd[i] = -1;\n}\n\n\u5148\u7a0b\u306b\u7d9a\u3051\u3066\u4ee5\u4e0b\u306e\u5ba3\u8a00\u3092\u3057\u307e\u3059\u3002\nfd_set fds;\n\nwhile(1){}\u306e\u30eb\u30fc\u30d7\u5185\u306b\u5165\u308a\u3001\u6700\u521d\u306b\u8907\u6570\u30bd\u30b1\u30c3\u30c8\u306e\u901a\u4fe1\u306e\u6e96\u5099\u3092\u3057\u3066\u304a\u304d\u307e\u3059\u3002\nFD_ZERO(&fds);\nFD_SET(sock->get_listenfd(), &fds);\nint width = sock->get_listenfd() + 1;\n\nfor (int i=0; i < MAX_SESSION; i++){\n    if(accfd[i] != -1){\n        FD_SET(accfd[i], &fds);\n        if(width < (accfd[i]+1)){\n            width = accfd[i]+1;\n        }\n    }\n}\nif(select(width, &fds, NULL,NULL, NULL) == -1) {\n    std::cout << \"select() failed.\" << std::endl;\n    break;\n}\n\nif(FD_ISSET(sock->get_listenfd(), &fds)){\n    int connfd = accept(sock->get_listenfd(), (struct sockaddr*)NULL, NULL);\n    bool limit_over = true;\n    for(int i = 0; i < MAX_SESSION; i++) {\n        if(accfd[i] == -1) {\n            accfd[i] = connfd;\n            limit_over = false;\n            break;\n        }\n    }\n    if(limit_over) {\n        close(connfd);\n        std::cout << \"over max connection.\" << std::endl;\n    }\n}\n\n\u5148\u7a0baccept()\u306e\u8fd4\u308a\u5024\u3092\u30c1\u30a7\u30c3\u30af\u3057\u3066\u4ee5\u4e0b\u306e\u3088\u3046\u306a\u8a18\u8ff0\u3067\u51e6\u7406\u3092\u7d9a\u3051\u3066\u3044\u307e\u3057\u305f\u3002\nif(accfd == -1) {\n    continue;\n}\nchar buf[BUF_SIZE];\nmemset(buf, 0, sizeof(buf));\n\n\u8907\u6570\u30bd\u30b1\u30c3\u30c8\u3067\u306e\u901a\u4fe1\u306e\u3068\u304d\u306f\u30bb\u30c3\u30b7\u30e7\u30f3\u6bce\u306b\u3053\u308c\u3089\u3092\u884c\u3046\u305f\u3081\u306b\u30bb\u30c3\u30b7\u30e7\u30f3\u306e\u6570\u3060\u3051\u30eb\u30fc\u30d7\u3092\u56de\u3057\u3066\u51e6\u7406\u3092\u3057\u307e\u3059\u3002\nfor( int i = 0; i < MAX_SESSION; i++) {\n    if(accfd[i] == -1) {\n        continue;\n    }\n    char buf[BUF_SIZE];\n    memset(buf, 0, sizeof(buf));\n    if(FD_ISSET(accfd[i], &fds)) {\n        std::string recv_str = \"\";\n        ssize_t read_size = 0;\n                    \ufe19\n                    \ufe19\n    }\n}\n\n\u4ee5\u4e0a\u3068\u306a\u308a\u307e\u3059\u3002\n\n\u5168\u4f53\n\u5148\u307b\u3069\u3068\u306fserver.cpp\u306e\u307f\u3092\u4fee\u6b63\u3057\u307e\u3059\u3002\n\nserver.cpp\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <errno.h>\n#include <string.h>\n#include <iostream>\n#include <algorithm>\n#include <errno.h>\n#include <sstream>\n#include <string>\n#include <iomanip>\n#include <fstream>\n#include <vector>\n#include <future>\n#include <thread>\n\n#include \"socket.h\"\n\n#include \"http1response.h\"\n#include \"http1header.h\"\n#include \"http1parser.h\"\n#include \"socket.h\"\n\n\n\nconst int MAX_SESSION = 10;\n\nint http1()\n{\n    std::string executive_file = HTTP1_FILE;\n    Socket *sock = new Socket(HTTP1_PORT);\n    sock->set_socket();\n\n    int body_length = 0;\n    int is_file_exist;\n\n    int accfd[MAX_SESSION];\n    for(int i=0; i < MAX_SESSION; i++){\n        accfd[i] = -1;\n    }\n    fd_set fds;\n\n    while(1) {\n        FD_ZERO(&fds);\n        FD_SET(sock->get_listenfd(), &fds);\n        int width = sock->get_listenfd() + 1;\n\n        for (int i=0; i < MAX_SESSION; i++){\n            if(accfd[i] != -1){\n                FD_SET(accfd[i], &fds);\n                if(width < (accfd[i]+1)){\n                    width = accfd[i]+1;\n                }\n            }\n        }\n        if(select(width, &fds, NULL,NULL, NULL) == -1) {\n            std::cout << \"select() failed.\" << std::endl;\n            break;\n        }\n\n        if(FD_ISSET(sock->get_listenfd(), &fds)){\n            int connfd = accept(sock->get_listenfd(), (struct sockaddr*)NULL, NULL);\n            bool limit_over = true;\n            for(int i = 0; i < MAX_SESSION; i++) {\n                if(accfd[i] == -1) {\n                    accfd[i] = connfd;\n                    limit_over = false;\n                    break;\n                }\n            }\n            if(limit_over) {\n                close(connfd);\n                std::cout << \"over max connection.\" << std::endl;\n            }\n        }\n\n        //Start reading message\n        for( int i = 0; i < MAX_SESSION; i++) {\n            if(accfd[i] == -1) {\n                continue;\n            }\n            char buf[BUF_SIZE];\n            memset(buf, 0, sizeof(buf));\n            if(FD_ISSET(accfd[i], &fds)) {\n                std::string recv_str = \"\";\n                ssize_t read_size = 0;\n\n                do {\n                    read_size = recv(accfd[i], buf, sizeof(buf)-1, 0);\n                    if(read_size == -1) {\n                        std::cout << \"read() failed.\" << std::endl;\n                        std::cout << \"ERROR: \" << errno << std::endl;\n                        close(accfd[i]);\n                        accfd[i] = -1;\n                        break;\n                    }\n                    if(read_size > 0) {\n                        recv_str.append(buf);\n                    }\n                    if( (recv_str[recv_str.length()-4] == 0x0d) &&\n                    (recv_str[recv_str.length()-3] == 0x0a) &&\n                    (recv_str[recv_str.length()-2] == 0x0d) &&\n                    (recv_str[recv_str.length()-1] == 0x0a)\n                    ){\n                        break;\n                    }\n                } while (read_size > 0); \n                std::string path = \"\", path_string = \"\";\n                std::string exe = executive_file;\n                std::size_t pos = exe.rfind('/');\n                if (pos != std::string::npos) {\n                    exe = exe.substr(pos + 1);\n                }\n                path_string.clear();\n                path = HTTP1_Parser::get_requestline_path(buf);\n                path_string = HTTP1_Parser::argv_path_analyzer(path, executive_file.c_str(), exe.c_str());\n                std::cout << \"path_string : \" << path_string << std::endl;\n                std::ifstream output_file(path_string.c_str());\n                char line[256];\n                is_file_exist = output_file.fail();\n                body_length = 0;\n                std::vector<std::string> message_body;\n                while (output_file.getline(line, 256-1)) {\n                    body_length += strlen(line);\n                    message_body.push_back(std::string(line));\n                }\n                recv_str.append(buf);\n                std::string server_response;\n                std::vector<std::string> header = HTTP1_Response::make_header(3, body_length, is_file_exist, path);\n                server_response = HTTP1_Response::make_response(header, message_body);\n                std::cout << server_response << std::endl;\n                if(send(accfd[i], server_response.c_str(), server_response.length(), 0) == -1){\n                    std::cout << \"write() failed.\" << std::endl;\n                }\n                output_file.close();\n                close(accfd[i]);\n                accfd[i] = -1;\n            }\n        }\n   }\n    close(sock->get_listenfd());\n    return 0;\n}\n\nint main(int argc, char *argv[])\n{\n    http1();\n    return 0;\n}\n\n\n\nHTTP/2\nHTTP/2\u306fSPDY\u3092\u30d9\u30fc\u30b9\u306b\u5f93\u6765\u306eHTTP/1.x\u3068\u4e92\u63db\u6027\u3092\u4fdd\u3061\u306a\u304c\u30891\u3064\u306e\u30b3\u30cd\u30af\u30b7\u30e7\u30f3\u4e0a\u3067\u8907\u6570\u306e\u30b9\u30c8\u30ea\u30fc\u30e0\u3092\u4f7f\u3046\u3053\u3068\u3084\u30d8\u30c3\u30c0\u306e\u30d0\u30a4\u30ca\u30ea\u8868\u73fe\u3084\u5727\u7e2e\u3001\u30ea\u30af\u30a8\u30b9\u30c8\u306e\u512a\u5148\u5ea6\u4ed8\u7b49\u3067\u52b9\u7387\u5316\u3092\u56f3\u3063\u305f\u3082\u306e\u3067\u3059\u3002\nHTTP/2\u3092\u4f7f\u3046\u304b\u306e\u78ba\u8a8d\u306f\u4ee5\u4e0b\u306e\u901a\u308a\u3068\u306a\u308a\u307e\u3059\u3002http\u30b9\u30ad\u30fc\u30e0\u3067HTTP/1.1\u304b\u3089HTTP/2\u3092\u4f7f\u7528\u3059\u308b\u306b\u306fUpgrade\u30d8\u30c3\u30c0\u30d5\u30a3\u30fc\u30eb\u3092\u4f7f\u7528\u3059\u308b\u304bHTTP Alternative Services\u3092\u4f7f\u7528\u3057\u307e\u3059\u3002\n\nTLS-NPN,TLS-ALPN\nUpgrade, Alt-Svc\n\u76f8\u624b\u304cHTTP/2\u3092\u3064\u304b\u3063\u3066\u3044\u308b\u3053\u3068\u3092\u524d\u63d0\u306b\u901a\u4fe1\n\n\nAppendix\n\n\u30b9\u30c6\u30fc\u30bf\u30b9\u30b3\u30fc\u30c9\n\n1xx\n\n100 Continue\n101 Switching Protocols\n\n\n2xx\n\n200 OK\n201 Created\n202 Accepted\n203 Non-Authoritative Information\n204 No Content\n205 Reset Content\n206 Partial Content\n\n\n3xx\n\n300 Multiple Choices\n301 Moved Permanently\n302 Found\n303 See Other\n304 Not Modified\n305 Use Proxy\n306 (Unused)\n307 Temporary Redirect\n308 Parmenent Redirect\n\n\n4xx\n\n400 Bad Request\n401 Unauthorized\n402 Payment Required\n403 Forbidden\n404 Not Found\n405 Method Not Allowed\n406 Not Acceptable\n407 Proxy Authentication Required\n408 Request Timeout\n409 Conflict\n410 Gone\n411 Length Required\n412 Precondition Failed\n413 Payment Too Large\n414 URI Too Long\n415 Unsupported Media Type\n416 Range Not Satisfiable\n417 Expectation Failed\n426 Upgrade Required\n428 Precondition Required\n429 Too Many Requests\n431 Request Header Fields Too Large\n\n\n5xx\n\n500 Internal Server Error\n501 Not Implemented\n502 Bad Gateway\n503 Service Unavailable\n504 Gateway Timeout\n505 HTTP Version Not Supported\n\n\nHTTP\u30d8\u30c3\u30c0\u30fc\n\nAccept\nAccept-Charset\nAccept-Encoding\nAccept-Language\nAccept-Ranges\nAge\nAllow\nAuthorization\nCache-Control\nConnection\nContent-Encoding\nContent-Language\nContent-Length\nContent-Location\nContent-Range\nContent-Type\nDate\nETag\nExpect\nExpires\nFrom\nHost\nIf-Match\nIf-Modified-Since\nIf-None-Match\nIf-Range\nIf-Unmodified-Since\nLocation\nMax-Forwards\nPragma\nProxy-Authenticate\nProxy-Authorization\nRange\nReferer\nRetry-After\nServer\nTE\nTrailer\nTransfer-Encoding\nUpgrade\nUser-Agent\nVary\nVia\nWarning\nWWW-Authenticate\n\n\n\u53c2\u8003\nftp://ftp.rfc-editor.org/in-notes/rfc2616.txt\nftp://ftp.rfc-editor.org/in-notes/rfc7230.txt\nftp://ftp.rfc-editor.org/in-notes/rfc7231.txt\nftp://ftp.rfc-editor.org/in-notes/rfc7232.txt\nftp://ftp.rfc-editor.org/in-notes/rfc7233.txt\nftp://ftp.rfc-editor.org/in-notes/rfc7234.txt\nftp://ftp.rfc-editor.org/in-notes/rfc7235.txt\nftp://ftp.rfc-editor.org/in-notes/rfc7236.txt\nftp://ftp.rfc-editor.org/in-notes/rfc7237.txt\nftp://ftp.rfc-editor.org/in-notes/rfc7238.txt\nftp://ftp.rfc-editor.org/in-notes/rfc7239.txt\nftp://ftp.rfc-editor.org/in-notes/rfc7540.txt\nftp://ftp.rfc-editor.org/in-notes/rfc7541.txt\nftp://ftp.rfc-editor.org/in-notes/rfc5789.txt\nhttps://tools.ietf.org/html/draft-nottingham-http-new-status-04\nhttp://www.asahi-net.or.jp/~ax2s-kmtn/ref/status.html\nhttp://d.hatena.ne.jp/s-kita/20080927/1222505067\nhttps://techblog.yahoo.co.jp/infrastructure/http2/ats_http2_pn/\nhttp://syucream.hatenablog.jp/entry/2014/12/20/160552\n\u524d\u534a\u3067HTTP\u306b\u3088\u308bWeb\u30b5\u30fc\u30d0\u306e\u52d5\u4f5c\u3092\u7406\u89e3\u3059\u308b\u305f\u3081\u306e\u57fa\u672c\u7684\u306a\u4e8b\u524d\u77e5\u8b58\u3092\u6574\u7406\u3057\u3066\u7406\u89e3\u3057\u307e\u3059\u3002\u305d\u3057\u3066\u3001\u5f8c\u534a\u306b\u305d\u308c\u3089\u306e\u77e5\u8b58\u3092\u5143\u306bC++\u306b\u3088\u308b\u7c21\u6613\u306aHTTP\u30b5\u30fc\u30d0\u3092\u30d5\u30eb\u30b9\u30af\u30e9\u30c3\u30c1\u3067\u5b9f\u88c5\u3057\u3066\u7406\u89e3\u3057\u307e\u3059\u3002\n\n\u4eca\u56de\u306f\u30ea\u30af\u30a8\u30b9\u30c8\u3055\u308c\u305f\u30c6\u30ad\u30b9\u30c8\u5f62\u5f0f\u306eHTML\u3092\u8fd4\u3059\u3060\u3051\u306e\u30b5\u30fc\u30d0\u3092\u5b9f\u88c5\u3057\u307e\u3059\u3002\n\n<!--\n`./server`\u3092\u5b9f\u884c\u3057\u305f\u72b6\u614b\u3067\n-->\n\u30d6\u30e9\u30a6\u30b6\u304b\u3089`http://127.0.0.1:5000`\u3068\u30a2\u30af\u30bb\u30b9\u3059\u308b\u3068\u7528\u610f\u3055\u308c\u305f\u30c6\u30ad\u30b9\u30c8\u306eHTML\u30d5\u30a1\u30a4\u30eb\u3092\u30d1\u30fc\u30b9\u3057\u3066`Hello, world!`\u3068\u3060\u3051\u51fa\u529b\u3059\u308b\u4ee5\u4e0b\u306e\u3088\u3046\u306a\u753b\u9762\u304c\u8868\u793a\u3055\u308c\u308b\u30b5\u30fc\u30d0\u3068\u306a\u308a\u307e\u3059\u3002\n\n![\u30b9\u30af\u30ea\u30fc\u30f3\u30b7\u30e7\u30c3\u30c8 2017-02-21 1.58.15.png](https://qiita-image-store.s3.amazonaws.com/0/81083/d1d597f4-ba40-1eee-3a32-6d030eef1d9b.png \"\u30b9\u30af\u30ea\u30fc\u30f3\u30b7\u30e7\u30c3\u30c8 2017-02-21 1.58.15.png\")\n\n# \u4e8b\u524d\u77e5\u8b58\n## HTTP\nHTTP\u306b\u306f\u3053\u308c\u307e\u3067\u4ee5\u4e0b\u306e\u3088\u3046\u306a\u30d0\u30fc\u30b8\u30e7\u30f3\u304c\u5b58\u5728\u3057\u3066\u3044\u307e\u3059\u3002\n\n- HTTP 0.9\n- HTTP 1.0\n- HTTP 1.1\n- HTTP 2\n\n\u6700\u8fd1\u3067\u306fHTTP2\u306e\u666e\u53ca\u304c\u9032\u3093\u3066\u3044\u3063\u3066\u3044\u307e\u3059\u304c\u3001\u73fe\u5728\u306fHTTP 1.1\u304c\u5e83\u304f\u4f7f\u308f\u308c\u3066\u3044\u307e\u3059\u3002\n\n### \u4ed5\u7d44\u307f\nWeb\u3067\u306f\u3001\u30af\u30e9\u30a4\u30a2\u30f3\u30c8/\u30b5\u30fc\u30d0\u306e\u30a2\u30fc\u30ad\u30c6\u30af\u30c1\u30e3\u3092\u53d6\u3063\u3066\u304a\u308a\u3001\u30af\u30e9\u30a4\u30a2\u30f3\u30c8\u304c\u30ea\u30af\u30a8\u30b9\u30c8\u3092\u9001\u308a\u3001\u30b5\u30fc\u30d0\u304c\u30ec\u30b9\u30dd\u30f3\u30b9\u3092\u8fd4\u3059\u3068\u3044\u3046\u4ed5\u7d44\u307f\u3068\u306a\u3063\u3066\u3044\u307e\u3059\u3002\n\n\u4f8b\u3048\u3070\u3001Chrome\u304b\u3089google.com\u3078\u30a2\u30af\u30bb\u30b9\u3059\u308b\u3068\u304d\u3001\u30d6\u30e9\u30a6\u30b6\u306f\u4ee5\u4e0b\u306e\u3088\u3046\u306a\u30ea\u30af\u30a8\u30b9\u30c8\u3092\u30b5\u30fc\u30d0\u306b\u5bfe\u3057\u3066\u9001\u308a\u307e\u3059\u3002\n\n```\nGET / HTTP/1.1\naccept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8\naccept-encoding: gzip, deflate, sdch, br\naccept-language: ja-JP,ja;q=0.8,en-US;q=0.6,en;q=0.4\ncookie: [1057 bytes were stripped]\nupgrade-insecure-requests: 1\nuser-agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36\nx-client-data: xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\n```\n\n\n\u30b5\u30fc\u30d0\u304b\u3089\u4ee5\u4e0b\u306e\u3088\u3046\u306a\u30ec\u30b9\u30dd\u30f3\u30b9\u304c\u8fd4\u3055\u308c\u308b\u3002\u30ec\u30b9\u30dd\u30f3\u30b9\u3092\u53d7\u3051\u53d6\u3063\u305f\u30af\u30e9\u30a4\u30a2\u30f3\u30c8\u306f\u30d1\u30fc\u30b9\u3057\u305f\u7d50\u679c\u3092\u30ec\u30f3\u30c0\u30ea\u30f3\u30b0\u3057\u3066\u7d50\u679c\u3092\u51fa\u529b\u3057\u307e\u3059\u3002\n\n```\nHTTP/1.1 200\nstatus: 200\ndate: Sat, 18 Feb 2017 17:48:01 GMT\nexpires: -1\ncache-control: private, max-age=0\ncontent-type: text/html; charset=UTF-8\ncontent-encoding: gzip\nserver: gws\nx-xss-protection: 1; mode=block\nx-frame-options: SAMEORIGIN\nalt-svc: quic=\":443\"; ma=2592000; v=\"35,34\"\n```\n\n<!--\n\n\u6c4e\u7528\u30d8\u30c3\u30c0\u30fc\n\n```\nRequest URL:https://www.google.com/\nRequest Method:GET\nStatus Code:302 \nRemote Address:216.58.197.228:443\n```\n\n\u30ea\u30af\u30a8\u30b9\u30c8\u30d8\u30c3\u30c0\u30fc\n\n\n```\n:authority:www.google.com\n:method:GET\n:path:/\n:scheme:https\naccept:text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8\naccept-encoding:gzip, deflate, sdch, br\naccept-language:ja-JP,ja;q=0.8,en-US;q=0.6,en;q=0.4\ncookie:GMAIL_RTT=1334; SID=xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx; HSID=xxxxxxxxxxxxxxxxx; SSID=Axzk-FBiIaQj_Euay; APISID=xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx; SAPISID=xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx; NID=xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\nupgrade-insecure-requests:1\nuser-agent:Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36\nx-client-data:xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\n```\n\n\n```\nalt-svc:quic=\":443\"; ma=2592000; v=\"35,34\"\ncache-control:private\ncontent-length:262\ncontent-type:text/html; charset=UTF-8\ndate:Sat, 18 Feb 2017 17:28:19 GMT\nlocation:https://www.google.co.jp/?gfe_rd=cr&ei=M4SoWPWOC6OL8QeRxbOgDg\nstatus:302\n```\n\n-->\n\n\n<!--\n\n```\nchrome://net-internals/#events\n```\n\n```\ntype:URL_REQUEST google.co.jp\n```\n\n-->\n\n### \u6d41\u308c\n#### \u30af\u30e9\u30a4\u30a2\u30f3\u30c8\n1. \u30ea\u30af\u30a8\u30b9\u30c8\u30e1\u30c3\u30bb\u30fc\u30b8\u306e\u4f5c\u6210\u30fb\u9001\u4fe1\n2. \u30ec\u30b9\u30dd\u30f3\u30b9\u306e\u5f85\u6a5f\n3. \u30ec\u30b9\u30dd\u30f3\u30b9\u30e1\u30c3\u30bb\u30fc\u30b8\u306e\u53d7\u4fe1\u30fb\u89e3\u6790\u30fb\u51e6\u7406\n\n#### \u30b5\u30fc\u30d0\n1. \u30ea\u30af\u30a8\u30b9\u30c8\u306e\u5f85\u6a5f\n2. \u30ea\u30af\u30a8\u30b9\u30c8\u30e1\u30c3\u30bb\u30fc\u30b8\u306e\u5f85\u6a5f\u30fb\u89e3\u6790\n3. \u89e3\u6790\u7d50\u679c\u3092\u5143\u306b\u5404\u30a2\u30d7\u30ea\u30b1\u30fc\u30b7\u30e7\u30f3\u306b\u3088\u308b\u51e6\u7406\u3068\u7d50\u679c\u306e\u53d6\u5f97\n4. \u30ec\u30b9\u30dd\u30f3\u30b9\u30e1\u30c3\u30bb\u30fc\u30b8\u306e\u69cb\u7bc9\u30fb\u9001\u4fe1\n\n### HTTP\u30e1\u30c3\u30bb\u30fc\u30b8\nHTTP\u3067\u306f\u4ee5\u4e0b\u306e\u3088\u3046\u306a\u30ea\u30af\u30a8\u30b9\u30c8\u3068\u30ec\u30b9\u30dd\u30f3\u30b9\u3067\u306e\u30e1\u30c3\u30bb\u30fc\u30b8\u306b\u3088\u308a\u30b9\u30c6\u30fc\u30c8\u30ec\u30b9\u3067\u30b7\u30f3\u30d7\u30eb\u306a\u901a\u4fe1\u3092\u884c\u3063\u3066\u3044\u307e\u3059\u3002\n\n\u30e1\u30c3\u30bb\u30fc\u30b8\u306fRFC7230\u4e2d\u3067\u306f\u4ee5\u4e0b\u306e\u3088\u3046\u306b\u5b9a\u7fa9\u3055\u308c\u3066\u3044\u307e\u3059\u3002\n\n```\n HTTP-message   = start-line\n                      *( header-field CRLF )\n                      CRLF\n                      [ message-body ]\n```\n                      \n`start-line     = request-line / status-line`\n`header-field   = field-name \":\" OWS field-value OWS`\n`message-body = *OCTET`\n\n\u3053\u308c\u306f\u30ea\u30af\u30a8\u30b9\u30c8\u3001\u30ec\u30b9\u30dd\u30f3\u30b9\u3067\u4ee5\u4e0b\u306e\u3088\u3046\u306b\u7c21\u5358\u306b\u8868\u3055\u308c\u307e\u3059\u3002\n\n#### \u30ea\u30af\u30a8\u30b9\u30c8\u30e1\u30c3\u30bb\u30fc\u30b8\n1. \u30ea\u30af\u30a8\u30b9\u30c8\u30e9\u30a4\u30f3\n2. \u30d8\u30c3\u30c0\n3. \u30dc\u30c7\u30a3\n\n#### \u30ec\u30b9\u30dd\u30f3\u30b9\u30e1\u30c3\u30bb\u30fc\u30b8\n1. \u30b9\u30c6\u30fc\u30bf\u30b9\u30e9\u30a4\u30f3\n2. \u30d8\u30c3\u30c0\n3. \u30dc\u30c7\u30a3\n\n\n\n### \u30ea\u30af\u30a8\u30b9\u30c8\u30e9\u30a4\u30f3/\u30b9\u30c6\u30fc\u30bf\u30b9\u30e9\u30a4\u30f3\n\u5148\u7a0b\u306eChrome\u304b\u3089\u30a2\u30af\u30bb\u30b9\u3057\u305f\u969b\u306b\u9001\u3089\u308c\u305f\u30ea\u30af\u30a8\u30b9\u30c8\u4e2d\u306e1\u884c\u76ee\u306e\n`GET / HTTP/1.1`\u304c\u30b9\u30c6\u30fc\u30bf\u30b9\u30e9\u30a4\u30f3\u3068\u306a\u308a\u307e\u3059\u3002\n\u4e00\u65b9\u3067\u3001\u30b5\u30fc\u30d0\u304b\u3089\u9001\u3089\u308c\u3066\u304d\u305f\u30ec\u30b9\u30dd\u30f3\u30b9\u4e2d\u306e1\u884c\u76ee\u306e\n`HTTP/1.1 200`\u304c\u30b9\u30c6\u30fc\u30bf\u30b9\u30e9\u30a4\u30f3\u3068\u306a\u308a\u307e\u3059\u3002\n\n####\u30ea\u30af\u30a8\u30b9\u30c8\u30e9\u30a4\u30f3\n`request-line   = method SP request-target SP HTTP-version CRLF`\n\n\n\u4e0a\u8a18\u306e\u3088\u3046\u306b\u5b9a\u7fa9\u3055\u308c\u308b\u3002method\u306fHTTP\u30e1\u30bd\u30c3\u30c9\u3002request-target\u306f\u30ea\u30af\u30a8\u30b9\u30c8\u3059\u308b\u30ea\u30bd\u30fc\u30b9\u3002HTTP-version\u306fHTTP\u306e\u30d0\u30fc\u30b8\u30e7\u30f3\u3092\u6307\u5b9a\u3059\u308b\u3002SP\u306f\u30b9\u30da\u30fc\u30b9\u3067\u3001CRLF\u306f\u6539\u884c\u3092\u3059\u308b\u3002\n\n#### \u30b9\u30c6\u30fc\u30bf\u30b9\u30e9\u30a4\u30f3\n`status-line = HTTP-version SP status-code SP reason-phrase CRLF`\n\n\u4e0a\u8a18\u306e\u3088\u3046\u306b\u5b9a\u7fa9\u3055\u308c\u308b\u3002HTTP-version\u306fHTTP\u306e\u30d0\u30fc\u30b8\u30e7\u30f3\u3002status-code\u306f\u30b9\u30c6\u30fc\u30bf\u30b9\u30b3\u30fc\u30c9\u3002reason-phrease\u306f\u30b9\u30c6\u30fc\u30bf\u30b9\u30b3\u30fc\u30c9\u306b\u5bfe\u5fdc\u3059\u308b\u30c7\u30a3\u30b9\u30af\u30ea\u30d7\u30b7\u30e7\u30f3\u306b\u5bfe\u5fdc\u3059\u308b\u3002\n\n\n### HTTP\u30e1\u30bd\u30c3\u30c9\nHTTP 1.1\u306b\u306f\u4ee5\u4e0b\u306e\u30e1\u30bd\u30c3\u30c9\u304c\u5b9a\u7fa9\u3055\u308c\u3066\u3044\u307e\u3059\u3002\n\n- OPTIONS\n- GET\n- HEAD\n- POST\n- PUT\n- DELETE\n- TRACE\n- CONNECT\n- PATCH\n\n\n### \u30b9\u30c6\u30fc\u30bf\u30b9\u30b3\u30fc\u30c9\n#### \u5206\u985e\n1. 1xx\n   * \u51e6\u7406\u4e2d\n2. 2xx\n   * \u6210\u529f\n3. 3xx\n   * \u30ea\u30c0\u30a4\u30ec\u30af\u30c8\n4. 4xx\n   * \u30af\u30e9\u30a4\u30a2\u30f3\u30c8\u30a8\u30e9\u30fc\n5. 5xx\n   * \u30b5\u30fc\u30d0\u30a8\u30e9\u30fc\n\n\u4ee5\u4e0b\u306e\u3088\u304f\u7528\u3044\u3089\u308c\u308b\u30b9\u30c6\u30fc\u30bf\u30b9\u30b3\u30fc\u30c9\u3092\u3044\u304f\u3064\u304b\u4e0a\u3052\u3066\u307f\u307e\u3059\u3002\n\n- 200 OK\n- 302 Found\n- 400 Bad Request\n- 401 Unauthorized\n- 403 Forbidden\n- 404 Not Found\n- 500 Internal Server Error\n- 502 Bad Gateway\n- 503 Service Unavailable\n- 504 Gateway Timeout\n\n\u6b8b\u308a\u306e\u30b9\u30c6\u30fc\u30bf\u30b9\u30b3\u30fc\u30c9\u306eAppendix\u3092\u53c2\u7167\u3002\n\n\n### HTTP\u30d8\u30c3\u30c0\nHTTP\u30d8\u30c3\u30c0\u306b\u306f\u30dc\u30c7\u30a3\u306b\u5bfe\u3059\u308b\u30e1\u30bf\u30c7\u30fc\u30bf\u3092\u5b9a\u7fa9\u3057\u307e\u3059\u3002\u4f8b\u3048\u3070\u30ea\u30af\u30a8\u30b9\u30c8\u3067\u306f\u4ee5\u4e0b\u306e\u3088\u3046\u306a\u8907\u6570\u306e\u30e1\u30bf\u30c7\u30fc\u30bf\u304b\u3089HTTP\u30d8\u30c3\u30c0\u3092\u69cb\u6210\u3057\u307e\u3059\u3002\n\n- Host\n- User-Agent\n- Accept\n- Accept-Language\n- Accept-Encoding\n- Accept-Charset\n- Keep-Alive\n- Connection\n\n\nHTTP\u30d8\u30c3\u30c0\u306f\u3001\u30ea\u30af\u30a8\u30b9\u30c8\u306f\u3001\u30ea\u30af\u30a8\u30b9\u30c8\u30d8\u30c3\u30c0\u30fc\u30d5\u30a3\u30fc\u30eb\u30c9\u3001\u6c4e\u7528\u30d8\u30c3\u30c0\u30fc\u30d5\u30a3\u30fc\u30eb\u30c9\u3001\u30a8\u30f3\u30c6\u30a3\u30c6\u30a3\u30d8\u30c3\u30c0\u30fc\u30d5\u30a3\u30fc\u30eb\u30c9\u304b\u3089\u3001\u30ec\u30b9\u30dd\u30f3\u30b9\u306f\u30ec\u30b9\u30dd\u30f3\u30b9\u30d8\u30c3\u30c0\u30fc\u30d5\u30a3\u30fc\u30eb\u30c9\u3001\u6c4e\u7528\u30d8\u30c3\u30c0\u30fc\u30d5\u30a3\u30fc\u30eb\u30c9\u3001\u30a8\u30f3\u30c6\u30a3\u30c6\u30a3\u30d8\u30c3\u30c0\u30fc\u30d5\u30a3\u30fc\u30eb\u30c9\u304b\u3089\u6210\u308a\u307e\u3059\u3002\n\n\u6b8b\u308a\u306e\u30d8\u30c3\u30c0\u306fAppendix\u3092\u53c2\u7167\u3002\n\n## Socket\u901a\u4fe1\n\u30b5\u30fc\u30d0\u5074\u3067\u4f7f\u7528\u3059\u308b\u4e3b\u306aSocket\u901a\u4fe1\u306e\u95a2\u6570\u3068\u6d41\u308c\u306f\u4ee5\u4e0b\u306e\u901a\u308a\u3068\u306a\u308a\u307e\u3059\u3002\n\n###1. socket()\n\u30bd\u30b1\u30c3\u30c8\u751f\u6210\n###2. bind()\n\u30bd\u30b1\u30c3\u30c8\u767b\u9332\n###3.listen()\n\u30bd\u30b1\u30c3\u30c8\u63a5\u7d9a\u6e96\u5099\n###4.accept()\n\u30bd\u30b1\u30c3\u30c8\u63a5\u7d9a\u5f85\u6a5f\n###5.recv()/send()\n\u30d1\u30b1\u30c3\u30c8\u306e\u9001\u53d7\u4fe1\n###6.close()\n\u30bd\u30b1\u30c3\u30c8\u5207\u65ad\t\n\n###\u5b9f\u88c5\n\n```C++\nint listenfd = socket(AF_INET, SOCK_STREAM, 0);\nif(listenfd == -1) {\n    std::cout << \"socket() failed.\" << std::endl;\n    exit(1);\n}\n\nint optval = 1;\nif(setsockopt(listenfd, SOL_SOCKET, SO_REUSEADDR, &optval, sizeof(optval)) == -1) {\n    std::cout << \"setsockopt() failed.\" << std::endl;\n    close(listenfd);\n    return -1;\n}\n\nint port = 5000;\nstruct sockaddr_in serv_addr;\n\nmemset(&serv_addr, 0, sizeof(serv_addr));\n\nserv_addr.sin_family = AF_INET;\nserv_addr.sin_addr.s_addr = htonl(INADDR_ANY);\nserv_addr.sin_port = htons(port);\n\n\nif(bind(listenfd, (struct sockaddr*)&serv_addr, sizeof(serv_addr)) == -1) {\n    std::cout << \"bind() failed.(\" << errno << \")\" << std::endl;\n    close(listenfd);\n    return -1;\n}\n\nif(listen(listenfd, SOMAXCONN) == -1) {\n    std::cout << \"listen() failed.\" << std::endl;\n    close(this->listenfd);\n    return -1;\n}\n```\n\n\u30bd\u30b1\u30c3\u30c8\u63a5\u7d9a\u5f85\u6a5f\u304b\u3089\u306f\u30eb\u30fc\u30d7\u5185\u3067\u51e6\u7406\u3059\u308b\u3002\n\n```C++\nint accfd = accept(sock->get_listenfd(), (struct sockaddr*)NULL, NULL);\n\nif(accfd == -1) {\n    std::cout << \"No acceptance\" << std::endl;\n}\n```\n\n```C++\nchar buf[BUF_SIZE];\nmemset(buf, 0, sizeof(buf));\nstd::string recv_str = \"\";\nssize_t read_size = 0;\n\nread_size = recv(accfd, buf, sizeof(buf)-1, 0);\nif(read_size == -1) {\n    std::cout << \"ERROR: \" << errno << std::endl;\n    close(accfd);\n    accfd = -1;\n    break;\n}\nif(read_size > 0) {\n    recv_str.append(buf);\n}\n```\n\n```C++\nif(write(accfd, server_response.c_str(), server_response.length()) == -1){\n    std::cout << \"write() failed.\" << std::endl;\n}\n```\n\n# HTTP\u30b5\u30fc\u30d0\u3092C++\u306b\u3088\u308b\u30d5\u30eb\u30b9\u30af\u30e9\u30c3\u30c1\u3067\u5b9f\u88c5\n\u4e0a\u8a18\u306e\u77e5\u8b58\u3092\u5143\u306bC++\u3067\u7c21\u6613\u306aHTTP\u30b5\u30fc\u30d0\u3092\u5b9f\u88c5\u3057\u3066\u7406\u89e3\u3092\u6df1\u3081\u3066\u307f\u307e\u3057\u3087\u3046\u3002\n\u305d\u306e\u5f8c\u3001\u540c\u6642\u30a2\u30af\u30bb\u30b9\u6570\u3092\u5897\u3084\u3057\u3066\u3082\u634c\u3051\u308b\u5b9f\u88c5\u3082\u884c\u3044\u307e\u3059\u3002\n(\u5b9f\u88c5\u306f\u6700\u4f4e\u9650\u306e\u52d5\u4f5c\u78ba\u8a8d\u306e\u305f\u3081\u306e\u3082\u306e\u3067\u8a2d\u8a08\u306a\u3069\u7d30\u304b\u3044\u70b9\u306f\u5bb9\u8d66\u304f\u3060\u3055\u3044^^;)\n\n## \u5b9f\u88c5\u306e\u6d41\u308c\n1.\u521d\u671f\u5316\n2.\u30ea\u30af\u30a8\u30b9\u30c8\u304b\u3089\u30d8\u30c3\u30c0\u30fc\u90e8\u5206\u3092\u8aad\u307f\u8fbc\u3080\n3.\u30ea\u30af\u30a8\u30b9\u30c8\u3092\u30d1\u30fc\u30b9\u3057\u3066\u30ea\u30bd\u30fc\u30b9\u306e\u30d1\u30b9\u3092\u53d6\u5f97\u3059\u308b\n4.\u53d6\u5f97\u3057\u305f\u30d1\u30b9\u306e\u30d5\u30a1\u30a4\u30eb\u306e\u5185\u5bb9\u3092\u53d6\u5f97\u3059\u308b\n5.HTTP\u30ec\u30b9\u30dd\u30f3\u30b9\u306e\u30e1\u30c3\u30bb\u30fc\u30b8\u3092\u4f5c\u6210\u3059\u308b\n6.\u30bd\u30b1\u30c3\u30c8\u306b\u30ec\u30b9\u30dd\u30f3\u30b9\u3092\u66f8\u304d\u8fbc\u3080\n7.\u4f7f\u3044\u7d42\u308f\u3063\u305f\u30d5\u30a1\u30a4\u30eb\u306e\u30af\u30ed\u30fc\u30ba\n\n\n### 1.\u521d\u671f\u5316\n\u59cb\u3081\u306b\u5fc5\u8981\u306a\u5909\u6570\u306e\u5ba3\u8a00\u3068Socket\u901a\u4fe1\u306e\u6e96\u5099\u3092\u884c\u3044\u307e\u3059\u3002\n\n```\nstd::string executive_file = HTML_FILE;\nSocket *sock = new Socket(HTTP1_PORT);\nsock->set_socket();\n\nint body_length = 0;\nint is_file_exist;\n\nint accfd = -1;\n```\n\n\u4ee5\u964d\u3001Socket\u901a\u4fe1\u306eClose\u307e\u3067\u306f`while(1){}`\u306e\u30eb\u30fc\u30d7\u5185\u3067\u306e\u51e6\u7406\u3068\u306a\u308a\u307e\u3059\u3002\n\n```C++\nwhile(1) {\n\taccfd = accept(sock->get_listenfd(), (struct sockaddr*)NULL, NULL);\n\t\n\t//\u521d\u671f\u5316\n\tif(accfd == -1) {\n\t    continue;\n\t}\n\tchar buf[BUF_SIZE];\n\tmemset(buf, 0, sizeof(buf));\n\tstd::string recv_str = \"\";\n\tssize_t read_size = 0;\n}\n```\n\n\u5b9a\u6570\u3068Socket\u901a\u4fe1\u306e\u6e96\u5099\u306e\u969b\u306b\u5229\u7528\u3057\u305f\u30af\u30e9\u30b9\u306e\u5b9a\u7fa9\u306f\u4ee5\u4e0b\u306e\u901a\u308a\u3068\u306a\u308a\u307e\u3059\u3002\n\n```configure.h\n#ifndef _CONFHET_H_\n#define _CONFHET_H_\n\nconst int BUF_SIZE = 1024;\nconst int HTTP1_PORT = 5000;\nconst int HTTP_VERSION = 1;\nconst std::string HTML_FILE = \"www\";\n\n#endif\n```\n\n```socket.h\n#ifndef _SOCHET_H_\n#define _SOCHET_H_\n\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <string.h>\n#include <iostream>\n#include \"configure.h\"\n\nclass Socket {\n    int listenfd;\n    int port;\n    struct sockaddr_in serv_addr;\npublic:\n    explicit Socket(int port_): port{port_} {}\n    void set_listenfd();\n    void set_sockaddr_in();\n    int set_socket();\n\n    int get_listenfd() const { return this->listenfd; }\n};\n\n#endif\n```\n\n```socket.cpp\n#include \"socket.h\"\n\nvoid Socket::set_listenfd() {\n    this->listenfd = socket(AF_INET, SOCK_STREAM, 0);\n    if(this->listenfd == -1) {\n        std::cout << \"socket() failed.\" << std::endl;\n        exit(1);\n    }\n}\n\nvoid Socket::set_sockaddr_in() {\n    memset(&this->serv_addr, 0, sizeof(this->serv_addr));\n\n    this->serv_addr.sin_family = AF_INET;\n    this->serv_addr.sin_addr.s_addr = htonl(INADDR_ANY);\n    this->serv_addr.sin_port = htons(this->port);\n\n}\n\nint Socket::set_socket() {\n    Socket::set_listenfd();\n    int optval = 1;\n    if(setsockopt(listenfd, SOL_SOCKET, SO_REUSEADDR, &optval, sizeof(optval)) == -1) {\n        std::cout << \"setsockopt() failed.\" << std::endl;\n        close(listenfd);\n        return -1;\n    }\n\n    Socket::set_sockaddr_in();\n    if(bind(this->listenfd, (struct sockaddr*)&this->serv_addr, sizeof(this->serv_addr)) == -1) {\n        std::cout << \"bind() failed.(\" << errno << \")\" << std::endl;\n        close(this->listenfd);\n        return -1;\n    }\n\n    if(listen(this->listenfd, SOMAXCONN) == -1) {\n        std::cout << \"listen() failed.\" << std::endl;\n        close(this->listenfd);\n        return -1;\n    }\n\n    return 0;\n}\n```\n\n### 2.\u30ea\u30af\u30a8\u30b9\u30c8\u304b\u3089\u30d8\u30c3\u30c0\u30fc\u90e8\u5206\u3092\u8aad\u307f\u8fbc\u3080\n\u30eb\u30fc\u30d7\u5185\u3067\u5148\u7a0b\u306e\u51e6\u7406\u306e\u7d9a\u304d\u306b\u30d8\u30c3\u30c0\u30fc\u90e8\u5206\u3092\u6700\u5f8c\u307e\u3067\u8aad\u307f\u8fbc\u3080\u51e6\u7406\u3092\u8a18\u8ff0\u3057\u307e\u3059\u3002\n\u30d8\u30c3\u30c0\u30fc\u90e8\u5206\u306e\u6700\u5f8c\u306fCRLFCRLF\u3067\u7d42\u308f\u308b\u306e\u3067ASCII\u30b3\u30fc\u30c9\u3067\u3053\u308c\u306b\u76f8\u5f53\u3059\u308b\u6587\u5b57\u5217\u307e\u3067\u8aad\u307f\u8fbc\u3080\u3002\n\n```C++\ndo {\n    read_size = recv(accfd, buf, sizeof(buf)-1, 0);\n    if(read_size == -1) {\n        std::cout << \"read() failed.\" << std::endl;\n        std::cout << \"ERROR: \" << errno << std::endl;\n        close(accfd);\n        accfd = -1;\n        break;\n    }\n    if(read_size > 0) {\n        recv_str.append(buf);\n    }\n    if( (recv_str[recv_str.length()-4] == 0x0d) &&\n    (recv_str[recv_str.length()-3] == 0x0a) &&\n    (recv_str[recv_str.length()-2] == 0x0d) &&\n    (recv_str[recv_str.length()-1] == 0x0a)\n    ){\n        break;\n    }\n} while (read_size > 0); \n```\n\n### 3.\u30ea\u30af\u30a8\u30b9\u30c8\u3092\u30d1\u30fc\u30b9\u3057\u3066\u30ea\u30bd\u30fc\u30b9\u306e\u30d1\u30b9\u3092\u53d6\u5f97\u3059\u308b\n\n```C++\nstd::string path = \"\", path_string = \"\";\nstd::string exe = executive_file;\nstd::size_t pos = exe.rfind('/');\nif (pos != std::string::npos) {\n    exe = exe.substr(pos + 1);\n}\npath_string.clear();\npath = HTTP1_Parser::get_requestline_path(buf);\npath_string = HTTP1_Parser::argv_path_analyzer(path, executive_file.c_str(), exe.c_str());\nstd::cout << \"path_string : \" << path_string << std::endl;\n```\n\n\u4e0a\u8a18\u3067\u4f7f\u7528\u3057\u305f\u30d8\u30c3\u30c0\u30fc\u306e\u30d1\u30fc\u30b5\u30af\u30e9\u30b9\u306e\u5b9a\u7fa9\u306f\u4ee5\u4e0b\u306e\u901a\u308a\u3068\u306a\u308a\u307e\u3059\u3002\n\n```http1parser.h\n#ifndef _HTTP1_PARSER_H_\n#define _HTTP1_PARSER_H_\n\n#include <string>\n#include <cstring>\n#include <unistd.h>\n#include \"configure.h\"\n\nclass HTTP1_Parser {\npublic:\n    static char *get_filename(const char *excutive_file);\n    static std::string argv_path_analyzer(std::string request_path, const char *path, const char *executive_file);\n    static std::string get_requestline_path(char _pbuf[BUF_SIZE]);\n};\n\n#endif\n```\n\n```http1parser.cpp\n#include \"http1parser.h\"\n#include <iostream>\nchar *HTTP1_Parser::get_filename(const char *excutive_file)\n{\n    int length = strlen(excutive_file);\n    static char buf[1024]={};\n    readlink( \"/proc/self/exe\", buf, sizeof(buf)-1 );\n    int buf_length = strlen(buf);\n    for(int i = 0; i <= length; i++){\n       buf[buf_length-i-1] = 0;\n    }\n    return buf;\n}\n\nstd::string HTTP1_Parser::argv_path_analyzer(std::string request_path, const char *path, const char *executive_file) {\n    std::string path_string;\n    if(strcmp(path,\"\") == 0){\n        if (request_path == std::string(\"/\")) {\n           path_string = std::string(HTTP1_Parser::get_filename(executive_file)) + std::string(\"/index.html\");\n        }\n        else {\n            int judge = request_path.rfind(\".\",20);\n            if (judge >= 0 ) {\n                path_string = std::string(HTTP1_Parser::get_filename(executive_file)) + request_path;\n            } else {\n                path_string = std::string(HTTP1_Parser::get_filename(executive_file)) + request_path + std::string(\"/index.html\");\n            }\n        }\n    }\n    else {\n         int judge = request_path.rfind(\".\",20);\n            if (judge >= 0 ) {\n                path_string = std::string(path) + request_path;\n            } else {\n                path_string = std::string(path) + request_path + std::string(\"/index.html\");\n            }\n\n    }\n    return path_string;\n}\n\nstd::string HTTP1_Parser::get_requestline_path(char _pbuf[BUF_SIZE]) {\n    int space_num = 0;\n    char path_buffer[32];\n    int current_point = 0;\n    std::string path_string;\n    for (int i = 0; i < BUF_SIZE; i++) {\n        if(space_num == 2){\n            path_buffer[current_point] = 0;\n            path_string = std::string(path_buffer);\n            return path_string;\n        }\n        if(space_num == 1){\n            if(_pbuf[i] != ' '){\n                path_buffer[current_point++] = _pbuf[i];\n            }\n        }\n        if(_pbuf[i] == ' '){\n            ++space_num;\n        }\n    }\n    return \"\";\n}\n```\n\n### 4.\u53d6\u5f97\u3057\u305f\u30d1\u30b9\u306e\u30d5\u30a1\u30a4\u30eb\u306e\u5185\u5bb9\u3092\u53d6\u5f97\u3059\u308b\n\n```C++\nstd::ifstream output_file(path_string.c_str());\nchar line[256];\nis_file_exist = output_file.fail();\nbody_length = 0;\nstd::vector<std::string> message_body;\nwhile (output_file.getline(line, 256-1)) {\n    body_length += strlen(line);\n    message_body.push_back(std::string(line));\n}\n```\n\n### 5.HTTP\u30ec\u30b9\u30dd\u30f3\u30b9\u306e\u30e1\u30c3\u30bb\u30fc\u30b8\u3092\u4f5c\u6210\u3059\u308b\n\n```C++\nstd::string server_response;\nstd::vector<std::string> header = HTTP1_Response::make_header(3, body_length, is_file_exist, path);\nserver_response = HTTP1_Response::make_response(header, message_body);\nstd::cout << server_response << std::endl;\n```\n\n```http1response.h\n#ifndef _HTTP1_RESHET_H_\n#define _HTTP1_RESHET_H_\n\n#include <string>\n#include <cstring>\n#include <vector>\n#include <fstream>\n#include \"configure.h\"\n\nclass HTTP1_Response {\npublic:\n    static std::string make_response(std::vector<std::string> &header, std::vector<std::string> &message_body);\n    static std::vector<std::string>& make_header(int version, int body_length, int is_file_exist, std::string path);\n    static void make_body (std::vector<std::string> &body_content, int &body_content_length, std::ifstream &output_file);\n};\n\n#endif\n```\n\n```http1response.cpp\n#include \"http1response.h\"\n#include \"http1header.h\"\n#include <iostream>\n#include <iterator>\n\nstd::string HTTP1_Response::make_response(std::vector<std::string> &header, std::vector<std::string> &message_body) {\n    std::string server_response;\n    int header_size = header.size();\n    int body_size = message_body.size();\n\n    for (int i = 0; i < header_size; i++){\n        server_response.append(header[i].c_str());\n    }\n\n    for (int i = 0; i < body_size; i++){\n        server_response.append(message_body[i].c_str());\n    }\n    return server_response;\n}\n\nstd::vector<std::string>& HTTP1_Response::make_header(int version, int body_length, int is_file_exist, std::string path) {\n    if (HTTP_VERSION == 1 && path != \"\") {\n        return HTTP1_Header::make_response302(path);\n    }\n    else if (HTTP_VERSION == 2) {\n        return HTTP1_Header::make_responseUpgrade();\n    }\n    else if (is_file_exist == 1) {\n        return HTTP1_Header::make_response404();\n    }\n    else {\n        return HTTP1_Header::make_response200(body_length);\n    }\n\n    static std::vector<std::string> response_header;\n    return response_header;\n}\n\nvoid HTTP1_Response::make_body(std::vector<std::string> &body_content, int &body_content_length, std::ifstream &output_file){\n   \n    if (output_file.fail() != 0) {\n        std::cout << \"File was not found.\" << std::endl;\n        return;\n    }\n\n    char read_file_buf[BUF_SIZE];\n    output_file.read(read_file_buf, BUF_SIZE);\n    body_content.push_back(read_file_buf);\n    body_content_length = output_file.gcount();    \n}\n```\n\n### 6.\u30bd\u30b1\u30c3\u30c8\u30c7\u30a3\u30b9\u30af\u30ea\u30d7\u30bf\u306b\u30ec\u30b9\u30dd\u30f3\u30b9\u5185\u5bb9\u3092\u66f8\u304d\u8fbc\u3080\n`while(1){}`\u306e\u30eb\u30fc\u30d7\u5185\u306e\u51e6\u7406\u3067\u306e\u6700\u5f8c\u306b\u30bd\u30b1\u30c3\u30c8\u306b\u30ec\u30b9\u30dd\u30f3\u30b9\u5185\u5bb9\u3092\u6e21\u3057\u307e\u3059\u3002\n\n```C++\nif(send(accfd, server_response.c_str(), server_response.length(), 0) == -1){\n    std::cout << \"write() failed.\" << std::endl;\n}\n```\n\n\u4e0a\u8a18\u306e\u51e6\u7406\u304c\u7d42\u308f\u3063\u305f\u3089\u307e\u305f\u30eb\u30fc\u30d7\u306e\u6700\u521d\u306b\u623b\u308a\u3001\u30ea\u30af\u30a8\u30b9\u30c8\u3092\u5f85\u6a5f\u3059\u308b\u3002\n\n### 7.\u4f7f\u3044\u7d42\u308f\u3063\u305f\u30d5\u30a1\u30a4\u30eb\u306e\u30af\u30ed\u30fc\u30ba\n`while(1){}`\u306e\u30eb\u30fc\u30d7\u304b\u3089\u51fa\u305f\u3042\u3068\u306b\u6700\u5f8c\u306bSocket\u306e\u30d5\u30a1\u30a4\u30eb\u30c7\u30a3\u30b9\u30af\u30ea\u30d7\u30bf\u3092Close\u3057\u3066\u304a\u304d\u307e\u3059\u3002\n\n```C++\nclose(sock->get_listenfd());\n```\n\n\u4ee5\u4e0a\u3067\u7d42\u4e86\u3067\u3059\u3002\u540c\u30c7\u30a3\u30ec\u30af\u30c8\u30ea\u306b`www`\u3068\u3044\u3046\u30c7\u30a3\u30ec\u30af\u30c8\u30ea\u3092\u4f5c\u6210\u3057\u3001`index.html`\u3068\u3044\u3046\u30d5\u30a1\u30a4\u30eb\u540d\u3067\u4ee5\u4e0b\u306e\u5185\u5bb9\u3067\u4fdd\u5b58\u3057\u307e\u3059\u3002\n`./server`\u3092\u5b9f\u884c\u3057\u3066\u3001\u30d6\u30e9\u30a6\u30b6\u304b\u3089`http://127.0.0.1:5000`\u306b\u30a2\u30af\u30bb\u30b9\u3057\u3066\u6700\u521d\u306b\u8f09\u305b\u305f\u753b\u50cf\u306e\u3088\u3046\u306a\u753b\u9762\u306b\u306a\u308c\u3070OK\u3002\n\n```index.html\n<html>\n\t<body>\n\t\tHello, world!\n\t</body>\n</html>\n```\n\n\u3053\u308c\u307e\u3067\u306e\u30d5\u30a1\u30a4\u30eb\u306e\u5168\u4f53\u306f\u6b21\u7ae0\u306b\u8f09\u305b\u307e\u3059\u3002\n\n### \u5168\u4f53\n\u5148\u7a0b\u307e\u3067\u306e\u30d7\u30ed\u30b0\u30e9\u30e0\u5168\u4f53\u306f\u4ee5\u4e0b\u306e\u901a\u308a\u3068\u306a\u308a\u307e\u3059\u3002\n\nMakefile\u304c\u3042\u308b\u540c\u968e\u5c64\u306e\u30c7\u30a3\u30ec\u30af\u30c8\u30ea\u3067`make`\u3092\u5b9f\u884c\u3057\u3066`./server`\u3092\u5b9f\u884c\u3059\u308b\u3068\u30b5\u30fc\u30d0\u304c\u7acb\u3061\u4e0a\u304c\u308a\u307e\u3059\u3002\u3042\u3068\u306f\u3001`www/`\u4ee5\u4e0b\u306b`index.html`\u3092\u7f6e\u3044\u3066\u3001\u30d6\u30e9\u30a6\u30b6\u304b\u3089`http://127.0.0.1:5000`\u306b\u30a2\u30af\u30bb\u30b9\u3059\u308b\u3068\u3001HTML\u306e\u5185\u5bb9\u304c\u8868\u793a\u3055\u308c\u308b\u3002\n\n```Makefile\nCC = g++\nHTTP1 = server\nHTTP1_SOURCE = server.cpp socket.cpp http1header.cpp http1parser.cpp http1response.cpp\n\n.PHONY: all clean\n\nall: $(HTTP1)\n\n$(HTTP1): $(HTTP1_SOURCE)\n\tg++ $(HTTP1_SOURCE) -o $(HTTP1) -g -std=c++11 -O0 -Wall\n\n\nclean:\n\trm -rf *.o $(HTTP1)\n```\n\n```configure.h\n#ifndef _CONFHET_H_\n#define _CONFHET_H_\n\nconst int BUF_SIZE = 1024;\nconst int HTTP1_PORT = 5000;\nconst int HTTP_VERSION = 1;\nconst std::string HTML_FILE = \"www\";\n\n#endif\n```\n\n```server.cpp\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <errno.h>\n#include <string.h>\n#include <iostream>\n#include <algorithm>\n#include <errno.h>\n#include <sstream>\n#include <string>\n#include <iomanip>\n#include <fstream>\n#include <vector>\n#include <future>\n#include <thread>\n\n#include \"socket.h\"\n\n#include \"http1response.h\"\n#include \"http1header.h\"\n#include \"http1parser.h\"\n\n\n\nint http1()\n{\n    std::string executive_file = HTTP1_FILE;\n    Socket *sock = new Socket(HTTP1_PORT);\n    sock->set_socket();\n\n    int body_length = 0;\n    int is_file_exist;\n\n    int accfd = -1;\n\n    while(1) {\n        accfd = accept(sock->get_listenfd(), (struct sockaddr*)NULL, NULL);\n\n        //\u521d\u671f\u5316\n        if(accfd == -1) {\n            continue;\n        }\n        char buf[BUF_SIZE];\n        memset(buf, 0, sizeof(buf));\n        std::string recv_str = \"\";\n        ssize_t read_size = 0;\n\n        // \\r\\n\\r\\n\u304c\u6765\u308b\u307e\u3067\u30e1\u30c3\u30bb\u30fc\u30b8\u53d7\u4fe1\n        do {\n            read_size = recv(accfd, buf, sizeof(buf)-1, 0);\n            if(read_size == -1) {\n                std::cout << \"read() failed.\" << std::endl;\n                std::cout << \"ERROR: \" << errno << std::endl;\n                close(accfd);\n                accfd = -1;\n                break;\n            }\n            if(read_size > 0) {\n                recv_str.append(buf);\n            }\n            if( (recv_str[recv_str.length()-4] == 0x0d) &&\n            (recv_str[recv_str.length()-3] == 0x0a) &&\n            (recv_str[recv_str.length()-2] == 0x0d) &&\n            (recv_str[recv_str.length()-1] == 0x0a)\n            ){\n                break;\n            }\n        } while (read_size > 0); \n\n        //\u30ea\u30af\u30a8\u30b9\u30c8\u3055\u308c\u305f\u30d1\u30b9\u3092\u53d6\u5f97\u3059\u308b\n        std::string path = \"\", path_string = \"\";\n        std::string exe = executive_file;\n        std::size_t pos = exe.rfind('/');\n        if (pos != std::string::npos) {\n            exe = exe.substr(pos + 1);\n        }\n        path_string.clear();\n        path = HTTP1_Parser::get_requestline_path(buf);\n        path_string = HTTP1_Parser::argv_path_analyzer(path, executive_file.c_str(), exe.c_str());\n        std::cout << \"path_string : \" << path_string << std::endl;\n\n        //\u53d6\u5f97\u3057\u305f\u30d1\u30b9\u306e\u30d5\u30a1\u30a4\u30eb\u3092\u958b\u3044\u3066\u5185\u5bb9\u3092\u53d6\u5f97\u3059\u308b\n        std::ifstream output_file(path_string.c_str());\n        char line[256];\n        is_file_exist = output_file.fail();\n        body_length = 0;\n        std::vector<std::string> message_body;\n        while (output_file.getline(line, 256-1)) {\n            body_length += strlen(line);\n            message_body.push_back(std::string(line));\n        }\n\n        //HTTP\u30ec\u30b9\u30dd\u30f3\u30b9\u3092\u4f5c\u6210\u3059\u308b\n        std::string server_response;\n        std::vector<std::string> header = HTTP1_Response::make_header(3, body_length, is_file_exist, path);\n        server_response = HTTP1_Response::make_response(header, message_body);\n        std::cout << server_response << std::endl;\n\n        //\u30bd\u30b1\u30c3\u30c8\u30c7\u30a3\u30b9\u30af\u30ea\u30d7\u30bf\u306b\u30ec\u30b9\u30dd\u30f3\u30b9\u5185\u5bb9\u3092\u66f8\u304d\u8fbc\u3080\n        if(send(accfd, server_response.c_str(), server_response.length(), 0) == -1){\n            std::cout << \"write() failed.\" << std::endl;\n        }\n\n        //\u4f7f\u3044\u7d42\u308f\u3063\u305f\u30d5\u30a1\u30a4\u30eb\u306e\u30af\u30ed\u30fc\u30ba\n        output_file.close();\n        close(accfd);\n        accfd = -1;\n   }\n    close(sock->get_listenfd());\n    return 0;\n}\n\nint main(int argc, char *argv[])\n{\n    http1();\n    return 0;\n}\n```\n\n```socket.h\n#ifndef _SOCHET_H_\n#define _SOCHET_H_\n\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <string.h>\n#include <iostream>\n#include \"configure.h\"\n\nclass Socket {\n    int listenfd;\n    int port;\n    struct sockaddr_in serv_addr;\npublic:\n    explicit Socket(int port_): port{port_} {}\n    void set_listenfd();\n    void set_sockaddr_in();\n    int set_socket();\n\n    int get_listenfd() const { return this->listenfd; }\n};\n\n#endif\n```\n\n```socket.cpp\n#include \"socket.h\"\n\nvoid Socket::set_listenfd() {\n    this->listenfd = socket(AF_INET, SOCK_STREAM, 0);\n    if(this->listenfd == -1) {\n        std::cout << \"socket() failed.\" << std::endl;\n        exit(1);\n    }\n}\n\nvoid Socket::set_sockaddr_in() {\n    memset(&this->serv_addr, 0, sizeof(this->serv_addr));\n\n    this->serv_addr.sin_family = AF_INET;\n    this->serv_addr.sin_addr.s_addr = htonl(INADDR_ANY);\n    this->serv_addr.sin_port = htons(this->port);\n\n}\n\nint Socket::set_socket() {\n    Socket::set_listenfd();\n    int optval = 1;\n    if(setsockopt(listenfd, SOL_SOCKET, SO_REUSEADDR, &optval, sizeof(optval)) == -1) {\n        std::cout << \"setsockopt() failed.\" << std::endl;\n        close(listenfd);\n        return -1;\n    }\n\n    Socket::set_sockaddr_in();\n    if(bind(this->listenfd, (struct sockaddr*)&this->serv_addr, sizeof(this->serv_addr)) == -1) {\n        std::cout << \"bind() failed.(\" << errno << \")\" << std::endl;\n        close(this->listenfd);\n        return -1;\n    }\n\n    if(listen(this->listenfd, SOMAXCONN) == -1) {\n        std::cout << \"listen() failed.\" << std::endl;\n        close(this->listenfd);\n        return -1;\n    }\n\n    return 0;\n}\n```\n\n```http1parse.h\n#ifndef _HTTP1_PARSER_H_\n#define _HTTP1_PARSER_H_\n\n#include <string>\n#include <cstring>\n#include <unistd.h>\n#include \"configure.h\"\n\nclass HTTP1_Parser {\npublic:\n    static char *get_filename(const char *excutive_file);\n    static std::string argv_path_analyzer(std::string request_path, const char *path, const char *executive_file);\n    static std::string get_requestline_path(char _pbuf[BUF_SIZE]);\n};\n\n#endif\n```\n\n```http1parse.cpp\n#include \"http1parser.h\"\n#include <iostream>\nchar *HTTP1_Parser::get_filename(const char *excutive_file)\n{\n    int length = strlen(excutive_file);\n    static char buf[1024]={};\n    readlink( \"/proc/self/exe\", buf, sizeof(buf)-1 );\n    int buf_length = strlen(buf);\n    for(int i = 0; i <= length; i++){\n       buf[buf_length-i-1] = 0;\n    }\n    return buf;\n}\n\nstd::string HTTP1_Parser::argv_path_analyzer(std::string request_path, const char *path, const char *executive_file) {\n    std::string path_string;\n    if(strcmp(path,\"\") == 0){\n        if (request_path == std::string(\"/\")) {\n           path_string = std::string(HTTP1_Parser::get_filename(executive_file)) + std::string(\"index.html\");\n        }\n        else {\n            int judge = request_path.rfind(\".\",20);\n            if (judge >= 0 ) {\n                path_string = std::string(HTTP1_Parser::get_filename(executive_file)) + request_path;\n            } else {\n                path_string = std::string(HTTP1_Parser::get_filename(executive_file)) + request_path + std::string(\"index.html\");\n            }\n        }\n    }\n    else {\n         int judge = request_path.rfind(\".\",20);\n            if (judge >= 0 ) {\n                path_string = std::string(path) + request_path;\n            } else {\n                path_string = std::string(path) + request_path + std::string(\"index.html\");\n            }\n\n    }\n    return path_string;\n}\n\nstd::string HTTP1_Parser::get_requestline_path(char _pbuf[BUF_SIZE]) {\n    int space_num = 0;\n    char path_buffer[32];\n    int current_point = 0;\n    std::string path_string;\n    for (int i = 0; i < BUF_SIZE; i++) {\n        if(space_num == 2){\n            path_buffer[current_point] = 0;\n            path_string = std::string(path_buffer);\n            return path_string;\n        }\n        if(space_num == 1){\n            if(_pbuf[i] != ' '){\n                path_buffer[current_point++] = _pbuf[i];\n            }\n        }\n        if(_pbuf[i] == ' '){\n            ++space_num;\n        }\n    }\n    return \"\";\n}\n```\n\n```http1header.h\n#ifndef _HTTP1_HEAD_H_\n#define _HTTP1_HEAD_H_\n\n#include <vector>\n#include <string>\n#include <map>\n#include <sstream>\n\n\nclass HTTP1_Header {\npublic:\n    static std::vector<std::string>& make_response404();\n    static std::vector<std::string>& make_response200(int body_length);\n    static std::vector<std::string>& make_response302(std::string path);\n    static std::vector<std::string>& make_responseUpgrade();\n};\n\n#endif\n```\n\n```http1header.cpp\n#include \"http1header.h\"\n#include <iostream>\nstd::vector<std::string>& HTTP1_Header::make_response404() {\n    static std::vector<std::string> header ={ \n        \"HTTP/1.1 404 Not Found\\r\\n\", \n        \"Content-Type: text/html; charset=UTF-8\\r\\n\",\n        \"Connection: close\\r\\n\",\n        \"\\r\\n\",\n        \"<html><body><h1>404 Not found</h1><p>The requested URL was not found on this server.</p><hr><address>Original Server</address></body></html>\\r\\n\"\n    };\n    \n    return header;\n}\n\nstd::vector<std::string>& HTTP1_Header::make_response200(int body_length) {\n    std::ostringstream oss;\n    oss << \"Content-Length: \" << body_length << \"\\r\\n\";\n\n    static std::vector<std::string> header = {\n        \"HTTP/1.1 200 OK\\r\\n\",\n        \"Content-Type: text/html; charset=UTF-8\\r\\n\",\n        oss.str(),\n        \"Connection: Keep-Alive\\r\\n\",\n        \"\\r\\n\"\n    };\n\n    return header;\n}\n\nstd::vector<std::string>& HTTP1_Header::make_response302(std::string path) {\n    std::ostringstream oss;\n    if (path != \"\") {\n        oss << \"Location: https://127.0.0.1:5001\" << path.c_str() << \"\\r\\n\";\n    }\n    else {\n        oss << \"Location: https://127.0.0.1:5001\\r\\n\";\n    }\n    static std::vector<std::string> header = {\n        \"HTTP/1.1 302 Found\\r\\n\",\n        oss.str(),\n        \"\\r\\n\"\n    };\n    return header;\n}\n\nstd::vector<std::string>& HTTP1_Header::make_responseUpgrade() {\n    static std::vector<std::string> header = {\n        \"HTTP/1.1 101 Switching Protocols\\r\\n\",\n        \"Connection: Upgrade\\r\\n\",\n        \"Upgrade: h2c\\r\\n\",\n        \"\\r\\n\"\n    };\n    \n    return header;\n}\n```\n\n```http1response.h\n#ifndef _HTTP1_RESHET_H_\n#define _HTTP1_RESHET_H_\n\n#include <string>\n#include <cstring>\n#include <vector>\n#include <fstream>\n#include \"configure.h\"\n\nclass HTTP1_Response {\npublic:\n    static std::string make_response(std::vector<std::string> &header, std::vector<std::string> &message_body);\n    //static std::vector<std::string>& make_header(int version, int body_length, std::ifstream &output_file);\n    static std::vector<std::string>& make_header(int version, int body_length, int is_file_exist, std::string path);\n    static void make_body (std::vector<std::string> &body_content, int &body_content_length, std::ifstream &output_file);\n};\n\n#endif\n```\n\n```http1response.cpp\n#include \"http1response.h\"\n#include \"http1header.h\"\n#include <iostream>\n#include <iterator>\n\nstd::string HTTP1_Response::make_response(std::vector<std::string> &header, std::vector<std::string> &message_body) {\n    std::string server_response;\n    int header_size = header.size();\n    int body_size = message_body.size();\n\n    std::string tmp;\n\n    for (int i = 0; i < header_size; i++){\n        server_response.append(header[i].c_str());\n    }\n\n    for (int i = 0; i < body_size; i++){\n        server_response.append(message_body[i].c_str());\n    }\n    return server_response;\n}\n\nstd::vector<std::string>& HTTP1_Response::make_header(int version, int body_length, int is_file_exist, std::string path) {\n    if (HTTP_VERSION == 1 && path != \"\") {\n        return HTTP1_Header::make_response302(path);\n    }\n    else if (HTTP_VERSION == 2) {\n        return HTTP1_Header::make_responseUpgrade();\n    }\n    else if (is_file_exist == 1) {\n        return HTTP1_Header::make_response404();\n    }\n    else {\n        return HTTP1_Header::make_response200(body_length);\n    }\n\n    static std::vector<std::string> response_header;\n    return response_header;\n}\n\nvoid HTTP1_Response::make_body(std::vector<std::string> &body_content, int &body_content_length, std::ifstream &output_file){\n   \n    if (output_file.fail() != 0) {\n        std::cout << \"File was not found.\" << std::endl;\n        return;\n    }\n\n    char read_file_buf[BUF_SIZE];\n    output_file.read(read_file_buf, BUF_SIZE);\n    body_content.push_back(read_file_buf);\n    body_content_length = output_file.gcount();    \n}\n```\n\n## \u540c\u6642\u30a2\u30af\u30bb\u30b9\u6570\u306e\u5897\u52a0\u306b\u5bfe\u5fdc\u3059\u308b\n\n```C++\nint accfd = -1;\n```\n\n\u3060\u3063\u305f\u3068\u3053\u308d\u3092\u4e0b\u306e\u3088\u3046\u306bint\u578b\u304b\u3089int\u578b\u306e\u914d\u5217\u306b\u4fee\u6b63\u3057\u307e\u3059\u3002\n\n```C++\nconst int MAX_SESSION = 10;\n\nint accfd[MAX_SESSION];\nfor(int i=0; i < MAX_SESSION; i++){\n    accfd[i] = -1;\n}\n```\n\n\u5148\u7a0b\u306b\u7d9a\u3051\u3066\u4ee5\u4e0b\u306e\u5ba3\u8a00\u3092\u3057\u307e\u3059\u3002\n\n```C++\nfd_set fds;\n```\n\n`while(1){}`\u306e\u30eb\u30fc\u30d7\u5185\u306b\u5165\u308a\u3001\u6700\u521d\u306b\u8907\u6570\u30bd\u30b1\u30c3\u30c8\u306e\u901a\u4fe1\u306e\u6e96\u5099\u3092\u3057\u3066\u304a\u304d\u307e\u3059\u3002\n\n```C++\nFD_ZERO(&fds);\nFD_SET(sock->get_listenfd(), &fds);\nint width = sock->get_listenfd() + 1;\n\nfor (int i=0; i < MAX_SESSION; i++){\n    if(accfd[i] != -1){\n        FD_SET(accfd[i], &fds);\n        if(width < (accfd[i]+1)){\n            width = accfd[i]+1;\n        }\n    }\n}\nif(select(width, &fds, NULL,NULL, NULL) == -1) {\n    std::cout << \"select() failed.\" << std::endl;\n    break;\n}\n\nif(FD_ISSET(sock->get_listenfd(), &fds)){\n    int connfd = accept(sock->get_listenfd(), (struct sockaddr*)NULL, NULL);\n    bool limit_over = true;\n    for(int i = 0; i < MAX_SESSION; i++) {\n        if(accfd[i] == -1) {\n            accfd[i] = connfd;\n            limit_over = false;\n            break;\n        }\n    }\n    if(limit_over) {\n        close(connfd);\n        std::cout << \"over max connection.\" << std::endl;\n    }\n}\n```\n\n\u5148\u7a0baccept()\u306e\u8fd4\u308a\u5024\u3092\u30c1\u30a7\u30c3\u30af\u3057\u3066\u4ee5\u4e0b\u306e\u3088\u3046\u306a\u8a18\u8ff0\u3067\u51e6\u7406\u3092\u7d9a\u3051\u3066\u3044\u307e\u3057\u305f\u3002\n\n```C++\nif(accfd == -1) {\n    continue;\n}\nchar buf[BUF_SIZE];\nmemset(buf, 0, sizeof(buf));\n```\n\n\u8907\u6570\u30bd\u30b1\u30c3\u30c8\u3067\u306e\u901a\u4fe1\u306e\u3068\u304d\u306f\u30bb\u30c3\u30b7\u30e7\u30f3\u6bce\u306b\u3053\u308c\u3089\u3092\u884c\u3046\u305f\u3081\u306b\u30bb\u30c3\u30b7\u30e7\u30f3\u306e\u6570\u3060\u3051\u30eb\u30fc\u30d7\u3092\u56de\u3057\u3066\u51e6\u7406\u3092\u3057\u307e\u3059\u3002\n\n```C++\nfor( int i = 0; i < MAX_SESSION; i++) {\n    if(accfd[i] == -1) {\n        continue;\n    }\n    char buf[BUF_SIZE];\n    memset(buf, 0, sizeof(buf));\n    if(FD_ISSET(accfd[i], &fds)) {\n        std::string recv_str = \"\";\n        ssize_t read_size = 0;\n\t\t\t\t\t\ufe19\n    \t\t\t\t\ufe19\n    }\n}\n```\n\n\u4ee5\u4e0a\u3068\u306a\u308a\u307e\u3059\u3002\n\n### \u5168\u4f53\n\u5148\u307b\u3069\u3068\u306fserver.cpp\u306e\u307f\u3092\u4fee\u6b63\u3057\u307e\u3059\u3002\n\n```server.cpp\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <errno.h>\n#include <string.h>\n#include <iostream>\n#include <algorithm>\n#include <errno.h>\n#include <sstream>\n#include <string>\n#include <iomanip>\n#include <fstream>\n#include <vector>\n#include <future>\n#include <thread>\n\n#include \"socket.h\"\n\n#include \"http1response.h\"\n#include \"http1header.h\"\n#include \"http1parser.h\"\n#include \"socket.h\"\n\n\n\nconst int MAX_SESSION = 10;\n\nint http1()\n{\n    std::string executive_file = HTTP1_FILE;\n    Socket *sock = new Socket(HTTP1_PORT);\n    sock->set_socket();\n\n    int body_length = 0;\n    int is_file_exist;\n\n    int accfd[MAX_SESSION];\n    for(int i=0; i < MAX_SESSION; i++){\n        accfd[i] = -1;\n    }\n    fd_set fds;\n\n    while(1) {\n        FD_ZERO(&fds);\n        FD_SET(sock->get_listenfd(), &fds);\n        int width = sock->get_listenfd() + 1;\n\n        for (int i=0; i < MAX_SESSION; i++){\n            if(accfd[i] != -1){\n                FD_SET(accfd[i], &fds);\n                if(width < (accfd[i]+1)){\n                    width = accfd[i]+1;\n                }\n            }\n        }\n        if(select(width, &fds, NULL,NULL, NULL) == -1) {\n            std::cout << \"select() failed.\" << std::endl;\n            break;\n        }\n\n        if(FD_ISSET(sock->get_listenfd(), &fds)){\n            int connfd = accept(sock->get_listenfd(), (struct sockaddr*)NULL, NULL);\n            bool limit_over = true;\n            for(int i = 0; i < MAX_SESSION; i++) {\n                if(accfd[i] == -1) {\n                    accfd[i] = connfd;\n                    limit_over = false;\n                    break;\n                }\n            }\n            if(limit_over) {\n                close(connfd);\n                std::cout << \"over max connection.\" << std::endl;\n            }\n        }\n\n        //Start reading message\n        for( int i = 0; i < MAX_SESSION; i++) {\n            if(accfd[i] == -1) {\n                continue;\n            }\n            char buf[BUF_SIZE];\n            memset(buf, 0, sizeof(buf));\n            if(FD_ISSET(accfd[i], &fds)) {\n                std::string recv_str = \"\";\n                ssize_t read_size = 0;\n\n                do {\n                    read_size = recv(accfd[i], buf, sizeof(buf)-1, 0);\n                    if(read_size == -1) {\n                        std::cout << \"read() failed.\" << std::endl;\n                        std::cout << \"ERROR: \" << errno << std::endl;\n                        close(accfd[i]);\n                        accfd[i] = -1;\n                        break;\n                    }\n                    if(read_size > 0) {\n                        recv_str.append(buf);\n                    }\n                    if( (recv_str[recv_str.length()-4] == 0x0d) &&\n                    (recv_str[recv_str.length()-3] == 0x0a) &&\n                    (recv_str[recv_str.length()-2] == 0x0d) &&\n                    (recv_str[recv_str.length()-1] == 0x0a)\n                    ){\n                        break;\n                    }\n                } while (read_size > 0); \n                std::string path = \"\", path_string = \"\";\n                std::string exe = executive_file;\n                std::size_t pos = exe.rfind('/');\n                if (pos != std::string::npos) {\n                    exe = exe.substr(pos + 1);\n                }\n                path_string.clear();\n                path = HTTP1_Parser::get_requestline_path(buf);\n                path_string = HTTP1_Parser::argv_path_analyzer(path, executive_file.c_str(), exe.c_str());\n                std::cout << \"path_string : \" << path_string << std::endl;\n                std::ifstream output_file(path_string.c_str());\n                char line[256];\n                is_file_exist = output_file.fail();\n                body_length = 0;\n                std::vector<std::string> message_body;\n                while (output_file.getline(line, 256-1)) {\n                    body_length += strlen(line);\n                    message_body.push_back(std::string(line));\n                }\n                recv_str.append(buf);\n                std::string server_response;\n                std::vector<std::string> header = HTTP1_Response::make_header(3, body_length, is_file_exist, path);\n                server_response = HTTP1_Response::make_response(header, message_body);\n                std::cout << server_response << std::endl;\n                if(send(accfd[i], server_response.c_str(), server_response.length(), 0) == -1){\n                    std::cout << \"write() failed.\" << std::endl;\n                }\n                output_file.close();\n                close(accfd[i]);\n                accfd[i] = -1;\n            }\n        }\n   }\n    close(sock->get_listenfd());\n    return 0;\n}\n\nint main(int argc, char *argv[])\n{\n    http1();\n    return 0;\n}\n```\n\n##HTTP/2\nHTTP/2\u306fSPDY\u3092\u30d9\u30fc\u30b9\u306b\u5f93\u6765\u306eHTTP/1.x\u3068\u4e92\u63db\u6027\u3092\u4fdd\u3061\u306a\u304c\u30891\u3064\u306e\u30b3\u30cd\u30af\u30b7\u30e7\u30f3\u4e0a\u3067\u8907\u6570\u306e\u30b9\u30c8\u30ea\u30fc\u30e0\u3092\u4f7f\u3046\u3053\u3068\u3084\u30d8\u30c3\u30c0\u306e\u30d0\u30a4\u30ca\u30ea\u8868\u73fe\u3084\u5727\u7e2e\u3001\u30ea\u30af\u30a8\u30b9\u30c8\u306e\u512a\u5148\u5ea6\u4ed8\u7b49\u3067\u52b9\u7387\u5316\u3092\u56f3\u3063\u305f\u3082\u306e\u3067\u3059\u3002\n\nHTTP/2\u3092\u4f7f\u3046\u304b\u306e\u78ba\u8a8d\u306f\u4ee5\u4e0b\u306e\u901a\u308a\u3068\u306a\u308a\u307e\u3059\u3002http\u30b9\u30ad\u30fc\u30e0\u3067HTTP/1.1\u304b\u3089HTTP/2\u3092\u4f7f\u7528\u3059\u308b\u306b\u306fUpgrade\u30d8\u30c3\u30c0\u30d5\u30a3\u30fc\u30eb\u3092\u4f7f\u7528\u3059\u308b\u304bHTTP Alternative Services\u3092\u4f7f\u7528\u3057\u307e\u3059\u3002\n\n- TLS-NPN,TLS-ALPN\n- Upgrade, Alt-Svc\n- \u76f8\u624b\u304cHTTP/2\u3092\u3064\u304b\u3063\u3066\u3044\u308b\u3053\u3068\u3092\u524d\u63d0\u306b\u901a\u4fe1\n\n\n# Appendix\n## \u30b9\u30c6\u30fc\u30bf\u30b9\u30b3\u30fc\u30c9\n###1xx\n- 100 Continue\n- 101 Switching Protocols\n\n###2xx\n- 200 OK\n- 201 Created\n- 202 Accepted\n- 203 Non-Authoritative Information\n- 204 No Content\n- 205 Reset Content\n- 206 Partial Content\n\n###3xx\n- 300 Multiple Choices\n- 301 Moved Permanently\n- 302 Found\n- 303 See Other\n- 304 Not Modified\n- 305 Use Proxy\n- 306 (Unused)\n- 307 Temporary Redirect\n- 308 Parmenent Redirect\n\n\n###4xx\n- 400 Bad Request\n- 401 Unauthorized\n- 402 Payment Required\n- 403 Forbidden\n- 404 Not Found\n- 405 Method Not Allowed\n- 406 Not Acceptable\n- 407 Proxy Authentication Required\n- 408 Request Timeout\n- 409 Conflict\n- 410 Gone\n- 411 Length Required\n- 412 Precondition Failed\n- 413 Payment Too Large\n- 414 URI Too Long\n- 415 Unsupported Media Type\n- 416 Range Not Satisfiable\n- 417 Expectation Failed\n- 426 Upgrade Required\n- 428 Precondition Required\n- 429 Too Many Requests\n- 431 Request Header Fields Too Large\n\n###5xx\n- 500 Internal Server Error\n- 501 Not Implemented\n- 502 Bad Gateway\n- 503 Service Unavailable\n- 504 Gateway Timeout\n- 505 HTTP Version Not Supported\n\n\n## HTTP\u30d8\u30c3\u30c0\u30fc\n\n- Accept\n- Accept-Charset\n- Accept-Encoding\n- Accept-Language\n- Accept-Ranges\n- Age\n- Allow\n- Authorization\n- Cache-Control\n- Connection\n- Content-Encoding\n- Content-Language\n- Content-Length\n- Content-Location\n- Content-Range\n- Content-Type\n- Date\n- ETag\n- Expect\n- Expires\n- From\n- Host\n- If-Match\n- If-Modified-Since\n- If-None-Match\n- If-Range\n- If-Unmodified-Since\n- Location\n- Max-Forwards\n- Pragma\n- Proxy-Authenticate\n- Proxy-Authorization\n- Range\n- Referer\n- Retry-After\n- Server\n- TE\n- Trailer\n- Transfer-Encoding\n- Upgrade\n- User-Agent\n- Vary\n- Via\n- Warning\n- WWW-Authenticate\n\n\n# \u53c2\u8003\nftp://ftp.rfc-editor.org/in-notes/rfc2616.txt\nftp://ftp.rfc-editor.org/in-notes/rfc7230.txt\nftp://ftp.rfc-editor.org/in-notes/rfc7231.txt\nftp://ftp.rfc-editor.org/in-notes/rfc7232.txt\nftp://ftp.rfc-editor.org/in-notes/rfc7233.txt\nftp://ftp.rfc-editor.org/in-notes/rfc7234.txt\nftp://ftp.rfc-editor.org/in-notes/rfc7235.txt\nftp://ftp.rfc-editor.org/in-notes/rfc7236.txt\nftp://ftp.rfc-editor.org/in-notes/rfc7237.txt\nftp://ftp.rfc-editor.org/in-notes/rfc7238.txt\nftp://ftp.rfc-editor.org/in-notes/rfc7239.txt\nftp://ftp.rfc-editor.org/in-notes/rfc7540.txt\nftp://ftp.rfc-editor.org/in-notes/rfc7541.txt\nftp://ftp.rfc-editor.org/in-notes/rfc5789.txt\nhttps://tools.ietf.org/html/draft-nottingham-http-new-status-04\nhttp://www.asahi-net.or.jp/~ax2s-kmtn/ref/status.html\nhttp://d.hatena.ne.jp/s-kita/20080927/1222505067\nhttps://techblog.yahoo.co.jp/infrastructure/http2/ats_http2_pn/\nhttp://syucream.hatenablog.jp/entry/2014/12/20/160552\n"}