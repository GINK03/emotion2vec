{"context": " More than 1 year has passed since last update.\u7b2c\u56db\u56de \u30aa\u30d5\u30e9\u30a4\u30f3\u30ea\u30a2\u30eb\u30bf\u30a4\u30e0\u3069\u3046\u66f8\u304f\u306b\u884c\u3063\u3066\u304d\u307e\u3057\u305f\u3002\u304a\u984c\u306f\u30c6\u30c8\u30ed\u30df\u30ce\u3068\u547c\u3070\u308c\u308b\u56f3\u5f62\u306e\u8a8d\u8b58\u3002\nHaskell\u3067\u66f8\u304d\u307e\u3057\u305f\u3002\u4e0e\u3048\u3089\u308c\u305f\u30d1\u30bf\u30fc\u30f3\u306e\u56de\u8ee2\u30fb\u93e1\u50cf\u306b\u5bfe\u3057\u3066\u3059\u3079\u3066\u30de\u30c3\u30c1\u30f3\u30b0\u3092\u304b\u3051\u308b\u3068\u3044\u3046\u3082\u306e\u3002\u56f3\u5f62\u3092\u5909\u63db\u3057\u305f\u5f8c\u3067\u6700\u3082\u5de6\u4e0a\u306e\u30d6\u30ed\u30c3\u30af\u3092\u539f\u70b9\u306b\u5bc4\u305b\u3066\u3044\u307e\u3059\u3002\n\u5236\u9650\u6642\u9593(1\u6642\u9593)\u306b\u9593\u306b\u5408\u3044\u307e\u3057\u305f\u3002\n\ntetroid.hs\nmodule Main where\n\nimport Control.Monad (mapM_)\nimport Control.Arrow ((***))\nimport Data.List (find, sort)\nimport Data.Maybe (maybe)\nimport Test.HUnit (Test(..), runTestTT, (~=?))\n\nfindTetroid :: [Int] -> Char\nfindTetroid = match . normalize . toCoord\n\ntoCoord :: [Int] -> [(Int, Int)]\ntoCoord = map (`divMod` 10)\n\nnormalize :: [(Int, Int)] -> [(Int, Int)]\nnormalize = toRelative . sort\n\ntoRelative :: [(Int, Int)] -> [(Int, Int)]\ntoRelative [] = error \"toRelative: logic error\"\ntoRelative ((x, y) : ps) = (0, 0) : map (subtract x *** subtract y) ps\n\nmatch :: [(Int, Int)] -> Char\nmatch ps = maybe '-' snd $ find (matchOne ps . fst) patterns\n\nmatchOne :: [(Int, Int)] -> [(Int, Int)] -> Bool\nmatchOne lhs rhs = any (== lhs)\n  [ rhs\n  , rotate rhs\n  , rotate $ rotate rhs\n  , rotate $ rotate $ rotate rhs\n  , mirror rhs\n  , mirror $ rotate rhs\n  , mirror $ rotate $ rotate rhs\n  , mirror $ rotate $ rotate $ rotate rhs\n  ]\n\nrotate :: [(Int, Int)] -> [(Int, Int)]\nrotate = normalize . map (\\(x, y) -> (y, -x))\n\nmirror :: [(Int, Int)] -> [(Int, Int)]\nmirror = normalize . map (\\(x, y) -> (y, x))\n\npatterns :: [([(Int, Int)], Char)]\npatterns =\n  [ ( [ (0, 0), (0, 1), (0, 2), (1, 2) ], 'L' )\n  , ( [ (0, 0), (0, 1), (0, 2), (0, 3) ], 'I' )\n  , ( [ (0, 0), (1, 0), (1, 1), (2, 0) ], 'T' )\n  , ( [ (0, 0), (0, 1), (1, 0), (1, 1) ], 'O' )\n  , ( [ (0, 0), (0, 1), (1, 1), (1, 2) ], 'S' )\n  ]\n\n--------\n\nmain :: IO ()\nmain = print =<< runTestTT (TestList $ map toTest testdata)\n\ntoTest :: ([Int], Char) -> Test\ntoTest (input, expected) = expected ~=? findTetroid input\n\ntestdata :: [([Int], Char)]\ntestdata =\n  [ ([55,55,55,55], '-')\n  , ([07,17,06,05], 'L')\n  , ([21,41,31,40], 'L')\n  , ([62,74,73,72], 'L')\n  , ([84,94,74,75], 'L')\n  , ([48,49,57,47], 'L')\n  , ([69,89,79,68], 'L')\n  , ([90,82,91,92], 'L')\n  , ([13,23,03,24], 'L')\n  , ([24,22,25,23], 'I')\n  , ([51,41,21,31], 'I')\n  , ([64,63,62,65], 'I')\n  , ([49,69,59,79], 'I')\n  , ([12,10,21,11], 'T')\n  , ([89,99,79,88], 'T')\n  , ([32,41,43,42], 'T')\n  , ([27,16,36,26], 'T')\n  , ([68,57,58,67], 'O')\n  , ([72,62,61,71], 'O')\n  , ([25,24,15,14], 'O')\n  , ([43,54,53,42], 'S')\n  , ([95,86,76,85], 'S')\n  , ([72,73,84,83], 'S')\n  , ([42,33,32,23], 'S')\n  , ([66,57,67,58], 'S')\n  , ([63,73,52,62], 'S')\n  , ([76,68,77,67], 'S')\n  , ([12,11,22,01], 'S')\n  , ([05,26,06,25], '-')\n  , ([03,11,13,01], '-')\n  , ([11,20,00,21], '-')\n  , ([84,95,94,86], '-')\n  , ([36,56,45,35], '-')\n  , ([41,33,32,43], '-')\n  , ([75,94,84,95], '-')\n  , ([27,39,28,37], '-')\n  , ([45,34,54,35], '-')\n  , ([24,36,35,26], '-')\n  , ([27,27,27,27], '-')\n  , ([55,44,44,45], '-')\n  , ([70,73,71,71], '-')\n  , ([67,37,47,47], '-')\n  , ([43,45,41,42], '-')\n  , ([87,57,97,67], '-')\n  , ([49,45,46,48], '-')\n  , ([63,63,52,72], '-')\n  , ([84,86,84,95], '-')\n  , ([61,60,62,73], '-')\n  , ([59,79,69,48], '-')\n  , ([55,57,77,75], '-')\n  ]\n\n\n\u3053\u3061\u3089\u306f\u30d6\u30ed\u30c3\u30af\u540c\u58eb\u306e\u8ddd\u96e2\u306e\u4e8c\u4e57(6\u3064)\u3092\u6bd4\u8f03\u3059\u308b\u3068\u3044\u3046\u3082\u306e\u3002\u56de\u8ee2\u3084\u93e1\u50cf\u3092\u8003\u3048\u308b\u5fc5\u8981\u304c\u306a\u3044\u3076\u3093\u77ed\u304f\u30b3\u30fc\u30c7\u30a3\u30f3\u30b0\u3067\u304d\u3066\u3044\u307e\u3059\u3002\u3053\u306e\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0\u306f\u52c9\u5f37\u4f1a\u5f8c\u306e\u98f2\u307f\u4f1a\u3067\u934b\u8c37\u3055\u3093\u306b\u6559\u3048\u3066\u3082\u3089\u3044\u307e\u3057\u305f\u3002\n\ndistance.hs\nmodule Main where\n\nimport Data.Maybe (maybe)\nimport Data.List (find, sort)\nimport Test.HUnit (Test(..), runTestTT, (~=?))\n\nfindTetroid :: [Int] -> Char\nfindTetroid = match . toCoord\n\ntoCoord :: [Int] -> [(Int, Int)]\ntoCoord = map (`divMod` 10)\n\nmatch :: [(Int, Int)] -> Char\nmatch ps = maybe '-' snd $ find ((== dist) . fst) patterns\n  where\n    dist = findDist ps\n\nfindDist :: [(Int, Int)] -> [Int]\nfindDist = sort . map dist . combination\n\ndist :: ((Int, Int), (Int, Int)) -> Int\ndist ((x1, y1), (x2, y2)) = (x2 - x1) ^ 2 + (y2 - y1) ^ 2\n\ncombination :: [a] -> [(a,a)]\ncombination []     = []\ncombination (x:xs) = map ((,) x) xs ++ combination xs\n\npatterns :: [([Int], Char)]\npatterns =\n  [ ([1,1,1,1,2,2], 'O')\n  , ([1,1,1,2,2,4], 'T')\n  , ([1,1,1,2,2,5], 'S')\n  , ([1,1,1,2,4,5], 'L')\n  , ([1,1,1,4,4,9], 'I')\n  ]\n\n--------\n\n-- \u30c6\u30b9\u30c8\u30b3\u30fc\u30c9\u306f\u7701\u7565\n\n\n\n[\u7b2c\u56db\u56de \u30aa\u30d5\u30e9\u30a4\u30f3\u30ea\u30a2\u30eb\u30bf\u30a4\u30e0\u3069\u3046\u66f8\u304f](http://atnd.org/events/32191)\u306b\u884c\u3063\u3066\u304d\u307e\u3057\u305f\u3002\u304a\u984c\u306f[\u30c6\u30c8\u30ed\u30df\u30ce\u3068\u547c\u3070\u308c\u308b\u56f3\u5f62\u306e\u8a8d\u8b58\u3002](http://nabetani.sakura.ne.jp/hena/ord4tetroid/)\n\nHaskell\u3067\u66f8\u304d\u307e\u3057\u305f\u3002\u4e0e\u3048\u3089\u308c\u305f\u30d1\u30bf\u30fc\u30f3\u306e\u56de\u8ee2\u30fb\u93e1\u50cf\u306b\u5bfe\u3057\u3066\u3059\u3079\u3066\u30de\u30c3\u30c1\u30f3\u30b0\u3092\u304b\u3051\u308b\u3068\u3044\u3046\u3082\u306e\u3002\u56f3\u5f62\u3092\u5909\u63db\u3057\u305f\u5f8c\u3067\u6700\u3082\u5de6\u4e0a\u306e\u30d6\u30ed\u30c3\u30af\u3092\u539f\u70b9\u306b\u5bc4\u305b\u3066\u3044\u307e\u3059\u3002\n\n\u5236\u9650\u6642\u9593(1\u6642\u9593)\u306b\u9593\u306b\u5408\u3044\u307e\u3057\u305f\u3002\n\n```haskell:tetroid.hs\nmodule Main where\n\nimport Control.Monad (mapM_)\nimport Control.Arrow ((***))\nimport Data.List (find, sort)\nimport Data.Maybe (maybe)\nimport Test.HUnit (Test(..), runTestTT, (~=?))\n\nfindTetroid :: [Int] -> Char\nfindTetroid = match . normalize . toCoord\n\ntoCoord :: [Int] -> [(Int, Int)]\ntoCoord = map (`divMod` 10)\n\nnormalize :: [(Int, Int)] -> [(Int, Int)]\nnormalize = toRelative . sort\n\ntoRelative :: [(Int, Int)] -> [(Int, Int)]\ntoRelative [] = error \"toRelative: logic error\"\ntoRelative ((x, y) : ps) = (0, 0) : map (subtract x *** subtract y) ps\n\nmatch :: [(Int, Int)] -> Char\nmatch ps = maybe '-' snd $ find (matchOne ps . fst) patterns\n\nmatchOne :: [(Int, Int)] -> [(Int, Int)] -> Bool\nmatchOne lhs rhs = any (== lhs)\n  [ rhs\n  , rotate rhs\n  , rotate $ rotate rhs\n  , rotate $ rotate $ rotate rhs\n  , mirror rhs\n  , mirror $ rotate rhs\n  , mirror $ rotate $ rotate rhs\n  , mirror $ rotate $ rotate $ rotate rhs\n  ]\n\nrotate :: [(Int, Int)] -> [(Int, Int)]\nrotate = normalize . map (\\(x, y) -> (y, -x))\n\nmirror :: [(Int, Int)] -> [(Int, Int)]\nmirror = normalize . map (\\(x, y) -> (y, x))\n\npatterns :: [([(Int, Int)], Char)]\npatterns =\n  [ ( [ (0, 0), (0, 1), (0, 2), (1, 2) ], 'L' )\n  , ( [ (0, 0), (0, 1), (0, 2), (0, 3) ], 'I' )\n  , ( [ (0, 0), (1, 0), (1, 1), (2, 0) ], 'T' )\n  , ( [ (0, 0), (0, 1), (1, 0), (1, 1) ], 'O' )\n  , ( [ (0, 0), (0, 1), (1, 1), (1, 2) ], 'S' )\n  ]\n\n--------\n\nmain :: IO ()\nmain = print =<< runTestTT (TestList $ map toTest testdata)\n\ntoTest :: ([Int], Char) -> Test\ntoTest (input, expected) = expected ~=? findTetroid input\n\ntestdata :: [([Int], Char)]\ntestdata =\n  [ ([55,55,55,55], '-')\n  , ([07,17,06,05], 'L')\n  , ([21,41,31,40], 'L')\n  , ([62,74,73,72], 'L')\n  , ([84,94,74,75], 'L')\n  , ([48,49,57,47], 'L')\n  , ([69,89,79,68], 'L')\n  , ([90,82,91,92], 'L')\n  , ([13,23,03,24], 'L')\n  , ([24,22,25,23], 'I')\n  , ([51,41,21,31], 'I')\n  , ([64,63,62,65], 'I')\n  , ([49,69,59,79], 'I')\n  , ([12,10,21,11], 'T')\n  , ([89,99,79,88], 'T')\n  , ([32,41,43,42], 'T')\n  , ([27,16,36,26], 'T')\n  , ([68,57,58,67], 'O')\n  , ([72,62,61,71], 'O')\n  , ([25,24,15,14], 'O')\n  , ([43,54,53,42], 'S')\n  , ([95,86,76,85], 'S')\n  , ([72,73,84,83], 'S')\n  , ([42,33,32,23], 'S')\n  , ([66,57,67,58], 'S')\n  , ([63,73,52,62], 'S')\n  , ([76,68,77,67], 'S')\n  , ([12,11,22,01], 'S')\n  , ([05,26,06,25], '-')\n  , ([03,11,13,01], '-')\n  , ([11,20,00,21], '-')\n  , ([84,95,94,86], '-')\n  , ([36,56,45,35], '-')\n  , ([41,33,32,43], '-')\n  , ([75,94,84,95], '-')\n  , ([27,39,28,37], '-')\n  , ([45,34,54,35], '-')\n  , ([24,36,35,26], '-')\n  , ([27,27,27,27], '-')\n  , ([55,44,44,45], '-')\n  , ([70,73,71,71], '-')\n  , ([67,37,47,47], '-')\n  , ([43,45,41,42], '-')\n  , ([87,57,97,67], '-')\n  , ([49,45,46,48], '-')\n  , ([63,63,52,72], '-')\n  , ([84,86,84,95], '-')\n  , ([61,60,62,73], '-')\n  , ([59,79,69,48], '-')\n  , ([55,57,77,75], '-')\n  ]\n```\n\n\u3053\u3061\u3089\u306f\u30d6\u30ed\u30c3\u30af\u540c\u58eb\u306e\u8ddd\u96e2\u306e\u4e8c\u4e57(6\u3064)\u3092\u6bd4\u8f03\u3059\u308b\u3068\u3044\u3046\u3082\u306e\u3002\u56de\u8ee2\u3084\u93e1\u50cf\u3092\u8003\u3048\u308b\u5fc5\u8981\u304c\u306a\u3044\u3076\u3093\u77ed\u304f\u30b3\u30fc\u30c7\u30a3\u30f3\u30b0\u3067\u304d\u3066\u3044\u307e\u3059\u3002\u3053\u306e\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0\u306f\u52c9\u5f37\u4f1a\u5f8c\u306e\u98f2\u307f\u4f1a\u3067[\u934b\u8c37\u3055\u3093](http://qiita.com/users/Nabetani)\u306b\u6559\u3048\u3066\u3082\u3089\u3044\u307e\u3057\u305f\u3002\n\n```haskell:distance.hs\nmodule Main where\n\nimport Data.Maybe (maybe)\nimport Data.List (find, sort)\nimport Test.HUnit (Test(..), runTestTT, (~=?))\n\nfindTetroid :: [Int] -> Char\nfindTetroid = match . toCoord\n\ntoCoord :: [Int] -> [(Int, Int)]\ntoCoord = map (`divMod` 10)\n\nmatch :: [(Int, Int)] -> Char\nmatch ps = maybe '-' snd $ find ((== dist) . fst) patterns\n  where\n    dist = findDist ps\n\nfindDist :: [(Int, Int)] -> [Int]\nfindDist = sort . map dist . combination\n\ndist :: ((Int, Int), (Int, Int)) -> Int\ndist ((x1, y1), (x2, y2)) = (x2 - x1) ^ 2 + (y2 - y1) ^ 2\n\ncombination :: [a] -> [(a,a)]\ncombination []     = []\ncombination (x:xs) = map ((,) x) xs ++ combination xs\n\npatterns :: [([Int], Char)]\npatterns =\n  [ ([1,1,1,1,2,2], 'O')\n  , ([1,1,1,2,2,4], 'T')\n  , ([1,1,1,2,2,5], 'S')\n  , ([1,1,1,2,4,5], 'L')\n  , ([1,1,1,4,4,9], 'I')\n  ]\n\n--------\n\n-- \u30c6\u30b9\u30c8\u30b3\u30fc\u30c9\u306f\u7701\u7565\n\n```", "tags": ["yhpg", "Haskell", "\u3069\u3046\u66f8\u304f"]}