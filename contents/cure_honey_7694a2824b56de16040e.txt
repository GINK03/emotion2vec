{"context": " More than 1 year has passed since last update.\n\nCoArray Fortran (CAF)\nCoArray Fortran \uff08CAF) \u3068\u306f\u3001Partitioned Global Address Space (PGAS) \u306b\u57fa\u3065\u304f\u5206\u6563\u4e26\u5217\u51e6\u7406\u6a5f\u80fd\u3092\u542b\u3093\u3060 Fortran \u306e\u3053\u3068\u3067\u3001\u304b\u3064\u3066\u306f F-- \u3068\u547c\u3070\u308c\u3066\u3044\u305f\u3082\u306e\u3067\u3059\u3002\u306e\u3061\u306b CoArray Fortran \u3068\u540d\u524d\u3092\u5909\u3048\u3001\u8b70\u8ad6\u306e\u672b ISO \u898f\u683c\u3068\u3057\u3066 Fortran2008 \u306e\u6a5f\u80fd\u3068\u3057\u3066\u6b63\u5f0f\u306b\u63a1\u7528\u3055\u308c\u307e\u3057\u305f\u3002\n\u601d\u60f3\u3068\u3057\u3066\u306f\u3001\u65e2\u5b58\u306eFortran \u306b\u6700\u5c0f\u9650\u306e\u62e1\u5f35\u3092\u65bd\u3057\u3066\u4e26\u5217\u30d7\u30ed\u30b0\u30e9\u30df\u30f3\u30b0\u3092\u53ef\u80fd\u306b\u3059\u308b\u3068\u3044\u3046\u3082\u306e\u3067\u3001\u30c7\u30fc\u30bf\u30d1\u30e9\u30ec\u30eb\u51e6\u7406\u6a5f\u80fd\u306e\u307f\u3092\u6301\u3063\u3066\u3044\u307e\u3059\u3002\u3053\u306e\u305f\u3081\u8272\u3005\u6a5f\u80fd\u4e0d\u8db3\u3067\u3001\u6b21\u306e Fortran \u898f\u683c\u3067\u306e\u6a5f\u80fd\u306e\u62e1\u5f35\u304c\u8ad6\u3058\u3089\u308c\u3066\u3044\u307e\u3059Draft TS 18508 Additional Parallel Features in Fortran\u3002\nCAF \u306f\u4e3b\u306b Cray \u304c\u624b\u304c\u3051\u3066\u3044\u305f\u3082\u306e\u3067\u300110 \u5e74\u4ee5\u4e0a\u3084\u3063\u3066\u3044\u307e\u3059\u304c\u3001\u4ed6\u306e PGAS \u8a00\u8a9e\u540c\u69d8\u30a4\u30de\u30a4\u30c1\u76db\u308a\u4e0a\u304c\u308a\u306b\u6b20\u3051\u307e\u3059\u3002\u6700\u8fd1\u3067\u306f Intel Fortran \u3084 GNU Fortran \u306a\u3069\u3067\u3082 CAF \u304c\u5229\u7528\u3067\u304d\u308b\u3088\u3046\u306b\u306a\u3063\u3066\u304d\u3066\u3044\u307e\u3059\u304c\u3001\u5b9f\u884c\u6027\u80fd\u304c\u51fa\u308b\u306e\u306f Cray \u3060\u3051\u3068\u3044\u3046\u3053\u3068\u3067\u3001\u4eca\u5f8c\u666e\u53ca\u3059\u308b\u304b\u898f\u683c\u304b\u3089\u53d6\u308a\u5916\u3055\u308c\u308b\u3053\u3068\u306b\u306a\u308b\u304b\u5c06\u6765\u306f\u307e\u3060\u4e0d\u660e\u3067\u3059\u3002\n\n\u5b9f\u884c\u7d50\u679c\n\n\u30b3\u30f3\u30bd\u30fc\u30eb\u51fa\u529b\nCAF \u306f\u3001\u3044\u308f\u3086\u308b Single Program Multiple Data (SPMD) \u578b\u306e\u8a00\u8a9e\u306b\u5c5e\u3059\u308b\u306e\u3067\u3001\u4e26\u5217\u52d5\u4f5c\u3059\u308b\u305d\u308c\u305e\u308c\u306e image \u3068\u547c\u3070\u308c\u308b CPU \u304c\u540c\u3058\u52d5\u4f5c\u3092\u3057\u307e\u3059\u3002\u3044\u307e\uff18\u500b\u306e image \u3067\u5b9f\u884c\u3057\u305f\u305f\u3081\u3001\u57fa\u672c\u7684\u306b\uff18\u500b\u306e\u91cd\u8907\u3059\u308b\u51fa\u529b\u304c\u306a\u3055\u308c\u3066\u3044\u307e\u3059\u3002\u305f\u3060 BMP \u30c7\u30fc\u30bf\u306e\u66f8\u304d\u51fa\u3057\u3060\u3051\u306f\u3001\u7b2c1 image \u3067\u306e\u307f\u884c\u3063\u3066\u3044\u307e\u3059\u3002\nimage=   8: time=       0.0000 cpu=       0.0000: start Mandel\nimage=   7: time=       0.0000 cpu=       0.0000: start Mandel\nimage=   4: time=       0.0000 cpu=       0.0000: start Mandel\nimage=   3: time=       0.0000 cpu=       0.0000: start Mandel\nimage=   2: time=       0.0000 cpu=       0.0000: start Mandel\nimage=   6: time=       0.0000 cpu=       0.0000: start Mandel\nimage=   5: time=       0.0000 cpu=       0.0000: start Mandel\nimage=   1: time=       0.0000 cpu=       0.0000: start Mandel\nimage=   8: time=       2.0300 cpu=       1.9531: end   Mandel\nimage=   7: time=       2.0450 cpu=       1.9688: end   Mandel\nimage=   2: time=       2.0210 cpu=       1.9688: end   Mandel\nimage=   1: time=       2.0440 cpu=       1.9688: end   Mandel\nimage=   3: time=       2.1300 cpu=       2.0625: end   Mandel\nimage=   4: time=       2.2500 cpu=       2.1719: end   Mandel\nimage=   6: time=       2.2430 cpu=       2.0625: end   Mandel\nimage=   5: time=       2.3270 cpu=       2.2344: end   Mandel\nimage=   6: time=       0.0890 cpu=       0.0000: normal end\nimage=   1: time=       0.2560 cpu=       0.0000: start bmp\nimage=   2: time=       0.3320 cpu=       0.0000: normal end\nimage=   8: time=       0.3540 cpu=       0.0000: normal end\nimage=   7: time=       0.3370 cpu=       0.0000: normal end\nimage=   3: time=       0.2480 cpu=       0.0000: normal end\nimage=   5: time=       0.0000 cpu=       0.0000: normal end\nimage=   4: time=       0.1290 cpu=       0.0000: normal end\nimage=   1: time=       0.0400 cpu=       0.0469: end   bmp\nimage=   1: time=       0.0000 cpu=       0.0000: normal end\n\u7d9a\u884c\u3059\u308b\u306b\u306f\u4f55\u304b\u30ad\u30fc\u3092\u62bc\u3057\u3066\u304f\u3060\u3055\u3044 . . .\n\n\n\n\u30d7\u30ed\u30b0\u30e9\u30e0\n\u3053\u3053\u3067\u306f\u3001\u8a08\u7b97\u9818\u57df\u3092\uff59\u8ef8\u65b9\u5411\u306b\u5206\u5272\u3057\u3066\u3001\u6a2a\u9577\u306e\u77ed\u518a\u72b6\u306e\u9818\u57df\u3067\u4e26\u5217\u8a08\u7b97\u3057\u307e\u3059\u3002\nI/O \u304c\u7d61\u3080 BMP \u30d5\u30a1\u30a4\u30eb\u751f\u6210\u3068\u51fa\u529b\u306f\u7b2c1 image \u306e\u307f\u3067\u884c\u3044\u307e\u3059\u3002\u3053\u306e\u6642\u3001\u5404 image \u6bce\u306b\u8a08\u7b97\u3057\u305f\u7d50\u679c\u3092\u7b2c1 image \u306b\u96c6\u7d04\u3059\u308b\u5fc5\u8981\u304c\u3042\u308b\u306e\u3067\u3001\u305d\u306e\u624b\u524d\u3067 sync all \u3092\u7528\u3044\u3066\u540c\u671f\u3092\u884c\u3044\u307e\u3059\u3002\n    module m_bmp\n      implicit none\n      type :: t_bmp_file_header\n        sequence  \n        integer(2) :: bfType = transfer('BM', 0_2, 1) ! BitMap\n        integer(4) :: bfSize          ! file size in bytes\n        integer(2) :: bfReserved1 = 0 ! always 0\n        integer(2) :: bfReserved2 = 0 ! always 0\n        integer(4) :: bfOffBits\n      end type t_bmp_file_header\n      ! \n      type :: t_bmp_info_header\n        sequence\n        integer(4) :: biSize     = Z'28' ! size of bmp_info_header ; 40bytes \n        integer(4) :: biWidth\n        integer(4) :: biHeight\n        integer(2) :: biPlanes   = 1 ! always 1\n        integer(2) :: biBitCount\n        integer(4) :: biCompression = 0 !0:nocompression,1:8bitRLE,2:4bitRLE,3:bitfield\n        integer(4) :: biSizeImage\n        integer(4) :: biXPelsPerMeter = 3780 ! 96dpi\n        integer(4) :: biYPelsPerMeter = 3780 ! 96dpi \n        integer(4) :: biClrUsed      = 0\n        integer(4) :: biClrImportant = 0 \n      end type t_bmp_info_header  \n      !\n      type :: t_rgb\n        sequence\n        character :: b, g, r  ! order is b g r \n      end type t_rgb \n      !\n      type :: t_bmp\n        type(t_rgb), allocatable :: rgb(:, :)\n      contains \n        procedure :: wr => wr_bmp\n      end type\n    contains   \n      subroutine wr_bmp(bmp, fn)\n        class(t_bmp), intent(in) :: bmp \n        character(len = *), intent(in) :: fn\n        type(t_bmp_file_header) :: bmp_file_header\n        type(t_bmp_info_header) :: bmp_info_header\n        associate(nx => size(bmp%rgb, 1), ny => size(bmp%rgb, 2))\n          bmp_file_header%bfSize      = 14 + 40 + 0 + nx * ny * 3\n          bmp_file_header%bfOffBits   = 14 + 40\n          bmp_info_header%biWidth     = nx       ! nx shouold be a multiple of 4\n          bmp_info_header%biHeight    = ny\n          bmp_info_header%biBitCount  = 24 \n          bmp_info_header%biSizeImage = nx * ny * 3\n        end associate\n        open(9, file = fn//'.bmp', form = 'binary', status = 'unknown')\n        write(9) bmp_file_header\n        write(9) bmp_info_header\n        write(9) bmp%rgb\n        close(9)\n        return\n      end subroutine wr_bmp\n ! convert to t_RGB    \n      pure elemental type(t_rgb) function to_rgb(ir, ig, ib)\n        integer, intent(in) :: ir, ig, ib\n        to_rgb = t_rgb(achar(ib), achar(ig), achar(ir))\n      end function to_rgb  \n    end module m_bmp\n\n    program Mandel\n      use m_bmp\n      implicit none\n      integer, parameter :: nx = 1920, ny = 1920, maxiter = 255\n      real   , parameter :: x0 = -2.0, x1 = 1.0, y0 = -1.5, y1 = 1.5\n      complex, allocatable :: c(:, :)[:], z(:, :)[:]\n      integer :: i, j, k, ni, my\n      integer, allocatable :: niter(:, :)[:]\n      ni = num_images()\n      k  = this_image()\n      if (mod(ny, ni) /= 0) stop 'ny must be a multiple of num_image()'\n      my = ny / ni\n      allocate(c(nx, my)[*], z(nx, my)[*])\n!\n! make 2D-mesh :  c(:, :)\n!      \n      block\n        real  :: x(nx), y(ny)\n        x = [( (x1 - x0) / (nx - 1) * (i - 1) + x0, i = 1, nx )]\n        y = [( (y1 - y0) / (ny - 1) * (i - 1) + y0, i = 1, ny )]\n        forall (i = 1:nx, j = 1:my) c(i, j)[k] = cmplx(x(i), y((k - 1) * my + j)) \n      end block\n !   \n ! main iteration : niter(:, :)        \n !     \n      call stamp('start Mandel')\n      allocate(niter(nx, my)[*])\n      do concurrent (i = 1:nx, j = 1:my)\n        niter(i, j)[k] = imandel(c(i, j)[k])  ! elemental function/forall  not working\n      end do  \n      call stamp('end   Mandel')\n !\n ! make bmp file in image 1 : Mandel.bmp   \n !\n      sync all\n      if (k == 1) then\n        call stamp('start bmp')\n        block          \n          type (t_bmp) :: bmp\n          integer :: m1, m2, kk, niter2(nx, ny)\n          do kk = 1, ni ! num_images()\n            m1 = (kk - 1) * my + 1\n            m2 = m1 + my - 1\n            niter2(:, m1:m2) = 256 - niter(:, :)[kk]  \n          end do\n\n          allocate(bmp%rgb(nx, ny))\n          bmp%rgb = to_rgb(niter2, niter2, niter2)\n          call bmp%wr('Mandel')\n        end block  \n        call stamp('end   bmp')\n      end if\n      call stamp('normal end')\n      sync all\n      stop\n    contains\n\n      pure elemental integer function imandel(c)\n        complex, intent(in) :: c\n        complex :: z\n        z = c\n        do imandel = 1, maxiter\n          if (abs(z) > 2.0) exit\n          z = z * z + c\n        end do    \n      end function imandel\n\n      subroutine stamp(text)\n        character(*), intent(in) :: text\n        real :: t0 = 0.0, t1      ! t0 save\n        integer :: c0 = 0, c1, cr ! c0 save\n        logical :: first = .true.\n        if (first) then \n          first = .false.\n          call cpu_time(t1)\n          call system_clock(c1, cr)\n          t0 = t1\n          c0 = c1\n        end if  \n        call cpu_time(t1)\n        call system_clock(c1, cr)\n        print '(a, i3, a, f12.4, a, f12.4, 2a)', 'image= ', this_image(), ': time= ', real(c1 - c0) / cr,' cpu= ', t1 - t0, ': ', text\n        t0 = t1\n        c0 = c1\n      end subroutine stamp\n    end program Mandel\n\n#CoArray Fortran (CAF)\nCoArray Fortran \uff08CAF) \u3068\u306f\u3001Partitioned Global Address Space (PGAS) \u306b\u57fa\u3065\u304f\u5206\u6563\u4e26\u5217\u51e6\u7406\u6a5f\u80fd\u3092\u542b\u3093\u3060 Fortran \u306e\u3053\u3068\u3067\u3001\u304b\u3064\u3066\u306f F-- \u3068\u547c\u3070\u308c\u3066\u3044\u305f\u3082\u306e\u3067\u3059\u3002\u306e\u3061\u306b CoArray Fortran \u3068\u540d\u524d\u3092\u5909\u3048\u3001\u8b70\u8ad6\u306e\u672b ISO \u898f\u683c\u3068\u3057\u3066 Fortran2008 \u306e\u6a5f\u80fd\u3068\u3057\u3066\u6b63\u5f0f\u306b\u63a1\u7528\u3055\u308c\u307e\u3057\u305f\u3002\n\n\u601d\u60f3\u3068\u3057\u3066\u306f\u3001\u65e2\u5b58\u306eFortran \u306b\u6700\u5c0f\u9650\u306e\u62e1\u5f35\u3092\u65bd\u3057\u3066\u4e26\u5217\u30d7\u30ed\u30b0\u30e9\u30df\u30f3\u30b0\u3092\u53ef\u80fd\u306b\u3059\u308b\u3068\u3044\u3046\u3082\u306e\u3067\u3001\u30c7\u30fc\u30bf\u30d1\u30e9\u30ec\u30eb\u51e6\u7406\u6a5f\u80fd\u306e\u307f\u3092\u6301\u3063\u3066\u3044\u307e\u3059\u3002\u3053\u306e\u305f\u3081\u8272\u3005\u6a5f\u80fd\u4e0d\u8db3\u3067\u3001\u6b21\u306e Fortran \u898f\u683c\u3067\u306e\u6a5f\u80fd\u306e\u62e1\u5f35\u304c\u8ad6\u3058\u3089\u308c\u3066\u3044\u307e\u3059[Draft TS 18508 Additional Parallel Features in Fortran](http://isotc.iso.org/livelink/livelink?func=ll&objId=16769292&objAction=Open)\u3002\n\nCAF \u306f\u4e3b\u306b Cray \u304c\u624b\u304c\u3051\u3066\u3044\u305f\u3082\u306e\u3067\u300110 \u5e74\u4ee5\u4e0a\u3084\u3063\u3066\u3044\u307e\u3059\u304c\u3001\u4ed6\u306e PGAS \u8a00\u8a9e\u540c\u69d8\u30a4\u30de\u30a4\u30c1\u76db\u308a\u4e0a\u304c\u308a\u306b\u6b20\u3051\u307e\u3059\u3002\u6700\u8fd1\u3067\u306f Intel Fortran \u3084 GNU Fortran \u306a\u3069\u3067\u3082 CAF \u304c\u5229\u7528\u3067\u304d\u308b\u3088\u3046\u306b\u306a\u3063\u3066\u304d\u3066\u3044\u307e\u3059\u304c\u3001\u5b9f\u884c\u6027\u80fd\u304c\u51fa\u308b\u306e\u306f Cray \u3060\u3051\u3068\u3044\u3046\u3053\u3068\u3067\u3001\u4eca\u5f8c\u666e\u53ca\u3059\u308b\u304b\u898f\u683c\u304b\u3089\u53d6\u308a\u5916\u3055\u308c\u308b\u3053\u3068\u306b\u306a\u308b\u304b\u5c06\u6765\u306f\u307e\u3060\u4e0d\u660e\u3067\u3059\u3002\n\n##\u5b9f\u884c\u7d50\u679c\n###\u30b3\u30f3\u30bd\u30fc\u30eb\u51fa\u529b\nCAF \u306f\u3001\u3044\u308f\u3086\u308b Single Program Multiple Data (SPMD) \u578b\u306e\u8a00\u8a9e\u306b\u5c5e\u3059\u308b\u306e\u3067\u3001\u4e26\u5217\u52d5\u4f5c\u3059\u308b\u305d\u308c\u305e\u308c\u306e image \u3068\u547c\u3070\u308c\u308b CPU \u304c\u540c\u3058\u52d5\u4f5c\u3092\u3057\u307e\u3059\u3002\u3044\u307e\uff18\u500b\u306e image \u3067\u5b9f\u884c\u3057\u305f\u305f\u3081\u3001\u57fa\u672c\u7684\u306b\uff18\u500b\u306e\u91cd\u8907\u3059\u308b\u51fa\u529b\u304c\u306a\u3055\u308c\u3066\u3044\u307e\u3059\u3002\u305f\u3060 BMP \u30c7\u30fc\u30bf\u306e\u66f8\u304d\u51fa\u3057\u3060\u3051\u306f\u3001\u7b2c1 image \u3067\u306e\u307f\u884c\u3063\u3066\u3044\u307e\u3059\u3002\n\n```\nimage=   8: time=       0.0000 cpu=       0.0000: start Mandel\nimage=   7: time=       0.0000 cpu=       0.0000: start Mandel\nimage=   4: time=       0.0000 cpu=       0.0000: start Mandel\nimage=   3: time=       0.0000 cpu=       0.0000: start Mandel\nimage=   2: time=       0.0000 cpu=       0.0000: start Mandel\nimage=   6: time=       0.0000 cpu=       0.0000: start Mandel\nimage=   5: time=       0.0000 cpu=       0.0000: start Mandel\nimage=   1: time=       0.0000 cpu=       0.0000: start Mandel\nimage=   8: time=       2.0300 cpu=       1.9531: end   Mandel\nimage=   7: time=       2.0450 cpu=       1.9688: end   Mandel\nimage=   2: time=       2.0210 cpu=       1.9688: end   Mandel\nimage=   1: time=       2.0440 cpu=       1.9688: end   Mandel\nimage=   3: time=       2.1300 cpu=       2.0625: end   Mandel\nimage=   4: time=       2.2500 cpu=       2.1719: end   Mandel\nimage=   6: time=       2.2430 cpu=       2.0625: end   Mandel\nimage=   5: time=       2.3270 cpu=       2.2344: end   Mandel\nimage=   6: time=       0.0890 cpu=       0.0000: normal end\nimage=   1: time=       0.2560 cpu=       0.0000: start bmp\nimage=   2: time=       0.3320 cpu=       0.0000: normal end\nimage=   8: time=       0.3540 cpu=       0.0000: normal end\nimage=   7: time=       0.3370 cpu=       0.0000: normal end\nimage=   3: time=       0.2480 cpu=       0.0000: normal end\nimage=   5: time=       0.0000 cpu=       0.0000: normal end\nimage=   4: time=       0.1290 cpu=       0.0000: normal end\nimage=   1: time=       0.0400 cpu=       0.0469: end   bmp\nimage=   1: time=       0.0000 cpu=       0.0000: normal end\n\u7d9a\u884c\u3059\u308b\u306b\u306f\u4f55\u304b\u30ad\u30fc\u3092\u62bc\u3057\u3066\u304f\u3060\u3055\u3044 . . .\n```\n![MandelCAF.png](https://qiita-image-store.s3.amazonaws.com/0/44522/87b364c6-79fb-9282-bfb7-13552da9a6e6.png)\n###\u30d7\u30ed\u30b0\u30e9\u30e0\n\u3053\u3053\u3067\u306f\u3001\u8a08\u7b97\u9818\u57df\u3092\uff59\u8ef8\u65b9\u5411\u306b\u5206\u5272\u3057\u3066\u3001\u6a2a\u9577\u306e\u77ed\u518a\u72b6\u306e\u9818\u57df\u3067\u4e26\u5217\u8a08\u7b97\u3057\u307e\u3059\u3002\nI/O \u304c\u7d61\u3080 BMP \u30d5\u30a1\u30a4\u30eb\u751f\u6210\u3068\u51fa\u529b\u306f\u7b2c1 image \u306e\u307f\u3067\u884c\u3044\u307e\u3059\u3002\u3053\u306e\u6642\u3001\u5404 image \u6bce\u306b\u8a08\u7b97\u3057\u305f\u7d50\u679c\u3092\u7b2c1 image \u306b\u96c6\u7d04\u3059\u308b\u5fc5\u8981\u304c\u3042\u308b\u306e\u3067\u3001\u305d\u306e\u624b\u524d\u3067 sync all \u3092\u7528\u3044\u3066\u540c\u671f\u3092\u884c\u3044\u307e\u3059\u3002\n\n```fortran\n    module m_bmp\n      implicit none\n      type :: t_bmp_file_header\n        sequence  \n        integer(2) :: bfType = transfer('BM', 0_2, 1) ! BitMap\n        integer(4) :: bfSize          ! file size in bytes\n        integer(2) :: bfReserved1 = 0 ! always 0\n        integer(2) :: bfReserved2 = 0 ! always 0\n        integer(4) :: bfOffBits\n      end type t_bmp_file_header\n      ! \n      type :: t_bmp_info_header\n        sequence\n        integer(4) :: biSize     = Z'28' ! size of bmp_info_header ; 40bytes \n        integer(4) :: biWidth\n        integer(4) :: biHeight\n        integer(2) :: biPlanes   = 1 ! always 1\n        integer(2) :: biBitCount\n        integer(4) :: biCompression = 0 !0:nocompression,1:8bitRLE,2:4bitRLE,3:bitfield\n        integer(4) :: biSizeImage\n        integer(4) :: biXPelsPerMeter = 3780 ! 96dpi\n        integer(4) :: biYPelsPerMeter = 3780 ! 96dpi \n        integer(4) :: biClrUsed      = 0\n        integer(4) :: biClrImportant = 0 \n      end type t_bmp_info_header  \n      !\n      type :: t_rgb\n        sequence\n        character :: b, g, r  ! order is b g r \n      end type t_rgb \n      !\n      type :: t_bmp\n        type(t_rgb), allocatable :: rgb(:, :)\n      contains \n        procedure :: wr => wr_bmp\n      end type\n    contains   \n      subroutine wr_bmp(bmp, fn)\n        class(t_bmp), intent(in) :: bmp \n        character(len = *), intent(in) :: fn\n        type(t_bmp_file_header) :: bmp_file_header\n        type(t_bmp_info_header) :: bmp_info_header\n        associate(nx => size(bmp%rgb, 1), ny => size(bmp%rgb, 2))\n          bmp_file_header%bfSize      = 14 + 40 + 0 + nx * ny * 3\n          bmp_file_header%bfOffBits   = 14 + 40\n          bmp_info_header%biWidth     = nx       ! nx shouold be a multiple of 4\n          bmp_info_header%biHeight    = ny\n          bmp_info_header%biBitCount  = 24 \n          bmp_info_header%biSizeImage = nx * ny * 3\n        end associate\n        open(9, file = fn//'.bmp', form = 'binary', status = 'unknown')\n        write(9) bmp_file_header\n        write(9) bmp_info_header\n        write(9) bmp%rgb\n        close(9)\n        return\n      end subroutine wr_bmp\n ! convert to t_RGB    \n      pure elemental type(t_rgb) function to_rgb(ir, ig, ib)\n        integer, intent(in) :: ir, ig, ib\n        to_rgb = t_rgb(achar(ib), achar(ig), achar(ir))\n      end function to_rgb  \n    end module m_bmp\n    \n    program Mandel\n      use m_bmp\n      implicit none\n      integer, parameter :: nx = 1920, ny = 1920, maxiter = 255\n      real   , parameter :: x0 = -2.0, x1 = 1.0, y0 = -1.5, y1 = 1.5\n      complex, allocatable :: c(:, :)[:], z(:, :)[:]\n      integer :: i, j, k, ni, my\n      integer, allocatable :: niter(:, :)[:]\n      ni = num_images()\n      k  = this_image()\n      if (mod(ny, ni) /= 0) stop 'ny must be a multiple of num_image()'\n      my = ny / ni\n      allocate(c(nx, my)[*], z(nx, my)[*])\n!\n! make 2D-mesh :  c(:, :)\n!      \n      block\n        real  :: x(nx), y(ny)\n        x = [( (x1 - x0) / (nx - 1) * (i - 1) + x0, i = 1, nx )]\n        y = [( (y1 - y0) / (ny - 1) * (i - 1) + y0, i = 1, ny )]\n        forall (i = 1:nx, j = 1:my) c(i, j)[k] = cmplx(x(i), y((k - 1) * my + j)) \n      end block\n !   \n ! main iteration : niter(:, :)        \n !     \n      call stamp('start Mandel')\n      allocate(niter(nx, my)[*])\n      do concurrent (i = 1:nx, j = 1:my)\n        niter(i, j)[k] = imandel(c(i, j)[k])  ! elemental function/forall  not working\n      end do  \n      call stamp('end   Mandel')\n !\n ! make bmp file in image 1 : Mandel.bmp   \n !\n      sync all\n      if (k == 1) then\n        call stamp('start bmp')\n        block          \n          type (t_bmp) :: bmp\n          integer :: m1, m2, kk, niter2(nx, ny)\n          do kk = 1, ni ! num_images()\n            m1 = (kk - 1) * my + 1\n            m2 = m1 + my - 1\n            niter2(:, m1:m2) = 256 - niter(:, :)[kk]  \n          end do\n\n          allocate(bmp%rgb(nx, ny))\n          bmp%rgb = to_rgb(niter2, niter2, niter2)\n          call bmp%wr('Mandel')\n        end block  \n        call stamp('end   bmp')\n      end if\n      call stamp('normal end')\n      sync all\n      stop\n    contains\n    \n      pure elemental integer function imandel(c)\n        complex, intent(in) :: c\n        complex :: z\n        z = c\n        do imandel = 1, maxiter\n          if (abs(z) > 2.0) exit\n          z = z * z + c\n        end do    \n      end function imandel\n      \n      subroutine stamp(text)\n        character(*), intent(in) :: text\n        real :: t0 = 0.0, t1      ! t0 save\n        integer :: c0 = 0, c1, cr ! c0 save\n        logical :: first = .true.\n        if (first) then \n          first = .false.\n          call cpu_time(t1)\n          call system_clock(c1, cr)\n          t0 = t1\n          c0 = c1\n        end if  \n        call cpu_time(t1)\n        call system_clock(c1, cr)\n        print '(a, i3, a, f12.4, a, f12.4, 2a)', 'image= ', this_image(), ': time= ', real(c1 - c0) / cr,' cpu= ', t1 - t0, ': ', text\n        t0 = t1\n        c0 = c1\n      end subroutine stamp\n    end program Mandel\n```\n\n\n \n", "tags": ["Fortran2008", "CAF"]}