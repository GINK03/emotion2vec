{"context": " More than 1 year has passed since last update.PRML 9.3.3\u306b\u8a18\u8f09\u306e\u901a\u308a\u3001EM\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0\u306b\u3088\u3063\u3066\u6df7\u5408\u30d9\u30eb\u30cc\u30fc\u30a4\u30e2\u30c7\u30eb\u306e\u6700\u5c24\u63a8\u5b9a\u304c\u884c\u308f\u308c\u308b\u904e\u7a0b\u3068\u3001\u5bfe\u6570\u5c24\u5ea6\u95a2\u6570\u306e\u53ce\u675f\u306e\u69d8\u5b50\u3092\u793a\u3057\u307e\u3059\u3002\n10\u6b21\u51432\u5024\u30b5\u30f3\u30d7\u30eb\u3092\u30013\u7a2e\u306e\u30d9\u30eb\u30cc\u30fc\u30a4\u5206\u5e03\u306b\u5f93\u3063\u3066\u3001150\u30b5\u30f3\u30d7\u30eb\u305a\u3064\u9806\u306b\u751f\u6210\u3057\u3001\u305d\u308c\u3089\u306e\u30b5\u30f3\u30d7\u30eb\u306b\u5bfe\u3059\u308b\u5bfe\u6570\u5c24\u5ea6\u3092\u6700\u5927\u5316\u3057\u307e\u3059\u3002EM\u30b9\u30c6\u30c3\u30d7\u6bce\u306b\u3001\u5404\u30b5\u30f3\u30d7\u30eb\u306b\u3064\u3044\u3066\u3001\u305d\u306e\u6df7\u5408\u8981\u7d20\u306e\u3046\u3061\u3001\u6700\u5927\u306e\u8ca0\u62c5\u7387\u03b3(z_nk)\u306e\u5024\u3092\u3001\u305d\u306e\u6df7\u5408\u8981\u7d20\u3092\u793a\u3059\u8272\u3067\u8a18\u3057\u307e\u3059\u3002\u307e\u305f\u3001\u5404\u6df7\u5408\u8981\u7d20\u306b\u3064\u3044\u3066\u3001\u30d9\u30eb\u30cc\u30fc\u30a4\u5206\u5e03\u306e\u30d1\u30e9\u30e1\u30fc\u30bf\u03bck\u306e\u5024\u3092\u793a\u3057\u307e\u3059\u3002\n\n\u307e\u305f\u3001MNIST\u306e\u624b\u66f8\u304d\u6570\u5b57\u6587\u5b57\u30c7\u30fc\u30bf\u304b\u3089\u751f\u6210\u3057\u305f784(=28x28)\u6b21\u51432\u5024\u30c7\u30fc\u30bf\u306b\u3064\u3044\u3066\u3001\u6570\u5b572,3,4\u3092\u5404150\u30b5\u30f3\u30d7\u30eb\u305a\u3064\u5229\u7528\u3057\u3001\u305d\u308c\u3089\u306e\u30b5\u30f3\u30d7\u30eb\u306b\u5bfe\u3059\u308b\u5bfe\u6570\u5c24\u5ea6\u3092\u6700\u5927\u5316\u3057\u307e\u3059\u3002\n\nframe()\nset.seed(0)\npar(mfrow=c(8, 4))\npar(mar=c(2.3, 2.5, 1, 0.1))\npar(mgp=c(1.3, .5, 0))\nMNIST <- F  # to load the MNIST handwritten digits\nK <- 3\nN <- 450\n\nrbern <- function(mu) {\n    ifelse(runif(length(mu)) < mu, 1, 0)\n}\nlogdbern <- function(x, mu) {\n    sum(log(mu ^ x * (1 - mu) ^ (1 - x)))\n}\nlogsumexp <- function (x) {\n  m <- max(x)\n  m + log(sum(exp(x - m)))\n}\n\nif (MNIST) {\n    # the following code is taken from https://gist.github.com/brendano/39760\n    load_mnist <- function() {\n      load_image_file <- function(filename) {\n        ret = list()\n        f = file(filename,'rb')\n        readBin(f,'integer',n=1,size=4,endian='big')\n        ret$n = readBin(f,'integer',n=1,size=4,endian='big')\n        nrow = readBin(f,'integer',n=1,size=4,endian='big')\n        ncol = readBin(f,'integer',n=1,size=4,endian='big')\n        x = readBin(f,'integer',n=ret$n*nrow*ncol,size=1,signed=F)\n        ret$x = matrix(x, ncol=nrow*ncol, byrow=T)\n        close(f)\n        ret\n      }\n      load_label_file <- function(filename) {\n        f = file(filename,'rb')\n        readBin(f,'integer',n=1,size=4,endian='big')\n        n = readBin(f,'integer',n=1,size=4,endian='big')\n        y = readBin(f,'integer',n=n,size=1,signed=F)\n        close(f)\n        y\n      }\n      train <<- load_image_file('mnist/train-images-idx3-ubyte')\n      train$y <<- load_label_file('mnist/train-labels-idx1-ubyte')\n    }\n    # the data is available at http://yann.lecun.com/exdb/mnist/\n    # extract the files in the \"mnist\" directory\n    setwd(\"C:/Users/Public/Documents\")\n    load_mnist()\n    x <- floor(rbind(\n        train$x[train$y == 2, ][1:(N / 3), ],  \n        train$x[train$y == 3, ][1:(N / 3), ],  \n        train$x[train$y == 4, ][1:(N / 3), ]) / 128)\n    D <- ncol(x)\n} else {\n    PHI <- 0.9\n    PLO <- 0.1\n    muorg <- matrix(c(\n        PHI, PHI, PHI, PHI, PHI, PLO, PLO, PLO, PLO, PLO, \n        PLO, PLO, PLO, PLO, PLO, PHI, PHI, PHI, PHI, PHI, \n        PHI, PHI, PHI, PLO, PLO, PLO, PLO, PHI, PHI, PHI\n        ), 3, byrow=T)\n    z <- rep(1:3, each=N/3)\n    x <- rbern(muorg[z, ])\n    D <- 10\n}\nimage(1:N, 1:D, x, xlab=\"n\", ylab=\"i\", breaks=seq(0, 1, 0.1), \n    col=hsv(0, seq(0.1, 1, 0.1), 1))\ntitle(\"sample\")\n\nmu <- matrix(runif(D * K), K, byrow=T)\npz <- rep(1 / K, K)\ngamma <- matrix(NA, nrow=N, ncol=K)\nlikelihood <- numeric()\n\niteration <- 0\nrepeat {\n    cat(\"mu\\n\");print(mu)\n    cat(\"pi\\n\");print(pz)\n\n    if (!is.na(gamma[1, 1])) {\n        plot(apply(gamma, 1, max), col=hsv(apply(gamma, 1, which.max) / K, 1, 1), \n            ylim=c(0, 1.05), pch=20, xlab=\"n\", ylab=expression(gamma(z_nk)))\n        title(paste0(\"gamma#\", iteration))\n    }\n\n    if (MNIST) {\n        image(1:28, 1:(28*K), matrix(as.vector(t(mu + rep(0:(K-1), D) + 1.0E-8)), nrow=28)[, (28*K):1], \n            axes=F, xlab=\"i\", ylab=\"k\", \n            breaks=seq(0, K, 0.1), \n            col=outer(seq(0.1, 1, 0.1), (1:K)/K, function(x1, x2) hsv(x2, x1, 1)))\n        axis(1)\n        axis(2, at=0:(K-1) * 28 + 14, labels=1:K)\n    } else {\n        image(1:K, 1:D, mu + rep(0:(K-1), D) + 1.0E-8, \n            axes=F, xlab=\"k\", ylab=\"i\",\n            breaks=seq(0, K, 0.1), \n            col=outer(seq(0.1, 1, 0.1), (1:K)/K, function(x1, x2) hsv(x2, x1, 1)))\n        axis(1, at=1:K)\n        axis(2)\n    }\n    title(paste0(\"mu#\", iteration))\n\n    # E step\n    for (n in 1:N) {\n        pzx <- sapply(\n            1:K, \n            function(k) log(pz[k]) + logdbern(x[n, ], mu[k, ])\n            )\n        pzx <- pzx - max(pzx)\n        gamma[n, ] <- exp(pzx) / sum(exp(pzx))\n    }\n\n    # M step\n    nk <- colSums(gamma)\n    for (k in 1:K) {\n        mu[k, ] <- colSums(x * gamma[, k]) / nk[k]\n        pz[k] <- nk[k] / N\n    }\n\n    # likelihood\n    likelihood <- c(likelihood, sum(sapply(1:N, function(n)\n            logsumexp(sapply(\n                1:K, \n                function(k)\n                    log(pz[k]) + logdbern(x[n, ], mu[k, ])\n                ))\n            )))\n\n    if (length(likelihood) > 1 \n        && likelihood[length(likelihood)] - likelihood[length(likelihood) - 1] < 1.0E-2) {\n        break\n    }\n    iteration <- iteration + 1\n}\n\nplot(likelihood, type=\"l\", xlab=\"iteration\", ylab=\"ln p(X)\")\ntitle(\"ln p(X)\")\n\nPRML 9.3.3\u306b\u8a18\u8f09\u306e\u901a\u308a\u3001EM\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0\u306b\u3088\u3063\u3066\u6df7\u5408\u30d9\u30eb\u30cc\u30fc\u30a4\u30e2\u30c7\u30eb\u306e\u6700\u5c24\u63a8\u5b9a\u304c\u884c\u308f\u308c\u308b\u904e\u7a0b\u3068\u3001\u5bfe\u6570\u5c24\u5ea6\u95a2\u6570\u306e\u53ce\u675f\u306e\u69d8\u5b50\u3092\u793a\u3057\u307e\u3059\u3002\n\n10\u6b21\u51432\u5024\u30b5\u30f3\u30d7\u30eb\u3092\u30013\u7a2e\u306e\u30d9\u30eb\u30cc\u30fc\u30a4\u5206\u5e03\u306b\u5f93\u3063\u3066\u3001150\u30b5\u30f3\u30d7\u30eb\u305a\u3064\u9806\u306b\u751f\u6210\u3057\u3001\u305d\u308c\u3089\u306e\u30b5\u30f3\u30d7\u30eb\u306b\u5bfe\u3059\u308b\u5bfe\u6570\u5c24\u5ea6\u3092\u6700\u5927\u5316\u3057\u307e\u3059\u3002EM\u30b9\u30c6\u30c3\u30d7\u6bce\u306b\u3001\u5404\u30b5\u30f3\u30d7\u30eb\u306b\u3064\u3044\u3066\u3001\u305d\u306e\u6df7\u5408\u8981\u7d20\u306e\u3046\u3061\u3001\u6700\u5927\u306e\u8ca0\u62c5\u7387\u03b3(z_nk)\u306e\u5024\u3092\u3001\u305d\u306e\u6df7\u5408\u8981\u7d20\u3092\u793a\u3059\u8272\u3067\u8a18\u3057\u307e\u3059\u3002\u307e\u305f\u3001\u5404\u6df7\u5408\u8981\u7d20\u306b\u3064\u3044\u3066\u3001\u30d9\u30eb\u30cc\u30fc\u30a4\u5206\u5e03\u306e\u30d1\u30e9\u30e1\u30fc\u30bf\u03bck\u306e\u5024\u3092\u793a\u3057\u307e\u3059\u3002\n\n![](https://dl.dropbox.com/sh/cwfemibvr7gk4cy/WNqdUmrkB4/23.BernoulliMixtureEM1.png)\n\n\u307e\u305f\u3001[MNIST](http://yann.lecun.com/exdb/mnist/)\u306e\u624b\u66f8\u304d\u6570\u5b57\u6587\u5b57\u30c7\u30fc\u30bf\u304b\u3089\u751f\u6210\u3057\u305f784(=28x28)\u6b21\u51432\u5024\u30c7\u30fc\u30bf\u306b\u3064\u3044\u3066\u3001\u6570\u5b572,3,4\u3092\u5404150\u30b5\u30f3\u30d7\u30eb\u305a\u3064\u5229\u7528\u3057\u3001\u305d\u308c\u3089\u306e\u30b5\u30f3\u30d7\u30eb\u306b\u5bfe\u3059\u308b\u5bfe\u6570\u5c24\u5ea6\u3092\u6700\u5927\u5316\u3057\u307e\u3059\u3002\n\n![](https://dl.dropbox.com/sh/cwfemibvr7gk4cy/KmXwDSraZ2/23.BernoulliMixtureEM2.png)\n\n```r\nframe()\nset.seed(0)\npar(mfrow=c(8, 4))\npar(mar=c(2.3, 2.5, 1, 0.1))\npar(mgp=c(1.3, .5, 0))\nMNIST <- F  # to load the MNIST handwritten digits\nK <- 3\nN <- 450\n\nrbern <- function(mu) {\n\tifelse(runif(length(mu)) < mu, 1, 0)\n}\nlogdbern <- function(x, mu) {\n\tsum(log(mu ^ x * (1 - mu) ^ (1 - x)))\n}\nlogsumexp <- function (x) {\n  m <- max(x)\n  m + log(sum(exp(x - m)))\n}\n\nif (MNIST) {\n\t# the following code is taken from https://gist.github.com/brendano/39760\n\tload_mnist <- function() {\n\t  load_image_file <- function(filename) {\n\t    ret = list()\n\t    f = file(filename,'rb')\n\t    readBin(f,'integer',n=1,size=4,endian='big')\n\t    ret$n = readBin(f,'integer',n=1,size=4,endian='big')\n\t    nrow = readBin(f,'integer',n=1,size=4,endian='big')\n\t    ncol = readBin(f,'integer',n=1,size=4,endian='big')\n\t    x = readBin(f,'integer',n=ret$n*nrow*ncol,size=1,signed=F)\n\t    ret$x = matrix(x, ncol=nrow*ncol, byrow=T)\n\t    close(f)\n\t    ret\n\t  }\n\t  load_label_file <- function(filename) {\n\t    f = file(filename,'rb')\n\t    readBin(f,'integer',n=1,size=4,endian='big')\n\t    n = readBin(f,'integer',n=1,size=4,endian='big')\n\t    y = readBin(f,'integer',n=n,size=1,signed=F)\n\t    close(f)\n\t    y\n\t  }\n\t  train <<- load_image_file('mnist/train-images-idx3-ubyte')\n\t  train$y <<- load_label_file('mnist/train-labels-idx1-ubyte')\n\t}\n\t# the data is available at http://yann.lecun.com/exdb/mnist/\n\t# extract the files in the \"mnist\" directory\n\tsetwd(\"C:/Users/Public/Documents\")\n\tload_mnist()\n\tx <- floor(rbind(\n\t\ttrain$x[train$y == 2, ][1:(N / 3), ],  \n\t\ttrain$x[train$y == 3, ][1:(N / 3), ],  \n\t\ttrain$x[train$y == 4, ][1:(N / 3), ]) / 128)\n\tD <- ncol(x)\n} else {\n\tPHI <- 0.9\n\tPLO <- 0.1\n\tmuorg <- matrix(c(\n\t\tPHI, PHI, PHI, PHI, PHI, PLO, PLO, PLO, PLO, PLO, \n\t\tPLO, PLO, PLO, PLO, PLO, PHI, PHI, PHI, PHI, PHI, \n\t\tPHI, PHI, PHI, PLO, PLO, PLO, PLO, PHI, PHI, PHI\n\t\t), 3, byrow=T)\n\tz <- rep(1:3, each=N/3)\n\tx <- rbern(muorg[z, ])\n\tD <- 10\n}\nimage(1:N, 1:D, x, xlab=\"n\", ylab=\"i\", breaks=seq(0, 1, 0.1), \n\tcol=hsv(0, seq(0.1, 1, 0.1), 1))\ntitle(\"sample\")\n\nmu <- matrix(runif(D * K), K, byrow=T)\npz <- rep(1 / K, K)\ngamma <- matrix(NA, nrow=N, ncol=K)\nlikelihood <- numeric()\n\niteration <- 0\nrepeat {\n\tcat(\"mu\\n\");print(mu)\n\tcat(\"pi\\n\");print(pz)\n\t\n\tif (!is.na(gamma[1, 1])) {\n\t\tplot(apply(gamma, 1, max), col=hsv(apply(gamma, 1, which.max) / K, 1, 1), \n\t\t\tylim=c(0, 1.05), pch=20, xlab=\"n\", ylab=expression(gamma(z_nk)))\n\t\ttitle(paste0(\"gamma#\", iteration))\n\t}\n\t\n\tif (MNIST) {\n\t\timage(1:28, 1:(28*K), matrix(as.vector(t(mu + rep(0:(K-1), D) + 1.0E-8)), nrow=28)[, (28*K):1], \n\t\t\taxes=F, xlab=\"i\", ylab=\"k\", \n\t\t\tbreaks=seq(0, K, 0.1), \n\t\t\tcol=outer(seq(0.1, 1, 0.1), (1:K)/K, function(x1, x2) hsv(x2, x1, 1)))\n\t\taxis(1)\n\t\taxis(2, at=0:(K-1) * 28 + 14, labels=1:K)\n\t} else {\n\t\timage(1:K, 1:D, mu + rep(0:(K-1), D) + 1.0E-8, \n\t\t\taxes=F, xlab=\"k\", ylab=\"i\",\n\t\t\tbreaks=seq(0, K, 0.1), \n\t\t\tcol=outer(seq(0.1, 1, 0.1), (1:K)/K, function(x1, x2) hsv(x2, x1, 1)))\n\t\taxis(1, at=1:K)\n\t\taxis(2)\n\t}\n\ttitle(paste0(\"mu#\", iteration))\n\n\t# E step\n\tfor (n in 1:N) {\n\t\tpzx <- sapply(\n\t\t\t1:K, \n\t\t\tfunction(k) log(pz[k]) + logdbern(x[n, ], mu[k, ])\n\t\t\t)\n\t\tpzx <- pzx - max(pzx)\n\t\tgamma[n, ] <- exp(pzx) / sum(exp(pzx))\n\t}\n\t\n\t# M step\n\tnk <- colSums(gamma)\n\tfor (k in 1:K) {\n\t\tmu[k, ] <- colSums(x * gamma[, k]) / nk[k]\n\t\tpz[k] <- nk[k] / N\n\t}\n\t\n\t# likelihood\n\tlikelihood <- c(likelihood, sum(sapply(1:N, function(n)\n\t\t\tlogsumexp(sapply(\n\t\t\t\t1:K, \n\t\t\t\tfunction(k)\n\t\t\t\t\tlog(pz[k]) + logdbern(x[n, ], mu[k, ])\n\t\t\t\t))\n\t\t\t)))\n\t\n\tif (length(likelihood) > 1 \n\t\t&& likelihood[length(likelihood)] - likelihood[length(likelihood) - 1] < 1.0E-2) {\n\t\tbreak\n\t}\n\titeration <- iteration + 1\n}\n\nplot(likelihood, type=\"l\", xlab=\"iteration\", ylab=\"ln p(X)\")\ntitle(\"ln p(X)\")\n```\n\n\n", "tags": ["R", "PRML"]}