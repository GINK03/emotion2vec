{"context": "\n\nIsotope\u3068\u306f\n\u9ad8\u3055\u3084\u5e45\u304c\u7570\u306a\u308b\u30d1\u30cd\u30eb\u3092\u304d\u308c\u3044\u306b\u30ec\u30f3\u30ac\u72b6\u306b\u914d\u7f6e\u3059\u308bjQuery\u306e\u30d7\u30e9\u30b0\u30a4\u30f3\nhttp://isotope.metafizzy.co/\n\n\u6a5f\u80fd:\u30d5\u30a3\u30eb\u30bf\u30fc\u6a5f\u80fd\u3001\u30bd\u30fc\u30c8\u6a5f\u80fd\n\u30e9\u30a4\u30bb\u30f3\u30b9:Commercial License\u3000$25~\nhttp://isotope.metafizzy.co/#commercial-license\n\u4f7f\u7528\u30b5\u30a4\u30c8\u4f8b\nhttp://isotope.metafizzy.co/#isotope-in-use\n\n\nhttp://malikafavre.com/\n\n\u4f7f\u3044\u65b9 \u57fa\u672c\n\nhtml\u306eclass\u89aa\u8981\u7d20\u3068\u3001\u5404\u8981\u7d20\u306b\u5b50\u8981\u7d20\u3092\u3064\u3051\u308b\n\n\n$('\u89aa\u8981\u7d20\u306eid or \u30af\u30e9\u30b9\u540d').isotope({\n//\u3053\u3053\u306b\u51e6\u7406\u3092\u66f8\u304f\n});\n\n\nitemSelector(\u52d5\u304b\u3059\u8981\u7d20\u306e\u30af\u30e9\u30b9\u540d\u3092\u66f8\u304f)\n\n$('\u89aa\u8981\u7d20\u306eid or \u30af\u30e9\u30b9\u540d').isotope({\n  itemSelector: '\u52d5\u304b\u3059\u8981\u7d20\u306e\u30af\u30e9\u30b9\u540d',\n  percentPosition: true,\n  masonry: {\n    columnWidth: '\u52d5\u304b\u3059\u8981\u7d20\u306e\u6a2a\u5e45(\u30af\u30e9\u30b9\u540d\u3067\u3082\u3088\u3044)'\n  }\n});\n\nmasonry(columnWidth)\u306e\u8a2d\u5b9a\u3092\u3057\u3066\u3044\u308b\u306e\u306f\u306a\u305c\u304b\uff1f\n\n\u8981\u7d20\u306e\u6a2a\u5e45\u306b\u95a2\u308f\u3089\u305a\u3001\u30ab\u30e9\u30e0\u306e\u6a2a\u5e45\u3092\u8a2d\u5b9a\u3067\u304d\u308b\u3002\n\n[\u6ce8\u610f\u70b9]\n\u5b9f\u969b\u306e\u8981\u7d20\u306e\u6a2a\u5e45:500px\ncolumnWidth\u306e\u6307\u5b9a:100px\n\u4e0a\u8a18\u306e\u5834\u5408\u3001columnWidth\u306f\u4e0a\u66f8\u304d\u3055\u308c\u3066\u3001\u8981\u7d20500px\u304c\u8868\u793a\u3055\u308c\u308b\u306e\u3067\u6ce8\u610f\u3002\n\n\n\u30b5\u30f3\u30d7\u30eb\n\n\u30d6\u30e9\u30a6\u30b6\u30b5\u30a4\u30ba(\u6a2a\u5e45)\u306b\u3088\u3063\u3066\u8981\u7d20\u306e\u4e26\u3073\u304c\u5909\u308f\u308b\n\n\u6a2a\u5e451000px\n\n\u6a2a\u5e45500px\n\n\nindex.html\n\n<!DOCTYPE html>\n<html>\n<head>\n<meta charset=\"UTF-8\">\n<title>masonry layout mode</title>\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\n<link rel=\"stylesheet\" href=\"css/style.css\">\n</head>\n<body>\n<h1>masonry layout mode</h1>\n<div class=\"grid\">\n  <div class=\"grid-item layout1\">1</div>\n  <div class=\"grid-item layout2\">2</div>\n  <div class=\"grid-item layout1\">3</div>\n  <div class=\"grid-item layout3\">4</div>\n  <div class=\"grid-item layout1\">5</div>\n  <div class=\"grid-item layout3\">6</div>\n  <div class=\"grid-item layout1\">7</div>\n  <div class=\"grid-item layout2\">8</div>\n</div>\n\n<script src='http://cdnjs.cloudflare.com/ajax/libs/jquery/2.2.2/jquery.min.js'></script>\n<script src='http://npmcdn.com/isotope-layout@3/dist/isotope.pkgd.js'></script>\n<script src=\"js/main.js\"></script>\n\n</body>\n</html>\n\n\n\nstyle.css\n\n* {box-sizing: border-box;}\n.grid {\n  background: #CCC;\n  max-width: 1000px;\n}\n/* clear fix */\n.grid:after {\n  content: '';\n  display: block;\n  clear: both;\n}\n.grid-item {\n  float: left;\n  width: 100px;\n  height: 100px;\n  background: #0D8;\n}\n.layout1{\n  width: 200px;\n  border:1px solid #000;\n}\n.layout2 {\n  height: 200px;\n  border:1px solid #000;\n}\n.layout3{\n  width: 200px;\n  height: 200px;\n  border:1px solid #000;\n}\n\n\n\nmain.js\n\n$('.grid').isotope({\n  itemSelector:'.grid-item',\n  masonry: {\n    columnWidth:100\n  }\n});\n\n\n\u88dc\u8db3:\n\nisotope\u3092\u4f7f\u3063\u3066\u3044\u306a\u3044\u5834\u5408(\u3059\u304d\u307e\u306b\u306f\u5165\u3089\u306a\u3044)\n\n\n\n\nmasonry\u306b\u3064\u3044\u3066\nhttp://isotope.metafizzy.co/layout-modes/masonry.html\n\u4ee5\u4e0b\u306e2\u3064\u3092\u899a\u3048\u3066\u304a\u3051\u3070\u3088\u3044\n\n1.columnWidth(\u8a2d\u5b9a\u5fc5\u9808)\n\n\u6c34\u5e73\u30b0\u30ea\u30c3\u30c9\u306b\u30a2\u30a4\u30c6\u30e0\u3092\u63c3\u3048\u308b\u3002\ncolumnWidth\u8a2d\u5b9a\u3092\u3057\u306a\u3044\u5834\u5408\u3001\n\u300c\u6700\u521d\u306e\u30a2\u30a4\u30c6\u30e0\u306e\u6a2a\u5e45\u300d\u304c\u4f7f\u7528\u3055\u308c\u308b\u3002\u6a2a\u5e45200\u304c\u8a2d\u5b9a\u3055\u308c\u3066\u3044\u308b\u5834\u5408\u306f\u4ee5\u4e0b\u306b\u306a\u308b\u3002\n\n\n\n2.fluid sizing(\u8981\u7d20\u306e%\u8868\u793a)\u3000\npercentPosition:true\nhttp://codepen.io/desandro/pen/mIkhq\n\nindex.html\n\n<body>\n\n<div class=\"grid\">\n  <div class=\"grid-sizer\"></div>\n  <div class=\"grid-item\">1</div>\n  <div class=\"grid-item\">2</div>\n  <div class=\"grid-item\">3</div>\n</div>\n\n<script src='http://cdnjs.cloudflare.com/ajax/libs/jquery/2.2.2/jquery.min.js'></script>\n<script src='http://npmcdn.com/isotope-layout@3/dist/isotope.pkgd.js'></script>\n<script src=\"js/main.js\"></script>\n\n</body>\n\n\n\nstyle.css\n\n* {box-sizing: border-box;}\n\n/* clear fix */\n.grid:after {\n  content: '';\n  display: block;\n  clear: both;\n}\n\n.grid {\n  background:#CCC;\n}\n\n.grid-item,\n.grid-sizer {\n  width:33.3%;\n}\n\n.grid-item {\n  float:left;\n  height: 100px;\n  background: #0D8;\n  border: 1px solid #333;\n}\n\n\n\nmain.js\n\n  $('.grid').isotope({\n    itemSelector:'.grid-item',\n    percentPosition: true,\n    masonry: {\n      columnWidth: '.grid-sizer'\n    }\n  });\n\n\n\n\n\nfitRows\nhttp://codepen.io/desandro/pen/nCskp\n\nfitRows\u306f\u540c\u3058\u9ad8\u3055\u3092\u6301\u3063\u3066\u3044\u308b\u30a2\u30a4\u30c6\u30e0\u306b\u6700\u9069\u3002\n\n\nfilter\n\n$('.grid').isotope({\nfilter: '.metal'\n\n});\n\n\u4f8b\u3048\u3070\u3001html\u5074\u306bdata-filter\u3092\u8a18\u8ff0\u3057\u3066\u304a\u304d\u3001filter\u306b\u6307\u5b9a\u3059\u308b\u8981\u7d20\u3092\u52d5\u7684\u306b\u3059\u308b\u3002\n\n$('.filter-button-group').on( 'click', 'button', function() {\n  var filterValue = $(this).attr('data-filter');\n  $grid.isotope({ filter: filterValue });\n});\n\n\u8907\u6570\u306e\u30ab\u30c6\u30b4\u30ea\u30fc\u3092\u7d44\u307f\u5408\u308f\u305b\u3067\u30d5\u30a3\u30eb\u30bf\u30fc\u3059\u308b\u4f8b\u306f\u3001\u300cCombination filters\u300d\u306e\u30b5\u30f3\u30d7\u30eb\u304c\u5206\u304b\u308a\u3084\u3059\u3044\u3002\nhttp://codepen.io/desandro/pen/JEojz\n\n\n\u305d\u306e\u4ed6\u306e\u30b5\u30f3\u30d7\u30eb\nsorting by selected category\n\u30bd\u30fc\u30c8\u5bfe\u8c61\u5916\u306e\u8981\u7d20\u306fopacity\u306b\u5909\u5316\nhttp://codepen.io/desandro/pen/zGZywM\n\n\u30a2\u30cb\u30e1\u30fc\u30b7\u30e7\u30f3\n\u30c7\u30d5\u30a9\u30eb\u30c8\u306f\u4ee5\u4e0b\u306e\u8a2d\u5b9a\nhttp://isotope.metafizzy.co/v1/docs/animating.html\n\n.\u89aa\u8981\u7d20{\ntransition-duration: 0.8s;\ntransition-property: height, width;\n}\n\n.\u5b50\u8981\u7d20{\ntransition-duration:0.2s;\ntransition-property:height, width;\ntransition-property:transform, opacity;\n}\n\n\u30d0\u30ea\u30a8\u30fc\u30b7\u30e7\u30f3\n\nJquery\u306e\u30a2\u30cb\u30e1\u30fc\u30b7\u30e7\u30f3\u3092\u4f7f\u3046\n\n\n\u30a8\u30e9\u30fc\u5bfe\u7b56\u306b\u3064\u3044\u3066\n\n\u30ed\u30fc\u30c9\u3059\u308b\u3068\u30d1\u30cd\u30eb\u540c\u58eb\u304c\u91cd\u306a\u3063\u3066\u3057\u307e\u3046\u5834\u5408\n\n\u539f\u56e0:\u30da\u30fc\u30b8\u3092\u5168\u3066\u30ed\u30fc\u30c9\u3059\u308b\u524d\u306bIsotope\u304c\u9ad8\u3055\u3092\u8a08\u7b97\u3057\u3066\u3057\u307e\u3044\u3001\u6b63\u78ba\u306a\u9ad8\u3055\u304c\u53d6\u308c\u306a\u3044\n\u4ee5\u4e0b\u3067\u89e3\u6c7a\n\n\n\u753b\u50cf\u3082\u542b\u3081\u305f\u30da\u30fc\u30b8\u304c\u5b8c\u5168\u306b\u8aad\u307f\u8fbc\u307e\u308c\u305f\u3089\u51e6\u7406.js\n\n    $(window).load(function(){\n      // \u3053\u3053\u306bIsotope\u8a18\u8ff0\n    });\n\n\n\n\n\nIsotope v1.5.25 \u5168\u30bd\u30fc\u30b9\n\nIsotope_v1.5.25.js\n\n/**\n * Isotope v1.5.25\n * An exquisite jQuery plugin for magical layouts\n * http://isotope.metafizzy.co\n *\n * Commercial use requires one-time license fee\n * http://metafizzy.co/#licenses\n *\n * Copyright 2012 David DeSandro / Metafizzy\n */\n\n/*jshint asi: true, browser: true, curly: true, eqeqeq: true, forin: false, immed: false, newcap: true, noempty: true, strict: true, undef: true */\n/*global jQuery: false */\n\n(function( window, $, undefined ){\n\n  'use strict';\n\n  // get global vars\n  var document = window.document;\n  var Modernizr = window.Modernizr;\n\n  // helper function\n  var capitalize = function( str ) {\n    return str.charAt(0).toUpperCase() + str.slice(1);\n  };\n\n  // ========================= getStyleProperty by kangax ===============================\n  // http://perfectionkills.com/feature-testing-css-properties/\n\n  var prefixes = 'Moz Webkit O Ms'.split(' ');\n\n  var getStyleProperty = function( propName ) {\n    var style = document.documentElement.style,\n        prefixed;\n\n    // test standard property first\n    if ( typeof style[propName] === 'string' ) {\n      return propName;\n    }\n\n    // capitalize\n    propName = capitalize( propName );\n\n    // test vendor specific properties\n    for ( var i=0, len = prefixes.length; i < len; i++ ) {\n      prefixed = prefixes[i] + propName;\n      if ( typeof style[ prefixed ] === 'string' ) {\n        return prefixed;\n      }\n    }\n  };\n\n  var transformProp = getStyleProperty('transform'),\n      transitionProp = getStyleProperty('transitionProperty');\n\n\n  // ========================= miniModernizr ===============================\n  // <3<3<3 and thanks to Faruk and Paul for doing the heavy lifting\n\n  /*!\n   * Modernizr v1.6ish: miniModernizr for Isotope\n   * http://www.modernizr.com\n   *\n   * Developed by:\n   * - Faruk Ates  http://farukat.es/\n   * - Paul Irish  http://paulirish.com/\n   *\n   * Copyright (c) 2009-2010\n   * Dual-licensed under the BSD or MIT licenses.\n   * http://www.modernizr.com/license/\n   */\n\n  /*\n   * This version whittles down the script just to check support for\n   * CSS transitions, transforms, and 3D transforms.\n  */\n\n  var tests = {\n    csstransforms: function() {\n      return !!transformProp;\n    },\n\n    csstransforms3d: function() {\n      var test = !!getStyleProperty('perspective');\n      // double check for Chrome's false positive\n      if ( test ) {\n        var vendorCSSPrefixes = ' -o- -moz- -ms- -webkit- -khtml- '.split(' '),\n            mediaQuery = '@media (' + vendorCSSPrefixes.join('transform-3d),(') + 'modernizr)',\n            $style = $('<style>' + mediaQuery + '{#modernizr{height:3px}}' + '</style>')\n                        .appendTo('head'),\n            $div = $('<div id=\"modernizr\" />').appendTo('html');\n\n        test = $div.height() === 3;\n\n        $div.remove();\n        $style.remove();\n      }\n      return test;\n    },\n\n    csstransitions: function() {\n      return !!transitionProp;\n    }\n  };\n\n  var testName;\n\n  if ( Modernizr ) {\n    // if there's a previous Modernzir, check if there are necessary tests\n    for ( testName in tests) {\n      if ( !Modernizr.hasOwnProperty( testName ) ) {\n        // if test hasn't been run, use addTest to run it\n        Modernizr.addTest( testName, tests[ testName ] );\n      }\n    }\n  } else {\n    // or create new mini Modernizr that just has the 3 tests\n    Modernizr = window.Modernizr = {\n      _version : '1.6ish: miniModernizr for Isotope'\n    };\n\n    var classes = ' ';\n    var result;\n\n    // Run through tests\n    for ( testName in tests) {\n      result = tests[ testName ]();\n      Modernizr[ testName ] = result;\n      classes += ' ' + ( result ?  '' : 'no-' ) + testName;\n    }\n\n    // Add the new classes to the <html> element.\n    $('html').addClass( classes );\n  }\n\n\n  // ========================= isoTransform ===============================\n\n  /**\n   *  provides hooks for .css({ scale: value, translate: [x, y] })\n   *  Progressively enhanced CSS transforms\n   *  Uses hardware accelerated 3D transforms for Safari\n   *  or falls back to 2D transforms.\n   */\n\n  if ( Modernizr.csstransforms ) {\n\n        // i.e. transformFnNotations.scale(0.5) >> 'scale3d( 0.5, 0.5, 1)'\n    var transformFnNotations = Modernizr.csstransforms3d ?\n      { // 3D transform functions\n        translate : function ( position ) {\n          return 'translate3d(' + position[0] + 'px, ' + position[1] + 'px, 0) ';\n        },\n        scale : function ( scale ) {\n          return 'scale3d(' + scale + ', ' + scale + ', 1) ';\n        }\n      } :\n      { // 2D transform functions\n        translate : function ( position ) {\n          return 'translate(' + position[0] + 'px, ' + position[1] + 'px) ';\n        },\n        scale : function ( scale ) {\n          return 'scale(' + scale + ') ';\n        }\n      }\n    ;\n\n    var setIsoTransform = function ( elem, name, value ) {\n          // unpack current transform data\n      var data =  $.data( elem, 'isoTransform' ) || {},\n          newData = {},\n          fnName,\n          transformObj = {},\n          transformValue;\n\n      // i.e. newData.scale = 0.5\n      newData[ name ] = value;\n      // extend new value over current data\n      $.extend( data, newData );\n\n      for ( fnName in data ) {\n        transformValue = data[ fnName ];\n        transformObj[ fnName ] = transformFnNotations[ fnName ]( transformValue );\n      }\n\n      // get proper order\n      // ideally, we could loop through this give an array, but since we only have\n      // a couple transforms we're keeping track of, we'll do it like so\n      var translateFn = transformObj.translate || '',\n          scaleFn = transformObj.scale || '',\n          // sorting so translate always comes first\n          valueFns = translateFn + scaleFn;\n\n      // set data back in elem\n      $.data( elem, 'isoTransform', data );\n\n      // set name to vendor specific property\n      elem.style[ transformProp ] = valueFns;\n    };\n\n    // ==================== scale ===================\n\n    $.cssNumber.scale = true;\n\n    $.cssHooks.scale = {\n      set: function( elem, value ) {\n        // uncomment this bit if you want to properly parse strings\n        // if ( typeof value === 'string' ) {\n        //   value = parseFloat( value );\n        // }\n        setIsoTransform( elem, 'scale', value );\n      },\n      get: function( elem, computed ) {\n        var transform = $.data( elem, 'isoTransform' );\n        return transform && transform.scale ? transform.scale : 1;\n      }\n    };\n\n    $.fx.step.scale = function( fx ) {\n      $.cssHooks.scale.set( fx.elem, fx.now+fx.unit );\n    };\n\n\n    // ==================== translate ===================\n\n    $.cssNumber.translate = true;\n\n    $.cssHooks.translate = {\n      set: function( elem, value ) {\n\n        // uncomment this bit if you want to properly parse strings\n        // if ( typeof value === 'string' ) {\n        //   value = value.split(' ');\n        // }\n        //\n        // var i, val;\n        // for ( i = 0; i < 2; i++ ) {\n        //   val = value[i];\n        //   if ( typeof val === 'string' ) {\n        //     val = parseInt( val );\n        //   }\n        // }\n\n        setIsoTransform( elem, 'translate', value );\n      },\n\n      get: function( elem, computed ) {\n        var transform = $.data( elem, 'isoTransform' );\n        return transform && transform.translate ? transform.translate : [ 0, 0 ];\n      }\n    };\n\n  }\n\n  // ========================= get transition-end event ===============================\n  var transitionEndEvent, transitionDurProp;\n\n  if ( Modernizr.csstransitions ) {\n    transitionEndEvent = {\n      WebkitTransitionProperty: 'webkitTransitionEnd',  // webkit\n      MozTransitionProperty: 'transitionend',\n      OTransitionProperty: 'oTransitionEnd otransitionend',\n      transitionProperty: 'transitionend'\n    }[ transitionProp ];\n\n    transitionDurProp = getStyleProperty('transitionDuration');\n  }\n\n  // ========================= smartresize ===============================\n\n  /*\n   * smartresize: debounced resize event for jQuery\n   *\n   * latest version and complete README available on Github:\n   * https://github.com/louisremi/jquery.smartresize.js\n   *\n   * Copyright 2011 @louis_remi\n   * Licensed under the MIT license.\n   */\n\n  var $event = $.event,\n      dispatchMethod = $.event.handle ? 'handle' : 'dispatch',\n      resizeTimeout;\n\n  $event.special.smartresize = {\n    setup: function() {\n      $(this).bind( \"resize\", $event.special.smartresize.handler );\n    },\n    teardown: function() {\n      $(this).unbind( \"resize\", $event.special.smartresize.handler );\n    },\n    handler: function( event, execAsap ) {\n      // Save the context\n      var context = this,\n          args = arguments;\n\n      // set correct event type\n      event.type = \"smartresize\";\n\n      if ( resizeTimeout ) { clearTimeout( resizeTimeout ); }\n      resizeTimeout = setTimeout(function() {\n        $event[ dispatchMethod ].apply( context, args );\n      }, execAsap === \"execAsap\"? 0 : 100 );\n    }\n  };\n\n  $.fn.smartresize = function( fn ) {\n    return fn ? this.bind( \"smartresize\", fn ) : this.trigger( \"smartresize\", [\"execAsap\"] );\n  };\n\n\n\n// ========================= Isotope ===============================\n\n\n  // our \"Widget\" object constructor\n  $.Isotope = function( options, element, callback ){\n    this.element = $( element );\n\n    this._create( options );\n    this._init( callback );\n  };\n\n  // styles of container element we want to keep track of\n  var isoContainerStyles = [ 'width', 'height' ];\n\n  var $window = $(window);\n\n  $.Isotope.settings = {\n    resizable: true,\n    layoutMode : 'masonry',\n    containerClass : 'isotope',\n    itemClass : 'isotope-item',\n    hiddenClass : 'isotope-hidden',\n    hiddenStyle: { opacity: 0, scale: 0.001 },\n    visibleStyle: { opacity: 1, scale: 1 },\n    containerStyle: {\n      position: 'relative',\n      overflow: 'hidden'\n    },\n    animationEngine: 'best-available',\n    animationOptions: {\n      queue: false,\n      duration: 800\n    },\n    sortBy : 'original-order',\n    sortAscending : true,\n    resizesContainer : true,\n    transformsEnabled: true,\n    itemPositionDataEnabled: false\n  };\n\n  $.Isotope.prototype = {\n\n    // sets up widget\n    _create : function( options ) {\n\n      this.options = $.extend( {}, $.Isotope.settings, options );\n\n      this.styleQueue = [];\n      this.elemCount = 0;\n\n      // get original styles in case we re-apply them in .destroy()\n      var elemStyle = this.element[0].style;\n      this.originalStyle = {};\n      // keep track of container styles\n      var containerStyles = isoContainerStyles.slice(0);\n      for ( var prop in this.options.containerStyle ) {\n        containerStyles.push( prop );\n      }\n      for ( var i=0, len = containerStyles.length; i < len; i++ ) {\n        prop = containerStyles[i];\n        this.originalStyle[ prop ] = elemStyle[ prop ] || '';\n      }\n      // apply container style from options\n      this.element.css( this.options.containerStyle );\n\n      this._updateAnimationEngine();\n      this._updateUsingTransforms();\n\n      // sorting\n      var originalOrderSorter = {\n        'original-order' : function( $elem, instance ) {\n          instance.elemCount ++;\n          return instance.elemCount;\n        },\n        random : function() {\n          return Math.random();\n        }\n      };\n\n      this.options.getSortData = $.extend( this.options.getSortData, originalOrderSorter );\n\n      // need to get atoms\n      this.reloadItems();\n\n      // get top left position of where the bricks should be\n      this.offset = {\n        left: parseInt( ( this.element.css('padding-left') || 0 ), 10 ),\n        top: parseInt( ( this.element.css('padding-top') || 0 ), 10 )\n      };\n\n      // add isotope class first time around\n      var instance = this;\n      setTimeout( function() {\n        instance.element.addClass( instance.options.containerClass );\n      }, 0 );\n\n      // bind resize method\n      if ( this.options.resizable ) {\n        $window.bind( 'smartresize.isotope', function() {\n          instance.resize();\n        });\n      }\n\n      // dismiss all click events from hidden events\n      this.element.delegate( '.' + this.options.hiddenClass, 'click', function(){\n        return false;\n      });\n\n    },\n\n    _getAtoms : function( $elems ) {\n      var selector = this.options.itemSelector,\n          // filter & find\n          $atoms = selector ? $elems.filter( selector ).add( $elems.find( selector ) ) : $elems,\n          // base style for atoms\n          atomStyle = { position: 'absolute' };\n\n      // filter out text nodes\n      $atoms = $atoms.filter( function( i, atom ) {\n        return atom.nodeType === 1;\n      });\n\n      if ( this.usingTransforms ) {\n        atomStyle.left = 0;\n        atomStyle.top = 0;\n      }\n\n      $atoms.css( atomStyle ).addClass( this.options.itemClass );\n\n      this.updateSortData( $atoms, true );\n\n      return $atoms;\n    },\n\n    // _init fires when your instance is first created\n    // (from the constructor above), and when you\n    // attempt to initialize the widget again (by the bridge)\n    // after it has already been initialized.\n    _init : function( callback ) {\n\n      this.$filteredAtoms = this._filter( this.$allAtoms );\n      this._sort();\n      this.reLayout( callback );\n\n    },\n\n    option : function( opts ){\n      // change options AFTER initialization:\n      // signature: $('#foo').bar({ cool:false });\n      if ( $.isPlainObject( opts ) ){\n        this.options = $.extend( true, this.options, opts );\n\n        // trigger _updateOptionName if it exists\n        var updateOptionFn;\n        for ( var optionName in opts ) {\n          updateOptionFn = '_update' + capitalize( optionName );\n          if ( this[ updateOptionFn ] ) {\n            this[ updateOptionFn ]();\n          }\n        }\n      }\n    },\n\n    // ====================== updaters ====================== //\n    // kind of like setters\n\n    _updateAnimationEngine : function() {\n      var animationEngine = this.options.animationEngine.toLowerCase().replace( /[ _\\-]/g, '');\n      var isUsingJQueryAnimation;\n      // set applyStyleFnName\n      switch ( animationEngine ) {\n        case 'css' :\n        case 'none' :\n          isUsingJQueryAnimation = false;\n          break;\n        case 'jquery' :\n          isUsingJQueryAnimation = true;\n          break;\n        default : // best available\n          isUsingJQueryAnimation = !Modernizr.csstransitions;\n      }\n      this.isUsingJQueryAnimation = isUsingJQueryAnimation;\n      this._updateUsingTransforms();\n    },\n\n    _updateTransformsEnabled : function() {\n      this._updateUsingTransforms();\n    },\n\n    _updateUsingTransforms : function() {\n      var usingTransforms = this.usingTransforms = this.options.transformsEnabled &&\n        Modernizr.csstransforms && Modernizr.csstransitions && !this.isUsingJQueryAnimation;\n\n      // prevent scales when transforms are disabled\n      if ( !usingTransforms ) {\n        delete this.options.hiddenStyle.scale;\n        delete this.options.visibleStyle.scale;\n      }\n\n      this.getPositionStyles = usingTransforms ? this._translate : this._positionAbs;\n    },\n\n\n    // ====================== Filtering ======================\n\n    _filter : function( $atoms ) {\n      var filter = this.options.filter === '' ? '*' : this.options.filter;\n\n      if ( !filter ) {\n        return $atoms;\n      }\n\n      var hiddenClass    = this.options.hiddenClass,\n          hiddenSelector = '.' + hiddenClass,\n          $hiddenAtoms   = $atoms.filter( hiddenSelector ),\n          $atomsToShow   = $hiddenAtoms;\n\n      if ( filter !== '*' ) {\n        $atomsToShow = $hiddenAtoms.filter( filter );\n        var $atomsToHide = $atoms.not( hiddenSelector ).not( filter ).addClass( hiddenClass );\n        this.styleQueue.push({ $el: $atomsToHide, style: this.options.hiddenStyle });\n      }\n\n      this.styleQueue.push({ $el: $atomsToShow, style: this.options.visibleStyle });\n      $atomsToShow.removeClass( hiddenClass );\n\n      return $atoms.filter( filter );\n    },\n\n    // ====================== Sorting ======================\n\n    updateSortData : function( $atoms, isIncrementingElemCount ) {\n      var instance = this,\n          getSortData = this.options.getSortData,\n          $this, sortData;\n      $atoms.each(function(){\n        $this = $(this);\n        sortData = {};\n        // get value for sort data based on fn( $elem ) passed in\n        for ( var key in getSortData ) {\n          if ( !isIncrementingElemCount && key === 'original-order' ) {\n            // keep original order original\n            sortData[ key ] = $.data( this, 'isotope-sort-data' )[ key ];\n          } else {\n            sortData[ key ] = getSortData[ key ]( $this, instance );\n          }\n        }\n        // apply sort data to element\n        $.data( this, 'isotope-sort-data', sortData );\n      });\n    },\n\n    // used on all the filtered atoms\n    _sort : function() {\n\n      var sortBy = this.options.sortBy,\n          getSorter = this._getSorter,\n          sortDir = this.options.sortAscending ? 1 : -1,\n          sortFn = function( alpha, beta ) {\n            var a = getSorter( alpha, sortBy ),\n                b = getSorter( beta, sortBy );\n            // fall back to original order if data matches\n            if ( a === b && sortBy !== 'original-order') {\n              a = getSorter( alpha, 'original-order' );\n              b = getSorter( beta, 'original-order' );\n            }\n            return ( ( a > b ) ? 1 : ( a < b ) ? -1 : 0 ) * sortDir;\n          };\n\n      this.$filteredAtoms.sort( sortFn );\n    },\n\n    _getSorter : function( elem, sortBy ) {\n      return $.data( elem, 'isotope-sort-data' )[ sortBy ];\n    },\n\n    // ====================== Layout Helpers ======================\n\n    _translate : function( x, y ) {\n      return { translate : [ x, y ] };\n    },\n\n    _positionAbs : function( x, y ) {\n      return { left: x, top: y };\n    },\n\n    _pushPosition : function( $elem, x, y ) {\n      x = Math.round( x + this.offset.left );\n      y = Math.round( y + this.offset.top );\n      var position = this.getPositionStyles( x, y );\n      this.styleQueue.push({ $el: $elem, style: position });\n      if ( this.options.itemPositionDataEnabled ) {\n        $elem.data('isotope-item-position', {x: x, y: y} );\n      }\n    },\n\n\n    // ====================== General Layout ======================\n\n    // used on collection of atoms (should be filtered, and sorted before )\n    // accepts atoms-to-be-laid-out to start with\n    layout : function( $elems, callback ) {\n\n      var layoutMode = this.options.layoutMode;\n\n      // layout logic\n      this[ '_' +  layoutMode + 'Layout' ]( $elems );\n\n      // set the size of the container\n      if ( this.options.resizesContainer ) {\n        var containerStyle = this[ '_' +  layoutMode + 'GetContainerSize' ]();\n        this.styleQueue.push({ $el: this.element, style: containerStyle });\n      }\n\n      this._processStyleQueue( $elems, callback );\n\n      this.isLaidOut = true;\n    },\n\n    _processStyleQueue : function( $elems, callback ) {\n      // are we animating the layout arrangement?\n      // use plugin-ish syntax for css or animate\n      var styleFn = !this.isLaidOut ? 'css' : (\n            this.isUsingJQueryAnimation ? 'animate' : 'css'\n          ),\n          animOpts = this.options.animationOptions,\n          onLayout = this.options.onLayout,\n          objStyleFn, processor,\n          triggerCallbackNow, callbackFn;\n\n      // default styleQueue processor, may be overwritten down below\n      processor = function( i, obj ) {\n        obj.$el[ styleFn ]( obj.style, animOpts );\n      };\n\n      if ( this._isInserting && this.isUsingJQueryAnimation ) {\n        // if using styleQueue to insert items\n        processor = function( i, obj ) {\n          // only animate if it not being inserted\n          objStyleFn = obj.$el.hasClass('no-transition') ? 'css' : styleFn;\n          obj.$el[ objStyleFn ]( obj.style, animOpts );\n        };\n\n      } else if ( callback || onLayout || animOpts.complete ) {\n        // has callback\n        var isCallbackTriggered = false,\n            // array of possible callbacks to trigger\n            callbacks = [ callback, onLayout, animOpts.complete ],\n            instance = this;\n        triggerCallbackNow = true;\n        // trigger callback only once\n        callbackFn = function() {\n          if ( isCallbackTriggered ) {\n            return;\n          }\n          var hollaback;\n          for (var i=0, len = callbacks.length; i < len; i++) {\n            hollaback = callbacks[i];\n            if ( typeof hollaback === 'function' ) {\n              hollaback.call( instance.element, $elems, instance );\n            }\n          }\n          isCallbackTriggered = true;\n        };\n\n        if ( this.isUsingJQueryAnimation && styleFn === 'animate' ) {\n          // add callback to animation options\n          animOpts.complete = callbackFn;\n          triggerCallbackNow = false;\n\n        } else if ( Modernizr.csstransitions ) {\n          // detect if first item has transition\n          var i = 0,\n              firstItem = this.styleQueue[0],\n              testElem = firstItem && firstItem.$el,\n              styleObj;\n          // get first non-empty jQ object\n          while ( !testElem || !testElem.length ) {\n            styleObj = this.styleQueue[ i++ ];\n            // HACK: sometimes styleQueue[i] is undefined\n            if ( !styleObj ) {\n              return;\n            }\n            testElem = styleObj.$el;\n          }\n          // get transition duration of the first element in that object\n          // yeah, this is inexact\n          var duration = parseFloat( getComputedStyle( testElem[0] )[ transitionDurProp ] );\n          if ( duration > 0 ) {\n            processor = function( i, obj ) {\n              obj.$el[ styleFn ]( obj.style, animOpts )\n                // trigger callback at transition end\n                .one( transitionEndEvent, callbackFn );\n            };\n            triggerCallbackNow = false;\n          }\n        }\n      }\n\n      // process styleQueue\n      $.each( this.styleQueue, processor );\n\n      if ( triggerCallbackNow ) {\n        callbackFn();\n      }\n\n      // clear out queue for next time\n      this.styleQueue = [];\n    },\n\n\n    resize : function() {\n      if ( this[ '_' + this.options.layoutMode + 'ResizeChanged' ]() ) {\n        this.reLayout();\n      }\n    },\n\n\n    reLayout : function( callback ) {\n\n      this[ '_' +  this.options.layoutMode + 'Reset' ]();\n      this.layout( this.$filteredAtoms, callback );\n\n    },\n\n    // ====================== Convenience methods ======================\n\n    // ====================== Adding items ======================\n\n    // adds a jQuery object of items to a isotope container\n    addItems : function( $content, callback ) {\n      var $newAtoms = this._getAtoms( $content );\n      // add new atoms to atoms pools\n      this.$allAtoms = this.$allAtoms.add( $newAtoms );\n\n      if ( callback ) {\n        callback( $newAtoms );\n      }\n    },\n\n    // convienence method for adding elements properly to any layout\n    // positions items, hides them, then animates them back in <--- very sezzy\n    insert : function( $content, callback ) {\n      // position items\n      this.element.append( $content );\n\n      var instance = this;\n      this.addItems( $content, function( $newAtoms ) {\n        var $newFilteredAtoms = instance._filter( $newAtoms );\n        instance._addHideAppended( $newFilteredAtoms );\n        instance._sort();\n        instance.reLayout();\n        instance._revealAppended( $newFilteredAtoms, callback );\n      });\n\n    },\n\n    // convienence method for working with Infinite Scroll\n    appended : function( $content, callback ) {\n      var instance = this;\n      this.addItems( $content, function( $newAtoms ) {\n        instance._addHideAppended( $newAtoms );\n        instance.layout( $newAtoms );\n        instance._revealAppended( $newAtoms, callback );\n      });\n    },\n\n    // adds new atoms, then hides them before positioning\n    _addHideAppended : function( $newAtoms ) {\n      this.$filteredAtoms = this.$filteredAtoms.add( $newAtoms );\n      $newAtoms.addClass('no-transition');\n\n      this._isInserting = true;\n\n      // apply hidden styles\n      this.styleQueue.push({ $el: $newAtoms, style: this.options.hiddenStyle });\n    },\n\n    // sets visible style on new atoms\n    _revealAppended : function( $newAtoms, callback ) {\n      var instance = this;\n      // apply visible style after a sec\n      setTimeout( function() {\n        // enable animation\n        $newAtoms.removeClass('no-transition');\n        // reveal newly inserted filtered elements\n        instance.styleQueue.push({ $el: $newAtoms, style: instance.options.visibleStyle });\n        instance._isInserting = false;\n        instance._processStyleQueue( $newAtoms, callback );\n      }, 10 );\n    },\n\n    // gathers all atoms\n    reloadItems : function() {\n      this.$allAtoms = this._getAtoms( this.element.children() );\n    },\n\n    // removes elements from Isotope widget\n    remove: function( $content, callback ) {\n      // remove elements immediately from Isotope instance\n      this.$allAtoms = this.$allAtoms.not( $content );\n      this.$filteredAtoms = this.$filteredAtoms.not( $content );\n      // remove() as a callback, for after transition / animation\n      var instance = this;\n      var removeContent = function() {\n        $content.remove();\n        if ( callback ) {\n          callback.call( instance.element );\n        }\n      };\n\n      if ( $content.filter( ':not(.' + this.options.hiddenClass + ')' ).length ) {\n        // if any non-hidden content needs to be removed\n        this.styleQueue.push({ $el: $content, style: this.options.hiddenStyle });\n        this._sort();\n        this.reLayout( removeContent );\n      } else {\n        // remove it now\n        removeContent();\n      }\n\n    },\n\n    shuffle : function( callback ) {\n      this.updateSortData( this.$allAtoms );\n      this.options.sortBy = 'random';\n      this._sort();\n      this.reLayout( callback );\n    },\n\n    // destroys widget, returns elements and container back (close) to original style\n    destroy : function() {\n\n      var usingTransforms = this.usingTransforms;\n      var options = this.options;\n\n      this.$allAtoms\n        .removeClass( options.hiddenClass + ' ' + options.itemClass )\n        .each(function(){\n          var style = this.style;\n          style.position = '';\n          style.top = '';\n          style.left = '';\n          style.opacity = '';\n          if ( usingTransforms ) {\n            style[ transformProp ] = '';\n          }\n        });\n\n      // re-apply saved container styles\n      var elemStyle = this.element[0].style;\n      for ( var prop in this.originalStyle ) {\n        elemStyle[ prop ] = this.originalStyle[ prop ];\n      }\n\n      this.element\n        .unbind('.isotope')\n        .undelegate( '.' + options.hiddenClass, 'click' )\n        .removeClass( options.containerClass )\n        .removeData('isotope');\n\n      $window.unbind('.isotope');\n\n    },\n\n\n    // ====================== LAYOUTS ======================\n\n    // calculates number of rows or columns\n    // requires columnWidth or rowHeight to be set on namespaced object\n    // i.e. this.masonry.columnWidth = 200\n    _getSegments : function( isRows ) {\n      var namespace = this.options.layoutMode,\n          measure  = isRows ? 'rowHeight' : 'columnWidth',\n          size     = isRows ? 'height' : 'width',\n          segmentsName = isRows ? 'rows' : 'cols',\n          containerSize = this.element[ size ](),\n          segments,\n                    // i.e. options.masonry && options.masonry.columnWidth\n          segmentSize = this.options[ namespace ] && this.options[ namespace ][ measure ] ||\n                    // or use the size of the first item, i.e. outerWidth\n                    this.$filteredAtoms[ 'outer' + capitalize(size) ](true) ||\n                    // if there's no items, use size of container\n                    containerSize;\n\n      segments = Math.floor( containerSize / segmentSize );\n      segments = Math.max( segments, 1 );\n\n      // i.e. this.masonry.cols = ....\n      this[ namespace ][ segmentsName ] = segments;\n      // i.e. this.masonry.columnWidth = ...\n      this[ namespace ][ measure ] = segmentSize;\n\n    },\n\n    _checkIfSegmentsChanged : function( isRows ) {\n      var namespace = this.options.layoutMode,\n          segmentsName = isRows ? 'rows' : 'cols',\n          prevSegments = this[ namespace ][ segmentsName ];\n      // update cols/rows\n      this._getSegments( isRows );\n      // return if updated cols/rows is not equal to previous\n      return ( this[ namespace ][ segmentsName ] !== prevSegments );\n    },\n\n    // ====================== Masonry ======================\n\n    _masonryReset : function() {\n      // layout-specific props\n      this.masonry = {};\n      // FIXME shouldn't have to call this again\n      this._getSegments();\n      var i = this.masonry.cols;\n      this.masonry.colYs = [];\n      while (i--) {\n        this.masonry.colYs.push( 0 );\n      }\n    },\n\n    _masonryLayout : function( $elems ) {\n      var instance = this,\n          props = instance.masonry;\n      $elems.each(function(){\n        var $this  = $(this),\n            //how many columns does this brick span\n            colSpan = Math.ceil( $this.outerWidth(true) / props.columnWidth );\n        colSpan = Math.min( colSpan, props.cols );\n\n        if ( colSpan === 1 ) {\n          // if brick spans only one column, just like singleMode\n          instance._masonryPlaceBrick( $this, props.colYs );\n        } else {\n          // brick spans more than one column\n          // how many different places could this brick fit horizontally\n          var groupCount = props.cols + 1 - colSpan,\n              groupY = [],\n              groupColY,\n              i;\n\n          // for each group potential horizontal position\n          for ( i=0; i < groupCount; i++ ) {\n            // make an array of colY values for that one group\n            groupColY = props.colYs.slice( i, i+colSpan );\n            // and get the max value of the array\n            groupY[i] = Math.max.apply( Math, groupColY );\n          }\n\n          instance._masonryPlaceBrick( $this, groupY );\n        }\n      });\n    },\n\n    // worker method that places brick in the columnSet\n    //   with the the minY\n    _masonryPlaceBrick : function( $brick, setY ) {\n      // get the minimum Y value from the columns\n      var minimumY = Math.min.apply( Math, setY ),\n          shortCol = 0;\n\n      // Find index of short column, the first from the left\n      for (var i=0, len = setY.length; i < len; i++) {\n        if ( setY[i] === minimumY ) {\n          shortCol = i;\n          break;\n        }\n      }\n\n      // position the brick\n      var x = this.masonry.columnWidth * shortCol,\n          y = minimumY;\n      this._pushPosition( $brick, x, y );\n\n      // apply setHeight to necessary columns\n      var setHeight = minimumY + $brick.outerHeight(true),\n          setSpan = this.masonry.cols + 1 - len;\n      for ( i=0; i < setSpan; i++ ) {\n        this.masonry.colYs[ shortCol + i ] = setHeight;\n      }\n\n    },\n\n    _masonryGetContainerSize : function() {\n      var containerHeight = Math.max.apply( Math, this.masonry.colYs );\n      return { height: containerHeight };\n    },\n\n    _masonryResizeChanged : function() {\n      return this._checkIfSegmentsChanged();\n    },\n\n    // ====================== fitRows ======================\n\n    _fitRowsReset : function() {\n      this.fitRows = {\n        x : 0,\n        y : 0,\n        height : 0\n      };\n    },\n\n    _fitRowsLayout : function( $elems ) {\n      var instance = this,\n          containerWidth = this.element.width(),\n          props = this.fitRows;\n\n      $elems.each( function() {\n        var $this = $(this),\n            atomW = $this.outerWidth(true),\n            atomH = $this.outerHeight(true);\n\n        if ( props.x !== 0 && atomW + props.x > containerWidth ) {\n          // if this element cannot fit in the current row\n          props.x = 0;\n          props.y = props.height;\n        }\n\n        // position the atom\n        instance._pushPosition( $this, props.x, props.y );\n\n        props.height = Math.max( props.y + atomH, props.height );\n        props.x += atomW;\n\n      });\n    },\n\n    _fitRowsGetContainerSize : function () {\n      return { height : this.fitRows.height };\n    },\n\n    _fitRowsResizeChanged : function() {\n      return true;\n    },\n\n\n    // ====================== cellsByRow ======================\n\n    _cellsByRowReset : function() {\n      this.cellsByRow = {\n        index : 0\n      };\n      // get this.cellsByRow.columnWidth\n      this._getSegments();\n      // get this.cellsByRow.rowHeight\n      this._getSegments(true);\n    },\n\n    _cellsByRowLayout : function( $elems ) {\n      var instance = this,\n          props = this.cellsByRow;\n      $elems.each( function(){\n        var $this = $(this),\n            col = props.index % props.cols,\n            row = Math.floor( props.index / props.cols ),\n            x = ( col + 0.5 ) * props.columnWidth - $this.outerWidth(true) / 2,\n            y = ( row + 0.5 ) * props.rowHeight - $this.outerHeight(true) / 2;\n        instance._pushPosition( $this, x, y );\n        props.index ++;\n      });\n    },\n\n    _cellsByRowGetContainerSize : function() {\n      return { height : Math.ceil( this.$filteredAtoms.length / this.cellsByRow.cols ) * this.cellsByRow.rowHeight + this.offset.top };\n    },\n\n    _cellsByRowResizeChanged : function() {\n      return this._checkIfSegmentsChanged();\n    },\n\n\n    // ====================== straightDown ======================\n\n    _straightDownReset : function() {\n      this.straightDown = {\n        y : 0\n      };\n    },\n\n    _straightDownLayout : function( $elems ) {\n      var instance = this;\n      $elems.each( function( i ){\n        var $this = $(this);\n        instance._pushPosition( $this, 0, instance.straightDown.y );\n        instance.straightDown.y += $this.outerHeight(true);\n      });\n    },\n\n    _straightDownGetContainerSize : function() {\n      return { height : this.straightDown.y };\n    },\n\n    _straightDownResizeChanged : function() {\n      return true;\n    },\n\n\n    // ====================== masonryHorizontal ======================\n\n    _masonryHorizontalReset : function() {\n      // layout-specific props\n      this.masonryHorizontal = {};\n      // FIXME shouldn't have to call this again\n      this._getSegments( true );\n      var i = this.masonryHorizontal.rows;\n      this.masonryHorizontal.rowXs = [];\n      while (i--) {\n        this.masonryHorizontal.rowXs.push( 0 );\n      }\n    },\n\n    _masonryHorizontalLayout : function( $elems ) {\n      var instance = this,\n          props = instance.masonryHorizontal;\n      $elems.each(function(){\n        var $this  = $(this),\n            //how many rows does this brick span\n            rowSpan = Math.ceil( $this.outerHeight(true) / props.rowHeight );\n        rowSpan = Math.min( rowSpan, props.rows );\n\n        if ( rowSpan === 1 ) {\n          // if brick spans only one column, just like singleMode\n          instance._masonryHorizontalPlaceBrick( $this, props.rowXs );\n        } else {\n          // brick spans more than one row\n          // how many different places could this brick fit horizontally\n          var groupCount = props.rows + 1 - rowSpan,\n              groupX = [],\n              groupRowX, i;\n\n          // for each group potential horizontal position\n          for ( i=0; i < groupCount; i++ ) {\n            // make an array of colY values for that one group\n            groupRowX = props.rowXs.slice( i, i+rowSpan );\n            // and get the max value of the array\n            groupX[i] = Math.max.apply( Math, groupRowX );\n          }\n\n          instance._masonryHorizontalPlaceBrick( $this, groupX );\n        }\n      });\n    },\n\n    _masonryHorizontalPlaceBrick : function( $brick, setX ) {\n      // get the minimum Y value from the columns\n      var minimumX  = Math.min.apply( Math, setX ),\n          smallRow  = 0;\n      // Find index of smallest row, the first from the top\n      for (var i=0, len = setX.length; i < len; i++) {\n        if ( setX[i] === minimumX ) {\n          smallRow = i;\n          break;\n        }\n      }\n\n      // position the brick\n      var x = minimumX,\n          y = this.masonryHorizontal.rowHeight * smallRow;\n      this._pushPosition( $brick, x, y );\n\n      // apply setHeight to necessary columns\n      var setWidth = minimumX + $brick.outerWidth(true),\n          setSpan = this.masonryHorizontal.rows + 1 - len;\n      for ( i=0; i < setSpan; i++ ) {\n        this.masonryHorizontal.rowXs[ smallRow + i ] = setWidth;\n      }\n    },\n\n    _masonryHorizontalGetContainerSize : function() {\n      var containerWidth = Math.max.apply( Math, this.masonryHorizontal.rowXs );\n      return { width: containerWidth };\n    },\n\n    _masonryHorizontalResizeChanged : function() {\n      return this._checkIfSegmentsChanged(true);\n    },\n\n\n    // ====================== fitColumns ======================\n\n    _fitColumnsReset : function() {\n      this.fitColumns = {\n        x : 0,\n        y : 0,\n        width : 0\n      };\n    },\n\n    _fitColumnsLayout : function( $elems ) {\n      var instance = this,\n          containerHeight = this.element.height(),\n          props = this.fitColumns;\n      $elems.each( function() {\n        var $this = $(this),\n            atomW = $this.outerWidth(true),\n            atomH = $this.outerHeight(true);\n\n        if ( props.y !== 0 && atomH + props.y > containerHeight ) {\n          // if this element cannot fit in the current column\n          props.x = props.width;\n          props.y = 0;\n        }\n\n        // position the atom\n        instance._pushPosition( $this, props.x, props.y );\n\n        props.width = Math.max( props.x + atomW, props.width );\n        props.y += atomH;\n\n      });\n    },\n\n    _fitColumnsGetContainerSize : function () {\n      return { width : this.fitColumns.width };\n    },\n\n    _fitColumnsResizeChanged : function() {\n      return true;\n    },\n\n\n\n    // ====================== cellsByColumn ======================\n\n    _cellsByColumnReset : function() {\n      this.cellsByColumn = {\n        index : 0\n      };\n      // get this.cellsByColumn.columnWidth\n      this._getSegments();\n      // get this.cellsByColumn.rowHeight\n      this._getSegments(true);\n    },\n\n    _cellsByColumnLayout : function( $elems ) {\n      var instance = this,\n          props = this.cellsByColumn;\n      $elems.each( function(){\n        var $this = $(this),\n            col = Math.floor( props.index / props.rows ),\n            row = props.index % props.rows,\n            x = ( col + 0.5 ) * props.columnWidth - $this.outerWidth(true) / 2,\n            y = ( row + 0.5 ) * props.rowHeight - $this.outerHeight(true) / 2;\n        instance._pushPosition( $this, x, y );\n        props.index ++;\n      });\n    },\n\n    _cellsByColumnGetContainerSize : function() {\n      return { width : Math.ceil( this.$filteredAtoms.length / this.cellsByColumn.rows ) * this.cellsByColumn.columnWidth };\n    },\n\n    _cellsByColumnResizeChanged : function() {\n      return this._checkIfSegmentsChanged(true);\n    },\n\n    // ====================== straightAcross ======================\n\n    _straightAcrossReset : function() {\n      this.straightAcross = {\n        x : 0\n      };\n    },\n\n    _straightAcrossLayout : function( $elems ) {\n      var instance = this;\n      $elems.each( function( i ){\n        var $this = $(this);\n        instance._pushPosition( $this, instance.straightAcross.x, 0 );\n        instance.straightAcross.x += $this.outerWidth(true);\n      });\n    },\n\n    _straightAcrossGetContainerSize : function() {\n      return { width : this.straightAcross.x };\n    },\n\n    _straightAcrossResizeChanged : function() {\n      return true;\n    }\n\n  };\n\n\n  // ======================= imagesLoaded Plugin ===============================\n  /*!\n   * jQuery imagesLoaded plugin v1.1.0\n   * http://github.com/desandro/imagesloaded\n   *\n   * MIT License. by Paul Irish et al.\n   */\n\n\n  // $('#my-container').imagesLoaded(myFunction)\n  // or\n  // $('img').imagesLoaded(myFunction)\n\n  // execute a callback when all images have loaded.\n  // needed because .load() doesn't work on cached images\n\n  // callback function gets image collection as argument\n  //  `this` is the container\n\n  $.fn.imagesLoaded = function( callback ) {\n    var $this = this,\n        $images = $this.find('img').add( $this.filter('img') ),\n        len = $images.length,\n        blank = 'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///ywAAAAAAQABAAACAUwAOw==',\n        loaded = [];\n\n    function triggerCallback() {\n      callback.call( $this, $images );\n    }\n\n    function imgLoaded( event ) {\n      var img = event.target;\n      if ( img.src !== blank && $.inArray( img, loaded ) === -1 ){\n        loaded.push( img );\n        if ( --len <= 0 ){\n          setTimeout( triggerCallback );\n          $images.unbind( '.imagesLoaded', imgLoaded );\n        }\n      }\n    }\n\n    // if no images, trigger immediately\n    if ( !len ) {\n      triggerCallback();\n    }\n\n    $images.bind( 'load.imagesLoaded error.imagesLoaded',  imgLoaded ).each( function() {\n      // cached images don't fire load sometimes, so we reset src.\n      var src = this.src;\n      // webkit hack from http://groups.google.com/group/jquery-dev/browse_thread/thread/eee6ab7b2da50e1f\n      // data uri bypasses webkit log warning (thx doug jones)\n      this.src = blank;\n      this.src = src;\n    });\n\n    return $this;\n  };\n\n\n  // helper function for logging errors\n  // $.error breaks jQuery chaining\n  var logError = function( message ) {\n    if ( window.console ) {\n      window.console.error( message );\n    }\n  };\n\n  // =======================  Plugin bridge  ===============================\n  // leverages data method to either create or return $.Isotope constructor\n  // A bit from jQuery UI\n  //   https://github.com/jquery/jquery-ui/blob/master/ui/jquery.ui.widget.js\n  // A bit from jcarousel\n  //   https://github.com/jsor/jcarousel/blob/master/lib/jquery.jcarousel.js\n\n  $.fn.isotope = function( options, callback ) {\n    if ( typeof options === 'string' ) {\n      // call method\n      var args = Array.prototype.slice.call( arguments, 1 );\n\n      this.each(function(){\n        var instance = $.data( this, 'isotope' );\n        if ( !instance ) {\n          logError( \"cannot call methods on isotope prior to initialization; \" +\n              \"attempted to call method '\" + options + \"'\" );\n          return;\n        }\n        if ( !$.isFunction( instance[options] ) || options.charAt(0) === \"_\" ) {\n          logError( \"no such method '\" + options + \"' for isotope instance\" );\n          return;\n        }\n        // apply method\n        instance[ options ].apply( instance, args );\n      });\n    } else {\n      this.each(function() {\n        var instance = $.data( this, 'isotope' );\n        if ( instance ) {\n          // apply options & init\n          instance.option( options );\n          instance._init( callback );\n        } else {\n          // initialize new instance\n          $.data( this, 'isotope', new $.Isotope( options, this, callback ) );\n        }\n      });\n    }\n    // return jQuery object\n    // so plugin methods do not have to\n    return this;\n  };\n\n})( window, jQuery );\n\n\n\n#Isotope\u3068\u306f\n\u9ad8\u3055\u3084\u5e45\u304c\u7570\u306a\u308b\u30d1\u30cd\u30eb\u3092\u304d\u308c\u3044\u306b\u30ec\u30f3\u30ac\u72b6\u306b\u914d\u7f6e\u3059\u308bjQuery\u306e\u30d7\u30e9\u30b0\u30a4\u30f3\nhttp://isotope.metafizzy.co/\n\n- \u6a5f\u80fd:\u30d5\u30a3\u30eb\u30bf\u30fc\u6a5f\u80fd\u3001\u30bd\u30fc\u30c8\u6a5f\u80fd\n\n- \u30e9\u30a4\u30bb\u30f3\u30b9:Commercial License\u3000$25~\nhttp://isotope.metafizzy.co/#commercial-license\n\n- \u4f7f\u7528\u30b5\u30a4\u30c8\u4f8b\nhttp://isotope.metafizzy.co/#isotope-in-use\n\n![\u30b9\u30af\u30ea\u30fc\u30f3\u30b7\u30e7\u30c3\u30c8 2016-09-15 14.01.19.png](https://qiita-image-store.s3.amazonaws.com/0/62264/f0173e8e-69cb-347b-0159-15ec2a3453d3.png)\nhttp://malikafavre.com/\n\n#\u4f7f\u3044\u65b9 \u57fa\u672c\n- html\u306eclass\u89aa\u8981\u7d20\u3068\u3001\u5404\u8981\u7d20\u306b\u5b50\u8981\u7d20\u3092\u3064\u3051\u308b\n\n```js\n\n$('\u89aa\u8981\u7d20\u306eid or \u30af\u30e9\u30b9\u540d').isotope({\n//\u3053\u3053\u306b\u51e6\u7406\u3092\u66f8\u304f\n});\n```\n- itemSelector(\u52d5\u304b\u3059\u8981\u7d20\u306e\u30af\u30e9\u30b9\u540d\u3092\u66f8\u304f)\n\n```js\n$('\u89aa\u8981\u7d20\u306eid or \u30af\u30e9\u30b9\u540d').isotope({\n  itemSelector: '\u52d5\u304b\u3059\u8981\u7d20\u306e\u30af\u30e9\u30b9\u540d',\n  percentPosition: true,\n  masonry: {\n    columnWidth: '\u52d5\u304b\u3059\u8981\u7d20\u306e\u6a2a\u5e45(\u30af\u30e9\u30b9\u540d\u3067\u3082\u3088\u3044)'\n  }\n});\n```\n\nmasonry(columnWidth)\u306e\u8a2d\u5b9a\u3092\u3057\u3066\u3044\u308b\u306e\u306f\u306a\u305c\u304b\uff1f\n\n- \u8981\u7d20\u306e\u6a2a\u5e45\u306b\u95a2\u308f\u3089\u305a\u3001\u30ab\u30e9\u30e0\u306e\u6a2a\u5e45\u3092\u8a2d\u5b9a\u3067\u304d\u308b\u3002\n\n[\u6ce8\u610f\u70b9]\n\u5b9f\u969b\u306e\u8981\u7d20\u306e\u6a2a\u5e45:500px\ncolumnWidth\u306e\u6307\u5b9a:100px\n\n\u4e0a\u8a18\u306e\u5834\u5408\u3001columnWidth\u306f\u4e0a\u66f8\u304d\u3055\u308c\u3066\u3001\u8981\u7d20500px\u304c\u8868\u793a\u3055\u308c\u308b\u306e\u3067\u6ce8\u610f\u3002\n\n---\n\n\n#\u30b5\u30f3\u30d7\u30eb\n\n- \u30d6\u30e9\u30a6\u30b6\u30b5\u30a4\u30ba(\u6a2a\u5e45)\u306b\u3088\u3063\u3066\u8981\u7d20\u306e\u4e26\u3073\u304c\u5909\u308f\u308b\n\n\u6a2a\u5e451000px\n![\u30b9\u30af\u30ea\u30fc\u30f3\u30b7\u30e7\u30c3\u30c8 2016-06-01 15.46.10.png](https://qiita-image-store.s3.amazonaws.com/0/62264/d21469ac-2c91-4bd5-f212-68951bea2c1f.png)\n\n\u6a2a\u5e45500px\n![\u30b9\u30af\u30ea\u30fc\u30f3\u30b7\u30e7\u30c3\u30c8 2016-06-01 15.53.50.png](https://qiita-image-store.s3.amazonaws.com/0/62264/7f0be4d5-2f03-7830-45ee-3c1784f22438.png)\n\n\n```index.html\n\n<!DOCTYPE html>\n<html>\n<head>\n<meta charset=\"UTF-8\">\n<title>masonry layout mode</title>\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\n<link rel=\"stylesheet\" href=\"css/style.css\">\n</head>\n<body>\n<h1>masonry layout mode</h1>\n<div class=\"grid\">\n  <div class=\"grid-item layout1\">1</div>\n  <div class=\"grid-item layout2\">2</div>\n  <div class=\"grid-item layout1\">3</div>\n  <div class=\"grid-item layout3\">4</div>\n  <div class=\"grid-item layout1\">5</div>\n  <div class=\"grid-item layout3\">6</div>\n  <div class=\"grid-item layout1\">7</div>\n  <div class=\"grid-item layout2\">8</div>\n</div>\n\n<script src='http://cdnjs.cloudflare.com/ajax/libs/jquery/2.2.2/jquery.min.js'></script>\n<script src='http://npmcdn.com/isotope-layout@3/dist/isotope.pkgd.js'></script>\n<script src=\"js/main.js\"></script>\n\n</body>\n</html>\n```\n\n```style.css\n\n* {box-sizing: border-box;}\n.grid {\n  background: #CCC;\n  max-width: 1000px;\n}\n/* clear fix */\n.grid:after {\n  content: '';\n  display: block;\n  clear: both;\n}\n.grid-item {\n  float: left;\n  width: 100px;\n  height: 100px;\n  background: #0D8;\n}\n.layout1{\n  width: 200px;\n  border:1px solid #000;\n}\n.layout2 {\n  height: 200px;\n  border:1px solid #000;\n}\n.layout3{\n  width: 200px;\n  height: 200px;\n  border:1px solid #000;\n}\n```\n\n```main.js\n\n$('.grid').isotope({\n  itemSelector:'.grid-item',\n  masonry: {\n    columnWidth:100\n  }\n});\n```\n\n\u88dc\u8db3:\n\n- isotope\u3092\u4f7f\u3063\u3066\u3044\u306a\u3044\u5834\u5408(\u3059\u304d\u307e\u306b\u306f\u5165\u3089\u306a\u3044)\n\n![\u30b9\u30af\u30ea\u30fc\u30f3\u30b7\u30e7\u30c3\u30c8 2016-06-01 15.47.51.png](https://qiita-image-store.s3.amazonaws.com/0/62264/12b5c5a4-f3db-1095-a1c0-072efd6e529f.png)\n\n---\n\n#masonry\u306b\u3064\u3044\u3066\n\nhttp://isotope.metafizzy.co/layout-modes/masonry.html\n\n\u4ee5\u4e0b\u306e2\u3064\u3092\u899a\u3048\u3066\u304a\u3051\u3070\u3088\u3044\n\n###1.columnWidth(\u8a2d\u5b9a\u5fc5\u9808)\n\n- \u6c34\u5e73\u30b0\u30ea\u30c3\u30c9\u306b\u30a2\u30a4\u30c6\u30e0\u3092\u63c3\u3048\u308b\u3002\n- columnWidth\u8a2d\u5b9a\u3092\u3057\u306a\u3044\u5834\u5408\u3001\n\u300c\u6700\u521d\u306e\u30a2\u30a4\u30c6\u30e0\u306e\u6a2a\u5e45\u300d\u304c\u4f7f\u7528\u3055\u308c\u308b\u3002\u6a2a\u5e45200\u304c\u8a2d\u5b9a\u3055\u308c\u3066\u3044\u308b\u5834\u5408\u306f\u4ee5\u4e0b\u306b\u306a\u308b\u3002\n\n![\u30b9\u30af\u30ea\u30fc\u30f3\u30b7\u30e7\u30c3\u30c8 2016-06-01 15.49.15.png](https://qiita-image-store.s3.amazonaws.com/0/62264/4388d3f1-b6a7-47f3-6afb-f93f158e3594.png)\n\n###2.fluid sizing(\u8981\u7d20\u306e%\u8868\u793a)\u3000\n\npercentPosition:true\n\nhttp://codepen.io/desandro/pen/mIkhq\n\n\n```index.html\n\n<body>\n\n<div class=\"grid\">\n  <div class=\"grid-sizer\"></div>\n  <div class=\"grid-item\">1</div>\n  <div class=\"grid-item\">2</div>\n  <div class=\"grid-item\">3</div>\n</div>\n\n<script src='http://cdnjs.cloudflare.com/ajax/libs/jquery/2.2.2/jquery.min.js'></script>\n<script src='http://npmcdn.com/isotope-layout@3/dist/isotope.pkgd.js'></script>\n<script src=\"js/main.js\"></script>\n\n</body>\n```\n\n```style.css\n\n* {box-sizing: border-box;}\n\n/* clear fix */\n.grid:after {\n  content: '';\n  display: block;\n  clear: both;\n}\n\n.grid {\n  background:#CCC;\n}\n\n.grid-item,\n.grid-sizer {\n  width:33.3%;\n}\n\n.grid-item {\n  float:left;\n  height: 100px;\n  background: #0D8;\n  border: 1px solid #333;\n}\n```\n\n```main.js\n\n  $('.grid').isotope({\n    itemSelector:'.grid-item',\n    percentPosition: true,\n    masonry: {\n      columnWidth: '.grid-sizer'\n    }\n  });\n```\n\n![\u30b9\u30af\u30ea\u30fc\u30f3\u30b7\u30e7\u30c3\u30c8 2016-06-01 17.11.58.png](https://qiita-image-store.s3.amazonaws.com/0/62264/47a7b693-4956-269d-98be-8a6b299484cf.png)\n\n---\n\n#fitRows\nhttp://codepen.io/desandro/pen/nCskp\n\n- fitRows\u306f\u540c\u3058\u9ad8\u3055\u3092\u6301\u3063\u3066\u3044\u308b\u30a2\u30a4\u30c6\u30e0\u306b\u6700\u9069\u3002\n\n\n#filter\n\n```js\n\n$('.grid').isotope({\nfilter: '.metal'\n\n});\n```\n\n\u4f8b\u3048\u3070\u3001html\u5074\u306bdata-filter\u3092\u8a18\u8ff0\u3057\u3066\u304a\u304d\u3001filter\u306b\u6307\u5b9a\u3059\u308b\u8981\u7d20\u3092\u52d5\u7684\u306b\u3059\u308b\u3002\n\n```js\n\n$('.filter-button-group').on( 'click', 'button', function() {\n  var filterValue = $(this).attr('data-filter');\n  $grid.isotope({ filter: filterValue });\n});\n```\n\n\u8907\u6570\u306e\u30ab\u30c6\u30b4\u30ea\u30fc\u3092\u7d44\u307f\u5408\u308f\u305b\u3067\u30d5\u30a3\u30eb\u30bf\u30fc\u3059\u308b\u4f8b\u306f\u3001\u300cCombination filters\u300d\u306e\u30b5\u30f3\u30d7\u30eb\u304c\u5206\u304b\u308a\u3084\u3059\u3044\u3002\nhttp://codepen.io/desandro/pen/JEojz\n\n![\u30b9\u30af\u30ea\u30fc\u30f3\u30b7\u30e7\u30c3\u30c8 2016-06-01 16.07.12.png](https://qiita-image-store.s3.amazonaws.com/0/62264/0c48b026-0067-85e8-0226-bf69b75bb367.png)\n\n\n#\u305d\u306e\u4ed6\u306e\u30b5\u30f3\u30d7\u30eb\nsorting by selected category\n\u30bd\u30fc\u30c8\u5bfe\u8c61\u5916\u306e\u8981\u7d20\u306fopacity\u306b\u5909\u5316\n\nhttp://codepen.io/desandro/pen/zGZywM\n\n\n#\u30a2\u30cb\u30e1\u30fc\u30b7\u30e7\u30f3\n\n\u30c7\u30d5\u30a9\u30eb\u30c8\u306f\u4ee5\u4e0b\u306e\u8a2d\u5b9a\nhttp://isotope.metafizzy.co/v1/docs/animating.html\n\n```css\n\n.\u89aa\u8981\u7d20{\ntransition-duration: 0.8s;\ntransition-property: height, width;\n}\n\n.\u5b50\u8981\u7d20{\ntransition-duration:0.2s;\ntransition-property:height, width;\ntransition-property:transform, opacity;\n}\n```\n\n\u30d0\u30ea\u30a8\u30fc\u30b7\u30e7\u30f3\n\n- Jquery\u306e\u30a2\u30cb\u30e1\u30fc\u30b7\u30e7\u30f3\u3092\u4f7f\u3046\n\n\n\n#\u30a8\u30e9\u30fc\u5bfe\u7b56\u306b\u3064\u3044\u3066\n\n###\u30ed\u30fc\u30c9\u3059\u308b\u3068\u30d1\u30cd\u30eb\u540c\u58eb\u304c\u91cd\u306a\u3063\u3066\u3057\u307e\u3046\u5834\u5408\n\n- \u539f\u56e0:\u30da\u30fc\u30b8\u3092\u5168\u3066\u30ed\u30fc\u30c9\u3059\u308b\u524d\u306bIsotope\u304c\u9ad8\u3055\u3092\u8a08\u7b97\u3057\u3066\u3057\u307e\u3044\u3001\u6b63\u78ba\u306a\u9ad8\u3055\u304c\u53d6\u308c\u306a\u3044\n\n- \u4ee5\u4e0b\u3067\u89e3\u6c7a\n\n\n```\u753b\u50cf\u3082\u542b\u3081\u305f\u30da\u30fc\u30b8\u304c\u5b8c\u5168\u306b\u8aad\u307f\u8fbc\u307e\u308c\u305f\u3089\u51e6\u7406.js\n\n    $(window).load(function(){\n      // \u3053\u3053\u306bIsotope\u8a18\u8ff0\n    });\n```\n\n\n---\n---\n\n\n#Isotope v1.5.25 \u5168\u30bd\u30fc\u30b9\n\n\n```Isotope_v1.5.25.js\n\n/**\n * Isotope v1.5.25\n * An exquisite jQuery plugin for magical layouts\n * http://isotope.metafizzy.co\n *\n * Commercial use requires one-time license fee\n * http://metafizzy.co/#licenses\n *\n * Copyright 2012 David DeSandro / Metafizzy\n */\n\n/*jshint asi: true, browser: true, curly: true, eqeqeq: true, forin: false, immed: false, newcap: true, noempty: true, strict: true, undef: true */\n/*global jQuery: false */\n\n(function( window, $, undefined ){\n\n  'use strict';\n\n  // get global vars\n  var document = window.document;\n  var Modernizr = window.Modernizr;\n\n  // helper function\n  var capitalize = function( str ) {\n    return str.charAt(0).toUpperCase() + str.slice(1);\n  };\n\n  // ========================= getStyleProperty by kangax ===============================\n  // http://perfectionkills.com/feature-testing-css-properties/\n\n  var prefixes = 'Moz Webkit O Ms'.split(' ');\n\n  var getStyleProperty = function( propName ) {\n    var style = document.documentElement.style,\n        prefixed;\n\n    // test standard property first\n    if ( typeof style[propName] === 'string' ) {\n      return propName;\n    }\n\n    // capitalize\n    propName = capitalize( propName );\n\n    // test vendor specific properties\n    for ( var i=0, len = prefixes.length; i < len; i++ ) {\n      prefixed = prefixes[i] + propName;\n      if ( typeof style[ prefixed ] === 'string' ) {\n        return prefixed;\n      }\n    }\n  };\n\n  var transformProp = getStyleProperty('transform'),\n      transitionProp = getStyleProperty('transitionProperty');\n\n\n  // ========================= miniModernizr ===============================\n  // <3<3<3 and thanks to Faruk and Paul for doing the heavy lifting\n\n  /*!\n   * Modernizr v1.6ish: miniModernizr for Isotope\n   * http://www.modernizr.com\n   *\n   * Developed by:\n   * - Faruk Ates  http://farukat.es/\n   * - Paul Irish  http://paulirish.com/\n   *\n   * Copyright (c) 2009-2010\n   * Dual-licensed under the BSD or MIT licenses.\n   * http://www.modernizr.com/license/\n   */\n\n  /*\n   * This version whittles down the script just to check support for\n   * CSS transitions, transforms, and 3D transforms.\n  */\n\n  var tests = {\n    csstransforms: function() {\n      return !!transformProp;\n    },\n\n    csstransforms3d: function() {\n      var test = !!getStyleProperty('perspective');\n      // double check for Chrome's false positive\n      if ( test ) {\n        var vendorCSSPrefixes = ' -o- -moz- -ms- -webkit- -khtml- '.split(' '),\n            mediaQuery = '@media (' + vendorCSSPrefixes.join('transform-3d),(') + 'modernizr)',\n            $style = $('<style>' + mediaQuery + '{#modernizr{height:3px}}' + '</style>')\n                        .appendTo('head'),\n            $div = $('<div id=\"modernizr\" />').appendTo('html');\n\n        test = $div.height() === 3;\n\n        $div.remove();\n        $style.remove();\n      }\n      return test;\n    },\n\n    csstransitions: function() {\n      return !!transitionProp;\n    }\n  };\n\n  var testName;\n\n  if ( Modernizr ) {\n    // if there's a previous Modernzir, check if there are necessary tests\n    for ( testName in tests) {\n      if ( !Modernizr.hasOwnProperty( testName ) ) {\n        // if test hasn't been run, use addTest to run it\n        Modernizr.addTest( testName, tests[ testName ] );\n      }\n    }\n  } else {\n    // or create new mini Modernizr that just has the 3 tests\n    Modernizr = window.Modernizr = {\n      _version : '1.6ish: miniModernizr for Isotope'\n    };\n\n    var classes = ' ';\n    var result;\n\n    // Run through tests\n    for ( testName in tests) {\n      result = tests[ testName ]();\n      Modernizr[ testName ] = result;\n      classes += ' ' + ( result ?  '' : 'no-' ) + testName;\n    }\n\n    // Add the new classes to the <html> element.\n    $('html').addClass( classes );\n  }\n\n\n  // ========================= isoTransform ===============================\n\n  /**\n   *  provides hooks for .css({ scale: value, translate: [x, y] })\n   *  Progressively enhanced CSS transforms\n   *  Uses hardware accelerated 3D transforms for Safari\n   *  or falls back to 2D transforms.\n   */\n\n  if ( Modernizr.csstransforms ) {\n\n        // i.e. transformFnNotations.scale(0.5) >> 'scale3d( 0.5, 0.5, 1)'\n    var transformFnNotations = Modernizr.csstransforms3d ?\n      { // 3D transform functions\n        translate : function ( position ) {\n          return 'translate3d(' + position[0] + 'px, ' + position[1] + 'px, 0) ';\n        },\n        scale : function ( scale ) {\n          return 'scale3d(' + scale + ', ' + scale + ', 1) ';\n        }\n      } :\n      { // 2D transform functions\n        translate : function ( position ) {\n          return 'translate(' + position[0] + 'px, ' + position[1] + 'px) ';\n        },\n        scale : function ( scale ) {\n          return 'scale(' + scale + ') ';\n        }\n      }\n    ;\n\n    var setIsoTransform = function ( elem, name, value ) {\n          // unpack current transform data\n      var data =  $.data( elem, 'isoTransform' ) || {},\n          newData = {},\n          fnName,\n          transformObj = {},\n          transformValue;\n\n      // i.e. newData.scale = 0.5\n      newData[ name ] = value;\n      // extend new value over current data\n      $.extend( data, newData );\n\n      for ( fnName in data ) {\n        transformValue = data[ fnName ];\n        transformObj[ fnName ] = transformFnNotations[ fnName ]( transformValue );\n      }\n\n      // get proper order\n      // ideally, we could loop through this give an array, but since we only have\n      // a couple transforms we're keeping track of, we'll do it like so\n      var translateFn = transformObj.translate || '',\n          scaleFn = transformObj.scale || '',\n          // sorting so translate always comes first\n          valueFns = translateFn + scaleFn;\n\n      // set data back in elem\n      $.data( elem, 'isoTransform', data );\n\n      // set name to vendor specific property\n      elem.style[ transformProp ] = valueFns;\n    };\n\n    // ==================== scale ===================\n\n    $.cssNumber.scale = true;\n\n    $.cssHooks.scale = {\n      set: function( elem, value ) {\n        // uncomment this bit if you want to properly parse strings\n        // if ( typeof value === 'string' ) {\n        //   value = parseFloat( value );\n        // }\n        setIsoTransform( elem, 'scale', value );\n      },\n      get: function( elem, computed ) {\n        var transform = $.data( elem, 'isoTransform' );\n        return transform && transform.scale ? transform.scale : 1;\n      }\n    };\n\n    $.fx.step.scale = function( fx ) {\n      $.cssHooks.scale.set( fx.elem, fx.now+fx.unit );\n    };\n\n\n    // ==================== translate ===================\n\n    $.cssNumber.translate = true;\n\n    $.cssHooks.translate = {\n      set: function( elem, value ) {\n\n        // uncomment this bit if you want to properly parse strings\n        // if ( typeof value === 'string' ) {\n        //   value = value.split(' ');\n        // }\n        //\n        // var i, val;\n        // for ( i = 0; i < 2; i++ ) {\n        //   val = value[i];\n        //   if ( typeof val === 'string' ) {\n        //     val = parseInt( val );\n        //   }\n        // }\n\n        setIsoTransform( elem, 'translate', value );\n      },\n\n      get: function( elem, computed ) {\n        var transform = $.data( elem, 'isoTransform' );\n        return transform && transform.translate ? transform.translate : [ 0, 0 ];\n      }\n    };\n\n  }\n\n  // ========================= get transition-end event ===============================\n  var transitionEndEvent, transitionDurProp;\n\n  if ( Modernizr.csstransitions ) {\n    transitionEndEvent = {\n      WebkitTransitionProperty: 'webkitTransitionEnd',  // webkit\n      MozTransitionProperty: 'transitionend',\n      OTransitionProperty: 'oTransitionEnd otransitionend',\n      transitionProperty: 'transitionend'\n    }[ transitionProp ];\n\n    transitionDurProp = getStyleProperty('transitionDuration');\n  }\n\n  // ========================= smartresize ===============================\n\n  /*\n   * smartresize: debounced resize event for jQuery\n   *\n   * latest version and complete README available on Github:\n   * https://github.com/louisremi/jquery.smartresize.js\n   *\n   * Copyright 2011 @louis_remi\n   * Licensed under the MIT license.\n   */\n\n  var $event = $.event,\n      dispatchMethod = $.event.handle ? 'handle' : 'dispatch',\n      resizeTimeout;\n\n  $event.special.smartresize = {\n    setup: function() {\n      $(this).bind( \"resize\", $event.special.smartresize.handler );\n    },\n    teardown: function() {\n      $(this).unbind( \"resize\", $event.special.smartresize.handler );\n    },\n    handler: function( event, execAsap ) {\n      // Save the context\n      var context = this,\n          args = arguments;\n\n      // set correct event type\n      event.type = \"smartresize\";\n\n      if ( resizeTimeout ) { clearTimeout( resizeTimeout ); }\n      resizeTimeout = setTimeout(function() {\n        $event[ dispatchMethod ].apply( context, args );\n      }, execAsap === \"execAsap\"? 0 : 100 );\n    }\n  };\n\n  $.fn.smartresize = function( fn ) {\n    return fn ? this.bind( \"smartresize\", fn ) : this.trigger( \"smartresize\", [\"execAsap\"] );\n  };\n\n\n\n// ========================= Isotope ===============================\n\n\n  // our \"Widget\" object constructor\n  $.Isotope = function( options, element, callback ){\n    this.element = $( element );\n\n    this._create( options );\n    this._init( callback );\n  };\n\n  // styles of container element we want to keep track of\n  var isoContainerStyles = [ 'width', 'height' ];\n\n  var $window = $(window);\n\n  $.Isotope.settings = {\n    resizable: true,\n    layoutMode : 'masonry',\n    containerClass : 'isotope',\n    itemClass : 'isotope-item',\n    hiddenClass : 'isotope-hidden',\n    hiddenStyle: { opacity: 0, scale: 0.001 },\n    visibleStyle: { opacity: 1, scale: 1 },\n    containerStyle: {\n      position: 'relative',\n      overflow: 'hidden'\n    },\n    animationEngine: 'best-available',\n    animationOptions: {\n      queue: false,\n      duration: 800\n    },\n    sortBy : 'original-order',\n    sortAscending : true,\n    resizesContainer : true,\n    transformsEnabled: true,\n    itemPositionDataEnabled: false\n  };\n\n  $.Isotope.prototype = {\n\n    // sets up widget\n    _create : function( options ) {\n\n      this.options = $.extend( {}, $.Isotope.settings, options );\n\n      this.styleQueue = [];\n      this.elemCount = 0;\n\n      // get original styles in case we re-apply them in .destroy()\n      var elemStyle = this.element[0].style;\n      this.originalStyle = {};\n      // keep track of container styles\n      var containerStyles = isoContainerStyles.slice(0);\n      for ( var prop in this.options.containerStyle ) {\n        containerStyles.push( prop );\n      }\n      for ( var i=0, len = containerStyles.length; i < len; i++ ) {\n        prop = containerStyles[i];\n        this.originalStyle[ prop ] = elemStyle[ prop ] || '';\n      }\n      // apply container style from options\n      this.element.css( this.options.containerStyle );\n\n      this._updateAnimationEngine();\n      this._updateUsingTransforms();\n\n      // sorting\n      var originalOrderSorter = {\n        'original-order' : function( $elem, instance ) {\n          instance.elemCount ++;\n          return instance.elemCount;\n        },\n        random : function() {\n          return Math.random();\n        }\n      };\n\n      this.options.getSortData = $.extend( this.options.getSortData, originalOrderSorter );\n\n      // need to get atoms\n      this.reloadItems();\n\n      // get top left position of where the bricks should be\n      this.offset = {\n        left: parseInt( ( this.element.css('padding-left') || 0 ), 10 ),\n        top: parseInt( ( this.element.css('padding-top') || 0 ), 10 )\n      };\n\n      // add isotope class first time around\n      var instance = this;\n      setTimeout( function() {\n        instance.element.addClass( instance.options.containerClass );\n      }, 0 );\n\n      // bind resize method\n      if ( this.options.resizable ) {\n        $window.bind( 'smartresize.isotope', function() {\n          instance.resize();\n        });\n      }\n\n      // dismiss all click events from hidden events\n      this.element.delegate( '.' + this.options.hiddenClass, 'click', function(){\n        return false;\n      });\n\n    },\n\n    _getAtoms : function( $elems ) {\n      var selector = this.options.itemSelector,\n          // filter & find\n          $atoms = selector ? $elems.filter( selector ).add( $elems.find( selector ) ) : $elems,\n          // base style for atoms\n          atomStyle = { position: 'absolute' };\n\n      // filter out text nodes\n      $atoms = $atoms.filter( function( i, atom ) {\n        return atom.nodeType === 1;\n      });\n\n      if ( this.usingTransforms ) {\n        atomStyle.left = 0;\n        atomStyle.top = 0;\n      }\n\n      $atoms.css( atomStyle ).addClass( this.options.itemClass );\n\n      this.updateSortData( $atoms, true );\n\n      return $atoms;\n    },\n\n    // _init fires when your instance is first created\n    // (from the constructor above), and when you\n    // attempt to initialize the widget again (by the bridge)\n    // after it has already been initialized.\n    _init : function( callback ) {\n\n      this.$filteredAtoms = this._filter( this.$allAtoms );\n      this._sort();\n      this.reLayout( callback );\n\n    },\n\n    option : function( opts ){\n      // change options AFTER initialization:\n      // signature: $('#foo').bar({ cool:false });\n      if ( $.isPlainObject( opts ) ){\n        this.options = $.extend( true, this.options, opts );\n\n        // trigger _updateOptionName if it exists\n        var updateOptionFn;\n        for ( var optionName in opts ) {\n          updateOptionFn = '_update' + capitalize( optionName );\n          if ( this[ updateOptionFn ] ) {\n            this[ updateOptionFn ]();\n          }\n        }\n      }\n    },\n\n    // ====================== updaters ====================== //\n    // kind of like setters\n\n    _updateAnimationEngine : function() {\n      var animationEngine = this.options.animationEngine.toLowerCase().replace( /[ _\\-]/g, '');\n      var isUsingJQueryAnimation;\n      // set applyStyleFnName\n      switch ( animationEngine ) {\n        case 'css' :\n        case 'none' :\n          isUsingJQueryAnimation = false;\n          break;\n        case 'jquery' :\n          isUsingJQueryAnimation = true;\n          break;\n        default : // best available\n          isUsingJQueryAnimation = !Modernizr.csstransitions;\n      }\n      this.isUsingJQueryAnimation = isUsingJQueryAnimation;\n      this._updateUsingTransforms();\n    },\n\n    _updateTransformsEnabled : function() {\n      this._updateUsingTransforms();\n    },\n\n    _updateUsingTransforms : function() {\n      var usingTransforms = this.usingTransforms = this.options.transformsEnabled &&\n        Modernizr.csstransforms && Modernizr.csstransitions && !this.isUsingJQueryAnimation;\n\n      // prevent scales when transforms are disabled\n      if ( !usingTransforms ) {\n        delete this.options.hiddenStyle.scale;\n        delete this.options.visibleStyle.scale;\n      }\n\n      this.getPositionStyles = usingTransforms ? this._translate : this._positionAbs;\n    },\n\n\n    // ====================== Filtering ======================\n\n    _filter : function( $atoms ) {\n      var filter = this.options.filter === '' ? '*' : this.options.filter;\n\n      if ( !filter ) {\n        return $atoms;\n      }\n\n      var hiddenClass    = this.options.hiddenClass,\n          hiddenSelector = '.' + hiddenClass,\n          $hiddenAtoms   = $atoms.filter( hiddenSelector ),\n          $atomsToShow   = $hiddenAtoms;\n\n      if ( filter !== '*' ) {\n        $atomsToShow = $hiddenAtoms.filter( filter );\n        var $atomsToHide = $atoms.not( hiddenSelector ).not( filter ).addClass( hiddenClass );\n        this.styleQueue.push({ $el: $atomsToHide, style: this.options.hiddenStyle });\n      }\n\n      this.styleQueue.push({ $el: $atomsToShow, style: this.options.visibleStyle });\n      $atomsToShow.removeClass( hiddenClass );\n\n      return $atoms.filter( filter );\n    },\n\n    // ====================== Sorting ======================\n\n    updateSortData : function( $atoms, isIncrementingElemCount ) {\n      var instance = this,\n          getSortData = this.options.getSortData,\n          $this, sortData;\n      $atoms.each(function(){\n        $this = $(this);\n        sortData = {};\n        // get value for sort data based on fn( $elem ) passed in\n        for ( var key in getSortData ) {\n          if ( !isIncrementingElemCount && key === 'original-order' ) {\n            // keep original order original\n            sortData[ key ] = $.data( this, 'isotope-sort-data' )[ key ];\n          } else {\n            sortData[ key ] = getSortData[ key ]( $this, instance );\n          }\n        }\n        // apply sort data to element\n        $.data( this, 'isotope-sort-data', sortData );\n      });\n    },\n\n    // used on all the filtered atoms\n    _sort : function() {\n\n      var sortBy = this.options.sortBy,\n          getSorter = this._getSorter,\n          sortDir = this.options.sortAscending ? 1 : -1,\n          sortFn = function( alpha, beta ) {\n            var a = getSorter( alpha, sortBy ),\n                b = getSorter( beta, sortBy );\n            // fall back to original order if data matches\n            if ( a === b && sortBy !== 'original-order') {\n              a = getSorter( alpha, 'original-order' );\n              b = getSorter( beta, 'original-order' );\n            }\n            return ( ( a > b ) ? 1 : ( a < b ) ? -1 : 0 ) * sortDir;\n          };\n\n      this.$filteredAtoms.sort( sortFn );\n    },\n\n    _getSorter : function( elem, sortBy ) {\n      return $.data( elem, 'isotope-sort-data' )[ sortBy ];\n    },\n\n    // ====================== Layout Helpers ======================\n\n    _translate : function( x, y ) {\n      return { translate : [ x, y ] };\n    },\n\n    _positionAbs : function( x, y ) {\n      return { left: x, top: y };\n    },\n\n    _pushPosition : function( $elem, x, y ) {\n      x = Math.round( x + this.offset.left );\n      y = Math.round( y + this.offset.top );\n      var position = this.getPositionStyles( x, y );\n      this.styleQueue.push({ $el: $elem, style: position });\n      if ( this.options.itemPositionDataEnabled ) {\n        $elem.data('isotope-item-position', {x: x, y: y} );\n      }\n    },\n\n\n    // ====================== General Layout ======================\n\n    // used on collection of atoms (should be filtered, and sorted before )\n    // accepts atoms-to-be-laid-out to start with\n    layout : function( $elems, callback ) {\n\n      var layoutMode = this.options.layoutMode;\n\n      // layout logic\n      this[ '_' +  layoutMode + 'Layout' ]( $elems );\n\n      // set the size of the container\n      if ( this.options.resizesContainer ) {\n        var containerStyle = this[ '_' +  layoutMode + 'GetContainerSize' ]();\n        this.styleQueue.push({ $el: this.element, style: containerStyle });\n      }\n\n      this._processStyleQueue( $elems, callback );\n\n      this.isLaidOut = true;\n    },\n\n    _processStyleQueue : function( $elems, callback ) {\n      // are we animating the layout arrangement?\n      // use plugin-ish syntax for css or animate\n      var styleFn = !this.isLaidOut ? 'css' : (\n            this.isUsingJQueryAnimation ? 'animate' : 'css'\n          ),\n          animOpts = this.options.animationOptions,\n          onLayout = this.options.onLayout,\n          objStyleFn, processor,\n          triggerCallbackNow, callbackFn;\n\n      // default styleQueue processor, may be overwritten down below\n      processor = function( i, obj ) {\n        obj.$el[ styleFn ]( obj.style, animOpts );\n      };\n\n      if ( this._isInserting && this.isUsingJQueryAnimation ) {\n        // if using styleQueue to insert items\n        processor = function( i, obj ) {\n          // only animate if it not being inserted\n          objStyleFn = obj.$el.hasClass('no-transition') ? 'css' : styleFn;\n          obj.$el[ objStyleFn ]( obj.style, animOpts );\n        };\n\n      } else if ( callback || onLayout || animOpts.complete ) {\n        // has callback\n        var isCallbackTriggered = false,\n            // array of possible callbacks to trigger\n            callbacks = [ callback, onLayout, animOpts.complete ],\n            instance = this;\n        triggerCallbackNow = true;\n        // trigger callback only once\n        callbackFn = function() {\n          if ( isCallbackTriggered ) {\n            return;\n          }\n          var hollaback;\n          for (var i=0, len = callbacks.length; i < len; i++) {\n            hollaback = callbacks[i];\n            if ( typeof hollaback === 'function' ) {\n              hollaback.call( instance.element, $elems, instance );\n            }\n          }\n          isCallbackTriggered = true;\n        };\n\n        if ( this.isUsingJQueryAnimation && styleFn === 'animate' ) {\n          // add callback to animation options\n          animOpts.complete = callbackFn;\n          triggerCallbackNow = false;\n\n        } else if ( Modernizr.csstransitions ) {\n          // detect if first item has transition\n          var i = 0,\n              firstItem = this.styleQueue[0],\n              testElem = firstItem && firstItem.$el,\n              styleObj;\n          // get first non-empty jQ object\n          while ( !testElem || !testElem.length ) {\n            styleObj = this.styleQueue[ i++ ];\n            // HACK: sometimes styleQueue[i] is undefined\n            if ( !styleObj ) {\n              return;\n            }\n            testElem = styleObj.$el;\n          }\n          // get transition duration of the first element in that object\n          // yeah, this is inexact\n          var duration = parseFloat( getComputedStyle( testElem[0] )[ transitionDurProp ] );\n          if ( duration > 0 ) {\n            processor = function( i, obj ) {\n              obj.$el[ styleFn ]( obj.style, animOpts )\n                // trigger callback at transition end\n                .one( transitionEndEvent, callbackFn );\n            };\n            triggerCallbackNow = false;\n          }\n        }\n      }\n\n      // process styleQueue\n      $.each( this.styleQueue, processor );\n\n      if ( triggerCallbackNow ) {\n        callbackFn();\n      }\n\n      // clear out queue for next time\n      this.styleQueue = [];\n    },\n\n\n    resize : function() {\n      if ( this[ '_' + this.options.layoutMode + 'ResizeChanged' ]() ) {\n        this.reLayout();\n      }\n    },\n\n\n    reLayout : function( callback ) {\n\n      this[ '_' +  this.options.layoutMode + 'Reset' ]();\n      this.layout( this.$filteredAtoms, callback );\n\n    },\n\n    // ====================== Convenience methods ======================\n\n    // ====================== Adding items ======================\n\n    // adds a jQuery object of items to a isotope container\n    addItems : function( $content, callback ) {\n      var $newAtoms = this._getAtoms( $content );\n      // add new atoms to atoms pools\n      this.$allAtoms = this.$allAtoms.add( $newAtoms );\n\n      if ( callback ) {\n        callback( $newAtoms );\n      }\n    },\n\n    // convienence method for adding elements properly to any layout\n    // positions items, hides them, then animates them back in <--- very sezzy\n    insert : function( $content, callback ) {\n      // position items\n      this.element.append( $content );\n\n      var instance = this;\n      this.addItems( $content, function( $newAtoms ) {\n        var $newFilteredAtoms = instance._filter( $newAtoms );\n        instance._addHideAppended( $newFilteredAtoms );\n        instance._sort();\n        instance.reLayout();\n        instance._revealAppended( $newFilteredAtoms, callback );\n      });\n\n    },\n\n    // convienence method for working with Infinite Scroll\n    appended : function( $content, callback ) {\n      var instance = this;\n      this.addItems( $content, function( $newAtoms ) {\n        instance._addHideAppended( $newAtoms );\n        instance.layout( $newAtoms );\n        instance._revealAppended( $newAtoms, callback );\n      });\n    },\n\n    // adds new atoms, then hides them before positioning\n    _addHideAppended : function( $newAtoms ) {\n      this.$filteredAtoms = this.$filteredAtoms.add( $newAtoms );\n      $newAtoms.addClass('no-transition');\n\n      this._isInserting = true;\n\n      // apply hidden styles\n      this.styleQueue.push({ $el: $newAtoms, style: this.options.hiddenStyle });\n    },\n\n    // sets visible style on new atoms\n    _revealAppended : function( $newAtoms, callback ) {\n      var instance = this;\n      // apply visible style after a sec\n      setTimeout( function() {\n        // enable animation\n        $newAtoms.removeClass('no-transition');\n        // reveal newly inserted filtered elements\n        instance.styleQueue.push({ $el: $newAtoms, style: instance.options.visibleStyle });\n        instance._isInserting = false;\n        instance._processStyleQueue( $newAtoms, callback );\n      }, 10 );\n    },\n\n    // gathers all atoms\n    reloadItems : function() {\n      this.$allAtoms = this._getAtoms( this.element.children() );\n    },\n\n    // removes elements from Isotope widget\n    remove: function( $content, callback ) {\n      // remove elements immediately from Isotope instance\n      this.$allAtoms = this.$allAtoms.not( $content );\n      this.$filteredAtoms = this.$filteredAtoms.not( $content );\n      // remove() as a callback, for after transition / animation\n      var instance = this;\n      var removeContent = function() {\n        $content.remove();\n        if ( callback ) {\n          callback.call( instance.element );\n        }\n      };\n\n      if ( $content.filter( ':not(.' + this.options.hiddenClass + ')' ).length ) {\n        // if any non-hidden content needs to be removed\n        this.styleQueue.push({ $el: $content, style: this.options.hiddenStyle });\n        this._sort();\n        this.reLayout( removeContent );\n      } else {\n        // remove it now\n        removeContent();\n      }\n\n    },\n\n    shuffle : function( callback ) {\n      this.updateSortData( this.$allAtoms );\n      this.options.sortBy = 'random';\n      this._sort();\n      this.reLayout( callback );\n    },\n\n    // destroys widget, returns elements and container back (close) to original style\n    destroy : function() {\n\n      var usingTransforms = this.usingTransforms;\n      var options = this.options;\n\n      this.$allAtoms\n        .removeClass( options.hiddenClass + ' ' + options.itemClass )\n        .each(function(){\n          var style = this.style;\n          style.position = '';\n          style.top = '';\n          style.left = '';\n          style.opacity = '';\n          if ( usingTransforms ) {\n            style[ transformProp ] = '';\n          }\n        });\n\n      // re-apply saved container styles\n      var elemStyle = this.element[0].style;\n      for ( var prop in this.originalStyle ) {\n        elemStyle[ prop ] = this.originalStyle[ prop ];\n      }\n\n      this.element\n        .unbind('.isotope')\n        .undelegate( '.' + options.hiddenClass, 'click' )\n        .removeClass( options.containerClass )\n        .removeData('isotope');\n\n      $window.unbind('.isotope');\n\n    },\n\n\n    // ====================== LAYOUTS ======================\n\n    // calculates number of rows or columns\n    // requires columnWidth or rowHeight to be set on namespaced object\n    // i.e. this.masonry.columnWidth = 200\n    _getSegments : function( isRows ) {\n      var namespace = this.options.layoutMode,\n          measure  = isRows ? 'rowHeight' : 'columnWidth',\n          size     = isRows ? 'height' : 'width',\n          segmentsName = isRows ? 'rows' : 'cols',\n          containerSize = this.element[ size ](),\n          segments,\n                    // i.e. options.masonry && options.masonry.columnWidth\n          segmentSize = this.options[ namespace ] && this.options[ namespace ][ measure ] ||\n                    // or use the size of the first item, i.e. outerWidth\n                    this.$filteredAtoms[ 'outer' + capitalize(size) ](true) ||\n                    // if there's no items, use size of container\n                    containerSize;\n\n      segments = Math.floor( containerSize / segmentSize );\n      segments = Math.max( segments, 1 );\n\n      // i.e. this.masonry.cols = ....\n      this[ namespace ][ segmentsName ] = segments;\n      // i.e. this.masonry.columnWidth = ...\n      this[ namespace ][ measure ] = segmentSize;\n\n    },\n\n    _checkIfSegmentsChanged : function( isRows ) {\n      var namespace = this.options.layoutMode,\n          segmentsName = isRows ? 'rows' : 'cols',\n          prevSegments = this[ namespace ][ segmentsName ];\n      // update cols/rows\n      this._getSegments( isRows );\n      // return if updated cols/rows is not equal to previous\n      return ( this[ namespace ][ segmentsName ] !== prevSegments );\n    },\n\n    // ====================== Masonry ======================\n\n    _masonryReset : function() {\n      // layout-specific props\n      this.masonry = {};\n      // FIXME shouldn't have to call this again\n      this._getSegments();\n      var i = this.masonry.cols;\n      this.masonry.colYs = [];\n      while (i--) {\n        this.masonry.colYs.push( 0 );\n      }\n    },\n\n    _masonryLayout : function( $elems ) {\n      var instance = this,\n          props = instance.masonry;\n      $elems.each(function(){\n        var $this  = $(this),\n            //how many columns does this brick span\n            colSpan = Math.ceil( $this.outerWidth(true) / props.columnWidth );\n        colSpan = Math.min( colSpan, props.cols );\n\n        if ( colSpan === 1 ) {\n          // if brick spans only one column, just like singleMode\n          instance._masonryPlaceBrick( $this, props.colYs );\n        } else {\n          // brick spans more than one column\n          // how many different places could this brick fit horizontally\n          var groupCount = props.cols + 1 - colSpan,\n              groupY = [],\n              groupColY,\n              i;\n\n          // for each group potential horizontal position\n          for ( i=0; i < groupCount; i++ ) {\n            // make an array of colY values for that one group\n            groupColY = props.colYs.slice( i, i+colSpan );\n            // and get the max value of the array\n            groupY[i] = Math.max.apply( Math, groupColY );\n          }\n\n          instance._masonryPlaceBrick( $this, groupY );\n        }\n      });\n    },\n\n    // worker method that places brick in the columnSet\n    //   with the the minY\n    _masonryPlaceBrick : function( $brick, setY ) {\n      // get the minimum Y value from the columns\n      var minimumY = Math.min.apply( Math, setY ),\n          shortCol = 0;\n\n      // Find index of short column, the first from the left\n      for (var i=0, len = setY.length; i < len; i++) {\n        if ( setY[i] === minimumY ) {\n          shortCol = i;\n          break;\n        }\n      }\n\n      // position the brick\n      var x = this.masonry.columnWidth * shortCol,\n          y = minimumY;\n      this._pushPosition( $brick, x, y );\n\n      // apply setHeight to necessary columns\n      var setHeight = minimumY + $brick.outerHeight(true),\n          setSpan = this.masonry.cols + 1 - len;\n      for ( i=0; i < setSpan; i++ ) {\n        this.masonry.colYs[ shortCol + i ] = setHeight;\n      }\n\n    },\n\n    _masonryGetContainerSize : function() {\n      var containerHeight = Math.max.apply( Math, this.masonry.colYs );\n      return { height: containerHeight };\n    },\n\n    _masonryResizeChanged : function() {\n      return this._checkIfSegmentsChanged();\n    },\n\n    // ====================== fitRows ======================\n\n    _fitRowsReset : function() {\n      this.fitRows = {\n        x : 0,\n        y : 0,\n        height : 0\n      };\n    },\n\n    _fitRowsLayout : function( $elems ) {\n      var instance = this,\n          containerWidth = this.element.width(),\n          props = this.fitRows;\n\n      $elems.each( function() {\n        var $this = $(this),\n            atomW = $this.outerWidth(true),\n            atomH = $this.outerHeight(true);\n\n        if ( props.x !== 0 && atomW + props.x > containerWidth ) {\n          // if this element cannot fit in the current row\n          props.x = 0;\n          props.y = props.height;\n        }\n\n        // position the atom\n        instance._pushPosition( $this, props.x, props.y );\n\n        props.height = Math.max( props.y + atomH, props.height );\n        props.x += atomW;\n\n      });\n    },\n\n    _fitRowsGetContainerSize : function () {\n      return { height : this.fitRows.height };\n    },\n\n    _fitRowsResizeChanged : function() {\n      return true;\n    },\n\n\n    // ====================== cellsByRow ======================\n\n    _cellsByRowReset : function() {\n      this.cellsByRow = {\n        index : 0\n      };\n      // get this.cellsByRow.columnWidth\n      this._getSegments();\n      // get this.cellsByRow.rowHeight\n      this._getSegments(true);\n    },\n\n    _cellsByRowLayout : function( $elems ) {\n      var instance = this,\n          props = this.cellsByRow;\n      $elems.each( function(){\n        var $this = $(this),\n            col = props.index % props.cols,\n            row = Math.floor( props.index / props.cols ),\n            x = ( col + 0.5 ) * props.columnWidth - $this.outerWidth(true) / 2,\n            y = ( row + 0.5 ) * props.rowHeight - $this.outerHeight(true) / 2;\n        instance._pushPosition( $this, x, y );\n        props.index ++;\n      });\n    },\n\n    _cellsByRowGetContainerSize : function() {\n      return { height : Math.ceil( this.$filteredAtoms.length / this.cellsByRow.cols ) * this.cellsByRow.rowHeight + this.offset.top };\n    },\n\n    _cellsByRowResizeChanged : function() {\n      return this._checkIfSegmentsChanged();\n    },\n\n\n    // ====================== straightDown ======================\n\n    _straightDownReset : function() {\n      this.straightDown = {\n        y : 0\n      };\n    },\n\n    _straightDownLayout : function( $elems ) {\n      var instance = this;\n      $elems.each( function( i ){\n        var $this = $(this);\n        instance._pushPosition( $this, 0, instance.straightDown.y );\n        instance.straightDown.y += $this.outerHeight(true);\n      });\n    },\n\n    _straightDownGetContainerSize : function() {\n      return { height : this.straightDown.y };\n    },\n\n    _straightDownResizeChanged : function() {\n      return true;\n    },\n\n\n    // ====================== masonryHorizontal ======================\n\n    _masonryHorizontalReset : function() {\n      // layout-specific props\n      this.masonryHorizontal = {};\n      // FIXME shouldn't have to call this again\n      this._getSegments( true );\n      var i = this.masonryHorizontal.rows;\n      this.masonryHorizontal.rowXs = [];\n      while (i--) {\n        this.masonryHorizontal.rowXs.push( 0 );\n      }\n    },\n\n    _masonryHorizontalLayout : function( $elems ) {\n      var instance = this,\n          props = instance.masonryHorizontal;\n      $elems.each(function(){\n        var $this  = $(this),\n            //how many rows does this brick span\n            rowSpan = Math.ceil( $this.outerHeight(true) / props.rowHeight );\n        rowSpan = Math.min( rowSpan, props.rows );\n\n        if ( rowSpan === 1 ) {\n          // if brick spans only one column, just like singleMode\n          instance._masonryHorizontalPlaceBrick( $this, props.rowXs );\n        } else {\n          // brick spans more than one row\n          // how many different places could this brick fit horizontally\n          var groupCount = props.rows + 1 - rowSpan,\n              groupX = [],\n              groupRowX, i;\n\n          // for each group potential horizontal position\n          for ( i=0; i < groupCount; i++ ) {\n            // make an array of colY values for that one group\n            groupRowX = props.rowXs.slice( i, i+rowSpan );\n            // and get the max value of the array\n            groupX[i] = Math.max.apply( Math, groupRowX );\n          }\n\n          instance._masonryHorizontalPlaceBrick( $this, groupX );\n        }\n      });\n    },\n\n    _masonryHorizontalPlaceBrick : function( $brick, setX ) {\n      // get the minimum Y value from the columns\n      var minimumX  = Math.min.apply( Math, setX ),\n          smallRow  = 0;\n      // Find index of smallest row, the first from the top\n      for (var i=0, len = setX.length; i < len; i++) {\n        if ( setX[i] === minimumX ) {\n          smallRow = i;\n          break;\n        }\n      }\n\n      // position the brick\n      var x = minimumX,\n          y = this.masonryHorizontal.rowHeight * smallRow;\n      this._pushPosition( $brick, x, y );\n\n      // apply setHeight to necessary columns\n      var setWidth = minimumX + $brick.outerWidth(true),\n          setSpan = this.masonryHorizontal.rows + 1 - len;\n      for ( i=0; i < setSpan; i++ ) {\n        this.masonryHorizontal.rowXs[ smallRow + i ] = setWidth;\n      }\n    },\n\n    _masonryHorizontalGetContainerSize : function() {\n      var containerWidth = Math.max.apply( Math, this.masonryHorizontal.rowXs );\n      return { width: containerWidth };\n    },\n\n    _masonryHorizontalResizeChanged : function() {\n      return this._checkIfSegmentsChanged(true);\n    },\n\n\n    // ====================== fitColumns ======================\n\n    _fitColumnsReset : function() {\n      this.fitColumns = {\n        x : 0,\n        y : 0,\n        width : 0\n      };\n    },\n\n    _fitColumnsLayout : function( $elems ) {\n      var instance = this,\n          containerHeight = this.element.height(),\n          props = this.fitColumns;\n      $elems.each( function() {\n        var $this = $(this),\n            atomW = $this.outerWidth(true),\n            atomH = $this.outerHeight(true);\n\n        if ( props.y !== 0 && atomH + props.y > containerHeight ) {\n          // if this element cannot fit in the current column\n          props.x = props.width;\n          props.y = 0;\n        }\n\n        // position the atom\n        instance._pushPosition( $this, props.x, props.y );\n\n        props.width = Math.max( props.x + atomW, props.width );\n        props.y += atomH;\n\n      });\n    },\n\n    _fitColumnsGetContainerSize : function () {\n      return { width : this.fitColumns.width };\n    },\n\n    _fitColumnsResizeChanged : function() {\n      return true;\n    },\n\n\n\n    // ====================== cellsByColumn ======================\n\n    _cellsByColumnReset : function() {\n      this.cellsByColumn = {\n        index : 0\n      };\n      // get this.cellsByColumn.columnWidth\n      this._getSegments();\n      // get this.cellsByColumn.rowHeight\n      this._getSegments(true);\n    },\n\n    _cellsByColumnLayout : function( $elems ) {\n      var instance = this,\n          props = this.cellsByColumn;\n      $elems.each( function(){\n        var $this = $(this),\n            col = Math.floor( props.index / props.rows ),\n            row = props.index % props.rows,\n            x = ( col + 0.5 ) * props.columnWidth - $this.outerWidth(true) / 2,\n            y = ( row + 0.5 ) * props.rowHeight - $this.outerHeight(true) / 2;\n        instance._pushPosition( $this, x, y );\n        props.index ++;\n      });\n    },\n\n    _cellsByColumnGetContainerSize : function() {\n      return { width : Math.ceil( this.$filteredAtoms.length / this.cellsByColumn.rows ) * this.cellsByColumn.columnWidth };\n    },\n\n    _cellsByColumnResizeChanged : function() {\n      return this._checkIfSegmentsChanged(true);\n    },\n\n    // ====================== straightAcross ======================\n\n    _straightAcrossReset : function() {\n      this.straightAcross = {\n        x : 0\n      };\n    },\n\n    _straightAcrossLayout : function( $elems ) {\n      var instance = this;\n      $elems.each( function( i ){\n        var $this = $(this);\n        instance._pushPosition( $this, instance.straightAcross.x, 0 );\n        instance.straightAcross.x += $this.outerWidth(true);\n      });\n    },\n\n    _straightAcrossGetContainerSize : function() {\n      return { width : this.straightAcross.x };\n    },\n\n    _straightAcrossResizeChanged : function() {\n      return true;\n    }\n\n  };\n\n\n  // ======================= imagesLoaded Plugin ===============================\n  /*!\n   * jQuery imagesLoaded plugin v1.1.0\n   * http://github.com/desandro/imagesloaded\n   *\n   * MIT License. by Paul Irish et al.\n   */\n\n\n  // $('#my-container').imagesLoaded(myFunction)\n  // or\n  // $('img').imagesLoaded(myFunction)\n\n  // execute a callback when all images have loaded.\n  // needed because .load() doesn't work on cached images\n\n  // callback function gets image collection as argument\n  //  `this` is the container\n\n  $.fn.imagesLoaded = function( callback ) {\n    var $this = this,\n        $images = $this.find('img').add( $this.filter('img') ),\n        len = $images.length,\n        blank = 'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///ywAAAAAAQABAAACAUwAOw==',\n        loaded = [];\n\n    function triggerCallback() {\n      callback.call( $this, $images );\n    }\n\n    function imgLoaded( event ) {\n      var img = event.target;\n      if ( img.src !== blank && $.inArray( img, loaded ) === -1 ){\n        loaded.push( img );\n        if ( --len <= 0 ){\n          setTimeout( triggerCallback );\n          $images.unbind( '.imagesLoaded', imgLoaded );\n        }\n      }\n    }\n\n    // if no images, trigger immediately\n    if ( !len ) {\n      triggerCallback();\n    }\n\n    $images.bind( 'load.imagesLoaded error.imagesLoaded',  imgLoaded ).each( function() {\n      // cached images don't fire load sometimes, so we reset src.\n      var src = this.src;\n      // webkit hack from http://groups.google.com/group/jquery-dev/browse_thread/thread/eee6ab7b2da50e1f\n      // data uri bypasses webkit log warning (thx doug jones)\n      this.src = blank;\n      this.src = src;\n    });\n\n    return $this;\n  };\n\n\n  // helper function for logging errors\n  // $.error breaks jQuery chaining\n  var logError = function( message ) {\n    if ( window.console ) {\n      window.console.error( message );\n    }\n  };\n\n  // =======================  Plugin bridge  ===============================\n  // leverages data method to either create or return $.Isotope constructor\n  // A bit from jQuery UI\n  //   https://github.com/jquery/jquery-ui/blob/master/ui/jquery.ui.widget.js\n  // A bit from jcarousel\n  //   https://github.com/jsor/jcarousel/blob/master/lib/jquery.jcarousel.js\n\n  $.fn.isotope = function( options, callback ) {\n    if ( typeof options === 'string' ) {\n      // call method\n      var args = Array.prototype.slice.call( arguments, 1 );\n\n      this.each(function(){\n        var instance = $.data( this, 'isotope' );\n        if ( !instance ) {\n          logError( \"cannot call methods on isotope prior to initialization; \" +\n              \"attempted to call method '\" + options + \"'\" );\n          return;\n        }\n        if ( !$.isFunction( instance[options] ) || options.charAt(0) === \"_\" ) {\n          logError( \"no such method '\" + options + \"' for isotope instance\" );\n          return;\n        }\n        // apply method\n        instance[ options ].apply( instance, args );\n      });\n    } else {\n      this.each(function() {\n        var instance = $.data( this, 'isotope' );\n        if ( instance ) {\n          // apply options & init\n          instance.option( options );\n          instance._init( callback );\n        } else {\n          // initialize new instance\n          $.data( this, 'isotope', new $.Isotope( options, this, callback ) );\n        }\n      });\n    }\n    // return jQuery object\n    // so plugin methods do not have to\n    return this;\n  };\n\n})( window, jQuery );\n\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "tags": ["js", "jQuery"]}