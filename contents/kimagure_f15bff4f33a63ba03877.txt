{"tags": ["Elm", "elmlang"], "context": "\n\n!!! OUT OF DATE !!! This is out of date, since everything here is written for 0.16 and below. I guess the code here with just Signal.map/mergeMany should work with the equivalent subscription versions kind of, but of course, you can't write programs in this fashion anymore in 0.17.\n(and using Elm with webpack)\nThere are a variety of writeups online about them that go into a lot of technical and design explanations for how ports work and why they are the way they are. This post seeks to simply look at how you use ports in Elm and some of their characteristics that might aid/hinder you.\nThis post is part of my ongoing efforts to provide googleable resources for \"obscure\" technologies so that others wanting to get into them quickly will be able to do so. (especially in the case of Elm, where you quite often end up reading source code a lot...)\n\nObjective\nWe'll make a simple JS + Elm application that \"fetches\" a list of files from JS and then displays them in the Elm application. The Elm application will communicate with the JS application through \"ports\" for get the new files and requesting a new list of files.\n\nSetup\nThree npm dependencies:\n\"dependencies\": {\n  \"elm-simple-loader\": \"^0.1.0\", // a webpack loader for Elm source code that I wrote so we can just boot up webpack like any normal JS project\n  \"rx\": \"^3.1.2\", // sane reactive programming in JS. helps us not have to write a bunch of buggy boilerplate and gives us \"Observables\" which are like Elm.Signals\n  \"webpack\": \"^1.12.2\" // our javascript bundling program.\n}\n\nThree elm dependencies:\n\"dependencies\": {\n  \"elm-lang/core\": \"2.1.0 <= v < 3.0.0\",\n  \"evancz/elm-html\": \"4.0.1 <= v < 5.0.0\"\n},\n\nYou could also just run elm package install -y and then install evancz/elm-html separately. Up to you.\nThen webpack.config.js:\nvar webpack = require('webpack');\n\nmodule.exports = {\n  entry: './src/js/app.js',\n  output: {\n    path: './build',\n    filename: 'app.js'\n  },\n  module: {\n    loaders: [\n      {\n        loader: 'elm-simple-loader',\n        test: /\\.elm$/,\n        exclude: /node_modules/\n      }\n    ]\n  }\n};\n\nThen this folder structure:\n\u25be src/\n  \u25be elm/\n      App.elm\n  \u25be js/\n      app.js\n\n\n\nAnnotated Code\n\nElm side Github link\n\nmodule App where\n\nimport Html exposing (..)\n-- we'll be using onClick to fire off our outgoing port\nimport Html.Events exposing (onClick)\n\n-- types important to our simple application that displays a list of files\ntype alias File = String\ntype alias Files = List File\n\n-- the model of our application. simple, right?\ntype alias Model = {\n  files: Files, -- the files we get fetched from the JS side\n  times: Int -- the number of times we've gotten data that we'll update with files\n}\n\n-- generic Action type that we'll use\ntype Action =\n  NoOp\n  | UpdateRequest\n\n-- our first port: the outgoing port\n-- first, we need a mailbox if we're going to have a signal and address.\n-- we'll declare a mailbox of Action\nupdateRequestMailbox : Signal.Mailbox Action\n-- we'll then instantiate one with a NoOp action by default\nupdateRequestMailbox = Signal.mailbox NoOp\n-- the \"port\" keyword is used to designate signals that are exposed in the compiled JS.\n-- they have the restriction of requiring concrete types, so we'll just emit strings\nport updateRequests : Signal String\n-- and so for our output stream, we will just map over each Action that comes in\n-- and just send down the string \"updateRequest\" instead.\nport updateRequests =\n  Signal.map (\\_ -> \"updateRequest\") updateRequestMailbox.signal\n\n-- our input port will be initialized and pushed to from the JS end,\n-- so all we need to do is declare the shape of data that will come down the port.\nport newFiles : Signal Files\n\n-- declare our updateFiles function. this will send down \"folder\" functions that\n-- will transform our old model into a new model.\nupdateFiles : Signal (Model -> Model)\n-- so in the definition we see that we will map over the newFiles signal\n-- and then update the model with new files and update the times property.\nupdateFiles =\n  Signal.map\n    (\\files -> (\\model -> { model | files <- files, times <- model.times + 1 }))\n    newFiles\n\n-- our update folder will just take the folders and apply them to our model\nupdate : (Model -> Model) -> Model -> Model\nupdate folder model =\n  folder model\n\n-- our updateRequestButton will handle onClick events by sending a message\n-- to updateRequestMailbox address with the Action. Give the Html.Events\n-- source a red if you're curious about the details.\nupdateRequestButton : Html\nupdateRequestButton =\n  button\n    [\n      onClick updateRequestMailbox.address UpdateRequest\n    ]\n    [text \"request update\"]\n\n-- the following views are boring\nfileView : File -> Html\nfileView file =\n  div [] [text file]\n\nfilesView : Files -> Html\nfilesView files =\n  div [] (List.map (\\n -> fileView n) files)\n\nview : Model -> Html\nview model =\n  div []\n    [\n      h3 [] [text \"Muh Filez:\"],\n      updateRequestButton,\n      h4 [] [text (\"times updated: \" ++ (toString model.times))],\n      filesView model.files\n    ]\n\n-- the initial model that we'll be using\nmodel =\n  {\n    files = [],\n    times = 0\n  }\n\n-- * if you're unfamiliar with the threading macro, basically it works as this:\n-- * (a |> max b) == (max b a)\n-- * so below is like (a |> fn1 b |> fn 2 c) == (fn 2 c (fn 1 b (a)))\n-- * the former is much easier to read, i think.\n-- so below we merge our folder functions, then we pass that into an updater and\n-- then our view mapper is there to produce a Signal Html for our main function.\nmain =\n  Signal.mergeMany\n    [\n      updateFiles\n    ]\n  |> Signal.foldp update model\n  |> Signal.map view\n\n\nJS side Github link\n\nvar Rx = require('rx');\n\n// bring in our Elm application through webpack!\nvar Elm = require('../elm/App.elm');\n\n// basically an event bus, but is an Observable we can subscribe to and whatnot\nvar filesData$ = new Rx.Subject();\n\n// default files listing\nvar files = [\n  'file1',\n  'file2',\n  'file3',\n  'file4',\n  'file5'\n];\n\nfunction loadFilesData() {\n  console.log('pretending to fetch data...');\n  // every time we \"fetch\" data, let's say it updated.\n  files.push('file' + files.length);\n  // fire off the files data stream with the new files\n  filesData$.onNext(files);\n}\n\nfunction init() {\n  var appContainer = document.getElementById('app');\n  console.log('embedding our Elm application!');\n  /**\n   * embed our elm app in our container.\n   * you might remember that this is what i was talking about in our Elm code,\n   * where you need to provide an initial value for these Signals.\n   * this is the one we control from the JS side, so we need to provide it from\n   * this side to make it work correctly.\n   *\n   * we also get the App instance returned when we call this, so\n   * we need to use to access our ports.\n   */\n  var elmApp = Elm.embed(Elm.App, appContainer, {\n    newFiles: [] // need to provide initial values to our listening port!\n  });\n\n  filesData$.subscribe(function (files) {\n    console.log('new data came down in our stream!');\n    console.log('sending data down our newFiles port...');\n    // so let's send the new files down the port\n    // in elm we had `port newFiles`, so this way we access this\n    // from JS is to do the following:\n    elmApp.ports.newFiles.send(files);\n  });\n\n  // just like above, we access the output port from JS similarly,\n  // but we will subscribe to the output from this.\n  // all we really care about is the event instead of the value,\n  // so we'll just kick of loadFilesData as a result.\n  elmApp.ports.updateRequests.subscribe(function (value) {\n    console.log('update request came from our updateRequests port!');\n    loadFilesData();\n  });\n\n  loadFilesData();\n}\n\ninit();\n\n\nBuilding and Running\nSo now you can just run webpack from your project root and everything builds!\nYou'll probably need a index.html like this:\n<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"utf-8\">\n    <title>Elm Simple Ports Example</title>\n  </head>\n\n  <body>\n    <div id=\"app\"></div>\n    <script src=\"build/app.js\"></script>\n  </body>\n</html>\n\nopen index.html and check it out!\n\nConclusion\nAnd so using ports with Elm really isn't that difficult. Now we can code a bunch of JS for the part that needs to integrate to whatever else we have (like legacy code, other JS libs, whatnot) and still have the guarantee of the Elm side of our application!\nSee the repository here: https://github.com/justinwoo/elm-simple-ports-example\nDemo here: http://justinwoo.github.io/elm-simple-ports-example\n\nReferences\n\nInterop - Ports: http://elm-lang.org/guide/interop#ports\n\nElm.Core.Signal - http://package.elm-lang.org/packages/elm-lang/core/2.1.0/Signal\n\n\n### **!!! OUT OF DATE !!!** This is out of date, since everything here is written for 0.16 and below. I guess the code here with just Signal.map/mergeMany should work with the equivalent subscription versions kind of, but of course, you can't write programs in this fashion anymore in 0.17.\n\n(and using Elm with webpack)\n\nThere are a variety of writeups online about them that go into a lot of technical and design explanations for how ports work and why they are the way they are. This post seeks to simply look at how you use ports in Elm and some of their characteristics that might aid/hinder you.\n\nThis post is part of my ongoing efforts to provide googleable resources for \"obscure\" technologies so that others wanting to get into them quickly will be able to do so. (especially in the case of Elm, where you quite often end up reading source code a lot...)\n\n## Objective\n\nWe'll make a simple JS + Elm application that \"fetches\" a list of files from JS and then displays them in the Elm application. The Elm application will communicate with the JS application through \"ports\" for get the new files and requesting a new list of files.\n\n## Setup\n\nThree npm dependencies:\n\n```\n\"dependencies\": {\n  \"elm-simple-loader\": \"^0.1.0\", // a webpack loader for Elm source code that I wrote so we can just boot up webpack like any normal JS project\n  \"rx\": \"^3.1.2\", // sane reactive programming in JS. helps us not have to write a bunch of buggy boilerplate and gives us \"Observables\" which are like Elm.Signals\n  \"webpack\": \"^1.12.2\" // our javascript bundling program.\n}\n```\n\nThree elm dependencies:\n\n```\n\"dependencies\": {\n  \"elm-lang/core\": \"2.1.0 <= v < 3.0.0\",\n  \"evancz/elm-html\": \"4.0.1 <= v < 5.0.0\"\n},\n```\n\nYou could also just run `elm package install -y` and then install `evancz/elm-html` separately. Up to you.\n\nThen `webpack.config.js`:\n\n```js\nvar webpack = require('webpack');\n\nmodule.exports = {\n  entry: './src/js/app.js',\n  output: {\n    path: './build',\n    filename: 'app.js'\n  },\n  module: {\n    loaders: [\n      {\n        loader: 'elm-simple-loader',\n        test: /\\.elm$/,\n        exclude: /node_modules/\n      }\n    ]\n  }\n};\n```\n\nThen this folder structure:\n\n```\n\u25be src/\n  \u25be elm/\n      App.elm\n  \u25be js/\n      app.js\n\n```\n\n## Annotated Code\n\n### Elm side [Github link](https://github.com/justinwoo/elm-simple-ports-example/blob/master/src/elm/App.elm)\n\n```elm\nmodule App where\n\nimport Html exposing (..)\n-- we'll be using onClick to fire off our outgoing port\nimport Html.Events exposing (onClick)\n\n-- types important to our simple application that displays a list of files\ntype alias File = String\ntype alias Files = List File\n\n-- the model of our application. simple, right?\ntype alias Model = {\n  files: Files, -- the files we get fetched from the JS side\n  times: Int -- the number of times we've gotten data that we'll update with files\n}\n\n-- generic Action type that we'll use\ntype Action =\n  NoOp\n  | UpdateRequest\n\n-- our first port: the outgoing port\n-- first, we need a mailbox if we're going to have a signal and address.\n-- we'll declare a mailbox of Action\nupdateRequestMailbox : Signal.Mailbox Action\n-- we'll then instantiate one with a NoOp action by default\nupdateRequestMailbox = Signal.mailbox NoOp\n-- the \"port\" keyword is used to designate signals that are exposed in the compiled JS.\n-- they have the restriction of requiring concrete types, so we'll just emit strings\nport updateRequests : Signal String\n-- and so for our output stream, we will just map over each Action that comes in\n-- and just send down the string \"updateRequest\" instead.\nport updateRequests =\n  Signal.map (\\_ -> \"updateRequest\") updateRequestMailbox.signal\n\n-- our input port will be initialized and pushed to from the JS end,\n-- so all we need to do is declare the shape of data that will come down the port.\nport newFiles : Signal Files\n\n-- declare our updateFiles function. this will send down \"folder\" functions that\n-- will transform our old model into a new model.\nupdateFiles : Signal (Model -> Model)\n-- so in the definition we see that we will map over the newFiles signal\n-- and then update the model with new files and update the times property.\nupdateFiles =\n  Signal.map\n    (\\files -> (\\model -> { model | files <- files, times <- model.times + 1 }))\n    newFiles\n\n-- our update folder will just take the folders and apply them to our model\nupdate : (Model -> Model) -> Model -> Model\nupdate folder model =\n  folder model\n\n-- our updateRequestButton will handle onClick events by sending a message\n-- to updateRequestMailbox address with the Action. Give the Html.Events\n-- source a red if you're curious about the details.\nupdateRequestButton : Html\nupdateRequestButton =\n  button\n    [\n      onClick updateRequestMailbox.address UpdateRequest\n    ]\n    [text \"request update\"]\n\n-- the following views are boring\nfileView : File -> Html\nfileView file =\n  div [] [text file]\n\nfilesView : Files -> Html\nfilesView files =\n  div [] (List.map (\\n -> fileView n) files)\n\nview : Model -> Html\nview model =\n  div []\n    [\n      h3 [] [text \"Muh Filez:\"],\n      updateRequestButton,\n      h4 [] [text (\"times updated: \" ++ (toString model.times))],\n      filesView model.files\n    ]\n\n-- the initial model that we'll be using\nmodel =\n  {\n    files = [],\n    times = 0\n  }\n\n-- * if you're unfamiliar with the threading macro, basically it works as this:\n-- * (a |> max b) == (max b a)\n-- * so below is like (a |> fn1 b |> fn 2 c) == (fn 2 c (fn 1 b (a)))\n-- * the former is much easier to read, i think.\n-- so below we merge our folder functions, then we pass that into an updater and\n-- then our view mapper is there to produce a Signal Html for our main function.\nmain =\n  Signal.mergeMany\n    [\n      updateFiles\n    ]\n  |> Signal.foldp update model\n  |> Signal.map view\n```\n\n### JS side [Github link](https://github.com/justinwoo/elm-simple-ports-example/blob/master/src/js/app.js)\n\n```js\nvar Rx = require('rx');\n\n// bring in our Elm application through webpack!\nvar Elm = require('../elm/App.elm');\n\n// basically an event bus, but is an Observable we can subscribe to and whatnot\nvar filesData$ = new Rx.Subject();\n\n// default files listing\nvar files = [\n  'file1',\n  'file2',\n  'file3',\n  'file4',\n  'file5'\n];\n\nfunction loadFilesData() {\n  console.log('pretending to fetch data...');\n  // every time we \"fetch\" data, let's say it updated.\n  files.push('file' + files.length);\n  // fire off the files data stream with the new files\n  filesData$.onNext(files);\n}\n\nfunction init() {\n  var appContainer = document.getElementById('app');\n  console.log('embedding our Elm application!');\n  /**\n   * embed our elm app in our container.\n   * you might remember that this is what i was talking about in our Elm code,\n   * where you need to provide an initial value for these Signals.\n   * this is the one we control from the JS side, so we need to provide it from\n   * this side to make it work correctly.\n   *\n   * we also get the App instance returned when we call this, so\n   * we need to use to access our ports.\n   */\n  var elmApp = Elm.embed(Elm.App, appContainer, {\n    newFiles: [] // need to provide initial values to our listening port!\n  });\n\n  filesData$.subscribe(function (files) {\n    console.log('new data came down in our stream!');\n    console.log('sending data down our newFiles port...');\n    // so let's send the new files down the port\n    // in elm we had `port newFiles`, so this way we access this\n    // from JS is to do the following:\n    elmApp.ports.newFiles.send(files);\n  });\n\n  // just like above, we access the output port from JS similarly,\n  // but we will subscribe to the output from this.\n  // all we really care about is the event instead of the value,\n  // so we'll just kick of loadFilesData as a result.\n  elmApp.ports.updateRequests.subscribe(function (value) {\n    console.log('update request came from our updateRequests port!');\n    loadFilesData();\n  });\n\n  loadFilesData();\n}\n\ninit();\n```\n\n### Building and Running\n\nSo now you can just run `webpack` from your project root and everything builds!\n\nYou'll probably need a `index.html` like this:\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"utf-8\">\n    <title>Elm Simple Ports Example</title>\n  </head>\n\n  <body>\n    <div id=\"app\"></div>\n    <script src=\"build/app.js\"></script>\n  </body>\n</html>\n```\n\n`open index.html` and check it out!\n\n## Conclusion\n\nAnd so using ports with Elm really isn't that difficult. Now we can code a bunch of JS for the part that needs to integrate to whatever else we have (like legacy code, other JS libs, whatnot) and still have the guarantee of the Elm side of our application!![Screen Shot 2015-09-24 at 12.29.39 AM.png](https://qiita-image-store.s3.amazonaws.com/0/42481/6d495e48-60e2-4a1d-facd-9b56067e1724.png \"Screen Shot 2015-09-24 at 12.29.39 AM.png\")\n\nSee the repository here: https://github.com/justinwoo/elm-simple-ports-example\nDemo here: http://justinwoo.github.io/elm-simple-ports-example\n\n## References\n\n* Interop - Ports: http://elm-lang.org/guide/interop#ports\n* Elm.Core.Signal - http://package.elm-lang.org/packages/elm-lang/core/2.1.0/Signal\n"}