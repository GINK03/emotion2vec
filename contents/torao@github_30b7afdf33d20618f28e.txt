{"context": "Netty 4 \u306e WebSocket \u30e9\u30a4\u30d6\u30e9\u30ea\u3092\u4f7f\u3063\u305f Scala \u5b9f\u88c5\u30b5\u30f3\u30d7\u30eb\u3002Java/Scala \u3067\u306e WebSocket \u30af\u30e9\u30a4\u30a2\u30f3\u30c8\u5b9f\u88c5\u3063\u3066\u30b5\u30fc\u30d0\u5074\u3068\u6bd4\u3079\u3066\u60c5\u5831\u304c\u5c11\u306a\u3044\u3067\u3059\u306d\u3002Netty \u516c\u5f0f\u306e WebSocket \u5b9f\u88c5\u4f8b \u3092 Scala \u3067\u66f8\u304d\u76f4\u3057\u305f\u30d0\u30fc\u30b8\u30e7\u30f3\u3067\u3059\u3002\nNetty \u306f\u30a4\u30d9\u30f3\u30c8\u30eb\u30fc\u30d7\u306e\u30b9\u30ec\u30c3\u30c9\u3084\u30c7\u30fc\u30bf\u5909\u63db\u306e\u30d1\u30a4\u30d7\u30e9\u30a4\u30f3\u5316\u306a\u3069\u4f4e\u30ec\u30d9\u30eb\u306a\u64cd\u4f5c\u3092\u30d7\u30ed\u30b0\u30e9\u30de\u81ea\u8eab\u304c\u884c\u3048\u3066\u6c17\u306b\u5165\u3063\u3066\u3044\u308b\u3093\u3067\u3059\u304c\u305d\u306e\u5206\u30b3\u30fc\u30c9\u91cf\u304c\u591a\u304f\u306a\u3063\u3066\u6ce5\u81ed\u3044\u3067\u3059\u306d\u3002\u6bce\u5ea6 ChannelHandler \u3042\u305f\u308a\u306f\u30b4\u30ea\u30b4\u30ea\u5b9f\u88c5\u3057\u3066\u3044\u307e\u3059\u3002\n\nbuild.sbt\norganization := \"org.koiroha\"\n\nname := \"websocket-client\"\n\nversion := \"1.0.0-SNAPSHOT\"\n\nscalaVersion := \"2.11.7\"\n\nscalacOptions ++= Seq(\"-deprecation\",\"-feature\",\"-unchecked\",\"-Xlint\",\"-Ywarn-dead-code\",\"-Ywarn-numeric-widen\",\"-Ywarn-unused\",\"-Ywarn-unused-import\")\n\nlibraryDependencies ++= Seq(\n  \"io.netty\" % \"netty-all\" % \"4.1.4.Final\"\n)\n\n\n\nWebSocketClient.scala\n// WebSocket Client Example for Scala 2.11 with Netty 4\n// http://netty.io/4.0/xref/io/netty/example/http/websocketx/client/WebSocketClient.html\npackage org.koiroha.websocket\n\nimport io.netty.bootstrap.Bootstrap\nimport io.netty.buffer.Unpooled\nimport io.netty.channel.{Channel,ChannelFuture,ChannelHandlerContext,ChannelInitializer,ChannelPipeline,ChannelPromise,EventLoopGroup,SimpleChannelInboundHandler}\nimport io.netty.channel.nio.NioEventLoopGroup\nimport io.netty.channel.socket.SocketChannel\nimport io.netty.channel.socket.nio.NioSocketChannel\nimport io.netty.handler.codec.http.{DefaultHttpHeaders,FullHttpResponse,HttpClientCodec,HttpObjectAggregator}\nimport io.netty.handler.codec.http.websocketx.{CloseWebSocketFrame,PingWebSocketFrame,PongWebSocketFrame,TextWebSocketFrame,WebSocketClientHandshaker,WebSocketClientHandshakerFactory,WebSocketFrame,WebSocketVersion}\nimport io.netty.handler.ssl.{SslContext,SslContextBuilder}\nimport io.netty.handler.ssl.util.{InsecureTrustManagerFactory,SelfSignedCertificate}\nimport io.netty.util.CharsetUtil\n\nimport java.io.{BufferedReader,InputStreamReader}\nimport java.net.URI\n\nimport scala.annotation.tailrec\n\nobject WebSocketClient extends App {\n  val WSURL = if(args.length == 0) \"ws://echo.websocket.org\" else args(0)\n\n  val uri = new URI(WSURL)\n  val scheme = Option(uri.getScheme).getOrElse(\"ws\").toLowerCase\n  val host = Option(uri.getHost).getOrElse(\"127.0.0.1\")\n  val port = if(uri.getPort < 0){\n    scheme match {\n      case \"ws\" => 80\n      case \"wss\" => 443\n      case _ => -1\n    }\n  } else uri.getPort\n\n  if(scheme != \"ws\" && scheme != \"wss\"){\n    System.err.println(s\"ERROR: unsupported schema: $scheme\")\n    System.exit(1)\n  }\n\n  val secure = scheme == \"wss\"\n  val sslContext = if(secure){\n    Some(SslContextBuilder.forClient().trustManager(InsecureTrustManagerFactory.INSTANCE).build())\n  } else None\n\n  val group = new NioEventLoopGroup()\n  try {\n    val handler = new WebSocketClientHandler(WebSocketClientHandshakerFactory.newHandshaker(uri, WebSocketVersion.V13, null, false, new DefaultHttpHeaders()))\n    val bootstrap = new Bootstrap()\n    bootstrap.group(group)\n      .channel(classOf[NioSocketChannel])\n      .handler(new ChannelInitializer[SocketChannel](){\n        override def initChannel(ch:SocketChannel){\n          val pipeline = ch.pipeline()\n          sslContext.foreach{ s => pipeline.addLast(s.newHandler(ch.alloc(), host, port)) }\n          pipeline.addLast(new HttpClientCodec(), new HttpObjectAggregator(8192), handler)\n        }\n      })\n\n      val ch = bootstrap.connect(uri.getHost, port).sync().channel()\n      handler.handshakeFuture.sync()\n\n      val in = new BufferedReader(new InputStreamReader(System.in))\n      @tailrec\n      def _loop():Unit = {\n        in.readLine() match {\n          case null => ()\n          case \"quit\" =>\n            ch.writeAndFlush(new CloseWebSocketFrame())\n            ch.closeFuture().sync()\n          case \"ping\" =>\n            ch.writeAndFlush(new PingWebSocketFrame(Unpooled.wrappedBuffer(Array[Byte](8,1,8,1))))\n            _loop()\n          case msg =>\n            ch.writeAndFlush(new TextWebSocketFrame(msg))\n            _loop()\n        }\n      }\n      _loop()\n  } finally {\n    group.shutdownGracefully()\n  }\n\n}\n\nprivate class WebSocketClientHandler(handshaker:WebSocketClientHandshaker) extends SimpleChannelInboundHandler[AnyRef] {\n  var handshakeFuture:ChannelPromise = _\n  override def handlerAdded(ctx:ChannelHandlerContext):Unit = handshakeFuture = ctx.newPromise()\n  override def channelActive(ctx:ChannelHandlerContext):Unit = handshaker.handshake(ctx.channel())\n  override def channelInactive(ctx:ChannelHandlerContext):Unit = System.out.println(\"WebSocket Client Disconnected\")\n  override def channelRead0(ctx:ChannelHandlerContext, msg:AnyRef):Unit = {\n    val ch = ctx.channel()\n    if(! handshaker.isHandshakeComplete){\n      handshaker.finishHandshake(ch, msg.asInstanceOf[FullHttpResponse])\n      System.out.println(\"WebSocket Client Connected\")\n      handshakeFuture.setSuccess()\n    } else msg match {\n      case res:FullHttpResponse =>\n        throw new IllegalStateException(s\"ERROR: Unexpected FullHttpResponse (status=${res.status.code}, content=${res.content().toString(CharsetUtil.UTF_8)})\")\n      case text:TextWebSocketFrame =>\n        System.out.println(s\"<< ${text.text()}\")\n      case pong:PongWebSocketFrame =>\n        System.out.println(\"!! PONG\")\n      case ping:PingWebSocketFrame =>\n        System.out.println(\"!! PING\")\n        ch.writeAndFlush(new PongWebSocketFrame(Unpooled.wrappedBuffer(Array[Byte](8,1,8,1))))\n      case close:CloseWebSocketFrame =>\n        System.out.println(\"WebSocket Client Received Closing\")\n        ch.close()\n    }\n  }\n  override def exceptionCaught(ctx:ChannelHandlerContext, cause:Throwable):Unit = {\n    cause.printStackTrace()\n    if(! handshakeFuture.isDone()){\n      handshakeFuture.setFailure(cause)\n    }\n    ctx.close()\n  }\n}\n\n\nNetty 4 \u306e WebSocket \u30e9\u30a4\u30d6\u30e9\u30ea\u3092\u4f7f\u3063\u305f Scala \u5b9f\u88c5\u30b5\u30f3\u30d7\u30eb\u3002Java/Scala \u3067\u306e WebSocket \u30af\u30e9\u30a4\u30a2\u30f3\u30c8\u5b9f\u88c5\u3063\u3066\u30b5\u30fc\u30d0\u5074\u3068\u6bd4\u3079\u3066\u60c5\u5831\u304c\u5c11\u306a\u3044\u3067\u3059\u306d\u3002[Netty \u516c\u5f0f\u306e WebSocket \u5b9f\u88c5\u4f8b](http://netty.io/4.0/xref/io/netty/example/http/websocketx/client/WebSocketClient.html) \u3092 Scala \u3067\u66f8\u304d\u76f4\u3057\u305f\u30d0\u30fc\u30b8\u30e7\u30f3\u3067\u3059\u3002\n\nNetty \u306f\u30a4\u30d9\u30f3\u30c8\u30eb\u30fc\u30d7\u306e\u30b9\u30ec\u30c3\u30c9\u3084\u30c7\u30fc\u30bf\u5909\u63db\u306e\u30d1\u30a4\u30d7\u30e9\u30a4\u30f3\u5316\u306a\u3069\u4f4e\u30ec\u30d9\u30eb\u306a\u64cd\u4f5c\u3092\u30d7\u30ed\u30b0\u30e9\u30de\u81ea\u8eab\u304c\u884c\u3048\u3066\u6c17\u306b\u5165\u3063\u3066\u3044\u308b\u3093\u3067\u3059\u304c\u305d\u306e\u5206\u30b3\u30fc\u30c9\u91cf\u304c\u591a\u304f\u306a\u3063\u3066\u6ce5\u81ed\u3044\u3067\u3059\u306d\u3002\u6bce\u5ea6 `ChannelHandler` \u3042\u305f\u308a\u306f\u30b4\u30ea\u30b4\u30ea\u5b9f\u88c5\u3057\u3066\u3044\u307e\u3059\u3002\n\n```build.sbt\norganization := \"org.koiroha\"\n\nname := \"websocket-client\"\n\nversion := \"1.0.0-SNAPSHOT\"\n\nscalaVersion := \"2.11.7\"\n\nscalacOptions ++= Seq(\"-deprecation\",\"-feature\",\"-unchecked\",\"-Xlint\",\"-Ywarn-dead-code\",\"-Ywarn-numeric-widen\",\"-Ywarn-unused\",\"-Ywarn-unused-import\")\n\nlibraryDependencies ++= Seq(\n  \"io.netty\" % \"netty-all\" % \"4.1.4.Final\"\n)\n```\n\n```WebSocketClient.scala\n// WebSocket Client Example for Scala 2.11 with Netty 4\n// http://netty.io/4.0/xref/io/netty/example/http/websocketx/client/WebSocketClient.html\npackage org.koiroha.websocket\n\nimport io.netty.bootstrap.Bootstrap\nimport io.netty.buffer.Unpooled\nimport io.netty.channel.{Channel,ChannelFuture,ChannelHandlerContext,ChannelInitializer,ChannelPipeline,ChannelPromise,EventLoopGroup,SimpleChannelInboundHandler}\nimport io.netty.channel.nio.NioEventLoopGroup\nimport io.netty.channel.socket.SocketChannel\nimport io.netty.channel.socket.nio.NioSocketChannel\nimport io.netty.handler.codec.http.{DefaultHttpHeaders,FullHttpResponse,HttpClientCodec,HttpObjectAggregator}\nimport io.netty.handler.codec.http.websocketx.{CloseWebSocketFrame,PingWebSocketFrame,PongWebSocketFrame,TextWebSocketFrame,WebSocketClientHandshaker,WebSocketClientHandshakerFactory,WebSocketFrame,WebSocketVersion}\nimport io.netty.handler.ssl.{SslContext,SslContextBuilder}\nimport io.netty.handler.ssl.util.{InsecureTrustManagerFactory,SelfSignedCertificate}\nimport io.netty.util.CharsetUtil\n\nimport java.io.{BufferedReader,InputStreamReader}\nimport java.net.URI\n\nimport scala.annotation.tailrec\n\nobject WebSocketClient extends App {\n  val WSURL = if(args.length == 0) \"ws://echo.websocket.org\" else args(0)\n\n  val uri = new URI(WSURL)\n  val scheme = Option(uri.getScheme).getOrElse(\"ws\").toLowerCase\n  val host = Option(uri.getHost).getOrElse(\"127.0.0.1\")\n  val port = if(uri.getPort < 0){\n    scheme match {\n      case \"ws\" => 80\n      case \"wss\" => 443\n      case _ => -1\n    }\n  } else uri.getPort\n\n  if(scheme != \"ws\" && scheme != \"wss\"){\n    System.err.println(s\"ERROR: unsupported schema: $scheme\")\n    System.exit(1)\n  }\n\n  val secure = scheme == \"wss\"\n  val sslContext = if(secure){\n    Some(SslContextBuilder.forClient().trustManager(InsecureTrustManagerFactory.INSTANCE).build())\n  } else None\n\n  val group = new NioEventLoopGroup()\n  try {\n    val handler = new WebSocketClientHandler(WebSocketClientHandshakerFactory.newHandshaker(uri, WebSocketVersion.V13, null, false, new DefaultHttpHeaders()))\n    val bootstrap = new Bootstrap()\n    bootstrap.group(group)\n      .channel(classOf[NioSocketChannel])\n      .handler(new ChannelInitializer[SocketChannel](){\n        override def initChannel(ch:SocketChannel){\n          val pipeline = ch.pipeline()\n          sslContext.foreach{ s => pipeline.addLast(s.newHandler(ch.alloc(), host, port)) }\n          pipeline.addLast(new HttpClientCodec(), new HttpObjectAggregator(8192), handler)\n        }\n      })\n\n      val ch = bootstrap.connect(uri.getHost, port).sync().channel()\n      handler.handshakeFuture.sync()\n\n      val in = new BufferedReader(new InputStreamReader(System.in))\n      @tailrec\n      def _loop():Unit = {\n        in.readLine() match {\n          case null => ()\n          case \"quit\" =>\n            ch.writeAndFlush(new CloseWebSocketFrame())\n            ch.closeFuture().sync()\n          case \"ping\" =>\n            ch.writeAndFlush(new PingWebSocketFrame(Unpooled.wrappedBuffer(Array[Byte](8,1,8,1))))\n            _loop()\n          case msg =>\n            ch.writeAndFlush(new TextWebSocketFrame(msg))\n            _loop()\n        }\n      }\n      _loop()\n  } finally {\n    group.shutdownGracefully()\n  }\n\n}\n\nprivate class WebSocketClientHandler(handshaker:WebSocketClientHandshaker) extends SimpleChannelInboundHandler[AnyRef] {\n  var handshakeFuture:ChannelPromise = _\n  override def handlerAdded(ctx:ChannelHandlerContext):Unit = handshakeFuture = ctx.newPromise()\n  override def channelActive(ctx:ChannelHandlerContext):Unit = handshaker.handshake(ctx.channel())\n  override def channelInactive(ctx:ChannelHandlerContext):Unit = System.out.println(\"WebSocket Client Disconnected\")\n  override def channelRead0(ctx:ChannelHandlerContext, msg:AnyRef):Unit = {\n    val ch = ctx.channel()\n    if(! handshaker.isHandshakeComplete){\n      handshaker.finishHandshake(ch, msg.asInstanceOf[FullHttpResponse])\n      System.out.println(\"WebSocket Client Connected\")\n      handshakeFuture.setSuccess()\n    } else msg match {\n      case res:FullHttpResponse =>\n        throw new IllegalStateException(s\"ERROR: Unexpected FullHttpResponse (status=${res.status.code}, content=${res.content().toString(CharsetUtil.UTF_8)})\")\n      case text:TextWebSocketFrame =>\n        System.out.println(s\"<< ${text.text()}\")\n      case pong:PongWebSocketFrame =>\n        System.out.println(\"!! PONG\")\n      case ping:PingWebSocketFrame =>\n        System.out.println(\"!! PING\")\n        ch.writeAndFlush(new PongWebSocketFrame(Unpooled.wrappedBuffer(Array[Byte](8,1,8,1))))\n      case close:CloseWebSocketFrame =>\n        System.out.println(\"WebSocket Client Received Closing\")\n        ch.close()\n    }\n  }\n  override def exceptionCaught(ctx:ChannelHandlerContext, cause:Throwable):Unit = {\n    cause.printStackTrace()\n    if(! handshakeFuture.isDone()){\n      handshakeFuture.setFailure(cause)\n    }\n    ctx.close()\n  }\n}\n```\n", "tags": ["Scala", "websocket", "Netty"]}