{"tags": ["Siv3DMay2014"], "context": " More than 1 year has passed since last update.\u305d\u308c\u3063\u307d\u3044\u6a5f\u80fd\n* \u30aa\u30fc\u30d7\u30cb\u30f3\u30b0\u753b\u9762\uff0c\u30b2\u30fc\u30e0\u753b\u9762\uff0c\u7d42\u4e86\u753b\u9762\uff0c\u7d50\u679c\u753b\u9762\u306b\u9077\u79fb\u3059\u308b\n* \u30cf\u30a4\u30b9\u30b3\u30a2\u30e9\u30f3\u30ad\u30f3\u30b0\u306e\u8868\u793a\n* 150\u884c\u4ee5\u5185\n* http://play-siv3d.hateblo.jp/ \u306e\u66f8\u5f0f\u306b\u6975\u529b\u63c3\u3048\u308b\n* \u30d3\u30b8\u30e5\u30a2\u30eb\u7684\u306b\u9762\u767d\u304f\n\u7121\u7406\u3084\u308a\u8a70\u3081\u8fbc\u3093\u3060\uff0c\u76f8\u5909\u308f\u3089\u305a\u8b0e\u3067\u3042\u308b\n\n\n\n\nMain.cpp\n# include <Siv3D.hpp>\n\nvoid Main()\n{\n    enum class GameState\n    {\n        Opening, Game, Finish, Result\n    };\n\n    Graphics::SetBackground(Palette::Black);\n    Window::SetTitle(L\"\u5341\u5b57\u30ad\u30fc\u3067\u64cd\u4f5c\");\n    GameState gameState = GameState::Opening;\n    GameState tGameState = gameState;\n    TimerMillisec timer;\n    Font font(20);\n    timer.start();  \n\n    const double windowWidth = Window::Width();\n    const double windowHeight = Window::Height();   \n    const double playerHeight = 0.05;\n    const double playerPosY = 0.1;\n    const double playerSpeed = 0.01;\n    const double gravity = 0.001;\n    const Color col = ColorF(0.0, 1.0, 0.0);\n\n    double playerPosX;\n    double playerWidth;\n    Vec2 ballPos;\n    Vec2 ballVelocity;\n    String scoreString;\n    unsigned score;\n    std::array<unsigned int, 9> scores;\n    scores.fill(0);\n\n    std::function<void()> initGame = [&]()\n    {\n        playerPosX = 0.5;\n        playerWidth = 0.1;\n        ballPos = Vec2(0.5, 0.8);\n        ballVelocity = RandomVec2({-0.001, 0.001}, {-0.001, 0.001});\n        scoreString.clear();\n        score = 0;\n    };\n\n    std::function<void()> setScore = [&]()\n    {\n        score = timer.elapsed();\n        auto minScore = std::min_element(scores.begin(), scores.end());\n\n        if (*minScore < score)\n        {\n            *minScore = score;\n            std::sort(scores.begin(), scores.end(), [&](unsigned int a, unsigned int b){return a > b; });\n        }           \n\n        for (auto it = scores.begin(); it < scores.end(); ++it)\n        {\n            scoreString += Format(it - scores.begin() + 1, L\": \");\n            scoreString += (*it == score) ? Format(L\"***\", score, L\"***\\n\") : Format(*it, L'\\n');\n        }\n    };\n\n    std::function<Vec2(const Vec2&)> getPos = [&](const Vec2& pos){return Vec2(windowWidth * pos.x, (1.0 - pos.y) * windowHeight);};\n\n    std::function<void()> updatePos = [&]()\n    {\n        ballVelocity.x = (ballPos.x < 0.0 || ballPos.x > 1.0) ? -ballVelocity.x : ballVelocity.x;\n        ballVelocity.y -= gravity;\n        ballPos += ballVelocity;\n        playerPosX += playerSpeed * (Input::KeyRight.pressed - Input::KeyLeft.pressed);\n        playerPosX = Clamp(playerPosX, 0.0, 1.0);\n    };\n\n    std::function<void()> drawBallAndPlayer = [&]()\n    {\n        RectF(windowWidth * playerWidth, windowHeight * playerHeight).setCenter(getPos({ playerPosX, playerPosY })).draw(col);\n        for (int i = -3; i < 4; ++i)\n            Circle(getPos(ballPos + static_cast<double>(i) / 3.0 * ballVelocity), 10.0).draw(col);\n    };\n\n    vector<std::function<void()>> functions = \n    {\n        [&]()\n        {\n            font(L\"\u30dc\u30fc\u30eb\u3092\u843d\u3068\u3055\u306a\u3044\u3088\u3046\u306b\u3059\u308b\u30b2\u30fc\u30e0\\n\u30ad\u30fc\u62bc\u3059\u3068\u30b2\u30fc\u30e0\u958b\u59cb\").drawCenter(Window::Center(), col);\n\n            if (Input::AnyKeyClicked())\n            {\n                initGame();\n                gameState = GameState::Game;\n            }\n        }, [&]()\n        {\n            font(timer.elapsed()).draw({ 0.0, 0.0 }, col);\n\n            if (RectF(playerWidth, playerHeight).setCenter(playerPosX, playerPosY).intersects(ballPos))\n            {\n                playerWidth *= 0.9;\n                ballVelocity = Vec2(0.03 * (ballPos.x - playerPosX) / playerWidth, -ballVelocity.y);\n                ballPos.y = playerPosY + playerHeight / 2.0;\n            }\n\n            updatePos();\n\n            drawBallAndPlayer();\n\n            if (ballPos.y < 0.0)\n            {\n                setScore();\n                gameState = GameState::Finish;\n            }\n        }, [&]()\n        {\n            font(L\"FINISH!!\\nscore : \", score).drawCenter(Window::Center(), col);\n\n            updatePos();\n\n            if (ballPos.y < 0.0)\n            {\n                ballPos.y = 0.0;\n                ballVelocity.x = 0.5 * ballVelocity.x;\n                ballVelocity.y = -0.5 * ballVelocity.y;\n            }\n\n            drawBallAndPlayer();\n\n            if (timer.elapsed() > 3000)\n                gameState = GameState::Result;\n        }, [&]()\n        {\n            font(scoreString).drawCenter(Window::Center(), col);\n\n            if (Input::AnyKeyClicked())\n                gameState = GameState::Opening;\n        }\n    };\n\n    while (System::Update())\n    {\n        functions[static_cast<int>(gameState)]();\n\n        if (tGameState != gameState)\n        {\n            timer.restart();\n\n            tGameState = gameState;\n        }\n    }\n}\n\n\n\u305d\u308c\u3063\u307d\u3044\u6a5f\u80fd\n* \u30aa\u30fc\u30d7\u30cb\u30f3\u30b0\u753b\u9762\uff0c\u30b2\u30fc\u30e0\u753b\u9762\uff0c\u7d42\u4e86\u753b\u9762\uff0c\u7d50\u679c\u753b\u9762\u306b\u9077\u79fb\u3059\u308b\n* \u30cf\u30a4\u30b9\u30b3\u30a2\u30e9\u30f3\u30ad\u30f3\u30b0\u306e\u8868\u793a\n* 150\u884c\u4ee5\u5185\n* http://play-siv3d.hateblo.jp/ \u306e\u66f8\u5f0f\u306b\u6975\u529b\u63c3\u3048\u308b\n* \u30d3\u30b8\u30e5\u30a2\u30eb\u7684\u306b\u9762\u767d\u304f\n\n\u7121\u7406\u3084\u308a\u8a70\u3081\u8fbc\u3093\u3060\uff0c\u76f8\u5909\u308f\u3089\u305a\u8b0e\u3067\u3042\u308b\n\n![soreppoi.png](https://qiita-image-store.s3.amazonaws.com/0/34295/a9a9d8d3-b8b5-f714-6899-0de520519a4a.png)\n\n![finish.png](https://qiita-image-store.s3.amazonaws.com/0/34295/0a5fea8d-2b17-6e56-b8eb-9464e8da9b49.png)\n\n![ranking.png](https://qiita-image-store.s3.amazonaws.com/0/34295/0436c169-f723-f32b-1188-d853618e9820.png)\n\n\n```cpp:Main.cpp\n# include <Siv3D.hpp>\n\nvoid Main()\n{\n\tenum class GameState\n\t{\n\t\tOpening, Game, Finish, Result\n\t};\n\n\tGraphics::SetBackground(Palette::Black);\n\tWindow::SetTitle(L\"\u5341\u5b57\u30ad\u30fc\u3067\u64cd\u4f5c\");\n\tGameState gameState = GameState::Opening;\n\tGameState tGameState = gameState;\n\tTimerMillisec timer;\n\tFont font(20);\n\ttimer.start();\t\n\n\tconst double windowWidth = Window::Width();\n\tconst double windowHeight = Window::Height();\t\n\tconst double playerHeight = 0.05;\n\tconst double playerPosY = 0.1;\n\tconst double playerSpeed = 0.01;\n\tconst double gravity = 0.001;\n\tconst Color col = ColorF(0.0, 1.0, 0.0);\n\t\n\tdouble playerPosX;\n\tdouble playerWidth;\n\tVec2 ballPos;\n\tVec2 ballVelocity;\n\tString scoreString;\n\tunsigned score;\n\tstd::array<unsigned int, 9> scores;\n\tscores.fill(0);\n\n\tstd::function<void()> initGame = [&]()\n\t{\n\t\tplayerPosX = 0.5;\n\t\tplayerWidth = 0.1;\n\t\tballPos = Vec2(0.5, 0.8);\n\t\tballVelocity = RandomVec2({-0.001, 0.001}, {-0.001, 0.001});\n\t\tscoreString.clear();\n\t\tscore = 0;\n\t};\n\n\tstd::function<void()> setScore = [&]()\n\t{\n\t\tscore = timer.elapsed();\n\t\tauto minScore = std::min_element(scores.begin(), scores.end());\n\n\t\tif (*minScore < score)\n\t\t{\n\t\t\t*minScore = score;\n\t\t\tstd::sort(scores.begin(), scores.end(), [&](unsigned int a, unsigned int b){return a > b; });\n\t\t}\t\t\t\n\n\t\tfor (auto it = scores.begin(); it < scores.end(); ++it)\n\t\t{\n\t\t\tscoreString += Format(it - scores.begin() + 1, L\": \");\n\t\t\tscoreString += (*it == score) ? Format(L\"***\", score, L\"***\\n\") : Format(*it, L'\\n');\n\t\t}\n\t};\n\n\tstd::function<Vec2(const Vec2&)> getPos = [&](const Vec2& pos){return Vec2(windowWidth * pos.x, (1.0 - pos.y) * windowHeight);};\n\n\tstd::function<void()> updatePos = [&]()\n\t{\n\t\tballVelocity.x = (ballPos.x < 0.0 || ballPos.x > 1.0) ? -ballVelocity.x : ballVelocity.x;\n\t\tballVelocity.y -= gravity;\n\t\tballPos += ballVelocity;\n\t\tplayerPosX += playerSpeed * (Input::KeyRight.pressed - Input::KeyLeft.pressed);\n\t\tplayerPosX = Clamp(playerPosX, 0.0, 1.0);\n\t};\n\n\tstd::function<void()> drawBallAndPlayer = [&]()\n\t{\n\t\tRectF(windowWidth * playerWidth, windowHeight * playerHeight).setCenter(getPos({ playerPosX, playerPosY })).draw(col);\n\t\tfor (int i = -3; i < 4; ++i)\n\t\t\tCircle(getPos(ballPos + static_cast<double>(i) / 3.0 * ballVelocity), 10.0).draw(col);\n\t};\n\n\tvector<std::function<void()>> functions = \n\t{\n\t\t[&]()\n\t\t{\n\t\t\tfont(L\"\u30dc\u30fc\u30eb\u3092\u843d\u3068\u3055\u306a\u3044\u3088\u3046\u306b\u3059\u308b\u30b2\u30fc\u30e0\\n\u30ad\u30fc\u62bc\u3059\u3068\u30b2\u30fc\u30e0\u958b\u59cb\").drawCenter(Window::Center(), col);\n\n\t\t\tif (Input::AnyKeyClicked())\n\t\t\t{\n\t\t\t\tinitGame();\n\t\t\t\tgameState = GameState::Game;\n\t\t\t}\n\t\t}, [&]()\n\t\t{\n\t\t\tfont(timer.elapsed()).draw({ 0.0, 0.0 }, col);\n\n\t\t\tif (RectF(playerWidth, playerHeight).setCenter(playerPosX, playerPosY).intersects(ballPos))\n\t\t\t{\n\t\t\t\tplayerWidth *= 0.9;\n\t\t\t\tballVelocity = Vec2(0.03 * (ballPos.x - playerPosX) / playerWidth, -ballVelocity.y);\n\t\t\t\tballPos.y = playerPosY + playerHeight / 2.0;\n\t\t\t}\n\n\t\t\tupdatePos();\n\n\t\t\tdrawBallAndPlayer();\n\n\t\t\tif (ballPos.y < 0.0)\n\t\t\t{\n\t\t\t\tsetScore();\n\t\t\t\tgameState = GameState::Finish;\n\t\t\t}\n\t\t}, [&]()\n\t\t{\n\t\t\tfont(L\"FINISH!!\\nscore : \", score).drawCenter(Window::Center(), col);\n\n\t\t\tupdatePos();\n\n\t\t\tif (ballPos.y < 0.0)\n\t\t\t{\n\t\t\t\tballPos.y = 0.0;\n\t\t\t\tballVelocity.x = 0.5 * ballVelocity.x;\n\t\t\t\tballVelocity.y = -0.5 * ballVelocity.y;\n\t\t\t}\n\t\t\t\t\n\t\t\tdrawBallAndPlayer();\n\n\t\t\tif (timer.elapsed() > 3000)\n\t\t\t\tgameState = GameState::Result;\n\t\t}, [&]()\n\t\t{\n\t\t\tfont(scoreString).drawCenter(Window::Center(), col);\n\n\t\t\tif (Input::AnyKeyClicked())\n\t\t\t\tgameState = GameState::Opening;\n\t\t}\n\t};\n\n\twhile (System::Update())\n\t{\n\t\tfunctions[static_cast<int>(gameState)]();\n\n\t\tif (tGameState != gameState)\n\t\t{\n\t\t\ttimer.restart();\n\n\t\t\ttGameState = gameState;\n\t\t}\n\t}\n}\n```\n"}