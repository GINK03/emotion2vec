{"context": " More than 1 year has passed since last update.macro ask-for (thing default &key in)\nmacro in-reply-to ((thing &key in)*) &body body\n;; this is a basic usage of `ask-for'.\n(defun fn1 (&optional (arg (ask-for arg 1 :in fn1)))\n  (print arg))\n(defun fn2 ()\n  (loop for i from 0 to 10 do (fn1)))\n(defun fn3 ()\n  (let ((lst (list :a :b :c)))\n    (setf (cdddr lst) lst)\n    (handler-bind ((ask-value\n                    (lambda (c)\n                      (when (and (eq 'arg (asked-name c))\n                                 (eq 'fn1 (asked-by c)))\n                        (use-value (pop lst) c)))))\n      (fn2))))\n\n\n;; Using `ask-for' is better than using a special variable.\n;; See the following example,\n;; the generator and iterator of *queue* is in the different position\n(defvar *queue*)\n(defun fn-special1 ()\n  (print (pop *queue*)))\n(defun fn-special2 ()\n  (loop for i from 0 to 10 do (fn-special1)))\n(defun fn-special3 ()\n  (let ((*queue* (list :a :b :c)))\n    (setf (cdddr *queue*) *queue*)\n    (fn-special2)))\n\n\n;; how about implementing with thunk and continuation?\n(defvar *cont*)\n(defun fn-cont1 ()\n  (print (funcall *cont*)))\n(defun fn-cont2 ()\n  ;; In this case, someone may change the definition of `*cont*'.\n  ;; This is unsafe in terms of debuggability.\n  ;; The effect continues until the let binding is\n  ;; unwound. Actually, the behavior of fn-cont2-2 is affected by \n  ;; fn-cont2 here.  During the debugging, the timing of unwinding\n  ;; should be carefully considered.\n  (setf *cont* (lambda () 1))\n  (loop for i from 0 to 10 do (fn-cont1)))\n(defun fn-cont2-2 ()\n  (loop for i from 0 to 3 do (fn-cont1)))\n(defun fn-cont3 ()\n  (let ((queue (list :a :b :c))\n        (*cont* (lambda () (pop queue))))\n    (setf (cdddr *queue*) *queue*)\n    (fn-cont2-2)\n    (fn-cont2)\n    (fn-cont2-2)))\n\n;; by using restarts, we can restrict the communication stream between\n;; upper and lower stack. Restart bindings are safe because\n;; they cannot be modified -- it can only be wrapped around.\n\n;; Finally, this is an exteded usage with a macro `in-reply-to'.\n\n(defun fn3-in-reply-to ()\n  (let ((lst (list :a :b :c)))\n    (setf (cdddr lst) lst)\n    (in-reply-to\n        (((arg :in fn1) (pop lst))\n         ((arg2 :in fn1) 1)\n         (arg2 (pop lst)))\n      (fn2))))\n\nThis utility is a part of guicho-utilities, available at https://github.com/guicho271828/guicho-utilities .\n\n\n**macro** *ask-for* (thing default &key in)\n\n**macro** *in-reply-to* ((thing &key in)*) &body body\n\n``` cl\n;; this is a basic usage of `ask-for'.\n(defun fn1 (&optional (arg (ask-for arg 1 :in fn1)))\n  (print arg))\n(defun fn2 ()\n  (loop for i from 0 to 10 do (fn1)))\n(defun fn3 ()\n  (let ((lst (list :a :b :c)))\n    (setf (cdddr lst) lst)\n    (handler-bind ((ask-value\n                    (lambda (c)\n                      (when (and (eq 'arg (asked-name c))\n                                 (eq 'fn1 (asked-by c)))\n                        (use-value (pop lst) c)))))\n      (fn2))))\n\n\n;; Using `ask-for' is better than using a special variable.\n;; See the following example,\n;; the generator and iterator of *queue* is in the different position\n(defvar *queue*)\n(defun fn-special1 ()\n  (print (pop *queue*)))\n(defun fn-special2 ()\n  (loop for i from 0 to 10 do (fn-special1)))\n(defun fn-special3 ()\n  (let ((*queue* (list :a :b :c)))\n    (setf (cdddr *queue*) *queue*)\n    (fn-special2)))\n\n\n;; how about implementing with thunk and continuation?\n(defvar *cont*)\n(defun fn-cont1 ()\n  (print (funcall *cont*)))\n(defun fn-cont2 ()\n  ;; In this case, someone may change the definition of `*cont*'.\n  ;; This is unsafe in terms of debuggability.\n  ;; The effect continues until the let binding is\n  ;; unwound. Actually, the behavior of fn-cont2-2 is affected by \n  ;; fn-cont2 here.  During the debugging, the timing of unwinding\n  ;; should be carefully considered.\n  (setf *cont* (lambda () 1))\n  (loop for i from 0 to 10 do (fn-cont1)))\n(defun fn-cont2-2 ()\n  (loop for i from 0 to 3 do (fn-cont1)))\n(defun fn-cont3 ()\n  (let ((queue (list :a :b :c))\n        (*cont* (lambda () (pop queue))))\n    (setf (cdddr *queue*) *queue*)\n    (fn-cont2-2)\n    (fn-cont2)\n    (fn-cont2-2)))\n\n;; by using restarts, we can restrict the communication stream between\n;; upper and lower stack. Restart bindings are safe because\n;; they cannot be modified -- it can only be wrapped around.\n\n;; Finally, this is an exteded usage with a macro `in-reply-to'.\n\n(defun fn3-in-reply-to ()\n  (let ((lst (list :a :b :c)))\n    (setf (cdddr lst) lst)\n    (in-reply-to\n        (((arg :in fn1) (pop lst))\n         ((arg2 :in fn1) 1)\n         (arg2 (pop lst)))\n      (fn2))))\n```\n\nThis utility is a part of guicho-utilities, available at https://github.com/guicho271828/guicho-utilities .\n", "tags": ["common-lisp"]}