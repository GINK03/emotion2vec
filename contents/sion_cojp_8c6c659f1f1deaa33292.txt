{"tags": ["GetWild", "Go", "golang", "OpenAL"], "context": "Get Wild Advent Calendar 2016 \u306e\uff115\u65e5\u76ee\u3067\u3059\u3002\n\n\u6982\u8981\n\n\u6a5f\u6750\u306f\u306a\u3044\u3051\u3069\u3001\u3069\u3046\u3057\u3066\u3082GetWild\u3092\u5f3e\u304d\u305f\u3044\n\u30c9\u30ec\u30df\u30d5\u30a1\u304c\u9cf4\u3089\u305b\u308c\u3070\u3044\u3051\u308b\u2026\n\u2192 Go\u3067OpenAL\u3092\u4f7f\u3063\u3066\u5b9f\u88c5\u3057\u307e\u3057\u305f\n\u6642\u9593\u304c\u306a\u304b\u3063\u305f\u306e\u3067\u304b\u306a\u308a\u3084\u3063\u3064\u3051\u3067\u3059\n\n\n\u5b9f\u88c5\n\nhttps://github.com/sioncojp/play-getwild\n\n$ curl -O https://github.com/sioncojp/play-getwild/releases/download/1.0.0/play-getwild.tar.gz\n$ tar zxvf play-getwild.tar.gz\n$ ./play-getwild\n\n\n\u4e2d\u8eab\npackage main\n\nimport (\n    \"encoding/binary\"\n    \"fmt\"\n    \"log\"\n    \"math\"\n    \"sync\"\n    \"time\"\n\n    \"golang.org/x/mobile/exp/audio/al\"\n    \"golang.org/x/mobile/exp/f32\"\n)\n\nvar pctx *Context\nvar pianoPlayer *Piano\n\nconst (\n    Pi         = float32(math.Pi)\n    Fmt        = al.FormatStereo16\n    QUEUE      = 500\n    SampleRate = 10000 // \u97f3\u306e\u9ad8\u3055\u306e\u30d9\u30fc\u30b9\n)\n\ntype Oscillator func() float32\n\ntype Context struct {\n    sync.RWMutex\n    source     al.Source\n    queue      []al.Buffer\n    oscillator Oscillator\n}\n\ntype Piano struct {\n    notes      []bool\n    oscillator Oscillator\n}\n\nfunc G(gain float32, f Oscillator) Oscillator {\n    return func() float32 {\n        return gain * f()\n    }\n}\n\nfunc GenOscillator(freq float32) Oscillator {\n    dt := 1.0 / float32(SampleRate)\n    k := 2.0 * Pi * freq\n    T := 1.0 / freq\n    t := float32(0.0)\n    return func() float32 {\n        res := f32.Sin(k * t)\n        t += dt\n        if t > T {\n            t -= T\n        }\n        return res\n    }\n}\n\nfunc Multiplex(fs ...Oscillator) Oscillator {\n    return func() float32 {\n        res := float32(0)\n        for _, osc := range fs {\n            res += osc()\n        }\n        return res\n    }\n}\n\nfunc GenEnvelope(press *bool, f Oscillator) Oscillator {\n    dt := 1.0 / float32(SampleRate)\n    top := false\n    gain := float32(0.0)\n    attackd := dt / 0.01\n    dekeyd := dt / 0.03\n    sustainlevel := float32(0.3)\n    sustaind := dt / 7.0\n    released := dt / 0.8\n    return func() float32 {\n        if *press {\n            if !top {\n                gain += attackd\n                if gain > 1.0 {\n                    top = true\n                    gain = 1.0\n                }\n            } else {\n                if gain > sustainlevel {\n                    gain -= dekeyd\n                } else {\n                    gain -= sustaind\n                }\n                if gain < 0.0 {\n                    gain = 0.0\n                }\n            }\n        } else {\n            top = false\n            gain -= released\n            if gain < 0.0 {\n                gain = 0.0\n            }\n        }\n        return gain * f()\n    }\n}\n\nfunc NewContext(oscillator Oscillator) *Context {\n    if err := al.OpenDevice(); err != nil {\n        log.Fatal(err)\n    }\n    s := al.GenSources(1)\n    return &Context{\n        source:     s[0],\n        queue:      []al.Buffer{},\n        oscillator: oscillator,\n    }\n}\n\nfunc NewPiano(freqs []float32) *Piano {\n    p := new(Piano)\n    p.notes = make([]bool, len(freqs))\n    envelopes := []Oscillator{}\n    for i, f := range freqs {\n        base := []Oscillator{}\n        for j := float32(1.0); j <= 8; j++ {\n            base = append(base, G(0.5/j, GenOscillator(f*j)))\n        }\n        base = append(base, G(0.3, GenOscillator(f+2)))\n        osc := Multiplex(base...)\n        envelopes = append(envelopes, G(0.4, GenEnvelope(&p.notes[i], osc)))\n    }\n    p.oscillator = Multiplex(envelopes...)\n    return p\n}\nfunc (p *Piano) NoteOn(key int) {\n    p.notes[key] = true\n}\n\nfunc (p *Piano) NoteOff(key int) {\n    p.notes[key] = false\n}\n\nfunc (p *Piano) GetOscillator() Oscillator { return p.oscillator }\n\nfunc (c *Context) Play(q int) {\n    c.Lock()\n    defer c.Unlock()\n    n := c.source.BuffersProcessed()\n    if n > 0 {\n        rm := c.queue[:n]\n        c.queue = nil\n        c.source.UnqueueBuffers(rm...)\n        al.DeleteBuffers(rm...)\n    }\n    fmt.Println(len(c.queue))\n    for len(c.queue) < QUEUE {\n        b := al.GenBuffers(q) // \u97f3\u306e\u9577\u3055\n        buf := make([]byte, 2048)\n        for n := 0; n < 2048; n += 2 {\n            f := c.oscillator()\n            v := int16(float32(92767) * f) // \u97f3\u306e\u5927\u304d\u3055\n            binary.LittleEndian.PutUint16(buf[n:n+2], uint16(v))\n        }\n        b[0].BufferData(Fmt, buf, SampleRate)\n        c.source.QueueBuffers(b...)\n        c.queue = append(c.queue, b...)\n    }\n    al.PlaySources(c.source)\n}\n\nfunc (c *Context) Close() {\n    c.Lock()\n    defer c.Unlock()\n    al.StopSources(c.source)\n}\n\nfunc PlaySound(s, q int, slp time.Duration) {\n    pianoPlayer.NoteOn(s)\n    pctx.Play(q)\n    time.Sleep(slp * time.Millisecond)\n    pctx.Close()\n    pianoPlayer.NoteOff(s)\n}\n\nfunc main() {\n    pianoPlayer = NewPiano([]float32{\n        246.941650628,\n        261.625565301,\n        277.182630977,\n        293.664767917,\n        311.126983722,\n        329.627556913,\n        349.228231433,\n        369.994422712,\n        391.995435982,\n        415.30469758,\n        440.0,\n        466.163761518,\n        493.883301256,\n        523.251130601,\n    })\n\n    pctx = NewContext(pianoPlayer.GetOscillator())\n\n    PlaySound(6, 70, 500)\n    PlaySound(4, 70, 500)\n    PlaySound(2, 10, 1000)\n\n    time.Sleep(100 * time.Millisecond)\n\n    PlaySound(6, 100, 300)\n    PlaySound(4, 80, 500)\n    PlaySound(2, 80, 500)\n    PlaySound(2, 100, 300)\n    PlaySound(2, 10, 1000)\n\n    time.Sleep(200 * time.Millisecond)\n\n    PlaySound(2, 100, 300)\n    PlaySound(4, 150, 300)\n    PlaySound(6, 150, 300)\n    PlaySound(6, 150, 300)\n    PlaySound(6, 150, 300)\n    PlaySound(7, 150, 300)\n    PlaySound(6, 150, 300)\n    PlaySound(2, 150, 300)\n    PlaySound(2, 150, 300)\n    PlaySound(6, 150, 300)\n\n    time.Sleep(10 * time.Millisecond)\n\n    PlaySound(6, 80, 300)\n    PlaySound(4, 50, 600)\n    PlaySound(2, 200, 180)\n    PlaySound(2, 10, 1000)\n}\n\n\n\u611f\u60f3\n\n\uff11\u65e5\u3067\u3044\u3051\u308b\u304b\u306a\u3068\u601d\u3063\u305f\u3051\u3069\u304b\u306a\u308a\u96e3\u3057\u304b\u3063\u305fOpenAL\uff08\u3067\u3082\u697d\u3057\u304b\u3063\u305f\uff09\n\u6539\u826f\u70b9\u3042\u308a\u3059\u304e\u306a\u306e\u3067\u3001\u6642\u9593\u304c\u3042\u308c\u3070\u3061\u3083\u3093\u3068\u3057\u305f\u3082\u306e\u3092\u4f5c\u308a\u305f\u3044\u3067\u3059\u306d\npiano\u3068\u3044\u3046\u30d1\u30c3\u30b1\u30fc\u30b8\u306b\u3057\u3066\u8272\u3093\u306a\u3082\u306e\u3092\u6f14\u594f\u51fa\u6765\u308b\u3088\u3046\u306b\u3057\u305f\u3044\u306a\u3068\u601d\u3044\u307e\u3057\u305f\n\n\n\u53c2\u8003\n\nhttps://github.com/nobonobo/nobopiano\nhttps://godoc.org/golang.org/x/mobile/exp/audio/al\n\n[Get Wild Advent Calendar 2016](http://qiita.com/advent-calendar/2016/getwild) \u306e\uff115\u65e5\u76ee\u3067\u3059\u3002\n\n# \u6982\u8981\n* \u6a5f\u6750\u306f\u306a\u3044\u3051\u3069\u3001\u3069\u3046\u3057\u3066\u3082GetWild\u3092\u5f3e\u304d\u305f\u3044\n* \u30c9\u30ec\u30df\u30d5\u30a1\u304c\u9cf4\u3089\u305b\u308c\u3070\u3044\u3051\u308b\u2026\n* \u2192 Go\u3067OpenAL\u3092\u4f7f\u3063\u3066\u5b9f\u88c5\u3057\u307e\u3057\u305f\n* \u6642\u9593\u304c\u306a\u304b\u3063\u305f\u306e\u3067\u304b\u306a\u308a\u3084\u3063\u3064\u3051\u3067\u3059\n\n# \u5b9f\u88c5\n* https://github.com/sioncojp/play-getwild\n\n```bash\n$ curl -O https://github.com/sioncojp/play-getwild/releases/download/1.0.0/play-getwild.tar.gz\n$ tar zxvf play-getwild.tar.gz\n$ ./play-getwild\n```\n\n### \u4e2d\u8eab\n\n```go\npackage main\n\nimport (\n\t\"encoding/binary\"\n\t\"fmt\"\n\t\"log\"\n\t\"math\"\n\t\"sync\"\n\t\"time\"\n\n\t\"golang.org/x/mobile/exp/audio/al\"\n\t\"golang.org/x/mobile/exp/f32\"\n)\n\nvar pctx *Context\nvar pianoPlayer *Piano\n\nconst (\n\tPi         = float32(math.Pi)\n\tFmt        = al.FormatStereo16\n\tQUEUE      = 500\n\tSampleRate = 10000 // \u97f3\u306e\u9ad8\u3055\u306e\u30d9\u30fc\u30b9\n)\n\ntype Oscillator func() float32\n\ntype Context struct {\n\tsync.RWMutex\n\tsource     al.Source\n\tqueue      []al.Buffer\n\toscillator Oscillator\n}\n\ntype Piano struct {\n\tnotes      []bool\n\toscillator Oscillator\n}\n\nfunc G(gain float32, f Oscillator) Oscillator {\n\treturn func() float32 {\n\t\treturn gain * f()\n\t}\n}\n\nfunc GenOscillator(freq float32) Oscillator {\n\tdt := 1.0 / float32(SampleRate)\n\tk := 2.0 * Pi * freq\n\tT := 1.0 / freq\n\tt := float32(0.0)\n\treturn func() float32 {\n\t\tres := f32.Sin(k * t)\n\t\tt += dt\n\t\tif t > T {\n\t\t\tt -= T\n\t\t}\n\t\treturn res\n\t}\n}\n\nfunc Multiplex(fs ...Oscillator) Oscillator {\n\treturn func() float32 {\n\t\tres := float32(0)\n\t\tfor _, osc := range fs {\n\t\t\tres += osc()\n\t\t}\n\t\treturn res\n\t}\n}\n\nfunc GenEnvelope(press *bool, f Oscillator) Oscillator {\n\tdt := 1.0 / float32(SampleRate)\n\ttop := false\n\tgain := float32(0.0)\n\tattackd := dt / 0.01\n\tdekeyd := dt / 0.03\n\tsustainlevel := float32(0.3)\n\tsustaind := dt / 7.0\n\treleased := dt / 0.8\n\treturn func() float32 {\n\t\tif *press {\n\t\t\tif !top {\n\t\t\t\tgain += attackd\n\t\t\t\tif gain > 1.0 {\n\t\t\t\t\ttop = true\n\t\t\t\t\tgain = 1.0\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif gain > sustainlevel {\n\t\t\t\t\tgain -= dekeyd\n\t\t\t\t} else {\n\t\t\t\t\tgain -= sustaind\n\t\t\t\t}\n\t\t\t\tif gain < 0.0 {\n\t\t\t\t\tgain = 0.0\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\ttop = false\n\t\t\tgain -= released\n\t\t\tif gain < 0.0 {\n\t\t\t\tgain = 0.0\n\t\t\t}\n\t\t}\n\t\treturn gain * f()\n\t}\n}\n\nfunc NewContext(oscillator Oscillator) *Context {\n\tif err := al.OpenDevice(); err != nil {\n\t\tlog.Fatal(err)\n\t}\n\ts := al.GenSources(1)\n\treturn &Context{\n\t\tsource:     s[0],\n\t\tqueue:      []al.Buffer{},\n\t\toscillator: oscillator,\n\t}\n}\n\nfunc NewPiano(freqs []float32) *Piano {\n\tp := new(Piano)\n\tp.notes = make([]bool, len(freqs))\n\tenvelopes := []Oscillator{}\n\tfor i, f := range freqs {\n\t\tbase := []Oscillator{}\n\t\tfor j := float32(1.0); j <= 8; j++ {\n\t\t\tbase = append(base, G(0.5/j, GenOscillator(f*j)))\n\t\t}\n\t\tbase = append(base, G(0.3, GenOscillator(f+2)))\n\t\tosc := Multiplex(base...)\n\t\tenvelopes = append(envelopes, G(0.4, GenEnvelope(&p.notes[i], osc)))\n\t}\n\tp.oscillator = Multiplex(envelopes...)\n\treturn p\n}\nfunc (p *Piano) NoteOn(key int) {\n\tp.notes[key] = true\n}\n\nfunc (p *Piano) NoteOff(key int) {\n\tp.notes[key] = false\n}\n\nfunc (p *Piano) GetOscillator() Oscillator { return p.oscillator }\n\nfunc (c *Context) Play(q int) {\n\tc.Lock()\n\tdefer c.Unlock()\n\tn := c.source.BuffersProcessed()\n\tif n > 0 {\n\t\trm := c.queue[:n]\n\t\tc.queue = nil\n\t\tc.source.UnqueueBuffers(rm...)\n\t\tal.DeleteBuffers(rm...)\n\t}\n\tfmt.Println(len(c.queue))\n\tfor len(c.queue) < QUEUE {\n\t\tb := al.GenBuffers(q) // \u97f3\u306e\u9577\u3055\n\t\tbuf := make([]byte, 2048)\n\t\tfor n := 0; n < 2048; n += 2 {\n\t\t\tf := c.oscillator()\n\t\t\tv := int16(float32(92767) * f) // \u97f3\u306e\u5927\u304d\u3055\n\t\t\tbinary.LittleEndian.PutUint16(buf[n:n+2], uint16(v))\n\t\t}\n\t\tb[0].BufferData(Fmt, buf, SampleRate)\n\t\tc.source.QueueBuffers(b...)\n\t\tc.queue = append(c.queue, b...)\n\t}\n\tal.PlaySources(c.source)\n}\n\nfunc (c *Context) Close() {\n\tc.Lock()\n\tdefer c.Unlock()\n\tal.StopSources(c.source)\n}\n\nfunc PlaySound(s, q int, slp time.Duration) {\n\tpianoPlayer.NoteOn(s)\n\tpctx.Play(q)\n\ttime.Sleep(slp * time.Millisecond)\n\tpctx.Close()\n\tpianoPlayer.NoteOff(s)\n}\n\nfunc main() {\n\tpianoPlayer = NewPiano([]float32{\n\t\t246.941650628,\n\t\t261.625565301,\n\t\t277.182630977,\n\t\t293.664767917,\n\t\t311.126983722,\n\t\t329.627556913,\n\t\t349.228231433,\n\t\t369.994422712,\n\t\t391.995435982,\n\t\t415.30469758,\n\t\t440.0,\n\t\t466.163761518,\n\t\t493.883301256,\n\t\t523.251130601,\n\t})\n\n\tpctx = NewContext(pianoPlayer.GetOscillator())\n\n\tPlaySound(6, 70, 500)\n\tPlaySound(4, 70, 500)\n\tPlaySound(2, 10, 1000)\n\n\ttime.Sleep(100 * time.Millisecond)\n\n\tPlaySound(6, 100, 300)\n\tPlaySound(4, 80, 500)\n\tPlaySound(2, 80, 500)\n\tPlaySound(2, 100, 300)\n\tPlaySound(2, 10, 1000)\n\n\ttime.Sleep(200 * time.Millisecond)\n\n\tPlaySound(2, 100, 300)\n\tPlaySound(4, 150, 300)\n\tPlaySound(6, 150, 300)\n\tPlaySound(6, 150, 300)\n\tPlaySound(6, 150, 300)\n\tPlaySound(7, 150, 300)\n\tPlaySound(6, 150, 300)\n\tPlaySound(2, 150, 300)\n\tPlaySound(2, 150, 300)\n\tPlaySound(6, 150, 300)\n\n\ttime.Sleep(10 * time.Millisecond)\n\n\tPlaySound(6, 80, 300)\n\tPlaySound(4, 50, 600)\n\tPlaySound(2, 200, 180)\n\tPlaySound(2, 10, 1000)\n}\n```\n\n\n# \u611f\u60f3\n* \uff11\u65e5\u3067\u3044\u3051\u308b\u304b\u306a\u3068\u601d\u3063\u305f\u3051\u3069\u304b\u306a\u308a\u96e3\u3057\u304b\u3063\u305fOpenAL\uff08\u3067\u3082\u697d\u3057\u304b\u3063\u305f\uff09\n* \u6539\u826f\u70b9\u3042\u308a\u3059\u304e\u306a\u306e\u3067\u3001\u6642\u9593\u304c\u3042\u308c\u3070\u3061\u3083\u3093\u3068\u3057\u305f\u3082\u306e\u3092\u4f5c\u308a\u305f\u3044\u3067\u3059\u306d\n* piano\u3068\u3044\u3046\u30d1\u30c3\u30b1\u30fc\u30b8\u306b\u3057\u3066\u8272\u3093\u306a\u3082\u306e\u3092\u6f14\u594f\u51fa\u6765\u308b\u3088\u3046\u306b\u3057\u305f\u3044\u306a\u3068\u601d\u3044\u307e\u3057\u305f\n\n# \u53c2\u8003\n* https://github.com/nobonobo/nobopiano\n* https://godoc.org/golang.org/x/mobile/exp/audio/al\n"}