{"context": " More than 1 year has passed since last update.\n\n\u4eca\u56de\u3084\u308b\u3053\u3068\n\u524d\u56de\u306f\u30da\u30fc\u30b8\u30d5\u30a9\u30eb\u30c8\u30cf\u30f3\u30c9\u30e9\u306e\u4e2d\u5fc3\u3068\u306a\u3063\u3066\u3044\u308bdo_page_fault()\u306e\u524d\u534a\u90e8\u5206\u3092\u8aad\u3093\u3067\u307f\u307e\u3057\u305f\u3002\n\u4eca\u56de\u3082\u5f15\u304d\u7d9a\u304ddo_page_fault()\u3092\u8aad\u307f\u307e\u3059\u3002\n\narch/x86/mm/fault.c\n  vma = find_vma(mm, address);\n  if (unlikely(!vma)) {\n    bad_area(regs, error_code, address);\n    return;\n  }\n\n\n\n\u307e\u305a\u306f\u30a2\u30af\u30bb\u30b9\u5bfe\u8c61\u306e\u4eee\u60f3\u30a2\u30c9\u30ec\u30b9\u9818\u57df\u3092\u898b\u3064\u3051\u308b\nfind_vma()\u306f\u4ee5\u4e0b\u306e\u3068\u304a\u308a\u3067\u3059\u3002\n\nmm/mmap.c\n/* Look up the first VMA which satisfies  addr < vm_end,  NULL if none. */\nstruct vm_area_struct *find_vma(struct mm_struct *mm, unsigned long addr)\n\n\n\u307e\u3055\u306b\u30b3\u30e1\u30f3\u30c8\u306e\u3068\u304a\u308a\u3067\u3059\u3002\u3053\u306e\u95a2\u6570\u306e\u30c1\u30a7\u30c3\u30af\u306b\u5916\u308c\u305f\u3089\u305d\u308c\u306f\u8a72\u5f53\u30d7\u30ed\u30bb\u30b9\u306e\u30e1\u30e2\u30ea\u7a7a\u9593\u306b\u306a\u3044\u9818\u57df\u3078\u306e\u30a2\u30af\u30bb\u30b9\u3067\u3042\u308b\u3053\u3068\u304c\u6c7a\u5b9a\u3059\u308b\u306e\u3067\u3001bad_area()\u3092\u547c\u3073\u307e\u3059\u3002\n\narch/x86/mm/fault.c\n  if (likely(vma->vm_start <= address))\n    goto good_area;\n\n\n\u3057\u304b\u3057\u3001\u5148\u306efind_vma()\u306e\u30b3\u30e1\u30f3\u30c8\u306b\u3082\u3042\u308b\u3068\u304a\u308a\u3001find_vma()\u3067\u306f\u3042\u304f\u307e\u3067\u3082address < vm_end(\u9818\u57df\u306e\u6700\u5f8c)\u306e\u307f\u3057\u304b\u30c1\u30a7\u30c3\u30af\u3057\u3066\u3044\u307e\u305b\u3093\u3002\n\u6b63\u5f53\u306a\u9818\u57df\u3067\u3042\u308c\u3070\n\nvma->vm_start <= address < vma->vm_end\n\n\u306e\u306f\u305a\u3067\u3059\u3002\n\u3053\u306e\u30c1\u30a7\u30c3\u30af\u306b\u6210\u529f\u3059\u308b\u3068\u3001\u4eee\u60f3\u30a2\u30c9\u30ec\u30b9\u9818\u57df\u3068\u3057\u3066\u5b58\u5728\u3059\u308b\u7a7a\u9593\u3078\u306e\u30a2\u30af\u30bb\u30b9\u3067\u3042\u308b\u3053\u3068\u304c\u78ba\u5b9a\u3057\u307e\u3059\u3002\n\n\u300c\u4eee\u60f3\u30a2\u30c9\u30ec\u30b9\u9818\u57df\u3068\u3057\u3066\u5b58\u5728\u3057\u306a\u3044\u30b1\u30fc\u30b9\u300d\u3068\u306f\n\u4ee5\u4e0b\u306f\u4eee\u60f3\u30a2\u30c9\u30ec\u30b9\u9818\u57df\u3068\u3057\u3066\u5b58\u5728\u3057\u306a\u3044\u30b1\u30fc\u30b9\u3068\u306a\u308a\u307e\u3059\u3002\n\u5ff5\u306e\u305f\u3081\u3001\u3053\u306e\u30b1\u30fc\u30b9\u306e\u4f8b\u3092\u56f3\u306b\u3057\u3066\u30a4\u30e1\u30fc\u30b8\u3057\u3084\u3059\u3044\u3088\u3046\u306b\u3057\u307e\u3059\u3002\n\n\u4e0a\u8a18\u306e\u4f8b\u3060\u3068\u3001\u78ba\u304b\u306bvma->vm_end < address\u306avma\u306f\u3042\u308a\u3001find_vma()\u3067\u306fvma(vm_start=0x5000/vm_end=0x7000)\u3092\u5f97\u3089\u308c\u307e\u3059\u3002\n\u3057\u304b\u3057\u3001\u30a2\u30af\u30bb\u30b9\u3057\u3088\u3046\u3068\u3057\u3066\u3044\u308baddress\u306b\u306f\u4f55\u3082\u3042\u308a\u307e\u305b\u3093\u3002\n\u3053\u306e\u5834\u5408\u306b\u8a72\u5f53\u3059\u308b\u30b1\u30fc\u30b9\u3092\u4ee5\u4e0b\u3067\u3055\u3070\u304d\u307e\u3059\u3002\n\narch/x86/mm/fault.c\n  if (unlikely(!(vma->vm_flags & VM_GROWSDOWN))) {\n    bad_area(regs, error_code, address);\n    return;\n  }\n\n\nVM_GROWSDOWN\u306f\u300c\u8a72\u5f53\u4eee\u60f3\u30a2\u30c9\u30ec\u30b9\u9818\u57df\u304c\u30a2\u30c9\u30ec\u30b9\u306e\u82e5\u3044\u65b9\u306b\u5411\u304b\u3063\u3066\u4f38\u3073\u3066\u3044\u304f\u300d\u9818\u57df\u3067\u3042\u308b\u3053\u3068\u3092\u793a\u3057\u307e\u3059\u3002\n\u666e\u901a\u3001\u30a2\u30c9\u30ec\u30b9\u7a7a\u9593\u306f\u30a2\u30c9\u30ec\u30b9\u5024\u304c\u5927\u304d\u306a\u65b9\u306b\u5411\u304b\u3063\u3066\u4f38\u3073\u3066\u3044\u304d\u307e\u3059\u304c\u3001\u30b9\u30bf\u30c3\u30af\u306e\u3088\u3046\u306a\u9818\u57df\u3060\u3068\u5c0f\u3055\u306a\u65b9\u306b\u5411\u304b\u3063\u3066\u4f38\u3073\u3066\u3044\u304d\u307e\u3059\u3002\n\u305d\u3057\u3066\u3001\u5c0f\u3055\u306a\u65b9\u306b\u5411\u304b\u3063\u3066\u4f38\u3073\u3066\u3044\u304f(=vma->vm_start\u306e\u5024\u304c\u5909\u308f\u308b)\u3053\u3068\u3067\u3001\u7d50\u679c\u3068\u3057\u3066\u5b58\u5728\u3059\u308b\u4eee\u60f3\u30a2\u30c9\u30ec\u30b9\u7a7a\u9593\u3078\u306e\u30a2\u30af\u30bb\u30b9\u306b\u306a\u308b\u30b1\u30fc\u30b9\u3082\u3042\u308a\u3048\u307e\u3059\u3002\n\u4eca\u56de\u306e\u5224\u5b9a\u306b\u3082\u8a72\u5f53\u3057\u306a\u3044\u5834\u5408\u3001\u8a72\u5f53\u30a2\u30af\u30bb\u30b9\u304c\u6b63\u5f53\u306b\u306a\u308b\u53ef\u80fd\u6027\u306f\u6d88\u3048\u308b\u306e\u3067\u3001bad_area()\u304c\u547c\u3070\u308c\u307e\u3059\u3002\n\narch/x86/mm/fault.c\n  if (error_code & PF_USER) {\n    /*\n     * Accessing the stack below %sp is always a bug.\n     * The large cushion allows instructions like enter\n     * and pusha to work. (\"enter $65535, $31\" pushes\n     * 32 pointers and then decrements %sp by 65535.)\n     */\n    if (unlikely(address + 65536 + 32 * sizeof(unsigned long) < regs->sp)) {\n      bad_area(regs, error_code, address);\n      return;\n    }\n  }\n\n\n\u3053\u308c\u306f\u30b9\u30bf\u30c3\u30af\u30d5\u30ec\u30fc\u30e0\u3092\u660e\u3089\u304b\u306b\u306f\u307f\u51fa\u308b\u3088\u3046\u306aaddress\u3092\u5f3e\u304f\u5224\u5b9a\u3067\u3059\u3002\nIntel SDM\u306b\u3088\u308b\u3068\u3001\u30b3\u30e1\u30f3\u30c8\u3067\u4f8b\u3068\u3057\u3066\u6319\u3052\u3089\u308c\u3066\u3044\u308benter\u306f\u4ee5\u4e0b\u306e\u547d\u4ee4\u3068\u306a\u3063\u3066\u3044\u307e\u3059\u3002\u592a\u5b57\u306e\u3068\u3053\u308d\u304c\u3001\u4e0a\u8a18\u76f4\u5024\u306e65536,32\u306b\u3064\u306a\u304c\u3063\u3066\u304f\u308b\u3068\u601d\u308f\u308c\u307e\u3059\u3002\n(\u3061\u306a\u307f\u306bpusha\u306f\u300cPushes the contents of the general-purpose registers onto the stack.\u300d\u3068\u306e\u3053\u3068\u3067\u3042\u308a\u300165536byte\u3082\u306e\u30b9\u30bf\u30c3\u30af\u3092\u6d88\u8cbb\u3059\u308b\u3068\u306f\u8003\u3048\u306b\u304f\u3044\u3067\u3059\u3002enter\u547d\u4ee4\u304c\u30b9\u30bf\u30c3\u30af\u3092\u5927\u91cf\u306b\u6d88\u8cbb\u3059\u308b\u53ef\u80fd\u6027\u304c\u3042\u308b\u3068\u3044\u3046\u3053\u3068\u3067\u3057\u3087\u3046\u3002)\n\nENTER imm16, imm8\n(\u7565)\nCreates a stack frame for a procedure. The first operand (size operand) specifies the size of the stack frame (that is, the number of bytes of dynamic storage allocated on the stack for the procedure). The second operand (nesting level operand) gives the lexical nesting level (0 to 31) of the procedure.\n\n\u30b9\u30bf\u30c3\u30af\u3092\u62e1\u5f35\u3057\u307e\u3059\u3002\u62e1\u5f35\u306b\u5931\u6557\u3057\u305f\u5834\u5408\u3001bad_area()\u3092\u547c\u3076\u306e\u3060\u3068\u63a8\u5b9a\u3067\u304d\u307e\u3059\u3002\n\narch/x86/mm/fault.c\n  if (unlikely(expand_stack(vma, address))) {\n    bad_area(regs, error_code, address);\n    return;\n  }\n\n\n\n\u4fdd\u8b77\u6a29\u9650\u30c1\u30a7\u30c3\u30af\n\u3055\u3066\u3001\u3044\u3088\u3044\u3088\u3001\u30a2\u30af\u30bb\u30b9\u3057\u3088\u3046\u3068\u3057\u3066\u3044\u308b\u4eee\u60f3\u30a2\u30c9\u30ec\u30b9\u7a7a\u9593\u304c\u5b58\u5728\u3059\u308b\u3053\u3068\u3092\u524d\u63d0\u3068\u3057\u305f\u51e6\u7406\u306b\u5165\u308a\u307e\u3059\u3002\n\narch/x86/mm/fault.c\n  /*\n   * Ok, we have a good vm_area for this memory access, so\n   * we can handle it..\n   */\ngood_area:\n  if (unlikely(access_error(error_code, vma))) {\n    bad_area_access_error(regs, error_code, address);\n    return;\n  }\n\n\naccess_error()\u306f\u4ee5\u4e0b\u306e\u3068\u304a\u308a\u3067\u3059\u3002\n\u30a2\u30af\u30bb\u30b9\u5bfe\u8c61\u306e\u4eee\u60f3\u30a2\u30c9\u30ec\u30b9\u9818\u57df\u306b\u5bfe\u3059\u308b\u30a2\u30af\u30bb\u30b9\u65b9\u5f0f(Read\u3068\u304bWrite)\u304c\u4fdd\u8b77\u5c5e\u6027\u7684\u306b\u8a31\u3055\u308c\u3066\u3044\u308b\u304b\u8abf\u3079\u308b\u95a2\u6570\u3067\u3059\u3002\n\narch/x86/mm/fault.c\nstatic inline int\naccess_error(unsigned long error_code, struct vm_area_struct *vma)\n{\n  if (error_code & PF_WRITE) {\n    /* write, present and write, not present: */\n    if (unlikely(!(vma->vm_flags & VM_WRITE)))\n      return 1;\n    return 0;\n  }\n\n  /* read, present: */\n  if (unlikely(error_code & PF_PROT))\n    return 1;\n\n  /* read, not present: */\n  if (unlikely(!(vma->vm_flags & (VM_READ | VM_EXEC | VM_WRITE))))\n    return 1;\n\n  return 0;\n}\n\n\n\u3061\u306a\u307f\u306b\u3001access_error()\u5185\u306b\u51fa\u3066\u304f\u308bPF_PROT\u3067\u3059\u304c\u3001\u3053\u306e\u5024\u306f\u4ee5\u4e0b\u306eenum\u5024\u3067\u8868\u73fe\u3055\u308c\u3066\u3044\u307e\u3059\u3002\n\narch/x86/mm/fault.c\n/*\n * Page fault error code bits:\n *\n *   bit 0 ==  0: no page found 1: protection fault\n *   bit 1 ==  0: read access   1: write access\n *   bit 2 ==  0: kernel-mode access  1: user-mode access\n *   bit 3 ==       1: use of reserved bit detected\n *   bit 4 ==       1: fault was an instruction fetch\n */\nenum x86_pf_error_code {\n\n  PF_PROT   =   1 << 0,\n  PF_WRITE  =   1 << 1,\n  PF_USER   =   1 << 2,\n  PF_RSVD   =   1 << 3,\n  PF_INSTR  =   1 << 4,\n};\n\n\n\u524d\u56de\u5f15\u7528\u3057\u305fIntel SDM\u306eerror_code\u306e\u30d5\u30a9\u30fc\u30de\u30c3\u30c8\u306ebit0\u3068\u4e0a\u8a18enum\u5024\u304b\u3089\u3001\u3053\u306e\u30d3\u30c3\u30c8\u306f\u30da\u30fc\u30b8\u30d5\u30a9\u30eb\u30c8\u4f8b\u5916\u306e\u8981\u56e0\u3092\u8868\u3057\u307e\u3059\u3002\n\n\u30da\u30fc\u30b8\u30d5\u30a9\u30eb\u30c8\u306e\u5b9f\u969b\u306e\u51e6\u7406\n\u3053\u3053\u307e\u3067\u306e\u30c1\u30a7\u30c3\u30af\u3092\u304f\u3050\u308a\u629c\u3051\u3066\u30da\u30fc\u30b8\u30d5\u30a9\u30eb\u30c8\u306e\u5b9f\u969b\u306e\u51e6\u7406\u306b\u5165\u308a\u307e\u3059\u3002\n\u305d\u308c\u3092\u884c\u3063\u3066\u3044\u308b\u306e\u304c\u3001handle_mm_fault()\u3068\u63a8\u5b9a\u3057\u307e\u3059\u3002\n\narch/x86/mm/fault.c\n  /*\n   * If for any reason at all we couldn't handle the fault,\n   * make sure we exit gracefully rather than endlessly redo\n   * the fault:\n   */\n  fault = handle_mm_fault(mm, vma, address, flags);\n\n\n\u4ee5\u5f8c\u306f\u3001handle_mm_fault()\u306e\u623b\u308a\u5024\u3092\u898b\u3066\u3001\u30a8\u30e9\u30fc\u51e6\u7406\u3092\u884c\u3063\u3066\u3044\u307e\u3059\u3002\n\u5358\u306a\u308b\u30a8\u30e9\u30fc(VM_FAULT_ERROR)\u3060\u3051\u3067\u306a\u304f\u3001\u300c\u30ea\u30c8\u30e9\u30a4\u3092\u8981\u3059\u308b\u300d(VM_FAULT_RETRY)\u3082\u3042\u308a\u307e\u3059\u3002\u305d\u308c\u304c\u3069\u306e\u3088\u3046\u306a\u30b1\u30fc\u30b9\u3067\u8d77\u3053\u308a\u3046\u308b\u304b\u306fhandle_mm_fault()\u306e\u5b9f\u88c5\u3092\u898b\u308b\u3053\u3068\u3067\u660e\u3089\u304b\u306b\u306a\u308b\u3067\u3057\u3087\u3046\u3002\n\narch/x86/mm/fault.c\n  /*\n   * If we need to retry but a fatal signal is pending, handle the\n   * signal first. We do not need to release the mmap_sem because it\n   * would already be released in __lock_page_or_retry in mm/filemap.c.\n   */\n  if (unlikely((fault & VM_FAULT_RETRY) && fatal_signal_pending(current)))\n    return;\n\n  if (unlikely(fault & VM_FAULT_ERROR)) {\n    mm_fault_error(regs, error_code, address, fault);\n    return;\n  }\n\n  /*\n   * Major/minor page fault accounting is only done on the\n   * initial attempt. If we go through a retry, it is extremely\n   * likely that the page will be found in page cache at that point.\n   */\n  if (flags & FAULT_FLAG_ALLOW_RETRY) {\n    if (fault & VM_FAULT_MAJOR) {\n      tsk->maj_flt++;\n      perf_sw_event(PERF_COUNT_SW_PAGE_FAULTS_MAJ, 1,\n              regs, address);\n    } else {\n      tsk->min_flt++;\n      perf_sw_event(PERF_COUNT_SW_PAGE_FAULTS_MIN, 1,\n              regs, address);\n    }\n    if (fault & VM_FAULT_RETRY) {\n      /* Clear FAULT_FLAG_ALLOW_RETRY to avoid any risk\n       * of starvation. */\n      flags &= ~FAULT_FLAG_ALLOW_RETRY;\n      flags |= FAULT_FLAG_TRIED;\n      goto retry;\n    }\n  }\n\n\n\u6700\u5f8c\u306b\u3001check_v8086_mode()\u3092\u547c\u3093\u3067\u3001\u30bb\u30de\u30d5\u30a9\u3092\u89e3\u9664\u3057\u3066\u30da\u30fc\u30b8\u30d5\u30a9\u30eb\u30c8\u51e6\u7406\u3092\u7d42\u4e86\u3057\u307e\u3059\u3002\n\narch/x86/mm/fault.c\n  check_v8086_mode(regs, address, tsk);\n\n  up_read(&mm->mmap_sem);\n}\n\n\n\u6c17\u306b\u306a\u308b\u306e\u3067\u3001check_v8086()\u3092\u8997\u3044\u3066\u307f\u307e\u3057\u305f\u3002\n\narch/x86/mm/fault.c\n/*\n * Did it hit the DOS screen memory VA from vm86 mode?\n */\nstatic inline void\ncheck_v8086_mode(struct pt_regs *regs, unsigned long address,\n     struct task_struct *tsk)\n{\n  unsigned long bit;\n\n  if (!v8086_mode(regs))\n    return;\n\n  bit = (address - 0xA0000) >> PAGE_SHIFT;\n  if (bit < 32)\n    tsk->thread.screen_bitmap |= 1 << bit;\n}\n\n\n\n\u3061\u3087\u3063\u3068\u3060\u3051\u4eee\u60f38086\u30e2\u30fc\u30c9\n\u3053\u308c\u306f\u3001\u4eee\u60f38086\u30e2\u30fc\u30c9\u306b\u95a2\u3059\u308b\u95a2\u6570\u3068\u63a8\u5bdf\u3067\u304d\u307e\u3059\u3002\n\u4eee\u60f38086\u30e2\u30fc\u30c9\u3068\u306f\u3001\u300c\u30d7\u30ed\u30c6\u30af\u30c8\u30e2\u30fc\u30c9\u306e\u30bf\u30b9\u30af\u4fdd\u8b77\u306e\u7ba1\u7406\u4e0b\u30678086\u306e\u30b3\u30fc\u30c9\u3092\u5b9f\u884c\u3059\u308b\u3053\u3068\u306b\u3088\u3063\u3066\u305d\u306e\u4eee\u60f3\u6a5f\u68b0\u306e\u5b9f\u88c5\u3092\u30cf\u30fc\u30c9\u30a6\u30a8\u30a2\u7684\u306b\u652f\u63f4\u3059\u308b(Wikipedia\u3088\u308a\u629c\u7c8b)\u300d\u6a5f\u80fd\u3067\u3059\u3002\n\u305d\u3057\u3066\u3001PC\u30a2\u30fc\u30ad\u30c6\u30af\u30c1\u30e3\u30670xA00000\u3068\u8a00\u3048\u3070Video RAM(VGA display)\u306e\u9818\u57df\u3067\u3059\u3002\u3053\u306e\u9818\u57df\u306e\u5024\u3092\u5909\u3048\u308b\u3068\u3001\u753b\u9762\u3078\u306e\u51fa\u529b\u3092\u5909\u3048\u308b\u3053\u3068\u304c\u3067\u304d\u307e\u3059\u3002\n(\u30e1\u30e2\u30ea\u30de\u30c3\u30d7\u306fOSDev\u306e\u8a18\u4e8b\u3092\u53c2\u7167\u3055\u308c\u308b\u3068\u308f\u304b\u308a\u3084\u3059\u3044\u3067\u3059\u3002\u3053\u308c\u3001\u3069\u3053\u304b\u306b\u516c\u5f0f\u306a\u898f\u683c\u66f8\u3042\u3063\u305f\u308a\u3059\u308b\u306e\u304b\u3044\u306a\uff1f)\n\u4e0a\u8a18\u30bd\u30fc\u30b9\u306e\n\ntsk->thread.screen_bitmap |= 1 << bit;\n\n\n\u306f\u4eee\u60f38086\u30e2\u30fc\u30c9\u4e0b\u3067\u52d5\u304f\u30bd\u30d5\u30c8\u30a6\u30a7\u30a2\u304c\u63d0\u4f9b\u3059\u308b\u4eee\u60f3\u7684\u306a\u753b\u9762\u3078\u306e\u51fa\u529b\u3092\u5909\u66f4\u3057\u3066\u3044\u308b\u3068\u63a8\u5b9a\u3067\u304d\u307e\u3059\u3002\n\n\u3084\u3063\u3068\u3001__do_page_fault()\u304c\u7d42\u308f\u308a\u307e\u3057\u305f\n\u9577\u304b\u3063\u305f\u3067\u3059\u304c\u3001__do_page_fault()\u3092\u3056\u3063\u3068\u773a\u3081\u3066\u304d\u307e\u3057\u305f\u3002\n\u3057\u304b\u3057\u3001\u307e\u3060\u5148\u306f\u9577\u3044\u3002\u3053\u308c\u304b\u3089\u304c\u672c\u756a\u3067\u3059\u3002\n\n\u6b21\u56de\u306e\u4e88\u5b9a\n\u6b21\u56de\u306f\u30da\u30fc\u30b8\u30d5\u30a9\u30eb\u30c8\u306e\u5b9f\u969b\u7684\u306a\u51e6\u7406\u3092\u884c\u3063\u3066\u3044\u308bhandle_mm_fault()\u3092\u8ffd\u3063\u3066\u307f\u307e\u3059\u3002\n## \u4eca\u56de\u3084\u308b\u3053\u3068\n\n[\u524d\u56de](http://qiita.com/akachochin/items/5121d658fa62fb116728)\u306f\u30da\u30fc\u30b8\u30d5\u30a9\u30eb\u30c8\u30cf\u30f3\u30c9\u30e9\u306e\u4e2d\u5fc3\u3068\u306a\u3063\u3066\u3044\u308bdo_page_fault()\u306e\u524d\u534a\u90e8\u5206\u3092\u8aad\u3093\u3067\u307f\u307e\u3057\u305f\u3002\n\u4eca\u56de\u3082\u5f15\u304d\u7d9a\u304ddo_page_fault()\u3092\u8aad\u307f\u307e\u3059\u3002\n\n```c:arch/x86/mm/fault.c\n  vma = find_vma(mm, address);\n  if (unlikely(!vma)) {\n    bad_area(regs, error_code, address);\n    return;\n  }\n```\n\n## \u307e\u305a\u306f\u30a2\u30af\u30bb\u30b9\u5bfe\u8c61\u306e\u4eee\u60f3\u30a2\u30c9\u30ec\u30b9\u9818\u57df\u3092\u898b\u3064\u3051\u308b\nfind_vma()\u306f\u4ee5\u4e0b\u306e\u3068\u304a\u308a\u3067\u3059\u3002\n\n```c:mm/mmap.c\n/* Look up the first VMA which satisfies  addr < vm_end,  NULL if none. */\nstruct vm_area_struct *find_vma(struct mm_struct *mm, unsigned long addr)\n```\n\n\u307e\u3055\u306b\u30b3\u30e1\u30f3\u30c8\u306e\u3068\u304a\u308a\u3067\u3059\u3002\u3053\u306e\u95a2\u6570\u306e\u30c1\u30a7\u30c3\u30af\u306b\u5916\u308c\u305f\u3089\u305d\u308c\u306f\u8a72\u5f53\u30d7\u30ed\u30bb\u30b9\u306e\u30e1\u30e2\u30ea\u7a7a\u9593\u306b\u306a\u3044\u9818\u57df\u3078\u306e\u30a2\u30af\u30bb\u30b9\u3067\u3042\u308b\u3053\u3068\u304c\u6c7a\u5b9a\u3059\u308b\u306e\u3067\u3001bad_area()\u3092\u547c\u3073\u307e\u3059\u3002\n\n```c:arch/x86/mm/fault.c\n  if (likely(vma->vm_start <= address))\n    goto good_area;\n```\n\n\u3057\u304b\u3057\u3001\u5148\u306efind_vma()\u306e\u30b3\u30e1\u30f3\u30c8\u306b\u3082\u3042\u308b\u3068\u304a\u308a\u3001find_vma()\u3067\u306f\u3042\u304f\u307e\u3067\u3082address < vm_end(\u9818\u57df\u306e\u6700\u5f8c)\u306e\u307f\u3057\u304b\u30c1\u30a7\u30c3\u30af\u3057\u3066\u3044\u307e\u305b\u3093\u3002\n\u6b63\u5f53\u306a\u9818\u57df\u3067\u3042\u308c\u3070\n\n> vma->vm_start <= address < vma->vm_end\n\n\u306e\u306f\u305a\u3067\u3059\u3002\n\u3053\u306e\u30c1\u30a7\u30c3\u30af\u306b\u6210\u529f\u3059\u308b\u3068\u3001\u4eee\u60f3\u30a2\u30c9\u30ec\u30b9\u9818\u57df\u3068\u3057\u3066\u5b58\u5728\u3059\u308b\u7a7a\u9593\u3078\u306e\u30a2\u30af\u30bb\u30b9\u3067\u3042\u308b\u3053\u3068\u304c\u78ba\u5b9a\u3057\u307e\u3059\u3002\n\n## \u300c\u4eee\u60f3\u30a2\u30c9\u30ec\u30b9\u9818\u57df\u3068\u3057\u3066\u5b58\u5728\u3057\u306a\u3044\u30b1\u30fc\u30b9\u300d\u3068\u306f\n\u4ee5\u4e0b\u306f\u4eee\u60f3\u30a2\u30c9\u30ec\u30b9\u9818\u57df\u3068\u3057\u3066\u5b58\u5728\u3057\u306a\u3044\u30b1\u30fc\u30b9\u3068\u306a\u308a\u307e\u3059\u3002\n\u5ff5\u306e\u305f\u3081\u3001\u3053\u306e\u30b1\u30fc\u30b9\u306e\u4f8b\u3092\u56f3\u306b\u3057\u3066\u30a4\u30e1\u30fc\u30b8\u3057\u3084\u3059\u3044\u3088\u3046\u306b\u3057\u307e\u3059\u3002\n\n![find_vma.jpg](https://qiita-image-store.s3.amazonaws.com/0/19975/74812ef4-7884-d0a7-5803-3eb4bb873c00.jpeg)\n\n\u4e0a\u8a18\u306e\u4f8b\u3060\u3068\u3001\u78ba\u304b\u306bvma->vm_end < address\u306avma\u306f\u3042\u308a\u3001find_vma()\u3067\u306fvma(vm_start=0x5000/vm_end=0x7000)\u3092\u5f97\u3089\u308c\u307e\u3059\u3002\n\u3057\u304b\u3057\u3001\u30a2\u30af\u30bb\u30b9\u3057\u3088\u3046\u3068\u3057\u3066\u3044\u308baddress\u306b\u306f\u4f55\u3082\u3042\u308a\u307e\u305b\u3093\u3002\n\u3053\u306e\u5834\u5408\u306b\u8a72\u5f53\u3059\u308b\u30b1\u30fc\u30b9\u3092\u4ee5\u4e0b\u3067\u3055\u3070\u304d\u307e\u3059\u3002\n\n```c:arch/x86/mm/fault.c\n  if (unlikely(!(vma->vm_flags & VM_GROWSDOWN))) {\n    bad_area(regs, error_code, address);\n    return;\n  }\n```\n\nVM_GROWSDOWN\u306f\u300c\u8a72\u5f53\u4eee\u60f3\u30a2\u30c9\u30ec\u30b9\u9818\u57df\u304c\u30a2\u30c9\u30ec\u30b9\u306e\u82e5\u3044\u65b9\u306b\u5411\u304b\u3063\u3066\u4f38\u3073\u3066\u3044\u304f\u300d\u9818\u57df\u3067\u3042\u308b\u3053\u3068\u3092\u793a\u3057\u307e\u3059\u3002\n\u666e\u901a\u3001\u30a2\u30c9\u30ec\u30b9\u7a7a\u9593\u306f\u30a2\u30c9\u30ec\u30b9\u5024\u304c\u5927\u304d\u306a\u65b9\u306b\u5411\u304b\u3063\u3066\u4f38\u3073\u3066\u3044\u304d\u307e\u3059\u304c\u3001\u30b9\u30bf\u30c3\u30af\u306e\u3088\u3046\u306a\u9818\u57df\u3060\u3068\u5c0f\u3055\u306a\u65b9\u306b\u5411\u304b\u3063\u3066\u4f38\u3073\u3066\u3044\u304d\u307e\u3059\u3002\n\u305d\u3057\u3066\u3001\u5c0f\u3055\u306a\u65b9\u306b\u5411\u304b\u3063\u3066\u4f38\u3073\u3066\u3044\u304f(=vma->vm_start\u306e\u5024\u304c\u5909\u308f\u308b)\u3053\u3068\u3067\u3001\u7d50\u679c\u3068\u3057\u3066\u5b58\u5728\u3059\u308b\u4eee\u60f3\u30a2\u30c9\u30ec\u30b9\u7a7a\u9593\u3078\u306e\u30a2\u30af\u30bb\u30b9\u306b\u306a\u308b\u30b1\u30fc\u30b9\u3082\u3042\u308a\u3048\u307e\u3059\u3002\n\n\u4eca\u56de\u306e\u5224\u5b9a\u306b\u3082\u8a72\u5f53\u3057\u306a\u3044\u5834\u5408\u3001\u8a72\u5f53\u30a2\u30af\u30bb\u30b9\u304c\u6b63\u5f53\u306b\u306a\u308b\u53ef\u80fd\u6027\u306f\u6d88\u3048\u308b\u306e\u3067\u3001bad_area()\u304c\u547c\u3070\u308c\u307e\u3059\u3002\n\n```c:arch/x86/mm/fault.c\n  if (error_code & PF_USER) {\n    /*\n     * Accessing the stack below %sp is always a bug.\n     * The large cushion allows instructions like enter\n     * and pusha to work. (\"enter $65535, $31\" pushes\n     * 32 pointers and then decrements %sp by 65535.)\n     */\n    if (unlikely(address + 65536 + 32 * sizeof(unsigned long) < regs->sp)) {\n      bad_area(regs, error_code, address);\n      return;\n    }\n  }\n```\n\n\u3053\u308c\u306f\u30b9\u30bf\u30c3\u30af\u30d5\u30ec\u30fc\u30e0\u3092\u660e\u3089\u304b\u306b\u306f\u307f\u51fa\u308b\u3088\u3046\u306aaddress\u3092\u5f3e\u304f\u5224\u5b9a\u3067\u3059\u3002\nIntel SDM\u306b\u3088\u308b\u3068\u3001\u30b3\u30e1\u30f3\u30c8\u3067\u4f8b\u3068\u3057\u3066\u6319\u3052\u3089\u308c\u3066\u3044\u308benter\u306f\u4ee5\u4e0b\u306e\u547d\u4ee4\u3068\u306a\u3063\u3066\u3044\u307e\u3059\u3002\u592a\u5b57\u306e\u3068\u3053\u308d\u304c\u3001\u4e0a\u8a18\u76f4\u5024\u306e65536,32\u306b\u3064\u306a\u304c\u3063\u3066\u304f\u308b\u3068\u601d\u308f\u308c\u307e\u3059\u3002\n(\u3061\u306a\u307f\u306bpusha\u306f\u300cPushes the contents of the general-purpose registers onto the stack.\u300d\u3068\u306e\u3053\u3068\u3067\u3042\u308a\u300165536byte\u3082\u306e\u30b9\u30bf\u30c3\u30af\u3092\u6d88\u8cbb\u3059\u308b\u3068\u306f\u8003\u3048\u306b\u304f\u3044\u3067\u3059\u3002enter\u547d\u4ee4\u304c\u30b9\u30bf\u30c3\u30af\u3092\u5927\u91cf\u306b\u6d88\u8cbb\u3059\u308b\u53ef\u80fd\u6027\u304c\u3042\u308b\u3068\u3044\u3046\u3053\u3068\u3067\u3057\u3087\u3046\u3002)\n\n> ENTER **imm16**, imm8\n> (\u7565)\n> Creates a stack frame for a procedure. The first operand (size operand) specifies the size of the stack frame (that is, the number of bytes of dynamic storage allocated on the stack for the procedure). The second operand (nesting level operand) gives the lexical nesting level **(0 to 31)** of the procedure.\n\n\u30b9\u30bf\u30c3\u30af\u3092\u62e1\u5f35\u3057\u307e\u3059\u3002\u62e1\u5f35\u306b\u5931\u6557\u3057\u305f\u5834\u5408\u3001bad_area()\u3092\u547c\u3076\u306e\u3060\u3068\u63a8\u5b9a\u3067\u304d\u307e\u3059\u3002\n\n```c:arch/x86/mm/fault.c\n  if (unlikely(expand_stack(vma, address))) {\n    bad_area(regs, error_code, address);\n    return;\n  }\n```\n\n## \u4fdd\u8b77\u6a29\u9650\u30c1\u30a7\u30c3\u30af\n\u3055\u3066\u3001\u3044\u3088\u3044\u3088\u3001\u30a2\u30af\u30bb\u30b9\u3057\u3088\u3046\u3068\u3057\u3066\u3044\u308b\u4eee\u60f3\u30a2\u30c9\u30ec\u30b9\u7a7a\u9593\u304c\u5b58\u5728\u3059\u308b\u3053\u3068\u3092\u524d\u63d0\u3068\u3057\u305f\u51e6\u7406\u306b\u5165\u308a\u307e\u3059\u3002\n\n```c:arch/x86/mm/fault.c\n  /*\n   * Ok, we have a good vm_area for this memory access, so\n   * we can handle it..\n   */\ngood_area:\n  if (unlikely(access_error(error_code, vma))) {\n    bad_area_access_error(regs, error_code, address);\n    return;\n  }\n```\n\naccess_error()\u306f\u4ee5\u4e0b\u306e\u3068\u304a\u308a\u3067\u3059\u3002\n\u30a2\u30af\u30bb\u30b9\u5bfe\u8c61\u306e\u4eee\u60f3\u30a2\u30c9\u30ec\u30b9\u9818\u57df\u306b\u5bfe\u3059\u308b\u30a2\u30af\u30bb\u30b9\u65b9\u5f0f(Read\u3068\u304bWrite)\u304c\u4fdd\u8b77\u5c5e\u6027\u7684\u306b\u8a31\u3055\u308c\u3066\u3044\u308b\u304b\u8abf\u3079\u308b\u95a2\u6570\u3067\u3059\u3002\n\n```c:arch/x86/mm/fault.c\nstatic inline int\naccess_error(unsigned long error_code, struct vm_area_struct *vma)\n{\n  if (error_code & PF_WRITE) {\n    /* write, present and write, not present: */\n    if (unlikely(!(vma->vm_flags & VM_WRITE)))\n      return 1;\n    return 0;\n  }\n\n  /* read, present: */\n  if (unlikely(error_code & PF_PROT))\n    return 1;\n\n  /* read, not present: */\n  if (unlikely(!(vma->vm_flags & (VM_READ | VM_EXEC | VM_WRITE))))\n    return 1;\n\n  return 0;\n}\n```\n\n\u3061\u306a\u307f\u306b\u3001access_error()\u5185\u306b\u51fa\u3066\u304f\u308bPF_PROT\u3067\u3059\u304c\u3001\u3053\u306e\u5024\u306f\u4ee5\u4e0b\u306eenum\u5024\u3067\u8868\u73fe\u3055\u308c\u3066\u3044\u307e\u3059\u3002\n\n```c:arch/x86/mm/fault.c\n/*\n * Page fault error code bits:\n *\n *   bit 0 ==  0: no page found 1: protection fault\n *   bit 1 ==  0: read access   1: write access\n *   bit 2 ==  0: kernel-mode access  1: user-mode access\n *   bit 3 ==       1: use of reserved bit detected\n *   bit 4 ==       1: fault was an instruction fetch\n */\nenum x86_pf_error_code {\n\n  PF_PROT   =   1 << 0,\n  PF_WRITE  =   1 << 1,\n  PF_USER   =   1 << 2,\n  PF_RSVD   =   1 << 3,\n  PF_INSTR  =   1 << 4,\n};\n```\n\n[\u524d\u56de](http://qiita.com/akachochin/items/5121d658fa62fb116728)\u5f15\u7528\u3057\u305fIntel SDM\u306eerror_code\u306e\u30d5\u30a9\u30fc\u30de\u30c3\u30c8\u306ebit0\u3068\u4e0a\u8a18enum\u5024\u304b\u3089\u3001\u3053\u306e\u30d3\u30c3\u30c8\u306f\u30da\u30fc\u30b8\u30d5\u30a9\u30eb\u30c8\u4f8b\u5916\u306e\u8981\u56e0\u3092\u8868\u3057\u307e\u3059\u3002\n\n## \u30da\u30fc\u30b8\u30d5\u30a9\u30eb\u30c8\u306e\u5b9f\u969b\u306e\u51e6\u7406\n\u3053\u3053\u307e\u3067\u306e\u30c1\u30a7\u30c3\u30af\u3092\u304f\u3050\u308a\u629c\u3051\u3066\u30da\u30fc\u30b8\u30d5\u30a9\u30eb\u30c8\u306e\u5b9f\u969b\u306e\u51e6\u7406\u306b\u5165\u308a\u307e\u3059\u3002\n\u305d\u308c\u3092\u884c\u3063\u3066\u3044\u308b\u306e\u304c\u3001handle_mm_fault()\u3068\u63a8\u5b9a\u3057\u307e\u3059\u3002\n\n```c:arch/x86/mm/fault.c\n  /*\n   * If for any reason at all we couldn't handle the fault,\n   * make sure we exit gracefully rather than endlessly redo\n   * the fault:\n   */\n  fault = handle_mm_fault(mm, vma, address, flags);\n```\n\n\u4ee5\u5f8c\u306f\u3001handle_mm_fault()\u306e\u623b\u308a\u5024\u3092\u898b\u3066\u3001\u30a8\u30e9\u30fc\u51e6\u7406\u3092\u884c\u3063\u3066\u3044\u307e\u3059\u3002\n\u5358\u306a\u308b\u30a8\u30e9\u30fc(VM_FAULT_ERROR)\u3060\u3051\u3067\u306a\u304f\u3001\u300c\u30ea\u30c8\u30e9\u30a4\u3092\u8981\u3059\u308b\u300d(VM_FAULT_RETRY)\u3082\u3042\u308a\u307e\u3059\u3002\u305d\u308c\u304c\u3069\u306e\u3088\u3046\u306a\u30b1\u30fc\u30b9\u3067\u8d77\u3053\u308a\u3046\u308b\u304b\u306fhandle_mm_fault()\u306e\u5b9f\u88c5\u3092\u898b\u308b\u3053\u3068\u3067\u660e\u3089\u304b\u306b\u306a\u308b\u3067\u3057\u3087\u3046\u3002\n\n```c:arch/x86/mm/fault.c\n  /*\n   * If we need to retry but a fatal signal is pending, handle the\n   * signal first. We do not need to release the mmap_sem because it\n   * would already be released in __lock_page_or_retry in mm/filemap.c.\n   */\n  if (unlikely((fault & VM_FAULT_RETRY) && fatal_signal_pending(current)))\n    return;\n\n  if (unlikely(fault & VM_FAULT_ERROR)) {\n    mm_fault_error(regs, error_code, address, fault);\n    return;\n  }\n\n  /*\n   * Major/minor page fault accounting is only done on the\n   * initial attempt. If we go through a retry, it is extremely\n   * likely that the page will be found in page cache at that point.\n   */\n  if (flags & FAULT_FLAG_ALLOW_RETRY) {\n    if (fault & VM_FAULT_MAJOR) {\n      tsk->maj_flt++;\n      perf_sw_event(PERF_COUNT_SW_PAGE_FAULTS_MAJ, 1,\n              regs, address);\n    } else {\n      tsk->min_flt++;\n      perf_sw_event(PERF_COUNT_SW_PAGE_FAULTS_MIN, 1,\n              regs, address);\n    }\n    if (fault & VM_FAULT_RETRY) {\n      /* Clear FAULT_FLAG_ALLOW_RETRY to avoid any risk\n       * of starvation. */\n      flags &= ~FAULT_FLAG_ALLOW_RETRY;\n      flags |= FAULT_FLAG_TRIED;\n      goto retry;\n    }\n  }\n```\n\n\u6700\u5f8c\u306b\u3001check_v8086_mode()\u3092\u547c\u3093\u3067\u3001\u30bb\u30de\u30d5\u30a9\u3092\u89e3\u9664\u3057\u3066\u30da\u30fc\u30b8\u30d5\u30a9\u30eb\u30c8\u51e6\u7406\u3092\u7d42\u4e86\u3057\u307e\u3059\u3002\n\n```c:arch/x86/mm/fault.c\n  check_v8086_mode(regs, address, tsk);\n\n  up_read(&mm->mmap_sem);\n}\n```\n\n\u6c17\u306b\u306a\u308b\u306e\u3067\u3001check_v8086()\u3092\u8997\u3044\u3066\u307f\u307e\u3057\u305f\u3002\n\n```c:arch/x86/mm/fault.c\n/*\n * Did it hit the DOS screen memory VA from vm86 mode?\n */\nstatic inline void\ncheck_v8086_mode(struct pt_regs *regs, unsigned long address,\n     struct task_struct *tsk)\n{\n  unsigned long bit;\n\n  if (!v8086_mode(regs))\n    return;\n\n  bit = (address - 0xA0000) >> PAGE_SHIFT;\n  if (bit < 32)\n    tsk->thread.screen_bitmap |= 1 << bit;\n}\n```\n\n## \u3061\u3087\u3063\u3068\u3060\u3051\u4eee\u60f38086\u30e2\u30fc\u30c9\n\u3053\u308c\u306f\u3001\u4eee\u60f38086\u30e2\u30fc\u30c9\u306b\u95a2\u3059\u308b\u95a2\u6570\u3068\u63a8\u5bdf\u3067\u304d\u307e\u3059\u3002\n\u4eee\u60f38086\u30e2\u30fc\u30c9\u3068\u306f\u3001\u300c\u30d7\u30ed\u30c6\u30af\u30c8\u30e2\u30fc\u30c9\u306e\u30bf\u30b9\u30af\u4fdd\u8b77\u306e\u7ba1\u7406\u4e0b\u30678086\u306e\u30b3\u30fc\u30c9\u3092\u5b9f\u884c\u3059\u308b\u3053\u3068\u306b\u3088\u3063\u3066\u305d\u306e\u4eee\u60f3\u6a5f\u68b0\u306e\u5b9f\u88c5\u3092\u30cf\u30fc\u30c9\u30a6\u30a8\u30a2\u7684\u306b\u652f\u63f4\u3059\u308b([Wikipedia](http://ja.wikipedia.org/wiki/%E4%BB%AE%E6%83%B386%E3%83%A2%E3%83%BC%E3%83%89)\u3088\u308a\u629c\u7c8b)\u300d\u6a5f\u80fd\u3067\u3059\u3002\n\n\u305d\u3057\u3066\u3001PC\u30a2\u30fc\u30ad\u30c6\u30af\u30c1\u30e3\u30670xA00000\u3068\u8a00\u3048\u3070Video RAM(VGA display)\u306e\u9818\u57df\u3067\u3059\u3002\u3053\u306e\u9818\u57df\u306e\u5024\u3092\u5909\u3048\u308b\u3068\u3001\u753b\u9762\u3078\u306e\u51fa\u529b\u3092\u5909\u3048\u308b\u3053\u3068\u304c\u3067\u304d\u307e\u3059\u3002\n(\u30e1\u30e2\u30ea\u30de\u30c3\u30d7\u306f[OSDev](http://wiki.osdev.org/Memory_Map_%28x86%29)\u306e\u8a18\u4e8b\u3092\u53c2\u7167\u3055\u308c\u308b\u3068\u308f\u304b\u308a\u3084\u3059\u3044\u3067\u3059\u3002\u3053\u308c\u3001\u3069\u3053\u304b\u306b\u516c\u5f0f\u306a\u898f\u683c\u66f8\u3042\u3063\u305f\u308a\u3059\u308b\u306e\u304b\u3044\u306a\uff1f)\n\n\u4e0a\u8a18\u30bd\u30fc\u30b9\u306e\n\n>     tsk->thread.screen_bitmap |= 1 << bit;\n\n\u306f\u4eee\u60f38086\u30e2\u30fc\u30c9\u4e0b\u3067\u52d5\u304f\u30bd\u30d5\u30c8\u30a6\u30a7\u30a2\u304c\u63d0\u4f9b\u3059\u308b\u4eee\u60f3\u7684\u306a\u753b\u9762\u3078\u306e\u51fa\u529b\u3092\u5909\u66f4\u3057\u3066\u3044\u308b\u3068\u63a8\u5b9a\u3067\u304d\u307e\u3059\u3002\n\n## \u3084\u3063\u3068\u3001__do_page_fault()\u304c\u7d42\u308f\u308a\u307e\u3057\u305f\n\u9577\u304b\u3063\u305f\u3067\u3059\u304c\u3001__do_page_fault()\u3092\u3056\u3063\u3068\u773a\u3081\u3066\u304d\u307e\u3057\u305f\u3002\n\u3057\u304b\u3057\u3001**\u307e\u3060\u5148\u306f\u9577\u3044\u3002\u3053\u308c\u304b\u3089\u304c\u672c\u756a\u3067\u3059\u3002**\n\n## \u6b21\u56de\u306e\u4e88\u5b9a\n\u6b21\u56de\u306f\u30da\u30fc\u30b8\u30d5\u30a9\u30eb\u30c8\u306e\u5b9f\u969b\u7684\u306a\u51e6\u7406\u3092\u884c\u3063\u3066\u3044\u308bhandle_mm_fault()\u3092\u8ffd\u3063\u3066\u307f\u307e\u3059\u3002\n\n", "tags": ["Linux", "\u4eee\u60f3\u8a18\u61b6", "kernel", "kernelvm"]}