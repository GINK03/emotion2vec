{"context": " More than 1 year has passed since last update.\n\nWhat is eval-in-repl.el?\neval-in-repl.el allows a single keybinding \"C-RET\" to do REPL start up, current expression evaluation in REPL, and selected (if any) expression evaluation in REPL. It currently supports various lisp languages (Clojure, Common Lisp, Scheme, Racket, Hy, and Emacs Lisp), Python, shell, Ruby, SML, and OCaml utilizing pre-existing major and minor modes. eval-in-repl.el is available at the MELPA package repostiroy (http://melpa.org/#/eval-in-repl ). You can skip to the screen shot\nUpdate on 2014-12-30: Added a screencast to the github repo\nhttps://github.com/kaz-yos/eval-in-repl\nHigher quality movie on YouTube\nhttps://www.youtube.com/watch?v=gNBlF67e-0w&feature=youtu.be\n\nInfluence of ESS\nI use emacs mainly for statistical analyses with R (http://www.r-project.org ). Emacs Speak Statistics (ESS; http://ess.r-project.org ) is my favorite emas package. Statistical analyses is inherently interactive. I constantly evaluate a small piece of code, check the results, and modify code or add code depending on the results. ESS makes REPL interaction easy by making \"C-RET\" (control+return) do everything. On the first invocation, \"C-RET\" will start up an R interpreter. From there on, \"C-RET\" will send code to the R interpreter. If there is no selection, the current line is sent. If there is a selection, the whole selected code is sent. The nice thing is that, the interpreter shows both the code evaluated and the evaluation result, so you can tell what resulted in what.\n\neval-in-repl.el\nEmacs has major and minor modes to support programming in many languages. Most recent languages have REPLs. \"C-x C-r\" is usually bound to evaluate the selected region. But it may or may not work if no REPL buffer exist yet. Also evaulation may only show the result in the minibuffer transiently or show the result in the REPL buffer but without the code.\nI wanted an ESS-like \"C-RET\"-rules-all system for other languages with REPLs. So I wrote eval-in-repl.el(http://melpa.org/#/eval-in-repl ). I'm an elisp beginner, so this package does not do anything fancy, but just wraps pre-existing major and minor modes with a very thin layer of functions to make them behave consistent. The mechanism is very simple, it just copy the current expression (lisps)/block (Python)/line, goes to the REPL, paste and execute, and come back, then move the cursor forward to the next expression/block/line. For installation, you can just use M-x list-packages. For configuration please refer to the github repo (http://melpa.org/#/eval-in-repl ). Just require the ones for the language you use.\neval-in-repl-ielm.el    for Emacs Lisp    (via ielm)\neval-in-repl-cider.el   for Clojure       (via cider.el)\neval-in-repl-slime.el   for SLIME         (via slime.el)\neval-in-repl-geiser.el  for Racket/Scheme (via geiser.el)\neval-in-repl-racket.el  for Racket        (via racket-mode.el)\neval-in-repl-scheme.el  for Scheme        (via scheme.el and cmuscheme.el)\neval-in-repl-python.el  for Python        (via python.el)\neval-in-repl-shell.el   for Shell         (via essh.el)\neval-in-repl-sml.el     for Standard ML   (via sml-mode.el and ess.el)\neval-in-repl-ruby.el    for Ruby          (via ruby-mode.el, inf-ruby.el, and ess.el)\neval-in-repl-ocaml.el   for OCaml         (via tuareg.el and ess.el)\neval-in-repl-hy.el      for Hy            (via hy-mode.el)\n\n\nUsing eval-in-repl.el for Clojure\nThe Clojure version utilizes the cider.el package. So you need to install it first if you have not done so. The following example was taken from the book Seven Web Frameworks in Seven Weeks, and is about SQLite interaction from Clojure REPL.\nIn the buffer on the right Clojure code exists, no REPL is running at this point. Do \"C-RET\" after the first S-expression\n\nJava VM start up takes some moments. A Clojure REPL appears on the left. cider.el tells us \"Design is about pulling things apart. -Rich Hickey\". Yes, Clojure is an opinionated language.\n\nWell, you need to move your cursor back to the code buffer (this is automatic for some other languages). Another \"C-RET\" will send the first top-level S-expression to the REPL. The S-expression evaluated to nil\n\nThe cursor goes to the point right after the next S-expression after evaluation. So multiple \"C-RET\" will send S-expressions one at a time to the REPL.\n\nLet's select the symbol \"project\" and do \"C-RET\". Oops, it has not been defined, and gave error. For good or bad, the REPL has a state, so you need to evaluate the first thing first. At around 1/3 from the top in the next picture, the evaulation result of \"project\" is shown. It looks like a Clojure hash-map. With eval-in-repl, the REPL keeps track of both code and the result, so it can be used as a simple log.\n\nYou can also select multiple top-level S-expressions and evaluate them all. Unfortunately, this is not possible with the Emacs Lisp version because IELM can only accept one S-expression at a time.\n\nFour SQL SELECT statements were sent, and 4 evaluation results returned.\n\nThe behavior when there are multiple REPL buffers open for a single language, \"C-RET\" behavior is determined by the major/minor mode for that language, as eval-in-repl is just utilizing them internally. \n\nOther languages supported (Python, Emacs Lisp, SML, shell as examples)\nHere is a screenshot of the Python version, which uses the built-in python.el as a backend. To be honest, for Python, Emacs IPython Notebook2 (EIN2; https://github.com/millejoh/emacs-ipython-notebook ) may be a better interactive computing environment.\n\nThe Emacs Lisp version connects to IELM. For lisp languages, Hy (http://docs.hylang.org/en/latest/ ) support is the latest change.\n\nThe Geiser version can run GNU Guile and Racket.\n\nVia SLIME, various Common Lisp implementations are supported.\n\nThe Standard ML version uses the sml-mode.el. I also added OCaml support recently.\n\nInteractive shell scripting is supported using essh.el as a backend. Well, there has been an effort to code Fibonacci in shell script...\n\nI'm still a novice elisper, and eval-in-repl.el is pretty rough. Your suggestions and contributions are appreciated.\nWhat is eval-in-repl.el?\n---\n\neval-in-repl.el allows a single keybinding \"C-RET\" to do REPL start up, current expression evaluation in REPL, and selected (if any) expression evaluation in REPL. It currently supports various lisp languages (Clojure, Common Lisp, Scheme, Racket, Hy, and Emacs Lisp), Python, shell, Ruby, SML, and OCaml utilizing pre-existing major and minor modes. eval-in-repl.el is available at the MELPA package repostiroy (http://melpa.org/#/eval-in-repl ). You can skip to the screen shot\n\nUpdate on 2014-12-30: Added a screencast to the github repo\nhttps://github.com/kaz-yos/eval-in-repl\nHigher quality movie on YouTube\nhttps://www.youtube.com/watch?v=gNBlF67e-0w&feature=youtu.be\n\nInfluence of ESS\n----\n\nI use emacs mainly for statistical analyses with R (http://www.r-project.org ). Emacs Speak Statistics (ESS; http://ess.r-project.org ) is my favorite emas package. Statistical analyses is inherently interactive. I constantly evaluate a small piece of code, check the results, and modify code or add code depending on the results. ESS makes REPL interaction easy by making \"C-RET\" (control+return) do everything. On the first invocation, \"C-RET\" will start up an R interpreter. From there on, \"C-RET\" will send code to the R interpreter. If there is no selection, the current line is sent. If there is a selection, the whole selected code is sent. The nice thing is that, the interpreter shows both the code evaluated and the evaluation result, so you can tell what resulted in what.\n\n\neval-in-repl.el\n----\n\nEmacs has major and minor modes to support programming in many languages. Most recent languages have REPLs. \"C-x C-r\" is usually bound to evaluate the selected region. But it may or may not work if no REPL buffer exist yet. Also evaulation may only show the result in the minibuffer transiently or show the result in the REPL buffer but without the code.\n\nI wanted an ESS-like \"C-RET\"-rules-all system for other languages with REPLs. So I wrote eval-in-repl.el(http://melpa.org/#/eval-in-repl ). I'm an elisp beginner, so this package does not do anything fancy, but just wraps pre-existing major and minor modes with a very thin layer of functions to make them behave consistent. The mechanism is very simple, it just copy the current expression (lisps)/block (Python)/line, goes to the REPL, paste and execute, and come back, then move the cursor forward to the next expression/block/line. For installation, you can just use M-x list-packages. For configuration please refer to the github repo (http://melpa.org/#/eval-in-repl ). Just require the ones for the language you use.\n\n\n```\neval-in-repl-ielm.el    for Emacs Lisp    (via ielm)\neval-in-repl-cider.el   for Clojure       (via cider.el)\neval-in-repl-slime.el   for SLIME         (via slime.el)\neval-in-repl-geiser.el  for Racket/Scheme (via geiser.el)\neval-in-repl-racket.el  for Racket        (via racket-mode.el)\neval-in-repl-scheme.el  for Scheme        (via scheme.el and cmuscheme.el)\neval-in-repl-python.el  for Python        (via python.el)\neval-in-repl-shell.el   for Shell         (via essh.el)\neval-in-repl-sml.el     for Standard ML   (via sml-mode.el and ess.el)\neval-in-repl-ruby.el    for Ruby          (via ruby-mode.el, inf-ruby.el, and ess.el)\neval-in-repl-ocaml.el   for OCaml         (via tuareg.el and ess.el)\neval-in-repl-hy.el      for Hy            (via hy-mode.el)\n```\n\n\n\nUsing eval-in-repl.el for Clojure\n----\n\nThe Clojure version utilizes the cider.el package. So you need to install it first if you have not done so. The following example was taken from the book Seven Web Frameworks in Seven Weeks, and is about SQLite interaction from Clojure REPL.\n\n\nIn the buffer on the right Clojure code exists, no REPL is running at this point. Do \"C-RET\" after the first S-expression\n\n![pic0250.png](http://f.cl.ly/items/03073M381Q1i2d0G0540/pic0250.png)\n\nJava VM start up takes some moments. A Clojure REPL appears on the left. cider.el tells us \"Design is about pulling things apart. -Rich Hickey\". Yes, Clojure is an opinionated language.\n\n![pic0305.png](http://f.cl.ly/items/2F1r0u41040F150L0U2U/pic0305.png)\n\n\nWell, you need to move your cursor back to the code buffer (this is automatic for some other languages). Another \"C-RET\" will send the first top-level S-expression to the REPL. The S-expression evaluated to nil\n\n![pic0352.png](http://f.cl.ly/items/2K2u1S2o3U1Z1n3T2L08/pic0352.png)\n\n\nThe cursor goes to the point right after the next S-expression after evaluation. So multiple \"C-RET\" will send S-expressions one at a time to the REPL.\n\n![pic0419.png](http://f.cl.ly/items/2C1u3h311I0m2G0q0M3a/pic0419.png)\n\nLet's select the symbol \"project\" and do \"C-RET\". Oops, it has not been defined, and gave error. For good or bad, the REPL has a state, so you need to evaluate the first thing first. At around 1/3 from the top in the next picture, the evaulation result of \"project\" is shown. It looks like a Clojure hash-map. With eval-in-repl, the REPL keeps track of both code and the result, so it can be used as a simple log.\n\n![pic0446.png](http://f.cl.ly/items/2w0q3a0E1A0g1g2v2F1d/pic0446.png)\n\n\nYou can also select multiple top-level S-expressions and evaluate them all. Unfortunately, this is not possible with the Emacs Lisp version because IELM can only accept one S-expression at a time.\n\n![pic0512.png](http://f.cl.ly/items/1x463a1v0s3V0N3n2G0x/pic0512.png)\n\n\nFour SQL SELECT statements were sent, and 4 evaluation results returned.\n\n![pic0522.png](http://f.cl.ly/items/030k2H2F12163m0q1C2O/pic0522.png)\n\n\nThe behavior when there are multiple REPL buffers open for a single language, \"C-RET\" behavior is determined by the major/minor mode for that language, as eval-in-repl is just utilizing them internally. \n\n\nOther languages supported (Python, Emacs Lisp, SML, shell as examples)\n---\n\nHere is a screenshot of the Python version, which uses the built-in python.el as a backend. To be honest, for Python, Emacs IPython Notebook2 (EIN2; https://github.com/millejoh/emacs-ipython-notebook ) may be a better interactive computing environment.\n\n![python.png](http://f.cl.ly/items/3h1U280T0a2n0K0W0H2a/python.png)\n\n\nThe Emacs Lisp version connects to IELM. For lisp languages, Hy (http://docs.hylang.org/en/latest/ ) support is the latest change.\n\n![elisp.png](http://f.cl.ly/items/281p1M0q2a3W0S2w3c2n/elisp.png)\n\n\nThe Geiser version can run GNU Guile and Racket.\n\n![racket.png](http://f.cl.ly/items/1o3E1l130S2t0u1m3m0p/racket.png)\n\n\nVia SLIME, various Common Lisp implementations are supported.\n\n![slime.png](http://f.cl.ly/items/2S1q423K472L0Q1h3a10/slime.png)\n\n\nThe Standard ML version uses the sml-mode.el. I also added OCaml support recently.\n\n![sml.png](http://f.cl.ly/items/042E3a0n381j1Y101E12/sml.png)\n\n\nInteractive shell scripting is supported using essh.el as a backend. Well, there has been an effort to code Fibonacci in shell script...\n\n![shell.png](http://f.cl.ly/items/0h2P151E3w0H3y0i3h3d/shell.png)\n\n\nI'm still a novice elisper, and eval-in-repl.el is pretty rough. Your suggestions and contributions are appreciated.\n", "tags": ["Emacs", "Clojure", "hy", "Python", "lisp"]}