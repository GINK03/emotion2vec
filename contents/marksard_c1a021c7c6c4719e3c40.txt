{"context": "\n\n\u524d\u7f6e\u304d\n\u3000\u3068\u3042\u308b\u30a2\u30d7\u30ea\u3092\u4f5c\u6210\u3059\u308b\u306e\u306bWin32\u30d5\u30c3\u30afDLL\u3068.Net\u306e\u30af\u30e9\u30a4\u30a2\u30f3\u30c8\u30a2\u30d7\u30ea\u9593\u3067\u30c7\u30fc\u30bf\u3092\u9023\u643a\u3055\u305b\u308b\u5fc5\u8981\u304c\u3042\u3063\u3066\u3001\u3053\u306e\u30c7\u30fc\u30bf\u9023\u643a\u306b\u30d5\u30a1\u30a4\u30eb\u30de\u30c3\u30d4\u30f3\u30b0\u3092\u63a1\u7528\u3059\u308b\u3053\u3068\u306b\u3057\u307e\u3057\u305f\u3002\n\u3000\u30cd\u30c3\u30c8\u306e\u65ad\u7247\u7684\u306a\u8cc7\u6599\u3092\u6f01\u3063\u3066\u3001\u5225\u306e\u5207\u308a\u53e3\u306e\u65ad\u7247\u7684\u306a\u60c5\u5831\u3092\u6d6e\u304b\u3079\u3088\u3046\u3068\u601d\u3044\u307e\u3059(\u3049\u3043)  \n\n\u30d5\u30a1\u30a4\u30eb\u30de\u30c3\u30d4\u30f3\u30b0\u4eca\u6614\n\u3000Win32API\u3060\u3068CreateFileMapping / OpenFileMapping\u3067\u5f97\u305f\u30cf\u30f3\u30c9\u30eb\u304b\u3089MapViewOfFile\u3092\u4f7f\u3063\u3066\u30dd\u30a4\u30f3\u30bf\u3092\u5f97\u3066\u69cb\u9020\u4f53\u306b\u30ad\u30e3\u30b9\u30c8\u3057\u3066\u4f7f\u3048\u3066\u7c21\u5358\u3067\u3059\u3002\n\u3000.Net4.0\u672a\u6e80\u306e\u5834\u5408\u306f\u305d\u308c\u3089API\u3092\u30de\u30fc\u30b7\u30e3\u30ea\u30f3\u30b0\u3059\u308b\u6240\u304b\u3089\u59cb\u3081\u308b\u30e1\u30f3\u30c9\u30af\u30b5\u30fc\u30e1\u30bd\u30c3\u30c9\u3060\u3063\u305f\u3051\u3069\u3001.Net4.0\u304b\u3089\u306fMemoryMappedFile\u3067\u591a\u5c11\u30a4\u30fc\u30b8\u30fc\u306b\u306a\u3063\u305f\u3088\u3046\u3067\u3042\u308a\u304c\u305f\u3044\u3067\u3059\u3002  \n\n\u30b5\u30f3\u30d7\u30eb\nC#\u306e\u30a2\u30d7\u30ea(WPF)\u3068C\u306e\u30a2\u30d7\u30ea(\u4eca\u56de\u306fWin32SDK\u3092\u30d9\u30bf\u3067\u4f7f\u3046\u30bf\u30a4\u30d7)\u3067\u30b5\u30f3\u30d7\u30eb\u3092\u4f5c\u3063\u305f\u3082\u306e\u3092\u629c\u7c8b\u3057\u307e\u3059\u3002  \n\nWPF\u30a2\u30d7\u30ea\nnamespace IPCwithCSandCPPSample\n{\n    /// <summary>\n    /// \u30c6\u30b9\u30c8\u30af\u30e9\u30b9\uff1a\u30d5\u30a1\u30a4\u30eb\u30de\u30c3\u30d4\u30f3\u30b0\u3078\u30de\u30c3\u30d4\u30f3\u30b0\u3059\u308b\u305f\u3081\u306e\u30af\u30e9\u30b9\n    /// C++\u5074\u3067\u95b2\u89a7\u3059\u308b\u305f\u3081\u30c7\u30fc\u30bf\u69cb\u9020\u304c\u540c\u4e00\u306b\u306a\u308b\u3088\u3046\u306b\u914d\u616e\u3059\u308b\u3053\u3068\n    /// </summary>\n    [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode, Pack = 4)]\n    public class Test1\n    {\n        public int A;\n        public bool B;\n        [MarshalAs(UnmanagedType.ByValTStr, SizeConst = 256)]\n        public string C;\n        public Test2 D = new Test2();\n    }\n\n    /// <summary>\n    /// \u30c6\u30b9\u30c8\u30af\u30e9\u30b9\uff12\n    /// </summary>\n    [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode, Pack = 4)]\n    public class Test2\n    {\n        public int AA;\n    }\n\n    /// <summary>\n    /// MainWindow.xaml \u306e\u76f8\u4e92\u4f5c\u7528\u30ed\u30b8\u30c3\u30af\n    /// </summary>\n    public partial class MainWindow : Window\n    {\n        private MemoryMappedFile mmf;\n        private MemoryMappedViewStream mmvs;\n        private Test1 testclass = new Test1();\n\n        public MainWindow()\n        {\n            InitializeComponent();\n\n            // \u983b\u7e41\u306b\u958b\u3051\u9589\u3081\u3057\u306a\u304f\u3066\u3082\u3088\u3044\u306e\u3067\u8d77\u52d5\u6642\u306b\u4f5c\u6210\n            mmf = MemoryMappedFile.CreateOrOpen(\"TestMap\", (uint)Marshal.SizeOf(typeof(Test1)));\n            mmvs = mmf.CreateViewStream();\n        }\n\n        private void Button_Click(object sender, RoutedEventArgs e)\n        {\n            // UI\u304b\u3089\u30c7\u30fc\u30bf\u3092\u53d6\u308a\u8fbc\u3080(\u53f3\u8fba\u306f\u5168\u90e8WPF\u306e\u30c6\u30ad\u30b9\u30c8\u30dc\u30c3\u30af\u30b9\u3067\u3059)\n            testclass.A = int.Parse(this.A.Text);\n            testclass.B = bool.Parse(this.B.Text);\n            testclass.C = this.C.Text;\n            testclass.D.AA = int.Parse(this.D.Text);\n\n            // \u69cb\u9020\u4f53\u306e\u4f53\u88c1\u3092\u6574\u3048\u305f\u30c7\u30fc\u30bf\u30af\u30e9\u30b9\u3092\u30d5\u30a1\u30a4\u30eb\u30de\u30c3\u30d4\u30f3\u30b0\u306e\u30b9\u30c8\u30ea\u30fc\u30e0\u306b\u6d41\u3059\u305f\u3081\u306b\u30d0\u30a4\u30c8\u5217\u306b\u5909\u63db\u3059\u308b\n            int size = Marshal.SizeOf(typeof(Test1));\n            byte[] bytes = new byte[size];\n            IntPtr ptr = Marshal.AllocCoTaskMem(size);\n            Marshal.StructureToPtr(testclass, ptr, false);\n            Marshal.Copy(ptr, bytes, 0, size);\n            Marshal.FreeCoTaskMem(ptr);\n\n            // \u30d5\u30a1\u30a4\u30eb\u30de\u30c3\u30d4\u30f3\u30b0\u306b\u66f8\u304f\n            mmvs.Write(bytes, 0, size);\n            mmvs.Seek(0, System.IO.SeekOrigin.Begin);\n        }\n    }\n}\n\n\n\nWin32API\u30a2\u30d7\u30ea\n\n/// <summary>\n/// \u30c6\u30b9\u30c8\u30af\u30e9\u30b9\uff12\n/// </summary>\ntypedef struct {\n    int AA;\n}Test2;\n\n/// <summary>\n/// \u30c6\u30b9\u30c8\u30af\u30e9\u30b9\uff1a\u30d5\u30a1\u30a4\u30eb\u30de\u30c3\u30d4\u30f3\u30b0\u3078\u30de\u30c3\u30d4\u30f3\u30b0\u3055\u308c\u3066\u3044\u308b\u30af\u30e9\u30b9\n/// </summary>\ntypedef struct {\n    int A;\n    BOOL B;\n    wchar_t C[256];\n    Test2 D;\n}Test1;\n\nHANDLE g_Handle = NULL;\nTest1 *g_pTest = NULL;\n\n/// <summary>\n/// Opens the mapping.\n/// </summary>\nvoid OpenMapping()\n{\n    if (g_Handle != NULL)\n    {\n        return;\n    }\n\n    // C#\u3067\u4f5c\u308b\u306e\u3067\u3053\u3061\u3089\u306f\u958b\u304f\u3060\u3051\n    g_Handle = OpenFileMapping(FILE_MAP_ALL_ACCESS, false, L\"TestMap\");\n    if (g_Handle == NULL)\n    {\n        return;\n    }\n\n    // \u30de\u30c3\u30d7\u30d5\u30a1\u30a4\u30eb\u306e\u30a2\u30af\u30bb\u30b9\u306f\u30ad\u30e3\u30b9\u30c8\u3057\u3066\u69cb\u9020\u4f53\u304b\u3089\u884c\u3048\u308b\n    g_pTest = (Test1*)MapViewOfFile(g_Handle, FILE_MAP_ALL_ACCESS, 0, 0, sizeof(Test1));\n    if (g_pTest == NULL)\n    {\n        CloseHandle(g_Handle);\n        return;\n    }\n}\n\n/// <summary>\n/// Closes the mapping.\n/// </summary>\nvoid CloseMapping()\n{\n    if (g_Handle == NULL)\n    {\n        return;\n    }\n\n    CloseHandle(g_Handle);\n}\n\n/// <summary>\n/// Gets the mapping structure to string.\n/// </summary>\n/// <param name=\"string\">The string.</param>\nvoid GetMappingStructToString(wchar_t * string)\n{\n    if (g_pTest == NULL)\n    {\n        return;\n    }\n\n    wsprintf(string, L\"%d %d %s %d\\n\", g_pTest->A, g_pTest->B, g_pTest->C, g_pTest->D.AA);\n}\n\n/// <summary>\n/// 200ms\u306b\u4e00\u56de\u5171\u6709\u30e1\u30e2\u30ea\u3092\u8aad\u3093\u3067\u8868\u793a\u3092\u66f4\u65b0\u3059\u308b\u3088\u30a6\u30a3\u30f3\u30c9\u30a6\n/// </summary>\nLRESULT CALLBACK WndProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)\n{\n    static int timerID;\n    static wchar_t string[256];\n\n    switch (message)\n    {\n    case WM_CREATE:\n        timerID = SetTimer(hwnd, -1, 200, NULL);\n        OpenMapping();\n        break;\n    case WM_TIMER:\n        OpenMapping();\n        GetMappingStructToString(string);\n        InvalidateRect(hwnd, NULL, true);\n        break;\n    case WM_PAINT:\n        hdc = BeginPaint(hwnd, &ps);\n        // TODO: \u63cf\u753b\u30b3\u30fc\u30c9\u3092\u3053\u3053\u306b\u8ffd\u52a0\u3057\u3066\u304f\u3060\u3055\u3044...\n        {\n            RECT temp;\n            GetClientRect(hwnd, &temp);\n            DrawText(hdc, string, lstrlen(string), &temp, DT_TOP | DT_LEFT | DT_WORDBREAK);\n        }\n        EndPaint(hwnd, &ps);\n        break;\n    case WM_DESTROY:\n        CloseMapping();\n        KillTimer(hwnd, timerID);\n        PostQuitMessage(0);\n        break;\n    default:\n        return DefWindowProc(hwnd, message, wParam, lParam);\n    }\n    return 0;\n}\n\n\n\n\u5171\u6709\u3059\u308b\u69cb\u9020\u4f53\u306b\u95a2\u3057\u3066\n\n\u30d5\u30a1\u30a4\u30eb\u30de\u30c3\u30d4\u30f3\u30b0\u306e\u4e2d\u8eab\u306f\u30d0\u30a4\u30c8\u5217\u3060\u3001\u3068\u8a00\u3046\u3053\u3068\u3092\u982d\u306b\u5165\u308c\u3066\u69cb\u9020\u4f53\u3092\u69cb\u6210\u3059\u308b\nC#\u3067\u306f\u30af\u30e9\u30b9\u3067\u3082StructLayout\u51fa\u6765\u308b\u304c\u4e0a\u8a18\u306f\u8003\u616e\u3059\u308b\u3053\u3068\n\n\u3000\u4e00\u3064\u76ee\u306f\u5f53\u7136\u306e\u3053\u3068\u3067\u3059\u306d\u3002\u30a2\u30c9\u30ec\u30b9\u6e21\u3055\u308c\u3066\u3082\u6e21\u3055\u308c\u305f\u5074\u306f\u898b\u3089\u308c\u307e\u305b\u3093\u3002\ntypedef struct {\n    int A;\n    BOOL B;\n    wchar_t C[256];\n    Test2 D;\n}Test1;\n\n\u3053\u3093\u306a\u611f\u3058\u306e\u69cb\u9020\u4f53\u306b\u3057\u305f\u5834\u5408\u306f\n[StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode, Pack = 4)]\npublic class Test1\n{\n    public int A;\n    public bool B;\n    [MarshalAs(UnmanagedType.ByValTStr, SizeConst = 256)]\n    public string C;\n    public Test2 D = new Test2();\n}\n\n\u3053\u3093\u306a\u611f\u3058\u3067\u5927\u4e08\u592b\u3002\n\n\u6ce8\u610f\u70b9\n\nC#\u306ebool\u3092StructureToPtr\u3059\u308b\u3068\u30ec\u30a4\u30a2\u30a6\u30c8\u60c5\u5831\u306bPack=1\u3068\u8a2d\u5b9a\u3057\u3066\u30824\u30d0\u30a4\u30c8\u306b\u306a\u308b\u306e\u3067\u3001C99\u306ebool\u3067\u53d7\u3051\u308b\u306a\u3089\u30a2\u30e9\u30a4\u30e1\u30f3\u30c8\u8abf\u6574\u304c\u5fc5\u8981\n\u591a\u52062\u30d0\u30a4\u30c8\u30843\u30d0\u30a4\u30c8\u3082\u5f37\u52364\u30d0\u30a4\u30c8\u30a2\u30e9\u30a4\u30e1\u30f3\u30c8\u306b\u306a\u308b\u4e88\u611f\uff08\u77e5\u3089\u3093\u3051\u3069\uff09\nCharSet = CharSet.Unicode (\u3053\u3053\u6570\u5e74\u306eWin32SDK\u30d9\u30bf\u30a2\u30d7\u30ea\u5074\u306f\u30c7\u30d5\u30a9\u3067Unicode)\n\u914d\u5217\u3001\u6587\u5b57\u5217\u306a\u3093\u304b\u306f\u4e0a\u9650\u5024\u5fc5\u9808\n\n\nC#\u5074\u306e\u66f8\u304d\u8fbc\u307f\u5074\u306e\u809d\n// \u69cb\u9020\u4f53\u306e\u4f53\u88c1\u3092\u6574\u3048\u305f\u30c7\u30fc\u30bf\u30af\u30e9\u30b9\u3092\u30d5\u30a1\u30a4\u30eb\u30de\u30c3\u30d4\u30f3\u30b0\u306e\u30b9\u30c8\u30ea\u30fc\u30e0\u306b\u6d41\u3059\u305f\u3081\u306b\u30d0\u30a4\u30c8\u5217\u306b\u5909\u63db\u3059\u308b\nint size = Marshal.SizeOf(typeof(Test1));\nbyte[] bytes = new byte[size];\nIntPtr ptr = Marshal.AllocCoTaskMem(size);\nMarshal.StructureToPtr(testclass, ptr, false);\nMarshal.Copy(ptr, bytes, 0, size);\nMarshal.FreeCoTaskMem(ptr);\n\n// \u30d5\u30a1\u30a4\u30eb\u30de\u30c3\u30d4\u30f3\u30b0\u306b\u66f8\u304f\nmmvs.Write(bytes, 0, size);\nmmvs.Seek(0, System.IO.SeekOrigin.Begin);\n\n\n\u69cb\u9020\u4f53\u2192\u30d0\u30a4\u30c8\u5217\u2192\u30b9\u30c8\u30ea\u30fc\u30e0Write \u306e\u624b\u9806\u304c\u5fc5\u8981\nMarshal.AllocCoTaskMem\u306fMarshal.AllocHGlobal\u3067\u3082\u901f\u5ea6\u7684\u306b\u306f\u3042\u307e\u308a\u5909\u5316\u304c\u306a\u3044\u6a21\u69d8\n\n\u3000mmvs.Seek(testclass.ToBytes(), 0, testclass.Length)\u3068\u51fa\u6765\u308b\u3088\u3046\u306b\u7d44\u3093\u3067\u304a\u304f\u3068\u826f\u3044\u304b\u3082\n\n\u53c2\u8003\uff1a\nC#\u3067\u30ec\u30ac\u30b7\u30fc\u306a\u4e8b\u3092\u3059\u308b\u65b9\u5411\u3051\u306e\u307e\u3068\u3081\n# \u524d\u7f6e\u304d\n\u3000\u3068\u3042\u308b\u30a2\u30d7\u30ea\u3092\u4f5c\u6210\u3059\u308b\u306e\u306bWin32\u30d5\u30c3\u30afDLL\u3068.Net\u306e\u30af\u30e9\u30a4\u30a2\u30f3\u30c8\u30a2\u30d7\u30ea\u9593\u3067\u30c7\u30fc\u30bf\u3092\u9023\u643a\u3055\u305b\u308b\u5fc5\u8981\u304c\u3042\u3063\u3066\u3001\u3053\u306e\u30c7\u30fc\u30bf\u9023\u643a\u306b\u30d5\u30a1\u30a4\u30eb\u30de\u30c3\u30d4\u30f3\u30b0\u3092\u63a1\u7528\u3059\u308b\u3053\u3068\u306b\u3057\u307e\u3057\u305f\u3002  \n\u3000\u30cd\u30c3\u30c8\u306e\u65ad\u7247\u7684\u306a\u8cc7\u6599\u3092\u6f01\u3063\u3066\u3001\u5225\u306e\u5207\u308a\u53e3\u306e\u65ad\u7247\u7684\u306a\u60c5\u5831\u3092\u6d6e\u304b\u3079\u3088\u3046\u3068\u601d\u3044\u307e\u3059(\u3049\u3043)  \n\n# \u30d5\u30a1\u30a4\u30eb\u30de\u30c3\u30d4\u30f3\u30b0\u4eca\u6614\n\u3000Win32API\u3060\u3068CreateFileMapping / OpenFileMapping\u3067\u5f97\u305f\u30cf\u30f3\u30c9\u30eb\u304b\u3089MapViewOfFile\u3092\u4f7f\u3063\u3066\u30dd\u30a4\u30f3\u30bf\u3092\u5f97\u3066\u69cb\u9020\u4f53\u306b\u30ad\u30e3\u30b9\u30c8\u3057\u3066\u4f7f\u3048\u3066\u7c21\u5358\u3067\u3059\u3002  \n\u3000.Net4.0\u672a\u6e80\u306e\u5834\u5408\u306f\u305d\u308c\u3089API\u3092\u30de\u30fc\u30b7\u30e3\u30ea\u30f3\u30b0\u3059\u308b\u6240\u304b\u3089\u59cb\u3081\u308b\u30e1\u30f3\u30c9\u30af\u30b5\u30fc\u30e1\u30bd\u30c3\u30c9\u3060\u3063\u305f\u3051\u3069\u3001.Net4.0\u304b\u3089\u306fMemoryMappedFile\u3067\u591a\u5c11\u30a4\u30fc\u30b8\u30fc\u306b\u306a\u3063\u305f\u3088\u3046\u3067\u3042\u308a\u304c\u305f\u3044\u3067\u3059\u3002  \n\n# \u30b5\u30f3\u30d7\u30eb\nC#\u306e\u30a2\u30d7\u30ea(WPF)\u3068C\u306e\u30a2\u30d7\u30ea(\u4eca\u56de\u306fWin32SDK\u3092\u30d9\u30bf\u3067\u4f7f\u3046\u30bf\u30a4\u30d7)\u3067\u30b5\u30f3\u30d7\u30eb\u3092\u4f5c\u3063\u305f\u3082\u306e\u3092\u629c\u7c8b\u3057\u307e\u3059\u3002  \n\n```csharp:WPF\u30a2\u30d7\u30ea\nnamespace IPCwithCSandCPPSample\n{\n    /// <summary>\n    /// \u30c6\u30b9\u30c8\u30af\u30e9\u30b9\uff1a\u30d5\u30a1\u30a4\u30eb\u30de\u30c3\u30d4\u30f3\u30b0\u3078\u30de\u30c3\u30d4\u30f3\u30b0\u3059\u308b\u305f\u3081\u306e\u30af\u30e9\u30b9\n    /// C++\u5074\u3067\u95b2\u89a7\u3059\u308b\u305f\u3081\u30c7\u30fc\u30bf\u69cb\u9020\u304c\u540c\u4e00\u306b\u306a\u308b\u3088\u3046\u306b\u914d\u616e\u3059\u308b\u3053\u3068\n    /// </summary>\n    [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode, Pack = 4)]\n    public class Test1\n    {\n        public int A;\n        public bool B;\n        [MarshalAs(UnmanagedType.ByValTStr, SizeConst = 256)]\n        public string C;\n        public Test2 D = new Test2();\n    }\n    \n    /// <summary>\n    /// \u30c6\u30b9\u30c8\u30af\u30e9\u30b9\uff12\n    /// </summary>\n    [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode, Pack = 4)]\n    public class Test2\n    {\n        public int AA;\n    }\n\n    /// <summary>\n    /// MainWindow.xaml \u306e\u76f8\u4e92\u4f5c\u7528\u30ed\u30b8\u30c3\u30af\n    /// </summary>\n    public partial class MainWindow : Window\n    {\n        private MemoryMappedFile mmf;\n        private MemoryMappedViewStream mmvs;\n        private Test1 testclass = new Test1();\n\n        public MainWindow()\n        {\n            InitializeComponent();\n\n            // \u983b\u7e41\u306b\u958b\u3051\u9589\u3081\u3057\u306a\u304f\u3066\u3082\u3088\u3044\u306e\u3067\u8d77\u52d5\u6642\u306b\u4f5c\u6210\n            mmf = MemoryMappedFile.CreateOrOpen(\"TestMap\", (uint)Marshal.SizeOf(typeof(Test1)));\n            mmvs = mmf.CreateViewStream();\n        }\n\n        private void Button_Click(object sender, RoutedEventArgs e)\n        {\n            // UI\u304b\u3089\u30c7\u30fc\u30bf\u3092\u53d6\u308a\u8fbc\u3080(\u53f3\u8fba\u306f\u5168\u90e8WPF\u306e\u30c6\u30ad\u30b9\u30c8\u30dc\u30c3\u30af\u30b9\u3067\u3059)\n            testclass.A = int.Parse(this.A.Text);\n            testclass.B = bool.Parse(this.B.Text);\n            testclass.C = this.C.Text;\n            testclass.D.AA = int.Parse(this.D.Text);\n\n            // \u69cb\u9020\u4f53\u306e\u4f53\u88c1\u3092\u6574\u3048\u305f\u30c7\u30fc\u30bf\u30af\u30e9\u30b9\u3092\u30d5\u30a1\u30a4\u30eb\u30de\u30c3\u30d4\u30f3\u30b0\u306e\u30b9\u30c8\u30ea\u30fc\u30e0\u306b\u6d41\u3059\u305f\u3081\u306b\u30d0\u30a4\u30c8\u5217\u306b\u5909\u63db\u3059\u308b\n            int size = Marshal.SizeOf(typeof(Test1));\n            byte[] bytes = new byte[size];\n            IntPtr ptr = Marshal.AllocCoTaskMem(size);\n            Marshal.StructureToPtr(testclass, ptr, false);\n            Marshal.Copy(ptr, bytes, 0, size);\n            Marshal.FreeCoTaskMem(ptr);\n\n            // \u30d5\u30a1\u30a4\u30eb\u30de\u30c3\u30d4\u30f3\u30b0\u306b\u66f8\u304f\n            mmvs.Write(bytes, 0, size);\n            mmvs.Seek(0, System.IO.SeekOrigin.Begin);\n        }\n    }\n}\n```\n\n```CPP:Win32API\u30a2\u30d7\u30ea\n\n/// <summary>\n/// \u30c6\u30b9\u30c8\u30af\u30e9\u30b9\uff12\n/// </summary>\ntypedef struct {\n\tint AA;\n}Test2;\n\n/// <summary>\n/// \u30c6\u30b9\u30c8\u30af\u30e9\u30b9\uff1a\u30d5\u30a1\u30a4\u30eb\u30de\u30c3\u30d4\u30f3\u30b0\u3078\u30de\u30c3\u30d4\u30f3\u30b0\u3055\u308c\u3066\u3044\u308b\u30af\u30e9\u30b9\n/// </summary>\ntypedef struct {\n\tint A;\n\tBOOL B;\n\twchar_t C[256];\n\tTest2 D;\n}Test1;\n\nHANDLE g_Handle = NULL;\nTest1 *g_pTest = NULL;\n\n/// <summary>\n/// Opens the mapping.\n/// </summary>\nvoid OpenMapping()\n{\n\tif (g_Handle != NULL)\n\t{\n\t\treturn;\n\t}\n\n\t// C#\u3067\u4f5c\u308b\u306e\u3067\u3053\u3061\u3089\u306f\u958b\u304f\u3060\u3051\n\tg_Handle = OpenFileMapping(FILE_MAP_ALL_ACCESS, false, L\"TestMap\");\n\tif (g_Handle == NULL)\n\t{\n\t\treturn;\n\t}\n\n\t// \u30de\u30c3\u30d7\u30d5\u30a1\u30a4\u30eb\u306e\u30a2\u30af\u30bb\u30b9\u306f\u30ad\u30e3\u30b9\u30c8\u3057\u3066\u69cb\u9020\u4f53\u304b\u3089\u884c\u3048\u308b\n\tg_pTest = (Test1*)MapViewOfFile(g_Handle, FILE_MAP_ALL_ACCESS, 0, 0, sizeof(Test1));\n\tif (g_pTest == NULL)\n\t{\n\t\tCloseHandle(g_Handle);\n\t\treturn;\n\t}\n}\n\n/// <summary>\n/// Closes the mapping.\n/// </summary>\nvoid CloseMapping()\n{\n\tif (g_Handle == NULL)\n\t{\n\t\treturn;\n\t}\n\n\tCloseHandle(g_Handle);\n}\n\n/// <summary>\n/// Gets the mapping structure to string.\n/// </summary>\n/// <param name=\"string\">The string.</param>\nvoid GetMappingStructToString(wchar_t * string)\n{\n\tif (g_pTest == NULL)\n\t{\n\t\treturn;\n\t}\n\n\twsprintf(string, L\"%d %d %s %d\\n\", g_pTest->A, g_pTest->B, g_pTest->C, g_pTest->D.AA);\n}\n\n/// <summary>\n/// 200ms\u306b\u4e00\u56de\u5171\u6709\u30e1\u30e2\u30ea\u3092\u8aad\u3093\u3067\u8868\u793a\u3092\u66f4\u65b0\u3059\u308b\u3088\u30a6\u30a3\u30f3\u30c9\u30a6\n/// </summary>\nLRESULT CALLBACK WndProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)\n{\n\tstatic int timerID;\n\tstatic wchar_t string[256];\n\n\tswitch (message)\n\t{\n\tcase WM_CREATE:\n\t\ttimerID = SetTimer(hwnd, -1, 200, NULL);\n\t\tOpenMapping();\n\t\tbreak;\n\tcase WM_TIMER:\n\t\tOpenMapping();\n\t\tGetMappingStructToString(string);\n\t\tInvalidateRect(hwnd, NULL, true);\n\t\tbreak;\n\tcase WM_PAINT:\n\t\thdc = BeginPaint(hwnd, &ps);\n\t\t// TODO: \u63cf\u753b\u30b3\u30fc\u30c9\u3092\u3053\u3053\u306b\u8ffd\u52a0\u3057\u3066\u304f\u3060\u3055\u3044...\n\t\t{\n\t\t\tRECT temp;\n\t\t\tGetClientRect(hwnd, &temp);\n\t\t\tDrawText(hdc, string, lstrlen(string), &temp, DT_TOP | DT_LEFT | DT_WORDBREAK);\n\t\t}\n\t\tEndPaint(hwnd, &ps);\n\t\tbreak;\n\tcase WM_DESTROY:\n\t\tCloseMapping();\n\t\tKillTimer(hwnd, timerID);\n\t\tPostQuitMessage(0);\n\t\tbreak;\n\tdefault:\n\t\treturn DefWindowProc(hwnd, message, wParam, lParam);\n\t}\n\treturn 0;\n}\n```\n\n# \u5171\u6709\u3059\u308b\u69cb\u9020\u4f53\u306b\u95a2\u3057\u3066\n- \u30d5\u30a1\u30a4\u30eb\u30de\u30c3\u30d4\u30f3\u30b0\u306e\u4e2d\u8eab\u306f\u30d0\u30a4\u30c8\u5217\u3060\u3001\u3068\u8a00\u3046\u3053\u3068\u3092\u982d\u306b\u5165\u308c\u3066\u69cb\u9020\u4f53\u3092\u69cb\u6210\u3059\u308b\n- C#\u3067\u306f\u30af\u30e9\u30b9\u3067\u3082StructLayout\u51fa\u6765\u308b\u304c\u4e0a\u8a18\u306f\u8003\u616e\u3059\u308b\u3053\u3068\n\n\u3000\u4e00\u3064\u76ee\u306f\u5f53\u7136\u306e\u3053\u3068\u3067\u3059\u306d\u3002\u30a2\u30c9\u30ec\u30b9\u6e21\u3055\u308c\u3066\u3082\u6e21\u3055\u308c\u305f\u5074\u306f\u898b\u3089\u308c\u307e\u305b\u3093\u3002\n\n```CPP\ntypedef struct {\n\tint A;\n\tBOOL B;\n\twchar_t C[256];\n\tTest2 D;\n}Test1;\n```\n\n\u3053\u3093\u306a\u611f\u3058\u306e\u69cb\u9020\u4f53\u306b\u3057\u305f\u5834\u5408\u306f\n\n```csharp\n[StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode, Pack = 4)]\npublic class Test1\n{\n\tpublic int A;\n\tpublic bool B;\n\t[MarshalAs(UnmanagedType.ByValTStr, SizeConst = 256)]\n\tpublic string C;\n\tpublic Test2 D = new Test2();\n}\n```\n\n\u3053\u3093\u306a\u611f\u3058\u3067\u5927\u4e08\u592b\u3002\n\n## \u6ce8\u610f\u70b9\n\n- C#\u306ebool\u3092StructureToPtr\u3059\u308b\u3068\u30ec\u30a4\u30a2\u30a6\u30c8\u60c5\u5831\u306bPack=1\u3068\u8a2d\u5b9a\u3057\u3066\u30824\u30d0\u30a4\u30c8\u306b\u306a\u308b\u306e\u3067\u3001C99\u306ebool\u3067\u53d7\u3051\u308b\u306a\u3089\u30a2\u30e9\u30a4\u30e1\u30f3\u30c8\u8abf\u6574\u304c\u5fc5\u8981\n- \u591a\u52062\u30d0\u30a4\u30c8\u30843\u30d0\u30a4\u30c8\u3082\u5f37\u52364\u30d0\u30a4\u30c8\u30a2\u30e9\u30a4\u30e1\u30f3\u30c8\u306b\u306a\u308b\u4e88\u611f\uff08\u77e5\u3089\u3093\u3051\u3069\uff09\n- CharSet = CharSet.Unicode (\u3053\u3053\u6570\u5e74\u306eWin32SDK\u30d9\u30bf\u30a2\u30d7\u30ea\u5074\u306f\u30c7\u30d5\u30a9\u3067Unicode)\n- \u914d\u5217\u3001\u6587\u5b57\u5217\u306a\u3093\u304b\u306f\u4e0a\u9650\u5024\u5fc5\u9808\n\n# C#\u5074\u306e\u66f8\u304d\u8fbc\u307f\u5074\u306e\u809d\n\n```csharp\n// \u69cb\u9020\u4f53\u306e\u4f53\u88c1\u3092\u6574\u3048\u305f\u30c7\u30fc\u30bf\u30af\u30e9\u30b9\u3092\u30d5\u30a1\u30a4\u30eb\u30de\u30c3\u30d4\u30f3\u30b0\u306e\u30b9\u30c8\u30ea\u30fc\u30e0\u306b\u6d41\u3059\u305f\u3081\u306b\u30d0\u30a4\u30c8\u5217\u306b\u5909\u63db\u3059\u308b\nint size = Marshal.SizeOf(typeof(Test1));\nbyte[] bytes = new byte[size];\nIntPtr ptr = Marshal.AllocCoTaskMem(size);\nMarshal.StructureToPtr(testclass, ptr, false);\nMarshal.Copy(ptr, bytes, 0, size);\nMarshal.FreeCoTaskMem(ptr);\n\n// \u30d5\u30a1\u30a4\u30eb\u30de\u30c3\u30d4\u30f3\u30b0\u306b\u66f8\u304f\nmmvs.Write(bytes, 0, size);\nmmvs.Seek(0, System.IO.SeekOrigin.Begin);\n```\n\n- \u69cb\u9020\u4f53\u2192\u30d0\u30a4\u30c8\u5217\u2192\u30b9\u30c8\u30ea\u30fc\u30e0Write \u306e\u624b\u9806\u304c\u5fc5\u8981\n- Marshal.AllocCoTaskMem\u306fMarshal.AllocHGlobal\u3067\u3082\u901f\u5ea6\u7684\u306b\u306f\u3042\u307e\u308a\u5909\u5316\u304c\u306a\u3044\u6a21\u69d8\n\n\u3000mmvs.Seek(testclass.ToBytes(), 0, testclass.Length)\u3068\u51fa\u6765\u308b\u3088\u3046\u306b\u7d44\u3093\u3067\u304a\u304f\u3068\u826f\u3044\u304b\u3082\n\n# \u53c2\u8003\uff1a\n[C#\u3067\u30ec\u30ac\u30b7\u30fc\u306a\u4e8b\u3092\u3059\u308b\u65b9\u5411\u3051\u306e\u307e\u3068\u3081]( http://qiita.com/hmuronaka/items/619f8889e36c7b5db92d)\n", "tags": ["C", "C#", "IPC", "Win32API"]}