{"tags": ["Ruby", "\u30aa\u30d6\u30b8\u30a7\u30af\u30c8\u6307\u5411", "\u30e1\u30bf\u30d7\u30ed\u30b0\u30e9\u30df\u30f3\u30b0", "\u30d7\u30ed\u30b0\u30e9\u30df\u30f3\u30b0\u4f5c\u6cd5"], "context": " \u3053\u306e\u8a18\u4e8b\u306f\u6700\u7d42\u66f4\u65b0\u65e5\u304b\u30891\u5e74\u4ee5\u4e0a\u304c\u7d4c\u904e\u3057\u3066\u3044\u307e\u3059\u3002\u52d5\u753b\nhttps://www.youtube.com/watch?v=9lv2lBq6x4A&feature=youtu.be\nmissingno15\u3055\u3093\u304c\u3053\u3061\u3089\u306b\u66f8\u3044\u305f\u30b3\u30fc\u30c9\u3092\u81ea\u5206\u306e\u30e1\u30e2\u3068\u3057\u3066\u8a18\u8ff0\uff61\nhttps://gist.github.com/missingno15/4bc7efabe7a45ff895fd\n\nrequire 'pry'\n\nclass Animal\n  DATABASE = [\n    { id: 1, name: \"Mockingbird\" },\n    { id: 2, name: \"Pheasant\" },\n    { id: 3, name: \"Duck\" },\n\n    { id: 4, name: \"Platypus\" },\n    { id: 5, name: \"Penguin\" },\n    { id: 6, name: \"Peacock\" },\n    { id: 7, name: \"Hummingbird\" },\n    { id: 8, name: \"Owl\" }\n  ]\n\n  attr_accessor :id, :name\n\n  def self.find(id)\n    target_data = DATABASE.find { |data| data[:id] == id }\n\n    if target_data\n      self.new(target_data)\n    end\n  end\n\n  def initialize(attrs)\n    @id = attrs.fetch(:id)\n    @name = attrs.fetch(:name)\n  end\nend\n\n\n# Now we have a list of ids that we want to query\n\nids = [4, 8]\n\n# Let's map this\n\nbirds = ids.map { |id| Animal.find(id) }\np birds  # => [{:id=>4, :name=>\"Platypus\"}, {:id=>8, :name=>\"Owl\"}]\n\n# Let's now add an id that doesn't exist in our database to our array of ids\n# Now when we run map on the ids, we should get nil in the resulting array\n\n\nids << 48\nbirds = ids.map { |id| Animal.find(id) }\np birds  # => [{:id=>4, :name=>\"Platypus\"}, {:id=>8, :name=>\"Owl\"}, nil]\n\n# However, let's say we don't want it to return 'nil', we want it to be \n# descriptive and return 'no animal' instead when we call #name on each object\n# With our current implementation, if you iterate through each element \n# in the array, you'll get:\n\n# birds.each { |bird| bird.name }\n# => undefined method `name' for nil:NilClass (NoMethodError)\n\n# Let's say we can't change Animal#find because it belonged to an \n# external framework so we have no control whatsoever on it\n\n# You could do something like this:\n\nbirds.each { |bird| bird ? (puts bird.name) : (puts \"no animal\") }\n\n# However, we can do better\n# Let's use the Null Object Pattern to substitute for our missing values\n\nclass MissingAnimal\n  def name\n    \"no animal\"\n  end\nend\n\nbirds = ids.map { |id| Animal.find(id) || MissingAnimal.new }\n\n# Now when when we call #name on each object\n\nbirds.each { |bird| puts bird.name }\n\n\n# #=> Platypus\n#     Owl\n#     No animal\n\n\n# However, Sandi Metz makes the point that everytime you want to do this, we will be calling on \n# twice the amount of objects. Her solution is wrapping up the Null Object into another class \n# which also handles the API of the thing that we have no control over.\n\nclass GuaranteedAnimal\n  def self.find(id)\n    Animal.find(id) || MissingAnimal.new\n  end\nend\n\n\n# Now in the rest of the areas of your app, you can now change this:\n\nbirds = ids.map { |id| Animal.find(id) || MissingAnimal.new }\n\n# to this\u2193\n\nbirds = ids.map { |id| GuaranteedAnimal.find(id) }\n\nbirds.each { |bird| puts bird.name  }\n# => Platypus\n#    Owl\n#    No animal\n\n\u52d5\u753b\nhttps://www.youtube.com/watch?v=9lv2lBq6x4A&feature=youtu.be\n\nmissingno15\u3055\u3093\u304c\u3053\u3061\u3089\u306b\u66f8\u3044\u305f\u30b3\u30fc\u30c9\u3092\u81ea\u5206\u306e\u30e1\u30e2\u3068\u3057\u3066\u8a18\u8ff0\uff61\nhttps://gist.github.com/missingno15/4bc7efabe7a45ff895fd\n\n```rb\n\nrequire 'pry'\n\nclass Animal\n  DATABASE = [\n    { id: 1, name: \"Mockingbird\" },\n    { id: 2, name: \"Pheasant\" },\n    { id: 3, name: \"Duck\" },\n\n    { id: 4, name: \"Platypus\" },\n    { id: 5, name: \"Penguin\" },\n    { id: 6, name: \"Peacock\" },\n    { id: 7, name: \"Hummingbird\" },\n    { id: 8, name: \"Owl\" }\n  ]\n \n  attr_accessor :id, :name\n  \n  def self.find(id)\n    target_data = DATABASE.find { |data| data[:id] == id }\n \n    if target_data\n      self.new(target_data)\n    end\n  end\n \n  def initialize(attrs)\n    @id = attrs.fetch(:id)\n    @name = attrs.fetch(:name)\n  end\nend\n \n \n# Now we have a list of ids that we want to query\n \nids = [4, 8]\n \n# Let's map this\n \nbirds = ids.map { |id| Animal.find(id) }\np birds  # => [{:id=>4, :name=>\"Platypus\"}, {:id=>8, :name=>\"Owl\"}]\n \n# Let's now add an id that doesn't exist in our database to our array of ids\n# Now when we run map on the ids, we should get nil in the resulting array\n \n \nids << 48\nbirds = ids.map { |id| Animal.find(id) }\np birds  # => [{:id=>4, :name=>\"Platypus\"}, {:id=>8, :name=>\"Owl\"}, nil]\n \n# However, let's say we don't want it to return 'nil', we want it to be \n# descriptive and return 'no animal' instead when we call #name on each object\n# With our current implementation, if you iterate through each element \n# in the array, you'll get:\n \n# birds.each { |bird| bird.name }\n# => undefined method `name' for nil:NilClass (NoMethodError)\n \n# Let's say we can't change Animal#find because it belonged to an \n# external framework so we have no control whatsoever on it\n \n# You could do something like this:\n \nbirds.each { |bird| bird ? (puts bird.name) : (puts \"no animal\") }\n \n# However, we can do better\n# Let's use the Null Object Pattern to substitute for our missing values\n \nclass MissingAnimal\n  def name\n    \"no animal\"\n  end\nend\n \nbirds = ids.map { |id| Animal.find(id) || MissingAnimal.new }\n \n# Now when when we call #name on each object\n \nbirds.each { |bird| puts bird.name }\n \n \n# #=> Platypus\n#     Owl\n#     No animal\n \n \n# However, Sandi Metz makes the point that everytime you want to do this, we will be calling on \n# twice the amount of objects. Her solution is wrapping up the Null Object into another class \n# which also handles the API of the thing that we have no control over.\n \nclass GuaranteedAnimal\n  def self.find(id)\n    Animal.find(id) || MissingAnimal.new\n  end\nend\n \n \n# Now in the rest of the areas of your app, you can now change this:\n \nbirds = ids.map { |id| Animal.find(id) || MissingAnimal.new }\n \n# to this\u2193\n \nbirds = ids.map { |id| GuaranteedAnimal.find(id) }\n \nbirds.each { |bird| puts bird.name  }\n# => Platypus\n#    Owl\n#    No animal\n```\n"}