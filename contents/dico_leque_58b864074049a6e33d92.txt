{"context": "Java \u306b\u306f\u5b9f\u884c\u6642\u306b\u3082\u578b\u60c5\u5831\u304c\u3042\u308b\u306e\u3067\u3001\u4e0b\u306e\u3088\u3046\u306a\u3001\u578b\u3060\u3051\u898b\u308b\u3068\u5f15\u6570\u3092\u305d\u306e\u307e\u307e\u8fd4\u3059\u3088\u3046\u306b\u898b\u305b\u304b\u3051\u3066\u3001 String \u306b\u5bfe\u3057\u3066\u306e\u307f null \u3092\u8fd4\u3059\u3088\u3046\u306a\u30e1\u30bd\u30c3\u30c9\u304c\u66f8\u3051\u308b\u3002\nclass Hoge {\n    public static <A> A foo(A x) {\n        if (x instanceof String)\n            return null;\n        return x;\n    }\n\n    public static void main(String[] args) {\n        System.out.println(foo(\"Hello\"));      // -| null\n        System.out.println(foo(42));           // -| 42\n        System.out.println(foo(new Object())); // -| java.lang.Object@15db9742\n    }\n}\n\n\u3053\u306e\u4f8b\u306b\u3064\u3044\u3066\u306f\u3001\u9759\u7684\u578b\u304b\u3089\u4e88\u60f3\u3055\u308c\u308b\u6319\u52d5\u3092\u88cf\u5207\u308b\u3088\u3046\u306a\u30d7\u30ed\u30b0\u30e9\u30e0\u304c\u66f8\u3051\u308b\u3060\u3051\u3067\u4f55\u3082\u5b09\u3057\u304f\u306a\u3044\u3051\u308c\u3069\u3001\u6642\u306b\u306f\u5b9f\u884c\u6642\u578b\u60c5\u5831\u304c\u4fbf\u5229\u306a\u5834\u5408\u3082\u3042\u308b\u3002\n\n\u578b\u3092\u8868\u3059\u5024\n\u4e16\u306e\u4e2d\u306b\u306f\u5b9f\u884c\u6642\u578b\u60c5\u5831\u306e\u3042\u308b\u30b8\u30a7\u30cd\u30ea\u30af\u30b9\u3092\u300c\u771f\u306e\u30b8\u30a7\u30cd\u30ea\u30af\u30b9\u300d\u306a\u3069\u3068\u547c\u3076\u754c\u9688\u3082\u3042\u308b\u305d\u3046\u3060\u3051\u308c\u3069\u3001 OCaml \u306f\u3001\u30b8\u30a7\u30cd\u30ea\u30af\u30b9\uff08\u30d1\u30e9\u30e1\u30c8\u30ea\u30c3\u30af\u591a\u76f8\uff09\u306b\u9650\u3089\u305a\u3001\uff08\u73fe\u5728\u306e\u51e6\u7406\u7cfb\u3067\u306f\uff09\u5b9f\u884c\u6642\u306b\u306f\u578b\u60c5\u5831\u304c\u3059\u3079\u3066\u306a\u304f\u306a\u3063\u3066\u3057\u307e\u3046\u3002\n\u3060\u304c\u3001 OCaml 4.00 \u304b\u3089\u5c0e\u5165\u3055\u308c\u305f GADT\uff08Generalized Algebraic Data Type\u3002\u4e00\u822c\u5316\u4ee3\u6570\u30c7\u30fc\u30bf\u578b\uff09\u3092\u4f7f\u3046\u3068\u5b9f\u884c\u6642\u578b\u60c5\u5831\u3092\u5b89\u5168\u306b\u8868\u73fe\u3059\u308b\u3059\u308b\u3053\u3068\u304c\u3067\u304d\u308b\u3002\n\u307e\u305a\u306f\u578b\u3092\u8868\u3059\u5024\u306e\u578b\u3092 GADT \u3067\u5b9a\u7fa9\u3059\u308b\u3002\ntype _ typ =\n  | Unit : unit typ\n  | Int : int typ\n  | Float : float typ\n  | String : string typ\n  | Pair : ('a typ * 'b typ) -> ('a * 'b) typ\n  | Arrow : ('a typ * 'b typ) -> ('a -> 'b) typ\n\na typ \u578b\u306e\u5024\u306f a \u578b\u306e\u5b9f\u884c\u6642\u578b\u60c5\u5831\u3092\u8868\u73fe\u3059\u308b\u5024\u3067\u3001\u305d\u308c\u305e\u308c\u306e\u30c7\u30fc\u30bf\u30b3\u30f3\u30b9\u30c8\u30e9\u30af\u30bf Unit, Int, ... \u304c\u305d\u308c\u305e\u308c unit \u578b\u3001 int \u578b\u3001\u2026\u2026\u306e\u578b\u60c5\u5831\u3092\u8868\u73fe\u3059\u308b\u3002\n\u3075\u3064\u3046\u306e\u4ee3\u6570\u30c7\u30fc\u30bf\u578b\uff08OCaml \u306e\u30d0\u30ea\u30a2\u30f3\u30c8\u578b\uff09\u3068\u306f\u7570\u306a\u308a\u3001\u30b3\u30f3\u30b9\u30c8\u30e9\u30af\u30bf\u3054\u3068\u306b a typ \u306e\u578b\u5909\u6570 a \u3092\u7570\u306a\u308b\u578b\u306b\u5177\u4f53\u5316\u3059\u308b\u3053\u3068\u304c\u3067\u304d\u308b\u3002\u307e\u305f\u3001 Pair \u3084 Arrow \u306f\u305d\u308c\u305e\u308c\u3001\u3042\u308b\u578b 'a, 'b \u306b\u5bfe\u3057\u3066 ('a * 'b) typ \u3084 ('a -> 'b) typ \u306e\u3088\u3046\u306b\u3001\u30b3\u30f3\u30b9\u30c8\u30e9\u30af\u30bf\u3054\u3068\u306b\u578b\u5909\u6570\u3092\u6301\u3064\u3053\u3068\u304c\u3067\u304d\u308b\u3002\n\n\u5b9f\u884c\u6642\u578b\u60c5\u5831\u3067\u5206\u5c90\u3059\u308b\n\u6b21\u306b\u3001 \u5b9f\u884c\u6642\u578b\u60c5\u5831\u3092\u4f7f\u3046\u95a2\u6570\u3092\u5b9a\u7fa9\u3059\u308b\u3002 a typ \u578b\u306e\u5024\u306f a \u578b\u306e\u5024\u306b\u6697\u9ed9\u306b\u4ed8\u52a0\u3055\u308c\u308b\u3082\u306e\u3067\u306f\u306a\u3044\u306e\u3067\u3001\u81ea\u5206\u3067\u967d\u306b\u6e21\u3057\u3066\u3084\u308b\u5fc5\u8981\u304c\u3042\u308b\u3002\nlet foo : type a. a typ -> a -> a =\n  fun ty v ->\n    match ty with\n    | Int -> 42\n    | _ -> v\n\nlet () =\n  Printf.printf \"%d\\n\" @@ foo Int 30;          (* -| 42 *)\n  Printf.printf \"%f\\n\" @@ foo Float 30.0;      (* -| 30.000000 *)\n  Printf.printf \"%s\\n\" @@ foo String \"foobar\"; (* -| foobar *)\n  ()\n\n\u95a2\u6570 foo \u306f\u3042\u308b\u578b a \u306b\u5bfe\u3057\u3066 a typ \u3067\u8868\u73fe\u3055\u308c\u308b\u578b\u60c5\u5831\u3068 a \u578b\u306e\u5024\u3092\u53d7\u3051\u53d6\u308a\u3001\u5f15\u6570\u3092\u305d\u306e\u307e\u307e\u8fd4\u3059\u3002\u305f\u3060\u3057\u3001 a = int \u306e\u5834\u5408\u306f\u5e38\u306b 42 \u3092\u8fd4\u3059\u3002\nGADT \u306f\u5225\u540d\u306b equality-qualified type \u3068\u3042\u308b\u3088\u3046\u306b\u3001\u5185\u90e8\u306b\u7b49\u5f0f\u3092\u6301\u3063\u3066\u3044\u308b\u3002 a typ \u578b\u306e\u5024\u3067\u306f\u3001 Unit \u306a\u3089 a = unit \u3060\u3057\u3001 Int \u306a\u3089 a = int \u3060\u3002 a typ \u578b\u306e\u5024\u3092\u30d1\u30bf\u30fc\u30f3\u30de\u30c3\u30c1\u3059\u308b\u3068\u3001\u3053\u306e\u7b49\u5f0f\u3067\u9759\u7684\u578b\u60c5\u5831\u304c\u8a73\u7d30\u5316\u3055\u308c\u308b\u3002\u305d\u306e\u305f\u3081\u3001\u4e0a\u306e foo \u306e | Int -> \u306e\u53f3\u5074\u3067\u306f a \u306f int \u3067\u3042\u308b\u3053\u3068\u304c\u308f\u304b\u3063\u3066\u3044\u308b\u306e\u3067\u3001 42 \u3068\u3044\u3046 int \u578b\u306e\u5024\u3092\u8fd4\u3059\u3053\u3068\u304c\u3067\u304d\u308b\uff08Java \u306e\u4f8b\u3067\u306f\u3001 x \u306e\u5b9f\u884c\u6642\u578b\u60c5\u5831\u304c String \u3067\u3042\u308b\u3053\u3068\u304c\u308f\u304b\u3063\u3066\u3082\u3001\u9759\u7684\u578b\u60c5\u5831\u306f\u5909\u5316\u3057\u306a\u3044\u306e\u3067\u3001 null \u4ee5\u5916\u306e String \u3068\u3057\u3066\u610f\u5473\u306e\u3042\u308b\u5024\u306f\u8fd4\u305b\u306a\u3044\uff08\u3068\u601d\u3046\uff09\uff09\u3002 _ -> \u306e\u65b9\u3067\u306f\u3001\u578b\u60c5\u5831\u306f\u8a73\u7d30\u5316\u3055\u308c\u305a\u3001 a \u578b\u306e\u5024\u306f\u5f15\u6570\u4ee5\u5916\u306a\u3044\u306e\u3067\u3001\u305d\u308c\u3092\u305d\u306e\u307e\u307e\u8fd4\u3059\u3053\u3068\u3057\u304b\u3067\u304d\u306a\u3044\u3002\nJava \u3067\u6697\u9ed9\u306b\u6e21\u3063\u3066\u3044\u305f\u578b\u60c5\u5831\u306f\u3001\u5f15\u6570\u3068\u3057\u3066\u967d\u306b\u6e21\u3063\u3066\u304f\u308b\u3088\u3046\u306b\u306a\u3063\u305f\u306e\u3067\u3001\u578b\u3092\u898b\u305f\u3060\u3051\u3067\u3001 foo \u306f\u5b9f\u884c\u6642\u578b\u60c5\u5831\u3092\u4f7f\u3046\u3053\u3068\u304c\u308f\u304b\u308b\u3088\u3046\u306b\u306a\u3063\u305f\u3002\nfoo \u306e\u547c\u3073\u51fa\u3057\u5074\u3067 foo Float \"a\" \u306e\u3088\u3046\u306b\u578b\u60c5\u5831\u3068\u7570\u306a\u308b\u5024\u3092\u6e21\u305d\u3046\u3068\u3057\u305f\u308a\u3001\u5b9f\u88c5\u5074\u3067\uff08\u8a73\u7d30\u5316\u3055\u308c\u305f\uff09 a \u3068\u7570\u306a\u308b\u5024\u3092\u8fd4\u305d\u3046\u3068\u3059\u308b\u3068\u3001\u578b\u691c\u67fb\u6642\u306b\u30a8\u30e9\u30fc\u306b\u306a\u308b\u3002\u307e\u305f\u3001 a typ \u578b\u306e\u30d1\u30bf\u30fc\u30f3\u30de\u30c3\u30c1\u3067\u3001\u53d6\u308a\u5f97\u308b\u5b9f\u884c\u6642\u578b\u3092\u7db2\u7f85\u3057\u3066\u3044\u306a\u3044\u3068\u30b3\u30f3\u30d1\u30a4\u30eb\u6642\u306b\u8b66\u544a\u3055\u308c\u308b\u3002\u7db2\u7f85\u7684\u306b\u5b9f\u884c\u6642\u578b\u691c\u67fb\u3059\u308b\u3053\u3068\u3092\u30b3\u30f3\u30d1\u30a4\u30eb\u6642\u306b\u5f37\u3044\u3089\u308c\u308b\u306e\u3060\uff08\uff01\uff09\u3002\n\u3082\u3046\u3072\u3068\u3064\u3001 OCaml \u3092\u4f7f\u3044\u59cb\u3081\u305f\u3068\u304d\u306b\u591a\u304f\u306e\u4eba\u304c\u60a9\u3080\u3001\u4efb\u610f\u306e\u578b\u306e\u5024\u306e\u6587\u5b57\u5217\u5316\u3082\uff08\u4e00\u5fdc\uff09\u66f8\u3051\u308b\u3002\nlet show_typ typ =\n  let rec show : type a. a typ -> bool -> string =\n    fun ty paren ->\n      let p x = if paren then Printf.sprintf \"(%s)\" x else x in\n      match ty with\n      | Unit -> \"unit\"\n      | Int -> \"int\"\n      | Float -> \"float\"\n      | String -> \"string\"\n      | Pair (ty1, ty2) ->\n          p @@ Printf.sprintf \"%s * %s\" (show ty1 true) (show ty2 true)\n      | Arrow (ty1, ty2) ->\n          p @@ Printf.sprintf \"%s -> %s\" (show ty1 true) (show ty2 false)\n  in show typ false\n\nlet rec show : type a. a typ -> a -> string =\n  fun ty v ->\n    match ty with\n    | Unit -> \"()\"\n    | Int -> string_of_int v\n    | Float -> string_of_float v\n    | String -> v\n    | Pair (ty1, ty2) ->\n        Printf.sprintf \"(%s, %s)\" (show ty1 @@ fst v) (show ty2 @@ snd v)\n    | Arrow (ty1, ty2) ->\n        Printf.sprintf \"<fun> : %s\" @@ show_typ ty\n\nlet ( %* ) x y = Pair (x, y)\n\nlet ( @-> ) x y = Arrow (x, y)\n\nlet () =\n  let f g = g 1 in\n  Printf.printf \"%s\\n\" @@ show Int 0;   (* -| 0 *)\n  Printf.printf \"%s\\n\" @@ show (Int %* String @-> Int) fst; (* -| <fun> : (int * string) -> int *)\n  Printf.printf \"%s\\n\" @@ show (Int @-> Int @-> Int) (+);   (* -| <fun> : int -> int -> int *)\n  Printf.printf \"%s\\n\" @@ show ((Int @-> Int) @-> Int) f;   (* -| <fun> : (int -> int) -> int *)\n  Printf.printf \"%s\\n\" @@ show_typ ((Int %* Int) %* Int);   (* -| (int * int) * int *)\n  Printf.printf \"%s\\n\" @@ show_typ (Int %* (Int %* Int));   (* -| int * (int * int) *)\n  ()\n\n\u578b\u60c5\u5831\u3092\u6e21\u3059\u3068\u3053\u308d\u304c\u9762\u5012\u3060\u3051\u308c\u3069\u3001\u3053\u3053\u306f\u6697\u9ed9\u306e\u5f15\u6570\u304c OCaml \u306b\u5c0e\u5165\u3055\u308c\u308b\u306e\u3092\u5f85\u3061\u305f\u3044\u3002\n\n\u52d5\u7684\u578b\u3092\u771f\u4f3c\u3059\u308b\n\u3053\u3053\u307e\u3067\u306f\u5024\u3068\u578b\u60c5\u5831\u3092\u5225\u3005\u306b\u6271\u3063\u3066\u3044\u305f\u304c\u3001 GADT \u3092\u4f7f\u3046\u3068\u3001\u52d5\u7684\u578b\u4ed8\u304d\u8a00\u8a9e\u306e\u3088\u3046\u306b\u5024\u81ea\u4f53\u306b\u578b\u60c5\u5831\u3092\u6301\u305f\u305b\u5b9f\u884c\u6642\u306b\u305d\u306e\u578b\u3067\u5206\u5c90\u3059\u308b\u3088\u3046\u306a\u30d7\u30ed\u30b0\u30e9\u30e0\u3082\u66f8\u3051\u308b\u3002\n\u307e\u305a\u306f\u578b\u306e\u7b49\u3057\u3055\u3092\u5224\u5b9a\u3059\u308b\u95a2\u6570\u3092\u5b9a\u7fa9\u3059\u308b\u3002\ntype (_, _) eq = Eq : ('a, 'a) eq\n\nlet rec eq_typ: type a b. a typ -> b typ -> (a, b) eq option =\n  fun a b ->\n    match a, b with\n    | Unit, Unit -> Some Eq\n    | Int, Int -> Some Eq\n    | Float, Float -> Some Eq\n    | String, String -> Some Eq\n    | Pair (a1, a2), Pair (b1, b2) ->\n        begin match eq_typ a1 b1, eq_typ a2 b2 with\n        | Some Eq, Some Eq -> Some Eq\n        | _ -> None\n        end\n    | Arrow (a1, a2), Arrow (b1, b2) ->\n        begin match eq_typ a1 b1, eq_typ a2 b2 with\n        | Some Eq, Some Eq -> Some Eq\n        | _ -> None\n        end\n    | _ -> None\n\n\u3053\u3053\u3067\u3001 eq_typ \u306e\u623b\u308a\u5024\u578b\u306f bool \u306b\u306f\u3067\u304d\u306a\u3044\u3002 bool \u306f\u3042\u304f\u307e\u3067\u5b9f\u884c\u6642\u306e\u771f\u507d\u3092\u8868\u3059\u5024\u3067\u3001\u578b\u306e\u7b49\u3057\u3055\u3068\u3044\u3046\u578b\u691c\u67fb\u6642\u306e\u9759\u7684\u306a\u60c5\u5831\u306f\u6301\u3063\u3066\u3044\u306a\u3044\u3002\u3075\u305f\u3064\u306e\u578b\u306e\u7b49\u3057\u3055\u3092 GADT \u306e eq \u578b\u3067\u8868\u73fe\u3057\u3001\u7b49\u3057\u3044\u5834\u5408\u306f\u305d\u308c\u3092 Some \u3067\u304f\u308b\u3093\u3067\u8fd4\u3057\u3001\u305d\u3046\u3067\u306a\u3044\u5834\u5408\u306f None \u3092\u8fd4\u3059\u3002\neq_typ \u306e\u5b9f\u88c5\u4e2d\u306b\u306f Some Eq \u304c\u8907\u6570\u73fe\u308c\u308b\u304c\u3001\u305d\u308c\u305e\u308c\u7570\u306a\u308b\u3082\u306e\u3067\u3042\u308b\u3053\u3068\u306b\u6ce8\u610f\u3002\u4f8b\u3048\u3070\u3001 | Pair (a1, a2), Pair (b1, b2) -> \u306e\u5206\u5c90\u306e | Some Eq, Some Eq -> Some Eq \u306e\u6700\u521d\u306e Some Eq \u306f\u3001\u30da\u30a2\u306e\u7b2c\u4e00\u8981\u7d20\u306e\u578b\u304c\u7b49\u3057\u3044\u3053\u3068\u3092\u8868\u308f\u3059\u5024\u3067\u3042\u308a\u3001\u3075\u305f\u3064\u76ee\u306e\u3082\u306e\u306f\u7b2c\u4e8c\u8981\u7d20\u306e\u578b\u304c\u7b49\u3057\u3044\u3053\u3068\u3092\u8868\u3059\u3002\u305d\u308c\u3089\u3092\u3082\u3068\u306b\u6700\u5f8c\u306e Some Eq \u3067\u30da\u30a2\u5168\u4f53\u306e\u578b\u304c\u7b49\u3057\u3044\u3053\u3068\u3092\u8868\u3059\u3002\u90e8\u5206\u306e eq_typ \u306e\u623b\u308a\u5024\u3092\u30d1\u30bf\u30fc\u30f3\u30de\u30c3\u30c1\u3057\u3066\u578b\u74b0\u5883\u3092\u8a73\u7d30\u5316\u3057\u3064\u3064\u3001\u8a73\u7d30\u5316\u3055\u308c\u305f\u578b\u74b0\u5883\u3067 Eq \u3092\u66f8\u304f\u3053\u3068\u3067\u3001\u5168\u4f53\u306e\u7b49\u3057\u3055\u3092\u793a\u3059\u3002\n\u3055\u3089\u306b\u3001\u5b9f\u884c\u6642\u578b\u60c5\u5831\u3068\u5024\u3092\u7d44\u306b\u3057\u305f\u5024\u3092\u5b9a\u7fa9\u3059\u308b\u3002\ntype dyn = Dyn : 'a typ * 'a -> dyn\n\nlet try_cast : type a. a typ -> dyn -> a option =\n  fun typ (Dyn (ty, v)) ->\n    match eq_typ typ ty with\n    | Some Eq -> Some v\n    | None -> None\n\ndyn \u306f\u5b58\u5728\u578b\uff08existential type\uff09\u3067\u5b9f\u969b\u306e\u578b\u3092\u96a0\u853d\u3059\u308b\u3002 'a \u306e\u90e8\u5206\u304c\u5916\u306b\u8868\u308c\u306a\u3044\u306e\u3067\u3001\u7570\u306a\u308b\u578b\u306e\u5024\u3092\u307e\u3068\u3081\u3066\u6271\u3046\u3053\u3068\u304c\u3067\u304d\u308b\u3002\ndyn \u3067\u5305\u307e\u308c\u305f\u5024\u3092\u4f7f\u3046\u306b\u306f try_cast \u3067\u9069\u5f53\u306a\u578b\u306b\u30ad\u30e3\u30b9\u30c8\u3057\u3066\u304b\u3089\u4f7f\u3046\u3002\nlet dyn_int_plus x y =\n  match try_cast Int x, try_cast Int y with\n  | Some a, Some b -> Dyn (Int, a + b)\n  | _, _ -> invalid_arg \"dyn_int_plus: arguments must be int\"\n\nOCaml \u306e\u6a19\u6e96\u30e9\u30a4\u30d6\u30e9\u30ea\u306e Marshal.from_string \u306f string -> int -> 'a \u3068\u3044\u3046\u5371\u306a\u3044\u578b\u3092\u3057\u3066\u3044\u308b\uff08\u4f8b\u3048\u3070\u3001 (int * string) \u3092 Marshal.to_string \u3057\u305f\u3082\u306e\u3092 (float * string) \u306b Marshal.from_string \u3059\u308b\u3053\u3068\u3082\u3067\u304d\u3066\u3057\u307e\u3046\uff09\u306e\u3060\u304c\u3001\u5e38\u306b dyn \u578b\u3092\u7d4c\u7531\u3059\u308b\u3053\u3068\u306b\u3059\u308c\u3070\u3001\u578b\u5b89\u5168\u306b\u30de\u30fc\u30b7\u30e3\u30ea\u30f3\u30b0\u3092\u3059\u308b\u3053\u3068\u304c\u3067\u304d\u308b\u3002\nlet marshal_to_string: type a. a typ -> a -> string =\n  fun ty v ->\n    Marshal.to_string (Dyn (ty, v)) []\n\nlet unmarshal_from_string: type a. a typ -> string -> a option =\n  fun ty s ->\n    try_cast ty @@ Marshal.from_string s 0\n\nlet () =\n  let t1 = Int %* String in\n  let t2 = Float %* String in\n  let b = marshal_to_string t1 (42, \"foo\") in\n  let pr t = function\n    | Some v -> Printf.printf \"Some %s\\n\" @@ show t v\n    | None -> print_endline \"None\"\n  in\n  pr t1 @@ unmarshal_from_string t1 b;  (* -| Some (42, foo) *)\n  pr t2 @@ unmarshal_from_string t2 b   (* -| None *)\n\n\n\u3082\u3063\u3068\u5b9f\u884c\u6642\u578b\u60c5\u5831\n\u5148\u7a0b\u306e show \u306f\u5206\u5c90\u3092\u95a2\u6570\u5185\u306b\u6301\u3063\u3066\u3044\u305f\u304c\u3001\u305d\u308c\u3092 Hashtbl.t \u306e\u3088\u3046\u306a\u30c7\u30fc\u30bf\u69cb\u9020\u5185\u306b\u6301\u3064\u3053\u3068\u3082\u3067\u304d\u308b\u3002\ntype dtyp = Dtyp : 'a typ -> dtyp\n\nlet tbl : (dtyp, dyn) Hashtbl.t = Hashtbl.create 16;;\n\n\u578b\u3068\u3057\u3066\u306f\u3001 Hashtbl.t \u306e\u30ad\u30fc\u3068\u5024\u3001\u305d\u308c\u305e\u308c\u306e\u5bfe\u5fdc\u95a2\u4fc2\u306b\u3064\u3044\u3066\u3001\u3042\u308b\u578b a \u304c\u5b58\u5728\u3057\u3066\u3001 a typ \u3068 a -> string \u306e\u7d44\u3067\u3042\u308c\u3070\u3088\u3044\u3088\u3046\u306a\u6c17\u304c\u3059\u308b\u304c\u3001 Hashtbl.t \u3067\u306f\u305d\u306e\u3088\u3046\u306a\u578b\u306e\u95a2\u4fc2\u3092\u8868\u73fe\u3059\u308b\u3053\u3068\u306f\u3067\u304d\u306a\u3044\u3002\u305d\u3082\u305d\u3082 Hashtbl.t \u306e\u5b9f\u88c5\u306f GADT \u306e\u3053\u3068\u306f\u4f55\u3082\u77e5\u3089\u306a\u3044\u3002\n\u30ad\u30fc\u306e\u65b9\u3082 'a typ \u306e\u5916\u306b\u51fa\u3066\u3044\u308b\u578b\u5909\u6570\u304c\u90aa\u9b54\u306a\u306e\u3067\u3001\u305d\u308c\u3092\u5185\u5074\u306b\u96a0\u3059 dtyp \u578b\u3092\u5b9a\u7fa9\u3059\u308b\uff08\u3082\u3063\u3068\u3088\u3044\u66f8\u304d\u65b9\u304c\u3042\u308b\uff1f \u672a\u8003\uff09\u3002\n\u30ad\u30fc\u3068\u5024\u306e\u95a2\u4fc2\u306f Hashtbl.t \u306e\u5916\u5074\u3001\u30b2\u30c3\u30bf\u30fc\u3068\u30bb\u30c3\u30bf\u30fc\u3067\u4fdd\u8a3c\u3059\u308b\u3053\u3068\u306b\u3059\u308b\u3002\u5b9f\u969b\u306b\u4f7f\u3046\u3068\u304d\u306f tbl \u3092\u96a0\u853d\u3059\u3079\u304d\u3060\u308d\u3046\u3002\nlet printer_ty x = x @-> String\n\nlet register_printer : type a. a typ -> (a -> string) -> unit =\n  fun ty printer ->\n    Hashtbl.add tbl (Dtyp ty) (Dyn (printer_ty ty, printer))\n\nlet get_printer : type a. a typ -> (a -> string) option =\n  fun ty ->\n    match Hashtbl.find tbl (Dtyp ty) with\n    | v -> try_cast (printer_ty ty) v\n    | exception Not_found -> None\n\n\n\u3055\u3089\u306b\u5148\u3078\n\u4eca\u56de\u306e\u8a71\u306f\u6982\u306d OCaml \u306e\u30ea\u30d5\u30a1\u30ec\u30f3\u30b9\u30de\u30cb\u30e5\u30a2\u30eb\u306e GADT \u306e\u7bc0\u306b\u8f09\u3063\u3066\u3044\u308b\u8a71\u3067\u3042\u308b\u3002\n\u3053\u3053\u3067\u306f\u3001 unit, int, float, string, \u5bfe\u3001\u95a2\u6570\u3068\u3044\u3063\u305f\u3001 OCaml \u3067\u6271\u3048\u308b\u578b\u306e\u3046\u3061\u306e\u3054\u304f\u4e00\u90e8\u3060\u3051\u3092\u6271\u3063\u305f\u3002\u30d0\u30ea\u30a2\u30f3\u30c8\u3084\u30ec\u30b3\u30fc\u30c9\u3001\u30aa\u30d6\u30b8\u30a7\u30af\u30c8\u3068\u3044\u3063\u305f\u3001\u3088\u308a\u591a\u304f\u306e\u578b\u3092 a typ \u65b9\u5f0f\u3067\u8868\u73fe\u3059\u308b\u65b9\u6cd5\u306f Runtime Types in OCaml \u306a\u3069\u3092\u53c2\u7167\u3002 OPAM \u306b\u767b\u9332\u3055\u308c\u3066\u3044\u308b\u5b9f\u884c\u6642\u578b\u60c5\u5831\u3092\u6271\u3046\u30e9\u30a4\u30d6\u30e9\u30ea\u306b\u306f typerep \u7b49\u304c\u3042\u308b\u3002 ppx_typerep_conv \u306f typerep \u306e\u578b\u60c5\u5831\u3092\u81ea\u52d5\u751f\u6210\u3059\u308b\u30e9\u30a4\u30d6\u30e9\u30ea\u3067\u3042\u308b\u3002\n\u307e\u305f\u3001 OCaml \u3067\u5f15\u6570\u3092\u6697\u9ed9\u306b\u6e21\u3059\u7814\u7a76\u306b\u3064\u3044\u3066\u306f Modular Implicits \u306a\u3069\u3092\u53c2\u7167\u3002\nJava \u306b\u306f\u5b9f\u884c\u6642\u306b\u3082\u578b\u60c5\u5831\u304c\u3042\u308b\u306e\u3067\u3001\u4e0b\u306e\u3088\u3046\u306a\u3001\u578b\u3060\u3051\u898b\u308b\u3068\u5f15\u6570\u3092\u305d\u306e\u307e\u307e\u8fd4\u3059\u3088\u3046\u306b\u898b\u305b\u304b\u3051\u3066\u3001 `String` \u306b\u5bfe\u3057\u3066\u306e\u307f `null` \u3092\u8fd4\u3059\u3088\u3046\u306a\u30e1\u30bd\u30c3\u30c9\u304c\u66f8\u3051\u308b\u3002\n\n```java\nclass Hoge {\n    public static <A> A foo(A x) {\n        if (x instanceof String)\n            return null;\n        return x;\n    }\n\n    public static void main(String[] args) {\n        System.out.println(foo(\"Hello\"));      // -| null\n        System.out.println(foo(42));           // -| 42\n        System.out.println(foo(new Object())); // -| java.lang.Object@15db9742\n    }\n}\n```\n\n\u3053\u306e\u4f8b\u306b\u3064\u3044\u3066\u306f\u3001\u9759\u7684\u578b\u304b\u3089\u4e88\u60f3\u3055\u308c\u308b\u6319\u52d5\u3092\u88cf\u5207\u308b\u3088\u3046\u306a\u30d7\u30ed\u30b0\u30e9\u30e0\u304c\u66f8\u3051\u308b\u3060\u3051\u3067\u4f55\u3082\u5b09\u3057\u304f\u306a\u3044\u3051\u308c\u3069\u3001\u6642\u306b\u306f\u5b9f\u884c\u6642\u578b\u60c5\u5831\u304c\u4fbf\u5229\u306a\u5834\u5408\u3082\u3042\u308b\u3002\n\n## \u578b\u3092\u8868\u3059\u5024\n\n\u4e16\u306e\u4e2d\u306b\u306f\u5b9f\u884c\u6642\u578b\u60c5\u5831\u306e\u3042\u308b\u30b8\u30a7\u30cd\u30ea\u30af\u30b9\u3092\u300c\u771f\u306e\u30b8\u30a7\u30cd\u30ea\u30af\u30b9\u300d\u306a\u3069\u3068\u547c\u3076\u754c\u9688\u3082\u3042\u308b\u305d\u3046\u3060\u3051\u308c\u3069\u3001 OCaml \u306f\u3001\u30b8\u30a7\u30cd\u30ea\u30af\u30b9\uff08\u30d1\u30e9\u30e1\u30c8\u30ea\u30c3\u30af\u591a\u76f8\uff09\u306b\u9650\u3089\u305a\u3001\uff08\u73fe\u5728\u306e\u51e6\u7406\u7cfb\u3067\u306f\uff09\u5b9f\u884c\u6642\u306b\u306f\u578b\u60c5\u5831\u304c\u3059\u3079\u3066\u306a\u304f\u306a\u3063\u3066\u3057\u307e\u3046\u3002\n\n\u3060\u304c\u3001 OCaml 4.00 \u304b\u3089\u5c0e\u5165\u3055\u308c\u305f GADT\uff08[Generalized Algebraic Data Type](https://en.wikipedia.org/wiki/Generalized_algebraic_data_type)\u3002\u4e00\u822c\u5316\u4ee3\u6570\u30c7\u30fc\u30bf\u578b\uff09\u3092\u4f7f\u3046\u3068\u5b9f\u884c\u6642\u578b\u60c5\u5831\u3092\u5b89\u5168\u306b\u8868\u73fe\u3059\u308b\u3059\u308b\u3053\u3068\u304c\u3067\u304d\u308b\u3002\n\n\u307e\u305a\u306f**\u578b\u3092\u8868\u3059\u5024**\u306e\u578b\u3092 GADT \u3067\u5b9a\u7fa9\u3059\u308b\u3002\n\n```ocaml\ntype _ typ =\n  | Unit : unit typ\n  | Int : int typ\n  | Float : float typ\n  | String : string typ\n  | Pair : ('a typ * 'b typ) -> ('a * 'b) typ\n  | Arrow : ('a typ * 'b typ) -> ('a -> 'b) typ\n```\n\n`a typ` \u578b\u306e\u5024\u306f `a` \u578b\u306e\u5b9f\u884c\u6642\u578b\u60c5\u5831\u3092\u8868\u73fe\u3059\u308b\u5024\u3067\u3001\u305d\u308c\u305e\u308c\u306e\u30c7\u30fc\u30bf\u30b3\u30f3\u30b9\u30c8\u30e9\u30af\u30bf `Unit`, `Int`, ... \u304c\u305d\u308c\u305e\u308c `unit` \u578b\u3001 `int` \u578b\u3001\u2026\u2026\u306e\u578b\u60c5\u5831\u3092\u8868\u73fe\u3059\u308b\u3002\n\n\u3075\u3064\u3046\u306e\u4ee3\u6570\u30c7\u30fc\u30bf\u578b\uff08OCaml \u306e\u30d0\u30ea\u30a2\u30f3\u30c8\u578b\uff09\u3068\u306f\u7570\u306a\u308a\u3001\u30b3\u30f3\u30b9\u30c8\u30e9\u30af\u30bf\u3054\u3068\u306b `a typ` \u306e\u578b\u5909\u6570 `a` \u3092\u7570\u306a\u308b\u578b\u306b\u5177\u4f53\u5316\u3059\u308b\u3053\u3068\u304c\u3067\u304d\u308b\u3002\u307e\u305f\u3001 `Pair` \u3084 `Arrow` \u306f\u305d\u308c\u305e\u308c\u3001\u3042\u308b\u578b `'a`, `'b` \u306b\u5bfe\u3057\u3066 `('a * 'b) typ` \u3084 `('a -> 'b) typ` \u306e\u3088\u3046\u306b\u3001\u30b3\u30f3\u30b9\u30c8\u30e9\u30af\u30bf\u3054\u3068\u306b\u578b\u5909\u6570\u3092\u6301\u3064\u3053\u3068\u304c\u3067\u304d\u308b\u3002\n\n## \u5b9f\u884c\u6642\u578b\u60c5\u5831\u3067\u5206\u5c90\u3059\u308b\n\n\u6b21\u306b\u3001 \u5b9f\u884c\u6642\u578b\u60c5\u5831\u3092\u4f7f\u3046\u95a2\u6570\u3092\u5b9a\u7fa9\u3059\u308b\u3002 `a typ` \u578b\u306e\u5024\u306f `a` \u578b\u306e\u5024\u306b\u6697\u9ed9\u306b\u4ed8\u52a0\u3055\u308c\u308b\u3082\u306e\u3067\u306f\u306a\u3044\u306e\u3067\u3001\u81ea\u5206\u3067\u967d\u306b\u6e21\u3057\u3066\u3084\u308b\u5fc5\u8981\u304c\u3042\u308b\u3002\n\n```ocaml\nlet foo : type a. a typ -> a -> a =\n  fun ty v ->\n    match ty with\n    | Int -> 42\n    | _ -> v\n\nlet () =\n  Printf.printf \"%d\\n\" @@ foo Int 30;          (* -| 42 *)\n  Printf.printf \"%f\\n\" @@ foo Float 30.0;      (* -| 30.000000 *)\n  Printf.printf \"%s\\n\" @@ foo String \"foobar\"; (* -| foobar *)\n  ()\n```\n\n\u95a2\u6570 `foo` \u306f\u3042\u308b\u578b `a` \u306b\u5bfe\u3057\u3066 `a typ` \u3067\u8868\u73fe\u3055\u308c\u308b\u578b\u60c5\u5831\u3068 `a` \u578b\u306e\u5024\u3092\u53d7\u3051\u53d6\u308a\u3001\u5f15\u6570\u3092\u305d\u306e\u307e\u307e\u8fd4\u3059\u3002\u305f\u3060\u3057\u3001 `a` = `int` \u306e\u5834\u5408\u306f\u5e38\u306b `42` \u3092\u8fd4\u3059\u3002\n\nGADT \u306f\u5225\u540d\u306b equality-qualified type \u3068\u3042\u308b\u3088\u3046\u306b\u3001\u5185\u90e8\u306b\u7b49\u5f0f\u3092\u6301\u3063\u3066\u3044\u308b\u3002 `a typ` \u578b\u306e\u5024\u3067\u306f\u3001 `Unit` \u306a\u3089 `a` = `unit` \u3060\u3057\u3001 `Int` \u306a\u3089 `a` = `int` \u3060\u3002 `a typ` \u578b\u306e\u5024\u3092\u30d1\u30bf\u30fc\u30f3\u30de\u30c3\u30c1\u3059\u308b\u3068\u3001\u3053\u306e\u7b49\u5f0f\u3067\u9759\u7684\u578b\u60c5\u5831\u304c\u8a73\u7d30\u5316\u3055\u308c\u308b\u3002\u305d\u306e\u305f\u3081\u3001\u4e0a\u306e `foo` \u306e `| Int ->` \u306e\u53f3\u5074\u3067\u306f `a` \u306f `int` \u3067\u3042\u308b\u3053\u3068\u304c\u308f\u304b\u3063\u3066\u3044\u308b\u306e\u3067\u3001 `42` \u3068\u3044\u3046 `int` \u578b\u306e\u5024\u3092\u8fd4\u3059\u3053\u3068\u304c\u3067\u304d\u308b\uff08Java \u306e\u4f8b\u3067\u306f\u3001 `x` \u306e\u5b9f\u884c\u6642\u578b\u60c5\u5831\u304c `String` \u3067\u3042\u308b\u3053\u3068\u304c\u308f\u304b\u3063\u3066\u3082\u3001\u9759\u7684\u578b\u60c5\u5831\u306f\u5909\u5316\u3057\u306a\u3044\u306e\u3067\u3001 `null` \u4ee5\u5916\u306e `String` \u3068\u3057\u3066\u610f\u5473\u306e\u3042\u308b\u5024\u306f\u8fd4\u305b\u306a\u3044\uff08\u3068\u601d\u3046\uff09\uff09\u3002 `_ ->` \u306e\u65b9\u3067\u306f\u3001\u578b\u60c5\u5831\u306f\u8a73\u7d30\u5316\u3055\u308c\u305a\u3001 `a` \u578b\u306e\u5024\u306f\u5f15\u6570\u4ee5\u5916\u306a\u3044\u306e\u3067\u3001\u305d\u308c\u3092\u305d\u306e\u307e\u307e\u8fd4\u3059\u3053\u3068\u3057\u304b\u3067\u304d\u306a\u3044\u3002\n\nJava \u3067\u6697\u9ed9\u306b\u6e21\u3063\u3066\u3044\u305f\u578b\u60c5\u5831\u306f\u3001\u5f15\u6570\u3068\u3057\u3066\u967d\u306b\u6e21\u3063\u3066\u304f\u308b\u3088\u3046\u306b\u306a\u3063\u305f\u306e\u3067\u3001\u578b\u3092\u898b\u305f\u3060\u3051\u3067\u3001 `foo` \u306f\u5b9f\u884c\u6642\u578b\u60c5\u5831\u3092\u4f7f\u3046\u3053\u3068\u304c\u308f\u304b\u308b\u3088\u3046\u306b\u306a\u3063\u305f\u3002\n\n`foo` \u306e\u547c\u3073\u51fa\u3057\u5074\u3067 `foo Float \"a\"` \u306e\u3088\u3046\u306b\u578b\u60c5\u5831\u3068\u7570\u306a\u308b\u5024\u3092\u6e21\u305d\u3046\u3068\u3057\u305f\u308a\u3001\u5b9f\u88c5\u5074\u3067\uff08\u8a73\u7d30\u5316\u3055\u308c\u305f\uff09 `a` \u3068\u7570\u306a\u308b\u5024\u3092\u8fd4\u305d\u3046\u3068\u3059\u308b\u3068\u3001\u578b\u691c\u67fb\u6642\u306b\u30a8\u30e9\u30fc\u306b\u306a\u308b\u3002\u307e\u305f\u3001 `a typ` \u578b\u306e\u30d1\u30bf\u30fc\u30f3\u30de\u30c3\u30c1\u3067\u3001\u53d6\u308a\u5f97\u308b\u5b9f\u884c\u6642\u578b\u3092\u7db2\u7f85\u3057\u3066\u3044\u306a\u3044\u3068\u30b3\u30f3\u30d1\u30a4\u30eb\u6642\u306b\u8b66\u544a\u3055\u308c\u308b\u3002\u7db2\u7f85\u7684\u306b\u5b9f\u884c\u6642\u578b\u691c\u67fb\u3059\u308b\u3053\u3068\u3092\u30b3\u30f3\u30d1\u30a4\u30eb\u6642\u306b\u5f37\u3044\u3089\u308c\u308b\u306e\u3060\uff08\uff01\uff09\u3002\n\n\u3082\u3046\u3072\u3068\u3064\u3001 OCaml \u3092\u4f7f\u3044\u59cb\u3081\u305f\u3068\u304d\u306b\u591a\u304f\u306e\u4eba\u304c\u60a9\u3080\u3001\u4efb\u610f\u306e\u578b\u306e\u5024\u306e\u6587\u5b57\u5217\u5316\u3082\uff08\u4e00\u5fdc\uff09\u66f8\u3051\u308b\u3002\n\n```ocaml\nlet show_typ typ =\n  let rec show : type a. a typ -> bool -> string =\n    fun ty paren ->\n      let p x = if paren then Printf.sprintf \"(%s)\" x else x in\n      match ty with\n      | Unit -> \"unit\"\n      | Int -> \"int\"\n      | Float -> \"float\"\n      | String -> \"string\"\n      | Pair (ty1, ty2) ->\n          p @@ Printf.sprintf \"%s * %s\" (show ty1 true) (show ty2 true)\n      | Arrow (ty1, ty2) ->\n          p @@ Printf.sprintf \"%s -> %s\" (show ty1 true) (show ty2 false)\n  in show typ false\n\nlet rec show : type a. a typ -> a -> string =\n  fun ty v ->\n    match ty with\n    | Unit -> \"()\"\n    | Int -> string_of_int v\n    | Float -> string_of_float v\n    | String -> v\n    | Pair (ty1, ty2) ->\n        Printf.sprintf \"(%s, %s)\" (show ty1 @@ fst v) (show ty2 @@ snd v)\n    | Arrow (ty1, ty2) ->\n        Printf.sprintf \"<fun> : %s\" @@ show_typ ty\n\nlet ( %* ) x y = Pair (x, y)\n\nlet ( @-> ) x y = Arrow (x, y)\n\nlet () =\n  let f g = g 1 in\n  Printf.printf \"%s\\n\" @@ show Int 0;   (* -| 0 *)\n  Printf.printf \"%s\\n\" @@ show (Int %* String @-> Int) fst; (* -| <fun> : (int * string) -> int *)\n  Printf.printf \"%s\\n\" @@ show (Int @-> Int @-> Int) (+);   (* -| <fun> : int -> int -> int *)\n  Printf.printf \"%s\\n\" @@ show ((Int @-> Int) @-> Int) f;   (* -| <fun> : (int -> int) -> int *)\n  Printf.printf \"%s\\n\" @@ show_typ ((Int %* Int) %* Int);   (* -| (int * int) * int *)\n  Printf.printf \"%s\\n\" @@ show_typ (Int %* (Int %* Int));   (* -| int * (int * int) *)\n  ()\n```\n\n\u578b\u60c5\u5831\u3092\u6e21\u3059\u3068\u3053\u308d\u304c\u9762\u5012\u3060\u3051\u308c\u3069\u3001\u3053\u3053\u306f\u6697\u9ed9\u306e\u5f15\u6570\u304c OCaml \u306b\u5c0e\u5165\u3055\u308c\u308b\u306e\u3092\u5f85\u3061\u305f\u3044\u3002\n\n## \u52d5\u7684\u578b\u3092\u771f\u4f3c\u3059\u308b\n\n\u3053\u3053\u307e\u3067\u306f\u5024\u3068\u578b\u60c5\u5831\u3092\u5225\u3005\u306b\u6271\u3063\u3066\u3044\u305f\u304c\u3001 GADT \u3092\u4f7f\u3046\u3068\u3001\u52d5\u7684\u578b\u4ed8\u304d\u8a00\u8a9e\u306e\u3088\u3046\u306b\u5024\u81ea\u4f53\u306b\u578b\u60c5\u5831\u3092\u6301\u305f\u305b\u5b9f\u884c\u6642\u306b\u305d\u306e\u578b\u3067\u5206\u5c90\u3059\u308b\u3088\u3046\u306a\u30d7\u30ed\u30b0\u30e9\u30e0\u3082\u66f8\u3051\u308b\u3002\n\n\u307e\u305a\u306f\u578b\u306e\u7b49\u3057\u3055\u3092\u5224\u5b9a\u3059\u308b\u95a2\u6570\u3092\u5b9a\u7fa9\u3059\u308b\u3002\n\n```ocaml\ntype (_, _) eq = Eq : ('a, 'a) eq\n\nlet rec eq_typ: type a b. a typ -> b typ -> (a, b) eq option =\n  fun a b ->\n    match a, b with\n    | Unit, Unit -> Some Eq\n    | Int, Int -> Some Eq\n    | Float, Float -> Some Eq\n    | String, String -> Some Eq\n    | Pair (a1, a2), Pair (b1, b2) ->\n        begin match eq_typ a1 b1, eq_typ a2 b2 with\n        | Some Eq, Some Eq -> Some Eq\n        | _ -> None\n        end\n    | Arrow (a1, a2), Arrow (b1, b2) ->\n        begin match eq_typ a1 b1, eq_typ a2 b2 with\n        | Some Eq, Some Eq -> Some Eq\n        | _ -> None\n        end\n    | _ -> None\n```\n\n\u3053\u3053\u3067\u3001 `eq_typ` \u306e\u623b\u308a\u5024\u578b\u306f `bool` \u306b\u306f\u3067\u304d**\u306a\u3044**\u3002 `bool` \u306f\u3042\u304f\u307e\u3067\u5b9f\u884c\u6642\u306e\u771f\u507d\u3092\u8868\u3059\u5024\u3067\u3001\u578b\u306e\u7b49\u3057\u3055\u3068\u3044\u3046\u578b\u691c\u67fb\u6642\u306e\u9759\u7684\u306a\u60c5\u5831\u306f\u6301\u3063\u3066\u3044\u306a\u3044\u3002\u3075\u305f\u3064\u306e\u578b\u306e\u7b49\u3057\u3055\u3092 GADT \u306e `eq` \u578b\u3067\u8868\u73fe\u3057\u3001\u7b49\u3057\u3044\u5834\u5408\u306f\u305d\u308c\u3092 `Some` \u3067\u304f\u308b\u3093\u3067\u8fd4\u3057\u3001\u305d\u3046\u3067\u306a\u3044\u5834\u5408\u306f `None` \u3092\u8fd4\u3059\u3002\n\n`eq_typ` \u306e\u5b9f\u88c5\u4e2d\u306b\u306f `Some Eq` \u304c\u8907\u6570\u73fe\u308c\u308b\u304c\u3001\u305d\u308c\u305e\u308c\u7570\u306a\u308b\u3082\u306e\u3067\u3042\u308b\u3053\u3068\u306b\u6ce8\u610f\u3002\u4f8b\u3048\u3070\u3001 `| Pair (a1, a2), Pair (b1, b2) ->` \u306e\u5206\u5c90\u306e `| Some Eq, Some Eq -> Some Eq` \u306e\u6700\u521d\u306e `Some Eq` \u306f\u3001\u30da\u30a2\u306e\u7b2c\u4e00\u8981\u7d20\u306e\u578b\u304c\u7b49\u3057\u3044\u3053\u3068\u3092\u8868\u308f\u3059\u5024\u3067\u3042\u308a\u3001\u3075\u305f\u3064\u76ee\u306e\u3082\u306e\u306f\u7b2c\u4e8c\u8981\u7d20\u306e\u578b\u304c\u7b49\u3057\u3044\u3053\u3068\u3092\u8868\u3059\u3002\u305d\u308c\u3089\u3092\u3082\u3068\u306b\u6700\u5f8c\u306e `Some Eq` \u3067\u30da\u30a2\u5168\u4f53\u306e\u578b\u304c\u7b49\u3057\u3044\u3053\u3068\u3092\u8868\u3059\u3002\u90e8\u5206\u306e `eq_typ` \u306e\u623b\u308a\u5024\u3092\u30d1\u30bf\u30fc\u30f3\u30de\u30c3\u30c1\u3057\u3066\u578b\u74b0\u5883\u3092\u8a73\u7d30\u5316\u3057\u3064\u3064\u3001\u8a73\u7d30\u5316\u3055\u308c\u305f\u578b\u74b0\u5883\u3067 `Eq` \u3092\u66f8\u304f\u3053\u3068\u3067\u3001\u5168\u4f53\u306e\u7b49\u3057\u3055\u3092\u793a\u3059\u3002\n\n\u3055\u3089\u306b\u3001\u5b9f\u884c\u6642\u578b\u60c5\u5831\u3068\u5024\u3092\u7d44\u306b\u3057\u305f\u5024\u3092\u5b9a\u7fa9\u3059\u308b\u3002\n\n```ocaml\ntype dyn = Dyn : 'a typ * 'a -> dyn\n\nlet try_cast : type a. a typ -> dyn -> a option =\n  fun typ (Dyn (ty, v)) ->\n    match eq_typ typ ty with\n    | Some Eq -> Some v\n    | None -> None\n```\n\n`dyn` \u306f\u5b58\u5728\u578b\uff08existential type\uff09\u3067\u5b9f\u969b\u306e\u578b\u3092\u96a0\u853d\u3059\u308b\u3002 `'a` \u306e\u90e8\u5206\u304c\u5916\u306b\u8868\u308c\u306a\u3044\u306e\u3067\u3001\u7570\u306a\u308b\u578b\u306e\u5024\u3092\u307e\u3068\u3081\u3066\u6271\u3046\u3053\u3068\u304c\u3067\u304d\u308b\u3002\n\n`dyn` \u3067\u5305\u307e\u308c\u305f\u5024\u3092\u4f7f\u3046\u306b\u306f `try_cast` \u3067\u9069\u5f53\u306a\u578b\u306b\u30ad\u30e3\u30b9\u30c8\u3057\u3066\u304b\u3089\u4f7f\u3046\u3002\n\n```ocaml\nlet dyn_int_plus x y =\n  match try_cast Int x, try_cast Int y with\n  | Some a, Some b -> Dyn (Int, a + b)\n  | _, _ -> invalid_arg \"dyn_int_plus: arguments must be int\"\n```\n\nOCaml \u306e\u6a19\u6e96\u30e9\u30a4\u30d6\u30e9\u30ea\u306e [`Marshal.from_string`](http://caml.inria.fr/pub/docs/manual-ocaml/libref/Marshal.html#VALfrom_string) \u306f `string -> int -> 'a` \u3068\u3044\u3046\u5371\u306a\u3044\u578b\u3092\u3057\u3066\u3044\u308b\uff08\u4f8b\u3048\u3070\u3001 `(int * string)` \u3092 `Marshal.to_string` \u3057\u305f\u3082\u306e\u3092 `(float * string)` \u306b `Marshal.from_string` \u3059\u308b\u3053\u3068\u3082\u3067\u304d\u3066\u3057\u307e\u3046\uff09\u306e\u3060\u304c\u3001\u5e38\u306b `dyn` \u578b\u3092\u7d4c\u7531\u3059\u308b\u3053\u3068\u306b\u3059\u308c\u3070\u3001\u578b\u5b89\u5168\u306b\u30de\u30fc\u30b7\u30e3\u30ea\u30f3\u30b0\u3092\u3059\u308b\u3053\u3068\u304c\u3067\u304d\u308b\u3002\n\n```ocaml\nlet marshal_to_string: type a. a typ -> a -> string =\n  fun ty v ->\n    Marshal.to_string (Dyn (ty, v)) []\n\nlet unmarshal_from_string: type a. a typ -> string -> a option =\n  fun ty s ->\n    try_cast ty @@ Marshal.from_string s 0\n\nlet () =\n  let t1 = Int %* String in\n  let t2 = Float %* String in\n  let b = marshal_to_string t1 (42, \"foo\") in\n  let pr t = function\n    | Some v -> Printf.printf \"Some %s\\n\" @@ show t v\n    | None -> print_endline \"None\"\n  in\n  pr t1 @@ unmarshal_from_string t1 b;  (* -| Some (42, foo) *)\n  pr t2 @@ unmarshal_from_string t2 b   (* -| None *)\n```\n\n## \u3082\u3063\u3068\u5b9f\u884c\u6642\u578b\u60c5\u5831\n\n\u5148\u7a0b\u306e `show` \u306f\u5206\u5c90\u3092\u95a2\u6570\u5185\u306b\u6301\u3063\u3066\u3044\u305f\u304c\u3001\u305d\u308c\u3092 [`Hashtbl.t`](http://caml.inria.fr/pub/docs/manual-ocaml/libref/Hashtbl.html#TYPEt) \u306e\u3088\u3046\u306a\u30c7\u30fc\u30bf\u69cb\u9020\u5185\u306b\u6301\u3064\u3053\u3068\u3082\u3067\u304d\u308b\u3002\n\n```ocaml\ntype dtyp = Dtyp : 'a typ -> dtyp\n\nlet tbl : (dtyp, dyn) Hashtbl.t = Hashtbl.create 16;;\n```\n\n\u578b\u3068\u3057\u3066\u306f\u3001 `Hashtbl.t` \u306e\u30ad\u30fc\u3068\u5024\u3001\u305d\u308c\u305e\u308c\u306e\u5bfe\u5fdc\u95a2\u4fc2\u306b\u3064\u3044\u3066\u3001\u3042\u308b\u578b `a` \u304c\u5b58\u5728\u3057\u3066\u3001 `a typ` \u3068 `a -> string` \u306e\u7d44\u3067\u3042\u308c\u3070\u3088\u3044\u3088\u3046\u306a\u6c17\u304c\u3059\u308b\u304c\u3001 `Hashtbl.t` \u3067\u306f\u305d\u306e\u3088\u3046\u306a\u578b\u306e\u95a2\u4fc2\u3092\u8868\u73fe\u3059\u308b\u3053\u3068\u306f\u3067\u304d\u306a\u3044\u3002\u305d\u3082\u305d\u3082 `Hashtbl.t` \u306e\u5b9f\u88c5\u306f GADT \u306e\u3053\u3068\u306f\u4f55\u3082\u77e5\u3089\u306a\u3044\u3002\n\n\u30ad\u30fc\u306e\u65b9\u3082 `'a typ` \u306e\u5916\u306b\u51fa\u3066\u3044\u308b\u578b\u5909\u6570\u304c\u90aa\u9b54\u306a\u306e\u3067\u3001\u305d\u308c\u3092\u5185\u5074\u306b\u96a0\u3059 `dtyp` \u578b\u3092\u5b9a\u7fa9\u3059\u308b\uff08\u3082\u3063\u3068\u3088\u3044\u66f8\u304d\u65b9\u304c\u3042\u308b\uff1f \u672a\u8003\uff09\u3002\n\n\u30ad\u30fc\u3068\u5024\u306e\u95a2\u4fc2\u306f `Hashtbl.t` \u306e\u5916\u5074\u3001\u30b2\u30c3\u30bf\u30fc\u3068\u30bb\u30c3\u30bf\u30fc\u3067\u4fdd\u8a3c\u3059\u308b\u3053\u3068\u306b\u3059\u308b\u3002\u5b9f\u969b\u306b\u4f7f\u3046\u3068\u304d\u306f `tbl` \u3092\u96a0\u853d\u3059\u3079\u304d\u3060\u308d\u3046\u3002\n\n```ocaml\nlet printer_ty x = x @-> String\n\nlet register_printer : type a. a typ -> (a -> string) -> unit =\n  fun ty printer ->\n    Hashtbl.add tbl (Dtyp ty) (Dyn (printer_ty ty, printer))\n\nlet get_printer : type a. a typ -> (a -> string) option =\n  fun ty ->\n    match Hashtbl.find tbl (Dtyp ty) with\n    | v -> try_cast (printer_ty ty) v\n    | exception Not_found -> None\n```\n\n## \u3055\u3089\u306b\u5148\u3078\n\n\u4eca\u56de\u306e\u8a71\u306f\u6982\u306d [OCaml \u306e\u30ea\u30d5\u30a1\u30ec\u30f3\u30b9\u30de\u30cb\u30e5\u30a2\u30eb](http://caml.inria.fr/pub/docs/manual-ocaml/)\u306e GADT \u306e\u7bc0\u306b\u8f09\u3063\u3066\u3044\u308b\u8a71\u3067\u3042\u308b\u3002\n\n\u3053\u3053\u3067\u306f\u3001 `unit`, `int`, `float`, `string`, \u5bfe\u3001\u95a2\u6570\u3068\u3044\u3063\u305f\u3001 OCaml \u3067\u6271\u3048\u308b\u578b\u306e\u3046\u3061\u306e\u3054\u304f\u4e00\u90e8\u3060\u3051\u3092\u6271\u3063\u305f\u3002\u30d0\u30ea\u30a2\u30f3\u30c8\u3084\u30ec\u30b3\u30fc\u30c9\u3001\u30aa\u30d6\u30b8\u30a7\u30af\u30c8\u3068\u3044\u3063\u305f\u3001\u3088\u308a\u591a\u304f\u306e\u578b\u3092 `a typ` \u65b9\u5f0f\u3067\u8868\u73fe\u3059\u308b\u65b9\u6cd5\u306f [Runtime Types in OCaml](https://www.lexifi.com/files/resources/runtime_types.pdf) \u306a\u3069\u3092\u53c2\u7167\u3002 [OPAM](http://opam.ocaml.org/) \u306b\u767b\u9332\u3055\u308c\u3066\u3044\u308b\u5b9f\u884c\u6642\u578b\u60c5\u5831\u3092\u6271\u3046\u30e9\u30a4\u30d6\u30e9\u30ea\u306b\u306f [typerep](https://github.com/janestreet/typerep) \u7b49\u304c\u3042\u308b\u3002 [ppx_typerep_conv](https://github.com/janestreet/ppx_typerep_conv) \u306f typerep \u306e\u578b\u60c5\u5831\u3092\u81ea\u52d5\u751f\u6210\u3059\u308b\u30e9\u30a4\u30d6\u30e9\u30ea\u3067\u3042\u308b\u3002\n\n\u307e\u305f\u3001 OCaml \u3067\u5f15\u6570\u3092\u6697\u9ed9\u306b\u6e21\u3059\u7814\u7a76\u306b\u3064\u3044\u3066\u306f Modular Implicits \u306a\u3069\u3092\u53c2\u7167\u3002\n", "tags": ["OCaml", "GADT", "GADTs"]}