{"context": "For a long time now, I've had this problem that I haven't liked any media players on Android for listening to long files, especially podcasts. While many media players come with a 30-second rewind, they don't give me the level of control I want, which is to be able to skip forward 30 seconds and move around in 5-10 second intervals. Well, what can you do, right?\nI had in mind to either do this with React Native and Web. Well, considering I only need to pick a single file, control playback, and target my own Android devices (which are all > 4.4), this wasn't that hard of a decision. This also saved me the trouble of trying to get this published.\nI picked Halogen since the way it handles effects in response to queries makes it quite easy for me to do everything I need.\n\nBuilding our app\n\nTypes\nOne thing I found out I needed was ObjectURL hashes, since security features mandate that a cilent's actual filepath to a file is not allowed to be shown. So I made a newtype for that.\nnewtype ObjectURL = ObjectURL String\nderive instance newtypeFilePath :: Newtype ObjectURL _\n\nThe derived Newtype instance lets me use some other nice functions to allow functions to be applied \"over\" my newtype. We'll come back to this later.\nThe actual application state that I care about is only whether or not I have a file to work with, as the actual running state of the audio element is something I really don't want to carry around. This makes for some boring state though.\ntype State =\n  { file :: Maybe ObjectURL\n  }\n\nNext, I need my actual Query data type that I'll be using with Halogen. This isn't too sophisticated either:\ndata Query a\n  = FileSet a\n  | Skip SkipDir SkipSize a\n\ndata SkipDir = Bck | Fwd\ndata SkipSize = Sm | Md | Lg\n\nWhen the file is set, I'll be just triggering the action to actually get the file hash to set it.\nWith the skip, I wanted to make sure a given button has what direction and size of skip defined to emit, so that I can use that to make the effects as needed.\nFinally, I have the type of effects that will run in my Halogen component as an Aff:\ntype AppEffects eff =\n  Aff\n  ( console :: CONSOLE\n  , dom :: DOM\n  | eff)\n\n\nComponent definition\nAs our application only needs to be a simple single component, there are features of Halogen we won't be using here (and that's a good thing!), and our ui definition looks simple enough:\nimport Halogen as H\nimport Halogen.HTML as HH\n\nui :: forall eff. H.Component HH.HTML Query Unit Void (AppEffects eff)\nui =\n  H.component\n    { initialState: const initialState\n    , render\n    , eval\n    , receiver: const Nothing\n    }\n  where\n    -- [...]\n\nThe Halogen Component definition has a ton of type variables, but there are only three we are actually using here.\n\nThe first, the type of what we're rendering, which will be HTML.\nThe second, the query algebra, which is the query data type with a parameter we defined earlier.\nThe last (fifth), the monad used for our effects, which is the AppEffects Aff we defined earlier.\n\nThe other two are for input and output that are used for parent-child communication that we won't be using here.\nThe actual spec passed to component seems simple enough: a record with initialState being a function for state using the Unit input we specified, a render function, and eval function, and a receiver function that we don't use here. In the where block, we define what we use here:\n\ninitialState\ninitialState =\n  { file: Nothing\n  }\n\nUnsurprisingly, we have nothing for the file at the start.\n\nrender\nimport Halogen as H\nimport Halogen.Aff as HA\nimport Halogen.HTML as HH\nimport Halogen.HTML.Events as HE\nimport Halogen.HTML.Properties as HP\n\nrender :: State -> H.ComponentHTML Query\nrender state =\n  HH.div\n    [ HP.class_ $ wrap \"container\" ]\n    [ HH.div\n      [ HP.class_ $ wrap \"root\" ]\n      [ HH.h1_ [HH.text \"glorious web audio thing\"]\n      , HH.div_\n          [ HH.input\n            [ HP.ref $ wrap \"input\"\n            , HP.type_ HP.InputFile\n            , HP.prop (wrap \"accept\")  \"audio/*\"\n            , HE.onChange (HE.input_ FileSet)\n            ]\n          ]\n      , HH.div_\n          [ HH.audio\n            [ HP.ref $ wrap \"audio\"\n            , HP.src $ unwrap $ fromMaybe (wrap \"\") state.file\n            , HP.controls true\n            , HP.autoplay true\n            ]\n          []\n        ]\n      , HH.div\n          [ HP.class_ $ wrap \"buttons\" ]\n          [ HH.button [HE.onClick (HE.input_ $ Skip Bck Lg)] [HH.text \"<<<\"]\n          , HH.button [HE.onClick (HE.input_ $ Skip Bck Md)] [HH.text \"<<\"]\n          , HH.button [HE.onClick (HE.input_ $ Skip Bck Sm)] [HH.text \"<\"]\n          , HH.button [HE.onClick (HE.input_ $ Skip Fwd Sm)] [HH.text \">\"]\n          , HH.button [HE.onClick (HE.input_ $ Skip Fwd Md)] [HH.text \">>\"]\n          , HH.button [HE.onClick (HE.input_ $ Skip Fwd Lg)] [HH.text \">>>\"]\n          ]\n      ]\n  ]\n\nNot much is involved here either, but we should keep note of a few things:\n[ HH.input\n  [ HP.ref $ wrap \"input\"\n  , HP.type_ HP.InputFile\n  , HP.prop (wrap \"accept\")  \"audio/*\"\n  , HE.onChange (HE.input_ FileSet)\n  ]\n]\n\nThe onchange handler here is set using a HE.input_ function, which will simply return the query FileSet to our eval function. Likewise is done for the skip buttons.\n\neval\neval :: Query ~> H.ComponentDSL State Query Void (AppEffects eff)\n\nThis is where the meat and bones of our app lives. Let's first see how we handle FileSet:\n\nFileSet\neval (FileSet next) = do\n  input <- H.getHTMLElementRef $ wrap \"input\"\n  case input >>= fromHTMLElement of\n    Just el -> do\n      nxs <- H.liftEff <<< files $ el\n      case toMaybe nxs >>= toMaybe <<< item 0 of\n        Just file -> do\n          url <- H.liftEff $ url =<< window\n          blob <- H.liftEff $ createObjectURL file url\n          prevBlob <- H.gets _.file\n          case prevBlob of\n            Just x ->\n              H.liftEff $ revokeObjectURL (unwrap x) url\n            _ -> pure unit\n          H.modify \\s ->\n            s {file = Just <<< wrap $ blob}\n        _ -> H.liftAff $ log \"No file found\"\n    _ -> H.liftAff $ log \"No input ref found\"\n  pure next\n\nFirst, we use the ref \"input\" from earlier to get our element. We then transform it using fromHTMLElement into the file input type that we will be using, where if the element parses correctly, then we can continue. Otherwise, nothing is done.\nNote that we use liftEff to \"transform\" our Eff actions into our Halogen component context.\nOnce the element has been found and typed, we then use its files property to get the first item. We can't use the value due to how the file input is designed. We then take the window.URL property to use URL.createObjectURL to get the ObjectURL we need.\nOnce we have our ObjectURL, we make sure to revoke the previous ObjectURL so that the browser is explicitly told to remove handlers to the file, and then modify our state to set the file.\nThis will load up our file to our audio element, allowing it to be played. Let's now look at how skipping is done:\n\nSkip\neval (Skip dir size next) = do\n  audio <- H.getHTMLElementRef $ wrap \"audio\"\n  case audio >>= fromHTMLElement of\n    Just el -> do\n      let el' = htmlAudioElementToHTMLMediaElement el\n      current <- H.liftEff $ currentTime el'\n      H.liftEff $ setCurrentTime (current + delta) el'\n    _ -> H.liftAff $ log \"No audio ref found\"\n  pure next\n  where\n    skip = case size of\n      Lg -> 30.0\n      Md -> 10.0\n      Sm -> 5.0\n    delta = skip * case dir of\n      Bck -> -1.0\n      _ -> 1.0\n\nWe grab the \"audio\" ref to get the element and attempt to type it as above. When we have our audio element, we then convert it to a media element to control it as such.\nUsing the size and direction, we are able to compute the delta we want, and we then grab the current time of the control, apply our delta, and set the current time of the audio element to the result. That's about it!\n\nmain\nimport Halogen.Aff as HA\nimport Halogen.VDom.Driver as D\n\nmain = HA.runHalogenAff do\n  body <- HA.awaitBody\n  io <- D.runUI ui unit body\n\n  log \"Running\"\n\nWe use Halogen's runHalogenAff utility to run our Aff, which consists of waiting for the body and running our UI using our ui.\n\nsw.js and offline\nTo use offline capabilities, we need to register a service worker and have a manifest file. It ends up being not much more than just some boilerplate:\n<!--in head-->\n<link rel=\"manifest\" href=\"manifest.json\">\n\n<script>\nif('serviceWorker' in navigator) {\n  navigator.serviceWorker\n    .register('sw.js')\n    .then(function() { console.log(\"Service Worker Registered\"); });\n}\n</script>\n\n{\n  \"name\": \"My Web Audio Player\",\n  \"short_name\": \"WebAudio\",\n  \"icons\": [{\n    \"src\": \"icon-256x256.png\",\n    \"sizes\": \"256x256\",\n    \"type\": \"image/png\"\n  }],\n  \"start_url\": \"/purescript-web-audio-player-demo/index.html\",\n  \"display\": \"standalone\",\n  \"orientation\": \"portrait\",\n  \"background_color\": \"#3E4EB8\",\n  \"theme_color\": \"#2F3BA2\"\n}\n\nself.addEventListener('install', function(e) {\n  e.waitUntil(\n    caches.open('airhorner').then(function(cache) {\n      return cache.addAll([\n        './',\n        './index.html',\n        './dist/app.js',\n        './dist/app.css'\n      ]);\n    })\n  );\n});\n\n\n\u767e\u805e\u306f\u4e00\u898b\u306b\u3057\u304b\u305a\nAfter all that, we have our app looking like this on Android:\n\nAnd we can add it to the home-screen like so:\n\n\nConclusion\nBy using the existing web platform, we were able to build this audio player that works offline on mobile without any native mess or too much work.\nI hope this has shown that building simple apps in Purescript is fun. I hope this helps you build your own Purescript apps. Let me know on Twitter what you think!\nAlso, please do try it out yourself! https://justinwoo.github.io/purescript-web-audio-player-demo/\n\nLinks\n\nRepo: https://github.com/justinwoo/purescript-web-audio-player-demo\n\nHalogen: https://github.com/slamdata/purescript-halogen\n\n\nFor a long time now, I've had this problem that I haven't liked any media players on Android for listening to long files, especially podcasts. While many media players come with a 30-second rewind, they don't give me the level of control I want, which is to be able to skip forward 30 seconds and move around in 5-10 second intervals. Well, what can you do, right?\n\nI had in mind to either do this with React Native and Web. Well, considering I only need to pick a single file, control playback, and target my own Android devices (which are all > 4.4), this wasn't that hard of a decision. This also saved me the trouble of trying to get this published.\n\nI picked [Halogen](https://github.com/slamdata/purescript-halogen) since the way it handles effects in response to queries makes it quite easy for me to do everything I need.\n\n## Building our app\n\n### Types\n\nOne thing I found out I needed was ObjectURL hashes, since security features mandate that a cilent's actual filepath to a file is not allowed to be shown. So I made a newtype for that.\n\n```hs\nnewtype ObjectURL = ObjectURL String\nderive instance newtypeFilePath :: Newtype ObjectURL _\n```\n\nThe derived `Newtype` instance lets me use some other nice functions to allow functions to be applied \"over\" my newtype. We'll come back to this later.\n\nThe actual application state that I care about is only whether or not I have a file to work with, as the actual running state of the audio element is something I really don't want to carry around. This makes for some boring state though.\n\n```hs\ntype State =\n  { file :: Maybe ObjectURL\n  }\n```\n\nNext, I need my actual Query data type that I'll be using with Halogen. This isn't too sophisticated either:\n\n```hs\ndata Query a\n  = FileSet a\n  | Skip SkipDir SkipSize a\n\ndata SkipDir = Bck | Fwd\ndata SkipSize = Sm | Md | Lg\n```\n\nWhen the file is set, I'll be just triggering the action to actually get the file hash to set it.\n\nWith the skip, I wanted to make sure a given button has what direction and size of skip defined to emit, so that I can use that to make the effects as needed.\n\nFinally, I have the type of effects that will run in my Halogen component as an `Aff`:\n\n```hs\ntype AppEffects eff =\n  Aff\n  ( console :: CONSOLE\n  , dom :: DOM\n  | eff)\n```\n\n### Component definition\n\nAs our application only needs to be a simple single component, there are features of Halogen we won't be using here (and that's a good thing!), and our ui definition looks simple enough:\n\n```hs\nimport Halogen as H\nimport Halogen.HTML as HH\n\nui :: forall eff. H.Component HH.HTML Query Unit Void (AppEffects eff)\nui =\n  H.component\n    { initialState: const initialState\n    , render\n    , eval\n    , receiver: const Nothing\n    }\n  where\n    -- [...]\n```\n\nThe Halogen [Component](https://pursuit.purescript.org/packages/purescript-halogen/1.0.0/docs/Halogen.Component#t:Component) definition has a ton of type variables, but there are only three we are actually using here.\n\n1. The first, the type of what we're rendering, which will be HTML.\n2. The second, the query algebra, which is the query data type with a parameter we defined earlier.\n3. The last (fifth), the monad used for our effects, which is the AppEffects Aff we defined earlier.\n\nThe other two are for input and output that are used for parent-child communication that we won't be using here.\n\nThe actual spec passed to component seems simple enough: a record with initialState being a function for state using the Unit input we specified, a render function, and eval function, and a receiver function that we don't use here. In the where block, we define what we use here:\n\n#### initialState\n\n```hs\ninitialState =\n  { file: Nothing\n  }\n```\n\nUnsurprisingly, we have nothing for the file at the start.\n\n#### render\n\n```hs\nimport Halogen as H\nimport Halogen.Aff as HA\nimport Halogen.HTML as HH\nimport Halogen.HTML.Events as HE\nimport Halogen.HTML.Properties as HP\n\nrender :: State -> H.ComponentHTML Query\nrender state =\n  HH.div\n    [ HP.class_ $ wrap \"container\" ]\n    [ HH.div\n      [ HP.class_ $ wrap \"root\" ]\n      [ HH.h1_ [HH.text \"glorious web audio thing\"]\n      , HH.div_\n          [ HH.input\n            [ HP.ref $ wrap \"input\"\n            , HP.type_ HP.InputFile\n            , HP.prop (wrap \"accept\")  \"audio/*\"\n            , HE.onChange (HE.input_ FileSet)\n            ]\n          ]\n      , HH.div_\n          [ HH.audio\n            [ HP.ref $ wrap \"audio\"\n            , HP.src $ unwrap $ fromMaybe (wrap \"\") state.file\n            , HP.controls true\n            , HP.autoplay true\n            ]\n          []\n        ]\n      , HH.div\n          [ HP.class_ $ wrap \"buttons\" ]\n          [ HH.button [HE.onClick (HE.input_ $ Skip Bck Lg)] [HH.text \"<<<\"]\n          , HH.button [HE.onClick (HE.input_ $ Skip Bck Md)] [HH.text \"<<\"]\n          , HH.button [HE.onClick (HE.input_ $ Skip Bck Sm)] [HH.text \"<\"]\n          , HH.button [HE.onClick (HE.input_ $ Skip Fwd Sm)] [HH.text \">\"]\n          , HH.button [HE.onClick (HE.input_ $ Skip Fwd Md)] [HH.text \">>\"]\n          , HH.button [HE.onClick (HE.input_ $ Skip Fwd Lg)] [HH.text \">>>\"]\n          ]\n      ]\n  ]\n```\n\nNot much is involved here either, but we should keep note of a few things:\n\n```hs\n[ HH.input\n  [ HP.ref $ wrap \"input\"\n  , HP.type_ HP.InputFile\n  , HP.prop (wrap \"accept\")  \"audio/*\"\n  , HE.onChange (HE.input_ FileSet)\n  ]\n]\n```\n\nThe onchange handler here is set using a HE.input_ function, which will simply return the query `FileSet` to our eval function. Likewise is done for the skip buttons.\n\n#### eval\n\n```hs\neval :: Query ~> H.ComponentDSL State Query Void (AppEffects eff)\n```\n\nThis is where the meat and bones of our app lives. Let's first see how we handle `FileSet`:\n\n##### FileSet\n\n```hs\neval (FileSet next) = do\n  input <- H.getHTMLElementRef $ wrap \"input\"\n  case input >>= fromHTMLElement of\n    Just el -> do\n      nxs <- H.liftEff <<< files $ el\n      case toMaybe nxs >>= toMaybe <<< item 0 of\n        Just file -> do\n          url <- H.liftEff $ url =<< window\n          blob <- H.liftEff $ createObjectURL file url\n          prevBlob <- H.gets _.file\n          case prevBlob of\n            Just x ->\n              H.liftEff $ revokeObjectURL (unwrap x) url\n            _ -> pure unit\n          H.modify \\s ->\n            s {file = Just <<< wrap $ blob}\n        _ -> H.liftAff $ log \"No file found\"\n    _ -> H.liftAff $ log \"No input ref found\"\n  pure next\n```\n\nFirst, we use the ref \"input\" from earlier to get our element. We then transform it using `fromHTMLElement` into the file input type that we will be using, where if the element parses correctly, then we can continue. Otherwise, nothing is done.\n\nNote that we use `liftEff` to \"transform\" our `Eff` actions into our Halogen component context.\n\nOnce the element has been found and typed, we then use its `files` property to get the first item. We can't use the value due to how the file input is designed. We then take the window.URL property to use URL.createObjectURL to get the ObjectURL we need.\n\nOnce we have our ObjectURL, we make sure to revoke the previous ObjectURL so that the browser is explicitly told to remove handlers to the file, and then modify our state to set the file.\n\nThis will load up our file to our audio element, allowing it to be played. Let's now look at how skipping is done:\n\n##### Skip\n\n```hs\neval (Skip dir size next) = do\n  audio <- H.getHTMLElementRef $ wrap \"audio\"\n  case audio >>= fromHTMLElement of\n    Just el -> do\n      let el' = htmlAudioElementToHTMLMediaElement el\n      current <- H.liftEff $ currentTime el'\n      H.liftEff $ setCurrentTime (current + delta) el'\n    _ -> H.liftAff $ log \"No audio ref found\"\n  pure next\n  where\n    skip = case size of\n      Lg -> 30.0\n      Md -> 10.0\n      Sm -> 5.0\n    delta = skip * case dir of\n      Bck -> -1.0\n      _ -> 1.0\n```\n\nWe grab the \"audio\" ref to get the element and attempt to type it as above. When we have our audio element, we then convert it to a media element to control it as such.\n\nUsing the size and direction, we are able to compute the delta we want, and we then grab the current time of the control, apply our delta, and set the current time of the audio element to the result. That's about it!\n\n### main\n\n```hs\nimport Halogen.Aff as HA\nimport Halogen.VDom.Driver as D\n\nmain = HA.runHalogenAff do\n  body <- HA.awaitBody\n  io <- D.runUI ui unit body\n\n  log \"Running\"\n```\n\nWe use Halogen's runHalogenAff utility to run our Aff, which consists of waiting for the body and running our UI using our ui.\n\n### sw.js and offline\n\nTo use offline capabilities, we need to register a service worker and have a manifest file. It ends up being not much more than just some boilerplate:\n\n```html\n<!--in head-->\n<link rel=\"manifest\" href=\"manifest.json\">\n\n<script>\nif('serviceWorker' in navigator) {\n  navigator.serviceWorker\n    .register('sw.js')\n    .then(function() { console.log(\"Service Worker Registered\"); });\n}\n</script>\n```\n\n```json\n{\n  \"name\": \"My Web Audio Player\",\n  \"short_name\": \"WebAudio\",\n  \"icons\": [{\n    \"src\": \"icon-256x256.png\",\n    \"sizes\": \"256x256\",\n    \"type\": \"image/png\"\n  }],\n  \"start_url\": \"/purescript-web-audio-player-demo/index.html\",\n  \"display\": \"standalone\",\n  \"orientation\": \"portrait\",\n  \"background_color\": \"#3E4EB8\",\n  \"theme_color\": \"#2F3BA2\"\n}\n```\n\n```js\nself.addEventListener('install', function(e) {\n  e.waitUntil(\n    caches.open('airhorner').then(function(cache) {\n      return cache.addAll([\n        './',\n        './index.html',\n        './dist/app.js',\n        './dist/app.css'\n      ]);\n    })\n  );\n});\n```\n\n## \u767e\u805e\u306f\u4e00\u898b\u306b\u3057\u304b\u305a\n\nAfter all that, we have our app looking like this on Android:\n\n![photo_2017-03-05_15-36-00.jpg](https://qiita-image-store.s3.amazonaws.com/0/42481/94bed1f2-b164-a4d7-fdf8-57ee9e8b0d4a.jpeg)\n\nAnd we can add it to the home-screen like so:\n\n![photo_2017-03-05_15-35-55.jpg](https://qiita-image-store.s3.amazonaws.com/0/42481/3a43941d-e851-e20f-4598-06304650c316.jpeg)\n\n## Conclusion\n\nBy using the existing web platform, we were able to build this audio player that works offline on mobile without any native mess or too much work.\n\nI hope this has shown that building simple apps in Purescript is fun. I hope this helps you build your own Purescript apps. Let me know on [Twitter](https://twitter.com/jusrin00) what you think!\n\nAlso, please do try it out yourself! https://justinwoo.github.io/purescript-web-audio-player-demo/\n\n## Links\n\n* Repo: https://github.com/justinwoo/purescript-web-audio-player-demo\n* Halogen: https://github.com/slamdata/purescript-halogen\n", "tags": ["purescript", "purescript-halogen", "web-audio", "HTML", "PWA"]}