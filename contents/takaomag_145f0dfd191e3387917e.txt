{"context": " More than 1 year has passed since last update.\n\nDefinitions\n\nvar\n  a = \"a\"  # l-value\n\nconst\n  b = \"a\"  # not l-value\n\nlet\n  c = \"a\" # not l-value\n\nvar\n  p: ptr string\n\necho(repr(a))\n# --> 0x7fd3b9d09050\"a\"\n\np = addr(a)\n\necho(repr(p))\n# --> ref 0x622958 --> 0x7fd3b9d09050\"a\"\n\n#p = addr(b)\n# static error: expression has no address\n\n#p = addr(b)\n# static error: expression has no address\n\n\nLexical Analysis\n\n\nEncoding\n\nAll Nim source files are in the UTF-8 encoding (or its ASCII subset). Other encodings are not supported.\n\nIndentation\n\n\nComments\n\nvar\n  x = 1  # comment piece\n  y = 1  # [comment start] comment piece\n# comment piece\n# comment piece [comment end]\n\n## Documentation comment\n## Documentation comment\n\n\nIdentifiers & Keywords\n\nletter ::= 'A'..'Z' | 'a'..'z' | '\\x80'..'\\xff'\ndigit ::= '0'..'9'\nIDENTIFIER ::= letter ( ['_'] (letter | digit) )*\n\nTwo immediate following underscores __ are not allowed\n\nIdentifier equality\n\na[0] == b[0] and a.replace(\"_\", \"\").toLower == b.replace(\"_\", \"\").toLower\n\n\nString literals\n\n\nTriple quoted string literals\n\nWhen the opening \"\"\" is followed by a newline (there may be whitespace between the opening \"\"\" and the newline), the newline (and the preceding whitespace) is not included in the string. \nassert \"\"\"\n \"aaa\"\nbbb\nccc\n\\n\\r\\c\\x00\\t\n\"\"\" == \" \\\"aaa\\\"\\nbbb\\nccc\\n\\\\n\\\\r\\\\c\\\\x00\\\\t\\n\"\n\n\nRaw string literals\n\nassert r\"C:\\texts\\text.txt\" == \"C:\\\\texts\\\\text.txt\"\nassert r\"a\"\"b\" == \"a\\\"b\"\n\n\nGeneralized raw string literals\n\nidentifier\"string literal\"\nis a shortcut for\nidentifier(r\"string literal\")\nidentifier\"\"\"string literal\"\"\"\nis a shortcut for\nidentifier(\"\"\"string literal\"\"\")\n\nCharacter literals\n\nCharacter literals are enclosed in single quotes ''. Newline (\\n) is not allowed as it may be wider than one character (often it is the pair CR/LF for example).\nA character is not an Unicode character but a single byte.Nim can thus support array[char, int] or set[char] efficiently as many algorithms rely on this feature.\n\nNumerical constants\n\nvar\n  i = 3  # signed int\n  i8 = 3'i8  # signed int8\n  i16 = 3'i16  # signed int16\n  i32 = 3'i32  # signed int32\n  i64 = 3'i64  # signed int64\n\n  ui = 3'u  # unsigned int\n  ui8 = 3'u8  # unsigned int8\n  ui16 = 3'u16  # unsigned int16\n  ui32 = 3'u32  # unsigned int32\n  ui64 = 3'u64  # unsigned int64\n\n  f = 0.0  # float\n  f32 = 0.0'f32  # float32\n  f64 = 0.0'f64  # float6\n\nassert 0b11111111 == 255\nassert 0o377 == 255\nassert 0xff == 255\nassert 0b0_10001110100_0000101001000111101011101111111011000101001101001001'f64 == 1.7282561e+35\nassert 1_999_999 == 1999999\n\nSize of int/uint is \"size_t\".\n\nOperators\n\n=     +     -     *     /     <     >\n@     $     ~     &     %     |\n!     ?     ^     .     :     \\\nand or not xor shl shr div mod in notin is isnot of\n\n\nOther tokens\n\n\nTypes\n\n\nordinal types\n\n\ninteger (except for uint/uint64)\nbool\nchar\nenum\nand subranges thereof\n\n\nfloat\nstring\nstructured types\n\n\narray\nseq\nset\nopenArray\nvarargs\ntuple\nobject\n\n\nref (ptr) type\nprocedural type\ngeneric type\n\n\nOrdinal types\n\n\ncountable and ordered\n\ninc(), dec()\n\n\nord(), low(), high(), pred(), succ()\n\n\nvar\n  i = 0\n\ninc(i)\nassert i == 1\ndec(i)\nassert i == 0\n\ni = high(int)\nassert i == high(i)\ntry:\n  inc(i)\nexcept OverFlowError:\n  # Error: unhandled exception: over- or underflow [OverflowError]\n  echo(\"OverFlowError:\", getCurrentExceptionMsg())\n\ni = low(int)\nassert i == low(i)\ntry:\n  dec(i)\nexcept OverFlowError:\n  # Error: unhandled exception: over- or underflow [OverflowError]\n  echo(\"OverFlowError:\", getCurrentExceptionMsg())\n\n\nimport unsigned\n# some ops requires unsigned module\n\nvar\n  u:uint = 0\n\ninc(u)\nassert u == 1\ndec(u)\nassert u == 0\n\n#u = low(uint)\n#u = low(u)\n# static error: invalid argument for `low`\n\n#u = high(uint)\n#u = high(u)\n# static error: invalid argument for `high`\n\nu = uint(high(int) * 2 + 1)\ninc(u)\nassert u == 0\ndec(u)\nassert u == uint(high(int) * 2 + 1)\n\n\nvar\n  c = 'm'\n\nassert ord(c) == 109\nassert chr(109) == c\nassert pred('m') == 'l'\nassert succ('m') == 'n'\n\ninc(c)\nassert c == 'n'\ndec(c)\nassert c == 'm'\n\nc = low(c)\nassert c == '\\0'\ntry:\n  dec(c)\nexcept OverFlowError:\n  # Error: unhandled exception: over- or underflow [OverflowError]\n  echo(\"OverFlowError:\", getCurrentExceptionMsg())\n\nc = high(c)\nassert c == '\\255'\ntry:\n  inc(c)\nexcept OverFlowError:\n  # Error: unhandled exception: over- or underflow [OverflowError]\n  echo(\"OverFlowError: \", getCurrentExceptionMsg())\n\n\nPre-defined integer types\n\nimport unsigned\n\nvar\n  i: int\n  ui: uint\n\nassert i == 0\nassert ui == 0\n\n\nSubrange type\n\nA subrange type is a range of values from an ordinal type(the base type). To define a subrange type, one must specify it's limiting values: the lowest and highest value of the type.\nA subrange type of a base ordinal type which can only hold the lowest value to highest value. Assignments from the base ordinal type to one of its subrange types (and vice versa) are allowed.\nA subrange type has the same size as its base type (int in the example).\ntype\n  IntSubRange = range[-10 .. 10]\n  ChrSubRange = range['a' .. 'c']\n\n  Direction {.pure.} = enum\n    north,\n    south,\n    east,\n    west,\n  EnumSubRange = range[Direction.north .. Direction.east]\n\nvar\n  s_i: IntSubRange\n  s_c: ChrSubRange\n  s_e: EnumSubrange\n  i: int = s_i\n\nassert s_i == 0\nassert s_c == '\\x0'\nassert s_e == Direction.north\ns_i = -10\ns_c = 'b'\ns_e = Direction.south\n#s_i = -11\n# static error: conversion from int literal(-11) to intSubRange is invalid\n\ntry:\n  dec(s_i)\nexcept OverFlowError:\n  # Error: unhandled exception: over- or underflow [OverflowError]\n  echo(\"OverFlowError: \", getCurrentExceptionMsg())\n\nNim requires interval arithmetic for subrange types over a set of built-in operators that involve constants: x %% 3 is of type range[0..2]. The following built-in operators for integers are affected by this rule: -, +, *, min, max, succ, pred, mod, div, %%, and (bitwise and).\nBitwise and only produces a range if one of its operands is a constant x so that (x+1) is a number of two. (Bitwise and is then a %% operation.)\ncase (x and 3) + 7\nof 7: echo \"A\"\nof 8: echo \"B\"\nof 9: echo \"C\"\nof 10: echo \"D\"\n# note: no ``else`` required as (x and 3) + 7 has the type: range[7..10]\n\n\nPre-defined floating point types\n\nArithmetic performed on floating point types follows the IEEE standard. Integer types are not converted to floating point types automatically and vice versa.\nThe IEEE standard defines five types of floating-point exceptions:\n\nInvalid: operations with mathematically invalid operands, for example 0.0/0.0, sqrt(-1.0), and log(-37.8).\nDivision by zero: divisor is zero and dividend is a finite nonzero number, for example 1.0/0.0.\nOverflow: operation produces a result that exceeds the range of the exponent, for example MAXDOUBLE+0.0000000000001e308.\nUnderflow: operation produces a result that is too small to be represented as a normal number, for example, MINDOUBLE * MINDOUBLE.\nInexact: operation produces a result that cannot be represented with infinite precision, for example, 2.0 / 3.0, log(1.1) and 0.1 in input.\n\nThe IEEE exceptions are either ignored at runtime or mapped to the Nim exceptions:\n\nFloatInvalidOpError\nFloatDivByZeroError\nFloatOverflowError\nFloatUnderflowError\nFloatInexactError\n\nThese exceptions inherit from the FloatingPointError base class.\nNim provides the pragmas NaNChecks and InfChecks to control whether the IEEE exceptions are ignored or trap a Nim exception:\n# https://akehrer.github.io/nim/2015/01/14/getting-started-with-nim-pt2.html\nimport math\n\nconst\n  Nan = 0.0/0.0 # floating point not a number (NaN)\n\nproc cIsNaN(x: float): cint {.importc: \"isnan\", header: \"<math.h>\".}\n  ## returns non-zero if x is not a number\n\nproc cIsInf(x: float): cint {.importc: \"isinf\", header: \"<math.h>\".}\n  ## returns non-zero if x is infinity\n\nproc isNaN*(x: float): bool =\n  ## converts the integer result from cIsNaN to a boolean\n  if cIsNaN(x) != 0.cint:\n    true\n  else:\n    false\n\nproc isInf*(x: float): bool =\n  ## converts the integer result from cIsInf to a boolean\n  if cIsInf(x) != 0.cint:\n    true\n  else:\n    false\n\n\nvar\n  a:float\n  b = 1.0\n\nassert a == 0.0\necho(0.0 / 0.0)  # --> nan\necho(1.0 / 0.0)  # --> inf\necho(a / a)  # --> -nan\necho(b / a)  # --> inf\n\n{.push nanChecks: on, infChecks: on.}\necho(0.0 / 0.0)\necho(1.0 / 0.0)\n\ntry:\n  echo a / a\nexcept FloatInvalidOpError:\n  # Error: unhandled exception: FPU operation caused a NaN result [FloatInvalidOpError]\n  echo(\"FloatInvalidOpError: \", getCurrentExceptionMsg())\n\ntry:\n  echo b / a\nexcept FloatOverflowError:\n  # Error: unhandled exception: FPU operation caused an overflow [FloatOverflowError]\n  echo(\"FloatOverflowError: \", getCurrentExceptionMsg())\n{.pop.}\n\nIn the current implementation FloatDivByZeroError and FloatInexactError are never raised. FloatOverflowError is raised instead of FloatDivByZeroError. There is also a floatChecks pragma that is a short-cut for the combination of NaNChecks and InfChecks pragmas. floatChecks are turned off as default.\nThe only operations that are affected by the floatChecks pragma are the +, -, *, / operators for floating point types.\nAn implementation should always use the maximum precision available to evaluate floating pointer values at compile time; this means expressions like 0.09'f32 + 0.01'f32 == 0.09'f64 + 0.01'f64 are true.\n\nBoolean type\n\nassert ord(false) == 0\nassert ord(true) == 1\n\n\nCharacter type\n\nNim can support array[char, int] or set[char] efficiently as many algorithms rely on this feature.\nvar\n  c: char\nassert c == '\\x0'\n\nvar\n  char_index_array: array[char, int]\n\nassert char_index_array.len == 256\nassert char_index_array['a'] == 0\nchar_index_array['v'] = 1\nassert char_index_array['v'] == 1\n\nvar\n  char_set: set[char] = {'a', 'a', 'b'}\n\nassert char_set == {'a', 'b'}\n\nvar\n  char_buffer: array[0 .. 255, char]\n\nassert char_buffer.len == 256\nassert char_buffer == ['\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0']\n\nchar_buffer[0] = 'a'\n\nassert cstring(char_buffer).len == 1\necho cstring(char_buffer)\n# --> a\n\n\nEnumeration type\n\nEnumeration types define a new type whose values consist of the ones specified. The values are ordered.\ntype\n  Direction = enum\n    north,\n    south,\n    east,\n    west,\n\nassert north == Direction.north\nassert north < Direction.south\n\nassert ord(Direction.north) == 0\nassert ord(north) == 0\nassert ord(south) == 1\nassert ord(east) == 2\nassert ord(west) == 3\n\nassert pred(east) == south\nassert succ(east) == west\n\nvar\n  e: Direction\n\nassert e == north\ne = east\n\ninc(e)\nassert e == west\ndec(e)\nassert e == east\nassert low(Direction) == north\nassert low(e) == north\nassert high(Direction) == west\nassert high(e) == west\n\nassert Direction(0) == north\nassert Direction(1) == south\nassert Direction(2) == east\nassert Direction(3) == west\n\nvar\n  arr_e0: array[Direction, float]\n  arr_e1: array[north .. west, float]\n\nassert arr_e0[east] == 0.0\nassert arr_e1[east] == 0.0\narr_e0[east] = 1.1\n\n\ntype\n  ScopedEnum {.pure.} = enum\n    val_a,\n    val_b,\n\n# static error: undeclared identifier: 'val_a'\n#echo val_a\n\nThe fields of enum types can be assigned an explicit ordinal value. However, the ordinal values have to be in ascending order. A field whose ordinal value is not explicitly given is assigned the value of the previous field + 1.\nAn explicit ordered enum can have holes. However, it is then not an ordinal anymore, so it is not possible to use these enums as an index type for arrays. The procedures inc, dec, succ and pred are not available for them either.\ntype\n  Status = enum\n    ok = 200,\n    created,\n    accepted = \"Accepted\",\n    multiple_sources = 300,\n    moved_permanently = \"Moved Permanently\",\n    bad_request = 400,\n    internal_server_error = (500, \"Internal Server Error\")\n\nassert ord(ok) == 200\nassert ord(created) == 201\nassert ord(accepted) == 202\n\n# static error: enum 'Status' has holes\n#var\n#  x: array[ok .. accepted, int]\n#  y: array[Status, int]\n\nvar\n  status = ok\n\ninc(status)\nassert status == created\ninc(status)\nassert status == accepted\ninc(status)\nassert status != multiple_sources\n\necho(status)\n# --> 203 (invalid data!)\n\n\nString type\n\nZero(Null)-terminated and have a length field. The length never counts the terminating zero. The assignment operator for strings always copies the string. The & operator concatenates strings.\nStrings are compared by their lexicographical order. All comparison operators are available. Strings can be indexed like arrays (lower bound is 0).\nvar\n  s: string\n\nassert s.isNil\ns = \"this\"  # assignment op does COPY the string\n\nvar\n  conc = s & \" is\"  # concat\n\nassert s[0] == 't'\n# static error\n#assert s[0] == \"t\"\ns[0] = 'T'\n# static error\n#s[0] = \"T\"\n\nassert s[0 .. 1] == \"Th\"\ns.add(\" \")\ns.add(\"is a string\")\nassert s == \"This is a string\"\nassert s[low(s) .. high(s)] == \"This is a string\"\n\ntry:\n  echo s[100]\nexcept IndexError:\n  # Error: unhandled exception: index out of bounds [IndexError]\n  echo(\"IndexError: \", getCurrentExceptionMsg())\n\nvar\n  s = \"0123456789\"\n\nassert s.len == 10\nassert s[0] == '0'\nassert s[^0] == '\\x0'\nassert s[^1] == '9'\nassert s[1 .. 1] == \"1\"\nassert s[1 .. 3] == \"123\"\nassert s[^1 .. ^1] == \"9\"\nassert s[^3 .. ^1] == \"789\"\nassert s[^1 .. ^2] == \"\"\nassert s[0 .. ^0] == \"0123456789\"\nassert s[0 .. ^1] == \"0123456789\"\ns[0] = 'a'\nassert s == \"a123456789\"\ns[0 .. 0] = \"a\" \nassert s == \"a123456789\"\ns[0 .. 2] = \"abc\"\nassert s == \"abc3456789\"\ns[^3 .. ^1] = \"xyz\"\nassert s == \"abc3456xyz\"\ns[0 .. 2] = \"a\"\nassert s == \"a3456xyz\"\ns[0 .. 2] = \"\"\nassert s == \"56xyz\"\ns[0 .. 0] = \"012345\"\nassert s == \"0123456xyz\"\ns[0 .. 2] = \"\"\nassert s == \"3456xyz\"\ns[^3 .. ^1] = \"\"\nassert s == \"3456\"\ns.setLen(1)\nassert s.len == 1\nassert s == \"3\"\n\nPer convention, all strings are UTF-8 strings, but this is not enforced. For example, when reading strings from binary files, they are merely a sequence of bytes. The index operation s[i] means the i-th char of s, not the i-th unichar.\n\ncstring type\n\nA pointer to zero-terminated char array(char* in c). No boundChecks. The index operation is unsafe.\nA Nim string is implicitly convertible to cstring for convenience. If a Nim string is passed to a C-style variadic proc, it is implicitly converted to cstring too:\nEven though the conversion is implicit, it is not safe: The garbage collector does not consider a cstring to be a root and may collect the underlying memory. However in practice this almost never happens as the GC considers stack roots conservatively. One can use the builtin procs GC_ref and GC_unref to keep the string data alive for the rare cases where it does not work.\nA $ proc is defined for cstrings that returns a string. Thus to get a nim string from a cstring:\nproc printf(formatstr: cstring) {.importc:\n  \"printf\", varargs,\n  header: \"<stdio.h>\".}\n\nprintf(\"This works as expected %s\", \"by printf in stdio\")\n\nvar\n  str: string = \"hello\"\n  cstr: cstring\n\nassert cstr.isNil\n\ncstr = str\n\nvar\n  str_back: string = $cstr\n\nvar\n  # `system.cstringArray` is equal to `ptr array [0..ArrayDummySize, cstring]`\n  cstring_arr: cstringArray = allocCStringArray([\"abc\"])\n\ncstring_arr[1] = \"def\"\ncstring_arr[2] = \"ghi\"\nassert cstringArrayToSeq(cstring_arr) == @[\"abc\", \"def\", \"ghi\"]\n\ndealloc(cstring_arr)\n\n# if the members of a cstringArray are allocated (for example, by c), call `deallocCStringArray()`\n#deallocCStringArray(cstring_arr)\n\n\nStructured types\n\nArrays, sequences, tuples, objects and sets belong to the structured types.\n\nArray and sequence types\n\n\narray\n\nelement: homogeneous\nlength: fixed\nindex type: ordinal type\nexpression constructor: []\nboundsCheck: yes(compile-time)\n\nimport typetraits\n\nvar\n  arr_obj: array[0 .. 5, int]\n  arr_ref: ref array[0 .. 5, int]\n\nassert arr_obj.type.name == \"array[0..5, int]\"\necho repr(arr_obj)\n# --> [0, 0, 0, 0, 0, 0]\n\nassert arr_ref.isNil\nnew(arr_ref)\nassert (not arr_ref.isNil)\nassert arr_ref.type.name == \"ref array[0..5, int]\"\necho repr(arr_ref)\n# --> ref 0x7fda81f0b0d0 --> [0, 0, 0, 0, 0, 0]\n\nvar\n  ii_arr0: array[int, int]\n  # too big array\n\nassert low(ii_arr0) == low(int)\nassert high(ii_arr0) == high(int)\nassert len(ii_arr0) == 0\nassert ii_arr0[0] == 0\nii_arr0[0] = 0\nassert ii_arr0.len == 0\n\n\nvar\n  i16i_arr: array[int16, int]\n\nassert low(i16i_arr) == low(int16)\nassert high(i16i_arr) == high(int16)\nassert len(i16i_arr) == 65536\n\n\nvar\n  ii_arr1: array[0 .. 3, int]\n\nassert low(ii_arr1) == 0\nassert high(ii_arr1) == 3\nassert len(ii_arr1) == 4\nassert ii_arr1[0] == 0\nii_arr1 = [0, 1, 2, 3]\n\n\nvar\n  ci_arr: array[char, int]\n\nassert low(ci_arr) == low(char)\nassert high(ci_arr) == high(char)\nassert len(ci_arr) == 256\nassert ci_arr['a'] == 0\nci_arr['v'] = 1\n\n\ntype\n  Direction = enum\n    north,\n    south,\n    east,\n    west,\n\nvar\n  ei_arr0:  array[Direction, int]\n  ei_arr1:  array[north .. west, int]\n\nassert low(ei_arr0) == north\nassert high(ei_arr0) == west\nassert len(ei_arr0) == 4\nassert ei_arr0[north] == 0\nei_arr0[north] = 1\n\n\nseq\n\nelement: homogeneous\nlength: dynamic\nindex type: ordinal type. From 0 to len(S) - 1\n\nboundsCheck: yes\nexpression constructor: @[] (the array constructor [] in conjunction with the array to sequence operator @)\nspace alloc:\n\n\nproc system.newSeq[T](s: var seq[T]; len: Natural)\nproc system.newSeq[T](len = 0.Natural): seq[T]\n\n\n\nnewSeq creates a new sequence of type seq[T] with length len. This is equivalent to s = @[]; setlen(s, len), but more efficient since no reallocation is needed.\nvar\n  seq_ref0: ref seq[int]\n\nassert seq_ref0.isNil\nnew(seq_ref0)\nassert (not seq_ref0.isNil)\necho repr(seq_ref0)\n# --> ref 0x7f180287b050 --> nil\nassert seq_ref0[].isNil\n\n\nvar\n  seq_obj = newSeq[int]()\n  seq_ref1: ref seq[int]\n\nassert seq_ref1.isNil\nnew(seq_ref1)\nassert (not seq_ref1.isNil)\necho repr(seq_ref1)\n# --> ref 0x7f180287b068 --> nil\nseq_ref1[] = seq_obj\necho repr(seq_obj)\n# --> 0x7f180287c050[]\necho repr(seq_ref1)\n# --> ref 0x7f180287b068 --> 0x7f180287c070[]\n\nvar\n  seq_0: seq[int]\n  seq_1 = @[0, 1, 2]\n\nassert seq_0.isNil\nseq_0 = @[0, 1, 2]\nassert (not seq_0.isNil)\nassert low(seq_0) == 0\nassert high(seq_0) == 2\nassert len(seq_0) == 3\nassert seq_0 & seq_1 == @[0, 1, 2, 0, 1, 2]\nassert seq_0.pop() == 2\nseq_0.add(1)\nassert seq_0 == @[0, 1, 1]\n\n\nvar\n  seq_2: seq[int]\n\nassert seq_2.isNil\nnewSeq(seq_2, 0)\nassert (not seq_2.isNil)\nassert len(seq_2) == 0\n\n\nvar\n  seq_3 = newSeq[int]()\n\nassert (not seq_3.isNil)\nassert len(seq_3) == 0\n\n\nvar\n  seq_4 = newSeq[int](3)\n\nassert (not seq_4.isNil)\nassert len(seq_4) == 3\n\nproc shallow[T](s: var seq[T]) marks a sequence s as shallow. Subsequent assignments will not perform deep copies of s. This is only useful for optimization purposes.\nvar\n  s0 = @[0, 0, 0]\n\nvar\n  s1 = s0\n\nshallow(s0)\n\nvar\n  s2 = s0\n  s3 = s0[0..2]\n\ninc s0[0]\ns0.add(3)\nassert s0 == @[1, 0, 0, 3]\nassert s1 == @[0, 0, 0]\nassert s2 == @[1, 0, 0]\nassert s3 == @[0, 0, 0]\n\n\nopenArray\n\n{.push boundChecks: off.}\nproc to_str_seq(a: openArray[int]): seq[string] =\n  #var\n  #  result = newSeq[string](len(a))\n  newSeq(result, len(a))\n  for i, it in a:\n    result[i] = $it\n{.pop.}\n\nassert to_str_seq([1,2,3]) == @[\"1\", \"2\", \"3\"]\n\n\n{.push boundChecks: off.}\nproc to_reversed_seq[T](a: openArray[T]): seq[T] =\n  var\n    li = 0\n    hi = high(a)\n  newSeq(result, hi + 1)\n  while hi >= 0:\n    result[hi] = a[li]\n    dec(hi)\n    inc(li)\n{.pop.}\n\nvar\n  arr = [1, 2, 3]\n  s = @[1, 2, 3]\n\nassert arr.to_reversed_seq == @[3, 2, 1]\nassert s.to_reversed_seq == @[3, 2, 1]\n\n\nvarargs\n\nproc anyFileWriteln0(f: File, sargs: varargs[string]): void =\n  for s in sargs:\n    write(f, s)\n  write(f, \"\\n\")\n\nanyFileWriteln0(stdout, \"abc\", \"def\", \"xyz\")\n# = anyFileWriteln0(stdout, [\"abc\", \"def\", \"xyz\",])\n\n\nproc anyFileWriteln1(f: File, sargs: varargs[string, `$`]): void =\n  for s in sargs:\n    write(f, s)\n  write(f, \"\\n\")\n\n\nanyFileWriteln1(stdout, 123, \"def\", 4.0)\n# = anyFileWriteln1(stdout, [$123, \"def\", $4.0])\n\n\nproc toS(x): string = $x\n\n\nproc anyFileWriteln2(f: File, sargs: varargs[string, toS]): void =\n  for s in sargs:\n    write(f, s)\n  write(f, \"\\n\")\n\n\nanyFileWriteln2(stdout, 123, 456, 5)\n# = anyFileWriteln2(stdout, [toS(123), toS(456), toS(5)])\n\n\nproc takeV[T](x: varargs[T]): void =\n  for s in x:\n   echo($s)\n\n\ntakeV([1, 2, 3])\n\nvarargs[expr] is treated specially: It matches a variable list of arguments of arbitrary type but always constructs an implicit array. This is required so that the builtin echo proc does what is expected:\nproc echo*(x: varargs[expr, `$`]) {...}\n\necho(@[1, 2, 3])\n# prints \"@[1, 2, 3]\" and not \"123\"\n\n\nTuples and object types\n\n\ntuple\nThe order of the fields in the constructor must match the order of the tuple's definition. Different tuple-types are equivalent if they specify the same fields of the same type in the same order. The names of the fields also have to be identical.\nThe assignment operator for tuples copies each component.\ntype\n  Person0 = tuple[\n    name: string,\n    age: Natural,\n  ]\n\nvar\n  p0: Person0\n\np0 = (name: \"Peter\", age: 20.Natural)  # assinment op does COPY each component\np0 = (\"Peter\", 20.Natural)\n\n\n# tuples in a type section can also be defined with indentation instead of []:\ntype\n  Person1 = tuple\n    name: string\n    age: Natural\n\nvar\n  p1: Person1 = (name: \"Peter\", age: 20.Natural)\n  p2: Person1 = (name: \"Adam\", age: 30.Natural)\n\n\nassert p0 == p1\nassert p0 != p2\nassert p0 == (name: \"Peter\", age: 20.Natural)\n\n\n# These are invalid because illegal recursion in the type\n# type\n  # MyTuple0 = tuple[a: MyTuple0]\n  # MyTuple1 = tuple[a: ref MyTuple1]\n\nimport tables\n\nvar\n  field_seq: seq[string] = @[]\n  field_pairs: Table[string, string] = initTable[string, string]()\n\nfor v in p0.fields:\n  field_seq.add($v)\n\nassert field_seq == @[\"Peter\", \"20\"]\n\nfield_seq.setLen(0)\n\nfor v0, v1 in fields(p0, p2):\n  field_seq.add($v0)\n  field_seq.add($v1)\n\nassert field_seq == @[\"Peter\", \"Adam\", \"20\", \"30\"]\n\nfor k, v in p0.fieldPairs:\n  field_pairs.add($k, $v)\n\nassert field_pairs == {\"name\": \"Peter\", \"age\": \"20\"}.toTable\n\n\nobject\nThe default assignment operator for objects copies each component.\nIn contrast to tuples, different object types are never equivalent. Objects that have no ancestor are implicitly final and thus have no hidden type field. One can use the inheritable pragma to introduce new object roots apart from system.RootObj.\ntype\n  PersonObj* {.inheritable.} = object\n    name*: string\n    age*: Natural\n  Person* = ref PersonObj\n\n  SubPersonObj* = object of PersonObj\n  SubPerson* = ref SubPersonObj\n\n  AltPersonObj* {.inheritable.} = object\n    name*: string\n    age*: Natural\n  AltPerson* = ref AltPersonObj\n\n  StudentObj* = object of PersonObj\n    id: int\n  Student* = ref StudentObj\n\nvar\n  pobj: PersonObj\n  p0, p1: Person\n  subp: SubPerson\n  altp: AltPerson\n  s: Student\n\necho(repr(pobj))\n# --> [name = nil, age = 0]\nassert p0.isNil\np0 = Person(name: \"Peter\", age: 20.Natural)  # assignment op does COPY each component\np1 = Person(name: \"Peter\", age: 20.Natural)\nsubp = SubPerson(name: \"Peter\", age: 20.Natural)\naltp = AltPerson(name: \"Peter\", age: 20.Natural)\ns = Student(name: \"Peter\", age: 20.Natural, id: 1)\n\nassert p0 of Person\nassert p0 of PersonObj\nassert p0[] of Person\nassert p0[] of PersonObj\nassert p0.type is Person\nassert p0[].type is PersonObj\n\nassert subp of SubPerson\nassert subp of SubPersonObj\nassert subp[] of SubPerson\nassert subp[] of SubPersonObj\nassert subp.type is SubPerson\nassert subp[].type is SubPersonObj\n\nassert subp of Person\nassert subp of PersonObj\nassert subp[] of Person\nassert subp[] of PersonObj\nassert subp.type is Person\nassert subp[].type is PersonObj\n\nassert s of Person\nassert s of PersonObj\nassert s[] of Person\nassert s[] of PersonObj\nassert s.type is Person\nassert s[].type is PersonObj\n\nassert p0 != p1\nassert p0[] == p1[]\nassert p0 != subp\nassert p0[] == subp[]\n#assert subp[] != p0[]\n# static error: type mismatch: got(SubPersonObj, PersonObj)\n\n#assert p0 != altp\n# static error: type mismatch: got(Person, AltPerson)\n\n#assert p0[] == altp[]\n# static error: type mismatch: got(Person, AltPerson)\nassert p0 != s\n#assert s != p0\n# static eror: type mismatch: got(Student, Person)\n\nassert p0[] == s[]\n#assert s[] == p0[]\n# static eror: type mismatch: got(StudentObj, PersonObj)\nassert s.name == \"Peter\"\nassert s.age == 20\nassert s.id == 1\n\n\nproc newStudent(name: string, age: int, id: int): Student =\n  new(result)\n  result.name = name\n  result.age = age.Natural\n  result.id = id\n\n\nvar\n  s1 = newStudent(\"Name\", 20, 1)\n  s2 = newStudent(\"Name\", 20, 1)\n\nassert s1 != s2\nassert s1[] == s2[]\n\n\nvar\n  s3: Student\n\nnew(s3)\ns3.name = \"Name\"\ns3.age = 20\ns3.id = 1\n\n\nimport tables\n\np1.name = \"Adam\"\np1.age = 30\nsubp.name = \"Adam\"\nsubp.age = 30\n\nvar\n  field_seq: seq[string] = @[]\n  field_pairs: Table[string, string] = initTable[string, string]()\n\nfor v in p0[].fields:\n  field_seq.add($v)\n\nassert field_seq == @[\"Peter\", \"20\"]\n\nfield_seq.setLen(0)\n\nfor v0, v1 in fields(p0[], p1[]):\n  field_seq.add($v0)\n  field_seq.add($v1)\n\nassert field_seq == @[\"Peter\", \"Adam\", \"20\", \"30\"]\n\nfor k, v in p0[].fieldPairs:\n  field_pairs.add($k, $v)\n\nassert field_pairs == {\"name\": \"Peter\", \"age\": \"20\"}.toTable\n\nfield_seq.setLen(0)\n# static error: type mismatch: got(SubPersonObj) but expected 'PersonObj'\n#for v0, v1 in fields(p0[], subp[]):\n#  field_seq.add($v0)\n#  field_seq.add($v1)\n\n# static error: type mismatch: got(StudentObj) but expected 'PersonObj'\n#for v0, v1 in fields(p0[], s[]):\n#  field_seq.add($v0)\n#  field_seq.add($v1)\n\nhttps://github.com/nim-lang/Nim/issues/3012\nhttps://github.com/nim-lang/Nim/issues/2926\ntype\n  A {.inheritable.} = object\n  B = ref object {. inheritable .}\n  C {.inheritable.} = ref object\n  D = object {.inheritable.}\n\ntype\n  AA = ref object of A\n  BB = ref object of B\n  #CC = ref object of C\n  # Error: inheritance only works with non-final objects\n  DD = ref object of D\n\n\nObject construction\n\nObjects can also be created with an object construction expression that has the syntax T(fieldA: valueA, fieldB: valueB, ...) where T is an object type or a ref object type:\nvar\n  student_obj = StudentObj(name: \"Anton\", age: 5, id: 3)\n  student = Student(name: \"Anton\", age: 5, id: 3)\n\nFor a ref object type system.new is invoked implicitly.\n\nObject variants\n\nAn advantage to an object hierarchy is that no casting between different object types is needed. Yet, access to invalid object fields raises an exception.\ntype\n  NodeKind = enum\n    nkInt,\n    nkFloat,\n    nkString,\n    nkAdd,\n    nkSub,\n    nkIf,\n\n  Node = ref NodeObj\n\n  NodeObj = object\n    case kind: NodeKind\n    of nkInt:\n      valInt: int\n    of nkFloat:\n      valFloat: float\n    of nkString:\n      valString: string\n    of nkAdd, nkSub:\n      opLeft, opRight: Node\n    of nkIf:\n      condition, thenPart, elsePart: Node\n\n\nvar\n  n = Node(kind: nkIf, condition: nil)\n\n\nn.thenPart = Node(kind: nkFloat, valFloat: 2.0)\n\ntry:\n  n.valString = \"\"\nexcept FieldError:\n  # Error: unhandled exception: valString is not accessible [FieldError]\n  echo(getCurrentExceptionMsg())\n\n\ntry:\n  n.kind = nkInt\nexcept FieldError:\n  # Error: unhandled exception: assignment to discriminant changes object branch [FieldError]\n  echo(getCurrentExceptionMsg())\n\n\n\nvar x: Node = Node(\n  kind: nkAdd,\n  opLeft: Node(kind: nkInt, valInt: 3),\n  opRight: Node(kind: nkInt, valInt: 2),\n)\n\nx.kind = nkSub\n\nIn the example the kind field is called the discriminator: For safety its address cannot be taken and assignments to it are restricted: The new value must not lead to a change of the active object branch. For an object branch switch system.reset has to be used.\n\nSet type\n\nThe set's basetype can only be an ordinal type. The reason is that sets are implemented as high performance bit vectors.\ntype\n  CharSet = set[char]\n\nvar\n  cs0: CharSet = {'a' .. 'z', 'A' .. 'Z', '0' .. '9'}\n  cs1: CharSet = {'a'.. 'd'}\n  cs2: CharSet = {'c'.. 'f'}\n  cs3: CharSet = {'c', 'd'}\n\nassert cs1 + cs2 == {'a' .. 'f'}\nassert cs1 - cs2 == {'a', 'b'}\nassert cs1 * cs2 == {'c', 'd'}\nassert cs1 != cs2\nassert cs1 >= cs3\nassert cs1 > cs3\nassert 'a' in cs1\nassert cs1.contains('a')\nassert 'e' notin cs1\nassert card(cs1) == 4\nincl(cs1, 'a')\nassert cs1 == {'a'.. 'd'}\nincl(cs1, 'e')\nassert cs1 == {'a'.. 'e'}\nexcl(cs1, 'e')\nassert cs1 == {'a'.. 'd'}\n\n\n\n\noperation\nmeaning\n\n\n\n\nA + B\nunion of two sets\n\n\nA * B\nintersection of two sets\n\n\nA - B\ndifference of two sets (A without B's elements)\n\n\nA == B\nset equality\n\n\nA <= B\nsubset relation (A is subset of B or equal to B)\n\n\nA < B\nstrong subset relation (A is a real subset of B)\n\n\ne in A\nset membership (A contains element e)\n\n\ne notin A\nA does not contain element e\n\n\ncontains(A, e)\nA contains element e\n\n\ncard(A)\nthe cardinality of A (number of elements in A)\n\n\nincl(A, elem)\nsame as A = A + {elem}\n\n\nexcl(A, elem)\nsame as A = A - {elem}\n\n\n\n\nReference and pointer type\n\nThe . (access a tuple/object field operator) and  operators perform implicit dereferencing operations for reference types:\nTo allocate a new traced object, the built-in procedure new has to be used. To deal with untraced memory, the procedures alloc, dealloc and realloc can be used.\nSpecial care has to be taken if an untraced object contains traced objects like traced references, strings or sequences: in order to free everything properly, the built-in procedure GCunref has to be called before freeing the untraced memory manually:\nIf a reference points to nothing, it has the value nil.\ntype\n  Node = ref NodeObj\n\n  NodeObj = object\n    left, right: Node\n    data: int\n\nvar\n  x: Node\n  y: Node\n  z: Node\n\nnew(x)\nnew(y)\nnew(z)\nx.data = 9\nx.left = y\nx.right = z\n\nproc get_data(x: NodeObj): int =\n  return x.data\n\n# static error\n#echo(get_data(x))\nassert get_data(x[]) == 9\n\n{. experimental .}\nassert get_data(x) == 9\n\ntype\n  # the object type is anonymous\n  Node = ref object\n    left, right: Node\n    data: int\n\nvar\n  n: Node\nnew(n)\necho(repr(n))\n# --> ref 0x7f9e92e4c050 --> [left = nil, right = nil, data = 0]\necho(repr(n[]))\n# --> [left = nil, right = nil, data = 0]\n\ntype\n  Data = tuple[\n    x, y: int,\n    s: string,\n  ]\n\n# allocate memory for Data on the heap\nvar\n  # Without the GCunref call the memory allocated for the d.s string\n  # would never be freed. The example also demonstrates two important\n  # features for low level programming: the sizeof proc returns the\n  # size of a type or value in bytes.\n  # The cast operator can circumvent the type system: the compiler is\n  # forced to treat the result of the alloc0 call (which returns an\n  # untyped pointer) as if it would have the type ptr Data.\n  # Casting should only be done if it is unavoidable: it breaks type\n  # safety and bugs can lead to mysterious crashes.\n\n  # Note: The example only works because the memory is initialized to\n  # zero (alloc0 instead of alloc does this): d.s is thus initialized\n  # to nil which the string assignment can handle.\n  # One needs to know low level details like this when mixing garbage\n  # collected data with unmanaged memory.\n  d = cast[ptr Data](alloc0(sizeof(Data)))\n\n# create a new string on the garbage collected heap\nd.s = \"abc\"\n\n# tell the GC that the string is not needed anymore\nGCunref(d.s)\n\n# free the memory\ndealloc(d)\n\ntype\n  RequestObj {.inheritable.} = object\n    body: string\n  Request = ref RequestObj\n\n\nproc handle_varobj(r: var RequestObj) =\n  r.body = \"changed by handle_varobj\"\n\n\nproc handle_varobj_returning(r: var RequestObj): RequestObj =\n  r.body = \"changed by handle_varobj_returning\"\n  return r\n\n\nproc handle_ref(r: Request) =\n  r.body = \"changed by handle_ref\"\n\n\nvar\n  obj0: RequestObj = RequestObj(body: \"original\")\n  obj1: RequestObj = RequestObj(body: \"original\")\n\n\nassert obj0 == obj1\nassert obj0.addr != obj1.addr\nobj1 = obj0\nassert obj0 == obj1\nassert obj0.addr != obj1.addr\nobj1.body = \"x\"\nassert obj0 != obj1\nassert obj0.body != obj1.body\nhandle_varobj(obj0)\nassert obj0.body == \"changed by handle_varobj\"\nobj1 = handle_varobj_returning(obj0)\nassert obj0.body == obj1.body\nassert obj0 == obj1\nassert obj0.addr != obj1.addr\n\n\nvar\n  ref0: Request\n  ref1: Request\n\nnew(ref0)\nnew(ref1)\nassert ref0 != ref1\nassert ref0[] == ref1[]\nref1 = ref0\nref0.body = \"original\"\nassert ref0.body == ref1.body\nassert ref0 == ref1\nassert ref0.addr != ref1.addr\nassert ref0[] == ref1[]\nassert ref0[].addr == ref1[].addr\n\ntype\n  Obj = object\n    kind: string\n  ObjRef = ref Obj\n  ObjPtr = ptr Obj\n\nvar\n  obj = Obj(kind: \"Obj\")\n  obj_ref, obj_ref1 : ObjRef\n  obj_ptr, obj_ptr1 : ObjPtr\n\n\nnew(obj_ref)\nobj_ref.kind = \"ObjRef\"\n\nobj_ref1 = ObjRef(kind: \"ObjRef\") \n\nobj_ptr = cast[ptr Obj](alloc0(sizeof(Obj)))\nobj_ptr.kind = \"ObjPtr\"\n\nobj_ptr1 = create(Obj)\nobj_ptr1.kind = \"ObjPtr\"\n\n\necho(\"======== object ========\")\necho(\"obj = \", obj)\n# --> (kind: Obj)\necho(\"obj = \", repr obj)\n# --> [kind = 0x7f3ee921f050\"Obj\"]\necho(\"obj.addr = \", repr obj.addr)\n# --> ref 0x624170 --> [kind = 0x7f3ee921f050\"Obj\"]\necho(\"obj.addr.pointer = \", repr obj.addr.pointer)\n# --> 0x624170\nassert obj.addr[] == obj\nassert cast[ObjPtr](obj.addr.pointer)[] == obj\nassert cast[ptr Obj](obj.addr.pointer)[] == obj\n\necho(\"======== ref ========\")\necho(\"obj_ref = \", repr obj_ref)\n# --> ref 0x7f5d71971050 --> [kind = 0x7f5d71970078\"ObjRef\"]\necho(\"obj_ref.addr = \", repr obj_ref.addr)\n# --> ref 0x624168 --> ref 0x7f5d71971050 --> [kind = 0x7f5d71970078\"ObjRef\"]\necho(\"obj_ref.addr.pointer = \", repr obj_ref.addr.pointer)\n# --> 0x624168\nassert obj_ref.addr[] == obj_ref\nassert obj_ref.addr[][] == obj_ref[]\nassert cast[ptr ref Obj](obj_ref.addr)[] == obj_ref\nassert cast[ptr ref Obj](obj_ref.addr)[][] == obj_ref[]\n\necho(\"======== ptr ========\")\necho(\"obj_ptr = \", repr(obj_ptr))\n# ref 0x7f5d71971080 --> [kind = 0x7f5d719700c8\"ObjPtr\"]\necho(\"obj_ptr.pointer = \", repr(obj_ptr.pointer))\n# 0x7f5d71971080\nassert cast[ptr Obj](obj_ptr.pointer) == obj_ptr\nassert cast[ptr Obj](obj_ptr.pointer)[] == obj_ptr[]\n\n\n\nproc check(x: pointer): string =\n  \"pointer\"\n\n\nproc check(x: ptr int): string =\n  \"ptr int\"\n\nassert check(create(int)) == \"ptr int\"\n\nassert check(create(int).pointer) == \"pointer\"\n\n# `ptr` is implicitly convertible to `pointer`\nassert check(create(char)) == \"pointer\"\n\n\nproc check(x: ptr): string =\n  \"ptr\"\n\nassert check(create(char)) == \"ptr\"\n\n\nGCunref(obj_ptr.kind)\ndealloc(obj_ptr)\nGCunref(obj_ptr1.kind)\ndealloc(obj_ptr1)\n\n\nnot nil annotation\n\nAll types for that nil is a valid value can be annotated to exclude nil as a valid value with the not nil annotation:\ntype\n  Proc = ref ProcObj not nil\n  ProcObj = (proc (x, y: int)) not nil\n\nproc call_proc(x: ProcObj): string =\n  \"called\"\n\nproc call_proc(x: Proc): string =\n  \"called\"\n\nproc deal_str(s: string not nil): string =\n  \"called\"\n\nvar\n  proc_obj: ProcObj\n  proc_ref: Proc\n  s: string\n\n# static error\n#call_proc(nil)\n\nassert proc_obj.isNil\nassert call_proc(proc_obj) == \"called\"\n\nassert proc_ref.isNil\nassert call_proc(proc_ref) == \"called\"\n\n# static error\n#deal_str(nil)\n\nassert s.isNil\n#discard deal_str(s)\n# Error: cannot prove 's' is not null\n\n\nMemory regions\n\n\nProcedural type\n\ntype\n  Event {.pure.} = enum\n    starting,\n    started,\n    stopping,\n    stopped,\n    restarting,\n    restarted,\n\nproc callback_event(\n  e: Event,\n  callback: proc(e: Event),\n) =\n  callback(e)\n\nproc callback_event_varargs(\n  e: Event,\n  callbacks: varargs[proc(e: Event) {.nimcall.}],\n) =\n  for c in callbacks:\n    c(e)\n\nproc callback_event_openArray(\n  e: Event,\n  callbacks: openArray[proc(e: Event) {.nimcall.}],\n) =\n  for c in callbacks:\n    c(e)\n\nproc echo_callback0(\n  e: Event,\n) =\n  echo(\"Event: \", e)\n\nproc echo_callback1(\n  e: Event,\n): void {.nimcall.} =\n  echo(\"Event: \", e)\n\ncallback_event(Event.started, echo_callback0)\ncallback_event(Event.started, echo_callback1)\ncallback_event_varargs(Event.started, echo_callback0, echo_callback1)\ncallback_event_openArray(Event.started, @[echo_callback0, echo_callback1])\n\n\ntype\n  Request = ref object\n    data: string\n\nproc handle_request(\n  req: var Request,\n  c: proc(req: var Request),\n) =\n  c(req)\n\nproc addstr_handler(\n  req: var Request,\n): void =\n  req.data &=\" added\"\n  discard\n\nvar\n  req = Request(data: \"data\")\n\nhandle_request(req, addstr_handler)\nassert req.data == \"data added\"\n\ntype\n  Event {.pure.} = enum\n    starting,\n    started,\n    stopping,\n    stopped,\n    restarting,\n    restarted,\n\nproc callback_one(\n  e: Event,\n  callback: proc(e: Event),\n) =\n  callback(e)\n\nproc callback_varargs(\n  e: Event,\n  callbacks: varargs[proc(e: Event) {.closure.}],\n) =\n  for cb in callbacks:\n    cb(e)\n\nproc callback_openArray(\n  e: Event,\n  callbacks: openArray[proc(e: Event) {.closure.}],\n) =\n  for cb in callbacks:\n    cb(e)\n\nproc echo_cb0(e: Event) =\n  echo(\"Event: \", e)\n\nproc echo_cb1(e: Event) {.closure.} =\n  echo(\"Event: \", e)\n\ncallback_one(Event.started, echo_cb0)\n# static error (different calling convention)\n#callback_varargs(Event.started, echo_cb0)\n#callback_openArray(Event.started, echo_cb0)\ncallback_varargs(Event.started, echo_cb1)\ncallback_openArray(Event.started, [echo_cb1])\ncallback_openArray(Event.started, @[echo_cb1])\n\n\ntype\n  Request = ref object\n    data: string\n\nproc handle_request(\n  r: var Request,\n  handler: proc(r: var Request): string\n): string =\n  return handler(r)\n\nproc change_data_handler(\n  r: var Request,\n): string {.procvar.} =\n  r.data &=\" changed\"\n  return r.data\n\nvar\n  r = Request(data: \"data\")\n\nassert handle_request(r, change_data_handler) == \"data changed\"\nassert r.data == \"data changed\"\n\n\ndistinct type\ntype\n  Dollar* = distinct float\n\nvar\n  d: Dollar\n\n\n# static error\n#echo(d + 12)\n\nproc `$`*(x: Dollar): string =\n  result = \"$\" & $float(x)\n\nproc `==`*(x, y: Dollar): bool {.borrow.}\nproc `<=`*(x, y: Dollar): bool {.borrow.}\nproc `<`*(x, y: Dollar): bool {.borrow.}\n\n\nproc `+`*(x, y: Dollar): Dollar =\n  result = Dollar(float(x) + float(y))\n\n\nproc `-`*(x, y: Dollar): Dollar {.borrow.}\n\n\nproc `*`*(x: Dollar, y: float): Dollar {.borrow.}\nproc `*`*(x: float, y: Dollar): Dollar {.borrow.}\n\nproc `/`*(x: Dollar, y: float): Dollar {.borrow.}\n\n\nassert Dollar(2) + d == Dollar(2) * 1\n\ntemplate add_same_types(typ: typedesc): stmt =\n  proc `+`*(x, y: typ): typ {.borrow.}\n  proc `-`*(x, y: typ): typ {.borrow.}\n\n  # unary ops\n  proc `+`*(x: typ): typ {.borrow.}\n  proc `-`*(x: typ): typ {.borrow.}\n\n\ntemplate multiply_by_base_type(typ, base_typ: typedesc): stmt =\n  proc `*`*(x: typ, y: base_typ): typ {.borrow.}\n  proc `*`*(x: base_typ, y: typ): typ {.borrow.}\n  proc `/`*(x: typ, y: base_typ): typ {.borrow.}\n\n\ntemplate compare_same_types(typ: typedesc): stmt =\n  proc `==`*(x, y: typ): bool {.borrow.}\n  proc `<`*(x, y: typ): bool {.borrow.}\n  proc `<=`*(x, y: typ): bool {.borrow.}\n\n\ntemplate define_currency(typ, base_typ: expr): stmt =\n  type\n    typ* = distinct base_typ\n  add_same_types(typ)\n  multiply_by_base_type(typ, base_typ)\n  compare_same_types(typ)\n\n\ndefine_currency(Euro, float)\n\ntype\n  FooObj = object\n    i: int\n    s: string\n\n  BarObj {.borrow: `.`.} = distinct FooObj\n\n  Bar = ref BarObj\n\nvar\n  b: Bar\n\n\nnew(b)\nb.i = 1\nb.s = \"s\"\n\ntype\n  AltString = distinct string\n\n\nproc add *(x: var AltString, y: string) =\n  ## workaround: https://github.com/nim-lang/Nim/issues/3082\n  system.add(string(x), y)\n\nproc `&=` *(x: var AltString, y: string) =\n  ## workaround: https://github.com/nim-lang/Nim/issues/3082\n  system.`&=`(string(x), y)\n\n\nvar\n  a = AltString(\"altstring\")\n  b = a\n\nassert string(a) == \"altstring\"\nassert string(a) == string(b)\nstring(a)[0 .. 2] = \"\"\nassert repr(a) != repr(b)\nassert repr(a) == repr(string(a))\nassert repr(a) == repr(cast[string](a))\n\n\ntype\n  AltInt = distinct int\n\nvar\n  i = AltInt(1)\n\n\nint(i) += 1\nassert int(i) == 2\nassert repr(i) == repr(int(i))\nassert repr(i) == repr(cast[int](i))\n\n\nvoid type\nproc callProc[T: int|void](p: proc (x: T), x: T) =\n  when T is void:\n    p()\n  else:\n    p(x)\n\n\nproc intProc(x: int) =\n  echo(\"called intProc\")\n\n\nproc emptyProc() = discard\n\n\ncallProc[int](intProc, 12)\ncallProc(intProc, 12)\n\ncallProc[void](emptyProc)\n# static error: a void type can not be inferred in generic code.\n#callProc(emptyProc)\n\n\nStatements and Expressions\n\nstatement list expression\nvar str = (var x: seq[string] = @[]; for i in [0, 1, 2]: x.add($i); x)\necho str\nassert str == @[\"0\", \"1\", \"2\"]\n\nAll the other statements than list expression must be of type void. (One can use discard to produce a void type.) (;) does not introduce a new scope.\n\ndiscard statement\nproc p(x, y: int): int {.discardable.} =\n  x + y\n\np(1, 2)\n\n\n\n\nType\ndefault value\n\n\n\n\nany integer type\n0\n\n\nany float\n0.0\n\n\nchar\n'\\0'\n\n\nbool\nfalse\n\n\nref or pointer type\nnil\n\n\nprocedural type\nnil\n\n\nsequence\nnil (not @[])\n\n\nstring\nnil (not \"\")\n\n\ntuple[x: A, y: B, ...]\n(default(A), default(B), ...) (analogous for objects)\n\n\narray[0..., T]\n[default(T), ...]\n\n\nrange[T]\ndefault(T); this may be out of the valid range\n\n\nT = enum\ncastT; this may be an invalid value\n\n\n\n# http://forum.nim-lang.org/t/1429/\n# I'm not sure what you are expecting. {.noinit.} makes no guarantees\n# about the content of a variable, and for global variables, it will\n# generally result in the same initial value, anyway.\n# All that {.noinit.} says is that it won't explicitly assign default\n# values; the variable will still have some value.\n# In the case of global variables, whatever's associated with zeroed\n# memory; in the case of local variables, whatever's been on the stack\n# location/in the register.\n# For me, all the asserts work, and that's pretty much what I'd expect.\n\nvar\n  int_0: int\n  int_1 {.noInit.}: int\n  float_0: float\n  float_1 {.noInit.}: float\n  char_0: char\n  char_1 {.noInit.}: char\n  string_0: string\n  string_1 {.noInit.}: string\n  bool_0: bool\n  bool_1 {.noInit.}: bool\n  arr_0: array[0..2, int]\n  arr_1 {.noInit.}: array[0..2, int]\n  seq_0: seq[int]\n  seq_1 {.noInit.}: seq[int]\n  tuple_0: tuple[id: int]\n  tuple_1 {.noInit.}: tuple[id: int]\n  range_0: range[0 .. 2]\n  range_1 {.noInit.}: range[0 .. 2]\n  proc_0: proc (x: int)\n  proc_1 {.noInit.}: proc (x: int)\n\n\nassert int_0 == 0\nassert int_1 == 0\nassert float_0 == 0.0\nassert float_1 == 0.0\nassert char_0 == '\\x0'\nassert char_1 == '\\x0'\nassert string_0 == nil\nassert string_1 == nil\nassert bool_0 == false\nassert bool_1 == false\nassert arr_0 == [0, 0, 0]\nassert arr_1 == [0, 0, 0]\nassert seq_0 == nil\nassert seq_1 == nil\nassert tuple_0 == (id: 0)\nassert tuple_1 == (id: 0)\nassert range_0 == 0\nassert range_1 == 0\nassert proc_0 == nil\nassert proc_1 == nil\n\n\ntype\n  Obj = object\n    x: int\n    y: string\n\n  Ref = ref Obj\n\n\nvar\n  obj_0: Obj\n  obj_1 {.noInit.}: Obj\n  ref_0: Ref\n  ref_1 {.noInit.}: Ref\n\n\nassert obj_0.x == 0\nassert obj_0.y == nil\nassert obj_0 == obj_1\nassert ref_0 == nil\nassert ref_1 == nil\n\n\nproc procInt: int {.noInit.} =\n  echo(\"int: \", result)  # => 140732219179232\n\nassert procInt() != 0\n\n\nproc procFloat: float {.noInit.} =\n  echo(\"float: \", result)  # => 6.953095475945912e-310\n\nassert procFloat() != 0.0\n\n\nproc procChar: char {.noInit.} =\n  echo(\"char: \", repr(result))  # => '\\0'\n\nassert procChar() == '\\0'\n\n\nproc procString: string {.noInit.} =\n  echo(\"string: \", result)  # => 6.953095475945912e-310\n\nassert procString() != nil\n\n\nproc procBool: bool {.noInit.} =\n  echo(\"bool: \", result)  # => false\n\nassert procBool() == false\n\n\nproc procArray: array[0..2, int] {.noInit.} =\n  echo(\"array: \", repr(result))  # => [0, 0, 0]\n\nassert procArray() == [0, 0, 0]\n\n\n#proc procSeq: seq[int] {.noInit.} =\n#  echo(\"seq: \", repr(result))\n\n#assert procSeq() == nil\n\n\nproc procTuple: (int, int) {.noInit.} =\n  echo(\"tuple: \", result)  # => (Field0: 3, Field1: 2)\n\nassert procTuple() != (0, 0)\n\n\nproc procRange: range[0 .. 2] {.noInit.} =\n  echo(\"range: \", result)  # => 65536\n\nassert procRange() != 0\n\n\nproc procProc: (proc (x: int): string) {.noInit.} =\n  echo(\"proc: \", repr(result))  # => [Field0 = nil, Field1 = nil]\n\nassert procProc() == nil\n\n\nlet statement\nlet\n  x: array[0..2, int] = [0, 1, 2]\n  y: int = 3\n\n# static error: can not take the address\n#echo(repr(x.addr))\n#echo(repr(y.addr))\n\n\ntuple unpacking\nproc returnTuple: (int, int, int) =\n  (0, 1, 2)\n\nvar\n  (a, _, c) = returnTuple()\n  d, e, f = returnTuple()\n\nassert a == 0\nassert c == 2\nassert d == (0, 1, 2)\nassert e == (0, 1, 2)\nassert f == (0, 1, 2)\n\n\nconst section\n\nstatic statement/expression\n\nif statement\nA new scope starts for the if/elif condition and ends after the corresponding then block:\nif {| (let m = input =~ re\"(\\w+)=\\w+\"; m.isMatch):\n  echo \"key \", m[0], \" value \", m[1]  |}\nelif {| (let m = input =~ re\"\"; m.isMatch):\n  echo \"new m in this scope\" |}\nelse:\n  # 'm' not declared here\n\nIn the example the scopes have been enclosed in {| |}.\n\ncase statement\nlet\n  i = 1\n\ncase i:\n  of 0 .. 2, 3 .. 4:\n    echo(\"0 .. 2, 3 .. 4\")\n  of 5, 6:\n    echo(\"5, 6\")\n  of 7 .. 9:\n    echo(\"7 .. 9\")\n  else:\n    discard\n\n\nlet\n  r: range[0 .. 9] = 3\n\ncase r:\n  of 0 .. 2, 3 .. 4:\n    echo(\"0 .. 2, 3 .. 4\")\n  of 5, 6:\n    echo(\"5, 6\")\n  of 7 .. 9:\n    echo(\"7 .. 9\")\n\n\nconst\n  SymChars: set[char] = {'a' .. 'z', 'A' .. 'Z', '\\x80' .. '\\xff'}\n\nvar\n  c = 'x'\n\ncase c:\n  of SymChars, '_':\n    echo(\"an identifier\")\n  of '0' .. '9':\n    echo(\"a number\")\n  else:\n    echo(\"other\")\n\n\ntype\n  Direction = enum\n    north, south, east, west\n\nvar\n  e = north\n\ncase e:\n  of {Direction.low .. Direction(1)}:\n    echo(\"north or south\")\n  of east .. west:\n    echo(\"east or west\")\n\n\nwhen statement\nwhen sizeof(int) == 2:\n  echo(\"running on a 16 bit system!\")\nelif sizeof(int) == 4:\n  echo(\"running on a 32 bit system!\")\nelif sizeof(int) == 8:\n  echo(\"running on a 64 bit system!\")\nelse:\n  echo(\"cannot happen!\")\n\n\nreturn statement\n\nyield statement\niterator itercount(start, last:int): int =\n  var i = start\n  while i <= last:\n    yield i\n    inc(i)\n\nfor i in itercount(0, 3):\n  echo(i)\n\n\nblock statement\nvar\n  found: bool = false\n  arr: array[\n    0 .. 2,\n    array[0 .. 2, int]\n  ] = [\n    [0,1,2],\n    [0,1,2],\n    [0,1,7],\n  ]\nblock myblock:\n  for i in 0 .. 2:\n    for j in 0 .. 2:\n      if arr[j][i] == 7:\n        found = true\n        break myblock\n\nassert found == true\n\n\nbreak statement\nvar\n  input: string\n\nwhile true:\n  input = readline(stdin)\n  if input.len > 0:\n    break\n\necho(input)\n\n\ncontinue statement\nwhile expr1:\n  stmt1\n  continue\n  stmt2\n\nIs equivalent to:\nwhile expr1:\n  block myBlockName:\n    stmt1\n    break myBlockName\n    stmt2\n\n\nif expression\nvar\n  a = 7\n  x = if a > 20: 20 elif a > 10: 10 else: 0\n  y =\n    if a > 20:\n      20\n    elif a > 10:\n      10\n    else:\n      0\n  z = if a > 20: 20\n    elif a > 10: 10\n    else: 0\n\nassert x == 0\nassert y == 0\nassert z == 0\n\n\nwhen expression\nvar\n  x = when sizeof(int) == 2: \"16bit\" elif sizeof(int) == 4: \"32bit\" elif sizeof(int) == 8: \"64bit\" else: \"unknown\"\n  y =\n    when sizeof(int) == 2:\n      \"16bit\"\n    elif sizeof(int) == 4:\n      \"32bit\"\n    elif sizeof(int) == 8:\n      \"64bit\"\n    else:\n      \"unknown\"\n  z = when sizeof(int) == 2: \"16bit\"\n    elif sizeof(int) == 4: \"32bit\"\n    elif sizeof(int) == 8:\"64bit\"\n    else: \"unknown\"\n\n\ncase expression\nimport strutils\n\nvar\n  animal = \"unknown\"\n  x =\n    case animal\n    of \"dog\": \"bones\"\n    of \"cat\": \"mice\"\n    elif animal.endsWith\"whale\": \"plankton\"\n    else:\n      echo \"I'm not sure what to serve, but everybody loves ice cream\"\n      \"ice cream\"\n  y =\n    case animal\n    of \"dog\":\n      \"bones\"\n    of \"cat\":\n      \"mice\"\n    elif animal.endsWith\"whale\":\n      \"plankton\"\n    else:\n      echo \"I'm not sure what to serve, but everybody loves ice cream\"\n      \"ice cream\"\n\nThe case expression can also introduce side effects. When multiple statements are given for a branch, Nim will use the last expression as the result value, much like in an expr template.\n\ntable constructor\n\nThe order of the (key,value)-pairs is preserved, thus it is easy to support ordered dicts with for example {key: val}.newOrderedTable.\nA table literal can be put into a const section and the compiler can easily put it into the executable's data section just like it can for arrays and the generated data section requires a minimal amount of memory.\nEvery table implementation is treated equal syntactically.\nApart from the minimal syntactic sugar the language core does not need to know about tables.\n\nconst\n  x = {\"key1\": \"value1\", \"key2\", \"key3\": \"value2\"}\n\nassert x == [(\"key1\", \"value1\"), (\"key2\", \"value2\"), (\"key3\", \"value2\")]\n\n\nimport tables\n\nconst\n  s = x.newOrderedTable\n\n\ntype conversions\nSyntactically a type conversion is like a procedure call, but a type name replaces the procedure name. A type conversion is always safe in the sense that a failure to convert a type to another results in an exception (if it cannot be determined statically).\nOrdinary procs are often preferred over type conversions in Nim: For instance, $ is the toString operator by convention and toFloat and toInt can be used to convert from floating point to integer or vice versa.\n\ntype casts\ncast[int](x)\n\nType casts are a crude mechanism to interpret the bit pattern of an expression as if it would be of another type. Type casts are only needed for low-level programming and are inherently unsafe.\n\naddr operator\nThe addr operator returns the address of an l-value. If the type of the location is T, the addr operator result is of the type ptr T. An address is always an untraced reference. Taking the address of an object that resides on the stack is unsafe, as the pointer may live longer than the object on the stack and can thus reference a non-existing object. One can get the address of variables, but one can't use it on variables declared through let statements:\nlet s0 = \"Hello\"\n\nvar\n  s1 = s0\n  p0 : pointer = addr(s1)\n  ptr0 : ptr = addr(s1)\n  ptr1 : ptr string = addr(s1)\n\nassert p0 == ptr0\nassert ptr0 == ptr1\n\n\necho(repr(p0))\n# --> 0x622c58\n\necho(repr(cast[ptr string](p0)))\n# --> ref 0x622c58 --> 0x7f20a4a1d078\"Hello\"\n\necho(repr(ptr0))\n# --> ref 0x622c58 --> 0x7f20a4a1d078\"Hello\"\n\necho(repr(ptr1))\n# --> ref 0x622c58 --> 0x7f20a4a1d078\"Hello\"\n\n\necho repr(addr(s1))\n# --> ref 0x622c58 --> 0x7f20a4a1d078\"Hello\"\n\necho cast[ptr string](p0)[]\n# --> Hello\n\n\n# The following line doesn't compile:\n#echo repr(addr(s0))\n# Error: expression has no address\n\n\nprocedure\nOperators are procedures with a special operator symbol as identifier:\nimport strutils\n\nproc `$` (x: int): string =\n  # converts an integer to a string; this is a prefix operator.\n  result = intToStr(x)\n\nOperators with one parameter are prefix operators, operators with two parameters are infix operators. (However, the parser distinguishes these from the operator's position within an expression.) There is no way to declare postfix operators: all postfix operators are built-in and handled by the grammar explicitly.\nAny operator can be called like an ordinary proc with the 'opr' notation. (Thus an operator can have more than two parameters):\nproc `*+` (a, b, c: int): int =\n  # Multiply and add\n  result = a * b + c\n\nassert `*+`(3, 4, 6) == `+`(`*`(3, 4), 6)\n\n\nexport marker\nproc exportedEcho*(s: string) = echo s\n\nproc `*`*(a: string; b: int): string =\n  result = newStringOfCap(a.len * b)\n  for i in 1..b:\n    result.add a\n\nassert \"ABC\" * 3 == \"ABCABCABC\"\n\n\nvar\n  exportedVar*: int\n\nconst\n  exportedConst* = 78\n\ntype\n  ExportedType* = object\n    exportedField*: int\n\n\nmethod call syntax\nimport strutils\n\necho(\"abc\".len)\n# is the same as echo(len(\"abc\"))\n\necho(\"abc\".toUpper())\n\necho({'a', 'b', 'c'}.card)\n\nstdout.writeln(\"Hallo\")\n# the same as writeln(stdout, \"Hallo\")\n\n\nproperties\ntype\n  Socket* = ref object of RootObj\n    FHost: int # cannot be accessed from the outside of the module\n               # the `F` prefix is a convention to avoid clashes since\n               # the accessors are named `host`\n\nproc host*(s: Socket): int {.inline.} =\n  ## getter of hostAddr\n  s.FHost\n\n\nproc `host=`*(s: var Socket, value: int) {.inline.} =\n  ## setter of hostAddr\n  s.FHost = value\n\n\nvar\n  s: Socket\n\nnew(s)\n\ns.host = 34\n# same as `host=`(s, 34)\n\nassert s.host == 34\n\n\nclosure\nproc create_closure_seq(count: Positive): seq[proc: int] =\n  newSeq(result, count)\n  #for i in 0 .. count - 1:\n  for i in countup(0, count - 1):\n    result[i] = proc: int = int(i)\n\n\nvar\n  result = (var a: array[0..2, int]; for i, p in create_closure_seq(3).pairs: a[i] = p(); a)\n\nassert result == [2, 2, 2]\n\n\nanonymous procedure\nimport algorithm\n\n\nvar\n  cities = @[\"Frankfurt\", \"Tokyo\", \"New York\"]\n\ncities.sort(proc (x,y: string): int =\n    cmp(x.len, y.len))\n\n\nassert cities == @[\"Tokyo\", \"New York\", \"Frankfurt\"]\n\n\nnonoverloadable builtins\ndeclared, defined, definedInScope, compiles, low, high, sizeOf, is, of, shallowCopy, getAst, astToStr, spawn, procCall\n\nThus they act more like keywords than like ordinary identifiers; unlike a keyword however, a redefinition may shadow the definition in the system module. From this list the following should not be written in dot notation x.f since x cannot be type checked before it gets passed to f:\ndeclared, defined, definedInScope, compiles, getAst, astToStr\n\n\nvar parameters\nproc divmod(a, b: int; res, remainder: var int) =\n  res = a div b\n  remainder = a mod b\n\nvar\n  x, y: int\n\ndivmod(8, 5, x, y) # modifies x and y\n\nassert x == 1\nassert y == 3\n\nThe argument passed to a var parameter has to be an l-value. Var parameters are implemented as hidden pointers.\nThe above example is equivalent to:\nproc divmod(a, b: int; res, remainder: ptr int) =\n  res[] = a div b\n  remainder[] = a mod b\n\nvar\n  x, y: int\n\ndivmod(8, 5, addr(x), addr(y))\n\nassert x == 1\nassert y == 3\n\nThis can be done in a cleaner way by returning a tuple.\nproc divmod(a, b: int): tuple[res, remainder: int] =\n  result.res = a div b\n  result.remainder = a mod b\n\n\nvar\n  t = divmod(8, 5)\n\nassert t.res == 1\nassert t.remainder == 3\n\n\nvar\n  (res, remainder) = divmod(8, 5)\n\nassert res == 1\nassert remainder == 3\n\nNote: var parameters are never necessary for efficient parameter passing. Since non-var parameters cannot be modified the compiler is always free to pass arguments by reference if it considers it can speed up execution.\n\nvar return type\nA proc, converter or iterator may return a var type which means that the returned value is an l-value and can be modified by the caller:\nvar g = 0\n\nproc WriteAccessToG(): var int =\n  result = g\n\nWriteAccessToG() = 6\n\nassert g == 6\n\nIt is a compile time error if the implicitly introduced pointer could be used to access a location beyond its lifetime:\n# static error: address of 'g' may not escape its stack frame\nproc WriteAccessToG(): var int =\n  var g = 0\n  result = g # Error!\n\nFor iterators, a component of a tuple return type can have a var type too:\nvar\n  sq = @[\"a\", \"b\", \"c\"]\n\n\n# static error: 'str[0]' cannot be assigned to\n#for i, str in sq.pairs:\n#  str[0] = 'x'\n\n\nfor i, str in sq.mpairs:\n  str[0] = 'x'\n\n\nassert sq == @[\"x\", \"x\", \"x\"]\n\n\n# same iterator as built-in mpairs\niterator custom_mpairs(a: var seq[string]): tuple[key: int, val: var string] =\n  for i in 0..a.high:\n    yield (i, a[i])\n\n\nfor i, str in sq.custom_mpairs:\n  str.add(\"y\")\n\n\nassert sq == @[\"xy\", \"xy\", \"xy\"]\n\n\nvar\n  arr: array[\n    0..2, \n    array[0..2, int],\n  ] = [\n    [0, 1, 2],\n    [0, 1, 2],\n    [0, 1, 2],\n  ]\n\n\n# static error: 'item[0]' cannot be assigned to\n#for item in arr.items:\n#  item[0] = 2\n\n\nfor item in arr.mitems:\n  item[0] = 2\n\n\nassert arr[0] == [2, 1, 2]\n\nIn the standard library every name of a routine that returns a var type starts with the prefix m per convention.\n\nOverloading of the subscript operator\nThe [] subscript operator for arrays/openarrays/sequences can be overloaded.\n\nMulti-methods\nProcedures always use static dispatch. Multi-methods use dynamic dispatch.\ntype\n  Expression = ref object of RootObj ## abstract base class for an expression\n  Literal = ref object of Expression\n    x: int\n  PlusExpr = ref object of Expression\n    a, b: Expression\n\n\nmethod eval(e: Expression): int =\n  # override this base method\n  quit \"to override!\"\n\n\nmethod eval(e: Literal): int = return e.x\n\n\nmethod eval(e: PlusExpr): int =\n  # watch out: relies on dynamic binding\n  result = eval(e.a) + eval(e.b)\n\n\nproc newLit(x: int): Literal =\n  new(result)\n  result.x = x\n\n\nproc newPlus(a, b: Expression): PlusExpr =\n  new(result)\n  result.a = a\n  result.b = b\n\n\nassert eval(\n  newPlus(\n    newPlus(\n      newLit(1), newLit(2)\n    ),\n    newLit(4)\n  )\n) == 7\n\ntype\n  Thing = ref object of RootObj\n  Unit = ref object of Thing\n    x: int\n\n\nmethod collide(a, b: Thing): int {.inline.} =\n  quit \"to override!\"\n\n\nmethod collide(a: Thing, b: Unit): int {.inline.} =\n  return 1\n\n\nmethod collide(a: Unit, b: Thing): int {.inline.} =\n  return 2\n\n\nvar a, b: Unit\nnew a\nnew b\n\nassert collide(a, b) == 2\n\nInvocation of a multi-method cannot be ambiguous: collide 2 is preferred over collide 1 because the resolution works from left to right. In the example (Unit, Thing) is preferred over (Thing, Unit).\nPerformance note: Nim does not produce a virtual method table, but generates dispatch trees. This avoids the expensive indirect branch for method calls and enables inlining. However, other optimizations like compile time evaluation or dead code elimination do not work with methods.\nimport math\n\ntype\n  Dollar* = distinct float\n\n  Kg* = distinct float\n\n  Fruit* = ref object {.inheritable.}\n    origin*: string\n    price*: Dollar\n\n  Banana* = ref object of Fruit\n    size*: int\n\n  Pumpkin* = ref object of Fruit\n    weight*: Kg\n\n  BigPumpkin* = ref object of Pumpkin\n\n  Bucket* {.inheritable.} = ref object\n    fruits*: seq[string]\n\n\n# op proc\nproc `$` *(x: Dollar): string {.borrow.}\n\nproc `$` *(x: Kg): string {.borrow.}\n\nproc `==` *(x, y: Dollar): bool {.borrow, inline.}\n\n\n# op method\nmethod `$`*(self: Fruit): string =\n  \"Fruit: origin='\" & self.origin & \", price=\" & $self.price\n\nmethod `$`*(self: Banana): string =\n  result = procCall($Fruit(self)) & \", size=\" & $self.size\n  result[0 .. 4] = \"Banana\"\n\nmethod `$`*(self: Pumpkin): string =\n  result = procCall($Fruit(self)) & \", weight=\" & $self.weight\n  result[0 .. 4] = \"Pumpkin\"\n\nmethod `$`*(self: BigPumpkin): string =\n  result = procCall($Fruit(self)) & \", weight=\" & $self.weight\n  result[0 .. 4] = \"BigPumpkin\"\n\n\n# reduction method\nmethod reduction_m(self: Fruit): Dollar =\n  echo(\n    \"Called Fruit.reduction_m (\" & $self & \")\"\n  )\n  Dollar(0)\n\nmethod reduction_m(self: Banana): Dollar =\n  echo(\n    \"Called Banana.reduction_m (\" & $self & \")\"\n  )\n  Dollar(9)\n\nmethod reduction_m(self: Pumpkin): Dollar =\n  echo(\n    \"Called Pumpkin.reduction_m (\" & $self & \")\"\n  )\n  Dollar(1)\n\n\n# reduction proc\nproc reduction_p(self: Fruit): Dollar =\n  echo(\n    \"Called Fruit.reduction_p (\" & $self & \")\"\n  )\n  Dollar(0)\n\nproc reduction_p(self: Banana): Dollar =\n  echo(\n    \"Called Banana.reduction_p (\" & $self & \")\"\n  )\n  Dollar(9)\n\nproc reduction_p(self: Pumpkin): Dollar =\n  echo(\n    \"Called Pumpkin.reduction_p (\" & $self & \")\"\n  )\n  Dollar(1)\n\n\n\n# calcPrice method\nmethod calcPrice_m*(self: Fruit): Dollar =\n  echo(\n    \"Called Fruit.calcPrice_m (\" & $self & \")\"\n  )\n  Dollar(round(float(self.price) * 100) / 100 - float(self.reduction_m))\n\nmethod calcPrice_m*(self: Banana): Dollar =\n  echo(\n    \"Called Banana.calcPrice_m (\" & $self & \")\"\n  )\n  procCall Fruit(self).calcPrice_m()\n\nmethod calcPrice_m*(self: Pumpkin): Dollar =\n  echo(\n    \"Called Pumpkin.calcPrice_m (\" & $self & \")\"\n  )\n  Dollar(float(procCall(Fruit(self).calcPrice_m())) * float(self.weight))\n\nmethod calcPrice_m*(self: Bigpumpkin): Dollar =\n  echo(\n    \"Called Bigpumpkin.calcPrice_m (\" & $self & \")\"\n  )\n  Dollar(1000)\n\n\n# calcPrice proc\nproc calcPrice_p*(self: Fruit): Dollar =\n  echo(\n    \"Called Fruit.calcPrice_p (\" & $self & \")\"\n  )\n  Dollar(round(float(self.price) * 100) / 100 - float(self.reduction_p))\n\nproc calcPrice_p*(self: Banana): Dollar =\n  echo(\n    \"Called Banana.calcPrice_p (\" & $self & \")\"\n  )\n  calcPrice_p(Fruit(self))\n\nproc calcPrice_p*(self: Pumpkin): Dollar =\n  echo(\n    \"Called Pumpkin.calcPrice_p (\" & $self & \")\"\n  )\n  Dollar(float(calcPrice_p(Fruit(self))) * float(self.weight))\n\nproc calcPrice_p*(self: Bigpumpkin): Dollar =\n  echo(\n    \"Called Bigpumpkin.calcPrice_p (\" & $self & \")\"\n  )\n  Dollar(1000)\n\n\n# add method\nmethod add(self: Bucket, fruit: Fruit) =\n  echo(\n    \"Called Bucket.Add (\" & $fruit & \")\"\n  )\n  self.fruits.add($fruit)\n\nmethod add(self: Bucket, fruit: Banana) =\n  echo(\n    \"Called Bucket.Add (\" & $fruit & \")\"\n  )\n  procCall self.add(Fruit(fruit))\n\nmethod add(self: Bucket, fruit: Pumpkin) =\n  echo(\n    \"Called Bucket.add (\" & $fruit & \")\"\n  )\n  procCall self.add(Fruit(fruit))\n\n\n# Constructor\nproc newBanana*(size: int, origin: string, price: float): Banana =\n  new(result)\n  result.origin = origin\n  result.price = Dollar(price)\n  result.size = size\n\nproc newPumpkin*(weight: float, origin: string, price: float): Pumpkin =\n  new(result)\n  result.origin = origin\n  result.price = Dollar(price)\n  result.weight = Kg(weight)\n\nproc newBigPumpkin*(weight: float, origin: string, price: float): BigPumpkin =\n  new(result)\n  result.origin = origin\n  result.price = Dollar(price)\n  result.weight = Kg(weight)\n\nproc newBucket(): Bucket =\n  new(result)\n  result.fruits = newSeq[string]()\n\n\nif isMainModule:\n  var banana = newBanana(size=10, origin=\"country_0\", price=1000)\n  var pumpkin = newPumpkin(weight=100, origin=\"country_1\", price=10000)\n  var big_pumpkin = newBigPumpkin(weight=1000, origin=\"country_1\", price=20000)\n\n  assert banana.calcPrice_m() == 991.0.Dollar\n  # --> Called Banana.calcPrice_m (Banana: origin='country_0, price=1000.0, size=10)\n  # --> Called Fruit.calcPrice_m (Banana: origin='country_0, price=1000.0, size=10)\n  # --> Called Banana.reduction_m (Banana: origin='country_0, price=1000.0, size=10)\n\n  assert banana.calcPrice_p() == 1000.0.Dollar\n  # --> Called Banana.calcPrice_p (Banana: origin='country_0, price=1000.0, size=10)\n  # --> Called Fruit.calcPrice_p (Banana: origin='country_0, price=1000.0, size=10)\n  # --> Called Fruit.reduction_p (Banana: origin='country_0, price=1000.0, size=10)\n\n  assert pumpkin.calcPrice_m() == 999900.0.Dollar\n  # --> Called Pumpkin.calcPrice_m (Pumpkin: origin='country_1, price=10000.0, weight=100.0)\n  # --> Called Fruit.calcPrice_m (Pumpkin: origin='country_1, price=10000.0, weight=100.0)\n  # --> Called Pumpkin.reduction_m (Pumpkin: origin='country_1, price=10000.0, weight=100.0)\n\n  assert pumpkin.calcPrice_p() == 1000000.0.Dollar\n  # --> Called Pumpkin.calcPrice_p (Pumpkin: origin='country_1, price=10000.0, weight=100.0)\n  # --> Called Fruit.calcPrice_p (Pumpkin: origin='country_1, price=10000.0, weight=100.0)\n  # --> Called Fruit.reduction_p (Pumpkin: origin='country_1, price=10000.0, weight=100.0)\n\n  var bucket = newBucket()\n  bucket.add(banana)\n  # --> Called Bucket.Add (Banana: origin='country_0, price=1000.0, size=10)\n  # --> Called Bucket.Add (Banana: origin='country_0, price=1000.0, size=10)\n\n  bucket.add(pumpkin)\n  # --> Called Bucket.add (Pumpkin: origin='country_1, price=10000.0, weight=100.0)\n  # --> Called Bucket.Add (Pumpkin: origin='country_1, price=10000.0, weight=100.0)\n  bucket.add(big_pumpkin)\n  # --> Called Bucket.add (BigPumpkin: origin='country_1, price=20000.0, weight=1000.0)\n  # --> Called Bucket.Add (BigPumpkin: origin='country_1, price=20000.0, weight=1000.0)\n  echo($bucket.fruits)\n  # --> @[Banana: origin='country_0, price=1000.0, size=10, Pumpkin: origin='country_1, price=10000.0, weight=100.0, BigPumpkin: origin='country_1, price=20000.0, weight=1000.0]\n\n\niterators and for statement\niterator triples *(s: string): (Natural, int, char) {.inline.} =\n  var i = 0\n  while i < len(s):\n    yield (i.Natural, ord(s[i]), s[i])\n    inc(i)\n\n\nvar q = newSeq[(int, char)](2)\n\nfor i, o, c in \"hi\".triples:\n  q[i] = (o, c)\n\nassert q == @[(104, 'h'), (105, 'i')]\n\n\nimplicit items/pairs invocation\n\nfirst class iterators\n\ninline iterator\nInline iterators are second class citizens; They can be passed as parameters only to other inlining code facilities like templates, macros and other inline iterators.\nclosure iterator\nCan be passed around more freely.\n\nrestrictions:\n\n\nyield in a closure iterator can not occur in a try statement.\nFor now, a closure iterator cannot be evaluated at compile time.\n\nreturn is allowed in a closure iterator (but rarely useful).\nBoth inline and closure iterators cannot be recursive.\n\nIterators that are neither marked {.closure.} nor {.inline.} explicitly default to being inline, but that this may change in future versions of the implementation.\nThe iterator type is always of the calling convention closure implicitly; the following example shows how to use iterators to implement a collaborative tasking system:\niterator count0(): int {.closure.} =\n  yield 0\n\n\niterator count2(): int {.closure.} =\n  var x = 1\n  yield x\n  inc x\n  yield x\n\n\nproc invoke(iter: iterator(): int {.closure.}): seq[int] =\n  newSeq(result, 0)\n  for x in iter():\n    result.add(x)\n\n\nassert invoke(count0) == @[0]\nassert invoke(count2) == @[1, 2]\n\nimport sequtils\n\ntype\n  Task = iterator (ticker: int)\n\niterator a1(ticker: int) {.closure.} =\n  echo \"a1: A\"\n  yield\n  echo \"a1: B\"\n  yield\n  echo \"a1: C\"\n\niterator a2(ticker: int) {.closure.} =\n  echo \"a2: A\"\n  yield\n  echo \"a2: B\"\n  yield\n  echo \"a2: C\"\n  yield\n  echo \"a2: D\"\n  yield\n  echo \"a2: E\"\n  yield\n  echo \"a2: F\"\n\niterator a3(ticker: int) {.closure.} =\n  echo \"a3: A\"\n  yield\n  echo \"a3: B\"\n  yield\n  echo \"a3: C\"\n\n\nproc runTasks(tasks: varargs[Task]) =\n  var\n    task_seq: seq[Task] = toSeq(tasks.items)\n    ticker = 0\n\n  while true:\n    let\n      x = task_seq[ticker]\n\n    x(ticker)\n\n    if finished(x):\n      task_seq.delete(ticker)\n      if task_seq.len == 0:\n        break\n      elif ticker >= task_seq.high:\n        ticker = 0\n    else:\n      ticker = (ticker + 1) mod task_seq.len\n\n\nrunTasks(a1, a2, a3)\n\nThe builtin system.finished can be used to determine if an iterator has finished its operation; no exception is raised on an attempt to invoke an iterator that has already finished its work.\nNote that system.finished is error prone to use because it only returns true one iteration after the iterator has finished:\niterator mycount(a, b: int): int {.closure.} =\n  var x = a\n  while x <= b:\n    yield x\n    inc x\n\nvar\n  c = mycount # instantiate the iterator\n  result: seq[int] = @[]\n\nwhile not finished(c):\n  result.add(c(1, 3))\n\n\nassert result == @[1, 2, 3, 0]\n# The last '0' is not intended value.\n\nInstead this code has be used;\niterator mycount(a, b: int): int {.closure.} =\n  var x = a\n  while x <= b:\n    yield x\n    inc x\n\nvar\n  c = mycount # instantiate the iterator\n  result: seq[int] = @[]\n\nwhile true:\n  let value = c(1, 3)\n  if finished(c):\n    break # and discard 'value'!\n  result.add(value)\n\n\nassert result == @[1, 2, 3]\n\nIt helps to think that the iterator actually returns a pair (value, done) and finished is used to access the hidden done field.\nClosure iterators are resumable functions and so one has to provide the arguments to every call. To get around this limitation one can capture parameters of an outer factory proc:\nproc mycount(a, b: int): iterator: (int, int) =\n  result = iterator: (int, int) =\n    var x = a\n    while x <= b:\n      yield (x, x)\n      inc(x)\n\nvar\n  result: seq[int] = @[]\nlet\n  c = mycount(1, 3)\n\n\nfor a, b in c():\n  result.add(a)\n\nassert result == @[1, 2, 3]\n\n\nconverters\n\nType sections\ntype # example demonstrating mutually recursive types\n  Node = ref NodeObj # a traced pointer to a NodeObj\n  NodeObj = object\n    le, ri: Node     # left and right subtrees\n    sym: ref Sym     # leaves contain a reference to a Sym\n\n  Sym = object       # a symbol\n    name: string     # the symbol's name\n    line: int        # the line the symbol was declared in\n    code: Node      # the symbol's abstract syntax tree\n\n\n# http://forum.nim-lang.org/t/1422\ntype\n  Obj = object\n    x: int\n    y: int\n\n  Ref = ref Obj\n\n  RefOrObj = Ref or Obj\n\n\nproc init(arg: var RefOrObj, x, y: int) =\n  when arg is ref:\n    new(arg)\n  arg.x = x\n  arg.y = y\n\n\nproc sum(arg: RefOrObj): int =\n  arg.x + arg.y\n\n\nproc main() =\n  var\n    o: Obj\n    r: Ref\n\n  init(o, 1, 1)\n  assert sum(o) == 2\n\n  init(r, 2, 2)\n  assert sum(r) == 4\n\nmain()\n\nA type section begins with the type keyword. It contains multiple type definitions. A type definition binds a type to a name. Type definitions can be recursive or even mutually recursive. Mutually recursive types are only possible within a single type section. Nominal types like objects or enums can only be defined in a type section.\n\nException handling\n\ntry statement\nimport strutils\n\nvar\n  f: File\n\nif open(f, \"/root/.bashrc\"):\n  try:\n    var a = readLine(f)\n    var b = readLine(f)\n    echo(\"sum: \" & $(parseInt(a) + parseInt(b)))\n  except Exception:\n    echo(\"Catch all !\")\n    let\n      exc = getCurrentException()\n      desc = \": parent=\" & repr(exc.parent) & \", msg=\" & exc.msg\n\n    if exc of ValueError:\n      # could not convert string to integer\n      echo(\"could not convert string to integer. ValueError\", desc)\n    elif exc of OverflowError:\n      echo(\"overflow!. OverflowError\", desc)\n    elif exc of IOError:\n      echo(\"IO error!. IOError\", desc)\n    else:\n      echo(\"Unknown exception!: Exception\", desc)\n\n  # no-op\n  except OverflowError:\n    echo(\"overflow!\")\n  except ValueError:\n    echo(\"could not convert string to integer\")\n  except IOError:\n    echo(\"IO error!\")\n  except:\n    echo(\"Unknown exception!\")\n  finally:\n    close(f)\n\n\nTry expression\nimport strutils\n\nlet\n  x = try: parseInt(\"133a\")\n    except: -1\n    finally: echo \"parseInt finished\"\n\nassert x == -1\n\n\nlet\n  y =\n    try:\n      parseint(\"133a\")\n    except:\n       -1\n    finally:\n      echo \"parseInt finished\"\n\nassert y == -1\n\nTo prevent confusing code there is a parsing limitation; if the try follows a ( it has to be written as a one liner\nimport strutils\n\nlet\n  x = (try: parseInt(\"133a\") except: -1 finally: echo \"parseInt finished\")\n\n\nassert x == -1\n\n\nExcept clauses\nNote that getCurrentException always returns a ref Exception type. If a variable of the proper type is needed (in the example above, IOError), one must convert it explicitly:\nimport strutils\n\nvar\n  x: int\n\n\ntry:\n  x = parseInt(\"133a\")\nexcept ValueError:\n  let\n    ref_exc = getCurrentException()\n    exc = (ref ValueError)(getCurrentException())\n  echo(repr(ref_exc))\n  echo(repr(exc))\n  assert ref_exc == exc\n\n\ntry:\n  x = parseInt(\"133a\")\nexcept ValueError:\n  echo(\"ValueError: \", getCurrentExceptionMsg())\n\n\nDefer statement\nInstead of a try finally statement a defer statement can be used.\nAny statements following the defer in the current block will be considered to be in an implicit try block:\nTop level defer statements are not supported since it's unclear what such a statement should refer to.\nimport streams\n\n\nproc withDefer() =\n  var\n    f: File\n\n  if f.open(filename=\"/tmp/numbers.txt\", mode=FileMode.fmWrite):\n    defer:\n      close(f)\n\n    f.write(\"abc\")\n    f.write(\"abc\")\n    f.write(\"\\n\")\n\nwithDefer()\n\n\nproc sameAsDefer() =\n  var\n    f: File\n\n  if f.open(filename=\"/tmp/numbers.txt\", mode=FileMode.fmWrite):\n    try:\n      f.write(\"abc\")\n      f.write(\"def\")\n      f.write(\"\\n\")\n    finally:\n      f.close()\n\nsameAsDefer()\n\n\nRaise statement\nThe raise statement is the only way to raise an exception.\nIf no exception name is given, the current exception is re-raised. The ReraiseError exception is raised if there is no exception to re-raise. It follows that the raise statement always raises an exception (unless a raise hook has been provided).\nraise newException(OSError, \"OS error\")\n\n\nEffect system\n\nException tracking\nThe raises pragma can be used to explicitly define which exceptions a proc/iterator/method/converter is allowed to raise. The compiler verifies this.\nAn empty raises list (raises: []) means that no exception may be raised.\nproc p(what: bool) {.raises: [IOError, OSError].} =\n  if what:\n    raise newException(IOError, \"IO\")\n  else:\n    raise newException(OSError, \"OS\")\n\n\nproc p(): bool {.raises: [].} =\n  try:\n    result = true\n  except:\n    result = false\n\nA raises list can also be attached to a proc type. This affects type compatibility:\ntype\n  Callback = proc (s: string) {.\n    raises: [IOError],\n  .}\n\n\nvar\n  c: Callback\n\n\nproc p(x: string) =\n  raise newException(OSError, \"OS\")\n\n\n# static error: type error\nc = p\n\nFor a routine p the compiler uses inference rules to determine the set of possibly raised exceptions; the algorithm operates on p's call graph:\n\nEvery indirect call via some proc type T is assumed to raise system.Exception (the base type of the exception hierarchy) and thus any exception unless T has an explicit raises list. However if the call is of the form f(...) where f is a parameter of the currently analysed routine it is ignored. The call is optimistically assumed to have no effect. Rule 2 compensates for this case.\nEvery expression of some proc type wihtin a call that is not a call itself (and not nil) is assumed to be called indirectly somehow and thus its raises list is added to p's raises list.\nEvery call to a proc q which has an unknown body (due to a forward declaration or an importc pragma) is assumed to raise system.Exception unless q has an explicit raises list.\nEvery call to a method m is assumed to raise system.Exception unless m has an explicit raises list.\nFor every other call the analysis can determine an exact raises list.\nFor determining a raises list, the raise and try statements of p are taken into consideration.\n\nRules 1-2 ensure the following works:\nproc noRaise(x: proc()) {.raises: [].} =\n  # unknown call that might raise anything, but valid:\n  x()\n\nproc doRaise() {.raises: [IOError].} =\n  raise newException(IOError, \"IO\")\n\nproc use() {.raises: [].} =\n  # doesn't compile! Can raise IOError!\n  noRaise(doRaise)\n\nSo in many cases a callback does not cause the compiler to be overly conservative in its effect analysis.\n\nTag tracking\nThe exception tracking is part of Nim's effect system. Raising an exception is an effect. Other effects can also be defined. A user defined effect is a means to tag a routine and to perform checks against this tag:\ntype\n  IO = object ## input/output effect\n\n\nproc readLine(): string {.tags: [IO].} =\n  \"some line\"\n\n\nproc IO_please() {.tags: [IO].} =\n  let\n    x = readLine()\n\n\nproc no_IO_please() {.tags: [].} =\n  # the compiler prevents this:\n  let\n    x = readLine()\n\nA tag has to be a type name. A tags list - like a raises list - can also be attached to a proc type. This affects type compatibility.\nThe inference for tag tracking is analogous to the inference for exception tracking.\n\nRead/Write tracking\nNote: Read/write tracking is not yet implemented!\nThe inference for read/write tracking is analogous to the inference for exception tracking.\n\nEffects pragma\nThe effects pragma has been designed to assist the programmer with the effects analysis. It is a statement that makes the compiler output all inferred effects up to the effects's position:\nproc proc0(what: bool) =\n  if what:\n    raise newException(IOError, \"IO\")\n    {.effects.}\n    # --> Hint: ref IOError [User]\n  else:\n    raise newException(OSError, \"OS\")\n\n\nproc proc1(what: bool) =\n  if what:\n    raise newException(IOError, \"IO\")\n  else:\n    raise newException(OSError, \"OS\")\n    {.effects.}\n    # --> Hint: ref IOError [User]\n    # --> Hint: ref OSError [User]\n\nThe compiler produces a hint message that IOError can be raised. OSError is not listed as it cannot be raised in the branch the effects pragma appears in. \n\nGenerics\ntype\n  BinaryTreeObj[T] = object\n    ## BinaryTreeObj is a generic type with generic param ``T``\n    left, right: BinaryTree[T]\n    ## left and right subtrees; may be nil\n    data: T\n    ## the data stored in a node\n\n  BinaryTree[T] = ref BinaryTreeObj[T]\n  ## a shorthand for notational convenience\n\n\nproc newNode[T](data: T): BinaryTree[T] =\n  ## constructor for a node\n  new(result)\n  result.data = data\n\n\nproc add[T](\n  root: var BinaryTree[T],\n  n: BinaryTree[T],\n) =\n  if root == nil:\n    root = n\n  else:\n    var\n      it = root\n    while it != nil:\n      var\n        c = cmp(it.data, n.data)\n        ## compare the data items;\n        ## uses the generic ``cmp`` proc that works for any type that\n        ## has a ``==`` and ``<`` operator\n\n      if c < 0:\n        if it.left == nil:\n          it.left = n\n          return\n        it = it.left\n      else:\n        if it.right == nil:\n          it.right = n\n          return\n        it = it.right\n\n\niterator inorder[T](root: BinaryTree[T]): T =\n  ## inorder traversal of a binary tree\n  ## recursive iterators are not yet implemented, so this does not\n  ## work in the current compiler!\n  if root.left != nil:\n    yield inorder(root.left)\n  if root.right != nil:\n    yield inorder(root.right)\n\n\nvar\n  root: BinaryTree[string]\n  # instantiates a BinaryTree with the type string\n\n\nroot.add(newNode(\"hallo\"))\nroot.add(newNode(\"world\"))\n# instantiates generic procs ``newNode`` and ``add``\n\n\nfor str in inorder(root):\n  echo(str)\n\n\nis operator\ntype\n  Table[Key, Val] = object\n    keys: seq[Key]\n    values: seq[Val]\n    count: Natural\n    when not (Key is string):  # nil value for strings used for optimization\n      deletedKeys: seq[bool]\n\n\nproc initTable*[Key, Val](initialSize: Natural = 64): Table[Key, Val] =\n  result.count = 0\n  newSeq(result.keys, initialSize)\n  newSeq(result.values, initialSize)\n  echo(\"String init\")\n  #newSeq(result.deletedKeys, 0)\n\n\nproc add*[Key, Val](t: var Table[Key, Val], key: Key, value: Val) =\n  t.keys[t.count] = key\n  t.values[t.count] = value\n  t.count += 1\n\n\nvar\n  t: Table[string, int] = initTable[string, int]()\n\nt.add(\"A\", 1)\n\n\ntype operator\nvar\n  x = 0\n\nvar\n  y: type(x)\n\nIf type is used to determine the result type of a proc/iterator/converter call c(X) (where X stands for a possibly empty list of arguments), the interpretation where c is an iterator is preferred over the other interpretations:\nimport strutils\n\n# strutils contains some ``split`` procs and iterators.\n#   proc split(s: string; seps: set[char] = Whitespace): seq[string]\n#   proc split(s: string; sep: char): seq[string]\n#   proc split(s: string; sep: string): seq[string]\n#   iterator split(s: string; seps: set[char] = Whitespace): string\n#   iterator split(s: string; sep: char): string\n#   iterator split(s: string; sep: string): string\n# But since an iterator is the preferred interpretation, `y' has the\n# type ``string``:\n\nvar\n  y: type(\"a b c\".split)\n\n\ny = \"a\"\n\n\nType classes\nA type class is a special pseudo-type that can be used to match against types in the context of overload resolution or the is operator. Nim supports the following built-in type classes:\n\n\n\ntype class\nmatches\n\n\n\n\nobject\nany object type\n\n\ntuple\nany tuple type\n\n\nenum\nany enumeration\n\n\nproc\nany proc type\n\n\nref\nany ref type\n\n\nptr\nany ptr type\n\n\nvar\nany var type\n\n\ndistinct\nany distinct type\n\n\narray\nany array type\n\n\nset\nany set type\n\n\nseq\nany seq type\n\n\nauto\nany type\n\n\n\nEvery generic type automatically creates a type class of the same name that will match any instantiation of the generic type.\nType classes can be combined using the standard boolean operators to form more complex type classes:\n# create a type class that will match all tuple and object types\nimport tables\n\ntype\n  ObjX = object\n    x: int\n    y: int\n    z: int\n\n  RefX = ref ObjX\n\n  RecordType = tuple[x:int, y:int, z:int] or object\n\n\nproc printFields(rec: RecordType) =\n  var\n    t = initTable[string, int]()\n  for k, v in fieldPairs(rec):\n    t[k] = v\n  assert t == {\"x\": 1, \"y\": 2, \"z\": 3}.toTable\n\nvar\n  tuple_rec: tuple[x:int, y:int, z:int] = (x: 1, y: 2, z: 3)\n  obj_rec = ObjX(x: 1, y: 2, z: 3)\n\nprintFields(tuple_rec)\nprintFields(obj_rec)\n\nProcedures utilizing type classes in such manner are considered to be implicitly generic. They will be instantiated once for each unique combination of param types used within the program.\nNim also allows for type classes and regular types to be specified as type constraints of the generic type parameter:\nproc gproc[T: int|string](x, y: T): string =\n  \"accepted by A\"\n\nassert gproc(100, 200) == \"accepted by A\"\nassert gproc(\"a\", \"b\") == \"accepted by A\"\n\n# static error: type mismatch\n#assert gproc(100, \"b\") == \"accepted by A\"\n#assert gproc(\"a\", 200) == \"accepted by A\"\n\n\nproc gproc[X: int|string, Y: string](x:X, y:Y): string =\n  \"accepted by B\"\n\n\nassert gproc(100, 200) == \"accepted by A\"\n\n# static error: ambiguous call\n#assert gproc(\"a\", \"b\") == \"accepted by A\"\n\nassert gproc(100, \"b\") == \"accepted by B\"\n\n# static error: type mismatch\nassert gproc(\"a\", 200) == \"accepted by A\"\n\nBy default, during overload resolution each named type class will bind to exactly one concrete type. Here is an example taken directly from the system module to illustrate this:\nproc `==`*[T: tuple|object](x, y: T): bool =\n  ## generic ``==`` operator for tuples that is lifted from the components\n  ## of `x` and `y`.\n  for a, b in fields(x, y):\n    if a != b: return false\n  return true\n\nAlternatively, the distinct type modifier can be applied to the type class to allow each param matching the type class to bind to a different type.\nIf a proc param doesn't have a type specified, Nim will use the distinct auto type class (also known as any):\nproc concat(a, b): string = $a & $b\n\nassert concat(\"str+\", 1) == \"str+1\"\n\nProcs written with the implicitly generic style will often need to refer to the type parameters of the matched generic type. They can be easily accessed using the dot syntax:\nimport typetraits\n\ntype\n  NameEnum = enum\n    first_name,\n    last_name,\n    middle_name\n\ntype\n  NormalMatrix[Rows, Cols, T] = array[Rows, array[Cols, T]]\n\n  Normal3Matrix[T] = NormalMatrix[range[0..2], range[0..2], T]\n\n  NameEnumMatrix[T] = NormalMatrix[range[0..2], NameEnum, T]\n\n\nproc `*`* [Rows, Cols, Ta, Tb](\n  a: NormalMatrix[Rows, Cols, Ta],\n  b: NormalMatrix[Rows, Cols, Tb],\n): NormalMatrix[Rows, Cols, Ta] =\n  for r in Rows.low .. Rows.high:\n    var\n      inner: array[Cols, int]\n    for c in Cols.low .. Cols.high:\n      inner[c] = a[r][c] * b[r][c]\n    result[r] = inner\n\nvar\n  normalm: NormalMatrix[range[0..2], range[0..2], int] = [\n    [0, 1, 2],\n    [10, 11, 12],\n    [20, 21, 22],\n  ]\n  normal3m: Normal3Matrix[int] = [\n    [0, 1, 2],\n    [10, 11, 12],\n    [20, 21, 22],\n  ]\n  enumm: NameEnumMatrix[string] = [\n    [\"Fn0\", \"Ln0\", \"Mn0\"],\n    [\"Fn1\", \"Ln1\", \"Mn1\"],\n    [\"Fn2\", \"Ln2\", \"Mn2\"],\n  ]\n\nassert normalm.type.name == \"NormalMatrix[range 0..2(int), range 0..2(int), system.int]\"\nassert normalm[2][2] == 22\nassert normalm.Rows is range[0..2]\nassert normalm.Cols is range[0..2]\nassert normalm.T is int\nassert normal3m.type.name == \"Normal3Matrix[system.int]\"\nassert normal3m[2][2] == 22\nassert normal3m.Rows is range[0..2]\nassert normal3m.Cols is range[0..2]\nassert normal3m.T is int\nassert enumm.type.name == \"NameEnumMatrix[system.string]\"\nassert enumm[2][NameEnum.middle_name] == \"Mn2\"\nassert enumm[2][NameEnum(2)] == \"Mn2\"\nassert enumm.Rows is range[0..2]\nassert enumm.Cols is NameEnum\nassert enumm.T is string\nassert normalm * normal3m == [[0, 1, 4], [100, 121, 144], [400, 441, 484]]\n\n\ntype\n  StaticMatrix[Rows, Cols: static[int], T] = array[Rows, array[Cols, T]]\n  Static3Matrix[T] = StaticMatrix[3, 3, T]\n\nvar\n  staticm: StaticMatrix[3, 3, int] = [\n    [0, 1, 2],\n    [10, 11, 12],\n    [20, 21, 22],\n  ]\n  static3m: Static3Matrix[int] = [\n    [0, 1, 2],\n    [10, 11, 12],\n    [20, 21, 22],\n  ]\n\nassert staticm.type.name == \"StaticMatrix[3, 3, system.int]\"\nassert staticm.Rows == 3\nassert staticm.Cols == 3\nassert staticm.T is int\nassert static3m.type.name == \"Static3Matrix[system.int]\"\nassert static3m.Rows == 3\nassert static3m.Cols == 3\nassert static3m.T is int\nassert staticm * static3m == [[0, 1, 4], [100, 121, 144], [400, 441, 484]]\n\n\n\ntype\n  #LwMatrix[Rows, Cols: static[range], T] = array[(high(Rows) + 1) * (high(Cols) + 1), T]\n  StaticLwMatrix[Rows, Cols: static[int], T] = array[Rows * Cols, T]\n  StaticLw3Matrix[T] = StaticLwMatrix[3, 3, T]\n\nproc `[]`* (a: StaticLwMatrix, row, col: int): StaticLwMatrix.T =\n  if (row >= 0 and row >= StaticLwMatrix.Rows) or\n    (row < 0 and row < -StaticLwMatrix.Rows) or\n    (col >=0 and col >= StaticLwMatrix.Cols) or\n    (col < 0 and col < -StaticLwMatrix.Cols):\n      raise newException(IndexError, \"index out of bounds\")\n  a[StaticLwMatrix.Cols * row + (if col >= 0: col else: StaticLwMatrix.Cols + col)]\n\n\n# same as above\nproc `[]`* [Rows, Cols, T](a: StaticLwMatrix[Rows, Cols, T], row, col: T): T =\n  if (row >= 0 and row >= Rows) or\n    (row < 0 and row < -Rows) or\n    (col >=0 and col >= Cols) or\n    (col < 0 and col < -Cols):\n      raise newException(IndexError, \"index out of bounds\")\n  a[Cols * row + (if col >= 0: col else: Cols + col)]\n\n\nvar\n  staticlwm: StaticLwMatrix[3, 3, int] = [\n    0, 1, 2,\n    10, 11, 12,\n    20, 21, 22,\n  ]\n  staticlw3m: StaticLw3Matrix[int] = [\n    0, 1, 2,\n    10, 11, 12,\n    20, 21, 22,\n  ]\n\nassert staticlwm.type.name == \"StaticLwMatrix[3, 3, system.int]\"\nassert staticlwm.Rows == 3\nassert staticlwm.Cols == 3\nassert staticlwm.T is int\nassert staticlw3m.type.name == \"StaticLw3Matrix[system.int]\"\nassert staticlw3m.Rows == 3\nassert staticlw3m.Cols == 3\nassert staticlw3m.T is int\nassert staticlw3m[1, -1] == 12\n\n\ntype\n  NormalMatrixObj[Rows, Cols, T] = object\n    data: array[Rows, array[Cols, T]]\n\n  NameEnumMatrixObj[Rows, T] = object\n    data: array[Rows, array[NameEnum, T]]\n\n  StaticMatrixObj[Rows, Cols: static[int], T] = object\n    data: array[Rows, array[Cols, T]]\n\nvar\n  normalm_obj = NormalMatrixObj[range[0..2], range[0..2], int](\n    data: [\n      [0, 1, 2],\n      [10, 11, 12],\n      [20, 21, 22],\n    ]\n  )\n  enumm_obj = NameEnumMatrixObj[range[0..2], string](\n    data: [\n      [\"Fn0\", \"Ln0\", \"Mn0\"],\n      [\"Fn1\", \"Ln1\", \"Mn1\"],\n      [\"Fn2\", \"Ln2\", \"Mn2\"],\n    ]\n  )\n  staticm_obj = StaticMatrixObj[3, 3, int](\n    data: [\n      [0, 1, 2],\n      [10, 11, 12],\n      [20, 21, 22],\n    ]\n  )\n\n\nassert normalm_obj.type.name == \"NormalMatrixObj[range 0..2(int), range 0..2(int), system.int]\"\nassert enumm_obj.type.name == \"NameEnumMatrixObj[range 0..2(int), system.string]\"\nassert staticm_obj.type.name == \"StaticMatrixObj[3, 3, system.int]\"\n\nAlternatively, the type operator can be used over the proc params for similar effect when anonymous or distinct type classes are used.\nWhen a generic type is instantiated with a type class instead of a concrete type, this results in another more specific type class:\n\n## [Definitions](http://nim-lang.org/docs/manual.html#definitions)\n\n```nim\nvar\n  a = \"a\"  # l-value\n\nconst\n  b = \"a\"  # not l-value\n\nlet\n  c = \"a\" # not l-value\n\nvar\n  p: ptr string\n\necho(repr(a))\n# --> 0x7fd3b9d09050\"a\"\n\np = addr(a)\n\necho(repr(p))\n# --> ref 0x622958 --> 0x7fd3b9d09050\"a\"\n\n#p = addr(b)\n# static error: expression has no address\n\n#p = addr(b)\n# static error: expression has no address\n```\n\n\n\n# [Lexical Analysis](http://nim-lang.org/docs/manual.html#lexical-analysis)\n\n\n## [Encoding](http://nim-lang.org/docs/manual.html#lexical-analysis-encoding)\n\nAll Nim source files are in the UTF-8 encoding (or its ASCII subset). Other encodings are not supported.\n\n\n## [Indentation](http://nim-lang.org/docs/manual.html#lexical-analysis-indentation)\n\n\n## [Comments](http://nim-lang.org/docs/manual.html#lexical-analysis-comments)\n\n```nim\nvar\n  x = 1  # comment piece\n  y = 1  # [comment start] comment piece\n# comment piece\n# comment piece [comment end]\n\n## Documentation comment\n## Documentation comment\n```\n\n\n## [Identifiers & Keywords](http://nim-lang.org/docs/manual.html#lexical-analysis-identifiers-keywords)\n\n    letter ::= 'A'..'Z' | 'a'..'z' | '\\x80'..'\\xff'\n    digit ::= '0'..'9'\n    IDENTIFIER ::= letter ( ['_'] (letter | digit) )*\n\nTwo immediate following underscores `__` are not allowed\n\n\n## [Identifier equality](http://nim-lang.org/docs/manual.html#lexical-analysis-identifier-equality)\n\n    a[0] == b[0] and a.replace(\"_\", \"\").toLower == b.replace(\"_\", \"\").toLower\n\n\n## [String literals](http://nim-lang.org/docs/manual.html#lexical-analysis-string-literals)\n\n\n## [Triple quoted string literals](http://nim-lang.org/docs/manual.html#lexical-analysis-triple-quoted-string-literals)\n\nWhen the opening *`\"\"\"`* is followed by a newline (there may be whitespace between the opening *`\"\"\"`* and the newline), the newline (and the preceding whitespace) is not included in the string. \n\n```nim\nassert \"\"\"\n \"aaa\"\nbbb\nccc\n\\n\\r\\c\\x00\\t\n\"\"\" == \" \\\"aaa\\\"\\nbbb\\nccc\\n\\\\n\\\\r\\\\c\\\\x00\\\\t\\n\"\n```\n\n\n## [Raw string literals](http://nim-lang.org/docs/manual.html#lexical-analysis-raw-string-literals)\n\n```nim\nassert r\"C:\\texts\\text.txt\" == \"C:\\\\texts\\\\text.txt\"\nassert r\"a\"\"b\" == \"a\\\"b\"\n```\n\n\n## [Generalized raw string literals](http://nim-lang.org/docs/manual.html#lexical-analysis-raw-string-literals)\n\n`identifier\"string literal\"`\nis a shortcut for\n`identifier(r\"string literal\")`\n\n`identifier\"\"\"string literal\"\"\"`\nis a shortcut for\n`identifier(\"\"\"string literal\"\"\")`\n\n\n## [Character literals](http://nim-lang.org/docs/manual.html#lexical-analysis-character-literals)\n\nCharacter literals are enclosed in single quotes `''`. Newline (`\\n`) is not allowed as it may be wider than one character (often it is the pair `CR/LF` for example).\n\nA character is not an Unicode character but a single byte.Nim can thus support `array[char, int]` or `set[char]` efficiently as many algorithms rely on this feature.\n\n\n## [Numerical constants](http://nim-lang.org/docs/manual.html#lexical-analysis-numerical-constants)\n\n```nim\nvar\n  i = 3  # signed int\n  i8 = 3'i8  # signed int8\n  i16 = 3'i16  # signed int16\n  i32 = 3'i32  # signed int32\n  i64 = 3'i64  # signed int64\n\n  ui = 3'u  # unsigned int\n  ui8 = 3'u8  # unsigned int8\n  ui16 = 3'u16  # unsigned int16\n  ui32 = 3'u32  # unsigned int32\n  ui64 = 3'u64  # unsigned int64\n\n  f = 0.0  # float\n  f32 = 0.0'f32  # float32\n  f64 = 0.0'f64  # float6\n\nassert 0b11111111 == 255\nassert 0o377 == 255\nassert 0xff == 255\nassert 0b0_10001110100_0000101001000111101011101111111011000101001101001001'f64 == 1.7282561e+35\nassert 1_999_999 == 1999999\n```\n\nSize of int/uint is \"size_t\".\n\n\n## [Operators](http://nim-lang.org/docs/manual.html#lexical-analysis-operators)\n\n    =     +     -     *     /     <     >\n    @     $     ~     &     %     |\n    !     ?     ^     .     :     \\\n    and or not xor shl shr div mod in notin is isnot of\n\n\n## [Other tokens](http://nim-lang.org/docs/manual.html#lexical-analysis-other-tokens)\n\n\n# [Types](http://nim-lang.org/docs/manual.html#types)\n\n- ordinal types\n    - integer (except for uint/uint64)\n    - bool\n    - char\n    - enum\n    - and subranges thereof\n- float\n- string\n- structured types\n    - array\n    - seq\n    - set\n    - openArray\n    - varargs\n    - tuple\n    - object\n- ref (ptr) type\n- procedural type\n- generic type\n\n\n## [Ordinal types](http://nim-lang.org/docs/manual.html#types-ordinal-types)\n\n- countable and ordered\n- *inc()*, *dec()*\n- *ord()*, *low()*, *high()*, *pred()*, *succ()*\n\n```nim\nvar\n  i = 0\n\ninc(i)\nassert i == 1\ndec(i)\nassert i == 0\n\ni = high(int)\nassert i == high(i)\ntry:\n  inc(i)\nexcept OverFlowError:\n  # Error: unhandled exception: over- or underflow [OverflowError]\n  echo(\"OverFlowError:\", getCurrentExceptionMsg())\n\ni = low(int)\nassert i == low(i)\ntry:\n  dec(i)\nexcept OverFlowError:\n  # Error: unhandled exception: over- or underflow [OverflowError]\n  echo(\"OverFlowError:\", getCurrentExceptionMsg())\n\n\nimport unsigned\n# some ops requires unsigned module\n\nvar\n  u:uint = 0\n\ninc(u)\nassert u == 1\ndec(u)\nassert u == 0\n\n#u = low(uint)\n#u = low(u)\n# static error: invalid argument for `low`\n\n#u = high(uint)\n#u = high(u)\n# static error: invalid argument for `high`\n\nu = uint(high(int) * 2 + 1)\ninc(u)\nassert u == 0\ndec(u)\nassert u == uint(high(int) * 2 + 1)\n\n\nvar\n  c = 'm'\n\nassert ord(c) == 109\nassert chr(109) == c\nassert pred('m') == 'l'\nassert succ('m') == 'n'\n\ninc(c)\nassert c == 'n'\ndec(c)\nassert c == 'm'\n\nc = low(c)\nassert c == '\\0'\ntry:\n  dec(c)\nexcept OverFlowError:\n  # Error: unhandled exception: over- or underflow [OverflowError]\n  echo(\"OverFlowError:\", getCurrentExceptionMsg())\n\nc = high(c)\nassert c == '\\255'\ntry:\n  inc(c)\nexcept OverFlowError:\n  # Error: unhandled exception: over- or underflow [OverflowError]\n  echo(\"OverFlowError: \", getCurrentExceptionMsg())\n```\n\n\n## [Pre-defined integer types](nim-lang.org/docs/manual.html#types-pre-defined-integer-types)\n\n```nim\nimport unsigned\n\nvar\n  i: int\n  ui: uint\n\nassert i == 0\nassert ui == 0\n```\n\n## [Subrange type](http://nim-lang.org/docs/manual.html#types-subrange-types)\n\nA subrange type is a range of values from an ordinal type(the base type). To define a subrange type, one must specify it's limiting values: the lowest and highest value of the type.\nA subrange type of a base ordinal type which can only hold the lowest value to highest value. Assignments from the base ordinal type to one of its subrange types (and vice versa) are allowed.\n\nA subrange type has the same size as its base type (int in the example).\n\n\n```nim\ntype\n  IntSubRange = range[-10 .. 10]\n  ChrSubRange = range['a' .. 'c']\n\n  Direction {.pure.} = enum\n    north,\n    south,\n    east,\n    west,\n  EnumSubRange = range[Direction.north .. Direction.east]\n\nvar\n  s_i: IntSubRange\n  s_c: ChrSubRange\n  s_e: EnumSubrange\n  i: int = s_i\n\nassert s_i == 0\nassert s_c == '\\x0'\nassert s_e == Direction.north\ns_i = -10\ns_c = 'b'\ns_e = Direction.south\n#s_i = -11\n# static error: conversion from int literal(-11) to intSubRange is invalid\n\ntry:\n  dec(s_i)\nexcept OverFlowError:\n  # Error: unhandled exception: over- or underflow [OverflowError]\n  echo(\"OverFlowError: \", getCurrentExceptionMsg())\n```\n\nNim requires interval arithmetic for subrange types over a set of built-in operators that involve constants: `x %% 3` is of type `range[0..2]`. The following built-in operators for integers are affected by this rule: `-`, `+`, `*`, `min`, `max`, `succ`, `pred`, `mod`, `div`, `%%`, `and` (bitwise `and`).\n\nBitwise `and` only produces a `range` if one of its operands is a constant `x` so that `(x+1)` is a number of two. (Bitwise `and` is then a `%%` operation.)\n\n```nim\ncase (x and 3) + 7\nof 7: echo \"A\"\nof 8: echo \"B\"\nof 9: echo \"C\"\nof 10: echo \"D\"\n# note: no ``else`` required as (x and 3) + 7 has the type: range[7..10]\n```\n\n\n## [Pre-defined floating point types](http://nim-lang.org/docs/manual.html#types-pre-defined-floating-point-types)\n\nArithmetic performed on floating point types follows the IEEE standard. Integer types are not converted to floating point types automatically and vice versa.\n\nThe IEEE standard defines five types of floating-point exceptions:\n\n* Invalid: operations with mathematically invalid operands, for example `0.0/0.0`, `sqrt(-1.0)`, and `log(-37.8)`.\n* Division by zero: divisor is zero and dividend is a finite nonzero number, for example `1.0/0.0`.\n* Overflow: operation produces a result that exceeds the range of the exponent, for example `MAXDOUBLE+0.0000000000001e308`.\n* Underflow: operation produces a result that is too small to be represented as a normal number, for example, `MINDOUBLE * MINDOUBLE`.\n* Inexact: operation produces a result that cannot be represented with infinite precision, for example, `2.0 / 3.0`, `log(1.1)` and `0.1` in input.\n\nThe IEEE exceptions are either ignored at runtime or mapped to the Nim exceptions:\n\n* FloatInvalidOpError\n* FloatDivByZeroError\n* FloatOverflowError\n* FloatUnderflowError\n* FloatInexactError\n\nThese exceptions inherit from the `FloatingPointError` base class.\n\nNim provides the pragmas `NaNChecks` and `InfChecks` to control whether the IEEE exceptions are ignored or trap a Nim exception:\n\n```nim\n# https://akehrer.github.io/nim/2015/01/14/getting-started-with-nim-pt2.html\nimport math\n\nconst\n  Nan = 0.0/0.0 # floating point not a number (NaN)\n\nproc cIsNaN(x: float): cint {.importc: \"isnan\", header: \"<math.h>\".}\n  ## returns non-zero if x is not a number\n\nproc cIsInf(x: float): cint {.importc: \"isinf\", header: \"<math.h>\".}\n  ## returns non-zero if x is infinity\n\nproc isNaN*(x: float): bool =\n  ## converts the integer result from cIsNaN to a boolean\n  if cIsNaN(x) != 0.cint:\n    true\n  else:\n    false\n\nproc isInf*(x: float): bool =\n  ## converts the integer result from cIsInf to a boolean\n  if cIsInf(x) != 0.cint:\n    true\n  else:\n    false\n\n\nvar\n  a:float\n  b = 1.0\n\nassert a == 0.0\necho(0.0 / 0.0)  # --> nan\necho(1.0 / 0.0)  # --> inf\necho(a / a)  # --> -nan\necho(b / a)  # --> inf\n\n{.push nanChecks: on, infChecks: on.}\necho(0.0 / 0.0)\necho(1.0 / 0.0)\n\ntry:\n  echo a / a\nexcept FloatInvalidOpError:\n  # Error: unhandled exception: FPU operation caused a NaN result [FloatInvalidOpError]\n  echo(\"FloatInvalidOpError: \", getCurrentExceptionMsg())\n\ntry:\n  echo b / a\nexcept FloatOverflowError:\n  # Error: unhandled exception: FPU operation caused an overflow [FloatOverflowError]\n  echo(\"FloatOverflowError: \", getCurrentExceptionMsg())\n{.pop.}\n```\n\nIn the current implementation `FloatDivByZeroError` and `FloatInexactError` are never raised. `FloatOverflowError` is raised instead of `FloatDivByZeroError`. There is also a *`floatChecks`* pragma that is a short-cut for the combination of *`NaNChecks`* and *`InfChecks`* pragmas. *`floatChecks`* are turned off as default.\n\nThe only operations that are affected by the *`floatChecks`* pragma are the `+`, `-`, `*`, `/` operators for floating point types.\n\nAn implementation should always use the maximum precision available to evaluate floating pointer values at compile time; this means expressions like ``0.09'f32 + 0.01'f32 == 0.09'f64 + 0.01'f64`` are true.\n\n\n## [Boolean type](http://nim-lang.org/docs/manual.html#types-boolean-type)\n\n```nim\nassert ord(false) == 0\nassert ord(true) == 1\n```\n\n\n## [Character type](http://nim-lang.org/docs/manual.html#types-character-type)\n\nNim can support `array[char, int]` or `set[char]` efficiently as many algorithms rely on this feature.\n\n```nim\nvar\n  c: char\nassert c == '\\x0'\n```\n\n```nim\nvar\n  char_index_array: array[char, int]\n\nassert char_index_array.len == 256\nassert char_index_array['a'] == 0\nchar_index_array['v'] = 1\nassert char_index_array['v'] == 1\n\nvar\n  char_set: set[char] = {'a', 'a', 'b'}\n\nassert char_set == {'a', 'b'}\n```\n\n```nim\nvar\n  char_buffer: array[0 .. 255, char]\n\nassert char_buffer.len == 256\nassert char_buffer == ['\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0']\n\nchar_buffer[0] = 'a'\n\nassert cstring(char_buffer).len == 1\necho cstring(char_buffer)\n# --> a\n```\n\n\n## [Enumeration type](http://nim-lang.org/docs/manual.html#types-enumeration-types)\n\nEnumeration types define a new type whose values consist of the ones specified. The values are ordered.\n\n```nim\ntype\n  Direction = enum\n    north,\n    south,\n    east,\n    west,\n\nassert north == Direction.north\nassert north < Direction.south\n\nassert ord(Direction.north) == 0\nassert ord(north) == 0\nassert ord(south) == 1\nassert ord(east) == 2\nassert ord(west) == 3\n\nassert pred(east) == south\nassert succ(east) == west\n\nvar\n  e: Direction\n\nassert e == north\ne = east\n\ninc(e)\nassert e == west\ndec(e)\nassert e == east\nassert low(Direction) == north\nassert low(e) == north\nassert high(Direction) == west\nassert high(e) == west\n\nassert Direction(0) == north\nassert Direction(1) == south\nassert Direction(2) == east\nassert Direction(3) == west\n\nvar\n  arr_e0: array[Direction, float]\n  arr_e1: array[north .. west, float]\n\nassert arr_e0[east] == 0.0\nassert arr_e1[east] == 0.0\narr_e0[east] = 1.1\n\n\ntype\n  ScopedEnum {.pure.} = enum\n    val_a,\n    val_b,\n\n# static error: undeclared identifier: 'val_a'\n#echo val_a\n```\n\nThe fields of enum types can be assigned an explicit ordinal value. However, the ordinal values have to be in ascending order. A field whose ordinal value is not explicitly given is assigned the value of the previous field + 1.\n\nAn explicit ordered enum can have holes. However, it is then not an ordinal anymore, so it is not possible to use these enums as an index type for arrays. The procedures `inc`, `dec`, `succ` and `pred` are not available for them either.\n\n```nim\ntype\n  Status = enum\n    ok = 200,\n    created,\n    accepted = \"Accepted\",\n    multiple_sources = 300,\n    moved_permanently = \"Moved Permanently\",\n    bad_request = 400,\n    internal_server_error = (500, \"Internal Server Error\")\n\nassert ord(ok) == 200\nassert ord(created) == 201\nassert ord(accepted) == 202\n\n# static error: enum 'Status' has holes\n#var\n#  x: array[ok .. accepted, int]\n#  y: array[Status, int]\n\nvar\n  status = ok\n\ninc(status)\nassert status == created\ninc(status)\nassert status == accepted\ninc(status)\nassert status != multiple_sources\n\necho(status)\n# --> 203 (invalid data!)\n```\n\n\n## [String type](http://nim-lang.org/docs/manual.html#types-string-type)\n\nZero(Null)-terminated and have a length field. The length never counts the terminating zero. The assignment operator for strings always copies the string. The & operator concatenates strings.\n\nStrings are compared by their lexicographical order. All comparison operators are available. Strings can be indexed like arrays (lower bound is 0).\n\n\n```nim\nvar\n  s: string\n\nassert s.isNil\ns = \"this\"  # assignment op does COPY the string\n\nvar\n  conc = s & \" is\"  # concat\n\nassert s[0] == 't'\n# static error\n#assert s[0] == \"t\"\ns[0] = 'T'\n# static error\n#s[0] = \"T\"\n\nassert s[0 .. 1] == \"Th\"\ns.add(\" \")\ns.add(\"is a string\")\nassert s == \"This is a string\"\nassert s[low(s) .. high(s)] == \"This is a string\"\n\ntry:\n  echo s[100]\nexcept IndexError:\n  # Error: unhandled exception: index out of bounds [IndexError]\n  echo(\"IndexError: \", getCurrentExceptionMsg())\n```\n\n```nim\nvar\n  s = \"0123456789\"\n\nassert s.len == 10\nassert s[0] == '0'\nassert s[^0] == '\\x0'\nassert s[^1] == '9'\nassert s[1 .. 1] == \"1\"\nassert s[1 .. 3] == \"123\"\nassert s[^1 .. ^1] == \"9\"\nassert s[^3 .. ^1] == \"789\"\nassert s[^1 .. ^2] == \"\"\nassert s[0 .. ^0] == \"0123456789\"\nassert s[0 .. ^1] == \"0123456789\"\ns[0] = 'a'\nassert s == \"a123456789\"\ns[0 .. 0] = \"a\" \nassert s == \"a123456789\"\ns[0 .. 2] = \"abc\"\nassert s == \"abc3456789\"\ns[^3 .. ^1] = \"xyz\"\nassert s == \"abc3456xyz\"\ns[0 .. 2] = \"a\"\nassert s == \"a3456xyz\"\ns[0 .. 2] = \"\"\nassert s == \"56xyz\"\ns[0 .. 0] = \"012345\"\nassert s == \"0123456xyz\"\ns[0 .. 2] = \"\"\nassert s == \"3456xyz\"\ns[^3 .. ^1] = \"\"\nassert s == \"3456\"\ns.setLen(1)\nassert s.len == 1\nassert s == \"3\"\n```\n\nPer convention, all strings are UTF-8 strings, but this is not enforced. For example, when reading strings from binary files, they are merely a sequence of bytes. The index operation s[i] means the i-th char of s, not the i-th unichar.\n\n\n## [cstring type](http://nim-lang.org/docs/manual.html#types-cstring-type)\n\nA pointer to zero-terminated char array(char* in c). No *`boundChecks`*. The index operation is unsafe.\n\nA Nim string is implicitly convertible to cstring for convenience. If a Nim string is passed to a C-style variadic proc, it is implicitly converted to cstring too:\n\nEven though the conversion is implicit, it is not safe: The garbage collector does not consider a cstring to be a root and may collect the underlying memory. However in practice this almost never happens as the GC considers stack roots conservatively. One can use the builtin procs `GC_ref` and `GC_unref` to keep the string data alive for the rare cases where it does not work.\n\nA `$` proc is defined for cstrings that returns a string. Thus to get a nim string from a cstring:\n\n```nim\nproc printf(formatstr: cstring) {.importc:\n  \"printf\", varargs,\n  header: \"<stdio.h>\".}\n\nprintf(\"This works as expected %s\", \"by printf in stdio\")\n\nvar\n  str: string = \"hello\"\n  cstr: cstring\n\nassert cstr.isNil\n\ncstr = str\n\nvar\n  str_back: string = $cstr\n```\n\n```nim\nvar\n  # `system.cstringArray` is equal to `ptr array [0..ArrayDummySize, cstring]`\n  cstring_arr: cstringArray = allocCStringArray([\"abc\"])\n\ncstring_arr[1] = \"def\"\ncstring_arr[2] = \"ghi\"\nassert cstringArrayToSeq(cstring_arr) == @[\"abc\", \"def\", \"ghi\"]\n\ndealloc(cstring_arr)\n\n# if the members of a cstringArray are allocated (for example, by c), call `deallocCStringArray()`\n#deallocCStringArray(cstring_arr)\n```\n\n\n## [Structured types](http://nim-lang.org/docs/manual.html#types-structured-types)\n\nArrays, sequences, tuples, objects and sets belong to the structured types.\n\n\n## [Array and sequence types](http://nim-lang.org/docs/manual.html#types-array-and-sequence-types)\n\n### array\n\n- element: homogeneous\n- length: fixed\n- index type: ordinal type\n- expression constructor: []\n- boundsCheck: yes(compile-time)\n\n```nim\nimport typetraits\n\nvar\n  arr_obj: array[0 .. 5, int]\n  arr_ref: ref array[0 .. 5, int]\n\nassert arr_obj.type.name == \"array[0..5, int]\"\necho repr(arr_obj)\n# --> [0, 0, 0, 0, 0, 0]\n\nassert arr_ref.isNil\nnew(arr_ref)\nassert (not arr_ref.isNil)\nassert arr_ref.type.name == \"ref array[0..5, int]\"\necho repr(arr_ref)\n# --> ref 0x7fda81f0b0d0 --> [0, 0, 0, 0, 0, 0]\n```\n\n```nim\nvar\n  ii_arr0: array[int, int]\n  # too big array\n\nassert low(ii_arr0) == low(int)\nassert high(ii_arr0) == high(int)\nassert len(ii_arr0) == 0\nassert ii_arr0[0] == 0\nii_arr0[0] = 0\nassert ii_arr0.len == 0\n\n\nvar\n  i16i_arr: array[int16, int]\n\nassert low(i16i_arr) == low(int16)\nassert high(i16i_arr) == high(int16)\nassert len(i16i_arr) == 65536\n\n\nvar\n  ii_arr1: array[0 .. 3, int]\n\nassert low(ii_arr1) == 0\nassert high(ii_arr1) == 3\nassert len(ii_arr1) == 4\nassert ii_arr1[0] == 0\nii_arr1 = [0, 1, 2, 3]\n\n\nvar\n  ci_arr: array[char, int]\n\nassert low(ci_arr) == low(char)\nassert high(ci_arr) == high(char)\nassert len(ci_arr) == 256\nassert ci_arr['a'] == 0\nci_arr['v'] = 1\n\n\ntype\n  Direction = enum\n    north,\n    south,\n    east,\n    west,\n\nvar\n  ei_arr0:  array[Direction, int]\n  ei_arr1:  array[north .. west, int]\n\nassert low(ei_arr0) == north\nassert high(ei_arr0) == west\nassert len(ei_arr0) == 4\nassert ei_arr0[north] == 0\nei_arr0[north] = 1\n```\n\n### seq\n\n- element: homogeneous\n- length: dynamic\n- index type: ordinal type. From `0` to `len(S) - 1`\n- boundsCheck: yes\n- expression constructor: `@[]` (the array constructor `[]` in conjunction with the array to sequence operator `@`)\n- space alloc:\n  - `proc system.newSeq[T](s: var seq[T]; len: Natural)`\n  - `proc system.newSeq[T](len = 0.Natural): seq[T]`\n\n`newSeq` creates a new sequence of type ``seq[T]`` with length ``len``. This is equivalent to ``s = @[]; setlen(s, len)``, but more efficient since no reallocation is needed.\n\n```nim\nvar\n  seq_ref0: ref seq[int]\n\nassert seq_ref0.isNil\nnew(seq_ref0)\nassert (not seq_ref0.isNil)\necho repr(seq_ref0)\n# --> ref 0x7f180287b050 --> nil\nassert seq_ref0[].isNil\n\n\nvar\n  seq_obj = newSeq[int]()\n  seq_ref1: ref seq[int]\n\nassert seq_ref1.isNil\nnew(seq_ref1)\nassert (not seq_ref1.isNil)\necho repr(seq_ref1)\n# --> ref 0x7f180287b068 --> nil\nseq_ref1[] = seq_obj\necho repr(seq_obj)\n# --> 0x7f180287c050[]\necho repr(seq_ref1)\n# --> ref 0x7f180287b068 --> 0x7f180287c070[]\n```\n\n```nim\nvar\n  seq_0: seq[int]\n  seq_1 = @[0, 1, 2]\n\nassert seq_0.isNil\nseq_0 = @[0, 1, 2]\nassert (not seq_0.isNil)\nassert low(seq_0) == 0\nassert high(seq_0) == 2\nassert len(seq_0) == 3\nassert seq_0 & seq_1 == @[0, 1, 2, 0, 1, 2]\nassert seq_0.pop() == 2\nseq_0.add(1)\nassert seq_0 == @[0, 1, 1]\n\n\nvar\n  seq_2: seq[int]\n\nassert seq_2.isNil\nnewSeq(seq_2, 0)\nassert (not seq_2.isNil)\nassert len(seq_2) == 0\n\n\nvar\n  seq_3 = newSeq[int]()\n\nassert (not seq_3.isNil)\nassert len(seq_3) == 0\n\n\nvar\n  seq_4 = newSeq[int](3)\n\nassert (not seq_4.isNil)\nassert len(seq_4) == 3\n```\n\n`proc shallow[T](s: var seq[T])` marks a sequence s as shallow. Subsequent assignments will not perform deep copies of s. This is only useful for optimization purposes.\n\n```nim\nvar\n  s0 = @[0, 0, 0]\n\nvar\n  s1 = s0\n\nshallow(s0)\n\nvar\n  s2 = s0\n  s3 = s0[0..2]\n\ninc s0[0]\ns0.add(3)\nassert s0 == @[1, 0, 0, 3]\nassert s1 == @[0, 0, 0]\nassert s2 == @[1, 0, 0]\nassert s3 == @[0, 0, 0]\n```\n\n\n## [openArray](http://nim-lang.org/docs/manual.html#types-open-arrays)\n\n```nim\n{.push boundChecks: off.}\nproc to_str_seq(a: openArray[int]): seq[string] =\n  #var\n  #  result = newSeq[string](len(a))\n  newSeq(result, len(a))\n  for i, it in a:\n    result[i] = $it\n{.pop.}\n\nassert to_str_seq([1,2,3]) == @[\"1\", \"2\", \"3\"]\n\n\n{.push boundChecks: off.}\nproc to_reversed_seq[T](a: openArray[T]): seq[T] =\n  var\n    li = 0\n    hi = high(a)\n  newSeq(result, hi + 1)\n  while hi >= 0:\n    result[hi] = a[li]\n    dec(hi)\n    inc(li)\n{.pop.}\n\nvar\n  arr = [1, 2, 3]\n  s = @[1, 2, 3]\n\nassert arr.to_reversed_seq == @[3, 2, 1]\nassert s.to_reversed_seq == @[3, 2, 1]\n```\n\n\n## [varargs](http://nim-lang.org/docs/manual.html#types-varargs)\n\n```nim\nproc anyFileWriteln0(f: File, sargs: varargs[string]): void =\n  for s in sargs:\n    write(f, s)\n  write(f, \"\\n\")\n\nanyFileWriteln0(stdout, \"abc\", \"def\", \"xyz\")\n# = anyFileWriteln0(stdout, [\"abc\", \"def\", \"xyz\",])\n\n\nproc anyFileWriteln1(f: File, sargs: varargs[string, `$`]): void =\n  for s in sargs:\n    write(f, s)\n  write(f, \"\\n\")\n\n\nanyFileWriteln1(stdout, 123, \"def\", 4.0)\n# = anyFileWriteln1(stdout, [$123, \"def\", $4.0])\n\n\nproc toS(x): string = $x\n\n\nproc anyFileWriteln2(f: File, sargs: varargs[string, toS]): void =\n  for s in sargs:\n    write(f, s)\n  write(f, \"\\n\")\n\n\nanyFileWriteln2(stdout, 123, 456, 5)\n# = anyFileWriteln2(stdout, [toS(123), toS(456), toS(5)])\n\n\nproc takeV[T](x: varargs[T]): void =\n  for s in x:\n   echo($s)\n\n\ntakeV([1, 2, 3])\n```\n\n`varargs[expr]` is treated specially: It matches a variable list of arguments of arbitrary type but always constructs an implicit array. This is required so that the builtin echo `proc` does what is expected:\n\n```nim\nproc echo*(x: varargs[expr, `$`]) {...}\n\necho(@[1, 2, 3])\n# prints \"@[1, 2, 3]\" and not \"123\"\n```\n\n\n## [Tuples and object types](http://nim-lang.org/docs/manual.html#types-tuples-and-object-types)\n\n### tuple\n\nThe order of the fields in the constructor must match the order of the tuple's definition. Different tuple-types are equivalent if they specify the same fields of the same type in the same order. The names of the fields also have to be identical.\n\nThe assignment operator for tuples copies each component.\n\n```nim\ntype\n  Person0 = tuple[\n    name: string,\n    age: Natural,\n  ]\n\nvar\n  p0: Person0\n\np0 = (name: \"Peter\", age: 20.Natural)  # assinment op does COPY each component\np0 = (\"Peter\", 20.Natural)\n\n\n# tuples in a type section can also be defined with indentation instead of []:\ntype\n  Person1 = tuple\n    name: string\n    age: Natural\n\nvar\n  p1: Person1 = (name: \"Peter\", age: 20.Natural)\n  p2: Person1 = (name: \"Adam\", age: 30.Natural)\n\n\nassert p0 == p1\nassert p0 != p2\nassert p0 == (name: \"Peter\", age: 20.Natural)\n\n\n# These are invalid because illegal recursion in the type\n# type\n  # MyTuple0 = tuple[a: MyTuple0]\n  # MyTuple1 = tuple[a: ref MyTuple1]\n\nimport tables\n\nvar\n  field_seq: seq[string] = @[]\n  field_pairs: Table[string, string] = initTable[string, string]()\n\nfor v in p0.fields:\n  field_seq.add($v)\n\nassert field_seq == @[\"Peter\", \"20\"]\n\nfield_seq.setLen(0)\n\nfor v0, v1 in fields(p0, p2):\n  field_seq.add($v0)\n  field_seq.add($v1)\n\nassert field_seq == @[\"Peter\", \"Adam\", \"20\", \"30\"]\n\nfor k, v in p0.fieldPairs:\n  field_pairs.add($k, $v)\n\nassert field_pairs == {\"name\": \"Peter\", \"age\": \"20\"}.toTable\n```\n\n\n### object\n\nThe default assignment operator for objects copies each component.\n\nIn contrast to tuples, different object types are never equivalent. Objects that have no ancestor are implicitly final and thus have no hidden type field. One can use the inheritable pragma to introduce new object roots apart from system.RootObj.\n\n```nim\ntype\n  PersonObj* {.inheritable.} = object\n    name*: string\n    age*: Natural\n  Person* = ref PersonObj\n\n  SubPersonObj* = object of PersonObj\n  SubPerson* = ref SubPersonObj\n\n  AltPersonObj* {.inheritable.} = object\n    name*: string\n    age*: Natural\n  AltPerson* = ref AltPersonObj\n\n  StudentObj* = object of PersonObj\n    id: int\n  Student* = ref StudentObj\n\nvar\n  pobj: PersonObj\n  p0, p1: Person\n  subp: SubPerson\n  altp: AltPerson\n  s: Student\n\necho(repr(pobj))\n# --> [name = nil, age = 0]\nassert p0.isNil\np0 = Person(name: \"Peter\", age: 20.Natural)  # assignment op does COPY each component\np1 = Person(name: \"Peter\", age: 20.Natural)\nsubp = SubPerson(name: \"Peter\", age: 20.Natural)\naltp = AltPerson(name: \"Peter\", age: 20.Natural)\ns = Student(name: \"Peter\", age: 20.Natural, id: 1)\n\nassert p0 of Person\nassert p0 of PersonObj\nassert p0[] of Person\nassert p0[] of PersonObj\nassert p0.type is Person\nassert p0[].type is PersonObj\n\nassert subp of SubPerson\nassert subp of SubPersonObj\nassert subp[] of SubPerson\nassert subp[] of SubPersonObj\nassert subp.type is SubPerson\nassert subp[].type is SubPersonObj\n\nassert subp of Person\nassert subp of PersonObj\nassert subp[] of Person\nassert subp[] of PersonObj\nassert subp.type is Person\nassert subp[].type is PersonObj\n\nassert s of Person\nassert s of PersonObj\nassert s[] of Person\nassert s[] of PersonObj\nassert s.type is Person\nassert s[].type is PersonObj\n\nassert p0 != p1\nassert p0[] == p1[]\nassert p0 != subp\nassert p0[] == subp[]\n#assert subp[] != p0[]\n# static error: type mismatch: got(SubPersonObj, PersonObj)\n\n#assert p0 != altp\n# static error: type mismatch: got(Person, AltPerson)\n\n#assert p0[] == altp[]\n# static error: type mismatch: got(Person, AltPerson)\nassert p0 != s\n#assert s != p0\n# static eror: type mismatch: got(Student, Person)\n\nassert p0[] == s[]\n#assert s[] == p0[]\n# static eror: type mismatch: got(StudentObj, PersonObj)\nassert s.name == \"Peter\"\nassert s.age == 20\nassert s.id == 1\n\n\nproc newStudent(name: string, age: int, id: int): Student =\n  new(result)\n  result.name = name\n  result.age = age.Natural\n  result.id = id\n\n\nvar\n  s1 = newStudent(\"Name\", 20, 1)\n  s2 = newStudent(\"Name\", 20, 1)\n\nassert s1 != s2\nassert s1[] == s2[]\n\n\nvar\n  s3: Student\n\nnew(s3)\ns3.name = \"Name\"\ns3.age = 20\ns3.id = 1\n\n\nimport tables\n\np1.name = \"Adam\"\np1.age = 30\nsubp.name = \"Adam\"\nsubp.age = 30\n\nvar\n  field_seq: seq[string] = @[]\n  field_pairs: Table[string, string] = initTable[string, string]()\n\nfor v in p0[].fields:\n  field_seq.add($v)\n\nassert field_seq == @[\"Peter\", \"20\"]\n\nfield_seq.setLen(0)\n\nfor v0, v1 in fields(p0[], p1[]):\n  field_seq.add($v0)\n  field_seq.add($v1)\n\nassert field_seq == @[\"Peter\", \"Adam\", \"20\", \"30\"]\n\nfor k, v in p0[].fieldPairs:\n  field_pairs.add($k, $v)\n\nassert field_pairs == {\"name\": \"Peter\", \"age\": \"20\"}.toTable\n\nfield_seq.setLen(0)\n# static error: type mismatch: got(SubPersonObj) but expected 'PersonObj'\n#for v0, v1 in fields(p0[], subp[]):\n#  field_seq.add($v0)\n#  field_seq.add($v1)\n\n# static error: type mismatch: got(StudentObj) but expected 'PersonObj'\n#for v0, v1 in fields(p0[], s[]):\n#  field_seq.add($v0)\n#  field_seq.add($v1)\n```\n\nhttps://github.com/nim-lang/Nim/issues/3012\nhttps://github.com/nim-lang/Nim/issues/2926\n\n```nim\ntype\n  A {.inheritable.} = object\n  B = ref object {. inheritable .}\n  C {.inheritable.} = ref object\n  D = object {.inheritable.}\n\ntype\n  AA = ref object of A\n  BB = ref object of B\n  #CC = ref object of C\n  # Error: inheritance only works with non-final objects\n  DD = ref object of D\n```\n\n\n## [Object construction](http://nim-lang.org/docs/manual.html#types-object-construction)\n\nObjects can also be created with an object construction expression that has the syntax T(fieldA: valueA, fieldB: valueB, ...) where T is an object type or a ref object type:\n\n```nim\nvar\n  student_obj = StudentObj(name: \"Anton\", age: 5, id: 3)\n  student = Student(name: \"Anton\", age: 5, id: 3)\n```\n\nFor a ref object type system.new is invoked implicitly.\n\n\n## [Object variants](http://nim-lang.org/docs/manual.html#types-object-variants)\n\nAn advantage to an object hierarchy is that no casting between different object types is needed. Yet, access to invalid object fields raises an exception.\n\n```nim\ntype\n  NodeKind = enum\n    nkInt,\n    nkFloat,\n    nkString,\n    nkAdd,\n    nkSub,\n    nkIf,\n\n  Node = ref NodeObj\n\n  NodeObj = object\n    case kind: NodeKind\n    of nkInt:\n      valInt: int\n    of nkFloat:\n      valFloat: float\n    of nkString:\n      valString: string\n    of nkAdd, nkSub:\n      opLeft, opRight: Node\n    of nkIf:\n      condition, thenPart, elsePart: Node\n\n\nvar\n  n = Node(kind: nkIf, condition: nil)\n\n\nn.thenPart = Node(kind: nkFloat, valFloat: 2.0)\n\ntry:\n  n.valString = \"\"\nexcept FieldError:\n  # Error: unhandled exception: valString is not accessible [FieldError]\n  echo(getCurrentExceptionMsg())\n\n\ntry:\n  n.kind = nkInt\nexcept FieldError:\n  # Error: unhandled exception: assignment to discriminant changes object branch [FieldError]\n  echo(getCurrentExceptionMsg())\n\n\n\nvar x: Node = Node(\n  kind: nkAdd,\n  opLeft: Node(kind: nkInt, valInt: 3),\n  opRight: Node(kind: nkInt, valInt: 2),\n)\n\nx.kind = nkSub\n```\n\nIn the example the kind field is called the discriminator: For safety its address cannot be taken and assignments to it are restricted: The new value must not lead to a change of the active object branch. For an object branch switch system.reset has to be used.\n\n\n## [Set type](http://nim-lang.org/docs/manual.html#types-set-type)\n\nThe set's basetype can only be an ordinal type. The reason is that sets are implemented as high performance bit vectors.\n\n```nim\ntype\n  CharSet = set[char]\n\nvar\n  cs0: CharSet = {'a' .. 'z', 'A' .. 'Z', '0' .. '9'}\n  cs1: CharSet = {'a'.. 'd'}\n  cs2: CharSet = {'c'.. 'f'}\n  cs3: CharSet = {'c', 'd'}\n\nassert cs1 + cs2 == {'a' .. 'f'}\nassert cs1 - cs2 == {'a', 'b'}\nassert cs1 * cs2 == {'c', 'd'}\nassert cs1 != cs2\nassert cs1 >= cs3\nassert cs1 > cs3\nassert 'a' in cs1\nassert cs1.contains('a')\nassert 'e' notin cs1\nassert card(cs1) == 4\nincl(cs1, 'a')\nassert cs1 == {'a'.. 'd'}\nincl(cs1, 'e')\nassert cs1 == {'a'.. 'e'}\nexcl(cs1, 'e')\nassert cs1 == {'a'.. 'd'}\n```\n\n| operation | meaning |\n|:----------|:--------|\n| A + B | union of two sets |\n| A * B | intersection of two sets |\n| A - B | difference of two sets (A without B's elements) |\n| A == B | set equality |\n| A <= B | subset relation (A is subset of B or equal to B) |\n| A < B | strong subset relation (A is a real subset of B) |\n| e in A | set membership (A contains element e) |\n| e notin A | A does not contain element e |\n| contains(A, e) | A contains element e |\n| card(A) | the cardinality of A (number of elements in A) |\n| incl(A, elem) | same as A = A + {elem} |\n| excl(A, elem) | same as A = A - {elem} |\n\n\n## [Reference and pointer type](http://nim-lang.org/docs/manual.html#types-reference-and-pointer-types)\n\nThe `.` (access a tuple/object field operator) and [] (array/string/sequence index operator) operators perform implicit dereferencing operations for reference types:\n\nTo allocate a new traced object, the built-in procedure `new` has to be used. To deal with untraced memory, the procedures `alloc`, `dealloc` and `realloc` can be used.\n\nSpecial care has to be taken if an untraced object contains traced objects like **traced references**, **strings** or **sequences**: in order to free everything properly, the built-in procedure GCunref has to be called before freeing the untraced memory manually:\n\nIf a reference points to nothing, it has the value nil.\n\n```nim\ntype\n  Node = ref NodeObj\n  \n  NodeObj = object\n    left, right: Node\n    data: int\n\nvar\n  x: Node\n  y: Node\n  z: Node\n\nnew(x)\nnew(y)\nnew(z)\nx.data = 9\nx.left = y\nx.right = z\n\nproc get_data(x: NodeObj): int =\n  return x.data\n\n# static error\n#echo(get_data(x))\nassert get_data(x[]) == 9\n\n{. experimental .}\nassert get_data(x) == 9\n```\n\n```nim\ntype\n  # the object type is anonymous\n  Node = ref object\n    left, right: Node\n    data: int\n\nvar\n  n: Node\nnew(n)\necho(repr(n))\n# --> ref 0x7f9e92e4c050 --> [left = nil, right = nil, data = 0]\necho(repr(n[]))\n# --> [left = nil, right = nil, data = 0]\n```\n\n```nim\ntype\n  Data = tuple[\n    x, y: int,\n    s: string,\n  ]\n\n# allocate memory for Data on the heap\nvar\n  # Without the GCunref call the memory allocated for the d.s string\n  # would never be freed. The example also demonstrates two important\n  # features for low level programming: the sizeof proc returns the\n  # size of a type or value in bytes.\n  # The cast operator can circumvent the type system: the compiler is\n  # forced to treat the result of the alloc0 call (which returns an\n  # untyped pointer) as if it would have the type ptr Data.\n  # Casting should only be done if it is unavoidable: it breaks type\n  # safety and bugs can lead to mysterious crashes.\n\n  # Note: The example only works because the memory is initialized to\n  # zero (alloc0 instead of alloc does this): d.s is thus initialized\n  # to nil which the string assignment can handle.\n  # One needs to know low level details like this when mixing garbage\n  # collected data with unmanaged memory.\n  d = cast[ptr Data](alloc0(sizeof(Data)))\n\n# create a new string on the garbage collected heap\nd.s = \"abc\"\n\n# tell the GC that the string is not needed anymore\nGCunref(d.s)\n\n# free the memory\ndealloc(d)\n```\n\n```nim\ntype\n  RequestObj {.inheritable.} = object\n    body: string\n  Request = ref RequestObj\n\n\nproc handle_varobj(r: var RequestObj) =\n  r.body = \"changed by handle_varobj\"\n\n\nproc handle_varobj_returning(r: var RequestObj): RequestObj =\n  r.body = \"changed by handle_varobj_returning\"\n  return r\n\n\nproc handle_ref(r: Request) =\n  r.body = \"changed by handle_ref\"\n\n\nvar\n  obj0: RequestObj = RequestObj(body: \"original\")\n  obj1: RequestObj = RequestObj(body: \"original\")\n\n\nassert obj0 == obj1\nassert obj0.addr != obj1.addr\nobj1 = obj0\nassert obj0 == obj1\nassert obj0.addr != obj1.addr\nobj1.body = \"x\"\nassert obj0 != obj1\nassert obj0.body != obj1.body\nhandle_varobj(obj0)\nassert obj0.body == \"changed by handle_varobj\"\nobj1 = handle_varobj_returning(obj0)\nassert obj0.body == obj1.body\nassert obj0 == obj1\nassert obj0.addr != obj1.addr\n\n\nvar\n  ref0: Request\n  ref1: Request\n\nnew(ref0)\nnew(ref1)\nassert ref0 != ref1\nassert ref0[] == ref1[]\nref1 = ref0\nref0.body = \"original\"\nassert ref0.body == ref1.body\nassert ref0 == ref1\nassert ref0.addr != ref1.addr\nassert ref0[] == ref1[]\nassert ref0[].addr == ref1[].addr\n```\n\n```nim\ntype\n  Obj = object\n    kind: string\n  ObjRef = ref Obj\n  ObjPtr = ptr Obj\n\nvar\n  obj = Obj(kind: \"Obj\")\n  obj_ref, obj_ref1 : ObjRef\n  obj_ptr, obj_ptr1 : ObjPtr\n\n\nnew(obj_ref)\nobj_ref.kind = \"ObjRef\"\n\nobj_ref1 = ObjRef(kind: \"ObjRef\") \n\nobj_ptr = cast[ptr Obj](alloc0(sizeof(Obj)))\nobj_ptr.kind = \"ObjPtr\"\n\nobj_ptr1 = create(Obj)\nobj_ptr1.kind = \"ObjPtr\"\n\n\necho(\"======== object ========\")\necho(\"obj = \", obj)\n# --> (kind: Obj)\necho(\"obj = \", repr obj)\n# --> [kind = 0x7f3ee921f050\"Obj\"]\necho(\"obj.addr = \", repr obj.addr)\n# --> ref 0x624170 --> [kind = 0x7f3ee921f050\"Obj\"]\necho(\"obj.addr.pointer = \", repr obj.addr.pointer)\n# --> 0x624170\nassert obj.addr[] == obj\nassert cast[ObjPtr](obj.addr.pointer)[] == obj\nassert cast[ptr Obj](obj.addr.pointer)[] == obj\n\necho(\"======== ref ========\")\necho(\"obj_ref = \", repr obj_ref)\n# --> ref 0x7f5d71971050 --> [kind = 0x7f5d71970078\"ObjRef\"]\necho(\"obj_ref.addr = \", repr obj_ref.addr)\n# --> ref 0x624168 --> ref 0x7f5d71971050 --> [kind = 0x7f5d71970078\"ObjRef\"]\necho(\"obj_ref.addr.pointer = \", repr obj_ref.addr.pointer)\n# --> 0x624168\nassert obj_ref.addr[] == obj_ref\nassert obj_ref.addr[][] == obj_ref[]\nassert cast[ptr ref Obj](obj_ref.addr)[] == obj_ref\nassert cast[ptr ref Obj](obj_ref.addr)[][] == obj_ref[]\n\necho(\"======== ptr ========\")\necho(\"obj_ptr = \", repr(obj_ptr))\n# ref 0x7f5d71971080 --> [kind = 0x7f5d719700c8\"ObjPtr\"]\necho(\"obj_ptr.pointer = \", repr(obj_ptr.pointer))\n# 0x7f5d71971080\nassert cast[ptr Obj](obj_ptr.pointer) == obj_ptr\nassert cast[ptr Obj](obj_ptr.pointer)[] == obj_ptr[]\n\n\n\nproc check(x: pointer): string =\n  \"pointer\"\n\n\nproc check(x: ptr int): string =\n  \"ptr int\"\n\nassert check(create(int)) == \"ptr int\"\n\nassert check(create(int).pointer) == \"pointer\"\n\n# `ptr` is implicitly convertible to `pointer`\nassert check(create(char)) == \"pointer\"\n\n\nproc check(x: ptr): string =\n  \"ptr\"\n\nassert check(create(char)) == \"ptr\"\n\n\nGCunref(obj_ptr.kind)\ndealloc(obj_ptr)\nGCunref(obj_ptr1.kind)\ndealloc(obj_ptr1)\n```\n\n\n## [not nil annotation](http://nim-lang.org/docs/manual.html#types-not-nil-annotation)\n\nAll types for that nil is a valid value can be annotated to exclude nil as a valid value with the not nil annotation:\n\n```nim\ntype\n  Proc = ref ProcObj not nil\n  ProcObj = (proc (x, y: int)) not nil\n\nproc call_proc(x: ProcObj): string =\n  \"called\"\n\nproc call_proc(x: Proc): string =\n  \"called\"\n\nproc deal_str(s: string not nil): string =\n  \"called\"\n\nvar\n  proc_obj: ProcObj\n  proc_ref: Proc\n  s: string\n\n# static error\n#call_proc(nil)\n\nassert proc_obj.isNil\nassert call_proc(proc_obj) == \"called\"\n\nassert proc_ref.isNil\nassert call_proc(proc_ref) == \"called\"\n\n# static error\n#deal_str(nil)\n\nassert s.isNil\n#discard deal_str(s)\n# Error: cannot prove 's' is not null\n```\n\n\n## [Memory regions](http://nim-lang.org/docs/manual.html#types-memory-regions)\n\n\n## [Procedural type](http://nim-lang.org/docs/manual.html#types-procedural-type)\n\n```nim\ntype\n  Event {.pure.} = enum\n    starting,\n    started,\n    stopping,\n    stopped,\n    restarting,\n    restarted,\n\nproc callback_event(\n  e: Event,\n  callback: proc(e: Event),\n) =\n  callback(e)\n\nproc callback_event_varargs(\n  e: Event,\n  callbacks: varargs[proc(e: Event) {.nimcall.}],\n) =\n  for c in callbacks:\n    c(e)\n\nproc callback_event_openArray(\n  e: Event,\n  callbacks: openArray[proc(e: Event) {.nimcall.}],\n) =\n  for c in callbacks:\n    c(e)\n\nproc echo_callback0(\n  e: Event,\n) =\n  echo(\"Event: \", e)\n\nproc echo_callback1(\n  e: Event,\n): void {.nimcall.} =\n  echo(\"Event: \", e)\n\ncallback_event(Event.started, echo_callback0)\ncallback_event(Event.started, echo_callback1)\ncallback_event_varargs(Event.started, echo_callback0, echo_callback1)\ncallback_event_openArray(Event.started, @[echo_callback0, echo_callback1])\n\n\ntype\n  Request = ref object\n    data: string\n\nproc handle_request(\n  req: var Request,\n  c: proc(req: var Request),\n) =\n  c(req)\n\nproc addstr_handler(\n  req: var Request,\n): void =\n  req.data &=\" added\"\n  discard\n\nvar\n  req = Request(data: \"data\")\n\nhandle_request(req, addstr_handler)\nassert req.data == \"data added\"\n```\n\n```nim\ntype\n  Event {.pure.} = enum\n    starting,\n    started,\n    stopping,\n    stopped,\n    restarting,\n    restarted,\n\nproc callback_one(\n  e: Event,\n  callback: proc(e: Event),\n) =\n  callback(e)\n\nproc callback_varargs(\n  e: Event,\n  callbacks: varargs[proc(e: Event) {.closure.}],\n) =\n  for cb in callbacks:\n    cb(e)\n\nproc callback_openArray(\n  e: Event,\n  callbacks: openArray[proc(e: Event) {.closure.}],\n) =\n  for cb in callbacks:\n    cb(e)\n\nproc echo_cb0(e: Event) =\n  echo(\"Event: \", e)\n\nproc echo_cb1(e: Event) {.closure.} =\n  echo(\"Event: \", e)\n\ncallback_one(Event.started, echo_cb0)\n# static error (different calling convention)\n#callback_varargs(Event.started, echo_cb0)\n#callback_openArray(Event.started, echo_cb0)\ncallback_varargs(Event.started, echo_cb1)\ncallback_openArray(Event.started, [echo_cb1])\ncallback_openArray(Event.started, @[echo_cb1])\n\n\ntype\n  Request = ref object\n    data: string\n\nproc handle_request(\n  r: var Request,\n  handler: proc(r: var Request): string\n): string =\n  return handler(r)\n\nproc change_data_handler(\n  r: var Request,\n): string {.procvar.} =\n  r.data &=\" changed\"\n  return r.data\n\nvar\n  r = Request(data: \"data\")\n\nassert handle_request(r, change_data_handler) == \"data changed\"\nassert r.data == \"data changed\"\n```\n\n\n## distinct type\n\n```nim\ntype\n  Dollar* = distinct float\n\nvar\n  d: Dollar\n\n\n# static error\n#echo(d + 12)\n\nproc `$`*(x: Dollar): string =\n  result = \"$\" & $float(x)\n\nproc `==`*(x, y: Dollar): bool {.borrow.}\nproc `<=`*(x, y: Dollar): bool {.borrow.}\nproc `<`*(x, y: Dollar): bool {.borrow.}\n\n\nproc `+`*(x, y: Dollar): Dollar =\n  result = Dollar(float(x) + float(y))\n\n\nproc `-`*(x, y: Dollar): Dollar {.borrow.}\n\n\nproc `*`*(x: Dollar, y: float): Dollar {.borrow.}\nproc `*`*(x: float, y: Dollar): Dollar {.borrow.}\n\nproc `/`*(x: Dollar, y: float): Dollar {.borrow.}\n\n\nassert Dollar(2) + d == Dollar(2) * 1\n```\n\n\n```nim\ntemplate add_same_types(typ: typedesc): stmt =\n  proc `+`*(x, y: typ): typ {.borrow.}\n  proc `-`*(x, y: typ): typ {.borrow.}\n\n  # unary ops\n  proc `+`*(x: typ): typ {.borrow.}\n  proc `-`*(x: typ): typ {.borrow.}\n\n\ntemplate multiply_by_base_type(typ, base_typ: typedesc): stmt =\n  proc `*`*(x: typ, y: base_typ): typ {.borrow.}\n  proc `*`*(x: base_typ, y: typ): typ {.borrow.}\n  proc `/`*(x: typ, y: base_typ): typ {.borrow.}\n\n\ntemplate compare_same_types(typ: typedesc): stmt =\n  proc `==`*(x, y: typ): bool {.borrow.}\n  proc `<`*(x, y: typ): bool {.borrow.}\n  proc `<=`*(x, y: typ): bool {.borrow.}\n\n\ntemplate define_currency(typ, base_typ: expr): stmt =\n  type\n    typ* = distinct base_typ\n  add_same_types(typ)\n  multiply_by_base_type(typ, base_typ)\n  compare_same_types(typ)\n\n\ndefine_currency(Euro, float)\n```\n\n```nim\ntype\n  FooObj = object\n    i: int\n    s: string\n\n  BarObj {.borrow: `.`.} = distinct FooObj\n\n  Bar = ref BarObj\n\nvar\n  b: Bar\n\n\nnew(b)\nb.i = 1\nb.s = \"s\"\n```\n\n```nim\ntype\n  AltString = distinct string\n\n\nproc add *(x: var AltString, y: string) =\n  ## workaround: https://github.com/nim-lang/Nim/issues/3082\n  system.add(string(x), y)\n\nproc `&=` *(x: var AltString, y: string) =\n  ## workaround: https://github.com/nim-lang/Nim/issues/3082\n  system.`&=`(string(x), y)\n\n\nvar\n  a = AltString(\"altstring\")\n  b = a\n\nassert string(a) == \"altstring\"\nassert string(a) == string(b)\nstring(a)[0 .. 2] = \"\"\nassert repr(a) != repr(b)\nassert repr(a) == repr(string(a))\nassert repr(a) == repr(cast[string](a))\n\n\ntype\n  AltInt = distinct int\n\nvar\n  i = AltInt(1)\n\n\nint(i) += 1\nassert int(i) == 2\nassert repr(i) == repr(int(i))\nassert repr(i) == repr(cast[int](i))\n```\n\n\n\n## void type\n\n```nim\nproc callProc[T: int|void](p: proc (x: T), x: T) =\n  when T is void:\n    p()\n  else:\n    p(x)\n\n\nproc intProc(x: int) =\n  echo(\"called intProc\")\n\n\nproc emptyProc() = discard\n\n\ncallProc[int](intProc, 12)\ncallProc(intProc, 12)\n\ncallProc[void](emptyProc)\n# static error: a void type can not be inferred in generic code.\n#callProc(emptyProc)\n```\n\n\n# Statements and Expressions\n\n## statement list expression\n\n```nim\nvar str = (var x: seq[string] = @[]; for i in [0, 1, 2]: x.add($i); x)\necho str\nassert str == @[\"0\", \"1\", \"2\"]\n```\n\nAll the other statements than list expression must be of type void. (One can use discard to produce a void type.) (;) does not introduce a new scope.\n\n\n## discard statement\n\n```nim\nproc p(x, y: int): int {.discardable.} =\n  x + y\n\np(1, 2)\n```\n\n| Type | default value |\n|:-----|:--------------|\n| any integer type | 0 |\n| any float | 0.0 |\n| char | '\\0' |\n| bool | false |\n| ref or pointer type | nil |\n| procedural type | nil |\n| sequence | nil (not @[]) |\n| string | nil (not \"\") |\n| tuple[x: A, y: B, ...] | (default(A), default(B), ...) (analogous for objects) |\n| array[0..., T] | [default(T), ...] |\n| range[T] | default(T); this may be out of the valid range |\n| T = enum | cast[T](0); this may be an invalid value |\n\n```nim\n# http://forum.nim-lang.org/t/1429/\n# I'm not sure what you are expecting. {.noinit.} makes no guarantees\n# about the content of a variable, and for global variables, it will\n# generally result in the same initial value, anyway.\n# All that {.noinit.} says is that it won't explicitly assign default\n# values; the variable will still have some value.\n# In the case of global variables, whatever's associated with zeroed\n# memory; in the case of local variables, whatever's been on the stack\n# location/in the register.\n# For me, all the asserts work, and that's pretty much what I'd expect.\n\nvar\n  int_0: int\n  int_1 {.noInit.}: int\n  float_0: float\n  float_1 {.noInit.}: float\n  char_0: char\n  char_1 {.noInit.}: char\n  string_0: string\n  string_1 {.noInit.}: string\n  bool_0: bool\n  bool_1 {.noInit.}: bool\n  arr_0: array[0..2, int]\n  arr_1 {.noInit.}: array[0..2, int]\n  seq_0: seq[int]\n  seq_1 {.noInit.}: seq[int]\n  tuple_0: tuple[id: int]\n  tuple_1 {.noInit.}: tuple[id: int]\n  range_0: range[0 .. 2]\n  range_1 {.noInit.}: range[0 .. 2]\n  proc_0: proc (x: int)\n  proc_1 {.noInit.}: proc (x: int)\n\n\nassert int_0 == 0\nassert int_1 == 0\nassert float_0 == 0.0\nassert float_1 == 0.0\nassert char_0 == '\\x0'\nassert char_1 == '\\x0'\nassert string_0 == nil\nassert string_1 == nil\nassert bool_0 == false\nassert bool_1 == false\nassert arr_0 == [0, 0, 0]\nassert arr_1 == [0, 0, 0]\nassert seq_0 == nil\nassert seq_1 == nil\nassert tuple_0 == (id: 0)\nassert tuple_1 == (id: 0)\nassert range_0 == 0\nassert range_1 == 0\nassert proc_0 == nil\nassert proc_1 == nil\n\n\ntype\n  Obj = object\n    x: int\n    y: string\n\n  Ref = ref Obj\n\n\nvar\n  obj_0: Obj\n  obj_1 {.noInit.}: Obj\n  ref_0: Ref\n  ref_1 {.noInit.}: Ref\n\n\nassert obj_0.x == 0\nassert obj_0.y == nil\nassert obj_0 == obj_1\nassert ref_0 == nil\nassert ref_1 == nil\n\n\nproc procInt: int {.noInit.} =\n  echo(\"int: \", result)  # => 140732219179232\n\nassert procInt() != 0\n\n\nproc procFloat: float {.noInit.} =\n  echo(\"float: \", result)  # => 6.953095475945912e-310\n\nassert procFloat() != 0.0\n\n\nproc procChar: char {.noInit.} =\n  echo(\"char: \", repr(result))  # => '\\0'\n\nassert procChar() == '\\0'\n\n\nproc procString: string {.noInit.} =\n  echo(\"string: \", result)  # => 6.953095475945912e-310\n\nassert procString() != nil\n\n\nproc procBool: bool {.noInit.} =\n  echo(\"bool: \", result)  # => false\n\nassert procBool() == false\n\n\nproc procArray: array[0..2, int] {.noInit.} =\n  echo(\"array: \", repr(result))  # => [0, 0, 0]\n\nassert procArray() == [0, 0, 0]\n\n\n#proc procSeq: seq[int] {.noInit.} =\n#  echo(\"seq: \", repr(result))\n\n#assert procSeq() == nil\n\n\nproc procTuple: (int, int) {.noInit.} =\n  echo(\"tuple: \", result)  # => (Field0: 3, Field1: 2)\n\nassert procTuple() != (0, 0)\n\n\nproc procRange: range[0 .. 2] {.noInit.} =\n  echo(\"range: \", result)  # => 65536\n\nassert procRange() != 0\n\n\nproc procProc: (proc (x: int): string) {.noInit.} =\n  echo(\"proc: \", repr(result))  # => [Field0 = nil, Field1 = nil]\n\nassert procProc() == nil\n```\n\n## let statement\n\n```nim\nlet\n  x: array[0..2, int] = [0, 1, 2]\n  y: int = 3\n\n# static error: can not take the address\n#echo(repr(x.addr))\n#echo(repr(y.addr))\n```\n\n## tuple unpacking\n\n```nim\nproc returnTuple: (int, int, int) =\n  (0, 1, 2)\n\nvar\n  (a, _, c) = returnTuple()\n  d, e, f = returnTuple()\n\nassert a == 0\nassert c == 2\nassert d == (0, 1, 2)\nassert e == (0, 1, 2)\nassert f == (0, 1, 2)\n```\n\n\n## const section\n\n## static statement/expression\n\n\n## if statement\nA new scope starts for the if/elif condition and ends after the corresponding then block:\n\n```nim\nif {| (let m = input =~ re\"(\\w+)=\\w+\"; m.isMatch):\n  echo \"key \", m[0], \" value \", m[1]  |}\nelif {| (let m = input =~ re\"\"; m.isMatch):\n  echo \"new m in this scope\" |}\nelse:\n  # 'm' not declared here\n```\n\nIn the example the scopes have been enclosed in {| |}.\n\n\n## case statement\n\n```nim\nlet\n  i = 1\n\ncase i:\n  of 0 .. 2, 3 .. 4:\n    echo(\"0 .. 2, 3 .. 4\")\n  of 5, 6:\n    echo(\"5, 6\")\n  of 7 .. 9:\n    echo(\"7 .. 9\")\n  else:\n    discard\n\n\nlet\n  r: range[0 .. 9] = 3\n\ncase r:\n  of 0 .. 2, 3 .. 4:\n    echo(\"0 .. 2, 3 .. 4\")\n  of 5, 6:\n    echo(\"5, 6\")\n  of 7 .. 9:\n    echo(\"7 .. 9\")\n\n\nconst\n  SymChars: set[char] = {'a' .. 'z', 'A' .. 'Z', '\\x80' .. '\\xff'}\n\nvar\n  c = 'x'\n\ncase c:\n  of SymChars, '_':\n    echo(\"an identifier\")\n  of '0' .. '9':\n    echo(\"a number\")\n  else:\n    echo(\"other\")\n\n\ntype\n  Direction = enum\n    north, south, east, west\n\nvar\n  e = north\n\ncase e:\n  of {Direction.low .. Direction(1)}:\n    echo(\"north or south\")\n  of east .. west:\n    echo(\"east or west\")\n```\n\n\n## when statement\n\n```nim\nwhen sizeof(int) == 2:\n  echo(\"running on a 16 bit system!\")\nelif sizeof(int) == 4:\n  echo(\"running on a 32 bit system!\")\nelif sizeof(int) == 8:\n  echo(\"running on a 64 bit system!\")\nelse:\n  echo(\"cannot happen!\")\n```\n\n\n##  return statement\n\n## yield statement\n\n```nim\niterator itercount(start, last:int): int =\n  var i = start\n  while i <= last:\n    yield i\n    inc(i)\n\nfor i in itercount(0, 3):\n  echo(i)\n```\n\n\n## block statement\n\n```nim\nvar\n  found: bool = false\n  arr: array[\n    0 .. 2,\n    array[0 .. 2, int]\n  ] = [\n    [0,1,2],\n    [0,1,2],\n    [0,1,7],\n  ]\nblock myblock:\n  for i in 0 .. 2:\n    for j in 0 .. 2:\n      if arr[j][i] == 7:\n        found = true\n        break myblock\n\nassert found == true\n```\n\n\n## break statement\n\n```nim\nvar\n  input: string\n\nwhile true:\n  input = readline(stdin)\n  if input.len > 0:\n    break\n\necho(input)\n```\n\n\n## continue statement\n\n```nim\nwhile expr1:\n  stmt1\n  continue\n  stmt2\n```\n\nIs equivalent to:\n\n```nim\nwhile expr1:\n  block myBlockName:\n    stmt1\n    break myBlockName\n    stmt2\n```\n\n## if expression\n\n```nim\nvar\n  a = 7\n  x = if a > 20: 20 elif a > 10: 10 else: 0\n  y =\n    if a > 20:\n      20\n    elif a > 10:\n      10\n    else:\n      0\n  z = if a > 20: 20\n    elif a > 10: 10\n    else: 0\n\nassert x == 0\nassert y == 0\nassert z == 0\n```\n\n## when expression\n\n```nim\nvar\n  x = when sizeof(int) == 2: \"16bit\" elif sizeof(int) == 4: \"32bit\" elif sizeof(int) == 8: \"64bit\" else: \"unknown\"\n  y =\n    when sizeof(int) == 2:\n      \"16bit\"\n    elif sizeof(int) == 4:\n      \"32bit\"\n    elif sizeof(int) == 8:\n      \"64bit\"\n    else:\n      \"unknown\"\n  z = when sizeof(int) == 2: \"16bit\"\n    elif sizeof(int) == 4: \"32bit\"\n    elif sizeof(int) == 8:\"64bit\"\n    else: \"unknown\"\n```\n\n## case expression\n\n```nim\nimport strutils\n\nvar\n  animal = \"unknown\"\n  x =\n    case animal\n    of \"dog\": \"bones\"\n    of \"cat\": \"mice\"\n    elif animal.endsWith\"whale\": \"plankton\"\n    else:\n      echo \"I'm not sure what to serve, but everybody loves ice cream\"\n      \"ice cream\"\n  y =\n    case animal\n    of \"dog\":\n      \"bones\"\n    of \"cat\":\n      \"mice\"\n    elif animal.endsWith\"whale\":\n      \"plankton\"\n    else:\n      echo \"I'm not sure what to serve, but everybody loves ice cream\"\n      \"ice cream\"\n```\n\nThe case expression can also introduce side effects. When multiple statements are given for a branch, Nim will use the last expression as the result value, much like in an expr template.\n\n\n## table constructor\n\n- The order of the (key,value)-pairs is preserved, thus it is easy to support ordered dicts with for example {key: val}.newOrderedTable.\n- A table literal can be put into a const section and the compiler can easily put it into the executable's data section just like it can for arrays and the generated data section requires a minimal amount of memory.\n- Every table implementation is treated equal syntactically.\n- Apart from the minimal syntactic sugar the language core does not need to know about tables.\n\n```nim\nconst\n  x = {\"key1\": \"value1\", \"key2\", \"key3\": \"value2\"}\n\nassert x == [(\"key1\", \"value1\"), (\"key2\", \"value2\"), (\"key3\", \"value2\")]\n\n\nimport tables\n\nconst\n  s = x.newOrderedTable\n```\n\n\n## type conversions\n\nSyntactically a type conversion is like a procedure call, but a type name replaces the procedure name. A type conversion is always safe in the sense that a failure to convert a type to another results in an exception (if it cannot be determined statically).\n\nOrdinary procs are often preferred over type conversions in Nim: For instance, $ is the toString operator by convention and toFloat and toInt can be used to convert from floating point to integer or vice versa.\n\n\n## type casts\n\n```nim\ncast[int](x)\n```\n\nType casts are a crude mechanism to interpret the bit pattern of an expression as if it would be of another type. Type casts are only needed for low-level programming and are inherently unsafe.\n\n\n## addr operator\n\nThe addr operator returns the address of an l-value. If the type of the location is T, the addr operator result is of the type ptr T. An address is always an untraced reference. Taking the address of an object that resides on the stack is unsafe, as the pointer may live longer than the object on the stack and can thus reference a non-existing object. One can get the address of variables, but one can't use it on variables declared through let statements:\n\n```nim\nlet s0 = \"Hello\"\n\nvar\n  s1 = s0\n  p0 : pointer = addr(s1)\n  ptr0 : ptr = addr(s1)\n  ptr1 : ptr string = addr(s1)\n\nassert p0 == ptr0\nassert ptr0 == ptr1\n\n\necho(repr(p0))\n# --> 0x622c58\n\necho(repr(cast[ptr string](p0)))\n# --> ref 0x622c58 --> 0x7f20a4a1d078\"Hello\"\n\necho(repr(ptr0))\n# --> ref 0x622c58 --> 0x7f20a4a1d078\"Hello\"\n\necho(repr(ptr1))\n# --> ref 0x622c58 --> 0x7f20a4a1d078\"Hello\"\n\n\necho repr(addr(s1))\n# --> ref 0x622c58 --> 0x7f20a4a1d078\"Hello\"\n\necho cast[ptr string](p0)[]\n# --> Hello\n\n\n# The following line doesn't compile:\n#echo repr(addr(s0))\n# Error: expression has no address\n```\n\n## procedure\n\nOperators are procedures with a special operator symbol as identifier:\n\n```nim\nimport strutils\n\nproc `$` (x: int): string =\n  # converts an integer to a string; this is a prefix operator.\n  result = intToStr(x)\n```\n\nOperators with one parameter are prefix operators, operators with two parameters are infix operators. (However, the parser distinguishes these from the operator's position within an expression.) There is no way to declare postfix operators: all postfix operators are built-in and handled by the grammar explicitly.\n\nAny operator can be called like an ordinary proc with the 'opr' notation. (Thus an operator can have more than two parameters):\n\n```nim\nproc `*+` (a, b, c: int): int =\n  # Multiply and add\n  result = a * b + c\n\nassert `*+`(3, 4, 6) == `+`(`*`(3, 4), 6)\n```\n\n\n## export marker\n\n```nim\nproc exportedEcho*(s: string) = echo s\n\nproc `*`*(a: string; b: int): string =\n  result = newStringOfCap(a.len * b)\n  for i in 1..b:\n    result.add a\n\nassert \"ABC\" * 3 == \"ABCABCABC\"\n\n\nvar\n  exportedVar*: int\n\nconst\n  exportedConst* = 78\n\ntype\n  ExportedType* = object\n    exportedField*: int\n```\n\n\n## method call syntax\n\n```nim\nimport strutils\n\necho(\"abc\".len)\n# is the same as echo(len(\"abc\"))\n\necho(\"abc\".toUpper())\n\necho({'a', 'b', 'c'}.card)\n\nstdout.writeln(\"Hallo\")\n# the same as writeln(stdout, \"Hallo\")\n```\n\n\n## properties\n\n```nim\ntype\n  Socket* = ref object of RootObj\n    FHost: int # cannot be accessed from the outside of the module\n               # the `F` prefix is a convention to avoid clashes since\n               # the accessors are named `host`\n\nproc host*(s: Socket): int {.inline.} =\n  ## getter of hostAddr\n  s.FHost\n\n\nproc `host=`*(s: var Socket, value: int) {.inline.} =\n  ## setter of hostAddr\n  s.FHost = value\n\n\nvar\n  s: Socket\n\nnew(s)\n\ns.host = 34\n# same as `host=`(s, 34)\n\nassert s.host == 34\n```\n\n\n## closure\n\n```nim\nproc create_closure_seq(count: Positive): seq[proc: int] =\n  newSeq(result, count)\n  #for i in 0 .. count - 1:\n  for i in countup(0, count - 1):\n    result[i] = proc: int = int(i)\n\n\nvar\n  result = (var a: array[0..2, int]; for i, p in create_closure_seq(3).pairs: a[i] = p(); a)\n\nassert result == [2, 2, 2]\n```\n\n\n## anonymous procedure\n\n```nim\nimport algorithm\n\n\nvar\n  cities = @[\"Frankfurt\", \"Tokyo\", \"New York\"]\n\ncities.sort(proc (x,y: string): int =\n    cmp(x.len, y.len))\n\n\nassert cities == @[\"Tokyo\", \"New York\", \"Frankfurt\"]\n```\n\n\n## nonoverloadable builtins\n\n```\ndeclared, defined, definedInScope, compiles, low, high, sizeOf, is, of, shallowCopy, getAst, astToStr, spawn, procCall\n```\n\nThus they act more like keywords than like ordinary identifiers; unlike a keyword however, a redefinition may shadow the definition in the system module. From this list the following should not be written in dot notation x.f since x cannot be type checked before it gets passed to f:\n\n```\ndeclared, defined, definedInScope, compiles, getAst, astToStr\n```\n\n\n## var parameters\n\n```nim\nproc divmod(a, b: int; res, remainder: var int) =\n  res = a div b\n  remainder = a mod b\n\nvar\n  x, y: int\n\ndivmod(8, 5, x, y) # modifies x and y\n\nassert x == 1\nassert y == 3\n```\n\nThe argument passed to a var parameter has to be an l-value. Var parameters are implemented as hidden pointers.\nThe above example is equivalent to:\n\n```nim\nproc divmod(a, b: int; res, remainder: ptr int) =\n  res[] = a div b\n  remainder[] = a mod b\n\nvar\n  x, y: int\n\ndivmod(8, 5, addr(x), addr(y))\n\nassert x == 1\nassert y == 3\n```\n\nThis can be done in a cleaner way by returning a tuple.\n\n```nim\nproc divmod(a, b: int): tuple[res, remainder: int] =\n  result.res = a div b\n  result.remainder = a mod b\n\n\nvar\n  t = divmod(8, 5)\n\nassert t.res == 1\nassert t.remainder == 3\n\n\nvar\n  (res, remainder) = divmod(8, 5)\n\nassert res == 1\nassert remainder == 3\n```\n\nNote: var parameters are never necessary for efficient parameter passing. Since non-var parameters cannot be modified the compiler is always free to pass arguments by reference if it considers it can speed up execution.\n\n\n## var return type\n\nA proc, converter or iterator may return a var type which means that the returned value is an l-value and can be modified by the caller:\n\n```nim\nvar g = 0\n\nproc WriteAccessToG(): var int =\n  result = g\n\nWriteAccessToG() = 6\n\nassert g == 6\n```\n\nIt is a compile time error if the implicitly introduced pointer could be used to access a location beyond its lifetime:\n\n```nim\n# static error: address of 'g' may not escape its stack frame\nproc WriteAccessToG(): var int =\n  var g = 0\n  result = g # Error!\n```\n\nFor iterators, a component of a tuple return type can have a var type too:\n\n```nim\nvar\n  sq = @[\"a\", \"b\", \"c\"]\n\n\n# static error: 'str[0]' cannot be assigned to\n#for i, str in sq.pairs:\n#  str[0] = 'x'\n\n\nfor i, str in sq.mpairs:\n  str[0] = 'x'\n\n\nassert sq == @[\"x\", \"x\", \"x\"]\n\n\n# same iterator as built-in mpairs\niterator custom_mpairs(a: var seq[string]): tuple[key: int, val: var string] =\n  for i in 0..a.high:\n    yield (i, a[i])\n\n\nfor i, str in sq.custom_mpairs:\n  str.add(\"y\")\n\n\nassert sq == @[\"xy\", \"xy\", \"xy\"]\n\n\nvar\n  arr: array[\n    0..2, \n    array[0..2, int],\n  ] = [\n    [0, 1, 2],\n    [0, 1, 2],\n    [0, 1, 2],\n  ]\n\n\n# static error: 'item[0]' cannot be assigned to\n#for item in arr.items:\n#  item[0] = 2\n\n\nfor item in arr.mitems:\n  item[0] = 2\n\n\nassert arr[0] == [2, 1, 2]\n```\n\nIn the standard library every name of a routine that returns a var type starts with the prefix m per convention.\n\n\n## Overloading of the subscript operator\n\nThe [] subscript operator for arrays/openarrays/sequences can be overloaded.\n\n\n# Multi-methods\n\nProcedures always use static dispatch. Multi-methods use dynamic dispatch.\n\n```nim\ntype\n  Expression = ref object of RootObj ## abstract base class for an expression\n  Literal = ref object of Expression\n    x: int\n  PlusExpr = ref object of Expression\n    a, b: Expression\n\n\nmethod eval(e: Expression): int =\n  # override this base method\n  quit \"to override!\"\n\n\nmethod eval(e: Literal): int = return e.x\n\n\nmethod eval(e: PlusExpr): int =\n  # watch out: relies on dynamic binding\n  result = eval(e.a) + eval(e.b)\n\n\nproc newLit(x: int): Literal =\n  new(result)\n  result.x = x\n\n\nproc newPlus(a, b: Expression): PlusExpr =\n  new(result)\n  result.a = a\n  result.b = b\n\n\nassert eval(\n  newPlus(\n    newPlus(\n      newLit(1), newLit(2)\n    ),\n    newLit(4)\n  )\n) == 7\n```\n\n```nim\ntype\n  Thing = ref object of RootObj\n  Unit = ref object of Thing\n    x: int\n\n\nmethod collide(a, b: Thing): int {.inline.} =\n  quit \"to override!\"\n\n\nmethod collide(a: Thing, b: Unit): int {.inline.} =\n  return 1\n\n\nmethod collide(a: Unit, b: Thing): int {.inline.} =\n  return 2\n\n\nvar a, b: Unit\nnew a\nnew b\n\nassert collide(a, b) == 2\n```\n\nInvocation of a multi-method cannot be ambiguous: collide 2 is preferred over collide 1 because the resolution works from left to right. In the example `(Unit, Thing)` is preferred over `(Thing, Unit)`.\n\nPerformance note: Nim does not produce a virtual method table, but generates dispatch trees. This avoids the expensive indirect branch for method calls and enables inlining. However, other optimizations like compile time evaluation or dead code elimination do not work with methods.\n\n\n```nim\nimport math\n\ntype\n  Dollar* = distinct float\n\n  Kg* = distinct float\n\n  Fruit* = ref object {.inheritable.}\n    origin*: string\n    price*: Dollar\n\n  Banana* = ref object of Fruit\n    size*: int\n\n  Pumpkin* = ref object of Fruit\n    weight*: Kg\n\n  BigPumpkin* = ref object of Pumpkin\n\n  Bucket* {.inheritable.} = ref object\n    fruits*: seq[string]\n\n\n# op proc\nproc `$` *(x: Dollar): string {.borrow.}\n\nproc `$` *(x: Kg): string {.borrow.}\n\nproc `==` *(x, y: Dollar): bool {.borrow, inline.}\n\n\n# op method\nmethod `$`*(self: Fruit): string =\n  \"Fruit: origin='\" & self.origin & \", price=\" & $self.price\n\nmethod `$`*(self: Banana): string =\n  result = procCall($Fruit(self)) & \", size=\" & $self.size\n  result[0 .. 4] = \"Banana\"\n\nmethod `$`*(self: Pumpkin): string =\n  result = procCall($Fruit(self)) & \", weight=\" & $self.weight\n  result[0 .. 4] = \"Pumpkin\"\n\nmethod `$`*(self: BigPumpkin): string =\n  result = procCall($Fruit(self)) & \", weight=\" & $self.weight\n  result[0 .. 4] = \"BigPumpkin\"\n\n\n# reduction method\nmethod reduction_m(self: Fruit): Dollar =\n  echo(\n    \"Called Fruit.reduction_m (\" & $self & \")\"\n  )\n  Dollar(0)\n\nmethod reduction_m(self: Banana): Dollar =\n  echo(\n    \"Called Banana.reduction_m (\" & $self & \")\"\n  )\n  Dollar(9)\n\nmethod reduction_m(self: Pumpkin): Dollar =\n  echo(\n    \"Called Pumpkin.reduction_m (\" & $self & \")\"\n  )\n  Dollar(1)\n\n\n# reduction proc\nproc reduction_p(self: Fruit): Dollar =\n  echo(\n    \"Called Fruit.reduction_p (\" & $self & \")\"\n  )\n  Dollar(0)\n\nproc reduction_p(self: Banana): Dollar =\n  echo(\n    \"Called Banana.reduction_p (\" & $self & \")\"\n  )\n  Dollar(9)\n\nproc reduction_p(self: Pumpkin): Dollar =\n  echo(\n    \"Called Pumpkin.reduction_p (\" & $self & \")\"\n  )\n  Dollar(1)\n\n\n\n# calcPrice method\nmethod calcPrice_m*(self: Fruit): Dollar =\n  echo(\n    \"Called Fruit.calcPrice_m (\" & $self & \")\"\n  )\n  Dollar(round(float(self.price) * 100) / 100 - float(self.reduction_m))\n\nmethod calcPrice_m*(self: Banana): Dollar =\n  echo(\n    \"Called Banana.calcPrice_m (\" & $self & \")\"\n  )\n  procCall Fruit(self).calcPrice_m()\n\nmethod calcPrice_m*(self: Pumpkin): Dollar =\n  echo(\n    \"Called Pumpkin.calcPrice_m (\" & $self & \")\"\n  )\n  Dollar(float(procCall(Fruit(self).calcPrice_m())) * float(self.weight))\n\nmethod calcPrice_m*(self: Bigpumpkin): Dollar =\n  echo(\n    \"Called Bigpumpkin.calcPrice_m (\" & $self & \")\"\n  )\n  Dollar(1000)\n\n\n# calcPrice proc\nproc calcPrice_p*(self: Fruit): Dollar =\n  echo(\n    \"Called Fruit.calcPrice_p (\" & $self & \")\"\n  )\n  Dollar(round(float(self.price) * 100) / 100 - float(self.reduction_p))\n\nproc calcPrice_p*(self: Banana): Dollar =\n  echo(\n    \"Called Banana.calcPrice_p (\" & $self & \")\"\n  )\n  calcPrice_p(Fruit(self))\n\nproc calcPrice_p*(self: Pumpkin): Dollar =\n  echo(\n    \"Called Pumpkin.calcPrice_p (\" & $self & \")\"\n  )\n  Dollar(float(calcPrice_p(Fruit(self))) * float(self.weight))\n\nproc calcPrice_p*(self: Bigpumpkin): Dollar =\n  echo(\n    \"Called Bigpumpkin.calcPrice_p (\" & $self & \")\"\n  )\n  Dollar(1000)\n\n\n# add method\nmethod add(self: Bucket, fruit: Fruit) =\n  echo(\n    \"Called Bucket.Add (\" & $fruit & \")\"\n  )\n  self.fruits.add($fruit)\n\nmethod add(self: Bucket, fruit: Banana) =\n  echo(\n    \"Called Bucket.Add (\" & $fruit & \")\"\n  )\n  procCall self.add(Fruit(fruit))\n\nmethod add(self: Bucket, fruit: Pumpkin) =\n  echo(\n    \"Called Bucket.add (\" & $fruit & \")\"\n  )\n  procCall self.add(Fruit(fruit))\n\n\n# Constructor\nproc newBanana*(size: int, origin: string, price: float): Banana =\n  new(result)\n  result.origin = origin\n  result.price = Dollar(price)\n  result.size = size\n\nproc newPumpkin*(weight: float, origin: string, price: float): Pumpkin =\n  new(result)\n  result.origin = origin\n  result.price = Dollar(price)\n  result.weight = Kg(weight)\n\nproc newBigPumpkin*(weight: float, origin: string, price: float): BigPumpkin =\n  new(result)\n  result.origin = origin\n  result.price = Dollar(price)\n  result.weight = Kg(weight)\n\nproc newBucket(): Bucket =\n  new(result)\n  result.fruits = newSeq[string]()\n\n\nif isMainModule:\n  var banana = newBanana(size=10, origin=\"country_0\", price=1000)\n  var pumpkin = newPumpkin(weight=100, origin=\"country_1\", price=10000)\n  var big_pumpkin = newBigPumpkin(weight=1000, origin=\"country_1\", price=20000)\n\n  assert banana.calcPrice_m() == 991.0.Dollar\n  # --> Called Banana.calcPrice_m (Banana: origin='country_0, price=1000.0, size=10)\n  # --> Called Fruit.calcPrice_m (Banana: origin='country_0, price=1000.0, size=10)\n  # --> Called Banana.reduction_m (Banana: origin='country_0, price=1000.0, size=10)\n\n  assert banana.calcPrice_p() == 1000.0.Dollar\n  # --> Called Banana.calcPrice_p (Banana: origin='country_0, price=1000.0, size=10)\n  # --> Called Fruit.calcPrice_p (Banana: origin='country_0, price=1000.0, size=10)\n  # --> Called Fruit.reduction_p (Banana: origin='country_0, price=1000.0, size=10)\n\n  assert pumpkin.calcPrice_m() == 999900.0.Dollar\n  # --> Called Pumpkin.calcPrice_m (Pumpkin: origin='country_1, price=10000.0, weight=100.0)\n  # --> Called Fruit.calcPrice_m (Pumpkin: origin='country_1, price=10000.0, weight=100.0)\n  # --> Called Pumpkin.reduction_m (Pumpkin: origin='country_1, price=10000.0, weight=100.0)\n\n  assert pumpkin.calcPrice_p() == 1000000.0.Dollar\n  # --> Called Pumpkin.calcPrice_p (Pumpkin: origin='country_1, price=10000.0, weight=100.0)\n  # --> Called Fruit.calcPrice_p (Pumpkin: origin='country_1, price=10000.0, weight=100.0)\n  # --> Called Fruit.reduction_p (Pumpkin: origin='country_1, price=10000.0, weight=100.0)\n\n  var bucket = newBucket()\n  bucket.add(banana)\n  # --> Called Bucket.Add (Banana: origin='country_0, price=1000.0, size=10)\n  # --> Called Bucket.Add (Banana: origin='country_0, price=1000.0, size=10)\n\n  bucket.add(pumpkin)\n  # --> Called Bucket.add (Pumpkin: origin='country_1, price=10000.0, weight=100.0)\n  # --> Called Bucket.Add (Pumpkin: origin='country_1, price=10000.0, weight=100.0)\n  bucket.add(big_pumpkin)\n  # --> Called Bucket.add (BigPumpkin: origin='country_1, price=20000.0, weight=1000.0)\n  # --> Called Bucket.Add (BigPumpkin: origin='country_1, price=20000.0, weight=1000.0)\n  echo($bucket.fruits)\n  # --> @[Banana: origin='country_0, price=1000.0, size=10, Pumpkin: origin='country_1, price=10000.0, weight=100.0, BigPumpkin: origin='country_1, price=20000.0, weight=1000.0]\n```\n\n\n\n# iterators and for statement\n\n```nim\niterator triples *(s: string): (Natural, int, char) {.inline.} =\n  var i = 0\n  while i < len(s):\n    yield (i.Natural, ord(s[i]), s[i])\n    inc(i)\n\n\nvar q = newSeq[(int, char)](2)\n\nfor i, o, c in \"hi\".triples:\n  q[i] = (o, c)\n\nassert q == @[(104, 'h'), (105, 'i')]\n```\n\n## implicit items/pairs invocation\n\n\n## first class iterators\n\n* inline iterator\n  Inline iterators are second class citizens; They can be passed as parameters only to other inlining code facilities like templates, macros and other inline iterators.\n* closure iterator\n  Can be passed around more freely.\n\nrestrictions:\n\n* `yield` in a closure iterator can not occur in a `try` statement.\n* For now, a closure iterator cannot be evaluated at compile time.\n* `return` is allowed in a closure iterator (but rarely useful).\n* Both inline and closure iterators cannot be recursive.\n\nIterators that are neither marked {.closure.} nor {.inline.} explicitly default to being inline, but that this may change in future versions of the implementation.\n\nThe iterator type is always of the calling convention closure implicitly; the following example shows how to use iterators to implement a collaborative tasking system:\n\n```nim\niterator count0(): int {.closure.} =\n  yield 0\n\n\niterator count2(): int {.closure.} =\n  var x = 1\n  yield x\n  inc x\n  yield x\n\n\nproc invoke(iter: iterator(): int {.closure.}): seq[int] =\n  newSeq(result, 0)\n  for x in iter():\n    result.add(x)\n\n\nassert invoke(count0) == @[0]\nassert invoke(count2) == @[1, 2]\n```\n\n```nim\nimport sequtils\n\ntype\n  Task = iterator (ticker: int)\n\niterator a1(ticker: int) {.closure.} =\n  echo \"a1: A\"\n  yield\n  echo \"a1: B\"\n  yield\n  echo \"a1: C\"\n\niterator a2(ticker: int) {.closure.} =\n  echo \"a2: A\"\n  yield\n  echo \"a2: B\"\n  yield\n  echo \"a2: C\"\n  yield\n  echo \"a2: D\"\n  yield\n  echo \"a2: E\"\n  yield\n  echo \"a2: F\"\n\niterator a3(ticker: int) {.closure.} =\n  echo \"a3: A\"\n  yield\n  echo \"a3: B\"\n  yield\n  echo \"a3: C\"\n\n\nproc runTasks(tasks: varargs[Task]) =\n  var\n    task_seq: seq[Task] = toSeq(tasks.items)\n    ticker = 0\n\n  while true:\n    let\n      x = task_seq[ticker]\n\n    x(ticker)\n\n    if finished(x):\n      task_seq.delete(ticker)\n      if task_seq.len == 0:\n        break\n      elif ticker >= task_seq.high:\n        ticker = 0\n    else:\n      ticker = (ticker + 1) mod task_seq.len\n\n\nrunTasks(a1, a2, a3)\n```\n\nThe builtin system.finished can be used to determine if an iterator has finished its operation; no exception is raised on an attempt to invoke an iterator that has already finished its work.\n\nNote that system.finished is error prone to use because it only returns true one iteration after the iterator has finished:\n\n```nim\niterator mycount(a, b: int): int {.closure.} =\n  var x = a\n  while x <= b:\n    yield x\n    inc x\n\nvar\n  c = mycount # instantiate the iterator\n  result: seq[int] = @[]\n\nwhile not finished(c):\n  result.add(c(1, 3))\n\n\nassert result == @[1, 2, 3, 0]\n# The last '0' is not intended value.\n```\n\nInstead this code has be used;\n\n```nim\niterator mycount(a, b: int): int {.closure.} =\n  var x = a\n  while x <= b:\n    yield x\n    inc x\n\nvar\n  c = mycount # instantiate the iterator\n  result: seq[int] = @[]\n\nwhile true:\n  let value = c(1, 3)\n  if finished(c):\n    break # and discard 'value'!\n  result.add(value)\n\n\nassert result == @[1, 2, 3]\n```\n\nIt helps to think that the iterator actually returns a pair (value, done) and finished is used to access the hidden done field.\n\nClosure iterators are resumable functions and so one has to provide the arguments to every call. To get around this limitation one can capture parameters of an outer factory proc:\n\n```nim\nproc mycount(a, b: int): iterator: (int, int) =\n  result = iterator: (int, int) =\n    var x = a\n    while x <= b:\n      yield (x, x)\n      inc(x)\n\nvar\n  result: seq[int] = @[]\nlet\n  c = mycount(1, 3)\n\n\nfor a, b in c():\n  result.add(a)\n\nassert result == @[1, 2, 3]\n```\n\n## converters\n\n\n## Type sections\n\n```nim\ntype # example demonstrating mutually recursive types\n  Node = ref NodeObj # a traced pointer to a NodeObj\n  NodeObj = object\n    le, ri: Node     # left and right subtrees\n    sym: ref Sym     # leaves contain a reference to a Sym\n  \n  Sym = object       # a symbol\n    name: string     # the symbol's name\n    line: int        # the line the symbol was declared in\n    code: Node      # the symbol's abstract syntax tree\n\n\n# http://forum.nim-lang.org/t/1422\ntype\n  Obj = object\n    x: int\n    y: int\n\n  Ref = ref Obj\n\n  RefOrObj = Ref or Obj\n\n\nproc init(arg: var RefOrObj, x, y: int) =\n  when arg is ref:\n    new(arg)\n  arg.x = x\n  arg.y = y\n\n\nproc sum(arg: RefOrObj): int =\n  arg.x + arg.y\n\n\nproc main() =\n  var\n    o: Obj\n    r: Ref\n\n  init(o, 1, 1)\n  assert sum(o) == 2\n\n  init(r, 2, 2)\n  assert sum(r) == 4\n\nmain()\n```\n\nA type section begins with the type keyword. It contains multiple type definitions. A type definition binds a type to a name. Type definitions can be recursive or even mutually recursive. Mutually recursive types are only possible within a single type section. Nominal types like objects or enums can only be defined in a type section.\n\n\n# Exception handling\n\n## try statement\n\n```nim\nimport strutils\n\nvar\n  f: File\n\nif open(f, \"/root/.bashrc\"):\n  try:\n    var a = readLine(f)\n    var b = readLine(f)\n    echo(\"sum: \" & $(parseInt(a) + parseInt(b)))\n  except Exception:\n    echo(\"Catch all !\")\n    let\n      exc = getCurrentException()\n      desc = \": parent=\" & repr(exc.parent) & \", msg=\" & exc.msg\n \n    if exc of ValueError:\n      # could not convert string to integer\n      echo(\"could not convert string to integer. ValueError\", desc)\n    elif exc of OverflowError:\n      echo(\"overflow!. OverflowError\", desc)\n    elif exc of IOError:\n      echo(\"IO error!. IOError\", desc)\n    else:\n      echo(\"Unknown exception!: Exception\", desc)\n\n  # no-op\n  except OverflowError:\n    echo(\"overflow!\")\n  except ValueError:\n    echo(\"could not convert string to integer\")\n  except IOError:\n    echo(\"IO error!\")\n  except:\n    echo(\"Unknown exception!\")\n  finally:\n    close(f)\n```\n\n\n## Try expression\n\n```nim\nimport strutils\n\nlet\n  x = try: parseInt(\"133a\")\n    except: -1\n    finally: echo \"parseInt finished\"\n\nassert x == -1\n\n\nlet\n  y =\n    try:\n      parseint(\"133a\")\n    except:\n       -1\n    finally:\n      echo \"parseInt finished\"\n\nassert y == -1\n```\n\nTo prevent confusing code there is a parsing limitation; if the try follows a ( it has to be written as a one liner\n\n```nim\nimport strutils\n\nlet\n  x = (try: parseInt(\"133a\") except: -1 finally: echo \"parseInt finished\")\n\n\nassert x == -1\n```\n\n\n## Except clauses\n\nNote that getCurrentException always returns a ref Exception type. If a variable of the proper type is needed (in the example above, IOError), one must convert it explicitly:\n\n```nim\nimport strutils\n\nvar\n  x: int\n\n\ntry:\n  x = parseInt(\"133a\")\nexcept ValueError:\n  let\n    ref_exc = getCurrentException()\n    exc = (ref ValueError)(getCurrentException())\n  echo(repr(ref_exc))\n  echo(repr(exc))\n  assert ref_exc == exc\n\n\ntry:\n  x = parseInt(\"133a\")\nexcept ValueError:\n  echo(\"ValueError: \", getCurrentExceptionMsg())\n```\n\n## Defer statement\n\nInstead of a try finally statement a defer statement can be used.\n\nAny statements following the defer in the current block will be considered to be in an implicit try block:\nTop level defer statements are not supported since it's unclear what such a statement should refer to.\n\n```nim\nimport streams\n\n\nproc withDefer() =\n  var\n    f: File\n\n  if f.open(filename=\"/tmp/numbers.txt\", mode=FileMode.fmWrite):\n    defer:\n      close(f)\n\n    f.write(\"abc\")\n    f.write(\"abc\")\n    f.write(\"\\n\")\n\nwithDefer()\n\n\nproc sameAsDefer() =\n  var\n    f: File\n\n  if f.open(filename=\"/tmp/numbers.txt\", mode=FileMode.fmWrite):\n    try:\n      f.write(\"abc\")\n      f.write(\"def\")\n      f.write(\"\\n\")\n    finally:\n      f.close()\n\nsameAsDefer()\n```\n\n## Raise statement\n\nThe raise statement is the only way to raise an exception.\n\nIf no exception name is given, the current exception is re-raised. The ReraiseError exception is raised if there is no exception to re-raise. It follows that the raise statement always raises an exception (unless a raise hook has been provided).\n\n```nim\nraise newException(OSError, \"OS error\")\n```\n\n\n# Effect system\n\n## Exception tracking\n\nThe raises pragma can be used to explicitly define which exceptions a proc/iterator/method/converter is allowed to raise. The compiler verifies this.\n\nAn empty raises list (raises: []) means that no exception may be raised.\n\n```nim\nproc p(what: bool) {.raises: [IOError, OSError].} =\n  if what:\n    raise newException(IOError, \"IO\")\n  else:\n    raise newException(OSError, \"OS\")\n\n\nproc p(): bool {.raises: [].} =\n  try:\n    result = true\n  except:\n    result = false\n```\n\nA raises list can also be attached to a proc type. This affects type compatibility:\n\n```nim\ntype\n  Callback = proc (s: string) {.\n    raises: [IOError],\n  .}\n\n\nvar\n  c: Callback\n\n\nproc p(x: string) =\n  raise newException(OSError, \"OS\")\n\n\n# static error: type error\nc = p\n```\n\n\nFor a routine p the compiler uses inference rules to determine the set of possibly raised exceptions; the algorithm operates on p's call graph:\n\n1. Every indirect call via some proc type T is assumed to raise system.Exception (the base type of the exception hierarchy) and thus any exception unless T has an explicit raises list. However if the call is of the form f(...) where f is a parameter of the currently analysed routine it is ignored. The call is optimistically assumed to have no effect. Rule 2 compensates for this case.\n2. Every expression of some proc type wihtin a call that is not a call itself (and not nil) is assumed to be called indirectly somehow and thus its raises list is added to p's raises list.\n3. Every call to a proc q which has an unknown body (due to a forward declaration or an importc pragma) is assumed to raise system.Exception unless q has an explicit raises list.\n4. Every call to a method m is assumed to raise system.Exception unless m has an explicit raises list.\n5. For every other call the analysis can determine an exact raises list.\n6. For determining a raises list, the raise and try statements of p are taken into consideration.\n\nRules 1-2 ensure the following works:\n\n```nim\nproc noRaise(x: proc()) {.raises: [].} =\n  # unknown call that might raise anything, but valid:\n  x()\n\nproc doRaise() {.raises: [IOError].} =\n  raise newException(IOError, \"IO\")\n\nproc use() {.raises: [].} =\n  # doesn't compile! Can raise IOError!\n  noRaise(doRaise)\n```\n\nSo in many cases a callback does not cause the compiler to be overly conservative in its effect analysis.\n\n\n## Tag tracking\n\nThe exception tracking is part of Nim's effect system. Raising an exception is an effect. Other effects can also be defined. A user defined effect is a means to tag a routine and to perform checks against this tag:\n\n```nim\ntype\n  IO = object ## input/output effect\n\n\nproc readLine(): string {.tags: [IO].} =\n  \"some line\"\n\n\nproc IO_please() {.tags: [IO].} =\n  let\n    x = readLine()\n\n\nproc no_IO_please() {.tags: [].} =\n  # the compiler prevents this:\n  let\n    x = readLine()\n```\n\nA tag has to be a type name. A tags list - like a raises list - can also be attached to a proc type. This affects type compatibility.\n\nThe inference for tag tracking is analogous to the inference for exception tracking.\n\n\n## Read/Write tracking\n\nNote: Read/write tracking is not yet implemented!\n\nThe inference for read/write tracking is analogous to the inference for exception tracking.\n\n\n## Effects pragma\n\nThe effects pragma has been designed to assist the programmer with the effects analysis. It is a statement that makes the compiler output all inferred effects up to the effects's position:\n\n```nim\nproc proc0(what: bool) =\n  if what:\n    raise newException(IOError, \"IO\")\n    {.effects.}\n    # --> Hint: ref IOError [User]\n  else:\n    raise newException(OSError, \"OS\")\n\n\nproc proc1(what: bool) =\n  if what:\n    raise newException(IOError, \"IO\")\n  else:\n    raise newException(OSError, \"OS\")\n    {.effects.}\n    # --> Hint: ref IOError [User]\n    # --> Hint: ref OSError [User]\n```\n\nThe compiler produces a hint message that IOError can be raised. OSError is not listed as it cannot be raised in the branch the effects pragma appears in. \n\n\n# Generics\n\n```nim\ntype\n  BinaryTreeObj[T] = object\n    ## BinaryTreeObj is a generic type with generic param ``T``\n    left, right: BinaryTree[T]\n    ## left and right subtrees; may be nil\n    data: T\n    ## the data stored in a node\n\n  BinaryTree[T] = ref BinaryTreeObj[T]\n  ## a shorthand for notational convenience\n\n\nproc newNode[T](data: T): BinaryTree[T] =\n  ## constructor for a node\n  new(result)\n  result.data = data\n\n\nproc add[T](\n  root: var BinaryTree[T],\n  n: BinaryTree[T],\n) =\n  if root == nil:\n    root = n\n  else:\n    var\n      it = root\n    while it != nil:\n      var\n        c = cmp(it.data, n.data)\n        ## compare the data items;\n        ## uses the generic ``cmp`` proc that works for any type that\n        ## has a ``==`` and ``<`` operator\n\n      if c < 0:\n        if it.left == nil:\n          it.left = n\n          return\n        it = it.left\n      else:\n        if it.right == nil:\n          it.right = n\n          return\n        it = it.right\n\n\niterator inorder[T](root: BinaryTree[T]): T =\n  ## inorder traversal of a binary tree\n  ## recursive iterators are not yet implemented, so this does not\n  ## work in the current compiler!\n  if root.left != nil:\n    yield inorder(root.left)\n  if root.right != nil:\n    yield inorder(root.right)\n\n\nvar\n  root: BinaryTree[string]\n  # instantiates a BinaryTree with the type string\n\n\nroot.add(newNode(\"hallo\"))\nroot.add(newNode(\"world\"))\n# instantiates generic procs ``newNode`` and ``add``\n\n\nfor str in inorder(root):\n  echo(str)\n```\n\n## is operator\n\n```nim\ntype\n  Table[Key, Val] = object\n    keys: seq[Key]\n    values: seq[Val]\n    count: Natural\n    when not (Key is string):  # nil value for strings used for optimization\n      deletedKeys: seq[bool]\n\n\nproc initTable*[Key, Val](initialSize: Natural = 64): Table[Key, Val] =\n  result.count = 0\n  newSeq(result.keys, initialSize)\n  newSeq(result.values, initialSize)\n  echo(\"String init\")\n  #newSeq(result.deletedKeys, 0)\n\n\nproc add*[Key, Val](t: var Table[Key, Val], key: Key, value: Val) =\n  t.keys[t.count] = key\n  t.values[t.count] = value\n  t.count += 1\n\n\nvar\n  t: Table[string, int] = initTable[string, int]()\n\nt.add(\"A\", 1)\n```\n\n## type operator\n\n```nim\nvar\n  x = 0\n\nvar\n  y: type(x)\n```\n\nIf type is used to determine the result type of a proc/iterator/converter call c(X) (where X stands for a possibly empty list of arguments), the interpretation where c is an iterator is preferred over the other interpretations:\n\n```nim\nimport strutils\n\n# strutils contains some ``split`` procs and iterators.\n#   proc split(s: string; seps: set[char] = Whitespace): seq[string]\n#   proc split(s: string; sep: char): seq[string]\n#   proc split(s: string; sep: string): seq[string]\n#   iterator split(s: string; seps: set[char] = Whitespace): string\n#   iterator split(s: string; sep: char): string\n#   iterator split(s: string; sep: string): string\n# But since an iterator is the preferred interpretation, `y' has the\n# type ``string``:\n\nvar\n  y: type(\"a b c\".split)\n\n\ny = \"a\"\n```\n\n## Type classes\n\nA type class is a special pseudo-type that can be used to match against types in the context of overload resolution or the is operator. Nim supports the following built-in type classes:\n\n| type class | matches |\n|:---------|:-------|\n| object | any object type |\n| tuple | any tuple type |\n| enum | any enumeration |\n| proc | any proc type |\n| ref | any ref type |\n| ptr | any ptr type |\n| var | any var type |\n| distinct | any distinct type |\n| array | any array type |\n| set | any set type |\n| seq | any seq type |\n| auto | any type |\n\n\n\n\nEvery generic type automatically creates a type class of the same name that will match any instantiation of the generic type.\n\nType classes can be combined using the standard boolean operators to form more complex type classes:\n\n```nim\n# create a type class that will match all tuple and object types\nimport tables\n\ntype\n  ObjX = object\n    x: int\n    y: int\n    z: int\n\n  RefX = ref ObjX\n\n  RecordType = tuple[x:int, y:int, z:int] or object\n\n\nproc printFields(rec: RecordType) =\n  var\n    t = initTable[string, int]()\n  for k, v in fieldPairs(rec):\n    t[k] = v\n  assert t == {\"x\": 1, \"y\": 2, \"z\": 3}.toTable\n\nvar\n  tuple_rec: tuple[x:int, y:int, z:int] = (x: 1, y: 2, z: 3)\n  obj_rec = ObjX(x: 1, y: 2, z: 3)\n\nprintFields(tuple_rec)\nprintFields(obj_rec)\n```\n\n\nProcedures utilizing type classes in such manner are considered to be implicitly generic. They will be instantiated once for each unique combination of param types used within the program.\n\nNim also allows for type classes and regular types to be specified as type constraints of the generic type parameter:\n\n```nim\nproc gproc[T: int|string](x, y: T): string =\n  \"accepted by A\"\n\nassert gproc(100, 200) == \"accepted by A\"\nassert gproc(\"a\", \"b\") == \"accepted by A\"\n\n# static error: type mismatch\n#assert gproc(100, \"b\") == \"accepted by A\"\n#assert gproc(\"a\", 200) == \"accepted by A\"\n\n\nproc gproc[X: int|string, Y: string](x:X, y:Y): string =\n  \"accepted by B\"\n\n\nassert gproc(100, 200) == \"accepted by A\"\n\n# static error: ambiguous call\n#assert gproc(\"a\", \"b\") == \"accepted by A\"\n\nassert gproc(100, \"b\") == \"accepted by B\"\n\n# static error: type mismatch\nassert gproc(\"a\", 200) == \"accepted by A\"\n```\n\nBy default, during overload resolution each named type class will bind to exactly one concrete type. Here is an example taken directly from the system module to illustrate this:\n\n```nim\nproc `==`*[T: tuple|object](x, y: T): bool =\n  ## generic ``==`` operator for tuples that is lifted from the components\n  ## of `x` and `y`.\n  for a, b in fields(x, y):\n    if a != b: return false\n  return true\n```\n\nAlternatively, the distinct type modifier can be applied to the type class to allow each param matching the type class to bind to a different type.\n\nIf a proc param doesn't have a type specified, Nim will use the distinct auto type class (also known as any):\n\n```nim\nproc concat(a, b): string = $a & $b\n\nassert concat(\"str+\", 1) == \"str+1\"\n```\n\nProcs written with the implicitly generic style will often need to refer to the type parameters of the matched generic type. They can be easily accessed using the dot syntax:\n\n```nim\nimport typetraits\n\ntype\n  NameEnum = enum\n    first_name,\n    last_name,\n    middle_name\n\ntype\n  NormalMatrix[Rows, Cols, T] = array[Rows, array[Cols, T]]\n\n  Normal3Matrix[T] = NormalMatrix[range[0..2], range[0..2], T]\n\n  NameEnumMatrix[T] = NormalMatrix[range[0..2], NameEnum, T]\n\n\nproc `*`* [Rows, Cols, Ta, Tb](\n  a: NormalMatrix[Rows, Cols, Ta],\n  b: NormalMatrix[Rows, Cols, Tb],\n): NormalMatrix[Rows, Cols, Ta] =\n  for r in Rows.low .. Rows.high:\n    var\n      inner: array[Cols, int]\n    for c in Cols.low .. Cols.high:\n      inner[c] = a[r][c] * b[r][c]\n    result[r] = inner\n\nvar\n  normalm: NormalMatrix[range[0..2], range[0..2], int] = [\n    [0, 1, 2],\n    [10, 11, 12],\n    [20, 21, 22],\n  ]\n  normal3m: Normal3Matrix[int] = [\n    [0, 1, 2],\n    [10, 11, 12],\n    [20, 21, 22],\n  ]\n  enumm: NameEnumMatrix[string] = [\n    [\"Fn0\", \"Ln0\", \"Mn0\"],\n    [\"Fn1\", \"Ln1\", \"Mn1\"],\n    [\"Fn2\", \"Ln2\", \"Mn2\"],\n  ]\n\nassert normalm.type.name == \"NormalMatrix[range 0..2(int), range 0..2(int), system.int]\"\nassert normalm[2][2] == 22\nassert normalm.Rows is range[0..2]\nassert normalm.Cols is range[0..2]\nassert normalm.T is int\nassert normal3m.type.name == \"Normal3Matrix[system.int]\"\nassert normal3m[2][2] == 22\nassert normal3m.Rows is range[0..2]\nassert normal3m.Cols is range[0..2]\nassert normal3m.T is int\nassert enumm.type.name == \"NameEnumMatrix[system.string]\"\nassert enumm[2][NameEnum.middle_name] == \"Mn2\"\nassert enumm[2][NameEnum(2)] == \"Mn2\"\nassert enumm.Rows is range[0..2]\nassert enumm.Cols is NameEnum\nassert enumm.T is string\nassert normalm * normal3m == [[0, 1, 4], [100, 121, 144], [400, 441, 484]]\n\n\ntype\n  StaticMatrix[Rows, Cols: static[int], T] = array[Rows, array[Cols, T]]\n  Static3Matrix[T] = StaticMatrix[3, 3, T]\n\nvar\n  staticm: StaticMatrix[3, 3, int] = [\n    [0, 1, 2],\n    [10, 11, 12],\n    [20, 21, 22],\n  ]\n  static3m: Static3Matrix[int] = [\n    [0, 1, 2],\n    [10, 11, 12],\n    [20, 21, 22],\n  ]\n\nassert staticm.type.name == \"StaticMatrix[3, 3, system.int]\"\nassert staticm.Rows == 3\nassert staticm.Cols == 3\nassert staticm.T is int\nassert static3m.type.name == \"Static3Matrix[system.int]\"\nassert static3m.Rows == 3\nassert static3m.Cols == 3\nassert static3m.T is int\nassert staticm * static3m == [[0, 1, 4], [100, 121, 144], [400, 441, 484]]\n\n\n\ntype\n  #LwMatrix[Rows, Cols: static[range], T] = array[(high(Rows) + 1) * (high(Cols) + 1), T]\n  StaticLwMatrix[Rows, Cols: static[int], T] = array[Rows * Cols, T]\n  StaticLw3Matrix[T] = StaticLwMatrix[3, 3, T]\n\nproc `[]`* (a: StaticLwMatrix, row, col: int): StaticLwMatrix.T =\n  if (row >= 0 and row >= StaticLwMatrix.Rows) or\n    (row < 0 and row < -StaticLwMatrix.Rows) or\n    (col >=0 and col >= StaticLwMatrix.Cols) or\n    (col < 0 and col < -StaticLwMatrix.Cols):\n      raise newException(IndexError, \"index out of bounds\")\n  a[StaticLwMatrix.Cols * row + (if col >= 0: col else: StaticLwMatrix.Cols + col)]\n\n\n# same as above\nproc `[]`* [Rows, Cols, T](a: StaticLwMatrix[Rows, Cols, T], row, col: T): T =\n  if (row >= 0 and row >= Rows) or\n    (row < 0 and row < -Rows) or\n    (col >=0 and col >= Cols) or\n    (col < 0 and col < -Cols):\n      raise newException(IndexError, \"index out of bounds\")\n  a[Cols * row + (if col >= 0: col else: Cols + col)]\n\n\nvar\n  staticlwm: StaticLwMatrix[3, 3, int] = [\n    0, 1, 2,\n    10, 11, 12,\n    20, 21, 22,\n  ]\n  staticlw3m: StaticLw3Matrix[int] = [\n    0, 1, 2,\n    10, 11, 12,\n    20, 21, 22,\n  ]\n\nassert staticlwm.type.name == \"StaticLwMatrix[3, 3, system.int]\"\nassert staticlwm.Rows == 3\nassert staticlwm.Cols == 3\nassert staticlwm.T is int\nassert staticlw3m.type.name == \"StaticLw3Matrix[system.int]\"\nassert staticlw3m.Rows == 3\nassert staticlw3m.Cols == 3\nassert staticlw3m.T is int\nassert staticlw3m[1, -1] == 12\n\n\ntype\n  NormalMatrixObj[Rows, Cols, T] = object\n    data: array[Rows, array[Cols, T]]\n\n  NameEnumMatrixObj[Rows, T] = object\n    data: array[Rows, array[NameEnum, T]]\n\n  StaticMatrixObj[Rows, Cols: static[int], T] = object\n    data: array[Rows, array[Cols, T]]\n\nvar\n  normalm_obj = NormalMatrixObj[range[0..2], range[0..2], int](\n    data: [\n      [0, 1, 2],\n      [10, 11, 12],\n      [20, 21, 22],\n    ]\n  )\n  enumm_obj = NameEnumMatrixObj[range[0..2], string](\n    data: [\n      [\"Fn0\", \"Ln0\", \"Mn0\"],\n      [\"Fn1\", \"Ln1\", \"Mn1\"],\n      [\"Fn2\", \"Ln2\", \"Mn2\"],\n    ]\n  )\n  staticm_obj = StaticMatrixObj[3, 3, int](\n    data: [\n      [0, 1, 2],\n      [10, 11, 12],\n      [20, 21, 22],\n    ]\n  )\n\n\nassert normalm_obj.type.name == \"NormalMatrixObj[range 0..2(int), range 0..2(int), system.int]\"\nassert enumm_obj.type.name == \"NameEnumMatrixObj[range 0..2(int), system.string]\"\nassert staticm_obj.type.name == \"StaticMatrixObj[3, 3, system.int]\"\n```\n\n\nAlternatively, the type operator can be used over the proc params for similar effect when anonymous or distinct type classes are used.\n\nWhen a generic type is instantiated with a type class instead of a concrete type, this results in another more specific type class:\n\n", "tags": ["Nim"]}