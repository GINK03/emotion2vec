{"context": " More than 1 year has passed since last update.#include <stdio.h>\n#include <string.h>\n\ntypedef int * const cp_i;\ntypedef char * const cp_c;\n\nchar input[] = \"\\\n    0   2RcL3LL22   ABCNYjmpsvy147edcbcdef\\\n    1   L3R4L5RR5R3L5   A?\\\n    2   2ReLLe  ABCNYjmpsvy147eTITe741yvspmjYNC\\\n    3   1ReRRe  ABMXilorux036fUJUf630xuroliXMB\\\n    4   ReRRe   ALWhknqtwz25gVKVg52zwtqnkhWLA\\\n    5   f   ABCDEFGHIJK?\\\n    6   Rf  ALWhknqtwz25gVK?\\\n    7   1Rf     ABMXilorux036fUJ?\\\n    8   2Rf     ABCNYjmpsvy147eTI?\\\n    9   aR1RaL1LaR1R2L1L2   ABCDEFGHIJKVUTSRQPONMLWXYZabcdefg567432\\\n    10  2R1R2L1L2R1R2L1L2R1R2L1L2R1R2L1L2   ABCNMLWXYjihklmponqrsvutwxy\\\n    11  2R4R2L4L2R4R2L4L2R4R2L4L2   ABCNYjmlknqtwxy147efgVK?\\\n    12  R1L2R4R2L4L2R4R2L4L2R4R2L4L2    ALMNYjmponqtwz0147eTUVK?\\\n    13  R2L2R4R2L4L2R4R2L4L2R4R2L4L2    ALWXYjmpsrqtwz2347eTIJK?\\\n    14  R3L2R4R2L4L2R4R2L4L2R4R2L4L2    ALWhijmpsvutwz2567eTI?\\\n    15  R5L2L5L1LaR1L4L5    ALWhknopmjYNCBMXilorux0325gVKJIHGF\\\n    16  1R2L4L2R4R2L4L2R4   ABMXYZabQFGHIJUfg?\\\n    17  2R2L4L2R4R2L4L2R4   ABCNYZabcRGHIJKVg?\\\n    18  3R2L4L2R4R2L4L2R4   ABCDOZabcdSHIJK?\\\n    19  4R2L4L2R4R2L4L2R4   ABCDEPabcdeTIJK?\\\n    20  5R2L4L2R4R2L4L2R4   ABCDEFQbcdefUJK?\\\n    21  LLL1RRR1LLL1RRR2R1  ALMXYZ?\\\n    22  R3RRR3  ALWhij?\\\n    23  1LLL4RRR1LR1RL1     ABMXilm?\\\n    24  R2L1R2L1R3R4    ALWXilmpsvut?\\\n    25  7R4f47LLLc6R9L  ABCDEFGHSd?\\\n    26  5RR868L8448LL4R6    ABCDEFEDCBA?\\\n    27  42Rd1RLLa7L5    ABCDEFGRc?\\\n    28  RRLL6RLR1L5d12LaLRRL529L    ABCDEFGRSTUV?\\\n    29  RLR7L6LL1LRRRcRL52R     ALWhknqtuv?\\\n    30  1RLR8RLR1R437L99636R    ABMXiloruxwtqnkhWLA?\\\n    31  LLL2L3La9Le5LRR     ALWXYZOD?\\\n    32  R1LcRR491   ALMNOPQRSTUV?\\\n    33  R8L1R1R512L8RLLReRf     ALWhknqtwx0z?\\\n    34  1RcL8f1L29a5    ABMXilorux036fedcbaZYXW?\\\n    35  R822LeL46LL39LL     ALWhknqtwz25gfedcbaZYXW?\\\n    36  9R3L5LRRLb5R3L7cLLLR4L  ABCDEFGHIJUf65?\\\n    37  7LLRRR2R3R69Lf76eR2L    ABCDEFGHSdcbaPE?\\\n    38  8RRRLL3Le   ABCDEFGHITe765?\\\n    39  8R5RLL6LbL4LL5bL    ABCDEFGHITe7410z?\\\n    40  6LR2R1LR5LRLRL484L63    ABCDEFGHITe741yxw?\";\n\nconst char MAP[] = \"\\\n?????????????\\\n?ABCDEFGHIJK?\\\n?LMNOPQRSTUV?\\\n?WXYZabcdefg?\\\n?hij?????765?\\\n?klm?????432?\\\n?nop?????10z?\\\n?qrs?????yxw?\\\n?tuv?????vut?\";\n\nconst char HEX[] = \"0123456789abcdefRL\";\n\nvoid solve(const cp_c data, cp_c output)\n{\n    const int DIR[] = {1,13,-1,-13};\n    int dir = 0, pos = 1+13*1, i, j, code=0, cnt=0;\n    output[0]='A';\n    for(i=0; data[i]!='\\0'; i++) {\n        code = strchr(HEX,data[i])-HEX;\n        if(code>=16) {\n            dir = (data[i]=='R') ? (dir+1)%4: (dir+3)%4;\n            continue;\n        }\n        for(j=0; j<code; j++) {\n            pos += DIR[dir];\n            output[(++cnt)] = MAP[pos];\n            if(MAP[pos]=='?') return;\n            if(pos/13==8) {\n                pos = 13*8+12-pos%13;\n                dir = (dir+2)%4;\n            }\n        }\n    }\n}\n\ntypedef struct {\n    char c[40];\n} OUTPUT;\n\nint main()\n{\n    int i = 0;\n    char *code = strtok(input,\"\\t \"), *data[3] = {code,0,0};\n    OUTPUT output={0}, clr={0}; \n    for(i=1; code!=NULL; i++) {\n        //printf(\"%s\\n\",code);\n        if(i%3==0) {\n            output = clr;\n            solve(data[1],output.c);\n            printf(\"%s\\t%s\\t%s\\t%s\\n\",\n                (strcmp(output.c,data[2])==0) ? \"OK\": \"NG\",\n                data[0],data[1],output.c);\n        }\n        data[i%3] = code = strtok(NULL,\"\\t \");\n    }\n    return 0;\n}\n\n```c:\n#include <stdio.h>\n#include <string.h>\n\ntypedef int * const cp_i;\ntypedef char * const cp_c;\n\nchar input[] = \"\\\n\t0 \t2RcL3LL22 \tABCNYjmpsvy147edcbcdef\\\n\t1 \tL3R4L5RR5R3L5 \tA?\\\n\t2 \t2ReLLe \tABCNYjmpsvy147eTITe741yvspmjYNC\\\n\t3 \t1ReRRe \tABMXilorux036fUJUf630xuroliXMB\\\n\t4 \tReRRe \tALWhknqtwz25gVKVg52zwtqnkhWLA\\\n\t5 \tf \tABCDEFGHIJK?\\\n\t6 \tRf \tALWhknqtwz25gVK?\\\n\t7 \t1Rf \tABMXilorux036fUJ?\\\n\t8 \t2Rf \tABCNYjmpsvy147eTI?\\\n\t9 \taR1RaL1LaR1R2L1L2 \tABCDEFGHIJKVUTSRQPONMLWXYZabcdefg567432\\\n\t10 \t2R1R2L1L2R1R2L1L2R1R2L1L2R1R2L1L2 \tABCNMLWXYjihklmponqrsvutwxy\\\n\t11 \t2R4R2L4L2R4R2L4L2R4R2L4L2 \tABCNYjmlknqtwxy147efgVK?\\\n\t12 \tR1L2R4R2L4L2R4R2L4L2R4R2L4L2 \tALMNYjmponqtwz0147eTUVK?\\\n\t13 \tR2L2R4R2L4L2R4R2L4L2R4R2L4L2 \tALWXYjmpsrqtwz2347eTIJK?\\\n\t14 \tR3L2R4R2L4L2R4R2L4L2R4R2L4L2 \tALWhijmpsvutwz2567eTI?\\\n\t15 \tR5L2L5L1LaR1L4L5 \tALWhknopmjYNCBMXilorux0325gVKJIHGF\\\n\t16 \t1R2L4L2R4R2L4L2R4 \tABMXYZabQFGHIJUfg?\\\n\t17 \t2R2L4L2R4R2L4L2R4 \tABCNYZabcRGHIJKVg?\\\n\t18 \t3R2L4L2R4R2L4L2R4 \tABCDOZabcdSHIJK?\\\n\t19 \t4R2L4L2R4R2L4L2R4 \tABCDEPabcdeTIJK?\\\n\t20 \t5R2L4L2R4R2L4L2R4 \tABCDEFQbcdefUJK?\\\n\t21 \tLLL1RRR1LLL1RRR2R1 \tALMXYZ?\\\n\t22 \tR3RRR3 \tALWhij?\\\n\t23 \t1LLL4RRR1LR1RL1 \tABMXilm?\\\n\t24 \tR2L1R2L1R3R4 \tALWXilmpsvut?\\\n\t25 \t7R4f47LLLc6R9L \tABCDEFGHSd?\\\n\t26 \t5RR868L8448LL4R6 \tABCDEFEDCBA?\\\n\t27 \t42Rd1RLLa7L5 \tABCDEFGRc?\\\n\t28 \tRRLL6RLR1L5d12LaLRRL529L \tABCDEFGRSTUV?\\\n\t29 \tRLR7L6LL1LRRRcRL52R \tALWhknqtuv?\\\n\t30 \t1RLR8RLR1R437L99636R \tABMXiloruxwtqnkhWLA?\\\n\t31 \tLLL2L3La9Le5LRR \tALWXYZOD?\\\n\t32 \tR1LcRR491 \tALMNOPQRSTUV?\\\n\t33 \tR8L1R1R512L8RLLReRf \tALWhknqtwx0z?\\\n\t34 \t1RcL8f1L29a5 \tABMXilorux036fedcbaZYXW?\\\n\t35 \tR822LeL46LL39LL \tALWhknqtwz25gfedcbaZYXW?\\\n\t36 \t9R3L5LRRLb5R3L7cLLLR4L \tABCDEFGHIJUf65?\\\n\t37 \t7LLRRR2R3R69Lf76eR2L \tABCDEFGHSdcbaPE?\\\n\t38 \t8RRRLL3Le \tABCDEFGHITe765?\\\n\t39 \t8R5RLL6LbL4LL5bL \tABCDEFGHITe7410z?\\\n\t40 \t6LR2R1LR5LRLRL484L63 \tABCDEFGHITe741yxw?\";\n\nconst char MAP[] = \"\\\n?????????????\\\n?ABCDEFGHIJK?\\\n?LMNOPQRSTUV?\\\n?WXYZabcdefg?\\\n?hij?????765?\\\n?klm?????432?\\\n?nop?????10z?\\\n?qrs?????yxw?\\\n?tuv?????vut?\";\n\nconst char HEX[] = \"0123456789abcdefRL\";\n\nvoid solve(const cp_c data, cp_c output)\n{\n\tconst int DIR[] = {1,13,-1,-13};\n\tint dir = 0, pos = 1+13*1, i, j, code=0, cnt=0;\n\toutput[0]='A';\n\tfor(i=0; data[i]!='\\0'; i++) {\n\t\tcode = strchr(HEX,data[i])-HEX;\n\t\tif(code>=16) {\n\t\t\tdir = (data[i]=='R') ? (dir+1)%4: (dir+3)%4;\n\t\t\tcontinue;\n\t\t}\n\t\tfor(j=0; j<code; j++) {\n\t\t\tpos += DIR[dir];\n\t\t\toutput[(++cnt)] = MAP[pos];\n\t\t\tif(MAP[pos]=='?') return;\n\t\t\tif(pos/13==8) {\n\t\t\t\tpos = 13*8+12-pos%13;\n\t\t\t\tdir = (dir+2)%4;\n\t\t\t}\n\t\t}\n\t}\n}\n\ntypedef struct {\n\tchar c[40];\n} OUTPUT;\n\nint main()\n{\n\tint i = 0;\n\tchar *code = strtok(input,\"\\t \"), *data[3] = {code,0,0};\n\tOUTPUT output={0}, clr={0};\t\n\tfor(i=1; code!=NULL; i++) {\n\t\t//printf(\"%s\\n\",code);\n\t\tif(i%3==0) {\n\t\t\toutput = clr;\n\t\t\tsolve(data[1],output.c);\n\t\t\tprintf(\"%s\\t%s\\t%s\\t%s\\n\",\n\t\t\t\t(strcmp(output.c,data[2])==0) ? \"OK\": \"NG\",\n\t\t\t\tdata[0],data[1],output.c);\n\t\t}\n\t\tdata[i%3] = code = strtok(NULL,\"\\t \");\n\t}\n\treturn 0;\n}\n```", "tags": ["C\u8a00\u8a9e", "yhpg", "\u3069\u3046\u66f8\u304f"]}