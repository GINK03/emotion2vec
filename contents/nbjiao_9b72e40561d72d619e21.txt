{"context": " More than 1 year has passed since last update.\u305f\u307e\u305f\u307eunsigned long\u3092float\u306b\u5909\u63db\u3059\u308b\u5fc5\u8981\u304c\u3042\u3063\u3066\u3001\u3069\u3046\u3082\u6a19\u6e96\u95a2\u6570\u306f\u306a\u3044\u3088\u3046\u306a\u306e\u3067\u899a\u66f8\u3068\u3057\u3066\u3002\nsse\u306b\u306fsigned long(= int32_t)\u3092float\u306b\u5909\u63db\u3057\u3066\u304f\u308c\u308b_mm_cvtepi32_ps()\u3068\u3044\u3046\u95a2\u6570\u304c\u3042\u308b\u306e\u3067\u3059\u304c\u3001\u3053\u308c\u3067\u306f0xffffffff\u304c-1.0f\u306b\u5909\u63db\u3055\u308c\u3066\u3057\u307e\u3044\u307e\u3059\u3002\n\u3084\u308a\u65b9\uff11\u306fstackoverflow\u306b\u3042\u3063\u305f\u30e4\u30c4\u306e\u30a2\u30bb\u30f3\u30d6\u30e9\u3092\u95a2\u6570\u306b\u7f6e\u304d\u63db\u3048\u305f\u3060\u3051\u3067\u3059\u3002\n\u624b\u5143\u306e\u74b0\u5883(corei5 ivybridge)\u3067\u306f\u3001\u3084\u308a\u65b92\u306e\u65b9\u304c\u6c17\u6301\u3061\u901f\u304f\u306a\u308a\u307e\u3057\u305f\u3002\n\nuint32tofloat.cpp\n    // test data\n    __m128i val = _mm_set_epi32(-1,0x10000,0xffffffff,0x7fffffff);\n\n// val is treated as signed long.\n// 0xffffffff becomes -1.0. ;(\n    __m128 valf = _mm_cvtepi32_ps(val);\n    __m256d vald = _mm256_cvtepi32_pd(val);\n\n// uint32 -> float method1\n    __m128i mask = _mm_set1_epi32(0xffffu);\n    __m128i onep39 = _mm_set1_epi32(0x53000000);\n    // low 16bits\n    __m128i val_low = _mm_and_si128(val, mask);\n    // 16bit int -> float\n    __m128 vallf = _mm_cvtepi32_ps(val_low);\n\n    // high 16bits\n    __m128i val_high = _mm_srli_epi32(val, 16);\n    val_high = _mm_or_si128(val_high, onep39);\n    __m128 valhf = _mm_castsi128_ps(val_high);\n    valhf = _mm_sub_ps(valhf, _mm_castsi128_ps(onep39));\n\n    // lower part + higher part --> result\n    __m128 result = _mm_add_ps(vallf, valhf);\n// uint32 -> float method1\n\n// uint32 -> float method2\n    __m128i mask = _mm_set1_epi32(0xffffu);\n    __m128 _0x10000 = _mm_set1_ps(0x10000);\n    // low 16bits\n    __m128i val_low = _mm_and_si128(val, mask);\n    // 16bit int -> float\n    __m128 vallf = _mm_cvtepi32_ps(val_low);\n\n    // high 16bits\n    __m128i val_high = _mm_srli_epi32(val, 16);\n    // 16bit int -> float\n    __m128 valhf = _mm_cvtepi32_ps(val_high);\n    // multiply 65536\n    valhf = _mm_mul_ps(valhf, _0x10000);\n\n    // lower part + higher part --> result\n    __m128 result = _mm_add_ps(vallf, valhf);\n// uint32 -> float method2\n\n\n\n\u53c2\u8003\nhttp://www.officedaytime.com/tips/simd.html\nhttp://stackoverflow.com/questions/9151711/most-efficient-way-to-convert-vector-of-uint32-to-vector-of-float\n\u305f\u307e\u305f\u307eunsigned long\u3092float\u306b\u5909\u63db\u3059\u308b\u5fc5\u8981\u304c\u3042\u3063\u3066\u3001\u3069\u3046\u3082\u6a19\u6e96\u95a2\u6570\u306f\u306a\u3044\u3088\u3046\u306a\u306e\u3067\u899a\u66f8\u3068\u3057\u3066\u3002\n\nsse\u306b\u306fsigned long(= int32_t)\u3092float\u306b\u5909\u63db\u3057\u3066\u304f\u308c\u308b_mm_cvtepi32_ps()\u3068\u3044\u3046\u95a2\u6570\u304c\u3042\u308b\u306e\u3067\u3059\u304c\u3001\u3053\u308c\u3067\u306f0xffffffff\u304c-1.0f\u306b\u5909\u63db\u3055\u308c\u3066\u3057\u307e\u3044\u307e\u3059\u3002\n\n\u3084\u308a\u65b9\uff11\u306fstackoverflow\u306b\u3042\u3063\u305f\u30e4\u30c4\u306e\u30a2\u30bb\u30f3\u30d6\u30e9\u3092\u95a2\u6570\u306b\u7f6e\u304d\u63db\u3048\u305f\u3060\u3051\u3067\u3059\u3002\n\n\u624b\u5143\u306e\u74b0\u5883(corei5 ivybridge)\u3067\u306f\u3001\u3084\u308a\u65b92\u306e\u65b9\u304c\u6c17\u6301\u3061\u901f\u304f\u306a\u308a\u307e\u3057\u305f\u3002\n\n```uint32tofloat.cpp\n    // test data\n    __m128i val = _mm_set_epi32(-1,0x10000,0xffffffff,0x7fffffff);\n\n// val is treated as signed long.\n// 0xffffffff becomes -1.0. ;(\n    __m128 valf = _mm_cvtepi32_ps(val);\n    __m256d vald = _mm256_cvtepi32_pd(val);\n\n// uint32 -> float method1\n    __m128i mask = _mm_set1_epi32(0xffffu);\n    __m128i onep39 = _mm_set1_epi32(0x53000000);\n    // low 16bits\n    __m128i val_low = _mm_and_si128(val, mask);\n    // 16bit int -> float\n    __m128 vallf = _mm_cvtepi32_ps(val_low);\n\n    // high 16bits\n    __m128i val_high = _mm_srli_epi32(val, 16);\n    val_high = _mm_or_si128(val_high, onep39);\n    __m128 valhf = _mm_castsi128_ps(val_high);\n    valhf = _mm_sub_ps(valhf, _mm_castsi128_ps(onep39));\n\n    // lower part + higher part --> result\n    __m128 result = _mm_add_ps(vallf, valhf);\n// uint32 -> float method1\n\n// uint32 -> float method2\n    __m128i mask = _mm_set1_epi32(0xffffu);\n    __m128 _0x10000 = _mm_set1_ps(0x10000);\n    // low 16bits\n    __m128i val_low = _mm_and_si128(val, mask);\n    // 16bit int -> float\n    __m128 vallf = _mm_cvtepi32_ps(val_low);\n\n    // high 16bits\n    __m128i val_high = _mm_srli_epi32(val, 16);\n    // 16bit int -> float\n    __m128 valhf = _mm_cvtepi32_ps(val_high);\n    // multiply 65536\n    valhf = _mm_mul_ps(valhf, _0x10000);\n\n    // lower part + higher part --> result\n    __m128 result = _mm_add_ps(vallf, valhf);\n// uint32 -> float method2\n```\n\n# \u53c2\u8003\nhttp://www.officedaytime.com/tips/simd.html\nhttp://stackoverflow.com/questions/9151711/most-efficient-way-to-convert-vector-of-uint32-to-vector-of-float\n\n", "tags": ["SSE", "SIMD"]}