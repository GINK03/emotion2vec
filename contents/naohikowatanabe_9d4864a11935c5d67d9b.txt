{"tags": ["three.js", "WebGL", "OpenGLES"], "context": " More than 1 year has passed since last update.\n\n\u6982\u8981\nThree.js \u3068 (Three.js \u672a\u4f7f\u7528\u306e) WebGL \u3068 OpenGL ES \u3067\u4e09\u89d2\u5f62\u3092\u63cf\u3044\u3066\u3001\u9055\u3044\u3092\u6bd4\u8f03\u3057\u3066\u307f\u305f\u3001\u3068\u3044\u3046\u8a71\u3067\u3059\u3002\n\u4ee5\u4e0b\u306e\u30b5\u30f3\u30d7\u30eb\u306e WebGL\u3001 OpenGL ES \u306f PVRSDK \u304b\u3089\u62dd\u501f\u3057\u307e\u3057\u305f\u3002\u30b3\u30fc\u30c9\u306e\u69cb\u6210\u304c\u4f3c\u3066\u3044\u3066\u6bd4\u8f03\u3057\u3084\u3059\u3044\u305f\u3081\u3067\u3059\u3002\n\n\u52d5\u6a5f\n\u6982\u5ff5\u3068\u3057\u3066\u306f Three.js, WebGL, OpenGL ES \u306e\u9055\u3044\u306f\u3001\n\u300cWebGL \u306f OpenGL ES \u306e\u30d0\u30a4\u30f3\u30c7\u30a3\u30f3\u30b0\u3067\u3057\u3087\u3001Three.js \u306f WebGL \u306e\u30e9\u30c3\u30d1\u30fc\u3067\u3057\u3087\u3001\u77e5\u3063\u3066\u308b\u3088\u305d\u308c\u304f\u3089\u3044\u300d\n\u3068\u7406\u89e3\u3057\u305f\u3064\u3082\u308a\u306b\u306a\u3063\u3066\u3044\u305f\u304c\u3001\u30b3\u30fc\u30c9\u30ec\u30d9\u30eb\u3067\u4f55\u304c\u3069\u306e\u7a0b\u5ea6\u9055\u3046\u306e\u304b\u77e5\u308a\u305f\u3044\u306a\u30fc\u3068\u3002\n\nThree.js\n<!DOCTYPE html>\n<html>\n\n<head>\n  <meta charset='utf-8'> \n  <script src=\"three.min.js\"></script>\n  <script src=\"http://ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js\"></script>\n  <script>\n    $(document).ready( function() {\n      // Renderer\u3092\u7528\u610f\n      renderer = new THREE.WebGLRenderer( { 'canvas' : $('#canvas')[0] } );\n\n      // \u80cc\u666f\u8272\u3092\u6307\u5b9a\n      renderer.setClearColor( new THREE.Color(0x99ccff) );\n\n      renderer.setSize(600, 500);\n\n      // Camera\u3092\u7528\u610f\n      camera = new THREE.PerspectiveCamera();\n      camera.position.z = 500;\n\n      // Scene\u3092\u7528\u610f\n      scene = new THREE.Scene();\n      scene.add( camera );\n\n      // \u4e09\u89d2\u3092\u4f5c\u308b\n      var material = new THREE.MeshBasicMaterial( { color: 0xffffa8 } );\n      var shape = new THREE.Shape();\n      shape.moveTo(  0, 100 );\n      shape.lineTo(  100, -50 );\n      shape.lineTo( -100, -50 );\n      shape.lineTo(  0, 100 );\n      var geometry = new THREE.ShapeGeometry( shape );\n      scene.add( new THREE.Mesh( geometry, material ) );\n\n      // \u63cf\u753b\n      renderer.render( scene, camera );\n    } );\n  </script>\n</head>\n\n<body>\n  <canvas id=\"canvas\" style=\"border:solid 1px; margin: 30px;\"></canvas>\n</body>\n\n\n\u5b9f\u884c\u7d50\u679c\n\n\nWebGL\n<html>\n\n<head>\n<title>WebGLHelloAPI</title>\n<meta http-equiv=\"content-type\" content=\"text/html; charset=ISO-8859-1\">\n\n<script type=\"text/javascript\" src=\"WebGLHelloAPI.js\">\n</script>\n\n\n</head>\n\n<body onload=\"main()\">\n    <canvas id=\"helloapicanvas\" style=\"border: none;\" width=\"800\" height=\"600\"></canvas>\n</body>\n\n</html>\n\nvar gl;\n\nfunction testGLError(functionLastCalled) {\n    /*\n        gl.getError returns the last error that occurred using WebGL, not necessarily the status of the last called function. The user\n        has to check after every single WebGL call or at least once every frame. Usually this would be for debugging only, but for this\n        example is is enabled always.\n    */\n\n    var lastError = gl.getError();\n\n    if (lastError != gl.NO_ERROR) {\n        alert(functionLastCalled + \" failed (\" + lastError + \")\");\n        return false;\n    }\n\n    return true;\n}\n\nfunction initialiseGL(canvas) {\n    try {\n        // Try to grab the standard context. If it fails, fallback to experimental\n        gl = canvas.getContext(\"webgl\") || canvas.getContext(\"experimental-webgl\");\n        gl.viewport(0, 0, canvas.width, canvas.height);\n    }\n    catch (e) {\n    }\n\n    if (!gl) {\n        alert(\"Unable to initialise WebGL. Your browser may not support it\");\n        return false;\n    }\n\n    return true;\n}\n\nvar shaderProgram;\n\nfunction initialiseBuffer() {\n    /*  Concept: Vertices\n        When rendering a polygon or model to screen, WebGL has to be told where to draw the object, and more fundamentally what shape \n        it is. The data used to do this is referred to as vertices, points in 3D space which are usually collected into groups of three \n        to render as triangles. Fundamentally, any advanced 3D shape in WebGL is constructed from a series of these vertices - each \n        vertex representing one corner of a polygon.\n    */\n    /*  Concept: Buffer Objects\n        To operate on any data, WebGL first needs to be able to access it. The GPU maintains a separate pool of memory it uses independent\n        of the CPU. Whilst on many embedded systems these are in the same physical memory, the distinction exists so that they can use and\n        allocate memory without having to worry about synchronising with any other processors in the device.\n        To this end, data needs to be uploaded into buffers, which are essentially a reserved bit of memory for the GPU to use. By creating\n        a buffer and giving it some data we can tell the GPU how to render a triangle.\n    */\n\n    var vertexData = [\n        -0.4, -0.4, 0.0, // Bottom left\n         0.4, -0.4, 0.0, // Bottom right\n         0.0, 0.4, 0.0  // Top middle\n    ];\n\n    // Generate a buffer object\n    gl.vertexBuffer = gl.createBuffer();\n\n    // Bind buffer as a vertex buffer so we can fill it with data\n    gl.bindBuffer(gl.ARRAY_BUFFER, gl.vertexBuffer);\n\n    /*\n        Set the buffer's size, data and usage\n        Note the last argument - gl.STATIC_DRAW. This tells the driver that we intend to read from the buffer on the GPU, and don't intend\n        to modify the data until we've done with it.\n    */\n    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertexData), gl.STATIC_DRAW);\n\n    return testGLError(\"initialiseBuffers\");\n}\n\nfunction initialiseShaders() {\n    /*  Concept: Shaders\n        WebGL uses what are known as shaders to determine how to draw objects on the screen. Instead of the fixed function\n        pipeline in early OpenGL or OpenGL ES 1.x, users can now programmatically define how vertices are transformed on screen, what\n        data is used where, and how each pixel on the screen is coloured.\n        These shaders are written in GL Shading Language ES: http://www.khronos.org/registry/gles/specs/2.0/GLSL_ES_Specification_1.0.17.pdf\n        which is usually abbreviated to simply \"GLSL ES\".\n        Each shader is compiled on-device and then linked into a shader program, which combines a vertex and fragment shader into a form \n        that the OpenGL ES implementation can execute.\n    */\n\n    /*  Concept: Fragment Shaders\n        In a final buffer of image data, each individual point is referred to as a pixel. Fragment shaders are the part of the pipeline\n        which determine how these final pixels are coloured when drawn to the framebuffer. When data is passed through here, the positions\n        of these pixels is already set, all that's left to do is set the final colour based on any defined inputs.\n        The reason these are called \"fragment\" shaders instead of \"pixel\" shaders is due to a small technical difference between the two\n        concepts. When you colour a fragment, it may not be the final colour which ends up on screen. This is particularly true when \n        performing blending, where multiple fragments can contribute to the final pixel colour.\n    */\n\n    var fragmentShaderSource = '\\\n            void main(void) \\\n            { \\\n                gl_FragColor = vec4(1.0, 1.0, 0.66, 1.0); \\\n            }';\n\n    // Create the fragment shader object\n    gl.fragShader = gl.createShader(gl.FRAGMENT_SHADER);\n\n    // Load the source code into it\n    gl.shaderSource(gl.fragShader, fragmentShaderSource);\n\n    // Compile the source code\n    gl.compileShader(gl.fragShader);\n\n    // Check if compilation succeeded\n    if (!gl.getShaderParameter(gl.fragShader, gl.COMPILE_STATUS)) {\n        // It didn't. Display the info log as to why\n        alert(\"Failed to compile the fragment shader.\\n\" + gl.getShaderInfoLog(gl.fragShader));\n        return false;\n    }\n\n    /*  Concept: Vertex Shaders\n        Vertex shaders primarily exist to allow a developer to express how to orient vertices in 3D space, through transformations like \n        Scaling, Translation or Rotation. Using the same basic layout and structure as a fragment shader, these take in vertex data and \n        output a fully transformed set of positions. Other inputs are also able to be used such as normals or texture coordinates, and can \n        also be transformed and output alongside the position data.\n    */\n\n    // Vertex shader code\n    var vertexShaderSource = '\\\n            attribute highp vec4 myVertex; \\\n            uniform mediump mat4 transformationMatrix; \\\n            void main(void)  \\\n            { \\\n                gl_Position = transformationMatrix * myVertex; \\\n            }';\n\n    // Create the vertex shader object\n    gl.vertexShader = gl.createShader(gl.VERTEX_SHADER);\n\n    // Load the source code into it\n    gl.shaderSource(gl.vertexShader, vertexShaderSource);\n\n    // Compile the source code\n    gl.compileShader(gl.vertexShader);\n\n    // Check if compilation succeeded\n    if (!gl.getShaderParameter(gl.vertexShader, gl.COMPILE_STATUS)) {\n        // It didn't. Display the info log as to why\n        alert(\"Failed to compile the vertex shader.\\n\" + gl.getShaderInfoLog(gl.vertexShader));\n        return false;\n    }\n\n    // Create the shader program\n    gl.programObject = gl.createProgram();\n\n    // Attach the fragment and vertex shaders to it\n    gl.attachShader(gl.programObject, gl.fragShader);\n    gl.attachShader(gl.programObject, gl.vertexShader);\n\n    // Bind the custom vertex attribute \"myVertex\" to location 0\n    gl.bindAttribLocation(gl.programObject, 0, \"myVertex\");\n\n    // Link the program\n    gl.linkProgram(gl.programObject);\n\n    // Check if linking succeeded in a similar way we checked for compilation errors\n    if (!gl.getProgramParameter(gl.programObject, gl.LINK_STATUS)) {\n        alert(\"Failed to link the program.\\n\" + gl.getProgramInfoLog(gl.programObject));\n        return false;\n    }\n\n    /*  Use the Program\n        Calling gl.useProgram tells WebGL that the application intends to use this program for rendering. Now that it's installed into\n        the current state, any further gl.draw* calls will use the shaders contained within it to process scene data. Only one program can\n        be active at once, so in a multi-program application this function would be called in the render loop. Since this application only\n        uses one program it can be installed in the current state and left there.\n    */\n    gl.useProgram(gl.programObject);\n\n    return testGLError(\"initialiseShaders\");\n}\n\nfunction renderScene() {\n    /*\n        Set the clear colour\n        At the start of a frame, generally you clear the image to tell WebGL that you're done with whatever was there before and want to\n        draw a new frame. In order to do that gowever, WebGL needs to know what colour to set in the image's place. gl.clearColor\n        sets this value as 4 floating point values between 0.0 and 1.0, as the Red, Green, Blue and Alpha channels. Each value represents\n        the intensity of the particular channel, with all 0.0 being transparent black, and all 1.0 being opaque white. Subsequent calls to\n        gl.clear with the colour bit will clear the framebuffer to this vlaue.\n        The functions gl.clearDepth and gl.clearStencil allow an application to do the same with depth and stencil values respectively.\n    */\n    gl.clearColor(0.6, 0.8, 1.0, 1.0);\n\n    /*\n        Clear the colour buffer\n        gl.clear is used here with the colour buffer to clear the colour. It can also be used to clear the depth or stencil buffer using\n        gl.DEPTH_BUFFER_BIT or gl.STENCIL_BUFFER_BIT, respectively.\n    */\n\n    gl.clear(gl.COLOR_BUFFER_BIT);\n\n    // Get the location of the transformation matrix in the shader using its name\n    var matrixLocation = gl.getUniformLocation(gl.programObject, \"transformationMatrix\");\n\n    // Matrix used to specify the orientation of the triangle on screen\n    var transformationMatrix = [\n        1.0, 0.0, 0.0, 0.0,\n        0.0, 1.0, 0.0, 0.0,\n        0.0, 0.0, 1.0, 0.0,\n        0.0, 0.0, 0.0, 1.0\n    ];\n\n    // Pass the identity transformation matrix to the shader using its location\n    gl.uniformMatrix4fv(matrixLocation, gl.FALSE, transformationMatrix);\n\n    if (!testGLError(\"gl.uniformMatrix4fv\")) {\n        return false;\n    }\n\n    // Enable the user-defined vertex array\n    gl.enableVertexAttribArray(0);\n\n    // Set the vertex data to this attribute index, with the number of floats in each position\n    gl.vertexAttribPointer(0, 3, gl.FLOAT, gl.FALSE, 0, 0);\n\n    if (!testGLError(\"gl.vertexAttribPointer\")) {\n        return false;\n    }\n\n    /*\n        Draw the triangle\n        gl.drawArrays is a draw call, and executes the shader program using the vertices and other state set by the user. Draw calls are the\n        functions which tell WebGL when to actually draw something to the framebuffer gived the current state.\n        gl.drawArrays causes the vertices to be submitted sequentially from the position given by the \"first\" argument until it has processed\n        \"count\" vertices. Other draw calls exist, notably gl.drawElements which also accepts index data to allow the user to specify that \n        some vertices are accessed multiple times, without copying the vertex multiple times.\n        Others include versions of the above that allow the user to draw the same ovhect multiple times with slightly different data, and\n        a version of gl.drawElements which allows a user to restrict the actuial indices accessed.\n    */\n    gl.drawArrays(gl.TRIANGLES, 0, 3);\n\n    if (!testGLError(\"gl.drawArrays\")) {\n        return false;\n    }\n\n    return true;\n}\n\nfunction main() {\n    var canvas = document.getElementById(\"helloapicanvas\");\n\n    if (!initialiseGL(canvas)) {\n        return;\n    }\n\n    if (!initialiseBuffer()) {\n        return;\n    }\n\n    if (!initialiseShaders()) {\n        return;\n    }\n\n    // Render loop\n    requestAnimFrame = (function () {\n        return window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame ||\n            function (callback) {\n                window.setTimeout(callback, 1000, 60);\n            };\n    })();\n\n    (function renderLoop() {\n        if (renderScene()) {\n            // Everything was successful, request that we redraw our scene again in the future\n            requestAnimFrame(renderLoop);\n        }\n    })();\n}\n\n\n\u5b9f\u884c\u7d50\u679c\n\nhttp://powervr-graphics.github.io/WebGL_SDK/WebGL_SDK/Examples/Beginner/01_HelloAPI/WebGL/\n\nOpenGL ES\n\n\u30b3\u30fc\u30c9\n/*******************************************************************************************************************************************\n\n @File         OGLES2HelloAPI_LinuxX11.cpp\n\n @Title        OpenGL ES 2.0 HelloAPI Tutorial\n\n @Version      \n\n @Copyright    Copyright (c) Imagination Technologies Limited.\n\n @Platform     \n\n @Description  Basic Tutorial that shows step-by-step how to initialize OpenGL ES 2.0, use it for drawing a triangle and terminate it.\n               Entry Point: main\n\n*******************************************************************************************************************************************/\n/*******************************************************************************************************************************************\n Include Files\n*******************************************************************************************************************************************/\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include \"X11/Xlib.h\"\n#include \"X11/Xutil.h\"\n\n#include <EGL/egl.h>\n#include <GLES2/gl2.h>\n\n/*******************************************************************************************************************************************\n Defines\n*******************************************************************************************************************************************/\n// Name of the application\n#define APPLICATION_NAME \"HelloAPI\"\n\n// Width and height of the window\n#define WINDOW_WIDTH    800\n#define WINDOW_HEIGHT   600\n\n// Index to bind the attributes to vertex shaders\n#define VERTEX_ARRAY    0\n\n/*******************************************************************************************************************************************\n Helper Functions\n*******************************************************************************************************************************************/\n\n/*!*****************************************************************************************************************************************\n @Function      TestEGLError\n @Input         functionLastCalled          Function which triggered the error\n @Return        True if no EGL error was detected\n @Description   Tests for an EGL error and prints it.\n*******************************************************************************************************************************************/\nbool TestEGLError(const char* functionLastCalled)\n{\n    /*  eglGetError returns the last error that occurred using EGL, not necessarily the status of the last called function. The user has to\n        check after every single EGL call or at least once every frame. Usually this would be for debugging only, but for this example\n        it is enabled always.\n    */\n    EGLint lastError = eglGetError();\n    if (lastError != EGL_SUCCESS)\n    {\n        printf(\"%s failed (%x).\\n\", functionLastCalled, lastError);\n        return false;\n    }\n\n    return true;\n}\n\n/*!*****************************************************************************************************************************************\n @Function      HandleX11Errors\n @Input         nativeDisplay               Handle to the display\n @Input         error                       The error event to handle\n @Return        Result code to send to the X window system\n @Description   Processes event messages for the main window\n*******************************************************************************************************************************************/\nint HandleX11Errors(Display *nativeDisplay, XErrorEvent *error)\n{\n    // Get the X Error\n    char errorStringBuffer[256];\n    XGetErrorText(nativeDisplay, error->error_code, errorStringBuffer, 256);\n\n    // Print the error\n    printf(\"%s\", errorStringBuffer);\n\n    // Exit the application\n    exit(-1);\n\n    return 0;\n}\n\n/*!*****************************************************************************************************************************************\n @Function      TestGLError\n @Input         functionLastCalled          Function which triggered the error\n @Return        True if no GL error was detected\n @Description   Tests for an GL error and prints it in a message box.\n*******************************************************************************************************************************************/\nbool TestGLError(const char* functionLastCalled)\n{\n    /*  glGetError returns the last error that occurred using OpenGL ES, not necessarily the status of the last called function. The user \n        has to check after every single OpenGL ES call or at least once every frame. Usually this would be for debugging only, but for this\n        example it is enabled always\n    */\n    GLenum lastError = glGetError();\n    if (lastError != GL_NO_ERROR)\n    {\n        printf(\"%s failed (%x).\\n\", functionLastCalled, lastError);\n        return false;\n    }\n\n    return true;\n}\n\n/*******************************************************************************************************************************************\n Application Functions\n*******************************************************************************************************************************************/\n\n/*!*****************************************************************************************************************************************\n @Function      CreateNativeDisplay\n @Output        nativeDisplay               Native display to create\n @Return        Whether the function succeeded or not.\n @Description   Creates a native isplay for the application to render into.\n*******************************************************************************************************************************************/\nbool CreateNativeDisplay(Display** nativeDisplay) \n{\n    // Check for a valid display\n    if (!nativeDisplay)\n    {\n        return false;\n    }\n\n    // Open the display\n    *nativeDisplay = XOpenDisplay( 0 );\n    if (!*nativeDisplay)\n    {\n        printf(\"Error: Unable to open X display\\n\");\n        return false;\n    }\n\n    return true;\n}\n\n/*!*****************************************************************************************************************************************\n @Function      CreateNativeWindow\n @Input         nativeDisplay               Native display used by the application\n @Output        nativeWindow                Native window type to create\n @Return        Whether the function succeeded or not.\n @Description   Creates a native window for the application to render into.\n*******************************************************************************************************************************************/\nbool CreateNativeWindow(Display* nativeDisplay, Window* nativeWindow) \n{\n    // Get the default screen for the display\n    int defaultScreen = XDefaultScreen(nativeDisplay);\n\n    // Get the default depth of the display\n    int defaultDepth = DefaultDepth(nativeDisplay, defaultScreen);\n\n    // Select a visual info\n    XVisualInfo* visualInfo = new XVisualInfo;\n    XMatchVisualInfo( nativeDisplay, defaultScreen, defaultDepth, TrueColor, visualInfo);\n    if (!visualInfo)\n    {\n        printf(\"Error: Unable to acquire visual\\n\");\n        return false;\n    }\n\n    // Get the root window for the display and default screen\n    Window rootWindow = RootWindow(nativeDisplay, defaultScreen);\n\n    // Create a colour map from the display, root window and visual info\n    Colormap colourMap = XCreateColormap(nativeDisplay, rootWindow, visualInfo->visual, AllocNone);\n\n    // Now setup the final window by specifying some attributes\n    XSetWindowAttributes windowAttributes;\n\n    // Set the colour map that was just created\n    windowAttributes.colormap = colourMap;\n\n    // Set events that will be handled by the app, add to these for other events.\n    windowAttributes.event_mask = StructureNotifyMask | ExposureMask | ButtonPressMask;\n\n    // Create the window\n    *nativeWindow =XCreateWindow(nativeDisplay,               // The display used to create the window\n                                 rootWindow,                   // The parent (root) window - the desktop\n                                 0,                            // The horizontal (x) origin of the window\n                                 0,                            // The vertical (y) origin of the window\n                                 WINDOW_WIDTH,                 // The width of the window\n                                 WINDOW_HEIGHT,                // The height of the window\n                                 0,                            // Border size - set it to zero\n                                 visualInfo->depth,            // Depth from the visual info\n                                 InputOutput,                  // Window type - this specifies InputOutput.\n                                 visualInfo->visual,           // Visual to use\n                                 CWEventMask | CWColormap,     // Mask specifying these have been defined in the window attributes\n                                 &windowAttributes);           // Pointer to the window attribute structure\n\n    // Make the window viewable by mapping it to the display\n    XMapWindow(nativeDisplay, *nativeWindow);\n\n    // Set the window title\n    XStoreName(nativeDisplay, *nativeWindow, APPLICATION_NAME);\n\n    // Setup the window manager protocols to handle window deletion events\n    Atom windowManagerDelete = XInternAtom(nativeDisplay, \"WM_DELETE_WINDOW\", True);\n    XSetWMProtocols(nativeDisplay, *nativeWindow, &windowManagerDelete , 1);\n\n    // Delete the visual info\n    delete visualInfo;\n\n    return true;\n}\n\n/*!*****************************************************************************************************************************************\n @Function      CreateEGLDisplay\n @Input         nativeDisplay               The native display used by the application\n @Output        eglDisplay                  EGLDisplay created from nativeDisplay\n @Return        Whether the function succeeded or not.\n @Description   Creates an EGLDisplay from a native native display, and initialises it.\n*******************************************************************************************************************************************/\nbool CreateEGLDisplay( Display* nativeDisplay, EGLDisplay &eglDisplay ) \n{\n    /*  Get an EGL display.\n        EGL uses the concept of a \"display\" which in most environments corresponds to a single physical screen. After creating a native\n        display for a given windowing system, EGL can use this handle to get a corresponding EGLDisplay handle to it for use in rendering.\n        Should this fail, EGL is usually able to provide access to a default display.\n    */\n    eglDisplay = eglGetDisplay((EGLNativeDisplayType)nativeDisplay);\n    // If a display couldn't be obtained, return an error.\n    if (eglDisplay == EGL_NO_DISPLAY)\n    {\n        printf(\"Failed to get an EGLDisplay\");\n        return false;\n    }\n\n    /*  Initialize EGL.\n        EGL has to be initialized with the display obtained in the previous step. All EGL functions other than eglGetDisplay \n        and eglGetError need an initialised EGLDisplay. \n        If an application is not interested in the EGL version number it can just pass NULL for the second and third parameters, but they \n        are queried here for illustration purposes.\n    */\n    EGLint eglMajorVersion, eglMinorVersion;\n    if (!eglInitialize(eglDisplay, &eglMajorVersion, &eglMinorVersion))\n    {\n        printf(\"Failed to initialise the EGLDisplay\");\n        return false;\n    }\n\n    return true;\n}\n\n/*!*****************************************************************************************************************************************\n @Function      ChooseEGLConfig\n @Input         eglDisplay                  The EGLDisplay used by the application\n @Output        eglConfig                   The EGLConfig chosen by the function\n @Return        Whether the function succeeded or not.\n @Description   Chooses an appropriate EGLConfig and return it.\n*******************************************************************************************************************************************/\nbool ChooseEGLConfig( EGLDisplay eglDisplay, EGLConfig& eglConfig ) \n{\n    /*  Specify the required configuration attributes.\n        An EGL \"configuration\" describes the capabilities an application requires and the type of surfaces that can be used for drawing.\n        Each implementation exposes a number of different configurations, and an application needs to describe to EGL what capabilities it\n        requires so that an appropriate one can be chosen. The first step in doing this is to create an attribute list, which is an array\n        of key/value pairs which describe particular capabilities requested. In this application nothing special is required so we can query\n        the minimum of needing it to render to a window, and being OpenGL ES 2.0 capable.\n    */\n    const EGLint configurationAttributes[] =\n    {\n        EGL_SURFACE_TYPE,       EGL_WINDOW_BIT,\n        EGL_RENDERABLE_TYPE,    EGL_OPENGL_ES2_BIT,\n        EGL_NONE\n    };\n\n    /*  Find a suitable EGLConfig\n        eglChooseConfig is provided by EGL to provide an easy way to select an appropriate configuration. It takes in the capabilities\n        specified in the attribute list, and returns a list of available configurations that match or exceed the capabilities requested.\n        Details of all the possible attributes and how they are selected for by this function are available in the EGL reference pages here:\n        http://www.khronos.org/registry/egl/sdk/docs/man/xhtml/eglChooseConfig.html\n        It is also possible to simply get the entire list of configurations and use a custom algorithm to choose a suitable one, as many\n        advanced applications choose to do. For this application however, taking the first EGLConfig that the function returns suits\n        its needs perfectly, so we limit it to returning a single EGLConfig.\n    */\n    EGLint configsReturned;\n    if (!eglChooseConfig(eglDisplay, configurationAttributes, &eglConfig, 1, &configsReturned) || (configsReturned != 1))\n    {\n        printf(\"Failed to choose a suitable config.\");\n        return false;\n    }\n\n    return true;\n}\n\n/*!*****************************************************************************************************************************************\n @Function      CreateEGLSurface\n @Input         nativeWindow                A native window that's been created\n @Input         eglDisplay                  The EGLDisplay used by the application\n @Input         eglConfig                   An EGLConfig chosen by the application\n @Output        eglSurface                  The EGLSurface created from the native window.\n @Return        Whether the function succeeds or not.\n @Description   Creates an EGLSurface from a native window\n*******************************************************************************************************************************************/\nbool CreateEGLSurface( Window nativeWindow, EGLDisplay eglDisplay, EGLConfig eglConfig, EGLSurface& eglSurface) \n{\n    /*  Create an EGLSurface for rendering.\n        Using a native window created earlier and a suitable eglConfig, a surface is created that can be used to render OpenGL ES calls to.\n        There are three main surface types in EGL, which can all be used in the same way once created but work slightly differently:\n         - Window Surfaces  - These are created from a native window and are drawn to the screen.\n         - Pixmap Surfaces  - These are created from a native windowing system as well, but are offscreen and are not displayed to the user.\n         - PBuffer Surfaces - These are created directly within EGL, and like Pixmap Surfaces are offscreen and thus not displayed.\n        The offscreen surfaces are useful for non-rendering contexts and in certain other scenarios, but for most applications the main\n        surface used will be a window surface as performed below.\n    */\n    eglSurface = eglCreateWindowSurface(eglDisplay, eglConfig, (EGLNativeWindowType)nativeWindow, NULL);\n    if (!TestEGLError(\"eglCreateWindowSurface\"))\n    {\n        return false;\n    }\n\n    return true;\n}\n\n/*!*****************************************************************************************************************************************\n @Function      SetupEGLContext\n @Input         eglDisplay                  The EGLDisplay used by the application\n @Input         eglConfig                   An EGLConfig chosen by the application\n @Input         eglSurface                  The EGLSurface created from the native window.\n @Output        eglContext                  The EGLContext created by this function\n @Input         nativeWindow                A native window, used to display error messages\n @Return        Whether the function succeeds or not.\n @Description   Sets up the EGLContext, creating it and then installing it to the current thread.\n*******************************************************************************************************************************************/\nbool SetupEGLContext( EGLDisplay eglDisplay, EGLConfig eglConfig, EGLSurface eglSurface, EGLContext& eglContext ) \n{\n    /*  Make OpenGL ES the current API.\n     EGL needs a way to know that any subsequent EGL calls are going to be affecting OpenGL ES,\n     rather than any other API (such as OpenVG).\n     */\n    eglBindAPI(EGL_OPENGL_ES_API);\n    if (!TestEGLError(\"eglBindAPI\"))\n    {\n        return false;\n    }\n\n    /*  Create a context.\n        EGL has to create what is known as a context for OpenGL ES. The concept of a context is OpenGL ES's way of encapsulating any\n        resources and state. What appear to be \"global\" functions in OpenGL actually only operate on the current context. A context\n        is required for any operations in OpenGL ES.\n        Similar to an EGLConfig, a context takes in a list of attributes specifying some of its capabilities. However in most cases this\n        is limited to just requiring the version of the OpenGL ES context required - In this case, OpenGL ES 2.0.\n    */\n    EGLint contextAttributes[] = \n    {\n        EGL_CONTEXT_CLIENT_VERSION, 2, \n        EGL_NONE\n    };\n\n    // Create the context with the context attributes supplied\n    eglContext = eglCreateContext(eglDisplay, eglConfig, NULL, contextAttributes);\n    if (!TestEGLError(\"eglCreateContext\"))\n    {\n        return false;\n    }\n\n    /*  Bind the context to the current thread.\n        Due to the way OpenGL uses global functions, contexts need to be made current so that any function call can operate on the correct\n        context. Specifically, make current will bind the context to the thread it's called from, and unbind it from any others. To use\n        multiple contexts at the same time, users should use multiple threads and synchronise between them.\n    */\n    eglMakeCurrent(eglDisplay, eglSurface, eglSurface, eglContext);\n    if (!TestEGLError(\"eglMakeCurrent\"))\n    {\n        return false;\n    }\n\n    return true;\n}\n\n/*!*****************************************************************************************************************************************\n @Function      InitialiseBuffer\n @Output        vertexBuffer                Handle to a vertex buffer object\n @Return        Whether the function succeeds or not.\n @Description   Initialises shaders, buffers and other state required to begin rendering with OpenGL ES\n*******************************************************************************************************************************************/\nbool InitialiseBuffer(GLuint &vertexBuffer) \n{\n    /*  Concept: Vertices\n        When rendering a polygon or model to screen, OpenGL ES has to be told where to draw the object, and more fundamentally what shape \n        it is. The data used to do this is referred to as vertices, points in 3D space which are usually collected into groups of three \n        to render as triangles. Fundamentally, any advanced 3D shape in OpenGL ES is constructed from a series of these vertices - each \n        vertex representing one corner of a polygon.\n    */\n\n    /*  Concept: Buffer Objects\n        To operate on any data, OpenGL first needs to be able to access it. The GPU maintains a separate pool of memory it uses independent\n        of the CPU. Whilst on many embedded systems these are in the same physical memory, the distinction exists so that they can use and\n        allocate memory without having to worry about synchronising with any other processors in the device.\n        To this end, data needs to be uploaded into buffers, which are essentially a reserved bit of memory for the GPU to use. By creating\n        a buffer and giving it some data we can tell the GPU how to render a triangle.\n    */\n\n    // Vertex data containing the positions of each point of the triangle\n    GLfloat vertexData[] = {-0.4f,-0.4f, 0.0f,  // Bottom Left\n                             0.4f,-0.4f, 0.0f,  // Bottom Right\n                             0.0f, 0.4f, 0.0f}; // Top Middle\n\n    // Generate a buffer object\n    glGenBuffers(1, &vertexBuffer);\n\n    // Bind buffer as an vertex buffer so we can fill it with data\n    glBindBuffer(GL_ARRAY_BUFFER, vertexBuffer);\n\n    /*  Set the buffer's size, data and usage\n        Note the last argument - GL_STATIC_DRAW. This tells the driver that we intend to read from the buffer on the GPU, and don't intend\n        to modify the data until we're done with it.        \n    */\n    glBufferData(GL_ARRAY_BUFFER, sizeof(vertexData), vertexData, GL_STATIC_DRAW);\n\n    if (!TestGLError(\"glBufferData\"))\n    {\n        return false;\n    }\n\n    return true;\n}\n\n/*!*****************************************************************************************************************************************\n @Function      InitialiseShaders\n @Output        fragmentShader              Handle to a fragment shader\n @Output        vertexShader                Handle to a vertex shader\n @Output        shaderProgram               Handle to a shader program containing the fragment and vertex shader\n @Return        Whether the function succeeds or not.\n @Description   Initialises shaders, buffers and other state required to begin rendering with OpenGL ES\n*******************************************************************************************************************************************/\nbool InitialiseShaders( GLuint &fragmentShader, GLuint &vertexShader, GLuint &shaderProgram) \n{\n    /*  Concept: Shaders\n        OpenGL ES 2.0 uses what are known as shaders to determine how to draw objects on the screen. Instead of the fixed function\n        pipeline in early OpenGL or OpenGL ES 1.x, users can now programmatically define how vertices are transformed on screen, what\n        data is used where, and how each pixel on the screen is coloured.\n        These shaders are written in GL Shading Language ES: http://www.khronos.org/registry/gles/specs/2.0/GLSL_ES_Specification_1.0.17.pdf\n        which is usually abbreviated to simply \"GLSL ES\".\n        Each shader is compiled on-device and then linked into a shader program, which combines a vertex and fragment shader into a form \n        that the OpenGL ES implementation can execute.\n    */\n\n    /*  Concept: Fragment Shaders\n        In a final buffer of image data, each individual point is referred to as a pixel. Fragment shaders are the part of the pipeline\n        which determine how these final pixels are coloured when drawn to the framebuffer. When data is passed through here, the positions\n        of these pixels is already set, all that's left to do is set the final colour based on any defined inputs.\n        The reason these are called \"fragment\" shaders instead of \"pixel\" shaders is due to a small technical difference between the two\n        concepts. When you colour a fragment, it may not be the final colour which ends up on screen. This is particularly true when \n        performing blending, where multiple fragments can contribute to the final pixel colour.\n    */\n    const char* const fragmentShaderSource = \"\\\n                                             void main (void)\\\n                                             {\\\n                                             gl_FragColor = vec4(1.0, 1.0, 0.66 ,1.0);\\\n                                             }\";\n\n    // Create a fragment shader object\n    fragmentShader = glCreateShader(GL_FRAGMENT_SHADER);\n\n    // Load the source code into it\n    glShaderSource(fragmentShader, 1, (const char**)&fragmentShaderSource, NULL);\n\n    // Compile the source code\n    glCompileShader(fragmentShader);\n\n    // Check that the shader compiled\n    GLint isShaderCompiled;\n    glGetShaderiv(fragmentShader, GL_COMPILE_STATUS, &isShaderCompiled);\n    if (!isShaderCompiled)\n    {\n        // If an error happened, first retrieve the length of the log message\n        int infoLogLength, charactersWritten;\n        glGetShaderiv(fragmentShader, GL_INFO_LOG_LENGTH, &infoLogLength);\n\n        // Allocate enough space for the message and retrieve it\n        char* infoLog = new char[infoLogLength];\n        glGetShaderInfoLog(fragmentShader, infoLogLength, &charactersWritten, infoLog);\n\n        // Display the error in a dialog box\n        infoLogLength>1 ? printf(\"%s\", infoLog) : printf(\"Failed to compile fragment shader.\");\n\n        delete[] infoLog;\n        return false;\n    }\n\n    /*  Concept: Vertex Shaders\n        Vertex shaders primarily exist to allow a developer to express how to orient vertices in 3D space, through transformations like \n        Scaling, Translation or Rotation. Using the same basic layout and structure as a fragment shader, these take in vertex data and \n        output a fully transformed set of positions. Other inputs are also able to be used such as normals or texture coordinates, and can \n        also be transformed and output alongside the position data.\n    */\n    // Vertex shader code\n    const char* const vertexShaderSource = \"\\\n                                           attribute highp vec4 myVertex;\\\n                                           uniform mediump mat4 transformationMatrix;\\\n                                           void main(void)\\\n                                           {\\\n                                           gl_Position = transformationMatrix * myVertex;\\\n                                           }\";\n\n    // Create a vertex shader object\n    vertexShader = glCreateShader(GL_VERTEX_SHADER);\n\n    // Load the source code into the shader\n    glShaderSource(vertexShader, 1, (const char**)&vertexShaderSource, NULL);\n\n    // Compile the shader\n    glCompileShader(vertexShader);\n\n    // Check the shader has compiled\n    glGetShaderiv(vertexShader, GL_COMPILE_STATUS, &isShaderCompiled);\n    if (!isShaderCompiled)\n    {\n        // If an error happened, first retrieve the length of the log message\n        int infoLogLength, charactersWritten;\n        glGetShaderiv(vertexShader, GL_INFO_LOG_LENGTH, &infoLogLength);\n\n        // Allocate enough space for the message and retrieve it\n        char* infoLog = new char[infoLogLength];\n        glGetShaderInfoLog(vertexShader, infoLogLength, &charactersWritten, infoLog);\n\n        // Display the error in a dialog box\n        infoLogLength>1 ? printf(\"%s\", infoLog) : printf(\"Failed to compile vertex shader.\");\n\n        delete[] infoLog;\n        return false;\n    }\n\n    // Create the shader program\n    shaderProgram = glCreateProgram();\n\n    // Attach the fragment and vertex shaders to it\n    glAttachShader(shaderProgram, fragmentShader);\n    glAttachShader(shaderProgram, vertexShader);\n\n    // Bind the vertex attribute \"myVertex\" to location VERTEX_ARRAY (0)\n    glBindAttribLocation(shaderProgram, VERTEX_ARRAY, \"myVertex\");\n\n    // Link the program\n    glLinkProgram(shaderProgram);\n\n    // Check if linking succeeded in the same way we checked for compilation success\n    GLint isLinked;\n    glGetProgramiv(shaderProgram, GL_LINK_STATUS, &isLinked);\n    if (!isLinked)\n    {\n        // If an error happened, first retrieve the length of the log message\n        int infoLogLength, charactersWritten;\n        glGetProgramiv(shaderProgram, GL_INFO_LOG_LENGTH, &infoLogLength);\n\n        // Allocate enough space for the message and retrieve it\n        char* infoLog = new char[infoLogLength];\n        glGetProgramInfoLog(shaderProgram, infoLogLength, &charactersWritten, infoLog);\n\n        // Display the error in a dialog box\n        infoLogLength>1 ? printf(\"%s\", infoLog) : printf(\"Failed to link shader program.\");\n\n        delete[] infoLog;\n        return false;\n    }\n\n    /*  Use the Program\n        Calling glUseProgram tells OpenGL ES that the application intends to use this program for rendering. Now that it's installed into\n        the current state, any further glDraw* calls will use the shaders contained within it to process scene data. Only one program can\n        be active at once, so in a multi-program application this function would be called in the render loop. Since this application only\n        uses one program it can be installed in the current state and left there.\n    */\n    glUseProgram(shaderProgram);\n\n    if (!TestGLError(\"glUseProgram\"))\n    {\n        return false;\n    }\n\n    return true;\n}\n\n/*!*****************************************************************************************************************************************\n @Function      RenderScene\n @Input         shaderProgram               The shader program used to render the scene\n @Input         eglDisplay                  The EGLDisplay used by the application\n @Input         eglSurface                  The EGLSurface created from the native window.\n @Input         nativeDisplay               The native display used by the application\n @Return        Whether the function succeeds or not.\n @Description   Renders the scene to the framebuffer. Usually called within a loop.\n*******************************************************************************************************************************************/\nbool RenderScene( GLuint shaderProgram, EGLDisplay eglDisplay, EGLSurface eglSurface, Display* nativeDisplay ) \n{\n    /*  Set the clear color\n        At the start of a frame, generally you clear the image to tell OpenGL ES that you're done with whatever was there before and want to\n        draw a new frame. In order to do that however, OpenGL ES needs to know what colour to set in the image's place. glClearColor\n        sets this value as 4 floating point values between 0.0 and 1.0, as the Red, Green, Blue and Alpha channels. Each value represents\n        the intensity of the particular channel, with all 0.0 being transparent black, and all 1.0 being opaque white. Subsequent calls to\n        glClear with the colour bit will clear the frame buffer to this value.\n        The functions glClearDepth and glClearStencil allow an application to do the same with depth and stencil values respectively.\n    */\n    glClearColor(0.6f, 0.8f, 1.0f, 1.0f);\n\n    /*  Clears the color buffer.\n        glClear is used here with the Colour Buffer to clear the colour. It can also be used to clear the depth or stencil buffer using \n        GL_DEPTH_BUFFER_BIT or GL_STENCIL_BUFFER_BIT, respectively.\n    */\n    glClear(GL_COLOR_BUFFER_BIT);\n\n    // Get the location of the transformation matrix in the shader using its name\n    int matrixLocation = glGetUniformLocation(shaderProgram, \"transformationMatrix\");\n\n    // Matrix used to specify the orientation of the triangle on screen.\n    const float transformationMatrix[] =\n    {\n        1.0f,0.0f,0.0f,0.0f,\n        0.0f,1.0f,0.0f,0.0f,\n        0.0f,0.0f,1.0f,0.0f,\n        0.0f,0.0f,0.0f,1.0f\n    };\n\n    // Pass the transformationMatrix to the shader using its location\n    glUniformMatrix4fv( matrixLocation, 1, GL_FALSE, transformationMatrix);\n    if (!TestGLError(\"glUniformMatrix4fv\"))\n    {\n        return false;\n    }\n\n    // Enable the user-defined vertex array\n    glEnableVertexAttribArray(VERTEX_ARRAY);\n\n    // Sets the vertex data to this attribute index, with the number of floats in each position\n    glVertexAttribPointer(VERTEX_ARRAY, 3, GL_FLOAT, GL_FALSE, 0, 0);\n    if (!TestGLError(\"glVertexAttribPointer\"))\n    {\n        return false;\n    }\n\n    /*  Draw the triangle\n        glDrawArrays is a draw call, and executes the shader program using the vertices and other state set by the user. Draw calls are the\n        functions which tell OpenGL ES when to actually draw something to the framebuffer given the current state.\n        glDrawArrays causes the vertices to be submitted sequentially from the position given by the \"first\" argument until it has processed\n        \"count\" vertices. Other draw calls exist, notably glDrawElements which also accepts index data to allow the user to specify that\n        some vertices are accessed multiple times, without copying the vertex multiple times.\n        Others include versions of the above that allow the user to draw the same object multiple times with slightly different data, and\n        a version of glDrawElements which allows a user to restrict the actual indices accessed.\n    */\n    glDrawArrays(GL_TRIANGLES, 0, 3);\n    if (!TestGLError(\"glDrawArrays\"))\n    {\n        return false;\n    }\n\n    /*  Present the display data to the screen.\n        When rendering to a Window surface, OpenGL ES is double buffered. This means that OpenGL ES renders directly to one frame buffer, \n        known as the back buffer, whilst the display reads from another - the front buffer. eglSwapBuffers signals to the windowing system\n        that OpenGL ES 2.0 has finished rendering a scene, and that the display should now draw to the screen from the new data. At the same\n        time, the front buffer is made available for OpenGL ES 2.0 to start rendering to. In effect, this call swaps the front and back \n        buffers.\n    */\n    if (!eglSwapBuffers(eglDisplay, eglSurface) )\n    {\n        TestEGLError(\"eglSwapBuffers\");\n        return false;\n    }\n\n    // Check for messages from the windowing system.\n    int numberOfMessages = XPending(nativeDisplay);\n    for( int i = 0; i < numberOfMessages; i++ )\n    {\n        XEvent event;\n        XNextEvent(nativeDisplay, &event);\n\n        switch( event.type )\n        {\n            // Exit on window close\n        case ClientMessage:\n            // Exit on mouse click\n        case ButtonPress:\n        case DestroyNotify:\n            return false;\n        default:\n            break;\n        }\n    }\n\n    return true;\n}\n\n/*!*****************************************************************************************************************************************\n @Function      DeInitialiseGLState\n @Input         fragmentShader              Handle to a fragment shader\n @Input         vertexShader                Handle to a vertex shader\n @Input         shaderProgram               Handle to a shader program containing the fragment and vertex shader\n @Input         vertexBuffer                Handle to a vertex buffer object\n @Description   Releases the resources created by \"InitialiseGLState\"\n*******************************************************************************************************************************************/\nvoid DeInitialiseGLState( GLuint fragmentShader, GLuint vertexShader, GLuint shaderProgram, GLuint vertexBuffer ) \n{\n    // Frees the OpenGL handles for the program and the 2 shaders\n    glDeleteShader(fragmentShader);\n    glDeleteShader(vertexShader);\n    glDeleteProgram(shaderProgram);\n\n    // Delete the VBO as it is no longer needed\n    glDeleteBuffers(1, &vertexBuffer);\n}\n\n/*!*****************************************************************************************************************************************\n @Function      ReleaseEGLState\n @Input         eglDisplay                   The EGLDisplay used by the application\n @Description   Releases all resources allocated by EGL\n*******************************************************************************************************************************************/\nvoid ReleaseEGLState(EGLDisplay eglDisplay) \n{\n    if(eglDisplay != NULL)\n    {\n        // To release the resources in the context, first the context has to be released from its binding with the current thread.\n        eglMakeCurrent(eglDisplay, EGL_NO_SURFACE, EGL_NO_SURFACE, EGL_NO_CONTEXT);\n\n        // Terminate the display, and any resources associated with it (including the EGLContext)\n        eglTerminate(eglDisplay);\n    }\n}\n\n/*!*****************************************************************************************************************************************\n @Function      ReleaseWindowAndDisplay\n @Input         nativeDisplay               The native display to release\n @Input         nativeWindow                The native window to destroy\n @Description   Releases all resources allocated by the windowing system\n*******************************************************************************************************************************************/\nvoid ReleaseNativeResources(Display* nativeDisplay, Window nativeWindow) \n{\n    // Destroy the window\n    if (nativeWindow)\n    {\n        XDestroyWindow(nativeDisplay, nativeWindow);\n    }\n\n    // Release the display.\n    if (nativeDisplay)\n    {\n        XCloseDisplay(nativeDisplay);\n    }\n}\n\n/*!*****************************************************************************************************************************************\n @Function      main\n @Input         argc                        Number of arguments passed to the application, ignored.\n @Input         argv           Command line strings passed to the application, ignored.\n @Return        Result code to send to the Operating System\n @Description   Main function of the program, executes other functions.\n*******************************************************************************************************************************************/\nint main(int /*argc*/, char **/*argv*/)\n{\n    // X11 variables\n    Display* nativeDisplay = NULL;\n    Window nativeWindow = 0;\n\n    // EGL variables\n    EGLDisplay          eglDisplay = NULL;\n    EGLConfig           eglConfig = NULL;\n    EGLSurface          eglSurface = NULL;\n    EGLContext          eglContext = NULL;\n\n    // Handles for the two shaders used to draw the triangle, and the program handle which combines them.\n    GLuint fragmentShader = 0, vertexShader = 0;\n    GLuint shaderProgram = 0;\n\n    // A vertex buffer object to store our model data.\n    GLuint vertexBuffer = 0;\n\n    // Get access to a native display\n    if (!CreateNativeDisplay(&nativeDisplay))\n    {\n        goto cleanup;\n    }\n\n    // Setup the windowing system, create a window\n    if (!CreateNativeWindow(nativeDisplay, &nativeWindow))\n    {\n        goto cleanup;\n    }\n\n    // Create and Initialise an EGLDisplay from the native display\n    if (!CreateEGLDisplay(nativeDisplay, eglDisplay))\n    {\n        goto cleanup;\n    }\n\n    // Choose an EGLConfig for the application, used when setting up the rendering surface and EGLContext\n    if (!ChooseEGLConfig(eglDisplay, eglConfig))\n    {\n        goto cleanup;\n    }\n\n    // Create an EGLSurface for rendering from the native window\n    if (!CreateEGLSurface(nativeWindow, eglDisplay, eglConfig, eglSurface))\n    {\n        goto cleanup;\n    }\n\n    // Setup the EGL Context from the other EGL constructs created so far, so that the application is ready to submit OpenGL ES commands\n    if (!SetupEGLContext(eglDisplay, eglConfig, eglSurface, eglContext))\n    {\n        goto cleanup;\n    }\n\n    // Initialise the vertex data in the application\n    if (!InitialiseBuffer(vertexBuffer))\n    {\n        goto cleanup;\n    }   \n\n    // Initialise the fragment and vertex shaders used in the application\n    if (!InitialiseShaders(fragmentShader, vertexShader, shaderProgram))\n    {\n        goto cleanup;\n    }\n\n    // Renders a triangle for 800 frames using the state setup in the previous function\n    for (int i = 0; i < 800; ++i)\n    {\n        if (!RenderScene(shaderProgram, eglDisplay, eglSurface, nativeDisplay))\n        {\n            break;\n        }\n    }\n\n    // Release any resources we created in the Initialise functions\n    DeInitialiseGLState(fragmentShader, vertexShader, shaderProgram, vertexBuffer);\n\ncleanup:\n    // Release the EGL State\n    ReleaseEGLState(eglDisplay);\n\n    // Release the windowing system resources\n    ReleaseNativeResources(nativeDisplay, nativeWindow);\n\n    // Destroy the eglWindow\n    return 0;\n}\n\n/*******************************************************************************************************************************************\n End of file (OGLES2HelloAPI_LinuxX11.cpp)\n*******************************************************************************************************************************************/\n\n\n\u30d3\u30eb\u30c9&\u5b9f\u884c\n$ g++ OGLES2HelloAPI_LinuxX11.cpp -lEGL -lGLESv2 -lX11\n$ ./a.out\n\n\u74b0\u5883: Ubuntu 12.04\n\n\u5b9f\u884c\u7d50\u679c\n\n\n\u6bd4\u8f03\n\u4e09\u8005\u306e\u6bd4\u8f03\u3092\u3057\u307e\u3059\u3002\n\u79c1\u304c\u601d\u3046\u7c21\u5358\u306a\u9806\u306f Three.js -> WebGL -> OpenGL ES \u306a\u306e\u3067\u3001\u305d\u306e\u9006\u306e\n\n\u300cOpenGL ES \u3068 WebGL\u300d\n\u300cWebGL \u3068 Three.js\u300d\n\n\u306e\u9806\u306b\u6bd4\u8f03\u3057\u307e\u3059\u3002\n\nOpenGL ES \u3068 WebGL\n\u4e00\u756a\u5927\u304d\u306a\u9055\u3044\u306f\u3001 \u521d\u671f\u5316\u90e8\u5206\uff08\u4e09\u89d2\u5f62\u3092\u63cf\u304f\u524d\u307e\u3067\u3001\u7279\u306b\u63cf\u753b\u9818\u57df\u3092\u4f5c\u308b\u307e\u3067\uff09\u304c WebGL \u306e\u65b9\u304c\u7c21\u5358\u3001\u3068\u3044\u3046\u3053\u3068\u3067\u3057\u3087\u3046\u304b\u3002\nOpenGL ES: X \u3084 EGL \u3092\u4f7f\u7528\u3057 Display \u3092\u53d6\u5f97\u3057\u305f\u308a Window \u3092\u751f\u6210\u3057\u305f\u308a\u3001 Surface \u3092\u751f\u6210\u3057\u305f\u308a\u3002\nWebGL: \u57fa\u672c\u7684\u306b\u306f Canvas \u30bf\u30b0\u4e00\u500b\u4f5c\u308b\u306e\u307f\nNative \u3067\u3042\u308c\u3070\u30a6\u30a4\u30f3\u30c9\u30a6\u306f\u4f55\u3067\u4f5c\u3089\u308c\u3066\u3044\u308b\u304b\u74b0\u5883\u4f9d\u5b58\u3067\u3059\u304c\u3001 WebGL \u3067\u3042\u308c\u3070\u5b9f\u884c\u74b0\u5883\u306f\u5e83\u3044\u610f\u5473\u306e\u30d6\u30e9\u30a6\u30b61\u3064\u306e\u307f\u306a\u306e\u3067\u3001Canvas \u30bf\u30b0\u3067\u4e00\u767a\u3001\u3068\u3044\u3046\u3053\u3068\u3067\u3059\u306d\u3002\n\u3068\u3044\u3046\u8a33\u3067\u65e9\u304f\u304a\u7d75\u63cf\u304d\u51fa\u6765\u308b\u3088\u3046\u306b\u306a\u308a\u307e\u3057\u305f\u3002\n\u305d\u306e\u5f8c\u306e GL API \u306e\u547c\u3073\u51fa\u3057\u306f\u3056\u3063\u304f\u308a\u5927\u304d\u304f\u306f\u5909\u308f\u308a\u307e\u305b\u3093\u3002\n\nWebGL \u3068 Three.js\nWebGL \u3068 Three.js \u306e\u9055\u3044\u306f\u3001\u4f7f\u7528\u3059\u308b GL API \u306e\u6570\u304c Three.js \u306e\u65b9\u304c\u5c11\u306a\u3044\u3001\u3068\u3044\u3046\u3068\u3053\u308d\u3067\u3057\u3087\u3046\u304b\u3002\nWebGL \u3067\u7d75\u3092\u63cf\u304f\u3068\u304d\u306b\u304a\u6c7a\u307e\u308a\u306e\u3088\u3046\u306b GL API \u3092\u8907\u6570\u547c\u3073\u51fa\u3057\u521d\u671f\u5316\u3057\u307e\u3059\u304c\u3001Three.js \u306f\u305d\u306e\u90e8\u5206\u3092\u30e9\u30c3\u30d7\u3057\u3001\u304a\u4f5c\u6cd5\u90e8\u5206\u3092\u80a9\u4ee3\u308f\u308a\u3057\u3066\u304f\u308c\u307e\u3059\u3002\nWebGL \u3060\u3068\u3001gl.createBuffer \u3067 Buffer \u30aa\u30d6\u30b8\u30a7\u30af\u30c8\u3092\u4f5c\u308a\u3001gl.bindBuffer \u3057\u3001gl.createShader \u3068 gl.shaderSource \u3067\u30b7\u30a7\u30fc\u30c0\u3092\u4f5c\u308a\u3001 gl.compileShader \u3057\u3066\u3001 gl.createProgram, gl.attachShader, gl.linkProgram \u3067\u30b7\u30a7\u30fc\u30c0\u30d7\u30ed\u30b0\u30e9\u30e0\u3092\u4f5c\u308a\u3001\u3001\u3001 \u3042\u308c\u3001\u4e09\u89d2\u5f62\u63cf\u304d\u305f\u3044\u3060\u3051\u306a\u306e\u306b\u307e\u3060\u63cf\u304d\u59cb\u3081\u3089\u308c\u306a\u3044\u3001\u3001\u3001\n\u3068\u3044\u3046\u3068\u3053\u308d\u304c\u3001Three.js \u3060\u3068\u300cRenderer \u4f5c\u3063\u3066 camera \u4f5c\u3063\u3066 scene \u4f5c\u3063\u3066\u3001\u306f\u3044\u4e09\u89d2\u5f62\u304b\u3051\u308b\u3088\uff01\u300d\u3068\u306a\u308a\u7c21\u5358\u3067\u3059\u3002\n\n\u307e\u3068\u3081\nThree.js \u3068 WebGL \u3068 OpenGL ES \u3067\u4e09\u89d2\u5f62\u3092\u63cf\u3044\u3066\u307f\u307e\u3057\u305f\u3002\nOpenGL ES -> WebGL -> Three.js \u3068\u9032\u3080\u6bce\u306b\u521d\u671f\u5316\u91cf\u304c\u6e1b\u308a\u3001\u5b9f\u969b\u306e\u63cf\u753b\uff08\u4eca\u56de\u306f\u4e09\u89d2\u5f62\uff09\u306b\u3059\u3050\u53d6\u308a\u304b\u304b\u308c\u308b\u3088\u3046\u306b\u306a\u308a\u307e\u3059\u3002\n\n\u53c2\u8003\nWebGL: WebGL Pre-Tutorial, Part 2: Drawing a 2d Triangle\nThree.js: Three.js\u3067\u3044\u308d\u3044\u308d\u306a\u56f3\u5f62\u3092\u63cf\u3044\u3066\u307f\u308b\nWebGL: powervr-graphics/WebGL_SDK\nOpenGL ES: powervr-graphics/Native_SDK\n# \u6982\u8981\nThree.js \u3068 (Three.js \u672a\u4f7f\u7528\u306e) WebGL \u3068 OpenGL ES \u3067\u4e09\u89d2\u5f62\u3092\u63cf\u3044\u3066\u3001\u9055\u3044\u3092\u6bd4\u8f03\u3057\u3066\u307f\u305f\u3001\u3068\u3044\u3046\u8a71\u3067\u3059\u3002\n\n\u4ee5\u4e0b\u306e\u30b5\u30f3\u30d7\u30eb\u306e WebGL\u3001 OpenGL ES \u306f PVRSDK \u304b\u3089\u62dd\u501f\u3057\u307e\u3057\u305f\u3002\u30b3\u30fc\u30c9\u306e\u69cb\u6210\u304c\u4f3c\u3066\u3044\u3066\u6bd4\u8f03\u3057\u3084\u3059\u3044\u305f\u3081\u3067\u3059\u3002\n\n# \u52d5\u6a5f\n\u6982\u5ff5\u3068\u3057\u3066\u306f Three.js, WebGL, OpenGL ES \u306e\u9055\u3044\u306f\u3001\n\u300cWebGL \u306f OpenGL ES \u306e\u30d0\u30a4\u30f3\u30c7\u30a3\u30f3\u30b0\u3067\u3057\u3087\u3001Three.js \u306f WebGL \u306e\u30e9\u30c3\u30d1\u30fc\u3067\u3057\u3087\u3001\u77e5\u3063\u3066\u308b\u3088\u305d\u308c\u304f\u3089\u3044\u300d\n\u3068\u7406\u89e3\u3057\u305f\u3064\u3082\u308a\u306b\u306a\u3063\u3066\u3044\u305f\u304c\u3001\u30b3\u30fc\u30c9\u30ec\u30d9\u30eb\u3067\u4f55\u304c\u3069\u306e\u7a0b\u5ea6\u9055\u3046\u306e\u304b\u77e5\u308a\u305f\u3044\u306a\u30fc\u3068\u3002\n\n\n\n# Three.js \n```html\n<!DOCTYPE html>\n<html>\n\n<head>\n  <meta charset='utf-8'> \n  <script src=\"three.min.js\"></script>\n  <script src=\"http://ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js\"></script>\n  <script>\n    $(document).ready( function() {\n      // Renderer\u3092\u7528\u610f\n      renderer = new THREE.WebGLRenderer( { 'canvas' : $('#canvas')[0] } );\n\n      // \u80cc\u666f\u8272\u3092\u6307\u5b9a\n      renderer.setClearColor( new THREE.Color(0x99ccff) );\n\n      renderer.setSize(600, 500);\n\n      // Camera\u3092\u7528\u610f\n      camera = new THREE.PerspectiveCamera();\n      camera.position.z = 500;\n\n      // Scene\u3092\u7528\u610f\n      scene = new THREE.Scene();\n      scene.add( camera );\n\n      // \u4e09\u89d2\u3092\u4f5c\u308b\n      var material = new THREE.MeshBasicMaterial( { color: 0xffffa8 } );\n      var shape = new THREE.Shape();\n      shape.moveTo(  0, 100 );\n      shape.lineTo(  100, -50 );\n      shape.lineTo( -100, -50 );\n      shape.lineTo(  0, 100 );\n      var geometry = new THREE.ShapeGeometry( shape );\n      scene.add( new THREE.Mesh( geometry, material ) );\n\n      // \u63cf\u753b\n      renderer.render( scene, camera );\n    } );\n  </script>\n</head>\n\n<body>\n  <canvas id=\"canvas\" style=\"border:solid 1px; margin: 30px;\"></canvas>\n</body>\n```\n\n## \u5b9f\u884c\u7d50\u679c\n![6c168aa5-2481-892f-fa50-91b2509d01d6.png](https://qiita-image-store.s3.amazonaws.com/0/35514/869b07cd-abad-38b5-c7f1-97febd4b3852.png)\n\n\n\n# WebGL \n\n```html\n<html>\n\n<head>\n<title>WebGLHelloAPI</title>\n<meta http-equiv=\"content-type\" content=\"text/html; charset=ISO-8859-1\">\n\n<script type=\"text/javascript\" src=\"WebGLHelloAPI.js\">\n</script>\n\n\n</head>\n\n<body onload=\"main()\">\n    <canvas id=\"helloapicanvas\" style=\"border: none;\" width=\"800\" height=\"600\"></canvas>\n</body>\n\n</html>\n```\n\n```js\nvar gl;\n\nfunction testGLError(functionLastCalled) {\n    /*\n\t\tgl.getError returns the last error that occurred using WebGL, not necessarily the status of the last called function. The user\n\t\thas to check after every single WebGL call or at least once every frame. Usually this would be for debugging only, but for this\n\t\texample is is enabled always.\n\t*/\n\n    var lastError = gl.getError();\n\n    if (lastError != gl.NO_ERROR) {\n        alert(functionLastCalled + \" failed (\" + lastError + \")\");\n        return false;\n    }\n\n    return true;\n}\n\nfunction initialiseGL(canvas) {\n    try {\n        // Try to grab the standard context. If it fails, fallback to experimental\n        gl = canvas.getContext(\"webgl\") || canvas.getContext(\"experimental-webgl\");\n        gl.viewport(0, 0, canvas.width, canvas.height);\n    }\n    catch (e) {\n    }\n\n    if (!gl) {\n        alert(\"Unable to initialise WebGL. Your browser may not support it\");\n        return false;\n    }\n\n    return true;\n}\n\nvar shaderProgram;\n\nfunction initialiseBuffer() {\n    /*\tConcept: Vertices\n\t\tWhen rendering a polygon or model to screen, WebGL has to be told where to draw the object, and more fundamentally what shape \n\t\tit is. The data used to do this is referred to as vertices, points in 3D space which are usually collected into groups of three \n\t\tto render as triangles. Fundamentally, any advanced 3D shape in WebGL is constructed from a series of these vertices - each \n\t\tvertex representing one corner of a polygon.\n\t*/\n    /*\tConcept: Buffer Objects\n\t\tTo operate on any data, WebGL first needs to be able to access it. The GPU maintains a separate pool of memory it uses independent\n\t\tof the CPU. Whilst on many embedded systems these are in the same physical memory, the distinction exists so that they can use and\n\t\tallocate memory without having to worry about synchronising with any other processors in the device.\n\t\tTo this end, data needs to be uploaded into buffers, which are essentially a reserved bit of memory for the GPU to use. By creating\n\t\ta buffer and giving it some data we can tell the GPU how to render a triangle.\n\t*/\n\n    var vertexData = [\n        -0.4, -0.4, 0.0, // Bottom left\n         0.4, -0.4, 0.0, // Bottom right\n         0.0, 0.4, 0.0  // Top middle\n    ];\n\n    // Generate a buffer object\n    gl.vertexBuffer = gl.createBuffer();\n\n    // Bind buffer as a vertex buffer so we can fill it with data\n    gl.bindBuffer(gl.ARRAY_BUFFER, gl.vertexBuffer);\n\n    /*\n        Set the buffer's size, data and usage\n        Note the last argument - gl.STATIC_DRAW. This tells the driver that we intend to read from the buffer on the GPU, and don't intend\n        to modify the data until we've done with it.\n    */\n    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertexData), gl.STATIC_DRAW);\n\n    return testGLError(\"initialiseBuffers\");\n}\n\nfunction initialiseShaders() {\n    /*\tConcept: Shaders\n        WebGL uses what are known as shaders to determine how to draw objects on the screen. Instead of the fixed function\n        pipeline in early OpenGL or OpenGL ES 1.x, users can now programmatically define how vertices are transformed on screen, what\n        data is used where, and how each pixel on the screen is coloured.\n        These shaders are written in GL Shading Language ES: http://www.khronos.org/registry/gles/specs/2.0/GLSL_ES_Specification_1.0.17.pdf\n        which is usually abbreviated to simply \"GLSL ES\".\n        Each shader is compiled on-device and then linked into a shader program, which combines a vertex and fragment shader into a form \n        that the OpenGL ES implementation can execute.\n    */\n\n    /*\tConcept: Fragment Shaders\n        In a final buffer of image data, each individual point is referred to as a pixel. Fragment shaders are the part of the pipeline\n        which determine how these final pixels are coloured when drawn to the framebuffer. When data is passed through here, the positions\n        of these pixels is already set, all that's left to do is set the final colour based on any defined inputs.\n        The reason these are called \"fragment\" shaders instead of \"pixel\" shaders is due to a small technical difference between the two\n        concepts. When you colour a fragment, it may not be the final colour which ends up on screen. This is particularly true when \n        performing blending, where multiple fragments can contribute to the final pixel colour.\n    */\n\n    var fragmentShaderSource = '\\\n\t\t\tvoid main(void) \\\n\t\t\t{ \\\n\t\t\t\tgl_FragColor = vec4(1.0, 1.0, 0.66, 1.0); \\\n\t\t\t}';\n\n    // Create the fragment shader object\n    gl.fragShader = gl.createShader(gl.FRAGMENT_SHADER);\n\n    // Load the source code into it\n    gl.shaderSource(gl.fragShader, fragmentShaderSource);\n\n    // Compile the source code\n    gl.compileShader(gl.fragShader);\n\n    // Check if compilation succeeded\n    if (!gl.getShaderParameter(gl.fragShader, gl.COMPILE_STATUS)) {\n        // It didn't. Display the info log as to why\n        alert(\"Failed to compile the fragment shader.\\n\" + gl.getShaderInfoLog(gl.fragShader));\n        return false;\n    }\n\n    /*\tConcept: Vertex Shaders\n        Vertex shaders primarily exist to allow a developer to express how to orient vertices in 3D space, through transformations like \n        Scaling, Translation or Rotation. Using the same basic layout and structure as a fragment shader, these take in vertex data and \n        output a fully transformed set of positions. Other inputs are also able to be used such as normals or texture coordinates, and can \n        also be transformed and output alongside the position data.\n    */\n\n    // Vertex shader code\n    var vertexShaderSource = '\\\n\t\t\tattribute highp vec4 myVertex; \\\n\t\t\tuniform mediump mat4 transformationMatrix; \\\n\t\t\tvoid main(void)  \\\n\t\t\t{ \\\n\t\t\t\tgl_Position = transformationMatrix * myVertex; \\\n\t\t\t}';\n\n    // Create the vertex shader object\n    gl.vertexShader = gl.createShader(gl.VERTEX_SHADER);\n\n    // Load the source code into it\n    gl.shaderSource(gl.vertexShader, vertexShaderSource);\n\n    // Compile the source code\n    gl.compileShader(gl.vertexShader);\n\n    // Check if compilation succeeded\n    if (!gl.getShaderParameter(gl.vertexShader, gl.COMPILE_STATUS)) {\n        // It didn't. Display the info log as to why\n        alert(\"Failed to compile the vertex shader.\\n\" + gl.getShaderInfoLog(gl.vertexShader));\n        return false;\n    }\n\n    // Create the shader program\n    gl.programObject = gl.createProgram();\n\n    // Attach the fragment and vertex shaders to it\n    gl.attachShader(gl.programObject, gl.fragShader);\n    gl.attachShader(gl.programObject, gl.vertexShader);\n\n    // Bind the custom vertex attribute \"myVertex\" to location 0\n    gl.bindAttribLocation(gl.programObject, 0, \"myVertex\");\n\n    // Link the program\n    gl.linkProgram(gl.programObject);\n\n    // Check if linking succeeded in a similar way we checked for compilation errors\n    if (!gl.getProgramParameter(gl.programObject, gl.LINK_STATUS)) {\n        alert(\"Failed to link the program.\\n\" + gl.getProgramInfoLog(gl.programObject));\n        return false;\n    }\n\n    /*\tUse the Program\n        Calling gl.useProgram tells WebGL that the application intends to use this program for rendering. Now that it's installed into\n        the current state, any further gl.draw* calls will use the shaders contained within it to process scene data. Only one program can\n        be active at once, so in a multi-program application this function would be called in the render loop. Since this application only\n        uses one program it can be installed in the current state and left there.\n    */\n    gl.useProgram(gl.programObject);\n\n    return testGLError(\"initialiseShaders\");\n}\n\nfunction renderScene() {\n    /*\n        Set the clear colour\n        At the start of a frame, generally you clear the image to tell WebGL that you're done with whatever was there before and want to\n        draw a new frame. In order to do that gowever, WebGL needs to know what colour to set in the image's place. gl.clearColor\n        sets this value as 4 floating point values between 0.0 and 1.0, as the Red, Green, Blue and Alpha channels. Each value represents\n        the intensity of the particular channel, with all 0.0 being transparent black, and all 1.0 being opaque white. Subsequent calls to\n        gl.clear with the colour bit will clear the framebuffer to this vlaue.\n        The functions gl.clearDepth and gl.clearStencil allow an application to do the same with depth and stencil values respectively.\n    */\n    gl.clearColor(0.6, 0.8, 1.0, 1.0);\n\n    /*\n        Clear the colour buffer\n        gl.clear is used here with the colour buffer to clear the colour. It can also be used to clear the depth or stencil buffer using\n        gl.DEPTH_BUFFER_BIT or gl.STENCIL_BUFFER_BIT, respectively.\n    */\n\n    gl.clear(gl.COLOR_BUFFER_BIT);\n\n    // Get the location of the transformation matrix in the shader using its name\n    var matrixLocation = gl.getUniformLocation(gl.programObject, \"transformationMatrix\");\n\n    // Matrix used to specify the orientation of the triangle on screen\n    var transformationMatrix = [\n        1.0, 0.0, 0.0, 0.0,\n        0.0, 1.0, 0.0, 0.0,\n        0.0, 0.0, 1.0, 0.0,\n        0.0, 0.0, 0.0, 1.0\n    ];\n\n    // Pass the identity transformation matrix to the shader using its location\n    gl.uniformMatrix4fv(matrixLocation, gl.FALSE, transformationMatrix);\n\n    if (!testGLError(\"gl.uniformMatrix4fv\")) {\n        return false;\n    }\n\n    // Enable the user-defined vertex array\n    gl.enableVertexAttribArray(0);\n\n    // Set the vertex data to this attribute index, with the number of floats in each position\n    gl.vertexAttribPointer(0, 3, gl.FLOAT, gl.FALSE, 0, 0);\n\n    if (!testGLError(\"gl.vertexAttribPointer\")) {\n        return false;\n    }\n\n    /*\n        Draw the triangle\n        gl.drawArrays is a draw call, and executes the shader program using the vertices and other state set by the user. Draw calls are the\n        functions which tell WebGL when to actually draw something to the framebuffer gived the current state.\n        gl.drawArrays causes the vertices to be submitted sequentially from the position given by the \"first\" argument until it has processed\n        \"count\" vertices. Other draw calls exist, notably gl.drawElements which also accepts index data to allow the user to specify that \n        some vertices are accessed multiple times, without copying the vertex multiple times.\n        Others include versions of the above that allow the user to draw the same ovhect multiple times with slightly different data, and\n        a version of gl.drawElements which allows a user to restrict the actuial indices accessed.\n    */\n    gl.drawArrays(gl.TRIANGLES, 0, 3);\n\n    if (!testGLError(\"gl.drawArrays\")) {\n        return false;\n    }\n\n    return true;\n}\n\nfunction main() {\n    var canvas = document.getElementById(\"helloapicanvas\");\n\n    if (!initialiseGL(canvas)) {\n        return;\n    }\n\n    if (!initialiseBuffer()) {\n        return;\n    }\n\n    if (!initialiseShaders()) {\n        return;\n    }\n\n    // Render loop\n    requestAnimFrame = (function () {\n        return window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame ||\n\t\t\tfunction (callback) {\n\t\t\t    window.setTimeout(callback, 1000, 60);\n\t\t\t};\n    })();\n\n    (function renderLoop() {\n        if (renderScene()) {\n            // Everything was successful, request that we redraw our scene again in the future\n            requestAnimFrame(renderLoop);\n        }\n    })();\n}\n```\n\n## \u5b9f\u884c\u7d50\u679c\n![pvrsdk_webgl_triangle.png](https://qiita-image-store.s3.amazonaws.com/0/35514/b5ca32d2-5a25-de55-823f-b611fbb72dee.png)\n\nhttp://powervr-graphics.github.io/WebGL_SDK/WebGL_SDK/Examples/Beginner/01_HelloAPI/WebGL/\n\n\n# OpenGL ES\n## \u30b3\u30fc\u30c9\n```\n/*******************************************************************************************************************************************\n\n @File         OGLES2HelloAPI_LinuxX11.cpp\n\n @Title        OpenGL ES 2.0 HelloAPI Tutorial\n\n @Version      \n\n @Copyright    Copyright (c) Imagination Technologies Limited.\n\n @Platform     \n\n @Description  Basic Tutorial that shows step-by-step how to initialize OpenGL ES 2.0, use it for drawing a triangle and terminate it.\n               Entry Point: main\n\n*******************************************************************************************************************************************/\n/*******************************************************************************************************************************************\n Include Files\n*******************************************************************************************************************************************/\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include \"X11/Xlib.h\"\n#include \"X11/Xutil.h\"\n\n#include <EGL/egl.h>\n#include <GLES2/gl2.h>\n\n/*******************************************************************************************************************************************\n Defines\n*******************************************************************************************************************************************/\n// Name of the application\n#define APPLICATION_NAME \"HelloAPI\"\n\n// Width and height of the window\n#define WINDOW_WIDTH\t800\n#define WINDOW_HEIGHT\t600\n\n// Index to bind the attributes to vertex shaders\n#define VERTEX_ARRAY\t0\n\n/*******************************************************************************************************************************************\n Helper Functions\n*******************************************************************************************************************************************/\n\n/*!*****************************************************************************************************************************************\n @Function\t\tTestEGLError\n @Input\t\t\tfunctionLastCalled          Function which triggered the error\n @Return\t\tTrue if no EGL error was detected\n @Description\tTests for an EGL error and prints it.\n*******************************************************************************************************************************************/\nbool TestEGLError(const char* functionLastCalled)\n{\n\t/*\teglGetError returns the last error that occurred using EGL, not necessarily the status of the last called function. The user has to\n\t\tcheck after every single EGL call or at least once every frame. Usually this would be for debugging only, but for this example\n\t\tit is enabled always.\n\t*/\n\tEGLint lastError = eglGetError();\n\tif (lastError != EGL_SUCCESS)\n\t{\n\t\tprintf(\"%s failed (%x).\\n\", functionLastCalled, lastError);\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\n/*!*****************************************************************************************************************************************\n @Function\t\tHandleX11Errors\n @Input\t\t\tnativeDisplay               Handle to the display\n @Input\t\t\terror                       The error event to handle\n @Return\t\tResult code to send to the X window system\n @Description\tProcesses event messages for the main window\n*******************************************************************************************************************************************/\nint HandleX11Errors(Display *nativeDisplay, XErrorEvent *error)\n{\n\t// Get the X Error\n\tchar errorStringBuffer[256];\n\tXGetErrorText(nativeDisplay, error->error_code, errorStringBuffer, 256);\n\n\t// Print the error\n\tprintf(\"%s\", errorStringBuffer);\n\n\t// Exit the application\n\texit(-1);\n\n\treturn 0;\n}\n\n/*!*****************************************************************************************************************************************\n @Function\t\tTestGLError\n @Input\t\t\tfunctionLastCalled          Function which triggered the error\n @Return\t\tTrue if no GL error was detected\n @Description\tTests for an GL error and prints it in a message box.\n*******************************************************************************************************************************************/\nbool TestGLError(const char* functionLastCalled)\n{\n\t/*\tglGetError returns the last error that occurred using OpenGL ES, not necessarily the status of the last called function. The user \n\t\thas to check after every single OpenGL ES call or at least once every frame. Usually this would be for debugging only, but for this\n\t\texample it is enabled always\n\t*/\n\tGLenum lastError = glGetError();\n\tif (lastError != GL_NO_ERROR)\n\t{\n\t\tprintf(\"%s failed (%x).\\n\", functionLastCalled, lastError);\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\n/*******************************************************************************************************************************************\n Application Functions\n*******************************************************************************************************************************************/\n\n/*!*****************************************************************************************************************************************\n @Function\t\tCreateNativeDisplay\n @Output\t\tnativeDisplay\t\t\t\tNative display to create\n @Return\t\tWhether the function succeeded or not.\n @Description\tCreates a native isplay for the application to render into.\n*******************************************************************************************************************************************/\nbool CreateNativeDisplay(Display** nativeDisplay) \n{\n\t// Check for a valid display\n\tif (!nativeDisplay)\n\t{\n\t\treturn false;\n\t}\n\n\t// Open the display\n\t*nativeDisplay = XOpenDisplay( 0 );\n\tif (!*nativeDisplay)\n\t{\n\t\tprintf(\"Error: Unable to open X display\\n\");\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\n/*!*****************************************************************************************************************************************\n @Function\t\tCreateNativeWindow\n @Input\t\t\tnativeDisplay\t\t\t\tNative display used by the application\n @Output\t\tnativeWindow\t\t\t    Native window type to create\n @Return\t\tWhether the function succeeded or not.\n @Description\tCreates a native window for the application to render into.\n*******************************************************************************************************************************************/\nbool CreateNativeWindow(Display* nativeDisplay, Window* nativeWindow) \n{\n\t// Get the default screen for the display\n\tint defaultScreen = XDefaultScreen(nativeDisplay);\n\n\t// Get the default depth of the display\n\tint defaultDepth = DefaultDepth(nativeDisplay, defaultScreen);\n\n\t// Select a visual info\n\tXVisualInfo* visualInfo = new XVisualInfo;\n\tXMatchVisualInfo( nativeDisplay, defaultScreen, defaultDepth, TrueColor, visualInfo);\n\tif (!visualInfo)\n\t{\n\t\tprintf(\"Error: Unable to acquire visual\\n\");\n\t\treturn false;\n\t}\n\n\t// Get the root window for the display and default screen\n\tWindow rootWindow = RootWindow(nativeDisplay, defaultScreen);\n\t\n\t// Create a colour map from the display, root window and visual info\n\tColormap colourMap = XCreateColormap(nativeDisplay, rootWindow, visualInfo->visual, AllocNone);\n\n\t// Now setup the final window by specifying some attributes\n\tXSetWindowAttributes windowAttributes;\n\n\t// Set the colour map that was just created\n\twindowAttributes.colormap = colourMap;\n\t\n\t// Set events that will be handled by the app, add to these for other events.\n\twindowAttributes.event_mask = StructureNotifyMask | ExposureMask | ButtonPressMask;\n\n\t// Create the window\n\t*nativeWindow =XCreateWindow(nativeDisplay,               // The display used to create the window\n\t                             rootWindow,                   // The parent (root) window - the desktop\n\t\t\t\t\t\t  \t\t 0,                            // The horizontal (x) origin of the window\n\t\t\t\t\t\t\t\t 0,                            // The vertical (y) origin of the window\n\t\t\t\t\t\t\t\t WINDOW_WIDTH,                 // The width of the window\n\t\t\t\t\t\t\t\t WINDOW_HEIGHT,                // The height of the window\n\t\t\t\t\t\t\t\t 0,                            // Border size - set it to zero\n\t                             visualInfo->depth,            // Depth from the visual info\n\t\t\t\t\t\t\t\t InputOutput,                  // Window type - this specifies InputOutput.\n\t\t\t\t\t\t\t\t visualInfo->visual,           // Visual to use\n\t\t\t\t\t\t\t\t CWEventMask | CWColormap,     // Mask specifying these have been defined in the window attributes\n\t\t\t\t\t\t\t\t &windowAttributes);           // Pointer to the window attribute structure\n\n\t// Make the window viewable by mapping it to the display\n\tXMapWindow(nativeDisplay, *nativeWindow);\n\n\t// Set the window title\n\tXStoreName(nativeDisplay, *nativeWindow, APPLICATION_NAME);\n\t\n\t// Setup the window manager protocols to handle window deletion events\n\tAtom windowManagerDelete = XInternAtom(nativeDisplay, \"WM_DELETE_WINDOW\", True);\n\tXSetWMProtocols(nativeDisplay, *nativeWindow, &windowManagerDelete , 1);\n\n\t// Delete the visual info\n\tdelete visualInfo;\n\n\treturn true;\n}\n\n/*!*****************************************************************************************************************************************\n @Function\t\tCreateEGLDisplay\n @Input\t\t\tnativeDisplay               The native display used by the application\n @Output\t\teglDisplay\t\t\t\t    EGLDisplay created from nativeDisplay\n @Return\t\tWhether the function succeeded or not.\n @Description\tCreates an EGLDisplay from a native native display, and initialises it.\n*******************************************************************************************************************************************/\nbool CreateEGLDisplay( Display* nativeDisplay, EGLDisplay &eglDisplay ) \n{\n\t/*\tGet an EGL display.\n\t\tEGL uses the concept of a \"display\" which in most environments corresponds to a single physical screen. After creating a native\n\t\tdisplay for a given windowing system, EGL can use this handle to get a corresponding EGLDisplay handle to it for use in rendering.\n\t\tShould this fail, EGL is usually able to provide access to a default display.\n\t*/\n\teglDisplay = eglGetDisplay((EGLNativeDisplayType)nativeDisplay);\n\t// If a display couldn't be obtained, return an error.\n\tif (eglDisplay == EGL_NO_DISPLAY)\n\t{\n\t\tprintf(\"Failed to get an EGLDisplay\");\n\t\treturn false;\n\t}\n\n\t/*\tInitialize EGL.\n\t\tEGL has to be initialized with the display obtained in the previous step. All EGL functions other than eglGetDisplay \n\t\tand eglGetError need an initialised EGLDisplay. \n\t\tIf an application is not interested in the EGL version number it can just pass NULL for the second and third parameters, but they \n\t\tare queried here for illustration purposes.\n\t*/\n\tEGLint eglMajorVersion, eglMinorVersion;\n\tif (!eglInitialize(eglDisplay, &eglMajorVersion, &eglMinorVersion))\n\t{\n\t\tprintf(\"Failed to initialise the EGLDisplay\");\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\n/*!*****************************************************************************************************************************************\n @Function\t\tChooseEGLConfig\n @Input\t\t\teglDisplay                  The EGLDisplay used by the application\n @Output\t\teglConfig                   The EGLConfig chosen by the function\n @Return\t\tWhether the function succeeded or not.\n @Description\tChooses an appropriate EGLConfig and return it.\n*******************************************************************************************************************************************/\nbool ChooseEGLConfig( EGLDisplay eglDisplay, EGLConfig& eglConfig ) \n{\n\t/*\tSpecify the required configuration attributes.\n\t\tAn EGL \"configuration\" describes the capabilities an application requires and the type of surfaces that can be used for drawing.\n\t\tEach implementation exposes a number of different configurations, and an application needs to describe to EGL what capabilities it\n\t\trequires so that an appropriate one can be chosen. The first step in doing this is to create an attribute list, which is an array\n\t\tof key/value pairs which describe particular capabilities requested. In this application nothing special is required so we can query\n\t\tthe minimum of needing it to render to a window, and being OpenGL ES 2.0 capable.\n\t*/\n\tconst EGLint configurationAttributes[] =\n\t{\n\t\tEGL_SURFACE_TYPE,\t\tEGL_WINDOW_BIT,\n\t\tEGL_RENDERABLE_TYPE,\tEGL_OPENGL_ES2_BIT,\n\t\tEGL_NONE\n\t};\n\n\t/*\tFind a suitable EGLConfig\n\t\teglChooseConfig is provided by EGL to provide an easy way to select an appropriate configuration. It takes in the capabilities\n\t\tspecified in the attribute list, and returns a list of available configurations that match or exceed the capabilities requested.\n\t\tDetails of all the possible attributes and how they are selected for by this function are available in the EGL reference pages here:\n\t\thttp://www.khronos.org/registry/egl/sdk/docs/man/xhtml/eglChooseConfig.html\n\t\tIt is also possible to simply get the entire list of configurations and use a custom algorithm to choose a suitable one, as many\n\t\tadvanced applications choose to do. For this application however, taking the first EGLConfig that the function returns suits\n\t\tits needs perfectly, so we limit it to returning a single EGLConfig.\n\t*/\n\tEGLint configsReturned;\n\tif (!eglChooseConfig(eglDisplay, configurationAttributes, &eglConfig, 1, &configsReturned) || (configsReturned != 1))\n\t{\n\t\tprintf(\"Failed to choose a suitable config.\");\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\n/*!*****************************************************************************************************************************************\n @Function\t\tCreateEGLSurface\n @Input\t\t\tnativeWindow                A native window that's been created\n @Input\t\t\teglDisplay                  The EGLDisplay used by the application\n @Input\t\t\teglConfig                   An EGLConfig chosen by the application\n @Output\t\teglSurface\t\t\t\t\tThe EGLSurface created from the native window.\n @Return\t\tWhether the function succeeds or not.\n @Description\tCreates an EGLSurface from a native window\n*******************************************************************************************************************************************/\nbool CreateEGLSurface( Window nativeWindow, EGLDisplay eglDisplay, EGLConfig eglConfig, EGLSurface& eglSurface) \n{\n\t/*\tCreate an EGLSurface for rendering.\n\t\tUsing a native window created earlier and a suitable eglConfig, a surface is created that can be used to render OpenGL ES calls to.\n\t\tThere are three main surface types in EGL, which can all be used in the same way once created but work slightly differently:\n\t\t - Window Surfaces  - These are created from a native window and are drawn to the screen.\n\t\t - Pixmap Surfaces  - These are created from a native windowing system as well, but are offscreen and are not displayed to the user.\n\t\t - PBuffer Surfaces - These are created directly within EGL, and like Pixmap Surfaces are offscreen and thus not displayed.\n\t\tThe offscreen surfaces are useful for non-rendering contexts and in certain other scenarios, but for most applications the main\n\t\tsurface used will be a window surface as performed below.\n\t*/\n\teglSurface = eglCreateWindowSurface(eglDisplay, eglConfig, (EGLNativeWindowType)nativeWindow, NULL);\n\tif (!TestEGLError(\"eglCreateWindowSurface\"))\n\t{\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\n/*!*****************************************************************************************************************************************\n @Function\t\tSetupEGLContext\n @Input\t\t\teglDisplay                  The EGLDisplay used by the application\n @Input\t\t\teglConfig                   An EGLConfig chosen by the application\n @Input\t\t\teglSurface\t\t\t\t\tThe EGLSurface created from the native window.\n @Output\t\teglContext                  The EGLContext created by this function\n @Input\t\t\tnativeWindow                A native window, used to display error messages\n @Return\t\tWhether the function succeeds or not.\n @Description\tSets up the EGLContext, creating it and then installing it to the current thread.\n*******************************************************************************************************************************************/\nbool SetupEGLContext( EGLDisplay eglDisplay, EGLConfig eglConfig, EGLSurface eglSurface, EGLContext& eglContext ) \n{\n\t/*\tMake OpenGL ES the current API.\n\t EGL needs a way to know that any subsequent EGL calls are going to be affecting OpenGL ES,\n\t rather than any other API (such as OpenVG).\n\t */\n\teglBindAPI(EGL_OPENGL_ES_API);\n\tif (!TestEGLError(\"eglBindAPI\"))\n\t{\n\t\treturn false;\n\t}\n\n\t/*\tCreate a context.\n\t\tEGL has to create what is known as a context for OpenGL ES. The concept of a context is OpenGL ES's way of encapsulating any\n\t\tresources and state. What appear to be \"global\" functions in OpenGL actually only operate on the current context. A context\n\t\tis required for any operations in OpenGL ES.\n\t\tSimilar to an EGLConfig, a context takes in a list of attributes specifying some of its capabilities. However in most cases this\n\t\tis limited to just requiring the version of the OpenGL ES context required - In this case, OpenGL ES 2.0.\n\t*/\n\tEGLint contextAttributes[] = \n\t{\n\t\tEGL_CONTEXT_CLIENT_VERSION, 2, \n\t\tEGL_NONE\n\t};\n\n\t// Create the context with the context attributes supplied\n\teglContext = eglCreateContext(eglDisplay, eglConfig, NULL, contextAttributes);\n\tif (!TestEGLError(\"eglCreateContext\"))\n\t{\n\t\treturn false;\n\t}\n\n\t/*\tBind the context to the current thread.\n\t\tDue to the way OpenGL uses global functions, contexts need to be made current so that any function call can operate on the correct\n\t\tcontext. Specifically, make current will bind the context to the thread it's called from, and unbind it from any others. To use\n\t\tmultiple contexts at the same time, users should use multiple threads and synchronise between them.\n\t*/\n\teglMakeCurrent(eglDisplay, eglSurface, eglSurface, eglContext);\n\tif (!TestEGLError(\"eglMakeCurrent\"))\n\t{\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\n/*!*****************************************************************************************************************************************\n @Function\t\tInitialiseBuffer\n @Output\t\tvertexBuffer                Handle to a vertex buffer object\n @Return\t\tWhether the function succeeds or not.\n @Description\tInitialises shaders, buffers and other state required to begin rendering with OpenGL ES\n*******************************************************************************************************************************************/\nbool InitialiseBuffer(GLuint &vertexBuffer) \n{\n\t/*\tConcept: Vertices\n\t\tWhen rendering a polygon or model to screen, OpenGL ES has to be told where to draw the object, and more fundamentally what shape \n\t\tit is. The data used to do this is referred to as vertices, points in 3D space which are usually collected into groups of three \n\t\tto render as triangles. Fundamentally, any advanced 3D shape in OpenGL ES is constructed from a series of these vertices - each \n\t\tvertex representing one corner of a polygon.\n\t*/\n\n\t/*\tConcept: Buffer Objects\n\t\tTo operate on any data, OpenGL first needs to be able to access it. The GPU maintains a separate pool of memory it uses independent\n\t\tof the CPU. Whilst on many embedded systems these are in the same physical memory, the distinction exists so that they can use and\n\t\tallocate memory without having to worry about synchronising with any other processors in the device.\n\t\tTo this end, data needs to be uploaded into buffers, which are essentially a reserved bit of memory for the GPU to use. By creating\n\t\ta buffer and giving it some data we can tell the GPU how to render a triangle.\n\t*/\n\n\t// Vertex data containing the positions of each point of the triangle\n\tGLfloat vertexData[] = {-0.4f,-0.4f, 0.0f,  // Bottom Left\n\t                         0.4f,-0.4f, 0.0f,  // Bottom Right\n\t                         0.0f, 0.4f, 0.0f}; // Top Middle\n\n\t// Generate a buffer object\n\tglGenBuffers(1, &vertexBuffer);\n\n\t// Bind buffer as an vertex buffer so we can fill it with data\n\tglBindBuffer(GL_ARRAY_BUFFER, vertexBuffer);\n\t\n\t/*\tSet the buffer's size, data and usage\n\t\tNote the last argument - GL_STATIC_DRAW. This tells the driver that we intend to read from the buffer on the GPU, and don't intend\n\t\tto modify the data until we're done with it.\t\t\n\t*/\n\tglBufferData(GL_ARRAY_BUFFER, sizeof(vertexData), vertexData, GL_STATIC_DRAW);\n\n\tif (!TestGLError(\"glBufferData\"))\n\t{\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\n/*!*****************************************************************************************************************************************\n @Function\t\tInitialiseShaders\n @Output\t\tfragmentShader              Handle to a fragment shader\n @Output\t\tvertexShader                Handle to a vertex shader\n @Output\t\tshaderProgram               Handle to a shader program containing the fragment and vertex shader\n @Return\t\tWhether the function succeeds or not.\n @Description\tInitialises shaders, buffers and other state required to begin rendering with OpenGL ES\n*******************************************************************************************************************************************/\nbool InitialiseShaders( GLuint &fragmentShader, GLuint &vertexShader, GLuint &shaderProgram) \n{\n\t/*\tConcept: Shaders\n\t\tOpenGL ES 2.0 uses what are known as shaders to determine how to draw objects on the screen. Instead of the fixed function\n\t\tpipeline in early OpenGL or OpenGL ES 1.x, users can now programmatically define how vertices are transformed on screen, what\n\t\tdata is used where, and how each pixel on the screen is coloured.\n\t\tThese shaders are written in GL Shading Language ES: http://www.khronos.org/registry/gles/specs/2.0/GLSL_ES_Specification_1.0.17.pdf\n\t\twhich is usually abbreviated to simply \"GLSL ES\".\n\t\tEach shader is compiled on-device and then linked into a shader program, which combines a vertex and fragment shader into a form \n\t\tthat the OpenGL ES implementation can execute.\n\t*/\n\n\t/*\tConcept: Fragment Shaders\n\t\tIn a final buffer of image data, each individual point is referred to as a pixel. Fragment shaders are the part of the pipeline\n\t\twhich determine how these final pixels are coloured when drawn to the framebuffer. When data is passed through here, the positions\n\t\tof these pixels is already set, all that's left to do is set the final colour based on any defined inputs.\n\t\tThe reason these are called \"fragment\" shaders instead of \"pixel\" shaders is due to a small technical difference between the two\n\t\tconcepts. When you colour a fragment, it may not be the final colour which ends up on screen. This is particularly true when \n\t\tperforming blending, where multiple fragments can contribute to the final pixel colour.\n\t*/\n\tconst char* const fragmentShaderSource = \"\\\n\t\t\t\t\t\t\t\t\t\t\t void main (void)\\\n\t\t\t\t\t\t\t\t\t\t\t {\\\n\t\t\t\t\t\t\t\t\t\t\t gl_FragColor = vec4(1.0, 1.0, 0.66 ,1.0);\\\n\t\t\t\t\t\t\t\t\t\t\t }\";\n\n\t// Create a fragment shader object\n\tfragmentShader = glCreateShader(GL_FRAGMENT_SHADER);\n\n\t// Load the source code into it\n\tglShaderSource(fragmentShader, 1, (const char**)&fragmentShaderSource, NULL);\n\n\t// Compile the source code\n\tglCompileShader(fragmentShader);\n\n\t// Check that the shader compiled\n\tGLint isShaderCompiled;\n\tglGetShaderiv(fragmentShader, GL_COMPILE_STATUS, &isShaderCompiled);\n\tif (!isShaderCompiled)\n\t{\n\t\t// If an error happened, first retrieve the length of the log message\n\t\tint infoLogLength, charactersWritten;\n\t\tglGetShaderiv(fragmentShader, GL_INFO_LOG_LENGTH, &infoLogLength);\n\n\t\t// Allocate enough space for the message and retrieve it\n\t\tchar* infoLog = new char[infoLogLength];\n\t\tglGetShaderInfoLog(fragmentShader, infoLogLength, &charactersWritten, infoLog);\n\n\t\t// Display the error in a dialog box\n\t\tinfoLogLength>1 ? printf(\"%s\", infoLog) : printf(\"Failed to compile fragment shader.\");\n\n\t\tdelete[] infoLog;\n\t\treturn false;\n\t}\n\t\n\t/*\tConcept: Vertex Shaders\n\t\tVertex shaders primarily exist to allow a developer to express how to orient vertices in 3D space, through transformations like \n\t\tScaling, Translation or Rotation. Using the same basic layout and structure as a fragment shader, these take in vertex data and \n\t\toutput a fully transformed set of positions. Other inputs are also able to be used such as normals or texture coordinates, and can \n\t\talso be transformed and output alongside the position data.\n\t*/\n\t// Vertex shader code\n\tconst char* const vertexShaderSource = \"\\\n\t\t\t\t\t\t\t\t\t\t   attribute highp vec4\tmyVertex;\\\n\t\t\t\t\t\t\t\t\t\t   uniform mediump mat4\ttransformationMatrix;\\\n\t\t\t\t\t\t\t\t\t\t   void main(void)\\\n\t\t\t\t\t\t\t\t\t\t   {\\\n\t\t\t\t\t\t\t\t\t\t   gl_Position = transformationMatrix * myVertex;\\\n\t\t\t\t\t\t\t\t\t\t   }\";\n\n\t// Create a vertex shader object\n\tvertexShader = glCreateShader(GL_VERTEX_SHADER);\n\n\t// Load the source code into the shader\n\tglShaderSource(vertexShader, 1, (const char**)&vertexShaderSource, NULL);\n\n\t// Compile the shader\n\tglCompileShader(vertexShader);\n\n\t// Check the shader has compiled\n\tglGetShaderiv(vertexShader, GL_COMPILE_STATUS, &isShaderCompiled);\n\tif (!isShaderCompiled)\n\t{\n\t\t// If an error happened, first retrieve the length of the log message\n\t\tint infoLogLength, charactersWritten;\n\t\tglGetShaderiv(vertexShader, GL_INFO_LOG_LENGTH, &infoLogLength);\n\n\t\t// Allocate enough space for the message and retrieve it\n\t\tchar* infoLog = new char[infoLogLength];\n\t\tglGetShaderInfoLog(vertexShader, infoLogLength, &charactersWritten, infoLog);\n\n\t\t// Display the error in a dialog box\n\t\tinfoLogLength>1 ? printf(\"%s\", infoLog) : printf(\"Failed to compile vertex shader.\");\n\n\t\tdelete[] infoLog;\n\t\treturn false;\n\t}\n\n\t// Create the shader program\n\tshaderProgram = glCreateProgram();\n\n\t// Attach the fragment and vertex shaders to it\n\tglAttachShader(shaderProgram, fragmentShader);\n\tglAttachShader(shaderProgram, vertexShader);\n\n\t// Bind the vertex attribute \"myVertex\" to location VERTEX_ARRAY (0)\n\tglBindAttribLocation(shaderProgram, VERTEX_ARRAY, \"myVertex\");\n\n\t// Link the program\n\tglLinkProgram(shaderProgram);\n\n\t// Check if linking succeeded in the same way we checked for compilation success\n\tGLint isLinked;\n\tglGetProgramiv(shaderProgram, GL_LINK_STATUS, &isLinked);\n\tif (!isLinked)\n\t{\n\t\t// If an error happened, first retrieve the length of the log message\n\t\tint infoLogLength, charactersWritten;\n\t\tglGetProgramiv(shaderProgram, GL_INFO_LOG_LENGTH, &infoLogLength);\n\n\t\t// Allocate enough space for the message and retrieve it\n\t\tchar* infoLog = new char[infoLogLength];\n\t\tglGetProgramInfoLog(shaderProgram, infoLogLength, &charactersWritten, infoLog);\n\n\t\t// Display the error in a dialog box\n\t\tinfoLogLength>1 ? printf(\"%s\", infoLog) : printf(\"Failed to link shader program.\");\n\n\t\tdelete[] infoLog;\n\t\treturn false;\n\t}\n\t\n\t/*\tUse the Program\n\t\tCalling glUseProgram tells OpenGL ES that the application intends to use this program for rendering. Now that it's installed into\n\t\tthe current state, any further glDraw* calls will use the shaders contained within it to process scene data. Only one program can\n\t\tbe active at once, so in a multi-program application this function would be called in the render loop. Since this application only\n\t\tuses one program it can be installed in the current state and left there.\n\t*/\n\tglUseProgram(shaderProgram);\n\n\tif (!TestGLError(\"glUseProgram\"))\n\t{\n\t\treturn false;\n\t}\n\t\n\treturn true;\n}\n\n/*!*****************************************************************************************************************************************\n @Function\t\tRenderScene\n @Input\t\t\tshaderProgram               The shader program used to render the scene\n @Input\t\t\teglDisplay                  The EGLDisplay used by the application\n @Input\t\t\teglSurface\t\t\t\t\tThe EGLSurface created from the native window.\n @Input\t\t\tnativeDisplay\t\t\t\tThe native display used by the application\n @Return\t\tWhether the function succeeds or not.\n @Description\tRenders the scene to the framebuffer. Usually called within a loop.\n*******************************************************************************************************************************************/\nbool RenderScene( GLuint shaderProgram, EGLDisplay eglDisplay, EGLSurface eglSurface, Display* nativeDisplay ) \n{\n\t/*\tSet the clear color\n\t\tAt the start of a frame, generally you clear the image to tell OpenGL ES that you're done with whatever was there before and want to\n\t\tdraw a new frame. In order to do that however, OpenGL ES needs to know what colour to set in the image's place. glClearColor\n\t\tsets this value as 4 floating point values between 0.0 and 1.0, as the Red, Green, Blue and Alpha channels. Each value represents\n\t\tthe intensity of the particular channel, with all 0.0 being transparent black, and all 1.0 being opaque white. Subsequent calls to\n\t\tglClear with the colour bit will clear the frame buffer to this value.\n\t\tThe functions glClearDepth and glClearStencil allow an application to do the same with depth and stencil values respectively.\n\t*/\n\tglClearColor(0.6f, 0.8f, 1.0f, 1.0f);\n\n\t/*\tClears the color buffer.\n\t\tglClear is used here with the Colour Buffer to clear the colour. It can also be used to clear the depth or stencil buffer using \n\t\tGL_DEPTH_BUFFER_BIT or GL_STENCIL_BUFFER_BIT, respectively.\n\t*/\n\tglClear(GL_COLOR_BUFFER_BIT);\n\n\t// Get the location of the transformation matrix in the shader using its name\n\tint matrixLocation = glGetUniformLocation(shaderProgram, \"transformationMatrix\");\n\n\t// Matrix used to specify the orientation of the triangle on screen.\n\tconst float transformationMatrix[] =\n\t{\n\t\t1.0f,0.0f,0.0f,0.0f,\n\t\t0.0f,1.0f,0.0f,0.0f,\n\t\t0.0f,0.0f,1.0f,0.0f,\n\t\t0.0f,0.0f,0.0f,1.0f\n\t};\n\n\t// Pass the transformationMatrix to the shader using its location\n\tglUniformMatrix4fv( matrixLocation, 1, GL_FALSE, transformationMatrix);\n\tif (!TestGLError(\"glUniformMatrix4fv\"))\n\t{\n\t\treturn false;\n\t}\n\n\t// Enable the user-defined vertex array\n\tglEnableVertexAttribArray(VERTEX_ARRAY);\n\n\t// Sets the vertex data to this attribute index, with the number of floats in each position\n\tglVertexAttribPointer(VERTEX_ARRAY, 3, GL_FLOAT, GL_FALSE, 0, 0);\n\tif (!TestGLError(\"glVertexAttribPointer\"))\n\t{\n\t\treturn false;\n\t}\n\n\t/*\tDraw the triangle\n\t\tglDrawArrays is a draw call, and executes the shader program using the vertices and other state set by the user. Draw calls are the\n\t\tfunctions which tell OpenGL ES when to actually draw something to the framebuffer given the current state.\n\t\tglDrawArrays causes the vertices to be submitted sequentially from the position given by the \"first\" argument until it has processed\n\t\t\"count\" vertices. Other draw calls exist, notably glDrawElements which also accepts index data to allow the user to specify that\n\t\tsome vertices are accessed multiple times, without copying the vertex multiple times.\n\t\tOthers include versions of the above that allow the user to draw the same object multiple times with slightly different data, and\n\t\ta version of glDrawElements which allows a user to restrict the actual indices accessed.\n\t*/\n\tglDrawArrays(GL_TRIANGLES, 0, 3);\n\tif (!TestGLError(\"glDrawArrays\"))\n\t{\n\t\treturn false;\n\t}\n\n\t/*\tPresent the display data to the screen.\n\t\tWhen rendering to a Window surface, OpenGL ES is double buffered. This means that OpenGL ES renders directly to one frame buffer, \n\t\tknown as the back buffer, whilst the display reads from another - the front buffer. eglSwapBuffers signals to the windowing system\n\t\tthat OpenGL ES 2.0 has finished rendering a scene, and that the display should now draw to the screen from the new data. At the same\n\t\ttime, the front buffer is made available for OpenGL ES 2.0 to start rendering to. In effect, this call swaps the front and back \n\t\tbuffers.\n\t*/\n\tif (!eglSwapBuffers(eglDisplay, eglSurface) )\n\t{\n\t\tTestEGLError(\"eglSwapBuffers\");\n\t\treturn false;\n\t}\n\n\t// Check for messages from the windowing system.\n\tint numberOfMessages = XPending(nativeDisplay);\n\tfor( int i = 0; i < numberOfMessages; i++ )\n\t{\n\t\tXEvent event;\n\t\tXNextEvent(nativeDisplay, &event);\n\n\t\tswitch( event.type )\n\t\t{\n\t\t\t// Exit on window close\n\t\tcase ClientMessage:\n\t\t\t// Exit on mouse click\n\t\tcase ButtonPress:\n\t\tcase DestroyNotify:\n\t\t\treturn false;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn true;\n}\n\n/*!*****************************************************************************************************************************************\n @Function\t\tDeInitialiseGLState\n @Input\t\t\tfragmentShader              Handle to a fragment shader\n @Input\t\t\tvertexShader                Handle to a vertex shader\n @Input\t\t\tshaderProgram               Handle to a shader program containing the fragment and vertex shader\n @Input\t\t\tvertexBuffer                Handle to a vertex buffer object\n @Description\tReleases the resources created by \"InitialiseGLState\"\n*******************************************************************************************************************************************/\nvoid DeInitialiseGLState( GLuint fragmentShader, GLuint vertexShader, GLuint shaderProgram, GLuint vertexBuffer ) \n{\n\t// Frees the OpenGL handles for the program and the 2 shaders\n\tglDeleteShader(fragmentShader);\n\tglDeleteShader(vertexShader);\n\tglDeleteProgram(shaderProgram);\n\n\t// Delete the VBO as it is no longer needed\n\tglDeleteBuffers(1, &vertexBuffer);\n}\n\n/*!*****************************************************************************************************************************************\n @Function\t\tReleaseEGLState\n @Input\t\t\teglDisplay                   The EGLDisplay used by the application\n @Description\tReleases all resources allocated by EGL\n*******************************************************************************************************************************************/\nvoid ReleaseEGLState(EGLDisplay eglDisplay) \n{\n\tif(eglDisplay != NULL)\n\t{\n\t\t// To release the resources in the context, first the context has to be released from its binding with the current thread.\n\t\teglMakeCurrent(eglDisplay, EGL_NO_SURFACE, EGL_NO_SURFACE, EGL_NO_CONTEXT);\n\n\t\t// Terminate the display, and any resources associated with it (including the EGLContext)\n\t\teglTerminate(eglDisplay);\n\t}\n}\n\n/*!*****************************************************************************************************************************************\n @Function\t\tReleaseWindowAndDisplay\n @Input\t\t\tnativeDisplay               The native display to release\n @Input\t\t\tnativeWindow                The native window to destroy\n @Description\tReleases all resources allocated by the windowing system\n*******************************************************************************************************************************************/\nvoid ReleaseNativeResources(Display* nativeDisplay, Window nativeWindow) \n{\n\t// Destroy the window\n\tif (nativeWindow)\n\t{\n\t\tXDestroyWindow(nativeDisplay, nativeWindow);\n\t}\n\n\t// Release the display.\n\tif (nativeDisplay)\n\t{\n\t\tXCloseDisplay(nativeDisplay);\n\t}\n}\n\n/*!*****************************************************************************************************************************************\n @Function\t\tmain\n @Input\t\t\targc                        Number of arguments passed to the application, ignored.\n @Input\t\t\targv           Command line strings passed to the application, ignored.\n @Return\t\tResult code to send to the Operating System\n @Description\tMain function of the program, executes other functions.\n*******************************************************************************************************************************************/\nint main(int /*argc*/, char **/*argv*/)\n{\n\t// X11 variables\n\tDisplay* nativeDisplay = NULL;\n\tWindow nativeWindow = 0;\n\n\t// EGL variables\n\tEGLDisplay\t\t\teglDisplay = NULL;\n\tEGLConfig\t\t\teglConfig = NULL;\n\tEGLSurface\t\t\teglSurface = NULL;\n\tEGLContext\t\t\teglContext = NULL;\n\n\t// Handles for the two shaders used to draw the triangle, and the program handle which combines them.\n\tGLuint fragmentShader = 0, vertexShader = 0;\n\tGLuint shaderProgram = 0;\n\n\t// A vertex buffer object to store our model data.\n\tGLuint vertexBuffer = 0;\n\n\t// Get access to a native display\n\tif (!CreateNativeDisplay(&nativeDisplay))\n\t{\n\t\tgoto cleanup;\n\t}\n\t\n\t// Setup the windowing system, create a window\n\tif (!CreateNativeWindow(nativeDisplay, &nativeWindow))\n\t{\n\t\tgoto cleanup;\n\t}\n\t\n\t// Create and Initialise an EGLDisplay from the native display\n\tif (!CreateEGLDisplay(nativeDisplay, eglDisplay))\n\t{\n\t\tgoto cleanup;\n\t}\n\n\t// Choose an EGLConfig for the application, used when setting up the rendering surface and EGLContext\n\tif (!ChooseEGLConfig(eglDisplay, eglConfig))\n\t{\n\t\tgoto cleanup;\n\t}\n\n\t// Create an EGLSurface for rendering from the native window\n\tif (!CreateEGLSurface(nativeWindow, eglDisplay, eglConfig, eglSurface))\n\t{\n\t\tgoto cleanup;\n\t}\n\n\t// Setup the EGL Context from the other EGL constructs created so far, so that the application is ready to submit OpenGL ES commands\n\tif (!SetupEGLContext(eglDisplay, eglConfig, eglSurface, eglContext))\n\t{\n\t\tgoto cleanup;\n\t}\n\n\t// Initialise the vertex data in the application\n\tif (!InitialiseBuffer(vertexBuffer))\n\t{\n\t\tgoto cleanup;\n\t}\t\n\t\n\t// Initialise the fragment and vertex shaders used in the application\n\tif (!InitialiseShaders(fragmentShader, vertexShader, shaderProgram))\n\t{\n\t\tgoto cleanup;\n\t}\n\t\n\t// Renders a triangle for 800 frames using the state setup in the previous function\n\tfor (int i = 0; i < 800; ++i)\n\t{\n\t\tif (!RenderScene(shaderProgram, eglDisplay, eglSurface, nativeDisplay))\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t// Release any resources we created in the Initialise functions\n\tDeInitialiseGLState(fragmentShader, vertexShader, shaderProgram, vertexBuffer);\n\ncleanup:\n\t// Release the EGL State\n\tReleaseEGLState(eglDisplay);\n\n\t// Release the windowing system resources\n\tReleaseNativeResources(nativeDisplay, nativeWindow);\n\n\t// Destroy the eglWindow\n\treturn 0;\n}\n\n/*******************************************************************************************************************************************\n End of file (OGLES2HelloAPI_LinuxX11.cpp)\n*******************************************************************************************************************************************/\n```\n\n## \u30d3\u30eb\u30c9&\u5b9f\u884c\n```\n$ g++ OGLES2HelloAPI_LinuxX11.cpp -lEGL -lGLESv2 -lX11\n$ ./a.out\n```\n\n\u74b0\u5883: Ubuntu 12.04\n\n## \u5b9f\u884c\u7d50\u679c\n![Screenshot_from_2015-02-01 21:57:32.png](https://qiita-image-store.s3.amazonaws.com/0/35514/6c168aa5-2481-892f-fa50-91b2509d01d6.png)\n\n\n\n# \u6bd4\u8f03\n\n\u4e09\u8005\u306e\u6bd4\u8f03\u3092\u3057\u307e\u3059\u3002\n\u79c1\u304c\u601d\u3046\u7c21\u5358\u306a\u9806\u306f Three.js -> WebGL -> OpenGL ES \u306a\u306e\u3067\u3001\u305d\u306e\u9006\u306e\n\n* \u300cOpenGL ES \u3068 WebGL\u300d\n* \u300cWebGL \u3068 Three.js\u300d\n\n\u306e\u9806\u306b\u6bd4\u8f03\u3057\u307e\u3059\u3002\n\n\n## OpenGL ES \u3068 WebGL \n\u4e00\u756a\u5927\u304d\u306a\u9055\u3044\u306f\u3001 \u521d\u671f\u5316\u90e8\u5206\uff08\u4e09\u89d2\u5f62\u3092\u63cf\u304f\u524d\u307e\u3067\u3001\u7279\u306b\u63cf\u753b\u9818\u57df\u3092\u4f5c\u308b\u307e\u3067\uff09\u304c WebGL \u306e\u65b9\u304c\u7c21\u5358\u3001\u3068\u3044\u3046\u3053\u3068\u3067\u3057\u3087\u3046\u304b\u3002\n\nOpenGL ES: X \u3084 EGL \u3092\u4f7f\u7528\u3057 Display \u3092\u53d6\u5f97\u3057\u305f\u308a Window \u3092\u751f\u6210\u3057\u305f\u308a\u3001 Surface \u3092\u751f\u6210\u3057\u305f\u308a\u3002\nWebGL: \u57fa\u672c\u7684\u306b\u306f Canvas \u30bf\u30b0\u4e00\u500b\u4f5c\u308b\u306e\u307f\n\nNative \u3067\u3042\u308c\u3070\u30a6\u30a4\u30f3\u30c9\u30a6\u306f\u4f55\u3067\u4f5c\u3089\u308c\u3066\u3044\u308b\u304b\u74b0\u5883\u4f9d\u5b58\u3067\u3059\u304c\u3001 WebGL \u3067\u3042\u308c\u3070\u5b9f\u884c\u74b0\u5883\u306f\u5e83\u3044\u610f\u5473\u306e\u30d6\u30e9\u30a6\u30b61\u3064\u306e\u307f\u306a\u306e\u3067\u3001Canvas \u30bf\u30b0\u3067\u4e00\u767a\u3001\u3068\u3044\u3046\u3053\u3068\u3067\u3059\u306d\u3002\n\n\u3068\u3044\u3046\u8a33\u3067\u65e9\u304f\u304a\u7d75\u63cf\u304d\u51fa\u6765\u308b\u3088\u3046\u306b\u306a\u308a\u307e\u3057\u305f\u3002\n\u305d\u306e\u5f8c\u306e GL API \u306e\u547c\u3073\u51fa\u3057\u306f\u3056\u3063\u304f\u308a\u5927\u304d\u304f\u306f\u5909\u308f\u308a\u307e\u305b\u3093\u3002\n\n## WebGL \u3068 Three.js\nWebGL \u3068 Three.js \u306e\u9055\u3044\u306f\u3001\u4f7f\u7528\u3059\u308b GL API \u306e\u6570\u304c Three.js \u306e\u65b9\u304c\u5c11\u306a\u3044\u3001\u3068\u3044\u3046\u3068\u3053\u308d\u3067\u3057\u3087\u3046\u304b\u3002\nWebGL \u3067\u7d75\u3092\u63cf\u304f\u3068\u304d\u306b\u304a\u6c7a\u307e\u308a\u306e\u3088\u3046\u306b GL API \u3092\u8907\u6570\u547c\u3073\u51fa\u3057\u521d\u671f\u5316\u3057\u307e\u3059\u304c\u3001Three.js \u306f\u305d\u306e\u90e8\u5206\u3092\u30e9\u30c3\u30d7\u3057\u3001\u304a\u4f5c\u6cd5\u90e8\u5206\u3092\u80a9\u4ee3\u308f\u308a\u3057\u3066\u304f\u308c\u307e\u3059\u3002\n\nWebGL \u3060\u3068\u3001gl.createBuffer \u3067 Buffer \u30aa\u30d6\u30b8\u30a7\u30af\u30c8\u3092\u4f5c\u308a\u3001gl.bindBuffer \u3057\u3001gl.createShader \u3068 gl.shaderSource \u3067\u30b7\u30a7\u30fc\u30c0\u3092\u4f5c\u308a\u3001 gl.compileShader \u3057\u3066\u3001 gl.createProgram, gl.attachShader, gl.linkProgram \u3067\u30b7\u30a7\u30fc\u30c0\u30d7\u30ed\u30b0\u30e9\u30e0\u3092\u4f5c\u308a\u3001\u3001\u3001 \u3042\u308c\u3001\u4e09\u89d2\u5f62\u63cf\u304d\u305f\u3044\u3060\u3051\u306a\u306e\u306b\u307e\u3060\u63cf\u304d\u59cb\u3081\u3089\u308c\u306a\u3044\u3001\u3001\u3001\n\u3068\u3044\u3046\u3068\u3053\u308d\u304c\u3001Three.js \u3060\u3068\u300cRenderer \u4f5c\u3063\u3066 camera \u4f5c\u3063\u3066 scene \u4f5c\u3063\u3066\u3001\u306f\u3044\u4e09\u89d2\u5f62\u304b\u3051\u308b\u3088\uff01\u300d\u3068\u306a\u308a\u7c21\u5358\u3067\u3059\u3002\n\n# \u307e\u3068\u3081\nThree.js \u3068 WebGL \u3068 OpenGL ES \u3067\u4e09\u89d2\u5f62\u3092\u63cf\u3044\u3066\u307f\u307e\u3057\u305f\u3002\nOpenGL ES -> WebGL -> Three.js \u3068\u9032\u3080\u6bce\u306b\u521d\u671f\u5316\u91cf\u304c\u6e1b\u308a\u3001\u5b9f\u969b\u306e\u63cf\u753b\uff08\u4eca\u56de\u306f\u4e09\u89d2\u5f62\uff09\u306b\u3059\u3050\u53d6\u308a\u304b\u304b\u308c\u308b\u3088\u3046\u306b\u306a\u308a\u307e\u3059\u3002\n\n\n# \u53c2\u8003\n\nWebGL: [WebGL Pre-Tutorial, Part 2: Drawing a 2d Triangle](http://my2iu.blogspot.jp/2011/11/webgl-pre-tutorial-part-2-drawing-2d.html)\n\nThree.js: [Three.js\u3067\u3044\u308d\u3044\u308d\u306a\u56f3\u5f62\u3092\u63cf\u3044\u3066\u307f\u308b](http://www.mwsoft.jp/programming/webgl/geometry.html)\n\nWebGL: [powervr-graphics/WebGL_SDK](https://github.com/powervr-graphics/WebGL_SDK)\n\nOpenGL ES: [powervr-graphics/Native_SDK](https://github.com/powervr-graphics/Native_SDK/blob/3.4/Examples/Beginner/01_HelloAPI/OGLES2/OGLES2HelloAPI_LinuxX11.cpp)\n"}