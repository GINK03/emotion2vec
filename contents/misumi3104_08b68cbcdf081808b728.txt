{"context": "\u74b0\u5883\u306fwindows xp 32\n\u4ee5\u4e0b\u306e\u30b5\u30a4\u30c8\u3092\u53c2\u8003\u306b\u3057\u307e\u3057\u305f\nhttp://tacoika.blog87.fc2.com/blog-entry-322.html\nhttp://d.hatena.ne.jp/yano-htn/20120226/1330263041\nCMake\u3092\u4f7f\u308f\u305a\u7528\u610f\u3055\u308c\u3066\u3044\u308bsln\u3067\u30b3\u30f3\u30d1\u30a4\u30eb\u3059\u308b\u3053\u3068\u3092\u304a\u52e7\u3081\u3057\u307e\u3059\u3002CMake\u306f\u7d20\u4eba\u304c\u89e6\u308c\u3070\u30ea\u30f3\u30af\u30a8\u30e9\u30fc\u306e\u5b9d\u5eab\u3067\u3059\n\n\u57fa\u672c\n\nmain.cpp\n/* -*- coding:utf-8 -*- */\n\n/**\n * sdl_with_opengl.cpp\n */\n#pragma comment(lib, \"SDL2.lib\")\n#pragma comment(lib, \"SDL2main.lib\")\n#pragma comment(lib,\"opengl32.lib\")\n#pragma comment(lib,\"glu32.lib\")\n\n#include <SDL.h>\n#include <SDL_opengl.h>\n#include <GL/glu.h>\n\n#include <iostream>\n#include <string>\n\n#include <cmath>\n\nstatic const std::string WINDOW_CAPTION = \"SDL with OpenGL\";\nstatic const Uint32 WINDOW_WIDTH = 640;\nstatic const Uint32 WINDOW_HEIGHT = 480;\nstatic const Uint32 WINDOW_BPP = 32;\n\nstatic const Uint32 FPS = 60;\n\nstatic SDL_Window* window;\nstatic SDL_GLContext context;\n\nbool init();\nbool finalize();\n\nvoid update();\nvoid draw();\nbool pollingEvent();\n\nint main(int argc, char *argv[]) {\n    // initialize\n    if (!init()) {\n        std::cerr << \"ERROR: failed to initialize SDL\" << std::endl;\n        exit(1);\n    }\n\n    // mainloop\n    static const Uint32 interval = 1000 / FPS;\n    static Uint32 nextTime = SDL_GetTicks() + interval;\n    bool skipDraw = false;\n    while (true) {\n        // check event\n        if (!pollingEvent()) break;\n\n        // update and draw\n        update();\n        if (!skipDraw) {\n            draw();\n            SDL_GL_SwapWindow(window);\n        }\n\n        int delayTime = (int)(nextTime - SDL_GetTicks());\n        if (delayTime > 0) {\n            SDL_Delay((Uint32)delayTime);\n            skipDraw = false;\n        } else {\n            // skip next draw step because of no time\n            skipDraw = true;\n        }\n\n        nextTime += interval;\n    }\n\n    // finalize\n    finalize();\n\n    return 0;\n}\n\nbool init() {\n    // initialize SDL\n    if( SDL_Init(SDL_INIT_VIDEO) < 0 ) return false;\n\n    // enable double buffering\n    SDL_GL_SetAttribute(SDL_GL_DOUBLEBUFFER, 1);\n\n    // create indow\n    // set SDL_WINDOW_OPENGL to use opengl for drawing\n    window = SDL_CreateWindow(WINDOW_CAPTION.c_str(),\n                              SDL_WINDOWPOS_CENTERED, SDL_WINDOWPOS_CENTERED,\n                              WINDOW_WIDTH, WINDOW_HEIGHT,\n                              SDL_WINDOW_OPENGL);\n    if (!window) return false;\n\n    // create OpenGL context\n    context = SDL_GL_CreateContext(window);\n    if (!context) return false;\n\n    // setup viewport\n    glViewport(0, 0, WINDOW_WIDTH, WINDOW_HEIGHT);\n    glClearColor(0.0f, 0.0f, 0.0f, 0.0f);\n    glEnable(GL_DEPTH_TEST);\n\n    // setup projection matrix\n    glMatrixMode(GL_PROJECTION);\n    glLoadIdentity();\n    gluPerspective(45.0, (GLdouble) WINDOW_WIDTH / (GLdouble) WINDOW_HEIGHT, 2.0, 200.0);\n\n    // setup light\n    static GLfloat position[] = {-10.0f, 10.0f, 10.0f, 1.0f};\n    static GLfloat ambient [] = { 1.0f, 1.0f, 1.0f, 1.0f};\n    static GLfloat diffuse [] = { 1.0f, 1.0f, 1.0f, 1.0f};\n    static GLfloat specular[] = { 0.0f, 0.0f, 0.0f, 0.0f};\n    glLightfv(GL_LIGHT0, GL_POSITION, position);\n    glLightfv(GL_LIGHT0, GL_AMBIENT, ambient);\n    glLightfv(GL_LIGHT0, GL_DIFFUSE, diffuse);\n    glLightfv(GL_LIGHT0, GL_SPECULAR, specular);\n    glLightModelf(GL_LIGHT_MODEL_LOCAL_VIEWER, GL_TRUE);\n    glEnable(GL_LIGHTING);\n    glEnable(GL_LIGHT0);\n\n    return true;\n}\n\nbool finalize() {\n  // finalize SDL\n  SDL_Quit();\n\n  return true;\n}\n\nvoid update() {\n}\n\nvoid draw() {\n    // clear\n    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);\n\n    // setup view\n    glMatrixMode(GL_MODELVIEW);\n    glLoadIdentity();\n    gluLookAt( 0.0f,  0.0f,-30.0f,\n               0.0f,  0.0f, 0.0f,\n               0.0f, -1.0f, 0.0f);\n\n    // setup material\n    GLfloat ambient  [] = { 0.1f, 0.1f, 0.1f, 1.0f};\n    GLfloat diffuse  [] = { 1.0f, 0.0f, 0.0f, 1.0f};\n    GLfloat specular [] = { 1.0f, 1.0f, 1.0f, 1.0f};\n    GLfloat shininess[] = { 0.0f};\n    glMaterialfv(GL_FRONT, GL_AMBIENT, ambient);\n    glMaterialfv(GL_FRONT, GL_DIFFUSE, diffuse);\n    glMaterialfv(GL_FRONT, GL_SPECULAR, specular);\n    glMaterialfv(GL_FRONT, GL_SHININESS, shininess);\n\n    // draw sphere\n    GLUquadric* quadric = gluNewQuadric();\n    gluSphere(quadric, 10.0, 30, 30);\n    gluDeleteQuadric(quadric);\n}\n\n// polling event and execute actions\nbool pollingEvent()\n{\n    SDL_Event ev;\n    SDL_Keycode key;\n    while ( SDL_PollEvent(&ev) )\n    {\n        switch(ev.type){\n        case SDL_QUIT:\n            // raise when exit event is occur\n            return false;\n            break;\n        case SDL_KEYDOWN:\n        // raise when key down\n        {\n            key = ev.key.keysym.sym;\n            // ESC\n            if(key == SDLK_ESCAPE){\n                return false;\n            }\n        }\n        break;\n        }\n    }\n    return true;\n}\n\n\n\n\u5206\u96e2(\u3084\u3063\u3066\u308b\u3053\u3068\u306f\u57fa\u672c\u3068\u540c\u3058)\n\u5197\u9577\u3060\u304b\u3089SDL\u3068opengl\u306e\u7d50\u5408\u90e8\u5206\u3092\u30af\u30e9\u30b9\u306b\u3057\u3066\u96a0\u853d\u3057\u305f\u3002\n\u3053\u306esdlgl\u3092\u7d99\u627f\u3057\u3066draw\u306e\u4e2d\u8eab\u3060\u3051\u3092\u66f8\u3051\u3070\u3044\u3044\u3002\n\nsdlgl.h\n#pragma once\n#pragma comment(lib,\"SDL2.lib\")\n#pragma comment(lib,\"SDL2main.lib\")\n#pragma comment(lib,\"opengl32.lib\")\n#pragma comment(lib,\"glu32.lib\")\n#include <SDL.h>\n#include <SDL_opengl.h>\n#include <GL/glu.h>\n\nclass   SDLGL{\n    void    setview(int w,int h){\n        // setup viewport&projection\n        glClearColor(0.0f, 0.0f, 0.0f, 0.0f);\n        glEnable(GL_DEPTH_TEST);\n        glViewport(0, 0, w, h);\n        glMatrixMode(GL_PROJECTION);\n        glLoadIdentity();\n        perspective(w,h);\n        //glOrtho(0 , w , h , 0 , 2 , 200);\n    }\n    bool finalize() {\n      // finalize SDL\n      SDL_Quit();\n      return true;\n    }\n    // polling event and execute actions\n    bool pollingEvent(){\n        SDL_Event ev;\n        SDL_Keycode key;\n        while ( SDL_PollEvent(&ev) )\n        {\n            switch(ev.type){\n                case    SDL_WINDOWEVENT:\n                    if(ev.window.event==SDL_WINDOWEVENT_RESIZED)setview(ev.window.data1,ev.window.data2);\n                    break;\n                case    SDL_QUIT:\n                    // raise when exit event is occur\n                    return false;\n                    break;\n                case SDL_KEYDOWN:\n                // raise when key down\n                {\n                    key = ev.key.keysym.sym;\n                    // ESC\n                    if(key == SDLK_ESCAPE){\n                        return false;\n                    }\n                }\n                break;\n            }\n        }\n        return true;\n    }\npublic:\n    signed  start(char*title,int w=600,int h=400){\n        SDL_Window* window;\n        SDL_GLContext context;\n        // initialize SDL\n        if( SDL_Init(SDL_INIT_VIDEO) < 0 ) return false;\n\n        // enable double buffering\n        SDL_GL_SetAttribute(SDL_GL_DOUBLEBUFFER, 1);\n\n        // create indow\n        // set SDL_WINDOW_OPENGL to use opengl for drawing\n        window = SDL_CreateWindow(title,\n                                  SDL_WINDOWPOS_CENTERED, SDL_WINDOWPOS_CENTERED,\n                                  w, h,\n                                  SDL_WINDOW_OPENGL|SDL_WINDOW_RESIZABLE);\n        if (!window)return 1;\n\n        // create OpenGL context\n        context = SDL_GL_CreateContext(window);\n        if (!context)return 1;\n\n        // setup viewport&projection\n        setview(w, h);\n\n        // setup light\n        static GLfloat position[] = {-10.0f, 10.0f, 10.0f, 1.0f};\n        static GLfloat ambient [] = { 1.0f, 1.0f, 1.0f, 1.0f};\n        static GLfloat diffuse [] = { 1.0f, 1.0f, 1.0f, 1.0f};\n        static GLfloat specular[] = { 0.0f, 0.0f, 0.0f, 0.0f};\n        glLightfv(GL_LIGHT0, GL_POSITION, position);\n        glLightfv(GL_LIGHT0, GL_AMBIENT, ambient);\n        glLightfv(GL_LIGHT0, GL_DIFFUSE, diffuse);\n        glLightfv(GL_LIGHT0, GL_SPECULAR, specular);\n        glLightModelf(GL_LIGHT_MODEL_LOCAL_VIEWER, GL_TRUE);\n        glEnable(GL_LIGHTING);\n        glEnable(GL_LIGHT0);\n\n        // mainloop\n        while (true) {\n            // check event\n            if (!pollingEvent()) break;\n            //draw\n            glClear(GL_COLOR_BUFFER_BIT|GL_DEPTH_BUFFER_BIT);\n            draw();\n            SDL_GL_SwapWindow(window);\n        }\n\n        // finalize\n        finalize();\n        return  0;\n    }\n    virtual void    draw(){\n        // setup view\n        glMatrixMode(GL_MODELVIEW);\n        glLoadIdentity();\n        gluLookAt( 0.0f,  0.0f,-30.0f,\n                   0.0f,  0.0f, 0.0f,\n                   0.0f, -1.0f, 0.0f);\n\n        // setup material\n        GLfloat ambient  [] = { 0.1f, 0.1f, 0.1f, 1.0f};\n        GLfloat diffuse  [] = { 1.0f, 0.0f, 0.0f, 1.0f};\n        GLfloat specular [] = { 1.0f, 1.0f, 1.0f, 1.0f};\n        GLfloat shininess[] = { 0.0f};\n        glMaterialfv(GL_FRONT, GL_AMBIENT, ambient);\n        glMaterialfv(GL_FRONT, GL_DIFFUSE, diffuse);\n        glMaterialfv(GL_FRONT, GL_SPECULAR, specular);\n        glMaterialfv(GL_FRONT, GL_SHININESS, shininess);\n\n        // draw sphere\n        GLUquadric* quadric = gluNewQuadric();\n        gluSphere(quadric, 10.0, 30, 30);\n        gluDeleteQuadric(quadric);\n    }\n    virtual void    perspective(int w,int h){\n        gluPerspective(45.0, (GLdouble) w / (GLdouble) h, 2.0, 200.0);\n    }\n};\n\n\n\nmain.cpp\n#include\"sdlgl.h\"\n\nstruct  MYSDLGL:public  SDLGL{\n    virtual void    perspective(int w,int h){\n        gluPerspective(45.0, (GLdouble) w / (GLdouble) h, 2.0, 200.0);\n    }\n    virtual void    draw(){\n        // setup view\n        glMatrixMode(GL_MODELVIEW);\n        glLoadIdentity();\n        gluLookAt( 0.0f,  0.0f,-30.0f,\n                   0.0f,  0.0f, 0.0f,\n                   0.0f, -1.0f, 0.0f);\n\n        // setup material\n        GLfloat ambient  [] = { 0.1f, 0.1f, 0.1f, 1.0f};\n        GLfloat diffuse  [] = { 1.0f, 0.0f, 0.0f, 1.0f};\n        GLfloat specular [] = { 1.0f, 1.0f, 1.0f, 1.0f};\n        GLfloat shininess[] = { 0.0f};\n        glMaterialfv(GL_FRONT, GL_AMBIENT, ambient);\n        glMaterialfv(GL_FRONT, GL_DIFFUSE, diffuse);\n        glMaterialfv(GL_FRONT, GL_SPECULAR, specular);\n        glMaterialfv(GL_FRONT, GL_SHININESS, shininess);\n\n        // draw sphere\n        GLUquadric* quadric = gluNewQuadric();\n        gluSphere(quadric, 10.0, 30, 30);\n        gluDeleteQuadric(quadric);\n    }\n};\nint main(int argc, char *argv[]){\n    MYSDLGL gl;\n    gl.start(\"nemui\");\n    return  0;\n}\n\n\n\u74b0\u5883\u306fwindows xp 32\n\u4ee5\u4e0b\u306e\u30b5\u30a4\u30c8\u3092\u53c2\u8003\u306b\u3057\u307e\u3057\u305f\nhttp://tacoika.blog87.fc2.com/blog-entry-322.html\nhttp://d.hatena.ne.jp/yano-htn/20120226/1330263041\nCMake\u3092\u4f7f\u308f\u305a\u7528\u610f\u3055\u308c\u3066\u3044\u308bsln\u3067\u30b3\u30f3\u30d1\u30a4\u30eb\u3059\u308b\u3053\u3068\u3092\u304a\u52e7\u3081\u3057\u307e\u3059\u3002CMake\u306f\u7d20\u4eba\u304c\u89e6\u308c\u3070\u30ea\u30f3\u30af\u30a8\u30e9\u30fc\u306e\u5b9d\u5eab\u3067\u3059\n\n#\u57fa\u672c\n\n```cpp:main.cpp\n/* -*- coding:utf-8 -*- */\n\n/**\n * sdl_with_opengl.cpp\n */\n#pragma comment(lib, \"SDL2.lib\")\n#pragma comment(lib, \"SDL2main.lib\")\n#pragma comment(lib,\"opengl32.lib\")\n#pragma comment(lib,\"glu32.lib\")\n\n#include <SDL.h>\n#include <SDL_opengl.h>\n#include <GL/glu.h>\n\n#include <iostream>\n#include <string>\n\n#include <cmath>\n\nstatic const std::string WINDOW_CAPTION = \"SDL with OpenGL\";\nstatic const Uint32 WINDOW_WIDTH = 640;\nstatic const Uint32 WINDOW_HEIGHT = 480;\nstatic const Uint32 WINDOW_BPP = 32;\n\nstatic const Uint32 FPS = 60;\n\nstatic SDL_Window* window;\nstatic SDL_GLContext context;\n\nbool init();\nbool finalize();\n\nvoid update();\nvoid draw();\nbool pollingEvent();\n\nint main(int argc, char *argv[]) {\n    // initialize\n    if (!init()) {\n        std::cerr << \"ERROR: failed to initialize SDL\" << std::endl;\n        exit(1);\n    }\n\n    // mainloop\n    static const Uint32 interval = 1000 / FPS;\n    static Uint32 nextTime = SDL_GetTicks() + interval;\n    bool skipDraw = false;\n    while (true) {\n        // check event\n        if (!pollingEvent()) break;\n\n        // update and draw\n        update();\n        if (!skipDraw) {\n            draw();\n            SDL_GL_SwapWindow(window);\n        }\n\n        int delayTime = (int)(nextTime - SDL_GetTicks());\n        if (delayTime > 0) {\n            SDL_Delay((Uint32)delayTime);\n            skipDraw = false;\n        } else {\n            // skip next draw step because of no time\n            skipDraw = true;\n        }\n\n        nextTime += interval;\n    }\n\n    // finalize\n    finalize();\n  \n    return 0;\n}\n\nbool init() {\n    // initialize SDL\n    if( SDL_Init(SDL_INIT_VIDEO) < 0 ) return false;\n\n    // enable double buffering\n    SDL_GL_SetAttribute(SDL_GL_DOUBLEBUFFER, 1);\n\n    // create indow\n    // set SDL_WINDOW_OPENGL to use opengl for drawing\n    window = SDL_CreateWindow(WINDOW_CAPTION.c_str(),\n                              SDL_WINDOWPOS_CENTERED, SDL_WINDOWPOS_CENTERED,\n                              WINDOW_WIDTH, WINDOW_HEIGHT,\n                              SDL_WINDOW_OPENGL);\n    if (!window) return false;\n\n    // create OpenGL context\n    context = SDL_GL_CreateContext(window);\n    if (!context) return false;\n\n    // setup viewport\n    glViewport(0, 0, WINDOW_WIDTH, WINDOW_HEIGHT);\n    glClearColor(0.0f, 0.0f, 0.0f, 0.0f);\n    glEnable(GL_DEPTH_TEST);\n\n    // setup projection matrix\n    glMatrixMode(GL_PROJECTION);\n    glLoadIdentity();\n    gluPerspective(45.0, (GLdouble) WINDOW_WIDTH / (GLdouble) WINDOW_HEIGHT, 2.0, 200.0);\n\n    // setup light\n    static GLfloat position[] = {-10.0f, 10.0f, 10.0f, 1.0f};\n    static GLfloat ambient [] = { 1.0f, 1.0f, 1.0f, 1.0f};\n    static GLfloat diffuse [] = { 1.0f, 1.0f, 1.0f, 1.0f};\n    static GLfloat specular[] = { 0.0f, 0.0f, 0.0f, 0.0f};\n    glLightfv(GL_LIGHT0, GL_POSITION, position);\n    glLightfv(GL_LIGHT0, GL_AMBIENT, ambient);\n    glLightfv(GL_LIGHT0, GL_DIFFUSE, diffuse);\n    glLightfv(GL_LIGHT0, GL_SPECULAR, specular);\n    glLightModelf(GL_LIGHT_MODEL_LOCAL_VIEWER, GL_TRUE);\n    glEnable(GL_LIGHTING);\n    glEnable(GL_LIGHT0);\n\n    return true;\n}\n\nbool finalize() {\n  // finalize SDL\n  SDL_Quit();\n\n  return true;\n}\n\nvoid update() {\n}\n\nvoid draw() {\n    // clear\n    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);\n\n    // setup view\n    glMatrixMode(GL_MODELVIEW);\n    glLoadIdentity();\n    gluLookAt( 0.0f,  0.0f,-30.0f,\n               0.0f,  0.0f, 0.0f,\n               0.0f, -1.0f, 0.0f);\n\n    // setup material\n    GLfloat ambient  [] = { 0.1f, 0.1f, 0.1f, 1.0f};\n    GLfloat diffuse  [] = { 1.0f, 0.0f, 0.0f, 1.0f};\n    GLfloat specular [] = { 1.0f, 1.0f, 1.0f, 1.0f};\n    GLfloat shininess[] = { 0.0f};\n    glMaterialfv(GL_FRONT, GL_AMBIENT, ambient);\n    glMaterialfv(GL_FRONT, GL_DIFFUSE, diffuse);\n    glMaterialfv(GL_FRONT, GL_SPECULAR, specular);\n    glMaterialfv(GL_FRONT, GL_SHININESS, shininess);\n\n    // draw sphere\n    GLUquadric* quadric = gluNewQuadric();\n    gluSphere(quadric, 10.0, 30, 30);\n    gluDeleteQuadric(quadric);\n}\n\n// polling event and execute actions\nbool pollingEvent()\n{\n    SDL_Event ev;\n    SDL_Keycode key;\n    while ( SDL_PollEvent(&ev) )\n    {\n        switch(ev.type){\n        case SDL_QUIT:\n            // raise when exit event is occur\n            return false;\n            break;\n        case SDL_KEYDOWN:\n        // raise when key down\n        {\n            key = ev.key.keysym.sym;\n            // ESC\n            if(key == SDLK_ESCAPE){\n                return false;\n            }\n        }\n        break;\n        }\n    }\n    return true;\n}\n```\n\n#\u5206\u96e2(\u3084\u3063\u3066\u308b\u3053\u3068\u306f\u57fa\u672c\u3068\u540c\u3058)\n\u5197\u9577\u3060\u304b\u3089SDL\u3068opengl\u306e\u7d50\u5408\u90e8\u5206\u3092\u30af\u30e9\u30b9\u306b\u3057\u3066\u96a0\u853d\u3057\u305f\u3002\n\u3053\u306esdlgl\u3092\u7d99\u627f\u3057\u3066draw\u306e\u4e2d\u8eab\u3060\u3051\u3092\u66f8\u3051\u3070\u3044\u3044\u3002\n\n```cpp:sdlgl.h\n#pragma\tonce\n#pragma comment(lib,\"SDL2.lib\")\n#pragma comment(lib,\"SDL2main.lib\")\n#pragma comment(lib,\"opengl32.lib\")\n#pragma comment(lib,\"glu32.lib\")\n#include <SDL.h>\n#include <SDL_opengl.h>\n#include <GL/glu.h>\n\nclass\tSDLGL{\n\tvoid\tsetview(int w,int h){\n\t\t// setup viewport&projection\n\t\tglClearColor(0.0f, 0.0f, 0.0f, 0.0f);\n\t\tglEnable(GL_DEPTH_TEST);\n\t\tglViewport(0, 0, w, h);\n\t\tglMatrixMode(GL_PROJECTION);\n\t\tglLoadIdentity();\n\t\tperspective(w,h);\n\t\t//glOrtho(0 , w , h , 0 , 2 , 200);\n\t}\n\tbool finalize() {\n\t  // finalize SDL\n\t  SDL_Quit();\n\t  return true;\n\t}\n\t// polling event and execute actions\n\tbool pollingEvent(){\n\t\tSDL_Event ev;\n\t\tSDL_Keycode key;\n\t\twhile ( SDL_PollEvent(&ev) )\n\t\t{\n\t\t\tswitch(ev.type){\n\t\t\t\tcase\tSDL_WINDOWEVENT:\n\t\t\t\t\tif(ev.window.event==SDL_WINDOWEVENT_RESIZED)setview(ev.window.data1,ev.window.data2);\n\t\t\t\t\tbreak;\n\t\t\t\tcase\tSDL_QUIT:\n\t\t\t\t\t// raise when exit event is occur\n\t\t\t\t\treturn false;\n\t\t\t\t\tbreak;\n\t\t\t\tcase SDL_KEYDOWN:\n\t\t\t\t// raise when key down\n\t\t\t\t{\n\t\t\t\t\tkey = ev.key.keysym.sym;\n\t\t\t\t\t// ESC\n\t\t\t\t\tif(key == SDLK_ESCAPE){\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\npublic:\n\tsigned\tstart(char*title,int w=600,int h=400){\n\t\tSDL_Window* window;\n\t\tSDL_GLContext context;\n\t\t// initialize SDL\n\t\tif( SDL_Init(SDL_INIT_VIDEO) < 0 ) return false;\n\n\t\t// enable double buffering\n\t\tSDL_GL_SetAttribute(SDL_GL_DOUBLEBUFFER, 1);\n\n\t\t// create indow\n\t\t// set SDL_WINDOW_OPENGL to use opengl for drawing\n\t\twindow = SDL_CreateWindow(title,\n\t\t\t\t\t\t\t\t  SDL_WINDOWPOS_CENTERED, SDL_WINDOWPOS_CENTERED,\n\t\t\t\t\t\t\t\t  w, h,\n\t\t\t\t\t\t\t\t  SDL_WINDOW_OPENGL|SDL_WINDOW_RESIZABLE);\n\t\tif (!window)return 1;\n\n\t\t// create OpenGL context\n\t\tcontext = SDL_GL_CreateContext(window);\n\t\tif (!context)return 1;\n\n\t\t// setup viewport&projection\n\t\tsetview(w, h);\n\n\t\t// setup light\n\t\tstatic GLfloat position[] = {-10.0f, 10.0f, 10.0f, 1.0f};\n\t\tstatic GLfloat ambient [] = { 1.0f, 1.0f, 1.0f, 1.0f};\n\t\tstatic GLfloat diffuse [] = { 1.0f, 1.0f, 1.0f, 1.0f};\n\t\tstatic GLfloat specular[] = { 0.0f, 0.0f, 0.0f, 0.0f};\n\t\tglLightfv(GL_LIGHT0, GL_POSITION, position);\n\t\tglLightfv(GL_LIGHT0, GL_AMBIENT, ambient);\n\t\tglLightfv(GL_LIGHT0, GL_DIFFUSE, diffuse);\n\t\tglLightfv(GL_LIGHT0, GL_SPECULAR, specular);\n\t\tglLightModelf(GL_LIGHT_MODEL_LOCAL_VIEWER, GL_TRUE);\n\t\tglEnable(GL_LIGHTING);\n\t\tglEnable(GL_LIGHT0);\n\n\t\t// mainloop\n\t\twhile (true) {\n\t\t\t// check event\n\t\t\tif (!pollingEvent()) break;\n\t\t\t//draw\n\t\t    glClear(GL_COLOR_BUFFER_BIT|GL_DEPTH_BUFFER_BIT);\n\t\t\tdraw();\n\t\t\tSDL_GL_SwapWindow(window);\n\t\t}\n\n\t\t// finalize\n\t\tfinalize();\n\t\treturn\t0;\n\t}\n\tvirtual\tvoid\tdraw(){\n\t\t// setup view\n\t\tglMatrixMode(GL_MODELVIEW);\n\t\tglLoadIdentity();\n\t\tgluLookAt( 0.0f,  0.0f,-30.0f,\n\t\t\t\t   0.0f,  0.0f, 0.0f,\n\t\t\t\t   0.0f, -1.0f, 0.0f);\n\n\t\t// setup material\n\t\tGLfloat ambient  [] = { 0.1f, 0.1f, 0.1f, 1.0f};\n\t\tGLfloat diffuse  [] = { 1.0f, 0.0f, 0.0f, 1.0f};\n\t\tGLfloat specular [] = { 1.0f, 1.0f, 1.0f, 1.0f};\n\t\tGLfloat shininess[] = { 0.0f};\n\t\tglMaterialfv(GL_FRONT, GL_AMBIENT, ambient);\n\t\tglMaterialfv(GL_FRONT, GL_DIFFUSE, diffuse);\n\t\tglMaterialfv(GL_FRONT, GL_SPECULAR, specular);\n\t\tglMaterialfv(GL_FRONT, GL_SHININESS, shininess);\n\n\t\t// draw sphere\n\t\tGLUquadric* quadric = gluNewQuadric();\n\t\tgluSphere(quadric, 10.0, 30, 30);\n\t\tgluDeleteQuadric(quadric);\n\t}\n\tvirtual\tvoid\tperspective(int w,int h){\n\t\tgluPerspective(45.0, (GLdouble) w / (GLdouble) h, 2.0, 200.0);\n\t}\n};\n```\n\n```cpp:main.cpp\n#include\"sdlgl.h\"\n\nstruct\tMYSDLGL:public\tSDLGL{\n\tvirtual\tvoid\tperspective(int w,int h){\n\t\tgluPerspective(45.0, (GLdouble) w / (GLdouble) h, 2.0, 200.0);\n\t}\n\tvirtual\tvoid\tdraw(){\n\t\t// setup view\n\t\tglMatrixMode(GL_MODELVIEW);\n\t\tglLoadIdentity();\n\t\tgluLookAt( 0.0f,  0.0f,-30.0f,\n\t\t\t\t   0.0f,  0.0f, 0.0f,\n\t\t\t\t   0.0f, -1.0f, 0.0f);\n\n\t\t// setup material\n\t\tGLfloat ambient  [] = { 0.1f, 0.1f, 0.1f, 1.0f};\n\t\tGLfloat diffuse  [] = { 1.0f, 0.0f, 0.0f, 1.0f};\n\t\tGLfloat specular [] = { 1.0f, 1.0f, 1.0f, 1.0f};\n\t\tGLfloat shininess[] = { 0.0f};\n\t\tglMaterialfv(GL_FRONT, GL_AMBIENT, ambient);\n\t\tglMaterialfv(GL_FRONT, GL_DIFFUSE, diffuse);\n\t\tglMaterialfv(GL_FRONT, GL_SPECULAR, specular);\n\t\tglMaterialfv(GL_FRONT, GL_SHININESS, shininess);\n\n\t\t// draw sphere\n\t\tGLUquadric* quadric = gluNewQuadric();\n\t\tgluSphere(quadric, 10.0, 30, 30);\n\t\tgluDeleteQuadric(quadric);\n\t}\n};\nint main(int argc, char *argv[]){\n\tMYSDLGL\tgl;\n\tgl.start(\"nemui\");\n\treturn\t0;\n}\n```\n", "tags": ["OpenGL", "SDL2", "SDL"]}