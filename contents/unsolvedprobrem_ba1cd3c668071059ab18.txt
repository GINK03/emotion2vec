{"context": " More than 1 year has passed since last update.\n\n\u30d0\u30bf\u30d5\u30e9\u30a4\u6f14\u7b97\nFFT\u306f\u5206\u5272\u7d71\u6cbb\u6cd5\u306e\u4e00\u7a2e\u3067\u3059\u3002\u5165\u529b2n2n2^n\u500b\u306b\u5bfe\u3057\u3066\u30c7\u30fc\u30bf\u3092\u5165\u308c\u66ff\u3048\u306a\u304c\u3089\u6f14\u7b97\u3092\u9032\u3081\u3066\u3044\u304d\u307e\u3059\u3002\nn=3n = 3\u306e\u5834\u5408\u306f\u4ee5\u4e0b\u306e\u56f3\u306e\u69d8\u306b\u306a\u308a\u307e\u3059\u3002\n\n\u3053\u3053\u3067\u03c9\\omega\u306f\u4f53\u306e\u6027\u8cea\u3092\u6301\u3063\u305f\u96c6\u5408\u306e\u5143\u3067\u3001\u4fe1\u53f7\u51e6\u7406\u306e\u5834\u5408\u306f\u8907\u7d20\u5e73\u9762\u4e0a\u306e\u5358\u4f4d\u5186\u306e\u539f\u59cbnn\u4e57\u6839\u306b\u306a\u308a\u3001\u30e2\u30b8\u30e5\u30ed\u4ee3\u6570\u306e\u5834\u5408\u306f\u7d20\u6570p=2nk+1p = 2^nk + 1\u3092\u6210\u308a\u7acb\u305f\u305b\u308b\u6700\u5c0f\u306ekk\u306b\u5bfe\u3057nkmodpn^k \\bmod p\u306b\u306a\u308a\u307e\u3059\u3002\n\u3053\u308c\u3092\u30d0\u30bf\u30d5\u30e9\u30a4\u6f14\u7b97\u3068\u547c\u3073\u307e\u3059\u3002\n\u30d0\u30bf\u30d5\u30e9\u30a4\u6f14\u7b97\u306f\u6b21\u306e\u69d8\u306b\u518d\u5e30\u95a2\u6570\u3092\u7528\u3044\u3066\u5b9f\u88c5\u3055\u308c\u308b\u4e8b\u304c\u591a\u3044\u69d8\u3067\u3059\u3002\n\nrecursive-fft.cpp\n#include <iostream>\n#include <vector>\n#include <complex>\n#include <cmath>\n\nusing complex_t = std::complex<float>;\nusing seq = std::vector<complex_t>;\n\n// \u518d\u5e30FFT\ntemplate<bool Regular>\nseq rec_fft(const seq &a){\n    std::size_t n = a.size();\n    if(n == 1){\n        return a;\n    }\n    complex_t omega_n(std::cos(2.0 * M_PI / n), std::sin(2.0 * M_PI / n)), omega = 1.0;\n    seq A(n / 2), B(n / 2);\n    for(std::size_t i = 0; i < n / 2; ++i){\n        if(Regular){\n            A[i] = a[i * 2];\n            B[i] = a[i * 2 + 1];\n        }else{\n            A[i] = complex_t(a[i * 2].real(), -a[i * 2].imag());\n            B[i] = complex_t(a[i * 2 + 1].real(), -a[i * 2 + 1].imag());\n        }\n    }\n    A = rec_fft<true>(A);\n    B = rec_fft<true>(B);\n    seq r(n);\n    for(std::size_t i = 0; i < n / 2; ++i){\n        r[i] = A[i] + omega * B[i];\n        r[i + n / 2] = A[i] - omega * B[i];\n        omega *= omega_n;\n    }\n    if(!Regular){\n        for(auto &i : r){\n            i /= n;\n        }\n    }\n    return r;\n}\n\nint main(){\n    // \u5165\u529b\u5217\n    std::vector<float> input = { 0, 1, 2, 3, 4, 5, 6, 7 };\n\n    // \u8907\u7d20\u6570\u5217\u306b\u5909\u63db\u3059\u308b\n    seq input_complex(input.size());\n    for(std::size_t i = 0; i < input.size(); ++i){\n        input_complex[i] = input[i];\n    }\n\n    // \u518d\u5e30FFT\n    seq result_rec_fft = rec_fft<true>(input_complex);\n    std::cout << \"Recursive-FFT\" << std::endl;\n    for(auto &&n : result_rec_fft){\n        std::cout << n << \" \";\n    }\n    std::cout << std::endl;\n\n    // \u5fa9\u5143\n    seq rev = rec_fft<false>(result_rec_fft);\n    std::cout << \"Inverse-FFT\" << std::endl;\n    for(auto &&n : rev){\n        std::cout << n << \" \";\n    }\n\n    return 0;\n}\n\n\nRecursiev-FFT\n(28,0) (-4,-9.65685) (-4,-4) (-4,-1.65685) (-4,0) (-4,1.65685) (-4,4) (-4,9.65685) \nInverse-FFT\n(0,0) (1,1.19209e-07) (2,0) (3,-1.19209e-07) (4,0) (5,-1.19209e-07) (6,-0) (7,1.19209e-07) \n\n\n\u6dfb\u3048\u5b57\u30d3\u30c3\u30c8\u53cd\u8ee2\u3092\u5c0e\u5165\u3059\u308b\n\u30d0\u30bf\u30d5\u30e9\u30a4\u6f14\u7b97\u3092\u89e3\u6790\u3059\u308b\u3068\u3001\u8981\u7d20\u306e\u5165\u308c\u66ff\u3048\u304c\u6b21\u306e\u6728\u69cb\u9020\u306b\u306a\u3063\u3066\u3044\u308b\u4e8b\u304c\u5206\u304b\u308a\u307e\u3059\u3002\n\n\u3053\u3053\u30670, 4, 2, 6, 1, 5, 3, 7\u3092\u6ce8\u610f\u6df1\u304f\u89b3\u5bdf\u3059\u308b\u3068\u3001\u305d\u308c\u305e\u308c\u5143\u306eindex\u306e2\u9032\u6570\u8868\u73fe\u3092\u6700\u4e0b\u4f4dbit\u304b\u3089n bit\u307e\u3067\u53cd\u8ee2\u3055\u305b\u305f\u3060\u3051\u306b\u306a\u3063\u3066\u3044\u307e\u3059\u3002\n\u30c7\u30fc\u30bf\u306e\u5165\u308c\u66ff\u3048\u306fn\u56de\u306e\u518d\u5e30\u95a2\u6570\u547c\u3073\u51fa\u3057\u304b\u3089n/2\u56de\u306e\u30eb\u30fc\u30d7\u306b\u7f6e\u304d\u63db\u3048\u308b\u4e8b\u304c\u53ef\u80fd\u306a\u4e8b\u304c\u5206\u304b\u308a\u307e\u3057\u305f\u3002\nFFT\u306e\u518d\u5e30\u95a2\u6570\u306b\u3088\u308b\u5b9f\u88c5\u306f\u672b\u5c3e\u518d\u5e30\u6700\u9069\u5316\u304c\u52b9\u304b\u305a\u3001\u5165\u308c\u66ff\u3048\u306e\u5ea6\u306b\u30b9\u30bf\u30c3\u30af\u3068\u30d2\u30fc\u30d7\u3092\u78ba\u4fdd\u30fb\u89e3\u6cd5\u3059\u308b\u624b\u7d9a\u304d\u3092\u884c\u3046\u306e\u3067\u52b9\u7387\u304c\u60aa\u3044\u3067\u3059\u3002\n\u4ee5\u4e0a\u306e\u8003\u5bdf\u306b\u57fa\u3065\u3044\u3066\u66f8\u304d\u76f4\u3057\u3066\u307f\u307e\u3057\u3087\u3046\u3002\n\niterative-fft.cpp\n#include <iostream>\n#include <vector>\n#include <complex>\n#include <cmath>\n\nusing complex_t = std::complex<float>;\nusing seq = std::vector<complex_t>;\n\n// \u30d3\u30c3\u30c8\u9577\u3092\u5f97\u308b\nstd::size_t bit_num(std::size_t t){\n    std::size_t n = 0;\n    while(t > 0){\n        ++n;\n        t >>= 1;\n    }\n    return n;\n}\n\n// \u30d3\u30c3\u30c8\u9806\u5e8f\u3092\u53cd\u8ee2\u3059\u308b\nint bit_rev(std::size_t a, std::size_t n){\n    if(a == 0){\n        return a;\n    }\n    std::size_t r = 0;\n    // \u9577\u3055\u304c\u57fa\u6570\u3060\u3063\u305f\u5834\u5408, \u4e2d\u592e\u306ebit\u3092\u5f97\u308b\n    if(n % 2 == 1){\n        r |= ((a >> (n / 2)) & 1) << (n / 2);\n    }\n    // \u524d\u5f8c\u306e\u9806\u5e8f\u3092\u5165\u308c\u66ff\u3048\u308b\n    for(std::size_t i = 0; i < n / 2; ++i){\n        r |= ((a >> i) & 1) << (n - 1 - i);\n        r |= ((a >> (n - 1 - i)) & 1) << i;\n    }\n    return r;\n}\n\n// \u30d3\u30c3\u30c8\u30ea\u30d0\u30fc\u30b9\u30b3\u30d4\u30fc\nvoid bit_rev_copy(const seq &a, seq &A, std::size_t n){\n//    \u4fe1\u53f7\u51e6\u7406\u3067\u7a93\u3092\u4f7f\u3046\u5834\u5408\u306f\u3053\u306e\u6642\u70b9\u3067\u9069\u7528\u3059\u308b\n//    \u4f8b:Vorbis\u7a93\n//    for(int i = 0; i < (1u << n); ++i){\n//        float v = std::sin(M_PI * i / (1u << n));\n//        v *= v;\n//        A[bit_rev(i, n)] = a[i] * std::sin(M_PI * v / 2);\n//    }\n\n    for(std::size_t i = 0; i < (1u << n); ++i){\n        A[bit_rev(i, n)] = a[i];\n    }\n}\n\ntemplate<bool Regular>\nseq fft(const seq &a){\n    seq A(a.size());\n    std::size_t lg_n = bit_num(a.size()) - 1;\n    std::size_t n = a.size();\n    bit_rev_copy(a, A, lg_n);\n    if(!Regular){\n        for(std::size_t i = 0; i < n; ++i){\n            A[i] = complex_t(A[i].real(), -A[i].imag());\n        }\n    }\n    for(std::size_t s = 1; s <= lg_n; ++s){\n        std::size_t m = 1 << s;\n        complex_t omega_m(std::cos(2.0 * M_PI / m), std::sin(2.0 * M_PI / m)), omega = 1.0;\n        for(std::size_t j = 0; j < m / 2; ++j){\n            for(std::size_t k = j; k < n; k += m){\n                complex_t t = omega * A[k + m / 2], u = A[k];\n                A[k] = u + t;\n                A[k + m / 2] = u - t;\n            }\n            omega *= omega_m;\n        }\n    }\n    if(!Regular){\n        for(std::size_t i = 0; i < n; ++i){\n            A[i] /= n;\n        }\n    }\n    return A;\n}\n\nint main(){\n    // \u5165\u529b\u5217\n    std::vector<float> input = { 0, 1, 2, 3, 4, 5, 6, 7 };\n\n    // \u8907\u7d20\u6570\u5217\u306b\u5909\u63db\u3059\u308b\n    seq input_complex(input.size());\n    for(std::size_t i = 0; i < input.size(); ++i){\n        input_complex[i] = input[i];\n    }\n\n    // \u975e\u518d\u5e30FFT\n    seq result_fft = fft<true>(input_complex);\n    std::cout << \"Iterative-FFT\" << std::endl;\n    for(auto &&n : result_fft){\n        std::cout << n << \" \";\n    }\n    std::cout << std::endl;\n\n    // \u5fa9\u5143\n    seq rev = fft<false>(result_fft);\n    std::cout << \"Inverse-FFT\" << std::endl;\n    for(auto &&n : rev){\n        std::cout << n << \" \";\n    }\n    return 0;\n}\n\n\nIterative-FFT\n(28,0) (-4,-9.65685) (-4,-4) (-4,-1.65685) (-4,0) (-4,1.65685) (-4,4) (-4,9.65685) \nInverse-FFT\n(0,0) (1,1.19209e-07) (2,0) (3,-1.19209e-07) (4,0) (5,-1.19209e-07) (6,-0) (7,1.19209e-07) \n\n\n\u53c2\u8003\u6587\u732e\n\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0\u30a4\u30f3\u30c8\u30ed\u30c0\u30af\u30b7\u30e7\u30f3\uff08\u7cbe\u9078\u30c8\u30d4\u30c3\u30af\u30b9\uff09\n## \u30d0\u30bf\u30d5\u30e9\u30a4\u6f14\u7b97\nFFT\u306f\u5206\u5272\u7d71\u6cbb\u6cd5\u306e\u4e00\u7a2e\u3067\u3059\u3002\u5165\u529b$2^n$\u500b\u306b\u5bfe\u3057\u3066\u30c7\u30fc\u30bf\u3092\u5165\u308c\u66ff\u3048\u306a\u304c\u3089\u6f14\u7b97\u3092\u9032\u3081\u3066\u3044\u304d\u307e\u3059\u3002\n$n = 3$\u306e\u5834\u5408\u306f\u4ee5\u4e0b\u306e\u56f3\u306e\u69d8\u306b\u306a\u308a\u307e\u3059\u3002\n![20151214081510_0.png](https://qiita-image-store.s3.amazonaws.com/0/34654/d33df711-d4d2-13c0-75f6-4e5a7863f62b.png)\n\u3053\u3053\u3067$\\omega$\u306f\u4f53\u306e\u6027\u8cea\u3092\u6301\u3063\u305f\u96c6\u5408\u306e\u5143\u3067\u3001\u4fe1\u53f7\u51e6\u7406\u306e\u5834\u5408\u306f\u8907\u7d20\u5e73\u9762\u4e0a\u306e\u5358\u4f4d\u5186\u306e\u539f\u59cb$n$\u4e57\u6839\u306b\u306a\u308a\u3001\u30e2\u30b8\u30e5\u30ed\u4ee3\u6570\u306e\u5834\u5408\u306f\u7d20\u6570$p = 2^nk + 1$\u3092\u6210\u308a\u7acb\u305f\u305b\u308b\u6700\u5c0f\u306e$k$\u306b\u5bfe\u3057$n^k \\bmod p$\u306b\u306a\u308a\u307e\u3059\u3002\n\u3053\u308c\u3092\u30d0\u30bf\u30d5\u30e9\u30a4\u6f14\u7b97\u3068\u547c\u3073\u307e\u3059\u3002\n\u30d0\u30bf\u30d5\u30e9\u30a4\u6f14\u7b97\u306f\u6b21\u306e\u69d8\u306b\u518d\u5e30\u95a2\u6570\u3092\u7528\u3044\u3066\u5b9f\u88c5\u3055\u308c\u308b\u4e8b\u304c\u591a\u3044\u69d8\u3067\u3059\u3002\n\n```cpp:recursive-fft.cpp\n#include <iostream>\n#include <vector>\n#include <complex>\n#include <cmath>\n\nusing complex_t = std::complex<float>;\nusing seq = std::vector<complex_t>;\n\n// \u518d\u5e30FFT\ntemplate<bool Regular>\nseq rec_fft(const seq &a){\n    std::size_t n = a.size();\n    if(n == 1){\n        return a;\n    }\n    complex_t omega_n(std::cos(2.0 * M_PI / n), std::sin(2.0 * M_PI / n)), omega = 1.0;\n    seq A(n / 2), B(n / 2);\n    for(std::size_t i = 0; i < n / 2; ++i){\n        if(Regular){\n            A[i] = a[i * 2];\n            B[i] = a[i * 2 + 1];\n        }else{\n            A[i] = complex_t(a[i * 2].real(), -a[i * 2].imag());\n            B[i] = complex_t(a[i * 2 + 1].real(), -a[i * 2 + 1].imag());\n        }\n    }\n    A = rec_fft<true>(A);\n    B = rec_fft<true>(B);\n    seq r(n);\n    for(std::size_t i = 0; i < n / 2; ++i){\n        r[i] = A[i] + omega * B[i];\n        r[i + n / 2] = A[i] - omega * B[i];\n        omega *= omega_n;\n    }\n    if(!Regular){\n        for(auto &i : r){\n            i /= n;\n        }\n    }\n    return r;\n}\n\nint main(){\n    // \u5165\u529b\u5217\n    std::vector<float> input = { 0, 1, 2, 3, 4, 5, 6, 7 };\n\n    // \u8907\u7d20\u6570\u5217\u306b\u5909\u63db\u3059\u308b\n    seq input_complex(input.size());\n    for(std::size_t i = 0; i < input.size(); ++i){\n        input_complex[i] = input[i];\n    }\n    \n    // \u518d\u5e30FFT\n    seq result_rec_fft = rec_fft<true>(input_complex);\n    std::cout << \"Recursive-FFT\" << std::endl;\n    for(auto &&n : result_rec_fft){\n        std::cout << n << \" \";\n    }\n    std::cout << std::endl;\n    \n    // \u5fa9\u5143\n    seq rev = rec_fft<false>(result_rec_fft);\n    std::cout << \"Inverse-FFT\" << std::endl;\n    for(auto &&n : rev){\n        std::cout << n << \" \";\n    }\n    \n    return 0;\n}\n```\n\n```\nRecursiev-FFT\n(28,0) (-4,-9.65685) (-4,-4) (-4,-1.65685) (-4,0) (-4,1.65685) (-4,4) (-4,9.65685) \nInverse-FFT\n(0,0) (1,1.19209e-07) (2,0) (3,-1.19209e-07) (4,0) (5,-1.19209e-07) (6,-0) (7,1.19209e-07) \n```\n\n## \u6dfb\u3048\u5b57\u30d3\u30c3\u30c8\u53cd\u8ee2\u3092\u5c0e\u5165\u3059\u308b\n\u30d0\u30bf\u30d5\u30e9\u30a4\u6f14\u7b97\u3092\u89e3\u6790\u3059\u308b\u3068\u3001\u8981\u7d20\u306e\u5165\u308c\u66ff\u3048\u304c\u6b21\u306e\u6728\u69cb\u9020\u306b\u306a\u3063\u3066\u3044\u308b\u4e8b\u304c\u5206\u304b\u308a\u307e\u3059\u3002\n![20151214081510_1.png](https://qiita-image-store.s3.amazonaws.com/0/34654/62ba1f19-8dcc-7e00-f1b9-373ef8ed8a65.png)\n\u3053\u3053\u3067`0, 4, 2, 6, 1, 5, 3, 7`\u3092\u6ce8\u610f\u6df1\u304f\u89b3\u5bdf\u3059\u308b\u3068\u3001\u305d\u308c\u305e\u308c\u5143\u306eindex\u306e2\u9032\u6570\u8868\u73fe\u3092\u6700\u4e0b\u4f4dbit\u304b\u3089n bit\u307e\u3067\u53cd\u8ee2\u3055\u305b\u305f\u3060\u3051\u306b\u306a\u3063\u3066\u3044\u307e\u3059\u3002\n\u30c7\u30fc\u30bf\u306e\u5165\u308c\u66ff\u3048\u306fn\u56de\u306e\u518d\u5e30\u95a2\u6570\u547c\u3073\u51fa\u3057\u304b\u3089n/2\u56de\u306e\u30eb\u30fc\u30d7\u306b\u7f6e\u304d\u63db\u3048\u308b\u4e8b\u304c\u53ef\u80fd\u306a\u4e8b\u304c\u5206\u304b\u308a\u307e\u3057\u305f\u3002\nFFT\u306e\u518d\u5e30\u95a2\u6570\u306b\u3088\u308b\u5b9f\u88c5\u306f\u672b\u5c3e\u518d\u5e30\u6700\u9069\u5316\u304c\u52b9\u304b\u305a\u3001\u5165\u308c\u66ff\u3048\u306e\u5ea6\u306b\u30b9\u30bf\u30c3\u30af\u3068\u30d2\u30fc\u30d7\u3092\u78ba\u4fdd\u30fb\u89e3\u6cd5\u3059\u308b\u624b\u7d9a\u304d\u3092\u884c\u3046\u306e\u3067\u52b9\u7387\u304c\u60aa\u3044\u3067\u3059\u3002\n\u4ee5\u4e0a\u306e\u8003\u5bdf\u306b\u57fa\u3065\u3044\u3066\u66f8\u304d\u76f4\u3057\u3066\u307f\u307e\u3057\u3087\u3046\u3002\n\n```cpp:iterative-fft.cpp\n#include <iostream>\n#include <vector>\n#include <complex>\n#include <cmath>\n\nusing complex_t = std::complex<float>;\nusing seq = std::vector<complex_t>;\n\n// \u30d3\u30c3\u30c8\u9577\u3092\u5f97\u308b\nstd::size_t bit_num(std::size_t t){\n    std::size_t n = 0;\n    while(t > 0){\n        ++n;\n        t >>= 1;\n    }\n    return n;\n}\n\n// \u30d3\u30c3\u30c8\u9806\u5e8f\u3092\u53cd\u8ee2\u3059\u308b\nint bit_rev(std::size_t a, std::size_t n){\n    if(a == 0){\n        return a;\n    }\n    std::size_t r = 0;\n    // \u9577\u3055\u304c\u57fa\u6570\u3060\u3063\u305f\u5834\u5408, \u4e2d\u592e\u306ebit\u3092\u5f97\u308b\n    if(n % 2 == 1){\n        r |= ((a >> (n / 2)) & 1) << (n / 2);\n    }\n    // \u524d\u5f8c\u306e\u9806\u5e8f\u3092\u5165\u308c\u66ff\u3048\u308b\n    for(std::size_t i = 0; i < n / 2; ++i){\n        r |= ((a >> i) & 1) << (n - 1 - i);\n        r |= ((a >> (n - 1 - i)) & 1) << i;\n    }\n    return r;\n}\n\n// \u30d3\u30c3\u30c8\u30ea\u30d0\u30fc\u30b9\u30b3\u30d4\u30fc\nvoid bit_rev_copy(const seq &a, seq &A, std::size_t n){\n//    \u4fe1\u53f7\u51e6\u7406\u3067\u7a93\u3092\u4f7f\u3046\u5834\u5408\u306f\u3053\u306e\u6642\u70b9\u3067\u9069\u7528\u3059\u308b\n//    \u4f8b:Vorbis\u7a93\n//    for(int i = 0; i < (1u << n); ++i){\n//        float v = std::sin(M_PI * i / (1u << n));\n//        v *= v;\n//        A[bit_rev(i, n)] = a[i] * std::sin(M_PI * v / 2);\n//    }\n    \n    for(std::size_t i = 0; i < (1u << n); ++i){\n        A[bit_rev(i, n)] = a[i];\n    }\n}\n\ntemplate<bool Regular>\nseq fft(const seq &a){\n    seq A(a.size());\n    std::size_t lg_n = bit_num(a.size()) - 1;\n    std::size_t n = a.size();\n    bit_rev_copy(a, A, lg_n);\n    if(!Regular){\n        for(std::size_t i = 0; i < n; ++i){\n            A[i] = complex_t(A[i].real(), -A[i].imag());\n        }\n    }\n    for(std::size_t s = 1; s <= lg_n; ++s){\n        std::size_t m = 1 << s;\n        complex_t omega_m(std::cos(2.0 * M_PI / m), std::sin(2.0 * M_PI / m)), omega = 1.0;\n        for(std::size_t j = 0; j < m / 2; ++j){\n            for(std::size_t k = j; k < n; k += m){\n                complex_t t = omega * A[k + m / 2], u = A[k];\n                A[k] = u + t;\n                A[k + m / 2] = u - t;\n            }\n            omega *= omega_m;\n        }\n    }\n    if(!Regular){\n        for(std::size_t i = 0; i < n; ++i){\n            A[i] /= n;\n        }\n    }\n    return A;\n}\n\nint main(){\n    // \u5165\u529b\u5217\n    std::vector<float> input = { 0, 1, 2, 3, 4, 5, 6, 7 };\n\n    // \u8907\u7d20\u6570\u5217\u306b\u5909\u63db\u3059\u308b\n    seq input_complex(input.size());\n    for(std::size_t i = 0; i < input.size(); ++i){\n        input_complex[i] = input[i];\n    }\n\n    // \u975e\u518d\u5e30FFT\n    seq result_fft = fft<true>(input_complex);\n    std::cout << \"Iterative-FFT\" << std::endl;\n    for(auto &&n : result_fft){\n        std::cout << n << \" \";\n    }\n    std::cout << std::endl;\n    \n    // \u5fa9\u5143\n    seq rev = fft<false>(result_fft);\n    std::cout << \"Inverse-FFT\" << std::endl;\n    for(auto &&n : rev){\n        std::cout << n << \" \";\n    }\n    return 0;\n}\n```\n\n```\nIterative-FFT\n(28,0) (-4,-9.65685) (-4,-4) (-4,-1.65685) (-4,0) (-4,1.65685) (-4,4) (-4,9.65685) \nInverse-FFT\n(0,0) (1,1.19209e-07) (2,0) (3,-1.19209e-07) (4,0) (5,-1.19209e-07) (6,-0) (7,1.19209e-07) \n```\n\n## \u53c2\u8003\u6587\u732e\n\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0\u30a4\u30f3\u30c8\u30ed\u30c0\u30af\u30b7\u30e7\u30f3\uff08\u7cbe\u9078\u30c8\u30d4\u30c3\u30af\u30b9\uff09\n", "tags": ["C++", "FFT", "\u4fe1\u53f7\u51e6\u7406"]}