{"context": " More than 1 year has passed since last update.\n\n\u306f\u3058\u3081\u306b\nOpenGL\u3068C\u8a00\u8a9e\u3092\u4f7f\u3063\u3066\u521d\u97f3\u30df\u30af\u306e3D\u30e2\u30c7\u30eb\u3092\u8868\u793a\u3059\u308b\u30d7\u30ed\u30b0\u30e9\u30e0\u3092\u4f5c\u6210\u306b\u6311\u6226\u3057\u3066\u3044\u307e\u3059\u3002\u4eca\u56de\u306f3D\u30e2\u30c7\u30eb\u306e\u9670\u5f71\u4ed8\u3051\u3068\u30c6\u30af\u30b9\u30c1\u30e3\u30de\u30c3\u30d4\u30f3\u30b0\u3092\u884c\u3044\u307e\u3059\u3002\n\n\u904e\u53bb\u306e\u8a18\u4e8b\n\n\u4eca\u3069\u304d\u306eOpenGL\u3068C\u8a00\u8a9e\u3067\u521d\u97f3\u30df\u30af\u3092\u8868\u793a\u3059\u308b(\u305d\u306e1): \u30a6\u30a4\u30f3\u30c9\u30a6\u306e\u8868\u793a\n\u4eca\u3069\u304d\u306eOpenGL\u3068C\u8a00\u8a9e\u3067\u521d\u97f3\u30df\u30af\u3092\u8868\u793a\u3059\u308b(\u305d\u306e2): \u30d7\u30ea\u30df\u30c6\u30a3\u30d6\u306e\u63cf\u753b\n\u4eca\u3069\u304d\u306eOpenGL\u3068C\u8a00\u8a9e\u3067\u521d\u97f3\u30df\u30af\u3092\u8868\u793a\u3059\u308b(\u305d\u306e3): 3D\u30e2\u30c7\u30eb\u306e\u8aad\u307f\u8fbc\u307f\u3068\u900f\u8996\u6295\u5f71\n\n\n\u9670\u5f71\u3092\u4ed8\u3051\u308b\n\u9670\u5f71\u3092\u3064\u3051\u308b\u305f\u3081\u306b\u3001\u30b7\u30a7\u30fc\u30c0\u3092\u62e1\u5f35\u3057\u307e\u3059\u3002\u4ee5\u4e0b\u306f\u7a7a\u9593\u4e0a\u306b\u5e73\u884c\u5149\u6e90\u3092\u914d\u7f6e\u3057\u3066\u3001\u30e9\u30f3\u30d0\u30fc\u30c8\u306e\u4f59\u5f26\u5247\u306b\u5f93\u3063\u3066\u62e1\u6563\u53cd\u5c04\u3092\u8a08\u7b97\u3059\u308b\u30b7\u30a7\u30fc\u30c0\u3067\u3059\u3002\n\nVertex.glsl\n#version 450\n\nlayout (location = 0) in vec3 in_position;\nlayout (location = 1) in vec3 in_normal;\n\nuniform mat4 mv_matrix;\nuniform mat3 normal_matrix;\nuniform mat4 mvp;\n\nout vec3 color;\n\nvoid main()\n{\n    vec3 n = normalize(normal_matrix * in_normal);\n\n    vec4 camera = mv_matrix * vec4(in_position, 1.0);\n    vec4 light = vec4(4.0, 4.0, 4.0, 1.0);\n    vec3 s = normalize(vec3(light - camera));\n\n    color = vec3(1.0, 1.0, 1.0) * max(dot(s, n), 0.0);\n    gl_Position = mvp * vec4(in_position, 1.0);\n}\n\n\n\nFragment.glsl\n#version 450\n\nin vec3 color;\n\nout vec4 out_color;\n\nvoid main()\n{\n    out_color = vec4(color, 1.0);\n}\n\n\n\u3053\u306e\u30b7\u30a7\u30fc\u30c0\u306f\u3001\u9802\u70b9\u4f4d\u7f6e\u3001\u9802\u70b9\u306e\u6cd5\u7dda\u3001\u30e2\u30c7\u30eb\u30d3\u30e5\u30fc\u884c\u5217\u3001\u6b63\u898f\u5316\u884c\u5217\u3001MVP\u884c\u5217\u3092\u53d7\u3051\u53d6\u308b\u3002\u3053\u308c\u3089\u306e\u3046\u3061\u9802\u70b9\u306e\u6cd5\u7dda\u306fOBJ\u30d5\u30a1\u30a4\u30eb\u304b\u3089\u8aad\u307f\u8fbc\u3080\u3053\u3068\u306b\u3057\u307e\u3059\u3002Metasequoia\u3067\u306fOBJ\u30d5\u30a1\u30a4\u30eb\u3092\u4fdd\u5b58\u3059\u308b\u3068\u304d\u306b\u4ee5\u4e0b\u306e\u3088\u3046\u306b\u8a2d\u5b9a\u3059\u308b\u3053\u3068\u3067\u3001\u6cd5\u7dda\u3092\u51fa\u529b\u3067\u304d\u307e\u3059\u3002\n\n\u3053\u306e\u8a2d\u5b9a\u3067\u7acb\u65b9\u4f53\u3092\u51fa\u529b\u3059\u308b\u3068\u4ee5\u4e0b\u306e\u3088\u3046\u306aOBJ\u30d5\u30a1\u30a4\u30eb\u304c\u5f97\u3089\u308c\u307e\u3059\u3002\n# Created by Metasequoia\n\nv -0.500000 0.500000 0.500000\nv -0.500000 -0.500000 0.500000\nv 0.500000 0.500000 0.500000\nv 0.500000 -0.500000 0.500000\nv 0.500000 0.500000 -0.500000\nv 0.500000 -0.500000 -0.500000\nv -0.500000 0.500000 -0.500000\nv -0.500000 -0.500000 -0.500000\n# 8 vertices\n\nvn 0.00000 0.00000 1.00000\nvn 1.00000 0.00000 0.00000\nvn 0.00000 0.00000 -1.00000\nvn -1.00000 0.00000 0.00000\nvn 0.00000 1.00000 0.00000\nvn 0.00000 -1.00000 0.00000\n# 6 normal vertices\n\nf 4//1 3//1 1//1\nf 2//1 4//1 1//1\nf 6//2 5//2 3//2\nf 4//2 6//2 3//2\nf 8//3 7//3 5//3\nf 6//3 8//3 5//3\nf 2//4 1//4 7//4\nf 8//4 2//4 7//4\nf 3//5 5//5 7//5\nf 1//5 3//5 7//5\nf 6//6 4//6 2//6\nf 8//6 6//6 2//6\n# 12 elements\n\n\u4ee5\u4e0b\u306fObjLoader.h\u3068ObjLoader.c\u3092\u3001\u4e0a\u306e\u3088\u3046\u306aOBJ\u30d5\u30a1\u30a4\u30eb\u3092\u8aad\u307f\u8fbc\u3081\u308b\u3088\u3046\u306b\u62e1\u5f35\u3057\u305f\u3082\u306e\u3067\u3059\u3002\n\nObjLoader.h\n#ifndef OBJLOADER_H_INCLUDE\n#define OBJLOADER_H_INCLUDE\n\n/* \u30e2\u30c7\u30eb\u30c7\u30fc\u30bf */\ntypedef struct {\n    float *vertices;\n    int num_vertices;\n    float *normals;\n    int num_normals;\n} model;\n\n/* OBJ\u30d5\u30a1\u30a4\u30eb\u306e\u8aad\u307f\u8fbc\u307f */\nvoid load_obj(model *m, const char *file_name);\n\n#endif\n\n\n\nObjLoader.c\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ObjLoader.h\"\n\n/* \u521d\u671f\u30d0\u30c3\u30d5\u30a1\u30b5\u30a4\u30ba */\n#define DEF_BUF_SIZE 2\n\n/* \u6d6e\u52d5\u5c0f\u6570\u70b9\u6570\u30d0\u30c3\u30d5\u30a1 */\ntypedef struct {\n    int buf_size;\n    int current_index;\n    float *buf;\n} float_buffer;\n\n/* \u6574\u6570\u30d0\u30c3\u30d5\u30a1 */\ntypedef struct {\n    int buf_size;\n    int current_index;\n    int *buf;\n} int_buffer;\n\n/* \u9802\u70b9\u5ea7\u6a19\u306e\u8aad\u307f\u8fbc\u307f */\nvoid read_vertices(const char *line, float_buffer *vs);\n\n/* \u6cd5\u7dda\u30d9\u30af\u30c8\u30eb\u306e\u8aad\u307f\u8fbc\u307f */\nvoid read_normals(const char *line, float_buffer *vns);\n\n/* \u30a4\u30f3\u30c7\u30c3\u30af\u30b9\u306e\u8aad\u307f\u8fbc\u307f */\nvoid read_indices(const char *line, int_buffer *fs);\n\n/* \u30e2\u30c7\u30eb\u306e\u4f5c\u6210 */\nvoid create_model(model *m,\n    float_buffer *vs, float_buffer *vns, int_buffer *fs);\n\n/* \u6d6e\u52d5\u5c0f\u6570\u70b9\u6570\u30d0\u30c3\u30d5\u30a1\u306e\u64cd\u4f5c */\nfloat_buffer *alloc_float_buffer(void);\nvoid free_float_buffer(float_buffer *fbuf);\nvoid add_float(float_buffer *fbuf, float value);\nfloat get_float(float_buffer *fbuf, int index);\n\n/* \u6574\u6570\u30d0\u30c3\u30d5\u30a1\u306e\u64cd\u4f5c */\nint_buffer *alloc_int_buffer(void);\nvoid free_int_buffer(int_buffer *ibuf);\nvoid add_int(int_buffer *ibuf, int value);\nint get_int(int_buffer *ibuf, int index);\n\n/*==============================*\n** OBJ\u30d5\u30a1\u30a4\u30eb\u306e\u8aad\u307f\u8fbc\u307f\n**==============================*/\nvoid load_obj(model *m, const char *file_name)\n{\n    FILE *fp;\n    char line[1024];\n    float_buffer *vs, *vns;\n    int_buffer *fs;\n\n    fp = fopen(file_name, \"r\");\n    if (!fp) {\n        fprintf(stderr, \"Cannot open %s.\\n\", file_name);\n        exit(EXIT_FAILURE);\n    }\n\n    vs = alloc_float_buffer();\n    vns = alloc_float_buffer();\n    fs = alloc_int_buffer();\n\n    while (!feof(fp)) {\n        fgets(line, sizeof(line), fp);\n        if (line[0] == 'v' && line[1] == ' ') {\n            read_vertices(line, vs);\n        }\n        else if (line[0] == 'v' && line[1] == 'n' && line[2] == ' ') {\n            read_normals(line, vns);\n        }\n        else if (line[0] == 'f' && line[1] == ' ') {\n            read_indices(line, fs);\n        }\n    }\n\n    create_model(m, vs, vns, fs);\n\n    free_float_buffer(vs);\n    free_float_buffer(vns);\n    free_int_buffer(fs);\n\n    fclose(fp);\n}\n\n/*------------------------------*\n** \u9802\u70b9\u5ea7\u6a19\u306e\u8aad\u307f\u8fbc\u307f\n**------------------------------*/\nvoid read_vertices(const char *line, float_buffer *vs)\n{\n    float x, y, z;\n    int count;\n\n    count = sscanf(line, \"%*s%f%f%f\", &x, &y, &z);\n\n    if (count == 3) {\n        add_float(vs, x);\n        add_float(vs, y);\n        add_float(vs, z);\n    }\n}\n\n/*------------------------------*\n** \u6cd5\u7dda\u30d9\u30af\u30c8\u30eb\u306e\u8aad\u307f\u8fbc\u307f\n**------------------------------*/\nvoid read_normals(const char *line, float_buffer *vns)\n{\n    float x, y, z;\n    int count;\n\n    count = sscanf(line, \"%*s%f%f%f\", &x, &y, &z);\n\n    if (count == 3) {\n        add_float(vns, x);\n        add_float(vns, y);\n        add_float(vns, z);\n    }\n}\n\n/*------------------------------*\n** \u30a4\u30f3\u30c7\u30c3\u30af\u30b9\u306e\u8aad\u307f\u8fbc\u307f\n**------------------------------*/\nvoid read_indices(const char *line, int_buffer *fs)\n{\n    int v1, v2, v3;\n    int n1, n2, n3;\n    int count;\n\n    count = sscanf(line,\n        \"%*s %d%*[/]%d %d%*[/]%d %d%*[/]%d\", \n        &v1, &n1, &v2, &n2, &v3, &n3);\n\n    if (count == 6) {\n        add_int(fs, v1);\n        add_int(fs, n1);\n        add_int(fs, v2);\n        add_int(fs, n2);\n        add_int(fs, v3);\n        add_int(fs, n3);\n    }\n}\n\n/*------------------------------*\n** \u30e2\u30c7\u30eb\u306e\u4f5c\u6210\n**------------------------------*/\nvoid create_model(model *m, \n    float_buffer *vs, float_buffer *vns, int_buffer *fs)\n{\n    int i, j;\n\n    m->num_vertices = fs->current_index / 2 * 3;\n    m->vertices = malloc(sizeof(float) * m->num_vertices);\n\n    if (!m->vertices) {\n        fprintf(stderr, \"Memory allocation error.\\n\");\n        exit(EXIT_FAILURE);\n    }\n\n    m->num_normals = fs->current_index / 2 * 3;\n    m->normals = malloc(sizeof(float) * m->num_normals);\n\n    if (!m->normals) {\n        fprintf(stderr, \"Memory allocation error.\\n\");\n        exit(EXIT_FAILURE);\n    }\n\n    for (i = 0; i < fs->current_index; i++) {\n        int idx = fs->buf[i] - 1;\n        if (i % 2 == 0) {\n            for (j = 0; j < 3; j++) {\n                m->vertices[i / 2 * 3 + j] = vs->buf[idx * 3 + j];\n            }\n        }\n        else {\n            for (j = 0; j < 3; j++) {\n                m->normals[i / 2 * 3 + j] = vns->buf[idx * 3 + j];\n            }\n        }\n\n    }\n}\n\n/*------------------------------*\n** \u6d6e\u52d5\u5c0f\u6570\u70b9\u6570\u30d0\u30c3\u30d5\u30a1\u306e\u5272\u308a\u5f53\u3066\n**------------------------------*/\nfloat_buffer *alloc_float_buffer(void)\n{\n    float_buffer *fbuf;\n\n    fbuf = malloc(sizeof(float_buffer));\n    if (!fbuf) {\n        fprintf(stderr, \"Memory allocation error.\\n\");\n        exit(EXIT_FAILURE);\n    }\n\n    fbuf->buf_size = DEF_BUF_SIZE;\n    fbuf->current_index = 0;\n    fbuf->buf = malloc(sizeof(float) * fbuf->buf_size);\n\n    return fbuf;\n}\n\n/*------------------------------*\n** \u6d6e\u52d5\u5c0f\u6570\u70b9\u6570\u30d0\u30c3\u30d5\u30a1\u306e\u89e3\u653e\n**------------------------------*/\nvoid free_float_buffer(float_buffer *fbuf)\n{\n    free(fbuf->buf);\n    free(fbuf);\n}\n\n/*------------------------------*\n** \u30d0\u30c3\u30d5\u30a1\u306b\u6d6e\u52d5\u5c0f\u6570\u70b9\u6570\u3092\u8ffd\u52a0\n**------------------------------*/\nvoid add_float(float_buffer *fbuf, float value)\n{\n    fbuf->buf[fbuf->current_index] = value;\n    fbuf->current_index++;\n    if (fbuf->current_index >= fbuf->buf_size) {\n        fbuf->buf_size *= 2;\n        fbuf->buf = realloc(fbuf->buf, sizeof(float) * fbuf->buf_size);\n        if (!fbuf->buf) {\n            fprintf(stderr, \"Memory allocation error.\\n\");\n            exit(EXIT_FAILURE);\n        }\n    }\n}\n\n/*------------------------------*\n** \u30d0\u30c3\u30d5\u30a1\u304b\u3089\u6d6e\u52d5\u5c0f\u6570\u70b9\u6570\u3092\u53d6\u308a\u51fa\u3057\n**------------------------------*/\nfloat get_float(float_buffer *fbuf, int index)\n{\n    return fbuf->buf[index];\n}\n\n/*------------------------------*\n** \u6574\u6570\u30d0\u30c3\u30d5\u30a1\u306e\u5272\u308a\u5f53\u3066\n**------------------------------*/\nint_buffer *alloc_int_buffer(void)\n{\n    int_buffer *ibuf;\n\n    ibuf = malloc(sizeof(int_buffer));\n    if (!ibuf) {\n        fprintf(stderr, \"Memory allocation error.\\n\");\n        exit(EXIT_FAILURE);\n    }\n\n    ibuf->buf_size = DEF_BUF_SIZE;\n    ibuf->current_index = 0;\n    ibuf->buf = malloc(sizeof(int) * ibuf->buf_size);\n\n    return ibuf;\n}\n\n/*------------------------------*\n** \u6574\u6570\u30d0\u30c3\u30d5\u30a1\u306e\u89e3\u653e\n**------------------------------*/\nvoid free_int_buffer(int_buffer *ibuf)\n{\n    free(ibuf->buf);\n    free(ibuf);\n}\n\n/*------------------------------*\n** \u30d0\u30c3\u30d5\u30a1\u306b\u6574\u6570\u3092\u8ffd\u52a0\n**------------------------------*/\nvoid add_int(int_buffer *ibuf, int value)\n{\n    ibuf->buf[ibuf->current_index] = value;\n    ibuf->current_index++;\n    if (ibuf->current_index >= ibuf->buf_size) {\n        ibuf->buf_size *= 2;\n        ibuf->buf = realloc(ibuf->buf, sizeof(int) * ibuf->buf_size);\n        if (!ibuf->buf) {\n            fprintf(stderr, \"Memory allocation error.\\n\");\n            exit(EXIT_FAILURE);\n        }\n    }\n}\n\n/*------------------------------*\n** \u30d0\u30c3\u30d5\u30a1\u304b\u3089\u6574\u6570\u3092\u53d6\u308a\u51fa\u3057\n**------------------------------*/\nint get_int(int_buffer *ibuf, int index)\n{\n    return ibuf->buf[index];\n}\n\n\nMain.c\u306f\u4ee5\u4e0b\u306e\u3088\u3046\u306b\u5909\u66f4\u3057\u307e\u3059\u3002\n\nMain.c\n#include <stdio.h>\n#include <stdlib.h>\n#include <GL/glew.h>\n#include <GLFW/glfw3.h>\n#include \"Init.h\"\n#include \"ShaderLoader.h\"\n#include \"Matrix.h\"\n#include \"ObjLoader.h\"\n\nint main(void)\n{\n    GLFWwindow *window;\n    GLuint program;\n    model model;\n    GLuint mv_matrix, normal_matrix, mvp;\n    int i, j;\n\n    float *mat_proj, *mat_view, *mat_model;\n    float *mat_mv, *mat_mvp;\n    float mat_norm[9];\n\n    GLuint position_buffer;\n    GLuint normal_buffer;\n\n    GLuint vertex_array;\n\n    const GLuint position_location = 0;\n    const GLuint position_bindindex = 0;\n\n    const GLuint normal_location = 1;\n    const GLuint normal_bindindex = 1;\n\n    window = init(640, 480, \"Step 04\");\n\n    program = load_shader(\"Vertex.glsl\", \"Fragment.glsl\");\n\n    load_obj(&model, \"cube.obj\");\n\n    mat_proj = alloc_matrix();\n    set_perspective_matrix(mat_proj,\n        45.0, 640.0f / 480.0f, 0.1f, 100.0f);\n\n    mat_view = alloc_matrix();\n    set_lookat_matrix(mat_view,\n        2.0f, 3.0f, 3.0f,\n        0.0f, 0.0f, 0.0f,\n        0.0f, 1.0f, 0.0f);\n\n    mat_model = alloc_matrix();\n    set_identity_matrix(mat_model);\n\n    mat_mv = alloc_matrix();\n    multiply_matrix(mat_mv, mat_view, mat_model);\n\n    mat_mvp = alloc_matrix();\n    multiply_matrix(mat_mvp, mat_proj, mat_mv);\n\n    free_matrix(mat_proj);\n    free_matrix(mat_view);\n    free_matrix(mat_model);\n\n    mv_matrix = glGetUniformLocation(program, \"mv_matrix\");\n    glUniformMatrix4fv(mv_matrix, 1, GL_FALSE, mat_mv);\n\n    for (i = 0; i < 3; i++) {\n        for (j = 0; j < 3; j++) {\n            mat_norm[i * 3 + j] = mat_mv[i * 4 + j];\n        }\n    }\n    normal_matrix = glGetUniformLocation(program, \"normal_matrix\");\n    glUniformMatrix3fv(normal_matrix, 1, GL_FALSE, mat_norm);\n\n    mvp = glGetUniformLocation(program, \"mvp\");\n    glUniformMatrix4fv(mvp, 1, GL_FALSE, mat_mvp);\n\n    glCreateBuffers(1, &position_buffer);\n    glNamedBufferData(position_buffer,\n        sizeof(float) * model.num_vertices,\n        model.vertices,\n        GL_STATIC_DRAW);\n\n    glCreateBuffers(1, &normal_buffer);\n    glNamedBufferData(normal_buffer,\n        sizeof(float) * model.num_normals,\n        model.normals,\n        GL_STATIC_DRAW);\n\n    glCreateVertexArrays(1, &vertex_array);\n\n    glEnableVertexArrayAttrib(\n        vertex_array, position_location);\n    glVertexArrayAttribFormat(\n        vertex_array, position_location,\n        3, GL_FLOAT, GL_FALSE, 0);\n\n    glVertexArrayAttribBinding(\n        vertex_array, position_location,\n        position_bindindex);\n    glVertexArrayVertexBuffer(\n        vertex_array, position_bindindex,\n        position_buffer, 0, sizeof(GLfloat) * 3);\n\n    glEnableVertexArrayAttrib(\n        vertex_array, normal_location);\n    glVertexArrayAttribFormat(\n        vertex_array, normal_location,\n        3, GL_FLOAT, GL_FALSE, 0);\n\n    glVertexArrayAttribBinding(\n        vertex_array, normal_location,\n        normal_bindindex);\n    glVertexArrayVertexBuffer(\n        vertex_array, normal_bindindex,\n        normal_buffer, 0, sizeof(GLfloat) * 3);\n\n    glClearColor(0.6, 0.8, 0.8, 1.0);\n    glEnable(GL_DEPTH_TEST);\n    glEnable(GL_CULL_FACE);\n\n    while (!glfwWindowShouldClose(window)) {\n        glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);\n\n        glBindVertexArray(vertex_array);\n        glDrawArrays(GL_TRIANGLES, 0, model.num_vertices / 3);\n\n        glfwSwapBuffers(window);\n        glfwPollEvents();\n    }\n\n    free_matrix(mat_mv);\n    free_matrix(mat_mvp);\n\n    glfwTerminate();\n\n    return EXIT_SUCCESS;\n}\n\n\n\u5b9f\u884c\u3059\u308b\u3068\u4ee5\u4e0b\u306e\u3088\u3046\u306b\u8868\u793a\u3055\u308c\u307e\u3059\u3002\n\n\u4ee5\u4e0b\u306f\u7403\u306e\u30e2\u30c7\u30eb\u3092\u8868\u793a\u3057\u305f\u5834\u5408\u3067\u3059\u3002\n\n\n\u521d\u97f3\u30df\u30af\u30e2\u30c7\u30eb\u306e\u8868\u793a\n\u4ee5\u4e0b\u306e\u30b5\u30a4\u30c8\u304b\u3089\u3001\u30e1\u30bf\u30bb\u30b3\u306f\u3061\u3085\u306d\uff08\uff0b\u30dc\u30fc\u30f3ver2.0\uff09nh0217.zip \u3092\u30c0\u30a6\u30f3\u30ed\u30fc\u30c9\u3057\u307e\u3059\u3002\n\n\u30d5\u30a1\u30a4\u30eb\u4fdd\u7ba1\u5eab\uff20\u4e03\u8449\u3000\u4eba\u6c17\u30c0\u30a6\u30f3\u30ed\u30fc\u30c9Top50\n\n\u89e3\u51cd\u3057\u3066Metasequoia\u3067\u958b\u304d\u307e\u3059\u3002\n\u30aa\u30d6\u30b8\u30a7\u30af\u30c8\u30d1\u30cd\u30eb\u3067bone\u3068anchor\u3092\u524a\u9664\u3057\u307e\u3059\u3002\n\n\u3059\u3079\u3066\u306e\u30aa\u30d6\u30b8\u30a7\u30af\u30c8\u3092\u8868\u793a\u3057\u3066\u3001\u3059\u3079\u3066\u306e\u30aa\u30d6\u30b8\u30a7\u30af\u30c8\u3092\u7de8\u96c6\u53ef\u80fd\u306b\u3057\u307e\u3059\u3002\n\n\u3059\u3079\u3066\u306e\u9802\u70b9\u3092\u9078\u629e\u3057\u3066\u3001\u9762\u3092\u4e09\u89d2\u5f62\u5316\u3057\u307e\u3059\u3002\n\n\u79fb\u52d5\u30b3\u30de\u30f3\u30c9\u3067\u3059\u3079\u3066\u306e\u9802\u70b9\u306eY\u5ea7\u6a19\u3092-100\u3057\u307e\u3059\u3002\n\n\u4ee5\u4e0b\u306e\u30d5\u30a9\u30fc\u30de\u30c3\u30c8\u3067OBJ\u30d5\u30a1\u30a4\u30eb\u3092\u66f8\u304d\u3060\u3057\u307e\u3059\u3002\n\n\u4f5c\u6210\u4e2d\u306e\u30d7\u30ed\u30b0\u30e9\u30e0\u3067\u8aad\u307f\u8fbc\u3080\u3068\u4ee5\u4e0b\u306e\u3088\u3046\u306b\u8868\u793a\u3055\u308c\u307e\u3059\u3002\n\n\nBMP\u753b\u50cf\u306e\u8aad\u307f\u8fbc\u307f\n\u30c6\u30af\u30b9\u30c1\u30e3\u30de\u30c3\u30d4\u30f3\u30b0\u3092\u3059\u308b\u305f\u3081\u306b\u306f\u30c6\u30af\u30b9\u30c1\u30e3\u306e\u8aad\u307f\u8fbc\u307f\u3092\u884c\u3046\u5fc5\u8981\u304c\u3042\u308a\u307e\u3059\u3002\u3053\u3053\u3067\u306f\u30c6\u30af\u30b9\u30c1\u30e3\u30d5\u30a1\u30a4\u30eb\u306e\u30d5\u30a9\u30fc\u30de\u30c3\u30c8\u3068\u3057\u3066\u30d3\u30c3\u30c8\u30de\u30c3\u30d7\u3092\u63a1\u7528\u3057\u307e\u3059\u3002\u30d7\u30ed\u30b8\u30a7\u30af\u30c8\u306bBmpLoader.h\u3068BmpLoader.c\u3092\u8ffd\u52a0\u3057\u3066\u3001\u30d3\u30c3\u30c8\u30de\u30c3\u30d7\u753b\u50cf\u3092\u8aad\u307f\u8fbc\u3080\u95a2\u6570\u3092\u4ee5\u4e0b\u306e\u3088\u3046\u306b\u5b9f\u88c5\u3057\u307e\u3059\u3002\n\nBmpLoader.h\n#ifndef BMPLOADER_H_INCLUDE\n#define BMPLOADER_H_INCLUDE\n\n#include <GL/glew.h>\n\n/* BMP\u30d5\u30a1\u30a4\u30eb\u306e\u8aad\u307f\u8fbc\u307f */\nGLuint load_bmp(const char *file_name);\n\n#endif\n\n\n\nBmpLoader.c\n#include <stdio.h>\n#include <stdlib.h>\n#include <GL/glew.h>\n#include \"BmpLoader.h\"\n\n/*==============================*\n** BMP\u30d5\u30a1\u30a4\u30eb\u306e\u8aad\u307f\u8fbc\u307f\n**==============================*/\nGLuint load_bmp(const char *file_name)\n{\n    FILE *fp;\n    unsigned char header[54];\n    unsigned char *data;\n    size_t count, size;\n    int width, height;\n    GLuint texture;\n\n    fp = fopen(file_name, \"rb\");\n    if (!fp) {\n        fprintf(stderr, \"Cannot open %s.\\n\", file_name);\n        exit(EXIT_FAILURE);\n    }\n\n    count = fread(header, 1, sizeof(header), fp);\n    if (count != sizeof(header)) {\n        fprintf(stderr, \"Cannot read bmp file %s.\\n\", file_name);\n        exit(EXIT_FAILURE);\n    }\n\n    if (header[0] != 'B' || header[1] != 'M') {\n        fprintf(stderr, \"Cannot read bmp file %s.\\n\", file_name);\n        exit(EXIT_FAILURE);\n    }\n\n    width = *(int*)(header + 0x12);\n    height = *(int*)(header + 0x16);\n    size = width * height * 3;\n\n    data = malloc(sizeof(unsigned char) * size);\n    if (!data) {\n        fprintf(stderr, \"Memory allocation error.\\n\");\n        exit(EXIT_FAILURE);\n    }\n\n    count = fread(data, sizeof(unsigned char), size, fp);\n    if (count != size) {\n        fprintf(stderr, \"Cannot read bmp file %s.\\n\", file_name);\n        exit(EXIT_FAILURE);\n    }\n\n    fclose(fp);\n\n    glCreateTextures(GL_TEXTURE_2D, 1, &texture);\n    glTextureStorage2D(texture, 1, GL_RGB8, width, height);\n    glTextureSubImage2D(texture, 0, 0, 0, width, height, GL_BGR, GL_UNSIGNED_BYTE, data);\n\n    free(data); \n\n    glTextureParameteri(texture, GL_TEXTURE_MAG_FILTER, GL_LINEAR);\n    glTextureParameteri(texture, GL_TEXTURE_MIN_FILTER, GL_LINEAR);\n\n    return texture;\n}\n\n\n\nUV\u5ea7\u6a19\u306e\u8aad\u307f\u8fbc\u307f\nObjLoader.h\u3001ObjLoader.c\u3092\u62e1\u5f35\u3057\u3066\u3001UV\u5ea7\u6a19\u3092\u8aad\u307f\u8fbc\u3081\u308b\u3088\u3046\u306b\u3057\u307e\u3059\u3002\n\nObjLoader.h\n#ifndef OBJLOADER_H_INCLUDE\n#define OBJLOADER_H_INCLUDE\n\n/* \u30e2\u30c7\u30eb\u30c7\u30fc\u30bf */\ntypedef struct {\n    float *vertices;\n    int num_vertices;\n    float *normals;\n    int num_normals;\n    float *uvs;\n    int num_uvs;\n} model;\n\n/* OBJ\u30d5\u30a1\u30a4\u30eb\u306e\u8aad\u307f\u8fbc\u307f */\nvoid load_obj(model *m, const char *file_name);\n\n#endif\n\n\n\nObjLoader.c\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ObjLoader.h\"\n\n/* \u521d\u671f\u30d0\u30c3\u30d5\u30a1\u30b5\u30a4\u30ba */\n#define DEF_BUF_SIZE 2\n\n/* \u6d6e\u52d5\u5c0f\u6570\u70b9\u6570\u30d0\u30c3\u30d5\u30a1 */\ntypedef struct {\n    int buf_size;\n    int current_index;\n    float *buf;\n} float_buffer;\n\n/* \u6574\u6570\u30d0\u30c3\u30d5\u30a1 */\ntypedef struct {\n    int buf_size;\n    int current_index;\n    int *buf;\n} int_buffer;\n\n/* \u9802\u70b9\u5ea7\u6a19\u306e\u8aad\u307f\u8fbc\u307f */\nvoid read_vertices(const char *line, float_buffer *vs);\n\n/* \u6cd5\u7dda\u30d9\u30af\u30c8\u30eb\u306e\u8aad\u307f\u8fbc\u307f */\nvoid read_normals(const char *line, float_buffer *vns);\n\n/* UV\u5ea7\u6a19\u306e\u8aad\u307f\u8fbc\u307f */\nvoid read_uvs(const char *line, float_buffer *vts);\n\n/* \u30a4\u30f3\u30c7\u30c3\u30af\u30b9\u306e\u8aad\u307f\u8fbc\u307f */\nvoid read_indices(const char *line, int_buffer *fs);\n\n/* \u30e2\u30c7\u30eb\u306e\u4f5c\u6210 */\nvoid create_model(model *m,\n    float_buffer *vs, float_buffer *vns, int_buffer *fs);\n\n/* \u6d6e\u52d5\u5c0f\u6570\u70b9\u6570\u30d0\u30c3\u30d5\u30a1\u306e\u64cd\u4f5c */\nfloat_buffer *alloc_float_buffer(void);\nvoid free_float_buffer(float_buffer *fbuf);\nvoid add_float(float_buffer *fbuf, float value);\nfloat get_float(float_buffer *fbuf, int index);\n\n/* \u6574\u6570\u30d0\u30c3\u30d5\u30a1\u306e\u64cd\u4f5c */\nint_buffer *alloc_int_buffer(void);\nvoid free_int_buffer(int_buffer *ibuf);\nvoid add_int(int_buffer *ibuf, int value);\nint get_int(int_buffer *ibuf, int index);\n\n/*==============================*\n** OBJ\u30d5\u30a1\u30a4\u30eb\u306e\u8aad\u307f\u8fbc\u307f\n**==============================*/\nvoid load_obj(model *m, const char *file_name)\n{\n    FILE *fp;\n    char line[1024];\n    float_buffer *vs, *vns, *vts;\n    int_buffer *fs;\n\n    fp = fopen(file_name, \"r\");\n    if (!fp) {\n        fprintf(stderr, \"Cannot open %s.\\n\", file_name);\n        exit(EXIT_FAILURE);\n    }\n\n    vs = alloc_float_buffer();\n    vns = alloc_float_buffer();\n    vts = alloc_float_buffer();\n    fs = alloc_int_buffer();\n\n    while (!feof(fp)) {\n        fgets(line, sizeof(line), fp);\n        if (line[0] == 'v' && line[1] == ' ') {\n            read_vertices(line, vs);\n        }\n        else if (line[0] == 'v' && line[1] == 'n' && line[2] == ' ') {\n            read_normals(line, vns);\n        }\n        else if (line[0] == 'v' && line[1] == 't' && line[2] == ' ') {\n            read_uvs(line, vts);\n        }\n        else if (line[0] == 'f' && line[1] == ' ') {\n            read_indices(line, fs);\n        }\n    }\n\n    create_model(m, vs, vns, vts, fs);\n\n    free_float_buffer(vs);\n    free_float_buffer(vns);\n    free_float_buffer(vts);\n    free_int_buffer(fs);\n\n    fclose(fp);\n}\n\n/*------------------------------*\n** \u9802\u70b9\u5ea7\u6a19\u306e\u8aad\u307f\u8fbc\u307f\n**------------------------------*/\nvoid read_vertices(const char *line, float_buffer *vs)\n{\n    float x, y, z;\n    int count;\n\n    count = sscanf(line, \"%*s%f%f%f\", &x, &y, &z);\n\n    if (count == 3) {\n        add_float(vs, x);\n        add_float(vs, y);\n        add_float(vs, z);\n    }\n}\n\n/*------------------------------*\n** \u6cd5\u7dda\u30d9\u30af\u30c8\u30eb\u306e\u8aad\u307f\u8fbc\u307f\n**------------------------------*/\nvoid read_normals(const char *line, float_buffer *vns)\n{\n    float x, y, z;\n    int count;\n\n    count = sscanf(line, \"%*s%f%f%f\", &x, &y, &z);\n\n    if (count == 3) {\n        add_float(vns, x);\n        add_float(vns, y);\n        add_float(vns, z);\n    }\n}\n\n/*------------------------------*\n** UV\u5ea7\u6a19\u306e\u8aad\u307f\u8fbc\u307f\n**------------------------------*/\nvoid read_uvs(const char *line, float_buffer *vts)\n{\n    float u, v;\n    int count;\n\n    count = sscanf(line, \"%*s%f%f\", &u, &v);\n\n    if (count == 2) {\n        add_float(vts, u);\n        add_float(vts, v);\n    }\n}\n\n/*------------------------------*\n** \u30a4\u30f3\u30c7\u30c3\u30af\u30b9\u306e\u8aad\u307f\u8fbc\u307f\n**------------------------------*/\nvoid read_indices(const char *line, int_buffer *fs)\n{\n    int v1, v2, v3;\n    int t1, t2, t3;\n    int n1, n2, n3;\n    int count;\n\n    count = sscanf(line,\n        \"%*s %d%*c%d%*c%d \"\n        \"%d%*c%d%*c%d \"\n        \"%d%*c%d%*c%d\", \n        &v1, &t1, &n1, &v2, &t2, &n2, &v3, &t3, &n3);\n\n    if (count == 9) {\n        add_int(fs, v1);\n        add_int(fs, t1);\n        add_int(fs, n1);\n        add_int(fs, v2);\n        add_int(fs, t2);\n        add_int(fs, n2);\n        add_int(fs, v3);\n        add_int(fs, t3);\n        add_int(fs, n3);\n    }\n}\n\n/*------------------------------*\n** \u30e2\u30c7\u30eb\u306e\u4f5c\u6210\n**------------------------------*/\nvoid create_model(model *m, \n    float_buffer *vs, float_buffer *vns, \n    float_buffer *vts, int_buffer *fs)\n{\n    int i, j;\n\n    m->num_vertices = fs->current_index / 3 * 3;\n    m->vertices = malloc(sizeof(float) * m->num_vertices);\n\n    if (!m->vertices) {\n        fprintf(stderr, \"Memory allocation error.\\n\");\n        exit(EXIT_FAILURE);\n    }\n\n    m->num_normals = fs->current_index / 3 * 3;\n    m->normals = malloc(sizeof(float) * m->num_normals);\n\n    if (!m->normals) {\n        fprintf(stderr, \"Memory allocation error.\\n\");\n        exit(EXIT_FAILURE);\n    }\n\n    m->num_uvs = fs->current_index / 3 * 2;\n    m->uvs = malloc(sizeof(float) * m->num_uvs);\n\n    if (!m->uvs) {\n        fprintf(stderr, \"Memory allocation error.\\n\");\n        exit(EXIT_FAILURE);\n    }\n\n    for (i = 0; i < fs->current_index; i++) {\n        int idx = fs->buf[i] - 1;\n        if (i % 3 == 0) {\n            for (j = 0; j < 3; j++) {\n                m->vertices[i / 3 * 3 + j] = vs->buf[idx * 3 + j];\n            }\n        }\n        else if (i % 3 == 1) {\n            for (j = 0; j < 2; j++) {\n                m->uvs[i / 3 * 2 + j] = vts->buf[idx * 2 + j];\n            }\n        }\n        else {\n            for (j = 0; j < 3; j++) {\n                m->normals[i / 3 * 3 + j] = vns->buf[idx * 3 + j];\n            }\n        }\n\n    }\n}\n\n/*------------------------------*\n** \u6d6e\u52d5\u5c0f\u6570\u70b9\u6570\u30d0\u30c3\u30d5\u30a1\u306e\u5272\u308a\u5f53\u3066\n**------------------------------*/\nfloat_buffer *alloc_float_buffer(void)\n{\n    float_buffer *fbuf;\n\n    fbuf = malloc(sizeof(float_buffer));\n    if (!fbuf) {\n        fprintf(stderr, \"Memory allocation error.\\n\");\n        exit(EXIT_FAILURE);\n    }\n\n    fbuf->buf_size = DEF_BUF_SIZE;\n    fbuf->current_index = 0;\n    fbuf->buf = malloc(sizeof(float) * fbuf->buf_size);\n\n    return fbuf;\n}\n\n/*------------------------------*\n** \u6d6e\u52d5\u5c0f\u6570\u70b9\u6570\u30d0\u30c3\u30d5\u30a1\u306e\u89e3\u653e\n**------------------------------*/\nvoid free_float_buffer(float_buffer *fbuf)\n{\n    free(fbuf->buf);\n    free(fbuf);\n}\n\n/*------------------------------*\n** \u30d0\u30c3\u30d5\u30a1\u306b\u6d6e\u52d5\u5c0f\u6570\u70b9\u6570\u3092\u8ffd\u52a0\n**------------------------------*/\nvoid add_float(float_buffer *fbuf, float value)\n{\n    fbuf->buf[fbuf->current_index] = value;\n    fbuf->current_index++;\n    if (fbuf->current_index >= fbuf->buf_size) {\n        fbuf->buf_size *= 2;\n        fbuf->buf = realloc(fbuf->buf, sizeof(float) * fbuf->buf_size);\n        if (!fbuf->buf) {\n            fprintf(stderr, \"Memory allocation error.\\n\");\n            exit(EXIT_FAILURE);\n        }\n    }\n}\n\n/*------------------------------*\n** \u30d0\u30c3\u30d5\u30a1\u304b\u3089\u6d6e\u52d5\u5c0f\u6570\u70b9\u6570\u3092\u53d6\u308a\u51fa\u3057\n**------------------------------*/\nfloat get_float(float_buffer *fbuf, int index)\n{\n    return fbuf->buf[index];\n}\n\n/*------------------------------*\n** \u6574\u6570\u30d0\u30c3\u30d5\u30a1\u306e\u5272\u308a\u5f53\u3066\n**------------------------------*/\nint_buffer *alloc_int_buffer(void)\n{\n    int_buffer *ibuf;\n\n    ibuf = malloc(sizeof(int_buffer));\n    if (!ibuf) {\n        fprintf(stderr, \"Memory allocation error.\\n\");\n        exit(EXIT_FAILURE);\n    }\n\n    ibuf->buf_size = DEF_BUF_SIZE;\n    ibuf->current_index = 0;\n    ibuf->buf = malloc(sizeof(int) * ibuf->buf_size);\n\n    return ibuf;\n}\n\n/*------------------------------*\n** \u6574\u6570\u30d0\u30c3\u30d5\u30a1\u306e\u89e3\u653e\n**------------------------------*/\nvoid free_int_buffer(int_buffer *ibuf)\n{\n    free(ibuf->buf);\n    free(ibuf);\n}\n\n/*------------------------------*\n** \u30d0\u30c3\u30d5\u30a1\u306b\u6574\u6570\u3092\u8ffd\u52a0\n**------------------------------*/\nvoid add_int(int_buffer *ibuf, int value)\n{\n    ibuf->buf[ibuf->current_index] = value;\n    ibuf->current_index++;\n    if (ibuf->current_index >= ibuf->buf_size) {\n        ibuf->buf_size *= 2;\n        ibuf->buf = realloc(ibuf->buf, sizeof(int) * ibuf->buf_size);\n        if (!ibuf->buf) {\n            fprintf(stderr, \"Memory allocation error.\\n\");\n            exit(EXIT_FAILURE);\n        }\n    }\n}\n\n/*------------------------------*\n** \u30d0\u30c3\u30d5\u30a1\u304b\u3089\u6574\u6570\u3092\u53d6\u308a\u51fa\u3057\n**------------------------------*/\nint get_int(int_buffer *ibuf, int index)\n{\n    return ibuf->buf[index];\n}\n\n\n\n\u30c6\u30af\u30b9\u30c1\u30e3\u30de\u30c3\u30d4\u30f3\u30b0\n\u30b7\u30a7\u30fc\u30c0\u3092\u4ee5\u4e0b\u306e\u3088\u3046\u306b\u66f8\u304d\u66ff\u3048\u3066\u3001\u30c6\u30af\u30b9\u30c1\u30e3\u30de\u30c3\u30d4\u30f3\u30b0\u3092\u884c\u3046\u3088\u3046\u306b\u3057\u307e\u3059\u3002\n\nVertex.glsl\n#version 450\n\nlayout (location = 0) in vec3 in_position;\nlayout (location = 1) in vec3 in_normal;\nlayout (location = 2) in vec2 in_uv;\n\nuniform mat4 mv_matrix;\nuniform mat3 normal_matrix;\nuniform mat4 mvp;\n\nout vec4 position;\nout vec3 normal;\nout vec2 uv;\n\nvoid main()\n{\n    uv = in_uv;\n    normal = normalize(normal_matrix * in_normal);\n    position = mv_matrix * vec4(in_position, 1.0);\n\n    gl_Position = mvp * vec4(in_position, 1.0);\n}\n\n\n\nFragment.glsl\n#version 450\n\nin vec4 position;\nin vec3 normal;\nin vec2 uv;\n\nuniform sampler2D texl;\n\nout vec4 out_color;\n\nvoid main()\n{\n    vec4 light = vec4(0.0, 2.0, 4.0, 1.0);\n    vec3 s = normalize(vec3(light - position));\n    vec3 diffusion = vec3(1.0, 1.0, 1.0) * max(dot(s, normal), 0.0);\n    vec3 material = texture2D(texl, uv).rgb;\n    out_color = vec4(diffusion * material, 1.0);\n}\n\n\n\u30b7\u30a7\u30fc\u30c0\u306b\u60c5\u5831\u3092\u53d7\u3051\u6e21\u3059\u3088\u3046\u306bMain.c\u3092\u4ee5\u4e0b\u306e\u3088\u3046\u306b\u66f8\u304d\u66ff\u3048\u307e\u3059\u3002\n\nMain.c\n#include <stdio.h>\n#include <stdlib.h>\n#include <GL/glew.h>\n#include <GLFW/glfw3.h>\n#include \"Init.h\"\n#include \"ShaderLoader.h\"\n#include \"Matrix.h\"\n#include \"ObjLoader.h\"\n#include \"BmpLoader.h\"\n\nint main(void)\n{\n    GLFWwindow *window;\n    GLuint program;\n    model model;\n    GLuint texture, texl;\n    GLuint mv_matrix, normal_matrix, mvp;\n    int i, j;\n\n    float *mat_proj, *mat_view, *mat_model;\n    float *mat_mv, *mat_mvp;\n    float mat_norm[9];\n\n    GLuint position_buffer;\n    GLuint normal_buffer;\n    GLuint uv_buffer;\n\n    GLuint vertex_array;\n\n    const GLuint position_location = 0;\n    const GLuint position_bindindex = 0;\n\n    const GLuint normal_location = 1;\n    const GLuint normal_bindindex = 1;\n\n    const GLuint uv_location = 2;\n    const GLuint uv_bindindex = 2;\n\n    window = init(640, 480, \"Step 04\");\n\n    program = load_shader(\"Vertex.glsl\", \"Fragment.glsl\");\n\n    load_obj(&model, \"miku.obj\");\n\n    mat_proj = alloc_matrix();\n    set_perspective_matrix(mat_proj,\n        45.0, 640.0f / 480.0f, 0.1f, 100.0f);\n\n    mat_view = alloc_matrix();\n    set_lookat_matrix(mat_view,\n        1.0f, 1.0f, 3.0f,\n        0.0f, 0.0f, 0.0f,\n        0.0f, 1.0f, 0.0f);\n\n    mat_model = alloc_matrix();\n    set_identity_matrix(mat_model);\n\n    mat_mv = alloc_matrix();\n    multiply_matrix(mat_mv, mat_view, mat_model);\n\n    mat_mvp = alloc_matrix();\n    multiply_matrix(mat_mvp, mat_proj, mat_mv);\n\n    free_matrix(mat_proj);\n    free_matrix(mat_view);\n    free_matrix(mat_model);\n\n    mv_matrix = glGetUniformLocation(program, \"mv_matrix\");\n    glUniformMatrix4fv(mv_matrix, 1, GL_FALSE, mat_mv);\n\n    for (i = 0; i < 3; i++) {\n        for (j = 0; j < 3; j++) {\n            mat_norm[i * 3 + j] = mat_mv[i * 4 + j];\n        }\n    }\n    normal_matrix = glGetUniformLocation(program, \"normal_matrix\");\n    glUniformMatrix3fv(normal_matrix, 1, GL_FALSE, mat_norm);\n\n    mvp = glGetUniformLocation(program, \"mvp\");\n    glUniformMatrix4fv(mvp, 1, GL_FALSE, mat_mvp);\n\n    texture = load_bmp(\"miku.bmp\");\n    texl = glGetUniformLocation(program, \"texl\");\n\n    glActiveTexture(GL_TEXTURE0);\n    glBindTexture(GL_TEXTURE_2D, texture);\n    glUniform1i(texl, 0);\n\n    glCreateBuffers(1, &position_buffer);\n    glNamedBufferData(position_buffer,\n        sizeof(float) * model.num_vertices,\n        model.vertices,\n        GL_STATIC_DRAW);\n\n    glCreateBuffers(1, &normal_buffer);\n    glNamedBufferData(normal_buffer,\n        sizeof(float) * model.num_normals,\n        model.normals,\n        GL_STATIC_DRAW);\n\n    glCreateBuffers(1, &uv_buffer);\n    glNamedBufferData(uv_buffer,\n        sizeof(float) * model.num_uvs,\n        model.uvs,\n        GL_STATIC_DRAW);\n\n    printf(\"%d %d %d\\n\", model.num_vertices, model.num_normals, model.num_uvs);\n\n    glCreateVertexArrays(1, &vertex_array);\n\n    glEnableVertexArrayAttrib(\n        vertex_array, position_location);\n    glVertexArrayAttribFormat(\n        vertex_array, position_location,\n        3, GL_FLOAT, GL_FALSE, 0);\n\n    glVertexArrayAttribBinding(\n        vertex_array, position_location,\n        position_bindindex);\n    glVertexArrayVertexBuffer(\n        vertex_array, position_bindindex,\n        position_buffer, 0, sizeof(GLfloat) * 3);\n\n    glEnableVertexArrayAttrib(\n        vertex_array, normal_location);\n    glVertexArrayAttribFormat(\n        vertex_array, normal_location,\n        3, GL_FLOAT, GL_FALSE, 0);\n\n    glVertexArrayAttribBinding(\n        vertex_array, normal_location,\n        normal_bindindex);\n    glVertexArrayVertexBuffer(\n        vertex_array, normal_bindindex,\n        normal_buffer, 0, sizeof(GLfloat) * 3);\n\n    glEnableVertexArrayAttrib(\n        vertex_array, uv_location);\n    glVertexArrayAttribFormat(\n        vertex_array, uv_location,\n        2, GL_FLOAT, GL_FALSE, 0);\n\n    glVertexArrayAttribBinding(\n        vertex_array, uv_location,\n        uv_bindindex);\n    glVertexArrayVertexBuffer(\n        vertex_array, uv_bindindex,\n        uv_buffer, 0, sizeof(GLfloat) * 2);\n\n    glClearColor(0.6, 0.8, 0.8, 1.0);\n    glEnable(GL_DEPTH_TEST);\n    glEnable(GL_CULL_FACE);\n\n    while (!glfwWindowShouldClose(window)) {\n        glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);\n\n        glBindVertexArray(vertex_array);\n        glDrawArrays(GL_TRIANGLES, 0, model.num_vertices / 3);\n\n        glfwSwapBuffers(window);\n        glfwPollEvents();\n    }\n\n    free_matrix(mat_mv);\n    free_matrix(mat_mvp);\n\n    glfwTerminate();\n\n    return EXIT_SUCCESS;\n}\n\n\n\u521d\u97f3\u30df\u30af\u306e\u30e2\u30c7\u30eb\u3092Metasequoia\u3092\u4f7f\u3063\u3066\u4ee5\u4e0b\u306e\u8a2d\u5b9a\u3067\u66f8\u304d\u3060\u3057\u307e\u3059\u3002\n\n\u30e2\u30c7\u30eb\u306b\u4ed8\u5c5e\u3057\u3066\u3044\u308b\u30c6\u30af\u30b9\u30c1\u30e3\u753b\u50cf\u309224bit\u30d3\u30c3\u30c8\u30de\u30c3\u30d7\u306b\u5909\u63db\u3057\u307e\u3059\u3002\u4f8b\u3048\u3070Photoshop\u3067\u306f\u4ee5\u4e0b\u306e\u3088\u3046\u306b\u8a2d\u5b9a\u3057\u307e\u3059\u3002\n\n\u30d7\u30ed\u30b0\u30e9\u30e0\u3092\u5b9f\u884c\u3059\u308b\u3068\u4ee5\u4e0b\u306e\u3088\u3046\u306b\u8868\u793a\u3055\u308c\u307e\u3059\u3002\n\n\u3064\u3044\u306b\u521d\u97f3\u30df\u30af\u304c\u8868\u793a\u3055\u308c\u307e\u3057\u305f\u3002\n# \u306f\u3058\u3081\u306b\nOpenGL\u3068C\u8a00\u8a9e\u3092\u4f7f\u3063\u3066\u521d\u97f3\u30df\u30af\u306e3D\u30e2\u30c7\u30eb\u3092\u8868\u793a\u3059\u308b\u30d7\u30ed\u30b0\u30e9\u30e0\u3092\u4f5c\u6210\u306b\u6311\u6226\u3057\u3066\u3044\u307e\u3059\u3002\u4eca\u56de\u306f3D\u30e2\u30c7\u30eb\u306e\u9670\u5f71\u4ed8\u3051\u3068\u30c6\u30af\u30b9\u30c1\u30e3\u30de\u30c3\u30d4\u30f3\u30b0\u3092\u884c\u3044\u307e\u3059\u3002\n\n# \u904e\u53bb\u306e\u8a18\u4e8b\n- [\u4eca\u3069\u304d\u306eOpenGL\u3068C\u8a00\u8a9e\u3067\u521d\u97f3\u30df\u30af\u3092\u8868\u793a\u3059\u308b(\u305d\u306e1): \u30a6\u30a4\u30f3\u30c9\u30a6\u306e\u8868\u793a](http://qiita.com/lambdataro/items/02668f5e542ffe9e80df)\n- [\u4eca\u3069\u304d\u306eOpenGL\u3068C\u8a00\u8a9e\u3067\u521d\u97f3\u30df\u30af\u3092\u8868\u793a\u3059\u308b(\u305d\u306e2): \u30d7\u30ea\u30df\u30c6\u30a3\u30d6\u306e\u63cf\u753b](http://qiita.com/lambdataro/items/c396dcd5fd12b56f1afb)\n- [\u4eca\u3069\u304d\u306eOpenGL\u3068C\u8a00\u8a9e\u3067\u521d\u97f3\u30df\u30af\u3092\u8868\u793a\u3059\u308b(\u305d\u306e3): 3D\u30e2\u30c7\u30eb\u306e\u8aad\u307f\u8fbc\u307f\u3068\u900f\u8996\u6295\u5f71](http://qiita.com/lambdataro/items/304e4d494b8547c43893)\n\n# \u9670\u5f71\u3092\u4ed8\u3051\u308b\n\u9670\u5f71\u3092\u3064\u3051\u308b\u305f\u3081\u306b\u3001\u30b7\u30a7\u30fc\u30c0\u3092\u62e1\u5f35\u3057\u307e\u3059\u3002\u4ee5\u4e0b\u306f\u7a7a\u9593\u4e0a\u306b\u5e73\u884c\u5149\u6e90\u3092\u914d\u7f6e\u3057\u3066\u3001\u30e9\u30f3\u30d0\u30fc\u30c8\u306e\u4f59\u5f26\u5247\u306b\u5f93\u3063\u3066\u62e1\u6563\u53cd\u5c04\u3092\u8a08\u7b97\u3059\u308b\u30b7\u30a7\u30fc\u30c0\u3067\u3059\u3002\n\n```glsl:Vertex.glsl\n#version 450\n\nlayout (location = 0) in vec3 in_position;\nlayout (location = 1) in vec3 in_normal;\n\nuniform mat4 mv_matrix;\nuniform mat3 normal_matrix;\nuniform mat4 mvp;\n\nout vec3 color;\n\nvoid main()\n{\n    vec3 n = normalize(normal_matrix * in_normal);\n    \n    vec4 camera = mv_matrix * vec4(in_position, 1.0);\n    vec4 light = vec4(4.0, 4.0, 4.0, 1.0);\n    vec3 s = normalize(vec3(light - camera));\n\n    color = vec3(1.0, 1.0, 1.0) * max(dot(s, n), 0.0);\n    gl_Position = mvp * vec4(in_position, 1.0);\n}\n```\n\n```glsl:Fragment.glsl\n#version 450\n\nin vec3 color;\n\nout vec4 out_color;\n\nvoid main()\n{\n    out_color = vec4(color, 1.0);\n}\n```\n\n\u3053\u306e\u30b7\u30a7\u30fc\u30c0\u306f\u3001\u9802\u70b9\u4f4d\u7f6e\u3001\u9802\u70b9\u306e\u6cd5\u7dda\u3001\u30e2\u30c7\u30eb\u30d3\u30e5\u30fc\u884c\u5217\u3001\u6b63\u898f\u5316\u884c\u5217\u3001MVP\u884c\u5217\u3092\u53d7\u3051\u53d6\u308b\u3002\u3053\u308c\u3089\u306e\u3046\u3061\u9802\u70b9\u306e\u6cd5\u7dda\u306fOBJ\u30d5\u30a1\u30a4\u30eb\u304b\u3089\u8aad\u307f\u8fbc\u3080\u3053\u3068\u306b\u3057\u307e\u3059\u3002Metasequoia\u3067\u306fOBJ\u30d5\u30a1\u30a4\u30eb\u3092\u4fdd\u5b58\u3059\u308b\u3068\u304d\u306b\u4ee5\u4e0b\u306e\u3088\u3046\u306b\u8a2d\u5b9a\u3059\u308b\u3053\u3068\u3067\u3001\u6cd5\u7dda\u3092\u51fa\u529b\u3067\u304d\u307e\u3059\u3002\n\n![miku27.png](https://qiita-image-store.s3.amazonaws.com/0/70306/93859c97-d971-5de2-1da1-52a4a7889e67.png)\n\n\u3053\u306e\u8a2d\u5b9a\u3067\u7acb\u65b9\u4f53\u3092\u51fa\u529b\u3059\u308b\u3068\u4ee5\u4e0b\u306e\u3088\u3046\u306aOBJ\u30d5\u30a1\u30a4\u30eb\u304c\u5f97\u3089\u308c\u307e\u3059\u3002\n\n```\n# Created by Metasequoia\n\nv -0.500000 0.500000 0.500000\nv -0.500000 -0.500000 0.500000\nv 0.500000 0.500000 0.500000\nv 0.500000 -0.500000 0.500000\nv 0.500000 0.500000 -0.500000\nv 0.500000 -0.500000 -0.500000\nv -0.500000 0.500000 -0.500000\nv -0.500000 -0.500000 -0.500000\n# 8 vertices\n\nvn 0.00000 0.00000 1.00000\nvn 1.00000 0.00000 0.00000\nvn 0.00000 0.00000 -1.00000\nvn -1.00000 0.00000 0.00000\nvn 0.00000 1.00000 0.00000\nvn 0.00000 -1.00000 0.00000\n# 6 normal vertices\n\nf 4//1 3//1 1//1\nf 2//1 4//1 1//1\nf 6//2 5//2 3//2\nf 4//2 6//2 3//2\nf 8//3 7//3 5//3\nf 6//3 8//3 5//3\nf 2//4 1//4 7//4\nf 8//4 2//4 7//4\nf 3//5 5//5 7//5\nf 1//5 3//5 7//5\nf 6//6 4//6 2//6\nf 8//6 6//6 2//6\n# 12 elements\n```\n\n\u4ee5\u4e0b\u306f`ObjLoader.h`\u3068`ObjLoader.c`\u3092\u3001\u4e0a\u306e\u3088\u3046\u306aOBJ\u30d5\u30a1\u30a4\u30eb\u3092\u8aad\u307f\u8fbc\u3081\u308b\u3088\u3046\u306b\u62e1\u5f35\u3057\u305f\u3082\u306e\u3067\u3059\u3002\n\n```c:ObjLoader.h\n#ifndef OBJLOADER_H_INCLUDE\n#define OBJLOADER_H_INCLUDE\n\n/* \u30e2\u30c7\u30eb\u30c7\u30fc\u30bf */\ntypedef struct {\n    float *vertices;\n    int num_vertices;\n    float *normals;\n    int num_normals;\n} model;\n\n/* OBJ\u30d5\u30a1\u30a4\u30eb\u306e\u8aad\u307f\u8fbc\u307f */\nvoid load_obj(model *m, const char *file_name);\n\n#endif\n```\n\n```c:ObjLoader.c\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ObjLoader.h\"\n\n/* \u521d\u671f\u30d0\u30c3\u30d5\u30a1\u30b5\u30a4\u30ba */\n#define DEF_BUF_SIZE 2\n\n/* \u6d6e\u52d5\u5c0f\u6570\u70b9\u6570\u30d0\u30c3\u30d5\u30a1 */\ntypedef struct {\n    int buf_size;\n    int current_index;\n    float *buf;\n} float_buffer;\n\n/* \u6574\u6570\u30d0\u30c3\u30d5\u30a1 */\ntypedef struct {\n    int buf_size;\n    int current_index;\n    int *buf;\n} int_buffer;\n\n/* \u9802\u70b9\u5ea7\u6a19\u306e\u8aad\u307f\u8fbc\u307f */\nvoid read_vertices(const char *line, float_buffer *vs);\n\n/* \u6cd5\u7dda\u30d9\u30af\u30c8\u30eb\u306e\u8aad\u307f\u8fbc\u307f */\nvoid read_normals(const char *line, float_buffer *vns);\n\n/* \u30a4\u30f3\u30c7\u30c3\u30af\u30b9\u306e\u8aad\u307f\u8fbc\u307f */\nvoid read_indices(const char *line, int_buffer *fs);\n\n/* \u30e2\u30c7\u30eb\u306e\u4f5c\u6210 */\nvoid create_model(model *m,\n    float_buffer *vs, float_buffer *vns, int_buffer *fs);\n\n/* \u6d6e\u52d5\u5c0f\u6570\u70b9\u6570\u30d0\u30c3\u30d5\u30a1\u306e\u64cd\u4f5c */\nfloat_buffer *alloc_float_buffer(void);\nvoid free_float_buffer(float_buffer *fbuf);\nvoid add_float(float_buffer *fbuf, float value);\nfloat get_float(float_buffer *fbuf, int index);\n\n/* \u6574\u6570\u30d0\u30c3\u30d5\u30a1\u306e\u64cd\u4f5c */\nint_buffer *alloc_int_buffer(void);\nvoid free_int_buffer(int_buffer *ibuf);\nvoid add_int(int_buffer *ibuf, int value);\nint get_int(int_buffer *ibuf, int index);\n\n/*==============================*\n** OBJ\u30d5\u30a1\u30a4\u30eb\u306e\u8aad\u307f\u8fbc\u307f\n**==============================*/\nvoid load_obj(model *m, const char *file_name)\n{\n    FILE *fp;\n    char line[1024];\n    float_buffer *vs, *vns;\n    int_buffer *fs;\n\n    fp = fopen(file_name, \"r\");\n    if (!fp) {\n        fprintf(stderr, \"Cannot open %s.\\n\", file_name);\n        exit(EXIT_FAILURE);\n    }\n\n    vs = alloc_float_buffer();\n    vns = alloc_float_buffer();\n    fs = alloc_int_buffer();\n\n    while (!feof(fp)) {\n        fgets(line, sizeof(line), fp);\n        if (line[0] == 'v' && line[1] == ' ') {\n            read_vertices(line, vs);\n        }\n        else if (line[0] == 'v' && line[1] == 'n' && line[2] == ' ') {\n            read_normals(line, vns);\n        }\n        else if (line[0] == 'f' && line[1] == ' ') {\n            read_indices(line, fs);\n        }\n    }\n\n    create_model(m, vs, vns, fs);\n\n    free_float_buffer(vs);\n    free_float_buffer(vns);\n    free_int_buffer(fs);\n\n    fclose(fp);\n}\n\n/*------------------------------*\n** \u9802\u70b9\u5ea7\u6a19\u306e\u8aad\u307f\u8fbc\u307f\n**------------------------------*/\nvoid read_vertices(const char *line, float_buffer *vs)\n{\n    float x, y, z;\n    int count;\n\n    count = sscanf(line, \"%*s%f%f%f\", &x, &y, &z);\n\n    if (count == 3) {\n        add_float(vs, x);\n        add_float(vs, y);\n        add_float(vs, z);\n    }\n}\n\n/*------------------------------*\n** \u6cd5\u7dda\u30d9\u30af\u30c8\u30eb\u306e\u8aad\u307f\u8fbc\u307f\n**------------------------------*/\nvoid read_normals(const char *line, float_buffer *vns)\n{\n    float x, y, z;\n    int count;\n\n    count = sscanf(line, \"%*s%f%f%f\", &x, &y, &z);\n\n    if (count == 3) {\n        add_float(vns, x);\n        add_float(vns, y);\n        add_float(vns, z);\n    }\n}\n\n/*------------------------------*\n** \u30a4\u30f3\u30c7\u30c3\u30af\u30b9\u306e\u8aad\u307f\u8fbc\u307f\n**------------------------------*/\nvoid read_indices(const char *line, int_buffer *fs)\n{\n    int v1, v2, v3;\n    int n1, n2, n3;\n    int count;\n\n    count = sscanf(line,\n        \"%*s %d%*[/]%d %d%*[/]%d %d%*[/]%d\", \n        &v1, &n1, &v2, &n2, &v3, &n3);\n\n    if (count == 6) {\n        add_int(fs, v1);\n        add_int(fs, n1);\n        add_int(fs, v2);\n        add_int(fs, n2);\n        add_int(fs, v3);\n        add_int(fs, n3);\n    }\n}\n\n/*------------------------------*\n** \u30e2\u30c7\u30eb\u306e\u4f5c\u6210\n**------------------------------*/\nvoid create_model(model *m, \n    float_buffer *vs, float_buffer *vns, int_buffer *fs)\n{\n    int i, j;\n\n    m->num_vertices = fs->current_index / 2 * 3;\n    m->vertices = malloc(sizeof(float) * m->num_vertices);\n\n    if (!m->vertices) {\n        fprintf(stderr, \"Memory allocation error.\\n\");\n        exit(EXIT_FAILURE);\n    }\n\n    m->num_normals = fs->current_index / 2 * 3;\n    m->normals = malloc(sizeof(float) * m->num_normals);\n\n    if (!m->normals) {\n        fprintf(stderr, \"Memory allocation error.\\n\");\n        exit(EXIT_FAILURE);\n    }\n\n    for (i = 0; i < fs->current_index; i++) {\n        int idx = fs->buf[i] - 1;\n        if (i % 2 == 0) {\n            for (j = 0; j < 3; j++) {\n                m->vertices[i / 2 * 3 + j] = vs->buf[idx * 3 + j];\n            }\n        }\n        else {\n            for (j = 0; j < 3; j++) {\n                m->normals[i / 2 * 3 + j] = vns->buf[idx * 3 + j];\n            }\n        }\n        \n    }\n}\n\n/*------------------------------*\n** \u6d6e\u52d5\u5c0f\u6570\u70b9\u6570\u30d0\u30c3\u30d5\u30a1\u306e\u5272\u308a\u5f53\u3066\n**------------------------------*/\nfloat_buffer *alloc_float_buffer(void)\n{\n    float_buffer *fbuf;\n\n    fbuf = malloc(sizeof(float_buffer));\n    if (!fbuf) {\n        fprintf(stderr, \"Memory allocation error.\\n\");\n        exit(EXIT_FAILURE);\n    }\n\n    fbuf->buf_size = DEF_BUF_SIZE;\n    fbuf->current_index = 0;\n    fbuf->buf = malloc(sizeof(float) * fbuf->buf_size);\n\n    return fbuf;\n}\n\n/*------------------------------*\n** \u6d6e\u52d5\u5c0f\u6570\u70b9\u6570\u30d0\u30c3\u30d5\u30a1\u306e\u89e3\u653e\n**------------------------------*/\nvoid free_float_buffer(float_buffer *fbuf)\n{\n    free(fbuf->buf);\n    free(fbuf);\n}\n\n/*------------------------------*\n** \u30d0\u30c3\u30d5\u30a1\u306b\u6d6e\u52d5\u5c0f\u6570\u70b9\u6570\u3092\u8ffd\u52a0\n**------------------------------*/\nvoid add_float(float_buffer *fbuf, float value)\n{\n    fbuf->buf[fbuf->current_index] = value;\n    fbuf->current_index++;\n    if (fbuf->current_index >= fbuf->buf_size) {\n        fbuf->buf_size *= 2;\n        fbuf->buf = realloc(fbuf->buf, sizeof(float) * fbuf->buf_size);\n        if (!fbuf->buf) {\n            fprintf(stderr, \"Memory allocation error.\\n\");\n            exit(EXIT_FAILURE);\n        }\n    }\n}\n\n/*------------------------------*\n** \u30d0\u30c3\u30d5\u30a1\u304b\u3089\u6d6e\u52d5\u5c0f\u6570\u70b9\u6570\u3092\u53d6\u308a\u51fa\u3057\n**------------------------------*/\nfloat get_float(float_buffer *fbuf, int index)\n{\n    return fbuf->buf[index];\n}\n\n/*------------------------------*\n** \u6574\u6570\u30d0\u30c3\u30d5\u30a1\u306e\u5272\u308a\u5f53\u3066\n**------------------------------*/\nint_buffer *alloc_int_buffer(void)\n{\n    int_buffer *ibuf;\n\n    ibuf = malloc(sizeof(int_buffer));\n    if (!ibuf) {\n        fprintf(stderr, \"Memory allocation error.\\n\");\n        exit(EXIT_FAILURE);\n    }\n\n    ibuf->buf_size = DEF_BUF_SIZE;\n    ibuf->current_index = 0;\n    ibuf->buf = malloc(sizeof(int) * ibuf->buf_size);\n\n    return ibuf;\n}\n\n/*------------------------------*\n** \u6574\u6570\u30d0\u30c3\u30d5\u30a1\u306e\u89e3\u653e\n**------------------------------*/\nvoid free_int_buffer(int_buffer *ibuf)\n{\n    free(ibuf->buf);\n    free(ibuf);\n}\n\n/*------------------------------*\n** \u30d0\u30c3\u30d5\u30a1\u306b\u6574\u6570\u3092\u8ffd\u52a0\n**------------------------------*/\nvoid add_int(int_buffer *ibuf, int value)\n{\n    ibuf->buf[ibuf->current_index] = value;\n    ibuf->current_index++;\n    if (ibuf->current_index >= ibuf->buf_size) {\n        ibuf->buf_size *= 2;\n        ibuf->buf = realloc(ibuf->buf, sizeof(int) * ibuf->buf_size);\n        if (!ibuf->buf) {\n            fprintf(stderr, \"Memory allocation error.\\n\");\n            exit(EXIT_FAILURE);\n        }\n    }\n}\n\n/*------------------------------*\n** \u30d0\u30c3\u30d5\u30a1\u304b\u3089\u6574\u6570\u3092\u53d6\u308a\u51fa\u3057\n**------------------------------*/\nint get_int(int_buffer *ibuf, int index)\n{\n    return ibuf->buf[index];\n}\n```\n\n`Main.c`\u306f\u4ee5\u4e0b\u306e\u3088\u3046\u306b\u5909\u66f4\u3057\u307e\u3059\u3002\n\n```c:Main.c\n#include <stdio.h>\n#include <stdlib.h>\n#include <GL/glew.h>\n#include <GLFW/glfw3.h>\n#include \"Init.h\"\n#include \"ShaderLoader.h\"\n#include \"Matrix.h\"\n#include \"ObjLoader.h\"\n\nint main(void)\n{\n    GLFWwindow *window;\n    GLuint program;\n    model model;\n    GLuint mv_matrix, normal_matrix, mvp;\n    int i, j;\n\n    float *mat_proj, *mat_view, *mat_model;\n    float *mat_mv, *mat_mvp;\n    float mat_norm[9];\n\n    GLuint position_buffer;\n    GLuint normal_buffer;\n\n    GLuint vertex_array;\n\n    const GLuint position_location = 0;\n    const GLuint position_bindindex = 0;\n\n    const GLuint normal_location = 1;\n    const GLuint normal_bindindex = 1;\n\n    window = init(640, 480, \"Step 04\");\n\n    program = load_shader(\"Vertex.glsl\", \"Fragment.glsl\");\n\n    load_obj(&model, \"cube.obj\");\n\n    mat_proj = alloc_matrix();\n    set_perspective_matrix(mat_proj,\n        45.0, 640.0f / 480.0f, 0.1f, 100.0f);\n\n    mat_view = alloc_matrix();\n    set_lookat_matrix(mat_view,\n        2.0f, 3.0f, 3.0f,\n        0.0f, 0.0f, 0.0f,\n        0.0f, 1.0f, 0.0f);\n\n    mat_model = alloc_matrix();\n    set_identity_matrix(mat_model);\n\n    mat_mv = alloc_matrix();\n    multiply_matrix(mat_mv, mat_view, mat_model);\n\n    mat_mvp = alloc_matrix();\n    multiply_matrix(mat_mvp, mat_proj, mat_mv);\n\n    free_matrix(mat_proj);\n    free_matrix(mat_view);\n    free_matrix(mat_model);\n\n    mv_matrix = glGetUniformLocation(program, \"mv_matrix\");\n    glUniformMatrix4fv(mv_matrix, 1, GL_FALSE, mat_mv);\n\n    for (i = 0; i < 3; i++) {\n        for (j = 0; j < 3; j++) {\n            mat_norm[i * 3 + j] = mat_mv[i * 4 + j];\n        }\n    }\n    normal_matrix = glGetUniformLocation(program, \"normal_matrix\");\n    glUniformMatrix3fv(normal_matrix, 1, GL_FALSE, mat_norm);\n\n    mvp = glGetUniformLocation(program, \"mvp\");\n    glUniformMatrix4fv(mvp, 1, GL_FALSE, mat_mvp);\n\n    glCreateBuffers(1, &position_buffer);\n    glNamedBufferData(position_buffer,\n        sizeof(float) * model.num_vertices,\n        model.vertices,\n        GL_STATIC_DRAW);\n\n    glCreateBuffers(1, &normal_buffer);\n    glNamedBufferData(normal_buffer,\n        sizeof(float) * model.num_normals,\n        model.normals,\n        GL_STATIC_DRAW);\n\n    glCreateVertexArrays(1, &vertex_array);\n\n    glEnableVertexArrayAttrib(\n        vertex_array, position_location);\n    glVertexArrayAttribFormat(\n        vertex_array, position_location,\n        3, GL_FLOAT, GL_FALSE, 0);\n\n    glVertexArrayAttribBinding(\n        vertex_array, position_location,\n        position_bindindex);\n    glVertexArrayVertexBuffer(\n        vertex_array, position_bindindex,\n        position_buffer, 0, sizeof(GLfloat) * 3);\n\n    glEnableVertexArrayAttrib(\n        vertex_array, normal_location);\n    glVertexArrayAttribFormat(\n        vertex_array, normal_location,\n        3, GL_FLOAT, GL_FALSE, 0);\n\n    glVertexArrayAttribBinding(\n        vertex_array, normal_location,\n        normal_bindindex);\n    glVertexArrayVertexBuffer(\n        vertex_array, normal_bindindex,\n        normal_buffer, 0, sizeof(GLfloat) * 3);\n\n    glClearColor(0.6, 0.8, 0.8, 1.0);\n    glEnable(GL_DEPTH_TEST);\n    glEnable(GL_CULL_FACE);\n\n    while (!glfwWindowShouldClose(window)) {\n        glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);\n\n        glBindVertexArray(vertex_array);\n        glDrawArrays(GL_TRIANGLES, 0, model.num_vertices / 3);\n\n        glfwSwapBuffers(window);\n        glfwPollEvents();\n    }\n\n    free_matrix(mat_mv);\n    free_matrix(mat_mvp);\n\n    glfwTerminate();\n\n    return EXIT_SUCCESS;\n}\n```\n\n\u5b9f\u884c\u3059\u308b\u3068\u4ee5\u4e0b\u306e\u3088\u3046\u306b\u8868\u793a\u3055\u308c\u307e\u3059\u3002\n\n![miku28.png](https://qiita-image-store.s3.amazonaws.com/0/70306/767ef90e-02d0-48b1-c8a2-c5795e0c579e.png)\n\n\u4ee5\u4e0b\u306f\u7403\u306e\u30e2\u30c7\u30eb\u3092\u8868\u793a\u3057\u305f\u5834\u5408\u3067\u3059\u3002\n\n![miku29.png](https://qiita-image-store.s3.amazonaws.com/0/70306/b4c88f6d-e2c7-ff6c-d8cf-18bd9b7e6df3.png)\n\n# \u521d\u97f3\u30df\u30af\u30e2\u30c7\u30eb\u306e\u8868\u793a\n\u4ee5\u4e0b\u306e\u30b5\u30a4\u30c8\u304b\u3089\u3001\u30e1\u30bf\u30bb\u30b3\u306f\u3061\u3085\u306d\uff08\uff0b\u30dc\u30fc\u30f3ver2.0\uff09`nh0217.zip` \u3092\u30c0\u30a6\u30f3\u30ed\u30fc\u30c9\u3057\u307e\u3059\u3002\n\n- [\u30d5\u30a1\u30a4\u30eb\u4fdd\u7ba1\u5eab\uff20\u4e03\u8449\u3000\u4eba\u6c17\u30c0\u30a6\u30f3\u30ed\u30fc\u30c9Top50](http://nanoha.kirara.st/3dcg/file/dlrank.php?top=50)\n\n\u89e3\u51cd\u3057\u3066Metasequoia\u3067\u958b\u304d\u307e\u3059\u3002\n\n\u30aa\u30d6\u30b8\u30a7\u30af\u30c8\u30d1\u30cd\u30eb\u3067bone\u3068anchor\u3092\u524a\u9664\u3057\u307e\u3059\u3002\n\n![miku30.png](https://qiita-image-store.s3.amazonaws.com/0/70306/d1317a89-d2e8-bcda-172d-c0090bc2073b.png)\n\n\u3059\u3079\u3066\u306e\u30aa\u30d6\u30b8\u30a7\u30af\u30c8\u3092\u8868\u793a\u3057\u3066\u3001\u3059\u3079\u3066\u306e\u30aa\u30d6\u30b8\u30a7\u30af\u30c8\u3092\u7de8\u96c6\u53ef\u80fd\u306b\u3057\u307e\u3059\u3002\n\n![miku32.png](https://qiita-image-store.s3.amazonaws.com/0/70306/9fcf5a8c-2330-6b54-3a6b-70244a64f8e9.png)\n\n\u3059\u3079\u3066\u306e\u9802\u70b9\u3092\u9078\u629e\u3057\u3066\u3001\u9762\u3092\u4e09\u89d2\u5f62\u5316\u3057\u307e\u3059\u3002\n\n![miku33.png](https://qiita-image-store.s3.amazonaws.com/0/70306/4250dbc9-8779-b4c7-fb09-622aeac8ca71.png)\n\n\u79fb\u52d5\u30b3\u30de\u30f3\u30c9\u3067\u3059\u3079\u3066\u306e\u9802\u70b9\u306eY\u5ea7\u6a19\u3092-100\u3057\u307e\u3059\u3002\n\n![miku34.png](https://qiita-image-store.s3.amazonaws.com/0/70306/22f08a66-bf03-c638-9994-3c5aaef58149.png)\n\n\u4ee5\u4e0b\u306e\u30d5\u30a9\u30fc\u30de\u30c3\u30c8\u3067OBJ\u30d5\u30a1\u30a4\u30eb\u3092\u66f8\u304d\u3060\u3057\u307e\u3059\u3002\n\n![miku35.png](https://qiita-image-store.s3.amazonaws.com/0/70306/928c2633-253c-ed14-cf34-985e7afc5a1c.png)\n\n\u4f5c\u6210\u4e2d\u306e\u30d7\u30ed\u30b0\u30e9\u30e0\u3067\u8aad\u307f\u8fbc\u3080\u3068\u4ee5\u4e0b\u306e\u3088\u3046\u306b\u8868\u793a\u3055\u308c\u307e\u3059\u3002\n\n![miku36.png](https://qiita-image-store.s3.amazonaws.com/0/70306/19fd975d-99e7-f881-2e6c-b8a00ad4250f.png)\n\n# BMP\u753b\u50cf\u306e\u8aad\u307f\u8fbc\u307f\n\u30c6\u30af\u30b9\u30c1\u30e3\u30de\u30c3\u30d4\u30f3\u30b0\u3092\u3059\u308b\u305f\u3081\u306b\u306f\u30c6\u30af\u30b9\u30c1\u30e3\u306e\u8aad\u307f\u8fbc\u307f\u3092\u884c\u3046\u5fc5\u8981\u304c\u3042\u308a\u307e\u3059\u3002\u3053\u3053\u3067\u306f\u30c6\u30af\u30b9\u30c1\u30e3\u30d5\u30a1\u30a4\u30eb\u306e\u30d5\u30a9\u30fc\u30de\u30c3\u30c8\u3068\u3057\u3066\u30d3\u30c3\u30c8\u30de\u30c3\u30d7\u3092\u63a1\u7528\u3057\u307e\u3059\u3002\u30d7\u30ed\u30b8\u30a7\u30af\u30c8\u306b`BmpLoader.h`\u3068`BmpLoader.c`\u3092\u8ffd\u52a0\u3057\u3066\u3001\u30d3\u30c3\u30c8\u30de\u30c3\u30d7\u753b\u50cf\u3092\u8aad\u307f\u8fbc\u3080\u95a2\u6570\u3092\u4ee5\u4e0b\u306e\u3088\u3046\u306b\u5b9f\u88c5\u3057\u307e\u3059\u3002\n\n```c:BmpLoader.h\n#ifndef BMPLOADER_H_INCLUDE\n#define BMPLOADER_H_INCLUDE\n\n#include <GL/glew.h>\n\n/* BMP\u30d5\u30a1\u30a4\u30eb\u306e\u8aad\u307f\u8fbc\u307f */\nGLuint load_bmp(const char *file_name);\n\n#endif\n```\n\n```c:BmpLoader.c\n#include <stdio.h>\n#include <stdlib.h>\n#include <GL/glew.h>\n#include \"BmpLoader.h\"\n\n/*==============================*\n** BMP\u30d5\u30a1\u30a4\u30eb\u306e\u8aad\u307f\u8fbc\u307f\n**==============================*/\nGLuint load_bmp(const char *file_name)\n{\n    FILE *fp;\n    unsigned char header[54];\n    unsigned char *data;\n    size_t count, size;\n    int width, height;\n    GLuint texture;\n\n    fp = fopen(file_name, \"rb\");\n    if (!fp) {\n        fprintf(stderr, \"Cannot open %s.\\n\", file_name);\n        exit(EXIT_FAILURE);\n    }\n\n    count = fread(header, 1, sizeof(header), fp);\n    if (count != sizeof(header)) {\n        fprintf(stderr, \"Cannot read bmp file %s.\\n\", file_name);\n        exit(EXIT_FAILURE);\n    }\n\n    if (header[0] != 'B' || header[1] != 'M') {\n        fprintf(stderr, \"Cannot read bmp file %s.\\n\", file_name);\n        exit(EXIT_FAILURE);\n    }\n\n    width = *(int*)(header + 0x12);\n    height = *(int*)(header + 0x16);\n    size = width * height * 3;\n\n    data = malloc(sizeof(unsigned char) * size);\n    if (!data) {\n        fprintf(stderr, \"Memory allocation error.\\n\");\n        exit(EXIT_FAILURE);\n    }\n\n    count = fread(data, sizeof(unsigned char), size, fp);\n    if (count != size) {\n        fprintf(stderr, \"Cannot read bmp file %s.\\n\", file_name);\n        exit(EXIT_FAILURE);\n    }\n\n    fclose(fp);\n\n    glCreateTextures(GL_TEXTURE_2D, 1, &texture);\n    glTextureStorage2D(texture, 1, GL_RGB8, width, height);\n    glTextureSubImage2D(texture, 0, 0, 0, width, height, GL_BGR, GL_UNSIGNED_BYTE, data);\n\n    free(data); \n\n    glTextureParameteri(texture, GL_TEXTURE_MAG_FILTER, GL_LINEAR);\n    glTextureParameteri(texture, GL_TEXTURE_MIN_FILTER, GL_LINEAR);\n\n    return texture;\n}\n```\n\n# UV\u5ea7\u6a19\u306e\u8aad\u307f\u8fbc\u307f\n`ObjLoader.h`\u3001`ObjLoader.c`\u3092\u62e1\u5f35\u3057\u3066\u3001UV\u5ea7\u6a19\u3092\u8aad\u307f\u8fbc\u3081\u308b\u3088\u3046\u306b\u3057\u307e\u3059\u3002\n\n```c:ObjLoader.h\n#ifndef OBJLOADER_H_INCLUDE\n#define OBJLOADER_H_INCLUDE\n\n/* \u30e2\u30c7\u30eb\u30c7\u30fc\u30bf */\ntypedef struct {\n    float *vertices;\n    int num_vertices;\n    float *normals;\n    int num_normals;\n    float *uvs;\n    int num_uvs;\n} model;\n\n/* OBJ\u30d5\u30a1\u30a4\u30eb\u306e\u8aad\u307f\u8fbc\u307f */\nvoid load_obj(model *m, const char *file_name);\n\n#endif\n```\n\n```c:ObjLoader.c\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ObjLoader.h\"\n\n/* \u521d\u671f\u30d0\u30c3\u30d5\u30a1\u30b5\u30a4\u30ba */\n#define DEF_BUF_SIZE 2\n\n/* \u6d6e\u52d5\u5c0f\u6570\u70b9\u6570\u30d0\u30c3\u30d5\u30a1 */\ntypedef struct {\n    int buf_size;\n    int current_index;\n    float *buf;\n} float_buffer;\n\n/* \u6574\u6570\u30d0\u30c3\u30d5\u30a1 */\ntypedef struct {\n    int buf_size;\n    int current_index;\n    int *buf;\n} int_buffer;\n\n/* \u9802\u70b9\u5ea7\u6a19\u306e\u8aad\u307f\u8fbc\u307f */\nvoid read_vertices(const char *line, float_buffer *vs);\n\n/* \u6cd5\u7dda\u30d9\u30af\u30c8\u30eb\u306e\u8aad\u307f\u8fbc\u307f */\nvoid read_normals(const char *line, float_buffer *vns);\n\n/* UV\u5ea7\u6a19\u306e\u8aad\u307f\u8fbc\u307f */\nvoid read_uvs(const char *line, float_buffer *vts);\n\n/* \u30a4\u30f3\u30c7\u30c3\u30af\u30b9\u306e\u8aad\u307f\u8fbc\u307f */\nvoid read_indices(const char *line, int_buffer *fs);\n\n/* \u30e2\u30c7\u30eb\u306e\u4f5c\u6210 */\nvoid create_model(model *m,\n    float_buffer *vs, float_buffer *vns, int_buffer *fs);\n\n/* \u6d6e\u52d5\u5c0f\u6570\u70b9\u6570\u30d0\u30c3\u30d5\u30a1\u306e\u64cd\u4f5c */\nfloat_buffer *alloc_float_buffer(void);\nvoid free_float_buffer(float_buffer *fbuf);\nvoid add_float(float_buffer *fbuf, float value);\nfloat get_float(float_buffer *fbuf, int index);\n\n/* \u6574\u6570\u30d0\u30c3\u30d5\u30a1\u306e\u64cd\u4f5c */\nint_buffer *alloc_int_buffer(void);\nvoid free_int_buffer(int_buffer *ibuf);\nvoid add_int(int_buffer *ibuf, int value);\nint get_int(int_buffer *ibuf, int index);\n\n/*==============================*\n** OBJ\u30d5\u30a1\u30a4\u30eb\u306e\u8aad\u307f\u8fbc\u307f\n**==============================*/\nvoid load_obj(model *m, const char *file_name)\n{\n    FILE *fp;\n    char line[1024];\n    float_buffer *vs, *vns, *vts;\n    int_buffer *fs;\n\n    fp = fopen(file_name, \"r\");\n    if (!fp) {\n        fprintf(stderr, \"Cannot open %s.\\n\", file_name);\n        exit(EXIT_FAILURE);\n    }\n\n    vs = alloc_float_buffer();\n    vns = alloc_float_buffer();\n    vts = alloc_float_buffer();\n    fs = alloc_int_buffer();\n\n    while (!feof(fp)) {\n        fgets(line, sizeof(line), fp);\n        if (line[0] == 'v' && line[1] == ' ') {\n            read_vertices(line, vs);\n        }\n        else if (line[0] == 'v' && line[1] == 'n' && line[2] == ' ') {\n            read_normals(line, vns);\n        }\n        else if (line[0] == 'v' && line[1] == 't' && line[2] == ' ') {\n            read_uvs(line, vts);\n        }\n        else if (line[0] == 'f' && line[1] == ' ') {\n            read_indices(line, fs);\n        }\n    }\n\n    create_model(m, vs, vns, vts, fs);\n\n    free_float_buffer(vs);\n    free_float_buffer(vns);\n    free_float_buffer(vts);\n    free_int_buffer(fs);\n\n    fclose(fp);\n}\n\n/*------------------------------*\n** \u9802\u70b9\u5ea7\u6a19\u306e\u8aad\u307f\u8fbc\u307f\n**------------------------------*/\nvoid read_vertices(const char *line, float_buffer *vs)\n{\n    float x, y, z;\n    int count;\n\n    count = sscanf(line, \"%*s%f%f%f\", &x, &y, &z);\n\n    if (count == 3) {\n        add_float(vs, x);\n        add_float(vs, y);\n        add_float(vs, z);\n    }\n}\n\n/*------------------------------*\n** \u6cd5\u7dda\u30d9\u30af\u30c8\u30eb\u306e\u8aad\u307f\u8fbc\u307f\n**------------------------------*/\nvoid read_normals(const char *line, float_buffer *vns)\n{\n    float x, y, z;\n    int count;\n\n    count = sscanf(line, \"%*s%f%f%f\", &x, &y, &z);\n\n    if (count == 3) {\n        add_float(vns, x);\n        add_float(vns, y);\n        add_float(vns, z);\n    }\n}\n\n/*------------------------------*\n** UV\u5ea7\u6a19\u306e\u8aad\u307f\u8fbc\u307f\n**------------------------------*/\nvoid read_uvs(const char *line, float_buffer *vts)\n{\n    float u, v;\n    int count;\n\n    count = sscanf(line, \"%*s%f%f\", &u, &v);\n\n    if (count == 2) {\n        add_float(vts, u);\n        add_float(vts, v);\n    }\n}\n\n/*------------------------------*\n** \u30a4\u30f3\u30c7\u30c3\u30af\u30b9\u306e\u8aad\u307f\u8fbc\u307f\n**------------------------------*/\nvoid read_indices(const char *line, int_buffer *fs)\n{\n    int v1, v2, v3;\n    int t1, t2, t3;\n    int n1, n2, n3;\n    int count;\n\n    count = sscanf(line,\n        \"%*s %d%*c%d%*c%d \"\n        \"%d%*c%d%*c%d \"\n        \"%d%*c%d%*c%d\", \n        &v1, &t1, &n1, &v2, &t2, &n2, &v3, &t3, &n3);\n\n    if (count == 9) {\n        add_int(fs, v1);\n        add_int(fs, t1);\n        add_int(fs, n1);\n        add_int(fs, v2);\n        add_int(fs, t2);\n        add_int(fs, n2);\n        add_int(fs, v3);\n        add_int(fs, t3);\n        add_int(fs, n3);\n    }\n}\n\n/*------------------------------*\n** \u30e2\u30c7\u30eb\u306e\u4f5c\u6210\n**------------------------------*/\nvoid create_model(model *m, \n    float_buffer *vs, float_buffer *vns, \n    float_buffer *vts, int_buffer *fs)\n{\n    int i, j;\n\n    m->num_vertices = fs->current_index / 3 * 3;\n    m->vertices = malloc(sizeof(float) * m->num_vertices);\n\n    if (!m->vertices) {\n        fprintf(stderr, \"Memory allocation error.\\n\");\n        exit(EXIT_FAILURE);\n    }\n\n    m->num_normals = fs->current_index / 3 * 3;\n    m->normals = malloc(sizeof(float) * m->num_normals);\n\n    if (!m->normals) {\n        fprintf(stderr, \"Memory allocation error.\\n\");\n        exit(EXIT_FAILURE);\n    }\n\n    m->num_uvs = fs->current_index / 3 * 2;\n    m->uvs = malloc(sizeof(float) * m->num_uvs);\n\n    if (!m->uvs) {\n        fprintf(stderr, \"Memory allocation error.\\n\");\n        exit(EXIT_FAILURE);\n    }\n\n    for (i = 0; i < fs->current_index; i++) {\n        int idx = fs->buf[i] - 1;\n        if (i % 3 == 0) {\n            for (j = 0; j < 3; j++) {\n                m->vertices[i / 3 * 3 + j] = vs->buf[idx * 3 + j];\n            }\n        }\n        else if (i % 3 == 1) {\n            for (j = 0; j < 2; j++) {\n                m->uvs[i / 3 * 2 + j] = vts->buf[idx * 2 + j];\n            }\n        }\n        else {\n            for (j = 0; j < 3; j++) {\n                m->normals[i / 3 * 3 + j] = vns->buf[idx * 3 + j];\n            }\n        }\n        \n    }\n}\n\n/*------------------------------*\n** \u6d6e\u52d5\u5c0f\u6570\u70b9\u6570\u30d0\u30c3\u30d5\u30a1\u306e\u5272\u308a\u5f53\u3066\n**------------------------------*/\nfloat_buffer *alloc_float_buffer(void)\n{\n    float_buffer *fbuf;\n\n    fbuf = malloc(sizeof(float_buffer));\n    if (!fbuf) {\n        fprintf(stderr, \"Memory allocation error.\\n\");\n        exit(EXIT_FAILURE);\n    }\n\n    fbuf->buf_size = DEF_BUF_SIZE;\n    fbuf->current_index = 0;\n    fbuf->buf = malloc(sizeof(float) * fbuf->buf_size);\n\n    return fbuf;\n}\n\n/*------------------------------*\n** \u6d6e\u52d5\u5c0f\u6570\u70b9\u6570\u30d0\u30c3\u30d5\u30a1\u306e\u89e3\u653e\n**------------------------------*/\nvoid free_float_buffer(float_buffer *fbuf)\n{\n    free(fbuf->buf);\n    free(fbuf);\n}\n\n/*------------------------------*\n** \u30d0\u30c3\u30d5\u30a1\u306b\u6d6e\u52d5\u5c0f\u6570\u70b9\u6570\u3092\u8ffd\u52a0\n**------------------------------*/\nvoid add_float(float_buffer *fbuf, float value)\n{\n    fbuf->buf[fbuf->current_index] = value;\n    fbuf->current_index++;\n    if (fbuf->current_index >= fbuf->buf_size) {\n        fbuf->buf_size *= 2;\n        fbuf->buf = realloc(fbuf->buf, sizeof(float) * fbuf->buf_size);\n        if (!fbuf->buf) {\n            fprintf(stderr, \"Memory allocation error.\\n\");\n            exit(EXIT_FAILURE);\n        }\n    }\n}\n\n/*------------------------------*\n** \u30d0\u30c3\u30d5\u30a1\u304b\u3089\u6d6e\u52d5\u5c0f\u6570\u70b9\u6570\u3092\u53d6\u308a\u51fa\u3057\n**------------------------------*/\nfloat get_float(float_buffer *fbuf, int index)\n{\n    return fbuf->buf[index];\n}\n\n/*------------------------------*\n** \u6574\u6570\u30d0\u30c3\u30d5\u30a1\u306e\u5272\u308a\u5f53\u3066\n**------------------------------*/\nint_buffer *alloc_int_buffer(void)\n{\n    int_buffer *ibuf;\n\n    ibuf = malloc(sizeof(int_buffer));\n    if (!ibuf) {\n        fprintf(stderr, \"Memory allocation error.\\n\");\n        exit(EXIT_FAILURE);\n    }\n\n    ibuf->buf_size = DEF_BUF_SIZE;\n    ibuf->current_index = 0;\n    ibuf->buf = malloc(sizeof(int) * ibuf->buf_size);\n\n    return ibuf;\n}\n\n/*------------------------------*\n** \u6574\u6570\u30d0\u30c3\u30d5\u30a1\u306e\u89e3\u653e\n**------------------------------*/\nvoid free_int_buffer(int_buffer *ibuf)\n{\n    free(ibuf->buf);\n    free(ibuf);\n}\n\n/*------------------------------*\n** \u30d0\u30c3\u30d5\u30a1\u306b\u6574\u6570\u3092\u8ffd\u52a0\n**------------------------------*/\nvoid add_int(int_buffer *ibuf, int value)\n{\n    ibuf->buf[ibuf->current_index] = value;\n    ibuf->current_index++;\n    if (ibuf->current_index >= ibuf->buf_size) {\n        ibuf->buf_size *= 2;\n        ibuf->buf = realloc(ibuf->buf, sizeof(int) * ibuf->buf_size);\n        if (!ibuf->buf) {\n            fprintf(stderr, \"Memory allocation error.\\n\");\n            exit(EXIT_FAILURE);\n        }\n    }\n}\n\n/*------------------------------*\n** \u30d0\u30c3\u30d5\u30a1\u304b\u3089\u6574\u6570\u3092\u53d6\u308a\u51fa\u3057\n**------------------------------*/\nint get_int(int_buffer *ibuf, int index)\n{\n    return ibuf->buf[index];\n}\n```\n\n# \u30c6\u30af\u30b9\u30c1\u30e3\u30de\u30c3\u30d4\u30f3\u30b0\n\u30b7\u30a7\u30fc\u30c0\u3092\u4ee5\u4e0b\u306e\u3088\u3046\u306b\u66f8\u304d\u66ff\u3048\u3066\u3001\u30c6\u30af\u30b9\u30c1\u30e3\u30de\u30c3\u30d4\u30f3\u30b0\u3092\u884c\u3046\u3088\u3046\u306b\u3057\u307e\u3059\u3002\n\n```glsl:Vertex.glsl\n#version 450\n\nlayout (location = 0) in vec3 in_position;\nlayout (location = 1) in vec3 in_normal;\nlayout (location = 2) in vec2 in_uv;\n\nuniform mat4 mv_matrix;\nuniform mat3 normal_matrix;\nuniform mat4 mvp;\n\nout vec4 position;\nout vec3 normal;\nout vec2 uv;\n\nvoid main()\n{\n    uv = in_uv;\n    normal = normalize(normal_matrix * in_normal);\n    position = mv_matrix * vec4(in_position, 1.0);\n\n    gl_Position = mvp * vec4(in_position, 1.0);\n}\n```\n\n```glsl:Fragment.glsl\n#version 450\n\nin vec4 position;\nin vec3 normal;\nin vec2 uv;\n\nuniform sampler2D texl;\n\nout vec4 out_color;\n\nvoid main()\n{\n    vec4 light = vec4(0.0, 2.0, 4.0, 1.0);\n    vec3 s = normalize(vec3(light - position));\n    vec3 diffusion = vec3(1.0, 1.0, 1.0) * max(dot(s, normal), 0.0);\n    vec3 material = texture2D(texl, uv).rgb;\n    out_color = vec4(diffusion * material, 1.0);\n}\n```\n\n\u30b7\u30a7\u30fc\u30c0\u306b\u60c5\u5831\u3092\u53d7\u3051\u6e21\u3059\u3088\u3046\u306b`Main.c`\u3092\u4ee5\u4e0b\u306e\u3088\u3046\u306b\u66f8\u304d\u66ff\u3048\u307e\u3059\u3002\n\n```c:Main.c\n#include <stdio.h>\n#include <stdlib.h>\n#include <GL/glew.h>\n#include <GLFW/glfw3.h>\n#include \"Init.h\"\n#include \"ShaderLoader.h\"\n#include \"Matrix.h\"\n#include \"ObjLoader.h\"\n#include \"BmpLoader.h\"\n\nint main(void)\n{\n    GLFWwindow *window;\n    GLuint program;\n    model model;\n    GLuint texture, texl;\n    GLuint mv_matrix, normal_matrix, mvp;\n    int i, j;\n\n    float *mat_proj, *mat_view, *mat_model;\n    float *mat_mv, *mat_mvp;\n    float mat_norm[9];\n\n    GLuint position_buffer;\n    GLuint normal_buffer;\n    GLuint uv_buffer;\n\n    GLuint vertex_array;\n\n    const GLuint position_location = 0;\n    const GLuint position_bindindex = 0;\n\n    const GLuint normal_location = 1;\n    const GLuint normal_bindindex = 1;\n\n    const GLuint uv_location = 2;\n    const GLuint uv_bindindex = 2;\n\n    window = init(640, 480, \"Step 04\");\n\n    program = load_shader(\"Vertex.glsl\", \"Fragment.glsl\");\n\n    load_obj(&model, \"miku.obj\");\n\n    mat_proj = alloc_matrix();\n    set_perspective_matrix(mat_proj,\n        45.0, 640.0f / 480.0f, 0.1f, 100.0f);\n\n    mat_view = alloc_matrix();\n    set_lookat_matrix(mat_view,\n        1.0f, 1.0f, 3.0f,\n        0.0f, 0.0f, 0.0f,\n        0.0f, 1.0f, 0.0f);\n\n    mat_model = alloc_matrix();\n    set_identity_matrix(mat_model);\n\n    mat_mv = alloc_matrix();\n    multiply_matrix(mat_mv, mat_view, mat_model);\n\n    mat_mvp = alloc_matrix();\n    multiply_matrix(mat_mvp, mat_proj, mat_mv);\n\n    free_matrix(mat_proj);\n    free_matrix(mat_view);\n    free_matrix(mat_model);\n\n    mv_matrix = glGetUniformLocation(program, \"mv_matrix\");\n    glUniformMatrix4fv(mv_matrix, 1, GL_FALSE, mat_mv);\n\n    for (i = 0; i < 3; i++) {\n        for (j = 0; j < 3; j++) {\n            mat_norm[i * 3 + j] = mat_mv[i * 4 + j];\n        }\n    }\n    normal_matrix = glGetUniformLocation(program, \"normal_matrix\");\n    glUniformMatrix3fv(normal_matrix, 1, GL_FALSE, mat_norm);\n\n    mvp = glGetUniformLocation(program, \"mvp\");\n    glUniformMatrix4fv(mvp, 1, GL_FALSE, mat_mvp);\n\n    texture = load_bmp(\"miku.bmp\");\n    texl = glGetUniformLocation(program, \"texl\");\n\n    glActiveTexture(GL_TEXTURE0);\n    glBindTexture(GL_TEXTURE_2D, texture);\n    glUniform1i(texl, 0);\n\n    glCreateBuffers(1, &position_buffer);\n    glNamedBufferData(position_buffer,\n        sizeof(float) * model.num_vertices,\n        model.vertices,\n        GL_STATIC_DRAW);\n\n    glCreateBuffers(1, &normal_buffer);\n    glNamedBufferData(normal_buffer,\n        sizeof(float) * model.num_normals,\n        model.normals,\n        GL_STATIC_DRAW);\n\n    glCreateBuffers(1, &uv_buffer);\n    glNamedBufferData(uv_buffer,\n        sizeof(float) * model.num_uvs,\n        model.uvs,\n        GL_STATIC_DRAW);\n\n    printf(\"%d %d %d\\n\", model.num_vertices, model.num_normals, model.num_uvs);\n\n    glCreateVertexArrays(1, &vertex_array);\n\n    glEnableVertexArrayAttrib(\n        vertex_array, position_location);\n    glVertexArrayAttribFormat(\n        vertex_array, position_location,\n        3, GL_FLOAT, GL_FALSE, 0);\n\n    glVertexArrayAttribBinding(\n        vertex_array, position_location,\n        position_bindindex);\n    glVertexArrayVertexBuffer(\n        vertex_array, position_bindindex,\n        position_buffer, 0, sizeof(GLfloat) * 3);\n\n    glEnableVertexArrayAttrib(\n        vertex_array, normal_location);\n    glVertexArrayAttribFormat(\n        vertex_array, normal_location,\n        3, GL_FLOAT, GL_FALSE, 0);\n\n    glVertexArrayAttribBinding(\n        vertex_array, normal_location,\n        normal_bindindex);\n    glVertexArrayVertexBuffer(\n        vertex_array, normal_bindindex,\n        normal_buffer, 0, sizeof(GLfloat) * 3);\n\n    glEnableVertexArrayAttrib(\n        vertex_array, uv_location);\n    glVertexArrayAttribFormat(\n        vertex_array, uv_location,\n        2, GL_FLOAT, GL_FALSE, 0);\n\n    glVertexArrayAttribBinding(\n        vertex_array, uv_location,\n        uv_bindindex);\n    glVertexArrayVertexBuffer(\n        vertex_array, uv_bindindex,\n        uv_buffer, 0, sizeof(GLfloat) * 2);\n\n    glClearColor(0.6, 0.8, 0.8, 1.0);\n    glEnable(GL_DEPTH_TEST);\n    glEnable(GL_CULL_FACE);\n\n    while (!glfwWindowShouldClose(window)) {\n        glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);\n\n        glBindVertexArray(vertex_array);\n        glDrawArrays(GL_TRIANGLES, 0, model.num_vertices / 3);\n\n        glfwSwapBuffers(window);\n        glfwPollEvents();\n    }\n\n    free_matrix(mat_mv);\n    free_matrix(mat_mvp);\n\n    glfwTerminate();\n\n    return EXIT_SUCCESS;\n}\n```\n\n\u521d\u97f3\u30df\u30af\u306e\u30e2\u30c7\u30eb\u3092Metasequoia\u3092\u4f7f\u3063\u3066\u4ee5\u4e0b\u306e\u8a2d\u5b9a\u3067\u66f8\u304d\u3060\u3057\u307e\u3059\u3002\n\n![miku37.png](https://qiita-image-store.s3.amazonaws.com/0/70306/9a53008e-b035-d061-4f9c-dc59d266c16f.png)\n\n\u30e2\u30c7\u30eb\u306b\u4ed8\u5c5e\u3057\u3066\u3044\u308b\u30c6\u30af\u30b9\u30c1\u30e3\u753b\u50cf\u309224bit\u30d3\u30c3\u30c8\u30de\u30c3\u30d7\u306b\u5909\u63db\u3057\u307e\u3059\u3002\u4f8b\u3048\u3070Photoshop\u3067\u306f\u4ee5\u4e0b\u306e\u3088\u3046\u306b\u8a2d\u5b9a\u3057\u307e\u3059\u3002\n\n![miku38.png](https://qiita-image-store.s3.amazonaws.com/0/70306/37b53242-a5d1-07fb-a735-c945c7d397e6.png)\n\n\u30d7\u30ed\u30b0\u30e9\u30e0\u3092\u5b9f\u884c\u3059\u308b\u3068\u4ee5\u4e0b\u306e\u3088\u3046\u306b\u8868\u793a\u3055\u308c\u307e\u3059\u3002\n\n![miku39.png](https://qiita-image-store.s3.amazonaws.com/0/70306/5619897c-a74b-48f6-f142-2e0f22088427.png)\n\n\u3064\u3044\u306b\u521d\u97f3\u30df\u30af\u304c\u8868\u793a\u3055\u308c\u307e\u3057\u305f\u3002\n", "tags": ["OpenGL4.5"]}