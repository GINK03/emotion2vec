{"context": "\nMy_Environment\nUbuntu 14.04 LTS Japanese Remix\non VMWare Fusion v8.5.2 (4635224)\non OS X El Captian v10.11.4\n\nGNU bash, version 4.3.11(1)-release\n\ngcc (Ubuntu 4.8.4-2ubuntu1~14.04.3) 4.8.4 \n(also for g++)\nADDA v.1.3b6\n\n\nThis article is related to ADDA (light scattering simulator based on the discrete dipole approximation).\nInitial Field for the iterative solver can be read from a file as defined below:\n\niterative.c\nstatic const char *CalcInitField(double zero_resid,const enum incpol which)\n{\n    ...\n    switch (InitField) {\n        ...\n        case IF_READ: {\n            const char *fname;\n            if (which==INCPOL_Y) fname=infi_fnameY;\n            else fname=infi_fnameX; // which==INCPOL_X\n            ReadField(fname,xvec); // read electric field\n            InitFieldfromE(); // transform it into starting vector\n            return dyn_sprintf(\"x_0 = from file %s\\n\",fname);\n        }\n        ...\n\n\nThe ReadField() is defined at comm.c as follows:\n\ncomm.c\nvoid ReadField(const char * restrict fname,doublecomplex *restrict field)\n/* Reads a complex field from file 'fname' and stores into 'field'.\n *\n * In MPI mode the algorithm is very far from optimal, since the whole \n * file is read in total nprocs/2 times.\n * However, this is mainly the limitation of the text file (need to test\n *  for blank lines and format consistency).\n * The only feasible way to improve it is to use binary format like NetCDF \n * (which may work on top of MPI_IO)\n */\n{\n    ...\n\n\nThe field is the pointer with which the data read from the file is stored. The field is named as xvec in the calling function (CalcInitField).\nIn function header comment of CalcInitField()\n\nAt the end of this function xvec should contain initial vector for the iterative solver (x_0)\n\n```txt:My_Environment\nUbuntu 14.04 LTS Japanese Remix\non VMWare Fusion v8.5.2 (4635224)\non OS X El Captian v10.11.4\n\nGNU bash, version 4.3.11(1)-release\n\ngcc (Ubuntu 4.8.4-2ubuntu1~14.04.3) 4.8.4 \n(also for g++)\nADDA v.1.3b6\n```\n\nThis article is related to [ADDA (light scattering simulator based on the discrete dipole approximation)](https://github.com/adda-team/adda/).\n\nInitial Field for the iterative solver can be read from a file as defined below:\n\n```iterative.c\nstatic const char *CalcInitField(double zero_resid,const enum incpol which)\n{\n    ...\n    switch (InitField) {\n        ...\n        case IF_READ: {\n            const char *fname;\n            if (which==INCPOL_Y) fname=infi_fnameY;\n            else fname=infi_fnameX; // which==INCPOL_X\n            ReadField(fname,xvec); // read electric field\n            InitFieldfromE(); // transform it into starting vector\n            return dyn_sprintf(\"x_0 = from file %s\\n\",fname);\n        }\n        ...\n```\n\nThe `ReadField()` is defined at `comm.c` as follows:\n\n```comm.c\nvoid ReadField(const char * restrict fname,doublecomplex *restrict field)\n/* Reads a complex field from file 'fname' and stores into 'field'.\n *\n * In MPI mode the algorithm is very far from optimal, since the whole \n * file is read in total nprocs/2 times.\n * However, this is mainly the limitation of the text file (need to test\n *  for blank lines and format consistency).\n * The only feasible way to improve it is to use binary format like NetCDF \n * (which may work on top of MPI_IO)\n */\n{\n    ...\n```\n\nThe `field` is the pointer with which the data read from the file is stored. The `field` is named as `xvec` in the calling function (CalcInitField).\n\nIn function header comment of `CalcInitField()`\n\n> At the end of this function **<font color=red>xvec</font>** should contain initial vector for the iterative solver (x_0)\n\n", "tags": ["ADDA"]}