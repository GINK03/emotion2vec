{"context": "\nMy_Environment\nUbuntu 14.04 LTS Japanese Remix\non VMWare Fusion v8.5.2 (4635224)\non OS X El Captian v10.11.4\n\nGNU bash, version 4.3.11(1)-release\n\ngcc (Ubuntu 4.8.4-2ubuntu1~14.04.3) 4.8.4 \n(also for g++)\nADDA v.1.3b6\n\n\nThis article is related to ADDA (light scattering simulator based on the discrete dipole approximation).\nRelated: http://qiita.com/7of9/items/9537252c79f5318d8f55\nRelated: http://qiita.com/7of9/items/4966f131d405cd89ee07\nRelated: http://qiita.com/7of9/items/0d477f8f84445ce35c3d\nIn order to read Chpoint file, we need auxiliary information shown below:\n\nparams[ind_m].sc_N\nscalars[i].size\nparams[ind_m].vec_N\nvectors[i].size\n\nThere may be two ways to store these values:\n\nModify the Chpoint file format\n\n\nDisadvantage: reading part of the Chpoint file also need to be modified\nDisadvantage: causes conflict to the update of the ADDA\n\n\nOutput as separate file\n\n\nAdvantage: can be removed easily\nAdvantage: can follow the update of ADDA\n\n\n\nI chose the second.\n\nmodification of the code\nI modify the iterative.c \n\nAdded #define OUTPUT_AUX_FILE and related\nAdded if (output_auxfile) { and related\n\nThis way, we can disable the output feature just by comment out #define OUTPUT_AUX_FILE. I decided to follow the way using const bool output_auxfile = true; as suggested by @nonbiri15.\nIn Japanese.\n\niterative.c\n#define OUTPUT_AUX_FILE // to output auxiliary values\n#ifdef OUTPUT_AUX_FILE\nconst bool output_auxfile = true;\n#else\nconst bool output_auxfile = false;\n#endif\n\nstatic void SaveIterChpoint(void)\n/* save a binary checkpoint; only limitedly foolproof - user should take care to load checkpoints on the same machine\n * (number of processors) and with the same command line.\n */\n{\n    int i;\n    char fname[MAX_FNAME];\n    FILE * restrict chp_file;\n    TIME_TYPE tstart;\n\n    // to store auxiliary values required to read Chpoint file by tools\n    FILE * restrict aux_file;\n    char fauxName[MAX_FNAME];   \n\n    tstart=GET_TIME();\n    if (IFROOT) {\n        // create directory \"chp_dir\" if needed and open info file\n        SnprintfErr(ONE_POS,fname,MAX_FNAME,\"%s/\"F_CHP_LOG,chp_dir);\n        if ((chp_file=fopen(fname,\"w\"))==NULL) {\n            MkDirErr(chp_dir,ONE_POS);\n            chp_file=FOpenErr(fname,\"w\",ONE_POS);\n        }\n        // write info and close file\n        fprintf(chp_file,\"Info about the run, which produced the checkpoint, can be found in ../%s\",directory);\n        FCloseErr(chp_file,fname,ONE_POS);\n    }\n    // wait to ensure that directory exists\n    Synchronize();\n    // open output file; writing errors are checked only for vectors\n    SnprintfErr(ALL_POS,fname,MAX_FNAME,\"%s/\"F_CHP,chp_dir,ringid);\n    chp_file=FOpenErr(fname,\"wb\",ALL_POS);\n    if (output_auxfile) {\n        SnprintfErr(ALL_POS,fauxName,MAX_FNAME,\"%s/aux.0\",chp_dir);\n        fprintf(stdout, \"\\r\\n[DEBUG] Line220>SaveIterChpoint: %s\\r\\n\", fauxName);\n        aux_file=FOpenErr(fauxName,\"wb\",ALL_POS);\n    }\n    // write common scalars\n    fwrite(&ind_m,sizeof(int),1,chp_file);\n    fwrite(&local_nRows,sizeof(size_t),1,chp_file);\n    fwrite(&niter,sizeof(int),1,chp_file);\n    fwrite(&counter,sizeof(int),1,chp_file);\n    fwrite(&inprodR,sizeof(double),1,chp_file);\n    fwrite(&prev_err,sizeof(double),1,chp_file); // written on ALL processors but used only on root\n    fwrite(&resid_scale,sizeof(double),1,chp_file);\n    // write specific scalars\n    for (i=0;i<params[ind_m].sc_N;i++) fwrite(scalars[i].ptr,scalars[i].size,1,chp_file);\n    // write common vectors\n    if (fwrite(xvec,sizeof(doublecomplex),local_nRows,chp_file)!=local_nRows)\n        LogError(ALL_POS,\"Failed writing to file '%s'\",fname);\n    if (fwrite(rvec,sizeof(doublecomplex),local_nRows,chp_file)!=local_nRows)\n        LogError(ALL_POS,\"Failed writing to file '%s'\",fname);\n    if (fwrite(pvec,sizeof(doublecomplex),local_nRows,chp_file)!=local_nRows)\n        LogError(ALL_POS,\"Failed writing to file '%s'\",fname);\n    // write specific vectors\n    for (i=0;i<params[ind_m].vec_N;i++) if (fwrite(vectors[i].ptr,vectors[i].size,local_nRows,chp_file)!=local_nRows)\n        LogError(ALL_POS,\"Failed writing to file '%s'\",fname);\n\n    if (output_auxfile) {   \n        fwrite(&(params[ind_m].sc_N), sizeof(int), 1, aux_file);\n        for (i=0;i<params[ind_m].sc_N;i++) {\n            fwrite(&(scalars[i].size), sizeof(int), 1, aux_file);\n        }\n        fwrite(&(params[ind_m].vec_N), sizeof(int), 1, aux_file);\n        for (i=0;i<params[ind_m].vec_N;i++) {\n            fwrite(&(vectors[i].size), sizeof(int), 1, aux_file);       \n        }\n        fprintf(stdout, \"[DEBUG] Line254>SaveIterChpoint: sc_N=%d\\r\\n\", params[ind_m].sc_N);\n        for (i=0;i<params[ind_m].sc_N;i++) {\n            fprintf(stdout, \"[DEBUG] Line256>SaveIterChpoint: scalars.size=%d\\r\\n\", scalars[i].size);\n        }\n        fprintf(stdout, \"[DEBUG] Line258>SaveIterChpoint: vec_N=%d\\r\\n\", params[ind_m].vec_N);\n        for (i=0;i<params[ind_m].vec_N;i++) {\n            fprintf(stdout, \"[DEBUG] Line260>SaveIterChpoint: vectors.size=%d\\r\\n\", vectors[i].size);\n        }\n    }\n\n    // close file\n    FCloseErr(chp_file,fname,ALL_POS);\n    if (output_auxfile) {\n        FCloseErr(aux_file,fauxName,ALL_POS);   \n    }\n\n    // write info to logfile after everyone is finished\n    Synchronize();\n    if (IFROOT) PrintBoth(logfile,\"Checkpoint (iteration) saved\\n\");\n    Timing_FileIO+=GET_TIME()-tstart;\n    Synchronize(); // this is to ensure that message above appears if and only if OK\n}\n\n\n\ntest run (#define OUTPUT_AUX_FILE enabled)\n$ ./adda -grid 25 -chp_type normal -chpoint 1s > log\n\n$ tail -n 20 log\nRE_052 = 3.3098144752E-01  + \nRE_053 = 3.2839613884E-01  + \nRE_054 = 3.2540677697E-01  + \nRE_055 = 3.2272283461E-01  + \n\n[DEBUG] Line220>SaveIterChpoint: chpoint/aux.0\n[DEBUG] Line254>SaveIterChpoint: sc_N=8\n[DEBUG] Line256>SaveIterChpoint: scalars.size=8\n[DEBUG] Line256>SaveIterChpoint: scalars.size=8\n[DEBUG] Line256>SaveIterChpoint: scalars.size=8\n[DEBUG] Line256>SaveIterChpoint: scalars.size=8\n[DEBUG] Line256>SaveIterChpoint: scalars.size=16\n[DEBUG] Line256>SaveIterChpoint: scalars.size=16\n[DEBUG] Line256>SaveIterChpoint: scalars.size=16\n[DEBUG] Line256>SaveIterChpoint: scalars.size=16\n[DEBUG] Line258>SaveIterChpoint: vec_N=3\n[DEBUG] Line260>SaveIterChpoint: vectors.size=16\n[DEBUG] Line260>SaveIterChpoint: vectors.size=16\n[DEBUG] Line260>SaveIterChpoint: vectors.size=16\nCheckpoint (iteration) saved\n\n$ ls chpoint/\naux.0  chp.0  chp.log\n\nBy reading aux.0 and chp.0, we can fully recover the values output to chp.0 from tools.\n```txt:My_Environment\nUbuntu 14.04 LTS Japanese Remix\non VMWare Fusion v8.5.2 (4635224)\non OS X El Captian v10.11.4\n\nGNU bash, version 4.3.11(1)-release\n\ngcc (Ubuntu 4.8.4-2ubuntu1~14.04.3) 4.8.4 \n(also for g++)\nADDA v.1.3b6\n```\n\nThis article is related to [ADDA (light scattering simulator based on the discrete dipole approximation)](https://github.com/adda-team/adda/).\n\nRelated: http://qiita.com/7of9/items/9537252c79f5318d8f55\nRelated: http://qiita.com/7of9/items/4966f131d405cd89ee07\nRelated: http://qiita.com/7of9/items/0d477f8f84445ce35c3d\n\nIn order to read Chpoint file, [we need auxiliary information](http://qiita.com/7of9/items/9aff38658d0922f1a319) shown below:\n\n- params[ind_m].sc_N\n- scalars[i].size\n- params[ind_m].vec_N\n- vectors[i].size\n\nThere may be two ways to store these values:\n\n1. Modify the Chpoint file format\n   - Disadvantage: reading part of the Chpoint file also need to be modified\n   - Disadvantage: causes conflict to the update of the ADDA\n2. Output as separate file\n   - Advantage: can be removed easily\n   - Advantage: can follow the update of ADDA\n\nI chose the second.\n\n### modification of the code\n\nI modify the `iterative.c` \n\n- Added `#define OUTPUT_AUX_FILE` and related\n- Added `if (output_auxfile) {` and related\n\nThis way, we can disable the output feature just by comment out `#define OUTPUT_AUX_FILE`. I decided to follow the way using `const bool output_auxfile = true;` as suggested by @nonbiri15.\n[In Japanese](http://qiita.com/nonbiri15/items/3417facd391e01c3e365).\n\n```iterative.c\n#define OUTPUT_AUX_FILE // to output auxiliary values\n#ifdef OUTPUT_AUX_FILE\nconst bool output_auxfile = true;\n#else\nconst bool output_auxfile = false;\n#endif\n\nstatic void SaveIterChpoint(void)\n/* save a binary checkpoint; only limitedly foolproof - user should take care to load checkpoints on the same machine\n * (number of processors) and with the same command line.\n */\n{\n\tint i;\n\tchar fname[MAX_FNAME];\n\tFILE * restrict chp_file;\n\tTIME_TYPE tstart;\n\n\t// to store auxiliary values required to read Chpoint file by tools\n\tFILE * restrict aux_file;\n\tchar fauxName[MAX_FNAME];\t\n\n\ttstart=GET_TIME();\n\tif (IFROOT) {\n\t\t// create directory \"chp_dir\" if needed and open info file\n\t\tSnprintfErr(ONE_POS,fname,MAX_FNAME,\"%s/\"F_CHP_LOG,chp_dir);\n\t\tif ((chp_file=fopen(fname,\"w\"))==NULL) {\n\t\t\tMkDirErr(chp_dir,ONE_POS);\n\t\t\tchp_file=FOpenErr(fname,\"w\",ONE_POS);\n\t\t}\n\t\t// write info and close file\n\t\tfprintf(chp_file,\"Info about the run, which produced the checkpoint, can be found in ../%s\",directory);\n\t\tFCloseErr(chp_file,fname,ONE_POS);\n\t}\n\t// wait to ensure that directory exists\n\tSynchronize();\n\t// open output file; writing errors are checked only for vectors\n\tSnprintfErr(ALL_POS,fname,MAX_FNAME,\"%s/\"F_CHP,chp_dir,ringid);\n\tchp_file=FOpenErr(fname,\"wb\",ALL_POS);\n\tif (output_auxfile) {\n\t\tSnprintfErr(ALL_POS,fauxName,MAX_FNAME,\"%s/aux.0\",chp_dir);\n\t\tfprintf(stdout, \"\\r\\n[DEBUG] Line220>SaveIterChpoint: %s\\r\\n\", fauxName);\n\t\taux_file=FOpenErr(fauxName,\"wb\",ALL_POS);\n\t}\n\t// write common scalars\n\tfwrite(&ind_m,sizeof(int),1,chp_file);\n\tfwrite(&local_nRows,sizeof(size_t),1,chp_file);\n\tfwrite(&niter,sizeof(int),1,chp_file);\n\tfwrite(&counter,sizeof(int),1,chp_file);\n\tfwrite(&inprodR,sizeof(double),1,chp_file);\n\tfwrite(&prev_err,sizeof(double),1,chp_file); // written on ALL processors but used only on root\n\tfwrite(&resid_scale,sizeof(double),1,chp_file);\n\t// write specific scalars\n\tfor (i=0;i<params[ind_m].sc_N;i++) fwrite(scalars[i].ptr,scalars[i].size,1,chp_file);\n\t// write common vectors\n\tif (fwrite(xvec,sizeof(doublecomplex),local_nRows,chp_file)!=local_nRows)\n\t\tLogError(ALL_POS,\"Failed writing to file '%s'\",fname);\n\tif (fwrite(rvec,sizeof(doublecomplex),local_nRows,chp_file)!=local_nRows)\n\t\tLogError(ALL_POS,\"Failed writing to file '%s'\",fname);\n\tif (fwrite(pvec,sizeof(doublecomplex),local_nRows,chp_file)!=local_nRows)\n\t\tLogError(ALL_POS,\"Failed writing to file '%s'\",fname);\n\t// write specific vectors\n\tfor (i=0;i<params[ind_m].vec_N;i++) if (fwrite(vectors[i].ptr,vectors[i].size,local_nRows,chp_file)!=local_nRows)\n\t\tLogError(ALL_POS,\"Failed writing to file '%s'\",fname);\n\n\tif (output_auxfile) {\t\n\t\tfwrite(&(params[ind_m].sc_N), sizeof(int), 1, aux_file);\n\t\tfor (i=0;i<params[ind_m].sc_N;i++) {\n\t\t\tfwrite(&(scalars[i].size), sizeof(int), 1, aux_file);\n\t\t}\n\t\tfwrite(&(params[ind_m].vec_N), sizeof(int), 1, aux_file);\n\t\tfor (i=0;i<params[ind_m].vec_N;i++) {\n\t\t\tfwrite(&(vectors[i].size), sizeof(int), 1, aux_file);\t\t\n\t\t}\n\t\tfprintf(stdout, \"[DEBUG] Line254>SaveIterChpoint: sc_N=%d\\r\\n\", params[ind_m].sc_N);\n\t\tfor (i=0;i<params[ind_m].sc_N;i++) {\n\t\t\tfprintf(stdout, \"[DEBUG] Line256>SaveIterChpoint: scalars.size=%d\\r\\n\", scalars[i].size);\n\t\t}\n\t\tfprintf(stdout, \"[DEBUG] Line258>SaveIterChpoint: vec_N=%d\\r\\n\", params[ind_m].vec_N);\n\t\tfor (i=0;i<params[ind_m].vec_N;i++) {\n\t\t\tfprintf(stdout, \"[DEBUG] Line260>SaveIterChpoint: vectors.size=%d\\r\\n\", vectors[i].size);\n\t\t}\n\t}\n\n\t// close file\n\tFCloseErr(chp_file,fname,ALL_POS);\n\tif (output_auxfile) {\n\t\tFCloseErr(aux_file,fauxName,ALL_POS);\t\n\t}\n\n\t// write info to logfile after everyone is finished\n\tSynchronize();\n\tif (IFROOT) PrintBoth(logfile,\"Checkpoint (iteration) saved\\n\");\n\tTiming_FileIO+=GET_TIME()-tstart;\n\tSynchronize(); // this is to ensure that message above appears if and only if OK\n}\n```\n\n### test run (`#define OUTPUT_AUX_FILE` enabled)\n\n```\n$ ./adda -grid 25 -chp_type normal -chpoint 1s > log\n```\n\n```\n$ tail -n 20 log\nRE_052 = 3.3098144752E-01  + \nRE_053 = 3.2839613884E-01  + \nRE_054 = 3.2540677697E-01  + \nRE_055 = 3.2272283461E-01  + \n\n[DEBUG] Line220>SaveIterChpoint: chpoint/aux.0\n[DEBUG] Line254>SaveIterChpoint: sc_N=8\n[DEBUG] Line256>SaveIterChpoint: scalars.size=8\n[DEBUG] Line256>SaveIterChpoint: scalars.size=8\n[DEBUG] Line256>SaveIterChpoint: scalars.size=8\n[DEBUG] Line256>SaveIterChpoint: scalars.size=8\n[DEBUG] Line256>SaveIterChpoint: scalars.size=16\n[DEBUG] Line256>SaveIterChpoint: scalars.size=16\n[DEBUG] Line256>SaveIterChpoint: scalars.size=16\n[DEBUG] Line256>SaveIterChpoint: scalars.size=16\n[DEBUG] Line258>SaveIterChpoint: vec_N=3\n[DEBUG] Line260>SaveIterChpoint: vectors.size=16\n[DEBUG] Line260>SaveIterChpoint: vectors.size=16\n[DEBUG] Line260>SaveIterChpoint: vectors.size=16\nCheckpoint (iteration) saved\n```\n\n```\n$ ls chpoint/\naux.0  chp.0  chp.log\n```\n\nBy reading aux.0 and chp.0, we can fully recover the values output to chp.0 from tools.\n\n\n\n\n\n\n\n", "tags": ["ADDA"]}