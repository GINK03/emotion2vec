{"context": " More than 1 year has passed since last update.\n\n4\u65e5\u76ee\n\n1.5.7\n\u7d50\u5c40iseq\u304c\u4f55\u306a\u306e\u304b\u308f\u304b\u3089\u306a\u3044\u307e\u307e1.5.7\u3092\u8fce\u3048\u305f.\u3044\u308d\u3093\u306a\u76ee\u7684\u306e\u305f\u3081\u306biseq\u4f7f\u3046\u3088\u3068\u304b\u66f8\u3044\u3066\u3042\u308b\u306e\u3067\u305d\u306e\u3046\u3061\u56f0\u308b.\n\u56f0\u3063\u305f\u3089haskell\u4f7f\u3046.\n2\u3064\u306egeneral points\u3082\u4f55\u8a00\u3063\u3066\u308b\u304b\u3088\u304f\u308f\u304b\u3089\u306a\u3044.\n\n1.6\n\u30d1\u30fc\u30b5\u3092\u4f5c\u308b.\n\n\u6700\u521d\u306b\u30d5\u30a1\u30a4\u30eb\u306e\u4e2d\u8eab\u3092\u8aad\u3080.\u3053\u308c\u306f\u7c21\u5358.\n\u30ec\u30ad\u30b5\u3092\u4f5c\u3063\u3066\u30c8\u30fc\u30af\u30f3\u306b\u5206\u89e3\u3059\u308b.clex :: String -> [Token]\n\n\u6587\u6cd5\u89e3\u6790\u3092\u3057\u3066CoreProgram\u306b\u843d\u3068\u3059.syntax :: [Token] -> CoreProgram\n\n\n\u3046\u30fc\u3093.\u6587\u5b57\u306b\u3055\u308c\u308b\u3068\u7c21\u5358\u305d\u3046\u306b\u898b\u3048\u308b.\n\u30d1\u30fc\u30b5\u81ea\u4f53\u306fclex\u3068syntax\u306e\u7d44\u307f\u5408\u308f\u305b.\nparse :: String -> CoreProgram\nparse = syntax . clex\n\n\u30b3\u30e1\u30f3\u30c8\u306b\u3088\u308b\u3068\u3053\u306e\u30d7\u30ed\u30b0\u30e9\u30e0\u306f\u5168\u90e8Gofer\u7528\u3089\u3057\u3044.\nExercise 1.9\u3067\"||\"\u304b\u3089\u884c\u672b\u307e\u3067\u30b3\u30e1\u30f3\u30c8\u306b\u51fa\u6765\u308b\u3088\u3046\u306b\u3057\u308d\u3063\u3066\u3042\u3063\u305f\u306e\u3067C\u8a00\u8a9e\u98a8\u306b\u30b3\u30e1\u30f3\u30c8\u306e\u59cb\u307e\u308a\u3092\"//\"\u306b\u5909\u3048\u305f.\nExercise 1.10\u30672\u6587\u5b57\u6f14\u7b97\u5b50\u306e\u5bfe\u5fdc,1.11\u3067\u884c\u3092\u8868\u793a\u3067\u304d\u308b\u3088\u3046\u306bToken\u578b\u3092\u5909\u3048\u305f.\u30c6\u30b9\u30c8\u306f\u3057\u3066\u306a\u3044.\n\n1.6.2\n\u554f\u984c\u306f,\u30d1\u30fc\u30b5\u306e\u65b9\u3092\u4f55\u306b\u3059\u3079\u304d\u304b,\u3060. \u304b\u3089\u30d1\u30fc\u30b5\u3092\u4f5c\u308a\u59cb\u3081\u308b\u3042\u305f\u308a\u3059\u3054\u304f\u95a2\u6570\u578b\u30d7\u30ed\u30b0\u30e9\u30df\u30f3\u30b0\u3063\u307d\u3044.\ntype Parser a = [Token] -> [(a, [Token])]\u304c\u3082\u3046\u4f55\u8a00\u3063\u3066\u308b\u304b\u308f\u304b\u3093\u306a\u3044.\n\u308f\u304b\u3093\u306a\u3044\u3051\u3069\u307e\u305apLit\u3092\u4f5c\u308b.\npLit :: String -> Parser String\u3068\u306a\u3063\u3066\u3044\u308b\u304b\u3089\u5b9f\u969b\u306b\u306f\npLit :: String -> [Token] -> [(String, [Token])] \u3067,String\u3068[Token]\u3092\u5f15\u6570\u306b\u53d6\u308a[(String, [Token])]\u304c\u5e30\u308b\u95a2\u6570.\n\u3057\u304b\u3057,pAlt\u304cpAlt :: Parser a -> Parser a -> Parser a\u3068\u306a\u3063\u3066\u3044\u308b\u306e\u3067,\u9ad8\u968e\u3063\u307d\u304f\u5b9f\u88c5\u3057\u306a\u3044\u3068\u3044\u3051\u306a\u3044\u306e\u304b?\n\u4e00\u5fdcpLit\u3092\u5b9f\u88c5\u3057\u3066\u30b3\u30f3\u30d1\u30a4\u30eb\u3092\u901a\u3057\u305f.\ntypedef struct {\n    size_t num;\n    String str;\n} Token_s;\n typedef Token_s * Token;\n\n Token init_tok(size_t num, size_t len) {\n    Token ret = (Token)gc_safealloc(sizeof(Token_s));\n    ret->num = num;\n    ret->str = init_str(len);\n    return ret;\n }\n\nmi_list clex(size_t line, char *str) {\n    mi_list ret = init_mi_list();\n    String twoCharOps[] = {\"==\", \"\u02dc=\", \">=\", \"<=\", \"->\"};\n    for(size_t i = 0; i < 5; i++) {\n        if(!strncmp(str, twoCharOps[i], 2)) {\n            Token twoop = init_tok(line, 3);\n            strncpy(twoop->str, str, 3);\n            ml_add_car(ret, twoop);\n        }\n    }\n    if(*str == '\\0') {\n        return ret;\n    } else if(isspace(*str)) {\n        return clex(*str == '\\n'?line+1:line, str+1);\n    } else if(*str == '/' && *(str+1) == '/') {\n        for(;*str != '\\n';str++);\n        return clex(line+1, str+1);\n    } else if(isdigit(*str)) {\n        Token num_token = init_tok(line, 15);\n        size_t i = 0;\n        for(; isdigit(*str); i++, str++) {\n            num_token->str[i] = *str;\n        }\n        ml_add_car(ret, num_token);\n    } else if(isalpha(*str)) {\n        Token var_tok = init_tok(line, 31);\n        size_t i = 0;\n        for(; isalpha(*str) || isdigit(*str) || *str == '_'; i++, str++) {\n            var_tok->str[i] = *str;\n        }\n        ml_add_car(ret, var_tok);\n    } else if(*str) {\n        Token tok = init_tok(line, 1);\n        tok->str[0] = *str;\n        ml_add_car(ret, tok);\n    }\n    ml_add_car(ret, clex(line, str));\n    return ret;\n}\n\nmi_list pLit(String s, mi_list toks) {\n    mi_list ret = init_mi_list();\n    if(toks && !strcmp(s, ((Token)ml_car(toks))->str)) {\n        mi_list tmp = init_mi_list();\n        ml_add_car(tmp, s);\n        ml_add_cdr(tmp, ml_cdr(toks));\n        ml_add_car(ret, tmp);\n    }\n    return ret;\n}\n\n32\u30da\u30fc\u30b8\u307e\u3067\u9032\u3093\u3060\n# 4\u65e5\u76ee\n\n## 1.5.7\n\u7d50\u5c40iseq\u304c\u4f55\u306a\u306e\u304b\u308f\u304b\u3089\u306a\u3044\u307e\u307e1.5.7\u3092\u8fce\u3048\u305f.\u3044\u308d\u3093\u306a\u76ee\u7684\u306e\u305f\u3081\u306biseq\u4f7f\u3046\u3088\u3068\u304b\u66f8\u3044\u3066\u3042\u308b\u306e\u3067\u305d\u306e\u3046\u3061\u56f0\u308b.\n\u56f0\u3063\u305f\u3089haskell\u4f7f\u3046.\n2\u3064\u306egeneral points\u3082\u4f55\u8a00\u3063\u3066\u308b\u304b\u3088\u304f\u308f\u304b\u3089\u306a\u3044.\n\n## 1.6\n\u30d1\u30fc\u30b5\u3092\u4f5c\u308b.\n\n1. \u6700\u521d\u306b\u30d5\u30a1\u30a4\u30eb\u306e\u4e2d\u8eab\u3092\u8aad\u3080.\u3053\u308c\u306f\u7c21\u5358.\n1. \u30ec\u30ad\u30b5\u3092\u4f5c\u3063\u3066\u30c8\u30fc\u30af\u30f3\u306b\u5206\u89e3\u3059\u308b.`clex :: String -> [Token]`\n1. \u6587\u6cd5\u89e3\u6790\u3092\u3057\u3066CoreProgram\u306b\u843d\u3068\u3059.` syntax :: [Token] -> CoreProgram`\n\n\u3046\u30fc\u3093.\u6587\u5b57\u306b\u3055\u308c\u308b\u3068\u7c21\u5358\u305d\u3046\u306b\u898b\u3048\u308b.\n\u30d1\u30fc\u30b5\u81ea\u4f53\u306fclex\u3068syntax\u306e\u7d44\u307f\u5408\u308f\u305b.\n\n```\nparse :: String -> CoreProgram\nparse = syntax . clex\n```\n\n\u30b3\u30e1\u30f3\u30c8\u306b\u3088\u308b\u3068\u3053\u306e\u30d7\u30ed\u30b0\u30e9\u30e0\u306f\u5168\u90e8[Gofer](https://en.wikipedia.org/wiki/Gofer_(programming_language))\u7528\u3089\u3057\u3044.\n\nExercise 1.9\u3067\"||\"\u304b\u3089\u884c\u672b\u307e\u3067\u30b3\u30e1\u30f3\u30c8\u306b\u51fa\u6765\u308b\u3088\u3046\u306b\u3057\u308d\u3063\u3066\u3042\u3063\u305f\u306e\u3067C\u8a00\u8a9e\u98a8\u306b\u30b3\u30e1\u30f3\u30c8\u306e\u59cb\u307e\u308a\u3092\"//\"\u306b\u5909\u3048\u305f.\n\nExercise 1.10\u30672\u6587\u5b57\u6f14\u7b97\u5b50\u306e\u5bfe\u5fdc,1.11\u3067\u884c\u3092\u8868\u793a\u3067\u304d\u308b\u3088\u3046\u306bToken\u578b\u3092\u5909\u3048\u305f.\u30c6\u30b9\u30c8\u306f\u3057\u3066\u306a\u3044.\n\n## 1.6.2\n\u554f\u984c\u306f,\u30d1\u30fc\u30b5\u306e\u65b9\u3092\u4f55\u306b\u3059\u3079\u304d\u304b,\u3060. \u304b\u3089\u30d1\u30fc\u30b5\u3092\u4f5c\u308a\u59cb\u3081\u308b\u3042\u305f\u308a\u3059\u3054\u304f\u95a2\u6570\u578b\u30d7\u30ed\u30b0\u30e9\u30df\u30f3\u30b0\u3063\u307d\u3044.\n`type Parser a = [Token] -> [(a, [Token])]`\u304c\u3082\u3046\u4f55\u8a00\u3063\u3066\u308b\u304b\u308f\u304b\u3093\u306a\u3044.\n\u308f\u304b\u3093\u306a\u3044\u3051\u3069\u307e\u305apLit\u3092\u4f5c\u308b.\n`pLit :: String -> Parser String`\u3068\u306a\u3063\u3066\u3044\u308b\u304b\u3089\u5b9f\u969b\u306b\u306f\n`pLit :: String -> [Token] -> [(String, [Token])]` \u3067,String\u3068[Token]\u3092\u5f15\u6570\u306b\u53d6\u308a[(String, [Token])]\u304c\u5e30\u308b\u95a2\u6570.\n\u3057\u304b\u3057,pAlt\u304c` pAlt :: Parser a -> Parser a -> Parser a`\u3068\u306a\u3063\u3066\u3044\u308b\u306e\u3067,\u9ad8\u968e\u3063\u307d\u304f\u5b9f\u88c5\u3057\u306a\u3044\u3068\u3044\u3051\u306a\u3044\u306e\u304b?\n\u4e00\u5fdcpLit\u3092\u5b9f\u88c5\u3057\u3066\u30b3\u30f3\u30d1\u30a4\u30eb\u3092\u901a\u3057\u305f.\n\n```c\ntypedef struct {\n\tsize_t num;\n\tString str;\n} Token_s;\n typedef Token_s * Token;\n\n Token init_tok(size_t num, size_t len) {\n\tToken ret = (Token)gc_safealloc(sizeof(Token_s));\n\tret->num = num;\n\tret->str = init_str(len);\n\treturn ret;\n }\n\nmi_list clex(size_t line, char *str) {\n\tmi_list ret = init_mi_list();\n\tString twoCharOps[] = {\"==\", \"\u02dc=\", \">=\", \"<=\", \"->\"};\n\tfor(size_t i = 0; i < 5; i++) {\n\t\tif(!strncmp(str, twoCharOps[i], 2)) {\n\t\t\tToken twoop = init_tok(line, 3);\n\t\t\tstrncpy(twoop->str, str, 3);\n\t\t\tml_add_car(ret, twoop);\n\t\t}\n\t}\n\tif(*str == '\\0') {\n\t\treturn ret;\n\t} else if(isspace(*str)) {\n\t\treturn clex(*str == '\\n'?line+1:line, str+1);\n\t} else if(*str == '/' && *(str+1) == '/') {\n\t\tfor(;*str != '\\n';str++);\n\t\treturn clex(line+1, str+1);\n\t} else if(isdigit(*str)) {\n\t\tToken num_token = init_tok(line, 15);\n\t\tsize_t i = 0;\n\t\tfor(; isdigit(*str); i++, str++) {\n\t\t\tnum_token->str[i] = *str;\n\t\t}\n\t\tml_add_car(ret, num_token);\n\t} else if(isalpha(*str)) {\n\t\tToken var_tok = init_tok(line, 31);\n\t\tsize_t i = 0;\n\t\tfor(; isalpha(*str) || isdigit(*str) || *str == '_'; i++, str++) {\n\t\t\tvar_tok->str[i] = *str;\n\t\t}\n\t\tml_add_car(ret, var_tok);\n\t} else if(*str) {\n\t\tToken tok = init_tok(line, 1);\n\t\ttok->str[0] = *str;\n\t\tml_add_car(ret, tok);\n\t}\n\tml_add_car(ret, clex(line, str));\n\treturn ret;\n}\n\nmi_list pLit(String s, mi_list toks) {\n\tmi_list ret = init_mi_list();\n\tif(toks && !strcmp(s, ((Token)ml_car(toks))->str)) {\n\t\tmi_list tmp = init_mi_list();\n\t\tml_add_car(tmp, s);\n\t\tml_add_cdr(tmp, ml_cdr(toks));\n\t\tml_add_car(ret, tmp);\n\t}\n\treturn ret;\n}\n```\n\n**32\u30da\u30fc\u30b8\u307e\u3067\u9032\u3093\u3060**\n", "tags": ["\u30a4\u30f3\u30d7\u30ea\u30e1\u30f3\u30c6\u30a3\u30f3\u30b0\u30d5\u30a1\u30f3\u30af\u30b7\u30e7\u30ca\u30eb\u30e9\u30f3\u30b2\u30fc\u30b8\u30ba"]}