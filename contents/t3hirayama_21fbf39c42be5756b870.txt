{"context": "OpenWhisk\u306f\u3001IBM\u304c\u63d0\u4f9b\u3059\u308b\u30b5\u30fc\u30d0\u30ec\u30b9\u30a2\u30fc\u30ad\u30c6\u30af\u30c1\u30e3\u30fc\u3067\u3059\u3002\nIBM Bluemix\u3001\u307e\u305f\u306fOSS\u3068\u3057\u3066\u5229\u7528\u3067\u304d\u307e\u3059\u3002\n\u300c\u30c8\u30ea\u30ac\u30fc\u300d\u300c\u30a2\u30af\u30b7\u30e7\u30f3\u300d\u300c\u30eb\u30fc\u30eb\u300d\u300c\u30b7\u30fc\u30b1\u30f3\u30b9\u300d\u306e4\u3064\u304b\u3089\u69cb\u6210\u3055\u308c\u307e\u3059\u3002\n\u6982\u8981\u56f3\u306f\u4ee5\u4e0b\u3092\u53c2\u7167\u304f\u3060\u3055\u3044\u3002\nhttps://github.com/openwhisk/openwhisk/blob/master/docs/about.md\n\u2193\u306e\u81ea\u52d5\u5316\u3067\u30c8\u30ea\u30ac\u30fc\u3001\n\u3000\u30b7\u30fc\u30b1\u30f3\u30b9\u3078\u306e\u30ea\u30f3\u30af\u3067\u30b7\u30fc\u30b1\u30f3\u30b9\u3001\n\u3000\u3092\u30a2\u30af\u30b7\u30e7\u30f3\u3068\u95a2\u9023\u4ed8\u3051\u3067\u304d\u307e\u3059\u3002\n\n\n\uff11\uff0e\u30a2\u30af\u30b7\u30e7\u30f3\u4f8b\nAWS Lambda , Azure Function , Google Function \u3082\u8fd1\u3044\u30a2\u30fc\u30ad\u30c6\u30af\u30c1\u30e3\u30fc\u3067\u3059\u304c\u3001\nDocker\u3001Swift\u5bfe\u5fdc\u3084Watson\u9023\u643a\u3060\u3051\u3067\u306f\u306a\u304f\u3001\u30b7\u30fc\u30b1\u30f3\u30b9\u8a2d\u5b9a\u306e\u5206\u304b\u308a\u3084\u3059\u3055\u306b\n\u3068\u30bd\u30fc\u30b9\u304c\u898b\u3048\u308b\u3053\u3068\u3060\u3068\u601d\u3044\u307e\u3059\u3002\n\u305d\u306e\u30bd\u30fc\u30b9\u30b3\u30fc\u30c9\u3092\u898b\u3066\u307f\u307e\u3057\u3087\u3046\u3002\n\nNode.js\nfunction main(params) {\n    return { \"message\": \"you sent me \" + params.message };\n}\n\nPython\nimport sys\ndef main(dict):\n    if 'message' in dict:\n        name = dict['message']\n    else:\n        name = 'stranger'\n    greeting = 'Hello ' + name + '!'\n    print(greeting)\n    return {'greeting':greeting}\n\nSwift\nfunc main(args: [String:Any]) -> [String:Any] {\n      if let message = args[\"message\"] as? String {\n          return [ \"greeting\" : \"Hello (message)!\" ]\n      } else {\n          return [ \"greeting\" : \"Hello stranger!\" ]\n      }\n}\n\nC inside Docker\nDocker\u306e\u5834\u5408\u306f\u3001Dockerhub\u5185\u306b\u8a18\u8f09\u3057\u307e\u3059\u3002\n\u30a4\u30e1\u30fc\u30b8\u3092\u4f7f\u7528\u3057\u3066 \n \u304c dockerhub \n \u306b\u63a5\u7d9a\u3055\u308c\u307e\u3057\u305f: openwhisk/example\n*request parameter\n{\n    \"arg\": \"3\"\n}\n*response\n{\n  \"args\": {\n    \"arg\": \"3\"\n  },\n  \"msg\": \"Hello from arbitrary C program!\"\n}\n\n\uff12\uff0e\u30b7\u30fc\u30b1\u30f3\u30b9\u4f8b\n\u30b7\u30fc\u30b1\u30f3\u30b9\u306fNode.js\u3067\u5b9f\u88c5\u3055\u308c\u307e\u3059\u3002\n\nWebsocket\nWebsocket send sample\u3000\u3067\u3059\u3002\nws.send(payload\u3000\u30fb\u30fb\u30fb\u3000\u90e8\u5206\u304c\u30e1\u30c3\u30bb\u30fc\u30b8\u9001\u4fe1\u3068\u306a\u308a\u307e\u3059\u3002\n/**\n * Sends a payload message to the designated WebSocket URI\n *\n * @param uri       String representation of the WebSocket uri\n * @param payload   Message to send to the WebSocket\n * @return  Standard OpenWhisk success/error response\n */\nfunction main(params) {\n    if (!params.uri) {\n        return whisk.error('You must specify a uri parameter.');\n    }\n    var uri = params.uri; \n   console.log(\"URI param is \" + params.uri);\nif (!params.payload) {\n    return whisk.error('You must specify a payload parameter.');\n}\nvar payload = params.payload;\n\nconsole.log(\"Payload param is \" + params.payload);\n\nvar WebSocket = require('ws');\n\nvar connectionEstablished = false;\nvar ws = new WebSocket(uri);\n\nvar connectionTimeout = 30 * 1000; // 30 seconds\n\nvar promise = new Promise(function(resolve, reject) {\n    setTimeout(function () {\n        if (!connectionEstablished) {\n            reject('Did not establish websocket connection to ' + uri + ' in a timely manner.');\n        }\n    }, connectionTimeout);\n\n    ws.on('open', function () {\n        connectionEstablished = true;\n\n        console.log(\"Sending payload: \" + payload);\n        ws.send(payload, function (error) {\n            if (error) {\n                console.log(\"Error received communicating with websocket: \" + error);\n                ws.close();\n                reject(error);\n            } else {\n                console.log(\"Send was successful.\");\n                ws.close();\n                resolve({\n                    'payload': payload\n                });\n            }\n        });\n    });\n\n    ws.on('error', function (error) {\n        console.log(\"Error communicating with websocket: \" + error);\n        ws.close();\n        reject(error);\n    });\n});\n\nreturn promise;\n\n}\n\nSlack\nSlack\u3078\u306e\u9023\u643a\u3067\u3059\u3002Slack\u306e\u57fa\u672c\u8a8d\u8a3c\u3068\u30e1\u30c3\u30bb\u30fc\u30b8\u304c\u5fc5\u9808\u30d1\u30e9\u30e1\u30fc\u30bf\u3067\u3059\u3002\nvar request = require('request');\n/**\n *   Action to post to slack\n *  @param {string} url - Slack webhook url\n *  @param {string} channel - Slack channel to post the message to\n *  @param {string} username - name to post the message as\n *  @param {string} text - message to post\n *  @param {string} icon_emoji - (optional) emoji to use as the icon for the message\n *  @param {boolean} as_user - (optional) when the token belongs to a bot, whether to post as the bot itself\n *  @param {object} attachments - (optional) message attachments (see Slack documentation for format)\n *  @return {object} whisk async\n */\nfunction main(params) {\nif (checkParams(params)) {\nvar body = {\n  channel: params.channel,\n  username: params.username || 'Simple Message Bot',\n  text: params.text\n};\n\nif (params.icon_emoji) {\n  // guard against sending icon_emoji: undefined\n  body.icon_emoji = params.icon_emoji;\n}\n\nif (params.token) {\n  //\n  // this allows us to support /api/chat.postMessage\n  // e.g. users can pass params.url = https://slack.com/api/chat.postMessage\n  //                 and params.token = <their auth token>\n  //\n  body.token = params.token;\n} else {\n  //\n  // the webhook api expects a nested payload\n  //\n  // notice that we need to stringify; this is due to limitations\n  // of the formData npm: it does not handle nested objects\n  //\n  console.log(body);\n  console.log(\"to: \" + params.url);\n\n  body = {\n    payload: JSON.stringify(body)\n  };\n}\n\nif (params.as_user === true) {\n    body.as_user = true;\n}\n\nif (params.attachments) {\n  body.attachments = params.attachments;\n}\n\nvar promise = new Promise(function (resolve, reject) {\n  request.post({\n    url: params.url,\n    formData: body\n  }, function (err, res, body) {\n    if (err) {\n      console.log('error: ', err, body);\n      reject(err);\n    } else {\n      console.log('success: ', params.text, 'successfully sent');\n      resolve();\n    }\n  });\n});\n\nreturn promise;\n\n}\n}\n/**\nChecks if all required params are set\n*/\nfunction checkParams(params) {\n  if (params.text === undefined) {\n    whisk.error('No text provided');\n    return false;\n  }\n  if (params.url === undefined) {\n    whisk.error('No Webhook URL provided');\n    return false;\n  }\n  if (params.channel === undefined) {\n    whisk.error('No channel provided');\n    return false;\n  }\n  return true;\n}\n\nCloudant\n\u30c9\u30ad\u30e5\u30e1\u30f3\u30c8NoSQLCloudant\u304c\u5909\u66f4\u3055\u308c\u305f\u5834\u5408\u3067\u3059\u3002\n/**\n * Create and update attachment for document in Cloudant database:\n * https://docs.cloudant.com/attachments.html#create-/-update\n **/\nfunction main(message) {\n  var cloudantOrError = getCloudantAccount(message);\n  if (typeof cloudantOrError !== 'object') {\n    return whisk.error('getCloudantAccount returned an unexpected object type.');\n  }\n  var cloudant = cloudantOrError;\n  var dbName = message.dbname;\n  var docId = message.docid;\n  var attName = message.attachmentname;\n  var att = message.attachment;\n  var contentType = message.contenttype;\n  var params = {};\nif(!dbName) {\n    return whisk.error('dbname is required.');\n  }\n  if(!docId) {\n    return whisk.error('docid is required.');\n  }\n  if(!attName) {\n    return whisk.error('attachmentname is required.');\n  }\n  if(!att) {\n    return whisk.error('attachment is required.');\n  }\n  if(!contentType) {\n    return whisk.error('contenttype is required.');\n  }\n  //Add document revision to query if it exists\n  if(typeof message.docrev !== 'undefined') {\n    params.rev = message.docrev;\n  }\n  var cloudantDb = cloudant.use(dbName);\nif (typeof message.params === 'object') {\n    params = message.params;\n  } else if (typeof message.params === 'string') {\n    try {\n      params = JSON.parse(message.params);\n    } catch (e) {\n      return whisk.error('params field cannot be parsed. Ensure it is valid JSON.');\n    }\n  }\nreturn insert(cloudantDb, docId, attName, att, contentType, params);\n}\n/**\n * Insert attachment for document in database.\n */\nfunction insert(cloudantDb, docId, attName, att, contentType, params) {\n  return new Promise(function(resolve, reject) {\n    cloudantDb.attachment.insert(docId, attName, att, contentType, params, function(error, response) {\n      if (!error) {\n        console.log(\"success\", response);\n        resolve(response);\n      } else {\n        console.log(\"error\", error)\n        reject(error);\n      }\n    });\n  });\n}\nfunction getCloudantAccount(message) {\n  // full cloudant URL - Cloudant NPM package has issues creating valid URLs\n  // when the username contains dashes (common in Bluemix scenarios)\n  var cloudantUrl;\nif (message.url) {\n    // use bluemix binding\n    cloudantUrl = message.url;\n  } else {\n    if (!message.host) {\n      whisk.error('cloudant account host is required.');\n      return;\n    }\n    if (!message.username) {\n      whisk.error('cloudant account username is required.');\n      return;\n    }\n    if (!message.password) {\n      whisk.error('cloudant account password is required.');\n      return;\n    }\ncloudantUrl = \"https://\" + message.username + \":\" + message.password + \"@\" + message.host;\n\n}\nreturn require('cloudant')({\n    url: cloudantUrl\n  });\n}\n\nWatson Text to speech\nwatson-developer-cloud\u3092\u547c\u3073\u51fa\u3059\u305f\u3081\u3001\u8a8d\u8a3c\u60c5\u5831\u3001\u6587\u5b57\u60c5\u5831\u7b49\u3092\u9001\u308a\u307e\u3059\u3002\nvar watson = require('watson-developer-cloud');\nfunction isValidEncoding(encoding) {\n  return encoding === 'ascii' ||\n    encoding === 'utf8' ||\n    encoding === 'utf16le' ||\n    encoding === 'ucs2' ||\n    encoding === 'base64' ||\n    encoding === 'binary' ||\n    encoding === 'hex';\n}\n/**\n * Synthesizes text to spoken audio.\n * See https://www.ibm.com/smarterplanet/us/en/ibmwatson/developercloud/text-to-speech/api/v1/\n *\n * @param voice The voice to be used for synthesis. Example: en-US_MichaelVoice\n * @param accept The requested MIME type of the audio. Example: audio/wav\n * @param payload The text to synthesized. Required.\n * @param encoding The encoding of the speech binary data. Defaults to base64.\n * @param username The Watson service username.\n * @param password The Watson service password.\n *\n * @return {\n *  \"payload\": \"\",\n *  \"encoding\": \"\",\n *  \"content_type\": \"\"\n * }\n */\nfunction main(params) {\n  var voice = params.voice;\n  var accept = params.accept;\n  var payload = params.payload;\n  var encoding = isValidEncoding(params.encoding) ? params.encoding : 'base64';\n  var username = params.username;\n  var password = params.password;\nconsole.log('params:', params);\nvar textToSpeech = watson.text_to_speech({\n    username: username,\n    password: password,\n    version: 'v1'\n  });\nvar promise = new Promise(function(resolve, reject) {\n    textToSpeech.synthesize({\n      voice: voice,\n      accept: accept,\n      text: payload,\n    }, function (err, res) {\n      if (err) {\n        reject(err);\n      } else {\n        resolve({\n          payload: res.toString(encoding),\n          encoding: encoding,\n          mimetype: accept\n        });\n      }\n    }, function (err) {\n      reject(err);\n    });\n  });\nreturn promise;\n}\n\nWeather\nBluemix\u4e0a\u306e\nForcast \u60c5\u5831\u3068\u306e\u9023\u52d5\u3067\u3059\u3002\nvar request = require('request');\n/**\n * Get hourly weather forecast for a lat/long from the Weather API service.\n *\n * Must specify one of zipCode or latitude/longitude.\n *\n * @param username The Weather service API account username.\n * @param username The Weather service API account password.\n * @param latitude Latitude of coordinate to get forecast.\n * @param longitude Longitude of coordinate to get forecast.\n * @param zipCode ZIP code of desired forecast.\n * @return The hourly forecast for the lat/long.\n */\nfunction main(params) {\n    console.log('input params:', params);\n    var username = params.username;\n    var password = params.password;\n    var lat = params.latitude || '0';\n    var lon = params.longitude ||  '0';\n    var language = params.language || 'en-US';\n    var units = params.units || 'm';\n    var timePeriod = params.timePeriod || '10day';\n    var url = 'https://twcservice.mybluemix.net/api/weather/v1/geocode/' + lat + '/' + lon;\n    var qs = {language: language, units: units};\nswitch(timePeriod) {\n    case '48hour':\n        url += '/forecast/hourly/48hour.json';\n        break;\n    case 'current':\n        url += '/observations.json';\n        break;\n    case 'timeseries':\n        url += '/observations/timeseries.json';\n        qs.hours = '23';\n        break;\n    case '10day':\n    default:\n        url += '/forecast/daily/10day.json';\n        break;\n}\n\nconsole.log('url:', url);\n\nvar promise = new Promise(function(resolve, reject) {\n    request({\n        url: url,\n        qs: qs,\n        auth: {username: username, password: password},\n        timeout: 30000\n    }, function (error, response, body) {\n        if (!error && response.statusCode === 200) {\n            var j = JSON.parse(body);\n            resolve(j);\n        } else {\n            console.log('error getting forecast');\n            console.log('http status code:', (response || {}).statusCode);\n            console.log('error:', error);\n            console.log('body:', body);\n            reject({\n                error: error,\n                response: response,\n                body: body\n            });\n        }\n    });\n});\n\nreturn promise;\n\n}\n\n\u30b7\u30fc\u30b1\u30f3\u30b9\u95a2\u9023\u4ed8\n\u4ee5\u4e0b\u306f\u3001Cloudand\u306eDocumentDB\u306b\u5909\u66f4\u304c\u3042\u3063\u305f\u5834\u5408\u306b\u30a2\u30af\u30b7\u30e7\u30f3\u304c\u8d77\u52d5\u3059\u308b\u4f8b\u3067\u3059\u3002\n\nOpenWhisk\u306f\u3001IBM\u304c\u63d0\u4f9b\u3059\u308b\u30b5\u30fc\u30d0\u30ec\u30b9\u30a2\u30fc\u30ad\u30c6\u30af\u30c1\u30e3\u30fc\u3067\u3059\u3002\nIBM Bluemix\u3001\u307e\u305f\u306fOSS\u3068\u3057\u3066\u5229\u7528\u3067\u304d\u307e\u3059\u3002\n\u300c\u30c8\u30ea\u30ac\u30fc\u300d\u300c\u30a2\u30af\u30b7\u30e7\u30f3\u300d\u300c\u30eb\u30fc\u30eb\u300d\u300c\u30b7\u30fc\u30b1\u30f3\u30b9\u300d\u306e4\u3064\u304b\u3089\u69cb\u6210\u3055\u308c\u307e\u3059\u3002\n\u6982\u8981\u56f3\u306f\u4ee5\u4e0b\u3092\u53c2\u7167\u304f\u3060\u3055\u3044\u3002\nhttps://github.com/openwhisk/openwhisk/blob/master/docs/about.md\n\n\u2193\u306e\u81ea\u52d5\u5316\u3067\u30c8\u30ea\u30ac\u30fc\u3001\n\u3000\u30b7\u30fc\u30b1\u30f3\u30b9\u3078\u306e\u30ea\u30f3\u30af\u3067\u30b7\u30fc\u30b1\u30f3\u30b9\u3001\n\u3000\u3092\u30a2\u30af\u30b7\u30e7\u30f3\u3068\u95a2\u9023\u4ed8\u3051\u3067\u304d\u307e\u3059\u3002\n\n<img width=\"525\" alt=\"secence action.png\" src=\"https://qiita-image-store.s3.amazonaws.com/0/94200/4b5654b3-5057-6f00-23e5-7f71227c2ea2.png\">\n\n#\uff11\uff0e\u30a2\u30af\u30b7\u30e7\u30f3\u4f8b\n\nAWS Lambda , Azure Function , Google Function \u3082\u8fd1\u3044\u30a2\u30fc\u30ad\u30c6\u30af\u30c1\u30e3\u30fc\u3067\u3059\u304c\u3001\nDocker\u3001Swift\u5bfe\u5fdc\u3084Watson\u9023\u643a\u3060\u3051\u3067\u306f\u306a\u304f\u3001\u30b7\u30fc\u30b1\u30f3\u30b9\u8a2d\u5b9a\u306e\u5206\u304b\u308a\u3084\u3059\u3055\u306b\n\u3068\u30bd\u30fc\u30b9\u304c\u898b\u3048\u308b\u3053\u3068\u3060\u3068\u601d\u3044\u307e\u3059\u3002\n\u305d\u306e\u30bd\u30fc\u30b9\u30b3\u30fc\u30c9\u3092\u898b\u3066\u307f\u307e\u3057\u3087\u3046\u3002\n\n#Node.js\n\nfunction main(params) {\n\treturn { \"message\": \"you sent me \" + params.message };\n}\n\n#Python\n\nimport sys\n\ndef main(dict):\n    if 'message' in dict:\n        name = dict['message']\n    else:\n        name = 'stranger'\n    greeting = 'Hello ' + name + '!'\n    print(greeting)\n    return {'greeting':greeting}\n\n\n#Swift\nfunc main(args: [String:Any]) -> [String:Any] {\n      if let message = args[\"message\"] as? String {\n          return [ \"greeting\" : \"Hello \\(message)!\" ]\n      } else {\n          return [ \"greeting\" : \"Hello stranger!\" ]\n      }\n}\n\n\n# C inside Docker\n\nDocker\u306e\u5834\u5408\u306f\u3001Dockerhub\u5185\u306b\u8a18\u8f09\u3057\u307e\u3059\u3002\n\n\u30a4\u30e1\u30fc\u30b8\u3092\u4f7f\u7528\u3057\u3066 \n \u304c dockerhub \n \u306b\u63a5\u7d9a\u3055\u308c\u307e\u3057\u305f: openwhisk/example\n\n*request parameter\n{\n    \"arg\": \"3\"\n}\n\n\n*response\n{\n  \"args\": {\n    \"arg\": \"3\"\n  },\n  \"msg\": \"Hello from arbitrary C program!\"\n}\n\n#\uff12\uff0e\u30b7\u30fc\u30b1\u30f3\u30b9\u4f8b\n\u30b7\u30fc\u30b1\u30f3\u30b9\u306fNode.js\u3067\u5b9f\u88c5\u3055\u308c\u307e\u3059\u3002\n\n# Websocket \n\nWebsocket send sample\u3000\u3067\u3059\u3002\nws.send(payload\u3000\u30fb\u30fb\u30fb\u3000\u90e8\u5206\u304c\u30e1\u30c3\u30bb\u30fc\u30b8\u9001\u4fe1\u3068\u306a\u308a\u307e\u3059\u3002\n\n\n/**\n * Sends a payload message to the designated WebSocket URI\n *\n * @param uri       String representation of the WebSocket uri\n * @param payload   Message to send to the WebSocket\n * @return  Standard OpenWhisk success/error response\n */\nfunction main(params) {\n    if (!params.uri) {\n        return whisk.error('You must specify a uri parameter.');\n    }\n    var uri = params.uri; \n   console.log(\"URI param is \" + params.uri);\n\n    if (!params.payload) {\n        return whisk.error('You must specify a payload parameter.');\n    }\n    var payload = params.payload;\n\n    console.log(\"Payload param is \" + params.payload);\n\n    var WebSocket = require('ws');\n\n    var connectionEstablished = false;\n    var ws = new WebSocket(uri);\n\n    var connectionTimeout = 30 * 1000; // 30 seconds\n\n    var promise = new Promise(function(resolve, reject) {\n        setTimeout(function () {\n            if (!connectionEstablished) {\n                reject('Did not establish websocket connection to ' + uri + ' in a timely manner.');\n            }\n        }, connectionTimeout);\n\n        ws.on('open', function () {\n            connectionEstablished = true;\n\n            console.log(\"Sending payload: \" + payload);\n            ws.send(payload, function (error) {\n                if (error) {\n                    console.log(\"Error received communicating with websocket: \" + error);\n                    ws.close();\n                    reject(error);\n                } else {\n                    console.log(\"Send was successful.\");\n                    ws.close();\n                    resolve({\n                        'payload': payload\n                    });\n                }\n            });\n        });\n\n        ws.on('error', function (error) {\n            console.log(\"Error communicating with websocket: \" + error);\n            ws.close();\n            reject(error);\n        });\n    });\n\n    return promise;\n}\n\n\n# Slack\n\nSlack\u3078\u306e\u9023\u643a\u3067\u3059\u3002Slack\u306e\u57fa\u672c\u8a8d\u8a3c\u3068\u30e1\u30c3\u30bb\u30fc\u30b8\u304c\u5fc5\u9808\u30d1\u30e9\u30e1\u30fc\u30bf\u3067\u3059\u3002\n\nvar request = require('request');\n\n/**\n *   Action to post to slack\n *  @param {string} url - Slack webhook url\n *  @param {string} channel - Slack channel to post the message to\n *  @param {string} username - name to post the message as\n *  @param {string} text - message to post\n *  @param {string} icon_emoji - (optional) emoji to use as the icon for the message\n *  @param {boolean} as_user - (optional) when the token belongs to a bot, whether to post as the bot itself\n *  @param {object} attachments - (optional) message attachments (see Slack documentation for format)\n *  @return {object} whisk async\n */\nfunction main(params) {\n\n  if (checkParams(params)) {\n\n    var body = {\n      channel: params.channel,\n      username: params.username || 'Simple Message Bot',\n      text: params.text\n    };\n\n    if (params.icon_emoji) {\n      // guard against sending icon_emoji: undefined\n      body.icon_emoji = params.icon_emoji;\n    }\n\n    if (params.token) {\n      //\n      // this allows us to support /api/chat.postMessage\n      // e.g. users can pass params.url = https://slack.com/api/chat.postMessage\n      //                 and params.token = <their auth token>\n      //\n      body.token = params.token;\n    } else {\n      //\n      // the webhook api expects a nested payload\n      //\n      // notice that we need to stringify; this is due to limitations\n      // of the formData npm: it does not handle nested objects\n      //\n      console.log(body);\n      console.log(\"to: \" + params.url);\n\n      body = {\n        payload: JSON.stringify(body)\n      };\n    }\n\n    if (params.as_user === true) {\n        body.as_user = true;\n    }\n\n    if (params.attachments) {\n      body.attachments = params.attachments;\n    }\n\n    var promise = new Promise(function (resolve, reject) {\n      request.post({\n        url: params.url,\n        formData: body\n      }, function (err, res, body) {\n        if (err) {\n          console.log('error: ', err, body);\n          reject(err);\n        } else {\n          console.log('success: ', params.text, 'successfully sent');\n          resolve();\n        }\n      });\n    });\n\n    return promise;\n  }\n}\n\n/**\nChecks if all required params are set\n*/\nfunction checkParams(params) {\n  if (params.text === undefined) {\n    whisk.error('No text provided');\n    return false;\n  }\n  if (params.url === undefined) {\n    whisk.error('No Webhook URL provided');\n    return false;\n  }\n  if (params.channel === undefined) {\n    whisk.error('No channel provided');\n    return false;\n  }\n  return true;\n}\n\n\n# Cloudant \n\n\u30c9\u30ad\u30e5\u30e1\u30f3\u30c8NoSQLCloudant\u304c\u5909\u66f4\u3055\u308c\u305f\u5834\u5408\u3067\u3059\u3002\n\n/**\n * Create and update attachment for document in Cloudant database:\n * https://docs.cloudant.com/attachments.html#create-/-update\n **/\n\nfunction main(message) {\n  var cloudantOrError = getCloudantAccount(message);\n  if (typeof cloudantOrError !== 'object') {\n    return whisk.error('getCloudantAccount returned an unexpected object type.');\n  }\n  var cloudant = cloudantOrError;\n  var dbName = message.dbname;\n  var docId = message.docid;\n  var attName = message.attachmentname;\n  var att = message.attachment;\n  var contentType = message.contenttype;\n  var params = {};\n\n  if(!dbName) {\n    return whisk.error('dbname is required.');\n  }\n  if(!docId) {\n    return whisk.error('docid is required.');\n  }\n  if(!attName) {\n    return whisk.error('attachmentname is required.');\n  }\n  if(!att) {\n    return whisk.error('attachment is required.');\n  }\n  if(!contentType) {\n    return whisk.error('contenttype is required.');\n  }\n  //Add document revision to query if it exists\n  if(typeof message.docrev !== 'undefined') {\n    params.rev = message.docrev;\n  }\n  var cloudantDb = cloudant.use(dbName);\n\n  if (typeof message.params === 'object') {\n    params = message.params;\n  } else if (typeof message.params === 'string') {\n    try {\n      params = JSON.parse(message.params);\n    } catch (e) {\n      return whisk.error('params field cannot be parsed. Ensure it is valid JSON.');\n    }\n  }\n\n  return insert(cloudantDb, docId, attName, att, contentType, params);\n}\n\n/**\n * Insert attachment for document in database.\n */\nfunction insert(cloudantDb, docId, attName, att, contentType, params) {\n  return new Promise(function(resolve, reject) {\n    cloudantDb.attachment.insert(docId, attName, att, contentType, params, function(error, response) {\n      if (!error) {\n        console.log(\"success\", response);\n        resolve(response);\n      } else {\n        console.log(\"error\", error)\n        reject(error);\n      }\n    });\n  });\n}\n\nfunction getCloudantAccount(message) {\n  // full cloudant URL - Cloudant NPM package has issues creating valid URLs\n  // when the username contains dashes (common in Bluemix scenarios)\n  var cloudantUrl;\n\n  if (message.url) {\n    // use bluemix binding\n    cloudantUrl = message.url;\n  } else {\n    if (!message.host) {\n      whisk.error('cloudant account host is required.');\n      return;\n    }\n    if (!message.username) {\n      whisk.error('cloudant account username is required.');\n      return;\n    }\n    if (!message.password) {\n      whisk.error('cloudant account password is required.');\n      return;\n    }\n\n    cloudantUrl = \"https://\" + message.username + \":\" + message.password + \"@\" + message.host;\n  }\n\n  return require('cloudant')({\n    url: cloudantUrl\n  });\n}\n\n# Watson Text to speech\n\nwatson-developer-cloud\u3092\u547c\u3073\u51fa\u3059\u305f\u3081\u3001\u8a8d\u8a3c\u60c5\u5831\u3001\u6587\u5b57\u60c5\u5831\u7b49\u3092\u9001\u308a\u307e\u3059\u3002\n\nvar watson = require('watson-developer-cloud');\n\nfunction isValidEncoding(encoding) {\n  return encoding === 'ascii' ||\n    encoding === 'utf8' ||\n    encoding === 'utf16le' ||\n    encoding === 'ucs2' ||\n    encoding === 'base64' ||\n    encoding === 'binary' ||\n    encoding === 'hex';\n}\n\n/**\n * Synthesizes text to spoken audio.\n * See https://www.ibm.com/smarterplanet/us/en/ibmwatson/developercloud/text-to-speech/api/v1/\n *\n * @param voice The voice to be used for synthesis. Example: en-US_MichaelVoice\n * @param accept The requested MIME type of the audio. Example: audio/wav\n * @param payload The text to synthesized. Required.\n * @param encoding The encoding of the speech binary data. Defaults to base64.\n * @param username The Watson service username.\n * @param password The Watson service password.\n *\n * @return {\n *  \"payload\": \"<encoded speech file>\",\n *  \"encoding\": \"<encoding of payload>\",\n *  \"content_type\": \"<content_type of payload>\"\n * }\n */\nfunction main(params) {\n  var voice = params.voice;\n  var accept = params.accept;\n  var payload = params.payload;\n  var encoding = isValidEncoding(params.encoding) ? params.encoding : 'base64';\n  var username = params.username;\n  var password = params.password;\n\n  console.log('params:', params);\n\n  var textToSpeech = watson.text_to_speech({\n    username: username,\n    password: password,\n    version: 'v1'\n  });\n\n  var promise = new Promise(function(resolve, reject) {\n    textToSpeech.synthesize({\n      voice: voice,\n      accept: accept,\n      text: payload,\n    }, function (err, res) {\n      if (err) {\n        reject(err);\n      } else {\n        resolve({\n          payload: res.toString(encoding),\n          encoding: encoding,\n          mimetype: accept\n        });\n      }\n    }, function (err) {\n      reject(err);\n    });\n  });\n\n  return promise;\n}\n\n\n# Weather \n\nBluemix\u4e0a\u306e\nForcast \u60c5\u5831\u3068\u306e\u9023\u52d5\u3067\u3059\u3002\n\nvar request = require('request');\n\n/**\n * Get hourly weather forecast for a lat/long from the Weather API service.\n *\n * Must specify one of zipCode or latitude/longitude.\n *\n * @param username The Weather service API account username.\n * @param username The Weather service API account password.\n * @param latitude Latitude of coordinate to get forecast.\n * @param longitude Longitude of coordinate to get forecast.\n * @param zipCode ZIP code of desired forecast.\n * @return The hourly forecast for the lat/long.\n */\nfunction main(params) {\n    console.log('input params:', params);\n    var username = params.username;\n    var password = params.password;\n    var lat = params.latitude || '0';\n    var lon = params.longitude ||  '0';\n    var language = params.language || 'en-US';\n    var units = params.units || 'm';\n    var timePeriod = params.timePeriod || '10day';\n    var url = 'https://twcservice.mybluemix.net/api/weather/v1/geocode/' + lat + '/' + lon;\n    var qs = {language: language, units: units};\n\n    switch(timePeriod) {\n        case '48hour':\n            url += '/forecast/hourly/48hour.json';\n            break;\n        case 'current':\n            url += '/observations.json';\n            break;\n        case 'timeseries':\n            url += '/observations/timeseries.json';\n            qs.hours = '23';\n            break;\n        case '10day':\n        default:\n            url += '/forecast/daily/10day.json';\n            break;\n    }\n\n    console.log('url:', url);\n\n    var promise = new Promise(function(resolve, reject) {\n        request({\n            url: url,\n            qs: qs,\n            auth: {username: username, password: password},\n            timeout: 30000\n        }, function (error, response, body) {\n            if (!error && response.statusCode === 200) {\n                var j = JSON.parse(body);\n                resolve(j);\n            } else {\n                console.log('error getting forecast');\n                console.log('http status code:', (response || {}).statusCode);\n                console.log('error:', error);\n                console.log('body:', body);\n                reject({\n                    error: error,\n                    response: response,\n                    body: body\n                });\n            }\n        });\n    });\n\n    return promise;\n}\n\n\n#\u30b7\u30fc\u30b1\u30f3\u30b9\u95a2\u9023\u4ed8\n\n\u4ee5\u4e0b\u306f\u3001Cloudand\u306eDocumentDB\u306b\u5909\u66f4\u304c\u3042\u3063\u305f\u5834\u5408\u306b\u30a2\u30af\u30b7\u30e7\u30f3\u304c\u8d77\u52d5\u3059\u308b\u4f8b\u3067\u3059\u3002\n\n<img width=\"565\" alt=\"relation.png\" src=\"https://qiita-image-store.s3.amazonaws.com/0/94200/f89d7dd5-aa80-2eb4-e55e-352577806355.png\">\n\n", "tags": ["OpenWhisk", "Bluemix"]}