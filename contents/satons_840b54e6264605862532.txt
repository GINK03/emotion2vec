{"tags": ["DAO", "solidity", "\u30b9\u30de\u30fc\u30c8\u30b3\u30f3\u30c8\u30e9\u30af\u30c8", "Ethereum"], "context": "\u30b9\u30de\u30fc\u30c8\u30b3\u30f3\u30c8\u30e9\u30af\u30c8\u3001Ethereum\u3092\u4f7f\u3063\u305fDAO\u3068\u3044\u3046\u306e\u304c\u3042\u308a\u307e\u3059\u3002\n\u30cf\u30c3\u30ad\u30f3\u30b0\u3055\u308c\u305f\u306e\u3067\u6709\u540d\u3067\u3059\u304c\u3001\u30cf\u30c3\u30ad\u30f3\u30b0\u3055\u308c\u308b\u76f4\u524d\u306b\u30bb\u30ad\u30e5\u30ea\u30c6\u30a3\u3092\u4e0a\u3052\u308b\u305f\u3081\u306e\u63d0\u6848\u3092\u3057\u3066\u3044\u3066\u3001\u305d\u3053\u3067\u30d7\u30ed\u30b0\u30e9\u30de\u30fc\u3092\u96c7\u3046\u30b9\u30de\u30fc\u30c8\u30b3\u30f3\u30c8\u30e9\u30af\u30c8\uff08\u6cd5\u95a2\u4fc2\u3092\u5b9f\u884c\u3059\u308b\u30d7\u30ed\u30b0\u30e9\u30e0\uff09\u304c\u66f8\u304b\u308c\u3066\u3044\u305f\u306e\u3067\u753b\u671f\u7684\u30fb\u4e16\u754c\u521d\u3060\u3068\u601d\u3044\u307e\u3059\u3002\n\nSlock.it Proposal #1 - DAO.Security (redux)\nhttps://forum.daohub.org/t/slock-it-proposal-1-dao-security-redux/3536\n\u8a00\u8a9e\u306fSolidity(JavaScript\u30e9\u30a4\u30af\u306a\u8a00\u8a9e\uff09\u3067\u66f8\u304b\u308c\u3066\u3044\u307e\u3059\u3002\n\u30b3\u30fc\u30c9\u5168\u6587\u306f\u3053\u3061\u3089\u306e(\u30ea\u30dd\u30b8\u30c8\u30ea\uff09\n\n\u30b3\u30fc\u30c9\u4e2d\u306b\u3042\u308b\u30e1\u30bd\u30c3\u30c9\nsign:\u30af\u30e9\u30a4\u30a2\u30f3\u30c8\u306b\u3088\u308b\u30b5\u30a4\u30f3\u3002\u3053\u308c\u304c\u5b9f\u884c\u3055\u308c\u308b\u3068\u5b9a\u671f\u306e\u51fa\u91d1\u53ef\u80fd\u306b\u306a\u308b\u3002\n  function sign() {\n        if (msg.sender != address(originalClient) // no good samaritans give us ether\n            || msg.value != totalCosts    // no under/over payment\n            || dateOfSignature != 0)      // don't sign twice\n            throw;\n        if (!contractor.send(oneTimeCosts))\n            throw;\n        dateOfSignature = now;\n        isContractValid = true;\n        lastPayment = now;\n    }\n\ngetDailyPayment(): \u6bce\u65e5\u51fa\u91d1\u3067\u304d\u308b\u3002\n // Withdraw to the Contractor.\n    //\n    // Withdraw the amount of ether the Contractor has right to according to\n    // the current withdraw limit.\n    // Executing this function before the Offer is signed off by the Client\n    // makes no sense as this contract has no ether.\n    function getDailyPayment() noEther {\n        if (msg.sender != contractor)\n            throw;\n        uint timeSinceLastPayment = now - lastPayment;\n        // Calculate the amount using 1 second precision.\n        uint amount = (timeSinceLastPayment * dailyWithdrawLimit) / (1 days);\n        if (amount > this.balance) {\n            amount = this.balance;\n        }\n        if (contractor.send(amount))\n            lastPayment = now;\n    }\n\n\n\u89e3\u96c7\u3082\u3067\u304d\u308b\u3002\n  // \"fire the contractor\"\n    function returnRemainingEther() onlyClient {\n        if (originalClient.DAOrewardAccount().call.value(this.balance)())\n            isContractValid = false;\n    }\n\n\n\u30b3\u30fc\u30c9\u5168\u6587\u306f\u4ee5\u4e0b(\u30ea\u30dd\u30b8\u30c8\u30ea\uff09\ncontract DAOSecurity {\n\n    // The total cost of the Offer. Exactly this amount is transfered from the\n    // Client to the Offer contract when the Offer is signed by the Client.\n    // Set once by the Offerer.\n    uint totalCosts;\n\n    // Initial withdraw to the Contractor. It is done the moment the Offer is\n    // signed.\n    // Set once by the Offerer.\n    uint oneTimeCosts;\n\n    // The minimal daily withdraw limit that the Contractor accepts.\n    // Set once by the Offerer.\n    uint128 minDailyWithdrawLimit;\n\n    // The amount of wei the Contractor has right to withdraw daily above the\n    // initial withdraw. The Contractor does not have to do the withdraws every\n    // day as this amount accumulates.\n    uint128 dailyWithdrawLimit;\n\n    // The address of the Contractor.\n    address contractor;\n\n    // The hash of the Proposal/Offer document.\n    bytes32 hashOfTheProposalDocument;\n\n    // The time of the last withdraw to the Contractor.\n    uint lastPayment;\n\n    uint dateOfSignature;\n    DAO client; // address of DAO\n    DAO originalClient; // address of DAO who signed the contract\n    bool isContractValid;\n\n    modifier onlyClient {\n        if (msg.sender != address(client))\n            throw;\n        _\n    }\n\n    // Prevents methods from perfoming any value transfer\n    modifier noEther() {if (msg.value > 0) throw; _}\n\n    function DAOSecurity(\n        address _contractor,\n        address _client,\n        bytes32 _hashOfTheProposalDocument,\n        uint _totalCosts,\n        uint _oneTimeCosts,\n        uint128 _minDailyWithdrawLimit\n    ) {\n        contractor = _contractor;\n        originalClient = DAO(_client);\n        client = DAO(_client);\n        hashOfTheProposalDocument = _hashOfTheProposalDocument;\n        totalCosts = _totalCosts;\n        oneTimeCosts = _oneTimeCosts;\n        minDailyWithdrawLimit = _minDailyWithdrawLimit;\n        dailyWithdrawLimit = _minDailyWithdrawLimit;\n    }\n\n    // non-value-transfer getters\n    function getTotalCosts() noEther constant returns (uint) {\n        return totalCosts;\n    }\n\n    function getOneTimeCosts() noEther constant returns (uint) {\n        return oneTimeCosts;\n    }\n\n    function getMinDailyWithdrawLimit() noEther constant returns (uint128) {\n        return minDailyWithdrawLimit;\n    }\n\n    function getDailyWithdrawLimit() noEther constant returns (uint128) {\n        return dailyWithdrawLimit;\n    }\n\n    function getContractor() noEther constant returns (address) {\n        return contractor;\n    }\n\n    function getHashOfTheProposalDocument() noEther constant returns (bytes32) {\n        return hashOfTheProposalDocument;\n    }\n\n    function getLastPayment() noEther constant returns (uint) {\n        return lastPayment;\n    }\n\n    function getDateOfSignature() noEther constant returns (uint) {\n        return dateOfSignature;\n    }\n\n    function getClient() noEther constant returns (DAO) {\n        return client;\n    }\n\n    function getOriginalClient() noEther constant returns (DAO) {\n        return originalClient;\n    }\n\n    function getIsContractValid() noEther constant returns (bool) {\n        return isContractValid;\n    }\n\n    function sign() {\n        if (msg.sender != address(originalClient) // no good samaritans give us ether\n            || msg.value != totalCosts    // no under/over payment\n            || dateOfSignature != 0)      // don't sign twice\n            throw;\n        if (!contractor.send(oneTimeCosts))\n            throw;\n        dateOfSignature = now;\n        isContractValid = true;\n        lastPayment = now;\n    }\n\n    function setDailyWithdrawLimit(uint128 _dailyWithdrawLimit) onlyClient noEther {\n        if (_dailyWithdrawLimit >= minDailyWithdrawLimit)\n            dailyWithdrawLimit = _dailyWithdrawLimit;\n    }\n\n    // \"fire the contractor\"\n    function returnRemainingEther() onlyClient {\n        if (originalClient.DAOrewardAccount().call.value(this.balance)())\n            isContractValid = false;\n    }\n\n    // Withdraw to the Contractor.\n    //\n    // Withdraw the amount of ether the Contractor has right to according to\n    // the current withdraw limit.\n    // Executing this function before the Offer is signed off by the Client\n    // makes no sense as this contract has no ether.\n    function getDailyPayment() noEther {\n        if (msg.sender != contractor)\n            throw;\n        uint timeSinceLastPayment = now - lastPayment;\n        // Calculate the amount using 1 second precision.\n        uint amount = (timeSinceLastPayment * dailyWithdrawLimit) / (1 days);\n        if (amount > this.balance) {\n            amount = this.balance;\n        }\n        if (contractor.send(amount))\n            lastPayment = now;\n    }\n\n    // Change the client DAO by giving the new DAO's address\n    // warning: The new DAO must come either from a split of the original\n    // DAO or an update via `newContract()` so that it can claim rewards\n    function updateClientAddress(DAO _newClient) onlyClient noEther {\n        client = _newClient;\n    }\n\n    function () {\n        throw; // this is a business contract, no donations\n    }\n}\nContact GitHub API Training Shop Blog About\n\u00a9 2017 GitHub, Inc. Terms Privacy Security Status Help\n\n\n\n\u30b9\u30de\u30fc\u30c8\u30b3\u30f3\u30c8\u30e9\u30af\u30c8\u3001Ethereum\u3092\u4f7f\u3063\u305fDAO\u3068\u3044\u3046\u306e\u304c\u3042\u308a\u307e\u3059\u3002\n\n\u30cf\u30c3\u30ad\u30f3\u30b0\u3055\u308c\u305f\u306e\u3067\u6709\u540d\u3067\u3059\u304c\u3001\u30cf\u30c3\u30ad\u30f3\u30b0\u3055\u308c\u308b\u76f4\u524d\u306b\u30bb\u30ad\u30e5\u30ea\u30c6\u30a3\u3092\u4e0a\u3052\u308b\u305f\u3081\u306e\u63d0\u6848\u3092\u3057\u3066\u3044\u3066\u3001\u305d\u3053\u3067\u30d7\u30ed\u30b0\u30e9\u30de\u30fc\u3092\u96c7\u3046\u30b9\u30de\u30fc\u30c8\u30b3\u30f3\u30c8\u30e9\u30af\u30c8\uff08\u6cd5\u95a2\u4fc2\u3092\u5b9f\u884c\u3059\u308b\u30d7\u30ed\u30b0\u30e9\u30e0\uff09\u304c\u66f8\u304b\u308c\u3066\u3044\u305f\u306e\u3067\u753b\u671f\u7684\u30fb\u4e16\u754c\u521d\u3060\u3068\u601d\u3044\u307e\u3059\u3002\n\n###Slock.it Proposal #1 - DAO.Security (redux)\nhttps://forum.daohub.org/t/slock-it-proposal-1-dao-security-redux/3536\n\n\u8a00\u8a9e\u306fSolidity(JavaScript\u30e9\u30a4\u30af\u306a\u8a00\u8a9e\uff09\u3067\u66f8\u304b\u308c\u3066\u3044\u307e\u3059\u3002\n\n\u30b3\u30fc\u30c9\u5168\u6587\u306f\u3053\u3061\u3089\u306e([\u30ea\u30dd\u30b8\u30c8\u30ea](https://github.com/slockit/smart-contract/blob/master/DAOSecurity.sol)\uff09\n\n##\u30b3\u30fc\u30c9\u4e2d\u306b\u3042\u308b\u30e1\u30bd\u30c3\u30c9\n\n\nsign:\u30af\u30e9\u30a4\u30a2\u30f3\u30c8\u306b\u3088\u308b\u30b5\u30a4\u30f3\u3002\u3053\u308c\u304c\u5b9f\u884c\u3055\u308c\u308b\u3068\u5b9a\u671f\u306e\u51fa\u91d1\u53ef\u80fd\u306b\u306a\u308b\u3002\n\n```\n  function sign() {\n        if (msg.sender != address(originalClient) // no good samaritans give us ether\n            || msg.value != totalCosts    // no under/over payment\n            || dateOfSignature != 0)      // don't sign twice\n            throw;\n        if (!contractor.send(oneTimeCosts))\n            throw;\n        dateOfSignature = now;\n        isContractValid = true;\n        lastPayment = now;\n    }\n```\n\ngetDailyPayment(): \u6bce\u65e5\u51fa\u91d1\u3067\u304d\u308b\u3002\n\n```\n // Withdraw to the Contractor.\n    //\n    // Withdraw the amount of ether the Contractor has right to according to\n    // the current withdraw limit.\n    // Executing this function before the Offer is signed off by the Client\n    // makes no sense as this contract has no ether.\n    function getDailyPayment() noEther {\n        if (msg.sender != contractor)\n            throw;\n        uint timeSinceLastPayment = now - lastPayment;\n        // Calculate the amount using 1 second precision.\n        uint amount = (timeSinceLastPayment * dailyWithdrawLimit) / (1 days);\n        if (amount > this.balance) {\n            amount = this.balance;\n        }\n        if (contractor.send(amount))\n            lastPayment = now;\n    }\n\n```\n\n\u89e3\u96c7\u3082\u3067\u304d\u308b\u3002\n\n```\u89e3\u96c7\u3059\u308b\u30e1\u30bd\u30c3\u30c9\n  // \"fire the contractor\"\n    function returnRemainingEther() onlyClient {\n        if (originalClient.DAOrewardAccount().call.value(this.balance)())\n            isContractValid = false;\n    }\n```\n\n\n\n##\u30b3\u30fc\u30c9\u5168\u6587\u306f\u4ee5\u4e0b([\u30ea\u30dd\u30b8\u30c8\u30ea](https://github.com/slockit/smart-contract/blob/master/DAOSecurity.sol)\uff09\n\n\n```\ncontract DAOSecurity {\n\n    // The total cost of the Offer. Exactly this amount is transfered from the\n    // Client to the Offer contract when the Offer is signed by the Client.\n    // Set once by the Offerer.\n    uint totalCosts;\n\n    // Initial withdraw to the Contractor. It is done the moment the Offer is\n    // signed.\n    // Set once by the Offerer.\n    uint oneTimeCosts;\n\n    // The minimal daily withdraw limit that the Contractor accepts.\n    // Set once by the Offerer.\n    uint128 minDailyWithdrawLimit;\n\n    // The amount of wei the Contractor has right to withdraw daily above the\n    // initial withdraw. The Contractor does not have to do the withdraws every\n    // day as this amount accumulates.\n    uint128 dailyWithdrawLimit;\n\n    // The address of the Contractor.\n    address contractor;\n\n    // The hash of the Proposal/Offer document.\n    bytes32 hashOfTheProposalDocument;\n\n    // The time of the last withdraw to the Contractor.\n    uint lastPayment;\n\n    uint dateOfSignature;\n    DAO client; // address of DAO\n    DAO originalClient; // address of DAO who signed the contract\n    bool isContractValid;\n\n    modifier onlyClient {\n        if (msg.sender != address(client))\n            throw;\n        _\n    }\n\n    // Prevents methods from perfoming any value transfer\n    modifier noEther() {if (msg.value > 0) throw; _}\n\n    function DAOSecurity(\n        address _contractor,\n        address _client,\n        bytes32 _hashOfTheProposalDocument,\n        uint _totalCosts,\n        uint _oneTimeCosts,\n        uint128 _minDailyWithdrawLimit\n    ) {\n        contractor = _contractor;\n        originalClient = DAO(_client);\n        client = DAO(_client);\n        hashOfTheProposalDocument = _hashOfTheProposalDocument;\n        totalCosts = _totalCosts;\n        oneTimeCosts = _oneTimeCosts;\n        minDailyWithdrawLimit = _minDailyWithdrawLimit;\n        dailyWithdrawLimit = _minDailyWithdrawLimit;\n    }\n\n    // non-value-transfer getters\n    function getTotalCosts() noEther constant returns (uint) {\n        return totalCosts;\n    }\n\n    function getOneTimeCosts() noEther constant returns (uint) {\n        return oneTimeCosts;\n    }\n\n    function getMinDailyWithdrawLimit() noEther constant returns (uint128) {\n        return minDailyWithdrawLimit;\n    }\n\n    function getDailyWithdrawLimit() noEther constant returns (uint128) {\n        return dailyWithdrawLimit;\n    }\n\n    function getContractor() noEther constant returns (address) {\n        return contractor;\n    }\n\n    function getHashOfTheProposalDocument() noEther constant returns (bytes32) {\n        return hashOfTheProposalDocument;\n    }\n\n    function getLastPayment() noEther constant returns (uint) {\n        return lastPayment;\n    }\n\n    function getDateOfSignature() noEther constant returns (uint) {\n        return dateOfSignature;\n    }\n\n    function getClient() noEther constant returns (DAO) {\n        return client;\n    }\n\n    function getOriginalClient() noEther constant returns (DAO) {\n        return originalClient;\n    }\n\n    function getIsContractValid() noEther constant returns (bool) {\n        return isContractValid;\n    }\n\n    function sign() {\n        if (msg.sender != address(originalClient) // no good samaritans give us ether\n            || msg.value != totalCosts    // no under/over payment\n            || dateOfSignature != 0)      // don't sign twice\n            throw;\n        if (!contractor.send(oneTimeCosts))\n            throw;\n        dateOfSignature = now;\n        isContractValid = true;\n        lastPayment = now;\n    }\n\n    function setDailyWithdrawLimit(uint128 _dailyWithdrawLimit) onlyClient noEther {\n        if (_dailyWithdrawLimit >= minDailyWithdrawLimit)\n            dailyWithdrawLimit = _dailyWithdrawLimit;\n    }\n\n    // \"fire the contractor\"\n    function returnRemainingEther() onlyClient {\n        if (originalClient.DAOrewardAccount().call.value(this.balance)())\n            isContractValid = false;\n    }\n\n    // Withdraw to the Contractor.\n    //\n    // Withdraw the amount of ether the Contractor has right to according to\n    // the current withdraw limit.\n    // Executing this function before the Offer is signed off by the Client\n    // makes no sense as this contract has no ether.\n    function getDailyPayment() noEther {\n        if (msg.sender != contractor)\n            throw;\n        uint timeSinceLastPayment = now - lastPayment;\n        // Calculate the amount using 1 second precision.\n        uint amount = (timeSinceLastPayment * dailyWithdrawLimit) / (1 days);\n        if (amount > this.balance) {\n            amount = this.balance;\n        }\n        if (contractor.send(amount))\n            lastPayment = now;\n    }\n\n    // Change the client DAO by giving the new DAO's address\n    // warning: The new DAO must come either from a split of the original\n    // DAO or an update via `newContract()` so that it can claim rewards\n    function updateClientAddress(DAO _newClient) onlyClient noEther {\n        client = _newClient;\n    }\n\n    function () {\n        throw; // this is a business contract, no donations\n    }\n}\nContact GitHub API Training Shop Blog About\n\u00a9 2017 GitHub, Inc. Terms Privacy Security Status Help\n```\n"}