{"context": " More than 1 year has passed since last update.OpenAL \u306e\u30d8\u30eb\u30d1\u30fc\u30e9\u30a4\u30d6\u30e9\u30ea\u3067\u3042\u308b ALURE \u306b\u5b9f\u88c5\u3055\u308c\u3066\u3044\u308b\u30ab\u30b9\u30bf\u30e0\u30c7\u30b3\u30fc\u30c0\u306e\u6a5f\u80fd\u3092\u4f7f\u3063\u3066\u30c7\u30d5\u30a9\u30eb\u30c8\u3067\u306f\u5bfe\u5fdc\u3057\u3066\u3044\u306a\u3044 mp3 \u3084 aac \u3092 AVFoundation \u3092\u5229\u7528\u3057\u3066 OpenAL \u4e0a\u3067\u3082\u518d\u751f\u51fa\u6765\u308b\u3088\u3046\u306b\u3059\u308b\u30b3\u30fc\u30c9\u3092\u66f8\u3044\u3066\u307f\u308b\u3002\n\n\u30ab\u30b9\u30bf\u30e0\u30c7\u30b3\u30fc\u30c0\u306e\u5b9f\u88c5\n\u30a8\u30e9\u30fc\u51e6\u7406\u304c\u306a\u3044\u306e\u3067\u3001\u5b9f\u969b\u306b\u4f7f\u3046\u969b\u306f\u30a8\u30e9\u30fc\u51e6\u7406\u3092\u66f8\u3044\u3066\u304a\u304f\u3053\u3068\u3002\n#import <AVFoundation/AVFoundation.h>\n#import <OpenAL/al.h>\n\n#include \"OpenAL/alure.h\"\n\n/* ARC \u524d\u63d0 */\nstruct AlureDecoder {\n    AlureDecoder(const char *path)\n    : asset(nil),\n      reader(nil),\n      output(nil)\n    {\n        NSString *filePath = [[NSString alloc] initWithUTF8String:path];\n        NSURL *fileUrl = [[NSURL alloc] initFileURLWithPath:filePath];\n        asset = [AVURLAsset assetWithURL:fileUrl];\n        NSError *error = nil;\n        reader = [[AVAssetReader alloc] initWithAsset:asset error:&error];\n        if (error == nil) {\n            /* \u30aa\u30fc\u30c7\u30a3\u30aa\u30c8\u30e9\u30c3\u30af\u306e\u307f\u3092\u53d6\u308a\u51fa\u3059 */\n            NSArray *tracks = [asset tracksWithMediaType:AVMediaTypeAudio];\n            /* 44.1KHz 2ch 16bits PCM \u3067\u53d6\u308a\u51fa\u3059\u8a2d\u5b9a\u3092\u884c\u3046 */\n            NSDictionary *outputSettings = [[NSDictionary alloc] initWithObjectsAndKeys:[NSNumber numberWithUnsignedLong:kAudioFormatLinearPCM], AVFormatIDKey, [NSNumber numberWithFloat:44100.0f], AVSampleRateKey, [NSNumber numberWithInt:2], AVNumberOfChannelsKey, [NSNumber numberWithBool:NO], AVLinearPCMIsNonInterleavedKey, [NSNumber numberWithBool:NO], AVLinearPCMIsBigEndianKey, [NSNumber numberWithBool:NO], AVLinearPCMIsFloatKey, [NSNumber numberWithInt:16], AVLinearPCMBitDepthKey, nil];\n            output = [[AVAssetReaderAudioMixOutput alloc] initWithAudioTracks:tracks audioSettings:outputSettings];\n            if ([reader canAddOutput:output]) {\n                [reader addOutput:output];\n                [reader startReading];\n            }\n            else {\n                /* \u30a8\u30e9\u30fc\u51e6\u7406\uff08\u666e\u901a\u3053\u3053\u306b\u5230\u9054\u3057\u306a\u3044\u306f\u305a\uff09 */\n            }\n        }\n        else {\n            /* \u30a8\u30e9\u30fc\u51e6\u7406 */\n        }\n    }\n    ~AlureDecoder() {\n    }\n    static void install() {\n        alureInstallDecodeCallbacks(0, createFromFile, createFromMemory, getFormat, decode, rewind, destroy);\n    }\n    static void *createFromFile(const ALchar *path) {\n        AlureDecoder *decoder = new AlureDecoder(path);\n        return decoder;\n    }\n    static void *createFromMemory(const ALubyte * /* bytes */, ALuint /* buffer */) {\n        /* \u672a\u5bfe\u5fdc */\n        return 0;\n    }\n    static ALboolean getFormat(void *opaque, ALenum *format, ALuint *samples, ALuint *bps) {\n        /* \u51fa\u529b\u8a2d\u5b9a\u306b\u5f93\u3063\u3066\u8a2d\u5b9a */\n        *format = AL_FORMAT_STEREO16;\n        *samples = 44100;\n        /* channels * (bits / 8) */\n        *bps = 4;\n        return AL_TRUE;\n    }\n    static ALuint decode(void *opaque, ALubyte *bytes, ALuint size) {\n        ALuint output = 0;\n        AlureDecoder *decoder = static_cast<AlureDecoder *>(opaque);\n        if (decoder->reader.status == AVAssetReaderStatusReading) {\n            CMSampleBufferRef sampleBuffer = [decoder->output copyNextSampleBuffer];\n            if (sampleBuffer) {\n                AudioBufferList audioBufferList;\n                CMBlockBufferRef blockBuffer;\n                /* \u751f\u306e PCM \u30c7\u30fc\u30bf\u3092\u53d6\u308a\u51fa\u3057\u3001bytes \u306b\u30b3\u30d4\u30fc\u3059\u308b */\n                CMSampleBufferGetAudioBufferListWithRetainedBlockBuffer(sampleBuffer, NULL, &audioBufferList, sizeof(audioBufferList), NULL, NULL, kCMSampleBufferFlag_AudioBufferList_Assure16ByteAlignment, &blockBuffer);\n                UInt64 sampleSize = CMSampleBufferGetTotalSampleSize(sampleBuffer);\n                memcpy(bytes, audioBufferList.mBuffers[0].mData, sampleSize);\n                CFRelease(blockBuffer);\n                CFRelease(sampleBuffer);\n                output = ALuint(sampleSize);\n            }\n        }\n        /* \uff08\u30a8\u30e9\u30fc\u542b\u3080\uff09\u8aad\u307f\u8fbc\u307f\u5b8c\u4e86\u3057\u305f\u5834\u5408 0 \u3092\u8fd4\u3059 */\n        return output;\n    }\n    static ALboolean rewind(void * /* opaque */) {\n        /* \u672a\u5bfe\u5fdc */\n        return AL_FALSE;\n    }\n    static void destroy(void *opaque) {\n        AlureDecoder *decoder = static_cast<AlureDecoder *>(opaque);\n        delete decoder;\n    }\n    AVAsset *asset;\n    AVAssetReader *reader;\n    AVAssetReaderAudioMixOutput *output;\n};\n\n\n\u52d5\u4f5c\u78ba\u8a8d\u306e\u305f\u3081\u306e\u5b9f\u88c5\n\u4ee5\u4e0b\u306f\u52d5\u4f5c\u78ba\u8a8d\u306e\u305f\u3081\u306e\u30b3\u30fc\u30c9\u3002\u30b3\u30f3\u30d1\u30a4\u30eb\u3059\u308b\u969b\u306f\u5148\u307b\u3069\u306e\u30b3\u30fc\u30c9\u3068 AVFoundation.framework \u3068 OpenAL.framework \u3068 ALURE \u3092\u30ea\u30f3\u30af\u3059\u308b\u5fc5\u8981\u304c\u3042\u308b\u3002\nstatic bool g_playing = true;\n\nstatic void callback(void *opaque, ALuint source)\n{\n    g_playing = false;\n}\n\nint main(int argc, const char * argv[])\n{\n    @autoreleasepool {\n        alureInitDevice(NULL, NULL);\n        AlureDecoder::install();\n        ALuint buffer, source;\n        alGenBuffers(1, &buffer);\n        alGenSources(1, &source);\n        alureBufferDataFromFile(\"/path/to/audio.mp3\", buffer);\n        alSourcei(source, AL_BUFFER, buffer);\n        if (alurePlaySource(source, callback, NULL)) {\n            while (g_playing) {\n                alureSleep(0.125f);\n                alureUpdate();\n            }\n        }\n        alDeleteBuffers(1, &buffer);\n        alDeleteSources(1, &source);\n        alureShutdownDevice();\n    }\n    return 0;\n}\n\nALURE \u306f\u5916\u90e8\u5411\u3051\u306e API \u306f C \u3067\u306f\u3042\u308b\u304c\u5185\u90e8\u5b9f\u88c5\u306f C++ \u306e\u305f\u3081\u9759\u7684\u30ea\u30f3\u30af\u3059\u308b\u5834\u5408\u306f C++ \u3068\u3057\u3066\u30b3\u30f3\u30d1\u30a4\u30eb\u3059\u308b\u5fc5\u8981\u304c\u3042\u308b\u3002\n\n\u304a\u307e\u3051\n\u30d0\u30c3\u30d5\u30a1\u306e\u9577\u3055\u3092\u6c42\u3081\u308b\u969b\u306f\u30b5\u30a4\u30ba\u304b\u3089\u8a08\u7b97\u3059\u308b\nint size, channels, bits, frequency, bytesPerSecond, durationSeconds;\nalGetBufferi(buffer, AL_SIZE, &size);\nalGetBufferi(buffer, AL_CHANNELS, &channels);\nalGetBufferi(buffer, AL_BITS, &bits);\nalGetBufferi(buffer, AL_FREQUENCY, &frequency);\nbytesPerSecond = (frequency * channels * bits) / 8;\ndurationSeconds = size / bytesPerSecond;\n\nfrom http://stackoverflow.com/questions/7978912/how-to-get-length-duration-of-a-source-with-single-buffer-in-openal\n\n[OpenAL](http://openal.org) \u306e\u30d8\u30eb\u30d1\u30fc\u30e9\u30a4\u30d6\u30e9\u30ea\u3067\u3042\u308b [ALURE](http://kcat.strangesoft.net/alure.html) \u306b\u5b9f\u88c5\u3055\u308c\u3066\u3044\u308b\u30ab\u30b9\u30bf\u30e0\u30c7\u30b3\u30fc\u30c0\u306e\u6a5f\u80fd\u3092\u4f7f\u3063\u3066\u30c7\u30d5\u30a9\u30eb\u30c8\u3067\u306f\u5bfe\u5fdc\u3057\u3066\u3044\u306a\u3044 mp3 \u3084 aac \u3092 AVFoundation \u3092\u5229\u7528\u3057\u3066 OpenAL \u4e0a\u3067\u3082\u518d\u751f\u51fa\u6765\u308b\u3088\u3046\u306b\u3059\u308b\u30b3\u30fc\u30c9\u3092\u66f8\u3044\u3066\u307f\u308b\u3002\n\n## \u30ab\u30b9\u30bf\u30e0\u30c7\u30b3\u30fc\u30c0\u306e\u5b9f\u88c5\n\n\u30a8\u30e9\u30fc\u51e6\u7406\u304c\u306a\u3044\u306e\u3067\u3001\u5b9f\u969b\u306b\u4f7f\u3046\u969b\u306f\u30a8\u30e9\u30fc\u51e6\u7406\u3092\u66f8\u3044\u3066\u304a\u304f\u3053\u3068\u3002\n\n```objc++\n#import <AVFoundation/AVFoundation.h>\n#import <OpenAL/al.h>\n\n#include \"OpenAL/alure.h\"\n\n/* ARC \u524d\u63d0 */\nstruct AlureDecoder {\n    AlureDecoder(const char *path)\n    : asset(nil),\n      reader(nil),\n      output(nil)\n    {\n        NSString *filePath = [[NSString alloc] initWithUTF8String:path];\n        NSURL *fileUrl = [[NSURL alloc] initFileURLWithPath:filePath];\n        asset = [AVURLAsset assetWithURL:fileUrl];\n        NSError *error = nil;\n        reader = [[AVAssetReader alloc] initWithAsset:asset error:&error];\n        if (error == nil) {\n            /* \u30aa\u30fc\u30c7\u30a3\u30aa\u30c8\u30e9\u30c3\u30af\u306e\u307f\u3092\u53d6\u308a\u51fa\u3059 */\n            NSArray *tracks = [asset tracksWithMediaType:AVMediaTypeAudio];\n            /* 44.1KHz 2ch 16bits PCM \u3067\u53d6\u308a\u51fa\u3059\u8a2d\u5b9a\u3092\u884c\u3046 */\n            NSDictionary *outputSettings = [[NSDictionary alloc] initWithObjectsAndKeys:[NSNumber numberWithUnsignedLong:kAudioFormatLinearPCM], AVFormatIDKey, [NSNumber numberWithFloat:44100.0f], AVSampleRateKey, [NSNumber numberWithInt:2], AVNumberOfChannelsKey, [NSNumber numberWithBool:NO], AVLinearPCMIsNonInterleavedKey, [NSNumber numberWithBool:NO], AVLinearPCMIsBigEndianKey, [NSNumber numberWithBool:NO], AVLinearPCMIsFloatKey, [NSNumber numberWithInt:16], AVLinearPCMBitDepthKey, nil];\n            output = [[AVAssetReaderAudioMixOutput alloc] initWithAudioTracks:tracks audioSettings:outputSettings];\n            if ([reader canAddOutput:output]) {\n                [reader addOutput:output];\n                [reader startReading];\n            }\n            else {\n                /* \u30a8\u30e9\u30fc\u51e6\u7406\uff08\u666e\u901a\u3053\u3053\u306b\u5230\u9054\u3057\u306a\u3044\u306f\u305a\uff09 */\n            }\n        }\n        else {\n            /* \u30a8\u30e9\u30fc\u51e6\u7406 */\n        }\n    }\n    ~AlureDecoder() {\n    }\n    static void install() {\n        alureInstallDecodeCallbacks(0, createFromFile, createFromMemory, getFormat, decode, rewind, destroy);\n    }\n    static void *createFromFile(const ALchar *path) {\n        AlureDecoder *decoder = new AlureDecoder(path);\n        return decoder;\n    }\n    static void *createFromMemory(const ALubyte * /* bytes */, ALuint /* buffer */) {\n        /* \u672a\u5bfe\u5fdc */\n        return 0;\n    }\n    static ALboolean getFormat(void *opaque, ALenum *format, ALuint *samples, ALuint *bps) {\n        /* \u51fa\u529b\u8a2d\u5b9a\u306b\u5f93\u3063\u3066\u8a2d\u5b9a */\n        *format = AL_FORMAT_STEREO16;\n        *samples = 44100;\n        /* channels * (bits / 8) */\n        *bps = 4;\n        return AL_TRUE;\n    }\n    static ALuint decode(void *opaque, ALubyte *bytes, ALuint size) {\n        ALuint output = 0;\n        AlureDecoder *decoder = static_cast<AlureDecoder *>(opaque);\n        if (decoder->reader.status == AVAssetReaderStatusReading) {\n            CMSampleBufferRef sampleBuffer = [decoder->output copyNextSampleBuffer];\n            if (sampleBuffer) {\n                AudioBufferList audioBufferList;\n                CMBlockBufferRef blockBuffer;\n                /* \u751f\u306e PCM \u30c7\u30fc\u30bf\u3092\u53d6\u308a\u51fa\u3057\u3001bytes \u306b\u30b3\u30d4\u30fc\u3059\u308b */\n                CMSampleBufferGetAudioBufferListWithRetainedBlockBuffer(sampleBuffer, NULL, &audioBufferList, sizeof(audioBufferList), NULL, NULL, kCMSampleBufferFlag_AudioBufferList_Assure16ByteAlignment, &blockBuffer);\n                UInt64 sampleSize = CMSampleBufferGetTotalSampleSize(sampleBuffer);\n                memcpy(bytes, audioBufferList.mBuffers[0].mData, sampleSize);\n                CFRelease(blockBuffer);\n                CFRelease(sampleBuffer);\n                output = ALuint(sampleSize);\n            }\n        }\n        /* \uff08\u30a8\u30e9\u30fc\u542b\u3080\uff09\u8aad\u307f\u8fbc\u307f\u5b8c\u4e86\u3057\u305f\u5834\u5408 0 \u3092\u8fd4\u3059 */\n        return output;\n    }\n    static ALboolean rewind(void * /* opaque */) {\n        /* \u672a\u5bfe\u5fdc */\n        return AL_FALSE;\n    }\n    static void destroy(void *opaque) {\n        AlureDecoder *decoder = static_cast<AlureDecoder *>(opaque);\n        delete decoder;\n    }\n    AVAsset *asset;\n    AVAssetReader *reader;\n    AVAssetReaderAudioMixOutput *output;\n};\n```\n\n## \u52d5\u4f5c\u78ba\u8a8d\u306e\u305f\u3081\u306e\u5b9f\u88c5\n\n\u4ee5\u4e0b\u306f\u52d5\u4f5c\u78ba\u8a8d\u306e\u305f\u3081\u306e\u30b3\u30fc\u30c9\u3002\u30b3\u30f3\u30d1\u30a4\u30eb\u3059\u308b\u969b\u306f\u5148\u307b\u3069\u306e\u30b3\u30fc\u30c9\u3068 AVFoundation.framework \u3068 OpenAL.framework \u3068 ALURE \u3092\u30ea\u30f3\u30af\u3059\u308b\u5fc5\u8981\u304c\u3042\u308b\u3002\n\n```objc++\nstatic bool g_playing = true;\n\nstatic void callback(void *opaque, ALuint source)\n{\n    g_playing = false;\n}\n\nint main(int argc, const char * argv[])\n{\n    @autoreleasepool {\n        alureInitDevice(NULL, NULL);\n        AlureDecoder::install();\n        ALuint buffer, source;\n        alGenBuffers(1, &buffer);\n        alGenSources(1, &source);\n        alureBufferDataFromFile(\"/path/to/audio.mp3\", buffer);\n        alSourcei(source, AL_BUFFER, buffer);\n        if (alurePlaySource(source, callback, NULL)) {\n            while (g_playing) {\n                alureSleep(0.125f);\n                alureUpdate();\n            }\n        }\n        alDeleteBuffers(1, &buffer);\n        alDeleteSources(1, &source);\n        alureShutdownDevice();\n    }\n    return 0;\n}\n```\n\nALURE \u306f\u5916\u90e8\u5411\u3051\u306e API \u306f C \u3067\u306f\u3042\u308b\u304c\u5185\u90e8\u5b9f\u88c5\u306f C++ \u306e\u305f\u3081\u9759\u7684\u30ea\u30f3\u30af\u3059\u308b\u5834\u5408\u306f C++ \u3068\u3057\u3066\u30b3\u30f3\u30d1\u30a4\u30eb\u3059\u308b\u5fc5\u8981\u304c\u3042\u308b\u3002\n\n### \u304a\u307e\u3051\n\n\u30d0\u30c3\u30d5\u30a1\u306e\u9577\u3055\u3092\u6c42\u3081\u308b\u969b\u306f\u30b5\u30a4\u30ba\u304b\u3089\u8a08\u7b97\u3059\u308b\n\n```c\nint size, channels, bits, frequency, bytesPerSecond, durationSeconds;\nalGetBufferi(buffer, AL_SIZE, &size);\nalGetBufferi(buffer, AL_CHANNELS, &channels);\nalGetBufferi(buffer, AL_BITS, &bits);\nalGetBufferi(buffer, AL_FREQUENCY, &frequency);\nbytesPerSecond = (frequency * channels * bits) / 8;\ndurationSeconds = size / bytesPerSecond;\n```\n\nfrom http://stackoverflow.com/questions/7978912/how-to-get-length-duration-of-a-source-with-single-buffer-in-openal\n", "tags": ["Objective-C", "OpenAL", "avfoundation", "ALURE"]}