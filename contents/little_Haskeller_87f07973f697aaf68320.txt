{"context": " More than 1 year has passed since last update.\u30a8\u30e9\u30c8\u30b9\u30c6\u30cd\u30b9\u306e\u7be9\u306e\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0\u3092\u4f7f\u3063\u3066\u7d20\u6570\u306e\u30ea\u30b9\u30c8\u3092\u8fd4\u3059\u95a2\u6570\u3092\u4f5c\u3063\u3066\u307f\u307e\u3057\u305f\u3002\nRuby \u3084 Scheme \u306e\u6642\u3068\u540c\u3058\u3088\u3046\u306b\u914d\u5217\u3092\u30d0\u30ea\u30d0\u30ea\u4f7f\u3044\u305f\u304b\u3063\u305f\u306e\u3067\u3001Data.Vector \u3092\u5229\u7528\u3057\u307e\u3057\u305f\u3002\n\u300c\u6c42\u3081\u308b\u7d20\u6570\u306e\u4e0a\u9650\u3092\u6c7a\u3081\u306a\u304f\u3066\u306f\u306a\u3089\u306a\u3044\u300d\u3068\u3044\u3046\u5236\u9650\u306f\u3042\u308a\u307e\u3059\u304c\u3001\u4e00\u5104\u4ee5\u4e0b\u306e\u7d20\u6570\u3092 5 \u79d2\u305f\u3089\u305a\u3067\u6c42\u3081\u3089\u308c\u308b\u306e\u3067\u3001\u9ad8\u901f\u306a\u65b9\u3060\u3068\u601d\u3044\u307e\u3059\u3002\n\u3000\n\nprimeList.hs\nimport qualified Data.Vector.Unboxed         as U\nimport qualified Data.Vector.Unboxed.Mutable as UM\nimport Control.Monad.ST\nimport Control.Monad\n\n--\n-- \u30a8\u30e9\u30c8\u30b9\u30c6\u30cd\u30b9\u306e\u7be9\u306b\u3088\u308b\u7d20\u6570\u30ea\u30b9\u30c8\n--\n-- * ex : primeList 20  =>  [2,3,5,7,11,13,17,19]\n--\nprimeList :: Int -> [Int]\nprimeList n = 2 : (map indexToValue $ U.toList $ U.elemIndices True $ sieve)\n  where\n    indexToValue i = 2 * i + 3\n    valueToIndex v = div (v - 3) 2\n    lastIndex      = valueToIndex n\n\n    sieve = runST $ do\n      mVec <- UM.replicate (lastIndex + 1) True\n      mapM_ (loop mVec) [0 .. valueToIndex (floor $ sqrt $ fromIntegral n)]\n      U.unsafeFreeze mVec\n\n    loop vec i = do\n      v <- UM.unsafeRead vec i\n      when v $ do\n        let (s, d) = (2 * i * (i + 3) + 3, indexToValue i)\n        mapM_ setFalse [s, s + d .. lastIndex]\n          where setFalse i = UM.unsafeWrite vec i False\n\n\n\n\nmain :: IO ()\nmain = print $ last $ primeList 100000000\n\n\n>primeList +RTS -sstderr\nprimeList +RTS -sstderr\n99999989\n   4,902,213,164 bytes allocated in the heap\n         393,184 bytes copied during GC\n      50,026,280 bytes maximum residency (3 sample(s))\n         342,232 bytes maximum slop\n              49 MB total memory in use (0 MB lost due to fragmentation)\n\n                                    Tot time (elapsed)  Avg pause  Max pause\n  Gen  0      9289 colls,     0 par    0.11s    0.07s     0.0000s    0.0021s\n  Gen  1         3 colls,     0 par    0.00s    0.01s     0.0017s    0.0049s\n\n  INIT    time    0.00s  (  0.00s elapsed)\n  MUT     time    4.29s  (  4.86s elapsed)\n  GC      time    0.11s  (  0.08s elapsed)\n  EXIT    time    0.00s  (  0.01s elapsed)\n  Total   time    4.40s  (  4.94s elapsed)\n\n  %GC     time       2.5%  (1.6% elapsed)\n\n  Alloc rate    1,142,699,706 bytes per MUT second\n\n  Productivity  97.5% of total user, 86.8% of total elapsed\n\n\u4ed6\u306e\u95a2\u6570\u3068\u4e00\u7dd2\u306b GitHub \u3067\u516c\u958b\u3057\u3066\u3044\u307e\u3059\u3002\n\u30a8\u30e9\u30c8\u30b9\u30c6\u30cd\u30b9\u306e\u7be9\u306e\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0\u3092\u4f7f\u3063\u3066\u7d20\u6570\u306e\u30ea\u30b9\u30c8\u3092\u8fd4\u3059\u95a2\u6570\u3092\u4f5c\u3063\u3066\u307f\u307e\u3057\u305f\u3002\n\nRuby \u3084 Scheme \u306e\u6642\u3068\u540c\u3058\u3088\u3046\u306b\u914d\u5217\u3092\u30d0\u30ea\u30d0\u30ea\u4f7f\u3044\u305f\u304b\u3063\u305f\u306e\u3067\u3001Data.Vector \u3092\u5229\u7528\u3057\u307e\u3057\u305f\u3002\n\u300c\u6c42\u3081\u308b\u7d20\u6570\u306e\u4e0a\u9650\u3092\u6c7a\u3081\u306a\u304f\u3066\u306f\u306a\u3089\u306a\u3044\u300d\u3068\u3044\u3046\u5236\u9650\u306f\u3042\u308a\u307e\u3059\u304c\u3001\u4e00\u5104\u4ee5\u4e0b\u306e\u7d20\u6570\u3092 5 \u79d2\u305f\u3089\u305a\u3067\u6c42\u3081\u3089\u308c\u308b\u306e\u3067\u3001\u9ad8\u901f\u306a\u65b9\u3060\u3068\u601d\u3044\u307e\u3059\u3002\n\u3000\n\n```primeList.hs\nimport qualified Data.Vector.Unboxed         as U\nimport qualified Data.Vector.Unboxed.Mutable as UM\nimport Control.Monad.ST\nimport Control.Monad\n\n--\n-- \u30a8\u30e9\u30c8\u30b9\u30c6\u30cd\u30b9\u306e\u7be9\u306b\u3088\u308b\u7d20\u6570\u30ea\u30b9\u30c8\n--\n-- * ex : primeList 20  =>  [2,3,5,7,11,13,17,19]\n--\nprimeList :: Int -> [Int]\nprimeList n = 2 : (map indexToValue $ U.toList $ U.elemIndices True $ sieve)\n  where\n    indexToValue i = 2 * i + 3\n    valueToIndex v = div (v - 3) 2\n    lastIndex      = valueToIndex n\n\n    sieve = runST $ do\n      mVec <- UM.replicate (lastIndex + 1) True\n      mapM_ (loop mVec) [0 .. valueToIndex (floor $ sqrt $ fromIntegral n)]\n      U.unsafeFreeze mVec\n\n    loop vec i = do\n      v <- UM.unsafeRead vec i\n      when v $ do\n        let (s, d) = (2 * i * (i + 3) + 3, indexToValue i)\n        mapM_ setFalse [s, s + d .. lastIndex]\n          where setFalse i = UM.unsafeWrite vec i False\n\n\n\n\nmain :: IO ()\nmain = print $ last $ primeList 100000000\n```\n\n```\n>primeList +RTS -sstderr\nprimeList +RTS -sstderr\n99999989\n   4,902,213,164 bytes allocated in the heap\n         393,184 bytes copied during GC\n      50,026,280 bytes maximum residency (3 sample(s))\n         342,232 bytes maximum slop\n              49 MB total memory in use (0 MB lost due to fragmentation)\n\n                                    Tot time (elapsed)  Avg pause  Max pause\n  Gen  0      9289 colls,     0 par    0.11s    0.07s     0.0000s    0.0021s\n  Gen  1         3 colls,     0 par    0.00s    0.01s     0.0017s    0.0049s\n\n  INIT    time    0.00s  (  0.00s elapsed)\n  MUT     time    4.29s  (  4.86s elapsed)\n  GC      time    0.11s  (  0.08s elapsed)\n  EXIT    time    0.00s  (  0.01s elapsed)\n  Total   time    4.40s  (  4.94s elapsed)\n\n  %GC     time       2.5%  (1.6% elapsed)\n\n  Alloc rate    1,142,699,706 bytes per MUT second\n\n  Productivity  97.5% of total user, 86.8% of total elapsed\n```\n\n\u4ed6\u306e\u95a2\u6570\u3068\u4e00\u7dd2\u306b [GitHub](https://github.com/little-schemer/MyModule) \u3067\u516c\u958b\u3057\u3066\u3044\u307e\u3059\u3002\n", "tags": ["Haskell", "\u7d20\u6570", "\u6570\u5b66"]}