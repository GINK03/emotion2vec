{"context": " More than 1 year has passed since last update.\u305b\u3063\u304b\u304f\u306e\u30de\u30eb\u30c1\u30b3\u30a2\u30de\u30b7\u30f3\u306a\u306e\u3067Intel Threading Building Blocks(TBB)\u3067\u30de\u30eb\u30c1\u30b9\u30ec\u30c3\u30c9\u4e26\u5217\u51e6\u7406\u3002\n\u753b\u50cf\u30ad\u30e3\u30d7\u30c1\u30e3[\u9010\u6b21] \u2192 \u9854\u691c\u51fa\uff0b\u30e2\u30b6\u30a4\u30af\u51e6\u7406[\u30d5\u30ec\u30fc\u30e0\u4e26\u5217] \u2192 \u30a6\u30a4\u30f3\u30c9\u30a6\u8868\u793a[\u9010\u6b21] \u306e\u30d1\u30a4\u30d7\u30e9\u30a4\u30f3\u3092\u69cb\u7bc9\u3002\nhttp://qiita.com/yohhoy/items/505815587d1fbb57cc8b \u00d7 http://d.hatena.ne.jp/yohhoy/20140514/p1\n\nfacemozp.cpp\n#include <vector>\n#include <string>\n#include <iostream>\n#include <opencv2/opencv.hpp>\n#include <tbb/tbb.h>\n\n\nstruct workset {\n    cv::CascadeClassifier classifier;\n};\nstd::vector<workset> ws;\n\nconst char * const file = \"./haarcascade.xml\";\ncv::Size min_face;\n\n//! initialize\nvoid init(int w, int h, size_t nthread)\n{\n    std::cout << \"frame=\" << w << 'x' << h << \" nthread=\" << nthread << std::endl;\n\n    ws.resize(nthread);\n    for (auto& w : ws) {\n        if (!w.classifier.load(file)) {\n            std::cout << \"fail to load: \" << file << std::endl;\n            std::exit(1);\n        }\n    }\n    const double scale = 0.10;\n    min_face = cv::Size(w * scale, h * scale);\n    std::cout << \"min_face=\" << min_face << std::endl;\n}\n\n//! process image frame\ncv::Mat process(cv::Mat& frame, workset& w)\n{\n    std::vector<cv::Rect> faces;\n    w.classifier.detectMultiScale(frame, faces, 1.1, 3, 0, min_face);\n    for (const auto& r : faces) {\n        // mosaic filter\n        const double f = 0.05;\n        cv::Mat tmp;\n        cv::resize(frame(r), tmp, {}, f, f);\n        cv::resize(tmp, frame(r), r.size(), 0, 0, cv::INTER_NEAREST);\n        // draw area border\n        cv::rectangle(frame, r.tl(), r.br(), {0,0,0});\n    }\n    return frame;\n}\n\nint main()\n{\n    const char * const window = \"Capture (Press ESC to exit)\";\n    const double scale = 0.75;\n    const int delay = 32;   // [msec]\n    const size_t nthread = tbb::task_scheduler_init::default_num_threads();\n\n    cv::VideoCapture cap(0);\n    if (!cap.isOpened()) {\n        std::cerr << \"fail to open cv::VideoCapture\" << std::endl;\n        return 2; \n    }\n\n    const double width = cap.get(cv::CAP_PROP_FRAME_WIDTH) * scale;\n    const double height = cap.get(cv::CAP_PROP_FRAME_HEIGHT) * scale;\n    cap.set(cv::CAP_PROP_FRAME_WIDTH, width);\n    cap.set(cv::CAP_PROP_FRAME_HEIGHT, height);\n    init(width, height, nthread);\n\n    cv::namedWindow(window);\n    std::vector<cv::Mat> frames(nthread);\n    size_t next_token = 0;\n    auto filter_chain =\n        tbb::make_filter<void, size_t>(\n            tbb::filter::serial_in_order,\n            [&](tbb::flow_control& fc) -> size_t {\n                if (cv::waitKey(delay) == '\\x1b') {\n                    fc.stop();\n                    return -1;\n                }\n                size_t token = (next_token++ % ws.size());\n                cap >> frames[token];\n                return token;\n            }) &\n        tbb::make_filter<size_t, size_t>(\n            tbb::filter::parallel,\n            [&](size_t token) -> size_t {\n                process(frames[token], ws[token]);\n                return token;\n            }) &\n        tbb::make_filter<size_t, void>(\n            tbb::filter::serial_in_order,\n            [&](size_t token) -> void {\n                cv::imshow(window, frames[token]);\n            });\n    tbb::task_scheduler_init sched(nthread);\n    tbb::parallel_pipeline(nthread, filter_chain);\n\n    return 0;\n}\n\n\n$ brew install science/opencv3\n...\n$ brew install tbb\n...\n$ clang++ -std=c++14 -W -Wall -O2 -o facemozp facemozp.cpp -I/usr/local/opt/opencv3/include -I/usr/local/opt/tbb/include -L/usr/local/opt/opencv3/lib -L/usr/local/opt/tbb/include -lopencv_core -lopencv_highgui -lopencv_videoio -lopencv_objdetect -lopencv_imgproc -ltbb\n$ cp /usr/local/opt/opencv3/share/OpenCV/haarcascades/haarcascade_frontalface_default.xml haarsascade.xml\n$ ./facemozp\n\n\u305b\u3063\u304b\u304f\u306e\u30de\u30eb\u30c1\u30b3\u30a2\u30de\u30b7\u30f3\u306a\u306e\u3067Intel [Threading Building Blocks(TBB)](https://www.threadingbuildingblocks.org/)\u3067\u30de\u30eb\u30c1\u30b9\u30ec\u30c3\u30c9\u4e26\u5217\u51e6\u7406\u3002\n\n\u753b\u50cf\u30ad\u30e3\u30d7\u30c1\u30e3[\u9010\u6b21] \u2192 \u9854\u691c\u51fa\uff0b\u30e2\u30b6\u30a4\u30af\u51e6\u7406[\u30d5\u30ec\u30fc\u30e0\u4e26\u5217] \u2192 \u30a6\u30a4\u30f3\u30c9\u30a6\u8868\u793a[\u9010\u6b21] \u306e\u30d1\u30a4\u30d7\u30e9\u30a4\u30f3\u3092\u69cb\u7bc9\u3002\n\nhttp://qiita.com/yohhoy/items/505815587d1fbb57cc8b \u00d7 http://d.hatena.ne.jp/yohhoy/20140514/p1\n\n```facemozp.cpp\n#include <vector>\n#include <string>\n#include <iostream>\n#include <opencv2/opencv.hpp>\n#include <tbb/tbb.h>\n\n\nstruct workset {\n    cv::CascadeClassifier classifier;\n};\nstd::vector<workset> ws;\n\nconst char * const file = \"./haarcascade.xml\";\ncv::Size min_face;\n\n//! initialize\nvoid init(int w, int h, size_t nthread)\n{\n    std::cout << \"frame=\" << w << 'x' << h << \" nthread=\" << nthread << std::endl;\n\n    ws.resize(nthread);\n    for (auto& w : ws) {\n        if (!w.classifier.load(file)) {\n            std::cout << \"fail to load: \" << file << std::endl;\n            std::exit(1);\n        }\n    }\n    const double scale = 0.10;\n    min_face = cv::Size(w * scale, h * scale);\n    std::cout << \"min_face=\" << min_face << std::endl;\n}\n\n//! process image frame\ncv::Mat process(cv::Mat& frame, workset& w)\n{\n    std::vector<cv::Rect> faces;\n    w.classifier.detectMultiScale(frame, faces, 1.1, 3, 0, min_face);\n    for (const auto& r : faces) {\n        // mosaic filter\n        const double f = 0.05;\n        cv::Mat tmp;\n        cv::resize(frame(r), tmp, {}, f, f);\n        cv::resize(tmp, frame(r), r.size(), 0, 0, cv::INTER_NEAREST);\n        // draw area border\n        cv::rectangle(frame, r.tl(), r.br(), {0,0,0});\n    }\n    return frame;\n}\n\nint main()\n{\n    const char * const window = \"Capture (Press ESC to exit)\";\n    const double scale = 0.75;\n    const int delay = 32;   // [msec]\n    const size_t nthread = tbb::task_scheduler_init::default_num_threads();\n\n    cv::VideoCapture cap(0);\n    if (!cap.isOpened()) {\n        std::cerr << \"fail to open cv::VideoCapture\" << std::endl;\n        return 2; \n    }\n\n    const double width = cap.get(cv::CAP_PROP_FRAME_WIDTH) * scale;\n    const double height = cap.get(cv::CAP_PROP_FRAME_HEIGHT) * scale;\n    cap.set(cv::CAP_PROP_FRAME_WIDTH, width);\n    cap.set(cv::CAP_PROP_FRAME_HEIGHT, height);\n    init(width, height, nthread);\n\n    cv::namedWindow(window);\n    std::vector<cv::Mat> frames(nthread);\n    size_t next_token = 0;\n    auto filter_chain =\n        tbb::make_filter<void, size_t>(\n            tbb::filter::serial_in_order,\n            [&](tbb::flow_control& fc) -> size_t {\n                if (cv::waitKey(delay) == '\\x1b') {\n                    fc.stop();\n                    return -1;\n                }\n                size_t token = (next_token++ % ws.size());\n                cap >> frames[token];\n                return token;\n            }) &\n        tbb::make_filter<size_t, size_t>(\n            tbb::filter::parallel,\n            [&](size_t token) -> size_t {\n                process(frames[token], ws[token]);\n                return token;\n            }) &\n        tbb::make_filter<size_t, void>(\n            tbb::filter::serial_in_order,\n            [&](size_t token) -> void {\n                cv::imshow(window, frames[token]);\n            });\n    tbb::task_scheduler_init sched(nthread);\n    tbb::parallel_pipeline(nthread, filter_chain);\n\n    return 0;\n}\n```\n\n```\n$ brew install science/opencv3\n...\n$ brew install tbb\n...\n$ clang++ -std=c++14 -W -Wall -O2 -o facemozp facemozp.cpp -I/usr/local/opt/opencv3/include -I/usr/local/opt/tbb/include -L/usr/local/opt/opencv3/lib -L/usr/local/opt/tbb/include -lopencv_core -lopencv_highgui -lopencv_videoio -lopencv_objdetect -lopencv_imgproc -ltbb\n$ cp /usr/local/opt/opencv3/share/OpenCV/haarcascades/haarcascade_frontalface_default.xml haarsascade.xml\n$ ./facemozp\n```\n", "tags": ["OpenCV3.0.0", "C++", "Mac", "homebrew", "TBB"]}