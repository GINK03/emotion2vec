{"context": " More than 1 year has passed since last update.\u524d\u56de\u306b\u5f15\u304d\u7d9a\u304d\u30018\u30d1\u30ba\u30eb\u3092\u984c\u6750\u306b\u3057\u3066\u3001\u57fa\u672c\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0\u306e\u6df1\u3055\u512a\u5148\u63a2\u7d22\u3092\u3001\u4e0b\u9650\u5024\u679d\u5208\u308a\u6cd5\u3092\u4f7f\u3063\u3066\u5b9f\u88c5\n\n\u624b\u9806\n\n\u958b\u59cb\u30d1\u30ba\u30eb\u3092\u751f\u6210\n\u958b\u59cb\u30d1\u30ba\u30eb\u3092\u30b9\u30bf\u30c3\u30af\u306b\u683c\u7d0d\n\u30b9\u30bf\u30c3\u30af\u306e\u5148\u982d\u304b\u3089\u30d1\u30ba\u30eb\u3092\u53d6\u5f97\n\u30d1\u30ba\u30eb\u306e\u30d1\u30cd\u30eb\u914d\u7f6e\u304c\u30b4\u30fc\u30eb\u306a\u3089\u7d42\u4e86\n\u30b4\u30fc\u30eb\u4ee5\u5916\u306a\u3089\u3001\u30d1\u30ba\u30eb\u3092\u4e0a\u4e0b\u5de6\u53f3\u306b\u79fb\u52d5\u3055\u305b\u305f\u3068\u304d\u306e\u30d1\u30ba\u30eb\u3092\u65b0\u898f\u4f5c\u6210\n\u305d\u306e\u30d1\u30ba\u30eb\u306e\u30d1\u30cd\u30eb\u914d\u7f6e\u306e\u300c\u30de\u30f3\u30cf\u30c3\u30bf\u30f3\u8ddd\u96e2 + \u5c65\u6b74\u624b\u6570\u300d\u304c\u4e0b\u9650\u502431\u4ee5\u5185\u3067\u3042\u308b\u304b\u78ba\u8a8d\n\u4e0b\u9650\u5024\u4ee5\u4e0a\u3067\u3042\u308c\u3070\u6b21\u306e\u65b9\u89d2\u30675\u304b\u3089\u7e70\u308a\u8fd4\u3059\n\u305d\u306e\u30d1\u30ba\u30eb\u306e\u30d1\u30cd\u30eb\u914d\u7f6e\u304c\u51fa\u73fe\u6e08\u307f\u304b\u3069\u3046\u304b\u3068\u5c65\u6b74\u624b\u6570\u3092\u78ba\u8a8d\n\u51fa\u73fe\u6e08\u307f\u304b\u3064\u3001\u305d\u306e\u30d1\u30ba\u30eb\u306e\u5c65\u6b74\u624b\u6570\u306e\u65b9\u304c\u5927\u304d\u3051\u308c\u3070\u3001\u5225\u306e\u65b9\u89d2\u306e\u30d1\u30ba\u30eb\u30675\u304b\u3089\u7e70\u308a\u8fd4\u3059\n\u30b9\u30bf\u30c3\u30af\u306b\u30d1\u30ba\u30eb\u3092\u683c\u7d0d\u3057\u3001\u5c65\u6b74\u30ea\u30b9\u30c8\u306b\u5c65\u6b74\u3092\u683c\u7d0d\n5 \u304b\u3089 10 \u307e\u3067\u3092\u3001\u5404\u65b9\u89d2\u306e\u30d1\u30ba\u30eb\u306b\u5bfe\u3057\u3066\u7e70\u308a\u8fd4\u3059\n3 \u304b\u3089 11 \u307e\u3067\u3092\u3001\u30b9\u30bf\u30c3\u30af\u304c\u7a7a\u306b\u306a\u308b\u307e\u3067\u7d9a\u3051\u308b\n\n\n\u30dd\u30a4\u30f3\u30c8\n\n\u30b9\u30bf\u30c3\u30af\u3092\u4f7f\u7528\u3059\u308b\n\u30de\u30f3\u30cf\u30c3\u30bf\u30f3\u8ddd\u96e2\u306e\u679d\u5208\u308a\u3067\u9ad8\u901f\u5316\n\nclass Stack:\n\n    def __init__(self, puzzle):\n        self.puzzle_list = []\n\n        self.puzzle_list.append(puzzle)\n\n    def push(self, puzzle):\n        self.puzzle_list.insert(0, puzzle)\n\n    def pop(self):\n        return self.puzzle_list.pop(0)\n\n    def is_empty(self):\n        return len(self.puzzle_list) == 0\n\nclass Puzzle():\n\n    def __init__(self, panel_list, state_list, size):\n        self.panel_list = panel_list\n        self.state_list = state_list\n        self.state_list.append(panel_list)\n        self.size = size\n        self.distance = 0\n\n        def manhattan():\n            for d, panel in enumerate(self.panel_list):\n\n                if panel > 0:\n                    self.distance += abs((panel - 1) // 3 - d // 3 + (panel - 1) % 3 - d % 3)\n\n        manhattan()\n\n    def gene_next_panel(self):\n        zero_pos = self.panel_list.index(0)\n\n        col = zero_pos // self.size\n        raw = zero_pos % self.size\n\n        def get_next_panel():\n            panel_list = self.panel_list[:]\n            n = panel_list[next_pos]\n            panel_list[next_pos] = 0\n            panel_list[zero_pos] = n\n            # \u79fb\u52d5\u8ddd\u96e2\u306e\u5dee\u5206\u3092\u8a08\u7b97\n            self.distance += zero_pos // 3 - next_pos // 3 + zero_pos % 3 - next_pos % 3\n            return panel_list\n\n        if self.size > col + 1:\n            next_pos = (col + 1) * self.size + raw\n            panel_list = get_next_panel()\n            yield tuple(panel_list)\n\n        if col - 1 >= 0:\n            next_pos = (col - 1) * self.size + raw\n            panel_list = get_next_panel()\n            yield tuple(panel_list)\n\n        if self.size > raw + 1:\n            next_pos = col * self.size + raw + 1\n            panel_list = get_next_panel()\n            yield tuple(panel_list)\n\n        if raw - 1 >= 0:\n            next_pos = col * self.size + raw - 1\n            panel_list = get_next_panel()\n            yield tuple(panel_list)\n\n    def result_print(self):\n\n        for s in self.state_list:\n            print(s)\n\n\ndef depth_first(panel_list, goal, size):\n    puzzle = Puzzle(panel_list, [], size)\n    stack = Stack(puzzle)\n    checked_dict = {}\n    cnt = 0\n\n    while stack.is_empty() is False:\n        next_puzzle = stack.pop()\n\n        if next_panel.panel_list == goal:\n            return next_puzzle\n\n        for new_panel in next_puzzle.gene_next_panel():\n            new_puzzle = Puzzle(list(new_panel), next_puzzle.state_list[:], size)\n\n            # \u4e0b\u9650\u679d\u5208\u308a\u6cd5\u306b\u30de\u30f3\u30cf\u30c3\u30bf\u30f3\u8ddd\u96e2\u3092\u4f7f\u7528\n            # \u73fe\u5728\u306e\u30d1\u30cd\u30eb\u914d\u7f6e\u3068\u5c65\u6b74\u624b\u6570\u306e\u5408\u8a08\u304c\u6700\u9577\u624b\u657031\u4ee5\u5185\u304b\u30c1\u30a7\u30c3\u30af\n            # -2 \u306f\u30b9\u30bf\u30fc\u30c8\u3068\u30b4\u30fc\u30eb\u306e\u30d1\u30cd\u30eb\u914d\u7f6e\u304c state_list \u306b\u542b\u307e\u308c\u3066\u3044\u308b\u305f\u3081\u6e1b\u7b97\n            if new_puzzle.distance + len(new_puzzle.state_list) - 2 >= 31:\n                continue\n\n            # \u904e\u53bb\u306b\u51fa\u73fe\u3057\u305f\u30d1\u30cd\u30eb\u914d\u7f6e\u306e\u5834\u5408\u3001\u305d\u306e\u914d\u7f6e\u3092\u4fdd\u6301\u3059\u308b\u30d1\u30ba\u30eb\u3068\u30c1\u30a7\u30c3\u30af\u4e2d\u306e\u30d1\u30ba\u30eb\u306e\u624b\u6570\u3092\u6bd4\u8f03\n            if new_panel in checked_dict and len(new_puzzle.state_list) > checked_dict[new_panel]:\n                continue\n\n            checked_dict[new_panel] = len(new_puzzle.state_list)\n            stack.push(new_puzzle)\n\n    return False\n\n\nif __name__ == '__main__':\n    panel_list = [5, 4, 2, 6, 7, 0, 8, 1, 3]\n    goal = [1, 2, 3, 4, 5, 6, 7, 8, 0]\n    size = 3\n\n    puzzle = depth_first(panel_list, goal, size)\n\n    if puzzle is not False:\n        puzzle.result_print()\n\n\n\u53c2\u8003\nAlgorithms with Python\u5e45\u512a\u5148\u63a2\u7d22\u3068\u53cd\u5fa9\u6df1\u5316\n[\u524d\u56de](http://qiita.com/masashi0127/items/63d4f5b52895af939fca)\u306b\u5f15\u304d\u7d9a\u304d\u30018\u30d1\u30ba\u30eb\u3092\u984c\u6750\u306b\u3057\u3066\u3001\u57fa\u672c\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0\u306e\u6df1\u3055\u512a\u5148\u63a2\u7d22\u3092\u3001\u4e0b\u9650\u5024\u679d\u5208\u308a\u6cd5\u3092\u4f7f\u3063\u3066\u5b9f\u88c5\n\n# \u624b\u9806\n1. \u958b\u59cb\u30d1\u30ba\u30eb\u3092\u751f\u6210\n2. \u958b\u59cb\u30d1\u30ba\u30eb\u3092\u30b9\u30bf\u30c3\u30af\u306b\u683c\u7d0d\n3. \u30b9\u30bf\u30c3\u30af\u306e\u5148\u982d\u304b\u3089\u30d1\u30ba\u30eb\u3092\u53d6\u5f97\n4. \u30d1\u30ba\u30eb\u306e\u30d1\u30cd\u30eb\u914d\u7f6e\u304c\u30b4\u30fc\u30eb\u306a\u3089\u7d42\u4e86\n5. \u30b4\u30fc\u30eb\u4ee5\u5916\u306a\u3089\u3001\u30d1\u30ba\u30eb\u3092\u4e0a\u4e0b\u5de6\u53f3\u306b\u79fb\u52d5\u3055\u305b\u305f\u3068\u304d\u306e\u30d1\u30ba\u30eb\u3092\u65b0\u898f\u4f5c\u6210\n6. \u305d\u306e\u30d1\u30ba\u30eb\u306e\u30d1\u30cd\u30eb\u914d\u7f6e\u306e\u300c\u30de\u30f3\u30cf\u30c3\u30bf\u30f3\u8ddd\u96e2 + \u5c65\u6b74\u624b\u6570\u300d\u304c\u4e0b\u9650\u502431\u4ee5\u5185\u3067\u3042\u308b\u304b\u78ba\u8a8d\n7. \u4e0b\u9650\u5024\u4ee5\u4e0a\u3067\u3042\u308c\u3070\u6b21\u306e\u65b9\u89d2\u30675\u304b\u3089\u7e70\u308a\u8fd4\u3059\n8. \u305d\u306e\u30d1\u30ba\u30eb\u306e\u30d1\u30cd\u30eb\u914d\u7f6e\u304c\u51fa\u73fe\u6e08\u307f\u304b\u3069\u3046\u304b\u3068\u5c65\u6b74\u624b\u6570\u3092\u78ba\u8a8d\n9. \u51fa\u73fe\u6e08\u307f\u304b\u3064\u3001\u305d\u306e\u30d1\u30ba\u30eb\u306e\u5c65\u6b74\u624b\u6570\u306e\u65b9\u304c\u5927\u304d\u3051\u308c\u3070\u3001\u5225\u306e\u65b9\u89d2\u306e\u30d1\u30ba\u30eb\u30675\u304b\u3089\u7e70\u308a\u8fd4\u3059\n10. \u30b9\u30bf\u30c3\u30af\u306b\u30d1\u30ba\u30eb\u3092\u683c\u7d0d\u3057\u3001\u5c65\u6b74\u30ea\u30b9\u30c8\u306b\u5c65\u6b74\u3092\u683c\u7d0d\n11. 5 \u304b\u3089 10 \u307e\u3067\u3092\u3001\u5404\u65b9\u89d2\u306e\u30d1\u30ba\u30eb\u306b\u5bfe\u3057\u3066\u7e70\u308a\u8fd4\u3059\n12. 3 \u304b\u3089 11 \u307e\u3067\u3092\u3001\u30b9\u30bf\u30c3\u30af\u304c\u7a7a\u306b\u306a\u308b\u307e\u3067\u7d9a\u3051\u308b\n\n# \u30dd\u30a4\u30f3\u30c8\n- \u30b9\u30bf\u30c3\u30af\u3092\u4f7f\u7528\u3059\u308b\n- \u30de\u30f3\u30cf\u30c3\u30bf\u30f3\u8ddd\u96e2\u306e\u679d\u5208\u308a\u3067\u9ad8\u901f\u5316\n\n```py\nclass Stack:\n\n    def __init__(self, puzzle):\n        self.puzzle_list = []\n\n        self.puzzle_list.append(puzzle)\n\n    def push(self, puzzle):\n        self.puzzle_list.insert(0, puzzle)\n\n    def pop(self):\n        return self.puzzle_list.pop(0)\n\n    def is_empty(self):\n        return len(self.puzzle_list) == 0\n\nclass Puzzle():\n\n    def __init__(self, panel_list, state_list, size):\n        self.panel_list = panel_list\n        self.state_list = state_list\n        self.state_list.append(panel_list)\n        self.size = size\n        self.distance = 0\n\n        def manhattan():\n            for d, panel in enumerate(self.panel_list):\n\n                if panel > 0:\n                    self.distance += abs((panel - 1) // 3 - d // 3 + (panel - 1) % 3 - d % 3)\n\n        manhattan()\n\n    def gene_next_panel(self):\n        zero_pos = self.panel_list.index(0)\n\n        col = zero_pos // self.size\n        raw = zero_pos % self.size\n\n        def get_next_panel():\n            panel_list = self.panel_list[:]\n            n = panel_list[next_pos]\n            panel_list[next_pos] = 0\n            panel_list[zero_pos] = n\n            # \u79fb\u52d5\u8ddd\u96e2\u306e\u5dee\u5206\u3092\u8a08\u7b97\n            self.distance += zero_pos // 3 - next_pos // 3 + zero_pos % 3 - next_pos % 3\n            return panel_list\n\n        if self.size > col + 1:\n            next_pos = (col + 1) * self.size + raw\n            panel_list = get_next_panel()\n            yield tuple(panel_list)\n\n        if col - 1 >= 0:\n            next_pos = (col - 1) * self.size + raw\n            panel_list = get_next_panel()\n            yield tuple(panel_list)\n\n        if self.size > raw + 1:\n            next_pos = col * self.size + raw + 1\n            panel_list = get_next_panel()\n            yield tuple(panel_list)\n\n        if raw - 1 >= 0:\n            next_pos = col * self.size + raw - 1\n            panel_list = get_next_panel()\n            yield tuple(panel_list)\n\n    def result_print(self):\n\n        for s in self.state_list:\n            print(s)\n\n\ndef depth_first(panel_list, goal, size):\n    puzzle = Puzzle(panel_list, [], size)\n    stack = Stack(puzzle)\n    checked_dict = {}\n    cnt = 0\n\n    while stack.is_empty() is False:\n        next_puzzle = stack.pop()\n\n        if next_panel.panel_list == goal:\n            return next_puzzle\n\n        for new_panel in next_puzzle.gene_next_panel():\n            new_puzzle = Puzzle(list(new_panel), next_puzzle.state_list[:], size)\n\n            # \u4e0b\u9650\u679d\u5208\u308a\u6cd5\u306b\u30de\u30f3\u30cf\u30c3\u30bf\u30f3\u8ddd\u96e2\u3092\u4f7f\u7528\n            # \u73fe\u5728\u306e\u30d1\u30cd\u30eb\u914d\u7f6e\u3068\u5c65\u6b74\u624b\u6570\u306e\u5408\u8a08\u304c\u6700\u9577\u624b\u657031\u4ee5\u5185\u304b\u30c1\u30a7\u30c3\u30af\n            # -2 \u306f\u30b9\u30bf\u30fc\u30c8\u3068\u30b4\u30fc\u30eb\u306e\u30d1\u30cd\u30eb\u914d\u7f6e\u304c state_list \u306b\u542b\u307e\u308c\u3066\u3044\u308b\u305f\u3081\u6e1b\u7b97\n            if new_puzzle.distance + len(new_puzzle.state_list) - 2 >= 31:\n                continue\n\n            # \u904e\u53bb\u306b\u51fa\u73fe\u3057\u305f\u30d1\u30cd\u30eb\u914d\u7f6e\u306e\u5834\u5408\u3001\u305d\u306e\u914d\u7f6e\u3092\u4fdd\u6301\u3059\u308b\u30d1\u30ba\u30eb\u3068\u30c1\u30a7\u30c3\u30af\u4e2d\u306e\u30d1\u30ba\u30eb\u306e\u624b\u6570\u3092\u6bd4\u8f03\n            if new_panel in checked_dict and len(new_puzzle.state_list) > checked_dict[new_panel]:\n                continue\n\n            checked_dict[new_panel] = len(new_puzzle.state_list)\n            stack.push(new_puzzle)\n\n    return False\n\n\nif __name__ == '__main__':\n    panel_list = [5, 4, 2, 6, 7, 0, 8, 1, 3]\n    goal = [1, 2, 3, 4, 5, 6, 7, 8, 0]\n    size = 3\n\n    puzzle = depth_first(panel_list, goal, size)\n\n    if puzzle is not False:\n        puzzle.result_print()\n```\n\n# \u53c2\u8003\n[Algorithms with Python\u5e45\u512a\u5148\u63a2\u7d22\u3068\u53cd\u5fa9\u6df1\u5316](http://www.geocities.jp/m_hiroi/light/pyalgo27.html)\n", "tags": ["Python", "\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0"]}