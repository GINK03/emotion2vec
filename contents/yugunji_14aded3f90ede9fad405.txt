{"context": " More than 1 year has passed since last update.\n\n\u8981\u4ef6\n\nelasticsearch\u3067\u306e\u691c\u7d22\u7d50\u679c\u3092jquery\u306edatatables\u3067\u51fa\u529b\u3057\u305f\u3044\n\n\n\u74b0\u5883\n\nGo 1.3 (with revel as Web Application Framework)\nelasticsearch 1.3.x (with Kuromoji)\njquery 1.10.x\ndatatables 1.10.x\n\n\n\u80cc\u666f\n\u3082\u3068\u3082\u3068mongo\u3092\u3046\u3089\u306eDB\u3068\u3057\u3066\u5229\u7528\u3057\u3066\u3044\u307e\u3057\u305f\u304c\u3001\u65e5\u672c\u8a9e\u3067\u306e\u5168\u6587\u691c\u7d22\u306e\u7cbe\u5ea6\u304c\u3069\u3046\u3057\u3066\u3082\u60aa\u3044\u306e\u3068\u3001\u6570\u5341\u4e07\u4ef6\u898f\u6a21\u306e\u30ec\u30b3\u30fc\u30c9\u306e\u691c\u7d22\u306b3\u79d2\u307b\u3069\u6642\u9593\u304c\u304b\u304b\u3063\u3066\u3057\u307e\u3063\u305f\u306e\u3067elasticsearch\u3092\u8a66\u3057\u3066\u307f\u308b\u3053\u3068\u306b\u3057\u307e\u3057\u305f\u3002\n\n\u304a\u65ad\u308a\nsnippet\u306f\u5fc5\u8981\u306a\u90e8\u5206\u306e\u307f\u62bd\u51fa\u3057\u3066\u307e\u3059\u3002\nstruct\u3067\u5ba3\u8a00\u3057\u3066\u304a\u304d\u306a\u304c\u3089\u3064\u304b\u3063\u3066\u306a\u3044\u306e\u3082\u3042\u308b\u304b\u3082\u3002\u3002\u3002\n\nsnipet\n\nlib.go\ntype ReturnDataTable struct {\n    Draw               int                      `json:\"draw\"`\n    RecordsTotal       int                      `json:\"recordsTotal\"`\n    RecordsFiltered    interface{}              `json:\"recordsFiltered\"`\n    Data               []map[string]interface{} `json:\"data\"`\n    SearchString       string\n    Length             int\n    OrderColumn        string\n    OrderDir           int\n    SearchFields       []string\n    Start              int\n    AndColumns         []bson.M\n    ObjectIdFields     []string\n    DefaultOrderColumn string\n}\n\ntype ESClause struct {\n    From      int\n    Size      int\n    Query     string\n    SortField string\n    SortOrder string\n    Draw      int\n}\n\ntype ESFilter struct {\n    Term map[string]interface{} `json:\"term\"`\n}\n\ntype ESFilterNot struct {\n    Term map[string]interface{} `json:\"term\"`\n}\n\ntype ESFilterShould struct {\n    Term map[string]interface{} `json:\"term\"`\n}\n\ntype ESFilterMustNot struct {\n    Term map[string]interface{} `json:\"term\"`\n}\n\nfunc ESGet(clause *ESClause, should *[]ESFilterShould, must_not *[]ESFilterMustNot) (*ReturnDataTable, error) {\n    var err error\n    var ret *ReturnDataTable\n\n    url_base, _ := revel.Config.String(\"es_url\")\n\n    type FilterBool struct {\n        Should  *[]ESFilterShould  `json:\"should\"`\n        MustNot *[]ESFilterMustNot `json:\"must_not\"`\n    }\n\n    type FilterNotBox struct {\n        Terms *[]ESFilterNot `json:\"and\"`\n    }\n\n    type FilterBox struct {\n        FilterBool `json:\"bool\"`\n    }\n\n    type QueryString struct {\n        Query string `json:\"query\"`\n        //Analyzer string `json:\"analyzer\"`\n    }\n\n    type Query struct {\n        QueryString `json:\"query_string\"`\n    }\n\n    type Size struct {\n        Size int `json:\"size\"`\n    }\n\n    type From struct {\n        From int `json:\"from\"`\n    }\n\n    type Analyzer struct {\n        Analyzer string `json:\"analyzer\"`\n    }\n\n    type JsonBucket struct {\n        //QueryString `json:\",inline\"`\n        From      `json:\",inline\"`\n        Size      `json:\",inline\"`\n        Query     `json:\"query\"`\n        FilterBox `json:\"filter\"`\n    }\n\n    //qstr := QueryString{clause.Query, \"\"}\n    qstr := QueryString{clause.Query}\n    qs := Query{qstr}\n\n    filbool := FilterBool{should, must_not}\n    filbox := FilterBox{filbool}\n\n    bucket := JsonBucket{\n        From{clause.From},\n        Size{clause.Size},\n        qs,\n        filbox,\n    }\n\n    //revel.ERROR.Println(filbox)\n\n    jbucket, _ := json.Marshal(bucket)\n\n    if err != nil {\n        revel.ERROR.Println(err)\n    }\n\n    url := url_base\n\n    client := &http.Client{}\n    req, _ := http.NewRequest(\n        \"POST\",\n        url,\n        bytes.NewReader(jbucket),\n    )\n\n    req.Header.Set(\"Content-Type\", \"application/json; charset=UTF-8\")\n\n    resp, _ := client.Do(req)\n    body, _ := ioutil.ReadAll(resp.Body)\n    defer resp.Body.Close()\n\n    var f interface{}\n    json.Unmarshal(body, &f)\n    m := f.(map[string]interface{})\n\n    n, ok := m[\"hits\"].(map[string]interface{})\n\n    if !ok {\n\n        ret = &ReturnDataTable{}\n\n        ret.Draw = clause.Draw\n        ret.Data = make([]map[string]interface{}, 0)\n        ret.RecordsFiltered = 0\n        ret.Start = clause.From\n\n        return ret, err\n\n    }\n\n    var fs []interface{}\n\n    fs = n[\"hits\"].([]interface{})\n\n    var sources []map[string]interface{}\n\n    for _, v := range fs {\n        d := v.(map[string]interface{})\n        sources = append(sources, d[\"_source\"].(map[string]interface{}))\n    }\n\n    ifound := len(sources)\n\n    var retVals []map[string]interface{}\n\n    for _, v := range sources {\n\n        var retVal map[string]interface{}\n\n        var id string\n\n        retVal = make(map[string]interface{})\n\n        for k, nv := range v {\n            retVal[k] = nv\n            if k == \"_id\" {\n                id = nv.(string)\n            }\n        }\n        retVal[\"Id\"] = id\n        retVal[\"DT_RowId\"] = id\n        retVal[\"DT_RowClass\"] = \"Rest_\" + id\n        retVal[\"DT_RowData\"] = map[string]string{\"id\": id}\n        retVals = append(retVals, retVal)\n    }\n\n    if ifound == 0 {\n        retVals = make([]map[string]interface{}, 0)\n    }\n\n    ret = &ReturnDataTable{}\n\n    ret.Draw = clause.Draw\n    ret.Data = retVals\n    ret.RecordsFiltered = n[\"total\"]\n    ret.Start = clause.From\n\n    return ret, err\n\n}\n\n\n\ncontrollers/app.go\nfunc (c Restaurant) GetDataTable() revel.Result {\n    var clause *lib.ESClause\n    var should []lib.ESFilterShould = []library.ESFilterShould{}\n    var must_not []lib.ESFilterMustNot = []library.ESFilterMustNot{}\n\n    // set query clauses here\n    iLen, _ := strconv.Atoi(c.Params.Get(\"length\"))\n    sVal := c.Params.Get(\"search[value]\")\n    /* your custom conditions\n    bSomeFlag := c.Params.Get(\"someflag\")\n    _should := lib.ESFilterShould{map[string]interface{}{\"whateverflag\": true}}\n    //_must_not := lib.ESFilterMustNot{map[string]interface{}{\"someeverflag\": false}}\n\n    */\n\n    if sVal == \"\" {\n        sVal = \"*\"\n    }\n\n    // append conditions to \"should\" and/or \"must_not\" if needed\n\n    var iDraw int = 0\n    c.Params.Bind(&iDraw, \"draw\")\n\n    var iFrom int = 0\n    c.Params.Bind(&iFrom, \"start\")\n\n    clause = &lib.ESClause{\n        Query: sVal,\n        Size:  iLen,\n        From:  iFrom,\n        Draw:  iDraw,\n    }\n\n    ret, err := lib.ESGet(clause, &should, &must_not)\n\n    if err != nil {\n        revel.INFO.Println(err)\n    }\n\n    return c.RenderJson(ret)\n}\n\n\n\napp.js\n  var dt = $(\"#table\").dataTable({\n    \"dom\": '<\"row-fluid\"<\"span2\"l><\"span10\"f<\"bushi-dt-btn2\">>>tip',\n    \"bLengthChange\": true,\n    \"iDisplayLength\": 25,\n    \"sPaginationType\": \"bootstrap\", \n    \"showPagenation\": true,\n    \"showFilter\": true,\n    \"info\": true,\n    \"bDestroy\": true,\n    \"processing\": true,\n    \"serverSide\": true,\n    \"ajax\": {\n      url: \"/app/get_dt\", // the uri for controller/app\n      data: { \"whateverflag\": \"true\" }, // default param you want to send\n      complete: function(d) {\n        $(\"#loading\").hide();\n      },\n    });\n\n\n\n\u52b9\u679c\n\u5b9f\u6e2c\u5024\u3067\u691c\u7d22\u5b9f\u884c\u6642\u9593\u306f0.6\u79d2\u307b\u3069\u3002\u7cbe\u5ea6\u306felasticsearch\u306eIndex\u69cb\u7bc9\u624b\u6cd5\u306b\u3088\u308a\u3051\u308a\u306b\u306a\u3063\u3066\u3057\u307e\u3044\u307e\u3059\u304c\u3001\u5229\u7528\u3057\u3066\u304f\u308c\u3066\u308b\u30e6\u30fc\u30b6\u304b\u3089\u306e\u6e80\u8db3\u5ea6\u306f\u305d\u3053\u305d\u3053\u9ad8\u3044\u3067\u3059\u3002\n\u3054\u8cea\u554f\u306a\u3069\u3042\u308a\u307e\u3057\u305f\u3089\u30b3\u30e1\u30f3\u30c8\u306b\u3069\u3046\u305e\uff01\n## \u8981\u4ef6\n\n1. elasticsearch\u3067\u306e\u691c\u7d22\u7d50\u679c\u3092jquery\u306edatatables\u3067\u51fa\u529b\u3057\u305f\u3044\n\n## \u74b0\u5883\n- Go 1.3 (with revel as Web Application Framework)\n- elasticsearch 1.3.x (with Kuromoji)\n- jquery 1.10.x\n- datatables 1.10.x\n\n## \u80cc\u666f\n\u3082\u3068\u3082\u3068mongo\u3092\u3046\u3089\u306eDB\u3068\u3057\u3066\u5229\u7528\u3057\u3066\u3044\u307e\u3057\u305f\u304c\u3001\u65e5\u672c\u8a9e\u3067\u306e\u5168\u6587\u691c\u7d22\u306e\u7cbe\u5ea6\u304c\u3069\u3046\u3057\u3066\u3082\u60aa\u3044\u306e\u3068\u3001\u6570\u5341\u4e07\u4ef6\u898f\u6a21\u306e\u30ec\u30b3\u30fc\u30c9\u306e\u691c\u7d22\u306b3\u79d2\u307b\u3069\u6642\u9593\u304c\u304b\u304b\u3063\u3066\u3057\u307e\u3063\u305f\u306e\u3067elasticsearch\u3092\u8a66\u3057\u3066\u307f\u308b\u3053\u3068\u306b\u3057\u307e\u3057\u305f\u3002\n\n## \u304a\u65ad\u308a\nsnippet\u306f\u5fc5\u8981\u306a\u90e8\u5206\u306e\u307f\u62bd\u51fa\u3057\u3066\u307e\u3059\u3002\nstruct\u3067\u5ba3\u8a00\u3057\u3066\u304a\u304d\u306a\u304c\u3089\u3064\u304b\u3063\u3066\u306a\u3044\u306e\u3082\u3042\u308b\u304b\u3082\u3002\u3002\u3002\n\n## snipet\n\n```go:lib.go\ntype ReturnDataTable struct {\n\tDraw               int                      `json:\"draw\"`\n\tRecordsTotal       int                      `json:\"recordsTotal\"`\n\tRecordsFiltered    interface{}              `json:\"recordsFiltered\"`\n\tData               []map[string]interface{} `json:\"data\"`\n\tSearchString       string\n\tLength             int\n\tOrderColumn        string\n\tOrderDir           int\n\tSearchFields       []string\n\tStart              int\n\tAndColumns         []bson.M\n\tObjectIdFields     []string\n\tDefaultOrderColumn string\n}\n\ntype ESClause struct {\n\tFrom      int\n\tSize      int\n\tQuery     string\n\tSortField string\n\tSortOrder string\n\tDraw      int\n}\n\ntype ESFilter struct {\n\tTerm map[string]interface{} `json:\"term\"`\n}\n\ntype ESFilterNot struct {\n\tTerm map[string]interface{} `json:\"term\"`\n}\n\ntype ESFilterShould struct {\n\tTerm map[string]interface{} `json:\"term\"`\n}\n\ntype ESFilterMustNot struct {\n\tTerm map[string]interface{} `json:\"term\"`\n}\n\nfunc ESGet(clause *ESClause, should *[]ESFilterShould, must_not *[]ESFilterMustNot) (*ReturnDataTable, error) {\n\tvar err error\n\tvar ret *ReturnDataTable\n\n\turl_base, _ := revel.Config.String(\"es_url\")\n\n\ttype FilterBool struct {\n\t\tShould  *[]ESFilterShould  `json:\"should\"`\n\t\tMustNot *[]ESFilterMustNot `json:\"must_not\"`\n\t}\n\n\ttype FilterNotBox struct {\n\t\tTerms *[]ESFilterNot `json:\"and\"`\n\t}\n\n\ttype FilterBox struct {\n\t\tFilterBool `json:\"bool\"`\n\t}\n\n\ttype QueryString struct {\n\t\tQuery string `json:\"query\"`\n\t\t//Analyzer string `json:\"analyzer\"`\n\t}\n\n\ttype Query struct {\n\t\tQueryString `json:\"query_string\"`\n\t}\n\n\ttype Size struct {\n\t\tSize int `json:\"size\"`\n\t}\n\n\ttype From struct {\n\t\tFrom int `json:\"from\"`\n\t}\n\n\ttype Analyzer struct {\n\t\tAnalyzer string `json:\"analyzer\"`\n\t}\n\n\ttype JsonBucket struct {\n\t\t//QueryString `json:\",inline\"`\n\t\tFrom      `json:\",inline\"`\n\t\tSize      `json:\",inline\"`\n\t\tQuery     `json:\"query\"`\n\t\tFilterBox `json:\"filter\"`\n\t}\n\n\t//qstr := QueryString{clause.Query, \"\"}\n\tqstr := QueryString{clause.Query}\n\tqs := Query{qstr}\n\n\tfilbool := FilterBool{should, must_not}\n\tfilbox := FilterBox{filbool}\n\n\tbucket := JsonBucket{\n\t\tFrom{clause.From},\n\t\tSize{clause.Size},\n\t\tqs,\n\t\tfilbox,\n\t}\n\n\t//revel.ERROR.Println(filbox)\n\n\tjbucket, _ := json.Marshal(bucket)\n\n\tif err != nil {\n\t\trevel.ERROR.Println(err)\n\t}\n\n\turl := url_base\n\n\tclient := &http.Client{}\n\treq, _ := http.NewRequest(\n\t\t\"POST\",\n\t\turl,\n\t\tbytes.NewReader(jbucket),\n\t)\n\n\treq.Header.Set(\"Content-Type\", \"application/json; charset=UTF-8\")\n\n\tresp, _ := client.Do(req)\n\tbody, _ := ioutil.ReadAll(resp.Body)\n\tdefer resp.Body.Close()\n\n\tvar f interface{}\n\tjson.Unmarshal(body, &f)\n\tm := f.(map[string]interface{})\n\n\tn, ok := m[\"hits\"].(map[string]interface{})\n\n\tif !ok {\n\n\t\tret = &ReturnDataTable{}\n\n\t\tret.Draw = clause.Draw\n\t\tret.Data = make([]map[string]interface{}, 0)\n\t\tret.RecordsFiltered = 0\n\t\tret.Start = clause.From\n\n\t\treturn ret, err\n\n\t}\n\n\tvar fs []interface{}\n\n\tfs = n[\"hits\"].([]interface{})\n\n\tvar sources []map[string]interface{}\n\n\tfor _, v := range fs {\n\t\td := v.(map[string]interface{})\n\t\tsources = append(sources, d[\"_source\"].(map[string]interface{}))\n\t}\n\n\tifound := len(sources)\n\n\tvar retVals []map[string]interface{}\n\n\tfor _, v := range sources {\n\n\t\tvar retVal map[string]interface{}\n\n\t\tvar id string\n\n\t\tretVal = make(map[string]interface{})\n\n\t\tfor k, nv := range v {\n\t\t\tretVal[k] = nv\n\t\t\tif k == \"_id\" {\n\t\t\t\tid = nv.(string)\n\t\t\t}\n\t\t}\n\t\tretVal[\"Id\"] = id\n\t\tretVal[\"DT_RowId\"] = id\n\t\tretVal[\"DT_RowClass\"] = \"Rest_\" + id\n\t\tretVal[\"DT_RowData\"] = map[string]string{\"id\": id}\n\t\tretVals = append(retVals, retVal)\n\t}\n\n\tif ifound == 0 {\n\t\tretVals = make([]map[string]interface{}, 0)\n\t}\n\n\tret = &ReturnDataTable{}\n\n\tret.Draw = clause.Draw\n\tret.Data = retVals\n\tret.RecordsFiltered = n[\"total\"]\n\tret.Start = clause.From\n\n\treturn ret, err\n\n}\n```\n\n```go:controllers/app.go\nfunc (c Restaurant) GetDataTable() revel.Result {\n\tvar clause *lib.ESClause\n\tvar should []lib.ESFilterShould = []library.ESFilterShould{}\n\tvar must_not []lib.ESFilterMustNot = []library.ESFilterMustNot{}\n\n    // set query clauses here\n\tiLen, _ := strconv.Atoi(c.Params.Get(\"length\"))\n\tsVal := c.Params.Get(\"search[value]\")\n    /* your custom conditions\n\tbSomeFlag := c.Params.Get(\"someflag\")\n\t_should := lib.ESFilterShould{map[string]interface{}{\"whateverflag\": true}}\n\t//_must_not := lib.ESFilterMustNot{map[string]interface{}{\"someeverflag\": false}}\n\n    */\n\n\tif sVal == \"\" {\n\t\tsVal = \"*\"\n\t}\n\n    // append conditions to \"should\" and/or \"must_not\" if needed\n\n\tvar iDraw int = 0\n\tc.Params.Bind(&iDraw, \"draw\")\n\n\tvar iFrom int = 0\n\tc.Params.Bind(&iFrom, \"start\")\n\n\tclause = &lib.ESClause{\n\t\tQuery: sVal,\n\t\tSize:  iLen,\n\t\tFrom:  iFrom,\n\t\tDraw:  iDraw,\n\t}\n\n\tret, err := lib.ESGet(clause, &should, &must_not)\n\n\tif err != nil {\n\t\trevel.INFO.Println(err)\n\t}\n\n\treturn c.RenderJson(ret)\n}\n```\n\n```js:app.js\n  var dt = $(\"#table\").dataTable({\n    \"dom\": '<\"row-fluid\"<\"span2\"l><\"span10\"f<\"bushi-dt-btn2\">>>tip',\n    \"bLengthChange\": true,\n    \"iDisplayLength\": 25,\n    \"sPaginationType\": \"bootstrap\", \n    \"showPagenation\": true,\n    \"showFilter\": true,\n    \"info\": true,\n    \"bDestroy\": true,\n    \"processing\": true,\n    \"serverSide\": true,\n    \"ajax\": {\n      url: \"/app/get_dt\", // the uri for controller/app\n      data: { \"whateverflag\": \"true\" }, // default param you want to send\n      complete: function(d) {\n        $(\"#loading\").hide();\n      },\n    });\n```\n\n##\u52b9\u679c\n\n\u5b9f\u6e2c\u5024\u3067\u691c\u7d22\u5b9f\u884c\u6642\u9593\u306f0.6\u79d2\u307b\u3069\u3002\u7cbe\u5ea6\u306felasticsearch\u306eIndex\u69cb\u7bc9\u624b\u6cd5\u306b\u3088\u308a\u3051\u308a\u306b\u306a\u3063\u3066\u3057\u307e\u3044\u307e\u3059\u304c\u3001\u5229\u7528\u3057\u3066\u304f\u308c\u3066\u308b\u30e6\u30fc\u30b6\u304b\u3089\u306e\u6e80\u8db3\u5ea6\u306f\u305d\u3053\u305d\u3053\u9ad8\u3044\u3067\u3059\u3002\n\n\u3054\u8cea\u554f\u306a\u3069\u3042\u308a\u307e\u3057\u305f\u3089\u30b3\u30e1\u30f3\u30c8\u306b\u3069\u3046\u305e\uff01\n", "tags": ["Elasticsearch", "golang", "Go", "DataTables"]}