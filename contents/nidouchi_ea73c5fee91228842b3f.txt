{"context": " More than 1 year has passed since last update.\u554f\u984c\u306f\u3053\u3061\u3089\u306e\u30ea\u30f3\u30af\u304b\u3089\nhttp://qiita.com/Nabetani/items/936e7885f4c607472060\ndef solve(q)\n  walls = q.chars.map(&:to_i)\n  y_sz = walls.max\n  x_sz = walls.size\n  pool = walls.map{|sz| sz==0 ? [:H]*y_sz : [:B]*sz + [:W]*(y_sz-sz)}\n  pool.each_with_index{|v, i|\n    v.each_with_index{|w, j|\n      next if w == :B\n      break if j == 0\n      left_ok = right_ok = false\n      if i > 0\n        (i-1).downto(0){|ii|\n          case pool[ii][j]\n          when :H\n            break\n          when :B\n            left_ok = true\n            break\n          end\n        }\n      end\n      if i < x_sz - 1\n        (i+1).upto(x_sz-1){|ii|\n          case pool[ii][j]\n          when :H\n            break\n          when :B\n            right_ok = true\n            break\n          end\n        }\n      end\n      unless left_ok and right_ok\n        pool[i] = pool[i][0, j]\n        break\n      end\n    }\n  }\n  pool.flatten.count{|v| v == :W}\nend\n\nDATA.readlines.each do |line|\n  no,q,a,d = line.chop.split(/\\s+/)\n  ans = solve(q)\n  print no + \"\\t\" + ans.to_s\n  puts ans == a.to_i ? ' o' : ' x'\nend\n__END__\n0   83141310145169154671122 24  \n1   923111128   45  \n2   923101128   1   \n\n\u554f\u984c\u306f\u3053\u3061\u3089\u306e\u30ea\u30f3\u30af\u304b\u3089\nhttp://qiita.com/Nabetani/items/936e7885f4c607472060\n\n```rb\ndef solve(q)\n  walls = q.chars.map(&:to_i)\n  y_sz = walls.max\n  x_sz = walls.size\n  pool = walls.map{|sz| sz==0 ? [:H]*y_sz : [:B]*sz + [:W]*(y_sz-sz)}\n  pool.each_with_index{|v, i|\n    v.each_with_index{|w, j|\n      next if w == :B\n      break if j == 0\n      left_ok = right_ok = false\n      if i > 0\n        (i-1).downto(0){|ii|\n          case pool[ii][j]\n          when :H\n            break\n          when :B\n            left_ok = true\n            break\n          end\n        }\n      end\n      if i < x_sz - 1\n        (i+1).upto(x_sz-1){|ii|\n          case pool[ii][j]\n          when :H\n            break\n          when :B\n            right_ok = true\n            break\n          end\n        }\n      end\n      unless left_ok and right_ok\n        pool[i] = pool[i][0, j]\n        break\n      end\n    }\n  }\n  pool.flatten.count{|v| v == :W}\nend\n\nDATA.readlines.each do |line|\n  no,q,a,d = line.chop.split(/\\s+/)\n  ans = solve(q)\n  print no + \"\\t\" + ans.to_s\n  puts ans == a.to_i ? ' o' : ' x'\nend\n__END__\n0\t83141310145169154671122\t24\t\n1\t923111128\t45\t\n2\t923101128\t1\t\n```", "tags": ["Ruby", "yhpg", "\u3069\u3046\u66f8\u304f"]}