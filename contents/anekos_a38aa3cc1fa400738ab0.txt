{"context": " More than 1 year has passed since last update.xmonad: executeFile: resource exhausted (Argument list too long)\n\u306a\u3084\u3064\u3002\n\u306a\u304c\u3059\u304e\u308b\u5f15\u6570\u3067\u72b6\u614b\u3092\u6e21\u3057\u3066\u3044\u308b\u306e\u304c\u539f\u56e0\u3067\u5931\u6557\u3057\u3066\u3044\u305f\u306e\u3067\u3001\u4e00\u6642\u30d5\u30a1\u30a4\u30eb\u3092\u4f7f\u3046\u3088\u3046\u306b\u3002\n\nResume.hs\n{-# LANGUAGE ScopedTypeVariables #-}\n\nmodule Anekos.Resume (withStrongResume, reload) where\n\n\nimport Control.Exception (catch, bracket)\nimport Control.Monad (void)\nimport Data.List (elemIndex)\nimport Data.Map (toList)\nimport Data.Maybe (mapMaybe)\nimport Prelude hiding (catch)\nimport System.Directory (removeFile)\nimport System.Environment (getArgs, withArgs)\nimport System.Exit (ExitCode(..))\nimport System.IO (FilePath)\nimport System.Posix.Files (fileExist)\nimport System.Posix.Process (executeFile)\nimport System.Process (runCommand, waitForProcess)\nimport XMonad\nimport qualified XMonad.StackSet as SS\n\n\nstateFilepath :: FilePath\nstateFilepath = \"/tmp/xmonad-state\"\n\n\nwithStrongResume :: IO () -> IO ()\nwithStrongResume act = do\n    args <- newArgs\n    withArgs args act\n\n-- ref: restart@XMonad/Operations.hs\n\nreload :: X ()\nreload = do\n    broadcastMessage ReleaseResources\n    io . flush =<< asks display\n    text <- gets $ show . (\\s -> windowSetData s : extState s)\n    io $ writeFile stateFilepath text\n    whenX (recompile True) $ catchIO (executeFile \"xmonad\" True [] Nothing)\n  where\n    windowSetData   = show . SS.mapLayout show . windowset\n    extState        = return . show . mapMaybe maybeShow . toList . extensibleState\n    maybeShow (t, Right (PersistentExtension ext)) = Just (t, show ext)\n    maybeShow (t, Left str)                        = Just (t, str)\n    maybeShow _                                    = Nothing\n\n\nnewArgs :: IO [String]\nnewArgs = do cnt <- readFile stateFilepath\n             let args = cnt `seq` read cnt\n             removeFile stateFilepath\n             return (\"--resume\" : args)\n          `catch`\n          \\(e::IOError) -> return []\n\n\n\n\nxmonad.hs\n\nimport Anekos.Resume (withStrongResume)\n\nimport XMonad\n\n\nmain = do\n  withStrongResume $ xmonad $ defaultConfig\n    { borderWidth        = 0\n    , \n    -- ....\n    } `additionalKeysP` myKeys\n\nmyKeys = [(\"M-q\",       reload)]\n\n\n\n\nhttps://bitbucket.org/anekos/xmonad-conf/changeset/e60bfb3ac83f\nxmonad: executeFile: resource exhausted (Argument list too long)\n\u306a\u3084\u3064\u3002\n\u306a\u304c\u3059\u304e\u308b\u5f15\u6570\u3067\u72b6\u614b\u3092\u6e21\u3057\u3066\u3044\u308b\u306e\u304c\u539f\u56e0\u3067\u5931\u6557\u3057\u3066\u3044\u305f\u306e\u3067\u3001\u4e00\u6642\u30d5\u30a1\u30a4\u30eb\u3092\u4f7f\u3046\u3088\u3046\u306b\u3002\n\n```Resume.hs\n{-# LANGUAGE ScopedTypeVariables #-}\n\nmodule Anekos.Resume (withStrongResume, reload) where\n\n\nimport Control.Exception (catch, bracket)\nimport Control.Monad (void)\nimport Data.List (elemIndex)\nimport Data.Map (toList)\nimport Data.Maybe (mapMaybe)\nimport Prelude hiding (catch)\nimport System.Directory (removeFile)\nimport System.Environment (getArgs, withArgs)\nimport System.Exit (ExitCode(..))\nimport System.IO (FilePath)\nimport System.Posix.Files (fileExist)\nimport System.Posix.Process (executeFile)\nimport System.Process (runCommand, waitForProcess)\nimport XMonad\nimport qualified XMonad.StackSet as SS\n\n\nstateFilepath :: FilePath\nstateFilepath = \"/tmp/xmonad-state\"\n\n\nwithStrongResume :: IO () -> IO ()\nwithStrongResume act = do\n    args <- newArgs\n    withArgs args act\n\n-- ref: restart@XMonad/Operations.hs\n\nreload :: X ()\nreload = do\n    broadcastMessage ReleaseResources\n    io . flush =<< asks display\n    text <- gets $ show . (\\s -> windowSetData s : extState s)\n    io $ writeFile stateFilepath text\n    whenX (recompile True) $ catchIO (executeFile \"xmonad\" True [] Nothing)\n  where\n    windowSetData   = show . SS.mapLayout show . windowset\n    extState        = return . show . mapMaybe maybeShow . toList . extensibleState\n    maybeShow (t, Right (PersistentExtension ext)) = Just (t, show ext)\n    maybeShow (t, Left str)                        = Just (t, str)\n    maybeShow _                                    = Nothing\n\n\nnewArgs :: IO [String]\nnewArgs = do cnt <- readFile stateFilepath\n             let args = cnt `seq` read cnt\n             removeFile stateFilepath\n             return (\"--resume\" : args)\n          `catch`\n          \\(e::IOError) -> return []\n\n```\n\n\n```xmonad.hs\n\nimport Anekos.Resume (withStrongResume)\n\nimport XMonad\n\n\nmain = do\n  withStrongResume $ xmonad $ defaultConfig\n    { borderWidth        = 0\n    , \n    -- ....\n    } `additionalKeysP` myKeys\n\nmyKeys = [(\"M-q\",       reload)]\n\n\n```\n\nhttps://bitbucket.org/anekos/xmonad-conf/changeset/e60bfb3ac83f\n", "tags": ["xmonad", "Haskell"]}