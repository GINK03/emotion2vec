{"context": "\u4eca\u66f4\u304b\u3082\u3057\u308c\u307e\u305b\u3093\u304c\u3001iOS Quickstart | Apps Script | Google Developers\u306eiOS\uff08Swift\uff09\u30b5\u30f3\u30d7\u30eb\u30b3\u30fc\u30c9\u304cWebView\u304b\u3089Google\u3078\u306eOAuth\u30ea\u30af\u30a8\u30b9\u30c8\u7981\u6b62\u306b\u5bfe\u5fdc\u3057\u3066\u3044\u306a\u3044\u306e\u3067\u3001\u5bfe\u5fdc\u3059\u308b\u3088\u3046\u306b\u3057\u3066\u307f\u307e\u3057\u305f\u3002\n\n\u6982\u8981\n\u3053\u308c\u307e\u3067iOS\u30a2\u30d7\u30ea\u3067\u3001Google\u30c9\u30e9\u30a4\u30d6\u304b\u3089Google Apps Script\u3092\u4f7f\u3063\u3066\u30c7\u30fc\u30bf\u3092\u53d6\u5f97\u3059\u308b\u306e\u306b\u3001Google\u516c\u5f0f\u306e\u30b5\u30f3\u30d7\u30eb\u30b3\u30fc\u30c9\uff08iOS Quickstart | Apps Script | Google Developers\uff09\u3092\u53c2\u8003\u306b\u3057\u3066\u3044\u305f\u306e\u3067\u3059\u304c\u3001\u3053\u306e\u30b5\u30f3\u30d7\u30eb\u30b3\u30fc\u30c9\u306fGoogle\u8a8d\u8a3c\u306e\u969b\u306bWebView\u3092\u5229\u7528\u3059\u308b\u65b9\u6cd5\u3092\u53d6\u3063\u3066\u3044\u307e\u3057\u305f\u3002\n\u3068\u3044\u3046\u308f\u3051\u3067\u3001Google\u304b\u3089\u30a2\u30ca\u30a6\u30f3\u30b9\u3055\u308c\u305fModernizing OAuth interactions in Native Apps for Better Usability and Security\u306e\n\nIn the coming months, we will no longer allow OAuth requests to Google in embedded browsers known as \u201cweb-views\u201d.\n\n\u8a33\uff1a\u300c\u30a6\u30a7\u30d6\u30d3\u30e5\u30fc\u300d\u3068\u8a00\u308f\u308c\u308b\u57cb\u3081\u8fbc\u307f\u30d6\u30e9\u30a6\u30b6\u304b\u3089 Google \u3078\u306e OAuth \u30ea\u30af\u30a8\u30b9\u30c8\u306f\u8a31\u53ef\u3055\u308c\u306a\u304f\u306a\u308a\u307e\u3059\u3002\n\u306b\u898b\u4e8b\u5f15\u3063\u304b\u304b\u3063\u3066\u3057\u307e\u3044\u307e\u3059\u3002\n\u306a\u306e\u3067\u3001Modernizing OAuth interactions in Native Apps for Better Usability and Security\u306b\u6848\u5185\u3055\u308c\u3066\u3044\u308b\u901a\u308a\u3001GTMAppAuth\u3092\u5229\u7528\u3057\u3066\u4fee\u6b63\u3092\u884c\u3044\u307e\u3057\u305f\u3002\n\u305f\u3060\u3001\u516c\u958b\u3055\u308c\u3066\u3044\u308b\u30b3\u30fc\u30c9\u306fObjective-C\u3060\u3063\u305f\u306e\u3067\u3001Swift\u3067\u306e\u5bfe\u5fdc\u3068\u3044\u3046\u3053\u3068\u3067\u3001\u672a\u3060\u4fee\u6b63\u3055\u308c\u3066\u3044\u306a\u3044\uff0812/13\u73fe\u5728\uff09iOS Quickstart | Apps Script | Google Developers\u306eiOS\uff08Swift\uff09\u306e\u30b5\u30f3\u30d7\u30eb\u30b3\u30fc\u30c9\u3092\u5bfe\u5fdc\u3055\u305b\u3066\u307f\u307e\u3057\u305f\u3002\n\n\u30b3\u30fc\u30c9\n\u624b\u9806\u306f\u57fa\u672c\u7684\u306biOS Quickstart | Apps Script | Google Developers\u306e\u901a\u308a\u3067\u3059\u3002\n\u307e\u305a\u3001\u6700\u521d\u306bPodfile\u306e\u4e2d\u8eab\u304c\u5909\u308f\u308a\u307e\u3059\u3002\n\nPodfile\ncat << EOF > Podfile &&\nuse_frameworks!\ntarget 'QuickstartApp' do\n    pod 'GoogleAPIClient/Core', '~> 1.0.2'\n    pod 'GTMAppAuth'\nend\nEOF\npod install &&\nopen QuickstartApp.xcworkspace\n\n\nViewController.swift\u306f\u4e0b\u8a18\u30b3\u30fc\u30c9\u306e\u3088\u3046\u306b\u7f6e\u304d\u63db\u3048\u307e\u3059\u3002\uff08ID\u7b49\u306f\u81ea\u8eab\u306e\u3082\u306e\u306b\u7f6e\u304d\u63db\u3048\u3066\u304f\u3060\u3055\u3044\u3002\uff09\n\nViewController.swift\nimport GoogleAPIClient\nimport AppAuth\nimport GTMAppAuth\nimport UIKit\n\nclass ViewController: UIViewController {\n\n    private let kKeychainItemName = \"Google Apps Script Execution API\"\n    private let kClientID = \"YOUR_CLIENT.apps.googleusercontent.com\"\n    private let kScriptId = \"ENTER_YOUR_SCRIPT_ID_HERE\"\n\n    private let kRedirectURI = \"com.googleusercontent.apps.YOUR_CLIENT:/oauthredirect\"\n    private let kIssuer = \"https://accounts.google.com\"\n\n    // If modifying these scopes, delete your previously saved credentials by\n    // resetting the iOS simulator or uninstall the app.\n    private let scopes = [\"https://www.googleapis.com/auth/drive\"]\n\n    private let service = GTLService()\n\n    var authorization: GTMAppAuthFetcherAuthorization?\n\n    let output = UITextView()\n\n    // When the view loads, create necessary subviews\n    // and initialize the Google Apps Script Execution API service\n    override func viewDidLoad() {\n        super.viewDidLoad()\n\n        output.frame = view.bounds\n        output.isEditable = false\n        output.contentInset = UIEdgeInsets(top: 20, left: 0, bottom: 20, right: 0)\n        output.autoresizingMask = [.flexibleHeight, .flexibleWidth]\n\n        view.addSubview(output);\n\n        loadState()\n\n        if authorization == nil {\n            authInBrowser()\n        } else {\n            service.authorizer = authorization\n            if let authorizer = service.authorizer,\n                let canAuth = authorizer.canAuthorize, canAuth {\n                callAppsScript()\n            }\n        }\n\n    }\n\n    func authInBrowser() {\n        let issuer = URL(string: kIssuer)\n        let redirectURI = URL(string: kRedirectURI)\n\n        // discovers endpoints\n        OIDAuthorizationService.discoverConfiguration(forIssuer: issuer!, completion: {\n            (configuration, error) in\n            if configuration == nil {\n                print(\"Error retrieving discovery document: \\(error?.localizedDescription)\")\n                self.setGtmAuthorization(stauthorization: nil)\n                return\n            }\n\n            print(\"Got configuration: \\(configuration!)\")\n\n            // builds authentication request\n            let request: OIDAuthorizationRequest = OIDAuthorizationRequest.init(\n                configuration: configuration!,\n                clientId: self.kClientID,\n                scopes: self.scopes,\n                redirectURL: redirectURI!,\n                responseType: OIDResponseTypeCode,\n                additionalParameters: nil)\n\n            // performs authentication request\n            let appDelegate: AppDelegate = UIApplication.shared.delegate as! AppDelegate\n            print(\"Initiating authorization request with scope: \\(request.scope!)\")\n\n            appDelegate.currentAuthorizationFlow = OIDAuthState.authState(\n                byPresenting: request,\n                presenting: self,\n                callback: {\n                    (authState, error) in\n                    if authState != nil {\n                        let gauthorization: GTMAppAuthFetcherAuthorization = GTMAppAuthFetcherAuthorization(authState: authState!)\n                        self.setGtmAuthorization(stauthorization: gauthorization)\n                        print(\"Got authorization tokens. Access token: \\(authState?.lastTokenResponse?.accessToken)\")\n                    } else {\n                        self.setGtmAuthorization(stauthorization: nil)\n                        print(\"Authorization error: \\(error?.localizedDescription)\")\n                    }\n                    if let authorizer = self.service.authorizer,\n                        let canAuth = authorizer.canAuthorize, canAuth {\n                        self.callAppsScript()\n                    }\n            })\n        })\n    }\n\n    func saveState() {\n        if authorization != nil {\n            if (authorization?.canAuthorize())! {\n                GTMAppAuthFetcherAuthorization.save(authorization!, toKeychainForName: \"authorization\")\n            } else {\n                GTMAppAuthFetcherAuthorization.removeFromKeychain(forName: \"authorization\")\n            }\n        } else {\n            GTMAppAuthFetcherAuthorization.removeFromKeychain(forName: \"authorization\")\n        }\n    }\n\n    func loadState() {\n        if GTMAppAuthFetcherAuthorization(fromKeychainForName: \"authorization\") != nil {\n            let lauthorization: GTMAppAuthFetcherAuthorization = GTMAppAuthFetcherAuthorization(fromKeychainForName: \"authorization\")!\n            self.setGtmAuthorization(stauthorization: lauthorization)\n        }\n    }\n\n    func setGtmAuthorization(stauthorization: GTMAppAuthFetcherAuthorization?) {\n        if authorization == stauthorization {\n            return\n        }\n        authorization = stauthorization\n        stateChanged()\n        service.authorizer = authorization\n    }\n\n    func stateChanged() {\n        self.saveState()\n    }\n\n    // Calls an Apps Script function to list the folders in the user's\n    // root Drive folder.\n    func callAppsScript() {\n        output.text = \"Getting folders...\"\n        let baseUrl = \"https://script.googleapis.com/v1/scripts/\\(kScriptId):run\"\n        let url = GTLUtilities.url(with: baseUrl, queryParameters: nil)\n\n        // Create an execution request object.\n        let request = GTLObject()\n        request.setJSONValue(\"getFoldersUnderRoot\", forKey: \"function\")\n\n        // Make the API request.\n        service.fetchObject(byInserting: request,\n                            for: url!,\n                            delegate: self,\n                            didFinish: #selector(displayResultWithTicket(ticket:finishedWithObject:error:)))\n    }\n\n    // Displays the retrieved folders returned by the Apps Script function.\n    func displayResultWithTicket(ticket: GTLServiceTicket,\n                                 finishedWithObject object : GTLObject,\n                                 error : NSError?) {\n        if let error = error {\n            // The API encountered a problem before the script\n            // started executing.\n            showAlert(title: \"The API returned the error: \",\n                      message: error.localizedDescription)\n            return\n        }\n\n        if let apiError = object.json[\"error\"] as? [String: AnyObject] {\n            // The API executed, but the script returned an error.\n\n            // Extract the first (and only) set of error details and cast as\n            // a Dictionary. The values of this Dictionary are the script's\n            // 'errorMessage' and 'errorType', and an array of stack trace\n            // elements (which also need to be cast as Dictionaries).\n            let details = apiError[\"details\"] as! [[String: AnyObject]]\n            var errMessage = String(\n                format:\"Script error message: %@\\n\",\n                details[0][\"errorMessage\"] as! String)\n\n            if let stacktrace =\n                details[0][\"scriptStackTraceElements\"] as? [[String: AnyObject]] {\n                // There may not be a stacktrace if the script didn't start\n                // executing.\n                for trace in stacktrace {\n                    let f = trace[\"function\"] as? String ?? \"Unknown\"\n                    let num = trace[\"lineNumber\"] as? Int ?? -1\n                    errMessage += \"\\t\\(f): \\(num)\\n\"\n                }\n            }\n\n            // Set the output as the compiled error message.\n            output.text = errMessage\n        } else {\n            // The result provided by the API needs to be cast into the\n            // correct type, based upon what types the Apps Script function\n            // returns. Here, the function returns an Apps Script Object with\n            // String keys and values, so must be cast into a Dictionary\n            // (folderSet).\n            let response = object.json[\"response\"] as! [String: AnyObject]\n            let folderSet = response[\"result\"] as! [String: AnyObject]\n            if folderSet.count == 0 {\n                output.text = \"No folders returned!\\n\"\n            } else {\n                var folderString = \"Folders under your root folder:\\n\"\n                for (id, folder) in folderSet {\n                    folderString += \"\\t\\(folder) (\\(id))\\n\"\n                }\n                output.text = folderString\n            }\n        }\n    }\n\n    // Helper for showing an alert\n    func showAlert(title : String, message: String) {\n        let alert = UIAlertController(\n            title: title,\n            message: message,\n            preferredStyle: UIAlertControllerStyle.alert\n        )\n        let ok = UIAlertAction(\n            title: \"OK\",\n            style: UIAlertActionStyle.default,\n            handler: nil\n        )\n        alert.addAction(ok)\n        present(alert, animated: true, completion: nil)\n    }\n\n    override func didReceiveMemoryWarning() {\n        super.didReceiveMemoryWarning()\n        // Dispose of any resources that can be recreated.\n    }   \n}\n\n\n\u8a8d\u8a3c\u90e8\u5206\u304c\u5225\u30b9\u30ec\u30c3\u30c9\u3067\u5b9f\u884c\u3055\u308c\u308b\u3088\u3046\u306b\u306a\u308b\u306e\u3067\u3001callAppsScript\u3092\u5b9f\u884c\u3059\u308b\u30bf\u30a4\u30df\u30f3\u30b0\u3092viewDidAppear\u306e\u30bf\u30a4\u30df\u30f3\u30b0\u304b\u3089\u8a8d\u8a3c\u51e6\u7406\u5f8c\u306b\u3057\u3066\u3044\u307e\u3059\u3002\nAppDelegate.swift\u306bAppAuth\u3092import\u3057\u3001AppDelegate\u30af\u30e9\u30b9\u306b\u4e0b\u8a18\u306e\u30b3\u30fc\u30c9\u3092\u8ffd\u52a0\u3057\u307e\u3059\u3002\n\nAppDelegate.swift\n    var currentAuthorizationFlow: OIDAuthorizationFlowSession?\n\n    func application(_ app: UIApplication, open url: URL, options: [UIApplicationOpenURLOptionsKey : Any] = [:]) -> Bool {\n        if (currentAuthorizationFlow?.resumeAuthorizationFlow(with: url))! {\n            currentAuthorizationFlow = nil\n            return true\n        }\n        return false\n    }\n\n\ninfo.plist\u306b\u4e0b\u8a18\u306e\u30b3\u30fc\u30c9\u3092\u8ffd\u52a0\u3057\u307e\u3059\u3002\uff08ID\u306f\u81ea\u8eab\u306e\u3082\u306e\u306b\u7f6e\u304d\u63db\u3048\u3066\u304f\u3060\u3055\u3044\u3002\uff09\n\ninfo.plist\n    <key>CFBundleURLTypes</key>\n    <array>\n        <dict>\n            <key>CFBundleTypeRole</key>\n            <string>Editor</string>\n            <key>CFBundleURLSchemes</key>\n            <array>\n                <string>com.googleusercontent.apps.YOUR_CLIENT</string>\n            </array>\n        </dict>\n    </array>\n\n\n\u305d\u306e\u4ed6\u3001GoogleAppsScript\u306f\u7279\u306b\u5909\u66f4\u306e\u5fc5\u8981\u306f\u3042\u308a\u307e\u305b\u3093\u3002\n\u4eca\u66f4\u304b\u3082\u3057\u308c\u307e\u305b\u3093\u304c\u3001[iOS Quickstart | Apps Script | Google Developers](https://developers.google.com/apps-script/guides/rest/quickstart/ios?ver=swift)\u306eiOS\uff08Swift\uff09\u30b5\u30f3\u30d7\u30eb\u30b3\u30fc\u30c9\u304cWebView\u304b\u3089Google\u3078\u306eOAuth\u30ea\u30af\u30a8\u30b9\u30c8\u7981\u6b62\u306b\u5bfe\u5fdc\u3057\u3066\u3044\u306a\u3044\u306e\u3067\u3001\u5bfe\u5fdc\u3059\u308b\u3088\u3046\u306b\u3057\u3066\u307f\u307e\u3057\u305f\u3002\n\n#\u6982\u8981\n\n\u3053\u308c\u307e\u3067iOS\u30a2\u30d7\u30ea\u3067\u3001Google\u30c9\u30e9\u30a4\u30d6\u304b\u3089Google Apps Script\u3092\u4f7f\u3063\u3066\u30c7\u30fc\u30bf\u3092\u53d6\u5f97\u3059\u308b\u306e\u306b\u3001Google\u516c\u5f0f\u306e\u30b5\u30f3\u30d7\u30eb\u30b3\u30fc\u30c9\uff08[iOS Quickstart | Apps Script | Google Developers](https://developers.google.com/apps-script/guides/rest/quickstart/ios?ver=swift)\uff09\u3092\u53c2\u8003\u306b\u3057\u3066\u3044\u305f\u306e\u3067\u3059\u304c\u3001\u3053\u306e\u30b5\u30f3\u30d7\u30eb\u30b3\u30fc\u30c9\u306fGoogle\u8a8d\u8a3c\u306e\u969b\u306bWebView\u3092\u5229\u7528\u3059\u308b\u65b9\u6cd5\u3092\u53d6\u3063\u3066\u3044\u307e\u3057\u305f\u3002\n\n\u3068\u3044\u3046\u308f\u3051\u3067\u3001Google\u304b\u3089\u30a2\u30ca\u30a6\u30f3\u30b9\u3055\u308c\u305f[Modernizing OAuth interactions in Native Apps for Better Usability and Security](https://developers.googleblog.com/2016/08/modernizing-oauth-interactions-in-native-apps.html)\u306e\n>In the coming months, we will no longer allow OAuth requests to Google in embedded browsers known as \u201cweb-views\u201d.\n\n\u8a33\uff1a\u300c\u30a6\u30a7\u30d6\u30d3\u30e5\u30fc\u300d\u3068\u8a00\u308f\u308c\u308b\u57cb\u3081\u8fbc\u307f\u30d6\u30e9\u30a6\u30b6\u304b\u3089 Google \u3078\u306e OAuth \u30ea\u30af\u30a8\u30b9\u30c8\u306f\u8a31\u53ef\u3055\u308c\u306a\u304f\u306a\u308a\u307e\u3059\u3002\n\n\u306b\u898b\u4e8b\u5f15\u3063\u304b\u304b\u3063\u3066\u3057\u307e\u3044\u307e\u3059\u3002\n\n\u306a\u306e\u3067\u3001[Modernizing OAuth interactions in Native Apps for Better Usability and Security](https://developers.googleblog.com/2016/08/modernizing-oauth-interactions-in-native-apps.html)\u306b\u6848\u5185\u3055\u308c\u3066\u3044\u308b\u901a\u308a\u3001[GTMAppAuth](https://github.com/google/GTMAppAuth)\u3092\u5229\u7528\u3057\u3066\u4fee\u6b63\u3092\u884c\u3044\u307e\u3057\u305f\u3002\n\n\u305f\u3060\u3001\u516c\u958b\u3055\u308c\u3066\u3044\u308b\u30b3\u30fc\u30c9\u306fObjective-C\u3060\u3063\u305f\u306e\u3067\u3001Swift\u3067\u306e\u5bfe\u5fdc\u3068\u3044\u3046\u3053\u3068\u3067\u3001\u672a\u3060\u4fee\u6b63\u3055\u308c\u3066\u3044\u306a\u3044\uff0812/13\u73fe\u5728\uff09[iOS Quickstart | Apps Script | Google Developers](https://developers.google.com/apps-script/guides/rest/quickstart/ios?ver=swift)\u306eiOS\uff08Swift\uff09\u306e\u30b5\u30f3\u30d7\u30eb\u30b3\u30fc\u30c9\u3092\u5bfe\u5fdc\u3055\u305b\u3066\u307f\u307e\u3057\u305f\u3002\n\n#\u30b3\u30fc\u30c9\n\u624b\u9806\u306f\u57fa\u672c\u7684\u306b[iOS Quickstart | Apps Script | Google Developers](https://developers.google.com/apps-script/guides/rest/quickstart/ios?ver=swift)\u306e\u901a\u308a\u3067\u3059\u3002\n\n\u307e\u305a\u3001\u6700\u521d\u306bPodfile\u306e\u4e2d\u8eab\u304c\u5909\u308f\u308a\u307e\u3059\u3002\n\n```rb:Podfile\ncat << EOF > Podfile &&\nuse_frameworks!\ntarget 'QuickstartApp' do\n    pod 'GoogleAPIClient/Core', '~> 1.0.2'\n    pod 'GTMAppAuth'\nend\nEOF\npod install &&\nopen QuickstartApp.xcworkspace\n```\n\nViewController.swift\u306f\u4e0b\u8a18\u30b3\u30fc\u30c9\u306e\u3088\u3046\u306b\u7f6e\u304d\u63db\u3048\u307e\u3059\u3002\uff08ID\u7b49\u306f\u81ea\u8eab\u306e\u3082\u306e\u306b\u7f6e\u304d\u63db\u3048\u3066\u304f\u3060\u3055\u3044\u3002\uff09\n\n```swift:ViewController.swift\nimport GoogleAPIClient\nimport AppAuth\nimport GTMAppAuth\nimport UIKit\n\nclass ViewController: UIViewController {\n    \n    private let kKeychainItemName = \"Google Apps Script Execution API\"\n    private let kClientID = \"YOUR_CLIENT.apps.googleusercontent.com\"\n    private let kScriptId = \"ENTER_YOUR_SCRIPT_ID_HERE\"\n    \n    private let kRedirectURI = \"com.googleusercontent.apps.YOUR_CLIENT:/oauthredirect\"\n    private let kIssuer = \"https://accounts.google.com\"\n        \n    // If modifying these scopes, delete your previously saved credentials by\n    // resetting the iOS simulator or uninstall the app.\n    private let scopes = [\"https://www.googleapis.com/auth/drive\"]\n    \n    private let service = GTLService()\n    \n    var authorization: GTMAppAuthFetcherAuthorization?\n    \n    let output = UITextView()\n    \n    // When the view loads, create necessary subviews\n    // and initialize the Google Apps Script Execution API service\n    override func viewDidLoad() {\n        super.viewDidLoad()\n        \n        output.frame = view.bounds\n        output.isEditable = false\n        output.contentInset = UIEdgeInsets(top: 20, left: 0, bottom: 20, right: 0)\n        output.autoresizingMask = [.flexibleHeight, .flexibleWidth]\n        \n        view.addSubview(output);\n        \n        loadState()\n        \n        if authorization == nil {\n            authInBrowser()\n        } else {\n            service.authorizer = authorization\n            if let authorizer = service.authorizer,\n                let canAuth = authorizer.canAuthorize, canAuth {\n                callAppsScript()\n            }\n        }\n        \n    }\n    \n    func authInBrowser() {\n        let issuer = URL(string: kIssuer)\n        let redirectURI = URL(string: kRedirectURI)\n        \n        // discovers endpoints\n        OIDAuthorizationService.discoverConfiguration(forIssuer: issuer!, completion: {\n            (configuration, error) in\n            if configuration == nil {\n                print(\"Error retrieving discovery document: \\(error?.localizedDescription)\")\n                self.setGtmAuthorization(stauthorization: nil)\n                return\n            }\n            \n            print(\"Got configuration: \\(configuration!)\")\n            \n            // builds authentication request\n            let request: OIDAuthorizationRequest = OIDAuthorizationRequest.init(\n                configuration: configuration!,\n                clientId: self.kClientID,\n                scopes: self.scopes,\n                redirectURL: redirectURI!,\n                responseType: OIDResponseTypeCode,\n                additionalParameters: nil)\n            \n            // performs authentication request\n            let appDelegate: AppDelegate = UIApplication.shared.delegate as! AppDelegate\n            print(\"Initiating authorization request with scope: \\(request.scope!)\")\n            \n            appDelegate.currentAuthorizationFlow = OIDAuthState.authState(\n                byPresenting: request,\n                presenting: self,\n                callback: {\n                    (authState, error) in\n                    if authState != nil {\n                        let gauthorization: GTMAppAuthFetcherAuthorization = GTMAppAuthFetcherAuthorization(authState: authState!)\n                        self.setGtmAuthorization(stauthorization: gauthorization)\n                        print(\"Got authorization tokens. Access token: \\(authState?.lastTokenResponse?.accessToken)\")\n                    } else {\n                        self.setGtmAuthorization(stauthorization: nil)\n                        print(\"Authorization error: \\(error?.localizedDescription)\")\n                    }\n                    if let authorizer = self.service.authorizer,\n                        let canAuth = authorizer.canAuthorize, canAuth {\n                        self.callAppsScript()\n                    }\n            })\n        })\n    }\n    \n    func saveState() {\n        if authorization != nil {\n            if (authorization?.canAuthorize())! {\n                GTMAppAuthFetcherAuthorization.save(authorization!, toKeychainForName: \"authorization\")\n            } else {\n                GTMAppAuthFetcherAuthorization.removeFromKeychain(forName: \"authorization\")\n            }\n        } else {\n            GTMAppAuthFetcherAuthorization.removeFromKeychain(forName: \"authorization\")\n        }\n    }\n    \n    func loadState() {\n        if GTMAppAuthFetcherAuthorization(fromKeychainForName: \"authorization\") != nil {\n            let lauthorization: GTMAppAuthFetcherAuthorization = GTMAppAuthFetcherAuthorization(fromKeychainForName: \"authorization\")!\n            self.setGtmAuthorization(stauthorization: lauthorization)\n        }\n    }\n    \n    func setGtmAuthorization(stauthorization: GTMAppAuthFetcherAuthorization?) {\n        if authorization == stauthorization {\n            return\n        }\n        authorization = stauthorization\n        stateChanged()\n        service.authorizer = authorization\n    }\n    \n    func stateChanged() {\n        self.saveState()\n    }\n    \n    // Calls an Apps Script function to list the folders in the user's\n    // root Drive folder.\n    func callAppsScript() {\n        output.text = \"Getting folders...\"\n        let baseUrl = \"https://script.googleapis.com/v1/scripts/\\(kScriptId):run\"\n        let url = GTLUtilities.url(with: baseUrl, queryParameters: nil)\n        \n        // Create an execution request object.\n        let request = GTLObject()\n        request.setJSONValue(\"getFoldersUnderRoot\", forKey: \"function\")\n        \n        // Make the API request.\n        service.fetchObject(byInserting: request,\n                            for: url!,\n                            delegate: self,\n                            didFinish: #selector(displayResultWithTicket(ticket:finishedWithObject:error:)))\n    }\n    \n    // Displays the retrieved folders returned by the Apps Script function.\n    func displayResultWithTicket(ticket: GTLServiceTicket,\n                                 finishedWithObject object : GTLObject,\n                                 error : NSError?) {\n        if let error = error {\n            // The API encountered a problem before the script\n            // started executing.\n            showAlert(title: \"The API returned the error: \",\n                      message: error.localizedDescription)\n            return\n        }\n        \n        if let apiError = object.json[\"error\"] as? [String: AnyObject] {\n            // The API executed, but the script returned an error.\n            \n            // Extract the first (and only) set of error details and cast as\n            // a Dictionary. The values of this Dictionary are the script's\n            // 'errorMessage' and 'errorType', and an array of stack trace\n            // elements (which also need to be cast as Dictionaries).\n            let details = apiError[\"details\"] as! [[String: AnyObject]]\n            var errMessage = String(\n                format:\"Script error message: %@\\n\",\n                details[0][\"errorMessage\"] as! String)\n            \n            if let stacktrace =\n                details[0][\"scriptStackTraceElements\"] as? [[String: AnyObject]] {\n                // There may not be a stacktrace if the script didn't start\n                // executing.\n                for trace in stacktrace {\n                    let f = trace[\"function\"] as? String ?? \"Unknown\"\n                    let num = trace[\"lineNumber\"] as? Int ?? -1\n                    errMessage += \"\\t\\(f): \\(num)\\n\"\n                }\n            }\n            \n            // Set the output as the compiled error message.\n            output.text = errMessage\n        } else {\n            // The result provided by the API needs to be cast into the\n            // correct type, based upon what types the Apps Script function\n            // returns. Here, the function returns an Apps Script Object with\n            // String keys and values, so must be cast into a Dictionary\n            // (folderSet).\n            let response = object.json[\"response\"] as! [String: AnyObject]\n            let folderSet = response[\"result\"] as! [String: AnyObject]\n            if folderSet.count == 0 {\n                output.text = \"No folders returned!\\n\"\n            } else {\n                var folderString = \"Folders under your root folder:\\n\"\n                for (id, folder) in folderSet {\n                    folderString += \"\\t\\(folder) (\\(id))\\n\"\n                }\n                output.text = folderString\n            }\n        }\n    }\n    \n    // Helper for showing an alert\n    func showAlert(title : String, message: String) {\n        let alert = UIAlertController(\n            title: title,\n            message: message,\n            preferredStyle: UIAlertControllerStyle.alert\n        )\n        let ok = UIAlertAction(\n            title: \"OK\",\n            style: UIAlertActionStyle.default,\n            handler: nil\n        )\n        alert.addAction(ok)\n        present(alert, animated: true, completion: nil)\n    }\n    \n    override func didReceiveMemoryWarning() {\n        super.didReceiveMemoryWarning()\n        // Dispose of any resources that can be recreated.\n    }   \n}\n```\n\n\u8a8d\u8a3c\u90e8\u5206\u304c\u5225\u30b9\u30ec\u30c3\u30c9\u3067\u5b9f\u884c\u3055\u308c\u308b\u3088\u3046\u306b\u306a\u308b\u306e\u3067\u3001callAppsScript\u3092\u5b9f\u884c\u3059\u308b\u30bf\u30a4\u30df\u30f3\u30b0\u3092viewDidAppear\u306e\u30bf\u30a4\u30df\u30f3\u30b0\u304b\u3089\u8a8d\u8a3c\u51e6\u7406\u5f8c\u306b\u3057\u3066\u3044\u307e\u3059\u3002\n\nAppDelegate.swift\u306bAppAuth\u3092import\u3057\u3001AppDelegate\u30af\u30e9\u30b9\u306b\u4e0b\u8a18\u306e\u30b3\u30fc\u30c9\u3092\u8ffd\u52a0\u3057\u307e\u3059\u3002\n\n```swift:AppDelegate.swift\n    var currentAuthorizationFlow: OIDAuthorizationFlowSession?\n    \n    func application(_ app: UIApplication, open url: URL, options: [UIApplicationOpenURLOptionsKey : Any] = [:]) -> Bool {\n        if (currentAuthorizationFlow?.resumeAuthorizationFlow(with: url))! {\n            currentAuthorizationFlow = nil\n            return true\n        }\n        return false\n    }\n```\n\ninfo.plist\u306b\u4e0b\u8a18\u306e\u30b3\u30fc\u30c9\u3092\u8ffd\u52a0\u3057\u307e\u3059\u3002\uff08ID\u306f\u81ea\u8eab\u306e\u3082\u306e\u306b\u7f6e\u304d\u63db\u3048\u3066\u304f\u3060\u3055\u3044\u3002\uff09\n\n```xml:info.plist\n\t<key>CFBundleURLTypes</key>\n\t<array>\n\t\t<dict>\n\t\t\t<key>CFBundleTypeRole</key>\n\t\t\t<string>Editor</string>\n\t\t\t<key>CFBundleURLSchemes</key>\n\t\t\t<array>\n\t\t\t\t<string>com.googleusercontent.apps.YOUR_CLIENT</string>\n\t\t\t</array>\n\t\t</dict>\n\t</array>\n```\n\n\u305d\u306e\u4ed6\u3001GoogleAppsScript\u306f\u7279\u306b\u5909\u66f4\u306e\u5fc5\u8981\u306f\u3042\u308a\u307e\u305b\u3093\u3002\n\n", "tags": ["Swift", "Swift3.0", "GoogleAppsScript"]}