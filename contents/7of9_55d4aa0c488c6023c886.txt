{"context": "MicroZed Chronicles \u30ea\u30b9\u30c8 http://adiuvoengineering.com/?page_id=285\n@ Adam Taylor blog\nhttps://forums.xilinx.com/t5/Xcell-Daily-Blog/Adam-Taylor-s-MicroZed-Chronicles-Part-38-Answering-a-question/ba-p/479978\n\nIn this example, I show how to use the private interrupt. However the general concept is the same regardless of interrupt used. For this example, I will be using an EMIO GPIO pin connected via the PL, looped back and connected to the processor\u2019s interrupt pin. A simple software program can then demonstrate how an interrupt from the PL works.\n\n\nVivado\u4e0a\u306e\u4f5c\u696d\n\nThe first stage of this example is to enable the interrupts between the PL and PS and to enable the specific interrupt you wish to use.\n\nblog\u306e\u753b\u50cf\u306b\u304a\u3044\u3066\u306f Re-customize IP > Interrupt\u306b\u3066 PL-PS Interrupt > Core0_nRQ \u306b\u30c1\u30a7\u30c3\u30af\u3092\u3064\u3051\u3066\u3044\u308b\u3088\u3046\u3060\u3002\n\nThe second step is to enable a single-bit GPIO using the EMIO option.\n\nRe-customize IP > MIO Configuration > GPIO > EMIO GPIO (Width) \u30921\u306b\u3057\u3066\u3044\u308b\u3002\n\nXSDK\u4e0a\u306e\u4f5c\u696d\n\n\nDeclare the following header files: Platform.h, xparameters.h, Xscugic.h, Xil_Exceptions.h and xgpio.h. These header files will provide functions and macros that enable us to generate the example.\nDefine the generic interrupt controller and GPIO device ID and interrupt numbers along with the FPGA interrupt and pin numbers for the EMIO and push-button switch.\nDeclare and write a number of required functions:\n\n\nxgpio.h\u306f\u306a\u3044\u306e\u3067xgpiops.h\u3092\u4ee3\u308f\u308a\u306binclude\u3059\u308b\u3002\n\nInterrupt\u306e\u8a2d\u5b9a\n\nWhen setting up an interrupt in the Zynq we need to do the following things:\n\nInitialize the Interrupt controller.\nConnect the exception ID to the associated handler so that when an event occurs it can be run correctly.\nConnect the FPGA interrupt to the generic interrupt controller. This requires the pre-defined interrupt ID, the call-back handler (which is defined to identify the source of the interrupt), and the interrupt service routine to be run when the interrupt occurs.\nEnable the interrupt on the interrupt controller.\nEnable interrupts on the processor.\n\n\n\u77ed\u3044\u30b5\u30f3\u30d7\u30eb\u30b3\u30fc\u30c9\u304c\u3042\u308b\u3088\u3046\u306a\u306e\u3067\u6642\u9593\u304c\u78ba\u4fdd\u3067\u304d\u305f\u6642\u306b\u5b9f\u65bd\u3057\u3066\u307f\u3088\u3046\u3002\nMicroZed Chronicles \u30ea\u30b9\u30c8 http://adiuvoengineering.com/?page_id=285\n@ Adam Taylor blog\nhttps://forums.xilinx.com/t5/Xcell-Daily-Blog/Adam-Taylor-s-MicroZed-Chronicles-Part-38-Answering-a-question/ba-p/479978\n\n> In this example, I show how to use the private interrupt. However the general concept is the same regardless of interrupt used. For this example, I will be using an EMIO GPIO pin connected via the PL, looped back and connected to the processor\u2019s interrupt pin. A simple software program can then demonstrate how an interrupt from the PL works.\n\n### Vivado\u4e0a\u306e\u4f5c\u696d\n\n> The first stage of this example is to enable the interrupts between the PL and PS and to enable the specific interrupt you wish to use.\n\nblog\u306e\u753b\u50cf\u306b\u304a\u3044\u3066\u306f Re-customize IP > Interrupt\u306b\u3066 PL-PS Interrupt > Core0_nRQ \u306b\u30c1\u30a7\u30c3\u30af\u3092\u3064\u3051\u3066\u3044\u308b\u3088\u3046\u3060\u3002\n\n> The second step is to enable a single-bit GPIO using the EMIO option.\n\nRe-customize IP > MIO Configuration > GPIO > EMIO GPIO (Width) \u30921\u306b\u3057\u3066\u3044\u308b\u3002\n\n### XSDK\u4e0a\u306e\u4f5c\u696d\n\n> 1. Declare the following header files: Platform.h, xparameters.h, Xscugic.h, Xil_Exceptions.h and xgpio.h. These header files will provide functions and macros that enable us to generate the example.\n2. Define the generic interrupt controller and GPIO device ID and interrupt numbers along with the FPGA interrupt and pin numbers for the EMIO and push-button switch.\n3. Declare and write a number of required functions:\n\n<font color=red>xgpio.h\u306f\u306a\u3044\u306e\u3067xgpiops.h\u3092\u4ee3\u308f\u308a\u306binclude\u3059\u308b\u3002</font>\n\n\n### Interrupt\u306e\u8a2d\u5b9a\n\n> When setting up an interrupt in the Zynq we need to do the following things:\n\n> 1. Initialize the Interrupt controller.\n1. Connect the exception ID to the associated handler so that when an event occurs it can be run correctly.\n1. Connect the FPGA interrupt to the generic interrupt controller. This requires the pre-defined interrupt ID, the call-back handler (which is defined to identify the source of the interrupt), and the interrupt service routine to be run when the interrupt occurs.\n1. Enable the interrupt on the interrupt controller.\n1. Enable interrupts on the processor.\n\n\u77ed\u3044\u30b5\u30f3\u30d7\u30eb\u30b3\u30fc\u30c9\u304c\u3042\u308b\u3088\u3046\u306a\u306e\u3067\u6642\u9593\u304c\u78ba\u4fdd\u3067\u304d\u305f\u6642\u306b\u5b9f\u65bd\u3057\u3066\u307f\u3088\u3046\u3002\n\n\n", "tags": ["adamTaylor", "Primer"]}