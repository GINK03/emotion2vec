{"context": " More than 1 year has passed since last update.Searching algorithm is one of main areas of artificial intelligence. I introduce some basic algorithms and ideas to evaluate them.\n\nFour properties to compare searching algorithms\n\nComplete\nWhether it always finds a solution if one exists.\ni.e.\n- BFS\n- Uniform-cost search (if cost is positive)\n\nare 'complete' searching algorithms because they can check every node in a map.\n\n\n\nTime Complexity\nNumber of nodes generated or expanded.\n\nSpace\nMaximum number of nodes in memory.\n\n Optimality\nWhether it always finds least-cost solution\n\nMeasures\nTime and space complexity are measured in terms of\n\nmaximum branching factor of the search tree (mentioned by b)\ndepth of the least-cost solution (d)\nmaximum depth of the state space (m)\n\n\nSearching Algorithms\n\nBreadth-first search\nUniform-cost search\nDepth-first search\nDepth-limited search\nIterative deepening search\n\n\nBreadth-first search (BFS)\n\nComplete?\nYes (if b is finite)\n\n Time?\n1 + b + b^2 + b^3 + ... + b(b^d-1)= O(b^{d+1})\n1+b+b2+b3+...+b(bd\u22121)=O(bd+1){1 + b + b^2 + b^3 + ... + b(b^d-1)= O(b^{d+1})\n}\nSum up to power of d+1 not d because you can detect finishing state when the node get enqueued from the queue. That means that you have to check upto nodes located at next level of the least cost node.\n\nSpace?\nO(b^{d+1})\nO(bd+1){O(b^{d+1})\n}\nKeep every nodes in the fringe in a queue. Worst case is the most expanded deepest level, which has b^(d+1) nodes on it.\n=> Space is the big problem about BFS. It can easily generate nodes at 100MB/sec so 24 hours = 8460GB for example.\n\nOptimal?\nYes if cost is constanct per step, like cost = 1 per step.\nBut not optimal in general.\n\nUniform-cost search\nExpand least-cost unexpanded node.\n\nImplementation\nfringe = queue ordered by path cost, lowest first.\n\nIf step costs all equal, it's equibalent to bfs.\n\n Complete?\nYes\n\nTime?\nIf C is destination cost and each step gets \u03b5 closer to the goal, the number of steps you need to take is given by C/\u03b5+1. The reason for the +1 is that you start at distance 0 and end at C/\u03b5, so you take steps at distances\n0, \u03b5, 2\u03b5, 3\u03b5, ..., (C/\u03b5)\u03b5\n\nAnd there are 1+C/\u03b5 total steps here. Therefore, there are 1+C/\u03b5 layers, and so the toal number of states you need to expand is O(b1+C/\u03b5)O(b^{1+C/\u03b5}).\n\n Space?\nsame logic as above O(b1+C/\u03b5)O(b^{1+C/\u03b5})\nso depends on number of nodes with less cost than targetted solution's cost.\n\nOptimal?\nYes, because nodes expand in increasing order of g(n) where g(n) is cost taken upto node n.\n\nDepth-first search (DFS)\n\n Complete?\nNo, it may falil in infinite-depth spaces with loops. Need to modify to avoid repeated states along path so that it becomes finite space.\n\nTime?\nO(bm)O(b^m). It will be terrible if m is larger than d. But if solutions are dense(m is small), may be much faster than breadth-first.\n\nSpace?\nO(bm)O(bm). its liniear space.\n=> This is better than bfs.\n\nOptimal?\nNo.\n\nIterative deepening search\nIterate depth-limited search from root until it finds the solution.\n\nComplete?\nYes\n\n Time?\nO(bd)O(b^d)\n\n Space\nO(bd)O(bd)\n\nOptimal?\nYes, if step cost = 1 (constant). Can be modified to explore uniform-cost tree.\nIDS does better because other nodes at depth d are not expanded.\nBFS can be modified to apply goal test when a node is generated. (instead of when node is enqueued.)\n=> it takes benefits from both of bfs and dfs. Like bfs, it is optimal, and like dfs, it have space complexity of linear.\n\n\nImformed search algorithms\n\nGreedy Search\nEvalation function h(n) (h from heuristic)\n=> estimate of cost from n to the closest goal.\nGreedy search expands the node that appears to be closest to goal.\n\n Complete?\nNo, can get stuck in loops\n\nTime?\nO(bm)O(b^m), but good heuristic can give dramatic improvement.\n\nSpace?\nO(bm)O(b^m), keeps all nodes in memory\n\nOptimal?\nNo.\n=> Greedy algorithm considers only heuristic distance from current node to goal, not thinking about how much cost it has taken to current node.\n=> So A* search is here.\n\nA* search\nIdea: Avoid expanding paths that are already expensive.\nEvaluation function f(n) = g(n) + h(n)\ng(n) = cost so far to reach n\nh(n) = estimated cost to goal from n\nf(n) = estimated total cost of path through n to goal\nA* search uses an admissible heuristic\ni.e., h(n) <= h*(n) where h*(n) is the true cost from n. Also require h(n) >= 0, so h(G) = 0 for any goal G.\nTheorem: A* search is optimal.\n\nDominate\nIf there is two heuristic values h1 and h2 (both admissible) and h2(n) >= h1(n) for all, then h2 dominates h1 and is better for search.\n\nPlanning to solve problems by implementing every algorithm above for each.\n\nSearching algorithm is one of main areas of artificial intelligence. I introduce some basic algorithms and ideas to evaluate them.\n\n# Four properties to compare searching algorithms\n\n## Complete\n\nWhether it always finds a solution if one exists.\n\n```\ni.e.\n- BFS\n- Uniform-cost search (if cost is positive)\n\nare 'complete' searching algorithms because they can check every node in a map.\n\n```\n\n## Time Complexity\n\nNumber of nodes generated or expanded.\n\n## Space\n\nMaximum number of nodes in memory.\n\n##\u0010 Optimality\n\nWhether it always finds least-cost solution\n\n## Measures\n\nTime and space complexity are measured in terms of\n\n- maximum branching factor of the search tree (mentioned by ```b```)\n- depth of the least-cost solution (```d```)\n- maximum depth of the state space (```m```)\n\n\n# Searching Algorithms\n\n- Breadth-first search\n- Uniform-cost search\n- Depth-first search\n- Depth-limited search\n- Iterative deepening search\n\n## Breadth-first search (BFS)\n\n### Complete?\nYes (if ```b``` is finite)\n\n###\u0010 Time?\n\n```math\n1 + b + b^2 + b^3 + ... + b(b^d-1)= O(b^{d+1})\n```\n\nSum up to power of ```d+1``` not ```d``` because you can detect finishing state when the node get enqueued from the queue. That means that you have to check upto nodes located at next level of the least cost node.\n\n### Space?\n\n```math\nO(b^{d+1})\n```\n\nKeep every nodes in the fringe in a queue. Worst case is the most expanded deepest level, which has b^(d+1) nodes on it.\n\n=> Space is the big problem about BFS. It can easily generate nodes at 100MB/sec so 24 hours = 8460GB for example.\n\n### Optimal?\n\nYes if cost is constanct per step, like cost = 1 per step.\nBut not optimal in general.\n\n## Uniform-cost search\n\nExpand least-cost unexpanded node.\n\n### Implementation\n\n```\nfringe = queue ordered by path cost, lowest first.\n```\n\nIf step costs all equal, it's equibalent to bfs.\n\n###\u0010 Complete?\n\nYes\n\n### Time?\n\nIf C is destination cost and each step gets \u03b5 closer to the goal, the number of steps you need to take is given by ```C/\u03b5+1```. The reason for the +1 is that you start at distance 0 and end at C/\u03b5, so you take steps at distances\n\n```\n0, \u03b5, 2\u03b5, 3\u03b5, ..., (C/\u03b5)\u03b5\n```\n\nAnd there are 1+C/\u03b5 total steps here. Therefore, there are 1+C/\u03b5 layers, and so the toal number of states you need to expand is $O(b^{1+C/\u03b5})$.\n\n###\u0010 Space?\n\nsame logic as above $O(b^{1+C/\u03b5})$\n\nso depends on number of nodes with less cost than targetted solution's cost.\n\n### Optimal?\n\nYes, because nodes expand in increasing order of g(n) where g(n) is cost taken upto node n.\n\n## Depth-first search (DFS)\n\n###\u0010 Complete?\n\nNo, it may falil in infinite-depth spaces with loops. Need to modify to avoid repeated states along path so that it becomes finite space.\n\n### Time?\n\n$O(b^m)$. It will be terrible if m is larger than d. But if solutions are dense(m is small), may be much faster than breadth-first.\n\n### Space?\n\n$O(bm)$. its liniear space.\n\n=> This is better than bfs.\n\n### Optimal?\n\nNo.\n\n## Iterative deepening search\n\nIterate depth-limited search from root until it finds the solution.\n\n### Complete?\n\nYes\n\n###\u0010 Time?\n\n$O(b^d)$\n\n###\u0010 Space\n\n$O(bd)$\n\n### Optimal?\n\nYes, if step cost = 1 (constant). Can be modified to explore uniform-cost tree.\n\nIDS does better because other nodes at depth d are not expanded.\nBFS can be modified to apply goal test when a node is generated. (instead of when node is enqueued.)\n\n=> it takes benefits from both of bfs and dfs. Like bfs, it is optimal, and like dfs, it have space complexity of linear.\n\n![kobito.1435576269.883175.png](https://qiita-image-store.s3.amazonaws.com/0/71621/5993271c-cc98-b4bf-9d8c-d3f6311e6d2a.png \"kobito.1435576269.883175.png\")\n\n\n# Imformed search algorithms\n\n## Greedy Search\n\nEvalation function h(n) (h from heuristic)\n=> estimate of cost from n to the closest goal.\n\n\u0010Greedy search expands the node that appears to be closest to goal.\n\n###\u0010 Complete?\n\nNo, can get stuck in loops\n\n### Time?\n\n$O(b^m)$, but good heuristic can give dramatic improvement.\n\n### Space?\n\n$O(b^m)$, keeps all nodes in memory\n\n### Optimal?\n\nNo.\n\n=> Greedy algorithm considers only heuristic distance from current node to goal, not thinking about how much cost it has taken to current node.\n=> So A* search is here.\n\n## A* search\n\nIdea: Avoid expanding paths that are already expensive.\n\nEvaluation function f(n) = g(n) + h(n)\n\ng(n) = cost so far to reach n\nh(n) = estimated cost to goal from n\nf(n) = estimated total cost of path through n to goal\n\nA* search uses an admissible heuristic\n\ni.e., h(n) <= h*(n) where h*(n) is the true cost from n. Also require h(n) >= 0, so h(G) = 0 for any goal G.\n\nTheorem: A* search is optimal.\n\n### Dominate\n\nIf there is two heuristic values h1 and h2 (both admissible) and h2(n) >= h1(n) for all, then h2 dominates h1 and is better for search.\n\n\n***\n\nPlanning to solve problems by implementing every algorithm above for each.\n", "tags": ["AI", "\u4eba\u5de5\u77e5\u80fd"]}