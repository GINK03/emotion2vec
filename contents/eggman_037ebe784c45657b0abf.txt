{"context": "RTL8821AS\u306e\u30c7\u30d0\u30a4\u30b9\u30c9\u30e9\u30a4\u30d0\u306e\u30bd\u30fc\u30b9\u30b3\u30fc\u30c9\u3092\u3061\u3087\u3063\u3068\u8aad\u3093\u3067\u307f\u307e\u3057\u305f\u3002\nRTL8821AS\u306fRealtek\u306e11ac\u5bfe\u5fdcWi-Fi\u30c1\u30c3\u30d7\u3067\u3059\u3002\u30db\u30b9\u30c8\u30a4\u30f3\u30bf\u30fc\u30d5\u30a7\u30a4\u30b9\u306fSDIO\u3067\u3059\u3002\nRealtek\u306eWi-Fi\u30c9\u30e9\u30a4\u30d0\u306fUSB\u304c\u57fa\u672c\u3067\u3001\u305d\u306e\u4ed6\u306e\u30db\u30b9\u30c8\u30a4\u30f3\u30bf\u30fc\u30d5\u30a7\u30a4\u30b9\u306e\u30c9\u30e9\u30a4\u30d0\u3067\u306fUSB\u3063\u307d\u304f\u30a2\u30af\u30bb\u30b9\u3067\u304d\u308b\u3088\u3046\u306b\u62bd\u8c61\u5316\u30ec\u30a4\u30e4\u3092\u8db3\u3057\u3066\u3044\u308b\u3068\u8003\u3048\u308b\u3068\u826f\u3044\u307f\u305f\u3044\u3067\u3059\u3002\n\n\u30bd\u30fc\u30b9\u30b3\u30fc\u30c9\n\nhttps://github.com/czc0713/imx6Q/tree/master/drivers/net/wireless/rtlwifi/rtl8821as\n\n\nSDIO\u306eport\n\n\u30b3\u30de\u30f3\u30c9\u3068\u30c7\u30fc\u30bf\u306e\u30d1\u30b9\u306e\u533a\u5225\u306f\u3001SDIO\u3067\u8aad\u307f\u66f8\u304d\u3059\u308b\u969b\u306e17bit\u306e\u30a2\u30c9\u30ec\u30b9\u60c5\u5831\u3067\u533a\u5225\u3059\u308b\u3002\n17bit\u306e\u30a2\u30c9\u30ec\u30b9\u306e\u4e0a\u4f4d\u3092\u4f7f\u3063\u3066port\u3068\u547c\u3076\u30b0\u30eb\u30fc\u30d7\u3092\u4f5c\u3063\u3066\u3044\u308b\u3002\n\u30bd\u30fc\u30b9\u30b3\u30fc\u30c9\u3067\u306fport\u6bce\u306bDeviceId\u3092\u5272\u308a\u5f53\u3066\u308b\u308b\u3002\n\n\nWLAN_TX_HIQ_DEVICE_ID \u30c7\u30fc\u30bf\u9001\u4fe1 high priority\nWLAN_TX_MIQ_DEVICE_ID \u30c7\u30fc\u30bf\u9001\u4fe1 middle priority\nWLAN_TX_LOQ_DEVICE_ID \u30c7\u30fc\u30bf\u9001\u4fe1 low priority\nSDIO_LOCAL_DEVICE_ID SDIO\u306e\u30ec\u30b8\u30b9\u30bf\u30a2\u30af\u30bb\u30b9\u7528\nWLAN_RX0FF_DEVICE_ID \u53d7\u4fe1\u7528\nWLAN_IOREG_DEVICE_ID \u30b3\u30de\u30f3\u30c9\u306a\u3069\u7528\n\n\n\n\nrtl8821as/include/hal_com_reg.h\n#define SDIO_LOCAL_DEVICE_ID                0   // 0b[16], 000b[15:13]\n#define WLAN_TX_HIQ_DEVICE_ID           4   // 0b[16], 100b[15:13]\n#define WLAN_TX_MIQ_DEVICE_ID       5   // 0b[16], 101b[15:13]\n#define WLAN_TX_LOQ_DEVICE_ID       6   // 0b[16], 110b[15:13]\n#define WLAN_RX0FF_DEVICE_ID            7   // 0b[16], 111b[15:13]\n#define WLAN_IOREG_DEVICE_ID            8   // 1b[16]\n\n\n\nDeviceId\u304b\u3089\u30a2\u30c9\u30ec\u30b9\u3078\u306e\u5909\u63db\n\n//\n// Description:\n//  The following mapping is for SDIO host local register space.\n//\n// Creadted by Roger, 2011.01.31.\n//\nstatic void HalSdioGetCmdAddr8821ASdio(\n    IN  PADAPTER            padapter,\n    IN  u8              DeviceID,\n    IN  u32             Addr,\n    OUT u32*                pCmdAddr\n    )\n{\n    switch (DeviceID)\n    {\n        case SDIO_LOCAL_DEVICE_ID:\n            *pCmdAddr = ((SDIO_LOCAL_DEVICE_ID << 13) | (Addr & SDIO_LOCAL_MSK));\n            break;\n\n        case WLAN_IOREG_DEVICE_ID:\n            *pCmdAddr = ((WLAN_IOREG_DEVICE_ID << 13) | (Addr & WLAN_IOREG_MSK));\n            break;\n\n        case WLAN_TX_HIQ_DEVICE_ID:\n            *pCmdAddr = ((WLAN_TX_HIQ_DEVICE_ID << 13) | (Addr & WLAN_FIFO_MSK));\n            break;\n\n        case WLAN_TX_MIQ_DEVICE_ID:\n            *pCmdAddr = ((WLAN_TX_MIQ_DEVICE_ID << 13) | (Addr & WLAN_FIFO_MSK));\n            break;\n\n        case WLAN_TX_LOQ_DEVICE_ID:\n            *pCmdAddr = ((WLAN_TX_LOQ_DEVICE_ID << 13) | (Addr & WLAN_FIFO_MSK));\n            break;\n\n        case WLAN_RX0FF_DEVICE_ID:\n            *pCmdAddr = ((WLAN_RX0FF_DEVICE_ID << 13) | (Addr & WLAN_RX0FF_MSK));\n            break;\n\n        default:\n            break;\n    }\n}\n\n\nQueueId\u3068DeviceId\u306e\u5909\u63db\u30c6\u30fc\u30d6\u30ebQueue2Pippe\u3092\u4f5c\u308b\nRtOutPipe\u306bDeviceId\u3092\u8a2d\u5b9a\u3059\u308b\u3002\n\n\nrtl8821as/hal/rtl8812a/sdio/sdio_halinit.c\nstatic void _InterfaceConfigure(PADAPTER padapter)\n{\n    PHAL_DATA_TYPE pHalData;\n    struct dvobj_priv *pdvobjpriv;\n    struct registry_priv *pregistrypriv;\n    u8 bWiFiConfig;\n\n\n    pHalData = GET_HAL_DATA(padapter);\n    pdvobjpriv = adapter_to_dvobj(padapter);\n    pregistrypriv = &padapter->registrypriv;\n    bWiFiConfig = pregistrypriv->wifi_spec;\n\n    pdvobjpriv->RtOutPipe[0] = WLAN_TX_HIQ_DEVICE_ID;\n    pdvobjpriv->RtOutPipe[1] = WLAN_TX_MIQ_DEVICE_ID;\n    pdvobjpriv->RtOutPipe[2] = WLAN_TX_LOQ_DEVICE_ID;\n\n    if (bWiFiConfig)\n        pHalData->OutEpNumber = 2;\n    else\n        pHalData->OutEpNumber = SDIO_MAX_TX_QUEUE;\n\n    switch (pHalData->OutEpNumber)\n    {\n        case 3:\n            pHalData->OutEpQueueSel = TX_SELE_HQ | TX_SELE_LQ | TX_SELE_NQ;\n            break;\n        case 2:\n            pHalData->OutEpQueueSel = TX_SELE_HQ | TX_SELE_NQ;\n            break;\n        case 1:\n            pHalData->OutEpQueueSel = TX_SELE_HQ;\n            break;\n        default:\n            break;\n    }\n\n    Hal_MappingOutPipe(padapter, pHalData->OutEpNumber);\n\n    pHalData->SdioRxFIFOCnt = 0;\n}\n\n\n\nrtl8821as/hal/hal_com.c\nstatic VOID _ThreeOutPipeMapping(\n    IN  PADAPTER    pAdapter,\n    IN  BOOLEAN     bWIFICfg\n    )\n{\n    struct dvobj_priv   *pdvobjpriv = adapter_to_dvobj(pAdapter);\n\n    if(bWIFICfg){//for WMM\n\n        //  BK,     BE,     VI,     VO,     BCN,    CMD,MGT,HIGH,HCCA \n        //{  1,     2,  1,  0,  0,  0,  0,  0,      0   };\n        //0:H, 1:N, 2:L \n\n        pdvobjpriv->Queue2Pipe[0] = pdvobjpriv->RtOutPipe[0];//VO\n        pdvobjpriv->Queue2Pipe[1] = pdvobjpriv->RtOutPipe[1];//VI\n        pdvobjpriv->Queue2Pipe[2] = pdvobjpriv->RtOutPipe[2];//BE\n        pdvobjpriv->Queue2Pipe[3] = pdvobjpriv->RtOutPipe[1];//BK\n\n        pdvobjpriv->Queue2Pipe[4] = pdvobjpriv->RtOutPipe[0];//BCN\n        pdvobjpriv->Queue2Pipe[5] = pdvobjpriv->RtOutPipe[0];//MGT\n        pdvobjpriv->Queue2Pipe[6] = pdvobjpriv->RtOutPipe[0];//HIGH\n        pdvobjpriv->Queue2Pipe[7] = pdvobjpriv->RtOutPipe[0];//TXCMD\n\n    }\n    else{//typical setting\n\n\n        //  BK,     BE,     VI,     VO,     BCN,    CMD,MGT,HIGH,HCCA \n        //{  2,     2,  1,  0,  0,  0,  0,  0,      0   };          \n        //0:H, 1:N, 2:L \n\n        pdvobjpriv->Queue2Pipe[0] = pdvobjpriv->RtOutPipe[0];//VO\n        pdvobjpriv->Queue2Pipe[1] = pdvobjpriv->RtOutPipe[1];//VI\n        pdvobjpriv->Queue2Pipe[2] = pdvobjpriv->RtOutPipe[2];//BE\n        pdvobjpriv->Queue2Pipe[3] = pdvobjpriv->RtOutPipe[2];//BK\n\n        pdvobjpriv->Queue2Pipe[4] = pdvobjpriv->RtOutPipe[0];//BCN\n        pdvobjpriv->Queue2Pipe[5] = pdvobjpriv->RtOutPipe[0];//MGT\n        pdvobjpriv->Queue2Pipe[6] = pdvobjpriv->RtOutPipe[0];//HIGH\n        pdvobjpriv->Queue2Pipe[7] = pdvobjpriv->RtOutPipe[0];//TXCMD    \n    }\n\n}\n\n\n\n\u30de\u30af\u30ed\u3067\u53c2\u7167\n\n#define ffaddr2deviceId(pdvobj, addr)   (pdvobj->Queue2Pipe[addr])\n\n\n\u30b3\u30de\u30f3\u30c9\u9001\u4fe1\n\n\u30b3\u30de\u30f3\u30c9\u9001\u4fe1\u306e\u7a7a\u304d\u304c\u3042\u308b\u304b\u78ba\u8a8d\nrtw_write8()\u3068rtw_write32()\u3067\u30b3\u30de\u30f3\u30c9\u9001\u4fe1\n\n\n/*****************************************\n* H2C Msg format :\n* 0x1DF - 0x1D0\n*| 31 - 8   | 7-5    4 - 0  |\n*| h2c_msg  |Class_ID CMD_ID    |\n*\n* Extend 0x1FF - 0x1F0\n*|31 - 0      |\n*|ext_msg|\n******************************************/\ns32 FillH2CCmd_8812(PADAPTER padapter, u8 ElementID, u32 CmdLen, u8 *pCmdBuffer)\n{\n    u8 h2c_box_num;\n    u32 msgbox_addr;\n    u32 msgbox_ex_addr;\n    HAL_DATA_TYPE *pHalData = GET_HAL_DATA(padapter);\n    u8 cmd_idx,ext_cmd_len;\n    u32 h2c_cmd = 0;\n    u32 h2c_cmd_ex = 0;\n    s32 ret = _FAIL;\n\n_func_enter_;\n\n    padapter = GET_PRIMARY_ADAPTER(padapter);       \n    pHalData = GET_HAL_DATA(padapter);\n\n\n    if(padapter->bFWReady == _FALSE)\n    {\n        //DBG_8192C(\"FillH2CCmd_8812(): return H2C cmd because fw is not ready\\n\");\n        return ret;\n    }\n\n    _enter_critical_mutex(&(adapter_to_dvobj(padapter)->h2c_fwcmd_mutex), NULL);\n\n\n    if (!pCmdBuffer) {\n        goto exit;\n    }\n    if (CmdLen > RTL8812_MAX_CMD_LEN) {\n        goto exit;\n    }\n    if (rtw_is_surprise_removed(padapter))\n        goto exit;\n\n    //pay attention to if  race condition happened in  H2C cmd setting.\n    do{\n        h2c_box_num = pHalData->LastHMEBoxNum;\n\n        if(!_is_fw_read_cmd_down(padapter, h2c_box_num)){\n            DBG_8192C(\" fw read cmd failed...\\n\");\n            goto exit;\n        }\n\n        *(u8*)(&h2c_cmd) = ElementID;\n\n        if(CmdLen<=3)\n        {\n            _rtw_memcpy((u8*)(&h2c_cmd)+1, pCmdBuffer, CmdLen );\n        }\n        else{           \n            _rtw_memcpy((u8*)(&h2c_cmd)+1, pCmdBuffer,3);\n            ext_cmd_len = CmdLen-3; \n            _rtw_memcpy((u8*)(&h2c_cmd_ex), pCmdBuffer+3,ext_cmd_len );\n\n            //Write Ext command\n            msgbox_ex_addr = REG_HMEBOX_EXT0_8812 + (h2c_box_num *RTL8812_EX_MESSAGE_BOX_SIZE);\n            #ifdef CONFIG_H2C_EF\n            for(cmd_idx=0;cmd_idx<ext_cmd_len;cmd_idx++ ){\n                rtw_write8(padapter,msgbox_ex_addr+cmd_idx,*((u8*)(&h2c_cmd_ex)+cmd_idx));\n            }\n            #else\n            h2c_cmd_ex = le32_to_cpu( h2c_cmd_ex );\n            rtw_write32(padapter, msgbox_ex_addr, h2c_cmd_ex);\n            #endif\n        }\n        // Write command\n        msgbox_addr =REG_HMEBOX_0 + (h2c_box_num *RTL8812_MESSAGE_BOX_SIZE);\n        #ifdef CONFIG_H2C_EF\n        for(cmd_idx=0;cmd_idx<RTL8812_MESSAGE_BOX_SIZE;cmd_idx++ ){\n            rtw_write8(padapter,msgbox_addr+cmd_idx,*((u8*)(&h2c_cmd)+cmd_idx));\n        }\n        #else\n        h2c_cmd = le32_to_cpu( h2c_cmd );\n        rtw_write32(padapter,msgbox_addr, h2c_cmd);\n        #endif\n\n        //DBG_871X(\"MSG_BOX:%d,CmdLen(%d), reg:0x%x =>h2c_cmd:0x%x, reg:0x%x =>h2c_cmd_ex:0x%x ..\\n\"\n        //  ,pHalData->LastHMEBoxNum ,CmdLen,msgbox_addr,h2c_cmd,msgbox_ex_addr,h2c_cmd_ex);\n\n        pHalData->LastHMEBoxNum = (h2c_box_num+1) % RTL8812_MAX_H2C_BOX_NUMS;\n\n    }while(0);\n\n    ret = _SUCCESS;\n\nexit:\n\n    _exit_critical_mutex(&(adapter_to_dvobj(padapter)->h2c_fwcmd_mutex), NULL); \n\n_func_exit_;\n\n    return ret;\n}\n\n\n\n\u30c7\u30fc\u30bf\u9001\u4fe1\n\nrtw_write_port()\u3067\u691c\u7d22\u3059\u308b\u3068\u3001\u9001\u4fe1\u3057\u3066\u3044\u308b\u7b87\u6240\u306f\u30c7\u30fc\u30bf\u9001\u4fe1\u3068\u30de\u30cd\u30fc\u30b8\u30e1\u30f3\u30c8\u30d5\u30ec\u30fc\u30e0\u9001\u4fe1\u306e\uff12\u7b87\u6240\u304c\u898b\u3064\u304b\u308b\u3002\n\u9001\u4fe1\u30c7\u30fc\u30bf\u30ad\u30e5\u30fc pxmitpriv\u304b\u3089\u9001\u4fe1\u30c7\u30fc\u30bf\u3092\u53d6\u308a\u51fa\u3059\u3002\n\u9001\u4fe1\u30c7\u30fc\u30bf\u306edeviceId\u3092\u898b\u3066\u3069\u306e\u30ad\u30e5\u30fc\u306b\u3059\u308b\u304b\u9078\u629e\u3057\u3066PageIdx\u3092\u8a2d\u5b9a\nrtw_hal_sdio_query_tx_freepage\uff08\uff09\u3067hardware tx fifo\u306e\u7a7a\u304d\u3092\u78ba\u8a8d\nrtw_sdio_wait_enough_TxOQT_space()\u3067\u7a7a\u304d\u306e\u78ba\u8a8d\nrtw_write_port()\u3067SDIO\u7d4c\u7531\u3067\u30c7\u30fc\u30bf\u9001\u4fe1\n\n/*\n * Dequeue xmit buffer and send to hardware\n *\n * Return:\n *  _TRUE   queue is empty, nothing to be send to HW\n *  _FALSE  queue is NOT empty\n */\nstatic s32 _dequeue_writeport(PADAPTER padapter)\n{\n    struct mlme_priv *pmlmepriv;\n    struct xmit_priv *pxmitpriv;\n    struct dvobj_priv *pdvobjpriv;\n    struct xmit_buf *pxmitbuf;\n    u8  PageIdx = 0;\n    u32 deviceId;\n#ifdef CONFIG_SDIO_TX_ENABLE_AVAL_INT\n    u8  bUpdatePageNum = _FALSE;\n#else\n    u32 polling_num = 0;\n#endif\n\n\n    pmlmepriv = &padapter->mlmepriv;\n    pxmitpriv = &padapter->xmitpriv;\n    pdvobjpriv = adapter_to_dvobj(padapter);\n\n    if (rtw_xmit_ac_blocked(padapter) == _TRUE)\n        pxmitbuf = dequeue_pending_xmitbuf_under_survey(pxmitpriv);\n    else\n        pxmitbuf = dequeue_pending_xmitbuf(pxmitpriv);\n\n    if (pxmitbuf == NULL)\n        return _TRUE;\n\n    deviceId = ffaddr2deviceId(pdvobjpriv, pxmitbuf->ff_hwaddr);\n\n    // translate fifo addr to queue index\n    switch (deviceId) {\n        case WLAN_TX_HIQ_DEVICE_ID:\n                PageIdx = HI_QUEUE_IDX;\n                break;\n\n        case WLAN_TX_MIQ_DEVICE_ID:\n                PageIdx = MID_QUEUE_IDX;\n                break;\n\n        case WLAN_TX_LOQ_DEVICE_ID:\n                PageIdx = LOW_QUEUE_IDX;\n                break;\n    }\n\nquery_free_page:\n    /* check if hardware tx fifo page is enough */\n    if (_FALSE == rtw_hal_sdio_query_tx_freepage(padapter, PageIdx, pxmitbuf->pg_num)) {\n#ifdef CONFIG_SDIO_TX_ENABLE_AVAL_INT\n        if (!bUpdatePageNum) {\n            // Total number of page is NOT available, so update current FIFO status\n            HalQueryTxBufferStatus8821AS(padapter);\n            bUpdatePageNum = _TRUE;\n            goto query_free_page;\n        } else {\n            bUpdatePageNum = _FALSE;\n            enqueue_pending_xmitbuf_to_head(pxmitpriv, pxmitbuf);\n            return _TRUE;\n        }\n#else //CONFIG_SDIO_TX_ENABLE_AVAL_INT\n        polling_num++;\n        if ((polling_num % 0x7F) == 0) {//or 80\n            //DBG_871X(\"%s: FIFO starvation!(%d) len=%d agg=%d page=(R)%d(A)%d\\n\",\n            //  __func__, n, pxmitbuf->len, pxmitbuf->agg_num, pframe->pg_num, freePage[PageIdx] + freePage[PUBLIC_QUEUE_IDX]);\n            rtw_msleep_os(1);\n        }\n\n        // Total number of page is NOT available, so update current FIFO status\n        HalQueryTxBufferStatus8821AS(padapter);\n        goto query_free_page;\n#endif //CONFIG_SDIO_TX_ENABLE_AVAL_INT\n    }\n\n    if (RTW_CANNOT_RUN(padapter)) {\n        DBG_8192C(\"%s: Removed=%s Stopped=%s, goto free xmitbuf!\\n\"\n            , __func__\n            , rtw_is_surprise_removed(padapter)?\"True\":\"False\"\n            , rtw_is_drv_stopped(padapter)?\"True\":\"False\");\n        goto free_xmitbuf;\n    }\n\n\n    if (rtw_sdio_wait_enough_TxOQT_space(padapter, pxmitbuf->agg_num) == _FALSE) \n    {\n        goto free_xmitbuf;\n    }\n\n    rtw_write_port(padapter, deviceId, pxmitbuf->len, (u8 *)pxmitbuf);\n\n    rtw_hal_sdio_update_tx_freepage(padapter, PageIdx, pxmitbuf->pg_num);\n\nfree_xmitbuf:\n    //rtw_free_xmitframe(pxmitpriv, pframe);\n    //pxmitbuf->priv_data = NULL;\n    rtw_free_xmitbuf(pxmitpriv, pxmitbuf);\n\n#ifdef CONFIG_SDIO_TX_TASKLET\n    tasklet_hi_schedule(&pxmitpriv->xmit_tasklet);\n#endif\n\n    return _FAIL;\n}\n\n\nRTL8821AS\u306e\u30c7\u30d0\u30a4\u30b9\u30c9\u30e9\u30a4\u30d0\u306e\u30bd\u30fc\u30b9\u30b3\u30fc\u30c9\u3092\u3061\u3087\u3063\u3068\u8aad\u3093\u3067\u307f\u307e\u3057\u305f\u3002\n\nRTL8821AS\u306fRealtek\u306e11ac\u5bfe\u5fdcWi-Fi\u30c1\u30c3\u30d7\u3067\u3059\u3002\u30db\u30b9\u30c8\u30a4\u30f3\u30bf\u30fc\u30d5\u30a7\u30a4\u30b9\u306fSDIO\u3067\u3059\u3002\n\nRealtek\u306eWi-Fi\u30c9\u30e9\u30a4\u30d0\u306fUSB\u304c\u57fa\u672c\u3067\u3001\u305d\u306e\u4ed6\u306e\u30db\u30b9\u30c8\u30a4\u30f3\u30bf\u30fc\u30d5\u30a7\u30a4\u30b9\u306e\u30c9\u30e9\u30a4\u30d0\u3067\u306fUSB\u3063\u307d\u304f\u30a2\u30af\u30bb\u30b9\u3067\u304d\u308b\u3088\u3046\u306b\u62bd\u8c61\u5316\u30ec\u30a4\u30e4\u3092\u8db3\u3057\u3066\u3044\u308b\u3068\u8003\u3048\u308b\u3068\u826f\u3044\u307f\u305f\u3044\u3067\u3059\u3002\n\n# \u30bd\u30fc\u30b9\u30b3\u30fc\u30c9\n* https://github.com/czc0713/imx6Q/tree/master/drivers/net/wireless/rtlwifi/rtl8821as\n\n# SDIO\u306eport\n* \u30b3\u30de\u30f3\u30c9\u3068\u30c7\u30fc\u30bf\u306e\u30d1\u30b9\u306e\u533a\u5225\u306f\u3001SDIO\u3067\u8aad\u307f\u66f8\u304d\u3059\u308b\u969b\u306e17bit\u306e\u30a2\u30c9\u30ec\u30b9\u60c5\u5831\u3067\u533a\u5225\u3059\u308b\u3002\n* 17bit\u306e\u30a2\u30c9\u30ec\u30b9\u306e\u4e0a\u4f4d\u3092\u4f7f\u3063\u3066port\u3068\u547c\u3076\u30b0\u30eb\u30fc\u30d7\u3092\u4f5c\u3063\u3066\u3044\u308b\u3002\n* \u30bd\u30fc\u30b9\u30b3\u30fc\u30c9\u3067\u306fport\u6bce\u306bDeviceId\u3092\u5272\u308a\u5f53\u3066\u308b\u308b\u3002\n * WLAN_TX_HIQ_DEVICE_ID \u30c7\u30fc\u30bf\u9001\u4fe1 high priority\n * WLAN_TX_MIQ_DEVICE_ID \u30c7\u30fc\u30bf\u9001\u4fe1 middle priority\n * WLAN_TX_LOQ_DEVICE_ID \u30c7\u30fc\u30bf\u9001\u4fe1 low priority\n * SDIO_LOCAL_DEVICE_ID SDIO\u306e\u30ec\u30b8\u30b9\u30bf\u30a2\u30af\u30bb\u30b9\u7528\n * WLAN_RX0FF_DEVICE_ID \u53d7\u4fe1\u7528\n * WLAN_IOREG_DEVICE_ID \u30b3\u30de\u30f3\u30c9\u306a\u3069\u7528\n\n```c:rtl8821as/include/hal_com_reg.h\n#define SDIO_LOCAL_DEVICE_ID           \t\t0\t// 0b[16], 000b[15:13]\n#define WLAN_TX_HIQ_DEVICE_ID\t\t\t4\t// 0b[16], 100b[15:13]\n#define WLAN_TX_MIQ_DEVICE_ID \t\t5\t// 0b[16], 101b[15:13]\n#define WLAN_TX_LOQ_DEVICE_ID \t\t6\t// 0b[16], 110b[15:13]\n#define WLAN_RX0FF_DEVICE_ID \t\t\t7\t// 0b[16], 111b[15:13]\n#define WLAN_IOREG_DEVICE_ID \t\t\t8\t// 1b[16]\n```\n\n* DeviceId\u304b\u3089\u30a2\u30c9\u30ec\u30b9\u3078\u306e\u5909\u63db\n\n```c\n//\n// Description:\n//\tThe following mapping is for SDIO host local register space.\n//\n// Creadted by Roger, 2011.01.31.\n//\nstatic void HalSdioGetCmdAddr8821ASdio(\n\tIN\tPADAPTER\t\t\tpadapter,\n\tIN \tu8\t\t\t\tDeviceID,\n\tIN\tu32\t\t\t\tAddr,\n\tOUT\tu32*\t\t\t\tpCmdAddr\n\t)\n{\n\tswitch (DeviceID)\n\t{\n\t\tcase SDIO_LOCAL_DEVICE_ID:\n\t\t\t*pCmdAddr = ((SDIO_LOCAL_DEVICE_ID << 13) | (Addr & SDIO_LOCAL_MSK));\n\t\t\tbreak;\n\n\t\tcase WLAN_IOREG_DEVICE_ID:\n\t\t\t*pCmdAddr = ((WLAN_IOREG_DEVICE_ID << 13) | (Addr & WLAN_IOREG_MSK));\n\t\t\tbreak;\n\n\t\tcase WLAN_TX_HIQ_DEVICE_ID:\n\t\t\t*pCmdAddr = ((WLAN_TX_HIQ_DEVICE_ID << 13) | (Addr & WLAN_FIFO_MSK));\n\t\t\tbreak;\n\n\t\tcase WLAN_TX_MIQ_DEVICE_ID:\n\t\t\t*pCmdAddr = ((WLAN_TX_MIQ_DEVICE_ID << 13) | (Addr & WLAN_FIFO_MSK));\n\t\t\tbreak;\n\n\t\tcase WLAN_TX_LOQ_DEVICE_ID:\n\t\t\t*pCmdAddr = ((WLAN_TX_LOQ_DEVICE_ID << 13) | (Addr & WLAN_FIFO_MSK));\n\t\t\tbreak;\n\n\t\tcase WLAN_RX0FF_DEVICE_ID:\n\t\t\t*pCmdAddr = ((WLAN_RX0FF_DEVICE_ID << 13) | (Addr & WLAN_RX0FF_MSK));\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tbreak;\n\t}\n}\n```\n\n* QueueId\u3068DeviceId\u306e\u5909\u63db\u30c6\u30fc\u30d6\u30ebQueue2Pippe\u3092\u4f5c\u308b\n* RtOutPipe\u306bDeviceId\u3092\u8a2d\u5b9a\u3059\u308b\u3002\n\n```c:rtl8821as/hal/rtl8812a/sdio/sdio_halinit.c\nstatic void _InterfaceConfigure(PADAPTER padapter)\n{\n\tPHAL_DATA_TYPE pHalData;\n\tstruct dvobj_priv *pdvobjpriv;\n\tstruct registry_priv *pregistrypriv;\n\tu8 bWiFiConfig;\n\n\n\tpHalData = GET_HAL_DATA(padapter);\n\tpdvobjpriv = adapter_to_dvobj(padapter);\n\tpregistrypriv = &padapter->registrypriv;\n\tbWiFiConfig\t= pregistrypriv->wifi_spec;\n\n\tpdvobjpriv->RtOutPipe[0] = WLAN_TX_HIQ_DEVICE_ID;\n\tpdvobjpriv->RtOutPipe[1] = WLAN_TX_MIQ_DEVICE_ID;\n\tpdvobjpriv->RtOutPipe[2] = WLAN_TX_LOQ_DEVICE_ID;\n\n\tif (bWiFiConfig)\n\t\tpHalData->OutEpNumber = 2;\n\telse\n\t\tpHalData->OutEpNumber = SDIO_MAX_TX_QUEUE;\n\n\tswitch (pHalData->OutEpNumber)\n\t{\n\t\tcase 3:\n\t\t\tpHalData->OutEpQueueSel = TX_SELE_HQ | TX_SELE_LQ | TX_SELE_NQ;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tpHalData->OutEpQueueSel = TX_SELE_HQ | TX_SELE_NQ;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tpHalData->OutEpQueueSel = TX_SELE_HQ;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t}\n\n\tHal_MappingOutPipe(padapter, pHalData->OutEpNumber);\n\n\tpHalData->SdioRxFIFOCnt = 0;\n}\n```\n\n\n```c:rtl8821as/hal/hal_com.c\nstatic VOID _ThreeOutPipeMapping(\n\tIN\tPADAPTER\tpAdapter,\n\tIN\tBOOLEAN\t \tbWIFICfg\n\t)\n{\n\tstruct dvobj_priv\t*pdvobjpriv = adapter_to_dvobj(pAdapter);\n\n\tif(bWIFICfg){//for WMM\n\t\t\n\t\t//\tBK, \tBE, \tVI, \tVO, \tBCN,\tCMD,MGT,HIGH,HCCA \n\t\t//{  1, \t2, \t1, \t0, \t0, \t0, \t0, \t0, \t\t0\t};\n\t\t//0:H, 1:N, 2:L \n\t\t\n\t\tpdvobjpriv->Queue2Pipe[0] = pdvobjpriv->RtOutPipe[0];//VO\n\t\tpdvobjpriv->Queue2Pipe[1] = pdvobjpriv->RtOutPipe[1];//VI\n\t\tpdvobjpriv->Queue2Pipe[2] = pdvobjpriv->RtOutPipe[2];//BE\n\t\tpdvobjpriv->Queue2Pipe[3] = pdvobjpriv->RtOutPipe[1];//BK\n\t\t\n\t\tpdvobjpriv->Queue2Pipe[4] = pdvobjpriv->RtOutPipe[0];//BCN\n\t\tpdvobjpriv->Queue2Pipe[5] = pdvobjpriv->RtOutPipe[0];//MGT\n\t\tpdvobjpriv->Queue2Pipe[6] = pdvobjpriv->RtOutPipe[0];//HIGH\n\t\tpdvobjpriv->Queue2Pipe[7] = pdvobjpriv->RtOutPipe[0];//TXCMD\n\t\t\n\t}\n\telse{//typical setting\n\n\t\t\n\t\t//\tBK, \tBE, \tVI, \tVO, \tBCN,\tCMD,MGT,HIGH,HCCA \n\t\t//{  2, \t2, \t1, \t0, \t0, \t0, \t0, \t0, \t\t0\t};\t\t\t\n\t\t//0:H, 1:N, 2:L \n\t\t\n\t\tpdvobjpriv->Queue2Pipe[0] = pdvobjpriv->RtOutPipe[0];//VO\n\t\tpdvobjpriv->Queue2Pipe[1] = pdvobjpriv->RtOutPipe[1];//VI\n\t\tpdvobjpriv->Queue2Pipe[2] = pdvobjpriv->RtOutPipe[2];//BE\n\t\tpdvobjpriv->Queue2Pipe[3] = pdvobjpriv->RtOutPipe[2];//BK\n\t\t\n\t\tpdvobjpriv->Queue2Pipe[4] = pdvobjpriv->RtOutPipe[0];//BCN\n\t\tpdvobjpriv->Queue2Pipe[5] = pdvobjpriv->RtOutPipe[0];//MGT\n\t\tpdvobjpriv->Queue2Pipe[6] = pdvobjpriv->RtOutPipe[0];//HIGH\n\t\tpdvobjpriv->Queue2Pipe[7] = pdvobjpriv->RtOutPipe[0];//TXCMD\t\n\t}\n\n}\n```\n* \u30de\u30af\u30ed\u3067\u53c2\u7167\n\n```c\n#define ffaddr2deviceId(pdvobj, addr)\t(pdvobj->Queue2Pipe[addr])\n```\n\n\n# \u30b3\u30de\u30f3\u30c9\u9001\u4fe1\n\n* \u30b3\u30de\u30f3\u30c9\u9001\u4fe1\u306e\u7a7a\u304d\u304c\u3042\u308b\u304b\u78ba\u8a8d\n* rtw_write8()\u3068rtw_write32()\u3067\u30b3\u30de\u30f3\u30c9\u9001\u4fe1\n\n```c\n\n/*****************************************\n* H2C Msg format :\n* 0x1DF - 0x1D0\n*| 31 - 8\t| 7-5 \t 4 - 0\t|\n*| h2c_msg \t|Class_ID CMD_ID\t|\n*\n* Extend 0x1FF - 0x1F0\n*|31 - 0\t  |\n*|ext_msg|\n******************************************/\ns32 FillH2CCmd_8812(PADAPTER padapter, u8 ElementID, u32 CmdLen, u8 *pCmdBuffer)\n{\n\tu8 h2c_box_num;\n\tu32\tmsgbox_addr;\n\tu32 msgbox_ex_addr;\n\tHAL_DATA_TYPE *pHalData = GET_HAL_DATA(padapter);\n\tu8 cmd_idx,ext_cmd_len;\n\tu32\th2c_cmd = 0;\n\tu32\th2c_cmd_ex = 0;\n\ts32 ret = _FAIL;\n\n_func_enter_;\n\n\tpadapter = GET_PRIMARY_ADAPTER(padapter);\t\t\n\tpHalData = GET_HAL_DATA(padapter);\n\n\t\n\tif(padapter->bFWReady == _FALSE)\n\t{\n\t\t//DBG_8192C(\"FillH2CCmd_8812(): return H2C cmd because fw is not ready\\n\");\n\t\treturn ret;\n\t}\n\n\t_enter_critical_mutex(&(adapter_to_dvobj(padapter)->h2c_fwcmd_mutex), NULL);\n\n\n\tif (!pCmdBuffer) {\n\t\tgoto exit;\n\t}\n\tif (CmdLen > RTL8812_MAX_CMD_LEN) {\n\t\tgoto exit;\n\t}\n\tif (rtw_is_surprise_removed(padapter))\n\t\tgoto exit;\n\n\t//pay attention to if  race condition happened in  H2C cmd setting.\n\tdo{\n\t\th2c_box_num = pHalData->LastHMEBoxNum;\n\n\t\tif(!_is_fw_read_cmd_down(padapter, h2c_box_num)){\n\t\t\tDBG_8192C(\" fw read cmd failed...\\n\");\n\t\t\tgoto exit;\n\t\t}\n\n\t\t*(u8*)(&h2c_cmd) = ElementID;\n\n\t\tif(CmdLen<=3)\n\t\t{\n\t\t\t_rtw_memcpy((u8*)(&h2c_cmd)+1, pCmdBuffer, CmdLen );\n\t\t}\n\t\telse{\t\t\t\n\t\t\t_rtw_memcpy((u8*)(&h2c_cmd)+1, pCmdBuffer,3);\n\t\t\text_cmd_len = CmdLen-3;\t\n\t\t\t_rtw_memcpy((u8*)(&h2c_cmd_ex), pCmdBuffer+3,ext_cmd_len );\n\n\t\t\t//Write Ext command\n\t\t\tmsgbox_ex_addr = REG_HMEBOX_EXT0_8812 + (h2c_box_num *RTL8812_EX_MESSAGE_BOX_SIZE);\n\t\t\t#ifdef CONFIG_H2C_EF\n\t\t\tfor(cmd_idx=0;cmd_idx<ext_cmd_len;cmd_idx++ ){\n\t\t\t\trtw_write8(padapter,msgbox_ex_addr+cmd_idx,*((u8*)(&h2c_cmd_ex)+cmd_idx));\n\t\t\t}\n\t\t\t#else\n\t\t\th2c_cmd_ex = le32_to_cpu( h2c_cmd_ex );\n\t\t\trtw_write32(padapter, msgbox_ex_addr, h2c_cmd_ex);\n\t\t\t#endif\n\t\t}\n\t\t// Write command\n\t\tmsgbox_addr =REG_HMEBOX_0 + (h2c_box_num *RTL8812_MESSAGE_BOX_SIZE);\n\t\t#ifdef CONFIG_H2C_EF\n\t\tfor(cmd_idx=0;cmd_idx<RTL8812_MESSAGE_BOX_SIZE;cmd_idx++ ){\n\t\t\trtw_write8(padapter,msgbox_addr+cmd_idx,*((u8*)(&h2c_cmd)+cmd_idx));\n\t\t}\n\t\t#else\n\t\th2c_cmd = le32_to_cpu( h2c_cmd );\n\t\trtw_write32(padapter,msgbox_addr, h2c_cmd);\n\t\t#endif\n\n\t\t//DBG_871X(\"MSG_BOX:%d,CmdLen(%d), reg:0x%x =>h2c_cmd:0x%x, reg:0x%x =>h2c_cmd_ex:0x%x ..\\n\"\n\t\t//\t,pHalData->LastHMEBoxNum ,CmdLen,msgbox_addr,h2c_cmd,msgbox_ex_addr,h2c_cmd_ex);\n\n\t\tpHalData->LastHMEBoxNum = (h2c_box_num+1) % RTL8812_MAX_H2C_BOX_NUMS;\n\t\n\t}while(0);\n\n\tret = _SUCCESS;\n\nexit:\n\n\t_exit_critical_mutex(&(adapter_to_dvobj(padapter)->h2c_fwcmd_mutex), NULL);\t\n\n_func_exit_;\n\n\treturn ret;\n}\n\n```\n\n\n# \u30c7\u30fc\u30bf\u9001\u4fe1\n* rtw_write_port()\u3067\u691c\u7d22\u3059\u308b\u3068\u3001\u9001\u4fe1\u3057\u3066\u3044\u308b\u7b87\u6240\u306f\u30c7\u30fc\u30bf\u9001\u4fe1\u3068\u30de\u30cd\u30fc\u30b8\u30e1\u30f3\u30c8\u30d5\u30ec\u30fc\u30e0\u9001\u4fe1\u306e\uff12\u7b87\u6240\u304c\u898b\u3064\u304b\u308b\u3002\n* \u9001\u4fe1\u30c7\u30fc\u30bf\u30ad\u30e5\u30fc pxmitpriv\u304b\u3089\u9001\u4fe1\u30c7\u30fc\u30bf\u3092\u53d6\u308a\u51fa\u3059\u3002\n* \u9001\u4fe1\u30c7\u30fc\u30bf\u306edeviceId\u3092\u898b\u3066\u3069\u306e\u30ad\u30e5\u30fc\u306b\u3059\u308b\u304b\u9078\u629e\u3057\u3066PageIdx\u3092\u8a2d\u5b9a\n* rtw_hal_sdio_query_tx_freepage\uff08\uff09\u3067hardware tx fifo\u306e\u7a7a\u304d\u3092\u78ba\u8a8d\n* rtw_sdio_wait_enough_TxOQT_space()\u3067\u7a7a\u304d\u306e\u78ba\u8a8d\n* rtw_write_port()\u3067SDIO\u7d4c\u7531\u3067\u30c7\u30fc\u30bf\u9001\u4fe1\n\n\n```c\n/*\n * Dequeue xmit buffer and send to hardware\n *\n * Return:\n *\t_TRUE\tqueue is empty, nothing to be send to HW\n *\t_FALSE\tqueue is NOT empty\n */\nstatic s32 _dequeue_writeport(PADAPTER padapter)\n{\n\tstruct mlme_priv *pmlmepriv;\n\tstruct xmit_priv *pxmitpriv;\n\tstruct dvobj_priv *pdvobjpriv;\n\tstruct xmit_buf *pxmitbuf;\n\tu8\tPageIdx = 0;\n\tu32\tdeviceId;\n#ifdef CONFIG_SDIO_TX_ENABLE_AVAL_INT\n\tu8\tbUpdatePageNum = _FALSE;\n#else\n\tu32\tpolling_num = 0;\n#endif\n\n\n\tpmlmepriv = &padapter->mlmepriv;\n\tpxmitpriv = &padapter->xmitpriv;\n\tpdvobjpriv = adapter_to_dvobj(padapter);\n\n\tif (rtw_xmit_ac_blocked(padapter) == _TRUE)\n\t\tpxmitbuf = dequeue_pending_xmitbuf_under_survey(pxmitpriv);\n\telse\n\t\tpxmitbuf = dequeue_pending_xmitbuf(pxmitpriv);\n\n\tif (pxmitbuf == NULL)\n\t\treturn _TRUE;\n\n\tdeviceId = ffaddr2deviceId(pdvobjpriv, pxmitbuf->ff_hwaddr);\n\n\t// translate fifo addr to queue index\n\tswitch (deviceId) {\n\t\tcase WLAN_TX_HIQ_DEVICE_ID:\n\t\t\t\tPageIdx = HI_QUEUE_IDX;\n\t\t\t\tbreak;\n\n\t\tcase WLAN_TX_MIQ_DEVICE_ID:\n\t\t\t\tPageIdx = MID_QUEUE_IDX;\n\t\t\t\tbreak;\n\n\t\tcase WLAN_TX_LOQ_DEVICE_ID:\n\t\t\t\tPageIdx = LOW_QUEUE_IDX;\n\t\t\t\tbreak;\n\t}\n\nquery_free_page:\n\t/* check if hardware tx fifo page is enough */\n\tif (_FALSE == rtw_hal_sdio_query_tx_freepage(padapter, PageIdx, pxmitbuf->pg_num)) {\n#ifdef CONFIG_SDIO_TX_ENABLE_AVAL_INT\n\t\tif (!bUpdatePageNum) {\n\t\t\t// Total number of page is NOT available, so update current FIFO status\n\t\t\tHalQueryTxBufferStatus8821AS(padapter);\n\t\t\tbUpdatePageNum = _TRUE;\n\t\t\tgoto query_free_page;\n\t\t} else {\n\t\t\tbUpdatePageNum = _FALSE;\n\t\t\tenqueue_pending_xmitbuf_to_head(pxmitpriv, pxmitbuf);\n\t\t\treturn _TRUE;\n\t\t}\n#else //CONFIG_SDIO_TX_ENABLE_AVAL_INT\n\t\tpolling_num++;\n\t\tif ((polling_num % 0x7F) == 0) {//or 80\n\t\t\t//DBG_871X(\"%s: FIFO starvation!(%d) len=%d agg=%d page=(R)%d(A)%d\\n\",\n\t\t\t//\t__func__, n, pxmitbuf->len, pxmitbuf->agg_num, pframe->pg_num, freePage[PageIdx] + freePage[PUBLIC_QUEUE_IDX]);\n\t\t\trtw_msleep_os(1);\n\t\t}\n\n\t\t// Total number of page is NOT available, so update current FIFO status\n\t\tHalQueryTxBufferStatus8821AS(padapter);\n\t\tgoto query_free_page;\n#endif //CONFIG_SDIO_TX_ENABLE_AVAL_INT\n\t}\n\n\tif (RTW_CANNOT_RUN(padapter)) {\n\t\tDBG_8192C(\"%s: Removed=%s Stopped=%s, goto free xmitbuf!\\n\"\n\t\t\t, __func__\n\t\t\t, rtw_is_surprise_removed(padapter)?\"True\":\"False\"\n\t\t\t, rtw_is_drv_stopped(padapter)?\"True\":\"False\");\n\t\tgoto free_xmitbuf;\n\t}\n\n\n\tif (rtw_sdio_wait_enough_TxOQT_space(padapter, pxmitbuf->agg_num) == _FALSE) \n\t{\n\t\tgoto free_xmitbuf;\n\t}\n\n\trtw_write_port(padapter, deviceId, pxmitbuf->len, (u8 *)pxmitbuf);\n\n\trtw_hal_sdio_update_tx_freepage(padapter, PageIdx, pxmitbuf->pg_num);\n\nfree_xmitbuf:\n\t//rtw_free_xmitframe(pxmitpriv, pframe);\n\t//pxmitbuf->priv_data = NULL;\n\trtw_free_xmitbuf(pxmitpriv, pxmitbuf);\n\n#ifdef CONFIG_SDIO_TX_TASKLET\n\ttasklet_hi_schedule(&pxmitpriv->xmit_tasklet);\n#endif\n\n\treturn _FAIL;\n}\n```\n", "tags": ["Linux", "kernel", "Wi-Fi", "802.11"]}