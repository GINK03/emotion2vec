{"context": " More than 1 year has passed since last update.\u7269\u7406\u30b7\u30df\u30e5\u30ec\u30fc\u30b7\u30e7\u30f3\u3001\u30b2\u30fc\u30e0\u3001\u305d\u306e\u4ed6\u3067\u5e7e\u4f55\u30d9\u30af\u30c8\u30eb\u306e\u8a08\u7b97\u3092\u3057\u305f\u3044\u30b1\u30fc\u30b9\u306f\u591a\u3044\u3068\u601d\u3044\u307e\u3059\u3002\n\u5148\u306e\u6295\u7a3f\u3067\u3082\u4e09\u6b21\u5143\u306e\u30d9\u30af\u30c8\u30eb\u3092\u8868\u73fe\u3059\u308b\u30af\u30e9\u30b9\u3092\u5b9a\u7fa9\u3057\u305f\u3082\u306e\u304c\u3042\u308a\u307e\u3057\u305f\u3002\nhttp://qiita.com/NatsukiLab/items/9148a48f05c5f8d45600\n\u3044\u304f\u3064\u304b\u4e0d\u6e80\u304c\u3042\u3063\u305f\u306e\u3067\u3001\u79c1\u306a\u308a\u306b\u6539\u826f\u3057\u305f\u3082\u306e\u3092\u4f5c\u3063\u3066\u307f\u307e\u3057\u305f\u3002 \u4f55\u756a\u714e\u3058\u3060\u304b\u308f\u304b\u3089\u306a\u3044\u304f\u3089\u3044\u4f3c\u305f\u3088\u3046\u306a\u3082\u306e\u306f\u8272\u3093\u306a\u3068\u3053\u308d\u3067\u66f8\u304b\u308c\u3066\u3044\u308b\u3068\u601d\u3044\u307e\u3059\u304c\u3002\n\u4ee5\u4e0b\u306b\u30b3\u30fc\u30c9\u3092\u793a\u3057\u307e\u3059\u3002\n\n// -*- mode: c++ -*-\n\n#ifndef EUCLIDEAN_VECTOR_HEADER__\n#define EUCLIDEAN_VECTOR_HEADER__\n\n#include <type_traits>\n#include <iostream>\n#include <tuple>\n#include <functional>\n#include <cmath>\n\ntemplate<int n, class T, template<class...> class S, class... U>\nstruct repeat_type {\n  typedef typename repeat_type<n-1, T, S, U..., T>::type type;\n};\n\ntemplate<class T, template<class...> class S, class... U>\nstruct repeat_type<0, T, S, U...> {\n  typedef S<U...> type;\n};\n\ntemplate<int degree, class T> class euclidean_vector;\n\ntemplate<class S, class... T>\neuclidean_vector<sizeof...(T)+1, S> make_euclidean_vector(S arg, T... args) {\n  return euclidean_vector<sizeof...(T)+1, S>(arg, args...);\n}\n\ntemplate<int n, class U>\nstd::ostream&\noperator<<(std::ostream&, const euclidean_vector<n, U>&);\n\ntemplate<int degree, class T=double>\nclass euclidean_vector :public repeat_type<degree, T, std::tuple>::type {\npublic:\n  template<class... U>\n  euclidean_vector(U... args) : repeat_type<degree, T, std::tuple>::type(args...) {}\n\n  euclidean_vector(void) : repeat_type<degree, T, std::tuple>::type() {}\n\nprivate:\n  template<int n, class U>\n  friend std::ostream&\n  operator<<(std::ostream&, const euclidean_vector<n, U>&);\n\n  typedef typename repeat_type<degree, T, std::tuple>::type type;\n\n  template<int n>\n  typename std::enable_if<n==degree && n!=0>::type\n  print_impl(std::ostream& os) const {\n    os << \")\";\n  }\n\n  template<int n>\n  typename std::enable_if<n!=degree && n!=0>::type\n  print_impl(std::ostream& os) const {\n    print_impl<n+1>(os << \", \" << std::get<n>(*this));\n  }\n\n  template<int n>\n  typename std::enable_if<n==0 && n!=degree>::type\n  print_impl(std::ostream& os) const {\n    print_impl<1>(os << \"(\" << std::get<0>(*this));\n  }\n\n  template<int n>\n  typename std::enable_if<n==0 && n==degree>::type\n  print_impl(std::ostream& os) const {\n    os<<\"()\";\n  }\n\n  void print(std::ostream& os) const {\n    print_impl<0>(os);\n  }\n\n  template<int n, class... U>\n  typename std::enable_if<n==degree, euclidean_vector>::type\n  transform_impl(const std::function<T(T)>&, U... args) const {\n    return make_euclidean_vector(args...);\n  }\n\n  template<int n, class... U>\n  typename std::enable_if<n!=degree, euclidean_vector>::type\n  transform_impl(const std::function<T(T)>& func, U... args) const {\n    return transform_impl<n+1>(func, args..., func(std::get<n>(*this)));\n  }\n\n  template<int n, class... U>\n  typename std::enable_if<n==degree, euclidean_vector>::type\n  zipwith_impl(const std::function<T(T,T)>& func, const euclidean_vector&, U... args) const {\n    return make_euclidean_vector(args...);\n  }\n\n  template<int n, class... U>\n  typename std::enable_if<n!=degree, euclidean_vector>::type\n  zipwith_impl(const std::function<T(T, T)>& func, const euclidean_vector& x, U... args) const {\n    return zipwith_impl<n+1>(func, x, args..., func(std::get<n>(*this), std::get<n>(x)));\n  }\n\n  template<int n>\n  typename std::enable_if<n==degree, euclidean_vector>::type\n  foreach_impl(const std::function<void(T)>&) const {\n  }\n\n  template<int n>\n  typename std::enable_if<n!=degree, euclidean_vector>::type\n  foreach_impl(const std::function<void(T)>& func) const {\n    func(std::get<n>(*this));\n    foreach_impl<n+1>(func);\n  }\n\npublic:\n  void foreach(const std::function<void(T)>& func) const {\n    foreach_impl<0>(func);\n  }\n\n  euclidean_vector transform(std::function<T(T)>&& func) const {\n    return transform_impl<0>(func);\n  }\n\n  euclidean_vector operator-(void) const {\n    return transform(std::negate<T>());\n  }\n\n  euclidean_vector zipwith(std::function<T(T,T)>&& func, const euclidean_vector &x) const {\n    return zipwith_impl<0>(func, x);\n  }\n\n  euclidean_vector operator+(const euclidean_vector& x) const {\n    return zipwith(std::plus<T>(), x);\n  }\n\n  euclidean_vector operator+=(const euclidean_vector& x) {\n    return *this=*this+x;\n  }\n\n  euclidean_vector operator-(const euclidean_vector& x) const {\n    return zipwith(std::minus<T>(), x);\n  }\n\n  euclidean_vector operator-=(const euclidean_vector& x) {\n    return *this=*this-x;\n  }\n\n  T operator*(const euclidean_vector& x) const {\n    T acc=0;\n    zipwith(std::multiplies<T>(), x).foreach([&acc](T e) -> void { acc+=e; });\n    return acc;\n  }\n\n  euclidean_vector operator*(const T& x) const {\n    return transform([x](T e) -> T { return e*x; });\n  }\n\n  euclidean_vector& operator*=(const euclidean_vector& x) {\n    *this=*this*x;\n    return *this;\n  }\n\n  euclidean_vector& operator*=(const T& x) {\n    *this=*this*x;\n    return *this;\n  }\n\n  euclidean_vector operator/(const T& x) const {\n    return transform([x](T e) -> T { return e/x; });\n  }\n\n  euclidean_vector& operator/=(const T& x) {\n    *this=*this/x;\n    return *this;\n  }\n};\n\ntemplate<int n, class T>\nT abs(const euclidean_vector<n, T> x) {\n  T acc=0;\n  x.foreach([&acc](T e)->void { acc+=e*e; });\n  return std::sqrt(acc);\n}\n\ntemplate<int n, class T>\neuclidean_vector<n, T> operator*(const T& x, const euclidean_vector<n, T>& y) {\n  return y*x;\n}\n\ntemplate<int n, class T>\nstd::ostream&\noperator<<(std::ostream& os, const euclidean_vector<n, T>& x) {\n  x.print(os);\n  return os;\n}\n\n#endif\n\n\u6570\u5b66\u7684\u306b\u306f vector \u3068\u3044\u3046\u540d\u524d\u3092\u4f7f\u3044\u305f\u3044\u3068\u3053\u308d\u3067\u3059\u304c\u3001 C++ \u306e\u30e9\u30a4\u30d6\u30e9\u30ea\u306b\u306f\u65e2\u306b vector \u304c\u3042\u308b\u306e\u3067\u533a\u5225\u306e\u305f\u3081\u306b euclidean_vector \u3068\u540d\u4ed8\u3051\u307e\u3057\u305f\u3002 \u5197\u9577\u3060\u3068\u611f\u3058\u308b\u306a\u3089\u3070\u3001\u5229\u7528\u306e\u969b\u306b\u306f\u9069\u5f53\u306a\u5225\u540d\u3092\u4ed8\u3051\u3066\u4e0b\u3055\u3044\u3002\n\n\u6539\u826f\u70b9\n\u3067\u306f\u3001\u3069\u3093\u306a\u70b9\u3092\u6539\u826f\u3057\u305f\u306e\u304b\u8aac\u660e\u3057\u3066\u3044\u304d\u307e\u3059\u3002\n\n\u6b21\u6570\u3092\u6307\u5b9a\u3067\u304d\u308b\n\u3053\u3053\u3067 euclidean_vector \u306f\u3075\u305f\u3064\u306e\u30c6\u30f3\u30d7\u30ec\u30fc\u30c8\u30d1\u30e9\u30e1\u30bf\u3092\u53d7\u3051\u53d6\u308b\u578b\u3067\u3059\u3002 \u305d\u306e\u3075\u305f\u3064\u306f\u6b21\u6570\u3068\u8981\u7d20\u306e\u578b\u3067\u3059\u3002 \u4e09\u6b21\u5143\u4ee5\u5916\u306e\u30d9\u30af\u30c8\u30eb\u3092\u5b9a\u7fa9\u3059\u308b\u3053\u3068\u304c\u51fa\u6765\u307e\u3059\u3002\n\u4f8b\u3048\u3070\u8981\u7d20\u304c double \u578b\u306e\u56db\u6b21\u5143\u30d9\u30af\u30c8\u30eb\u306e\u5ba3\u8a00\u306f\u4ee5\u4e0b\u306e\u3088\u3046\u306b\u3057\u307e\u3059\u3002\neuclidean_vector<4, double> foo(1, 2, 3, 4);\n\n\n\u30b9\u30c8\u30ea\u30fc\u30e0\u306b\u51fa\u529b\u3067\u304d\u308b\n\u5dee\u8fbc\u307f\u6f14\u7b97\u5b50\u3067\u30b9\u30c8\u30ea\u30fc\u30e0\u306b\u51fa\u529b\u3059\u308b\u3053\u3068\u304c\u51fa\u6765\u307e\u3059\u3002\n\u4f8b\u3048\u3070\u3001\nstd::cout << euclidean_vector<3, int>(1, 2, 3) <<std::endl;\n\n\u3068\u3059\u308b\u3068\n(1, 2, 3)\n\n\u306e\u3088\u3046\u306b\u8868\u793a\u3055\u308c\u307e\u3059\u3002\n\n\u30d8\u30eb\u30d1\u95a2\u6570\n\u5e7e\u4f55\u30d9\u30af\u30c8\u30eb\u30aa\u30d6\u30b8\u30a7\u30af\u30c8\u3092\u751f\u6210\u3059\u308b\u30d8\u30eb\u30d1\u95a2\u6570\u3092\u7528\u610f\u3057\u307e\u3057\u305f\u3002\n\u578b\u3092\u660e\u8a18\u305b\u305a\u3068\u3082\u81ea\u52d5\u3067\u63a8\u8ad6\u3057\u3066\u304f\u308c\u308b (\u3082\u3061\u308d\u3093\u660e\u8a18\u3057\u3066\u3082\u3088\u3044\u3067\u3059\u304c) \u306e\u3067\u66f8\u304f\u306e\u304c\u697d\u306b\u306a\u308b\u3053\u3068\u3082\u3042\u308b\u3067\u3057\u3087\u3046\u3002\n\u4ee5\u4e0b\u306e\u3088\u3046\u306a\u8981\u9818\u3067\u4f7f\u3044\u307e\u3059\u3002\nstd::cout << make_euclidean_vector(1, 2, 3) <<std::endl;\n\n\n\u30bf\u30d7\u30eb\u304b\u3089\u306e\u6d3e\u751f\neuclidean_vector \u306f tuple \u304b\u3089\u6d3e\u751f\u3059\u308b\u5f62\u3067\u5b9a\u7fa9\u3057\u3066\u3044\u307e\u3059\u3002 \u3064\u307e\u308a\u3001 tuple \u306b\u5bfe\u3057\u3066\u3067\u304d\u308b\u64cd\u4f5c\u306f euclidean_vector \u306b\u5bfe\u3057\u3066\u3082\u51fa\u6765\u308b\u3068\u3044\u3046\u3053\u3068\u3067\u3059\u3002\n\u4f8b\u3048\u3070\u3001 get \u306a\u3069\u306e\u30a2\u30af\u30bb\u30b5\u3082\u9069\u7528\u3059\u308b\u3053\u3068\u304c\u53ef\u80fd\u3067\u3059\u3002\neuclidean_vector<4, double> foo(1, 2, 3, 4);\nstd::cout << std::get<0>(foo) <<std::endl;\n\n\u3067\u3059\u304c\u3053\u308c\u306f\u5931\u6557\u3060\u3063\u305f\u304b\u3082\u3057\u308c\u306a\u3044\u3068\u601d\u3044\u307e\u3059\u3002 \u8981\u7d20\u306e\u578b\u304c\u5168\u3066\u540c\u3058\u3068\u3044\u3046\u524d\u63d0\u3067\u3042\u308c\u3070\u30bf\u30d7\u30eb\u306b\u3059\u308b\u610f\u7fa9\u306f\u4f55\u3082\u3042\u308a\u307e\u305b\u3093\u3002 \u5b9f\u969b\u306b\u4f7f\u3063\u3066\u307f\u308b\u3068\u30a4\u30c6\u30ec\u30fc\u30bf\u306a\u3069\u304c\u4f7f\u3048\u306a\u3044\u3053\u3068\u304c\u305a\u3044\u3076\u3093\u3068\u624b\u9593\u306b\u601d\u3048\u307e\u3057\u305f\u3002\n\n\u305d\u306e\u4ed6\n\u3042\u3068\u306f\u5143\u30cd\u30bf\u540c\u69d8\u306b\u5404\u7a2e\u6f14\u7b97\u304c\u53ef\u80fd\u3067\u3059\u3002\nauto x = make_euclidean_vector(1.0, 2.0, 3.0);\nauto y = make_euclidean_vector(1.0, 2.0, 3.0);\n\nstd::cout << x+y    << std::endl; // \u30d9\u30af\u30c8\u30eb\u540c\u58eb\u306e\u8db3\u3057\u7b97\nstd::cout << x-y    << std::endl; // \u30d9\u30af\u30c8\u30eb\u540c\u58eb\u306e\u5f15\u304d\u7b97\nstd::cout << x*y    << std::endl; // \u30d9\u30af\u30c8\u30eb\u306e\u5185\u7a4d\nstd::cout << x*2.0  << std::endl; // \u30d9\u30af\u30c8\u30eb\u306e\u30b9\u30ab\u30e9\u500d\nstd::cout << 2.0*x  << std::endl; // \u30d9\u30af\u30c8\u30eb\u306e\u30b9\u30ab\u30e9\u500d\u3001\u9806\u5e8f\u3092\u5909\u3048\u3066\u3082 OK\nstd::cout << x/2    << std::endl; // \u30d9\u30af\u30c8\u30eb\u3092\u30b9\u30ab\u30e9\u5024\u3067\u5272\u308b\nstd::cout << abs(x) << std::endl; // \u7d76\u5bfe\u5024\u306e\u8a08\u7b97\u3002 cmath \u306e abs \u3092\u30aa\u30fc\u30d0\u30fc\u30ed\u30fc\u30c9\u3057\u3066\u3042\u308b\n\n\u7269\u7406\u30b7\u30df\u30e5\u30ec\u30fc\u30b7\u30e7\u30f3\u3001\u30b2\u30fc\u30e0\u3001\u305d\u306e\u4ed6\u3067\u5e7e\u4f55\u30d9\u30af\u30c8\u30eb\u306e\u8a08\u7b97\u3092\u3057\u305f\u3044\u30b1\u30fc\u30b9\u306f\u591a\u3044\u3068\u601d\u3044\u307e\u3059\u3002\n\n\u5148\u306e\u6295\u7a3f\u3067\u3082\u4e09\u6b21\u5143\u306e\u30d9\u30af\u30c8\u30eb\u3092\u8868\u73fe\u3059\u308b\u30af\u30e9\u30b9\u3092\u5b9a\u7fa9\u3057\u305f\u3082\u306e\u304c\u3042\u308a\u307e\u3057\u305f\u3002\n\nhttp://qiita.com/NatsukiLab/items/9148a48f05c5f8d45600\n\n\u3044\u304f\u3064\u304b\u4e0d\u6e80\u304c\u3042\u3063\u305f\u306e\u3067\u3001\u79c1\u306a\u308a\u306b\u6539\u826f\u3057\u305f\u3082\u306e\u3092\u4f5c\u3063\u3066\u307f\u307e\u3057\u305f\u3002 \u4f55\u756a\u714e\u3058\u3060\u304b\u308f\u304b\u3089\u306a\u3044\u304f\u3089\u3044\u4f3c\u305f\u3088\u3046\u306a\u3082\u306e\u306f\u8272\u3093\u306a\u3068\u3053\u308d\u3067\u66f8\u304b\u308c\u3066\u3044\u308b\u3068\u601d\u3044\u307e\u3059\u304c\u3002\n\n\u4ee5\u4e0b\u306b\u30b3\u30fc\u30c9\u3092\u793a\u3057\u307e\u3059\u3002\n\n```cpp\n\n// -*- mode: c++ -*-\n\n#ifndef EUCLIDEAN_VECTOR_HEADER__\n#define EUCLIDEAN_VECTOR_HEADER__\n\n#include <type_traits>\n#include <iostream>\n#include <tuple>\n#include <functional>\n#include <cmath>\n\ntemplate<int n, class T, template<class...> class S, class... U>\nstruct repeat_type {\n  typedef typename repeat_type<n-1, T, S, U..., T>::type type;\n};\n\ntemplate<class T, template<class...> class S, class... U>\nstruct repeat_type<0, T, S, U...> {\n  typedef S<U...> type;\n};\n\ntemplate<int degree, class T> class euclidean_vector;\n\ntemplate<class S, class... T>\neuclidean_vector<sizeof...(T)+1, S> make_euclidean_vector(S arg, T... args) {\n  return euclidean_vector<sizeof...(T)+1, S>(arg, args...);\n}\n\ntemplate<int n, class U>\nstd::ostream&\noperator<<(std::ostream&, const euclidean_vector<n, U>&);\n\ntemplate<int degree, class T=double>\nclass euclidean_vector :public repeat_type<degree, T, std::tuple>::type {\npublic:\n  template<class... U>\n  euclidean_vector(U... args) : repeat_type<degree, T, std::tuple>::type(args...) {}\n\n  euclidean_vector(void) : repeat_type<degree, T, std::tuple>::type() {}\n\nprivate:\n  template<int n, class U>\n  friend std::ostream&\n  operator<<(std::ostream&, const euclidean_vector<n, U>&);\n\n  typedef typename repeat_type<degree, T, std::tuple>::type type;\n\n  template<int n>\n  typename std::enable_if<n==degree && n!=0>::type\n  print_impl(std::ostream& os) const {\n    os << \")\";\n  }\n\n  template<int n>\n  typename std::enable_if<n!=degree && n!=0>::type\n  print_impl(std::ostream& os) const {\n    print_impl<n+1>(os << \", \" << std::get<n>(*this));\n  }\n\n  template<int n>\n  typename std::enable_if<n==0 && n!=degree>::type\n  print_impl(std::ostream& os) const {\n    print_impl<1>(os << \"(\" << std::get<0>(*this));\n  }\n\n  template<int n>\n  typename std::enable_if<n==0 && n==degree>::type\n  print_impl(std::ostream& os) const {\n    os<<\"()\";\n  }\n\n  void print(std::ostream& os) const {\n    print_impl<0>(os);\n  }\n\n  template<int n, class... U>\n  typename std::enable_if<n==degree, euclidean_vector>::type\n  transform_impl(const std::function<T(T)>&, U... args) const {\n    return make_euclidean_vector(args...);\n  }\n\n  template<int n, class... U>\n  typename std::enable_if<n!=degree, euclidean_vector>::type\n  transform_impl(const std::function<T(T)>& func, U... args) const {\n    return transform_impl<n+1>(func, args..., func(std::get<n>(*this)));\n  }\n\n  template<int n, class... U>\n  typename std::enable_if<n==degree, euclidean_vector>::type\n  zipwith_impl(const std::function<T(T,T)>& func, const euclidean_vector&, U... args) const {\n    return make_euclidean_vector(args...);\n  }\n\n  template<int n, class... U>\n  typename std::enable_if<n!=degree, euclidean_vector>::type\n  zipwith_impl(const std::function<T(T, T)>& func, const euclidean_vector& x, U... args) const {\n    return zipwith_impl<n+1>(func, x, args..., func(std::get<n>(*this), std::get<n>(x)));\n  }\n\n  template<int n>\n  typename std::enable_if<n==degree, euclidean_vector>::type\n  foreach_impl(const std::function<void(T)>&) const {\n  }\n\n  template<int n>\n  typename std::enable_if<n!=degree, euclidean_vector>::type\n  foreach_impl(const std::function<void(T)>& func) const {\n    func(std::get<n>(*this));\n    foreach_impl<n+1>(func);\n  }\n\npublic:\n  void foreach(const std::function<void(T)>& func) const {\n    foreach_impl<0>(func);\n  }\n\n  euclidean_vector transform(std::function<T(T)>&& func) const {\n    return transform_impl<0>(func);\n  }\n\n  euclidean_vector operator-(void) const {\n    return transform(std::negate<T>());\n  }\n\n  euclidean_vector zipwith(std::function<T(T,T)>&& func, const euclidean_vector &x) const {\n    return zipwith_impl<0>(func, x);\n  }\n\n  euclidean_vector operator+(const euclidean_vector& x) const {\n    return zipwith(std::plus<T>(), x);\n  }\n\n  euclidean_vector operator+=(const euclidean_vector& x) {\n    return *this=*this+x;\n  }\n\n  euclidean_vector operator-(const euclidean_vector& x) const {\n    return zipwith(std::minus<T>(), x);\n  }\n\n  euclidean_vector operator-=(const euclidean_vector& x) {\n    return *this=*this-x;\n  }\n\n  T operator*(const euclidean_vector& x) const {\n    T acc=0;\n    zipwith(std::multiplies<T>(), x).foreach([&acc](T e) -> void { acc+=e; });\n    return acc;\n  }\n\n  euclidean_vector operator*(const T& x) const {\n    return transform([x](T e) -> T { return e*x; });\n  }\n\n  euclidean_vector& operator*=(const euclidean_vector& x) {\n    *this=*this*x;\n    return *this;\n  }\n\n  euclidean_vector& operator*=(const T& x) {\n    *this=*this*x;\n    return *this;\n  }\n\n  euclidean_vector operator/(const T& x) const {\n    return transform([x](T e) -> T { return e/x; });\n  }\n\n  euclidean_vector& operator/=(const T& x) {\n    *this=*this/x;\n    return *this;\n  }\n};\n\ntemplate<int n, class T>\nT abs(const euclidean_vector<n, T> x) {\n  T acc=0;\n  x.foreach([&acc](T e)->void { acc+=e*e; });\n  return std::sqrt(acc);\n}\n\ntemplate<int n, class T>\neuclidean_vector<n, T> operator*(const T& x, const euclidean_vector<n, T>& y) {\n  return y*x;\n}\n\ntemplate<int n, class T>\nstd::ostream&\noperator<<(std::ostream& os, const euclidean_vector<n, T>& x) {\n  x.print(os);\n  return os;\n}\n\n#endif\n```\n\n\u6570\u5b66\u7684\u306b\u306f vector \u3068\u3044\u3046\u540d\u524d\u3092\u4f7f\u3044\u305f\u3044\u3068\u3053\u308d\u3067\u3059\u304c\u3001 C++ \u306e\u30e9\u30a4\u30d6\u30e9\u30ea\u306b\u306f\u65e2\u306b vector \u304c\u3042\u308b\u306e\u3067\u533a\u5225\u306e\u305f\u3081\u306b euclidean_vector \u3068\u540d\u4ed8\u3051\u307e\u3057\u305f\u3002 \u5197\u9577\u3060\u3068\u611f\u3058\u308b\u306a\u3089\u3070\u3001\u5229\u7528\u306e\u969b\u306b\u306f\u9069\u5f53\u306a\u5225\u540d\u3092\u4ed8\u3051\u3066\u4e0b\u3055\u3044\u3002\n\n# \u6539\u826f\u70b9\n\n\u3067\u306f\u3001\u3069\u3093\u306a\u70b9\u3092\u6539\u826f\u3057\u305f\u306e\u304b\u8aac\u660e\u3057\u3066\u3044\u304d\u307e\u3059\u3002\n\n## \u6b21\u6570\u3092\u6307\u5b9a\u3067\u304d\u308b\n\n\u3053\u3053\u3067 euclidean_vector \u306f\u3075\u305f\u3064\u306e\u30c6\u30f3\u30d7\u30ec\u30fc\u30c8\u30d1\u30e9\u30e1\u30bf\u3092\u53d7\u3051\u53d6\u308b\u578b\u3067\u3059\u3002 \u305d\u306e\u3075\u305f\u3064\u306f\u6b21\u6570\u3068\u8981\u7d20\u306e\u578b\u3067\u3059\u3002 \u4e09\u6b21\u5143\u4ee5\u5916\u306e\u30d9\u30af\u30c8\u30eb\u3092\u5b9a\u7fa9\u3059\u308b\u3053\u3068\u304c\u51fa\u6765\u307e\u3059\u3002\n\n\u4f8b\u3048\u3070\u8981\u7d20\u304c double \u578b\u306e\u56db\u6b21\u5143\u30d9\u30af\u30c8\u30eb\u306e\u5ba3\u8a00\u306f\u4ee5\u4e0b\u306e\u3088\u3046\u306b\u3057\u307e\u3059\u3002\n\n```cpp\neuclidean_vector<4, double> foo(1, 2, 3, 4);\n```\n\n## \u30b9\u30c8\u30ea\u30fc\u30e0\u306b\u51fa\u529b\u3067\u304d\u308b\n\n\u5dee\u8fbc\u307f\u6f14\u7b97\u5b50\u3067\u30b9\u30c8\u30ea\u30fc\u30e0\u306b\u51fa\u529b\u3059\u308b\u3053\u3068\u304c\u51fa\u6765\u307e\u3059\u3002\n\n\u4f8b\u3048\u3070\u3001\n\n```cpp\nstd::cout << euclidean_vector<3, int>(1, 2, 3) <<std::endl;\n```\n\n\u3068\u3059\u308b\u3068\n\n```\n(1, 2, 3)\n```\n\n\u306e\u3088\u3046\u306b\u8868\u793a\u3055\u308c\u307e\u3059\u3002\n\n## \u30d8\u30eb\u30d1\u95a2\u6570\n\n\u5e7e\u4f55\u30d9\u30af\u30c8\u30eb\u30aa\u30d6\u30b8\u30a7\u30af\u30c8\u3092\u751f\u6210\u3059\u308b\u30d8\u30eb\u30d1\u95a2\u6570\u3092\u7528\u610f\u3057\u307e\u3057\u305f\u3002\n\n\u578b\u3092\u660e\u8a18\u305b\u305a\u3068\u3082\u81ea\u52d5\u3067\u63a8\u8ad6\u3057\u3066\u304f\u308c\u308b (\u3082\u3061\u308d\u3093\u660e\u8a18\u3057\u3066\u3082\u3088\u3044\u3067\u3059\u304c) \u306e\u3067\u66f8\u304f\u306e\u304c\u697d\u306b\u306a\u308b\u3053\u3068\u3082\u3042\u308b\u3067\u3057\u3087\u3046\u3002\n\n\u4ee5\u4e0b\u306e\u3088\u3046\u306a\u8981\u9818\u3067\u4f7f\u3044\u307e\u3059\u3002\n\n```cpp\nstd::cout << make_euclidean_vector(1, 2, 3) <<std::endl;\n```\n\n## \u30bf\u30d7\u30eb\u304b\u3089\u306e\u6d3e\u751f\n\neuclidean_vector \u306f tuple \u304b\u3089\u6d3e\u751f\u3059\u308b\u5f62\u3067\u5b9a\u7fa9\u3057\u3066\u3044\u307e\u3059\u3002 \u3064\u307e\u308a\u3001 tuple \u306b\u5bfe\u3057\u3066\u3067\u304d\u308b\u64cd\u4f5c\u306f euclidean_vector \u306b\u5bfe\u3057\u3066\u3082\u51fa\u6765\u308b\u3068\u3044\u3046\u3053\u3068\u3067\u3059\u3002\n\n\u4f8b\u3048\u3070\u3001 get \u306a\u3069\u306e\u30a2\u30af\u30bb\u30b5\u3082\u9069\u7528\u3059\u308b\u3053\u3068\u304c\u53ef\u80fd\u3067\u3059\u3002\n\n```cpp\neuclidean_vector<4, double> foo(1, 2, 3, 4);\nstd::cout << std::get<0>(foo) <<std::endl;\n```\n\n\u3067\u3059\u304c\u3053\u308c\u306f\u5931\u6557\u3060\u3063\u305f\u304b\u3082\u3057\u308c\u306a\u3044\u3068\u601d\u3044\u307e\u3059\u3002 \u8981\u7d20\u306e\u578b\u304c\u5168\u3066\u540c\u3058\u3068\u3044\u3046\u524d\u63d0\u3067\u3042\u308c\u3070\u30bf\u30d7\u30eb\u306b\u3059\u308b\u610f\u7fa9\u306f\u4f55\u3082\u3042\u308a\u307e\u305b\u3093\u3002 \u5b9f\u969b\u306b\u4f7f\u3063\u3066\u307f\u308b\u3068\u30a4\u30c6\u30ec\u30fc\u30bf\u306a\u3069\u304c\u4f7f\u3048\u306a\u3044\u3053\u3068\u304c\u305a\u3044\u3076\u3093\u3068\u624b\u9593\u306b\u601d\u3048\u307e\u3057\u305f\u3002\n\n## \u305d\u306e\u4ed6\n\n\u3042\u3068\u306f\u5143\u30cd\u30bf\u540c\u69d8\u306b\u5404\u7a2e\u6f14\u7b97\u304c\u53ef\u80fd\u3067\u3059\u3002\n\n```cpp\nauto x = make_euclidean_vector(1.0, 2.0, 3.0);\nauto y = make_euclidean_vector(1.0, 2.0, 3.0);\n\nstd::cout << x+y    << std::endl; // \u30d9\u30af\u30c8\u30eb\u540c\u58eb\u306e\u8db3\u3057\u7b97\nstd::cout << x-y    << std::endl; // \u30d9\u30af\u30c8\u30eb\u540c\u58eb\u306e\u5f15\u304d\u7b97\nstd::cout << x*y    << std::endl; // \u30d9\u30af\u30c8\u30eb\u306e\u5185\u7a4d\nstd::cout << x*2.0  << std::endl; // \u30d9\u30af\u30c8\u30eb\u306e\u30b9\u30ab\u30e9\u500d\nstd::cout << 2.0*x  << std::endl; // \u30d9\u30af\u30c8\u30eb\u306e\u30b9\u30ab\u30e9\u500d\u3001\u9806\u5e8f\u3092\u5909\u3048\u3066\u3082 OK\nstd::cout << x/2    << std::endl; // \u30d9\u30af\u30c8\u30eb\u3092\u30b9\u30ab\u30e9\u5024\u3067\u5272\u308b\nstd::cout << abs(x) << std::endl; // \u7d76\u5bfe\u5024\u306e\u8a08\u7b97\u3002 cmath \u306e abs \u3092\u30aa\u30fc\u30d0\u30fc\u30ed\u30fc\u30c9\u3057\u3066\u3042\u308b\n```\n", "tags": ["C++11", "C++"]}