{"context": "\u3053\u306e\u8a18\u4e8b\u306fBitVisor Advent Calendar 8\u65e5\u76ee\u306e\u8a18\u4e8b\u3067\u3059\uff0e\nBitVisor\u306bVMCALL\u3092\u8ffd\u52a0\u3059\u308b\u4e8b\u3067\u3001Linux\u4e0a\u3067\u306e\u30c7\u30d0\u30a4\u30b9\u30c9\u30e9\u30a4\u30d0\u306e\u30ed\u30fc\u30c9\u3092\u691c\u77e5\u3057\u3066\u307f\u307e\u3059\u3002\n\n\u30b7\u30b9\u30c6\u30e0\u30b3\u30fc\u30eb\u30d5\u30c3\u30af\n\u30c7\u30d0\u30a4\u30b9\u30c9\u30e9\u30a4\u30d0\u306finsmod\u306a\u3069\u3067\u30ab\u30fc\u30cd\u30eb\u306b\u7d44\u307f\u8fbc\u307e\u308c\u307e\u3059\u3002\u3053\u306e\u6642init_module\u307e\u305f\u306ffinit_module\u30b7\u30b9\u30c6\u30e0\u30b3\u30fc\u30eb\u304c\u547c\u3070\u308c\u30c9\u30e9\u30a4\u30d0\u304c\u30ed\u30fc\u30c9\u3055\u308c\u308b\u308f\u3051\u3067\u3059\u304c\u3001\u3053\u308c\u3089\u306e\u30b7\u30b9\u30c6\u30e0\u30b3\u30fc\u30eb\u3092\u30d5\u30c3\u30af\u3057\u3066VMCALL\u3067BitVisor\u306b\u901a\u77e5\u3059\u308b\u3088\u3046\u306a\u30a8\u30fc\u30b8\u30a7\u30f3\u30c8\u306e\u5f79\u5272\u3092\u6301\u3064\u30ab\u30fc\u30cd\u30eb\u30e2\u30b8\u30e5\u30fc\u30eb\u3092\u958b\u767a\u3057\u3066\u307f\u307e\u3059\u3002\n\u30b7\u30b9\u30c6\u30e0\u30b3\u30fc\u30eb\u306e\u30d5\u30c3\u30af\u306fsys_call_table\u306e\u30da\u30fc\u30b8\u30d1\u30fc\u30df\u30c3\u30b7\u30e7\u30f3\u3092\u66f8\u304d\u8fbc\u307f\u53ef\u80fd\u306b\u5909\u66f4\u3057\u3066\u3001\u30d5\u30c3\u30af\u95a2\u6570\u306b\u3059\u3052\u66ff\u3048\u308b\u624b\u6cd5\u3092\u53d6\u308a\u307e\u3059\u3002\n- Linux\u30ab\u30fc\u30cd\u30eb\u3067system call\u306ehook http://kernhack.hatenablog.com/entry/2014/12/05/000346\n\n\u30c9\u30e9\u30a4\u30d0\u306e\u30a2\u30c9\u30ec\u30b9\u53d6\u5f97\ninit_module\u306b\u3088\u3063\u3066\u8aad\u307f\u8fbc\u307e\u308c\u305f\u30e2\u30b8\u30e5\u30fc\u30eb\u306f\u5185\u90e8\u3067\u30ed\u30fc\u30c9\u51e6\u7406\u3092\u884c\u3044\u3001struct module->module_core\u30e1\u30f3\u30d0\u306b\u30ed\u30fc\u30c9\u3055\u308c\u305f\u30a2\u30c9\u30ec\u30b9\u304c\u683c\u7d0d\u3055\u308c\u307e\u3059\u3002\n\u3088\u3063\u3066init_module\u306e\u30d5\u30c3\u30af\u95a2\u6570\u5185\u3067\u3001\u30aa\u30ea\u30b8\u30ca\u30eb\u306einit_module\u3092\u5b9f\u884c\u3057\u3066\u30ed\u30fc\u30c9\u3055\u305b\u305f\u5f8c\u3001struct module\u3092\u53c2\u7167\u3057\u3066\u3084\u308c\u3070\u30ed\u30fc\u30c9\u30a2\u30c9\u30ec\u30b9\u304c\u53d6\u5f97\u3067\u304d\u307e\u3059\u3002\u5b9f\u969b\u306b\u8a72\u5f53\u51e6\u7406\u90e8\u5206\u306e\u30b3\u30fc\u30c9\u3092\u8f09\u305b\u307e\u3059\u3002\n\ntools/drvhook/drvhook.c\nstatic struct module*\nget_module(const char *modname)\n{\n  struct module *mod = NULL;\n  if (mutex_lock_interruptible(&module_mutex) != 0) {\n    goto mutex_fail;\n  }\n\n  mod = find_module(modname);\n\n  mutex_unlock(&module_mutex);\nmutex_fail:\n  pr_info(\"get_module(%s) = %p\\n\", modname, mod);\n  return mod;\n}\n\nasmlinkage long\nk2e_sys_finit_module (int fd, const char __user *uargs, int flags)\n{\n  long orig;\n  struct module *mod = NULL;\n  pr_info(\"call k2e_sys_finit_module\\n\");\n\n  orig = orig_sys_finit_module (fd, uargs, flags);\n\n  mod = get_module(target);\n  if (mod)\n    vmcall_drvhook(mod->module_core);\n\n  return orig;\n}\n\n\nk2e_sys_finit_module\u3068\u3044\u3046\u306e\u304c\u30d5\u30c3\u30af\u95a2\u6570\u3067\u3001find_module\u3067\u30bf\u30fc\u30b2\u30c3\u30c8\u3068\u3059\u308b\u30c9\u30e9\u30a4\u30d0\u3092\u691c\u7d22\u3057\u307e\u3059\u3002orig_sys_finit_module\u3067\u30aa\u30ea\u30b8\u30ca\u30eb\u3092\u5b9f\u884c\u3057\u305f\u5f8c\u306a\u306e\u3067\u3001\u3053\u306e\u6bb5\u968e\u3067\u306f\u65e2\u306b\u30ed\u30fc\u30c9\u304c\u5b8c\u4e86\u3057\u3066\u304a\u308a\u3001find_module\u3067\u60c5\u5831\u304c\u53d6\u5f97\u3067\u304d\u308b\u308f\u3051\u3067\u3059\u3002\n\nBitVisor\u3078\u306e\u901a\u77e5\n\u3067\u306f\u53d6\u5f97\u3057\u305f\u30c9\u30e9\u30a4\u30d0\u306e\u30ed\u30fc\u30c9\u30a2\u30c9\u30ec\u30b9\u3092VMCALL\u3067BitVisor\u306b\u901a\u77e5\u3057\u3066\u307f\u307e\u3059\u3002\n\u901a\u5e38BitVisor\u306bVMCALL\u3092\u8ffd\u52a0\u3059\u308b\u306b\u306ftools/common/call_vmm.c\u306a\u3069\u3092\u4f7f\u3046\u306e\u3067\u3059\u304c\u3001\n\n[\u53c2\u8003] BitVisor\u306bVMMCALL\u3092\u8ffd\u52a0\u3059\u308b\nhttp://qiita.com/deep_tkkn/items/ca794e66c25df9a9bf66\n\n\ncall_vmm.c\u306f\u305d\u306e\u307e\u307e\u3067\u306f\u30ab\u30fc\u30cd\u30eb\u30e2\u30b8\u30e5\u30fc\u30eb\u7528\u306b\u306f\u30b3\u30f3\u30d1\u30a4\u30eb\u3067\u304d\u306a\u3044\u306e\u3067\u3001\u5fc5\u8981\u306a\u90e8\u5206\u3060\u3051\u3092\u5207\u308a\u51fa\u3057\u3066\u4f7f\u7528\u3057\u307e\u3057\u305f\u3002\u3088\u3063\u3066\u30cf\u30a4\u30d1\u30fc\u30b3\u30fc\u30eb\u756a\u53f7\u53d6\u5f97\u306e\u305f\u3081\u306eCALL_VMM_GET_FUNCTION\u30de\u30af\u30ed\u306a\u3069\u3092\u4f7f\u308f\u305a\u3001\u4e00\u90e8\u518d\u5b9f\u88c5\u3057\u3066\u30ab\u30fc\u30cd\u30eb\u30e2\u30b8\u30e5\u30fc\u30eb\u304b\u3089\u3082\u4f7f\u3048\u308b\u3088\u3046\u306b\u3057\u307e\u3057\u305f\u3002\n\ntools/drvhook/drvhook.c\nMODULE_DESCRIPTION(\"guest driver hook for k2e\");\nMODULE_AUTHOR(\"rkx1209\");\nMODULE_LICENSE(\"GPL\");\n\n/* following string SYSCALL_TABLE_ADDRESS will be replaced by set_syscall_table_address.sh */\nstatic void **syscall_table = (void *) 0xffffffff81a001c0;\nstatic char *target = \"blahblah\";\nmodule_param(target, charp, S_IRUGO);\n\nasmlinkage long (*orig_sys_init_module)(void __user *umod, unsigned long len, const char __user *uargs);\nasmlinkage long (*orig_sys_finit_module)(int fd, const char __user *uargs, int flags);\n\n\nvoid\ncall_vmm_call_function (call_vmm_function_t *function,\n                        call_vmm_arg_t *arg, call_vmm_ret_t *ret)\n{\n  struct call_vmm_call_function_sub_data data;\n  data.function = function;\n  data.arg = arg;\n  data.ret = ret;\n  pr_info(\"vmcall %d(arg=0x%lx)\\n\", data.function->vmmcall_number, data.arg->rbx);\n  switch (data.function->vmmcall_type) {\n    case VMMCALL_TYPE_VMCALL:\n        asm volatile (\"vmcall\"\n                       : \"=a\" (data.ret->rax), \"=b\" (data.ret->rbx),\n                             \"=c\" (data.ret->rcx), \"=d\" (data.ret->rdx),\n                           \"=S\" (data.ret->rsi), \"=D\" (data.ret->rdi)\n                       : \"a\" (data.function->vmmcall_number),\n                           \"b\" (data.arg->rbx),\n                           \"c\" (data.arg->rcx), \"d\" (data.arg->rdx),\n                           \"S\" (data.arg->rsi), \"D\" (data.arg->rdi)\n                       : \"memory\");\n        break;\n    case VMMCALL_TYPE_VMMCALL:\n        asm volatile (\"vmmcall\"\n                       : \"=a\" (data.ret->rax), \"=b\" (data.ret->rbx),\n                           \"=c\" (data.ret->rcx), \"=d\" (data.ret->rdx),\n                           \"=S\" (data.ret->rsi), \"=D\" (data.ret->rdi)\n                       : \"a\" (data.function->vmmcall_number),\n                           \"b\" (data.arg->rbx),\n                         \"c\" (data.arg->rcx), \"d\" (data.arg->rdx),\n                         \"S\" (data.arg->rsi), \"D\" (data.arg->rdi)\n                       : \"memory\");\n        break;\n    }\n}\n\n/* Get a entry number of specified vmmcall */\nvoid\nvmmcall_get_function(const char *vmmcall, call_vmm_function_t *res)\n{\n  call_vmm_function_t gf;\n  call_vmm_arg_t gf_a;\n  call_vmm_ret_t gf_r;\n\n  gf.vmmcall_number = GET_VMMCALL_NUMBER;\n  gf.vmmcall_type = VMMCALL_TYPE_VMCALL;\n  gf_a.rbx = (intptr_t)vmmcall;\n  pr_info(\"vmmcall_string:%p, 0x%lx, %s\\n\", vmmcall, gf_a.rbx, vmmcall);\n  call_vmm_call_function(&gf, &gf_a, &gf_r);\n\n  /* RAX = vmmcall number */\n  res->vmmcall_number = (int)gf_r.rax;\n  res->vmmcall_type = VMMCALL_TYPE_VMCALL; // XXX: should get this value too.\n}\n\n\n\nvmmcall_get_function\u3067\u30cf\u30a4\u30d1\u30fc\u30b3\u30fc\u30eb\u306e\u756a\u53f7\u3092\u53d6\u5f97\u3067\u304d\u307e\u3059\u3002\u5f8c\u306fdrvhook\u3068\u3044\u3046\u65b0\u3057\u3044VMCALL(\u624b\u5143\u3067\u306f4\u756a\u306b\u306a\u308a\u307e\u3057\u305f)\u3092\u767a\u884c\u3057\u3066\u3001BitVisor\u306b\u30e2\u30b8\u30e5\u30fc\u30eb\u306e\u30a2\u30c9\u30ec\u30b9\u3092\u901a\u77e5\u3057\u307e\u3059\u3002\n\ntools/drvhook/drvhook.c\nstatic void\nvmcall_drvhook (void *mod)\n{\n  call_vmm_function_t drvf;\n  call_vmm_arg_t drv_a;\n  call_vmm_ret_t drv_r;\n  char drvhook[] = \"drvhook\";\n\n  vmmcall_get_function(drvhook, &drvf);\n  pr_info(\"drvhook number=%d\\n\",drvf.vmmcall_number);\n\n\n  drv_a.rbx = (intptr_t)mod;\n  call_vmm_call_function(&drvf, &drv_a, &drv_r);\n}\n\n\n\n\nBitVisor\u306bVMCALL\u3092\u8ffd\u52a0\u3059\u308b\n\u30b2\u30b9\u30c8\u306e\u30a8\u30fc\u30b8\u30a7\u30f3\u30c8\u30e2\u30b8\u30e5\u30fc\u30eb\u306f\u5b9f\u88c5\u3067\u304d\u305f\u306e\u3067\u3001\u3042\u3068\u306fBitVisor\u5074\u306bVMCALL\u3092\u8ffd\u52a0\u3057\u307e\u3059\u3002\u3068\u308a\u3042\u3048\u305a\u5f15\u6570\u3067\u6e21\u3063\u3066\u304d\u305f\u30e2\u30b8\u30e5\u30fc\u30eb\u306e\u30a2\u30c9\u30ec\u30b9\u3092\u8868\u793a\u3059\u308b\u3060\u3051\u3067\u3059\u3002\n\ncore/vmmcall_drvhook.c\n#include \"config.h\"\n#include \"constants.h\"\n#include \"current.h\"\n#include \"debug.h\"\n#include \"initfunc.h\"\n#include \"panic.h\"\n#include \"printf.h\"\n#include \"process.h\"\n#include \"thread.h\"\n#include \"spinlock.h\"\n#include \"vmmcall.h\"\n\nstatic void\ndrvhook(void)\n{\n  ulong drvaddr;\n  ulong ret = 0;\n  current->vmctl.read_general_reg(GENERAL_REG_RBX, &drvaddr);\n  printf(\"k2e: driver has loaded at 0x%lx\", drvaddr);\n  current->vmctl.write_general_reg(GENERAL_REG_RAX, (ulong)ret);\n}\n\nstatic void\nvmmcall_drvhook_init(void)\n{\n  vmmcall_register(\"drvhook\", drvhook);\n}\nINITFUNC (\"vmmcal0\", vmmcall_drvhook_init);\n\n\n\n\n\u5b9f\u884c\n\u3067\u306f\u5b9f\u969b\u306b\u5b9f\u884c\u3057\u3066\u307f\u307e\u3057\u3087\u3046\u3002\ntestmod\u3068\u3044\u3046\u30c6\u30b9\u30c8\u7528\u306e\u30e2\u30b8\u30e5\u30fc\u30eb\u3092\u66f8\u3044\u3066\u30d5\u30c3\u30af\u3057\u3066\u307f\u307e\u3059\u3002\nsudo insmod drvhook.ko target=\"testmod\"\nsudo insmod testmod.ko\ndmesg\u3067\u78ba\u8a8d\u3059\u308b\u3068\u3061\u3083\u3093\u3068\u30a8\u30fc\u30b8\u30a7\u30f3\u30c8\u304c\u52d5\u3044\u3066\u3044\u308b\u4e8b\u304c\u5206\u304b\u308a\u307e\u3059\u3002\n\n[   47.663567] system call replaced\n[   57.012967] call k2e_sys_finit_module\n[   57.014397] testmod: module license 'unspecified' taints kernel.\n[   57.014399] Disabling lock debugging due to kernel taint\n[   57.014696] try 'sudo mknod testdev c 200 0'\n[   57.014729] get_module(testmod) = ffffffffc095b100\n[   57.014732] vmmcall_string:ffff880117e7fef8, 0xffff880117e7fef8, drvhook\n[   57.014733] vmcall 0(arg=0xffff880117e7fef8)\n[   57.014751] drvhook number=4\n[   57.014753] vmcall 4(arg=0xffffffffc0959000)\n\ndbgsh\u3067BitVisor\u5074\u306e\u30ed\u30b0\u3092\u898b\u3066\u307f\u308b\u3068\nk2e: driver has loaded at 0xffffffffc0959000`\n\n\u3061\u3083\u3093\u3068\u30c9\u30e9\u30a4\u30d0\u306e\u6b63\u3057\u3044\u30ed\u30fc\u30c9\u5834\u6240\u304c\u691c\u77e5\u3067\u304d\u307e\u3057\u305f\u3002\n\u7c21\u5358\u306a\u51e6\u7406\u3067\u3059\u304c\u3001\u4e00\u65e5\u3061\u3087\u3063\u3068\u3067\u66f8\u3051\u3066\u3057\u307e\u3063\u305f\u3002BitVisor\u3059\u3054\u304f\u6271\u3044\u3084\u3059\u3044\u3002\n\u3053\u306e\u8a18\u4e8b\u306fBitVisor Advent Calendar 8\u65e5\u76ee\u306e\u8a18\u4e8b\u3067\u3059\uff0e\n\nBitVisor\u306bVMCALL\u3092\u8ffd\u52a0\u3059\u308b\u4e8b\u3067\u3001Linux\u4e0a\u3067\u306e\u30c7\u30d0\u30a4\u30b9\u30c9\u30e9\u30a4\u30d0\u306e\u30ed\u30fc\u30c9\u3092\u691c\u77e5\u3057\u3066\u307f\u307e\u3059\u3002\n\n# \u30b7\u30b9\u30c6\u30e0\u30b3\u30fc\u30eb\u30d5\u30c3\u30af\n\u30c7\u30d0\u30a4\u30b9\u30c9\u30e9\u30a4\u30d0\u306finsmod\u306a\u3069\u3067\u30ab\u30fc\u30cd\u30eb\u306b\u7d44\u307f\u8fbc\u307e\u308c\u307e\u3059\u3002\u3053\u306e\u6642init_module\u307e\u305f\u306ffinit_module\u30b7\u30b9\u30c6\u30e0\u30b3\u30fc\u30eb\u304c\u547c\u3070\u308c\u30c9\u30e9\u30a4\u30d0\u304c\u30ed\u30fc\u30c9\u3055\u308c\u308b\u308f\u3051\u3067\u3059\u304c\u3001\u3053\u308c\u3089\u306e\u30b7\u30b9\u30c6\u30e0\u30b3\u30fc\u30eb\u3092\u30d5\u30c3\u30af\u3057\u3066VMCALL\u3067BitVisor\u306b\u901a\u77e5\u3059\u308b\u3088\u3046\u306a\u30a8\u30fc\u30b8\u30a7\u30f3\u30c8\u306e\u5f79\u5272\u3092\u6301\u3064\u30ab\u30fc\u30cd\u30eb\u30e2\u30b8\u30e5\u30fc\u30eb\u3092\u958b\u767a\u3057\u3066\u307f\u307e\u3059\u3002\n\u30b7\u30b9\u30c6\u30e0\u30b3\u30fc\u30eb\u306e\u30d5\u30c3\u30af\u306fsys_call_table\u306e\u30da\u30fc\u30b8\u30d1\u30fc\u30df\u30c3\u30b7\u30e7\u30f3\u3092\u66f8\u304d\u8fbc\u307f\u53ef\u80fd\u306b\u5909\u66f4\u3057\u3066\u3001\u30d5\u30c3\u30af\u95a2\u6570\u306b\u3059\u3052\u66ff\u3048\u308b\u624b\u6cd5\u3092\u53d6\u308a\u307e\u3059\u3002\n- Linux\u30ab\u30fc\u30cd\u30eb\u3067system call\u306ehook http://kernhack.hatenablog.com/entry/2014/12/05/000346\n\n# \u30c9\u30e9\u30a4\u30d0\u306e\u30a2\u30c9\u30ec\u30b9\u53d6\u5f97\ninit_module\u306b\u3088\u3063\u3066\u8aad\u307f\u8fbc\u307e\u308c\u305f\u30e2\u30b8\u30e5\u30fc\u30eb\u306f\u5185\u90e8\u3067\u30ed\u30fc\u30c9\u51e6\u7406\u3092\u884c\u3044\u3001struct module->module_core\u30e1\u30f3\u30d0\u306b\u30ed\u30fc\u30c9\u3055\u308c\u305f\u30a2\u30c9\u30ec\u30b9\u304c\u683c\u7d0d\u3055\u308c\u307e\u3059\u3002\n\u3088\u3063\u3066init_module\u306e\u30d5\u30c3\u30af\u95a2\u6570\u5185\u3067\u3001\u30aa\u30ea\u30b8\u30ca\u30eb\u306einit_module\u3092\u5b9f\u884c\u3057\u3066\u30ed\u30fc\u30c9\u3055\u305b\u305f\u5f8c\u3001struct module\u3092\u53c2\u7167\u3057\u3066\u3084\u308c\u3070\u30ed\u30fc\u30c9\u30a2\u30c9\u30ec\u30b9\u304c\u53d6\u5f97\u3067\u304d\u307e\u3059\u3002\u5b9f\u969b\u306b\u8a72\u5f53\u51e6\u7406\u90e8\u5206\u306e\u30b3\u30fc\u30c9\u3092\u8f09\u305b\u307e\u3059\u3002\n\n```tools/drvhook/drvhook.c\nstatic struct module*\nget_module(const char *modname)\n{\n  struct module *mod = NULL;\n  if (mutex_lock_interruptible(&module_mutex) != 0) {\n    goto mutex_fail;\n  }\n\n  mod = find_module(modname);\n\n  mutex_unlock(&module_mutex);\nmutex_fail:\n  pr_info(\"get_module(%s) = %p\\n\", modname, mod);\n  return mod;\n}\n\nasmlinkage long\nk2e_sys_finit_module (int fd, const char __user *uargs, int flags)\n{\n  long orig;\n  struct module *mod = NULL;\n  pr_info(\"call k2e_sys_finit_module\\n\");\n\n  orig = orig_sys_finit_module (fd, uargs, flags);\n\n  mod = get_module(target);\n  if (mod)\n    vmcall_drvhook(mod->module_core);\n\n  return orig;\n}\n```\nk2e_sys_finit_module\u3068\u3044\u3046\u306e\u304c\u30d5\u30c3\u30af\u95a2\u6570\u3067\u3001find_module\u3067\u30bf\u30fc\u30b2\u30c3\u30c8\u3068\u3059\u308b\u30c9\u30e9\u30a4\u30d0\u3092\u691c\u7d22\u3057\u307e\u3059\u3002orig_sys_finit_module\u3067\u30aa\u30ea\u30b8\u30ca\u30eb\u3092\u5b9f\u884c\u3057\u305f\u5f8c\u306a\u306e\u3067\u3001\u3053\u306e\u6bb5\u968e\u3067\u306f\u65e2\u306b\u30ed\u30fc\u30c9\u304c\u5b8c\u4e86\u3057\u3066\u304a\u308a\u3001find_module\u3067\u60c5\u5831\u304c\u53d6\u5f97\u3067\u304d\u308b\u308f\u3051\u3067\u3059\u3002\n\n# BitVisor\u3078\u306e\u901a\u77e5\n\u3067\u306f\u53d6\u5f97\u3057\u305f\u30c9\u30e9\u30a4\u30d0\u306e\u30ed\u30fc\u30c9\u30a2\u30c9\u30ec\u30b9\u3092VMCALL\u3067BitVisor\u306b\u901a\u77e5\u3057\u3066\u307f\u307e\u3059\u3002\n\u901a\u5e38BitVisor\u306bVMCALL\u3092\u8ffd\u52a0\u3059\u308b\u306b\u306ftools/common/call_vmm.c\u306a\u3069\u3092\u4f7f\u3046\u306e\u3067\u3059\u304c\u3001\n\n- [\u53c2\u8003] BitVisor\u306bVMMCALL\u3092\u8ffd\u52a0\u3059\u308b\nhttp://qiita.com/deep_tkkn/items/ca794e66c25df9a9bf66\n\ncall_vmm.c\u306f\u305d\u306e\u307e\u307e\u3067\u306f\u30ab\u30fc\u30cd\u30eb\u30e2\u30b8\u30e5\u30fc\u30eb\u7528\u306b\u306f\u30b3\u30f3\u30d1\u30a4\u30eb\u3067\u304d\u306a\u3044\u306e\u3067\u3001\u5fc5\u8981\u306a\u90e8\u5206\u3060\u3051\u3092\u5207\u308a\u51fa\u3057\u3066\u4f7f\u7528\u3057\u307e\u3057\u305f\u3002\u3088\u3063\u3066\u30cf\u30a4\u30d1\u30fc\u30b3\u30fc\u30eb\u756a\u53f7\u53d6\u5f97\u306e\u305f\u3081\u306eCALL_VMM_GET_FUNCTION\u30de\u30af\u30ed\u306a\u3069\u3092\u4f7f\u308f\u305a\u3001\u4e00\u90e8\u518d\u5b9f\u88c5\u3057\u3066\u30ab\u30fc\u30cd\u30eb\u30e2\u30b8\u30e5\u30fc\u30eb\u304b\u3089\u3082\u4f7f\u3048\u308b\u3088\u3046\u306b\u3057\u307e\u3057\u305f\u3002\n\n```tools/drvhook/drvhook.c\nMODULE_DESCRIPTION(\"guest driver hook for k2e\");\nMODULE_AUTHOR(\"rkx1209\");\nMODULE_LICENSE(\"GPL\");\n\n/* following string SYSCALL_TABLE_ADDRESS will be replaced by set_syscall_table_address.sh */\nstatic void **syscall_table = (void *) 0xffffffff81a001c0;\nstatic char *target = \"blahblah\";\nmodule_param(target, charp, S_IRUGO);\n\nasmlinkage long (*orig_sys_init_module)(void __user *umod, unsigned long len, const char __user *uargs);\nasmlinkage long (*orig_sys_finit_module)(int fd, const char __user *uargs, int flags);\n\n\nvoid\ncall_vmm_call_function (call_vmm_function_t *function,\n                        call_vmm_arg_t *arg, call_vmm_ret_t *ret)\n{\n  struct call_vmm_call_function_sub_data data;\n  data.function = function;\n  data.arg = arg;\n  data.ret = ret;\n  pr_info(\"vmcall %d(arg=0x%lx)\\n\", data.function->vmmcall_number, data.arg->rbx);\n  switch (data.function->vmmcall_type) {\n  \tcase VMMCALL_TYPE_VMCALL:\n  \t\tasm volatile (\"vmcall\"\n  \t\t\t           : \"=a\" (data.ret->rax), \"=b\" (data.ret->rbx),\n\t\t\t\t             \"=c\" (data.ret->rcx), \"=d\" (data.ret->rdx),\n  \t\t\t\t           \"=S\" (data.ret->rsi), \"=D\" (data.ret->rdi)\n  \t\t\t           : \"a\" (data.function->vmmcall_number),\n  \t\t\t\t           \"b\" (data.arg->rbx),\n  \t\t\t\t           \"c\" (data.arg->rcx), \"d\" (data.arg->rdx),\n  \t\t\t\t           \"S\" (data.arg->rsi), \"D\" (data.arg->rdi)\n  \t\t\t           : \"memory\");\n  \t\tbreak;\n  \tcase VMMCALL_TYPE_VMMCALL:\n  \t\tasm volatile (\"vmmcall\"\n  \t\t\t           : \"=a\" (data.ret->rax), \"=b\" (data.ret->rbx),\n  \t\t\t\t           \"=c\" (data.ret->rcx), \"=d\" (data.ret->rdx),\n  \t\t\t\t           \"=S\" (data.ret->rsi), \"=D\" (data.ret->rdi)\n  \t\t\t           : \"a\" (data.function->vmmcall_number),\n  \t\t\t\t           \"b\" (data.arg->rbx),\n              \t\t\t \"c\" (data.arg->rcx), \"d\" (data.arg->rdx),\n              \t\t\t \"S\" (data.arg->rsi), \"D\" (data.arg->rdi)\n  \t\t\t           : \"memory\");\n  \t\tbreak;\n  \t}\n}\n\n/* Get a entry number of specified vmmcall */\nvoid\nvmmcall_get_function(const char *vmmcall, call_vmm_function_t *res)\n{\n  call_vmm_function_t gf;\n  call_vmm_arg_t gf_a;\n  call_vmm_ret_t gf_r;\n\n  gf.vmmcall_number = GET_VMMCALL_NUMBER;\n  gf.vmmcall_type = VMMCALL_TYPE_VMCALL;\n  gf_a.rbx = (intptr_t)vmmcall;\n  pr_info(\"vmmcall_string:%p, 0x%lx, %s\\n\", vmmcall, gf_a.rbx, vmmcall);\n  call_vmm_call_function(&gf, &gf_a, &gf_r);\n\n  /* RAX = vmmcall number */\n  res->vmmcall_number = (int)gf_r.rax;\n  res->vmmcall_type = VMMCALL_TYPE_VMCALL; // XXX: should get this value too.\n}\n\n```\nvmmcall_get_function\u3067\u30cf\u30a4\u30d1\u30fc\u30b3\u30fc\u30eb\u306e\u756a\u53f7\u3092\u53d6\u5f97\u3067\u304d\u307e\u3059\u3002\u5f8c\u306fdrvhook\u3068\u3044\u3046\u65b0\u3057\u3044VMCALL(\u624b\u5143\u3067\u306f4\u756a\u306b\u306a\u308a\u307e\u3057\u305f)\u3092\u767a\u884c\u3057\u3066\u3001BitVisor\u306b\u30e2\u30b8\u30e5\u30fc\u30eb\u306e\u30a2\u30c9\u30ec\u30b9\u3092\u901a\u77e5\u3057\u307e\u3059\u3002\n\n```tools/drvhook/drvhook.c\nstatic void\nvmcall_drvhook (void *mod)\n{\n  call_vmm_function_t drvf;\n  call_vmm_arg_t drv_a;\n  call_vmm_ret_t drv_r;\n  char drvhook[] = \"drvhook\";\n\n  vmmcall_get_function(drvhook, &drvf);\n  pr_info(\"drvhook number=%d\\n\",drvf.vmmcall_number);\n\n\n  drv_a.rbx = (intptr_t)mod;\n  call_vmm_call_function(&drvf, &drv_a, &drv_r);\n}\n\n```\n\n# BitVisor\u306bVMCALL\u3092\u8ffd\u52a0\u3059\u308b\n\u30b2\u30b9\u30c8\u306e\u30a8\u30fc\u30b8\u30a7\u30f3\u30c8\u30e2\u30b8\u30e5\u30fc\u30eb\u306f\u5b9f\u88c5\u3067\u304d\u305f\u306e\u3067\u3001\u3042\u3068\u306fBitVisor\u5074\u306bVMCALL\u3092\u8ffd\u52a0\u3057\u307e\u3059\u3002\u3068\u308a\u3042\u3048\u305a\u5f15\u6570\u3067\u6e21\u3063\u3066\u304d\u305f\u30e2\u30b8\u30e5\u30fc\u30eb\u306e\u30a2\u30c9\u30ec\u30b9\u3092\u8868\u793a\u3059\u308b\u3060\u3051\u3067\u3059\u3002\n\n```core/vmmcall_drvhook.c\n#include \"config.h\"\n#include \"constants.h\"\n#include \"current.h\"\n#include \"debug.h\"\n#include \"initfunc.h\"\n#include \"panic.h\"\n#include \"printf.h\"\n#include \"process.h\"\n#include \"thread.h\"\n#include \"spinlock.h\"\n#include \"vmmcall.h\"\n\nstatic void\ndrvhook(void)\n{\n  ulong drvaddr;\n  ulong ret = 0;\n  current->vmctl.read_general_reg(GENERAL_REG_RBX, &drvaddr);\n  printf(\"k2e: driver has loaded at 0x%lx\", drvaddr);\n  current->vmctl.write_general_reg(GENERAL_REG_RAX, (ulong)ret);\n}\n\nstatic void\nvmmcall_drvhook_init(void)\n{\n  vmmcall_register(\"drvhook\", drvhook);\n}\nINITFUNC (\"vmmcal0\", vmmcall_drvhook_init);\n\n```\n\n# \u5b9f\u884c\n\u3067\u306f\u5b9f\u969b\u306b\u5b9f\u884c\u3057\u3066\u307f\u307e\u3057\u3087\u3046\u3002\ntestmod\u3068\u3044\u3046\u30c6\u30b9\u30c8\u7528\u306e\u30e2\u30b8\u30e5\u30fc\u30eb\u3092\u66f8\u3044\u3066\u30d5\u30c3\u30af\u3057\u3066\u307f\u307e\u3059\u3002\n`sudo insmod drvhook.ko target=\"testmod\"`\n`sudo insmod testmod.ko`\n\ndmesg\u3067\u78ba\u8a8d\u3059\u308b\u3068\u3061\u3083\u3093\u3068\u30a8\u30fc\u30b8\u30a7\u30f3\u30c8\u304c\u52d5\u3044\u3066\u3044\u308b\u4e8b\u304c\u5206\u304b\u308a\u307e\u3059\u3002\n\n```text\n\n[   47.663567] system call replaced\n[   57.012967] call k2e_sys_finit_module\n[   57.014397] testmod: module license 'unspecified' taints kernel.\n[   57.014399] Disabling lock debugging due to kernel taint\n[   57.014696] try 'sudo mknod testdev c 200 0'\n[   57.014729] get_module(testmod) = ffffffffc095b100\n[   57.014732] vmmcall_string:ffff880117e7fef8, 0xffff880117e7fef8, drvhook\n[   57.014733] vmcall 0(arg=0xffff880117e7fef8)\n[   57.014751] drvhook number=4\n[   57.014753] vmcall 4(arg=0xffffffffc0959000)\n```\ndbgsh\u3067BitVisor\u5074\u306e\u30ed\u30b0\u3092\u898b\u3066\u307f\u308b\u3068\n\n```text\nk2e: driver has loaded at 0xffffffffc0959000`\n```\n\n\u3061\u3083\u3093\u3068\u30c9\u30e9\u30a4\u30d0\u306e\u6b63\u3057\u3044\u30ed\u30fc\u30c9\u5834\u6240\u304c\u691c\u77e5\u3067\u304d\u307e\u3057\u305f\u3002\n\n\u7c21\u5358\u306a\u51e6\u7406\u3067\u3059\u304c\u3001\u4e00\u65e5\u3061\u3087\u3063\u3068\u3067\u66f8\u3051\u3066\u3057\u307e\u3063\u305f\u3002BitVisor\u3059\u3054\u304f\u6271\u3044\u3084\u3059\u3044\u3002\n", "tags": ["BitVisor"]}