{"tags": ["Ruby2.0.0", "Clojure"], "context": " More than 1 year has passed since last update.Clojure\u306eloop-recur\u3092\u3001Ruby\u3067\u3084\u3063\u305f\u3002Elixir\u306e\u53e4\u3044version\u306b\u3082\u6709\u3063\u305f\u3089\u3057\u3044\u3002\n\u672b\u5c3e\u518d\u5e30\u306e\u6700\u9069\u5316 (TCO, tail call optimization) \u304c\u51fa\u6765\u306a\u3044system\u3060\u3068\u3001\u52a9\u304b\u308b\u307f\u305f\u3044\u3002Ruby 2.0.0\u3068\u304bClojure\u307f\u305f\u3044\u306a\u3002\ndef factorial n\n  cloop n, 1 do |n, acc|\n    if n == 0\n      acc\n    else\n      recur n - 1, acc * n\n    end\n  end\nend\n\n\u307f\u305f\u3044\u306b\u4f7f\u3075\u3002\ninstance_eval\u3057\u304b\u77e5\u3089\u306a\u304f\u3066\u3001instance_exec\u3092\u898b\u9644\u3051\u51fa\u3059\u306e\u306b\u4e00\u756a\u6642\u9593\u304c\u639b\u3063\u305f\u3002\u30a2\u30db\u3060\u3002\nRuby\u3060\u3068\u3001\u672b\u5c3e\u518d\u5e30\u3092loop\u306b\u5909\u63db\u3059\u308bmethod\u5b9f\u88c5\u4f8b\u3068\u304b\u3082\u3001\u691c\u7d22\u3059\u308c\u3070\u898b\u9644\u304b\u308b\u3051\u3069\u3002\ncf. Ruby\u3067\u672b\u5c3e\u518d\u5e30\u6700\u9069\u5316\u3092\u3059\u308b\u3002 - athos\u306e\u65e5\u8a18\ncf. Ruby\u306e\u672b\u5c3e\u518d\u5e30\u6700\u9069\u5316\u3092\u7406\u89e3\u3059\u308b\n\u56e0\u307f\u306b\u591a\u5206\u3001\u6b21\u306eversion\u306b\u306f\u5165\u308b\u3093\u3058\u3083\u306a\u3044\u304b\u306a\u3002\ncf. CRuby\u3067\u672b\u5c3e\u6700\u9069\u5316\u3092\u4f7f\u3063\u305f\u518d\u5e30 - yarb\u306e\u65e5\u8a18\ncf. 10 Things You Didn't Know Ruby Could do - SSSSLIDE\n\u500b\u4eba\u7684\u306b\u306fTCO\u304c\u7121\u304f\u3066\u3082\u3001\u6b86\u3069\u306e\u5834\u5408\u306fEnumerable\u3092\u4f7f\u3078\u3070\u56f0\u3063\u3066\u306a\u3044\u3002\u5076\u306b\u6b32\u3057\u3044\u4e8b\u304c\u6709\u308b\u3002\n\n\u5b9f\u88c5\n# license: Public Domain\n\n$DEBUG = true\n\n# {{{ util\n\n# Ruby\u3067\u3001D\u8a00\u8a9e\u98a8\u306bassertion\u3092\u76f4\u66f8\u304d\u3059\u308b\u7c21\u6613unit test - c4se\u8a18\uff1a\u3055\u3063\u3061\u3083\u3093\u3067\u3059\u3088\u2606\n# http://c4se.hatenablog.com/entry/2013/08/15/022137\n#\n# @param test_name [String]\ndef unittest test_name, &proc\n  if $DEBUG\n    include Test::Unit::Assertions\n    proc.call\n    puts \"#{test_name} ok.\"\n  end\nend\nif $DEBUG\n  require 'test/unit/assertions'\nend\n\n# }}}\n\n# loop-recur like Clojure special form\n# http://clojure.org/special_forms#Special%20Forms--(recur%20exprs*)\nclass LoopRecur\n  def initialize proc\n    @proc = proc\n    @params = []\n  end\n\n  def eval params = []\n    @params = params\n    start\n  end\n\n  private\n  def start\n    v = self\n    while v == self\n      v = instance_exec *@params, &@proc\n    end\n    v\n  end\n\n  def recur *params\n    @params = params\n    self\n  end\nend\n\nmodule Kernel\n  def cloop *params, &proc\n    LoopRecur.new(proc).eval(params)\n  end\nend\n\nunittest 'loop-recur works' do\n  v = cloop 5, 0 do |n, acc|\n    if n <= 0\n      acc\n    else\n      recur n - 1, acc + n\n    end\n  end\n  assert_equal 15, v\nend\n\nunittest 'loop-recur can make tail recurusion' do\n  v = cloop 1 do |n|\n    if n == 10000\n      n\n    else\n      recur n + 1\n    end\n  end\n  assert_equal 10000, v\nend\n# vim:set et sw=2 sts=2 ff=unix foldmethod=marker:\n\ncf. Ruby\u3067Clojure\u98a8loop-recur (\u672b\u5c3e\u518d\u5e30) - c4se\u8a18\uff1a\u3055\u3063\u3061\u3083\u3093\u3067\u3059\u3088\u2606\n<a href=\"http://clojure.org/special_forms#Special%20Forms--(recur%20exprs*)\">Clojure\u306eloop-recur</a>\u3092\u3001Ruby\u3067\u3084\u3063\u305f\u3002Elixir\u306e\u53e4\u3044version\u306b\u3082\u6709\u3063\u305f\u3089\u3057\u3044\u3002\n\u672b\u5c3e\u518d\u5e30\u306e\u6700\u9069\u5316 (TCO, tail call optimization) \u304c\u51fa\u6765\u306a\u3044system\u3060\u3068\u3001\u52a9\u304b\u308b\u307f\u305f\u3044\u3002Ruby 2.0.0\u3068\u304bClojure\u307f\u305f\u3044\u306a\u3002\n\n```rb\ndef factorial n\n  cloop n, 1 do |n, acc|\n    if n == 0\n      acc\n    else\n      recur n - 1, acc * n\n    end\n  end\nend\n```\n\u307f\u305f\u3044\u306b\u4f7f\u3075\u3002\n<code>instance_eval</code>\u3057\u304b\u77e5\u3089\u306a\u304f\u3066\u3001<code>instance_exec</code>\u3092\u898b\u9644\u3051\u51fa\u3059\u306e\u306b\u4e00\u756a\u6642\u9593\u304c\u639b\u3063\u305f\u3002\u30a2\u30db\u3060\u3002\n\nRuby\u3060\u3068\u3001\u672b\u5c3e\u518d\u5e30\u3092loop\u306b\u5909\u63db\u3059\u308bmethod\u5b9f\u88c5\u4f8b\u3068\u304b\u3082\u3001\u691c\u7d22\u3059\u308c\u3070\u898b\u9644\u304b\u308b\u3051\u3069\u3002\n<i>cf.</i> [Ruby\u3067\u672b\u5c3e\u518d\u5e30\u6700\u9069\u5316\u3092\u3059\u308b\u3002 - athos\u306e\u65e5\u8a18](http://d.hatena.ne.jp/athos/20110119/p1)\n<i>cf.</i> [Ruby\u306e\u672b\u5c3e\u518d\u5e30\u6700\u9069\u5316\u3092\u7406\u89e3\u3059\u308b](http://melborne.github.io/2011/01/20/Ruby/)\n\u56e0\u307f\u306b\u591a\u5206\u3001\u6b21\u306eversion\u306b\u306f\u5165\u308b\u3093\u3058\u3083\u306a\u3044\u304b\u306a\u3002\n<i>cf.</i> [CRuby\u3067\u672b\u5c3e\u6700\u9069\u5316\u3092\u4f7f\u3063\u305f\u518d\u5e30 - yarb\u306e\u65e5\u8a18](http://d.hatena.ne.jp/yarb/20121029/p1)\n<i>cf.</i> [10 Things You Didn't Know Ruby Could do - SSSSLIDE](http://sssslide.com/speakerdeck.com/jeg2/10-things-you-didnt-know-ruby-could-do#43)\n\u500b\u4eba\u7684\u306b\u306fTCO\u304c\u7121\u304f\u3066\u3082\u3001\u6b86\u3069\u306e\u5834\u5408\u306fEnumerable\u3092\u4f7f\u3078\u3070\u56f0\u3063\u3066\u306a\u3044\u3002\u5076\u306b\u6b32\u3057\u3044\u4e8b\u304c\u6709\u308b\u3002\n\n# \u5b9f\u88c5\n\n```rb\n# license: Public Domain\n\n$DEBUG = true\n\n# {{{ util\n\n# Ruby\u3067\u3001D\u8a00\u8a9e\u98a8\u306bassertion\u3092\u76f4\u66f8\u304d\u3059\u308b\u7c21\u6613unit test - c4se\u8a18\uff1a\u3055\u3063\u3061\u3083\u3093\u3067\u3059\u3088\u2606\n# http://c4se.hatenablog.com/entry/2013/08/15/022137\n#\n# @param test_name [String]\ndef unittest test_name, &proc\n  if $DEBUG\n    include Test::Unit::Assertions\n    proc.call\n    puts \"#{test_name} ok.\"\n  end\nend\nif $DEBUG\n  require 'test/unit/assertions'\nend\n\n# }}}\n\n# loop-recur like Clojure special form\n# http://clojure.org/special_forms#Special%20Forms--(recur%20exprs*)\nclass LoopRecur\n  def initialize proc\n    @proc = proc\n    @params = []\n  end\n\n  def eval params = []\n    @params = params\n    start\n  end\n\n  private\n  def start\n    v = self\n    while v == self\n      v = instance_exec *@params, &@proc\n    end\n    v\n  end\n\n  def recur *params\n    @params = params\n    self\n  end\nend\n\nmodule Kernel\n  def cloop *params, &proc\n    LoopRecur.new(proc).eval(params)\n  end\nend\n\nunittest 'loop-recur works' do\n  v = cloop 5, 0 do |n, acc|\n    if n <= 0\n      acc\n    else\n      recur n - 1, acc + n\n    end\n  end\n  assert_equal 15, v\nend\n\nunittest 'loop-recur can make tail recurusion' do\n  v = cloop 1 do |n|\n    if n == 10000\n      n\n    else\n      recur n + 1\n    end\n  end\n  assert_equal 10000, v\nend\n# vim:set et sw=2 sts=2 ff=unix foldmethod=marker:\n```\n\n<i>cf.</i> [Ruby\u3067Clojure\u98a8loop-recur (\u672b\u5c3e\u518d\u5e30) - c4se\u8a18\uff1a\u3055\u3063\u3061\u3083\u3093\u3067\u3059\u3088\u2606](http://c4se.hatenablog.com/entry/2013/09/05/184937)"}