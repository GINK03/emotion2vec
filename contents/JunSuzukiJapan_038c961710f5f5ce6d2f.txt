{"context": "\u30bb\u30df\u30b3\u30ed\u30f3\u30ec\u30b9\u3067\u30af\u30a4\u30c3\u30af\u30bd\u30fc\u30c8\u3092\u66f8\u3044\u3066\u307f\u305f\u3044\u306e\u3060\u3051\u308c\u3069\u3001\u3068\u308a\u3042\u3048\u305a\u666e\u901a\u306b\u30af\u30a4\u30c3\u30af\u30bd\u30fc\u30c8\u3092\u66f8\u3044\u3066\u307f\u305f\u899a\u66f8\u3002\n\nquicksort.rs\npub fn quicksort<T: Ord + Copy>(numbers: &mut [T]) {\n    let last: usize = numbers.len() - 1;\n    q_sort(numbers, 0, last);\n}\n\nfn q_sort<T: Ord + Copy>(numbers: &mut [T], left: usize, right: usize) {\n    let pivot = numbers[left];\n    let mut l = left;\n    let mut r = right;\n    while l < r {\n        while (numbers[r] >= pivot) && (l < r) {\n            r = r - 1;\n        }\n        if l != r {\n            numbers[l] = numbers[r];\n            l = l + 1;\n        }\n        while (numbers[l] <= pivot) && (l < r) {\n            l = l + 1;\n        }\n        if l != r {\n            numbers[r] = numbers[l];\n            r = r - 1;\n        }\n    }\n    numbers[l] = pivot;\n    if left < l {\n        q_sort(numbers, left, l - 1);\n    } \n    if right > l {\n        q_sort(numbers, l + 1, right);\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*; // \u5916\u306e\u5b9a\u7fa9\u306b\u30a2\u30af\u30bb\u30b9\u3059\u308b\u305f\u3081 use\n\n    #[test]\n    fn test_quicksort(){\n        let mut numbers = [5, 3, 1, 6, 8, 4, 7, 2];\n        quicksort(&mut numbers);\n        assert_eq!([1, 2, 3, 4, 5, 6, 7, 8], numbers);\n    }\n}\n\n\n\u53c2\u8003: http://www.codereading.com/algo_and_ds/algo/quick_sort.html\n\n\u30bb\u30df\u30b3\u30ed\u30f3\u30ec\u30b9\u3067\u30af\u30a4\u30c3\u30af\u30bd\u30fc\u30c8\u3092\u66f8\u3044\u3066\u307f\u305f\u3044\u306e\u3060\u3051\u308c\u3069\u3001\u3068\u308a\u3042\u3048\u305a\u666e\u901a\u306b\u30af\u30a4\u30c3\u30af\u30bd\u30fc\u30c8\u3092\u66f8\u3044\u3066\u307f\u305f\u899a\u66f8\u3002\n\n```rust:quicksort.rs\npub fn quicksort<T: Ord + Copy>(numbers: &mut [T]) {\n    let last: usize = numbers.len() - 1;\n    q_sort(numbers, 0, last);\n}\n\nfn q_sort<T: Ord + Copy>(numbers: &mut [T], left: usize, right: usize) {\n    let pivot = numbers[left];\n    let mut l = left;\n    let mut r = right;\n    while l < r {\n        while (numbers[r] >= pivot) && (l < r) {\n            r = r - 1;\n        }\n        if l != r {\n            numbers[l] = numbers[r];\n            l = l + 1;\n        }\n        while (numbers[l] <= pivot) && (l < r) {\n            l = l + 1;\n        }\n        if l != r {\n            numbers[r] = numbers[l];\n            r = r - 1;\n        }\n    }\n    numbers[l] = pivot;\n    if left < l {\n        q_sort(numbers, left, l - 1);\n    } \n    if right > l {\n        q_sort(numbers, l + 1, right);\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*; // \u5916\u306e\u5b9a\u7fa9\u306b\u30a2\u30af\u30bb\u30b9\u3059\u308b\u305f\u3081 use\n\n    #[test]\n    fn test_quicksort(){\n        let mut numbers = [5, 3, 1, 6, 8, 4, 7, 2];\n        quicksort(&mut numbers);\n        assert_eq!([1, 2, 3, 4, 5, 6, 7, 8], numbers);\n    }\n}\n```\n\n\u53c2\u8003: [http://www.codereading.com/algo_and_ds/algo/quick_sort.html](http://www.codereading.com/algo_and_ds/algo/quick_sort.html)\n", "tags": ["rust"]}