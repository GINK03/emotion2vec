{"context": "\n\n\u306f\u3058\u3081\u306b\n\u5148\u306e\u8a18\u4e8b\u306e\u4e88\u544a\u306e\u901a\u308a\u3001nobarrier\u3068journal_async_commit\u304c\u3069\u3046\u52d5\u304f\u306e\u304b\u306b\u3064\u3044\u3066\u306e\u8a73\u7d30\u306e\u8abf\u67fb\u3092\u5b9f\u65bd\u3057\u305f\u3002\n\u306a\u304a\u3001\u307b\u3084\u307b\u3084\u306eLinux-4.10\u304f\u3089\u3044\u3092\u898b\u3066\u3044\u307e\u3059\u3002\n\nDocumentation\nkernel/Documentation/filesystems/ext4.txt\u3088\u308a\n185 barrier=<0|1(*)>        This enables/disables the use of write barriers in\n186 barrier(*)              the jbd code.  barrier=0 disables, barrier=1 enables.\n187 nobarrier               This also requires an IO stack which can support\n188                         barriers, and if jbd gets an error on a barrier\n189                         write, it will disable again with a warning.\n190                         Write barriers enforce proper on-disk ordering\n191                         of journal commits, making volatile disk write caches\n192                         safe to use, at some performance penalty.  If\n193                         your disks are battery-backed in one way or another,\n194                         disabling barriers may safely improve performance.\n195                         The mount options \"barrier\" and \"nobarrier\" can\n196                         also be used to enable or disable barriers, for\n197                         consistency with other ext4 mount options.\n\n142 journal_async_commit    Commit block can be written to disk without waiting\n143                         for descriptor blocks. If enabled older kernels cannot\n144                         mount the device. This will enable 'journal_checksum'\n145                         internally.\n\n\nnobarrier\n\n\u30aa\u30d7\u30b7\u30e7\u30f3\u6307\u5b9a\u306e\u8a31\u5bb9\u5ea6\nnobarrier, \u3082\u3057\u304f\u306f barrier, barrier=[0|1]\u3067\u3044\u3051\u308b\n\n\u30b3\u30fc\u30c9\u3092\u8aad\u3080\nkernel/fs/ext4/super.c\u3088\u308a\u3001barrier\u306e\u3068\u304d\u306bEXT4_MOUNT_BARRIER\u304c\u7acb\u3064\u3053\u3068\u304c\u308f\u304b\u308b\u3002\n\nsuper.c\n1352         {Opt_barrier, \"barrier=%u\"},\n1353         {Opt_barrier, \"barrier\"},\n1354         {Opt_nobarrier, \"nobarrier\"},\n\n\n\nsuper.c\n1534         {Opt_barrier, EXT4_MOUNT_BARRIER, MOPT_SET},\n1535         {Opt_nobarrier, EXT4_MOUNT_BARRIER, MOPT_CLEAR},\n\n\nkernel/fs/ext4/super.c:ext4_init_journal_params()\u3088\u308a\u3001jbd2\u306b\u6e21\u3059\u30aa\u30d7\u30b7\u30e7\u30f3\u3092\u4f5c\u3063\u3066\u3044\u308b\u3002\u3064\u307e\u308ajbd2\u306e\u4e2d\u3067\u306fJBD2_BARRIER\u3092\u8ffd\u3048\u3070\u3088\u3044\u3068\u308f\u304b\u308b\u3002\n\nsuper.c\n4308         if (test_opt(sb, BARRIER))\n4309                 journal->j_flags |= JBD2_BARRIER;\n4310         else\n4311                 journal->j_flags &= ~JBD2_BARRIER;\n\n\n\next4\u306e\u30b3\u30fc\u30c9\u3092\u8aad\u3080\nkernel/fs/ext4/super.c:ext4_fill_super()\u3088\u308a\u3001DEFM\u306bnobarrier\u304c\u306a\u3044\u6642\u306fEXT4_MOUNT_BARRIER\u3092\u7acb\u3063\u3066\u3044\u308b\u3002DEFM\u306fext4\u306esuperblock\u306b\u66f8\u304b\u308c\u308b\u30c7\u30d5\u30a9\u30eb\u30c8\u30de\u30a6\u30f3\u30c8\u30aa\u30d7\u30b7\u30e7\u30f3\u306e\u3053\u3068\u3002\n\nsuper.c\n3478         if ((def_mount_opts & EXT4_DEFM_NOBARRIER) == 0)\n3479                 set_opt(sb, BARRIER);\n\n\nkernel/fs/ext4/super.c:ext4_load_journal()\u3088\u308a\u3001KERN_INFO\u306b\u30e1\u30c3\u30bb\u30fc\u30b8\u3092\u66f8\u3044\u3066\u3044\u308b\u3002\u9006\u306b\u8a00\u3048\u3070\u3001dmesg\u3092\u898b\u308c\u3070nobarrier\u3060\u3063\u305f\u304b\u3069\u3046\u304b\u304c\u308f\u304b\u308b\u3002\n\nsuper.c\n4524         if (!(journal->j_flags & JBD2_BARRIER))\n4525                 ext4_msg(sb, KERN_INFO, \"barriers disabled\");\n\n\nkernel/fs/ext4/super.c:ext4_commit_super()\u3088\u308a\u3001superblock\u3092sync\u3067\u66f8\u304f\u6642\u306bREQ_FUA\u304bREQ_SYNC\u304b\u3092\u9078\u3093\u3067\u3044\u308b\u3002\n\nsuper.c\n4616         if (sync) {\n4617                 unlock_buffer(sbh);\n4618                 error = __sync_dirty_buffer(sbh,\n4619                         test_opt(sb, BARRIER) ? REQ_FUA : REQ_SYNC);\n4620                 if (error)\n4621                         return error;\n4622 \n4623                 error = buffer_write_io_error(sbh);\n4624                 if (error) {\n4625                         ext4_msg(sb, KERN_ERR, \"I/O error while writing \"\n4626                                \"superblock\");\n4627                         clear_buffer_write_io_error(sbh);\n4628                         set_buffer_uptodate(sbh);\n4629                 }\n4630         }\n\n\nkernel/fs/ext4/super.c:ext4_sync_fs()\u3088\u308a\u3001sync\u306e\u6700\u5f8c\u306bblkdev_issue_flush()\u3092\u547c\u3076(REQ_OP_FLUSH\u3092\u9001\u308b)\u5fc5\u8981\u304c\u3042\u308b\u304b\u3069\u3046\u304b\u3092\u78ba\u8a8d\u3057\u3066\u3044\u308b\u3002\u30b3\u30e1\u30f3\u30c8\u306b\u3042\u308b\u3088\u3046\u306b\u3001\u300cwriteback\u306ainode\u3092\u66f8\u304d\u51fa\u3057\u305f\u3051\u3069journal\u306f\u306a\u306b\u3082\u66f8\u304d\u51fa\u3059\u5fc5\u8981\u304c\u306a\u304b\u3063\u305f\u300d\u3088\u3046\u306a\u5834\u5408\u304c\u8a72\u5f53\u3059\u308b\u3068\u601d\u308f\u308c\u308b\u3002\n\nsuper.c\n4730         /*\n4731          * Data writeback is possible w/o journal transaction, so barrier must\n4732          * being sent at the end of the function. But we can skip it if\n4733          * transaction_commit will do it for us.\n4734          */\n4735         if (sbi->s_journal) {\n4736                 target = jbd2_get_latest_transaction(sbi->s_journal);\n4737                 if (wait && sbi->s_journal->j_flags & JBD2_BARRIER &&\n4738                     !jbd2_trans_will_send_data_barrier(sbi->s_journal, target))\n4739                         needs_barrier = true;\n4740 \n4741                 if (jbd2_journal_start_commit(sbi->s_journal, &target)) {\n4742                         if (wait)\n4743                                 ret = jbd2_log_wait_commit(sbi->s_journal,\n4744                                                            target);\n4745                 }\n4746         } else if (wait && test_opt(sb, BARRIER))\n4747                 needs_barrier = true;\n4748         if (needs_barrier) {\n4749                 int err;\n4750                 err = blkdev_issue_flush(sb->s_bdev, GFP_KERNEL, NULL);\n4751                 if (!ret)\n4752                         ret = err;\n4753         }\n\n\nkernel/fs/ext4/fsync.c:ext4_sync_file()\u3088\u308a\u3001\u304a\u304a\u3080\u306d\u5148\u3068\u540c\u3058\u3088\u3046\u306a\u3053\u3068\u3092\u3084\u3063\u3066\u3044\u308b\u3002\n\nfsync.c\n115         if (!journal) {\n116                 ret = __generic_file_fsync(file, start, end, datasync);\n117                 if (!ret)\n118                         ret = ext4_sync_parent(inode);\n119                 if (test_opt(inode->i_sb, BARRIER))\n120                         goto issue_flush;\n121                 goto out;\n122         }\n123 \n124         ret = filemap_write_and_wait_range(inode->i_mapping, start, end);\n125         if (ret)\n126                 return ret;\n127         /*\n128          * data=writeback,ordered:\n129          *  The caller's filemap_fdatawrite()/wait will sync the data.\n130          *  Metadata is in the journal, we wait for proper transaction to\n131          *  commit here.\n132          *\n133          * data=journal:\n134          *  filemap_fdatawrite won't do anything (the buffers are clean).\n135          *  ext4_force_commit will write the file data into the journal and\n136          *  will wait on that.\n137          *  filemap_fdatawait() will encounter a ton of newly-dirtied pages\n138          *  (they were dirtied by commit).  But that's OK - the blocks are\n139          *  safe in-journal, which is all fsync() needs to ensure.\n140          */\n141         if (ext4_should_journal_data(inode)) {\n142                 ret = ext4_force_commit(inode->i_sb);\n143                 goto out;\n144         }\n145 \n146         commit_tid = datasync ? ei->i_datasync_tid : ei->i_sync_tid;\n147         if (journal->j_flags & JBD2_BARRIER &&\n148             !jbd2_trans_will_send_data_barrier(journal, commit_tid))\n149                 needs_barrier = true;\n150         ret = jbd2_complete_transaction(journal, commit_tid);\n151         if (needs_barrier) {\n152         issue_flush:\n153                 err = blkdev_issue_flush(inode->i_sb->s_bdev, GFP_KERNEL, NULL);\n154                 if (!ret)\n155                         ret = err;\n156         }\n\n\n\njbd2\u306e\u30b3\u30fc\u30c9\u3092\u8aad\u3080\next4\u306e\u30b3\u30fc\u30c9\u3088\u308a\u3001JBD2_BARRIER\u3092\u8ffd\u3048\u3070\u826f\u3044\u3053\u3068\u304c\u308f\u304b\u3063\u3066\u3044\u308b\u3002\nkernel/fs/jbd2/journal.c:jbd2_trans_will_send_data_barrier()\u3088\u308a\u3001JBD2_BARRIER\u304c\u306a\u3044\u5834\u5408\u306fREQ_OP_FLUSH\u3092\u9001\u3089\u306a\u3044\u4e88\u5b9a\u3060\u3068\u3057\u3066\u3044\u308b\u3002\n\njournal.c\n656         if (!(journal->j_flags & JBD2_BARRIER))\n657                 return 0;\n\n\nkernel/fs/jbd2/journal.c:jbd2_write_superblock()\u3088\u308a\u3001JBD2_BARRIER\u304c\u306a\u3044\u5834\u5408\u306fsuperblock\u3092\u66f8\u304f\u3068\u304d\u306bREQ_FUA,REQ_PREFLUSH\u3092\u7acb\u3066\u306a\u3044\u3088\u3046\u306b\u3057\u3066\u3044\u308b\u3002\n\njournal.c\n1330         if (!(journal->j_flags & JBD2_BARRIER))\n1331                 write_flags &= ~(REQ_FUA | REQ_PREFLUSH);\n\n\nkernel/fs/jbd2/commit.c:journal_submit_commit_record()\u3088\u308a\u3001journal_async_commit\u306b\u3082\u95a2\u308f\u308b\u304c\u3001jbd2\u306ecommit\u30d6\u30ed\u30c3\u30af\u3092\u66f8\u304d\u51fa\u3059\u3068\u304d\u306bREQ_PREFLUSH, REQ_FUA\u3092\u6307\u5b9a\u3059\u308b\u304b\u3069\u3046\u304b\u306e\u5224\u65ad\u306b\u4f7f\u3063\u3066\u3044\u308b\u3002\u3042\u3068\u3067\u51fa\u3066\u304f\u308b\u304c\u3001journal_async_commit\u306fjournal_submit_commit_record()\u3092\u547c\u3076\u30bf\u30a4\u30df\u30f3\u30b0\u3082\u5909\u3048\u308b\u3002\n\ncommit.c\n156         if (journal->j_flags & JBD2_BARRIER &&\n157             !jbd2_has_feature_async_commit(journal))\n158                 ret = submit_bh(REQ_OP_WRITE,\n159                         REQ_SYNC | REQ_PREFLUSH | REQ_FUA, bh);\n160         else\n161                 ret = submit_bh(REQ_OP_WRITE, REQ_SYNC, bh);\n\n\nkernel/fs/jbd2/commit.c:jbd2_journal_commit_transaction()\u3088\u308a\u3001jbd2\u306ecommit\u30d6\u30ed\u30c3\u30af\u3092\u66f8\u304f\u524d\u306bREQ_OP_FLUSH\u3092\u9001\u308b\u3088\u3046\u306b\u3057\u3066\u3044\u308b\u3002\n\ncommit.c\n767         /* \n768          * If the journal is not located on the file system device,\n769          * then we must flush the file system device before we issue\n770          * the commit record\n771          */\n772         if (commit_transaction->t_need_data_flush &&\n773             (journal->j_fs_dev != journal->j_dev) &&\n774             (journal->j_flags & JBD2_BARRIER))\n775                 blkdev_issue_flush(journal->j_fs_dev, GFP_NOFS, NULL)\n\n\nkernel/fs/jbd2/commit.c:jbd2_journal_commit_transaction()\u3088\u308a\u3001journal_async_commit\u304b\u3064JBD2_BARRIER\u306e\u3068\u304d\u306fjbd2\u306ecommit\u30d6\u30ed\u30c3\u30af\u3092\u66f8\u3044\u305f\u5f8c\u306bREQ_OP_FLUSH\u3092\u9001\u308b\u3068\u3057\u3066\u3044\u308b\u3002\n\ncommit.c\n869         if (!jbd2_has_feature_async_commit(journal)) {\n870                 err = journal_submit_commit_record(journal, commit_transaction,\n871                                                 &cbh, crc32_sum);\n872                 if (err)\n873                         __jbd2_journal_abort_hard(journal);\n874         }\n875         if (cbh)\n876                 err = journal_wait_on_commit_record(journal, cbh);\n877         if (jbd2_has_feature_async_commit(journal) &&\n878             journal->j_flags & JBD2_BARRIER) {\n879                 blkdev_issue_flush(journal->j_dev, GFP_NOFS, NULL);\n880         }\n\n\nkernel/fs/jbd2/recovery.c:jbd2_journal_recover()\u3088\u308a\u3001recovery(replay)\u306e\u6700\u5f8c\u306bREQ_OP_FLUSH\u3092\u9001\u3063\u3066\u3044\u308b\u3002\n\nrecovery.c\n290         /* Make sure all replayed data is on permanent storage */\n291         if (journal->j_flags & JBD2_BARRIER) {\n292                 err2 = blkdev_issue_flush(journal->j_fs_dev, GFP_KERNEL, NULL);\n293                 if (!err)\n294                         err = err2;\n295         }\n\n\nkernel/fs/jbd2/checkpoint.c:jbd2_journal_recover()\u3088\u308a\u3001\u6700\u5f8c\u306bREQ_OP_FLUSH\u3092\u9001\u3063\u3066\u3044\u308b\u3002\u5927\u304d\u306a\u8996\u70b9\u304b\u3089journal\u306e\u72b6\u614b\u3092\u78ba\u5b9a\u3055\u305b\u305f\u3044\u307f\u305f\u3044\u3060\u3051\u3069\u3001\u666e\u6bb5\u304b\u3089flush\u306e\u30bf\u30a4\u30df\u30f3\u30b0\u3092\u6c17\u306b\u3057\u3066\u3044\u308b\u306f\u305a\u3060\u304b\u3089\u3001\u3053\u308c\u3063\u3066\u3044\u3089\u306a\u3044\u3093\u3058\u3083\u30fb\u30fb\u30fb\u78ba\u304b\u306b\u30b3\u30e1\u30f3\u30c8\u306b\u3042\u308b\u30a8\u30e9\u30fc(abort)\u304c\u51fa\u305f\u6642\u306f\u6c17\u306b\u3057\u305f\u307b\u3046\u304c\u3088\u3044\u3068\u306f\u601d\u3046\u304c\u3002\n\nrecovery.c\n369 /*\n370  * Check the list of checkpoint transactions for the journal to see if\n371  * we have already got rid of any since the last update of the log tail\n372  * in the journal superblock.  If so, we can instantly roll the\n373  * superblock forward to remove those transactions from the log.\n374  *\n375  * Return <0 on error, 0 on success, 1 if there was nothing to clean up.\n376  *\n377  * Called with the journal lock held.\n378  *\n379  * This is the only part of the journaling code which really needs to be\n380  * aware of transaction aborts.  Checkpointing involves writing to the\n381  * main filesystem area rather than to the journal, so it can proceed\n382  * even in abort state, but we must not update the super block if\n383  * checkpointing may have failed.  Otherwise, we would lose some metadata\n384  * buffers which should be written-back to the filesystem.\n385  */\n386 \n387 int jbd2_cleanup_journal_tail(journal_t *journal)\n388 {\n389         tid_t           first_tid;\n390         unsigned long   blocknr;\n391 \n392         if (is_journal_aborted(journal))\n393                 return -EIO;\n394 \n395         if (!jbd2_journal_get_log_tail(journal, &first_tid, &blocknr))\n396                 return 1;\n397         J_ASSERT(blocknr != 0);\n398 \n399         /*\n400          * We need to make sure that any blocks that were recently written out\n401          * --- perhaps by jbd2_log_do_checkpoint() --- are flushed out before\n402          * we drop the transactions from the journal. It's unlikely this will\n403          * be necessary, especially with an appropriately sized journal, but we\n404          * need this to guarantee correctness.  Fortunately\n405          * jbd2_cleanup_journal_tail() doesn't get called all that often.\n406          */\n407         if (journal->j_flags & JBD2_BARRIER)\n408                 blkdev_issue_flush(journal->j_fs_dev, GFP_NOFS, NULL);\n409 \n410         return __jbd2_update_log_tail(journal, first_tid, blocknr);\n411 }\n\n\n\njournal_async_commit\n\n\u30b3\u30fc\u30c9\u3092\u8aad\u3080\nkernel/fs/ext4/super.c\u3088\u308a\u3001EXT4_MOUNT_JOURNAL_ASYNC_COMMIT\u304c\u7acb\u3064\u3053\u3068\u304c\u308f\u304b\u308b\u3002\n\nsuper.c\n1333         {Opt_journal_async_commit, \"journal_async_commit\"},\n\n\n\nsuper.c\n1523         {Opt_journal_async_commit, (EXT4_MOUNT_JOURNAL_ASYNC_COMMIT |\n1524                                     EXT4_MOUNT_JOURNAL_CHECKSUM),\n\n\nkernel/fs/ext4/super.c:set_journal_csum_feature_set()\u3088\u308a\u3001JOURNAL_ASYNC_COMMIT\u306e\u3068\u304d\u306b\u306e\u307fjbd2\u306eJBD2_FEATURE_INCOMPAT_ASYNC_COMMIT\u304c\u6709\u52b9\u306b\u306a\u308b\u3002\n\nsuper.c\n3134         if (test_opt(sb, JOURNAL_ASYNC_COMMIT)) {\n3135                 ret = jbd2_journal_set_features(sbi->s_journal,\n3136                                 compat, 0,\n3137                                 JBD2_FEATURE_INCOMPAT_ASYNC_COMMIT |\n3138                                 incompat);\n3139         } else if (test_opt(sb, JOURNAL_CHECKSUM)) {\n3140                 ret = jbd2_journal_set_features(sbi->s_journal,\n3141                                 compat, 0,\n3142                                 incompat);\n3143                 jbd2_journal_clear_features(sbi->s_journal, 0, 0,\n3144                                 JBD2_FEATURE_INCOMPAT_ASYNC_COMMIT);\n3145         } else {\n3146                 jbd2_journal_clear_features(sbi->s_journal, 0, 0,\n3147                                 JBD2_FEATURE_INCOMPAT_ASYNC_COMMIT);\n3148         }\n\n\n\next4\u306e\u30b3\u30fc\u30c9\u3092\u8aad\u3080\n\u30a8\u30e9\u30fc\u30e1\u30c3\u30bb\u30fc\u30b8\u3092\u51fa\u3057\u3066\u3044\u308b\u3060\u3051\u3063\u307d\u3044\u3002\nkernel/fs/ext4/super.c:ext4_fill_super()\u3088\u308a\u3001journal\u306a\u3057\u3067\u306fjournal_async_commit\u3092\u8a31\u3057\u3066\u3044\u306a\u3044\u3002\n\nsuper.c\n3927         if (!test_opt(sb, NOLOAD) && ext4_has_feature_journal(sb)) {\n3928                 if (ext4_load_journal(sb, es, journal_devnum))\n3929                         goto failed_mount3a;\n3930         } else if (test_opt(sb, NOLOAD) && !(sb->s_flags & MS_RDONLY) &&\n3931                    ext4_has_feature_journal_needs_recovery(sb)) {\n3932                 ext4_msg(sb, KERN_ERR, \"required journal recovery \"\n3933                        \"suppressed and not mounted read-only\");\n3934                 goto failed_mount_wq;\n3935         } else {\n3936                 /* Nojournal mode, all journal mount options are illegal */\n3937                 if (test_opt2(sb, EXPLICIT_JOURNAL_CHECKSUM)) {\n3938                         ext4_msg(sb, KERN_ERR, \"can't mount with \"\n3939                                  \"journal_checksum, fs mounted w/o journal\");\n3940                         goto failed_mount_wq;\n3941                 }\n3942                 if (test_opt(sb, JOURNAL_ASYNC_COMMIT)) {\n3943                         ext4_msg(sb, KERN_ERR, \"can't mount with \"\n3944                                  \"journal_async_commit, fs mounted w/o journal\");\n3945                         goto failed_mount_wq;\n3946                 }\n\n\nkernel/fs/ext4/super.c:ext4_fill_super()\u3088\u308a\u3001data=ordered\u306e\u3068\u304d\u306fjournal_async_commit\u3092\u8a31\u3057\u3066\u3044\u306a\u3044\u3002\n\nsuper.c\n4007         if (test_opt(sb, DATA_FLAGS) == EXT4_MOUNT_ORDERED_DATA &&\n4008             test_opt(sb, JOURNAL_ASYNC_COMMIT)) {\n4009                 ext4_msg(sb, KERN_ERR, \"can't mount with \"\n4010                         \"journal_async_commit in data=ordered mode\");\n4011                 goto failed_mount_wq;\n4012         }\n\n\nkernel/fs/ext4/super.c:ext4_remount()\u3088\u308a\u3001data=ordered\u306e\u3068\u304d\u306fjournal_async_commit\u3092\u8a31\u3057\u3066\u3044\u306a\u3044\u3002\n\nc;super.c\n4907         } else if (test_opt(sb, DATA_FLAGS) == EXT4_MOUNT_ORDERED_DATA) {\n4908                 if (test_opt(sb, JOURNAL_ASYNC_COMMIT)) {\n4909                         ext4_msg(sb, KERN_ERR, \"can't mount with \"\n4910                                 \"journal_async_commit in data=ordered mode\");\n4911                         err = -EINVAL;\n4912                         goto restore_opts;\n4913                 }\n4914         }\n\n\n\njbd2\u306e\u30b3\u30fc\u30c9\u3092\u8aad\u3080\nkernel/include/linux/jbd2.h\u3088\u308a\u3001jbd2_has_feature_async_commit\u3092\u78ba\u8a8d\u3059\u308c\u3070\u826f\u3044\u3068\u308f\u304b\u308b\u3002\n\njbd2.h\n1114 JBD2_FEATURE_INCOMPAT_FUNCS(async_commit,       ASYNC_COMMIT)\n\n\nkernel/fs/jbd2/commit.c:journal_submit_commit_record()\u3088\u308a\u3001JBD2_BARRIER\u306b\u3082\u95a2\u308f\u308b\u304c\u3001jbd2\u306ecommit\u30d6\u30ed\u30c3\u30af\u3092\u66f8\u304d\u51fa\u3059\u3068\u304d\u306bREQ_PREFLUSH, REQ_FUA\u3092\u6307\u5b9a\u3059\u308b\u304b\u3069\u3046\u304b\u306e\u5224\u65ad\u306b\u4f7f\u3063\u3066\u3044\u308b\u3002\n\ncommit.c\n156         if (journal->j_flags & JBD2_BARRIER &&\n157             !jbd2_has_feature_async_commit(journal))\n158                 ret = submit_bh(REQ_OP_WRITE,\n159                         REQ_SYNC | REQ_PREFLUSH | REQ_FUA, bh);\n160         else\n161                 ret = submit_bh(REQ_OP_WRITE, REQ_SYNC, bh);\n\n\nkernel/fs/jbd2/commit.c:jbd2_journal_commit_transaction()\u3088\u308a\u3001journal_submit_commit_record()\u3092\u547c\u3076\u30bf\u30a4\u30df\u30f3\u30b0\u3092\u5909\u66f4\u3057\u3066\u3044\u308b\u3002commit phase 3\u306e\u6700\u5f8c\u304b\u3001commit phase 5\u306e\u6700\u521d\u304b\u3002\n\ncommit.c\n777         /* Done it all: now write the commit record asynchronously. */\n778         if (jbd2_has_feature_async_commit(journal)) {\n779                 err = journal_submit_commit_record(journal, commit_transaction,\n780                                                  &cbh, crc32_sum);\n781                 if (err)\n782                         __jbd2_journal_abort_hard(journal);\n783         }\n\n\n\ncommit.c\n869         if (!jbd2_has_feature_async_commit(journal)) {\n870                 err = journal_submit_commit_record(journal, commit_transaction,\n871                                                 &cbh, crc32_sum);\n872                 if (err)\n873                         __jbd2_journal_abort_hard(journal);\n874         }\n\n\nkernel/fs/jbd2/commit.c:jbd2_journal_commit_transaction()\u3088\u308a\u3001journal_async_commit\u304b\u3064JBD2_BARRIER\u306e\u3068\u304d\u306fjbd2\u306ecommit\u30d6\u30ed\u30c3\u30af\u3092\u66f8\u3044\u305f\u5f8c\u306bREQ_OP_FLUSH\u3092\u9001\u308b\u3068\u3057\u3066\u3044\u308b\u3002\n\ncommit.c\n869         if (!jbd2_has_feature_async_commit(journal)) {\n870                 err = journal_submit_commit_record(journal, commit_transaction,\n871                                                 &cbh, crc32_sum);\n872                 if (err)\n873                         __jbd2_journal_abort_hard(journal);\n874         }\n875         if (cbh)\n876                 err = journal_wait_on_commit_record(journal, cbh);\n877         if (jbd2_has_feature_async_commit(journal) &&\n878             journal->j_flags & JBD2_BARRIER) {\n879                 blkdev_issue_flush(journal->j_dev, GFP_NOFS, NULL);\n880         }\n\n\nkernel/fs/jbd2/recovery.c:do_one_pass()\u3088\u308a\u3001journal_async_commit\u306e\u5834\u5408\u306b\u8d77\u3053\u308a\u3046\u308bcommit\u30d6\u30ed\u30c3\u30af\u306ecorruption\u306e\u5224\u65ad\u3092\u3057\u3066\u3044\u308b\u3002\u3069\u3046\u3044\u3046\u30b1\u30fc\u30b9\u304b\u304c\u30b3\u30e1\u30f3\u30c8\u306b\u66f8\u3044\u3066\u3042\u308b\u3002...\u3067\u3082\u3001\u300c\u96fb\u6e90\u65ad\u3084IO\u30a8\u30e9\u30fc\u304c\u8d77\u3053\u3063\u305f\u6642\u306bjournal_async_commit\u3060\u3063\u305f\u300d\u306e\u3068\u300c\u305d\u308c\u3092replay\u3059\u308b\u3068\u304d\u306bjournal_async_commit\u3060\u3063\u305f\u300d\u306e\u3068\u306f\u9055\u3046\u3088\u3046\u306a...\n\nrecovery.c\n658                 case JBD2_COMMIT_BLOCK:\n659                         /*     How to differentiate between interrupted commit\n660                          *               and journal corruption ?\n661                          *\n662                          * {nth transaction}\n663                          *        Checksum Verification Failed\n664                          *                       |\n665                          *               ____________________\n666                          *              |                    |\n667                          *      async_commit             sync_commit\n668                          *              |                    |\n669                          *              | GO TO NEXT    \"Journal Corruption\"\n670                          *              | TRANSACTION\n671                          *              |\n672                          * {(n+1)th transanction}\n673                          *              |\n674                          *       _______|______________\n675                          *      |                     |\n676                          * Commit block found   Commit block not found\n677                          *      |                     |\n678                          * \"Journal Corruption\"       |\n679                          *               _____________|_________\n680                          *              |                       |\n681                          *      nth trans corrupt       OR   nth trans\n682                          *      and (n+1)th interrupted     interrupted\n683                          *      before commit block\n684                          *      could reach the disk.\n685                          *      (Cannot find the difference in above\n686                          *       mentioned conditions. Hence assume\n687                          *       \"Interrupted Commit\".)\n688                          */\n(----------snip----------)\n735                                         if (!jbd2_has_feature_async_commit(journal)) {\n736                                                 journal->j_failed_commit =\n737                                                         next_commit_ID;\n738                                                 brelse(bh);\n739                                                 break;\n740                                         }\n(----------snip----------)\n749                                 if (!jbd2_has_feature_async_commit(journal)) {\n750                                         journal->j_failed_commit =\n751                                                 next_commit_ID;\n752                                         brelse(bh);\n753                                         break;\n754                                 }\n\n\n\nREQ_OP_FLUSH, REQ_FUA, REQ_PREFLUSH,\n\n\u7c21\u5358\u306a\u8aac\u660e\n\u4eca\u6642\u306e\u30b9\u30c8\u30ec\u30fc\u30b8\u306f\u30cf\u30fc\u30c9\u30a6\u30a7\u30a2\u306e\u30b9\u30c8\u30ec\u30fc\u30b8\u306e\u4e2d\u306b\u3082\u30ad\u30e3\u30c3\u30b7\u30e5\u3092\u6301\u3063\u3066\u3044\u3066\u3001\u5916\u304b\u3089\u898b\u305f\u66f8\u304d\u8fbc\u307f\u304c\u5b8c\u4e86\u3057\u305f\u304b\u3089\u3068\u8a00\u3063\u3066non volatile(\u4e0d\u63ee\u767a\u9818\u57df(\u96fb\u6e90\u65ad\u3057\u3066\u3082\u6d88\u3048\u306a\u3044\u3068\u3053))\u306b\u66f8\u3044\u305f\u3068\u306f\u9650\u3089\u306a\u3044\u3002\u3053\u306e\u30ad\u30e3\u30c3\u30b7\u30e5\u3092\u660e\u793a\u7684\u306b\u30b3\u30f3\u30c8\u30ed\u30fc\u30eb\u3057\u3088\u3046\u3068\u3044\u3046\u8981\u6c42\u306b\u306a\u308b\u3002\nREQ_OP_FLUSH, REQ_PREFLUSH\u306f\u3001\u30ad\u30e3\u30c3\u30b7\u30e5\u306b\u6b8b\u3063\u3066\u3044\u308b\u66f8\u304d\u51fa\u305b\u3066\u3044\u306a\u3044\u3082\u306e\u3092\u66f8\u304d\u51fa\u305b\u3001\u3068\u3044\u3046\u610f\u5473\u306b\u306a\u308b\u3002\nREQ_FUA\u306f\u3001\u6b21\u306b\u66f8\u3053\u3046\u3068\u3057\u3066\u3044\u308b\u3082\u306e\u306f\u30ad\u30e3\u30c3\u30b7\u30e5\u3060\u3051\u306b\u7559\u3081\u308b\u3053\u3068\u306f\u305b\u305a\u306b\u66f8\u304d\u51fa\u305b\u3001\u3068\u3044\u3046\u610f\u5473\u306b\u306a\u308b\u3002\n\n\u521d\u5fc3\u8005\u5411\u3051\u86c7\u8db3\u306a\u6ce8\u610f\u4e8b\u9805\n\u30d7\u30ed\u30b0\u30e9\u30de\u304b\u3089\u3059\u308b\u3068\u3001\u30c7\u30fc\u30bf(\u30d5\u30a1\u30a4\u30eb)\u3092\u6271\u3046\u4e0a\u3067\u4e0b\u8a18\u306e\u3088\u3046\u306a\u30ad\u30e3\u30c3\u30b7\u30e5\u3092\u610f\u8b58\u3057\u306a\u3044\u3068\u3044\u3051\u306a\u3044\u3002\u3044\u3084\u3001\u5927\u4f53\u306e\u5834\u5408\u306fOS\u3084\u30e9\u30a4\u30d6\u30e9\u30ea\u304c\u52dd\u624b\u306b\u3084\u308b\u304b\u3089\u3042\u307e\u308a\u610f\u8b58\u3057\u306a\u304f\u3066\u3044\u3044(\u30cf\u30ba\u3060)\u3051\u3069\u3002\n\n\nfflush(3)\u985e\u3001\u30e6\u30fc\u30b6\u30e9\u30f3\u30c9\u3067\u306e\u30ad\u30e3\u30c3\u30b7\u30e5\n\nsync(2)\u985e\u3001kernel\u306e\u30d6\u30ed\u30c3\u30af\u5c64\u3067\u306e\u30d0\u30c3\u30d5\u30a1\u30ad\u30e3\u30c3\u30b7\u30e5\n\nioprio_get(2)\u985e\u3001\u30c7\u30a3\u30b9\u30af\u30c9\u30e9\u30a4\u30d0\u304c\u8981\u6c42\u3092\u3069\u306e\u9806\u3067\u51e6\u7406\u3059\u308b\u304b\u306e\u30ad\u30e5\u30fc\u306b\u52b9\u304f\u3001IO scheduler(/sys/block/sda/queue/scheduler\u306a\u3069)\u306b\u3082\u6ce8\u610f\n\u4eca\u56de\u6c17\u306b\u3066\u3044\u308b\u30b9\u30c8\u30ec\u30fc\u30b8\u5074\u304c\u6301\u3063\u3066\u3044\u308b\u4e2d\u306e\u30ad\u30e3\u30c3\u30b7\u30e5\n\n\u985e\u4f3c\u4f8b\u3068\u3057\u3066\u3001CPU\u306eL1/L2/L3\u30ad\u30e3\u30c3\u30b7\u30e5\u3068\u304b\u3001\u4e00\u90e8SoC\u3067\u306fDRAM\u4ee5\u5916\u306e\u30d0\u30b9\u306b\u3082\u30ad\u30e3\u30c3\u30b7\u30e5\u304c\u3042\u3063\u305f\u308a\u3068\u304b\u3002\u305f\u3060\u3069\u308c\u3082\u4e00\u8a00\u3067\u300c\u30ad\u30e3\u30c3\u30b7\u30e5(cache)\u300d\u3068\u3060\u3051\u8a00\u308f\u308c\u308b\u3053\u3068\u304c\u591a\u3044\u305f\u3081\u3001\u3069\u3053\u306e\u30ad\u30e3\u30c3\u30b7\u30e5\u306e\u3053\u3068\u306a\u306e\u304b\u3092\u5e38\u306b\u610f\u8b58\u3057\u306a\u3044\u3068\u3044\u3051\u306a\u3044\u3002\n\u4eca\u6642\u306eCPU\u306fGHz\u30aa\u30fc\u30c0\u3067\u3067\u30ad\u30d3\u30ad\u30d3\u52d5\u304f\u3051\u3069\u3001\u305d\u308c\u3092\u6709\u52b9\u306b\u4f7f\u3046\u306b\u306f\u7d76\u3048\u9593\u306a\u304f\u30c7\u30fc\u30bf\u3092\u6d41\u3057\u8fbc\u307e\u306a\u3044\u3068\u3044\u3051\u306a\u3044\u306e\u3067\u3001\u305d\u306e\u30c7\u30fc\u30bf\u3092\u5b89\u5b9a\u63a2\u5075\u3057\u3066\u4f9b\u7d66\u3059\u308b\u305f\u3081\u306b\u305d\u3053\u3089\u3058\u3085\u3046\u306b\u30ad\u30e3\u30c3\u30b7\u30e5\u304c\u3042\u308b\u3002\u30ad\u30e3\u30c3\u30b7\u30e5\u304c\u3042\u308b\u3068\u30c7\u30fc\u30bf\u4e00\u8cab\u6027\u304c\u5d29\u308c\u308b\u306e\u3067\u3001\u4e00\u8cab\u6027\u3092\u4fdd\u3064\u305f\u3081\u306b\u8272\u3005\u3057\u306a\u3044\u3068\u3044\u3051\u306a\u304f\u3066\u9762\u5012\u306b\u306a\u308b\u3002\n\n\u5b9a\u7fa9\nkernel/include/linux/blk_types.h\u3067\u5b9a\u7fa9\u3055\u308c\u3066\u3044\u308b\u3002OP\u304c\u4ed8\u3044\u3066\u3044\u308b\u307b\u3046\u304c\u30ea\u30af\u30a8\u30b9\u30c8\u306e\u7a2e\u985e(1\u7a2e\u985e\u3057\u304b\u9078\u3079\u306a\u3044)\u3001OP\u304c\u3064\u3044\u3066\u3044\u306a\u3044\u307b\u3046\u304c\u30d5\u30e9\u30b0(\u30ea\u30af\u30a8\u30b9\u30c8\u306b\u5bfe\u3057\u30d3\u30c3\u30c8\u3067\u8907\u6570\u7acb\u3066\u3089\u308c\u308b)\u3001\u3068\u306a\u3063\u3066\u3044\u308b\u3002\n\nblk_types.h\n145 enum req_opf {\n146         /* read sectors from the device */\n147         REQ_OP_READ             = 0,\n148         /* write sectors to the device */\n149         REQ_OP_WRITE            = 1,\n150         /* flush the volatile write cache */\n151         REQ_OP_FLUSH            = 2,\n152         /* discard sectors */\n153         REQ_OP_DISCARD          = 3,\n154         /* get zone information */\n155         REQ_OP_ZONE_REPORT      = 4,\n156         /* securely erase sectors */\n157         REQ_OP_SECURE_ERASE     = 5,\n158         /* seset a zone write pointer */\n159         REQ_OP_ZONE_RESET       = 6,\n160         /* write the same sector many times */\n161         REQ_OP_WRITE_SAME       = 7,\n162         /* write the zero filled sector many times */\n163         REQ_OP_WRITE_ZEROES     = 8,\n164 \n165         REQ_OP_LAST,\n166 };\n167 \n168 enum req_flag_bits {\n169         __REQ_FAILFAST_DEV =    /* no driver retries of device errors */\n170                 REQ_OP_BITS,\n171         __REQ_FAILFAST_TRANSPORT, /* no driver retries of transport errors */\n172         __REQ_FAILFAST_DRIVER,  /* no driver retries of driver errors */\n173         __REQ_SYNC,             /* request is sync (sync write or read) */\n174         __REQ_META,             /* metadata io request */\n175         __REQ_PRIO,             /* boost priority in cfq */\n176         __REQ_NOMERGE,          /* don't touch this for merging */\n177         __REQ_IDLE,             /* anticipate more IO after this one */\n178         __REQ_INTEGRITY,        /* I/O includes block integrity payload */\n179         __REQ_FUA,              /* forced unit access */\n180         __REQ_PREFLUSH,         /* request for cache flush */\n181         __REQ_RAHEAD,           /* read ahead, can fail anytime */\n182         __REQ_BACKGROUND,       /* background IO */\n183         __REQ_NR_BITS,          /* stops here */\n184 };\n185 \n186 #define REQ_FAILFAST_DEV        (1ULL << __REQ_FAILFAST_DEV)\n187 #define REQ_FAILFAST_TRANSPORT  (1ULL << __REQ_FAILFAST_TRANSPORT)\n188 #define REQ_FAILFAST_DRIVER     (1ULL << __REQ_FAILFAST_DRIVER)\n189 #define REQ_SYNC                (1ULL << __REQ_SYNC)\n190 #define REQ_META                (1ULL << __REQ_META)\n191 #define REQ_PRIO                (1ULL << __REQ_PRIO)\n192 #define REQ_NOMERGE             (1ULL << __REQ_NOMERGE)\n193 #define REQ_IDLE                (1ULL << __REQ_IDLE)\n194 #define REQ_INTEGRITY           (1ULL << __REQ_INTEGRITY)\n195 #define REQ_FUA                 (1ULL << __REQ_FUA)\n196 #define REQ_PREFLUSH            (1ULL << __REQ_PREFLUSH)\n197 #define REQ_RAHEAD              (1ULL << __REQ_RAHEAD)\n198 #define REQ_BACKGROUND          (1ULL << __REQ_BACKGROUND)\n\n\n\u3061\u306a\u307f\u306b\u3001\u3053\u306eREQ_BACKGROUND\u304cLinux-4.10\u3067\u306e\u76ee\u7389\u306e\u6a5f\u80fd(writeback\u306e\u6539\u5584)\u3089\u3057\u3044\u3067\u3059\u3002\n\nDocumentation\nkernel/Documentation/block/writeback_cache_control.txt\u306b\u305d\u308c\u3063\u307d\u3044\u30c9\u30ad\u30e5\u30e1\u30f3\u30c8\u304c\u3042\u308b\u3002\n\nREQ_FUA\n\nscsi(sd)\u306e\u5834\u5408\nscsi disk(sd)\u3060\u3068\u3001WRITE_32, WRITE_16 \u30b3\u30de\u30f3\u30c9\u306e\u6642\u306e FUA_NV\u30d3\u30c3\u30c8\u3092\u6307\u5b9a\u3057\u3066\u3044\u308b\u3002\nSCSI\u4ed5\u69d8\u66f8(PDF)\u306b\u3088\u308c\u3070\u3001\nWRITE: If FUA = 1, all data must be written to the media before the SCSI operation returns the status and completion message bytes\n\n\neMMC\u306e\u5834\u5408\nreliable write\u3092\u3059\u308b\u3002JEDEC\u306b\u3088\u308b\u3068reliable write\u306f\u3001cache\u306b\u7559\u3081\u306a\u3044write\u3067\u3042\u308b\u3053\u3068\u304c\u898f\u5b9a\u3055\u308c\u3066\u3044\u308b\u3002http://www.jedec.org/sites/default/files/docs/JESD84-B451.pdf \u306f\u4f1a\u54e1\u3057\u304b\u898b\u308c\u306a\u3044\u3002...JEDEC\u306e\u4ed5\u69d8\u66f8\u3063\u3066\u58f2\u308a\u7269\u3060\u304b\u3089\u30cd\u30c3\u30c8\u306b\u30bf\u30c0\u3067\u898b\u308c\u308b\u72b6\u614b\u3067\u7f6e\u3044\u3061\u3083\u307e\u305a\u304b\u3063\u305f\u3093\u3058\u3083\u306a\u304b\u3063\u305f\u3063\u3051\u3002\u30b0\u30b0\u308c\u3070\u666e\u901a\u306b\u898b\u3048\u3061\u3083\u3046\u30b5\u30a4\u30c8\u3082\u3042\u308b\u4ef6\u3002\n\nREQ_PREFLUSH\n\u8a72\u5f53\u306e\u30ea\u30af\u30a8\u30b9\u30c8\u3092\u51e6\u7406\u3059\u308b\u524d\u306bREQ_OP_FLUSH\u304c\u30ea\u30af\u30a8\u30b9\u30c8\u3055\u308c\u305f\u306e\u3068\u540c\u3058\u3053\u3068\u3092\u3059\u308b\u3001\u3068\u3044\u3046\u610f\u5473\u306b\u306a\u308b\u3002\n\nREQ_OP_FLUSH\n\nscsi(sd)\u306e\u5834\u5408\nSYNCHRONIZE_CACHE (SYNCHRONIZE CACHE 10\u30b3\u30de\u30f3\u30c9)\u3092\u9001\u3063\u3066\u3044\u308b\u3002\n\neMMC\u306e\u5834\u5408\nEXT_CSD_FLUSH_CACHE (index 32)\u306b1\u3092\u66f8\u3044\u3066\u3044\u308b\n\n\u3042\u3068\u304c\u304d\njournal_async_commit\u306f\u3068\u3082\u304b\u304f\u3001nobarrier\u306fRAID\u3084lvm\u306a\u3069\u8907\u6570\u306e\u30b9\u30c8\u30ec\u30fc\u30b8\u306b\u5206\u6563\u3059\u308b\u6642\u3068\u304d\u306b\u30ad\u30e3\u30c3\u30b7\u30e5\u304c\u8907\u6570\u306b\u5206\u304b\u308c\u3066\u30bf\u30a4\u30df\u30f3\u30b0\u304c\u8aad\u3081\u306a\u304f\u306a\u308b\u306e\u3067\u3001\u4e0d\u7528\u610f\u306bnobarrier\u3092\u3064\u3051\u308b\u3068\u96fb\u6e90\u65ad\u306b\u5f31\u304f\u306a\u308b\u3068\u601d\u308f\u308c\u308b\u3002\u5927\u4e8b\u306a\u30c7\u30fc\u30bf\u3060\u3068UPS\u985e\u306a\u3057\u306b\u306f\u4f7f\u3048\u306a\u3044\u3002\u9006\u306b\u5358\u4f53\u30b9\u30c8\u30ec\u30fc\u30b8\u3060\u3068\u3001\u4e2d\u306e\u30d5\u30a1\u30fc\u30e0\u30a6\u30a7\u30a2\u6b21\u7b2c\u3060\u3051\u3069\u3001\u6bd4\u8f03\u7684\u5371\u967a\u304c\u5c11\u306a\u3044\u3068\u601d\u308f\u308c\u308b\u3002\n\u305f\u3060\u3044\u305a\u308c\u3082\u3001\u4e2d\u306e\u30d5\u30a1\u30fc\u30e0\u30a6\u30a7\u30a2\u6b21\u7b2c\u306a\u306e\u3067\u3001fua\u3084cache\u306e\u30b3\u30de\u30f3\u30c9\u306b\u30a6\u30bd\u3064\u3044\u3066\u3044\u308b(\u300c\u5b8c\u4e86\u300d\u3068\u3044\u3044\u3064\u3064\u5b9f\u969b\u306b\u306f\u4f55\u3082\u3057\u3066\u3044\u306a\u3044)\u3068\u3001ext4/jbd2\u304c\u3084\u3063\u3066\u3044\u308b\u4e0a\u8a18\u306e\u3088\u3046\u306a\u3053\u3068\u304c\u610f\u5473\u3092\u306a\u3055\u306a\u304f\u306a\u308b\u3002\u9006\u306e\u3053\u3068\u3082\u8d77\u3053\u308a\u3048\u3066\u30015\u5e74\u307b\u3069\u524d\u306f\u3088\u304f\u3042\u3063\u305f\u300c\u30d7\u30c1\u30d5\u30eaSSD\u300d\u306e\u3088\u3046\u306b\u3001\u51e6\u7406\u306e\u9069\u6b63\u5316\u304c\u9032\u3093\u3067\u3044\u306a\u3044\u30d5\u30a1\u30fc\u30e0\u30a6\u30a7\u30a2\u3067\u30d1\u30d5\u30a9\u30fc\u30de\u30f3\u30b9\u304c\u30c0\u30c0\u843d\u3061\u306b\u306a\u3063\u3066\u3057\u307e\u3063\u305f\u308a\u3068\u3002\n\u30c7\u30a3\u30b9\u30af\u66f8\u304d\u51fa\u3057\u306b\u95a2\u308f\u308b\u3068\u3053\u306f\u304a\u304a\u3080\u306d\u898b\u7d42\u308f\u3063\u305f\u305f\u3081\u3001\u3053\u308c\u3067ext4\u95a2\u9023\u306e\u8a18\u4e8b\u306f\u7d42\u308f\u308a\u306e\u4e88\u5b9a\u3067\u3059\u3002\u6c17\u306b\u306a\u308b\u65b9\u306f\u904e\u53bb\u306e\u8a18\u4e8b\u3082\u53c2\u8003\u306b\u3057\u3066\u3082\u3089\u3048\u308c\u3070\u3068\u601d\u3044\u307e\u3059\u3002\n...\u3042\u3001Linux-4.10\u3067LogFS\u6d88\u3055\u308c\u3066\u308b...\n# \u306f\u3058\u3081\u306b\n[\u5148\u306e\u8a18\u4e8b\u306e\u4e88\u544a](http://qiita.com/rarul/items/6e9f96a58629157db4df#%E7%B5%82%E3%82%8F%E3%82%8A%E3%81%AB)\u306e\u901a\u308a\u3001**nobarrier**\u3068**journal_async_commit**\u304c\u3069\u3046\u52d5\u304f\u306e\u304b\u306b\u3064\u3044\u3066\u306e\u8a73\u7d30\u306e\u8abf\u67fb\u3092\u5b9f\u65bd\u3057\u305f\u3002\n\n\u306a\u304a\u3001[\u307b\u3084\u307b\u3084\u306eLinux-4.10](http://gihyo.jp/admin/clip/01/linux_dt/201702/21)\u304f\u3089\u3044\u3092\u898b\u3066\u3044\u307e\u3059\u3002\n\n# Documentation\n[**kernel/Documentation/filesystems/ext4.txt**](http://lxr.free-electrons.com/source/Documentation/filesystems/ext4.txt?v=4.10)\u3088\u308a\n\n```text\n185 barrier=<0|1(*)>        This enables/disables the use of write barriers in\n186 barrier(*)              the jbd code.  barrier=0 disables, barrier=1 enables.\n187 nobarrier               This also requires an IO stack which can support\n188                         barriers, and if jbd gets an error on a barrier\n189                         write, it will disable again with a warning.\n190                         Write barriers enforce proper on-disk ordering\n191                         of journal commits, making volatile disk write caches\n192                         safe to use, at some performance penalty.  If\n193                         your disks are battery-backed in one way or another,\n194                         disabling barriers may safely improve performance.\n195                         The mount options \"barrier\" and \"nobarrier\" can\n196                         also be used to enable or disable barriers, for\n197                         consistency with other ext4 mount options.\n```\n\n```text\n142 journal_async_commit    Commit block can be written to disk without waiting\n143                         for descriptor blocks. If enabled older kernels cannot\n144                         mount the device. This will enable 'journal_checksum'\n145                         internally.\n```\n\n# nobarrier\n## \u30aa\u30d7\u30b7\u30e7\u30f3\u6307\u5b9a\u306e\u8a31\u5bb9\u5ea6\n**nobarrier**, \u3082\u3057\u304f\u306f **barrier**, **barrier=[0|1]**\u3067\u3044\u3051\u308b\n\n## \u30b3\u30fc\u30c9\u3092\u8aad\u3080\n[kernel/fs/ext4/super.c](http://lxr.free-electrons.com/source/fs/ext4/super.c?v=4.10#L1352)\u3088\u308a\u3001**barrier**\u306e\u3068\u304d\u306b**EXT4_MOUNT_BARRIER**\u304c\u7acb\u3064\u3053\u3068\u304c\u308f\u304b\u308b\u3002\n\n```c:super.c\n1352         {Opt_barrier, \"barrier=%u\"},\n1353         {Opt_barrier, \"barrier\"},\n1354         {Opt_nobarrier, \"nobarrier\"},\n```\n\n```c:super.c\n1534         {Opt_barrier, EXT4_MOUNT_BARRIER, MOPT_SET},\n1535         {Opt_nobarrier, EXT4_MOUNT_BARRIER, MOPT_CLEAR},\n```\n\n[kernel/fs/ext4/super.c:**ext4_init_journal_params()**](http://lxr.free-electrons.com/source/fs/ext4/super.c?v=4.10#L4309)\u3088\u308a\u3001jbd2\u306b\u6e21\u3059\u30aa\u30d7\u30b7\u30e7\u30f3\u3092\u4f5c\u3063\u3066\u3044\u308b\u3002\u3064\u307e\u308ajbd2\u306e\u4e2d\u3067\u306f**JBD2_BARRIER**\u3092\u8ffd\u3048\u3070\u3088\u3044\u3068\u308f\u304b\u308b\u3002\n\n```c:super.c\n4308         if (test_opt(sb, BARRIER))\n4309                 journal->j_flags |= JBD2_BARRIER;\n4310         else\n4311                 journal->j_flags &= ~JBD2_BARRIER;\n```\n\n### ext4\u306e\u30b3\u30fc\u30c9\u3092\u8aad\u3080\n[kernel/fs/ext4/super.c:**ext4_fill_super()**](http://lxr.free-electrons.com/source/fs/ext4/super.c?v=4.10#L3478)\u3088\u308a\u3001DEFM\u306b**nobarrier**\u304c\u306a\u3044\u6642\u306f**EXT4_MOUNT_BARRIER**\u3092\u7acb\u3063\u3066\u3044\u308b\u3002DEFM\u306fext4\u306esuperblock\u306b\u66f8\u304b\u308c\u308b\u30c7\u30d5\u30a9\u30eb\u30c8\u30de\u30a6\u30f3\u30c8\u30aa\u30d7\u30b7\u30e7\u30f3\u306e\u3053\u3068\u3002\n\n```c:super.c\n3478         if ((def_mount_opts & EXT4_DEFM_NOBARRIER) == 0)\n3479                 set_opt(sb, BARRIER);\n```\n\n[kernel/fs/ext4/super.c:**ext4_load_journal()**](http://lxr.free-electrons.com/source/fs/ext4/super.c?v=4.10#L4524)\u3088\u308a\u3001**KERN_INFO**\u306b\u30e1\u30c3\u30bb\u30fc\u30b8\u3092\u66f8\u3044\u3066\u3044\u308b\u3002\u9006\u306b\u8a00\u3048\u3070\u3001**dmesg**\u3092\u898b\u308c\u3070**nobarrier**\u3060\u3063\u305f\u304b\u3069\u3046\u304b\u304c\u308f\u304b\u308b\u3002\n\n```c:super.c\n4524         if (!(journal->j_flags & JBD2_BARRIER))\n4525                 ext4_msg(sb, KERN_INFO, \"barriers disabled\");\n```\n\n[kernel/fs/ext4/super.c:**ext4_commit_super()**](http://lxr.free-electrons.com/source/fs/ext4/super.c?v=4.10#L4524)\u3088\u308a\u3001superblock\u3092sync\u3067\u66f8\u304f\u6642\u306b**REQ_FUA**\u304b**REQ_SYNC**\u304b\u3092\u9078\u3093\u3067\u3044\u308b\u3002\n\n```c:super.c\n4616         if (sync) {\n4617                 unlock_buffer(sbh);\n4618                 error = __sync_dirty_buffer(sbh,\n4619                         test_opt(sb, BARRIER) ? REQ_FUA : REQ_SYNC);\n4620                 if (error)\n4621                         return error;\n4622 \n4623                 error = buffer_write_io_error(sbh);\n4624                 if (error) {\n4625                         ext4_msg(sb, KERN_ERR, \"I/O error while writing \"\n4626                                \"superblock\");\n4627                         clear_buffer_write_io_error(sbh);\n4628                         set_buffer_uptodate(sbh);\n4629                 }\n4630         }\n```\n\n[kernel/fs/ext4/super.c:**ext4_sync_fs()**](http://lxr.free-electrons.com/source/fs/ext4/super.c?v=4.10#L4730)\u3088\u308a\u3001sync\u306e\u6700\u5f8c\u306b**blkdev_issue_flush()**\u3092\u547c\u3076(**REQ_OP_FLUSH**\u3092\u9001\u308b)\u5fc5\u8981\u304c\u3042\u308b\u304b\u3069\u3046\u304b\u3092\u78ba\u8a8d\u3057\u3066\u3044\u308b\u3002\u30b3\u30e1\u30f3\u30c8\u306b\u3042\u308b\u3088\u3046\u306b\u3001\u300cwriteback\u306ainode\u3092\u66f8\u304d\u51fa\u3057\u305f\u3051\u3069journal\u306f\u306a\u306b\u3082\u66f8\u304d\u51fa\u3059\u5fc5\u8981\u304c\u306a\u304b\u3063\u305f\u300d\u3088\u3046\u306a\u5834\u5408\u304c\u8a72\u5f53\u3059\u308b\u3068\u601d\u308f\u308c\u308b\u3002\n\n```c:super.c\n4730         /*\n4731          * Data writeback is possible w/o journal transaction, so barrier must\n4732          * being sent at the end of the function. But we can skip it if\n4733          * transaction_commit will do it for us.\n4734          */\n4735         if (sbi->s_journal) {\n4736                 target = jbd2_get_latest_transaction(sbi->s_journal);\n4737                 if (wait && sbi->s_journal->j_flags & JBD2_BARRIER &&\n4738                     !jbd2_trans_will_send_data_barrier(sbi->s_journal, target))\n4739                         needs_barrier = true;\n4740 \n4741                 if (jbd2_journal_start_commit(sbi->s_journal, &target)) {\n4742                         if (wait)\n4743                                 ret = jbd2_log_wait_commit(sbi->s_journal,\n4744                                                            target);\n4745                 }\n4746         } else if (wait && test_opt(sb, BARRIER))\n4747                 needs_barrier = true;\n4748         if (needs_barrier) {\n4749                 int err;\n4750                 err = blkdev_issue_flush(sb->s_bdev, GFP_KERNEL, NULL);\n4751                 if (!ret)\n4752                         ret = err;\n4753         }\n```\n\n[kernel/fs/ext4/fsync.c:**ext4_sync_file()**](http://lxr.free-electrons.com/source/fs/ext4/fsync.c?v=4.10#L115)\u3088\u308a\u3001\u304a\u304a\u3080\u306d\u5148\u3068\u540c\u3058\u3088\u3046\u306a\u3053\u3068\u3092\u3084\u3063\u3066\u3044\u308b\u3002\n\n```c:fsync.c\n115         if (!journal) {\n116                 ret = __generic_file_fsync(file, start, end, datasync);\n117                 if (!ret)\n118                         ret = ext4_sync_parent(inode);\n119                 if (test_opt(inode->i_sb, BARRIER))\n120                         goto issue_flush;\n121                 goto out;\n122         }\n123 \n124         ret = filemap_write_and_wait_range(inode->i_mapping, start, end);\n125         if (ret)\n126                 return ret;\n127         /*\n128          * data=writeback,ordered:\n129          *  The caller's filemap_fdatawrite()/wait will sync the data.\n130          *  Metadata is in the journal, we wait for proper transaction to\n131          *  commit here.\n132          *\n133          * data=journal:\n134          *  filemap_fdatawrite won't do anything (the buffers are clean).\n135          *  ext4_force_commit will write the file data into the journal and\n136          *  will wait on that.\n137          *  filemap_fdatawait() will encounter a ton of newly-dirtied pages\n138          *  (they were dirtied by commit).  But that's OK - the blocks are\n139          *  safe in-journal, which is all fsync() needs to ensure.\n140          */\n141         if (ext4_should_journal_data(inode)) {\n142                 ret = ext4_force_commit(inode->i_sb);\n143                 goto out;\n144         }\n145 \n146         commit_tid = datasync ? ei->i_datasync_tid : ei->i_sync_tid;\n147         if (journal->j_flags & JBD2_BARRIER &&\n148             !jbd2_trans_will_send_data_barrier(journal, commit_tid))\n149                 needs_barrier = true;\n150         ret = jbd2_complete_transaction(journal, commit_tid);\n151         if (needs_barrier) {\n152         issue_flush:\n153                 err = blkdev_issue_flush(inode->i_sb->s_bdev, GFP_KERNEL, NULL);\n154                 if (!ret)\n155                         ret = err;\n156         }\n```\n\n### jbd2\u306e\u30b3\u30fc\u30c9\u3092\u8aad\u3080\next4\u306e\u30b3\u30fc\u30c9\u3088\u308a\u3001**JBD2_BARRIER**\u3092\u8ffd\u3048\u3070\u826f\u3044\u3053\u3068\u304c\u308f\u304b\u3063\u3066\u3044\u308b\u3002\n\n[kernel/fs/jbd2/journal.c:**jbd2_trans_will_send_data_barrier()**](http://lxr.free-electrons.com/source/fs/jbd2/journal.c?v=4.10#L656)\u3088\u308a\u3001**JBD2_BARRIER**\u304c\u306a\u3044\u5834\u5408\u306f**REQ_OP_FLUSH**\u3092\u9001\u3089\u306a\u3044\u4e88\u5b9a\u3060\u3068\u3057\u3066\u3044\u308b\u3002\n\n```c:journal.c\n656         if (!(journal->j_flags & JBD2_BARRIER))\n657                 return 0;\n```\n\n[kernel/fs/jbd2/journal.c:**jbd2_write_superblock()**](http://lxr.free-electrons.com/source/fs/jbd2/journal.c?v=4.10#L1330)\u3088\u308a\u3001**JBD2_BARRIER**\u304c\u306a\u3044\u5834\u5408\u306fsuperblock\u3092\u66f8\u304f\u3068\u304d\u306b**REQ_FUA**,**REQ_PREFLUSH**\u3092\u7acb\u3066\u306a\u3044\u3088\u3046\u306b\u3057\u3066\u3044\u308b\u3002\n\n```c:journal.c\n1330         if (!(journal->j_flags & JBD2_BARRIER))\n1331                 write_flags &= ~(REQ_FUA | REQ_PREFLUSH);\n```\n\n[kernel/fs/jbd2/commit.c:**journal_submit_commit_record()**](http://lxr.free-electrons.com/source/fs/jbd2/commit.c?v=4.10#L156)\u3088\u308a\u3001**journal_async_commit**\u306b\u3082\u95a2\u308f\u308b\u304c\u3001jbd2\u306ecommit\u30d6\u30ed\u30c3\u30af\u3092\u66f8\u304d\u51fa\u3059\u3068\u304d\u306b**REQ_PREFLUSH**, **REQ_FUA**\u3092\u6307\u5b9a\u3059\u308b\u304b\u3069\u3046\u304b\u306e\u5224\u65ad\u306b\u4f7f\u3063\u3066\u3044\u308b\u3002\u3042\u3068\u3067\u51fa\u3066\u304f\u308b\u304c\u3001**journal_async_commit**\u306fjournal_submit_commit_record()\u3092\u547c\u3076\u30bf\u30a4\u30df\u30f3\u30b0\u3082\u5909\u3048\u308b\u3002\n\n\n```c:commit.c\n156         if (journal->j_flags & JBD2_BARRIER &&\n157             !jbd2_has_feature_async_commit(journal))\n158                 ret = submit_bh(REQ_OP_WRITE,\n159                         REQ_SYNC | REQ_PREFLUSH | REQ_FUA, bh);\n160         else\n161                 ret = submit_bh(REQ_OP_WRITE, REQ_SYNC, bh);\n```\n\n[kernel/fs/jbd2/commit.c:**jbd2_journal_commit_transaction()**](http://lxr.free-electrons.com/source/fs/jbd2/commit.c?v=4.10#L767)\u3088\u308a\u3001jbd2\u306ecommit\u30d6\u30ed\u30c3\u30af\u3092\u66f8\u304f\u524d\u306b**REQ_OP_FLUSH**\u3092\u9001\u308b\u3088\u3046\u306b\u3057\u3066\u3044\u308b\u3002\n\n```c:commit.c\n767         /* \n768          * If the journal is not located on the file system device,\n769          * then we must flush the file system device before we issue\n770          * the commit record\n771          */\n772         if (commit_transaction->t_need_data_flush &&\n773             (journal->j_fs_dev != journal->j_dev) &&\n774             (journal->j_flags & JBD2_BARRIER))\n775                 blkdev_issue_flush(journal->j_fs_dev, GFP_NOFS, NULL)\n```\n\n[kernel/fs/jbd2/commit.c:**jbd2_journal_commit_transaction()**](http://lxr.free-electrons.com/source/fs/jbd2/commit.c?v=4.10#L869)\u3088\u308a\u3001**journal_async_commit**\u304b\u3064**JBD2_BARRIER**\u306e\u3068\u304d\u306fjbd2\u306ecommit\u30d6\u30ed\u30c3\u30af\u3092\u66f8\u3044\u305f\u5f8c\u306b**REQ_OP_FLUSH**\u3092\u9001\u308b\u3068\u3057\u3066\u3044\u308b\u3002\n\n```c:commit.c\n869         if (!jbd2_has_feature_async_commit(journal)) {\n870                 err = journal_submit_commit_record(journal, commit_transaction,\n871                                                 &cbh, crc32_sum);\n872                 if (err)\n873                         __jbd2_journal_abort_hard(journal);\n874         }\n875         if (cbh)\n876                 err = journal_wait_on_commit_record(journal, cbh);\n877         if (jbd2_has_feature_async_commit(journal) &&\n878             journal->j_flags & JBD2_BARRIER) {\n879                 blkdev_issue_flush(journal->j_dev, GFP_NOFS, NULL);\n880         }\n```\n\n[kernel/fs/jbd2/recovery.c:**jbd2_journal_recover()**](http://lxr.free-electrons.com/source/fs/jbd2/recovery.c?v=4.10#L291)\u3088\u308a\u3001recovery(replay)\u306e\u6700\u5f8c\u306b**REQ_OP_FLUSH**\u3092\u9001\u3063\u3066\u3044\u308b\u3002\n\n```c:recovery.c\n290         /* Make sure all replayed data is on permanent storage */\n291         if (journal->j_flags & JBD2_BARRIER) {\n292                 err2 = blkdev_issue_flush(journal->j_fs_dev, GFP_KERNEL, NULL);\n293                 if (!err)\n294                         err = err2;\n295         }\n```\n\n[kernel/fs/jbd2/checkpoint.c:**jbd2_journal_recover()**](http://lxr.free-electrons.com/source/fs/jbd2/checkpoint.c?v=4.10#L291)\u3088\u308a\u3001\u6700\u5f8c\u306b**REQ_OP_FLUSH**\u3092\u9001\u3063\u3066\u3044\u308b\u3002\u5927\u304d\u306a\u8996\u70b9\u304b\u3089journal\u306e\u72b6\u614b\u3092\u78ba\u5b9a\u3055\u305b\u305f\u3044\u307f\u305f\u3044\u3060\u3051\u3069\u3001\u666e\u6bb5\u304b\u3089flush\u306e\u30bf\u30a4\u30df\u30f3\u30b0\u3092\u6c17\u306b\u3057\u3066\u3044\u308b\u306f\u305a\u3060\u304b\u3089\u3001\u3053\u308c\u3063\u3066\u3044\u3089\u306a\u3044\u3093\u3058\u3083\u30fb\u30fb\u30fb\u78ba\u304b\u306b\u30b3\u30e1\u30f3\u30c8\u306b\u3042\u308b\u30a8\u30e9\u30fc(abort)\u304c\u51fa\u305f\u6642\u306f\u6c17\u306b\u3057\u305f\u307b\u3046\u304c\u3088\u3044\u3068\u306f\u601d\u3046\u304c\u3002\n\n```c:recovery.c\n369 /*\n370  * Check the list of checkpoint transactions for the journal to see if\n371  * we have already got rid of any since the last update of the log tail\n372  * in the journal superblock.  If so, we can instantly roll the\n373  * superblock forward to remove those transactions from the log.\n374  *\n375  * Return <0 on error, 0 on success, 1 if there was nothing to clean up.\n376  *\n377  * Called with the journal lock held.\n378  *\n379  * This is the only part of the journaling code which really needs to be\n380  * aware of transaction aborts.  Checkpointing involves writing to the\n381  * main filesystem area rather than to the journal, so it can proceed\n382  * even in abort state, but we must not update the super block if\n383  * checkpointing may have failed.  Otherwise, we would lose some metadata\n384  * buffers which should be written-back to the filesystem.\n385  */\n386 \n387 int jbd2_cleanup_journal_tail(journal_t *journal)\n388 {\n389         tid_t           first_tid;\n390         unsigned long   blocknr;\n391 \n392         if (is_journal_aborted(journal))\n393                 return -EIO;\n394 \n395         if (!jbd2_journal_get_log_tail(journal, &first_tid, &blocknr))\n396                 return 1;\n397         J_ASSERT(blocknr != 0);\n398 \n399         /*\n400          * We need to make sure that any blocks that were recently written out\n401          * --- perhaps by jbd2_log_do_checkpoint() --- are flushed out before\n402          * we drop the transactions from the journal. It's unlikely this will\n403          * be necessary, especially with an appropriately sized journal, but we\n404          * need this to guarantee correctness.  Fortunately\n405          * jbd2_cleanup_journal_tail() doesn't get called all that often.\n406          */\n407         if (journal->j_flags & JBD2_BARRIER)\n408                 blkdev_issue_flush(journal->j_fs_dev, GFP_NOFS, NULL);\n409 \n410         return __jbd2_update_log_tail(journal, first_tid, blocknr);\n411 }\n```\n\n# journal_async_commit\n## \u30b3\u30fc\u30c9\u3092\u8aad\u3080\n[kernel/fs/ext4/super.c](http://lxr.free-electrons.com/source/fs/ext4/super.c?v=4.10#L1333)\u3088\u308a\u3001**EXT4_MOUNT_JOURNAL_ASYNC_COMMIT**\u304c\u7acb\u3064\u3053\u3068\u304c\u308f\u304b\u308b\u3002\n\n```c:super.c\n1333         {Opt_journal_async_commit, \"journal_async_commit\"},\n```\n\n```c:super.c\n1523         {Opt_journal_async_commit, (EXT4_MOUNT_JOURNAL_ASYNC_COMMIT |\n1524                                     EXT4_MOUNT_JOURNAL_CHECKSUM),\n```\n\n[kernel/fs/ext4/super.c:**set_journal_csum_feature_set()**](http://lxr.free-electrons.com/source/fs/ext4/super.c?v=4.10#L3134)\u3088\u308a\u3001**JOURNAL_ASYNC_COMMIT**\u306e\u3068\u304d\u306b\u306e\u307fjbd2\u306e**JBD2_FEATURE_INCOMPAT_ASYNC_COMMIT**\u304c\u6709\u52b9\u306b\u306a\u308b\u3002\n\n```c:super.c\n3134         if (test_opt(sb, JOURNAL_ASYNC_COMMIT)) {\n3135                 ret = jbd2_journal_set_features(sbi->s_journal,\n3136                                 compat, 0,\n3137                                 JBD2_FEATURE_INCOMPAT_ASYNC_COMMIT |\n3138                                 incompat);\n3139         } else if (test_opt(sb, JOURNAL_CHECKSUM)) {\n3140                 ret = jbd2_journal_set_features(sbi->s_journal,\n3141                                 compat, 0,\n3142                                 incompat);\n3143                 jbd2_journal_clear_features(sbi->s_journal, 0, 0,\n3144                                 JBD2_FEATURE_INCOMPAT_ASYNC_COMMIT);\n3145         } else {\n3146                 jbd2_journal_clear_features(sbi->s_journal, 0, 0,\n3147                                 JBD2_FEATURE_INCOMPAT_ASYNC_COMMIT);\n3148         }\n```\n\n### ext4\u306e\u30b3\u30fc\u30c9\u3092\u8aad\u3080\n\u30a8\u30e9\u30fc\u30e1\u30c3\u30bb\u30fc\u30b8\u3092\u51fa\u3057\u3066\u3044\u308b\u3060\u3051\u3063\u307d\u3044\u3002\n\n[kernel/fs/ext4/super.c:**ext4_fill_super()**](http://lxr.free-electrons.com/source/fs/ext4/super.c?v=4.10#L3942)\u3088\u308a\u3001journal\u306a\u3057\u3067\u306f**journal_async_commit**\u3092\u8a31\u3057\u3066\u3044\u306a\u3044\u3002\n\n```c:super.c\n3927         if (!test_opt(sb, NOLOAD) && ext4_has_feature_journal(sb)) {\n3928                 if (ext4_load_journal(sb, es, journal_devnum))\n3929                         goto failed_mount3a;\n3930         } else if (test_opt(sb, NOLOAD) && !(sb->s_flags & MS_RDONLY) &&\n3931                    ext4_has_feature_journal_needs_recovery(sb)) {\n3932                 ext4_msg(sb, KERN_ERR, \"required journal recovery \"\n3933                        \"suppressed and not mounted read-only\");\n3934                 goto failed_mount_wq;\n3935         } else {\n3936                 /* Nojournal mode, all journal mount options are illegal */\n3937                 if (test_opt2(sb, EXPLICIT_JOURNAL_CHECKSUM)) {\n3938                         ext4_msg(sb, KERN_ERR, \"can't mount with \"\n3939                                  \"journal_checksum, fs mounted w/o journal\");\n3940                         goto failed_mount_wq;\n3941                 }\n3942                 if (test_opt(sb, JOURNAL_ASYNC_COMMIT)) {\n3943                         ext4_msg(sb, KERN_ERR, \"can't mount with \"\n3944                                  \"journal_async_commit, fs mounted w/o journal\");\n3945                         goto failed_mount_wq;\n3946                 }\n```\n\n[kernel/fs/ext4/super.c:**ext4_fill_super()**](http://lxr.free-electrons.com/source/fs/ext4/super.c?v=4.10#L4007)\u3088\u308a\u3001**data=ordered**\u306e\u3068\u304d\u306f**journal_async_commit**\u3092\u8a31\u3057\u3066\u3044\u306a\u3044\u3002\n\n```c:super.c\n4007         if (test_opt(sb, DATA_FLAGS) == EXT4_MOUNT_ORDERED_DATA &&\n4008             test_opt(sb, JOURNAL_ASYNC_COMMIT)) {\n4009                 ext4_msg(sb, KERN_ERR, \"can't mount with \"\n4010                         \"journal_async_commit in data=ordered mode\");\n4011                 goto failed_mount_wq;\n4012         }\n```\n\n[kernel/fs/ext4/super.c:ext4_remount()](http://lxr.free-electrons.com/source/fs/ext4/super.c?v=4.10#L4907)\u3088\u308a\u3001**data=ordered**\u306e\u3068\u304d\u306f**journal_async_commit**\u3092\u8a31\u3057\u3066\u3044\u306a\u3044\u3002\n\n```c;super.c\n4907         } else if (test_opt(sb, DATA_FLAGS) == EXT4_MOUNT_ORDERED_DATA) {\n4908                 if (test_opt(sb, JOURNAL_ASYNC_COMMIT)) {\n4909                         ext4_msg(sb, KERN_ERR, \"can't mount with \"\n4910                                 \"journal_async_commit in data=ordered mode\");\n4911                         err = -EINVAL;\n4912                         goto restore_opts;\n4913                 }\n4914         }\n````\n\n### jbd2\u306e\u30b3\u30fc\u30c9\u3092\u8aad\u3080\n\n[kernel/include/linux/jbd2.h](http://lxr.free-electrons.com/source/include/linux/jbd2.h?v=4.10#L1114)\u3088\u308a\u3001**jbd2_has_feature_async_commit**\u3092\u78ba\u8a8d\u3059\u308c\u3070\u826f\u3044\u3068\u308f\u304b\u308b\u3002\n\n```c:jbd2.h\n1114 JBD2_FEATURE_INCOMPAT_FUNCS(async_commit,       ASYNC_COMMIT)\n```\n\n[kernel/fs/jbd2/commit.c:**journal_submit_commit_record()**](http://lxr.free-electrons.com/source/fs/jbd2/commit.c?v=4.10#L156)\u3088\u308a\u3001**JBD2_BARRIER**\u306b\u3082\u95a2\u308f\u308b\u304c\u3001jbd2\u306ecommit\u30d6\u30ed\u30c3\u30af\u3092\u66f8\u304d\u51fa\u3059\u3068\u304d\u306b**REQ_PREFLUSH**, **REQ_FUA**\u3092\u6307\u5b9a\u3059\u308b\u304b\u3069\u3046\u304b\u306e\u5224\u65ad\u306b\u4f7f\u3063\u3066\u3044\u308b\u3002\n\n```c:commit.c\n156         if (journal->j_flags & JBD2_BARRIER &&\n157             !jbd2_has_feature_async_commit(journal))\n158                 ret = submit_bh(REQ_OP_WRITE,\n159                         REQ_SYNC | REQ_PREFLUSH | REQ_FUA, bh);\n160         else\n161                 ret = submit_bh(REQ_OP_WRITE, REQ_SYNC, bh);\n```\n\n[kernel/fs/jbd2/commit.c:**jbd2_journal_commit_transaction()**](http://lxr.free-electrons.com/source/fs/jbd2/commit.c?v=4.10#L778)\u3088\u308a\u3001journal_submit_commit_record()\u3092\u547c\u3076\u30bf\u30a4\u30df\u30f3\u30b0\u3092\u5909\u66f4\u3057\u3066\u3044\u308b\u3002commit phase 3\u306e\u6700\u5f8c\u304b\u3001commit phase 5\u306e\u6700\u521d\u304b\u3002\n\n```c:commit.c\n777         /* Done it all: now write the commit record asynchronously. */\n778         if (jbd2_has_feature_async_commit(journal)) {\n779                 err = journal_submit_commit_record(journal, commit_transaction,\n780                                                  &cbh, crc32_sum);\n781                 if (err)\n782                         __jbd2_journal_abort_hard(journal);\n783         }\n```\n```c:commit.c\n869         if (!jbd2_has_feature_async_commit(journal)) {\n870                 err = journal_submit_commit_record(journal, commit_transaction,\n871                                                 &cbh, crc32_sum);\n872                 if (err)\n873                         __jbd2_journal_abort_hard(journal);\n874         }\n```\n\n[kernel/fs/jbd2/commit.c:**jbd2_journal_commit_transaction()**](http://lxr.free-electrons.com/source/fs/jbd2/commit.c?v=4.10#L869)\u3088\u308a\u3001**journal_async_commit**\u304b\u3064**JBD2_BARRIER**\u306e\u3068\u304d\u306fjbd2\u306ecommit\u30d6\u30ed\u30c3\u30af\u3092\u66f8\u3044\u305f\u5f8c\u306b**REQ_OP_FLUSH**\u3092\u9001\u308b\u3068\u3057\u3066\u3044\u308b\u3002\n\n```c:commit.c\n869         if (!jbd2_has_feature_async_commit(journal)) {\n870                 err = journal_submit_commit_record(journal, commit_transaction,\n871                                                 &cbh, crc32_sum);\n872                 if (err)\n873                         __jbd2_journal_abort_hard(journal);\n874         }\n875         if (cbh)\n876                 err = journal_wait_on_commit_record(journal, cbh);\n877         if (jbd2_has_feature_async_commit(journal) &&\n878             journal->j_flags & JBD2_BARRIER) {\n879                 blkdev_issue_flush(journal->j_dev, GFP_NOFS, NULL);\n880         }\n```\n\n[kernel/fs/jbd2/recovery.c:**do_one_pass()**](http://lxr.free-electrons.com/source/fs/jbd2/recovery.c?v=4.10#L869)\u3088\u308a\u3001**journal_async_commit**\u306e\u5834\u5408\u306b\u8d77\u3053\u308a\u3046\u308bcommit\u30d6\u30ed\u30c3\u30af\u306ecorruption\u306e\u5224\u65ad\u3092\u3057\u3066\u3044\u308b\u3002\u3069\u3046\u3044\u3046\u30b1\u30fc\u30b9\u304b\u304c\u30b3\u30e1\u30f3\u30c8\u306b\u66f8\u3044\u3066\u3042\u308b\u3002...\u3067\u3082\u3001\u300c\u96fb\u6e90\u65ad\u3084IO\u30a8\u30e9\u30fc\u304c\u8d77\u3053\u3063\u305f\u6642\u306b**journal_async_commit**\u3060\u3063\u305f\u300d\u306e\u3068\u300c\u305d\u308c\u3092replay\u3059\u308b\u3068\u304d\u306b**journal_async_commit**\u3060\u3063\u305f\u300d\u306e\u3068\u306f\u9055\u3046\u3088\u3046\u306a...\n\n```c:recovery.c\n658                 case JBD2_COMMIT_BLOCK:\n659                         /*     How to differentiate between interrupted commit\n660                          *               and journal corruption ?\n661                          *\n662                          * {nth transaction}\n663                          *        Checksum Verification Failed\n664                          *                       |\n665                          *               ____________________\n666                          *              |                    |\n667                          *      async_commit             sync_commit\n668                          *              |                    |\n669                          *              | GO TO NEXT    \"Journal Corruption\"\n670                          *              | TRANSACTION\n671                          *              |\n672                          * {(n+1)th transanction}\n673                          *              |\n674                          *       _______|______________\n675                          *      |                     |\n676                          * Commit block found   Commit block not found\n677                          *      |                     |\n678                          * \"Journal Corruption\"       |\n679                          *               _____________|_________\n680                          *              |                       |\n681                          *      nth trans corrupt       OR   nth trans\n682                          *      and (n+1)th interrupted     interrupted\n683                          *      before commit block\n684                          *      could reach the disk.\n685                          *      (Cannot find the difference in above\n686                          *       mentioned conditions. Hence assume\n687                          *       \"Interrupted Commit\".)\n688                          */\n(----------snip----------)\n735                                         if (!jbd2_has_feature_async_commit(journal)) {\n736                                                 journal->j_failed_commit =\n737                                                         next_commit_ID;\n738                                                 brelse(bh);\n739                                                 break;\n740                                         }\n(----------snip----------)\n749                                 if (!jbd2_has_feature_async_commit(journal)) {\n750                                         journal->j_failed_commit =\n751                                                 next_commit_ID;\n752                                         brelse(bh);\n753                                         break;\n754                                 }\n```\n\n# REQ_OP_FLUSH, REQ_FUA, REQ_PREFLUSH, \n## \u7c21\u5358\u306a\u8aac\u660e\n\u4eca\u6642\u306e\u30b9\u30c8\u30ec\u30fc\u30b8\u306f\u30cf\u30fc\u30c9\u30a6\u30a7\u30a2\u306e\u30b9\u30c8\u30ec\u30fc\u30b8\u306e\u4e2d\u306b\u3082\u30ad\u30e3\u30c3\u30b7\u30e5\u3092\u6301\u3063\u3066\u3044\u3066\u3001\u5916\u304b\u3089\u898b\u305f\u66f8\u304d\u8fbc\u307f\u304c\u5b8c\u4e86\u3057\u305f\u304b\u3089\u3068\u8a00\u3063\u3066non volatile(\u4e0d\u63ee\u767a\u9818\u57df(\u96fb\u6e90\u65ad\u3057\u3066\u3082\u6d88\u3048\u306a\u3044\u3068\u3053))\u306b\u66f8\u3044\u305f\u3068\u306f\u9650\u3089\u306a\u3044\u3002\u3053\u306e\u30ad\u30e3\u30c3\u30b7\u30e5\u3092\u660e\u793a\u7684\u306b\u30b3\u30f3\u30c8\u30ed\u30fc\u30eb\u3057\u3088\u3046\u3068\u3044\u3046\u8981\u6c42\u306b\u306a\u308b\u3002\n\n**REQ_OP_FLUSH**, **REQ_PREFLUSH**\u306f\u3001\u30ad\u30e3\u30c3\u30b7\u30e5\u306b\u6b8b\u3063\u3066\u3044\u308b\u66f8\u304d\u51fa\u305b\u3066\u3044\u306a\u3044\u3082\u306e\u3092\u66f8\u304d\u51fa\u305b\u3001\u3068\u3044\u3046\u610f\u5473\u306b\u306a\u308b\u3002\n\n**REQ_FUA**\u306f\u3001\u6b21\u306b\u66f8\u3053\u3046\u3068\u3057\u3066\u3044\u308b\u3082\u306e\u306f\u30ad\u30e3\u30c3\u30b7\u30e5\u3060\u3051\u306b\u7559\u3081\u308b\u3053\u3068\u306f\u305b\u305a\u306b\u66f8\u304d\u51fa\u305b\u3001\u3068\u3044\u3046\u610f\u5473\u306b\u306a\u308b\u3002\n\n## \u521d\u5fc3\u8005\u5411\u3051\u86c7\u8db3\u306a\u6ce8\u610f\u4e8b\u9805\n\u30d7\u30ed\u30b0\u30e9\u30de\u304b\u3089\u3059\u308b\u3068\u3001\u30c7\u30fc\u30bf(\u30d5\u30a1\u30a4\u30eb)\u3092\u6271\u3046\u4e0a\u3067\u4e0b\u8a18\u306e\u3088\u3046\u306a\u30ad\u30e3\u30c3\u30b7\u30e5\u3092\u610f\u8b58\u3057\u306a\u3044\u3068\u3044\u3051\u306a\u3044\u3002\u3044\u3084\u3001\u5927\u4f53\u306e\u5834\u5408\u306fOS\u3084\u30e9\u30a4\u30d6\u30e9\u30ea\u304c\u52dd\u624b\u306b\u3084\u308b\u304b\u3089\u3042\u307e\u308a\u610f\u8b58\u3057\u306a\u304f\u3066\u3044\u3044(\u30cf\u30ba\u3060)\u3051\u3069\u3002\n\n - [**fflush(3)**](https://linuxjm.osdn.jp/html/LDP_man-pages/man3/fflush.3.html)\u985e\u3001\u30e6\u30fc\u30b6\u30e9\u30f3\u30c9\u3067\u306e\u30ad\u30e3\u30c3\u30b7\u30e5\n - [**sync(2)**](https://linuxjm.osdn.jp/html/LDP_man-pages/man2/sync.2.html)\u985e\u3001kernel\u306e\u30d6\u30ed\u30c3\u30af\u5c64\u3067\u306e\u30d0\u30c3\u30d5\u30a1\u30ad\u30e3\u30c3\u30b7\u30e5\n - [**ioprio_get(2)**](https://linuxjm.osdn.jp/html/LDP_man-pages/man2/ioprio_set.2.html)\u985e\u3001\u30c7\u30a3\u30b9\u30af\u30c9\u30e9\u30a4\u30d0\u304c\u8981\u6c42\u3092\u3069\u306e\u9806\u3067\u51e6\u7406\u3059\u308b\u304b\u306e\u30ad\u30e5\u30fc\u306b\u52b9\u304f\u3001IO scheduler(**/sys/block/sda/queue/scheduler**\u306a\u3069)\u306b\u3082\u6ce8\u610f\n - \u4eca\u56de\u6c17\u306b\u3066\u3044\u308b\u30b9\u30c8\u30ec\u30fc\u30b8\u5074\u304c\u6301\u3063\u3066\u3044\u308b\u4e2d\u306e\u30ad\u30e3\u30c3\u30b7\u30e5\n\n\u985e\u4f3c\u4f8b\u3068\u3057\u3066\u3001CPU\u306eL1/L2/L3\u30ad\u30e3\u30c3\u30b7\u30e5\u3068\u304b\u3001\u4e00\u90e8SoC\u3067\u306fDRAM\u4ee5\u5916\u306e\u30d0\u30b9\u306b\u3082\u30ad\u30e3\u30c3\u30b7\u30e5\u304c\u3042\u3063\u305f\u308a\u3068\u304b\u3002\u305f\u3060\u3069\u308c\u3082\u4e00\u8a00\u3067\u300c\u30ad\u30e3\u30c3\u30b7\u30e5(cache)\u300d\u3068\u3060\u3051\u8a00\u308f\u308c\u308b\u3053\u3068\u304c\u591a\u3044\u305f\u3081\u3001\u3069\u3053\u306e\u30ad\u30e3\u30c3\u30b7\u30e5\u306e\u3053\u3068\u306a\u306e\u304b\u3092\u5e38\u306b\u610f\u8b58\u3057\u306a\u3044\u3068\u3044\u3051\u306a\u3044\u3002\n\n\u4eca\u6642\u306eCPU\u306fGHz\u30aa\u30fc\u30c0\u3067\u3067\u30ad\u30d3\u30ad\u30d3\u52d5\u304f\u3051\u3069\u3001\u305d\u308c\u3092\u6709\u52b9\u306b\u4f7f\u3046\u306b\u306f\u7d76\u3048\u9593\u306a\u304f\u30c7\u30fc\u30bf\u3092\u6d41\u3057\u8fbc\u307e\u306a\u3044\u3068\u3044\u3051\u306a\u3044\u306e\u3067\u3001\u305d\u306e\u30c7\u30fc\u30bf\u3092\u5b89\u5b9a\u63a2\u5075\u3057\u3066\u4f9b\u7d66\u3059\u308b\u305f\u3081\u306b\u305d\u3053\u3089\u3058\u3085\u3046\u306b\u30ad\u30e3\u30c3\u30b7\u30e5\u304c\u3042\u308b\u3002\u30ad\u30e3\u30c3\u30b7\u30e5\u304c\u3042\u308b\u3068\u30c7\u30fc\u30bf\u4e00\u8cab\u6027\u304c\u5d29\u308c\u308b\u306e\u3067\u3001\u4e00\u8cab\u6027\u3092\u4fdd\u3064\u305f\u3081\u306b\u8272\u3005\u3057\u306a\u3044\u3068\u3044\u3051\u306a\u304f\u3066\u9762\u5012\u306b\u306a\u308b\u3002\n\n## \u5b9a\u7fa9\n[**kernel/include/linux/blk_types.h**](http://lxr.free-electrons.com/source/include/linux/blk_types.h?v=4.10#L145)\u3067\u5b9a\u7fa9\u3055\u308c\u3066\u3044\u308b\u3002OP\u304c\u4ed8\u3044\u3066\u3044\u308b\u307b\u3046\u304c\u30ea\u30af\u30a8\u30b9\u30c8\u306e\u7a2e\u985e(1\u7a2e\u985e\u3057\u304b\u9078\u3079\u306a\u3044)\u3001OP\u304c\u3064\u3044\u3066\u3044\u306a\u3044\u307b\u3046\u304c\u30d5\u30e9\u30b0(\u30ea\u30af\u30a8\u30b9\u30c8\u306b\u5bfe\u3057\u30d3\u30c3\u30c8\u3067\u8907\u6570\u7acb\u3066\u3089\u308c\u308b)\u3001\u3068\u306a\u3063\u3066\u3044\u308b\u3002\n\n```c:blk_types.h\n145 enum req_opf {\n146         /* read sectors from the device */\n147         REQ_OP_READ             = 0,\n148         /* write sectors to the device */\n149         REQ_OP_WRITE            = 1,\n150         /* flush the volatile write cache */\n151         REQ_OP_FLUSH            = 2,\n152         /* discard sectors */\n153         REQ_OP_DISCARD          = 3,\n154         /* get zone information */\n155         REQ_OP_ZONE_REPORT      = 4,\n156         /* securely erase sectors */\n157         REQ_OP_SECURE_ERASE     = 5,\n158         /* seset a zone write pointer */\n159         REQ_OP_ZONE_RESET       = 6,\n160         /* write the same sector many times */\n161         REQ_OP_WRITE_SAME       = 7,\n162         /* write the zero filled sector many times */\n163         REQ_OP_WRITE_ZEROES     = 8,\n164 \n165         REQ_OP_LAST,\n166 };\n167 \n168 enum req_flag_bits {\n169         __REQ_FAILFAST_DEV =    /* no driver retries of device errors */\n170                 REQ_OP_BITS,\n171         __REQ_FAILFAST_TRANSPORT, /* no driver retries of transport errors */\n172         __REQ_FAILFAST_DRIVER,  /* no driver retries of driver errors */\n173         __REQ_SYNC,             /* request is sync (sync write or read) */\n174         __REQ_META,             /* metadata io request */\n175         __REQ_PRIO,             /* boost priority in cfq */\n176         __REQ_NOMERGE,          /* don't touch this for merging */\n177         __REQ_IDLE,             /* anticipate more IO after this one */\n178         __REQ_INTEGRITY,        /* I/O includes block integrity payload */\n179         __REQ_FUA,              /* forced unit access */\n180         __REQ_PREFLUSH,         /* request for cache flush */\n181         __REQ_RAHEAD,           /* read ahead, can fail anytime */\n182         __REQ_BACKGROUND,       /* background IO */\n183         __REQ_NR_BITS,          /* stops here */\n184 };\n185 \n186 #define REQ_FAILFAST_DEV        (1ULL << __REQ_FAILFAST_DEV)\n187 #define REQ_FAILFAST_TRANSPORT  (1ULL << __REQ_FAILFAST_TRANSPORT)\n188 #define REQ_FAILFAST_DRIVER     (1ULL << __REQ_FAILFAST_DRIVER)\n189 #define REQ_SYNC                (1ULL << __REQ_SYNC)\n190 #define REQ_META                (1ULL << __REQ_META)\n191 #define REQ_PRIO                (1ULL << __REQ_PRIO)\n192 #define REQ_NOMERGE             (1ULL << __REQ_NOMERGE)\n193 #define REQ_IDLE                (1ULL << __REQ_IDLE)\n194 #define REQ_INTEGRITY           (1ULL << __REQ_INTEGRITY)\n195 #define REQ_FUA                 (1ULL << __REQ_FUA)\n196 #define REQ_PREFLUSH            (1ULL << __REQ_PREFLUSH)\n197 #define REQ_RAHEAD              (1ULL << __REQ_RAHEAD)\n198 #define REQ_BACKGROUND          (1ULL << __REQ_BACKGROUND)\n```\n\n\u3061\u306a\u307f\u306b\u3001\u3053\u306e**REQ_BACKGROUND**\u304c[Linux-4.10\u3067\u306e\u76ee\u7389\u306e\u6a5f\u80fd(writeback\u306e\u6539\u5584)](https://lwn.net/Articles/682582/)\u3089\u3057\u3044\u3067\u3059\u3002\n\n## Documentation\n[**kernel/Documentation/block/writeback_cache_control.txt**](http://lxr.free-electrons.com/source/Documentation/block/writeback_cache_control.txt?v=4.10)\u306b\u305d\u308c\u3063\u307d\u3044\u30c9\u30ad\u30e5\u30e1\u30f3\u30c8\u304c\u3042\u308b\u3002\n\n## REQ_FUA\n### scsi(sd)\u306e\u5834\u5408\nscsi disk(sd)\u3060\u3068\u3001**WRITE_32**, **WRITE_16** \u30b3\u30de\u30f3\u30c9\u306e\u6642\u306e **FUA_NV**\u30d3\u30c3\u30c8\u3092\u6307\u5b9a\u3057\u3066\u3044\u308b\u3002\n[SCSI\u4ed5\u69d8\u66f8(PDF)](http://www.seagate.com/staticfiles/support/disc/manuals/scsi/100293068a.pdf)\u306b\u3088\u308c\u3070\u3001\n\n```text\nWRITE: If FUA = 1, all data must be written to the media before the SCSI operation returns the status and completion message bytes\n```\n\n### eMMC\u306e\u5834\u5408\n**reliable write**\u3092\u3059\u308b\u3002JEDEC\u306b\u3088\u308b\u3068reliable write\u306f\u3001cache\u306b\u7559\u3081\u306a\u3044write\u3067\u3042\u308b\u3053\u3068\u304c\u898f\u5b9a\u3055\u308c\u3066\u3044\u308b\u3002http://www.jedec.org/sites/default/files/docs/JESD84-B451.pdf \u306f\u4f1a\u54e1\u3057\u304b\u898b\u308c\u306a\u3044\u3002...JEDEC\u306e\u4ed5\u69d8\u66f8\u3063\u3066\u58f2\u308a\u7269\u3060\u304b\u3089\u30cd\u30c3\u30c8\u306b\u30bf\u30c0\u3067\u898b\u308c\u308b\u72b6\u614b\u3067\u7f6e\u3044\u3061\u3083\u307e\u305a\u304b\u3063\u305f\u3093\u3058\u3083\u306a\u304b\u3063\u305f\u3063\u3051\u3002\u30b0\u30b0\u308c\u3070\u666e\u901a\u306b\u898b\u3048\u3061\u3083\u3046\u30b5\u30a4\u30c8\u3082\u3042\u308b\u4ef6\u3002\n\n## REQ_PREFLUSH\n\u8a72\u5f53\u306e\u30ea\u30af\u30a8\u30b9\u30c8\u3092\u51e6\u7406\u3059\u308b\u524d\u306b**REQ_OP_FLUSH**\u304c\u30ea\u30af\u30a8\u30b9\u30c8\u3055\u308c\u305f\u306e\u3068\u540c\u3058\u3053\u3068\u3092\u3059\u308b\u3001\u3068\u3044\u3046\u610f\u5473\u306b\u306a\u308b\u3002\n\n## REQ_OP_FLUSH\n### scsi(sd)\u306e\u5834\u5408\n**SYNCHRONIZE_CACHE** (SYNCHRONIZE CACHE 10\u30b3\u30de\u30f3\u30c9)\u3092\u9001\u3063\u3066\u3044\u308b\u3002\n### eMMC\u306e\u5834\u5408\n**EXT_CSD_FLUSH_CACHE** (index 32)\u306b1\u3092\u66f8\u3044\u3066\u3044\u308b\n\n# \u3042\u3068\u304c\u304d\n**journal_async_commit**\u306f\u3068\u3082\u304b\u304f\u3001**nobarrier**\u306fRAID\u3084lvm\u306a\u3069\u8907\u6570\u306e\u30b9\u30c8\u30ec\u30fc\u30b8\u306b\u5206\u6563\u3059\u308b\u6642\u3068\u304d\u306b\u30ad\u30e3\u30c3\u30b7\u30e5\u304c\u8907\u6570\u306b\u5206\u304b\u308c\u3066\u30bf\u30a4\u30df\u30f3\u30b0\u304c\u8aad\u3081\u306a\u304f\u306a\u308b\u306e\u3067\u3001\u4e0d\u7528\u610f\u306b**nobarrier**\u3092\u3064\u3051\u308b\u3068\u96fb\u6e90\u65ad\u306b\u5f31\u304f\u306a\u308b\u3068\u601d\u308f\u308c\u308b\u3002\u5927\u4e8b\u306a\u30c7\u30fc\u30bf\u3060\u3068UPS\u985e\u306a\u3057\u306b\u306f\u4f7f\u3048\u306a\u3044\u3002\u9006\u306b\u5358\u4f53\u30b9\u30c8\u30ec\u30fc\u30b8\u3060\u3068\u3001\u4e2d\u306e\u30d5\u30a1\u30fc\u30e0\u30a6\u30a7\u30a2\u6b21\u7b2c\u3060\u3051\u3069\u3001\u6bd4\u8f03\u7684\u5371\u967a\u304c\u5c11\u306a\u3044\u3068\u601d\u308f\u308c\u308b\u3002\n\n\u305f\u3060\u3044\u305a\u308c\u3082\u3001\u4e2d\u306e\u30d5\u30a1\u30fc\u30e0\u30a6\u30a7\u30a2\u6b21\u7b2c\u306a\u306e\u3067\u3001fua\u3084cache\u306e\u30b3\u30de\u30f3\u30c9\u306b\u30a6\u30bd\u3064\u3044\u3066\u3044\u308b(\u300c\u5b8c\u4e86\u300d\u3068\u3044\u3044\u3064\u3064\u5b9f\u969b\u306b\u306f\u4f55\u3082\u3057\u3066\u3044\u306a\u3044)\u3068\u3001ext4/jbd2\u304c\u3084\u3063\u3066\u3044\u308b\u4e0a\u8a18\u306e\u3088\u3046\u306a\u3053\u3068\u304c\u610f\u5473\u3092\u306a\u3055\u306a\u304f\u306a\u308b\u3002\u9006\u306e\u3053\u3068\u3082\u8d77\u3053\u308a\u3048\u3066\u30015\u5e74\u307b\u3069\u524d\u306f\u3088\u304f\u3042\u3063\u305f\u300c\u30d7\u30c1\u30d5\u30eaSSD\u300d\u306e\u3088\u3046\u306b\u3001\u51e6\u7406\u306e\u9069\u6b63\u5316\u304c\u9032\u3093\u3067\u3044\u306a\u3044\u30d5\u30a1\u30fc\u30e0\u30a6\u30a7\u30a2\u3067\u30d1\u30d5\u30a9\u30fc\u30de\u30f3\u30b9\u304c\u30c0\u30c0\u843d\u3061\u306b\u306a\u3063\u3066\u3057\u307e\u3063\u305f\u308a\u3068\u3002\n\n\u30c7\u30a3\u30b9\u30af\u66f8\u304d\u51fa\u3057\u306b\u95a2\u308f\u308b\u3068\u3053\u306f\u304a\u304a\u3080\u306d\u898b\u7d42\u308f\u3063\u305f\u305f\u3081\u3001\u3053\u308c\u3067ext4\u95a2\u9023\u306e\u8a18\u4e8b\u306f\u7d42\u308f\u308a\u306e\u4e88\u5b9a\u3067\u3059\u3002\u6c17\u306b\u306a\u308b\u65b9\u306f[\u904e\u53bb\u306e\u8a18\u4e8b\u3082\u53c2\u8003\u306b](http://qiita.com/rarul)\u3057\u3066\u3082\u3089\u3048\u308c\u3070\u3068\u601d\u3044\u307e\u3059\u3002\n\n...\u3042\u3001Linux-4.10\u3067LogFS\u6d88\u3055\u308c\u3066\u308b...\n", "tags": ["kernel", "ext4", "jbd2", "journal_async_commit", "nobarrier"]}