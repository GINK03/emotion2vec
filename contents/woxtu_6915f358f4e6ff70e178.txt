{"context": " More than 1 year has passed since last update.\u3000\u3084\u3063\u306f\u308d\u30fc\u3002\u3053\u308c\u306f\u3001Rust Advent Calendar 2014 \u306e 7\u65e5\u76ee\u306e\u8a18\u4e8b\u3067\u3059\u3002Rust \u304b\u3089 OpenGL \u3092\u53e9\u3044\u3066\u307f\u305f\u304b\u3063\u305f\u306e\u3067\u3001\u30b7\u30c0\u3092\u63cf\u304f\u3053\u3068\u306b\u3057\u307e\u3057\u305f\u3002\n\u3000\u5143\u30cd\u30bf\u3067\u3059\u3002\n\n\u30d7\u30ed\u30b0\u30e9\u30e0\u3067\u30b7\u30c0\u3092\u63cf\u753b\u3059\u308b - \u5f37\u706b\u3067\u9032\u3081\n\u300c\u30d7\u30ed\u30b0\u30e9\u30e0\u3067\u30b7\u30c0\u3092\u63cf\u753b\u3059\u308b\u300d\u4e00\u89a7 - Qiita\n\n// rustc 0.13.0-nightly (d9c7c00b9 2014-12-04 21:33:07 +0000)\n\nextern crate gl;\nextern crate glfw;\n\nuse std::{mem, ptr, rand};\nuse gl::types::{GLboolean, GLfloat, GLsizeiptr};\nuse glfw::Context;\n\nconst WIDTH: uint = 512;\nconst HEIGHT: uint = 512;\n\nstatic VERTEX_SOURCE: &'static str = \"\n  #version 150\n\n  in vec2 position;\n  out vec2 texcoord;\n\n  void main() {\n    texcoord = (vec2(position.x, -1.0 * position.y) + 1.0) / 2.0;\n    gl_Position = vec4(position, 0.0, 1.0);\n  }\";\n\nstatic FRAGMENT_SOURCE: &'static str = \"\n  #version 150\n\n  uniform sampler2D tex;\n  in vec2 texcoord;\n  out vec4 color;\n\n  void main() {\n    if (0 < texture(tex, texcoord).r) {\n      color = vec4(0.125, 0.502, 0.125, 1.0);\n    } else {\n      color = vec4(0.0);\n    }\n  }\";\n\nfn main() {\n  let image = {\n    static mut buffer: [u8, ..WIDTH * HEIGHT] = [0, ..WIDTH * HEIGHT];\n\n    fn fern(n: uint, x: f64, y: f64) {\n      fn w1x(x: f64, y: f64) -> f64 { 0.836 * x + 0.044 * y }\n      fn w1y(x: f64, y: f64) -> f64 { -0.044 * x + 0.836 * y + 0.169 }\n      fn w2x(x: f64, y: f64) -> f64 { -0.141 * x + 0.302 * y }\n      fn w2y(x: f64, y: f64) -> f64 { 0.302 * x + 0.141 * y + 0.127 }\n      fn w3x(x: f64, y: f64) -> f64 { 0.141 * x - 0.302 * y }\n      fn w3y(x: f64, y: f64) -> f64 { 0.302 * x + 0.141 * y + 0.169 }\n      fn w4x(_: f64, _: f64) -> f64 { 0.0 }\n      fn w4y(_: f64, y: f64) -> f64 { 0.175337 * y }\n\n      if 0 < n {\n        fern(n - 1, w1x(x, y), w1y(x, y));\n        if rand::random::<f64>() < 0.3 { fern(n - 1, w2x(x, y), w2y(x, y)); } \n        if rand::random::<f64>() < 0.3 { fern(n - 1, w3x(x, y), w3y(x, y)); } \n        if rand::random::<f64>() < 0.3 { fern(n - 1, w4x(x, y), w4y(x, y)); } \n      } else {\n        let x = (x * WIDTH as f64 + WIDTH as f64 * 0.5) as uint;\n        let y = (HEIGHT as f64 - y * HEIGHT as f64) as uint;\n        unsafe { buffer[x + y * HEIGHT] = 1; }\n      }\n    }\n\n    fern(20, 0.0, 0.0);\n    unsafe { buffer.to_vec() }\n  };\n\n  unsafe {\n    let glfw = glfw::init(glfw::FAIL_ON_ERRORS).unwrap();\n    glfw.window_hint(glfw::WindowHint::ContextVersion(3, 2));\n    glfw.window_hint(glfw::WindowHint::OpenglForwardCompat(true));\n    glfw.window_hint(glfw::WindowHint::OpenglProfile(glfw::OpenGlProfileHint::Core));\n\n    let (window, _) =\n      glfw.create_window(WIDTH as u32, HEIGHT as u32, \"fern\", glfw::WindowMode::Windowed).unwrap();\n    window.make_current();\n    gl::load_with(|s| window.get_proc_address(s));\n\n    let program = gl::CreateProgram();\n    for &(type_, source) in [(gl::VERTEX_SHADER, VERTEX_SOURCE),\n                             (gl::FRAGMENT_SHADER, FRAGMENT_SOURCE)].iter() {\n      let shader = gl::CreateShader(type_);\n      source.with_c_str(|source| gl::ShaderSource(shader, 1, &source, ptr::null()));\n      gl::CompileShader(shader);\n      gl::AttachShader(program, shader);\n      gl::DeleteShader(shader);\n    }\n    gl::LinkProgram(program);\n    gl::UseProgram(program);\n    \"color\".with_c_str(|p| gl::BindFragDataLocation(program, 0, p));\n    \"tex\".with_c_str(|p| gl::Uniform1i(gl::GetUniformLocation(program, p), 0));\n    gl::UseProgram(0);\n\n    let mut array = 0;\n    gl::GenVertexArrays(1, &mut array);\n    gl::BindVertexArray(array);\n\n    let position = [-1.0f32, 1.0, 1.0, 1.0, -1.0, -1.0, 1.0, -1.0];\n    let mut buffer = 0;\n    gl::GenBuffers(1, &mut buffer);\n    gl::BindBuffer(gl::ARRAY_BUFFER, buffer);\n    gl::BufferData(gl::ARRAY_BUFFER,\n                   (position.len() * mem::size_of::<GLfloat>()) as GLsizeiptr,\n                   mem::transmute(position.as_ptr()),\n                   gl::STATIC_DRAW);\n    \"position\".with_c_str(|p| {\n      let location = gl::GetAttribLocation(program, p) as u32;\n      gl::EnableVertexAttribArray(location);\n      gl::VertexAttribPointer(location, 2, gl::FLOAT, gl::FALSE as GLboolean, 0, ptr::null());\n    });\n    gl::BindBuffer(gl::ARRAY_BUFFER, 0);\n    gl::BindVertexArray(0);\n\n    let mut texture = 0;\n    gl::GenTextures(1, &mut texture);\n    gl::BindTexture(gl::TEXTURE_2D, texture);\n    gl::TexParameteri(gl::TEXTURE_2D, gl::TEXTURE_MIN_FILTER, gl::LINEAR as i32);\n    gl::TexParameteri(gl::TEXTURE_2D, gl::TEXTURE_MAG_FILTER, gl::LINEAR as i32);\n    gl::TexImage2D(gl::TEXTURE_2D, 0, gl::RGB as i32,\n                   WIDTH as i32, HEIGHT as i32,\n                   0, gl::RED, gl::UNSIGNED_BYTE, mem::transmute(image.as_ptr()));\n    gl::BindTexture(gl::TEXTURE_2D, 0);\n\n    gl::ClearColor(1.0, 1.0, 1.0, 1.0);\n    gl::Enable(gl::BLEND);\n    gl::BlendFunc(gl::SRC_ALPHA, gl::ONE_MINUS_SRC_ALPHA);\n\n    while !window.should_close() {\n      glfw.poll_events();\n\n      gl::Clear(gl::COLOR_BUFFER_BIT);\n\n      gl::UseProgram(program);\n      gl::BindTexture(gl::TEXTURE_2D, texture);\n      gl::BindVertexArray(array);\n\n      gl::DrawArrays(gl::TRIANGLE_STRIP, 0, 4);\n\n      gl::BindVertexArray(0);\n      gl::BindTexture(gl::TEXTURE_2D, 0);\n      gl::UseProgram(0);\n\n      window.swap_buffers();\n    }\n\n    gl::DeleteTextures(1, &texture);\n    gl::DeleteBuffers(1, &buffer);\n    gl::DeleteVertexArrays(1, &array);\n    gl::DeleteProgram(program);\n  }\n}\n\n\n\u697d\u3057\u3044\uff01\u208d\u208d (\u0e07\u2579\u25e1\u2579)\u0e27 \u207e\u207e\n\n\u5e8a\u4e95\u7814\u7a76\u5ba4\nwgld.org\nbjz/gl-rs - GitHub\nbjz/glfw-rs - GitHub\n\n\u3000\u3084\u3063\u306f\u308d\u30fc\u3002\u3053\u308c\u306f\u3001[Rust Advent Calendar 2014](http://www.adventar.org/calendars/462) \u306e 7\u65e5\u76ee\u306e\u8a18\u4e8b\u3067\u3059\u3002Rust \u304b\u3089 OpenGL \u3092\u53e9\u3044\u3066\u307f\u305f\u304b\u3063\u305f\u306e\u3067\u3001\u30b7\u30c0\u3092\u63cf\u304f\u3053\u3068\u306b\u3057\u307e\u3057\u305f\u3002\n\n\u3000\u5143\u30cd\u30bf\u3067\u3059\u3002\n\n> [\u30d7\u30ed\u30b0\u30e9\u30e0\u3067\u30b7\u30c0\u3092\u63cf\u753b\u3059\u308b - \u5f37\u706b\u3067\u9032\u3081](http://d.hatena.ne.jp/nakamura001/20140505/1399316565)\n\n> [\u300c\u30d7\u30ed\u30b0\u30e9\u30e0\u3067\u30b7\u30c0\u3092\u63cf\u753b\u3059\u308b\u300d\u4e00\u89a7 - Qiita](http://qiita.com/qt-luigi/items/b22204c7ef73260324bd)\n\n```rust\n// rustc 0.13.0-nightly (d9c7c00b9 2014-12-04 21:33:07 +0000)\n\nextern crate gl;\nextern crate glfw;\n\nuse std::{mem, ptr, rand};\nuse gl::types::{GLboolean, GLfloat, GLsizeiptr};\nuse glfw::Context;\n\nconst WIDTH: uint = 512;\nconst HEIGHT: uint = 512;\n\nstatic VERTEX_SOURCE: &'static str = \"\n  #version 150\n\n  in vec2 position;\n  out vec2 texcoord;\n\n  void main() {\n    texcoord = (vec2(position.x, -1.0 * position.y) + 1.0) / 2.0;\n    gl_Position = vec4(position, 0.0, 1.0);\n  }\";\n\nstatic FRAGMENT_SOURCE: &'static str = \"\n  #version 150\n\n  uniform sampler2D tex;\n  in vec2 texcoord;\n  out vec4 color;\n\n  void main() {\n    if (0 < texture(tex, texcoord).r) {\n      color = vec4(0.125, 0.502, 0.125, 1.0);\n    } else {\n      color = vec4(0.0);\n    }\n  }\";\n\nfn main() {\n  let image = {\n    static mut buffer: [u8, ..WIDTH * HEIGHT] = [0, ..WIDTH * HEIGHT];\n\n    fn fern(n: uint, x: f64, y: f64) {\n      fn w1x(x: f64, y: f64) -> f64 { 0.836 * x + 0.044 * y }\n      fn w1y(x: f64, y: f64) -> f64 { -0.044 * x + 0.836 * y + 0.169 }\n      fn w2x(x: f64, y: f64) -> f64 { -0.141 * x + 0.302 * y }\n      fn w2y(x: f64, y: f64) -> f64 { 0.302 * x + 0.141 * y + 0.127 }\n      fn w3x(x: f64, y: f64) -> f64 { 0.141 * x - 0.302 * y }\n      fn w3y(x: f64, y: f64) -> f64 { 0.302 * x + 0.141 * y + 0.169 }\n      fn w4x(_: f64, _: f64) -> f64 { 0.0 }\n      fn w4y(_: f64, y: f64) -> f64 { 0.175337 * y }\n\n      if 0 < n {\n        fern(n - 1, w1x(x, y), w1y(x, y));\n        if rand::random::<f64>() < 0.3 { fern(n - 1, w2x(x, y), w2y(x, y)); } \n        if rand::random::<f64>() < 0.3 { fern(n - 1, w3x(x, y), w3y(x, y)); } \n        if rand::random::<f64>() < 0.3 { fern(n - 1, w4x(x, y), w4y(x, y)); } \n      } else {\n        let x = (x * WIDTH as f64 + WIDTH as f64 * 0.5) as uint;\n        let y = (HEIGHT as f64 - y * HEIGHT as f64) as uint;\n        unsafe { buffer[x + y * HEIGHT] = 1; }\n      }\n    }\n\n    fern(20, 0.0, 0.0);\n    unsafe { buffer.to_vec() }\n  };\n\n  unsafe {\n    let glfw = glfw::init(glfw::FAIL_ON_ERRORS).unwrap();\n    glfw.window_hint(glfw::WindowHint::ContextVersion(3, 2));\n    glfw.window_hint(glfw::WindowHint::OpenglForwardCompat(true));\n    glfw.window_hint(glfw::WindowHint::OpenglProfile(glfw::OpenGlProfileHint::Core));\n\n    let (window, _) =\n      glfw.create_window(WIDTH as u32, HEIGHT as u32, \"fern\", glfw::WindowMode::Windowed).unwrap();\n    window.make_current();\n    gl::load_with(|s| window.get_proc_address(s));\n\n    let program = gl::CreateProgram();\n    for &(type_, source) in [(gl::VERTEX_SHADER, VERTEX_SOURCE),\n                             (gl::FRAGMENT_SHADER, FRAGMENT_SOURCE)].iter() {\n      let shader = gl::CreateShader(type_);\n      source.with_c_str(|source| gl::ShaderSource(shader, 1, &source, ptr::null()));\n      gl::CompileShader(shader);\n      gl::AttachShader(program, shader);\n      gl::DeleteShader(shader);\n    }\n    gl::LinkProgram(program);\n    gl::UseProgram(program);\n    \"color\".with_c_str(|p| gl::BindFragDataLocation(program, 0, p));\n    \"tex\".with_c_str(|p| gl::Uniform1i(gl::GetUniformLocation(program, p), 0));\n    gl::UseProgram(0);\n\n    let mut array = 0;\n    gl::GenVertexArrays(1, &mut array);\n    gl::BindVertexArray(array);\n\n    let position = [-1.0f32, 1.0, 1.0, 1.0, -1.0, -1.0, 1.0, -1.0];\n    let mut buffer = 0;\n    gl::GenBuffers(1, &mut buffer);\n    gl::BindBuffer(gl::ARRAY_BUFFER, buffer);\n    gl::BufferData(gl::ARRAY_BUFFER,\n                   (position.len() * mem::size_of::<GLfloat>()) as GLsizeiptr,\n                   mem::transmute(position.as_ptr()),\n                   gl::STATIC_DRAW);\n    \"position\".with_c_str(|p| {\n      let location = gl::GetAttribLocation(program, p) as u32;\n      gl::EnableVertexAttribArray(location);\n      gl::VertexAttribPointer(location, 2, gl::FLOAT, gl::FALSE as GLboolean, 0, ptr::null());\n    });\n    gl::BindBuffer(gl::ARRAY_BUFFER, 0);\n    gl::BindVertexArray(0);\n\n    let mut texture = 0;\n    gl::GenTextures(1, &mut texture);\n    gl::BindTexture(gl::TEXTURE_2D, texture);\n    gl::TexParameteri(gl::TEXTURE_2D, gl::TEXTURE_MIN_FILTER, gl::LINEAR as i32);\n    gl::TexParameteri(gl::TEXTURE_2D, gl::TEXTURE_MAG_FILTER, gl::LINEAR as i32);\n    gl::TexImage2D(gl::TEXTURE_2D, 0, gl::RGB as i32,\n                   WIDTH as i32, HEIGHT as i32,\n                   0, gl::RED, gl::UNSIGNED_BYTE, mem::transmute(image.as_ptr()));\n    gl::BindTexture(gl::TEXTURE_2D, 0);\n\n    gl::ClearColor(1.0, 1.0, 1.0, 1.0);\n    gl::Enable(gl::BLEND);\n    gl::BlendFunc(gl::SRC_ALPHA, gl::ONE_MINUS_SRC_ALPHA);\n\n    while !window.should_close() {\n      glfw.poll_events();\n\n      gl::Clear(gl::COLOR_BUFFER_BIT);\n\n      gl::UseProgram(program);\n      gl::BindTexture(gl::TEXTURE_2D, texture);\n      gl::BindVertexArray(array);\n\n      gl::DrawArrays(gl::TRIANGLE_STRIP, 0, 4);\n\n      gl::BindVertexArray(0);\n      gl::BindTexture(gl::TEXTURE_2D, 0);\n      gl::UseProgram(0);\n\n      window.swap_buffers();\n    }\n\n    gl::DeleteTextures(1, &texture);\n    gl::DeleteBuffers(1, &buffer);\n    gl::DeleteVertexArrays(1, &array);\n    gl::DeleteProgram(program);\n  }\n}\n```\n\n![\u30b7\u30c0](https://qiita-image-store.s3.amazonaws.com/0/4250/92ef4595-52bb-475e-04cb-40fcee623464.png)\n\n\u697d\u3057\u3044\uff01\u208d\u208d (\u0e07\u2579\u25e1\u2579)\u0e27 \u207e\u207e\n\n> [\u5e8a\u4e95\u7814\u7a76\u5ba4](http://marina.sys.wakayama-u.ac.jp/~tokoi/)\n\n> [wgld.org](http://wgld.org/)\n\n> [bjz/gl-rs - GitHub](https://github.com/bjz/gl-rs)\n\n> [bjz/glfw-rs - GitHub](https://github.com/bjz/glfw-rs)\n", "tags": ["rust"]}