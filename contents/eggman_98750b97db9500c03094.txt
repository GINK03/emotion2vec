{"context": "SD Association \u306e SD host controller \u4ed5\u69d8\u306ehost controller \u306eSDIO\u30c7\u30fc\u30bf\u3092DMA\u8ee2\u9001\u306e\u624b\u9806\u306b\u3064\u3044\u3066Linux Kernel\u306e\u5b9f\u88c5\u3092\u8abf\u3079\u3066\u307f\u307e\u3057\u305f\u3002\n\n\u307e\u3068\u3081\n\nLinux kernel\u306fSD host\u4ed5\u69d8\u306eSDMA\u3068ADMA\u306b\u5bfe\u5fdc\u3057\u3066\u3044\u308b\u3002\nmmc/core (\u5171\u901a\u90e8\u5206)\u3067\u9001\u4fe1\u30c7\u30fc\u30bf\u306blinux kernel\u306escatter gather\u306e\u5f62\u5f0f\u306e\u60c5\u5831\u3092\u4ed8\u52a0\u3059\u308b\u3002\nsdhost controller\u306e\u30c9\u30e9\u30a4\u30d0(\u30db\u30b9\u30c8\u30c9\u30e9\u30a4\u30d0\u90e8\u5206)\u3067\u3001DMA\u7121\u3057\u3001ADMA, SDMA\u306e\u3069\u308c\u3092\u4f7f\u3046\u304b\u9078\u629e\u3059\u308b\u3002\nSDMA\u3092\u4f7f\u3046\u5834\u5408\u306fscatter gather\u306e\u60c5\u5831\u306f\u7121\u8996\u3057\u3066\u3001\uff11\u500b\u306e\u30c7\u30fc\u30bf\u3068\u3057\u3066DMA\u8ee2\u9001\u3059\u308b\u3002\nADMA\u3092\u4f7f\u3046\u5834\u5408\u306fscatter gather\u306e\u60c5\u5831\u3092ADMA\u306escatter gather\u306e\u5f62\u5f0f\u306b\u5909\u63db\u3057\u3066\u3001\u8907\u6570\u500b\u306e\u30c7\u30fc\u30bf\u3068\u3057\u3066DMA\u8ee2\u9001\u3059\u308b\u3002\n\n\nSD\u306e\u4ed5\u69d8\u306b\u3064\u3044\u3066\n\nSDA\u304cSD host controller\u306e\u4ed5\u69d8\u3092\u6c7a\u3081\u3066\u3044\u307e\u3059\u3002\u5225\u306b\u3053\u306e\u4ed5\u69d8\u306b\u5f93\u308f\u306a\u304f\u3066\u3082\u826f\u3044\u306e\u3067\u3059\u304c\u3001\u3053\u306e\u4ed5\u69d8\u306b\u6e96\u62e0\u3057\u305fSD host controller \u3082\u305d\u308c\u306a\u308a\u306b\u666e\u53ca\u3057\u3066\u3044\u308b\u3002\n\u3053\u306e\u4ed5\u69d8\u306e\u7c21\u6613\u7248\u304c\u516c\u958b\u3055\u308c\u3066\u3044\u308b\uff1a https://www.sdcard.org/jp/developers/overview/host_controller/simple_spec/\n\nDMA\u306fSDMA (Simple DMA) \u3068 ADMA(Advanced DMA)\u306e2\u7a2e\u985e\u304c\u3042\u308b\u3002\nSDMA\u306f\u5358\u4e00\u306e\u30d6\u30ed\u30c3\u30af\u3092\u8ee2\u9001\u3067\u304d\u308b\u3002\nADMA\u306fscatter gather\u3092\u4f7f\u3063\u3066\u8907\u6570\u306e\u30d6\u30ed\u30c3\u30af\u3092\u8ee2\u9001\u3067\u304d\u308b\n\n\u3068\u308a\u3042\u3048\u305a\u3001\u9001\u4fe1\u90e8\u5206\u304b\u3089\u8aad\u3093\u3067\u307f\u308b\u3002\n\nSDIO\u306e\u9001\u4fe1\u51e6\u7406 (mmc/core)\n\nlinux kernel API\u3067 sdio\u306e\u30c7\u30fc\u30bf\u9001\u4fe1\u306f include/linux/mmc/sdio_func.h \u306e sdio_memcpy_toio()\u3067\u3059\u3002\n\n\nsdio_func.h\nextern int sdio_memcpy_toio(struct sdio_func *func, unsigned int addr,\n        void *src, int count);\n\n\n\nwrite \u3068 incr_addr \u3092\u6307\u5b9a\u3057\u3066 sdio_io_rw_ext_helper()\u3092\u547c\u3076\n\n\nsdio_func.c\nint sdio_memcpy_toio(struct sdio_func *func, unsigned int addr,\n    void *src, int count)\n{\n    return sdio_io_rw_ext_helper(func, 1, addr, 1, src, count);\n}\n\n\n\n\u9001\u4fe1\u30c7\u30fc\u30bf\u30b5\u30a4\u30ba\u3000\u3092 SDIO card \u306e function \u306e\u3000cur_blksize \u3067\u5272\u3063\u3066\u9001\u4fe1\u30d6\u30ed\u30c3\u30af\u6570 blocks \u3092\u8a08\u7b97\u3059\u308b\u3002\n\u30d6\u30ed\u30c3\u30af\u30b5\u30a4\u30ba\u3068\u30d6\u30ed\u30c3\u30af\u6570\u3092\u6307\u5b9a\u3057\u3066 mmc_io_rw_extended()\u3092\u547c\u3076\n\n\nsdio_func.c\n/* Split an arbitrarily sized data transfer into several\n * IO_RW_EXTENDED commands. */\nstatic int sdio_io_rw_ext_helper(struct sdio_func *func, int write,\n    unsigned addr, int incr_addr, u8 *buf, unsigned size)\n{\n    unsigned remainder = size;\n    unsigned max_blocks;\n    int ret;\n\n    /* Do the bulk of the transfer using block mode (if supported). */\n    if (func->card->cccr.multi_block && (size > sdio_max_byte_size(func))) {\n        /* Blocks per command is limited by host count, host transfer\n         * size and the maximum for IO_RW_EXTENDED of 511 blocks. */\n        max_blocks = min(func->card->host->max_blk_count, 511u);\n\n        while (remainder >= func->cur_blksize) {\n            unsigned blocks;\n\n            blocks = remainder / func->cur_blksize;\n            if (blocks > max_blocks)\n                blocks = max_blocks;\n            size = blocks * func->cur_blksize;\n\n            ret = mmc_io_rw_extended(func->card, write,\n                func->num, addr, incr_addr, buf,\n                blocks, func->cur_blksize);\n            if (ret)\n                return ret;\n\n            remainder -= size;\n            buf += size;\n            if (incr_addr)\n                addr += size;\n        }\n    }\n\n    /* Write the remainder using byte mode. */\n//\u7701\u7565 skip\n    return 0;\n}\n\n\n\nlinux kernel\u306escatter gather\u306e\u4ed5\u7d44\u307f\u3092\u4f7f\u3046\u3002\nSDIO host \u306e DMA\u304c\u8a31\u5bb9\u3059\u308b\u30bb\u30b0\u30e1\u30f3\u30c8\u30b5\u30a4\u30ba card->host->max_seg_size \u6bce\u306b \u306bscatter gather\u306e\u30a8\u30f3\u30c8\u30ea\u3092\u4f5c\u6210\u3059\u308b\u3002\n\u4f5c\u6210\u3057\u305fscatter gather \u3092 struct mmc_request mrq \u306e mrq.cmd->data.sg \u306b\u8a2d\u5b9a\u3059\u308b\u3002\nmmc_wait_for_req()\u3067\u30ea\u30af\u30a8\u30b9\u30c8\u3092\u9001\u4fe1\u3059\u308b\u3002\n\n\nsdio_ops.c\nint mmc_io_rw_extended(struct mmc_card *card, int write, unsigned fn,\n    unsigned addr, int incr_addr, u8 *buf, unsigned blocks, unsigned blksz)\n{\n    struct mmc_request mrq = {NULL};\n    struct mmc_command cmd = {0};\n    struct mmc_data data = {0};\n    struct scatterlist sg, *sg_ptr;\n    struct sg_table sgtable;\n    unsigned int nents, left_size, i;\n    unsigned int seg_size = card->host->max_seg_size;\n\n    BUG_ON(!card);\n    BUG_ON(fn > 7);\n    WARN_ON(blksz == 0);\n\n    /* sanity check */\n    if (addr & ~0x1FFFF)\n        return -EINVAL;\n\n    mrq.cmd = &cmd;\n    mrq.data = &data;\n\n    cmd.opcode = SD_IO_RW_EXTENDED;\n    cmd.arg = write ? 0x80000000 : 0x00000000;\n    cmd.arg |= fn << 28;\n    cmd.arg |= incr_addr ? 0x04000000 : 0x00000000;\n    cmd.arg |= addr << 9;\n    if (blocks == 0)\n        cmd.arg |= (blksz == 512) ? 0 : blksz;  /* byte mode */\n    else\n        cmd.arg |= 0x08000000 | blocks;     /* block mode */\n    cmd.flags = MMC_RSP_SPI_R5 | MMC_RSP_R5 | MMC_CMD_ADTC;\n\n    data.blksz = blksz;\n    /* Code in host drivers/fwk assumes that \"blocks\" always is >=1 */\n    data.blocks = blocks ? blocks : 1;\n    data.flags = write ? MMC_DATA_WRITE : MMC_DATA_READ;\n\n    left_size = data.blksz * data.blocks;\n    nents = (left_size - 1) / seg_size + 1;\n    if (nents > 1) {\n        if (sg_alloc_table(&sgtable, nents, GFP_KERNEL))\n            return -ENOMEM;\n\n        data.sg = sgtable.sgl;\n        data.sg_len = nents;\n\n        for_each_sg(data.sg, sg_ptr, data.sg_len, i) {\n            sg_set_page(sg_ptr, virt_to_page(buf + (i * seg_size)),\n                    min(seg_size, left_size),\n                    offset_in_page(buf + (i * seg_size)));\n            left_size = left_size - seg_size;\n        }\n    } else {\n        data.sg = &sg;\n        data.sg_len = 1;\n\n        sg_init_one(&sg, buf, left_size);\n    }\n\n    mmc_set_data_timeout(&data, card);\n\n    mmc_wait_for_req(card->host, &mrq);\n\n    if (nents > 1)\n        sg_free_table(&sgtable);\n\n    if (cmd.error)\n        return cmd.error;\n    if (data.error)\n        return data.error;\n\n    if (mmc_host_is_spi(card->host)) {\n        /* host driver already reported errors */\n    } else {\n        if (cmd.resp[0] & R5_ERROR)\n            return -EIO;\n        if (cmd.resp[0] & R5_FUNCTION_NUMBER)\n            return -EINVAL;\n        if (cmd.resp[0] & R5_OUT_OF_RANGE)\n            return -ERANGE;\n    }\n\n    return 0;\n}\n\n\n\nmmc_wait_for_req()\u3042\u3068\u306bmmc_core.c\u306e\u3044\u304f\u3064\u304b\u306e\u95a2\u6570\u3092\u7d4c\u3066 __mmc_start_reques()\u3067host\u30c9\u30e9\u30a4\u30d0\u6bce\u306ehost->ops->request()\u3092\u547c\u3076\n\n        host->ops->request(host, mrq);\n\n\nSDIO\u306e\u9001\u4fe1\u51e6\u7406 (SD host controller)\n\nhost\u30c9\u30e9\u30a4\u30d0\u3068\u3057\u3066\u3001SD association\u304c\u5b9a\u7fa9\u3057\u305fSD host controller \u6e96\u62e0\u306e\u30c9\u30e9\u30a4\u30d0\u3092\u898b\u3066\u3044\u304f\u3002\nhost->ops->request() \u306e\u5b9f\u4f53\u306f sdhci_request()\u3002\n\nstatic const struct mmc_host_ops sdhci_ops = {\n    .request    = sdhci_request,\n    .post_req   = sdhci_post_req,\n    .pre_req    = sdhci_pre_req,\n    .set_ios    = sdhci_set_ios,\n    .get_cd     = sdhci_get_cd,\n    .get_ro     = sdhci_get_ro,\n    .hw_reset   = sdhci_hw_reset,\n    .enable_sdio_irq = sdhci_enable_sdio_irq,\n    .start_signal_voltage_switch    = sdhci_start_signal_voltage_switch,\n    .prepare_hs400_tuning       = sdhci_prepare_hs400_tuning,\n    .execute_tuning         = sdhci_execute_tuning,\n    .select_drive_strength      = sdhci_select_drive_strength,\n    .card_event         = sdhci_card_event,\n    .card_busy  = sdhci_card_busy,\n};\n\n\n\u30b3\u30de\u30f3\u30c9\u3092\u9001\u4fe1\u3059\u308b\u305f\u3081\u306b sdhci_send_command() \u3092\u547c\u3076\n\nstatic void sdhci_request(struct mmc_host *mmc, struct mmc_request *mrq)\n{\n    struct sdhci_host *host;\n    int present;\n    unsigned long flags;\n\n    host = mmc_priv(mmc);\n\n    /* Firstly check card presence */\n    present = mmc->ops->get_cd(mmc);\n\n    spin_lock_irqsave(&host->lock, flags);\n\n    WARN_ON(host->mrq != NULL);\n\n    sdhci_led_activate(host);\n\n    /*\n     * Ensure we don't send the STOP for non-SET_BLOCK_COUNTED\n     * requests if Auto-CMD12 is enabled.\n     */\n    if (!mrq->sbc && (host->flags & SDHCI_AUTO_CMD12)) {\n        if (mrq->stop) {\n            mrq->data->stop = NULL;\n            mrq->stop = NULL;\n        }\n    }\n\n    host->mrq = mrq;\n\n    if (!present || host->flags & SDHCI_DEVICE_DEAD) {\n        host->mrq->cmd->error = -ENOMEDIUM;\n        tasklet_schedule(&host->finish_tasklet);\n    } else {\n        if (mrq->sbc && !(host->flags & SDHCI_AUTO_CMD23))\n            sdhci_send_command(host, mrq->sbc);\n        else\n            sdhci_send_command(host, mrq->cmd);\n    }\n\n    mmiowb();\n    spin_unlock_irqrestore(&host->lock, flags);\n}\n\n\nsdhci_prepare_data()\u3067DMA\u306e\u8a2d\u5b9a\u3092\u884c\u3046\nsdhci_set_transfer_mode()\u3067\u30b3\u30de\u30f3\u30c9\u306e\u9001\u4fe1\u6307\u793a\u3092\u51fa\u3059\u3002\n\nvoid sdhci_send_command(struct sdhci_host *host, struct mmc_command *cmd)\n{\n    int flags;\n    u32 mask;\n    unsigned long timeout;\n\n    WARN_ON(host->cmd);\n\n    /* Initially, a command has no error */\n    cmd->error = 0;\n\n    /* Wait max 10 ms */\n    timeout = 10;\n\n    mask = SDHCI_CMD_INHIBIT;\n    if ((cmd->data != NULL) || (cmd->flags & MMC_RSP_BUSY))\n        mask |= SDHCI_DATA_INHIBIT;\n\n    /* We shouldn't wait for data inihibit for stop commands, even\n       though they might use busy signaling */\n    if (host->mrq->data && (cmd == host->mrq->data->stop))\n        mask &= ~SDHCI_DATA_INHIBIT;\n\n    while (sdhci_readl(host, SDHCI_PRESENT_STATE) & mask) {\n        if (timeout == 0) {\n            pr_err(\"%s: Controller never released inhibit bit(s).\\n\",\n                   mmc_hostname(host->mmc));\n            sdhci_dumpregs(host);\n            cmd->error = -EIO;\n            tasklet_schedule(&host->finish_tasklet);\n            return;\n        }\n        timeout--;\n        mdelay(1);\n    }\n\n    timeout = jiffies;\n    if (!cmd->data && cmd->busy_timeout > 9000)\n        timeout += DIV_ROUND_UP(cmd->busy_timeout, 1000) * HZ + HZ;\n    else\n        timeout += 10 * HZ;\n    mod_timer(&host->timer, timeout);\n\n    host->cmd = cmd;\n    host->busy_handle = 0;\n\n    sdhci_prepare_data(host, cmd);\n\n    sdhci_writel(host, cmd->arg, SDHCI_ARGUMENT);\n\n    sdhci_set_transfer_mode(host, cmd);\n\n    if ((cmd->flags & MMC_RSP_136) && (cmd->flags & MMC_RSP_BUSY)) {\n        pr_err(\"%s: Unsupported response type!\\n\",\n            mmc_hostname(host->mmc));\n        cmd->error = -EINVAL;\n        tasklet_schedule(&host->finish_tasklet);\n        return;\n    }\n\n    if (!(cmd->flags & MMC_RSP_PRESENT))\n        flags = SDHCI_CMD_RESP_NONE;\n    else if (cmd->flags & MMC_RSP_136)\n        flags = SDHCI_CMD_RESP_LONG;\n    else if (cmd->flags & MMC_RSP_BUSY)\n        flags = SDHCI_CMD_RESP_SHORT_BUSY;\n    else\n        flags = SDHCI_CMD_RESP_SHORT;\n\n    if (cmd->flags & MMC_RSP_CRC)\n        flags |= SDHCI_CMD_CRC;\n    if (cmd->flags & MMC_RSP_OPCODE)\n        flags |= SDHCI_CMD_INDEX;\n\n    /* CMD19 is special in that the Data Present Select should be set */\n    if (cmd->data || cmd->opcode == MMC_SEND_TUNING_BLOCK ||\n        cmd->opcode == MMC_SEND_TUNING_BLOCK_HS200)\n        flags |= SDHCI_CMD_DATA;\n\n    sdhci_writew(host, SDHCI_MAKE_CMD(cmd->opcode, flags), SDHCI_COMMAND);\n}\n\n\nSDHCI\u306eDMA\u51e6\u7406\n\n\u9577\u3055\u3092\u30c1\u30a7\u30c3\u30af\u3057\u3066DMA\u3092\u4f7f\u3046\u304b\u5224\u5b9a (DMA\u306f\u30aa\u30fc\u30d0\u30fc\u30d8\u30c3\u30c9\u304c\u3042\u308b\u306e\u3067\u3042\u308b\u95be\u5024\u4ee5\u4e0b\u306fDMA\u3092\u4f7f\u308f\u306a\u3044\u65b9\u304c\u826f\u3044)\nADMA\u3092\u30b5\u30dd\u30fc\u30c8\u3057\u3066\u3044\u308b\u306a\u3089ADMA\u3092\u4f7f\u3046\u3002ADMA\u3092\u30b5\u30dd\u30fc\u30c8\u3057\u3066\u3044\u306a\u3044\u5834\u5408\u306fSDMA\u3092\u4f7f\u3046\u3002\nDMA\u306e\u30b3\u30d4\u30fc\u5143or\u30b3\u30d4\u30fc\u5148\u306e\u30a2\u30c9\u30ec\u30b9\u8a2d\u5b9a\nDMA\u306e\u5b8c\u4e86\u5272\u308a\u8fbc\u307f\u8a2d\u5b9a\nSDHCI_HOST_CONTROL\u306bPIO/SDMA/ADMA\u306e\u3069\u308c\u3092\u4f7f\u3046\u304b\u8a2d\u5b9a\nSDHCI_BLOCK_SIZE\nSDHCI_BLOCK_COUNT\n\n\nstatic void sdhci_prepare_data(struct sdhci_host *host, struct mmc_command *cmd)\n{\n    u8 ctrl;\n    struct mmc_data *data = cmd->data;\n\n    WARN_ON(host->data);\n\n    if (data || (cmd->flags & MMC_RSP_BUSY))\n        sdhci_set_timeout(host, cmd);\n\n    if (!data)\n        return;\n\n    /* Sanity checks */\n    BUG_ON(data->blksz * data->blocks > 524288);\n    BUG_ON(data->blksz > host->mmc->max_blk_size);\n    BUG_ON(data->blocks > 65535);\n\n    host->data = data;\n    host->data_early = 0;\n    host->data->bytes_xfered = 0;\n\n    if (host->flags & (SDHCI_USE_SDMA | SDHCI_USE_ADMA)) {\n        struct scatterlist *sg;\n        unsigned int length_mask, offset_mask;\n        int i;\n\n        host->flags |= SDHCI_REQ_USE_DMA;\n\n        /*\n         * FIXME: This doesn't account for merging when mapping the\n         * scatterlist.\n         *\n         * The assumption here being that alignment and lengths are\n         * the same after DMA mapping to device address space.\n         */\n        length_mask = 0;\n        offset_mask = 0;\n        if (host->flags & SDHCI_USE_ADMA) {\n            if (host->quirks & SDHCI_QUIRK_32BIT_ADMA_SIZE) {\n                length_mask = 3;\n                /*\n                 * As we use up to 3 byte chunks to work\n                 * around alignment problems, we need to\n                 * check the offset as well.\n                 */\n                offset_mask = 3;\n            }\n        } else {\n            if (host->quirks & SDHCI_QUIRK_32BIT_DMA_SIZE)\n                length_mask = 3;\n            if (host->quirks & SDHCI_QUIRK_32BIT_DMA_ADDR)\n                offset_mask = 3;\n        }\n\n        if (unlikely(length_mask | offset_mask)) {\n            for_each_sg(data->sg, sg, data->sg_len, i) {\n                if (sg->length & length_mask) {\n                    DBG(\"Reverting to PIO because of transfer size (%d)\\n\",\n                        sg->length);\n                    host->flags &= ~SDHCI_REQ_USE_DMA;\n                    break;\n                }\n                if (sg->offset & offset_mask) {\n                    DBG(\"Reverting to PIO because of bad alignment\\n\");\n                    host->flags &= ~SDHCI_REQ_USE_DMA;\n                    break;\n                }\n            }\n        }\n    }\n\n    if (host->flags & SDHCI_REQ_USE_DMA) {\n        int sg_cnt = sdhci_pre_dma_transfer(host, data, COOKIE_MAPPED);\n\n        if (sg_cnt <= 0) {\n            /*\n             * This only happens when someone fed\n             * us an invalid request.\n             */\n            WARN_ON(1);\n            host->flags &= ~SDHCI_REQ_USE_DMA;\n        } else if (host->flags & SDHCI_USE_ADMA) {\n            sdhci_adma_table_pre(host, data, sg_cnt);\n\n            sdhci_writel(host, host->adma_addr, SDHCI_ADMA_ADDRESS);\n            if (host->flags & SDHCI_USE_64_BIT_DMA)\n                sdhci_writel(host,\n                         (u64)host->adma_addr >> 32,\n                         SDHCI_ADMA_ADDRESS_HI);\n        } else {\n            WARN_ON(sg_cnt != 1);\n            sdhci_writel(host, sg_dma_address(data->sg),\n                SDHCI_DMA_ADDRESS);\n        }\n    }\n\n    /*\n     * Always adjust the DMA selection as some controllers\n     * (e.g. JMicron) can't do PIO properly when the selection\n     * is ADMA.\n     */\n    if (host->version >= SDHCI_SPEC_200) {\n        ctrl = sdhci_readb(host, SDHCI_HOST_CONTROL);\n        ctrl &= ~SDHCI_CTRL_DMA_MASK;\n        if ((host->flags & SDHCI_REQ_USE_DMA) &&\n            (host->flags & SDHCI_USE_ADMA)) {\n            if (host->flags & SDHCI_USE_64_BIT_DMA)\n                ctrl |= SDHCI_CTRL_ADMA64;\n            else\n                ctrl |= SDHCI_CTRL_ADMA32;\n        } else {\n            ctrl |= SDHCI_CTRL_SDMA;\n        }\n        sdhci_writeb(host, ctrl, SDHCI_HOST_CONTROL);\n    }\n\n    if (!(host->flags & SDHCI_REQ_USE_DMA)) {\n        int flags;\n\n        flags = SG_MITER_ATOMIC;\n        if (host->data->flags & MMC_DATA_READ)\n            flags |= SG_MITER_TO_SG;\n        else\n            flags |= SG_MITER_FROM_SG;\n        sg_miter_start(&host->sg_miter, data->sg, data->sg_len, flags);\n        host->blocks = data->blocks;\n    }\n\n    sdhci_set_transfer_irqs(host);\n\n    /* Set the DMA boundary value and block size */\n    sdhci_writew(host, SDHCI_MAKE_BLKSZ(SDHCI_DEFAULT_BOUNDARY_ARG,\n        data->blksz), SDHCI_BLOCK_SIZE);\n    sdhci_writew(host, data->blocks, SDHCI_BLOCK_COUNT);\n}\n\n\u3068\u308a\u3042\u3048\u305a\u3001\u3053\u3053\u307e\u3067\u3002\n\nSD Association \u306e SD host controller \u4ed5\u69d8\u306ehost controller \u306eSDIO\u30c7\u30fc\u30bf\u3092DMA\u8ee2\u9001\u306e\u624b\u9806\u306b\u3064\u3044\u3066Linux Kernel\u306e\u5b9f\u88c5\u3092\u8abf\u3079\u3066\u307f\u307e\u3057\u305f\u3002\n\n# \u307e\u3068\u3081\n* Linux kernel\u306fSD host\u4ed5\u69d8\u306eSDMA\u3068ADMA\u306b\u5bfe\u5fdc\u3057\u3066\u3044\u308b\u3002\n* mmc/core (\u5171\u901a\u90e8\u5206)\u3067\u9001\u4fe1\u30c7\u30fc\u30bf\u306blinux kernel\u306escatter gather\u306e\u5f62\u5f0f\u306e\u60c5\u5831\u3092\u4ed8\u52a0\u3059\u308b\u3002\n* sdhost controller\u306e\u30c9\u30e9\u30a4\u30d0(\u30db\u30b9\u30c8\u30c9\u30e9\u30a4\u30d0\u90e8\u5206)\u3067\u3001DMA\u7121\u3057\u3001ADMA, SDMA\u306e\u3069\u308c\u3092\u4f7f\u3046\u304b\u9078\u629e\u3059\u308b\u3002\n* SDMA\u3092\u4f7f\u3046\u5834\u5408\u306fscatter gather\u306e\u60c5\u5831\u306f\u7121\u8996\u3057\u3066\u3001\uff11\u500b\u306e\u30c7\u30fc\u30bf\u3068\u3057\u3066DMA\u8ee2\u9001\u3059\u308b\u3002\n* ADMA\u3092\u4f7f\u3046\u5834\u5408\u306fscatter gather\u306e\u60c5\u5831\u3092ADMA\u306escatter gather\u306e\u5f62\u5f0f\u306b\u5909\u63db\u3057\u3066\u3001\u8907\u6570\u500b\u306e\u30c7\u30fc\u30bf\u3068\u3057\u3066DMA\u8ee2\u9001\u3059\u308b\u3002\n\n# SD\u306e\u4ed5\u69d8\u306b\u3064\u3044\u3066\n* SDA\u304cSD host controller\u306e\u4ed5\u69d8\u3092\u6c7a\u3081\u3066\u3044\u307e\u3059\u3002\u5225\u306b\u3053\u306e\u4ed5\u69d8\u306b\u5f93\u308f\u306a\u304f\u3066\u3082\u826f\u3044\u306e\u3067\u3059\u304c\u3001\u3053\u306e\u4ed5\u69d8\u306b\u6e96\u62e0\u3057\u305fSD host controller \u3082\u305d\u308c\u306a\u308a\u306b\u666e\u53ca\u3057\u3066\u3044\u308b\u3002\n* \u3053\u306e\u4ed5\u69d8\u306e\u7c21\u6613\u7248\u304c\u516c\u958b\u3055\u308c\u3066\u3044\u308b\uff1a https://www.sdcard.org/jp/developers/overview/host_controller/simple_spec/\n* DMA\u306fSDMA (Simple DMA) \u3068 ADMA(Advanced DMA)\u306e2\u7a2e\u985e\u304c\u3042\u308b\u3002\n* SDMA\u306f\u5358\u4e00\u306e\u30d6\u30ed\u30c3\u30af\u3092\u8ee2\u9001\u3067\u304d\u308b\u3002\n* ADMA\u306fscatter gather\u3092\u4f7f\u3063\u3066\u8907\u6570\u306e\u30d6\u30ed\u30c3\u30af\u3092\u8ee2\u9001\u3067\u304d\u308b\n\n\u3068\u308a\u3042\u3048\u305a\u3001\u9001\u4fe1\u90e8\u5206\u304b\u3089\u8aad\u3093\u3067\u307f\u308b\u3002\n\n# SDIO\u306e\u9001\u4fe1\u51e6\u7406 (mmc/core)\n* linux kernel API\u3067 sdio\u306e\u30c7\u30fc\u30bf\u9001\u4fe1\u306f include/linux/mmc/sdio_func.h \u306e sdio_memcpy_toio()\u3067\u3059\u3002\n\n```c:sdio_func.h\nextern int sdio_memcpy_toio(struct sdio_func *func, unsigned int addr,\n        void *src, int count);\n```\n\n* write \u3068 incr_addr \u3092\u6307\u5b9a\u3057\u3066 sdio_io_rw_ext_helper()\u3092\u547c\u3076\n\n```c:sdio_func.c\nint sdio_memcpy_toio(struct sdio_func *func, unsigned int addr,\n\tvoid *src, int count)\n{\n\treturn sdio_io_rw_ext_helper(func, 1, addr, 1, src, count);\n}\n```\n\n* \u9001\u4fe1\u30c7\u30fc\u30bf\u30b5\u30a4\u30ba\u3000\u3092 SDIO card \u306e function \u306e\u3000cur_blksize \u3067\u5272\u3063\u3066\u9001\u4fe1\u30d6\u30ed\u30c3\u30af\u6570 blocks \u3092\u8a08\u7b97\u3059\u308b\u3002\n* \u30d6\u30ed\u30c3\u30af\u30b5\u30a4\u30ba\u3068\u30d6\u30ed\u30c3\u30af\u6570\u3092\u6307\u5b9a\u3057\u3066 mmc_io_rw_extended()\u3092\u547c\u3076\n\n\n```c:sdio_func.c\n/* Split an arbitrarily sized data transfer into several\n * IO_RW_EXTENDED commands. */\nstatic int sdio_io_rw_ext_helper(struct sdio_func *func, int write,\n\tunsigned addr, int incr_addr, u8 *buf, unsigned size)\n{\n\tunsigned remainder = size;\n\tunsigned max_blocks;\n\tint ret;\n\n\t/* Do the bulk of the transfer using block mode (if supported). */\n\tif (func->card->cccr.multi_block && (size > sdio_max_byte_size(func))) {\n\t\t/* Blocks per command is limited by host count, host transfer\n\t\t * size and the maximum for IO_RW_EXTENDED of 511 blocks. */\n\t\tmax_blocks = min(func->card->host->max_blk_count, 511u);\n\n\t\twhile (remainder >= func->cur_blksize) {\n\t\t\tunsigned blocks;\n\n\t\t\tblocks = remainder / func->cur_blksize;\n\t\t\tif (blocks > max_blocks)\n\t\t\t\tblocks = max_blocks;\n\t\t\tsize = blocks * func->cur_blksize;\n\n\t\t\tret = mmc_io_rw_extended(func->card, write,\n\t\t\t\tfunc->num, addr, incr_addr, buf,\n\t\t\t\tblocks, func->cur_blksize);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\n\t\t\tremainder -= size;\n\t\t\tbuf += size;\n\t\t\tif (incr_addr)\n\t\t\t\taddr += size;\n\t\t}\n\t}\n\n\t/* Write the remainder using byte mode. */\n//\u7701\u7565 skip\n\treturn 0;\n}\n```\n\n* linux kernel\u306escatter gather\u306e\u4ed5\u7d44\u307f\u3092\u4f7f\u3046\u3002\n* SDIO host \u306e DMA\u304c\u8a31\u5bb9\u3059\u308b\u30bb\u30b0\u30e1\u30f3\u30c8\u30b5\u30a4\u30ba card->host->max_seg_size \u6bce\u306b \u306bscatter gather\u306e\u30a8\u30f3\u30c8\u30ea\u3092\u4f5c\u6210\u3059\u308b\u3002\n* \u4f5c\u6210\u3057\u305fscatter gather \u3092 struct mmc_request mrq \u306e mrq.cmd->data.sg \u306b\u8a2d\u5b9a\u3059\u308b\u3002\n* mmc_wait_for_req()\u3067\u30ea\u30af\u30a8\u30b9\u30c8\u3092\u9001\u4fe1\u3059\u308b\u3002\n\n```c:sdio_ops.c\nint mmc_io_rw_extended(struct mmc_card *card, int write, unsigned fn,\n\tunsigned addr, int incr_addr, u8 *buf, unsigned blocks, unsigned blksz)\n{\n\tstruct mmc_request mrq = {NULL};\n\tstruct mmc_command cmd = {0};\n\tstruct mmc_data data = {0};\n\tstruct scatterlist sg, *sg_ptr;\n\tstruct sg_table sgtable;\n\tunsigned int nents, left_size, i;\n\tunsigned int seg_size = card->host->max_seg_size;\n\n\tBUG_ON(!card);\n\tBUG_ON(fn > 7);\n\tWARN_ON(blksz == 0);\n\n\t/* sanity check */\n\tif (addr & ~0x1FFFF)\n\t\treturn -EINVAL;\n\n\tmrq.cmd = &cmd;\n\tmrq.data = &data;\n\n\tcmd.opcode = SD_IO_RW_EXTENDED;\n\tcmd.arg = write ? 0x80000000 : 0x00000000;\n\tcmd.arg |= fn << 28;\n\tcmd.arg |= incr_addr ? 0x04000000 : 0x00000000;\n\tcmd.arg |= addr << 9;\n\tif (blocks == 0)\n\t\tcmd.arg |= (blksz == 512) ? 0 : blksz;\t/* byte mode */\n\telse\n\t\tcmd.arg |= 0x08000000 | blocks;\t\t/* block mode */\n\tcmd.flags = MMC_RSP_SPI_R5 | MMC_RSP_R5 | MMC_CMD_ADTC;\n\n\tdata.blksz = blksz;\n\t/* Code in host drivers/fwk assumes that \"blocks\" always is >=1 */\n\tdata.blocks = blocks ? blocks : 1;\n\tdata.flags = write ? MMC_DATA_WRITE : MMC_DATA_READ;\n\n\tleft_size = data.blksz * data.blocks;\n\tnents = (left_size - 1) / seg_size + 1;\n\tif (nents > 1) {\n\t\tif (sg_alloc_table(&sgtable, nents, GFP_KERNEL))\n\t\t\treturn -ENOMEM;\n\n\t\tdata.sg = sgtable.sgl;\n\t\tdata.sg_len = nents;\n\n\t\tfor_each_sg(data.sg, sg_ptr, data.sg_len, i) {\n\t\t\tsg_set_page(sg_ptr, virt_to_page(buf + (i * seg_size)),\n\t\t\t\t\tmin(seg_size, left_size),\n\t\t\t\t\toffset_in_page(buf + (i * seg_size)));\n\t\t\tleft_size = left_size - seg_size;\n\t\t}\n\t} else {\n\t\tdata.sg = &sg;\n\t\tdata.sg_len = 1;\n\n\t\tsg_init_one(&sg, buf, left_size);\n\t}\n\n\tmmc_set_data_timeout(&data, card);\n\n\tmmc_wait_for_req(card->host, &mrq);\n\n\tif (nents > 1)\n\t\tsg_free_table(&sgtable);\n\n\tif (cmd.error)\n\t\treturn cmd.error;\n\tif (data.error)\n\t\treturn data.error;\n\n\tif (mmc_host_is_spi(card->host)) {\n\t\t/* host driver already reported errors */\n\t} else {\n\t\tif (cmd.resp[0] & R5_ERROR)\n\t\t\treturn -EIO;\n\t\tif (cmd.resp[0] & R5_FUNCTION_NUMBER)\n\t\t\treturn -EINVAL;\n\t\tif (cmd.resp[0] & R5_OUT_OF_RANGE)\n\t\t\treturn -ERANGE;\n\t}\n\n\treturn 0;\n}\n```\n\n* mmc_wait_for_req()\u3042\u3068\u306bmmc_core.c\u306e\u3044\u304f\u3064\u304b\u306e\u95a2\u6570\u3092\u7d4c\u3066 __mmc_start_reques()\u3067host\u30c9\u30e9\u30a4\u30d0\u6bce\u306ehost->ops->request()\u3092\u547c\u3076\n\n```c\n        host->ops->request(host, mrq);\n```\n\n# SDIO\u306e\u9001\u4fe1\u51e6\u7406 (SD host controller)\n* host\u30c9\u30e9\u30a4\u30d0\u3068\u3057\u3066\u3001SD association\u304c\u5b9a\u7fa9\u3057\u305fSD host controller \u6e96\u62e0\u306e\u30c9\u30e9\u30a4\u30d0\u3092\u898b\u3066\u3044\u304f\u3002\n* host->ops->request() \u306e\u5b9f\u4f53\u306f sdhci_request()\u3002\n\n```c\nstatic const struct mmc_host_ops sdhci_ops = {\n\t.request\t= sdhci_request,\n\t.post_req\t= sdhci_post_req,\n\t.pre_req\t= sdhci_pre_req,\n\t.set_ios\t= sdhci_set_ios,\n\t.get_cd\t\t= sdhci_get_cd,\n\t.get_ro\t\t= sdhci_get_ro,\n\t.hw_reset\t= sdhci_hw_reset,\n\t.enable_sdio_irq = sdhci_enable_sdio_irq,\n\t.start_signal_voltage_switch\t= sdhci_start_signal_voltage_switch,\n\t.prepare_hs400_tuning\t\t= sdhci_prepare_hs400_tuning,\n\t.execute_tuning\t\t\t= sdhci_execute_tuning,\n\t.select_drive_strength\t\t= sdhci_select_drive_strength,\n\t.card_event\t\t\t= sdhci_card_event,\n\t.card_busy\t= sdhci_card_busy,\n};\n```\n\n* \u30b3\u30de\u30f3\u30c9\u3092\u9001\u4fe1\u3059\u308b\u305f\u3081\u306b sdhci_send_command() \u3092\u547c\u3076\n\n```c\nstatic void sdhci_request(struct mmc_host *mmc, struct mmc_request *mrq)\n{\n\tstruct sdhci_host *host;\n\tint present;\n\tunsigned long flags;\n\n\thost = mmc_priv(mmc);\n\n\t/* Firstly check card presence */\n\tpresent = mmc->ops->get_cd(mmc);\n\n\tspin_lock_irqsave(&host->lock, flags);\n\n\tWARN_ON(host->mrq != NULL);\n\n\tsdhci_led_activate(host);\n\n\t/*\n\t * Ensure we don't send the STOP for non-SET_BLOCK_COUNTED\n\t * requests if Auto-CMD12 is enabled.\n\t */\n\tif (!mrq->sbc && (host->flags & SDHCI_AUTO_CMD12)) {\n\t\tif (mrq->stop) {\n\t\t\tmrq->data->stop = NULL;\n\t\t\tmrq->stop = NULL;\n\t\t}\n\t}\n\n\thost->mrq = mrq;\n\n\tif (!present || host->flags & SDHCI_DEVICE_DEAD) {\n\t\thost->mrq->cmd->error = -ENOMEDIUM;\n\t\ttasklet_schedule(&host->finish_tasklet);\n\t} else {\n\t\tif (mrq->sbc && !(host->flags & SDHCI_AUTO_CMD23))\n\t\t\tsdhci_send_command(host, mrq->sbc);\n\t\telse\n\t\t\tsdhci_send_command(host, mrq->cmd);\n\t}\n\n\tmmiowb();\n\tspin_unlock_irqrestore(&host->lock, flags);\n}\n```\n\n* sdhci_prepare_data()\u3067DMA\u306e\u8a2d\u5b9a\u3092\u884c\u3046\n* sdhci_set_transfer_mode()\u3067\u30b3\u30de\u30f3\u30c9\u306e\u9001\u4fe1\u6307\u793a\u3092\u51fa\u3059\u3002\n\n```\nvoid sdhci_send_command(struct sdhci_host *host, struct mmc_command *cmd)\n{\n\tint flags;\n\tu32 mask;\n\tunsigned long timeout;\n\n\tWARN_ON(host->cmd);\n\n\t/* Initially, a command has no error */\n\tcmd->error = 0;\n\n\t/* Wait max 10 ms */\n\ttimeout = 10;\n\n\tmask = SDHCI_CMD_INHIBIT;\n\tif ((cmd->data != NULL) || (cmd->flags & MMC_RSP_BUSY))\n\t\tmask |= SDHCI_DATA_INHIBIT;\n\n\t/* We shouldn't wait for data inihibit for stop commands, even\n\t   though they might use busy signaling */\n\tif (host->mrq->data && (cmd == host->mrq->data->stop))\n\t\tmask &= ~SDHCI_DATA_INHIBIT;\n\n\twhile (sdhci_readl(host, SDHCI_PRESENT_STATE) & mask) {\n\t\tif (timeout == 0) {\n\t\t\tpr_err(\"%s: Controller never released inhibit bit(s).\\n\",\n\t\t\t       mmc_hostname(host->mmc));\n\t\t\tsdhci_dumpregs(host);\n\t\t\tcmd->error = -EIO;\n\t\t\ttasklet_schedule(&host->finish_tasklet);\n\t\t\treturn;\n\t\t}\n\t\ttimeout--;\n\t\tmdelay(1);\n\t}\n\n\ttimeout = jiffies;\n\tif (!cmd->data && cmd->busy_timeout > 9000)\n\t\ttimeout += DIV_ROUND_UP(cmd->busy_timeout, 1000) * HZ + HZ;\n\telse\n\t\ttimeout += 10 * HZ;\n\tmod_timer(&host->timer, timeout);\n\n\thost->cmd = cmd;\n\thost->busy_handle = 0;\n\n\tsdhci_prepare_data(host, cmd);\n\n\tsdhci_writel(host, cmd->arg, SDHCI_ARGUMENT);\n\n\tsdhci_set_transfer_mode(host, cmd);\n\n\tif ((cmd->flags & MMC_RSP_136) && (cmd->flags & MMC_RSP_BUSY)) {\n\t\tpr_err(\"%s: Unsupported response type!\\n\",\n\t\t\tmmc_hostname(host->mmc));\n\t\tcmd->error = -EINVAL;\n\t\ttasklet_schedule(&host->finish_tasklet);\n\t\treturn;\n\t}\n\n\tif (!(cmd->flags & MMC_RSP_PRESENT))\n\t\tflags = SDHCI_CMD_RESP_NONE;\n\telse if (cmd->flags & MMC_RSP_136)\n\t\tflags = SDHCI_CMD_RESP_LONG;\n\telse if (cmd->flags & MMC_RSP_BUSY)\n\t\tflags = SDHCI_CMD_RESP_SHORT_BUSY;\n\telse\n\t\tflags = SDHCI_CMD_RESP_SHORT;\n\n\tif (cmd->flags & MMC_RSP_CRC)\n\t\tflags |= SDHCI_CMD_CRC;\n\tif (cmd->flags & MMC_RSP_OPCODE)\n\t\tflags |= SDHCI_CMD_INDEX;\n\n\t/* CMD19 is special in that the Data Present Select should be set */\n\tif (cmd->data || cmd->opcode == MMC_SEND_TUNING_BLOCK ||\n\t    cmd->opcode == MMC_SEND_TUNING_BLOCK_HS200)\n\t\tflags |= SDHCI_CMD_DATA;\n\n\tsdhci_writew(host, SDHCI_MAKE_CMD(cmd->opcode, flags), SDHCI_COMMAND);\n}\n```\n\n# SDHCI\u306eDMA\u51e6\u7406\n\n* \u9577\u3055\u3092\u30c1\u30a7\u30c3\u30af\u3057\u3066DMA\u3092\u4f7f\u3046\u304b\u5224\u5b9a (DMA\u306f\u30aa\u30fc\u30d0\u30fc\u30d8\u30c3\u30c9\u304c\u3042\u308b\u306e\u3067\u3042\u308b\u95be\u5024\u4ee5\u4e0b\u306fDMA\u3092\u4f7f\u308f\u306a\u3044\u65b9\u304c\u826f\u3044)\n* ADMA\u3092\u30b5\u30dd\u30fc\u30c8\u3057\u3066\u3044\u308b\u306a\u3089ADMA\u3092\u4f7f\u3046\u3002ADMA\u3092\u30b5\u30dd\u30fc\u30c8\u3057\u3066\u3044\u306a\u3044\u5834\u5408\u306fSDMA\u3092\u4f7f\u3046\u3002\n* DMA\u306e\u30b3\u30d4\u30fc\u5143or\u30b3\u30d4\u30fc\u5148\u306e\u30a2\u30c9\u30ec\u30b9\u8a2d\u5b9a\n* DMA\u306e\u5b8c\u4e86\u5272\u308a\u8fbc\u307f\u8a2d\u5b9a\n* SDHCI_HOST_CONTROL\u306bPIO/SDMA/ADMA\u306e\u3069\u308c\u3092\u4f7f\u3046\u304b\u8a2d\u5b9a\n* SDHCI_BLOCK_SIZE\n* SDHCI_BLOCK_COUNT\n\n```\n\nstatic void sdhci_prepare_data(struct sdhci_host *host, struct mmc_command *cmd)\n{\n\tu8 ctrl;\n\tstruct mmc_data *data = cmd->data;\n\n\tWARN_ON(host->data);\n\n\tif (data || (cmd->flags & MMC_RSP_BUSY))\n\t\tsdhci_set_timeout(host, cmd);\n\n\tif (!data)\n\t\treturn;\n\n\t/* Sanity checks */\n\tBUG_ON(data->blksz * data->blocks > 524288);\n\tBUG_ON(data->blksz > host->mmc->max_blk_size);\n\tBUG_ON(data->blocks > 65535);\n\n\thost->data = data;\n\thost->data_early = 0;\n\thost->data->bytes_xfered = 0;\n\n\tif (host->flags & (SDHCI_USE_SDMA | SDHCI_USE_ADMA)) {\n\t\tstruct scatterlist *sg;\n\t\tunsigned int length_mask, offset_mask;\n\t\tint i;\n\n\t\thost->flags |= SDHCI_REQ_USE_DMA;\n\n\t\t/*\n\t\t * FIXME: This doesn't account for merging when mapping the\n\t\t * scatterlist.\n\t\t *\n\t\t * The assumption here being that alignment and lengths are\n\t\t * the same after DMA mapping to device address space.\n\t\t */\n\t\tlength_mask = 0;\n\t\toffset_mask = 0;\n\t\tif (host->flags & SDHCI_USE_ADMA) {\n\t\t\tif (host->quirks & SDHCI_QUIRK_32BIT_ADMA_SIZE) {\n\t\t\t\tlength_mask = 3;\n\t\t\t\t/*\n\t\t\t\t * As we use up to 3 byte chunks to work\n\t\t\t\t * around alignment problems, we need to\n\t\t\t\t * check the offset as well.\n\t\t\t\t */\n\t\t\t\toffset_mask = 3;\n\t\t\t}\n\t\t} else {\n\t\t\tif (host->quirks & SDHCI_QUIRK_32BIT_DMA_SIZE)\n\t\t\t\tlength_mask = 3;\n\t\t\tif (host->quirks & SDHCI_QUIRK_32BIT_DMA_ADDR)\n\t\t\t\toffset_mask = 3;\n\t\t}\n\n\t\tif (unlikely(length_mask | offset_mask)) {\n\t\t\tfor_each_sg(data->sg, sg, data->sg_len, i) {\n\t\t\t\tif (sg->length & length_mask) {\n\t\t\t\t\tDBG(\"Reverting to PIO because of transfer size (%d)\\n\",\n\t\t\t\t\t    sg->length);\n\t\t\t\t\thost->flags &= ~SDHCI_REQ_USE_DMA;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (sg->offset & offset_mask) {\n\t\t\t\t\tDBG(\"Reverting to PIO because of bad alignment\\n\");\n\t\t\t\t\thost->flags &= ~SDHCI_REQ_USE_DMA;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (host->flags & SDHCI_REQ_USE_DMA) {\n\t\tint sg_cnt = sdhci_pre_dma_transfer(host, data, COOKIE_MAPPED);\n\n\t\tif (sg_cnt <= 0) {\n\t\t\t/*\n\t\t\t * This only happens when someone fed\n\t\t\t * us an invalid request.\n\t\t\t */\n\t\t\tWARN_ON(1);\n\t\t\thost->flags &= ~SDHCI_REQ_USE_DMA;\n\t\t} else if (host->flags & SDHCI_USE_ADMA) {\n\t\t\tsdhci_adma_table_pre(host, data, sg_cnt);\n\n\t\t\tsdhci_writel(host, host->adma_addr, SDHCI_ADMA_ADDRESS);\n\t\t\tif (host->flags & SDHCI_USE_64_BIT_DMA)\n\t\t\t\tsdhci_writel(host,\n\t\t\t\t\t     (u64)host->adma_addr >> 32,\n\t\t\t\t\t     SDHCI_ADMA_ADDRESS_HI);\n\t\t} else {\n\t\t\tWARN_ON(sg_cnt != 1);\n\t\t\tsdhci_writel(host, sg_dma_address(data->sg),\n\t\t\t\tSDHCI_DMA_ADDRESS);\n\t\t}\n\t}\n\n\t/*\n\t * Always adjust the DMA selection as some controllers\n\t * (e.g. JMicron) can't do PIO properly when the selection\n\t * is ADMA.\n\t */\n\tif (host->version >= SDHCI_SPEC_200) {\n\t\tctrl = sdhci_readb(host, SDHCI_HOST_CONTROL);\n\t\tctrl &= ~SDHCI_CTRL_DMA_MASK;\n\t\tif ((host->flags & SDHCI_REQ_USE_DMA) &&\n\t\t\t(host->flags & SDHCI_USE_ADMA)) {\n\t\t\tif (host->flags & SDHCI_USE_64_BIT_DMA)\n\t\t\t\tctrl |= SDHCI_CTRL_ADMA64;\n\t\t\telse\n\t\t\t\tctrl |= SDHCI_CTRL_ADMA32;\n\t\t} else {\n\t\t\tctrl |= SDHCI_CTRL_SDMA;\n\t\t}\n\t\tsdhci_writeb(host, ctrl, SDHCI_HOST_CONTROL);\n\t}\n\n\tif (!(host->flags & SDHCI_REQ_USE_DMA)) {\n\t\tint flags;\n\n\t\tflags = SG_MITER_ATOMIC;\n\t\tif (host->data->flags & MMC_DATA_READ)\n\t\t\tflags |= SG_MITER_TO_SG;\n\t\telse\n\t\t\tflags |= SG_MITER_FROM_SG;\n\t\tsg_miter_start(&host->sg_miter, data->sg, data->sg_len, flags);\n\t\thost->blocks = data->blocks;\n\t}\n\n\tsdhci_set_transfer_irqs(host);\n\n\t/* Set the DMA boundary value and block size */\n\tsdhci_writew(host, SDHCI_MAKE_BLKSZ(SDHCI_DEFAULT_BOUNDARY_ARG,\n\t\tdata->blksz), SDHCI_BLOCK_SIZE);\n\tsdhci_writew(host, data->blocks, SDHCI_BLOCK_COUNT);\n}\n```\n\n\u3068\u308a\u3042\u3048\u305a\u3001\u3053\u3053\u307e\u3067\u3002\n", "tags": ["Linux", "kernel", "sdio", "dma"]}