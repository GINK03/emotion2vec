{"context": "http://qiita.com/66zaha_9su/items/de5dff79f2be21a1db1f\n\u2191\u306e\u30bd\u30fc\u30b9\u306b\u306a\u3063\u3066\u304a\u308a\u307e\u3059\u3002\u2191\n\n\u30bd\u30fc\u30b9\n\nsoccer_ai.pde\nlong frame =0;\nfloat eb_xPos;\nfloat eb_yPos;\nboolean kicked=false;\nint b_point=0;\nint p_point=0;\n\nfloat[] dist;\n\nPlayer[] players =new Player[22];\nBall ball =new Ball();\n\nvoid setup() {\n  size(400, 800);  \n  background(255);\n  smooth();\n  noStroke();\n  fill(0);\n  frameRate(-60);\n\n  dist=new float[players.length];\n\n  for (int i = 0; i < players.length; i++) players[i] = new Player();\n  for (int j = 0; j < players.length; j++) players[j].P_initialize(j);\n  for (int k = 0; k < players.length; k++)dist[k]=9999.9;\n\n  ball=new Ball();\n  ball.B_initialize();\n}\n\nvoid draw() {\n  background(255);\n  frame++;\n\n\n  for (int i = 0; i < players.length; i++) {\n    dist[i]=9999.9;\n    players[i].update(i);\n    players[i].p_kick_hantei(i);\n    players[i].display(i);\n\n    //circles[i].update();\n    //circles[i].display();\n  }\n  ball.display();\n  kicked=false;\n\n  fill(0);\n  text(frame+\"F\", 5, 10);\n  text(nfs(frameRate, 3, 1)+\"FPS\", 80, 10);\n  text(p_point+\"-\"+b_point, 160, 10);\n}\n\n\nclass Ball{\n  float b_radius;\n  float b_xPos;\n  float b_yPos;\n\n  Ball(){\n    b_radius=18.0;\n    b_xPos=200;\n    b_yPos=400;\n  }\n\n  void B_initialize(){\n    fill(#000000);\n    ellipse(200, 400, b_radius, b_radius);\n    b_xPos=200; b_yPos=400;\n    eb_xPos=200; eb_yPos=400;\n  }\n\n  void display(){\n    fill(#000000);\n    ellipse(b_xPos, b_yPos, b_radius, b_radius);\n    eb_xPos=b_xPos; eb_yPos=b_yPos;\n  }\n\n  void kick(float kakudo,float power,int num){\n    float p_x_kick=(cos(kakudo*PI/180)+0.2)*power;\n    float p_y_kick=(sin(kakudo*PI/180)+0.2)*power;\n\n\n\n    if(num%2 ==0){\n      b_xPos+=p_x_kick;\n      b_yPos+=p_y_kick;\n\n      if(b_xPos>400-b_radius) b_xPos=400-b_radius;  //ball is out of vesel (not goal)\n      if(b_xPos<b_radius) b_xPos=b_radius;  //ball is out of vesel (not goal)\n\n      if(b_yPos>800-b_radius){\n        p_point++;\n        b_yPos=400;\n        b_xPos=200;\n\n        for(int i=0; i<players.length; i++){\n          players[i].p_goal_init(i);\n        }\n    }\n      if(b_yPos<b_radius){\n        b_point++;\n        b_yPos=400;\n        b_xPos=200;\n\n        for(int i=0; i<players.length; i++){\n          players[i].p_goal_init(i);\n        }\n    }\n\n      eb_xPos=b_xPos;\n      eb_yPos=b_yPos;\n    }\n\n    else if(num%2 ==1){\n      b_xPos-=p_x_kick;\n      b_yPos-=p_y_kick;\n\n      if(b_xPos>400-b_radius) b_xPos=400-b_radius;  //ball is out of vesel (not goal)\n      if(b_xPos<b_radius) b_xPos=b_radius;  //ball is out of vesel (not goal)\n\n      if(b_yPos>800-b_radius){\n        p_point++;\n        b_yPos=400;\n        b_xPos=200;\n\n        for(int i=0; i<players.length; i++){\n          players[i].p_goal_init(i);\n        }\n    }\n      if(b_yPos<b_radius){\n        b_point++;\n        b_yPos=400;\n        b_xPos=200;\n\n        for(int i=0; i<players.length; i++){\n          players[i].p_goal_init(i);\n        }\n    }\n\n      eb_xPos=b_xPos;\n      eb_yPos=b_yPos;\n    }\n  }\n}\n\n\n\n///////////////////////////////////////////////////////////////////////////////////\nclass Player{\n  float p_radius = 28;\n  float p_xPos;\n  float p_yPos;\n  float p_xVec;\n  float p_yVec;\n  float p_spd;\n  float p_angl;\n  float p_power;\n\n  int p_siya;\n  int p_siya_d;\n\n  Player(){    //mainly initiallize process    initial position determine another process\n  p_spd=12*random(0.6,0.9);\n  p_angl=0;\n  p_xPos=0;\n  p_yPos=0;\n\n  p_siya=(int) random(2,12);\n  p_siya_d=(int) random(160,600);\n\n  p_power=random(12,32);\n  }\n\n  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n  void P_initialize(int _number){\n    int p_number = _number;\n\n    if(p_number%2 ==0){\n\n      if(p_number == 0){\n        fill(#ff7fff);\n        ellipse(40, 80, p_radius, p_radius);\n        p_xPos=40; p_yPos=80;\n      }\n\n      if(p_number == 2){\n        fill(#ff7fff);\n        ellipse(200, 80, p_radius, p_radius);\n        p_xPos=200; p_yPos=80;\n      }\n\n      if(p_number == 4){\n        fill(#ff7fff);\n        ellipse(360, 80, p_radius, p_radius);\n        p_xPos=360; p_yPos=80;\n      }\n\n      if(p_number == 6){\n        fill(#ff7fff);\n        ellipse(150, 350, p_radius, p_radius);\n        p_xPos=150; p_yPos=350;\n      }\n\n      if(p_number == 8){\n        fill(#ff7fff);\n        ellipse(250, 350, p_radius, p_radius);\n        p_xPos=250; p_yPos=350;\n      }\n    }\n\n    else if(p_number%2 ==1){\n\n      if(p_number == 1){\n        fill(#00bfff);\n        ellipse(40, 720, p_radius, p_radius);\n        p_xPos=40; p_yPos=720;\n      }\n\n      if(p_number == 3){\n        fill(#00bfff);\n        ellipse(200, 720, p_radius, p_radius);\n        p_xPos=200; p_yPos=720;\n      }\n\n      if(p_number == 5){\n        fill(#00bfff);\n        ellipse(360, 720, p_radius, p_radius);\n        p_xPos=360; p_yPos=720;\n      }\n\n      if(p_number == 7){\n        fill(#00bfff);\n        ellipse(150, 450, p_radius, p_radius);\n        p_xPos=150; p_yPos=450;\n      }\n\n      if(p_number == 9){\n        fill(#00bfff);\n        ellipse(250, 450, p_radius, p_radius);\n        p_xPos=250; p_yPos=450;\n      }\n    }\n\n  }\n ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n  void update(int num){\n    float p_dist;\n    float x_dist;\n    float y_dist;\n    float kakudo;\n\n    float p_siya_f;    //f means from\n    float p_siya_e;    //e means end\n\n    float p_x_ran;\n    float p_y_ran;\n\n\n    p_dist=sqrt((p_xPos-eb_xPos)*(p_xPos-eb_xPos)+(p_yPos-eb_yPos)*(p_yPos-eb_yPos));\n    x_dist=eb_xPos-p_xPos;\n    y_dist=eb_yPos-p_yPos;\n\n    kakudo=degrees(atan2(x_dist,y_dist));\n\n    if(kakudo < 0){\n      kakudo+=kakudo+360;\n    }\n\n    p_angl=kakudo;\n\n    p_siya_f = 360 * ( (float)frame % (float)p_siya ) / (float)p_siya;\n    p_siya_e = 360 * ( (float)frame % (float)p_siya +1) / (float)p_siya;\n\n    /////////////jyouken 1    ball siyanai   ball chikai\n    if( p_dist < ((float)p_siya_d) && p_siya_f < kakudo && kakudo < p_siya_e){\n      //println(\"players[\"+num+\"], \"+x_dist+\",\"+y_dist +\" , p_dist: \"+p_dist +\", p_siya_d: \"+p_siya_d +\" , kakudo: \"+kakudo +\", siya: \"+ p_siya_f +\" ~ \"+p_siya_e);\n\n      if(x_dist<=0 && y_dist <=0){\n        p_x_ran=p_spd*(abs(cos(kakudo*PI/180)))*-1;\n        p_y_ran=p_spd*abs(sin(kakudo*PI/180))*-1;\n\n        p_xPos+=p_x_ran;\n        p_yPos+=p_y_ran;\n      }\n\n      else if(x_dist>=0 && y_dist <=0){\n        p_x_ran=p_spd*abs(cos(kakudo*PI/180));\n        p_y_ran=p_spd*abs(sin(kakudo*PI/180))*-1;\n\n        p_xPos+=p_x_ran;\n        p_yPos+=p_y_ran;\n      }\n\n      if(x_dist<=0 && y_dist >=0){\n        p_x_ran=p_spd*abs(cos(kakudo*PI/180))*-1;\n        p_y_ran=p_spd*abs(sin(kakudo*PI/180));\n\n        p_xPos+=p_x_ran;\n        p_yPos+=p_y_ran;\n      }\n\n      else if(x_dist>=0 && y_dist >=0){\n        p_x_ran=p_spd*abs(cos(kakudo*PI/180));\n        p_y_ran=p_spd*abs(sin(kakudo*PI/180));\n\n        p_xPos+=p_x_ran;\n        p_yPos+=p_y_ran;\n      }\n\n      //hamidasi\n      if(p_xPos>400-p_radius) p_xPos=400-p_radius;\n      if(p_xPos<p_radius) p_xPos=p_radius;\n      if(p_yPos>800-p_radius) p_yPos=800-p_radius;\n      if(p_yPos<p_radius) p_yPos=p_radius;\n\n      dist[num]=sqrt((p_xPos-eb_xPos)*(p_xPos-eb_xPos)+(p_yPos-eb_yPos)*(p_yPos-eb_yPos));\n    }\n    ///////////////////////////////////////////////////////////////\n\n\n    //////////////////jyouken 2    ball out of gancyu   ball chikai\n    else if(p_dist < ((float)p_siya_d) ){\n      if(x_dist<0 && y_dist <0){\n        p_x_ran=p_spd*abs(cos(kakudo*PI/180))*-1*random(-0.75,0.75);\n        p_y_ran=p_spd*abs(sin(kakudo*PI/180))*-1*random(-0.75,0.75);\n\n        p_xPos+=p_x_ran;\n        p_yPos+=p_y_ran;\n      }\n\n      else if(x_dist>0 && y_dist <0){\n        p_x_ran=p_spd*abs(cos(kakudo*PI/180))*random(-0.75,0.75);\n        p_y_ran=p_spd*abs(sin(kakudo*PI/180))*-1*random(-0.75,0.75);\n\n        p_xPos+=p_x_ran;\n        p_yPos+=p_y_ran;\n      }\n\n      if(x_dist<0 && y_dist >0){\n        p_x_ran=p_spd*abs(cos(kakudo*PI/180))*-1*random(-0.75,0.75);\n        p_y_ran=p_spd*abs(sin(kakudo*PI/180))*random(-0.75,0.75);\n\n        p_xPos+=p_x_ran;\n        p_yPos+=p_y_ran;\n      }\n\n      else if(x_dist>0 && y_dist >0){\n        p_x_ran=p_spd*abs(cos(kakudo*PI/180))*random(-0.75,0.75);\n        p_y_ran=p_spd*abs(sin(kakudo*PI/180))*random(-0.75,0.75);\n\n        p_xPos+=p_x_ran;\n        p_yPos+=p_y_ran;\n      }\n\n      //hamidasi\n      if(p_xPos>400-p_radius) p_xPos=400-p_radius;\n      if(p_xPos<p_radius) p_xPos=p_radius;\n      if(p_yPos>800-p_radius) p_yPos=800-p_radius;\n      if(p_yPos<p_radius) p_yPos=p_radius;\n\n      dist[num]=sqrt((p_xPos-eb_xPos)*(p_xPos-eb_xPos)+(p_yPos-eb_yPos)*(p_yPos-eb_yPos));\n\n    }\n    /////////////////////////////////////////////////////////\n\n    /////////////jyouken 3    ball toi\n    else if(p_dist > ((float)p_siya_d) ){\n\n            if(x_dist<=0 && y_dist <0){\n        p_x_ran=p_spd*(abs(cos(kakudo*PI/180))+random(-5.0,5.0))*-1*random(0,0.4);\n        p_y_ran=p_spd*abs(sin(kakudo*PI/180))*-1*random(0,0.4);\n\n        p_xPos+=p_x_ran;\n        p_yPos+=p_y_ran;\n      }\n\n      else if(x_dist>=0 && y_dist <0){\n        p_x_ran=p_spd*(abs(cos(kakudo*PI/180))+random(-5.0,5.0))*random(0,0.4);\n        p_y_ran=p_spd*abs(sin(kakudo*PI/180))*-1*random(0,0.4);\n\n        p_xPos+=p_x_ran;\n        p_yPos+=p_y_ran;\n      }\n\n      if(x_dist<=0 && y_dist >0){\n        p_x_ran=p_spd*(abs(cos(kakudo*PI/180))+random(-5.0,5.0))*-1*random(0,0.4);\n        p_y_ran=p_spd*abs(sin(kakudo*PI/180))*random(0,0.4);\n\n        p_xPos+=p_x_ran;\n        p_yPos+=p_y_ran;\n      }\n\n      else if(x_dist>=0 && y_dist >0){\n        p_x_ran=p_spd*(abs(cos(kakudo*PI/180))+random(-5.0,5.0))*random(0,0.4);\n        p_y_ran=p_spd*abs(sin(kakudo*PI/180))*random(0,0.4);\n\n        p_xPos+=p_x_ran;\n        p_yPos+=p_y_ran;\n      }\n\n      //hamidasi\n      if(p_xPos>400-p_radius) p_xPos=400-p_radius;\n      if(p_xPos<p_radius) p_xPos=p_radius;\n      if(p_yPos>800-p_radius) p_yPos=800-p_radius;\n      if(p_yPos<p_radius) p_yPos=p_radius;\n\n    }\n\n  }\n  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n  void p_kick_hantei(int num){\n    float min=min(dist);\n    if(dist[num]<p_radius && min == dist[num]){\n      kicked=true;\n      ball.kick(p_angl,p_power,num);    //ball.kick method uses as  ball.kick(ANGLE,POWER);\n    }\n  }\n\n\n  ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n  void display(int num){\n    float hani =(float) p_siya;\n    float siya1 =(float) (frame%p_siya);\n    float siya2 =(float) ((frame+1)%p_siya);\n    float siya_d=p_siya_d;\n    float kakudo=360.0;\n\n\n\n    if(num%2 == 0){\n      fill(#ff7fff,255);\n      ellipse(p_xPos,p_yPos,p_radius,p_radius);\n      fill(#ff7fff,63);\n      arc( p_xPos, p_yPos, siya_d*2, siya_d*2, radians(kakudo*siya1/hani),radians(kakudo*siya2/hani));\n      alpha(0);\n    }\n\n    else{\n      fill(#00bfff,255);\n      ellipse(p_xPos,p_yPos,p_radius,p_radius);\n      fill(#00bfff,63);\n      arc( p_xPos, p_yPos, siya_d*2, siya_d*2, radians(kakudo*siya1/hani),radians(kakudo*siya2/hani));\n      alpha(0);\n    }\n  }\n  ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n  void p_goal_init(int num){\n    float x_pos=random(p_radius*2,400-p_radius*2);\n    float y_pos=random(p_radius*2,800-p_radius*2);\n\n    p_xPos=x_pos;\n    p_yPos=y_pos;\n  }\n}\n\n\nhttp://qiita.com/66zaha_9su/items/de5dff79f2be21a1db1f\n\u2191\u306e\u30bd\u30fc\u30b9\u306b\u306a\u3063\u3066\u304a\u308a\u307e\u3059\u3002\u2191\n\n#\u30bd\u30fc\u30b9\n\n```processing:soccer_ai.pde\nlong frame =0;\nfloat eb_xPos;\nfloat eb_yPos;\nboolean kicked=false;\nint b_point=0;\nint p_point=0;\n\nfloat[] dist;\n\nPlayer[] players =new Player[22];\nBall ball =new Ball();\n \nvoid setup() {\n  size(400, 800);  \n  background(255);\n  smooth();\n  noStroke();\n  fill(0);\n  frameRate(-60);\n  \n  dist=new float[players.length];\n  \n  for (int i = 0; i < players.length; i++) players[i] = new Player();\n  for (int j = 0; j < players.length; j++) players[j].P_initialize(j);\n  for (int k = 0; k < players.length; k++)dist[k]=9999.9;\n  \n  ball=new Ball();\n  ball.B_initialize();\n}\n \nvoid draw() {\n  background(255);\n  frame++;\n  \n  \n  for (int i = 0; i < players.length; i++) {\n    dist[i]=9999.9;\n    players[i].update(i);\n    players[i].p_kick_hantei(i);\n    players[i].display(i);\n    \n    //circles[i].update();\n    //circles[i].display();\n  }\n  ball.display();\n  kicked=false;\n  \n  fill(0);\n  text(frame+\"F\", 5, 10);\n  text(nfs(frameRate, 3, 1)+\"FPS\", 80, 10);\n  text(p_point+\"-\"+b_point, 160, 10);\n}\n\n\nclass Ball{\n  float b_radius;\n  float b_xPos;\n  float b_yPos;\n  \n  Ball(){\n    b_radius=18.0;\n    b_xPos=200;\n    b_yPos=400;\n  }\n  \n  void B_initialize(){\n    fill(#000000);\n    ellipse(200, 400, b_radius, b_radius);\n    b_xPos=200; b_yPos=400;\n    eb_xPos=200; eb_yPos=400;\n  }\n  \n  void display(){\n    fill(#000000);\n    ellipse(b_xPos, b_yPos, b_radius, b_radius);\n    eb_xPos=b_xPos; eb_yPos=b_yPos;\n  }\n  \n  void kick(float kakudo,float power,int num){\n    float p_x_kick=(cos(kakudo*PI/180)+0.2)*power;\n    float p_y_kick=(sin(kakudo*PI/180)+0.2)*power;\n    \n    \n    \n    if(num%2 ==0){\n      b_xPos+=p_x_kick;\n      b_yPos+=p_y_kick;\n      \n      if(b_xPos>400-b_radius) b_xPos=400-b_radius;  //ball is out of vesel (not goal)\n      if(b_xPos<b_radius) b_xPos=b_radius;  //ball is out of vesel (not goal)\n      \n      if(b_yPos>800-b_radius){\n        p_point++;\n        b_yPos=400;\n        b_xPos=200;\n        \n        for(int i=0; i<players.length; i++){\n          players[i].p_goal_init(i);\n        }\n    }\n      if(b_yPos<b_radius){\n        b_point++;\n        b_yPos=400;\n        b_xPos=200;\n        \n        for(int i=0; i<players.length; i++){\n          players[i].p_goal_init(i);\n        }\n    }\n      \n      eb_xPos=b_xPos;\n      eb_yPos=b_yPos;\n    }\n    \n    else if(num%2 ==1){\n      b_xPos-=p_x_kick;\n      b_yPos-=p_y_kick;\n      \n      if(b_xPos>400-b_radius) b_xPos=400-b_radius;  //ball is out of vesel (not goal)\n      if(b_xPos<b_radius) b_xPos=b_radius;  //ball is out of vesel (not goal)\n      \n      if(b_yPos>800-b_radius){\n        p_point++;\n        b_yPos=400;\n        b_xPos=200;\n        \n        for(int i=0; i<players.length; i++){\n          players[i].p_goal_init(i);\n        }\n    }\n      if(b_yPos<b_radius){\n        b_point++;\n        b_yPos=400;\n        b_xPos=200;\n        \n        for(int i=0; i<players.length; i++){\n          players[i].p_goal_init(i);\n        }\n    }\n      \n      eb_xPos=b_xPos;\n      eb_yPos=b_yPos;\n    }\n  }\n}\n\n\n\n///////////////////////////////////////////////////////////////////////////////////\nclass Player{\n  float p_radius = 28;\n  float p_xPos;\n  float p_yPos;\n  float p_xVec;\n  float p_yVec;\n  float p_spd;\n  float p_angl;\n  float p_power;\n  \n  int p_siya;\n  int p_siya_d;\n  \n  Player(){    //mainly initiallize process    initial position determine another process\n  p_spd=12*random(0.6,0.9);\n  p_angl=0;\n  p_xPos=0;\n  p_yPos=0;\n  \n  p_siya=(int) random(2,12);\n  p_siya_d=(int) random(160,600);\n  \n  p_power=random(12,32);\n  }\n  \n  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n  void P_initialize(int _number){\n    int p_number = _number;\n    \n    if(p_number%2 ==0){\n      \n      if(p_number == 0){\n        fill(#ff7fff);\n        ellipse(40, 80, p_radius, p_radius);\n        p_xPos=40; p_yPos=80;\n      }\n      \n      if(p_number == 2){\n        fill(#ff7fff);\n        ellipse(200, 80, p_radius, p_radius);\n        p_xPos=200; p_yPos=80;\n      }\n      \n      if(p_number == 4){\n        fill(#ff7fff);\n        ellipse(360, 80, p_radius, p_radius);\n        p_xPos=360; p_yPos=80;\n      }\n      \n      if(p_number == 6){\n        fill(#ff7fff);\n        ellipse(150, 350, p_radius, p_radius);\n        p_xPos=150; p_yPos=350;\n      }\n      \n      if(p_number == 8){\n        fill(#ff7fff);\n        ellipse(250, 350, p_radius, p_radius);\n        p_xPos=250; p_yPos=350;\n      }\n    }\n    \n    else if(p_number%2 ==1){\n      \n      if(p_number == 1){\n        fill(#00bfff);\n        ellipse(40, 720, p_radius, p_radius);\n        p_xPos=40; p_yPos=720;\n      }\n      \n      if(p_number == 3){\n        fill(#00bfff);\n        ellipse(200, 720, p_radius, p_radius);\n        p_xPos=200; p_yPos=720;\n      }\n      \n      if(p_number == 5){\n        fill(#00bfff);\n        ellipse(360, 720, p_radius, p_radius);\n        p_xPos=360; p_yPos=720;\n      }\n      \n      if(p_number == 7){\n        fill(#00bfff);\n        ellipse(150, 450, p_radius, p_radius);\n        p_xPos=150; p_yPos=450;\n      }\n      \n      if(p_number == 9){\n        fill(#00bfff);\n        ellipse(250, 450, p_radius, p_radius);\n        p_xPos=250; p_yPos=450;\n      }\n    }\n    \n  }\n ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n  \n  void update(int num){\n    float p_dist;\n    float x_dist;\n    float y_dist;\n    float kakudo;\n    \n    float p_siya_f;    //f means from\n    float p_siya_e;    //e means end\n    \n    float p_x_ran;\n    float p_y_ran;\n    \n    \n    p_dist=sqrt((p_xPos-eb_xPos)*(p_xPos-eb_xPos)+(p_yPos-eb_yPos)*(p_yPos-eb_yPos));\n    x_dist=eb_xPos-p_xPos;\n    y_dist=eb_yPos-p_yPos;\n    \n    kakudo=degrees(atan2(x_dist,y_dist));\n    \n    if(kakudo < 0){\n      kakudo+=kakudo+360;\n    }\n    \n    p_angl=kakudo;\n    \n    p_siya_f = 360 * ( (float)frame % (float)p_siya ) / (float)p_siya;\n    p_siya_e = 360 * ( (float)frame % (float)p_siya +1) / (float)p_siya;\n    \n    /////////////jyouken 1    ball siyanai   ball chikai\n    if( p_dist < ((float)p_siya_d) && p_siya_f < kakudo && kakudo < p_siya_e){\n      //println(\"players[\"+num+\"], \"+x_dist+\",\"+y_dist +\" , p_dist: \"+p_dist +\", p_siya_d: \"+p_siya_d +\" , kakudo: \"+kakudo +\", siya: \"+ p_siya_f +\" ~ \"+p_siya_e);\n      \n      if(x_dist<=0 && y_dist <=0){\n        p_x_ran=p_spd*(abs(cos(kakudo*PI/180)))*-1;\n        p_y_ran=p_spd*abs(sin(kakudo*PI/180))*-1;\n        \n        p_xPos+=p_x_ran;\n        p_yPos+=p_y_ran;\n      }\n      \n      else if(x_dist>=0 && y_dist <=0){\n        p_x_ran=p_spd*abs(cos(kakudo*PI/180));\n        p_y_ran=p_spd*abs(sin(kakudo*PI/180))*-1;\n        \n        p_xPos+=p_x_ran;\n        p_yPos+=p_y_ran;\n      }\n      \n      if(x_dist<=0 && y_dist >=0){\n        p_x_ran=p_spd*abs(cos(kakudo*PI/180))*-1;\n        p_y_ran=p_spd*abs(sin(kakudo*PI/180));\n        \n        p_xPos+=p_x_ran;\n        p_yPos+=p_y_ran;\n      }\n      \n      else if(x_dist>=0 && y_dist >=0){\n        p_x_ran=p_spd*abs(cos(kakudo*PI/180));\n        p_y_ran=p_spd*abs(sin(kakudo*PI/180));\n        \n        p_xPos+=p_x_ran;\n        p_yPos+=p_y_ran;\n      }\n      \n      //hamidasi\n      if(p_xPos>400-p_radius) p_xPos=400-p_radius;\n      if(p_xPos<p_radius) p_xPos=p_radius;\n      if(p_yPos>800-p_radius) p_yPos=800-p_radius;\n      if(p_yPos<p_radius) p_yPos=p_radius;\n      \n      dist[num]=sqrt((p_xPos-eb_xPos)*(p_xPos-eb_xPos)+(p_yPos-eb_yPos)*(p_yPos-eb_yPos));\n    }\n    ///////////////////////////////////////////////////////////////\n    \n    \n    //////////////////jyouken 2    ball out of gancyu   ball chikai\n    else if(p_dist < ((float)p_siya_d) ){\n      if(x_dist<0 && y_dist <0){\n        p_x_ran=p_spd*abs(cos(kakudo*PI/180))*-1*random(-0.75,0.75);\n        p_y_ran=p_spd*abs(sin(kakudo*PI/180))*-1*random(-0.75,0.75);\n        \n        p_xPos+=p_x_ran;\n        p_yPos+=p_y_ran;\n      }\n      \n      else if(x_dist>0 && y_dist <0){\n        p_x_ran=p_spd*abs(cos(kakudo*PI/180))*random(-0.75,0.75);\n        p_y_ran=p_spd*abs(sin(kakudo*PI/180))*-1*random(-0.75,0.75);\n        \n        p_xPos+=p_x_ran;\n        p_yPos+=p_y_ran;\n      }\n      \n      if(x_dist<0 && y_dist >0){\n        p_x_ran=p_spd*abs(cos(kakudo*PI/180))*-1*random(-0.75,0.75);\n        p_y_ran=p_spd*abs(sin(kakudo*PI/180))*random(-0.75,0.75);\n        \n        p_xPos+=p_x_ran;\n        p_yPos+=p_y_ran;\n      }\n      \n      else if(x_dist>0 && y_dist >0){\n        p_x_ran=p_spd*abs(cos(kakudo*PI/180))*random(-0.75,0.75);\n        p_y_ran=p_spd*abs(sin(kakudo*PI/180))*random(-0.75,0.75);\n        \n        p_xPos+=p_x_ran;\n        p_yPos+=p_y_ran;\n      }\n      \n      //hamidasi\n      if(p_xPos>400-p_radius) p_xPos=400-p_radius;\n      if(p_xPos<p_radius) p_xPos=p_radius;\n      if(p_yPos>800-p_radius) p_yPos=800-p_radius;\n      if(p_yPos<p_radius) p_yPos=p_radius;\n      \n      dist[num]=sqrt((p_xPos-eb_xPos)*(p_xPos-eb_xPos)+(p_yPos-eb_yPos)*(p_yPos-eb_yPos));\n      \n    }\n    /////////////////////////////////////////////////////////\n    \n    /////////////jyouken 3    ball toi\n    else if(p_dist > ((float)p_siya_d) ){\n      \n            if(x_dist<=0 && y_dist <0){\n        p_x_ran=p_spd*(abs(cos(kakudo*PI/180))+random(-5.0,5.0))*-1*random(0,0.4);\n        p_y_ran=p_spd*abs(sin(kakudo*PI/180))*-1*random(0,0.4);\n        \n        p_xPos+=p_x_ran;\n        p_yPos+=p_y_ran;\n      }\n      \n      else if(x_dist>=0 && y_dist <0){\n        p_x_ran=p_spd*(abs(cos(kakudo*PI/180))+random(-5.0,5.0))*random(0,0.4);\n        p_y_ran=p_spd*abs(sin(kakudo*PI/180))*-1*random(0,0.4);\n       \n        p_xPos+=p_x_ran;\n        p_yPos+=p_y_ran;\n      }\n      \n      if(x_dist<=0 && y_dist >0){\n        p_x_ran=p_spd*(abs(cos(kakudo*PI/180))+random(-5.0,5.0))*-1*random(0,0.4);\n        p_y_ran=p_spd*abs(sin(kakudo*PI/180))*random(0,0.4);\n        \n        p_xPos+=p_x_ran;\n        p_yPos+=p_y_ran;\n      }\n      \n      else if(x_dist>=0 && y_dist >0){\n        p_x_ran=p_spd*(abs(cos(kakudo*PI/180))+random(-5.0,5.0))*random(0,0.4);\n        p_y_ran=p_spd*abs(sin(kakudo*PI/180))*random(0,0.4);\n        \n        p_xPos+=p_x_ran;\n        p_yPos+=p_y_ran;\n      }\n      \n      //hamidasi\n      if(p_xPos>400-p_radius) p_xPos=400-p_radius;\n      if(p_xPos<p_radius) p_xPos=p_radius;\n      if(p_yPos>800-p_radius) p_yPos=800-p_radius;\n      if(p_yPos<p_radius) p_yPos=p_radius;\n      \n    }\n    \n  }\n  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n  \n  void p_kick_hantei(int num){\n    float min=min(dist);\n    if(dist[num]<p_radius && min == dist[num]){\n      kicked=true;\n      ball.kick(p_angl,p_power,num);    //ball.kick method uses as  ball.kick(ANGLE,POWER);\n    }\n  }\n  \n  \n  ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n  void display(int num){\n    float hani =(float) p_siya;\n    float siya1 =(float) (frame%p_siya);\n    float siya2 =(float) ((frame+1)%p_siya);\n    float siya_d=p_siya_d;\n    float kakudo=360.0;\n    \n    \n    \n    if(num%2 == 0){\n      fill(#ff7fff,255);\n      ellipse(p_xPos,p_yPos,p_radius,p_radius);\n      fill(#ff7fff,63);\n      arc( p_xPos, p_yPos, siya_d*2, siya_d*2, radians(kakudo*siya1/hani),radians(kakudo*siya2/hani));\n      alpha(0);\n    }\n    \n    else{\n      fill(#00bfff,255);\n      ellipse(p_xPos,p_yPos,p_radius,p_radius);\n      fill(#00bfff,63);\n      arc( p_xPos, p_yPos, siya_d*2, siya_d*2, radians(kakudo*siya1/hani),radians(kakudo*siya2/hani));\n      alpha(0);\n    }\n  }\n  ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n  \n  void p_goal_init(int num){\n    float x_pos=random(p_radius*2,400-p_radius*2);\n    float y_pos=random(p_radius*2,800-p_radius*2);\n    \n    p_xPos=x_pos;\n    p_yPos=y_pos;\n  }\n}\n```\n\n", "tags": ["\u4eba\u5de5\u77e5\u80fd", "processing", "Java", "\u30b7\u30df\u30e5\u30ec\u30fc\u30b7\u30e7\u30f3", "\u30bd\u30fc\u30b9\u30b3\u30fc\u30c9"]}