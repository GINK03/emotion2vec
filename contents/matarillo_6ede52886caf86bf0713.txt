{"tags": ["\u3069\u3046\u66f8\u304f", "yhpg", "F#"], "context": " More than 1 year has passed since last update.\u554f\u984c\u306f\u300c\u5c71\u6298\u308a\u8c37\u6298\u308a\u300d\n\u3084\u3063\u3066\u308b\u3053\u3068\u306fC#\u3068\u3042\u3093\u307e\u308a\u5909\u308f\u3089\u306a\u3044\u3051\u3069\u3001\u578b\u3092\u304d\u3063\u3061\u308a\u3057\u3066\u307f\u305f\u306e\u3067\u4f59\u8a08\u306b\u9577\u304f\u306a\u3063\u3066\u3044\u308b\u3002\n\nProgram.fs\ntype Paper = Front | Back\ntype Folding = Mountain | Volley\ntype Tree = Leaf of Paper | Node of Paper * Folding * Tree\n\nlet rec add f x y =\n  match x with\n  | Leaf p           -> Node (p, f, y)\n  | Node (p, f', x') -> Node (p, f', add f x' y)\n\nlet fold p c =\n    match (p, c) with\n    | (Front, 'L') -> Node (Back, Volley, Leaf Front)\n    | (Front, 'J') -> Node (Front, Volley, Leaf Back)\n    | (Front, 'Z') -> Node (Front, Mountain, Node (Back, Volley, Leaf Front))\n    | (Front, 'U') -> Node (Back, Volley, Node (Front, Volley, Leaf Back))\n    | (Front, 'S') -> Node (Front, Volley, Node (Back, Mountain, Leaf Front))\n    | (Back,  'L') -> Node (Back, Mountain, Leaf Front)\n    | (Back,  'J') -> Node (Front, Mountain, Leaf Back)\n    | (Back,  'Z') -> Node (Back, Mountain, Node (Front, Volley, Leaf Back))\n    | (Back,  'U') -> Node (Front, Mountain, Node (Back, Mountain, Leaf Front))\n    | (Back,  'S') -> Node (Back, Volley, Node (Front, Mountain, Leaf Back))\n    | _            -> Leaf Front\n\nlet rec foldRec = function\n    | Leaf p         -> fold p\n    | Node (p, f, x) -> fun c -> add f (fold p c) (foldRec x c)\n\nlet rec openRec = function\n    | Leaf _ -> []\n    | Node (x, f, y) -> f :: openRec y\n\nlet solve (s: string) =\n    s\n    |> Seq.fold foldRec (Leaf Front)\n    |> openRec\n    |> List.map (function|Mountain->'m'|Volley->'V')\n    |> List.toArray\n    |> fun x -> new string(x)\n\n(* for test *)\n\ntype TestResult = Success | Failure\n\nlet test target expected =\n  let actual = solve target\n  printfn \"%A\" (if expected = actual then Success else Failure)\n\n[<EntryPoint>]\nlet main argv = \n    test \"JZ\" \"mVVmV\"\n    test \"J\" \"V\"\n    test \"L\" \"V\"\n    test \"Z\" \"mV\"\n    test \"U\" \"VV\"\n    test \"S\" \"Vm\"\n    test \"JL\" \"VVm\"\n    test \"JS\" \"VmVVm\"\n    test \"JU\" \"VVVmm\"\n    test \"LU\" \"mmVVV\"\n    test \"SL\" \"VVmmV\"\n    test \"SS\" \"VmVVmmVm\"\n    test \"SU\" \"VVVmmmVV\"\n    test \"SZ\" \"mVVmVmmV\"\n    test \"UL\" \"mVVVm\"\n    test \"UU\" \"mmVVVVmm\"\n    test \"UZ\" \"mVVmVVmV\"\n    test \"ZJ\" \"VmmVV\"\n    test \"ZS\" \"VmmVmVVm\"\n    test \"ZZ\" \"mVmmVVmV\"\n    test \"JJJ\" \"VVmVVmm\"\n    test \"JJZ\" \"mVVmVVmVmmV\"\n    test \"JSJ\" \"VVmmVVmVVmm\"\n    test \"JSS\" \"VmVVmmVmVVmVVmmVm\"\n    test \"JUS\" \"VmVVmVVmVVmmVmmVm\"\n    test \"JUU\" \"mmVVVVmmVVVmmmmVV\"\n    test \"JUZ\" \"mVVmVVmVVmVmmVmmV\"\n    test \"LJJ\" \"VmmVVVm\"\n    test \"LLS\" \"VmmVmVVmVVm\"\n    test \"LLU\" \"mmmVVVmmVVV\"\n    test \"LLZ\" \"mVmmVVmVVmV\"\n    test \"LSU\" \"mmVVVmmmVVVVmmmVV\"\n    test \"LSZ\" \"mVVmVmmVVmVVmVmmV\"\n    test \"LZL\" \"mmVVmVVmmVV\"\n    test \"LZS\" \"VmmVmVVmVVmmVmVVm\"\n    test \"LZU\" \"mmmVVVmmVVVmmmVVV\"\n    test \"SJL\" \"VVmVVmmmVVm\"\n    test \"SLU\" \"mmVVVVmmmVVmmmVVV\"\n    test \"SLZ\" \"mVVmVVmVmmVmmVVmV\"\n    test \"SSU\" \"VVVmmmVVVmmVVVmmmmVVVmmmVV\"\n    test \"SUJ\" \"mVVVmVVmmmVmmVVVm\"\n    test \"SUS\" \"VmVVmVVmVVmmVmmVmmVmVVmVVm\"\n    test \"SZZ\" \"mVmmVVmVVmVmmVVmVmmVmmVVmV\"\n    test \"UJJ\" \"VmmVVVmVVmm\"\n    test \"ULU\" \"mmmVVVmmVVVVmmmVV\"\n    test \"ULZ\" \"mVmmVVmVVmVVmVmmV\"\n    test \"UUU\" \"VVmmmmVVVmmVVVVmmVVVmmmmVV\"\n    test \"ZJU\" \"VVVmmmVVmmmVVVVmm\"\n    test \"ZLS\" \"VmVVmmVmmVmVVmVVm\"\n    test \"ZSJ\" \"VVmmVmmVVmmVVVmmV\"\n    test \"ZUJ\" \"mVVVmmVmmmVVmVVVm\"\n    test \"JJLJ\" \"mVVVmmVVmVVmmmV\"\n    test \"JLJJ\" \"VmmVVVmVVmmmVVm\"\n    test \"JLJL\" \"VmmVVVmVVmmmVVm\"\n    test \"LJJL\" \"VVmmVmmVVVmVVmm\"\n    test \"LLJJ\" \"VmmmVVmVVmmVVVm\"\n    test \"SZUS\" \"VmVVmVVmmVmmVmmVmVVmVVmVVmVVmmVmmVmmVmVVmVVmVVmmVmmVmmVmVVmVVmmVmmVmmVmVVmVVmVVm\"\n    test \"ULLS\" \"VmmVmmVmVVmVVmmVmVVmVVmVVmmVmmVmVVm\"\n    test \"JJJJZJ\" \"VmmVVVmmVVmVVmmVVmmmVVmVVmmVVVmmVVmmVmmVVmmmVVmVVmmVVVmmVVmVVmmVVmmmVVmmVmmVVVmmVVmmVmmVVmmmVVm\"\n    test \"JULLLJ\" \"mmVmmVVmmmVVmVVVmmVmmVVVmmVVmVVVmmVmmVVmmmVVmVVVmmVmmVVVmmVVmVVmmmVmmVVmmmVVmVVmmmVmmVVVmmVVmVV\"\n    test \"LJJJUL\" \"mVVVmVVmmmVVmVVVmmVmmmVmmVVVmVVmmmVmmVVVmmVmmmVVmVVVmVVmmmVVmVVVmmVmmmVVmVVVmVVmmmVmmVVVmmVmmmV\"\n    test \"LJSJJL\" \"VVmVVmmVVVmmVmmmVVmVVmmmVVmmVmmVVVmVVmmmVVmmVmmVVVmVVmmVVVmmVmmmVVmVVmmVVVmmVmmVVVmVVmmmVVmmVmm\"\n    test \"LZLLLJ\" \"mmVmmVVmmmVVmVVmmmVmmVVVmmVVmVVVmmVmmVVmmmVVmVVVmmVmmVVVmmVVmVVmmmVmmVVmmmVVmVVVmmVmmVVVmmVVmVV\"\n    test \"SJJJJL\" \"VVmVVmmVVVmmVmmVVVmVVmmmVVmmVmmVVVmVVmmVVVmmVmmmVVmVVmmmVVmmVmmmVVmVVmmVVVmmVmmVVVmVVmmmVVmmVmm\"\n    test \"ZLJLJL\" \"VmmVVVmmVmmmVVmVVmmVVVmVVmmmVVmmVmmVVVmmVmmmVVmmVmmVVVmVVmmmVVmVVmmVVVmmVmmmVVmVVmmVVVmVVmmmVVm\"\n    0\n\n\n\u554f\u984c\u306f\u300c[\u5c71\u6298\u308a\u8c37\u6298\u308a](http://nabetani.sakura.ne.jp/hena/ord18mafovafo/)\u300d\n\u3084\u3063\u3066\u308b\u3053\u3068\u306fC#\u3068\u3042\u3093\u307e\u308a\u5909\u308f\u3089\u306a\u3044\u3051\u3069\u3001\u578b\u3092\u304d\u3063\u3061\u308a\u3057\u3066\u307f\u305f\u306e\u3067\u4f59\u8a08\u306b\u9577\u304f\u306a\u3063\u3066\u3044\u308b\u3002\n\n```fsharp:Program.fs\ntype Paper = Front | Back\ntype Folding = Mountain | Volley\ntype Tree = Leaf of Paper | Node of Paper * Folding * Tree\n\nlet rec add f x y =\n  match x with\n  | Leaf p           -> Node (p, f, y)\n  | Node (p, f', x') -> Node (p, f', add f x' y)\n\nlet fold p c =\n    match (p, c) with\n    | (Front, 'L') -> Node (Back, Volley, Leaf Front)\n    | (Front, 'J') -> Node (Front, Volley, Leaf Back)\n    | (Front, 'Z') -> Node (Front, Mountain, Node (Back, Volley, Leaf Front))\n    | (Front, 'U') -> Node (Back, Volley, Node (Front, Volley, Leaf Back))\n    | (Front, 'S') -> Node (Front, Volley, Node (Back, Mountain, Leaf Front))\n    | (Back,  'L') -> Node (Back, Mountain, Leaf Front)\n    | (Back,  'J') -> Node (Front, Mountain, Leaf Back)\n    | (Back,  'Z') -> Node (Back, Mountain, Node (Front, Volley, Leaf Back))\n    | (Back,  'U') -> Node (Front, Mountain, Node (Back, Mountain, Leaf Front))\n    | (Back,  'S') -> Node (Back, Volley, Node (Front, Mountain, Leaf Back))\n    | _            -> Leaf Front\n\nlet rec foldRec = function\n    | Leaf p         -> fold p\n    | Node (p, f, x) -> fun c -> add f (fold p c) (foldRec x c)\n\nlet rec openRec = function\n    | Leaf _ -> []\n    | Node (x, f, y) -> f :: openRec y\n\nlet solve (s: string) =\n    s\n    |> Seq.fold foldRec (Leaf Front)\n    |> openRec\n    |> List.map (function|Mountain->'m'|Volley->'V')\n    |> List.toArray\n    |> fun x -> new string(x)\n\n(* for test *)\n\ntype TestResult = Success | Failure\n\nlet test target expected =\n  let actual = solve target\n  printfn \"%A\" (if expected = actual then Success else Failure)\n\n[<EntryPoint>]\nlet main argv = \n    test \"JZ\" \"mVVmV\"\n    test \"J\" \"V\"\n    test \"L\" \"V\"\n    test \"Z\" \"mV\"\n    test \"U\" \"VV\"\n    test \"S\" \"Vm\"\n    test \"JL\" \"VVm\"\n    test \"JS\" \"VmVVm\"\n    test \"JU\" \"VVVmm\"\n    test \"LU\" \"mmVVV\"\n    test \"SL\" \"VVmmV\"\n    test \"SS\" \"VmVVmmVm\"\n    test \"SU\" \"VVVmmmVV\"\n    test \"SZ\" \"mVVmVmmV\"\n    test \"UL\" \"mVVVm\"\n    test \"UU\" \"mmVVVVmm\"\n    test \"UZ\" \"mVVmVVmV\"\n    test \"ZJ\" \"VmmVV\"\n    test \"ZS\" \"VmmVmVVm\"\n    test \"ZZ\" \"mVmmVVmV\"\n    test \"JJJ\" \"VVmVVmm\"\n    test \"JJZ\" \"mVVmVVmVmmV\"\n    test \"JSJ\" \"VVmmVVmVVmm\"\n    test \"JSS\" \"VmVVmmVmVVmVVmmVm\"\n    test \"JUS\" \"VmVVmVVmVVmmVmmVm\"\n    test \"JUU\" \"mmVVVVmmVVVmmmmVV\"\n    test \"JUZ\" \"mVVmVVmVVmVmmVmmV\"\n    test \"LJJ\" \"VmmVVVm\"\n    test \"LLS\" \"VmmVmVVmVVm\"\n    test \"LLU\" \"mmmVVVmmVVV\"\n    test \"LLZ\" \"mVmmVVmVVmV\"\n    test \"LSU\" \"mmVVVmmmVVVVmmmVV\"\n    test \"LSZ\" \"mVVmVmmVVmVVmVmmV\"\n    test \"LZL\" \"mmVVmVVmmVV\"\n    test \"LZS\" \"VmmVmVVmVVmmVmVVm\"\n    test \"LZU\" \"mmmVVVmmVVVmmmVVV\"\n    test \"SJL\" \"VVmVVmmmVVm\"\n    test \"SLU\" \"mmVVVVmmmVVmmmVVV\"\n    test \"SLZ\" \"mVVmVVmVmmVmmVVmV\"\n    test \"SSU\" \"VVVmmmVVVmmVVVmmmmVVVmmmVV\"\n    test \"SUJ\" \"mVVVmVVmmmVmmVVVm\"\n    test \"SUS\" \"VmVVmVVmVVmmVmmVmmVmVVmVVm\"\n    test \"SZZ\" \"mVmmVVmVVmVmmVVmVmmVmmVVmV\"\n    test \"UJJ\" \"VmmVVVmVVmm\"\n    test \"ULU\" \"mmmVVVmmVVVVmmmVV\"\n    test \"ULZ\" \"mVmmVVmVVmVVmVmmV\"\n    test \"UUU\" \"VVmmmmVVVmmVVVVmmVVVmmmmVV\"\n    test \"ZJU\" \"VVVmmmVVmmmVVVVmm\"\n    test \"ZLS\" \"VmVVmmVmmVmVVmVVm\"\n    test \"ZSJ\" \"VVmmVmmVVmmVVVmmV\"\n    test \"ZUJ\" \"mVVVmmVmmmVVmVVVm\"\n    test \"JJLJ\" \"mVVVmmVVmVVmmmV\"\n    test \"JLJJ\" \"VmmVVVmVVmmmVVm\"\n    test \"JLJL\" \"VmmVVVmVVmmmVVm\"\n    test \"LJJL\" \"VVmmVmmVVVmVVmm\"\n    test \"LLJJ\" \"VmmmVVmVVmmVVVm\"\n    test \"SZUS\" \"VmVVmVVmmVmmVmmVmVVmVVmVVmVVmmVmmVmmVmVVmVVmVVmmVmmVmmVmVVmVVmmVmmVmmVmVVmVVmVVm\"\n    test \"ULLS\" \"VmmVmmVmVVmVVmmVmVVmVVmVVmmVmmVmVVm\"\n    test \"JJJJZJ\" \"VmmVVVmmVVmVVmmVVmmmVVmVVmmVVVmmVVmmVmmVVmmmVVmVVmmVVVmmVVmVVmmVVmmmVVmmVmmVVVmmVVmmVmmVVmmmVVm\"\n    test \"JULLLJ\" \"mmVmmVVmmmVVmVVVmmVmmVVVmmVVmVVVmmVmmVVmmmVVmVVVmmVmmVVVmmVVmVVmmmVmmVVmmmVVmVVmmmVmmVVVmmVVmVV\"\n    test \"LJJJUL\" \"mVVVmVVmmmVVmVVVmmVmmmVmmVVVmVVmmmVmmVVVmmVmmmVVmVVVmVVmmmVVmVVVmmVmmmVVmVVVmVVmmmVmmVVVmmVmmmV\"\n    test \"LJSJJL\" \"VVmVVmmVVVmmVmmmVVmVVmmmVVmmVmmVVVmVVmmmVVmmVmmVVVmVVmmVVVmmVmmmVVmVVmmVVVmmVmmVVVmVVmmmVVmmVmm\"\n    test \"LZLLLJ\" \"mmVmmVVmmmVVmVVmmmVmmVVVmmVVmVVVmmVmmVVmmmVVmVVVmmVmmVVVmmVVmVVmmmVmmVVmmmVVmVVVmmVmmVVVmmVVmVV\"\n    test \"SJJJJL\" \"VVmVVmmVVVmmVmmVVVmVVmmmVVmmVmmVVVmVVmmVVVmmVmmmVVmVVmmmVVmmVmmmVVmVVmmVVVmmVmmVVVmVVmmmVVmmVmm\"\n    test \"ZLJLJL\" \"VmmVVVmmVmmmVVmVVmmVVVmVVmmmVVmmVmmVVVmmVmmmVVmmVmmVVVmVVmmmVVmVVmmVVVmmVmmmVVmVVmmVVVmVVmmmVVm\"\n    0\n```"}