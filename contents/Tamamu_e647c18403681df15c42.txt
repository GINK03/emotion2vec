{"context": "\u8a00\u8a9e\u5b9f\u88c5\u7d20\u4eba\u3067\u3059\u304c\u3001Lisp\u306eLLVM\u30d5\u30ed\u30f3\u30c8\u30a8\u30f3\u30c9\u3092\u4f5c\u308d\u3046\u3068\u3057\u305f\u8a18\u9332\u3092\u6b8b\u3057\u305f\u3044\u3068\u601d\u3044\u307e\u3059\u3002\n\u9014\u4e2d\u3067\u884c\u304d\u8a70\u307e\u3063\u3066\u3057\u307e\u3063\u305f\u306e\u3067\u3001\u307e\u305f\u9032\u5c55\u304c\u3042\u308c\u3070\u968f\u6642\u66f4\u65b0\u3057\u3066\u3044\u304d\u307e\u3059\u3002\n2016/12/10 23:55 \u8ffd\u8a18\u3057\u307e\u3057\u305f\u3002car\u3067\u5024\u304c\u53d6\u308a\u51fa\u305b\u308b\u3088\u3046\u306b\u3002\n\n\u76ee\u6a19\ncons\u30fbcar\u30fbcdr\u3068\u56db\u5247\u6f14\u7b97+-*/\u3092\u7528\u3044\u305fLisp\u30b3\u30fc\u30c9\u3092LLVM IR\u306b\u5909\u63db\u3059\u308b\u3002\n\n\u74b0\u5883\n\nOCaml 4.03.0\noasis 0.4.7\nllvm 3.9\nsedlex 1.99.3\nmenhir 20160825\nppx_deriving 4.1\n\n\n\u958b\u767a\u306e\u6d41\u308c\n\u5168\u4f53\u7684\u306b\u3053\u3053\u3092\u53c2\u8003\u306b\u3057\u3066\u9032\u3081\u305f\u3002\n\n\u30d3\u30eb\u30c9\u30c4\u30fc\u30eb\u306e\u30bb\u30c3\u30c8\u30a2\u30c3\u30d7\n\u958b\u767a\u30c7\u30a3\u30ec\u30af\u30c8\u30ea\u76f4\u4e0b\u306bsrc\u30c7\u30a3\u30ec\u30af\u30c8\u30ea\u3068_oasis\u30d5\u30a1\u30a4\u30eb\u3092\u4f5c\u6210\u3002\n\n_oasis\nOASISFormat: 0.4\nName:        Llclimp\nVersion:     0.1.0\nSynopsis:    LLVM Common Lisp Implementation.\nAuthors:     Tamamu\nLicense:     MIT\nPlugins:     META (0.4)\n\nBuildTools: ocamlbuild\n\nLibrary llclimp\n  Path:       src\n  InternalModules: Parser\n  Modules: Ast, Syntax\n  CompiledObject: best\n  BuildDepends:\n    llvm, llvm.analysis, llvm.bitreader, sedlex, menhirLib, ppx_deriving.show\n\nExecutable llclimp\n  Path:       src\n  MainIs:     main.ml\n  CompiledObject: best\n  BuildDepends: llclimp\n\n\n\u4ee5\u4e0b\u306e\u30b3\u30de\u30f3\u30c9\u3067\u30d3\u30eb\u30c9\u7528\u306e\u30b9\u30af\u30ea\u30d7\u30c8\u3092\u4f5c\u6210\u3002\n$ oasis setup -setup-update dynamic\n\n\u30d3\u30eb\u30c9\u3059\u308b\u6642\u306f\u3053\u3046\u3002\n$ ocaml setup.ml -build -use-menhir\n\n\n\u69cb\u6587\u89e3\u6790\n\u307e\u305aparser\u3068lexer\u3092\u4f5c\u3063\u305f\u3002\n\u69cb\u6587\u6728\u306e\u305f\u3081\u306e\u30c7\u30fc\u30bf\u578b\u3092\u5b9a\u7fa9\u3059\u308b\u3002\n[@@deriving show]\u3067\u81ea\u52d5\u7684\u306b\u305d\u306e\u578b\u306eprinter\u304c\u4f5c\u3089\u308c\u308b\u3002\n\nsrc/ast.ml\ntype atom =\n  | Nil\n  | T\n  | Integer of int\n  | Float of float\n  | String of string\n  | Symbol of string\n[@@deriving show]\n\ntype statement =\n  |Sexp of statement list\n  |Atom of atom\n[@@deriving show]\n\n\nmenhir-example\u3092\u53c2\u8003\u306bparser\u3092\u4f5c\u6210\u3002\n\nsrc/parser.mly\n%{ open Ast %}\n\n%token Nil\n%token T\n%token <string> Symbol\n%token <int> Integer\n%token <float> Float\n%token <string> String\n%token LParen RParen Eof\n\n%start main\n%type <Ast.statement list> main\n\n%start main_statement\n%type <Ast.statement option> main_statement\n\n%%\n\nmain:\n| statements = list(statement) Eof {statements}\n\nmain_statement:\n| statement = statement {Some statement}\n| Eof {None}\n\nstatement:\n| sexp=sexp {Sexp sexp}\n| atom=atom {Atom atom}\n\nsexp:\n| LParen statements=list(statement) RParen {statements}\n\natom:\n| Nil {Nil}\n| T {T}\n| i=Integer {Integer i}\n| f=Float {Float f}\n| str=String {String str}\n| sym=Symbol {Symbol sym}\n\n\n\u6570\u5024\u578b\u4ee5\u5916\u306b\u3082t\u3084\u6587\u5b57\u5217\u578b\u3092\u5b9a\u7fa9\u3057\u3066\u3044\u308b\u304c\u3001\u4eca\u56de\u306f\u4f7f\u308f\u306a\u3044\u306e\u3067\u7121\u8996\u3057\u3066\u3082\u3088\u3044\u3002\n\u6b21\u306b\u5b57\u53e5\u89e3\u6790\u5668\u3092\u4f5c\u3063\u3066\u3044\u304f\u3002\n\u30c8\u30fc\u30af\u30f3\u5316\u306e\u90e8\u5206\u3092\u5909\u3048\u305f\u3060\u3051\u3067\u3001\u307b\u3068\u3093\u3069\u53c2\u8003\u5148\u3092\u5199\u7d4c\u3057\u305f\u306b\u904e\u304e\u306a\u3044\u3002\nsedlex\u306e\u6b63\u898f\u8868\u73fe\u306e\u66f8\u304d\u65b9\u306fGithub\u306e\u30da\u30fc\u30b8\u306b\u66f8\u3044\u3066\u3042\u308b\u3082\u306e\u3092\u53c2\u8003\u306b\u3057\u305f\u3002\nhttps://github.com/alainfrisch/sedlex\n\u307e\u305f\u8b58\u5225\u5b50\u540d\u306b\u4f7f\u3048\u308b\u6587\u5b57\u306f\u4ee5\u4e0b\u306e\u30da\u30fc\u30b8\u3092\u53c2\u8003\u306b\u3001C#\u306e\u3082\u306e\u3092\u771f\u4f3c\u3057\u3066\u307f\u305f\u3002\nhttp://ufcpp.net/study/csharp/misc_identifier.html\n\nsrc/syntax.ml\ntype lexbuf = {\n  stream: Sedlexing.lexbuf;\n  mutable pos: Lexing.position;\n}\n\nlet create_lexbuf ?(file=\"\") stream =\n  let pos = {Lexing.\n              pos_fname = file;\n              pos_lnum = 1;\n              pos_bol = 0;\n              pos_cnum = 0;\n            }\n  in {pos; stream}\n\nlet new_line ?(n=0) lexbuf =\n  let open Lexing in\n  let lcp = lexbuf.pos in\n  lexbuf.pos <-\n    {lcp with\n     pos_lnum = lcp.pos_lnum + 1;\n     pos_bol = lcp.pos_cnum;\n    }\n\nlet update lexbuf =\n  let new_pos = Sedlexing.lexeme_end lexbuf.stream in\n  let p = lexbuf.pos in\n  lexbuf.pos <- {p with Lexing.pos_cnum = new_pos}\n\nlet lexeme {stream} = Sedlexing.Utf8.lexeme stream\n\n(** [ParseError (file, line, col, token)] *)\nexception ParseError of (string * int * int * string)\n\nlet raise_ParseError lexbuf =\n  let {pos} = lexbuf in\n  let line = pos.pos_lnum in\n  let col = pos.pos_cnum - pos.pos_bol in\n  let tok = lexeme lexbuf in\n  raise @@ ParseError (pos.pos_fname, line, col, tok)\n\nlet string_of_ParseError (file, line, cnum, tok) =\n  let file_to_string file =\n    if file = \"\" then \"\"\n    else \" on file \" ^ file\n  in\n  Printf.sprintf\n    \"Parse error%s line %i, column %i, token %s\"\n    (file_to_string file)\n    line cnum tok\n\n(** Sedlex\u306e\u69cb\u6587\u306b\u5f93\u3063\u3066\u30c8\u30fc\u30af\u30f3\u8868\u73fe\u3092\u5b9a\u7fa9 *)\n(** \u6570\u5b571\u6587\u5b57\u306b\u30de\u30c3\u30c1 *)\nlet exp_digit = [%sedlex.regexp? '0'..'9']\n(** \u8b58\u5225\u5b50\u306e\u5148\u982d\u6587\u5b57 *)\nlet exp_initial = [%sedlex.regexp? alphabetic | Chars \"!#$%&=-+*<>?/\" | lu | ll | lt | lm | lo | nl]\n(** \u8b58\u5225\u5b50\u306e\u5148\u982d\u4ee5\u964d\u306e\u6587\u5b57 *)\nlet exp_rest = [%sedlex.regexp? exp_initial | mn | mc | pc | cf | '.' | exp_digit]\n(** Symbol\u306e\u30c8\u30fc\u30af\u30f3\u8868\u73fe *)\nlet exp_symbol = [%sedlex.regexp? exp_initial, Star exp_rest]\n(** Integer\u306e\u30c8\u30fc\u30af\u30f3\u8868\u73fe *)\nlet exp_integer = [%sedlex.regexp? (Opt (Chars \"+-\")), Plus exp_digit]\n(** Float\u306e\u30c8\u30fc\u30af\u30f3\u8868\u73fe *)\nlet exp_float = [%sedlex.regexp? (Opt (Chars \"+-\")),\n                               ((Opt exp_digit, '.', exp_integer)\n                               | (Plus exp_digit, '.', Opt exp_integer))]\n(** String\u306e\u30c8\u30fc\u30af\u30f3\u8868\u73fe *)\nlet exp_string = [%sedlex.regexp? '\"', Star any, '\"']\n\n(** \u5b57\u53e5\u89e3\u6790 *)\nlet rec lex lexbuf =\n  let buf = lexbuf.stream in\n  match%sedlex buf with\n\n  (** \u6539\u884c *)\n  | '\\n' ->\n    update lexbuf; new_line lexbuf;\n    lex lexbuf\n\n  (** \u7a7a\u767d\u6587\u5b57 *)\n  | white_space ->\n    update lexbuf;\n    lex lexbuf\n\n  | 't' ->\n    update lexbuf;\n    Parser.T\n\n  | \"nil\" ->\n    update lexbuf;\n    Parser.Nil\n\n  | exp_integer ->\n    update lexbuf;\n    Parser.Integer (int_of_string @@ lexeme lexbuf)\n\n  | exp_float ->\n    update lexbuf;\n    Parser.Float (float_of_string @@ lexeme lexbuf)\n\n  | exp_string ->\n    update lexbuf;\n    Parser.String (lexeme lexbuf)\n\n  | exp_symbol ->\n    update lexbuf;\n    Parser.Symbol (lexeme lexbuf)\n\n  (** \u30b3\u30e1\u30f3\u30c8 *)\n  | ';', Star (Compl '\\n'), '\\n' ->\n    update lexbuf; new_line lexbuf;\n    lex lexbuf\n\n  | eof ->\n    update lexbuf;\n    Parser.Eof\n\n  | '(' -> update lexbuf; Parser.LParen\n  | ')' -> update lexbuf; Parser.RParen\n\n  | _ ->\n    update lexbuf;\n    raise_ParseError lexbuf\n\n\nlet parse f lexbuf =\n  let lexer () =\n    let ante_position = lexbuf.pos in\n    let token = lex lexbuf in\n    let post_position = lexbuf.pos\n    in (token, ante_position, post_position) in\n  let parser =\n    MenhirLib.Convert.Simplified.traditional2revised f\n  in\n  try\n    parser lexer\n  with\n  | Parser.Error\n  | Sedlexing.MalFormed\n  | Sedlexing.InvalidCodepoint _\n    -> raise_ParseError lexbuf\n\nlet parse_program lexbuf =\n  parse Parser.main lexbuf\n\n\nlet parse_statement lexbuf =\n  parse Parser.main_statement lexbuf\n\n\n\u7d9a\u3044\u3066\u5b57\u53e5\u89e3\u6790\u5668\u306e\u30a4\u30f3\u30bf\u30fc\u30d5\u30a7\u30fc\u30b9\u3092\u4f5c\u6210\u3002\n\nsrc/syntax.mli\ntype lexbuf\n\nval create_lexbuf:\n  ?file:string -> Sedlexing.lexbuf -> lexbuf\n\nval parse_program:\n  lexbuf -> Ast.statement list\n\nval parse_statement:\n  lexbuf -> Ast.statement option\n\n\nexception ParseError of (string * int * int * string)\n\nval string_of_ParseError: (string * int * int * string) -> string\n\n\n\u4ee5\u4e0a\u3067\u69cb\u6587\u89e3\u6790\u5668\u306e\u5b8c\u6210\u3002\n\n\u69cb\u6587\u6728\u3092\u51fa\u529b\n\u69cb\u6587\u89e3\u6790\u5668\u304c\u6b63\u3057\u304f\u69cb\u6587\u6728\u3092\u51fa\u529b\u3067\u304d\u308b\u304b\u8a66\u3057\u3066\u307f\u308b\u3002\n\u6a19\u6e96\u5165\u529b\u304b\u3089Lisp\u30b3\u30fc\u30c9\u3092\u53d7\u3051\u53d6\u3063\u3066\u3001\u69cb\u6587\u6728\u3092\u51fa\u529b\u3059\u308b\u30eb\u30fc\u30d7\u3092\u4f5c\u6210\u3059\u308b\u3002\n\nsrc/toplevel.ml\nlet rec main_loop () : unit =\n  Printf.printf \"ready> %!\";\n  match\n    let lexbuf = Syntax.create_lexbuf @@\n      Sedlexing.Utf8.from_channel stdin in\n    Syntax.parse_statement lexbuf\n  with\n  | Some statement -> begin\n      print_endline @@ Ast.show_statement statement;\n      main_loop ()\n    end\n\n  | exception Syntax.ParseError e -> begin\n      print_endline @@ Syntax.string_of_ParseError e;\n      main_loop ()\n    end\n\n  | None -> print_newline ()\n\n\n\u30e1\u30a4\u30f3\u30d5\u30a1\u30a4\u30eb\u304b\u3089\u3053\u306e\u30eb\u30fc\u30d7\u3092\u547c\u3073\u51fa\u3059\u3002\n\nsrc/main.ml\nlet main () =\n  Toplevel.main_loop ();;\n\nmain ()\n\n\n\u3053\u3053\u307e\u3067\u3067\u4e00\u65e6\u30d3\u30eb\u30c9\u3057\u3066\u5b9f\u884c\u3057\u3066\u307f\u305f\u3002\n$ ./main.native\nready> (cons \"Hello\" (cons 14 9))  \n(Ast.Sexp\n   [(Ast.Atom (Ast.Symbol \"cons\")); (Ast.Atom (Ast.String \"\\\"Hello\\\"\"));\n     (Ast.Sexp\n        [(Ast.Atom (Ast.Symbol \"cons\")); (Ast.Atom (Ast.Integer 14));\n          (Ast.Atom (Ast.Integer 9))])\n     ])\nready>\n\n\u3061\u3083\u3093\u3068\u30d1\u30fc\u30b9\u51fa\u6765\u3066\u3044\u308b\u3063\u307d\u3044\u3002\n\nLLVM\u30b3\u30fc\u30c9\u751f\u6210\n\u3053\u3053\u304b\u3089\u5b9f\u969b\u306bLLVM IR\u3092\u5410\u3051\u308b\u3088\u3046\u306b\u3057\u3066\u3044\u304f\u3002\n\u307e\u305a\u30b3\u30fc\u30c9\u751f\u6210\u90e8\u5206\u306e\u672c\u4f53\u3092\u4f5c\u6210\u3002\n\nsrc/codegen.ml\nopen Llvm\n\nexception Error of string\n\nlet context = global_context ()\nlet the_module = create_module context \"llclimp\"\nlet builder = builder context\nlet symbol_tbl:(string, llvalue) Hashtbl.t = Hashtbl.create 10\nlet bit_type = i1_type context\nlet integer_type = i32_type context\nlet address_type = i8_type context\nlet float_type = float_type context\nlet cell_type = named_struct_type context \"cell\";;\nstruct_set_body cell_type [|address_type; address_type|] false;\n\nlet rec codegen = function\n    Ast.Sexp vals ->\n    (try\n       let head = match (List.hd vals) with\n           Ast.Sexp sexp -> raise (Error \"Not implemented: Call the S-expression\")\n         | Ast.Atom atom -> atom\n       in\n       match head with\n         Ast.Symbol name ->\n         let args = Array.of_list (try List.tl vals with Failure \"tl\" -> []) in\n         let callee = match lookup_function name the_module with\n           | Some func -> func\n           | None -> raise (Error \"unknown function\")\n         in let params = params callee in\n         if Array.length params == Array.length args then () else\n           raise (Error \"incorrect # arguments passed\");\n         let args = Array.map codegen args in\n         build_call callee args \"calltmp\" builder\n       | _ -> raise (Error \"Expect any function\")\n     with\n       Failure \"hd\" -> const_int bit_type 0)\n  | Ast.Atom atom -> codegen_expr atom\n\nand codegen_expr = function\n  | Ast.Integer n -> const_int integer_type n\n  | Ast.Float n -> const_float float_type n\n  | Ast.String s -> const_string context s\n  | Ast.Nil -> const_int bit_type 0\n  | Ast.T -> const_int bit_type 1\n  | Ast.Symbol name ->\n    (try Hashtbl.find symbol_tbl name with\n     | Not_found -> raise (Error \"unknown symbol\"))\n  | _ -> raise (Error \"unknown symbol\")\n\n\n\u6b21\u306b\u3001\u69cb\u6587\u6728\u3068\u5171\u306bIR\u30b3\u30fc\u30c9\u3092\u51fa\u529b\u3059\u308b\u3088\u3046\u306b\u30e1\u30a4\u30f3\u30eb\u30fc\u30d7\u3092\u4fee\u6b63\u3002\n\nsrc/toplevel.ml\nopen Llvm\n\n(** \u4e2d\u7565 *)\n  | Some statement -> begin\n      print_endline @@ Ast.show_statement statement;\n      dump_value (Codegen.codegen statement);\n      main_loop ()\n    end\n\n(** \u7565 *)\n\n\n\u7d42\u4e86\u6642\u306b\u30b3\u30fc\u30c9\u5168\u4f53\u3092\u30c0\u30f3\u30d7\u3059\u308b\u3088\u3046\u306b\u30e1\u30a4\u30f3\u30d5\u30a1\u30a4\u30eb\u3092\u4fee\u6b63\u3002\n\nsrc/main.ml\nopen Llvm\n\nlet main () =\n  Toplevel.main_loop ();\n  dump_module Codegen.the_module;;\n\nmain ()\n\n\n\u3053\u3053\u307e\u3067\u3067\u30d3\u30eb\u30c9\u30fb\u5b9f\u884c\u3059\u308b\u3068\u3001\u30c7\u30fc\u30bf\u578b\u306b\u5bfe\u5fdc\u3057\u305f\u30b3\u30fc\u30c9\u304c\u51fa\u529b\u3055\u308c\u308b\u3002\n\u305f\u3060\u3057\u30b7\u30f3\u30dc\u30eb\u306f\u4f55\u3082\u5b9a\u7fa9\u3057\u3066\u3044\u306a\u3044\u305f\u3081\u3001\u30b7\u30f3\u30dc\u30eb\u3084S\u5f0f\u3067\u306f\u4f8b\u5916\u51e6\u7406\u3055\u308c\u3066\u5f37\u5236\u7d42\u4e86\u3059\u308b\u3002\n\ncons\u95a2\u6570\u306e\u5b9a\u7fa9\ncons\u3092\u5b9a\u7fa9\u3057\u3066\u307f\u308b\u3002\n\u30bb\u30eb\u69cb\u9020\u4f53\u578b\u306f\u5148\u307b\u3069\u5b9a\u7fa9\u3057\u305f\u306e\u3067\u3001\u5f15\u6570\u30922\u3064\u53d7\u3051\u53d6\u3063\u3066\u305d\u308c\u3092\u69cb\u9020\u4f53\u306b\u683c\u7d0d\u3057\u3066\u8fd4\u3059\u3088\u3046\u306b\u3059\u308b\u3002\n\u5f15\u6570\u306f\u30dd\u30a4\u30f3\u30bf\u30a2\u30c9\u30ec\u30b9(i8)\u3092\u60f3\u5b9a\u3057\u3066\u3044\u308b\u3002\n\u30d3\u30eb\u30c8\u30a4\u30f3\u95a2\u6570\u306f\u30e1\u30a4\u30f3\u30eb\u30fc\u30d7\u3088\u308a\u3082\u524d\u306b\u5b9a\u7fa9\u3055\u308c\u3066\u3044\u3066\u6b32\u3057\u3044\u306e\u3067\u3001codegen\u306e\u4e0a\u306b\u66f8\u304f\u3002\n\nsrc/codegen.ml\nlet arg_type = Array.make 2 address_type in\nlet ft = function_type cell_type arg_type in\nlet the_function = declare_function \"cons\" ft the_module in\nlet car = param the_function 0 in\nlet cdr = param the_function 1 in\nlet bb = append_block context \"entry\" the_function in\nposition_at_end bb builder;\ntry\n  let ret_val = const_named_struct cell_type [|car; cdr|] in\n  let _ = build_ret ret_val builder in\n  Llvm_analysis.assert_valid_function the_function;\nwith e->\n  delete_function the_function;\n  raise e;;\n\n\n\u3053\u308c\u3067\u5b9f\u884c\u3057\u3066\u307f\u308b\u3002\nready> (cons 1 2)\n(Ast.Sexp\n   [(Ast.Atom (Ast.Symbol \"cons\")); (Ast.Atom (Ast.Integer 1));\n     (Ast.Atom (Ast.Integer 2))])\n  %calltmp = call %cell @cons(i32 1, i32 2)\nready> \n; ModuleID = 'llclimp'\nsource_filename = \"llclimp\"\n\n%cell = type { i8*, i8* }\n\ndefine %cell @cons(i8*, i8*) {\nentry:\n  ret %cell { i8* %0, i8* %1 }\n  %calltmp = call %cell @cons(i32 1, i32 2)\n}\n\n\u305d\u308c\u3089\u3057\u3044\u95a2\u6570\u306f\u51fa\u529b\u3055\u308c\u305f\u3002\n\u3057\u304b\u3057\u30e6\u30fc\u30b6\u5165\u529b\u306b\u3088\u308b\u95a2\u6570\u547c\u3073\u51fa\u3057\u304c\u5909\u306a\u3068\u3053\u308d\u306b\u5165\u3063\u3066\u3057\u307e\u3063\u3066\u3044\u308b\u3002\n\u307e\u305f\u95a2\u6570\u547c\u3073\u51fa\u3057\u6642\u306b\u578b\u306e\u30c1\u30a7\u30c3\u30af\u3092\u884c\u3063\u3066\u3044\u306a\u3044\u305f\u3081\u3001\u5b9f\u969b\u306b\u306f\u52d5\u304b\u306a\u3044\u3067\u3042\u308d\u3046\u30b3\u30fc\u30c9\u304c\u51fa\u529b\u3055\u308c\u3066\u3044\u308b\u3002\n\u3053\u308c\u3089\u306e\u554f\u984c\u306f\u3072\u3068\u307e\u305a\u7f6e\u3044\u3066\u3001\u6b21\u306b\u9032\u3093\u3060\u3002\n\ncar\u95a2\u6570\u306e\u5b9a\u7fa9\ncons\u3067\u4f5c\u3063\u305f\u30bb\u30eb\u306e\u5148\u982d\u8981\u7d20\u3092\u53d6\u308a\u51fa\u305b\u308b\u3088\u3046\u306b\u3057\u305f\u3044\u3002\n\u5b9f\u969b\u306bcons\u3092\u5b9f\u884c\u3059\u308b\u305f\u3081\u306b\u306f\u3001\u5f15\u6570\u306b\u6e21\u3059\u5024\u306f\u5168\u3066\u5b9a\u6570\u3068\u3057\u3066\u4fdd\u6301\u3057\u3001\u305d\u306e\u53c2\u7167\u3092\u6e21\u305b\u308b\u3088\u3046\u306b\u3057\u306a\u3044\u3068\u3044\u3051\u306a\u3044\u3002\n\u3053\u308c\u306b\u3064\u3044\u3066\u306fcar\u3092\u5b9a\u7fa9\u3057\u3066\u304b\u3089\u5bfe\u51e6\u3059\u308b\u3064\u3082\u308a\u3060\u3063\u305f\u3002\ncons\u306e\u5b9a\u7fa9\u306e\u5f8c\u306b\u7d9a\u3044\u3066\u66f8\u304f\u3002\n\nsrc/codegen.ml\nlet arg_type = Array.make 1 cell_type in\nlet ft = function_type address_type arg_type in\nlet the_function = declare_function \"car\" ft the_module in\nlet cell = param the_function 0 in\nlet gep = build_struct_gep cell 0 \"gep\" builder in\nlet elm = build_load gep \"ret\" builder in\nlet bb = append_block context \"entry\" the_function in\nposition_at_end bb builder;\ntry\n  let ret_val = elm in\n  let _ = build_ret ret_val builder in\n  Llvm_analysis.assert_valid_function the_function;\nwith e->\n  delete_function the_function;\n  raise e\n\n\n\u5b9f\u884c\u3057\u3066\u307f\u308b\u3002\n[1]    12214 segmentation fault (core dumped)  ./main.native\n\n\u3053\u3053\u3067\u307e\u3055\u304b\u306e\u30bb\u30b0\u30e1\u30f3\u30c6\u30fc\u30b7\u30e7\u30f3\u30d5\u30a9\u30eb\u30c8\u3002\n\u3069\u3046\u3084\u3089build_struct_gep\u3092\u547c\u3073\u51fa\u3057\u3066\u308b\u90e8\u5206\u3067\u8d77\u304d\u3066\u3044\u308b\u3088\u3046\u3060\u3002\n\u3044\u308d\u3044\u308d\u8a66\u884c\u932f\u8aa4\u3057\u3066\u307f\u305f\u304c\u3001\u3069\u3046\u3084\u3063\u3066\u3082\u6d88\u305b\u306a\u304b\u3063\u305f\u3002\n\n\u554f\u984c\u306e\u6574\u7406\n\n\u30e6\u30fc\u30b6\u5165\u529b\u306b\u3088\u308b\u95a2\u6570\u547c\u3073\u51fa\u3057\u304c\u5909\u306a\u3068\u3053\u308d\u306b\u5165\u308b\n\u30e6\u30fc\u30b6\u5165\u529b\u306b\u79fb\u308b\u524d\u306bbuilder\u306e\u6307\u3057\u3066\u3044\u308b\u4f4d\u7f6e\u3092\u5909\u3048\u3066\u3084\u308c\u3070\u826f\u3055\u305d\u3046\u3002\u305f\u3060\u305d\u306e\u3084\u308a\u65b9\u304c\u5206\u304b\u3089\u306a\u3044\u3002\n=> \u30e6\u30fc\u30b6\u5165\u529b\u7528\u306e\u30d6\u30ed\u30c3\u30af\u3092\u4f5c\u6210\u3057position_at_end\u3067\u305d\u306e\u4f4d\u7f6e\u306b\u5408\u308f\u305b\u3066\u3084\u308c\u3070OK\u3002\n\n\u95a2\u6570\u547c\u3073\u51fa\u3057\u6642\u306b\u578b\u306e\u30c1\u30a7\u30c3\u30af\u3092\u884c\u3063\u3066\u3044\u306a\u3044\n\u5f15\u6570\u306f\u5168\u3066\u30dd\u30a4\u30f3\u30bf\u306b\u306a\u308b\u306f\u305a\u306a\u306e\u3067\u3001\u304a\u305d\u3089\u304f\u30c1\u30a7\u30c3\u30af\u3057\u306a\u304f\u3066\u3082\u5927\u4e08\u592b\uff1f\n=> \u5f15\u6570\u306b\u30dd\u30a4\u30f3\u30bf\u30a2\u30c9\u30ec\u30b9(i64)\u3092\u6e21\u3059\u3088\u3046\u306b\u3057\u305f\u305f\u3081\u3001\u5404\u95a2\u6570\u306e\u4e2d\u3067\u5143\u306e\u30dd\u30a4\u30f3\u30bf\u578b\u306b\u623b\u3057\u3066\u3084\u308b\u3002\n\n\u5024\u306f\u5168\u3066\u5b9a\u6570\u3068\u3057\u3066\u4fdd\u6301\u3059\u308b\ncodegen_expr\u3067\u5b9a\u6570\u3068\u3057\u3066\u4fdd\u6301\u3059\u308b\u3088\u3046\u306b\u3057\u3001\u30dd\u30a4\u30f3\u30bf\u3068\u3057\u3066\u8fd4\u3059\u3002LLVM\u306bdata segment\u306b\u76f8\u5f53\u3059\u308b\u3082\u306e\u306f\u3042\u308b\u306e\u304b\uff1f\n=> codegen_expr\u306e\u6642\u306b\u30b0\u30ed\u30fc\u30d0\u30eb\u5b9a\u6570\u3092\u4f5c\u308a\u3001\u305d\u306e\u5024\u3092\u305d\u306e\u307e\u307e\u6e21\u305b\u3070\u826f\u3044(\u52dd\u624b\u306b\u30dd\u30a4\u30f3\u30bf\u3068\u3057\u3066\u6271\u308f\u308c\u308b)\u3002\n\nbuild_struct_gep\u3067\u30bb\u30b0\u30e1\u30f3\u30c6\u30fc\u30b7\u30e7\u30f3\u30d5\u30a9\u30eb\u30c8\n\u305d\u3082\u305d\u3082\u539f\u56e0\u304c\u5206\u304b\u3089\u306a\u3044\u3002\n=> \u76f4\u63a5\u69cb\u9020\u4f53\u3092\u6e21\u3059\u306e\u3067\u306f\u306a\u304f\u3001\u30dd\u30a4\u30f3\u30bf\u3067\u30e9\u30c3\u30d7\u3057\u3066\u304b\u3089\u6e21\u3059\u3088\u3046\u306b\u3059\u308c\u3070\u3088\u3044\u3002\n\n\n2016/12/10 \u8ffd\u8a18\n\n\u958b\u767a\u306e\u7d9a\u304d\n\ncar\u95a2\u6570\u306e\u5b9a\u7fa9\u30ea\u30d9\u30f3\u30b8\n\u30b3\u30e1\u30f3\u30c8\u3088\u308a\u3001\n\ngdb\u3067\u30b9\u30bf\u30c3\u30af\u30c8\u30ec\u30fc\u30b9\u3092\u898b\u305f\u3068\u3053\u308d\u3001llvalue\u306b\u30dd\u30a4\u30f3\u30bf\u3092\u671f\u5f85\u3057\u3066\u3044\u308b\u3068\u3053\u308d\u306b\u30dd\u30a4\u30f3\u30bf\u3067\u306f\u306a\u3044\u751f\u306ecell_type\u3092\u6e21\u3057\u3066\u3044\u308b\u306e\u3067\u30a8\u30e9\u30fc\u306b\u306a\u3063\u3066\u307e\u3057\u305f\u3002\u30dd\u30a4\u30f3\u30bf\u578b\u3092\u53d7\u3051\u53d6\u308b\u3088\u3046\u306b\u3059\u308c\u3070\u89e3\u6c7a\u3057\u307e\u3059\u3002\n\n\u9802\u3044\u305f\u30b3\u30fc\u30c9\u3092\u53c2\u8003\u306b\u3001\u30b9\u30b3\u30fc\u30d7\u3092\u5207\u308a\u3064\u3064\u8a72\u5f53\u7b87\u6240\u3092\u66f8\u304d\u63db\u3048\u3066\u307f\u305f\u3089\u30bb\u30b0\u30e1\u30f3\u30c6\u30fc\u30b7\u30e7\u30f3\u30d5\u30a9\u30eb\u30c8\u304c\u6d88\u3048\u305f\uff01\n\u3068\u308a\u3042\u3048\u305a\u3001\u305d\u306e\u307e\u307e\u8cbc\u3089\u305b\u3066\u3044\u305f\u3060\u304d\u307e\u3059\u3002\n\nsrc/codegen.ml\n(* \u30b9\u30b3\u30fc\u30d7\u3092\u5207\u308b *)\nlet gen_cons a_module context =\n  let arg_type = Array.make 2 address_type in\n  let ft = function_type cell_type arg_type in\n  let the_function = declare_function \"cons\" ft a_module in\n  let car = param the_function 0 in\n  let cdr = param the_function 1 in\n  let bb = append_block context \"entry\" the_function in\n  position_at_end bb builder;\n  try\n    let ret_val = const_named_struct cell_type [|car; cdr|] in\n    let _ = build_ret ret_val builder in\n    Llvm_analysis.assert_valid_function the_function;\n  with e->\n    delete_function the_function;\n    raise e;;\n\nlet gen_car a_module context =\n  (* cell_type\u3067\u306f\u306a\u304fpointer_type cell_type\u306b\u3059\u308b *)\n  let arg_type = Array.make 1 (pointer_type cell_type) in\n  let ft = function_type address_type arg_type in\n  let the_function = declare_function \"car\" ft a_module in\n  let cell = param the_function 0 in\n  let bb = append_block context \"entry\" the_function in\n  position_at_end bb builder;\n  try\n    (* \u305d\u308c\u3063\u307d\u3044\u540d\u524d\u304c\u3042\u3063\u305f\u65b9\u304c\u5206\u304b\u308a\u3084\u3059\u3044 *)\n    let gep = build_struct_gep cell 0 \"cons\" builder in\n    let elm = build_load gep \"car\" builder in\n    let ret_val = elm in\n    let _ = build_ret ret_val builder in\n    Llvm_analysis.assert_valid_function the_function;\n  with e->\n    delete_function the_function;\n    raise e;;\n\n(* \u30e6\u30fc\u30b6\u5165\u529b\u7528\u306bmain\u95a2\u6570\u3082\u7528\u610f *)\nlet gen_main a_module context =\n  let arg_type = [||] in\n  let ft = function_type (void_type context) arg_type in\n  let main_function = declare_function \"main\" ft the_module in\n  let bb = append_block context \"entry\" main_function in\n  bb;;\n\ngen_cons the_module context;;\ngen_car the_module context;;\nlet main_bb = gen_main the_module context in\n    (* builder\u306e\u30dd\u30b8\u30b7\u30e7\u30f3\u3092main\u306b\u5408\u308f\u305b\u3066\u304a\u304f *)\n    position_at_end main_bb builder;;\n\n\n\u3053\u3053\u3067\u521d\u3081\u3066\u3001\u51fa\u529b\u3055\u308c\u305fLLVM IR\u3092\u52d5\u304b\u3057\u3066\u307f\u3088\u3046\u3068\u601d\u3044\u7acb\u3063\u305f\u3002\n$ ./main.native\nready> (car (cons 23 56))\n(Ast.Sexp\n   [(Ast.Atom (Ast.Symbol \"car\"));\n     (Ast.Sexp\n        [(Ast.Atom (Ast.Symbol \"cons\")); (Ast.Atom (Ast.Integer 23));\n          (Ast.Atom (Ast.Integer 56))])\n     ])\n  %calltmp1 = call void* @car(%cell %calltmp)\n\n\u6700\u7d42\u7684\u306b\u30c0\u30f3\u30d7\u3055\u308c\u305f\u30b3\u30fc\u30c9\u304c\u4ee5\u4e0b\u3002\n\ntest0.ll\n; ModuleID = 'llclimp'\nsource_filename = \"llclimp\"\n\n%cell = type { void*, void* }\n\ndefine %cell @cons(void*, void*) {\nentry:\n  ret %cell { void* %0, void* %1 }\n}\n\ndefine void* @car(%cell*) {\nentry:\n  %cons = getelementptr inbounds %cell, %cell* %0, i32 0, i32 0\n  %car = load void*, void** %cons\n  ret void* %car\n}\n\ndefine void @main() {\nentry:\n  %calltmp = call %cell @cons(i32 23, i32 56)\n  %calltmp1 = call void* @car(%cell %calltmp)\n}\n\n\n\u3053\u308c\u3092\u307e\u305aLLVM\u30d3\u30c3\u30c8\u30b3\u30fc\u30c9\u306b\u5909\u63db\u3059\u308b\u3002\n$ llvm-as test0.ll\nllvm-as: test0.ll:4:20: error: pointers to void are invalid - use i8* instead\n%cell = type { void*, void* }\n                               ^\n\n\u3068\u3001\u3053\u3053\u3067\u30a8\u30e9\u30fc\u3002void\u578b\u3078\u306e\u30dd\u30a4\u30f3\u30bf\u306f\u4f7f\u3048\u306a\u3044\u3089\u3057\u3044\u3002\n\u3068\u306a\u308b\u3068\u3001\u578b\u3092\u533a\u5225\u3057\u306a\u3044\u3067\u5024\u3092\u5165\u308c\u308b\u305f\u3081\u306b\u306f\u30dd\u30a4\u30f3\u30bf\u30a2\u30c9\u30ec\u30b9\u3092\u683c\u7d0d\u3057\u306a\u3051\u308c\u3070\u306a\u3089\u306a\u3044\u3002\n\u3053\u3053\u3067\u30dd\u30a4\u30f3\u30bf\u30a2\u30c9\u30ec\u30b9\u306e\u30b5\u30a4\u30ba\u3092\u8abf\u3079\u3066\u307f\u305f\u3068\u3053\u308d\u300132bit\u74b0\u5883\u3067\u306f4bytes\u300164bit\u74b0\u5883\u3067\u306f8bytes\u3068\u306a\u308b\u3089\u3057\u3044\u3002\n\u81ea\u5206\u306f64bit\u74b0\u5883\u306a\u306e\u3067\u3001address_type\u306e\u5b9a\u7fa9\u3092\u4ee5\u4e0b\u306e\u3088\u3046\u306b\u5909\u3048\u305f\u3002\n\nsrc/codegen.ml\nlet address_type = i64_type context\n\n\n\u3053\u308c\u3067\u5148\u307b\u3069\u3068\u540c\u3058\u3088\u3046\u306b\u3001\u51fa\u529b\u3055\u308c\u305fLLVM IR\u3092\u30d3\u30c3\u30c8\u30b3\u30fc\u30c9\u306b\u5909\u63db\u3059\u308b\u3002\n$ llvm-as test1.ll\nllvm-as: test1.ll:8:20: error: invalid use of function-local name\n  ret %cell { i64* %0, i64* %1 }\n                                ^\n\n\u4eca\u5ea6\u306fcons\u95a2\u6570\u306e\u5b9a\u7fa9\u5834\u6240\u3067\u30a8\u30e9\u30fc\u304c\u8d77\u304d\u305f\u3002\n\u5f15\u6570\u3092\u305d\u306e\u307e\u307e\u69cb\u9020\u4f53\u306e\u30e1\u30f3\u30d0\u3068\u3057\u3066\u3044\u308b\u306e\u304c\u99c4\u76ee\u305d\u3046\u3002\n\u3053\u3046\u3044\u3046\u6642\u306f\u5b9f\u969b\u306bC\u8a00\u8a9e\u306e\u30b3\u30fc\u30c9\u3092LLVM IR\u306b\u5909\u63db\u3057\u3066\u52d5\u304d\u3092\u898b\u3066\u307f\u308c\u3070\u826f\u3044\u3002\n\ntest.c\n#include <stdio.h>\n\nstruct cell{\n  int* car;\n  int* cdr;\n};\n\nint main() {\n  int a = 30;\n  int b = 50;\n  struct cell cons = {&a, &b};\n  return 0;\n}\n\n\n\u4e0a\u306e\u3088\u3046\u306aC\u8a00\u8a9e\u30b3\u30fc\u30c9\u3092\u66f8\u3044\u3066\u3001clang\u3092\u5229\u7528\u3057\u3066LLVM IR\u3092\u5410\u304b\u305b\u308b\u3002\n$ clang -c -S -emit-llvm test.c\n\n\u3059\u308b\u3068\u4ee5\u4e0b\u306e\u3088\u3046\u306a\u30b3\u30fc\u30c9\u304c\u51fa\u529b\u3055\u308c\u305f\u3002\n\ntest.ll(\u4e00\u90e8\u7565)\n%struct.cell = type { i32*, i32* }\n\n; Function Attrs: nounwind uwtable\ndefine i32 @main() #0 {\n  %1 = alloca i32, align 4\n  %2 = alloca i32, align 4\n  %3 = alloca i32, align 4\n  %4 = alloca %struct.cell, align 8\n  store i32 0, i32* %1, align 4\n  store i32 30, i32* %2, align 4\n  store i32 50, i32* %3, align 4\n  %5 = getelementptr inbounds %struct.cell, %struct.cell* %4, i32 0, i32 0\n  store i32* %2, i32** %5, align 8\n  %6 = getelementptr inbounds %struct.cell, %struct.cell* %4, i32 0, i32 1\n  store i32* %3, i32** %6, align 8\n  ret i32 0\n}\n\n\n\u3053\u308c\u3092\u898b\u308b\u3068\u3001\u307e\u305aalloca\u3067\u69cb\u9020\u4f53\u306e\u30e1\u30e2\u30ea\u3092\u78ba\u4fdd\u3057\u3001\u5404\u8981\u7d20\u3078\u306e\u30dd\u30a4\u30f3\u30bf\u7d4c\u7531\u3067\u5024\u3092store\u3057\u3066\u3044\u308b\u3002\n\u3053\u306e\u6642\u77e5\u3063\u305f\u306e\u3060\u304c\u3001constant\u306a\u5024\u306f\u52d5\u7684\u306b\u306f\u4f5c\u308c\u306a\u3044\u3088\u3046\u3060\u3002\u5f53\u7136\u3068\u3044\u3048\u3070\u5f53\u7136\u3067\u3042\u308b\u3002\nconst_*\u95a2\u6570\u306f\u30b0\u30ed\u30fc\u30d0\u30eb\u5909\u6570(\u5b9a\u6570)\u3092\u4f5c\u6210\u3059\u308b\u6642\u306b\u306e\u307f\u7528\u3044\u308b\u3089\u3057\u3044\u3002\n\u3068\u3044\u3046\u3053\u3068\u3067\u3001\u3053\u308c\u3092\u53c2\u8003\u306bcons\u95a2\u6570\u306e\u5b9a\u7fa9\u3092\u66f8\u304d\u63db\u3048\u305f\u3002\n\u540c\u6642\u306b\u8fd4\u308a\u5024\u3082\u3001\u30bb\u30eb\u306e\u30a2\u30c9\u30ec\u30b9\u3092\u8fd4\u3059\u3088\u3046\u306b\u5909\u66f4\u3057\u305f\u3002\n\nsrc/codegen.ml\nlet gen_cons a_module context =\n  let arg_type = Array.make 2 address_type in\n  let ft = function_type address_type arg_type in\n  let the_function = declare_function \"cons\" ft a_module in\n  (** p0 = &a *)\n  let p0 = param the_function 0 in\n  (** p1 = &b *)\n  let p1 = param the_function 1 in\n  let bb = append_block context \"entry\" the_function in\n  position_at_end bb builder;\n  try\n    (** struct cell *cell; *)\n    let cell = build_alloca cell_type \"cell\" builder in\n    (** cell->car = p0 *)\n    let car = build_struct_gep cell 0 \"car\" builder in\n    let _ = build_store p0 car builder in\n    (** cell->cdr = p1 *)\n    let cdr = build_struct_gep cell 1 \"cdr\" builder in\n    let _ = build_store p1 cdr builder in\n    (** return (i64_t)cell *)\n    let addr = build_ptrtoint cell address_type \"addr\" builder in\n    let ret_val = addr in\n    let _ = build_ret ret_val builder in\n    Llvm_analysis.assert_valid_function the_function;\n  with e->\n    delete_function the_function;\n    raise e;;\n\n\n\u3055\u3089\u306b\u3001\u3053\u308c\u306b\u5bfe\u5fdc\u3059\u308b\u5f62\u3067car\u95a2\u6570\u306e\u5b9a\u7fa9\u3082\u66f8\u304d\u63db\u3048\u305f\u3002\n\nsrc/codegen.ml\nlet gen_car a_module context =\n  (** cons\u30bb\u30eb\u3078\u306e\u30dd\u30a4\u30f3\u30bf\u30a2\u30c9\u30ec\u30b9\u3092\u53d7\u3051\u53d6\u308b *)\n  let arg_type = Array.make 1 address_type in\n  let ft = function_type address_type arg_type in\n  let the_function = declare_function \"car\" ft a_module in\n  let p0 = param the_function 0 in\n  let bb = append_block context \"entry\" the_function in\n  position_at_end bb builder;\n  try\n    (** \u30dd\u30a4\u30f3\u30bf\u30a2\u30c9\u30ec\u30b9\u3092cons\u30bb\u30eb\u306e\u30dd\u30a4\u30f3\u30bf\u306b\u5909\u63db *)\n    let ptr = build_inttoptr p0 (pointer_type cell_type) \"consptr\" builder in\n    let cons = build_struct_gep ptr 0 \"cons\" builder in\n    let car = build_load cons \"car\" builder in\n    let ret_val = car in\n    let _ = build_ret ret_val builder in\n    Llvm_analysis.assert_valid_function the_function;\n  with e->\n    delete_function the_function;\n    raise e\n\n\n\u305d\u3057\u3066\u30b3\u30fc\u30c9\u3092\u51fa\u529b\u3057\u3066\u5909\u63db\u2026\u306e\u524d\u306b\u3001codegen_expr\u3067\u30b0\u30ed\u30fc\u30d0\u30eb\u5b9a\u6570\u3092\u4f5c\u6210\u3059\u308b\u3088\u3046\u306b\u3059\u308b\u306e\u3092\u5fd8\u308c\u3066\u3044\u305f\u3002\n\u4ee5\u4e0b\u306e\u3088\u3046\u306b\u3001\u3072\u3068\u307e\u305aint\u3068float\u3060\u3051\u5b9a\u6570\u3092\u4f5c\u6210\u3059\u308b\u3088\u3046\u306b\u3057\u3001\u30dd\u30a4\u30f3\u30bf\u3092\u30a2\u30c9\u30ec\u30b9\u306b\u5909\u63db\u3055\u305b\u308b\u3002\n\nsrc/codegen.ml\nand codegen_expr = function\n  | Ast.Integer n -> build_ptrtoint (define_global \".int\" (const_int integer_type n) the_module) address_type \".intp\" builder\n  | Ast.Float n -> build_ptrtoint (define_global \".float\" (const_float float_type n) the_module) address_type \".floatp\" builder\n  | Ast.String s -> const_string context s\n  | Ast.Nil -> const_int bit_type 0\n  | Ast.T -> const_int bit_type 1\n  | Ast.Symbol name ->\n    (try Hashtbl.find symbol_tbl name with\n     | Not_found -> raise (Error \"unknown symbol\"))\n  | _ -> raise (Error \"unknown symbol\")\n\n\n\u3053\u3053\u307e\u3067\u3067\u30d3\u30eb\u30c9\u3057\u3066\u3001\u30b3\u30fc\u30c9\u3092\u51fa\u529b\u3055\u305b\u3066\u307f\u308b\u3002\n$ ./main.native\nready> (car (cons 30 50))\n\n\ntest2.ll\n; ModuleID = 'llclimp'\nsource_filename = \"llclimp\"\n\n%cell = type { i64, i64 }\n\n@.int = global i32 30\n@.int.1 = global i32 50\n\ndefine i64 @cons(i64, i64) {\nentry:\n  %cell = alloca %cell\n  %car = getelementptr inbounds %cell, %cell* %cell, i32 0, i32 0\n  store i64 %0, i64* %car\n  %cdr = getelementptr inbounds %cell, %cell* %cell, i32 0, i32 1\n  store i64 %1, i64* %cdr\n  %addr = ptrtoint %cell* %cell to i64\n  ret i64 %addr\n}\n\ndefine i64 @car(i64) {\nentry:\n  %consptr = inttoptr i64 %0 to %cell*\n  %cons = getelementptr inbounds %cell, %cell* %consptr, i32 0, i32 0\n  %car = load i64, i64* %cons\n  ret i64 %car\n}\n\ndefine void @main() {\nentry:\n  %calltmp = call i64 @cons(i64 ptrtoint (i32* @.int to i64), i64 ptrtoint (i32* @.int.1 to i64))\n  %calltmp1 = call i64 @car(i64 %calltmp)\n}\n\n\n\u305d\u3057\u3066\u30d3\u30c3\u30c8\u30b3\u30fc\u30c9\u306b\u5909\u63db\u3002\n$ llvm-as test2.ll\nllvm-as: test2.ll:32:1: error: expected instruction opcode\n}\n^\n\n\u3042\u3042\u3001main\u95a2\u6570\u306e\u4e2d\u3067return\u3059\u308b\u306e\u3092\u5fd8\u308c\u3066\u3044\u305f\u3002\n\u5834\u5f53\u305f\u308a\u7684\u306b\u3001\u305d\u306e\u307e\u307e\u76f4\u63a5\u4ed8\u3051\u8db3\u3057\u305f\u3002\n\ntest2.ll(main\u95a2\u6570\u306e\u307f\u629c\u7c8b)\ndefine void @main() {\nentry:\n  %calltmp = call i64 @cons(i64 ptrtoint (i32* @.int to i64), i64 ptrtoint (i32* @.int.1 to i64))\n  %calltmp1 = call i64 @car(i64 %calltmp)\n  ret void\n}\n\n\n\u3053\u308c\u3092\u5909\u63db\u3059\u308b\u3068test2.bc\u304c\u51fa\u529b\u3055\u308c\u308b\u3002\n\u4ed8\u5c5e\u306eJIT\u30a4\u30f3\u30bf\u30fc\u30d7\u30ea\u30bf\u3067\u5b9f\u884c\u3057\u3066\u307f\u308b\u3002\n$ lli test2.bc  # \u4f55\u3082\u51fa\u529b\u3055\u308c\u306a\u3044\uff01\n\n\u4f55\u3082\u51fa\u529b\u3055\u308c\u306a\u3044\u306e\u304c\u6b63\u5e38\u306a\u52d5\u4f5c\u3060\u3002\n\u3057\u304b\u3057\u3053\u308c\u3067\u306f\u672c\u5f53\u306bcons\u3084\u3089car\u304c\u52d5\u4f5c\u3057\u3066\u3044\u308b\u306e\u304b\u5206\u304b\u3089\u306a\u3044\u306e\u3067\u3001car\u306e\u8fd4\u308a\u5024\u3060\u3051\u3067\u3082\u77e5\u308a\u305f\u3044\u3002\n\u3057\u304b\u3057car\u3067\u8fd4\u3063\u3066\u304f\u308b\u306e\u306f\u30dd\u30a4\u30f3\u30bf\u30a2\u30c9\u30ec\u30b9\u3060\u3002\u3053\u306e\u307e\u307e\u3067\u306f\u51fa\u529b\u51fa\u6765\u306a\u3044\u3002\n\nretint\u95a2\u6570\u306e\u5b9a\u7fa9\n\u30dd\u30a4\u30f3\u30bf\u306e\u4e2d\u8eab\u3092\u8868\u793a\u3059\u308b\u306e\u306bC\u306eputs\u95a2\u6570\u3084printf\u95a2\u6570\u3092\u5229\u7528\u3057\u3066\u3082\u826f\u3044\u306e\u3060\u304c\u3001\u5c11\u3057\u5927\u8888\u88df\u3060\u3002\n\u306a\u306e\u3067\u3001\u30dd\u30a4\u30f3\u30bf\u30a2\u30c9\u30ec\u30b9\u3092\u6e21\u3059\u3068\u305d\u306e\u5148\u306e\u5024\u3092\u8fd4\u3057\u3066\u304f\u308c\u308b\u95a2\u6570\u3092\u4f5c\u308a\u3001\u305d\u306e\u7d50\u679c\u3092main\u95a2\u6570\u306e\u8fd4\u308a\u5024\u306b\u3059\u308b\u3002\n\u305d\u3046\u3059\u308c\u3070\u30b7\u30a7\u30eb\u4e0a\u304b\u3089\u7d42\u4e86\u30b3\u30fc\u30c9\u3068\u3057\u3066\u5024\u3092\u77e5\u308b\u3053\u3068\u304c\u51fa\u6765\u308b\u3002\n\u4ee5\u4e0b\u306e\u3088\u3046\u306b\u5b9a\u7fa9\u3057\u305f\u3002\n\nsrc/codegen.ml\nlet gen_retint a_module context =\n  let arg_type = Array.make 1 address_type in\n  let ft = function_type integer_type arg_type in\n  let the_function = declare_function \"retint\" ft a_module in\n  let p0 = param the_function 0 in\n  let bb = append_block context \"entry\" the_function in\n  position_at_end bb builder;\n  try\n    let ptr = build_inttoptr p0 (pointer_type integer_type) \"vptr\" builder in\n    let v = build_load ptr \"v\" builder in\n    let ret_val = v in\n    let _ = build_ret ret_val builder in\n    Llvm_analysis.assert_valid_function the_function;\n  with e->\n    delete_function the_function;\n    raise e\n\n;;\n\n(** \u95a2\u6570\u306e\u767b\u9332\u3082\u5fd8\u308c\u305a\u306b\u884c\u3046 *)\ngen_retint the_module context;;\n\n\n\u3053\u308c\u3092\u4f7f\u3063\u3066\u4ee5\u4e0b\u306e\u3088\u3046\u306a\u30b3\u30fc\u30c9\u3092\u66f8\u3044\u305f\u3002\n$ ./main.native\nready> (retint (car (cons 30 50)))\n\n\ntest3.ll\n; ModuleID = 'llclimp'\nsource_filename = \"llclimp\"\n\n%cell = type { i64, i64 }\n\n@.int = global i32 30\n@.int.1 = global i32 50\n\ndefine i64 @cons(i64, i64) {\nentry:\n  %cell = alloca %cell\n  %car = getelementptr inbounds %cell, %cell* %cell, i32 0, i32 0\n  store i64 %0, i64* %car\n  %cdr = getelementptr inbounds %cell, %cell* %cell, i32 0, i32 1\n  store i64 %1, i64* %cdr\n  %addr = ptrtoint %cell* %cell to i64\n  ret i64 %addr\n}\n\ndefine i64 @car(i64) {\nentry:\n  %consptr = inttoptr i64 %0 to %cell*\n  %cons = getelementptr inbounds %cell, %cell* %consptr, i32 0, i32 0\n  %car = load i64, i64* %cons\n  ret i64 %car\n}\n\ndefine i32 @retint(i64) {\nentry:\n  %vptr = inttoptr i64 %0 to i32*\n  %v = load i32, i32* %vptr\n  ret i32 %v\n}\n\ndefine void @main() {\nentry:\n  %calltmp = call i64 @cons(i64 ptrtoint (i32* @.int to i64), i64 ptrtoint (i32* @.int.1 to i64))\n  %calltmp1 = call i64 @car(i64 %calltmp)\n  %calltmp2 = call i32 @retint(i64 %calltmp1)\n}\n\n\n\u305d\u3057\u3066main\u95a2\u6570\u306e\u578b\u3068\u672b\u5c3e\u3092\u66f8\u304d\u63db\u3048\u308b\u3002\n\ntest3.ll(main\u95a2\u6570\u306e\u307f\u629c\u7c8b)\ndefine i32 @main() {\nentry:\n  %calltmp = call i64 @cons(i64 ptrtoint (i32* @.int to i64), i64 ptrtoint (i32* @.int.1 to i64))\n  %calltmp1 = call i64 @car(i64 %calltmp)\n  %calltmp2 = call i32 @retint(i64 %calltmp1)\n  ret i32 %calltmp2\n}\n\n\n\u7d9a\u3051\u3066\u5909\u63db\u3001\u5b9f\u884c\u307e\u3067\u3057\u3066\u307f\u308b\u3002\n$ llvm-as test3.ll\n$ lli test3.bc\n$ echo $?\n30\n\ncons\u3067\u4f5c\u3063\u305f\u30bb\u30eb\u304b\u3089car\u3067\u5024\u304c\u53d6\u308a\u51fa\u305b\u305f\uff01\uff01\n\u9577\u3044\u9053\u306e\u308a\u3060\u3063\u305f\u304c\u3001\u3060\u3044\u3076\u76ee\u6a19\u307e\u3067\u8fd1\u4ed8\u3051\u305f\u6c17\u304c\u3059\u308b\u3002\n@blackenedgold\u3055\u3093\u3001\u3042\u308a\u304c\u3068\u3046\u3054\u3056\u3044\u307e\u3057\u305f\uff01\n\n\u8ab2\u984c\n\n\ncdr\u95a2\u6570\u306e\u5b9a\u7fa9\n\u56db\u5247\u6f14\u7b97+-*/\u95a2\u6570\u306e\u5b9a\u7fa9\n\u53ef\u5909\u9577\u5f15\u6570\u3078\u306e\u5bfe\u5fdc\n\u6a19\u6e96\u51fa\u529b\u3092\u51fa\u6765\u308b\u3088\u3046\u306b\u3059\u308b\u3053\u3068\n\n\u8a00\u8a9e\u5b9f\u88c5\u7d20\u4eba\u3067\u3059\u304c\u3001Lisp\u306eLLVM\u30d5\u30ed\u30f3\u30c8\u30a8\u30f3\u30c9\u3092\u4f5c\u308d\u3046\u3068\u3057\u305f\u8a18\u9332\u3092\u6b8b\u3057\u305f\u3044\u3068\u601d\u3044\u307e\u3059\u3002\n\u9014\u4e2d\u3067\u884c\u304d\u8a70\u307e\u3063\u3066\u3057\u307e\u3063\u305f\u306e\u3067\u3001\u307e\u305f\u9032\u5c55\u304c\u3042\u308c\u3070\u968f\u6642\u66f4\u65b0\u3057\u3066\u3044\u304d\u307e\u3059\u3002\n\n2016/12/10 23:55 \u8ffd\u8a18\u3057\u307e\u3057\u305f\u3002`car`\u3067\u5024\u304c\u53d6\u308a\u51fa\u305b\u308b\u3088\u3046\u306b\u3002\n\n## \u76ee\u6a19\n`cons`\u30fb`car`\u30fb`cdr`\u3068\u56db\u5247\u6f14\u7b97`+-*/`\u3092\u7528\u3044\u305fLisp\u30b3\u30fc\u30c9\u3092LLVM IR\u306b\u5909\u63db\u3059\u308b\u3002\n\n## \u74b0\u5883\n* OCaml 4.03.0\n* oasis 0.4.7\n* llvm 3.9\n* sedlex 1.99.3\n* menhir 20160825\n* ppx_deriving 4.1\n\n## \u958b\u767a\u306e\u6d41\u308c\n\n\u5168\u4f53\u7684\u306b[\u3053\u3053](https://github.com/Drup/llvm/tree/3c43000f4e86af5b9b368f50721604957d403750/test/Bindings/OCaml/kaleidoscope)\u3092\u53c2\u8003\u306b\u3057\u3066\u9032\u3081\u305f\u3002\n\n### \u30d3\u30eb\u30c9\u30c4\u30fc\u30eb\u306e\u30bb\u30c3\u30c8\u30a2\u30c3\u30d7\n\u958b\u767a\u30c7\u30a3\u30ec\u30af\u30c8\u30ea\u76f4\u4e0b\u306b`src`\u30c7\u30a3\u30ec\u30af\u30c8\u30ea\u3068`_oasis`\u30d5\u30a1\u30a4\u30eb\u3092\u4f5c\u6210\u3002\n\n```:_oasis\nOASISFormat: 0.4\nName:        Llclimp\nVersion:     0.1.0\nSynopsis:    LLVM Common Lisp Implementation.\nAuthors:     Tamamu\nLicense:     MIT\nPlugins:     META (0.4)\n\nBuildTools: ocamlbuild\n\nLibrary llclimp\n  Path:       src\n  InternalModules: Parser\n  Modules: Ast, Syntax\n  CompiledObject: best\n  BuildDepends:\n    llvm, llvm.analysis, llvm.bitreader, sedlex, menhirLib, ppx_deriving.show\n\nExecutable llclimp\n  Path:       src\n  MainIs:     main.ml\n  CompiledObject: best\n  BuildDepends: llclimp\n```\n\n\u4ee5\u4e0b\u306e\u30b3\u30de\u30f3\u30c9\u3067\u30d3\u30eb\u30c9\u7528\u306e\u30b9\u30af\u30ea\u30d7\u30c8\u3092\u4f5c\u6210\u3002\n\n```bash\n$ oasis setup -setup-update dynamic\n```\n\n\u30d3\u30eb\u30c9\u3059\u308b\u6642\u306f\u3053\u3046\u3002\n\n```bash\n$ ocaml setup.ml -build -use-menhir\n```\n\n### \u69cb\u6587\u89e3\u6790\n\u307e\u305aparser\u3068lexer\u3092\u4f5c\u3063\u305f\u3002\n\u69cb\u6587\u6728\u306e\u305f\u3081\u306e\u30c7\u30fc\u30bf\u578b\u3092\u5b9a\u7fa9\u3059\u308b\u3002\n`[@@deriving show]`\u3067\u81ea\u52d5\u7684\u306b\u305d\u306e\u578b\u306eprinter\u304c\u4f5c\u3089\u308c\u308b\u3002\n\n```ocaml:src/ast.ml\ntype atom =\n  | Nil\n  | T\n  | Integer of int\n  | Float of float\n  | String of string\n  | Symbol of string\n[@@deriving show]\n\ntype statement =\n  |Sexp of statement list\n  |Atom of atom\n[@@deriving show]\n```\n\n[menhir-example](https://github.com/derdon/menhir-example)\u3092\u53c2\u8003\u306bparser\u3092\u4f5c\u6210\u3002\n\n```ocaml:src/parser.mly\n%{ open Ast %}\n\n%token Nil\n%token T\n%token <string> Symbol\n%token <int> Integer\n%token <float> Float\n%token <string> String\n%token LParen RParen Eof\n\n%start main\n%type <Ast.statement list> main\n\n%start main_statement\n%type <Ast.statement option> main_statement\n\n%%\n\nmain:\n| statements = list(statement) Eof {statements}\n\nmain_statement:\n| statement = statement {Some statement}\n| Eof {None}\n\nstatement:\n| sexp=sexp {Sexp sexp}\n| atom=atom {Atom atom}\n\nsexp:\n| LParen statements=list(statement) RParen {statements}\n\natom:\n| Nil {Nil}\n| T {T}\n| i=Integer {Integer i}\n| f=Float {Float f}\n| str=String {String str}\n| sym=Symbol {Symbol sym}\n```\n\n\u6570\u5024\u578b\u4ee5\u5916\u306b\u3082t\u3084\u6587\u5b57\u5217\u578b\u3092\u5b9a\u7fa9\u3057\u3066\u3044\u308b\u304c\u3001\u4eca\u56de\u306f\u4f7f\u308f\u306a\u3044\u306e\u3067\u7121\u8996\u3057\u3066\u3082\u3088\u3044\u3002\n\n\u6b21\u306b\u5b57\u53e5\u89e3\u6790\u5668\u3092\u4f5c\u3063\u3066\u3044\u304f\u3002\n\u30c8\u30fc\u30af\u30f3\u5316\u306e\u90e8\u5206\u3092\u5909\u3048\u305f\u3060\u3051\u3067\u3001\u307b\u3068\u3093\u3069\u53c2\u8003\u5148\u3092\u5199\u7d4c\u3057\u305f\u306b\u904e\u304e\u306a\u3044\u3002\nsedlex\u306e\u6b63\u898f\u8868\u73fe\u306e\u66f8\u304d\u65b9\u306fGithub\u306e\u30da\u30fc\u30b8\u306b\u66f8\u3044\u3066\u3042\u308b\u3082\u306e\u3092\u53c2\u8003\u306b\u3057\u305f\u3002\n<https://github.com/alainfrisch/sedlex>\n\u307e\u305f\u8b58\u5225\u5b50\u540d\u306b\u4f7f\u3048\u308b\u6587\u5b57\u306f\u4ee5\u4e0b\u306e\u30da\u30fc\u30b8\u3092\u53c2\u8003\u306b\u3001C#\u306e\u3082\u306e\u3092\u771f\u4f3c\u3057\u3066\u307f\u305f\u3002\n<http://ufcpp.net/study/csharp/misc_identifier.html>\n\n```ocaml:src/syntax.ml\ntype lexbuf = {\n  stream: Sedlexing.lexbuf;\n  mutable pos: Lexing.position;\n}\n\nlet create_lexbuf ?(file=\"\") stream =\n  let pos = {Lexing.\n              pos_fname = file;\n              pos_lnum = 1;\n              pos_bol = 0;\n              pos_cnum = 0;\n            }\n  in {pos; stream}\n\nlet new_line ?(n=0) lexbuf =\n  let open Lexing in\n  let lcp = lexbuf.pos in\n  lexbuf.pos <-\n    {lcp with\n     pos_lnum = lcp.pos_lnum + 1;\n     pos_bol = lcp.pos_cnum;\n    }\n\nlet update lexbuf =\n  let new_pos = Sedlexing.lexeme_end lexbuf.stream in\n  let p = lexbuf.pos in\n  lexbuf.pos <- {p with Lexing.pos_cnum = new_pos}\n\nlet lexeme {stream} = Sedlexing.Utf8.lexeme stream\n\n(** [ParseError (file, line, col, token)] *)\nexception ParseError of (string * int * int * string)\n\nlet raise_ParseError lexbuf =\n  let {pos} = lexbuf in\n  let line = pos.pos_lnum in\n  let col = pos.pos_cnum - pos.pos_bol in\n  let tok = lexeme lexbuf in\n  raise @@ ParseError (pos.pos_fname, line, col, tok)\n\nlet string_of_ParseError (file, line, cnum, tok) =\n  let file_to_string file =\n    if file = \"\" then \"\"\n    else \" on file \" ^ file\n  in\n  Printf.sprintf\n    \"Parse error%s line %i, column %i, token %s\"\n    (file_to_string file)\n    line cnum tok\n\n(** Sedlex\u306e\u69cb\u6587\u306b\u5f93\u3063\u3066\u30c8\u30fc\u30af\u30f3\u8868\u73fe\u3092\u5b9a\u7fa9 *)\n(** \u6570\u5b571\u6587\u5b57\u306b\u30de\u30c3\u30c1 *)\nlet exp_digit = [%sedlex.regexp? '0'..'9']\n(** \u8b58\u5225\u5b50\u306e\u5148\u982d\u6587\u5b57 *)\nlet exp_initial = [%sedlex.regexp? alphabetic | Chars \"!#$%&=-+*<>?/\" | lu | ll | lt | lm | lo | nl]\n(** \u8b58\u5225\u5b50\u306e\u5148\u982d\u4ee5\u964d\u306e\u6587\u5b57 *)\nlet exp_rest = [%sedlex.regexp? exp_initial | mn | mc | pc | cf | '.' | exp_digit]\n(** Symbol\u306e\u30c8\u30fc\u30af\u30f3\u8868\u73fe *)\nlet exp_symbol = [%sedlex.regexp? exp_initial, Star exp_rest]\n(** Integer\u306e\u30c8\u30fc\u30af\u30f3\u8868\u73fe *)\nlet exp_integer = [%sedlex.regexp? (Opt (Chars \"+-\")), Plus exp_digit]\n(** Float\u306e\u30c8\u30fc\u30af\u30f3\u8868\u73fe *)\nlet exp_float = [%sedlex.regexp? (Opt (Chars \"+-\")),\n                               ((Opt exp_digit, '.', exp_integer)\n                               | (Plus exp_digit, '.', Opt exp_integer))]\n(** String\u306e\u30c8\u30fc\u30af\u30f3\u8868\u73fe *)\nlet exp_string = [%sedlex.regexp? '\"', Star any, '\"']\n\n(** \u5b57\u53e5\u89e3\u6790 *)\nlet rec lex lexbuf =\n  let buf = lexbuf.stream in\n  match%sedlex buf with\n\n  (** \u6539\u884c *)\n  | '\\n' ->\n    update lexbuf; new_line lexbuf;\n    lex lexbuf\n\n  (** \u7a7a\u767d\u6587\u5b57 *)\n  | white_space ->\n    update lexbuf;\n    lex lexbuf\n\n  | 't' ->\n    update lexbuf;\n    Parser.T\n\n  | \"nil\" ->\n    update lexbuf;\n    Parser.Nil\n\n  | exp_integer ->\n    update lexbuf;\n    Parser.Integer (int_of_string @@ lexeme lexbuf)\n\n  | exp_float ->\n    update lexbuf;\n    Parser.Float (float_of_string @@ lexeme lexbuf)\n\n  | exp_string ->\n    update lexbuf;\n    Parser.String (lexeme lexbuf)\n\n  | exp_symbol ->\n    update lexbuf;\n    Parser.Symbol (lexeme lexbuf)\n\n  (** \u30b3\u30e1\u30f3\u30c8 *)\n  | ';', Star (Compl '\\n'), '\\n' ->\n    update lexbuf; new_line lexbuf;\n    lex lexbuf\n\n  | eof ->\n    update lexbuf;\n    Parser.Eof\n\n  | '(' -> update lexbuf; Parser.LParen\n  | ')' -> update lexbuf; Parser.RParen\n\n  | _ ->\n    update lexbuf;\n    raise_ParseError lexbuf\n\n\nlet parse f lexbuf =\n  let lexer () =\n    let ante_position = lexbuf.pos in\n    let token = lex lexbuf in\n    let post_position = lexbuf.pos\n    in (token, ante_position, post_position) in\n  let parser =\n    MenhirLib.Convert.Simplified.traditional2revised f\n  in\n  try\n    parser lexer\n  with\n  | Parser.Error\n  | Sedlexing.MalFormed\n  | Sedlexing.InvalidCodepoint _\n    -> raise_ParseError lexbuf\n\nlet parse_program lexbuf =\n  parse Parser.main lexbuf\n\n\nlet parse_statement lexbuf =\n  parse Parser.main_statement lexbuf\n```\n\n\u7d9a\u3044\u3066\u5b57\u53e5\u89e3\u6790\u5668\u306e\u30a4\u30f3\u30bf\u30fc\u30d5\u30a7\u30fc\u30b9\u3092\u4f5c\u6210\u3002\n\n```ocaml:src/syntax.mli\ntype lexbuf\n\nval create_lexbuf:\n  ?file:string -> Sedlexing.lexbuf -> lexbuf\n\nval parse_program:\n  lexbuf -> Ast.statement list\n\nval parse_statement:\n  lexbuf -> Ast.statement option\n\n\nexception ParseError of (string * int * int * string)\n\nval string_of_ParseError: (string * int * int * string) -> string\n```\n\n\u4ee5\u4e0a\u3067\u69cb\u6587\u89e3\u6790\u5668\u306e\u5b8c\u6210\u3002\n\n### \u69cb\u6587\u6728\u3092\u51fa\u529b\n\n\u69cb\u6587\u89e3\u6790\u5668\u304c\u6b63\u3057\u304f\u69cb\u6587\u6728\u3092\u51fa\u529b\u3067\u304d\u308b\u304b\u8a66\u3057\u3066\u307f\u308b\u3002\n\u6a19\u6e96\u5165\u529b\u304b\u3089Lisp\u30b3\u30fc\u30c9\u3092\u53d7\u3051\u53d6\u3063\u3066\u3001\u69cb\u6587\u6728\u3092\u51fa\u529b\u3059\u308b\u30eb\u30fc\u30d7\u3092\u4f5c\u6210\u3059\u308b\u3002\n\n```ocaml:src/toplevel.ml\nlet rec main_loop () : unit =\n  Printf.printf \"ready> %!\";\n  match\n    let lexbuf = Syntax.create_lexbuf @@\n      Sedlexing.Utf8.from_channel stdin in\n    Syntax.parse_statement lexbuf\n  with\n  | Some statement -> begin\n      print_endline @@ Ast.show_statement statement;\n      main_loop ()\n    end\n\n  | exception Syntax.ParseError e -> begin\n      print_endline @@ Syntax.string_of_ParseError e;\n      main_loop ()\n    end\n\n  | None -> print_newline ()\n```\n\n\u30e1\u30a4\u30f3\u30d5\u30a1\u30a4\u30eb\u304b\u3089\u3053\u306e\u30eb\u30fc\u30d7\u3092\u547c\u3073\u51fa\u3059\u3002\n\n```ocaml:src/main.ml\nlet main () =\n  Toplevel.main_loop ();;\n\nmain ()\n```\n\n\u3053\u3053\u307e\u3067\u3067\u4e00\u65e6\u30d3\u30eb\u30c9\u3057\u3066\u5b9f\u884c\u3057\u3066\u307f\u305f\u3002\n\n```bash\n$ ./main.native\nready> (cons \"Hello\" (cons 14 9))  \n(Ast.Sexp\n   [(Ast.Atom (Ast.Symbol \"cons\")); (Ast.Atom (Ast.String \"\\\"Hello\\\"\"));\n     (Ast.Sexp\n        [(Ast.Atom (Ast.Symbol \"cons\")); (Ast.Atom (Ast.Integer 14));\n          (Ast.Atom (Ast.Integer 9))])\n     ])\nready>\n```\n\n\u3061\u3083\u3093\u3068\u30d1\u30fc\u30b9\u51fa\u6765\u3066\u3044\u308b\u3063\u307d\u3044\u3002\n\n### LLVM\u30b3\u30fc\u30c9\u751f\u6210\n\n\u3053\u3053\u304b\u3089\u5b9f\u969b\u306bLLVM IR\u3092\u5410\u3051\u308b\u3088\u3046\u306b\u3057\u3066\u3044\u304f\u3002\n\u307e\u305a\u30b3\u30fc\u30c9\u751f\u6210\u90e8\u5206\u306e\u672c\u4f53\u3092\u4f5c\u6210\u3002\n\n```ocaml:src/codegen.ml\nopen Llvm\n\nexception Error of string\n\nlet context = global_context ()\nlet the_module = create_module context \"llclimp\"\nlet builder = builder context\nlet symbol_tbl:(string, llvalue) Hashtbl.t = Hashtbl.create 10\nlet bit_type = i1_type context\nlet integer_type = i32_type context\nlet address_type = i8_type context\nlet float_type = float_type context\nlet cell_type = named_struct_type context \"cell\";;\nstruct_set_body cell_type [|address_type; address_type|] false;\n\nlet rec codegen = function\n    Ast.Sexp vals ->\n    (try\n       let head = match (List.hd vals) with\n           Ast.Sexp sexp -> raise (Error \"Not implemented: Call the S-expression\")\n         | Ast.Atom atom -> atom\n       in\n       match head with\n         Ast.Symbol name ->\n         let args = Array.of_list (try List.tl vals with Failure \"tl\" -> []) in\n         let callee = match lookup_function name the_module with\n           | Some func -> func\n           | None -> raise (Error \"unknown function\")\n         in let params = params callee in\n         if Array.length params == Array.length args then () else\n           raise (Error \"incorrect # arguments passed\");\n         let args = Array.map codegen args in\n         build_call callee args \"calltmp\" builder\n       | _ -> raise (Error \"Expect any function\")\n     with\n       Failure \"hd\" -> const_int bit_type 0)\n  | Ast.Atom atom -> codegen_expr atom\n\nand codegen_expr = function\n  | Ast.Integer n -> const_int integer_type n\n  | Ast.Float n -> const_float float_type n\n  | Ast.String s -> const_string context s\n  | Ast.Nil -> const_int bit_type 0\n  | Ast.T -> const_int bit_type 1\n  | Ast.Symbol name ->\n    (try Hashtbl.find symbol_tbl name with\n     | Not_found -> raise (Error \"unknown symbol\"))\n  | _ -> raise (Error \"unknown symbol\")\n```\n\n\u6b21\u306b\u3001\u69cb\u6587\u6728\u3068\u5171\u306bIR\u30b3\u30fc\u30c9\u3092\u51fa\u529b\u3059\u308b\u3088\u3046\u306b\u30e1\u30a4\u30f3\u30eb\u30fc\u30d7\u3092\u4fee\u6b63\u3002\n\n```ocaml:src/toplevel.ml\nopen Llvm\n\n(** \u4e2d\u7565 *)\n  | Some statement -> begin\n      print_endline @@ Ast.show_statement statement;\n      dump_value (Codegen.codegen statement);\n      main_loop ()\n    end\n\n(** \u7565 *)\n```\n\n\u7d42\u4e86\u6642\u306b\u30b3\u30fc\u30c9\u5168\u4f53\u3092\u30c0\u30f3\u30d7\u3059\u308b\u3088\u3046\u306b\u30e1\u30a4\u30f3\u30d5\u30a1\u30a4\u30eb\u3092\u4fee\u6b63\u3002\n\n```ocaml:src/main.ml\nopen Llvm\n\nlet main () =\n  Toplevel.main_loop ();\n  dump_module Codegen.the_module;;\n\nmain ()\n```\n\n\u3053\u3053\u307e\u3067\u3067\u30d3\u30eb\u30c9\u30fb\u5b9f\u884c\u3059\u308b\u3068\u3001\u30c7\u30fc\u30bf\u578b\u306b\u5bfe\u5fdc\u3057\u305f\u30b3\u30fc\u30c9\u304c\u51fa\u529b\u3055\u308c\u308b\u3002\n\u305f\u3060\u3057\u30b7\u30f3\u30dc\u30eb\u306f\u4f55\u3082\u5b9a\u7fa9\u3057\u3066\u3044\u306a\u3044\u305f\u3081\u3001\u30b7\u30f3\u30dc\u30eb\u3084S\u5f0f\u3067\u306f\u4f8b\u5916\u51e6\u7406\u3055\u308c\u3066\u5f37\u5236\u7d42\u4e86\u3059\u308b\u3002\n\n### `cons`\u95a2\u6570\u306e\u5b9a\u7fa9\n`cons`\u3092\u5b9a\u7fa9\u3057\u3066\u307f\u308b\u3002\n\u30bb\u30eb\u69cb\u9020\u4f53\u578b\u306f\u5148\u307b\u3069\u5b9a\u7fa9\u3057\u305f\u306e\u3067\u3001\u5f15\u6570\u30922\u3064\u53d7\u3051\u53d6\u3063\u3066\u305d\u308c\u3092\u69cb\u9020\u4f53\u306b\u683c\u7d0d\u3057\u3066\u8fd4\u3059\u3088\u3046\u306b\u3059\u308b\u3002\n\u5f15\u6570\u306f\u30dd\u30a4\u30f3\u30bf\u30a2\u30c9\u30ec\u30b9(i8)\u3092\u60f3\u5b9a\u3057\u3066\u3044\u308b\u3002\n\n\u30d3\u30eb\u30c8\u30a4\u30f3\u95a2\u6570\u306f\u30e1\u30a4\u30f3\u30eb\u30fc\u30d7\u3088\u308a\u3082\u524d\u306b\u5b9a\u7fa9\u3055\u308c\u3066\u3044\u3066\u6b32\u3057\u3044\u306e\u3067\u3001`codegen`\u306e\u4e0a\u306b\u66f8\u304f\u3002\n\n```ocaml:src/codegen.ml\nlet arg_type = Array.make 2 address_type in\nlet ft = function_type cell_type arg_type in\nlet the_function = declare_function \"cons\" ft the_module in\nlet car = param the_function 0 in\nlet cdr = param the_function 1 in\nlet bb = append_block context \"entry\" the_function in\nposition_at_end bb builder;\ntry\n  let ret_val = const_named_struct cell_type [|car; cdr|] in\n  let _ = build_ret ret_val builder in\n  Llvm_analysis.assert_valid_function the_function;\nwith e->\n  delete_function the_function;\n  raise e;;\n```\n\n\u3053\u308c\u3067\u5b9f\u884c\u3057\u3066\u307f\u308b\u3002\n\n```\nready> (cons 1 2)\n(Ast.Sexp\n   [(Ast.Atom (Ast.Symbol \"cons\")); (Ast.Atom (Ast.Integer 1));\n     (Ast.Atom (Ast.Integer 2))])\n  %calltmp = call %cell @cons(i32 1, i32 2)\nready> \n; ModuleID = 'llclimp'\nsource_filename = \"llclimp\"\n\n%cell = type { i8*, i8* }\n\ndefine %cell @cons(i8*, i8*) {\nentry:\n  ret %cell { i8* %0, i8* %1 }\n  %calltmp = call %cell @cons(i32 1, i32 2)\n}\n```\n\n\u305d\u308c\u3089\u3057\u3044\u95a2\u6570\u306f\u51fa\u529b\u3055\u308c\u305f\u3002\n\u3057\u304b\u3057\u30e6\u30fc\u30b6\u5165\u529b\u306b\u3088\u308b\u95a2\u6570\u547c\u3073\u51fa\u3057\u304c\u5909\u306a\u3068\u3053\u308d\u306b\u5165\u3063\u3066\u3057\u307e\u3063\u3066\u3044\u308b\u3002\n\u307e\u305f\u95a2\u6570\u547c\u3073\u51fa\u3057\u6642\u306b\u578b\u306e\u30c1\u30a7\u30c3\u30af\u3092\u884c\u3063\u3066\u3044\u306a\u3044\u305f\u3081\u3001\u5b9f\u969b\u306b\u306f\u52d5\u304b\u306a\u3044\u3067\u3042\u308d\u3046\u30b3\u30fc\u30c9\u304c\u51fa\u529b\u3055\u308c\u3066\u3044\u308b\u3002\n\n\u3053\u308c\u3089\u306e\u554f\u984c\u306f\u3072\u3068\u307e\u305a\u7f6e\u3044\u3066\u3001\u6b21\u306b\u9032\u3093\u3060\u3002\n\n### `car`\u95a2\u6570\u306e\u5b9a\u7fa9\n`cons`\u3067\u4f5c\u3063\u305f\u30bb\u30eb\u306e\u5148\u982d\u8981\u7d20\u3092\u53d6\u308a\u51fa\u305b\u308b\u3088\u3046\u306b\u3057\u305f\u3044\u3002\n\u5b9f\u969b\u306b`cons`\u3092\u5b9f\u884c\u3059\u308b\u305f\u3081\u306b\u306f\u3001\u5f15\u6570\u306b\u6e21\u3059\u5024\u306f\u5168\u3066\u5b9a\u6570\u3068\u3057\u3066\u4fdd\u6301\u3057\u3001\u305d\u306e\u53c2\u7167\u3092\u6e21\u305b\u308b\u3088\u3046\u306b\u3057\u306a\u3044\u3068\u3044\u3051\u306a\u3044\u3002\n\u3053\u308c\u306b\u3064\u3044\u3066\u306f`car`\u3092\u5b9a\u7fa9\u3057\u3066\u304b\u3089\u5bfe\u51e6\u3059\u308b\u3064\u3082\u308a\u3060\u3063\u305f\u3002\n\n`cons`\u306e\u5b9a\u7fa9\u306e\u5f8c\u306b\u7d9a\u3044\u3066\u66f8\u304f\u3002\n\n```ocaml:src/codegen.ml\nlet arg_type = Array.make 1 cell_type in\nlet ft = function_type address_type arg_type in\nlet the_function = declare_function \"car\" ft the_module in\nlet cell = param the_function 0 in\nlet gep = build_struct_gep cell 0 \"gep\" builder in\nlet elm = build_load gep \"ret\" builder in\nlet bb = append_block context \"entry\" the_function in\nposition_at_end bb builder;\ntry\n  let ret_val = elm in\n  let _ = build_ret ret_val builder in\n  Llvm_analysis.assert_valid_function the_function;\nwith e->\n  delete_function the_function;\n  raise e\n```\n\n\u5b9f\u884c\u3057\u3066\u307f\u308b\u3002\n\n```\n[1]    12214 segmentation fault (core dumped)  ./main.native\n```\n\n\u3053\u3053\u3067\u307e\u3055\u304b\u306e\u30bb\u30b0\u30e1\u30f3\u30c6\u30fc\u30b7\u30e7\u30f3\u30d5\u30a9\u30eb\u30c8\u3002\n\u3069\u3046\u3084\u3089`build_struct_gep`\u3092\u547c\u3073\u51fa\u3057\u3066\u308b\u90e8\u5206\u3067\u8d77\u304d\u3066\u3044\u308b\u3088\u3046\u3060\u3002\n\u3044\u308d\u3044\u308d\u8a66\u884c\u932f\u8aa4\u3057\u3066\u307f\u305f\u304c\u3001\u3069\u3046\u3084\u3063\u3066\u3082\u6d88\u305b\u306a\u304b\u3063\u305f\u3002\n\n## \u554f\u984c\u306e\u6574\u7406\n\n* \u30e6\u30fc\u30b6\u5165\u529b\u306b\u3088\u308b\u95a2\u6570\u547c\u3073\u51fa\u3057\u304c\u5909\u306a\u3068\u3053\u308d\u306b\u5165\u308b  \n  ~~\u30e6\u30fc\u30b6\u5165\u529b\u306b\u79fb\u308b\u524d\u306bbuilder\u306e\u6307\u3057\u3066\u3044\u308b\u4f4d\u7f6e\u3092\u5909\u3048\u3066\u3084\u308c\u3070\u826f\u3055\u305d\u3046\u3002\u305f\u3060\u305d\u306e\u3084\u308a\u65b9\u304c\u5206\u304b\u3089\u306a\u3044\u3002~~  \n  => \u30e6\u30fc\u30b6\u5165\u529b\u7528\u306e\u30d6\u30ed\u30c3\u30af\u3092\u4f5c\u6210\u3057`position_at_end`\u3067\u305d\u306e\u4f4d\u7f6e\u306b\u5408\u308f\u305b\u3066\u3084\u308c\u3070OK\u3002  \n* \u95a2\u6570\u547c\u3073\u51fa\u3057\u6642\u306b\u578b\u306e\u30c1\u30a7\u30c3\u30af\u3092\u884c\u3063\u3066\u3044\u306a\u3044  \n  ~~\u5f15\u6570\u306f\u5168\u3066\u30dd\u30a4\u30f3\u30bf\u306b\u306a\u308b\u306f\u305a\u306a\u306e\u3067\u3001\u304a\u305d\u3089\u304f\u30c1\u30a7\u30c3\u30af\u3057\u306a\u304f\u3066\u3082\u5927\u4e08\u592b\uff1f~~  \n  => \u5f15\u6570\u306b\u30dd\u30a4\u30f3\u30bf\u30a2\u30c9\u30ec\u30b9(i64)\u3092\u6e21\u3059\u3088\u3046\u306b\u3057\u305f\u305f\u3081\u3001\u5404\u95a2\u6570\u306e\u4e2d\u3067\u5143\u306e\u30dd\u30a4\u30f3\u30bf\u578b\u306b\u623b\u3057\u3066\u3084\u308b\u3002  \n* \u5024\u306f\u5168\u3066\u5b9a\u6570\u3068\u3057\u3066\u4fdd\u6301\u3059\u308b  \n  ~~`codegen_expr`\u3067\u5b9a\u6570\u3068\u3057\u3066\u4fdd\u6301\u3059\u308b\u3088\u3046\u306b\u3057\u3001\u30dd\u30a4\u30f3\u30bf\u3068\u3057\u3066\u8fd4\u3059\u3002LLVM\u306bdata segment\u306b\u76f8\u5f53\u3059\u308b\u3082\u306e\u306f\u3042\u308b\u306e\u304b\uff1f~~  \n  => `codegen_expr`\u306e\u6642\u306b\u30b0\u30ed\u30fc\u30d0\u30eb\u5b9a\u6570\u3092\u4f5c\u308a\u3001\u305d\u306e\u5024\u3092\u305d\u306e\u307e\u307e\u6e21\u305b\u3070\u826f\u3044(\u52dd\u624b\u306b\u30dd\u30a4\u30f3\u30bf\u3068\u3057\u3066\u6271\u308f\u308c\u308b)\u3002\n* `build_struct_gep`\u3067\u30bb\u30b0\u30e1\u30f3\u30c6\u30fc\u30b7\u30e7\u30f3\u30d5\u30a9\u30eb\u30c8  \n  ~~\u305d\u3082\u305d\u3082\u539f\u56e0\u304c\u5206\u304b\u3089\u306a\u3044\u3002~~  \n  => \u76f4\u63a5\u69cb\u9020\u4f53\u3092\u6e21\u3059\u306e\u3067\u306f\u306a\u304f\u3001\u30dd\u30a4\u30f3\u30bf\u3067\u30e9\u30c3\u30d7\u3057\u3066\u304b\u3089\u6e21\u3059\u3088\u3046\u306b\u3059\u308c\u3070\u3088\u3044\u3002\n\n# 2016/12/10 \u8ffd\u8a18\n\n## \u958b\u767a\u306e\u7d9a\u304d\n\n### `car`\u95a2\u6570\u306e\u5b9a\u7fa9\u30ea\u30d9\u30f3\u30b8\n\u30b3\u30e1\u30f3\u30c8\u3088\u308a\u3001\n>gdb\u3067\u30b9\u30bf\u30c3\u30af\u30c8\u30ec\u30fc\u30b9\u3092\u898b\u305f\u3068\u3053\u308d\u3001llvalue\u306b\u30dd\u30a4\u30f3\u30bf\u3092\u671f\u5f85\u3057\u3066\u3044\u308b\u3068\u3053\u308d\u306b\u30dd\u30a4\u30f3\u30bf\u3067\u306f\u306a\u3044\u751f\u306ecell_type\u3092\u6e21\u3057\u3066\u3044\u308b\u306e\u3067\u30a8\u30e9\u30fc\u306b\u306a\u3063\u3066\u307e\u3057\u305f\u3002\u30dd\u30a4\u30f3\u30bf\u578b\u3092\u53d7\u3051\u53d6\u308b\u3088\u3046\u306b\u3059\u308c\u3070\u89e3\u6c7a\u3057\u307e\u3059\u3002\n\n\u9802\u3044\u305f\u30b3\u30fc\u30c9\u3092\u53c2\u8003\u306b\u3001\u30b9\u30b3\u30fc\u30d7\u3092\u5207\u308a\u3064\u3064\u8a72\u5f53\u7b87\u6240\u3092\u66f8\u304d\u63db\u3048\u3066\u307f\u305f\u3089\u30bb\u30b0\u30e1\u30f3\u30c6\u30fc\u30b7\u30e7\u30f3\u30d5\u30a9\u30eb\u30c8\u304c\u6d88\u3048\u305f\uff01\n\u3068\u308a\u3042\u3048\u305a\u3001\u305d\u306e\u307e\u307e\u8cbc\u3089\u305b\u3066\u3044\u305f\u3060\u304d\u307e\u3059\u3002\n\n```ocaml:src/codegen.ml\n(* \u30b9\u30b3\u30fc\u30d7\u3092\u5207\u308b *)\nlet gen_cons a_module context =\n  let arg_type = Array.make 2 address_type in\n  let ft = function_type cell_type arg_type in\n  let the_function = declare_function \"cons\" ft a_module in\n  let car = param the_function 0 in\n  let cdr = param the_function 1 in\n  let bb = append_block context \"entry\" the_function in\n  position_at_end bb builder;\n  try\n    let ret_val = const_named_struct cell_type [|car; cdr|] in\n    let _ = build_ret ret_val builder in\n    Llvm_analysis.assert_valid_function the_function;\n  with e->\n    delete_function the_function;\n    raise e;;\n\nlet gen_car a_module context =\n  (* cell_type\u3067\u306f\u306a\u304fpointer_type cell_type\u306b\u3059\u308b *)\n  let arg_type = Array.make 1 (pointer_type cell_type) in\n  let ft = function_type address_type arg_type in\n  let the_function = declare_function \"car\" ft a_module in\n  let cell = param the_function 0 in\n  let bb = append_block context \"entry\" the_function in\n  position_at_end bb builder;\n  try\n    (* \u305d\u308c\u3063\u307d\u3044\u540d\u524d\u304c\u3042\u3063\u305f\u65b9\u304c\u5206\u304b\u308a\u3084\u3059\u3044 *)\n    let gep = build_struct_gep cell 0 \"cons\" builder in\n    let elm = build_load gep \"car\" builder in\n    let ret_val = elm in\n    let _ = build_ret ret_val builder in\n    Llvm_analysis.assert_valid_function the_function;\n  with e->\n    delete_function the_function;\n    raise e;;\n\n(* \u30e6\u30fc\u30b6\u5165\u529b\u7528\u306bmain\u95a2\u6570\u3082\u7528\u610f *)\nlet gen_main a_module context =\n  let arg_type = [||] in\n  let ft = function_type (void_type context) arg_type in\n  let main_function = declare_function \"main\" ft the_module in\n  let bb = append_block context \"entry\" main_function in\n  bb;;\n\ngen_cons the_module context;;\ngen_car the_module context;;\nlet main_bb = gen_main the_module context in\n    (* builder\u306e\u30dd\u30b8\u30b7\u30e7\u30f3\u3092main\u306b\u5408\u308f\u305b\u3066\u304a\u304f *)\n    position_at_end main_bb builder;;\n```\n\n\u3053\u3053\u3067\u521d\u3081\u3066\u3001\u51fa\u529b\u3055\u308c\u305fLLVM IR\u3092\u52d5\u304b\u3057\u3066\u307f\u3088\u3046\u3068\u601d\u3044\u7acb\u3063\u305f\u3002\n\n```bash\n$ ./main.native\nready> (car (cons 23 56))\n(Ast.Sexp\n   [(Ast.Atom (Ast.Symbol \"car\"));\n     (Ast.Sexp\n        [(Ast.Atom (Ast.Symbol \"cons\")); (Ast.Atom (Ast.Integer 23));\n          (Ast.Atom (Ast.Integer 56))])\n     ])\n  %calltmp1 = call void* @car(%cell %calltmp)\n```\n\n\u6700\u7d42\u7684\u306b\u30c0\u30f3\u30d7\u3055\u308c\u305f\u30b3\u30fc\u30c9\u304c\u4ee5\u4e0b\u3002\n\n```llvm:test0.ll\n; ModuleID = 'llclimp'\nsource_filename = \"llclimp\"\n\n%cell = type { void*, void* }\n\ndefine %cell @cons(void*, void*) {\nentry:\n  ret %cell { void* %0, void* %1 }\n}\n\ndefine void* @car(%cell*) {\nentry:\n  %cons = getelementptr inbounds %cell, %cell* %0, i32 0, i32 0\n  %car = load void*, void** %cons\n  ret void* %car\n}\n\ndefine void @main() {\nentry:\n  %calltmp = call %cell @cons(i32 23, i32 56)\n  %calltmp1 = call void* @car(%cell %calltmp)\n}\n```\n\n\u3053\u308c\u3092\u307e\u305aLLVM\u30d3\u30c3\u30c8\u30b3\u30fc\u30c9\u306b\u5909\u63db\u3059\u308b\u3002\n\n```bash\n$ llvm-as test0.ll\nllvm-as: test0.ll:4:20: error: pointers to void are invalid - use i8* instead\n%cell = type { void*, void* }\n                               ^\n```\n\n\u3068\u3001\u3053\u3053\u3067\u30a8\u30e9\u30fc\u3002void\u578b\u3078\u306e\u30dd\u30a4\u30f3\u30bf\u306f\u4f7f\u3048\u306a\u3044\u3089\u3057\u3044\u3002\n\u3068\u306a\u308b\u3068\u3001\u578b\u3092\u533a\u5225\u3057\u306a\u3044\u3067\u5024\u3092\u5165\u308c\u308b\u305f\u3081\u306b\u306f\u30dd\u30a4\u30f3\u30bf\u30a2\u30c9\u30ec\u30b9\u3092\u683c\u7d0d\u3057\u306a\u3051\u308c\u3070\u306a\u3089\u306a\u3044\u3002\n\u3053\u3053\u3067\u30dd\u30a4\u30f3\u30bf\u30a2\u30c9\u30ec\u30b9\u306e\u30b5\u30a4\u30ba\u3092\u8abf\u3079\u3066\u307f\u305f\u3068\u3053\u308d\u300132bit\u74b0\u5883\u3067\u306f4bytes\u300164bit\u74b0\u5883\u3067\u306f8bytes\u3068\u306a\u308b\u3089\u3057\u3044\u3002\n\u81ea\u5206\u306f64bit\u74b0\u5883\u306a\u306e\u3067\u3001`address_type`\u306e\u5b9a\u7fa9\u3092\u4ee5\u4e0b\u306e\u3088\u3046\u306b\u5909\u3048\u305f\u3002\n\n```ocaml:src/codegen.ml\nlet address_type = i64_type context\n```\n\n\u3053\u308c\u3067\u5148\u307b\u3069\u3068\u540c\u3058\u3088\u3046\u306b\u3001\u51fa\u529b\u3055\u308c\u305fLLVM IR\u3092\u30d3\u30c3\u30c8\u30b3\u30fc\u30c9\u306b\u5909\u63db\u3059\u308b\u3002\n\n```bash\n$ llvm-as test1.ll\nllvm-as: test1.ll:8:20: error: invalid use of function-local name\n  ret %cell { i64* %0, i64* %1 }\n                                ^\n```\n\n\u4eca\u5ea6\u306f`cons`\u95a2\u6570\u306e\u5b9a\u7fa9\u5834\u6240\u3067\u30a8\u30e9\u30fc\u304c\u8d77\u304d\u305f\u3002\n\u5f15\u6570\u3092\u305d\u306e\u307e\u307e\u69cb\u9020\u4f53\u306e\u30e1\u30f3\u30d0\u3068\u3057\u3066\u3044\u308b\u306e\u304c\u99c4\u76ee\u305d\u3046\u3002\n\u3053\u3046\u3044\u3046\u6642\u306f\u5b9f\u969b\u306bC\u8a00\u8a9e\u306e\u30b3\u30fc\u30c9\u3092LLVM IR\u306b\u5909\u63db\u3057\u3066\u52d5\u304d\u3092\u898b\u3066\u307f\u308c\u3070\u826f\u3044\u3002\n\n```c:test.c\n#include <stdio.h>\n\nstruct cell{\n  int* car;\n  int* cdr;\n};\n\nint main() {\n  int a = 30;\n  int b = 50;\n  struct cell cons = {&a, &b};\n  return 0;\n}\n```\n\n\u4e0a\u306e\u3088\u3046\u306aC\u8a00\u8a9e\u30b3\u30fc\u30c9\u3092\u66f8\u3044\u3066\u3001clang\u3092\u5229\u7528\u3057\u3066LLVM IR\u3092\u5410\u304b\u305b\u308b\u3002\n\n```bash\n$ clang -c -S -emit-llvm test.c\n```\n\n\u3059\u308b\u3068\u4ee5\u4e0b\u306e\u3088\u3046\u306a\u30b3\u30fc\u30c9\u304c\u51fa\u529b\u3055\u308c\u305f\u3002\n\n```llvm:test.ll(\u4e00\u90e8\u7565)\n%struct.cell = type { i32*, i32* }\n\n; Function Attrs: nounwind uwtable\ndefine i32 @main() #0 {\n  %1 = alloca i32, align 4\n  %2 = alloca i32, align 4\n  %3 = alloca i32, align 4\n  %4 = alloca %struct.cell, align 8\n  store i32 0, i32* %1, align 4\n  store i32 30, i32* %2, align 4\n  store i32 50, i32* %3, align 4\n  %5 = getelementptr inbounds %struct.cell, %struct.cell* %4, i32 0, i32 0\n  store i32* %2, i32** %5, align 8\n  %6 = getelementptr inbounds %struct.cell, %struct.cell* %4, i32 0, i32 1\n  store i32* %3, i32** %6, align 8\n  ret i32 0\n}\n```\n\n\u3053\u308c\u3092\u898b\u308b\u3068\u3001\u307e\u305a`alloca`\u3067\u69cb\u9020\u4f53\u306e\u30e1\u30e2\u30ea\u3092\u78ba\u4fdd\u3057\u3001\u5404\u8981\u7d20\u3078\u306e\u30dd\u30a4\u30f3\u30bf\u7d4c\u7531\u3067\u5024\u3092`store`\u3057\u3066\u3044\u308b\u3002\n\u3053\u306e\u6642\u77e5\u3063\u305f\u306e\u3060\u304c\u3001constant\u306a\u5024\u306f\u52d5\u7684\u306b\u306f\u4f5c\u308c\u306a\u3044\u3088\u3046\u3060\u3002\u5f53\u7136\u3068\u3044\u3048\u3070\u5f53\u7136\u3067\u3042\u308b\u3002\n`const_*`\u95a2\u6570\u306f\u30b0\u30ed\u30fc\u30d0\u30eb\u5909\u6570(\u5b9a\u6570)\u3092\u4f5c\u6210\u3059\u308b\u6642\u306b\u306e\u307f\u7528\u3044\u308b\u3089\u3057\u3044\u3002\n\n\u3068\u3044\u3046\u3053\u3068\u3067\u3001\u3053\u308c\u3092\u53c2\u8003\u306b`cons`\u95a2\u6570\u306e\u5b9a\u7fa9\u3092\u66f8\u304d\u63db\u3048\u305f\u3002\n\u540c\u6642\u306b\u8fd4\u308a\u5024\u3082\u3001\u30bb\u30eb\u306e\u30a2\u30c9\u30ec\u30b9\u3092\u8fd4\u3059\u3088\u3046\u306b\u5909\u66f4\u3057\u305f\u3002\n\n```src/codegen.ml\nlet gen_cons a_module context =\n  let arg_type = Array.make 2 address_type in\n  let ft = function_type address_type arg_type in\n  let the_function = declare_function \"cons\" ft a_module in\n  (** p0 = &a *)\n  let p0 = param the_function 0 in\n  (** p1 = &b *)\n  let p1 = param the_function 1 in\n  let bb = append_block context \"entry\" the_function in\n  position_at_end bb builder;\n  try\n    (** struct cell *cell; *)\n    let cell = build_alloca cell_type \"cell\" builder in\n    (** cell->car = p0 *)\n    let car = build_struct_gep cell 0 \"car\" builder in\n    let _ = build_store p0 car builder in\n    (** cell->cdr = p1 *)\n    let cdr = build_struct_gep cell 1 \"cdr\" builder in\n    let _ = build_store p1 cdr builder in\n    (** return (i64_t)cell *)\n    let addr = build_ptrtoint cell address_type \"addr\" builder in\n    let ret_val = addr in\n    let _ = build_ret ret_val builder in\n    Llvm_analysis.assert_valid_function the_function;\n  with e->\n    delete_function the_function;\n    raise e;;\n```\n\n\u3055\u3089\u306b\u3001\u3053\u308c\u306b\u5bfe\u5fdc\u3059\u308b\u5f62\u3067`car`\u95a2\u6570\u306e\u5b9a\u7fa9\u3082\u66f8\u304d\u63db\u3048\u305f\u3002\n\n```src/codegen.ml\nlet gen_car a_module context =\n  (** cons\u30bb\u30eb\u3078\u306e\u30dd\u30a4\u30f3\u30bf\u30a2\u30c9\u30ec\u30b9\u3092\u53d7\u3051\u53d6\u308b *)\n  let arg_type = Array.make 1 address_type in\n  let ft = function_type address_type arg_type in\n  let the_function = declare_function \"car\" ft a_module in\n  let p0 = param the_function 0 in\n  let bb = append_block context \"entry\" the_function in\n  position_at_end bb builder;\n  try\n    (** \u30dd\u30a4\u30f3\u30bf\u30a2\u30c9\u30ec\u30b9\u3092cons\u30bb\u30eb\u306e\u30dd\u30a4\u30f3\u30bf\u306b\u5909\u63db *)\n    let ptr = build_inttoptr p0 (pointer_type cell_type) \"consptr\" builder in\n    let cons = build_struct_gep ptr 0 \"cons\" builder in\n    let car = build_load cons \"car\" builder in\n    let ret_val = car in\n    let _ = build_ret ret_val builder in\n    Llvm_analysis.assert_valid_function the_function;\n  with e->\n    delete_function the_function;\n    raise e\n```\n\n\u305d\u3057\u3066\u30b3\u30fc\u30c9\u3092\u51fa\u529b\u3057\u3066\u5909\u63db\u2026\u306e\u524d\u306b\u3001`codegen_expr`\u3067\u30b0\u30ed\u30fc\u30d0\u30eb\u5b9a\u6570\u3092\u4f5c\u6210\u3059\u308b\u3088\u3046\u306b\u3059\u308b\u306e\u3092\u5fd8\u308c\u3066\u3044\u305f\u3002\n\u4ee5\u4e0b\u306e\u3088\u3046\u306b\u3001\u3072\u3068\u307e\u305aint\u3068float\u3060\u3051\u5b9a\u6570\u3092\u4f5c\u6210\u3059\u308b\u3088\u3046\u306b\u3057\u3001\u30dd\u30a4\u30f3\u30bf\u3092\u30a2\u30c9\u30ec\u30b9\u306b\u5909\u63db\u3055\u305b\u308b\u3002\n\n```ocaml:src/codegen.ml\nand codegen_expr = function\n  | Ast.Integer n -> build_ptrtoint (define_global \".int\" (const_int integer_type n) the_module) address_type \".intp\" builder\n  | Ast.Float n -> build_ptrtoint (define_global \".float\" (const_float float_type n) the_module) address_type \".floatp\" builder\n  | Ast.String s -> const_string context s\n  | Ast.Nil -> const_int bit_type 0\n  | Ast.T -> const_int bit_type 1\n  | Ast.Symbol name ->\n    (try Hashtbl.find symbol_tbl name with\n     | Not_found -> raise (Error \"unknown symbol\"))\n  | _ -> raise (Error \"unknown symbol\")\n```\n\n\u3053\u3053\u307e\u3067\u3067\u30d3\u30eb\u30c9\u3057\u3066\u3001\u30b3\u30fc\u30c9\u3092\u51fa\u529b\u3055\u305b\u3066\u307f\u308b\u3002\n\n```bash\n$ ./main.native\nready> (car (cons 30 50))\n```\n\n```llvm:test2.ll\n; ModuleID = 'llclimp'\nsource_filename = \"llclimp\"\n\n%cell = type { i64, i64 }\n\n@.int = global i32 30\n@.int.1 = global i32 50\n\ndefine i64 @cons(i64, i64) {\nentry:\n  %cell = alloca %cell\n  %car = getelementptr inbounds %cell, %cell* %cell, i32 0, i32 0\n  store i64 %0, i64* %car\n  %cdr = getelementptr inbounds %cell, %cell* %cell, i32 0, i32 1\n  store i64 %1, i64* %cdr\n  %addr = ptrtoint %cell* %cell to i64\n  ret i64 %addr\n}\n\ndefine i64 @car(i64) {\nentry:\n  %consptr = inttoptr i64 %0 to %cell*\n  %cons = getelementptr inbounds %cell, %cell* %consptr, i32 0, i32 0\n  %car = load i64, i64* %cons\n  ret i64 %car\n}\n\ndefine void @main() {\nentry:\n  %calltmp = call i64 @cons(i64 ptrtoint (i32* @.int to i64), i64 ptrtoint (i32* @.int.1 to i64))\n  %calltmp1 = call i64 @car(i64 %calltmp)\n}\n```\n\n\u305d\u3057\u3066\u30d3\u30c3\u30c8\u30b3\u30fc\u30c9\u306b\u5909\u63db\u3002\n\n```bash\n$ llvm-as test2.ll\nllvm-as: test2.ll:32:1: error: expected instruction opcode\n}\n^\n```\n\n\u3042\u3042\u3001main\u95a2\u6570\u306e\u4e2d\u3067return\u3059\u308b\u306e\u3092\u5fd8\u308c\u3066\u3044\u305f\u3002\n\u5834\u5f53\u305f\u308a\u7684\u306b\u3001\u305d\u306e\u307e\u307e\u76f4\u63a5\u4ed8\u3051\u8db3\u3057\u305f\u3002\n\n```llvm:test2.ll(main\u95a2\u6570\u306e\u307f\u629c\u7c8b)\ndefine void @main() {\nentry:\n  %calltmp = call i64 @cons(i64 ptrtoint (i32* @.int to i64), i64 ptrtoint (i32* @.int.1 to i64))\n  %calltmp1 = call i64 @car(i64 %calltmp)\n  ret void\n}\n```\n\n\u3053\u308c\u3092\u5909\u63db\u3059\u308b\u3068`test2.bc`\u304c\u51fa\u529b\u3055\u308c\u308b\u3002\n\u4ed8\u5c5e\u306eJIT\u30a4\u30f3\u30bf\u30fc\u30d7\u30ea\u30bf\u3067\u5b9f\u884c\u3057\u3066\u307f\u308b\u3002\n\n```bash\n$ lli test2.bc  # \u4f55\u3082\u51fa\u529b\u3055\u308c\u306a\u3044\uff01\n```\n\n\u4f55\u3082\u51fa\u529b\u3055\u308c\u306a\u3044\u306e\u304c\u6b63\u5e38\u306a\u52d5\u4f5c\u3060\u3002\n\u3057\u304b\u3057\u3053\u308c\u3067\u306f\u672c\u5f53\u306b`cons`\u3084\u3089`car`\u304c\u52d5\u4f5c\u3057\u3066\u3044\u308b\u306e\u304b\u5206\u304b\u3089\u306a\u3044\u306e\u3067\u3001`car`\u306e\u8fd4\u308a\u5024\u3060\u3051\u3067\u3082\u77e5\u308a\u305f\u3044\u3002\n\u3057\u304b\u3057`car`\u3067\u8fd4\u3063\u3066\u304f\u308b\u306e\u306f\u30dd\u30a4\u30f3\u30bf\u30a2\u30c9\u30ec\u30b9\u3060\u3002\u3053\u306e\u307e\u307e\u3067\u306f\u51fa\u529b\u51fa\u6765\u306a\u3044\u3002\n\n### `retint`\u95a2\u6570\u306e\u5b9a\u7fa9\n\n\u30dd\u30a4\u30f3\u30bf\u306e\u4e2d\u8eab\u3092\u8868\u793a\u3059\u308b\u306e\u306bC\u306eputs\u95a2\u6570\u3084printf\u95a2\u6570\u3092\u5229\u7528\u3057\u3066\u3082\u826f\u3044\u306e\u3060\u304c\u3001\u5c11\u3057\u5927\u8888\u88df\u3060\u3002\n\u306a\u306e\u3067\u3001\u30dd\u30a4\u30f3\u30bf\u30a2\u30c9\u30ec\u30b9\u3092\u6e21\u3059\u3068\u305d\u306e\u5148\u306e\u5024\u3092\u8fd4\u3057\u3066\u304f\u308c\u308b\u95a2\u6570\u3092\u4f5c\u308a\u3001\u305d\u306e\u7d50\u679c\u3092main\u95a2\u6570\u306e\u8fd4\u308a\u5024\u306b\u3059\u308b\u3002\n\u305d\u3046\u3059\u308c\u3070\u30b7\u30a7\u30eb\u4e0a\u304b\u3089\u7d42\u4e86\u30b3\u30fc\u30c9\u3068\u3057\u3066\u5024\u3092\u77e5\u308b\u3053\u3068\u304c\u51fa\u6765\u308b\u3002\n\n\u4ee5\u4e0b\u306e\u3088\u3046\u306b\u5b9a\u7fa9\u3057\u305f\u3002\n\n```ocaml:src/codegen.ml\nlet gen_retint a_module context =\n  let arg_type = Array.make 1 address_type in\n  let ft = function_type integer_type arg_type in\n  let the_function = declare_function \"retint\" ft a_module in\n  let p0 = param the_function 0 in\n  let bb = append_block context \"entry\" the_function in\n  position_at_end bb builder;\n  try\n    let ptr = build_inttoptr p0 (pointer_type integer_type) \"vptr\" builder in\n    let v = build_load ptr \"v\" builder in\n    let ret_val = v in\n    let _ = build_ret ret_val builder in\n    Llvm_analysis.assert_valid_function the_function;\n  with e->\n    delete_function the_function;\n    raise e\n\n;;\n\n(** \u95a2\u6570\u306e\u767b\u9332\u3082\u5fd8\u308c\u305a\u306b\u884c\u3046 *)\ngen_retint the_module context;;\n```\n\n\u3053\u308c\u3092\u4f7f\u3063\u3066\u4ee5\u4e0b\u306e\u3088\u3046\u306a\u30b3\u30fc\u30c9\u3092\u66f8\u3044\u305f\u3002\n\n```bash\n$ ./main.native\nready> (retint (car (cons 30 50)))\n```\n\n```llvm:test3.ll\n; ModuleID = 'llclimp'\nsource_filename = \"llclimp\"\n\n%cell = type { i64, i64 }\n\n@.int = global i32 30\n@.int.1 = global i32 50\n\ndefine i64 @cons(i64, i64) {\nentry:\n  %cell = alloca %cell\n  %car = getelementptr inbounds %cell, %cell* %cell, i32 0, i32 0\n  store i64 %0, i64* %car\n  %cdr = getelementptr inbounds %cell, %cell* %cell, i32 0, i32 1\n  store i64 %1, i64* %cdr\n  %addr = ptrtoint %cell* %cell to i64\n  ret i64 %addr\n}\n\ndefine i64 @car(i64) {\nentry:\n  %consptr = inttoptr i64 %0 to %cell*\n  %cons = getelementptr inbounds %cell, %cell* %consptr, i32 0, i32 0\n  %car = load i64, i64* %cons\n  ret i64 %car\n}\n\ndefine i32 @retint(i64) {\nentry:\n  %vptr = inttoptr i64 %0 to i32*\n  %v = load i32, i32* %vptr\n  ret i32 %v\n}\n\ndefine void @main() {\nentry:\n  %calltmp = call i64 @cons(i64 ptrtoint (i32* @.int to i64), i64 ptrtoint (i32* @.int.1 to i64))\n  %calltmp1 = call i64 @car(i64 %calltmp)\n  %calltmp2 = call i32 @retint(i64 %calltmp1)\n}\n```\n\n\u305d\u3057\u3066main\u95a2\u6570\u306e\u578b\u3068\u672b\u5c3e\u3092\u66f8\u304d\u63db\u3048\u308b\u3002\n\n```llvm:test3.ll(main\u95a2\u6570\u306e\u307f\u629c\u7c8b)\ndefine i32 @main() {\nentry:\n  %calltmp = call i64 @cons(i64 ptrtoint (i32* @.int to i64), i64 ptrtoint (i32* @.int.1 to i64))\n  %calltmp1 = call i64 @car(i64 %calltmp)\n  %calltmp2 = call i32 @retint(i64 %calltmp1)\n  ret i32 %calltmp2\n}\n```\n\n\u7d9a\u3051\u3066\u5909\u63db\u3001\u5b9f\u884c\u307e\u3067\u3057\u3066\u307f\u308b\u3002\n\n```bash\n$ llvm-as test3.ll\n$ lli test3.bc\n$ echo $?\n30\n```\n\n`cons`\u3067\u4f5c\u3063\u305f\u30bb\u30eb\u304b\u3089`car`\u3067\u5024\u304c\u53d6\u308a\u51fa\u305b\u305f\uff01\uff01\n\u9577\u3044\u9053\u306e\u308a\u3060\u3063\u305f\u304c\u3001\u3060\u3044\u3076\u76ee\u6a19\u307e\u3067\u8fd1\u4ed8\u3051\u305f\u6c17\u304c\u3059\u308b\u3002\n\n@blackenedgold\u3055\u3093\u3001\u3042\u308a\u304c\u3068\u3046\u3054\u3056\u3044\u307e\u3057\u305f\uff01\n\n## \u8ab2\u984c\n\n* `cdr`\u95a2\u6570\u306e\u5b9a\u7fa9\n* \u56db\u5247\u6f14\u7b97`+-*/`\u95a2\u6570\u306e\u5b9a\u7fa9\n* \u53ef\u5909\u9577\u5f15\u6570\u3078\u306e\u5bfe\u5fdc\n* \u6a19\u6e96\u51fa\u529b\u3092\u51fa\u6765\u308b\u3088\u3046\u306b\u3059\u308b\u3053\u3068\n", "tags": ["OCaml", "LLVM", "lisp"]}