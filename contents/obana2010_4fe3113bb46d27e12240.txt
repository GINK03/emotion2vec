{"context": "\n\nThe Volatility Framework 2.5 Windows Core Command Reference\n\u30e1\u30e2\u30ea\u30d5\u30a9\u30ec\u30f3\u30b8\u30c3\u30af\u30c4\u30fc\u30eb\u306eVolatility Framework\u30b3\u30de\u30f3\u30c9\u30ea\u30d5\u30a1\u30ec\u30f3\u30b9\u306e\u65e5\u672c\u8a9e\u8a33\u3067\u3059\u3002Windows Core\u3001Windows Malware\u3001Windows GUI\u3068\u3044\u3046\u9806\u756a\u3067\u7ffb\u8a33\u3059\u308b\u4e88\u5b9a\u3067\u3059\u3002(\u6c17\u529b\u304c\u7d9a\u3051\u3070)\n\nImage Identification\n\nimageinfo\n\nFor a high level summary of the memory sample you're analyzing, use the imageinfo command. Most often this command is used to identify the operating system, service pack, and hardware architecture (32 or 64 bit), but it also contains other useful information such as the DTB address and time the sample was collected.\n\nimageinfo\u30b3\u30de\u30f3\u30c9\u3067\u89e3\u6790\u3059\u308b\u30e1\u30e2\u30ea\u30b5\u30f3\u30d7\u30eb\u306e\u6982\u8981\u304c\u5206\u304b\u308a\u307e\u3059\u3002\u4e3b\u306bOS\u306e\u7a2e\u985e\u3001\u30b5\u30fc\u30d3\u30b9\u30d1\u30c3\u30af\u306e\u6709\u7121\u3001\u30cf\u30fc\u30c9\u30a6\u30a7\u30a2\u30a2\u30fc\u30ad\u30c6\u30af\u30c1\u30e3(32/64bit)\u3092\u8b58\u5225\u3059\u308b\u305f\u3081\u306b\u5229\u7528\u3055\u308c\u307e\u3059\u304c\u3001DTB\u30a2\u30c9\u30ec\u30b9\u3068\u3044\u3063\u305f\u6709\u76ca\u306a\u60c5\u5831\u3092\u77e5\u308b\u3053\u3068\u3082\u3067\u304d\u307e\u3059\u3002\n$ python vol.py -f ~/Desktop/win7_trial_64bit.raw imageinfo\nVolatility Foundation Volatility Framework 2.4\nDetermining profile based on KDBG search...\n\n          Suggested Profile(s) : Win7SP0x64, Win7SP1x64, Win2008R2SP0x64, Win2008R2SP1x64\n                     AS Layer1 : AMD64PagedMemory (Kernel AS)\n                     AS Layer2 : FileAddressSpace (/Users/Michael/Desktop/win7_trial_64bit.raw)\n                      PAE type : PAE\n                           DTB : 0x187000L\n                          KDBG : 0xf80002803070\n          Number of Processors : 1\n     Image Type (Service Pack) : 0\n                KPCR for CPU 0 : 0xfffff80002804d00L\n             KUSER_SHARED_DATA : 0xfffff78000000000L\n           Image date and time : 2012-02-22 11:29:02 UTC+0000\n     Image local date and time : 2012-02-22 03:29:02 -0800\n\n\nThe imageinfo output tells you the suggested profile that you should pass as the parameter to --profile=PROFILE when using other plugins. There may be more than one profile suggestion if profiles are closely related. It also prints the address of the KDBG (short for _KDDEBUGGER_DATA64) structure that will be used by plugins like pslist and modules to find the process and module list heads, respectively. In some cases, especially larger memory samples, there may be multiple KDBG structures. Similarly, if there are multiple processors, you'll see the KPCR address and CPU number for each one.\n\nimageinfo\u306f\u3001\u5225\u306e\u30d7\u30e9\u30b0\u30a4\u30f3\u3092\u5b9f\u884c\u3059\u308b\u969b\u306b--profile=PROFILE\u30aa\u30d7\u30b7\u30e7\u30f3\u3067\u6307\u5b9a\u3059\u3079\u304d\u30d7\u30ed\u30d5\u30a1\u30a4\u30eb\u3092\u793a\u5506\u3057\u3066\u304f\u308c\u307e\u3059\u3002\u95a2\u9023\u3059\u308b\u8907\u6570\u306e\u30d7\u30ed\u30d5\u30a1\u30a4\u30eb\u304c\u793a\u3055\u308c\u308b\u5834\u5408\u3082\u3042\u308a\u307e\u3059\u3002pslist\u3084\u30d7\u30ed\u30bb\u30b9\u3068\u30e2\u30b8\u30e5\u30fc\u30eb\u30ea\u30b9\u30c8\u3092\u63a2\u7d22\u3059\u308b\u30d7\u30e9\u30b0\u30a4\u30f3\u3067\u5229\u7528\u3055\u308c\u308bKDBG\u69cb\u9020\u4f53(_KDDEBUGGER_DATA64)\u306e\u30a2\u30c9\u30ec\u30b9\u3082\u8868\u793a\u3057\u307e\u3059\u3002\u7279\u306b\u5927\u304d\u306a\u30e1\u30e2\u30ea\u30b5\u30f3\u30d7\u30eb\u3067\u306f\u3001\u8907\u6570\u306eKDBG\u69cb\u9020\u4f53\u306e\u30a2\u30c9\u30ec\u30b9\u304c\u793a\u3055\u308c\u308b\u304b\u3082\u3057\u308c\u307e\u305b\u3093\u3002\u540c\u3058\u3088\u3046\u306b\u8907\u6570\u306e\u30d7\u30ed\u30bb\u30c3\u30b5\u3092\u6301\u3063\u305f\u30b7\u30b9\u30c6\u30e0\u306e\u5834\u5408\u3001\u305d\u308c\u305e\u308c\u306bKPCR\u30a2\u30c9\u30ec\u30b9\u3068CPU\u756a\u53f7\u304c\u8868\u793a\u3055\u308c\u307e\u3059\u3002\n\nPlugins automatically scan for the KPCR and KDBG values when they need them. However, you can specify the values directly for any plugin by providing --kpcr=ADDRESS or --kdbg=ADDRESS. By supplying the profile and KDBG (or failing that KPCR) to other Volatility commands, you'll get the most accurate and fastest results possible.\n\nvolatility\u306e\u30d7\u30e9\u30b0\u30a4\u30f3\u306f\u5fc5\u8981\u306b\u5fdc\u3058\u3066\u81ea\u52d5\u7684\u306bKPCR\u3068KDBG\u306e\u5024\u3092\u30b9\u30ad\u30e3\u30f3\u3057\u307e\u3059\u304c\u3001--kpcr=ADDRESS\u3068--kgbg=ADDRESS\u3068\u3044\u3046\u30d1\u30e9\u30e1\u30fc\u30bf\u3067\u660e\u793a\u7684\u306b\u6307\u5b9a\u3059\u308b\u3053\u3068\u3082\u3067\u304d\u307e\u3059\u3002\u30d7\u30ed\u30d5\u30a1\u30a4\u30eb\u3068KDBG\u3092\u30b3\u30de\u30f3\u30c9\u306b\u4e0e\u3048\u308b\u3053\u3068\u306b\u3088\u3063\u3066\u3001\u6700\u3082\u6b63\u78ba\u306a\u7d50\u679c\u3092\u9ad8\u901f\u306b\u5f97\u308b\u3053\u3068\u304c\u3067\u304d\u307e\u3059\u3002\n\nNote: The imageinfo plugin will not work on hibernation files unless the correct profile is given in advance. This is because important structure definitions vary between different operating systems.\n\nNote: \u30cf\u30a4\u30d0\u30cd\u30fc\u30b7\u30e7\u30f3\u30d5\u30a1\u30a4\u30eb\u306b\u5bfe\u3057\u3066\u306f\u6b63\u3057\u3044\u30d7\u30ed\u30d5\u30a1\u30a4\u30eb\u3092\u6307\u5b9a\u3057\u306a\u3044\u3068imageinfo\u306f\u6a5f\u80fd\u3057\u307e\u305b\u3093\u3002\u3053\u308c\u306fOS\u9593\u3067\u91cd\u8981\u306a\u69cb\u9020\u4f53\u306e\u5b9a\u7fa9\u304c\u7570\u306a\u308b\u305f\u3081\u3067\u3059\u3002\n\nkdbgscan\n\nAs opposed to imageinfo which simply provides profile suggestions, kdbgscan is designed to positively identify the correct profile and the correct KDBG address (if there happen to be multiple). This plugin scans for the KDBGHeader signatures linked to Volatility profiles and applies sanity checks to reduce false positives. The verbosity of the output and number of sanity checks that can be performed depends on whether Volatility can find a DTB, so if you already know the correct profile (or if you have a profile suggestion from imageinfo), then make sure you use it.\n\n\u5358\u7d14\u306b\u30d7\u30ed\u30d5\u30a1\u30a4\u30eb\u3092\u793a\u5506\u3059\u308bimageinfo\u3068\u306f\u9055\u3044\u3001kdbgscan\u306f\u6b63\u78ba\u306a\u30d7\u30ed\u30d5\u30a1\u30a4\u30eb\u3068KDBG\u30a2\u30c9\u30ec\u30b9(\u8907\u6570\u5b58\u5728\u3059\u308c\u3070)\u3092\u8b58\u5225\u3059\u308b\u3088\u3046\u306b\u30c7\u30b6\u30a4\u30f3\u3055\u308c\u3066\u3044\u307e\u3059\u3002\u3053\u306e\u30d7\u30e9\u30b0\u30a4\u30f3\u306f\u3001\u30d7\u30ed\u30d5\u30a1\u30a4\u30eb\u306b\u5bfe\u5fdc\u3057\u305fKDBGHeader\u30b7\u30b0\u30cb\u30c1\u30e3\u3092\u30b9\u30ad\u30e3\u30f3\u3057\u3001\u8aa4\u691c\u77e5\u3092\u4f4e\u4e0b\u3055\u305b\u308b\u305f\u3081\u306e\u30c1\u30a7\u30c3\u30af\u3092\u884c\u3044\u307e\u3059\u3002\u51fa\u529b\u306e\u8a73\u7d30\u3055\u3068\u5b9f\u884c\u53ef\u80fd\u306a\u30c1\u30a7\u30c3\u30af\u6570\u306f\u3001Volatility\u304cDTB\u3092\u898b\u3064\u3051\u3089\u308c\u308b\u304b\u306b\u3088\u308a\u307e\u3059\u3002\u305d\u306e\u305f\u3081\u3001\u3059\u3067\u306b\u6b63\u78ba\u306a\u30d7\u30ed\u30d5\u30a1\u30a4\u30eb\u3092\u77e5\u3063\u3066\u3044\u308b\u5834\u5408(\u307e\u305f\u306fimageinfo\u3067\u793a\u5506\u3055\u308c\u305f\u5834\u5408)\u3001\u305d\u308c\u3092\u5229\u7528\u3059\u308b\u3079\u304d\u3067\u3059\u3002\n\nHere's an example scenario of when this plugin can be useful. You have a memory sample that you believe to be Windows 2003 SP2 x64, but pslist doesn't show any processes. The pslist plugin relies on finding the process list head which is pointed to by KDBG. However, the plugin takes the first KDBG found in the memory sample, which is not always the best one. You may run into this problem if a KDBG with an invalid PsActiveProcessHead pointer is found earlier in a sample (i.e. at a lower physical offset) than the valid KDBG.\n\n\u3053\u306e\u30d7\u30e9\u30b0\u30a4\u30f3\u304c\u6709\u7528\u306a\u306e\u306f\u3001\u3053\u3093\u306a\u5834\u5408\u3067\u3059\u3002Windows 2003 SP2 x64\u306e\u3082\u306e\u3067\u3042\u308b\u3068\u8003\u3048\u3066\u3044\u308b\u30a4\u30e1\u30fc\u30b8\u30b5\u30f3\u30d7\u30eb\u304c\u3042\u308b\u304c\u3001pslist\u30b3\u30de\u30f3\u30c9\u306f\u30d7\u30ed\u30bb\u30b9\u3092\u8868\u793a\u3057\u3066\u304f\u308c\u307e\u305b\u3093\u3002pslist\u306fKDBG\u304b\u3089\u793a\u3055\u308c\u308b\u30d7\u30ed\u30bb\u30b9\u30ea\u30b9\u30c8\u30d8\u30c3\u30c9\u3092\u5229\u7528\u3057\u3066\u3044\u307e\u3059\u304c\u3001pslist\u306f\u5fc5\u305a\u3057\u3082\u3075\u3055\u308f\u3057\u3044\u3068\u306f\u3044\u3048\u306a\u3044\u30e1\u30e2\u30ea\u5185\u3067\u521d\u3081\u306b\u898b\u3064\u304b\u3063\u305fKDBG\u3092\u5229\u7528\u3057\u307e\u3059\u3002\u4e0d\u6b63\u306aPsActiveProcessHead\u30dd\u30a4\u30f3\u30bf\u3092\u6301\u3064KDBG\u304c\u3001(\u4f4e\u3044\u7269\u7406\u30a2\u30c9\u30ec\u30b9\u306b\u4f4d\u7f6e\u3057\u3066\u3044\u308b\u306a\u3069\u306e\u7406\u7531\u3067)\u6b63\u3057\u3044KDBG\u3088\u308a\u5148\u306b\u898b\u3064\u304b\u3063\u305f\u5834\u5408\u306b\u3053\u3046\u3044\u3063\u305f\u554f\u984c\u306b\u906d\u9047\u3059\u308b\u304b\u3082\u3057\u308c\u307e\u305b\u3093\u3002\n\nNotice below how kdbgscan picks up two KDBG structures: an invalid one (with 0 processes and 0 modules) is found first at 0xf80001172cb0 and a valid one (with 37 processes and 116 modules) is found next at 0xf80001175cf0. In order to \"fix\" pslist for this sample, you would simply need to supply the --kdbg=0xf80001175cf0 to the plist plugin.\n\n\u4e0b\u8a18\u306e\u4f8b\u3067\u306f\u3001kdbgscan\u304c2\u3064\u306eKDBG\u3092\u898b\u3064\u3051\u3066\u3044\u308b\u3053\u3068\u306b\u6ce8\u76ee\u3057\u3066\u304f\u3060\u3055\u3044\u3002\u6b63\u3057\u304f\u306a\u3044\u65b9\u304c\u5148\u306b0xf80001172cb0\u3067\u898b\u3064\u304b\u3063\u3066\u3044\u3066\u3001(37\u30d7\u30ed\u30bb\u30b9\u3068116\u30e2\u30b8\u30e5\u30fc\u30eb\u306b\u5bfe\u3059\u308b)\u6b63\u3057\u3044\u65b9\u304c\u5f8c\u304b\u30890xf80001175cf0\u3067\u898b\u3064\u304b\u3063\u3066\u3044\u307e\u3059\u3002\u3053\u306e\u30b5\u30f3\u30d7\u30eb\u3067\u306f\u3001pslist\u30d7\u30e9\u30b0\u30a4\u30f3\u306b\u5bfe\u3057\u3066--kdbg=0xf80001175cf0\u3068\u6307\u5b9a\u3059\u308c\u3070\u3001pslist\u306f\u6b63\u3057\u304f\u52d5\u4f5c\u3057\u307e\u3059\u3002\n$ python vol.py -f Win2K3SP2x64-6f1bedec.vmem --profile=Win2003SP2x64 kdbgscan\nVolatility Foundation Volatility Framework 2.4\n**************************************************\nInstantiating KDBG using: Kernel AS Win2003SP2x64 (5.2.3791 64bit)\nOffset (V)                    : 0xf80001172cb0\nOffset (P)                    : 0x1172cb0\nKDBG owner tag check          : True\nProfile suggestion (KDBGHeader): Win2003SP2x64\nVersion64                     : 0xf80001172c70 (Major: 15, Minor: 3790)\nService Pack (CmNtCSDVersion) : 0\nBuild string (NtBuildLab)     : T?\nPsActiveProcessHead           : 0xfffff800011947f0 (0 processes)\nPsLoadedModuleList            : 0xfffff80001197ac0 (0 modules)\nKernelBase                    : 0xfffff80001000000 (Matches MZ: True)\nMajor (OptionalHeader)        : 5\nMinor (OptionalHeader)        : 2\n\n**************************************************\nInstantiating KDBG using: Kernel AS Win2003SP2x64 (5.2.3791 64bit)\nOffset (V)                    : 0xf80001175cf0\nOffset (P)                    : 0x1175cf0\nKDBG owner tag check          : True\nProfile suggestion (KDBGHeader): Win2003SP2x64\nVersion64                     : 0xf80001175cb0 (Major: 15, Minor: 3790)\nService Pack (CmNtCSDVersion) : 2\nBuild string (NtBuildLab)     : 3790.srv03_sp2_rtm.070216-1710\nPsActiveProcessHead           : 0xfffff800011977f0 (37 processes)\nPsLoadedModuleList            : 0xfffff8000119aae0 (116 modules)\nKernelBase                    : 0xfffff80001000000 (Matches MZ: True)\nMajor (OptionalHeader)        : 5\nMinor (OptionalHeader)        : 2\nKPCR                          : 0xfffff80001177000 (CPU 0)\n\n\nFor more information on how KDBG structures are identified read Finding Kernel Global Variables in Windows and Identifying Memory Images\n\nKDBG\u69cb\u9020\u4f53\u3092\u8b58\u5225\u3059\u308b\u305f\u3081\u306e\u8a73\u3057\u3044\u60c5\u5831\u3092\u77e5\u308b\u305f\u3081\u306b\u306f\u3001\"inding Kernel Global Variables in Windows\"\u3068\"Identifying Memory Images\"\u3092\u53c2\u7167\u3057\u3066\u304f\u3060\u3055\u3044\u3002\n\nkpcrscan\n\nUse this command to scan for potential KPCR structures by checking for the self-referencing members as described by Finding Object Roots in Vista. On a multi-core system, each processor has its own KPCR. Therefore, you'll see details for each processor, including IDT and GDT address; current, idle, and next threads; CPU number, vendor & speed; and CR3 value.\n\nkpcrscan\u30b3\u30de\u30f3\u30c9\u3067\u3001\"Finding Object Roots in Vista\"\u3067\u8aac\u660e\u3055\u308c\u3066\u3044\u308b\u3088\u3046\u306b\u3001\u81ea\u5df1\u53c2\u7167\u3092\u30c1\u30a7\u30c3\u30af\u3059\u308b\u3053\u3068\u306b\u3088\u308a\u3001KPCR\u69cb\u9020\u4f53\u3092\u63a2\u3059\u3053\u3068\u304c\u3067\u304d\u307e\u3059\u3002\u8907\u6570\u306eCPU\u30b3\u30a2\u3092\u6301\u3064\u30b7\u30b9\u30c6\u30e0\u3067\u306f\u3001\u305d\u308c\u305e\u308c\u306e\u30d7\u30ed\u30bb\u30c3\u30b5\u304cKPCR\u3092\u6301\u3061\u307e\u3059\u3002IDT\u3068GDT\u30a2\u30c9\u30ec\u30b9\u3092\u542b\u3080\u3001\u73fe\u5728\uff0f\u30a2\u30a4\u30c9\u30eb\uff0f\u6b21\u306e\u30b9\u30ec\u30c3\u30c9\u3001CPU\u756a\u53f7\u3001\u30d9\u30f3\u30c0\u30fc\u3001\u30b9\u30d4\u30fc\u30c9\u3001CR3\u306e\u5024\u306a\u3069\u3001\u305d\u308c\u305e\u308c\u306e\u30d7\u30ed\u30bb\u30c3\u30b5\u306e\u8a73\u7d30\u3092\u78ba\u8a8d\u3067\u304d\u307e\u3059\u3002\n$ python vol.py -f dang_win7_x64.raw --profile=Win7SP1x64 kpcrscan\nVolatility Foundation Volatility Framework 2.4\n**************************************************\nOffset (V)                    : 0xf800029ead00\nOffset (P)                    : 0x29ead00\nKdVersionBlock                : 0x0\nIDT                           : 0xfffff80000b95080\nGDT                           : 0xfffff80000b95000\nCurrentThread                 : 0xfffffa800cf694d0 TID 2148 (kd.exe:2964)\nIdleThread                    : 0xfffff800029f8c40 TID 0 (Idle:0)\nDetails                       : CPU 0 (GenuineIntel @ 2128 MHz)\nCR3/DTB                       : 0x1dcec000\n**************************************************\nOffset (V)                    : 0xf880009e7000\nOffset (P)                    : 0x4d9e000\nKdVersionBlock                : 0x0\nIDT                           : 0xfffff880009f2540\nGDT                           : 0xfffff880009f24c0\nCurrentThread                 : 0xfffffa800cf694d0 TID 2148 (kd.exe:2964)\nIdleThread                    : 0xfffff880009f1f40 TID 0 (Idle:0)\nDetails                       : CPU 1 (GenuineIntel @ 2220 MHz)\nCR3/DTB                       : 0x1dcec000\n\n\nIf the KdVersionBlock is not null, then it may be possible to find the machine's KDBG address via the KPCR. In fact, the backup method of finding KDBG used by plugins such as pslist is to leverage kpcrscan and then call the KPCR.get_kdbg() API function.\n\nKdVersionBlock\u304cnull\u3067\u306f\u306a\u3044\u5834\u5408\u3001KPCR\u304b\u3089KDBG\u3092\u898b\u3064\u3051\u308b\u3053\u3068\u304c\u3067\u304d\u308b\u304b\u3082\u3057\u308c\u307e\u305b\u3093\u3002pslist\u306a\u3069\u306e\u30d7\u30e9\u30b0\u30a4\u30f3\u306f\u3001KDBG\u3092\u898b\u3064\u3051\u308b\u305f\u3081\u306e\u526f\u6b21\u7684\u306a\u65b9\u6cd5\u3068\u3057\u3066\u3001kpcrscan\u3092\u4f7f\u3044\u3001KPCR.get_kdbg() API\u3092\u5229\u7528\u3057\u3066\u3044\u307e\u3059\u3002\n\nProcesses and DLLs\n\npslist\n\nTo list the processes of a system, use the pslist command. This walks the doubly-linked list pointed to by PsActiveProcessHead and shows the offset, process name, process ID, the parent process ID, number of threads, number of handles, and date/time when the process started and exited. As of 2.1 it also shows the Session ID and if the process is a Wow64 process (it uses a 32 bit address space on a 64 bit kernel).\n\npslist\u30b3\u30de\u30f3\u30c9\u3067\u30d7\u30ed\u30bb\u30b9\u3092\u5217\u6319\u3057\u307e\u3059\u3002PsActiveProcessHead\u3067\u793a\u3055\u308c\u308b\u30c0\u30d6\u30eb\u30ea\u30f3\u30af\u30ea\u30b9\u30c8\u3092\u8fbf\u3063\u3066\u3001\u30aa\u30d5\u30bb\u30c3\u30c8\u3001\u30d7\u30ed\u30bb\u30b9\u540d\u3001\u30d7\u30ed\u30bb\u30b9ID\u3001\u89aa\u30d7\u30ed\u30bb\u30b9ID\u3001\u30b9\u30ec\u30c3\u30c9\u6570\u3001\u30cf\u30f3\u30c9\u30eb\u6570\u3001\u958b\u59cb\u30fb\u7d42\u4e86\u6642\u523b\u3092\u8868\u793a\u3057\u307e\u3059\u3002\u30d0\u30fc\u30b8\u30e7\u30f32.1\u304b\u3089\u3001\u30bb\u30c3\u30b7\u30e7\u30f3ID\u3001WOW64\u30d7\u30ed\u30bb\u30b9\u304b\u3069\u3046\u304b\u3082\u8868\u793a\u3057\u307e\u3059(WOW64\u30d7\u30ed\u30bb\u30b9\u306f\u300164bit\u30b7\u30b9\u30c6\u30e0\u4e0a\u306732bit\u30a2\u30c9\u30ec\u30b9\u7a7a\u9593\u3092\u4f7f\u7528\u3057\u307e\u3059)\u3002\n\nThis plugin does not detect hidden or unlinked processes (but psscan can do that).\n\n\u3053\u306e\u30d7\u30e9\u30b0\u30a4\u30f3\u3067\u306f\u3001\u96a0\u3055\u308c\u305f\u30d7\u30ed\u30bb\u30b9\u3084\u30ea\u30f3\u30af\u30ea\u30b9\u30c8\u3092\u306f\u305a\u3055\u308c\u305f\u30d7\u30ed\u30bb\u30b9\u306f\u8a8d\u8b58\u3067\u304d\u307e\u305b\u3093\u3002(psscan\u306f\u53ef\u80fd)\n\nIf you see processes with 0 threads, 0 handles, and/or a non-empty exit time, the process may not actually still be active. For more information, see The Missing Active in PsActiveProcessHead. Below, you'll notice regsvr32.exe has terminated even though its still in the \"active\" list.\n\n\u30b9\u30ec\u30c3\u30c9\u65700\u3001\u30cf\u30f3\u30c9\u30eb\u65700\u3067\u3001\u7d42\u4e86\u6642\u523b\u304c\u8868\u793a\u3055\u308c\u308b/\u3055\u308c\u306a\u3044\u5834\u5408\u3001\u3082\u3046\u30a2\u30af\u30c6\u30a3\u30d6\u306a\u30d7\u30ed\u30bb\u30b9\u3067\u306f\u306a\u3044\u304b\u3082\u3057\u308c\u307e\u305b\u3093\u3002\u8a73\u3057\u304f\u306f\u3001\"The Missing Active in PsActiveProcessHead\"\u3092\u53c2\u7167\u3002\u4ee5\u4e0b\u306e\u4f8b\u3067\u306f\u3001regsvr32.exe\u304c\u30a2\u30af\u30c6\u30a3\u30d6\u30ea\u30b9\u30c8\u306b\u6319\u304c\u3063\u3066\u3044\u3066\u3082\u3001\u3059\u3067\u306b\u7d42\u4e86\u3057\u3066\u3044\u308b\u3053\u3068\u304c\u308f\u304b\u308a\u307e\u3059\u3002\n\nAlso note the two processes System and smss.exe will not have a Session ID, because System starts before sessions are established and smss.exe is the session manager itself.\n\nSysem\u306f\u30bb\u30c3\u30b7\u30e7\u30f3\u78ba\u7acb\u524d\u306b\u958b\u59cb\u3057\u3001smss.exe\u306f\u30bb\u30c3\u30b7\u30e7\u30f3\u30de\u30cd\u30fc\u30b8\u30e3\u305d\u306e\u3082\u306e\u3067\u3042\u308b\u305f\u3081\u3001System\u3068smss.exe\u306e2\u3064\u306e\u30d7\u30ed\u30bb\u30b9\u306f\u30bb\u30c3\u30b7\u30e7\u30f3ID\u3092\u6301\u3063\u3066\u3044\u307e\u305b\u3093\u3002\n$ python vol.py -f ~/Desktop/win7_trial_64bit.raw --profile=Win7SP0x64 pslist\nVolatility Foundation Volatility Framework 2.4\nOffset(V)          Name                    PID   PPID   Thds     Hnds   Sess  Wow64 Start                Exit\n------------------ -------------------- ------ ------ ------ -------- ------ ------ -------------------- --------------------\n0xfffffa80004b09e0 System                    4      0     78      489 ------      0 2012-02-22 19:58:20\n0xfffffa8000ce97f0 smss.exe                208      4      2       29 ------      0 2012-02-22 19:58:20\n0xfffffa8000c006c0 csrss.exe               296    288      9      385      0      0 2012-02-22 19:58:24\n0xfffffa8000c92300 wininit.exe             332    288      3       74      0      0 2012-02-22 19:58:30\n0xfffffa8000c06b30 csrss.exe               344    324      7      252      1      0 2012-02-22 19:58:30\n0xfffffa8000c80b30 winlogon.exe            372    324      5      136      1      0 2012-02-22 19:58:31\n0xfffffa8000c5eb30 services.exe            428    332      6      193      0      0 2012-02-22 19:58:32\n0xfffffa80011c5700 lsass.exe               444    332      6      557      0      0 2012-02-22 19:58:32\n0xfffffa8000ea31b0 lsm.exe                 452    332     10      133      0      0 2012-02-22 19:58:32\n0xfffffa8001296b30 svchost.exe             568    428     10      352      0      0 2012-02-22 19:58:34\n0xfffffa80012c3620 svchost.exe             628    428      6      247      0      0 2012-02-22 19:58:34\n0xfffffa8001325950 sppsvc.exe              816    428      5      154      0      0 2012-02-22 19:58:41\n0xfffffa80007b7960 svchost.exe             856    428     16      404      0      0 2012-02-22 19:58:43\n0xfffffa80007bb750 svchost.exe             880    428     34     1118      0      0 2012-02-22 19:58:43\n0xfffffa80007d09e0 svchost.exe             916    428     19      443      0      0 2012-02-22 19:58:43\n0xfffffa8000c64840 svchost.exe             348    428     14      338      0      0 2012-02-22 20:02:07\n0xfffffa8000c09630 svchost.exe             504    428     16      496      0      0 2012-02-22 20:02:07\n0xfffffa8000e86690 spoolsv.exe            1076    428     12      271      0      0 2012-02-22 20:02:10\n0xfffffa8000518b30 svchost.exe            1104    428     18      307      0      0 2012-02-22 20:02:10\n0xfffffa800094d960 wlms.exe               1264    428      4       43      0      0 2012-02-22 20:02:11\n0xfffffa8000995b30 svchost.exe            1736    428     12      200      0      0 2012-02-22 20:02:25\n0xfffffa8000aa0b30 SearchIndexer.         1800    428     12      757      0      0 2012-02-22 20:02:26\n0xfffffa8000aea630 taskhost.exe           1144    428      7      189      1      0 2012-02-22 20:02:41\n0xfffffa8000eafb30 dwm.exe                1476    856      3       71      1      0 2012-02-22 20:02:41\n0xfffffa80008f3420 explorer.exe           1652    840     21      760      1      0 2012-02-22 20:02:42\n0xfffffa8000c9a630 regsvr32.exe           1180   1652      0 --------      1      0 2012-02-22 20:03:05  2012-02-22 20:03:08\n0xfffffa8000a03b30 rundll32.exe           2016    568      3       67      1      0 2012-02-22 20:03:16\n0xfffffa8000a4f630 svchost.exe            1432    428     12      350      0      0 2012-02-22 20:04:14\n0xfffffa8000999780 iexplore.exe           1892   1652     19      688      1      1 2012-02-22 11:26:12\n0xfffffa80010c9060 iexplore.exe           2820   1892     23      733      1      1 2012-02-22 11:26:15\n0xfffffa8001016060 DumpIt.exe             2860   1652      2       42      1      1 2012-02-22 11:28:59\n0xfffffa8000acab30 conhost.exe            2236    344      2       51      1      0 2012-02-22 11:28:59\n\n\nBy default, pslist shows virtual offsets for the EPROCESS but the physical offset can be obtained with the -P switch:\n\n\u30c7\u30d5\u30a9\u30eb\u30c8\u3067\u306f\u3001pslist\u306fEPROCESS\u306e\u4eee\u60f3\u30aa\u30d5\u30bb\u30c3\u30c8\u3092\u8868\u793a\u3057\u307e\u3059\u304c\u3001-P\u30aa\u30d7\u30b7\u30e7\u30f3\u306b\u3088\u3063\u3066\u7269\u7406\u30aa\u30d5\u30bb\u30c3\u30c8\u3092\u8868\u793a\u3055\u305b\u308b\u3053\u3068\u304c\u3067\u304d\u307e\u3059\u3002\n$ python vol.py -f ~/Desktop/win7_trial_64bit.raw --profile=Win7SP0x64 pslist -P\nVolatility Foundation Volatility Framework 2.4\nOffset(P)          Name                    PID   PPID   Thds     Hnds   Sess  Wow64 Start                Exit\n------------------ -------------------- ------ ------ ------ -------- ------ ------ -------------------- --------------------\n0x0000000017fef9e0 System                    4      0     78      489 ------      0 2012-02-22 19:58:20\n0x00000000176e97f0 smss.exe                208      4      2       29 ------      0 2012-02-22 19:58:20\n0x00000000176006c0 csrss.exe               296    288      9      385      0      0 2012-02-22 19:58:24\n0x0000000017692300 wininit.exe             332    288      3       74      0      0 2012-02-22 19:58:30\n0x0000000017606b30 csrss.exe               344    324      7      252      1      0 2012-02-22 19:58:30\n...\n\n\npstree\n\nTo view the process listing in tree form, use the pstree command. This enumerates processes using the same technique as pslist, so it will also not show hidden or unlinked processes. Child process are indicated using indention and periods.\n\npstree\u30b3\u30de\u30f3\u30c9\u306f\u3001\u30c4\u30ea\u30fc\u5f62\u5f0f\u306e\u30d7\u30ed\u30bb\u30b9\u30ea\u30b9\u30c8\u3092\u8868\u793a\u3057\u307e\u3059\u3002pslist\u3068\u540c\u3058\u4ed5\u7d44\u307f\u3067\u30d7\u30ed\u30bb\u30b9\u3092\u5217\u6319\u3059\u308b\u305f\u3081\u3001\u96a0\u3055\u308c\u305f\u30d7\u30ed\u30bb\u30b9\u3084\u30ea\u30f3\u30af\u304c\u5916\u3055\u308c\u305f\u30d7\u30ed\u30bb\u30b9\u306f\u8868\u793a\u3055\u308c\u307e\u305b\u3093\u3002\u5b50\u30d7\u30ed\u30bb\u30b9\u306f\u3001\u30a4\u30f3\u30c7\u30f3\u30c8\u3068\u30d4\u30ea\u30aa\u30c9\u3067\u793a\u3055\u308c\u307e\u3059\u3002\n$ python vol.py -f ~/Desktop/win7_trial_64bit.raw --profile=Win7SP0x64 pstree\nVolatility Foundation Volatility Framework 2.4\nName                                                  Pid   PPid   Thds   Hnds Time\n-------------------------------------------------- ------ ------ ------ ------ --------------------\n 0xfffffa80004b09e0:System                              4      0     78    489 2012-02-22 19:58:20\n. 0xfffffa8000ce97f0:smss.exe                         208      4      2     29 2012-02-22 19:58:20\n 0xfffffa8000c006c0:csrss.exe                         296    288      9    385 2012-02-22 19:58:24\n 0xfffffa8000c92300:wininit.exe                       332    288      3     74 2012-02-22 19:58:30\n. 0xfffffa8000c5eb30:services.exe                     428    332      6    193 2012-02-22 19:58:32\n.. 0xfffffa8000aa0b30:SearchIndexer.                 1800    428     12    757 2012-02-22 20:02:26\n.. 0xfffffa80007d09e0:svchost.exe                     916    428     19    443 2012-02-22 19:58:43\n.. 0xfffffa8000a4f630:svchost.exe                    1432    428     12    350 2012-02-22 20:04:14\n.. 0xfffffa800094d960:wlms.exe                       1264    428      4     43 2012-02-22 20:02:11\n.. 0xfffffa8001325950:sppsvc.exe                      816    428      5    154 2012-02-22 19:58:41\n.. 0xfffffa8000e86690:spoolsv.exe                    1076    428     12    271 2012-02-22 20:02:10\n.. 0xfffffa8001296b30:svchost.exe                     568    428     10    352 2012-02-22 19:58:34\n... 0xfffffa8000a03b30:rundll32.exe                  2016    568      3     67 2012-02-22 20:03:16\n...\n\n\npsscan\n\nTo enumerate processes using pool tag scanning (POOL_HEADER), use the psscan command. This can find processes that previously terminated (inactive) and processes that have been hidden or unlinked by a rootkit. The downside is that rootkits can still hide by overwriting the pool tag values (though not commonly seen in the wild).\n\npsscan\u30b3\u30de\u30f3\u30c9\u306f\u3001\u30d7\u30fc\u30eb\u30bf\u30b0(POOL_HEADER)\u3092\u30b9\u30ad\u30e3\u30f3\u3059\u308b\u3053\u3068\u306b\u3088\u308a\u30d7\u30ed\u30bb\u30b9\u3092\u5217\u6319\u3059\u308b\u3002\u65e2\u306b\u505c\u6b62\u3057\u305f(\u30a2\u30af\u30c6\u30a3\u30d6\u3067\u306f\u306a\u3044)\u30d7\u30ed\u30bb\u30b9\u3001rootkit\u306b\u3088\u3063\u3066\u96a0\u3055\u308c\u305f\u30d7\u30ed\u30bb\u30b9\u3084\u30ea\u30f3\u30af\u3092\u5916\u3055\u308c\u305f\u30d7\u30ed\u30bb\u30b9\u3082\u898b\u3064\u3051\u51fa\u3059\u3053\u3068\u304c\u3067\u304d\u308b\u3002rootkit\u306f\u30d7\u30fc\u30eb\u30bf\u30b0\u3092\u4e0a\u66f8\u304d\u3059\u308b\u3053\u3068\u3082\u3067\u304d\u308b\u3053\u3068\u306f\u554f\u984c\u3067\u3059(\u73fe\u5b9f\u306b\u306f\u3042\u307e\u308a\u898b\u3089\u308c\u307e\u305b\u3093)\u3002\n$ python vol.py --profile=Win7SP0x86 -f win7.dmp psscan\nVolatility Foundation Volatility Framework 2.0\n Offset     Name             PID    PPID   PDB        Time created             Time exited\n---------- ---------------- ------ ------ ---------- ------------------------ ------------------------\n0x3e025ba8 svchost.exe        1116    508 0x3ecf1220 2010-06-16 15:25:25\n0x3e04f070 svchost.exe        1152    508 0x3ecf1340 2010-06-16 15:27:40\n0x3e144c08 dwm.exe            1540    832 0x3ecf12e0 2010-06-16 15:26:58\n0x3e145c18 TPAutoConnSvc.     1900    508 0x3ecf1360 2010-06-16 15:25:41\n0x3e3393f8 lsass.exe           516    392 0x3ecf10e0 2010-06-16 15:25:18\n0x3e35b8f8 svchost.exe         628    508 0x3ecf1120 2010-06-16 15:25:19\n0x3e383770 svchost.exe         832    508 0x3ecf11a0 2010-06-16 15:25:20\n0x3e3949d0 svchost.exe         740    508 0x3ecf1160 2010-06-16 15:25:20\n0x3e3a5100 svchost.exe         872    508 0x3ecf11c0 2010-06-16 15:25:20\n0x3e3f64e8 svchost.exe         992    508 0x3ecf1200 2010-06-16 15:25:24\n0x3e45a530 wininit.exe         392    316 0x3ecf10a0 2010-06-16 15:25:15\n0x3e45d928 svchost.exe        1304    508 0x3ecf1260 2010-06-16 15:25:28\n0x3e45f530 csrss.exe           400    384 0x3ecf1040 2010-06-16 15:25:15\n0x3e4d89c8 vmtoolsd.exe       1436    508 0x3ecf1280 2010-06-16 15:25:30\n0x3e4db030 spoolsv.exe        1268    508 0x3ecf1240 2010-06-16 15:25:28\n0x3e50b318 services.exe        508    392 0x3ecf1080 2010-06-16 15:25:18\n0x3e7f3d40 csrss.exe           352    316 0x3ecf1060 2010-06-16 15:25:12\n0x3e7f5bc0 winlogon.exe        464    384 0x3ecf10c0 2010-06-16 15:25:18\n0x3eac6030 SearchProtocol     2448   1168 0x3ecf15c0 2010-06-16 23:30:52      2010-06-16 23:33:14\n0x3eb10030 SearchFilterHo     1812   1168 0x3ecf1480 2010-06-16 23:31:02      2010-06-16 23:33:14\n[snip]\n\n\nIf a process has previously terminated, the Time exited field will show the exit time. If you want to investigate a hidden process (such as displaying its DLLs), then you'll need physical offset of the _EPROCESS object, which is shown in the far left column. Almost all process-related plugins take a --OFFSET parameter so that you can work with hidden processes.\n\n\u30d7\u30ed\u30bb\u30b9\u304c\u65e2\u306b\u7d42\u4e86\u3057\u3066\u3044\u308b\u5834\u5408\u3001Time exited\u30d5\u30a3\u30fc\u30eb\u30c9\u304c\u7d42\u4e86\u6642\u523b\u3092\u8868\u3057\u307e\u3059\u3002(DLL\u306e\u3088\u3046\u306a)\u96a0\u3055\u308c\u305f\u30d7\u30ed\u30bb\u30b9\u3092\u8abf\u67fb\u3057\u305f\u3044\u306a\u3089\u3001\u5de6\u306e\u5217\u306b\u8868\u793a\u3055\u308c\u3066\u3044\u308bEPROCESS\u30aa\u30d6\u30b8\u30a7\u30af\u30c8\u306e\u7269\u7406\u30aa\u30d5\u30bb\u30c3\u30c8\u304c\u5fc5\u8981\u3067\u3059\u3002\u96a0\u3055\u308c\u305f\u30d7\u30ed\u30bb\u30b9\u3092\u8abf\u67fb\u3059\u308b\u305f\u3081\u306b\u3001\u307b\u3068\u3093\u3069\u306e\u30d7\u30ed\u30bb\u30b9\u95a2\u9023\u306e\u30d7\u30e9\u30b0\u30a4\u30f3\u306b\u306f--OFFSET\u30d1\u30e9\u30e1\u30fc\u30bf\u3092\u6307\u5b9a\u3059\u308b\u3053\u3068\u304c\u3067\u304d\u307e\u3059\u3002\n\npsdispscan\n\nThis plugin is similar to psscan, except it enumerates processes by scanning for DISPATCHER_HEADER instead of pool tags. This gives you an alternate way to carve _EPROCESS objects in the event an attacker tried to hide by altering pool tags. This plugin is not well maintained and only supports XP x86. To use it, you must type --plugins=contrib/plugins on command-line.\n\n\u3053\u306e\u30d7\u30e9\u30b0\u30a4\u30f3\u306fpsscan\u3068\u4f3c\u3066\u3044\u307e\u3059\u304c\u3001\u30d7\u30fc\u30eb\u30bf\u30b0\u3067\u306f\u306a\u304fDISPATCHER_HEADER\u3092\u30b9\u30ad\u30e3\u30f3\u3059\u308b\u3053\u3068\u306b\u3088\u3063\u3066\u30d7\u30ed\u30bb\u30b9\u3092\u5217\u6319\u3057\u307e\u3059\u3002\u653b\u6483\u8005\u304c\u30d7\u30fc\u30eb\u30bf\u30b0\u3092\u5909\u66f4\u3059\u308b\u3053\u3068\u306b\u3088\u3063\u3066\u96a0\u853d\u3059\u308b\u3088\u3046\u306a\u5834\u5408\u306b\u3001EPROCESS\u3092\u8abf\u67fb\u3059\u308b\u5225\u306e\u3084\u308a\u65b9\u3068\u306a\u308a\u307e\u3059\u3002\u3053\u306e\u30d7\u30e9\u30b0\u30a4\u30f3\u306f\u3042\u307e\u308a\u30e1\u30f3\u30c6\u30ca\u30f3\u30b9\u3055\u308c\u3066\u304a\u3089\u305a\u3001XP x86\u306e\u307f\u30b5\u30dd\u30fc\u30c8\u3055\u308c\u3066\u3044\u307e\u3059\u3002\u3053\u306e\u30d7\u30e9\u30b0\u30a4\u30f3\u3092\u4f7f\u7528\u3059\u308b\u305f\u3081\u306b\u306f\u3001--plugins=contrib/plugins\u3068\u3044\u3046\u30aa\u30d7\u30b7\u30e7\u30f3\u3092\u6307\u5b9a\u3059\u308b\u5fc5\u8981\u304c\u3042\u308a\u307e\u3059\u3002\n\ndlllist\n\nTo display a process's loaded DLLs, use the dlllist command. It walks the doubly-linked list of _LDR_DATA_TABLE_ENTRY structures which is pointed to by the PEB's InLoadOrderModuleList. DLLs are automatically added to this list when a process calls LoadLibrary (or some derivative such as LdrLoadDll) and they aren't removed until FreeLibrary is called and the reference count reaches zero. The load count column tells you if a DLL was statically loaded (i.e. as a result of being in the exe or another DLL's import table) or dynamically loaded.\n\ndlllist\u30b3\u30de\u30f3\u30c9\u3067\u3001\u30d7\u30ed\u30bb\u30b9\u304c\u30ed\u30fc\u30c9\u3057\u305fDLL\u3092\u8868\u793a\u3059\u308b\u3053\u3068\u304c\u3067\u304d\u308b\u3002PEB\u306eInLoadOrderModuleList\u3067\u793a\u3055\u308c\u308b_LDR_DATA_TABLE_ENTRY\u69cb\u9020\u4f53\u306e\u30c0\u30d6\u30eb\u30ea\u30f3\u30af\u30ea\u30b9\u30c8\u3092\u305f\u3069\u3063\u3066\u3044\u304f\u3002\u30d7\u30ed\u30bb\u30b9\u304cLoadLibrary\u3092\u30b3\u30fc\u30eb\u3057\u305f\u969b\u306b(\u307e\u305f\u306fLdrLoadDll\u306a\u3069\u306e\u6d3e\u751f\u306b\u3088\u3063\u3066)\u3053\u306e\u30ea\u30b9\u30c8\u306b\u8ffd\u52a0\u3055\u308c\u3001FreeLibrary\u304c\u547c\u3073\u51fa\u3055\u308c\u3066\u53c2\u7167\u6570\u304c0\u306b\u306a\u308b\u307e\u3067\u524a\u9664\u3055\u308c\u306a\u3044\u3002load count\u5217\u306f\u9759\u7684\u306b\u30ed\u30fc\u30c9(exe\u3082\u3057\u304f\u306f\u5225\u306eDLL\u306e\u30a4\u30f3\u30dd\u30fc\u30c8\u30c6\u30fc\u30d6\u30eb\u306b\u767b\u9332\u3055\u308c\u3066\u3044\u308b\u3053\u3068\u306b\u3088\u308a)\u3055\u308c\u305f\u304b\u52d5\u7684\u306b\u30ed\u30fc\u30c9\u3055\u308c\u305f\u304b\u3092\u793a\u3059\u3002\n$ python vol.py -f ~/Desktop/win7_trial_64bit.raw --profile=Win7SP0x64 dlllist\n************************************************************************\nwininit.exe pid:    332\nCommand line : wininit.exe\n\nBase                             Size          LoadCount Path\n------------------ ------------------ ------------------ ----\n0x00000000ff530000            0x23000             0xffff C:\\Windows\\system32\\wininit.exe\n0x0000000076d40000           0x1ab000             0xffff C:\\Windows\\SYSTEM32\\ntdll.dll\n0x0000000076b20000           0x11f000             0xffff C:\\Windows\\system32\\kernel32.dll\n0x000007fefcd50000            0x6b000             0xffff C:\\Windows\\system32\\KERNELBASE.dll\n0x0000000076c40000            0xfa000             0xffff C:\\Windows\\system32\\USER32.dll\n0x000007fefd7c0000            0x67000             0xffff C:\\Windows\\system32\\GDI32.dll\n0x000007fefe190000             0xe000             0xffff C:\\Windows\\system32\\LPK.dll\n0x000007fefef80000            0xca000             0xffff C:\\Windows\\system32\\USP10.dll\n0x000007fefd860000            0x9f000             0xffff C:\\Windows\\system32\\msvcrt.dll\n[snip]\n\n\nTo display the DLLs for a specific process instead of all processes, use the -p or --pid filter as shown below. Also, in the following output, notice we're analyzing a Wow64 process. Wow64 processes have a limited list of DLLs in the PEB lists, but that doesn't mean they're the only DLLs loaded in the process address space. Thus Volatility will remind you to use the ldrmodules instead for these processes.\n\n\u5168\u30d7\u30ed\u30bb\u30b9\u3067\u306f\u306a\u304f\u3001\u7279\u5b9a\u306e\u30d7\u30ed\u30bb\u30b9\u306eDLL\u3092\u8868\u793a\u3059\u308b\u5834\u5408\u3001\u4e0b\u306e\u4f8b\u306e\u3088\u3046\u306b-p\u304b--pid\u30d5\u30a3\u30eb\u30bf\u3092\u6307\u5b9a\u3057\u307e\u3059\u3002\u3053\u306e\u4f8b\u3067\u306f\u3001Wow64\u30d7\u30ed\u30bb\u30b9\u3092\u89e3\u6790\u3057\u3066\u3044\u307e\u3059\u3002Wow64\u30d7\u30ed\u30bb\u30b9\u306f\u3001PEB\u30ea\u30b9\u30c8\u306b\u9650\u3089\u308c\u305fDLL\u306e\u30ea\u30b9\u30c8\u3057\u304b\u6301\u3063\u3066\u3044\u307e\u305b\u3093\u304c\u3001\u305d\u308c\u3089\u3060\u3051\u304c\u30d7\u30ed\u30bb\u30b9\u306e\u30a2\u30c9\u30ec\u30b9\u7a7a\u9593\u306b\u30ed\u30fc\u30c9\u3055\u308c\u305fDLL\u3067\u306f\u3042\u308a\u307e\u305b\u3093\u3002\u305d\u3046\u3057\u305f\u30d7\u30ed\u30bb\u30b9\u306e\u305f\u3081\u306b\u3001ldrmodules\u3092\u4ee3\u308f\u308a\u306b\u5229\u7528\u3059\u308b\u3053\u3068\u304c\u3067\u304d\u307e\u3059\u3002\n$ python vol.py -f ~/Desktop/win7_trial_64bit.raw --profile=Win7SP0x64 dlllist -p 1892\nVolatility Foundation Volatility Framework 2.4\n************************************************************************\niexplore.exe pid:   1892\nCommand line : \"C:\\Program Files (x86)\\Internet Explorer\\iexplore.exe\"\nNote: use ldrmodules for listing DLLs in Wow64 processes\n\nBase                             Size          LoadCount Path\n------------------ ------------------ ------------------ ----\n0x0000000000080000            0xa6000             0xffff C:\\Program Files (x86)\\Internet Explorer\\iexplore.exe\n0x0000000076d40000           0x1ab000             0xffff C:\\Windows\\SYSTEM32\\ntdll.dll\n0x00000000748d0000            0x3f000                0x3 C:\\Windows\\SYSTEM32\\wow64.dll\n0x0000000074870000            0x5c000                0x1 C:\\Windows\\SYSTEM32\\wow64win.dll\n0x0000000074940000             0x8000                0x1 C:\\Windows\\SYSTEM32\\wow64cpu.dll\n\n\nTo display the DLLs for a process that is hidden or unlinked by a rootkit, first use the psscan to get the physical offset of the EPROCESS object and supply it with --offset=OFFSET. The plugin will \"bounce back\" and determine the virtual address of the EPROCESS and then acquire an address space in order to access the PEB.\n\n\u30eb\u30fc\u30c8\u30ad\u30c3\u30c8\u306b\u3088\u3063\u3066\u96a0\u853d\u3055\u308c\u305f\u308a\u30ea\u30f3\u30af\u3092\u5916\u3055\u308c\u305fDLL\u3092\u8868\u793a\u3059\u308b\u305f\u3081\u306b\u306f\u3001\u307e\u305apsscan\u3067EPROCESS\u306e\u7269\u7406\u30aa\u30d5\u30bb\u30c3\u30c8\u3092\u53d6\u5f97\u3057\u3066\u3001--offset=OFFSET\u30aa\u30d7\u30b7\u30e7\u30f3\u3067\u6307\u5b9a\u3057\u3066\u304f\u3060\u3055\u3044\u3002\u30d7\u30e9\u30b0\u30a4\u30f3\u306f\u3001\"bounce back\"\u3057\u3066\u3001EPROCESS\u306e\u4eee\u60f3\u30a2\u30c9\u30ec\u30b9\u3092\u6c7a\u5b9a\u3057\u3001PEB\u306b\u30a2\u30af\u30bb\u30b9\u3059\u308b\u305f\u3081\u306b\u30a2\u30c9\u30ec\u30b9\u7a7a\u9593\u3092\u53d6\u5f97\u3057\u307e\u3059\u3002\n$ python vol.py -f ~/Desktop/win7_trial_64bit.raw --profile=Win7SP0x64 dlllist --offset=0x04a291a8\n\n\ndlldump\n\nTo extract a DLL from a process's memory space and dump it to disk for analysis, use the dlldump command. The syntax is nearly the same as what we've shown for dlllist above. You can:\n\ndlldump\u30b3\u30de\u30f3\u30c9\u3067\u3001\u89e3\u6790\u306e\u305f\u3081\u306b\u30d7\u30ed\u30bb\u30b9\u306e\u30e1\u30e2\u30ea\u7a7a\u9593\u304b\u3089DLL\u3092\u30c7\u30a3\u30b9\u30af\u306b\u30c0\u30f3\u30d7\u3059\u308b\u3053\u3068\u304c\u3067\u304d\u307e\u3059\u3002\u6307\u5b9a\u306e\u4ed5\u65b9\u306f\u3001\u4e0a\u306edlllist\u306e\u6307\u5b9a\u3068\u540c\u3058\u3067\u3059\u3002\u4ee5\u4e0b\u306e\u6307\u5b9a\u304c\u53ef\u80fd\u3067\u3059\u3002\n\n\nDump all DLLs from all processes\nDump all DLLs from a specific process (with --pid=PID)\nDump all DLLs from a hidden/unlinked process (with --offset=OFFSET)\nDump a PE from anywhere in process memory (with --base=BASEADDR), this option is useful for extracting hidden DLLs\nDump one or more DLLs that match a regular expression (--regex=REGEX), case sensitive or not (--ignore-case)\n\n\n\n\u5168\u30d7\u30ed\u30bb\u30b9\u304b\u3089\u5168DLL\u3092\u30c0\u30f3\u30d7\u3059\u308b\n\u6307\u5b9a\u3057\u305f\u30d7\u30ed\u30bb\u30b9\u306e\u5168DLL\u3092\u30c0\u30f3\u30d7\u3059\u308b(--pid=PID)\n\u96a0\u853d\u3084\u30ea\u30f3\u30af\u3092\u5916\u3055\u308c\u305f\u30d7\u30ed\u30bb\u30b9\u304b\u3089\u3059\u3079\u3066\u306eDLL\u3092\u30c0\u30f3\u30d7\u3059\u308b(--offset=OFFSET)\n\u30d7\u30ed\u30bb\u30b9\u30e1\u30e2\u30ea\u306e\u3069\u3053\u304b\u304b\u3089PE\u5f62\u5f0f\u3067\u30c0\u30f3\u30d7\u3059\u308b(--base=BASEADDR)\u3002\u3053\u308c\u306f\u96a0\u3055\u308c\u305fDLL\u3092\u53d6\u5f97\u3059\u308b\u306e\u306b\u4fbf\u5229\u3067\u3059\u3002\n\u6b63\u898f\u8868\u73fe\u306b\u30de\u30c3\u30c1\u3057\u305f(\u8907\u6570\u306e)DLL\u3092\u30c0\u30f3\u30d7\u3059\u308b(--regex=REGEX)\u3002\u5927\uff0f\u5c0f\u6587\u5b57\u3092\u533a\u5225\u3057\u306a\u3044(--ignore-case)\n\n\nTo specify an output directory, use --dump-dir=DIR or -d DIR.\n\n--dump-dir=DIR\u307e\u305f\u306f-d DIR\u30aa\u30d7\u30b7\u30e7\u30f3\u3067\u3001\u51fa\u529b\u30c7\u30a3\u30ec\u30af\u30c8\u30ea\u3092\u6307\u5b9a\u3057\u307e\u3059\u3002\n$ python vol.py -f ~/Desktop/win7_trial_64bit.raw --profile=Win7SP0x64 dlldump -D dlls/\n...\nProcess(V)         Name                 Module Base        Module Name          Result\n------------------ -------------------- ------------------ -------------------- ------\n0xfffffa8000ce97f0 smss.exe             0x0000000047a90000 smss.exe             OK: module.208.176e97f0.47a90000.dll\n0xfffffa8000ce97f0 smss.exe             0x0000000076d40000                      Error: DllBase is paged\n0xfffffa8000c006c0 csrss.exe            0x0000000049700000 csrss.exe            OK: module.296.176006c0.49700000.dll\n0xfffffa8000c006c0 csrss.exe            0x0000000076d40000 ntdll.dll            Error: DllBase is paged\n0xfffffa8000c006c0 csrss.exe            0x000007fefd860000 msvcrt.dll           Error: DllBase is paged\n0xfffffa80011c5700 lsass.exe            0x000007fefcc40000 WINSTA.dll           Error: DllBase is paged\n0xfffffa80011c5700 lsass.exe            0x000007fefd7c0000 GDI32.dll            OK: module.444.173c5700.7fefd7c0000.dll\n0xfffffa80011c5700 lsass.exe            0x000007fefc270000 DNSAPI.dll           OK: module.444.173c5700.7fefc270000.dll\n0xfffffa80011c5700 lsass.exe            0x000007fefc5d0000 Secur32.dll          OK: module.444.173c5700.7fefc5d0000.dll\n...\n\n\nIf the extraction fails, as it did for a few DLLs above, it probably means that some of the memory pages in that DLL were not memory resident (due to paging). In particular, this is a problem if the first page containing the PE header and thus the PE section mappings is not available. In these cases you can still extract the memory segment using the vaddump command, but you'll need to manually rebuild the PE header and fixup the sections (if you plan on analyzing in IDA Pro) as described in Recovering CoreFlood Binaries with Volatility.\n\n\u4e0a\u306e\u3044\u304f\u3064\u304b\u306eDLL\u306e\u3088\u3046\u306b\u62bd\u51fa\u304c\u5931\u6557\u3057\u305f\u5834\u5408\u3001DLL\u306e\u4e00\u90e8\u306e\u30e1\u30e2\u30ea\u30da\u30fc\u30b8\u304c\u7269\u7406\u30e1\u30e2\u30ea\u4e0a\u306b\u306a\u3044\u306e\u304b\u3082\u3057\u308c\u307e\u305b\u3093(\u30da\u30fc\u30b8\u30f3\u30b0\u306b\u3088\u3063\u3066)\u3002\u7279\u306bPE\u30d8\u30c3\u30c0\u306e\u982d\u306e\u30da\u30fc\u30b8\u304c\u306a\u304f\u3066PE\u30bb\u30af\u30b7\u30e7\u30f3\u30de\u30c3\u30d4\u30f3\u30b0\u304c\u53d6\u5f97\u3067\u304d\u306a\u3044\u5834\u5408\u306b\u554f\u984c\u3068\u306a\u308a\u307e\u3059\u3002\u3053\u306e\u3088\u3046\u306a\u5834\u5408\u3067\u3082\u3001vaddump\u30b3\u30de\u30f3\u30c9\u3067\u306f\u30e1\u30e2\u30ea\u30bb\u30b0\u30e1\u30f3\u30c8\u3092\u62bd\u51fa\u3067\u304d\u307e\u3059\u304c\u3001(IDA Pro\u3067\u89e3\u6790\u3057\u3088\u3046\u3068\u3057\u3066\u3044\u308b\u306a\u3089)\u201dRecovering CoreFlood Binaries with Volatility\u201d\u3067\u89e3\u8aac\u3057\u3066\u3044\u308b\u3088\u3046\u306bPE\u30d8\u30c3\u30c0\u3092\u518d\u69cb\u7bc9\u3057\u3066\u30bb\u30af\u30b7\u30e7\u30f3\u3092\u4fee\u5fa9\u3059\u308b\u5fc5\u8981\u304c\u3042\u308a\u307e\u3059\u3002\n\nTo dump a PE file that doesn't exist in the DLLs list (for example, due to code injection or malicious unlinking), just specify the base address of the PE in process memory:\n\n(\u30b3\u30fc\u30c9\u30a4\u30f3\u30b8\u30a7\u30af\u30b7\u30e7\u30f3\u3084\u60aa\u610f\u306b\u3088\u3063\u3066\u30ea\u30f3\u30af\u3092\u5916\u3055\u308c\u3066\u3044\u308b\u3088\u3046\u306a\u5834\u5408\u306a\u3069)DLL\u30ea\u30b9\u30c8\u306b\u306a\u3044PE\u30d5\u30a1\u30a4\u30eb\u3092\u30c0\u30f3\u30d7\u3059\u308b\u306b\u306f\u3001\u30d7\u30ed\u30bb\u30b9\u30e1\u30e2\u30ea\u4e2d\u306ePE\u306e\u30d9\u30fc\u30b9\u30a2\u30c9\u30ec\u30b9\u3092\u6307\u5b9a\u3057\u307e\u3059\u3002\n$ python vol.py --profile=Win7SP0x86 -f win7.dmp dlldump --pid=492 -D out --base=0x00680000\n\n\nYou can also specify an EPROCESS offset if the DLL you want is in a hidden process:\n\n\u96a0\u853d\u3055\u308c\u305f\u30d7\u30ed\u30bb\u30b9\u5185\u306eDLL\u3092\u30c0\u30f3\u30d7\u3057\u305f\u3044\u5834\u5408\u3001EPROCESS\u306e\u30aa\u30d5\u30bb\u30c3\u30c8\u3092\u6307\u5b9a\u3059\u308b\u3053\u3068\u3082\u3067\u304d\u307e\u3059\u3002\n$ python vol.py --profile=Win7SP0x86 -f win7.dmp dlldump -o 0x3e3f64e8 -D out --base=0x00680000\n\n\nhandles\n\nTo display the open handles in a process, use the handles command. This applies to files, registry keys, mutexes, named pipes, events, window stations, desktops, threads, and all other types of securable executive objects. As of 2.1, the output includes handle value and granted access for each object.\n\nhandles\u30b3\u30de\u30f3\u30c9\u3067\u30d7\u30ed\u30bb\u30b9\u304c\u30aa\u30fc\u30d7\u30f3\u3057\u3066\u3044\u308b\u30cf\u30f3\u30c9\u30eb\u3092\u8868\u793a\u3067\u304d\u307e\u3059\u3002\u30d5\u30a1\u30a4\u30eb\u3001\u30ec\u30b8\u30b9\u30c8\u30ea\u30ad\u30fc\u3001\u30df\u30e5\u30fc\u30c6\u30c3\u30af\u30b9\u3001\u540d\u524d\u4ed8\u304d\u30d1\u30a4\u30d7\u3001\u30a4\u30d9\u30f3\u30c8\u3001\u30a6\u30a3\u30f3\u30c9\u30a6\u30b9\u30c6\u30fc\u30b7\u30e7\u30f3\u3001\u30c7\u30b9\u30af\u30c8\u30c3\u30d7\u3001\u30b9\u30ec\u30c3\u30c9\u3001\u4ed6\u306e\u3059\u3079\u3066\u306eSecurable executive objects\u306b\u9069\u7528\u3055\u308c\u307e\u3059\u3002\u30d0\u30fc\u30b8\u30e7\u30f32.1\u304b\u3089\u3001\u30cf\u30f3\u30c9\u30eb\u306e\u5024\u3068\u8a31\u3055\u308c\u308b\u30a2\u30af\u30bb\u30b9\u304c\u305d\u308c\u305e\u308c\u306e\u30aa\u30d6\u30b8\u30a7\u30af\u30c8\u306b\u8868\u793a\u3055\u308c\u308b\u3088\u3046\u306b\u306a\u308a\u307e\u3057\u305f\u3002\n$ python vol.py -f ~/Desktop/win7_trial_64bit.raw --profile=Win7SP0x64 handles\nVolatility Foundation Volatility Framework 2.4\nOffset(V)             Pid             Handle             Access Type             Details\n------------------ ------ ------------------ ------------------ ---------------- -------\n0xfffffa80004b09e0      4                0x4           0x1fffff Process          System(4)\n0xfffff8a0000821a0      4               0x10            0x2001f Key              MACHINE\\SYSTEM\\CONTROLSET001\\CONTROL\\PRODUCTOPTIONS\n0xfffff8a00007e040      4               0x14            0xf003f Key              MACHINE\\SYSTEM\\CONTROLSET001\\CONTROL\\SESSION MANAGER\\MEMORY MANAGEMENT\\PREFETCHPARAMETERS\n0xfffff8a000081fa0      4               0x18            0x2001f Key              MACHINE\\SYSTEM\\SETUP\n0xfffffa8000546990      4               0x1c           0x1f0001 ALPC Port        PowerMonitorPort\n0xfffffa800054d070      4               0x20           0x1f0001 ALPC Port        PowerPort\n0xfffff8a0000676a0      4               0x24            0x20019 Key              MACHINE\\HARDWARE\\DESCRIPTION\\SYSTEM\\MULTIFUNCTIONADAPTER\n0xfffffa8000625460      4               0x28           0x1fffff Thread           TID 160 PID 4\n0xfffff8a00007f400      4               0x2c            0xf003f Key              MACHINE\\SYSTEM\\CONTROLSET001\n0xfffff8a00007f200      4               0x30            0xf003f Key              MACHINE\\SYSTEM\\CONTROLSET001\\ENUM\n0xfffff8a000080d10      4               0x34            0xf003f Key              MACHINE\\SYSTEM\\CONTROLSET001\\CONTROL\\CLASS\n0xfffff8a00007f500      4               0x38            0xf003f Key              MACHINE\\SYSTEM\\CONTROLSET001\\SERVICES\n0xfffff8a0001cd990      4               0x3c                0xe Token\n0xfffff8a00007bfa0      4               0x40            0x20019 Key              MACHINE\\SYSTEM\\CONTROLSET001\\CONTROL\\WMI\\SECURITY\n0xfffffa8000cd52b0      4               0x44           0x120116 File             \\Device\\Mup\n0xfffffa8000ce97f0      4               0x48               0x2a Process          smss.exe(208)\n0xfffffa8000df16f0      4               0x4c           0x120089 File             \\Device\\HarddiskVolume2\\Windows\\System32\\en-US\\win32k.sys.mui\n0xfffffa8000de37f0      4               0x50           0x12019f File             \\Device\\clfsTxfLog\n0xfffff8a000952fa0      4               0x54            0x2001f Key              MACHINE\\SYSTEM\\CONTROLSET001\\CONTROL\\VIDEO\\{6A8FC9DC-A76B-47FC-A703-17800182E1CE}\\0000\\VOLATILESETTINGS\n0xfffffa800078da20      4               0x58           0x12019f File             \\Device\\Tcp\n0xfffff8a002e17610      4               0x5c                0x9 Key              MACHINE\\SOFTWARE\\MICROSOFT\\WINDOWS NT\\CURRENTVERSION\\IMAGE FILE EXECUTION OPTIONS\n0xfffff8a0008f7b00      4               0x60               0x10 Key              MACHINE\\SYSTEM\\CONTROLSET001\\CONTROL\\LSA\n0xfffffa8000da2870      4               0x64           0x100001 File             \\Device\\KsecDD\n0xfffffa8000da3040      4               0x68                0x0 Thread           TID 228 PID 4\n...\n\n\nYou can display handles for a particular process by specifying --pid=PID or the physical offset of an EPROCESS structure (--physical-offset=OFFSET). You can also filter by object type using -t or --object-type=OBJECTTYPE. For example to only display handles to process objects for pid 600, do the following:\n\n--pid=PID\u3082\u3057\u304f\u306fEPROCESS\u69cb\u9020\u4f53\u306e\u7269\u7406\u30a2\u30c9\u30ec\u30b9\u3092--physical-offset=OFFSET\u3068\u3044\u3046\u30aa\u30d7\u30b7\u30e7\u30f3\u3067\u6307\u5b9a\u3059\u308b\u3053\u3068\u306b\u3088\u308a\u3001\u7279\u5b9a\u306e\u30d7\u30ed\u30bb\u30b9\u306e\u30cf\u30f3\u30c9\u30eb\u306e\u307f\u3092\u8868\u793a\u3055\u305b\u308b\u3053\u3068\u304c\u3067\u304d\u307e\u3059\u3002-t\u3082\u3057\u304f\u306f--object-type=OBJECTTYPE\u30aa\u30d7\u30b7\u30e7\u30f3\u3067\u3001\u30aa\u30d6\u30b8\u30a7\u30af\u30c8\u3092\u30d5\u30a3\u30eb\u30bf\u3059\u308b\u3053\u3068\u304c\u3067\u304d\u307e\u3059\u3002pid 600(\u30de\u30de)\u306e\u30d7\u30ed\u30bb\u30b9\u306e\u30cf\u30f3\u30c9\u30eb\u306e\u307f\u3092\u8868\u793a\u3057\u305f\u3044\u5834\u5408\u306f\u3001\u6b21\u306e\u3088\u3046\u306b\u3057\u307e\u3059\u3002\n$ python vol.py -f ~/Desktop/win7_trial_64bit.raw --profile=Win7SP0x64 handles -p 296 -t Process\nVolatility Foundation Volatility Framework 2.4\nOffset(V)             Pid             Handle             Access Type             Details\n------------------ ------ ------------------ ------------------ ---------------- -------\n0xfffffa8000c92300    296               0x54           0x1fffff Process          wininit.exe(332)\n0xfffffa8000c5eb30    296               0xc4           0x1fffff Process          services.exe(428)\n0xfffffa80011c5700    296               0xd4           0x1fffff Process          lsass.exe(444)\n0xfffffa8000ea31b0    296               0xe4           0x1fffff Process          lsm.exe(452)\n0xfffffa8000c64840    296              0x140           0x1fffff Process          svchost.exe(348)\n0xfffffa8001296b30    296              0x150           0x1fffff Process          svchost.exe(568)\n0xfffffa80012c3620    296              0x18c           0x1fffff Process          svchost.exe(628)\n0xfffffa8001325950    296              0x1dc           0x1fffff Process          sppsvc.exe(816)\n...\n\n\nThe object type can be any of the names printed by the \"object \\ObjectTypes\" windbg command (see Enumerate Object Types for more details.\n\n\u30aa\u30d6\u30b8\u30a7\u30af\u30c8\u30bf\u30a4\u30d7\u306f\u3001windbg\u30b3\u30de\u30f3\u30c9\u306eobject/ObjecTypes\u3067\u8868\u793a\u3055\u308c\u308b\u30bf\u30a4\u30d7\u3067\u3059\u3002(\"numerate Object Types\"\u53c2\u7167)\n\nIn some cases, the Details column will be blank (for example, if the objects don't have names). By default, you'll see both named and un-named objects. However, if you want to hide the less meaningful results and only show named objects, use the --silent parameter to this plugin.\n\n\u8a73\u7d30\u30ab\u30e9\u30e0\u304c\u30d6\u30e9\u30f3\u30af\u8868\u793a\u3055\u308c\u308b\u5834\u5408\u3082\u3042\u308a\u307e\u3059(\u30aa\u30d6\u30b8\u30a7\u30af\u30c8\u304c\u540d\u524d\u3092\u6301\u305f\u306a\u3044\u5834\u5408\u306a\u3069)\u3002\u30c7\u30d5\u30a9\u30eb\u30c8\u3067\u306f\u3001\u540d\u524d\u4ed8\u304d\u3068\u540d\u524d\u7121\u3057\u306e\u4e21\u65b9\u306e\u30aa\u30d6\u30b8\u30a7\u30af\u30c8\u304c\u8868\u793a\u3055\u308c\u307e\u3059\u3002\u540d\u524d\u3064\u304d\u30aa\u30d6\u30b8\u30a7\u30af\u30c8\u306e\u307f\u8868\u793a\u3057\u3066\u3001\u3042\u307e\u308a\u610f\u5473\u304c\u306a\u3044\u30aa\u30d6\u30b8\u30a7\u30af\u30c8\u3092\u975e\u8868\u793a\u306b\u3057\u305f\u3044\u5834\u5408\u306f\u3001--silent\u30aa\u30d7\u30b7\u30e7\u30f3\u3092\u6307\u5b9a\u3057\u3066\u304f\u3060\u3055\u3044\u3002\n\ngetsids\n\nTo view the SIDs (Security Identifiers) associated with a process, use the getsids command. Among other things, this can help you identify processes which have maliciously escalated privileges and which processes belong to specific users.\n\ngetsids\u30b3\u30de\u30f3\u30c9\u3067\u3001\u30d7\u30ed\u30bb\u30b9\u306b\u95a2\u9023\u3057\u305fSIDs(Security Identifiers)\u3092\u8868\u793a\u3067\u304d\u307e\u3059\u3002\u3053\u308c\u306b\u3088\u308a\u3001\u60aa\u610f\u3092\u6301\u3063\u3066\u6a29\u9650\u6607\u683c\u3092\u3057\u305f\u30d7\u30ed\u30bb\u30b9\u3068\u7279\u5b9a\u306e\u30e6\u30fc\u30b6\u306b\u5c5e\u3059\u308b\u30d7\u30ed\u30bb\u30b9\u3092\u8b58\u5225\u3059\u308b\u306e\u306b\u5f79\u7acb\u3061\u307e\u3059\u3002\n\nFor more information, see BDG's Linking Processes To Users.\n\n\u8a73\u3057\u304f\u306f\u3001\"BDG's Linking Processes To Users\"\u3092\u53c2\u7167\u3002\n$ python vol.py -f ~/Desktop/win7_trial_64bit.raw --profile=Win7SP0x64 getsids\nVolatility Foundation Volatility Framework 2.4\nSystem (4): S-1-5-18 (Local System)\nSystem (4): S-1-5-32-544 (Administrators)\nSystem (4): S-1-1-0 (Everyone)\nSystem (4): S-1-5-11 (Authenticated Users)\nSystem (4): S-1-16-16384 (System Mandatory Level)\nsmss.exe (208): S-1-5-18 (Local System)\nsmss.exe (208): S-1-5-32-544 (Administrators)\nsmss.exe (208): S-1-1-0 (Everyone)\nsmss.exe (208): S-1-5-11 (Authenticated Users)\nsmss.exe (208): S-1-16-16384 (System Mandatory Level)\n[snip]\n\n\ncmdscan\n\nThe cmdscan plugin searches the memory of csrss.exe on XP/2003/Vista/2008 and conhost.exe on Windows 7 for commands that attackers entered through a console shell (cmd.exe). This is one of the most powerful commands you can use to gain visibility into an attackers actions on a victim system, whether they opened cmd.exe through an RDP session or proxied input/output to a command shell from a networked backdoor.\n\ncmdscan\u306f\u3001XP/2003/Vista/2008\u3067\u306fcsrss.exe\u3001Windows 7\u3067\u306fconhost.exe\u306e\u30e1\u30e2\u30ea\u304b\u3089\u3001\u653b\u6483\u8005\u304c\u30b3\u30f3\u30bd\u30fc\u30eb\u30b7\u30a7\u30eb(cmd.exe)\u3067\u5165\u529b\u3057\u305f\u30b3\u30de\u30f3\u30c9\u3092\u63a2\u7d22\u3057\u307e\u3059\u3002\u3053\u308c\u306f\u88ab\u5bb3\u3092\u53d7\u3051\u305f\u30b7\u30b9\u30c6\u30e0\u3067\u653b\u6483\u8005\u306e\u884c\u52d5\u306b\u3064\u3044\u3066\u53ef\u8996\u5316\u3092\u884c\u3046\u305f\u3081\u306e\u6700\u3082\u5f37\u529b\u306a\u30b3\u30de\u30f3\u30c9\u306e\u3072\u3068\u3064\u3067\u3059\u3002\u653b\u6483\u8005\u304ccmd.exe\u3092\u4f7f\u7528\u3057\u305f\u5834\u5408\u3001RDP\u30bb\u30c3\u30b7\u30e7\u30f3\u7d4c\u7531\u306e\u5834\u5408\u3001\u30a4\u30f3\u30d7\u30c3\u30c8\u3068\u30a2\u30a6\u30c8\u30d7\u30c3\u30c8\u306e\u30d7\u30ed\u30ad\u30b7\u3092\u884c\u3046\u30d0\u30c3\u30af\u30c9\u30a2\u306b\u3088\u3063\u3066\u30cd\u30c3\u30c8\u30ef\u30fc\u30af\u7d4c\u7531\u3067\u30b3\u30de\u30f3\u30c9\u30b7\u30a7\u30eb\u3092\u4f7f\u3063\u305f\u5834\u5408\u3067\u3082\u6709\u52b9\u3067\u3059\u3002\n\nThis plugin finds structures known as COMMAND_HISTORY by looking for a known constant value (MaxHistory) and then applying sanity checks. It is important to note that the MaxHistory value can be changed by right clicking in the top left of a cmd.exe window and going to Properties. The value can also be changed for all consoles opened by a given user by modifying the registry key HKCU\\Console\\HistoryBufferSize. The default is 50 on Windows systems, meaning the most recent 50 commands are saved. You can tweak it if needed by using the --max_history=NUMBER parameter.\n\n\u3053\u306e\u30d7\u30e9\u30b0\u30a4\u30f3\u306f\u3001\u65e2\u306b\u77e5\u3089\u308c\u3066\u3044\u308b\u56fa\u5b9a\u5024(MaxHistory)\u304b\u3089\u3001COMMAND_HISTORY\u3068\u547c\u3070\u308c\u308b\u69cb\u9020\u4f53\u3092\u898b\u3064\u3051\u3001\u6b63\u5e38\u304b\u3069\u3046\u304b\u30c1\u30a7\u30c3\u30af\u3057\u307e\u3059\u3002cmd.exe\u306e\u30a6\u30a3\u30f3\u30c9\u30a6\u306e\u4e0a\u90e8\u30d0\u30fc\u3092\u30e9\u30a4\u30c8\u30af\u30ea\u30c3\u30af\u3059\u308b\u3053\u3068\u306b\u3088\u3063\u3066\u30d7\u30ed\u30d1\u30c6\u30a3\u3092\u5909\u66f4\u3059\u308b\u3068\u3001MaxHistory\u306e\u5024\u304c\u5909\u308f\u308b\u3053\u3068\u306f\u91cd\u8981\u3067\u3059\u3002\u30ec\u30b8\u30b9\u30c8\u30ea\u30ad\u30fcHKCU\\Console\\HistoryBufferSize\u3092\u5909\u66f4\u3059\u308b\u3053\u3068\u306b\u3088\u3063\u3066\u30e6\u30fc\u30b6\u306e\u3059\u3079\u3066\u306e\u30b3\u30f3\u30bd\u30fc\u30eb\u306eMaxHistory\u306e\u5024\u304c\u5909\u66f4\u3055\u308c\u308b\u3053\u3068\u3082\u3042\u308a\u307e\u3059\u3002\n\u30c7\u30d5\u30a9\u30eb\u30c8\u3067\u306f50\u3068\u306a\u3063\u3066\u304a\u308a\u3001\u76f4\u8fd1\u306e50\u30b3\u30de\u30f3\u30c9\u304c\u8a18\u9332\u3055\u308c\u307e\u3059\u3002\u5fc5\u8981\u304c\u3042\u308c\u3070\u3001--max_history=NUMBER\u30aa\u30d7\u30b7\u30e7\u30f3\u3067\u3001\u8abf\u6574\u3059\u308b\u3053\u3068\u304c\u3067\u304d\u307e\u3059\u3002\n\nThe structures used by this plugin are not public (i.e. Microsoft does not produce PDBs for them), thus they're not available in WinDBG or any other forensic framework. They were reverse engineered by Michael Ligh from the conhost.exe and winsrv.dll binaries.\n\n\u3053\u306e\u30d7\u30e9\u30b0\u30a4\u30f3\u304c\u5229\u7528\u3057\u3066\u3044\u308b\u69cb\u9020\u4f53\u306f\u516c\u5f0f\u306e\u3082\u306e\u3067\u306f\u3042\u308a\u307e\u305b\u3093(\u30de\u30a4\u30af\u30ed\u30bd\u30d5\u30c8\u306f\u3001PDBs\u306e\u69cb\u9020\u306a\u3069\u3092\u516c\u958b\u3057\u3066\u3044\u307e\u305b\u3093)\u306e\u3067\u3001WinDBG\u3084\u305d\u306e\u4ed6\u306e\u30d5\u30a9\u30ec\u30f3\u30b8\u30c3\u30af\u30d5\u30ec\u30fc\u30e0\u30ef\u30fc\u30af\u3067\u306f\u5229\u7528\u3067\u304d\u307e\u305b\u3093\u3002Michael Ligh\u304cconhost.exe\u3068winsrv.dll\u306e\u30d0\u30a4\u30ca\u30ea\u304b\u3089\u30ea\u30d0\u30fc\u30b9\u30a8\u30f3\u30b8\u30cb\u30a2\u30ea\u30f3\u30b0\u3057\u305f\u3082\u306e\u3067\u3059\u3002\n\nIn addition to the commands entered into a shell, this plugin shows:\n\n\u30b7\u30a7\u30eb\u3092\u8abf\u67fb\u3059\u308b\u3060\u3051\u3067\u306f\u306a\u304f\u3001\u4ee5\u4e0b\u306e\u60c5\u5831\u3092\u8868\u793a\u3057\u307e\u3059\u3002\n\n\nThe name of the console host process (csrss.exe or conhost.exe)\nThe name of the application using the console (whatever process is using cmd.exe)\nThe location of the command history buffers, including the current buffer count, last added command, and last displayed command\nThe application process handle\n\n\n\n\u30b3\u30f3\u30bd\u30fc\u30eb\u30db\u30b9\u30c8\u30d7\u30ed\u30bb\u30b9\u306e\u540d\u79f0(csrss.exe\u304bconhost.exe)\n\u30b3\u30f3\u30bd\u30fc\u30eb\u3092\u4f7f\u3063\u3066\u3044\u308b\u30a2\u30d7\u30ea\u30b1\u30fc\u30b7\u30e7\u30f3\u306e\u540d\u79f0(cmd.exe\u3092\u4f7f\u3063\u3066\u3044\u308b\u3069\u3093\u306a\u30d7\u30ed\u30bb\u30b9\u3067\u3082)\n\u73fe\u5728\u306e\u30d0\u30c3\u30d5\u30a1\u6570\u3001\u6700\u5f8c\u306b\u8ffd\u52a0\u3055\u308c\u305f\u30b3\u30de\u30f3\u30c9\u3001\u6700\u5f8c\u306b\u8868\u793a\u3055\u308c\u305f\u30b3\u30de\u30f3\u30c9\u3092\u542b\u3080\u30b3\u30de\u30f3\u30c9\u30d2\u30b9\u30c8\u30ea\u30d0\u30c3\u30d5\u30a1\u306e\u4f4d\u7f6e\n\u30a2\u30d7\u30ea\u30b1\u30fc\u30b7\u30e7\u30f3\u30d7\u30ed\u30bb\u30b9\u306e\u30cf\u30f3\u30c9\u30eb\n\n\nDue to the scanning technique this plugin uses, it has the capability to find commands from both active and closed consoles.\n\n\u30b9\u30ad\u30e3\u30f3\u30c6\u30af\u30cb\u30c3\u30af\u3092\u5229\u7528\u3059\u308b\u3053\u3068\u306b\u3088\u308a\u3001\u30a2\u30af\u30c6\u30a3\u30d6\u3068\u9589\u3058\u3089\u308c\u305f\u30b3\u30f3\u30bd\u30fc\u30eb\u306e\u4e21\u65b9\u304b\u3089\u30b3\u30de\u30f3\u30c9\u3092\u898b\u3064\u3051\u51fa\u3059\u3053\u3068\u304c\u3067\u304d\u307e\u3059\u3002\n$ python vol.py -f VistaSP2x64.vmem --profile=VistaSP2x64 cmdscan\nVolatility Foundation Volatility Framework 2.4\n\n**************************************************\nCommandProcess: csrss.exe Pid: 528\nCommandHistory: 0x135ec00 Application: cmd.exe Flags: Allocated, Reset\nCommandCount: 18 LastAdded: 17 LastDisplayed: 17\nFirstCommand: 0 CommandCountMax: 50\nProcessHandle: 0x330\nCmd #0 @ 0x135ef10: cd \\\nCmd #1 @ 0x135ef50: cd de\nCmd #2 @ 0x135ef70: cd PerfLogs\nCmd #3 @ 0x135ef90: cd ..\nCmd #4 @ 0x5c78b90: cd \"Program Files\"\nCmd #5 @ 0x135fae0: cd \"Debugging Tools for Windows (x64)\"\nCmd #6 @ 0x135efb0: livekd -w\nCmd #7 @ 0x135f010: windbg\nCmd #8 @ 0x135efd0: cd \\\nCmd #9 @ 0x135fd20: rundll32 c:\\apphelp.dll,ExportFunc\nCmd #10 @ 0x5c8bdb0: rundll32 c:\\windows_apphelp.dll,ExportFunc\nCmd #11 @ 0x5c8be10: rundll32 c:\\windows_apphelp.dll\nCmd #12 @ 0x135ee30: rundll32 c:\\windows_apphelp.dll,Test\nCmd #13 @ 0x135fd70: cd \"Program Files\"\nCmd #14 @ 0x5c8b9e0: dir\nCmd #15 @ 0x5c8be60: cd \"Debugging Tools for Windows (x64)\"\nCmd #16 @ 0x5c8ba00: dir\nCmd #17 @ 0x135eff0: livekd -w\n\n[snip]\n\n\nFor background information, see Richard Stevens and Eoghan Casey's Extracting Windows Cmd Line Details from Physical Memory.\n\n\u80cc\u666f\u77e5\u8b58\u3068\u3057\u3066\u3001\"Richard Stevens and Eoghan Casey's Extracting Windows Cmd Line Details from Physical Memory\"\u3092\u53c2\u7167\u3002\n\nconsoles\n\nSimilar to cmdscan the consoles plugin finds commands that attackers typed into cmd.exe or executed via backdoors. However, instead of scanning for COMMAND_HISTORY, this plugin scans for CONSOLE_INFORMATION. The major advantage to this plugin is it not only prints the commands attackers typed, but it collects the entire screen buffer (input and output). For instance, instead of just seeing \"dir\", you'll see exactly what the attacker saw, including all files and directories listed by the \"dir\" command.\n\ncmdscan\u3068\u540c\u69d8\u306b\u3001comsoles\u30d7\u30e9\u30b0\u30a4\u30f3\u306f\u3001\u653b\u6483\u8005\u304ccmd.exe\u306b\u30bf\u30a4\u30d7\u3057\u305f\u304b\u30d0\u30c3\u30af\u30c9\u30a2\u7d4c\u7531\u3067\u5b9f\u884c\u3057\u305f\u30b3\u30de\u30f3\u30c9\u3092\u63a2\u3057\u3060\u3057\u307e\u3059\u3002COMMAND_HISTORY\u3092\u30b9\u30ad\u30e3\u30f3\u3059\u308b\u306e\u3067\u306f\u306a\u304f\u3001\u3053\u306e\u30d7\u30e9\u30b0\u30a4\u30f3\u3067\u306f\u3001CONSOLE_INFORMATION\u3092\u30b9\u30ad\u30e3\u30f3\u3057\u307e\u3059\u3002\u653b\u6483\u8005\u304c\u30bf\u30a4\u30d7\u3057\u305f\u30b3\u30de\u30f3\u30c9\u3060\u3051\u3067\u306f\u306a\u304f\u3001\u30b9\u30af\u30ea\u30fc\u30f3\u30d0\u30c3\u30d5\u30a1\u5168\u4f53(\u30a4\u30f3\u30d7\u30c3\u30c8\u3068\u30a2\u30a6\u30c8\u30d7\u30c3\u30c8)\u3092\u53d6\u5f97\u3067\u304d\u308b\u3068\u3053\u308d\u304c\u512a\u308c\u3066\u3044\u307e\u3059\u3002\u4f8b\u3048\u3070\u3001\u5358\u306b\"dir\"\u3068\u8868\u793a\u3055\u308c\u308b\u3060\u3051\u3067\u306f\u306a\u304f\u3001dir\u30b3\u30de\u30f3\u30c9\u304c\u8868\u793a\u3057\u305f\u30d5\u30a1\u30a4\u30eb\u3068\u30c7\u30a3\u30ec\u30af\u30c8\u30ea\u306e\u30ea\u30b9\u30c8\u3092\u542b\u3080\u3001\u653b\u6483\u8005\u304c\u898b\u305f\u307e\u307e\u3092\u6b63\u78ba\u306b\u8868\u793a\u3059\u308b\u3053\u3068\u304c\u3067\u304d\u307e\u3059\u3002\n\nAdditionally, this plugin prints the following:\n\n\u66f4\u306b\u3001\u3053\u306e\u30d7\u30e9\u30b0\u30a4\u30f3\u3067\u306f\u4ee5\u4e0b\u306e\u8868\u793a\u3092\u884c\u3044\u307e\u3059\u3002\n\n\nThe original console window title and current console window title\nThe name and pid of attached processes (walks a LIST_ENTRY to enumerate all of them if more than one)\nAny aliases associated with the commands executed. For example, attackers can register an alias such that typing \"hello\" actually executes \"cd system\"\nThe screen coordinates of the cmd.exe console\n\n\n\n\u30aa\u30ea\u30b8\u30ca\u30eb\u306e\u30b3\u30f3\u30bd\u30fc\u30eb\u30a6\u30a3\u30f3\u30c9\u30a6\u30bf\u30a4\u30c8\u30eb\u3068\u73fe\u5728\u306e\u30a6\u30a3\u30f3\u30c9\u30a6\u30bf\u30a4\u30c8\u30eb\n\u30a2\u30bf\u30c3\u30c1\u3055\u308c\u305f\u30d7\u30ed\u30bb\u30b9\u306e\u540d\u524d\u3068pid(LIST_ENTRY\u3092\u305f\u3069\u3063\u3066\u5217\u6319\u3057\u307e\u3059)\n\u5b9f\u884c\u3055\u308c\u305f\u30b3\u30de\u30f3\u30c9\u306b\u7d50\u3073\u4ed8\u3051\u3089\u308c\u305f\u30a8\u30a4\u30ea\u30a2\u30b9\u3002\u4f8b\u3048\u3070\u3001\u653b\u6483\u8005\u306f\"hello\"\u3068\u30bf\u30a4\u30d7\u3059\u308b\u3068\u3001\"cd system\"\u304c\u5b9f\u969b\u306b\u306f\u5b9f\u884c\u3055\u308c\u308b\u3088\u3046\u306b\u30a8\u30a4\u30ea\u30a2\u30b9\u3068\u767b\u9332\u3059\u308b\u3053\u3068\u304c\u3067\u304d\u308b\n*\u3000cmd.exe\u30b3\u30f3\u30bd\u30fc\u30eb\u306e\u30b9\u30af\u30ea\u30fc\u30f3\u8abf\u6574\n\n\nHere's an example of the consoles command. Below, you'll notice something quite funny. The forensic investigator seems to have lost his mind and cannot find the dd.exe tool for dumping memory. Nearly 20 typos later, he finds the tool and uses it.\n\n\u3053\u308c\u306fconsoles\u30b3\u30de\u30f3\u30c9\u306e\u4f8b\u3067\u3059\u3002\u4e0b\u3092\u898b\u308b\u3068\u3001\u304a\u304b\u3057\u306a\u3053\u3068\u306b\u6c17\u3065\u304f\u3067\u3057\u3087\u3046\u3002\u30d5\u30a9\u30ec\u30f3\u30b8\u30c3\u30af\u8abf\u67fb\u8005\u306f\u3001\u6b63\u6c17\u3092\u5931\u3063\u305f\u3088\u3046\u3067\u3001\u30e1\u30e2\u30ea\u3092\u30c0\u30f3\u30d7\u3059\u308b\u305f\u3081\u306edd.exe\u30c4\u30fc\u30eb\u304c\u898b\u3064\u3051\u3089\u308c\u307e\u305b\u3093\u300220\u56de\u8fd1\u304f\u306e\u5165\u529b\u30df\u30b9\u306e\u3042\u3068\u3001\u30c4\u30fc\u30eb\u3092\u898b\u3064\u3051\u3066\u5b9f\u884c\u3057\u307e\u3057\u305f\u3002\n$ python vol.py -f xp-laptop-2005-07-04-1430.img consoles\nVolatility Foundation Volatility Framework 2.4\n\n[csrss.exe @ 0x821c11a8 pid 456 console @ 0x4e23b0]\n  OriginalTitle: '%SystemRoot%\\\\system32\\\\cmd.exe'\n  Title: 'C:\\\\WINDOWS\\\\system32\\\\cmd.exe - dd if=\\\\\\\\.\\\\PhysicalMemory of=c:\\\\xp-2005-07-04-1430.img conv=noerror'\n  HistoryBufferCount: 2\n  HistoryBufferMax: 4\n  CommandHistorySize: 50\n[history @ 0x4e4008]\n  CommandCount: 0\n  CommandCountMax: 50\n  Application: 'dd.exe'\n[history @ 0x4e4d88]\n  CommandCount: 20\n  CommandCountMax: 50\n  Application: 'cmd.exe'\n  Cmd #0 @ 0x4e1f90: 'dd'\n  Cmd #1 @ 0x4e2cb8: 'cd\\\\'\n  Cmd #2 @ 0x4e2d18: 'dr'\n  Cmd #3 @ 0x4e2d28: 'ee:'\n  Cmd #4 @ 0x4e2d38: 'e;'\n  Cmd #5 @ 0x4e2d48: 'e:'\n  Cmd #6 @ 0x4e2d58: 'dr'\n  Cmd #7 @ 0x4e2d68: 'd;'\n  Cmd #8 @ 0x4e2d78: 'd:'\n  Cmd #9 @ 0x4e2d88: 'dr'\n  Cmd #10 @ 0x4e2d98: 'ls'\n  Cmd #11 @ 0x4e2da8: 'cd Docu'\n  Cmd #12 @ 0x4e2dc0: 'cd Documents and'\n  Cmd #13 @ 0x4e2e58: 'dr'\n  Cmd #14 @ 0x4e2e68: 'd:'\n  Cmd #15 @ 0x4e2e78: 'cd dd\\\\'\n  Cmd #16 @ 0x4e2e90: 'cd UnicodeRelease'\n  Cmd #17 @ 0x4e2ec0: 'dr'\n  Cmd #18 @ 0x4e2ed0: 'dd '\n  Cmd #19 @ 0x4e4100: 'dd if=\\\\\\\\.\\\\PhysicalMemory of=c:\\\\xp-2005-07-04-1430.img conv=noerror'\n[screen @ 0x4e2460 X:80 Y:300]\n  Output: Microsoft Windows XP [Version 5.1.2600]\n  Output: (C) Copyright 1985-2001 Microsoft Corp.\n  Output:\n  Output: C:\\Documents and Settings\\Sarah>dd\n  Output: 'dd' is not recognized as an internal or external command,\n  Output: operable program or batch file.\n  Output:\n  Output: C:\\Documents and Settings\\Sarah>cd\\\n  Output:\n  Output: C:\\>dr\n  Output: 'dr' is not recognized as an internal or external command,\n  Output: operable program or batch file.\n  Output:\n  Output: C:\\>ee:\n  Output: 'ee:' is not recognized as an internal or external command,\n  Output: operable program or batch file.\n  Output:\n  Output: C:\\>e;\n  Output: 'e' is not recognized as an internal or external command,\n  Output: operable program or batch file.\n  Output:\n  Output: C:\\>e:\n  Output: The system cannot find the drive specified.\n  Output:\n  Output: C:\\>dr\n  Output: 'dr' is not recognized as an internal or external command,\n  Output: operable program or batch file.\n  Output:\n  Output: C:\\>d;\n  Output: 'd' is not recognized as an internal or external command,\n  Output: operable program or batch file.\n  Output:\n  Output: C:\\>d:\n  Output:\n  Output: D:\\>dr\n  Output: 'dr' is not recognized as an internal or external command,\n  Output: operable program or batch file.\n  Output:\n  Output: D:\\>dr\n  Output: 'dr' is not recognized as an internal or external command,\n  Output: operable program or batch file.\n  Output:\n  Output: D:\\>ls\n  Output: 'ls' is not recognized as an internal or external command,\n  Output: operable program or batch file.\n  Output:\n  Output: D:\\>cd Docu\n  Output: The system cannot find the path specified.\n  Output:\n  Output: D:\\>cd Documents and\n  Output: The system cannot find the path specified.\n  Output:\n  Output: D:\\>dr\n  Output: 'dr' is not recognized as an internal or external command,\n  Output: operable program or batch file.\n  Output:\n  Output: D:\\>d:\n  Output:\n  Output: D:\\>cd dd\\\n  Output:\n  Output: D:\\dd>\n  Output: D:\\dd>cd UnicodeRelease\n  Output:\n  Output: D:\\dd\\UnicodeRelease>dr\n  Output: 'dr' is not recognized as an internal or external command,\n  Output: operable program or batch file.\n  Output:\n  Output: D:\\dd\\UnicodeRelease>dd\n  Output:\n  Output: 0+0 records in\n  Output: 0+0 records out\n  Output: ^C\n  Output: D:\\dd\\UnicodeRelease>dd if=\\\\.\\PhysicalMemory of=c:\\xp-2005-07-04-1430.img conv=\n  Output: noerror\n  Output: Forensic Acquisition Utilities, 1, 0, 0, 1035\n  Output: dd, 3, 16, 2, 1035\n  Output: Copyright (C) 2002-2004 George M. Garner Jr.\n  Output:\n  Output: Command Line: dd if=\\\\.\\PhysicalMemory of=c:\\xp-2005-07-04-1430.img conv=noerror\n  Output:\n  Output: Based on original version developed by Paul Rubin, David MacKenzie, and Stuart K\n  Output: emp\n  Output: Microsoft Windows: Version 5.1 (Build 2600.Professional Service Pack 2)\n  Output:\n  Output: 04/07/2005  18:30:32 (UTC)\n  Output: 04/07/2005  14:30:32 (local time)\n  Output:\n  Output: Current User: SPLATITUDE\\Sarah\n  Output:\n  Output: Total physical memory reported: 523676 KB\n  Output: Copying physical memory...\n  Output: Physical memory in the range 0x00004000-0x00004000 could not be read.\n\n\nprivs\n\nThis plugin shows you which process privileges are present, enabled, and/or enabled by default. You can pass it the --silent flag to only show privileges that a process explicitly enabled (i.e. that were were not enabled by default but are currently enabled). The --regex=REGEX parameter can be used to filter for specific privilege names.\n\n\u3053\u306e\u30d7\u30e9\u30b0\u30a4\u30f3\u306f\u3001\u3069\u3093\u306a\u30d7\u30ed\u30bb\u30b9\u7279\u6a29\u304cPresent\u3001\u6709\u52b9\u5316\u3001\u30c7\u30d5\u30a9\u30eb\u30c8\u3067\u6709\u52b9\u5316\uff0f\u7121\u52b9\u5316\u3067\u3042\u308b\u304b\u3092\u8868\u793a\u3059\u308b\u3002--silent\u30aa\u30d7\u30b7\u30e7\u30f3\u3092\u6307\u5b9a\u3059\u308b\u3053\u3068\u3067\u3001\u660e\u793a\u7684\u306b\u6709\u52b9\u5316\u3055\u308c\u3066\u3044\u308b\u7279\u6a29\u306e\u307f\u3092\u8868\u793a\u3055\u305b\u308b\u3053\u3068\u304c\u3067\u304d\u308b(\u30c7\u30d5\u30a9\u30eb\u30c8\u3067\u306f\u7121\u52b9\u5316\u3055\u308c\u3066\u3044\u308b\u304c\u3001\u73fe\u5728\u6709\u52b9\u304b\u3055\u308c\u3066\u3044\u308b\u3082\u306e\u306a\u3069)\u3002--regex=REGEX\u30aa\u30d7\u30b7\u30e7\u30f3\u3067\u3001\u7279\u5b9a\u306e\u7279\u6a29\u306e\u307f\u3092\u30d5\u30a3\u30eb\u30bf\u3057\u3066\u8868\u793a\u3055\u305b\u308b\u3053\u3068\u304c\u3067\u304d\u308b\u3002\n$ python vol.py -f win7_trial_64bit.raw privs --profile=Win7SP0x64\nVolatility Foundation Volatility Framework 2.3_alpha\nPid      Process          Value  Privilege                            Attributes               Description\n-------- ---------------- ------ ------------------------------------ ------------------------ -----------\n       4 System                2 SeCreateTokenPrivilege               Present                  Create a token object\n       4 System                3 SeAssignPrimaryTokenPrivilege        Present                  Replace a process-level token\n       4 System                4 SeLockMemoryPrivilege                Present,Enabled,Default  Lock pages in memory\n       4 System                5 SeIncreaseQuotaPrivilege             Present                  Increase quotas\n       4 System                6 SeMachineAccountPrivilege                                     Add workstations to the domain\n       4 System                7 SeTcbPrivilege                       Present,Enabled,Default  Act as part of the operating system\n       4 System                8 SeSecurityPrivilege                  Present                  Manage auditing and security log\n       4 System                9 SeTakeOwnershipPrivilege             Present                  Take ownership of files/objects\n       4 System               10 SeLoadDriverPrivilege                Present                  Load and unload device drivers\n       4 System               11 SeSystemProfilePrivilege             Present,Enabled,Default  Profile system performance\n       4 System               12 SeSystemtimePrivilege                Present                  Change the system time\n       4 System               13 SeProfileSingleProcessPrivilege      Present,Enabled,Default  Profile a single process\n       4 System               14 SeIncreaseBasePriorityPrivilege      Present,Enabled,Default  Increase scheduling priority\n       4 System               15 SeCreatePagefilePrivilege            Present,Enabled,Default  Create a pagefile\n       4 System               16 SeCreatePermanentPrivilege           Present,Enabled,Default  Create permanent shared objects\n.....\n\n\nenvars\n\nTo display a process's environment variables, use the envars plugin. Typically this will show the number of CPUs installed and the hardware architecture (though the kdbgscan output is a much more reliable source), the process's current directory, temporary directory, session name, computer name, user name, and various other interesting artifacts.\n\nenvars\u30d7\u30e9\u30b0\u30a4\u30f3\u3067\u3001\u30d7\u30ed\u30bb\u30b9\u306e\u74b0\u5883\u5909\u6570\u3092\u8868\u793a\u3055\u305b\u308b\u3053\u3068\u304c\u3067\u304d\u308b\u3002\u5178\u578b\u7684\u306b\u306f\u3001CPU\u6570\u3068\u30cf\u30fc\u30c9\u30a6\u30a7\u30a2\u30a2\u30fc\u30ad\u30c6\u30af\u30c1\u30e3(kdbgscan\u306e\u51fa\u529b\u306f\u3001\u306f\u308b\u304b\u306b\u4fe1\u983c\u3067\u304d\u308b\u304c)\u3001\u30d7\u30ed\u30bb\u30b9\u306e\u30ab\u30ec\u30f3\u30c8\u30c7\u30a3\u30ec\u30af\u30c8\u30ea\u3001\u30c6\u30f3\u30dd\u30e9\u30ea\u30c7\u30a3\u30ec\u30af\u30c8\u30ea\u3001\u30bb\u30c3\u30b7\u30e7\u30f3\u540d\u3001\u30b3\u30f3\u30d4\u30e5\u30fc\u30bf\u540d\u3001\u30e6\u30fc\u30b6\u540d\u3001\u69d8\u3005\u306a\u5f79\u306b\u7acb\u3064\u60c5\u5831\u306a\u3069\u3092\u8868\u793a\u3059\u308b\u3002\n$ python vol.py -f ~/Desktop/win7_trial_64bit.raw --profile=Win7SP0x64 envars\nVolatility Foundation Volatility Framework 2.4\nPid      Process              Block              Variable                       Value\n-------- -------------------- ------------------ ------------------------------ -----\n     296 csrss.exe            0x00000000003d1320 ComSpec                        C:\\Windows\\system32\\cmd.exe\n     296 csrss.exe            0x00000000003d1320 FP_NO_HOST_CHECK               NO\n     296 csrss.exe            0x00000000003d1320 NUMBER_OF_PROCESSORS           1\n     296 csrss.exe            0x00000000003d1320 OS                             Windows_NT\n     296 csrss.exe            0x00000000003d1320 Path                           C:\\Windows\\system32;C:\\Windows;C:\\Windows\\System32\\Wbem;C:\\Windows\\System32\\WindowsPowerShell\\v1.0\\\n     296 csrss.exe            0x00000000003d1320 PATHEXT                        .COM;.EXE;.BAT;.CMD;.VBS;.VBE;.JS;.JSE;.WSF;.WSH;.MSC\n     296 csrss.exe            0x00000000003d1320 PROCESSOR_ARCHITECTURE         AMD64\n     296 csrss.exe            0x00000000003d1320 PROCESSOR_IDENTIFIER           Intel64 Family 6 Model 2 Stepping 3, GenuineIntel\n     296 csrss.exe            0x00000000003d1320 PROCESSOR_LEVEL                6\n     296 csrss.exe            0x00000000003d1320 PROCESSOR_REVISION             0203\n     296 csrss.exe            0x00000000003d1320 PSModulePath                   C:\\Windows\\system32\\WindowsPowerShell\\v1.0\\Modules\\\n     296 csrss.exe            0x00000000003d1320 SystemDrive                    C:\n     296 csrss.exe            0x00000000003d1320 SystemRoot                     C:\\Windows\n     296 csrss.exe            0x00000000003d1320 TEMP                           C:\\Windows\\TEMP\n     296 csrss.exe            0x00000000003d1320 TMP                            C:\\Windows\\TEMP\n     296 csrss.exe            0x00000000003d1320 USERNAME                       SYSTEM\n     296 csrss.exe            0x00000000003d1320 windir                         C:\\Windows\n\n\nverinfo\n\nTo display the version information embedded in PE files, use the verinfo command. Not all PE files have version information, and many malware authors forge it to include false data, but nonetheless this command can be very helpful with identifying binaries and for making correlations with other files.\n\nverinfo\u3067\u3001PE\u30d5\u30a1\u30a4\u30eb\u306b\u57cb\u3081\u8fbc\u307e\u308c\u3066\u3044\u308b\u30d0\u30fc\u30b8\u30e7\u30f3\u60c5\u5831\u3092\u51fa\u529b\u3067\u304d\u308b\u3002\u3059\u3079\u3066\u306ePE\u30d5\u30a1\u30a4\u30eb\u304c\u30d0\u30fc\u30b8\u30e7\u30f3\u60c5\u5831\u3092\u6301\u3063\u3066\u3044\u308b\u308f\u3051\u3067\u306f\u306a\u3044\u3057\u3001\u591a\u304f\u306e\u30de\u30eb\u30a6\u30a7\u30a2\u306e\u4f5c\u8005\u306f\u8aa4\u3063\u305f\u60c5\u5831\u3067\u507d\u88c5\u3092\u884c\u3046\u304c\u3001\u30d0\u30a4\u30ca\u30ea\u3092\u8b58\u5225\u3057\u5225\u306e\u30d5\u30a1\u30a4\u30eb\u3068\u306e\u95a2\u9023\u3092\u8abf\u3079\u308b\u306e\u306b\u5f79\u306b\u7acb\u3064\u30b3\u30de\u30f3\u30c9\u3067\u3042\u308b\u3002\n\nThis plugin only supports printing version information from process executables and DLLs, but later will be expanded to include kernel modules. If you want to filter by module name, use the --regex=REGEX and/or --ignore-case options.\n\n\u3053\u306e\u30d7\u30e9\u30b0\u30a4\u30f3\u306f\u3001\u30d7\u30ed\u30bb\u30b9\u306e\u5b9f\u884c\u30d5\u30a1\u30a4\u30eb\u3068DLL\u306e\u30d0\u30fc\u30b8\u30e7\u30f3\u60c5\u5831\u3057\u304b\u30b5\u30dd\u30fc\u30c8\u3057\u306a\u3044\u304c\u3001\u30ab\u30fc\u30cd\u30eb\u30e2\u30b8\u30e5\u30fc\u30eb\u307e\u3067\u30b5\u30dd\u30fc\u30c8\u7bc4\u56f2\u304c\u5e83\u304c\u308b\u3060\u308d\u3046\u3002\u30e2\u30b8\u30e5\u30fc\u30eb\u540d\u3067\u30d5\u30a3\u30eb\u30bf\u3092\u3057\u305f\u3051\u308c\u3070\u3001--regex=REGEX\u3068\u5fc5\u8981\u306b\u5fdc\u3058\u3066--ignore-case\u30aa\u30d7\u30b7\u30e7\u30f3\u3092\u6307\u5b9a\u3059\u308b\u3002\n$ python vol.py -f ~/Desktop/win7_trial_64bit.raw --profile=Win7SP0x64 verinfo\nVolatility Foundation Volatility Framework 2.4\n\\SystemRoot\\System32\\smss.exe\nC:\\Windows\\SYSTEM32\\ntdll.dll\n\nC:\\Windows\\system32\\csrss.exe\n  File version    : 6.1.7600.16385\n  Product version : 6.1.7600.16385\n  Flags           :\n  OS              : Windows NT\n  File Type       : Application\n  File Date       :\n  CompanyName : Microsoft Corporation\n  FileDescription : Client Server Runtime Process\n  FileVersion : 6.1.7600.16385 (win7_rtm.090713-1255)\n  InternalName : CSRSS.Exe\n  LegalCopyright : \\xa9 Microsoft Corporation. All rights reserved.\n  OriginalFilename : CSRSS.Exe\n  ProductName : Microsoft\\xae Windows\\xae Operating System\n  ProductVersion : 6.1.7600.16385\n\n[snip]\n\n\nenumfunc\n\nThis plugin enumerates imported and exported functions from processes, dlls, and kernel drivers. Specifically, it handles functions imported by name or ordinal, functions exported by name or ordinal, and forwarded exports. The output will be very verbose in most cases (functions exported by ntdll, msvcrt, and kernel32 can reach 1000+ alone). So you can either reduce the verbosity by filtering criteria with the command-line options (shown below) or you can use look at the code in enumfunc.py and use it as an example of how to use the IAT and EAT parsing API functions in your own plugin. For example, the apihooks plugin leverages the imports and exports APIs to find functions in memory when checking for hooks.\n\n\u3053\u306e\u30d7\u30e9\u30b0\u30a4\u30f3\u306f\u3001\u30d7\u30ed\u30bb\u30b9\u3001DLL\u3001\u30ab\u30fc\u30cd\u30eb\u30c9\u30e9\u30a4\u30d0\u306b\u30a4\u30f3\u30dd\u30fc\u30c8\u307e\u305f\u306f\u305d\u308c\u3089\u304b\u3089\u30a8\u30af\u30b9\u30dd\u30fc\u30c8\u3055\u308c\u308b\u95a2\u6570\u3092\u5217\u6319\u3059\u308b\u3002\u7279\u306b\u540d\u524d\u304b\u5e8f\u6570\u3067\u30a4\u30f3\u30dd\u30fc\u30c8\u3055\u308c\u305f\u95a2\u6570\u3001\u540d\u524d\u304b\u5e8f\u6570\u3067\u30a8\u30af\u30b9\u30dd\u30fc\u30c8\u3055\u308c\u305f\u95a2\u6570\u3001forwarded\u30a8\u30af\u30b9\u30dd\u30fc\u30c8\u3092\u64cd\u4f5c\u3059\u308b\u3002\u901a\u5e38\u306e\u4f7f\u7528\u306e\u305f\u3081\u306b\u306f\u3001\u3068\u3066\u3082\u8a73\u7d30\u306a\u51fa\u529b\u3060\u308d\u3046(ntdll, msvcrt,\u3000kernel32\u304b\u3089\u30a8\u30af\u30b9\u30dd\u30fc\u30c8\u3055\u308c\u305f\u95a2\u6570\u306f\u3001\u305d\u308c\u305e\u308c1000\u4ee5\u4e0a\u306b\u9054\u3059\u308b)\u3002\u30b3\u30de\u30f3\u30c9\u30e9\u30a4\u30f3\u30aa\u30d7\u30b7\u30e7\u30f3\u306e\u30d5\u30a3\u30eb\u30bf\u3067\u524a\u6e1b\u3092\u884c\u3046(\u4e0b\u3067\u8ff0\u3079\u308b)\u304b\u3001enumfunc.py\u306e\u30b3\u30fc\u30c9\u3092\u898b\u3066IAT\u3068EAT\u3092\u30d1\u30fc\u30b9\u3059\u308bAPI\u306e\u30b5\u30f3\u30d7\u30eb\u3068\u3057\u3066\u8cb4\u65b9\u81ea\u8eab\u306e\u30d7\u30e9\u30b0\u30a4\u30f3\u3067\u5229\u7528\u3059\u308b\u3053\u3068\u3082\u3067\u304d\u308b\u3002\u4f8b\u3048\u3070\u3001apihooks\u30d7\u30e9\u30b0\u30a4\u30f3\u306f\u30e1\u30e2\u30ea\u4e0a\u306e\u95a2\u6570\u304c\u30d5\u30c3\u30af\u3055\u308c\u3066\u3044\u308b\u3092\u30c1\u30a7\u30c3\u30af\u3059\u308b\u305f\u3081\u306b\u30a4\u30f3\u30dd\u30fc\u30c8\u3068\u30a8\u30af\u30b9\u30dd\u30fc\u30c8\u306eAPI\u3092\u5229\u7528\u3057\u3066\u3044\u308b\u3002\n\nAlso note this plugin is in the contrib directory, so you can pass that to --plugins like this:\n\n\u3053\u306e\u30d7\u30e9\u30b0\u30a4\u30f3\u306f\u3001contrib\u30c7\u30a3\u30ec\u30af\u30c8\u30ea\u306b\u3042\u308b\u305f\u3081\u3001--plugins\u30aa\u30d7\u30b7\u30e7\u30f3\u3092\u3053\u306e\u3088\u3046\u306b\u6e21\u3059\u3053\u3068\u304c\u3067\u304d\u308b\uff1a\n$ python vol.py --plugins=contrib/plugins/ -f ~/Desktop/win7_trial_64bit.raw --profile=Win7SP0x64 enumfunc -h\n....\n  -s, --scan            Scan for objects\n  -P, --process-only    Process only\n  -K, --kernel-only     Kernel only\n  -I, --import-only     Imports only\n  -E, --export-only     Exports only\n\n\nTo use pool scanners for finding processes and kernel drivers instead of walking linked lists, use the -s option. This can be useful if you're trying to enumerate functions in hidden processes or drivers. An example of the remaining command-line options is shown below.\n\n\u30d7\u30ed\u30bb\u30b9\u3068\u30ab\u30fc\u30cd\u30eb\u30c9\u30e9\u30a4\u30d0\u3092\u898b\u3064\u3051\u308b\u305f\u3081\u306b\u30ea\u30f3\u30af\u30ea\u30b9\u30c8\u3092\u305f\u3069\u308b\u306e\u3067\u306f\u306a\u304f\u3001\u30d7\u30fc\u30eb\u30b9\u30ad\u30e3\u30ca\u3092\u4f7f\u3046\u305f\u3081\u306b\u306f\u3001-s\u30aa\u30d7\u30b7\u30e7\u30f3\u3092\u6307\u5b9a\u3059\u308b\u3002\u96a0\u3055\u308c\u305f\u30d7\u30ed\u30bb\u30b9\u3084\u30c9\u30e9\u30a4\u30d0\u306e\u95a2\u6570\u3092\u5217\u6319\u3057\u3088\u3046\u3068\u3059\u308b\u5834\u5408\u306b\u306f\u6709\u7528\u3067\u3059\u3002\u6b8b\u3055\u308c\u305f\u30b3\u30de\u30f3\u30c9\u30e9\u30a4\u30f3\u30aa\u30d7\u30b7\u30e7\u30f3\u306f\u4ee5\u4e0b\u306b\u793a\u3055\u308c\u307e\u3059\u3002\n\nTo show exported functions in process memory, use -P and -E like this:\n\n\u30d7\u30ed\u30bb\u30b9\u30e1\u30e2\u30ea\u3067\u30a8\u30af\u30b9\u30dd\u30fc\u30c8\u3055\u308c\u305f\u95a2\u6570\u306e\u8868\u793a\u306b\u306f\u3001-p\u3068-E\u30aa\u30d7\u30b7\u30e7\u30f3\u3092\u3053\u306e\u3088\u3046\u306b\u6307\u5b9a\u3057\u307e\u3059\uff1a\n$ python vol.py --plugins=contrib/plugins/ -f ~/Desktop/win7_trial_64bit.raw --profile=Win7SP0x64 enumfunc -P -E\nProcess              Type       Module               Ordinal    Address              Name\nlsass.exe            Export     ADVAPI32.dll         1133       0x000007fefd11dd34 CreateWellKnownSid\nlsass.exe            Export     ADVAPI32.dll         1134       0x000007fefd17a460 CredBackupCredentials\nlsass.exe            Export     ADVAPI32.dll         1135       0x000007fefd170590 CredDeleteA\nlsass.exe            Export     ADVAPI32.dll         1136       0x000007fefd1704d0 CredDeleteW\nlsass.exe            Export     ADVAPI32.dll         1137       0x000007fefd17a310 CredEncryptAndMarshalBinaryBlob\nlsass.exe            Export     ADVAPI32.dll         1138       0x000007fefd17d080 CredEnumerateA\nlsass.exe            Export     ADVAPI32.dll         1139       0x000007fefd17cf50 CredEnumerateW\nlsass.exe            Export     ADVAPI32.dll         1140       0x000007fefd17ca00 CredFindBestCredentialA\nlsass.exe            Export     ADVAPI32.dll         1141       0x000007fefd17c8f0 CredFindBestCredentialW\nlsass.exe            Export     ADVAPI32.dll         1142       0x000007fefd130c10 CredFree\nlsass.exe            Export     ADVAPI32.dll         1143       0x000007fefd1630f0 CredGetSessionTypes\nlsass.exe            Export     ADVAPI32.dll         1144       0x000007fefd1703d0 CredGetTargetInfoA\n[snip]\n\n\nTo show imported functions in kernel memory, use -K and -I like this:\n\n\u30ab\u30fc\u30cd\u30eb\u30e1\u30e2\u30ea\u306b\u30a4\u30f3\u30dd\u30fc\u30c8\u3055\u308c\u305f\u95a2\u6570\u3092\u8868\u793a\u3059\u308b\u306b\u306f\u3001-K\u3068-I\u30aa\u30d7\u30b7\u30e7\u30f3\u3092\u3053\u306e\u3088\u3046\u306b\u5229\u7528\u3057\u307e\u3059\uff1a\n$ python vol.py --plugins=contrib/plugins/ -f ~/Desktop/win7_trial_64bit.raw --profile=Win7SP0x64 enumfunc -K -I\nVolatility Foundation Volatility Framework 2.4\nProcess              Type       Module               Ordinal    Address              Name\n<KERNEL>             Import     VIDEOPRT.SYS         583        0xfffff80002acc320 ntoskrnl.exeIoRegisterPlugPlayNotification\n<KERNEL>             Import     VIDEOPRT.SYS         1325       0xfffff800029f9f30 ntoskrnl.exeRtlAppendStringToString\n<KERNEL>             Import     VIDEOPRT.SYS         509        0xfffff800026d06e0 ntoskrnl.exeIoGetAttachedDevice\n<KERNEL>             Import     VIDEOPRT.SYS         443        0xfffff800028f7ec0 ntoskrnl.exeIoBuildSynchronousFsdRequest\n<KERNEL>             Import     VIDEOPRT.SYS         1466       0xfffff80002699300 ntoskrnl.exeRtlInitUnicodeString\n<KERNEL>             Import     VIDEOPRT.SYS         759        0xfffff80002697be0 ntoskrnl.exeKeInitializeEvent\n<KERNEL>             Import     VIDEOPRT.SYS         1461       0xfffff8000265e8a0 ntoskrnl.exeRtlInitAnsiString\n<KERNEL>             Import     VIDEOPRT.SYS         1966       0xfffff80002685060 ntoskrnl.exeZwSetValueKey\n<KERNEL>             Import     VIDEOPRT.SYS         840        0xfffff80002699440 ntoskrnl.exeKeReleaseSpinLock\n<KERNEL>             Import     VIDEOPRT.SYS         1190       0xfffff800027a98b0 ntoskrnl.exePoRequestPowerIrp\n<KERNEL>             Import     VIDEOPRT.SYS         158        0xfffff800026840f0 ntoskrnl.exeExInterlockedInsertTailList\n<KERNEL>             Import     VIDEOPRT.SYS         1810       0xfffff80002684640 ntoskrnl.exeZwClose\n[snip]\n\n\nProcess Memory\n\nmemmap\n\nThe memmap command shows you exactly which pages are memory resident, given a specific process DTB (or kernel DTB if you use this plugin on the Idle or System process). It shows you the virtual address of the page, the corresponding physical offset of the page, and the size of the page. The map information generated by this plugin comes from the underlying address space's get_available_addresses method.\n\nmemmap\u306f\u3001\u6307\u5b9a\u3057\u305f\u30d7\u30ed\u30bb\u30b9DTB(\u3082\u3057\u304f\u306f\u30a2\u30a4\u30c9\u30eb\u304b\u30b7\u30b9\u30c6\u30e0\u30d7\u30ed\u30bb\u30b9\u306b\u5bfe\u3057\u3066\u306f\u3001\u30ab\u30fc\u30cd\u30ebDTB)\u306e\u3069\u306e\u30da\u30fc\u30b8\u304c\u7269\u7406\u30e1\u30e2\u30ea\u4e0a\u306b\u3042\u308b\u304b\u3092\u8868\u793a\u3059\u308b\u3002\u30da\u30fc\u30b8\u306e\u4eee\u60f3\u30a2\u30c9\u30ec\u30b9\u3001\u5bfe\u5fdc\u3059\u308b\u7269\u7406\u30a2\u30c9\u30ec\u30b9\u3068\u30b5\u30a4\u30ba\u3092\u8868\u793a\u3059\u308b\u3002\u3053\u306e\u30d7\u30e9\u30b0\u30a4\u30f3\u304c\u8868\u793a\u3059\u308b\u60c5\u5831\u306f\u3001\u30a2\u30c9\u30ec\u30b9\u7a7a\u9593\u306eget_available_addresses\u30e1\u30bd\u30c3\u30c9\u3067\u53d6\u5f97\u3055\u308c\u308b\u3002\n\nAs of 2.1, the new column DumpFileOffset helps you correlate the output of memmap with the dump file produced by the memdump plugin. For example, according to the output below, the page at virtual address 0x0000000000058000 in the System process's memory can be found at offset 0x00000000162ed000 of the win7_trial_64bit.raw file. After using memdump to extract the addressable memory of the System process to an individual file, you can find this page at offset 0x8000.\n\n2.1\u304b\u3089\u3001DumpFileOffset\u3068\u3044\u3046\u65b0\u3057\u3044\u5217\u3067\u3001memmap\u306e\u51fa\u529b\u3068memdump\u306b\u3088\u308b\u30c0\u30f3\u30d7\u30d5\u30a1\u30a4\u30eb\u306e\u95a2\u9023\u4ed8\u3051\u304c\u3067\u304d\u308b\u3088\u3046\u306b\u306a\u3063\u3066\u3044\u308b\u3002\u4f8b\u3048\u3070\u3001\u4e0b\u306e\u51fa\u529b\u4f8b\u3067\u306f\u3001\u30b7\u30b9\u30c6\u30e0\u30d7\u30ed\u30bb\u30b9\u306e\u4eee\u60f3\u30a2\u30c9\u30ec\u30b90x0000000000058000\u306e\u30da\u30fc\u30b8\u306f\u3001win7_trial_64bit.raw\u30d5\u30a1\u30a4\u30eb\u306e0x00000000162ed000\u30aa\u30d5\u30bb\u30c3\u30c8\u306b\u898b\u3064\u3051\u3089\u308c\u308b\u3002\u30b7\u30b9\u30c6\u30e0\u30d7\u30ed\u30bb\u30b9\u306e\u30e1\u30e2\u30ea\u3092\u500b\u5225\u306e\u30d5\u30a1\u30a4\u30eb\u306b\u30c0\u30f3\u30d7\u3057\u305f\u5f8c\u306b\u3001\u305d\u306e\u30d5\u30a1\u30a4\u30eb\u306e0x8000\u30aa\u30d5\u30bb\u30c3\u30c8\u306b\u30da\u30fc\u30b8\u304c\u898b\u3064\u3051\u3089\u308c\u308b\u3002\n$ python vol.py -f ~/Desktop/win7_trial_64bit.raw --profile=Win7SP0x64 memmap -p 4\nVolatility Foundation Volatility Framework 2.4\nSystem pid:      4\nVirtual            Physical                         Size     DumpFileOffset\n------------------ ------------------ ------------------ ------------------\n0x0000000000050000 0x0000000000cbc000             0x1000                0x0\n0x0000000000051000 0x0000000015ec6000             0x1000             0x1000\n0x0000000000052000 0x000000000f5e7000             0x1000             0x2000\n0x0000000000053000 0x0000000005e28000             0x1000             0x3000\n0x0000000000054000 0x0000000008b29000             0x1000             0x4000\n0x0000000000055000 0x00000000155b8000             0x1000             0x5000\n0x0000000000056000 0x000000000926e000             0x1000             0x6000\n0x0000000000057000 0x0000000002dac000             0x1000             0x7000\n0x0000000000058000 0x00000000162ed000             0x1000             0x8000\n[snip]\n\n\nmemdump\n\nTo extract all memory resident pages in a process (see memmap for details) into an individual file, use the memdump command. Supply the output directory with -D or --dump-dir=DIR.\n\n\u30d7\u30ed\u30bb\u30b9\u5185\u306e\u3059\u3079\u3066\u306e\u7269\u7406\u30e1\u30e2\u30ea\u4e0a\u306e\u30da\u30fc\u30b8\u3092\u500b\u5225\u306e\u30d5\u30a1\u30a4\u30eb\u306b\u5c55\u958b\u3059\u308b\u306b\u306f\u3001memdump\u30b3\u30de\u30f3\u30c9\u3092\u4f7f\u3046\u3002-D\u307e\u305f\u306f--dump-dir=DIR\u30aa\u30d7\u30b7\u30e7\u30f3\u3067\u3001\u51fa\u529b\u30c7\u30a3\u30ec\u30af\u30c8\u30ea\u3092\u3057\u3066\u3044\u3059\u308b\u3053\u3068\u304c\u3067\u304d\u308b\u3002\n$ python vol.py -f ~/Desktop/win7_trial_64bit.raw --profile=Win7SP0x64 memdump -p 4 -D dump/\nVolatility Foundation Volatility Framework 2.4\n************************************************************************\nWriting System [     4] to 4.dmp\n\n$ ls -alh dump/4.dmp\n-rw-r--r--  1 Michael  staff   111M Jun 24 15:47 dump/4.dmp\n\n\nTo conclude the demonstration we began in the memmap discussion, we should now be able to make an assertion regarding the relationship of the mapped and extracted pages:\n\nmemmap\u306e\u8b70\u8ad6\u3067\u59cb\u3081\u305f\u8aac\u660e\u306b\u7d50\u8ad6\u3092\u3060\u3059\u305f\u3081\u306b\u3001\u30de\u30c3\u30d7\u3055\u308c\u305f\u30da\u30fc\u30b8\u3068\u5c55\u958b\u3055\u308c\u305f\u30da\u30fc\u30b8\u9593\u306e\u95a2\u4fc2\u306b\u3064\u3044\u3066\u4e3b\u5f35\u3067\u304d\u308b\u3079\u304d\u3067\u3057\u3087\u3046\u3002\n$ python vol.py -f ~/Desktop/win7_trial_64bit.raw --profile=Win7SP0x64 volshell\nVolatility Foundation Volatility Framework 2.4\nCurrent context: process System, pid=4, ppid=0 DTB=0x187000\nWelcome to volshell Current memory image is:\nfile:///Users/Michael/Desktop/win7_trial_64bit.raw\nTo get help, type 'hh()'\n\n>>> PAGE_SIZE = 0x1000\n\n>>> assert addrspace().read(0x0000000000058000, PAGE_SIZE) == \\\n...        addrspace().base.read(0x00000000162ed000, PAGE_SIZE) == \\\n...        open(\"dump/4.dmp\", \"rb\").read()[0x8000:0x8000 + PAGE_SIZE]\n>>>\n\n\nprocdump\n\nTo dump a process's executable, use the procdump command. Optionally, pass the --unsafe or -u flags to bypass certain sanity checks used when parsing the PE header. Some malware will intentionally forge size fields in the PE header so that memory dumping tools fail.\n\n\u30d7\u30ed\u30bb\u30b9\u306e\u5b9f\u884c\u5f62\u5f0f\u30d5\u30a1\u30a4\u30eb\u3092\u30c0\u30f3\u30d7\u3059\u308b\u305f\u3081\u306bprocdump\u30b3\u30de\u30f3\u30c9\u304c\u4f7f\u3048\u307e\u3059\u3002\u30aa\u30d7\u30b7\u30e7\u30f3\u3068\u3057\u3066\u3001--unsafe\u307e\u305f\u306f-u\u30aa\u30d7\u30b7\u30e7\u30f3\u3092\u6307\u5b9a\u3059\u308b\u3068PE\u30d8\u30c3\u30c0\u3092\u30d1\u30fc\u30b9\u3059\u308b\u969b\u306b\u3044\u304f\u3064\u304b\u306e\u5065\u5168\u3055\u306e\u30c1\u30a7\u30c3\u30af\u304c\u30d0\u30a4\u30d1\u30b9\u3055\u308c\u307e\u3059\u3002\n\nUse --memory to include slack space between the PE sections that aren't page aligned. Without --memory you'll get a file that more closely resembles the file on disk, before sections expanded.\n\n--memory\u30aa\u30d7\u30b7\u30e7\u30f3\u3067\u30da\u30fc\u30b8\u4f4d\u7f6e\u306b\u5408\u3063\u3066\u3044\u306a\u3044PE\u30bb\u30af\u30b7\u30e7\u30f3\u306e\u30b9\u30e9\u30c3\u30af\u30b9\u30da\u30fc\u30b9\u3092\u542b\u3081\u3089\u308c\u307e\u3059\u3002--memory\u30aa\u30d7\u30b7\u30e7\u30f3\u306a\u3057\u3067\u306f\u3001\u30bb\u30af\u30b7\u30e7\u30f3\u304c\u62e1\u5927\u3059\u308b\u524d\u306e\u30c7\u30a3\u30b9\u30af\u4e0a\u306e\u30d5\u30a1\u30a4\u30eb\u306b\u3088\u304f\u4f3c\u305f\u30d5\u30a1\u30a4\u30eb\u3092\u53d6\u5f97\u3059\u308b\u3053\u3068\u306b\u306a\u308a\u307e\u3059\u3002\n\nFor more information, see Andreas Schuster's 4-part series on Reconstructing a Binary. Also see impscan for help rebuilding a binary's import address table.\n\n\u66f4\u306b\u8a73\u3057\u3044\u60c5\u5831\u306f\u3001\u201dAndreas Schuster's 4-part series on Reconstructing a Binary\u201d\u3092\u53c2\u7167\u3002\u30d0\u30a4\u30ca\u30ea\u306e\u30a4\u30f3\u30dd\u30fc\u30c8\u30a2\u30c9\u30ec\u30b9\u30c6\u30fc\u30d6\u30eb\u3092\u518d\u69cb\u7bc9\u3059\u308b\u305f\u3081\u306bimpscan\u3082\u53c2\u7167\u3057\u3066\u304f\u3060\u3055\u3044\u3002\n$ python vol.py -f win7_trial_64bit.raw --profile=Win7SP0x64 procdump -D dump/ -p 296\nVolatility Foundation Volatility Framework 2.4\n************************************************************************\nDumping csrss.exe, pid:    296 output: executable.296.exe\n\n$ file dump/executable.296.exe\ndump/executable.296.exe: PE32+ executable for MS Windows (native) Mono/.Net assembly\n\n\nvadinfo\n\nThe vadinfo command displays extended information about a process's VAD nodes. In particular, it shows:\n\nvadinfo\u306f\u3001\u30d7\u30ed\u30bb\u30b9\u306eVAD\u30ce\u30fc\u30c9\u306b\u3064\u3044\u3066\u306e\u62e1\u5f35\u3055\u308c\u305f\u60c5\u5831\u3092\u8868\u793a\u3057\u307e\u3059\u3002\u4ee5\u4e0b\u306e\u3082\u306e\u3092\u8868\u793a\u3057\u307e\u3059\u3002\n\n\nThe address of the MMVAD structure in kernel memory\nThe starting and ending virtual addresses in process memory that the MMVAD structure pertains to\nThe VAD Tag\nThe VAD flags, control flags, etc\nThe name of the memory mapped file (if one exists)\nThe memory protection constant (permissions). Note there is a difference between the original protection and current protection. The original protection is derived from the flProtect parameter to VirtualAlloc. For example you can reserve memory (MEM_RESERVE) with protection PAGE_NOACCESS (original protection). Later, you can call VirtualAlloc again to commit (MEM_COMMIT) and specify PAGE_READWRITE (becomes current protection). The vadinfo command shows the original protection only. Thus, just because you see PAGE_NOACCESS here, it doesn't mean code in the region cannot be read, written, or executed.\n\n\n\n\u30ab\u30fc\u30cd\u30eb\u5185\u306eNMVAD\u69cb\u9020\u4f53\u306e\u30a2\u30c9\u30ec\u30b9\nNMVAD\u69cb\u9020\u4f53\u306e\u30d7\u30ed\u30bb\u30b9\u5185\u306e\u958b\u59cb\u3068\u7d42\u4e86\u4eee\u60f3\u30a2\u30c9\u30ec\u30b9\nVAD\u30bf\u30b0\nVAD\u30d5\u30e9\u30b0\u3001\u30b3\u30f3\u30c8\u30ed\u30fc\u30eb\u30d5\u30e9\u30b0\u306a\u3069\n\u30e1\u30e2\u30ea\u30de\u30c3\u30d7\u30c9\u30d5\u30a1\u30a4\u30eb\u306e\u540d\u524d(\u3082\u3057\u3042\u308c\u3070)\n\u30e1\u30e2\u30ea\u30d7\u30ed\u30c6\u30af\u30b7\u30e7\u30f3\u5b9a\u6570(\u8a31\u53ef)\u3002\u30aa\u30ea\u30b8\u30ca\u30eb\u306e\u30d7\u30ed\u30c6\u30af\u30b7\u30e7\u30f3\u3068\u73fe\u5728\u306e\u30d7\u30ed\u30c6\u30af\u30b7\u30e7\u30f3\u306b\u306f\u9055\u3044\u304c\u3042\u308b\u3053\u3068\u306b\u6ce8\u610f\u3002\u30aa\u30ea\u30b8\u30ca\u30eb\u306e\u30d7\u30ed\u30c6\u30af\u30b7\u30e7\u30f3\u306f\u3001VirtualAlloc\u306b\u5bfe\u3059\u308bflProtect\u30d1\u30e9\u30e1\u30fc\u30bf\u304b\u3089\u304d\u3066\u3044\u308b\u3002\u4f8b\u3048\u3070\u3001PAGE_NOACCESS\u30d7\u30ed\u30c6\u30af\u30b7\u30e7\u30f3(\u30aa\u30ea\u30b8\u30ca\u30eb\u306e\u30d7\u30ed\u30c6\u30af\u30b7\u30e7\u30f3)\u3067\u30e1\u30e2\u30ea\u3092\u4e88\u7d04(MEM_RESERVE)\u3067\u304d\u308b\u3002\u305d\u306e\u5f8c\u3001VirtualAlloc\u3092\u518d\u3073\u547c\u3093\u3067\u3001PAGE_READWRITE\u30d7\u30ed\u30c6\u30af\u30b7\u30e7\u30f3\u3067\u30b3\u30df\u30c3\u30c8(MEM_COMMIT)\u3059\u308b\u3053\u3068\u304c\u3067\u304d\u308b(\u73fe\u5728\u306e\u30d7\u30ed\u30c6\u30af\u30b7\u30e7\u30f3\u306b\u306a\u308b)\u3002vadinfo\u306f\u3001\u30aa\u30ea\u30b8\u30ca\u30eb\u306e\u30d7\u30ed\u30c6\u30af\u30b7\u30e7\u30f3\u3057\u304b\u8868\u793a\u3057\u306a\u3044\u3002PAGE_NOACCESS\u3068\u8868\u793a\u3055\u308c\u3066\u3044\u308b\u304b\u3089\u3068\u3044\u3063\u3066\u3001\u5fc5\u305a\u3057\u3082\u305d\u306e\u30e1\u30e2\u30ea\u306e\u30b3\u30fc\u30c9\u304c\u3001\u30ea\u30fc\u30c9\u3001\u30e9\u30a4\u30c8\u3001\u5b9f\u884c\u3067\u304d\u306a\u3044\u3068\u3044\u3046\u308f\u3051\u3067\u306f\u306a\u3044\u3002\n\n    $ python vol.py -f ~/Desktop/win7_trial_64bit.raw --profile=Win7SP0x64 vadinfo -p 296\n    Volatility Foundation Volatility Framework 2.4\n    ************************************************************************\n    Pid:    296\n    VAD node @ 0xfffffa8000c00620 Start 0x000000007f0e0000 End 0x000000007ffdffff Tag VadS\n    Flags: PrivateMemory: 1, Protection: 1\n    Protection: PAGE_READONLY\n    Vad Type: VadNone\n\n    [snip]\n\n    VAD node @ 0xfffffa8000c04ce0 Start 0x000007fefcd00000 End 0x000007fefcd10fff Tag Vad\n    Flags: CommitCharge: 2, Protection: 7, VadType: 2\n    Protection: PAGE_EXECUTE_WRITECOPY\n    Vad Type: VadImageMap\n    ControlArea @fffffa8000c04d70 Segment fffff8a000c45c10\n    Dereference list: Flink 00000000, Blink 00000000\n    NumberOfSectionReferences:          0 NumberOfPfnReferences:          13\n    NumberOfMappedViews:                2 NumberOfUserReferences:          2\n    WaitingForDeletion Event:  00000000\n    Control Flags: Accessed: 1, File: 1, Image: 1\n    FileObject @fffffa8000c074d0, Name: \\Windows\\System32\\basesrv.dll\n    First prototype PTE: fffff8a000c45c58 Last contiguous PTE: fffffffffffffffc\n    Flags2: Inherit: 1\n\n\nFor more information on the VAD, see BDG's The VAD Tree: A Process-Eye View of Physical Memory.\n\nVAD\u306e\u8a73\u3057\u3044\u60c5\u5831\u306b\u3064\u3044\u3066\u306f\u3001\"BDG's The VAD Tree: A Process-Eye View of Physical Memory\"\u3092\u53c2\u7167\u3002\n\nvadwalk\n\nTo inspect a process's VAD nodes in table form, use the vadwalk command.\n\nvadwalk\u3067\u3001\u30d7\u30ed\u30bb\u30b9\u306eVAD\u30ce\u30fc\u30c9\u3092\u8868\u5f62\u5f0f\u3067\u8868\u793a\u3067\u304d\u308b\u3002\n$ python vol.py -f ~/Desktop/win7_trial_64bit.raw --profile=Win7SP0x64 vadwalk -p 296\nVolatility Foundation Volatility Framework 2.4\n************************************************************************\nPid:    296\nAddress            Parent             Left               Right              Start              End                Tag\n------------------ ------------------ ------------------ ------------------ ------------------ ------------------ ----\n0xfffffa8000c00620 0x0000000000000000 0xfffffa8000deaa40 0xfffffa8000c043d0 0x000000007f0e0000 0x000000007ffdffff VadS\n0xfffffa8000deaa40 0xfffffa8000c00620 0xfffffa8000bc4660 0xfffffa80011b8d80 0x0000000000ae0000 0x0000000000b1ffff VadS\n0xfffffa8000bc4660 0xfffffa8000deaa40 0xfffffa8000c04260 0xfffffa8000c91010 0x00000000004d0000 0x0000000000650fff Vadm\n0xfffffa8000c04260 0xfffffa8000bc4660 0xfffffa8000c82010 0xfffffa80012acce0 0x00000000002a0000 0x000000000039ffff VadS\n0xfffffa8000c82010 0xfffffa8000c04260 0xfffffa8000cbce80 0xfffffa8000c00330 0x00000000001f0000 0x00000000001f0fff Vadm\n0xfffffa8000cbce80 0xfffffa8000c82010 0xfffffa8000bc4790 0xfffffa8000d9bb80 0x0000000000180000 0x0000000000181fff Vad\n0xfffffa8000bc4790 0xfffffa8000cbce80 0xfffffa8000c00380 0xfffffa8000e673a0 0x0000000000100000 0x0000000000166fff Vad\n0xfffffa8000c00380 0xfffffa8000bc4790 0x0000000000000000 0x0000000000000000 0x0000000000000000 0x00000000000fffff VadS\n[snip]\n\n\nvadtree\n\nTo display the VAD nodes in a visual tree form, use the vadtree command.\n\nvadtree\u3067\u306f\u3001VAD\u30ce\u30fc\u30c9\u3092\u30c4\u30ea\u30fc\u5f62\u5f0f\u3067\u8868\u793a\u3067\u304d\u308b\u3002\n$ python vol.py -f ~/Desktop/win7_trial_64bit.raw --profile=Win7SP0x64 vadtree -p 296\nVolatility Foundation Volatility Framework 2.4\n************************************************************************\nPid:    296\n 0x000000007f0e0000 - 0x000000007ffdffff\n  0x0000000000ae0000 - 0x0000000000b1ffff\n   0x00000000004d0000 - 0x0000000000650fff\n    0x00000000002a0000 - 0x000000000039ffff\n     0x00000000001f0000 - 0x00000000001f0fff\n      0x0000000000180000 - 0x0000000000181fff\n       0x0000000000100000 - 0x0000000000166fff\n        0x0000000000000000 - 0x00000000000fffff\n        0x0000000000170000 - 0x0000000000170fff\n       0x00000000001a0000 - 0x00000000001a1fff\n        0x0000000000190000 - 0x0000000000190fff\n        0x00000000001b0000 - 0x00000000001effff\n      0x0000000000240000 - 0x000000000024ffff\n       0x0000000000210000 - 0x0000000000216fff\n        0x0000000000200000 - 0x000000000020ffff\n[snip]\n\n\nIf you want to view the balanced binary tree in Graphviz format, just add --output=dot --output-file=graph.dot to your command. Then you can open graph.dot in any Graphviz-compatible viewer. This plugin also supports color coding the output based on the regions that contain stacks, heaps, mapped files, DLLs, etc. A partial example is shown below using Omnigraffle:\n\nGraphviza\u5f62\u5f0f\u3067\u3001\u30d0\u30e9\u30f3\u30b9\u3055\u308c\u305f\u30c4\u30ea\u30fc\u3067\u8868\u793a\u3055\u305b\u305f\u3051\u308c\u3070\u3001-output=dot --output-file=graph.dot\u30aa\u30d7\u30b7\u30e7\u30f3\u3092\u6307\u5b9a\u3059\u308b\u3002\u305d\u3046\u3059\u308c\u3070\u3001Graphviz\u4e92\u63db\u30d3\u30e5\u30a2\u30fc\u3067\u958b\u304f\u3053\u3068\u304c\u3067\u304d\u308b\u3002\u30b9\u30bf\u30c3\u30af\u3001\u30d2\u30fc\u30d7\u3001\u30de\u30c3\u30d7\u30c9\u30d5\u30a1\u30a4\u30eb\u3001DLL\u306a\u3069\u306e\u9818\u57df\u3067\u51fa\u529b\u306e\u8272\u3092\u5909\u3048\u308b\u8a2d\u5b9a\u3082\u30b5\u30dd\u30fc\u30c8\u3057\u3066\u3044\u308b\u3002Omnigraffle\u3092\u4f7f\u3063\u305f\u90e8\u5206\u7684\u306a\u4f8b\u3002\n\u753b\u50cf\"VADTree with Dot output\"\n\nFillcolor Legend:\n\n\u30d5\u30eb\u30ab\u30e9\u30fc\u306e\u51e1\u4f8b\n\n\nRed: Heaps\nGray: DLLs\nGreen: Stacks\nYellow: Mapped Files\n\n\n\n\u8d64\uff1a\u30d2\u30fc\u30d7\n\u30b0\u30ec\u30fc\uff1aDLL\n\u7dd1\uff1a\u30b9\u30bf\u30c3\u30af\n\u9ec3\uff1a\u30de\u30c3\u30d7\u30c9\u30d5\u30a1\u30a4\u30eb\n\n\nvaddump\n\nTo extract the range of pages described by a VAD node, use the vaddump command. This is similar to memdump, except the pages belonging to each VAD node are placed in separate files (named according to the starting and ending addresses) instead of one large conglomerate file. If any pages in the range are not memory resident, they're padded with 0's using the address space's zread() method.\n\nvaddump\u30b3\u30de\u30f3\u30c9\u306f\u3001VAD\u30ce\u30fc\u30c9\u306e\u9818\u57df\u306b\u3042\u308b\u30da\u30fc\u30b8\u3092\u51fa\u529b\u3059\u308b\u3002\n\u8907\u5408\u3057\u305f\u5927\u304d\u306a1\u30d5\u30a1\u30a4\u30eb\u306e\u4ee3\u308f\u308a\u306b\u5404VAD\u30ce\u30fc\u30c9\u306b\u5c5e\u3059\u308b\u30da\u30fc\u30b8\u304c\u5206\u5272\u3055\u308c\u305f\u30d5\u30a1\u30a4\u30eb(\u958b\u59cb\u30fb\u7d42\u4e86\u30a2\u30c9\u30ec\u30b9\u306b\u3088\u308b\u30d5\u30a1\u30a4\u30eb\u540d)\u306b\u306a\u308b\u3053\u3068\u4ee5\u5916\u306fmemdump\u306b\u4f3c\u3066\u3044\u308b\u3002\u7269\u7406\u30e1\u30e2\u30ea\u306b\u3069\u306e\u30da\u30fc\u30b8\u3082\u306a\u3044\u5834\u5408\u3001\u30a2\u30c9\u30ec\u30b9\u7a7a\u9593\u306ezread()\u30e1\u30bd\u30c3\u30c9\u306b\u3088\u3063\u30660\u3067\u30d1\u30c7\u30a3\u30f3\u30b0\u3055\u308c\u308b\u3002\n$ python vol.py -f ~/Desktop/win7_trial_64bit.raw --profile=Win7SP0x64 vaddump -D vads\nVolatility Foundation Volatility Framework 2.4\nPid        Process              Start              End                Result\n---------- -------------------- ------------------ ------------------ ------\n         4 System               0x0000000076d40000 0x0000000076eeafff vads/System.17fef9e0.0x0000000076d40000-0x0000000076eeafff.dmp\n         4 System               0x0000000000040000 0x0000000000040fff vads/System.17fef9e0.0x0000000000040000-0x0000000000040fff.dmp\n         4 System               0x0000000000010000 0x0000000000032fff vads/System.17fef9e0.0x0000000000010000-0x0000000000032fff.dmp\n         4 System               0x000000007ffe0000 0x000000007ffeffff vads/System.17fef9e0.0x000000007ffe0000-0x000000007ffeffff.dmp\n         4 System               0x0000000076f20000 0x000000007709ffff vads/System.17fef9e0.0x0000000076f20000-0x000000007709ffff.dmp\n       208 smss.exe             0x000000007efe0000 0x000000007ffdffff vads/smss.exe.176e97f0.0x000000007efe0000-0x000000007ffdffff.dmp\n       208 smss.exe             0x00000000003d0000 0x00000000004cffff vads/smss.exe.176e97f0.0x00000000003d0000-0x00000000004cffff.dmp\n       208 smss.exe             0x0000000000100000 0x0000000000100fff vads/smss.exe.176e97f0.0x0000000000100000-0x0000000000100fff.dmp\n       208 smss.exe             0x0000000000000000 0x00000000000fffff vads/smss.exe.176e97f0.0x0000000000000000-0x00000000000fffff.dmp\n       208 smss.exe             0x0000000000190000 0x000000000020ffff vads/smss.exe.176e97f0.0x0000000000190000-0x000000000020ffff.dmp\n       208 smss.exe             0x0000000047a90000 0x0000000047aaffff vads/smss.exe.176e97f0.0x0000000047a90000-0x0000000047aaffff.dmp\n       208 smss.exe             0x00000000005e0000 0x000000000065ffff vads/smss.exe.176e97f0.0x00000000005e0000-0x000000000065ffff.dmp\n[snip]\n\n$ ls -al vads/\ntotal 123720\ndrwxr-xr-x  69 michaelligh  staff      2346 Apr  6 13:12 .\ndrwxr-xr-x  37 michaelligh  staff      1258 Apr  6 13:11 ..\n-rw-r--r--   1 michaelligh  staff    143360 Apr  6 13:12 System.17fef9e0.0x0000000000010000-0x0000000000032fff.dmp\n-rw-r--r--   1 michaelligh  staff      4096 Apr  6 13:12 System.17fef9e0.0x0000000000040000-0x0000000000040fff.dmp\n-rw-r--r--   1 michaelligh  staff   1748992 Apr  6 13:12 System.17fef9e0.0x0000000076d40000-0x0000000076eeafff.dmp\n-rw-r--r--   1 michaelligh  staff   1572864 Apr  6 13:12 System.17fef9e0.0x0000000076f20000-0x000000007709ffff.dmp\n-rw-r--r--   1 michaelligh  staff     65536 Apr  6 13:12 System.17fef9e0.0x000000007ffe0000-0x000000007ffeffff.dmp\n-rw-r--r--   1 michaelligh  staff   1048576 Apr  6 13:12 csrss.exe.176006c0.0x0000000000000000-0x00000000000fffff.dmp\n-rw-r--r--   1 michaelligh  staff    421888 Apr  6 13:12 csrss.exe.176006c0.0x0000000000100000-0x0000000000166fff.dmp\n-rw-r--r--   1 michaelligh  staff      4096 Apr  6 13:12 csrss.exe.176006c0.0x0000000000170000-0x0000000000170fff.dmp\n-rw-r--r--   1 michaelligh  staff      8192 Apr  6 13:12 csrss.exe.176006c0.0x0000000000180000-0x0000000000181fff.dmp\n[snip]\n\n\nThe files are named like this:\n\n\u30d5\u30a1\u30a4\u30eb\u540d\u3092\u3053\u306e\u3088\u3046\u306b\u306a\u308b\uff1a\n\nProcessName.PhysicalOffset.StartingVPN.EndingVPN.dmp\n\n\u30d7\u30ed\u30bb\u30b9\u540d.\u7269\u7406\u30aa\u30d5\u30bb\u30c3\u30c8.\u958b\u59cbVPN.\u7d42\u4e86VPN.dmp\n\nThe reason the PhysicalOffset field exists is so you can distinguish between two processes with the same name.\n\n\u540c\u3058\u540d\u79f0\u306e\u30d7\u30ed\u30bb\u30b9\u3092\u8b58\u5225\u3059\u308b\u305f\u3081\u306b\u7269\u7406\u30aa\u30d5\u30bb\u30c3\u30c8\u6b04\u304c\u3042\u308b\n\nevtlogs\n\nThe evtlogs command extracts and parses binary event logs from memory. Binary event logs are found on Windows XP and 2003 machines, therefore this plugin only works on these architectures. These files are extracted from VAD of the services.exe process, parsed and dumped to a specified location.\n\nevtlogs\u30b3\u30de\u30f3\u30c9\u306f\u3001\u30e1\u30e2\u30ea\u4e0a\u306e\u30d0\u30a4\u30ca\u30ea\u30a4\u30d9\u30f3\u30c8\u30ed\u30b0\u3092\u62bd\u51fa\u3059\u308b\u3002\u30d0\u30a4\u30ca\u30ea\u30a4\u30d9\u30f3\u30c8\u30ed\u30b0\u306fWindows XP\u30682003\u306b\u5b58\u5728\u3059\u308b\u306e\u3067\u3001\u3053\u308c\u3089\u306e\u30a2\u30fc\u30ad\u30c6\u30af\u30c1\u30e3\u4e0a\u3067\u306e\u307f\u6709\u52b9\u3067\u3042\u308b\u3002service.exe\u30d7\u30ed\u30bb\u30b9\u306eVAD\u304b\u3089\u62bd\u51fa\u3001\u30d1\u30fc\u30b9\u3055\u308c\u3066\u6307\u5b9a\u3055\u308c\u305f\u5834\u6240\u306b\u51fa\u529b\u3055\u308c\u308b\u3002\n$ python vol.py -f WinXPSP1x64.vmem --profile=WinXPSP2x64 evtlogs -D output\nVolatility Foundation Volatility Framework 2.4\nParsed data sent to appevent.txt\nParsed data sent to secevent.txt\nParsed data sent to sysevent.txt\n\n\nThere is also an option (--save-evt) to dump raw event logs for parsing with external tools:\n\n\u5225\u306e\u30c4\u30fc\u30eb\u3067\u30d1\u30fc\u30b9\u3059\u308b\u305f\u3081\u306b\u3001\u30d1\u30fc\u30b9\u524d\u306e\u30c0\u30f3\u30d7\u3092\u884c\u3046\u30aa\u30d7\u30b7\u30e7\u30f3\u304c\u3042\u308b\u3002(--save-evt)\n$ python vol.py -f WinXPSP1x64.vmem --profile=WinXPSP2x64 evtlogs\n--save-evt -D output\nVolatility Foundation Volatility Framework 2.4\nSaved raw .evt file to appevent.evt\nParsed data sent to appevent.txt\nSaved raw .evt file to secevent.evt\nParsed data sent to secevent.txt\nSaved raw .evt file to sysevent.evt\nParsed data sent to sysevent.txt\nParsed output is pipe delimited to make it easier to import into excel files and the \"messages\" are separated by semicolons:\n\n$ cat output/secevent.txt\n\n2012-01-17 12:01:27|secevent.evt|MACHINENAME|S-1-5-18 (Local System)|Security|612|Success|-;-;+;-;-;-;-;-;-;-;-;-;-;-;-;-;+;-;MACHINENAME$;;(0x0,0x3E7)\n2012-01-17 17:06:18|secevent.evt|MACHINENAME|S-1-5-19 (NT Authority)|Security|528|Success|LOCAL SERVICE;NT AUTHORITY;(0x0,0x3E5);5;Advapi;Negotiate;;-;MACHINENAME$(0x0,0x3E7);252;-;-;-\n2012-01-17 17:06:18|secevent.evt|MACHINENAME|S-1-5-19 (NT Authority)|Security|576|Success|LOCAL SERVICE;NT AUTHORITY;(0x0,0x3E5);SeAuditPrivilege            SeAssignPrimaryTokenPrivilege                   SeImpersonatePrivilege\n2012-01-17 17:06:19|secevent.evt|MACHINENAME|S-1-5-20 (NT Authority)|Security|528|Success|NETWORK SERVICE;NT AUTHORITY;(0x0,0x3E4);5;Advapi;Negotiate;;-;MACHINENAME$(0x0,0x3E7);252;-;-;-\n2012-01-17 17:06:19|secevent.evt|MACHINENAME|S-1-5-20 (NT Authority)|Security|576|Success|NETWORK SERVICE;NTAUTHORITY;(0x0,0x3E4);SeAuditPrivilege                  SeAssignPrimaryTokenPrivilege                   SeImpersonatePrivilege\n\n[snip]\n\n\nIf the --verbose flag is used, SIDs are also evaluated and placed in the parsed output instead of the defaulting raw SID. This action takes longer to run, since the plugin has to calculate each of the service SID and user SID from registry entries.\n\n--verbose\u30aa\u30d7\u30b7\u30e7\u30f3\u304c\u6307\u5b9a\u3055\u308c\u308b\u3068\u3001\u65e2\u5b9a\u306e\u52a0\u5de5\u3057\u3066\u3044\u306a\u3044SID\u306e\u4ee3\u308f\u308a\u306bSID\u304c\u8a55\u4fa1\u3055\u308c\u3066\u8868\u793a\u3055\u308c\u308b\u3002\u3053\u306e\u52d5\u4f5c\u306b\u306f\u6bd4\u8f03\u3059\u308b\u3068\u9577\u3044\u6642\u9593\u304c\u304b\u304b\u308b\u304c\u3001\u5404\u30b5\u30fc\u30d3\u30b9SID\u3068\u30e6\u30fc\u30b6SID\u3092\u30ec\u30b8\u30b9\u30c8\u30ea\u30a8\u30f3\u30c8\u30ea\u304b\u3089\u8a08\u7b97\u3057\u3066\u3044\u308b\u305f\u3081\u3067\u3059\u3002\n\niehistory\n\nThis plugin recovers fragments of IE history index.dat cache files. It can find basic accessed links (via FTP or HTTP), redirected links (--REDR), and deleted entries (--LEAK). It applies to any process which loads and uses the wininet.dll library, not just Internet Explorer. Typically that includes Windows Explorer and even malware samples. For more information, see HowTo: Scan for Internet Cache/History and URLs.\n\n\u3053\u306e\u30d7\u30e9\u30b0\u30a4\u30f3\u306f\u3001IE\u5c65\u6b74\u306eindex.dat\u30ad\u30e3\u30c3\u30b7\u30e5\u30d5\u30a1\u30a4\u30eb\u306e\u65ad\u7247\u3092\u4fee\u5fa9\u3057\u307e\u3059\u3002\u666e\u901a\u306e\u30a2\u30af\u30bb\u30b9(FTP\u304bHTTP\u306b\u3088\u308b)\u3001\u30ea\u30c0\u30a4\u30ec\u30af\u30c8\u30ea\u30f3\u30af(--REDR)\u3001\u524a\u9664\u3055\u308c\u305f\u30a8\u30f3\u30c8\u30ea(--LEAK)\u3092\u898b\u3064\u3051\u308b\u3053\u3068\u304c\u3067\u304d\u307e\u3059\u3002IE\u3060\u3051\u3067\u306f\u306a\u304f\u3001wininet.dll\u30e9\u30a4\u30d6\u30e9\u30ea\u3092\u30ed\u30fc\u30c9\u3057\u3066\u5229\u7528\u3057\u3066\u3044\u308b\u3059\u3079\u3066\u306e\u30d7\u30ed\u30bb\u30b9\u306b\u9069\u7528\u3055\u308c\u307e\u3059\u3002\u4e00\u822c\u7684\u306b\u3001Windows Explorer\u3068\u30de\u30eb\u30a6\u30a7\u30a2\u30b5\u30f3\u30d7\u30eb\u3092\u542b\u307f\u307e\u3059\u3002\n$ python vol.py -f exemplar17_1.vmem iehistory\nVolatility Foundation Volatility Framework 2.4\n**************************************************\nProcess: 1928 explorer.exe\nCache type \"URL \" at 0xf25100\nRecord length: 0x100\nLocation: Visited: foo@http://192.168.30.129/malware/40024.exe\nLast modified: 2009-01-08 01:52:09\nLast accessed: 2009-01-08 01:52:09\nFile Offset: 0x100, Data Offset: 0x0, Data Length: 0xa0\n**************************************************\nProcess: 1928 explorer.exe\nCache type \"URL \" at 0xf25300\nRecord length: 0x180\nLocation: Visited: foo@http://www.abcjmp.com/jump1/?affiliate=mu1&subid=88037&terms=eminem&sid=Z605044303%40%40wMfNTNxkTM1EzX5QzNy81My8lM18FN4gTM2gzNzITM&a=zh5&mr=1&rc=0\nLast modified: 2009-01-08 01:52:44\nLast accessed: 2009-01-08 01:52:44\nFile Offset: 0x180, Data Offset: 0x0, Data Length: 0x108\n**************************************************\n.....\n\n\nKernel Memory and Objects\n\nmodules\n\nTo view the list of kernel drivers loaded on the system, use the modules command. This walks the doubly-linked list of LDR_DATA_TABLE_ENTRY structures pointed to by PsLoadedModuleList. Similar to the pslist command, this relies on finding the KDBG structure. In rare cases, you may need to use kdbgscan to find the most appropriate KDBG structure address and then supply it to this plugin like --kdbg=ADDRESS.\n```\n\nmodules\u30b3\u30de\u30f3\u30c9\u306b\u3088\u3063\u3066\u3001\u30b7\u30b9\u30c6\u30e0\u306b\u30ed\u30fc\u30c9\u3055\u308c\u3066\u3044\u305f\u30ab\u30fc\u30cd\u30eb\u30c9\u30e9\u30a4\u30d0\u306e\u30ea\u30b9\u30c8\u3092\u5f97\u308b\u3053\u3068\u304c\u3067\u307e\u3059\u3002PsLoadedModuleList\u304c\u793a\u3059\u3001LDR_DATA_TABLE_ENTRY\u69cb\u9020\u4f53\u306e\u30c0\u30d6\u30eb\u30ea\u30f3\u30af\u30ea\u30b9\u30c8\u3092\u8fbf\u308a\u307e\u3059\u3002pslist\u30b3\u30de\u30f3\u30c9\u3068\u540c\u69d8\u306b\u3001KDBG\u69cb\u9020\u4f53\u3092\u983c\u308a\u306b\u3057\u307e\u3059\u3002\u30ec\u30a2\u30b1\u30fc\u30b9\u3067\u306f\u3001\u6700\u3082\u9069\u5207\u306aKDBG\u69cb\u9020\u4f53\u306e\u30a2\u30c9\u30ec\u30b9\u3092kdbgscan\u3067\u898b\u3064\u3051\u3066\u3001--kdbg=ADDRESS\u3068\u3044\u3046\u3088\u3046\u306b\u4e0e\u3048\u308b\u5fc5\u8981\u304c\u3042\u308b\u304b\u3082\u3057\u308c\u307e\u305b\u3093\u3002\n\nIt cannot find hidden/unlinked kernel drivers, however modscan serves that purpose. Also, since this plugin uses list walking techniques, you typically can assume that the order the modules are displayed in the output is the order they were loaded on the system. For example, below, ntoskrnl.exe was first to load, followed by hal.dll, etc.\n\n\u96a0\u853d\u3055\u308c\u305f\uff0f\u30ea\u30f3\u30af\u3092\u5916\u3055\u308c\u305f\u30ab\u30fc\u30cd\u30eb\u30c9\u30e9\u30a4\u30d0\u3092\u898b\u3064\u3051\u308b\u3053\u3068\u306f\u3067\u304d\u307e\u305b\u3093\u304c\u3001modscan\u304c\u305d\u306e\u305f\u3081\u306b\u4f7f\u3048\u307e\u3059\u3002\u30c0\u30d6\u30eb\u30ea\u30f3\u30af\u30ea\u30b9\u30c8\u3092\u305f\u3069\u308b\u305f\u3081\u3001\u901a\u5e38\u30b7\u30b9\u30c6\u30e0\u306b\u30ed\u30fc\u30c9\u3055\u308c\u305f\u9806\u756a\u306b\u8868\u793a\u3055\u308c\u3066\u3044\u308b\u3068\u8003\u3048\u308b\u3053\u3068\u304c\u53ef\u80fd\u3067\u3059\u3002\u4f8b\u3048\u3070\u3001\u4e0b\u306e\u4f8b\u306b\u3042\u308b\u3088\u3046\u306b\u3001ntoskrnl.exe\u304c\u6700\u521d\u306b\u30ed\u30fc\u30c9\u3055\u308c\u3001\u305d\u306e\u5f8c\u304chal.dll\u3068\u306a\u3063\u3066\u3044\u308b\u3088\u3046\u306b\u3067\u3059\u3002\n$ python vol.py -f ~/Desktop/win7_trial_64bit.raw --profile=Win7SP0x64 modules\nVolatility Foundation Volatility Framework 2.4\nOffset(V)          Name                 Base                             Size File\n------------------ -------------------- ------------------ ------------------ ----\n0xfffffa80004a11a0 ntoskrnl.exe         0xfffff8000261a000           0x5dd000 \\SystemRoot\\system32\\ntoskrnl.exe\n0xfffffa80004a10b0 hal.dll              0xfffff80002bf7000            0x49000 \\SystemRoot\\system32\\hal.dll\n0xfffffa80004a7950 kdcom.dll            0xfffff80000bb4000             0xa000 \\SystemRoot\\system32\\kdcom.dll\n0xfffffa80004a7860 mcupdate.dll         0xfffff88000c3a000            0x44000 \\SystemRoot\\system32\\mcupdate_GenuineIntel.dll\n0xfffffa80004a7780 PSHED.dll            0xfffff88000c7e000            0x14000 \\SystemRoot\\system32\\PSHED.dll\n0xfffffa80004a7690 CLFS.SYS             0xfffff88000c92000            0x5e000 \\SystemRoot\\system32\\CLFS.SYS\n0xfffffa80004a8010 CI.dll               0xfffff88000cf0000            0xc0000 \\SystemRoot\\system32\\CI.dll\n[snip]\n\n\nThe output shows the offset of the LDR_DATA_TABLE_ENTRY structure, which is a virtual address by default but can be specified as a physical address with the -P switch as shown below. In either case, the Base column is the virtual address of the module's base in kernel memory (where you'd expect to find the PE header).\n\n\u3053\u306e\u51fa\u529b\u3067\u306f\u3001LDR_DATA_TABLE_ENTRY\u69cb\u9020\u4f53\u306e\u30aa\u30d5\u30bb\u30c3\u30c8\u304c\u30c7\u30d5\u30a9\u30eb\u30c8\u3067\u306f\u4eee\u60f3\u30a2\u30c9\u30ec\u30b9\u3067\u8868\u793a\u3055\u308c\u3066\u3044\u307e\u3059\u304c\u3001\u4e0b\u306e\u4f8b\u306b\u3042\u308b\u3088\u3046\u306b\u3001-P\u30b9\u30a4\u30c3\u30c1\u3067\u7269\u7406\u30a2\u30c9\u30ec\u30b9\u3092\u8868\u793a\u3055\u305b\u308b\u3088\u3046\u306b\u3059\u308b\u3053\u3068\u3082\u53ef\u80fd\u3067\u3059\u3002\u3069\u3061\u3089\u306e\u5834\u5408\u3067\u3082Base\u30ab\u30e9\u30e0\u306f\u3001\u30ab\u30fc\u30cd\u30eb\u30e1\u30e2\u30ea\u5185\u3067\u306e\u30e2\u30b8\u30e5\u30fc\u30eb\u306e\u4eee\u60f3\u30d9\u30fc\u30b9\u30a2\u30c9\u30ec\u30b9\u3067\u3059(PE\u30d8\u30c3\u30c0\u3067\u898b\u3064\u3051\u3089\u308c\u308b)\u3002\n$ python vol.py -f ~/Desktop/win7_trial_64bit.raw --profile=Win7SP0x64 modules -P\nVolatility Foundation Volatility Framework 2.4\nOffset(P)          Name                 Base                             Size File\n------------------ -------------------- ------------------ ------------------ ----\n0x0000000017fe01a0 ntoskrnl.exe         0xfffff8000261a000           0x5dd000 \\SystemRoot\\system32\\ntoskrnl.exe\n0x0000000017fe00b0 hal.dll              0xfffff80002bf7000            0x49000 \\SystemRoot\\system32\\hal.dll\n0x0000000017fe6950 kdcom.dll            0xfffff80000bb4000             0xa000 \\SystemRoot\\system32\\kdcom.dll\n0x0000000017fe6860 mcupdate.dll         0xfffff88000c3a000            0x44000 \\SystemRoot\\system32\\mcupdate_GenuineIntel.dll\n0x0000000017fe6780 PSHED.dll            0xfffff88000c7e000            0x14000 \\SystemRoot\\system32\\PSHED.dll\n0x0000000017fe6690 CLFS.SYS             0xfffff88000c92000            0x5e000 \\SystemRoot\\system32\\CLFS.SYS\n0x0000000017fe7010 CI.dll               0xfffff88000cf0000            0xc0000 \\SystemRoot\\system32\\CI.dll\n[snip]\n\n\nmodscan\n\nThe modscan command finds LDR_DATA_TABLE_ENTRY structures by scanning physical memory for pool tags. This can pick up previously unloaded drivers and drivers that have been hidden/unlinked by rootkits. Unlike modules the order of results has no relationship with the order in which the drivers loaded. As you can see below, DumpIt.sys was found at the lowest physical offset, but it was probably one of the last drivers to load (since it was used to acquire memory).\n\nmodscan\u30b3\u30de\u30f3\u30c9\u306f\u3001\u7269\u7406\u30e1\u30e2\u30ea\u3067pool\u30bf\u30b0\u3092\u691c\u7d22\u3057\u3066LDR_DATA_TABLE_ENTRY\u69cb\u9020\u4f53\u3092\u898b\u3064\u3051\u307e\u3059\u3002\u3053\u308c\u306b\u3088\u308a\u3001\u30a2\u30f3\u30ed\u30fc\u30c9\u6e08\u307f\u306e\u30c9\u30e9\u30a4\u30d0\u3068\u30eb\u30fc\u30c8\u30ad\u30c3\u30c8\u306b\u3088\u308a\u96a0\u853d\uff0f\u30ea\u30f3\u30af\u3092\u5916\u3055\u308c\u305f\u30c9\u30e9\u30a4\u30d0\u3092\u898b\u3064\u3051\u308b\u3053\u3068\u304c\u53ef\u80fd\u3067\u3059\u3002modules\u30b3\u30de\u30f3\u30c9\u3068\u306f\u9055\u3044\u3001\u7d50\u679c\u306e\u9806\u756a\u306f\u30c9\u30e9\u30a4\u30d0\u304c\u30ed\u30fc\u30c9\u3055\u308c\u305f\u9806\u756a\u3068\u306f\u95a2\u4fc2\u304c\u3042\u308a\u307e\u305b\u3093\u3002\u4e0b\u306e\u4f8b\u3067\u5206\u304b\u308b\u3088\u3046\u306b\u3001DumpIt.sys\u304c\u6700\u3082\u4f4e\u3044\u7269\u7406\u30aa\u30d5\u30bb\u30c3\u30c8\u3067\u898b\u3064\u304b\u308a\u307e\u3057\u305f\u304c\u3001\u304a\u305d\u3089\u304f\u6700\u3082\u6700\u8fd1\u30ed\u30fc\u30c9\u3055\u308c\u305f\u30c9\u30e9\u30a4\u30d0\u306e\u4e00\u3064\u3067\u3059(\u30e1\u30e2\u30ea\u30c0\u30f3\u30d7\u306e\u305f\u3081\u306b\u4f7f\u308f\u308c\u305f\u30c9\u30e9\u30a4\u30d0\u306a\u306e\u3067)\u3002\n$ python vol.py -f ~/Desktop/win7_trial_64bit.raw --profile=Win7SP0x64 modscan\nVolatility Foundation Volatility Framework 2.4\nOffset(P)          Name                 Base                             Size File\n------------------ -------------------- ------------------ ------------------ ----\n0x00000000173b90b0 DumpIt.sys           0xfffff88003980000            0x11000 \\??\\C:\\Windows\\SysWOW64\\Drivers\\DumpIt.sys\n0x000000001745b180 mouhid.sys           0xfffff880037e9000             0xd000 \\SystemRoot\\system32\\DRIVERS\\mouhid.sys\n0x0000000017473010 lltdio.sys           0xfffff88002585000            0x15000 \\SystemRoot\\system32\\DRIVERS\\lltdio.sys\n0x000000001747f010 rspndr.sys           0xfffff8800259a000            0x18000 \\SystemRoot\\system32\\DRIVERS\\rspndr.sys\n0x00000000174cac40 dxg.sys              0xfffff96000440000            0x1e000 \\SystemRoot\\System32\\drivers\\dxg.sys\n0x0000000017600190 monitor.sys          0xfffff8800360c000             0xe000 \\SystemRoot\\system32\\DRIVERS\\monitor.sys\n0x0000000017601170 HIDPARSE.SYS         0xfffff880037de000             0x9000 \\SystemRoot\\system32\\DRIVERS\\HIDPARSE.SYS\n0x0000000017604180 USBD.SYS             0xfffff880037e7000             0x2000 \\SystemRoot\\system32\\DRIVERS\\USBD.SYS\n0x0000000017611d70 cdrom.sys            0xfffff88001944000            0x2a000 \\SystemRoot\\system32\\DRIVERS\\cdrom.sys\n[snip]\n\n\nmoddump\n\nTo extract a kernel driver to a file, use the moddump command. Supply the output directory with -D or --dump-dir=DIR. Without any additional parameters, all drivers identified by modlist will be dumped. If you want a specific driver, supply a regular expression of the driver's name with --regex=REGEX or the module's base address with --base=BASE.\n\nmoddump\u30b3\u30de\u30f3\u30c9\u306f\u3001\u30ab\u30fc\u30cd\u30eb\u30c9\u30e9\u30a4\u30d0\u3092\u30d5\u30a1\u30a4\u30eb\u306b\u51fa\u529b\u3057\u307e\u3059\u3002-D\u3082\u3057\u304f\u306f--dump-dir=DIR\u30aa\u30d7\u30b7\u30e7\u30f3\u3067\u51fa\u529b\u30c7\u30a3\u30ec\u30af\u30c8\u30ea\u3092\u6307\u5b9a\u3057\u307e\u3059\u3002\u30d1\u30e9\u30e1\u30fc\u30bf\u306e\u6307\u5b9a\u3057\u306a\u3044\u3068modlist\u3067\u8b58\u5225\u3055\u308c\u305f\u3059\u3079\u3066\u306e\u30c9\u30e9\u30a4\u30d0\u304c\u51fa\u529b\u3055\u308c\u307e\u3059\u3002\u7279\u5b9a\u306e\u30c9\u30e9\u30a4\u30d0\u3092\u51fa\u529b\u3057\u305f\u3044\u5834\u5408\u3001--regex=REGEX\u30aa\u30d7\u30b7\u30e7\u30f3\u3067\u30c9\u30e9\u30a4\u30d0\u306e\u540d\u524d\u3092\u6b63\u898f\u8868\u73fe\u3067\u6307\u5b9a\u3059\u308b\u304b\u3001--base=BASE\u30aa\u30d7\u30b7\u30e7\u30f3\u3067\u30e2\u30b8\u30e5\u30fc\u30eb\u306e\u30d9\u30fc\u30b9\u30a2\u30c9\u30ec\u30b9\u3092\u6307\u5b9a\u3057\u307e\u3059\u3002\n\nFor more information, see BDG's Plugin Post: Moddump.\n\n\u66f4\u306b\u8a73\u3057\u3044\u60c5\u5831\u306f\u3001BDG\u306e\u30d7\u30e9\u30b0\u30a4\u30f3\u30dd\u30b9\u30c8\u3092\u53c2\u7167\u3057\u3066\u304f\u3060\u3055\u3044\u3002\n$ python vol.py -f ~/Desktop/win7_trial_64bit.raw --profile=Win7SP0x64 moddump -D drivers/\nVolatility Foundation Volatility Framework 2.4\nModule Base        Module Name          Result\n------------------ -------------------- ------\n0xfffff8000261a000 ntoskrnl.exe         OK: driver.fffff8000261a000.sys\n0xfffff80002bf7000 hal.dll              OK: driver.fffff80002bf7000.sys\n0xfffff88000e5c000 intelide.sys         OK: driver.fffff88000e5c000.sys\n0xfffff8800349b000 mouclass.sys         OK: driver.fffff8800349b000.sys\n0xfffff88000f7c000 msisadrv.sys         OK: driver.fffff88000f7c000.sys\n0xfffff880035c3000 ndistapi.sys         OK: driver.fffff880035c3000.sys\n0xfffff88002c5d000 pacer.sys            OK: driver.fffff88002c5d000.sys\n[snip]\n\n\nSimilar to dlldump, if critical parts of the PE header are not memory resident, then rebuilding/extracting the driver may fail. Additionally, for drivers that are mapped in different sessions (like win32k.sys), there is currently no way to specify which session to use when acquiring the driver sample.\n\ndlldump\u3068\u540c\u69d8\u306b\u3001PE\u30d8\u30c3\u30c0\u306e\u30af\u30ea\u30c6\u30a3\u30ab\u30eb\u306a\u90e8\u5206\u304c\u30e1\u30e2\u30ea\u306b\u8f09\u3063\u3066\u3044\u306a\u3044\u5834\u5408\u3001\u30c9\u30e9\u30a4\u30d0\u306e\u6700\u69cb\u6210\uff0f\u51fa\u529b\u306f\u5931\u6557\u3059\u308b\u304b\u3082\u3057\u308c\u307e\u305b\u3093\u3002\u66f4\u306b\u3001(win32k.sys\u306e\u3088\u3046\u306b)\u5225\u306e\u30bb\u30c3\u30b7\u30e7\u30f3\u306b\u30de\u30c3\u30d7\u3055\u308c\u305f\u30c9\u30e9\u30a4\u30d0\u306b\u95a2\u3057\u3066\u306f\u3001\u73fe\u5728\u3069\u306e\u30bb\u30c3\u30b7\u30e7\u30f3\u3092\u4f7f\u3063\u3066\u30c9\u30e9\u30a4\u30d0\u3092\u53d6\u5f97\u3059\u308b\u304b\u3092\u6307\u5b9a\u3059\u308b\u3053\u3068\u306f\u3067\u304d\u307e\u305b\u3093\u3002\n\nssdt\n\nTo list the functions in the Native and GUI SSDTs, use the ssdt command. This displays the index, function name, and owning driver for each entry in the SSDT. Please note the following:\nWindows has 4 SSDTs by default (you can add more with KeAddSystemServiceTable), but only 2 of them are used - one for Native functions in the NT module, and one for GUI functions in the win32k.sys module.\n\nssdt\u30b3\u30de\u30f3\u30c9\u306f\u3001\u30cd\u30a4\u30c6\u30a3\u30d6\u3068GUI SSDT\u3092\u8868\u793a\u3057\u307e\u3059\u3002\u305d\u308c\u305e\u308c\u306eSSDT\u30a8\u30f3\u30c8\u30ea\u306e\u30a4\u30f3\u30c7\u30c3\u30af\u30b9\u3001\u95a2\u6570\u540d\u3001\u30c9\u30e9\u30a4\u30d0\u3092\u8868\u793a\u3057\u307e\u3059\u3002\u4ee5\u4e0b\u306e\u3053\u3068\u306b\u6ce8\u610f\u3057\u3066\u304f\u3060\u3055\u3044\u3002Windows\u306f\u30c7\u30d5\u30a9\u30eb\u30c8\u30674\u3064\u306eSSDT\u3092\u6301\u3063\u3066\u3044\u307e\u3059\u304c\u30012\u3064\u306e\u307f\u304c\u4f7f\u7528\u3055\u308c\u3066\u3044\u307e\u3059\u3002NT\u30e2\u30b8\u30e5\u30fc\u30eb\u5185\u306e\u30cd\u30a4\u30c6\u30a3\u30d6\u95a2\u6570\u3068win32k.sys\u30e2\u30b8\u30e5\u30fc\u30eb\u5185\u306eGUI\u95a2\u6570\u3067\u3059\u3002\n\nThere are multiple ways to locate the SSDTs in memory. Most tools do it by finding the exported KeServiceDescriptorTable symbol in the NT module, but this is not the way Volatility works.\n\n\u30e1\u30e2\u30ea\u5185\u306eSSDT\u306e\u5834\u6240\u3092\u77e5\u308b\u306b\u306f\u3044\u304f\u3064\u304b\u306e\u65b9\u6cd5\u304c\u3042\u308a\u307e\u3059\u3002\u307b\u3068\u3093\u3069\u30c4\u30fc\u30eb\u306f\u3001NT\u30e2\u30b8\u30e5\u30fc\u30eb\u3067\u30a8\u30af\u30b9\u30dd\u30fc\u30c8\u3055\u308c\u3066\u3044\u308bKeServiceDescriptorTable\u30b7\u30f3\u30dc\u30eb\u3092\u898b\u3064\u3051\u3066\u5229\u7528\u3057\u307e\u3059\u304c\u3001Volatility\u306f\u5225\u306e\u65b9\u6cd5\u3092\u4f7f\u3044\u307e\u3059\u3002\n\nFor x86 systems, Volatility scans for ETHREAD objects (see the thrdscan command) and gathers all unique ETHREAD.Tcb.ServiceTable pointers. This method is more robust and complete, because it can detect when rootkits make copies of the existing SSDTs and assign them to particular threads. Also see the threads command.\n\nx86\u30b7\u30b9\u30c6\u30e0\u3067\u306f\u3001Volatility\u306fETHREAD\u30aa\u30d6\u30b8\u30a7\u30af\u30c8\u3092\u691c\u7d22\u3057(thrdscan\u30b3\u30de\u30f3\u30c9\u53c2\u7167)\u3001\u30e6\u30cb\u30fc\u30af\u306aETHREAD.Tcb.ServiceTable\u30dd\u30a4\u30f3\u30bf\u3092\u96c6\u3081\u307e\u3059\u3002\u3053\u306e\u65b9\u6cd5\u306f\u3001\u30eb\u30fc\u30c8\u30ad\u30c3\u30c8\u304cSSDT\u306e\u30b3\u30d4\u30fc\u3092\u4f5c\u6210\u3057\u3066\u7279\u5b9a\u306e\u30b9\u30ec\u30c3\u30c9\u306b\u5272\u308a\u5f53\u3066\u305f\u6642\u306b\u691c\u77e5\u3067\u304d\u308b\u305f\u3081\u3001\u3088\u308a\u5b89\u5b9a\u3057\u305f\u5b8c\u5168\u306a\u65b9\u6cd5\u3067\u3059\u3002threads\u30b3\u30de\u30f3\u30c9\u3092\u53c2\u7167\u3057\u3066\u304f\u3060\u3055\u3044\u3002\n\nFor x64 systems (which do not have an ETHREAD.Tcb.ServiceTable member) Volatility disassembles code in ntKeAddSystemServiceTable and finds its references to the KeServiceDescriptorTable and KeServiceDescriptorTableShadow symbols.\n\nx64\u30b7\u30b9\u30c6\u30e0(ETHREAD.Tcb.ServiceTable\u304c\u5b58\u5728\u3057\u307e\u305b\u3093)\u3067\u306f\u3001Volatility\u306fntKeAddSystemServiceTable\u5185\u306e\u30b3\u30fc\u30c9\u3092\u9006\u30a2\u30bb\u30f3\u30d6\u30eb\u3057\u3066KeServiceDescriptorTable\u3068KeServiceDescriptorTableShadow\u306e\u30b7\u30f3\u30dc\u30eb\u3078\u306e\u30ea\u30d5\u30a1\u30ec\u30f3\u30b9\u3092\u898b\u3064\u3051\u307e\u3059\u3002\n\nThe order and total number of functions in the SSDTs differ across operating system versions. Thus, Volatility stores the information in a per-profile (OS) dictionary which is auto-generated and cross-referenced using the ntoskrnl.exe, ntdll.dll, win32k.sys, user32.dll and gdi32.dll modules from the respective systems.\n\nSSDT\u5185\u306e\u95a2\u6570\u306e\u9806\u756a\u3068\u7dcf\u6570\u306f\u3001OS\u306e\u30d0\u30fc\u30b8\u30e7\u30f3\u306b\u3088\u3063\u3066\u7570\u306a\u308a\u307e\u3059\u3002\u305d\u306e\u305f\u3081\u3001Volatility\u306f\u3001\u500b\u5225\u306e\u30b7\u30b9\u30c6\u30e0\u306entoskrnl.exe\u3001ntdll.dll\u3001win32k.sys\u3001user32.dll\u304a\u3088\u3073gdi32.dll\u30e2\u30b8\u30e5\u30fc\u30eb\u3092\u4f7f\u3063\u3066\u76f8\u4e92\u30ea\u30d5\u30a1\u30ec\u30f3\u30b9\u3092\u81ea\u52d5\u751f\u6210\u3057\u305f\u30d7\u30ed\u30d5\u30a1\u30a4\u30eb(OS)\u3054\u3068\u306e\u8f9e\u66f8\u306b\u60c5\u5831\u3092\u51fa\u529b\u3057\u307e\u3059\u3002\n\nFor more information, see BDG's Auditing the System Call Table.\n\n    $ python vol.py -f ~/Desktop/win7_trial_64bit.raw --profile=Win7SP0x64 ssdt\n    Volatility Foundation Volatility Framework 2.4\n    [x64] Gathering all referenced SSDTs from KeAddSystemServiceTable...\n    Finding appropriate address space for tables...\n    SSDT[0] at fffff8000268cb00 with 401 entries\n      Entry 0x0000: 0xfffff80002a9d190 (NtMapUserPhysicalPagesScatter) owned by ntoskrnl.exe\n      Entry 0x0001: 0xfffff80002983a00 (NtWaitForSingleObject) owned by ntoskrnl.exe\n      Entry 0x0002: 0xfffff80002683dd0 (NtCallbackReturn) owned by ntoskrnl.exe\n      Entry 0x0003: 0xfffff800029a6b10 (NtReadFile) owned by ntoskrnl.exe\n      Entry 0x0004: 0xfffff800029a4bb0 (NtDeviceIoControlFile) owned by ntoskrnl.exe\n      Entry 0x0005: 0xfffff8000299fee0 (NtWriteFile) owned by ntoskrnl.exe\n      Entry 0x0006: 0xfffff80002945dc0 (NtRemoveIoCompletion) owned by ntoskrnl.exe\n      Entry 0x0007: 0xfffff80002942f10 (NtReleaseSemaphore) owned by ntoskrnl.exe\n      Entry 0x0008: 0xfffff8000299ada0 (NtReplyWaitReceivePort) owned by ntoskrnl.exe\n      Entry 0x0009: 0xfffff80002a6ce20 (NtReplyPort) owned by ntoskrnl.exe\n\n    [snip]\n\n    SSDT[1] at fffff96000101c00 with 827 entries\n      Entry 0x1000: 0xfffff960000f5580 (NtUserGetThreadState) owned by win32k.sys\n      Entry 0x1001: 0xfffff960000f2630 (NtUserPeekMessage) owned by win32k.sys\n      Entry 0x1002: 0xfffff96000103c6c (NtUserCallOneParam) owned by win32k.sys\n      Entry 0x1003: 0xfffff96000111dd0 (NtUserGetKeyState) owned by win32k.sys\n      Entry 0x1004: 0xfffff9600010b1ac (NtUserInvalidateRect) owned by win32k.sys\n      Entry 0x1005: 0xfffff96000103e70 (NtUserCallNoParam) owned by win32k.sys\n      Entry 0x1006: 0xfffff960000fb5a0 (NtUserGetMessage) owned by win32k.sys\n      Entry 0x1007: 0xfffff960000dfbec (NtUserMessageCall) owned by win32k.sys\n      Entry 0x1008: 0xfffff960001056c4 (NtGdiBitBlt) owned by win32k.sys\n      Entry 0x1009: 0xfffff960001fd750 (NtGdiGetCharSet) owned by win32k.sys\n\n\nTo filter all functions which point to ntoskrnl.exe and win32k.sys, you can use egrep on command-line. This will only show hooked SSDT functions.\n\n\u5168\u3066\u306entoskrnl.exe\u3068win32k.sys\u5185\u306e\u30a2\u30c9\u30ec\u30b9\u306b\u30dd\u30a4\u30f3\u30c8\u3059\u308b\u95a2\u6570\u3092\u975e\u8868\u793a\u306b\u3059\u308b\u305f\u3081\u306b\u3001\u30b3\u30de\u30f3\u30c9\u30e9\u30a4\u30f3\u4e0a\u3067egrep\u30b3\u30de\u30f3\u30c9\u3092\u4f7f\u3046\u3053\u3068\u304c\u3067\u304d\u307e\u3059\u3002\u3053\u308c\u306b\u3088\u308a\u3001\u30d5\u30c3\u30af\u3055\u308c\u305fSSDT\u95a2\u6570\u306e\u307f\u3092\u8868\u793a\u3067\u304d\u307e\u3059\u3002\n$ python vol.py -f ~/Desktop/win7_trial_64bit.raw --profile=Win7SP0x64 ssdt | egrep -v '(ntos|win32k)'\n\n\nNote that the NT module on your system may be ntkrnlpa.exe or ntkrnlmp.exe - so check that before using egrep of you'll be filtering the wrong module name. Also be aware that this isn't a hardened technique for finding hooks, as malware can load a driver named win32ktesting.sys and bypass your filter.\n\nNT\u30e2\u30b8\u30e5\u30fc\u30eb\u306f\u3001ntkrnlpa.exe\u3084ntkrnlmp.exe\u3067\u3042\u308b\u304b\u3082\u3057\u308c\u307e\u305b\u3093\u3002\u305d\u306e\u305f\u3081\u3001egrep\u3092\u4f7f\u3046\u524d\u306b\u9593\u9055\u3063\u305f\u30e2\u30b8\u30e5\u30fc\u30eb\u540d\u3067\u30d5\u30a3\u30eb\u30bf\u3092\u3057\u3088\u3046\u3068\u3057\u3066\u3044\u306a\u3044\u304b\u3092\u78ba\u8a8d\u3057\u3066\u304f\u3060\u3055\u3044\u3002\u30de\u30eb\u30a6\u30a7\u30a2\u306f\u3001win32ktesting.sys\u3068\u3044\u3046\u3088\u3046\u306a\u540d\u524d\u306e\u30c9\u30e9\u30a4\u30d0\u3092\u30ed\u30fc\u30c9\u3057\u3066\u30d5\u30a3\u30eb\u30bf\u3092\u56de\u907f\u3059\u308b\u3053\u3068\u306e\u53ef\u80fd\u306a\u306e\u3067\u3001\u5fc5\u305a\u3057\u3082\u6210\u529f\u3059\u308b\u30c6\u30af\u30cb\u30c3\u30af\u3067\u306f\u306a\u3044\u3053\u3068\u306b\u6ce8\u610f\u3057\u3066\u304f\u3060\u3055\u3044\u3002\n\ndriverscan\n\nTo find DRIVER_OBJECTs in physical memory using pool tag scanning, use the driverscan command. This is another way to locate kernel modules, although not all kernel modules have an associated DRIVER_OBJECT. The DRIVER_OBJECT is what contains the 28 IRP (Major Function) tables, thus the driverirp command is based on the methodology used by driverscan.\nFor more information, see Andreas Schuster's Scanning for Drivers.\n\n$ python vol.py -f ~/Desktop/win7_trial_64bit.raw --profile=Win7SP0x64 driverscan\nVolatility Foundation Volatility Framework 2.4\nOffset(P)          #Ptr #Hnd Start                            Size Service Key          Name         Driver Name\n------------------ ---- ---- ------------------ ------------------ -------------------- ------------ -----------\n0x00000000174c6350    3    0 0xfffff880037e9000             0xd000 mouhid               mouhid       \\Driver\\mouhid\n0x0000000017660cb0    3    0 0xfffff8800259a000            0x18000 rspndr               rspndr       \\Driver\\rspndr\n0x0000000017663e70    3    0 0xfffff88002585000            0x15000 lltdio               lltdio       \\Driver\\lltdio\n0x0000000017691d70    3    0 0xfffff88001944000            0x2a000 cdrom                cdrom        \\Driver\\cdrom\n0x0000000017692a50    3    0 0xfffff8800196e000             0x9000 Null                 Null         \\Driver\\Null\n0x0000000017695e70    3    0 0xfffff88001977000             0x7000 Beep                 Beep         \\Driver\\Beep\n0x00000000176965c0    3    0 0xfffff8800197e000             0xe000 VgaSave              VgaSave      \\Driver\\VgaSave\n0x000000001769fb00    4    0 0xfffff880019c1000             0x9000 RDPCDD               RDPCDD       \\Driver\\RDPCDD\n0x00000000176a1720    3    0 0xfffff880019ca000             0x9000 RDPENCDD             RDPENCDD     \\Driver\\RDPENCDD\n0x00000000176a2230    3    0 0xfffff880019d3000             0x9000 RDPREFMP             RDPREFMP     \\Driver\\RDPREFMP\n[snip]\n\n\nfilescan\n\nTo find FILE_OBJECTs in physical memory using pool tag scanning, use the filescan command. This will find open files even if a rootkit is hiding the files on disk and if the rootkit hooks some API functions to hide the open handles on a live system. The output shows the physical offset of the FILE_OBJECT, file name, number of pointers to the object, number of handles to the object, and the effective permissions granted to the object.\nFor more information, see Andreas Schuster's Scanning for File Objects and Linking File Objects To Processes.\n\n$ python vol.py -f ~/Desktop/win7_trial_64bit.raw --profile=Win7SP0x64 filescan\nVolatility Foundation Volatility Framework 2.4\nOffset(P)            #Ptr   #Hnd Access Name\n------------------ ------ ------ ------ ----\n0x000000000126f3a0     14      0 R--r-d \\Windows\\System32\\mswsock.dll\n0x000000000126fdc0     11      0 R--r-d \\Windows\\System32\\ssdpsrv.dll\n0x000000000468f7e0      6      0 R--r-d \\Windows\\System32\\cryptsp.dll\n0x000000000468fdc0     16      0 R--r-d \\Windows\\System32\\Apphlpdm.dll\n0x00000000048223a0      1      1 ------ \\Endpoint\n0x0000000004822a30     16      0 R--r-d \\Windows\\System32\\kerberos.dll\n0x0000000004906070     13      0 R--r-d \\Windows\\System32\\wbem\\repdrvfs.dll\n0x0000000004906580      9      0 R--r-d \\Windows\\SysWOW64\\netprofm.dll\n0x0000000004906bf0      9      0 R--r-d \\Windows\\System32\\wbem\\wmiutils.dll\n0x00000000049ce8e0      2      1 R--rwd \\$Extend\\$ObjId\n0x00000000049cedd0      1      1 R--r-d \\Windows\\System32\\en-US\\vsstrace.dll.mui\n0x0000000004a71070     17      1 R--r-d \\Windows\\System32\\en-US\\pnidui.dll.mui\n0x0000000004a71440     11      0 R--r-d \\Windows\\System32\\nci.dll\n0x0000000004a719c0      1      1 ------ \\srvsvc\n[snip]\n\n\nmutantscan\n\nTo scan physical memory for KMUTANT objects with pool tag scanning, use the mutantscan command. By default, it displays all objects, but you can pass -s or --silent to only show named mutexes. The CID column contains the process ID and thread ID of the mutex owner if one exists.\nFor more information, see Andreas Schuster's Searching for Mutants.\n\n$ python -f ~/Desktop/win7_trial_64bit.raw --profile=Win7SP0x64 mutantscan --silent\nVolatility Foundation Volatility Framework 2.4\nOffset(P)          #Ptr #Hnd Signal Thread                   CID Name\n------------------ ---- ---- ------ ------------------ --------- ----\n0x000000000f702630    2    1      1 0x0000000000000000           {A3BD3259-3E4F-428a-84C8-F0463A9D3EB5}\n0x00000000102fd930    2    1      1 0x0000000000000000           Feed Arbitration Shared Memory Mutex [ User : S-1-5-21-2628989162-3383567662-1028919141-1000 ]\n0x00000000104e5e60    3    2      1 0x0000000000000000           ZoneAttributeCacheCounterMutex\n0x0000000010c29e40    2    1      1 0x0000000000000000           _MSFTHISTORY_LOW_\n0x0000000013035080    2    1      1 0x0000000000000000           c:userstestingappdatalocalmicrosoftfeeds cache\n0x000000001722dfc0    2    1      1 0x0000000000000000           c:userstestingappdataroamingmicrosoftwindowsietldcachelow\n0x00000000172497f0    2    1      1 0x0000000000000000           LRIEElevationPolicyMutex\n0x000000001724bfc0    3    2      1 0x0000000000000000           BrowserEmulationSharedMemoryMutex\n0x000000001724f400    2    1      1 0x0000000000000000           c:userstestingappdatalocalmicrosoftwindowshistorylowhistory.ie5mshist012012022220120223\n0x000000001724f4c0    4    3      1 0x0000000000000000           _SHMSFTHISTORY_\n0x00000000172517c0    2    1      1 0x0000000000000000           __DDrawExclMode__\n0x00000000172783a0    2    1      1 0x0000000000000000           Lowhttp://sourceforge.net/\n0x00000000172db840    4    3      1 0x0000000000000000           ConnHashTable<1892>_HashTable_Mutex\n0x00000000172de1d0    2    1      1 0x0000000000000000           Feeds Store Mutex S-1-5-21-2628989162-3383567662-1028919141-1000\n0x00000000173b8080    2    1      1 0x0000000000000000           DDrawDriverObjectListMutex\n0x00000000173bd340    2    1      0 0xfffffa8000a216d0 1652:2000 ALTTAB_RUNNING_MUTEX\n0x0000000017449c40    2    1      1 0x0000000000000000           DDrawWindowListMutex\n[snip]\n\n\nsymlinkscan\n\nThis plugin scans for symbolic link objects and outputs their information. In the past, this has been used to link drive letters (i.e. D:, E:, F:, etc) to true crypt volumes (i.e. \\Device\\TrueCryptVolume). For more information, see Symbolic Link Objects and Identifying a Mounted True Crypt Volume from Artifacts in Volatile Memory.\n\n$ python -f ~/Desktop/win7_trial_64bit.raw --profile=Win7SP0x64 symlinkscan\nVolatility Foundation Volatility Framework 2.4\nOffset(P)            #Ptr   #Hnd Creation time            From                 To\n------------------ ------ ------ ------------------------ -------------------- ------------------------------------------------------------\n0x0000000000469780      1      0 2012-02-22 20:03:13      UMB#UMB#1...e1ba19f} \\Device\\00000048\n0x0000000000754560      1      0 2012-02-22 20:03:15      ASYNCMAC             \\Device\\ASYNCMAC\n0x0000000000ef6cf0      2      1 2012-02-22 19:58:24      0                    \\BaseNamedObjects\n0x00000000014b2a10      1      0 2012-02-22 20:02:10      LanmanRedirector     \\Device\\Mup\\;LanmanRedirector\n0x00000000053e56f0      1      0 2012-02-22 20:03:15      SW#{eeab7...abac361} \\Device\\KSENUM#00000001\n0x0000000005cc0770      1      0 2012-02-22 19:58:20      WanArpV6             \\Device\\WANARPV6\n0x0000000005cc0820      1      0 2012-02-22 19:58:20      WanArp               \\Device\\WANARP\n0x0000000008ffa680      1      0 2012-02-22 19:58:24      Global               \\BaseNamedObjects\n0x0000000009594810      1      0 2012-02-22 19:58:24      KnownDllPath         C:\\Windows\\syswow64\n0x000000000968f5f0      1      0 2012-02-22 19:58:23      KnownDllPath         C:\\Windows\\system32\n0x000000000ab24060      1      0 2012-02-22 19:58:20      Volume{3b...f6e6963} \\Device\\CdRom0\n0x000000000ab24220      1      0 2012-02-22 19:58:21      {EE0434CC...863ACC2} \\Device\\NDMP2\n0x000000000abd3460      1      0 2012-02-22 19:58:21      ACPI#PNP0...91405dd} \\Device\\00000041\n0x000000000abd36f0      1      0 2012-02-22 19:58:21      {802389A0...A90C31A} \\Device\\NDMP3\n[snip]\n\n\nthrdscan\n\nTo find ETHREAD objects in physical memory with pool tag scanning, use the thrdscan command. Since an ETHREAD contains fields that identify its parent process, you can use this technique to find hidden processes. One such use case is documented in the psxview command. Also, for verbose details, try the threads plugin.\n\n$ python vol.py -f ~/Desktop/win7_trial_64bit.raw --profile=Win7SP0x64 thrdscan\nVolatility Foundation Volatility Framework 2.4\nOffset(P)             PID    TID      Start Address Create Time               Exit Time\n------------------ ------ ------ ------------------ ------------------------- -------------------------\n0x0000000008df68d0    280    392         0x77943260 2012-02-22 19:08:18\n0x000000000eac3850   2040    144         0x76d73260 2012-02-22 11:28:59       2012-02-22 11:29:04\n0x000000000fd82590    880   1944         0x76d73260 2012-02-22 20:02:29       2012-02-22 20:02:29\n0x00000000103d15f0    880    884         0x76d73260 2012-02-22 19:58:43\n0x00000000103e5480   1652   1788 0xfffff8a0010ed490 2012-02-22 20:03:44\n0x00000000105a3940    916    324         0x76d73260 2012-02-22 20:02:07       2012-02-22 20:02:09\n0x00000000105b3560    816    824         0x76d73260 2012-02-22 19:58:42\n0x00000000106d1710    916   1228         0x76d73260 2012-02-22 20:02:11\n0x0000000010a349a0    816    820         0x76d73260 2012-02-22 19:58:41\n0x0000000010bd1060   1892   2280         0x76d73260 2012-02-22 11:26:13\n0x0000000010f24230    628    660         0x76d73260 2012-02-22 19:58:34\n0x0000000010f27060    568    648 0xfffff8a0017c6650 2012-02-22 19:58:34\n[snip]\n\n\ndumpfiles\n\nAn important concept that every computer scientist, especially those who have spent time doing operating system research, is intimately familiar with is that of caching. Files are cached in memory for system performance as they are accessed and used. This makes the cache a valuable source from a forensic perspective since we are able to retrieve files that were in use correctly, instead of file carving which does not make use of how items are mapped in memory. Files may not be completely mapped in memory (also for performance), so missing sections are zero padded. Files dumped from memory can then be processed with external tools.\nFor more information see AAron Walter's post: MoVP 4.4 Cache Rules Everything Around Me(mory).\nThere are several options in the dumpfiles plugin, for example:\n\n-r REGEX, --regex=REGEX\n                        Dump files matching REGEX\n  -i, --ignore-case     Ignore case in pattern match\n  -o OFFSET, --offset=OFFSET\n                        Dump files for Process with physical address OFFSET\n  -Q PHYSOFFSET, --physoffset=PHYSOFFSET\n                        Dump File Object at physical address PHYSOFFSET\n  -D DUMP_DIR, --dump-dir=DUMP_DIR\n                        Directory in which to dump extracted files\n  -S SUMMARY_FILE, --summary-file=SUMMARY_FILE\n                        File where to store summary information\n  -p PID, --pid=PID     Operate on these Process IDs (comma-separated)\n  -n, --name            Include extracted filename in output file path\n  -u, --unsafe          Relax safety constraints for more data\n  -F FILTER, --filter=FILTER\n                        Filters to apply (comma-separated)\n\nBy default, dumpfiles iterates through the VAD and extracts all files that are mapped as DataSectionObject, ImageSectionObject or SharedCacheMap. As an investigator, however, you may want to perform a more targeted search. You can use the -r and -i flags to specify a case-insensitive regex of a filename. In the output below, you can see where the file was dumped from (DataSectionObject, ImageSectionObject or SharedCacheMap), the offset of the _FILE_OBJECT, the PID of the process whose VAD contained the file and the file path on disk:\n\n$ python vol.py -f mebromi.raw dumpfiles -D output/ -r evt$ -i -S summary.txt\nVolatility Foundation Volatility Framework 2.4\nDataSectionObject 0x81ed6240   684    \\Device\\HarddiskVolume1\\WINDOWS\\system32\\config\\AppEvent.Evt\nSharedCacheMap 0x81ed6240   684    \\Device\\HarddiskVolume1\\WINDOWS\\system32\\config\\AppEvent.Evt\nDataSectionObject 0x8217beb0   684    \\Device\\HarddiskVolume1\\WINDOWS\\system32\\config\\SecEvent.Evt\nDataSectionObject 0x8217bd78   684    \\Device\\HarddiskVolume1\\WINDOWS\\system32\\config\\SysEvent.Evt\nSharedCacheMap 0x8217bd78   684    \\Device\\HarddiskVolume1\\WINDOWS\\system32\\config\\SysEvent.Evt\n\n$ ls output/\nfile.684.0x81fc6ed0.vacb    file.684.0x82256a48.dat     file.684.0x82256e48.dat     file.None.0x82339cd8.vacb\nfile.684.0x8217b720.vacb    file.684.0x82256c50.dat     file.None.0x82339c70.dat\nThe dumped filename is in the format of:\n\nfile.[PID].[OFFSET].ext\n\n\nThe OFFSET is the offset of the SharedCacheMap or the CONTROL_AREA, not the _FILEOBJECT.\nThe extension (EXT) can be:\n\nimg \u2013 ImageSectionObject\ndat - DataSectionObject\nvacb \u2013 SharedCacheMap\n\nYou can look at the -S/--summary-file in order to map the file back to its original filename:\n{\"name\": \"\\Device\\HarddiskVolume1\\WINDOWS\\system32\\config\\AppEvent.Evt\", \"ofpath\": \"dumpfiles/file.684.0x82256e48.dat\", \"pid\": 684,...\nYou can also use the parsesummary.py script to parse out the json output of the summary file. The following shows an example of using this script. In addition to the original file name, PID of the process that had the file open and size, you can see which pages were present and which pages were missing and padded with zeros in the parsed summary output:\n\n$ python vol.py -f grrcon.img dumpfiles --summary=grrcon_summary.json -D output/\nVolatility Foundation Volatility Framework 2.4\n\n$ python parsesummary.py grrcon_summary.json |less\n[snip]\nFile: \\Device\\HarddiskVolume1\\Documents and Settings\\administrator\\NTUSER.DAT -> output/file.4.0x82245008.vacb\n        PID: 4\n        _FILE_OBJECT offset: 0x821cd9e8\n        Type: SharedCacheMap\n        Size: 262144\n        Present Pages:\n                Offset(V): 0xde5c0000, Length: 4096\n                Offset(V): 0xde5c1000, Length: 4096\n                Offset(V): 0xde5c2000, Length: 4096\n                Offset(V): 0xde5c3000, Length: 4096\n[snip]\n        Padding:\n                FileOffset: 0xde62e000 x 0x1000\n                FileOffset: 0xde62f000 x 0x1000\n                FileOffset: 0xde630000 x 0x1000\n                FileOffset: 0xde631000 x 0x1000\n                FileOffset: 0xde632000 x 0x1000\n[snip]\n\n\nOr you can use the -n/--name option in order to dump file the files with the original filename.\nNot every file will be currently active or in the VAD, and such files will not be dumped when using the -r/--regex option. For these files you can first scan for a _FILE_OBJECT and then use the -Q/--physoffset flag to extract the file. Special NTFS files are examples of files that must be dumped specifically:\n\n$ python vol.py -f mebromi.raw filescan |grep -i mft\nVolatility Foundation Volatility Framework 2.4\n0x02410900      3      0 RWD--- \\Device\\HarddiskVolume1\\$Mft\n0x02539e30      3      0 RWD--- \\Device\\HarddiskVolume1\\$Mft\n0x025ac868      3      0 RWD--- \\Device\\HarddiskVolume1\\$MftMirr\n\n$ python vol.py -f mebromi.raw dumpfiles -D output/ -Q 0x02539e30\nVolatility Foundation Volatility Framework 2.4\nDataSectionObject 0x02539e30   None   \\Device\\HarddiskVolume1\\$Mft\nSharedCacheMap 0x02539e30   None   \\Device\\HarddiskVolume1\\$Mft\n\n\nThe -f/--filter option allows you to specify which view of the file you would like to dump (DataSectionObject, ImageSectionObject or SharedCacheMap). For example, if you wanted to only see the state information for an executable file, you could specify --filter=ImageSectionObject.\n\n\nunloadedmodules\nWindows stores information on recently unloaded drivers for debugging purposes. This gives you an alternative way to determine what happened on a system, besides the well known modules and modscan plugins.\n$ python vol.py -f win7_trial_64bit.raw unloadedmodules --profile=Win7SP0x64\nVolatility Foundation Volatility Framework 2.4\nName                 StartAddress       EndAddress         Time\n\ndump_dumpfve.sys     0xfffff88001931000 0xfffff88001944000 2012-02-22 19:58:21\ndump_atapi.sys       0xfffff88001928000 0xfffff88001931000 2012-02-22 19:58:21\ndump_ataport.sys     0xfffff8800191c000 0xfffff88001928000 2012-02-22 19:58:21\ncrashdmp.sys         0xfffff8800190e000 0xfffff8800191c000 2012-02-22 19:58:21\nNetworking\nconnections\nTo view TCP connections that were active at the time of the memory acquisition, use the connections command. This walks the singly-linked list of connection structures pointed to by a non-exported symbol in the tcpip.sys module.\nThis command is for x86 and x64 Windows XP and Windows 2003 Server only.\n$ python vol.py -f Win2003SP2x64.vmem --profile=Win2003SP2x64 connections\nVolatile Systems Volatility Framework 2.1_alpha\nOffset(V)          Local Address             Remote Address               Pid\n\n0xfffffadfe6f2e2f0 172.16.237.150:1408       72.246.25.25:80             2136\n0xfffffadfe72e8080 172.16.237.150:1369       64.4.11.30:80               2136\n0xfffffadfe622d010 172.16.237.150:1403       74.125.229.188:80           2136\n0xfffffadfe62e09e0 172.16.237.150:1352       64.4.11.20:80               2136\n0xfffffadfe6f2e630 172.16.237.150:1389       209.191.122.70:80           2136\n0xfffffadfe5e7a610 172.16.237.150:1419       74.125.229.187:80           2136\n0xfffffadfe7321bc0 172.16.237.150:1418       74.125.229.188:80           2136\n0xfffffadfe5ea3c90 172.16.237.150:1393       216.115.98.241:80           2136\n0xfffffadfe72a3a80 172.16.237.150:1391       209.191.122.70:80           2136\n0xfffffadfe5ed8560 172.16.237.150:1402       74.125.229.188:80           2136\nOutput includes the virtual offset of the _TCPT_OBJECT by default. The physical offset can be obtained with the -P switch.\nconnscan\nTo find _TCPT_OBJECT structures using pool tag scanning, use the connscan command. This can find artifacts from previous connections that have since been terminated, in addition to the active ones. In the output below, you'll notice some fields have been partially overwritten, but some of the information is still accurate. For example, the very last entry's Pid field is 0, but all other fields are still in tact. Thus, while it may find false positives sometimes, you also get the benefit of detecting as much information as possible.\nThis command is for x86 and x64 Windows XP and Windows 2003 Server only.\n$ python vol.py -f Win2K3SP0x64.vmem --profile=Win2003SP2x64 connscan\nVolatility Foundation Volatility Framework 2.4\nOffset(P)  Local Address             Remote Address            Pid\n\n0x0ea7a610 172.16.237.150:1419       74.125.229.187:80           2136\n0x0eaa3c90 172.16.237.150:1393       216.115.98.241:80           2136\n0x0eaa4480 172.16.237.150:1398       216.115.98.241:80           2136\n0x0ead8560 172.16.237.150:1402       74.125.229.188:80           2136\n0x0ee2d010 172.16.237.150:1403       74.125.229.188:80           2136\n0x0eee09e0 172.16.237.150:1352       64.4.11.20:80               2136\n0x0f9f83c0 172.16.237.150:1425       98.139.240.23:80            2136\n0x0f9fe010 172.16.237.150:1394       216.115.98.241:80           2136\n0x0fb2e2f0 172.16.237.150:1408       72.246.25.25:80             2136\n0x0fb2e630 172.16.237.150:1389       209.191.122.70:80           2136\n0x0fb72730 172.16.237.150:1424       98.139.240.23:80            2136\n0x0fea3a80 172.16.237.150:1391       209.191.122.70:80           2136\n0x0fee8080 172.16.237.150:1369       64.4.11.30:80               2136\n0x0ff21bc0 172.16.237.150:1418       74.125.229.188:80           2136\n0x1019ec90 172.16.237.150:1397       216.115.98.241:80           2136\n0x179099e0 172.16.237.150:1115       66.150.117.33:80            2856\n0x2cdb1bf0 172.16.237.150:139        172.16.237.1:63369             4\n0x339c2c00 172.16.237.150:1138       23.45.66.43:80              1332\n0x39b10010 172.16.237.150:1148       172.16.237.138:139             0\nsockets\nTo detect listening sockets for any protocol (TCP, UDP, RAW, etc), use the sockets command. This walks a singly-linked list of socket structures which is pointed to by a non-exported symbol in the tcpip.sys module.\nThis command is for x86 and x64 Windows XP and Windows 2003 Server only.\n$ python vol.py -f Win2K3SP0x64.vmem --profile=Win2003SP2x64 sockets\nVolatility Foundation Volatility Framework 2.4\nOffset(V)             PID   Port  Proto Protocol        Address         Create Time\n\n0xfffffadfe71bbda0    432   1025      6 TCP             0.0.0.0         2012-01-23 18:20:01\n0xfffffadfe7350490    776   1028     17 UDP             0.0.0.0         2012-01-23 18:21:44\n0xfffffadfe6281120    804    123     17 UDP             127.0.0.1       2012-06-25 12:40:55\n0xfffffadfe7549010    432    500     17 UDP             0.0.0.0         2012-01-23 18:20:09\n0xfffffadfe5ee8400      4      0     47 GRE             0.0.0.0         2012-02-24 18:09:07\n0xfffffadfe606dc90      4    445      6 TCP             0.0.0.0         2012-01-23 18:19:38\n0xfffffadfe6eef770      4    445     17 UDP             0.0.0.0         2012-01-23 18:19:38\n0xfffffadfe7055210   2136   1321     17 UDP             127.0.0.1       2012-05-09 02:09:59\n0xfffffadfe750c010      4    139      6 TCP             172.16.237.150  2012-06-25 12:40:55\n0xfffffadfe745f610      4    138     17 UDP             172.16.237.150  2012-06-25 12:40:55\n0xfffffadfe6096560      4    137     17 UDP             172.16.237.150  2012-06-25 12:40:55\n0xfffffadfe7236da0    720    135      6 TCP             0.0.0.0         2012-01-23 18:19:51\n0xfffffadfe755c5b0   2136   1419      6 TCP             0.0.0.0         2012-06-25 12:42:37\n0xfffffadfe6f36510   2136   1418      6 TCP             0.0.0.0         2012-06-25 12:42:37\n[snip]\nOutput includes the virtual offset of the _ADDRESS_OBJECT by default. The physical offset can be obtained with the -P switch.\nsockscan\nTo find _ADDRESS_OBJECT structures using pool tag scanning, use the sockscan command. As with connscan, this can pick up residual data and artifacts from previous sockets.\nThis command is for x86 and x64 Windows XP and Windows 2003 Server only.\n$ python vol.py -f Win2K3SP0x64.vmem --profile=Win2003SP2x64 sockscan\nVolatility Foundation Volatility Framework 2.4\nOffset(P)             PID   Port  Proto Protocol        Address         Create Time\n\n0x0000000000608010    804    123     17 UDP             172.16.237.150  2012-05-08 22:17:44\n0x000000000eae8400      4      0     47 GRE             0.0.0.0         2012-02-24 18:09:07\n0x000000000eaf1240   2136   1403      6 TCP             0.0.0.0         2012-06-25 12:42:37\n0x000000000ec6dc90      4    445      6 TCP             0.0.0.0         2012-01-23 18:19:38\n0x000000000ec96560      4    137     17 UDP             172.16.237.150  2012-06-25 12:40:55\n0x000000000ecf7d20   2136   1408      6 TCP             0.0.0.0         2012-06-25 12:42:37\n0x000000000ed5a010   2136   1352      6 TCP             0.0.0.0         2012-06-25 12:42:18\n0x000000000ed84ca0    804    123     17 UDP             172.16.237.150  2012-06-25 12:40:55\n0x000000000ee2d380   2136   1393      6 TCP             0.0.0.0         2012-06-25 12:42:37\n0x000000000ee81120    804    123     17 UDP             127.0.0.1       2012-06-25 12:40:55\n0x000000000eeda8c0    776   1363     17 UDP             0.0.0.0         2012-06-25 12:42:20\n0x000000000f0be1a0   2136   1402      6 TCP             0.0.0.0         2012-06-25 12:42:37\n0x000000000f0d0890      4   1133      6 TCP             0.0.0.0         2012-02-24 18:09:07\n[snip]\nnetscan\nTo scan for network artifacts in 32- and 64-bit Windows Vista, Windows 2008 Server and Windows 7 memory dumps, use the netscan command. This finds TCP endpoints, TCP listeners, UDP endpoints, and UDP listeners. It distinguishes between IPv4 and IPv6, prints the local and remote IP (if applicable), the local and remote port (if applicable), the time when the socket was bound or when the connection was established, and the current state (for TCP connections only). For more information, see http://mnin.blogspot.com/2011/03/volatilitys-new-netscan-module.html Volatility's New Netscan Module.\nPlease note the following:\nThe netscan command uses pool tag scanning\nThere are at least 2 alternate ways to enumerate connections and sockets on Vista+ operating systems. One of them is using partitions and dynamic hash tables, which is how the netstat.exe utility on Windows systems works. The other involves bitmaps and port pools.\n$ python vol.py -f ~/Desktop/win7_trial_64bit.raw --profile=Win7SP0x64 netscan\nVolatility Foundation Volatility Framework 2.4\nOffset(P)  Proto    Local Address                  Foreign Address      State            Pid      Owner          Created\n0xf882a30  TCPv4    0.0.0.0:135                    0.0.0.0:0            LISTENING        628      svchost.exe\n0xfc13770  TCPv4    0.0.0.0:49154                  0.0.0.0:0            LISTENING        916      svchost.exe\n0xfdda1e0  TCPv4    0.0.0.0:49154                  0.0.0.0:0            LISTENING        916      svchost.exe\n0xfdda1e0  TCPv6    :::49154                       :::0                 LISTENING        916      svchost.exe\n0x1121b7b0 TCPv4    0.0.0.0:135                    0.0.0.0:0            LISTENING        628      svchost.exe\n0x1121b7b0 TCPv6    :::135                         :::0                 LISTENING        628      svchost.exe\n0x11431360 TCPv4    0.0.0.0:49152                  0.0.0.0:0            LISTENING        332      wininit.exe\n0x11431360 TCPv6    :::49152                       :::0                 LISTENING        332      wininit.exe\n[snip]\n0x17de8980 TCPv6    :::49153                       :::0                 LISTENING        444      lsass.exe\n0x17f35240 TCPv4    0.0.0.0:49155                  0.0.0.0:0            LISTENING        880      svchost.exe\n0x17f362b0 TCPv4    0.0.0.0:49155                  0.0.0.0:0            LISTENING        880      svchost.exe\n0x17f362b0 TCPv6    :::49155                       :::0                 LISTENING        880      svchost.exe\n0xfd96570  TCPv4    -:0                            232.9.125.0:0        CLOSED           1        ?C?\n0x17236010 TCPv4    -:49227                        184.26.31.55:80      CLOSED           2820     iexplore.exe\n0x1725d010 TCPv4    -:49359                        93.184.220.20:80     CLOSED           2820     iexplore.exe\n0x17270530 TCPv4    10.0.2.15:49363                173.194.35.38:80     ESTABLISHED      2820     iexplore.exe\n0x17285010 TCPv4    -:49341                        82.165.218.111:80    CLOSED           2820     iexplore.exe\n0x17288a90 TCPv4    10.0.2.15:49254                74.125.31.157:80     CLOSE_WAIT       2820     iexplore.exe\n0x1728f6b0 TCPv4    10.0.2.15:49171                204.245.34.130:80    ESTABLISHED      2820     iexplore.exe\n0x17291ba0 TCPv4    10.0.2.15:49347                173.194.35.36:80     CLOSE_WAIT       2820     iexplore.exe\n[snip]\n0x17854010 TCPv4    -:49168                        157.55.15.32:80      CLOSED           2820     iexplore.exe\n0x178a2a20 TCPv4    -:0                            88.183.123.0:0       CLOSED           504      svchost.exe\n0x178f5b00 TCPv4    10.0.2.15:49362                173.194.35.38:80     CLOSE_WAIT       2820     iexplore.exe\n0x17922910 TCPv4    -:49262                        184.26.31.55:80      CLOSED           2820     iexplore.exe\n0x17a9d860 TCPv4    10.0.2.15:49221                204.245.34.130:80    ESTABLISHED      2820     iexplore.exe\n0x17ac84d0 TCPv4    10.0.2.15:49241                74.125.31.157:80     CLOSE_WAIT       2820     iexplore.exe\n0x17b9acf0 TCPv4    10.0.2.15:49319                74.125.127.148:80    CLOSE_WAIT       2820     iexplore.exe\n0x10f38d70 UDPv4    10.0.2.15:1900                 :                                   1736     svchost.exe    2012-02-22 20:04:12\n0x173b3dc0 UDPv4    0.0.0.0:59362                  :                                   1736     svchost.exe    2012-02-22 20:02:27\n0x173b3dc0 UDPv6    :::59362                       :                                   1736     svchost.exe    2012-02-22 20:02:27\n0x173b4cf0 UDPv4    0.0.0.0:3702                   :                                   1736     svchost.exe    2012-02-22 20:02:27\n0x173b4cf0 UDPv6    :::3702                        :                                   1736     svchost.exe    2012-02-22 20:02:27\n[snip]\nRegistry\nVolatility is the only memory forensics framework with the ability to carve registry data. For more information, see BDG's Memory Registry Tools and Registry Code Updates.\nhivescan\nTo find the physical addresses of CMHIVEs (registry hives) in memory, use the hivescan command. For more information, see BDG's Enumerating Registry Hives.\nThis plugin isn't generally useful by itself. Its meant to be inherited by other plugins (such as hivelist below) that build on and interpret the information found in CMHIVEs.\n$python vol.py -f ~/Desktop/win7_trial_64bit.raw --profile=Win7SP0x64 hivescan\nVolatility Foundation Volatility Framework 2.4\n\nOffset(P)\n0x0000000008c95010\n0x000000000aa1a010\n0x000000000acf9010\n0x000000000b1a9010\n0x000000000c2b4010\n0x000000000cd20010\n0x000000000da51010\n[snip]\nhivelist\nTo locate the virtual addresses of registry hives in memory, and the full paths to the corresponding hive on disk, use the hivelist command. If you want to print values from a certain hive, run this command first so you can see the address of the hives.\n$ python vol.py -f ~/Desktop/win7_trial_64bit.raw --profile=Win7SP0x64 hivelist\nVolatility Foundation Volatility Framework 2.4\nVirtual            Physical           Name\n\n0xfffff8a001053010 0x000000000b1a9010 \\??\\C:\\System Volume Information\\Syscache.hve\n0xfffff8a0016a7420 0x0000000012329420 \\REGISTRY\\MACHINE\\SAM\n0xfffff8a0017462a0 0x00000000101822a0 \\??\\C:\\Windows\\ServiceProfiles\\NetworkService\\NTUSER.DAT\n0xfffff8a001abe420 0x000000000eae0420 \\??\\C:\\Windows\\ServiceProfiles\\LocalService\\NTUSER.DAT\n0xfffff8a002ccf010 0x0000000014659010 \\??\\C:\\Users\\testing\\AppData\\Local\\Microsoft\\Windows\\UsrClass.dat\n0xfffff80002b53b10 0x000000000a441b10 [no name]\n0xfffff8a00000d010 0x000000000ddc6010 [no name]\n0xfffff8a000022010 0x000000000da51010 \\REGISTRY\\MACHINE\\SYSTEM\n0xfffff8a00005c010 0x000000000dacd010 \\REGISTRY\\MACHINE\\HARDWARE\n0xfffff8a00021d010 0x000000000cd20010 \\SystemRoot\\System32\\Config\\SECURITY\n0xfffff8a0009f1010 0x000000000aa1a010 \\Device\\HarddiskVolume1\\Boot\\BCD\n0xfffff8a000a15010 0x000000000acf9010 \\SystemRoot\\System32\\Config\\SOFTWARE\n0xfffff8a000ce5010 0x0000000008c95010 \\SystemRoot\\System32\\Config\\DEFAULT\n0xfffff8a000f95010 0x000000000c2b4010 \\??\\C:\\Users\\testing\\ntuser.dat\nprintkey\nTo display the subkeys, values, data, and data types contained within a specified registry key, use the printkey command. By default, printkey will search all hives and print the key information (if found) for the requested key. Therefore, if the key is located in more than one hive, the information for the key will be printed for each hive that contains it.\nSay you want to traverse into the HKEY_LOCAL_MACHINE\\Microsoft\\Security Center\\Svc key. You can do that in the following manner. Note: if you're running Volatility on Windows, enclose the key in double quotes (see issue 166).\n$ python vol.py -f ~/Desktop/win7_trial_64bit.raw --profile=Win7SP0x64 printkey -K \"Microsoft\\Security Center\\Svc\"\nVolatility Foundation Volatility Framework 2.4\nLegend: (S) = Stable   (V) = Volatile\n\nRegistry: \\SystemRoot\\System32\\Config\\SOFTWARE\nKey name: Svc (S)\nLast updated: 2012-02-22 20:04:44\nSubkeys:\n  (V) Vol\nValues:\nREG_QWORD     VistaSp1        : (S) 128920218544262440\nREG_DWORD     AntiSpywareOverride : (S) 0\nREG_DWORD     ConfigMask      : (S) 4361\nHere you can see how the output appears when multiple hives (DEFAULT and ntuser.dat) contain the same key \"Software\\Microsoft\\Windows NT\\CurrentVersion\".\n$ python vol.py -f ~/Desktop/win7_trial_64bit.raw --profile=Win7SP0x64 printkey -K \"Software\\Microsoft\\Windows NT\\CurrentVersion\"\nVolatility Foundation Volatility Framework 2.4\nLegend: (S) = Stable   (V) = Volatile\n\nRegistry: \\SystemRoot\\System32\\Config\\DEFAULT\nKey name: CurrentVersion (S)\nLast updated: 2009-07-14 04:53:31\nSubkeys:\n  (S) Devices\n  (S) PrinterPorts\n\nValues:\nRegistry: \\??\\C:\\Users\\testing\\ntuser.dat\nKey name: CurrentVersion (S)\nLast updated: 2012-02-22 11:26:13\nSubkeys:\n  (S) Devices\n  (S) EFS\n  (S) MsiCorruptedFileRecovery\n  (S) Network\n  (S) PeerNet\n  (S) PrinterPorts\n  (S) Windows\n  (S) Winlogon\n[snip]\nIf you want to limit your search to a specific hive, printkey also accepts a virtual address to the hive. For example, to see the contents of HKEY_LOCAL_MACHINE, use the command below. Note: the offset is taken from the previous hivelist output.\n$ python vol.py -f ~/Desktop/win7_trial_64bit.raw --profile=Win7SP0x64 printkey -o 0xfffff8a000a15010\nVolatility Foundation Volatility Framework 2.4\nLegend: (S) = Stable   (V) = Volatile\n\nRegistry: User Specified\nKey name: CMI-CreateHive{199DAFC2-6F16-4946-BF90-5A3FC3A60902} (S)\nLast updated: 2009-07-14 07:13:38\nSubkeys:\n  (S) ATI Technologies\n  (S) Classes\n  (S) Clients\n  (S) Intel\n  (S) Microsoft\n  (S) ODBC\n  (S) Policies\n  (S) RegisteredApplications\n  (S) Sonic\n  (S) Wow6432Node\nhivedump\nTo recursively list all subkeys in a hive, use the hivedump command and pass it the virtual address to the desired hive.\n$ python vol.py -f ~/Desktop/win7_trial_64bit.raw --profile=Win7SP0x64 hivedump -o 0xfffff8a000a15010\nVolatility Foundation Volatility Framework 2.4\nLast Written         Key\n2009-07-14 07:13:38  \\CMI-CreateHive{199DAFC2-6F16-4946-BF90-5A3FC3A60902}\n2009-07-14 04:48:57  \\CMI-CreateHive{199DAFC2-6F16-4946-BF90-5A3FC3A60902}\\ATI Technologies\n2009-07-14 04:48:57  \\CMI-CreateHive{199DAFC2-6F16-4946-BF90-5A3FC3A60902}\\ATI Technologies\\Install\n2009-07-14 04:48:57  \\CMI-CreateHive{199DAFC2-6F16-4946-BF90-5A3FC3A60902}\\ATI Technologies\\Install\\South Bridge\n2009-07-14 04:48:57  \\CMI-CreateHive{199DAFC2-6F16-4946-BF90-5A3FC3A60902}\\ATI Technologies\\Install\\South Bridge\\ATI_AHCI_RAID\n2009-07-14 07:13:39  \\CMI-CreateHive{199DAFC2-6F16-4946-BF90-5A3FC3A60902}\\Classes\n2009-07-14 04:53:38  \\CMI-CreateHive{199DAFC2-6F16-4946-BF90-5A3FC3A60902}\\Classes*\n2009-07-14 04:53:38  \\CMI-CreateHive{199DAFC2-6F16-4946-BF90-5A3FC3A60902}\\Classes*\\OpenWithList\n2009-07-14 04:53:38  \\CMI-CreateHive{199DAFC2-6F16-4946-BF90-5A3FC3A60902}\\Classes*\\OpenWithList\\Excel.exe\n2009-07-14 04:53:38  \\CMI-CreateHive{199DAFC2-6F16-4946-BF90-5A3FC3A60902}\\Classes*\\OpenWithList\\IExplore.exe\n[snip]\nhashdump\nTo extract and decrypt cached domain credentials stored in the registry, use the hashdump command. For more information, see BDG's Cached Domain Credentials and SANS Forensics 2009 - Memory Forensics and Registry Analysis.\nTo use hashdump, pass the virtual address of the SYSTEM hive as -y and the virtual address of the SAM hive as -s, like this:\n$ python vol.py hashdump -f image.dd -y 0xe1035b60 -s 0xe165cb60\nAdministrator:500:08f3a52bdd35f179c81667e9d738c5d9:ed88cccbc08d1c18bcded317112555f4:::\nGuest:501:aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0:::\nHelpAssistant:1000:ddd4c9c883a8ecb2078f88d729ba2e67:e78d693bc40f92a534197dc1d3a6d34f:::\nSUPPORT_388945a0:1002:aad3b435b51404eeaad3b435b51404ee:8bfd47482583168a0ae5ab020e1186a9:::\nphoenix:1003:07b8418e83fad948aad3b435b51404ee:53905140b80b6d8cbe1ab5953f7c1c51:::\nASPNET:1004:2b5f618079400df84f9346ce3e830467:aef73a8bb65a0f01d9470fadc55a411c:::\nS----:1006:aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0:::\nHashes can now be cracked using John the Ripper, rainbow tables, etc.\nIt is possible that a registry key is not available in memory. When this happens, you may see the following error:\n\"ERROR : volatility.plugins.registry.lsadump: Unable to read hashes from registry\"\nYou can try to see if the correct keys are available: \"CurrentControlSet\\Control\\lsa\" from SYSTEM and \"SAM\\Domains\\Account\" from SAM. First you need to get the \"CurrentControlSet\", for this we can use volshell (replace REGISTRY ADDRESS below with the offset you get from hivelist), for example:\n$ python vol.py -f XPSP3.vmem --profile=WinXPSP3x86 volshell\nVolatility Foundation Volatility Framework 2.4\nCurrent context: process System, pid=4, ppid=0 DTB=0x319000\nWelcome to volshell Current memory image is:\nfile:///XPSP3.vmem\nTo get help, type 'hh()'\n\n\n\nimport volatility.win32.hashdump as h\nimport volatility.win32.hive as hive\naddr_space = utils.load_as(self._config)\nsysaddr = hive.HiveAddressSpace(addr_space, self._config, [SYSTEM REGISTRY ADDRESS])\nprint h.find_control_set(sysaddr)\n1\n^D\nThen you can use the printkey plugin to make sure the keys and their data are there. Since the \"CurrentControlSet\" is 1 in our previous example, we use \"ControlSet001\" in the first command:\n\n\n\n$ python vol.py -f XPSP3.vmem --profile=WinXPSP3x86 printkey -K \"ControlSet001\\Control\\lsa\"\n$ python vol.py -f XPSP3.vmem --profile=WinXPSP3x86 printkey -K \"SAM\\Domains\\Account\"\nIf the key is missing you should see an error message:\n\"The requested key could not be found in the hive(s) searched\"\nlsadump\nTo dump LSA secrets from the registry, use the lsadump command. This exposes information such as the default password (for systems with autologin enabled), the RDP public key, and credentials used by DPAPI.\nFor more information, see BDG's Decrypting LSA Secrets.\nTo use lsadump, pass the virtual address of the SYSTEM hive as the -y parameter and the virtual address of the SECURITY hive as the -s parameter.\npythonvol.py\u2212flaqma.vmemlsadump\u2212y0xe1035b60\u2212s0xe16a6b60VolatilityFoundationVolatilityFramework2.4L python vol.py -f laqma.vmem lsadump -y 0xe1035b60 -s 0xe16a6b60 \nVolatility Foundation Volatility Framework 2.4 \nLRTMTIMEBOMB_1320153D-8DA3-4e8e-B27B-0D888223A588\n0000   00 92 8D 60 01 FF C8 01                            ...`....\n_SC_Dnscache\nL$HYDRAENCKEY_28ada6da-d622-11d1-9cb9-00c04fb16e75\n0000   52 53 41 32 48 00 00 00 00 02 00 00 3F 00 00 00    RSA2H.......?...\n0010   01 00 01 00 37 CE 0C C0 EF EC 13 C8 A4 C5 BC B8    ....7...........\n0020   AA F5 1A 7C 50 95 A4 E9 3B BA 41 C8 53 D7 CE C6    ...|P...;.A.S...\n0030   CB A0 6A 46 7C 70 F3 21 17 1C FB 79 5C C1 83 68    ..jF|p....y...h\n0040   91 E5 62 5E 2C AC 21 1E 79 07 A9 21 BB F0 74 E8    ..b^,..y....t.\n0050   85 66 F4 C4 00 00 00 00 00 00 00 00 F9 D7 AD 5C    .f..............\n0060   B4 7C FB F6 88 89 9D 2E 91 F2 60 07 10 42 CA 5A    .|........`..B.Z\n0070   FC F0 D1 00 0F 86 29 B5 2E 1E 8C E0 00 00 00 00    ......).........\n0080   AF 43 30 5F 0D 0E 55 04 57 F9 0D 70 4A C8 36 01    .C0_..U.W..pJ.6.\n0090   C2 63 45 59 27 62 B5 77 59 84 B7 65 8E DB 8A E0    .cEY'b.wY..e....\n00A0   00 00 00 00 89 19 5E D8 CB 0E 03 39 E2 52 04 37    ......^....9.R.7\n00B0   20 DC 03 C8 47 B5 2A B3 9C 01 65 15 FF 0F FF 8F     ...G....e.....\n00C0   17 9F C1 47 00 00 00 00 1B AC BF 62 4E 81 D6 2A    ...G.......bN..\n00D0   32 98 36 3A 11 88 2D 99 3A EA 59 DE 4D 45 2B 9E    2.6:..-.:.Y.ME+.\n00E0   74 15 14 E1 F2 B5 B2 80 00 00 00 00 75 BD A0 36    t...........u..6\n00F0   20 AD 29 0E 88 E0 FD 5B AD 67 CA 88 FC 85 B9 82     .)....[.g......\n0100   94 15 33 1A F1 65 45 D1 CA F9 D8 4C 00 00 00 00    ..3..eE....L....\n0110   71 F0 0B 11 F2 F1 AA C5 0C 22 44 06 E1 38 6C ED    q........\"D..8l.\n0120   6E 38 51 18 E8 44 5F AD C2 CE 0A 0A 1E 8C 68 4F    n8Q..D_.......hO\n0130   4D 91 69 07 DE AA 1A EC E6 36 2A 9C 9C B6 49 1F    M.i......6*...I.\n0140   B3 DD 89 18 52 7C F8 96 4F AF 05 29 DF 17 D8 48    ....R|..O..)...H\n0150   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................\n0160   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................\n0170   00 00 00 00 00 00 00 00 00 00 00 00                ............\nDPAPI_SYSTEM\n0000   01 00 00 00 24 04 D6 B0 DA D1 3C 40 BB EE EC 89    ....$.....<@....\n0010   B4 BB 90 5B 9A BF 60 7D 3E 96 72 CD 9A F6 F8 BE    ...[..`}>.r.....\n0020   D3 91 5C FA A5 8B E6 B4 81 0D B6 D4                ............\nuserassist\nTo get the UserAssist keys from a sample you can use the userassist plugin. For more information see Gleeda's Volatility UserAssist plugin post.\n$ python vol.py -f win7.vmem --profile=Win7SP0x86 userassist\n\nVolatility Foundation Volatility Framework 2.4\nRegistry: \\??\\C:\\Users\\admin\\ntuser.dat\nKey name: Count\nLast updated: 2010-07-06 22:40:25\nSubkeys:\nValues:\nREG_BINARY    Microsoft.Windows.GettingStarted :\nCount:          14\nFocus Count:    21\nTime Focused:   0:07:00.500000\nLast updated:   2010-03-09 19:49:20\n0000   00 00 00 00 0E 00 00 00 15 00 00 00 A0 68 06 00    .............h..\n0010   00 00 80 BF 00 00 80 BF 00 00 80 BF 00 00 80 BF    ................\n0020   00 00 80 BF 00 00 80 BF 00 00 80 BF 00 00 80 BF    ................\n0030   00 00 80 BF 00 00 80 BF FF FF FF FF EC FE 7B 9C    ..............{.\n0040   C1 BF CA 01 00 00 00 00                            ........\nREG_BINARY    UEME_CTLSESSION :\nCount:          187\nFocus Count:    1205\nTime Focused:   6:25:06.216000\nLast updated:   1970-01-01 00:00:00\n[snip]\nREG_BINARY    %windir%\\system32\\calc.exe :\nCount:          12\nFocus Count:    17\nTime Focused:   0:05:40.500000\nLast updated:   2010-03-09 19:49:20\n0000   00 00 00 00 0C 00 00 00 11 00 00 00 20 30 05 00    ............ 0..\n0010   00 00 80 BF 00 00 80 BF 00 00 80 BF 00 00 80 BF    ................\n0020   00 00 80 BF 00 00 80 BF 00 00 80 BF 00 00 80 BF    ................\n0030   00 00 80 BF 00 00 80 BF FF FF FF FF EC FE 7B 9C    ..............{.\n0040   C1 BF CA 01 00 00 00 00                            ........\n                          ........\nREG_BINARY    Z:\\vmware-share\\apps\\odbg110\\OLLYDBG.EXE :\nCount:          11\nFocus Count:    266\nTime Focused:   1:19:58.045000\nLast updated:   2010-03-18 01:56:31\n0000   00 00 00 00 0B 00 00 00 0A 01 00 00 69 34 49 00    ............i4I.\n0010   00 00 80 BF 00 00 80 BF 00 00 80 BF 00 00 80 BF    ................\n0020   00 00 80 BF 00 00 80 BF 00 00 80 BF 00 00 80 BF    ................\n0030   00 00 80 BF 00 00 80 BF FF FF FF FF 70 3B CB 3A    ............p;.:\n0040   3E C6 CA 01 00 00 00 00                            >.......\n[snip]\nshellbags\nThis plugin parses and prints Shellbag (pdf) information obtained from the registry. For more information see Shellbags in Memory, SetRegTime, and TrueCrypt Volumes. There are two options for output: verbose (default) and bodyfile format.\n$ python vol.py -f win7.vmem --profile=Win7SP1x86 shellbags\nVolatility Foundation Volatility Framework 2.4\nScanning for registries....\nGathering shellbag items and building path tree...\n\nRegistry: \\??\\C:\\Users\\user\\ntuser.dat\nKey: Software\\Microsoft\\Windows\\Shell\\Bags\\1\\Desktop\nLast updated: 2011-10-20 15:24:46\nValue                     File Name      Modified Date        Create Date          Access Date          File Attr                 Unicode Name\n\nItemPos1176x882x96(1)     ADOBER~1.LNK   2011-10-20 15:20:04  2011-10-20 15:20:04  2011-10-20 15:20:04  ARC                       Adobe Reader X.lnk\nItemPos1176x882x96(1)     ENCASE~1.LNK   2011-05-15 23:02:26  2011-05-15 23:02:26  2011-05-15 23:02:26  ARC                       EnCase v6.18.lnk\nItemPos1176x882x96(1)     VMWARE~1.LNK   2011-10-20 15:13:06  2011-05-15 23:09:08  2011-10-20 15:13:06  ARC                       VMware Shared Folders.lnk\nItemPos1176x882x96(1)     EF_SET~1.EXE   2010-12-28 15:47:32  2011-05-15 23:01:10  2011-05-15 23:01:10  ARC, NI                   ef_setup_618_english.exe\nItemPos1366x768x96(1)     ADOBER~1.LNK   2011-10-20 15:20:04  2011-10-20 15:20:04  2011-10-20 15:20:04  ARC                       Adobe Reader X.lnk\nItemPos1366x768x96(1)     ENCASE~1.LNK   2011-05-15 23:02:26  2011-05-15 23:02:26  2011-05-15 23:02:26  ARC                       EnCase v6.18.lnk\nItemPos1366x768x96(1)     EF_SET~1.EXE   2010-12-28 15:47:32  2011-05-15 23:01:10  2011-05-15 23:01:10  ARC, NI                   ef_setup_618_english.exe\nItemPos1366x768x96(1)     VMWARE~1.LNK   2011-10-20 15:24:22  2011-05-15 23:09:08  2011-10-20 15:24:22  ARC                       VMware Shared Folders.lnk\nItemPos1640x834x96(1)     EF_SET~1.EXE   2010-12-28 15:47:32  2011-05-15 23:01:10  2011-05-15 23:01:10  ARC, NI                   ef_setup_618_english.exe\nItemPos1640x834x96(1)     ENCASE~1.LNK   2011-05-15 23:02:26  2011-05-15 23:02:26  2011-05-15 23:02:26  ARC                       EnCase v6.18.lnk\nItemPos1640x834x96(1)     VMWARE~1.LNK   2011-05-15 23:09:08  2011-05-15 23:09:08  2011-05-15 23:09:08  ARC                       VMware Shared Folders.lnk\n\n\nRegistry: \\??\\C:\\Users\\user\\AppData\\Local\\Microsoft\\Windows\\UsrClass.dat\nKey: Local Settings\\Software\\Microsoft\\Windows\\Shell\\BagMRU\nLast updated: 2011-10-20 15:14:21\nValue   Mru   Entry Type     GUID                                     GUID Description     Folder IDs\n\n1       2     Folder Entry   031e4825-7b94-4dc3-b131-e946b44c8dd5     Libraries            EXPLORER, LIBRARIES\n0       1     Folder Entry   20d04fe0-3aea-1069-a2d8-08002b30309d     My Computer          EXPLORER, MY_COMPUTER\n2       0     Folder Entry   59031a47-3f72-44a7-89c5-5595fe6b30ee     Users                EXPLORER, USERS\n\n\nRegistry: \\??\\C:\\Users\\user\\AppData\\Local\\Microsoft\\Windows\\UsrClass.dat\nKey: Local Settings\\Software\\Microsoft\\Windows\\Shell\\BagMRU\\0\nLast updated: 2011-05-15 23:10:01\nValue   Mru   Entry Type     Path\n\n1       0     Volume Name    Z:\\\n0       1     Volume Name    C:\\\n\n[snip]\n\nRegistry: \\??\\C:\\Users\\user\\AppData\\Local\\Microsoft\\Windows\\UsrClass.dat\nKey: Local Settings\\Software\\Microsoft\\Windows\\Shell\\BagMRU\\0\\0\\0\\0\nLast updated: 2011-05-15 23:03:22\nValue   Mru   File Name      Modified Date        Create Date          Access Date          File Attr                 Path\n\n0       0     AppData        2011-05-15 22:57:52  2011-05-15 22:57:52  2011-05-15 22:57:52  HID, NI, DIR              C:\\Users\\user\\AppData\n\n[snip]\nAnother option is to use the --output=body option for TSK 3.x bodyfile format. You can use this output option when you want to combine output from timeliner, mftparser and timeliner. You can also include a machine identifier in the bodyfile header with the --machine flag (this is useful when combining timelines from multiple machines). Only ITEMPOS and FILE_ENTRY items are output with the bodyfile format:\n$ python vol.py -f win7.vmem --profile=Win7SP1x86 shellbags --output=body\nVolatility Foundation Volatility Framework 2.4\nScanning for registries....\nGathering shellbag items and building path tree...\n0|[SHELLBAGS ITEMPOS] Name: Adobe Reader X.lnk/Attrs: ARC/FullPath: Adobe Reader X.lnk/Registry: \\??\\C:\\Users\\user\\ntuser.dat /Key: Software\\Microsoft\\Windows\\Shell\\Bags\\1\\Desktop/LW: 2011-10-20 15:24:46 UTC+0000|0|---------------|0|0|0|1319124004|1319124004|1319124004|1319124004\n0|[SHELLBAGS ITEMPOS] Name: EnCase v6.18.lnk/Attrs: ARC/FullPath: EnCase v6.18.lnk/Registry: \\??\\C:\\Users\\user\\ntuser.dat /Key: Software\\Microsoft\\Windows\\Shell\\Bags\\1\\Desktop/LW: 2011-10-20 15:24:46 UTC+0000|0|---------------|0|0|0|1305500546|1305500546|1305500546|1305500546\n0|[SHELLBAGS ITEMPOS] Name: VMware Shared Folders.lnk/Attrs: ARC/FullPath: VMware Shared Folders.lnk/Registry: \\??\\C:\\Users\\user\\ntuser.dat /Key: Software\\Microsoft\\Windows\\Shell\\Bags\\1\\Desktop/LW: 2011-10-20 15:24:46 UTC+0000|0|---------------|0|0|0|1319123586|1319123586|1305500948|1305500948\n[snip]\n0|[SHELLBAGS FILE_ENTRY] Name: Program Files/Attrs: RO, DIR/FullPath: C:\\Program Files/Registry: \\??\\C:\\Users\\user\\AppData\\Local\\Microsoft\\Windows\\UsrClass.dat /Key: Local Settings\\Software\\Microsoft\\Windows\\Shell\\BagMRU\\0\\0/LW: 2011-05-15 23:03:35 UTC+0000|0|---------------|0|0|0|1305500504|1305500504|1247539026|1247539026\n0|[SHELLBAGS FILE_ENTRY] Name: Users/Attrs: RO, DIR/FullPath: C:\\Users/Registry: \\??\\C:\\Users\\user\\AppData\\Local\\Microsoft\\Windows\\UsrClass.dat /Key: Local Settings\\Software\\Microsoft\\Windows\\Shell\\BagMRU\\0\\0/LW: 2011-05-15 23:03:35 UTC+0000|0|---------------|0|0|0|1305500270|1305500270|1247539026|1247539026\n[snip]\nshimcache\nThis plugin parses the Application Compatibility Shim Cache registry key.\n$ python vol.py -f win7.vmem --profile=Win7SP1x86 shimcache\nVolatility Foundation Volatility Framework 2.4\nLast Modified                  Path\n\n2009-07-14 01:14:22 UTC+0000   \\??\\C:\\Windows\\system32\\LogonUI.exe\n2009-07-14 01:14:18 UTC+0000   \\??\\C:\\Windows\\system32\\DllHost.exe\n2009-07-14 01:16:03 UTC+0000   \\??\\C:\\Windows\\System32\\networkexplorer.dll\n2009-07-14 01:14:31 UTC+0000   \\??\\C:\\WINDOWS\\SYSTEM32\\RUNDLL32.EXE\n2011-03-22 18:18:16 UTC+0000   \\??\\C:\\Program Files\\VMware\\VMware Tools\\TPAutoConnect.exe\n2009-07-14 01:14:25 UTC+0000   \\??\\C:\\Windows\\System32\\msdtc.exe\n2009-07-14 01:15:22 UTC+0000   \\??\\C:\\Windows\\System32\\gameux.dll\n2011-08-12 00:00:18 UTC+0000   \\??\\C:\\Program Files\\Common Files\\VMware\\Drivers\\vss\\comreg.exe\n2010-08-02 20:42:26 UTC+0000   \\??\\C:\\Program Files\\VMware\\VMware Tools\\TPAutoConnSvc.exe\n2009-07-14 01:14:27 UTC+0000   \\??\\C:\\Windows\\system32\\net1.exe\n2009-07-14 01:14:27 UTC+0000   \\??\\C:\\Windows\\System32\\net.exe\n2011-08-12 00:06:50 UTC+0000   \\??\\C:\\Program Files\\VMware\\VMware Tools\\vmtoolsd.exe\n2009-07-14 01:14:45 UTC+0000   \\??\\C:\\Windows\\system32\\WFS.exe\n[snip]\ngetservicesids\nThe getservicesids command calculates the SIDs for services on a machine and outputs them in Python dictionary format for future use. The service names are taken from the registry (\"SYSTEM\\CurrentControlSet\\Services\"). For more information on how these SIDs are calculated, see Timeliner Release Documentation (pdf). Example output can be seen below:\n$ python vol.py -f WinXPSP1x64.vmem --profile=WinXPSP2x64 getservicesids\nVolatility Foundation Volatility Framework 2.4\nservicesids = {\n    'S-1-5-80-2675092186-3691566608-1139246469-1504068187-1286574349':\n'Abiosdsk',\n    'S-1-5-80-850610371-2162948594-2204246734-1395993891-583065928': 'ACPIEC',\n    'S-1-5-80-2838020983-819055183-730598559-323496739-448665943': 'adpu160m',\n    'S-1-5-80-3218321610-3296847771-3570773115-868698368-3117473630': 'aec',\n    'S-1-5-80-1344778701-2960353790-662938617-678076498-4183748354': 'aic78u2',\n    'S-1-5-80-1076555770-1261388817-3553637611-899283093-3303637635': 'Alerter',\n    'S-1-5-80-1587539839-2488332913-1287008632-3751426284-4220573165': 'AliIde',\n    'S-1-5-80-4100430975-1934021090-490597466-3817433801-2954987127': 'AmdIde',\n    'S-1-5-80-258649362-1997344556-1754272750-1450123204-3407402222': 'Atdisk',\n[snip]\nIn order to save output to a file, use the --output-file option.\ndumpregistry\nThe dumpregistry plugin allows you to dump a registry hive to disk. It works on all supported Windows versions (Windows XP-8.1). By default the plugin will dump all registry files (including virtual registries like HARDWARE) found to disk, however you may specify the virtual offset for a specific hive in order to only dump one registry at a time. One caveat about using this plugin (or the dumpfiles plugin) is that there may be holes in the dumped registry file, so offline registry tools may crash if they are not made robustly to handle \"corrupt\" files. These holes are denoted in the text output with lines like Physical layer returned None for index 2000, filling with NULL. Example output is shown below:\n$ python vol.py -f voltest.dmp --profile=Win7SP1x86 dumpregistry -D output\n\nWriting out registry: registry.0x888101e0.no_name.reg\n\n\nWriting out registry: registry.0x8cec09d0.ntuserdat.reg\nPhysical layer returned None for index 9000, filling with NULL\nPhysical layer returned None for index a000, filling with NULL\nPhysical layer returned None for index b000, filling with NULL\n[snip]\n\nWriting out registry: registry.0x8883c7d0.HARDWARE.reg\nPhysical layer returned None for index 2000, filling with NULL\nPhysical layer returned None for index 3000, filling with NULL\nPhysical layer returned None for index 4000, filling with NULL\n[snip]\n\nWriting out registry: registry.0x88c9c008.SAM.reg\n\n\nWriting out registry: registry.0x8a5449d0.NTUSERDAT.reg\n\n[snip]\n$ file output/*\noutput/registry.0x888101e0.no_name.reg:     MS Windows registry file, NT/2000 or above\noutput/registry.0x8881c008.SYSTEM.reg:      MS Windows registry file, NT/2000 or above\noutput/registry.0x8883c7d0.HARDWARE.reg:    data\noutput/registry.0x888c14e8.DEFAULT.reg:     MS Windows registry file, NT/2000 or above\noutput/registry.0x88c3b898.SECURITY.reg:    MS Windows registry file, NT/2000 or above\noutput/registry.0x88c9c008.SAM.reg:         MS Windows registry file, NT/2000 or above\noutput/registry.0x8a4c2008.NTUSERDAT.reg:   MS Windows registry file, NT/2000 or above\noutput/registry.0x8a5449d0.NTUSERDAT.reg:   MS Windows registry file, NT/2000 or above\noutput/registry.0x8c7e7008.BCD.reg:         MS Windows registry file, NT/2000 or above\noutput/registry.0x8cec09d0.ntuserdat.reg:   MS Windows registry file, NT/2000 or above\noutput/registry.0x8d432008.SOFTWARE.reg:    MS Windows registry file, NT/2000 or above\noutput/registry.0x945229d0.UsrClassdat.reg: MS Windows registry file, NT/2000 or above\noutput/registry.0xa019c9d0.Syscachehve.reg: MS Windows registry file, NT/2000 or above\nNotice that the HARDWARE registry has \"Data\" as the type. This is because the first few cells of the registry are zeroed out. If you examine the registry with a hex editor, you will see valid keys and values:\n$ xxd output/registry.0x8883c7d0.HARDWARE.reg |grep -v \"0000 0000 0000 0000 0000 0000 0000 0000\" |less\n0001000: 6862 696e 0000 0000 0010 0000 0000 0000  hbin............\n0001020: a8ff ffff 6e6b 2c00 c1be 7203 3eba cf01  ....nk,...r.>...\n0001030: 0000 0000 d002 0000 0300 0000 0100 0000  ................\n0001040: 9018 0000 2801 0080 0000 0000 ffff ffff  ....(...........\n0001050: 7800 0000 ffff ffff 1600 0000 0000 0000  x...............\n0001060: 0000 0000 0000 0000 0000 0000 0800 0000  ................\n0001070: 4841 5244 5741 5245 58ff ffff 736b 0000  HARDWAREX...sk..\n0001080: 7800 0000 7800 0000 2800 0000 8c00 0000  x...x...(.......\n0001090: 0100 0480 7000 0000 8000 0000 0000 0000  ....p...........\n00010a0: 1400 0000 0200 5c00 0400 0000 0002 1400  ...............\n00010b0: 3f00 0f00 0101 0000 0000 0005 1200 0000  ?...............\n00010c0: 0002 1800 3f00 0f00 0102 0000 0000 0005  ....?...........\n00010d0: 2000 0000 2002 0000 0002 1400 1900 0200   ... ...........\n00010e0: 0101 0000 0000 0001 0000 0000 0002 1400  ................\n00010f0: 1900 0200 0101 0000 0000 0005 0c00 0000  ................\n0001100: 0102 0000 0000 0005 2000 0000 2002 0000  ........ ... ...\n0001110: 0101 0000 0000 0005 1200 0000 0000 0000  ................\n0001120: a0ff ffff 6e6b 2000 3eb5 f30a 3eba cf01  ....nk .>...>...\n0001130: 0000 0000 2000 0000 0500 0000 0100 0000  .... ...........\n0001140: 6828 0200 701f 0080 0000 0000 ffff ffff  h(..p...........\n0001150: 7800 0000 ffff ffff 1c00 0000 0000 0000  x...............\n0001160: 0000 0000 0000 0000 0000 0000 0900 0000  ................\n0001170: 4445 5649 4345 4d41 5000 0000 0000 0000  DEVICEMAP.......\n0001180: f0ff ffff 6c66 0100 0802 0000 5379 7374  ....lf......Syst\n0001190: a0ff ffff 6e6b 2000 00fc 6d03 3eba cf01  ....nk ...m.>...\n00011a0: 0000 0000 2000 0000 0100 0000 0000 0000  .... ...........\n00011b0: 8001 0000 ffff ffff 0000 0000 ffff ffff  ................\n00011c0: 7800 0000 ffff ffff 0c00 0000 0000 0000  x...............\n00011d0: 0000 0000 0000 0000 0000 0000 0b00 0000  ................\n00011e0: 4445 5343 5249 5054 494f 4e00 0000 0000  DESCRIPTION.....\n00011f0: f0ff ffff 6c66 0100 901b 0000 494e 5445  ....lf......INTE\n0001200: f8ff ffff 181a 0000 a8ff ffff 6e6b 2000  ............nk .\n0001210: b68f c70b 3eba cf01 0000 0000 9001 0000  ....>...........\n0001220: 0300 0000 0200 0000 f012 0000 a05a 0080  .............Z..\n0001230: 0800 0000 8017 0000 7800 0000 ffff ffff  ........x.......\n0001240: 2c00 0000 0000 0000 2a00 0000 6600 0000  ,.......*...f...\n0001250: 0000 0000 0600 0000 5379 7374 656d 0000  ........System..\n0001260: d0ff ffff 766b 1500 1000 0000 9002 0000  ....vk..........\n0001270: 0300 0000 0100 0000 436f 6d70 6f6e 656e  ........Componen\n0001280: 7420 496e 666f 726d 6174 696f 6e00 0000  t Information...\n[snip]\nYou may also dump only one registry at a time by using the virtual offset of the hive:\n$ python vol.py -f voltest.dmp --profile=Win7SP1x86 hivelist\nVolatility Foundation Volatility Framework 2.4\nVirtual    Physical   Name\n\n[snip]\n0x8cec09d0 0x0d1f19d0 \\??\\C:\\Users\\test\\ntuser.dat\n[snip]\n$ python vol.py -f voltest.dmp --profile=Win7SP1x86 dumpregistry -o 0x8cec09d0 -D output/\nVolatility Foundation Volatility Framework 2.4\n\nWriting out registry: registry.0x8cec09d0.ntuserdat.reg\nPhysical layer returned None for index 9000, filling with NULL\nPhysical layer returned None for index a000, filling with NULL\nPhysical layer returned None for index b000, filling with NULL\nPhysical layer returned None for index c000, filling with NULL\nPhysical layer returned None for index d000, filling with NULL\nPhysical layer returned None for index e000, filling with NULL\nPhysical layer returned None for index f000, filling with NULL\nPhysical layer returned None for index 10000, filling with NULL\nPhysical layer returned None for index 11000, filling with NULL\nPhysical layer returned None for index 20000, filling with NULL\nPhysical layer returned None for index 21000, filling with NULL\n$ file output/*\noutput/registry.0x8cec09d0.ntuserdat.reg: MS Windows registry file, NT/2000 or above\nCrash Dumps, Hibernation, and Conversion\nVolatility supports memory dumps in several different formats, to ensure the highest compatibility with different acquisition tools. You can analyze hibernation files, crash dumps, virtualbox core dumps, etc in the same way as any raw memory dump and Volatility will detect the underlying file format and apply the appropriate address space. You can also convert between file formats.\ncrashinfo\nInformation from the crashdump header can be printed using the crashinfo command. You will see information like that of the Microsoft dumpcheck utility.\n$ python vol.py -f win7_x64.dmp --profile=Win7SP0x64 crashinfo\nVolatility Foundation Volatility Framework 2.4\n_DMP_HEADER64:\n Majorversion:         0x0000000f (15)\n Minorversion:         0x00001db0 (7600)\n KdSecondaryVersion    0x00000000\n DirectoryTableBase    0x32a44000\n PfnDataBase           0xfffff80002aa8220\n PsLoadedModuleList    0xfffff80002a3de50\n PsActiveProcessHead   0xfffff80002a1fb30\n MachineImageType      0x00008664\n NumberProcessors      0x00000002\n BugCheckCode          0x00000000\n KdDebuggerDataBlock   0xfffff800029e9070\n ProductType           0x00000001\n SuiteMask             0x00000110\n WriterStatus          0x00000000\n Comment               PAGEPAGEPAGEPAGEPAGEPAGE[snip]\nPhysical Memory Description:\nNumber of runs: 3\nFileOffset    Start Address    Length\n00002000      00001000         0009e000\n000a0000      00100000         3fde0000\n3fe80000      3ff00000         00100000\n3ff7f000      3ffff000\nhibinfo\nThe hibinfo command reveals additional information stored in the hibernation file, including the state of the Control Registers, such as CR0, etc. It also identifies the time at which the hibernation file was created, the state of the hibernation file, and the version of windows being hibernated. Example output for the function is shown below.\n$ python vol.py -f hiberfil.sys --profile=Win7SP1x64 hibinfo\nIMAGE_HIBER_HEADER:\nSignature: HIBR\nSystemTime: 2011-12-23 16:34:27\nControl registers flags\nCR0: 80050031\nCR0[PAGING]: 1\nCR3: 00187000\nCR4: 000006f8\nCR4[PSE]: 1\nCR4[PAE]: 1\nWindows Version is 6.1 (7601)\nimagecopy\nThe imagecopy command allows you to convert any existing type of address space (such as a crashdump, hibernation file, virtualbox core dump, vmware snapshot, or live firewire session) to a raw memory image. This conversion be necessary if some of your other forensic tools only support reading raw memory dumps.\nThe profile should be specified for this command, so if you don't know it already, use the [or Command Reference#kdbgscan kdbgscan commands first. The output file is specified with the -O flag. The progress is updated as the file is converted:\n$ python vol.py -f win7_x64.dmp --profile=Win7SP0x64 imagecopy -O copy.raw\nVolatility Foundation Volatility Framework 2.4\nWriting data (5.00 MB chunks): |.......................................|\nraw2dmp\nTo convert a raw memory dump (for example from a win32dd acquisition or a VMware .vmem file) into a Microsoft crash dump, use the raw2dmp command. This is useful if you want to load the memory in the WinDbg kernel debugger for analysis.\n$ python vol.py -f ~/Desktop/win7_trial_64bit.raw --profile=Win7SP0x64 raw2dmp -O copy.dmp\nVolatility Foundation Volatility Framework 2.4\nWriting data (5.00 MB chunks): |..............................................................................|\nvboxinfo\nTo pull details from a virtualbox core dump, use the vboxinfo command.\n$ python vol.py -f ~/Desktop/win7sp1x64_vbox.elf --profile=Win7SP1x64 vboxinfo\nVolatility Foundation Volatility Framework 2.4\nMagic: 0xc01ac0de\nFormat: 0x10000\nVirtualBox 4.1.23 (revision 80870)\nCPUs: 1\nFile Offset        PhysMem Offset     Size\n\n0x0000000000000758 0x0000000000000000 0x00000000e0000000\n0x00000000e0000758 0x00000000e0000000 0x0000000003000000\n0x00000000e3000758 0x00000000f0400000 0x0000000000400000\n0x00000000e3400758 0x00000000f0800000 0x0000000000004000\n0x00000000e3404758 0x00000000ffff0000 0x0000000000010000\n0x00000000e3414758 0x0000000100000000 0x000000006a600000\nvmwareinfo\nUse this plugin to analyze header information from vmware saved state (vmss) or vmware snapshot (vmsn) files. The metadata contains CPU registers, the entire VMX configuration file, memory run information, and PNG screenshots of the guest VM.\n$ python vol.py -f ~/Desktop/Win7SP1x64-d8737a34.vmss vmwareinfo --verbose | less\nMagic: 0xbad1bad1 (Version 1)\nGroup count: 0x5c\nFile Offset PhysMem Offset Size\n\n0x000010000 0x000000000000 0xc0000000\n0x0c0010000 0x000100000000 0xc0000000\nDataOffset   DataSize Name                                               Value\n\n0x00001cd9        0x4 Checkpoint/fileversion                             0xa\n0x00001cfc      0x100 Checkpoint/ProductName\n0x00001cfc  56 4d 77 61 72 65 20 45 53 58 00 00 00 00 00 00   VMware.ESX......\n0x00001d0c  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00   ................\n[snip]\n0x00001e1d      0x100 Checkpoint/VersionNumber\n0x00001e1d  34 2e 31 2e 30 00 00 00 00 00 00 00 00 00 00 00   4.1.0...........\n0x00001e2d  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00   ................\n[snip]\n0x00002046        0x4 Checkpoint/Platform                                0x1\n0x00002055        0x4 Checkpoint/usageMode                               0x1\n0x00002062        0x4 Checkpoint/memSize                                 0x1800\n......\nhpakinfo\nThis plugin shows info from an hpak formatted memory dump created by FDPro.exe.\n$ python vol.py -f memdump.hpak hpakinfo\nHeader:     HPAKSECTHPAK_SECTION_PHYSDUMP\nLength:     0x20000000\nOffset:     0x4f8\nNextOffset: 0x200004f8\nName:       memdump.bin\nCompressed: 0\nHeader:     HPAKSECTHPAK_SECTION_PAGEDUMP\nLength:     0x30000000\nOffset:     0x200009d0\nNextOffset: 0x500009d0\nName:       dumpfile.sys\nCompressed: 0\nhpakextract\nIf you have an hpak file whose contents are compressed, you can extract and decompress the physical memory image using this plugin.\nFile System\nmbrparser\nScans for and parses potential Master Boot Records (MBRs). There are different options for finding MBRs and filtering output. For more information please see Recovering Master Boot Records from Memory. While this plugin was written with Windows bootkits in mind, it can also be used with memory samples from other systems.\nWhen run without any extra options, mbrparser scans for and returns information all potential MBRs defined by signature ('\\x55\\xaa') found in memory. Information includes: disassembly of bootcode (must have distorm3 installed) and partition information. This will most likely have false positives.\nIf distorm3 is not installed, the -H/--hex option can be used to get the entire bootcode section in hex instead of disassembly:\n$ python vol.py -f [sample] mbrparser -H\nIf the physical offset of the MBR is known, it can be specified with the -o/--offset= option for example:\n$ python vol.py -f [sample] -o 0x600 mbrparser\nIf the md5 hash of the desired bootcode is known, one can be specified using either the -M/--hash (the hash of bootcode up to the RET instruction) or -F/--fullhash (the hash of full bootcode) option.\n$ python vol.py mbrparser -f AnalysisXPSP3.vmem -M 6010862faee6d5e314aba791380d4f41\nor\n$ python vol.py mbrparser -f AnalysisXPSP3.vmem -F 6010862faee6d5e314aba791380d4f41\nIn order to cut down on false positives there is a -C/--check option that checks the partition table for one bootable partition that has a known, nonempty type (NTFS, FAT*, etc).\n$ python vol.py -f [sample] -C mbrparser\nThere is also an option to change the offset for the start of the disassembly. This can be useful for investigating machines (like Windows XP) that only copy the part of the MBR bootcode that has not yet executed. For example, before changing the offset:\n$ python vol.py mbrparser -f AnalysisXPSP3.vmem -o 0x600\nVolatility Foundation Volatility Framework 2.4\nPotential MBR at physical offset: 0x600\nDisk Signature: d8-8f-d8-8f\nBootcode md5: c1ca166a3417427890520bbb18911b1f\nBootcode (FULL) md5: c0bf3a94515bbd70e5a0af82f1804d89\nDisassembly of Bootable Code:\n0x00000600: 0000                             ADD [BX+SI], AL\n0x00000602: 0000                             ADD [BX+SI], AL\n0x00000604: 0000                             ADD [BX+SI], AL\n0x00000606: 0000                             ADD [BX+SI], AL\n0x00000608: 0000                             ADD [BX+SI], AL\n0x0000060a: 0000                             ADD [BX+SI], AL\n0x0000060c: 0000                             ADD [BX+SI], AL\n0x0000060e: 0000                             ADD [BX+SI], AL\n0x00000610: 0000                             ADD [BX+SI], AL\n0x00000612: 0000                             ADD [BX+SI], AL\n0x00000614: 0000                             ADD [BX+SI], AL\n0x00000616: 0000                             ADD [BX+SI], AL\n0x00000618: 0000                             ADD [BX+SI], AL\n0x0000061a: 00bdbe07                         ADD [DI+0x7be], BH\n0x0000061e: b104                             MOV CL, 0x4\n0x00000620: 386e00                           CMP [BP+0x0], CH\n[snip]\nAfter changing the starting offset:\n$ python vol.py mbrparser -f AnalysisXPSP3.vmem -o 0x600 -D 0x1b\nVolatility Foundation Volatility Framework 2.4\nPotential MBR at physical offset: 0x600\nDisk Signature: d8-8f-d8-8f\nBootcode md5: 961f3ad835d6fa9396e60ea9f825c393\nBootcode (FULL) md5: f54546c199c72389f20d537997d50c66\nDisassembly of Bootable Code:\n0x0000061b: bdbe07                           MOV BP, 0x7be\n0x0000061e: b104                             MOV CL, 0x4\n0x00000620: 386e00                           CMP [BP+0x0], CH\n0x00000623: 7c09                             JL 0x13\n0x00000625: 7513                             JNZ 0x1f\n0x00000627: 83c510                           ADD BP, 0x10\n0x0000062a: e2f4                             LOOP 0x5\n[snip]\nmftparser\nThis plugin scans for potential Master File Table (MFT) entries in memory (using \"FILE\" and \"BAAD\" signatures) and prints out information for certain attributes, currently: FILENAME(FILE_NAME (FN), STANDARDINFORMATION(STANDARD_INFORMATION (SI), FNandFN and SI attributes from the ATTRIBUTELIST,ATTRIBUTE_LIST, OBJECT_ID (default output only) and resident $DATA. This plugin has room for expansion, however, and VTypes for other attributes are already included. For more information please see Reconstructing the MBR and MFT from Memory (OMFW 2012 slides). Options of interest include:\n--machine - Machine name to add to timeline header (useful when combining timelines from multiple machines)\n-D/--dump-dir - Output directory to which resident data files are dumped\n--output=body - print output in Sleuthkit 3.X body format\n--no-check - Prints out all entries including those with null timestamps\n-E/--entry-size - Changes the default 1024 byte MFT entry size.\n-O/--offset - Prints out the MFT entry at a give offset (comma delimited)\nThis plugin may take a while to run before seeing output, since it scans first and then builds the directory tree for full file paths.\nExample (default output):\n$ python vol.py -f Bob.vmem mftparser\nVolatility Foundation Volatility Framework 2.4\nScanning for MFT entries and building directory, this can take a while\n[snip]\n\nMFT entry found at offset 0x1e69c00\nType: File\nRecord Number: 12091\nLink count: 2\n$STANDARD_INFORMATION\nCreation             Modified             MFT Altered          Access Date          Type\n\n2010-02-27 20:12:32  2010-02-27 20:12:32  2010-02-27 20:12:32  2010-02-27 20:12:32  Archive\n$FILE_NAME\nCreation             Modified             MFT Altered          Access Date          Name/Path\n\n2010-02-27 20:12:32  2010-02-27 20:12:32  2010-02-27 20:12:32  2010-02-27 20:12:32  Documents and Settings\\Administrator\\Cookies\\ADMINI~1.TXT\n$FILE_NAME\nCreation             Modified             MFT Altered          Access Date          Name/Path\n\n2010-02-27 20:12:32  2010-02-27 20:12:32  2010-02-27 20:12:32  2010-02-27 20:12:32  Documents and Settings\\Administrator\\Cookies\\administrator@search-network-plus[1].txt\n$DATA\n0000000000: 65 78 70 0a 31 39 0a 73 65 61 72 63 68 2d 6e 65   exp.19.search-ne\n0000000010: 74 77 6f 72 6b 2d 70 6c 75 73 2e 63 6f 6d 2f 0a   twork-plus.com/.\n0000000020: 31 35 33 36 0a 33 03 00 32 34 33 33 39 32 30 0a   1536.3..2433920.\n0000000030: 33 30 30 36 32 36 30 35 0a 38 33 37 34 31 36 35   30062605.8374165\n0000000040: 37 36 0a 33 30 30 36 32 35 36 39 0a 2a 0a         76.30062569.*.\n\n[snip]\n\nMFT entry found at offset 0x1cdbac00\nType: In Use & File\nRecord Number: 12079\nLink count: 1\n$STANDARD_INFORMATION\nCreation             Modified             MFT Altered          Access Date          Type\n\n2010-02-27 20:12:28  2010-02-27 20:12:28  2010-02-27 20:12:28  2010-02-27 20:12:28  Archive\n$FILE_NAME\nCreation             Modified             MFT Altered          Access Date          Name/Path\n\n2010-02-27 20:12:28  2010-02-27 20:12:28  2010-02-27 20:12:28  2010-02-27 20:12:28  Documents and Settings\\Administrator\\Local Settings\\Temp\\plugtmp\\PDF.php\n$DATA\nNon-Resident\n\n[snip]\nThe bodyfile output is also an option. It is recommended that the output be stored in a file using the --output-file option, since it is quite lengthy. The following shows creating a bodyfile using mftparser while dumping resident files. You can also see a file of interest that is created on the system (f.txt) which happens to be recovered in the output directory:\n$ python vol.py -f grrcon.img mftparser --output=body -D output --output-file=grrcon_mft.body\nVolatility Foundation Volatility Framework 2.4\nScanning for MFT entries and building directory, this can take a while\n$ cat grrcon_mft.body\n[snip]\n0|[MFT STD_INFO] WINDOWS\\system32\\systems (Offset: 0x15938400)|12029|---------------|0|0|0|1335579320|1335579320|1335579320|1335578463\n0|[MFT FILE_NAME] WINDOWS\\system32\\systems\\f.txt (Offset: 0x15938800)|12030|---a-----------|0|0|0|1335578503|1335578503|1335578503|1335578503\n0|[MFT STD_INFO] WINDOWS\\system32\\systems\\f.txt (Offset: 0x15938800)|12030|---a-----------|0|0|0|1335578503|1335578503|1335578503|1335578503\n0|[MFT FILE_NAME] WINDOWS\\system32\\systems\\g.exe (Offset: 0x15938c00)|12031|---a-----------|0|0|0|1335578514|1335578514|1335578514|1335578514\n0|[MFT STD_INFO] WINDOWS\\system32\\systems\\g.exe (Offset: 0x15938c00)|12031|---a-----------|0|0|0|1335579014|1335578514|1335578514|1335578514\n0|[MFT FILE_NAME] WINDOWS\\inf\\divasrv.inf (Offset: 0x15c83000)|2192|---a-----------|0|0|22554|1332601266|1332601266|1332601266|1332601235\n[snip]\n$ ls output/15938800\noutput/file.0x15938800.data0.dmp\n$ cat output/15938800\nopen 66.32.119.38\njack\n2awes0me\nlcd c:\\WINDOWS\\System32\\systems\ncd  /home/jack\nbinary\nmput \"*.txt\"\ndisconnect\nbye\nThe Sleuthkit mactime utility can then be used to output the bodyfile in a readable manner:\n$ mactime -b grrcon_mft.body -d -z UTC |less\n[snip]\nSat Apr 28 2012 02:01:43,0,macb,---a-----------,0,0,12030,\"[MFT FILE_NAME] WINDOWS\\system32\\systems\\f.txt (Offset: 0x15938800)\"\nSat Apr 28 2012 02:01:43,0,macb,---a-----------,0,0,12030,\"[MFT STD_INFO] WINDOWS\\system32\\systems\\f.txt (Offset: 0x15938800)\"\nSat Apr 28 2012 02:01:54,0,macb,---a-----------,0,0,12031,\"[MFT FILE_NAME] WINDOWS\\system32\\systems\\g.exe (Offset: 0x15938c00)\"\nSat Apr 28 2012 02:01:54,0,m.cb,---a-----------,0,0,12031,\"[MFT STD_INFO] WINDOWS\\system32\\systems\\g.exe (Offset: 0x15938c00)\"\nSat Apr 28 2012 02:02:05,0,macb,---a-----------,0,0,12032,\"[MFT FILE_NAME] WINDOWS\\system32\\systems\\p.exe (Offset: 0x18229000)\"\nSat Apr 28 2012 02:02:05,0,...b,---a-----------,0,0,12032,\"[MFT STD_INFO] WINDOWS\\system32\\systems\\p.exe (Offset: 0x18229000)\"\nSat Apr 28 2012 02:02:06,0,m...,---a-----------,0,0,12032,\"[MFT STD_INFO] WINDOWS\\system32\\systems\\p.exe (Offset: 0x18229000)\"\nSat Apr 28 2012 02:02:17,0,macb,---a-----------,0,0,12033,\"[MFT FILE_NAME] WINDOWS\\system32\\systems\\r.exe (Offset: 0x18229400)\"\nSat Apr 28 2012 02:02:17,0,m.cb,---a-----------,0,0,12033,\"[MFT STD_INFO] WINDOWS\\system32\\systems\\r.exe (Offset: 0x18229400)\"\nSat Apr 28 2012 02:02:26,0,macb,---a-----------,0,0,12034,\"[MFT FILE_NAME] WINDOWS\\system32\\systems\\sysmon.exe (Offset: 0x18229800)\"\nSat Apr 28 2012 02:02:26,0,...b,---a-----------,0,0,12034,\"[MFT STD_INFO] WINDOWS\\system32\\systems\\sysmon.exe (Offset: 0x18229800)\"\nSat Apr 28 2012 02:02:27,0,m.c.,---a-----------,0,0,12034,\"[MFT STD_INFO] WINDOWS\\system32\\systems\\sysmon.exe (Offset: 0x18229800)\"\n[snip]\nMiscellaneous\nstrings\nFor a given image and a file with lines of the form :, or  , output the corresponding process and virtual addresses where that string can be found. Expected input for this tool is the output of Microsoft Sysinternals' Strings utility, or another utility that provides similarly formatted offset:string mappings. Note that the input offsets are physical offsets from the start of the file/image.\nSysinternals Strings can be used on Linux/Mac using Wine. Output should be redirected to a file to be fed to the Volatility strings plugin. If you're using GNU strings command, use the -td flags to produce offsets in decimal (the plugin does not accept hex offsets). Some example usages are as follows:\nWindows\nC:> strings.exe \u2013q \u2013o -accepteula win7.dd > win7_strings.txt\nIt can take a while for the Sysinternals strings program to finish. The \u2013q and \u2013o switches are imperative, since they make sure the header is not output (-q) and that there is an offset for each line (-o).\nLinux/Mac\nYou can use the Sysinternals strings program with wine:\n$ wine strings.exe \u2013q \u2013o -accepteula win7.dd > win7_strings.txt\nYou can also use the GNU strings utility that comes with Linux and Mac (Note: the default strings utility on Mac does not have Unicode support. You can install the GNU binutils package in order to get a strings utility that does). You should use the -td flags to get the decimal offset and will have to make a second pass with the -el flags in order to get (little endian) Unicode strings. Notice that the second pass appends (>>) to the existing file:\nstrings\u2212a\u2212tdwin7.dd>win7strings.txt strings -a -td win7.dd > win7_strings.txt \n strings -a -td -el win7.dd >> win7_strings.txt\nThe result should be a text file that contains the offset and strings from the image for example:\n16392:@@@\n17409:\n17441:\n17473:\"\"\"\n17505:###\n17537:$$$\n17569:%%%\n17601:&&&\n17633:'''\n17665:(((\n17697:)))\n17729:***\nEnCase Keyword Export\nYou can also use EnCase to export keywords and offsets in this format with some tweaking. One thing to note is that EnCase exports text in UTF-16 with a BOM of (U+FEFF) which can cause issues with the strings plugin. An example look at the exported keyword file:\nFile Offset Hit Text\n114923  DHCP\n114967  DHCP\n115892  DHCP\n115922  DHCP\n115952  DHCP\n116319  DHCP\n[snip]\nNow tweaking the file by removing the header and tabs we have:\n114923:DHCP\n114967:DHCP\n115892:DHCP\n115922:DHCP\n115952:DHCP\n116319:DHCP\n[snip]\nWe can see that it is UTF-16 and has a BOM of (U+FEFF) by using a hex editor.\n$ file export.txt\nexport.txt: Little-endian UTF-16 Unicode text, with CRLF, CR line terminators\n$ xxd export.txt |less\n0000000: fffe 3100 3100 3400 3900 3200 3300 3a00  ..1.1.4.9.2.3.:.\n[snip]\nWe have to convert this to ANSI or UTF-8. In Windows you can open the text file and use the \"Save As\" dialog to save the file as ANSI (in the \"Encoding\" drop-down menu). In Linux you can use iconv:\n$ iconv -f UTF-16 -t UTF-8 export.txt > export1.txt\nNOTE: You must make sure there are NO blank lines in your final \"strings\" file.\nNow we can see a difference in how these two files are handled:\n$ python vol.py -f Bob.vmem --profile=WinXPSP2x86 strings -s export.txt\nVolatility Foundation Volatility Framework 2.4\nERROR   : volatility.plugins.strings: String file format invalid.\n$ python vol.py -f Bob.vmem --profile=WinXPSP2x86 strings -s export1.txt\nVolatility Foundation Volatility Framework 2.4\n0001c0eb [kernel:2147598571] DHCP\n0001c117 [kernel:2147598615] DHCP\n0001c4b4 [kernel:2147599540] DHCP\n0001c4d2 [kernel:2147599570] DHCP\n0001c4f0 [kernel:2147599600] DHCP\n0001c65f [kernel:2147599967] DHCP\n0001c686 [kernel:2147600006] DHCP\n[snip]\nNOTE: The Volatility strings output is very verbose and it is best to redirect or save to a file. The following command saves the output using the --output-file option and filename \"win7_vol_strings.txt\"\n$ python vol.py --profile=Win7SP0x86 strings \u2013f win7.dd \u2013s win7_strings.txt --output-file=win7_vol_strings.txt\nBy default strings will only provide output for processes found by walking the doubly linked list pointed to by PsActiveProcessHead (see pslist) in addition to kernel addresses. strings can also provide output for hidden processes (see psscan) by using the (capital) -S switch:\n$ python vol.py --profile=Win7SP0x86 strings \u2013f win7.dd \u2013s win7_strings.txt --output-file=win7_vol_strings.txt -S\nAlso an EPROCESS offset can be provided:\n$ python vol.py --profile=Win7SP0x86 strings \u2013f win7.dd \u2013s win7_strings.txt --output-file=win7_vol_strings.txt -o 0x04a291a8\nThe strings plugin takes a while to complete. When it completes, you should have an output file with each line in the following format:\nphysical_address [kernel_or_pid:virtual_address] string\nIn the example output you can see PIDs/kernel references:\n$ less win7_vol_strings.txt\n000003c1 [kernel:4184445889] '<'@\n00000636 [kernel:4184446518] 8,t\n000006c1 [kernel:4184446657] w#r\n000006d8 [kernel:4184446680] sQOtN2\n000006fc [kernel:4184446716] t+a`j\n00000719 [kernel:4184446745] aas\n0000072c [kernel:4184446764] Invalid partition ta\n00000748 [kernel:4184446792] r loading operating system\n00000763 [kernel:4184446819] Missing operating system\n000007b5 [kernel:4184446901] ,Dc\n0000400b [kernel:2147500043 kernel:4184461323] 3TYk\n00004056 [kernel:2147500118 kernel:4184461398] #:s\n000040b0 [kernel:2147500208 kernel:4184461488] CO0\n000040e9 [kernel:2147500265 kernel:4184461545] BrvWo\n000040f0 [kernel:2147500272 kernel:4184461552] %Sz\n000040fc [kernel:2147500284 kernel:4184461564] A0?0=\n00004106 [kernel:2147500294 kernel:4184461574] 7http://crl.microsoft.com/pki/crl/products/WinIntPCA.crl0U\n[snip]\n00369f14 [1648:1975394068] Ph00369f2e\u00a0[1648:1975394094]\u00a09} \n00369f2e [1648:1975394094] 9}\n00376044 [1372:20422724] Ju0w\n0037616d [1372:20423021] msxml6.dll\n003761e8 [1372:20423144] U'H\n003762e3 [1372:20423395] }e_\n0037632e [1372:20423470] xnA\n[snip]\n03678031 [360:2089816113 596:2089816113 620:2089816113 672:2089816113 684:2089816113 844:2089816113 932:2089816113 1064:2089816113 1164:2089816113 1264:2089816113 1516:2089816113 1648\n:2089816113 1896:2089816113 1904:2089816113 1756:2089816113 512:2089816113 1372:2089816113 560:2089816113] A$9B\nOnce you have the strings output, you can see which process(es) have the suspicious string in memory and can then narrow your focus. You can grep for the string or pattern depending on the context you were given. For example, if you are looking for a particular command:\n$ grep [command or pattern] win7_vol_strings.txt > strings_of_interest.txt\nFor all IPs:\ncat\u00a0win7_vol_strings.txt\u00a0|\u00a0\\\u00a0perl\u00a0-e\u00a0'while(<>){if(/(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?).){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)/){print cat win7_vol_strings.txt | \\ \nperl -e 'while(<>){if(/(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?).){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)/){print _;}}' > IPs.txt\nFor all URLs:\ncat\u00a0win7_vol_strings.txt\u00a0|\u00a0\\\u00a0perl\u00a0-e\u00a0'while(<>){\u00a0if(/(http|https|ftp|mail):[\\/\\w.]+/){print cat win7_vol_strings.txt | \\ \nperl -e 'while(<>){ if(/(http|https|ftp|mail):[\\/\\w.]+/){print _;}}' > URLs.txt\nDepending on the context, your searches will vary.\nvolshell\nIf you want to interactively explore a memory image, use the volshell command. This gives you an interface similar to WinDbg into the memory dump. For example, you can:\nList processes\nSwitch into a process's context\nDisplay types of structures/objects\nOverlay a type over a given address\nWalk linked lists\nDisassemble code at a given address\nNote: volshell can take advantage of IPython if you have it installed. This will add tab-completion and saved command history.\nTo break into a volshell:\n$ python vol.py --profile=Win7SP0x86 -f win7.dmp volshell\nVolatility Foundation Volatility Framework 2.0\nCurrent context: process System, pid=4, ppid=0 DTB=0x185000\nWelcome to volshell Current memory image is:\nfile:///Users/M/Desktop/win7.dmp\nTo get help, type 'hh()'\n\n\n\nhh()\nps()                                     : Print a process listing.\ncc(offset=None, pid=None, name=None)     : Change current shell context.\ndd(address, length=128, space=None)      : Print dwords at address.\ndb(address, length=128, width=16, space=None) : Print bytes as canonical hexdump.\nhh(cmd=None)                             : Get help on a command.\ndt(objct, address=None, address_space=None)  : Describe an object or show type info.\nlist_entry(head, objname, offset=-1, fieldname=None, forward=True) : Traverse a _LIST_ENTRY.\ndis(address, length=128, space=None)     : Disassemble code at a given address.\n\n\n\nFor help on a specific command, type 'hh()'\n\n\n\nLet's say you want to see what's at 0x779f0000 in the memory of explorer.exe. First display the processes so you can get the PID or offset of Explorer's EPROCESS. (Note: if you want to view data in kernel memory, you do not need to switch contexts first.)\nps()\nName             PID    PPID   Offset\nSystem           4      0      0x83dad960\nsmss.exe         252    4      0x84e47840\ncsrss.exe        348    340    0x8d5ffd40\nwininit.exe      384    340    0x84e6e3d8\ncsrss.exe        396    376    0x8d580530\nwinlogon.exe     424    376    0x8d598530\nservices.exe     492    384    0x8d4cc030\nlsass.exe        500    384    0x8d6064a0\nlsm.exe          508    384    0x8d6075d8\nsvchost.exe      616    492    0x8d653030\nsvchost.exe      680    492    0x8d673b88\nsvchost.exe      728    492    0x8d64fb38\ntaskhost.exe     1156   492    0x8d7ee030\ndwm.exe          956    848    0x8d52bd40\nexplorer.exe     1880   1720   0x8d66c1a8\nwuauclt.exe      1896   876    0x83ec3238\nVMwareTray.exe   2144   1880   0x83f028d8\nVMwareUser.exe   2156   1880   0x8d7893b0\n[snip]\nNow switch into Explorer's context and print the data with either db (display as canonical hexdump) or dd (display as double-words):\ndd(0x779f0000)\n779f0000  00905a4d 00000003 00000004 0000ffff\n779f0010  000000b8 00000000 00000040 00000000\n779f0020  00000000 00000000 00000000 00000000\n779f0030  00000000 00000000 00000000 000000e0\n779f0040  0eba1f0e cd09b400 4c01b821 685421cd\n779f0050  70207369 72676f72 63206d61 6f6e6e61\n779f0060  65622074 6e757220 206e6920 20534f44\n779f0070  65646f6d 0a0d0d2e 00000024 00000000\ndb(0x779f0000)\n779f0000   4d 5a 90 00 03 00 00 00 04 00 00 00 ff ff 00 00    MZ..............\n779f0010   b8 00 00 00 00 00 00 00 40 00 00 00 00 00 00 00    ........@.......\n779f0020   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................\n779f0030   00 00 00 00 00 00 00 00 00 00 00 00 e0 00 00 00    ................\n779f0040   0e 1f ba 0e 00 b4 09 cd 21 b8 01 4c cd 21 54 68    ..........L.Th\n779f0050   69 73 20 70 72 6f 67 72 61 6d 20 63 61 6e 6e 6f    is program canno\n779f0060   74 20 62 65 20 72 75 6e 20 69 6e 20 44 4f 53 20    t be run in DOS\n779f0070   6d 6f 64 65 2e 0d 0d 0a 24 00 00 00 00 00 00 00    mode....$.......\nSo there is a PE at 0x779f0000 in explorer.exe. If you want to disassemble instructions at RVA 0x2506 in the PE, do this:\ndis(0x779f0000 + 0x2506)\n0x779f2506 8d0c48                           LEA ECX, [EAX+ECX*2]\n0x779f2509 8b4508                           MOV EAX, [EBP+0x8]\n0x779f250c 8b4c4802                         MOV ECX, [EAX+ECX*2+0x2]\n0x779f2510 8d0448                           LEA EAX, [EAX+ECX*2]\n0x779f2513 e9c07f0300                       JMP 0x77a2a4d8\n0x779f2518 85f6                             TEST ESI, ESI\n0x779f251a 0f85c12c0700                     JNZ 0x77a651e1\n0x779f2520 8b4310                           MOV EAX, [EBX+0x10]\n0x779f2523 8b407c                           MOV EAX, [EAX+0x7c]\n0x779f2526 8b4b18                           MOV ECX, [EBX+0x18]\n0x779f2529 0fb7444102                       MOVZX EAX, [ECX+EAX*2+0x2]\n0x779f252e 894520                           MOV [EBP+0x20], EAX\n[snip]\nIf you want to remind yourself of the members in an EPROCESS object for the given OS, do this:\ndt(\"EPROCESS\")\n'EPROCESS' (704 bytes)\n0x0   : Pcb                            ['KPROCESS']\n0x98  : ProcessLock                    ['_EX_PUSH_LOCK']\n0xa0  : CreateTime                     ['LARGE_INTEGER']\n0xa8  : ExitTime                       ['LARGE_INTEGER']\n0xb0  : RundownProtect                 ['_EX_RUNDOWN_REF']\n0xb4  : UniqueProcessId                ['pointer', ['void']]\n0xb8  : ActiveProcessLinks             ['LIST_ENTRY']\n0xc0  : ProcessQuotaUsage              ['array', 2, ['unsigned long']]\n0xc8  : ProcessQuotaPeak               ['array', 2, ['unsigned long']]\n0xd0  : CommitCharge                   ['unsigned long']\n0xd4  : QuotaBlock                     ['pointer', ['_EPROCESS_QUOTA_BLOCK']]\n[snip]\nTo overlay the EPROCESS types onto the offset for explorer.exe, do this:\ndt(\"_EPROCESS\", 0x8d66c1a8)\n[_EPROCESS _EPROCESS] @ 0x8D66C1A8\n0x0   : Pcb                            2372321704\n0x98  : ProcessLock                    2372321856\n0xa0  : CreateTime                     2010-07-06 22:38:07\n0xa8  : ExitTime                       1970-01-01 00:00:00\n0xb0  : RundownProtect                 2372321880\n0xb4  : UniqueProcessId                1880\n0xb8  : ActiveProcessLinks             2372321888\n0xc0  : ProcessQuotaUsage              -\n0xc8  : ProcessQuotaPeak               -\n0xd0  : CommitCharge                   4489\n0xd4  : QuotaBlock                     2372351104\n[snip]\nThe db, dd, dt, and dis commands all accept an optional \"space\" parameter which allows you to specify an address space. You will see different data depending on which address space you're using. Volshell has some defaults and rules that are important to note:\n\n\n\nIf you don't supply an address space and have not switched into a process context with cc, then you'll be using the default kernel space (System process).\nIf you don't supply an address space and have switched into a process context with cc, then you'll be using the space of the active/current process.\nIf you explicitly supply an address space, the one you supplied will be used.\nImagine you're using one of the scan commands (psscan, connscan, etc.) and you think it has picked up a false positive. The scan commands output a physical offset (offset into the memory dump file). You want to explore the data around the potential false positive to determine for yourself if any structure members appear sane or not. One way you could do that is by opening the memory dump in a hex viewer and going to the physical offset to view the raw bytes. However, a better way is to use volshell and overlay the structure question to the alleged physical offset. This allows you to see the fields interpreted as their intended type (DWORD, string, short, etc.)\nHere's an example. First instantiate a physical address space:\n\n\n\nphysical_space = utils.load_as(self._config, astype = 'physical')\nAssuming the alleged false positive for an EPROCESS is at 0x433308, you would then do:\ndt(\"_EPROCESS\", 0x433308, physical_space)\n[_EPROCESS _EPROCESS] @ 0x00433308\n0x0   : Pcb                            4403976\n0x6c  : ProcessLock                    4404084\n0x70  : CreateTime                     1970-01-01 00:00:00\n0x78  : ExitTime                       1970-01-01 00:00:00\n...\nAnother neat trick is to use volshell in a non-interactive manner. For example, say you want to translate an address in kernel memory to its corresponding physical offset.\n\n\n\n$ echo \"hex(addrspace().vtop(0x823c8830))\" | python vol.py -f stuxnet.vmem volshell\nVolatility Foundation Volatility Framework 2.4\nCurrent context: process System, pid=4, ppid=0 DTB=0x319000\nWelcome to volshell Current memory image is:\nfile:///mem/stuxnet.vmem\nTo get help, type 'hh()'\n\n\n\n'0x25c8830'\nThus the kernel address 0x823c8830 translates to physical offset 0x25c8830 in the memory dump file.\n\n\n\nYou can execute multiple commands sequentially like this:\n$ echo \"cc(pid=4); dd(0x10000)\" | [...]\nFor more information, see BDG's Introducing Volshell.\nbioskbd\nTo read keystrokes from the BIOS area of memory, use the bioskbd command. This can reveal passwords typed into HP, Intel, and Lenovo BIOS and SafeBoot, TrueCrypt, and BitLocker software. Depending on the tool used to acquire memory, not all memory samples will contain the necessary BIOS area. For more information, see Andreas Schuster's Reading Passwords From the Keyboard Buffer, David Sharpe's Duplicating Volatility Bioskbd Command Function on Live Windows Systems, and Jonathan Brossard's Bypassing pre-boot authentication passwords by instrumenting the BIOS keyboard buffer.\npatcher\nThe patcher plugin accepts a single argument of '-x' followed by an XML file. The XML file then specifies any required patches as in the following example:\n\n\n\n      554433221100\n\n\n      001122334455\n\n\n\n    ...\n\n\nThe XML root element is always patchfile, and contains any number of patchinfo elements. When the patchfile is run, it will scan over the memory once for each patchinfo, attempting to scan using the method specified in the method attribute. Currently the only support method is pagescan and this must be explicitly declared in each patchinfo element.\nEach pagescan type patchinfo element contains a single constraints element and a single patches element. The scan then proceeds over each page in memory, verifying that all constraints are met, and if so, the instructions specified in the patches element are carried out.\nThe constraints element contains any number of match elements which take a specific offset attribute (specifying where within the page the match should occur) and then contain a hexadecimal string for the bytes that are supposed to match.\nThe patches element contains any number of setbytes elements which take a specific offset attribute (specifying where with the page the patch should modify data) and then contains a hexidecimal string for the bytes that should be written into the page.\nNote: When running the patcher plugin, there will be no modification made to memory unless the write option (-w) has been specified on the command line.\npagecheck\nThe pagecheck plugin uses a kernel DTB (from the System/Idle process) and determines which pages should be memory resident (using the AddressSpace.get_available_pages method). For each page, it attempts to access the page data and reports details, such as the PDE and PTE addresses if the attempt fails. This is a diagnostic plugin, usually helpful in troubleshooting \"holes\" in an address space.\nThis plugin is not well-supported. It is in the contrib directory and currently only works with non-PAE x86 address spaces.\n$ python vol.py --plugins=contrib/plugins/ -f pat-2009-11-16.mddramimage pagecheck\nVolatility Foundation Volatility Framework 2.4\n(V): 0x06a5a000 [PDE] 0x038c3067 [PTE] 0x1fe5e047 (P): 0x1fe5e000 Size: 0x00001000\n(V): 0x06c5f000 [PDE] 0x14d62067 [PTE] 0x1fe52047 (P): 0x1fe52000 Size: 0x00001000\n(V): 0x06cd5000 [PDE] 0x14d62067 [PTE] 0x1fe6f047 (P): 0x1fe6f000 Size: 0x00001000\n(V): 0x06d57000 [PDE] 0x14d62067 [PTE] 0x1fe5c047 (P): 0x1fe5c000 Size: 0x00001000\n(V): 0x06e10000 [PDE] 0x14d62067 [PTE] 0x1fe62047 (P): 0x1fe62000 Size: 0x00001000\n(V): 0x070e4000 [PDE] 0x1cac7067 [PTE] 0x1fe1e047 (P): 0x1fe1e000 Size: 0x00001000\n(V): 0x077a8000 [PDE] 0x1350a067 [PTE] 0x1fe06047 (P): 0x1fe06000 Size: 0x00001000\n(V): 0x07a41000 [PDE] 0x05103067 [PTE] 0x1fe05047 (P): 0x1fe05000 Size: 0x00001000\n(V): 0x07c05000 [PDE] 0x103f7067 [PTE] 0x1fe30047 (P): 0x1fe30000 Size: 0x00001000\n...\ntimeliner\nThis timeliner plugin creates a timeline from various artifacts in memory from the following sources (items in parenthesis are filters that may be used with the --type flag in order to obtain only items of that artifact):\nSystem time (ImageDate)\nProcesses (Process)\nCreate and Exit times\nLastTrimTime (XP and 2003 only)\nDLLs (Process, LoadTime)\nLoadTime (Windows 7 and 8 only)\nPE Timestamps (TimeDateStamp)\nModules/Processes/DLLs\nIMAGE_FILE_HEADER\nIMAGE_DEBUG_DIRECTORY\nThreads (Thread)\nCreate and Exit times\nSockets (Socket)\nCreate time\nEvent logs (XP and 2003 only) (EvtLog)\nIE History (IEHistory)\nRegistry hives (CMHIVE and _HBASE_BLOCK)\nRegistry keys\nLastWriteTime of registry keys in _CMHIVE (Registry)\nLastWriteTime of registry key objects referenced in the handle table (CM_KEY_BODY)\nEmbedded registry (filters below)\nUserassist\nShimcache\nTimers (Timer)\nSymbolic links (Symlink)\nYou can filter for any of the above options in order to have more focused output using the --type flag:\n$ python vol.py -f Win2k12x64-Snapshot3.vmsn --profile=Win2012R2x64 --kdbg=0xf800f17dd9b0 timeliner --type=CMHIVE\nVolatility Foundation Volatility Framework 2.4\n1970-01-01 00:00:00 UTC+0000|[CMHIVE LastWriteTime]| [no name]|\n1970-01-01 00:00:00 UTC+0000|[CMHIVE LastWriteTime]| \\REGISTRY\\MACHINE\\SYSTEM|\n2014-06-20 06:31:29 UTC+0000|[CMHIVE LastWriteTime]| \\SystemRoot\\System32\\Config\\SOFTWARE|\n2014-06-20 06:31:29 UTC+0000|[CMHIVE LastWriteTime]| \\SystemRoot\\System32\\Config\\DEFAULT|\n2014-06-20 06:31:29 UTC+0000|[CMHIVE LastWriteTime]| \\REGISTRY\\MACHINE\\SAM|\n2014-06-20 06:31:05 UTC+0000|[_CMHIVE LastWriteTime]| \\??\\C:\\Users\\Administrator\\AppData\\Local\\Microsoft\\Windows\\UsrClass.dat|\n2013-09-15 03:33:22 UTC+0000|[CMHIVE LastWriteTime]| \\SystemRoot\\System32\\Config\\BBI|\n2014-06-20 06:31:29 UTC+0000|[CMHIVE LastWriteTime]| \\??\\C:\\Windows\\ServiceProfiles\\NetworkService\\NTUSER.DAT|\n2014-06-20 06:31:29 UTC+0000|[CMHIVE LastWriteTime]| \\REGISTRY\\MACHINE\\SECURITY|\n2014-06-20 06:31:05 UTC+0000|[CMHIVE LastWriteTime]| \\??\\C:\\Users\\Administrator\\ntuser.dat|\n2014-06-20 06:31:29 UTC+0000|[_CMHIVE LastWriteTime]| \\??\\C:\\Windows\\ServiceProfiles\\LocalService\\NTUSER.DAT|\n2014-06-20 06:31:29 UTC+0000|[_CMHIVE LastWriteTime]| \\Device\\HarddiskVolume1\\Boot\\BCD|\n1970-01-01 00:00:00 UTC+0000|[_CMHIVE LastWriteTime]| \\REGISTRY\\MACHINE\\HARDWARE|\nThere are three options for output: default text output, bodyfile format and an Excel 2007 file. For more details see Timeliner Release Documentation (pdf) and the OMFW 2011 presentation Time is on My Side. You can also include a machine identifier in the header with the --machine flag (this is useful when combining timelines from multiple machines). The following shows the default text output:\n$ python vol.py -f XPSP3x86.vmem timeliner\nVolatility Foundation Volatility Framework 2.4\n2011-10-13 04:29:21 UTC+0000|[LIVE RESPONSE]| (System time)\n2010-08-22 17:38:12 UTC+0000|[IEHISTORY]| explorer.exe->Visited: Administrator@about:Home| PID: 1196/Cache type \"URL \" at 0x17f5100 End: 2010-08-22 17:38:12 UTC+0000\n2010-10-31 13:48:47 UTC+0000|[IEHISTORY]| explorer.exe->Visited: Administrator@file:///C:/Documents%20and%20Settings/Administrator/Desktop/Sparkling_Swiss-4288x2848.jpg| PID: 1196/Cache type \"URL \" at 0x17f5300 End: 2010-10-31 13:48:47 UTC+0000\n2010-10-31 13:49:00 UTC+0000|[IEHISTORY]| explorer.exe->Visited: Administrator@file:///C:/Documents%20and%20Settings/Administrator/My%20Documents/My%20Pictures/Sparkling_Swiss-4288x2848.jpg| PID: 1196/Cache type \"URL \" at 0x17f6000 End: 2010-10-31 13:49:00 UTC+0000\n2011-10-13 04:20:23 UTC+0000|[PROCESS]| wuauclt.exe| PID: 332/PPID: 1032/POffset: 0x0226d580\n2011-10-13 04:20:23 UTC+0000|[PROCESS LastTrimTime]| wuauclt.exe| PID: 332/PPID: 1032/POffset: 0x0226d580\n2010-10-29 17:08:54 UTC+0000|[Handle (Key)]| MACHINE| wuauclt.exe PID: 332/PPID: 1032/POffset: 0x0226d580\n2010-08-22 17:35:38 UTC+0000|[Handle (Key)]| MACHINE\\SOFTWARE\\MICROSOFT\\WINDOWS NT\\CURRENTVERSION\\DRIVERS32| wuauclt.exe PID: 332/PPID: 1032/POffset: 0x0226d580\n2010-08-22 17:35:38 UTC+0000|[Handle (Key)]| MACHINE\\SOFTWARE\\MICROSOFT\\WINDOWS NT\\CURRENTVERSION\\DRIVERS32| wuauclt.exe PID: 332/PPID: 1032/POffset: 0x0226d580\n2010-10-29 16:50:27 UTC+0000|[Handle (Key)]| MACHINE\\SOFTWARE\\CLASSES| wuauclt.exe PID: 332/PPID: 1032/POffset: 0x0226d580\n[snip]\nIf you don't want to do the extra step of importing, you can use the --output=xlsx option with --output-file=FILE to save directly an Excel 2007 file. Note: You must have OpenPyxl installed for this.\n$ python vol.py -f XPSP3x86.vmem timeliner --output=xlsx --output-file=output.xlsx\nAnother option is to use the --output=body option for TSK 3.x bodyfile format. You can use this output option when you want to combine output from timeliner, mftparser and shellbags.\nBy default everything except the registry LastWrite timestamps are included in the output of timeliner, this is because obtaining the registry timestamps is quite labor intensive. In order to add them to the output, simply add the --type=Registry option when you run Volatility. You can also limit your focus of registry timestamps by listing a specific registry name (like --hive=SYSTEM) or user (--user=Jim) or both (--hive=UsrClass.dat --user=jim). These options are case insensitive.\n$ python vol.py -f win7SP1x86.vmem --profile=Win7SP1x86 timeliner --output=body --output-file=output.body --type=Registry --user=Jim --hive=UsrClass.dat\n# The Volatility Framework 2.5 Windows Core Command Reference\n\n\u30e1\u30e2\u30ea\u30d5\u30a9\u30ec\u30f3\u30b8\u30c3\u30af\u30c4\u30fc\u30eb\u306eVolatility Framework\u30b3\u30de\u30f3\u30c9\u30ea\u30d5\u30a1\u30ec\u30f3\u30b9\u306e\u65e5\u672c\u8a9e\u8a33\u3067\u3059\u3002Windows Core\u3001Windows Malware\u3001Windows GUI\u3068\u3044\u3046\u9806\u756a\u3067\u7ffb\u8a33\u3059\u308b\u4e88\u5b9a\u3067\u3059\u3002(\u6c17\u529b\u304c\u7d9a\u3051\u3070)\n\n# Image Identification\n\n## imageinfo\n\n>For a high level summary of the memory sample you're analyzing, use the imageinfo command. Most often this command is used to identify the operating system, service pack, and hardware architecture (32 or 64 bit), but it also contains other useful information such as the DTB address and time the sample was collected.\n\nimageinfo\u30b3\u30de\u30f3\u30c9\u3067\u89e3\u6790\u3059\u308b\u30e1\u30e2\u30ea\u30b5\u30f3\u30d7\u30eb\u306e\u6982\u8981\u304c\u5206\u304b\u308a\u307e\u3059\u3002\u4e3b\u306bOS\u306e\u7a2e\u985e\u3001\u30b5\u30fc\u30d3\u30b9\u30d1\u30c3\u30af\u306e\u6709\u7121\u3001\u30cf\u30fc\u30c9\u30a6\u30a7\u30a2\u30a2\u30fc\u30ad\u30c6\u30af\u30c1\u30e3(32/64bit)\u3092\u8b58\u5225\u3059\u308b\u305f\u3081\u306b\u5229\u7528\u3055\u308c\u307e\u3059\u304c\u3001DTB\u30a2\u30c9\u30ec\u30b9\u3068\u3044\u3063\u305f\u6709\u76ca\u306a\u60c5\u5831\u3092\u77e5\u308b\u3053\u3068\u3082\u3067\u304d\u307e\u3059\u3002\n\n```\n$ python vol.py -f ~/Desktop/win7_trial_64bit.raw imageinfo\nVolatility Foundation Volatility Framework 2.4\nDetermining profile based on KDBG search...\n\n          Suggested Profile(s) : Win7SP0x64, Win7SP1x64, Win2008R2SP0x64, Win2008R2SP1x64\n                     AS Layer1 : AMD64PagedMemory (Kernel AS)\n                     AS Layer2 : FileAddressSpace (/Users/Michael/Desktop/win7_trial_64bit.raw)\n                      PAE type : PAE\n                           DTB : 0x187000L\n                          KDBG : 0xf80002803070\n          Number of Processors : 1\n     Image Type (Service Pack) : 0\n                KPCR for CPU 0 : 0xfffff80002804d00L\n             KUSER_SHARED_DATA : 0xfffff78000000000L\n           Image date and time : 2012-02-22 11:29:02 UTC+0000\n     Image local date and time : 2012-02-22 03:29:02 -0800\n```\n\n>The imageinfo output tells you the suggested profile that you should pass as the parameter to --profile=PROFILE when using other plugins. There may be more than one profile suggestion if profiles are closely related. It also prints the address of the KDBG (short for _KDDEBUGGER_DATA64) structure that will be used by plugins like pslist and modules to find the process and module list heads, respectively. In some cases, especially larger memory samples, there may be multiple KDBG structures. Similarly, if there are multiple processors, you'll see the KPCR address and CPU number for each one.\n\nimageinfo\u306f\u3001\u5225\u306e\u30d7\u30e9\u30b0\u30a4\u30f3\u3092\u5b9f\u884c\u3059\u308b\u969b\u306b--profile=PROFILE\u30aa\u30d7\u30b7\u30e7\u30f3\u3067\u6307\u5b9a\u3059\u3079\u304d\u30d7\u30ed\u30d5\u30a1\u30a4\u30eb\u3092\u793a\u5506\u3057\u3066\u304f\u308c\u307e\u3059\u3002\u95a2\u9023\u3059\u308b\u8907\u6570\u306e\u30d7\u30ed\u30d5\u30a1\u30a4\u30eb\u304c\u793a\u3055\u308c\u308b\u5834\u5408\u3082\u3042\u308a\u307e\u3059\u3002pslist\u3084\u30d7\u30ed\u30bb\u30b9\u3068\u30e2\u30b8\u30e5\u30fc\u30eb\u30ea\u30b9\u30c8\u3092\u63a2\u7d22\u3059\u308b\u30d7\u30e9\u30b0\u30a4\u30f3\u3067\u5229\u7528\u3055\u308c\u308bKDBG\u69cb\u9020\u4f53(_KDDEBUGGER_DATA64)\u306e\u30a2\u30c9\u30ec\u30b9\u3082\u8868\u793a\u3057\u307e\u3059\u3002\u7279\u306b\u5927\u304d\u306a\u30e1\u30e2\u30ea\u30b5\u30f3\u30d7\u30eb\u3067\u306f\u3001\u8907\u6570\u306eKDBG\u69cb\u9020\u4f53\u306e\u30a2\u30c9\u30ec\u30b9\u304c\u793a\u3055\u308c\u308b\u304b\u3082\u3057\u308c\u307e\u305b\u3093\u3002\u540c\u3058\u3088\u3046\u306b\u8907\u6570\u306e\u30d7\u30ed\u30bb\u30c3\u30b5\u3092\u6301\u3063\u305f\u30b7\u30b9\u30c6\u30e0\u306e\u5834\u5408\u3001\u305d\u308c\u305e\u308c\u306bKPCR\u30a2\u30c9\u30ec\u30b9\u3068CPU\u756a\u53f7\u304c\u8868\u793a\u3055\u308c\u307e\u3059\u3002\n\n>Plugins automatically scan for the KPCR and KDBG values when they need them. However, you can specify the values directly for any plugin by providing --kpcr=ADDRESS or --kdbg=ADDRESS. By supplying the profile and KDBG (or failing that KPCR) to other Volatility commands, you'll get the most accurate and fastest results possible.\n\n\nvolatility\u306e\u30d7\u30e9\u30b0\u30a4\u30f3\u306f\u5fc5\u8981\u306b\u5fdc\u3058\u3066\u81ea\u52d5\u7684\u306bKPCR\u3068KDBG\u306e\u5024\u3092\u30b9\u30ad\u30e3\u30f3\u3057\u307e\u3059\u304c\u3001--kpcr=ADDRESS\u3068--kgbg=ADDRESS\u3068\u3044\u3046\u30d1\u30e9\u30e1\u30fc\u30bf\u3067\u660e\u793a\u7684\u306b\u6307\u5b9a\u3059\u308b\u3053\u3068\u3082\u3067\u304d\u307e\u3059\u3002\u30d7\u30ed\u30d5\u30a1\u30a4\u30eb\u3068KDBG\u3092\u30b3\u30de\u30f3\u30c9\u306b\u4e0e\u3048\u308b\u3053\u3068\u306b\u3088\u3063\u3066\u3001\u6700\u3082\u6b63\u78ba\u306a\u7d50\u679c\u3092\u9ad8\u901f\u306b\u5f97\u308b\u3053\u3068\u304c\u3067\u304d\u307e\u3059\u3002\n\n>Note: The imageinfo plugin will not work on hibernation files unless the correct profile is given in advance. This is because important structure definitions vary between different operating systems.\n\nNote: \u30cf\u30a4\u30d0\u30cd\u30fc\u30b7\u30e7\u30f3\u30d5\u30a1\u30a4\u30eb\u306b\u5bfe\u3057\u3066\u306f\u6b63\u3057\u3044\u30d7\u30ed\u30d5\u30a1\u30a4\u30eb\u3092\u6307\u5b9a\u3057\u306a\u3044\u3068imageinfo\u306f\u6a5f\u80fd\u3057\u307e\u305b\u3093\u3002\u3053\u308c\u306fOS\u9593\u3067\u91cd\u8981\u306a\u69cb\u9020\u4f53\u306e\u5b9a\u7fa9\u304c\u7570\u306a\u308b\u305f\u3081\u3067\u3059\u3002\n\n## kdbgscan\n\n>As opposed to imageinfo which simply provides profile suggestions, kdbgscan is designed to positively identify the correct profile and the correct KDBG address (if there happen to be multiple). This plugin scans for the KDBGHeader signatures linked to Volatility profiles and applies sanity checks to reduce false positives. The verbosity of the output and number of sanity checks that can be performed depends on whether Volatility can find a DTB, so if you already know the correct profile (or if you have a profile suggestion from imageinfo), then make sure you use it.\n\n\u5358\u7d14\u306b\u30d7\u30ed\u30d5\u30a1\u30a4\u30eb\u3092\u793a\u5506\u3059\u308bimageinfo\u3068\u306f\u9055\u3044\u3001kdbgscan\u306f\u6b63\u78ba\u306a\u30d7\u30ed\u30d5\u30a1\u30a4\u30eb\u3068KDBG\u30a2\u30c9\u30ec\u30b9(\u8907\u6570\u5b58\u5728\u3059\u308c\u3070)\u3092\u8b58\u5225\u3059\u308b\u3088\u3046\u306b\u30c7\u30b6\u30a4\u30f3\u3055\u308c\u3066\u3044\u307e\u3059\u3002\u3053\u306e\u30d7\u30e9\u30b0\u30a4\u30f3\u306f\u3001\u30d7\u30ed\u30d5\u30a1\u30a4\u30eb\u306b\u5bfe\u5fdc\u3057\u305fKDBGHeader\u30b7\u30b0\u30cb\u30c1\u30e3\u3092\u30b9\u30ad\u30e3\u30f3\u3057\u3001\u8aa4\u691c\u77e5\u3092\u4f4e\u4e0b\u3055\u305b\u308b\u305f\u3081\u306e\u30c1\u30a7\u30c3\u30af\u3092\u884c\u3044\u307e\u3059\u3002\u51fa\u529b\u306e\u8a73\u7d30\u3055\u3068\u5b9f\u884c\u53ef\u80fd\u306a\u30c1\u30a7\u30c3\u30af\u6570\u306f\u3001Volatility\u304cDTB\u3092\u898b\u3064\u3051\u3089\u308c\u308b\u304b\u306b\u3088\u308a\u307e\u3059\u3002\u305d\u306e\u305f\u3081\u3001\u3059\u3067\u306b\u6b63\u78ba\u306a\u30d7\u30ed\u30d5\u30a1\u30a4\u30eb\u3092\u77e5\u3063\u3066\u3044\u308b\u5834\u5408(\u307e\u305f\u306fimageinfo\u3067\u793a\u5506\u3055\u308c\u305f\u5834\u5408)\u3001\u305d\u308c\u3092\u5229\u7528\u3059\u308b\u3079\u304d\u3067\u3059\u3002\n\n>Here's an example scenario of when this plugin can be useful. You have a memory sample that you believe to be Windows 2003 SP2 x64, but pslist doesn't show any processes. The pslist plugin relies on finding the process list head which is pointed to by KDBG. However, the plugin takes the first KDBG found in the memory sample, which is not always the best one. You may run into this problem if a KDBG with an invalid PsActiveProcessHead pointer is found earlier in a sample (i.e. at a lower physical offset) than the valid KDBG.\n\n\u3053\u306e\u30d7\u30e9\u30b0\u30a4\u30f3\u304c\u6709\u7528\u306a\u306e\u306f\u3001\u3053\u3093\u306a\u5834\u5408\u3067\u3059\u3002Windows 2003 SP2 x64\u306e\u3082\u306e\u3067\u3042\u308b\u3068\u8003\u3048\u3066\u3044\u308b\u30a4\u30e1\u30fc\u30b8\u30b5\u30f3\u30d7\u30eb\u304c\u3042\u308b\u304c\u3001pslist\u30b3\u30de\u30f3\u30c9\u306f\u30d7\u30ed\u30bb\u30b9\u3092\u8868\u793a\u3057\u3066\u304f\u308c\u307e\u305b\u3093\u3002pslist\u306fKDBG\u304b\u3089\u793a\u3055\u308c\u308b\u30d7\u30ed\u30bb\u30b9\u30ea\u30b9\u30c8\u30d8\u30c3\u30c9\u3092\u5229\u7528\u3057\u3066\u3044\u307e\u3059\u304c\u3001pslist\u306f\u5fc5\u305a\u3057\u3082\u3075\u3055\u308f\u3057\u3044\u3068\u306f\u3044\u3048\u306a\u3044\u30e1\u30e2\u30ea\u5185\u3067\u521d\u3081\u306b\u898b\u3064\u304b\u3063\u305fKDBG\u3092\u5229\u7528\u3057\u307e\u3059\u3002\u4e0d\u6b63\u306aPsActiveProcessHead\u30dd\u30a4\u30f3\u30bf\u3092\u6301\u3064KDBG\u304c\u3001(\u4f4e\u3044\u7269\u7406\u30a2\u30c9\u30ec\u30b9\u306b\u4f4d\u7f6e\u3057\u3066\u3044\u308b\u306a\u3069\u306e\u7406\u7531\u3067)\u6b63\u3057\u3044KDBG\u3088\u308a\u5148\u306b\u898b\u3064\u304b\u3063\u305f\u5834\u5408\u306b\u3053\u3046\u3044\u3063\u305f\u554f\u984c\u306b\u906d\u9047\u3059\u308b\u304b\u3082\u3057\u308c\u307e\u305b\u3093\u3002\n\n>Notice below how kdbgscan picks up two KDBG structures: an invalid one (with 0 processes and 0 modules) is found first at 0xf80001172cb0 and a valid one (with 37 processes and 116 modules) is found next at 0xf80001175cf0. In order to \"fix\" pslist for this sample, you would simply need to supply the --kdbg=0xf80001175cf0 to the plist plugin.\n\n\u4e0b\u8a18\u306e\u4f8b\u3067\u306f\u3001kdbgscan\u304c2\u3064\u306eKDBG\u3092\u898b\u3064\u3051\u3066\u3044\u308b\u3053\u3068\u306b\u6ce8\u76ee\u3057\u3066\u304f\u3060\u3055\u3044\u3002\u6b63\u3057\u304f\u306a\u3044\u65b9\u304c\u5148\u306b0xf80001172cb0\u3067\u898b\u3064\u304b\u3063\u3066\u3044\u3066\u3001(37\u30d7\u30ed\u30bb\u30b9\u3068116\u30e2\u30b8\u30e5\u30fc\u30eb\u306b\u5bfe\u3059\u308b)\u6b63\u3057\u3044\u65b9\u304c\u5f8c\u304b\u30890xf80001175cf0\u3067\u898b\u3064\u304b\u3063\u3066\u3044\u307e\u3059\u3002\u3053\u306e\u30b5\u30f3\u30d7\u30eb\u3067\u306f\u3001pslist\u30d7\u30e9\u30b0\u30a4\u30f3\u306b\u5bfe\u3057\u3066--kdbg=0xf80001175cf0\u3068\u6307\u5b9a\u3059\u308c\u3070\u3001pslist\u306f\u6b63\u3057\u304f\u52d5\u4f5c\u3057\u307e\u3059\u3002\n\n```\n$ python vol.py -f Win2K3SP2x64-6f1bedec.vmem --profile=Win2003SP2x64 kdbgscan\nVolatility Foundation Volatility Framework 2.4\n**************************************************\nInstantiating KDBG using: Kernel AS Win2003SP2x64 (5.2.3791 64bit)\nOffset (V)                    : 0xf80001172cb0\nOffset (P)                    : 0x1172cb0\nKDBG owner tag check          : True\nProfile suggestion (KDBGHeader): Win2003SP2x64\nVersion64                     : 0xf80001172c70 (Major: 15, Minor: 3790)\nService Pack (CmNtCSDVersion) : 0\nBuild string (NtBuildLab)     : T?\nPsActiveProcessHead           : 0xfffff800011947f0 (0 processes)\nPsLoadedModuleList            : 0xfffff80001197ac0 (0 modules)\nKernelBase                    : 0xfffff80001000000 (Matches MZ: True)\nMajor (OptionalHeader)        : 5\nMinor (OptionalHeader)        : 2\n\n**************************************************\nInstantiating KDBG using: Kernel AS Win2003SP2x64 (5.2.3791 64bit)\nOffset (V)                    : 0xf80001175cf0\nOffset (P)                    : 0x1175cf0\nKDBG owner tag check          : True\nProfile suggestion (KDBGHeader): Win2003SP2x64\nVersion64                     : 0xf80001175cb0 (Major: 15, Minor: 3790)\nService Pack (CmNtCSDVersion) : 2\nBuild string (NtBuildLab)     : 3790.srv03_sp2_rtm.070216-1710\nPsActiveProcessHead           : 0xfffff800011977f0 (37 processes)\nPsLoadedModuleList            : 0xfffff8000119aae0 (116 modules)\nKernelBase                    : 0xfffff80001000000 (Matches MZ: True)\nMajor (OptionalHeader)        : 5\nMinor (OptionalHeader)        : 2\nKPCR                          : 0xfffff80001177000 (CPU 0)\n```\n>For more information on how KDBG structures are identified read Finding Kernel Global Variables in Windows and Identifying Memory Images\n\nKDBG\u69cb\u9020\u4f53\u3092\u8b58\u5225\u3059\u308b\u305f\u3081\u306e\u8a73\u3057\u3044\u60c5\u5831\u3092\u77e5\u308b\u305f\u3081\u306b\u306f\u3001\"inding Kernel Global Variables in Windows\"\u3068\"Identifying Memory Images\"\u3092\u53c2\u7167\u3057\u3066\u304f\u3060\u3055\u3044\u3002\n\n## kpcrscan\n\n>Use this command to scan for potential KPCR structures by checking for the self-referencing members as described by Finding Object Roots in Vista. On a multi-core system, each processor has its own KPCR. Therefore, you'll see details for each processor, including IDT and GDT address; current, idle, and next threads; CPU number, vendor & speed; and CR3 value.\n\nkpcrscan\u30b3\u30de\u30f3\u30c9\u3067\u3001\"Finding Object Roots in Vista\"\u3067\u8aac\u660e\u3055\u308c\u3066\u3044\u308b\u3088\u3046\u306b\u3001\u81ea\u5df1\u53c2\u7167\u3092\u30c1\u30a7\u30c3\u30af\u3059\u308b\u3053\u3068\u306b\u3088\u308a\u3001KPCR\u69cb\u9020\u4f53\u3092\u63a2\u3059\u3053\u3068\u304c\u3067\u304d\u307e\u3059\u3002\u8907\u6570\u306eCPU\u30b3\u30a2\u3092\u6301\u3064\u30b7\u30b9\u30c6\u30e0\u3067\u306f\u3001\u305d\u308c\u305e\u308c\u306e\u30d7\u30ed\u30bb\u30c3\u30b5\u304cKPCR\u3092\u6301\u3061\u307e\u3059\u3002IDT\u3068GDT\u30a2\u30c9\u30ec\u30b9\u3092\u542b\u3080\u3001\u73fe\u5728\uff0f\u30a2\u30a4\u30c9\u30eb\uff0f\u6b21\u306e\u30b9\u30ec\u30c3\u30c9\u3001CPU\u756a\u53f7\u3001\u30d9\u30f3\u30c0\u30fc\u3001\u30b9\u30d4\u30fc\u30c9\u3001CR3\u306e\u5024\u306a\u3069\u3001\u305d\u308c\u305e\u308c\u306e\u30d7\u30ed\u30bb\u30c3\u30b5\u306e\u8a73\u7d30\u3092\u78ba\u8a8d\u3067\u304d\u307e\u3059\u3002\n\n```\n$ python vol.py -f dang_win7_x64.raw --profile=Win7SP1x64 kpcrscan\nVolatility Foundation Volatility Framework 2.4\n**************************************************\nOffset (V)                    : 0xf800029ead00\nOffset (P)                    : 0x29ead00\nKdVersionBlock                : 0x0\nIDT                           : 0xfffff80000b95080\nGDT                           : 0xfffff80000b95000\nCurrentThread                 : 0xfffffa800cf694d0 TID 2148 (kd.exe:2964)\nIdleThread                    : 0xfffff800029f8c40 TID 0 (Idle:0)\nDetails                       : CPU 0 (GenuineIntel @ 2128 MHz)\nCR3/DTB                       : 0x1dcec000\n**************************************************\nOffset (V)                    : 0xf880009e7000\nOffset (P)                    : 0x4d9e000\nKdVersionBlock                : 0x0\nIDT                           : 0xfffff880009f2540\nGDT                           : 0xfffff880009f24c0\nCurrentThread                 : 0xfffffa800cf694d0 TID 2148 (kd.exe:2964)\nIdleThread                    : 0xfffff880009f1f40 TID 0 (Idle:0)\nDetails                       : CPU 1 (GenuineIntel @ 2220 MHz)\nCR3/DTB                       : 0x1dcec000\n```\n\n>If the KdVersionBlock is not null, then it may be possible to find the machine's KDBG address via the KPCR. In fact, the backup method of finding KDBG used by plugins such as pslist is to leverage kpcrscan and then call the KPCR.get_kdbg() API function.\n\nKdVersionBlock\u304cnull\u3067\u306f\u306a\u3044\u5834\u5408\u3001KPCR\u304b\u3089KDBG\u3092\u898b\u3064\u3051\u308b\u3053\u3068\u304c\u3067\u304d\u308b\u304b\u3082\u3057\u308c\u307e\u305b\u3093\u3002pslist\u306a\u3069\u306e\u30d7\u30e9\u30b0\u30a4\u30f3\u306f\u3001KDBG\u3092\u898b\u3064\u3051\u308b\u305f\u3081\u306e\u526f\u6b21\u7684\u306a\u65b9\u6cd5\u3068\u3057\u3066\u3001kpcrscan\u3092\u4f7f\u3044\u3001KPCR.get_kdbg() API\u3092\u5229\u7528\u3057\u3066\u3044\u307e\u3059\u3002\n\n# Processes and DLLs\n\n## pslist\n\n>To list the processes of a system, use the pslist command. This walks the doubly-linked list pointed to by PsActiveProcessHead and shows the offset, process name, process ID, the parent process ID, number of threads, number of handles, and date/time when the process started and exited. As of 2.1 it also shows the Session ID and if the process is a Wow64 process (it uses a 32 bit address space on a 64 bit kernel).\n\npslist\u30b3\u30de\u30f3\u30c9\u3067\u30d7\u30ed\u30bb\u30b9\u3092\u5217\u6319\u3057\u307e\u3059\u3002PsActiveProcessHead\u3067\u793a\u3055\u308c\u308b\u30c0\u30d6\u30eb\u30ea\u30f3\u30af\u30ea\u30b9\u30c8\u3092\u8fbf\u3063\u3066\u3001\u30aa\u30d5\u30bb\u30c3\u30c8\u3001\u30d7\u30ed\u30bb\u30b9\u540d\u3001\u30d7\u30ed\u30bb\u30b9ID\u3001\u89aa\u30d7\u30ed\u30bb\u30b9ID\u3001\u30b9\u30ec\u30c3\u30c9\u6570\u3001\u30cf\u30f3\u30c9\u30eb\u6570\u3001\u958b\u59cb\u30fb\u7d42\u4e86\u6642\u523b\u3092\u8868\u793a\u3057\u307e\u3059\u3002\u30d0\u30fc\u30b8\u30e7\u30f32.1\u304b\u3089\u3001\u30bb\u30c3\u30b7\u30e7\u30f3ID\u3001WOW64\u30d7\u30ed\u30bb\u30b9\u304b\u3069\u3046\u304b\u3082\u8868\u793a\u3057\u307e\u3059(WOW64\u30d7\u30ed\u30bb\u30b9\u306f\u300164bit\u30b7\u30b9\u30c6\u30e0\u4e0a\u306732bit\u30a2\u30c9\u30ec\u30b9\u7a7a\u9593\u3092\u4f7f\u7528\u3057\u307e\u3059)\u3002\n\n>This plugin does not detect hidden or unlinked processes (but psscan can do that).\n\n\u3053\u306e\u30d7\u30e9\u30b0\u30a4\u30f3\u3067\u306f\u3001\u96a0\u3055\u308c\u305f\u30d7\u30ed\u30bb\u30b9\u3084\u30ea\u30f3\u30af\u30ea\u30b9\u30c8\u3092\u306f\u305a\u3055\u308c\u305f\u30d7\u30ed\u30bb\u30b9\u306f\u8a8d\u8b58\u3067\u304d\u307e\u305b\u3093\u3002(psscan\u306f\u53ef\u80fd)\n\n>If you see processes with 0 threads, 0 handles, and/or a non-empty exit time, the process may not actually still be active. For more information, see The Missing Active in PsActiveProcessHead. Below, you'll notice regsvr32.exe has terminated even though its still in the \"active\" list.\n\n\u30b9\u30ec\u30c3\u30c9\u65700\u3001\u30cf\u30f3\u30c9\u30eb\u65700\u3067\u3001\u7d42\u4e86\u6642\u523b\u304c\u8868\u793a\u3055\u308c\u308b/\u3055\u308c\u306a\u3044\u5834\u5408\u3001\u3082\u3046\u30a2\u30af\u30c6\u30a3\u30d6\u306a\u30d7\u30ed\u30bb\u30b9\u3067\u306f\u306a\u3044\u304b\u3082\u3057\u308c\u307e\u305b\u3093\u3002\u8a73\u3057\u304f\u306f\u3001\"The Missing Active in PsActiveProcessHead\"\u3092\u53c2\u7167\u3002\u4ee5\u4e0b\u306e\u4f8b\u3067\u306f\u3001regsvr32.exe\u304c\u30a2\u30af\u30c6\u30a3\u30d6\u30ea\u30b9\u30c8\u306b\u6319\u304c\u3063\u3066\u3044\u3066\u3082\u3001\u3059\u3067\u306b\u7d42\u4e86\u3057\u3066\u3044\u308b\u3053\u3068\u304c\u308f\u304b\u308a\u307e\u3059\u3002\n\n>Also note the two processes System and smss.exe will not have a Session ID, because System starts before sessions are established and smss.exe is the session manager itself.\n\nSysem\u306f\u30bb\u30c3\u30b7\u30e7\u30f3\u78ba\u7acb\u524d\u306b\u958b\u59cb\u3057\u3001smss.exe\u306f\u30bb\u30c3\u30b7\u30e7\u30f3\u30de\u30cd\u30fc\u30b8\u30e3\u305d\u306e\u3082\u306e\u3067\u3042\u308b\u305f\u3081\u3001System\u3068smss.exe\u306e2\u3064\u306e\u30d7\u30ed\u30bb\u30b9\u306f\u30bb\u30c3\u30b7\u30e7\u30f3ID\u3092\u6301\u3063\u3066\u3044\u307e\u305b\u3093\u3002\n\n```\n$ python vol.py -f ~/Desktop/win7_trial_64bit.raw --profile=Win7SP0x64 pslist\nVolatility Foundation Volatility Framework 2.4\nOffset(V)          Name                    PID   PPID   Thds     Hnds   Sess  Wow64 Start                Exit\n------------------ -------------------- ------ ------ ------ -------- ------ ------ -------------------- --------------------\n0xfffffa80004b09e0 System                    4      0     78      489 ------      0 2012-02-22 19:58:20\n0xfffffa8000ce97f0 smss.exe                208      4      2       29 ------      0 2012-02-22 19:58:20\n0xfffffa8000c006c0 csrss.exe               296    288      9      385      0      0 2012-02-22 19:58:24\n0xfffffa8000c92300 wininit.exe             332    288      3       74      0      0 2012-02-22 19:58:30\n0xfffffa8000c06b30 csrss.exe               344    324      7      252      1      0 2012-02-22 19:58:30\n0xfffffa8000c80b30 winlogon.exe            372    324      5      136      1      0 2012-02-22 19:58:31\n0xfffffa8000c5eb30 services.exe            428    332      6      193      0      0 2012-02-22 19:58:32\n0xfffffa80011c5700 lsass.exe               444    332      6      557      0      0 2012-02-22 19:58:32\n0xfffffa8000ea31b0 lsm.exe                 452    332     10      133      0      0 2012-02-22 19:58:32\n0xfffffa8001296b30 svchost.exe             568    428     10      352      0      0 2012-02-22 19:58:34\n0xfffffa80012c3620 svchost.exe             628    428      6      247      0      0 2012-02-22 19:58:34\n0xfffffa8001325950 sppsvc.exe              816    428      5      154      0      0 2012-02-22 19:58:41\n0xfffffa80007b7960 svchost.exe             856    428     16      404      0      0 2012-02-22 19:58:43\n0xfffffa80007bb750 svchost.exe             880    428     34     1118      0      0 2012-02-22 19:58:43\n0xfffffa80007d09e0 svchost.exe             916    428     19      443      0      0 2012-02-22 19:58:43\n0xfffffa8000c64840 svchost.exe             348    428     14      338      0      0 2012-02-22 20:02:07\n0xfffffa8000c09630 svchost.exe             504    428     16      496      0      0 2012-02-22 20:02:07\n0xfffffa8000e86690 spoolsv.exe            1076    428     12      271      0      0 2012-02-22 20:02:10\n0xfffffa8000518b30 svchost.exe            1104    428     18      307      0      0 2012-02-22 20:02:10\n0xfffffa800094d960 wlms.exe               1264    428      4       43      0      0 2012-02-22 20:02:11\n0xfffffa8000995b30 svchost.exe            1736    428     12      200      0      0 2012-02-22 20:02:25\n0xfffffa8000aa0b30 SearchIndexer.         1800    428     12      757      0      0 2012-02-22 20:02:26\n0xfffffa8000aea630 taskhost.exe           1144    428      7      189      1      0 2012-02-22 20:02:41\n0xfffffa8000eafb30 dwm.exe                1476    856      3       71      1      0 2012-02-22 20:02:41\n0xfffffa80008f3420 explorer.exe           1652    840     21      760      1      0 2012-02-22 20:02:42\n0xfffffa8000c9a630 regsvr32.exe           1180   1652      0 --------      1      0 2012-02-22 20:03:05  2012-02-22 20:03:08\n0xfffffa8000a03b30 rundll32.exe           2016    568      3       67      1      0 2012-02-22 20:03:16\n0xfffffa8000a4f630 svchost.exe            1432    428     12      350      0      0 2012-02-22 20:04:14\n0xfffffa8000999780 iexplore.exe           1892   1652     19      688      1      1 2012-02-22 11:26:12\n0xfffffa80010c9060 iexplore.exe           2820   1892     23      733      1      1 2012-02-22 11:26:15\n0xfffffa8001016060 DumpIt.exe             2860   1652      2       42      1      1 2012-02-22 11:28:59\n0xfffffa8000acab30 conhost.exe            2236    344      2       51      1      0 2012-02-22 11:28:59\n```\n\n>By default, pslist shows virtual offsets for the EPROCESS but the physical offset can be obtained with the -P switch:\n\n\u30c7\u30d5\u30a9\u30eb\u30c8\u3067\u306f\u3001pslist\u306fEPROCESS\u306e\u4eee\u60f3\u30aa\u30d5\u30bb\u30c3\u30c8\u3092\u8868\u793a\u3057\u307e\u3059\u304c\u3001-P\u30aa\u30d7\u30b7\u30e7\u30f3\u306b\u3088\u3063\u3066\u7269\u7406\u30aa\u30d5\u30bb\u30c3\u30c8\u3092\u8868\u793a\u3055\u305b\u308b\u3053\u3068\u304c\u3067\u304d\u307e\u3059\u3002\n\n```\n$ python vol.py -f ~/Desktop/win7_trial_64bit.raw --profile=Win7SP0x64 pslist -P\nVolatility Foundation Volatility Framework 2.4\nOffset(P)          Name                    PID   PPID   Thds     Hnds   Sess  Wow64 Start                Exit\n------------------ -------------------- ------ ------ ------ -------- ------ ------ -------------------- --------------------\n0x0000000017fef9e0 System                    4      0     78      489 ------      0 2012-02-22 19:58:20\n0x00000000176e97f0 smss.exe                208      4      2       29 ------      0 2012-02-22 19:58:20\n0x00000000176006c0 csrss.exe               296    288      9      385      0      0 2012-02-22 19:58:24\n0x0000000017692300 wininit.exe             332    288      3       74      0      0 2012-02-22 19:58:30\n0x0000000017606b30 csrss.exe               344    324      7      252      1      0 2012-02-22 19:58:30\n...\n```\n\n## pstree\n\n>To view the process listing in tree form, use the pstree command. This enumerates processes using the same technique as pslist, so it will also not show hidden or unlinked processes. Child process are indicated using indention and periods.\n\npstree\u30b3\u30de\u30f3\u30c9\u306f\u3001\u30c4\u30ea\u30fc\u5f62\u5f0f\u306e\u30d7\u30ed\u30bb\u30b9\u30ea\u30b9\u30c8\u3092\u8868\u793a\u3057\u307e\u3059\u3002pslist\u3068\u540c\u3058\u4ed5\u7d44\u307f\u3067\u30d7\u30ed\u30bb\u30b9\u3092\u5217\u6319\u3059\u308b\u305f\u3081\u3001\u96a0\u3055\u308c\u305f\u30d7\u30ed\u30bb\u30b9\u3084\u30ea\u30f3\u30af\u304c\u5916\u3055\u308c\u305f\u30d7\u30ed\u30bb\u30b9\u306f\u8868\u793a\u3055\u308c\u307e\u305b\u3093\u3002\u5b50\u30d7\u30ed\u30bb\u30b9\u306f\u3001\u30a4\u30f3\u30c7\u30f3\u30c8\u3068\u30d4\u30ea\u30aa\u30c9\u3067\u793a\u3055\u308c\u307e\u3059\u3002\n\n```\n$ python vol.py -f ~/Desktop/win7_trial_64bit.raw --profile=Win7SP0x64 pstree\nVolatility Foundation Volatility Framework 2.4\nName                                                  Pid   PPid   Thds   Hnds Time\n-------------------------------------------------- ------ ------ ------ ------ --------------------\n 0xfffffa80004b09e0:System                              4      0     78    489 2012-02-22 19:58:20\n. 0xfffffa8000ce97f0:smss.exe                         208      4      2     29 2012-02-22 19:58:20\n 0xfffffa8000c006c0:csrss.exe                         296    288      9    385 2012-02-22 19:58:24\n 0xfffffa8000c92300:wininit.exe                       332    288      3     74 2012-02-22 19:58:30\n. 0xfffffa8000c5eb30:services.exe                     428    332      6    193 2012-02-22 19:58:32\n.. 0xfffffa8000aa0b30:SearchIndexer.                 1800    428     12    757 2012-02-22 20:02:26\n.. 0xfffffa80007d09e0:svchost.exe                     916    428     19    443 2012-02-22 19:58:43\n.. 0xfffffa8000a4f630:svchost.exe                    1432    428     12    350 2012-02-22 20:04:14\n.. 0xfffffa800094d960:wlms.exe                       1264    428      4     43 2012-02-22 20:02:11\n.. 0xfffffa8001325950:sppsvc.exe                      816    428      5    154 2012-02-22 19:58:41\n.. 0xfffffa8000e86690:spoolsv.exe                    1076    428     12    271 2012-02-22 20:02:10\n.. 0xfffffa8001296b30:svchost.exe                     568    428     10    352 2012-02-22 19:58:34\n... 0xfffffa8000a03b30:rundll32.exe                  2016    568      3     67 2012-02-22 20:03:16\n...\n```\n## psscan\n\n>To enumerate processes using pool tag scanning (POOL_HEADER), use the psscan command. This can find processes that previously terminated (inactive) and processes that have been hidden or unlinked by a rootkit. The downside is that rootkits can still hide by overwriting the pool tag values (though not commonly seen in the wild).\n\npsscan\u30b3\u30de\u30f3\u30c9\u306f\u3001\u30d7\u30fc\u30eb\u30bf\u30b0(POOL_HEADER)\u3092\u30b9\u30ad\u30e3\u30f3\u3059\u308b\u3053\u3068\u306b\u3088\u308a\u30d7\u30ed\u30bb\u30b9\u3092\u5217\u6319\u3059\u308b\u3002\u65e2\u306b\u505c\u6b62\u3057\u305f(\u30a2\u30af\u30c6\u30a3\u30d6\u3067\u306f\u306a\u3044)\u30d7\u30ed\u30bb\u30b9\u3001rootkit\u306b\u3088\u3063\u3066\u96a0\u3055\u308c\u305f\u30d7\u30ed\u30bb\u30b9\u3084\u30ea\u30f3\u30af\u3092\u5916\u3055\u308c\u305f\u30d7\u30ed\u30bb\u30b9\u3082\u898b\u3064\u3051\u51fa\u3059\u3053\u3068\u304c\u3067\u304d\u308b\u3002rootkit\u306f\u30d7\u30fc\u30eb\u30bf\u30b0\u3092\u4e0a\u66f8\u304d\u3059\u308b\u3053\u3068\u3082\u3067\u304d\u308b\u3053\u3068\u306f\u554f\u984c\u3067\u3059(\u73fe\u5b9f\u306b\u306f\u3042\u307e\u308a\u898b\u3089\u308c\u307e\u305b\u3093)\u3002\n\n```\n$ python vol.py --profile=Win7SP0x86 -f win7.dmp psscan\nVolatility Foundation Volatility Framework 2.0\n Offset     Name             PID    PPID   PDB        Time created             Time exited\n---------- ---------------- ------ ------ ---------- ------------------------ ------------------------\n0x3e025ba8 svchost.exe        1116    508 0x3ecf1220 2010-06-16 15:25:25\n0x3e04f070 svchost.exe        1152    508 0x3ecf1340 2010-06-16 15:27:40\n0x3e144c08 dwm.exe            1540    832 0x3ecf12e0 2010-06-16 15:26:58\n0x3e145c18 TPAutoConnSvc.     1900    508 0x3ecf1360 2010-06-16 15:25:41\n0x3e3393f8 lsass.exe           516    392 0x3ecf10e0 2010-06-16 15:25:18\n0x3e35b8f8 svchost.exe         628    508 0x3ecf1120 2010-06-16 15:25:19\n0x3e383770 svchost.exe         832    508 0x3ecf11a0 2010-06-16 15:25:20\n0x3e3949d0 svchost.exe         740    508 0x3ecf1160 2010-06-16 15:25:20\n0x3e3a5100 svchost.exe         872    508 0x3ecf11c0 2010-06-16 15:25:20\n0x3e3f64e8 svchost.exe         992    508 0x3ecf1200 2010-06-16 15:25:24\n0x3e45a530 wininit.exe         392    316 0x3ecf10a0 2010-06-16 15:25:15\n0x3e45d928 svchost.exe        1304    508 0x3ecf1260 2010-06-16 15:25:28\n0x3e45f530 csrss.exe           400    384 0x3ecf1040 2010-06-16 15:25:15\n0x3e4d89c8 vmtoolsd.exe       1436    508 0x3ecf1280 2010-06-16 15:25:30\n0x3e4db030 spoolsv.exe        1268    508 0x3ecf1240 2010-06-16 15:25:28\n0x3e50b318 services.exe        508    392 0x3ecf1080 2010-06-16 15:25:18\n0x3e7f3d40 csrss.exe           352    316 0x3ecf1060 2010-06-16 15:25:12\n0x3e7f5bc0 winlogon.exe        464    384 0x3ecf10c0 2010-06-16 15:25:18\n0x3eac6030 SearchProtocol     2448   1168 0x3ecf15c0 2010-06-16 23:30:52      2010-06-16 23:33:14\n0x3eb10030 SearchFilterHo     1812   1168 0x3ecf1480 2010-06-16 23:31:02      2010-06-16 23:33:14\n[snip]\n```\n\n>If a process has previously terminated, the Time exited field will show the exit time. If you want to investigate a hidden process (such as displaying its DLLs), then you'll need physical offset of the _EPROCESS object, which is shown in the far left column. Almost all process-related plugins take a --OFFSET parameter so that you can work with hidden processes.\n\n\u30d7\u30ed\u30bb\u30b9\u304c\u65e2\u306b\u7d42\u4e86\u3057\u3066\u3044\u308b\u5834\u5408\u3001Time exited\u30d5\u30a3\u30fc\u30eb\u30c9\u304c\u7d42\u4e86\u6642\u523b\u3092\u8868\u3057\u307e\u3059\u3002(DLL\u306e\u3088\u3046\u306a)\u96a0\u3055\u308c\u305f\u30d7\u30ed\u30bb\u30b9\u3092\u8abf\u67fb\u3057\u305f\u3044\u306a\u3089\u3001\u5de6\u306e\u5217\u306b\u8868\u793a\u3055\u308c\u3066\u3044\u308bEPROCESS\u30aa\u30d6\u30b8\u30a7\u30af\u30c8\u306e\u7269\u7406\u30aa\u30d5\u30bb\u30c3\u30c8\u304c\u5fc5\u8981\u3067\u3059\u3002\u96a0\u3055\u308c\u305f\u30d7\u30ed\u30bb\u30b9\u3092\u8abf\u67fb\u3059\u308b\u305f\u3081\u306b\u3001\u307b\u3068\u3093\u3069\u306e\u30d7\u30ed\u30bb\u30b9\u95a2\u9023\u306e\u30d7\u30e9\u30b0\u30a4\u30f3\u306b\u306f--OFFSET\u30d1\u30e9\u30e1\u30fc\u30bf\u3092\u6307\u5b9a\u3059\u308b\u3053\u3068\u304c\u3067\u304d\u307e\u3059\u3002\n\n# psdispscan\n\n>This plugin is similar to psscan, except it enumerates processes by scanning for DISPATCHER_HEADER instead of pool tags. This gives you an alternate way to carve _EPROCESS objects in the event an attacker tried to hide by altering pool tags. This plugin is not well maintained and only supports XP x86. To use it, you must type --plugins=contrib/plugins on command-line.\n\n\u3053\u306e\u30d7\u30e9\u30b0\u30a4\u30f3\u306fpsscan\u3068\u4f3c\u3066\u3044\u307e\u3059\u304c\u3001\u30d7\u30fc\u30eb\u30bf\u30b0\u3067\u306f\u306a\u304fDISPATCHER_HEADER\u3092\u30b9\u30ad\u30e3\u30f3\u3059\u308b\u3053\u3068\u306b\u3088\u3063\u3066\u30d7\u30ed\u30bb\u30b9\u3092\u5217\u6319\u3057\u307e\u3059\u3002\u653b\u6483\u8005\u304c\u30d7\u30fc\u30eb\u30bf\u30b0\u3092\u5909\u66f4\u3059\u308b\u3053\u3068\u306b\u3088\u3063\u3066\u96a0\u853d\u3059\u308b\u3088\u3046\u306a\u5834\u5408\u306b\u3001EPROCESS\u3092\u8abf\u67fb\u3059\u308b\u5225\u306e\u3084\u308a\u65b9\u3068\u306a\u308a\u307e\u3059\u3002\u3053\u306e\u30d7\u30e9\u30b0\u30a4\u30f3\u306f\u3042\u307e\u308a\u30e1\u30f3\u30c6\u30ca\u30f3\u30b9\u3055\u308c\u3066\u304a\u3089\u305a\u3001XP x86\u306e\u307f\u30b5\u30dd\u30fc\u30c8\u3055\u308c\u3066\u3044\u307e\u3059\u3002\u3053\u306e\u30d7\u30e9\u30b0\u30a4\u30f3\u3092\u4f7f\u7528\u3059\u308b\u305f\u3081\u306b\u306f\u3001--plugins=contrib/plugins\u3068\u3044\u3046\u30aa\u30d7\u30b7\u30e7\u30f3\u3092\u6307\u5b9a\u3059\u308b\u5fc5\u8981\u304c\u3042\u308a\u307e\u3059\u3002\n\n## dlllist\n\n>To display a process's loaded DLLs, use the dlllist command. It walks the doubly-linked list of _LDR_DATA_TABLE_ENTRY structures which is pointed to by the PEB's InLoadOrderModuleList. DLLs are automatically added to this list when a process calls LoadLibrary (or some derivative such as LdrLoadDll) and they aren't removed until FreeLibrary is called and the reference count reaches zero. The load count column tells you if a DLL was statically loaded (i.e. as a result of being in the exe or another DLL's import table) or dynamically loaded.\n\ndlllist\u30b3\u30de\u30f3\u30c9\u3067\u3001\u30d7\u30ed\u30bb\u30b9\u304c\u30ed\u30fc\u30c9\u3057\u305fDLL\u3092\u8868\u793a\u3059\u308b\u3053\u3068\u304c\u3067\u304d\u308b\u3002PEB\u306eInLoadOrderModuleList\u3067\u793a\u3055\u308c\u308b_LDR_DATA_TABLE_ENTRY\u69cb\u9020\u4f53\u306e\u30c0\u30d6\u30eb\u30ea\u30f3\u30af\u30ea\u30b9\u30c8\u3092\u305f\u3069\u3063\u3066\u3044\u304f\u3002\u30d7\u30ed\u30bb\u30b9\u304cLoadLibrary\u3092\u30b3\u30fc\u30eb\u3057\u305f\u969b\u306b(\u307e\u305f\u306fLdrLoadDll\u306a\u3069\u306e\u6d3e\u751f\u306b\u3088\u3063\u3066)\u3053\u306e\u30ea\u30b9\u30c8\u306b\u8ffd\u52a0\u3055\u308c\u3001FreeLibrary\u304c\u547c\u3073\u51fa\u3055\u308c\u3066\u53c2\u7167\u6570\u304c0\u306b\u306a\u308b\u307e\u3067\u524a\u9664\u3055\u308c\u306a\u3044\u3002load count\u5217\u306f\u9759\u7684\u306b\u30ed\u30fc\u30c9(exe\u3082\u3057\u304f\u306f\u5225\u306eDLL\u306e\u30a4\u30f3\u30dd\u30fc\u30c8\u30c6\u30fc\u30d6\u30eb\u306b\u767b\u9332\u3055\u308c\u3066\u3044\u308b\u3053\u3068\u306b\u3088\u308a)\u3055\u308c\u305f\u304b\u52d5\u7684\u306b\u30ed\u30fc\u30c9\u3055\u308c\u305f\u304b\u3092\u793a\u3059\u3002\n\n```\n$ python vol.py -f ~/Desktop/win7_trial_64bit.raw --profile=Win7SP0x64 dlllist\n************************************************************************\nwininit.exe pid:    332\nCommand line : wininit.exe\n\nBase                             Size          LoadCount Path\n------------------ ------------------ ------------------ ----\n0x00000000ff530000            0x23000             0xffff C:\\Windows\\system32\\wininit.exe\n0x0000000076d40000           0x1ab000             0xffff C:\\Windows\\SYSTEM32\\ntdll.dll\n0x0000000076b20000           0x11f000             0xffff C:\\Windows\\system32\\kernel32.dll\n0x000007fefcd50000            0x6b000             0xffff C:\\Windows\\system32\\KERNELBASE.dll\n0x0000000076c40000            0xfa000             0xffff C:\\Windows\\system32\\USER32.dll\n0x000007fefd7c0000            0x67000             0xffff C:\\Windows\\system32\\GDI32.dll\n0x000007fefe190000             0xe000             0xffff C:\\Windows\\system32\\LPK.dll\n0x000007fefef80000            0xca000             0xffff C:\\Windows\\system32\\USP10.dll\n0x000007fefd860000            0x9f000             0xffff C:\\Windows\\system32\\msvcrt.dll\n[snip]\n```\n\n>To display the DLLs for a specific process instead of all processes, use the -p or --pid filter as shown below. Also, in the following output, notice we're analyzing a Wow64 process. Wow64 processes have a limited list of DLLs in the PEB lists, but that doesn't mean they're the only DLLs loaded in the process address space. Thus Volatility will remind you to use the ldrmodules instead for these processes.\n\n\u5168\u30d7\u30ed\u30bb\u30b9\u3067\u306f\u306a\u304f\u3001\u7279\u5b9a\u306e\u30d7\u30ed\u30bb\u30b9\u306eDLL\u3092\u8868\u793a\u3059\u308b\u5834\u5408\u3001\u4e0b\u306e\u4f8b\u306e\u3088\u3046\u306b-p\u304b--pid\u30d5\u30a3\u30eb\u30bf\u3092\u6307\u5b9a\u3057\u307e\u3059\u3002\u3053\u306e\u4f8b\u3067\u306f\u3001Wow64\u30d7\u30ed\u30bb\u30b9\u3092\u89e3\u6790\u3057\u3066\u3044\u307e\u3059\u3002Wow64\u30d7\u30ed\u30bb\u30b9\u306f\u3001PEB\u30ea\u30b9\u30c8\u306b\u9650\u3089\u308c\u305fDLL\u306e\u30ea\u30b9\u30c8\u3057\u304b\u6301\u3063\u3066\u3044\u307e\u305b\u3093\u304c\u3001\u305d\u308c\u3089\u3060\u3051\u304c\u30d7\u30ed\u30bb\u30b9\u306e\u30a2\u30c9\u30ec\u30b9\u7a7a\u9593\u306b\u30ed\u30fc\u30c9\u3055\u308c\u305fDLL\u3067\u306f\u3042\u308a\u307e\u305b\u3093\u3002\u305d\u3046\u3057\u305f\u30d7\u30ed\u30bb\u30b9\u306e\u305f\u3081\u306b\u3001ldrmodules\u3092\u4ee3\u308f\u308a\u306b\u5229\u7528\u3059\u308b\u3053\u3068\u304c\u3067\u304d\u307e\u3059\u3002\n\n```\n$ python vol.py -f ~/Desktop/win7_trial_64bit.raw --profile=Win7SP0x64 dlllist -p 1892\nVolatility Foundation Volatility Framework 2.4\n************************************************************************\niexplore.exe pid:   1892\nCommand line : \"C:\\Program Files (x86)\\Internet Explorer\\iexplore.exe\"\nNote: use ldrmodules for listing DLLs in Wow64 processes\n\nBase                             Size          LoadCount Path\n------------------ ------------------ ------------------ ----\n0x0000000000080000            0xa6000             0xffff C:\\Program Files (x86)\\Internet Explorer\\iexplore.exe\n0x0000000076d40000           0x1ab000             0xffff C:\\Windows\\SYSTEM32\\ntdll.dll\n0x00000000748d0000            0x3f000                0x3 C:\\Windows\\SYSTEM32\\wow64.dll\n0x0000000074870000            0x5c000                0x1 C:\\Windows\\SYSTEM32\\wow64win.dll\n0x0000000074940000             0x8000                0x1 C:\\Windows\\SYSTEM32\\wow64cpu.dll\n```\n\n>To display the DLLs for a process that is hidden or unlinked by a rootkit, first use the psscan to get the physical offset of the EPROCESS object and supply it with --offset=OFFSET. The plugin will \"bounce back\" and determine the virtual address of the EPROCESS and then acquire an address space in order to access the PEB.\n\n\u30eb\u30fc\u30c8\u30ad\u30c3\u30c8\u306b\u3088\u3063\u3066\u96a0\u853d\u3055\u308c\u305f\u308a\u30ea\u30f3\u30af\u3092\u5916\u3055\u308c\u305fDLL\u3092\u8868\u793a\u3059\u308b\u305f\u3081\u306b\u306f\u3001\u307e\u305apsscan\u3067EPROCESS\u306e\u7269\u7406\u30aa\u30d5\u30bb\u30c3\u30c8\u3092\u53d6\u5f97\u3057\u3066\u3001--offset=OFFSET\u30aa\u30d7\u30b7\u30e7\u30f3\u3067\u6307\u5b9a\u3057\u3066\u304f\u3060\u3055\u3044\u3002\u30d7\u30e9\u30b0\u30a4\u30f3\u306f\u3001\"bounce back\"\u3057\u3066\u3001EPROCESS\u306e\u4eee\u60f3\u30a2\u30c9\u30ec\u30b9\u3092\u6c7a\u5b9a\u3057\u3001PEB\u306b\u30a2\u30af\u30bb\u30b9\u3059\u308b\u305f\u3081\u306b\u30a2\u30c9\u30ec\u30b9\u7a7a\u9593\u3092\u53d6\u5f97\u3057\u307e\u3059\u3002\n\n```\n$ python vol.py -f ~/Desktop/win7_trial_64bit.raw --profile=Win7SP0x64 dlllist --offset=0x04a291a8\n```\n\n## dlldump\n\n>To extract a DLL from a process's memory space and dump it to disk for analysis, use the dlldump command. The syntax is nearly the same as what we've shown for dlllist above. You can:\n\ndlldump\u30b3\u30de\u30f3\u30c9\u3067\u3001\u89e3\u6790\u306e\u305f\u3081\u306b\u30d7\u30ed\u30bb\u30b9\u306e\u30e1\u30e2\u30ea\u7a7a\u9593\u304b\u3089DLL\u3092\u30c7\u30a3\u30b9\u30af\u306b\u30c0\u30f3\u30d7\u3059\u308b\u3053\u3068\u304c\u3067\u304d\u307e\u3059\u3002\u6307\u5b9a\u306e\u4ed5\u65b9\u306f\u3001\u4e0a\u306edlllist\u306e\u6307\u5b9a\u3068\u540c\u3058\u3067\u3059\u3002\u4ee5\u4e0b\u306e\u6307\u5b9a\u304c\u53ef\u80fd\u3067\u3059\u3002\n\n>* Dump all DLLs from all processes\n* Dump all DLLs from a specific process (with --pid=PID)\n* Dump all DLLs from a hidden/unlinked process (with --offset=OFFSET)\n* Dump a PE from anywhere in process memory (with --base=BASEADDR), this option is useful for extracting hidden DLLs\n* Dump one or more DLLs that match a regular expression (--regex=REGEX), case sensitive or not (--ignore-case)\n\n* \u5168\u30d7\u30ed\u30bb\u30b9\u304b\u3089\u5168DLL\u3092\u30c0\u30f3\u30d7\u3059\u308b\n* \u6307\u5b9a\u3057\u305f\u30d7\u30ed\u30bb\u30b9\u306e\u5168DLL\u3092\u30c0\u30f3\u30d7\u3059\u308b(--pid=PID)\n* \u96a0\u853d\u3084\u30ea\u30f3\u30af\u3092\u5916\u3055\u308c\u305f\u30d7\u30ed\u30bb\u30b9\u304b\u3089\u3059\u3079\u3066\u306eDLL\u3092\u30c0\u30f3\u30d7\u3059\u308b(--offset=OFFSET)\n* \u30d7\u30ed\u30bb\u30b9\u30e1\u30e2\u30ea\u306e\u3069\u3053\u304b\u304b\u3089PE\u5f62\u5f0f\u3067\u30c0\u30f3\u30d7\u3059\u308b(--base=BASEADDR)\u3002\u3053\u308c\u306f\u96a0\u3055\u308c\u305fDLL\u3092\u53d6\u5f97\u3059\u308b\u306e\u306b\u4fbf\u5229\u3067\u3059\u3002\n* \u6b63\u898f\u8868\u73fe\u306b\u30de\u30c3\u30c1\u3057\u305f(\u8907\u6570\u306e)DLL\u3092\u30c0\u30f3\u30d7\u3059\u308b(--regex=REGEX)\u3002\u5927\uff0f\u5c0f\u6587\u5b57\u3092\u533a\u5225\u3057\u306a\u3044(--ignore-case)\n\n>To specify an output directory, use --dump-dir=DIR or -d DIR.\n\n--dump-dir=DIR\u307e\u305f\u306f-d DIR\u30aa\u30d7\u30b7\u30e7\u30f3\u3067\u3001\u51fa\u529b\u30c7\u30a3\u30ec\u30af\u30c8\u30ea\u3092\u6307\u5b9a\u3057\u307e\u3059\u3002\n\n```\n$ python vol.py -f ~/Desktop/win7_trial_64bit.raw --profile=Win7SP0x64 dlldump -D dlls/\n...\nProcess(V)         Name                 Module Base        Module Name          Result\n------------------ -------------------- ------------------ -------------------- ------\n0xfffffa8000ce97f0 smss.exe             0x0000000047a90000 smss.exe             OK: module.208.176e97f0.47a90000.dll\n0xfffffa8000ce97f0 smss.exe             0x0000000076d40000                      Error: DllBase is paged\n0xfffffa8000c006c0 csrss.exe            0x0000000049700000 csrss.exe            OK: module.296.176006c0.49700000.dll\n0xfffffa8000c006c0 csrss.exe            0x0000000076d40000 ntdll.dll            Error: DllBase is paged\n0xfffffa8000c006c0 csrss.exe            0x000007fefd860000 msvcrt.dll           Error: DllBase is paged\n0xfffffa80011c5700 lsass.exe            0x000007fefcc40000 WINSTA.dll           Error: DllBase is paged\n0xfffffa80011c5700 lsass.exe            0x000007fefd7c0000 GDI32.dll            OK: module.444.173c5700.7fefd7c0000.dll\n0xfffffa80011c5700 lsass.exe            0x000007fefc270000 DNSAPI.dll           OK: module.444.173c5700.7fefc270000.dll\n0xfffffa80011c5700 lsass.exe            0x000007fefc5d0000 Secur32.dll          OK: module.444.173c5700.7fefc5d0000.dll\n...\n```\n\n>If the extraction fails, as it did for a few DLLs above, it probably means that some of the memory pages in that DLL were not memory resident (due to paging). In particular, this is a problem if the first page containing the PE header and thus the PE section mappings is not available. In these cases you can still extract the memory segment using the vaddump command, but you'll need to manually rebuild the PE header and fixup the sections (if you plan on analyzing in IDA Pro) as described in Recovering CoreFlood Binaries with Volatility.\n\n\u4e0a\u306e\u3044\u304f\u3064\u304b\u306eDLL\u306e\u3088\u3046\u306b\u62bd\u51fa\u304c\u5931\u6557\u3057\u305f\u5834\u5408\u3001DLL\u306e\u4e00\u90e8\u306e\u30e1\u30e2\u30ea\u30da\u30fc\u30b8\u304c\u7269\u7406\u30e1\u30e2\u30ea\u4e0a\u306b\u306a\u3044\u306e\u304b\u3082\u3057\u308c\u307e\u305b\u3093(\u30da\u30fc\u30b8\u30f3\u30b0\u306b\u3088\u3063\u3066)\u3002\u7279\u306bPE\u30d8\u30c3\u30c0\u306e\u982d\u306e\u30da\u30fc\u30b8\u304c\u306a\u304f\u3066PE\u30bb\u30af\u30b7\u30e7\u30f3\u30de\u30c3\u30d4\u30f3\u30b0\u304c\u53d6\u5f97\u3067\u304d\u306a\u3044\u5834\u5408\u306b\u554f\u984c\u3068\u306a\u308a\u307e\u3059\u3002\u3053\u306e\u3088\u3046\u306a\u5834\u5408\u3067\u3082\u3001vaddump\u30b3\u30de\u30f3\u30c9\u3067\u306f\u30e1\u30e2\u30ea\u30bb\u30b0\u30e1\u30f3\u30c8\u3092\u62bd\u51fa\u3067\u304d\u307e\u3059\u304c\u3001(IDA Pro\u3067\u89e3\u6790\u3057\u3088\u3046\u3068\u3057\u3066\u3044\u308b\u306a\u3089)\u201dRecovering CoreFlood Binaries with Volatility\u201d\u3067\u89e3\u8aac\u3057\u3066\u3044\u308b\u3088\u3046\u306bPE\u30d8\u30c3\u30c0\u3092\u518d\u69cb\u7bc9\u3057\u3066\u30bb\u30af\u30b7\u30e7\u30f3\u3092\u4fee\u5fa9\u3059\u308b\u5fc5\u8981\u304c\u3042\u308a\u307e\u3059\u3002\n\n>To dump a PE file that doesn't exist in the DLLs list (for example, due to code injection or malicious unlinking), just specify the base address of the PE in process memory:\n\n(\u30b3\u30fc\u30c9\u30a4\u30f3\u30b8\u30a7\u30af\u30b7\u30e7\u30f3\u3084\u60aa\u610f\u306b\u3088\u3063\u3066\u30ea\u30f3\u30af\u3092\u5916\u3055\u308c\u3066\u3044\u308b\u3088\u3046\u306a\u5834\u5408\u306a\u3069)DLL\u30ea\u30b9\u30c8\u306b\u306a\u3044PE\u30d5\u30a1\u30a4\u30eb\u3092\u30c0\u30f3\u30d7\u3059\u308b\u306b\u306f\u3001\u30d7\u30ed\u30bb\u30b9\u30e1\u30e2\u30ea\u4e2d\u306ePE\u306e\u30d9\u30fc\u30b9\u30a2\u30c9\u30ec\u30b9\u3092\u6307\u5b9a\u3057\u307e\u3059\u3002\n\n```\n$ python vol.py --profile=Win7SP0x86 -f win7.dmp dlldump --pid=492 -D out --base=0x00680000\n```\n\n>You can also specify an EPROCESS offset if the DLL you want is in a hidden process:\n\n\u96a0\u853d\u3055\u308c\u305f\u30d7\u30ed\u30bb\u30b9\u5185\u306eDLL\u3092\u30c0\u30f3\u30d7\u3057\u305f\u3044\u5834\u5408\u3001EPROCESS\u306e\u30aa\u30d5\u30bb\u30c3\u30c8\u3092\u6307\u5b9a\u3059\u308b\u3053\u3068\u3082\u3067\u304d\u307e\u3059\u3002\n\n```\n$ python vol.py --profile=Win7SP0x86 -f win7.dmp dlldump -o 0x3e3f64e8 -D out --base=0x00680000\n```\n\n## handles\n\n>To display the open handles in a process, use the handles command. This applies to files, registry keys, mutexes, named pipes, events, window stations, desktops, threads, and all other types of securable executive objects. As of 2.1, the output includes handle value and granted access for each object.\n\nhandles\u30b3\u30de\u30f3\u30c9\u3067\u30d7\u30ed\u30bb\u30b9\u304c\u30aa\u30fc\u30d7\u30f3\u3057\u3066\u3044\u308b\u30cf\u30f3\u30c9\u30eb\u3092\u8868\u793a\u3067\u304d\u307e\u3059\u3002\u30d5\u30a1\u30a4\u30eb\u3001\u30ec\u30b8\u30b9\u30c8\u30ea\u30ad\u30fc\u3001\u30df\u30e5\u30fc\u30c6\u30c3\u30af\u30b9\u3001\u540d\u524d\u4ed8\u304d\u30d1\u30a4\u30d7\u3001\u30a4\u30d9\u30f3\u30c8\u3001\u30a6\u30a3\u30f3\u30c9\u30a6\u30b9\u30c6\u30fc\u30b7\u30e7\u30f3\u3001\u30c7\u30b9\u30af\u30c8\u30c3\u30d7\u3001\u30b9\u30ec\u30c3\u30c9\u3001\u4ed6\u306e\u3059\u3079\u3066\u306eSecurable executive objects\u306b\u9069\u7528\u3055\u308c\u307e\u3059\u3002\u30d0\u30fc\u30b8\u30e7\u30f32.1\u304b\u3089\u3001\u30cf\u30f3\u30c9\u30eb\u306e\u5024\u3068\u8a31\u3055\u308c\u308b\u30a2\u30af\u30bb\u30b9\u304c\u305d\u308c\u305e\u308c\u306e\u30aa\u30d6\u30b8\u30a7\u30af\u30c8\u306b\u8868\u793a\u3055\u308c\u308b\u3088\u3046\u306b\u306a\u308a\u307e\u3057\u305f\u3002\n\n```\n$ python vol.py -f ~/Desktop/win7_trial_64bit.raw --profile=Win7SP0x64 handles\nVolatility Foundation Volatility Framework 2.4\nOffset(V)             Pid             Handle             Access Type             Details\n------------------ ------ ------------------ ------------------ ---------------- -------\n0xfffffa80004b09e0      4                0x4           0x1fffff Process          System(4)\n0xfffff8a0000821a0      4               0x10            0x2001f Key              MACHINE\\SYSTEM\\CONTROLSET001\\CONTROL\\PRODUCTOPTIONS\n0xfffff8a00007e040      4               0x14            0xf003f Key              MACHINE\\SYSTEM\\CONTROLSET001\\CONTROL\\SESSION MANAGER\\MEMORY MANAGEMENT\\PREFETCHPARAMETERS\n0xfffff8a000081fa0      4               0x18            0x2001f Key              MACHINE\\SYSTEM\\SETUP\n0xfffffa8000546990      4               0x1c           0x1f0001 ALPC Port        PowerMonitorPort\n0xfffffa800054d070      4               0x20           0x1f0001 ALPC Port        PowerPort\n0xfffff8a0000676a0      4               0x24            0x20019 Key              MACHINE\\HARDWARE\\DESCRIPTION\\SYSTEM\\MULTIFUNCTIONADAPTER\n0xfffffa8000625460      4               0x28           0x1fffff Thread           TID 160 PID 4\n0xfffff8a00007f400      4               0x2c            0xf003f Key              MACHINE\\SYSTEM\\CONTROLSET001\n0xfffff8a00007f200      4               0x30            0xf003f Key              MACHINE\\SYSTEM\\CONTROLSET001\\ENUM\n0xfffff8a000080d10      4               0x34            0xf003f Key              MACHINE\\SYSTEM\\CONTROLSET001\\CONTROL\\CLASS\n0xfffff8a00007f500      4               0x38            0xf003f Key              MACHINE\\SYSTEM\\CONTROLSET001\\SERVICES\n0xfffff8a0001cd990      4               0x3c                0xe Token\n0xfffff8a00007bfa0      4               0x40            0x20019 Key              MACHINE\\SYSTEM\\CONTROLSET001\\CONTROL\\WMI\\SECURITY\n0xfffffa8000cd52b0      4               0x44           0x120116 File             \\Device\\Mup\n0xfffffa8000ce97f0      4               0x48               0x2a Process          smss.exe(208)\n0xfffffa8000df16f0      4               0x4c           0x120089 File             \\Device\\HarddiskVolume2\\Windows\\System32\\en-US\\win32k.sys.mui\n0xfffffa8000de37f0      4               0x50           0x12019f File             \\Device\\clfsTxfLog\n0xfffff8a000952fa0      4               0x54            0x2001f Key              MACHINE\\SYSTEM\\CONTROLSET001\\CONTROL\\VIDEO\\{6A8FC9DC-A76B-47FC-A703-17800182E1CE}\\0000\\VOLATILESETTINGS\n0xfffffa800078da20      4               0x58           0x12019f File             \\Device\\Tcp\n0xfffff8a002e17610      4               0x5c                0x9 Key              MACHINE\\SOFTWARE\\MICROSOFT\\WINDOWS NT\\CURRENTVERSION\\IMAGE FILE EXECUTION OPTIONS\n0xfffff8a0008f7b00      4               0x60               0x10 Key              MACHINE\\SYSTEM\\CONTROLSET001\\CONTROL\\LSA\n0xfffffa8000da2870      4               0x64           0x100001 File             \\Device\\KsecDD\n0xfffffa8000da3040      4               0x68                0x0 Thread           TID 228 PID 4\n...\n```\n\n>You can display handles for a particular process by specifying --pid=PID or the physical offset of an EPROCESS structure (--physical-offset=OFFSET). You can also filter by object type using -t or --object-type=OBJECTTYPE. For example to only display handles to process objects for pid 600, do the following:\n\n--pid=PID\u3082\u3057\u304f\u306fEPROCESS\u69cb\u9020\u4f53\u306e\u7269\u7406\u30a2\u30c9\u30ec\u30b9\u3092--physical-offset=OFFSET\u3068\u3044\u3046\u30aa\u30d7\u30b7\u30e7\u30f3\u3067\u6307\u5b9a\u3059\u308b\u3053\u3068\u306b\u3088\u308a\u3001\u7279\u5b9a\u306e\u30d7\u30ed\u30bb\u30b9\u306e\u30cf\u30f3\u30c9\u30eb\u306e\u307f\u3092\u8868\u793a\u3055\u305b\u308b\u3053\u3068\u304c\u3067\u304d\u307e\u3059\u3002-t\u3082\u3057\u304f\u306f--object-type=OBJECTTYPE\u30aa\u30d7\u30b7\u30e7\u30f3\u3067\u3001\u30aa\u30d6\u30b8\u30a7\u30af\u30c8\u3092\u30d5\u30a3\u30eb\u30bf\u3059\u308b\u3053\u3068\u304c\u3067\u304d\u307e\u3059\u3002pid 600(\u30de\u30de)\u306e\u30d7\u30ed\u30bb\u30b9\u306e\u30cf\u30f3\u30c9\u30eb\u306e\u307f\u3092\u8868\u793a\u3057\u305f\u3044\u5834\u5408\u306f\u3001\u6b21\u306e\u3088\u3046\u306b\u3057\u307e\u3059\u3002\n\n```\n$ python vol.py -f ~/Desktop/win7_trial_64bit.raw --profile=Win7SP0x64 handles -p 296 -t Process\nVolatility Foundation Volatility Framework 2.4\nOffset(V)             Pid             Handle             Access Type             Details\n------------------ ------ ------------------ ------------------ ---------------- -------\n0xfffffa8000c92300    296               0x54           0x1fffff Process          wininit.exe(332)\n0xfffffa8000c5eb30    296               0xc4           0x1fffff Process          services.exe(428)\n0xfffffa80011c5700    296               0xd4           0x1fffff Process          lsass.exe(444)\n0xfffffa8000ea31b0    296               0xe4           0x1fffff Process          lsm.exe(452)\n0xfffffa8000c64840    296              0x140           0x1fffff Process          svchost.exe(348)\n0xfffffa8001296b30    296              0x150           0x1fffff Process          svchost.exe(568)\n0xfffffa80012c3620    296              0x18c           0x1fffff Process          svchost.exe(628)\n0xfffffa8001325950    296              0x1dc           0x1fffff Process          sppsvc.exe(816)\n...\n```\n\n>The object type can be any of the names printed by the \"object \\ObjectTypes\" windbg command (see Enumerate Object Types for more details.\n\n\u30aa\u30d6\u30b8\u30a7\u30af\u30c8\u30bf\u30a4\u30d7\u306f\u3001windbg\u30b3\u30de\u30f3\u30c9\u306eobject/ObjecTypes\u3067\u8868\u793a\u3055\u308c\u308b\u30bf\u30a4\u30d7\u3067\u3059\u3002(\"numerate Object Types\"\u53c2\u7167)\n\n>In some cases, the Details column will be blank (for example, if the objects don't have names). By default, you'll see both named and un-named objects. However, if you want to hide the less meaningful results and only show named objects, use the --silent parameter to this plugin.\n\n\u8a73\u7d30\u30ab\u30e9\u30e0\u304c\u30d6\u30e9\u30f3\u30af\u8868\u793a\u3055\u308c\u308b\u5834\u5408\u3082\u3042\u308a\u307e\u3059(\u30aa\u30d6\u30b8\u30a7\u30af\u30c8\u304c\u540d\u524d\u3092\u6301\u305f\u306a\u3044\u5834\u5408\u306a\u3069)\u3002\u30c7\u30d5\u30a9\u30eb\u30c8\u3067\u306f\u3001\u540d\u524d\u4ed8\u304d\u3068\u540d\u524d\u7121\u3057\u306e\u4e21\u65b9\u306e\u30aa\u30d6\u30b8\u30a7\u30af\u30c8\u304c\u8868\u793a\u3055\u308c\u307e\u3059\u3002\u540d\u524d\u3064\u304d\u30aa\u30d6\u30b8\u30a7\u30af\u30c8\u306e\u307f\u8868\u793a\u3057\u3066\u3001\u3042\u307e\u308a\u610f\u5473\u304c\u306a\u3044\u30aa\u30d6\u30b8\u30a7\u30af\u30c8\u3092\u975e\u8868\u793a\u306b\u3057\u305f\u3044\u5834\u5408\u306f\u3001--silent\u30aa\u30d7\u30b7\u30e7\u30f3\u3092\u6307\u5b9a\u3057\u3066\u304f\u3060\u3055\u3044\u3002\n\n## getsids\n\n>To view the SIDs (Security Identifiers) associated with a process, use the getsids command. Among other things, this can help you identify processes which have maliciously escalated privileges and which processes belong to specific users.\n\ngetsids\u30b3\u30de\u30f3\u30c9\u3067\u3001\u30d7\u30ed\u30bb\u30b9\u306b\u95a2\u9023\u3057\u305fSIDs(Security Identifiers)\u3092\u8868\u793a\u3067\u304d\u307e\u3059\u3002\u3053\u308c\u306b\u3088\u308a\u3001\u60aa\u610f\u3092\u6301\u3063\u3066\u6a29\u9650\u6607\u683c\u3092\u3057\u305f\u30d7\u30ed\u30bb\u30b9\u3068\u7279\u5b9a\u306e\u30e6\u30fc\u30b6\u306b\u5c5e\u3059\u308b\u30d7\u30ed\u30bb\u30b9\u3092\u8b58\u5225\u3059\u308b\u306e\u306b\u5f79\u7acb\u3061\u307e\u3059\u3002\n\n>For more information, see BDG's Linking Processes To Users.\n\n\u8a73\u3057\u304f\u306f\u3001\"BDG's Linking Processes To Users\"\u3092\u53c2\u7167\u3002\n\n```\n$ python vol.py -f ~/Desktop/win7_trial_64bit.raw --profile=Win7SP0x64 getsids\nVolatility Foundation Volatility Framework 2.4\nSystem (4): S-1-5-18 (Local System)\nSystem (4): S-1-5-32-544 (Administrators)\nSystem (4): S-1-1-0 (Everyone)\nSystem (4): S-1-5-11 (Authenticated Users)\nSystem (4): S-1-16-16384 (System Mandatory Level)\nsmss.exe (208): S-1-5-18 (Local System)\nsmss.exe (208): S-1-5-32-544 (Administrators)\nsmss.exe (208): S-1-1-0 (Everyone)\nsmss.exe (208): S-1-5-11 (Authenticated Users)\nsmss.exe (208): S-1-16-16384 (System Mandatory Level)\n[snip]\n```\n\n## cmdscan\n\n>The cmdscan plugin searches the memory of csrss.exe on XP/2003/Vista/2008 and conhost.exe on Windows 7 for commands that attackers entered through a console shell (cmd.exe). This is one of the most powerful commands you can use to gain visibility into an attackers actions on a victim system, whether they opened cmd.exe through an RDP session or proxied input/output to a command shell from a networked backdoor.\n\ncmdscan\u306f\u3001XP/2003/Vista/2008\u3067\u306fcsrss.exe\u3001Windows 7\u3067\u306fconhost.exe\u306e\u30e1\u30e2\u30ea\u304b\u3089\u3001\u653b\u6483\u8005\u304c\u30b3\u30f3\u30bd\u30fc\u30eb\u30b7\u30a7\u30eb(cmd.exe)\u3067\u5165\u529b\u3057\u305f\u30b3\u30de\u30f3\u30c9\u3092\u63a2\u7d22\u3057\u307e\u3059\u3002\u3053\u308c\u306f\u88ab\u5bb3\u3092\u53d7\u3051\u305f\u30b7\u30b9\u30c6\u30e0\u3067\u653b\u6483\u8005\u306e\u884c\u52d5\u306b\u3064\u3044\u3066\u53ef\u8996\u5316\u3092\u884c\u3046\u305f\u3081\u306e\u6700\u3082\u5f37\u529b\u306a\u30b3\u30de\u30f3\u30c9\u306e\u3072\u3068\u3064\u3067\u3059\u3002\u653b\u6483\u8005\u304ccmd.exe\u3092\u4f7f\u7528\u3057\u305f\u5834\u5408\u3001RDP\u30bb\u30c3\u30b7\u30e7\u30f3\u7d4c\u7531\u306e\u5834\u5408\u3001\u30a4\u30f3\u30d7\u30c3\u30c8\u3068\u30a2\u30a6\u30c8\u30d7\u30c3\u30c8\u306e\u30d7\u30ed\u30ad\u30b7\u3092\u884c\u3046\u30d0\u30c3\u30af\u30c9\u30a2\u306b\u3088\u3063\u3066\u30cd\u30c3\u30c8\u30ef\u30fc\u30af\u7d4c\u7531\u3067\u30b3\u30de\u30f3\u30c9\u30b7\u30a7\u30eb\u3092\u4f7f\u3063\u305f\u5834\u5408\u3067\u3082\u6709\u52b9\u3067\u3059\u3002\n\n>This plugin finds structures known as COMMAND_HISTORY by looking for a known constant value (MaxHistory) and then applying sanity checks. It is important to note that the MaxHistory value can be changed by right clicking in the top left of a cmd.exe window and going to Properties. The value can also be changed for all consoles opened by a given user by modifying the registry key HKCU\\Console\\HistoryBufferSize. The default is 50 on Windows systems, meaning the most recent 50 commands are saved. You can tweak it if needed by using the --max_history=NUMBER parameter.\n\n\u3053\u306e\u30d7\u30e9\u30b0\u30a4\u30f3\u306f\u3001\u65e2\u306b\u77e5\u3089\u308c\u3066\u3044\u308b\u56fa\u5b9a\u5024(MaxHistory)\u304b\u3089\u3001COMMAND_HISTORY\u3068\u547c\u3070\u308c\u308b\u69cb\u9020\u4f53\u3092\u898b\u3064\u3051\u3001\u6b63\u5e38\u304b\u3069\u3046\u304b\u30c1\u30a7\u30c3\u30af\u3057\u307e\u3059\u3002cmd.exe\u306e\u30a6\u30a3\u30f3\u30c9\u30a6\u306e\u4e0a\u90e8\u30d0\u30fc\u3092\u30e9\u30a4\u30c8\u30af\u30ea\u30c3\u30af\u3059\u308b\u3053\u3068\u306b\u3088\u3063\u3066\u30d7\u30ed\u30d1\u30c6\u30a3\u3092\u5909\u66f4\u3059\u308b\u3068\u3001MaxHistory\u306e\u5024\u304c\u5909\u308f\u308b\u3053\u3068\u306f\u91cd\u8981\u3067\u3059\u3002\u30ec\u30b8\u30b9\u30c8\u30ea\u30ad\u30fcHKCU\\Console\\HistoryBufferSize\u3092\u5909\u66f4\u3059\u308b\u3053\u3068\u306b\u3088\u3063\u3066\u30e6\u30fc\u30b6\u306e\u3059\u3079\u3066\u306e\u30b3\u30f3\u30bd\u30fc\u30eb\u306eMaxHistory\u306e\u5024\u304c\u5909\u66f4\u3055\u308c\u308b\u3053\u3068\u3082\u3042\u308a\u307e\u3059\u3002\n\u30c7\u30d5\u30a9\u30eb\u30c8\u3067\u306f50\u3068\u306a\u3063\u3066\u304a\u308a\u3001\u76f4\u8fd1\u306e50\u30b3\u30de\u30f3\u30c9\u304c\u8a18\u9332\u3055\u308c\u307e\u3059\u3002\u5fc5\u8981\u304c\u3042\u308c\u3070\u3001--max_history=NUMBER\u30aa\u30d7\u30b7\u30e7\u30f3\u3067\u3001\u8abf\u6574\u3059\u308b\u3053\u3068\u304c\u3067\u304d\u307e\u3059\u3002\n\n>The structures used by this plugin are not public (i.e. Microsoft does not produce PDBs for them), thus they're not available in WinDBG or any other forensic framework. They were reverse engineered by Michael Ligh from the conhost.exe and winsrv.dll binaries.\n\n\u3053\u306e\u30d7\u30e9\u30b0\u30a4\u30f3\u304c\u5229\u7528\u3057\u3066\u3044\u308b\u69cb\u9020\u4f53\u306f\u516c\u5f0f\u306e\u3082\u306e\u3067\u306f\u3042\u308a\u307e\u305b\u3093(\u30de\u30a4\u30af\u30ed\u30bd\u30d5\u30c8\u306f\u3001PDBs\u306e\u69cb\u9020\u306a\u3069\u3092\u516c\u958b\u3057\u3066\u3044\u307e\u305b\u3093)\u306e\u3067\u3001WinDBG\u3084\u305d\u306e\u4ed6\u306e\u30d5\u30a9\u30ec\u30f3\u30b8\u30c3\u30af\u30d5\u30ec\u30fc\u30e0\u30ef\u30fc\u30af\u3067\u306f\u5229\u7528\u3067\u304d\u307e\u305b\u3093\u3002Michael Ligh\u304cconhost.exe\u3068winsrv.dll\u306e\u30d0\u30a4\u30ca\u30ea\u304b\u3089\u30ea\u30d0\u30fc\u30b9\u30a8\u30f3\u30b8\u30cb\u30a2\u30ea\u30f3\u30b0\u3057\u305f\u3082\u306e\u3067\u3059\u3002\n\n>In addition to the commands entered into a shell, this plugin shows:\n\n\u30b7\u30a7\u30eb\u3092\u8abf\u67fb\u3059\u308b\u3060\u3051\u3067\u306f\u306a\u304f\u3001\u4ee5\u4e0b\u306e\u60c5\u5831\u3092\u8868\u793a\u3057\u307e\u3059\u3002\n\n>* The name of the console host process (csrss.exe or conhost.exe)\n* The name of the application using the console (whatever process is using cmd.exe)\n* The location of the command history buffers, including the current buffer count, last added command, and last displayed command\n* The application process handle\n\n* \u30b3\u30f3\u30bd\u30fc\u30eb\u30db\u30b9\u30c8\u30d7\u30ed\u30bb\u30b9\u306e\u540d\u79f0(csrss.exe\u304bconhost.exe)\n* \u30b3\u30f3\u30bd\u30fc\u30eb\u3092\u4f7f\u3063\u3066\u3044\u308b\u30a2\u30d7\u30ea\u30b1\u30fc\u30b7\u30e7\u30f3\u306e\u540d\u79f0(cmd.exe\u3092\u4f7f\u3063\u3066\u3044\u308b\u3069\u3093\u306a\u30d7\u30ed\u30bb\u30b9\u3067\u3082)\n* \u73fe\u5728\u306e\u30d0\u30c3\u30d5\u30a1\u6570\u3001\u6700\u5f8c\u306b\u8ffd\u52a0\u3055\u308c\u305f\u30b3\u30de\u30f3\u30c9\u3001\u6700\u5f8c\u306b\u8868\u793a\u3055\u308c\u305f\u30b3\u30de\u30f3\u30c9\u3092\u542b\u3080\u30b3\u30de\u30f3\u30c9\u30d2\u30b9\u30c8\u30ea\u30d0\u30c3\u30d5\u30a1\u306e\u4f4d\u7f6e\n* \u30a2\u30d7\u30ea\u30b1\u30fc\u30b7\u30e7\u30f3\u30d7\u30ed\u30bb\u30b9\u306e\u30cf\u30f3\u30c9\u30eb\n\n>Due to the scanning technique this plugin uses, it has the capability to find commands from both active and closed consoles.\n\n\u30b9\u30ad\u30e3\u30f3\u30c6\u30af\u30cb\u30c3\u30af\u3092\u5229\u7528\u3059\u308b\u3053\u3068\u306b\u3088\u308a\u3001\u30a2\u30af\u30c6\u30a3\u30d6\u3068\u9589\u3058\u3089\u308c\u305f\u30b3\u30f3\u30bd\u30fc\u30eb\u306e\u4e21\u65b9\u304b\u3089\u30b3\u30de\u30f3\u30c9\u3092\u898b\u3064\u3051\u51fa\u3059\u3053\u3068\u304c\u3067\u304d\u307e\u3059\u3002\n\n```\n$ python vol.py -f VistaSP2x64.vmem --profile=VistaSP2x64 cmdscan\nVolatility Foundation Volatility Framework 2.4\n\n**************************************************\nCommandProcess: csrss.exe Pid: 528\nCommandHistory: 0x135ec00 Application: cmd.exe Flags: Allocated, Reset\nCommandCount: 18 LastAdded: 17 LastDisplayed: 17\nFirstCommand: 0 CommandCountMax: 50\nProcessHandle: 0x330\nCmd #0 @ 0x135ef10: cd \\\nCmd #1 @ 0x135ef50: cd de\nCmd #2 @ 0x135ef70: cd PerfLogs\nCmd #3 @ 0x135ef90: cd ..\nCmd #4 @ 0x5c78b90: cd \"Program Files\"\nCmd #5 @ 0x135fae0: cd \"Debugging Tools for Windows (x64)\"\nCmd #6 @ 0x135efb0: livekd -w\nCmd #7 @ 0x135f010: windbg\nCmd #8 @ 0x135efd0: cd \\\nCmd #9 @ 0x135fd20: rundll32 c:\\apphelp.dll,ExportFunc\nCmd #10 @ 0x5c8bdb0: rundll32 c:\\windows_apphelp.dll,ExportFunc\nCmd #11 @ 0x5c8be10: rundll32 c:\\windows_apphelp.dll\nCmd #12 @ 0x135ee30: rundll32 c:\\windows_apphelp.dll,Test\nCmd #13 @ 0x135fd70: cd \"Program Files\"\nCmd #14 @ 0x5c8b9e0: dir\nCmd #15 @ 0x5c8be60: cd \"Debugging Tools for Windows (x64)\"\nCmd #16 @ 0x5c8ba00: dir\nCmd #17 @ 0x135eff0: livekd -w\n\n[snip]\n```\n\n>For background information, see Richard Stevens and Eoghan Casey's Extracting Windows Cmd Line Details from Physical Memory.\n\n\u80cc\u666f\u77e5\u8b58\u3068\u3057\u3066\u3001\"Richard Stevens and Eoghan Casey's Extracting Windows Cmd Line Details from Physical Memory\"\u3092\u53c2\u7167\u3002\n\n## consoles\n\n>Similar to cmdscan the consoles plugin finds commands that attackers typed into cmd.exe or executed via backdoors. However, instead of scanning for COMMAND_HISTORY, this plugin scans for CONSOLE_INFORMATION. The major advantage to this plugin is it not only prints the commands attackers typed, but it collects the entire screen buffer (input and output). For instance, instead of just seeing \"dir\", you'll see exactly what the attacker saw, including all files and directories listed by the \"dir\" command.\n\ncmdscan\u3068\u540c\u69d8\u306b\u3001comsoles\u30d7\u30e9\u30b0\u30a4\u30f3\u306f\u3001\u653b\u6483\u8005\u304ccmd.exe\u306b\u30bf\u30a4\u30d7\u3057\u305f\u304b\u30d0\u30c3\u30af\u30c9\u30a2\u7d4c\u7531\u3067\u5b9f\u884c\u3057\u305f\u30b3\u30de\u30f3\u30c9\u3092\u63a2\u3057\u3060\u3057\u307e\u3059\u3002COMMAND_HISTORY\u3092\u30b9\u30ad\u30e3\u30f3\u3059\u308b\u306e\u3067\u306f\u306a\u304f\u3001\u3053\u306e\u30d7\u30e9\u30b0\u30a4\u30f3\u3067\u306f\u3001CONSOLE_INFORMATION\u3092\u30b9\u30ad\u30e3\u30f3\u3057\u307e\u3059\u3002\u653b\u6483\u8005\u304c\u30bf\u30a4\u30d7\u3057\u305f\u30b3\u30de\u30f3\u30c9\u3060\u3051\u3067\u306f\u306a\u304f\u3001\u30b9\u30af\u30ea\u30fc\u30f3\u30d0\u30c3\u30d5\u30a1\u5168\u4f53(\u30a4\u30f3\u30d7\u30c3\u30c8\u3068\u30a2\u30a6\u30c8\u30d7\u30c3\u30c8)\u3092\u53d6\u5f97\u3067\u304d\u308b\u3068\u3053\u308d\u304c\u512a\u308c\u3066\u3044\u307e\u3059\u3002\u4f8b\u3048\u3070\u3001\u5358\u306b\"dir\"\u3068\u8868\u793a\u3055\u308c\u308b\u3060\u3051\u3067\u306f\u306a\u304f\u3001dir\u30b3\u30de\u30f3\u30c9\u304c\u8868\u793a\u3057\u305f\u30d5\u30a1\u30a4\u30eb\u3068\u30c7\u30a3\u30ec\u30af\u30c8\u30ea\u306e\u30ea\u30b9\u30c8\u3092\u542b\u3080\u3001\u653b\u6483\u8005\u304c\u898b\u305f\u307e\u307e\u3092\u6b63\u78ba\u306b\u8868\u793a\u3059\u308b\u3053\u3068\u304c\u3067\u304d\u307e\u3059\u3002\n\n>Additionally, this plugin prints the following:\n\n\u66f4\u306b\u3001\u3053\u306e\u30d7\u30e9\u30b0\u30a4\u30f3\u3067\u306f\u4ee5\u4e0b\u306e\u8868\u793a\u3092\u884c\u3044\u307e\u3059\u3002\n\n>* The original console window title and current console window title\n* The name and pid of attached processes (walks a LIST_ENTRY to enumerate all of them if more than one)\n* Any aliases associated with the commands executed. For example, attackers can register an alias such that typing \"hello\" actually executes \"cd system\"\n* The screen coordinates of the cmd.exe console\n\n* \u30aa\u30ea\u30b8\u30ca\u30eb\u306e\u30b3\u30f3\u30bd\u30fc\u30eb\u30a6\u30a3\u30f3\u30c9\u30a6\u30bf\u30a4\u30c8\u30eb\u3068\u73fe\u5728\u306e\u30a6\u30a3\u30f3\u30c9\u30a6\u30bf\u30a4\u30c8\u30eb\n* \u30a2\u30bf\u30c3\u30c1\u3055\u308c\u305f\u30d7\u30ed\u30bb\u30b9\u306e\u540d\u524d\u3068pid(LIST_ENTRY\u3092\u305f\u3069\u3063\u3066\u5217\u6319\u3057\u307e\u3059)\n* \u5b9f\u884c\u3055\u308c\u305f\u30b3\u30de\u30f3\u30c9\u306b\u7d50\u3073\u4ed8\u3051\u3089\u308c\u305f\u30a8\u30a4\u30ea\u30a2\u30b9\u3002\u4f8b\u3048\u3070\u3001\u653b\u6483\u8005\u306f\"hello\"\u3068\u30bf\u30a4\u30d7\u3059\u308b\u3068\u3001\"cd system\"\u304c\u5b9f\u969b\u306b\u306f\u5b9f\u884c\u3055\u308c\u308b\u3088\u3046\u306b\u30a8\u30a4\u30ea\u30a2\u30b9\u3068\u767b\u9332\u3059\u308b\u3053\u3068\u304c\u3067\u304d\u308b\n*\u3000cmd.exe\u30b3\u30f3\u30bd\u30fc\u30eb\u306e\u30b9\u30af\u30ea\u30fc\u30f3\u8abf\u6574\n\n>Here's an example of the consoles command. Below, you'll notice something quite funny. The forensic investigator seems to have lost his mind and cannot find the dd.exe tool for dumping memory. Nearly 20 typos later, he finds the tool and uses it.\n\n\u3053\u308c\u306fconsoles\u30b3\u30de\u30f3\u30c9\u306e\u4f8b\u3067\u3059\u3002\u4e0b\u3092\u898b\u308b\u3068\u3001\u304a\u304b\u3057\u306a\u3053\u3068\u306b\u6c17\u3065\u304f\u3067\u3057\u3087\u3046\u3002\u30d5\u30a9\u30ec\u30f3\u30b8\u30c3\u30af\u8abf\u67fb\u8005\u306f\u3001\u6b63\u6c17\u3092\u5931\u3063\u305f\u3088\u3046\u3067\u3001\u30e1\u30e2\u30ea\u3092\u30c0\u30f3\u30d7\u3059\u308b\u305f\u3081\u306edd.exe\u30c4\u30fc\u30eb\u304c\u898b\u3064\u3051\u3089\u308c\u307e\u305b\u3093\u300220\u56de\u8fd1\u304f\u306e\u5165\u529b\u30df\u30b9\u306e\u3042\u3068\u3001\u30c4\u30fc\u30eb\u3092\u898b\u3064\u3051\u3066\u5b9f\u884c\u3057\u307e\u3057\u305f\u3002\n\n```\n$ python vol.py -f xp-laptop-2005-07-04-1430.img consoles\nVolatility Foundation Volatility Framework 2.4\n\n[csrss.exe @ 0x821c11a8 pid 456 console @ 0x4e23b0]\n  OriginalTitle: '%SystemRoot%\\\\system32\\\\cmd.exe'\n  Title: 'C:\\\\WINDOWS\\\\system32\\\\cmd.exe - dd if=\\\\\\\\.\\\\PhysicalMemory of=c:\\\\xp-2005-07-04-1430.img conv=noerror'\n  HistoryBufferCount: 2\n  HistoryBufferMax: 4\n  CommandHistorySize: 50\n[history @ 0x4e4008]\n  CommandCount: 0\n  CommandCountMax: 50\n  Application: 'dd.exe'\n[history @ 0x4e4d88]\n  CommandCount: 20\n  CommandCountMax: 50\n  Application: 'cmd.exe'\n  Cmd #0 @ 0x4e1f90: 'dd'\n  Cmd #1 @ 0x4e2cb8: 'cd\\\\'\n  Cmd #2 @ 0x4e2d18: 'dr'\n  Cmd #3 @ 0x4e2d28: 'ee:'\n  Cmd #4 @ 0x4e2d38: 'e;'\n  Cmd #5 @ 0x4e2d48: 'e:'\n  Cmd #6 @ 0x4e2d58: 'dr'\n  Cmd #7 @ 0x4e2d68: 'd;'\n  Cmd #8 @ 0x4e2d78: 'd:'\n  Cmd #9 @ 0x4e2d88: 'dr'\n  Cmd #10 @ 0x4e2d98: 'ls'\n  Cmd #11 @ 0x4e2da8: 'cd Docu'\n  Cmd #12 @ 0x4e2dc0: 'cd Documents and'\n  Cmd #13 @ 0x4e2e58: 'dr'\n  Cmd #14 @ 0x4e2e68: 'd:'\n  Cmd #15 @ 0x4e2e78: 'cd dd\\\\'\n  Cmd #16 @ 0x4e2e90: 'cd UnicodeRelease'\n  Cmd #17 @ 0x4e2ec0: 'dr'\n  Cmd #18 @ 0x4e2ed0: 'dd '\n  Cmd #19 @ 0x4e4100: 'dd if=\\\\\\\\.\\\\PhysicalMemory of=c:\\\\xp-2005-07-04-1430.img conv=noerror'\n[screen @ 0x4e2460 X:80 Y:300]\n  Output: Microsoft Windows XP [Version 5.1.2600]\n  Output: (C) Copyright 1985-2001 Microsoft Corp.\n  Output:\n  Output: C:\\Documents and Settings\\Sarah>dd\n  Output: 'dd' is not recognized as an internal or external command,\n  Output: operable program or batch file.\n  Output:\n  Output: C:\\Documents and Settings\\Sarah>cd\\\n  Output:\n  Output: C:\\>dr\n  Output: 'dr' is not recognized as an internal or external command,\n  Output: operable program or batch file.\n  Output:\n  Output: C:\\>ee:\n  Output: 'ee:' is not recognized as an internal or external command,\n  Output: operable program or batch file.\n  Output:\n  Output: C:\\>e;\n  Output: 'e' is not recognized as an internal or external command,\n  Output: operable program or batch file.\n  Output:\n  Output: C:\\>e:\n  Output: The system cannot find the drive specified.\n  Output:\n  Output: C:\\>dr\n  Output: 'dr' is not recognized as an internal or external command,\n  Output: operable program or batch file.\n  Output:\n  Output: C:\\>d;\n  Output: 'd' is not recognized as an internal or external command,\n  Output: operable program or batch file.\n  Output:\n  Output: C:\\>d:\n  Output:\n  Output: D:\\>dr\n  Output: 'dr' is not recognized as an internal or external command,\n  Output: operable program or batch file.\n  Output:\n  Output: D:\\>dr\n  Output: 'dr' is not recognized as an internal or external command,\n  Output: operable program or batch file.\n  Output:\n  Output: D:\\>ls\n  Output: 'ls' is not recognized as an internal or external command,\n  Output: operable program or batch file.\n  Output:\n  Output: D:\\>cd Docu\n  Output: The system cannot find the path specified.\n  Output:\n  Output: D:\\>cd Documents and\n  Output: The system cannot find the path specified.\n  Output:\n  Output: D:\\>dr\n  Output: 'dr' is not recognized as an internal or external command,\n  Output: operable program or batch file.\n  Output:\n  Output: D:\\>d:\n  Output:\n  Output: D:\\>cd dd\\\n  Output:\n  Output: D:\\dd>\n  Output: D:\\dd>cd UnicodeRelease\n  Output:\n  Output: D:\\dd\\UnicodeRelease>dr\n  Output: 'dr' is not recognized as an internal or external command,\n  Output: operable program or batch file.\n  Output:\n  Output: D:\\dd\\UnicodeRelease>dd\n  Output:\n  Output: 0+0 records in\n  Output: 0+0 records out\n  Output: ^C\n  Output: D:\\dd\\UnicodeRelease>dd if=\\\\.\\PhysicalMemory of=c:\\xp-2005-07-04-1430.img conv=\n  Output: noerror\n  Output: Forensic Acquisition Utilities, 1, 0, 0, 1035\n  Output: dd, 3, 16, 2, 1035\n  Output: Copyright (C) 2002-2004 George M. Garner Jr.\n  Output:\n  Output: Command Line: dd if=\\\\.\\PhysicalMemory of=c:\\xp-2005-07-04-1430.img conv=noerror\n  Output:\n  Output: Based on original version developed by Paul Rubin, David MacKenzie, and Stuart K\n  Output: emp\n  Output: Microsoft Windows: Version 5.1 (Build 2600.Professional Service Pack 2)\n  Output:\n  Output: 04/07/2005  18:30:32 (UTC)\n  Output: 04/07/2005  14:30:32 (local time)\n  Output:\n  Output: Current User: SPLATITUDE\\Sarah\n  Output:\n  Output: Total physical memory reported: 523676 KB\n  Output: Copying physical memory...\n  Output: Physical memory in the range 0x00004000-0x00004000 could not be read.\n```\n\n## privs\n\n>This plugin shows you which process privileges are present, enabled, and/or enabled by default. You can pass it the --silent flag to only show privileges that a process explicitly enabled (i.e. that were were not enabled by default but are currently enabled). The --regex=REGEX parameter can be used to filter for specific privilege names.\n\n\u3053\u306e\u30d7\u30e9\u30b0\u30a4\u30f3\u306f\u3001\u3069\u3093\u306a\u30d7\u30ed\u30bb\u30b9\u7279\u6a29\u304cPresent\u3001\u6709\u52b9\u5316\u3001\u30c7\u30d5\u30a9\u30eb\u30c8\u3067\u6709\u52b9\u5316\uff0f\u7121\u52b9\u5316\u3067\u3042\u308b\u304b\u3092\u8868\u793a\u3059\u308b\u3002--silent\u30aa\u30d7\u30b7\u30e7\u30f3\u3092\u6307\u5b9a\u3059\u308b\u3053\u3068\u3067\u3001\u660e\u793a\u7684\u306b\u6709\u52b9\u5316\u3055\u308c\u3066\u3044\u308b\u7279\u6a29\u306e\u307f\u3092\u8868\u793a\u3055\u305b\u308b\u3053\u3068\u304c\u3067\u304d\u308b(\u30c7\u30d5\u30a9\u30eb\u30c8\u3067\u306f\u7121\u52b9\u5316\u3055\u308c\u3066\u3044\u308b\u304c\u3001\u73fe\u5728\u6709\u52b9\u304b\u3055\u308c\u3066\u3044\u308b\u3082\u306e\u306a\u3069)\u3002--regex=REGEX\u30aa\u30d7\u30b7\u30e7\u30f3\u3067\u3001\u7279\u5b9a\u306e\u7279\u6a29\u306e\u307f\u3092\u30d5\u30a3\u30eb\u30bf\u3057\u3066\u8868\u793a\u3055\u305b\u308b\u3053\u3068\u304c\u3067\u304d\u308b\u3002\n\n```\n$ python vol.py -f win7_trial_64bit.raw privs --profile=Win7SP0x64\nVolatility Foundation Volatility Framework 2.3_alpha\nPid      Process          Value  Privilege                            Attributes               Description\n-------- ---------------- ------ ------------------------------------ ------------------------ -----------\n       4 System                2 SeCreateTokenPrivilege               Present                  Create a token object\n       4 System                3 SeAssignPrimaryTokenPrivilege        Present                  Replace a process-level token\n       4 System                4 SeLockMemoryPrivilege                Present,Enabled,Default  Lock pages in memory\n       4 System                5 SeIncreaseQuotaPrivilege             Present                  Increase quotas\n       4 System                6 SeMachineAccountPrivilege                                     Add workstations to the domain\n       4 System                7 SeTcbPrivilege                       Present,Enabled,Default  Act as part of the operating system\n       4 System                8 SeSecurityPrivilege                  Present                  Manage auditing and security log\n       4 System                9 SeTakeOwnershipPrivilege             Present                  Take ownership of files/objects\n       4 System               10 SeLoadDriverPrivilege                Present                  Load and unload device drivers\n       4 System               11 SeSystemProfilePrivilege             Present,Enabled,Default  Profile system performance\n       4 System               12 SeSystemtimePrivilege                Present                  Change the system time\n       4 System               13 SeProfileSingleProcessPrivilege      Present,Enabled,Default  Profile a single process\n       4 System               14 SeIncreaseBasePriorityPrivilege      Present,Enabled,Default  Increase scheduling priority\n       4 System               15 SeCreatePagefilePrivilege            Present,Enabled,Default  Create a pagefile\n       4 System               16 SeCreatePermanentPrivilege           Present,Enabled,Default  Create permanent shared objects\n.....\n```\n\n## envars\n\n>To display a process's environment variables, use the envars plugin. Typically this will show the number of CPUs installed and the hardware architecture (though the kdbgscan output is a much more reliable source), the process's current directory, temporary directory, session name, computer name, user name, and various other interesting artifacts.\n\nenvars\u30d7\u30e9\u30b0\u30a4\u30f3\u3067\u3001\u30d7\u30ed\u30bb\u30b9\u306e\u74b0\u5883\u5909\u6570\u3092\u8868\u793a\u3055\u305b\u308b\u3053\u3068\u304c\u3067\u304d\u308b\u3002\u5178\u578b\u7684\u306b\u306f\u3001CPU\u6570\u3068\u30cf\u30fc\u30c9\u30a6\u30a7\u30a2\u30a2\u30fc\u30ad\u30c6\u30af\u30c1\u30e3(kdbgscan\u306e\u51fa\u529b\u306f\u3001\u306f\u308b\u304b\u306b\u4fe1\u983c\u3067\u304d\u308b\u304c)\u3001\u30d7\u30ed\u30bb\u30b9\u306e\u30ab\u30ec\u30f3\u30c8\u30c7\u30a3\u30ec\u30af\u30c8\u30ea\u3001\u30c6\u30f3\u30dd\u30e9\u30ea\u30c7\u30a3\u30ec\u30af\u30c8\u30ea\u3001\u30bb\u30c3\u30b7\u30e7\u30f3\u540d\u3001\u30b3\u30f3\u30d4\u30e5\u30fc\u30bf\u540d\u3001\u30e6\u30fc\u30b6\u540d\u3001\u69d8\u3005\u306a\u5f79\u306b\u7acb\u3064\u60c5\u5831\u306a\u3069\u3092\u8868\u793a\u3059\u308b\u3002\n\n```\n$ python vol.py -f ~/Desktop/win7_trial_64bit.raw --profile=Win7SP0x64 envars\nVolatility Foundation Volatility Framework 2.4\nPid      Process              Block              Variable                       Value\n-------- -------------------- ------------------ ------------------------------ -----\n     296 csrss.exe            0x00000000003d1320 ComSpec                        C:\\Windows\\system32\\cmd.exe\n     296 csrss.exe            0x00000000003d1320 FP_NO_HOST_CHECK               NO\n     296 csrss.exe            0x00000000003d1320 NUMBER_OF_PROCESSORS           1\n     296 csrss.exe            0x00000000003d1320 OS                             Windows_NT\n     296 csrss.exe            0x00000000003d1320 Path                           C:\\Windows\\system32;C:\\Windows;C:\\Windows\\System32\\Wbem;C:\\Windows\\System32\\WindowsPowerShell\\v1.0\\\n     296 csrss.exe            0x00000000003d1320 PATHEXT                        .COM;.EXE;.BAT;.CMD;.VBS;.VBE;.JS;.JSE;.WSF;.WSH;.MSC\n     296 csrss.exe            0x00000000003d1320 PROCESSOR_ARCHITECTURE         AMD64\n     296 csrss.exe            0x00000000003d1320 PROCESSOR_IDENTIFIER           Intel64 Family 6 Model 2 Stepping 3, GenuineIntel\n     296 csrss.exe            0x00000000003d1320 PROCESSOR_LEVEL                6\n     296 csrss.exe            0x00000000003d1320 PROCESSOR_REVISION             0203\n     296 csrss.exe            0x00000000003d1320 PSModulePath                   C:\\Windows\\system32\\WindowsPowerShell\\v1.0\\Modules\\\n     296 csrss.exe            0x00000000003d1320 SystemDrive                    C:\n     296 csrss.exe            0x00000000003d1320 SystemRoot                     C:\\Windows\n     296 csrss.exe            0x00000000003d1320 TEMP                           C:\\Windows\\TEMP\n     296 csrss.exe            0x00000000003d1320 TMP                            C:\\Windows\\TEMP\n     296 csrss.exe            0x00000000003d1320 USERNAME                       SYSTEM\n     296 csrss.exe            0x00000000003d1320 windir                         C:\\Windows\n```\n\n## verinfo\n\n>To display the version information embedded in PE files, use the verinfo command. Not all PE files have version information, and many malware authors forge it to include false data, but nonetheless this command can be very helpful with identifying binaries and for making correlations with other files.\n\nverinfo\u3067\u3001PE\u30d5\u30a1\u30a4\u30eb\u306b\u57cb\u3081\u8fbc\u307e\u308c\u3066\u3044\u308b\u30d0\u30fc\u30b8\u30e7\u30f3\u60c5\u5831\u3092\u51fa\u529b\u3067\u304d\u308b\u3002\u3059\u3079\u3066\u306ePE\u30d5\u30a1\u30a4\u30eb\u304c\u30d0\u30fc\u30b8\u30e7\u30f3\u60c5\u5831\u3092\u6301\u3063\u3066\u3044\u308b\u308f\u3051\u3067\u306f\u306a\u3044\u3057\u3001\u591a\u304f\u306e\u30de\u30eb\u30a6\u30a7\u30a2\u306e\u4f5c\u8005\u306f\u8aa4\u3063\u305f\u60c5\u5831\u3067\u507d\u88c5\u3092\u884c\u3046\u304c\u3001\u30d0\u30a4\u30ca\u30ea\u3092\u8b58\u5225\u3057\u5225\u306e\u30d5\u30a1\u30a4\u30eb\u3068\u306e\u95a2\u9023\u3092\u8abf\u3079\u308b\u306e\u306b\u5f79\u306b\u7acb\u3064\u30b3\u30de\u30f3\u30c9\u3067\u3042\u308b\u3002\n\n>This plugin only supports printing version information from process executables and DLLs, but later will be expanded to include kernel modules. If you want to filter by module name, use the --regex=REGEX and/or --ignore-case options.\n\n\u3053\u306e\u30d7\u30e9\u30b0\u30a4\u30f3\u306f\u3001\u30d7\u30ed\u30bb\u30b9\u306e\u5b9f\u884c\u30d5\u30a1\u30a4\u30eb\u3068DLL\u306e\u30d0\u30fc\u30b8\u30e7\u30f3\u60c5\u5831\u3057\u304b\u30b5\u30dd\u30fc\u30c8\u3057\u306a\u3044\u304c\u3001\u30ab\u30fc\u30cd\u30eb\u30e2\u30b8\u30e5\u30fc\u30eb\u307e\u3067\u30b5\u30dd\u30fc\u30c8\u7bc4\u56f2\u304c\u5e83\u304c\u308b\u3060\u308d\u3046\u3002\u30e2\u30b8\u30e5\u30fc\u30eb\u540d\u3067\u30d5\u30a3\u30eb\u30bf\u3092\u3057\u305f\u3051\u308c\u3070\u3001--regex=REGEX\u3068\u5fc5\u8981\u306b\u5fdc\u3058\u3066--ignore-case\u30aa\u30d7\u30b7\u30e7\u30f3\u3092\u6307\u5b9a\u3059\u308b\u3002\n\n```\n$ python vol.py -f ~/Desktop/win7_trial_64bit.raw --profile=Win7SP0x64 verinfo\nVolatility Foundation Volatility Framework 2.4\n\\SystemRoot\\System32\\smss.exe\nC:\\Windows\\SYSTEM32\\ntdll.dll\n\nC:\\Windows\\system32\\csrss.exe\n  File version    : 6.1.7600.16385\n  Product version : 6.1.7600.16385\n  Flags           :\n  OS              : Windows NT\n  File Type       : Application\n  File Date       :\n  CompanyName : Microsoft Corporation\n  FileDescription : Client Server Runtime Process\n  FileVersion : 6.1.7600.16385 (win7_rtm.090713-1255)\n  InternalName : CSRSS.Exe\n  LegalCopyright : \\xa9 Microsoft Corporation. All rights reserved.\n  OriginalFilename : CSRSS.Exe\n  ProductName : Microsoft\\xae Windows\\xae Operating System\n  ProductVersion : 6.1.7600.16385\n\n[snip]\n```\n\n## enumfunc\n\n>This plugin enumerates imported and exported functions from processes, dlls, and kernel drivers. Specifically, it handles functions imported by name or ordinal, functions exported by name or ordinal, and forwarded exports. The output will be very verbose in most cases (functions exported by ntdll, msvcrt, and kernel32 can reach 1000+ alone). So you can either reduce the verbosity by filtering criteria with the command-line options (shown below) or you can use look at the code in enumfunc.py and use it as an example of how to use the IAT and EAT parsing API functions in your own plugin. For example, the apihooks plugin leverages the imports and exports APIs to find functions in memory when checking for hooks.\n\n\u3053\u306e\u30d7\u30e9\u30b0\u30a4\u30f3\u306f\u3001\u30d7\u30ed\u30bb\u30b9\u3001DLL\u3001\u30ab\u30fc\u30cd\u30eb\u30c9\u30e9\u30a4\u30d0\u306b\u30a4\u30f3\u30dd\u30fc\u30c8\u307e\u305f\u306f\u305d\u308c\u3089\u304b\u3089\u30a8\u30af\u30b9\u30dd\u30fc\u30c8\u3055\u308c\u308b\u95a2\u6570\u3092\u5217\u6319\u3059\u308b\u3002\u7279\u306b\u540d\u524d\u304b\u5e8f\u6570\u3067\u30a4\u30f3\u30dd\u30fc\u30c8\u3055\u308c\u305f\u95a2\u6570\u3001\u540d\u524d\u304b\u5e8f\u6570\u3067\u30a8\u30af\u30b9\u30dd\u30fc\u30c8\u3055\u308c\u305f\u95a2\u6570\u3001forwarded\u30a8\u30af\u30b9\u30dd\u30fc\u30c8\u3092\u64cd\u4f5c\u3059\u308b\u3002\u901a\u5e38\u306e\u4f7f\u7528\u306e\u305f\u3081\u306b\u306f\u3001\u3068\u3066\u3082\u8a73\u7d30\u306a\u51fa\u529b\u3060\u308d\u3046(ntdll, msvcrt,\u3000kernel32\u304b\u3089\u30a8\u30af\u30b9\u30dd\u30fc\u30c8\u3055\u308c\u305f\u95a2\u6570\u306f\u3001\u305d\u308c\u305e\u308c1000\u4ee5\u4e0a\u306b\u9054\u3059\u308b)\u3002\u30b3\u30de\u30f3\u30c9\u30e9\u30a4\u30f3\u30aa\u30d7\u30b7\u30e7\u30f3\u306e\u30d5\u30a3\u30eb\u30bf\u3067\u524a\u6e1b\u3092\u884c\u3046(\u4e0b\u3067\u8ff0\u3079\u308b)\u304b\u3001enumfunc.py\u306e\u30b3\u30fc\u30c9\u3092\u898b\u3066IAT\u3068EAT\u3092\u30d1\u30fc\u30b9\u3059\u308bAPI\u306e\u30b5\u30f3\u30d7\u30eb\u3068\u3057\u3066\u8cb4\u65b9\u81ea\u8eab\u306e\u30d7\u30e9\u30b0\u30a4\u30f3\u3067\u5229\u7528\u3059\u308b\u3053\u3068\u3082\u3067\u304d\u308b\u3002\u4f8b\u3048\u3070\u3001apihooks\u30d7\u30e9\u30b0\u30a4\u30f3\u306f\u30e1\u30e2\u30ea\u4e0a\u306e\u95a2\u6570\u304c\u30d5\u30c3\u30af\u3055\u308c\u3066\u3044\u308b\u3092\u30c1\u30a7\u30c3\u30af\u3059\u308b\u305f\u3081\u306b\u30a4\u30f3\u30dd\u30fc\u30c8\u3068\u30a8\u30af\u30b9\u30dd\u30fc\u30c8\u306eAPI\u3092\u5229\u7528\u3057\u3066\u3044\u308b\u3002\n\n>Also note this plugin is in the contrib directory, so you can pass that to --plugins like this:\n\n\u3053\u306e\u30d7\u30e9\u30b0\u30a4\u30f3\u306f\u3001contrib\u30c7\u30a3\u30ec\u30af\u30c8\u30ea\u306b\u3042\u308b\u305f\u3081\u3001--plugins\u30aa\u30d7\u30b7\u30e7\u30f3\u3092\u3053\u306e\u3088\u3046\u306b\u6e21\u3059\u3053\u3068\u304c\u3067\u304d\u308b\uff1a\n\n```\n$ python vol.py --plugins=contrib/plugins/ -f ~/Desktop/win7_trial_64bit.raw --profile=Win7SP0x64 enumfunc -h\n....\n  -s, --scan            Scan for objects\n  -P, --process-only    Process only\n  -K, --kernel-only     Kernel only\n  -I, --import-only     Imports only\n  -E, --export-only     Exports only\n```\n\n>To use pool scanners for finding processes and kernel drivers instead of walking linked lists, use the -s option. This can be useful if you're trying to enumerate functions in hidden processes or drivers. An example of the remaining command-line options is shown below.\n\n\u30d7\u30ed\u30bb\u30b9\u3068\u30ab\u30fc\u30cd\u30eb\u30c9\u30e9\u30a4\u30d0\u3092\u898b\u3064\u3051\u308b\u305f\u3081\u306b\u30ea\u30f3\u30af\u30ea\u30b9\u30c8\u3092\u305f\u3069\u308b\u306e\u3067\u306f\u306a\u304f\u3001\u30d7\u30fc\u30eb\u30b9\u30ad\u30e3\u30ca\u3092\u4f7f\u3046\u305f\u3081\u306b\u306f\u3001-s\u30aa\u30d7\u30b7\u30e7\u30f3\u3092\u6307\u5b9a\u3059\u308b\u3002\u96a0\u3055\u308c\u305f\u30d7\u30ed\u30bb\u30b9\u3084\u30c9\u30e9\u30a4\u30d0\u306e\u95a2\u6570\u3092\u5217\u6319\u3057\u3088\u3046\u3068\u3059\u308b\u5834\u5408\u306b\u306f\u6709\u7528\u3067\u3059\u3002\u6b8b\u3055\u308c\u305f\u30b3\u30de\u30f3\u30c9\u30e9\u30a4\u30f3\u30aa\u30d7\u30b7\u30e7\u30f3\u306f\u4ee5\u4e0b\u306b\u793a\u3055\u308c\u307e\u3059\u3002\n\n>To show exported functions in process memory, use -P and -E like this:\n\n\u30d7\u30ed\u30bb\u30b9\u30e1\u30e2\u30ea\u3067\u30a8\u30af\u30b9\u30dd\u30fc\u30c8\u3055\u308c\u305f\u95a2\u6570\u306e\u8868\u793a\u306b\u306f\u3001-p\u3068-E\u30aa\u30d7\u30b7\u30e7\u30f3\u3092\u3053\u306e\u3088\u3046\u306b\u6307\u5b9a\u3057\u307e\u3059\uff1a\n\n```\n$ python vol.py --plugins=contrib/plugins/ -f ~/Desktop/win7_trial_64bit.raw --profile=Win7SP0x64 enumfunc -P -E\nProcess              Type       Module               Ordinal    Address              Name\nlsass.exe            Export     ADVAPI32.dll         1133       0x000007fefd11dd34 CreateWellKnownSid\nlsass.exe            Export     ADVAPI32.dll         1134       0x000007fefd17a460 CredBackupCredentials\nlsass.exe            Export     ADVAPI32.dll         1135       0x000007fefd170590 CredDeleteA\nlsass.exe            Export     ADVAPI32.dll         1136       0x000007fefd1704d0 CredDeleteW\nlsass.exe            Export     ADVAPI32.dll         1137       0x000007fefd17a310 CredEncryptAndMarshalBinaryBlob\nlsass.exe            Export     ADVAPI32.dll         1138       0x000007fefd17d080 CredEnumerateA\nlsass.exe            Export     ADVAPI32.dll         1139       0x000007fefd17cf50 CredEnumerateW\nlsass.exe            Export     ADVAPI32.dll         1140       0x000007fefd17ca00 CredFindBestCredentialA\nlsass.exe            Export     ADVAPI32.dll         1141       0x000007fefd17c8f0 CredFindBestCredentialW\nlsass.exe            Export     ADVAPI32.dll         1142       0x000007fefd130c10 CredFree\nlsass.exe            Export     ADVAPI32.dll         1143       0x000007fefd1630f0 CredGetSessionTypes\nlsass.exe            Export     ADVAPI32.dll         1144       0x000007fefd1703d0 CredGetTargetInfoA\n[snip]\n```\n\n>To show imported functions in kernel memory, use -K and -I like this:\n\n\u30ab\u30fc\u30cd\u30eb\u30e1\u30e2\u30ea\u306b\u30a4\u30f3\u30dd\u30fc\u30c8\u3055\u308c\u305f\u95a2\u6570\u3092\u8868\u793a\u3059\u308b\u306b\u306f\u3001-K\u3068-I\u30aa\u30d7\u30b7\u30e7\u30f3\u3092\u3053\u306e\u3088\u3046\u306b\u5229\u7528\u3057\u307e\u3059\uff1a\n\n```\n$ python vol.py --plugins=contrib/plugins/ -f ~/Desktop/win7_trial_64bit.raw --profile=Win7SP0x64 enumfunc -K -I\nVolatility Foundation Volatility Framework 2.4\nProcess              Type       Module               Ordinal    Address              Name\n<KERNEL>             Import     VIDEOPRT.SYS         583        0xfffff80002acc320 ntoskrnl.exeIoRegisterPlugPlayNotification\n<KERNEL>             Import     VIDEOPRT.SYS         1325       0xfffff800029f9f30 ntoskrnl.exeRtlAppendStringToString\n<KERNEL>             Import     VIDEOPRT.SYS         509        0xfffff800026d06e0 ntoskrnl.exeIoGetAttachedDevice\n<KERNEL>             Import     VIDEOPRT.SYS         443        0xfffff800028f7ec0 ntoskrnl.exeIoBuildSynchronousFsdRequest\n<KERNEL>             Import     VIDEOPRT.SYS         1466       0xfffff80002699300 ntoskrnl.exeRtlInitUnicodeString\n<KERNEL>             Import     VIDEOPRT.SYS         759        0xfffff80002697be0 ntoskrnl.exeKeInitializeEvent\n<KERNEL>             Import     VIDEOPRT.SYS         1461       0xfffff8000265e8a0 ntoskrnl.exeRtlInitAnsiString\n<KERNEL>             Import     VIDEOPRT.SYS         1966       0xfffff80002685060 ntoskrnl.exeZwSetValueKey\n<KERNEL>             Import     VIDEOPRT.SYS         840        0xfffff80002699440 ntoskrnl.exeKeReleaseSpinLock\n<KERNEL>             Import     VIDEOPRT.SYS         1190       0xfffff800027a98b0 ntoskrnl.exePoRequestPowerIrp\n<KERNEL>             Import     VIDEOPRT.SYS         158        0xfffff800026840f0 ntoskrnl.exeExInterlockedInsertTailList\n<KERNEL>             Import     VIDEOPRT.SYS         1810       0xfffff80002684640 ntoskrnl.exeZwClose\n[snip]\n```\n\n# Process Memory\n\n## memmap\n\n>The memmap command shows you exactly which pages are memory resident, given a specific process DTB (or kernel DTB if you use this plugin on the Idle or System process). It shows you the virtual address of the page, the corresponding physical offset of the page, and the size of the page. The map information generated by this plugin comes from the underlying address space's get_available_addresses method.\n\nmemmap\u306f\u3001\u6307\u5b9a\u3057\u305f\u30d7\u30ed\u30bb\u30b9DTB(\u3082\u3057\u304f\u306f\u30a2\u30a4\u30c9\u30eb\u304b\u30b7\u30b9\u30c6\u30e0\u30d7\u30ed\u30bb\u30b9\u306b\u5bfe\u3057\u3066\u306f\u3001\u30ab\u30fc\u30cd\u30ebDTB)\u306e\u3069\u306e\u30da\u30fc\u30b8\u304c\u7269\u7406\u30e1\u30e2\u30ea\u4e0a\u306b\u3042\u308b\u304b\u3092\u8868\u793a\u3059\u308b\u3002\u30da\u30fc\u30b8\u306e\u4eee\u60f3\u30a2\u30c9\u30ec\u30b9\u3001\u5bfe\u5fdc\u3059\u308b\u7269\u7406\u30a2\u30c9\u30ec\u30b9\u3068\u30b5\u30a4\u30ba\u3092\u8868\u793a\u3059\u308b\u3002\u3053\u306e\u30d7\u30e9\u30b0\u30a4\u30f3\u304c\u8868\u793a\u3059\u308b\u60c5\u5831\u306f\u3001\u30a2\u30c9\u30ec\u30b9\u7a7a\u9593\u306eget_available_addresses\u30e1\u30bd\u30c3\u30c9\u3067\u53d6\u5f97\u3055\u308c\u308b\u3002\n\n>As of 2.1, the new column DumpFileOffset helps you correlate the output of memmap with the dump file produced by the memdump plugin. For example, according to the output below, the page at virtual address 0x0000000000058000 in the System process's memory can be found at offset 0x00000000162ed000 of the win7_trial_64bit.raw file. After using memdump to extract the addressable memory of the System process to an individual file, you can find this page at offset 0x8000.\n\n2.1\u304b\u3089\u3001DumpFileOffset\u3068\u3044\u3046\u65b0\u3057\u3044\u5217\u3067\u3001memmap\u306e\u51fa\u529b\u3068memdump\u306b\u3088\u308b\u30c0\u30f3\u30d7\u30d5\u30a1\u30a4\u30eb\u306e\u95a2\u9023\u4ed8\u3051\u304c\u3067\u304d\u308b\u3088\u3046\u306b\u306a\u3063\u3066\u3044\u308b\u3002\u4f8b\u3048\u3070\u3001\u4e0b\u306e\u51fa\u529b\u4f8b\u3067\u306f\u3001\u30b7\u30b9\u30c6\u30e0\u30d7\u30ed\u30bb\u30b9\u306e\u4eee\u60f3\u30a2\u30c9\u30ec\u30b90x0000000000058000\u306e\u30da\u30fc\u30b8\u306f\u3001win7_trial_64bit.raw\u30d5\u30a1\u30a4\u30eb\u306e0x00000000162ed000\u30aa\u30d5\u30bb\u30c3\u30c8\u306b\u898b\u3064\u3051\u3089\u308c\u308b\u3002\u30b7\u30b9\u30c6\u30e0\u30d7\u30ed\u30bb\u30b9\u306e\u30e1\u30e2\u30ea\u3092\u500b\u5225\u306e\u30d5\u30a1\u30a4\u30eb\u306b\u30c0\u30f3\u30d7\u3057\u305f\u5f8c\u306b\u3001\u305d\u306e\u30d5\u30a1\u30a4\u30eb\u306e0x8000\u30aa\u30d5\u30bb\u30c3\u30c8\u306b\u30da\u30fc\u30b8\u304c\u898b\u3064\u3051\u3089\u308c\u308b\u3002\n\n```\n$ python vol.py -f ~/Desktop/win7_trial_64bit.raw --profile=Win7SP0x64 memmap -p 4\nVolatility Foundation Volatility Framework 2.4\nSystem pid:      4\nVirtual            Physical                         Size     DumpFileOffset\n------------------ ------------------ ------------------ ------------------\n0x0000000000050000 0x0000000000cbc000             0x1000                0x0\n0x0000000000051000 0x0000000015ec6000             0x1000             0x1000\n0x0000000000052000 0x000000000f5e7000             0x1000             0x2000\n0x0000000000053000 0x0000000005e28000             0x1000             0x3000\n0x0000000000054000 0x0000000008b29000             0x1000             0x4000\n0x0000000000055000 0x00000000155b8000             0x1000             0x5000\n0x0000000000056000 0x000000000926e000             0x1000             0x6000\n0x0000000000057000 0x0000000002dac000             0x1000             0x7000\n0x0000000000058000 0x00000000162ed000             0x1000             0x8000\n[snip]\n```\n\n## memdump\n\n>To extract all memory resident pages in a process (see memmap for details) into an individual file, use the memdump command. Supply the output directory with -D or --dump-dir=DIR.\n\n\u30d7\u30ed\u30bb\u30b9\u5185\u306e\u3059\u3079\u3066\u306e\u7269\u7406\u30e1\u30e2\u30ea\u4e0a\u306e\u30da\u30fc\u30b8\u3092\u500b\u5225\u306e\u30d5\u30a1\u30a4\u30eb\u306b\u5c55\u958b\u3059\u308b\u306b\u306f\u3001memdump\u30b3\u30de\u30f3\u30c9\u3092\u4f7f\u3046\u3002-D\u307e\u305f\u306f--dump-dir=DIR\u30aa\u30d7\u30b7\u30e7\u30f3\u3067\u3001\u51fa\u529b\u30c7\u30a3\u30ec\u30af\u30c8\u30ea\u3092\u3057\u3066\u3044\u3059\u308b\u3053\u3068\u304c\u3067\u304d\u308b\u3002\n\n```\n$ python vol.py -f ~/Desktop/win7_trial_64bit.raw --profile=Win7SP0x64 memdump -p 4 -D dump/\nVolatility Foundation Volatility Framework 2.4\n************************************************************************\nWriting System [     4] to 4.dmp\n\n$ ls -alh dump/4.dmp\n-rw-r--r--  1 Michael  staff   111M Jun 24 15:47 dump/4.dmp\n```\n\n>To conclude the demonstration we began in the memmap discussion, we should now be able to make an assertion regarding the relationship of the mapped and extracted pages:\n\nmemmap\u306e\u8b70\u8ad6\u3067\u59cb\u3081\u305f\u8aac\u660e\u306b\u7d50\u8ad6\u3092\u3060\u3059\u305f\u3081\u306b\u3001\u30de\u30c3\u30d7\u3055\u308c\u305f\u30da\u30fc\u30b8\u3068\u5c55\u958b\u3055\u308c\u305f\u30da\u30fc\u30b8\u9593\u306e\u95a2\u4fc2\u306b\u3064\u3044\u3066\u4e3b\u5f35\u3067\u304d\u308b\u3079\u304d\u3067\u3057\u3087\u3046\u3002\n\n```\n$ python vol.py -f ~/Desktop/win7_trial_64bit.raw --profile=Win7SP0x64 volshell\nVolatility Foundation Volatility Framework 2.4\nCurrent context: process System, pid=4, ppid=0 DTB=0x187000\nWelcome to volshell Current memory image is:\nfile:///Users/Michael/Desktop/win7_trial_64bit.raw\nTo get help, type 'hh()'\n\n>>> PAGE_SIZE = 0x1000\n\n>>> assert addrspace().read(0x0000000000058000, PAGE_SIZE) == \\\n...        addrspace().base.read(0x00000000162ed000, PAGE_SIZE) == \\\n...        open(\"dump/4.dmp\", \"rb\").read()[0x8000:0x8000 + PAGE_SIZE]\n>>>\n```\n\n## procdump\n\n>To dump a process's executable, use the procdump command. Optionally, pass the --unsafe or -u flags to bypass certain sanity checks used when parsing the PE header. Some malware will intentionally forge size fields in the PE header so that memory dumping tools fail.\n\n\u30d7\u30ed\u30bb\u30b9\u306e\u5b9f\u884c\u5f62\u5f0f\u30d5\u30a1\u30a4\u30eb\u3092\u30c0\u30f3\u30d7\u3059\u308b\u305f\u3081\u306bprocdump\u30b3\u30de\u30f3\u30c9\u304c\u4f7f\u3048\u307e\u3059\u3002\u30aa\u30d7\u30b7\u30e7\u30f3\u3068\u3057\u3066\u3001--unsafe\u307e\u305f\u306f-u\u30aa\u30d7\u30b7\u30e7\u30f3\u3092\u6307\u5b9a\u3059\u308b\u3068PE\u30d8\u30c3\u30c0\u3092\u30d1\u30fc\u30b9\u3059\u308b\u969b\u306b\u3044\u304f\u3064\u304b\u306e\u5065\u5168\u3055\u306e\u30c1\u30a7\u30c3\u30af\u304c\u30d0\u30a4\u30d1\u30b9\u3055\u308c\u307e\u3059\u3002\n\n>Use --memory to include slack space between the PE sections that aren't page aligned. Without --memory you'll get a file that more closely resembles the file on disk, before sections expanded.\n\n--memory\u30aa\u30d7\u30b7\u30e7\u30f3\u3067\u30da\u30fc\u30b8\u4f4d\u7f6e\u306b\u5408\u3063\u3066\u3044\u306a\u3044PE\u30bb\u30af\u30b7\u30e7\u30f3\u306e\u30b9\u30e9\u30c3\u30af\u30b9\u30da\u30fc\u30b9\u3092\u542b\u3081\u3089\u308c\u307e\u3059\u3002--memory\u30aa\u30d7\u30b7\u30e7\u30f3\u306a\u3057\u3067\u306f\u3001\u30bb\u30af\u30b7\u30e7\u30f3\u304c\u62e1\u5927\u3059\u308b\u524d\u306e\u30c7\u30a3\u30b9\u30af\u4e0a\u306e\u30d5\u30a1\u30a4\u30eb\u306b\u3088\u304f\u4f3c\u305f\u30d5\u30a1\u30a4\u30eb\u3092\u53d6\u5f97\u3059\u308b\u3053\u3068\u306b\u306a\u308a\u307e\u3059\u3002\n\n>For more information, see Andreas Schuster's 4-part series on Reconstructing a Binary. Also see impscan for help rebuilding a binary's import address table.\n\n\u66f4\u306b\u8a73\u3057\u3044\u60c5\u5831\u306f\u3001\u201dAndreas Schuster's 4-part series on Reconstructing a Binary\u201d\u3092\u53c2\u7167\u3002\u30d0\u30a4\u30ca\u30ea\u306e\u30a4\u30f3\u30dd\u30fc\u30c8\u30a2\u30c9\u30ec\u30b9\u30c6\u30fc\u30d6\u30eb\u3092\u518d\u69cb\u7bc9\u3059\u308b\u305f\u3081\u306bimpscan\u3082\u53c2\u7167\u3057\u3066\u304f\u3060\u3055\u3044\u3002\n\n```\n$ python vol.py -f win7_trial_64bit.raw --profile=Win7SP0x64 procdump -D dump/ -p 296\nVolatility Foundation Volatility Framework 2.4\n************************************************************************\nDumping csrss.exe, pid:    296 output: executable.296.exe\n\n$ file dump/executable.296.exe\ndump/executable.296.exe: PE32+ executable for MS Windows (native) Mono/.Net assembly\n```\n\n## vadinfo\n\n>The vadinfo command displays extended information about a process's VAD nodes. In particular, it shows:\n\nvadinfo\u306f\u3001\u30d7\u30ed\u30bb\u30b9\u306eVAD\u30ce\u30fc\u30c9\u306b\u3064\u3044\u3066\u306e\u62e1\u5f35\u3055\u308c\u305f\u60c5\u5831\u3092\u8868\u793a\u3057\u307e\u3059\u3002\u4ee5\u4e0b\u306e\u3082\u306e\u3092\u8868\u793a\u3057\u307e\u3059\u3002\n\n>* The address of the MMVAD structure in kernel memory\n* The starting and ending virtual addresses in process memory that the MMVAD structure pertains to\n* The VAD Tag\n* The VAD flags, control flags, etc\n* The name of the memory mapped file (if one exists)\n* The memory protection constant (permissions). Note there is a difference between the original protection and current protection. The original protection is derived from the flProtect parameter to VirtualAlloc. For example you can reserve memory (MEM_RESERVE) with protection PAGE_NOACCESS (original protection). Later, you can call VirtualAlloc again to commit (MEM_COMMIT) and specify PAGE_READWRITE (becomes current protection). The vadinfo command shows the original protection only. Thus, just because you see PAGE_NOACCESS here, it doesn't mean code in the region cannot be read, written, or executed.\n\n* \u30ab\u30fc\u30cd\u30eb\u5185\u306eNMVAD\u69cb\u9020\u4f53\u306e\u30a2\u30c9\u30ec\u30b9\n* NMVAD\u69cb\u9020\u4f53\u306e\u30d7\u30ed\u30bb\u30b9\u5185\u306e\u958b\u59cb\u3068\u7d42\u4e86\u4eee\u60f3\u30a2\u30c9\u30ec\u30b9\n* VAD\u30bf\u30b0\n* VAD\u30d5\u30e9\u30b0\u3001\u30b3\u30f3\u30c8\u30ed\u30fc\u30eb\u30d5\u30e9\u30b0\u306a\u3069\n* \u30e1\u30e2\u30ea\u30de\u30c3\u30d7\u30c9\u30d5\u30a1\u30a4\u30eb\u306e\u540d\u524d(\u3082\u3057\u3042\u308c\u3070)\n* \u30e1\u30e2\u30ea\u30d7\u30ed\u30c6\u30af\u30b7\u30e7\u30f3\u5b9a\u6570(\u8a31\u53ef)\u3002\u30aa\u30ea\u30b8\u30ca\u30eb\u306e\u30d7\u30ed\u30c6\u30af\u30b7\u30e7\u30f3\u3068\u73fe\u5728\u306e\u30d7\u30ed\u30c6\u30af\u30b7\u30e7\u30f3\u306b\u306f\u9055\u3044\u304c\u3042\u308b\u3053\u3068\u306b\u6ce8\u610f\u3002\u30aa\u30ea\u30b8\u30ca\u30eb\u306e\u30d7\u30ed\u30c6\u30af\u30b7\u30e7\u30f3\u306f\u3001VirtualAlloc\u306b\u5bfe\u3059\u308bflProtect\u30d1\u30e9\u30e1\u30fc\u30bf\u304b\u3089\u304d\u3066\u3044\u308b\u3002\u4f8b\u3048\u3070\u3001PAGE_NOACCESS\u30d7\u30ed\u30c6\u30af\u30b7\u30e7\u30f3(\u30aa\u30ea\u30b8\u30ca\u30eb\u306e\u30d7\u30ed\u30c6\u30af\u30b7\u30e7\u30f3)\u3067\u30e1\u30e2\u30ea\u3092\u4e88\u7d04(MEM_RESERVE)\u3067\u304d\u308b\u3002\u305d\u306e\u5f8c\u3001VirtualAlloc\u3092\u518d\u3073\u547c\u3093\u3067\u3001PAGE_READWRITE\u30d7\u30ed\u30c6\u30af\u30b7\u30e7\u30f3\u3067\u30b3\u30df\u30c3\u30c8(MEM_COMMIT)\u3059\u308b\u3053\u3068\u304c\u3067\u304d\u308b(\u73fe\u5728\u306e\u30d7\u30ed\u30c6\u30af\u30b7\u30e7\u30f3\u306b\u306a\u308b)\u3002vadinfo\u306f\u3001\u30aa\u30ea\u30b8\u30ca\u30eb\u306e\u30d7\u30ed\u30c6\u30af\u30b7\u30e7\u30f3\u3057\u304b\u8868\u793a\u3057\u306a\u3044\u3002PAGE_NOACCESS\u3068\u8868\u793a\u3055\u308c\u3066\u3044\u308b\u304b\u3089\u3068\u3044\u3063\u3066\u3001\u5fc5\u305a\u3057\u3082\u305d\u306e\u30e1\u30e2\u30ea\u306e\u30b3\u30fc\u30c9\u304c\u3001\u30ea\u30fc\u30c9\u3001\u30e9\u30a4\u30c8\u3001\u5b9f\u884c\u3067\u304d\u306a\u3044\u3068\u3044\u3046\u308f\u3051\u3067\u306f\u306a\u3044\u3002\n\n```\n    $ python vol.py -f ~/Desktop/win7_trial_64bit.raw --profile=Win7SP0x64 vadinfo -p 296\n    Volatility Foundation Volatility Framework 2.4\n    ************************************************************************\n    Pid:    296\n    VAD node @ 0xfffffa8000c00620 Start 0x000000007f0e0000 End 0x000000007ffdffff Tag VadS\n    Flags: PrivateMemory: 1, Protection: 1\n    Protection: PAGE_READONLY\n    Vad Type: VadNone\n\n    [snip]\n\n    VAD node @ 0xfffffa8000c04ce0 Start 0x000007fefcd00000 End 0x000007fefcd10fff Tag Vad\n    Flags: CommitCharge: 2, Protection: 7, VadType: 2\n    Protection: PAGE_EXECUTE_WRITECOPY\n    Vad Type: VadImageMap\n    ControlArea @fffffa8000c04d70 Segment fffff8a000c45c10\n    Dereference list: Flink 00000000, Blink 00000000\n    NumberOfSectionReferences:          0 NumberOfPfnReferences:          13\n    NumberOfMappedViews:                2 NumberOfUserReferences:          2\n    WaitingForDeletion Event:  00000000\n    Control Flags: Accessed: 1, File: 1, Image: 1\n    FileObject @fffffa8000c074d0, Name: \\Windows\\System32\\basesrv.dll\n    First prototype PTE: fffff8a000c45c58 Last contiguous PTE: fffffffffffffffc\n    Flags2: Inherit: 1\n```\n\n>For more information on the VAD, see BDG's The VAD Tree: A Process-Eye View of Physical Memory.\n\nVAD\u306e\u8a73\u3057\u3044\u60c5\u5831\u306b\u3064\u3044\u3066\u306f\u3001\"BDG's The VAD Tree: A Process-Eye View of Physical Memory\"\u3092\u53c2\u7167\u3002\n\n## vadwalk\n\n>To inspect a process's VAD nodes in table form, use the vadwalk command.\n\nvadwalk\u3067\u3001\u30d7\u30ed\u30bb\u30b9\u306eVAD\u30ce\u30fc\u30c9\u3092\u8868\u5f62\u5f0f\u3067\u8868\u793a\u3067\u304d\u308b\u3002\n\n```\n$ python vol.py -f ~/Desktop/win7_trial_64bit.raw --profile=Win7SP0x64 vadwalk -p 296\nVolatility Foundation Volatility Framework 2.4\n************************************************************************\nPid:    296\nAddress            Parent             Left               Right              Start              End                Tag\n------------------ ------------------ ------------------ ------------------ ------------------ ------------------ ----\n0xfffffa8000c00620 0x0000000000000000 0xfffffa8000deaa40 0xfffffa8000c043d0 0x000000007f0e0000 0x000000007ffdffff VadS\n0xfffffa8000deaa40 0xfffffa8000c00620 0xfffffa8000bc4660 0xfffffa80011b8d80 0x0000000000ae0000 0x0000000000b1ffff VadS\n0xfffffa8000bc4660 0xfffffa8000deaa40 0xfffffa8000c04260 0xfffffa8000c91010 0x00000000004d0000 0x0000000000650fff Vadm\n0xfffffa8000c04260 0xfffffa8000bc4660 0xfffffa8000c82010 0xfffffa80012acce0 0x00000000002a0000 0x000000000039ffff VadS\n0xfffffa8000c82010 0xfffffa8000c04260 0xfffffa8000cbce80 0xfffffa8000c00330 0x00000000001f0000 0x00000000001f0fff Vadm\n0xfffffa8000cbce80 0xfffffa8000c82010 0xfffffa8000bc4790 0xfffffa8000d9bb80 0x0000000000180000 0x0000000000181fff Vad\n0xfffffa8000bc4790 0xfffffa8000cbce80 0xfffffa8000c00380 0xfffffa8000e673a0 0x0000000000100000 0x0000000000166fff Vad\n0xfffffa8000c00380 0xfffffa8000bc4790 0x0000000000000000 0x0000000000000000 0x0000000000000000 0x00000000000fffff VadS\n[snip]\n```\n\n## vadtree\n\n>To display the VAD nodes in a visual tree form, use the vadtree command.\n\nvadtree\u3067\u306f\u3001VAD\u30ce\u30fc\u30c9\u3092\u30c4\u30ea\u30fc\u5f62\u5f0f\u3067\u8868\u793a\u3067\u304d\u308b\u3002\n\n```\n$ python vol.py -f ~/Desktop/win7_trial_64bit.raw --profile=Win7SP0x64 vadtree -p 296\nVolatility Foundation Volatility Framework 2.4\n************************************************************************\nPid:    296\n 0x000000007f0e0000 - 0x000000007ffdffff\n  0x0000000000ae0000 - 0x0000000000b1ffff\n   0x00000000004d0000 - 0x0000000000650fff\n    0x00000000002a0000 - 0x000000000039ffff\n     0x00000000001f0000 - 0x00000000001f0fff\n      0x0000000000180000 - 0x0000000000181fff\n       0x0000000000100000 - 0x0000000000166fff\n        0x0000000000000000 - 0x00000000000fffff\n        0x0000000000170000 - 0x0000000000170fff\n       0x00000000001a0000 - 0x00000000001a1fff\n        0x0000000000190000 - 0x0000000000190fff\n        0x00000000001b0000 - 0x00000000001effff\n      0x0000000000240000 - 0x000000000024ffff\n       0x0000000000210000 - 0x0000000000216fff\n        0x0000000000200000 - 0x000000000020ffff\n[snip]\n```\n\n>If you want to view the balanced binary tree in Graphviz format, just add --output=dot --output-file=graph.dot to your command. Then you can open graph.dot in any Graphviz-compatible viewer. This plugin also supports color coding the output based on the regions that contain stacks, heaps, mapped files, DLLs, etc. A partial example is shown below using Omnigraffle:\n\nGraphviza\u5f62\u5f0f\u3067\u3001\u30d0\u30e9\u30f3\u30b9\u3055\u308c\u305f\u30c4\u30ea\u30fc\u3067\u8868\u793a\u3055\u305b\u305f\u3051\u308c\u3070\u3001-output=dot --output-file=graph.dot\u30aa\u30d7\u30b7\u30e7\u30f3\u3092\u6307\u5b9a\u3059\u308b\u3002\u305d\u3046\u3059\u308c\u3070\u3001Graphviz\u4e92\u63db\u30d3\u30e5\u30a2\u30fc\u3067\u958b\u304f\u3053\u3068\u304c\u3067\u304d\u308b\u3002\u30b9\u30bf\u30c3\u30af\u3001\u30d2\u30fc\u30d7\u3001\u30de\u30c3\u30d7\u30c9\u30d5\u30a1\u30a4\u30eb\u3001DLL\u306a\u3069\u306e\u9818\u57df\u3067\u51fa\u529b\u306e\u8272\u3092\u5909\u3048\u308b\u8a2d\u5b9a\u3082\u30b5\u30dd\u30fc\u30c8\u3057\u3066\u3044\u308b\u3002Omnigraffle\u3092\u4f7f\u3063\u305f\u90e8\u5206\u7684\u306a\u4f8b\u3002\n\n\u753b\u50cf\"VADTree with Dot output\"\n\n>Fillcolor Legend:\n\n\u30d5\u30eb\u30ab\u30e9\u30fc\u306e\u51e1\u4f8b\n\n>* Red: Heaps\n* Gray: DLLs\n* Green: Stacks\n* Yellow: Mapped Files\n\n* \u8d64\uff1a\u30d2\u30fc\u30d7\n* \u30b0\u30ec\u30fc\uff1aDLL\n* \u7dd1\uff1a\u30b9\u30bf\u30c3\u30af\n* \u9ec3\uff1a\u30de\u30c3\u30d7\u30c9\u30d5\u30a1\u30a4\u30eb\n\n## vaddump\n\n>To extract the range of pages described by a VAD node, use the vaddump command. This is similar to memdump, except the pages belonging to each VAD node are placed in separate files (named according to the starting and ending addresses) instead of one large conglomerate file. If any pages in the range are not memory resident, they're padded with 0's using the address space's zread() method.\n\nvaddump\u30b3\u30de\u30f3\u30c9\u306f\u3001VAD\u30ce\u30fc\u30c9\u306e\u9818\u57df\u306b\u3042\u308b\u30da\u30fc\u30b8\u3092\u51fa\u529b\u3059\u308b\u3002\n\u8907\u5408\u3057\u305f\u5927\u304d\u306a1\u30d5\u30a1\u30a4\u30eb\u306e\u4ee3\u308f\u308a\u306b\u5404VAD\u30ce\u30fc\u30c9\u306b\u5c5e\u3059\u308b\u30da\u30fc\u30b8\u304c\u5206\u5272\u3055\u308c\u305f\u30d5\u30a1\u30a4\u30eb(\u958b\u59cb\u30fb\u7d42\u4e86\u30a2\u30c9\u30ec\u30b9\u306b\u3088\u308b\u30d5\u30a1\u30a4\u30eb\u540d)\u306b\u306a\u308b\u3053\u3068\u4ee5\u5916\u306fmemdump\u306b\u4f3c\u3066\u3044\u308b\u3002\u7269\u7406\u30e1\u30e2\u30ea\u306b\u3069\u306e\u30da\u30fc\u30b8\u3082\u306a\u3044\u5834\u5408\u3001\u30a2\u30c9\u30ec\u30b9\u7a7a\u9593\u306ezread()\u30e1\u30bd\u30c3\u30c9\u306b\u3088\u3063\u30660\u3067\u30d1\u30c7\u30a3\u30f3\u30b0\u3055\u308c\u308b\u3002\n\n```\n$ python vol.py -f ~/Desktop/win7_trial_64bit.raw --profile=Win7SP0x64 vaddump -D vads\nVolatility Foundation Volatility Framework 2.4\nPid        Process              Start              End                Result\n---------- -------------------- ------------------ ------------------ ------\n         4 System               0x0000000076d40000 0x0000000076eeafff vads/System.17fef9e0.0x0000000076d40000-0x0000000076eeafff.dmp\n         4 System               0x0000000000040000 0x0000000000040fff vads/System.17fef9e0.0x0000000000040000-0x0000000000040fff.dmp\n         4 System               0x0000000000010000 0x0000000000032fff vads/System.17fef9e0.0x0000000000010000-0x0000000000032fff.dmp\n         4 System               0x000000007ffe0000 0x000000007ffeffff vads/System.17fef9e0.0x000000007ffe0000-0x000000007ffeffff.dmp\n         4 System               0x0000000076f20000 0x000000007709ffff vads/System.17fef9e0.0x0000000076f20000-0x000000007709ffff.dmp\n       208 smss.exe             0x000000007efe0000 0x000000007ffdffff vads/smss.exe.176e97f0.0x000000007efe0000-0x000000007ffdffff.dmp\n       208 smss.exe             0x00000000003d0000 0x00000000004cffff vads/smss.exe.176e97f0.0x00000000003d0000-0x00000000004cffff.dmp\n       208 smss.exe             0x0000000000100000 0x0000000000100fff vads/smss.exe.176e97f0.0x0000000000100000-0x0000000000100fff.dmp\n       208 smss.exe             0x0000000000000000 0x00000000000fffff vads/smss.exe.176e97f0.0x0000000000000000-0x00000000000fffff.dmp\n       208 smss.exe             0x0000000000190000 0x000000000020ffff vads/smss.exe.176e97f0.0x0000000000190000-0x000000000020ffff.dmp\n       208 smss.exe             0x0000000047a90000 0x0000000047aaffff vads/smss.exe.176e97f0.0x0000000047a90000-0x0000000047aaffff.dmp\n       208 smss.exe             0x00000000005e0000 0x000000000065ffff vads/smss.exe.176e97f0.0x00000000005e0000-0x000000000065ffff.dmp\n[snip]\n\n$ ls -al vads/\ntotal 123720\ndrwxr-xr-x  69 michaelligh  staff      2346 Apr  6 13:12 .\ndrwxr-xr-x  37 michaelligh  staff      1258 Apr  6 13:11 ..\n-rw-r--r--   1 michaelligh  staff    143360 Apr  6 13:12 System.17fef9e0.0x0000000000010000-0x0000000000032fff.dmp\n-rw-r--r--   1 michaelligh  staff      4096 Apr  6 13:12 System.17fef9e0.0x0000000000040000-0x0000000000040fff.dmp\n-rw-r--r--   1 michaelligh  staff   1748992 Apr  6 13:12 System.17fef9e0.0x0000000076d40000-0x0000000076eeafff.dmp\n-rw-r--r--   1 michaelligh  staff   1572864 Apr  6 13:12 System.17fef9e0.0x0000000076f20000-0x000000007709ffff.dmp\n-rw-r--r--   1 michaelligh  staff     65536 Apr  6 13:12 System.17fef9e0.0x000000007ffe0000-0x000000007ffeffff.dmp\n-rw-r--r--   1 michaelligh  staff   1048576 Apr  6 13:12 csrss.exe.176006c0.0x0000000000000000-0x00000000000fffff.dmp\n-rw-r--r--   1 michaelligh  staff    421888 Apr  6 13:12 csrss.exe.176006c0.0x0000000000100000-0x0000000000166fff.dmp\n-rw-r--r--   1 michaelligh  staff      4096 Apr  6 13:12 csrss.exe.176006c0.0x0000000000170000-0x0000000000170fff.dmp\n-rw-r--r--   1 michaelligh  staff      8192 Apr  6 13:12 csrss.exe.176006c0.0x0000000000180000-0x0000000000181fff.dmp\n[snip]\n```\n\n>The files are named like this:\n\n\u30d5\u30a1\u30a4\u30eb\u540d\u3092\u3053\u306e\u3088\u3046\u306b\u306a\u308b\uff1a\n\n>ProcessName.PhysicalOffset.StartingVPN.EndingVPN.dmp\n\n\u30d7\u30ed\u30bb\u30b9\u540d.\u7269\u7406\u30aa\u30d5\u30bb\u30c3\u30c8.\u958b\u59cbVPN.\u7d42\u4e86VPN.dmp\n\n>The reason the PhysicalOffset field exists is so you can distinguish between two processes with the same name.\n\n\u540c\u3058\u540d\u79f0\u306e\u30d7\u30ed\u30bb\u30b9\u3092\u8b58\u5225\u3059\u308b\u305f\u3081\u306b\u7269\u7406\u30aa\u30d5\u30bb\u30c3\u30c8\u6b04\u304c\u3042\u308b\n\n## evtlogs\n\n>The evtlogs command extracts and parses binary event logs from memory. Binary event logs are found on Windows XP and 2003 machines, therefore this plugin only works on these architectures. These files are extracted from VAD of the services.exe process, parsed and dumped to a specified location.\n\nevtlogs\u30b3\u30de\u30f3\u30c9\u306f\u3001\u30e1\u30e2\u30ea\u4e0a\u306e\u30d0\u30a4\u30ca\u30ea\u30a4\u30d9\u30f3\u30c8\u30ed\u30b0\u3092\u62bd\u51fa\u3059\u308b\u3002\u30d0\u30a4\u30ca\u30ea\u30a4\u30d9\u30f3\u30c8\u30ed\u30b0\u306fWindows XP\u30682003\u306b\u5b58\u5728\u3059\u308b\u306e\u3067\u3001\u3053\u308c\u3089\u306e\u30a2\u30fc\u30ad\u30c6\u30af\u30c1\u30e3\u4e0a\u3067\u306e\u307f\u6709\u52b9\u3067\u3042\u308b\u3002service.exe\u30d7\u30ed\u30bb\u30b9\u306eVAD\u304b\u3089\u62bd\u51fa\u3001\u30d1\u30fc\u30b9\u3055\u308c\u3066\u6307\u5b9a\u3055\u308c\u305f\u5834\u6240\u306b\u51fa\u529b\u3055\u308c\u308b\u3002\n\n```\n$ python vol.py -f WinXPSP1x64.vmem --profile=WinXPSP2x64 evtlogs -D output\nVolatility Foundation Volatility Framework 2.4\nParsed data sent to appevent.txt\nParsed data sent to secevent.txt\nParsed data sent to sysevent.txt\n```\n\n>There is also an option (--save-evt) to dump raw event logs for parsing with external tools:\n\n\u5225\u306e\u30c4\u30fc\u30eb\u3067\u30d1\u30fc\u30b9\u3059\u308b\u305f\u3081\u306b\u3001\u30d1\u30fc\u30b9\u524d\u306e\u30c0\u30f3\u30d7\u3092\u884c\u3046\u30aa\u30d7\u30b7\u30e7\u30f3\u304c\u3042\u308b\u3002(--save-evt)\n\n```\n$ python vol.py -f WinXPSP1x64.vmem --profile=WinXPSP2x64 evtlogs\n--save-evt -D output\nVolatility Foundation Volatility Framework 2.4\nSaved raw .evt file to appevent.evt\nParsed data sent to appevent.txt\nSaved raw .evt file to secevent.evt\nParsed data sent to secevent.txt\nSaved raw .evt file to sysevent.evt\nParsed data sent to sysevent.txt\nParsed output is pipe delimited to make it easier to import into excel files and the \"messages\" are separated by semicolons:\n\n$ cat output/secevent.txt\n\n2012-01-17 12:01:27|secevent.evt|MACHINENAME|S-1-5-18 (Local System)|Security|612|Success|-;-;+;-;-;-;-;-;-;-;-;-;-;-;-;-;+;-;MACHINENAME$;;(0x0,0x3E7)\n2012-01-17 17:06:18|secevent.evt|MACHINENAME|S-1-5-19 (NT Authority)|Security|528|Success|LOCAL SERVICE;NT AUTHORITY;(0x0,0x3E5);5;Advapi;Negotiate;;-;MACHINENAME$(0x0,0x3E7);252;-;-;-\n2012-01-17 17:06:18|secevent.evt|MACHINENAME|S-1-5-19 (NT Authority)|Security|576|Success|LOCAL SERVICE;NT AUTHORITY;(0x0,0x3E5);SeAuditPrivilege            SeAssignPrimaryTokenPrivilege                   SeImpersonatePrivilege\n2012-01-17 17:06:19|secevent.evt|MACHINENAME|S-1-5-20 (NT Authority)|Security|528|Success|NETWORK SERVICE;NT AUTHORITY;(0x0,0x3E4);5;Advapi;Negotiate;;-;MACHINENAME$(0x0,0x3E7);252;-;-;-\n2012-01-17 17:06:19|secevent.evt|MACHINENAME|S-1-5-20 (NT Authority)|Security|576|Success|NETWORK SERVICE;NTAUTHORITY;(0x0,0x3E4);SeAuditPrivilege                  SeAssignPrimaryTokenPrivilege                   SeImpersonatePrivilege\n\n[snip]\n```\n\n>If the --verbose flag is used, SIDs are also evaluated and placed in the parsed output instead of the defaulting raw SID. This action takes longer to run, since the plugin has to calculate each of the service SID and user SID from registry entries.\n\n--verbose\u30aa\u30d7\u30b7\u30e7\u30f3\u304c\u6307\u5b9a\u3055\u308c\u308b\u3068\u3001\u65e2\u5b9a\u306e\u52a0\u5de5\u3057\u3066\u3044\u306a\u3044SID\u306e\u4ee3\u308f\u308a\u306bSID\u304c\u8a55\u4fa1\u3055\u308c\u3066\u8868\u793a\u3055\u308c\u308b\u3002\u3053\u306e\u52d5\u4f5c\u306b\u306f\u6bd4\u8f03\u3059\u308b\u3068\u9577\u3044\u6642\u9593\u304c\u304b\u304b\u308b\u304c\u3001\u5404\u30b5\u30fc\u30d3\u30b9SID\u3068\u30e6\u30fc\u30b6SID\u3092\u30ec\u30b8\u30b9\u30c8\u30ea\u30a8\u30f3\u30c8\u30ea\u304b\u3089\u8a08\u7b97\u3057\u3066\u3044\u308b\u305f\u3081\u3067\u3059\u3002\n\n## iehistory\n\n>This plugin recovers fragments of IE history index.dat cache files. It can find basic accessed links (via FTP or HTTP), redirected links (--REDR), and deleted entries (--LEAK). It applies to any process which loads and uses the wininet.dll library, not just Internet Explorer. Typically that includes Windows Explorer and even malware samples. For more information, see HowTo: Scan for Internet Cache/History and URLs.\n\n\u3053\u306e\u30d7\u30e9\u30b0\u30a4\u30f3\u306f\u3001IE\u5c65\u6b74\u306eindex.dat\u30ad\u30e3\u30c3\u30b7\u30e5\u30d5\u30a1\u30a4\u30eb\u306e\u65ad\u7247\u3092\u4fee\u5fa9\u3057\u307e\u3059\u3002\u666e\u901a\u306e\u30a2\u30af\u30bb\u30b9(FTP\u304bHTTP\u306b\u3088\u308b)\u3001\u30ea\u30c0\u30a4\u30ec\u30af\u30c8\u30ea\u30f3\u30af(--REDR)\u3001\u524a\u9664\u3055\u308c\u305f\u30a8\u30f3\u30c8\u30ea(--LEAK)\u3092\u898b\u3064\u3051\u308b\u3053\u3068\u304c\u3067\u304d\u307e\u3059\u3002IE\u3060\u3051\u3067\u306f\u306a\u304f\u3001wininet.dll\u30e9\u30a4\u30d6\u30e9\u30ea\u3092\u30ed\u30fc\u30c9\u3057\u3066\u5229\u7528\u3057\u3066\u3044\u308b\u3059\u3079\u3066\u306e\u30d7\u30ed\u30bb\u30b9\u306b\u9069\u7528\u3055\u308c\u307e\u3059\u3002\u4e00\u822c\u7684\u306b\u3001Windows Explorer\u3068\u30de\u30eb\u30a6\u30a7\u30a2\u30b5\u30f3\u30d7\u30eb\u3092\u542b\u307f\u307e\u3059\u3002\n\n```\n$ python vol.py -f exemplar17_1.vmem iehistory\nVolatility Foundation Volatility Framework 2.4\n**************************************************\nProcess: 1928 explorer.exe\nCache type \"URL \" at 0xf25100\nRecord length: 0x100\nLocation: Visited: foo@http://192.168.30.129/malware/40024.exe\nLast modified: 2009-01-08 01:52:09\nLast accessed: 2009-01-08 01:52:09\nFile Offset: 0x100, Data Offset: 0x0, Data Length: 0xa0\n**************************************************\nProcess: 1928 explorer.exe\nCache type \"URL \" at 0xf25300\nRecord length: 0x180\nLocation: Visited: foo@http://www.abcjmp.com/jump1/?affiliate=mu1&subid=88037&terms=eminem&sid=Z605044303%40%40wMfNTNxkTM1EzX5QzNy81My8lM18FN4gTM2gzNzITM&a=zh5&mr=1&rc=0\nLast modified: 2009-01-08 01:52:44\nLast accessed: 2009-01-08 01:52:44\nFile Offset: 0x180, Data Offset: 0x0, Data Length: 0x108\n**************************************************\n.....\n```\n\n# Kernel Memory and Objects\n\n## modules\n\n>To view the list of kernel drivers loaded on the system, use the modules command. This walks the doubly-linked list of LDR_DATA_TABLE_ENTRY structures pointed to by PsLoadedModuleList. Similar to the pslist command, this relies on finding the KDBG structure. In rare cases, you may need to use kdbgscan to find the most appropriate KDBG structure address and then supply it to this plugin like --kdbg=ADDRESS.\n```\n\nmodules\u30b3\u30de\u30f3\u30c9\u306b\u3088\u3063\u3066\u3001\u30b7\u30b9\u30c6\u30e0\u306b\u30ed\u30fc\u30c9\u3055\u308c\u3066\u3044\u305f\u30ab\u30fc\u30cd\u30eb\u30c9\u30e9\u30a4\u30d0\u306e\u30ea\u30b9\u30c8\u3092\u5f97\u308b\u3053\u3068\u304c\u3067\u307e\u3059\u3002PsLoadedModuleList\u304c\u793a\u3059\u3001LDR_DATA_TABLE_ENTRY\u69cb\u9020\u4f53\u306e\u30c0\u30d6\u30eb\u30ea\u30f3\u30af\u30ea\u30b9\u30c8\u3092\u8fbf\u308a\u307e\u3059\u3002pslist\u30b3\u30de\u30f3\u30c9\u3068\u540c\u69d8\u306b\u3001KDBG\u69cb\u9020\u4f53\u3092\u983c\u308a\u306b\u3057\u307e\u3059\u3002\u30ec\u30a2\u30b1\u30fc\u30b9\u3067\u306f\u3001\u6700\u3082\u9069\u5207\u306aKDBG\u69cb\u9020\u4f53\u306e\u30a2\u30c9\u30ec\u30b9\u3092kdbgscan\u3067\u898b\u3064\u3051\u3066\u3001--kdbg=ADDRESS\u3068\u3044\u3046\u3088\u3046\u306b\u4e0e\u3048\u308b\u5fc5\u8981\u304c\u3042\u308b\u304b\u3082\u3057\u308c\u307e\u305b\u3093\u3002\n\n>It cannot find hidden/unlinked kernel drivers, however modscan serves that purpose. Also, since this plugin uses list walking techniques, you typically can assume that the order the modules are displayed in the output is the order they were loaded on the system. For example, below, ntoskrnl.exe was first to load, followed by hal.dll, etc.\n\n\u96a0\u853d\u3055\u308c\u305f\uff0f\u30ea\u30f3\u30af\u3092\u5916\u3055\u308c\u305f\u30ab\u30fc\u30cd\u30eb\u30c9\u30e9\u30a4\u30d0\u3092\u898b\u3064\u3051\u308b\u3053\u3068\u306f\u3067\u304d\u307e\u305b\u3093\u304c\u3001modscan\u304c\u305d\u306e\u305f\u3081\u306b\u4f7f\u3048\u307e\u3059\u3002\u30c0\u30d6\u30eb\u30ea\u30f3\u30af\u30ea\u30b9\u30c8\u3092\u305f\u3069\u308b\u305f\u3081\u3001\u901a\u5e38\u30b7\u30b9\u30c6\u30e0\u306b\u30ed\u30fc\u30c9\u3055\u308c\u305f\u9806\u756a\u306b\u8868\u793a\u3055\u308c\u3066\u3044\u308b\u3068\u8003\u3048\u308b\u3053\u3068\u304c\u53ef\u80fd\u3067\u3059\u3002\u4f8b\u3048\u3070\u3001\u4e0b\u306e\u4f8b\u306b\u3042\u308b\u3088\u3046\u306b\u3001ntoskrnl.exe\u304c\u6700\u521d\u306b\u30ed\u30fc\u30c9\u3055\u308c\u3001\u305d\u306e\u5f8c\u304chal.dll\u3068\u306a\u3063\u3066\u3044\u308b\u3088\u3046\u306b\u3067\u3059\u3002\n\n```\n$ python vol.py -f ~/Desktop/win7_trial_64bit.raw --profile=Win7SP0x64 modules\nVolatility Foundation Volatility Framework 2.4\nOffset(V)          Name                 Base                             Size File\n------------------ -------------------- ------------------ ------------------ ----\n0xfffffa80004a11a0 ntoskrnl.exe         0xfffff8000261a000           0x5dd000 \\SystemRoot\\system32\\ntoskrnl.exe\n0xfffffa80004a10b0 hal.dll              0xfffff80002bf7000            0x49000 \\SystemRoot\\system32\\hal.dll\n0xfffffa80004a7950 kdcom.dll            0xfffff80000bb4000             0xa000 \\SystemRoot\\system32\\kdcom.dll\n0xfffffa80004a7860 mcupdate.dll         0xfffff88000c3a000            0x44000 \\SystemRoot\\system32\\mcupdate_GenuineIntel.dll\n0xfffffa80004a7780 PSHED.dll            0xfffff88000c7e000            0x14000 \\SystemRoot\\system32\\PSHED.dll\n0xfffffa80004a7690 CLFS.SYS             0xfffff88000c92000            0x5e000 \\SystemRoot\\system32\\CLFS.SYS\n0xfffffa80004a8010 CI.dll               0xfffff88000cf0000            0xc0000 \\SystemRoot\\system32\\CI.dll\n[snip]\n```\n\n>The output shows the offset of the LDR_DATA_TABLE_ENTRY structure, which is a virtual address by default but can be specified as a physical address with the -P switch as shown below. In either case, the Base column is the virtual address of the module's base in kernel memory (where you'd expect to find the PE header).\n\n\u3053\u306e\u51fa\u529b\u3067\u306f\u3001LDR_DATA_TABLE_ENTRY\u69cb\u9020\u4f53\u306e\u30aa\u30d5\u30bb\u30c3\u30c8\u304c\u30c7\u30d5\u30a9\u30eb\u30c8\u3067\u306f\u4eee\u60f3\u30a2\u30c9\u30ec\u30b9\u3067\u8868\u793a\u3055\u308c\u3066\u3044\u307e\u3059\u304c\u3001\u4e0b\u306e\u4f8b\u306b\u3042\u308b\u3088\u3046\u306b\u3001-P\u30b9\u30a4\u30c3\u30c1\u3067\u7269\u7406\u30a2\u30c9\u30ec\u30b9\u3092\u8868\u793a\u3055\u305b\u308b\u3088\u3046\u306b\u3059\u308b\u3053\u3068\u3082\u53ef\u80fd\u3067\u3059\u3002\u3069\u3061\u3089\u306e\u5834\u5408\u3067\u3082Base\u30ab\u30e9\u30e0\u306f\u3001\u30ab\u30fc\u30cd\u30eb\u30e1\u30e2\u30ea\u5185\u3067\u306e\u30e2\u30b8\u30e5\u30fc\u30eb\u306e\u4eee\u60f3\u30d9\u30fc\u30b9\u30a2\u30c9\u30ec\u30b9\u3067\u3059(PE\u30d8\u30c3\u30c0\u3067\u898b\u3064\u3051\u3089\u308c\u308b)\u3002\n\n```\n$ python vol.py -f ~/Desktop/win7_trial_64bit.raw --profile=Win7SP0x64 modules -P\nVolatility Foundation Volatility Framework 2.4\nOffset(P)          Name                 Base                             Size File\n------------------ -------------------- ------------------ ------------------ ----\n0x0000000017fe01a0 ntoskrnl.exe         0xfffff8000261a000           0x5dd000 \\SystemRoot\\system32\\ntoskrnl.exe\n0x0000000017fe00b0 hal.dll              0xfffff80002bf7000            0x49000 \\SystemRoot\\system32\\hal.dll\n0x0000000017fe6950 kdcom.dll            0xfffff80000bb4000             0xa000 \\SystemRoot\\system32\\kdcom.dll\n0x0000000017fe6860 mcupdate.dll         0xfffff88000c3a000            0x44000 \\SystemRoot\\system32\\mcupdate_GenuineIntel.dll\n0x0000000017fe6780 PSHED.dll            0xfffff88000c7e000            0x14000 \\SystemRoot\\system32\\PSHED.dll\n0x0000000017fe6690 CLFS.SYS             0xfffff88000c92000            0x5e000 \\SystemRoot\\system32\\CLFS.SYS\n0x0000000017fe7010 CI.dll               0xfffff88000cf0000            0xc0000 \\SystemRoot\\system32\\CI.dll\n[snip]\n```\n\n## modscan\n\n>The modscan command finds LDR_DATA_TABLE_ENTRY structures by scanning physical memory for pool tags. This can pick up previously unloaded drivers and drivers that have been hidden/unlinked by rootkits. Unlike modules the order of results has no relationship with the order in which the drivers loaded. As you can see below, DumpIt.sys was found at the lowest physical offset, but it was probably one of the last drivers to load (since it was used to acquire memory).\n\nmodscan\u30b3\u30de\u30f3\u30c9\u306f\u3001\u7269\u7406\u30e1\u30e2\u30ea\u3067pool\u30bf\u30b0\u3092\u691c\u7d22\u3057\u3066LDR_DATA_TABLE_ENTRY\u69cb\u9020\u4f53\u3092\u898b\u3064\u3051\u307e\u3059\u3002\u3053\u308c\u306b\u3088\u308a\u3001\u30a2\u30f3\u30ed\u30fc\u30c9\u6e08\u307f\u306e\u30c9\u30e9\u30a4\u30d0\u3068\u30eb\u30fc\u30c8\u30ad\u30c3\u30c8\u306b\u3088\u308a\u96a0\u853d\uff0f\u30ea\u30f3\u30af\u3092\u5916\u3055\u308c\u305f\u30c9\u30e9\u30a4\u30d0\u3092\u898b\u3064\u3051\u308b\u3053\u3068\u304c\u53ef\u80fd\u3067\u3059\u3002modules\u30b3\u30de\u30f3\u30c9\u3068\u306f\u9055\u3044\u3001\u7d50\u679c\u306e\u9806\u756a\u306f\u30c9\u30e9\u30a4\u30d0\u304c\u30ed\u30fc\u30c9\u3055\u308c\u305f\u9806\u756a\u3068\u306f\u95a2\u4fc2\u304c\u3042\u308a\u307e\u305b\u3093\u3002\u4e0b\u306e\u4f8b\u3067\u5206\u304b\u308b\u3088\u3046\u306b\u3001DumpIt.sys\u304c\u6700\u3082\u4f4e\u3044\u7269\u7406\u30aa\u30d5\u30bb\u30c3\u30c8\u3067\u898b\u3064\u304b\u308a\u307e\u3057\u305f\u304c\u3001\u304a\u305d\u3089\u304f\u6700\u3082\u6700\u8fd1\u30ed\u30fc\u30c9\u3055\u308c\u305f\u30c9\u30e9\u30a4\u30d0\u306e\u4e00\u3064\u3067\u3059(\u30e1\u30e2\u30ea\u30c0\u30f3\u30d7\u306e\u305f\u3081\u306b\u4f7f\u308f\u308c\u305f\u30c9\u30e9\u30a4\u30d0\u306a\u306e\u3067)\u3002\n\n```\n$ python vol.py -f ~/Desktop/win7_trial_64bit.raw --profile=Win7SP0x64 modscan\nVolatility Foundation Volatility Framework 2.4\nOffset(P)          Name                 Base                             Size File\n------------------ -------------------- ------------------ ------------------ ----\n0x00000000173b90b0 DumpIt.sys           0xfffff88003980000            0x11000 \\??\\C:\\Windows\\SysWOW64\\Drivers\\DumpIt.sys\n0x000000001745b180 mouhid.sys           0xfffff880037e9000             0xd000 \\SystemRoot\\system32\\DRIVERS\\mouhid.sys\n0x0000000017473010 lltdio.sys           0xfffff88002585000            0x15000 \\SystemRoot\\system32\\DRIVERS\\lltdio.sys\n0x000000001747f010 rspndr.sys           0xfffff8800259a000            0x18000 \\SystemRoot\\system32\\DRIVERS\\rspndr.sys\n0x00000000174cac40 dxg.sys              0xfffff96000440000            0x1e000 \\SystemRoot\\System32\\drivers\\dxg.sys\n0x0000000017600190 monitor.sys          0xfffff8800360c000             0xe000 \\SystemRoot\\system32\\DRIVERS\\monitor.sys\n0x0000000017601170 HIDPARSE.SYS         0xfffff880037de000             0x9000 \\SystemRoot\\system32\\DRIVERS\\HIDPARSE.SYS\n0x0000000017604180 USBD.SYS             0xfffff880037e7000             0x2000 \\SystemRoot\\system32\\DRIVERS\\USBD.SYS\n0x0000000017611d70 cdrom.sys            0xfffff88001944000            0x2a000 \\SystemRoot\\system32\\DRIVERS\\cdrom.sys\n[snip]\n```\n\n## moddump\n\n>To extract a kernel driver to a file, use the moddump command. Supply the output directory with -D or --dump-dir=DIR. Without any additional parameters, all drivers identified by modlist will be dumped. If you want a specific driver, supply a regular expression of the driver's name with --regex=REGEX or the module's base address with --base=BASE.\n\nmoddump\u30b3\u30de\u30f3\u30c9\u306f\u3001\u30ab\u30fc\u30cd\u30eb\u30c9\u30e9\u30a4\u30d0\u3092\u30d5\u30a1\u30a4\u30eb\u306b\u51fa\u529b\u3057\u307e\u3059\u3002-D\u3082\u3057\u304f\u306f--dump-dir=DIR\u30aa\u30d7\u30b7\u30e7\u30f3\u3067\u51fa\u529b\u30c7\u30a3\u30ec\u30af\u30c8\u30ea\u3092\u6307\u5b9a\u3057\u307e\u3059\u3002\u30d1\u30e9\u30e1\u30fc\u30bf\u306e\u6307\u5b9a\u3057\u306a\u3044\u3068modlist\u3067\u8b58\u5225\u3055\u308c\u305f\u3059\u3079\u3066\u306e\u30c9\u30e9\u30a4\u30d0\u304c\u51fa\u529b\u3055\u308c\u307e\u3059\u3002\u7279\u5b9a\u306e\u30c9\u30e9\u30a4\u30d0\u3092\u51fa\u529b\u3057\u305f\u3044\u5834\u5408\u3001--regex=REGEX\u30aa\u30d7\u30b7\u30e7\u30f3\u3067\u30c9\u30e9\u30a4\u30d0\u306e\u540d\u524d\u3092\u6b63\u898f\u8868\u73fe\u3067\u6307\u5b9a\u3059\u308b\u304b\u3001--base=BASE\u30aa\u30d7\u30b7\u30e7\u30f3\u3067\u30e2\u30b8\u30e5\u30fc\u30eb\u306e\u30d9\u30fc\u30b9\u30a2\u30c9\u30ec\u30b9\u3092\u6307\u5b9a\u3057\u307e\u3059\u3002\n\n>For more information, see BDG's Plugin Post: Moddump.\n\n\u66f4\u306b\u8a73\u3057\u3044\u60c5\u5831\u306f\u3001BDG\u306e\u30d7\u30e9\u30b0\u30a4\u30f3\u30dd\u30b9\u30c8\u3092\u53c2\u7167\u3057\u3066\u304f\u3060\u3055\u3044\u3002\n\n```\n$ python vol.py -f ~/Desktop/win7_trial_64bit.raw --profile=Win7SP0x64 moddump -D drivers/\nVolatility Foundation Volatility Framework 2.4\nModule Base        Module Name          Result\n------------------ -------------------- ------\n0xfffff8000261a000 ntoskrnl.exe         OK: driver.fffff8000261a000.sys\n0xfffff80002bf7000 hal.dll              OK: driver.fffff80002bf7000.sys\n0xfffff88000e5c000 intelide.sys         OK: driver.fffff88000e5c000.sys\n0xfffff8800349b000 mouclass.sys         OK: driver.fffff8800349b000.sys\n0xfffff88000f7c000 msisadrv.sys         OK: driver.fffff88000f7c000.sys\n0xfffff880035c3000 ndistapi.sys         OK: driver.fffff880035c3000.sys\n0xfffff88002c5d000 pacer.sys            OK: driver.fffff88002c5d000.sys\n[snip]\n```\n\n>Similar to dlldump, if critical parts of the PE header are not memory resident, then rebuilding/extracting the driver may fail. Additionally, for drivers that are mapped in different sessions (like win32k.sys), there is currently no way to specify which session to use when acquiring the driver sample.\n\ndlldump\u3068\u540c\u69d8\u306b\u3001PE\u30d8\u30c3\u30c0\u306e\u30af\u30ea\u30c6\u30a3\u30ab\u30eb\u306a\u90e8\u5206\u304c\u30e1\u30e2\u30ea\u306b\u8f09\u3063\u3066\u3044\u306a\u3044\u5834\u5408\u3001\u30c9\u30e9\u30a4\u30d0\u306e\u6700\u69cb\u6210\uff0f\u51fa\u529b\u306f\u5931\u6557\u3059\u308b\u304b\u3082\u3057\u308c\u307e\u305b\u3093\u3002\u66f4\u306b\u3001(win32k.sys\u306e\u3088\u3046\u306b)\u5225\u306e\u30bb\u30c3\u30b7\u30e7\u30f3\u306b\u30de\u30c3\u30d7\u3055\u308c\u305f\u30c9\u30e9\u30a4\u30d0\u306b\u95a2\u3057\u3066\u306f\u3001\u73fe\u5728\u3069\u306e\u30bb\u30c3\u30b7\u30e7\u30f3\u3092\u4f7f\u3063\u3066\u30c9\u30e9\u30a4\u30d0\u3092\u53d6\u5f97\u3059\u308b\u304b\u3092\u6307\u5b9a\u3059\u308b\u3053\u3068\u306f\u3067\u304d\u307e\u305b\u3093\u3002\n\n## ssdt\n\n>To list the functions in the Native and GUI SSDTs, use the ssdt command. This displays the index, function name, and owning driver for each entry in the SSDT. Please note the following:\nWindows has 4 SSDTs by default (you can add more with KeAddSystemServiceTable), but only 2 of them are used - one for Native functions in the NT module, and one for GUI functions in the win32k.sys module.\n\nssdt\u30b3\u30de\u30f3\u30c9\u306f\u3001\u30cd\u30a4\u30c6\u30a3\u30d6\u3068GUI SSDT\u3092\u8868\u793a\u3057\u307e\u3059\u3002\u305d\u308c\u305e\u308c\u306eSSDT\u30a8\u30f3\u30c8\u30ea\u306e\u30a4\u30f3\u30c7\u30c3\u30af\u30b9\u3001\u95a2\u6570\u540d\u3001\u30c9\u30e9\u30a4\u30d0\u3092\u8868\u793a\u3057\u307e\u3059\u3002\u4ee5\u4e0b\u306e\u3053\u3068\u306b\u6ce8\u610f\u3057\u3066\u304f\u3060\u3055\u3044\u3002Windows\u306f\u30c7\u30d5\u30a9\u30eb\u30c8\u30674\u3064\u306eSSDT\u3092\u6301\u3063\u3066\u3044\u307e\u3059\u304c\u30012\u3064\u306e\u307f\u304c\u4f7f\u7528\u3055\u308c\u3066\u3044\u307e\u3059\u3002NT\u30e2\u30b8\u30e5\u30fc\u30eb\u5185\u306e\u30cd\u30a4\u30c6\u30a3\u30d6\u95a2\u6570\u3068win32k.sys\u30e2\u30b8\u30e5\u30fc\u30eb\u5185\u306eGUI\u95a2\u6570\u3067\u3059\u3002\n\n>There are multiple ways to locate the SSDTs in memory. Most tools do it by finding the exported KeServiceDescriptorTable symbol in the NT module, but this is not the way Volatility works.\n\n\u30e1\u30e2\u30ea\u5185\u306eSSDT\u306e\u5834\u6240\u3092\u77e5\u308b\u306b\u306f\u3044\u304f\u3064\u304b\u306e\u65b9\u6cd5\u304c\u3042\u308a\u307e\u3059\u3002\u307b\u3068\u3093\u3069\u30c4\u30fc\u30eb\u306f\u3001NT\u30e2\u30b8\u30e5\u30fc\u30eb\u3067\u30a8\u30af\u30b9\u30dd\u30fc\u30c8\u3055\u308c\u3066\u3044\u308bKeServiceDescriptorTable\u30b7\u30f3\u30dc\u30eb\u3092\u898b\u3064\u3051\u3066\u5229\u7528\u3057\u307e\u3059\u304c\u3001Volatility\u306f\u5225\u306e\u65b9\u6cd5\u3092\u4f7f\u3044\u307e\u3059\u3002\n\n\n>For x86 systems, Volatility scans for ETHREAD objects (see the thrdscan command) and gathers all unique ETHREAD.Tcb.ServiceTable pointers. This method is more robust and complete, because it can detect when rootkits make copies of the existing SSDTs and assign them to particular threads. Also see the threads command.\n\nx86\u30b7\u30b9\u30c6\u30e0\u3067\u306f\u3001Volatility\u306fETHREAD\u30aa\u30d6\u30b8\u30a7\u30af\u30c8\u3092\u691c\u7d22\u3057(thrdscan\u30b3\u30de\u30f3\u30c9\u53c2\u7167)\u3001\u30e6\u30cb\u30fc\u30af\u306aETHREAD.Tcb.ServiceTable\u30dd\u30a4\u30f3\u30bf\u3092\u96c6\u3081\u307e\u3059\u3002\u3053\u306e\u65b9\u6cd5\u306f\u3001\u30eb\u30fc\u30c8\u30ad\u30c3\u30c8\u304cSSDT\u306e\u30b3\u30d4\u30fc\u3092\u4f5c\u6210\u3057\u3066\u7279\u5b9a\u306e\u30b9\u30ec\u30c3\u30c9\u306b\u5272\u308a\u5f53\u3066\u305f\u6642\u306b\u691c\u77e5\u3067\u304d\u308b\u305f\u3081\u3001\u3088\u308a\u5b89\u5b9a\u3057\u305f\u5b8c\u5168\u306a\u65b9\u6cd5\u3067\u3059\u3002threads\u30b3\u30de\u30f3\u30c9\u3092\u53c2\u7167\u3057\u3066\u304f\u3060\u3055\u3044\u3002\n\n>For x64 systems (which do not have an ETHREAD.Tcb.ServiceTable member) Volatility disassembles code in ntKeAddSystemServiceTable and finds its references to the KeServiceDescriptorTable and KeServiceDescriptorTableShadow symbols.\n\nx64\u30b7\u30b9\u30c6\u30e0(ETHREAD.Tcb.ServiceTable\u304c\u5b58\u5728\u3057\u307e\u305b\u3093)\u3067\u306f\u3001Volatility\u306fntKeAddSystemServiceTable\u5185\u306e\u30b3\u30fc\u30c9\u3092\u9006\u30a2\u30bb\u30f3\u30d6\u30eb\u3057\u3066KeServiceDescriptorTable\u3068KeServiceDescriptorTableShadow\u306e\u30b7\u30f3\u30dc\u30eb\u3078\u306e\u30ea\u30d5\u30a1\u30ec\u30f3\u30b9\u3092\u898b\u3064\u3051\u307e\u3059\u3002\n\n>The order and total number of functions in the SSDTs differ across operating system versions. Thus, Volatility stores the information in a per-profile (OS) dictionary which is auto-generated and cross-referenced using the ntoskrnl.exe, ntdll.dll, win32k.sys, user32.dll and gdi32.dll modules from the respective systems.\n\nSSDT\u5185\u306e\u95a2\u6570\u306e\u9806\u756a\u3068\u7dcf\u6570\u306f\u3001OS\u306e\u30d0\u30fc\u30b8\u30e7\u30f3\u306b\u3088\u3063\u3066\u7570\u306a\u308a\u307e\u3059\u3002\u305d\u306e\u305f\u3081\u3001Volatility\u306f\u3001\u500b\u5225\u306e\u30b7\u30b9\u30c6\u30e0\u306entoskrnl.exe\u3001ntdll.dll\u3001win32k.sys\u3001user32.dll\u304a\u3088\u3073gdi32.dll\u30e2\u30b8\u30e5\u30fc\u30eb\u3092\u4f7f\u3063\u3066\u76f8\u4e92\u30ea\u30d5\u30a1\u30ec\u30f3\u30b9\u3092\u81ea\u52d5\u751f\u6210\u3057\u305f\u30d7\u30ed\u30d5\u30a1\u30a4\u30eb(OS)\u3054\u3068\u306e\u8f9e\u66f8\u306b\u60c5\u5831\u3092\u51fa\u529b\u3057\u307e\u3059\u3002\n\n>For more information, see BDG's Auditing the System Call Table.\n\n```\n    $ python vol.py -f ~/Desktop/win7_trial_64bit.raw --profile=Win7SP0x64 ssdt\n    Volatility Foundation Volatility Framework 2.4\n    [x64] Gathering all referenced SSDTs from KeAddSystemServiceTable...\n    Finding appropriate address space for tables...\n    SSDT[0] at fffff8000268cb00 with 401 entries\n      Entry 0x0000: 0xfffff80002a9d190 (NtMapUserPhysicalPagesScatter) owned by ntoskrnl.exe\n      Entry 0x0001: 0xfffff80002983a00 (NtWaitForSingleObject) owned by ntoskrnl.exe\n      Entry 0x0002: 0xfffff80002683dd0 (NtCallbackReturn) owned by ntoskrnl.exe\n      Entry 0x0003: 0xfffff800029a6b10 (NtReadFile) owned by ntoskrnl.exe\n      Entry 0x0004: 0xfffff800029a4bb0 (NtDeviceIoControlFile) owned by ntoskrnl.exe\n      Entry 0x0005: 0xfffff8000299fee0 (NtWriteFile) owned by ntoskrnl.exe\n      Entry 0x0006: 0xfffff80002945dc0 (NtRemoveIoCompletion) owned by ntoskrnl.exe\n      Entry 0x0007: 0xfffff80002942f10 (NtReleaseSemaphore) owned by ntoskrnl.exe\n      Entry 0x0008: 0xfffff8000299ada0 (NtReplyWaitReceivePort) owned by ntoskrnl.exe\n      Entry 0x0009: 0xfffff80002a6ce20 (NtReplyPort) owned by ntoskrnl.exe\n\n    [snip]\n\n    SSDT[1] at fffff96000101c00 with 827 entries\n      Entry 0x1000: 0xfffff960000f5580 (NtUserGetThreadState) owned by win32k.sys\n      Entry 0x1001: 0xfffff960000f2630 (NtUserPeekMessage) owned by win32k.sys\n      Entry 0x1002: 0xfffff96000103c6c (NtUserCallOneParam) owned by win32k.sys\n      Entry 0x1003: 0xfffff96000111dd0 (NtUserGetKeyState) owned by win32k.sys\n      Entry 0x1004: 0xfffff9600010b1ac (NtUserInvalidateRect) owned by win32k.sys\n      Entry 0x1005: 0xfffff96000103e70 (NtUserCallNoParam) owned by win32k.sys\n      Entry 0x1006: 0xfffff960000fb5a0 (NtUserGetMessage) owned by win32k.sys\n      Entry 0x1007: 0xfffff960000dfbec (NtUserMessageCall) owned by win32k.sys\n      Entry 0x1008: 0xfffff960001056c4 (NtGdiBitBlt) owned by win32k.sys\n      Entry 0x1009: 0xfffff960001fd750 (NtGdiGetCharSet) owned by win32k.sys\n```\n\n>To filter all functions which point to ntoskrnl.exe and win32k.sys, you can use egrep on command-line. This will only show hooked SSDT functions.\n\n\u5168\u3066\u306entoskrnl.exe\u3068win32k.sys\u5185\u306e\u30a2\u30c9\u30ec\u30b9\u306b\u30dd\u30a4\u30f3\u30c8\u3059\u308b\u95a2\u6570\u3092\u975e\u8868\u793a\u306b\u3059\u308b\u305f\u3081\u306b\u3001\u30b3\u30de\u30f3\u30c9\u30e9\u30a4\u30f3\u4e0a\u3067egrep\u30b3\u30de\u30f3\u30c9\u3092\u4f7f\u3046\u3053\u3068\u304c\u3067\u304d\u307e\u3059\u3002\u3053\u308c\u306b\u3088\u308a\u3001\u30d5\u30c3\u30af\u3055\u308c\u305fSSDT\u95a2\u6570\u306e\u307f\u3092\u8868\u793a\u3067\u304d\u307e\u3059\u3002\n\n```\n$ python vol.py -f ~/Desktop/win7_trial_64bit.raw --profile=Win7SP0x64 ssdt | egrep -v '(ntos|win32k)'\n```\n>Note that the NT module on your system may be ntkrnlpa.exe or ntkrnlmp.exe - so check that before using egrep of you'll be filtering the wrong module name. Also be aware that this isn't a hardened technique for finding hooks, as malware can load a driver named win32ktesting.sys and bypass your filter.\n\nNT\u30e2\u30b8\u30e5\u30fc\u30eb\u306f\u3001ntkrnlpa.exe\u3084ntkrnlmp.exe\u3067\u3042\u308b\u304b\u3082\u3057\u308c\u307e\u305b\u3093\u3002\u305d\u306e\u305f\u3081\u3001egrep\u3092\u4f7f\u3046\u524d\u306b\u9593\u9055\u3063\u305f\u30e2\u30b8\u30e5\u30fc\u30eb\u540d\u3067\u30d5\u30a3\u30eb\u30bf\u3092\u3057\u3088\u3046\u3068\u3057\u3066\u3044\u306a\u3044\u304b\u3092\u78ba\u8a8d\u3057\u3066\u304f\u3060\u3055\u3044\u3002\u30de\u30eb\u30a6\u30a7\u30a2\u306f\u3001win32ktesting.sys\u3068\u3044\u3046\u3088\u3046\u306a\u540d\u524d\u306e\u30c9\u30e9\u30a4\u30d0\u3092\u30ed\u30fc\u30c9\u3057\u3066\u30d5\u30a3\u30eb\u30bf\u3092\u56de\u907f\u3059\u308b\u3053\u3068\u306e\u53ef\u80fd\u306a\u306e\u3067\u3001\u5fc5\u305a\u3057\u3082\u6210\u529f\u3059\u308b\u30c6\u30af\u30cb\u30c3\u30af\u3067\u306f\u306a\u3044\u3053\u3068\u306b\u6ce8\u610f\u3057\u3066\u304f\u3060\u3055\u3044\u3002\n\n## driverscan\n\n>To find DRIVER_OBJECTs in physical memory using pool tag scanning, use the driverscan command. This is another way to locate kernel modules, although not all kernel modules have an associated DRIVER_OBJECT. The DRIVER_OBJECT is what contains the 28 IRP (Major Function) tables, thus the driverirp command is based on the methodology used by driverscan.\n\n>For more information, see Andreas Schuster's Scanning for Drivers.\n\n```\n$ python vol.py -f ~/Desktop/win7_trial_64bit.raw --profile=Win7SP0x64 driverscan\nVolatility Foundation Volatility Framework 2.4\nOffset(P)          #Ptr #Hnd Start                            Size Service Key          Name         Driver Name\n------------------ ---- ---- ------------------ ------------------ -------------------- ------------ -----------\n0x00000000174c6350    3    0 0xfffff880037e9000             0xd000 mouhid               mouhid       \\Driver\\mouhid\n0x0000000017660cb0    3    0 0xfffff8800259a000            0x18000 rspndr               rspndr       \\Driver\\rspndr\n0x0000000017663e70    3    0 0xfffff88002585000            0x15000 lltdio               lltdio       \\Driver\\lltdio\n0x0000000017691d70    3    0 0xfffff88001944000            0x2a000 cdrom                cdrom        \\Driver\\cdrom\n0x0000000017692a50    3    0 0xfffff8800196e000             0x9000 Null                 Null         \\Driver\\Null\n0x0000000017695e70    3    0 0xfffff88001977000             0x7000 Beep                 Beep         \\Driver\\Beep\n0x00000000176965c0    3    0 0xfffff8800197e000             0xe000 VgaSave              VgaSave      \\Driver\\VgaSave\n0x000000001769fb00    4    0 0xfffff880019c1000             0x9000 RDPCDD               RDPCDD       \\Driver\\RDPCDD\n0x00000000176a1720    3    0 0xfffff880019ca000             0x9000 RDPENCDD             RDPENCDD     \\Driver\\RDPENCDD\n0x00000000176a2230    3    0 0xfffff880019d3000             0x9000 RDPREFMP             RDPREFMP     \\Driver\\RDPREFMP\n[snip]\n```\n\n## filescan\n\n>To find FILE_OBJECTs in physical memory using pool tag scanning, use the filescan command. This will find open files even if a rootkit is hiding the files on disk and if the rootkit hooks some API functions to hide the open handles on a live system. The output shows the physical offset of the FILE_OBJECT, file name, number of pointers to the object, number of handles to the object, and the effective permissions granted to the object.\n\n>For more information, see Andreas Schuster's Scanning for File Objects and Linking File Objects To Processes.\n\n```\n$ python vol.py -f ~/Desktop/win7_trial_64bit.raw --profile=Win7SP0x64 filescan\nVolatility Foundation Volatility Framework 2.4\nOffset(P)            #Ptr   #Hnd Access Name\n------------------ ------ ------ ------ ----\n0x000000000126f3a0     14      0 R--r-d \\Windows\\System32\\mswsock.dll\n0x000000000126fdc0     11      0 R--r-d \\Windows\\System32\\ssdpsrv.dll\n0x000000000468f7e0      6      0 R--r-d \\Windows\\System32\\cryptsp.dll\n0x000000000468fdc0     16      0 R--r-d \\Windows\\System32\\Apphlpdm.dll\n0x00000000048223a0      1      1 ------ \\Endpoint\n0x0000000004822a30     16      0 R--r-d \\Windows\\System32\\kerberos.dll\n0x0000000004906070     13      0 R--r-d \\Windows\\System32\\wbem\\repdrvfs.dll\n0x0000000004906580      9      0 R--r-d \\Windows\\SysWOW64\\netprofm.dll\n0x0000000004906bf0      9      0 R--r-d \\Windows\\System32\\wbem\\wmiutils.dll\n0x00000000049ce8e0      2      1 R--rwd \\$Extend\\$ObjId\n0x00000000049cedd0      1      1 R--r-d \\Windows\\System32\\en-US\\vsstrace.dll.mui\n0x0000000004a71070     17      1 R--r-d \\Windows\\System32\\en-US\\pnidui.dll.mui\n0x0000000004a71440     11      0 R--r-d \\Windows\\System32\\nci.dll\n0x0000000004a719c0      1      1 ------ \\srvsvc\n[snip]\n```\n\n## mutantscan\n\n>To scan physical memory for KMUTANT objects with pool tag scanning, use the mutantscan command. By default, it displays all objects, but you can pass -s or --silent to only show named mutexes. The CID column contains the process ID and thread ID of the mutex owner if one exists.\n\n>For more information, see Andreas Schuster's Searching for Mutants.\n\n```\n$ python -f ~/Desktop/win7_trial_64bit.raw --profile=Win7SP0x64 mutantscan --silent\nVolatility Foundation Volatility Framework 2.4\nOffset(P)          #Ptr #Hnd Signal Thread                   CID Name\n------------------ ---- ---- ------ ------------------ --------- ----\n0x000000000f702630    2    1      1 0x0000000000000000           {A3BD3259-3E4F-428a-84C8-F0463A9D3EB5}\n0x00000000102fd930    2    1      1 0x0000000000000000           Feed Arbitration Shared Memory Mutex [ User : S-1-5-21-2628989162-3383567662-1028919141-1000 ]\n0x00000000104e5e60    3    2      1 0x0000000000000000           ZoneAttributeCacheCounterMutex\n0x0000000010c29e40    2    1      1 0x0000000000000000           _MSFTHISTORY_LOW_\n0x0000000013035080    2    1      1 0x0000000000000000           c:userstestingappdatalocalmicrosoftfeeds cache\n0x000000001722dfc0    2    1      1 0x0000000000000000           c:userstestingappdataroamingmicrosoftwindowsietldcachelow\n0x00000000172497f0    2    1      1 0x0000000000000000           LRIEElevationPolicyMutex\n0x000000001724bfc0    3    2      1 0x0000000000000000           BrowserEmulationSharedMemoryMutex\n0x000000001724f400    2    1      1 0x0000000000000000           c:userstestingappdatalocalmicrosoftwindowshistorylowhistory.ie5mshist012012022220120223\n0x000000001724f4c0    4    3      1 0x0000000000000000           _SHMSFTHISTORY_\n0x00000000172517c0    2    1      1 0x0000000000000000           __DDrawExclMode__\n0x00000000172783a0    2    1      1 0x0000000000000000           Lowhttp://sourceforge.net/\n0x00000000172db840    4    3      1 0x0000000000000000           ConnHashTable<1892>_HashTable_Mutex\n0x00000000172de1d0    2    1      1 0x0000000000000000           Feeds Store Mutex S-1-5-21-2628989162-3383567662-1028919141-1000\n0x00000000173b8080    2    1      1 0x0000000000000000           DDrawDriverObjectListMutex\n0x00000000173bd340    2    1      0 0xfffffa8000a216d0 1652:2000 ALTTAB_RUNNING_MUTEX\n0x0000000017449c40    2    1      1 0x0000000000000000           DDrawWindowListMutex\n[snip]\n```\n\n## symlinkscan\n\n>This plugin scans for symbolic link objects and outputs their information. In the past, this has been used to link drive letters (i.e. D:, E:, F:, etc) to true crypt volumes (i.e. \\Device\\TrueCryptVolume). For more information, see Symbolic Link Objects and Identifying a Mounted True Crypt Volume from Artifacts in Volatile Memory.\n\n```\n$ python -f ~/Desktop/win7_trial_64bit.raw --profile=Win7SP0x64 symlinkscan\nVolatility Foundation Volatility Framework 2.4\nOffset(P)            #Ptr   #Hnd Creation time            From                 To\n------------------ ------ ------ ------------------------ -------------------- ------------------------------------------------------------\n0x0000000000469780      1      0 2012-02-22 20:03:13      UMB#UMB#1...e1ba19f} \\Device\\00000048\n0x0000000000754560      1      0 2012-02-22 20:03:15      ASYNCMAC             \\Device\\ASYNCMAC\n0x0000000000ef6cf0      2      1 2012-02-22 19:58:24      0                    \\BaseNamedObjects\n0x00000000014b2a10      1      0 2012-02-22 20:02:10      LanmanRedirector     \\Device\\Mup\\;LanmanRedirector\n0x00000000053e56f0      1      0 2012-02-22 20:03:15      SW#{eeab7...abac361} \\Device\\KSENUM#00000001\n0x0000000005cc0770      1      0 2012-02-22 19:58:20      WanArpV6             \\Device\\WANARPV6\n0x0000000005cc0820      1      0 2012-02-22 19:58:20      WanArp               \\Device\\WANARP\n0x0000000008ffa680      1      0 2012-02-22 19:58:24      Global               \\BaseNamedObjects\n0x0000000009594810      1      0 2012-02-22 19:58:24      KnownDllPath         C:\\Windows\\syswow64\n0x000000000968f5f0      1      0 2012-02-22 19:58:23      KnownDllPath         C:\\Windows\\system32\n0x000000000ab24060      1      0 2012-02-22 19:58:20      Volume{3b...f6e6963} \\Device\\CdRom0\n0x000000000ab24220      1      0 2012-02-22 19:58:21      {EE0434CC...863ACC2} \\Device\\NDMP2\n0x000000000abd3460      1      0 2012-02-22 19:58:21      ACPI#PNP0...91405dd} \\Device\\00000041\n0x000000000abd36f0      1      0 2012-02-22 19:58:21      {802389A0...A90C31A} \\Device\\NDMP3\n[snip]\n```\n\n## thrdscan\n\n>To find ETHREAD objects in physical memory with pool tag scanning, use the thrdscan command. Since an ETHREAD contains fields that identify its parent process, you can use this technique to find hidden processes. One such use case is documented in the psxview command. Also, for verbose details, try the threads plugin.\n\n```\n$ python vol.py -f ~/Desktop/win7_trial_64bit.raw --profile=Win7SP0x64 thrdscan\nVolatility Foundation Volatility Framework 2.4\nOffset(P)             PID    TID      Start Address Create Time               Exit Time\n------------------ ------ ------ ------------------ ------------------------- -------------------------\n0x0000000008df68d0    280    392         0x77943260 2012-02-22 19:08:18\n0x000000000eac3850   2040    144         0x76d73260 2012-02-22 11:28:59       2012-02-22 11:29:04\n0x000000000fd82590    880   1944         0x76d73260 2012-02-22 20:02:29       2012-02-22 20:02:29\n0x00000000103d15f0    880    884         0x76d73260 2012-02-22 19:58:43\n0x00000000103e5480   1652   1788 0xfffff8a0010ed490 2012-02-22 20:03:44\n0x00000000105a3940    916    324         0x76d73260 2012-02-22 20:02:07       2012-02-22 20:02:09\n0x00000000105b3560    816    824         0x76d73260 2012-02-22 19:58:42\n0x00000000106d1710    916   1228         0x76d73260 2012-02-22 20:02:11\n0x0000000010a349a0    816    820         0x76d73260 2012-02-22 19:58:41\n0x0000000010bd1060   1892   2280         0x76d73260 2012-02-22 11:26:13\n0x0000000010f24230    628    660         0x76d73260 2012-02-22 19:58:34\n0x0000000010f27060    568    648 0xfffff8a0017c6650 2012-02-22 19:58:34\n[snip]\n```\n\n## dumpfiles\n\n>An important concept that every computer scientist, especially those who have spent time doing operating system research, is intimately familiar with is that of caching. Files are cached in memory for system performance as they are accessed and used. This makes the cache a valuable source from a forensic perspective since we are able to retrieve files that were in use correctly, instead of file carving which does not make use of how items are mapped in memory. Files may not be completely mapped in memory (also for performance), so missing sections are zero padded. Files dumped from memory can then be processed with external tools.\n\n>For more information see AAron Walter's post: MoVP 4.4 Cache Rules Everything Around Me(mory).\n\n>There are several options in the dumpfiles plugin, for example:\n\n  -r REGEX, --regex=REGEX\n                        Dump files matching REGEX\n  -i, --ignore-case     Ignore case in pattern match\n  -o OFFSET, --offset=OFFSET\n                        Dump files for Process with physical address OFFSET\n  -Q PHYSOFFSET, --physoffset=PHYSOFFSET\n                        Dump File Object at physical address PHYSOFFSET\n  -D DUMP_DIR, --dump-dir=DUMP_DIR\n                        Directory in which to dump extracted files\n  -S SUMMARY_FILE, --summary-file=SUMMARY_FILE\n                        File where to store summary information\n  -p PID, --pid=PID     Operate on these Process IDs (comma-separated)\n  -n, --name            Include extracted filename in output file path\n  -u, --unsafe          Relax safety constraints for more data\n  -F FILTER, --filter=FILTER\n                        Filters to apply (comma-separated)\n\n>By default, dumpfiles iterates through the VAD and extracts all files that are mapped as DataSectionObject, ImageSectionObject or SharedCacheMap. As an investigator, however, you may want to perform a more targeted search. You can use the -r and -i flags to specify a case-insensitive regex of a filename. In the output below, you can see where the file was dumped from (DataSectionObject, ImageSectionObject or SharedCacheMap), the offset of the _FILE_OBJECT, the PID of the process whose VAD contained the file and the file path on disk:\n\n```\n$ python vol.py -f mebromi.raw dumpfiles -D output/ -r evt$ -i -S summary.txt\nVolatility Foundation Volatility Framework 2.4\nDataSectionObject 0x81ed6240   684    \\Device\\HarddiskVolume1\\WINDOWS\\system32\\config\\AppEvent.Evt\nSharedCacheMap 0x81ed6240   684    \\Device\\HarddiskVolume1\\WINDOWS\\system32\\config\\AppEvent.Evt\nDataSectionObject 0x8217beb0   684    \\Device\\HarddiskVolume1\\WINDOWS\\system32\\config\\SecEvent.Evt\nDataSectionObject 0x8217bd78   684    \\Device\\HarddiskVolume1\\WINDOWS\\system32\\config\\SysEvent.Evt\nSharedCacheMap 0x8217bd78   684    \\Device\\HarddiskVolume1\\WINDOWS\\system32\\config\\SysEvent.Evt\n\n$ ls output/\nfile.684.0x81fc6ed0.vacb    file.684.0x82256a48.dat     file.684.0x82256e48.dat     file.None.0x82339cd8.vacb\nfile.684.0x8217b720.vacb    file.684.0x82256c50.dat     file.None.0x82339c70.dat\nThe dumped filename is in the format of:\n\nfile.[PID].[OFFSET].ext\n```\n\n>The OFFSET is the offset of the SharedCacheMap or the _CONTROL_AREA, not the _FILE_OBJECT.\n\n>The extension (EXT) can be:\n\nimg \u2013 ImageSectionObject\ndat - DataSectionObject\nvacb \u2013 SharedCacheMap\n\n>You can look at the -S/--summary-file in order to map the file back to its original filename:\n\n>{\"name\": \"\\\\Device\\\\HarddiskVolume1\\\\WINDOWS\\\\system32\\\\config\\\\AppEvent.Evt\", \"ofpath\": \"dumpfiles/file.684.0x82256e48.dat\", \"pid\": 684,...\n>You can also use the parsesummary.py script to parse out the json output of the summary file. The following shows an example of using this script. In addition to the original file name, PID of the process that had the file open and size, you can see which pages were present and which pages were missing and padded with zeros in the parsed summary output:\n\n```\n$ python vol.py -f grrcon.img dumpfiles --summary=grrcon_summary.json -D output/\nVolatility Foundation Volatility Framework 2.4\n\n$ python parsesummary.py grrcon_summary.json |less\n[snip]\nFile: \\Device\\HarddiskVolume1\\Documents and Settings\\administrator\\NTUSER.DAT -> output/file.4.0x82245008.vacb\n        PID: 4\n        _FILE_OBJECT offset: 0x821cd9e8\n        Type: SharedCacheMap\n        Size: 262144\n        Present Pages:\n                Offset(V): 0xde5c0000, Length: 4096\n                Offset(V): 0xde5c1000, Length: 4096\n                Offset(V): 0xde5c2000, Length: 4096\n                Offset(V): 0xde5c3000, Length: 4096\n[snip]\n        Padding:\n                FileOffset: 0xde62e000 x 0x1000\n                FileOffset: 0xde62f000 x 0x1000\n                FileOffset: 0xde630000 x 0x1000\n                FileOffset: 0xde631000 x 0x1000\n                FileOffset: 0xde632000 x 0x1000\n[snip]\n```\n>Or you can use the -n/--name option in order to dump file the files with the original filename.\n\n>Not every file will be currently active or in the VAD, and such files will not be dumped when using the -r/--regex option. For these files you can first scan for a _FILE_OBJECT and then use the -Q/--physoffset flag to extract the file. Special NTFS files are examples of files that must be dumped specifically:\n\n```\n$ python vol.py -f mebromi.raw filescan |grep -i mft\nVolatility Foundation Volatility Framework 2.4\n0x02410900      3      0 RWD--- \\Device\\HarddiskVolume1\\$Mft\n0x02539e30      3      0 RWD--- \\Device\\HarddiskVolume1\\$Mft\n0x025ac868      3      0 RWD--- \\Device\\HarddiskVolume1\\$MftMirr\n\n$ python vol.py -f mebromi.raw dumpfiles -D output/ -Q 0x02539e30\nVolatility Foundation Volatility Framework 2.4\nDataSectionObject 0x02539e30   None   \\Device\\HarddiskVolume1\\$Mft\nSharedCacheMap 0x02539e30   None   \\Device\\HarddiskVolume1\\$Mft\n```\n>The -f/--filter option allows you to specify which view of the file you would like to dump (DataSectionObject, ImageSectionObject or SharedCacheMap). For example, if you wanted to only see the state information for an executable file, you could specify --filter=ImageSectionObject.\n\n## unloadedmodules\n\nWindows stores information on recently unloaded drivers for debugging purposes. This gives you an alternative way to determine what happened on a system, besides the well known modules and modscan plugins.\n\n$ python vol.py -f win7_trial_64bit.raw unloadedmodules --profile=Win7SP0x64\nVolatility Foundation Volatility Framework 2.4\nName                 StartAddress       EndAddress         Time\n-------------------- ------------------ ------------------ ----\ndump_dumpfve.sys     0xfffff88001931000 0xfffff88001944000 2012-02-22 19:58:21\ndump_atapi.sys       0xfffff88001928000 0xfffff88001931000 2012-02-22 19:58:21\ndump_ataport.sys     0xfffff8800191c000 0xfffff88001928000 2012-02-22 19:58:21\ncrashdmp.sys         0xfffff8800190e000 0xfffff8800191c000 2012-02-22 19:58:21\nNetworking\nconnections\n\nTo view TCP connections that were active at the time of the memory acquisition, use the connections command. This walks the singly-linked list of connection structures pointed to by a non-exported symbol in the tcpip.sys module.\n\nThis command is for x86 and x64 Windows XP and Windows 2003 Server only.\n\n$ python vol.py -f Win2003SP2x64.vmem --profile=Win2003SP2x64 connections\nVolatile Systems Volatility Framework 2.1_alpha\nOffset(V)          Local Address             Remote Address               Pid\n------------------ ------------------------- ------------------------- ------\n0xfffffadfe6f2e2f0 172.16.237.150:1408       72.246.25.25:80             2136\n0xfffffadfe72e8080 172.16.237.150:1369       64.4.11.30:80               2136\n0xfffffadfe622d010 172.16.237.150:1403       74.125.229.188:80           2136\n0xfffffadfe62e09e0 172.16.237.150:1352       64.4.11.20:80               2136\n0xfffffadfe6f2e630 172.16.237.150:1389       209.191.122.70:80           2136\n0xfffffadfe5e7a610 172.16.237.150:1419       74.125.229.187:80           2136\n0xfffffadfe7321bc0 172.16.237.150:1418       74.125.229.188:80           2136\n0xfffffadfe5ea3c90 172.16.237.150:1393       216.115.98.241:80           2136\n0xfffffadfe72a3a80 172.16.237.150:1391       209.191.122.70:80           2136\n0xfffffadfe5ed8560 172.16.237.150:1402       74.125.229.188:80           2136\nOutput includes the virtual offset of the _TCPT_OBJECT by default. The physical offset can be obtained with the -P switch.\n\nconnscan\n\nTo find _TCPT_OBJECT structures using pool tag scanning, use the connscan command. This can find artifacts from previous connections that have since been terminated, in addition to the active ones. In the output below, you'll notice some fields have been partially overwritten, but some of the information is still accurate. For example, the very last entry's Pid field is 0, but all other fields are still in tact. Thus, while it may find false positives sometimes, you also get the benefit of detecting as much information as possible.\n\nThis command is for x86 and x64 Windows XP and Windows 2003 Server only.\n\n$ python vol.py -f Win2K3SP0x64.vmem --profile=Win2003SP2x64 connscan\nVolatility Foundation Volatility Framework 2.4\nOffset(P)  Local Address             Remote Address            Pid\n---------- ------------------------- ------------------------- ------\n0x0ea7a610 172.16.237.150:1419       74.125.229.187:80           2136\n0x0eaa3c90 172.16.237.150:1393       216.115.98.241:80           2136\n0x0eaa4480 172.16.237.150:1398       216.115.98.241:80           2136\n0x0ead8560 172.16.237.150:1402       74.125.229.188:80           2136\n0x0ee2d010 172.16.237.150:1403       74.125.229.188:80           2136\n0x0eee09e0 172.16.237.150:1352       64.4.11.20:80               2136\n0x0f9f83c0 172.16.237.150:1425       98.139.240.23:80            2136\n0x0f9fe010 172.16.237.150:1394       216.115.98.241:80           2136\n0x0fb2e2f0 172.16.237.150:1408       72.246.25.25:80             2136\n0x0fb2e630 172.16.237.150:1389       209.191.122.70:80           2136\n0x0fb72730 172.16.237.150:1424       98.139.240.23:80            2136\n0x0fea3a80 172.16.237.150:1391       209.191.122.70:80           2136\n0x0fee8080 172.16.237.150:1369       64.4.11.30:80               2136\n0x0ff21bc0 172.16.237.150:1418       74.125.229.188:80           2136\n0x1019ec90 172.16.237.150:1397       216.115.98.241:80           2136\n0x179099e0 172.16.237.150:1115       66.150.117.33:80            2856\n0x2cdb1bf0 172.16.237.150:139        172.16.237.1:63369             4\n0x339c2c00 172.16.237.150:1138       23.45.66.43:80              1332\n0x39b10010 172.16.237.150:1148       172.16.237.138:139             0\nsockets\n\nTo detect listening sockets for any protocol (TCP, UDP, RAW, etc), use the sockets command. This walks a singly-linked list of socket structures which is pointed to by a non-exported symbol in the tcpip.sys module.\n\nThis command is for x86 and x64 Windows XP and Windows 2003 Server only.\n\n$ python vol.py -f Win2K3SP0x64.vmem --profile=Win2003SP2x64 sockets\nVolatility Foundation Volatility Framework 2.4\nOffset(V)             PID   Port  Proto Protocol        Address         Create Time\n------------------ ------ ------ ------ --------------- --------------- -----------\n0xfffffadfe71bbda0    432   1025      6 TCP             0.0.0.0         2012-01-23 18:20:01\n0xfffffadfe7350490    776   1028     17 UDP             0.0.0.0         2012-01-23 18:21:44\n0xfffffadfe6281120    804    123     17 UDP             127.0.0.1       2012-06-25 12:40:55\n0xfffffadfe7549010    432    500     17 UDP             0.0.0.0         2012-01-23 18:20:09\n0xfffffadfe5ee8400      4      0     47 GRE             0.0.0.0         2012-02-24 18:09:07\n0xfffffadfe606dc90      4    445      6 TCP             0.0.0.0         2012-01-23 18:19:38\n0xfffffadfe6eef770      4    445     17 UDP             0.0.0.0         2012-01-23 18:19:38\n0xfffffadfe7055210   2136   1321     17 UDP             127.0.0.1       2012-05-09 02:09:59\n0xfffffadfe750c010      4    139      6 TCP             172.16.237.150  2012-06-25 12:40:55\n0xfffffadfe745f610      4    138     17 UDP             172.16.237.150  2012-06-25 12:40:55\n0xfffffadfe6096560      4    137     17 UDP             172.16.237.150  2012-06-25 12:40:55\n0xfffffadfe7236da0    720    135      6 TCP             0.0.0.0         2012-01-23 18:19:51\n0xfffffadfe755c5b0   2136   1419      6 TCP             0.0.0.0         2012-06-25 12:42:37\n0xfffffadfe6f36510   2136   1418      6 TCP             0.0.0.0         2012-06-25 12:42:37\n[snip]\nOutput includes the virtual offset of the _ADDRESS_OBJECT by default. The physical offset can be obtained with the -P switch.\n\nsockscan\n\nTo find _ADDRESS_OBJECT structures using pool tag scanning, use the sockscan command. As with connscan, this can pick up residual data and artifacts from previous sockets.\n\nThis command is for x86 and x64 Windows XP and Windows 2003 Server only.\n\n$ python vol.py -f Win2K3SP0x64.vmem --profile=Win2003SP2x64 sockscan\nVolatility Foundation Volatility Framework 2.4\nOffset(P)             PID   Port  Proto Protocol        Address         Create Time\n------------------ ------ ------ ------ --------------- --------------- -----------\n0x0000000000608010    804    123     17 UDP             172.16.237.150  2012-05-08 22:17:44\n0x000000000eae8400      4      0     47 GRE             0.0.0.0         2012-02-24 18:09:07\n0x000000000eaf1240   2136   1403      6 TCP             0.0.0.0         2012-06-25 12:42:37\n0x000000000ec6dc90      4    445      6 TCP             0.0.0.0         2012-01-23 18:19:38\n0x000000000ec96560      4    137     17 UDP             172.16.237.150  2012-06-25 12:40:55\n0x000000000ecf7d20   2136   1408      6 TCP             0.0.0.0         2012-06-25 12:42:37\n0x000000000ed5a010   2136   1352      6 TCP             0.0.0.0         2012-06-25 12:42:18\n0x000000000ed84ca0    804    123     17 UDP             172.16.237.150  2012-06-25 12:40:55\n0x000000000ee2d380   2136   1393      6 TCP             0.0.0.0         2012-06-25 12:42:37\n0x000000000ee81120    804    123     17 UDP             127.0.0.1       2012-06-25 12:40:55\n0x000000000eeda8c0    776   1363     17 UDP             0.0.0.0         2012-06-25 12:42:20\n0x000000000f0be1a0   2136   1402      6 TCP             0.0.0.0         2012-06-25 12:42:37\n0x000000000f0d0890      4   1133      6 TCP             0.0.0.0         2012-02-24 18:09:07\n[snip]\nnetscan\n\nTo scan for network artifacts in 32- and 64-bit Windows Vista, Windows 2008 Server and Windows 7 memory dumps, use the netscan command. This finds TCP endpoints, TCP listeners, UDP endpoints, and UDP listeners. It distinguishes between IPv4 and IPv6, prints the local and remote IP (if applicable), the local and remote port (if applicable), the time when the socket was bound or when the connection was established, and the current state (for TCP connections only). For more information, see http://mnin.blogspot.com/2011/03/volatilitys-new-netscan-module.html Volatility's New Netscan Module.\n\nPlease note the following:\n\nThe netscan command uses pool tag scanning\nThere are at least 2 alternate ways to enumerate connections and sockets on Vista+ operating systems. One of them is using partitions and dynamic hash tables, which is how the netstat.exe utility on Windows systems works. The other involves bitmaps and port pools.\n$ python vol.py -f ~/Desktop/win7_trial_64bit.raw --profile=Win7SP0x64 netscan\nVolatility Foundation Volatility Framework 2.4\nOffset(P)  Proto    Local Address                  Foreign Address      State            Pid      Owner          Created\n0xf882a30  TCPv4    0.0.0.0:135                    0.0.0.0:0            LISTENING        628      svchost.exe\n0xfc13770  TCPv4    0.0.0.0:49154                  0.0.0.0:0            LISTENING        916      svchost.exe\n0xfdda1e0  TCPv4    0.0.0.0:49154                  0.0.0.0:0            LISTENING        916      svchost.exe\n0xfdda1e0  TCPv6    :::49154                       :::0                 LISTENING        916      svchost.exe\n0x1121b7b0 TCPv4    0.0.0.0:135                    0.0.0.0:0            LISTENING        628      svchost.exe\n0x1121b7b0 TCPv6    :::135                         :::0                 LISTENING        628      svchost.exe\n0x11431360 TCPv4    0.0.0.0:49152                  0.0.0.0:0            LISTENING        332      wininit.exe\n0x11431360 TCPv6    :::49152                       :::0                 LISTENING        332      wininit.exe\n[snip]\n0x17de8980 TCPv6    :::49153                       :::0                 LISTENING        444      lsass.exe\n0x17f35240 TCPv4    0.0.0.0:49155                  0.0.0.0:0            LISTENING        880      svchost.exe\n0x17f362b0 TCPv4    0.0.0.0:49155                  0.0.0.0:0            LISTENING        880      svchost.exe\n0x17f362b0 TCPv6    :::49155                       :::0                 LISTENING        880      svchost.exe\n0xfd96570  TCPv4    -:0                            232.9.125.0:0        CLOSED           1        ?C?\n0x17236010 TCPv4    -:49227                        184.26.31.55:80      CLOSED           2820     iexplore.exe\n0x1725d010 TCPv4    -:49359                        93.184.220.20:80     CLOSED           2820     iexplore.exe\n0x17270530 TCPv4    10.0.2.15:49363                173.194.35.38:80     ESTABLISHED      2820     iexplore.exe\n0x17285010 TCPv4    -:49341                        82.165.218.111:80    CLOSED           2820     iexplore.exe\n0x17288a90 TCPv4    10.0.2.15:49254                74.125.31.157:80     CLOSE_WAIT       2820     iexplore.exe\n0x1728f6b0 TCPv4    10.0.2.15:49171                204.245.34.130:80    ESTABLISHED      2820     iexplore.exe\n0x17291ba0 TCPv4    10.0.2.15:49347                173.194.35.36:80     CLOSE_WAIT       2820     iexplore.exe\n[snip]\n0x17854010 TCPv4    -:49168                        157.55.15.32:80      CLOSED           2820     iexplore.exe\n0x178a2a20 TCPv4    -:0                            88.183.123.0:0       CLOSED           504      svchost.exe\n0x178f5b00 TCPv4    10.0.2.15:49362                173.194.35.38:80     CLOSE_WAIT       2820     iexplore.exe\n0x17922910 TCPv4    -:49262                        184.26.31.55:80      CLOSED           2820     iexplore.exe\n0x17a9d860 TCPv4    10.0.2.15:49221                204.245.34.130:80    ESTABLISHED      2820     iexplore.exe\n0x17ac84d0 TCPv4    10.0.2.15:49241                74.125.31.157:80     CLOSE_WAIT       2820     iexplore.exe\n0x17b9acf0 TCPv4    10.0.2.15:49319                74.125.127.148:80    CLOSE_WAIT       2820     iexplore.exe\n0x10f38d70 UDPv4    10.0.2.15:1900                 *:*                                   1736     svchost.exe    2012-02-22 20:04:12\n0x173b3dc0 UDPv4    0.0.0.0:59362                  *:*                                   1736     svchost.exe    2012-02-22 20:02:27\n0x173b3dc0 UDPv6    :::59362                       *:*                                   1736     svchost.exe    2012-02-22 20:02:27\n0x173b4cf0 UDPv4    0.0.0.0:3702                   *:*                                   1736     svchost.exe    2012-02-22 20:02:27\n0x173b4cf0 UDPv6    :::3702                        *:*                                   1736     svchost.exe    2012-02-22 20:02:27\n[snip]\nRegistry\nVolatility is the only memory forensics framework with the ability to carve registry data. For more information, see BDG's Memory Registry Tools and Registry Code Updates.\n\nhivescan\n\nTo find the physical addresses of CMHIVEs (registry hives) in memory, use the hivescan command. For more information, see BDG's Enumerating Registry Hives.\n\nThis plugin isn't generally useful by itself. Its meant to be inherited by other plugins (such as hivelist below) that build on and interpret the information found in CMHIVEs.\n\n$python vol.py -f ~/Desktop/win7_trial_64bit.raw --profile=Win7SP0x64 hivescan\nVolatility Foundation Volatility Framework 2.4\nOffset(P)\n------------------\n0x0000000008c95010\n0x000000000aa1a010\n0x000000000acf9010\n0x000000000b1a9010\n0x000000000c2b4010\n0x000000000cd20010\n0x000000000da51010\n[snip]\nhivelist\n\nTo locate the virtual addresses of registry hives in memory, and the full paths to the corresponding hive on disk, use the hivelist command. If you want to print values from a certain hive, run this command first so you can see the address of the hives.\n\n$ python vol.py -f ~/Desktop/win7_trial_64bit.raw --profile=Win7SP0x64 hivelist\nVolatility Foundation Volatility Framework 2.4\nVirtual            Physical           Name\n------------------ ------------------ ----\n0xfffff8a001053010 0x000000000b1a9010 \\??\\C:\\System Volume Information\\Syscache.hve\n0xfffff8a0016a7420 0x0000000012329420 \\REGISTRY\\MACHINE\\SAM\n0xfffff8a0017462a0 0x00000000101822a0 \\??\\C:\\Windows\\ServiceProfiles\\NetworkService\\NTUSER.DAT\n0xfffff8a001abe420 0x000000000eae0420 \\??\\C:\\Windows\\ServiceProfiles\\LocalService\\NTUSER.DAT\n0xfffff8a002ccf010 0x0000000014659010 \\??\\C:\\Users\\testing\\AppData\\Local\\Microsoft\\Windows\\UsrClass.dat\n0xfffff80002b53b10 0x000000000a441b10 [no name]\n0xfffff8a00000d010 0x000000000ddc6010 [no name]\n0xfffff8a000022010 0x000000000da51010 \\REGISTRY\\MACHINE\\SYSTEM\n0xfffff8a00005c010 0x000000000dacd010 \\REGISTRY\\MACHINE\\HARDWARE\n0xfffff8a00021d010 0x000000000cd20010 \\SystemRoot\\System32\\Config\\SECURITY\n0xfffff8a0009f1010 0x000000000aa1a010 \\Device\\HarddiskVolume1\\Boot\\BCD\n0xfffff8a000a15010 0x000000000acf9010 \\SystemRoot\\System32\\Config\\SOFTWARE\n0xfffff8a000ce5010 0x0000000008c95010 \\SystemRoot\\System32\\Config\\DEFAULT\n0xfffff8a000f95010 0x000000000c2b4010 \\??\\C:\\Users\\testing\\ntuser.dat\nprintkey\n\nTo display the subkeys, values, data, and data types contained within a specified registry key, use the printkey command. By default, printkey will search all hives and print the key information (if found) for the requested key. Therefore, if the key is located in more than one hive, the information for the key will be printed for each hive that contains it.\n\nSay you want to traverse into the HKEY_LOCAL_MACHINE\\Microsoft\\Security Center\\Svc key. You can do that in the following manner. Note: if you're running Volatility on Windows, enclose the key in double quotes (see issue 166).\n\n$ python vol.py -f ~/Desktop/win7_trial_64bit.raw --profile=Win7SP0x64 printkey -K \"Microsoft\\Security Center\\Svc\"\nVolatility Foundation Volatility Framework 2.4\nLegend: (S) = Stable   (V) = Volatile\n\n----------------------------\nRegistry: \\SystemRoot\\System32\\Config\\SOFTWARE\nKey name: Svc (S)\nLast updated: 2012-02-22 20:04:44\n\nSubkeys:\n  (V) Vol\n\nValues:\nREG_QWORD     VistaSp1        : (S) 128920218544262440\nREG_DWORD     AntiSpywareOverride : (S) 0\nREG_DWORD     ConfigMask      : (S) 4361\nHere you can see how the output appears when multiple hives (DEFAULT and ntuser.dat) contain the same key \"Software\\Microsoft\\Windows NT\\CurrentVersion\".\n\n$ python vol.py -f ~/Desktop/win7_trial_64bit.raw --profile=Win7SP0x64 printkey -K \"Software\\Microsoft\\Windows NT\\CurrentVersion\"\nVolatility Foundation Volatility Framework 2.4\nLegend: (S) = Stable   (V) = Volatile\n\n----------------------------\nRegistry: \\SystemRoot\\System32\\Config\\DEFAULT\nKey name: CurrentVersion (S)\nLast updated: 2009-07-14 04:53:31\n\nSubkeys:\n  (S) Devices\n  (S) PrinterPorts\n\nValues:\n----------------------------\nRegistry: \\??\\C:\\Users\\testing\\ntuser.dat\nKey name: CurrentVersion (S)\nLast updated: 2012-02-22 11:26:13\n\nSubkeys:\n  (S) Devices\n  (S) EFS\n  (S) MsiCorruptedFileRecovery\n  (S) Network\n  (S) PeerNet\n  (S) PrinterPorts\n  (S) Windows\n  (S) Winlogon\n\n[snip]\nIf you want to limit your search to a specific hive, printkey also accepts a virtual address to the hive. For example, to see the contents of HKEY_LOCAL_MACHINE, use the command below. Note: the offset is taken from the previous hivelist output.\n\n$ python vol.py -f ~/Desktop/win7_trial_64bit.raw --profile=Win7SP0x64 printkey -o 0xfffff8a000a15010\nVolatility Foundation Volatility Framework 2.4\nLegend: (S) = Stable   (V) = Volatile\n\n----------------------------\nRegistry: User Specified\nKey name: CMI-CreateHive{199DAFC2-6F16-4946-BF90-5A3FC3A60902} (S)\nLast updated: 2009-07-14 07:13:38\n\nSubkeys:\n  (S) ATI Technologies\n  (S) Classes\n  (S) Clients\n  (S) Intel\n  (S) Microsoft\n  (S) ODBC\n  (S) Policies\n  (S) RegisteredApplications\n  (S) Sonic\n  (S) Wow6432Node\nhivedump\n\nTo recursively list all subkeys in a hive, use the hivedump command and pass it the virtual address to the desired hive.\n\n$ python vol.py -f ~/Desktop/win7_trial_64bit.raw --profile=Win7SP0x64 hivedump -o 0xfffff8a000a15010\nVolatility Foundation Volatility Framework 2.4\nLast Written         Key\n2009-07-14 07:13:38  \\CMI-CreateHive{199DAFC2-6F16-4946-BF90-5A3FC3A60902}\n2009-07-14 04:48:57  \\CMI-CreateHive{199DAFC2-6F16-4946-BF90-5A3FC3A60902}\\ATI Technologies\n2009-07-14 04:48:57  \\CMI-CreateHive{199DAFC2-6F16-4946-BF90-5A3FC3A60902}\\ATI Technologies\\Install\n2009-07-14 04:48:57  \\CMI-CreateHive{199DAFC2-6F16-4946-BF90-5A3FC3A60902}\\ATI Technologies\\Install\\South Bridge\n2009-07-14 04:48:57  \\CMI-CreateHive{199DAFC2-6F16-4946-BF90-5A3FC3A60902}\\ATI Technologies\\Install\\South Bridge\\ATI_AHCI_RAID\n2009-07-14 07:13:39  \\CMI-CreateHive{199DAFC2-6F16-4946-BF90-5A3FC3A60902}\\Classes\n2009-07-14 04:53:38  \\CMI-CreateHive{199DAFC2-6F16-4946-BF90-5A3FC3A60902}\\Classes\\*\n2009-07-14 04:53:38  \\CMI-CreateHive{199DAFC2-6F16-4946-BF90-5A3FC3A60902}\\Classes\\*\\OpenWithList\n2009-07-14 04:53:38  \\CMI-CreateHive{199DAFC2-6F16-4946-BF90-5A3FC3A60902}\\Classes\\*\\OpenWithList\\Excel.exe\n2009-07-14 04:53:38  \\CMI-CreateHive{199DAFC2-6F16-4946-BF90-5A3FC3A60902}\\Classes\\*\\OpenWithList\\IExplore.exe\n[snip]\nhashdump\n\nTo extract and decrypt cached domain credentials stored in the registry, use the hashdump command. For more information, see BDG's Cached Domain Credentials and SANS Forensics 2009 - Memory Forensics and Registry Analysis.\n\nTo use hashdump, pass the virtual address of the SYSTEM hive as -y and the virtual address of the SAM hive as -s, like this:\n\n$ python vol.py hashdump -f image.dd -y 0xe1035b60 -s 0xe165cb60\nAdministrator:500:08f3a52bdd35f179c81667e9d738c5d9:ed88cccbc08d1c18bcded317112555f4:::\nGuest:501:aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0:::\nHelpAssistant:1000:ddd4c9c883a8ecb2078f88d729ba2e67:e78d693bc40f92a534197dc1d3a6d34f:::\nSUPPORT_388945a0:1002:aad3b435b51404eeaad3b435b51404ee:8bfd47482583168a0ae5ab020e1186a9:::\nphoenix:1003:07b8418e83fad948aad3b435b51404ee:53905140b80b6d8cbe1ab5953f7c1c51:::\nASPNET:1004:2b5f618079400df84f9346ce3e830467:aef73a8bb65a0f01d9470fadc55a411c:::\nS----:1006:aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0:::\nHashes can now be cracked using John the Ripper, rainbow tables, etc.\n\nIt is possible that a registry key is not available in memory. When this happens, you may see the following error:\n\n\"ERROR : volatility.plugins.registry.lsadump: Unable to read hashes from registry\"\n\nYou can try to see if the correct keys are available: \"CurrentControlSet\\Control\\lsa\" from SYSTEM and \"SAM\\Domains\\Account\" from SAM. First you need to get the \"CurrentControlSet\", for this we can use volshell (replace [REGISTRY ADDRESS](SYSTEM) below with the offset you get from hivelist), for example:\n\n$ python vol.py -f XPSP3.vmem --profile=WinXPSP3x86 volshell\nVolatility Foundation Volatility Framework 2.4\nCurrent context: process System, pid=4, ppid=0 DTB=0x319000\nWelcome to volshell Current memory image is:\nfile:///XPSP3.vmem\nTo get help, type 'hh()'\n>>> import volatility.win32.hashdump as h\n>>> import volatility.win32.hive as hive\n>>> addr_space = utils.load_as(self._config)\n>>> sysaddr = hive.HiveAddressSpace(addr_space, self._config, [SYSTEM REGISTRY ADDRESS])\n>>> print h.find_control_set(sysaddr)\n1\n>>> ^D\nThen you can use the printkey plugin to make sure the keys and their data are there. Since the \"CurrentControlSet\" is 1 in our previous example, we use \"ControlSet001\" in the first command:\n\n$ python vol.py -f XPSP3.vmem --profile=WinXPSP3x86 printkey -K \"ControlSet001\\Control\\lsa\"\n\n$ python vol.py -f XPSP3.vmem --profile=WinXPSP3x86 printkey -K \"SAM\\Domains\\Account\"\nIf the key is missing you should see an error message:\n\n\"The requested key could not be found in the hive(s) searched\"\n\nlsadump\n\nTo dump LSA secrets from the registry, use the lsadump command. This exposes information such as the default password (for systems with autologin enabled), the RDP public key, and credentials used by DPAPI.\n\nFor more information, see BDG's Decrypting LSA Secrets.\n\nTo use lsadump, pass the virtual address of the SYSTEM hive as the -y parameter and the virtual address of the SECURITY hive as the -s parameter.\n\n$ python vol.py -f laqma.vmem lsadump -y 0xe1035b60 -s 0xe16a6b60\nVolatility Foundation Volatility Framework 2.4\nL$RTMTIMEBOMB_1320153D-8DA3-4e8e-B27B-0D888223A588\n\n0000   00 92 8D 60 01 FF C8 01                            ...`....\n\n_SC_Dnscache\n\nL$HYDRAENCKEY_28ada6da-d622-11d1-9cb9-00c04fb16e75\n\n0000   52 53 41 32 48 00 00 00 00 02 00 00 3F 00 00 00    RSA2H.......?...\n0010   01 00 01 00 37 CE 0C C0 EF EC 13 C8 A4 C5 BC B8    ....7...........\n0020   AA F5 1A 7C 50 95 A4 E9 3B BA 41 C8 53 D7 CE C6    ...|P...;.A.S...\n0030   CB A0 6A 46 7C 70 F3 21 17 1C FB 79 5C C1 83 68    ..jF|p....y...h\n0040   91 E5 62 5E 2C AC 21 1E 79 07 A9 21 BB F0 74 E8    ..b^,..y....t.\n0050   85 66 F4 C4 00 00 00 00 00 00 00 00 F9 D7 AD 5C    .f..............\n0060   B4 7C FB F6 88 89 9D 2E 91 F2 60 07 10 42 CA 5A    .|........`..B.Z\n0070   FC F0 D1 00 0F 86 29 B5 2E 1E 8C E0 00 00 00 00    ......).........\n0080   AF 43 30 5F 0D 0E 55 04 57 F9 0D 70 4A C8 36 01    .C0_..U.W..pJ.6.\n0090   C2 63 45 59 27 62 B5 77 59 84 B7 65 8E DB 8A E0    .cEY'b.wY..e....\n00A0   00 00 00 00 89 19 5E D8 CB 0E 03 39 E2 52 04 37    ......^....9.R.7\n00B0   20 DC 03 C8 47 B5 2A B3 9C 01 65 15 FF 0F FF 8F     ...G.*...e.....\n00C0   17 9F C1 47 00 00 00 00 1B AC BF 62 4E 81 D6 2A    ...G.......bN..*\n00D0   32 98 36 3A 11 88 2D 99 3A EA 59 DE 4D 45 2B 9E    2.6:..-.:.Y.ME+.\n00E0   74 15 14 E1 F2 B5 B2 80 00 00 00 00 75 BD A0 36    t...........u..6\n00F0   20 AD 29 0E 88 E0 FD 5B AD 67 CA 88 FC 85 B9 82     .)....[.g......\n0100   94 15 33 1A F1 65 45 D1 CA F9 D8 4C 00 00 00 00    ..3..eE....L....\n0110   71 F0 0B 11 F2 F1 AA C5 0C 22 44 06 E1 38 6C ED    q........\"D..8l.\n0120   6E 38 51 18 E8 44 5F AD C2 CE 0A 0A 1E 8C 68 4F    n8Q..D_.......hO\n0130   4D 91 69 07 DE AA 1A EC E6 36 2A 9C 9C B6 49 1F    M.i......6*...I.\n0140   B3 DD 89 18 52 7C F8 96 4F AF 05 29 DF 17 D8 48    ....R|..O..)...H\n0150   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................\n0160   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................\n0170   00 00 00 00 00 00 00 00 00 00 00 00                ............\n\nDPAPI_SYSTEM\n\n0000   01 00 00 00 24 04 D6 B0 DA D1 3C 40 BB EE EC 89    ....$.....<@....\n0010   B4 BB 90 5B 9A BF 60 7D 3E 96 72 CD 9A F6 F8 BE    ...[..`}>.r.....\n0020   D3 91 5C FA A5 8B E6 B4 81 0D B6 D4                ............\nuserassist\n\nTo get the UserAssist keys from a sample you can use the userassist plugin. For more information see Gleeda's Volatility UserAssist plugin post.\n\n$ python vol.py -f win7.vmem --profile=Win7SP0x86 userassist\nVolatility Foundation Volatility Framework 2.4\n----------------------------\nRegistry: \\??\\C:\\Users\\admin\\ntuser.dat\nKey name: Count\nLast updated: 2010-07-06 22:40:25\n\nSubkeys:\n\nValues:\nREG_BINARY    Microsoft.Windows.GettingStarted :\nCount:          14\nFocus Count:    21\nTime Focused:   0:07:00.500000\nLast updated:   2010-03-09 19:49:20\n\n0000   00 00 00 00 0E 00 00 00 15 00 00 00 A0 68 06 00    .............h..\n0010   00 00 80 BF 00 00 80 BF 00 00 80 BF 00 00 80 BF    ................\n0020   00 00 80 BF 00 00 80 BF 00 00 80 BF 00 00 80 BF    ................\n0030   00 00 80 BF 00 00 80 BF FF FF FF FF EC FE 7B 9C    ..............{.\n0040   C1 BF CA 01 00 00 00 00                            ........\n\nREG_BINARY    UEME_CTLSESSION :\nCount:          187\nFocus Count:    1205\nTime Focused:   6:25:06.216000\nLast updated:   1970-01-01 00:00:00\n\n[snip]\n\nREG_BINARY    %windir%\\system32\\calc.exe :\nCount:          12\nFocus Count:    17\nTime Focused:   0:05:40.500000\nLast updated:   2010-03-09 19:49:20\n\n0000   00 00 00 00 0C 00 00 00 11 00 00 00 20 30 05 00    ............ 0..\n0010   00 00 80 BF 00 00 80 BF 00 00 80 BF 00 00 80 BF    ................\n0020   00 00 80 BF 00 00 80 BF 00 00 80 BF 00 00 80 BF    ................\n0030   00 00 80 BF 00 00 80 BF FF FF FF FF EC FE 7B 9C    ..............{.\n0040   C1 BF CA 01 00 00 00 00                            ........\n                          ........\n\nREG_BINARY    Z:\\vmware-share\\apps\\odbg110\\OLLYDBG.EXE :\nCount:          11\nFocus Count:    266\nTime Focused:   1:19:58.045000\nLast updated:   2010-03-18 01:56:31\n\n0000   00 00 00 00 0B 00 00 00 0A 01 00 00 69 34 49 00    ............i4I.\n0010   00 00 80 BF 00 00 80 BF 00 00 80 BF 00 00 80 BF    ................\n0020   00 00 80 BF 00 00 80 BF 00 00 80 BF 00 00 80 BF    ................\n0030   00 00 80 BF 00 00 80 BF FF FF FF FF 70 3B CB 3A    ............p;.:\n0040   3E C6 CA 01 00 00 00 00                            >.......\n[snip]\nshellbags\n\nThis plugin parses and prints Shellbag (pdf) information obtained from the registry. For more information see Shellbags in Memory, SetRegTime, and TrueCrypt Volumes. There are two options for output: verbose (default) and bodyfile format.\n\n$ python vol.py -f win7.vmem --profile=Win7SP1x86 shellbags\nVolatility Foundation Volatility Framework 2.4\nScanning for registries....\nGathering shellbag items and building path tree...\n***************************************************************************\nRegistry: \\??\\C:\\Users\\user\\ntuser.dat\nKey: Software\\Microsoft\\Windows\\Shell\\Bags\\1\\Desktop\nLast updated: 2011-10-20 15:24:46\nValue                     File Name      Modified Date        Create Date          Access Date          File Attr                 Unicode Name\n------------------------- -------------- -------------------- -------------------- -------------------- ------------------------- ------------\nItemPos1176x882x96(1)     ADOBER~1.LNK   2011-10-20 15:20:04  2011-10-20 15:20:04  2011-10-20 15:20:04  ARC                       Adobe Reader X.lnk\nItemPos1176x882x96(1)     ENCASE~1.LNK   2011-05-15 23:02:26  2011-05-15 23:02:26  2011-05-15 23:02:26  ARC                       EnCase v6.18.lnk\nItemPos1176x882x96(1)     VMWARE~1.LNK   2011-10-20 15:13:06  2011-05-15 23:09:08  2011-10-20 15:13:06  ARC                       VMware Shared Folders.lnk\nItemPos1176x882x96(1)     EF_SET~1.EXE   2010-12-28 15:47:32  2011-05-15 23:01:10  2011-05-15 23:01:10  ARC, NI                   ef_setup_618_english.exe\nItemPos1366x768x96(1)     ADOBER~1.LNK   2011-10-20 15:20:04  2011-10-20 15:20:04  2011-10-20 15:20:04  ARC                       Adobe Reader X.lnk\nItemPos1366x768x96(1)     ENCASE~1.LNK   2011-05-15 23:02:26  2011-05-15 23:02:26  2011-05-15 23:02:26  ARC                       EnCase v6.18.lnk\nItemPos1366x768x96(1)     EF_SET~1.EXE   2010-12-28 15:47:32  2011-05-15 23:01:10  2011-05-15 23:01:10  ARC, NI                   ef_setup_618_english.exe\nItemPos1366x768x96(1)     VMWARE~1.LNK   2011-10-20 15:24:22  2011-05-15 23:09:08  2011-10-20 15:24:22  ARC                       VMware Shared Folders.lnk\nItemPos1640x834x96(1)     EF_SET~1.EXE   2010-12-28 15:47:32  2011-05-15 23:01:10  2011-05-15 23:01:10  ARC, NI                   ef_setup_618_english.exe\nItemPos1640x834x96(1)     ENCASE~1.LNK   2011-05-15 23:02:26  2011-05-15 23:02:26  2011-05-15 23:02:26  ARC                       EnCase v6.18.lnk\nItemPos1640x834x96(1)     VMWARE~1.LNK   2011-05-15 23:09:08  2011-05-15 23:09:08  2011-05-15 23:09:08  ARC                       VMware Shared Folders.lnk\n***************************************************************************\n\n***************************************************************************\nRegistry: \\??\\C:\\Users\\user\\AppData\\Local\\Microsoft\\Windows\\UsrClass.dat\nKey: Local Settings\\Software\\Microsoft\\Windows\\Shell\\BagMRU\nLast updated: 2011-10-20 15:14:21\nValue   Mru   Entry Type     GUID                                     GUID Description     Folder IDs\n------- ----- -------------- ---------------------------------------- -------------------- ----------\n1       2     Folder Entry   031e4825-7b94-4dc3-b131-e946b44c8dd5     Libraries            EXPLORER, LIBRARIES\n0       1     Folder Entry   20d04fe0-3aea-1069-a2d8-08002b30309d     My Computer          EXPLORER, MY_COMPUTER\n2       0     Folder Entry   59031a47-3f72-44a7-89c5-5595fe6b30ee     Users                EXPLORER, USERS\n***************************************************************************\n\n***************************************************************************\nRegistry: \\??\\C:\\Users\\user\\AppData\\Local\\Microsoft\\Windows\\UsrClass.dat\nKey: Local Settings\\Software\\Microsoft\\Windows\\Shell\\BagMRU\\0\nLast updated: 2011-05-15 23:10:01\nValue   Mru   Entry Type     Path\n------- ----- -------------- ----\n1       0     Volume Name    Z:\\\n0       1     Volume Name    C:\\\n***************************************************************************\n[snip]\n\n***************************************************************************\nRegistry: \\??\\C:\\Users\\user\\AppData\\Local\\Microsoft\\Windows\\UsrClass.dat\nKey: Local Settings\\Software\\Microsoft\\Windows\\Shell\\BagMRU\\0\\0\\0\\0\nLast updated: 2011-05-15 23:03:22\nValue   Mru   File Name      Modified Date        Create Date          Access Date          File Attr                 Path\n------- ----- -------------- -------------------- -------------------- -------------------- ------------------------- ----\n0       0     AppData        2011-05-15 22:57:52  2011-05-15 22:57:52  2011-05-15 22:57:52  HID, NI, DIR              C:\\Users\\user\\AppData\n***************************************************************************\n[snip]\nAnother option is to use the --output=body option for TSK 3.x bodyfile format. You can use this output option when you want to combine output from timeliner, mftparser and timeliner. You can also include a machine identifier in the bodyfile header with the --machine flag (this is useful when combining timelines from multiple machines). Only ITEMPOS and FILE_ENTRY items are output with the bodyfile format:\n\n$ python vol.py -f win7.vmem --profile=Win7SP1x86 shellbags --output=body\nVolatility Foundation Volatility Framework 2.4\nScanning for registries....\nGathering shellbag items and building path tree...\n0|[SHELLBAGS ITEMPOS] Name: Adobe Reader X.lnk/Attrs: ARC/FullPath: Adobe Reader X.lnk/Registry: \\??\\C:\\Users\\user\\ntuser.dat /Key: Software\\Microsoft\\Windows\\Shell\\Bags\\1\\Desktop/LW: 2011-10-20 15:24:46 UTC+0000|0|---------------|0|0|0|1319124004|1319124004|1319124004|1319124004\n0|[SHELLBAGS ITEMPOS] Name: EnCase v6.18.lnk/Attrs: ARC/FullPath: EnCase v6.18.lnk/Registry: \\??\\C:\\Users\\user\\ntuser.dat /Key: Software\\Microsoft\\Windows\\Shell\\Bags\\1\\Desktop/LW: 2011-10-20 15:24:46 UTC+0000|0|---------------|0|0|0|1305500546|1305500546|1305500546|1305500546\n0|[SHELLBAGS ITEMPOS] Name: VMware Shared Folders.lnk/Attrs: ARC/FullPath: VMware Shared Folders.lnk/Registry: \\??\\C:\\Users\\user\\ntuser.dat /Key: Software\\Microsoft\\Windows\\Shell\\Bags\\1\\Desktop/LW: 2011-10-20 15:24:46 UTC+0000|0|---------------|0|0|0|1319123586|1319123586|1305500948|1305500948\n[snip]\n0|[SHELLBAGS FILE_ENTRY] Name: Program Files/Attrs: RO, DIR/FullPath: C:\\Program Files/Registry: \\??\\C:\\Users\\user\\AppData\\Local\\Microsoft\\Windows\\UsrClass.dat /Key: Local Settings\\Software\\Microsoft\\Windows\\Shell\\BagMRU\\0\\0/LW: 2011-05-15 23:03:35 UTC+0000|0|---------------|0|0|0|1305500504|1305500504|1247539026|1247539026\n0|[SHELLBAGS FILE_ENTRY] Name: Users/Attrs: RO, DIR/FullPath: C:\\Users/Registry: \\??\\C:\\Users\\user\\AppData\\Local\\Microsoft\\Windows\\UsrClass.dat /Key: Local Settings\\Software\\Microsoft\\Windows\\Shell\\BagMRU\\0\\0/LW: 2011-05-15 23:03:35 UTC+0000|0|---------------|0|0|0|1305500270|1305500270|1247539026|1247539026\n[snip]\nshimcache\n\nThis plugin parses the Application Compatibility Shim Cache registry key.\n\n$ python vol.py -f win7.vmem --profile=Win7SP1x86 shimcache\nVolatility Foundation Volatility Framework 2.4\nLast Modified                  Path\n------------------------------ ----\n2009-07-14 01:14:22 UTC+0000   \\??\\C:\\Windows\\system32\\LogonUI.exe\n2009-07-14 01:14:18 UTC+0000   \\??\\C:\\Windows\\system32\\DllHost.exe\n2009-07-14 01:16:03 UTC+0000   \\??\\C:\\Windows\\System32\\networkexplorer.dll\n2009-07-14 01:14:31 UTC+0000   \\??\\C:\\WINDOWS\\SYSTEM32\\RUNDLL32.EXE\n2011-03-22 18:18:16 UTC+0000   \\??\\C:\\Program Files\\VMware\\VMware Tools\\TPAutoConnect.exe\n2009-07-14 01:14:25 UTC+0000   \\??\\C:\\Windows\\System32\\msdtc.exe\n2009-07-14 01:15:22 UTC+0000   \\??\\C:\\Windows\\System32\\gameux.dll\n2011-08-12 00:00:18 UTC+0000   \\??\\C:\\Program Files\\Common Files\\VMware\\Drivers\\vss\\comreg.exe\n2010-08-02 20:42:26 UTC+0000   \\??\\C:\\Program Files\\VMware\\VMware Tools\\TPAutoConnSvc.exe\n2009-07-14 01:14:27 UTC+0000   \\??\\C:\\Windows\\system32\\net1.exe\n2009-07-14 01:14:27 UTC+0000   \\??\\C:\\Windows\\System32\\net.exe\n2011-08-12 00:06:50 UTC+0000   \\??\\C:\\Program Files\\VMware\\VMware Tools\\vmtoolsd.exe\n2009-07-14 01:14:45 UTC+0000   \\??\\C:\\Windows\\system32\\WFS.exe\n[snip]\ngetservicesids\n\nThe getservicesids command calculates the SIDs for services on a machine and outputs them in Python dictionary format for future use. The service names are taken from the registry (\"SYSTEM\\CurrentControlSet\\Services\"). For more information on how these SIDs are calculated, see Timeliner Release Documentation (pdf). Example output can be seen below:\n\n$ python vol.py -f WinXPSP1x64.vmem --profile=WinXPSP2x64 getservicesids\nVolatility Foundation Volatility Framework 2.4\nservicesids = {\n    'S-1-5-80-2675092186-3691566608-1139246469-1504068187-1286574349':\n'Abiosdsk',\n    'S-1-5-80-850610371-2162948594-2204246734-1395993891-583065928': 'ACPIEC',\n    'S-1-5-80-2838020983-819055183-730598559-323496739-448665943': 'adpu160m',\n    'S-1-5-80-3218321610-3296847771-3570773115-868698368-3117473630': 'aec',\n    'S-1-5-80-1344778701-2960353790-662938617-678076498-4183748354': 'aic78u2',\n    'S-1-5-80-1076555770-1261388817-3553637611-899283093-3303637635': 'Alerter',\n    'S-1-5-80-1587539839-2488332913-1287008632-3751426284-4220573165': 'AliIde',\n    'S-1-5-80-4100430975-1934021090-490597466-3817433801-2954987127': 'AmdIde',\n    'S-1-5-80-258649362-1997344556-1754272750-1450123204-3407402222': 'Atdisk',\n\n[snip]\nIn order to save output to a file, use the --output-file option.\n\ndumpregistry\n\nThe dumpregistry plugin allows you to dump a registry hive to disk. It works on all supported Windows versions (Windows XP-8.1). By default the plugin will dump all registry files (including virtual registries like HARDWARE) found to disk, however you may specify the virtual offset for a specific hive in order to only dump one registry at a time. One caveat about using this plugin (or the dumpfiles plugin) is that there may be holes in the dumped registry file, so offline registry tools may crash if they are not made robustly to handle \"corrupt\" files. These holes are denoted in the text output with lines like Physical layer returned None for index 2000, filling with NULL. Example output is shown below:\n\n$ python vol.py -f voltest.dmp --profile=Win7SP1x86 dumpregistry -D output\n**************************************************\nWriting out registry: registry.0x888101e0.no_name.reg\n\n**************************************************\n**************************************************\nWriting out registry: registry.0x8cec09d0.ntuserdat.reg\n\nPhysical layer returned None for index 9000, filling with NULL\nPhysical layer returned None for index a000, filling with NULL\nPhysical layer returned None for index b000, filling with NULL\n[snip]\n**************************************************\nWriting out registry: registry.0x8883c7d0.HARDWARE.reg\n\nPhysical layer returned None for index 2000, filling with NULL\nPhysical layer returned None for index 3000, filling with NULL\nPhysical layer returned None for index 4000, filling with NULL\n[snip]\n**************************************************\nWriting out registry: registry.0x88c9c008.SAM.reg\n\n**************************************************\n**************************************************\nWriting out registry: registry.0x8a5449d0.NTUSERDAT.reg\n\n**************************************************\n[snip]\n$ file output/*\noutput/registry.0x888101e0.no_name.reg:     MS Windows registry file, NT/2000 or above\noutput/registry.0x8881c008.SYSTEM.reg:      MS Windows registry file, NT/2000 or above\noutput/registry.0x8883c7d0.HARDWARE.reg:    data\noutput/registry.0x888c14e8.DEFAULT.reg:     MS Windows registry file, NT/2000 or above\noutput/registry.0x88c3b898.SECURITY.reg:    MS Windows registry file, NT/2000 or above\noutput/registry.0x88c9c008.SAM.reg:         MS Windows registry file, NT/2000 or above\noutput/registry.0x8a4c2008.NTUSERDAT.reg:   MS Windows registry file, NT/2000 or above\noutput/registry.0x8a5449d0.NTUSERDAT.reg:   MS Windows registry file, NT/2000 or above\noutput/registry.0x8c7e7008.BCD.reg:         MS Windows registry file, NT/2000 or above\noutput/registry.0x8cec09d0.ntuserdat.reg:   MS Windows registry file, NT/2000 or above\noutput/registry.0x8d432008.SOFTWARE.reg:    MS Windows registry file, NT/2000 or above\noutput/registry.0x945229d0.UsrClassdat.reg: MS Windows registry file, NT/2000 or above\noutput/registry.0xa019c9d0.Syscachehve.reg: MS Windows registry file, NT/2000 or above\nNotice that the HARDWARE registry has \"Data\" as the type. This is because the first few cells of the registry are zeroed out. If you examine the registry with a hex editor, you will see valid keys and values:\n\n$ xxd output/registry.0x8883c7d0.HARDWARE.reg |grep -v \"0000 0000 0000 0000 0000 0000 0000 0000\" |less\n0001000: 6862 696e 0000 0000 0010 0000 0000 0000  hbin............\n0001020: a8ff ffff 6e6b 2c00 c1be 7203 3eba cf01  ....nk,...r.>...\n0001030: 0000 0000 d002 0000 0300 0000 0100 0000  ................\n0001040: 9018 0000 2801 0080 0000 0000 ffff ffff  ....(...........\n0001050: 7800 0000 ffff ffff 1600 0000 0000 0000  x...............\n0001060: 0000 0000 0000 0000 0000 0000 0800 0000  ................\n0001070: 4841 5244 5741 5245 58ff ffff 736b 0000  HARDWAREX...sk..\n0001080: 7800 0000 7800 0000 2800 0000 8c00 0000  x...x...(.......\n0001090: 0100 0480 7000 0000 8000 0000 0000 0000  ....p...........\n00010a0: 1400 0000 0200 5c00 0400 0000 0002 1400  ......\\.........\n00010b0: 3f00 0f00 0101 0000 0000 0005 1200 0000  ?...............\n00010c0: 0002 1800 3f00 0f00 0102 0000 0000 0005  ....?...........\n00010d0: 2000 0000 2002 0000 0002 1400 1900 0200   ... ...........\n00010e0: 0101 0000 0000 0001 0000 0000 0002 1400  ................\n00010f0: 1900 0200 0101 0000 0000 0005 0c00 0000  ................\n0001100: 0102 0000 0000 0005 2000 0000 2002 0000  ........ ... ...\n0001110: 0101 0000 0000 0005 1200 0000 0000 0000  ................\n0001120: a0ff ffff 6e6b 2000 3eb5 f30a 3eba cf01  ....nk .>...>...\n0001130: 0000 0000 2000 0000 0500 0000 0100 0000  .... ...........\n0001140: 6828 0200 701f 0080 0000 0000 ffff ffff  h(..p...........\n0001150: 7800 0000 ffff ffff 1c00 0000 0000 0000  x...............\n0001160: 0000 0000 0000 0000 0000 0000 0900 0000  ................\n0001170: 4445 5649 4345 4d41 5000 0000 0000 0000  DEVICEMAP.......\n0001180: f0ff ffff 6c66 0100 0802 0000 5379 7374  ....lf......Syst\n0001190: a0ff ffff 6e6b 2000 00fc 6d03 3eba cf01  ....nk ...m.>...\n00011a0: 0000 0000 2000 0000 0100 0000 0000 0000  .... ...........\n00011b0: 8001 0000 ffff ffff 0000 0000 ffff ffff  ................\n00011c0: 7800 0000 ffff ffff 0c00 0000 0000 0000  x...............\n00011d0: 0000 0000 0000 0000 0000 0000 0b00 0000  ................\n00011e0: 4445 5343 5249 5054 494f 4e00 0000 0000  DESCRIPTION.....\n00011f0: f0ff ffff 6c66 0100 901b 0000 494e 5445  ....lf......INTE\n0001200: f8ff ffff 181a 0000 a8ff ffff 6e6b 2000  ............nk .\n0001210: b68f c70b 3eba cf01 0000 0000 9001 0000  ....>...........\n0001220: 0300 0000 0200 0000 f012 0000 a05a 0080  .............Z..\n0001230: 0800 0000 8017 0000 7800 0000 ffff ffff  ........x.......\n0001240: 2c00 0000 0000 0000 2a00 0000 6600 0000  ,.......*...f...\n0001250: 0000 0000 0600 0000 5379 7374 656d 0000  ........System..\n0001260: d0ff ffff 766b 1500 1000 0000 9002 0000  ....vk..........\n0001270: 0300 0000 0100 0000 436f 6d70 6f6e 656e  ........Componen\n0001280: 7420 496e 666f 726d 6174 696f 6e00 0000  t Information...\n[snip]\nYou may also dump only one registry at a time by using the virtual offset of the hive:\n\n$ python vol.py -f voltest.dmp --profile=Win7SP1x86 hivelist\nVolatility Foundation Volatility Framework 2.4\nVirtual    Physical   Name\n---------- ---------- ----\n[snip]\n0x8cec09d0 0x0d1f19d0 \\??\\C:\\Users\\test\\ntuser.dat\n[snip]\n\n$ python vol.py -f voltest.dmp --profile=Win7SP1x86 dumpregistry -o 0x8cec09d0 -D output/\nVolatility Foundation Volatility Framework 2.4\n**************************************************\nWriting out registry: registry.0x8cec09d0.ntuserdat.reg\n\nPhysical layer returned None for index 9000, filling with NULL\nPhysical layer returned None for index a000, filling with NULL\nPhysical layer returned None for index b000, filling with NULL\nPhysical layer returned None for index c000, filling with NULL\nPhysical layer returned None for index d000, filling with NULL\nPhysical layer returned None for index e000, filling with NULL\nPhysical layer returned None for index f000, filling with NULL\nPhysical layer returned None for index 10000, filling with NULL\nPhysical layer returned None for index 11000, filling with NULL\nPhysical layer returned None for index 20000, filling with NULL\nPhysical layer returned None for index 21000, filling with NULL\n\n$ file output/*\noutput/registry.0x8cec09d0.ntuserdat.reg: MS Windows registry file, NT/2000 or above\nCrash Dumps, Hibernation, and Conversion\nVolatility supports memory dumps in several different formats, to ensure the highest compatibility with different acquisition tools. You can analyze hibernation files, crash dumps, virtualbox core dumps, etc in the same way as any raw memory dump and Volatility will detect the underlying file format and apply the appropriate address space. You can also convert between file formats.\n\ncrashinfo\n\nInformation from the crashdump header can be printed using the crashinfo command. You will see information like that of the Microsoft dumpcheck utility.\n\n$ python vol.py -f win7_x64.dmp --profile=Win7SP0x64 crashinfo\nVolatility Foundation Volatility Framework 2.4\n_DMP_HEADER64:\n Majorversion:         0x0000000f (15)\n Minorversion:         0x00001db0 (7600)\n KdSecondaryVersion    0x00000000\n DirectoryTableBase    0x32a44000\n PfnDataBase           0xfffff80002aa8220\n PsLoadedModuleList    0xfffff80002a3de50\n PsActiveProcessHead   0xfffff80002a1fb30\n MachineImageType      0x00008664\n NumberProcessors      0x00000002\n BugCheckCode          0x00000000\n KdDebuggerDataBlock   0xfffff800029e9070\n ProductType           0x00000001\n SuiteMask             0x00000110\n WriterStatus          0x00000000\n Comment               PAGEPAGEPAGEPAGEPAGEPAGE[snip]\n\nPhysical Memory Description:\nNumber of runs: 3\nFileOffset    Start Address    Length\n00002000      00001000         0009e000\n000a0000      00100000         3fde0000\n3fe80000      3ff00000         00100000\n3ff7f000      3ffff000\nhibinfo\n\nThe hibinfo command reveals additional information stored in the hibernation file, including the state of the Control Registers, such as CR0, etc. It also identifies the time at which the hibernation file was created, the state of the hibernation file, and the version of windows being hibernated. Example output for the function is shown below.\n\n$ python vol.py -f hiberfil.sys --profile=Win7SP1x64 hibinfo\nIMAGE_HIBER_HEADER:\nSignature: HIBR\nSystemTime: 2011-12-23 16:34:27\n\nControl registers flags\nCR0: 80050031\nCR0[PAGING]: 1\nCR3: 00187000\nCR4: 000006f8\nCR4[PSE]: 1\nCR4[PAE]: 1\n\nWindows Version is 6.1 (7601)\nimagecopy\n\nThe imagecopy command allows you to convert any existing type of address space (such as a crashdump, hibernation file, virtualbox core dump, vmware snapshot, or live firewire session) to a raw memory image. This conversion be necessary if some of your other forensic tools only support reading raw memory dumps.\n\nThe profile should be specified for this command, so if you don't know it already, use the [or Command Reference#kdbgscan kdbgscan commands first. The output file is specified with the -O flag. The progress is updated as the file is converted:\n\n$ python vol.py -f win7_x64.dmp --profile=Win7SP0x64 imagecopy -O copy.raw\nVolatility Foundation Volatility Framework 2.4\nWriting data (5.00 MB chunks): |.......................................|\nraw2dmp\n\nTo convert a raw memory dump (for example from a win32dd acquisition or a VMware .vmem file) into a Microsoft crash dump, use the raw2dmp command. This is useful if you want to load the memory in the WinDbg kernel debugger for analysis.\n\n$ python vol.py -f ~/Desktop/win7_trial_64bit.raw --profile=Win7SP0x64 raw2dmp -O copy.dmp\nVolatility Foundation Volatility Framework 2.4\nWriting data (5.00 MB chunks): |..............................................................................|\nvboxinfo\n\nTo pull details from a virtualbox core dump, use the vboxinfo command.\n\n$ python vol.py -f ~/Desktop/win7sp1x64_vbox.elf --profile=Win7SP1x64 vboxinfo\nVolatility Foundation Volatility Framework 2.4\n\nMagic: 0xc01ac0de\nFormat: 0x10000\nVirtualBox 4.1.23 (revision 80870)\nCPUs: 1\n\nFile Offset        PhysMem Offset     Size\n------------------ ------------------ ------------------\n0x0000000000000758 0x0000000000000000 0x00000000e0000000\n0x00000000e0000758 0x00000000e0000000 0x0000000003000000\n0x00000000e3000758 0x00000000f0400000 0x0000000000400000\n0x00000000e3400758 0x00000000f0800000 0x0000000000004000\n0x00000000e3404758 0x00000000ffff0000 0x0000000000010000\n0x00000000e3414758 0x0000000100000000 0x000000006a600000\nvmwareinfo\n\nUse this plugin to analyze header information from vmware saved state (vmss) or vmware snapshot (vmsn) files. The metadata contains CPU registers, the entire VMX configuration file, memory run information, and PNG screenshots of the guest VM.\n\n$ python vol.py -f ~/Desktop/Win7SP1x64-d8737a34.vmss vmwareinfo --verbose | less\n\nMagic: 0xbad1bad1 (Version 1)\nGroup count: 0x5c\n\nFile Offset PhysMem Offset Size\n----------- -------------- ----------\n0x000010000 0x000000000000 0xc0000000\n0x0c0010000 0x000100000000 0xc0000000\n\nDataOffset   DataSize Name                                               Value\n---------- ---------- -------------------------------------------------- -----\n0x00001cd9        0x4 Checkpoint/fileversion                             0xa\n0x00001cfc      0x100 Checkpoint/ProductName\n0x00001cfc  56 4d 77 61 72 65 20 45 53 58 00 00 00 00 00 00   VMware.ESX......\n0x00001d0c  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00   ................\n[snip]\n0x00001e1d      0x100 Checkpoint/VersionNumber\n0x00001e1d  34 2e 31 2e 30 00 00 00 00 00 00 00 00 00 00 00   4.1.0...........\n0x00001e2d  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00   ................\n[snip]\n0x00002046        0x4 Checkpoint/Platform                                0x1\n0x00002055        0x4 Checkpoint/usageMode                               0x1\n0x00002062        0x4 Checkpoint/memSize                                 0x1800\n......\nhpakinfo\n\nThis plugin shows info from an hpak formatted memory dump created by FDPro.exe.\n\n$ python vol.py -f memdump.hpak hpakinfo\nHeader:     HPAKSECTHPAK_SECTION_PHYSDUMP\nLength:     0x20000000\nOffset:     0x4f8\nNextOffset: 0x200004f8\nName:       memdump.bin\nCompressed: 0\n\nHeader:     HPAKSECTHPAK_SECTION_PAGEDUMP\nLength:     0x30000000\nOffset:     0x200009d0\nNextOffset: 0x500009d0\nName:       dumpfile.sys\nCompressed: 0\nhpakextract\n\nIf you have an hpak file whose contents are compressed, you can extract and decompress the physical memory image using this plugin.\n\nFile System\nmbrparser\n\nScans for and parses potential Master Boot Records (MBRs). There are different options for finding MBRs and filtering output. For more information please see Recovering Master Boot Records from Memory. While this plugin was written with Windows bootkits in mind, it can also be used with memory samples from other systems.\n\nWhen run without any extra options, mbrparser scans for and returns information all potential MBRs defined by signature ('\\x55\\xaa') found in memory. Information includes: disassembly of bootcode (must have distorm3 installed) and partition information. This will most likely have false positives.\n\nIf distorm3 is not installed, the -H/--hex option can be used to get the entire bootcode section in hex instead of disassembly:\n\n$ python vol.py -f [sample] mbrparser -H\nIf the physical offset of the MBR is known, it can be specified with the -o/--offset= option for example:\n\n$ python vol.py -f [sample] -o 0x600 mbrparser\nIf the md5 hash of the desired bootcode is known, one can be specified using either the -M/--hash (the hash of bootcode up to the RET instruction) or -F/--fullhash (the hash of full bootcode) option.\n\n$ python vol.py mbrparser -f AnalysisXPSP3.vmem -M 6010862faee6d5e314aba791380d4f41\nor\n\n$ python vol.py mbrparser -f AnalysisXPSP3.vmem -F 6010862faee6d5e314aba791380d4f41\nIn order to cut down on false positives there is a -C/--check option that checks the partition table for one bootable partition that has a known, nonempty type (NTFS, FAT*, etc).\n\n$ python vol.py -f [sample] -C mbrparser\nThere is also an option to change the offset for the start of the disassembly. This can be useful for investigating machines (like Windows XP) that only copy the part of the MBR bootcode that has not yet executed. For example, before changing the offset:\n\n$ python vol.py mbrparser -f AnalysisXPSP3.vmem -o 0x600\nVolatility Foundation Volatility Framework 2.4\nPotential MBR at physical offset: 0x600\nDisk Signature: d8-8f-d8-8f\nBootcode md5: c1ca166a3417427890520bbb18911b1f\nBootcode (FULL) md5: c0bf3a94515bbd70e5a0af82f1804d89\nDisassembly of Bootable Code:\n0x00000600: 0000                             ADD [BX+SI], AL\n0x00000602: 0000                             ADD [BX+SI], AL\n0x00000604: 0000                             ADD [BX+SI], AL\n0x00000606: 0000                             ADD [BX+SI], AL\n0x00000608: 0000                             ADD [BX+SI], AL\n0x0000060a: 0000                             ADD [BX+SI], AL\n0x0000060c: 0000                             ADD [BX+SI], AL\n0x0000060e: 0000                             ADD [BX+SI], AL\n0x00000610: 0000                             ADD [BX+SI], AL\n0x00000612: 0000                             ADD [BX+SI], AL\n0x00000614: 0000                             ADD [BX+SI], AL\n0x00000616: 0000                             ADD [BX+SI], AL\n0x00000618: 0000                             ADD [BX+SI], AL\n0x0000061a: 00bdbe07                         ADD [DI+0x7be], BH\n0x0000061e: b104                             MOV CL, 0x4\n0x00000620: 386e00                           CMP [BP+0x0], CH\n[snip]\nAfter changing the starting offset:\n\n$ python vol.py mbrparser -f AnalysisXPSP3.vmem -o 0x600 -D 0x1b\nVolatility Foundation Volatility Framework 2.4\nPotential MBR at physical offset: 0x600\nDisk Signature: d8-8f-d8-8f\nBootcode md5: 961f3ad835d6fa9396e60ea9f825c393\nBootcode (FULL) md5: f54546c199c72389f20d537997d50c66\nDisassembly of Bootable Code:\n0x0000061b: bdbe07                           MOV BP, 0x7be\n0x0000061e: b104                             MOV CL, 0x4\n0x00000620: 386e00                           CMP [BP+0x0], CH\n0x00000623: 7c09                             JL 0x13\n0x00000625: 7513                             JNZ 0x1f\n0x00000627: 83c510                           ADD BP, 0x10\n0x0000062a: e2f4                             LOOP 0x5\n[snip]\nmftparser\n\nThis plugin scans for potential Master File Table (MFT) entries in memory (using \"FILE\" and \"BAAD\" signatures) and prints out information for certain attributes, currently: $FILE_NAME ($FN), $STANDARD_INFORMATION ($SI), $FN and $SI attributes from the $ATTRIBUTE_LIST, $OBJECT_ID (default output only) and resident $DATA. This plugin has room for expansion, however, and VTypes for other attributes are already included. For more information please see Reconstructing the MBR and MFT from Memory (OMFW 2012 slides). Options of interest include:\n\n--machine - Machine name to add to timeline header (useful when combining timelines from multiple machines)\n-D/--dump-dir - Output directory to which resident data files are dumped\n--output=body - print output in Sleuthkit 3.X body format\n--no-check - Prints out all entries including those with null timestamps\n-E/--entry-size - Changes the default 1024 byte MFT entry size.\n-O/--offset - Prints out the MFT entry at a give offset (comma delimited)\nThis plugin may take a while to run before seeing output, since it scans first and then builds the directory tree for full file paths.\n\nExample (default output):\n\n$ python vol.py -f Bob.vmem mftparser\nVolatility Foundation Volatility Framework 2.4\nScanning for MFT entries and building directory, this can take a while\n[snip]\n***************************************************************************\nMFT entry found at offset 0x1e69c00\nType: File\nRecord Number: 12091\nLink count: 2\n\n\n$STANDARD_INFORMATION\nCreation             Modified             MFT Altered          Access Date          Type\n-------------------- -------------------- -------------------- -------------------- ----\n2010-02-27 20:12:32  2010-02-27 20:12:32  2010-02-27 20:12:32  2010-02-27 20:12:32  Archive\n\n$FILE_NAME\nCreation             Modified             MFT Altered          Access Date          Name/Path\n-------------------- -------------------- -------------------- -------------------- ---------\n2010-02-27 20:12:32  2010-02-27 20:12:32  2010-02-27 20:12:32  2010-02-27 20:12:32  Documents and Settings\\Administrator\\Cookies\\ADMINI~1.TXT\n\n$FILE_NAME\nCreation             Modified             MFT Altered          Access Date          Name/Path\n-------------------- -------------------- -------------------- -------------------- ---------\n2010-02-27 20:12:32  2010-02-27 20:12:32  2010-02-27 20:12:32  2010-02-27 20:12:32  Documents and Settings\\Administrator\\Cookies\\administrator@search-network-plus[1].txt\n\n$DATA\n0000000000: 65 78 70 0a 31 39 0a 73 65 61 72 63 68 2d 6e 65   exp.19.search-ne\n0000000010: 74 77 6f 72 6b 2d 70 6c 75 73 2e 63 6f 6d 2f 0a   twork-plus.com/.\n0000000020: 31 35 33 36 0a 33 03 00 32 34 33 33 39 32 30 0a   1536.3..2433920.\n0000000030: 33 30 30 36 32 36 30 35 0a 38 33 37 34 31 36 35   30062605.8374165\n0000000040: 37 36 0a 33 30 30 36 32 35 36 39 0a 2a 0a         76.30062569.*.\n\n***************************************************************************\n[snip]\n***************************************************************************\nMFT entry found at offset 0x1cdbac00\nType: In Use & File\nRecord Number: 12079\nLink count: 1\n\n\n$STANDARD_INFORMATION\nCreation             Modified             MFT Altered          Access Date          Type\n-------------------- -------------------- -------------------- -------------------- ----\n2010-02-27 20:12:28  2010-02-27 20:12:28  2010-02-27 20:12:28  2010-02-27 20:12:28  Archive\n\n$FILE_NAME\nCreation             Modified             MFT Altered          Access Date          Name/Path\n-------------------- -------------------- -------------------- -------------------- ---------\n2010-02-27 20:12:28  2010-02-27 20:12:28  2010-02-27 20:12:28  2010-02-27 20:12:28  Documents and Settings\\Administrator\\Local Settings\\Temp\\plugtmp\\PDF.php\n\n$DATA\nNon-Resident\n\n***************************************************************************\n[snip]\nThe bodyfile output is also an option. It is recommended that the output be stored in a file using the --output-file option, since it is quite lengthy. The following shows creating a bodyfile using mftparser while dumping resident files. You can also see a file of interest that is created on the system (f.txt) which happens to be recovered in the output directory:\n\n$ python vol.py -f grrcon.img mftparser --output=body -D output --output-file=grrcon_mft.body\nVolatility Foundation Volatility Framework 2.4\nScanning for MFT entries and building directory, this can take a while\n\n$ cat grrcon_mft.body\n[snip]\n0|[MFT STD_INFO] WINDOWS\\system32\\systems (Offset: 0x15938400)|12029|---------------|0|0|0|1335579320|1335579320|1335579320|1335578463\n0|[MFT FILE_NAME] WINDOWS\\system32\\systems\\f.txt (Offset: 0x15938800)|12030|---a-----------|0|0|0|1335578503|1335578503|1335578503|1335578503\n0|[MFT STD_INFO] WINDOWS\\system32\\systems\\f.txt (Offset: 0x15938800)|12030|---a-----------|0|0|0|1335578503|1335578503|1335578503|1335578503\n0|[MFT FILE_NAME] WINDOWS\\system32\\systems\\g.exe (Offset: 0x15938c00)|12031|---a-----------|0|0|0|1335578514|1335578514|1335578514|1335578514\n0|[MFT STD_INFO] WINDOWS\\system32\\systems\\g.exe (Offset: 0x15938c00)|12031|---a-----------|0|0|0|1335579014|1335578514|1335578514|1335578514\n0|[MFT FILE_NAME] WINDOWS\\inf\\divasrv.inf (Offset: 0x15c83000)|2192|---a-----------|0|0|22554|1332601266|1332601266|1332601266|1332601235\n[snip]\n\n$ ls output/*15938800*\noutput/file.0x15938800.data0.dmp\n\n$ cat output/*15938800*\nopen 66.32.119.38\njack\n2awes0me\nlcd c:\\WINDOWS\\System32\\systems\ncd  /home/jack\nbinary\nmput \"*.txt\"\ndisconnect\nbye\nThe Sleuthkit mactime utility can then be used to output the bodyfile in a readable manner:\n\n$ mactime -b grrcon_mft.body -d -z UTC |less\n[snip]\nSat Apr 28 2012 02:01:43,0,macb,---a-----------,0,0,12030,\"[MFT FILE_NAME] WINDOWS\\system32\\systems\\f.txt (Offset: 0x15938800)\"\nSat Apr 28 2012 02:01:43,0,macb,---a-----------,0,0,12030,\"[MFT STD_INFO] WINDOWS\\system32\\systems\\f.txt (Offset: 0x15938800)\"\nSat Apr 28 2012 02:01:54,0,macb,---a-----------,0,0,12031,\"[MFT FILE_NAME] WINDOWS\\system32\\systems\\g.exe (Offset: 0x15938c00)\"\nSat Apr 28 2012 02:01:54,0,m.cb,---a-----------,0,0,12031,\"[MFT STD_INFO] WINDOWS\\system32\\systems\\g.exe (Offset: 0x15938c00)\"\nSat Apr 28 2012 02:02:05,0,macb,---a-----------,0,0,12032,\"[MFT FILE_NAME] WINDOWS\\system32\\systems\\p.exe (Offset: 0x18229000)\"\nSat Apr 28 2012 02:02:05,0,...b,---a-----------,0,0,12032,\"[MFT STD_INFO] WINDOWS\\system32\\systems\\p.exe (Offset: 0x18229000)\"\nSat Apr 28 2012 02:02:06,0,m...,---a-----------,0,0,12032,\"[MFT STD_INFO] WINDOWS\\system32\\systems\\p.exe (Offset: 0x18229000)\"\nSat Apr 28 2012 02:02:17,0,macb,---a-----------,0,0,12033,\"[MFT FILE_NAME] WINDOWS\\system32\\systems\\r.exe (Offset: 0x18229400)\"\nSat Apr 28 2012 02:02:17,0,m.cb,---a-----------,0,0,12033,\"[MFT STD_INFO] WINDOWS\\system32\\systems\\r.exe (Offset: 0x18229400)\"\nSat Apr 28 2012 02:02:26,0,macb,---a-----------,0,0,12034,\"[MFT FILE_NAME] WINDOWS\\system32\\systems\\sysmon.exe (Offset: 0x18229800)\"\nSat Apr 28 2012 02:02:26,0,...b,---a-----------,0,0,12034,\"[MFT STD_INFO] WINDOWS\\system32\\systems\\sysmon.exe (Offset: 0x18229800)\"\nSat Apr 28 2012 02:02:27,0,m.c.,---a-----------,0,0,12034,\"[MFT STD_INFO] WINDOWS\\system32\\systems\\sysmon.exe (Offset: 0x18229800)\"\n[snip]\nMiscellaneous\nstrings\n\nFor a given image and a file with lines of the form <decimal_offset>:<string>, or <decimal_offset> <string>, output the corresponding process and virtual addresses where that string can be found. Expected input for this tool is the output of Microsoft Sysinternals' Strings utility, or another utility that provides similarly formatted offset:string mappings. Note that the input offsets are physical offsets from the start of the file/image.\n\nSysinternals Strings can be used on Linux/Mac using Wine. Output should be redirected to a file to be fed to the Volatility strings plugin. If you're using GNU strings command, use the -td flags to produce offsets in decimal (the plugin does not accept hex offsets). Some example usages are as follows:\n\nWindows\n\nC:\\> strings.exe \u2013q \u2013o -accepteula win7.dd > win7_strings.txt\nIt can take a while for the Sysinternals strings program to finish. The \u2013q and \u2013o switches are imperative, since they make sure the header is not output (-q) and that there is an offset for each line (-o).\n\nLinux/Mac\n\nYou can use the Sysinternals strings program with wine:\n\n$ wine strings.exe \u2013q \u2013o -accepteula win7.dd > win7_strings.txt\nYou can also use the GNU strings utility that comes with Linux and Mac (Note: the default strings utility on Mac does not have Unicode support. You can install the GNU binutils package in order to get a strings utility that does). You should use the -td flags to get the decimal offset and will have to make a second pass with the -el flags in order to get (little endian) Unicode strings. Notice that the second pass appends (>>) to the existing file:\n\n$ strings -a -td win7.dd > win7_strings.txt\n$ strings -a -td -el win7.dd >> win7_strings.txt\nThe result should be a text file that contains the offset and strings from the image for example:\n\n16392:@@@\n17409:\n17441:\n17473:\"\"\"\n17505:###\n17537:$$$\n17569:%%%\n17601:&&&\n17633:'''\n17665:(((\n17697:)))\n17729:***\nEnCase Keyword Export\n\nYou can also use EnCase to export keywords and offsets in this format with some tweaking. One thing to note is that EnCase exports text in UTF-16 with a BOM of (U+FEFF) which can cause issues with the strings plugin. An example look at the exported keyword file:\n\nFile Offset Hit Text\n114923  DHCP\n114967  DHCP\n115892  DHCP\n115922  DHCP\n115952  DHCP\n116319  DHCP\n\n[snip]\nNow tweaking the file by removing the header and tabs we have:\n\n114923:DHCP\n114967:DHCP\n115892:DHCP\n115922:DHCP\n115952:DHCP\n116319:DHCP\n\n[snip]\nWe can see that it is UTF-16 and has a BOM of (U+FEFF) by using a hex editor.\n\n$ file export.txt\nexport.txt: Little-endian UTF-16 Unicode text, with CRLF, CR line terminators\n\n$ xxd export.txt |less\n\n0000000: fffe 3100 3100 3400 3900 3200 3300 3a00  ..1.1.4.9.2.3.:.\n\n[snip]\nWe have to convert this to ANSI or UTF-8. In Windows you can open the text file and use the \"Save As\" dialog to save the file as ANSI (in the \"Encoding\" drop-down menu). In Linux you can use iconv:\n\n$ iconv -f UTF-16 -t UTF-8 export.txt > export1.txt\nNOTE: You must make sure there are NO blank lines in your final \"strings\" file.\n\nNow we can see a difference in how these two files are handled:\n\n$ python vol.py -f Bob.vmem --profile=WinXPSP2x86 strings -s export.txt\nVolatility Foundation Volatility Framework 2.4\nERROR   : volatility.plugins.strings: String file format invalid.\n\n$ python vol.py -f Bob.vmem --profile=WinXPSP2x86 strings -s export1.txt\nVolatility Foundation Volatility Framework 2.4\n0001c0eb [kernel:2147598571] DHCP\n0001c117 [kernel:2147598615] DHCP\n0001c4b4 [kernel:2147599540] DHCP\n0001c4d2 [kernel:2147599570] DHCP\n0001c4f0 [kernel:2147599600] DHCP\n0001c65f [kernel:2147599967] DHCP\n0001c686 [kernel:2147600006] DHCP\n\n[snip]\nNOTE: The Volatility strings output is very verbose and it is best to redirect or save to a file. The following command saves the output using the --output-file option and filename \"win7_vol_strings.txt\"\n\n$ python vol.py --profile=Win7SP0x86 strings \u2013f win7.dd \u2013s win7_strings.txt --output-file=win7_vol_strings.txt\nBy default strings will only provide output for processes found by walking the doubly linked list pointed to by PsActiveProcessHead (see pslist) in addition to kernel addresses. strings can also provide output for hidden processes (see psscan) by using the (capital) -S switch:\n\n$ python vol.py --profile=Win7SP0x86 strings \u2013f win7.dd \u2013s win7_strings.txt --output-file=win7_vol_strings.txt -S\nAlso an EPROCESS offset can be provided:\n\n$ python vol.py --profile=Win7SP0x86 strings \u2013f win7.dd \u2013s win7_strings.txt --output-file=win7_vol_strings.txt -o 0x04a291a8\nThe strings plugin takes a while to complete. When it completes, you should have an output file with each line in the following format:\n\nphysical_address [kernel_or_pid:virtual_address] string\nIn the example output you can see PIDs/kernel references:\n\n$ less win7_vol_strings.txt\n\n000003c1 [kernel:4184445889] '<'@\n00000636 [kernel:4184446518] 8,t\n000006c1 [kernel:4184446657] w#r\n000006d8 [kernel:4184446680] sQOtN2\n000006fc [kernel:4184446716] t+a`j\n00000719 [kernel:4184446745] aas\n0000072c [kernel:4184446764] Invalid partition ta\n00000748 [kernel:4184446792] r loading operating system\n00000763 [kernel:4184446819] Missing operating system\n000007b5 [kernel:4184446901] ,Dc\n0000400b [kernel:2147500043 kernel:4184461323] 3TYk\n00004056 [kernel:2147500118 kernel:4184461398] #:s\n000040b0 [kernel:2147500208 kernel:4184461488] CO0\n000040e9 [kernel:2147500265 kernel:4184461545] BrvWo\n000040f0 [kernel:2147500272 kernel:4184461552] %Sz\n000040fc [kernel:2147500284 kernel:4184461564] A0?0=\n00004106 [kernel:2147500294 kernel:4184461574] 7http://crl.microsoft.com/pki/crl/products/WinIntPCA.crl0U\n\n[snip]\n\n00369f14 [1648:1975394068] Ph$\n00369f2e [1648:1975394094] 9}$\n00376044 [1372:20422724] Ju0w\n0037616d [1372:20423021] msxml6.dll\n003761e8 [1372:20423144] U'H\n003762e3 [1372:20423395] }e_\n0037632e [1372:20423470] xnA\n\n[snip]\n\n03678031 [360:2089816113 596:2089816113 620:2089816113 672:2089816113 684:2089816113 844:2089816113 932:2089816113 1064:2089816113 1164:2089816113 1264:2089816113 1516:2089816113 1648\n:2089816113 1896:2089816113 1904:2089816113 1756:2089816113 512:2089816113 1372:2089816113 560:2089816113] A$9B\nOnce you have the strings output, you can see which process(es) have the suspicious string in memory and can then narrow your focus. You can grep for the string or pattern depending on the context you were given. For example, if you are looking for a particular command:\n\n$ grep [command or pattern] win7_vol_strings.txt > strings_of_interest.txt\nFor all IPs:\n\n$ cat win7_vol_strings.txt | \\\nperl -e 'while(<>){if(/(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)/){print $_;}}' > IPs.txt\nFor all URLs:\n\n$ cat win7_vol_strings.txt | \\\nperl -e 'while(<>){ if(/(http|https|ftp|mail)\\:[\\/\\w.]+/){print $_;}}' > URLs.txt\nDepending on the context, your searches will vary.\n\nvolshell\n\nIf you want to interactively explore a memory image, use the volshell command. This gives you an interface similar to WinDbg into the memory dump. For example, you can:\n\nList processes\nSwitch into a process's context\nDisplay types of structures/objects\nOverlay a type over a given address\nWalk linked lists\nDisassemble code at a given address\nNote: volshell can take advantage of IPython if you have it installed. This will add tab-completion and saved command history.\n\nTo break into a volshell:\n\n$ python vol.py --profile=Win7SP0x86 -f win7.dmp volshell\nVolatility Foundation Volatility Framework 2.0\nCurrent context: process System, pid=4, ppid=0 DTB=0x185000\nWelcome to volshell Current memory image is:\nfile:///Users/M/Desktop/win7.dmp\nTo get help, type 'hh()'\n>>> hh()\nps()                                     : Print a process listing.\ncc(offset=None, pid=None, name=None)     : Change current shell context.\ndd(address, length=128, space=None)      : Print dwords at address.\ndb(address, length=128, width=16, space=None) : Print bytes as canonical hexdump.\nhh(cmd=None)                             : Get help on a command.\ndt(objct, address=None, address_space=None)  : Describe an object or show type info.\nlist_entry(head, objname, offset=-1, fieldname=None, forward=True) : Traverse a _LIST_ENTRY.\ndis(address, length=128, space=None)     : Disassemble code at a given address.\n\nFor help on a specific command, type 'hh(<command>)'\n>>>\nLet's say you want to see what's at 0x779f0000 in the memory of explorer.exe. First display the processes so you can get the PID or offset of Explorer's EPROCESS. (Note: if you want to view data in kernel memory, you do not need to switch contexts first.)\n\n>>> ps()\nName             PID    PPID   Offset\nSystem           4      0      0x83dad960\nsmss.exe         252    4      0x84e47840\ncsrss.exe        348    340    0x8d5ffd40\nwininit.exe      384    340    0x84e6e3d8\ncsrss.exe        396    376    0x8d580530\nwinlogon.exe     424    376    0x8d598530\nservices.exe     492    384    0x8d4cc030\nlsass.exe        500    384    0x8d6064a0\nlsm.exe          508    384    0x8d6075d8\nsvchost.exe      616    492    0x8d653030\nsvchost.exe      680    492    0x8d673b88\nsvchost.exe      728    492    0x8d64fb38\ntaskhost.exe     1156   492    0x8d7ee030\ndwm.exe          956    848    0x8d52bd40\nexplorer.exe     1880   1720   0x8d66c1a8\nwuauclt.exe      1896   876    0x83ec3238\nVMwareTray.exe   2144   1880   0x83f028d8\nVMwareUser.exe   2156   1880   0x8d7893b0\n[snip]\nNow switch into Explorer's context and print the data with either db (display as canonical hexdump) or dd (display as double-words):\n\n>>> dd(0x779f0000)\n779f0000  00905a4d 00000003 00000004 0000ffff\n779f0010  000000b8 00000000 00000040 00000000\n779f0020  00000000 00000000 00000000 00000000\n779f0030  00000000 00000000 00000000 000000e0\n779f0040  0eba1f0e cd09b400 4c01b821 685421cd\n779f0050  70207369 72676f72 63206d61 6f6e6e61\n779f0060  65622074 6e757220 206e6920 20534f44\n779f0070  65646f6d 0a0d0d2e 00000024 00000000\n>>> db(0x779f0000)\n779f0000   4d 5a 90 00 03 00 00 00 04 00 00 00 ff ff 00 00    MZ..............\n779f0010   b8 00 00 00 00 00 00 00 40 00 00 00 00 00 00 00    ........@.......\n779f0020   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................\n779f0030   00 00 00 00 00 00 00 00 00 00 00 00 e0 00 00 00    ................\n779f0040   0e 1f ba 0e 00 b4 09 cd 21 b8 01 4c cd 21 54 68    ..........L.Th\n779f0050   69 73 20 70 72 6f 67 72 61 6d 20 63 61 6e 6e 6f    is program canno\n779f0060   74 20 62 65 20 72 75 6e 20 69 6e 20 44 4f 53 20    t be run in DOS\n779f0070   6d 6f 64 65 2e 0d 0d 0a 24 00 00 00 00 00 00 00    mode....$.......\nSo there is a PE at 0x779f0000 in explorer.exe. If you want to disassemble instructions at RVA 0x2506 in the PE, do this:\n\n>>> dis(0x779f0000 + 0x2506)\n0x779f2506 8d0c48                           LEA ECX, [EAX+ECX*2]\n0x779f2509 8b4508                           MOV EAX, [EBP+0x8]\n0x779f250c 8b4c4802                         MOV ECX, [EAX+ECX*2+0x2]\n0x779f2510 8d0448                           LEA EAX, [EAX+ECX*2]\n0x779f2513 e9c07f0300                       JMP 0x77a2a4d8\n0x779f2518 85f6                             TEST ESI, ESI\n0x779f251a 0f85c12c0700                     JNZ 0x77a651e1\n0x779f2520 8b4310                           MOV EAX, [EBX+0x10]\n0x779f2523 8b407c                           MOV EAX, [EAX+0x7c]\n0x779f2526 8b4b18                           MOV ECX, [EBX+0x18]\n0x779f2529 0fb7444102                       MOVZX EAX, [ECX+EAX*2+0x2]\n0x779f252e 894520                           MOV [EBP+0x20], EAX\n[snip]\nIf you want to remind yourself of the members in an EPROCESS object for the given OS, do this:\n\n>>> dt(\"_EPROCESS\")\n'_EPROCESS' (704 bytes)\n0x0   : Pcb                            ['_KPROCESS']\n0x98  : ProcessLock                    ['_EX_PUSH_LOCK']\n0xa0  : CreateTime                     ['_LARGE_INTEGER']\n0xa8  : ExitTime                       ['_LARGE_INTEGER']\n0xb0  : RundownProtect                 ['_EX_RUNDOWN_REF']\n0xb4  : UniqueProcessId                ['pointer', ['void']]\n0xb8  : ActiveProcessLinks             ['_LIST_ENTRY']\n0xc0  : ProcessQuotaUsage              ['array', 2, ['unsigned long']]\n0xc8  : ProcessQuotaPeak               ['array', 2, ['unsigned long']]\n0xd0  : CommitCharge                   ['unsigned long']\n0xd4  : QuotaBlock                     ['pointer', ['_EPROCESS_QUOTA_BLOCK']]\n[snip]\nTo overlay the EPROCESS types onto the offset for explorer.exe, do this:\n\n>>> dt(\"_EPROCESS\", 0x8d66c1a8)\n[_EPROCESS _EPROCESS] @ 0x8D66C1A8\n0x0   : Pcb                            2372321704\n0x98  : ProcessLock                    2372321856\n0xa0  : CreateTime                     2010-07-06 22:38:07\n0xa8  : ExitTime                       1970-01-01 00:00:00\n0xb0  : RundownProtect                 2372321880\n0xb4  : UniqueProcessId                1880\n0xb8  : ActiveProcessLinks             2372321888\n0xc0  : ProcessQuotaUsage              -\n0xc8  : ProcessQuotaPeak               -\n0xd0  : CommitCharge                   4489\n0xd4  : QuotaBlock                     2372351104\n[snip]\nThe db, dd, dt, and dis commands all accept an optional \"space\" parameter which allows you to specify an address space. You will see different data depending on which address space you're using. Volshell has some defaults and rules that are important to note:\n\nIf you don't supply an address space and have not switched into a process context with cc, then you'll be using the default kernel space (System process).\n\nIf you don't supply an address space and have switched into a process context with cc, then you'll be using the space of the active/current process.\n\nIf you explicitly supply an address space, the one you supplied will be used.\n\nImagine you're using one of the scan commands (psscan, connscan, etc.) and you think it has picked up a false positive. The scan commands output a physical offset (offset into the memory dump file). You want to explore the data around the potential false positive to determine for yourself if any structure members appear sane or not. One way you could do that is by opening the memory dump in a hex viewer and going to the physical offset to view the raw bytes. However, a better way is to use volshell and overlay the structure question to the alleged physical offset. This allows you to see the fields interpreted as their intended type (DWORD, string, short, etc.)\n\nHere's an example. First instantiate a physical address space:\n\n>>> physical_space = utils.load_as(self._config, astype = 'physical')\nAssuming the alleged false positive for an EPROCESS is at 0x433308, you would then do:\n\n>>> dt(\"_EPROCESS\", 0x433308, physical_space)\n[_EPROCESS _EPROCESS] @ 0x00433308\n0x0   : Pcb                            4403976\n0x6c  : ProcessLock                    4404084\n0x70  : CreateTime                     1970-01-01 00:00:00\n0x78  : ExitTime                       1970-01-01 00:00:00\n...\nAnother neat trick is to use volshell in a non-interactive manner. For example, say you want to translate an address in kernel memory to its corresponding physical offset.\n\n$ echo \"hex(addrspace().vtop(0x823c8830))\" | python vol.py -f stuxnet.vmem volshell\nVolatility Foundation Volatility Framework 2.4\nCurrent context: process System, pid=4, ppid=0 DTB=0x319000\nWelcome to volshell Current memory image is:\nfile:///mem/stuxnet.vmem\nTo get help, type 'hh()'\n>>> '0x25c8830'\nThus the kernel address 0x823c8830 translates to physical offset 0x25c8830 in the memory dump file.\n\nYou can execute multiple commands sequentially like this:\n\n$ echo \"cc(pid=4); dd(0x10000)\" | [...]\nFor more information, see BDG's Introducing Volshell.\n\nbioskbd\n\nTo read keystrokes from the BIOS area of memory, use the bioskbd command. This can reveal passwords typed into HP, Intel, and Lenovo BIOS and SafeBoot, TrueCrypt, and BitLocker software. Depending on the tool used to acquire memory, not all memory samples will contain the necessary BIOS area. For more information, see Andreas Schuster's Reading Passwords From the Keyboard Buffer, David Sharpe's Duplicating Volatility Bioskbd Command Function on Live Windows Systems, and Jonathan Brossard's Bypassing pre-boot authentication passwords by instrumenting the BIOS keyboard buffer.\n\npatcher\n\nThe patcher plugin accepts a single argument of '-x' followed by an XML file. The XML file then specifies any required patches as in the following example:\n\n<patchfile>\n  <patchinfo method=\"pagescan\" name=\"Some Descriptive Name\">\n    <constraints>\n      <match offset=\"0x123\">554433221100</match>\n    </constraints>\n    <patches>\n      <setbytes offset=\"0x234\">001122334455</setbytes>\n    </patches>\n  </patchinfo>\n  <patchinfo>\n    ...\n  </patchinfo>\n</patchfile>\nThe XML root element is always patchfile, and contains any number of patchinfo elements. When the patchfile is run, it will scan over the memory once for each patchinfo, attempting to scan using the method specified in the method attribute. Currently the only support method is pagescan and this must be explicitly declared in each patchinfo element.\n\nEach pagescan type patchinfo element contains a single constraints element and a single patches element. The scan then proceeds over each page in memory, verifying that all constraints are met, and if so, the instructions specified in the patches element are carried out.\n\nThe constraints element contains any number of match elements which take a specific offset attribute (specifying where within the page the match should occur) and then contain a hexadecimal string for the bytes that are supposed to match.\n\nThe patches element contains any number of setbytes elements which take a specific offset attribute (specifying where with the page the patch should modify data) and then contains a hexidecimal string for the bytes that should be written into the page.\n\nNote: When running the patcher plugin, there will be no modification made to memory unless the write option (-w) has been specified on the command line.\n\npagecheck\n\nThe pagecheck plugin uses a kernel DTB (from the System/Idle process) and determines which pages should be memory resident (using the AddressSpace.get_available_pages method). For each page, it attempts to access the page data and reports details, such as the PDE and PTE addresses if the attempt fails. This is a diagnostic plugin, usually helpful in troubleshooting \"holes\" in an address space.\n\nThis plugin is not well-supported. It is in the contrib directory and currently only works with non-PAE x86 address spaces.\n\n$ python vol.py --plugins=contrib/plugins/ -f pat-2009-11-16.mddramimage pagecheck\nVolatility Foundation Volatility Framework 2.4\n(V): 0x06a5a000 [PDE] 0x038c3067 [PTE] 0x1fe5e047 (P): 0x1fe5e000 Size: 0x00001000\n(V): 0x06c5f000 [PDE] 0x14d62067 [PTE] 0x1fe52047 (P): 0x1fe52000 Size: 0x00001000\n(V): 0x06cd5000 [PDE] 0x14d62067 [PTE] 0x1fe6f047 (P): 0x1fe6f000 Size: 0x00001000\n(V): 0x06d57000 [PDE] 0x14d62067 [PTE] 0x1fe5c047 (P): 0x1fe5c000 Size: 0x00001000\n(V): 0x06e10000 [PDE] 0x14d62067 [PTE] 0x1fe62047 (P): 0x1fe62000 Size: 0x00001000\n(V): 0x070e4000 [PDE] 0x1cac7067 [PTE] 0x1fe1e047 (P): 0x1fe1e000 Size: 0x00001000\n(V): 0x077a8000 [PDE] 0x1350a067 [PTE] 0x1fe06047 (P): 0x1fe06000 Size: 0x00001000\n(V): 0x07a41000 [PDE] 0x05103067 [PTE] 0x1fe05047 (P): 0x1fe05000 Size: 0x00001000\n(V): 0x07c05000 [PDE] 0x103f7067 [PTE] 0x1fe30047 (P): 0x1fe30000 Size: 0x00001000\n...\ntimeliner\n\nThis timeliner plugin creates a timeline from various artifacts in memory from the following sources (items in parenthesis are filters that may be used with the --type flag in order to obtain only items of that artifact):\n\nSystem time (ImageDate)\nProcesses (Process)\nCreate and Exit times\nLastTrimTime (XP and 2003 only)\nDLLs (Process, LoadTime)\nLoadTime (Windows 7 and 8 only)\nPE Timestamps (TimeDateStamp)\nModules/Processes/DLLs\n_IMAGE_FILE_HEADER\n_IMAGE_DEBUG_DIRECTORY\nThreads (Thread)\nCreate and Exit times\nSockets (Socket)\nCreate time\nEvent logs (XP and 2003 only) (EvtLog)\nIE History (IEHistory)\nRegistry hives (_CMHIVE and _HBASE_BLOCK)\nRegistry keys\nLastWriteTime of registry keys in _CMHIVE (Registry)\nLastWriteTime of registry key objects referenced in the handle table (_CM_KEY_BODY)\nEmbedded registry (filters below)\nUserassist\nShimcache\nTimers (Timer)\nSymbolic links (Symlink)\nYou can filter for any of the above options in order to have more focused output using the --type flag:\n\n$ python vol.py -f Win2k12x64-Snapshot3.vmsn --profile=Win2012R2x64 --kdbg=0xf800f17dd9b0 timeliner --type=_CMHIVE\nVolatility Foundation Volatility Framework 2.4\n1970-01-01 00:00:00 UTC+0000|[_CMHIVE LastWriteTime]| [no name]|\n1970-01-01 00:00:00 UTC+0000|[_CMHIVE LastWriteTime]| \\REGISTRY\\MACHINE\\SYSTEM|\n2014-06-20 06:31:29 UTC+0000|[_CMHIVE LastWriteTime]| \\SystemRoot\\System32\\Config\\SOFTWARE|\n2014-06-20 06:31:29 UTC+0000|[_CMHIVE LastWriteTime]| \\SystemRoot\\System32\\Config\\DEFAULT|\n2014-06-20 06:31:29 UTC+0000|[_CMHIVE LastWriteTime]| \\REGISTRY\\MACHINE\\SAM|\n2014-06-20 06:31:05 UTC+0000|[_CMHIVE LastWriteTime]| \\??\\C:\\Users\\Administrator\\AppData\\Local\\Microsoft\\Windows\\UsrClass.dat|\n2013-09-15 03:33:22 UTC+0000|[_CMHIVE LastWriteTime]| \\SystemRoot\\System32\\Config\\BBI|\n2014-06-20 06:31:29 UTC+0000|[_CMHIVE LastWriteTime]| \\??\\C:\\Windows\\ServiceProfiles\\NetworkService\\NTUSER.DAT|\n2014-06-20 06:31:29 UTC+0000|[_CMHIVE LastWriteTime]| \\REGISTRY\\MACHINE\\SECURITY|\n2014-06-20 06:31:05 UTC+0000|[_CMHIVE LastWriteTime]| \\??\\C:\\Users\\Administrator\\ntuser.dat|\n2014-06-20 06:31:29 UTC+0000|[_CMHIVE LastWriteTime]| \\??\\C:\\Windows\\ServiceProfiles\\LocalService\\NTUSER.DAT|\n2014-06-20 06:31:29 UTC+0000|[_CMHIVE LastWriteTime]| \\Device\\HarddiskVolume1\\Boot\\BCD|\n1970-01-01 00:00:00 UTC+0000|[_CMHIVE LastWriteTime]| \\REGISTRY\\MACHINE\\HARDWARE|\nThere are three options for output: default text output, bodyfile format and an Excel 2007 file. For more details see Timeliner Release Documentation (pdf) and the OMFW 2011 presentation Time is on My Side. You can also include a machine identifier in the header with the --machine flag (this is useful when combining timelines from multiple machines). The following shows the default text output:\n\n$ python vol.py -f XPSP3x86.vmem timeliner\nVolatility Foundation Volatility Framework 2.4\n2011-10-13 04:29:21 UTC+0000|[LIVE RESPONSE]| (System time)\n2010-08-22 17:38:12 UTC+0000|[IEHISTORY]| explorer.exe->Visited: Administrator@about:Home| PID: 1196/Cache type \"URL \" at 0x17f5100 End: 2010-08-22 17:38:12 UTC+0000\n2010-10-31 13:48:47 UTC+0000|[IEHISTORY]| explorer.exe->Visited: Administrator@file:///C:/Documents%20and%20Settings/Administrator/Desktop/Sparkling_Swiss-4288x2848.jpg| PID: 1196/Cache type \"URL \" at 0x17f5300 End: 2010-10-31 13:48:47 UTC+0000\n2010-10-31 13:49:00 UTC+0000|[IEHISTORY]| explorer.exe->Visited: Administrator@file:///C:/Documents%20and%20Settings/Administrator/My%20Documents/My%20Pictures/Sparkling_Swiss-4288x2848.jpg| PID: 1196/Cache type \"URL \" at 0x17f6000 End: 2010-10-31 13:49:00 UTC+0000\n2011-10-13 04:20:23 UTC+0000|[PROCESS]| wuauclt.exe| PID: 332/PPID: 1032/POffset: 0x0226d580\n2011-10-13 04:20:23 UTC+0000|[PROCESS LastTrimTime]| wuauclt.exe| PID: 332/PPID: 1032/POffset: 0x0226d580\n2010-10-29 17:08:54 UTC+0000|[Handle (Key)]| MACHINE| wuauclt.exe PID: 332/PPID: 1032/POffset: 0x0226d580\n2010-08-22 17:35:38 UTC+0000|[Handle (Key)]| MACHINE\\SOFTWARE\\MICROSOFT\\WINDOWS NT\\CURRENTVERSION\\DRIVERS32| wuauclt.exe PID: 332/PPID: 1032/POffset: 0x0226d580\n2010-08-22 17:35:38 UTC+0000|[Handle (Key)]| MACHINE\\SOFTWARE\\MICROSOFT\\WINDOWS NT\\CURRENTVERSION\\DRIVERS32| wuauclt.exe PID: 332/PPID: 1032/POffset: 0x0226d580\n2010-10-29 16:50:27 UTC+0000|[Handle (Key)]| MACHINE\\SOFTWARE\\CLASSES| wuauclt.exe PID: 332/PPID: 1032/POffset: 0x0226d580\n[snip]\nIf you don't want to do the extra step of importing, you can use the --output=xlsx option with --output-file=[FILE](OUTPUT) to save directly an Excel 2007 file. Note: You must have OpenPyxl installed for this.\n\n$ python vol.py -f XPSP3x86.vmem timeliner --output=xlsx --output-file=output.xlsx\nAnother option is to use the --output=body option for TSK 3.x bodyfile format. You can use this output option when you want to combine output from timeliner, mftparser and shellbags.\n\nBy default everything except the registry LastWrite timestamps are included in the output of timeliner, this is because obtaining the registry timestamps is quite labor intensive. In order to add them to the output, simply add the --type=Registry option when you run Volatility. You can also limit your focus of registry timestamps by listing a specific registry name (like --hive=SYSTEM) or user (--user=Jim) or both (--hive=UsrClass.dat --user=jim). These options are case insensitive.\n\n$ python vol.py -f win7SP1x86.vmem --profile=Win7SP1x86 timeliner --output=body --output-file=output.body --type=Registry --user=Jim --hive=UsrClass.dat\n", "tags": ["\u30bb\u30ad\u30e5\u30ea\u30c6\u30a3"]}