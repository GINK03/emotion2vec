{"context": "\n\n\u7d4c\u7def\n\u89e3\u51cd\u3057\u3066\u3001\u914d\u7f6e\u3057\u3066\u3001goapp serve\u3057\u305f\u3089Failed.\nDownload the App Engine SDK for Go \u00a0|\u00a0 App Engine standard environment for Go \u00a0|\u00a0 Google Cloud Platform\n\n\u30d1\u30c3\u30c1\n\u30a8\u30e9\u30fc\u3092\u307f\u308b\u3068\u3001set_skip_files_re\u95a2\u6570\u304c\u7121\u3044\u30e8\u3002\u3068\u3044\u308f\u308c\u3066\u3044\u308b\u3002\u305f\u3057\u304b\u306bWin32FileWatcher\u30af\u30e9\u30b9\u3060\u3051\u5b9f\u88c5\u3055\u308c\u3066\u3044\u306a\u304b\u3063\u305f\u3002\u4ee5\u4e0b\u306f\u4ed8\u3051\u713c\u304d\u5203\u7684\u30d1\u30c3\u30c1\u306a\u306e\u3067\u3001\u4e0d\u5b8c\u5168\u3060\u3068\u304a\u3082\u3044\u307e\u3059\u3002app.yaml \u3067skip_files \u30d1\u30e9\u30e1\u30fc\u30bf\u3092\u4f7f\u7528\u3057\u3066\u3044\u308b\u74b0\u5883\u306e\u65b9\u306f\u30a2\u30c3\u30d7\u30c7\u30fc\u30c8\u3092\u5f85\u3064\u307b\u3046\u304c\u3044\u3044\u3068\u304a\u3082\u3044\u307e\u3059\u3002\napp.yaml Reference \u00a0|\u00a0 App Engine standard environment for Python \u00a0|\u00a0 Google Cloud Platform\nVersion: 1.9.46 - 2016-11-03 Size: 67.7 MB\n\ngo_appengine\\google\\appengine\\tools\\devappserver2\\win32_file_watcher.py\nclass Win32FileWatcher(object):\n  \"\"\"Monitors a directory tree for changes using win32 API.\"\"\"\n  SUPPORTS_MULTIPLE_DIRECTORIES = False\n\n  def __init__(self, directory):\n    \"\"\"Initializer for Win32FileWatcher.\n\n    Args:\n      directory: A string representing the path to a directory that should\n          be monitored for changes i.e. files and directories added, renamed,\n          deleted or changed.\n    \"\"\"\n    self._directory = os.path.abspath(directory)\n    self._directory_handle = None\n    self._change_set = set()\n    self._lock = threading.Lock()  # protects self._change_set\n    self._stop = threading.Event()\n    self._change_event = threading.Event()\n    self._thread = None\n+   self._skip_files_re = None\n\n+ def set_skip_files_re(self, skip_files_re):\n+   \"\"\"Allows the file watcher to respect skip_files in app.yaml.\n+\n+   Args:\n+     skip_files_re: The skip_files field of current ModuleConfiguration,\n+         defined in app.yaml.\n+   \"\"\"\n+   self._skip_files_re = skip_files_re\n\n  def start(self):\n    \"\"\"Start watching the directory for changes.\"\"\"\n    self._directory_handle = ctypes.windll.kernel32.CreateFileW(\n        ctypes.c_wchar_p(self._directory),\n        ctypes.c_ulong(_FILE_LIST_DIRECTORY),\n        ctypes.c_ulong(_FILE_SHARE_READ |\n                       _FILE_SHARE_WRITE),\n        None,\n        ctypes.c_ulong(_OPEN_EXISTING),\n        # required to monitor changes.\n        ctypes.c_ulong(_FILE_FLAG_BACKUP_SEMANTICS),\n        None)\n    if self._directory_handle == _INVALID_HANDLE_VALUE:\n      raise ctypes.WinError()\n    self._thread = threading.Thread(\n        target=self._monitor, name='Win32 File Watcher')\n    self._thread.start()\n\n  def quit(self):\n    \"\"\"Stop watching the directory for changes.\"\"\"\n    self._stop.set()\n    # Note: this will unlock the blocking ReadDirectoryChangesW call.\n    ctypes.windll.kernel32.CancelIoEx(self._directory_handle, None)\n    self._thread.join()\n    ctypes.windll.kernel32.CloseHandle(self._directory_handle)\n\n  def changes(self, timeout_ms=0):\n    \"\"\"Returns the paths changed in the watched directory since the last call.\n\n    start() must be called before this method.\n\n    Args:\n      timeout_ms: the maximum number of milliseconds you allow this function to\n                  wait for a filesystem change.\n\n    Returns:\n      Returns an iterable of changed directories/files.\n    \"\"\"\n    if timeout_ms != 0:\n      self._change_event.wait(timeout_ms / 1000.0)\n\n    with self._lock:\n      result = self._change_set\n      self._change_set = set()\n      self._change_event.clear()\n\n    return result\n\n  def _monitor(self):\n    buff = ctypes.create_string_buffer(_BUFF_SIZE)\n    while not self._stop.isSet():\n      size_returned = ctypes.c_ulong(0)\n      result = ctypes.windll.kernel32.ReadDirectoryChangesW(\n          self._directory_handle,\n          buff,\n          ctypes.c_ulong(_BUFF_SIZE),\n          True,  # recursive.\n          ctypes.c_ulong(_FILE_NOTIFY_CHANGE_ANY),\n          ctypes.byref(size_returned),\n          None,\n          None)  # this is a blocking call.\n      if result == 0 and ctypes.GetLastError() == _ERROR_NOTIFY_ENUM_DIR:\n        logging.warning('Buffer overflow while monitoring for file changes.')\n        # we need to notify that something changed anyway\n        with self._lock:\n          self._change_set |= {'Unknown file'}\n      if result != 0 and size_returned.value != 0:\n        additional_changes = _parse_buffer(buff)\n        with self._lock:\n          self._change_set |= additional_changes\n          self._change_event.set()\n\n\n\n# \u7d4c\u7def\n\u89e3\u51cd\u3057\u3066\u3001\u914d\u7f6e\u3057\u3066\u3001`goapp serve`\u3057\u305f\u3089Failed.\n\n<a href=\"https://cloud.google.com/appengine/docs/go/download\" target=\"_blank\">Download the App Engine SDK for Go \u00a0|\u00a0 App Engine standard environment for Go \u00a0|\u00a0 Google Cloud Platform</a>\n\n#\u30d1\u30c3\u30c1\n\n\u30a8\u30e9\u30fc\u3092\u307f\u308b\u3068\u3001`set_skip_files_re`\u95a2\u6570\u304c\u7121\u3044\u30e8\u3002\u3068\u3044\u308f\u308c\u3066\u3044\u308b\u3002\u305f\u3057\u304b\u306bWin32FileWatcher\u30af\u30e9\u30b9\u3060\u3051\u5b9f\u88c5\u3055\u308c\u3066\u3044\u306a\u304b\u3063\u305f\u3002\u4ee5\u4e0b\u306f\u4ed8\u3051\u713c\u304d\u5203\u7684\u30d1\u30c3\u30c1\u306a\u306e\u3067\u3001\u4e0d\u5b8c\u5168\u3060\u3068\u304a\u3082\u3044\u307e\u3059\u3002app.yaml \u3067skip_files \u30d1\u30e9\u30e1\u30fc\u30bf\u3092\u4f7f\u7528\u3057\u3066\u3044\u308b\u74b0\u5883\u306e\u65b9\u306f\u30a2\u30c3\u30d7\u30c7\u30fc\u30c8\u3092\u5f85\u3064\u307b\u3046\u304c\u3044\u3044\u3068\u304a\u3082\u3044\u307e\u3059\u3002\n\n<a href=\"https://cloud.google.com/appengine/docs/python/config/appref#skip_files\" target=\"_blank\">app.yaml Reference \u00a0|\u00a0 App Engine standard environment for Python \u00a0|\u00a0 Google Cloud Platform</a>\n\nVersion: 1.9.46 - 2016-11-03 Size: 67.7 MB\n\n```diff:go_appengine\\google\\appengine\\tools\\devappserver2\\win32_file_watcher.py\nclass Win32FileWatcher(object):\n  \"\"\"Monitors a directory tree for changes using win32 API.\"\"\"\n  SUPPORTS_MULTIPLE_DIRECTORIES = False\n\n  def __init__(self, directory):\n    \"\"\"Initializer for Win32FileWatcher.\n\n    Args:\n      directory: A string representing the path to a directory that should\n          be monitored for changes i.e. files and directories added, renamed,\n          deleted or changed.\n    \"\"\"\n    self._directory = os.path.abspath(directory)\n    self._directory_handle = None\n    self._change_set = set()\n    self._lock = threading.Lock()  # protects self._change_set\n    self._stop = threading.Event()\n    self._change_event = threading.Event()\n    self._thread = None\n+   self._skip_files_re = None\n\n+ def set_skip_files_re(self, skip_files_re):\n+   \"\"\"Allows the file watcher to respect skip_files in app.yaml.\n+\n+   Args:\n+     skip_files_re: The skip_files field of current ModuleConfiguration,\n+         defined in app.yaml.\n+   \"\"\"\n+   self._skip_files_re = skip_files_re\n\n  def start(self):\n    \"\"\"Start watching the directory for changes.\"\"\"\n    self._directory_handle = ctypes.windll.kernel32.CreateFileW(\n        ctypes.c_wchar_p(self._directory),\n        ctypes.c_ulong(_FILE_LIST_DIRECTORY),\n        ctypes.c_ulong(_FILE_SHARE_READ |\n                       _FILE_SHARE_WRITE),\n        None,\n        ctypes.c_ulong(_OPEN_EXISTING),\n        # required to monitor changes.\n        ctypes.c_ulong(_FILE_FLAG_BACKUP_SEMANTICS),\n        None)\n    if self._directory_handle == _INVALID_HANDLE_VALUE:\n      raise ctypes.WinError()\n    self._thread = threading.Thread(\n        target=self._monitor, name='Win32 File Watcher')\n    self._thread.start()\n\n  def quit(self):\n    \"\"\"Stop watching the directory for changes.\"\"\"\n    self._stop.set()\n    # Note: this will unlock the blocking ReadDirectoryChangesW call.\n    ctypes.windll.kernel32.CancelIoEx(self._directory_handle, None)\n    self._thread.join()\n    ctypes.windll.kernel32.CloseHandle(self._directory_handle)\n\n  def changes(self, timeout_ms=0):\n    \"\"\"Returns the paths changed in the watched directory since the last call.\n\n    start() must be called before this method.\n\n    Args:\n      timeout_ms: the maximum number of milliseconds you allow this function to\n                  wait for a filesystem change.\n\n    Returns:\n      Returns an iterable of changed directories/files.\n    \"\"\"\n    if timeout_ms != 0:\n      self._change_event.wait(timeout_ms / 1000.0)\n\n    with self._lock:\n      result = self._change_set\n      self._change_set = set()\n      self._change_event.clear()\n\n    return result\n\n  def _monitor(self):\n    buff = ctypes.create_string_buffer(_BUFF_SIZE)\n    while not self._stop.isSet():\n      size_returned = ctypes.c_ulong(0)\n      result = ctypes.windll.kernel32.ReadDirectoryChangesW(\n          self._directory_handle,\n          buff,\n          ctypes.c_ulong(_BUFF_SIZE),\n          True,  # recursive.\n          ctypes.c_ulong(_FILE_NOTIFY_CHANGE_ANY),\n          ctypes.byref(size_returned),\n          None,\n          None)  # this is a blocking call.\n      if result == 0 and ctypes.GetLastError() == _ERROR_NOTIFY_ENUM_DIR:\n        logging.warning('Buffer overflow while monitoring for file changes.')\n        # we need to notify that something changed anyway\n        with self._lock:\n          self._change_set |= {'Unknown file'}\n      if result != 0 and size_returned.value != 0:\n        additional_changes = _parse_buffer(buff)\n        with self._lock:\n          self._change_set |= additional_changes\n          self._change_event.set()\n\n```\n\n", "tags": ["GoogleAppEngine"]}