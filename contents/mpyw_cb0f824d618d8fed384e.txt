{"context": " More than 1 year has passed since last update.\u4f55\u3068\u306a\u304f\u6c17\u304c\u5411\u3044\u305f\u306e\u3067\u6628\u65e5\u306f\u3058\u3081\u305f\u3070\u304b\u308a\u306eGo\u8a00\u8a9e\u3067\u7df4\u7fd2\u304c\u3066\u3089\u66f8\u3044\u3066\u307f\u307e\u3057\u305f\u3002JSON\u306e\u30ec\u30b9\u30dd\u30f3\u30b9\u306f\u30a8\u30e9\u30fc\u30c1\u30a7\u30c3\u30af\u7528\u306b\u3057\u304b\u884c\u3063\u3066\u304a\u3089\u305a\u3001\u6b63\u5e38\u6642\u306f\u305d\u306e\u307e\u307e\u6587\u5b57\u5217\u3068\u3057\u3066\u8fd4\u3057\u307e\u3059\u3002\u3057\u304b\u3082\u5947\u5f62\u30ec\u30b9\u30dd\u30f3\u30b9\u306e\u30c1\u30a7\u30c3\u30af\u306f\u7701\u3044\u3066\u3044\u308b\u306e\u3067\u304b\u306a\u308a\u624b\u629c\u304d\u3067\u3059\u3002\u3067\u3082\u6a19\u6e96\u30d1\u30c3\u30b1\u30fc\u30b8\u3057\u304b\u4f7f\u3063\u3066\u306a\u3044\u304b\u3089\u3044\u3044\u3093\u3060\u3001\u3046\u3093\uff01\n\ngoisgod/goisgod.go\n/**\n * GO is GOD\n */\npackage goisgod\n\nimport (\n    \"fmt\"\n    \"time\"\n    \"sort\"\n    \"strings\"\n    \"crypto/hmac\"\n    \"crypto/rand\"\n    \"crypto/sha1\"\n    \"encoding/base64\"\n    \"encoding/json\"\n    \"net/http\"\n    \"net/url\"\n    \"io/ioutil\"\n)\n\n/**\n * \u30af\u30ec\u30c7\u30f3\u30b7\u30e3\u30eb\u3092\u4fdd\u6301\u3059\u308b\u69cb\u9020\u4f53\n */\ntype OAuth struct {\n    ConsumerKey string\n    ConsumerSecret string\n    OAuthToken string\n    OAuthTokenSecret string\n}\n\n/**\n * \u30ec\u30b9\u30dd\u30f3\u30b9\u306e\u30e1\u30bf\u60c5\u5831\n */\ntype ResponseStatus struct {\n    IsError bool\n    StatusCode int\n    ErrorCode int\n    ErrorMessage string\n}\n\n/**\n * PHP\u306earray_merge\u7684\u306a\u95a2\u6570\u304c\u6b32\u3057\u304b\u3063\u305f\n */\nfunc mergeMap(maps ...map[string]string) map[string]string {\n    hint := 0\n    for _, m := range maps {\n        hint += len(m)\n    }\n    newmap := make(map[string]string, hint)\n    for _, m := range maps {\n        for k, v := range m {\n            newmap[k] = v\n        }\n    }\n    return newmap\n}\n\n/**\n * PHP\u306earray_map\u7684\u306a\u95a2\u6570\u304c\u6b32\u3057\u304b\u3063\u305f\n */\nfunc forStrings(fn func(string) string, strs []string) []string {\n    newstrs := make([]string, len(strs))\n    for i, s := range strs {\n        newstrs[i] = fn(s)\n    }\n    return newstrs\n}\n\n/**\n * PHP\u306erawurlencode\u95a2\u6570\u76f8\u5f53\u306e\u51e6\u7406\n * \u3053\u308c\u306b1\u6642\u9593\u4ee5\u4e0a\u60a9\u307e\u3055\u308c\u305f\n */\nfunc encodeRFC3986(s string) string {\n    return strings.Replace(url.QueryEscape(s), \"+\", \"%20\", -1)\n}\n\n/**\n * map\u3092\u30ad\u30fc\u57fa\u6e96\u3067\u30bd\u30fc\u30c8\u3057\u3066\u30af\u30a8\u30ea\u6587\u5b57\u5217\u306b\u3059\u308b\u95a2\u6570\n * Go\u8a00\u8a9e\u306emap\u306b\u306f\u9806\u5e8f\u4fdd\u8a3c\u304c\u7121\u3044\u3088\u3046\u3067\u3042\u3063\u305f\n */\nfunc encodeMap(\n    m map[string]string,\n    separator string,\n    enclosure string,\n) string {\n    keys := make([]string, len(m))\n    i := 0\n    for k := range m {\n        keys[i] = k\n        i++\n    }\n    sort.Strings(keys)\n    sets := make([]string, len(m))\n    for i, k := range keys {\n        ek := encodeRFC3986(k)\n        ev := encodeRFC3986(m[k])\n        sets[i] = fmt.Sprintf(\"%s=%s%s%s\", ek, enclosure, ev, enclosure)\n    }\n    return strings.Join(sets, separator)\n}\n\n/**\n * \u30e9\u30f3\u30c0\u30e0\u6587\u5b57\u5217\u751f\u6210\n */\nfunc generateNonce(n int) string {\n    const chars = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\"\n    bytes := make([]byte, n)\n    rand.Read(bytes)\n    for i, b := range bytes {\n        bytes[i] = chars[b % byte(len(chars))]\n    }\n    return string(bytes)\n}\n\n/**\n * oauth_signature\u306e\u751f\u6210\n */\nfunc generateSignature(data string, key string) string {\n    hash := hmac.New(sha1.New, []byte(key))\n    hash.Write([]byte(data))\n    return base64.StdEncoding.EncodeToString(hash.Sum(nil))\n}\n\n/**\n * Authorization\u30d8\u30c3\u30c0\u306e\u751f\u6210\n * \u3053\u3053\u3092\u6c17\u6301\u3061\u3088\u304f\u30d5\u30a1\u30f3\u30af\u30b7\u30e7\u30ca\u30eb\u306b\u66f8\u304f\u305f\u3081\u306b\u5168\u529b\u3092\u5c3d\u304f\u3057\u305f\n */\nfunc (t *OAuth) generateAuthorizationHeader(\n    method string,\n    request_url string,\n    additional_params map[string]string,\n) string {\n    oauth_params := map[string]string {\n        \"oauth_consumer_key\": t.ConsumerKey,\n        \"oauth_signature_method\": \"HMAC-SHA1\",\n        \"oauth_timestamp\": fmt.Sprint(uint32(time.Now().Unix())),\n        \"oauth_version\": \"1.0a\",\n        \"oauth_nonce\": generateNonce(32),\n        \"oauth_token\": t.OAuthToken,\n    }\n    base := mergeMap(additional_params, oauth_params)\n    oauth_params[\"oauth_signature\"] = generateSignature(\n        strings.Join(forStrings(encodeRFC3986, []string {\n            method,\n            request_url,\n            encodeMap(base, \"&\", \"\"),\n        }), \"&\"),\n        strings.Join(forStrings(encodeRFC3986, []string {\n            t.ConsumerSecret,\n            t.OAuthTokenSecret,\n        }), \"&\"),\n    )\n    return encodeMap(oauth_params, \", \", \"\\\"\")\n}\n\n/**\n * \u30ea\u30af\u30a8\u30b9\u30c8\u3092\u51e6\u7406\u3059\u308b\u95a2\u6570\n * \u6210\u529f\u6642\u306b\u306fJSON\u6587\u5b57\u5217\u305d\u306e\u307e\u307e\u3001\u5931\u6557\u6642\u306b\u306f\u7a7a\u6587\u5b57\u5217\u3092\u8fd4\u3059\n * \u30ec\u30b9\u30dd\u30f3\u30b9\u30b9\u30c6\u30fc\u30bf\u30b9\u306f\u5e38\u306b\u8fd4\u3059\n */\nfunc processRequest(req *http.Request)(string, *ResponseStatus) {\n    resp, err := http.DefaultClient.Do(req)\n    if err != nil {\n        return \"\", &ResponseStatus {\n            true,\n            0,\n            0,\n            fmt.Sprint(err),\n        }\n    }\n    defer resp.Body.Close()\n    content, err := ioutil.ReadAll(resp.Body)\n    if err != nil {\n        return \"\", &ResponseStatus {\n            true,\n            resp.StatusCode,\n            0,\n            fmt.Sprint(err),\n        }\n    }\n    if resp.StatusCode >= 400 {\n        type ErrorObject struct {\n            Code int\n            Message string\n        }\n        type ErrorListObject struct {\n            Errors [1]ErrorObject\n        }\n        var elo ErrorListObject\n        json.Unmarshal(content, &elo)\n        fmt.Println(string(content), elo)\n        if elo.Errors[0].Code == 0 || elo.Errors[0].Message == \"\" {\n            return \"\", &ResponseStatus {\n                true,\n                resp.StatusCode,\n                0,\n                \"Unknown Error\",\n            }\n        }\n        return \"\", &ResponseStatus {\n            true,\n            resp.StatusCode,\n            elo.Errors[0].Code,\n            elo.Errors[0].Message,\n        }\n    }\n    return string(content), &ResponseStatus {\n        false,\n        resp.StatusCode,\n        0,\n        \"\",\n    }\n}\n\n/**\n * GET\u30ea\u30af\u30a8\u30b9\u30c8\u7528\n */\nfunc (t *OAuth) Get(request_url string, params map[string]string)(string, *ResponseStatus) {\n    ah := t.generateAuthorizationHeader(\"GET\", request_url, params)\n    req, _ := http.NewRequest(\"GET\", request_url + \"?\" + encodeMap(params, \"&\", \"\"), nil)\n    req.Header.Add(\"Authorization\", \"OAuth \" + ah)\n    return processRequest(req)\n}\n\n/**\n * POST\u30ea\u30af\u30a8\u30b9\u30c8\u7528\n */\nfunc (t *OAuth) Post(request_url string, params map[string]string)(string, *ResponseStatus) {\n    ah := t.generateAuthorizationHeader(\"POST\", request_url, params)\n    reader := strings.NewReader(encodeMap(params, \"&\", \"\"))\n    req, _ := http.NewRequest(\"POST\", request_url, reader)\n    req.Header.Add(\"Content-Type\", \"application/x-www-form-urlencoded\")\n    req.Header.Add(\"Authorization\", \"OAuth \" + ah)\n    return processRequest(req)\n}\n\n\n\nexample.go\npackage main\n\nimport (\n    \"fmt\"\n    \"log\"\n    \"./goisgod\"\n)\n\nfunc main() {\n    gg := &goisgod.OAuth {\n        \"XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\",\n        \"XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\",\n        \"XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\",\n        \"XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\",\n    }\n    url := \"https://api.twitter.com/1.1/statuses/update.json\"\n    params := map[string]string {\n        \"status\": \"GO is GOD\",\n    }\n    result, status := gg.Post(url, params)\n    if status.IsError {\n        log.Fatal(fmt.Sprint(status))\n    }\n    fmt.Println(result)\n}\n\n\n\nexample_async.go\npackage main\n\nimport (\n    \"fmt\"\n    \"log\"\n    \"sync\"\n    \"strings\"\n    \"./goisgod\"\n)\n\nfunc main() {\n    gg := &goisgod.OAuth {\n        \"XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\",\n        \"XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\",\n        \"XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\",\n        \"XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\",\n    }\n    url := \"https://api.twitter.com/1.1/statuses/update.json\"\n    wg := &sync.WaitGroup {}\n    for i := 1; i <= 5; i++ {\n        wg.Add(1)\n        go func (i int) {\n            defer wg.Done()\n            params := map[string]string {\"status\": \"@null GO is GOD \" + strings.Repeat(\"!\", i)}\n            result, status := gg.Post(url, params)\n            if status.IsError {\n                log.Fatal(fmt.Sprint(status))\n            }\n            fmt.Println(result)\n        }(i)\n    }\n    wg.Wait()\n}\n\n\n\u4f55\u3068\u306a\u304f\u6c17\u304c\u5411\u3044\u305f\u306e\u3067\u6628\u65e5\u306f\u3058\u3081\u305f\u3070\u304b\u308a\u306eGo\u8a00\u8a9e\u3067\u7df4\u7fd2\u304c\u3066\u3089\u66f8\u3044\u3066\u307f\u307e\u3057\u305f\u3002JSON\u306e\u30ec\u30b9\u30dd\u30f3\u30b9\u306f\u30a8\u30e9\u30fc\u30c1\u30a7\u30c3\u30af\u7528\u306b\u3057\u304b\u884c\u3063\u3066\u304a\u3089\u305a\u3001\u6b63\u5e38\u6642\u306f\u305d\u306e\u307e\u307e\u6587\u5b57\u5217\u3068\u3057\u3066\u8fd4\u3057\u307e\u3059\u3002\u3057\u304b\u3082\u5947\u5f62\u30ec\u30b9\u30dd\u30f3\u30b9\u306e\u30c1\u30a7\u30c3\u30af\u306f\u7701\u3044\u3066\u3044\u308b\u306e\u3067\u304b\u306a\u308a\u624b\u629c\u304d\u3067\u3059\u3002\u3067\u3082\u6a19\u6e96\u30d1\u30c3\u30b1\u30fc\u30b8\u3057\u304b\u4f7f\u3063\u3066\u306a\u3044\u304b\u3089\u3044\u3044\u3093\u3060\u3001\u3046\u3093\uff01\n\n```go:goisgod/goisgod.go\n/**\n * GO is GOD\n */\npackage goisgod\n\nimport (\n    \"fmt\"\n    \"time\"\n    \"sort\"\n    \"strings\"\n    \"crypto/hmac\"\n    \"crypto/rand\"\n    \"crypto/sha1\"\n    \"encoding/base64\"\n    \"encoding/json\"\n    \"net/http\"\n    \"net/url\"\n    \"io/ioutil\"\n)\n\n/**\n * \u30af\u30ec\u30c7\u30f3\u30b7\u30e3\u30eb\u3092\u4fdd\u6301\u3059\u308b\u69cb\u9020\u4f53\n */\ntype OAuth struct {\n    ConsumerKey string\n    ConsumerSecret string\n    OAuthToken string\n    OAuthTokenSecret string\n}\n\n/**\n * \u30ec\u30b9\u30dd\u30f3\u30b9\u306e\u30e1\u30bf\u60c5\u5831\n */\ntype ResponseStatus struct {\n    IsError bool\n    StatusCode int\n    ErrorCode int\n    ErrorMessage string\n}\n\n/**\n * PHP\u306earray_merge\u7684\u306a\u95a2\u6570\u304c\u6b32\u3057\u304b\u3063\u305f\n */\nfunc mergeMap(maps ...map[string]string) map[string]string {\n    hint := 0\n    for _, m := range maps {\n        hint += len(m)\n    }\n    newmap := make(map[string]string, hint)\n    for _, m := range maps {\n        for k, v := range m {\n            newmap[k] = v\n        }\n    }\n    return newmap\n}\n\n/**\n * PHP\u306earray_map\u7684\u306a\u95a2\u6570\u304c\u6b32\u3057\u304b\u3063\u305f\n */\nfunc forStrings(fn func(string) string, strs []string) []string {\n    newstrs := make([]string, len(strs))\n    for i, s := range strs {\n        newstrs[i] = fn(s)\n    }\n    return newstrs\n}\n\n/**\n * PHP\u306erawurlencode\u95a2\u6570\u76f8\u5f53\u306e\u51e6\u7406\n * \u3053\u308c\u306b1\u6642\u9593\u4ee5\u4e0a\u60a9\u307e\u3055\u308c\u305f\n */\nfunc encodeRFC3986(s string) string {\n    return strings.Replace(url.QueryEscape(s), \"+\", \"%20\", -1)\n}\n\n/**\n * map\u3092\u30ad\u30fc\u57fa\u6e96\u3067\u30bd\u30fc\u30c8\u3057\u3066\u30af\u30a8\u30ea\u6587\u5b57\u5217\u306b\u3059\u308b\u95a2\u6570\n * Go\u8a00\u8a9e\u306emap\u306b\u306f\u9806\u5e8f\u4fdd\u8a3c\u304c\u7121\u3044\u3088\u3046\u3067\u3042\u3063\u305f\n */\nfunc encodeMap(\n    m map[string]string,\n    separator string,\n    enclosure string,\n) string {\n    keys := make([]string, len(m))\n    i := 0\n    for k := range m {\n        keys[i] = k\n        i++\n    }\n    sort.Strings(keys)\n    sets := make([]string, len(m))\n    for i, k := range keys {\n        ek := encodeRFC3986(k)\n        ev := encodeRFC3986(m[k])\n        sets[i] = fmt.Sprintf(\"%s=%s%s%s\", ek, enclosure, ev, enclosure)\n    }\n    return strings.Join(sets, separator)\n}\n\n/**\n * \u30e9\u30f3\u30c0\u30e0\u6587\u5b57\u5217\u751f\u6210\n */\nfunc generateNonce(n int) string {\n    const chars = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\"\n    bytes := make([]byte, n)\n    rand.Read(bytes)\n    for i, b := range bytes {\n        bytes[i] = chars[b % byte(len(chars))]\n    }\n    return string(bytes)\n}\n\n/**\n * oauth_signature\u306e\u751f\u6210\n */\nfunc generateSignature(data string, key string) string {\n    hash := hmac.New(sha1.New, []byte(key))\n    hash.Write([]byte(data))\n    return base64.StdEncoding.EncodeToString(hash.Sum(nil))\n}\n\n/**\n * Authorization\u30d8\u30c3\u30c0\u306e\u751f\u6210\n * \u3053\u3053\u3092\u6c17\u6301\u3061\u3088\u304f\u30d5\u30a1\u30f3\u30af\u30b7\u30e7\u30ca\u30eb\u306b\u66f8\u304f\u305f\u3081\u306b\u5168\u529b\u3092\u5c3d\u304f\u3057\u305f\n */\nfunc (t *OAuth) generateAuthorizationHeader(\n    method string,\n    request_url string,\n    additional_params map[string]string,\n) string {\n    oauth_params := map[string]string {\n        \"oauth_consumer_key\": t.ConsumerKey,\n        \"oauth_signature_method\": \"HMAC-SHA1\",\n        \"oauth_timestamp\": fmt.Sprint(uint32(time.Now().Unix())),\n        \"oauth_version\": \"1.0a\",\n        \"oauth_nonce\": generateNonce(32),\n        \"oauth_token\": t.OAuthToken,\n    }\n    base := mergeMap(additional_params, oauth_params)\n    oauth_params[\"oauth_signature\"] = generateSignature(\n        strings.Join(forStrings(encodeRFC3986, []string {\n            method,\n            request_url,\n            encodeMap(base, \"&\", \"\"),\n        }), \"&\"),\n        strings.Join(forStrings(encodeRFC3986, []string {\n            t.ConsumerSecret,\n            t.OAuthTokenSecret,\n        }), \"&\"),\n    )\n    return encodeMap(oauth_params, \", \", \"\\\"\")\n}\n\n/**\n * \u30ea\u30af\u30a8\u30b9\u30c8\u3092\u51e6\u7406\u3059\u308b\u95a2\u6570\n * \u6210\u529f\u6642\u306b\u306fJSON\u6587\u5b57\u5217\u305d\u306e\u307e\u307e\u3001\u5931\u6557\u6642\u306b\u306f\u7a7a\u6587\u5b57\u5217\u3092\u8fd4\u3059\n * \u30ec\u30b9\u30dd\u30f3\u30b9\u30b9\u30c6\u30fc\u30bf\u30b9\u306f\u5e38\u306b\u8fd4\u3059\n */\nfunc processRequest(req *http.Request)(string, *ResponseStatus) {\n    resp, err := http.DefaultClient.Do(req)\n    if err != nil {\n        return \"\", &ResponseStatus {\n            true,\n            0,\n            0,\n            fmt.Sprint(err),\n        }\n    }\n    defer resp.Body.Close()\n    content, err := ioutil.ReadAll(resp.Body)\n    if err != nil {\n        return \"\", &ResponseStatus {\n            true,\n            resp.StatusCode,\n            0,\n            fmt.Sprint(err),\n        }\n    }\n    if resp.StatusCode >= 400 {\n        type ErrorObject struct {\n            Code int\n            Message string\n        }\n        type ErrorListObject struct {\n            Errors [1]ErrorObject\n        }\n        var elo ErrorListObject\n        json.Unmarshal(content, &elo)\n        fmt.Println(string(content), elo)\n        if elo.Errors[0].Code == 0 || elo.Errors[0].Message == \"\" {\n            return \"\", &ResponseStatus {\n                true,\n                resp.StatusCode,\n                0,\n                \"Unknown Error\",\n            }\n        }\n        return \"\", &ResponseStatus {\n            true,\n            resp.StatusCode,\n            elo.Errors[0].Code,\n            elo.Errors[0].Message,\n        }\n    }\n    return string(content), &ResponseStatus {\n        false,\n        resp.StatusCode,\n        0,\n        \"\",\n    }\n}\n\n/**\n * GET\u30ea\u30af\u30a8\u30b9\u30c8\u7528\n */\nfunc (t *OAuth) Get(request_url string, params map[string]string)(string, *ResponseStatus) {\n    ah := t.generateAuthorizationHeader(\"GET\", request_url, params)\n    req, _ := http.NewRequest(\"GET\", request_url + \"?\" + encodeMap(params, \"&\", \"\"), nil)\n    req.Header.Add(\"Authorization\", \"OAuth \" + ah)\n    return processRequest(req)\n}\n\n/**\n * POST\u30ea\u30af\u30a8\u30b9\u30c8\u7528\n */\nfunc (t *OAuth) Post(request_url string, params map[string]string)(string, *ResponseStatus) {\n    ah := t.generateAuthorizationHeader(\"POST\", request_url, params)\n    reader := strings.NewReader(encodeMap(params, \"&\", \"\"))\n    req, _ := http.NewRequest(\"POST\", request_url, reader)\n    req.Header.Add(\"Content-Type\", \"application/x-www-form-urlencoded\")\n    req.Header.Add(\"Authorization\", \"OAuth \" + ah)\n    return processRequest(req)\n}\n```\n\n```go:example.go\npackage main\n\nimport (\n    \"fmt\"\n    \"log\"\n    \"./goisgod\"\n)\n\nfunc main() {\n    gg := &goisgod.OAuth {\n        \"XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\",\n        \"XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\",\n        \"XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\",\n        \"XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\",\n    }\n    url := \"https://api.twitter.com/1.1/statuses/update.json\"\n    params := map[string]string {\n        \"status\": \"GO is GOD\",\n    }\n    result, status := gg.Post(url, params)\n    if status.IsError {\n        log.Fatal(fmt.Sprint(status))\n    }\n    fmt.Println(result)\n}\n```\n\n```go:example_async.go\npackage main\n\nimport (\n    \"fmt\"\n    \"log\"\n    \"sync\"\n    \"strings\"\n    \"./goisgod\"\n)\n\nfunc main() {\n    gg := &goisgod.OAuth {\n        \"XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\",\n        \"XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\",\n        \"XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\",\n        \"XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\",\n    }\n    url := \"https://api.twitter.com/1.1/statuses/update.json\"\n    wg := &sync.WaitGroup {}\n    for i := 1; i <= 5; i++ {\n        wg.Add(1)\n        go func (i int) {\n            defer wg.Done()\n            params := map[string]string {\"status\": \"@null GO is GOD \" + strings.Repeat(\"!\", i)}\n            result, status := gg.Post(url, params)\n            if status.IsError {\n                log.Fatal(fmt.Sprint(status))\n            }\n            fmt.Println(result)\n        }(i)\n    }\n    wg.Wait()\n}\n```\n", "tags": ["Go", "golang", "Twitter", "OAuth", "\u771f\u590f\u306e\u591c\u306e\u6deb\u5922"]}