{"context": " More than 1 year has passed since last update.\u4e45\u3057\u3076\u308a\u306bmbed\u3092\u3044\u3058\u308d\u3046\u3068\u601d\u3063\u3066\u3001\u3068\u308a\u3042\u3048\u305a\u524d\u306b\u66f8\u3044\u305fEthernetNetIf\u3092\u7528\u3044\u305f\u3082\u306e\u3092mbed\u516c\u5f0f\u306eEthernetInterface\u3092\u4f7f\u7528\u3057\u305f\u3082\u306e\u306b\u66f8\u304d\u63db\u3048\u3066\u307f\u307e\u3057\u305f\u3002\nmbed official/EthernetInterface\nEthernetInterface\u306fmbed-rtos\u306b\u4f9d\u5b58\u3057\u305f\u30e9\u30a4\u30d6\u30e9\u30ea\u3068\u306a\u3063\u3066\u304a\u308a\u3001EthernetInterface\u3060\u3051\u3092\u30a4\u30f3\u30dd\u30fc\u30c8\u3057\u3066\u3082\u30b3\u30f3\u30d1\u30a4\u30eb\u30a8\u30e9\u30fc\u3068\u306a\u308b\u306e\u3067\u3001mbed-rtos\u3082\u30a4\u30f3\u30dd\u30fc\u30c8\u3059\u308b\u5fc5\u8981\u304c\u3042\u308a\u307e\u3059\u3002\n\u975e\u540c\u671f\u306a\u30b3\u30fc\u30c9\u306e\u66f8\u304d\u65b9\u304c\u308f\u304b\u3089\u306a\u3044\u305f\u3081\u3001\uff11\u30af\u30e9\u30a4\u30a2\u30f3\u30c8\u306e\u307f\u306b\u3057\u304b\u5bfe\u5fdc\u3057\u3066\u3044\u307e\u305b\u3093\u3002\u975e\u540c\u671f\u306a\u30b3\u30fc\u30c9\u304c\u66f8\u3051\u308c\u3070\u30de\u30eb\u30c1\u30af\u30e9\u30a4\u30a2\u30f3\u30c8\u306b\u5bfe\u5fdc\u3057\u305f\u3082\u306e\u304c\u3067\u304d\u308b\u304b\u3068\u601d\u3044\u307e\u3059\u3002\n\u30aa\u30f3\u30e9\u30a4\u30f3\u30b3\u30f3\u30d1\u30a4\u30e9\u3092\u5143\u306b\u8aac\u660e\u3059\u308b\u3068\u3001\u65b0\u3057\u304f\u30d7\u30ed\u30b0\u30e9\u30e0\u3092\u4f5c\u6210\u3057\u305f\u3089EthernetInterface\u3068mbed-rtos\u30e9\u30a4\u30d6\u30e9\u30ea\u3092\u30a4\u30f3\u30dd\u30fc\u30c8\u3057\u3001main.cpp\u3092\u4e0b\u8a18\u306e\u3088\u3046\u306b\u66f8\u304d\u63db\u3048\u3001sha1.h\u3001sha1.c\u3001sha1config.h\u306e3\u30d5\u30a1\u30a4\u30eb\u3092\u8ffd\u52a0\u3057\u3066\u30b3\u30f3\u30d1\u30a4\u30eb\u3057\u305f\u3089\u3001mbed\u306b\u5165\u308c\u3066\u5b9f\u884c\u5f8c\u3001L\u30c1\u30ab\u30af\u30e9\u30a4\u30a2\u30f3\u30c8/jsdo.it\u306b\u30a2\u30af\u30bb\u30b9\u3057\u3066\u8a66\u3057\u3066\u307f\u3066\u304f\u3060\u3055\u3044\u3002\n(sha1config.h\u306e\u30b3\u30fc\u30c9\u3092\u4e00\u756a\u4e0a\u306b\u66f8\u3044\u3066\u3042\u308b\u306e\u306f\u3001\u4e00\u756a\u4e0b\u306b\u66f8\u3044\u3066\u305f\u3089\u8868\u793a\u3055\u308c\u306a\u304b\u3063\u305f\u305f\u3081\u3067\u3059\u3002)\n\nsha1config.h\n#ifndef SHA1CONFIG_H\n#define SHA1CONFIG_H\n\n#define POLARSSL_SHA1_C 1\n\n#endif\n\n\n\nmain.cpp\n#include <string>\n#include <sstream>\n#include \"mbed.h\"\n#include \"EthernetInterface.h\"\n#include \"sha1config.h\"\n#include \"sha1.h\"\nconst int WS_HANDSHAKE = 1;\nconst int WS_CONNECT = 2;\nint wsState = 0;\nDigitalOut led1(LED1);\nDigitalOut led2(LED2);\nDigitalOut led3(LED3);\nDigitalOut led4(LED4);\n\nstring encode64(char *Buf,int Length) {\n    char *Codes64 = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n    int Byte3=0;\n    string Result=\"\";\n    for (int i=0; i<Length; i++) {\n        Byte3=(Byte3<<8)+(int)Buf[i];\n        if ((i+1)%3==0) {\n            Result=Result+Codes64[(Byte3>>18)&0x3F];\n            Result=Result+Codes64[(Byte3>>12)&0x3F];\n            Result=Result+Codes64[(Byte3>>6)&0x3F];\n            Result=Result+Codes64[(Byte3)&0x3F];\n            Byte3=0;\n        }\n    }\n\n    int Rest=Length%3;\n    switch (Rest) {\n        case 1:\n            Byte3=Byte3<<4;\n            Result=Result+Codes64[(Byte3>>6)&0x3F];\n            Result=Result+Codes64[(Byte3)&0x3F];\n            Result=Result+\"==\";\n            break;\n        case 2:\n            Byte3=Byte3<<2;\n            Result=Result+Codes64[(Byte3>>12)&0x3F];\n            Result=Result+Codes64[(Byte3>>6 )&0x3F];\n            Result=Result+Codes64[(Byte3)&0x3F];\n            Result=Result+\"=\";\n            break;\n    }\n    return Result;\n}\n\nint main() {\n    EthernetInterface eth;\n    eth.init(\"192.168.0.2\", \"255.255.255.0\", \"192.168.0.2\");\n    eth.connect(); \n    TCPSocketServer server;\n    server.bind(8080);\n    server.listen();\n    printf(\"\\nWait for new connection...\\n\");\n    TCPSocketConnection sock;\n    server.accept(sock);\n    wsState = WS_HANDSHAKE;\n    char buff[600];\n    int len;\n    while (true) {\n        len = sock.receive(buff, sizeof(buff)-1);\n        if (len <= 0){\n            printf(\"close by 0 length\\n\");\n            wsState = WS_HANDSHAKE;\n            continue;\n        }\n        buff[len] = '\\0';\n        switch(wsState){\n            case WS_HANDSHAKE:\n                printf(\"Received %d chars from server:\\n%s\\n\", len, buff);\n                for (int i = 0; i < len; i++) {\n                    if (buff[i] == 'K' && buff[i + 1] == 'e' && buff[i + 2] == 'y') {\n                        for (int j = i + 1; j < len; j++) {\n                            if (buff[j] == '\\r') {\n                                i += 5;\n                                int keyLen = j - i;\n                                char strKey[keyLen + 1];\n                                strKey[keyLen] = 0;\n                                strncpy(strKey, buff + i, keyLen);\n                                char guid[] = \"258EAFA5-E914-47DA-95CA-C5AB0DC85B11\";\n                                strcat(strKey, guid);\n                                unsigned char hash[20];\n                                sha1((unsigned char*)strKey,strlen((char*)strKey),hash);\n                                string accept = encode64((char*)hash, 20);\n                                string hsRes = \"HTTP/1.1 101 Switching Protocols\\r\\nUpgrade: websocket\\r\\nConnection: Upgrade\\r\\nSec-WebSocket-Accept: \";\n                                hsRes += accept;\n                                hsRes += \"\\r\\n\\r\\n\";\n                                printf(\"%s\", hsRes.c_str());\n                                sock.send_all((char *)hsRes.c_str(), hsRes.size());\n                                printf(\"change to WS_CONNECT state\\n\");\n                                wsState = WS_CONNECT;\n                                break;\n                            }\n                        }\n                    }\n                }\n                break;\n            case WS_CONNECT:\n                bool fin = (buff[0] & 0x80) == 0x80;\n                int opcode = buff[0] & 0x0f;\n                if (opcode == 0x8) {\n                    printf(\"close by close opcode\\n\");\n                    wsState = WS_HANDSHAKE;\n                    sock.close();\n                    break;\n                }\n                if (opcode == 0x9) {\n                    buff[0] += 1;\n                    sock.send_all(buff, len);\n                    break;\n                }\n                int dataLen = buff[1] & 0x7f;\n                if (!fin || dataLen > 125) {\n                    sock.close();\n                    printf(\"close by illegal data length \\n\");\n                    wsState = WS_HANDSHAKE;\n                    break;\n                }\n                int i = 0;\n                for (i = 0; i < dataLen; i++) {\n                    buff[6 + i] = buff[6 + i] ^ buff[2 + (i % 4)];\n                }\n                printf(\"data length:%d\\n\", dataLen);\n                buff[6 + dataLen] = 0;\n                if (opcode == 1) {\n                    printf(\"received data:%s\\n\", buff + 6);\n                    char sendData[2 + dataLen + 1];\n                    sendData[0] = buff[0];\n                    sendData[1] = buff[1] & 0x7f;\n                    for (i = 0; i < dataLen; i++) {\n                        sendData[2 + i] = buff[6 + i];\n                    }\n                    sendData[2 + dataLen] = 0;\n                    sock.send_all(sendData, 2 + dataLen);\n                } else if (opcode == 2) {\n                    led1 = buff[6 + 0];\n                    led2 = buff[6 + 1];\n                    led3 = buff[6 + 2];\n                    led4 = buff[6 + 3];\n                }\n                break;\n        }\n    }\n\n    sock.close();\n    eth.disconnect();\n    while(1) {}\n}\n\n\n\nsha1.h\n/**\n * \\file sha1.h\n *\n *  Copyright (C) 2006-2010, Paul Bakker <polarssl_maintainer at polarssl.org>\n *  All rights reserved.\n *\n *  This program is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation; either version 2 of the License, or\n *  (at your option) any later version.\n *\n *  This program is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License along\n *  with this program; if not, write to the Free Software Foundation, Inc.,\n *  51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n */\n#ifndef POLARSSL_SHA1_H\n#define POLARSSL_SHA1_H\n\n/**\n * \\brief          SHA-1 context structure\n */\ntypedef struct\n{\n    unsigned long total[2];     /*!< number of bytes processed  */\n    unsigned long state[5];     /*!< intermediate digest state  */\n    unsigned char buffer[64];   /*!< data block being processed */\n\n    unsigned char ipad[64];     /*!< HMAC: inner padding        */\n    unsigned char opad[64];     /*!< HMAC: outer padding        */\n}\nsha1_context;\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n/**\n * \\brief          SHA-1 context setup\n *\n * \\param ctx      context to be initialized\n */\nvoid sha1_starts( sha1_context *ctx );\n\n/**\n * \\brief          SHA-1 process buffer\n *\n * \\param ctx      SHA-1 context\n * \\param input    buffer holding the  data\n * \\param ilen     length of the input data\n */\nvoid sha1_update( sha1_context *ctx, const unsigned char *input, int ilen );\n\n/**\n * \\brief          SHA-1 final digest\n *\n * \\param ctx      SHA-1 context\n * \\param output   SHA-1 checksum result\n */\nvoid sha1_finish( sha1_context *ctx, unsigned char output[20] );\n\n/**\n * \\brief          Output = SHA-1( input buffer )\n *\n * \\param input    buffer holding the  data\n * \\param ilen     length of the input data\n * \\param output   SHA-1 checksum result\n */\nvoid sha1( const unsigned char *input, int ilen, unsigned char output[20] );\n\n#if 0 //No need for that\n/**\n * \\brief          Output = SHA-1( file contents )\n *\n * \\param path     input file name\n * \\param output   SHA-1 checksum result\n *\n * \\return         0 if successful, 1 if fopen failed,\n *                 or 2 if fread failed\n */\nint sha1_file( const char *path, unsigned char output[20] );\n#endif\n\n/**\n * \\brief          SHA-1 HMAC context setup\n *\n * \\param ctx      HMAC context to be initialized\n * \\param key      HMAC secret key\n * \\param keylen   length of the HMAC key\n */\nvoid sha1_hmac_starts( sha1_context *ctx, const unsigned char *key, int keylen );\n\n/**\n * \\brief          SHA-1 HMAC process buffer\n *\n * \\param ctx      HMAC context\n * \\param input    buffer holding the  data\n * \\param ilen     length of the input data\n */\nvoid sha1_hmac_update( sha1_context *ctx, const unsigned char *input, int ilen );\n\n/**\n * \\brief          SHA-1 HMAC final digest\n *\n * \\param ctx      HMAC context\n * \\param output   SHA-1 HMAC checksum result\n */\nvoid sha1_hmac_finish( sha1_context *ctx, unsigned char output[20] );\n\n/**\n * \\brief          SHA-1 HMAC context reset\n *\n * \\param ctx      HMAC context to be reset\n */\nvoid sha1_hmac_reset( sha1_context *ctx );\n\n/**\n * \\brief          Output = HMAC-SHA-1( hmac key, input buffer )\n *\n * \\param key      HMAC secret key\n * \\param keylen   length of the HMAC key\n * \\param input    buffer holding the  data\n * \\param ilen     length of the input data\n * \\param output   HMAC-SHA-1 result\n */\nvoid sha1_hmac( const unsigned char *key, int keylen,\n                const unsigned char *input, int ilen,\n                unsigned char output[20] );\n\n/**\n * \\brief          Checkup routine\n *\n * \\return         0 if successful, or 1 if the test failed\n */\nint sha1_self_test( int verbose );\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif /* sha1.h */\n\n\n\nsha1.c\n/*\n *  FIPS-180-1 compliant SHA-1 implementation\n *\n *  Copyright (C) 2006-2010, Paul Bakker <polarssl_maintainer at polarssl.org>\n *  All rights reserved.\n *\n *  This program is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation; either version 2 of the License, or\n *  (at your option) any later version.\n *\n *  This program is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License along\n *  with this program; if not, write to the Free Software Foundation, Inc.,\n *  51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n */\n/*\n *  The SHA-1 standard was published by NIST in 1993.\n *\n *  http://www.itl.nist.gov/fipspubs/fip180-1.htm\n */\n#include \"sha1config.h\"\n#if defined(POLARSSL_SHA1_C)\n#include \"sha1.h\"\n#include <string.h>\n#include <stdio.h>\n\n/*\n * 32-bit integer manipulation macros (big endian)\n */\n#ifndef GET_ULONG_BE\n#define GET_ULONG_BE(n,b,i)                             \\\n{                                                       \\\n    (n) = ( (unsigned long) (b)[(i)    ] << 24 )        \\\n        | ( (unsigned long) (b)[(i) + 1] << 16 )        \\\n        | ( (unsigned long) (b)[(i) + 2] <<  8 )        \\\n        | ( (unsigned long) (b)[(i) + 3]       );       \\\n}\n#endif\n\n#ifndef PUT_ULONG_BE\n#define PUT_ULONG_BE(n,b,i)                             \\\n{                                                       \\\n    (b)[(i)    ] = (unsigned char) ( (n) >> 24 );       \\\n    (b)[(i) + 1] = (unsigned char) ( (n) >> 16 );       \\\n    (b)[(i) + 2] = (unsigned char) ( (n) >>  8 );       \\\n    (b)[(i) + 3] = (unsigned char) ( (n)       );       \\\n}\n#endif\n\n/*\n * SHA-1 context setup\n */\nvoid sha1_starts( sha1_context *ctx )\n{\n    ctx->total[0] = 0;\n    ctx->total[1] = 0;\n    ctx->state[0] = 0x67452301;\n    ctx->state[1] = 0xEFCDAB89;\n    ctx->state[2] = 0x98BADCFE;\n    ctx->state[3] = 0x10325476;\n    ctx->state[4] = 0xC3D2E1F0;\n}\n\nstatic void sha1_process( sha1_context *ctx, const unsigned char data[64] )\n{\n    unsigned long temp, W[16], A, B, C, D, E;\n    GET_ULONG_BE( W[ 0], data,  0 );\n    GET_ULONG_BE( W[ 1], data,  4 );\n    GET_ULONG_BE( W[ 2], data,  8 );\n    GET_ULONG_BE( W[ 3], data, 12 );\n    GET_ULONG_BE( W[ 4], data, 16 );\n    GET_ULONG_BE( W[ 5], data, 20 );\n    GET_ULONG_BE( W[ 6], data, 24 );\n    GET_ULONG_BE( W[ 7], data, 28 );\n    GET_ULONG_BE( W[ 8], data, 32 );\n    GET_ULONG_BE( W[ 9], data, 36 );\n    GET_ULONG_BE( W[10], data, 40 );\n    GET_ULONG_BE( W[11], data, 44 );\n    GET_ULONG_BE( W[12], data, 48 );\n    GET_ULONG_BE( W[13], data, 52 );\n    GET_ULONG_BE( W[14], data, 56 );\n    GET_ULONG_BE( W[15], data, 60 );\n#define S(x,n) ((x << n) | ((x & 0xFFFFFFFF) >> (32 - n)))\n#define R(t)                                            \\\n(                                                       \\\n    temp = W[(t -  3) & 0x0F] ^ W[(t - 8) & 0x0F] ^     \\\n           W[(t - 14) & 0x0F] ^ W[ t      & 0x0F],      \\\n    ( W[t & 0x0F] = S(temp,1) )                         \\\n)\n#define P(a,b,c,d,e,x)                                  \\\n{                                                       \\\n    e += S(a,5) + F(b,c,d) + K + x; b = S(b,30);        \\\n}\n    A = ctx->state[0];\n    B = ctx->state[1];\n    C = ctx->state[2];\n    D = ctx->state[3];\n    E = ctx->state[4];\n#define F(x,y,z) (z ^ (x & (y ^ z)))\n#define K 0x5A827999\n    P( A, B, C, D, E, W[0]  );\n    P( E, A, B, C, D, W[1]  );\n    P( D, E, A, B, C, W[2]  );\n    P( C, D, E, A, B, W[3]  );\n    P( B, C, D, E, A, W[4]  );\n    P( A, B, C, D, E, W[5]  );\n    P( E, A, B, C, D, W[6]  );\n    P( D, E, A, B, C, W[7]  );\n    P( C, D, E, A, B, W[8]  );\n    P( B, C, D, E, A, W[9]  );\n    P( A, B, C, D, E, W[10] );\n    P( E, A, B, C, D, W[11] );\n    P( D, E, A, B, C, W[12] );\n    P( C, D, E, A, B, W[13] );\n    P( B, C, D, E, A, W[14] );\n    P( A, B, C, D, E, W[15] );\n    P( E, A, B, C, D, R(16) );\n    P( D, E, A, B, C, R(17) );\n    P( C, D, E, A, B, R(18) );\n    P( B, C, D, E, A, R(19) );\n#undef K\n#undef F\n#define F(x,y,z) (x ^ y ^ z)\n#define K 0x6ED9EBA1\n    P( A, B, C, D, E, R(20) );\n    P( E, A, B, C, D, R(21) );\n    P( D, E, A, B, C, R(22) );\n    P( C, D, E, A, B, R(23) );\n    P( B, C, D, E, A, R(24) );\n    P( A, B, C, D, E, R(25) );\n    P( E, A, B, C, D, R(26) );\n    P( D, E, A, B, C, R(27) );\n    P( C, D, E, A, B, R(28) );\n    P( B, C, D, E, A, R(29) );\n    P( A, B, C, D, E, R(30) );\n    P( E, A, B, C, D, R(31) );\n    P( D, E, A, B, C, R(32) );\n    P( C, D, E, A, B, R(33) );\n    P( B, C, D, E, A, R(34) );\n    P( A, B, C, D, E, R(35) );\n    P( E, A, B, C, D, R(36) );\n    P( D, E, A, B, C, R(37) );\n    P( C, D, E, A, B, R(38) );\n    P( B, C, D, E, A, R(39) );\n#undef K\n#undef F\n#define F(x,y,z) ((x & y) | (z & (x | y)))\n#define K 0x8F1BBCDC\n    P( A, B, C, D, E, R(40) );\n    P( E, A, B, C, D, R(41) );\n    P( D, E, A, B, C, R(42) );\n    P( C, D, E, A, B, R(43) );\n    P( B, C, D, E, A, R(44) );\n    P( A, B, C, D, E, R(45) );\n    P( E, A, B, C, D, R(46) );\n    P( D, E, A, B, C, R(47) );\n    P( C, D, E, A, B, R(48) );\n    P( B, C, D, E, A, R(49) );\n    P( A, B, C, D, E, R(50) );\n    P( E, A, B, C, D, R(51) );\n    P( D, E, A, B, C, R(52) );\n    P( C, D, E, A, B, R(53) );\n    P( B, C, D, E, A, R(54) );\n    P( A, B, C, D, E, R(55) );\n    P( E, A, B, C, D, R(56) );\n    P( D, E, A, B, C, R(57) );\n    P( C, D, E, A, B, R(58) );\n    P( B, C, D, E, A, R(59) );\n#undef K\n#undef F\n#define F(x,y,z) (x ^ y ^ z)\n#define K 0xCA62C1D6\n    P( A, B, C, D, E, R(60) );\n    P( E, A, B, C, D, R(61) );\n    P( D, E, A, B, C, R(62) );\n    P( C, D, E, A, B, R(63) );\n    P( B, C, D, E, A, R(64) );\n    P( A, B, C, D, E, R(65) );\n    P( E, A, B, C, D, R(66) );\n    P( D, E, A, B, C, R(67) );\n    P( C, D, E, A, B, R(68) );\n    P( B, C, D, E, A, R(69) );\n    P( A, B, C, D, E, R(70) );\n    P( E, A, B, C, D, R(71) );\n    P( D, E, A, B, C, R(72) );\n    P( C, D, E, A, B, R(73) );\n    P( B, C, D, E, A, R(74) );\n    P( A, B, C, D, E, R(75) );\n    P( E, A, B, C, D, R(76) );\n    P( D, E, A, B, C, R(77) );\n    P( C, D, E, A, B, R(78) );\n    P( B, C, D, E, A, R(79) );\n#undef K\n#undef F\n    ctx->state[0] += A;\n    ctx->state[1] += B;\n    ctx->state[2] += C;\n    ctx->state[3] += D;\n    ctx->state[4] += E;\n}\n\n/*\n * SHA-1 process buffer\n */\nvoid sha1_update( sha1_context *ctx, const unsigned char *input, int ilen )\n{\n    int fill;\n    unsigned long left;\n    if( ilen <= 0 ) return;\n    left = ctx->total[0] & 0x3F;\n    fill = 64 - left;\n    ctx->total[0] += ilen;\n    ctx->total[0] &= 0xFFFFFFFF;\n    if( ctx->total[0] < (unsigned long) ilen )\n        ctx->total[1]++;\n    if( left && ilen >= fill )\n    {\n        memcpy( (void *) (ctx->buffer + left),\n                (void *) input, fill );\n        sha1_process( ctx, ctx->buffer );\n        input += fill;\n        ilen  -= fill;\n        left = 0;\n    }\n    while( ilen >= 64 )\n    {\n        sha1_process( ctx, input );\n        input += 64;\n        ilen  -= 64;\n    }\n    if( ilen > 0 )\n    {\n        memcpy( (void *) (ctx->buffer + left),\n                (void *) input, ilen );\n    }\n}\n\nstatic const unsigned char sha1_padding[64] =\n{\n 0x80, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0\n};\n\n/*\n * SHA-1 final digest\n */\nvoid sha1_finish( sha1_context *ctx, unsigned char output[20] )\n{\n    unsigned long last, padn;\n    unsigned long high, low;\n    unsigned char msglen[8];\n    high = ( ctx->total[0] >> 29 )\n         | ( ctx->total[1] <<  3 );\n    low  = ( ctx->total[0] <<  3 );\n    PUT_ULONG_BE( high, msglen, 0 );\n    PUT_ULONG_BE( low,  msglen, 4 );\n    last = ctx->total[0] & 0x3F;\n    padn = ( last < 56 ) ? ( 56 - last ) : ( 120 - last );\n    sha1_update( ctx, (unsigned char *) sha1_padding, padn );\n    sha1_update( ctx, msglen, 8 );\n    PUT_ULONG_BE( ctx->state[0], output,  0 );\n    PUT_ULONG_BE( ctx->state[1], output,  4 );\n    PUT_ULONG_BE( ctx->state[2], output,  8 );\n    PUT_ULONG_BE( ctx->state[3], output, 12 );\n    PUT_ULONG_BE( ctx->state[4], output, 16 );\n}\n\n/*\n * output = SHA-1( input buffer )\n */\nvoid sha1( const unsigned char *input, int ilen, unsigned char output[20] )\n{\n    sha1_context ctx;\n    sha1_starts( &ctx );\n    sha1_update( &ctx, input, ilen );\n    sha1_finish( &ctx, output );\n    memset( &ctx, 0, sizeof( sha1_context ) );\n}\n\n/*\n * output = SHA-1( file contents )\n */\n#if 0 //No need for that\nint sha1_file( const char *path, unsigned char output[20] )\n{\n    FILE *f;\n    size_t n;\n    sha1_context ctx;\n    unsigned char buf[1024];\n    if( ( f = fopen( path, \"rb\" ) ) == NULL )\n        return( 1 );\n    sha1_starts( &ctx );\n    while( ( n = fread( buf, 1, sizeof( buf ), f ) ) > 0 )\n        sha1_update( &ctx, buf, (int) n );\n    sha1_finish( &ctx, output );\n    memset( &ctx, 0, sizeof( sha1_context ) );\n    if( ferror( f ) != 0 )\n    {\n        fclose( f );\n        return( 2 );\n    }\n    fclose( f );\n    return( 0 );\n}\n#endif\n\n/*\n * SHA-1 HMAC context setup\n */\nvoid sha1_hmac_starts( sha1_context *ctx, const unsigned char *key, int keylen )\n{\n    int i;\n    unsigned char sum[20];\n    if( keylen > 64 )\n    {\n        sha1( key, keylen, sum );\n        keylen = 20;\n        key = sum;\n    }\n    memset( ctx->ipad, 0x36, 64 );\n    memset( ctx->opad, 0x5C, 64 );\n    for( i = 0; i < keylen; i++ )\n    {\n        ctx->ipad[i] = (unsigned char)( ctx->ipad[i] ^ key[i] );\n        ctx->opad[i] = (unsigned char)( ctx->opad[i] ^ key[i] );\n    }\n    sha1_starts( ctx );\n    sha1_update( ctx, ctx->ipad, 64 );\n    memset( sum, 0, sizeof( sum ) );\n}\n\n/*\n * SHA-1 HMAC process buffer\n */\nvoid sha1_hmac_update( sha1_context *ctx, const unsigned char *input, int ilen )\n{\n    sha1_update( ctx, input, ilen );\n}\n\n/*\n * SHA-1 HMAC final digest\n */\nvoid sha1_hmac_finish( sha1_context *ctx, unsigned char output[20] )\n{\n    unsigned char tmpbuf[20];\n    sha1_finish( ctx, tmpbuf );\n    sha1_starts( ctx );\n    sha1_update( ctx, ctx->opad, 64 );\n    sha1_update( ctx, tmpbuf, 20 );\n    sha1_finish( ctx, output );\n    memset( tmpbuf, 0, sizeof( tmpbuf ) );\n}\n\n/*\n * SHA1 HMAC context reset\n */\nvoid sha1_hmac_reset( sha1_context *ctx )\n{\n    sha1_starts( ctx );\n    sha1_update( ctx, ctx->ipad, 64 );\n}\n\n/*\n * output = HMAC-SHA-1( hmac key, input buffer )\n */\nvoid sha1_hmac( const unsigned char *key, int keylen,\n                const unsigned char *input, int ilen,\n                unsigned char output[20] )\n{\n    sha1_context ctx;\n    sha1_hmac_starts( &ctx, key, keylen );\n    sha1_hmac_update( &ctx, input, ilen );\n    sha1_hmac_finish( &ctx, output );\n    memset( &ctx, 0, sizeof( sha1_context ) );\n}\n\n#if defined(POLARSSL_SELF_TEST)\n/*\n * FIPS-180-1 test vectors\n */\nstatic unsigned char sha1_test_buf[3][57] = \n{\n    { \"abc\" },\n    { \"abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq\" },\n    { \"\" }\n};\n\nstatic const int sha1_test_buflen[3] =\n{\n    3, 56, 1000\n};\n\nstatic const unsigned char sha1_test_sum[3][20] =\n{\n    { 0xA9, 0x99, 0x3E, 0x36, 0x47, 0x06, 0x81, 0x6A, 0xBA, 0x3E,\n      0x25, 0x71, 0x78, 0x50, 0xC2, 0x6C, 0x9C, 0xD0, 0xD8, 0x9D },\n    { 0x84, 0x98, 0x3E, 0x44, 0x1C, 0x3B, 0xD2, 0x6E, 0xBA, 0xAE,\n      0x4A, 0xA1, 0xF9, 0x51, 0x29, 0xE5, 0xE5, 0x46, 0x70, 0xF1 },\n    { 0x34, 0xAA, 0x97, 0x3C, 0xD4, 0xC4, 0xDA, 0xA4, 0xF6, 0x1E,\n      0xEB, 0x2B, 0xDB, 0xAD, 0x27, 0x31, 0x65, 0x34, 0x01, 0x6F }\n};\n\n/*\n * RFC 2202 test vectors\n */\nstatic unsigned char sha1_hmac_test_key[7][26] =\n{\n    { \"\\x0B\\x0B\\x0B\\x0B\\x0B\\x0B\\x0B\\x0B\\x0B\\x0B\\x0B\\x0B\\x0B\\x0B\\x0B\\x0B\"\n      \"\\x0B\\x0B\\x0B\\x0B\" },\n    { \"Jefe\" },\n    { \"\\xAA\\xAA\\xAA\\xAA\\xAA\\xAA\\xAA\\xAA\\xAA\\xAA\\xAA\\xAA\\xAA\\xAA\\xAA\\xAA\"\n      \"\\xAA\\xAA\\xAA\\xAA\" },\n    { \"\\x01\\x02\\x03\\x04\\x05\\x06\\x07\\x08\\x09\\x0A\\x0B\\x0C\\x0D\\x0E\\x0F\\x10\"\n      \"\\x11\\x12\\x13\\x14\\x15\\x16\\x17\\x18\\x19\" },\n    { \"\\x0C\\x0C\\x0C\\x0C\\x0C\\x0C\\x0C\\x0C\\x0C\\x0C\\x0C\\x0C\\x0C\\x0C\\x0C\\x0C\"\n      \"\\x0C\\x0C\\x0C\\x0C\" },\n    { \"\" }, /* 0xAA 80 times */\n    { \"\" }\n};\n\nstatic const int sha1_hmac_test_keylen[7] =\n{\n    20, 4, 20, 25, 20, 80, 80\n};\n\nstatic unsigned char sha1_hmac_test_buf[7][74] =\n{\n    { \"Hi There\" },\n    { \"what do ya want for nothing?\" },\n    { \"\\xDD\\xDD\\xDD\\xDD\\xDD\\xDD\\xDD\\xDD\\xDD\\xDD\"\n      \"\\xDD\\xDD\\xDD\\xDD\\xDD\\xDD\\xDD\\xDD\\xDD\\xDD\"\n      \"\\xDD\\xDD\\xDD\\xDD\\xDD\\xDD\\xDD\\xDD\\xDD\\xDD\"\n      \"\\xDD\\xDD\\xDD\\xDD\\xDD\\xDD\\xDD\\xDD\\xDD\\xDD\"\n      \"\\xDD\\xDD\\xDD\\xDD\\xDD\\xDD\\xDD\\xDD\\xDD\\xDD\" },\n    { \"\\xCD\\xCD\\xCD\\xCD\\xCD\\xCD\\xCD\\xCD\\xCD\\xCD\"\n      \"\\xCD\\xCD\\xCD\\xCD\\xCD\\xCD\\xCD\\xCD\\xCD\\xCD\"\n      \"\\xCD\\xCD\\xCD\\xCD\\xCD\\xCD\\xCD\\xCD\\xCD\\xCD\"\n      \"\\xCD\\xCD\\xCD\\xCD\\xCD\\xCD\\xCD\\xCD\\xCD\\xCD\"\n      \"\\xCD\\xCD\\xCD\\xCD\\xCD\\xCD\\xCD\\xCD\\xCD\\xCD\" },\n    { \"Test With Truncation\" },\n    { \"Test Using Larger Than Block-Size Key - Hash Key First\" },\n    { \"Test Using Larger Than Block-Size Key and Larger\"\n      \" Than One Block-Size Data\" }\n};\n\nstatic const int sha1_hmac_test_buflen[7] =\n{\n    8, 28, 50, 50, 20, 54, 73\n};\n\nstatic const unsigned char sha1_hmac_test_sum[7][20] =\n{\n    { 0xB6, 0x17, 0x31, 0x86, 0x55, 0x05, 0x72, 0x64, 0xE2, 0x8B,\n      0xC0, 0xB6, 0xFB, 0x37, 0x8C, 0x8E, 0xF1, 0x46, 0xBE, 0x00 },\n    { 0xEF, 0xFC, 0xDF, 0x6A, 0xE5, 0xEB, 0x2F, 0xA2, 0xD2, 0x74,\n      0x16, 0xD5, 0xF1, 0x84, 0xDF, 0x9C, 0x25, 0x9A, 0x7C, 0x79 },\n    { 0x12, 0x5D, 0x73, 0x42, 0xB9, 0xAC, 0x11, 0xCD, 0x91, 0xA3,\n      0x9A, 0xF4, 0x8A, 0xA1, 0x7B, 0x4F, 0x63, 0xF1, 0x75, 0xD3 },\n    { 0x4C, 0x90, 0x07, 0xF4, 0x02, 0x62, 0x50, 0xC6, 0xBC, 0x84,\n      0x14, 0xF9, 0xBF, 0x50, 0xC8, 0x6C, 0x2D, 0x72, 0x35, 0xDA },\n    { 0x4C, 0x1A, 0x03, 0x42, 0x4B, 0x55, 0xE0, 0x7F, 0xE7, 0xF2,\n      0x7B, 0xE1 },\n    { 0xAA, 0x4A, 0xE5, 0xE1, 0x52, 0x72, 0xD0, 0x0E, 0x95, 0x70,\n      0x56, 0x37, 0xCE, 0x8A, 0x3B, 0x55, 0xED, 0x40, 0x21, 0x12 },\n    { 0xE8, 0xE9, 0x9D, 0x0F, 0x45, 0x23, 0x7D, 0x78, 0x6D, 0x6B,\n      0xBA, 0xA7, 0x96, 0x5C, 0x78, 0x08, 0xBB, 0xFF, 0x1A, 0x91 }\n};\n\n/*\n * Checkup routine\n */\nint sha1_self_test( int verbose )\n{\n    int i, j, buflen;\n    unsigned char buf[1024];\n    unsigned char sha1sum[20];\n    sha1_context ctx;\n    /*\n     * SHA-1\n     */\n    for( i = 0; i < 3; i++ )\n    {\n        if( verbose != 0 )\n            printf( \"  SHA-1 test #%d: \", i + 1 );\n        sha1_starts( &ctx );\n        if( i == 2 )\n        {\n            memset( buf, 'a', buflen = 1000 );\n            for( j = 0; j < 1000; j++ )\n                sha1_update( &ctx, buf, buflen );\n        }\n        else\n            sha1_update( &ctx, sha1_test_buf[i],\n                               sha1_test_buflen[i] );\n        sha1_finish( &ctx, sha1sum );\n        if( memcmp( sha1sum, sha1_test_sum[i], 20 ) != 0 )\n        {\n            if( verbose != 0 )\n                printf( \"failed\\n\" );\n            return( 1 );\n        }\n        if( verbose != 0 )\n            printf( \"passed\\n\" );\n    }\n    if( verbose != 0 )\n        printf( \"\\n\" );\n    for( i = 0; i < 7; i++ )\n    {\n        if( verbose != 0 )\n            printf( \"  HMAC-SHA-1 test #%d: \", i + 1 );\n        if( i == 5 || i == 6 )\n        {\n            memset( buf, '\\xAA', buflen = 80 );\n            sha1_hmac_starts( &ctx, buf, buflen );\n        }\n        else\n            sha1_hmac_starts( &ctx, sha1_hmac_test_key[i],\n                                    sha1_hmac_test_keylen[i] );\n        sha1_hmac_update( &ctx, sha1_hmac_test_buf[i],\n                                sha1_hmac_test_buflen[i] );\n        sha1_hmac_finish( &ctx, sha1sum );\n        buflen = ( i == 4 ) ? 12 : 20;\n        if( memcmp( sha1sum, sha1_hmac_test_sum[i], buflen ) != 0 )\n        {\n            if( verbose != 0 )\n                printf( \"failed\\n\" );\n            return( 1 );\n        }\n        if( verbose != 0 )\n            printf( \"passed\\n\" );\n    }\n    if( verbose != 0 )\n        printf( \"\\n\" );\n    return( 0 );\n}\n#endif\n#endif\n\n\n\u4e45\u3057\u3076\u308a\u306bmbed\u3092\u3044\u3058\u308d\u3046\u3068\u601d\u3063\u3066\u3001\u3068\u308a\u3042\u3048\u305a\u524d\u306b\u66f8\u3044\u305fEthernetNetIf\u3092\u7528\u3044\u305f\u3082\u306e\u3092mbed\u516c\u5f0f\u306eEthernetInterface\u3092\u4f7f\u7528\u3057\u305f\u3082\u306e\u306b\u66f8\u304d\u63db\u3048\u3066\u307f\u307e\u3057\u305f\u3002\n[mbed official/EthernetInterface](http://mbed.org/users/mbed_official/code/EthernetInterface/ \"mbed official/EthernetInterface\")\nEthernetInterface\u306fmbed-rtos\u306b\u4f9d\u5b58\u3057\u305f\u30e9\u30a4\u30d6\u30e9\u30ea\u3068\u306a\u3063\u3066\u304a\u308a\u3001EthernetInterface\u3060\u3051\u3092\u30a4\u30f3\u30dd\u30fc\u30c8\u3057\u3066\u3082\u30b3\u30f3\u30d1\u30a4\u30eb\u30a8\u30e9\u30fc\u3068\u306a\u308b\u306e\u3067\u3001mbed-rtos\u3082\u30a4\u30f3\u30dd\u30fc\u30c8\u3059\u308b\u5fc5\u8981\u304c\u3042\u308a\u307e\u3059\u3002\n\u975e\u540c\u671f\u306a\u30b3\u30fc\u30c9\u306e\u66f8\u304d\u65b9\u304c\u308f\u304b\u3089\u306a\u3044\u305f\u3081\u3001\uff11\u30af\u30e9\u30a4\u30a2\u30f3\u30c8\u306e\u307f\u306b\u3057\u304b\u5bfe\u5fdc\u3057\u3066\u3044\u307e\u305b\u3093\u3002\u975e\u540c\u671f\u306a\u30b3\u30fc\u30c9\u304c\u66f8\u3051\u308c\u3070\u30de\u30eb\u30c1\u30af\u30e9\u30a4\u30a2\u30f3\u30c8\u306b\u5bfe\u5fdc\u3057\u305f\u3082\u306e\u304c\u3067\u304d\u308b\u304b\u3068\u601d\u3044\u307e\u3059\u3002\n\u30aa\u30f3\u30e9\u30a4\u30f3\u30b3\u30f3\u30d1\u30a4\u30e9\u3092\u5143\u306b\u8aac\u660e\u3059\u308b\u3068\u3001\u65b0\u3057\u304f\u30d7\u30ed\u30b0\u30e9\u30e0\u3092\u4f5c\u6210\u3057\u305f\u3089EthernetInterface\u3068mbed-rtos\u30e9\u30a4\u30d6\u30e9\u30ea\u3092\u30a4\u30f3\u30dd\u30fc\u30c8\u3057\u3001main.cpp\u3092\u4e0b\u8a18\u306e\u3088\u3046\u306b\u66f8\u304d\u63db\u3048\u3001sha1.h\u3001sha1.c\u3001sha1config.h\u306e3\u30d5\u30a1\u30a4\u30eb\u3092\u8ffd\u52a0\u3057\u3066\u30b3\u30f3\u30d1\u30a4\u30eb\u3057\u305f\u3089\u3001mbed\u306b\u5165\u308c\u3066\u5b9f\u884c\u5f8c\u3001[L\u30c1\u30ab\u30af\u30e9\u30a4\u30a2\u30f3\u30c8/jsdo.it](http://jsdo.it/gtk2k/fDZP \"L\u30c1\u30ab\u30af\u30e9\u30a4\u30a2\u30f3\u30c8/jsdo.it\")\u306b\u30a2\u30af\u30bb\u30b9\u3057\u3066\u8a66\u3057\u3066\u307f\u3066\u304f\u3060\u3055\u3044\u3002\n(sha1config.h\u306e\u30b3\u30fc\u30c9\u3092\u4e00\u756a\u4e0a\u306b\u66f8\u3044\u3066\u3042\u308b\u306e\u306f\u3001\u4e00\u756a\u4e0b\u306b\u66f8\u3044\u3066\u305f\u3089\u8868\u793a\u3055\u308c\u306a\u304b\u3063\u305f\u305f\u3081\u3067\u3059\u3002)\n\n```sha1config.h\n#ifndef SHA1CONFIG_H\n#define SHA1CONFIG_H\n\n#define POLARSSL_SHA1_C 1\n\n#endif\n```\n\n```cpp:main.cpp\n#include <string>\n#include <sstream>\n#include \"mbed.h\"\n#include \"EthernetInterface.h\"\n#include \"sha1config.h\"\n#include \"sha1.h\"\nconst int WS_HANDSHAKE = 1;\nconst int WS_CONNECT = 2;\nint wsState = 0;\nDigitalOut led1(LED1);\nDigitalOut led2(LED2);\nDigitalOut led3(LED3);\nDigitalOut led4(LED4);\n\nstring encode64(char *Buf,int Length) {\n    char *Codes64 = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n    int Byte3=0;\n    string Result=\"\";\n    for (int i=0; i<Length; i++) {\n        Byte3=(Byte3<<8)+(int)Buf[i];\n        if ((i+1)%3==0) {\n            Result=Result+Codes64[(Byte3>>18)&0x3F];\n            Result=Result+Codes64[(Byte3>>12)&0x3F];\n            Result=Result+Codes64[(Byte3>>6)&0x3F];\n            Result=Result+Codes64[(Byte3)&0x3F];\n            Byte3=0;\n        }\n    }\n\n    int Rest=Length%3;\n    switch (Rest) {\n        case 1:\n            Byte3=Byte3<<4;\n            Result=Result+Codes64[(Byte3>>6)&0x3F];\n            Result=Result+Codes64[(Byte3)&0x3F];\n            Result=Result+\"==\";\n            break;\n        case 2:\n            Byte3=Byte3<<2;\n            Result=Result+Codes64[(Byte3>>12)&0x3F];\n            Result=Result+Codes64[(Byte3>>6 )&0x3F];\n            Result=Result+Codes64[(Byte3)&0x3F];\n            Result=Result+\"=\";\n            break;\n    }\n    return Result;\n}\n\nint main() {\n    EthernetInterface eth;\n    eth.init(\"192.168.0.2\", \"255.255.255.0\", \"192.168.0.2\");\n    eth.connect(); \n    TCPSocketServer server;\n    server.bind(8080);\n    server.listen();\n    printf(\"\\nWait for new connection...\\n\");\n    TCPSocketConnection sock;\n    server.accept(sock);\n    wsState = WS_HANDSHAKE;\n    char buff[600];\n    int len;\n    while (true) {\n        len = sock.receive(buff, sizeof(buff)-1);\n        if (len <= 0){\n            printf(\"close by 0 length\\n\");\n            wsState = WS_HANDSHAKE;\n            continue;\n        }\n        buff[len] = '\\0';\n        switch(wsState){\n            case WS_HANDSHAKE:\n                printf(\"Received %d chars from server:\\n%s\\n\", len, buff);\n                for (int i = 0; i < len; i++) {\n                    if (buff[i] == 'K' && buff[i + 1] == 'e' && buff[i + 2] == 'y') {\n                        for (int j = i + 1; j < len; j++) {\n                            if (buff[j] == '\\r') {\n                                i += 5;\n                                int keyLen = j - i;\n                                char strKey[keyLen + 1];\n                                strKey[keyLen] = 0;\n                                strncpy(strKey, buff + i, keyLen);\n                                char guid[] = \"258EAFA5-E914-47DA-95CA-C5AB0DC85B11\";\n                                strcat(strKey, guid);\n                                unsigned char hash[20];\n                                sha1((unsigned char*)strKey,strlen((char*)strKey),hash);\n                                string accept = encode64((char*)hash, 20);\n                                string hsRes = \"HTTP/1.1 101 Switching Protocols\\r\\nUpgrade: websocket\\r\\nConnection: Upgrade\\r\\nSec-WebSocket-Accept: \";\n                                hsRes += accept;\n                                hsRes += \"\\r\\n\\r\\n\";\n                                printf(\"%s\", hsRes.c_str());\n                                sock.send_all((char *)hsRes.c_str(), hsRes.size());\n                                printf(\"change to WS_CONNECT state\\n\");\n                                wsState = WS_CONNECT;\n                                break;\n                            }\n                        }\n                    }\n                }\n                break;\n            case WS_CONNECT:\n                bool fin = (buff[0] & 0x80) == 0x80;\n                int opcode = buff[0] & 0x0f;\n                if (opcode == 0x8) {\n                    printf(\"close by close opcode\\n\");\n                    wsState = WS_HANDSHAKE;\n                    sock.close();\n                    break;\n                }\n                if (opcode == 0x9) {\n                    buff[0] += 1;\n                    sock.send_all(buff, len);\n                    break;\n                }\n                int dataLen = buff[1] & 0x7f;\n                if (!fin || dataLen > 125) {\n                    sock.close();\n                    printf(\"close by illegal data length \\n\");\n                    wsState = WS_HANDSHAKE;\n                    break;\n                }\n                int i = 0;\n                for (i = 0; i < dataLen; i++) {\n                    buff[6 + i] = buff[6 + i] ^ buff[2 + (i % 4)];\n                }\n                printf(\"data length:%d\\n\", dataLen);\n                buff[6 + dataLen] = 0;\n                if (opcode == 1) {\n                    printf(\"received data:%s\\n\", buff + 6);\n                    char sendData[2 + dataLen + 1];\n                    sendData[0] = buff[0];\n                    sendData[1] = buff[1] & 0x7f;\n                    for (i = 0; i < dataLen; i++) {\n                        sendData[2 + i] = buff[6 + i];\n                    }\n                    sendData[2 + dataLen] = 0;\n                    sock.send_all(sendData, 2 + dataLen);\n                } else if (opcode == 2) {\n                    led1 = buff[6 + 0];\n                    led2 = buff[6 + 1];\n                    led3 = buff[6 + 2];\n                    led4 = buff[6 + 3];\n                }\n                break;\n        }\n    }\n      \n    sock.close();\n    eth.disconnect();\n    while(1) {}\n}\n```\n\n```cpp:sha1.h\n/**\n * \\file sha1.h\n *\n *  Copyright (C) 2006-2010, Paul Bakker <polarssl_maintainer at polarssl.org>\n *  All rights reserved.\n *\n *  This program is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation; either version 2 of the License, or\n *  (at your option) any later version.\n *\n *  This program is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License along\n *  with this program; if not, write to the Free Software Foundation, Inc.,\n *  51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n */\n#ifndef POLARSSL_SHA1_H\n#define POLARSSL_SHA1_H\n\n/**\n * \\brief          SHA-1 context structure\n */\ntypedef struct\n{\n    unsigned long total[2];     /*!< number of bytes processed  */\n    unsigned long state[5];     /*!< intermediate digest state  */\n    unsigned char buffer[64];   /*!< data block being processed */\n\n    unsigned char ipad[64];     /*!< HMAC: inner padding        */\n    unsigned char opad[64];     /*!< HMAC: outer padding        */\n}\nsha1_context;\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n/**\n * \\brief          SHA-1 context setup\n *\n * \\param ctx      context to be initialized\n */\nvoid sha1_starts( sha1_context *ctx );\n\n/**\n * \\brief          SHA-1 process buffer\n *\n * \\param ctx      SHA-1 context\n * \\param input    buffer holding the  data\n * \\param ilen     length of the input data\n */\nvoid sha1_update( sha1_context *ctx, const unsigned char *input, int ilen );\n\n/**\n * \\brief          SHA-1 final digest\n *\n * \\param ctx      SHA-1 context\n * \\param output   SHA-1 checksum result\n */\nvoid sha1_finish( sha1_context *ctx, unsigned char output[20] );\n\n/**\n * \\brief          Output = SHA-1( input buffer )\n *\n * \\param input    buffer holding the  data\n * \\param ilen     length of the input data\n * \\param output   SHA-1 checksum result\n */\nvoid sha1( const unsigned char *input, int ilen, unsigned char output[20] );\n\n#if 0 //No need for that\n/**\n * \\brief          Output = SHA-1( file contents )\n *\n * \\param path     input file name\n * \\param output   SHA-1 checksum result\n *\n * \\return         0 if successful, 1 if fopen failed,\n *                 or 2 if fread failed\n */\nint sha1_file( const char *path, unsigned char output[20] );\n#endif\n\n/**\n * \\brief          SHA-1 HMAC context setup\n *\n * \\param ctx      HMAC context to be initialized\n * \\param key      HMAC secret key\n * \\param keylen   length of the HMAC key\n */\nvoid sha1_hmac_starts( sha1_context *ctx, const unsigned char *key, int keylen );\n\n/**\n * \\brief          SHA-1 HMAC process buffer\n *\n * \\param ctx      HMAC context\n * \\param input    buffer holding the  data\n * \\param ilen     length of the input data\n */\nvoid sha1_hmac_update( sha1_context *ctx, const unsigned char *input, int ilen );\n\n/**\n * \\brief          SHA-1 HMAC final digest\n *\n * \\param ctx      HMAC context\n * \\param output   SHA-1 HMAC checksum result\n */\nvoid sha1_hmac_finish( sha1_context *ctx, unsigned char output[20] );\n\n/**\n * \\brief          SHA-1 HMAC context reset\n *\n * \\param ctx      HMAC context to be reset\n */\nvoid sha1_hmac_reset( sha1_context *ctx );\n\n/**\n * \\brief          Output = HMAC-SHA-1( hmac key, input buffer )\n *\n * \\param key      HMAC secret key\n * \\param keylen   length of the HMAC key\n * \\param input    buffer holding the  data\n * \\param ilen     length of the input data\n * \\param output   HMAC-SHA-1 result\n */\nvoid sha1_hmac( const unsigned char *key, int keylen,\n                const unsigned char *input, int ilen,\n                unsigned char output[20] );\n\n/**\n * \\brief          Checkup routine\n *\n * \\return         0 if successful, or 1 if the test failed\n */\nint sha1_self_test( int verbose );\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif /* sha1.h */\n```\n\n```c:sha1.c\n/*\n *  FIPS-180-1 compliant SHA-1 implementation\n *\n *  Copyright (C) 2006-2010, Paul Bakker <polarssl_maintainer at polarssl.org>\n *  All rights reserved.\n *\n *  This program is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation; either version 2 of the License, or\n *  (at your option) any later version.\n *\n *  This program is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License along\n *  with this program; if not, write to the Free Software Foundation, Inc.,\n *  51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n */\n/*\n *  The SHA-1 standard was published by NIST in 1993.\n *\n *  http://www.itl.nist.gov/fipspubs/fip180-1.htm\n */\n#include \"sha1config.h\"\n#if defined(POLARSSL_SHA1_C)\n#include \"sha1.h\"\n#include <string.h>\n#include <stdio.h>\n\n/*\n * 32-bit integer manipulation macros (big endian)\n */\n#ifndef GET_ULONG_BE\n#define GET_ULONG_BE(n,b,i)                             \\\n{                                                       \\\n    (n) = ( (unsigned long) (b)[(i)    ] << 24 )        \\\n        | ( (unsigned long) (b)[(i) + 1] << 16 )        \\\n        | ( (unsigned long) (b)[(i) + 2] <<  8 )        \\\n        | ( (unsigned long) (b)[(i) + 3]       );       \\\n}\n#endif\n\n#ifndef PUT_ULONG_BE\n#define PUT_ULONG_BE(n,b,i)                             \\\n{                                                       \\\n    (b)[(i)    ] = (unsigned char) ( (n) >> 24 );       \\\n    (b)[(i) + 1] = (unsigned char) ( (n) >> 16 );       \\\n    (b)[(i) + 2] = (unsigned char) ( (n) >>  8 );       \\\n    (b)[(i) + 3] = (unsigned char) ( (n)       );       \\\n}\n#endif\n\n/*\n * SHA-1 context setup\n */\nvoid sha1_starts( sha1_context *ctx )\n{\n    ctx->total[0] = 0;\n    ctx->total[1] = 0;\n    ctx->state[0] = 0x67452301;\n    ctx->state[1] = 0xEFCDAB89;\n    ctx->state[2] = 0x98BADCFE;\n    ctx->state[3] = 0x10325476;\n    ctx->state[4] = 0xC3D2E1F0;\n}\n\nstatic void sha1_process( sha1_context *ctx, const unsigned char data[64] )\n{\n    unsigned long temp, W[16], A, B, C, D, E;\n    GET_ULONG_BE( W[ 0], data,  0 );\n    GET_ULONG_BE( W[ 1], data,  4 );\n    GET_ULONG_BE( W[ 2], data,  8 );\n    GET_ULONG_BE( W[ 3], data, 12 );\n    GET_ULONG_BE( W[ 4], data, 16 );\n    GET_ULONG_BE( W[ 5], data, 20 );\n    GET_ULONG_BE( W[ 6], data, 24 );\n    GET_ULONG_BE( W[ 7], data, 28 );\n    GET_ULONG_BE( W[ 8], data, 32 );\n    GET_ULONG_BE( W[ 9], data, 36 );\n    GET_ULONG_BE( W[10], data, 40 );\n    GET_ULONG_BE( W[11], data, 44 );\n    GET_ULONG_BE( W[12], data, 48 );\n    GET_ULONG_BE( W[13], data, 52 );\n    GET_ULONG_BE( W[14], data, 56 );\n    GET_ULONG_BE( W[15], data, 60 );\n#define S(x,n) ((x << n) | ((x & 0xFFFFFFFF) >> (32 - n)))\n#define R(t)                                            \\\n(                                                       \\\n    temp = W[(t -  3) & 0x0F] ^ W[(t - 8) & 0x0F] ^     \\\n           W[(t - 14) & 0x0F] ^ W[ t      & 0x0F],      \\\n    ( W[t & 0x0F] = S(temp,1) )                         \\\n)\n#define P(a,b,c,d,e,x)                                  \\\n{                                                       \\\n    e += S(a,5) + F(b,c,d) + K + x; b = S(b,30);        \\\n}\n    A = ctx->state[0];\n    B = ctx->state[1];\n    C = ctx->state[2];\n    D = ctx->state[3];\n    E = ctx->state[4];\n#define F(x,y,z) (z ^ (x & (y ^ z)))\n#define K 0x5A827999\n    P( A, B, C, D, E, W[0]  );\n    P( E, A, B, C, D, W[1]  );\n    P( D, E, A, B, C, W[2]  );\n    P( C, D, E, A, B, W[3]  );\n    P( B, C, D, E, A, W[4]  );\n    P( A, B, C, D, E, W[5]  );\n    P( E, A, B, C, D, W[6]  );\n    P( D, E, A, B, C, W[7]  );\n    P( C, D, E, A, B, W[8]  );\n    P( B, C, D, E, A, W[9]  );\n    P( A, B, C, D, E, W[10] );\n    P( E, A, B, C, D, W[11] );\n    P( D, E, A, B, C, W[12] );\n    P( C, D, E, A, B, W[13] );\n    P( B, C, D, E, A, W[14] );\n    P( A, B, C, D, E, W[15] );\n    P( E, A, B, C, D, R(16) );\n    P( D, E, A, B, C, R(17) );\n    P( C, D, E, A, B, R(18) );\n    P( B, C, D, E, A, R(19) );\n#undef K\n#undef F\n#define F(x,y,z) (x ^ y ^ z)\n#define K 0x6ED9EBA1\n    P( A, B, C, D, E, R(20) );\n    P( E, A, B, C, D, R(21) );\n    P( D, E, A, B, C, R(22) );\n    P( C, D, E, A, B, R(23) );\n    P( B, C, D, E, A, R(24) );\n    P( A, B, C, D, E, R(25) );\n    P( E, A, B, C, D, R(26) );\n    P( D, E, A, B, C, R(27) );\n    P( C, D, E, A, B, R(28) );\n    P( B, C, D, E, A, R(29) );\n    P( A, B, C, D, E, R(30) );\n    P( E, A, B, C, D, R(31) );\n    P( D, E, A, B, C, R(32) );\n    P( C, D, E, A, B, R(33) );\n    P( B, C, D, E, A, R(34) );\n    P( A, B, C, D, E, R(35) );\n    P( E, A, B, C, D, R(36) );\n    P( D, E, A, B, C, R(37) );\n    P( C, D, E, A, B, R(38) );\n    P( B, C, D, E, A, R(39) );\n#undef K\n#undef F\n#define F(x,y,z) ((x & y) | (z & (x | y)))\n#define K 0x8F1BBCDC\n    P( A, B, C, D, E, R(40) );\n    P( E, A, B, C, D, R(41) );\n    P( D, E, A, B, C, R(42) );\n    P( C, D, E, A, B, R(43) );\n    P( B, C, D, E, A, R(44) );\n    P( A, B, C, D, E, R(45) );\n    P( E, A, B, C, D, R(46) );\n    P( D, E, A, B, C, R(47) );\n    P( C, D, E, A, B, R(48) );\n    P( B, C, D, E, A, R(49) );\n    P( A, B, C, D, E, R(50) );\n    P( E, A, B, C, D, R(51) );\n    P( D, E, A, B, C, R(52) );\n    P( C, D, E, A, B, R(53) );\n    P( B, C, D, E, A, R(54) );\n    P( A, B, C, D, E, R(55) );\n    P( E, A, B, C, D, R(56) );\n    P( D, E, A, B, C, R(57) );\n    P( C, D, E, A, B, R(58) );\n    P( B, C, D, E, A, R(59) );\n#undef K\n#undef F\n#define F(x,y,z) (x ^ y ^ z)\n#define K 0xCA62C1D6\n    P( A, B, C, D, E, R(60) );\n    P( E, A, B, C, D, R(61) );\n    P( D, E, A, B, C, R(62) );\n    P( C, D, E, A, B, R(63) );\n    P( B, C, D, E, A, R(64) );\n    P( A, B, C, D, E, R(65) );\n    P( E, A, B, C, D, R(66) );\n    P( D, E, A, B, C, R(67) );\n    P( C, D, E, A, B, R(68) );\n    P( B, C, D, E, A, R(69) );\n    P( A, B, C, D, E, R(70) );\n    P( E, A, B, C, D, R(71) );\n    P( D, E, A, B, C, R(72) );\n    P( C, D, E, A, B, R(73) );\n    P( B, C, D, E, A, R(74) );\n    P( A, B, C, D, E, R(75) );\n    P( E, A, B, C, D, R(76) );\n    P( D, E, A, B, C, R(77) );\n    P( C, D, E, A, B, R(78) );\n    P( B, C, D, E, A, R(79) );\n#undef K\n#undef F\n    ctx->state[0] += A;\n    ctx->state[1] += B;\n    ctx->state[2] += C;\n    ctx->state[3] += D;\n    ctx->state[4] += E;\n}\n\n/*\n * SHA-1 process buffer\n */\nvoid sha1_update( sha1_context *ctx, const unsigned char *input, int ilen )\n{\n    int fill;\n    unsigned long left;\n    if( ilen <= 0 ) return;\n    left = ctx->total[0] & 0x3F;\n    fill = 64 - left;\n    ctx->total[0] += ilen;\n    ctx->total[0] &= 0xFFFFFFFF;\n    if( ctx->total[0] < (unsigned long) ilen )\n        ctx->total[1]++;\n    if( left && ilen >= fill )\n    {\n        memcpy( (void *) (ctx->buffer + left),\n                (void *) input, fill );\n        sha1_process( ctx, ctx->buffer );\n        input += fill;\n        ilen  -= fill;\n        left = 0;\n    }\n    while( ilen >= 64 )\n    {\n        sha1_process( ctx, input );\n        input += 64;\n        ilen  -= 64;\n    }\n    if( ilen > 0 )\n    {\n        memcpy( (void *) (ctx->buffer + left),\n                (void *) input, ilen );\n    }\n}\n\nstatic const unsigned char sha1_padding[64] =\n{\n 0x80, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0\n};\n\n/*\n * SHA-1 final digest\n */\nvoid sha1_finish( sha1_context *ctx, unsigned char output[20] )\n{\n    unsigned long last, padn;\n    unsigned long high, low;\n    unsigned char msglen[8];\n    high = ( ctx->total[0] >> 29 )\n         | ( ctx->total[1] <<  3 );\n    low  = ( ctx->total[0] <<  3 );\n    PUT_ULONG_BE( high, msglen, 0 );\n    PUT_ULONG_BE( low,  msglen, 4 );\n    last = ctx->total[0] & 0x3F;\n    padn = ( last < 56 ) ? ( 56 - last ) : ( 120 - last );\n    sha1_update( ctx, (unsigned char *) sha1_padding, padn );\n    sha1_update( ctx, msglen, 8 );\n    PUT_ULONG_BE( ctx->state[0], output,  0 );\n    PUT_ULONG_BE( ctx->state[1], output,  4 );\n    PUT_ULONG_BE( ctx->state[2], output,  8 );\n    PUT_ULONG_BE( ctx->state[3], output, 12 );\n    PUT_ULONG_BE( ctx->state[4], output, 16 );\n}\n\n/*\n * output = SHA-1( input buffer )\n */\nvoid sha1( const unsigned char *input, int ilen, unsigned char output[20] )\n{\n    sha1_context ctx;\n    sha1_starts( &ctx );\n    sha1_update( &ctx, input, ilen );\n    sha1_finish( &ctx, output );\n    memset( &ctx, 0, sizeof( sha1_context ) );\n}\n\n/*\n * output = SHA-1( file contents )\n */\n#if 0 //No need for that\nint sha1_file( const char *path, unsigned char output[20] )\n{\n    FILE *f;\n    size_t n;\n    sha1_context ctx;\n    unsigned char buf[1024];\n    if( ( f = fopen( path, \"rb\" ) ) == NULL )\n        return( 1 );\n    sha1_starts( &ctx );\n    while( ( n = fread( buf, 1, sizeof( buf ), f ) ) > 0 )\n        sha1_update( &ctx, buf, (int) n );\n    sha1_finish( &ctx, output );\n    memset( &ctx, 0, sizeof( sha1_context ) );\n    if( ferror( f ) != 0 )\n    {\n        fclose( f );\n        return( 2 );\n    }\n    fclose( f );\n    return( 0 );\n}\n#endif\n\n/*\n * SHA-1 HMAC context setup\n */\nvoid sha1_hmac_starts( sha1_context *ctx, const unsigned char *key, int keylen )\n{\n    int i;\n    unsigned char sum[20];\n    if( keylen > 64 )\n    {\n        sha1( key, keylen, sum );\n        keylen = 20;\n        key = sum;\n    }\n    memset( ctx->ipad, 0x36, 64 );\n    memset( ctx->opad, 0x5C, 64 );\n    for( i = 0; i < keylen; i++ )\n    {\n        ctx->ipad[i] = (unsigned char)( ctx->ipad[i] ^ key[i] );\n        ctx->opad[i] = (unsigned char)( ctx->opad[i] ^ key[i] );\n    }\n    sha1_starts( ctx );\n    sha1_update( ctx, ctx->ipad, 64 );\n    memset( sum, 0, sizeof( sum ) );\n}\n\n/*\n * SHA-1 HMAC process buffer\n */\nvoid sha1_hmac_update( sha1_context *ctx, const unsigned char *input, int ilen )\n{\n    sha1_update( ctx, input, ilen );\n}\n\n/*\n * SHA-1 HMAC final digest\n */\nvoid sha1_hmac_finish( sha1_context *ctx, unsigned char output[20] )\n{\n    unsigned char tmpbuf[20];\n    sha1_finish( ctx, tmpbuf );\n    sha1_starts( ctx );\n    sha1_update( ctx, ctx->opad, 64 );\n    sha1_update( ctx, tmpbuf, 20 );\n    sha1_finish( ctx, output );\n    memset( tmpbuf, 0, sizeof( tmpbuf ) );\n}\n\n/*\n * SHA1 HMAC context reset\n */\nvoid sha1_hmac_reset( sha1_context *ctx )\n{\n    sha1_starts( ctx );\n    sha1_update( ctx, ctx->ipad, 64 );\n}\n\n/*\n * output = HMAC-SHA-1( hmac key, input buffer )\n */\nvoid sha1_hmac( const unsigned char *key, int keylen,\n                const unsigned char *input, int ilen,\n                unsigned char output[20] )\n{\n    sha1_context ctx;\n    sha1_hmac_starts( &ctx, key, keylen );\n    sha1_hmac_update( &ctx, input, ilen );\n    sha1_hmac_finish( &ctx, output );\n    memset( &ctx, 0, sizeof( sha1_context ) );\n}\n\n#if defined(POLARSSL_SELF_TEST)\n/*\n * FIPS-180-1 test vectors\n */\nstatic unsigned char sha1_test_buf[3][57] = \n{\n    { \"abc\" },\n    { \"abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq\" },\n    { \"\" }\n};\n\nstatic const int sha1_test_buflen[3] =\n{\n    3, 56, 1000\n};\n\nstatic const unsigned char sha1_test_sum[3][20] =\n{\n    { 0xA9, 0x99, 0x3E, 0x36, 0x47, 0x06, 0x81, 0x6A, 0xBA, 0x3E,\n      0x25, 0x71, 0x78, 0x50, 0xC2, 0x6C, 0x9C, 0xD0, 0xD8, 0x9D },\n    { 0x84, 0x98, 0x3E, 0x44, 0x1C, 0x3B, 0xD2, 0x6E, 0xBA, 0xAE,\n      0x4A, 0xA1, 0xF9, 0x51, 0x29, 0xE5, 0xE5, 0x46, 0x70, 0xF1 },\n    { 0x34, 0xAA, 0x97, 0x3C, 0xD4, 0xC4, 0xDA, 0xA4, 0xF6, 0x1E,\n      0xEB, 0x2B, 0xDB, 0xAD, 0x27, 0x31, 0x65, 0x34, 0x01, 0x6F }\n};\n\n/*\n * RFC 2202 test vectors\n */\nstatic unsigned char sha1_hmac_test_key[7][26] =\n{\n    { \"\\x0B\\x0B\\x0B\\x0B\\x0B\\x0B\\x0B\\x0B\\x0B\\x0B\\x0B\\x0B\\x0B\\x0B\\x0B\\x0B\"\n      \"\\x0B\\x0B\\x0B\\x0B\" },\n    { \"Jefe\" },\n    { \"\\xAA\\xAA\\xAA\\xAA\\xAA\\xAA\\xAA\\xAA\\xAA\\xAA\\xAA\\xAA\\xAA\\xAA\\xAA\\xAA\"\n      \"\\xAA\\xAA\\xAA\\xAA\" },\n    { \"\\x01\\x02\\x03\\x04\\x05\\x06\\x07\\x08\\x09\\x0A\\x0B\\x0C\\x0D\\x0E\\x0F\\x10\"\n      \"\\x11\\x12\\x13\\x14\\x15\\x16\\x17\\x18\\x19\" },\n    { \"\\x0C\\x0C\\x0C\\x0C\\x0C\\x0C\\x0C\\x0C\\x0C\\x0C\\x0C\\x0C\\x0C\\x0C\\x0C\\x0C\"\n      \"\\x0C\\x0C\\x0C\\x0C\" },\n    { \"\" }, /* 0xAA 80 times */\n    { \"\" }\n};\n\nstatic const int sha1_hmac_test_keylen[7] =\n{\n    20, 4, 20, 25, 20, 80, 80\n};\n\nstatic unsigned char sha1_hmac_test_buf[7][74] =\n{\n    { \"Hi There\" },\n    { \"what do ya want for nothing?\" },\n    { \"\\xDD\\xDD\\xDD\\xDD\\xDD\\xDD\\xDD\\xDD\\xDD\\xDD\"\n      \"\\xDD\\xDD\\xDD\\xDD\\xDD\\xDD\\xDD\\xDD\\xDD\\xDD\"\n      \"\\xDD\\xDD\\xDD\\xDD\\xDD\\xDD\\xDD\\xDD\\xDD\\xDD\"\n      \"\\xDD\\xDD\\xDD\\xDD\\xDD\\xDD\\xDD\\xDD\\xDD\\xDD\"\n      \"\\xDD\\xDD\\xDD\\xDD\\xDD\\xDD\\xDD\\xDD\\xDD\\xDD\" },\n    { \"\\xCD\\xCD\\xCD\\xCD\\xCD\\xCD\\xCD\\xCD\\xCD\\xCD\"\n      \"\\xCD\\xCD\\xCD\\xCD\\xCD\\xCD\\xCD\\xCD\\xCD\\xCD\"\n      \"\\xCD\\xCD\\xCD\\xCD\\xCD\\xCD\\xCD\\xCD\\xCD\\xCD\"\n      \"\\xCD\\xCD\\xCD\\xCD\\xCD\\xCD\\xCD\\xCD\\xCD\\xCD\"\n      \"\\xCD\\xCD\\xCD\\xCD\\xCD\\xCD\\xCD\\xCD\\xCD\\xCD\" },\n    { \"Test With Truncation\" },\n    { \"Test Using Larger Than Block-Size Key - Hash Key First\" },\n    { \"Test Using Larger Than Block-Size Key and Larger\"\n      \" Than One Block-Size Data\" }\n};\n\nstatic const int sha1_hmac_test_buflen[7] =\n{\n    8, 28, 50, 50, 20, 54, 73\n};\n\nstatic const unsigned char sha1_hmac_test_sum[7][20] =\n{\n    { 0xB6, 0x17, 0x31, 0x86, 0x55, 0x05, 0x72, 0x64, 0xE2, 0x8B,\n      0xC0, 0xB6, 0xFB, 0x37, 0x8C, 0x8E, 0xF1, 0x46, 0xBE, 0x00 },\n    { 0xEF, 0xFC, 0xDF, 0x6A, 0xE5, 0xEB, 0x2F, 0xA2, 0xD2, 0x74,\n      0x16, 0xD5, 0xF1, 0x84, 0xDF, 0x9C, 0x25, 0x9A, 0x7C, 0x79 },\n    { 0x12, 0x5D, 0x73, 0x42, 0xB9, 0xAC, 0x11, 0xCD, 0x91, 0xA3,\n      0x9A, 0xF4, 0x8A, 0xA1, 0x7B, 0x4F, 0x63, 0xF1, 0x75, 0xD3 },\n    { 0x4C, 0x90, 0x07, 0xF4, 0x02, 0x62, 0x50, 0xC6, 0xBC, 0x84,\n      0x14, 0xF9, 0xBF, 0x50, 0xC8, 0x6C, 0x2D, 0x72, 0x35, 0xDA },\n    { 0x4C, 0x1A, 0x03, 0x42, 0x4B, 0x55, 0xE0, 0x7F, 0xE7, 0xF2,\n      0x7B, 0xE1 },\n    { 0xAA, 0x4A, 0xE5, 0xE1, 0x52, 0x72, 0xD0, 0x0E, 0x95, 0x70,\n      0x56, 0x37, 0xCE, 0x8A, 0x3B, 0x55, 0xED, 0x40, 0x21, 0x12 },\n    { 0xE8, 0xE9, 0x9D, 0x0F, 0x45, 0x23, 0x7D, 0x78, 0x6D, 0x6B,\n      0xBA, 0xA7, 0x96, 0x5C, 0x78, 0x08, 0xBB, 0xFF, 0x1A, 0x91 }\n};\n\n/*\n * Checkup routine\n */\nint sha1_self_test( int verbose )\n{\n    int i, j, buflen;\n    unsigned char buf[1024];\n    unsigned char sha1sum[20];\n    sha1_context ctx;\n    /*\n     * SHA-1\n     */\n    for( i = 0; i < 3; i++ )\n    {\n        if( verbose != 0 )\n            printf( \"  SHA-1 test #%d: \", i + 1 );\n        sha1_starts( &ctx );\n        if( i == 2 )\n        {\n            memset( buf, 'a', buflen = 1000 );\n            for( j = 0; j < 1000; j++ )\n                sha1_update( &ctx, buf, buflen );\n        }\n        else\n            sha1_update( &ctx, sha1_test_buf[i],\n                               sha1_test_buflen[i] );\n        sha1_finish( &ctx, sha1sum );\n        if( memcmp( sha1sum, sha1_test_sum[i], 20 ) != 0 )\n        {\n            if( verbose != 0 )\n                printf( \"failed\\n\" );\n            return( 1 );\n        }\n        if( verbose != 0 )\n            printf( \"passed\\n\" );\n    }\n    if( verbose != 0 )\n        printf( \"\\n\" );\n    for( i = 0; i < 7; i++ )\n    {\n        if( verbose != 0 )\n            printf( \"  HMAC-SHA-1 test #%d: \", i + 1 );\n        if( i == 5 || i == 6 )\n        {\n            memset( buf, '\\xAA', buflen = 80 );\n            sha1_hmac_starts( &ctx, buf, buflen );\n        }\n        else\n            sha1_hmac_starts( &ctx, sha1_hmac_test_key[i],\n                                    sha1_hmac_test_keylen[i] );\n        sha1_hmac_update( &ctx, sha1_hmac_test_buf[i],\n                                sha1_hmac_test_buflen[i] );\n        sha1_hmac_finish( &ctx, sha1sum );\n        buflen = ( i == 4 ) ? 12 : 20;\n        if( memcmp( sha1sum, sha1_hmac_test_sum[i], buflen ) != 0 )\n        {\n            if( verbose != 0 )\n                printf( \"failed\\n\" );\n            return( 1 );\n        }\n        if( verbose != 0 )\n            printf( \"passed\\n\" );\n    }\n    if( verbose != 0 )\n        printf( \"\\n\" );\n    return( 0 );\n}\n#endif\n#endif\n```", "tags": ["mbed", "websocket"]}