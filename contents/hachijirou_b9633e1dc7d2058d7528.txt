{"context": "\n\n\u52d5\u6a5f\n\u5b66\u751f\u6642\u4ee3\u306f\u82f1\u8a9e\u304c\u4e00\u756a\u82e6\u624b\u3067\u3057\u305f\u304c\u3001\u3044\u307e\u3044\u3061redux-thunk\u304c\u7406\u89e3\u3067\u304d\u306a\u304b\u3063\u305f\u306e\u3067\u9811\u5f35\u3063\u3066\u7ffb\u8a33\u3057\u307e\u3057\u305f\u3002\u304a\u304b\u3057\u306a\u8a33\u304c\u3042\u308c\u3070\u3054\u6307\u6458\u304f\u3060\u3055\u3044\u3002\u307e\u305f\u3001\u5206\u304b\u3089\u306a\u3044\u3068\u3053\u308d\u306f\u539f\u6587\u306e\u8a00\u8449\u3092\u4f7f\u3046\u304b\u7701\u7565\u3057\u3066\u304a\u308a\u307e\u3059\u306e\u3067\u3054\u4e86\u627f\u304f\u3060\u3055\u3044\u3002\n\u5143\u8a18\u4e8b:\nhttp://stackoverflow.com/questions/35411423/how-to-dispatch-a-redux-action-with-a-timeout/35415559#35415559\n\n\u7ffb\u8a33\n\nWriting Async Code Inline\n\n\u975e\u540c\u671f\u30b3\u30fc\u30c9\u306b\u3064\u3044\u3066\u66f8\u304f\n\nThis is by far the simplest way. And there\u2019s nothing specific to Redux here.\n\n\u3053\u308c\u306f\u6700\u3082\u7c21\u5358\u306a\u65b9\u6cd5\u3067\u3059\u3002\u305d\u3057\u3066\u3001\u3053\u308c\u306fRedux\u56fa\u6709\u306e\u3082\u306e\u3067\u306f\u3042\u308a\u307e\u305b\u3093\u3002\nstore.dispatch({ type: 'SHOW_NOTIFICATION', text: 'You logged in.' })\nsetTimeout(() => {\n  store.dispatch({ type: 'HIDE_NOTIFICATION' })\n}, 5000)\n\n\nSimilarly, from inside a connected component:\n\n\u540c\u69d8\u306b\u300ca connected component\u300d\u306e\u5185\u5074\u304b\u3089\nthis.props.dispatch({ type: 'SHOW_NOTIFICATION', text: 'You logged in.' })\nsetTimeout(() => {\n  this.props.dispatch({ type: 'HIDE_NOTIFICATION' })\n}, 5000)\n\n\nThe only difference is that in a connected component you usually don\u2019t have access to the store itself, but get either dispatch() or specific action creators injected as props. However this doesn\u2019t make any difference for us.\n\n\u552f\u4e00\u306e\u9055\u3044\u306f\u3001\u300ca connected component\u300d\u306e\u4e2d\u3067\u306f\u3042\u306a\u305f\u306f\u901a\u5e38store\u81ea\u4f53\u306b\u30a2\u30af\u30bb\u30b9\u3067\u304d\u307e\u305b\u3093\u304c\u3001dispatch()\u304bprops\u3068\u3057\u3066\u6ce8\u5165\u3055\u308c\u305f\u7279\u5b9a\u306e\u30a2\u30af\u30b7\u30e7\u30f3\u30af\u30ea\u30a8\u30fc\u30bf\u30fc\u306e\u3044\u305a\u308c\u304b\u3092\u53d6\u5f97\u3059\u308b\u3053\u3068\u3067\u3059\u3002\u3057\u304b\u3057\u3001\u79c1\u305f\u3061\u306b\u3068\u3063\u3066\u9055\u3044\u306f\u3042\u308a\u307e\u305b\u3093\u3002\n\nIf you don\u2019t like making typos when dispatching the same actions from different components, you might want to extract action creators instead of dispatching action objects inline:\n\n\u3082\u3057\u3001\u3042\u306a\u305f\u304c\u7570\u306a\u308b\u30b3\u30f3\u30dd\u30fc\u30cd\u30f3\u30c8\u304b\u3089\u540c\u3058\u30a2\u30af\u30b7\u30e7\u30f3\u306b\u30c7\u30a3\u30b9\u30d1\u30c3\u30c1\u3059\u308b\u3068\u304d\u306e\u30bf\u30a4\u30d7\u30df\u30b9\u3092\u6c17\u306b\u98df\u308f\u306a\u3044\u306a\u3089\u3070\u3001\u30c7\u30a3\u30b9\u30d1\u30c3\u30c1\u3059\u308b\u30a2\u30af\u30b7\u30e7\u30f3\u30aa\u30d6\u30b8\u30a7\u30af\u30c8\u306e\u4ee3\u308f\u308a\u306b\u30a2\u30af\u30b7\u30e7\u30f3\u30af\u30ea\u30a8\u30fc\u30bf\u3092\u62bd\u51fa\u3059\u308b\u3053\u3068\u304c\u3067\u304d\u307e\u3059\u3002\n// actions.js\nexport function showNotification(text) {\n  return { type: 'SHOW_NOTIFICATION', text }\n}\nexport function hideNotification() {\n  return { type: 'HIDE_NOTIFICATION' }\n}\n\n// component.js\nimport { showNotification, hideNotification } from '../actions'\n\nthis.props.dispatch(showNotification('You just logged in.'))\nsetTimeout(() => {\n  this.props.dispatch(hideNotification())\n}, 5000)\n\n\nOr, if you have previously bound them with connect():\n\n\u307e\u305f\u3001\u3042\u306a\u305f\u304c\u4ee5\u524dconnect()\u3092\u4f7f\u3063\u3066\u305d\u308c\u3089\u3092\u7d50\u5408\u3057\u305f\u5834\u5408:\nthis.props.showNotification('You just logged in.')\nsetTimeout(() => {\n  this.props.hideNotification()\n}, 5000)\n\n\nSo far we have not used any middleware or other advanced concept.\n\n\u3053\u3053\u307e\u3067\u306f\u30df\u30c9\u30eb\u30a6\u30a7\u30a2\u3084\u9ad8\u5ea6\u306a\u6982\u5ff5\u3092\u4f7f\u7528\u3057\u3066\u306f\u3044\u307e\u305b\u3093\u3002\n\nExtracting Async Action Creator\n\n\u975e\u540c\u671f\u30a2\u30af\u30b7\u30e7\u30f3\u30af\u30ea\u30a8\u30fc\u30bf\u3092\u62bd\u51fa\u3059\u308b\n\nThe approach above works fine in simple cases but you might find that it has a few problems:\n\n\u5358\u7d14\u306a\u4f8b\u3067\u306f\u4e0a\u8a18\u306e\u3088\u3046\u306a\u30a2\u30d7\u30ed\u30fc\u30c1\u306f\u6b63\u5e38\u306b\u52d5\u4f5c\u3059\u308b\u304b\u3082\u3057\u308c\u307e\u305b\u3093\u304c\u3001\u3042\u306a\u305f\u306f\u3044\u304f\u3064\u304b\u306e\u554f\u984c\u3092\u898b\u3064\u3051\u308b\u304b\u3082\u3057\u308c\u307e\u305b\u3093\u3002\n\nIt forces you to duplicate this logic anywhere you want to show a notification.\n\n\n\u3042\u306a\u305f\u304c\u901a\u77e5\u3092\u8868\u793a\u3057\u305f\u3044\u5834\u6240\u306b\u3053\u306e\u30ed\u30b8\u30c3\u30af\u306e\u8907\u88fd\u3092\u5f37\u5236\u3057\u307e\u3059\u3002\n\n\nThe notifications have no IDs so you\u2019ll have a race condition if you show two notifications fast enough. When the first timeout finishes, it will dispatch HIDE_NOTIIFICATION, erroneously hiding the second notification sooner than after the timeout.\n\n\n\u3082\u3057\u3001\u3042\u306a\u305f\u304c\u5341\u5206\u306a\u65e9\u3055\u3067\uff12\u3064\u306e\u901a\u77e5\u3092\u8868\u793a\u3055\u305b\u305f\u3089\u3001\u305d\u306e\u901a\u77e5\u306fID\u3092\u6301\u3063\u3066\u3044\u306a\u3044\u306e\u3067\u3001\u7af6\u5408\u72b6\u614b\u306b\u306a\u308b\u3067\u3057\u3087\u3046\u3002\u6700\u521d\u306e\u30bf\u30a4\u30e0\u30a2\u30a6\u30c8\u304c\u5b8c\u4e86\u3057\u305f\u3068\u304d\u3001HIDE_NOTIFICATION\u304c\u30c7\u30a3\u30b9\u30d1\u30c3\u30c1\u3055\u308c\u307e\u3059\u3002\u305d\u3057\u3066\u3001\u305d\u308c\u306f\u8aa4\u3063\u3066\u30bf\u30a4\u30e0\u30a2\u30a6\u30c8\u5f8c\u3088\u308a\u65e9\u30442\u3064\u76ee\u306e\u901a\u77e5\u3092\u96a0\u3057\u307e\u3059\u3002\n\n\nTo solve these problems, you would need to extract a function that centralizes the timeout logic and dispatches those two actions. It might look like this:\n\n\u3053\u308c\u3089\u306e\u554f\u984c\u3092\u89e3\u6c7a\u3059\u308b\u305f\u3081\u306b\u3001\u3042\u306a\u305f\u306f\u30bf\u30a4\u30e0\u30a2\u30a6\u30c8\u306e\u30ed\u30b8\u30c3\u30af\u30682\u3064\u306e\u30a2\u30af\u30b7\u30e7\u30f3\u3078\u306e\u30c7\u30a3\u30b9\u30d1\u30c3\u30c1\u3092\u96c6\u3081\u305f\u6a5f\u80fd\u3092\u62bd\u51fa\u3059\u308b\u5fc5\u8981\u304c\u3042\u308a\u307e\u3059\u3002\n// actions.js\nfunction showNotification(id, text) {\n  return { type: 'SHOW_NOTIFICATION', id, text }\n}\nfunction hideNotification(id) {\n  return { type: 'HIDE_NOTIFICATION', id }\n}\n\nlet nextNotificationId = 0\nexport function showNotificationWithTimeout(dispatch, text) {\n  // Assigning IDs to notifications lets reducer ignore HIDE_NOTIFICATION\n  // for the notification that is not currently visible.\n  // Alternatively, we could store the interval ID and call\n  // clearInterval(), but we\u2019d still want to do it in a single place.\n  const id = nextNotificationId++\n  dispatch(showNotification(id, text))\n\n  setTimeout(() => {\n    dispatch(hideNotification(id))\n  }, 5000)\n}\n\n\nNow components can use showNotificationWithTimeout without duplicating this logic or having race conditions with different notifications:\n\n\u3053\u306e\u30b3\u30f3\u30dd\u30fc\u30cd\u30f3\u30c8\u306f\u30ed\u30b8\u30c3\u30af\u306e\u91cd\u8907\u3084\u7570\u306a\u308b\u901a\u77e5\u306e\u7af6\u5408\u72b6\u614b\u306a\u3057\u306bshowNotificationWithTimeout\u3092\u5229\u7528\u3059\u308b\u3053\u3068\u304c\u3067\u304d\u307e\u3059\u3002\n// component.js\nshowNotificationWithTimeout(this.props.dispatch, 'You just logged in.')\n\n// otherComponent.js\nshowNotificationWithTimeout(this.props.dispatch, 'You just logged out.')\n\n\nWhy does showNotificationWithTimeout() accept dispatch as the first argument? Because it needs to dispatch actions to the store. Normally a component has access to dispatch but since we want an external function to take control over dispatching, we need to give it control over dispatching.\n\n\u306a\u305c\u6700\u521d\u306e\u5f15\u6570\u3068\u3057\u3066showNotificationWithTimeout()\u3067dispatch\u3092\u53d7\u3051\u5165\u308c\u3066\u3044\u308b\u306e\u3067\u3057\u3087\u3046\u304b\u3002\u305d\u308c\u306fstore\u306b\u30a2\u30af\u30b7\u30e7\u30f3\u3092\u30c7\u30a3\u30b9\u30d1\u30c3\u30c1\u3059\u308b\u5fc5\u8981\u304c\u3042\u308b\u305f\u3081\u3067\u3059\u3002\u901a\u5e38\u3001\u30b3\u30f3\u30dd\u30fc\u30cd\u30f3\u30c8\u306f\u30c7\u30a3\u30b9\u30d1\u30c3\u30c1\u306b\u30a2\u30af\u30bb\u30b9\u3059\u308b\u6a29\u9650\u3092\u6301\u3063\u3066\u3044\u307e\u3059\u304c\u3001\u79c1\u305f\u3061\u306f\u5916\u90e8\u306e\u6a5f\u80fd\u306b\u30c7\u30a3\u30b9\u30d1\u30c3\u30c1\u306e\u30b3\u30f3\u30c8\u30ed\u30fc\u30eb\u3092\u6301\u3063\u3066\u3082\u3089\u3044\u305f\u3044\u306e\u3067\u3001\u30c7\u30a3\u30b9\u30d1\u30c3\u30c1\u306e\u30b3\u30f3\u30c8\u30ed\u30fc\u30eb\u3092\u4e0e\u3048\u308b\u5fc5\u8981\u304c\u3042\u308a\u307e\u3059\u3002\n\nIf you had a singleton store exported from some module, you could just import it and dispatch directly on it instead:\n\n\u3082\u3057\u3001\u3042\u306a\u305f\u304c\u30e2\u30b8\u30e5\u30fc\u30eb\u304b\u3089\u30a8\u30af\u30b9\u30dd\u30fc\u30c8\u3055\u308c\u305f\u30b7\u30f3\u30b0\u30eb\u30c8\u30f3\u306estore\u3092\u6301\u3063\u3066\u3044\u305f\u3089\u3001\u3042\u306a\u305f\u306f\u305d\u308c\u3092\u30a4\u30f3\u30dd\u30fc\u30c8\u3057\u3001\u76f4\u63a5\u30c7\u30a3\u30b9\u30d1\u30c3\u30c1\u3067\u304d\u307e\u3059\u3002\n// store.js\nexport default createStore(reducer)\n\n// actions.js\nimport store from './store'\n\n// ...\n\nlet nextNotificationId = 0\nexport function showNotificationWithTimeout(text) {\n  const id = nextNotificationId++\n  store.dispatch(showNotification(id, text))\n\n  setTimeout(() => {\n    store.dispatch(hideNotification(id))\n  }, 5000)\n}\n\n// component.js\nshowNotificationWithTimeout('You just logged in.')\n\n// otherComponent.js\nshowNotificationWithTimeout('You just logged out.') \n\n\nThis looks simpler but we don\u2019t recommend this approach. The main reason we dislike it is because it forces store to be a singleton. This makes it very hard to implement server rendering. On the server, you will want each request to have its own store, so that different users get different preloaded data.\n\n\u3053\u308c\u306f\u4e00\u898b\u5358\u7d14\u3067\u3059\u304c\u3001\u79c1\u305f\u3061\u306f\u3053\u306e\u30a2\u30d7\u30ed\u30fc\u30c1\u3092\u63a8\u5968\u3057\u307e\u305b\u3093\u3002\u4e3b\u306a\u7406\u7531\u306fstore\u304c\u30b7\u30f3\u30b0\u30eb\u30c8\u30f3\u3067\u3042\u308b\u3053\u3068\u3092\u5f37\u5236\u3059\u308b\u306e\u3092\u5acc\u3046\u304b\u3089\u3067\u3059\u3002\u3053\u308c\u306f\u30b5\u30fc\u30d0\u30fc\u306e\u30ec\u30f3\u30c0\u30ea\u30f3\u30b0\u3092\u5b9f\u88c5\u3059\u308b\u3053\u3068\u304c\u975e\u5e38\u306b\u96e3\u3057\u304f\u306a\u308a\u307e\u3059\u3002\u30b5\u30fc\u30d0\u30fc\u4e0a\u3067\u3042\u306a\u305f\u306f\u5404\u3005\u306e\u30ea\u30af\u30a8\u30b9\u30c8\u304c\u305d\u308c\u81ea\u8eab\u306estore\u3092\u3082\u3064\u3053\u3068\u3092\u671b\u307f\u3001\u305d\u306e\u7d50\u679c\u3001\u30e6\u30fc\u30b6\u306f\u7570\u306a\u3063\u305f\u4e8b\u524d\u30ed\u30fc\u30c9\u30c7\u30fc\u30bf\u3092\u53d6\u5f97\u3057\u307e\u3059\u3002\n\nA singleton store also makes testing harder. You can no longer mock a store when testing action creators because they reference a specific real store exported from a specific module. You can\u2019t even reset its state from outside.\n\n\u30b7\u30f3\u30b0\u30eb\u30c8\u30f3\u306estore\u306f\u30c6\u30b9\u30c8\u3082\u307e\u305f\u96e3\u3057\u304f\u306a\u308a\u307e\u3059\u3002\u3042\u306a\u305f\u306f\u30a2\u30af\u30b7\u30e7\u30f3\u30af\u30ea\u30a8\u30fc\u30bf\u30fc\u3092\u30c6\u30b9\u30c8\u3059\u308b\u3068\u304d\u3082\u306f\u3084store\u3092\u30e2\u30c3\u30af\u5316\u3067\u304d\u307e\u305b\u3093\u3002\u306a\u305c\u306a\u3089\u3001\u305d\u308c\u3089\u306f\u7279\u5b9a\u306e\u30e2\u30b8\u30e5\u30fc\u30eb\u304b\u3089\u30a8\u30af\u30b9\u30dd\u30fc\u30c8\u3055\u308c\u305f\u7279\u5b9a\u306e\u30b9\u30c8\u30a2\u3092\u53c2\u7167\u3057\u3066\u3044\u308b\u304b\u3089\u3067\u3059\u3002\u3042\u306a\u305f\u306f\u5916\u5074\u304b\u3089\u72b6\u614b\u3092\u30ea\u30bb\u30c3\u30c8\u3059\u308b\u3053\u3068\u3055\u3048\u3067\u304d\u307e\u305b\u3093\u3002\n\nSo while you technically can export a singleton store from a module, we discourage it. Don\u2019t do this unless you are sure that your app will never add server rendering.\n\n\u305d\u3057\u3066\u3001\u30e2\u30b8\u30e5\u30fc\u30eb\u304b\u3089\u30b7\u30f3\u30b0\u30eb\u30c8\u30f3\u306estore\u3092\u6280\u8853\u7684\u306b\u30a8\u30af\u30b9\u30dd\u30fc\u30c8\u3067\u304d\u308b\u9593\u3001\u79c1\u305f\u3061\u306f\u305d\u308c\u3092\u963b\u6b62\u3057\u307e\u3059\u3002\u3042\u306a\u305f\u306e\u30a2\u30d7\u30ea\u304c\u6c7a\u3057\u3066\u30ec\u30f3\u30c0\u30ea\u30f3\u30b0\u3092\u8ffd\u52a0\u3057\u306a\u3044\u3068\u78ba\u4fe1\u3057\u3066\u306a\u3044\u9650\u308a\u3053\u308c\u3092\u3084\u3063\u3066\u306f\u3044\u3051\u307e\u305b\u3093\u3002\n\nGetting back to the previous version:\n\n\u524d\u306e\u30d0\u30fc\u30b8\u30e7\u30f3\u306b\u623b\u308a\u307e\u3057\u3087\u3046\u3002\n// actions.js\n\n// ...\n\nlet nextNotificationId = 0\nexport function showNotificationWithTimeout(dispatch, text) {\n  const id = nextNotificationId++\n  dispatch(showNotification(id, text))\n\n  setTimeout(() => {\n    dispatch(hideNotification(id))\n  }, 5000)\n}\n\n// component.js\nshowNotificationWithTimeout(this.props.dispatch, 'You just logged in.')\n\n// otherComponent.js\nshowNotificationWithTimeout(this.props.dispatch, 'You just logged out.')    \n\n\nThis solves the problems with duplication of logic and saves us from race conditions.\n\n\u3053\u308c\u306f\u30ed\u30b8\u30c3\u30af\u306e\u8907\u88fd\u306e\u554f\u984c\u3092\u89e3\u6c7a\u3057\u3001\u7af6\u5408\u72b6\u614b\u304b\u3089\u79c1\u305f\u3061\u3092\u6551\u3044\u307e\u3059\u3002\n\nThunk Middleware\n\nThunk\u30df\u30c9\u30eb\u30a6\u30a7\u30a2\n\nFor simple apps, the approach should suffice. Don\u2019t worry about middleware if you\u2019re happy with it.\n\n\u30b7\u30f3\u30d7\u30eb\u306a\u30a2\u30d7\u30ea\u30b1\u30fc\u30b7\u30e7\u30f3\u306e\u5834\u5408\u3001\u3053\u308c\u307e\u3067\u306e\u30a2\u30d7\u30ed\u30fc\u30c1\u3067\u5341\u5206\u3067\u3059\u3002\u3042\u306a\u305f\u304c\u6e80\u8db3\u3057\u3066\u3044\u308b\u306a\u3089\u3001\u30df\u30c9\u30eb\u30a6\u30a7\u30a2\u306e\u5fc3\u914d\u306f\u3057\u306a\u3044\u3067\u304f\u3060\u3055\u3044\u3002\n\nIn larger apps, however, you might find certain inconveniences around it.\n\n\u3057\u304b\u3057\u5927\u304d\u306a\u30a2\u30d7\u30ea\u30b1\u30fc\u30b7\u30e7\u30f3\u306e\u5834\u5408\u3001\u3042\u306a\u305f\u306f\u305d\u306e\u30a2\u30d7\u30ed\u30fc\u30c1\u306b\u4e0d\u4fbf\u306a\u90e8\u5206\u3092\u898b\u3064\u3051\u308b\u304b\u3082\u3057\u308c\u307e\u305b\u3093\u3002\n\nFor example, it seems unfortunate that we have to pass dispatch around. This makes it trickier to separate container and presentational components because any component that dispatches Redux actions asynchronously in the manner above has to accept dispatch as a prop so it can pass it further. You can\u2019t just bind action creators with connect() anymore because showNotificationWithTimeout() is not really an action creator. It does not return a Redux action.\n\n\u4f8b\u3048\u3070\u3001\u30c7\u30a3\u30b9\u30d1\u30c3\u30c1\u3092\u6301\u3061\u56de\u3059\u3053\u3068\u306f\u6b8b\u5ff5\u306b\u611f\u3058\u307e\u3059\u3002Redux\u30a2\u30af\u30b7\u30e7\u30f3\u3092\u975e\u540c\u671f\u306b\u30c7\u30a3\u30b9\u30d1\u30c3\u30c1\u3059\u308b\u4efb\u610f\u306e\u30b3\u30f3\u30dd\u30fc\u30cd\u30f3\u30c8\u306f\u3001\u30c7\u30a3\u30b9\u30d1\u30c3\u30c1\u3092\u3055\u3089\u306b\u6e21\u305b\u308b\u3088\u3046\u306bprop\u3068\u3057\u3066\u30c7\u30a3\u30b9\u30d1\u30c3\u30c1\u3092\u8a31\u53ef\u3059\u308b\u306e\u3067\u3001\u30b3\u30f3\u30c6\u30ca\u3068\u30d7\u30ec\u30bc\u30f3\u30c6\u30fc\u30b7\u30e7\u30f3\u30b3\u30f3\u30dd\u30fc\u30cd\u30f3\u30c8\u306b\u5206\u96e2\u3059\u308b\u3053\u3068\u3092\u3088\u308a\u96e3\u3057\u304f\u3059\u308b\u3002showNotificationWithTimeout()\u306f\u5b9f\u969b\u306e\u30a2\u30af\u30b7\u30e7\u30f3\u30af\u30ea\u30a8\u30fc\u30bf\u3067\u306f\u306a\u3044\u306e\u3067\u3001\u3042\u306a\u305f\u306f\u3082\u306f\u3084\u30a2\u30af\u30b7\u30e7\u30f3\u30af\u30ea\u30a8\u30fc\u30bf\u3092\u30d0\u30a4\u30f3\u30c9\u3059\u308b\u3053\u3068\u306f\u3067\u304d\u307e\u305b\u3093\u3002\u305d\u308c\u306fRedux\u30a2\u30af\u30b7\u30e7\u30f3\u3092\u8fd4\u3057\u307e\u305b\u3093\u3002\n\nIn addition, it can be awkward to remember which functions are synchronous action creators like showNotification() and which are asynchronous helpers like showNotificationWithTimeout(). You have to use them differently and be careful not to mistake them with each other.\n\n\u3055\u3089\u306b\u3001showNotification()\u306e\u3088\u3046\u306a\u540c\u671f\u30a2\u30af\u30b7\u30e7\u30f3\u30af\u30ea\u30a8\u30fc\u30bf\u30fc\u306e\u6a5f\u80fd\u3068showNotificationWithTimeout()\u306e\u3088\u3046\u975e\u540c\u671f\u306a\u30d8\u30eb\u30d1\u30fc\u3092\u899a\u3048\u308b\u306e\u306f\u5384\u4ecb\u306a\u3053\u3068\u304b\u3082\u3057\u308c\u307e\u305b\u3093\u3002\u3042\u306a\u305f\u306f\u3001\u305d\u308c\u3089\u3092\u4e92\u3044\u306b\u9593\u9055\u3048\u306a\u3044\u3088\u3046\u306b\u6ce8\u610f\u3057\u3001\u5225\u3005\u306b\u4f7f\u7528\u3057\u306a\u3051\u308c\u3070\u306a\u308a\u307e\u305b\u3093\u3002\n\nThis was the motivation for finding a way to \u201clegitimize\u201d this pattern of providing dispatch to a helper function, and help Redux \u201csee\u201d such asynchronous action creators as a special case of normal action creators rather than totally different functions.\nIf you\u2019re still with us and you also recognize as a problem in your app, you are welcome to use the Redux Thunk middleware.\n\n\u3082\u3057\u3001\u3042\u306a\u305f\u304c\u307e\u3060\u79c1\u305f\u3061\u3068\u3042\u306a\u305f\u306e\u30a2\u30d7\u30ea\u306e\u554f\u984c\u3068\u3057\u3066\u8a8d\u8b58\u3059\u308b\u306a\u3089\u3001\u3042\u306a\u305f\u306fRedux-Thunk\u30df\u30c9\u30eb\u30a6\u30a7\u30a2\u3092\u5229\u7528\u3067\u304d\u307e\u3059\u3002\n\nIn a gist, Redux Thunk teaches Redux to recognize special kinds of actions that are in fact functions:\n\n\u8981\u3059\u308b\u306b\u3001Redux-thunk\u306fRedux\u306b\u5b9f\u969b\u306e\u95a2\u6570\u3067\u3042\u308b\u30a2\u30af\u30b7\u30e7\u30f3\u306e\u7279\u5225\u306a\u7a2e\u985e\u3092\u8a8d\u8b58\u3059\u308b\u3053\u3068\u3092\u6559\u3048\u307e\u3059\u3002\nimport { createStore, applyMiddleware } from 'redux'\nimport thunk from 'redux-thunk'\n\nconst store = createStore(\n  reducer,\n  applyMiddleware(thunk)\n)\n\n// It still recognizes plain object actions\nstore.dispatch({ type: 'INCREMENT' })\n\n// But with thunk middleware, it also recognizes functions\nstore.dispatch(function (dispatch) {\n  // ... which themselves may dispatch many times\n  dispatch({ type: 'INCREMENT' })\n  dispatch({ type: 'INCREMENT' })\n  dispatch({ type: 'INCREMENT' })\n\n  setTimeout(() => {\n    // ... even asynchronously!\n    dispatch({ type: 'DECREMENT' })\n  }, 1000)\n})\n\n\nWhen this middleware is enabled, if you dispatch a function, Redux Thunk middleware will give it dispatch as an argument. It will also \u201cswallow\u201d such actions so don\u2019t worry about your reducers receiving weird function arguments. Your reducers will only receive plain object actions\u2014either emitted directly, or emitted by the functions as we just described.\n\n\u3053\u306e\u30df\u30c9\u30eb\u30a6\u30a7\u30a2\u304c\u6709\u52b9\u306a\u3068\u304d\u3001\u3082\u3057\u3042\u306a\u305f\u304c\u30e1\u30bd\u30c3\u30c9\u3092\u30c7\u30a3\u30b9\u30d1\u30c3\u30c1\u3059\u308b\u306a\u3089\u3001Redux-Thunk\u30df\u30c9\u30eb\u30a6\u30a7\u30a2\u306f\u5f15\u6570\u3068\u3057\u3066dispatch\u3092\u4e0e\u3048\u307e\u3059\u3002\u305d\u306e\u3088\u3046\u306a\u30a2\u30af\u30b7\u30e7\u30f3\u3092\u300c\u98f2\u307f\u8fbc\u3080\u300d\u306e\u3067\u3001\u5947\u5999\u306a\u30e1\u30bd\u30c3\u30c9\u306e\u5f15\u6570\u3092\u53d7\u3051\u53d6\u308b\u3042\u306a\u305f\u306ereducer\u306b\u3064\u3044\u3066\u5fc3\u914d\u3042\u308a\u307e\u305b\u3093\u3002\u3042\u306a\u305f\u306ereducer\u306f\u76f4\u63a5\u4f5c\u6210\u3055\u308c\u305f\u304b\u3001\u5f8c\u8ff0\u3059\u308b\u95a2\u6570\u306b\u3088\u3063\u3066\u4f5c\u6210\u3055\u308c\u305f\u304b\u3057\u305f\u30d7\u30ec\u30fc\u30f3\u30aa\u30d6\u30b8\u30a7\u30af\u30c8\u3060\u3051\u3092\u53d7\u3051\u53d6\u308b\u3067\u3057\u3087\u3046\u3002\n\nThis does not look very useful, does it? Not in this particular situation. However it lets us declare showNotificationWithTimeout() as a regular Redux action creator:\n\n\u3053\u308c\u306f\u3042\u307e\u308a\u6709\u76ca\u306b\u898b\u3048\u307e\u305b\u3093\u306d\u3002\u7279\u5b9a\u306e\u72b6\u6cc1\u3067\u306f\u3042\u308a\u307e\u305b\u3093\u3002\u3057\u304b\u3057\u3001showNotificationWithTimeout()\u3092\u901a\u5e38\u306eRedux\u30a2\u30af\u30b7\u30e7\u30f3\u30af\u30ea\u30a8\u30fc\u30bf\u3068\u3057\u3066\u5b9a\u7fa9\u3057\u307e\u3057\u3087\u3046\u3002\n// actions.js\nfunction showNotification(id, text) {\n  return { type: 'SHOW_NOTIFICATION', id, text }\n}\nfunction hideNotification(id) {\n  return { type: 'HIDE_NOTIFICATION', id }\n}\n\nlet nextNotificationId = 0\nexport function showNotificationWithTimeout(text) {\n  return function (dispatch) {\n    const id = nextNotificationId++\n    dispatch(showNotification(id, text))\n\n    setTimeout(() => {\n      dispatch(hideNotification(id))\n    }, 5000)\n  }\n}\n\n\nNote how the function is almost identical to the one we wrote in the previous section. However it doesn\u2019t accept dispatch as the first argument. Instead it returns a function that accepts dispatch as the first argument.\n\n\u95a2\u6570\u306f\u524d\u7bc0\u306b\u66f8\u3044\u305f\u3082\u306e\u3068\u307b\u307c\u540c\u3058\u3067\u3042\u308b\u304b\u306b\u6ce8\u610f\u3057\u3066\u304f\u3060\u3055\u3044\u3002\u3057\u304b\u3057\u3001\u6700\u521d\u306e\u5f15\u6570\u3068\u3057\u3066dispatch\u304c\u8a31\u53ef\u3055\u308c\u3066\u3044\u307e\u305b\u3093\u3002\u4ee3\u308f\u308a\u306b\u6700\u521d\u306e\u5f15\u6570\u3068\u3057\u3066dispatch\u3092\u8a31\u53ef\u3059\u308b\u95a2\u6570\u3092\u8fd4\u5374\u3057\u307e\u3059\u3002\n\nHow would we use it in our component? Definitely, we could write this:\n\n\u3069\u306e\u3088\u3046\u306b\u79c1\u305f\u3061\u306e\u30b3\u30f3\u30dd\u30fc\u30cd\u30f3\u30c8\u3092\u5229\u7528\u3059\u308b\u306e\u3067\u3057\u3087\u3046\u304b\u3002\u79c1\u305f\u3061\u306f\u3053\u308c\u3092\u66f8\u304f\u3053\u3068\u304c\u3067\u304d\u307e\u3059:\n// component.js\nshowNotificationWithTimeout('You just logged in.')(this.props.dispatch)\n\n\nWe are calling the async action creator to get the inner function that wants just dispatch, and then we pass dispatch.\n\n\u79c1\u305f\u3061\u306fdispatch\u3092\u671b\u3080\u5185\u90e8\u95a2\u6570\u3092\u53d6\u5f97\u3059\u308b\u305f\u3081\u306e\u975e\u540c\u671f\u30a2\u30af\u30b7\u30e7\u30f3\u30af\u30ea\u30a8\u30fc\u30bf\u3092\u547c\u3073\u307e\u3059\u3002\u305d\u3057\u3066\u305d\u306e\u3068\u304d\u79c1\u305f\u3061\u306fdispatch\u3092\u6e21\u3057\u307e\u3059\u3002\n\nHowever this is even more awkward than the original version! Why did we even go that way?\n\n\u3057\u304b\u3057\u3053\u308c\u306f\u5143\u306e\u30d0\u30fc\u30b8\u30e7\u30f3\u3088\u308a\u5384\u4ecb\u3067\u3059\u3002\u306a\u305c\u79c1\u305f\u3061\u306f\u305d\u306e\u65b9\u5411\u306b\u884c\u3063\u305f\u306e\u3067\u3057\u3087\u3046\u304b\u3002\n\nBecause of what I told you before. If Redux Thunk middleware is enabled, any time you attempt to dispatch a function instead of an action object, the middleware will call that function with dispatch method itself as the first argument.\n\n\u79c1\u304c\u524d\u306b\u3042\u306a\u305f\u306b\u8a00\u3063\u305f\u3053\u3068\u306e\u305f\u3081\u3067\u3059\u3002\u3082\u3057Redux-Thunk\u30df\u30c9\u30eb\u30a6\u30a7\u30a2\u304c\u6709\u52b9\u306a\u3089\u3001\u3044\u3064\u3067\u3082\u3042\u306a\u305f\u306f\u30a2\u30af\u30b7\u30e7\u30f3\u30aa\u30d6\u30b8\u30a7\u30af\u30c8\u306e\u4ee3\u308f\u308a\u306b\u95a2\u6570\u3092\u30c7\u30a3\u30b9\u30d1\u30c3\u30c1\u3059\u308b\u3053\u3068\u3092\u8a66\u307f\u307e\u3059\u3002\u305d\u306e\u30df\u30c9\u30eb\u30a6\u30a7\u30a2\u306f\u6700\u521d\u306e\u5f15\u6570\u3068\u3057\u3066\u30c7\u30a3\u30b9\u30d1\u30c3\u30c1\u95a2\u6570\u81ea\u8eab\u3067\u95a2\u6570\u3092\u547c\u3073\u51fa\u3057\u307e\u3059\u3002\n\nSo we can do this instead:\n\n\u3060\u304b\u3089\u4ee3\u308f\u308a\u306b\u3053\u308c\u3092\u884c\u3044\u307e\u3059\u3002\n// component.js\nthis.props.dispatch(showNotificationWithTimeout('You just logged in.'))\n\n\nFinally, dispatching an asynchronous action (really, a series of actions) looks no different than dispatching a single action synchronously to the component. Which is good because components shouldn\u2019t care whether something happens synchronously or asynchronously. We just abstracted that away.\n\n\u975e\u540c\u671f\u306e\u30a2\u30af\u30b7\u30e7\u30f3(\u5b9f\u969b\u306b\u306f\u3001\u4e00\u9023\u306e\u30a2\u30af\u30b7\u30e7\u30f3)\u306f\u3001\u30b3\u30f3\u30dd\u30fc\u30cd\u30f3\u30c8\u306b\u540c\u671f\u7684\u306b\u30c7\u30a3\u30b9\u30d1\u30c3\u30c1\u3059\u308b\u5358\u4e00\u306e\u30a2\u30af\u30b7\u30e7\u30f3\u3068\u5909\u308f\u3063\u3066\u898b\u3048\u307e\u305b\u3093\u3002\u305d\u308c\u306f\u30b3\u30f3\u30dd\u30fc\u30cd\u30f3\u30c8\u304c\u306a\u306b\u304b\u304c\u540c\u671f\u7684\u3042\u308b\u3044\u306f\u975e\u540c\u671f\u7684\u306b\u767a\u751f\u3057\u305f\u304b\u3092\u6c17\u306b\u3059\u308b\u3079\u304d\u3067\u306f\u306a\u3044\u306e\u3067\u3088\u3044\u3053\u3068\u3067\u3059\u3002\u79c1\u305f\u3061\u306f\u307e\u3055\u306b\u305d\u308c\u3092\u62bd\u8c61\u5316\u3057\u307e\u3057\u305f\u3002\n\nNotice that since we \u201ctaught\u201d Redux to recognize such \u201cspecial\u201d action creators (we call them thunk action creators), we can now use them in any place where we would use regular action creators. For example, we can use them with connect():\n\n\u79c1\u305f\u3061\u306f\u305d\u306e\u3088\u3046\u306a\u300c\u7279\u5225\u300d\u306e\u30a2\u30af\u30b7\u30e7\u30f3\u30af\u30ea\u30a8\u30fc\u30bf\u3092\u7406\u89e3\u3059\u308b\u3088\u3046\u306bRedux\u306b\u300c\u6559\u3048\u305f\u300d(\u305d\u308c\u3089\u3092thunk\u30a2\u30af\u30b7\u30e7\u30f3\u30af\u30ea\u30a8\u30fc\u30bf\u3068\u547c\u3076)\u3068\u3044\u3046\u3053\u3068\u306b\u6ce8\u610f\u3057\u3066\u304f\u3060\u3055\u3044\u3002\u79c1\u305f\u3061\u306f\u901a\u5e38\u306e\u30a2\u30af\u30b7\u30e7\u30f3\u30af\u30ea\u30a8\u30fc\u30bf\u3092\u5229\u7528\u3059\u308b\u5834\u6240\u3067\u305d\u308c\u3089\u3092\u5229\u7528\u3059\u308b\u3053\u3068\u304c\u3067\u3067\u304d\u308b\u3002\u4f8b\u3048\u3070\u3001\u79c1\u305f\u3061\u306fconnect()\u3067\u305d\u308c\u3089\u3092\u5229\u7528\u3059\u308b\u3053\u3068\u304c\u3067\u304d\u307e\u3059\u3002\n// actions.js\n\nfunction showNotification(id, text) {\n  return { type: 'SHOW_NOTIFICATION', id, text }\n}\nfunction hideNotification(id) {\n  return { type: 'HIDE_NOTIFICATION', id }\n}\n\nlet nextNotificationId = 0\nexport function showNotificationWithTimeout(text) {\n  return function (dispatch) {\n    const id = nextNotificationId++\n    dispatch(showNotification(id, text))\n\n    setTimeout(() => {\n      dispatch(hideNotification(id))\n    }, 5000)\n  }\n}\n\n// component.js\n\nimport { connect } from 'react-redux'\n\n// ...\n\nthis.props.showNotificationWithTimeout('You just logged in.')\n\n// ...\n\nexport default connect(\n  mapStateToProps,\n  { showNotificationWithTimeout }\n)(MyComponent)\n\n\nReading State in Thunks\n\nthunk\u306e\u72b6\u614b\u3092\u8aad\u307f\u8fbc\u3080\n\nUsually your reducers contain the business logic for determining the next state. However, reducers only kick in after the actions are dispatched. What if you have a side effect (such as calling an API) in a thunk action creator, and you want to prevent it under some condition?\n\n\u901a\u5e38\u3042\u306a\u305f\u306ereducer\u306f\u6b21\u306e\u72b6\u614b\u3092\u6c7a\u5b9a\u3059\u308b\u305f\u3081\u306b\u30d3\u30b8\u30cd\u30b9\u30ed\u30b8\u30c3\u30af\u3092\u542b\u3093\u3067\u3044\u307e\u3059\u3002\u3057\u304b\u3057\u3001reducer\u306f\u30a2\u30af\u30b7\u30e7\u30f3\u304c\u30c7\u30a3\u30b9\u30d1\u30c3\u30c1\u3055\u308c\u305f\u3042\u3068\u306b\u3060\u3051\u30ad\u30c3\u30af\u3055\u308c\u307e\u3059\u3002\u4eee\u306b\u3042\u306a\u305f\u304cthunk\u30a2\u30af\u30b7\u30e7\u30f3\u30af\u30ea\u30a8\u30fc\u30bf\u3067\u526f\u4f5c\u7528(\u4f8b\u3048\u3070API\u3092\u547c\u3076\u3068\u304d)\u3092\u3082\u3063\u3066\u3044\u305f\u3089\u3001\u3044\u304f\u3064\u304b\u306e\u6761\u4ef6\u4e0b\u3067\u305d\u308c\u3092\u9632\u304e\u305f\u3044\u3067\u3059\u3002\nWithout using the thunk middleware, you\u2019d just do this check inside the component:\nthunk\u30df\u30c9\u30eb\u30a6\u30a7\u30a2\u3092\u4f7f\u7528\u305b\u305a\u306b\u3001\u3042\u306a\u305f\u306f\u307e\u3055\u306b\u30b3\u30f3\u30dd\u30fc\u30cd\u30f3\u30c8\u306e\u4e2d\u3092\u30c1\u30a7\u30c3\u30af\u3059\u308b\u3067\u3057\u3087\u3046\u3002\n// component.js\nif (this.props.areNotificationsEnabled) {\n  showNotificationWithTimeout(this.props.dispatch, 'You just logged in.')\n}\n\n\nHowever, the point of extracting an action creator was to centralize this repetitive logic across many components. Fortunately, Redux Thunk offers you a way to read the current state of the Redux store. In addition to dispatch, it also passes getState as the second argument to the function you return from your thunk action creator. This lets the thunk read the current state of the store.\n\n\u3057\u304b\u3057\u3001\u305d\u306e\u30a2\u30af\u30b7\u30e7\u30f3\u30af\u30ea\u30a8\u30fc\u30bf\u3092\u62bd\u51fa\u3059\u308b\u30dd\u30a4\u30f3\u30c8\u306f\u591a\u304f\u306e\u30b3\u30f3\u30dd\u30fc\u30cd\u30f3\u30c8\u3067\u7e70\u308a\u8fd4\u3057\u30ed\u30b8\u30c3\u30af\u3092\u96c6\u4e2d\u7ba1\u7406\u3059\u308b\u3053\u3068\u3067\u3057\u305f\u3002\u5e78\u3044\u306a\u3053\u3068\u306b\u3001Redux-thunk\u306f\u3042\u306a\u305f\u306bRedux\u306estore\u306e\u73fe\u5728\u306e\u72b6\u614b\u3092\u8aad\u307f\u51fa\u3059\u305f\u3081\u306e\u65b9\u6cd5\u3092\u63d0\u4f9b\u3057\u3066\u3044\u307e\u3059\u3002\u30c7\u30a3\u30b9\u30d1\u30c3\u30c1\u306b\u52a0\u3048\u3066\u3001\u3042\u306a\u305f\u306ethunk\u30a2\u30af\u30b7\u30e7\u30f3\u30af\u30ea\u30a8\u30fc\u30bf\u304b\u3089\u8fd4\u3059\u95a2\u6570\u306b\u7b2c\u4e8c\u5f15\u6570\u3068\u3057\u3066getState\u3082\u6e21\u3057\u307e\u3059\u3002thunk\u306bstore\u306e\u73fe\u5728\u306e\u72b6\u614b\u3092\u3088\u307f\u3053\u307e\u305b\u3066\u307f\u307e\u3057\u3087\u3046\u3002\nlet nextNotificationId = 0\nexport function showNotificationWithTimeout(text) {\n  return function (dispatch, getState) {\n    // Unlike in a regular action creator, we can exit early in a thunk\n    // Redux doesn\u2019t care about its return value (or lack of it)\n    if (!getState().areNotificationsEnabled) {\n      return\n    }\n\n    const id = nextNotificationId++\n    dispatch(showNotification(id, text))\n\n    setTimeout(() => {\n      dispatch(hideNotification(id))\n    }, 5000)\n  }\n}\n\n\nDon\u2019t abuse this pattern. It is good for bailing out of API calls when there is cached data available, but it is not a very good foundation to build your business logic upon. If you use getState() only to conditionally dispatch different actions, consider putting the business logic into the reducers instead.\n\n\u3053\u306e\u30d1\u30bf\u30fc\u30f3\u3092\u8aa4\u7528\u3057\u306a\u3044\u3067\u304f\u3060\u3055\u3044\u3002\u6709\u52b9\u306a\u30ad\u30e3\u30c3\u30b7\u30e5\u30c7\u30fc\u30bf\u304c\u3042\u308b\u6642\u306bAPI\u30b3\u30fc\u30eb\u306e\u6551\u6e08\u306b\u306f\u3088\u3044\u3067\u3059\u304c\u3001\u30d3\u30b8\u30cd\u30b9\u30ed\u30b8\u30c3\u30af\u3092\u69cb\u7bc9\u3059\u308b\u305f\u3081\u306e\u3088\u3044\u57fa\u76e4\u3067\u306f\u3042\u308a\u307e\u305b\u3093\u3002\u3082\u3057\u3001\u3042\u306a\u305f\u304cgetState()\u3092\u6761\u4ef6\u4ed8\u304d\u3067\u7570\u306a\u308b\u30a2\u30af\u30b7\u30e7\u30f3\u3092\u30c7\u30a3\u30b9\u30d1\u30c3\u30c1\u3059\u308b\u305f\u3081\u306b\u4f7f\u3046\u306a\u3089\u3001\u4ee3\u308f\u308a\u306breducer\u306e\u4e2d\u306b\u30d3\u30b8\u30cd\u30b9\u30ed\u30b8\u30c3\u30af\u3092\u7f6e\u304f\u3053\u3068\u3092\u691c\u8a0e\u3057\u3066\u304f\u3060\u3055\u3044\u3002\n\nNext Steps\n\n\u6b21\u306e\u30b9\u30c6\u30c3\u30d7(\u7701\u7565)\n\nNow that you have a basic intuition about how thunks work, check out Redux async example which uses them.\nYou may find many examples in which thunks return Promises. This is not required but can be very convenient. Redux doesn\u2019t care what you return from a thunk, but it gives you its return value from dispatch(). This is why you can return a Promise from a thunk and wait for it to complete by calling dispatch(someThunkReturningPromise()).then(...).\nYou may also split complex thunk action creators into several smaller thunk action creators. The dispatch method provided by thunks can accept thunks itself, so you can apply the pattern recursively. Again, this works best with Promises because you can implement asynchronous control flow on top of that.\nFor some apps, you may find yourself in a situation where your asynchronous control flow requirements are too complex to be expressed with thunks. For example, retrying failed requests, reauthorization flow with tokens, or a step-by-step onboarding can be too verbose and error-prone when written this way. In this case, you might want to look at more advanced asynchronous control flow solutions such as Redux Saga or Redux Loop. Evaluate them, compare the examples relevant to your needs, and pick the one you like the most.\nFinally, don\u2019t use anything (including thunks) if you don\u2019t have the genuine need for them. Remember that, depending on the requirements, your solution might look as simple as\n\nstore.dispatch({ type: 'SHOW_NOTIFICATION', text: 'You logged in.' })\nsetTimeout(() => {\n  store.dispatch({ type: 'HIDE_NOTIFICATION' })\n}, 5000)\n\n\nDon\u2019t sweat it unless you know why you\u2019re doing this.\n\n# \u52d5\u6a5f\n\n\u5b66\u751f\u6642\u4ee3\u306f\u82f1\u8a9e\u304c\u4e00\u756a\u82e6\u624b\u3067\u3057\u305f\u304c\u3001\u3044\u307e\u3044\u3061redux-thunk\u304c\u7406\u89e3\u3067\u304d\u306a\u304b\u3063\u305f\u306e\u3067\u9811\u5f35\u3063\u3066\u7ffb\u8a33\u3057\u307e\u3057\u305f\u3002\u304a\u304b\u3057\u306a\u8a33\u304c\u3042\u308c\u3070\u3054\u6307\u6458\u304f\u3060\u3055\u3044\u3002\u307e\u305f\u3001\u5206\u304b\u3089\u306a\u3044\u3068\u3053\u308d\u306f\u539f\u6587\u306e\u8a00\u8449\u3092\u4f7f\u3046\u304b\u7701\u7565\u3057\u3066\u304a\u308a\u307e\u3059\u306e\u3067\u3054\u4e86\u627f\u304f\u3060\u3055\u3044\u3002\n\n\u5143\u8a18\u4e8b:\nhttp://stackoverflow.com/questions/35411423/how-to-dispatch-a-redux-action-with-a-timeout/35415559#35415559\n\n# \u7ffb\u8a33\n\n>Writing Async Code Inline\n\n**\u975e\u540c\u671f\u30b3\u30fc\u30c9\u306b\u3064\u3044\u3066\u66f8\u304f**\n\n>This is by far the simplest way. And there\u2019s nothing specific to Redux here.\n\n\u3053\u308c\u306f\u6700\u3082\u7c21\u5358\u306a\u65b9\u6cd5\u3067\u3059\u3002\u305d\u3057\u3066\u3001\u3053\u308c\u306fRedux\u56fa\u6709\u306e\u3082\u306e\u3067\u306f\u3042\u308a\u307e\u305b\u3093\u3002\n\n```js\nstore.dispatch({ type: 'SHOW_NOTIFICATION', text: 'You logged in.' })\nsetTimeout(() => {\n  store.dispatch({ type: 'HIDE_NOTIFICATION' })\n}, 5000)\n```\n> Similarly, from inside a connected component:\n\n\u540c\u69d8\u306b\u300ca connected component\u300d\u306e\u5185\u5074\u304b\u3089\n\n```js\nthis.props.dispatch({ type: 'SHOW_NOTIFICATION', text: 'You logged in.' })\nsetTimeout(() => {\n  this.props.dispatch({ type: 'HIDE_NOTIFICATION' })\n}, 5000)\n```\n\n>The only difference is that in a connected component you usually don\u2019t have access to the store itself, but get either dispatch() or specific action creators injected as props. However this doesn\u2019t make any difference for us.\n\n\u552f\u4e00\u306e\u9055\u3044\u306f\u3001\u300ca connected component\u300d\u306e\u4e2d\u3067\u306f\u3042\u306a\u305f\u306f\u901a\u5e38store\u81ea\u4f53\u306b\u30a2\u30af\u30bb\u30b9\u3067\u304d\u307e\u305b\u3093\u304c\u3001dispatch()\u304bprops\u3068\u3057\u3066\u6ce8\u5165\u3055\u308c\u305f\u7279\u5b9a\u306e\u30a2\u30af\u30b7\u30e7\u30f3\u30af\u30ea\u30a8\u30fc\u30bf\u30fc\u306e\u3044\u305a\u308c\u304b\u3092\u53d6\u5f97\u3059\u308b\u3053\u3068\u3067\u3059\u3002\u3057\u304b\u3057\u3001\u79c1\u305f\u3061\u306b\u3068\u3063\u3066\u9055\u3044\u306f\u3042\u308a\u307e\u305b\u3093\u3002\n\n> If you don\u2019t like making typos when dispatching the same actions from different components, you might want to extract action creators instead of dispatching action objects inline:\n\n\u3082\u3057\u3001\u3042\u306a\u305f\u304c\u7570\u306a\u308b\u30b3\u30f3\u30dd\u30fc\u30cd\u30f3\u30c8\u304b\u3089\u540c\u3058\u30a2\u30af\u30b7\u30e7\u30f3\u306b\u30c7\u30a3\u30b9\u30d1\u30c3\u30c1\u3059\u308b\u3068\u304d\u306e\u30bf\u30a4\u30d7\u30df\u30b9\u3092\u6c17\u306b\u98df\u308f\u306a\u3044\u306a\u3089\u3070\u3001\u30c7\u30a3\u30b9\u30d1\u30c3\u30c1\u3059\u308b\u30a2\u30af\u30b7\u30e7\u30f3\u30aa\u30d6\u30b8\u30a7\u30af\u30c8\u306e\u4ee3\u308f\u308a\u306b\u30a2\u30af\u30b7\u30e7\u30f3\u30af\u30ea\u30a8\u30fc\u30bf\u3092\u62bd\u51fa\u3059\u308b\u3053\u3068\u304c\u3067\u304d\u307e\u3059\u3002\n\n```js\n// actions.js\nexport function showNotification(text) {\n  return { type: 'SHOW_NOTIFICATION', text }\n}\nexport function hideNotification() {\n  return { type: 'HIDE_NOTIFICATION' }\n}\n\n// component.js\nimport { showNotification, hideNotification } from '../actions'\n\nthis.props.dispatch(showNotification('You just logged in.'))\nsetTimeout(() => {\n  this.props.dispatch(hideNotification())\n}, 5000)\n```\n\n> Or, if you have previously bound them with connect():\n\n\u307e\u305f\u3001\u3042\u306a\u305f\u304c\u4ee5\u524dconnect()\u3092\u4f7f\u3063\u3066\u305d\u308c\u3089\u3092\u7d50\u5408\u3057\u305f\u5834\u5408:\n\n```js\nthis.props.showNotification('You just logged in.')\nsetTimeout(() => {\n  this.props.hideNotification()\n}, 5000)\n```\n> So far we have not used any middleware or other advanced concept.\n\n\u3053\u3053\u307e\u3067\u306f\u30df\u30c9\u30eb\u30a6\u30a7\u30a2\u3084\u9ad8\u5ea6\u306a\u6982\u5ff5\u3092\u4f7f\u7528\u3057\u3066\u306f\u3044\u307e\u305b\u3093\u3002\n\n> Extracting Async Action Creator\n\n**\u975e\u540c\u671f\u30a2\u30af\u30b7\u30e7\u30f3\u30af\u30ea\u30a8\u30fc\u30bf\u3092\u62bd\u51fa\u3059\u308b**\n\n> The approach above works fine in simple cases but you might find that it has a few problems:\n\n\u5358\u7d14\u306a\u4f8b\u3067\u306f\u4e0a\u8a18\u306e\u3088\u3046\u306a\u30a2\u30d7\u30ed\u30fc\u30c1\u306f\u6b63\u5e38\u306b\u52d5\u4f5c\u3059\u308b\u304b\u3082\u3057\u308c\u307e\u305b\u3093\u304c\u3001\u3042\u306a\u305f\u306f\u3044\u304f\u3064\u304b\u306e\u554f\u984c\u3092\u898b\u3064\u3051\u308b\u304b\u3082\u3057\u308c\u307e\u305b\u3093\u3002\n\n> It forces you to duplicate this logic anywhere you want to show a notification.\n\n* \u3042\u306a\u305f\u304c\u901a\u77e5\u3092\u8868\u793a\u3057\u305f\u3044\u5834\u6240\u306b\u3053\u306e\u30ed\u30b8\u30c3\u30af\u306e\u8907\u88fd\u3092\u5f37\u5236\u3057\u307e\u3059\u3002\n\n> The notifications have no IDs so you\u2019ll have a race condition if you show two notifications fast enough. When the first timeout finishes, it will dispatch HIDE_NOTIIFICATION, erroneously hiding the second notification sooner than after the timeout.\n\n* \u3082\u3057\u3001\u3042\u306a\u305f\u304c\u5341\u5206\u306a\u65e9\u3055\u3067\uff12\u3064\u306e\u901a\u77e5\u3092\u8868\u793a\u3055\u305b\u305f\u3089\u3001\u305d\u306e\u901a\u77e5\u306fID\u3092\u6301\u3063\u3066\u3044\u306a\u3044\u306e\u3067\u3001\u7af6\u5408\u72b6\u614b\u306b\u306a\u308b\u3067\u3057\u3087\u3046\u3002\u6700\u521d\u306e\u30bf\u30a4\u30e0\u30a2\u30a6\u30c8\u304c\u5b8c\u4e86\u3057\u305f\u3068\u304d\u3001HIDE_NOTIFICATION\u304c\u30c7\u30a3\u30b9\u30d1\u30c3\u30c1\u3055\u308c\u307e\u3059\u3002\u305d\u3057\u3066\u3001\u305d\u308c\u306f\u8aa4\u3063\u3066\u30bf\u30a4\u30e0\u30a2\u30a6\u30c8\u5f8c\u3088\u308a\u65e9\u30442\u3064\u76ee\u306e\u901a\u77e5\u3092\u96a0\u3057\u307e\u3059\u3002\n\n> To solve these problems, you would need to extract a function that centralizes the timeout logic and dispatches those two actions. It might look like this:\n\n\u3053\u308c\u3089\u306e\u554f\u984c\u3092\u89e3\u6c7a\u3059\u308b\u305f\u3081\u306b\u3001\u3042\u306a\u305f\u306f\u30bf\u30a4\u30e0\u30a2\u30a6\u30c8\u306e\u30ed\u30b8\u30c3\u30af\u30682\u3064\u306e\u30a2\u30af\u30b7\u30e7\u30f3\u3078\u306e\u30c7\u30a3\u30b9\u30d1\u30c3\u30c1\u3092\u96c6\u3081\u305f\u6a5f\u80fd\u3092\u62bd\u51fa\u3059\u308b\u5fc5\u8981\u304c\u3042\u308a\u307e\u3059\u3002\n\n```js\n// actions.js\nfunction showNotification(id, text) {\n  return { type: 'SHOW_NOTIFICATION', id, text }\n}\nfunction hideNotification(id) {\n  return { type: 'HIDE_NOTIFICATION', id }\n}\n\nlet nextNotificationId = 0\nexport function showNotificationWithTimeout(dispatch, text) {\n  // Assigning IDs to notifications lets reducer ignore HIDE_NOTIFICATION\n  // for the notification that is not currently visible.\n  // Alternatively, we could store the interval ID and call\n  // clearInterval(), but we\u2019d still want to do it in a single place.\n  const id = nextNotificationId++\n  dispatch(showNotification(id, text))\n\n  setTimeout(() => {\n    dispatch(hideNotification(id))\n  }, 5000)\n}\n```\n\n> Now components can use showNotificationWithTimeout without duplicating this logic or having race conditions with different notifications:\n\n\u3053\u306e\u30b3\u30f3\u30dd\u30fc\u30cd\u30f3\u30c8\u306f\u30ed\u30b8\u30c3\u30af\u306e\u91cd\u8907\u3084\u7570\u306a\u308b\u901a\u77e5\u306e\u7af6\u5408\u72b6\u614b\u306a\u3057\u306bshowNotificationWithTimeout\u3092\u5229\u7528\u3059\u308b\u3053\u3068\u304c\u3067\u304d\u307e\u3059\u3002\n\n```js\n// component.js\nshowNotificationWithTimeout(this.props.dispatch, 'You just logged in.')\n\n// otherComponent.js\nshowNotificationWithTimeout(this.props.dispatch, 'You just logged out.')\n```\n\n> Why does showNotificationWithTimeout() accept dispatch as the first argument? Because it needs to dispatch actions to the store. Normally a component has access to dispatch but since we want an external function to take control over dispatching, we need to give it control over dispatching.\n\n\u306a\u305c\u6700\u521d\u306e\u5f15\u6570\u3068\u3057\u3066showNotificationWithTimeout()\u3067dispatch\u3092\u53d7\u3051\u5165\u308c\u3066\u3044\u308b\u306e\u3067\u3057\u3087\u3046\u304b\u3002\u305d\u308c\u306fstore\u306b\u30a2\u30af\u30b7\u30e7\u30f3\u3092\u30c7\u30a3\u30b9\u30d1\u30c3\u30c1\u3059\u308b\u5fc5\u8981\u304c\u3042\u308b\u305f\u3081\u3067\u3059\u3002\u901a\u5e38\u3001\u30b3\u30f3\u30dd\u30fc\u30cd\u30f3\u30c8\u306f\u30c7\u30a3\u30b9\u30d1\u30c3\u30c1\u306b\u30a2\u30af\u30bb\u30b9\u3059\u308b\u6a29\u9650\u3092\u6301\u3063\u3066\u3044\u307e\u3059\u304c\u3001\u79c1\u305f\u3061\u306f\u5916\u90e8\u306e\u6a5f\u80fd\u306b\u30c7\u30a3\u30b9\u30d1\u30c3\u30c1\u306e\u30b3\u30f3\u30c8\u30ed\u30fc\u30eb\u3092\u6301\u3063\u3066\u3082\u3089\u3044\u305f\u3044\u306e\u3067\u3001\u30c7\u30a3\u30b9\u30d1\u30c3\u30c1\u306e\u30b3\u30f3\u30c8\u30ed\u30fc\u30eb\u3092\u4e0e\u3048\u308b\u5fc5\u8981\u304c\u3042\u308a\u307e\u3059\u3002\n\n> If you had a singleton store exported from some module, you could just import it and dispatch directly on it instead:\n\n\u3082\u3057\u3001\u3042\u306a\u305f\u304c\u30e2\u30b8\u30e5\u30fc\u30eb\u304b\u3089\u30a8\u30af\u30b9\u30dd\u30fc\u30c8\u3055\u308c\u305f\u30b7\u30f3\u30b0\u30eb\u30c8\u30f3\u306estore\u3092\u6301\u3063\u3066\u3044\u305f\u3089\u3001\u3042\u306a\u305f\u306f\u305d\u308c\u3092\u30a4\u30f3\u30dd\u30fc\u30c8\u3057\u3001\u76f4\u63a5\u30c7\u30a3\u30b9\u30d1\u30c3\u30c1\u3067\u304d\u307e\u3059\u3002\n\n```js\n// store.js\nexport default createStore(reducer)\n\n// actions.js\nimport store from './store'\n\n// ...\n\nlet nextNotificationId = 0\nexport function showNotificationWithTimeout(text) {\n  const id = nextNotificationId++\n  store.dispatch(showNotification(id, text))\n\n  setTimeout(() => {\n    store.dispatch(hideNotification(id))\n  }, 5000)\n}\n\n// component.js\nshowNotificationWithTimeout('You just logged in.')\n\n// otherComponent.js\nshowNotificationWithTimeout('You just logged out.') \n```\n\n> This looks simpler but we don\u2019t recommend this approach. The main reason we dislike it is because it forces store to be a singleton. This makes it very hard to implement server rendering. On the server, you will want each request to have its own store, so that different users get different preloaded data.\n\n\u3053\u308c\u306f\u4e00\u898b\u5358\u7d14\u3067\u3059\u304c\u3001\u79c1\u305f\u3061\u306f\u3053\u306e\u30a2\u30d7\u30ed\u30fc\u30c1\u3092\u63a8\u5968\u3057\u307e\u305b\u3093\u3002\u4e3b\u306a\u7406\u7531\u306fstore\u304c\u30b7\u30f3\u30b0\u30eb\u30c8\u30f3\u3067\u3042\u308b\u3053\u3068\u3092\u5f37\u5236\u3059\u308b\u306e\u3092\u5acc\u3046\u304b\u3089\u3067\u3059\u3002\u3053\u308c\u306f\u30b5\u30fc\u30d0\u30fc\u306e\u30ec\u30f3\u30c0\u30ea\u30f3\u30b0\u3092\u5b9f\u88c5\u3059\u308b\u3053\u3068\u304c\u975e\u5e38\u306b\u96e3\u3057\u304f\u306a\u308a\u307e\u3059\u3002\u30b5\u30fc\u30d0\u30fc\u4e0a\u3067\u3042\u306a\u305f\u306f\u5404\u3005\u306e\u30ea\u30af\u30a8\u30b9\u30c8\u304c\u305d\u308c\u81ea\u8eab\u306estore\u3092\u3082\u3064\u3053\u3068\u3092\u671b\u307f\u3001\u305d\u306e\u7d50\u679c\u3001\u30e6\u30fc\u30b6\u306f\u7570\u306a\u3063\u305f\u4e8b\u524d\u30ed\u30fc\u30c9\u30c7\u30fc\u30bf\u3092\u53d6\u5f97\u3057\u307e\u3059\u3002\n\n> A singleton store also makes testing harder. You can no longer mock a store when testing action creators because they reference a specific real store exported from a specific module. You can\u2019t even reset its state from outside.\n\n\u30b7\u30f3\u30b0\u30eb\u30c8\u30f3\u306estore\u306f\u30c6\u30b9\u30c8\u3082\u307e\u305f\u96e3\u3057\u304f\u306a\u308a\u307e\u3059\u3002\u3042\u306a\u305f\u306f\u30a2\u30af\u30b7\u30e7\u30f3\u30af\u30ea\u30a8\u30fc\u30bf\u30fc\u3092\u30c6\u30b9\u30c8\u3059\u308b\u3068\u304d\u3082\u306f\u3084store\u3092\u30e2\u30c3\u30af\u5316\u3067\u304d\u307e\u305b\u3093\u3002\u306a\u305c\u306a\u3089\u3001\u305d\u308c\u3089\u306f\u7279\u5b9a\u306e\u30e2\u30b8\u30e5\u30fc\u30eb\u304b\u3089\u30a8\u30af\u30b9\u30dd\u30fc\u30c8\u3055\u308c\u305f\u7279\u5b9a\u306e\u30b9\u30c8\u30a2\u3092\u53c2\u7167\u3057\u3066\u3044\u308b\u304b\u3089\u3067\u3059\u3002\u3042\u306a\u305f\u306f\u5916\u5074\u304b\u3089\u72b6\u614b\u3092\u30ea\u30bb\u30c3\u30c8\u3059\u308b\u3053\u3068\u3055\u3048\u3067\u304d\u307e\u305b\u3093\u3002\n\n> So while you technically can export a singleton store from a module, we discourage it. Don\u2019t do this unless you are sure that your app will never add server rendering.\n\n\u305d\u3057\u3066\u3001\u30e2\u30b8\u30e5\u30fc\u30eb\u304b\u3089\u30b7\u30f3\u30b0\u30eb\u30c8\u30f3\u306estore\u3092\u6280\u8853\u7684\u306b\u30a8\u30af\u30b9\u30dd\u30fc\u30c8\u3067\u304d\u308b\u9593\u3001\u79c1\u305f\u3061\u306f\u305d\u308c\u3092\u963b\u6b62\u3057\u307e\u3059\u3002\u3042\u306a\u305f\u306e\u30a2\u30d7\u30ea\u304c\u6c7a\u3057\u3066\u30ec\u30f3\u30c0\u30ea\u30f3\u30b0\u3092\u8ffd\u52a0\u3057\u306a\u3044\u3068\u78ba\u4fe1\u3057\u3066\u306a\u3044\u9650\u308a\u3053\u308c\u3092\u3084\u3063\u3066\u306f\u3044\u3051\u307e\u305b\u3093\u3002\n\n> Getting back to the previous version:\n\n\u524d\u306e\u30d0\u30fc\u30b8\u30e7\u30f3\u306b\u623b\u308a\u307e\u3057\u3087\u3046\u3002\n\n```js\n// actions.js\n\n// ...\n\nlet nextNotificationId = 0\nexport function showNotificationWithTimeout(dispatch, text) {\n  const id = nextNotificationId++\n  dispatch(showNotification(id, text))\n\n  setTimeout(() => {\n    dispatch(hideNotification(id))\n  }, 5000)\n}\n\n// component.js\nshowNotificationWithTimeout(this.props.dispatch, 'You just logged in.')\n\n// otherComponent.js\nshowNotificationWithTimeout(this.props.dispatch, 'You just logged out.')    \n```\n\n> This solves the problems with duplication of logic and saves us from race conditions.\n\n\u3053\u308c\u306f\u30ed\u30b8\u30c3\u30af\u306e\u8907\u88fd\u306e\u554f\u984c\u3092\u89e3\u6c7a\u3057\u3001\u7af6\u5408\u72b6\u614b\u304b\u3089\u79c1\u305f\u3061\u3092\u6551\u3044\u307e\u3059\u3002\n\n> Thunk Middleware\n\n**Thunk\u30df\u30c9\u30eb\u30a6\u30a7\u30a2**\n\n> For simple apps, the approach should suffice. Don\u2019t worry about middleware if you\u2019re happy with it.\n\n\u30b7\u30f3\u30d7\u30eb\u306a\u30a2\u30d7\u30ea\u30b1\u30fc\u30b7\u30e7\u30f3\u306e\u5834\u5408\u3001\u3053\u308c\u307e\u3067\u306e\u30a2\u30d7\u30ed\u30fc\u30c1\u3067\u5341\u5206\u3067\u3059\u3002\u3042\u306a\u305f\u304c\u6e80\u8db3\u3057\u3066\u3044\u308b\u306a\u3089\u3001\u30df\u30c9\u30eb\u30a6\u30a7\u30a2\u306e\u5fc3\u914d\u306f\u3057\u306a\u3044\u3067\u304f\u3060\u3055\u3044\u3002\n\n> In larger apps, however, you might find certain inconveniences around it.\n\n\u3057\u304b\u3057\u5927\u304d\u306a\u30a2\u30d7\u30ea\u30b1\u30fc\u30b7\u30e7\u30f3\u306e\u5834\u5408\u3001\u3042\u306a\u305f\u306f\u305d\u306e\u30a2\u30d7\u30ed\u30fc\u30c1\u306b\u4e0d\u4fbf\u306a\u90e8\u5206\u3092\u898b\u3064\u3051\u308b\u304b\u3082\u3057\u308c\u307e\u305b\u3093\u3002\n\n> For example, it seems unfortunate that we have to pass dispatch around. This makes it trickier to separate container and presentational components because any component that dispatches Redux actions asynchronously in the manner above has to accept dispatch as a prop so it can pass it further. You can\u2019t just bind action creators with connect() anymore because showNotificationWithTimeout() is not really an action creator. It does not return a Redux action.\n\n\u4f8b\u3048\u3070\u3001\u30c7\u30a3\u30b9\u30d1\u30c3\u30c1\u3092\u6301\u3061\u56de\u3059\u3053\u3068\u306f\u6b8b\u5ff5\u306b\u611f\u3058\u307e\u3059\u3002Redux\u30a2\u30af\u30b7\u30e7\u30f3\u3092\u975e\u540c\u671f\u306b\u30c7\u30a3\u30b9\u30d1\u30c3\u30c1\u3059\u308b\u4efb\u610f\u306e\u30b3\u30f3\u30dd\u30fc\u30cd\u30f3\u30c8\u306f\u3001\u30c7\u30a3\u30b9\u30d1\u30c3\u30c1\u3092\u3055\u3089\u306b\u6e21\u305b\u308b\u3088\u3046\u306bprop\u3068\u3057\u3066\u30c7\u30a3\u30b9\u30d1\u30c3\u30c1\u3092\u8a31\u53ef\u3059\u308b\u306e\u3067\u3001\u30b3\u30f3\u30c6\u30ca\u3068\u30d7\u30ec\u30bc\u30f3\u30c6\u30fc\u30b7\u30e7\u30f3\u30b3\u30f3\u30dd\u30fc\u30cd\u30f3\u30c8\u306b\u5206\u96e2\u3059\u308b\u3053\u3068\u3092\u3088\u308a\u96e3\u3057\u304f\u3059\u308b\u3002showNotificationWithTimeout()\u306f\u5b9f\u969b\u306e\u30a2\u30af\u30b7\u30e7\u30f3\u30af\u30ea\u30a8\u30fc\u30bf\u3067\u306f\u306a\u3044\u306e\u3067\u3001\u3042\u306a\u305f\u306f\u3082\u306f\u3084\u30a2\u30af\u30b7\u30e7\u30f3\u30af\u30ea\u30a8\u30fc\u30bf\u3092\u30d0\u30a4\u30f3\u30c9\u3059\u308b\u3053\u3068\u306f\u3067\u304d\u307e\u305b\u3093\u3002\u305d\u308c\u306fRedux\u30a2\u30af\u30b7\u30e7\u30f3\u3092\u8fd4\u3057\u307e\u305b\u3093\u3002\n\n> In addition, it can be awkward to remember which functions are synchronous action creators like showNotification() and which are asynchronous helpers like showNotificationWithTimeout(). You have to use them differently and be careful not to mistake them with each other.\n\n\u3055\u3089\u306b\u3001showNotification()\u306e\u3088\u3046\u306a\u540c\u671f\u30a2\u30af\u30b7\u30e7\u30f3\u30af\u30ea\u30a8\u30fc\u30bf\u30fc\u306e\u6a5f\u80fd\u3068showNotificationWithTimeout()\u306e\u3088\u3046\u975e\u540c\u671f\u306a\u30d8\u30eb\u30d1\u30fc\u3092\u899a\u3048\u308b\u306e\u306f\u5384\u4ecb\u306a\u3053\u3068\u304b\u3082\u3057\u308c\u307e\u305b\u3093\u3002\u3042\u306a\u305f\u306f\u3001\u305d\u308c\u3089\u3092\u4e92\u3044\u306b\u9593\u9055\u3048\u306a\u3044\u3088\u3046\u306b\u6ce8\u610f\u3057\u3001\u5225\u3005\u306b\u4f7f\u7528\u3057\u306a\u3051\u308c\u3070\u306a\u308a\u307e\u305b\u3093\u3002\n\n> This was the motivation for finding a way to \u201clegitimize\u201d this pattern of providing dispatch to a helper function, and help Redux \u201csee\u201d such asynchronous action creators as a special case of normal action creators rather than totally different functions.\n\n> If you\u2019re still with us and you also recognize as a problem in your app, you are welcome to use the Redux Thunk middleware.\n\n\u3082\u3057\u3001\u3042\u306a\u305f\u304c\u307e\u3060\u79c1\u305f\u3061\u3068\u3042\u306a\u305f\u306e\u30a2\u30d7\u30ea\u306e\u554f\u984c\u3068\u3057\u3066\u8a8d\u8b58\u3059\u308b\u306a\u3089\u3001\u3042\u306a\u305f\u306fRedux-Thunk\u30df\u30c9\u30eb\u30a6\u30a7\u30a2\u3092\u5229\u7528\u3067\u304d\u307e\u3059\u3002\n\n>In a gist, Redux Thunk teaches Redux to recognize special kinds of actions that are in fact functions:\n\n\u8981\u3059\u308b\u306b\u3001Redux-thunk\u306fRedux\u306b\u5b9f\u969b\u306e\u95a2\u6570\u3067\u3042\u308b\u30a2\u30af\u30b7\u30e7\u30f3\u306e\u7279\u5225\u306a\u7a2e\u985e\u3092\u8a8d\u8b58\u3059\u308b\u3053\u3068\u3092\u6559\u3048\u307e\u3059\u3002\n\n```js\nimport { createStore, applyMiddleware } from 'redux'\nimport thunk from 'redux-thunk'\n\nconst store = createStore(\n  reducer,\n  applyMiddleware(thunk)\n)\n\n// It still recognizes plain object actions\nstore.dispatch({ type: 'INCREMENT' })\n\n// But with thunk middleware, it also recognizes functions\nstore.dispatch(function (dispatch) {\n  // ... which themselves may dispatch many times\n  dispatch({ type: 'INCREMENT' })\n  dispatch({ type: 'INCREMENT' })\n  dispatch({ type: 'INCREMENT' })\n\n  setTimeout(() => {\n    // ... even asynchronously!\n    dispatch({ type: 'DECREMENT' })\n  }, 1000)\n})\n```\n\n> When this middleware is enabled, if you dispatch a function, Redux Thunk middleware will give it dispatch as an argument. It will also \u201cswallow\u201d such actions so don\u2019t worry about your reducers receiving weird function arguments. Your reducers will only receive plain object actions\u2014either emitted directly, or emitted by the functions as we just described.\n\n\u3053\u306e\u30df\u30c9\u30eb\u30a6\u30a7\u30a2\u304c\u6709\u52b9\u306a\u3068\u304d\u3001\u3082\u3057\u3042\u306a\u305f\u304c\u30e1\u30bd\u30c3\u30c9\u3092\u30c7\u30a3\u30b9\u30d1\u30c3\u30c1\u3059\u308b\u306a\u3089\u3001Redux-Thunk\u30df\u30c9\u30eb\u30a6\u30a7\u30a2\u306f\u5f15\u6570\u3068\u3057\u3066dispatch\u3092\u4e0e\u3048\u307e\u3059\u3002\u305d\u306e\u3088\u3046\u306a\u30a2\u30af\u30b7\u30e7\u30f3\u3092\u300c\u98f2\u307f\u8fbc\u3080\u300d\u306e\u3067\u3001\u5947\u5999\u306a\u30e1\u30bd\u30c3\u30c9\u306e\u5f15\u6570\u3092\u53d7\u3051\u53d6\u308b\u3042\u306a\u305f\u306ereducer\u306b\u3064\u3044\u3066\u5fc3\u914d\u3042\u308a\u307e\u305b\u3093\u3002\u3042\u306a\u305f\u306ereducer\u306f\u76f4\u63a5\u4f5c\u6210\u3055\u308c\u305f\u304b\u3001\u5f8c\u8ff0\u3059\u308b\u95a2\u6570\u306b\u3088\u3063\u3066\u4f5c\u6210\u3055\u308c\u305f\u304b\u3057\u305f\u30d7\u30ec\u30fc\u30f3\u30aa\u30d6\u30b8\u30a7\u30af\u30c8\u3060\u3051\u3092\u53d7\u3051\u53d6\u308b\u3067\u3057\u3087\u3046\u3002\n\n> This does not look very useful, does it? Not in this particular situation. However it lets us declare showNotificationWithTimeout() as a regular Redux action creator:\n\n\u3053\u308c\u306f\u3042\u307e\u308a\u6709\u76ca\u306b\u898b\u3048\u307e\u305b\u3093\u306d\u3002\u7279\u5b9a\u306e\u72b6\u6cc1\u3067\u306f\u3042\u308a\u307e\u305b\u3093\u3002\u3057\u304b\u3057\u3001showNotificationWithTimeout()\u3092\u901a\u5e38\u306eRedux\u30a2\u30af\u30b7\u30e7\u30f3\u30af\u30ea\u30a8\u30fc\u30bf\u3068\u3057\u3066\u5b9a\u7fa9\u3057\u307e\u3057\u3087\u3046\u3002\n\n```js\n// actions.js\nfunction showNotification(id, text) {\n  return { type: 'SHOW_NOTIFICATION', id, text }\n}\nfunction hideNotification(id) {\n  return { type: 'HIDE_NOTIFICATION', id }\n}\n\nlet nextNotificationId = 0\nexport function showNotificationWithTimeout(text) {\n  return function (dispatch) {\n    const id = nextNotificationId++\n    dispatch(showNotification(id, text))\n\n    setTimeout(() => {\n      dispatch(hideNotification(id))\n    }, 5000)\n  }\n}\n```\n\n> Note how the function is almost identical to the one we wrote in the previous section. However it doesn\u2019t accept dispatch as the first argument. Instead it returns a function that accepts dispatch as the first argument.\n\n\u95a2\u6570\u306f\u524d\u7bc0\u306b\u66f8\u3044\u305f\u3082\u306e\u3068\u307b\u307c\u540c\u3058\u3067\u3042\u308b\u304b\u306b\u6ce8\u610f\u3057\u3066\u304f\u3060\u3055\u3044\u3002\u3057\u304b\u3057\u3001\u6700\u521d\u306e\u5f15\u6570\u3068\u3057\u3066dispatch\u304c\u8a31\u53ef\u3055\u308c\u3066\u3044\u307e\u305b\u3093\u3002\u4ee3\u308f\u308a\u306b\u6700\u521d\u306e\u5f15\u6570\u3068\u3057\u3066dispatch\u3092\u8a31\u53ef\u3059\u308b\u95a2\u6570\u3092\u8fd4\u5374\u3057\u307e\u3059\u3002\n\n> How would we use it in our component? Definitely, we could write this:\n\n\u3069\u306e\u3088\u3046\u306b\u79c1\u305f\u3061\u306e\u30b3\u30f3\u30dd\u30fc\u30cd\u30f3\u30c8\u3092\u5229\u7528\u3059\u308b\u306e\u3067\u3057\u3087\u3046\u304b\u3002\u79c1\u305f\u3061\u306f\u3053\u308c\u3092\u66f8\u304f\u3053\u3068\u304c\u3067\u304d\u307e\u3059:\n\n```js\n// component.js\nshowNotificationWithTimeout('You just logged in.')(this.props.dispatch)\n```\n\n> We are calling the async action creator to get the inner function that wants just dispatch, and then we pass dispatch.\n\n\u79c1\u305f\u3061\u306fdispatch\u3092\u671b\u3080\u5185\u90e8\u95a2\u6570\u3092\u53d6\u5f97\u3059\u308b\u305f\u3081\u306e\u975e\u540c\u671f\u30a2\u30af\u30b7\u30e7\u30f3\u30af\u30ea\u30a8\u30fc\u30bf\u3092\u547c\u3073\u307e\u3059\u3002\u305d\u3057\u3066\u305d\u306e\u3068\u304d\u79c1\u305f\u3061\u306fdispatch\u3092\u6e21\u3057\u307e\u3059\u3002\n\n> However this is even more awkward than the original version! Why did we even go that way?\n\n\u3057\u304b\u3057\u3053\u308c\u306f\u5143\u306e\u30d0\u30fc\u30b8\u30e7\u30f3\u3088\u308a\u5384\u4ecb\u3067\u3059\u3002\u306a\u305c\u79c1\u305f\u3061\u306f\u305d\u306e\u65b9\u5411\u306b\u884c\u3063\u305f\u306e\u3067\u3057\u3087\u3046\u304b\u3002\n\n> Because of what I told you before. If Redux Thunk middleware is enabled, any time you attempt to dispatch a function instead of an action object, the middleware will call that function with dispatch method itself as the first argument.\n\n\u79c1\u304c\u524d\u306b\u3042\u306a\u305f\u306b\u8a00\u3063\u305f\u3053\u3068\u306e\u305f\u3081\u3067\u3059\u3002\u3082\u3057Redux-Thunk\u30df\u30c9\u30eb\u30a6\u30a7\u30a2\u304c\u6709\u52b9\u306a\u3089\u3001\u3044\u3064\u3067\u3082\u3042\u306a\u305f\u306f\u30a2\u30af\u30b7\u30e7\u30f3\u30aa\u30d6\u30b8\u30a7\u30af\u30c8\u306e\u4ee3\u308f\u308a\u306b\u95a2\u6570\u3092\u30c7\u30a3\u30b9\u30d1\u30c3\u30c1\u3059\u308b\u3053\u3068\u3092\u8a66\u307f\u307e\u3059\u3002\u305d\u306e\u30df\u30c9\u30eb\u30a6\u30a7\u30a2\u306f\u6700\u521d\u306e\u5f15\u6570\u3068\u3057\u3066\u30c7\u30a3\u30b9\u30d1\u30c3\u30c1\u95a2\u6570\u81ea\u8eab\u3067\u95a2\u6570\u3092\u547c\u3073\u51fa\u3057\u307e\u3059\u3002\n\n> So we can do this instead:\n\n\u3060\u304b\u3089\u4ee3\u308f\u308a\u306b\u3053\u308c\u3092\u884c\u3044\u307e\u3059\u3002\n\n```js\n// component.js\nthis.props.dispatch(showNotificationWithTimeout('You just logged in.'))\n```\n\n> Finally, dispatching an asynchronous action (really, a series of actions) looks no different than dispatching a single action synchronously to the component. Which is good because components shouldn\u2019t care whether something happens synchronously or asynchronously. We just abstracted that away.\n\n\u975e\u540c\u671f\u306e\u30a2\u30af\u30b7\u30e7\u30f3(\u5b9f\u969b\u306b\u306f\u3001\u4e00\u9023\u306e\u30a2\u30af\u30b7\u30e7\u30f3)\u306f\u3001\u30b3\u30f3\u30dd\u30fc\u30cd\u30f3\u30c8\u306b\u540c\u671f\u7684\u306b\u30c7\u30a3\u30b9\u30d1\u30c3\u30c1\u3059\u308b\u5358\u4e00\u306e\u30a2\u30af\u30b7\u30e7\u30f3\u3068\u5909\u308f\u3063\u3066\u898b\u3048\u307e\u305b\u3093\u3002\u305d\u308c\u306f\u30b3\u30f3\u30dd\u30fc\u30cd\u30f3\u30c8\u304c\u306a\u306b\u304b\u304c\u540c\u671f\u7684\u3042\u308b\u3044\u306f\u975e\u540c\u671f\u7684\u306b\u767a\u751f\u3057\u305f\u304b\u3092\u6c17\u306b\u3059\u308b\u3079\u304d\u3067\u306f\u306a\u3044\u306e\u3067\u3088\u3044\u3053\u3068\u3067\u3059\u3002\u79c1\u305f\u3061\u306f\u307e\u3055\u306b\u305d\u308c\u3092\u62bd\u8c61\u5316\u3057\u307e\u3057\u305f\u3002\n\n> Notice that since we \u201ctaught\u201d Redux to recognize such \u201cspecial\u201d action creators (we call them thunk action creators), we can now use them in any place where we would use regular action creators. For example, we can use them with connect():\n\n\u79c1\u305f\u3061\u306f\u305d\u306e\u3088\u3046\u306a\u300c\u7279\u5225\u300d\u306e\u30a2\u30af\u30b7\u30e7\u30f3\u30af\u30ea\u30a8\u30fc\u30bf\u3092\u7406\u89e3\u3059\u308b\u3088\u3046\u306bRedux\u306b\u300c\u6559\u3048\u305f\u300d(\u305d\u308c\u3089\u3092thunk\u30a2\u30af\u30b7\u30e7\u30f3\u30af\u30ea\u30a8\u30fc\u30bf\u3068\u547c\u3076)\u3068\u3044\u3046\u3053\u3068\u306b\u6ce8\u610f\u3057\u3066\u304f\u3060\u3055\u3044\u3002\u79c1\u305f\u3061\u306f\u901a\u5e38\u306e\u30a2\u30af\u30b7\u30e7\u30f3\u30af\u30ea\u30a8\u30fc\u30bf\u3092\u5229\u7528\u3059\u308b\u5834\u6240\u3067\u305d\u308c\u3089\u3092\u5229\u7528\u3059\u308b\u3053\u3068\u304c\u3067\u3067\u304d\u308b\u3002\u4f8b\u3048\u3070\u3001\u79c1\u305f\u3061\u306fconnect()\u3067\u305d\u308c\u3089\u3092\u5229\u7528\u3059\u308b\u3053\u3068\u304c\u3067\u304d\u307e\u3059\u3002\n\n```js\n// actions.js\n\nfunction showNotification(id, text) {\n  return { type: 'SHOW_NOTIFICATION', id, text }\n}\nfunction hideNotification(id) {\n  return { type: 'HIDE_NOTIFICATION', id }\n}\n\nlet nextNotificationId = 0\nexport function showNotificationWithTimeout(text) {\n  return function (dispatch) {\n    const id = nextNotificationId++\n    dispatch(showNotification(id, text))\n\n    setTimeout(() => {\n      dispatch(hideNotification(id))\n    }, 5000)\n  }\n}\n\n// component.js\n\nimport { connect } from 'react-redux'\n\n// ...\n\nthis.props.showNotificationWithTimeout('You just logged in.')\n\n// ...\n\nexport default connect(\n  mapStateToProps,\n  { showNotificationWithTimeout }\n)(MyComponent)\n```\n\n> Reading State in Thunks\n\n**thunk\u306e\u72b6\u614b\u3092\u8aad\u307f\u8fbc\u3080**\n\n> Usually your reducers contain the business logic for determining the next state. However, reducers only kick in after the actions are dispatched. What if you have a side effect (such as calling an API) in a thunk action creator, and you want to prevent it under some condition?\n\n\u901a\u5e38\u3042\u306a\u305f\u306ereducer\u306f\u6b21\u306e\u72b6\u614b\u3092\u6c7a\u5b9a\u3059\u308b\u305f\u3081\u306b\u30d3\u30b8\u30cd\u30b9\u30ed\u30b8\u30c3\u30af\u3092\u542b\u3093\u3067\u3044\u307e\u3059\u3002\u3057\u304b\u3057\u3001reducer\u306f\u30a2\u30af\u30b7\u30e7\u30f3\u304c\u30c7\u30a3\u30b9\u30d1\u30c3\u30c1\u3055\u308c\u305f\u3042\u3068\u306b\u3060\u3051\u30ad\u30c3\u30af\u3055\u308c\u307e\u3059\u3002\u4eee\u306b\u3042\u306a\u305f\u304cthunk\u30a2\u30af\u30b7\u30e7\u30f3\u30af\u30ea\u30a8\u30fc\u30bf\u3067\u526f\u4f5c\u7528(\u4f8b\u3048\u3070API\u3092\u547c\u3076\u3068\u304d)\u3092\u3082\u3063\u3066\u3044\u305f\u3089\u3001\u3044\u304f\u3064\u304b\u306e\u6761\u4ef6\u4e0b\u3067\u305d\u308c\u3092\u9632\u304e\u305f\u3044\u3067\u3059\u3002\n\nWithout using the thunk middleware, you\u2019d just do this check inside the component:\n\nthunk\u30df\u30c9\u30eb\u30a6\u30a7\u30a2\u3092\u4f7f\u7528\u305b\u305a\u306b\u3001\u3042\u306a\u305f\u306f\u307e\u3055\u306b\u30b3\u30f3\u30dd\u30fc\u30cd\u30f3\u30c8\u306e\u4e2d\u3092\u30c1\u30a7\u30c3\u30af\u3059\u308b\u3067\u3057\u3087\u3046\u3002\n\n```js\n// component.js\nif (this.props.areNotificationsEnabled) {\n  showNotificationWithTimeout(this.props.dispatch, 'You just logged in.')\n}\n```\n\n> However, the point of extracting an action creator was to centralize this repetitive logic across many components. Fortunately, Redux Thunk offers you a way to read the current state of the Redux store. In addition to dispatch, it also passes getState as the second argument to the function you return from your thunk action creator. This lets the thunk read the current state of the store.\n\n\u3057\u304b\u3057\u3001\u305d\u306e\u30a2\u30af\u30b7\u30e7\u30f3\u30af\u30ea\u30a8\u30fc\u30bf\u3092\u62bd\u51fa\u3059\u308b\u30dd\u30a4\u30f3\u30c8\u306f\u591a\u304f\u306e\u30b3\u30f3\u30dd\u30fc\u30cd\u30f3\u30c8\u3067\u7e70\u308a\u8fd4\u3057\u30ed\u30b8\u30c3\u30af\u3092\u96c6\u4e2d\u7ba1\u7406\u3059\u308b\u3053\u3068\u3067\u3057\u305f\u3002\u5e78\u3044\u306a\u3053\u3068\u306b\u3001Redux-thunk\u306f\u3042\u306a\u305f\u306bRedux\u306estore\u306e\u73fe\u5728\u306e\u72b6\u614b\u3092\u8aad\u307f\u51fa\u3059\u305f\u3081\u306e\u65b9\u6cd5\u3092\u63d0\u4f9b\u3057\u3066\u3044\u307e\u3059\u3002\u30c7\u30a3\u30b9\u30d1\u30c3\u30c1\u306b\u52a0\u3048\u3066\u3001\u3042\u306a\u305f\u306ethunk\u30a2\u30af\u30b7\u30e7\u30f3\u30af\u30ea\u30a8\u30fc\u30bf\u304b\u3089\u8fd4\u3059\u95a2\u6570\u306b\u7b2c\u4e8c\u5f15\u6570\u3068\u3057\u3066getState\u3082\u6e21\u3057\u307e\u3059\u3002thunk\u306bstore\u306e\u73fe\u5728\u306e\u72b6\u614b\u3092\u3088\u307f\u3053\u307e\u305b\u3066\u307f\u307e\u3057\u3087\u3046\u3002\n\n```js\nlet nextNotificationId = 0\nexport function showNotificationWithTimeout(text) {\n  return function (dispatch, getState) {\n    // Unlike in a regular action creator, we can exit early in a thunk\n    // Redux doesn\u2019t care about its return value (or lack of it)\n    if (!getState().areNotificationsEnabled) {\n      return\n    }\n\n    const id = nextNotificationId++\n    dispatch(showNotification(id, text))\n\n    setTimeout(() => {\n      dispatch(hideNotification(id))\n    }, 5000)\n  }\n}\n```\n\n> Don\u2019t abuse this pattern. It is good for bailing out of API calls when there is cached data available, but it is not a very good foundation to build your business logic upon. If you use getState() only to conditionally dispatch different actions, consider putting the business logic into the reducers instead.\n\n\u3053\u306e\u30d1\u30bf\u30fc\u30f3\u3092\u8aa4\u7528\u3057\u306a\u3044\u3067\u304f\u3060\u3055\u3044\u3002\u6709\u52b9\u306a\u30ad\u30e3\u30c3\u30b7\u30e5\u30c7\u30fc\u30bf\u304c\u3042\u308b\u6642\u306bAPI\u30b3\u30fc\u30eb\u306e\u6551\u6e08\u306b\u306f\u3088\u3044\u3067\u3059\u304c\u3001\u30d3\u30b8\u30cd\u30b9\u30ed\u30b8\u30c3\u30af\u3092\u69cb\u7bc9\u3059\u308b\u305f\u3081\u306e\u3088\u3044\u57fa\u76e4\u3067\u306f\u3042\u308a\u307e\u305b\u3093\u3002\u3082\u3057\u3001\u3042\u306a\u305f\u304cgetState()\u3092\u6761\u4ef6\u4ed8\u304d\u3067\u7570\u306a\u308b\u30a2\u30af\u30b7\u30e7\u30f3\u3092\u30c7\u30a3\u30b9\u30d1\u30c3\u30c1\u3059\u308b\u305f\u3081\u306b\u4f7f\u3046\u306a\u3089\u3001\u4ee3\u308f\u308a\u306breducer\u306e\u4e2d\u306b\u30d3\u30b8\u30cd\u30b9\u30ed\u30b8\u30c3\u30af\u3092\u7f6e\u304f\u3053\u3068\u3092\u691c\u8a0e\u3057\u3066\u304f\u3060\u3055\u3044\u3002\n\n> Next Steps\n\n**\u6b21\u306e\u30b9\u30c6\u30c3\u30d7(\u7701\u7565)**\n\n> Now that you have a basic intuition about how thunks work, check out Redux async example which uses them.\n\n> You may find many examples in which thunks return Promises. This is not required but can be very convenient. Redux doesn\u2019t care what you return from a thunk, but it gives you its return value from dispatch(). This is why you can return a Promise from a thunk and wait for it to complete by calling dispatch(someThunkReturningPromise()).then(...).\n\n>You may also split complex thunk action creators into several smaller thunk action creators. The dispatch method provided by thunks can accept thunks itself, so you can apply the pattern recursively. Again, this works best with Promises because you can implement asynchronous control flow on top of that.\n\n>For some apps, you may find yourself in a situation where your asynchronous control flow requirements are too complex to be expressed with thunks. For example, retrying failed requests, reauthorization flow with tokens, or a step-by-step onboarding can be too verbose and error-prone when written this way. In this case, you might want to look at more advanced asynchronous control flow solutions such as Redux Saga or Redux Loop. Evaluate them, compare the examples relevant to your needs, and pick the one you like the most.\n\n>Finally, don\u2019t use anything (including thunks) if you don\u2019t have the genuine need for them. Remember that, depending on the requirements, your solution might look as simple as\n\n```js\nstore.dispatch({ type: 'SHOW_NOTIFICATION', text: 'You logged in.' })\nsetTimeout(() => {\n  store.dispatch({ type: 'HIDE_NOTIFICATION' })\n}, 5000)\n```\n\n> Don\u2019t sweat it unless you know why you\u2019re doing this.\n", "tags": ["redux-thunk", "redux"]}