{"context": " More than 1 year has passed since last update.(\u7d9a\u304d\u305d\u306e3\u2192 http://qiita.com/takeru@github/items/23f41616db9367ea26b5)\n\n\u3053\u3053\u307e\u3067\u306e\u3042\u3089\u3059\u3058\n\nhttp://qiita.com/takeru@github/items/c591323acf24e58ed6c0\nAVR\u306bUSB\u30b1\u30fc\u30d6\u30eb\u76f4\u7d50\u3067USB\u30c7\u30d0\u30a4\u30b9\u304c\u4f5c\u308c\u308bV-USB\nAVR-CDC\u3067\u30b7\u30ea\u30a2\u30eb\u8aad\u307f\u66f8\u304d\u30c7\u30d0\u30a4\u30b9\u306f\u3067\u304d\u305f\u304c\u30a4\u30de\u30a4\u30c1\nHID\u306b\u6e96\u3058\u305f\u3082\u306e\u3092\u4f5c\u308b\u306e\u304c\u826f\u3044\u3063\u307d\u3044\n\u3068\u308a\u3042\u3048\u305a\u3001LED\u304c\u3064\u3044\u305f\u308a\u304d\u3048\u305f\u308a\u3059\u308bHID\u30c7\u30d0\u30a4\u30b9\u3092\u4f5c\u3063\u3066\u307f\u308b\u3002\n\n\n\u8abf\u67fb\n\nUSB\u306e\u4ed5\u69d8\n\n\nhttp://www.picfun.com/usb00.html\nhttp://vusb.wikidot.com/usb-device-classes\n\n\nHID\u3067\u30b7\u30ea\u30a2\u30eb\u901a\u4fe1\n\n\nhttp://rayshobby.net/?p=7363\n/dev/tty*\u304c\u3067\u304d\u308b\u308f\u3051\u3067\u306f\u306a\u3044\u3002\u72ec\u81ea\u306e\u30a2\u30d7\u30ea\u304c\u5fc5\u8981\u3002\n\u901f\u5ea6\u304c\u9045\u3044\u306e\u304c\u554f\u984c\u3060\u305d\u3046\u3060\u3002\nArduinoIDE\u306eUSBasp\u3067\u4f7f\u3048\u308b\u30d6\u30fc\u30c8\u30ed\u30fc\u30c0\u304c\u3042\u308b\n\n\nUSBaspx\n\n\nhttp://d.hatena.ne.jp/deb/20110103/1294060194\n\n\nRuby\u3067libusb\n\n\nhttps://github.com/larskanis/libusb\nhost\u5074\u306f\u3053\u308c\u3067\u3064\u304f\u308d\u3046\n\n\nHID\u30c7\u30d0\u30a4\u30b9\u3092\u4f5c\u308a\u306a\u304c\u3089\u89e3\u8aac\n\n\nhttp://jsdiy.web.fc2.com/vusb_hid/\n\n\n\n\u30ad\u30fc\u30ef\u30fc\u30c9\u304c\u308f\u304b\u308b\u3068\u3069\u3093\u3069\u3093\u60c5\u5831\u304c\u307f\u3064\u304b\u3063\u3066\u304f\u308b\u3002\n\n\u30cf\u30fc\u30c9\u30a6\u30a8\u30a2\nAVR-CDC\u3068\u304a\u306a\u3058\u3002\nhttp://qiita.com/takeru@github/items/c591323acf24e58ed6c0\nhttp://www.recursion.jp/avrcdc/cdc-ioj.html\n\u30af\u30ea\u30b9\u30bf\u30eb\u3060\u305120MHz\u306a\u306e\u3067\u3001Makefile\u306e\u8a2d\u5b9a\u3092\u5909\u3048\u3066\u3044\u307e\u3059\u3002\n\n\u30bd\u30d5\u30c8\u30a6\u30a8\u30a2\n\n\u30b3\u30f3\u30c8\u30ed\u30fc\u30eb\u8ee2\u9001\u30678byte\u9001\u4fe1\u30018byte\u53d7\u4fe1\u304c\u3067\u304d\u308b\u3088\u3046\u306b\u306a\u3063\u305f\u3002\nusbHidReportDescriptor\u304c\u96e3\u3057\u3044\u3063\u307d\u3044\u304c\u3001\u30b0\u30b0\u3063\u3066\u898b\u3064\u3051\u305f\u79d8\u4f1d\u306e\u30bf\u30ec\u3092\u306a\u3093\u3068\u306a\u304f\u4f7f\u3063\u3066\u3044\u308b\u3002\nhttps://github.com/takeru/hidled\n\nhttps://github.com/larskanis/libusb \u3092\u3044\u308c\u305f \n\n\nbrew install libusb\ngem install libusb\n\n\n\n\nmain.c\n#include <string.h>\n#include <avr/io.h>\n#include <avr/interrupt.h>\n#include <avr/pgmspace.h>\n#include <avr/wdt.h>\n#include <util/delay.h>\n#include \"usbdrv.h\"\n\nuchar recv_buf[8];\nuchar counter = 0;\n\n/*\ntypedef struct usbRequest{\n    uchar       bmRequestType;\n    uchar       bRequest;\n    usbWord_t   wValue;\n    usbWord_t   wIndex;\n    usbWord_t   wLength;\n}usbRequest_t;\n*/\n\nPROGMEM const char usbHidReportDescriptor[USB_CFG_HID_REPORT_DESCRIPTOR_LENGTH] = {\n    0x06, 0x00, 0xff,              // USAGE_PAGE (Generic Desktop)\n    0x09, 0x01,                    // USAGE (Vendor Usage 1)\n    0xa1, 0x01,                    // COLLECTION (Application)\n\n    0x15, 0x00,                    //   LOGICAL_MINIMUM (0)\n    0x26, 0xff, 0x00,              //   LOGICAL_MAXIMUM (255)\n    0x75, 0x08,                    //   REPORT_SIZE (8)\n\n    0x95, 0x08,                    //   REPORT_COUNT (8)\n    0x09, 0x00,                    //   USAGE (Undefined)\n    0xb2, 0x02, 0x01,              //   FEATURE (Data,Var,Abs,Buf)\n\n    0xc0                           // END_COLLECTION\n};\n\n\n/* You need to implement this function ONLY if you provide USB descriptors at\n * runtime (which is an expert feature). It is very similar to\n * usbFunctionSetup() above, but it is called only to request USB descriptor\n * data. See the documentation of usbFunctionSetup() above for more info.\n */\n/*\nusbMsgLen_t usbFunctionDescriptor(struct usbRequest_t *rq)\n{\n}\n*/\n\n\n/* This function is called when the driver receives a SETUP transaction from\n * the host which is not answered by the driver itself (in practice: class and\n * vendor requests). All control transfers start with a SETUP transaction where\n * the host communicates the parameters of the following (optional) data\n * transfer. The SETUP data is available in the 'data' parameter which can\n * (and should) be casted to 'usbRequest_t *' for a more user-friendly access\n * to parameters.\n *\n * If the SETUP indicates a control-in transfer, you should provide the\n * requested data to the driver. There are two ways to transfer this data:\n * (1) Set the global pointer 'usbMsgPtr' to the base of the static RAM data\n * block and return the length of the data in 'usbFunctionSetup()'. The driver\n * will handle the rest. Or (2) return USB_NO_MSG in 'usbFunctionSetup()'. The\n * driver will then call 'usbFunctionRead()' when data is needed. See the\n * documentation for usbFunctionRead() for details.\n *\n * If the SETUP indicates a control-out transfer, the only way to receive the\n * data from the host is through the 'usbFunctionWrite()' call. If you\n * implement this function, you must return USB_NO_MSG in 'usbFunctionSetup()'\n * to indicate that 'usbFunctionWrite()' should be used. See the documentation\n * of this function for more information. If you just want to ignore the data\n * sent by the host, return 0 in 'usbFunctionSetup()'.\n *\n * Note that calls to the functions usbFunctionRead() and usbFunctionWrite()\n * are only done if enabled by the configuration in usbconfig.h.\n */\nusbMsgLen_t usbFunctionSetup(uchar data[8])\n{\n    usbRequest_t *rq = (usbRequest_t*)data;\n\n    if((rq->bmRequestType & USBRQ_TYPE_MASK) == USBRQ_TYPE_CLASS){\n        if(rq->bRequest == USBRQ_HID_SET_REPORT){\n            // host to device\n            return USB_NO_MSG; // => usbFunctionWrite\n        }\n        if(rq->bRequest == USBRQ_HID_GET_REPORT){\n            // device to host\n            return USB_NO_MSG; // => usbFunctionRead\n        }\n    }\n\n    return 0;\n}\n\n/* This function is called by the driver to provide a control transfer's\n * payload data (control-out). It is called in chunks of up to 8 bytes. The\n * total count provided in the current control transfer can be obtained from\n * the 'length' property in the setup data. If an error occurred during\n * processing, return 0xff (== -1). The driver will answer the entire transfer\n * with a STALL token in this case. If you have received the entire payload\n * successfully, return 1. If you expect more data, return 0. If you don't\n * know whether the host will send more data (you should know, the total is\n * provided in the usbFunctionSetup() call!), return 1.\n * NOTE: If you return 0xff for STALL, 'usbFunctionWrite()' may still be called\n * for the remaining data. You must continue to return 0xff for STALL in these\n * calls.\n * In order to get usbFunctionWrite() called, define USB_CFG_IMPLEMENT_FN_WRITE\n * to 1 in usbconfig.h and return 0xff in usbFunctionSetup()..\n */\nuchar usbFunctionWrite(uchar *data, uchar len)\n{\n    // host to device\n    if(len==8){\n        memcpy(recv_buf, data, len);\n        return 1;\n    }else{\n        return -1; // STALL\n    }\n}\n\n/* This function is called by the driver to ask the application for a control\n * transfer's payload data (control-in). It is called in chunks of up to 8\n * bytes each. You should copy the data to the location given by 'data' and\n * return the actual number of bytes copied. If you return less than requested,\n * the control-in transfer is terminated. If you return 0xff, the driver aborts\n * the transfer with a STALL token.\n * In order to get usbFunctionRead() called, define USB_CFG_IMPLEMENT_FN_READ\n * to 1 in usbconfig.h and return 0xff in usbFunctionSetup()..\n */\nuchar usbFunctionRead(uchar *data, uchar len)\n{\n    // device to host\n    if(len==8){\n        //memset(data, 0, len);\n        memcpy(data, recv_buf, len);\n        data[7] = counter++;\n        return len;\n    }else{\n        return -1; // STALL\n    }\n}\n\n/* This function is called by the driver when data is received on an interrupt-\n * or bulk-out endpoint. The endpoint number can be found in the global\n * variable usbRxToken. You must define USB_CFG_IMPLEMENT_FN_WRITEOUT to 1 in\n * usbconfig.h to get this function called.\n */\n /*\nvoid usbFunctionWriteOut(uchar *data, uchar len)\n{\n    usbDisableAllRequests();\n    // ...\n    usbEnableAllRequests();\n}\n*/\n\nstatic void hardwareInit(void)\n{\n    uchar i;\n    USB_CFG_IOPORT = (uchar)~((1<<USB_CFG_DMINUS_BIT)|(1<<USB_CFG_DPLUS_BIT));\n\n    usbDeviceDisconnect();\n    for(i=0; i<10; i++){\n        wdt_reset();\n        _delay_ms(10);\n    }\n    usbDeviceConnect();\n}\n\nint main(void)\n{\n    wdt_enable(WDTO_1S);\n    hardwareInit();\n    usbInit();\n\n    sei();\n    for(;;){\n        wdt_reset();\n        usbPoll();\n    }\n    return 0;\n}\n\n\n\nhidled% AVR_PATH=/Applications/Arduino.app/Contents/Resources/Java/hardware/tools/avr/bin; PATH=$AVR_PATH:$PATH\n\nhidled% make\navr-gcc -I\".\" -I\"./v-usb/usbdrv\"  -mmcu=atmega88p -Wall -gdwarf-2 -DF_CPU=20000000UL -Os -fsigned-char -MD -MP -MT main.o -MF dep/main.o.d  -c  main.c\navr-gcc -I\".\" -I\"./v-usb/usbdrv\"  -mmcu=atmega88p -mmcu=atmega88p -Wall -gdwarf-2 -DF_CPU=20000000UL -Os -fsigned-char -MD -MP -MT usbdrvasm.o -MF dep/usbdrvasm.o.d  -x assembler-with-cpp -Wa,-gdwarf2 -c  v-usb/usbdrv/usbdrvasm.S\navr-gcc -I\".\" -I\"./v-usb/usbdrv\"  -mmcu=atmega88p -Wall -gdwarf-2 -DF_CPU=20000000UL -Os -fsigned-char -MD -MP -MT oddebug.o -MF dep/oddebug.o.d  -c  v-usb/usbdrv/oddebug.c\navr-gcc -I\".\" -I\"./v-usb/usbdrv\"  -mmcu=atmega88p -Wall -gdwarf-2 -DF_CPU=20000000UL -Os -fsigned-char -MD -MP -MT usbdrv.o -MF dep/usbdrv.o.d  -c  v-usb/usbdrv/usbdrv.c\navr-gcc -mmcu=atmega88p  main.o usbdrvasm.o oddebug.o usbdrv.o     -o hidled.elf\navr-objcopy -O ihex -R .eeprom -R .fuse -R .lock -R .signature  hidled.elf hidled.hex\navr-objcopy -j .eeprom --set-section-flags=.eeprom=\"alloc,load\" --change-section-lma .eeprom=0 --no-change-warnings -O ihex hidled.elf hidled.eep || exit 0\navr-objdump -h -S hidled.elf > hidled.lss\n\nhidled% avrdude -C /Applications/Arduino.app/Contents/Resources/Java/hardware/tools/avr/etc/avrdude.conf -P /dev/tty.usbserial-A9005bvI -c avrisp -p m88p -b 19200 -U flash:w:hidled.hex\n\navrdude: AVR device initialized and ready to accept instructions\n\nReading | ################################################## | 100% 0.06s\n\navrdude: Device signature = 0x1e930f\navrdude: NOTE: FLASH memory has been specified, an erase cycle will be performed\n         To disable this feature, specify the -D option.\navrdude: erasing chip\navrdude: reading input file \"hidled.hex\"\navrdude: input file hidled.hex auto detected as Intel Hex\navrdude: writing flash (1582 bytes):\n\nWriting | ################################################## | 100% 2.78s\n\navrdude: 1582 bytes of flash written\navrdude: verifying flash memory against hidled.hex:\navrdude: load data flash data from input file hidled.hex:\navrdude: input file hidled.hex auto detected as Intel Hex\navrdude: input file hidled.hex contains 1582 bytes\navrdude: reading on-chip flash data:\n\nReading | ################################################## | 100% 1.82s\n\navrdude: verifying ...\navrdude: 1582 bytes of flash verified\n\navrdude: safemode: Fuses OK\n\navrdude done.  Thank you.\n\n\nhidled_host.rb\nrequire \"libusb\"\n\ninclude LIBUSB\n\nUSBRQ_HID_GET_REPORT    = 0x01\nUSBRQ_HID_GET_IDLE      = 0x02\nUSBRQ_HID_GET_PROTOCOL  = 0x03\nUSBRQ_HID_SET_REPORT    = 0x09\nUSBRQ_HID_SET_IDLE      = 0x0a\nUSBRQ_HID_SET_PROTOCOL  = 0x0b\n\nusb = LIBUSB::Context.new\n\ndevices = usb.devices(:idVendor => 0x16c0, :idProduct => 0x05dc)\nputs \"devices = #{devices.inspect}\"\nexit if devices.size==0\n\ndevice = devices.first\ndevice.open_interface(0) do |handle|\n  16.times do |n|\n    # send to device\n    data = [n+0,n+1,n+2,n+3,n+4,n+5,n+6,n+7]\n\n    sent_byte_size = handle.control_transfer(\n      :bmRequestType => ENDPOINT_OUT|REQUEST_TYPE_CLASS|RECIPIENT_ENDPOINT,\n      :bRequest      => USBRQ_HID_SET_REPORT,\n      :wValue        => 0x0000,\n      :wIndex        => 0x0000,\n      :dataOut       => data.pack(\"C*\")\n    )\n    puts \"sent_byte_size = #{sent_byte_size}\"\n\n    # receive from device\n    received_bytes = handle.control_transfer(\n      :bmRequestType => ENDPOINT_IN|REQUEST_TYPE_CLASS|RECIPIENT_ENDPOINT,\n      :bRequest      => USBRQ_HID_GET_REPORT,\n      :wValue        => 0x0000,\n      :wIndex        => 0x0000,\n      :dataIn        => 8\n    )\n    puts \"received_bytes = #{received_bytes.unpack('C*').inspect}\"\n  end\nend\n\n\n\nhidled% ruby hidled_host.rb\ndevices = [#<LIBUSB::Device 26/7 16c0:05dc ssktkr.com HID-LED ? (Vendor specific (00,00))>]\nsent_byte_size = 8\nreceived_bytes = [0, 1, 2, 3, 4, 5, 6, 0]\nsent_byte_size = 8\nreceived_bytes = [1, 2, 3, 4, 5, 6, 7, 1]\nsent_byte_size = 8\nreceived_bytes = [2, 3, 4, 5, 6, 7, 8, 2]\nsent_byte_size = 8\nreceived_bytes = [3, 4, 5, 6, 7, 8, 9, 3]\nsent_byte_size = 8\nreceived_bytes = [4, 5, 6, 7, 8, 9, 10, 4]\nsent_byte_size = 8\nreceived_bytes = [5, 6, 7, 8, 9, 10, 11, 5]\nsent_byte_size = 8\nreceived_bytes = [6, 7, 8, 9, 10, 11, 12, 6]\nsent_byte_size = 8\nreceived_bytes = [7, 8, 9, 10, 11, 12, 13, 7]\nsent_byte_size = 8\nreceived_bytes = [8, 9, 10, 11, 12, 13, 14, 8]\nsent_byte_size = 8\nreceived_bytes = [9, 10, 11, 12, 13, 14, 15, 9]\nsent_byte_size = 8\nreceived_bytes = [10, 11, 12, 13, 14, 15, 16, 10]\nsent_byte_size = 8\nreceived_bytes = [11, 12, 13, 14, 15, 16, 17, 11]\nsent_byte_size = 8\nreceived_bytes = [12, 13, 14, 15, 16, 17, 18, 12]\nsent_byte_size = 8\nreceived_bytes = [13, 14, 15, 16, 17, 18, 19, 13]\nsent_byte_size = 8\nreceived_bytes = [14, 15, 16, 17, 18, 19, 20, 14]\nsent_byte_size = 8\nreceived_bytes = [15, 16, 17, 18, 19, 20, 21, 15]\n\n\n\u307e\u3068\u3081\n\nHID\u30af\u30e9\u30b9\u306e\u30c7\u30d0\u30a4\u30b9\u3092\u3064\u304f\u3063\u3066Ruby\u3067\u64cd\u4f5c\u3067\u304d\u308b\u3088\u3046\u306b\u306a\u3063\u305f\u3002\n\u30cf\u30d6\u3092\u901a\u3057\u3066\u3082\u76f4\u63a5\u63a5\u7d9a\u3067\u3082\u3061\u3083\u3093\u3068\u52d5\u304f\n\u30c7\u30b9\u30af\u30ea\u30d7\u30bf\u306f\u5f8c\u3005\u8a73\u3057\u3044\u3053\u3068\u3092\u8abf\u3079\u308b\u304b\u3082\u3057\u308c\u306a\u3044\u3002\n\u30a4\u30f3\u30bf\u30e9\u30d7\u30c8\u8ee2\u9001\u306f\u307e\u3060\u3084\u3063\u3066\u3044\u306a\u3044\u3002\nTODO\n\n\n\u53d7\u4fe1\u30c7\u30fc\u30bf\u306b\u3088\u3063\u3066LED\u3092\u70b9\u3051\u305f\u308a\u6d88\u3057\u305f\u308a\u3059\u308b\n\u30b7\u30ea\u30a2\u30eb\u30c7\u30d0\u30c3\u30b0\u3067\u304d\u308b\u3088\u3046\u306b\u3059\u308b\n\u30a4\u30f3\u30bf\u30e9\u30d7\u30c8\u8ee2\u9001\n\n\n\n\n\n\n(\u7d9a\u304d\u305d\u306e3\u2192 http://qiita.com/takeru@github/items/23f41616db9367ea26b5)\n\n\n\u3053\u3053\u307e\u3067\u306e\u3042\u3089\u3059\u3058\n---------------\n* http://qiita.com/takeru@github/items/c591323acf24e58ed6c0\n* AVR\u306bUSB\u30b1\u30fc\u30d6\u30eb\u76f4\u7d50\u3067USB\u30c7\u30d0\u30a4\u30b9\u304c\u4f5c\u308c\u308bV-USB\n* AVR-CDC\u3067\u30b7\u30ea\u30a2\u30eb\u8aad\u307f\u66f8\u304d\u30c7\u30d0\u30a4\u30b9\u306f\u3067\u304d\u305f\u304c\u30a4\u30de\u30a4\u30c1\n* HID\u306b\u6e96\u3058\u305f\u3082\u306e\u3092\u4f5c\u308b\u306e\u304c\u826f\u3044\u3063\u307d\u3044\n* \u3068\u308a\u3042\u3048\u305a\u3001LED\u304c\u3064\u3044\u305f\u308a\u304d\u3048\u305f\u308a\u3059\u308bHID\u30c7\u30d0\u30a4\u30b9\u3092\u4f5c\u3063\u3066\u307f\u308b\u3002\n\n\n\u8abf\u67fb\n----\n\n* USB\u306e\u4ed5\u69d8\n * http://www.picfun.com/usb00.html\n * http://vusb.wikidot.com/usb-device-classes\n* HID\u3067\u30b7\u30ea\u30a2\u30eb\u901a\u4fe1\n * http://rayshobby.net/?p=7363\n * /dev/tty*\u304c\u3067\u304d\u308b\u308f\u3051\u3067\u306f\u306a\u3044\u3002\u72ec\u81ea\u306e\u30a2\u30d7\u30ea\u304c\u5fc5\u8981\u3002\n * \u901f\u5ea6\u304c\u9045\u3044\u306e\u304c\u554f\u984c\u3060\u305d\u3046\u3060\u3002\n * ArduinoIDE\u306eUSBasp\u3067\u4f7f\u3048\u308b\u30d6\u30fc\u30c8\u30ed\u30fc\u30c0\u304c\u3042\u308b\n* USBaspx\n * http://d.hatena.ne.jp/deb/20110103/1294060194\n* Ruby\u3067libusb\n * https://github.com/larskanis/libusb\n * host\u5074\u306f\u3053\u308c\u3067\u3064\u304f\u308d\u3046\n* HID\u30c7\u30d0\u30a4\u30b9\u3092\u4f5c\u308a\u306a\u304c\u3089\u89e3\u8aac\n * http://jsdiy.web.fc2.com/vusb_hid/\n\n\n\u30ad\u30fc\u30ef\u30fc\u30c9\u304c\u308f\u304b\u308b\u3068\u3069\u3093\u3069\u3093\u60c5\u5831\u304c\u307f\u3064\u304b\u3063\u3066\u304f\u308b\u3002\n\n\n\n\u30cf\u30fc\u30c9\u30a6\u30a8\u30a2\n----------\nAVR-CDC\u3068\u304a\u306a\u3058\u3002\nhttp://qiita.com/takeru@github/items/c591323acf24e58ed6c0\nhttp://www.recursion.jp/avrcdc/cdc-ioj.html\n\n\u30af\u30ea\u30b9\u30bf\u30eb\u3060\u305120MHz\u306a\u306e\u3067\u3001Makefile\u306e\u8a2d\u5b9a\u3092\u5909\u3048\u3066\u3044\u307e\u3059\u3002\n\n\n\u30bd\u30d5\u30c8\u30a6\u30a8\u30a2\n----------\n\n* \u30b3\u30f3\u30c8\u30ed\u30fc\u30eb\u8ee2\u9001\u30678byte\u9001\u4fe1\u30018byte\u53d7\u4fe1\u304c\u3067\u304d\u308b\u3088\u3046\u306b\u306a\u3063\u305f\u3002\n* usbHidReportDescriptor\u304c\u96e3\u3057\u3044\u3063\u307d\u3044\u304c\u3001\u30b0\u30b0\u3063\u3066\u898b\u3064\u3051\u305f\u79d8\u4f1d\u306e\u30bf\u30ec\u3092\u306a\u3093\u3068\u306a\u304f\u4f7f\u3063\u3066\u3044\u308b\u3002\n* https://github.com/takeru/hidled\n* https://github.com/larskanis/libusb \u3092\u3044\u308c\u305f \n * brew install libusb\n * gem install libusb\n\n\n```main.c\n#include <string.h>\n#include <avr/io.h>\n#include <avr/interrupt.h>\n#include <avr/pgmspace.h>\n#include <avr/wdt.h>\n#include <util/delay.h>\n#include \"usbdrv.h\"\n\nuchar recv_buf[8];\nuchar counter = 0;\n\n/*\ntypedef struct usbRequest{\n    uchar       bmRequestType;\n    uchar       bRequest;\n    usbWord_t   wValue;\n    usbWord_t   wIndex;\n    usbWord_t   wLength;\n}usbRequest_t;\n*/\n\nPROGMEM const char usbHidReportDescriptor[USB_CFG_HID_REPORT_DESCRIPTOR_LENGTH] = {\n    0x06, 0x00, 0xff,              // USAGE_PAGE (Generic Desktop)\n    0x09, 0x01,                    // USAGE (Vendor Usage 1)\n    0xa1, 0x01,                    // COLLECTION (Application)\n\n    0x15, 0x00,                    //   LOGICAL_MINIMUM (0)\n    0x26, 0xff, 0x00,              //   LOGICAL_MAXIMUM (255)\n    0x75, 0x08,                    //   REPORT_SIZE (8)\n\n    0x95, 0x08,                    //   REPORT_COUNT (8)\n    0x09, 0x00,                    //   USAGE (Undefined)\n    0xb2, 0x02, 0x01,              //   FEATURE (Data,Var,Abs,Buf)\n\n    0xc0                           // END_COLLECTION\n};\n\n\n/* You need to implement this function ONLY if you provide USB descriptors at\n * runtime (which is an expert feature). It is very similar to\n * usbFunctionSetup() above, but it is called only to request USB descriptor\n * data. See the documentation of usbFunctionSetup() above for more info.\n */\n/*\nusbMsgLen_t usbFunctionDescriptor(struct usbRequest_t *rq)\n{\n}\n*/\n\n\n/* This function is called when the driver receives a SETUP transaction from\n * the host which is not answered by the driver itself (in practice: class and\n * vendor requests). All control transfers start with a SETUP transaction where\n * the host communicates the parameters of the following (optional) data\n * transfer. The SETUP data is available in the 'data' parameter which can\n * (and should) be casted to 'usbRequest_t *' for a more user-friendly access\n * to parameters.\n *\n * If the SETUP indicates a control-in transfer, you should provide the\n * requested data to the driver. There are two ways to transfer this data:\n * (1) Set the global pointer 'usbMsgPtr' to the base of the static RAM data\n * block and return the length of the data in 'usbFunctionSetup()'. The driver\n * will handle the rest. Or (2) return USB_NO_MSG in 'usbFunctionSetup()'. The\n * driver will then call 'usbFunctionRead()' when data is needed. See the\n * documentation for usbFunctionRead() for details.\n *\n * If the SETUP indicates a control-out transfer, the only way to receive the\n * data from the host is through the 'usbFunctionWrite()' call. If you\n * implement this function, you must return USB_NO_MSG in 'usbFunctionSetup()'\n * to indicate that 'usbFunctionWrite()' should be used. See the documentation\n * of this function for more information. If you just want to ignore the data\n * sent by the host, return 0 in 'usbFunctionSetup()'.\n *\n * Note that calls to the functions usbFunctionRead() and usbFunctionWrite()\n * are only done if enabled by the configuration in usbconfig.h.\n */\nusbMsgLen_t usbFunctionSetup(uchar data[8])\n{\n    usbRequest_t *rq = (usbRequest_t*)data;\n\n    if((rq->bmRequestType & USBRQ_TYPE_MASK) == USBRQ_TYPE_CLASS){\n        if(rq->bRequest == USBRQ_HID_SET_REPORT){\n            // host to device\n            return USB_NO_MSG; // => usbFunctionWrite\n        }\n        if(rq->bRequest == USBRQ_HID_GET_REPORT){\n            // device to host\n            return USB_NO_MSG; // => usbFunctionRead\n        }\n    }\n\n    return 0;\n}\n\n/* This function is called by the driver to provide a control transfer's\n * payload data (control-out). It is called in chunks of up to 8 bytes. The\n * total count provided in the current control transfer can be obtained from\n * the 'length' property in the setup data. If an error occurred during\n * processing, return 0xff (== -1). The driver will answer the entire transfer\n * with a STALL token in this case. If you have received the entire payload\n * successfully, return 1. If you expect more data, return 0. If you don't\n * know whether the host will send more data (you should know, the total is\n * provided in the usbFunctionSetup() call!), return 1.\n * NOTE: If you return 0xff for STALL, 'usbFunctionWrite()' may still be called\n * for the remaining data. You must continue to return 0xff for STALL in these\n * calls.\n * In order to get usbFunctionWrite() called, define USB_CFG_IMPLEMENT_FN_WRITE\n * to 1 in usbconfig.h and return 0xff in usbFunctionSetup()..\n */\nuchar usbFunctionWrite(uchar *data, uchar len)\n{\n    // host to device\n    if(len==8){\n        memcpy(recv_buf, data, len);\n        return 1;\n    }else{\n        return -1; // STALL\n    }\n}\n\n/* This function is called by the driver to ask the application for a control\n * transfer's payload data (control-in). It is called in chunks of up to 8\n * bytes each. You should copy the data to the location given by 'data' and\n * return the actual number of bytes copied. If you return less than requested,\n * the control-in transfer is terminated. If you return 0xff, the driver aborts\n * the transfer with a STALL token.\n * In order to get usbFunctionRead() called, define USB_CFG_IMPLEMENT_FN_READ\n * to 1 in usbconfig.h and return 0xff in usbFunctionSetup()..\n */\nuchar usbFunctionRead(uchar *data, uchar len)\n{\n    // device to host\n    if(len==8){\n        //memset(data, 0, len);\n        memcpy(data, recv_buf, len);\n        data[7] = counter++;\n        return len;\n    }else{\n        return -1; // STALL\n    }\n}\n\n/* This function is called by the driver when data is received on an interrupt-\n * or bulk-out endpoint. The endpoint number can be found in the global\n * variable usbRxToken. You must define USB_CFG_IMPLEMENT_FN_WRITEOUT to 1 in\n * usbconfig.h to get this function called.\n */\n /*\nvoid usbFunctionWriteOut(uchar *data, uchar len)\n{\n    usbDisableAllRequests();\n    // ...\n    usbEnableAllRequests();\n}\n*/\n\nstatic void hardwareInit(void)\n{\n    uchar i;\n    USB_CFG_IOPORT = (uchar)~((1<<USB_CFG_DMINUS_BIT)|(1<<USB_CFG_DPLUS_BIT));\n\n    usbDeviceDisconnect();\n    for(i=0; i<10; i++){\n        wdt_reset();\n        _delay_ms(10);\n    }\n    usbDeviceConnect();\n}\n\nint main(void)\n{\n    wdt_enable(WDTO_1S);\n    hardwareInit();\n    usbInit();\n\n    sei();\n    for(;;){\n        wdt_reset();\n        usbPoll();\n    }\n    return 0;\n}\n\n```\n\n```\nhidled% AVR_PATH=/Applications/Arduino.app/Contents/Resources/Java/hardware/tools/avr/bin; PATH=$AVR_PATH:$PATH\n\nhidled% make\navr-gcc -I\".\" -I\"./v-usb/usbdrv\"  -mmcu=atmega88p -Wall -gdwarf-2 -DF_CPU=20000000UL -Os -fsigned-char -MD -MP -MT main.o -MF dep/main.o.d  -c  main.c\navr-gcc -I\".\" -I\"./v-usb/usbdrv\"  -mmcu=atmega88p -mmcu=atmega88p -Wall -gdwarf-2 -DF_CPU=20000000UL -Os -fsigned-char -MD -MP -MT usbdrvasm.o -MF dep/usbdrvasm.o.d  -x assembler-with-cpp -Wa,-gdwarf2 -c  v-usb/usbdrv/usbdrvasm.S\navr-gcc -I\".\" -I\"./v-usb/usbdrv\"  -mmcu=atmega88p -Wall -gdwarf-2 -DF_CPU=20000000UL -Os -fsigned-char -MD -MP -MT oddebug.o -MF dep/oddebug.o.d  -c  v-usb/usbdrv/oddebug.c\navr-gcc -I\".\" -I\"./v-usb/usbdrv\"  -mmcu=atmega88p -Wall -gdwarf-2 -DF_CPU=20000000UL -Os -fsigned-char -MD -MP -MT usbdrv.o -MF dep/usbdrv.o.d  -c  v-usb/usbdrv/usbdrv.c\navr-gcc -mmcu=atmega88p  main.o usbdrvasm.o oddebug.o usbdrv.o     -o hidled.elf\navr-objcopy -O ihex -R .eeprom -R .fuse -R .lock -R .signature  hidled.elf hidled.hex\navr-objcopy -j .eeprom --set-section-flags=.eeprom=\"alloc,load\" --change-section-lma .eeprom=0 --no-change-warnings -O ihex hidled.elf hidled.eep || exit 0\navr-objdump -h -S hidled.elf > hidled.lss\n```\n\n```\nhidled% avrdude -C /Applications/Arduino.app/Contents/Resources/Java/hardware/tools/avr/etc/avrdude.conf -P /dev/tty.usbserial-A9005bvI -c avrisp -p m88p -b 19200 -U flash:w:hidled.hex\n\navrdude: AVR device initialized and ready to accept instructions\n\nReading | ################################################## | 100% 0.06s\n\navrdude: Device signature = 0x1e930f\navrdude: NOTE: FLASH memory has been specified, an erase cycle will be performed\n         To disable this feature, specify the -D option.\navrdude: erasing chip\navrdude: reading input file \"hidled.hex\"\navrdude: input file hidled.hex auto detected as Intel Hex\navrdude: writing flash (1582 bytes):\n\nWriting | ################################################## | 100% 2.78s\n\navrdude: 1582 bytes of flash written\navrdude: verifying flash memory against hidled.hex:\navrdude: load data flash data from input file hidled.hex:\navrdude: input file hidled.hex auto detected as Intel Hex\navrdude: input file hidled.hex contains 1582 bytes\navrdude: reading on-chip flash data:\n\nReading | ################################################## | 100% 1.82s\n\navrdude: verifying ...\navrdude: 1582 bytes of flash verified\n\navrdude: safemode: Fuses OK\n\navrdude done.  Thank you.\n```\n\n\n\n```hidled_host.rb\nrequire \"libusb\"\n\ninclude LIBUSB\n\nUSBRQ_HID_GET_REPORT    = 0x01\nUSBRQ_HID_GET_IDLE      = 0x02\nUSBRQ_HID_GET_PROTOCOL  = 0x03\nUSBRQ_HID_SET_REPORT    = 0x09\nUSBRQ_HID_SET_IDLE      = 0x0a\nUSBRQ_HID_SET_PROTOCOL  = 0x0b\n\nusb = LIBUSB::Context.new\n\ndevices = usb.devices(:idVendor => 0x16c0, :idProduct => 0x05dc)\nputs \"devices = #{devices.inspect}\"\nexit if devices.size==0\n\ndevice = devices.first\ndevice.open_interface(0) do |handle|\n  16.times do |n|\n    # send to device\n    data = [n+0,n+1,n+2,n+3,n+4,n+5,n+6,n+7]\n\n    sent_byte_size = handle.control_transfer(\n      :bmRequestType => ENDPOINT_OUT|REQUEST_TYPE_CLASS|RECIPIENT_ENDPOINT,\n      :bRequest      => USBRQ_HID_SET_REPORT,\n      :wValue        => 0x0000,\n      :wIndex        => 0x0000,\n      :dataOut       => data.pack(\"C*\")\n    )\n    puts \"sent_byte_size = #{sent_byte_size}\"\n\n    # receive from device\n    received_bytes = handle.control_transfer(\n      :bmRequestType => ENDPOINT_IN|REQUEST_TYPE_CLASS|RECIPIENT_ENDPOINT,\n      :bRequest      => USBRQ_HID_GET_REPORT,\n      :wValue        => 0x0000,\n      :wIndex        => 0x0000,\n      :dataIn        => 8\n    )\n    puts \"received_bytes = #{received_bytes.unpack('C*').inspect}\"\n  end\nend\n\n```\n\n\n\n```\nhidled% ruby hidled_host.rb\ndevices = [#<LIBUSB::Device 26/7 16c0:05dc ssktkr.com HID-LED ? (Vendor specific (00,00))>]\nsent_byte_size = 8\nreceived_bytes = [0, 1, 2, 3, 4, 5, 6, 0]\nsent_byte_size = 8\nreceived_bytes = [1, 2, 3, 4, 5, 6, 7, 1]\nsent_byte_size = 8\nreceived_bytes = [2, 3, 4, 5, 6, 7, 8, 2]\nsent_byte_size = 8\nreceived_bytes = [3, 4, 5, 6, 7, 8, 9, 3]\nsent_byte_size = 8\nreceived_bytes = [4, 5, 6, 7, 8, 9, 10, 4]\nsent_byte_size = 8\nreceived_bytes = [5, 6, 7, 8, 9, 10, 11, 5]\nsent_byte_size = 8\nreceived_bytes = [6, 7, 8, 9, 10, 11, 12, 6]\nsent_byte_size = 8\nreceived_bytes = [7, 8, 9, 10, 11, 12, 13, 7]\nsent_byte_size = 8\nreceived_bytes = [8, 9, 10, 11, 12, 13, 14, 8]\nsent_byte_size = 8\nreceived_bytes = [9, 10, 11, 12, 13, 14, 15, 9]\nsent_byte_size = 8\nreceived_bytes = [10, 11, 12, 13, 14, 15, 16, 10]\nsent_byte_size = 8\nreceived_bytes = [11, 12, 13, 14, 15, 16, 17, 11]\nsent_byte_size = 8\nreceived_bytes = [12, 13, 14, 15, 16, 17, 18, 12]\nsent_byte_size = 8\nreceived_bytes = [13, 14, 15, 16, 17, 18, 19, 13]\nsent_byte_size = 8\nreceived_bytes = [14, 15, 16, 17, 18, 19, 20, 14]\nsent_byte_size = 8\nreceived_bytes = [15, 16, 17, 18, 19, 20, 21, 15]\n```\n\n\n\n\u307e\u3068\u3081\n-----\n* HID\u30af\u30e9\u30b9\u306e\u30c7\u30d0\u30a4\u30b9\u3092\u3064\u304f\u3063\u3066Ruby\u3067\u64cd\u4f5c\u3067\u304d\u308b\u3088\u3046\u306b\u306a\u3063\u305f\u3002\n* \u30cf\u30d6\u3092\u901a\u3057\u3066\u3082\u76f4\u63a5\u63a5\u7d9a\u3067\u3082\u3061\u3083\u3093\u3068\u52d5\u304f\n* \u30c7\u30b9\u30af\u30ea\u30d7\u30bf\u306f\u5f8c\u3005\u8a73\u3057\u3044\u3053\u3068\u3092\u8abf\u3079\u308b\u304b\u3082\u3057\u308c\u306a\u3044\u3002\n* \u30a4\u30f3\u30bf\u30e9\u30d7\u30c8\u8ee2\u9001\u306f\u307e\u3060\u3084\u3063\u3066\u3044\u306a\u3044\u3002\n* TODO\n * \u53d7\u4fe1\u30c7\u30fc\u30bf\u306b\u3088\u3063\u3066LED\u3092\u70b9\u3051\u305f\u308a\u6d88\u3057\u305f\u308a\u3059\u308b\n * \u30b7\u30ea\u30a2\u30eb\u30c7\u30d0\u30c3\u30b0\u3067\u304d\u308b\u3088\u3046\u306b\u3059\u308b\n * \u30a4\u30f3\u30bf\u30e9\u30d7\u30c8\u8ee2\u9001\n\n\n![\u30b9\u30af\u30ea\u30fc\u30f3\u30b7\u30e7\u30c3\u30c8 2014-05-18 21.28.59.png](https://qiita-image-store.s3.amazonaws.com/0/16626/a99210f1-98d7-f0f7-5c98-6781eee2164e.png \"\u30b9\u30af\u30ea\u30fc\u30f3\u30b7\u30e7\u30c3\u30c8 2014-05-18 21.28.59.png\")\n\n\n", "tags": ["USB", "AVR", "Arduino"]}