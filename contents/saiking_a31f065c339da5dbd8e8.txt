{"context": " More than 1 year has passed since last update.\n\n\u30c6\u30b9\u30c8\u53ef\u80fd\u306a\u968e\u5c64\u69cb\u9020\u306e\u8a2d\u8a08\u3092\u76ee\u6307\u3059\u3002\n\u3044\u308d\u3044\u308d\u8a2d\u8a08\u306e\u66f8\u7c4d\u3001\u8cc7\u6599\u3092\u898b\u3066\u304d\u305f\u304c\u3001\u7406\u89e3\u3059\u308b\u306e\u306b\u7d50\u69cb\u6642\u9593\u304c\u304b\u304b\u308b\u3002\n\u30af\u30ea\u30fc\u30f3\u30a2\u30fc\u30ad\u30c6\u30af\u30c1\u30e3\u306e\u8cc7\u6599\u3092\u898b\u305f\u3068\u304d\u306a\u3093\u3066\u5206\u304b\u308a\u3084\u3059\u3044\u3093\u3060\u3068\u601d\u3063\u305f\u306e\u304c\u59cb\u307e\u308a\u3002\n\n\u53c2\u8003\u306b\u3057\u305f\u8cc7\u6599\n\u4ee5\u4e0b\u306e\u30ea\u30f3\u30af\u3042\u305f\u308a\u304c\u8cc7\u6599\n\u30fb\u6301\u7d9a\u53ef\u80fd\u306a\u958b\u767a\u3092\u76ee\u6307\u3059 ~ \u30c9\u30e1\u30a4\u30f3\u30fb\u30e6\u30fc\u30b9\u30b1\u30fc\u30b9\u99c6\u52d5\uff08\u30af\u30ea\u30fc\u30f3\u30a2\u30fc\u30ad\u30c6\u30af\u30c1\u30e3\uff09 + \u5358\u65b9\u5411\u306b\u5236\u9650\u3057\u305f\u51e6\u7406 + FRP\n\u30fb\u30af\u30ea\u30fc\u30f3\u30a2\u30fc\u30ad\u30c6\u30af\u30c1\u30e3(The Clean Architecture\u7ffb\u8a33)\n\u30fb\u30c9\u30e1\u30a4\u30f3\u30e2\u30c7\u30eb\u4e2d\u5fc3\u306e\u30a2\u30fc\u30ad\u30c6\u30af\u30c1\u30e3\n\u30fbClean Architecture\u3067\u8a2d\u8a08\u3057\u3066RxJS\u3092\u4f7f\u3063\u305f\u8a71\n\n\u30ad\u30e5\u30fc\u30d6\u3092\u56de\u3059\n\u81ea\u5206\u3067\u5b9f\u88c5\u3057\u3066\u7406\u89e3\u3057\u3088\u3046\u3068\u601d\u3063\u3066\u4f5c\u3063\u3066\u307f\u307e\u3057\u305f\u3002\n\u30c9\u30e1\u30a4\u30f3\u3000\u30ad\u30e5\u30fc\u30d6\n\u30e6\u30fc\u30b9\u30b1\u30fc\u30b9\u3000\uff58\u8ef8\u309230\u5ea6\u56de\u8ee2\u3057\u3066\u7d50\u679c\u3092\u8868\u793a\u3059\u308b\u3002\n\n\u30bd\u30fc\u30b9\u30b3\u30fc\u30c9\ndomain\n\nCCube.h\n#pragma once\n#define _USE_MATH_DEFINES\n#include <cmath>\n#include <list>\n#include \"Cpoint.h\"\nusing namespace std;\nnamespace domain{\n    class CCube\n    {\n    public:\n        CCube(){}\n        ~CCube(void){}\n        void add(CCpoint value){m_cube.push_back(value);}\n        CCube kaitenX(double value);\n        CCube kaitenY(double value);\n        CCube kaitenZ(double value);\n        CPOINT_TABLE_STRUCT draw();\n    private:\n        list<CCpoint> m_cube;\n\n    };\n}\n\n\n\n\nCCube.cpp\n#include \"StdAfx.h\"\n#include \"CCube.h\"\n\n\nnamespace domain{\n    CCube CCube::kaitenX(double value)\n    {\n        CCube sq;\n        for(list<CCpoint>::iterator it =m_cube.begin(); it != m_cube.end(); ++it)\n        {\n            sq.add(it->rotX(value));\n        }\n        return sq;\n\n\n    }\n    CCube CCube::kaitenY(double value)\n    {\n        CCube sq;\n        for(list<CCpoint>::iterator it =m_cube.begin(); it != m_cube.end(); ++it)\n        {\n            sq.add(it->rotY(value));\n        }\n        return sq;\n    }\n    CCube CCube::kaitenZ(double value)\n    {\n        CCube sq;\n        for(list<CCpoint>::iterator it =m_cube.begin(); it != m_cube.end(); ++it)\n        {\n            sq.add(it->rotZ(value));\n        }\n        return sq;\n    }\n    CPOINT_TABLE_STRUCT CCube::draw()\n    {\n        CPOINT_TABLE_STRUCT pointTable;\n        for(list<CCpoint>::iterator it =m_cube.begin(); it != m_cube.end(); ++it)\n        {\n            pointTable.point.push_back(it->draw());\n        }\n        return pointTable;\n    }\n\n\n\n\nCPoint.h\n#pragma once\n#include <list>\n#include \"CVectol.h\"\nusing namespace std;\nnamespace domain{\n    typedef struct {\n        double x;\n        double y;\n        double z;\n    }CPOINT_STRUCT; \n    typedef struct {\n        list<CPOINT_STRUCT> point;\n    }CPOINT_TABLE_STRUCT;   \n    class CCpoint\n    {\n    public:\n        CCpoint(double x,double y,double z):m_x(x),m_y(y),m_z(z){};\n        ~CCpoint(void){};\n        CCpoint rotX(double value);\n        CCpoint rotY(double value);\n        CCpoint rotZ(double value);\n        bool eq(CCpoint& value);\n        CPOINT_STRUCT draw(){\n            CPOINT_STRUCT str;\n            str.x=m_x.draw();\n            str.y=m_y.draw();\n            str.z=m_z.draw();\n            return str;\n        }\n\n    private:\n        CVectol m_x;\n        CVectol m_y;\n        CVectol m_z;\n    };\n}\n\n\n\n\n\nCPoint.cpp\n#include \"StdAfx.h\"\n#include \"Cpoint.h\"\n\n\nnamespace domain{\n    CCpoint CCpoint::rotX(double value)\n    {\n        double y=m_y.degCos(value)-m_z.degSin(value);\n        double z=m_y.degSin(value)+m_z.degCos(value);\n        double x=m_x.degCos(0);\n        return CCpoint(x,y,z);\n    };\n    CCpoint CCpoint::rotY(double value)\n    {\n        double x=m_x.degCos(value)+m_z.degSin(value);\n        double z=-m_z.degSin(value)+m_z.degCos(value);\n        double y=m_x.degCos(0);\n        return CCpoint(x,y,z);\n    };\n    CCpoint CCpoint::rotZ(double value)\n    {\n        double x=m_x.degCos(value)-m_y.degSin(value);\n        double y=m_x.degSin(value)+m_y.degCos(value);\n        double z=m_x.degCos(0);\n        return CCpoint(x,y,z);\n    };\n    bool CCpoint::eq(CCpoint& value)\n    {\n        if(!m_x.eq(value.m_x)) return false;\n        if(!m_y.eq(value.m_y)) return false;\n        if(!m_z.eq(value.m_z)) return false;\n        return true;\n    };\n\n}\n\n\n\nCVectol.h\n#pragma once\n#define _USE_MATH_DEFINES\n#include <math.h>\nnamespace domain{\n    class CVectol\n    {\n    public:\n        CVectol(double value):m_value(value){}\n        ~CVectol(void){}\n        double degSin(double value){return m_value*sin(deg2rad(value));}\n        double degCos(double value){return m_value*cos(deg2rad(value));}\n        bool eq(CVectol value){ return (value.m_value!=m_value)?false:true;}\n        double draw(){return m_value;}\n    private:\n        double deg2rad(double value){return M_PI*value/180.0l;}\n        double m_value;\n\n    };\n}\n\n\n\n\nuse case\n\nCDo.h\n#pragma once\n#include \"CCube.h\"\n#include \"CKaiten.h\"\n#include \"CCDraw.h\"\nnamespace useCase\n{\n\n    class CDo\n    {\n    public:\n        CDo(domain::CCube& cube):m_cube(cube){}\n        void start(double value)\n        {\n\n            IKaitenPtr kai = IKaitenPtr(new interfaceAdapter::CKaiten());\n            kai->kaiten(m_cube,value);\n            IDrawerPtr drawer = IDrawerPtr(new interfaceAdapter::CCDrawer());\n            drawer->draw(m_cube);\n        }\n    private :\n        domain::CCube& m_cube;\n    };\n}\n\n\n\nIDrawer.h\n#pragma once\n#include \"CCube.h\"\n#include <boost\\shared_ptr.hpp>\nnamespace useCase\n{\n    class IDrawer\n    {\n    public:\n        virtual ~IDrawer(){}\n        virtual void draw(domain::CCube& cube)=0;\n\n    };\n    typedef boost::shared_ptr<IDrawer> IDrawerPtr;\n\n}\n\n\n\n\nIKaiten.h\n#pragma once\n#include \"CCube.h\"\n#include <boost\\shared_ptr.hpp>\nnamespace useCase\n{\n    class IKaiten\n    {\n    public:\n        virtual ~IKaiten(){}\n        virtual void kaiten(domain::CCube& sqr,double angl)=0;\n\n    };\n    typedef boost::shared_ptr<IKaiten> IKaitenPtr;\n\n}\n\n\n\ninterface Adapter\n\nCKaiten.h\n#pragma once\n#include \"CCube.h\"\n#include <boost\\shared_ptr.hpp>\nnamespace useCase\n{\n    class IKaiten\n    {\n    public:\n        virtual ~IKaiten(){}\n        virtual void kaiten(domain::CCube& sqr,double angl)=0;\n\n    };\n    typedef boost::shared_ptr<IKaiten> IKaitenPtr;\n\n}\n\n\n\n\nCCDraw.h\n#pragma once\n#include <iostream>\n#include \"CCube.h\"\n#include \"IDrawer.h\"\nusing namespace std;\nnamespace interfaceAdapter\n{\n\n    class CCDrawer:public useCase::IDrawer\n    {\n    public:\n        CCDrawer(){}\n        ~CCDrawer(){}\n        void draw( domain::CCube& cube )\n        {\n\n            domain::CPOINT_TABLE_STRUCT pointTable=cube.draw();//sqrt.drawX();\n\n            for(list<domain::CPOINT_STRUCT>::iterator it =pointTable.point.begin(); it != pointTable.point.end(); ++it)\n            {\n                cout <<\"x=\"<<it->x<<\"y=\"<<it->y<<\"z=\"<<it->z<<endl;\n            }\n        }\n\n    };\n}\n\n\ninit\n\nCCubeBuilder.h\n#pragma once\n#include \"IBuilder.h\"\nnamespace init{\n    class CCubeBuilder:public IBuilder\n    {\n    public:\n        CCubeBuilder(void){}\n        ~CCubeBuilder(void){}\n        void make()\n        {\n            double x[]={10,10,-10,-10};\n            double y[]={-10,10,10,-10};\n            double z[]={10,-10};\n            for(int i=0;i<8;i++)\n            {\n                int ii=i%4;\n                int iii=i/4;\n                domain::CCpoint point(x[ii],y[ii],z[iii]);\n                m_cube.add(point);\n            }\n        }\n        domain::CCube getResult()\n        {\n            return m_cube;\n        }\n    private:\n        domain::CCube m_cube;\n\n    };\n}\n\n\n\nIBuilder.h\n#pragma once\n#include <boost\\shared_ptr.hpp>\n#include \"CCube.h\"\nnamespace init{\n    class IBuilder\n    {\n    public:\n        virtual ~IBuilder(void){}\n        virtual void make()=0;\n        virtual domain::CCube getResult()=0; \n    };\n    typedef boost::shared_ptr<IBuilder> IBuilderPtr;\n\n}\n\n\n\n\nCDirector.h\n#pragma once\n#include \"CCubeBuilder.h\"\nnamespace init{\n    class CDirector\n    {\n    public:\n        CDirector(IBuilderPtr cube):m_cube(cube){} \n        ~CDirector(void){}\n        void construct()\n        {\n            m_cube->make(); \n        }\n    private:\n        IBuilderPtr m_cube;\n\n    };\n}\n\n\n\n\nTestCube.cpp\nint _tmain(int argc, _TCHAR* argv[]) {\n\n    init::IBuilderPtr ptr = init::IBuilderPtr(new init::CCubeBuilder());\n    init::CDirector director(ptr);\n    director.construct();\n    domain::CCube cube= ptr->getResult() ;\n\n    useCase::CDo kaiten(cube);\n    kaiten.start(30);\n        return 0;\n}\n\n\n\n\n\u7406\u89e3\u3059\u308b\u70ba\u306b\u5b9f\u88c5\u3057\u3066\u307f\u307e\u3057\u305f\u3002\u7686\u3055\u3093\u306e\u3054\u610f\u898b\u3092\u304a\u9858\u3044\u3057\u307e\u3059\u3002\ndrawer\u3092interfaceAdapter\u306b\u3059\u308b\u306e\u304c\u3088\u3044\u306e\u304b\u306a\u3069\u3044\u308d\u3044\u308d\u7591\u554f\u304c\u3042\u308a\u307e\u3059\u304c\u3001\u7686\u3055\u3093\u306e\u610f\u898b\u3092\u805e\u3044\u3066\u307f\u305f\u3044\u306e\u3067\u3001\u4eca\u56de\u6295\u7a3f\u3057\u307e\u3057\u305f\u3002\u7686\u3055\u3093\u306e\u3054\u610f\u898b\u3092\u304a\u9858\u3044\u3057\u307e\u3059\u3002\n#\u30c6\u30b9\u30c8\u53ef\u80fd\u306a\u968e\u5c64\u69cb\u9020\u306e\u8a2d\u8a08\u3092\u76ee\u6307\u3059\u3002\n\u3044\u308d\u3044\u308d\u8a2d\u8a08\u306e\u66f8\u7c4d\u3001\u8cc7\u6599\u3092\u898b\u3066\u304d\u305f\u304c\u3001\u7406\u89e3\u3059\u308b\u306e\u306b\u7d50\u69cb\u6642\u9593\u304c\u304b\u304b\u308b\u3002\n\u30af\u30ea\u30fc\u30f3\u30a2\u30fc\u30ad\u30c6\u30af\u30c1\u30e3\u306e\u8cc7\u6599\u3092\u898b\u305f\u3068\u304d\u306a\u3093\u3066\u5206\u304b\u308a\u3084\u3059\u3044\u3093\u3060\u3068\u601d\u3063\u305f\u306e\u304c\u59cb\u307e\u308a\u3002\n#\u53c2\u8003\u306b\u3057\u305f\u8cc7\u6599\n\u4ee5\u4e0b\u306e\u30ea\u30f3\u30af\u3042\u305f\u308a\u304c\u8cc7\u6599\n\u30fb[\u6301\u7d9a\u53ef\u80fd\u306a\u958b\u767a\u3092\u76ee\u6307\u3059 ~ \u30c9\u30e1\u30a4\u30f3\u30fb\u30e6\u30fc\u30b9\u30b1\u30fc\u30b9\u99c6\u52d5\uff08\u30af\u30ea\u30fc\u30f3\u30a2\u30fc\u30ad\u30c6\u30af\u30c1\u30e3\uff09 + \u5358\u65b9\u5411\u306b\u5236\u9650\u3057\u305f\u51e6\u7406 + FRP](http://qiita.com/kondei/items/41c28674c1bfd4156186)\n\u30fb[\u30af\u30ea\u30fc\u30f3\u30a2\u30fc\u30ad\u30c6\u30af\u30c1\u30e3(The Clean Architecture\u7ffb\u8a33)](http://blog.tai2.net/the_clean_architecture.html)\n\u30fb[\u30c9\u30e1\u30a4\u30f3\u30e2\u30c7\u30eb\u4e2d\u5fc3\u306e\u30a2\u30fc\u30ad\u30c6\u30af\u30c1\u30e3]( http://blog.guildworks.jp/2014/11/14/%E3%83%89%E3%83%A1%E3%82%A4%E3%83%B3%E3%83%A2%E3%83%87%E3%83%AB%E4%B8%AD%E5%BF%83%E3%81%AE%E3%82%A2%E3%83%BC%E3%82%AD%E3%83%86%E3%82%AF%E3%83%81%E3%83%A3/)\n\u30fb[Clean Architecture\u3067\u8a2d\u8a08\u3057\u3066RxJS\u3092\u4f7f\u3063\u305f\u8a71](http://www.slideshare.net/_kondei/clean-architecturerxjs)\n\n\n#\u30ad\u30e5\u30fc\u30d6\u3092\u56de\u3059\n\u81ea\u5206\u3067\u5b9f\u88c5\u3057\u3066\u7406\u89e3\u3057\u3088\u3046\u3068\u601d\u3063\u3066\u4f5c\u3063\u3066\u307f\u307e\u3057\u305f\u3002\n\n\u30c9\u30e1\u30a4\u30f3\u3000\u30ad\u30e5\u30fc\u30d6\n\u30e6\u30fc\u30b9\u30b1\u30fc\u30b9\u3000\uff58\u8ef8\u309230\u5ea6\u56de\u8ee2\u3057\u3066\u7d50\u679c\u3092\u8868\u793a\u3059\u308b\u3002\n\n#\u30bd\u30fc\u30b9\u30b3\u30fc\u30c9\ndomain\n\n```c++:CCube.h\n#pragma once\n#define _USE_MATH_DEFINES\n#include <cmath>\n#include <list>\n#include \"Cpoint.h\"\nusing namespace std;\nnamespace domain{\n\tclass CCube\n\t{\n\tpublic:\n\t\tCCube(){}\n\t\t~CCube(void){}\n\t\tvoid add(CCpoint value){m_cube.push_back(value);}\n\t\tCCube kaitenX(double value);\n\t\tCCube kaitenY(double value);\n\t\tCCube kaitenZ(double value);\n\t\tCPOINT_TABLE_STRUCT draw();\n\tprivate:\n\t\tlist<CCpoint> m_cube;\n\n\t};\n}\n\n```\n\n```c++:CCube.cpp\n#include \"StdAfx.h\"\n#include \"CCube.h\"\n\n\nnamespace domain{\n\tCCube CCube::kaitenX(double value)\n\t{\n\t\tCCube sq;\n\t\tfor(list<CCpoint>::iterator it =m_cube.begin(); it != m_cube.end(); ++it)\n\t\t{\n\t\t\tsq.add(it->rotX(value));\n\t\t}\n\t\treturn sq;\n\t\t\n\t\t\n\t}\n\tCCube CCube::kaitenY(double value)\n\t{\n\t\tCCube sq;\n\t\tfor(list<CCpoint>::iterator it =m_cube.begin(); it != m_cube.end(); ++it)\n\t\t{\n\t\t\tsq.add(it->rotY(value));\n\t\t}\n\t\treturn sq;\n\t}\n\tCCube CCube::kaitenZ(double value)\n\t{\n\t\tCCube sq;\n\t\tfor(list<CCpoint>::iterator it =m_cube.begin(); it != m_cube.end(); ++it)\n\t\t{\n\t\t\tsq.add(it->rotZ(value));\n\t\t}\n\t\treturn sq;\n\t}\n\tCPOINT_TABLE_STRUCT CCube::draw()\n\t{\n\t\tCPOINT_TABLE_STRUCT pointTable;\n\t\tfor(list<CCpoint>::iterator it =m_cube.begin(); it != m_cube.end(); ++it)\n\t\t{\n\t\t\tpointTable.point.push_back(it->draw());\n\t\t}\n\t\treturn pointTable;\n\t}\n\n```\n\n```c++:CPoint.h\n#pragma once\n#include <list>\n#include \"CVectol.h\"\nusing namespace std;\nnamespace domain{\n\ttypedef struct {\n\t\tdouble x;\n\t\tdouble y;\n\t\tdouble z;\n\t}CPOINT_STRUCT;\t\n\ttypedef struct {\n\t\tlist<CPOINT_STRUCT> point;\n\t}CPOINT_TABLE_STRUCT;\t\n\tclass CCpoint\n\t{\n\tpublic:\n\t\tCCpoint(double x,double y,double z):m_x(x),m_y(y),m_z(z){};\n\t\t~CCpoint(void){};\n\t\tCCpoint rotX(double value);\n\t\tCCpoint rotY(double value);\n\t\tCCpoint rotZ(double value);\n\t\tbool eq(CCpoint& value);\n\t\tCPOINT_STRUCT draw(){\n\t\t\tCPOINT_STRUCT str;\n\t\t\tstr.x=m_x.draw();\n\t\t\tstr.y=m_y.draw();\n\t\t\tstr.z=m_z.draw();\n\t\t\treturn str;\n\t\t}\n\n\tprivate:\n\t\tCVectol m_x;\n\t\tCVectol m_y;\n\t\tCVectol m_z;\n\t};\n}\n\n\n```\n\n```c++:CPoint.cpp\n#include \"StdAfx.h\"\n#include \"Cpoint.h\"\n\n\nnamespace domain{\n\tCCpoint CCpoint::rotX(double value)\n\t{\n\t\tdouble y=m_y.degCos(value)-m_z.degSin(value);\n\t\tdouble z=m_y.degSin(value)+m_z.degCos(value);\n\t\tdouble x=m_x.degCos(0);\n\t\treturn CCpoint(x,y,z);\n\t};\n\tCCpoint CCpoint::rotY(double value)\n\t{\n\t\tdouble x=m_x.degCos(value)+m_z.degSin(value);\n\t\tdouble z=-m_z.degSin(value)+m_z.degCos(value);\n\t\tdouble y=m_x.degCos(0);\n\t\treturn CCpoint(x,y,z);\n\t};\n\tCCpoint CCpoint::rotZ(double value)\n\t{\n\t\tdouble x=m_x.degCos(value)-m_y.degSin(value);\n\t\tdouble y=m_x.degSin(value)+m_y.degCos(value);\n\t\tdouble z=m_x.degCos(0);\n\t\treturn CCpoint(x,y,z);\n\t};\n\tbool CCpoint::eq(CCpoint& value)\n\t{\n\t\tif(!m_x.eq(value.m_x)) return false;\n\t\tif(!m_y.eq(value.m_y)) return false;\n\t\tif(!m_z.eq(value.m_z)) return false;\n\t\treturn true;\n\t};\n\n}\n```\n\n```c++:CVectol.h\n#pragma once\n#define _USE_MATH_DEFINES\n#include <math.h>\nnamespace domain{\n\tclass CVectol\n\t{\n\tpublic:\n\t\tCVectol(double value):m_value(value){}\n\t\t~CVectol(void){}\n\t\tdouble degSin(double value){return m_value*sin(deg2rad(value));}\n\t\tdouble degCos(double value){return m_value*cos(deg2rad(value));}\n\t\tbool eq(CVectol value){ return (value.m_value!=m_value)?false:true;}\n\t\tdouble draw(){return m_value;}\n\tprivate:\n\t\tdouble deg2rad(double value){return M_PI*value/180.0l;}\n\t\tdouble m_value;\n\n\t};\n}\n\n\n```\n\nuse case\n\n```c++:CDo.h\n#pragma once\n#include \"CCube.h\"\n#include \"CKaiten.h\"\n#include \"CCDraw.h\"\nnamespace useCase\n{\n\n\tclass CDo\n\t{\n\tpublic:\n\t\tCDo(domain::CCube& cube):m_cube(cube){}\n\t\tvoid start(double value)\n\t\t{\n\t\t  \n\t\t\tIKaitenPtr kai = IKaitenPtr(new interfaceAdapter::CKaiten());\n\t\t\tkai->kaiten(m_cube,value);\n\t\t\tIDrawerPtr drawer = IDrawerPtr(new interfaceAdapter::CCDrawer());\n\t\t\tdrawer->draw(m_cube);\n\t\t}\n\tprivate :\n\t\tdomain::CCube& m_cube;\n\t};\n}\n```\n\n```c++:IDrawer.h\n#pragma once\n#include \"CCube.h\"\n#include <boost\\shared_ptr.hpp>\nnamespace useCase\n{\n\tclass IDrawer\n\t{\n\tpublic:\n\t\tvirtual ~IDrawer(){}\n\t\tvirtual void draw(domain::CCube& cube)=0;\n\n\t};\n\ttypedef boost::shared_ptr<IDrawer> IDrawerPtr;\n\n}\n\n```\n\n```c++:IKaiten.h\n#pragma once\n#include \"CCube.h\"\n#include <boost\\shared_ptr.hpp>\nnamespace useCase\n{\n\tclass IKaiten\n\t{\n\tpublic:\n\t\tvirtual ~IKaiten(){}\n\t\tvirtual void kaiten(domain::CCube& sqr,double angl)=0;\n\n\t};\n\ttypedef boost::shared_ptr<IKaiten> IKaitenPtr;\n\n}\n\n```\n\ninterface Adapter\n\n```c++:CKaiten.h\n#pragma once\n#include \"CCube.h\"\n#include <boost\\shared_ptr.hpp>\nnamespace useCase\n{\n\tclass IKaiten\n\t{\n\tpublic:\n\t\tvirtual ~IKaiten(){}\n\t\tvirtual void kaiten(domain::CCube& sqr,double angl)=0;\n\n\t};\n\ttypedef boost::shared_ptr<IKaiten> IKaitenPtr;\n\n}\n\n```\n\n```c++:CCDraw.h\n#pragma once\n#include <iostream>\n#include \"CCube.h\"\n#include \"IDrawer.h\"\nusing namespace std;\nnamespace interfaceAdapter\n{\n\n\tclass CCDrawer:public useCase::IDrawer\n\t{\n\tpublic:\n\t\tCCDrawer(){}\n\t\t~CCDrawer(){}\n\t\tvoid draw( domain::CCube& cube )\n\t\t{\n\n\t\t\tdomain::CPOINT_TABLE_STRUCT pointTable=cube.draw();//sqrt.drawX();\n\n\t\t\tfor(list<domain::CPOINT_STRUCT>::iterator it =pointTable.point.begin(); it != pointTable.point.end(); ++it)\n\t\t\t{\n\t\t\t\tcout <<\"x=\"<<it->x<<\"y=\"<<it->y<<\"z=\"<<it->z<<endl;\n\t\t\t}\n\t\t}\n\t\t\n\t};\n}\n```\n\ninit\n\n```c++:CCubeBuilder.h\n#pragma once\n#include \"IBuilder.h\"\nnamespace init{\n\tclass CCubeBuilder:public IBuilder\n\t{\n\tpublic:\n\t\tCCubeBuilder(void){}\n\t\t~CCubeBuilder(void){}\n\t\tvoid make()\n\t\t{\n\t\t\tdouble x[]={10,10,-10,-10};\n\t\t\tdouble y[]={-10,10,10,-10};\n\t\t\tdouble z[]={10,-10};\n\t\t\tfor(int i=0;i<8;i++)\n\t\t\t{\n\t\t\t\tint ii=i%4;\n\t\t\t\tint iii=i/4;\n\t\t\t\tdomain::CCpoint point(x[ii],y[ii],z[iii]);\n\t\t\t\tm_cube.add(point);\n\t\t\t}\n\t\t}\n\t\tdomain::CCube getResult()\n\t\t{\n\t\t\treturn m_cube;\n\t\t}\n\tprivate:\n\t\tdomain::CCube m_cube;\n\n\t};\n}\n```\n\n```c++:IBuilder.h\n#pragma once\n#include <boost\\shared_ptr.hpp>\n#include \"CCube.h\"\nnamespace init{\n\tclass IBuilder\n\t{\n\tpublic:\n\t\tvirtual ~IBuilder(void){}\n\t\tvirtual void make()=0;\n\t\tvirtual domain::CCube getResult()=0; \n\t};\n\ttypedef boost::shared_ptr<IBuilder> IBuilderPtr;\n\n}\n\n```\n\n```c++:CDirector.h\n#pragma once\n#include \"CCubeBuilder.h\"\nnamespace init{\n\tclass CDirector\n\t{\n\tpublic:\n\t\tCDirector(IBuilderPtr cube):m_cube(cube){} \n\t\t~CDirector(void){}\n\t\tvoid construct()\n\t\t{\n\t\t\tm_cube->make();\t\n\t\t}\n\tprivate:\n\t\tIBuilderPtr m_cube;\n\n\t};\n}\n\n```\n\n```c++:TestCube.cpp\nint _tmain(int argc, _TCHAR* argv[]) {\n\n\tinit::IBuilderPtr ptr = init::IBuilderPtr(new init::CCubeBuilder());\n\tinit::CDirector director(ptr);\n\tdirector.construct();\n\tdomain::CCube cube= ptr->getResult() ;\n\n\tuseCase::CDo kaiten(cube);\n\tkaiten.start(30);\n        return 0;\n}\n\n```\n\n#\u7406\u89e3\u3059\u308b\u70ba\u306b\u5b9f\u88c5\u3057\u3066\u307f\u307e\u3057\u305f\u3002\u7686\u3055\u3093\u306e\u3054\u610f\u898b\u3092\u304a\u9858\u3044\u3057\u307e\u3059\u3002\ndrawer\u3092interfaceAdapter\u306b\u3059\u308b\u306e\u304c\u3088\u3044\u306e\u304b\u306a\u3069\u3044\u308d\u3044\u308d\u7591\u554f\u304c\u3042\u308a\u307e\u3059\u304c\u3001\u7686\u3055\u3093\u306e\u610f\u898b\u3092\u805e\u3044\u3066\u307f\u305f\u3044\u306e\u3067\u3001\u4eca\u56de\u6295\u7a3f\u3057\u307e\u3057\u305f\u3002\u7686\u3055\u3093\u306e\u3054\u610f\u898b\u3092\u304a\u9858\u3044\u3057\u307e\u3059\u3002\n", "tags": ["DDD", "C++"]}