{"context": " More than 1 year has passed since last update.I've seen this question come up multiple times now, and it's a question that doesn't really make sense -- it's like asking \"what's the difference between pants and trees?\". But this idea probably got planted in people's heads because there's so many terms that are alien to them they hear when trying to learn how to build modern web applications: React, Redux, Flux, \"Reactive\", Rx, Dispatcher, EventEmitter, Observables, etc.\nSo this article is going to go through how a basic application is written in Redux, and then how similar ideas can be used to write an application using RxJS.\n\nThe code\n\nStarting blocks\nWe will use a simple application for our study: an application that displays a counter, and provides two buttons to increment and decrement the counter.\nFor this, we will use some shared bits:\nimport React from 'react';\nimport ReactDOM from 'react-dom';\n\nWe import React and ReactDOM for our application's view.\ntype State = {\n  counter: number\n};\n\nWe define a Flow type for the state of our application. This is just extra stuff that allows us to use Flow to validate some behaviors for our program before we run it.\ntype Callback = () => void;\n\nThis is a convenience type for saying that we will have functions that are called that do not return anything.\ntype ViewProps = {\n  name: string,\n  callbacks: {\n    increment: Callback,\n    decrement: Callback\n  },\n  state: State\n};\n\nThis defines the type of the props that want to pass into our View.\nconst initState = {\n  counter: 0\n};\n\nThis is the initial state of our application that we will use.\nfunction View(props: ViewProps) {\n  return (\n    <div>\n      <h2>Hello, {props.name}!</h2>\n      <h2>Count: {props.state.counter}</h2>\n      <button onClick={props.callbacks.increment}>+</button>\n      <button onClick={props.callbacks.decrement}>-</button>\n    </div>\n  );\n}\n\nThis is a function that will produce React Elements that we can render on to our page. Notice that we have callbacks here in the props: we will call whichever callbacks are provided to our application when the buttons are clicked, leaving us free to specify whatever callback we want into the view.\n\nRedux\nYou probably know the high level of what Redux does by now, but just in case you need a refresher: Redux allows you to manage your application state by having a projecting function that takes the current state of your application and some information about what changes need to be applied to produce a new state for your application. We will verify this with Flow.\nimport {createStore} from 'redux';\n\nWe bring in the createStore method from Redux.\ntype Action = {\n  type: string,\n  payload?: Object\n};\n\nIn Redux, we have the concept of Actions, which are objects that identify what operation is to be performed, and an optional payload object that will specify additional information we need.\nconst INCREMENT = 'INCREMENT';\nconst DECREMENT = 'DECREMENT';\n\nThese constants will be used for our Action.type property, so that we can match these directly for the same value.\nfunction projectRedux(state: State = initState, action: Action): State {\n  switch(action.type) {\n    case INCREMENT:\n      return Object.assign({}, state, {\n        counter: state.counter + 1\n      });\n    case DECREMENT:\n      return Object.assign({}, state, {\n        counter: state.counter - 1\n      });\n    default:\n      return state;\n  }\n}\n\nThis is the bulk of our application. We provide a function for projecting the state of our application using the old state and the action data. So is verified in our type signature: (State, Action) => State.\nconst reduxStore = createStore(projectRedux);\n\nWe create a Redux Store using the projecting function we just described.\nconst reduxCallbacks = {\n  increment: function () {\n    reduxStore.dispatch({\n      type: INCREMENT\n    });\n  },\n  decrement: function () {\n    reduxStore.dispatch({\n      type: DECREMENT\n    });\n  }\n}\n\nMentioned above, we specify the callbacks that will be used in the view here. They call the Redux Store's dispatch method to notify the store to run the projecting function to get the new state, and then notify subscribers that the state has been updated.\nfunction renderReduxApp() {\n  const reduxState = reduxStore.getState();\n\n  console.log('reduxState', reduxState);\n\n  const view = (\n    <View\n      name='Redux'\n      state={reduxState}\n      callbacks={reduxCallbacks}\n    />\n  );\n\n  ReactDOM.render(view, document.getElementById('app-redux'));\n}\n\nThis is our basic function to get the state from our Redux Store, log it out so we can see, and then render this to #app-redux.\nreduxStore.subscribe(function () {\n  renderReduxApp();\n});\n\nWe subscribe to the Redux Store events with a function that calls renderReduxApp.\nrenderReduxApp();\n\nOur Store will not emit an event initially, since nothing will have been dispatched. We will have to call our render function manually at first to get this to work.\n\nRx\nRx is a library that is like lodash for asynchronous events, allowing you to think about events as elements in an array, which you can operate on using operators. You can map, filter, scan, and a whole lot of other things, in addition to being able to delay events that come in and whatnot as you please. In short, Rx is basically completely unrelated to Redux, despite the fact that there are only three letters different between the two. But why am I writing a post comparing the two? The secret: I'm not actually comparing Redux and Rx.\nWe should remember that we aren't using Redux in this version, and we can source information from multiple sources easily. In the Redux version, we get events from multiple sources: the increment button and the decrement button. We then add an event listener that will call dispatch on our Store, which queues up Actions to be flushed later. What if we could abstract this into multiple streams? We then need to merge these streams into one synchronous stream to provide a stream of our application state. Luckily for us, this is pretty easy.\nimport Rx from 'rx';\n\nWe import the Rx module.\ntype Project = (state: State) => State;\n\nThis type is for our projection functions below with scan. The function does have values in the closure that it will access, but the function will properly project the current state into the next state.\nconst increment$ = new Rx.Subject();\nconst decrement$ = new Rx.Subject();\n\nWe then have two subjects, which can have information sent to them, and represent multiple future values that might come out of this, like our button clicks. It's like a Redux Store in that you can send information to it, and you can subscribe to the values that come out.\nfunction projectIncrement(): Project {\n  return function (state: State): State {\n    return Object.assign({}, state, {\n      counter: state.counter + 1\n    });\n  };\n}\n\nfunction projectDecrement(): Project {\n  return function (state: State): State {\n    return Object.assign({}, state, {\n      counter: state.counter - 1\n    });\n  };\n}\n\nThese are separate projecting functions that we can use since we have multiple sources of information. We even could simply map over the streams to transform these into Actions, but since we have multiple sources, we don't need to differentiate the data coming in like when we only have a single source for data (e.g. the Store dispatch queue).\nconst rxCallbacks = {\n  increment: function () {\n    increment$.onNext();\n  },\n  decrement: function () {\n    decrement$.onNext();\n  }\n};\n\nSimilar to the reduxCallbacks we defined above, except we have multiple streams now. onNext tells the subject to queue up the object for emitting the event.\nconst rxState$ = Rx.Observable\n  .merge(\n    increment$.map(projectIncrement),\n    decrement$.map(projectDecrement)\n  )\n  .startWith(initState)\n  .scan(function (state: State, project: Project) {\n    return project(state);\n  });\n\nThis is where everything happens, so let's go through this step by step.\nObservable.merge lets us merge multiple streams together. In this case, we will merge streams of our increments and decrements. To get something useful out of this, we map over these streams with a function to produce the projecting functions that we need to work with.\nstartWith begins our stream with an initial value that we will use.\nscan is a term more familiar with math people, Haskell people, and people who like scanners, but it's  an operation that is like your plain old Array.prototype.reduce. In our case, we will pass in our current state and a projecting function to produce a new state to work with.\nrxState$.subscribe(function (rxState: State) {\n  console.log('rxState', rxState);\n\n  const view = (\n    <View\n      name='Rx'\n      state={rxState}\n      callbacks={rxCallbacks}\n    />\n  );\n\n  ReactDOM.render(view, document.getElementById('app-rx'));\n});\n\nWe then subscribe to our state stream. In this case, because we started off our stream with an initial value, the observer function will be called with the initial state.\n\nA biased conclusion\nIn the end, it kind of doesn't matter which approach you use. You will end up doing a lot of work if you ever want to do things that Rx operators can give you if you choose to write your application in Redux, or you might find that you use Rx streams to manage when you dispatch events with Redux. The thing I want you to take away from this is that Redux and Rx aren't related, but because Rx is a general purpose library, you can do just about anything you want with it.\nThe rigid structure of Redux may even prove to be very useful for you, just like how it has benefitted some folks I've talked to who have migrated from a plethora of vanilla Flux and Flux library approaches to Redux: when you set boundaries on what people can do, there's only so much they can break -- but that's a sad thought, because you should be able to trust your coworkers as people who can keep learning things and come up with good solutions to problems, not malicious forces that mostly contribute bugs and hacks to your codebase, but I digress.\nMy own biased perspective would be that I would want applications that work and can handle complex tasks written using Rx, but I would consider also using Redux. Besides, Redux users' focus on debugging tools and interactive debugging has made for some really cool results.\nOn the other hand, if completely programming with streams sounds fun and you wish you could use a cycle to hook input streams into outputs into inputs, try out Cycle.js. It's fun.\nAs always, if you made it this far, thanks for reading! Please give some feedback on this on Twitter: @jusrin00.\nThis was written on a 14-hour flight without WiFi and may contain lots of errors and meaningless babble. Why can't I get Netflix on flights? The world sucks.\nTL;DR Use either or both.\n\nBonus\nYou can reuse your Redux projection/reducer if you want. It's easy:\n+function incrementAction(): Action {\n+  return {\n+    type: INCREMENT\n+  };\n+}\n\n+function decrementAction(): Action {\n+  return {\n+    type: DECREMENT\n+  };\n+}\n\n const rxState$ = Rx.Observable\n   .merge(\n-    increment$.map(projectIncrement),\n-    decrement$.map(projectDecrement)\n+    increment$.map(incrementAction),\n+    decrement$.map(decrementAction)\n   )\n   .startWith(initState)\n-  .scan(function (state, project) {\n-    return project(state);\n-  });\n+  .scan(projectRedux);\n\n\nLinks\nDirect source: https://github.com/justinwoo/redux-rx-fun/blob/f1dbe526cfedfd3a6b5d05d9a710cee82fbb0729/src/index.js\nGithub repo: https://github.com/justinwoo/redux-rx-fun/\nReactiveX: http://reactivex.io/\nRxJS: https://github.com/Reactive-Extensions/RxJS\nRedux: https://github.com/rackt/redux\n\nI've seen this question come up multiple times now, and it's a question that doesn't really make sense -- it's like asking \"what's the difference between pants and trees?\". But this idea probably got planted in people's heads because there's so many terms that are alien to them they hear when trying to learn how to build modern web applications: React, Redux, Flux, \"Reactive\", Rx, Dispatcher, EventEmitter, Observables, etc.\n\nSo this article is going to go through how a basic application is written in Redux, and then how similar ideas can be used to write an application using RxJS.\n\n## The code\n\n### Starting blocks\n\nWe will use a simple application for our study: an application that displays a counter, and provides two buttons to increment and decrement the counter.\n\nFor this, we will use some shared bits:\n\n```js\nimport React from 'react';\nimport ReactDOM from 'react-dom';\n```\n\nWe import React and ReactDOM for our application's view.\n\n```js\ntype State = {\n  counter: number\n};\n```\n\nWe define a Flow type for the state of our application. This is just extra stuff that allows us to use Flow to validate some behaviors for our program before we run it.\n\n```js\ntype Callback = () => void;\n```\n\nThis is a convenience type for saying that we will have functions that are called that do not return anything.\n\n```js\ntype ViewProps = {\n  name: string,\n  callbacks: {\n    increment: Callback,\n    decrement: Callback\n  },\n  state: State\n};\n```\n\nThis defines the type of the props that want to pass into our View.\n\n```js\nconst initState = {\n  counter: 0\n};\n```\n\nThis is the initial state of our application that we will use.\n\n```js\nfunction View(props: ViewProps) {\n  return (\n    <div>\n      <h2>Hello, {props.name}!</h2>\n      <h2>Count: {props.state.counter}</h2>\n      <button onClick={props.callbacks.increment}>+</button>\n      <button onClick={props.callbacks.decrement}>-</button>\n    </div>\n  );\n}\n```\n\nThis is a function that will produce React Elements that we can render on to our page. Notice that we have callbacks here in the props: we will call whichever callbacks are provided to our application when the buttons are clicked, leaving us free to specify whatever callback we want into the view.\n\n### Redux\n\nYou probably know the high level of what Redux does by now, but just in case you need a refresher: Redux allows you to manage your application state by having a projecting function that takes the current state of your application and some information about what changes need to be applied to produce a new state for your application. We will verify this with Flow.\n\n```js\nimport {createStore} from 'redux';\n```\n\nWe bring in the `createStore` method from Redux.\n\n```js\ntype Action = {\n  type: string,\n  payload?: Object\n};\n```\n\nIn Redux, we have the concept of Actions, which are objects that identify what operation is to be performed, and an optional payload object that will specify additional information we need.\n\n```js\nconst INCREMENT = 'INCREMENT';\nconst DECREMENT = 'DECREMENT';\n```\n\nThese constants will be used for our `Action.type` property, so that we can match these directly for the same value.\n\n```js\nfunction projectRedux(state: State = initState, action: Action): State {\n  switch(action.type) {\n    case INCREMENT:\n      return Object.assign({}, state, {\n        counter: state.counter + 1\n      });\n    case DECREMENT:\n      return Object.assign({}, state, {\n        counter: state.counter - 1\n      });\n    default:\n      return state;\n  }\n}\n```\n\nThis is the bulk of our application. We provide a function for projecting the state of our application using the old state and the action data. So is verified in our type signature: (State, Action) => State.\n\n```js\nconst reduxStore = createStore(projectRedux);\n```\n\nWe create a Redux Store using the projecting function we just described.\n\n```js\nconst reduxCallbacks = {\n  increment: function () {\n    reduxStore.dispatch({\n      type: INCREMENT\n    });\n  },\n  decrement: function () {\n    reduxStore.dispatch({\n      type: DECREMENT\n    });\n  }\n}\n```\n\nMentioned above, we specify the callbacks that will be used in the view here. They call the Redux Store's `dispatch` method to notify the store to run the projecting function to get the new state, and then notify subscribers that the state has been updated.\n\n```js\nfunction renderReduxApp() {\n  const reduxState = reduxStore.getState();\n\n  console.log('reduxState', reduxState);\n\n  const view = (\n    <View\n      name='Redux'\n      state={reduxState}\n      callbacks={reduxCallbacks}\n    />\n  );\n\n  ReactDOM.render(view, document.getElementById('app-redux'));\n}\n```\n\nThis is our basic function to get the state from our Redux Store, log it out so we can see, and then render this to `#app-redux`.\n\n```js\nreduxStore.subscribe(function () {\n  renderReduxApp();\n});\n```\n\nWe subscribe to the Redux Store events with a function that calls `renderReduxApp`.\n\n```js\nrenderReduxApp();\n```\n\nOur Store will not emit an event initially, since nothing will have been dispatched. We will have to call our render function manually at first to get this to work.\n\n### Rx\n\nRx is a library that is like lodash for asynchronous events, allowing you to think about events as elements in an array, which you can operate on using operators. You can map, filter, scan, and a whole lot of other things, in addition to being able to delay events that come in and whatnot as you please. In short, Rx is basically completely unrelated to Redux, despite the fact that there are only three letters different between the two. But why am I writing a post comparing the two? The secret: I'm not actually comparing Redux and Rx.\n\nWe should remember that we aren't using Redux in this version, and we can source information from multiple sources easily. In the Redux version, we get events from multiple sources: the increment button and the decrement button. We then add an event listener that will call `dispatch` on our Store, which queues up Actions to be flushed later. What if we could abstract this into multiple streams? We then need to merge these streams into one synchronous stream to provide a stream of our application state. Luckily for us, this is pretty easy.\n\n```js\nimport Rx from 'rx';\n```\n\nWe import the Rx module.\n\n```js\ntype Project = (state: State) => State;\n```\n\nThis type is for our projection functions below with scan. The function does have values in the closure that it will access, but the function will properly project the current state into the next state.\n\n```js\nconst increment$ = new Rx.Subject();\nconst decrement$ = new Rx.Subject();\n```\n\nWe then have two subjects, which can have information sent to them, and represent multiple future values that might come out of this, like our button clicks. It's like a Redux Store in that you can send information to it, and you can subscribe to the values that come out.\n\n```js\nfunction projectIncrement(): Project {\n  return function (state: State): State {\n    return Object.assign({}, state, {\n      counter: state.counter + 1\n    });\n  };\n}\n\nfunction projectDecrement(): Project {\n  return function (state: State): State {\n    return Object.assign({}, state, {\n      counter: state.counter - 1\n    });\n  };\n}\n```\n\nThese are separate projecting functions that we can use since we have multiple sources of information. We even could simply map over the streams to transform these into Actions, but since we have multiple sources, we don't need to differentiate the data coming in like when we only have a single source for data (e.g. the Store dispatch queue).\n\n```js\nconst rxCallbacks = {\n  increment: function () {\n    increment$.onNext();\n  },\n  decrement: function () {\n    decrement$.onNext();\n  }\n};\n```\n\nSimilar to the `reduxCallbacks` we defined above, except we have multiple streams now. `onNext` tells the subject to queue up the object for emitting the event.\n\n```js\nconst rxState$ = Rx.Observable\n  .merge(\n    increment$.map(projectIncrement),\n    decrement$.map(projectDecrement)\n  )\n  .startWith(initState)\n  .scan(function (state: State, project: Project) {\n    return project(state);\n  });\n```\n\nThis is where everything happens, so let's go through this step by step.\n\n`Observable.merge` lets us merge multiple streams together. In this case, we will merge streams of our increments and decrements. To get something useful out of this, we map over these streams with a function to produce the projecting functions that we need to work with.\n\n`startWith` begins our stream with an initial value that we will use.\n\n`scan` is a term more familiar with math people, Haskell people, and people who like scanners, but it's  an operation that is like your plain old `Array.prototype.reduce`. In our case, we will pass in our current state and a projecting function to produce a new state to work with.\n\n```js\nrxState$.subscribe(function (rxState: State) {\n  console.log('rxState', rxState);\n\n  const view = (\n    <View\n      name='Rx'\n      state={rxState}\n      callbacks={rxCallbacks}\n    />\n  );\n\n  ReactDOM.render(view, document.getElementById('app-rx'));\n});\n```\n\nWe then subscribe to our state stream. In this case, because we started off our stream with an initial value, the observer function will be called with the initial state.\n\n## A biased conclusion\n\nIn the end, it kind of doesn't matter which approach you use. You will end up doing a lot of work if you ever want to do things that Rx operators can give you if you choose to write your application in Redux, or you might find that you use Rx streams to manage when you dispatch events with Redux. The thing I want you to take away from this is that Redux and Rx aren't related, but because Rx is a general purpose library, you can do just about anything you want with it.\n\nThe rigid structure of Redux may even prove to be very useful for you, just like how it has benefitted some folks I've talked to who have migrated from a plethora of vanilla Flux and Flux library approaches to Redux: when you set boundaries on what people can do, there's only so much they can break -- but that's a sad thought, because you should be able to trust your coworkers as people who can keep learning things and come up with good solutions to problems, not malicious forces that mostly contribute bugs and hacks to your codebase, but I digress.\n\nMy own biased perspective would be that I would want applications that work and can handle complex tasks written using Rx, but I would consider also using Redux. Besides, Redux users' focus on debugging tools and interactive debugging has made for some really cool results.\n\nOn the other hand, if completely programming with streams sounds fun and you wish you could use a cycle to hook input streams into outputs into inputs, try out [Cycle.js](http://cycle.js.org/). It's fun.\n\nAs always, if you made it this far, thanks for reading! Please give some feedback on this on Twitter: [@jusrin00](https://twitter.com/jusrin00).\n\n*This was written on a 14-hour flight without WiFi and may contain lots of errors and meaningless babble. Why can't I get Netflix on flights? The world sucks.*\n\n**TL;DR Use either or both.**\n\n### Bonus\n\nYou *can* reuse your Redux projection/reducer if you want. It's easy:\n\n```diff\n+function incrementAction(): Action {\n+  return {\n+    type: INCREMENT\n+  };\n+}\n\n+function decrementAction(): Action {\n+  return {\n+    type: DECREMENT\n+  };\n+}\n\n const rxState$ = Rx.Observable\n   .merge(\n-    increment$.map(projectIncrement),\n-    decrement$.map(projectDecrement)\n+    increment$.map(incrementAction),\n+    decrement$.map(decrementAction)\n   )\n   .startWith(initState)\n-  .scan(function (state, project) {\n-    return project(state);\n-  });\n+  .scan(projectRedux);\n```\n\n## Links\n\nDirect source: https://github.com/justinwoo/redux-rx-fun/blob/f1dbe526cfedfd3a6b5d05d9a710cee82fbb0729/src/index.js\nGithub repo: https://github.com/justinwoo/redux-rx-fun/\nReactiveX: http://reactivex.io/\nRxJS: https://github.com/Reactive-Extensions/RxJS\nRedux: https://github.com/rackt/redux\n\t\n", "tags": ["RxJS", "JavaScript", "redux", "React"]}