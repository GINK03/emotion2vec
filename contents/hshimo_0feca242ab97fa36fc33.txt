{"context": " More than 1 year has passed since last update.Solidity\u306e\u4ed5\u69d8\u306e\u81ea\u5206\u7528\u30e1\u30e2\u3001\u307e\u3068\u3081\u3067\u3059\u3002\n\u4ee5\u4e0b\u306ewiki\u3088\u308a\u50d5\u304c\u5fc5\u8981\u306a\u3068\u3053\u308d\u3060\u3051\u5927\u96d1\u628a\u306b\u5f15\u7528\u3001\u307e\u3068\u3081\u3001\u8a33\u3002\n\u8a33\u306f\u8d85\u9069\u5f53\u306a\u306e\u3067\u3001\u3061\u3083\u3093\u3068\u77e5\u308a\u305f\u3044\u4eba\u306f\u3001\u672c\u5bb6\u30c9\u30ad\u30e5\u30e1\u30f3\u30c8\u3092\u8aad\u307f\u307e\u3057\u3087\u3046\u3002\n\nSolidity Tutorial \u00b7 ethereum/wiki Wiki\n\n\n\u30b3\u30e1\u30f3\u30c8\n\n// \u4e00\u884c\u30b3\u30e1\u30f3\u30c8\n/* */ \u8907\u6570\u884c\u30b3\u30e1\u30f3\u30c8\n/// NatSpec\u30b3\u30e1\u30f3\u30c8\n\n\n\u578b\n\nbool\nuint/int\u306f\u3001uint256/int256\u3068address(16bit)\u306e\u30a8\u30a4\u30ea\u30a2\u30b9\n\n\n\u6574\u6570\u30ea\u30c6\u30e9\u30eb\n\u7565)\n\nEther\u3068\u6642\u9593\u30e6\u30cb\u30c3\u30c8\n\n2 ether == 2000 finney \u306f\u3001true\n\n\nControl Structures\n\nswitch\u3068goto\u306f\u5b9f\u88c5\u4e88\u5b9a\u306a\u3057\nif, else, while, for, break, continue, return \u304c\u3042\u308b\n\u578b\u5909\u63db\u306f\u306a\u3044\u306e\u3067\u3001\u300cif (1) { ... }\u300d\u306f\u3001\u7121\u52b9\n\n\n\u95a2\u6570\u547c\u3073\u51fa\u3057\n\u4ee5\u4e0b\u306e\u30b5\u30f3\u30d7\u30eb\u306e\u3088\u3046\u306b\u3001\u73fe\u30b3\u30f3\u30c8\u30e9\u30af\u30c8\u306e\u95a2\u6570\u306f\n\n\u76f4\u63a5\u547c\u3079\u308b\n\u518d\u5e30\u7684\u306b\u547c\u3079\u308b\n\ncontract c {\n  function g(uint a) returns (uint ret) { return f(); }\n  function f() returns (uint ret) { return g(7) + f(); }\n}\n\n\n\u7279\u5225\u306a\u5909\u6570\u3068\u95a2\u6570\n\nblock.coinbase (address): current block miner's address\nblock.difficulty (uint): current block difficulty\nblock.gaslimit (uint): current block gaslimit\nblock.number (uint): current block number\nblock.blockhash (function(uint) returns (bytes32)): hash of the given block\nblock.timestamp (uint): current block timestamp\nmsg.data (bytes): complete calldata\nmsg.gas (uint): remaining gas\nmsg.sender (address): sender of the message (current call)\nmsg.value (uint): number of wei sent with the message\nnow (uint): current block timestamp (alias for block.timestamp)\ntx.gasprice (uint): gas price of the transaction\ntx.origin (address): sender of the transaction (full call chai\n\n\n\u6697\u53f7\u7cfb\u306e\u95a2\u6570\n\nsha3(...) returns (bytes32): compute the SHA3 hash of the (tightly packed) arguments\nsha256(...) returns (bytes32): compute the SHA256 hash of the (tightly packed) arguments\nripemd160(...) returns (bytes20): compute RIPEMD of 256 the (tightly packed) arguments\necrecover(bytes32, byte, bytes32, bytes32) returns (address): recover public key from elliptic curve signature\n\n\n\u30b3\u30f3\u30c8\u30e9\u30af\u30c8\u95a2\u4fc2\n\nthis (\u73fe\u30b3\u30f3\u30c8\u30e9\u30af\u30c8\u306e\u578b): \u73fe\u30b3\u30f3\u30c8\u30e9\u30af\u30c8\u3002\u660e\u793a\u7684\u306b\u30a2\u30c9\u30ec\u30b9\u306b\u5909\u63db\u53ef\u80fd\nsuicide(address): \u73fe\u30b3\u30f3\u30c8\u30e9\u30af\u30c8\u3092suicide\u3002\u30d5\u30a1\u30f3\u30c9\u3092\u4e0e\u3048\u3089\u308c\u305f\u30a2\u30c9\u30ec\u30b9\u306b\u9001\u308b\n\n\n\u30a2\u30c9\u30ec\u30b9\u4e0a\u306e\u95a2\u6570\nbalance\u30d7\u30ed\u30d1\u30c6\u30a3\u3068send\u95a2\u6570\u3092\u4f7f\u3063\u3066\u30a2\u30c9\u30ec\u30b9\u306bEther\u3092\u9001\u308b\u3053\u3068\u3067\u30a2\u30c9\u30ec\u30b9\u306e\u6b8b\u9ad8\u3092\u8981\u6c42\u3059\u308b\u3053\u3068\u304c\u53ef\u80fd??\naddress x = 0x123;\nif (x.balance < 10 && address(this).balance >= 10) x.send(10);\n\n\nABI\n\n\nExpression\u306e\u8a55\u4fa1\u306e\u9806\u756a\n\nnot specified?\n\n\n\u914d\u5217\n\n\u52d5\u7684\u30fb\u56fa\u5b9a\u30b5\u30a4\u30ba\u306e\u914d\u5217\u306f\u30b5\u30dd\u30fc\u30c8\u3055\u308c\u3066\u3044\u308b\n\ncontract ArrayContract {\n  uint[2**20] m_aLotOfIntegers;\n  bool[2][] m_pairsOfFlags;\n  function setAllFlagPairs(bool[2][] newPairs) external {\n    // assignment to array replaces the complete array\n    m_pairsOfFlags = newPairs;\n  }\n  function setFlagPair(uint index, bool flagA, bool flagB) {\n    // access to a non-existing index will stop execution\n    m_pairsOfFlags[index][0] = flagA;\n    m_pairsOfFlags[index][1] = flagB;\n  }\n  function changeFlagArraySize(uint newSize) {\n    // if the new size is smaller, removed array elements will be cleared\n    m_pairsOfFlags.length = newSize;\n  }\n  function clear() {\n    // these clear the arrays completely\n    delete m_pairsOfFlags;\n    delete m_aLotOfIntegers;\n    // identical effect here\n    m_pairsOfFlags.length = 0;\n  }\n  bytes m_byteData;\n  function byteArrays(bytes data) external {\n    // byte arrays (\"bytes\") are different as they are stored without padding,\n    // but can be treated identical to \"uint8[]\"\n    m_byteData = data;\n    m_byteData.length += 7;\n    m_byteData[3] = 8;\n    delete m_byteData[2];\n  }\n}\n\n\n\u69cb\u9020\u4f53(Structs)\n\u2028\u4f8b:\ncontract CrowdFunding {\n  struct Funder {\n    address addr;\n    uint amount;\n  }\n  struct Campaign {\n    address beneficiary;\n    uint fundingGoal;\n    uint numFunders;\n    uint amount;\n    mapping (uint => Funder) funders;\n  }\n  uint numCampaigns;\n  mapping (uint => Campaign) campaigns;\n  function newCampaign(address beneficiary, uint goal) returns (uint campaignID) {\n    campaignID = numCampaigns++; // campaignID is return variable\n    Campaign c = campaigns[campaignID];  // assigns reference\n    c.beneficiary = beneficiary;\n    c.fundingGoal = goal;\n  }\n  function contribute(uint campaignID) {\n    Campaign c = campaigns[campaignID];\n    Funder f = c.funders[c.numFunders++];\n    f.addr = msg.sender;\n    f.amount = msg.value;\n    c.amount += f.amount;\n  }\n  function checkGoalReached(uint campaignID) returns (bool reached) {\n    Campaign c = campaigns[campaignID];\n    if (c.amount < c.fundingGoal)\n      return false;\n    c.beneficiary.send(c.amount);\n    c.amount = 0;\n    return true;\n  }\n}\n\n\nAssignment\n(\u7565)\n\nEnums\n\u4f8b\u306e\u307e\u307e\ncontract test {\n    enum ActionChoices { GoLeft, GoRight, GoStraight, SitStill }\n    ActionChoices choices;\n    ActionChoices constant defaultChoice = ActionChoices.GoStraight;\n    function setGoStraight()\n    {\n        choices = ActionChoices.GoStraight;\n    }\n    function getChoice() returns (uint)\n    {\n        return uint(choices);\n    }\n    function getDefaultChoice() returns (uint)\n    {\n        return uint(defaultChoice);\n    }\n}\n\n\n\u4ed6\u306e\u30b3\u30f3\u30c8\u30e9\u30af\u30c8\u3068\u3084\u308a\u53d6\u308a\u3059\u308b\n2\u3064\u306e\u65b9\u6cd5\u304c\u3042\u308b\n\n\u30a2\u30c9\u30ec\u30b9\u304c\u308f\u304b\u3063\u3066\u3044\u308b\u30b3\u30f3\u30c8\u30e9\u30af\u30c8\u306e\u30e1\u30bd\u30c3\u30c9\u3092\u547c\u3076\n\u65b0\u3057\u3044\u30b3\u30f3\u30c8\u30e9\u30af\u30c8\u3092\u4f5c\u6210\u3059\u308b\n\n\u4ee5\u4e0b\u306e\u30b5\u30f3\u30d7\u30eb\u306b2\u3064\u306e\u65b9\u6cd5\u304c\u8a18\u8f09\u3055\u308c\u3066\u3044\u308b\ncontract OwnedToken {\n  // TokenCreator is a contract type that is defined below. It is fine to reference it\n  // as long as it is not used to create a new contract.\n  TokenCreator creator;\n  address owner;\n  bytes32 name;\n  function OwnedToken(bytes32 _name) {\n    address nameReg = 0x72ba7d8e73fe8eb666ea66babc8116a41bfb10e2;\n    nameReg.call(\"register\", _name);\n    owner = msg.sender;\n    // We do an explicit type conversion from `address` to `TokenCreator` and assume that the type of\n    // the calling contract is TokenCreator, there is no real way to check.\n    creator = TokenCreator(msg.sender);\n    name = _name;\n  }\n  function changeName(bytes32 newName) {\n    // Only the creator can alter the name -- contracts are explicitly convertible to addresses.\n    if (msg.sender == address(creator)) name = newName;\n  }\n  function transfer(address newOwner) {\n    // Only the current owner can transfer the token.\n    if (msg.sender != owner) return;\n    // We also want to ask the creator if the transfer is fine.\n    // Note that this calls a function of the contract defined below.\n    // If the call fails (e.g. due to out-of-gas), the execution here stops\n    // immediately (the ability to catch this will be added later).\n    if (creator.isTokenTransferOK(owner, newOwner))\n      owner = newOwner;\n  }\n}\ncontract TokenCreator {\n  function createToken(bytes32 name) returns (address tokenAddress) {\n    // Create a new Token contract and return its address.\n    return address(new OwnedToken(name));\n  }\n  function changeName(address tokenAddress, bytes32 name) {\n    // We need an explicit type conversion because contract types are not part of the ABI.\n    OwnedToken token = OwnedToken(tokenAddress);\n    token.changeName(name);\n  }\n  function isTokenTransferOK(address currentOwner, address newOwner) returns (bool ok) {\n    // Check some arbitrary condition.\n    address tokenAddress = msg.sender;\n    return (sha3(newOwner) & 0xff) == (bytes20(tokenAddress) & 0xff);\n  }\n}\n\n\n\u30b3\u30f3\u30b9\u30c8\u30e9\u30af\u30bf\u306e\u5f15\u6570\nSolidiy\u306e\u30b3\u30f3\u30c8\u30e9\u30af\u30c8\u306f\u3001\u30b3\u30f3\u30c8\u30e9\u30af\u30c8\u30fb\u30c7\u30fc\u30bf\u81ea\u8eab\u306e\u7d42\u308f\u308a\u306e\u5f8c\u306b\u30b3\u30f3\u30b9\u30c8\u30e9\u30af\u30bf\u306e\u5f15\u6570\u3092\u671f\u5f85\u3057\u3066\u3044\u308b\u3002\n\u3064\u307e\u308a\u3001\u901a\u5e38\u306eABI\u5f62\u5f0f\u306e\u30b3\u30f3\u30d1\u30a4\u30e9\u306b\u3088\u3063\u3066\u8fd4\u3055\u308c\u308b\u3088\u3046\u306a\u5f62\u3067\u3001\u30b3\u30f3\u30d1\u30a4\u30eb\u3055\u308c\u305f\u30d0\u30a4\u30c8\u306e\u5f8c\u306b\u7f6e\u304f\u3053\u3068\u3067\u30b3\u30f3\u30c8\u30e9\u30af\u30c8\u306b\u5f15\u6570\u3092\u6e21\u3059\u3002\n\n\u30b3\u30f3\u30c8\u30e9\u30af\u30c8\u306e\u7d99\u627f\nSolidity\u306f\u3001\u30dd\u30ea\u30e2\u30fc\u30d5\u30a3\u30ba\u30e0\u3092\u542b\u3080\u30b3\u30fc\u30c9\u3092\u30b3\u30d4\u30fc\u3059\u308b\u3053\u3068\u3067\u3001\u591a\u91cd\u7d99\u627f\u3092\u30b5\u30dd\u30fc\u30c8\u3059\u308b\u3002\ncontract owned {\n    function owned() { owner = msg.sender; }\n    address owner;\n}\n\n// Use \"is\" to derive from another contract. Derived contracts can access all members\n// including private functions and state variables.\ncontract mortal is owned {\n    function kill() { if (msg.sender == owner) suicide(owner); }\n}\n\n// These are only provided to make the interface known to the compiler.\ncontract Config { function lookup(uint id) returns (address adr) {} }\ncontract NameReg { function register(bytes32 name) {} function unregister() {} }\n\n// Multiple inheritance is possible. Note that \"owned\" is also a base class of\n// \"mortal\", yet there is only a single instance of \"owned\" (as for virtual\n// inheritance in C++).\ncontract named is owned, mortal {\n    function named(bytes32 name) {\n        address ConfigAddress = 0xd5f9d8d94886e70b06e474c3fb14fd43e2f23970;\n        NameReg(Config(ConfigAddress).lookup(1)).register(name);\n    }\n\n// Functions can be overridden, both local and message-based function calls take\n// these overrides into account.\n    function kill() {\n        if (msg.sender == owner) {\n            address ConfigAddress = 0xd5f9d8d94886e70b06e474c3fb14fd43e2f23970;\n            NameReg(Config(ConfigAddress).lookup(1)).unregister();\n// It is still possible to call a specific overridden function. \n            mortal.kill();\n        }\n    }\n}\n\n// If a constructor takes an argument, it needs to be provided in the header.\ncontract PriceFeed is owned, mortal, named(\"GoldFeed\") {\n   function updateInfo(uint newInfo) {\n      if (msg.sender == owner) info = newInfo;\n   }\n\n   function get() constant returns(uint r) { return info; }\n\n   uint info;\n}\n\n\u4e0a\u8a18\u3067\u66f8\u3044\u305f\u3088\u3046\u306b\u3001destruction\u30ea\u30af\u30a8\u30b9\u30c8\u3092\u30d5\u30a9\u30ef\u30fc\u30c9\u3059\u308b\u305f\u3081\u306b\u3001mortal.kill() \u3092\u547c\u3076\u3002\ncontract mortal is owned {\n    function kill() { if (msg.sender == owner) suicide(owner); }\n}\ncontract Base1 is mortal {\n    function kill() { /* do cleanup 1 */ mortal.kill(); }\n}\ncontract Base2 is mortal {\n    function kill() { /* do cleanup 2 */ mortal.kill(); }\n}\ncontract Final is Base1, Base2 {\n}\n\n(\u7565)\n\n\u591a\u91cd\u7d99\u627f\u3068\u7dda\u5f62\u5316\n(WIP)\n\n\u62bd\u8c61\u30b3\u30f3\u30c8\u30e9\u30af\u30c8\n(WIP)\n\nVisibility Specifiers\npublic, internal, private\n(WIP)\n\nAccessor Functions\n(WIP)\n\nFallback\u95a2\u6570\ncontract Test {\n  function() { x = 1; }\n  uint x;\n}\n\ncontract Caller {\n  function callTest(address testAddress) {\n    Test(testAddress).call(0xabcdefgh); // hash does not exist\n    // results in Test(testAddress).x becoming == 1.\n  }\n}\n\n\n\u95a2\u6570\u4fee\u98fe\u5b50\n\n_\nonlyowner\nmodifier\n\n\nModifiers can be used to easily change the behaviour of functions, for example to automatically check a condition prior to executing the function. They are inheritable properties of contracts and may be overridden by derived contracts.\n\ncontract owned {\n  function owned() { owner = msg.sender; }\n  address owner;\n\n  // This contract only defines a modifier but does not use it - it will\n  // be used in derived contracts.\n  // The function body is inserted where the special symbol \"_\" in the\n  // definition of a modifier appears.\n  modifier onlyowner { if (msg.sender == owner) _ }\n}\ncontract mortal is owned {\n  // This contract inherits the \"onlyowner\"-modifier from \"owned\" and\n  // applies it to the \"kill\"-function, which causes that calls to \"kill\"\n  // only have an effect if they are made by the stored owner.\n  function kill() onlyowner {\n    suicide(owner);\n  }\n}\ncontract priced {\n  // Modifiers can receive arguments:\n  modifier costs(uint price) { if (msg.value >= price) _ }\n}\ncontract Register is priced, owned {\n  mapping (address => bool) registeredAddresses;\n  uint price;\n  function Register(uint initialPrice) { price = initialPrice; }\n  function register() costs(price) {\n    registeredAddresses[msg.sender] = true;\n  }\n  function changePrice(uint _price) onlyowner {\n    price = _price;\n  }\n}\n\n\nMultiple modifiers can be applied to a function by specifying them in a whitespace-separated list and will be evaluated in order. Explicit returns from a modifier or function body immediately leave the whole function, while control flow reaching the end of a function or modifier body continues after the \"_\" in the preceding modifier. Arbitrary expressions are allowed for modifier arguments and in this context, all symbols visible from the function are visible in the modifier. Symbols introduced in the modifier are not visible in the function (as they might change by overriding).\n\n\n\u30a4\u30d9\u30f3\u30c8\n\u30a4\u30d9\u30f3\u30c8\u306f\u3001EVM\u306e\u30ed\u30ae\u30f3\u30b0\u30fb\u30d5\u30a1\u30b7\u30ea\u30c6\u30a3\u306e\u5bb9\u6613\u306a\u5229\u7528\u3092\u8a31\u3059\u3002\u30a4\u30d9\u30f3\u30c8\u306f\u3001\u30b3\u30f3\u30c8\u30e9\u30af\u30c8\u306e\u7d99\u627f\u53ef\u80fd\u306a\u30e1\u30f3\u30d0\u30fc\u3002\u30a4\u30d9\u30f3\u30c8\u304c\u547c\u3070\u308c\u305f\u6642\u306b\u3001\u5f15\u6570\u304c\u30c8\u30e9\u30f3\u30b6\u30af\u30b7\u30e7\u30f3\u30ed\u30b0\u306b\u4fdd\u5b58\u3055\u308c\u308b\u3002\u6700\u59273\u3064\u306e\u30d1\u30e9\u30e1\u30fc\u30bf\u304c\u3001indexed\u5c5e\u6027\u3092\u53d7\u3051\u4ed8\u3051\u308b\u3053\u3068\u304c\u3067\u304d\u308b\u3002\n(WIP)\ncontract ClientReceipt {\n  event Deposit(address indexed _from, bytes32 indexed _id, uint _value);\n  function deposit(bytes32 _id) {\n    Deposit(msg.sender, _id, msg.value);\n  }\n}\n\nDeposit\u3092\u547c\u3076\u306e\u306f\u3001log3(msg.value, 0x50cb9fe53daa9737b786ab3646f04d0150dc50ef4e75f59509d83667ad5adb20, sha3(msg.sender), _id); \u3068\u540c\u3058\u3002\n\nLayout of State Variables in Storage\n(WIP)\n\nStatically-sized variables (everything except mapping and dynamically-sized array types) are laid out contiguously in storage starting from position 0. Multiple items that need less than 32 bytes are packed into a single storage slot if possible, according to the following rules:\nThe first item in a storage slot is stored lower-order aligned.\nElementary types use only that many bytes that are necessary to store them.\nIf an elementary type does not fit the remaining part of a storage slot, it is moved to the next storage slot.\nStructs and array data always start a new slot and occupy whole slots (but items inside a struct or array are packed tightly according to these rules).\nThe elements of structs and arrays are stored after each other, just as if they were given explicitly.\nDue to their unpredictable size, mapping and dynamically-sized array types use a sha3 computation to find the starting position of the value or the array data. These starting positions are always full stack slots.\nThe mapping or the dynamic array itself occupies an (unfilled) slot in storage at some position p according to the above rule (or by recursively applying this rule for mappings to mappings or arrays of arrays). For a dynamic array, this slot stores the number of elements in the array. For a mapping, the slot is unused (but it is needed so that two equal mappings after each other will use a different hash distribution). Array data is located at sha3(p) and the value corresponding to a mapping key k is located at sha3(k . p) where . is concatenation. If the value is again a non-elementary type, the positions are found by adding an offset of sha3(k . p).\nSo for the following contract snippet:\n\ncontract c {\n  struct S { uint a; uint b; }\n  uint x;\n  mapping(uint => mapping(uint => S)) data;\n}\n\n\nThe position of data[4][9].b is at sha3(uint256(9) . sha3(uint256(4) . uint(256(1))) + 1.\n\n\nEsoteric Features\n(WIP)\n\nThere are some types in Solidity's type system that have no counterpart in the syntax. One of these types are the types of functions. But still, using var it is possible to have local variables of these types:\ncontract FunctionSelector {\n  function select(bool useB, uint x) returns (uint z) {\n    var f = a;\n    if (useB) f = b;\n    return f(x);\n  }\n  function a(uint x) returns (uint z) {\n    return x * x;\n  }\n  function b(uint x) returns (uint z) {\n    return 2 * x;\n  }\n}\nCalling select(false, x) will compute x * x and select(true, x) will compute 2 * x.\n\n\n\nInternals - the Optimizer\n(WIP)\n\n\u30c1\u30fc\u30c8\u30b7\u30fc\u30c8\n(WIP)\n\u4ee5\u4e0b\u3001\u5225\u306e\u30c9\u30ad\u30e5\u30e1\u30f3\u30c8\u304b\u3089\n\nSimple Sample\ncontract Coin {\n    address minter;\n    mapping (address => uint) balances;\n\n    event Send(address from, address to, uint value);\n\n    function Coin() {\n        minter = msg.sender;\n    }\n\n    function mint(address owner, uint amount) {\n        if (msg.sender != minter) return;\n        balances[owner] += amount;\n    }\n    function send(address receiver, uint amount) {\n        if (balances[msg.sender] < amount) return;\n        balances[msg.sender] -= amount;\n        balances[receiver] += amount;\n        Send(msg.sender, receiver, amount);\n    }\n    function queryBalance(address addr) constant returns (uint balance) {\n        return balances[addr];\n    }\n}\n\n\nuint: unsigned integer of 256 bits\naddress: a 160 bit value that does not allow any arithmetic operations\nthe state variable balances is of a complex datatype that maps addresses to unsigned integers\nMappings can be seen as hashtables which are virtually initialized such that every possible key exists and is mapped to a value whose byte-representation is all zeros\n\n\n\nSolidity\u306e\u4ed5\u69d8\u306e\u81ea\u5206\u7528\u30e1\u30e2\u3001\u307e\u3068\u3081\u3067\u3059\u3002\n\n\u4ee5\u4e0b\u306ewiki\u3088\u308a\u50d5\u304c\u5fc5\u8981\u306a\u3068\u3053\u308d\u3060\u3051\u5927\u96d1\u628a\u306b\u5f15\u7528\u3001\u307e\u3068\u3081\u3001\u8a33\u3002\n\u8a33\u306f\u8d85\u9069\u5f53\u306a\u306e\u3067\u3001\u3061\u3083\u3093\u3068\u77e5\u308a\u305f\u3044\u4eba\u306f\u3001\u672c\u5bb6\u30c9\u30ad\u30e5\u30e1\u30f3\u30c8\u3092\u8aad\u307f\u307e\u3057\u3087\u3046\u3002\n\n* [Solidity Tutorial \u00b7 ethereum/wiki Wiki](https://github.com/ethereum/wiki/wiki/Solidity-Tutorial)\n\n\n## \u30b3\u30e1\u30f3\u30c8\n\n* // \u4e00\u884c\u30b3\u30e1\u30f3\u30c8\n* /* */ \u8907\u6570\u884c\u30b3\u30e1\u30f3\u30c8\n* /// NatSpec\u30b3\u30e1\u30f3\u30c8\n\n## \u578b\n\n* bool\n* uint/int\u306f\u3001uint256/int256\u3068address(16bit)\u306e\u30a8\u30a4\u30ea\u30a2\u30b9\n\n## \u6574\u6570\u30ea\u30c6\u30e9\u30eb\n\n\u7565)\n\n## Ether\u3068\u6642\u9593\u30e6\u30cb\u30c3\u30c8\n\n* 2 ether == 2000 finney \u306f\u3001true\n\n\n## Control Structures\n\n* switch\u3068goto\u306f\u5b9f\u88c5\u4e88\u5b9a\u306a\u3057\n* if, else, while, for, break, continue, return \u304c\u3042\u308b\n* \u578b\u5909\u63db\u306f\u306a\u3044\u306e\u3067\u3001\u300cif (1) { ... }\u300d\u306f\u3001\u7121\u52b9\n\n## \u95a2\u6570\u547c\u3073\u51fa\u3057\n\n\u4ee5\u4e0b\u306e\u30b5\u30f3\u30d7\u30eb\u306e\u3088\u3046\u306b\u3001\u73fe\u30b3\u30f3\u30c8\u30e9\u30af\u30c8\u306e\u95a2\u6570\u306f\n\n* \u76f4\u63a5\u547c\u3079\u308b\n* \u518d\u5e30\u7684\u306b\u547c\u3079\u308b\n\n```\ncontract c {\n  function g(uint a) returns (uint ret) { return f(); }\n  function f() returns (uint ret) { return g(7) + f(); }\n}\n```\n\n## \u7279\u5225\u306a\u5909\u6570\u3068\u95a2\u6570\n\n\n* block.coinbase (address): current block miner's address\n* block.difficulty (uint): current block difficulty\n* block.gaslimit (uint): current block gaslimit\n* block.number (uint): current block number\n* block.blockhash (function(uint) returns (bytes32)): hash of the given block\n* block.timestamp (uint): current block timestamp\n* msg.data (bytes): complete calldata\n* msg.gas (uint): remaining gas\n* msg.sender (address): sender of the message (current call)\n* msg.value (uint): number of wei sent with the message\n* now (uint): current block timestamp (alias for block.timestamp)\n* tx.gasprice (uint): gas price of the transaction\n* tx.origin (address): sender of the transaction (full call chai\n\n## \u6697\u53f7\u7cfb\u306e\u95a2\u6570\n\n* sha3(...) returns (bytes32): compute the SHA3 hash of the (tightly packed) arguments\n* sha256(...) returns (bytes32): compute the SHA256 hash of the (tightly packed) arguments\n* ripemd160(...) returns (bytes20): compute RIPEMD of 256 the (tightly packed) arguments\n* ecrecover(bytes32, byte, bytes32, bytes32) returns (address): recover public key from elliptic curve signature\n\n## \u30b3\u30f3\u30c8\u30e9\u30af\u30c8\u95a2\u4fc2\n\n* this (\u73fe\u30b3\u30f3\u30c8\u30e9\u30af\u30c8\u306e\u578b): \u73fe\u30b3\u30f3\u30c8\u30e9\u30af\u30c8\u3002\u660e\u793a\u7684\u306b\u30a2\u30c9\u30ec\u30b9\u306b\u5909\u63db\u53ef\u80fd\n* suicide(address): \u73fe\u30b3\u30f3\u30c8\u30e9\u30af\u30c8\u3092suicide\u3002\u30d5\u30a1\u30f3\u30c9\u3092\u4e0e\u3048\u3089\u308c\u305f\u30a2\u30c9\u30ec\u30b9\u306b\u9001\u308b\n\n## \u30a2\u30c9\u30ec\u30b9\u4e0a\u306e\u95a2\u6570\n\nbalance\u30d7\u30ed\u30d1\u30c6\u30a3\u3068send\u95a2\u6570\u3092\u4f7f\u3063\u3066\u30a2\u30c9\u30ec\u30b9\u306bEther\u3092\u9001\u308b\u3053\u3068\u3067\u30a2\u30c9\u30ec\u30b9\u306e\u6b8b\u9ad8\u3092\u8981\u6c42\u3059\u308b\u3053\u3068\u304c\u53ef\u80fd??\n\n```\naddress x = 0x123;\nif (x.balance < 10 && address(this).balance >= 10) x.send(10);\n```\n\n* ABI\n\n\n## Expression\u306e\u8a55\u4fa1\u306e\u9806\u756a\n\n* not specified?\n\n## \u914d\u5217\n\n* \u52d5\u7684\u30fb\u56fa\u5b9a\u30b5\u30a4\u30ba\u306e\u914d\u5217\u306f\u30b5\u30dd\u30fc\u30c8\u3055\u308c\u3066\u3044\u308b\n\n```\ncontract ArrayContract {\n  uint[2**20] m_aLotOfIntegers;\n  bool[2][] m_pairsOfFlags;\n  function setAllFlagPairs(bool[2][] newPairs) external {\n    // assignment to array replaces the complete array\n    m_pairsOfFlags = newPairs;\n  }\n  function setFlagPair(uint index, bool flagA, bool flagB) {\n    // access to a non-existing index will stop execution\n    m_pairsOfFlags[index][0] = flagA;\n    m_pairsOfFlags[index][1] = flagB;\n  }\n  function changeFlagArraySize(uint newSize) {\n    // if the new size is smaller, removed array elements will be cleared\n    m_pairsOfFlags.length = newSize;\n  }\n  function clear() {\n    // these clear the arrays completely\n    delete m_pairsOfFlags;\n    delete m_aLotOfIntegers;\n    // identical effect here\n    m_pairsOfFlags.length = 0;\n  }\n  bytes m_byteData;\n  function byteArrays(bytes data) external {\n    // byte arrays (\"bytes\") are different as they are stored without padding,\n    // but can be treated identical to \"uint8[]\"\n    m_byteData = data;\n    m_byteData.length += 7;\n    m_byteData[3] = 8;\n    delete m_byteData[2];\n  }\n}\n```\n\n## \u69cb\u9020\u4f53(Structs)\n\u2028\u4f8b:\n\n```\ncontract CrowdFunding {\n  struct Funder {\n    address addr;\n    uint amount;\n  }\n  struct Campaign {\n    address beneficiary;\n    uint fundingGoal;\n    uint numFunders;\n    uint amount;\n    mapping (uint => Funder) funders;\n  }\n  uint numCampaigns;\n  mapping (uint => Campaign) campaigns;\n  function newCampaign(address beneficiary, uint goal) returns (uint campaignID) {\n    campaignID = numCampaigns++; // campaignID is return variable\n    Campaign c = campaigns[campaignID];  // assigns reference\n    c.beneficiary = beneficiary;\n    c.fundingGoal = goal;\n  }\n  function contribute(uint campaignID) {\n    Campaign c = campaigns[campaignID];\n    Funder f = c.funders[c.numFunders++];\n    f.addr = msg.sender;\n    f.amount = msg.value;\n    c.amount += f.amount;\n  }\n  function checkGoalReached(uint campaignID) returns (bool reached) {\n    Campaign c = campaigns[campaignID];\n    if (c.amount < c.fundingGoal)\n      return false;\n    c.beneficiary.send(c.amount);\n    c.amount = 0;\n    return true;\n  }\n}\n```\n\n## Assignment\n\n(\u7565)\n\n\n## Enums\n\n\u4f8b\u306e\u307e\u307e\n\n```\ncontract test {\n    enum ActionChoices { GoLeft, GoRight, GoStraight, SitStill }\n    ActionChoices choices;\n    ActionChoices constant defaultChoice = ActionChoices.GoStraight;\n    function setGoStraight()\n    {\n        choices = ActionChoices.GoStraight;\n    }\n    function getChoice() returns (uint)\n    {\n        return uint(choices);\n    }\n    function getDefaultChoice() returns (uint)\n    {\n        return uint(defaultChoice);\n    }\n}\n```\n\n## \u4ed6\u306e\u30b3\u30f3\u30c8\u30e9\u30af\u30c8\u3068\u3084\u308a\u53d6\u308a\u3059\u308b\n\n2\u3064\u306e\u65b9\u6cd5\u304c\u3042\u308b\n\n* \u30a2\u30c9\u30ec\u30b9\u304c\u308f\u304b\u3063\u3066\u3044\u308b\u30b3\u30f3\u30c8\u30e9\u30af\u30c8\u306e\u30e1\u30bd\u30c3\u30c9\u3092\u547c\u3076\n* \u65b0\u3057\u3044\u30b3\u30f3\u30c8\u30e9\u30af\u30c8\u3092\u4f5c\u6210\u3059\u308b\n\n\u4ee5\u4e0b\u306e\u30b5\u30f3\u30d7\u30eb\u306b2\u3064\u306e\u65b9\u6cd5\u304c\u8a18\u8f09\u3055\u308c\u3066\u3044\u308b\n\n```\ncontract OwnedToken {\n  // TokenCreator is a contract type that is defined below. It is fine to reference it\n  // as long as it is not used to create a new contract.\n  TokenCreator creator;\n  address owner;\n  bytes32 name;\n  function OwnedToken(bytes32 _name) {\n    address nameReg = 0x72ba7d8e73fe8eb666ea66babc8116a41bfb10e2;\n    nameReg.call(\"register\", _name);\n    owner = msg.sender;\n    // We do an explicit type conversion from `address` to `TokenCreator` and assume that the type of\n    // the calling contract is TokenCreator, there is no real way to check.\n    creator = TokenCreator(msg.sender);\n    name = _name;\n  }\n  function changeName(bytes32 newName) {\n    // Only the creator can alter the name -- contracts are explicitly convertible to addresses.\n    if (msg.sender == address(creator)) name = newName;\n  }\n  function transfer(address newOwner) {\n    // Only the current owner can transfer the token.\n    if (msg.sender != owner) return;\n    // We also want to ask the creator if the transfer is fine.\n    // Note that this calls a function of the contract defined below.\n    // If the call fails (e.g. due to out-of-gas), the execution here stops\n    // immediately (the ability to catch this will be added later).\n    if (creator.isTokenTransferOK(owner, newOwner))\n      owner = newOwner;\n  }\n}\ncontract TokenCreator {\n  function createToken(bytes32 name) returns (address tokenAddress) {\n    // Create a new Token contract and return its address.\n    return address(new OwnedToken(name));\n  }\n  function changeName(address tokenAddress, bytes32 name) {\n    // We need an explicit type conversion because contract types are not part of the ABI.\n    OwnedToken token = OwnedToken(tokenAddress);\n    token.changeName(name);\n  }\n  function isTokenTransferOK(address currentOwner, address newOwner) returns (bool ok) {\n    // Check some arbitrary condition.\n    address tokenAddress = msg.sender;\n    return (sha3(newOwner) & 0xff) == (bytes20(tokenAddress) & 0xff);\n  }\n}\n```\n\n\n## \u30b3\u30f3\u30b9\u30c8\u30e9\u30af\u30bf\u306e\u5f15\u6570\n\nSolidiy\u306e\u30b3\u30f3\u30c8\u30e9\u30af\u30c8\u306f\u3001\u30b3\u30f3\u30c8\u30e9\u30af\u30c8\u30fb\u30c7\u30fc\u30bf\u81ea\u8eab\u306e\u7d42\u308f\u308a\u306e\u5f8c\u306b\u30b3\u30f3\u30b9\u30c8\u30e9\u30af\u30bf\u306e\u5f15\u6570\u3092\u671f\u5f85\u3057\u3066\u3044\u308b\u3002\n\u3064\u307e\u308a\u3001\u901a\u5e38\u306eABI\u5f62\u5f0f\u306e\u30b3\u30f3\u30d1\u30a4\u30e9\u306b\u3088\u3063\u3066\u8fd4\u3055\u308c\u308b\u3088\u3046\u306a\u5f62\u3067\u3001\u30b3\u30f3\u30d1\u30a4\u30eb\u3055\u308c\u305f\u30d0\u30a4\u30c8\u306e\u5f8c\u306b\u7f6e\u304f\u3053\u3068\u3067\u30b3\u30f3\u30c8\u30e9\u30af\u30c8\u306b\u5f15\u6570\u3092\u6e21\u3059\u3002\n\n## \u30b3\u30f3\u30c8\u30e9\u30af\u30c8\u306e\u7d99\u627f\n\nSolidity\u306f\u3001\u30dd\u30ea\u30e2\u30fc\u30d5\u30a3\u30ba\u30e0\u3092\u542b\u3080\u30b3\u30fc\u30c9\u3092\u30b3\u30d4\u30fc\u3059\u308b\u3053\u3068\u3067\u3001\u591a\u91cd\u7d99\u627f\u3092\u30b5\u30dd\u30fc\u30c8\u3059\u308b\u3002\n\n```\ncontract owned {\n    function owned() { owner = msg.sender; }\n    address owner;\n}\n\n// Use \"is\" to derive from another contract. Derived contracts can access all members\n// including private functions and state variables.\ncontract mortal is owned {\n    function kill() { if (msg.sender == owner) suicide(owner); }\n}\n\n// These are only provided to make the interface known to the compiler.\ncontract Config { function lookup(uint id) returns (address adr) {} }\ncontract NameReg { function register(bytes32 name) {} function unregister() {} }\n\n// Multiple inheritance is possible. Note that \"owned\" is also a base class of\n// \"mortal\", yet there is only a single instance of \"owned\" (as for virtual\n// inheritance in C++).\ncontract named is owned, mortal {\n    function named(bytes32 name) {\n        address ConfigAddress = 0xd5f9d8d94886e70b06e474c3fb14fd43e2f23970;\n        NameReg(Config(ConfigAddress).lookup(1)).register(name);\n    }\n\n// Functions can be overridden, both local and message-based function calls take\n// these overrides into account.\n    function kill() {\n        if (msg.sender == owner) {\n            address ConfigAddress = 0xd5f9d8d94886e70b06e474c3fb14fd43e2f23970;\n            NameReg(Config(ConfigAddress).lookup(1)).unregister();\n// It is still possible to call a specific overridden function. \n            mortal.kill();\n        }\n    }\n}\n\n// If a constructor takes an argument, it needs to be provided in the header.\ncontract PriceFeed is owned, mortal, named(\"GoldFeed\") {\n   function updateInfo(uint newInfo) {\n      if (msg.sender == owner) info = newInfo;\n   }\n\n   function get() constant returns(uint r) { return info; }\n\n   uint info;\n}\n```\n\n\u4e0a\u8a18\u3067\u66f8\u3044\u305f\u3088\u3046\u306b\u3001destruction\u30ea\u30af\u30a8\u30b9\u30c8\u3092\u30d5\u30a9\u30ef\u30fc\u30c9\u3059\u308b\u305f\u3081\u306b\u3001mortal.kill() \u3092\u547c\u3076\u3002\n\n```\ncontract mortal is owned {\n    function kill() { if (msg.sender == owner) suicide(owner); }\n}\ncontract Base1 is mortal {\n    function kill() { /* do cleanup 1 */ mortal.kill(); }\n}\ncontract Base2 is mortal {\n    function kill() { /* do cleanup 2 */ mortal.kill(); }\n}\ncontract Final is Base1, Base2 {\n}\n```\n\n\n(\u7565)\n\n\n## \u591a\u91cd\u7d99\u627f\u3068\u7dda\u5f62\u5316\n\n(WIP)\n\n## \u62bd\u8c61\u30b3\u30f3\u30c8\u30e9\u30af\u30c8\n\n\n(WIP)\n\n## Visibility Specifiers\n\npublic, internal, private\n\n(WIP)\n\n## Accessor Functions\n\n(WIP)\n\n## Fallback\u95a2\u6570\n\n```\ncontract Test {\n  function() { x = 1; }\n  uint x;\n}\n\ncontract Caller {\n  function callTest(address testAddress) {\n    Test(testAddress).call(0xabcdefgh); // hash does not exist\n    // results in Test(testAddress).x becoming == 1.\n  }\n}\n```\n\n### \u95a2\u6570\u4fee\u98fe\u5b50\n\n* _\n* onlyowner\n* modifier\n\n>Modifiers can be used to easily change the behaviour of functions, for example to automatically check a condition prior to executing the function. They are inheritable properties of contracts and may be overridden by derived contracts.\n\n\n```\ncontract owned {\n  function owned() { owner = msg.sender; }\n  address owner;\n\n  // This contract only defines a modifier but does not use it - it will\n  // be used in derived contracts.\n  // The function body is inserted where the special symbol \"_\" in the\n  // definition of a modifier appears.\n  modifier onlyowner { if (msg.sender == owner) _ }\n}\ncontract mortal is owned {\n  // This contract inherits the \"onlyowner\"-modifier from \"owned\" and\n  // applies it to the \"kill\"-function, which causes that calls to \"kill\"\n  // only have an effect if they are made by the stored owner.\n  function kill() onlyowner {\n    suicide(owner);\n  }\n}\ncontract priced {\n  // Modifiers can receive arguments:\n  modifier costs(uint price) { if (msg.value >= price) _ }\n}\ncontract Register is priced, owned {\n  mapping (address => bool) registeredAddresses;\n  uint price;\n  function Register(uint initialPrice) { price = initialPrice; }\n  function register() costs(price) {\n    registeredAddresses[msg.sender] = true;\n  }\n  function changePrice(uint _price) onlyowner {\n    price = _price;\n  }\n}\n```\n\n>Multiple modifiers can be applied to a function by specifying them in a whitespace-separated list and will be evaluated in order. Explicit returns from a modifier or function body immediately leave the whole function, while control flow reaching the end of a function or modifier body continues after the \"_\" in the preceding modifier. Arbitrary expressions are allowed for modifier arguments and in this context, all symbols visible from the function are visible in the modifier. Symbols introduced in the modifier are not visible in the function (as they might change by overriding).\n\n\n## \u30a4\u30d9\u30f3\u30c8\n\n\u30a4\u30d9\u30f3\u30c8\u306f\u3001EVM\u306e\u30ed\u30ae\u30f3\u30b0\u30fb\u30d5\u30a1\u30b7\u30ea\u30c6\u30a3\u306e\u5bb9\u6613\u306a\u5229\u7528\u3092\u8a31\u3059\u3002\u30a4\u30d9\u30f3\u30c8\u306f\u3001\u30b3\u30f3\u30c8\u30e9\u30af\u30c8\u306e\u7d99\u627f\u53ef\u80fd\u306a\u30e1\u30f3\u30d0\u30fc\u3002\u30a4\u30d9\u30f3\u30c8\u304c\u547c\u3070\u308c\u305f\u6642\u306b\u3001\u5f15\u6570\u304c\u30c8\u30e9\u30f3\u30b6\u30af\u30b7\u30e7\u30f3\u30ed\u30b0\u306b\u4fdd\u5b58\u3055\u308c\u308b\u3002\u6700\u59273\u3064\u306e\u30d1\u30e9\u30e1\u30fc\u30bf\u304c\u3001indexed\u5c5e\u6027\u3092\u53d7\u3051\u4ed8\u3051\u308b\u3053\u3068\u304c\u3067\u304d\u308b\u3002\n\n(WIP)\n\n```\ncontract ClientReceipt {\n  event Deposit(address indexed _from, bytes32 indexed _id, uint _value);\n  function deposit(bytes32 _id) {\n    Deposit(msg.sender, _id, msg.value);\n  }\n}\n```\n\nDeposit\u3092\u547c\u3076\u306e\u306f\u3001log3(msg.value, 0x50cb9fe53daa9737b786ab3646f04d0150dc50ef4e75f59509d83667ad5adb20, sha3(msg.sender), _id); \u3068\u540c\u3058\u3002\n\n\n## Layout of State Variables in Storage\n\n(WIP)\n\n>Statically-sized variables (everything except mapping and dynamically-sized array types) are laid out contiguously in storage starting from position 0. Multiple items that need less than 32 bytes are packed into a single storage slot if possible, according to the following rules:\n>\n>The first item in a storage slot is stored lower-order aligned.\nElementary types use only that many bytes that are necessary to store them.\n>If an elementary type does not fit the remaining part of a storage slot, it is moved to the next storage slot.\nStructs and array data always start a new slot and occupy whole slots (but items inside a struct or array are packed tightly according to these rules).\nThe elements of structs and arrays are stored after each other, just as if they were given explicitly.\n>\n>Due to their unpredictable size, mapping and dynamically-sized array types use a sha3 computation to find the starting position of the value or the array data. These starting positions are always full stack slots.\n>\n>The mapping or the dynamic array itself occupies an (unfilled) slot in storage at some position p according to the above rule (or by recursively applying this rule for mappings to mappings or arrays of arrays). For a dynamic array, this slot stores the number of elements in the array. For a mapping, the slot is unused (but it is needed so that two equal mappings after each other will use a different hash distribution). Array data is located at sha3(p) and the value corresponding to a mapping key k is located at sha3(k . p) where . is concatenation. If the value is again a non-elementary type, the positions are found by adding an offset of sha3(k . p).\n>\n>So for the following contract snippet:\n\n```\ncontract c {\n  struct S { uint a; uint b; }\n  uint x;\n  mapping(uint => mapping(uint => S)) data;\n}\n```\n\n>The position of data[4][9].b is at sha3(uint256(9) . sha3(uint256(4) . uint(256(1))) + 1.\n\n\n\n## Esoteric Features\n\n\n(WIP)\n\n>There are some types in Solidity's type system that have no counterpart in the syntax. One of these types are the types of functions. But still, using var it is possible to have local variables of these types:\n>\n```\ncontract FunctionSelector {\n  function select(bool useB, uint x) returns (uint z) {\n    var f = a;\n    if (useB) f = b;\n    return f(x);\n  }\n  function a(uint x) returns (uint z) {\n    return x * x;\n  }\n  function b(uint x) returns (uint z) {\n    return 2 * x;\n  }\n}\nCalling select(false, x) will compute x * x and select(true, x) will compute 2 * x.\n```\n\n## Internals - the Optimizer\n\n(WIP)\n\n## \u30c1\u30fc\u30c8\u30b7\u30fc\u30c8\n\n(WIP)\n\n\n\n\u4ee5\u4e0b\u3001\u5225\u306e\u30c9\u30ad\u30e5\u30e1\u30f3\u30c8\u304b\u3089\n\n## Simple Sample\n\n\n```Solidty\ncontract Coin {\n    address minter;\n    mapping (address => uint) balances;\n\n    event Send(address from, address to, uint value);\n\n    function Coin() {\n        minter = msg.sender;\n    }\n   \n    function mint(address owner, uint amount) {\n        if (msg.sender != minter) return;\n        balances[owner] += amount;\n    }\n    function send(address receiver, uint amount) {\n        if (balances[msg.sender] < amount) return;\n        balances[msg.sender] -= amount;\n        balances[receiver] += amount;\n        Send(msg.sender, receiver, amount);\n    }\n    function queryBalance(address addr) constant returns (uint balance) {\n        return balances[addr];\n    }\n}\n```\n\n\n* uint: unsigned integer of 256 bits\n* address: a 160 bit value that does not allow any arithmetic operations\n* the state variable balances is of a complex datatype that maps addresses to unsigned integers\n* Mappings can be seen as hashtables which are virtually initialized such that every possible key exists and is mapped to a value whose byte-representation is all zeros\n", "tags": ["solidity", "Ethereum"]}