{"context": " More than 1 year has passed since last update.The first version of my article was pretty messy, and Andre helped rewrite it so that it was cleaner and pure.\n\nWhy Cycle.js?\nIt's pretty neat in how it lets you write your application in terms of data streams (implemented in RxJS) using Observables that return a VDOM tree, and it's in many ways \"the next step\" to what I described in my previous post \"Using RxJS for data flow instead of Flux with React\".\nThere are three big differences from React:\n\nNo \"component lifecycle\" -- in React, I abuse the component lifecycle in order to do things after a \"logical component\" has been rendered, so that I can manipulate the DOM nodes in the document directly. But in return, because of the large cost of these component lifecycle events (and React-style mixins), if you want to render a large number of items, you have to get pretty creative with how you limit component render calls.\nNo component state -- in React, I might store a lot of data that only the component cares about, but then makes things more tricky to debug, as app state is a product of app state + the sum of all component states.\nWrite functions, not class/object definitions -- It's very convenient to just create React component definitions and stick them into other components' render methods and all, but it is very heavy compared to a simple function that returns VDOM trees.\n\nI think the two features in React make React very easy to use, but are quite dangerous and really annoying to debug. There are definitely a lot of people who are switching to a \"props-only\" approach to React components, but you still do deal with everything else being there. Well, not that we don't already restrict ourselves elsewhere.\nWell, we might as well get started with the actual code.\n\nCode time\n\nInitial project setup\nLet's get some basic stuff set up in our project:\nsrc\n  main.js\n.gitignore\nindex.html\npackage.json\nwebpack.config.js\n\nI use webpack to build my javascripts, babel to do my ES6 compilation, and npm to download my packages.\nDownload away with npm i -D [module_name]: https://github.com/justinwoo/cycle-scroll-table/blob/25ca120416fb42a74ad8cf489f8d20a3ed84290b/package.json\nSet up your webpack config: https://github.com/justinwoo/cycle-scroll-table/blob/25ca120416fb42a74ad8cf489f8d20a3ed84290b/webpack.config.js\nSet up your npm start task: https://github.com/justinwoo/cycle-scroll-table/blob/25ca120416fb42a74ad8cf489f8d20a3ed84290b/package.json#L7\nWrite some boilerplate HTML for index.html: https://github.com/justinwoo/cycle-scroll-table/blob/25ca120416fb42a74ad8cf489f8d20a3ed84290b/index.html\n\nUpdated project setup\nThis used to use a very lazy setup, but Andre helped turn it into a proper Model-View-Intent application.\n\u25be src/\n  \u25be models/\n      main-model.js -- our main app model as a function of our actions stream\n      make-visible-indices.js -- function for aggregating streams to make the visible indices stream\n  \u25be views/\n      main-view.js -- the main view of our app as a function of our state stream\n      tbody.js -- a simple function for calculating my tbody\n      thead.js -- another simple function for calculating my thead\n    intent.js -- a function for the intent, as a function of our DOM object that we can use to create an object of streams\n    main.js -- the main entry point of our app\n\n\nGetting started/app bootstrap\nmain.js:\nimport Cycle from '@cycle/core'; // bring in CycleJS core stuff\nimport CycleWeb from '@cycle/web'; // bring in CycleJS Web driver for DOM interaction and whatnot\n\nimport intent from './intent'; // bring in the intent in our app\nimport model from './models/main-model'; // same for model\nimport view from './views/main-view'; // same for view\n\nfunction main({DOM}) {\n  let actions = intent(DOM); // supply the DOM object to intent to get the actions\n  let state$ = model(actions); // then feed the actions object of streams to model to get our current state\n  let vtree$ = view(state$); // then feed our state into the view to get the snapshot view of that state\n  return { DOM: vtree$ }; // return this vtree stream the DOM driver to consume\n}\n\nlet drivers = {\n  DOM: CycleWeb.makeDOMDriver('#app')\n};\n\nlet drivers = {\n  DOM: CycleWeb.makeDOMDriver('#app') // take over the main app container to render my VDOM to\n};\n\nCycle.run(main, drivers); // run Cycle.js, like React.render in a way, using the main function defined above\n\n\nIntent\nOur application only has a single action to be handled. intent.js\nfunction intent(DOM) {\n  let actions = {\n    userScrolled$: DOM.get('#scroll-table-container', 'scroll')\n      .map(e => e.srcElement.scrollTop)\n  };\n  return actions;\n}\n\nexport default intent;\n\nThe DOM object comes from main, where we can use the get method of this object to get our rendered node so that we can handle scroll events.\n\nModel\nThis is where we take the actions stream and create a state stream based on that. model.js\nimport {Rx} from '@cycle/core';\n\nimport makeVisibleIndices$ from './make-visible-indices';\n\nfunction model(actions) {\n  let tableHeight$ = Rx.Observable.just(500);\n  let rowHeight$ = Rx.Observable.just(30);\n  let columns$ = Rx.Observable.just(['ID', 'ID * 10', 'Random Number']);\n  let rowCount$ = Rx.Observable.just(10000);\n  let scrollTop$ = actions.userScrolled$.startWith(0);\n  let visibleIndices$ = makeVisibleIndices$(\n    tableHeight$, rowHeight$, rowCount$, scrollTop$\n  );\n  let state$ = Rx.Observable.combineLatest(\n    tableHeight$, rowHeight$, columns$, rowCount$, visibleIndices$,\n    (tableHeight, rowHeight, columns, rowCount, visibleIndices) =>\n      ({tableHeight, rowHeight, columns, rowCount, visibleIndices})\n  );\n  return state$;\n}\n\nexport default model;\n\n\nMaking the Visible Indices Stream\nOf course, I'm not very original. The original algorithm was written in Eric Miller's article \"Create an Infinite Scroll List with Bacon.js\".\nmake-visible-indices.js\n// just bring in Rx from Cycle Core\nimport {Rx} from '@cycle/core';\n\n// get the visible indices stream as a function of the streams that make up the data for this\nfunction makeVisibleIndices$(tableHeight$, rowHeight$, rowCount$, scrollTop$) {\n  // calculate what the first visible row will be based off the height of the rows and how far we scrolled down\n  // limit the stream output to distinct values per click\n  let firstVisibleRow$ = Rx.Observable.combineLatest(scrollTop$, rowHeight$,\n    (scrollTop, rowHeight) => Math.floor(scrollTop / rowHeight)\n  ).distinctUntilChanged();\n\n  // calculate how many rows will even be visible, i.e. how many rows fit into the height of the table\n  let visibleRows$ = Rx.Observable.combineLatest(tableHeight$, rowHeight$,\n    (tableHeight, rowHeight) => Math.ceil(tableHeight / rowHeight)\n  );\n\n  // calculate the visible indices based on the above two streams and how many rows we have in our application\n  let visibleIndices$ = Rx.Observable.combineLatest(\n    rowCount$, visibleRows$, firstVisibleRow$,\n    (rowCount, visibleRows, firstVisibleRow) => {\n      let visibleIndices = [];\n      let lastRow = firstVisibleRow + visibleRows + 1;\n\n      if (lastRow > rowCount) {\n        firstVisibleRow -= lastRow - rowCount;\n      }\n\n      for (let i = 0; i <= visibleRows; i++) {\n        visibleIndices.push(i + firstVisibleRow);\n      }\n      return visibleIndices;\n    }\n  );\n\n  return visibleIndices$;\n}\n\nexport default makeVisibleIndices$;\n\n\nMy view functions\nAnd so, using the state stream we get from our model, we can render our view. views/main-view.js\nimport Cycle from '@cycle/core';\nimport {h} from '@cycle/web';\n\nimport renderTHead from './thead';\nimport renderTBody from './tbody';\n\n// returns a vtree stream based on this state stream\nfunction view(state$) {\n  return state$.map(({tableHeight, rowHeight, columns, rowCount, visibleIndices}) =>\n    h(\n      'div#app-container',\n      [\n        h(\n          'table#static-header-table',\n          {\n            style: {\n              overflowX: 'hidden',\n              borderBottom: '1px solid black'\n            }\n          },\n          renderTHead(columns) // get the vtree of THead as a product of columns\n        ),\n        h(\n          'div#scroll-table-container',\n          {\n            style: {\n              position: 'relative',\n              overflowX: 'hidden',\n              borderBottom: '1px solid black',\n              height: tableHeight + 'px',\n            }\n          },\n          h(\n            'table#scroll-table',\n            {\n              style: {\n                height: rowCount * rowHeight + 'px'\n              }\n            },\n            renderTBody(rowHeight, visibleIndices) // same for TBody, using row heights and visible indices\n          )\n        )\n      ]\n    )\n  );\n}\n\nexport default view;\n\nviews/thead.js\nviews/tbody.js\n\nWrapping up\nCheck out the repo and demo here: https://github.com/justinwoo/cycle-scroll-table\nAs you've probably noticed, I pasted most of all 167 lines of code for this application in this article. Does that seem like a lot? The React version with components and RxJS is around the same number of lines, but uses a lot of complicated local component state to figure stuff out with the rendered DOM nodes.\nOverall, I really enjoyed trying out Cycle.js. It seems like a really hardcore framework at first, but it's actually quite practical and isn't too hard to use, especially if you already use React or RxJS.\nThough, if I had to give some complaints based on one day of use, it'd be...\n\nNot enough fanboys -- having a huge userbase is important for being able to use other people's ideas and code (just look at React, Angular, jQuery). With a big focus in purity and reactive programming, I think this is a little punishing for people who want to write easy code, me included.\nNo JSX -- it's WIP, so this complaint will be addressed and go away soon, but this is important to me. Not because I need JSX, but I like using it to easily guess what I'm going to get in my output, and it's familiar. Not to mention, I can introduce React to almost any project and everyone can contribute code very easily, which will inevitably be harder with the virtual-hyperscript functions.\nNot a lot of people care about reactive programming (in JS) -- I think code is simpler and easier to write using some basic Observables and Subjects with operators like Combine Latest, but a lot of people really want async single-value resolution and event emitters. I think that kind of coding is really hard to debug and follow through, but alas, that's what a lot of people code with. Maybe more articles and works like Dan Abramov's Redux will make people start to care more about different ways to do things, but who knows. Some people also love channels, but to me, that's like eating wet rice with chopsticks -- you can do it, and you can glue together chopsticks and carve out a scoop, but shit, I just want a spoon from the start.\n\nIf you got this far, thanks for reading! (or for just scrolling down)\nLet me know on Twitter if this sucks or is kind of okay.\nThanks again to Andre, who fixed this code to make it pure and much cleaner.\n\nUpdate #1\nAndre helped fix all of my code, so I'll be rewriting a large chunk/all of this article accordingly.\n\nUpdate #2\nRewrote chunks of this article accordingly with the MVI bits.\n\nUpdate #3: React-based views\nBecause Cycle.js is mostly just architecture that facilitates cyclical streams, it's easy to just substitute in React-based views.\nAll of the changes are in this commit.\nMain differences:\n\nI no longer have Cycle.js handling cyclical events for me, so now I use Subjects to have event handlers feed events to them.\nI have the output stream output a React Element tree.\nI subscribe to this output stream with a React.render for my output and target container.\nI have to provide key data for React's reconciliation.\n\nThere might be some real use to this other than just for having familiar React code, such as reusing some of the animation tools that are being developed for React. Otherwise, this is just a demonstration of how Cycle.js applications don't require massive buy-in to anything other than RxJS Observables.\n\nLinks\n\nCycle.js -- http://cycle.js.org/getting-started.html\n\nRxJS -- https://github.com/Reactive-Extensions/RxJS/\n\nMy Repo for this -- https://github.com/justinwoo/cycle-scroll-table\n\n\n\nThe first version of my article was pretty messy, and [Andre](https://twitter.com/andrestaltz) helped [rewrite it](https://github.com/justinwoo/cycle-scroll-table/pull/2) so that it was cleaner and pure.\n\n# Why Cycle.js?\n\nIt's pretty neat in how it lets you write your application in terms of data streams (implemented in RxJS) using Observables that return a VDOM tree, and it's in many ways \"the next step\" to what I described in my previous post [\"Using RxJS for data flow instead of Flux with React\"](http://qiita.com/kimagure/items/22cf4bb2a967fcba376e).\n\nThere are three big differences from React:\n\n1. No \"component lifecycle\" -- in React, I abuse the component lifecycle in order to do things after a \"logical component\" has been rendered, so that I can manipulate the DOM nodes in the document directly. But in return, because of the large cost of these component lifecycle events (and React-style mixins), if you want to render a large number of items, you have to get pretty creative with how you limit component `render` calls.\n2. No component state -- in React, I might store a lot of data that only the component cares about, but then makes things more tricky to debug, as app state is a product of app state + the sum of all component states.\n3. Write functions, not class/object definitions -- It's very convenient to just create React component definitions and stick them into other components' `render` methods and all, but it is very heavy compared to a simple function that returns VDOM trees.\n\nI think the two features in React make React very easy to use, but are quite dangerous and really annoying to debug. There are definitely a lot of people who are switching to a \"props-only\" approach to React components, but you still do deal with everything else being there. Well, not that we don't already restrict ourselves elsewhere.\n\nWell, we might as well get started with the actual code.\n\n# Code time\n\n## Initial project setup\n\nLet's get some basic stuff set up in our project:\n\n```text\nsrc\n  main.js\n.gitignore\nindex.html\npackage.json\nwebpack.config.js\n```\n\nI use webpack to build my javascripts, babel to do my ES6 compilation, and npm to download my packages.\n\nDownload away with `npm i -D [module_name]`: https://github.com/justinwoo/cycle-scroll-table/blob/25ca120416fb42a74ad8cf489f8d20a3ed84290b/package.json\n\nSet up your webpack config: https://github.com/justinwoo/cycle-scroll-table/blob/25ca120416fb42a74ad8cf489f8d20a3ed84290b/webpack.config.js\n\nSet up your `npm start` task: https://github.com/justinwoo/cycle-scroll-table/blob/25ca120416fb42a74ad8cf489f8d20a3ed84290b/package.json#L7\n\nWrite some boilerplate HTML for `index.html`: https://github.com/justinwoo/cycle-scroll-table/blob/25ca120416fb42a74ad8cf489f8d20a3ed84290b/index.html\n\n## Updated project setup\n\nThis used to use a very lazy setup, but Andre helped turn it into a proper Model-View-Intent application.\n\n```\n\u25be src/\n  \u25be models/\n      main-model.js -- our main app model as a function of our actions stream\n      make-visible-indices.js -- function for aggregating streams to make the visible indices stream\n  \u25be views/\n      main-view.js -- the main view of our app as a function of our state stream\n      tbody.js -- a simple function for calculating my tbody\n      thead.js -- another simple function for calculating my thead\n    intent.js -- a function for the intent, as a function of our DOM object that we can use to create an object of streams\n    main.js -- the main entry point of our app\n```\n\n## Getting started/app bootstrap\n\n[main.js](https://github.com/justinwoo/cycle-scroll-table/blob/25ca120416fb42a74ad8cf489f8d20a3ed84290b/src/main.js):\n\n```js\nimport Cycle from '@cycle/core'; // bring in CycleJS core stuff\nimport CycleWeb from '@cycle/web'; // bring in CycleJS Web driver for DOM interaction and whatnot\n\nimport intent from './intent'; // bring in the intent in our app\nimport model from './models/main-model'; // same for model\nimport view from './views/main-view'; // same for view\n\nfunction main({DOM}) {\n  let actions = intent(DOM); // supply the DOM object to intent to get the actions\n  let state$ = model(actions); // then feed the actions object of streams to model to get our current state\n  let vtree$ = view(state$); // then feed our state into the view to get the snapshot view of that state\n  return { DOM: vtree$ }; // return this vtree stream the DOM driver to consume\n}\n\nlet drivers = {\n  DOM: CycleWeb.makeDOMDriver('#app')\n};\n\nlet drivers = {\n  DOM: CycleWeb.makeDOMDriver('#app') // take over the main app container to render my VDOM to\n};\n\nCycle.run(main, drivers); // run Cycle.js, like React.render in a way, using the main function defined above\n```\n\n## Intent\n\nOur application only has a single action to be handled. [intent.js](https://github.com/justinwoo/cycle-scroll-table/blob/25ca120416fb42a74ad8cf489f8d20a3ed84290b/src/intent.js)\n\n```js\nfunction intent(DOM) {\n  let actions = {\n    userScrolled$: DOM.get('#scroll-table-container', 'scroll')\n      .map(e => e.srcElement.scrollTop)\n  };\n  return actions;\n}\n\nexport default intent;\n```\n\nThe `DOM` object comes from main, where we can use the `get` method of this object to get our rendered node so that we can handle scroll events.\n\n## Model\n\nThis is where we take the actions stream and create a state stream based on that. [model.js](https://github.com/justinwoo/cycle-scroll-table/blob/982d252b8411e4d3e3d4218dda4584aca7f8d2ae/src/models/main-model.js)\n\n```js\nimport {Rx} from '@cycle/core';\n\nimport makeVisibleIndices$ from './make-visible-indices';\n\nfunction model(actions) {\n  let tableHeight$ = Rx.Observable.just(500);\n  let rowHeight$ = Rx.Observable.just(30);\n  let columns$ = Rx.Observable.just(['ID', 'ID * 10', 'Random Number']);\n  let rowCount$ = Rx.Observable.just(10000);\n  let scrollTop$ = actions.userScrolled$.startWith(0);\n  let visibleIndices$ = makeVisibleIndices$(\n    tableHeight$, rowHeight$, rowCount$, scrollTop$\n  );\n  let state$ = Rx.Observable.combineLatest(\n    tableHeight$, rowHeight$, columns$, rowCount$, visibleIndices$,\n    (tableHeight, rowHeight, columns, rowCount, visibleIndices) =>\n      ({tableHeight, rowHeight, columns, rowCount, visibleIndices})\n  );\n  return state$;\n}\n\nexport default model;\n```\n\n## Making the Visible Indices Stream\n\nOf course, I'm not very original. The original algorithm was written in [Eric Miller](https://twitter.com/SimplGy)'s article [\"Create an Infinite Scroll List with Bacon.js\"](http://www.simple.gy/blog/infinite-bacon/).\n\n[make-visible-indices.js](https://github.com/justinwoo/cycle-scroll-table/blob/25ca120416fb42a74ad8cf489f8d20a3ed84290b/src/models/make-visible-indices.js)\n\n```js\n// just bring in Rx from Cycle Core\nimport {Rx} from '@cycle/core';\n\n// get the visible indices stream as a function of the streams that make up the data for this\nfunction makeVisibleIndices$(tableHeight$, rowHeight$, rowCount$, scrollTop$) {\n  // calculate what the first visible row will be based off the height of the rows and how far we scrolled down\n  // limit the stream output to distinct values per click\n  let firstVisibleRow$ = Rx.Observable.combineLatest(scrollTop$, rowHeight$,\n    (scrollTop, rowHeight) => Math.floor(scrollTop / rowHeight)\n  ).distinctUntilChanged();\n\n  // calculate how many rows will even be visible, i.e. how many rows fit into the height of the table\n  let visibleRows$ = Rx.Observable.combineLatest(tableHeight$, rowHeight$,\n    (tableHeight, rowHeight) => Math.ceil(tableHeight / rowHeight)\n  );\n\n  // calculate the visible indices based on the above two streams and how many rows we have in our application\n  let visibleIndices$ = Rx.Observable.combineLatest(\n    rowCount$, visibleRows$, firstVisibleRow$,\n    (rowCount, visibleRows, firstVisibleRow) => {\n      let visibleIndices = [];\n      let lastRow = firstVisibleRow + visibleRows + 1;\n\n      if (lastRow > rowCount) {\n        firstVisibleRow -= lastRow - rowCount;\n      }\n\n      for (let i = 0; i <= visibleRows; i++) {\n        visibleIndices.push(i + firstVisibleRow);\n      }\n      return visibleIndices;\n    }\n  );\n\n  return visibleIndices$;\n}\n\nexport default makeVisibleIndices$;\n```\n\n## My view functions\n\nAnd so, using the state stream we get from our model, we can render our view. [views/main-view.js](https://github.com/justinwoo/cycle-scroll-table/blob/25ca120416fb42a74ad8cf489f8d20a3ed84290b/src/views/main-view.js)\n\n```js\nimport Cycle from '@cycle/core';\nimport {h} from '@cycle/web';\n\nimport renderTHead from './thead';\nimport renderTBody from './tbody';\n\n// returns a vtree stream based on this state stream\nfunction view(state$) {\n  return state$.map(({tableHeight, rowHeight, columns, rowCount, visibleIndices}) =>\n    h(\n      'div#app-container',\n      [\n        h(\n          'table#static-header-table',\n          {\n            style: {\n              overflowX: 'hidden',\n              borderBottom: '1px solid black'\n            }\n          },\n          renderTHead(columns) // get the vtree of THead as a product of columns\n        ),\n        h(\n          'div#scroll-table-container',\n          {\n            style: {\n              position: 'relative',\n              overflowX: 'hidden',\n              borderBottom: '1px solid black',\n              height: tableHeight + 'px',\n            }\n          },\n          h(\n            'table#scroll-table',\n            {\n              style: {\n                height: rowCount * rowHeight + 'px'\n              }\n            },\n            renderTBody(rowHeight, visibleIndices) // same for TBody, using row heights and visible indices\n          )\n        )\n      ]\n    )\n  );\n}\n\nexport default view;\n```\n\n[views/thead.js](https://github.com/justinwoo/cycle-scroll-table/blob/25ca120416fb42a74ad8cf489f8d20a3ed84290b/src/views/thead.js)\n\n[views/tbody.js](https://github.com/justinwoo/cycle-scroll-table/blob/25ca120416fb42a74ad8cf489f8d20a3ed84290b/src/views/tbody.js)\n\n# Wrapping up\n\nCheck out the repo and demo here: https://github.com/justinwoo/cycle-scroll-table\n\nAs you've probably noticed, I pasted most of all 167 lines of code for this application in this article. Does that seem like a lot? The React version with components and RxJS is around the same number of lines, but uses a lot of complicated local component state to figure stuff out with the rendered DOM nodes.\n\nOverall, I really enjoyed trying out Cycle.js. It seems like a really hardcore framework at first, but it's actually quite practical and isn't too hard to use, especially if you already use React or RxJS.\n\nThough, if I had to give some complaints based on one day of use, it'd be...\n\n1. Not enough fanboys -- having a huge userbase is important for being able to use other people's ideas and code (just look at React, Angular, jQuery). With a big focus in purity and reactive programming, I think this is a little punishing for people who want to write easy code, me included.\n2. No JSX -- it's WIP, so this complaint will be addressed and go away soon, but this is important to me. Not because I need JSX, but I like using it to easily guess what I'm going to get in my output, and it's familiar. Not to mention, I can introduce React to almost any project and everyone can contribute code very easily, which will inevitably be harder with the [virtual-hyperscript](https://github.com/Matt-Esch/virtual-dom/tree/master/virtual-hyperscript) functions.\n3. Not a lot of people care about reactive programming (in JS) -- I think code is simpler and easier to write using some basic Observables and Subjects with operators like Combine Latest, but a lot of people really want async single-value resolution and event emitters. I think that kind of coding is really hard to debug and follow through, but alas, that's what a lot of people code with. Maybe more articles and works like Dan Abramov's [Redux](https://github.com/gaearon/redux) will make people start to care more about different ways to do things, but who knows. Some people also love channels, but to me, that's like eating wet rice with chopsticks -- you can do it, and you can glue together chopsticks and carve out a scoop, but shit, I just want a spoon from the start.\n\nIf you got this far, thanks for reading! (or for just scrolling down)\n\nLet me know on [Twitter](https://twitter.com/jusrin00) if this sucks or is kind of okay.\n\nThanks again to Andre, who fixed this code to make it pure and much cleaner.\n\n# Update #1\n\nAndre helped fix [all of my code](https://github.com/justinwoo/cycle-scroll-table/pull/2), so I'll be rewriting a large chunk/all of this article accordingly.\n\n# Update #2\n\nRewrote chunks of this article accordingly with the MVI bits.\n\n# Update #3: React-based views\n\nBecause Cycle.js is mostly just architecture that facilitates cyclical streams, it's easy to just substitute in React-based views.\n\nAll of the changes are in [this commit](https://github.com/justinwoo/cycle-scroll-table/commit/28b8e6cf81b2bdb0f552ae2f8be77f0372d2f301).\n\nMain differences:\n\n1. I no longer have Cycle.js handling cyclical events for me, so now I use Subjects to have event handlers feed events to them.\n2. I have the output stream output a React Element tree.\n3. I subscribe to this output stream with a React.render for my output and target container.\n4. I have to provide key data for React's reconciliation.\n\nThere might be some real use to this other than just for having familiar React code, such as reusing some of the animation tools that are being developed for React. Otherwise, this is just a demonstration of how Cycle.js applications don't require massive buy-in to anything other than RxJS Observables.\n\n# Links\n\n* Cycle.js -- http://cycle.js.org/getting-started.html\n* RxJS -- https://github.com/Reactive-Extensions/RxJS/\n* My Repo for this -- https://github.com/justinwoo/cycle-scroll-table\n", "tags": ["cycle.js", "reactjs", "JavaScript", "RxJS"]}