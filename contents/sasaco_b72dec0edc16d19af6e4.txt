{"context": "\n\n\u30b7\u30ea\u30fc\u30ba\u76ee\u6b21\n\n\u30bb\u30b0\u30a6\u30a7\u30a4\u3092\u81ea\u4f5c\u3057\u3066\u307f\u305f \uff5e\u6750\u6599\u7de8\uff5e\n\u30bb\u30b0\u30a6\u30a7\u30a4\u3092\u81ea\u4f5c\u3057\u3066\u307f\u305f \uff5e\u96fb\u5b50\u56de\u8def\u7d44\u7acb\u7de8\uff5e\n\u30bb\u30b0\u30a6\u30a7\u30a4\u3092\u81ea\u4f5c\u3057\u3066\u307f\u305f \uff5e\u30d7\u30ed\u30b0\u30e9\u30e0\u7de8\uff5e\n\u30bb\u30b0\u30a6\u30a7\u30a4\u3092\u81ea\u4f5c\u3057\u3066\u307f\u305f \uff5e\u30dc\u30c7\u30a3\u30fc\u7d44\u7acb\u7de8\uff5e\n\n\n\u3053\u306e\u5206\u91ce\u3067\u306f\u9580\u5916\u6f22\u306e\u79c1\u304c\u3001\u300c\u96fb\u5b50\u5236\u5fa1\u300d\u3092\u307e\u3063\u305f\u304f\u52c9\u5f37\u305b\u305a\u306b\n\u30bb\u30b0\u30a6\u30a7\u30a4\u3092\u4f5c\u3063\u3066\u307f\u3088\u3046\u3068\u601d\u3044\u307e\u3059\u3002\n\u53c2\u8003\u306b\u3057\u305f\u672c\u306f\u3053\u3061\u3089\nArduino Robotics (Technology in Action)\n\u30b5\u30f3\u30d7\u30eb\u30bd\u30fc\u30b9/Segbot\n\n\u5168\u30bd\u30fc\u30b9\u30b3\u30fc\u30c9\narduino \u306f c\u8a00\u8a9e\u3067\u66f8\u304d\u307e\u3059\n\nbalancer.ino\n// \u5012\u7acb\u632f\u5b50\u3001\u52a0\u901f\u5ea6/\u30b8\u30e3\u30a4\u30ed\u30bb\u30f3\u30b5\u30fc(MPU-6050)\u7248\n// 2016/3/4\n\n#include <Wire.h>\n#include \"KalmanFilter.h\"\n#include <SoftwareSerial.h>\n#include <SabertoothSimplified.h>\n\n// \u30e2\u30fc\u30bf\u30fc\u30c9\u30e9\u30a4\u30d0\u306e\u5236\u5fa1\u5b9a\u6570\u3002\nSoftwareSerial SWSerial(NOT_A_PIN, 13); // RX on no pin (unused), TX on pin 11 (to S1).\nSabertoothSimplified ST(SWSerial); // Use SWSerial as the serial port.\n\n#define SABER_MOTOR1_FULL_FORWARD  -127\n#define SABER_MOTOR1_FULL_REVERSE  127\n#define SABER_MOTOR1_FULL_STOP  0\n\n#define SABER_MOTOR2_FULL_FORWARD  -127\n#define SABER_MOTOR2_FULL_REVERSE  127\n#define SABER_MOTOR2_FULL_STOP  0\n\n// \u52a0\u901f\u5ea6/\u30b8\u30e3\u30a4\u30ed\u30bb\u30f3\u30b5\u30fc\u306e\u5236\u5fa1\u5b9a\u6570\u3002\n#define MPU6050_ADDR         0x68 // MPU-6050 device address\n#define MPU6050_SMPLRT_DIV   0x19 // MPU-6050 register address\n#define MPU6050_CONFIG       0x1a\n#define MPU6050_GYRO_CONFIG  0x1b\n#define MPU6050_ACCEL_CONFIG 0x1c\n#define MPU6050_ACCEL_XOUT_H 0x3b\n#define MPU6050_ACCEL_XOUT_L 0x3c\n#define MPU6050_ACCEL_YOUT_H 0x3d\n#define MPU6050_ACCEL_YOUT_L 0x3e\n#define MPU6050_ACCEL_ZOUT_H 0x3f\n#define MPU6050_ACCEL_ZOUT_L 0x40\n#define MPU6050_GYRO_XOUT_H  0x43\n#define MPU6050_GYRO_XOUT_L  0x44\n#define MPU6050_GYRO_YOUT_H  0x45\n#define MPU6050_GYRO_YOUT_L  0x46\n#define MPU6050_GYRO_ZOUT_H  0x47\n#define MPU6050_GYRO_ZOUT_L  0x48\n#define MPU6050_PWR_MGMT_1   0x6b\n#define MPU6050_WHO_AM_I     0x75\n\n// \u52a0\u901f\u5ea6/\u30b8\u30e3\u30a4\u30ed\u30bb\u30f3\u30b5\u30fc\u306e\u5236\u5fa1\u5909\u6570\u3002\nKalmanFilter gKfx, gKfy; // \u30ab\u30eb\u30de\u30f3\u30d5\u30a3\u30eb\u30bf\u3002\nfloat gCalibrateX; // \u521d\u671f\u5316\u6642\u306e\u89d2\u5ea6\u3002\uff08\uff1d\u9759\u6b62\u89d2\u3068\u307f\u306a\u3059\uff09\nfloat gCalibrateY; // \u521d\u671f\u5316\u6642\u306e\u89d2\u5ea6\u3002\uff08\uff1d\u9759\u6b62\u89d2\u3068\u307f\u306a\u3059\uff09\nlong gPrevMicros;  // loop()\u9593\u9694\u306e\u8a08\u6e2c\u7528\u3002\n\n// \u5012\u7acb\u632f\u5b50\u306e\u5236\u5fa1\u5909\u6570\u3002\nfloat gPx, gIx, gDx; // \u73fe\u5728\u51fa\u529b\u5024\u3068PID\u6210\u5206\u3002\n// \u3053\u306e\u6570\u5b57\u306f\u8a66\u884c\u932f\u8aa4\u3067\u8abf\u6574\u3002\nfloat gyro_weightX = 0.98;\nfloat integra_weightX = 0;\nfloat accel_weightX = 0.02;\n\nfloat gPy, gIy, gDy; // \u73fe\u5728\u51fa\u529b\u5024\u3068PID\u6210\u5206\u3002\n// \u3053\u306e\u6570\u5b57\u306f\u8a66\u884c\u932f\u8aa4\u3067\u8abf\u6574\u3002\nfloat gyro_weightY = 0.98;\nfloat integra_weightY = 0;\nfloat accel_weightY = 0.02;\n\n// \u52a0\u901f\u5ea6/\u30b8\u30e3\u30a4\u30ed\u30bb\u30f3\u30b5\u30fc\u3078\u306e\u30b3\u30de\u30f3\u30c9\u9001\u4fe1\u3002\nvoid writeMPU6050(byte reg, byte data) {\n  Wire.beginTransmission(MPU6050_ADDR);\n  Wire.write(reg);\n  Wire.write(data);\n  Wire.endTransmission();\n}\n\n// \u52a0\u901f\u5ea6/\u30b8\u30e3\u30a4\u30ed\u30bb\u30f3\u30b5\u30fc\u304b\u3089\u306e\u30c7\u30fc\u30bf\u8aad\u307f\u8fbc\u307f\u3002\nbyte readMPU6050(byte reg) {\n  Wire.beginTransmission(MPU6050_ADDR);\n  Wire.write(reg);\n  Wire.endTransmission(false);\n  Wire.requestFrom(MPU6050_ADDR, 1/*length*/, false);\n  byte data =  Wire.read();\n  Wire.endTransmission(true);\n  return data;\n}\n\nvoid setup() {\n  Serial.begin(115200);\n\n  // \u30e2\u30fc\u30bf\u30fc\u30c9\u30e9\u30a4\u30d0\u306e\u521d\u671f\u5316\u3002\n  SWSerial.begin(9600);\n\n  // \u52a0\u901f\u5ea6/\u30b8\u30e3\u30a4\u30ed\u30bb\u30f3\u30b5\u30fc\u306e\u521d\u671f\u5316\u3002\n  Wire.begin();\n  if (readMPU6050(MPU6050_WHO_AM_I) != 0x68) {\n    Serial.println(\"\\nWHO_AM_I error.\");\n    while (true) ;\n  }\n  writeMPU6050(MPU6050_SMPLRT_DIV, 0x07);   // sample rate: 8kHz/(7+1) = 1kHz\n  writeMPU6050(MPU6050_CONFIG, 0x00);       // disable DLPF, gyro output rate = 8kHz\n  writeMPU6050(MPU6050_GYRO_CONFIG, 0x00);  // gyro range: \u00b1250dps\n  writeMPU6050(MPU6050_ACCEL_CONFIG, 0x00); // accel range: \u00b12g\n  writeMPU6050(MPU6050_PWR_MGMT_1, 0x01);   // disable sleep mode, PLL with X gyro\n  delay(2000);\n\n  // \u91cd\u529b\u52a0\u901f\u5ea6\u304b\u3089\u6c42\u3081\u305f\u89d2\u5ea6\u3092\u30ab\u30eb\u30de\u30f3\u30d5\u30a3\u30eb\u30bf\u306e\u521d\u671f\u5024\u3068\u3059\u308b\u3002\n  float ax = (readMPU6050(MPU6050_ACCEL_XOUT_H) << 8) | readMPU6050(MPU6050_ACCEL_XOUT_L);\n  float ay = (readMPU6050(MPU6050_ACCEL_YOUT_H) << 8) | readMPU6050(MPU6050_ACCEL_YOUT_L);\n  float az = (readMPU6050(MPU6050_ACCEL_ZOUT_H) << 8) | readMPU6050(MPU6050_ACCEL_ZOUT_L);\n  float degRoll  = atan2(ay, az) * RAD_TO_DEG;\n  float degPitch = atan(-ax / sqrt(ay * ay + az * az)) * RAD_TO_DEG;\n  gKfx.setAngle(degRoll);\n  gKfy.setAngle(degPitch);\n  gCalibrateX = degRoll;\n  gCalibrateY = degPitch;\n  gPrevMicros = micros();\n\n  //kill motors when first switched on\n  setEngineSpeed(0, 0);\n}\n\nvoid loop() {\n\n  // \u91cd\u529b\u52a0\u901f\u5ea6\u304b\u3089\u89d2\u5ea6\u3092\u6c42\u3081\u308b\u3002\n  float ax = (readMPU6050(MPU6050_ACCEL_XOUT_H) << 8) | readMPU6050(MPU6050_ACCEL_XOUT_L);\n  float ay = (readMPU6050(MPU6050_ACCEL_YOUT_H) << 8) | readMPU6050(MPU6050_ACCEL_YOUT_L);\n  float az = (readMPU6050(MPU6050_ACCEL_ZOUT_H) << 8) | readMPU6050(MPU6050_ACCEL_ZOUT_L);\n  float degRoll  = atan2(ay, az) * RAD_TO_DEG;\n  float degPitch = atan(-ax / sqrt(ay * ay + az * az)) * RAD_TO_DEG;\n\n  // \u30b8\u30e3\u30a4\u30ed\u3067\u89d2\u901f\u5ea6\u3092\u6c42\u3081\u308b\u3002\n  float gx = (readMPU6050(MPU6050_GYRO_XOUT_H) << 8) | readMPU6050(MPU6050_GYRO_XOUT_L);\n  float gy = (readMPU6050(MPU6050_GYRO_YOUT_H) << 8) | readMPU6050(MPU6050_GYRO_YOUT_L);\n  float gz = (readMPU6050(MPU6050_GYRO_ZOUT_H) << 8) | readMPU6050(MPU6050_GYRO_ZOUT_L);\n  float dpsX = gx / 131.0; // LSB sensitivity: 131 LSB/dps @ \u00b1250dps\n  float dpsY = gy / 131.0;\n  float dpsZ = gz / 131.0;\n\n  // \u30ab\u30eb\u30de\u30f3\u30d5\u30a3\u30eb\u30bf\u3067\u89d2\u5ea6(x,y)\u3092\u8a08\u7b97\u3059\u308b\u3002\n  long curMicros = micros();\n  float dt = (float)(curMicros - gPrevMicros) / 1000000; // \u03bcsec -> sec\n  gPrevMicros = curMicros;\n  float degX = gKfx.calcAngle(degRoll, dpsX, dt);\n  float degY = gKfy.calcAngle(degPitch, dpsY, dt);\n  degX -= gCalibrateX;\n  degY -= gCalibrateY;\n\n  // \u5012\u308c\u305f\u3089\u30e2\u30fc\u30bf\u30fc\u505c\u6b62\u3002\n  if (30 < abs(degX)) {\n    setEngineSpeed(0, 0);\n    Serial.print(\"**** stop \");\n    Serial.print(degX);\n    return;\n  }\n\n  // PID\u5236\u5fa1\u3067\u30e2\u30fc\u30bf\u30fc\u51fa\u529b\u3092\u8a08\u7b97\u3002\n  gPx = degX / 90;   // P\u6210\u5206\uff1a\u50be\u304d-90\uff5e90\u5ea6 \u2192 -1\uff5e1\n  gIx += gPx;        // I\u6210\u5206\uff1a\u50be\u304d\u306e\u7a4d\u7b97\u3002\n  gDx = dpsX / 250;  // D\u6210\u5206\uff1a\u89d2\u901f\u5ea6-250\uff5e250dps \u2192 -1\uff5e1\n\n  gPy = degY / 90;   // P\u6210\u5206\uff1a\u50be\u304d-90\uff5e90\u5ea6 \u2192 -1\uff5e1\n  gIy += gPy;        // I\u6210\u5206\uff1a\u50be\u304d\u306e\u7a4d\u7b97\u3002\n  gDy = dpsY / 250;  // D\u6210\u5206\uff1a\u89d2\u901f\u5ea6-250\uff5e250dps \u2192 -1\uff5e1\n\n  // \u524d\u5f8c\u65b9\u5411\u306e\u51fa\u529b\u3092\u6c7a\u5b9a\n  float level = (gPx * gyro_weightX + \n                gIx * integra_weightX +\n                gDx * accel_weightX) * 400;\n\n  // \u5de6\u53f3\u65b9\u5411\u306e\u51fa\u529b\u3092\u6c7a\u5b9a\n  float Steer = (gPy * gyro_weightY + \n                gIy * integra_weightY +\n                gDy * accel_weightY) * 150;\n\n  float Motor1percent = level - Steer;\n  float Motor2percent = level + Steer;\n\n  setEngineSpeed(Motor1percent, Motor2percent);\n\n\n  // \u30c7\u30d0\u30c3\u30b0\u7528\u3002\n  static int ps;\n  if (++ps % 1 == 0) {\n    Serial.print(\"dt:\"); Serial.print(dt);\n    Serial.print(\"\\tdegX:\"); Serial.print(degX);\n    Serial.print(\"\\tdpsX:\"); Serial.print(dpsX);\n    Serial.print(\"\\tdegY:\"); Serial.print(degY);\n    Serial.print(\"\\tdpsY:\"); Serial.print(dpsY);\n    Serial.print(\"\\tlevel:\"); Serial.print(level);\n    Serial.print(\"\\tSteer:\"); Serial.print(Steer);\n    Serial.print(\"\\tMotor1percent:\"); Serial.print(Motor1percent);\n    Serial.print(\"\\tMotor2percent:\"); Serial.print(Motor2percent);\n    Serial.println(\"\");\n  }\n  delay(1);\n}\n\nvoid setEngineSpeed( float Motor1percent, float Motor2percent ){\n\n  Motor1percent = max(-100, min(100, Motor1percent)); // \u2192 -100\uff5e100\n  Motor2percent = max(-100, min(100, Motor2percent)); // \u2192 -100\uff5e100\n\n  float cSpeedVal_Motor1 = 0;\n  float cSpeedVal_Motor2 = 0;\n\n  cSpeedVal_Motor1 = map (Motor1percent,\n                         -100,\n                         100,\n                         SABER_MOTOR1_FULL_REVERSE,\n                         SABER_MOTOR1_FULL_FORWARD);\n\n  cSpeedVal_Motor2 = map (Motor2percent,\n                         -100,\n                          100,\n                         SABER_MOTOR2_FULL_REVERSE,\n                         SABER_MOTOR2_FULL_FORWARD);\n\n  ST.motor(1, cSpeedVal_Motor1);\n  ST.motor(2, cSpeedVal_Motor2);\n}\n\n\n\nKalmanFilter.h\n// \u30ab\u30eb\u30de\u30f3\u30d5\u30a3\u30eb\u30bf\u3002\n// 2016/3/3\n\nclass KalmanFilter {\nprivate:\n    float angle;\n    float bias;\n    float P[2][2];\npublic:\n    KalmanFilter();\n    void setAngle(float newAngle);\n    float calcAngle(float newAngle, float newRate, float dt);\n};\n\n\n\nKalmanFilter.cpp\n// \u30ab\u30eb\u30de\u30f3\u30d5\u30a3\u30eb\u30bf\u3002\n// 2016/3/3\n//\n// \u8a08\u7b97\u5f0f\u306e\u53c2\u8003\u8cc7\u6599\u3002\n// http://blog.tkjelectronics.dk/2012/09/a-practical-approach-to-kalman-filter-and-how-to-implement-it/\n\n#include \"KalmanFilter.h\"\n\nKalmanFilter::KalmanFilter() {\n  angle = 0.0;\n  bias = 0.0;\n  P[0][0] = 0.0;\n  P[0][1] = 0.0;\n  P[1][0] = 0.0;\n  P[1][1] = 0.0;\n};\n\nvoid KalmanFilter::setAngle(float newAngle) {\n  angle = newAngle;\n};\n\nfloat KalmanFilter::calcAngle(float newAngle, float newRate, float dt) {\n\n  // variances\n  float Q_angle = 0.001;\n  float Q_bias = 0.003;\n  float R_measure = 0.03;\n\n  // step 1\n  float rate = newRate - bias;\n  angle += dt * rate;\n\n  // step 2\n  P[0][0] += dt * (dt * P[1][1] - P[0][1] - P[1][0] + Q_angle);\n  P[0][1] -= dt * P[1][1];\n  P[1][0] -= dt * P[1][1];\n  P[1][1] += Q_bias * dt;\n\n  // step 3\n  float y = newAngle - angle;\n\n  // step 4\n  float S = P[0][0] + R_measure;\n\n  // step 5\n  float K[2];\n  K[0] = P[0][0] / S;\n  K[1] = P[1][0] / S;\n\n  // step 6\n  angle += K[0] * y;\n  bias += K[1] * y;\n\n  // step 7\n  float P00_temp = P[0][0];\n  float P01_temp = P[0][1];\n  P[0][0] -= K[0] * P00_temp;\n  P[0][1] -= K[0] * P01_temp;\n  P[1][0] -= K[1] * P00_temp;\n  P[1][1] -= K[1] * P01_temp;\n\n  return angle;\n};\n\n\n\n\n\u89e3\u8aac\n\u5404\u30bb\u30af\u30b7\u30e7\u30f3\u3054\u3068\u306e\u89e3\u8aac\u3092\u3057\u3066\u3044\u304d\u307e\u3059\u3002\n\n\u5916\u90e8\u53c2\u7167\u30e2\u30b8\u30e5\u30fc\u30eb\n\u30b8\u30e3\u30a4\u30ed\u30bb\u30f3\u30b5\u30fc\u306e\u5236\u5fa1\u306e\u305f\u3081\u306b\u4e0b\u8a18\u306e\u30e2\u30b8\u30e5\u30fc\u30eb\u3092\u4f7f\u3044\u307e\u3059\u3002\n\u3053\u308c\u306f\u3001arduino \u306b\u6a19\u6e96\u3067\u5165\u3063\u3066\u3044\u306a\u3044\u306e\u3067\u3001\n\u4e0b\u8a18\u306e URL \u3092\u53c2\u8003\u306b \u5404\u74b0\u5883\u306b \u30e2\u30b8\u30e5\u30fc\u30eb\u3092\u8ffd\u52a0\u3057\u3066\u304f\u3060\u3055\u3044\nMPU-6050 Accelerometer + Gyro\n#include \"I2Cdev.h\"\n#include \"MPU6050.h\"\n\n\n\u5236\u5fa1\u7528\u5909\u6570\u306e\u5b9a\u7fa9\n\u30d5\u30eb\u30d1\u30ef\u30fc\u3092 500 \u3068\u3057\u307e\u3059\u3002\n\u3069\u3046\u3084\u3089 1023 \u307e\u3067\u3044\u3051\u308b\u3088\u3046\u3067\u3059\u3002\n/*  Attitude Control Parameters */\n#define FULL_SPEED 500//1023\n\n\u30b8\u30e3\u30a4\u30ed\u30bb\u30f3\u30b5\u30fc\u306e\u30a2\u30af\u30bb\u30b9\u7528\u5909\u6570\n/*  MPU-6050 Accelerometer + Gyro */\nMPU6050 accelgyro;\n\n\u30e2\u30fc\u30bf\u30fc\u5236\u5fa1\u306f\n\u4e0b\u8a18\u306e pin \u756a\u53f7\u3092\u901a\u3058\u3066\u5236\u5fa1\u3057\u307e\u3059\u3002\n/*  VNH2SP30 pin definitions */\nint inApin[2] = {7, 4};  // INA: Clockwise input\nint inBpin[2] = {8, 9}; // INB: Counter-clockwise input\nint pwmpin[2] = {5, 6}; // PWM input\nint cspin[2] = {2, 3}; // CS: Current sense ANALOG input\nint enpin[2] = {0, 1}; // EN: Status of switches output (Analog pin)\n\n\u30e2\u30fc\u30bf\u306e\u56de\u8ee2\u6570\u3092\u6c7a\u5b9a\u3059\u308b\u306e\u306b\n\u30b8\u30e3\u30a4\u30ed\u30bb\u30f3\u30b5\u30fc\u306e10\u56de\u306e\u691c\u51fa\u5024\u306e\u5e73\u5747\u3092\u7528\u3044\u308b\u3088\u3046\u306b\u3057\u307e\u3059\u3002\n/*  gyro multiple times to get an average baseline value. */\n#define average_times 10\nfloat angular_rate_Y_log[average_times];\nfloat angular_rate_Y_sum;\nfloat angular_rate_Z_log[average_times];\nfloat angular_rate_Z_sum;\n\n\u30ed\u30b0\u306f\u6bce\u56de\u51fa\u3057\u307e\u3059\u3002\nint log_times = 0;\n\n\n\u521d\u671f\u5316\u51e6\u7406\n\u5b9a\u578b\u5206\nvoid setup() {\n\n    Wire.begin();\n    Serial.begin(9600);\n\n\n\u30b8\u30e3\u30a4\u30ed\u30bb\u30f3\u30b5\u30fc\u306e\u521d\u671f\u5316\n    // initialize device\n    accelgyro.initialize();\n    Serial.println(accelgyro.testConnection() ? \"MPU6050 connection successful\" : \"MPU6050 connection failed\");\n\n\u30e2\u30fc\u30bf\u30fc\u5236\u5fa1\u306e\u521d\u671f\u5316\n    // Initialize digital pins as outputs\n    Serial.println(\"Initializing Mortor Driver digital pins...\");\n    for (int i=0; i<2; i++){\n      pinMode(inApin[i], OUTPUT);\n      pinMode(inBpin[i], OUTPUT);\n      pinMode(pwmpin[i], OUTPUT);\n    }\n    // Initialize braked\n    for (int i=0; i<2; i++){\n      digitalWrite(inApin[i], LOW);\n      digitalWrite(inBpin[i], LOW);\n    }\n}\n\n\n\u5236\u5fa1\u51e6\u7406\n\u30b8\u30e3\u30a4\u30ed\u30bb\u30f3\u30b5\u30fc\u306e\u5024\u3092\u89d2\u5ea6\uff08\u00b0\uff09\u5358\u4f4d\u306b\u5909\u63db\u3059\u308b\nvoid loop() {\n\n  int16_t ax, ay, az;\n  int16_t gx, gy, gz;\n  accelgyro.getMotion6(&ax, &ay, &az, &gx, &gy, &gz);\n  float acc_x = ax / 16384.0;\n  float acc_y = ay / 16384.0; \n  float acc_z = az / 16384.0; \n  float rate_X = atan2(acc_x, acc_z) * 360 / 2.0 / PI; \n  float rate_Y = atan2(acc_y, acc_z) * 360 / 2.0 / PI;\n  float rate_Z = atan2(acc_x, acc_y) * 180 / 2.0 / PI;\n\n  Serial.print(rate_X);\n  Serial.print(\"\\t\"); \n  Serial.print(rate_Y);\n  Serial.print(\"\\t\"); \n  Serial.print(rate_Z);\n  Serial.print(\"\\t\"); \n\n\u521d\u56de(average_times=10\u56de)\u306f\u5024\u3092\u4fdd\u6301\u3059\u308b\u3060\u3051\n\u30b8\u30e3\u30a4\u30ed\u30bb\u30f3\u30b5\u30fc\u306e10\u56de\u306e\u691c\u51fa\u5024\u306e\u5e73\u5747\u3092\u8a08\u7b97\u3059\u308b\n  if(log_times < average_times){\n    angular_rate_Y_sum += rate_Y; \n    angular_rate_Y_log[log_times] = rate_Y;\n    angular_rate_Z_sum += rate_Z; \n    angular_rate_Z_log[log_times] = rate_Z;\n    log_times ++;\n  }else{\n    //\u50be\u304d\u306e\u5e73\u5747\u5024X\u3092\u8a08\u7b97\u3059\u308b\u3002\n    angular_rate_Y_sum -= angular_rate_Y_log[0];\n    angular_rate_Y_sum += rate_Y;\n    for (int i=1; i<average_times; i++) \n      angular_rate_Y_log[i-1] = angular_rate_Y_log[i];\n    angular_rate_Y_log[average_times-1]= rate_Y;\n    float angular_rate_Y_average = angular_rate_Y_sum / average_times;\n\n    //\u50be\u304d\u306e\u5e73\u5747\u5024Z\u3092\u8a08\u7b97\u3059\u308b\u3002\n    angular_rate_Z_sum -= angular_rate_Z_log[0];\n    angular_rate_Z_sum += rate_Z;\n    for (int i=1; i<average_times; i++) \n      angular_rate_Z_log[i-1] = angular_rate_Z_log[i];\n    angular_rate_Z_log[average_times-1]= rate_Z;\n    float angular_rate_Z_average = angular_rate_Z_sum / average_times;\n\n\u30e2\u30fc\u30bf\u30fc\u306e\u56de\u8ee2\u6570\u3092\u6c7a\u5b9a\u3059\u308b\u3002\nY\u306e\u89d2\u5ea6(10\u56de\u5206\u306e\u5e73\u5747\u5024)\u304c 60\u00b0 \u4ee5\u4e0a 0 \u4ee5\u4e0b\u306a\u3089 \u524d\u9032\uff08go_state = 2\uff09\n    //\u30e2\u30fc\u30bf\u30fc\u306e\u56de\u8ee2\u6570\u3092\u6c7a\u5b9a\u3059\u308b\u3002\n    float pmw1 = 0; //0 to 1023\n    float pmw2 = 0; //0 to 1023\n    int go_state = 0;\n    float delta = 0;\n\n      if (angular_rate_Y_average <= 60 && angular_rate_Y_average >= 0 ){\n        angular_rate_Y_average = abs(angular_rate_Y_average);\n        float a2 = angular_rate_Y_average / 60;\n        pmw1 =  FULL_SPEED * a2;\n        pmw2 = pmw1;\n        go_state = 2;\n\nY\u306e\u89d2\u5ea6(10\u56de\u5206\u306e\u5e73\u5747\u5024)\u304c 0 \u4ee5\u4e0a -60\u00b0 \u4ee5\u4e0b\u306a\u3089 \u5f8c\u9032\uff08go_state = 1\uff09\n      }\n      if (angular_rate_Y_average >= -60 && angular_rate_Y_average <= 0 ){\n        angular_rate_Y_average = abs(angular_rate_Y_average);\n        float a1 = angular_rate_Y_average / 60;\n        pmw1 =  FULL_SPEED * a1;\n        pmw2 = pmw1;\n       go_state = 1;\n      }\n\n\u30ed\u30b0\u3068 \u5b9f\u969b\u306b\u30e2\u30fc\u30bf\u30fc\u306b\u547d\u4ee4\u3092\u51fa\u3059\u95a2\u6570 motorGo \u3092\u547c\u3076\n      Serial.print(go_state);\n      Serial.print(\"\\t\"); \n      Serial.print(pmw1);\n      Serial.print(\"\\t\"); \n      Serial.print(pmw2);\n      Serial.print(\"\\t\"); \n\n      Serial.print(delta);\n      Serial.print(\"\\t\"); \n\n      if ( go_state == 0 ){\n        motorOff(0);\n        motorOff(1);\n      }else{\n        motorGo(0, go_state, pmw1); \n        motorGo(1, go_state, pmw2);\n      }\n    }\n    Serial.println(\"\");\n }\n\n\n\u52d5\u4f5c\u51e6\u7406\n\u5b9f\u969b\u306b\u30e2\u30fc\u30bf\u30fc\u306b\u547d\u4ee4\u3092\u51fa\u3059\u95a2\u6570\nvoid motorOff(int motor){\n  for (int i=0; i<2; i++){\n    digitalWrite(inApin[i], LOW);\n    digitalWrite(inBpin[i], LOW);\n  }\n  analogWrite(pwmpin[motor], 0);\n}\n\nvoid motorGo(uint8_t motor, uint8_t direct, uint8_t pwm)\n{\n  if (motor <= 1){\n    if (direct <=4){\n      // Set inA[motor]\n      if (direct <=1)\n        digitalWrite(inApin[motor], HIGH);\n      else\n        digitalWrite(inApin[motor], LOW);\n      // Set inB[motor]\n      if ((direct==0)||(direct==2))\n        digitalWrite(inBpin[motor], HIGH);\n      else\n        digitalWrite(inBpin[motor], LOW);\n\n      analogWrite(pwmpin[motor], pwm);\n    }\n  }\n\n\n\u6539\u826f\u306e\u4f59\u5730\n\u30bd\u30fc\u30b9\u306f\u3053\u3053\u306b\n'https://github.com/sasaco/segway.git'\n\u307e\u3060\u3001\u524d\u9032\u30fb\u5f8c\u9032\u3057\u304b\u3084\u3063\u3066\u3044\u307e\u305b\u3093\n\u305d\u306e\u3046\u3061 z\u8ef8\u306e\u50be\u304d\u3092\u4f7f\u3063\u3066 \u5de6\u53f3\u306e\u30e2\u30fc\u30bf\u30fc\u306e\u56de\u8ee2\u6570\u3092\u5909\u3048\u3066\n\u66f2\u304c\u308c\u308b\u3088\u3046\u306b\u3057\u305f\u3044\u3068\u601d\u3044\u307e\u3059\u3002\n\n\u6b21\u56de\u306f\u30dc\u30c7\u30a3\u30fc\u7d44\u7acb\u7de8\u306b\u3064\u3044\u3066\u304a\u5c4a\u3051\u3057\u307e\u3059\u3002\n#\u30b7\u30ea\u30fc\u30ba\u76ee\u6b21\n\n- [\u30bb\u30b0\u30a6\u30a7\u30a4\u3092\u81ea\u4f5c\u3057\u3066\u307f\u305f \uff5e\u6750\u6599\u7de8\uff5e](http://qiita.com/sasaco/items/54a1faec2ddaa935dec1)\n- [\u30bb\u30b0\u30a6\u30a7\u30a4\u3092\u81ea\u4f5c\u3057\u3066\u307f\u305f \uff5e\u96fb\u5b50\u56de\u8def\u7d44\u7acb\u7de8\uff5e](http://qiita.com/sasaco/items/b72819993790443877ec)\n- \u30bb\u30b0\u30a6\u30a7\u30a4\u3092\u81ea\u4f5c\u3057\u3066\u307f\u305f \uff5e\u30d7\u30ed\u30b0\u30e9\u30e0\u7de8\uff5e\n- [\u30bb\u30b0\u30a6\u30a7\u30a4\u3092\u81ea\u4f5c\u3057\u3066\u307f\u305f \uff5e\u30dc\u30c7\u30a3\u30fc\u7d44\u7acb\u7de8\uff5e](http://qiita.com/sasaco/items/7f361b4fa2d1db572a6f)\n\n---\n\n\u3053\u306e\u5206\u91ce\u3067\u306f\u9580\u5916\u6f22\u306e\u79c1\u304c\u3001\u300c\u96fb\u5b50\u5236\u5fa1\u300d\u3092\u307e\u3063\u305f\u304f\u52c9\u5f37\u305b\u305a\u306b\n\u30bb\u30b0\u30a6\u30a7\u30a4\u3092\u4f5c\u3063\u3066\u307f\u3088\u3046\u3068\u601d\u3044\u307e\u3059\u3002\n\u53c2\u8003\u306b\u3057\u305f\u672c\u306f\u3053\u3061\u3089\n[Arduino Robotics (Technology in Action)](https://www.amazon.co.jp/gp/product/1430231831/ref=oh_aui_detailpage_o00_s00?ie=UTF8&psc=1)\n[\u30b5\u30f3\u30d7\u30eb\u30bd\u30fc\u30b9/Segbot](https://github.com/johndavid400/Segbot)\n\n#\u5168\u30bd\u30fc\u30b9\u30b3\u30fc\u30c9\narduino \u306f c\u8a00\u8a9e\u3067\u66f8\u304d\u307e\u3059\n\n```c:balancer.ino\n// \u5012\u7acb\u632f\u5b50\u3001\u52a0\u901f\u5ea6/\u30b8\u30e3\u30a4\u30ed\u30bb\u30f3\u30b5\u30fc(MPU-6050)\u7248\n// 2016/3/4\n\n#include <Wire.h>\n#include \"KalmanFilter.h\"\n#include <SoftwareSerial.h>\n#include <SabertoothSimplified.h>\n\n// \u30e2\u30fc\u30bf\u30fc\u30c9\u30e9\u30a4\u30d0\u306e\u5236\u5fa1\u5b9a\u6570\u3002\nSoftwareSerial SWSerial(NOT_A_PIN, 13); // RX on no pin (unused), TX on pin 11 (to S1).\nSabertoothSimplified ST(SWSerial); // Use SWSerial as the serial port.\n\n#define SABER_MOTOR1_FULL_FORWARD  -127\n#define SABER_MOTOR1_FULL_REVERSE  127\n#define SABER_MOTOR1_FULL_STOP  0\n\n#define SABER_MOTOR2_FULL_FORWARD  -127\n#define SABER_MOTOR2_FULL_REVERSE  127\n#define SABER_MOTOR2_FULL_STOP  0\n\n// \u52a0\u901f\u5ea6/\u30b8\u30e3\u30a4\u30ed\u30bb\u30f3\u30b5\u30fc\u306e\u5236\u5fa1\u5b9a\u6570\u3002\n#define MPU6050_ADDR         0x68 // MPU-6050 device address\n#define MPU6050_SMPLRT_DIV   0x19 // MPU-6050 register address\n#define MPU6050_CONFIG       0x1a\n#define MPU6050_GYRO_CONFIG  0x1b\n#define MPU6050_ACCEL_CONFIG 0x1c\n#define MPU6050_ACCEL_XOUT_H 0x3b\n#define MPU6050_ACCEL_XOUT_L 0x3c\n#define MPU6050_ACCEL_YOUT_H 0x3d\n#define MPU6050_ACCEL_YOUT_L 0x3e\n#define MPU6050_ACCEL_ZOUT_H 0x3f\n#define MPU6050_ACCEL_ZOUT_L 0x40\n#define MPU6050_GYRO_XOUT_H  0x43\n#define MPU6050_GYRO_XOUT_L  0x44\n#define MPU6050_GYRO_YOUT_H  0x45\n#define MPU6050_GYRO_YOUT_L  0x46\n#define MPU6050_GYRO_ZOUT_H  0x47\n#define MPU6050_GYRO_ZOUT_L  0x48\n#define MPU6050_PWR_MGMT_1   0x6b\n#define MPU6050_WHO_AM_I     0x75\n\n// \u52a0\u901f\u5ea6/\u30b8\u30e3\u30a4\u30ed\u30bb\u30f3\u30b5\u30fc\u306e\u5236\u5fa1\u5909\u6570\u3002\nKalmanFilter gKfx, gKfy; // \u30ab\u30eb\u30de\u30f3\u30d5\u30a3\u30eb\u30bf\u3002\nfloat gCalibrateX; // \u521d\u671f\u5316\u6642\u306e\u89d2\u5ea6\u3002\uff08\uff1d\u9759\u6b62\u89d2\u3068\u307f\u306a\u3059\uff09\nfloat gCalibrateY; // \u521d\u671f\u5316\u6642\u306e\u89d2\u5ea6\u3002\uff08\uff1d\u9759\u6b62\u89d2\u3068\u307f\u306a\u3059\uff09\nlong gPrevMicros;  // loop()\u9593\u9694\u306e\u8a08\u6e2c\u7528\u3002\n\n// \u5012\u7acb\u632f\u5b50\u306e\u5236\u5fa1\u5909\u6570\u3002\nfloat gPx, gIx, gDx; // \u73fe\u5728\u51fa\u529b\u5024\u3068PID\u6210\u5206\u3002\n// \u3053\u306e\u6570\u5b57\u306f\u8a66\u884c\u932f\u8aa4\u3067\u8abf\u6574\u3002\nfloat gyro_weightX = 0.98;\nfloat integra_weightX = 0;\nfloat accel_weightX = 0.02;\n\nfloat gPy, gIy, gDy; // \u73fe\u5728\u51fa\u529b\u5024\u3068PID\u6210\u5206\u3002\n// \u3053\u306e\u6570\u5b57\u306f\u8a66\u884c\u932f\u8aa4\u3067\u8abf\u6574\u3002\nfloat gyro_weightY = 0.98;\nfloat integra_weightY = 0;\nfloat accel_weightY = 0.02;\n\n// \u52a0\u901f\u5ea6/\u30b8\u30e3\u30a4\u30ed\u30bb\u30f3\u30b5\u30fc\u3078\u306e\u30b3\u30de\u30f3\u30c9\u9001\u4fe1\u3002\nvoid writeMPU6050(byte reg, byte data) {\n  Wire.beginTransmission(MPU6050_ADDR);\n  Wire.write(reg);\n  Wire.write(data);\n  Wire.endTransmission();\n}\n\n// \u52a0\u901f\u5ea6/\u30b8\u30e3\u30a4\u30ed\u30bb\u30f3\u30b5\u30fc\u304b\u3089\u306e\u30c7\u30fc\u30bf\u8aad\u307f\u8fbc\u307f\u3002\nbyte readMPU6050(byte reg) {\n  Wire.beginTransmission(MPU6050_ADDR);\n  Wire.write(reg);\n  Wire.endTransmission(false);\n  Wire.requestFrom(MPU6050_ADDR, 1/*length*/, false);\n  byte data =  Wire.read();\n  Wire.endTransmission(true);\n  return data;\n}\n\nvoid setup() {\n  Serial.begin(115200);\n\n  // \u30e2\u30fc\u30bf\u30fc\u30c9\u30e9\u30a4\u30d0\u306e\u521d\u671f\u5316\u3002\n  SWSerial.begin(9600);\n   \n  // \u52a0\u901f\u5ea6/\u30b8\u30e3\u30a4\u30ed\u30bb\u30f3\u30b5\u30fc\u306e\u521d\u671f\u5316\u3002\n  Wire.begin();\n  if (readMPU6050(MPU6050_WHO_AM_I) != 0x68) {\n    Serial.println(\"\\nWHO_AM_I error.\");\n    while (true) ;\n  }\n  writeMPU6050(MPU6050_SMPLRT_DIV, 0x07);   // sample rate: 8kHz/(7+1) = 1kHz\n  writeMPU6050(MPU6050_CONFIG, 0x00);       // disable DLPF, gyro output rate = 8kHz\n  writeMPU6050(MPU6050_GYRO_CONFIG, 0x00);  // gyro range: \u00b1250dps\n  writeMPU6050(MPU6050_ACCEL_CONFIG, 0x00); // accel range: \u00b12g\n  writeMPU6050(MPU6050_PWR_MGMT_1, 0x01);   // disable sleep mode, PLL with X gyro\n  delay(2000);\n\n  // \u91cd\u529b\u52a0\u901f\u5ea6\u304b\u3089\u6c42\u3081\u305f\u89d2\u5ea6\u3092\u30ab\u30eb\u30de\u30f3\u30d5\u30a3\u30eb\u30bf\u306e\u521d\u671f\u5024\u3068\u3059\u308b\u3002\n  float ax = (readMPU6050(MPU6050_ACCEL_XOUT_H) << 8) | readMPU6050(MPU6050_ACCEL_XOUT_L);\n  float ay = (readMPU6050(MPU6050_ACCEL_YOUT_H) << 8) | readMPU6050(MPU6050_ACCEL_YOUT_L);\n  float az = (readMPU6050(MPU6050_ACCEL_ZOUT_H) << 8) | readMPU6050(MPU6050_ACCEL_ZOUT_L);\n  float degRoll  = atan2(ay, az) * RAD_TO_DEG;\n  float degPitch = atan(-ax / sqrt(ay * ay + az * az)) * RAD_TO_DEG;\n  gKfx.setAngle(degRoll);\n  gKfy.setAngle(degPitch);\n  gCalibrateX = degRoll;\n  gCalibrateY = degPitch;\n  gPrevMicros = micros();\n  \n  //kill motors when first switched on\n  setEngineSpeed(0, 0);\n}\n\nvoid loop() {\n\n  // \u91cd\u529b\u52a0\u901f\u5ea6\u304b\u3089\u89d2\u5ea6\u3092\u6c42\u3081\u308b\u3002\n  float ax = (readMPU6050(MPU6050_ACCEL_XOUT_H) << 8) | readMPU6050(MPU6050_ACCEL_XOUT_L);\n  float ay = (readMPU6050(MPU6050_ACCEL_YOUT_H) << 8) | readMPU6050(MPU6050_ACCEL_YOUT_L);\n  float az = (readMPU6050(MPU6050_ACCEL_ZOUT_H) << 8) | readMPU6050(MPU6050_ACCEL_ZOUT_L);\n  float degRoll  = atan2(ay, az) * RAD_TO_DEG;\n  float degPitch = atan(-ax / sqrt(ay * ay + az * az)) * RAD_TO_DEG;\n\n  // \u30b8\u30e3\u30a4\u30ed\u3067\u89d2\u901f\u5ea6\u3092\u6c42\u3081\u308b\u3002\n  float gx = (readMPU6050(MPU6050_GYRO_XOUT_H) << 8) | readMPU6050(MPU6050_GYRO_XOUT_L);\n  float gy = (readMPU6050(MPU6050_GYRO_YOUT_H) << 8) | readMPU6050(MPU6050_GYRO_YOUT_L);\n  float gz = (readMPU6050(MPU6050_GYRO_ZOUT_H) << 8) | readMPU6050(MPU6050_GYRO_ZOUT_L);\n  float dpsX = gx / 131.0; // LSB sensitivity: 131 LSB/dps @ \u00b1250dps\n  float dpsY = gy / 131.0;\n  float dpsZ = gz / 131.0;\n\n  // \u30ab\u30eb\u30de\u30f3\u30d5\u30a3\u30eb\u30bf\u3067\u89d2\u5ea6(x,y)\u3092\u8a08\u7b97\u3059\u308b\u3002\n  long curMicros = micros();\n  float dt = (float)(curMicros - gPrevMicros) / 1000000; // \u03bcsec -> sec\n  gPrevMicros = curMicros;\n  float degX = gKfx.calcAngle(degRoll, dpsX, dt);\n  float degY = gKfy.calcAngle(degPitch, dpsY, dt);\n  degX -= gCalibrateX;\n  degY -= gCalibrateY;\n\n  // \u5012\u308c\u305f\u3089\u30e2\u30fc\u30bf\u30fc\u505c\u6b62\u3002\n  if (30 < abs(degX)) {\n    setEngineSpeed(0, 0);\n    Serial.print(\"**** stop \");\n    Serial.print(degX);\n    return;\n  }\n\n  // PID\u5236\u5fa1\u3067\u30e2\u30fc\u30bf\u30fc\u51fa\u529b\u3092\u8a08\u7b97\u3002\n  gPx = degX / 90;   // P\u6210\u5206\uff1a\u50be\u304d-90\uff5e90\u5ea6 \u2192 -1\uff5e1\n  gIx += gPx;        // I\u6210\u5206\uff1a\u50be\u304d\u306e\u7a4d\u7b97\u3002\n  gDx = dpsX / 250;  // D\u6210\u5206\uff1a\u89d2\u901f\u5ea6-250\uff5e250dps \u2192 -1\uff5e1\n  \n  gPy = degY / 90;   // P\u6210\u5206\uff1a\u50be\u304d-90\uff5e90\u5ea6 \u2192 -1\uff5e1\n  gIy += gPy;        // I\u6210\u5206\uff1a\u50be\u304d\u306e\u7a4d\u7b97\u3002\n  gDy = dpsY / 250;  // D\u6210\u5206\uff1a\u89d2\u901f\u5ea6-250\uff5e250dps \u2192 -1\uff5e1\n  \n  // \u524d\u5f8c\u65b9\u5411\u306e\u51fa\u529b\u3092\u6c7a\u5b9a\n  float level = (gPx * gyro_weightX + \n                gIx * integra_weightX +\n                gDx * accel_weightX) * 400;\n                \n  // \u5de6\u53f3\u65b9\u5411\u306e\u51fa\u529b\u3092\u6c7a\u5b9a\n  float Steer = (gPy * gyro_weightY + \n                gIy * integra_weightY +\n                gDy * accel_weightY) * 150;\n \n  float Motor1percent = level - Steer;\n  float Motor2percent = level + Steer;\n  \n  setEngineSpeed(Motor1percent, Motor2percent);\n\n\n  // \u30c7\u30d0\u30c3\u30b0\u7528\u3002\n  static int ps;\n  if (++ps % 1 == 0) {\n    Serial.print(\"dt:\"); Serial.print(dt);\n    Serial.print(\"\\tdegX:\"); Serial.print(degX);\n    Serial.print(\"\\tdpsX:\"); Serial.print(dpsX);\n    Serial.print(\"\\tdegY:\"); Serial.print(degY);\n    Serial.print(\"\\tdpsY:\"); Serial.print(dpsY);\n    Serial.print(\"\\tlevel:\"); Serial.print(level);\n    Serial.print(\"\\tSteer:\"); Serial.print(Steer);\n    Serial.print(\"\\tMotor1percent:\"); Serial.print(Motor1percent);\n    Serial.print(\"\\tMotor2percent:\"); Serial.print(Motor2percent);\n    Serial.println(\"\");\n  }\n  delay(1);\n}\n\nvoid setEngineSpeed( float Motor1percent, float Motor2percent ){\n  \n  Motor1percent = max(-100, min(100, Motor1percent)); // \u2192 -100\uff5e100\n  Motor2percent = max(-100, min(100, Motor2percent)); // \u2192 -100\uff5e100\n\n  float cSpeedVal_Motor1 = 0;\n  float cSpeedVal_Motor2 = 0;\n\n  cSpeedVal_Motor1 = map (Motor1percent,\n                         -100,\n                         100,\n                         SABER_MOTOR1_FULL_REVERSE,\n                         SABER_MOTOR1_FULL_FORWARD);\n                         \n  cSpeedVal_Motor2 = map (Motor2percent,\n                         -100,\n                          100,\n                         SABER_MOTOR2_FULL_REVERSE,\n                         SABER_MOTOR2_FULL_FORWARD);\n                         \n  ST.motor(1, cSpeedVal_Motor1);\n  ST.motor(2, cSpeedVal_Motor2);\n}\n```\n\n```c:KalmanFilter.h\n// \u30ab\u30eb\u30de\u30f3\u30d5\u30a3\u30eb\u30bf\u3002\n// 2016/3/3\n\nclass KalmanFilter {\nprivate:\n    float angle;\n    float bias;\n    float P[2][2];\npublic:\n    KalmanFilter();\n    void setAngle(float newAngle);\n    float calcAngle(float newAngle, float newRate, float dt);\n};\n```\n\n```c:KalmanFilter.cpp\n// \u30ab\u30eb\u30de\u30f3\u30d5\u30a3\u30eb\u30bf\u3002\n// 2016/3/3\n//\n// \u8a08\u7b97\u5f0f\u306e\u53c2\u8003\u8cc7\u6599\u3002\n// http://blog.tkjelectronics.dk/2012/09/a-practical-approach-to-kalman-filter-and-how-to-implement-it/\n\n#include \"KalmanFilter.h\"\n\nKalmanFilter::KalmanFilter() {\n  angle = 0.0;\n  bias = 0.0;\n  P[0][0] = 0.0;\n  P[0][1] = 0.0;\n  P[1][0] = 0.0;\n  P[1][1] = 0.0;\n};\n\nvoid KalmanFilter::setAngle(float newAngle) {\n  angle = newAngle;\n};\n\nfloat KalmanFilter::calcAngle(float newAngle, float newRate, float dt) {\n\n  // variances\n  float Q_angle = 0.001;\n  float Q_bias = 0.003;\n  float R_measure = 0.03;\n\n  // step 1\n  float rate = newRate - bias;\n  angle += dt * rate;\n\n  // step 2\n  P[0][0] += dt * (dt * P[1][1] - P[0][1] - P[1][0] + Q_angle);\n  P[0][1] -= dt * P[1][1];\n  P[1][0] -= dt * P[1][1];\n  P[1][1] += Q_bias * dt;\n\n  // step 3\n  float y = newAngle - angle;\n\n  // step 4\n  float S = P[0][0] + R_measure;\n\n  // step 5\n  float K[2];\n  K[0] = P[0][0] / S;\n  K[1] = P[1][0] / S;\n\n  // step 6\n  angle += K[0] * y;\n  bias += K[1] * y;\n\n  // step 7\n  float P00_temp = P[0][0];\n  float P01_temp = P[0][1];\n  P[0][0] -= K[0] * P00_temp;\n  P[0][1] -= K[0] * P01_temp;\n  P[1][0] -= K[1] * P00_temp;\n  P[1][1] -= K[1] * P01_temp;\n\n  return angle;\n};\n```\n\n---\n\n#\u89e3\u8aac\n\u5404\u30bb\u30af\u30b7\u30e7\u30f3\u3054\u3068\u306e\u89e3\u8aac\u3092\u3057\u3066\u3044\u304d\u307e\u3059\u3002\n\n##\u5916\u90e8\u53c2\u7167\u30e2\u30b8\u30e5\u30fc\u30eb\n\n\u30b8\u30e3\u30a4\u30ed\u30bb\u30f3\u30b5\u30fc\u306e\u5236\u5fa1\u306e\u305f\u3081\u306b\u4e0b\u8a18\u306e\u30e2\u30b8\u30e5\u30fc\u30eb\u3092\u4f7f\u3044\u307e\u3059\u3002\n\u3053\u308c\u306f\u3001arduino \u306b\u6a19\u6e96\u3067\u5165\u3063\u3066\u3044\u306a\u3044\u306e\u3067\u3001\n\u4e0b\u8a18\u306e URL \u3092\u53c2\u8003\u306b \u5404\u74b0\u5883\u306b \u30e2\u30b8\u30e5\u30fc\u30eb\u3092\u8ffd\u52a0\u3057\u3066\u304f\u3060\u3055\u3044\n\n[MPU-6050 Accelerometer + Gyro](http://playground.arduino.cc/Main/MPU-6050)\n\n```c:\n#include \"I2Cdev.h\"\n#include \"MPU6050.h\"\n```\n\n\n\n##\u5236\u5fa1\u7528\u5909\u6570\u306e\u5b9a\u7fa9\n\n\u30d5\u30eb\u30d1\u30ef\u30fc\u3092 500 \u3068\u3057\u307e\u3059\u3002\n\u3069\u3046\u3084\u3089 1023 \u307e\u3067\u3044\u3051\u308b\u3088\u3046\u3067\u3059\u3002\n\n```c:\n/*  Attitude Control Parameters */\n#define FULL_SPEED 500//1023\n```\n\n\n\u30b8\u30e3\u30a4\u30ed\u30bb\u30f3\u30b5\u30fc\u306e\u30a2\u30af\u30bb\u30b9\u7528\u5909\u6570\n\n```c:\n/*  MPU-6050 Accelerometer + Gyro */\nMPU6050 accelgyro;\n```\n\n\n\u30e2\u30fc\u30bf\u30fc\u5236\u5fa1\u306f\n\u4e0b\u8a18\u306e pin \u756a\u53f7\u3092\u901a\u3058\u3066\u5236\u5fa1\u3057\u307e\u3059\u3002\n\n```c:\n/*  VNH2SP30 pin definitions */\nint inApin[2] = {7, 4};  // INA: Clockwise input\nint inBpin[2] = {8, 9}; // INB: Counter-clockwise input\nint pwmpin[2] = {5, 6}; // PWM input\nint cspin[2] = {2, 3}; // CS: Current sense ANALOG input\nint enpin[2] = {0, 1}; // EN: Status of switches output (Analog pin)\n```\n\n\n\u30e2\u30fc\u30bf\u306e\u56de\u8ee2\u6570\u3092\u6c7a\u5b9a\u3059\u308b\u306e\u306b\n\u30b8\u30e3\u30a4\u30ed\u30bb\u30f3\u30b5\u30fc\u306e10\u56de\u306e\u691c\u51fa\u5024\u306e\u5e73\u5747\u3092\u7528\u3044\u308b\u3088\u3046\u306b\u3057\u307e\u3059\u3002\n\n```c:\n/*  gyro multiple times to get an average baseline value. */\n#define average_times 10\nfloat angular_rate_Y_log[average_times];\nfloat angular_rate_Y_sum;\nfloat angular_rate_Z_log[average_times];\nfloat angular_rate_Z_sum;\n```\n\n\n\u30ed\u30b0\u306f\u6bce\u56de\u51fa\u3057\u307e\u3059\u3002\n\n```c:\nint log_times = 0;\n```\n\n\n\n##\u521d\u671f\u5316\u51e6\u7406\n\n\n\u5b9a\u578b\u5206\n\n```c:\nvoid setup() {\n\n    Wire.begin();\n    Serial.begin(9600);\n\n```\n\n\n\u30b8\u30e3\u30a4\u30ed\u30bb\u30f3\u30b5\u30fc\u306e\u521d\u671f\u5316\n\n```c:\n    // initialize device\n    accelgyro.initialize();\n    Serial.println(accelgyro.testConnection() ? \"MPU6050 connection successful\" : \"MPU6050 connection failed\");\n```\n\n\n\u30e2\u30fc\u30bf\u30fc\u5236\u5fa1\u306e\u521d\u671f\u5316\n\n```c:\n    // Initialize digital pins as outputs\n    Serial.println(\"Initializing Mortor Driver digital pins...\");\n    for (int i=0; i<2; i++){\n      pinMode(inApin[i], OUTPUT);\n      pinMode(inBpin[i], OUTPUT);\n      pinMode(pwmpin[i], OUTPUT);\n    }\n    // Initialize braked\n    for (int i=0; i<2; i++){\n      digitalWrite(inApin[i], LOW);\n      digitalWrite(inBpin[i], LOW);\n    }\n}\n```\n\n\n\n##\u5236\u5fa1\u51e6\u7406\n\n\n\u30b8\u30e3\u30a4\u30ed\u30bb\u30f3\u30b5\u30fc\u306e\u5024\u3092\u89d2\u5ea6\uff08\u00b0\uff09\u5358\u4f4d\u306b\u5909\u63db\u3059\u308b\n\n```c:\nvoid loop() {\n  \n  int16_t ax, ay, az;\n  int16_t gx, gy, gz;\n  accelgyro.getMotion6(&ax, &ay, &az, &gx, &gy, &gz);\n  float acc_x = ax / 16384.0;\n  float acc_y = ay / 16384.0; \n  float acc_z = az / 16384.0; \n  float rate_X = atan2(acc_x, acc_z) * 360 / 2.0 / PI; \n  float rate_Y = atan2(acc_y, acc_z) * 360 / 2.0 / PI;\n  float rate_Z = atan2(acc_x, acc_y) * 180 / 2.0 / PI;\n  \n  Serial.print(rate_X);\n  Serial.print(\"\\t\"); \n  Serial.print(rate_Y);\n  Serial.print(\"\\t\"); \n  Serial.print(rate_Z);\n  Serial.print(\"\\t\"); \n```\n\n\n\u521d\u56de(average_times=10\u56de)\u306f\u5024\u3092\u4fdd\u6301\u3059\u308b\u3060\u3051\n\u30b8\u30e3\u30a4\u30ed\u30bb\u30f3\u30b5\u30fc\u306e10\u56de\u306e\u691c\u51fa\u5024\u306e\u5e73\u5747\u3092\u8a08\u7b97\u3059\u308b\n\n```c:\n  if(log_times < average_times){\n    angular_rate_Y_sum += rate_Y; \n    angular_rate_Y_log[log_times] = rate_Y;\n    angular_rate_Z_sum += rate_Z; \n    angular_rate_Z_log[log_times] = rate_Z;\n    log_times ++;\n  }else{\n    //\u50be\u304d\u306e\u5e73\u5747\u5024X\u3092\u8a08\u7b97\u3059\u308b\u3002\n    angular_rate_Y_sum -= angular_rate_Y_log[0];\n    angular_rate_Y_sum += rate_Y;\n    for (int i=1; i<average_times; i++) \n      angular_rate_Y_log[i-1] = angular_rate_Y_log[i];\n    angular_rate_Y_log[average_times-1]= rate_Y;\n    float angular_rate_Y_average = angular_rate_Y_sum / average_times;\n\n    //\u50be\u304d\u306e\u5e73\u5747\u5024Z\u3092\u8a08\u7b97\u3059\u308b\u3002\n    angular_rate_Z_sum -= angular_rate_Z_log[0];\n    angular_rate_Z_sum += rate_Z;\n    for (int i=1; i<average_times; i++) \n      angular_rate_Z_log[i-1] = angular_rate_Z_log[i];\n    angular_rate_Z_log[average_times-1]= rate_Z;\n    float angular_rate_Z_average = angular_rate_Z_sum / average_times;\n```\n\n\n\u30e2\u30fc\u30bf\u30fc\u306e\u56de\u8ee2\u6570\u3092\u6c7a\u5b9a\u3059\u308b\u3002\nY\u306e\u89d2\u5ea6(10\u56de\u5206\u306e\u5e73\u5747\u5024)\u304c 60\u00b0 \u4ee5\u4e0a 0 \u4ee5\u4e0b\u306a\u3089 \u524d\u9032\uff08go_state = 2\uff09\n\n```c:\n    //\u30e2\u30fc\u30bf\u30fc\u306e\u56de\u8ee2\u6570\u3092\u6c7a\u5b9a\u3059\u308b\u3002\n    float pmw1 = 0; //0 to 1023\n    float pmw2 = 0; //0 to 1023\n    int go_state = 0;\n    float delta = 0;\n\n      if (angular_rate_Y_average <= 60 && angular_rate_Y_average >= 0 ){\n        angular_rate_Y_average = abs(angular_rate_Y_average);\n        float a2 = angular_rate_Y_average / 60;\n        pmw1 =  FULL_SPEED * a2;\n        pmw2 = pmw1;\n        go_state = 2;\n```\n\n\nY\u306e\u89d2\u5ea6(10\u56de\u5206\u306e\u5e73\u5747\u5024)\u304c 0 \u4ee5\u4e0a -60\u00b0 \u4ee5\u4e0b\u306a\u3089 \u5f8c\u9032\uff08go_state = 1\uff09\n\n```c:\n      }\n      if (angular_rate_Y_average >= -60 && angular_rate_Y_average <= 0 ){\n        angular_rate_Y_average = abs(angular_rate_Y_average);\n        float a1 = angular_rate_Y_average / 60;\n        pmw1 =  FULL_SPEED * a1;\n        pmw2 = pmw1;\n       go_state = 1;\n      }\n```\n\n\n\u30ed\u30b0\u3068 \u5b9f\u969b\u306b\u30e2\u30fc\u30bf\u30fc\u306b\u547d\u4ee4\u3092\u51fa\u3059\u95a2\u6570 motorGo \u3092\u547c\u3076\n\n```c:\n      Serial.print(go_state);\n      Serial.print(\"\\t\"); \n      Serial.print(pmw1);\n      Serial.print(\"\\t\"); \n      Serial.print(pmw2);\n      Serial.print(\"\\t\"); \n\n      Serial.print(delta);\n      Serial.print(\"\\t\"); \n\n      if ( go_state == 0 ){\n        motorOff(0);\n        motorOff(1);\n      }else{\n        motorGo(0, go_state, pmw1); \n        motorGo(1, go_state, pmw2);\n      }\n    }\n    Serial.println(\"\");\n }\n```\n\n\n\n##\u52d5\u4f5c\u51e6\u7406\n\n\n\u5b9f\u969b\u306b\u30e2\u30fc\u30bf\u30fc\u306b\u547d\u4ee4\u3092\u51fa\u3059\u95a2\u6570\n\n```c:\nvoid motorOff(int motor){\n  for (int i=0; i<2; i++){\n    digitalWrite(inApin[i], LOW);\n    digitalWrite(inBpin[i], LOW);\n  }\n  analogWrite(pwmpin[motor], 0);\n}\n\nvoid motorGo(uint8_t motor, uint8_t direct, uint8_t pwm)\n{\n  if (motor <= 1){\n    if (direct <=4){\n      // Set inA[motor]\n      if (direct <=1)\n        digitalWrite(inApin[motor], HIGH);\n      else\n        digitalWrite(inApin[motor], LOW);\n      // Set inB[motor]\n      if ((direct==0)||(direct==2))\n        digitalWrite(inBpin[motor], HIGH);\n      else\n        digitalWrite(inBpin[motor], LOW);\n\n      analogWrite(pwmpin[motor], pwm);\n    }\n  }\n```\n\n\n\n#\u6539\u826f\u306e\u4f59\u5730\n\u30bd\u30fc\u30b9\u306f\u3053\u3053\u306b\n'https://github.com/sasaco/segway.git'\n\n\u307e\u3060\u3001\u524d\u9032\u30fb\u5f8c\u9032\u3057\u304b\u3084\u3063\u3066\u3044\u307e\u305b\u3093\n\u305d\u306e\u3046\u3061 z\u8ef8\u306e\u50be\u304d\u3092\u4f7f\u3063\u3066 \u5de6\u53f3\u306e\u30e2\u30fc\u30bf\u30fc\u306e\u56de\u8ee2\u6570\u3092\u5909\u3048\u3066\n\u66f2\u304c\u308c\u308b\u3088\u3046\u306b\u3057\u305f\u3044\u3068\u601d\u3044\u307e\u3059\u3002\n\n---\n\n\u6b21\u56de\u306f[\u30dc\u30c7\u30a3\u30fc\u7d44\u7acb\u7de8](http://qiita.com/sasaco/items/7f361b4fa2d1db572a6f)\u306b\u3064\u3044\u3066\u304a\u5c4a\u3051\u3057\u307e\u3059\u3002\n\n", "tags": ["segway", "DIY", "\u30bb\u30b0\u30a6\u30a7\u30a4", "Arduino", "C\u8a00\u8a9e"]}