{"context": "\n\n\u306f\u3058\u3081\u306b\next4\u306b\u3064\u3044\u3066\u306e\u8cc7\u6599\u306f\u30b0\u30b0\u308c\u3070\u307e\u3060\u63a2\u305b\u3070\u3042\u308b\u65b9\u3060\u3051\u3069\u3001\u3053\u3068journal\u306b\u3064\u3044\u3066\u306f\u3001mount\u30aa\u30d7\u30b7\u30e7\u30f3\u3068\u6982\u8981\u304f\u3089\u3044\u3057\u304b\u306a\u304f\u3066\u3001\u3064\u3063\u3053\u3093\u3060\u3053\u3068\u307e\u3067\u8aac\u660e\u3057\u305f\u8cc7\u6599\u304c\u7686\u7121\u306a\u72b6\u614b\u3002\u3068\u3044\u3046\u308f\u3051\u3067\u3001\u8a73\u7d30\u3092\u8ffd\u3046\u3053\u3068\u306b\u3057\u305f\u3002\u7121\u8336\u306a\u3053\u3068\u3057\u3084\u304c\u3063\u3066(AA\u7565\n\u306a\u304a\u3001Linux-4.6\u304f\u3089\u3044\u3092\u307f\u3066\u307e\u3059\u3002\n\nDocumentation\n\u6982\u8981\u3084\u3089mount\u30aa\u30d7\u30b7\u30e7\u30f3\u3084\u3089\u306b\u3064\u3044\u3066\u306f\u3001\u4e0b\u8a18\u306e\u3050\u305f\u3050\u305f\u3057\u305f\u6587\u7ae0\u3092\u8aad\u3080\u3088\u308a\u3082kernel/Documentation/filesystems/ext4.txt\u306e\u30c9\u30ad\u30e5\u30e1\u30f3\u30c8\u3092\u53c2\u7167\u3059\u308b\u65b9\u304c\u3088\u3044\u3002\n\njdb2\next4(\u307e\u305f\u306fext3)\u306ejournal\u306f\u6b63\u78ba\u306b\u306fext4\u306e\u4e00\u90e8\u3067\u306f\u306a\u304f\u3066jbd2(Journaling block device 2)\u3068\u3044\u3046\u30e2\u30b8\u30e5\u30fc\u30eb\u3068\u3057\u3066\u6c4e\u7528\u5316\u3055\u308c\u3066\u3044\u308b\u3002\u305f\u3060\u5b9f\u4f53\u306f\u3001ext4\u306f\u307e\u3060\u4ed6\u306ejournal\u306b\u8f09\u305b\u66ff\u3048\u308c\u305d\u3046\u306a\u8a2d\u8a08\u306b\u306a\u3063\u3066\u3044\u308b\u304c\u3001jdb2\u306f\u3082\u3046ext4\u5c02\u7528\u3068\u3044\u308f\u3056\u308b\u3092\u3048\u306a\u3044\u307b\u3069\u5bc6\u7d50\u5408\u3057\u3066\u3044\u308b\u3088\u3046\u306b\u8aad\u3081\u305f\u3002\next4\u3068\u3057\u3066\u306f\u591a\u304f\u306e\u5834\u5408journal\u306finode(\u3064\u307e\u308a\u666e\u901a\u306e\u30d5\u30a1\u30a4\u30eb)\u3068\u3057\u3066\u30b9\u30c8\u30ec\u30fc\u30b8\u306b\u4fdd\u5b58\u3059\u308b\u3002kernel/fs/ext4.h\u3088\u308a\u3001\n\next4.h\n209 /*\n210  * Special inodes numbers\n211  */\n212 #define EXT4_BAD_INO             1      /* Bad blocks inode */\n213 #define EXT4_ROOT_INO            2      /* Root inode */\n214 #define EXT4_USR_QUOTA_INO       3      /* User quota inode */\n215 #define EXT4_GRP_QUOTA_INO       4      /* Group quota inode */\n216 #define EXT4_BOOT_LOADER_INO     5      /* Boot loader inode */\n217 #define EXT4_UNDEL_DIR_INO       6      /* Undelete directory inode */\n218 #define EXT4_RESIZE_INO          7      /* Reserved group descriptors inode */\n219 #define EXT4_JOURNAL_INO         8      /* Journal inode */\n\n\n\u3068\u306a\u3063\u3066\u3044\u3066\u3001\u901a\u5e38\u306finode\u756a\u53f78\u304c\u4f7f\u308f\u308c\u308b\u3002\u304c\u3001\u30b3\u30fc\u30c9\u3068\u3057\u3066\u306fsuerblock\u306b\u3042\u308bs_journal_inum\u306e\u3082\u306e\u304c\u4f7f\u308f\u308c\u308b\u306e\u3067\u3001\u53e4\u3044e2fsprogs\u3092\u4f7f\u3063\u305f\u3001\u904e\u53bb\u304b\u3089\u5f15\u304d\u3064\u3044\u3060\u306a\u3069\u306e\u7279\u6b8a\u306a\u5834\u5408\u306f\u3053\u306e\u9650\u308a\u3067\u306a\u3044\u6a21\u69d8\u3002\u3067\u3001\u3053\u306einode\u756a\u53f7\u306e\u3082\u306e\u306fmount/umount\u6642\u306b\u7279\u6b8a\u306b\u6271\u308f\u308c\u3001journal\u306e\u8aad\u307f\u66f8\u304d\u306b\u4f7f\u308f\u308c\u308b\u3002\njournal\u30d5\u30a1\u30a4\u30eb\u306f\u901a\u5e38e2fsprogs\u306emke2fs(mkfs.ext4)\u3067\u4f5c\u3089\u308c\u308b\u3002lib/ext2fs/mkjournal.c:ext2fs_add_journal_inode2()\u3088\u308a\u3001\n\nmkjournal.c\n    } else {\n        if ((mount_flags & EXT2_MF_BUSY) &&\n            !(fs->flags & EXT2_FLAG_EXCLUSIVE)) {\n            retval = EBUSY;\n            goto errout;\n        }\n        journal_ino = EXT2_JOURNAL_INO;\n        if ((retval = write_journal_inode(fs, journal_ino,\n                          num_blocks, goal, flags)))\n            return retval;\n    }\n\n\nmount\u3055\u308c\u3066\u3044\u308b\u72b6\u614b\u304b\u3089\u4f5c\u308d\u3046\u3068\u3059\u308b\u3068\u3001EXT2_IOC_SETFLAGS\u3092\u4f7f\u3063\u3066UF_NODUMP|UF_IMMUTABLE(immutable\u304b\u3064no dump)\u30d5\u30e9\u30b0\u3092\u7acb\u3066\u308b\u304c\u3001mount\u3055\u308c\u3066\u3044\u306a\u304b\u3063\u305f\u3089\u4e0a\u8a18\u306e\u901a\u308a\u7279\u306b\u306a\u306b\u3082\u3057\u3066\u3044\u306a\u3044\u3002lookup\u3067\u304d\u306a\u3044(\u540d\u524d\u304b\u3089\u305f\u3069\u308c\u306a\u3044)inode\u3060\u304b\u3089\u7279\u306bIMMUTALBE\u306b\u3057\u306a\u304f\u3066\u3082\u3088\u3044\u3068\u3044\u3046\u3053\u3068\u306a\u3093\u3060\u308d\u3046\u304b\u3002\n# debugfs /dev/sa1\ndebugfs 1.42.13 (17-May-2015)\ndebugfs: stat <8>\nInode: 8   Type: regular    Mode:  0600   Flags: 0x80000\nGeneration: 0    Version: 0x00000000:00000000\nUser:     0   Group:     0   Size: 134217728\nFile ACL: 0    Directory ACL: 0\nLinks: 1   Blockcount: 262144\nFragment:  Address: 0    Number: 0    Size: 0\n ctime: 0x5878dec7:00000000 -- Fri Jan 13 23:05:59 2017\n atime: 0x5878dec7:00000000 -- Fri Jan 13 23:05:59 2017\n mtime: 0x5878dec7:00000000 -- Fri Jan 13 23:05:59 2017\ncrtime: 0x5878dec7:00000000 -- Fri Jan 13 23:05:59 2017\nSize of extra inode fields: 28\nEXTENTS:\n(0-32766):2655233-2687999, (32767):2688000\n\n\u624b\u5143\u3067inode\u756a\u53f78\u3092\u78ba\u8a8d\u3059\u308b\u3068\u3001flags: 0x80000 \u306a\u306e\u3067\u3001EXT4_EXTENTS_FL\u306e\u307f\u306e\u3088\u3046\u3060\u3063\u305f\u3002\n\u3061\u306a\u307f\u306b\u3001\u5916\u90e8journal\u3082\u30b5\u30dd\u30fc\u30c8\u3057\u3066\u3044\u3066\u3001mkfs.ext4 -J device=/dev/sda1\u3067\u4f5c\u308b\u3002\u305f\u3060\u3001\u30da\u30fc\u30b8\u306b\u3082\u66f8\u3044\u3066\u3042\u308b\u3068\u304a\u308a\u3001\u5916\u90e8\u30d6\u30ed\u30c3\u30af\u30c7\u30d0\u30a4\u30b9\u540d\u304c\u3044\u3064\u3082\u540c\u3058\u306b\u306a\u308b\u3068\u306f\u9650\u3089\u306a\u304b\u3063\u305f\u308a\u3059\u308b\u306e\u3067\u3001\u30aa\u30da\u30ec\u30fc\u30b7\u30e7\u30f3\u306b\u624b\u9593\u3092\u639b\u3051\u305f\u304f\u306a\u3044\u306a\u3089\u4f7f\u308f\u306a\u3044\u65b9\u304c\u3088\u3044\u3002\u307e\u305fjournal_async_commit\u3067\u306a\u3044\u3068\u30c0\u30e1\u3068\u66f8\u304b\u308c\u3066\u3044\u3066\u3055\u3089\u306b\u4e0d\u5b89\u306b\u306a\u308b\u3002\u3069\u3046\u30c0\u30e1\u306a\u306e\u304b\u88cf\u4ed8\u3051\u3057\u305f\u304b\u3063\u305f\u3051\u3069\u3001kernel\u30bd\u30fc\u30b9\u7684\u306b\u306f\u7279\u306b\u305d\u308c\u3063\u307d\u3044\u306e\u306f\u898b\u3042\u305f\u3089\u306a\u304b\u3063\u305f\u3002\n\njournal\u30e2\u30fc\u30c9\n3\u7a2e\u985e\u306e\u30e2\u30fc\u30c9\u304c\u3042\u308b\u3002default mount option(HOGE_DEFM_HOGE\u306e\u3084\u3064)\u3001\u3082\u3057\u304f\u306fmount\u30aa\u30d7\u30b7\u30e7\u30f3\u306b\u6307\u5b9a\u3059\u308b\u3002\u6307\u5b9a\u304c\u306a\u3044\u5834\u5408data=ordered\u306b\u306a\u308b\u3002\n\n\ndata=writeback\u3001metadata(\u30d5\u30a1\u30a4\u30eb\u30b5\u30a4\u30ba\u306a\u3069)\u3068\u30c7\u30fc\u30bf\u306e\u4e2d\u8eab\u306e\u66f8\u304d\u51fa\u3057\u9806\u304c\u4fdd\u969c\u3055\u308c\u306a\u3044\u3002\u30bb\u30ad\u30e5\u30ea\u30c6\u30a3\u9762\u3067\u3082\u3088\u304f\u306a\u3044\u3068\u30c9\u30ad\u30e5\u30e1\u30f3\u30c8\u306b\u66f8\u3044\u3066\u3042\u308a\u3001\u3088\u307b\u3069\u30d1\u30d5\u30a9\u30fc\u30de\u30f3\u30b9\u3092\u6c17\u306b\u3059\u308b\u5834\u9762\u4ee5\u5916\u3067\u306f\u3082\u3046\u4f7f\u308f\u306a\u3044\u3093\u3058\u3083\u306a\u3044\u304b\u3068\u601d\u3046\u3002 \u305d\u306e\u30d1\u30d5\u30a9\u30fc\u30de\u30f3\u30b9\u3082\u3001\u624b\u5143\u3067\u30c6\u30b9\u30c8\u3057\u3066\u307f\u305f\u9650\u308adata=ordered\u3068\u6709\u610f\u306a\u5dee\u304c\u306a\u304b\u3063\u305f\u3002 data=writeback\u3060\u3068\u5dee\u304c\u308f\u304b\u308b\u7a0b\u5ea6\u306b\u306f\u5c11\u3057\u65e9\u304b\u3063\u305f\u3002\u305f\u3060data=journal\u306f\u3055\u3059\u304c\u306b\u9045\u304b\u3063\u305f\u3002\n\ndata=ordered\u3001meta\u30c7\u30fc\u30bf\u3068\u30c7\u30fc\u30bf\u306e\u4e2d\u8eab\u306e\u66f8\u304d\u51fa\u3057\u9806\u304c\u4fdd\u969c\u3055\u308c\u308b\u3002\u6a19\u6e96\u306e\u30e2\u30fc\u30c9\u3002\n\ndata=journal\u3001\u30c7\u30fc\u30bf\u306e\u4e2d\u8eab\u3082\u4e00\u5ea6journal\u306b\u66f8\u304d\u51fa\u3057\u3066\u304b\u3089\u5b9f\u969b\u306e\u66f8\u304d\u8fbc\u307f\u304c\u884c\u308f\u308c\u308b\u3002\u3082\u3046journal\u3068\u3044\u3046\u3088\u308atransaction\u3068\u3044\u3063\u305f\u65b9\u304c\u3044\u3044\u304b\u3082\u3057\u308c\u306a\u3044\u3002\n\n\u305f\u3060\u3001ext4\u304c\u5897\u7bc9\u3067\u6a5f\u80fd\u304c\u5897\u3048\u3066\u304d\u305f\u7d4c\u7def\u3082\u3042\u3063\u3066\u304b\u3001journal\u30e2\u30fc\u30c9\u306b\u3088\u3063\u3066\u4f7f\u3048\u308b\u6a5f\u80fd\u306b\u5236\u9650\u304c\u304b\u304b\u308b\u3053\u3068\u304c\u591a\u3044\u3002\u3064\u307e\u307f\u98df\u3044\u7a0b\u5ea6\u306b\u4e0b\u8a18\u306b\u5177\u4f53\u4f8b\u3092\u3002\nkernel/fs/ext4/super.c:ext4_fill_super()\u3088\u308a\u3001data=journal\u3060\u3068DELALLOC\u306f\u7121\u52b9\u306b\u306a\u308b\u3002\u3055\u304b\u306e\u307c\u308b\u9650\u308a\u3001dd919b982\u3001\u3064\u307e\u308aDEALLOC\u5f53\u521d\u304b\u3089\u306e\u6a21\u69d8\u3002\u5b9f\u88c5\u304c\u96e3\u3057\u304f\u306a\u308b(\u4ed6\u306ejournal\u30e2\u30fc\u30c9\u3068\u306f\u5225\u306epath\u306b\u306a\u308b)\u304b\u3089\u3058\u3083\u306a\u3044\u304b\u3068\u601d\u308f\u308c\u308b\u3002\n\nsuper.c\n3335         if (test_opt(sb, DATA_FLAGS) == EXT4_MOUNT_JOURNAL_DATA) {\n3336                 printk_once(KERN_WARNING \"EXT4-fs: Warning: mounting \"\n3337                             \"with data=journal disables delayed \"\n3338                             \"allocation and O_DIRECT support!\\n\");\n3339                 if (test_opt2(sb, EXPLICIT_DELALLOC)) {\n3340                         ext4_msg(sb, KERN_ERR, \"can't mount with \"\n3341                                  \"both data=journal and delalloc\");\n3342                         goto failed_mount;\n3343                 }\n3344                 if (test_opt(sb, DIOREAD_NOLOCK)) {\n3345                         ext4_msg(sb, KERN_ERR, \"can't mount with \"\n3346                                  \"both data=journal and dioread_nolock\");\n3347                         goto failed_mount;\n3348                 }\n3349                 if (test_opt(sb, DAX)) {\n3350                         ext4_msg(sb, KERN_ERR, \"can't mount with \"\n3351                                  \"both data=journal and dax\");\n3352                         goto failed_mount;\n3353                 }\n3354                 if (test_opt(sb, DELALLOC))\n3355                         clear_opt(sb, DELALLOC);\n3356         } else {\n3357                 sb->s_iflags |= SB_I_CGROUPWB;\n3358         }\n\n\nkernel/fs/ext4/super.c:parse_options()\u3088\u308a\u3001data=ordered\u3060\u3068journal_async_commit\u306f\u4f7f\u3048\u306a\u3044\u3002d4f761074\u3067\u5165\u3063\u305f\u3002\n\nsuper.c\n1794         if (test_opt(sb, DATA_FLAGS) == EXT4_MOUNT_ORDERED_DATA &&\n1795             test_opt(sb, JOURNAL_ASYNC_COMMIT)) {\n1796                 ext4_msg(sb, KERN_ERR, \"can't mount with journal_async_commit \"\n1797                          \"in data=ordered mode\");\n1798                 return 0;\n1799         }\n\n\nkernel/fs/ext4/super.c:ext4_mount_opts[]\u3088\u308a\u3001journal_async_commit\u3060\u3068journal_checksum\u3082\u7acb\u3064\u3002\n\nsuper.c\n1420         {Opt_journal_async_commit, (EXT4_MOUNT_JOURNAL_ASYNC_COMMIT |\n1421                                     EXT4_MOUNT_JOURNAL_CHECKSUM),\n\n\n\u304c\u3001kernel/fs/ext4/super.c:set_journal_csum_feature_set()\u306b\u3088\u308b\u3068\u3001JOURNAL_ASYNC_COMMIT\u304c\u7acb\u3063\u3066\u3044\u308b\u3068\u304d\u306fJOURNAL_CHECKSUM\u306f\u610f\u5473\u3092\u306a\u3057\u3066\u3044\u306a\u3044\u3088\u3046\u306b\u898b\u3048\u308b\u3002\u4ed6\u306bJOURNAL_CHECKSUM\u3092\u53c2\u7167\u3057\u3066\u3044\u308b\u7b87\u6240\u3082\u306a\u304f\u3001jbd2\u306e\u4e2d\u3067async_commit\u304c\u7acb\u3063\u3066\u3044\u308b\u3068checksum\u3082\u52d5\u304f\u3001\u3068\u304b\u3044\u3046\u98a8\u306b\u3082\u898b\u3048\u305a\u3001\u4f55\u306e\u305f\u3081\u306a\u306e\u304b\u308f\u304b\u3089\u306a\u304b\u3063\u305f\u3002\n\nsuper.c\n2981         if (test_opt(sb, JOURNAL_ASYNC_COMMIT)) {\n2982                 ret = jbd2_journal_set_features(sbi->s_journal,\n2983                                 compat, 0,\n2984                                 JBD2_FEATURE_INCOMPAT_ASYNC_COMMIT |\n2985                                 incompat);\n2986         } else if (test_opt(sb, JOURNAL_CHECKSUM)) {\n2987                 ret = jbd2_journal_set_features(sbi->s_journal,\n2988                                 compat, 0,\n2989                                 incompat);\n2990                 jbd2_journal_clear_features(sbi->s_journal, 0, 0,\n2991                                 JBD2_FEATURE_INCOMPAT_ASYNC_COMMIT);\n2992         } else {\n2993                 jbd2_journal_clear_features(sbi->s_journal, 0, 0,\n2994                                 JBD2_FEATURE_INCOMPAT_ASYNC_COMMIT);\n2995         }\n\n\nkernel/fs/ext4/super.c:ext4_fill_super()\u3088\u308a\u3001journal\u306a\u3057\u3060\u3068journal_async_commit\u306f\u4f7f\u3048\u306a\u3044\u3002\u30fb\u30fb\u30fb\u306f\u3055\u3059\u304c\u306b\u81ea\u660e\u304b\u3002\n\nsuper.c\n3736                 if (test_opt(sb, JOURNAL_ASYNC_COMMIT)) {\n3737                         ext4_msg(sb, KERN_ERR, \"can't mount with \"\n3738                                  \"journal_async_commit, fs mounted w/o journal\");\n3739                         goto failed_mount_wq;\n3740                 }\n\n\n\n\u30b3\u30fc\u30c9\u3092\u8aad\u3080\n\n\u30aa\u30d7\u30b7\u30e7\u30f3\u306e\u89e3\u91c8\nkernel/fs/ext4/super.c\u306etokens\u3068ext4_mount_opts\u3088\u308a\u3001\n\nsuper.c\n1233         {Opt_data_journal, \"data=journal\"},\n1234         {Opt_data_ordered, \"data=ordered\"},\n1235         {Opt_data_writeback, \"data=writeback\"},\n\n\n\nsuper.c\n1448         {Opt_data_journal, EXT4_MOUNT_JOURNAL_DATA, MOPT_NO_EXT2 | MOPT_DATAJ},\n1449         {Opt_data_ordered, EXT4_MOUNT_ORDERED_DATA, MOPT_NO_EXT2 | MOPT_DATAJ},\n1450         {Opt_data_writeback, EXT4_MOUNT_WRITEBACK_DATA,\n1451          MOPT_NO_EXT2 | MOPT_DATAJ},\n\n\ndata=writeback\u306e\u5834\u5408\u306fEXT4_MOUNT_WRITEBACK_DATA\u304c\u3001data=ordered\u306e\u5834\u5408\u306fEXT4_MOUNT_ORDERED_DATA\u304c\u3001data=journal\u306e\u5834\u5408\u306fEXT4_MOUNT_JOURNAL_DATA\u304c\u3001\u305d\u308c\u305e\u308c\u7acb\u3064\u3002\njournal\u306e\u8aad\u307f\u8fbc\u307f\u3082\u307e\u305fkernel/fs/ext4/super.c:ext4_fill_super()\u3067\u884c\u308f\u308c\u308b\u3002\n\nsuper.c\n3717         /*\n3718          * The first inode we look at is the journal inode.  Don't try\n3719          * root first: it may be modified in the journal!\n3720          */\n3721         if (!test_opt(sb, NOLOAD) && ext4_has_feature_journal(sb)) {\n3722                 if (ext4_load_journal(sb, es, journal_devnum))\n3723                         goto failed_mount3a;\n3724         } else if (test_opt(sb, NOLOAD) && !(sb->s_flags & MS_RDONLY) &&\n3725                    ext4_has_feature_journal_needs_recovery(sb)) {\n3726                 ext4_msg(sb, KERN_ERR, \"required journal recovery \"\n3727                        \"suppressed and not mounted read-only\");\n3728                 goto failed_mount_wq;\n3729         } else {\n3730                 /* Nojournal mode, all journal mount options are illegal */\n3731                 if (test_opt2(sb, EXPLICIT_JOURNAL_CHECKSUM)) {\n3732                         ext4_msg(sb, KERN_ERR, \"can't mount with \"\n3733                                  \"journal_checksum, fs mounted w/o journal\");\n3734                         goto failed_mount_wq;\n3735                 }\n3736                 if (test_opt(sb, JOURNAL_ASYNC_COMMIT)) {\n3737                         ext4_msg(sb, KERN_ERR, \"can't mount with \"\n3738                                  \"journal_async_commit, fs mounted w/o journal\");\n3739                         goto failed_mount_wq;\n3740                 }\n3741                 if (sbi->s_commit_interval != JBD2_DEFAULT_MAX_COMMIT_AGE*HZ) {\n3742                         ext4_msg(sb, KERN_ERR, \"can't mount with \"\n3743                                  \"commit=%lu, fs mounted w/o journal\",\n3744                                  sbi->s_commit_interval / HZ);\n3745                         goto failed_mount_wq;\n3746                 }\n3747                 if (EXT4_MOUNT_DATA_FLAGS &\n3748                     (sbi->s_mount_opt ^ sbi->s_def_mount_opt)) {\n3749                         ext4_msg(sb, KERN_ERR, \"can't mount with \"\n3750                                  \"data=, fs mounted w/o journal\");\n3751                         goto failed_mount_wq;\n3752                 }\n3753                 sbi->s_def_mount_opt &= EXT4_MOUNT_JOURNAL_CHECKSUM;\n3754                 clear_opt(sb, JOURNAL_CHECKSUM);\n3755                 clear_opt(sb, DATA_FLAGS);\n3756                 sbi->s_journal = NULL;\n3757                 needs_recovery = 0;\n3758                 goto no_journal;\n3759         }\n\n\n\nnoload\u3058\u3083\u306a\u3044\u3001\u304b\u3064\u3001super\u30d6\u30ed\u30c3\u30af\u306bjournal\u30aa\u30d7\u30b7\u30e7\u30f3\u304c\u3042\u308b\u5834\u5408\u3001journal\u3092\u8aad\u307f\u306b\u3044\u3063\u3066\u30c0\u30e1\u306a\u3089mount\u30a8\u30e9\u30fc\nnoload\u3001\u304b\u3064\u3001readonly\u3058\u3083\u306a\u3044\u3001\u304b\u3064\u3001super\u30d6\u30ed\u30c3\u30af\u306brecovery\u30aa\u30d7\u30b7\u30e7\u30f3\u304c\u3042\u308b\u306a\u3089\u3001mount\u30a8\u30e9\u30fc\n\u4e0a\u8a18\u3058\u3083\u306a\u3044\u5834\u5408\u3001journal\u306a\u3057\u30e2\u30fc\u30c9(sbi->s_journal\u304cNULL)\u3068\u306a\u3063\u3066\u5404\u7a2e\u30c1\u30a7\u30c3\u30af\u3092\u884c\u3046\u3002\n\n\u3068\u3044\u3046\u611f\u3058\u306b\u306a\u3063\u3066\u3044\u308b\u3002\nEXT4_MOUNT_WRITEBACK_DATA, EXT4_MOUNT_ORDERED_DATA, EXT4_MOUNT_JOURNAL_DATA\u306f\u3001\u5b9f\u8cea\u7684\u306bkernel/fs/ext4/ext4_jbd2.h:ext4_inode_journal_mode()\u3067\u306e\u307f\u4f7f\u308f\u308c\u3066\u3044\u308b\n\next4_jbd2.h\n392 static inline int ext4_inode_journal_mode(struct inode *inode)\n393 {\n394         if (EXT4_JOURNAL(inode) == NULL)\n395                 return EXT4_INODE_WRITEBACK_DATA_MODE;  /* writeback */\n396         /* We do not support data journalling with delayed allocation */\n397         if (!S_ISREG(inode->i_mode) ||\n398             test_opt(inode->i_sb, DATA_FLAGS) == EXT4_MOUNT_JOURNAL_DATA)\n399                 return EXT4_INODE_JOURNAL_DATA_MODE;    /* journal data */\n400         if (ext4_test_inode_flag(inode, EXT4_INODE_JOURNAL_DATA) &&\n401             !test_opt(inode->i_sb, DELALLOC))\n402                 return EXT4_INODE_JOURNAL_DATA_MODE;    /* journal data */\n403         if (test_opt(inode->i_sb, DATA_FLAGS) == EXT4_MOUNT_ORDERED_DATA)\n404                 return EXT4_INODE_ORDERED_DATA_MODE;    /* ordered */\n405         if (test_opt(inode->i_sb, DATA_FLAGS) == EXT4_MOUNT_WRITEBACK_DATA)\n406                 return EXT4_INODE_WRITEBACK_DATA_MODE;  /* writeback */\n407         else\n408                 BUG();\n409 }\n410 \n411 static inline int ext4_should_journal_data(struct inode *inode)\n412 {\n413         return ext4_inode_journal_mode(inode) & EXT4_INODE_JOURNAL_DATA_MODE;\n414 }\n415 \n416 static inline int ext4_should_order_data(struct inode *inode)\n417 {\n418         return ext4_inode_journal_mode(inode) & EXT4_INODE_ORDERED_DATA_MODE;\n419 }\n420 \n421 static inline int ext4_should_writeback_data(struct inode *inode)\n422 {\n423         return ext4_inode_journal_mode(inode) & EXT4_INODE_WRITEBACK_DATA_MODE;\n424 }\n\n\ninode\u3054\u3068\u306b\u5224\u65ad\u3055\u308c\u308b\u3082\u306e\u306e\u3001\u7d50\u5c40\u3001ext4_should_journal_data(), ext4_should_order_data(), ext4_should_writeback_data()\u3092\u78ba\u8a8d\u3059\u308c\u3070\u3088\u3044\u3068\u306a\u308b\u3002...\u53b3\u5bc6\u306b\u8a00\u3046\u3068\u3001kernel/fs/ext4/inode.c:ext4_set_aops()\u3082\u3042\u308b\u3051\u3069\u3001\u3053\u3063\u3061\u306f\u3069\u3093\u3069\u3093\u8131\u7dda\u65b9\u5411\u306b\u306a\u308a\u305d\u3046\u3067\u3001\u4eca\u56de\u306f\u7701\u7565\u3059\u308b...\n\ninode.c\n3533 void ext4_set_aops(struct inode *inode)\n3534 {\n3535         switch (ext4_inode_journal_mode(inode)) {\n3536         case EXT4_INODE_ORDERED_DATA_MODE:\n3537                 ext4_set_inode_state(inode, EXT4_STATE_ORDERED_MODE);\n3538                 break;\n3539         case EXT4_INODE_WRITEBACK_DATA_MODE:\n3540                 ext4_clear_inode_state(inode, EXT4_STATE_ORDERED_MODE);\n3541                 break;\n3542         case EXT4_INODE_JOURNAL_DATA_MODE:\n3543                 inode->i_mapping->a_ops = &ext4_journalled_aops;\n3544                 return;\n3545         default:\n3546                 BUG();\n3547         }\n3548         if (test_opt(inode->i_sb, DELALLOC))\n3549                 inode->i_mapping->a_ops = &ext4_da_aops;\n3550         else\n3551                 inode->i_mapping->a_ops = &ext4_aops;\n3552 }\n\n\n\njournal\u30e2\u30fc\u30c9\u306b\u3088\u308b\u9055\u3044\n\next4_should_writeback_data()\nkernel/fs/ext4/mballoc.c:ext4_free_blocks()\u3067\u4f7f\u308f\u308c\u3066\u3044\u308b\u3002\n\nmballoc.c\n4820         /*\n4821          * We need to make sure we don't reuse the freed block until after the\n4822          * transaction is committed. We make an exception if the inode is to be\n4823          * written in writeback mode since writeback mode has weak data\n4824          * consistency guarantees.\n4825          */\n4826         if (ext4_handle_valid(handle) &&\n4827             ((flags & EXT4_FREE_BLOCKS_METADATA) ||\n4828              !ext4_should_writeback_data(inode))) {\n4829                 struct ext4_free_data *new_entry;\n4830                 /*\n4831                  * We use __GFP_NOFAIL because ext4_free_blocks() is not allowed\n4832                  * to fail.\n4833                  */\n4834                 new_entry = kmem_cache_alloc(ext4_free_data_cachep,\n4835                                 GFP_NOFS|__GFP_NOFAIL);\n4836                 new_entry->efd_start_cluster = bit;\n4837                 new_entry->efd_group = block_group;\n4838                 new_entry->efd_count = count_clusters;\n4839                 new_entry->efd_tid = handle->h_transaction->t_tid;\n4840 \n4841                 ext4_lock_group(sb, block_group);\n4842                 mb_clear_bits(bitmap_bh->b_data, bit, count_clusters);\n4843                 ext4_mb_free_metadata(handle, &e4b, new_entry);\n4844         } else {\n4845                 /* need to update group_info->bb_free and bitmap\n4846                  * with group lock held. generate_buddy look at\n4847                  * them with group lock_held\n4848                  */\n4849                 if (test_opt(sb, DISCARD)) {\n4850                         err = ext4_issue_discard(sb, block_group, bit, count);\n4851                         if (err && err != -EOPNOTSUPP)\n4852                                 ext4_msg(sb, KERN_WARNING, \"discard request in\"\n4853                                          \" group:%d block:%d count:%lu failed\"\n4854                                          \" with %d\", block_group, bit, count,\n4855                                          err);\n4856                 } else\n4857                         EXT4_MB_GRP_CLEAR_TRIMMED(e4b.bd_info);\n4858 \n4859                 ext4_lock_group(sb, block_group);\n4860                 mb_clear_bits(bitmap_bh->b_data, bit, count_clusters);\n4861                 mb_free_blocks(inode, &e4b, bit, count_clusters);\n4862         }\n\n\nfree(\u30d5\u30a1\u30a4\u30eb\u304c\u6d88\u3048\u308b\u30fb\u5c0f\u3055\u304f\u306a\u308b)\u6642\u306b\u3001metadata(\u30d5\u30a1\u30a4\u30eb\u30b5\u30a4\u30ba)\u306e\u5909\u66f4\u3068\u30c7\u30fc\u30bf\u306ebitmap\u5909\u66f4\u3068\u306e\u3069\u3061\u3089\u3092\u5148\u306b\u3059\u308b\u304b\u3001\u306e\u3088\u3046\u3060\u3002\n\next4_should_order_data()\n2\u7b87\u6240\u3042\u308b\u3002\n1\u3064\u3081\u306fkernel/fs/ext4/inode.c:ext4_evict_inode()\u3001\u30d5\u30a1\u30a4\u30eb\u3092\u6d88\u3059\u3068\u304d\u306b\u30d5\u30a1\u30a4\u30eb\u30b5\u30a4\u30ba\u3092\u5148\u306b\u30bc\u30ed\u306b\u3057\u3066\u3044\u308b\u3002\n\ninode.c\n226         if (ext4_should_order_data(inode))\n227                 ext4_begin_ordered_truncate(inode, 0);\n\n\n2\u3064\u3081\u306f\u3001kernel/fs/ext4/inode.c:ext4_setattr()\u3001\u30d5\u30a1\u30a4\u30eb\u30b5\u30a4\u30ba\u3092\u5c0f\u3055\u304f\u3059\u308b\u3068\u304d\u306bext4_begin_ordered_truncate()\u3092\u547c\u3076\u3002\n\ninode.c\n5006                 if (ext4_should_order_data(inode) &&\n5007                     (attr->ia_size < inode->i_size)) {\n5008                         error = ext4_begin_ordered_truncate(inode,\n5009                                                             attr->ia_size);\n5010                         if (error)\n5011                                 goto err_out;\n5012                 }\n\n\next4_begin_ordered_truncate()\u306f\u3001kernel/fs/jbd2/transaction.c:jbd2_journal_begin_ordered_truncate()\u3092\u547c\u3076\u3002\u7d50\u5c40\u306e\u3068\u3053\u308d\u3001journal\u304c\u307e\u3060commit\u3055\u308c\u3066\u3044\u306a\u304b\u3063\u305f\u3089filemap_fdatawrite_range()\u3092\u547c\u3076\u3002\u3053\u308c\u306fWB_SYNC_ALL\u3067_filemap_fdatawriterange()\u3092\u547c\u3076\u3001\u3064\u307e\u308a\u66f8\u304d\u51fa\u3057\u5f85\u3061\u3092\u3059\u308b\u3002\n\ntransaction.c\n2565         if (inode_trans == commit_trans) {\n2566                 ret = filemap_fdatawrite_range(jinode->i_vfs_inode->i_mapping,\n2567                         new_size, LLONG_MAX);\n2568                 if (ret)\n2569                         jbd2_journal_abort(journal, ret);\n2570         }\n\n\n\next4_should_journal_data()\n\u305f\u304f\u3055\u3093\u3042\u3063\u3066\u9577\u3005\u3068\u306a\u3063\u3066\u3057\u307e\u3063\u3066\u3044\u308b\u306e\u3067\u3001\u6c17\u9577\u306b\u8aad\u3093\u3067...\nkernel/fs/ext4/super.c:ext4_quota_on()\u3067\u306f\u3001quota\u51e6\u7406\u3092\u958b\u59cb\u3059\u308b\u524d\u306b\u660e\u793a\u7684\u306bflush\u3057\u3066\u3044\u308b\u3002\u30b3\u30e1\u30f3\u30c8\u304b\u3089\u5bdf\u3059\u308b\u306b\u3001\u305f\u3076\u3093flush\u305b\u305a\u306bquota\u51e6\u7406\u3057\u3088\u3046\u3068\u3059\u308b\u3068\u8907\u96d1\u306b\u306a\u308b\u3093\u3060\u308d\u3046\u3002\n\nsuper.c\n5069         /*\n5070          * When we journal data on quota file, we have to flush journal to see\n5071          * all updates to the file when we bypass pagecache...\n5072          */\n5073         if (EXT4_SB(sb)->s_journal &&\n5074             ext4_should_journal_data(d_inode(path->dentry))) {\n5075                 /*\n5076                  * We don't need to lock updates but journal_flush() could\n5077                  * otherwise be livelocked...\n5078                  */\n5079                 jbd2_journal_lock_updates(EXT4_SB(sb)->s_journal);\n5080                 err = jbd2_journal_flush(EXT4_SB(sb)->s_journal);\n5081                 jbd2_journal_unlock_updates(EXT4_SB(sb)->s_journal);\n5082                 if (err)\n5083                         return err;\n5084         }\n\n\nkernel/fs/ext4/inline.c:ext4_convert_inline_data_to_extent()\u306f\u3001\u3059\u3079\u3066\u306e\u30da\u30fc\u30b8\u3054\u3068\u306bdo_journal_get_write_access()\u95a2\u6570\u3092\u547c\u3076\u3002kernel/fs/ext4/inode.c:do_journal_get_write_access()\u306f\u3001\u3044\u307e\u3044\u3061\u7406\u89e3\u3057\u304d\u308c\u306a\u3044\u3051\u3069\u3001dirty\u306a\u3089ext4_handle_dirty_metadata()\u3092\u547c\u3076\u3053\u3068\u3067\u66f8\u304d\u8fbc\u3080\u30bf\u30a4\u30df\u30f3\u30b0\u3092\u78ba\u5b9a\u3055\u305b\u3066\u3044\u308b\u3063\u307d\u3044\uff1f\n\ninline.c\n590         if (!ret && ext4_should_journal_data(inode)) {\n591                 ret = ext4_walk_page_buffers(handle, page_buffers(page),\n592                                              from, to, NULL,\n593                                              do_journal_get_write_access);\n594         }\n\n\n\ninode\n1005 /*\n1006  * To preserve ordering, it is essential that the hole instantiation and\n1007  * the data write be encapsulated in a single transaction.  We cannot\n1008  * close off a transaction and start a new one between the ext4_get_block()\n1009  * and the commit_write().  So doing the jbd2_journal_start at the start of\n1010  * prepare_write() is the right place.\n1011  *\n1012  * Also, this function can nest inside ext4_writepage().  In that case, we\n1013  * *know* that ext4_writepage() has generated enough buffer credits to do the\n1014  * whole page.  So we won't block on the journal in that case, which is good,\n1015  * because the caller may be PF_MEMALLOC.\n1016  *\n1017  * By accident, ext4 can be reentered when a transaction is open via\n1018  * quota file writes.  If we were to commit the transaction while thus\n1019  * reentered, there can be a deadlock - we would be holding a quota\n1020  * lock, and the commit would never complete if another thread had a\n1021  * transaction open and was blocking on the quota lock - a ranking\n1022  * violation.\n1023  *\n1024  * So what we do is to rely on the fact that jbd2_journal_stop/journal_start\n1025  * will _not_ run commit under these circumstances because handle->h_ref\n1026  * is elevated.  We'll still have enough credits for the tiny quotafile\n1027  * write.\n1028  */\n1029 int do_journal_get_write_access(handle_t *handle,\n1030                                 struct buffer_head *bh)\n1031 {\n1032         int dirty = buffer_dirty(bh);\n1033         int ret;\n1034 \n1035         if (!buffer_mapped(bh) || buffer_freed(bh))\n1036                 return 0;\n1037         /*\n1038          * __block_write_begin() could have dirtied some buffers. Clean\n1039          * the dirty bit as jbd2_journal_get_write_access() could complain\n1040          * otherwise about fs integrity issues. Setting of the dirty bit\n1041          * by __block_write_begin() isn't a real problem here as we clear\n1042          * the bit before releasing a page lock and thus writeback cannot\n1043          * ever write the buffer.\n1044          */\n1045         if (dirty)\n1046                 clear_buffer_dirty(bh);\n1047         BUFFER_TRACE(bh, \"get write access\");\n1048         ret = ext4_journal_get_write_access(handle, bh);\n1049         if (!ret && dirty)\n1050                 ret = ext4_handle_dirty_metadata(handle, NULL, bh);\n1051         return ret;\n1052 }\n\n\nkernel/fs/ext4/indirect.c:ext4_clear_blocks()\u306f\u3001EXT4_FREE_BLOCKS_FORGET\u3092\u7acb\u3066\u308b\u3053\u3068\u3067\u3001ext4_free_blocks()\u306e\u4e2d\u304b\u3089ext4_forget()\u3092\u547c\u3076\u3088\u3046\u306b\u3057\u3066\u3044\u308b\u3002ext4_forget()\u306f\u3001data=journal\u306e\u5834\u5408\u306fjbd2\u306eforget\u3092\u547c\u3076\u3001\u305d\u3046\u3067\u306a\u3044\u5834\u5408\u306fjbd2\u306erevoke\u3092\u547c\u3076\u3002\n\nindirect.c\n959         if (S_ISDIR(inode->i_mode) || S_ISLNK(inode->i_mode))\n960                 flags |= EXT4_FREE_BLOCKS_FORGET | EXT4_FREE_BLOCKS_METADATA;\n961         else if (ext4_should_journal_data(inode))\n962                 flags |= EXT4_FREE_BLOCKS_FORGET;\n\n\nkernel/fs/ext4/fsync.c:ext4_sync_file()\u306f\u3001fsync(2)\u306f\u672c\u6765\u306a\u3089\u30c7\u30fc\u30bf\u3092\u66f8\u304d\u8fbc\u3080\u3068\u3053\u308d\u307e\u3067\u5f85\u3064\u3079\u304d\u3060\u304c\u3001data=journal\u30e2\u30fc\u30c9\u3060\u3068\u30c7\u30fc\u30bf\u306fjournal\u306b\u5148\u306b\u66f8\u304f\u306e\u3067\u3001journal\u3060\u3051\u66f8\u304d\u51fa\u305b\u3070\u3088\u3044\u3053\u3068\u306b\u306a\u308b\u3001\u304b\u3089\u305d\u3046\u3057\u3066\u3044\u308b\u3088\u3046\u3060\u3002\n\nfsync.c\n118         /*\n119          * data=writeback,ordered:\n120          *  The caller's filemap_fdatawrite()/wait will sync the data.\n121          *  Metadata is in the journal, we wait for proper transaction to\n122          *  commit here.\n123          *\n124          * data=journal:\n125          *  filemap_fdatawrite won't do anything (the buffers are clean).\n126          *  ext4_force_commit will write the file data into the journal and\n127          *  will wait on that.\n128          *  filemap_fdatawait() will encounter a ton of newly-dirtied pages\n129          *  (they were dirtied by commit).  But that's OK - the blocks are\n130          *  safe in-journal, which is all fsync() needs to ensure.\n131          */\n132         if (ext4_should_journal_data(inode)) {\n133                 ret = ext4_force_commit(inode->i_sb);\n134                 goto out;\n135         }\n\n\nkernel/fs/ext4/move_extent.c:ext4_move_extents()\u306f\u3001data=journal\u3060\u3068online defrag\u304c\u3067\u304d\u306a\u3044\u307f\u305f\u3044\u3002\u305f\u3060\u73fe\u6642\u70b9(2017/02/08)\u3067\u3082\u307e\u3060TODO:\u306e\u307e\u307e\u3060\u3063\u305f\u3002\u3050\u306c\u306c...\u3061\u306a\u307f\u306bonline defrag\u3066\u3044\u3046\u306e\u306fe2fsprogs\u306b\u542b\u307e\u308c\u308be4defrag(8)\u3068\u3044\u3046\u30c4\u30fc\u30eb\u306e\u3053\u3068\u307f\u305f\u3044\u3002ioctl\u306eEXT4_IOC_MOVE_EXT\u3067\u3067\u304d\u308b\u307f\u305f\u3044\u3002\n\nmove_extent.c\n592         /* TODO: it's not obvious how to swap blocks for inodes with full\n593            journaling enabled */\n594         if (ext4_should_journal_data(orig_inode) ||\n595             ext4_should_journal_data(donor_inode)) {\n596                 ext4_msg(orig_inode->i_sb, KERN_ERR,\n597                          \"Online defrag not supported with data journaling\");\n598                 return -EOPNOTSUPP;\n599         }\n\n\nkernel/fs/ext4/inode.c:ext4_evict_inode()\u306f\u3001\n\u6d88\u305d\u3046\u3068\u3057\u3066\u3044\u308b\u30d5\u30a1\u30a4\u30eb\u306fVFS\u7684\u306bclean\u3068\u5224\u65ad\u3055\u308c\u308b\u3051\u3069journal\u7684\u306b\u306f\u6b8b\u3063\u3066\u3044\u308b\u306e\u3067\u3001\u305d\u308c\u3092\u30b1\u30a2\u3057\u306a\u3044\u3068\u3044\u3051\u306a\u3044\u307f\u305f\u3044\uff1f\n\ninode.c\n189         if (inode->i_nlink) {\n190                 /*\n191                  * When journalling data dirty buffers are tracked only in the\n192                  * journal. So although mm thinks everything is clean and\n193                  * ready for reaping the inode might still have some pages to\n194                  * write in the running transaction or waiting to be\n195                  * checkpointed. Thus calling jbd2_journal_invalidatepage()\n196                  * (via truncate_inode_pages()) to discard these buffers can\n197                  * cause data loss. Also even if we did not discard these\n198                  * buffers, we would have no way to find them after the inode\n199                  * is reaped and thus user could see stale data if he tries to\n200                  * read them before the transaction is checkpointed. So be\n201                  * careful and force everything to disk here... We use\n202                  * ei->i_datasync_tid to store the newest transaction\n203                  * containing inode's data.\n204                  *\n205                  * Note that directories do not have this problem because they\n206                  * don't use page cache.\n207                  */\n208                 if (ext4_should_journal_data(inode) &&\n209                     (S_ISLNK(inode->i_mode) || S_ISREG(inode->i_mode)) &&\n210                     inode->i_ino != EXT4_JOURNAL_INO) {\n211                         journal_t *journal = EXT4_SB(inode->i_sb)->s_journal;\n212                         tid_t commit_tid = EXT4_I(inode)->i_datasync_tid;\n213 \n214                         jbd2_complete_transaction(journal, commit_tid);\n215                         filemap_write_and_wait(&inode->i_data);\n216                 }\n217                 truncate_inode_pages_final(&inode->i_data);\n218 \n219                 goto no_delete;\n220         }\n\n\nkernel/fs/ext4/inode.c:ext4_write_begin()\u306f\u3001\u5148\u306eext4_convert_inline_data_to_extent()\u3068\u540c\u3058\u3002\n\ninode\n1218         if (!ret && ext4_should_journal_data(inode)) {\n1219                 ret = ext4_walk_page_buffers(handle, page_buffers(page),\n1220                                              from, to, NULL,\n1221                                              do_journal_get_write_access);\n1222         }\n\n\nkernel/fs/ext4/inode.c:ext4_writepage()\u306f...\u3088\u304f\u308f\u304b\u3089\u306a\u3044\u300243ce1d23b\u3042\u305f\u308a\u3067\u5165\u3063\u305f\u3088\u3046\u306b\u898b\u3048\u308b\u3051\u3069\u3001\u3053\u308c\u4ee5\u524d\u306e\u5185\u5bb9\u3082\u591a\u304f\u3001history\u8ffd\u8de1\u3057\u3066\u3082\u3044\u307e\u3044\u3061\u610f\u56f3\u304c\u308f\u304b\u3089\u305a\u3002mmap\u3055\u308c\u3066\u3044\u308b\u5834\u5408\u306b\u4f55\u304b\u3057\u305f\u3044\u307f\u305f\u3044\u3002\n\ninode.c\n2049         if (PageChecked(page) && ext4_should_journal_data(inode))\n2050                 /*\n2051                  * It's mmapped pagecache.  Add buffers and journal it.  There\n2052                  * doesn't seem much point in redirtying the page here.\n2053                  */\n2054                 return __ext4_journalled_writepage(page, len);\n\n\nkernel/fs/ext4/inode.c:ext4_writepages()\u306f\u3001\u9045\u5ef6\u30a2\u30ed\u30b1\u30fc\u30b7\u30e7\u30f3\u3058\u3083\u306a\u3044\u3068\u3044\u3046\u6c7a\u3081\u6253\u3061\u3067\u7c21\u6613\u30b3\u30fc\u30c9\u306b\u5206\u5c90\u3055\u305b\u3066\u3044\u308b\u307f\u305f\u3044\u3002\n\ninode.c\n2619         if (ext4_should_journal_data(inode)) {\n2620                 struct blk_plug plug;\n2621 \n2622                 blk_start_plug(&plug);\n2623                 ret = write_cache_pages(mapping, wbc, __writepage, mapping);\n2624                 blk_finish_plug(&plug);\n2625                 goto out_writepages;\n2626         }\n\n\nkernel/fs/ext4/inode.c:ext4_direct_IO()\u306f\u3001data=journal\u3060\u3068O_DIRECT\u30e2\u30fc\u30c9\u306f\u4f7f\u3048\u306a\u3044\u3002\n\ninode.c\n3447         /*\n3448          * If we are doing data journalling we don't support O_DIRECT\n3449          */\n3450         if (ext4_should_journal_data(inode))\n3451                 return 0;\n\n\nkernel/fs/ext4/inode.c:_ext4_block_zeropage_range()\u306f\u3001\u5148\u306eext4_convert_inline_data_to_extent()\u3068\u540c\u3058\u3002\n\ninode.c\n3619         if (ext4_should_journal_data(inode)) {\n3620                 BUFFER_TRACE(bh, \"get write access\");\n3621                 err = ext4_journal_get_write_access(handle, bh);\n3622                 if (err)\n3623                         goto unlock;\n3624         }\n3625         zero_user(page, offset, length);\n3626         BUFFER_TRACE(bh, \"zeroed end of block\");\n3627 \n3628         if (ext4_should_journal_data(inode)) {\n3629                 err = ext4_handle_dirty_metadata(handle, inode, bh);\n3630         } else {\n3631                 err = 0;\n3632                 mark_buffer_dirty(bh);\n3633                 if (ext4_test_inode_state(inode, EXT4_STATE_ORDERED_MODE))\n3634                         err = ext4_jbd2_file_inode(handle, inode);\n3635         }\n\n\nkernel/fs/ext4/inode.c:ext4_setattr()\u306f\u3001inode\u304c\u6d88\u3055\u308c\u304b\u3051\u306e\u6642\u306bIO\u5f85\u3061\u3092\u3057\u3066\u3044\u308b\u3002\u5148\u306b\u3042\u3063\u305f\u306e\u3068\u540c\u3058\u304f\u3001data=journal\u3060\u3068\u30c7\u30fc\u30bf\u3060\u3051\u3058\u3083\u306a\u304fjournal\u3082\u66f8\u304d\u51fa\u3055\u306a\u3044\u3068\u3044\u3051\u306a\u3044\u3002\n\ninode.c\n5054                 /*\n5055                  * Blocks are going to be removed from the inode. Wait\n5056                  * for dio in flight.  Temporarily disable\n5057                  * dioread_nolock to prevent livelock.\n5058                  */\n5059                 if (orphan) {\n5060                         if (!ext4_should_journal_data(inode)) {\n5061                                 ext4_inode_block_unlocked_dio(inode);\n5062                                 inode_dio_wait(inode);\n5063                                 ext4_inode_resume_unlocked_dio(inode);\n5064                         } else\n5065                                 ext4_wait_for_tail_page_commit(inode);\n5066                 }\n\n\nkernel/fs/ext4/inode.c:ext4_writepage_trans_blocks()\u306f\u3001\u66f8\u304d\u8fbc\u307f\u4e88\u7d04\u30da\u30fc\u30b8\u6570\u3092\u8fd4\u3059\u305f\u3081\u306b\u3001journal\u306b\u66f8\u304b\u308c\u308b\u30c7\u30fc\u30bf\u306e\u5206\u3082\u8a08\u4e0a\u3057\u3066\u3044\u308b\u3002\n\ninode.c\n5189 /*\n5190  * Calculate the total number of credits to reserve to fit\n5191  * the modification of a single pages into a single transaction,\n5192  * which may include multiple chunks of block allocations.\n5193  *\n5194  * This could be called via ext4_write_begin()\n5195  *\n5196  * We need to consider the worse case, when\n5197  * one new block per extent.\n5198  */\n5199 int ext4_writepage_trans_blocks(struct inode *inode)\n5200 {\n5201         int bpp = ext4_journal_blocks_per_page(inode);\n5202         int ret;\n5203 \n5204         ret = ext4_meta_trans_blocks(inode, bpp, bpp);\n5205 \n5206         /* Account for data blocks for journalled mode */\n5207         if (ext4_should_journal_data(inode))\n5208                 ret += bpp;\n5209         return ret;\n5210 }\n\n\nkernel/fs/ext4/inode.c:ext4_page_mkwrite()\u306e\u5148\u306b\u3042\u308b\u65b9\u306f...\u3088\u304f\u308f\u304b\u3089\u306a\u3044\u3002ext4_page_mkwrite()\u306fDocumentation\u306eLocking\u306b\u3088\u308b\u3068\u3001read-only\u304b\u3089writable\u306b\u5909\u308f\u308b\u3068\u304d\u306b\u547c\u3070\u308c\u308b\u30a8\u30f3\u30c8\u30ea\u95a2\u6570\u3089\u3057\u3044...\n\ninode.c\n5526         /* Delalloc case is easy... */\n5527         if (test_opt(inode->i_sb, DELALLOC) &&\n5528             !ext4_should_journal_data(inode) &&\n5529             !ext4_nonda_switch(inode->i_sb)) {\n5530                 do {\n5531                         ret = block_page_mkwrite(vma, vmf,\n5532                                                    ext4_da_get_block_prep);\n5533                 } while (ret == -ENOSPC &&\n5534                        ext4_should_retry_alloc(inode->i_sb, &retries));\n5535                 goto out_ret;\n5536         }\n\n\n555         ->page_mkwrite() is called when a previously read-only pte is\n556 about to become writeable. The filesystem again must ensure that there are\n557 no truncate/invalidate races, and then return with the page locked. If\n558 the page has been truncated, the filesystem should not look up a new page\n559 like the ->fault() handler, but simply return with VM_FAULT_NOPAGE, which\n560 will cause the VM to retry the fault.\n561 \n562         ->pfn_mkwrite() is the same as page_mkwrite but when the pte is\n563 VM_PFNMAP or VM_MIXEDMAP with a page-less entry. Expected return is\n564 VM_FAULT_NOPAGE. Or one of the VM_FAULT_ERROR types. The default behavior\n565 after this call is to make the pte read-write, unless pfn_mkwrite returns\n566 an error.\n\nkernel/fs/ext4/inode.c:ext4_page_mkwrite()\u306e\u5f8c\u306b\u3042\u308b\u65b9\u306f\u3001\u5148\u306eext4_convert_inline_data_to_extent()\u3068\u540c\u3058\u3002\n\ninode.c\n5579         if (!ret && ext4_should_journal_data(inode)) {\n5580                 if (ext4_walk_page_buffers(handle, page_buffers(page), 0,\n5581                           PAGE_SIZE, NULL, do_journal_get_write_access)) {\n5582                         unlock_page(page);\n5583                         ret = VM_FAULT_SIGBUS;\n5584                         ext4_journal_stop(handle);\n5585                         goto out;\n5586                 }\n5587                 ext4_set_inode_state(inode, EXT4_STATE_JDATA);\n5588         }\n\n\nkernel/fs/ext4/ext4_jbd2.c:__ext4_forget()\u306f\u3001data=journal\u306e\u5834\u5408\u306frevoke\u3067\u306f\u306a\u304fforget\u3092\u547c\u3076\u3088\u3046\u306b\u3057\u3066\u3044\u308b\u3002\n\next4_jbd2.c\n206         /* Never use the revoke function if we are doing full data\n207          * journaling: there is no need to, and a V1 superblock won't\n208          * support it.  Otherwise, only skip the revoke on un-journaled\n209          * data blocks. */\n210 \n211         if (test_opt(inode->i_sb, DATA_FLAGS) == EXT4_MOUNT_JOURNAL_DATA ||\n212             (!is_metadata && !ext4_should_journal_data(inode))) {\n213                 if (bh) {\n214                         BUFFER_TRACE(bh, \"call jbd2_journal_forget\");\n215                         err = jbd2_journal_forget(handle, bh);\n216                         if (err)\n217                                 ext4_journal_abort_handle(where, line, __func__,\n218                                                           bh, handle, err);\n219                         return err;\n220                 }\n221                 return 0;\n222         }\n\n\nkernel/fs/ext4/extents.c:get_default_free_blocks_flags()\u306f\u3001\u30c7\u30d5\u30a9\u30eb\u30c8EXT4_FREE_BLOCKS_FORGET\u306b\u3057\u3066\u3001\u5148\u306eext4_clear_blocks()\u306e\u5834\u5408\u3078\u3068\u3064\u306a\u304c\u308b\u3002\n\nextentc.c\n2483 static inline int get_default_free_blocks_flags(struct inode *inode)\n2484 {\n2485         if (S_ISDIR(inode->i_mode) || S_ISLNK(inode->i_mode))\n2486                 return EXT4_FREE_BLOCKS_METADATA | EXT4_FREE_BLOCKS_FORGET;\n2487         else if (ext4_should_journal_data(inode))\n2488                 return EXT4_FREE_BLOCKS_FORGET;\n2489         return 0;\n2490 }\n\n\nkernel/fs/ext4/extents.c:ext4_zero_range()\u306e1\u3064\u3081\u306f\u3001ext4_force_commit()\u3092\u547c\u3076\u3053\u3068\u3067\u3001\u73fe\u5728\u3042\u308b\u30c8\u30e9\u30f3\u30b6\u30af\u30b7\u30e7\u30f3\u3092\u5f37\u5236\u7684\u306bcommit\u3057\u3066\u305d\u308c\u304c\u7d42\u308f\u308b\u307e\u3067\u5f85\u3064\u3002\n\nextents.c\n5632         /* Call ext4_force_commit to flush all data in case of data=journal */\n5633         if (ext4_should_journal_data(inode)) {\n5634                 ret = ext4_force_commit(inode->i_sb);\n5635                 if (ret)\n5636                         return ret;\n5637         }\n\n\nkernel/fs/ext4/extents.c:ext4_zero_range()\u306e2\u3064\u3081\u306f\u3001journal\u8a18\u9332\u306b\u5fc5\u8981\u306a\u30d6\u30ed\u30c3\u30af\u6570\u306e\u8a08\u7b97\u3002\n\nextents.c\n4866         /*\n4867          * In worst case we have to writeout two nonadjacent unwritten\n4868          * blocks and update the inode\n4869          */\n4870         credits = (2 * ext4_ext_index_trans_blocks(inode, 2)) + 1;\n4871         if (ext4_should_journal_data(inode))\n4872                 credits += 2;\n4873         handle = ext4_journal_start(inode, EXT4_HT_MISC, credits);\n\n\nkernel/fs/ext4/extents.c:ext4_collapse_range()\u306f\u3001\u5148\u3068\u540c\u3058\u304fext4_force_commit()\u3092\u547c\u3093\u3067\u3044\u308b\u3002\n\nextents.c\n5486         /* Call ext4_force_commit to flush all data in case of data=journal. */\n5487         if (ext4_should_journal_data(inode)) {\n5488                 ret = ext4_force_commit(inode->i_sb);\n5489                 if (ret)\n5490                         return ret;\n5491         }\n\n\nkernel/fs/ext4/extents.c:ext4_insert_range()\u306f\u3001\u5148\u3068\u540c\u3058\u304fext4_force_commit()\u3092\u547c\u3093\u3067\u3044\u308b\u3002\n\nextents.c\n5632         /* Call ext4_force_commit to flush all data in case of data=journal */\n5633         if (ext4_should_journal_data(inode)) {\n5634                 ret = ext4_force_commit(inode->i_sb);\n5635                 if (ret)\n5636                         return ret;\n5637         }\n\n\n...\u3084\u3063\u3068ext4_should_journal_data()\u306e\u5206\u304c\u7d42\u308f\u3063\u305f...\n\nmore study\ndebugfs\u306elogdump\u304c\u3001journal\u3092\u8aad\u3080\u624b\u52a9\u3051\u306b\u306a\u308b\u3002\n# debugfs /dev/sa1\ndebugfs 1.42.13 (17-May-2015)\ndebugfs: logdump\nJournal starts at block 1, transaction 21047\nFound expected sequence 21047, type 1 (descriptor block) at block 1\nFound expected sequence 21047, type 2 (commit block) at block 18\nFound expected sequence 21048, type 1 (descriptor block) at block 19\nFound expected sequence 21048, type 2 (commit block) at block 30\nFound expected sequence 21049, type 1 (descriptor block) at block 31\n(---snip---)\n\nsleuthkit\u306ejls\u304c\u3042\u308b\u3068\u3044\u3046\u60c5\u5831\u3082\u898b\u3064\u304b\u3063\u305f\u304c\u3001\u30c4\u30fc\u30eb\u304cext3\u4ee5\u6765\u30e1\u30f3\u30c6\u3055\u308c\u3066\u3044\u306a\u304f\u3066ext4\u306b\u5bfe\u5fdc\u3057\u3066\u306a\u3044\u3063\u307d\u304b\u3063\u305f\u3002\n\u3042\u3068\u306f\u3001kernel wiki \u306e ext4 Disk Layout\u306eJBD2\u95a2\u9023\u3092\u53c2\u8003\u306b\u3057\u306a\u304c\u3089\u30fb\u30fb\u30fb\u3068\u3044\u3046\u304b\u3001jbd2\u306edescriptor\u3092\u5b9a\u7fa9\u3059\u308bstruct\u306e\u30d8\u30c3\u30c0\u3068\u30d8\u30ad\u30b5\u30c0\u30f3\u30d7\u3068\u3092\u4e26\u3079\u3066\u306b\u3089\u3081\u3063\u3053\u3059\u308b\u3057\u304b\u306a\u3044\u6a21\u69d8\u3002\n\n\u3042\u3068\u304c\u304d\next4\u306ejournal\u306e\u30e2\u30fc\u30c9\u3068\u305d\u308c\u306b\u3088\u308b\u51e6\u7406\u306e\u6d41\u308c\u304c\u4e0a\u8a18\u306e\u3088\u3046\u306b\u3061\u3087\u3063\u3068\u306f\u308f\u304b\u3063\u305f\u6c17\u306b\u306a\u308c\u305f\u3002\u3051\u3069\u3001\u809d\u5fc3\u306ejournal\u306e\u4e2d\u8eab\u306f\u5168\u304f\u308f\u304b\u3089\u306a\u3044\u3002\u7d50\u5c40\u306e\u3068\u3053\u308d\u3001\u5b9f\u969b\u306ejournal\u3068\u3044\u3046\u304btransaction\u3068\u3044\u3046\u304b\u306e\u3042\u305f\u308a\u306f\u3001\u30d6\u30ed\u30c3\u30af\u3068\u3044\u3046\u304b\u30da\u30fc\u30b8\u3068\u3044\u3046\u304b\u306e\u5358\u4f4d\u3067jbd2\u4efb\u305b\u306b\u3057\u3066\u3044\u308b\u306e\u3067\u3001\u305d\u3063\u3061\u3082\u8aad\u307f\u3059\u3059\u3081\u306a\u3051\u308c\u3070\u3044\u3051\u306a\u3044\u3002\n\u307e\u305fjournal\u3068\u5bc6\u63a5\u306b\u95a2\u9023\u3059\u308b\u6a5f\u80fd\u3068\u3057\u3066\u3001metadata_csum\u3084journal_checksum\u306e\u30c1\u30a7\u30c3\u30af\u30b5\u30e0\u6a5f\u80fd\u3082\u3042\u308a\u3001\u30c7\u30fc\u30bf\u4fdd\u8b77\u306e\u89b3\u70b9\u3067\u306f\u3053\u308c\u3089\u3082\u304d\u3061\u3093\u3068\u8ffd\u308f\u306a\u3044\u3068\u3044\u3051\u306a\u3044\u3002\n\u79c1\u3082\u9806\u3092\u8ffd\u3063\u3066\u7406\u89e3\u3057\u3066\u3044\u304f\u3064\u3082\u308a\u3067\u3059\u3002REQ_FUA\u3068\u304bREQ_PREFLUSH\u3068\u304bREQ_META\u3068\u304bREQ_SYNC\u3068\u304b\u3002\u30fb\u30fb\u30fb\u3067\u3082\u305d\u306e\u8fba\u306fblock/writeback_cache_control.txt\u3092\u7406\u89e3\u3059\u308c\u3070\u3044\u3044\u3060\u3051\uff1f ...\u3068\u601d\u3063\u3066\u305f\u3089\u3001a2b809672(v4.10-rc1)\u304b\u3089\u30de\u30af\u30ed\u540d\u3068\u3044\u3046\u304b\u30dd\u30ea\u30b7\u30fc\u304c\u5909\u308f\u3063\u3066\u3044\u305f\u3002(WRITE_FUA\u2192REQ_FUA\u3068\u304b\u3002) \u305d\u3046\u3044\u3046\u306e\u306f\u30bd\u30fc\u30b9\u30b3\u30fc\u30c9\u8ffd\u3044\u3065\u3089\u304f\u306a\u308b\u304b\u3089\u30e4\u30e1\u30c6... \u8aa4\u89e3\u3067\u3057\u305f\u3001\u30de\u30af\u30ed\u306e\u610f\u5473\u3092\u53b3\u5bc6\u306b\u518d\u5b9a\u7fa9\u3057\u305f\u3060\u3051\u3067\u3001\u30de\u30af\u30ed\u540d\u3092\u7f6e\u304d\u63db\u3048\u305f\u308a\u307e\u3067\u306f\u3057\u3066\u307e\u305b\u3093\u3067\u3057\u305f\u3002\n# \u306f\u3058\u3081\u306b\next4\u306b\u3064\u3044\u3066\u306e\u8cc7\u6599\u306f\u30b0\u30b0\u308c\u3070\u307e\u3060\u63a2\u305b\u3070\u3042\u308b\u65b9\u3060\u3051\u3069\u3001\u3053\u3068journal\u306b\u3064\u3044\u3066\u306f\u3001mount\u30aa\u30d7\u30b7\u30e7\u30f3\u3068\u6982\u8981\u304f\u3089\u3044\u3057\u304b\u306a\u304f\u3066\u3001\u3064\u3063\u3053\u3093\u3060\u3053\u3068\u307e\u3067\u8aac\u660e\u3057\u305f\u8cc7\u6599\u304c\u7686\u7121\u306a\u72b6\u614b\u3002\u3068\u3044\u3046\u308f\u3051\u3067\u3001\u8a73\u7d30\u3092\u8ffd\u3046\u3053\u3068\u306b\u3057\u305f\u3002\u7121\u8336\u306a\u3053\u3068\u3057\u3084\u304c\u3063\u3066(AA\u7565\n\n\u306a\u304a\u3001Linux-4.6\u304f\u3089\u3044\u3092\u307f\u3066\u307e\u3059\u3002\n\n# Documentation\n\u6982\u8981\u3084\u3089mount\u30aa\u30d7\u30b7\u30e7\u30f3\u3084\u3089\u306b\u3064\u3044\u3066\u306f\u3001\u4e0b\u8a18\u306e\u3050\u305f\u3050\u305f\u3057\u305f\u6587\u7ae0\u3092\u8aad\u3080\u3088\u308a\u3082[kernel/Documentation/filesystems/ext4.txt](https://www.kernel.org/doc/Documentation/filesystems/ext4.txt)\u306e\u30c9\u30ad\u30e5\u30e1\u30f3\u30c8\u3092\u53c2\u7167\u3059\u308b\u65b9\u304c\u3088\u3044\u3002\n\n# jdb2\next4(\u307e\u305f\u306fext3)\u306ejournal\u306f\u6b63\u78ba\u306b\u306fext4\u306e\u4e00\u90e8\u3067\u306f\u306a\u304f\u3066**jbd2(Journaling block device 2)**\u3068\u3044\u3046\u30e2\u30b8\u30e5\u30fc\u30eb\u3068\u3057\u3066\u6c4e\u7528\u5316\u3055\u308c\u3066\u3044\u308b\u3002\u305f\u3060\u5b9f\u4f53\u306f\u3001ext4\u306f\u307e\u3060\u4ed6\u306ejournal\u306b\u8f09\u305b\u66ff\u3048\u308c\u305d\u3046\u306a\u8a2d\u8a08\u306b\u306a\u3063\u3066\u3044\u308b\u304c\u3001jdb2\u306f\u3082\u3046ext4\u5c02\u7528\u3068\u3044\u308f\u3056\u308b\u3092\u3048\u306a\u3044\u307b\u3069\u5bc6\u7d50\u5408\u3057\u3066\u3044\u308b\u3088\u3046\u306b\u8aad\u3081\u305f\u3002\n\next4\u3068\u3057\u3066\u306f\u591a\u304f\u306e\u5834\u5408journal\u306finode(\u3064\u307e\u308a\u666e\u901a\u306e\u30d5\u30a1\u30a4\u30eb)\u3068\u3057\u3066\u30b9\u30c8\u30ec\u30fc\u30b8\u306b\u4fdd\u5b58\u3059\u308b\u3002[kernel/fs/ext4.h](http://lxr.free-electrons.com/source/fs/ext4/ext4.h?v=4.6#L212)\u3088\u308a\u3001\n\n```c:ext4.h\n209 /*\n210  * Special inodes numbers\n211  */\n212 #define EXT4_BAD_INO             1      /* Bad blocks inode */\n213 #define EXT4_ROOT_INO            2      /* Root inode */\n214 #define EXT4_USR_QUOTA_INO       3      /* User quota inode */\n215 #define EXT4_GRP_QUOTA_INO       4      /* Group quota inode */\n216 #define EXT4_BOOT_LOADER_INO     5      /* Boot loader inode */\n217 #define EXT4_UNDEL_DIR_INO       6      /* Undelete directory inode */\n218 #define EXT4_RESIZE_INO          7      /* Reserved group descriptors inode */\n219 #define EXT4_JOURNAL_INO         8      /* Journal inode */\n```\n\n\u3068\u306a\u3063\u3066\u3044\u3066\u3001\u901a\u5e38\u306f**inode\u756a\u53f78**\u304c\u4f7f\u308f\u308c\u308b\u3002\u304c\u3001\u30b3\u30fc\u30c9\u3068\u3057\u3066\u306fsuerblock\u306b\u3042\u308bs_journal_inum\u306e\u3082\u306e\u304c\u4f7f\u308f\u308c\u308b\u306e\u3067\u3001\u53e4\u3044**e2fsprogs**\u3092\u4f7f\u3063\u305f\u3001\u904e\u53bb\u304b\u3089\u5f15\u304d\u3064\u3044\u3060\u306a\u3069\u306e\u7279\u6b8a\u306a\u5834\u5408\u306f\u3053\u306e\u9650\u308a\u3067\u306a\u3044\u6a21\u69d8\u3002\u3067\u3001\u3053\u306einode\u756a\u53f7\u306e\u3082\u306e\u306fmount/umount\u6642\u306b\u7279\u6b8a\u306b\u6271\u308f\u308c\u3001journal\u306e\u8aad\u307f\u66f8\u304d\u306b\u4f7f\u308f\u308c\u308b\u3002\n\njournal\u30d5\u30a1\u30a4\u30eb\u306f\u901a\u5e38**e2fsprogs**\u306e**mke2fs(mkfs.ext4)**\u3067\u4f5c\u3089\u308c\u308b\u3002[lib/ext2fs/mkjournal.c:**ext2fs_add_journal_inode2()**](https://github.com/tytso/e2fsprogs/blob/master/lib/ext2fs/mkjournal.c#L435)\u3088\u308a\u3001\n\n```c:mkjournal.c\n\t} else {\n\t\tif ((mount_flags & EXT2_MF_BUSY) &&\n\t\t    !(fs->flags & EXT2_FLAG_EXCLUSIVE)) {\n\t\t\tretval = EBUSY;\n\t\t\tgoto errout;\n\t\t}\n\t\tjournal_ino = EXT2_JOURNAL_INO;\n\t\tif ((retval = write_journal_inode(fs, journal_ino,\n\t\t\t\t\t\t  num_blocks, goal, flags)))\n\t\t\treturn retval;\n\t}\n```\nmount\u3055\u308c\u3066\u3044\u308b\u72b6\u614b\u304b\u3089\u4f5c\u308d\u3046\u3068\u3059\u308b\u3068\u3001**EXT2_IOC_SETFLAGS**\u3092\u4f7f\u3063\u3066**UF_NODUMP|UF_IMMUTABLE(immutable\u304b\u3064no dump)**\u30d5\u30e9\u30b0\u3092\u7acb\u3066\u308b\u304c\u3001mount\u3055\u308c\u3066\u3044\u306a\u304b\u3063\u305f\u3089\u4e0a\u8a18\u306e\u901a\u308a\u7279\u306b\u306a\u306b\u3082\u3057\u3066\u3044\u306a\u3044\u3002lookup\u3067\u304d\u306a\u3044(\u540d\u524d\u304b\u3089\u305f\u3069\u308c\u306a\u3044)inode\u3060\u304b\u3089\u7279\u306bIMMUTALBE\u306b\u3057\u306a\u304f\u3066\u3082\u3088\u3044\u3068\u3044\u3046\u3053\u3068\u306a\u3093\u3060\u308d\u3046\u304b\u3002\n\n```bash\n# debugfs /dev/sa1\ndebugfs 1.42.13 (17-May-2015)\ndebugfs: stat <8>\nInode: 8   Type: regular    Mode:  0600   Flags: 0x80000\nGeneration: 0    Version: 0x00000000:00000000\nUser:     0   Group:     0   Size: 134217728\nFile ACL: 0    Directory ACL: 0\nLinks: 1   Blockcount: 262144\nFragment:  Address: 0    Number: 0    Size: 0\n ctime: 0x5878dec7:00000000 -- Fri Jan 13 23:05:59 2017\n atime: 0x5878dec7:00000000 -- Fri Jan 13 23:05:59 2017\n mtime: 0x5878dec7:00000000 -- Fri Jan 13 23:05:59 2017\ncrtime: 0x5878dec7:00000000 -- Fri Jan 13 23:05:59 2017\nSize of extra inode fields: 28\nEXTENTS:\n(0-32766):2655233-2687999, (32767):2688000\n```\n\u624b\u5143\u3067inode\u756a\u53f78\u3092\u78ba\u8a8d\u3059\u308b\u3068\u3001flags: 0x80000 \u306a\u306e\u3067\u3001**EXT4_EXTENTS_FL\u306e\u307f**\u306e\u3088\u3046\u3060\u3063\u305f\u3002\n\n\n\u3061\u306a\u307f\u306b\u3001\u5916\u90e8journal\u3082\u30b5\u30dd\u30fc\u30c8\u3057\u3066\u3044\u3066\u3001**[mkfs.ext4 -J device=/dev/sda1](http://raid6.com.au/posts/fs_ext4_external_journal_caveats/)**\u3067\u4f5c\u308b\u3002\u305f\u3060\u3001\u30da\u30fc\u30b8\u306b\u3082\u66f8\u3044\u3066\u3042\u308b\u3068\u304a\u308a\u3001\u5916\u90e8\u30d6\u30ed\u30c3\u30af\u30c7\u30d0\u30a4\u30b9\u540d\u304c\u3044\u3064\u3082\u540c\u3058\u306b\u306a\u308b\u3068\u306f\u9650\u3089\u306a\u304b\u3063\u305f\u308a\u3059\u308b\u306e\u3067\u3001\u30aa\u30da\u30ec\u30fc\u30b7\u30e7\u30f3\u306b\u624b\u9593\u3092\u639b\u3051\u305f\u304f\u306a\u3044\u306a\u3089\u4f7f\u308f\u306a\u3044\u65b9\u304c\u3088\u3044\u3002\u307e\u305f**journal_async_commit**\u3067\u306a\u3044\u3068\u30c0\u30e1\u3068\u66f8\u304b\u308c\u3066\u3044\u3066\u3055\u3089\u306b\u4e0d\u5b89\u306b\u306a\u308b\u3002\u3069\u3046\u30c0\u30e1\u306a\u306e\u304b\u88cf\u4ed8\u3051\u3057\u305f\u304b\u3063\u305f\u3051\u3069\u3001kernel\u30bd\u30fc\u30b9\u7684\u306b\u306f\u7279\u306b\u305d\u308c\u3063\u307d\u3044\u306e\u306f\u898b\u3042\u305f\u3089\u306a\u304b\u3063\u305f\u3002\n\n# journal\u30e2\u30fc\u30c9\n3\u7a2e\u985e\u306e\u30e2\u30fc\u30c9\u304c\u3042\u308b\u3002default mount option(**HOGE_DEFM_HOGE**\u306e\u3084\u3064)\u3001\u3082\u3057\u304f\u306fmount\u30aa\u30d7\u30b7\u30e7\u30f3\u306b\u6307\u5b9a\u3059\u308b\u3002\u6307\u5b9a\u304c\u306a\u3044\u5834\u5408**data=ordered**\u306b\u306a\u308b\u3002\n\n- **data=writeback**\u3001metadata(\u30d5\u30a1\u30a4\u30eb\u30b5\u30a4\u30ba\u306a\u3069)\u3068\u30c7\u30fc\u30bf\u306e\u4e2d\u8eab\u306e\u66f8\u304d\u51fa\u3057\u9806\u304c\u4fdd\u969c\u3055\u308c\u306a\u3044\u3002\u30bb\u30ad\u30e5\u30ea\u30c6\u30a3\u9762\u3067\u3082\u3088\u304f\u306a\u3044\u3068\u30c9\u30ad\u30e5\u30e1\u30f3\u30c8\u306b\u66f8\u3044\u3066\u3042\u308a\u3001\u3088\u307b\u3069\u30d1\u30d5\u30a9\u30fc\u30de\u30f3\u30b9\u3092\u6c17\u306b\u3059\u308b\u5834\u9762\u4ee5\u5916\u3067\u306f\u3082\u3046\u4f7f\u308f\u306a\u3044\u3093\u3058\u3083\u306a\u3044\u304b\u3068\u601d\u3046\u3002 ~~\u305d\u306e\u30d1\u30d5\u30a9\u30fc\u30de\u30f3\u30b9\u3082\u3001\u624b\u5143\u3067\u30c6\u30b9\u30c8\u3057\u3066\u307f\u305f\u9650\u308a**data=ordered**\u3068\u6709\u610f\u306a\u5dee\u304c\u306a\u304b\u3063\u305f\u3002~~ **data=writeback**\u3060\u3068\u5dee\u304c\u308f\u304b\u308b\u7a0b\u5ea6\u306b\u306f\u5c11\u3057\u65e9\u304b\u3063\u305f\u3002\u305f\u3060**data=journal**\u306f\u3055\u3059\u304c\u306b\u9045\u304b\u3063\u305f\u3002\n- **data=ordered**\u3001meta\u30c7\u30fc\u30bf\u3068\u30c7\u30fc\u30bf\u306e\u4e2d\u8eab\u306e\u66f8\u304d\u51fa\u3057\u9806\u304c\u4fdd\u969c\u3055\u308c\u308b\u3002\u6a19\u6e96\u306e\u30e2\u30fc\u30c9\u3002\n- **data=journal**\u3001\u30c7\u30fc\u30bf\u306e\u4e2d\u8eab\u3082\u4e00\u5ea6journal\u306b\u66f8\u304d\u51fa\u3057\u3066\u304b\u3089\u5b9f\u969b\u306e\u66f8\u304d\u8fbc\u307f\u304c\u884c\u308f\u308c\u308b\u3002\u3082\u3046journal\u3068\u3044\u3046\u3088\u308atransaction\u3068\u3044\u3063\u305f\u65b9\u304c\u3044\u3044\u304b\u3082\u3057\u308c\u306a\u3044\u3002\n\n\u305f\u3060\u3001ext4\u304c\u5897\u7bc9\u3067\u6a5f\u80fd\u304c\u5897\u3048\u3066\u304d\u305f\u7d4c\u7def\u3082\u3042\u3063\u3066\u304b\u3001journal\u30e2\u30fc\u30c9\u306b\u3088\u3063\u3066\u4f7f\u3048\u308b\u6a5f\u80fd\u306b\u5236\u9650\u304c\u304b\u304b\u308b\u3053\u3068\u304c\u591a\u3044\u3002\u3064\u307e\u307f\u98df\u3044\u7a0b\u5ea6\u306b\u4e0b\u8a18\u306b\u5177\u4f53\u4f8b\u3092\u3002\n\n[kernel/fs/ext4/super.c:ext4_fill_super()](http://lxr.free-electrons.com/source/fs/ext4/super.c?v=4.6#L3335)\u3088\u308a\u3001**data=journal\u3060\u3068DELALLOC\u306f\u7121\u52b9**\u306b\u306a\u308b\u3002\u3055\u304b\u306e\u307c\u308b\u9650\u308a\u3001[dd919b982](https://lkml.org/lkml/2008/7/5/176)\u3001\u3064\u307e\u308aDEALLOC\u5f53\u521d\u304b\u3089\u306e\u6a21\u69d8\u3002\u5b9f\u88c5\u304c\u96e3\u3057\u304f\u306a\u308b(\u4ed6\u306ejournal\u30e2\u30fc\u30c9\u3068\u306f\u5225\u306epath\u306b\u306a\u308b)\u304b\u3089\u3058\u3083\u306a\u3044\u304b\u3068\u601d\u308f\u308c\u308b\u3002\n\n```c:super.c\n3335         if (test_opt(sb, DATA_FLAGS) == EXT4_MOUNT_JOURNAL_DATA) {\n3336                 printk_once(KERN_WARNING \"EXT4-fs: Warning: mounting \"\n3337                             \"with data=journal disables delayed \"\n3338                             \"allocation and O_DIRECT support!\\n\");\n3339                 if (test_opt2(sb, EXPLICIT_DELALLOC)) {\n3340                         ext4_msg(sb, KERN_ERR, \"can't mount with \"\n3341                                  \"both data=journal and delalloc\");\n3342                         goto failed_mount;\n3343                 }\n3344                 if (test_opt(sb, DIOREAD_NOLOCK)) {\n3345                         ext4_msg(sb, KERN_ERR, \"can't mount with \"\n3346                                  \"both data=journal and dioread_nolock\");\n3347                         goto failed_mount;\n3348                 }\n3349                 if (test_opt(sb, DAX)) {\n3350                         ext4_msg(sb, KERN_ERR, \"can't mount with \"\n3351                                  \"both data=journal and dax\");\n3352                         goto failed_mount;\n3353                 }\n3354                 if (test_opt(sb, DELALLOC))\n3355                         clear_opt(sb, DELALLOC);\n3356         } else {\n3357                 sb->s_iflags |= SB_I_CGROUPWB;\n3358         }\n```\n\n[kernel/fs/ext4/super.c:parse_options()](http://lxr.free-electrons.com/source/fs/ext4/super.c?v=4.6#L1794)\u3088\u308a\u3001**data=ordered\u3060\u3068journal_async_commit\u306f\u4f7f\u3048\u306a\u3044**\u3002[d4f761074](https://patchwork.ozlabs.org/patch/414750/)\u3067\u5165\u3063\u305f\u3002\n\n```c:super.c\n1794         if (test_opt(sb, DATA_FLAGS) == EXT4_MOUNT_ORDERED_DATA &&\n1795             test_opt(sb, JOURNAL_ASYNC_COMMIT)) {\n1796                 ext4_msg(sb, KERN_ERR, \"can't mount with journal_async_commit \"\n1797                          \"in data=ordered mode\");\n1798                 return 0;\n1799         }\n```\n\n[kernel/fs/ext4/super.c:ext4_mount_opts[]](http://lxr.free-electrons.com/source/fs/ext4/super.c?v=4.6#L1420)\u3088\u308a\u3001**journal_async_commit\u3060\u3068journal_checksum**\u3082\u7acb\u3064\u3002\n\n```c:super.c\n1420         {Opt_journal_async_commit, (EXT4_MOUNT_JOURNAL_ASYNC_COMMIT |\n1421                                     EXT4_MOUNT_JOURNAL_CHECKSUM),\n```\n\u304c\u3001[kernel/fs/ext4/super.c:set_journal_csum_feature_set()](http://lxr.free-electrons.com/source/fs/ext4/super.c?v=4.6#L2981)\u306b\u3088\u308b\u3068\u3001**JOURNAL_ASYNC_COMMIT**\u304c\u7acb\u3063\u3066\u3044\u308b\u3068\u304d\u306f**JOURNAL_CHECKSUM**\u306f\u610f\u5473\u3092\u306a\u3057\u3066\u3044\u306a\u3044\u3088\u3046\u306b\u898b\u3048\u308b\u3002\u4ed6\u306bJOURNAL_CHECKSUM\u3092\u53c2\u7167\u3057\u3066\u3044\u308b\u7b87\u6240\u3082\u306a\u304f\u3001jbd2\u306e\u4e2d\u3067**async_commit**\u304c\u7acb\u3063\u3066\u3044\u308b\u3068**checksum**\u3082\u52d5\u304f\u3001\u3068\u304b\u3044\u3046\u98a8\u306b\u3082\u898b\u3048\u305a\u3001\u4f55\u306e\u305f\u3081\u306a\u306e\u304b\u308f\u304b\u3089\u306a\u304b\u3063\u305f\u3002\n\n```c:super.c\n2981         if (test_opt(sb, JOURNAL_ASYNC_COMMIT)) {\n2982                 ret = jbd2_journal_set_features(sbi->s_journal,\n2983                                 compat, 0,\n2984                                 JBD2_FEATURE_INCOMPAT_ASYNC_COMMIT |\n2985                                 incompat);\n2986         } else if (test_opt(sb, JOURNAL_CHECKSUM)) {\n2987                 ret = jbd2_journal_set_features(sbi->s_journal,\n2988                                 compat, 0,\n2989                                 incompat);\n2990                 jbd2_journal_clear_features(sbi->s_journal, 0, 0,\n2991                                 JBD2_FEATURE_INCOMPAT_ASYNC_COMMIT);\n2992         } else {\n2993                 jbd2_journal_clear_features(sbi->s_journal, 0, 0,\n2994                                 JBD2_FEATURE_INCOMPAT_ASYNC_COMMIT);\n2995         }\n```\n\n[kernel/fs/ext4/super.c:ext4_fill_super()](http://lxr.free-electrons.com/source/fs/ext4/super.c?v=4.6#L3736)\u3088\u308a\u3001**journal\u306a\u3057\u3060\u3068journal_async_commit\u306f\u4f7f\u3048\u306a\u3044**\u3002\u30fb\u30fb\u30fb\u306f\u3055\u3059\u304c\u306b\u81ea\u660e\u304b\u3002\n\n```c:super.c\n3736                 if (test_opt(sb, JOURNAL_ASYNC_COMMIT)) {\n3737                         ext4_msg(sb, KERN_ERR, \"can't mount with \"\n3738                                  \"journal_async_commit, fs mounted w/o journal\");\n3739                         goto failed_mount_wq;\n3740                 }\n```\n\n# \u30b3\u30fc\u30c9\u3092\u8aad\u3080\n## \u30aa\u30d7\u30b7\u30e7\u30f3\u306e\u89e3\u91c8\n[kernel/fs/ext4/super.c\u306etokens\u3068ext4_mount_opts](http://lxr.free-electrons.com/source/fs/ext4/super.c?v=4.6#L1233)\u3088\u308a\u3001\n\n```c:super.c\n1233         {Opt_data_journal, \"data=journal\"},\n1234         {Opt_data_ordered, \"data=ordered\"},\n1235         {Opt_data_writeback, \"data=writeback\"},\n```\n```c:super.c\n1448         {Opt_data_journal, EXT4_MOUNT_JOURNAL_DATA, MOPT_NO_EXT2 | MOPT_DATAJ},\n1449         {Opt_data_ordered, EXT4_MOUNT_ORDERED_DATA, MOPT_NO_EXT2 | MOPT_DATAJ},\n1450         {Opt_data_writeback, EXT4_MOUNT_WRITEBACK_DATA,\n1451          MOPT_NO_EXT2 | MOPT_DATAJ},\n```\n**data=writeback**\u306e\u5834\u5408\u306f**EXT4_MOUNT_WRITEBACK_DATA**\u304c\u3001**data=ordered**\u306e\u5834\u5408\u306f**EXT4_MOUNT_ORDERED_DATA**\u304c\u3001**data=journal**\u306e\u5834\u5408\u306f**EXT4_MOUNT_JOURNAL_DATA**\u304c\u3001\u305d\u308c\u305e\u308c\u7acb\u3064\u3002\n\njournal\u306e\u8aad\u307f\u8fbc\u307f\u3082\u307e\u305f[kernel/fs/ext4/super.c:ext4_fill_super()](http://lxr.free-electrons.com/source/fs/ext4/super.c?v=4.6#L3717)\u3067\u884c\u308f\u308c\u308b\u3002\n\n```c:super.c\n3717         /*\n3718          * The first inode we look at is the journal inode.  Don't try\n3719          * root first: it may be modified in the journal!\n3720          */\n3721         if (!test_opt(sb, NOLOAD) && ext4_has_feature_journal(sb)) {\n3722                 if (ext4_load_journal(sb, es, journal_devnum))\n3723                         goto failed_mount3a;\n3724         } else if (test_opt(sb, NOLOAD) && !(sb->s_flags & MS_RDONLY) &&\n3725                    ext4_has_feature_journal_needs_recovery(sb)) {\n3726                 ext4_msg(sb, KERN_ERR, \"required journal recovery \"\n3727                        \"suppressed and not mounted read-only\");\n3728                 goto failed_mount_wq;\n3729         } else {\n3730                 /* Nojournal mode, all journal mount options are illegal */\n3731                 if (test_opt2(sb, EXPLICIT_JOURNAL_CHECKSUM)) {\n3732                         ext4_msg(sb, KERN_ERR, \"can't mount with \"\n3733                                  \"journal_checksum, fs mounted w/o journal\");\n3734                         goto failed_mount_wq;\n3735                 }\n3736                 if (test_opt(sb, JOURNAL_ASYNC_COMMIT)) {\n3737                         ext4_msg(sb, KERN_ERR, \"can't mount with \"\n3738                                  \"journal_async_commit, fs mounted w/o journal\");\n3739                         goto failed_mount_wq;\n3740                 }\n3741                 if (sbi->s_commit_interval != JBD2_DEFAULT_MAX_COMMIT_AGE*HZ) {\n3742                         ext4_msg(sb, KERN_ERR, \"can't mount with \"\n3743                                  \"commit=%lu, fs mounted w/o journal\",\n3744                                  sbi->s_commit_interval / HZ);\n3745                         goto failed_mount_wq;\n3746                 }\n3747                 if (EXT4_MOUNT_DATA_FLAGS &\n3748                     (sbi->s_mount_opt ^ sbi->s_def_mount_opt)) {\n3749                         ext4_msg(sb, KERN_ERR, \"can't mount with \"\n3750                                  \"data=, fs mounted w/o journal\");\n3751                         goto failed_mount_wq;\n3752                 }\n3753                 sbi->s_def_mount_opt &= EXT4_MOUNT_JOURNAL_CHECKSUM;\n3754                 clear_opt(sb, JOURNAL_CHECKSUM);\n3755                 clear_opt(sb, DATA_FLAGS);\n3756                 sbi->s_journal = NULL;\n3757                 needs_recovery = 0;\n3758                 goto no_journal;\n3759         }\n```\n- noload\u3058\u3083\u306a\u3044\u3001\u304b\u3064\u3001super\u30d6\u30ed\u30c3\u30af\u306bjournal\u30aa\u30d7\u30b7\u30e7\u30f3\u304c\u3042\u308b\u5834\u5408\u3001journal\u3092\u8aad\u307f\u306b\u3044\u3063\u3066\u30c0\u30e1\u306a\u3089mount\u30a8\u30e9\u30fc\n- noload\u3001\u304b\u3064\u3001readonly\u3058\u3083\u306a\u3044\u3001\u304b\u3064\u3001super\u30d6\u30ed\u30c3\u30af\u306brecovery\u30aa\u30d7\u30b7\u30e7\u30f3\u304c\u3042\u308b\u306a\u3089\u3001mount\u30a8\u30e9\u30fc\n- \u4e0a\u8a18\u3058\u3083\u306a\u3044\u5834\u5408\u3001journal\u306a\u3057\u30e2\u30fc\u30c9(**sbi->s_journal\u304cNULL**)\u3068\u306a\u3063\u3066\u5404\u7a2e\u30c1\u30a7\u30c3\u30af\u3092\u884c\u3046\u3002\n\n\u3068\u3044\u3046\u611f\u3058\u306b\u306a\u3063\u3066\u3044\u308b\u3002\n\n**EXT4_MOUNT_WRITEBACK_DATA**, **EXT4_MOUNT_ORDERED_DATA**, **EXT4_MOUNT_JOURNAL_DATA**\u306f\u3001\u5b9f\u8cea\u7684\u306b[kernel/fs/ext4/ext4_jbd2.h:ext4_inode_journal_mode()]()\u3067\u306e\u307f\u4f7f\u308f\u308c\u3066\u3044\u308b\n\n```c:ext4_jbd2.h\n392 static inline int ext4_inode_journal_mode(struct inode *inode)\n393 {\n394         if (EXT4_JOURNAL(inode) == NULL)\n395                 return EXT4_INODE_WRITEBACK_DATA_MODE;  /* writeback */\n396         /* We do not support data journalling with delayed allocation */\n397         if (!S_ISREG(inode->i_mode) ||\n398             test_opt(inode->i_sb, DATA_FLAGS) == EXT4_MOUNT_JOURNAL_DATA)\n399                 return EXT4_INODE_JOURNAL_DATA_MODE;    /* journal data */\n400         if (ext4_test_inode_flag(inode, EXT4_INODE_JOURNAL_DATA) &&\n401             !test_opt(inode->i_sb, DELALLOC))\n402                 return EXT4_INODE_JOURNAL_DATA_MODE;    /* journal data */\n403         if (test_opt(inode->i_sb, DATA_FLAGS) == EXT4_MOUNT_ORDERED_DATA)\n404                 return EXT4_INODE_ORDERED_DATA_MODE;    /* ordered */\n405         if (test_opt(inode->i_sb, DATA_FLAGS) == EXT4_MOUNT_WRITEBACK_DATA)\n406                 return EXT4_INODE_WRITEBACK_DATA_MODE;  /* writeback */\n407         else\n408                 BUG();\n409 }\n410 \n411 static inline int ext4_should_journal_data(struct inode *inode)\n412 {\n413         return ext4_inode_journal_mode(inode) & EXT4_INODE_JOURNAL_DATA_MODE;\n414 }\n415 \n416 static inline int ext4_should_order_data(struct inode *inode)\n417 {\n418         return ext4_inode_journal_mode(inode) & EXT4_INODE_ORDERED_DATA_MODE;\n419 }\n420 \n421 static inline int ext4_should_writeback_data(struct inode *inode)\n422 {\n423         return ext4_inode_journal_mode(inode) & EXT4_INODE_WRITEBACK_DATA_MODE;\n424 }\n```\ninode\u3054\u3068\u306b\u5224\u65ad\u3055\u308c\u308b\u3082\u306e\u306e\u3001\u7d50\u5c40\u3001**ext4_should_journal_data()**, **ext4_should_order_data()**, **ext4_should_writeback_data()**\u3092\u78ba\u8a8d\u3059\u308c\u3070\u3088\u3044\u3068\u306a\u308b\u3002...\u53b3\u5bc6\u306b\u8a00\u3046\u3068\u3001[kernel/fs/ext4/inode.c:ext4_set_aops()](http://lxr.free-electrons.com/source/fs/ext4/inode.c?v=4.6#L3533)\u3082\u3042\u308b\u3051\u3069\u3001\u3053\u3063\u3061\u306f\u3069\u3093\u3069\u3093\u8131\u7dda\u65b9\u5411\u306b\u306a\u308a\u305d\u3046\u3067\u3001\u4eca\u56de\u306f\u7701\u7565\u3059\u308b...\n\n```c:inode.c\n3533 void ext4_set_aops(struct inode *inode)\n3534 {\n3535         switch (ext4_inode_journal_mode(inode)) {\n3536         case EXT4_INODE_ORDERED_DATA_MODE:\n3537                 ext4_set_inode_state(inode, EXT4_STATE_ORDERED_MODE);\n3538                 break;\n3539         case EXT4_INODE_WRITEBACK_DATA_MODE:\n3540                 ext4_clear_inode_state(inode, EXT4_STATE_ORDERED_MODE);\n3541                 break;\n3542         case EXT4_INODE_JOURNAL_DATA_MODE:\n3543                 inode->i_mapping->a_ops = &ext4_journalled_aops;\n3544                 return;\n3545         default:\n3546                 BUG();\n3547         }\n3548         if (test_opt(inode->i_sb, DELALLOC))\n3549                 inode->i_mapping->a_ops = &ext4_da_aops;\n3550         else\n3551                 inode->i_mapping->a_ops = &ext4_aops;\n3552 }\n```\n\n## journal\u30e2\u30fc\u30c9\u306b\u3088\u308b\u9055\u3044\n## ext4_should_writeback_data()\n[kernel/fs/ext4/mballoc.c:**ext4_free_blocks()**](http://lxr.free-electrons.com/source/fs/ext4/mballoc.c?v=4.6#L4820)\u3067\u4f7f\u308f\u308c\u3066\u3044\u308b\u3002\n\n```c:mballoc.c\n4820         /*\n4821          * We need to make sure we don't reuse the freed block until after the\n4822          * transaction is committed. We make an exception if the inode is to be\n4823          * written in writeback mode since writeback mode has weak data\n4824          * consistency guarantees.\n4825          */\n4826         if (ext4_handle_valid(handle) &&\n4827             ((flags & EXT4_FREE_BLOCKS_METADATA) ||\n4828              !ext4_should_writeback_data(inode))) {\n4829                 struct ext4_free_data *new_entry;\n4830                 /*\n4831                  * We use __GFP_NOFAIL because ext4_free_blocks() is not allowed\n4832                  * to fail.\n4833                  */\n4834                 new_entry = kmem_cache_alloc(ext4_free_data_cachep,\n4835                                 GFP_NOFS|__GFP_NOFAIL);\n4836                 new_entry->efd_start_cluster = bit;\n4837                 new_entry->efd_group = block_group;\n4838                 new_entry->efd_count = count_clusters;\n4839                 new_entry->efd_tid = handle->h_transaction->t_tid;\n4840 \n4841                 ext4_lock_group(sb, block_group);\n4842                 mb_clear_bits(bitmap_bh->b_data, bit, count_clusters);\n4843                 ext4_mb_free_metadata(handle, &e4b, new_entry);\n4844         } else {\n4845                 /* need to update group_info->bb_free and bitmap\n4846                  * with group lock held. generate_buddy look at\n4847                  * them with group lock_held\n4848                  */\n4849                 if (test_opt(sb, DISCARD)) {\n4850                         err = ext4_issue_discard(sb, block_group, bit, count);\n4851                         if (err && err != -EOPNOTSUPP)\n4852                                 ext4_msg(sb, KERN_WARNING, \"discard request in\"\n4853                                          \" group:%d block:%d count:%lu failed\"\n4854                                          \" with %d\", block_group, bit, count,\n4855                                          err);\n4856                 } else\n4857                         EXT4_MB_GRP_CLEAR_TRIMMED(e4b.bd_info);\n4858 \n4859                 ext4_lock_group(sb, block_group);\n4860                 mb_clear_bits(bitmap_bh->b_data, bit, count_clusters);\n4861                 mb_free_blocks(inode, &e4b, bit, count_clusters);\n4862         }\n```\nfree(\u30d5\u30a1\u30a4\u30eb\u304c\u6d88\u3048\u308b\u30fb\u5c0f\u3055\u304f\u306a\u308b)\u6642\u306b\u3001metadata(\u30d5\u30a1\u30a4\u30eb\u30b5\u30a4\u30ba)\u306e\u5909\u66f4\u3068\u30c7\u30fc\u30bf\u306ebitmap\u5909\u66f4\u3068\u306e\u3069\u3061\u3089\u3092\u5148\u306b\u3059\u308b\u304b\u3001\u306e\u3088\u3046\u3060\u3002\n\n## ext4_should_order_data()\n2\u7b87\u6240\u3042\u308b\u3002\n\n1\u3064\u3081\u306f[kernel/fs/ext4/inode.c:**ext4_evict_inode()**](http://lxr.free-electrons.com/source/fs/ext4/inode.c?v=4.6#L226)\u3001\u30d5\u30a1\u30a4\u30eb\u3092\u6d88\u3059\u3068\u304d\u306b\u30d5\u30a1\u30a4\u30eb\u30b5\u30a4\u30ba\u3092\u5148\u306b\u30bc\u30ed\u306b\u3057\u3066\u3044\u308b\u3002\n\n```c:inode.c\n226         if (ext4_should_order_data(inode))\n227                 ext4_begin_ordered_truncate(inode, 0);\n```\n\n2\u3064\u3081\u306f\u3001[kernel/fs/ext4/inode.c:**ext4_setattr()**](http://lxr.free-electrons.com/source/fs/ext4/inode.c?v=4.6#L5006)\u3001\u30d5\u30a1\u30a4\u30eb\u30b5\u30a4\u30ba\u3092\u5c0f\u3055\u304f\u3059\u308b\u3068\u304d\u306b**ext4_begin_ordered_truncate()**\u3092\u547c\u3076\u3002\n\n```c:inode.c\n5006                 if (ext4_should_order_data(inode) &&\n5007                     (attr->ia_size < inode->i_size)) {\n5008                         error = ext4_begin_ordered_truncate(inode,\n5009                                                             attr->ia_size);\n5010                         if (error)\n5011                                 goto err_out;\n5012                 }\n```\n\n**[ext4_begin_ordered_truncate()](http://lxr.free-electrons.com/source/fs/ext4/inode.c?v=4.6#L115)**\u306f\u3001[kernel/fs/jbd2/transaction.c:**jbd2_journal_begin_ordered_truncate()**](http://lxr.free-electrons.com/source/fs/jbd2/transaction.c?v=4.6#L2546)\u3092\u547c\u3076\u3002\u7d50\u5c40\u306e\u3068\u3053\u308d\u3001journal\u304c\u307e\u3060commit\u3055\u308c\u3066\u3044\u306a\u304b\u3063\u305f\u3089**filemap_fdatawrite_range()**\u3092\u547c\u3076\u3002\u3053\u308c\u306f**WB_SYNC_ALL**\u3067**__filemap_fdatawrite_range()**\u3092\u547c\u3076\u3001\u3064\u307e\u308a\u66f8\u304d\u51fa\u3057\u5f85\u3061\u3092\u3059\u308b\u3002\n\n```c:transaction.c\n2565         if (inode_trans == commit_trans) {\n2566                 ret = filemap_fdatawrite_range(jinode->i_vfs_inode->i_mapping,\n2567                         new_size, LLONG_MAX);\n2568                 if (ret)\n2569                         jbd2_journal_abort(journal, ret);\n2570         }\n```\n\n## ext4_should_journal_data()\n\u305f\u304f\u3055\u3093\u3042\u3063\u3066\u9577\u3005\u3068\u306a\u3063\u3066\u3057\u307e\u3063\u3066\u3044\u308b\u306e\u3067\u3001\u6c17\u9577\u306b\u8aad\u3093\u3067...\n\n[kernel/fs/ext4/super.c:**ext4_quota_on()**](http://lxr.free-electrons.com/source/fs/ext4/inline.c?v=4.6#L5069)\u3067\u306f\u3001quota\u51e6\u7406\u3092\u958b\u59cb\u3059\u308b\u524d\u306b\u660e\u793a\u7684\u306bflush\u3057\u3066\u3044\u308b\u3002\u30b3\u30e1\u30f3\u30c8\u304b\u3089\u5bdf\u3059\u308b\u306b\u3001\u305f\u3076\u3093flush\u305b\u305a\u306bquota\u51e6\u7406\u3057\u3088\u3046\u3068\u3059\u308b\u3068\u8907\u96d1\u306b\u306a\u308b\u3093\u3060\u308d\u3046\u3002\n\n```c:super.c\n5069         /*\n5070          * When we journal data on quota file, we have to flush journal to see\n5071          * all updates to the file when we bypass pagecache...\n5072          */\n5073         if (EXT4_SB(sb)->s_journal &&\n5074             ext4_should_journal_data(d_inode(path->dentry))) {\n5075                 /*\n5076                  * We don't need to lock updates but journal_flush() could\n5077                  * otherwise be livelocked...\n5078                  */\n5079                 jbd2_journal_lock_updates(EXT4_SB(sb)->s_journal);\n5080                 err = jbd2_journal_flush(EXT4_SB(sb)->s_journal);\n5081                 jbd2_journal_unlock_updates(EXT4_SB(sb)->s_journal);\n5082                 if (err)\n5083                         return err;\n5084         }\n```\n\n[kernel/fs/ext4/inline.c:**ext4_convert_inline_data_to_extent()**](http://lxr.free-electrons.com/source/fs/ext4/inline.c?v=4.6#L590)\u306f\u3001\u3059\u3079\u3066\u306e\u30da\u30fc\u30b8\u3054\u3068\u306b**do_journal_get_write_access()**\u95a2\u6570\u3092\u547c\u3076\u3002[kernel/fs/ext4/inode.c:**do_journal_get_write_access()**](http://lxr.free-electrons.com/source/fs/ext4/inode.c?v=4.6#L1029)\u306f\u3001\u3044\u307e\u3044\u3061\u7406\u89e3\u3057\u304d\u308c\u306a\u3044\u3051\u3069\u3001dirty\u306a\u3089**ext4_handle_dirty_metadata()**\u3092\u547c\u3076\u3053\u3068\u3067\u66f8\u304d\u8fbc\u3080\u30bf\u30a4\u30df\u30f3\u30b0\u3092\u78ba\u5b9a\u3055\u305b\u3066\u3044\u308b\u3063\u307d\u3044\uff1f\n\n```c:inline.c\n590         if (!ret && ext4_should_journal_data(inode)) {\n591                 ret = ext4_walk_page_buffers(handle, page_buffers(page),\n592                                              from, to, NULL,\n593                                              do_journal_get_write_access);\n594         }\n```\n```c:inode\n1005 /*\n1006  * To preserve ordering, it is essential that the hole instantiation and\n1007  * the data write be encapsulated in a single transaction.  We cannot\n1008  * close off a transaction and start a new one between the ext4_get_block()\n1009  * and the commit_write().  So doing the jbd2_journal_start at the start of\n1010  * prepare_write() is the right place.\n1011  *\n1012  * Also, this function can nest inside ext4_writepage().  In that case, we\n1013  * *know* that ext4_writepage() has generated enough buffer credits to do the\n1014  * whole page.  So we won't block on the journal in that case, which is good,\n1015  * because the caller may be PF_MEMALLOC.\n1016  *\n1017  * By accident, ext4 can be reentered when a transaction is open via\n1018  * quota file writes.  If we were to commit the transaction while thus\n1019  * reentered, there can be a deadlock - we would be holding a quota\n1020  * lock, and the commit would never complete if another thread had a\n1021  * transaction open and was blocking on the quota lock - a ranking\n1022  * violation.\n1023  *\n1024  * So what we do is to rely on the fact that jbd2_journal_stop/journal_start\n1025  * will _not_ run commit under these circumstances because handle->h_ref\n1026  * is elevated.  We'll still have enough credits for the tiny quotafile\n1027  * write.\n1028  */\n1029 int do_journal_get_write_access(handle_t *handle,\n1030                                 struct buffer_head *bh)\n1031 {\n1032         int dirty = buffer_dirty(bh);\n1033         int ret;\n1034 \n1035         if (!buffer_mapped(bh) || buffer_freed(bh))\n1036                 return 0;\n1037         /*\n1038          * __block_write_begin() could have dirtied some buffers. Clean\n1039          * the dirty bit as jbd2_journal_get_write_access() could complain\n1040          * otherwise about fs integrity issues. Setting of the dirty bit\n1041          * by __block_write_begin() isn't a real problem here as we clear\n1042          * the bit before releasing a page lock and thus writeback cannot\n1043          * ever write the buffer.\n1044          */\n1045         if (dirty)\n1046                 clear_buffer_dirty(bh);\n1047         BUFFER_TRACE(bh, \"get write access\");\n1048         ret = ext4_journal_get_write_access(handle, bh);\n1049         if (!ret && dirty)\n1050                 ret = ext4_handle_dirty_metadata(handle, NULL, bh);\n1051         return ret;\n1052 }\n```\n\n[kernel/fs/ext4/indirect.c:**ext4_clear_blocks()**](http://lxr.free-electrons.com/source/fs/ext4/indirect.c?v=4.6#L961)\u306f\u3001**EXT4_FREE_BLOCKS_FORGET**\u3092\u7acb\u3066\u308b\u3053\u3068\u3067\u3001**ext4_free_blocks()**\u306e\u4e2d\u304b\u3089**ext4_forget()**\u3092\u547c\u3076\u3088\u3046\u306b\u3057\u3066\u3044\u308b\u3002**ext4_forget()**\u306f\u3001**data=journal**\u306e\u5834\u5408\u306fjbd2\u306eforget\u3092\u547c\u3076\u3001\u305d\u3046\u3067\u306a\u3044\u5834\u5408\u306fjbd2\u306erevoke\u3092\u547c\u3076\u3002\n\n```c:indirect.c\n959         if (S_ISDIR(inode->i_mode) || S_ISLNK(inode->i_mode))\n960                 flags |= EXT4_FREE_BLOCKS_FORGET | EXT4_FREE_BLOCKS_METADATA;\n961         else if (ext4_should_journal_data(inode))\n962                 flags |= EXT4_FREE_BLOCKS_FORGET;\n```\n\n[kernel/fs/ext4/fsync.c:**ext4_sync_file()**](http://lxr.free-electrons.com/source/fs/ext4/fsync.c?v=4.6#L132)\u306f\u3001[**fsync(2)**](https://linuxjm.osdn.jp/html/LDP_man-pages/man2/fsync.2.html)\u306f\u672c\u6765\u306a\u3089\u30c7\u30fc\u30bf\u3092\u66f8\u304d\u8fbc\u3080\u3068\u3053\u308d\u307e\u3067\u5f85\u3064\u3079\u304d\u3060\u304c\u3001**data=journal**\u30e2\u30fc\u30c9\u3060\u3068\u30c7\u30fc\u30bf\u306fjournal\u306b\u5148\u306b\u66f8\u304f\u306e\u3067\u3001journal\u3060\u3051\u66f8\u304d\u51fa\u305b\u3070\u3088\u3044\u3053\u3068\u306b\u306a\u308b\u3001\u304b\u3089\u305d\u3046\u3057\u3066\u3044\u308b\u3088\u3046\u3060\u3002\n\n```c:fsync.c\n118         /*\n119          * data=writeback,ordered:\n120          *  The caller's filemap_fdatawrite()/wait will sync the data.\n121          *  Metadata is in the journal, we wait for proper transaction to\n122          *  commit here.\n123          *\n124          * data=journal:\n125          *  filemap_fdatawrite won't do anything (the buffers are clean).\n126          *  ext4_force_commit will write the file data into the journal and\n127          *  will wait on that.\n128          *  filemap_fdatawait() will encounter a ton of newly-dirtied pages\n129          *  (they were dirtied by commit).  But that's OK - the blocks are\n130          *  safe in-journal, which is all fsync() needs to ensure.\n131          */\n132         if (ext4_should_journal_data(inode)) {\n133                 ret = ext4_force_commit(inode->i_sb);\n134                 goto out;\n135         }\n```\n\n[kernel/fs/ext4/move_extent.c:**ext4_move_extents()**](http://lxr.free-electrons.com/source/fs/ext4/move_extent.c?v=4.6#L594)\u306f\u3001**data=journal**\u3060\u3068online defrag\u304c\u3067\u304d\u306a\u3044\u307f\u305f\u3044\u3002\u305f\u3060\u73fe\u6642\u70b9(2017/02/08)\u3067\u3082\u307e\u3060TODO:\u306e\u307e\u307e\u3060\u3063\u305f\u3002\u3050\u306c\u306c...\u3061\u306a\u307f\u306b**online defrag**\u3066\u3044\u3046\u306e\u306f**e2fsprogs**\u306b\u542b\u307e\u308c\u308b**e4defrag(8)**\u3068\u3044\u3046\u30c4\u30fc\u30eb\u306e\u3053\u3068\u307f\u305f\u3044\u3002ioctl\u306e**EXT4_IOC_MOVE_EXT**\u3067\u3067\u304d\u308b\u307f\u305f\u3044\u3002\n\n```c:move_extent.c\n592         /* TODO: it's not obvious how to swap blocks for inodes with full\n593            journaling enabled */\n594         if (ext4_should_journal_data(orig_inode) ||\n595             ext4_should_journal_data(donor_inode)) {\n596                 ext4_msg(orig_inode->i_sb, KERN_ERR,\n597                          \"Online defrag not supported with data journaling\");\n598                 return -EOPNOTSUPP;\n599         }\n```\n\n[kernel/fs/ext4/inode.c:**ext4_evict_inode()**](http://lxr.free-electrons.com/source/fs/ext4/inode.c?v=4.6#L189)\u306f\u3001\n\u6d88\u305d\u3046\u3068\u3057\u3066\u3044\u308b\u30d5\u30a1\u30a4\u30eb\u306fVFS\u7684\u306bclean\u3068\u5224\u65ad\u3055\u308c\u308b\u3051\u3069journal\u7684\u306b\u306f\u6b8b\u3063\u3066\u3044\u308b\u306e\u3067\u3001\u305d\u308c\u3092\u30b1\u30a2\u3057\u306a\u3044\u3068\u3044\u3051\u306a\u3044\u307f\u305f\u3044\uff1f\n\n```c:inode.c\n189         if (inode->i_nlink) {\n190                 /*\n191                  * When journalling data dirty buffers are tracked only in the\n192                  * journal. So although mm thinks everything is clean and\n193                  * ready for reaping the inode might still have some pages to\n194                  * write in the running transaction or waiting to be\n195                  * checkpointed. Thus calling jbd2_journal_invalidatepage()\n196                  * (via truncate_inode_pages()) to discard these buffers can\n197                  * cause data loss. Also even if we did not discard these\n198                  * buffers, we would have no way to find them after the inode\n199                  * is reaped and thus user could see stale data if he tries to\n200                  * read them before the transaction is checkpointed. So be\n201                  * careful and force everything to disk here... We use\n202                  * ei->i_datasync_tid to store the newest transaction\n203                  * containing inode's data.\n204                  *\n205                  * Note that directories do not have this problem because they\n206                  * don't use page cache.\n207                  */\n208                 if (ext4_should_journal_data(inode) &&\n209                     (S_ISLNK(inode->i_mode) || S_ISREG(inode->i_mode)) &&\n210                     inode->i_ino != EXT4_JOURNAL_INO) {\n211                         journal_t *journal = EXT4_SB(inode->i_sb)->s_journal;\n212                         tid_t commit_tid = EXT4_I(inode)->i_datasync_tid;\n213 \n214                         jbd2_complete_transaction(journal, commit_tid);\n215                         filemap_write_and_wait(&inode->i_data);\n216                 }\n217                 truncate_inode_pages_final(&inode->i_data);\n218 \n219                 goto no_delete;\n220         }\n```\n\n[kernel/fs/ext4/inode.c:**ext4_write_begin()**](http://lxr.free-electrons.com/source/fs/ext4/inode.c?v=4.6#L1218)\u306f\u3001\u5148\u306e**ext4_convert_inline_data_to_extent()**\u3068\u540c\u3058\u3002\n\n```c:inode\n1218         if (!ret && ext4_should_journal_data(inode)) {\n1219                 ret = ext4_walk_page_buffers(handle, page_buffers(page),\n1220                                              from, to, NULL,\n1221                                              do_journal_get_write_access);\n1222         }\n```\n\n[kernel/fs/ext4/inode.c:**ext4_writepage()**](http://lxr.free-electrons.com/source/fs/ext4/inode.c?v=4.6#L2049)\u306f...\u3088\u304f\u308f\u304b\u3089\u306a\u3044\u3002[43ce1d23b](https://lab.nexedi.cn/kirr/linux/commit/43ce1d23b43330634507a049b55c36e91d27282e)\u3042\u305f\u308a\u3067\u5165\u3063\u305f\u3088\u3046\u306b\u898b\u3048\u308b\u3051\u3069\u3001\u3053\u308c\u4ee5\u524d\u306e\u5185\u5bb9\u3082\u591a\u304f\u3001history\u8ffd\u8de1\u3057\u3066\u3082\u3044\u307e\u3044\u3061\u610f\u56f3\u304c\u308f\u304b\u3089\u305a\u3002mmap\u3055\u308c\u3066\u3044\u308b\u5834\u5408\u306b\u4f55\u304b\u3057\u305f\u3044\u307f\u305f\u3044\u3002\n\n```c:inode.c\n2049         if (PageChecked(page) && ext4_should_journal_data(inode))\n2050                 /*\n2051                  * It's mmapped pagecache.  Add buffers and journal it.  There\n2052                  * doesn't seem much point in redirtying the page here.\n2053                  */\n2054                 return __ext4_journalled_writepage(page, len);\n```\n\n[kernel/fs/ext4/inode.c:**ext4_writepages()**](http://lxr.free-electrons.com/source/fs/ext4/inode.c?v=4.6#L2619)\u306f\u3001\u9045\u5ef6\u30a2\u30ed\u30b1\u30fc\u30b7\u30e7\u30f3\u3058\u3083\u306a\u3044\u3068\u3044\u3046\u6c7a\u3081\u6253\u3061\u3067\u7c21\u6613\u30b3\u30fc\u30c9\u306b\u5206\u5c90\u3055\u305b\u3066\u3044\u308b\u307f\u305f\u3044\u3002\n\n```c:inode.c\n2619         if (ext4_should_journal_data(inode)) {\n2620                 struct blk_plug plug;\n2621 \n2622                 blk_start_plug(&plug);\n2623                 ret = write_cache_pages(mapping, wbc, __writepage, mapping);\n2624                 blk_finish_plug(&plug);\n2625                 goto out_writepages;\n2626         }\n```\n\n[kernel/fs/ext4/inode.c:**ext4_direct_IO()**](http://lxr.free-electrons.com/source/fs/ext4/inode.c?v=4.6#L3447)\u306f\u3001**data=journal**\u3060\u3068**O_DIRECT**\u30e2\u30fc\u30c9\u306f\u4f7f\u3048\u306a\u3044\u3002\n\n```c:inode.c\n3447         /*\n3448          * If we are doing data journalling we don't support O_DIRECT\n3449          */\n3450         if (ext4_should_journal_data(inode))\n3451                 return 0;\n```\n\n[kernel/fs/ext4/inode.c:**__ext4_block_zero_page_range()**](http://lxr.free-electrons.com/source/fs/ext4/inode.c?v=4.6#L3619)\u306f\u3001\u5148\u306eext4_convert_inline_data_to_extent()\u3068\u540c\u3058\u3002\n\n```c:inode.c\n3619         if (ext4_should_journal_data(inode)) {\n3620                 BUFFER_TRACE(bh, \"get write access\");\n3621                 err = ext4_journal_get_write_access(handle, bh);\n3622                 if (err)\n3623                         goto unlock;\n3624         }\n3625         zero_user(page, offset, length);\n3626         BUFFER_TRACE(bh, \"zeroed end of block\");\n3627 \n3628         if (ext4_should_journal_data(inode)) {\n3629                 err = ext4_handle_dirty_metadata(handle, inode, bh);\n3630         } else {\n3631                 err = 0;\n3632                 mark_buffer_dirty(bh);\n3633                 if (ext4_test_inode_state(inode, EXT4_STATE_ORDERED_MODE))\n3634                         err = ext4_jbd2_file_inode(handle, inode);\n3635         }\n```\n\n[kernel/fs/ext4/inode.c:**ext4_setattr()**](http://lxr.free-electrons.com/source/fs/ext4/inode.c?v=4.6#L5054)\u306f\u3001inode\u304c\u6d88\u3055\u308c\u304b\u3051\u306e\u6642\u306bIO\u5f85\u3061\u3092\u3057\u3066\u3044\u308b\u3002\u5148\u306b\u3042\u3063\u305f\u306e\u3068\u540c\u3058\u304f\u3001**data=journal**\u3060\u3068\u30c7\u30fc\u30bf\u3060\u3051\u3058\u3083\u306a\u304fjournal\u3082\u66f8\u304d\u51fa\u3055\u306a\u3044\u3068\u3044\u3051\u306a\u3044\u3002\n\n```c:inode.c\n5054                 /*\n5055                  * Blocks are going to be removed from the inode. Wait\n5056                  * for dio in flight.  Temporarily disable\n5057                  * dioread_nolock to prevent livelock.\n5058                  */\n5059                 if (orphan) {\n5060                         if (!ext4_should_journal_data(inode)) {\n5061                                 ext4_inode_block_unlocked_dio(inode);\n5062                                 inode_dio_wait(inode);\n5063                                 ext4_inode_resume_unlocked_dio(inode);\n5064                         } else\n5065                                 ext4_wait_for_tail_page_commit(inode);\n5066                 }\n```\n\n[kernel/fs/ext4/inode.c:**ext4_writepage_trans_blocks()**](http://lxr.free-electrons.com/source/fs/ext4/inode.c?v=4.6#L5189)\u306f\u3001\u66f8\u304d\u8fbc\u307f\u4e88\u7d04\u30da\u30fc\u30b8\u6570\u3092\u8fd4\u3059\u305f\u3081\u306b\u3001journal\u306b\u66f8\u304b\u308c\u308b\u30c7\u30fc\u30bf\u306e\u5206\u3082\u8a08\u4e0a\u3057\u3066\u3044\u308b\u3002\n\n```c:inode.c\n5189 /*\n5190  * Calculate the total number of credits to reserve to fit\n5191  * the modification of a single pages into a single transaction,\n5192  * which may include multiple chunks of block allocations.\n5193  *\n5194  * This could be called via ext4_write_begin()\n5195  *\n5196  * We need to consider the worse case, when\n5197  * one new block per extent.\n5198  */\n5199 int ext4_writepage_trans_blocks(struct inode *inode)\n5200 {\n5201         int bpp = ext4_journal_blocks_per_page(inode);\n5202         int ret;\n5203 \n5204         ret = ext4_meta_trans_blocks(inode, bpp, bpp);\n5205 \n5206         /* Account for data blocks for journalled mode */\n5207         if (ext4_should_journal_data(inode))\n5208                 ret += bpp;\n5209         return ret;\n5210 }\n```\n\n[kernel/fs/ext4/inode.c:**ext4_page_mkwrite()**](http://lxr.free-electrons.com/source/fs/ext4/inode.c?v=4.6#L5526)\u306e\u5148\u306b\u3042\u308b\u65b9\u306f...\u3088\u304f\u308f\u304b\u3089\u306a\u3044\u3002**ext4_page_mkwrite()**\u306f[Documentation\u306eLocking\u306b\u3088\u308b](http://lxr.free-electrons.com/source/Documentation/filesystems/Locking?v=4.6)\u3068\u3001read-only\u304b\u3089writable\u306b\u5909\u308f\u308b\u3068\u304d\u306b\u547c\u3070\u308c\u308b\u30a8\u30f3\u30c8\u30ea\u95a2\u6570\u3089\u3057\u3044...\n\n```c:inode.c\n5526         /* Delalloc case is easy... */\n5527         if (test_opt(inode->i_sb, DELALLOC) &&\n5528             !ext4_should_journal_data(inode) &&\n5529             !ext4_nonda_switch(inode->i_sb)) {\n5530                 do {\n5531                         ret = block_page_mkwrite(vma, vmf,\n5532                                                    ext4_da_get_block_prep);\n5533                 } while (ret == -ENOSPC &&\n5534                        ext4_should_retry_alloc(inode->i_sb, &retries));\n5535                 goto out_ret;\n5536         }\n```\n```Locking\n555         ->page_mkwrite() is called when a previously read-only pte is\n556 about to become writeable. The filesystem again must ensure that there are\n557 no truncate/invalidate races, and then return with the page locked. If\n558 the page has been truncated, the filesystem should not look up a new page\n559 like the ->fault() handler, but simply return with VM_FAULT_NOPAGE, which\n560 will cause the VM to retry the fault.\n561 \n562         ->pfn_mkwrite() is the same as page_mkwrite but when the pte is\n563 VM_PFNMAP or VM_MIXEDMAP with a page-less entry. Expected return is\n564 VM_FAULT_NOPAGE. Or one of the VM_FAULT_ERROR types. The default behavior\n565 after this call is to make the pte read-write, unless pfn_mkwrite returns\n566 an error.\n```\n\n[kernel/fs/ext4/inode.c:**ext4_page_mkwrite()**](http://lxr.free-electrons.com/source/fs/ext4/inode.c?v=4.6#L5579)\u306e\u5f8c\u306b\u3042\u308b\u65b9\u306f\u3001\u5148\u306e**ext4_convert_inline_data_to_extent()**\u3068\u540c\u3058\u3002\n\n```c:inode.c\n5579         if (!ret && ext4_should_journal_data(inode)) {\n5580                 if (ext4_walk_page_buffers(handle, page_buffers(page), 0,\n5581                           PAGE_SIZE, NULL, do_journal_get_write_access)) {\n5582                         unlock_page(page);\n5583                         ret = VM_FAULT_SIGBUS;\n5584                         ext4_journal_stop(handle);\n5585                         goto out;\n5586                 }\n5587                 ext4_set_inode_state(inode, EXT4_STATE_JDATA);\n5588         }\n```\n\n[kernel/fs/ext4/ext4_jbd2.c:**__ext4_forget()**](http://lxr.free-electrons.com/source/fs/ext4/ext4_jbd2.c?v=4.6#L206)\u306f\u3001**data=journal**\u306e\u5834\u5408\u306frevoke\u3067\u306f\u306a\u304fforget\u3092\u547c\u3076\u3088\u3046\u306b\u3057\u3066\u3044\u308b\u3002\n\n```c:ext4_jbd2.c\n206         /* Never use the revoke function if we are doing full data\n207          * journaling: there is no need to, and a V1 superblock won't\n208          * support it.  Otherwise, only skip the revoke on un-journaled\n209          * data blocks. */\n210 \n211         if (test_opt(inode->i_sb, DATA_FLAGS) == EXT4_MOUNT_JOURNAL_DATA ||\n212             (!is_metadata && !ext4_should_journal_data(inode))) {\n213                 if (bh) {\n214                         BUFFER_TRACE(bh, \"call jbd2_journal_forget\");\n215                         err = jbd2_journal_forget(handle, bh);\n216                         if (err)\n217                                 ext4_journal_abort_handle(where, line, __func__,\n218                                                           bh, handle, err);\n219                         return err;\n220                 }\n221                 return 0;\n222         }\n```\n\n[kernel/fs/ext4/extents.c:**get_default_free_blocks_flags()**](http://lxr.free-electrons.com/source/fs/ext4/extents.c?v=4.6#L2483)\u306f\u3001\u30c7\u30d5\u30a9\u30eb\u30c8**EXT4_FREE_BLOCKS_FORGET**\u306b\u3057\u3066\u3001\u5148\u306e**ext4_clear_blocks()**\u306e\u5834\u5408\u3078\u3068\u3064\u306a\u304c\u308b\u3002\n\n```c:extentc.c\n2483 static inline int get_default_free_blocks_flags(struct inode *inode)\n2484 {\n2485         if (S_ISDIR(inode->i_mode) || S_ISLNK(inode->i_mode))\n2486                 return EXT4_FREE_BLOCKS_METADATA | EXT4_FREE_BLOCKS_FORGET;\n2487         else if (ext4_should_journal_data(inode))\n2488                 return EXT4_FREE_BLOCKS_FORGET;\n2489         return 0;\n2490 }\n```\n\n[kernel/fs/ext4/extents.c:**ext4_zero_range()**](http://lxr.free-electrons.com/source/fs/ext4/extents.c?v=4.6#L4772)\u306e1\u3064\u3081\u306f\u3001**ext4_force_commit()**\u3092\u547c\u3076\u3053\u3068\u3067\u3001\u73fe\u5728\u3042\u308b\u30c8\u30e9\u30f3\u30b6\u30af\u30b7\u30e7\u30f3\u3092\u5f37\u5236\u7684\u306bcommit\u3057\u3066\u305d\u308c\u304c\u7d42\u308f\u308b\u307e\u3067\u5f85\u3064\u3002\n\n```c:extents.c\n5632         /* Call ext4_force_commit to flush all data in case of data=journal */\n5633         if (ext4_should_journal_data(inode)) {\n5634                 ret = ext4_force_commit(inode->i_sb);\n5635                 if (ret)\n5636                         return ret;\n5637         }\n```\n\n[kernel/fs/ext4/extents.c:**ext4_zero_range()**](http://lxr.free-electrons.com/source/fs/ext4/extents.c?v=4.6#L4772)\u306e2\u3064\u3081\u306f\u3001journal\u8a18\u9332\u306b\u5fc5\u8981\u306a\u30d6\u30ed\u30c3\u30af\u6570\u306e\u8a08\u7b97\u3002\n\n```c:extents.c\n4866         /*\n4867          * In worst case we have to writeout two nonadjacent unwritten\n4868          * blocks and update the inode\n4869          */\n4870         credits = (2 * ext4_ext_index_trans_blocks(inode, 2)) + 1;\n4871         if (ext4_should_journal_data(inode))\n4872                 credits += 2;\n4873         handle = ext4_journal_start(inode, EXT4_HT_MISC, credits);\n```\n\n[kernel/fs/ext4/extents.c:**ext4_collapse_range()**](http://lxr.free-electrons.com/source/fs/ext4/extents.c?v=4.6#L5486)\u306f\u3001\u5148\u3068\u540c\u3058\u304f**ext4_force_commit()**\u3092\u547c\u3093\u3067\u3044\u308b\u3002\n\n```c:extents.c\n5486         /* Call ext4_force_commit to flush all data in case of data=journal. */\n5487         if (ext4_should_journal_data(inode)) {\n5488                 ret = ext4_force_commit(inode->i_sb);\n5489                 if (ret)\n5490                         return ret;\n5491         }\n```\n\n[kernel/fs/ext4/extents.c:**ext4_insert_range()**](http://lxr.free-electrons.com/source/fs/ext4/extents.c?v=4.6#L5632)\u306f\u3001\u5148\u3068\u540c\u3058\u304f**ext4_force_commit()**\u3092\u547c\u3093\u3067\u3044\u308b\u3002\n\n```c:extents.c\n5632         /* Call ext4_force_commit to flush all data in case of data=journal */\n5633         if (ext4_should_journal_data(inode)) {\n5634                 ret = ext4_force_commit(inode->i_sb);\n5635                 if (ret)\n5636                         return ret;\n5637         }\n```\n\n...\u3084\u3063\u3068**ext4_should_journal_data()**\u306e\u5206\u304c\u7d42\u308f\u3063\u305f...\n\n# more study\n**debugfs\u306elogdump**\u304c\u3001journal\u3092\u8aad\u3080\u624b\u52a9\u3051\u306b\u306a\u308b\u3002\n\n```bash\n# debugfs /dev/sa1\ndebugfs 1.42.13 (17-May-2015)\ndebugfs: logdump\nJournal starts at block 1, transaction 21047\nFound expected sequence 21047, type 1 (descriptor block) at block 1\nFound expected sequence 21047, type 2 (commit block) at block 18\nFound expected sequence 21048, type 1 (descriptor block) at block 19\nFound expected sequence 21048, type 2 (commit block) at block 30\nFound expected sequence 21049, type 1 (descriptor block) at block 31\n(---snip---)\n```\n**sleuthkit\u306ejls**\u304c\u3042\u308b\u3068\u3044\u3046\u60c5\u5831\u3082\u898b\u3064\u304b\u3063\u305f\u304c\u3001\u30c4\u30fc\u30eb\u304cext3\u4ee5\u6765\u30e1\u30f3\u30c6\u3055\u308c\u3066\u3044\u306a\u304f\u3066ext4\u306b\u5bfe\u5fdc\u3057\u3066\u306a\u3044\u3063\u307d\u304b\u3063\u305f\u3002\n\n\u3042\u3068\u306f\u3001[kernel wiki \u306e ext4 Disk Layout\u306eJBD2\u95a2\u9023](https://ext4.wiki.kernel.org/index.php/Ext4_Disk_Layout#Journal_.28jbd2.29)\u3092\u53c2\u8003\u306b\u3057\u306a\u304c\u3089\u30fb\u30fb\u30fb\u3068\u3044\u3046\u304b\u3001jbd2\u306edescriptor\u3092\u5b9a\u7fa9\u3059\u308bstruct\u306e\u30d8\u30c3\u30c0\u3068\u30d8\u30ad\u30b5\u30c0\u30f3\u30d7\u3068\u3092\u4e26\u3079\u3066\u306b\u3089\u3081\u3063\u3053\u3059\u308b\u3057\u304b\u306a\u3044\u6a21\u69d8\u3002\n\n# \u3042\u3068\u304c\u304d\next4\u306ejournal\u306e\u30e2\u30fc\u30c9\u3068\u305d\u308c\u306b\u3088\u308b\u51e6\u7406\u306e\u6d41\u308c\u304c\u4e0a\u8a18\u306e\u3088\u3046\u306b\u3061\u3087\u3063\u3068\u306f\u308f\u304b\u3063\u305f\u6c17\u306b\u306a\u308c\u305f\u3002\u3051\u3069\u3001\u809d\u5fc3\u306ejournal\u306e\u4e2d\u8eab\u306f\u5168\u304f\u308f\u304b\u3089\u306a\u3044\u3002\u7d50\u5c40\u306e\u3068\u3053\u308d\u3001\u5b9f\u969b\u306ejournal\u3068\u3044\u3046\u304btransaction\u3068\u3044\u3046\u304b\u306e\u3042\u305f\u308a\u306f\u3001\u30d6\u30ed\u30c3\u30af\u3068\u3044\u3046\u304b\u30da\u30fc\u30b8\u3068\u3044\u3046\u304b\u306e\u5358\u4f4d\u3067jbd2\u4efb\u305b\u306b\u3057\u3066\u3044\u308b\u306e\u3067\u3001\u305d\u3063\u3061\u3082\u8aad\u307f\u3059\u3059\u3081\u306a\u3051\u308c\u3070\u3044\u3051\u306a\u3044\u3002\n\n\u307e\u305fjournal\u3068\u5bc6\u63a5\u306b\u95a2\u9023\u3059\u308b\u6a5f\u80fd\u3068\u3057\u3066\u3001**metadata_csum**\u3084**journal_checksum**\u306e\u30c1\u30a7\u30c3\u30af\u30b5\u30e0\u6a5f\u80fd\u3082\u3042\u308a\u3001\u30c7\u30fc\u30bf\u4fdd\u8b77\u306e\u89b3\u70b9\u3067\u306f\u3053\u308c\u3089\u3082\u304d\u3061\u3093\u3068\u8ffd\u308f\u306a\u3044\u3068\u3044\u3051\u306a\u3044\u3002\n\n\u79c1\u3082\u9806\u3092\u8ffd\u3063\u3066\u7406\u89e3\u3057\u3066\u3044\u304f\u3064\u3082\u308a\u3067\u3059\u3002**REQ_FUA**\u3068\u304b**REQ_PREFLUSH**\u3068\u304b**REQ_META**\u3068\u304b**REQ_SYNC**\u3068\u304b\u3002\u30fb\u30fb\u30fb\u3067\u3082\u305d\u306e\u8fba\u306f**block/writeback_cache_control.txt**\u3092\u7406\u89e3\u3059\u308c\u3070\u3044\u3044\u3060\u3051\uff1f ~~...\u3068\u601d\u3063\u3066\u305f\u3089\u3001[a2b809672(v4.10-rc1)](https://patchwork.kernel.org/patch/9407451/)\u304b\u3089\u30de\u30af\u30ed\u540d\u3068\u3044\u3046\u304b\u30dd\u30ea\u30b7\u30fc\u304c\u5909\u308f\u3063\u3066\u3044\u305f\u3002(**WRITE_FUA**\u2192**REQ_FUA**\u3068\u304b\u3002) \u305d\u3046\u3044\u3046\u306e\u306f\u30bd\u30fc\u30b9\u30b3\u30fc\u30c9\u8ffd\u3044\u3065\u3089\u304f\u306a\u308b\u304b\u3089\u30e4\u30e1\u30c6...~~ \u8aa4\u89e3\u3067\u3057\u305f\u3001\u30de\u30af\u30ed\u306e\u610f\u5473\u3092\u53b3\u5bc6\u306b\u518d\u5b9a\u7fa9\u3057\u305f\u3060\u3051\u3067\u3001\u30de\u30af\u30ed\u540d\u3092\u7f6e\u304d\u63db\u3048\u305f\u308a\u307e\u3067\u306f\u3057\u3066\u307e\u305b\u3093\u3067\u3057\u305f\u3002\n", "tags": ["Linux", "ext4", "kernel", "jbd2"]}