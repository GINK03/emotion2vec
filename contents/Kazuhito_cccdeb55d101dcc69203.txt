{"context": "\u6700\u8fd1Python\u306e\u30b3\u30fc\u30c9\u306e\u66f8\u304d\u3084\u3059\u3055\u306b\u9b45\u529b\u3092\u611f\u3058\u3066\u3001\u7d50\u69cbPython\u3067\u30b5\u30f3\u30d7\u30eb\u30d7\u30ed\u30b0\u30e9\u30e0\u3068\u304b\u66f8\u3044\u3066\u307e\u3059\u3002\n\u3067\u3001\u8868\u984c\u306e\u4ef6\u3002\n\u3053\u306e\u5148\u4ed5\u4e8b\u3067\u9b5a\u773c\u3068\u304b\u8d85\u5e83\u89d2\u30ec\u30f3\u30ba\u3092\u5229\u7528\u3059\u308b\u304b\u3082\u3057\u308c\u306a\u3044\u306e\u3067\u3001\u304a\u8a66\u3057\u30b5\u30f3\u30d7\u30eb\u3092\u4f5c\u308d\u3046\u3068\u3057\u305f\u3089\u3001\nC++\u7248OpenCV\u306b\u5b58\u5728\u3059\u308b cv::fisheye\u7cfb\u306eI/F\u304cPython\u7248\u306b\u306f\u7121\u3044\u3089\u3057\u3044\u3002\u3002\u3002\n\u3057\u304b\u305f\u306a\u304f\u3001\u8272\u3005\u8ae6\u3081\u304d\u308c\u306a\u304b\u3063\u305f\u306e\u3067\u3001Python\u3067\u901a\u5e38\u306e\u30ad\u30e3\u30ea\u30d6\u30ec\u30fc\u30b7\u30e7\u30f3\u306e\u624b\u756a\u3092\u8e0f\u3093\u3067\u3001\n\u9b5a\u773c\u30ec\u30f3\u30ba\u3092\u30ad\u30e3\u30ea\u30d6\u30ec\u30fc\u30b7\u30e7\u30f3\u3057\u3066\u307f\u307e\u3057\u305f\u3002\n\uff08Python\u7248\u3067\u51fa\u6765\u305f\u3089\u3001C++\u7248\u3067\u3061\u3083\u3093\u3068\u3057\u305f\u5b9f\u88c5\u3059\u308c\u3070\u6280\u8853\u7684\u306b\u306f\u554f\u984c\u7121\u3044\u3067\u3057\u3087\u3046\u7406\u8ad6\n\u4ee5\u4e0b\u3001YouTube\u52d5\u753b\u2193\n\n\u3042\u308c\uff1f\u306a\u3093\u304b\u666e\u901a\u306b\u51fa\u6765\u3066\u308b\uff1f\u3000\u7406\u7531\u8981\u78ba\u8a8d\u3002\n\u3042\u3068\u3001\u6c17\u6301\u3061\u5207\u308a\u53d6\u3089\u308c\u3066\u3044\u308b\u7b87\u6240\u591a\u3044\u3088\u3046\u306a\u6c17\u304c\u3057\u306a\u3044\u3067\u3082\u306a\u3044\u3002\n\u305f\u3076\u3093\u5e83\u89d2130\u5ea6\u304f\u3089\u3044\u78ba\u4fdd\u51fa\u6765\u3066\u3044\u308b\u3002\n\u3061\u306a\u307f\u306b\u4f7f\u7528\u3057\u305f\u30ab\u30e1\u30e9\u306f\u4ee5\u4e0b\u2193\nhttps://www.amazon.co.jp/ELP-USB2-0-Ominivison-OV2710-%E5%BA%A6%E3%83%A1%E3%82%AC%E3%83%94%E3%82%AF%E3%82%BB%E3%83%AB%E9%AD%9A%E7%9C%BC%E3%83%AC%E3%83%B3%E3%82%BA/dp/B017R02JLI\n\n\u30b3\u30fc\u30c9\u3082\u4ee5\u4e0b\u306b\u8cbc\u308a\u4ed8\u3051\u2193\n#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\nimport numpy as np\nimport cv2\nimport Tkinter\nimport tkMessageBox\n\nsquare_side_length = 23.0 # \u30c1\u30a7\u30b9\u30dc\u30fc\u30c9\u5185\u306e\u6b63\u65b9\u5f62\u306e1\u8fba\u306e\u30b5\u30a4\u30ba(mm)\ngrid_intersection_size = (10, 7) # \u30c1\u30a7\u30b9\u30dc\u30fc\u30c9\u5185\u306e\u683c\u5b50\u6570\n\npattern_points = np.zeros( (np.prod(grid_intersection_size), 3), np.float32 )\npattern_points[:,:2] = np.indices(grid_intersection_size).T.reshape(-1, 2)\npattern_points *= square_side_length\nobject_points = []\nimage_points = []\n\nroot = Tkinter.Tk()\nroot.withdraw()\n\nvideo_input = cv2.VideoCapture(1)\nif (video_input.isOpened() == False):\n    exit()\n\ncamera_mat, dist_coef = [], []\n\nif tkMessageBox.askyesno('askyesno','\u30ad\u30e3\u30ea\u30d6\u30ec\u30fc\u30b7\u30e7\u30f3\u30c7\u30fc\u30bf(K.csv, d.csv)\u3092\u8aad\u307f\u8fbc\u307f\u307e\u3059\u304b\uff1f'):\n    # \u30ad\u30e3\u30ea\u30d6\u30ec\u30fc\u30b7\u30e7\u30f3\u30c7\u30fc\u30bf\u306e\u8aad\u307f\u8fbc\u307f\n    camera_mat = np.loadtxt('K.csv', delimiter=',')\n    dist_coef = np.loadtxt('d.csv', delimiter=',')\n    print \"K = \\n\", camera_mat\n    print \"d = \", dist_coef.ravel()\nelse:\n    # \u30c1\u30a7\u30b9\u30dc\u30fc\u30c9\u306e\u64ae\u5f71\n    capture_count = 0\n    while(True):\n        ret, frame = video_input.read()\n\n        # \u30c1\u30a7\u30b9\u30dc\u30fc\u30c9\u691c\u51fa\u7528\u306b\u30b0\u30ec\u30fc\u30b9\u30b1\u30fc\u30eb\u753b\u50cf\u3078\u5909\u63db\n        #grayscale_image = cv2.cvtColor(frame, cv2.COLOR_RGB2GRAY)\n\n        # \u30c1\u30a7\u30b9\u30dc\u30fc\u30c9\u306e\u30b3\u30fc\u30ca\u30fc\u3092\u691c\u51fa\n        #found, corner = cv2.findChessboardCorners(grayscale_image, grid_intersection_size)\n        found, corner = cv2.findChessboardCorners(frame, grid_intersection_size)\n\n        if found == True:\n            print 'findChessboardCorners : True'\n\n            # \u73fe\u5728\u306eOpenCV\u3067\u306ffindChessboardCorners()\u5185\u3067\u3001cornerSubPix()\u76f8\u5f53\u306e\u51e6\u7406\u304c\u5b9f\u65bd\u3055\u308c\u3066\u3044\u308b\uff1f\u8981\u78ba\u8a8d\n            #term = (cv2.TERM_CRITERIA_EPS + cv2.TERM_CRITERIA_COUNT, 30, 0.1)\n            #cv2.cornerSubPix(grayscale_image, corner, (5,5), (-1,-1), term)\n            #cv2.drawChessboardCorners(grayscale_image, grid_intersection_size, corner, found)\n\n            cv2.drawChessboardCorners(frame, grid_intersection_size, corner, found)\n        if found == False:\n            print 'findChessboardCorners : False'\n\n        cv2.putText(frame, \"Enter:Capture Chessboard(\" + str(capture_count) + \")\", (100, 50), cv2.FONT_HERSHEY_SIMPLEX, 0.4, (0,0,255), 1)\n        cv2.putText(frame, \"N    :Completes Calibration Photographing\", (100, 75), cv2.FONT_HERSHEY_SIMPLEX, 0.4, (0,0,255), 1)\n        cv2.putText(frame, \"ESC  :terminate program\", (100, 100), cv2.FONT_HERSHEY_SIMPLEX, 0.4, (0,0,255), 1)\n        #cv2.putText(grayscale_image, \"Enter:Capture Chessboard(\" + str(capture_count) + \")\", (100, 50), cv2.FONT_HERSHEY_SIMPLEX, 0.4, (0,0,255), 1)\n        #cv2.putText(grayscale_image, \"ESC  :Completes Calibration Photographing.\", (100, 75), cv2.FONT_HERSHEY_SIMPLEX, 0.4, (0,0,255), 1)\n        cv2.imshow('original', frame)\n        #cv2.imshow('findChessboardCorners', grayscale_image)\n\n        c = cv2.waitKey(50) & 0xFF\n        if c == 13 and found == True: # Enter\n            # \u30c1\u30a7\u30b9\u30dc\u30fc\u30c9\u30b3\u30fc\u30ca\u30fc\u691c\u51fa\u60c5\u5831\u3092\u8ffd\u52a0\n            image_points.append(corner)\n            object_points.append(pattern_points)\n            capture_count += 1\n        if c == 110: # N\n            if tkMessageBox.askyesno('askyesno','\u30c1\u30a7\u30b9\u30dc\u30fc\u30c9\u64ae\u5f71\u3092\u7d42\u4e86\u3057\u3001\u30ab\u30e1\u30e9\u5185\u90e8\u30d1\u30e9\u30e1\u30fc\u30bf\u3092\u6c42\u3081\u307e\u3059\u304b\uff1f'):\n                cv2.destroyAllWindows()\n                break\n        if c == 27: # ESC\n            if tkMessageBox.askyesno('askyesno','\u30d7\u30ed\u30b0\u30e9\u30e0\u3092\u7d42\u4e86\u3057\u307e\u3059\u304b\uff1f'):\n                video_input.release()\n                cv2.destroyAllWindows()\n                exit()\n\n    if len(image_points) > 0:\n        # \u30ab\u30e1\u30e9\u5185\u90e8\u30d1\u30e9\u30e1\u30fc\u30bf\u3092\u8a08\u7b97\n        print 'calibrateCamera() start'\n        rms, K, d, r, t = cv2.calibrateCamera(object_points,image_points,(frame.shape[1],frame.shape[0]),None,None)\n        print \"RMS = \", rms\n        print \"K = \\n\", K\n        print \"d = \", d.ravel()\n        np.savetxt(\"K.csv\", K, delimiter =',',fmt=\"%0.14f\") #\u30ab\u30e1\u30e9\u884c\u5217\u306e\u4fdd\u5b58\n        np.savetxt(\"d.csv\", d, delimiter =',',fmt=\"%0.14f\") #\u6b6a\u307f\u4fc2\u6570\u306e\u4fdd\u5b58\n\n        camera_mat = K\n        dist_coef = d\n\n        # \u518d\u6295\u5f71\u8aa4\u5dee\u306b\u3088\u308b\u8a55\u4fa1\n        mean_error = 0\n        for i in xrange(len(object_points)):\n            image_points2, _ = cv2.projectPoints(object_points[i], r[i], t[i], camera_mat, dist_coef)\n            error = cv2.norm(image_points[i], image_points2, cv2.NORM_L2) / len(image_points2)\n            mean_error += error\n        print \"total error: \", mean_error/len(object_points) # 0\u306b\u8fd1\u3044\u5024\u304c\u671b\u307e\u3057\u3044(\u9b5a\u773c\u30ec\u30f3\u30ba\u306e\u8a55\u4fa1\u306b\u306f\u4e0d\u9069\uff1f)\n    else:\n        print \"findChessboardCorners() not be successful once\"\n\n# \u6b6a\u307f\u88dc\u6b63\u753b\u50cf\u8868\u793a\nif camera_mat != []:\n    while(True):\n        ret, frame = video_input.read()\n        undistort_image = cv2.undistort(frame, camera_mat, dist_coef)\n\n        cv2.imshow('original', frame)\n        cv2.imshow('undistort', undistort_image)\n        c = cv2.waitKey(50) & 0xFF\n        if c==27: # ESC\n            break\n\nvideo_input.release()\ncv2.destroyAllWindows()\n\n\u4ee5\u4e0a\u3002\n\u6700\u8fd1Python\u306e\u30b3\u30fc\u30c9\u306e\u66f8\u304d\u3084\u3059\u3055\u306b\u9b45\u529b\u3092\u611f\u3058\u3066\u3001\u7d50\u69cbPython\u3067\u30b5\u30f3\u30d7\u30eb\u30d7\u30ed\u30b0\u30e9\u30e0\u3068\u304b\u66f8\u3044\u3066\u307e\u3059\u3002\n\n\u3067\u3001\u8868\u984c\u306e\u4ef6\u3002\n\u3053\u306e\u5148\u4ed5\u4e8b\u3067\u9b5a\u773c\u3068\u304b\u8d85\u5e83\u89d2\u30ec\u30f3\u30ba\u3092\u5229\u7528\u3059\u308b\u304b\u3082\u3057\u308c\u306a\u3044\u306e\u3067\u3001\u304a\u8a66\u3057\u30b5\u30f3\u30d7\u30eb\u3092\u4f5c\u308d\u3046\u3068\u3057\u305f\u3089\u3001\nC++\u7248OpenCV\u306b\u5b58\u5728\u3059\u308b cv::fisheye\u7cfb\u306eI/F\u304cPython\u7248\u306b\u306f\u7121\u3044\u3089\u3057\u3044\u3002\u3002\u3002\n\n\u3057\u304b\u305f\u306a\u304f\u3001\u8272\u3005\u8ae6\u3081\u304d\u308c\u306a\u304b\u3063\u305f\u306e\u3067\u3001Python\u3067\u901a\u5e38\u306e\u30ad\u30e3\u30ea\u30d6\u30ec\u30fc\u30b7\u30e7\u30f3\u306e\u624b\u756a\u3092\u8e0f\u3093\u3067\u3001\n\u9b5a\u773c\u30ec\u30f3\u30ba\u3092\u30ad\u30e3\u30ea\u30d6\u30ec\u30fc\u30b7\u30e7\u30f3\u3057\u3066\u307f\u307e\u3057\u305f\u3002\n\uff08Python\u7248\u3067\u51fa\u6765\u305f\u3089\u3001C++\u7248\u3067\u3061\u3083\u3093\u3068\u3057\u305f\u5b9f\u88c5\u3059\u308c\u3070\u6280\u8853\u7684\u306b\u306f\u554f\u984c\u7121\u3044\u3067\u3057\u3087\u3046\u7406\u8ad6\n\n\u4ee5\u4e0b\u3001YouTube\u52d5\u753b\u2193\n[![\u3010Windows\u3011\u3010Python\u3011 OpenCV\u3067\u9b5a\u773c\u30ec\u30f3\u30ba\u306e\u30ab\u30e1\u30e9\u30ad\u30e3\u30ea\u30d6\u30ec\u30fc\u30b7\u30e7\u30f3](http://img.youtube.com/vi/WGtZeyfzve4/0.jpg)](http://www.youtube.com/watch?v=WGtZeyfzve4)\n\n\u3042\u308c\uff1f\u306a\u3093\u304b\u666e\u901a\u306b\u51fa\u6765\u3066\u308b\uff1f\u3000\u7406\u7531\u8981\u78ba\u8a8d\u3002\n\u3042\u3068\u3001\u6c17\u6301\u3061\u5207\u308a\u53d6\u3089\u308c\u3066\u3044\u308b\u7b87\u6240\u591a\u3044\u3088\u3046\u306a\u6c17\u304c\u3057\u306a\u3044\u3067\u3082\u306a\u3044\u3002\n\u305f\u3076\u3093\u5e83\u89d2130\u5ea6\u304f\u3089\u3044\u78ba\u4fdd\u51fa\u6765\u3066\u3044\u308b\u3002\n\n\u3061\u306a\u307f\u306b\u4f7f\u7528\u3057\u305f\u30ab\u30e1\u30e9\u306f\u4ee5\u4e0b\u2193\nhttps://www.amazon.co.jp/ELP-USB2-0-Ominivison-OV2710-%E5%BA%A6%E3%83%A1%E3%82%AC%E3%83%94%E3%82%AF%E3%82%BB%E3%83%AB%E9%AD%9A%E7%9C%BC%E3%83%AC%E3%83%B3%E3%82%BA/dp/B017R02JLI\n![DSC_0267.JPG](https://qiita-image-store.s3.amazonaws.com/0/140207/83877216-7afc-1a90-3d88-06acd88576c5.jpeg)\n\n\n\u30b3\u30fc\u30c9\u3082\u4ee5\u4e0b\u306b\u8cbc\u308a\u4ed8\u3051\u2193\n\n```py\n#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\nimport numpy as np\nimport cv2\nimport Tkinter\nimport tkMessageBox\n\nsquare_side_length = 23.0 # \u30c1\u30a7\u30b9\u30dc\u30fc\u30c9\u5185\u306e\u6b63\u65b9\u5f62\u306e1\u8fba\u306e\u30b5\u30a4\u30ba(mm)\ngrid_intersection_size = (10, 7) # \u30c1\u30a7\u30b9\u30dc\u30fc\u30c9\u5185\u306e\u683c\u5b50\u6570\n\npattern_points = np.zeros( (np.prod(grid_intersection_size), 3), np.float32 )\npattern_points[:,:2] = np.indices(grid_intersection_size).T.reshape(-1, 2)\npattern_points *= square_side_length\nobject_points = []\nimage_points = []\n\nroot = Tkinter.Tk()\nroot.withdraw()\n\nvideo_input = cv2.VideoCapture(1)\nif (video_input.isOpened() == False):\n    exit()\n\ncamera_mat, dist_coef = [], []\n\nif tkMessageBox.askyesno('askyesno','\u30ad\u30e3\u30ea\u30d6\u30ec\u30fc\u30b7\u30e7\u30f3\u30c7\u30fc\u30bf(K.csv, d.csv)\u3092\u8aad\u307f\u8fbc\u307f\u307e\u3059\u304b\uff1f'):\n    # \u30ad\u30e3\u30ea\u30d6\u30ec\u30fc\u30b7\u30e7\u30f3\u30c7\u30fc\u30bf\u306e\u8aad\u307f\u8fbc\u307f\n    camera_mat = np.loadtxt('K.csv', delimiter=',')\n    dist_coef = np.loadtxt('d.csv', delimiter=',')\n    print \"K = \\n\", camera_mat\n    print \"d = \", dist_coef.ravel()\nelse:\n    # \u30c1\u30a7\u30b9\u30dc\u30fc\u30c9\u306e\u64ae\u5f71\n    capture_count = 0\n    while(True):\n        ret, frame = video_input.read()\n\n        # \u30c1\u30a7\u30b9\u30dc\u30fc\u30c9\u691c\u51fa\u7528\u306b\u30b0\u30ec\u30fc\u30b9\u30b1\u30fc\u30eb\u753b\u50cf\u3078\u5909\u63db\n        #grayscale_image = cv2.cvtColor(frame, cv2.COLOR_RGB2GRAY)\n\n        # \u30c1\u30a7\u30b9\u30dc\u30fc\u30c9\u306e\u30b3\u30fc\u30ca\u30fc\u3092\u691c\u51fa\n        #found, corner = cv2.findChessboardCorners(grayscale_image, grid_intersection_size)\n        found, corner = cv2.findChessboardCorners(frame, grid_intersection_size)\n\n        if found == True:\n            print 'findChessboardCorners : True'\n\n            # \u73fe\u5728\u306eOpenCV\u3067\u306ffindChessboardCorners()\u5185\u3067\u3001cornerSubPix()\u76f8\u5f53\u306e\u51e6\u7406\u304c\u5b9f\u65bd\u3055\u308c\u3066\u3044\u308b\uff1f\u8981\u78ba\u8a8d\n            #term = (cv2.TERM_CRITERIA_EPS + cv2.TERM_CRITERIA_COUNT, 30, 0.1)\n            #cv2.cornerSubPix(grayscale_image, corner, (5,5), (-1,-1), term)\n            #cv2.drawChessboardCorners(grayscale_image, grid_intersection_size, corner, found)\n\n            cv2.drawChessboardCorners(frame, grid_intersection_size, corner, found)\n        if found == False:\n            print 'findChessboardCorners : False'\n\n        cv2.putText(frame, \"Enter:Capture Chessboard(\" + str(capture_count) + \")\", (100, 50), cv2.FONT_HERSHEY_SIMPLEX, 0.4, (0,0,255), 1)\n        cv2.putText(frame, \"N    :Completes Calibration Photographing\", (100, 75), cv2.FONT_HERSHEY_SIMPLEX, 0.4, (0,0,255), 1)\n        cv2.putText(frame, \"ESC  :terminate program\", (100, 100), cv2.FONT_HERSHEY_SIMPLEX, 0.4, (0,0,255), 1)\n        #cv2.putText(grayscale_image, \"Enter:Capture Chessboard(\" + str(capture_count) + \")\", (100, 50), cv2.FONT_HERSHEY_SIMPLEX, 0.4, (0,0,255), 1)\n        #cv2.putText(grayscale_image, \"ESC  :Completes Calibration Photographing.\", (100, 75), cv2.FONT_HERSHEY_SIMPLEX, 0.4, (0,0,255), 1)\n        cv2.imshow('original', frame)\n        #cv2.imshow('findChessboardCorners', grayscale_image)\n\n        c = cv2.waitKey(50) & 0xFF\n        if c == 13 and found == True: # Enter\n            # \u30c1\u30a7\u30b9\u30dc\u30fc\u30c9\u30b3\u30fc\u30ca\u30fc\u691c\u51fa\u60c5\u5831\u3092\u8ffd\u52a0\n            image_points.append(corner)\n            object_points.append(pattern_points)\n            capture_count += 1\n        if c == 110: # N\n            if tkMessageBox.askyesno('askyesno','\u30c1\u30a7\u30b9\u30dc\u30fc\u30c9\u64ae\u5f71\u3092\u7d42\u4e86\u3057\u3001\u30ab\u30e1\u30e9\u5185\u90e8\u30d1\u30e9\u30e1\u30fc\u30bf\u3092\u6c42\u3081\u307e\u3059\u304b\uff1f'):\n                cv2.destroyAllWindows()\n                break\n        if c == 27: # ESC\n            if tkMessageBox.askyesno('askyesno','\u30d7\u30ed\u30b0\u30e9\u30e0\u3092\u7d42\u4e86\u3057\u307e\u3059\u304b\uff1f'):\n                video_input.release()\n                cv2.destroyAllWindows()\n                exit()\n\n    if len(image_points) > 0:\n        # \u30ab\u30e1\u30e9\u5185\u90e8\u30d1\u30e9\u30e1\u30fc\u30bf\u3092\u8a08\u7b97\n        print 'calibrateCamera() start'\n        rms, K, d, r, t = cv2.calibrateCamera(object_points,image_points,(frame.shape[1],frame.shape[0]),None,None)\n        print \"RMS = \", rms\n        print \"K = \\n\", K\n        print \"d = \", d.ravel()\n        np.savetxt(\"K.csv\", K, delimiter =',',fmt=\"%0.14f\") #\u30ab\u30e1\u30e9\u884c\u5217\u306e\u4fdd\u5b58\n        np.savetxt(\"d.csv\", d, delimiter =',',fmt=\"%0.14f\") #\u6b6a\u307f\u4fc2\u6570\u306e\u4fdd\u5b58\n\n        camera_mat = K\n        dist_coef = d\n\n        # \u518d\u6295\u5f71\u8aa4\u5dee\u306b\u3088\u308b\u8a55\u4fa1\n        mean_error = 0\n        for i in xrange(len(object_points)):\n            image_points2, _ = cv2.projectPoints(object_points[i], r[i], t[i], camera_mat, dist_coef)\n            error = cv2.norm(image_points[i], image_points2, cv2.NORM_L2) / len(image_points2)\n            mean_error += error\n        print \"total error: \", mean_error/len(object_points) # 0\u306b\u8fd1\u3044\u5024\u304c\u671b\u307e\u3057\u3044(\u9b5a\u773c\u30ec\u30f3\u30ba\u306e\u8a55\u4fa1\u306b\u306f\u4e0d\u9069\uff1f)\n    else:\n        print \"findChessboardCorners() not be successful once\"\n\n# \u6b6a\u307f\u88dc\u6b63\u753b\u50cf\u8868\u793a\nif camera_mat != []:\n    while(True):\n        ret, frame = video_input.read()\n        undistort_image = cv2.undistort(frame, camera_mat, dist_coef)\n\n        cv2.imshow('original', frame)\n        cv2.imshow('undistort', undistort_image)\n        c = cv2.waitKey(50) & 0xFF\n        if c==27: # ESC\n            break\n\nvideo_input.release()\ncv2.destroyAllWindows()\n```\n\n\u4ee5\u4e0a\u3002\n", "tags": ["OpenCV", "Python", "\u9b5a\u773c\u30ec\u30f3\u30ba"]}