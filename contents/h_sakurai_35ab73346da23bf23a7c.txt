{"context": " More than 1 year has passed since last update.\u4eca\u56de\u306f\u30d1\u30fc\u30b5\u3068\u578b\u30c1\u30a7\u30c3\u30af\u3092\u4f5c\u308a\u307e\u3059\u3002Scala\u3060\u3068\u30d1\u30fc\u30b5\u30b3\u30f3\u30d3\u30cd\u30fc\u30bf\u306e\u30e9\u30a4\u30d6\u30e9\u30ea\u304c\u6a19\u6e96\u3067\u3064\u3044\u3066\u3044\u308b\u306e\u3067\u305d\u308c\u3092\u4f7f\u3044\u307e\u3059\u3002PackRatParser\u3092\u4f7f\u3046\u3068\u30e1\u30e2\u5316\u3055\u308c\u30e1\u30e2\u30ea\u306f\u98df\u3044\u307e\u3059\u304c\u9ad8\u901f\u306b\u51e6\u7406\u3067\u304d\u308b\u305d\u3046\u3067\u3059\u306e\u3067\u3001\u3053\u3061\u3089\u3092\u4f7f\u3044\u307e\u3057\u305f\u3002\u307e\u305f\u3001\u6b63\u898f\u8868\u73fe\u3082\u4f7f\u3044\u305f\u3044\u306e\u3067\u3001RegexpParser\u3092\u4f7f\u3044\u307e\u3057\u305f\u3002\n\u30d1\u30fc\u30b5\u30b3\u30f3\u30d3\u30cd\u30fc\u30bf\u306e\u826f\u3044\u6240\u306f\u5c0f\u3055\u3044\u30d1\u30fc\u30b5\u3092\u5148\u306b\u4f5c\u3063\u3066\u305d\u308c\u3092\u5143\u306b\u62e1\u5f35\u3057\u3066\u884c\u3051\u3070\u3088\u3044\u306e\u3067\u4f5c\u308b\u306e\u304c\u697d\u3067\u3059\u3002\u307e\u305f\u3001Yacc\u3068\u306f\u9055\u3063\u3066\u30b3\u30f3\u30d5\u30ea\u30af\u30c8\u304c\u8d77\u304d\u306a\u3044\u306e\u3067\u7c21\u5358\u3067\u3059\u3002\u304a\u624b\u8efd\u306a\u30d1\u30fc\u30b5\u3092\u66f8\u304f\u306a\u3089\u30d1\u30fc\u30b5\u30b3\u30f3\u30d3\u30cd\u30fc\u30bf\u306f\u826f\u3044\u3082\u306e\u3067\u3059\u3002\n\u30d1\u30fc\u30b5\u3092\u4f5c\u308b\u3060\u3051\u3067\u3001\u7d42\u308f\u3089\u305b\u305f\u3044\u6240\u3067\u3059\u304c\u3001\u69cb\u9020\u4f53\u3084\u30f4\u30a1\u30ea\u30a2\u30f3\u30c8\u306e\u578b\u3092\u4f7f\u3046\u306b\u306ftypedef\u5ba3\u8a00\u306e\u3088\u3046\u306a\u69cb\u6587\u304c\u306a\u3044\u3068\u4e0d\u4fbf\u306a\u306e\u3067\u3001\u305d\u3061\u3089\u3082\u8ffd\u52a0\u3057\u307e\u3057\u305f\u3002\n\u578b\u306e\u30c1\u30a7\u30c3\u30af\u3068\u578b\u63a8\u8ad6\u306f\u4f3c\u3066\u3044\u308b\u306e\u3067\u3059\u304c\u3001\u63a8\u8ad6\u306f\u5927\u5909\u306a\u306e\u3067\u30c1\u30a7\u30c3\u30af\u3092\u3057\u3064\u3064\u63a8\u8ad6\u3063\u307d\u3044\u3053\u3068\u304c\u51fa\u6765\u305d\u3046\u306a\u6642\u3060\u3051\u63a8\u8ad6\u3063\u307d\u3044\u3053\u3068\u3092\u3057\u3066\u307f\u307e\u3059\u3002\n\u578b\u63a8\u8ad6\u3063\u307d\u3044\u5b9f\u88c5\u306b\u3064\u3044\u3066\u306f\u30012\u9031\u9593\u3067\u51fa\u6765\u308b\uff01\u30b9\u30af\u30ea\u30d7\u30c8\u8a00\u8a9e\u306e\u4f5c\u308a\u65b9[1]\u3092\u53c2\u8003\u306b\u3057\u307e\u3057\u305f\u3002\n\u30d1\u30fc\u30b5\u30b3\u30f3\u30d3\u30cd\u30fc\u30bf\u306e\u4f5c\u6210\u306f\u3001Packrat Parser\u3092\u4f7f\u3063\u3066\u307f\u305f[2]\u3084\u3001tapl-scala[3] \u3092\u53c2\u8003\u306b\u3057\u307e\u3057\u305f\u3002\n\u6b63\u898f\u8868\u73fe\u306e\u30d1\u30fc\u30b5\u30b3\u30f3\u30d3\u30cd\u30fc\u30bf\u306b\u3064\u3044\u3066\u306f\u3001RegexParsers\u3067\u624b\u8efd\u306bScala\u306e\u30d1\u30fc\u30b5\u30b3\u30f3\u30d3\u30cd\u30fc\u30bf\u3092\u4f7f\u3063\u3066\u307f\u308b[4]\u3092\u53c2\u8003\u306b\u3057\u307e\u3057\u305f\u3002\n\n\u578b\u30c1\u30a7\u30c3\u30af\u306e\u5b9f\u88c5\n\u3053\u306e\u578b\u30c1\u30a7\u30c3\u30af\u306e\u5b9f\u88c5\u3068\u30d1\u30fc\u30b5\u306e\u4f5c\u6210\u306e\u89e3\u8aac\u306f\u3001\u578b\u30c1\u30a7\u30c3\u30af\u306e\u5b9f\u88c5\u304b\u3089\u66f8\u3044\u3066\u3042\u308a\u307e\u3059\u304c\u3001\u30d1\u30fc\u30b5\u304b\u3089\u5b9f\u88c5\u3057\u305f\u65b9\u304c\u826f\u3044\u3068\u601d\u3044\u307e\u3059\u3002\u3042\u3042\u3001\u578b\u30c1\u30a7\u30c3\u30af\u304c\u5fc5\u8981\u3060\u3002\u3063\u3066\u7b87\u6240\u304c\u51fa\u3066\u304d\u307e\u3059\u306e\u3067\u3002\u305d\u3053\u306e\u5bfe\u7b56\u304c\u3053\u306e\u578b\u30c1\u30a7\u30c3\u30af\u306e\u5b9f\u88c5\u3067\u3059\u3002\u3053\u3061\u3089\u306e\u5b9f\u88c5\u3092\u5148\u306b\u66f8\u3044\u3066\u3044\u308b\u306e\u306f\u3001\u578b\u30c1\u30a7\u30c3\u30af\u306e\u5b9f\u88c5\u3092\u5148\u306b\u4f5c\u3063\u3066\u3082\u30a8\u30e9\u30fc\u304c\u51fa\u306a\u3044\u304b\u3089\u3067\u3059\u3002\n\u74b0\u5883\u3092\u4f5c\u3063\u3066\u578b\u3092\u74b0\u5883\u306b\u4fdd\u5b58\u3057\u3001\u307e\u305f\u53d6\u308a\u51fa\u3057\u3066\u53d6\u308a\u51fa\u3057\u3066\u3001\uff12\u9805\u6f14\u7b97\u5b50\u306e\u578b\u3092\u6c42\u3081\u308b\u3068\u8a00\u3063\u305f\u51e6\u7406\u3092\u8ffd\u52a0\u3057\u307e\u3059\u3002\n\u03b1\u5909\u63db\u3092\u884c\u3063\u305f\u5f8c\u306b\u578b\u30c1\u30a7\u30c3\u30af\u3092\u884c\u3046\u4e8b\u3067\u3001\u540d\u524d\u304c\u3076\u3064\u304b\u3089\u306a\u3044\u3088\u3046\u306b\u306a\u3063\u3066\u3044\u307e\u3059\u304c\u3001\u3053\u308c\u304c\u826f\u3044\u4e8b\u306a\u306e\u304b\u3069\u3046\u304b\u306f\u5206\u304b\u308a\u307e\u305b\u3093\u3002\u3068\u306b\u304b\u304f\u3001\u3046\u307e\u304f\u3044\u3063\u3066\u3044\u308c\u3070\u3044\u3044\u3067\u3059\u3088\u306d\u3002\u305d\u308c\u3067\u3001\u30c6\u30b9\u30c8\u7684\u306a\u30d7\u30ed\u30b0\u30e9\u30e0\u304c\u52d5\u4f5c\u3059\u308b\u304f\u3089\u3044\u307e\u3067\u51fa\u6765\u305f\u3089\u7d42\u4e86\u3068\u3057\u307e\u3057\u305f\u3002\nimport util.parsing.input.Positional\n\nsealed trait E \u3092Positional\u3092\u7d99\u627f\u3057\u3066\u4f4d\u7f6e\u60c5\u5831\u3092\u683c\u7d0d\u51fa\u6765\u308b\u3088\u3046\u306b\u3057\u307e\u3059\u3002\nsealed trait E extends Positional {\n\n\u30bf\u30a4\u30d7\u5ba3\u8a00\u7528\u306e\u578b\u3068\u3001Switch\u30b1\u30fc\u30b9\u7528\u306e\u30d1\u30fc\u30b5\u7528\u306eECase\u3092\u8ffd\u52a0\u3057\u307e\u3059\u3002\ncase class EType(t:T, id:String) extends E\ncase class ECase(t:T, e:E) extends E\n\nsealed trait T \u3092Positional\u3092\u7d99\u627f\u3057\u3066\u4f4d\u7f6e\u60c5\u5831\u3092\u683c\u7d0d\u51fa\u6765\u308b\u3088\u3046\u306b\u3057\u307e\u3059\u3002\nsealed trait T extends Positional\n\n\u578b\u306e\u6c7a\u307e\u3063\u3066\u3044\u306a\u3044\u578bTn\u3068\u578b\u306e\u540d\u524d\u6307\u5b9a\u578bTDef\u306e\u8ffd\u52a0\u3092\u3057\u307e\u3059\u3002\ncase object Tn extends T\ncase class TDef(id:String) extends T\n\n\u30c6\u30b9\u30c8\u30b3\u30fc\u30c9\u306e\u8ffd\u52a0\u3092\u3057\u307e\u3059\u3002\n        EType(TStr(List((\"a\", Ti(32)), (\"b\", Ti(32)))), \"Dt\"),\n        EVal(TDef(\"Dt\"), \"a2\", null),\n        EAssign(Ti(32), EField(Ti(32), \"a2\", \"a\"), ELdc(Ti(32), 9)),\n        EPrint(Ti(32), EField(Ti(32), \"a2\", \"a\"))\n\n\u03b1\u5909\u63db\u306b\u578b\u306e\u8ffd\u52a0\u3057\u307e\u3059\u3002\n      case e @ EType(t:T, id:String) => (e.copy(t, id), env)\n      case e : ECase => throw new Exception(\"error\")\n\nkNormal\u306bTDef\u5bfe\u7b56\u3067\u3001env.stripT\u3092\u5165\u308c\u3001\u578b\u304c\u69cb\u9020\u4f53\u304b\u30f4\u30a1\u30ea\u30a2\u30f3\u30c8\u3060\u3063\u305f\u3089\u578b\u3092\u5909\u3048\u3066\u518d\u5ea6\u8aad\u307f\u8fbc\u307f\u3057\u307e\u3059\u3002\nenv.stripT\u306f\u578b\u306bTDef\u304c\u5165\u3063\u3066\u3044\u305f\u5834\u5408\u306b\u3001TDef\u3092\u53d6\u308a\u9664\u304f\u51e6\u7406\u3067\u3059\u3002TDef\u304c\u90aa\u9b54\u306a\u306e\u3067\u3069\u3053\u304b\u3067\u5947\u9e97\u306b\u53d6\u308a\u9664\u304d\u305f\u3044\u6240\u3067\u3059\u304c\u3001\u30a2\u30c9\u30db\u30c3\u30af\u306b\u30a8\u30e9\u30fc\u304c\u51fa\u305f\u7b87\u6240\u306b\u5165\u308c\u3066\u3044\u307e\u3059\u3002\n        f(a) match {\n          case a =>\n            add(LLAssign(RL(a.t, id), a))\n            RL(a.t, id)\n        }\n\n\u2193\n        val t2 = env.stripT(t)\n        t2 match {\n          case t: TStr => f(e.copy(t = t))\n          case t: TVariant => f(e.copy(t = t))\n          case _ =>\n            f(a) match {\n              case a =>\n                add(LLAssign(RL(a.t, id), a))\n                RL(a.t, id)\n            }\n        }\n\nenv.stripT\u3092\u5165\u308c\u307e\u3059\u3002\n            if (t != b.t) throw new Exception(\"type mismatch \" + t + \" \" + b.t)\n\n\u2193\n            if (env.stripT(t) != env.stripT(b.t)) throw new Exception(\"type mismatch \" + t + \" \" + b.t)\n\nenv.stripT\u3092\u5165\u308c\u307e\u3059\u3002\n       val (_, _, maxT, _) = emit.llvariantInfo(a.t.asInstanceOf[TVariant])\n\n\u2193\n        val (_, _, maxT, _) = emit.llvariantInfo(env.stripT(a.t).asInstanceOf[TVariant])\n\nenv.stripT\u3092\u5165\u308c\u307e\u3059\u3002\n        env.stripT(a.t) match {\n          case t:TVariant => return f(e.copy(t=t))\n          case _ =>\n        }\n\n\u30bf\u30a4\u30d7\u3092\u8ffd\u52a0\u3057\u307e\u3059\u3002\n      case EType(t: T, id: String) =>\n        env.map = env.map + (id -> RR(t, null))\n        null\n\n\u8ffd\u52a0\u51e6\u7406\u3092\u8ffd\u52a0\u3057\u307e\u3059\u3002\n  def add(id:String, r:R) {\n    map = map + (id -> r)\n  }\n  def findTag(t:TVariant, id:String):TStr = {\n    for((tag,t) <- t.ls) {\n      if(tag==id) return t\n    }\n    throw new Exception(\"not found tag \"+id)\n  }\n  def stripT(t:T):T = {\n    t match {\n      case TDef(id) =>\n        val r = env.map(id)\n        if(r.id != null) throw new Exception(id + \" is not type\")\n        stripT(r.t)\n      case t => t\n    }\n  }\n\n      case t:TDef => llt(env.stripT(t))\n      case Tn => throw new Exception(\"error\")\n\nenv.stripT\u3092\u5165\u308c\u307e\u3059\u3002\n    t match {\n\n\u2193\n    env.stripT(t) match {\n\nTn,TDef\u306f\u7121\u3044\u306f\u305a\u306a\u306e\u3067\u30a8\u30e9\u30fc\u306b\u3057\u307e\u3059\u3002\n      case Tn => throw new Exception(\"error\")\n      case t:TDef => throw new Exception(\"error\")\n\n\n\u30d1\u30fc\u30b5\u306e\u5b9f\u88c5\n\u5b9f\u88c5\u306f\u306f\u3058\u3081\u306b\u6570\u5024\u3068\u8b58\u5225\u5b50\u3092\u5b9f\u88c5\u3057\u3066\u52d5\u304b\u3057\u3066\u307f\u307e\u3057\u305f\u3002\u6b21\u306b\u3001\u8db3\u3057\u7b97\u3001\u304b\u3051\u7b97\u3068print\u306e\u5b9f\u88c5\u3002AST\u3092\u30b3\u30f3\u30d1\u30a4\u30eb\u3057\u3066\u3057\u307e\u3048\u3070\u3001\u52d5\u304f\u306e\u3067\u52d5\u304b\u3057\u306a\u304c\u3089\u3001\u5f8c\u306f\u3001AST\u306e\u30c6\u30b9\u30c8\u3092\u518d\u73fe\u3059\u308b\u30b3\u30fc\u30c9\u3092\u66f8\u3044\u3066\u3001\u30c6\u30b9\u30c8\u3057\u306a\u304c\u3089\u6210\u9577\u3055\u305b\u3066\u884c\u304d\u307e\u3057\u305f\u3002\u305d\u308c\u3067\u3001\u578b\u306e\u30c1\u30a7\u30c3\u30af\u304c\u5fc5\u8981\u306a\u7b87\u6240\u304c\u3067\u3066\u6765\u305f\u306e\u3067\u30b3\u30e1\u30f3\u30c8\u30a2\u30a6\u30c8\u3057\u3066\u30d1\u30fc\u30b5\u3092\u4f5c\u308b\u3060\u3051\u3067\u98db\u3070\u3057\u305f\u308a\u3057\u3066\u5148\u306b\u4f5c\u3063\u3066\u3044\u307e\u3057\u305f\u3002\n\nparse.scala\u306e\u5b9f\u88c5\npackage chapter11\n\nimport util.parsing.combinator._\nimport util.parsing.input.Positional\n\nobject parser extends RegexParsers with PackratParsers {\n  def p(e:PackratParser[E]) = positioned(e)\n  def t(e:PackratParser[T]) = positioned(e)\n\n  // skip C/C++ style comments and whitespace.\n  override protected val whiteSpace = \"\"\"((/\\*(?:.|\\r|\\n)*?\\*/)|//.*|\\s+)+\"\"\".r\n\n  lazy val id: PackratParser[String] = memo(\"\"\"[A-Za-z_][\\w_]*\"\"\".r)\n  lazy val lng: PackratParser[E] = p(memo(\"\"\"(0|[1-9][0-9]*)\"\"\".r  ^^ {case a => ELdc(Ti(32),a.toLong)}))\n  lazy val tpl: PackratParser[E] = p((\"(\" ~> expr) ~ rep(\",\" ~> expr) <~ \")\" ^^ { case a~b => ETuple(Tn, a::b) })\n  lazy val tpl2: PackratParser[List[E]] = (\"(\" ~> expr) ~ rep(\",\" ~> expr) <~ \")\" ^^ { case a~b => a::b }\n  lazy val _val: PackratParser[E] = p((\"val\" ~> id)~ (\"=\" ~> lng) ^^ { case a~b => EVal(Ti(32),a,b)} |\n    (\"val\" ~> id)~ (\":\" ~> id) ~ (\"=\" ~> id) ~ tpl2 ^^ { case a~t~id~ls => EVal(mkT(t),a,ETag(mkT(t),id,ls))} |\n    (\"val\" ~> id)~ (\":\" ~> id) ~ (\"=\" ~> tpl) ^^ { case a~t~tpl => EVal(mkT(t),a,tpl)} |\n    (\"val\" ~> id)~ (\":\" ~> id) ~ (\"=\" ~> expr) ^^ { case a~t~tpl => EVal(mkT(t),a,tpl)} |\n    (\"val\" ~> id)~ (\":\" ~> id) ^^ { case a~t => EVal(mkT(t),a,null)})\n\n  lazy val _id: PackratParser[E] = p(id ^^ { case a => EId(Tn, a)})\n\n  def calc(op: String, op2:String):PackratParser[(E,E)=>E] = op ^^ {\n    a => (a:E,b:E) => Op(op2)(Tn, a, b)\n  }\n  lazy val eq: PackratParser[E] = p(expr ~ rep( \"=\" ~> expr) ^^ {\n    case a~b =>\n      b.foldLeft(a){case (a,b) => EAssign(Ti(32), a, b)}})\n  lazy val t1: PackratParser[E] = p(chainl1(eq,eq, calc(\"*\",\"mul\") | calc(\"/\",\"div\") | calc(\"%\",\"mod\")))\n  lazy val term: PackratParser[E] = p(chainl1(t1, t1, calc(\"+\",\"add\") | calc(\"-\",\"sub\")))\n  lazy val print: PackratParser[E] = p(\"print_i\" ~> \"(\" ~> expr <~ \")\" ^^ {case a => EPrint(Ti(32),a) })\n  lazy val block: PackratParser[E] = p(\"{\" ~> rep(expr) <~ \"}\" ^^ {case a => EBlock(Tv,a)})\n  lazy val typ: PackratParser[T] = t(id ^^ {case a => mkT(a)})\n  lazy val ctyps: PackratParser[List[(String,TStr)]] = rep((id <~ \"(\") ~ (typs <~ \")\") ^^ { case a~b => (a,TStr(b))}) \n  lazy val typs: PackratParser[List[(String,T)]] = rep((id <~ \":\") ~ typ ^^ { case a~b => (a,b)}) \n  lazy val typdef: PackratParser[E] = (\"type\" ~> id) ~ (\"=\" ~> \"struct\" ~> \"{\" ~> typs <~ \"}\") ^^ { case a~b => EType(TStr(b), a)} |\n    (\"type\" ~> id) ~ (\"=\" ~> \"enum\" ~> \"{\" ~> ctyps <~ \"}\") ^^ { case a~b => EType(TVariant(b), a)}\n\n  lazy val fields: PackratParser[E] = (id <~ \".\") ~ id ^^ { case a~b => EField(Ti(32),a,b)}\n  lazy val cases: PackratParser[List[(E,E)]] =  rep((\"case\" ~> ((lng^^ {case a=>ECase(Tn,a)})|tag)  <~ \":\") | expr ) ^^ {case a:List[E] =>\n    a.foldLeft(List[(E,E)]()){\n      case (l,ECase(_,a)) => (a,EBlock(Tv,List()))::l\n      case ((tag,EBlock(_,bls))::ls,a) => (tag,EBlock(Tv,bls:::List(a)))::ls\n      case _ => throw new Exception(\"error\")\n    }.reverse\n  }    \n  lazy val switch: PackratParser[E] = (\"switch\" ~> \"(\" ~> expr <~ \")\") ~ (\"{\" ~> cases <~ \"}\") ^^ {case a~b => ESwitch(Ti(32), a, b)} \n  lazy val tpl3: PackratParser[List[String]] = (\"(\" ~> id) ~ rep(\",\" ~> id) <~ \")\" ^^ { case a~b => a::b }\n  lazy val tag: PackratParser[ECase] = id ~ tpl3 ^^ {case a~b => ECase(Tn,ETag(Tn,a,b.map{case a => EVal(Tn,a,null)}))}\n  lazy val expr: PackratParser[E] = typdef | term | block | switch | print | lng | _val | fields | _id\n\n  def mkT(a:String):T = {\n    a match {\n      case \"Int\" => Ti(32)\n      case a => TDef(a)\n    }\n  }\n}\n\nobject typing {\n\n  def apply(e:E):E = {\n    val r = f(e)\n    env.map=Map()\n    r\n  }\n  def add(id:String, t:T):T = {\n    env.add(RL(t,id))\n    t\n  }\n  def f(e:E):E = {\n    e match {\n      case e @ ELdc(Tn, i:Long) => e.copy(t=Ti(32))\n      case e @ ELdc(t:T, i:Long) => e\n      case e @ EBin(t:T, s:String, l:E, r:E) => val (l2,r2) = (f(l),f(r)); e.copy(t=l2.t, l=l2, r=r2)\n      case e @ EPrint(t:T, a:E) => val a2 = f(a); e.copy(a2.t, a2)\n      case e @ EBlock(t: T, ls: List[E]) => e.copy(ls=ls.map(f))\n      case e @ EVal(Tn, id: String, a: E) => val a2 = f(a); e.copy(t=add(id,a.t), a=a2)\n      case e @ EVal(t: T, id: String, null) => add(id,t); e \n      case e @ EVal(t: T, id: String, a: ETuple) => e.copy(t=add(id,t), a=f(a.copy(t=t))) \n      case e @ EVal(t: T, id: String, a: E) =>\n        val a2 = f(a)\n        if(env.stripT(a2.t) != env.stripT(t)) throw new Exception(\"error \"+a2+\" \"+a2.t +\" != \"+t)\n        e.copy(t=add(id,t), a=a2) \n      case e @ EId(t: T, id: String) => val r=env.map(id); e.copy(t=r.t)\n      case e @ EAssign(t: T, a: E, b: E) => val a2 = f(a); val b2 = f(b); e.copy(a2.t, a2, b2)\n      case e @ EField(Tn, id: String, idx: String) => val r = env.map(id); f(e.copy(t=r.t))\n      case e @ EField(t: T, id: String, idx: String) =>\n        t match {\n          case t@TStr(ls) => val (idx2,tt) = T.find(t, idx); e.copy(t=tt)\n          case t:TDef => env.stripT(t) match { case t:TDef => throw new Exception(\"type error \"+t) case t => println(t); f(e.copy(t=t)) }\n          case t => e\n        }\n      case e @ ETuple(t:T,ls:List[E]) => e.copy(ls=ls.map(f))\n      case e @ ETag(t:T,id:String,ls:List[E]) => val r = env.map(id); e.copy(t=r.t,ls=ls.map(f) )\n      case e @ ESwitch(t: T, d: E, cases:List[(E,E)] ) =>\n        val d2 = f(d)\n        val dt = env.stripT(d2.t)\n        e.copy(\n            a=d2,\n            cases=cases.map{\n              case (a@ETag(t,id,ls),b)=>\n                val ls2 = env.findTag(dt.asInstanceOf[TVariant],id).types.zip(ls) map {\n                  case ((_,t), e @ EVal(_,id2,_)) => add(id2,t); e.copy(t,id2)\n                  case _ => throw new Exception(\"error\")\n                }\n                (a.copy(t=dt,ls=ls2), f(b))\n              case (a,b) => (a,f(b))\n            })\n      case e @ EUnit => e\n      case e @ EType(t@TVariant(ls), id:String) => env.add(id, RR(t,null));for((tag,_)<-ls) env.add(tag, RR(t,null));  e\n      case e @ EType(t:T, id:String) => env.add(id, RR(t, null)); e\n      case e @ ECase(t:T, a:E) => f(a)\n    }\n  }\n}\n\nobject parseTest {\n\n  def main(args:Array[String]) {\n    run(\"\"\"{\n        print_i(100+2*3)\n        print_i(10)\n        print_i(20)\n    }\"\"\")\n    run(\"\"\"{\n        val a = 10\n        print_i(a)\n        print_i(a+10*a)\n    }\"\"\")\n\n    // \u69cb\u9020\u4f53\n    run(\"\"\"{\n        type SA = struct { a:Int b:Int }\n        val c = 10\n        val aa:SA\n        aa.a = 9\n        aa.b = c\n        print_i(aa.a)\n        print_i(aa.b)\n    }\"\"\")\n    // \u69cb\u9020\u4f53\u521d\u671f\u5316\u30ea\u30c6\u30e9\u30eb\n    run(\"\"\"{\n        type SA = struct { a:Int b:Int }\n        val ab:SA = (123,456)\n        print_i(ab.a)\n        print_i(ab.b)\n    }\"\"\")\n    // \u30f4\u30a1\u30ea\u30a2\u30f3\u30c8\n    run(\"\"\"{\n        type Data = enum { A(a:Int) B(a:Int b:Int) }\n        val data:Data\n        val data2:Data = B(555,777)\n    }\"\"\")\n    run(\"\"\"{\n        // switch\n        switch(2) {\n        case 1: print_i(10001)\n        case 2: print_i(10002)\n        case 3: print_i(10003) print_i(10004)\n        }\n        print_i(1)\n        switch(0) {\n        case 1: print_i(10001)\n        case 2: print_i(10002)\n        case 3: print_i(10003)\n        }\n    }\"\"\")\n    run(\"\"\"{\n\n        // alpha test\n        val a = 1000\n        print_i(a)\n        val a:Int = a + 2000\n        print_i(a)\n        // alpha block test\n        {\n          val a = 5000\n          print_i(a)\n        }\n        print_i(a)\n    }\"\"\")\n    run(\"\"\"{\n        type Data = enum { A(a:Int) B(a:Int b:Int) }\n        val data2:Data = B(555,777)\n        // match\u69cb\u6587\n        switch(data2) {\n        case A(x) : print_i(x)\n        case B(x,y) : print_i(x) print_i(y)\n        }\n        val data3:Data = A(333)\n        switch(data3) {\n        case A(x) : print_i(x)\n        case B(x,y) : print_i(x) print_i(y)\n        }\n        val x = 10\n        print_i(x)\n    }\"\"\")\n  }\n\n  def run(src:String) {\n    println(\"src=\"+src)\n    val result = parser.parseAll(parser.block,src)\n    if(!result.successful) {\n      println(result)\n      throw new Exception(result+\"\")\n    }\n    val ast = result.get\n\n    env.map = Map(\"Int\"->RR(Ti(32),null))\n    println(\"ast=\"+ast)\n    val ast2 = alpha(ast)\n    val ast3 = typing(ast2)\n    println(\"ast3=\"+ast3)\n    val ll = kNormal(ast3)\n    println(\"ll=\" + ll)\n    val ll2 = constFold(ll)\n    emit(\"e.ll\", ll2)\n    println(exec(\"llc e.ll -o e.s\"))\n    println(exec(\"llvm-gcc -m64 e.s -o e\"))\n    println(exec(\"./e\"))\n  }\n}\n\n\ncore.scala\npackage chapter11\n\nimport java.io._\nimport util.parsing.input.Positional\n\nsealed trait E extends Positional {\n  def t:T\n}\ncase class ELdc(t:T, i:Long) extends E\ncase class EBin(t:T, s:String, l:E, r:E) extends E\ncase class EPrint(t:T, a:E) extends E\ncase class EBlock(t: T, ls: List[E]) extends E\ncase class EVal(t: T, id: String, a: E) extends E\ncase class EId(t: T, id: String) extends E\ncase class EAssign(t: T, a: E, b: E) extends E\ncase class EField(t: T, id: String, idx: String) extends E\ncase class ETuple(t:T,ls:List[E]) extends E\ncase class ETag(t:T,id:String,ls:List[E]) extends E\ncase class ESwitch(t: T, a: E, cases:List[(E,E)] ) extends E\ncase object EUnit extends E { def t = Tv }\ncase class EType(t:T, id:String) extends E\ncase class ECase(t:T, e:E) extends E\n\nsealed trait T extends Positional\ncase class Ti(i:Int) extends T\ncase object Tv extends T\ncase object Tn extends T\ncase class TFun(t: T, prms: List[T]) extends T\ncase class TStr(types: List[(String, T)]) extends T\ncase class TVariant(ls:List[(String,TStr)]) extends T\ncase class Tp(t:T) extends T\ncase class TDef(id:String) extends T\n\nobject T {\n  def find(t:TStr, a: String): (Int, T) = {\n    def f(i: Int, xs: List[(String, T)]): (Int, T) = {\n      xs match {\n        case List() => (-1, Tv)\n        case (x, t) :: xs => if (a == x) (i, t) else f(i + 1, xs)\n      }\n    }\n    f(0, t.types)\n  }\n}\n\ncase class Op(s: String) {\n  def apply(t: T, a: E, b: E): E = {\n    EBin(t, s, a, b)\n  }\n}\nobject EAdd extends Op(\"add\")\nobject EMul extends Op(\"mul\")\n\nsealed trait R {\n  def t:T\n  def id:String\n}\ncase class RG(t:T, id: String) extends R\ncase class RL(t:T, id: String) extends R\ncase class RR(t:T, id: String) extends R\ncase class RN(t:T, id: String) extends R\n\nobject test {\n  def main(argv: Array[String]) {\n    try {\n      val t = TVariant(List(\n          \"A\"->TStr(List(\"a\"->Ti(32))),\n          \"B\"->TStr(List(\"a\"->Ti(32), \"b\"->Ti(32)))\n        ))\n      val ast = EBlock(Tv, List(\n        EPrint(Ti(32), ELdc(Ti(32), 11)),\n        EPrint(Ti(32), EAdd(Ti(32), ELdc(Ti(32), 11), ELdc(Ti(32), 22))),\n        // \u5909\u6570 a \u5b9a\u6570\n        EVal(Ti(32), \"a\", ELdc(Ti(32), 11)),\n        EPrint(Ti(32), EId(Ti(32), \"a\")),\n        // \u5909\u6570 b \u8db3\u3057\u7b97\n        EVal(Ti(32), \"b\", EAdd(Ti(32), ELdc(Ti(32), 11), ELdc(Ti(32), 22))),\n        EPrint(Ti(32), EId(Ti(32), \"b\")),\n        // \u5909\u6570 c \u5909\u6570\u306e\u5024\n        EVal(Ti(32), \"c\", EId(Ti(32), \"a\")),\n        EPrint(Ti(32), EId(Ti(32), \"c\")),\n        // \u69cb\u9020\u4f53\n        EVal(TStr(List((\"a\", Ti(32)), (\"b\", Ti(32)))), \"aa\", null),\n        EAssign(Ti(32), EField(Ti(32), \"aa\", \"a\"), ELdc(Ti(32), 9)),\n        EAssign(Ti(32), EField(Ti(32), \"aa\", \"b\"), EId(Ti(32), \"c\")),\n        EPrint(Ti(32), EField(Ti(32), \"aa\", \"a\")),\n        EPrint(Ti(32), EField(Ti(32), \"aa\", \"b\")),\n        // \u69cb\u9020\u4f53\u521d\u671f\u5316\u30ea\u30c6\u30e9\u30eb\n        EVal(TStr(List((\"a\", Ti(32)), (\"b\", Ti(32)))), \"ab\",\n          ETuple(TStr(List((\"a\", Ti(32)), (\"b\", Ti(32)))),\n            List(ELdc(Ti(32),123),ELdc(Ti(32),456)))),\n        EPrint(Ti(32), EField(Ti(32), \"ab\", \"a\")),\n        EPrint(Ti(32), EField(Ti(32), \"ab\", \"b\")),\n\n        // \u30f4\u30a1\u30ea\u30a2\u30f3\u30c8\n        EVal(TVariant(List(\n          \"A\"->TStr(List(\"a\"->Ti(32))),\n          \"B\"->TStr(List(\"a\"->Ti(32), \"b\"->Ti(32)))\n        )),\"data\", null),\n\n        EVal(TVariant(List(\n            \"A\"->TStr(List(\"a\"->Ti(32))),\n            \"B\"->TStr(List(\"a\"->Ti(32), \"b\"->Ti(32)))\n          )),\n          \"data2\",\n          ETag(TVariant(List(\n            \"A\"->TStr(List(\"a\"->Ti(32))),\n            \"B\"->TStr(List(\"a\"->Ti(32), \"b\"->Ti(32)))\n            )),\n            \"B\",\n            List(\n              ELdc(Ti(32), 555),\n              ELdc(Ti(32), 777)\n          ))\n        ),\n        // switch\n        ESwitch(Ti(32), ELdc(Ti(32), 2), List(\n          ELdc(Ti(32), 1) -> EPrint(Ti(32), ELdc(Ti(32), 10001)),\n          ELdc(Ti(32), 2) -> EPrint(Ti(32), ELdc(Ti(32), 10002)),\n          ELdc(Ti(32), 3) -> EPrint(Ti(32), ELdc(Ti(32), 10003))\n        )),\n        ESwitch(Ti(32), ELdc(Ti(32), 0), List(\n          ELdc(Ti(32), 1) -> EPrint(Ti(32), ELdc(Ti(32), 10001)),\n          ELdc(Ti(32), 2) -> EPrint(Ti(32), ELdc(Ti(32), 10002)),\n          ELdc(Ti(32), 3) -> EPrint(Ti(32), ELdc(Ti(32), 10003))\n        )),\n\n        // alpha test\n        EVal(Ti(32), \"a\", ELdc(Ti(32), 1000)),\n        EPrint(Ti(32), EId(Ti(32), \"a\")),\n        EVal(Ti(32), \"a\", EAdd(Ti(32), EId(Ti(32),\"a\"), ELdc(Ti(32),2000))),\n        EPrint(Ti(32), EId(Ti(32), \"a\")),\n        // alpha block test\n        EBlock(Tv, List(\n          EVal(Ti(32), \"a\", ELdc(Ti(32), 5000)),\n          EPrint(Ti(32), EId(Ti(32), \"a\"))\n        )),\n        EPrint(Ti(32), EId(Ti(32), \"a\")),\n\n        // match\u69cb\u6587\n        ESwitch(t, EId(t,\"data2\"), List(\n          ETag(t, \"A\", List(EVal(Ti(32),\"x\",null))) -> EBlock(Tv,List(EPrint(Ti(32),EId(Ti(32),\"x\")))),\n          ETag(t, \"B\", List(EVal(Ti(32),\"x\",null),EVal(Ti(32),\"y\",null))) -> EBlock(Tv,List(EPrint(Ti(32),EId(Ti(32),\"x\")),EPrint(Ti(32),EId(Ti(32),\"y\"))))\n        )),\n\n        EVal(t, \"data3\",\n          ETag(t, \"A\", List(\n              ELdc(Ti(32), 333)\n          ))\n        ),\n        ESwitch(t, EId(t,\"data3\"), List(\n          ETag(t, \"A\", List(EVal(Ti(32),\"x\",null))) -> EBlock(Tv,List(\n              EPrint(Ti(32),EId(Ti(32),\"x\")))),\n          ETag(t, \"B\", List(EVal(Ti(32),\"x\",null),EVal(Ti(32),\"y\",null))) -> EBlock(Tv,List(\n              EPrint(Ti(32),EId(Ti(32),\"x\")),\n              EPrint(Ti(32),EId(Ti(32),\"y\"))))\n        )),\n        EVal(Ti(32),\"x\",ELdc(Ti(32),10)),\n        EPrint(Ti(32),EId(Ti(32),\"x\")),\n        EType(TStr(List((\"a\", Ti(32)), (\"b\", Ti(32)))), \"Dt\"),\n        EVal(TDef(\"Dt\"), \"a2\", null),\n        EAssign(Ti(32), EField(Ti(32), \"a2\", \"a\"), ELdc(Ti(32), 9)),\n        EPrint(Ti(32), EField(Ti(32), \"a2\", \"a\"))\n\n      ))\n      println(\"ast=\" + ast)\n      val ast2 = alpha(ast)\n      println(\"ast2=\" + ast2)\n      val ll = kNormal(ast2)\n      println(\"ll=\" + ll)\n      val ll2 = constFold(ll)\n      emit(\"e.ll\", ll2)\n      println(exec(\"llc e.ll -o e.s\"))\n      println(exec(\"llvm-gcc -m64 e.s -o e\"))\n      println(exec(\"./e\"))\n    } catch {\n      case e:Throwable => e.printStackTrace()\n    }\n  }\n}\n\nobject alpha {\n\n  def find(id: String, env: Map[String, String]): String = {\n    if (env.contains(id)) env(id) else id\n  }\n\n  def apply(e: E): E = {\n    f(e, Map()) match { case(e, _) => e }\n  }\n  def l(ls:List[E],env:Map[String,String]):(List[E],Map[String, String]) = {\n    val (ls2,env2) = ls.foldLeft(List[E](), env) {\n      case ((ls, env), a) =>\n        val (a1, env1) = f(a, env)\n        ((a1 :: ls), env1)\n    }\n    (ls2.reverse,env2)\n  }\n  def l2(ls:List[(E,E)],env:Map[String,String]):(List[(E,E)],Map[String, String]) = {\n    val (cases1, env2) = ls.foldLeft(List[(E,E)](), env) {\n      case ((ls, env), (a,b)) =>\n        val (a1, env1) = f(a, env)\n        val (b1, env2) = f(b, env1)\n        (((a1,b1) :: ls), env)\n    }\n    (cases1.reverse, env2)\n  }\n  def f(e: E, env: Map[String, String]): (E, Map[String, String]) = {\n    e match {\n      case e @ EBin(t: T, i: String, a: E, b: E) =>\n        val (a1, env1) = f(a, env)\n        val (b1, env2) = f(b, env1)\n        (e.copy(t, i, a1, b1), env2)\n      case e @ ELdc(t: T, i: Long) => (e.copy(t, i), env)\n      case e @ EBlock(t: T, ls: List[E]) =>\n        val (ls1, env1) = l(ls, env)\n        (e.copy(t, ls1), env)\n      case e @ EPrint(t: T, a: E) =>\n        val (a1, env1)  = f(a, env)\n        (e.copy(t, a1), env1)\n      case e @ EVal(t: T, id: String, a) =>\n        val (a1,env1) = if (a == null) (null, env) else f(a, env)\n        val id2 = if (env.contains(id)) genid(\".\") else id\n        (e.copy(t, id2, a1), env1 + (id -> id2))\n      case e @ EId(t: T, id: String) => (e.copy(t, find(id, env)), env)\n      case e @ EField(t: T, id: String, idx: String) =>\n        (e.copy(t, find(id, env), idx), env)\n      case e @ EAssign(t: T, a: E, b: E) =>\n        val (a1, env1) = f(a, env)\n        val (b1, env2) = f(b, env1)\n        (e.copy(t, a1, b1), env2)\n      case e @ ESwitch(t: T, a: E, cases:List[(E,E)]) =>\n        val (a1, env1) = f(a, env)\n        val (cases1, _) = l2(cases, env1)\n        (e.copy(t, a1, cases1), env)\n      case e @ EUnit => (e, env)\n      case e @ ETag(t: T, id:String, ls: List[E]) =>\n        val (ls1, env1) = l(ls, env)\n        (e.copy(t, id, ls1), env1)\n      case e @ ETuple(t:T,ls:List[E]) =>\n        val (ls1, env1) = l(ls, env)\n        (e.copy(t, ls1), env1)\n      case e @ EType(t:T, id:String) => (e.copy(t, id), env)\n      case e : ECase => throw new Exception(\"error\")\n    }\n  }\n}\n\nobject kNormal {\n  def gid(t:T): R = {\n    RR(t,genid(\"\"))\n  }\n  var ls: List[LL] = null\n  def add(l: LL) {\n    ls = l :: ls\n  }\n\n  def arr(e: E): R = {\n    e match {\n      case EField(t, id, idx) =>\n        env.map(id) match {\n          case i:R =>\n            val ((n, nt), reg1) = (T.find(i.t.asInstanceOf[TStr],idx), gid(t))\n            add(LLField(reg1, i, RN(Ti(64),\"0\"), RN(nt,\"\"+n)))\n            reg1\n          case t => throw new Exception(\"type mismatch \" + t)\n        }\n      case EId(t, id) => env.map(id)\n      case _ => throw new Exception(\"error\")\n    }\n  }\n\n  def findTag(tagId:String, n:Int, ls:List[(String, TStr)]):(Int, TStr) = ls match {\n    case List() => throw new Exception(\"not found \"+tagId)\n    case (stId,stT:TStr)::ls => if (stId == tagId) (n,stT) else findTag(tagId, n + 1, ls)\n  }\n\n  def f(a: E): R = {\n    a match {\n      case EBin(t, op, a1, b1) =>\n        (f(a1), f(b1), gid(t)) match {\n          case (a, b, id) =>\n            if (t != a.t || t != b.t) throw new Exception(\"type mismatch \" + t)\n            add(LLBin(id, op, a, b))\n            id\n        }\n      case ELdc(t, i) => RN(t, \"\"+i)\n      case EPrint(t, a) =>\n        f(a) match {\n          case a =>\n            if (t != a.t) throw new Exception(\"type mismatch t=\" + t + \" ta=\" + a.t)\n            add(LLCall(null, RG(TFun(Tv, List(t)), \"print_\" + emit.llt(t)), List((a.t, a))))\n            a\n        }\n      case EBlock(t, ls) =>\n        ls.foldLeft(null: R) {\n          case (tid, l) => f(l)\n        }\n      case EVal(t: TStr, id, tpl) =>\n        emit.llstruct(t)\n        env.add(RL(t,id))\n        add(LLAlloca(RL(t,id)))\n        tpl match {\n          case ETuple(_, ls) =>\n            for ((e, (name, t)) <- ls.zip(t.types)) {\n              f(EAssign(t, EField(t, id, name), e))\n            }\n          case null =>\n          case _ => throw new Exception(\"error\")\n        }\n        RL(t,id)\n      case EVal(t: TVariant, id, tpl) =>\n        val (_, valT, maxT, _) = emit.llvariantInfo(t)\n        env.add(RL(t,id))\n        add(LLAlloca(RL(t,id)))\n        tpl match {\n          case ETag(_, tagId, ls) =>\n            val (tagIdx, stT) = findTag(tagId, 0, t.ls)\n            val tagR = gid(stT)\n            // tag id \u306e\u30a2\u30c9\u30ec\u30b9\u53d6\u5f97\n            add(LLField(tagR, RL(valT, id), RN(Ti(64), \"0\"), RN(Ti(32), \"0\")))\n            // tag id\u4fdd\u5b58\n            add(LLStore(RN(Ti(32),\"\"+tagIdx), tagR))\n\n            // \u5185\u90e8\u306e\u69cb\u9020\u4f53\u306e\u30a2\u30c9\u30ec\u30b9\u3092\u53d6\u5f97\n            val maxAdrR = gid(Tp(maxT))\n            add(LLField(maxAdrR, RL(valT, id), RN(Ti(64), \"0\"), RN(Ti(32), \"1\")))\n\n            // \u30ad\u30e3\u30b9\u30c8\u3059\u308b\n            val stId = genid(\"st\")\n            val stR = RL(Tp(stT), stId)\n            add(LLBitCast(stR, maxAdrR))\n\n            // \u767b\u9332\u3059\u308b\n            env.add(RL(stT, stId))\n\n            // \u5404\u30d5\u30a3\u30fc\u30eb\u30c9\u5024\u3092\u8a2d\u5b9a\u3059\u308b\n            for ((e, (id, t)) <- ls.zip(stT.types)) {\n              f(EAssign(t, EField(t, stId, id), e))\n            }\n          case null =>\n          case _ => throw new Exception(\"error\")\n        }\n        RL(t,id)\n      case e @ EVal(t, id, a) =>\n        val t2 = env.stripT(t)\n        t2 match {\n          case t: TStr => f(e.copy(t = t))\n          case t: TVariant => f(e.copy(t = t))\n          case _ =>\n            env.add(RL(t, id))\n            f(a) match {\n              case a =>\n                add(LLAssign(RL(a.t, id), a))\n                RL(a.t, id)\n            }\n        }\n      case EId(t, id) => env.map(id)\n      case EAssign(t, a, b) =>\n        (arr(a), f(b)) match {\n          case (a, b) =>\n            if (env.stripT(t) != env.stripT(b.t)) throw new Exception(\"type mismatch \" + t + \" \" + b.t)\n            add(LLStore(b, a))\n            b\n        }\n      case a: EField =>\n        val a2 = arr(a)\n        val b = gid(a2.t)\n        add(LLLoad(b, a2))\n        b\n      case ESwitch(t: TVariant, a: E, cases: List[(E, E)]) =>\n        val valR = f(a)\n        val tagAdrR = gid(valR.t)\n        add(LLField(tagAdrR, valR, RN(Ti(64), \"0\"), RN(Ti(32), \"0\")))\n\n        val tagR = gid(Ti(32))\n        add(LLLoad(tagR, tagAdrR))\n\n        // \u30c6\u30fc\u30d6\u30eb\u30b8\u30e3\u30f3\u30d7\n        val lbl = genid(\"match\")\n        val ls = for ((ETag(tl: TVariant, id, vs), _) <- cases) yield {\n          val (tagIdx,stT) = findTag(id, 0, tl.ls)\n          (tagIdx.asInstanceOf[Long], lbl + \".\" + tagIdx)\n        }\n        add(LLSwitch(tagR, lbl, ls))\n\n        // \u5404\u30b1\u30fc\u30b9\n        val (_, _, maxT, _) = emit.llvariantInfo(env.stripT(a.t).asInstanceOf[TVariant])\n        for ((ETag(tl: TVariant, id, vs), e) <- cases) {\n          val (tagIdx,stT) = findTag(id, 0, tl.ls)\n          add(LLLabel(lbl + \".\" + tagIdx))\n\n          val maxAdrR = gid(Tp(maxT))\n          add(LLField(maxAdrR, valR, RN(Ti(64), \"0\"), RN(Ti(32), \"1\")))\n\n          val stId = genid(\"st\")\n          val stR = RL(stT, stId)\n          add(LLBitCast(RL(Tp(stT), stId), maxAdrR))\n          env.add(stR)\n\n          for ((e: EVal, (id, t)) <- vs.zip(stT.types)) {\n            f(e.copy(e.t, e.id, EField(t, stId, id)))\n          }\n          f(e)\n          add(LLGoto(lbl))\n        }\n        add(LLLabel(lbl))\n        null\n      case e @ ESwitch(t: T, a: E, cases: List[(E, E)]) =>\n        env.stripT(a.t) match {\n          case t:TVariant => return f(e.copy(t=t))\n          case _ =>\n        }\n        val ra = f(a)\n        val lbl = genid(\"switch\")\n        val (length, ls) = cases.foldLeft(0, List[(Long, String)]()) {\n          case ((n, ls), (ELdc(tl, a), _)) => (n + 1, (a, lbl + n) :: ls)\n          case ((n, ls), (EUnit, _)) => (n + 1, (-1L, lbl + n) :: ls)\n        }\n        add(LLSwitch(ra, lbl, ls.reverse))\n        for((n, (_, e)) <- (0 until cases.length).zip(cases)) {\n          add(LLLabel(lbl + n)); f(e); add(LLGoto(lbl))\n        }\n        add(LLLabel(lbl))\n        null\n      case EType(t: T, id: String) =>\n        env.map = env.map + (id -> RR(t, null))\n        null\n    }\n  }\n\n  def apply(a: E): List[LL] = {\n    ls = List[LL]()\n    f(a)\n    ls.reverse\n  }\n}\n\nobject env {\n  var map = Map[String, R]()\n  def add(r: R) {\n    map = map + (r.id -> r)\n  }\n  def add(id:String, r:R) {\n    map = map + (id -> r)\n  }\n  def findTag(t:TVariant, id:String):TStr = {\n    for((tag,t) <- t.ls) {\n      if(tag==id) return t\n    }\n    throw new Exception(\"not found tag \"+id)\n  }\n  def stripT(t:T):T = {\n    t match {\n      case TDef(id) =>\n        val r = env.map(id)\n        if(r.id != null) throw new Exception(id + \" is not type\")\n        stripT(r.t)\n      case t => t\n    }\n  }\n}\n\nsealed trait LL\ncase class LLCall(id: R, op: R, prms: List[(T, R)]) extends LL\ncase class LLBin(id: R, op: String, a: R, b: R) extends LL\ncase class LLAssign(s: R, d: R) extends LL\ncase class LLField(id1: R, aid: R, z: R, b: R) extends LL\ncase class LLAlloca(id: R) extends LL\ncase class LLLoad(id1: R, id2: R) extends LL\ncase class LLStore(id1: R, id2: R) extends LL\ncase class LLBitCast(did: R, sid:R) extends LL\ncase class LLSwitch(reg:R, label:String, cases:List[(Long,String)]) extends LL\ncase class LLGoto(label:String) extends LL\ncase class LLLabel(s: String) extends LL\n\nobject constFold {\n  var map: Map[R, R] = null\n  def m(v: R): R = {\n    if (map.contains(v)) m(map(v)) else v\n  }\n  def fs(prms: List[(T, R)]): List[(T, R)] = {\n    prms.map {\n      case (t, v) => (t, m(v))\n    }\n  }\n  def apply(ls: List[LL]): List[LL] = {\n    map = Map()\n    ls.foldLeft(List[LL]()) {\n      case (ls, l @ LLCall(id, op, prms)) => l.copy(prms = fs(prms)) :: ls\n      case (ls, l @ LLBin(id, op, a, b)) => l.copy(a = m(a), b = m(b)) :: ls\n      case (ls, l @ LLAssign(s, d)) => map = map + (s -> d); ls\n      case (ls, l @ LLAlloca(id: R)) => l.copy(m(id)) :: ls\n      case (ls, l @ LLField(id, id2, id3, id4)) => l.copy(id, m(id2), m(id3), m(id4)) :: ls\n      case (ls, l @ LLStore(id1, id2)) => l.copy(m(id1), m(id2)) :: ls\n      case (ls, l @ LLLoad(id1, id2)) => l.copy(m(id1), m(id2)) :: ls\n      case (ls, l @ LLBitCast(did, sid)) => l.copy(m(did),m(sid)) :: ls\n      case (ls, l @ LLSwitch(n, lbl, cases)) => l.copy(m(n), lbl, cases)::ls\n      case (ls, l @ LLLabel(_)) => l::ls\n      case (ls, l @ LLGoto(_)) => l::ls\n      case (ls, l) => throw new Exception(\"error no implementation \"+l)\n    }.reverse\n  }\n}\n\nobject emit {\n\n  def llt(t:T):String = {\n    t match {\n      case Ti(i) => \"i\" + i\n      case Tv => \"void\"\n      case TFun(t, ls) => llt(t) + \"(\" + ls.map(llt).mkString(\", \") + \")*\"\n      case t:TStr => llstruct(t)\n      case t:TVariant => llvariant(t)\n      case Tp(t) => llt(t) + \"*\"\n      case t:TDef => llt(env.stripT(t))\n      case Tn => throw new Exception(\"error\")\n    }\n  }\n  // \u30b5\u30a4\u30ba\u8a08\u7b97\n  def size(t:T):Int = {\n    env.stripT(t) match {\n      case t@TStr(ls) =>\n        llstruct(t) // \u69cb\u9020\u4f53\u306e\u767b\u9332\n        ls.foldLeft(0) { case (s,(n,t)) => s + size(t) }\n      case Ti(n) => n / 8\n      case Tv => 0\n      case t:TFun => 8\n      case t:TVariant =>\n        val (_, _, m, _) = llvariantInfo(t)\n        size(m) + 4\n      case Tp(n) => 8\n      case Tn => throw new Exception(\"error\")\n      case t:TDef => throw new Exception(\"error\")\n    }\n  }\n  /**\n   * \u30f4\u30a1\u30ea\u30a2\u30f3\u30c8\u578b\u306e\u60c5\u5831\u3092\u53d6\u5f97\n   * (\u578b\u306e\u540d\u524d, \u69cb\u9020\u4f53, \u6700\u5927\u30b5\u30a4\u30ba\u69cb\u9020\u4f53, \u5185\u90e8\u306e\u69cb\u9020\u4f53\u30ea\u30b9\u30c8)\n   */\n  def llvariantInfo(v:TVariant):(String,TStr,TStr,List[TStr]) = {\n    val (maxsize, maxt, tys) = v.ls.foldLeft((0, null:TStr, List[TStr]())) {\n      case ((n:Int,t,ls),(name:String,vt:T)) =>\n        val sizevt = size(vt)\n        if (sizevt > n) (sizevt, vt,vt::ls) else (n, t,vt::ls)\n    }\n    val t = TStr(List(\"tag\"->Ti(32),\"data\"->maxt))\n    (llstruct(t), t, maxt, tys)\n  }\n\n  def llvariant(v:TVariant):String = {\n    llvariantInfo(v) match {\n      case (s,_,_,_) => s\n    }\n  }\n\n  def llr(r:R): String = {\n    r match {\n      case RG(t,id) => \"@\" + id\n      case RL(t,id) => \"%\" + id\n      case RR(t,id) => \"%.\" + id\n      case RN(t,id) => \"\" + id\n    }\n  }\n\n  def o(id: R, out: String) {\n    if (id != null) asm(llr(id) + \" = \" + out)\n    else asm(out)\n  }\n  def f(l: LL) {\n    l match {\n      case LLCall(id, op, prms) =>\n        val ps = prms.map { case (a, b) => llt(a) + \" \" + llr(b) }.mkString(\", \")\n        o(id, \"call \" + llt(op.t) + \" \" + llr(op) + \"(\" + ps + \") nounwind\")\n      case LLBin(id, op, a, b) =>\n        o(id, op + \" \" + llt(id.t) + \" \" + llr(a) + \", \" + llr(b))\n      case _:LLAssign => throw new Exception(\"error\")\n      case LLField(reg1: R, addr: R, zero: R, a: R) =>\n        o(reg1, \"getelementptr inbounds \" + llt(addr.t) + \"* \" + llr(addr) + \", \" + llt(zero.t) + \" \" + llr(zero) + \", \" + llt(a.t) + \" \" + llr(a))\n      case LLLoad(reg1: R, reg2: R) =>\n        o(reg1, \"load \" + llt(reg1.t) + \"* \" + llr(reg2))\n      case LLStore(reg1: R, reg2: R) =>\n        asm(\"store \" + llt(reg1.t) + \" \" + llr(reg1) + \", \" + llt(reg1.t) + \"* \" + llr(reg2))\n      case LLAlloca(reg: R) =>\n        o(reg, \"alloca \" + llt(reg.t))\n      case LLBitCast(d: R, s:R) =>\n        o(d, \"bitcast \" + llt(s.t) + \" \" + llr(s) + \" to \" + llt(d.t))  \n      case LLSwitch(n, lbl, cases) =>\n        asm(\"switch \"+llt(n.t)+\" \"+llr(n)+\", label %\"+lbl+ \" [\")\n        for((a,b) <- cases) {\n          asm(\"  i32 \" + a + \", label %\"+b)\n        }\n        asm(\"]\")\n      case LLLabel(l) =>\n        asm.label(l+\":\")\n      case LLGoto(l) =>\n        asm(\"br label %\"+l)\n    }\n  }\n\n  var structs: Map[TStr, String] = Map()\n  def llstruct(t: TStr): String = {\n    if (structs.contains(t)) return structs(t)\n    val name = genid(\"%.struct\")\n    structs = structs + (t -> name)\n    name\n  }\n\n  def apply(file: String, ls: List[LL]) {\n    asm.open(file)\n    structs.foreach { case (t, n) =>\n        asm(n + \" = type {\" + t.types.map { case (a, b) => llt(b) }.mkString(\", \") + \"}\")\n    }\n    asm.label(\"@.str = private constant [4 x i8] c\\\"%d\\\\0A\\\\00\\\"\")\n    asm.label(\"define void @print_i32(i32 %a) nounwind ssp {\")\n    asm.label(\"entry:\")\n    asm(\"call i32 (i8*, ...)* @printf(i8* getelementptr inbounds ([4 x i8]* @.str, i64 0, i64 0), i32 %a) nounwind\")\n    asm(\"ret void\")\n    asm.label(\"}\")\n    asm.label(\"define void @print_i8(i8 %a) nounwind ssp {\")\n    asm.label(\"entry:\")\n    asm(\"call i32 (i8*, ...)* @printf(i8* getelementptr inbounds ([4 x i8]* @.str, i64 0, i64 0), i8 %a) nounwind\")\n    asm(\"ret void\")\n    asm.label(\"}\")\n\n    asm.label(\"declare i32 @printf(i8*, ...) nounwind\")\n\n    asm.label(\"define i32 @main() nounwind ssp {\")\n    asm.label(\"entry:\")\n    ls.foreach(f)\n    asm(\"ret i32 0\")\n    asm.label(\"}\")\n    asm.close()\n  }\n}\n\nobject genid {\n  var id = 0\n  def apply(s: String): String = {\n    id += 1\n    s + id\n  }\n}\nobject asm {\n  var p: PrintWriter = null\n  def open(file: String) {\n    p = new PrintWriter(new BufferedWriter(new FileWriter(file)))\n  }\n\n  var indent: String = \"\"\n\n  def apply(s: String, n: String = \"\") {\n    val v = indent + s + \"\\t\" + n + \"\\n\"\n    p.print(v)\n  }\n  def label(s: String) {\n    asm.indent = \"\";\n    apply(s)\n    asm.indent = \"\\t\";\n  }\n  def close() {\n    p.close()\n  }\n}\n\nobject exec {\n  def apply(cmd: String): (Int, String, String) = {\n    val p = Runtime.getRuntime().exec(cmd)\n    val stdin = (readAll(p.getInputStream()))\n    val stderr = (readAll(p.getErrorStream()))\n    (p.waitFor(), stdin, stderr)\n  }\n\n  def readAll(p: InputStream): String = {\n    def f(s: String, i: BufferedReader): String = {\n      i.readLine() match {\n        case null => s\n        case a => f(s + a + \"\\n\", i)\n      }\n    }\n    f(\"\", new BufferedReader(new InputStreamReader(p)))\n  }\n}\n\n\n\n\u307e\u3068\u3081\n\u30d1\u30fc\u30b5\u30b3\u30f3\u30d3\u30cd\u30fc\u30bf\u3067\u30d1\u30fc\u30b5\u3092\u4f5c\u308a\u3001AST\u306b\u578b\u30c1\u30a7\u30c3\u30af\u3092\u5165\u308c\u305f\u4e8b\u3067\u3001\u52d5\u4f5c\u3059\u308b\u3088\u3046\u306b\u306a\u308a\u307e\u3057\u305f\u3002\u304a\u305d\u3089\u304f\u30c6\u30b9\u30c8\u30b3\u30fc\u30c9\u4ee5\u5916\u306e\u30b3\u30fc\u30c9\u3092\u52d5\u304b\u305d\u3046\u3068\u3059\u308b\u3068\u30d0\u30b0\u304c\u51fa\u308b\u3068\u601d\u3044\u307e\u3059\u304c(\u51fa\u306a\u3044\u304b\u3082\u3057\u308c\u306a\u3044\u3067\u3059\u304c)\u3001\u30d0\u30b0\u6f70\u3057\u3092\u59cb\u3081\u308b\u3068\u5927\u5909\u306a\u306e\u3067\u3053\u3053\u307e\u3067\u3068\u3057\u307e\u3059\u3002\n\n\u4eca\u5f8c\u306e\u4e88\u5b9a\n\u3053\u306e\u5f8c\u306e\u4e88\u5b9a\u306f\u3001\u307b\u3093\u3068\u3046\u306b\u4f7f\u3048\u308b\u8a00\u8a9e\u306b\u4ed5\u4e0a\u3052\u3066\u884c\u3063\u305f\u308a\u3059\u308b\u4e8b\u3068\u3001\u30d1\u30bf\u30fc\u30f3\u30de\u30c3\u30c1\u306e\u4f5c\u308a\u65b9\u3092\u5947\u9e97\u306b\u7e8f\u3081\u308b\u4e8b\u3067\u3059\u3002\u6587\u7ae0\u80fd\u529b\u306f\u4f4e\u3044\u306e\u3067\u5927\u5909\u3067\u3059\u3051\u3069\u3001\u60a9\u3093\u3067\u306a\u3044\u65b9\u304c\u591a\u5206\u5206\u304b\u308a\u3084\u3059\u3044\u3060\u308d\u3046\u3068\u3044\u3046\u306e\u304c\u3042\u3063\u3066\u305d\u306e\u3088\u3046\u306b\u4f5c\u308d\u3046\u3068\u601d\u3063\u3066\u3044\u307e\u3059\u3002\u4eca\u56de\u306fScala\u3067\u4f5c\u6210\u3057\u307e\u3057\u305f\u304c\u3001Haxe\u3067\u4f5c\u3063\u3066\u307f\u308b\u306e\u3082\u3042\u308a\u3060\u3088\u306a\u3041\u3068\u601d\u3063\u3066\u3044\u307e\u3059\u3002Haxe\u3067\u4f5c\u308c\u3070\u3001CPP\u306b\u5909\u63db\u3067\u304d\u308b\u306e\u3067C\u8a00\u8a9e\u98a8\u306e\u8a00\u8a9e\u3067\u5947\u9e97\u306b\u30cd\u30a4\u30c6\u30a3\u30d6\u306a\u30b3\u30f3\u30d1\u30a4\u30e9\u3092\u304b\u3051\u308b\u306f\u305a\u306a\u3093\u3067\u3059\u3002\u554f\u984c\u306f\u3001\u30d1\u30fc\u30b5\u30b3\u30f3\u30d3\u30cd\u30fc\u30bf\u306e\u30e9\u30a4\u30d6\u30e9\u30ea\u3067\u3042\u308b\u3001ParserX\u3092CPP\u3067\u51fa\u529b\u3057\u3088\u3046\u3068\u3059\u308b\u3068\u30a8\u30e9\u30fc\u306b\u306a\u3063\u3066\u3057\u307e\u3046\u306e\u3067\u3001\u30d1\u30fc\u30b5\u306f\u5225\u306a\u65b9\u6cd5\u3067\u5b9f\u88c5\u3059\u308b\u5fc5\u8981\u304c\u3042\u308a\u307e\u3059\u3002\n\n\u53c2\u8003\u6587\u732e\n[1]\uff12\u9031\u9593\u3067\u3067\u304d\u308b\uff01\u30b9\u30af\u30ea\u30d7\u30c8\u8a00\u8a9e\u306e\u4f5c\u308a\u65b9\n[2]Packrat Parser\u3092\u4f7f\u3063\u3066\u307f\u305f\n[3]tapl-scala\n[4]RegexParsers\u3067\u624b\u8efd\u306bScala\u306e\u30d1\u30fc\u30b5\u30b3\u30f3\u30d3\u30cd\u30fc\u30bf\u3092\u4f7f\u3063\u3066\u307f\u308b\n\u4eca\u56de\u306f\u30d1\u30fc\u30b5\u3068\u578b\u30c1\u30a7\u30c3\u30af\u3092\u4f5c\u308a\u307e\u3059\u3002Scala\u3060\u3068\u30d1\u30fc\u30b5\u30b3\u30f3\u30d3\u30cd\u30fc\u30bf\u306e\u30e9\u30a4\u30d6\u30e9\u30ea\u304c\u6a19\u6e96\u3067\u3064\u3044\u3066\u3044\u308b\u306e\u3067\u305d\u308c\u3092\u4f7f\u3044\u307e\u3059\u3002PackRatParser\u3092\u4f7f\u3046\u3068\u30e1\u30e2\u5316\u3055\u308c\u30e1\u30e2\u30ea\u306f\u98df\u3044\u307e\u3059\u304c\u9ad8\u901f\u306b\u51e6\u7406\u3067\u304d\u308b\u305d\u3046\u3067\u3059\u306e\u3067\u3001\u3053\u3061\u3089\u3092\u4f7f\u3044\u307e\u3057\u305f\u3002\u307e\u305f\u3001\u6b63\u898f\u8868\u73fe\u3082\u4f7f\u3044\u305f\u3044\u306e\u3067\u3001RegexpParser\u3092\u4f7f\u3044\u307e\u3057\u305f\u3002\n\n\u30d1\u30fc\u30b5\u30b3\u30f3\u30d3\u30cd\u30fc\u30bf\u306e\u826f\u3044\u6240\u306f\u5c0f\u3055\u3044\u30d1\u30fc\u30b5\u3092\u5148\u306b\u4f5c\u3063\u3066\u305d\u308c\u3092\u5143\u306b\u62e1\u5f35\u3057\u3066\u884c\u3051\u3070\u3088\u3044\u306e\u3067\u4f5c\u308b\u306e\u304c\u697d\u3067\u3059\u3002\u307e\u305f\u3001Yacc\u3068\u306f\u9055\u3063\u3066\u30b3\u30f3\u30d5\u30ea\u30af\u30c8\u304c\u8d77\u304d\u306a\u3044\u306e\u3067\u7c21\u5358\u3067\u3059\u3002\u304a\u624b\u8efd\u306a\u30d1\u30fc\u30b5\u3092\u66f8\u304f\u306a\u3089\u30d1\u30fc\u30b5\u30b3\u30f3\u30d3\u30cd\u30fc\u30bf\u306f\u826f\u3044\u3082\u306e\u3067\u3059\u3002\n\n\u30d1\u30fc\u30b5\u3092\u4f5c\u308b\u3060\u3051\u3067\u3001\u7d42\u308f\u3089\u305b\u305f\u3044\u6240\u3067\u3059\u304c\u3001\u69cb\u9020\u4f53\u3084\u30f4\u30a1\u30ea\u30a2\u30f3\u30c8\u306e\u578b\u3092\u4f7f\u3046\u306b\u306ftypedef\u5ba3\u8a00\u306e\u3088\u3046\u306a\u69cb\u6587\u304c\u306a\u3044\u3068\u4e0d\u4fbf\u306a\u306e\u3067\u3001\u305d\u3061\u3089\u3082\u8ffd\u52a0\u3057\u307e\u3057\u305f\u3002\n\n\u578b\u306e\u30c1\u30a7\u30c3\u30af\u3068\u578b\u63a8\u8ad6\u306f\u4f3c\u3066\u3044\u308b\u306e\u3067\u3059\u304c\u3001\u63a8\u8ad6\u306f\u5927\u5909\u306a\u306e\u3067\u30c1\u30a7\u30c3\u30af\u3092\u3057\u3064\u3064\u63a8\u8ad6\u3063\u307d\u3044\u3053\u3068\u304c\u51fa\u6765\u305d\u3046\u306a\u6642\u3060\u3051\u63a8\u8ad6\u3063\u307d\u3044\u3053\u3068\u3092\u3057\u3066\u307f\u307e\u3059\u3002\n\n\u578b\u63a8\u8ad6\u3063\u307d\u3044\u5b9f\u88c5\u306b\u3064\u3044\u3066\u306f\u3001[2\u9031\u9593\u3067\u51fa\u6765\u308b\uff01\u30b9\u30af\u30ea\u30d7\u30c8\u8a00\u8a9e\u306e\u4f5c\u308a\u65b9](http://gihyo.jp/book/2012/978-4-7741-4974-5)[1]\u3092\u53c2\u8003\u306b\u3057\u307e\u3057\u305f\u3002\n\u30d1\u30fc\u30b5\u30b3\u30f3\u30d3\u30cd\u30fc\u30bf\u306e\u4f5c\u6210\u306f\u3001[Packrat Parser\u3092\u4f7f\u3063\u3066\u307f\u305f](http://sca-lab.blogspot.jp/2011/12/packrat-parser.html)[2]\u3084\u3001[tapl-scala](https://github.com/ilya-klyuchnikov/tapl-scala)[3] \u3092\u53c2\u8003\u306b\u3057\u307e\u3057\u305f\u3002\n\u6b63\u898f\u8868\u73fe\u306e\u30d1\u30fc\u30b5\u30b3\u30f3\u30d3\u30cd\u30fc\u30bf\u306b\u3064\u3044\u3066\u306f\u3001[RegexParsers\u3067\u624b\u8efd\u306bScala\u306e\u30d1\u30fc\u30b5\u30b3\u30f3\u30d3\u30cd\u30fc\u30bf\u3092\u4f7f\u3063\u3066\u307f\u308b](http://seratch.hatenablog.jp/entry/20111010/1318254084)[4]\u3092\u53c2\u8003\u306b\u3057\u307e\u3057\u305f\u3002\n\n## \u578b\u30c1\u30a7\u30c3\u30af\u306e\u5b9f\u88c5\n\n\u3053\u306e\u578b\u30c1\u30a7\u30c3\u30af\u306e\u5b9f\u88c5\u3068\u30d1\u30fc\u30b5\u306e\u4f5c\u6210\u306e\u89e3\u8aac\u306f\u3001\u578b\u30c1\u30a7\u30c3\u30af\u306e\u5b9f\u88c5\u304b\u3089\u66f8\u3044\u3066\u3042\u308a\u307e\u3059\u304c\u3001\u30d1\u30fc\u30b5\u304b\u3089\u5b9f\u88c5\u3057\u305f\u65b9\u304c\u826f\u3044\u3068\u601d\u3044\u307e\u3059\u3002\u3042\u3042\u3001\u578b\u30c1\u30a7\u30c3\u30af\u304c\u5fc5\u8981\u3060\u3002\u3063\u3066\u7b87\u6240\u304c\u51fa\u3066\u304d\u307e\u3059\u306e\u3067\u3002\u305d\u3053\u306e\u5bfe\u7b56\u304c\u3053\u306e\u578b\u30c1\u30a7\u30c3\u30af\u306e\u5b9f\u88c5\u3067\u3059\u3002\u3053\u3061\u3089\u306e\u5b9f\u88c5\u3092\u5148\u306b\u66f8\u3044\u3066\u3044\u308b\u306e\u306f\u3001\u578b\u30c1\u30a7\u30c3\u30af\u306e\u5b9f\u88c5\u3092\u5148\u306b\u4f5c\u3063\u3066\u3082\u30a8\u30e9\u30fc\u304c\u51fa\u306a\u3044\u304b\u3089\u3067\u3059\u3002\n\n\u74b0\u5883\u3092\u4f5c\u3063\u3066\u578b\u3092\u74b0\u5883\u306b\u4fdd\u5b58\u3057\u3001\u307e\u305f\u53d6\u308a\u51fa\u3057\u3066\u53d6\u308a\u51fa\u3057\u3066\u3001\uff12\u9805\u6f14\u7b97\u5b50\u306e\u578b\u3092\u6c42\u3081\u308b\u3068\u8a00\u3063\u305f\u51e6\u7406\u3092\u8ffd\u52a0\u3057\u307e\u3059\u3002\n\n\u03b1\u5909\u63db\u3092\u884c\u3063\u305f\u5f8c\u306b\u578b\u30c1\u30a7\u30c3\u30af\u3092\u884c\u3046\u4e8b\u3067\u3001\u540d\u524d\u304c\u3076\u3064\u304b\u3089\u306a\u3044\u3088\u3046\u306b\u306a\u3063\u3066\u3044\u307e\u3059\u304c\u3001\u3053\u308c\u304c\u826f\u3044\u4e8b\u306a\u306e\u304b\u3069\u3046\u304b\u306f\u5206\u304b\u308a\u307e\u305b\u3093\u3002\u3068\u306b\u304b\u304f\u3001\u3046\u307e\u304f\u3044\u3063\u3066\u3044\u308c\u3070\u3044\u3044\u3067\u3059\u3088\u306d\u3002\u305d\u308c\u3067\u3001\u30c6\u30b9\u30c8\u7684\u306a\u30d7\u30ed\u30b0\u30e9\u30e0\u304c\u52d5\u4f5c\u3059\u308b\u304f\u3089\u3044\u307e\u3067\u51fa\u6765\u305f\u3089\u7d42\u4e86\u3068\u3057\u307e\u3057\u305f\u3002\n\n```scala:\nimport util.parsing.input.Positional\n```\n\nsealed trait E \u3092Positional\u3092\u7d99\u627f\u3057\u3066\u4f4d\u7f6e\u60c5\u5831\u3092\u683c\u7d0d\u51fa\u6765\u308b\u3088\u3046\u306b\u3057\u307e\u3059\u3002\n\n```scala:\nsealed trait E extends Positional {\n```\n\n\u30bf\u30a4\u30d7\u5ba3\u8a00\u7528\u306e\u578b\u3068\u3001Switch\u30b1\u30fc\u30b9\u7528\u306e\u30d1\u30fc\u30b5\u7528\u306eECase\u3092\u8ffd\u52a0\u3057\u307e\u3059\u3002\n\n```scala:\ncase class EType(t:T, id:String) extends E\ncase class ECase(t:T, e:E) extends E\n```\n\nsealed trait T \u3092Positional\u3092\u7d99\u627f\u3057\u3066\u4f4d\u7f6e\u60c5\u5831\u3092\u683c\u7d0d\u51fa\u6765\u308b\u3088\u3046\u306b\u3057\u307e\u3059\u3002\n\n```scala:\nsealed trait T extends Positional\n```\n\n\u578b\u306e\u6c7a\u307e\u3063\u3066\u3044\u306a\u3044\u578bTn\u3068\u578b\u306e\u540d\u524d\u6307\u5b9a\u578bTDef\u306e\u8ffd\u52a0\u3092\u3057\u307e\u3059\u3002\n\n```scala:\ncase object Tn extends T\ncase class TDef(id:String) extends T\n```\n\n\u30c6\u30b9\u30c8\u30b3\u30fc\u30c9\u306e\u8ffd\u52a0\u3092\u3057\u307e\u3059\u3002\n\n```scala:\n        EType(TStr(List((\"a\", Ti(32)), (\"b\", Ti(32)))), \"Dt\"),\n        EVal(TDef(\"Dt\"), \"a2\", null),\n        EAssign(Ti(32), EField(Ti(32), \"a2\", \"a\"), ELdc(Ti(32), 9)),\n        EPrint(Ti(32), EField(Ti(32), \"a2\", \"a\"))\n```\n\n\u03b1\u5909\u63db\u306b\u578b\u306e\u8ffd\u52a0\u3057\u307e\u3059\u3002\n\n```scala:\n      case e @ EType(t:T, id:String) => (e.copy(t, id), env)\n      case e : ECase => throw new Exception(\"error\")\n```\n\nkNormal\u306bTDef\u5bfe\u7b56\u3067\u3001env.stripT\u3092\u5165\u308c\u3001\u578b\u304c\u69cb\u9020\u4f53\u304b\u30f4\u30a1\u30ea\u30a2\u30f3\u30c8\u3060\u3063\u305f\u3089\u578b\u3092\u5909\u3048\u3066\u518d\u5ea6\u8aad\u307f\u8fbc\u307f\u3057\u307e\u3059\u3002\nenv.stripT\u306f\u578b\u306bTDef\u304c\u5165\u3063\u3066\u3044\u305f\u5834\u5408\u306b\u3001TDef\u3092\u53d6\u308a\u9664\u304f\u51e6\u7406\u3067\u3059\u3002TDef\u304c\u90aa\u9b54\u306a\u306e\u3067\u3069\u3053\u304b\u3067\u5947\u9e97\u306b\u53d6\u308a\u9664\u304d\u305f\u3044\u6240\u3067\u3059\u304c\u3001\u30a2\u30c9\u30db\u30c3\u30af\u306b\u30a8\u30e9\u30fc\u304c\u51fa\u305f\u7b87\u6240\u306b\u5165\u308c\u3066\u3044\u307e\u3059\u3002\n\n```scala:\n        f(a) match {\n          case a =>\n            add(LLAssign(RL(a.t, id), a))\n            RL(a.t, id)\n        }\n```\n\u2193\n\n```scala:\n        val t2 = env.stripT(t)\n        t2 match {\n          case t: TStr => f(e.copy(t = t))\n          case t: TVariant => f(e.copy(t = t))\n          case _ =>\n            f(a) match {\n              case a =>\n                add(LLAssign(RL(a.t, id), a))\n                RL(a.t, id)\n            }\n        }\n```\n\nenv.stripT\u3092\u5165\u308c\u307e\u3059\u3002\n\n```scala:\n            if (t != b.t) throw new Exception(\"type mismatch \" + t + \" \" + b.t)\n```\n\u2193\n\n```scala:\n            if (env.stripT(t) != env.stripT(b.t)) throw new Exception(\"type mismatch \" + t + \" \" + b.t)\n```\n\nenv.stripT\u3092\u5165\u308c\u307e\u3059\u3002\n\n```scala:\n       val (_, _, maxT, _) = emit.llvariantInfo(a.t.asInstanceOf[TVariant])\n```\n\u2193\n\n```scala:\n        val (_, _, maxT, _) = emit.llvariantInfo(env.stripT(a.t).asInstanceOf[TVariant])\n```\n\nenv.stripT\u3092\u5165\u308c\u307e\u3059\u3002\n\n```scala:\n        env.stripT(a.t) match {\n          case t:TVariant => return f(e.copy(t=t))\n          case _ =>\n        }\n```\n\n\u30bf\u30a4\u30d7\u3092\u8ffd\u52a0\u3057\u307e\u3059\u3002\n\n```scala:\n      case EType(t: T, id: String) =>\n        env.map = env.map + (id -> RR(t, null))\n        null\n```\n\n\u8ffd\u52a0\u51e6\u7406\u3092\u8ffd\u52a0\u3057\u307e\u3059\u3002\n\n```scala:\n  def add(id:String, r:R) {\n    map = map + (id -> r)\n  }\n  def findTag(t:TVariant, id:String):TStr = {\n    for((tag,t) <- t.ls) {\n      if(tag==id) return t\n    }\n    throw new Exception(\"not found tag \"+id)\n  }\n  def stripT(t:T):T = {\n    t match {\n      case TDef(id) =>\n        val r = env.map(id)\n        if(r.id != null) throw new Exception(id + \" is not type\")\n        stripT(r.t)\n      case t => t\n    }\n  }\n```\n\n\n```scala:\n      case t:TDef => llt(env.stripT(t))\n      case Tn => throw new Exception(\"error\")\n```\n\nenv.stripT\u3092\u5165\u308c\u307e\u3059\u3002\n\n```scala:\n    t match {\n```\n\u2193\n\n```scala:\n    env.stripT(t) match {\n```\n\nTn,TDef\u306f\u7121\u3044\u306f\u305a\u306a\u306e\u3067\u30a8\u30e9\u30fc\u306b\u3057\u307e\u3059\u3002\n\n```scala:\n      case Tn => throw new Exception(\"error\")\n      case t:TDef => throw new Exception(\"error\")\n```\n\n## \u30d1\u30fc\u30b5\u306e\u5b9f\u88c5\n\n\u5b9f\u88c5\u306f\u306f\u3058\u3081\u306b\u6570\u5024\u3068\u8b58\u5225\u5b50\u3092\u5b9f\u88c5\u3057\u3066\u52d5\u304b\u3057\u3066\u307f\u307e\u3057\u305f\u3002\u6b21\u306b\u3001\u8db3\u3057\u7b97\u3001\u304b\u3051\u7b97\u3068print\u306e\u5b9f\u88c5\u3002AST\u3092\u30b3\u30f3\u30d1\u30a4\u30eb\u3057\u3066\u3057\u307e\u3048\u3070\u3001\u52d5\u304f\u306e\u3067\u52d5\u304b\u3057\u306a\u304c\u3089\u3001\u5f8c\u306f\u3001AST\u306e\u30c6\u30b9\u30c8\u3092\u518d\u73fe\u3059\u308b\u30b3\u30fc\u30c9\u3092\u66f8\u3044\u3066\u3001\u30c6\u30b9\u30c8\u3057\u306a\u304c\u3089\u6210\u9577\u3055\u305b\u3066\u884c\u304d\u307e\u3057\u305f\u3002\u305d\u308c\u3067\u3001\u578b\u306e\u30c1\u30a7\u30c3\u30af\u304c\u5fc5\u8981\u306a\u7b87\u6240\u304c\u3067\u3066\u6765\u305f\u306e\u3067\u30b3\u30e1\u30f3\u30c8\u30a2\u30a6\u30c8\u3057\u3066\u30d1\u30fc\u30b5\u3092\u4f5c\u308b\u3060\u3051\u3067\u98db\u3070\u3057\u305f\u308a\u3057\u3066\u5148\u306b\u4f5c\u3063\u3066\u3044\u307e\u3057\u305f\u3002\n\n## parse.scala\u306e\u5b9f\u88c5\n\n```scala:\npackage chapter11\n\nimport util.parsing.combinator._\nimport util.parsing.input.Positional\n\nobject parser extends RegexParsers with PackratParsers {\n  def p(e:PackratParser[E]) = positioned(e)\n  def t(e:PackratParser[T]) = positioned(e)\n\n  // skip C/C++ style comments and whitespace.\n  override protected val whiteSpace = \"\"\"((/\\*(?:.|\\r|\\n)*?\\*/)|//.*|\\s+)+\"\"\".r\n\n  lazy val id: PackratParser[String] = memo(\"\"\"[A-Za-z_][\\w_]*\"\"\".r)\n  lazy val lng: PackratParser[E] = p(memo(\"\"\"(0|[1-9][0-9]*)\"\"\".r  ^^ {case a => ELdc(Ti(32),a.toLong)}))\n  lazy val tpl: PackratParser[E] = p((\"(\" ~> expr) ~ rep(\",\" ~> expr) <~ \")\" ^^ { case a~b => ETuple(Tn, a::b) })\n  lazy val tpl2: PackratParser[List[E]] = (\"(\" ~> expr) ~ rep(\",\" ~> expr) <~ \")\" ^^ { case a~b => a::b }\n  lazy val _val: PackratParser[E] = p((\"val\" ~> id)~ (\"=\" ~> lng) ^^ { case a~b => EVal(Ti(32),a,b)} |\n    (\"val\" ~> id)~ (\":\" ~> id) ~ (\"=\" ~> id) ~ tpl2 ^^ { case a~t~id~ls => EVal(mkT(t),a,ETag(mkT(t),id,ls))} |\n    (\"val\" ~> id)~ (\":\" ~> id) ~ (\"=\" ~> tpl) ^^ { case a~t~tpl => EVal(mkT(t),a,tpl)} |\n    (\"val\" ~> id)~ (\":\" ~> id) ~ (\"=\" ~> expr) ^^ { case a~t~tpl => EVal(mkT(t),a,tpl)} |\n    (\"val\" ~> id)~ (\":\" ~> id) ^^ { case a~t => EVal(mkT(t),a,null)})\n  \n  lazy val _id: PackratParser[E] = p(id ^^ { case a => EId(Tn, a)})\n\n  def calc(op: String, op2:String):PackratParser[(E,E)=>E] = op ^^ {\n    a => (a:E,b:E) => Op(op2)(Tn, a, b)\n  }\n  lazy val eq: PackratParser[E] = p(expr ~ rep( \"=\" ~> expr) ^^ {\n    case a~b =>\n      b.foldLeft(a){case (a,b) => EAssign(Ti(32), a, b)}})\n  lazy val t1: PackratParser[E] = p(chainl1(eq,eq, calc(\"*\",\"mul\") | calc(\"/\",\"div\") | calc(\"%\",\"mod\")))\n  lazy val term: PackratParser[E] = p(chainl1(t1, t1, calc(\"+\",\"add\") | calc(\"-\",\"sub\")))\n  lazy val print: PackratParser[E] = p(\"print_i\" ~> \"(\" ~> expr <~ \")\" ^^ {case a => EPrint(Ti(32),a) })\n  lazy val block: PackratParser[E] = p(\"{\" ~> rep(expr) <~ \"}\" ^^ {case a => EBlock(Tv,a)})\n  lazy val typ: PackratParser[T] = t(id ^^ {case a => mkT(a)})\n  lazy val ctyps: PackratParser[List[(String,TStr)]] = rep((id <~ \"(\") ~ (typs <~ \")\") ^^ { case a~b => (a,TStr(b))}) \n  lazy val typs: PackratParser[List[(String,T)]] = rep((id <~ \":\") ~ typ ^^ { case a~b => (a,b)}) \n  lazy val typdef: PackratParser[E] = (\"type\" ~> id) ~ (\"=\" ~> \"struct\" ~> \"{\" ~> typs <~ \"}\") ^^ { case a~b => EType(TStr(b), a)} |\n    (\"type\" ~> id) ~ (\"=\" ~> \"enum\" ~> \"{\" ~> ctyps <~ \"}\") ^^ { case a~b => EType(TVariant(b), a)}\n  \n  lazy val fields: PackratParser[E] = (id <~ \".\") ~ id ^^ { case a~b => EField(Ti(32),a,b)}\n  lazy val cases: PackratParser[List[(E,E)]] =  rep((\"case\" ~> ((lng^^ {case a=>ECase(Tn,a)})|tag)  <~ \":\") | expr ) ^^ {case a:List[E] =>\n    a.foldLeft(List[(E,E)]()){\n      case (l,ECase(_,a)) => (a,EBlock(Tv,List()))::l\n      case ((tag,EBlock(_,bls))::ls,a) => (tag,EBlock(Tv,bls:::List(a)))::ls\n      case _ => throw new Exception(\"error\")\n    }.reverse\n  }    \n  lazy val switch: PackratParser[E] = (\"switch\" ~> \"(\" ~> expr <~ \")\") ~ (\"{\" ~> cases <~ \"}\") ^^ {case a~b => ESwitch(Ti(32), a, b)} \n  lazy val tpl3: PackratParser[List[String]] = (\"(\" ~> id) ~ rep(\",\" ~> id) <~ \")\" ^^ { case a~b => a::b }\n  lazy val tag: PackratParser[ECase] = id ~ tpl3 ^^ {case a~b => ECase(Tn,ETag(Tn,a,b.map{case a => EVal(Tn,a,null)}))}\n  lazy val expr: PackratParser[E] = typdef | term | block | switch | print | lng | _val | fields | _id\n\n  def mkT(a:String):T = {\n    a match {\n      case \"Int\" => Ti(32)\n      case a => TDef(a)\n    }\n  }\n}\n\nobject typing {\n  \n  def apply(e:E):E = {\n    val r = f(e)\n    env.map=Map()\n    r\n  }\n  def add(id:String, t:T):T = {\n    env.add(RL(t,id))\n    t\n  }\n  def f(e:E):E = {\n    e match {\n      case e @ ELdc(Tn, i:Long) => e.copy(t=Ti(32))\n      case e @ ELdc(t:T, i:Long) => e\n      case e @ EBin(t:T, s:String, l:E, r:E) => val (l2,r2) = (f(l),f(r)); e.copy(t=l2.t, l=l2, r=r2)\n      case e @ EPrint(t:T, a:E) => val a2 = f(a); e.copy(a2.t, a2)\n      case e @ EBlock(t: T, ls: List[E]) => e.copy(ls=ls.map(f))\n      case e @ EVal(Tn, id: String, a: E) => val a2 = f(a); e.copy(t=add(id,a.t), a=a2)\n      case e @ EVal(t: T, id: String, null) => add(id,t); e \n      case e @ EVal(t: T, id: String, a: ETuple) => e.copy(t=add(id,t), a=f(a.copy(t=t))) \n      case e @ EVal(t: T, id: String, a: E) =>\n        val a2 = f(a)\n        if(env.stripT(a2.t) != env.stripT(t)) throw new Exception(\"error \"+a2+\" \"+a2.t +\" != \"+t)\n        e.copy(t=add(id,t), a=a2) \n      case e @ EId(t: T, id: String) => val r=env.map(id); e.copy(t=r.t)\n      case e @ EAssign(t: T, a: E, b: E) => val a2 = f(a); val b2 = f(b); e.copy(a2.t, a2, b2)\n      case e @ EField(Tn, id: String, idx: String) => val r = env.map(id); f(e.copy(t=r.t))\n      case e @ EField(t: T, id: String, idx: String) =>\n        t match {\n          case t@TStr(ls) => val (idx2,tt) = T.find(t, idx); e.copy(t=tt)\n          case t:TDef => env.stripT(t) match { case t:TDef => throw new Exception(\"type error \"+t) case t => println(t); f(e.copy(t=t)) }\n          case t => e\n        }\n      case e @ ETuple(t:T,ls:List[E]) => e.copy(ls=ls.map(f))\n      case e @ ETag(t:T,id:String,ls:List[E]) => val r = env.map(id); e.copy(t=r.t,ls=ls.map(f) )\n      case e @ ESwitch(t: T, d: E, cases:List[(E,E)] ) =>\n        val d2 = f(d)\n        val dt = env.stripT(d2.t)\n        e.copy(\n            a=d2,\n            cases=cases.map{\n              case (a@ETag(t,id,ls),b)=>\n                val ls2 = env.findTag(dt.asInstanceOf[TVariant],id).types.zip(ls) map {\n                  case ((_,t), e @ EVal(_,id2,_)) => add(id2,t); e.copy(t,id2)\n                  case _ => throw new Exception(\"error\")\n                }\n                (a.copy(t=dt,ls=ls2), f(b))\n              case (a,b) => (a,f(b))\n            })\n      case e @ EUnit => e\n      case e @ EType(t@TVariant(ls), id:String) => env.add(id, RR(t,null));for((tag,_)<-ls) env.add(tag, RR(t,null));  e\n      case e @ EType(t:T, id:String) => env.add(id, RR(t, null)); e\n      case e @ ECase(t:T, a:E) => f(a)\n    }\n  }\n}\n\nobject parseTest {\n    \n  def main(args:Array[String]) {\n    run(\"\"\"{\n        print_i(100+2*3)\n        print_i(10)\n        print_i(20)\n    }\"\"\")\n    run(\"\"\"{\n        val a = 10\n        print_i(a)\n        print_i(a+10*a)\n    }\"\"\")\n    \n    // \u69cb\u9020\u4f53\n    run(\"\"\"{\n        type SA = struct { a:Int b:Int }\n        val c = 10\n        val aa:SA\n        aa.a = 9\n        aa.b = c\n        print_i(aa.a)\n        print_i(aa.b)\n    }\"\"\")\n    // \u69cb\u9020\u4f53\u521d\u671f\u5316\u30ea\u30c6\u30e9\u30eb\n    run(\"\"\"{\n        type SA = struct { a:Int b:Int }\n        val ab:SA = (123,456)\n        print_i(ab.a)\n        print_i(ab.b)\n    }\"\"\")\n    // \u30f4\u30a1\u30ea\u30a2\u30f3\u30c8\n    run(\"\"\"{\n        type Data = enum { A(a:Int) B(a:Int b:Int) }\n        val data:Data\n        val data2:Data = B(555,777)\n    }\"\"\")\n    run(\"\"\"{\n        // switch\n        switch(2) {\n        case 1: print_i(10001)\n        case 2: print_i(10002)\n        case 3: print_i(10003) print_i(10004)\n        }\n        print_i(1)\n        switch(0) {\n        case 1: print_i(10001)\n        case 2: print_i(10002)\n        case 3: print_i(10003)\n        }\n    }\"\"\")\n    run(\"\"\"{\n        \n        // alpha test\n        val a = 1000\n        print_i(a)\n        val a:Int = a + 2000\n        print_i(a)\n        // alpha block test\n        {\n          val a = 5000\n          print_i(a)\n        }\n        print_i(a)\n    }\"\"\")\n    run(\"\"\"{\n        type Data = enum { A(a:Int) B(a:Int b:Int) }\n        val data2:Data = B(555,777)\n        // match\u69cb\u6587\n        switch(data2) {\n        case A(x) : print_i(x)\n        case B(x,y) : print_i(x) print_i(y)\n        }\n        val data3:Data = A(333)\n        switch(data3) {\n        case A(x) : print_i(x)\n        case B(x,y) : print_i(x) print_i(y)\n        }\n        val x = 10\n        print_i(x)\n    }\"\"\")\n  }\n\n  def run(src:String) {\n    println(\"src=\"+src)\n    val result = parser.parseAll(parser.block,src)\n    if(!result.successful) {\n      println(result)\n      throw new Exception(result+\"\")\n    }\n    val ast = result.get\n  \n    env.map = Map(\"Int\"->RR(Ti(32),null))\n    println(\"ast=\"+ast)\n    val ast2 = alpha(ast)\n    val ast3 = typing(ast2)\n    println(\"ast3=\"+ast3)\n    val ll = kNormal(ast3)\n    println(\"ll=\" + ll)\n    val ll2 = constFold(ll)\n    emit(\"e.ll\", ll2)\n    println(exec(\"llc e.ll -o e.s\"))\n    println(exec(\"llvm-gcc -m64 e.s -o e\"))\n    println(exec(\"./e\"))\n  }\n}\n```\n\n```scala:core.scala\npackage chapter11\n\nimport java.io._\nimport util.parsing.input.Positional\n\nsealed trait E extends Positional {\n  def t:T\n}\ncase class ELdc(t:T, i:Long) extends E\ncase class EBin(t:T, s:String, l:E, r:E) extends E\ncase class EPrint(t:T, a:E) extends E\ncase class EBlock(t: T, ls: List[E]) extends E\ncase class EVal(t: T, id: String, a: E) extends E\ncase class EId(t: T, id: String) extends E\ncase class EAssign(t: T, a: E, b: E) extends E\ncase class EField(t: T, id: String, idx: String) extends E\ncase class ETuple(t:T,ls:List[E]) extends E\ncase class ETag(t:T,id:String,ls:List[E]) extends E\ncase class ESwitch(t: T, a: E, cases:List[(E,E)] ) extends E\ncase object EUnit extends E { def t = Tv }\ncase class EType(t:T, id:String) extends E\ncase class ECase(t:T, e:E) extends E\n\nsealed trait T extends Positional\ncase class Ti(i:Int) extends T\ncase object Tv extends T\ncase object Tn extends T\ncase class TFun(t: T, prms: List[T]) extends T\ncase class TStr(types: List[(String, T)]) extends T\ncase class TVariant(ls:List[(String,TStr)]) extends T\ncase class Tp(t:T) extends T\ncase class TDef(id:String) extends T\n\nobject T {\n  def find(t:TStr, a: String): (Int, T) = {\n    def f(i: Int, xs: List[(String, T)]): (Int, T) = {\n      xs match {\n        case List() => (-1, Tv)\n        case (x, t) :: xs => if (a == x) (i, t) else f(i + 1, xs)\n      }\n    }\n    f(0, t.types)\n  }\n}\n\ncase class Op(s: String) {\n  def apply(t: T, a: E, b: E): E = {\n    EBin(t, s, a, b)\n  }\n}\nobject EAdd extends Op(\"add\")\nobject EMul extends Op(\"mul\")\n\nsealed trait R {\n  def t:T\n  def id:String\n}\ncase class RG(t:T, id: String) extends R\ncase class RL(t:T, id: String) extends R\ncase class RR(t:T, id: String) extends R\ncase class RN(t:T, id: String) extends R\n\nobject test {\n  def main(argv: Array[String]) {\n    try {\n      val t = TVariant(List(\n          \"A\"->TStr(List(\"a\"->Ti(32))),\n          \"B\"->TStr(List(\"a\"->Ti(32), \"b\"->Ti(32)))\n        ))\n      val ast = EBlock(Tv, List(\n        EPrint(Ti(32), ELdc(Ti(32), 11)),\n        EPrint(Ti(32), EAdd(Ti(32), ELdc(Ti(32), 11), ELdc(Ti(32), 22))),\n        // \u5909\u6570 a \u5b9a\u6570\n        EVal(Ti(32), \"a\", ELdc(Ti(32), 11)),\n        EPrint(Ti(32), EId(Ti(32), \"a\")),\n        // \u5909\u6570 b \u8db3\u3057\u7b97\n        EVal(Ti(32), \"b\", EAdd(Ti(32), ELdc(Ti(32), 11), ELdc(Ti(32), 22))),\n        EPrint(Ti(32), EId(Ti(32), \"b\")),\n        // \u5909\u6570 c \u5909\u6570\u306e\u5024\n        EVal(Ti(32), \"c\", EId(Ti(32), \"a\")),\n        EPrint(Ti(32), EId(Ti(32), \"c\")),\n        // \u69cb\u9020\u4f53\n        EVal(TStr(List((\"a\", Ti(32)), (\"b\", Ti(32)))), \"aa\", null),\n        EAssign(Ti(32), EField(Ti(32), \"aa\", \"a\"), ELdc(Ti(32), 9)),\n        EAssign(Ti(32), EField(Ti(32), \"aa\", \"b\"), EId(Ti(32), \"c\")),\n        EPrint(Ti(32), EField(Ti(32), \"aa\", \"a\")),\n        EPrint(Ti(32), EField(Ti(32), \"aa\", \"b\")),\n        // \u69cb\u9020\u4f53\u521d\u671f\u5316\u30ea\u30c6\u30e9\u30eb\n        EVal(TStr(List((\"a\", Ti(32)), (\"b\", Ti(32)))), \"ab\",\n          ETuple(TStr(List((\"a\", Ti(32)), (\"b\", Ti(32)))),\n            List(ELdc(Ti(32),123),ELdc(Ti(32),456)))),\n        EPrint(Ti(32), EField(Ti(32), \"ab\", \"a\")),\n        EPrint(Ti(32), EField(Ti(32), \"ab\", \"b\")),\n\n        // \u30f4\u30a1\u30ea\u30a2\u30f3\u30c8\n        EVal(TVariant(List(\n          \"A\"->TStr(List(\"a\"->Ti(32))),\n          \"B\"->TStr(List(\"a\"->Ti(32), \"b\"->Ti(32)))\n        )),\"data\", null),\n\n        EVal(TVariant(List(\n            \"A\"->TStr(List(\"a\"->Ti(32))),\n            \"B\"->TStr(List(\"a\"->Ti(32), \"b\"->Ti(32)))\n          )),\n          \"data2\",\n          ETag(TVariant(List(\n            \"A\"->TStr(List(\"a\"->Ti(32))),\n            \"B\"->TStr(List(\"a\"->Ti(32), \"b\"->Ti(32)))\n            )),\n            \"B\",\n            List(\n              ELdc(Ti(32), 555),\n              ELdc(Ti(32), 777)\n          ))\n        ),\n        // switch\n        ESwitch(Ti(32), ELdc(Ti(32), 2), List(\n          ELdc(Ti(32), 1) -> EPrint(Ti(32), ELdc(Ti(32), 10001)),\n          ELdc(Ti(32), 2) -> EPrint(Ti(32), ELdc(Ti(32), 10002)),\n          ELdc(Ti(32), 3) -> EPrint(Ti(32), ELdc(Ti(32), 10003))\n        )),\n        ESwitch(Ti(32), ELdc(Ti(32), 0), List(\n          ELdc(Ti(32), 1) -> EPrint(Ti(32), ELdc(Ti(32), 10001)),\n          ELdc(Ti(32), 2) -> EPrint(Ti(32), ELdc(Ti(32), 10002)),\n          ELdc(Ti(32), 3) -> EPrint(Ti(32), ELdc(Ti(32), 10003))\n        )),\n        \n        // alpha test\n        EVal(Ti(32), \"a\", ELdc(Ti(32), 1000)),\n        EPrint(Ti(32), EId(Ti(32), \"a\")),\n        EVal(Ti(32), \"a\", EAdd(Ti(32), EId(Ti(32),\"a\"), ELdc(Ti(32),2000))),\n        EPrint(Ti(32), EId(Ti(32), \"a\")),\n        // alpha block test\n        EBlock(Tv, List(\n          EVal(Ti(32), \"a\", ELdc(Ti(32), 5000)),\n          EPrint(Ti(32), EId(Ti(32), \"a\"))\n        )),\n        EPrint(Ti(32), EId(Ti(32), \"a\")),\n\n        // match\u69cb\u6587\n        ESwitch(t, EId(t,\"data2\"), List(\n          ETag(t, \"A\", List(EVal(Ti(32),\"x\",null))) -> EBlock(Tv,List(EPrint(Ti(32),EId(Ti(32),\"x\")))),\n          ETag(t, \"B\", List(EVal(Ti(32),\"x\",null),EVal(Ti(32),\"y\",null))) -> EBlock(Tv,List(EPrint(Ti(32),EId(Ti(32),\"x\")),EPrint(Ti(32),EId(Ti(32),\"y\"))))\n        )),\n\n        EVal(t, \"data3\",\n          ETag(t, \"A\", List(\n              ELdc(Ti(32), 333)\n          ))\n        ),\n        ESwitch(t, EId(t,\"data3\"), List(\n          ETag(t, \"A\", List(EVal(Ti(32),\"x\",null))) -> EBlock(Tv,List(\n              EPrint(Ti(32),EId(Ti(32),\"x\")))),\n          ETag(t, \"B\", List(EVal(Ti(32),\"x\",null),EVal(Ti(32),\"y\",null))) -> EBlock(Tv,List(\n              EPrint(Ti(32),EId(Ti(32),\"x\")),\n              EPrint(Ti(32),EId(Ti(32),\"y\"))))\n        )),\n        EVal(Ti(32),\"x\",ELdc(Ti(32),10)),\n        EPrint(Ti(32),EId(Ti(32),\"x\")),\n        EType(TStr(List((\"a\", Ti(32)), (\"b\", Ti(32)))), \"Dt\"),\n        EVal(TDef(\"Dt\"), \"a2\", null),\n        EAssign(Ti(32), EField(Ti(32), \"a2\", \"a\"), ELdc(Ti(32), 9)),\n        EPrint(Ti(32), EField(Ti(32), \"a2\", \"a\"))\n        \n      ))\n      println(\"ast=\" + ast)\n      val ast2 = alpha(ast)\n      println(\"ast2=\" + ast2)\n      val ll = kNormal(ast2)\n      println(\"ll=\" + ll)\n      val ll2 = constFold(ll)\n      emit(\"e.ll\", ll2)\n      println(exec(\"llc e.ll -o e.s\"))\n      println(exec(\"llvm-gcc -m64 e.s -o e\"))\n      println(exec(\"./e\"))\n    } catch {\n      case e:Throwable => e.printStackTrace()\n    }\n  }\n}\n\nobject alpha {\n\n  def find(id: String, env: Map[String, String]): String = {\n    if (env.contains(id)) env(id) else id\n  }\n\n  def apply(e: E): E = {\n    f(e, Map()) match { case(e, _) => e }\n  }\n  def l(ls:List[E],env:Map[String,String]):(List[E],Map[String, String]) = {\n    val (ls2,env2) = ls.foldLeft(List[E](), env) {\n      case ((ls, env), a) =>\n        val (a1, env1) = f(a, env)\n        ((a1 :: ls), env1)\n    }\n    (ls2.reverse,env2)\n  }\n  def l2(ls:List[(E,E)],env:Map[String,String]):(List[(E,E)],Map[String, String]) = {\n    val (cases1, env2) = ls.foldLeft(List[(E,E)](), env) {\n      case ((ls, env), (a,b)) =>\n        val (a1, env1) = f(a, env)\n        val (b1, env2) = f(b, env1)\n        (((a1,b1) :: ls), env)\n    }\n    (cases1.reverse, env2)\n  }\n  def f(e: E, env: Map[String, String]): (E, Map[String, String]) = {\n    e match {\n      case e @ EBin(t: T, i: String, a: E, b: E) =>\n        val (a1, env1) = f(a, env)\n        val (b1, env2) = f(b, env1)\n        (e.copy(t, i, a1, b1), env2)\n      case e @ ELdc(t: T, i: Long) => (e.copy(t, i), env)\n      case e @ EBlock(t: T, ls: List[E]) =>\n        val (ls1, env1) = l(ls, env)\n        (e.copy(t, ls1), env)\n      case e @ EPrint(t: T, a: E) =>\n        val (a1, env1)  = f(a, env)\n        (e.copy(t, a1), env1)\n      case e @ EVal(t: T, id: String, a) =>\n        val (a1,env1) = if (a == null) (null, env) else f(a, env)\n        val id2 = if (env.contains(id)) genid(\".\") else id\n        (e.copy(t, id2, a1), env1 + (id -> id2))\n      case e @ EId(t: T, id: String) => (e.copy(t, find(id, env)), env)\n      case e @ EField(t: T, id: String, idx: String) =>\n        (e.copy(t, find(id, env), idx), env)\n      case e @ EAssign(t: T, a: E, b: E) =>\n        val (a1, env1) = f(a, env)\n        val (b1, env2) = f(b, env1)\n        (e.copy(t, a1, b1), env2)\n      case e @ ESwitch(t: T, a: E, cases:List[(E,E)]) =>\n        val (a1, env1) = f(a, env)\n        val (cases1, _) = l2(cases, env1)\n        (e.copy(t, a1, cases1), env)\n      case e @ EUnit => (e, env)\n      case e @ ETag(t: T, id:String, ls: List[E]) =>\n        val (ls1, env1) = l(ls, env)\n        (e.copy(t, id, ls1), env1)\n      case e @ ETuple(t:T,ls:List[E]) =>\n        val (ls1, env1) = l(ls, env)\n        (e.copy(t, ls1), env1)\n      case e @ EType(t:T, id:String) => (e.copy(t, id), env)\n      case e : ECase => throw new Exception(\"error\")\n    }\n  }\n}\n\nobject kNormal {\n  def gid(t:T): R = {\n    RR(t,genid(\"\"))\n  }\n  var ls: List[LL] = null\n  def add(l: LL) {\n    ls = l :: ls\n  }\n\n  def arr(e: E): R = {\n    e match {\n      case EField(t, id, idx) =>\n        env.map(id) match {\n          case i:R =>\n            val ((n, nt), reg1) = (T.find(i.t.asInstanceOf[TStr],idx), gid(t))\n            add(LLField(reg1, i, RN(Ti(64),\"0\"), RN(nt,\"\"+n)))\n            reg1\n          case t => throw new Exception(\"type mismatch \" + t)\n        }\n      case EId(t, id) => env.map(id)\n      case _ => throw new Exception(\"error\")\n    }\n  }\n\n  def findTag(tagId:String, n:Int, ls:List[(String, TStr)]):(Int, TStr) = ls match {\n    case List() => throw new Exception(\"not found \"+tagId)\n    case (stId,stT:TStr)::ls => if (stId == tagId) (n,stT) else findTag(tagId, n + 1, ls)\n  }\n\n  def f(a: E): R = {\n    a match {\n      case EBin(t, op, a1, b1) =>\n        (f(a1), f(b1), gid(t)) match {\n          case (a, b, id) =>\n            if (t != a.t || t != b.t) throw new Exception(\"type mismatch \" + t)\n            add(LLBin(id, op, a, b))\n            id\n        }\n      case ELdc(t, i) => RN(t, \"\"+i)\n      case EPrint(t, a) =>\n        f(a) match {\n          case a =>\n            if (t != a.t) throw new Exception(\"type mismatch t=\" + t + \" ta=\" + a.t)\n            add(LLCall(null, RG(TFun(Tv, List(t)), \"print_\" + emit.llt(t)), List((a.t, a))))\n            a\n        }\n      case EBlock(t, ls) =>\n        ls.foldLeft(null: R) {\n          case (tid, l) => f(l)\n        }\n      case EVal(t: TStr, id, tpl) =>\n        emit.llstruct(t)\n        env.add(RL(t,id))\n        add(LLAlloca(RL(t,id)))\n        tpl match {\n          case ETuple(_, ls) =>\n            for ((e, (name, t)) <- ls.zip(t.types)) {\n              f(EAssign(t, EField(t, id, name), e))\n            }\n          case null =>\n          case _ => throw new Exception(\"error\")\n        }\n        RL(t,id)\n      case EVal(t: TVariant, id, tpl) =>\n        val (_, valT, maxT, _) = emit.llvariantInfo(t)\n        env.add(RL(t,id))\n        add(LLAlloca(RL(t,id)))\n        tpl match {\n          case ETag(_, tagId, ls) =>\n            val (tagIdx, stT) = findTag(tagId, 0, t.ls)\n            val tagR = gid(stT)\n            // tag id \u306e\u30a2\u30c9\u30ec\u30b9\u53d6\u5f97\n            add(LLField(tagR, RL(valT, id), RN(Ti(64), \"0\"), RN(Ti(32), \"0\")))\n            // tag id\u4fdd\u5b58\n            add(LLStore(RN(Ti(32),\"\"+tagIdx), tagR))\n\n            // \u5185\u90e8\u306e\u69cb\u9020\u4f53\u306e\u30a2\u30c9\u30ec\u30b9\u3092\u53d6\u5f97\n            val maxAdrR = gid(Tp(maxT))\n            add(LLField(maxAdrR, RL(valT, id), RN(Ti(64), \"0\"), RN(Ti(32), \"1\")))\n\n            // \u30ad\u30e3\u30b9\u30c8\u3059\u308b\n            val stId = genid(\"st\")\n            val stR = RL(Tp(stT), stId)\n            add(LLBitCast(stR, maxAdrR))\n\n            // \u767b\u9332\u3059\u308b\n            env.add(RL(stT, stId))\n\n            // \u5404\u30d5\u30a3\u30fc\u30eb\u30c9\u5024\u3092\u8a2d\u5b9a\u3059\u308b\n            for ((e, (id, t)) <- ls.zip(stT.types)) {\n              f(EAssign(t, EField(t, stId, id), e))\n            }\n          case null =>\n          case _ => throw new Exception(\"error\")\n        }\n        RL(t,id)\n      case e @ EVal(t, id, a) =>\n        val t2 = env.stripT(t)\n        t2 match {\n          case t: TStr => f(e.copy(t = t))\n          case t: TVariant => f(e.copy(t = t))\n          case _ =>\n            env.add(RL(t, id))\n            f(a) match {\n              case a =>\n                add(LLAssign(RL(a.t, id), a))\n                RL(a.t, id)\n            }\n        }\n      case EId(t, id) => env.map(id)\n      case EAssign(t, a, b) =>\n        (arr(a), f(b)) match {\n          case (a, b) =>\n            if (env.stripT(t) != env.stripT(b.t)) throw new Exception(\"type mismatch \" + t + \" \" + b.t)\n            add(LLStore(b, a))\n            b\n        }\n      case a: EField =>\n        val a2 = arr(a)\n        val b = gid(a2.t)\n        add(LLLoad(b, a2))\n        b\n      case ESwitch(t: TVariant, a: E, cases: List[(E, E)]) =>\n        val valR = f(a)\n        val tagAdrR = gid(valR.t)\n        add(LLField(tagAdrR, valR, RN(Ti(64), \"0\"), RN(Ti(32), \"0\")))\n\n        val tagR = gid(Ti(32))\n        add(LLLoad(tagR, tagAdrR))\n\n        // \u30c6\u30fc\u30d6\u30eb\u30b8\u30e3\u30f3\u30d7\n        val lbl = genid(\"match\")\n        val ls = for ((ETag(tl: TVariant, id, vs), _) <- cases) yield {\n          val (tagIdx,stT) = findTag(id, 0, tl.ls)\n          (tagIdx.asInstanceOf[Long], lbl + \".\" + tagIdx)\n        }\n        add(LLSwitch(tagR, lbl, ls))\n\n        // \u5404\u30b1\u30fc\u30b9\n        val (_, _, maxT, _) = emit.llvariantInfo(env.stripT(a.t).asInstanceOf[TVariant])\n        for ((ETag(tl: TVariant, id, vs), e) <- cases) {\n          val (tagIdx,stT) = findTag(id, 0, tl.ls)\n          add(LLLabel(lbl + \".\" + tagIdx))\n\n          val maxAdrR = gid(Tp(maxT))\n          add(LLField(maxAdrR, valR, RN(Ti(64), \"0\"), RN(Ti(32), \"1\")))\n\n          val stId = genid(\"st\")\n          val stR = RL(stT, stId)\n          add(LLBitCast(RL(Tp(stT), stId), maxAdrR))\n          env.add(stR)\n\n          for ((e: EVal, (id, t)) <- vs.zip(stT.types)) {\n            f(e.copy(e.t, e.id, EField(t, stId, id)))\n          }\n          f(e)\n          add(LLGoto(lbl))\n        }\n        add(LLLabel(lbl))\n        null\n      case e @ ESwitch(t: T, a: E, cases: List[(E, E)]) =>\n        env.stripT(a.t) match {\n          case t:TVariant => return f(e.copy(t=t))\n          case _ =>\n        }\n        val ra = f(a)\n        val lbl = genid(\"switch\")\n        val (length, ls) = cases.foldLeft(0, List[(Long, String)]()) {\n          case ((n, ls), (ELdc(tl, a), _)) => (n + 1, (a, lbl + n) :: ls)\n          case ((n, ls), (EUnit, _)) => (n + 1, (-1L, lbl + n) :: ls)\n        }\n        add(LLSwitch(ra, lbl, ls.reverse))\n        for((n, (_, e)) <- (0 until cases.length).zip(cases)) {\n          add(LLLabel(lbl + n)); f(e); add(LLGoto(lbl))\n        }\n        add(LLLabel(lbl))\n        null\n      case EType(t: T, id: String) =>\n        env.map = env.map + (id -> RR(t, null))\n        null\n    }\n  }\n\n  def apply(a: E): List[LL] = {\n    ls = List[LL]()\n    f(a)\n    ls.reverse\n  }\n}\n\nobject env {\n  var map = Map[String, R]()\n  def add(r: R) {\n    map = map + (r.id -> r)\n  }\n  def add(id:String, r:R) {\n    map = map + (id -> r)\n  }\n  def findTag(t:TVariant, id:String):TStr = {\n    for((tag,t) <- t.ls) {\n      if(tag==id) return t\n    }\n    throw new Exception(\"not found tag \"+id)\n  }\n  def stripT(t:T):T = {\n    t match {\n      case TDef(id) =>\n        val r = env.map(id)\n        if(r.id != null) throw new Exception(id + \" is not type\")\n        stripT(r.t)\n      case t => t\n    }\n  }\n}\n\nsealed trait LL\ncase class LLCall(id: R, op: R, prms: List[(T, R)]) extends LL\ncase class LLBin(id: R, op: String, a: R, b: R) extends LL\ncase class LLAssign(s: R, d: R) extends LL\ncase class LLField(id1: R, aid: R, z: R, b: R) extends LL\ncase class LLAlloca(id: R) extends LL\ncase class LLLoad(id1: R, id2: R) extends LL\ncase class LLStore(id1: R, id2: R) extends LL\ncase class LLBitCast(did: R, sid:R) extends LL\ncase class LLSwitch(reg:R, label:String, cases:List[(Long,String)]) extends LL\ncase class LLGoto(label:String) extends LL\ncase class LLLabel(s: String) extends LL\n\nobject constFold {\n  var map: Map[R, R] = null\n  def m(v: R): R = {\n    if (map.contains(v)) m(map(v)) else v\n  }\n  def fs(prms: List[(T, R)]): List[(T, R)] = {\n    prms.map {\n      case (t, v) => (t, m(v))\n    }\n  }\n  def apply(ls: List[LL]): List[LL] = {\n    map = Map()\n    ls.foldLeft(List[LL]()) {\n      case (ls, l @ LLCall(id, op, prms)) => l.copy(prms = fs(prms)) :: ls\n      case (ls, l @ LLBin(id, op, a, b)) => l.copy(a = m(a), b = m(b)) :: ls\n      case (ls, l @ LLAssign(s, d)) => map = map + (s -> d); ls\n      case (ls, l @ LLAlloca(id: R)) => l.copy(m(id)) :: ls\n      case (ls, l @ LLField(id, id2, id3, id4)) => l.copy(id, m(id2), m(id3), m(id4)) :: ls\n      case (ls, l @ LLStore(id1, id2)) => l.copy(m(id1), m(id2)) :: ls\n      case (ls, l @ LLLoad(id1, id2)) => l.copy(m(id1), m(id2)) :: ls\n      case (ls, l @ LLBitCast(did, sid)) => l.copy(m(did),m(sid)) :: ls\n      case (ls, l @ LLSwitch(n, lbl, cases)) => l.copy(m(n), lbl, cases)::ls\n      case (ls, l @ LLLabel(_)) => l::ls\n      case (ls, l @ LLGoto(_)) => l::ls\n      case (ls, l) => throw new Exception(\"error no implementation \"+l)\n    }.reverse\n  }\n}\n\nobject emit {\n\n  def llt(t:T):String = {\n    t match {\n      case Ti(i) => \"i\" + i\n      case Tv => \"void\"\n      case TFun(t, ls) => llt(t) + \"(\" + ls.map(llt).mkString(\", \") + \")*\"\n      case t:TStr => llstruct(t)\n      case t:TVariant => llvariant(t)\n      case Tp(t) => llt(t) + \"*\"\n      case t:TDef => llt(env.stripT(t))\n      case Tn => throw new Exception(\"error\")\n    }\n  }\n  // \u30b5\u30a4\u30ba\u8a08\u7b97\n  def size(t:T):Int = {\n    env.stripT(t) match {\n      case t@TStr(ls) =>\n        llstruct(t) // \u69cb\u9020\u4f53\u306e\u767b\u9332\n        ls.foldLeft(0) { case (s,(n,t)) => s + size(t) }\n      case Ti(n) => n / 8\n      case Tv => 0\n      case t:TFun => 8\n      case t:TVariant =>\n        val (_, _, m, _) = llvariantInfo(t)\n        size(m) + 4\n      case Tp(n) => 8\n      case Tn => throw new Exception(\"error\")\n      case t:TDef => throw new Exception(\"error\")\n    }\n  }\n  /**\n   * \u30f4\u30a1\u30ea\u30a2\u30f3\u30c8\u578b\u306e\u60c5\u5831\u3092\u53d6\u5f97\n   * (\u578b\u306e\u540d\u524d, \u69cb\u9020\u4f53, \u6700\u5927\u30b5\u30a4\u30ba\u69cb\u9020\u4f53, \u5185\u90e8\u306e\u69cb\u9020\u4f53\u30ea\u30b9\u30c8)\n   */\n  def llvariantInfo(v:TVariant):(String,TStr,TStr,List[TStr]) = {\n    val (maxsize, maxt, tys) = v.ls.foldLeft((0, null:TStr, List[TStr]())) {\n      case ((n:Int,t,ls),(name:String,vt:T)) =>\n        val sizevt = size(vt)\n        if (sizevt > n) (sizevt, vt,vt::ls) else (n, t,vt::ls)\n    }\n    val t = TStr(List(\"tag\"->Ti(32),\"data\"->maxt))\n    (llstruct(t), t, maxt, tys)\n  }\n\n  def llvariant(v:TVariant):String = {\n    llvariantInfo(v) match {\n      case (s,_,_,_) => s\n    }\n  }\n\n  def llr(r:R): String = {\n    r match {\n      case RG(t,id) => \"@\" + id\n      case RL(t,id) => \"%\" + id\n      case RR(t,id) => \"%.\" + id\n      case RN(t,id) => \"\" + id\n    }\n  }\n  \n  def o(id: R, out: String) {\n    if (id != null) asm(llr(id) + \" = \" + out)\n    else asm(out)\n  }\n  def f(l: LL) {\n    l match {\n      case LLCall(id, op, prms) =>\n        val ps = prms.map { case (a, b) => llt(a) + \" \" + llr(b) }.mkString(\", \")\n        o(id, \"call \" + llt(op.t) + \" \" + llr(op) + \"(\" + ps + \") nounwind\")\n      case LLBin(id, op, a, b) =>\n        o(id, op + \" \" + llt(id.t) + \" \" + llr(a) + \", \" + llr(b))\n      case _:LLAssign => throw new Exception(\"error\")\n      case LLField(reg1: R, addr: R, zero: R, a: R) =>\n        o(reg1, \"getelementptr inbounds \" + llt(addr.t) + \"* \" + llr(addr) + \", \" + llt(zero.t) + \" \" + llr(zero) + \", \" + llt(a.t) + \" \" + llr(a))\n      case LLLoad(reg1: R, reg2: R) =>\n        o(reg1, \"load \" + llt(reg1.t) + \"* \" + llr(reg2))\n      case LLStore(reg1: R, reg2: R) =>\n        asm(\"store \" + llt(reg1.t) + \" \" + llr(reg1) + \", \" + llt(reg1.t) + \"* \" + llr(reg2))\n      case LLAlloca(reg: R) =>\n        o(reg, \"alloca \" + llt(reg.t))\n      case LLBitCast(d: R, s:R) =>\n        o(d, \"bitcast \" + llt(s.t) + \" \" + llr(s) + \" to \" + llt(d.t))  \n      case LLSwitch(n, lbl, cases) =>\n        asm(\"switch \"+llt(n.t)+\" \"+llr(n)+\", label %\"+lbl+ \" [\")\n        for((a,b) <- cases) {\n          asm(\"  i32 \" + a + \", label %\"+b)\n        }\n        asm(\"]\")\n      case LLLabel(l) =>\n        asm.label(l+\":\")\n      case LLGoto(l) =>\n        asm(\"br label %\"+l)\n    }\n  }\n\n  var structs: Map[TStr, String] = Map()\n  def llstruct(t: TStr): String = {\n    if (structs.contains(t)) return structs(t)\n    val name = genid(\"%.struct\")\n    structs = structs + (t -> name)\n    name\n  }\n\n  def apply(file: String, ls: List[LL]) {\n    asm.open(file)\n    structs.foreach { case (t, n) =>\n        asm(n + \" = type {\" + t.types.map { case (a, b) => llt(b) }.mkString(\", \") + \"}\")\n    }\n    asm.label(\"@.str = private constant [4 x i8] c\\\"%d\\\\0A\\\\00\\\"\")\n    asm.label(\"define void @print_i32(i32 %a) nounwind ssp {\")\n    asm.label(\"entry:\")\n    asm(\"call i32 (i8*, ...)* @printf(i8* getelementptr inbounds ([4 x i8]* @.str, i64 0, i64 0), i32 %a) nounwind\")\n    asm(\"ret void\")\n    asm.label(\"}\")\n    asm.label(\"define void @print_i8(i8 %a) nounwind ssp {\")\n    asm.label(\"entry:\")\n    asm(\"call i32 (i8*, ...)* @printf(i8* getelementptr inbounds ([4 x i8]* @.str, i64 0, i64 0), i8 %a) nounwind\")\n    asm(\"ret void\")\n    asm.label(\"}\")\n\n    asm.label(\"declare i32 @printf(i8*, ...) nounwind\")\n\n    asm.label(\"define i32 @main() nounwind ssp {\")\n    asm.label(\"entry:\")\n    ls.foreach(f)\n    asm(\"ret i32 0\")\n    asm.label(\"}\")\n    asm.close()\n  }\n}\n\nobject genid {\n  var id = 0\n  def apply(s: String): String = {\n    id += 1\n    s + id\n  }\n}\nobject asm {\n  var p: PrintWriter = null\n  def open(file: String) {\n    p = new PrintWriter(new BufferedWriter(new FileWriter(file)))\n  }\n\n  var indent: String = \"\"\n\n  def apply(s: String, n: String = \"\") {\n    val v = indent + s + \"\\t\" + n + \"\\n\"\n    p.print(v)\n  }\n  def label(s: String) {\n    asm.indent = \"\";\n    apply(s)\n    asm.indent = \"\\t\";\n  }\n  def close() {\n    p.close()\n  }\n}\n\nobject exec {\n  def apply(cmd: String): (Int, String, String) = {\n    val p = Runtime.getRuntime().exec(cmd)\n    val stdin = (readAll(p.getInputStream()))\n    val stderr = (readAll(p.getErrorStream()))\n    (p.waitFor(), stdin, stderr)\n  }\n\n  def readAll(p: InputStream): String = {\n    def f(s: String, i: BufferedReader): String = {\n      i.readLine() match {\n        case null => s\n        case a => f(s + a + \"\\n\", i)\n      }\n    }\n    f(\"\", new BufferedReader(new InputStreamReader(p)))\n  }\n}\n```\n\n## \u307e\u3068\u3081\n\n\u30d1\u30fc\u30b5\u30b3\u30f3\u30d3\u30cd\u30fc\u30bf\u3067\u30d1\u30fc\u30b5\u3092\u4f5c\u308a\u3001AST\u306b\u578b\u30c1\u30a7\u30c3\u30af\u3092\u5165\u308c\u305f\u4e8b\u3067\u3001\u52d5\u4f5c\u3059\u308b\u3088\u3046\u306b\u306a\u308a\u307e\u3057\u305f\u3002\u304a\u305d\u3089\u304f\u30c6\u30b9\u30c8\u30b3\u30fc\u30c9\u4ee5\u5916\u306e\u30b3\u30fc\u30c9\u3092\u52d5\u304b\u305d\u3046\u3068\u3059\u308b\u3068\u30d0\u30b0\u304c\u51fa\u308b\u3068\u601d\u3044\u307e\u3059\u304c(\u51fa\u306a\u3044\u304b\u3082\u3057\u308c\u306a\u3044\u3067\u3059\u304c)\u3001\u30d0\u30b0\u6f70\u3057\u3092\u59cb\u3081\u308b\u3068\u5927\u5909\u306a\u306e\u3067\u3053\u3053\u307e\u3067\u3068\u3057\u307e\u3059\u3002\n\n## \u4eca\u5f8c\u306e\u4e88\u5b9a\n\n\u3053\u306e\u5f8c\u306e\u4e88\u5b9a\u306f\u3001\u307b\u3093\u3068\u3046\u306b\u4f7f\u3048\u308b\u8a00\u8a9e\u306b\u4ed5\u4e0a\u3052\u3066\u884c\u3063\u305f\u308a\u3059\u308b\u4e8b\u3068\u3001\u30d1\u30bf\u30fc\u30f3\u30de\u30c3\u30c1\u306e\u4f5c\u308a\u65b9\u3092\u5947\u9e97\u306b\u7e8f\u3081\u308b\u4e8b\u3067\u3059\u3002\u6587\u7ae0\u80fd\u529b\u306f\u4f4e\u3044\u306e\u3067\u5927\u5909\u3067\u3059\u3051\u3069\u3001\u60a9\u3093\u3067\u306a\u3044\u65b9\u304c\u591a\u5206\u5206\u304b\u308a\u3084\u3059\u3044\u3060\u308d\u3046\u3068\u3044\u3046\u306e\u304c\u3042\u3063\u3066\u305d\u306e\u3088\u3046\u306b\u4f5c\u308d\u3046\u3068\u601d\u3063\u3066\u3044\u307e\u3059\u3002\u4eca\u56de\u306fScala\u3067\u4f5c\u6210\u3057\u307e\u3057\u305f\u304c\u3001Haxe\u3067\u4f5c\u3063\u3066\u307f\u308b\u306e\u3082\u3042\u308a\u3060\u3088\u306a\u3041\u3068\u601d\u3063\u3066\u3044\u307e\u3059\u3002Haxe\u3067\u4f5c\u308c\u3070\u3001CPP\u306b\u5909\u63db\u3067\u304d\u308b\u306e\u3067C\u8a00\u8a9e\u98a8\u306e\u8a00\u8a9e\u3067\u5947\u9e97\u306b\u30cd\u30a4\u30c6\u30a3\u30d6\u306a\u30b3\u30f3\u30d1\u30a4\u30e9\u3092\u304b\u3051\u308b\u306f\u305a\u306a\u3093\u3067\u3059\u3002\u554f\u984c\u306f\u3001\u30d1\u30fc\u30b5\u30b3\u30f3\u30d3\u30cd\u30fc\u30bf\u306e\u30e9\u30a4\u30d6\u30e9\u30ea\u3067\u3042\u308b\u3001ParserX\u3092CPP\u3067\u51fa\u529b\u3057\u3088\u3046\u3068\u3059\u308b\u3068\u30a8\u30e9\u30fc\u306b\u306a\u3063\u3066\u3057\u307e\u3046\u306e\u3067\u3001\u30d1\u30fc\u30b5\u306f\u5225\u306a\u65b9\u6cd5\u3067\u5b9f\u88c5\u3059\u308b\u5fc5\u8981\u304c\u3042\u308a\u307e\u3059\u3002\n\n\n## \u53c2\u8003\u6587\u732e\n\n[1][\uff12\u9031\u9593\u3067\u3067\u304d\u308b\uff01\u30b9\u30af\u30ea\u30d7\u30c8\u8a00\u8a9e\u306e\u4f5c\u308a\u65b9](http://gihyo.jp/book/2012/978-4-7741-4974-5)\n[2][Packrat Parser\u3092\u4f7f\u3063\u3066\u307f\u305f](http://sca-lab.blogspot.jp/2011/12/packrat-parser.html)\n[3][tapl-scala](https://github.com/ilya-klyuchnikov/tapl-scala)\n[4][RegexParsers\u3067\u624b\u8efd\u306bScala\u306e\u30d1\u30fc\u30b5\u30b3\u30f3\u30d3\u30cd\u30fc\u30bf\u3092\u4f7f\u3063\u3066\u307f\u308b](http://seratch.hatenablog.jp/entry/20111010/1318254084)\n", "tags": ["\u30d1\u30bf\u30fc\u30f3\u30de\u30c3\u30c1\u306e\u4f5c\u308a\u65b9", "Scala", "\u30d1\u30bf\u30fc\u30f3\u30de\u30c3\u30c1", "\u30b3\u30f3\u30d1\u30a4\u30e9", "\u8a00\u8a9e\u4f5c\u6210"]}