{"context": "\u6a2a\u6d5c\u3078\u306a\u3061\u3087\u3053\u30d7\u30ed\u30b0\u30e9\u30df\u30f3\u30b0\u52c9\u5f37\u4f1a\u306b\u3066\u904e\u53bb\u306b\u51fa\u984c\u3055\u308c\u305fY\u5b57\u8def\u5de1\u308a\u3092\u89e3\u3044\u3066\u307f\u305f\u3002\n\u56de\u7b54\u306b\u304b\u304b\u3063\u305f\u6642\u9593\u306f55\u5206\u3050\u3089\u3044\u3068\u304b\u306a\u308a\u30ae\u30ea\u30ae\u30ea\u3002\n\u9032\u3080\u65b9\u5411\u306e\u6cd5\u5247\u6027\u304c\u3046\u307e\u304f\u8aad\u3081\u305a\u3001@map\u306b\u5165\u308c\u308b\u9806\u5e8f\u3092\u5de5\u592b\u3057\u3066\u3046\u307e\u3044\u3068\u3053\u308d\u51fa\u3059\u3088\u3046\u306b\u5b9f\u88c5\u3059\u308b\u3079\u304d\u304b\u3057\u3070\u3089\u304f\u60a9\u3093\u3060\u3002\n\u5b9f\u88c5\u306b\u4f7f\u3063\u305f\u6642\u9593\u3088\u308a\u3082\u60a9\u3093\u3060\u6642\u9593\u306e\u307b\u3046\u304c\u9577\u3044\u3042\u305f\u308a\u3001\u81ea\u8eab\u306e\u601d\u8003\u529b\u304c\u4f4e\u3044\u3053\u3068\u3092\u5b9f\u611f\u3055\u305b\u3089\u308c\u308b\u3002\nclass Route\n  def initialize\n    @history = [:B, :A]\n    @all = (:A..:F).to_a\n    @map = {\n      A: [:B, :C, :D],\n      B: [:A, :C, :E],\n      C: [:A, :B, :F],\n      D: [:A, :E, :F],\n      E: [:B, :D, :F],\n      F: [:C, :D, :E]\n    }\n    @pattern = [\n      [2, 1],\n      [0, 2],\n      [1, 0]\n    ]\n  end\n\n  def choose input\n    current = @history[-1]\n    prev    = @history[-2]\n    index = @map[current].index prev\n    type = @all.index(current) % 2\n    case input\n    when \"b\"\n      @history.push prev\n    when \"l\"\n      @history.push @map[current][@pattern[index][type]]\n    when \"r\"\n      @history.push @map[current][@pattern[index][type == 0 ? 1 : 0]]\n    end\n  end\n\n  def route\n    @history[1..(@history.size - 1)].join\n  end\nend\n\ntest = <<_TEST\n/*0*/ {\"b\", \"AB\" },\n/*1*/ {\"l\", \"AD\" },\n/*2*/ {\"r\", \"AC\" },\n/*3*/ {\"bbb\", \"ABAB\" },\n/*4*/ {\"rrr\", \"ACBA\" },\n/*5*/ {\"blll\", \"ABCAB\" },\n/*6*/ {\"llll\", \"ADEBA\" },\n/*7*/ {\"rbrl\", \"ACADE\" },\n/*8*/ {\"brrrr\", \"ABEDAB\" },\n/*9*/ {\"llrrr\", \"ADEFDE\" },\n/*10*/ {\"lrlll\", \"ADFEDF\" },\n/*11*/ {\"lrrrr\", \"ADFCAD\" },\n/*12*/ {\"rllll\", \"ACFDAC\" },\n/*13*/ {\"blrrrr\", \"ABCFEBC\" },\n/*14*/ {\"brllll\", \"ABEFCBE\" },\n/*15*/ {\"bbrllrrr\", \"ABACFDEFD\" },\n/*16*/ {\"rrrrblll\", \"ACBACABCA\" },\n/*17*/ {\"llrlrrbrb\", \"ADEFCADABA\" },\n/*18*/ {\"rrrbrllrr\", \"ACBABEFCAD\" },\n/*19*/ {\"llrllblrll\", \"ADEFCBCADEB\" },\n/*20*/ {\"lrrlllrbrl\", \"ADFCBEFDFCB\" },\n/*21*/ {\"lllrbrrlbrl\", \"ADEBCBACFCAB\" },\n/*22*/ {\"rrrrrrlrbrl\", \"ACBACBADFDEB\" },\n/*23*/ {\"lbrbbrbrbbrr\", \"ADABABEBCBCFE\" },\n/*24*/ {\"rrrrlbrblllr\", \"ACBACFCACFDAB\" },\n/*25*/ {\"lbbrblrlrlbll\", \"ADADFDABCFDFED\" },\n/*26*/ {\"rrbbrlrlrblrl\", \"ACBCBADFEBEFDA\" },\n/*27*/ {\"blrllblbrrrrll\", \"ABCFDADEDABEDFE\" },\n/*28*/ {\"blrllrlbllrrbr\", \"ABCFDABCBEFDEDA\" },\n/*29*/ {\"lbrbbrllllrblrr\", \"ADABABEFCBEDEBCF\" },\n/*30*/ {\"rrrrbllrlrbrbrr\", \"ACBACABCFDEDADFC\" },\n_TEST\n\nrequire 'minitest/autorun'\n\ndescribe 'Y Road' do\n  test.split(\"\\n\").each do |line|\n    t, n, input, expect = line.match(/^\\/\\*(\\d+)\\*\\/\\s{\"([^\"]+)\",\\s\"([^\"]+)\"\\s},$/).to_a\n    route = Route.new\n    input.split(//).each do |i|\n      route.choose i\n    end\n    it input do\n      assert_equal route.route, expect\n    end\n  end\nend\n\n\n[\u6a2a\u6d5c\u3078\u306a\u3061\u3087\u3053\u30d7\u30ed\u30b0\u30e9\u30df\u30f3\u30b0\u52c9\u5f37\u4f1a](https://yhpg.doorkeeper.jp/)\u306b\u3066\u904e\u53bb\u306b\u51fa\u984c\u3055\u308c\u305f[Y\u5b57\u8def\u5de1\u308a](http://nabetani.sakura.ne.jp/hena/ord3ynode/)\u3092\u89e3\u3044\u3066\u307f\u305f\u3002\n\u56de\u7b54\u306b\u304b\u304b\u3063\u305f\u6642\u9593\u306f55\u5206\u3050\u3089\u3044\u3068\u304b\u306a\u308a\u30ae\u30ea\u30ae\u30ea\u3002\n\n\u9032\u3080\u65b9\u5411\u306e\u6cd5\u5247\u6027\u304c\u3046\u307e\u304f\u8aad\u3081\u305a\u3001`@map`\u306b\u5165\u308c\u308b\u9806\u5e8f\u3092\u5de5\u592b\u3057\u3066\u3046\u307e\u3044\u3068\u3053\u308d\u51fa\u3059\u3088\u3046\u306b\u5b9f\u88c5\u3059\u308b\u3079\u304d\u304b\u3057\u3070\u3089\u304f\u60a9\u3093\u3060\u3002\n\u5b9f\u88c5\u306b\u4f7f\u3063\u305f\u6642\u9593\u3088\u308a\u3082\u60a9\u3093\u3060\u6642\u9593\u306e\u307b\u3046\u304c\u9577\u3044\u3042\u305f\u308a\u3001\u81ea\u8eab\u306e\u601d\u8003\u529b\u304c\u4f4e\u3044\u3053\u3068\u3092\u5b9f\u611f\u3055\u305b\u3089\u308c\u308b\u3002\n\n```ruby\nclass Route\n  def initialize\n    @history = [:B, :A]\n    @all = (:A..:F).to_a\n    @map = {\n      A: [:B, :C, :D],\n      B: [:A, :C, :E],\n      C: [:A, :B, :F],\n      D: [:A, :E, :F],\n      E: [:B, :D, :F],\n      F: [:C, :D, :E]\n    }\n    @pattern = [\n      [2, 1],\n      [0, 2],\n      [1, 0]\n    ]\n  end\n\n  def choose input\n    current = @history[-1]\n    prev    = @history[-2]\n    index = @map[current].index prev\n    type = @all.index(current) % 2\n    case input\n    when \"b\"\n      @history.push prev\n    when \"l\"\n      @history.push @map[current][@pattern[index][type]]\n    when \"r\"\n      @history.push @map[current][@pattern[index][type == 0 ? 1 : 0]]\n    end\n  end\n\n  def route\n    @history[1..(@history.size - 1)].join\n  end\nend\n\ntest = <<_TEST\n/*0*/ {\"b\", \"AB\" },\n/*1*/ {\"l\", \"AD\" },\n/*2*/ {\"r\", \"AC\" },\n/*3*/ {\"bbb\", \"ABAB\" },\n/*4*/ {\"rrr\", \"ACBA\" },\n/*5*/ {\"blll\", \"ABCAB\" },\n/*6*/ {\"llll\", \"ADEBA\" },\n/*7*/ {\"rbrl\", \"ACADE\" },\n/*8*/ {\"brrrr\", \"ABEDAB\" },\n/*9*/ {\"llrrr\", \"ADEFDE\" },\n/*10*/ {\"lrlll\", \"ADFEDF\" },\n/*11*/ {\"lrrrr\", \"ADFCAD\" },\n/*12*/ {\"rllll\", \"ACFDAC\" },\n/*13*/ {\"blrrrr\", \"ABCFEBC\" },\n/*14*/ {\"brllll\", \"ABEFCBE\" },\n/*15*/ {\"bbrllrrr\", \"ABACFDEFD\" },\n/*16*/ {\"rrrrblll\", \"ACBACABCA\" },\n/*17*/ {\"llrlrrbrb\", \"ADEFCADABA\" },\n/*18*/ {\"rrrbrllrr\", \"ACBABEFCAD\" },\n/*19*/ {\"llrllblrll\", \"ADEFCBCADEB\" },\n/*20*/ {\"lrrlllrbrl\", \"ADFCBEFDFCB\" },\n/*21*/ {\"lllrbrrlbrl\", \"ADEBCBACFCAB\" },\n/*22*/ {\"rrrrrrlrbrl\", \"ACBACBADFDEB\" },\n/*23*/ {\"lbrbbrbrbbrr\", \"ADABABEBCBCFE\" },\n/*24*/ {\"rrrrlbrblllr\", \"ACBACFCACFDAB\" },\n/*25*/ {\"lbbrblrlrlbll\", \"ADADFDABCFDFED\" },\n/*26*/ {\"rrbbrlrlrblrl\", \"ACBCBADFEBEFDA\" },\n/*27*/ {\"blrllblbrrrrll\", \"ABCFDADEDABEDFE\" },\n/*28*/ {\"blrllrlbllrrbr\", \"ABCFDABCBEFDEDA\" },\n/*29*/ {\"lbrbbrllllrblrr\", \"ADABABEFCBEDEBCF\" },\n/*30*/ {\"rrrrbllrlrbrbrr\", \"ACBACABCFDEDADFC\" },\n_TEST\n\nrequire 'minitest/autorun'\n\ndescribe 'Y Road' do\n  test.split(\"\\n\").each do |line|\n    t, n, input, expect = line.match(/^\\/\\*(\\d+)\\*\\/\\s{\"([^\"]+)\",\\s\"([^\"]+)\"\\s},$/).to_a\n    route = Route.new\n    input.split(//).each do |i|\n      route.choose i\n    end\n    it input do\n      assert_equal route.route, expect\n    end\n  end\nend\n```\n", "tags": ["Ruby", "\u3069\u3046\u66f8\u304f", "yhpg"]}