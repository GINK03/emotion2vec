{"tags": ["Python", "pandas"], "context": "\u30a4\u30f3\u30d7\u30e9\u30a4\u30c9\u30fb\u30dc\u30e9\u30c6\u30a3\u30ea\u30c6\u30a3\u3068\u304b\u30d6\u30e9\u30c3\u30af\u30b7\u30e7\u30fc\u30eb\u30ba\u65b9\u7a0b\u5f0f\u306b\u3064\u3044\u3066\u306f\u3001\nBlack\u2013Scholes model - Wikipedia\n\u4f7f\u3063\u3066\u3044\u308b\u30c7\u30fc\u30bf\u306e\u8aad\u307f\u8fbc\u307f\u306a\u3069\u306b\u3064\u3044\u3066\u306f\n\u65e5\u672c\u53d6\u5f15\u6240\u30b0\u30eb\u30fc\u30d7\u306e\u30aa\u30d7\u30b7\u30e7\u30f3\u7406\u8ad6\u4fa1\u683c\u7b49\u60c5\u5831\u306ePandas\u8aad\u307f\u8fbc\u307f\uff5e\u6574\u5f62\u307e\u3067 - Volo di notte\n\u3092\u53c2\u7167\u306e\u3053\u3068\n\n\u3057\u3066\u308b\u3053\u3068\n\n\u30aa\u30d7\u30b7\u30e7\u30f3\u4fa1\u683c\u304b\u3089\u30a4\u30f3\u30d7\u30e9\u30a4\u30c9\u30fb\u30dc\u30e9\u30c6\u30a3\u30ea\u30c6\u30a3\u306e\u8a08\u7b97\n\u8a08\u7b97\u901f\u5ea6\u306e\u6bd4\u8f03\uff08\u3088\u308a\u6b63\u78ba\u306b\u306f\u5b9f\u884c\u6642\u9593\u306e\u6bd4\u8f03)\n\n\u30dc\u30e9\u30c6\u30a3\u30ea\u30c6\u30a3 - Wikipedia\n\n\u03c3\u03c3\\sigma  \u306b\u95a2\u3059\u308b\u65b9\u7a0b\u5f0f\uff08C(K,T)C(K,T) C(K,T)\u306f \u03c3\u03c3 \\sigma \u306e\u95a2\u6570\u3067\u3042\u308b\u3053\u3068\u306b\u6ce8\u610f\uff09\n\u5e02\u5834\u4fa1\u683c =C(K,T)=C(K,T) =C(K,T) \n\u3092\u89e3\u3044\u3066\u5f97\u3089\u308c\u308b \u03c3\u03c3 \\sigma \u3092\u30a4\u30f3\u30d7\u30e9\u30a4\u30c9\u30fb\u30dc\u30e9\u30c6\u30a3\u30ea\u30c6\u30a3\u3068\u3044\u3046\u3002\n\n\u306e\u901a\u308a\u3001C(K,T)\u304c\u5e02\u5834\u4fa1\u683c\u3068\u306a\u308b\u03c3\u3092\u6c42\u3081\u308b\u8a08\u7b97\u3092\u3059\u308b\u308f\u3051\u3067\u3059\u304c\u3001C(K,T)\u304c\u5358\u7d14\u306b\u89e3\u3051\u306a\u3044\u306e\u3067\u3001\u6c42\u6839\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0\u306a\u3069\u3092\u4f7f\u3063\u3066\u3001\u30a4\u30f3\u30d7\u30e9\u30a4\u30c9\u30dc\u30e9\u30c6\u30a3\u30ea\u30c6\u30a3\u3092\u6c42\u3081\u308b\u308f\u3051\u3067\u3059\u3002\n\u305d\u306e\u3046\u3061\u306e\u65b9\u6cd5\u306e\u4e00\u3064\u306f\u3001Bisection method - Wikipedia\u3067\u3059\u306d\u3002\n\n\u8a08\u7b97\u6761\u4ef6\n\n2017/02/10\u306e2017\u5e743\u6708\u9650 \u65e5\u7d4c225\u30aa\u30d7\u30b7\u30e7\u30f3\u30c7\u30fc\u30bf\n\u6b8b\u5b58\u65e5\u6570 19.75\u65e5\n\u30ea\u30b9\u30af\u30d5\u30ea\u30fc\u30ec\u30fc\u30c8 = 0.0%\n\n\n\u5b9f\u65bd\u9805\u76ee\n\n\nScipy\u4f7f\u3063\u305f\u6700\u9069\u5316\u8a08\u7b97 (\u6570\u5024\u89e3) / pandas.apply - Single Process\n\nScipy\u4f7f\u3063\u305f\u6700\u9069\u5316\u8a08\u7b97 (\u6570\u5024\u89e3) / ndarray\u30b9\u30ab\u30e9\u30fc\u95a2\u6570\u6700\u9069\u5316 x \u30eb\u30fc\u30d7 : \u95a2\u6570\u306e\u30d9\u30af\u30c8\u30eb\u5316 - Single Process\n\nScipy\u4f7f\u3063\u305f\u6700\u9069\u5316\u8a08\u7b97 (\u6570\u5024\u89e3) / ndarray\u30d9\u30af\u30c8\u30eb\u95a2\u6570\u6700\u9069\u5316 : \u95a2\u6570\u306e\u30d9\u30af\u30c8\u30eb\u5316 - Single Process\n\nndarray\u6700\u9069\u5316Cython /ndarray\u30d9\u30af\u30c8\u30eb\u95a2\u6570\u6700\u9069\u5316- Single Process\n\nndarray\u6700\u9069\u5316Cython /ndarray\u30b9\u30ab\u30e9\u30fc\u95a2\u6570\u6700\u9069\u5316\u30d9\u30af\u30c8\u30eb- Single Process\n\nScipy\u4f7f\u3063\u305f\u6700\u9069\u5316\u8a08\u7b97 (\u6570\u5024\u89e3) / pandas.apply  + Multi Process \n\nANN\u3092\u4f7f\u3063\u305f\u9006\u95a2\u6570\u306e\u5b66\u7fd2\u21d2\u30a4\u30f3\u30d5\u30a1\u30ec\u30f3\u30b9\u30a8\u30f3\u30b8\u30f3\u3068\u3057\u3066\u5229\u7528(Keras)\n\nSwig\u5229\u7528(C++\u5b9f\u88c5)/\u30b7\u30f3\u30b0\u30eb\u30eb\u30fc\u30d7 - Single Process\n\n\n\u5b9f\u884c\u6642\u9593\u7d50\u679c\nPython\u3067\u8272\u3005\u306a\u5de5\u592b\u3092\u3059\u308b\u3088\u308aC++\u3067\u5b9f\u88c5\u3057\u305f\u3082\u306e\u304c\u5727\u5012\u7684\u306b\u901f\u304f\u3066\u3001Cython\u306e\u52aa\u529b\u306a\u3093\u3060\u3063\u305f\u306e\u2026\u3068\u601d\u3048\u3066\u304f\u308b\u3002\n\u3057\u304b\u3082C++\u306f\u672a\u3060\u30b9\u30ec\u30c3\u30c9\u4e26\u5217\u5316\u306a\u3069\u306e\u4f59\u529b\u3092\u6b8b\u3057\u3066\u306e\u3001\u3053\u306e\u30bf\u30a4\u30e0\u2026\u3063\uff01\nPython\u306e\u30de\u30eb\u30c1\u30d7\u30ed\u30bb\u30b9\u306fWindwos\u306e\u5834\u5408\u3060\u3068\u6bce\u56deKeras\u306e\u30e9\u30a4\u30d6\u30e9\u30ea\u3092\u8aad\u307f\u306b\u884c\u3063\u3066\u3057\u307e\u3046\u305f\u3081\u3001\u3053\u3053\u304c\u60aa\u3055\u3057\u3066\u3044\u308b\u306e\u3060\u3051\u3069\u3001\u3053\u308c\u3092\u306a\u304f\u3057\u305f\u500b\u5225\u5b9f\u884c\u30d0\u30fc\u30b8\u30e7\u30f3\u3067\u308235\u79d2\u307b\u3069\u304b\u304b\u3063\u3066\u305f\u3002\nANN\u3092\u4f7f\u3063\u305f\u9006\u95a2\u6570\u306f\u901f\u3044\u304c\u7cbe\u5ea6\u304c\u60aa\u3044\u3002NN\u306e\u8a2d\u8a08\u3067\u3082\u9650\u754c\u304c\u3042\u308b\u3068\u601d\u3046\u3002\n(\u305f\u3076\u3093WGAN/StackGAN\u307f\u305f\u3044\u306a\u3053\u3068\u3057\u306a\u3044\u3068\u7121\u7406)\n\n\n\n\u9805\u76ee\nData Handling\nOptimize\nBS_Vectorized\nProc\nTime[sec]\n\n\n\n\nScipy\u4f7f\u3063\u305f\u6700\u9069\u5316\u8a08\u7b97 (\u6570\u5024\u89e3) / pandas.apply - Single Process\nPd.apply\nminimize_scalar(Scipy)\nNo\nSingle\n2.8061\n\n\nScipy\u4f7f\u3063\u305f\u6700\u9069\u5316\u8a08\u7b97 (\u6570\u5024\u89e3) / ndarray\u30b9\u30ab\u30e9\u30fc\u95a2\u6570\u6700\u9069\u5316 x \u30eb\u30fc\u30d7 : \u95a2\u6570\u306e\u30d9\u30af\u30c8\u30eb\u5316 - Single Process\nPd->np\nminimize_scalar(Scipy)\nYes\nSingle\n3.2068\n\n\nScipy\u4f7f\u3063\u305f\u6700\u9069\u5316\u8a08\u7b97 (\u6570\u5024\u89e3) / ndarray\u30d9\u30af\u30c8\u30eb\u95a2\u6570\u6700\u9069\u5316 : \u95a2\u6570\u306e\u30d9\u30af\u30c8\u30eb\u5316 - Single Process\nPd->np\nroot(Scipy)\nYes\nSingle\n0.6706\n\n\nndarray\u6700\u9069\u5316Cython /ndarray\u30d9\u30af\u30c8\u30eb\u95a2\u6570\u6700\u9069\u5316- Single Process\nPd->np(CyPy)\nroot(Scipy)\nYes\nSingle\n0.6860\n\n\nndarray\u6700\u9069\u5316Cython /ndarray\u30b9\u30ab\u30e9\u30fc\u95a2\u6570\u6700\u9069\u5316\u30d9\u30af\u30c8\u30eb- Single Process\nPd->np(CyPy)\nVectBisection(Cython)\nYes\nSingle\n0.4848\n\n\nScipy\u4f7f\u3063\u305f\u6700\u9069\u5316\u8a08\u7b97 (\u6570\u5024\u89e3) / pandas.apply + Multi Process\nPd->Split(Pdx8)->np(CyPy)\nVectBisection(Cython)\nYes\nMultiProc\n128.3856\n\n\nANN\u3092\u4f7f\u3063\u305f\u9006\u95a2\u6570\u306e\u5b66\u7fd2\u21d2\u30a4\u30f3\u30d5\u30a1\u30ec\u30f3\u30b9\u30a8\u30f3\u30b8\u30f3\u3068\u3057\u3066\u5229\u7528(Keras)\nPd->np->ANN\nN/A\nYes\nSingle\n0.1526\n\n\nSwig\u5229\u7528(C++\u5b9f\u88c5)/\u30b7\u30f3\u30b0\u30eb\u30eb\u30fc\u30d7 - Single Process\nPd->np->C++(Swig)\nBisection(C++)\nNo\nSingle\n0.0010\n\n\n\n\n\u30bd\u30fc\u30b9\n# -*- coding: utf-8 -*-\nimport pandas as pd\nimport numpy as np\n\nfrom keras.models import load_model\n\n\nfrom datetime import datetime\nimport dateutil\n\nimport scipy.optimize\nfrom scipy.stats import norm\n\n# Cython\u7248\nfrom BS_Cy import *\n# Swig\u7248\nfrom _BS import *\n\nimport multiprocessing as mp\nimport time\nimport matplotlib.pyplot as plt\n\nmaturity = 19.75/245.\n\ndef strip(text):\n    try:\n        return text.strip()\n    except AttributeError:\n        return text\n\n\ndef BS_norm(F225, Strike, maturity, vol, call):\n    volSQM = vol * (maturity ** .5)\n    d1 = np.log(F225/Strike) / volSQM + volSQM/2\n    d2 = d1 - volSQM\n\n    return (F225   * norm.cdf(d1) - Strike*norm.cdf(d2)) if call else \\\n            (Strike * norm.cdf(-d2) - F225*norm.cdf(-d1))\n\ndef BS_norm_vect(F225, Strike, maturity, vol, call):\n    volSQM = vol * (maturity ** .5)\n    d1 = np.log(F225/Strike) / volSQM + volSQM/2\n    d2 = d1 - volSQM\n\n    Call = F225   * norm.cdf(d1) - Strike*norm.cdf(d2)\n    Put  = Strike * norm.cdf(-d2) - F225*norm.cdf(-d1)\n    premium = Call * call + Put * np.logical_not(call)\n    return premium\n\ndef myapply(x):\n    res = scipy.optimize.minimize_scalar(\n            lambda vol:\n            (\n                BS_norm(x['F225_PRICE'], x['STRIKE'], maturity, vol, x['CALL'])\n                                - x['OP_PRICE']\n            )**2, \n            method='Bounded', bounds =(0.01, 0.5),\n            options={'maxiter': 50, 'xatol': 1e-04})\n    x['vol1'] = res.x\n    return x\n\ndef myapply_vect(F225, Strike, price, call):\n    x = []\n    for i in range(len(F225)):\n        res = scipy.optimize.minimize_scalar(\n            lambda vol:\n            ( BS_norm_vect(F225[i], Strike[i], maturity, vol,call[i]) - price[i] )**2, \n            method='Bounded', bounds =(0.01, 0.5),\n            options={'maxiter': 50, 'xatol': 1e-04})\n        x.append(res.x)\n    return x\n\ndef myapply_vect2(F225, Strike, price, call):\n    res = scipy.optimize.root(\n        lambda vol:( BS_norm_vect(F225, Strike, maturity, vol,call) - price), \n        np.ones_like(F225)*.3)\n    return res.x\n\ndef pworker(df):\n    df['vol6'] = cy_apply2(df['F225_PRICE'].values, df['STRIKE'].values, \n                              df['OP_PRICE'].values,   df['CALL'].values)\n    return df\n\nif __name__ == '__main__':\n    # # \u30c7\u30fc\u30bf\u6e96\u5099\n    # [\u30aa\u30d7\u30b7\u30e7\u30f3\u7406\u8ad6\u4fa1\u683c\u7b49\u60c5\u5831 \\| \u65e5\u672c\u53d6\u5f15\u6240\u30b0\u30eb\u30fc\u30d7](http://www.jpx.co.jp/markets/derivatives/option-price/01.html)\u304b\u3089\u5165\u624b\u3057\u305f2017\u5e742\u670810\u65e5\u306e\u7d42\u5024\u30c7\u30fc\u30bf\u3002\n    # \u8272\u3005\u5165\u3063\u3066\u3044\u308b\u3051\u30692017\u5e743\u6708\u9650\u306e\u539f\u8cc7\u7523\uff1a\u65e5\u7d4c225\u306e\u30aa\u30d7\u30b7\u30e7\u30f3\u53d6\u5f15\u30c7\u30fc\u30bf\u3060\u3051\u4f7f\u3046\u3002\n    # \n    # ## Pandas\u3078\u30c7\u30fc\u30bf\u8aad\u307f\u8fbc\u307f\n    # 1. \u30c7\u30fc\u30bf\u672c\u4f53\u3068\u5225\u306b\u914d\u5e03\u3055\u308c\u3066\u3044\u308b\u30d8\u30c3\u30c0\u30fc\u60c5\u5831\u3092\u3082\u3068\u306b\u81ea\u5206\u3067\u30d8\u30c3\u30c0\u30fc\u3092\u8d77\u3053\u3057\u3066\u540d\u524d\u3092\u3064\u3051\u308b\n    # 2. \u8aad\u307f\u8fbc\u307f\u4e2d\u306b\u30c6\u30ad\u30b9\u30c8\u30c7\u30fc\u30bf\u306e\u7a7a\u767d\u3092\u30c8\u30ea\u30e0\u3059\u308b\n\n    # \u30d8\u30c3\u30c0\u30fc\u540d (\u5909\u6570\u540d\u9806)\n    #     \u5546\u54c1\u30b3\u30fc\u30c9, \u5546\u54c1\u30bf\u30a4\u30d7, \u9650\u6708, \u6a29\u5229\u884c\u4f7f\u4fa1\u683c, \u4e88\u5099\n    #     \u30d7\u30c3\u30c8\u30aa\u30d7\u30b7\u30e7\u30f3: \u9298\u67c4\u30b3\u30fc\u30c9, \u7d42\u5024, \u4e88\u5099, \u7406\u8ad6\u4fa1\u683c, \u30dc\u30e9\u30c6\u30a3\u30ea\u30c6\u30a3\n    #     \u30b3\u30fc\u30eb\u30aa\u30d7\u30b7\u30e7\u30f3: \u9298\u67c4\u30b3\u30fc\u30c9, \u7d42\u5024, \u4e88\u5099, \u7406\u8ad6\u4fa1\u683c, \u30dc\u30e9\u30c6\u30a3\u30ea\u30c6\u30a3\n    #     \u539f\u8cc7\u7523\u7d42\u5024, \u57fa\u6e96\u30dc\u30e9\u30c6\u30a3\u30ea\u30c6\u30a3\n    colName = (\"CODE\",\"TYPE\",\"MATURITY\",\"STRIKE\", \"RSV\", \n               \"PUT_CODE\", \"PUT_PRICE\", \"PUT_RSV\", \"PUT_TPRICE\", \"PUT_VOLATILITY\",\n               \"CALL_CODE\",\"CALL_PRICE\",\"CALL_RSV\",\"CALL_TPRICE\",\"CALL_VOLATILITY\",\n               \"F225_PRICE\", \"Base_VOL\")\n\n    df = pd.read_csv('./ose20170210tp.csv',names=colName,\n                     converters = {'CODE' : strip,\n                                   'TYPE' : strip})\n    # 2017\u5e743\u6708\u9650\u306e\u65e5\u7d4c225\u30aa\u30d7\u30b7\u30e7\u30f3\u3060\u3051\u629c\u304d\u51fa\u3057\u3002\u3064\u3044\u3067\u306b\u8981\u3089\u306a\u3044\u5217\u3092\u524a\u9664\u3057\u3066\u30b9\u30c3\u30ad\u30ea\u3002\n    df = df.query(\"MATURITY == 201703 & CODE==\\\"NK225E\\\"\")    .drop(['RSV','PUT_RSV','CALL_RSV','PUT_CODE','CALL_CODE','CODE','TYPE','MATURITY'], 1)\n\n    # * PUT\u3068CALL\u304c\u5206\u304b\u308c\u3066\u3057\u307e\u3063\u3066\u3044\u308b\u306e\u3067\u3001\u30c7\u30fc\u30bf\u3092\u6b63\u898f\u5316\u3002\n    # * CALL\u5217\u304cTRUE\u306e\u3068\u304dCALL\u306e\u30c7\u30fc\u30bf\u3001FALSE\u306e\u3068\u304d\u3001PUT\u306e\u30c7\u30fc\u30bf\u3068\u3059\u308b\u3002\n    # * \u884c\u4f7f\u4fa1\u683c\u308214000\u5186\u4ee5\u4e0a\u300122000\u5186\u672a\u6e80\u306b\u7d5e\u308b\n    df_p = df[[\"STRIKE\",\"PUT_PRICE\",\"PUT_TPRICE\", \"PUT_VOLATILITY\",\"F225_PRICE\", \"Base_VOL\"]]    .rename(columns={'PUT_PRICE': 'OP_PRICE', 'PUT_TPRICE':'OP_TPRICE', 'PUT_VOLATILITY':'OP_VOL'})\n    df_p['CALL'] = False\n    df_c = df[[\"STRIKE\",\"CALL_PRICE\",\"CALL_TPRICE\", \"CALL_VOLATILITY\",\"F225_PRICE\", \"Base_VOL\"]]    .rename(columns={'CALL_PRICE': 'OP_PRICE', 'CALL_TPRICE':'OP_TPRICE', 'CALL_VOLATILITY':'OP_VOL'})\n    df_c['CALL'] = True\n    df = df_p.append(df_c).query(\"OP_PRICE > 1.0 & STRIKE < 22000 & STRIKE >= 14000\")\n    del (df_p,df_c)\n\n    tmp_df = df\n    loop_num = 10\n    text = 'Time elapsed: %.2f seconds'\n\n    result_time = []\n    result_Col  = np.array([[\"Data Handling\",\"Optimize\",\"BS_Vectorized\",\"Proc\",\"Time[sec]\"]])\n    result_con  = np.array([[\"Pd.apply\",\n                   \"Pd->np\",\n                   \"Pd->np\",\n                   \"Pd->np(CyPy)\",\n                   \"Pd->np(CyPy)\",\n                   \"Pd->Split(Pd x 8)->np(CyPy)\",\n                   \"Pd->np->ANN\",\n                   \"Pd->np->C++(Swig)\"\n                   ]])\n    result_opt  = np.array([[\"minimize_scalar(Scipy)\",\n                   \"minimize_scalar(Scipy)\",\n                   \"root(Scipy)\",\n                   \"root(Scipy)\",\n                   \"Vect Bisection(Cython)\",\n                   \"Vect Bisection(Cython)\",\n                   \"N/A\",\n                   \"Bisection(C++)\"\n                    ]])\n    result_Vect = np.array([[\"No\",\n                   \"Yes\",\n                   \"Yes\",\n                   \"Yes\",\n                   \"Yes\",\n                   \"Yes\",\n                   \"Yes\",\n                   \"No\"\n                    ]])\n    result_Proc = np.array([[\"Single\",\n                   \"Single\",\n                   \"Single\",\n                   \"Single\",\n                   \"Single\",\n                   \"Multi Proc\",\n                   \"Single\",\n                   \"Single\"\n                    ]])\n\n    # 1. Scipy\u4f7f\u3063\u305f\u6700\u9069\u5316\u8a08\u7b97 (\u6570\u5024\u89e3) / pandas.apply - Single Process\n    time_start = time.time()\n    for i in range(loop_num):\n        tmp_df = df.apply(myapply, axis=1)\n    result_time.append((time.time() - time_start))\n\n\n    # 2. Scipy\u4f7f\u3063\u305f\u6700\u9069\u5316\u8a08\u7b97 (\u6570\u5024\u89e3) / ndarray\u30eb\u30fc\u30d7 : \u95a2\u6570\u306e\u30d9\u30af\u30c8\u30eb\u5316 - Single Process\n    time_start = time.time()\n    for i in range(loop_num):\n        tmp_df['vol2'] = myapply_vect(df['F225_PRICE'].values, df['STRIKE'].values, \n                              df['OP_PRICE'].values,   df['CALL'].values)\n    result_time.append((time.time() - time_start))\n\n    # 3. Scipy\u4f7f\u3063\u305f\u6700\u9069\u5316\u8a08\u7b97 (\u6570\u5024\u89e3) / ndarray\u30d9\u30af\u30c8\u30eb : \u95a2\u6570\u306e\u30d9\u30af\u30c8\u30eb\u5316 - Single Process\n    time_start = time.time()\n    for i in range(loop_num):\n        tmp_df['vol3'] = myapply_vect2(df['F225_PRICE'].values, df['STRIKE'].values, \n                              df['OP_PRICE'].values,   df['CALL'].values)\n    result_time.append((time.time() - time_start))\n\n    # 4. Cython - Root\n    time_start = time.time()\n    for i in range(loop_num):\n        tmp_df['vol4'] = cy_apply1(df['F225_PRICE'].values, df['STRIKE'].values, \n                              df['OP_PRICE'].values,   df['CALL'].values)\n    result_time.append((time.time() - time_start))\n\n    # 5. Cython - My Bisection\n    time_start = time.time()\n    for i in range(loop_num):\n        tmp_df['vol5'] = cy_apply2(df['F225_PRICE'].values, df['STRIKE'].values, \n                              df['OP_PRICE'].values,   df['CALL'].values)\n    result_time.append((time.time() - time_start))\n\n    # 6. Multi Process\n    time_start = time.time()\n    for i in range(loop_num):\n        p = mp.Pool(processes=8)\n        split_dfs = np.array_split(df,8)\n        pool_results = p.map(pworker, split_dfs)\n        p.close()\n        p.join()\n\n        tmp_df = pd.concat(pool_results, axis=0)\n    result_time.append((time.time() - time_start))\n\n    # 7. ANN\n    model = load_model('./model.h5')\n\n    a = np.array([df['STRIKE'].values/df['F225_PRICE'].values])\n    b = np.array([np.ones_like(df['F225_PRICE'].values)*maturity/(40./245.)])\n    c = np.array([(df['OP_PRICE'].values/df['F225_PRICE'].values/0.25)**0.25])\n\n    X = np.vstack((a,b,c)).transpose()\n\n    time_start = time.time()\n    for i in range(loop_num):\n        tmp_df['vol7'] = 0.4*model.predict(X)+0.1\n    result_time.append((time.time() - time_start))    \n\n    # 8. Swig C++\n    tmpmpmp=np.ones_like(df['F225_PRICE'].values).astype(np.float32)\n    time_start = time.time()\n    for i in range(loop_num):\n        tmpmpmp = Swig_Apply_PY(df['F225_PRICE'].values, df['STRIKE'].values, \n                              df['OP_PRICE'].values,  df['CALL'].values.astype(dtype=np.int32),tmpmpmp.shape[0])\n        tmp_df['vol8'] =  tmpmpmp\n    result_time.append((time.time() - time_start))\n\n    result_time = np.array([result_time])\n    print(np.vstack((result_con, result_opt, result_Vect, result_Proc,result_time)).transpose())\n\n\u30a4\u30f3\u30d7\u30e9\u30a4\u30c9\u30fb\u30dc\u30e9\u30c6\u30a3\u30ea\u30c6\u30a3\u3068\u304b\u30d6\u30e9\u30c3\u30af\u30b7\u30e7\u30fc\u30eb\u30ba\u65b9\u7a0b\u5f0f\u306b\u3064\u3044\u3066\u306f\u3001\n [Black\u2013Scholes model \\- Wikipedia](https://en.wikipedia.org/wiki/Black%E2%80%93Scholes_model)\n\n\u4f7f\u3063\u3066\u3044\u308b\u30c7\u30fc\u30bf\u306e\u8aad\u307f\u8fbc\u307f\u306a\u3069\u306b\u3064\u3044\u3066\u306f\n[\u65e5\u672c\u53d6\u5f15\u6240\u30b0\u30eb\u30fc\u30d7\u306e\u30aa\u30d7\u30b7\u30e7\u30f3\u7406\u8ad6\u4fa1\u683c\u7b49\u60c5\u5831\u306ePandas\u8aad\u307f\u8fbc\u307f\uff5e\u6574\u5f62\u307e\u3067 \\- Volo di notte](http://chachay.hatenablog.com/entry/2017/02/12/223800)\n\n\n\u3092\u53c2\u7167\u306e\u3053\u3068\n\n\n# \u3057\u3066\u308b\u3053\u3068\n- \u30aa\u30d7\u30b7\u30e7\u30f3\u4fa1\u683c\u304b\u3089\u30a4\u30f3\u30d7\u30e9\u30a4\u30c9\u30fb\u30dc\u30e9\u30c6\u30a3\u30ea\u30c6\u30a3\u306e\u8a08\u7b97\n- \u8a08\u7b97\u901f\u5ea6\u306e\u6bd4\u8f03\uff08\u3088\u308a\u6b63\u78ba\u306b\u306f\u5b9f\u884c\u6642\u9593\u306e\u6bd4\u8f03)\n\n[\u30dc\u30e9\u30c6\u30a3\u30ea\u30c6\u30a3 \\- Wikipedia](https://ja.wikipedia.org/wiki/%E3%83%9C%E3%83%A9%E3%83%86%E3%82%A3%E3%83%AA%E3%83%86%E3%82%A3#.E3.82.A4.E3.83.B3.E3.83.97.E3.83.A9.E3.82.A4.E3.83.89.E3.83.BB.E3.83.9C.E3.83.A9.E3.83.86.E3.82.A3.E3.83.AA.E3.83.86.E3.82.A3)\n\n>  $\\sigma $ \u306b\u95a2\u3059\u308b\u65b9\u7a0b\u5f0f\uff08$ C(K,T)$\u306f $ \\sigma $\u306e\u95a2\u6570\u3067\u3042\u308b\u3053\u3068\u306b\u6ce8\u610f\uff09\n> \u5e02\u5834\u4fa1\u683c $ =C(K,T) $\n> \u3092\u89e3\u3044\u3066\u5f97\u3089\u308c\u308b $ \\sigma $\u3092\u30a4\u30f3\u30d7\u30e9\u30a4\u30c9\u30fb\u30dc\u30e9\u30c6\u30a3\u30ea\u30c6\u30a3\u3068\u3044\u3046\u3002\n\n\u306e\u901a\u308a\u3001C(K,T)\u304c\u5e02\u5834\u4fa1\u683c\u3068\u306a\u308b\u03c3\u3092\u6c42\u3081\u308b\u8a08\u7b97\u3092\u3059\u308b\u308f\u3051\u3067\u3059\u304c\u3001C(K,T)\u304c\u5358\u7d14\u306b\u89e3\u3051\u306a\u3044\u306e\u3067\u3001[\u6c42\u6839\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0](https://ja.wikipedia.org/wiki/%E6%B1%82%E6%A0%B9%E3%82%A2%E3%83%AB%E3%82%B4%E3%83%AA%E3%82%BA%E3%83%A0)\u306a\u3069\u3092\u4f7f\u3063\u3066\u3001\u30a4\u30f3\u30d7\u30e9\u30a4\u30c9\u30dc\u30e9\u30c6\u30a3\u30ea\u30c6\u30a3\u3092\u6c42\u3081\u308b\u308f\u3051\u3067\u3059\u3002\n\n\u305d\u306e\u3046\u3061\u306e\u65b9\u6cd5\u306e\u4e00\u3064\u306f\u3001[Bisection method \\- Wikipedia](https://en.wikipedia.org/wiki/Bisection_method)\u3067\u3059\u306d\u3002\n\n# \u8a08\u7b97\u6761\u4ef6\n\n* 2017/02/10\u306e2017\u5e743\u6708\u9650 \u65e5\u7d4c225\u30aa\u30d7\u30b7\u30e7\u30f3\u30c7\u30fc\u30bf\n* \u6b8b\u5b58\u65e5\u6570 19.75\u65e5\n* \u30ea\u30b9\u30af\u30d5\u30ea\u30fc\u30ec\u30fc\u30c8 = 0.0%\n\n## \u5b9f\u65bd\u9805\u76ee\n- [x] Scipy\u4f7f\u3063\u305f\u6700\u9069\u5316\u8a08\u7b97 (\u6570\u5024\u89e3) / pandas.apply - Single Process\n- [x] Scipy\u4f7f\u3063\u305f\u6700\u9069\u5316\u8a08\u7b97 (\u6570\u5024\u89e3) / ndarray\u30b9\u30ab\u30e9\u30fc\u95a2\u6570\u6700\u9069\u5316 x \u30eb\u30fc\u30d7 : \u95a2\u6570\u306e\u30d9\u30af\u30c8\u30eb\u5316 - Single Process\n- [x] Scipy\u4f7f\u3063\u305f\u6700\u9069\u5316\u8a08\u7b97 (\u6570\u5024\u89e3) / ndarray\u30d9\u30af\u30c8\u30eb\u95a2\u6570\u6700\u9069\u5316 : \u95a2\u6570\u306e\u30d9\u30af\u30c8\u30eb\u5316 - Single Process\n- [x] ndarray\u6700\u9069\u5316Cython /ndarray\u30d9\u30af\u30c8\u30eb\u95a2\u6570\u6700\u9069\u5316- Single Process\n- [x] ndarray\u6700\u9069\u5316Cython /ndarray\u30b9\u30ab\u30e9\u30fc\u95a2\u6570\u6700\u9069\u5316\u30d9\u30af\u30c8\u30eb- Single Process\n- [x] Scipy\u4f7f\u3063\u305f\u6700\u9069\u5316\u8a08\u7b97 (\u6570\u5024\u89e3) / pandas.apply  + Multi Process \n- [x] ANN\u3092\u4f7f\u3063\u305f\u9006\u95a2\u6570\u306e\u5b66\u7fd2\u21d2\u30a4\u30f3\u30d5\u30a1\u30ec\u30f3\u30b9\u30a8\u30f3\u30b8\u30f3\u3068\u3057\u3066\u5229\u7528(Keras)\n- [x] Swig\u5229\u7528(C++\u5b9f\u88c5)/\u30b7\u30f3\u30b0\u30eb\u30eb\u30fc\u30d7 - Single Process\n\n## \u5b9f\u884c\u6642\u9593\u7d50\u679c\n\nPython\u3067\u8272\u3005\u306a\u5de5\u592b\u3092\u3059\u308b\u3088\u308aC++\u3067\u5b9f\u88c5\u3057\u305f\u3082\u306e\u304c\u5727\u5012\u7684\u306b\u901f\u304f\u3066\u3001Cython\u306e\u52aa\u529b\u306a\u3093\u3060\u3063\u305f\u306e\u2026\u3068\u601d\u3048\u3066\u304f\u308b\u3002\n\u3057\u304b\u3082C++\u306f\u672a\u3060\u30b9\u30ec\u30c3\u30c9\u4e26\u5217\u5316\u306a\u3069\u306e\u4f59\u529b\u3092\u6b8b\u3057\u3066\u306e\u3001\u3053\u306e\u30bf\u30a4\u30e0\u2026\u3063\uff01\n\nPython\u306e\u30de\u30eb\u30c1\u30d7\u30ed\u30bb\u30b9\u306fWindwos\u306e\u5834\u5408\u3060\u3068\u6bce\u56deKeras\u306e\u30e9\u30a4\u30d6\u30e9\u30ea\u3092\u8aad\u307f\u306b\u884c\u3063\u3066\u3057\u307e\u3046\u305f\u3081\u3001\u3053\u3053\u304c\u60aa\u3055\u3057\u3066\u3044\u308b\u306e\u3060\u3051\u3069\u3001\u3053\u308c\u3092\u306a\u304f\u3057\u305f\u500b\u5225\u5b9f\u884c\u30d0\u30fc\u30b8\u30e7\u30f3\u3067\u308235\u79d2\u307b\u3069\u304b\u304b\u3063\u3066\u305f\u3002\n\nANN\u3092\u4f7f\u3063\u305f\u9006\u95a2\u6570\u306f\u901f\u3044\u304c\u7cbe\u5ea6\u304c\u60aa\u3044\u3002NN\u306e\u8a2d\u8a08\u3067\u3082\u9650\u754c\u304c\u3042\u308b\u3068\u601d\u3046\u3002\n(\u305f\u3076\u3093WGAN/StackGAN\u307f\u305f\u3044\u306a\u3053\u3068\u3057\u306a\u3044\u3068\u7121\u7406)\n\n| \u9805\u76ee                                                                                                    | Data Handling             | Optimize               | BS_Vectorized | Proc      | Time[sec] |\n|---------------------------------------------------------------------------------------------------------|---------------------------|------------------------|---------------|-----------|-----------|\n| Scipy\u4f7f\u3063\u305f\u6700\u9069\u5316\u8a08\u7b97 (\u6570\u5024\u89e3) / pandas.apply - Single Process                                          | Pd.apply                  | minimize_scalar(Scipy) | No            | Single    | 2.8061    |\n| Scipy\u4f7f\u3063\u305f\u6700\u9069\u5316\u8a08\u7b97 (\u6570\u5024\u89e3) / ndarray\u30b9\u30ab\u30e9\u30fc\u95a2\u6570\u6700\u9069\u5316 x \u30eb\u30fc\u30d7 : \u95a2\u6570\u306e\u30d9\u30af\u30c8\u30eb\u5316 - Single Process | Pd->np                    | minimize_scalar(Scipy) | Yes           | Single    | 3.2068    |\n| Scipy\u4f7f\u3063\u305f\u6700\u9069\u5316\u8a08\u7b97 (\u6570\u5024\u89e3) / ndarray\u30d9\u30af\u30c8\u30eb\u95a2\u6570\u6700\u9069\u5316 : \u95a2\u6570\u306e\u30d9\u30af\u30c8\u30eb\u5316 - Single Process          | Pd->np                    | root(Scipy)            | Yes           | Single    | 0.6706    |\n| ndarray\u6700\u9069\u5316Cython /ndarray\u30d9\u30af\u30c8\u30eb\u95a2\u6570\u6700\u9069\u5316- Single Process                                          | Pd->np(CyPy)              | root(Scipy)            | Yes           | Single    | 0.6860    |\n| ndarray\u6700\u9069\u5316Cython /ndarray\u30b9\u30ab\u30e9\u30fc\u95a2\u6570\u6700\u9069\u5316\u30d9\u30af\u30c8\u30eb- Single Process                                  | Pd->np(CyPy)              | VectBisection(Cython)  | Yes           | Single    | 0.4848    |\n| Scipy\u4f7f\u3063\u305f\u6700\u9069\u5316\u8a08\u7b97 (\u6570\u5024\u89e3) / pandas.apply + Multi Process                                           | Pd->Split(Pdx8)->np(CyPy) | VectBisection(Cython)  | Yes           | MultiProc | 128.3856  |\n| ANN\u3092\u4f7f\u3063\u305f\u9006\u95a2\u6570\u306e\u5b66\u7fd2\u21d2\u30a4\u30f3\u30d5\u30a1\u30ec\u30f3\u30b9\u30a8\u30f3\u30b8\u30f3\u3068\u3057\u3066\u5229\u7528(Keras)                                         | Pd->np->ANN               | N/A                    | Yes           | Single    | 0.1526    |\n| Swig\u5229\u7528(C++\u5b9f\u88c5)/\u30b7\u30f3\u30b0\u30eb\u30eb\u30fc\u30d7 - Single Process                                                       | Pd->np->C++(Swig)         | Bisection(C++)         | No            | Single    | 0.0010    |\n\n## \u30bd\u30fc\u30b9\n\n```python\n# -*- coding: utf-8 -*-\nimport pandas as pd\nimport numpy as np\n\nfrom keras.models import load_model\n\n\nfrom datetime import datetime\nimport dateutil\n\nimport scipy.optimize\nfrom scipy.stats import norm\n\n# Cython\u7248\nfrom BS_Cy import *\n# Swig\u7248\nfrom _BS import *\n\nimport multiprocessing as mp\nimport time\nimport matplotlib.pyplot as plt\n\nmaturity = 19.75/245.\n\ndef strip(text):\n    try:\n        return text.strip()\n    except AttributeError:\n        return text\n\n\ndef BS_norm(F225, Strike, maturity, vol, call):\n    volSQM = vol * (maturity ** .5)\n    d1 = np.log(F225/Strike) / volSQM + volSQM/2\n    d2 = d1 - volSQM\n\n    return (F225   * norm.cdf(d1) - Strike*norm.cdf(d2)) if call else \\\n            (Strike * norm.cdf(-d2) - F225*norm.cdf(-d1))\n\ndef BS_norm_vect(F225, Strike, maturity, vol, call):\n    volSQM = vol * (maturity ** .5)\n    d1 = np.log(F225/Strike) / volSQM + volSQM/2\n    d2 = d1 - volSQM\n\n    Call = F225   * norm.cdf(d1) - Strike*norm.cdf(d2)\n    Put  = Strike * norm.cdf(-d2) - F225*norm.cdf(-d1)\n    premium = Call * call + Put * np.logical_not(call)\n    return premium\n    \ndef myapply(x):\n    res = scipy.optimize.minimize_scalar(\n            lambda vol:\n            (\n                BS_norm(x['F225_PRICE'], x['STRIKE'], maturity, vol, x['CALL'])\n                                - x['OP_PRICE']\n            )**2, \n            method='Bounded', bounds =(0.01, 0.5),\n            options={'maxiter': 50, 'xatol': 1e-04})\n    x['vol1'] = res.x\n    return x\n   \ndef myapply_vect(F225, Strike, price, call):\n    x = []\n    for i in range(len(F225)):\n        res = scipy.optimize.minimize_scalar(\n            lambda vol:\n            ( BS_norm_vect(F225[i], Strike[i], maturity, vol,call[i]) - price[i] )**2, \n            method='Bounded', bounds =(0.01, 0.5),\n            options={'maxiter': 50, 'xatol': 1e-04})\n        x.append(res.x)\n    return x\n\ndef myapply_vect2(F225, Strike, price, call):\n    res = scipy.optimize.root(\n        lambda vol:( BS_norm_vect(F225, Strike, maturity, vol,call) - price), \n        np.ones_like(F225)*.3)\n    return res.x\n\ndef pworker(df):\n    df['vol6'] = cy_apply2(df['F225_PRICE'].values, df['STRIKE'].values, \n                              df['OP_PRICE'].values,   df['CALL'].values)\n    return df\n\nif __name__ == '__main__':\n    # # \u30c7\u30fc\u30bf\u6e96\u5099\n    # [\u30aa\u30d7\u30b7\u30e7\u30f3\u7406\u8ad6\u4fa1\u683c\u7b49\u60c5\u5831 \\| \u65e5\u672c\u53d6\u5f15\u6240\u30b0\u30eb\u30fc\u30d7](http://www.jpx.co.jp/markets/derivatives/option-price/01.html)\u304b\u3089\u5165\u624b\u3057\u305f2017\u5e742\u670810\u65e5\u306e\u7d42\u5024\u30c7\u30fc\u30bf\u3002\n    # \u8272\u3005\u5165\u3063\u3066\u3044\u308b\u3051\u30692017\u5e743\u6708\u9650\u306e\u539f\u8cc7\u7523\uff1a\u65e5\u7d4c225\u306e\u30aa\u30d7\u30b7\u30e7\u30f3\u53d6\u5f15\u30c7\u30fc\u30bf\u3060\u3051\u4f7f\u3046\u3002\n    # \n    # ## Pandas\u3078\u30c7\u30fc\u30bf\u8aad\u307f\u8fbc\u307f\n    # 1. \u30c7\u30fc\u30bf\u672c\u4f53\u3068\u5225\u306b\u914d\u5e03\u3055\u308c\u3066\u3044\u308b\u30d8\u30c3\u30c0\u30fc\u60c5\u5831\u3092\u3082\u3068\u306b\u81ea\u5206\u3067\u30d8\u30c3\u30c0\u30fc\u3092\u8d77\u3053\u3057\u3066\u540d\u524d\u3092\u3064\u3051\u308b\n    # 2. \u8aad\u307f\u8fbc\u307f\u4e2d\u306b\u30c6\u30ad\u30b9\u30c8\u30c7\u30fc\u30bf\u306e\u7a7a\u767d\u3092\u30c8\u30ea\u30e0\u3059\u308b\n\n    # \u30d8\u30c3\u30c0\u30fc\u540d (\u5909\u6570\u540d\u9806)\n    #     \u5546\u54c1\u30b3\u30fc\u30c9, \u5546\u54c1\u30bf\u30a4\u30d7, \u9650\u6708, \u6a29\u5229\u884c\u4f7f\u4fa1\u683c, \u4e88\u5099\n    #     \u30d7\u30c3\u30c8\u30aa\u30d7\u30b7\u30e7\u30f3: \u9298\u67c4\u30b3\u30fc\u30c9, \u7d42\u5024, \u4e88\u5099, \u7406\u8ad6\u4fa1\u683c, \u30dc\u30e9\u30c6\u30a3\u30ea\u30c6\u30a3\n    #     \u30b3\u30fc\u30eb\u30aa\u30d7\u30b7\u30e7\u30f3: \u9298\u67c4\u30b3\u30fc\u30c9, \u7d42\u5024, \u4e88\u5099, \u7406\u8ad6\u4fa1\u683c, \u30dc\u30e9\u30c6\u30a3\u30ea\u30c6\u30a3\n    #     \u539f\u8cc7\u7523\u7d42\u5024, \u57fa\u6e96\u30dc\u30e9\u30c6\u30a3\u30ea\u30c6\u30a3\n    colName = (\"CODE\",\"TYPE\",\"MATURITY\",\"STRIKE\", \"RSV\", \n               \"PUT_CODE\", \"PUT_PRICE\", \"PUT_RSV\", \"PUT_TPRICE\", \"PUT_VOLATILITY\",\n               \"CALL_CODE\",\"CALL_PRICE\",\"CALL_RSV\",\"CALL_TPRICE\",\"CALL_VOLATILITY\",\n               \"F225_PRICE\", \"Base_VOL\")\n\n    df = pd.read_csv('./ose20170210tp.csv',names=colName,\n                     converters = {'CODE' : strip,\n                                   'TYPE' : strip})\n    # 2017\u5e743\u6708\u9650\u306e\u65e5\u7d4c225\u30aa\u30d7\u30b7\u30e7\u30f3\u3060\u3051\u629c\u304d\u51fa\u3057\u3002\u3064\u3044\u3067\u306b\u8981\u3089\u306a\u3044\u5217\u3092\u524a\u9664\u3057\u3066\u30b9\u30c3\u30ad\u30ea\u3002\n    df = df.query(\"MATURITY == 201703 & CODE==\\\"NK225E\\\"\")    .drop(['RSV','PUT_RSV','CALL_RSV','PUT_CODE','CALL_CODE','CODE','TYPE','MATURITY'], 1)\n\n    # * PUT\u3068CALL\u304c\u5206\u304b\u308c\u3066\u3057\u307e\u3063\u3066\u3044\u308b\u306e\u3067\u3001\u30c7\u30fc\u30bf\u3092\u6b63\u898f\u5316\u3002\n    # * CALL\u5217\u304cTRUE\u306e\u3068\u304dCALL\u306e\u30c7\u30fc\u30bf\u3001FALSE\u306e\u3068\u304d\u3001PUT\u306e\u30c7\u30fc\u30bf\u3068\u3059\u308b\u3002\n    # * \u884c\u4f7f\u4fa1\u683c\u308214000\u5186\u4ee5\u4e0a\u300122000\u5186\u672a\u6e80\u306b\u7d5e\u308b\n    df_p = df[[\"STRIKE\",\"PUT_PRICE\",\"PUT_TPRICE\", \"PUT_VOLATILITY\",\"F225_PRICE\", \"Base_VOL\"]]    .rename(columns={'PUT_PRICE': 'OP_PRICE', 'PUT_TPRICE':'OP_TPRICE', 'PUT_VOLATILITY':'OP_VOL'})\n    df_p['CALL'] = False\n    df_c = df[[\"STRIKE\",\"CALL_PRICE\",\"CALL_TPRICE\", \"CALL_VOLATILITY\",\"F225_PRICE\", \"Base_VOL\"]]    .rename(columns={'CALL_PRICE': 'OP_PRICE', 'CALL_TPRICE':'OP_TPRICE', 'CALL_VOLATILITY':'OP_VOL'})\n    df_c['CALL'] = True\n    df = df_p.append(df_c).query(\"OP_PRICE > 1.0 & STRIKE < 22000 & STRIKE >= 14000\")\n    del (df_p,df_c)\n\n    tmp_df = df\n    loop_num = 10\n    text = 'Time elapsed: %.2f seconds'\n\n    result_time = []\n    result_Col  = np.array([[\"Data Handling\",\"Optimize\",\"BS_Vectorized\",\"Proc\",\"Time[sec]\"]])\n    result_con  = np.array([[\"Pd.apply\",\n                   \"Pd->np\",\n                   \"Pd->np\",\n                   \"Pd->np(CyPy)\",\n                   \"Pd->np(CyPy)\",\n                   \"Pd->Split(Pd x 8)->np(CyPy)\",\n                   \"Pd->np->ANN\",\n                   \"Pd->np->C++(Swig)\"\n                   ]])\n    result_opt  = np.array([[\"minimize_scalar(Scipy)\",\n                   \"minimize_scalar(Scipy)\",\n                   \"root(Scipy)\",\n                   \"root(Scipy)\",\n                   \"Vect Bisection(Cython)\",\n                   \"Vect Bisection(Cython)\",\n                   \"N/A\",\n                   \"Bisection(C++)\"\n                    ]])\n    result_Vect = np.array([[\"No\",\n                   \"Yes\",\n                   \"Yes\",\n                   \"Yes\",\n                   \"Yes\",\n                   \"Yes\",\n                   \"Yes\",\n                   \"No\"\n                    ]])\n    result_Proc = np.array([[\"Single\",\n                   \"Single\",\n                   \"Single\",\n                   \"Single\",\n                   \"Single\",\n                   \"Multi Proc\",\n                   \"Single\",\n                   \"Single\"\n                    ]])\n    \n    # 1. Scipy\u4f7f\u3063\u305f\u6700\u9069\u5316\u8a08\u7b97 (\u6570\u5024\u89e3) / pandas.apply - Single Process\n    time_start = time.time()\n    for i in range(loop_num):\n        tmp_df = df.apply(myapply, axis=1)\n    result_time.append((time.time() - time_start))\n\n\n    # 2. Scipy\u4f7f\u3063\u305f\u6700\u9069\u5316\u8a08\u7b97 (\u6570\u5024\u89e3) / ndarray\u30eb\u30fc\u30d7 : \u95a2\u6570\u306e\u30d9\u30af\u30c8\u30eb\u5316 - Single Process\n    time_start = time.time()\n    for i in range(loop_num):\n        tmp_df['vol2'] = myapply_vect(df['F225_PRICE'].values, df['STRIKE'].values, \n                              df['OP_PRICE'].values,   df['CALL'].values)\n    result_time.append((time.time() - time_start))\n\n    # 3. Scipy\u4f7f\u3063\u305f\u6700\u9069\u5316\u8a08\u7b97 (\u6570\u5024\u89e3) / ndarray\u30d9\u30af\u30c8\u30eb : \u95a2\u6570\u306e\u30d9\u30af\u30c8\u30eb\u5316 - Single Process\n    time_start = time.time()\n    for i in range(loop_num):\n        tmp_df['vol3'] = myapply_vect2(df['F225_PRICE'].values, df['STRIKE'].values, \n                              df['OP_PRICE'].values,   df['CALL'].values)\n    result_time.append((time.time() - time_start))\n    \n    # 4. Cython - Root\n    time_start = time.time()\n    for i in range(loop_num):\n        tmp_df['vol4'] = cy_apply1(df['F225_PRICE'].values, df['STRIKE'].values, \n                              df['OP_PRICE'].values,   df['CALL'].values)\n    result_time.append((time.time() - time_start))\n\n    # 5. Cython - My Bisection\n    time_start = time.time()\n    for i in range(loop_num):\n        tmp_df['vol5'] = cy_apply2(df['F225_PRICE'].values, df['STRIKE'].values, \n                              df['OP_PRICE'].values,   df['CALL'].values)\n    result_time.append((time.time() - time_start))\n\n    # 6. Multi Process\n    time_start = time.time()\n    for i in range(loop_num):\n        p = mp.Pool(processes=8)\n        split_dfs = np.array_split(df,8)\n        pool_results = p.map(pworker, split_dfs)\n        p.close()\n        p.join()\n\n        tmp_df = pd.concat(pool_results, axis=0)\n    result_time.append((time.time() - time_start))\n\n    # 7. ANN\n    model = load_model('./model.h5')\n    \n    a = np.array([df['STRIKE'].values/df['F225_PRICE'].values])\n    b = np.array([np.ones_like(df['F225_PRICE'].values)*maturity/(40./245.)])\n    c = np.array([(df['OP_PRICE'].values/df['F225_PRICE'].values/0.25)**0.25])\n    \n    X = np.vstack((a,b,c)).transpose()\n\n    time_start = time.time()\n    for i in range(loop_num):\n        tmp_df['vol7'] = 0.4*model.predict(X)+0.1\n    result_time.append((time.time() - time_start))    \n        \n    # 8. Swig C++\n    tmpmpmp=np.ones_like(df['F225_PRICE'].values).astype(np.float32)\n    time_start = time.time()\n    for i in range(loop_num):\n        tmpmpmp = Swig_Apply_PY(df['F225_PRICE'].values, df['STRIKE'].values, \n                              df['OP_PRICE'].values,  df['CALL'].values.astype(dtype=np.int32),tmpmpmp.shape[0])\n        tmp_df['vol8'] =  tmpmpmp\n    result_time.append((time.time() - time_start))\n\n    result_time = np.array([result_time])\n    print(np.vstack((result_con, result_opt, result_Vect, result_Proc,result_time)).transpose())\n```\n\n"}