{"tags": ["C++", "Siv3DMay2014v2"], "context": " More than 1 year has passed since last update.\u521d\u671f\u72b6\u614b\n\n\u51fa\u529b\u4f8b\n\n\u3093\uff5e\u3001\u3044\u307e\u3044\u3061\u3002\n\u306a\u3093\u304b\u9045\u3044\u3057\u3002\n\nSiv3DApp.cpp\n#include <Siv3D.hpp>\n#include <map>\n\nvoid Main()\n{\n\n  const unsigned int WIDTH  = 32 ;\n  const unsigned int HEIGHT = 24 ;\n\n  std::vector<std::vector<int>> field(WIDTH, std::vector<int>(HEIGHT, 0)) ;\n  std::map<int, Rect> clusters ;\n  for (int y = 0, i = 0; y < HEIGHT; ++y) for (int x = 0; x < WIDTH; ++x) {\n    clusters[i] = Rect{x, y, 1, 1} ;\n    field[x][y] = i++ ;\n  }\n\n  for (std::vector<Point> p; clusters.size() > 1; p.clear()) {\n    for (auto d : clusters) {\n      if ((d.second.x + d.second.w) < WIDTH) {\n        auto t = field[d.second.x + d.second.w][d.second.y] ;\n        if (d.second.y == clusters[t].y && d.second.h == clusters[t].h) p.emplace_back(Point{d.first, t}) ;\n      }\n      if ((d.second.y + d.second.h) < HEIGHT) {\n        auto t = field[d.second.x][d.second.y + d.second.h] ;\n        if (d.second.x == clusters[t].x && d.second.w == clusters[t].w) p.emplace_back(Point{d.first, t}) ;\n      }\n    }\n    if (p.empty()) break ;\n\n    Point t = p[Random<int>(0, p.size()-1)] ;\n    if ((Max(clusters[t.x].w, clusters[t.x].h) / Min(clusters[t.x].w, clusters[t.x].h)) >= 3) t = p[Random<int>(0, p.size()-1)] ;\n    if (clusters[t.x].x + clusters[t.x].w < WIDTH && t.y == field[clusters[t.x].x + clusters[t.x].w][clusters[t.x].y]) clusters[t.x].w += clusters[t.y].w ;\n    else {\n      clusters[t.x].h += clusters[t.y].h ;\n    }\n    for (unsigned int y = 0; y < HEIGHT; ++y) for (unsigned int x = 0; x < WIDTH; ++x) if (field[x][y] == t.y) field[x][y] = t.x ;\n    clusters.erase(clusters.find(t.y)) ;\n  }\n\n  int i = 0 ;\n  for (auto c : clusters) {\n    for (unsigned int y = 0; y < HEIGHT; ++y) for (unsigned int x = 0; x < WIDTH; ++x) if (field[x][y] == c.first) field[x][y] = i ;\n    ++i ;\n  }\n\n  const int CSIZE = 20 ;\n  while (System::Update()) {\n    for (int y = 0; y < HEIGHT; ++y) for (int x = 0; x < WIDTH; ++x) {\n      if (x == (WIDTH - 1) || field[x][y] != field[x+1][y]) Line(CSIZE * (x + 1), CSIZE * y, CSIZE * (x + 1), CSIZE * (y + 1)).draw() ;\n      if (y == (HEIGHT - 1) || field[x][y] != field[x][y+1]) Line(CSIZE * x, CSIZE * (y + 1), CSIZE * (x + 1), CSIZE * (y + 1)).draw() ;\n    }\n  }\n}\n\n\n\u521d\u671f\u72b6\u614b\n![20140923-120823-235.png](https://qiita-image-store.s3.amazonaws.com/0/54532/5051c1da-806c-cd45-3f39-8c06c150e8c5.png)\n\n\u51fa\u529b\u4f8b\n![20140923-121016-271.png](https://qiita-image-store.s3.amazonaws.com/0/54532/045074d6-33a5-782a-e1d4-ee7567e7d450.png)\n\n\u3093\uff5e\u3001\u3044\u307e\u3044\u3061\u3002\n\u306a\u3093\u304b\u9045\u3044\u3057\u3002\n\n```Cpp:Siv3DApp.cpp\n#include <Siv3D.hpp>\n#include <map>\n\nvoid Main()\n{\n\n  const unsigned int WIDTH  = 32 ;\n  const unsigned int HEIGHT = 24 ;\n\n  std::vector<std::vector<int>> field(WIDTH, std::vector<int>(HEIGHT, 0)) ;\n  std::map<int, Rect> clusters ;\n  for (int y = 0, i = 0; y < HEIGHT; ++y) for (int x = 0; x < WIDTH; ++x) {\n    clusters[i] = Rect{x, y, 1, 1} ;\n    field[x][y] = i++ ;\n  }\n\n  for (std::vector<Point> p; clusters.size() > 1; p.clear()) {\n    for (auto d : clusters) {\n      if ((d.second.x + d.second.w) < WIDTH) {\n        auto t = field[d.second.x + d.second.w][d.second.y] ;\n        if (d.second.y == clusters[t].y && d.second.h == clusters[t].h) p.emplace_back(Point{d.first, t}) ;\n      }\n      if ((d.second.y + d.second.h) < HEIGHT) {\n        auto t = field[d.second.x][d.second.y + d.second.h] ;\n        if (d.second.x == clusters[t].x && d.second.w == clusters[t].w) p.emplace_back(Point{d.first, t}) ;\n      }\n    }\n    if (p.empty()) break ;\n\n    Point t = p[Random<int>(0, p.size()-1)] ;\n    if ((Max(clusters[t.x].w, clusters[t.x].h) / Min(clusters[t.x].w, clusters[t.x].h)) >= 3) t = p[Random<int>(0, p.size()-1)] ;\n    if (clusters[t.x].x + clusters[t.x].w < WIDTH && t.y == field[clusters[t.x].x + clusters[t.x].w][clusters[t.x].y]) clusters[t.x].w += clusters[t.y].w ;\n    else {\n      clusters[t.x].h += clusters[t.y].h ;\n    }\n    for (unsigned int y = 0; y < HEIGHT; ++y) for (unsigned int x = 0; x < WIDTH; ++x) if (field[x][y] == t.y) field[x][y] = t.x ;\n    clusters.erase(clusters.find(t.y)) ;\n  }\n\n  int i = 0 ;\n  for (auto c : clusters) {\n    for (unsigned int y = 0; y < HEIGHT; ++y) for (unsigned int x = 0; x < WIDTH; ++x) if (field[x][y] == c.first) field[x][y] = i ;\n    ++i ;\n  }\n\n  const int CSIZE = 20 ;\n  while (System::Update()) {\n    for (int y = 0; y < HEIGHT; ++y) for (int x = 0; x < WIDTH; ++x) {\n      if (x == (WIDTH - 1) || field[x][y] != field[x+1][y]) Line(CSIZE * (x + 1), CSIZE * y, CSIZE * (x + 1), CSIZE * (y + 1)).draw() ;\n      if (y == (HEIGHT - 1) || field[x][y] != field[x][y+1]) Line(CSIZE * x, CSIZE * (y + 1), CSIZE * (x + 1), CSIZE * (y + 1)).draw() ;\n    }\n  }\n}\n```\n"}