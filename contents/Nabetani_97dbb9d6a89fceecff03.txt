{"context": " More than 1 year has passed since last update.\u7b2c\u4e94\u56de\u30aa\u30d5\u30e9\u30a4\u30f3\u30ea\u30a2\u30eb\u30bf\u30a4\u30e0\u3069\u3046\u66f8\u304f( http://atnd.org/events/32979 )\u3002\n\u554f\u984c\u306f\u4e0b\u8a18 URL\u3002\nhttp://nabetani.sakura.ne.jp/hena/ord5dahimi/\n\u3067\u3002\nruby \u306e\u5b9f\u88c5 ( http://qiita.com/items/65923e184b2331c266e8 ) \u3092\u307b\u307c\u305d\u306e\u307e\u307e C++11 \u306b\u79fb\u690d\u3057\u3066\u307f\u305f\u3002\n\ndahi.cpp\n// use -std=c++0x or -std=c++11\n#include <iostream>\n#include <vector>\n#include <string>\n#include <set>\n#include <tr1/functional>\n\nusing namespace std;\nusing namespace std::tr1;\nconst int JOKER=13;\n\nint strength1( string const & str )\n{\n    return string(\"3456789TJQKA2o\").find( str[1] );\n}\n\nint strength( vector<string> const & c )\n{\n    return strength1( \n        *min_element( \n            c.begin(), c.end(), \n            []( string const & a, string const & b)->bool{  return strength1(a)<strength1(b);  } ) );\n}\n\nbool legal_hand( vector<string> const & cand )\n{\n    set<int> s;\n    transform( cand.begin(), cand.end(), inserter( s, s.end() ), strength1 );\n    return s.size()==1 || ( s.size()==2 && *s.rbegin()==JOKER );\n}\n\ntemplate< typename itor_t >\nvector<string>\ncardset( itor_t const & b, itor_t const & e )\n{\n    vector<string> r;\n    for( itor_t it = b ; it!=e && it-1!=e ; it+=2 ){\n        r.push_back( string( it, it+2 ) );\n    }\n    return r;\n}\n\ntemplate< typename itor_t >\nstd::vector<string>\nconcat( std::vector<string> const & a, itor_t b, itor_t e )\n{\n    std::vector<string> r(a);\n    r.insert( r.end(), b, e );\n    return r;\n}\n\ntemplate< typename itor_t >\nvoid\ncombination( \n    itor_t b, itor_t e, int size, \n    function< void( vector<string> const & ) > const & pred )\n{\n    typedef string value_type;\n    if (size==0){\n        pred( std::vector< value_type >() );\n    } else if ( size<=e-b ){\n        combination( b+1, e, size, pred );\n        combination( b+1, e, size-1,[&]( vector<value_type> const & c ){\n            pred( concat( c, b, b+1 ) );\n        });\n    }\n}\n\ntemplate< typename container_t >\nstring join( container_t const & c, string const & sepa )\n{\n    string result;\n    for( auto it = c.begin() ; it != c.end() ; ++it ){\n        result += ( it != c.begin() ? sepa : string() )+*it;\n    }\n    return result;\n}\n\nstring solve( string const & input )\n{\n    size_t comma=input.find( ',' );\n    auto f=cardset( input.begin(), input.begin()+comma );\n    auto hand=cardset( input.begin()+comma+1, input.end() );\n    int sf=strength(f);\n    set< string > candidates;\n    combination( hand.begin(), hand.end(), f.size(), [&]( vector<string> const & c ){\n        if ( legal_hand(c) && sf<strength(c) ){\n            candidates.insert( join( set<string>( c.begin(), c.end() ), \"\" ) );\n        }\n    });\n    string result = join( candidates, \",\" );\n    return result.empty() ? \"-\" : result;\n}\n\nset< string >\nnormalized( string const & str )\n{\n    set<string> r;\n    auto sorted = []( string const & s )->string{\n        string r=s;\n        sort( (int16_t*)r.data(), (int16_t*)( r.data()+r.size()/2*2) ); // evil implement.\n        return r;\n    };\n    for( size_t ix=0;;){\n        size_t comma=str.find( \",\", ix );\n        if ( comma==string::npos ){\n            r.insert( sorted( str.substr( ix )) );\n            return r;\n        } else {\n            r.insert( sorted( str.substr( ix, comma-ix )));\n            ix=comma+1;\n        }\n    }\n}\n\nbool are_same( string const & a, string const & b )\n{\n    return normalized( a ) == normalized( b );\n}\n\nvoid test( string const & input, string const & expected )\n{\n    string actual = solve( input );\n    cout << input << \"\\n   :\" \n        << actual << \"\\n   :\" \n        << expected << \"\\n    -> \" \n        << ( are_same( actual, expected ) ? \"ok\" : \"*** FAIL ***\" )<< endl;\n}\n\nint main()\n{\n    /*#1*/ test( \"DJ,\", \"-\" );\n    /*#7*/ test( \"ST,D6S8JoC7HQHAC2CK\", \"Jo,C2,CK,HA,HQ\" );\n    /*#10*/ test( \"Jo,HAC8DJSJDTH2\", \"-\" );\n    /*#24*/ test( \"JoD4H4,D3H3S3C3CADASAD2\", \"DACASA\" );\n    /*#31*/ test( \"DTCTSTHT,S3SQH3HQD3DQC3CQJo\", \"HQSQJoDQ,SQCQDQJo,DQCQHQJo,SQHQJoCQ,CQDQHQSQ\" );\n}\n\n\n\u3044\u3064\u3082\u3069\u304a\u308a\u30c6\u30b9\u30c8\u306e\u5927\u534a\u306f\u7701\u7565\u3002\n\u307e\u3060 lambda \u306e\u6587\u6cd5\u306b\u6163\u308c\u3066\u306a\u3044\u3002\nC++11 \u306e algorithm \u3068 string \u3092\u8abf\u3079\u308c\u3070\u3082\u3046\u5c11\u3057\u697d\u3067\u304d\u308b\u306e\u304b\u3082\u3057\u308c\u306a\u3044\u3068\u8003\u3048\u3066\u3044\u308b\u3082\u306e\u306e\u3001\u4eca\u306e\u3068\u3053\u308d\u306f\u3053\u3093\u306a\u611f\u3058\u3002\nstd::next_permutation \u306f\u3042\u308b\u306e\u306b std::next_combination \u304c\u306a\u3044\u306e\u304c\u6b8b\u5ff5\u3002\n\u7b2c\u4e94\u56de\u30aa\u30d5\u30e9\u30a4\u30f3\u30ea\u30a2\u30eb\u30bf\u30a4\u30e0\u3069\u3046\u66f8\u304f( http://atnd.org/events/32979 )\u3002\n\u554f\u984c\u306f\u4e0b\u8a18 URL\u3002\nhttp://nabetani.sakura.ne.jp/hena/ord5dahimi/\n\u3067\u3002\nruby \u306e\u5b9f\u88c5 ( http://qiita.com/items/65923e184b2331c266e8 ) \u3092\u307b\u307c\u305d\u306e\u307e\u307e C++11 \u306b\u79fb\u690d\u3057\u3066\u307f\u305f\u3002\n\n```c++:dahi.cpp\n// use -std=c++0x or -std=c++11\n#include <iostream>\n#include <vector>\n#include <string>\n#include <set>\n#include <tr1/functional>\n\nusing namespace std;\nusing namespace std::tr1;\nconst int JOKER=13;\n\nint strength1( string const & str )\n{\n    return string(\"3456789TJQKA2o\").find( str[1] );\n}\n\nint strength( vector<string> const & c )\n{\n    return strength1( \n        *min_element( \n            c.begin(), c.end(), \n            []( string const & a, string const & b)->bool{  return strength1(a)<strength1(b);  } ) );\n}\n\nbool legal_hand( vector<string> const & cand )\n{\n    set<int> s;\n    transform( cand.begin(), cand.end(), inserter( s, s.end() ), strength1 );\n    return s.size()==1 || ( s.size()==2 && *s.rbegin()==JOKER );\n}\n\ntemplate< typename itor_t >\nvector<string>\ncardset( itor_t const & b, itor_t const & e )\n{\n    vector<string> r;\n    for( itor_t it = b ; it!=e && it-1!=e ; it+=2 ){\n        r.push_back( string( it, it+2 ) );\n    }\n    return r;\n}\n\ntemplate< typename itor_t >\nstd::vector<string>\nconcat( std::vector<string> const & a, itor_t b, itor_t e )\n{\n    std::vector<string> r(a);\n    r.insert( r.end(), b, e );\n    return r;\n}\n\ntemplate< typename itor_t >\nvoid\ncombination( \n    itor_t b, itor_t e, int size, \n    function< void( vector<string> const & ) > const & pred )\n{\n    typedef string value_type;\n    if (size==0){\n        pred( std::vector< value_type >() );\n    } else if ( size<=e-b ){\n        combination( b+1, e, size, pred );\n        combination( b+1, e, size-1,[&]( vector<value_type> const & c ){\n            pred( concat( c, b, b+1 ) );\n        });\n    }\n}\n\ntemplate< typename container_t >\nstring join( container_t const & c, string const & sepa )\n{\n    string result;\n    for( auto it = c.begin() ; it != c.end() ; ++it ){\n        result += ( it != c.begin() ? sepa : string() )+*it;\n    }\n    return result;\n}\n\nstring solve( string const & input )\n{\n    size_t comma=input.find( ',' );\n    auto f=cardset( input.begin(), input.begin()+comma );\n    auto hand=cardset( input.begin()+comma+1, input.end() );\n    int sf=strength(f);\n    set< string > candidates;\n    combination( hand.begin(), hand.end(), f.size(), [&]( vector<string> const & c ){\n        if ( legal_hand(c) && sf<strength(c) ){\n            candidates.insert( join( set<string>( c.begin(), c.end() ), \"\" ) );\n        }\n    });\n    string result = join( candidates, \",\" );\n    return result.empty() ? \"-\" : result;\n}\n\nset< string >\nnormalized( string const & str )\n{\n    set<string> r;\n    auto sorted = []( string const & s )->string{\n        string r=s;\n        sort( (int16_t*)r.data(), (int16_t*)( r.data()+r.size()/2*2) ); // evil implement.\n        return r;\n    };\n    for( size_t ix=0;;){\n        size_t comma=str.find( \",\", ix );\n        if ( comma==string::npos ){\n            r.insert( sorted( str.substr( ix )) );\n            return r;\n        } else {\n            r.insert( sorted( str.substr( ix, comma-ix )));\n            ix=comma+1;\n        }\n    }\n}\n\nbool are_same( string const & a, string const & b )\n{\n    return normalized( a ) == normalized( b );\n}\n\nvoid test( string const & input, string const & expected )\n{\n    string actual = solve( input );\n    cout << input << \"\\n   :\" \n        << actual << \"\\n   :\" \n        << expected << \"\\n    -> \" \n        << ( are_same( actual, expected ) ? \"ok\" : \"*** FAIL ***\" )<< endl;\n}\n\nint main()\n{\n    /*#1*/ test( \"DJ,\", \"-\" );\n    /*#7*/ test( \"ST,D6S8JoC7HQHAC2CK\", \"Jo,C2,CK,HA,HQ\" );\n    /*#10*/ test( \"Jo,HAC8DJSJDTH2\", \"-\" );\n    /*#24*/ test( \"JoD4H4,D3H3S3C3CADASAD2\", \"DACASA\" );\n    /*#31*/ test( \"DTCTSTHT,S3SQH3HQD3DQC3CQJo\", \"HQSQJoDQ,SQCQDQJo,DQCQHQJo,SQHQJoCQ,CQDQHQSQ\" );\n}\n```\n\n\u3044\u3064\u3082\u3069\u304a\u308a\u30c6\u30b9\u30c8\u306e\u5927\u534a\u306f\u7701\u7565\u3002\n\u307e\u3060 lambda \u306e\u6587\u6cd5\u306b\u6163\u308c\u3066\u306a\u3044\u3002\n\nC++11 \u306e algorithm \u3068 string \u3092\u8abf\u3079\u308c\u3070\u3082\u3046\u5c11\u3057\u697d\u3067\u304d\u308b\u306e\u304b\u3082\u3057\u308c\u306a\u3044\u3068\u8003\u3048\u3066\u3044\u308b\u3082\u306e\u306e\u3001\u4eca\u306e\u3068\u3053\u308d\u306f\u3053\u3093\u306a\u611f\u3058\u3002\n\nstd::next_permutation \u306f\u3042\u308b\u306e\u306b std::next_combination \u304c\u306a\u3044\u306e\u304c\u6b8b\u5ff5\u3002\n\n\n", "tags": ["\u3069\u3046\u66f8\u304f", "yhpg", "C++11", "C++"]}