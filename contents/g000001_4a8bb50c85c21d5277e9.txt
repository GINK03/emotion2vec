{"tags": ["common-lisp", "2ch"], "context": " More than 1 year has passed since last update.577 \u540d\u524d\uff1a\u30c7\u30d5\u30a9\u30eb\u30c8\u306e\u540d\u7121\u3057\u3055\u3093 [sage]\uff1a 2012/10/12(\u91d1) 02:28:41.73\nCormen\u306eintroduction to algorrithms\u306einsertion-sort\u3092common lisp\u3067\n\u305d\u306e\u307e\u307e\u66f8\u3044\u3066\u307f\u3088\u3046\u3068\u3057\u305f\u306e\u3067\u3059\u304c\u3046\u307e\u304f\u52d5\u304d\u307e\u305b\u3093\n\u64ec\u4f3c\u30b3\u30fc\u30c9\u306f\u2193\u306e\u30ce\u30fc\u30c8\u4e2d\u7a0b\u306b\u3042\u308a\u307e\u3059\nhttp://www.catonmat.net/blog/wp-content/uploads/2008/08/mit-algorithms-lecture-01-01.jpg\n\u3053\u308c\u3092\u3082\u3068\u306b\n(defun insertion-sort (a)\n  (let (key i j)\n    (do ((j 1 (+ j 1)))\n        ((= j (length a)) a)\n      (setf key (nth j a))\n      (let ((i 0)\n            (j 0))\n        (loop\n          when (and (> i 0)\n                    (> (nth i a) key))\n            do\n         (setf (nth (+ i 1) a) (nth i a))\n         (setf i 0\n               j 0))\n        (setf (nth i a) key))\n      )\n    a))\n\n\u3068\u66f8\u3044\u3066\n(insertion-sort '(5 2 4 6 1 3))\n\n\u3067\u4f55\u3082\u5024\u304c\u8fd4\u3063\u3066\u304d\u307e\u305b\u3093\u3067\u3057\u305f\n\u3069\u3053\u304c\u9593\u9055\u3063\u3066\u3044\u308b\u306e\u3067\u3057\u3087\u3046\u304b \n\n\u30d0\u30b0\u4fee\u6b63\n\n\u5909\u6570\u30b9\u30b3\u30fc\u30d7\u306e\u53d6\u308a\u65b9\u304c\u304a\u304b\u3057\u3044\u306e\u3067\u4fee\u6b63\nwhen\u3058\u3083\u306a\u304f\u3066while\ni\u3092\u30c7\u30af\u30ea\u30e1\u30f3\u30c8\u3057\u3066\u306a\u3044\u306e\u3067\u8ffd\u8a18(\u7121\u9650\u30eb\u30fc\u30d7\u306e\u539f\u56e0)\n\n(defun insertion-sort (a)\n  (do ((j 1 (1+ j))\n       (len (length a)) )\n      ((>= j len) a)\n    (let ((key (nth j a))\n          (i (- j 1)) )\n      (loop :while (and (>= i 0)\n                        (> (nth i a) key) )\n            :do (setf (nth (+ i 1) a) (nth i a))\n                (decf i) )\n      (setf (nth (+ i 1) a) key) )))\n\n(insertion-sort '(5 2 4 6 1 3))\n;=>  (1 2 3 4 5 6)\n\n\n\u6539\u5584\n\u3053\u306e\u3088\u3046\u306a\u51e6\u7406\u3067\u4f7f\u3046\u30c7\u30fc\u30bf\u578b\u3068\u3057\u3066\u30ea\u30b9\u30c8\u306f\u4e0d\u9069\u5207\u306a\u306e\u3067\u30d9\u30af\u30bf\u306b\u5909\u66f4\n\u53c2\u8003: http://google-styleguide.googlecode.com/svn/trunk/lispguide.xml?showone=Lists_vs._Arrays#Lists_vs._Arrays\n;;; DO\u4e00\u8272\n(defun insertion-sort (a)\n  (do ((j 1 (1+ j))\n       (len (length a)) )\n      ((>= j len) a)\n    (do ((key (aref a j))\n         (i (1- j) (1- i)) )\n        ((not (and (>= i 0)\n                   (> (aref a i) key) ))\n         (setf (aref a (1+ i)) key) )\n      (setf (aref a (1+ i)) (aref a i)) )))\n\n\n;;; LOOP\u4e00\u8272\n(defun insertion-sort (a)\n  (loop :for j :from 1 :below (length a)\n        :for key := (aref a j)\n        :for i := (1- j)\n        :do (loop :while (and (>= i 0) (> (aref a i) key))\n                  :do (setf (aref a (1+ i)) (aref a i))\n                      (decf i) )\n            (setf (aref a (1+ i))\n                  key))\n  a)\n\n(mapcar #'insertion-sort\n        (list (vector)\n              (vector 1)\n              (vector 2 1)\n              (vector 9 8 7 6 5 4 3 2 1)))\n;=>  (#() #(1) #(1 2) #(1 2 3 4 5 6 7 8 9))\n\n577 \u540d\u524d\uff1a\u30c7\u30d5\u30a9\u30eb\u30c8\u306e\u540d\u7121\u3057\u3055\u3093 [sage]\uff1a 2012/10/12(\u91d1) 02:28:41.73  \nCormen\u306eintroduction to algorrithms\u306einsertion-sort\u3092common lisp\u3067\n\u305d\u306e\u307e\u307e\u66f8\u3044\u3066\u307f\u3088\u3046\u3068\u3057\u305f\u306e\u3067\u3059\u304c\u3046\u307e\u304f\u52d5\u304d\u307e\u305b\u3093\n\u64ec\u4f3c\u30b3\u30fc\u30c9\u306f\u2193\u306e\u30ce\u30fc\u30c8\u4e2d\u7a0b\u306b\u3042\u308a\u307e\u3059\nhttp://www.catonmat.net/blog/wp-content/uploads/2008/08/mit-algorithms-lecture-01-01.jpg\n\u3053\u308c\u3092\u3082\u3068\u306b\n\n```cl\n(defun insertion-sort (a)\n  (let (key i j)\n    (do ((j 1 (+ j 1)))\n        ((= j (length a)) a)\n      (setf key (nth j a))\n      (let ((i 0)\n            (j 0))\n        (loop\n          when (and (> i 0)\n                    (> (nth i a) key))\n            do\n         (setf (nth (+ i 1) a) (nth i a))\n         (setf i 0\n               j 0))\n        (setf (nth i a) key))\n      )\n    a))\n```\n\u3068\u66f8\u3044\u3066\n\n```cl\n(insertion-sort '(5 2 4 6 1 3))\n```\n\u3067\u4f55\u3082\u5024\u304c\u8fd4\u3063\u3066\u304d\u307e\u305b\u3093\u3067\u3057\u305f\n\u3069\u3053\u304c\u9593\u9055\u3063\u3066\u3044\u308b\u306e\u3067\u3057\u3087\u3046\u304b \n\n## \u30d0\u30b0\u4fee\u6b63\n1. \u5909\u6570\u30b9\u30b3\u30fc\u30d7\u306e\u53d6\u308a\u65b9\u304c\u304a\u304b\u3057\u3044\u306e\u3067\u4fee\u6b63\n2. when\u3058\u3083\u306a\u304f\u3066while\n3. i\u3092\u30c7\u30af\u30ea\u30e1\u30f3\u30c8\u3057\u3066\u306a\u3044\u306e\u3067\u8ffd\u8a18(\u7121\u9650\u30eb\u30fc\u30d7\u306e\u539f\u56e0)\n\n```cl\n(defun insertion-sort (a)\n  (do ((j 1 (1+ j))\n       (len (length a)) )\n      ((>= j len) a)\n    (let ((key (nth j a))\n          (i (- j 1)) )\n      (loop :while (and (>= i 0)\n                        (> (nth i a) key) )\n            :do (setf (nth (+ i 1) a) (nth i a))\n                (decf i) )\n      (setf (nth (+ i 1) a) key) )))\n```\n\n```cl\n(insertion-sort '(5 2 4 6 1 3))\n;=>  (1 2 3 4 5 6)\n```\n## \u6539\u5584\n\u3053\u306e\u3088\u3046\u306a\u51e6\u7406\u3067\u4f7f\u3046\u30c7\u30fc\u30bf\u578b\u3068\u3057\u3066\u30ea\u30b9\u30c8\u306f\u4e0d\u9069\u5207\u306a\u306e\u3067\u30d9\u30af\u30bf\u306b\u5909\u66f4\n\u53c2\u8003: http://google-styleguide.googlecode.com/svn/trunk/lispguide.xml?showone=Lists_vs._Arrays#Lists_vs._Arrays\n\n```cl\n;;; DO\u4e00\u8272\n(defun insertion-sort (a)\n  (do ((j 1 (1+ j))\n       (len (length a)) )\n      ((>= j len) a)\n    (do ((key (aref a j))\n         (i (1- j) (1- i)) )\n        ((not (and (>= i 0)\n                   (> (aref a i) key) ))\n         (setf (aref a (1+ i)) key) )\n      (setf (aref a (1+ i)) (aref a i)) )))\n\n\n;;; LOOP\u4e00\u8272\n(defun insertion-sort (a)\n  (loop :for j :from 1 :below (length a)\n        :for key := (aref a j)\n        :for i := (1- j)\n        :do (loop :while (and (>= i 0) (> (aref a i) key))\n                  :do (setf (aref a (1+ i)) (aref a i))\n                      (decf i) )\n            (setf (aref a (1+ i))\n                  key))\n  a)\n```\n\n```cl\n(mapcar #'insertion-sort\n        (list (vector)\n              (vector 1)\n              (vector 2 1)\n              (vector 9 8 7 6 5 4 3 2 1)))\n;=>  (#() #(1) #(1 2) #(1 2 3 4 5 6 7 8 9))\n```\n\n"}