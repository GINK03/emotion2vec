{"tags": ["\u60c5\u5f31", "Haskell"], "context": " \u3053\u306e\u8a18\u4e8b\u306f\u6700\u7d42\u66f4\u65b0\u65e5\u304b\u30891\u5e74\u4ee5\u4e0a\u304c\u7d4c\u904e\u3057\u3066\u3044\u307e\u3059\u3002\uff08\u5143\u30cd\u30bf\u306f http://nabetani.sakura.ne.jp/hena/ord17foldcut/ \uff09\n\uff08\u89e3\u7b54\u4f8b\u306f http://qiita.com/Nabetani/items/ebd9d7deb30c57447806 \uff09\n(Ver.1)\u3092\u66f8\u3044\u3066\u308b\u9014\u4e2d\u3067\u6c17\u304c\u3064\u3044\u305f\u304cBool\u5024\u3067\u306a\u304f0,1\u3067\n\u8868\u73fe\u3057\u3066||\u306e\u4ee3\u308f\u308a\u306b*\u3092\u4f7f\u3063\u3066\u3001\u96c6\u8a08\u306f\u5168\u8981\u7d20\u3092\u8db3\u3057\u4e0a\u3052\u308b\u3001\n\u3068\u3044\u3046\u65b9\u304c\u30b7\u30f3\u30d7\u30eb\u3060\u3063\u305f\u3002\u307e\u3042\u3067\u3082\u306a\u306b\u3082\u5de5\u592b\u305b\u305a\u306b\n\u611a\u76f4\u306b\u66f8\u304f\u3068\u3053\u3046\u306a\u3063\u305f\u3068\u3044\u3046\u3053\u3068\u3067\uff08\u3067\u308245\u5206\u304b\u304b\u3063\u305f\u2026\uff09\n(Ver.2)\u3068\u3057\u3066\u52b9\u7387\u306e\u60aa\u3055\u3082\u3042\u3093\u307e\u308a\u3068\u3044\u3048\u3070\u3042\u3093\u307e\u308a\u306a\u306e\u3067\u3001\n\u3082\u3046\u5c11\u3057\u3060\u3051\u30de\u30b7\u306a\u3084\u3064\u3082\u66f8\u3044\u3066\u307f\u305f\u3002\u3067\u3082\u307e\u3042\u3042\u3093\u307e\u308a\u5909\u308f\u3089\u306a\u3044\u6c17\u3082\u3059\u308b\u3002\n\u6700\u7d42\u7684\u306b\u8eab\u3082\u84cb\u3082\u306a\u3044(Ver.3)\u3092\u66f8\u3044\u3066\u307f\u305f\u3002\n\u591a\u5206\u3053\u308c\u304c\u4e00\u756a\u901f\u3044\uff0820\u56de\u307b\u3069\u6298\u308a\u8fd4\u3057\u3066\u30823ms\u3068\u304b\u3067\u8a08\u7b97\u304c\u7d42\u308f\u308b\uff09\u3002\n\u7a74\u306e\u6570\u3057\u304b\u8003\u3048\u306a\u3044\u30d0\u30fc\u30b8\u30e7\u30f3(ver.3)\n4\u9685\u306e\u5207\u308c\u8fbc\u307f\u30014\u8fba\u306e\u5207\u308c\u8fbc\u307f\u3001\u5185\u90e8\u306e\u7a74\u306e\u6570\u306e\u307f\u3067\u7d19\u306e\u72b6\u614b\u3092\u8868\u73fe\u3059\u308b\uff1a\n\nFold_and_Cut_Ter.hs\nmodule Main where\n\nimport Control.Applicative\nimport Data.List\nimport Data.List.Split (splitOn)\n\n-- 4\u96854\u8fba\u306e\u5207\u308c\u8fbc\u307f\u306e\u6570\u3068\u5185\u90e8\u306e\u7a74\u306e\u6570\ntype Paper = (Int,Int,Int,Int,Int,Int,Int,Int,Int)\ntype Fold = Char\n\nconstruct :: String -> Paper\nconstruct str = develop (cut b) (reverse a)\n  where [a,b] = splitOn \"-\" str \n\ncut :: String -> Paper\ncut str = case str of\n  \"tl\" -> (1,0,0,0,0,0,0,0,0)\n  \"tr\" -> (0,1,0,0,0,0,0,0,0)\n  \"bl\" -> (0,0,1,0,0,0,0,0,0)\n  \"br\" -> (0,0,0,1,0,0,0,0,0)\n\n-- \u6298\u308a\u3092\u5e83\u3052\u308b\u3068\u5207\u308c\u8fbc\u307f\u3068\u7a74\u306e\u6570\u304c\u3069\u3046\u5909\u5316\u3059\u308b\u304b\nufold :: Paper -> Fold -> Paper\nufold (tl,tr,bl,br,t,b,l,r,n) c = case c of\n  'T' -> (bl,br,bl,br,b,b,2*l+tl,2*r+tr,2*n+t)\n  'B' -> (tl,tr,tl,tr,t,t,2*l+bl,2*r+br,2*n+b)\n  'L' -> (tr,tr,br,br,2*t+tl,2*b+bl,r,r,2*n+l)\n  'R' -> (tl,tl,bl,bl,2*t+tr,2*b+br,l,l,2*n+r)\n\ndevelop :: Paper -> [Fold] -> Paper\ndevelop p fs = foldl ufold p fs\n\ncountHoles :: Paper -> Int\ncountHoles (tl,tr,bl,br,t,b,l,r,n) = n\n\nsolve :: String -> Int\nsolve = countHoles.construct\n\nmain = solve<$>getLine >>= print >> main\n\n\n\u7d19\u3092\u305d\u306e\u307e\u307e\u8868\u73fe\u3059\u308b\u30f4\u30a1\u30fc\u30b8\u30e7\u30f3(Ver.1)\uff1a\n\nFold_and_Cut.hs\nmodule Main where\nimport Control.Applicative\nimport Data.List\nimport Data.List.Split (splitOn)\n\ntype Cell = Bool\ntype Paper = [[Cell]]\ntype Fold = Char\n\nconstruct str = develop (cut b) (reverse a)\n  where [a,b] = splitOn \"-\" str \n\ncut str = case str of\n  \"tl\" ->[[False,True],[True,True]] \n  \"tr\" ->[[True,False],[True,True]] \n  \"bl\" ->[[True,True],[False,True]] \n  \"br\" ->[[True,True],[True,False]] \n\nufold :: Paper -> Fold -> Paper\nufold p f = case f of\n  'T' -> reverse p ++ p\n  'B' -> p ++ reverse p \n  'L' -> map (\\x -> reverse x ++ x) p\n  'R' -> map (\\x -> x ++ reverse x) p\n\ndevelop :: Paper -> [Fold] -> Paper\ndevelop p fs = foldl ufold p fs\n\nreduce :: Paper -> [[Cell]]\nreduce [x] = [map (const True) x]\nreduce (x:y:xs) = (zipWith (||) x y) : reduce (y:xs)\n\ncountHoles = length.filter (==False).concat.reduce.transpose.reduce\n\nsolve = countHoles.construct\n\nmain = solve<$>getLine >>= print >> main\n\n\n\n\u7a74\u306e\u5ea7\u6a19\u3060\u3051\u3067\u7d19\u306e\u72b6\u614b\u3092\u8868\u73fe\u3059\u308b\u30f4\u30a1\u30fc\u30b8\u30e7\u30f3(Ver.2)\uff1a\n\nFold_and_Cut_Bis.hs\nmodule Main where\nimport Control.Applicative\nimport Data.List\nimport Data.List.Split (splitOn)\n\ntype Position = (Int,Int)\ntype Paper = ((Int,Int),[Position])\ntype Fold = Char\n\nconstruct :: String -> Paper\nconstruct str = develop (cut b) (reverse a)\n  where [a,b] = splitOn \"-\" str \n\ncut :: String -> Paper\ncut str = case str of\n  \"tl\" -> ((2,2),[(0,0)])\n  \"tr\" -> ((2,2),[(1,0)])\n  \"bl\" -> ((2,2),[(0,1)])\n  \"br\" -> ((2,2),[(1,1)])\n\nufold :: Paper -> Fold -> Paper\nufold ((w,h),ps) c = case c of\n  'T' -> ((w,2*h), dup ps)\n           where dup = concat.map (\\(x,y) -> [(x,h+y),(x,h-y-1)])\n  'B' -> ((w,2*h), dup ps)\n           where dup = concat.map (\\(x,y) -> [(x,y),(x,2*h-y-1)])\n  'L' -> ((2*w, h), dup ps)\n           where dup = concat.map (\\(x,y) -> [(w+x,y),(w-x-1,y)])\n  'R' -> ((2*w, h), dup ps)\n           where dup = concat.map (\\(x,y) -> [(x,y),(2*w-x-1,y)])\n\ndevelop :: Paper -> [Fold] -> Paper\ndevelop p fs = foldl ufold p fs\n\ncountHoles :: Paper -> Int\ncountHoles p = length $ intersect poss $ map (\\(x,y) -> (x+1,y+1)) poss\n  where poss = snd p\n\nsolve = countHoles.construct\n\nmain = solve<$>getLine >>= print >> main\n\n\n\uff08\u5143\u30cd\u30bf\u306f http://nabetani.sakura.ne.jp/hena/ord17foldcut/ \uff09\n\uff08\u89e3\u7b54\u4f8b\u306f http://qiita.com/Nabetani/items/ebd9d7deb30c57447806 \uff09\n\n(Ver.1)\u3092\u66f8\u3044\u3066\u308b\u9014\u4e2d\u3067\u6c17\u304c\u3064\u3044\u305f\u304c`Bool`\u5024\u3067\u306a\u304f`0,1`\u3067\n\u8868\u73fe\u3057\u3066`||`\u306e\u4ee3\u308f\u308a\u306b`*`\u3092\u4f7f\u3063\u3066\u3001\u96c6\u8a08\u306f\u5168\u8981\u7d20\u3092\u8db3\u3057\u4e0a\u3052\u308b\u3001\n\u3068\u3044\u3046\u65b9\u304c\u30b7\u30f3\u30d7\u30eb\u3060\u3063\u305f\u3002\u307e\u3042\u3067\u3082\u306a\u306b\u3082\u5de5\u592b\u305b\u305a\u306b\n\u611a\u76f4\u306b\u66f8\u304f\u3068\u3053\u3046\u306a\u3063\u305f\u3068\u3044\u3046\u3053\u3068\u3067\uff08\u3067\u308245\u5206\u304b\u304b\u3063\u305f\u2026\uff09\n\n(Ver.2)\u3068\u3057\u3066\u52b9\u7387\u306e\u60aa\u3055\u3082\u3042\u3093\u307e\u308a\u3068\u3044\u3048\u3070\u3042\u3093\u307e\u308a\u306a\u306e\u3067\u3001\n\u3082\u3046\u5c11\u3057\u3060\u3051\u30de\u30b7\u306a\u3084\u3064\u3082\u66f8\u3044\u3066\u307f\u305f\u3002\u3067\u3082\u307e\u3042\u3042\u3093\u307e\u308a\u5909\u308f\u3089\u306a\u3044\u6c17\u3082\u3059\u308b\u3002\n\n\u6700\u7d42\u7684\u306b\u8eab\u3082\u84cb\u3082\u306a\u3044(Ver.3)\u3092\u66f8\u3044\u3066\u307f\u305f\u3002\n\u591a\u5206\u3053\u308c\u304c\u4e00\u756a\u901f\u3044\uff0820\u56de\u307b\u3069\u6298\u308a\u8fd4\u3057\u3066\u30823ms\u3068\u304b\u3067\u8a08\u7b97\u304c\u7d42\u308f\u308b\uff09\u3002\n\n\u7a74\u306e\u6570\u3057\u304b\u8003\u3048\u306a\u3044\u30d0\u30fc\u30b8\u30e7\u30f3(ver.3)\n4\u9685\u306e\u5207\u308c\u8fbc\u307f\u30014\u8fba\u306e\u5207\u308c\u8fbc\u307f\u3001\u5185\u90e8\u306e\u7a74\u306e\u6570\u306e\u307f\u3067\u7d19\u306e\u72b6\u614b\u3092\u8868\u73fe\u3059\u308b\uff1a\n\n```hs:Fold_and_Cut_Ter.hs\nmodule Main where\n\nimport Control.Applicative\nimport Data.List\nimport Data.List.Split (splitOn)\n\n-- 4\u96854\u8fba\u306e\u5207\u308c\u8fbc\u307f\u306e\u6570\u3068\u5185\u90e8\u306e\u7a74\u306e\u6570\ntype Paper = (Int,Int,Int,Int,Int,Int,Int,Int,Int)\ntype Fold = Char\n\nconstruct :: String -> Paper\nconstruct str = develop (cut b) (reverse a)\n  where [a,b] = splitOn \"-\" str \n\ncut :: String -> Paper\ncut str = case str of\n  \"tl\" -> (1,0,0,0,0,0,0,0,0)\n  \"tr\" -> (0,1,0,0,0,0,0,0,0)\n  \"bl\" -> (0,0,1,0,0,0,0,0,0)\n  \"br\" -> (0,0,0,1,0,0,0,0,0)\n\n-- \u6298\u308a\u3092\u5e83\u3052\u308b\u3068\u5207\u308c\u8fbc\u307f\u3068\u7a74\u306e\u6570\u304c\u3069\u3046\u5909\u5316\u3059\u308b\u304b\nufold :: Paper -> Fold -> Paper\nufold (tl,tr,bl,br,t,b,l,r,n) c = case c of\n  'T' -> (bl,br,bl,br,b,b,2*l+tl,2*r+tr,2*n+t)\n  'B' -> (tl,tr,tl,tr,t,t,2*l+bl,2*r+br,2*n+b)\n  'L' -> (tr,tr,br,br,2*t+tl,2*b+bl,r,r,2*n+l)\n  'R' -> (tl,tl,bl,bl,2*t+tr,2*b+br,l,l,2*n+r)\n\ndevelop :: Paper -> [Fold] -> Paper\ndevelop p fs = foldl ufold p fs\n\ncountHoles :: Paper -> Int\ncountHoles (tl,tr,bl,br,t,b,l,r,n) = n\n\nsolve :: String -> Int\nsolve = countHoles.construct\n\nmain = solve<$>getLine >>= print >> main\n```\n\n\n\u7d19\u3092\u305d\u306e\u307e\u307e\u8868\u73fe\u3059\u308b\u30f4\u30a1\u30fc\u30b8\u30e7\u30f3(Ver.1)\uff1a\n\n```hs:Fold_and_Cut.hs\nmodule Main where\nimport Control.Applicative\nimport Data.List\nimport Data.List.Split (splitOn)\n\ntype Cell = Bool\ntype Paper = [[Cell]]\ntype Fold = Char\n\nconstruct str = develop (cut b) (reverse a)\n  where [a,b] = splitOn \"-\" str \n\ncut str = case str of\n  \"tl\" ->[[False,True],[True,True]] \n  \"tr\" ->[[True,False],[True,True]] \n  \"bl\" ->[[True,True],[False,True]] \n  \"br\" ->[[True,True],[True,False]] \n\nufold :: Paper -> Fold -> Paper\nufold p f = case f of\n  'T' -> reverse p ++ p\n  'B' -> p ++ reverse p \n  'L' -> map (\\x -> reverse x ++ x) p\n  'R' -> map (\\x -> x ++ reverse x) p\n\ndevelop :: Paper -> [Fold] -> Paper\ndevelop p fs = foldl ufold p fs\n\nreduce :: Paper -> [[Cell]]\nreduce [x] = [map (const True) x]\nreduce (x:y:xs) = (zipWith (||) x y) : reduce (y:xs)\n\ncountHoles = length.filter (==False).concat.reduce.transpose.reduce\n\nsolve = countHoles.construct\n\nmain = solve<$>getLine >>= print >> main\n\n```\n\n\u7a74\u306e\u5ea7\u6a19\u3060\u3051\u3067\u7d19\u306e\u72b6\u614b\u3092\u8868\u73fe\u3059\u308b\u30f4\u30a1\u30fc\u30b8\u30e7\u30f3(Ver.2)\uff1a\n\n```hs:Fold_and_Cut_Bis.hs\nmodule Main where\nimport Control.Applicative\nimport Data.List\nimport Data.List.Split (splitOn)\n\ntype Position = (Int,Int)\ntype Paper = ((Int,Int),[Position])\ntype Fold = Char\n\nconstruct :: String -> Paper\nconstruct str = develop (cut b) (reverse a)\n  where [a,b] = splitOn \"-\" str \n\ncut :: String -> Paper\ncut str = case str of\n  \"tl\" -> ((2,2),[(0,0)])\n  \"tr\" -> ((2,2),[(1,0)])\n  \"bl\" -> ((2,2),[(0,1)])\n  \"br\" -> ((2,2),[(1,1)])\n\nufold :: Paper -> Fold -> Paper\nufold ((w,h),ps) c = case c of\n  'T' -> ((w,2*h), dup ps)\n           where dup = concat.map (\\(x,y) -> [(x,h+y),(x,h-y-1)])\n  'B' -> ((w,2*h), dup ps)\n           where dup = concat.map (\\(x,y) -> [(x,y),(x,2*h-y-1)])\n  'L' -> ((2*w, h), dup ps)\n           where dup = concat.map (\\(x,y) -> [(w+x,y),(w-x-1,y)])\n  'R' -> ((2*w, h), dup ps)\n           where dup = concat.map (\\(x,y) -> [(x,y),(2*w-x-1,y)])\n\ndevelop :: Paper -> [Fold] -> Paper\ndevelop p fs = foldl ufold p fs\n\ncountHoles :: Paper -> Int\ncountHoles p = length $ intersect poss $ map (\\(x,y) -> (x+1,y+1)) poss\n  where poss = snd p\n\nsolve = countHoles.construct\n\nmain = solve<$>getLine >>= print >> main\n```"}