{"context": " More than 1 year has passed since last update.\u4ee5\u4e0b\u306e2\u30a8\u30f3\u30c8\u30ea\u306e\u7d9a\u304d\u3082\u306e\u3002\n\nJedis\u30d1\u30a4\u30d7\u30e9\u30a4\u30f3\u51e6\u7406\u3092(\u7121\u7406\u3084\u308a)Redis Cluster\u5bfe\u5fdc\u3055\u305b\u308b\n\u7d9a\u30fbJedis\u30d1\u30a4\u30d7\u30e9\u30a4\u30f3\u51e6\u7406\u3092(\u7121\u7406\u3084\u308a)Redis Cluster\u5bfe\u5fdc\u3055\u305b\u308b\n\n\nredis.clients.jedis.Response \u306b\u3064\u3044\u3066\u304a\u3055\u3089\u3044\nJedis\u306e Pipeline \u3092\u4f7f\u3046\u3068\u3001get, set \u306a\u3069\u306e\u5404\u51e6\u7406\u306f Response \u306b\u5305\u307e\u308c\u305f\u8fd4\u308a\u5024\u3068\u3057\u3066\u53d6\u5f97\u3055\u308c\u3001sync \u5f8c\u306b get \u3059\u308b\u3053\u3068\u3067\u5b9f\u969b\u306e\u5024\u304c\u53d6\u5f97\u3055\u308c\u308b\u3002\nusing(new Jedis(\"192.168.53.52\", 6379)) { jedis =>\n  val p = jedis.pipelined()\n  val v2 = p.get(\"key2\")\n  val v3 = p.get(\"key3\")\n  p.sync()\n  println((v2.get, v3.get))\n}\n\nsync \u547c\u3073\u51fa\u3057\u524d\u306b get \u3057\u3088\u3046\u3068\u3059\u308b\u3068 JedisDataException: Please close pipeline or multi block before calling this method. \u304c\u767a\u751f\u3059\u308b\u3002\n\nClusteredPipeline \u30ea\u30d5\u30a1\u30af\u30bf\u30ea\u30f3\u30b0\u6848\n\u3055\u3066\u3001\u524d\u56de\u304b\u3089\u306e\u7d9a\u304d\u3067\u3001ClusteredPipeline \u306b\u5404\u8aad\u307f\u66f8\u304d\u30e1\u30bd\u30c3\u30c9\u306e\u8ffd\u52a0\u3092\u691c\u8a0e\u3059\u308b\u3002\n\u3053\u3093\u306a\u611f\u3058\u306b\u3057\u305f\u304b\u3063\u305f\u304c\u2026\npackage com.zaneli.redis.jedis\n\nimport org.apache.commons.pool2.impl.GenericObjectPoolConfig\nimport redis.clients.jedis.{HostAndPort, Jedis, JedisSlotBasedConnectionHandler, JedisPool, Pipeline, Response}\nimport redis.clients.util.JedisClusterCRC16\n\nimport scala.collection.JavaConversions._\nimport scala.collection.mutable\nimport scala.language.reflectiveCalls\nimport scala.util.Try\n\nclass ClusteredPipeline(nodes: Set[HostAndPort], config: GenericObjectPoolConfig, timeout: Int) extends AutoCloseable {\n\n  private[this] case class Connection(jedis: Jedis, pipeline: Pipeline)\n\n  private[this] val connections: mutable.Map[JedisPool, Connection] = mutable.Map.empty\n\n  private[this] val handler = new JedisSlotBasedConnectionHandler(nodes, config, timeout) {\n    def getSlotPool(slot: Int): JedisPool = {\n      cache.getSlotPool(slot)\n    }\n    def getConnection(pool: JedisPool): Jedis = {\n      if (pool != null) pool.getResource() else getConnection()\n    }\n  }\n\n  def get(key: String): Response[String] = {\n    exec(key)(_.get(key))\n  }\n\n  def set(key: String, value: String): Response[String] = {\n    exec(key)(_.set(key, value))\n  }\n\n  def lrange(key: String, start: Long, end: Long): Response[JList[String]] = {\n    exec(key)(_.lrange(key, start, end))\n  }\n\n  def hgetAll(key: String): Response[Map[String, String]] = {\n    exec(key)(_.hgetAll(key))\n  }\n\n  private[this] def exec[A](key: String)(cmd: Pipeline => Response[A]): Response[A] = {\n    val slot = JedisClusterCRC16.getSlot(key)\n    val pool = handler.getSlotPool(slot)\n    val pipeline = getPipeline(pool)\n    cmd(pipeline)\n  }\n\n  private[this] def getPipeline(pool: JedisPool): Pipeline = {\n    connections.get(pool).map(_.pipeline).getOrElse {\n      val j = handler.getConnection(pool)\n      val p = j.pipelined()\n      connections.put(pool, Connection(j, p))\n      p\n    }\n  }\n\n  def sync(): Unit = {\n    connections.values.foreach(_.pipeline.sync())\n  }\n\n  override def close(): Unit = {\n    connections.values.foreach(j => Try(j.jedis.close()))\n    connections.clear()\n  }\n}\n\n\u3053\u308c\u306f\u4ee5\u4e0b\u306e\u30b3\u30f3\u30d1\u30a4\u30eb\u30a8\u30e9\u30fc\u306b\u306a\u308b\u3002\n[error]  found   : redis.clients.jedis.Response[java.util.List[String]]\n[error]  required: redis.clients.jedis.Response[scala.collection.immutable.List[String]]\n[error]     exec(key)(_.lrange(key, start, end))\n[error]                       ^\n[error]  found   : redis.clients.jedis.Response[java.util.Map[String,String]]\n[error]  required: redis.clients.jedis.Response[scala.collection.immutable.Map[String,String]]\n[error]     exec(key)(_.hgetAll(key))\n[error]                        ^\n[error] two errors found\n\n\u4ed5\u65b9\u306a\u304f\u3001import java.util.{List => JList, Map => JMap} \u307f\u305f\u3044\u306a\u30a4\u30f3\u30dd\u30fc\u30c8\u3092\u8ffd\u52a0\u3057\u3066\u3001\ndef lrange(key: String, start: Long, end: Long): Response[JList[String]]\ndef hgetAll(key: String): Response[JMap[String, String]]\n\u3068\u3059\u308b\u3053\u3068\u3067\u30b3\u30f3\u30d1\u30a4\u30eb\u306f\u901a\u308b\u304c\u3001\u547c\u3073\u51fa\u3057\u5074\u3067Scala\u306e\u30b3\u30ec\u30af\u30b7\u30e7\u30f3\u306b\u5909\u63db\u3057\u305f\u308a\u30b4\u30cb\u30e7\u30b4\u30cb\u30e7\u3059\u308b\u306e\u3082\u4e0d\u4fbf\u306a\u306e\u3067\n\u3082\u3046\u5c11\u3057\u4f55\u3068\u304b\u3067\u304d\u306a\u3044\u3082\u306e\u304b\u3002\nFunctor\u306b\u3057\u3066\u3001map\u3067\u5024\u306e\u5909\u63db\u3092\u884c\u3048\u306a\u3044\u304b\u8a66\u307f\u308b\u3053\u3068\u306b\u3059\u308b\u3002\n\nscalaz.Functor \u306e\u5c0e\u5165\n\u3053\u3093\u306a package object \u3092\u4f5c\u308b\u3002\n\npackage.scala\npackage com.zaneli.redis\n\nimport redis.clients.jedis.{Builder, Response}\n\nimport scalaz.Functor\n\npackage object jedis {\n\n  implicit val responseFunctor = new Functor[Response] {\n    def map[A, B](fa: Response[A])(f: A => B): Response[B] = {\n      val r = new Response[B](new Builder[B] {\n        override def build(o: scala.Any): B = f(o.asInstanceOf[Response[A]].get)\n      })\n      r.set(fa)\n      r\n    }\n  }\n}\n\n\nClusteredPipeline \u306f\u3053\u3046\u306a\u308b\u3002\n\nClusteredPipeline.scala(\u4e00\u90e8\u629c\u7c8b)\n...\n\nimport scala.collection.JavaConversions._\n\n...\n\nclass ClusteredPipeline(nodes: Set[HostAndPort], config: GenericObjectPoolConfig, timeout: Int) extends AutoCloseable {\n\n  import scalaz.Scalaz._\n\n  ...\n\n  def lrange(key: String, start: Long, end: Long): Response[List[String]] = {\n    exec(key)(_.lrange(key, start, end).map(_.toList))\n  }\n\n  def hgetAll(key: String): Response[Map[String, String]] = {\n    exec(key)(_.hgetAll(key).map(_.toMap))\n  }\n\n  ...\n}\n\n\n\u3053\u308c\u3067Scala\u306e List, Map \u3068\u3057\u3066\u6271\u3046\u3053\u3068\u304c\u3067\u304d\u308b\u3002\n\u307e\u305f\u3001\u547c\u3073\u51fa\u3057\u5143\u3067\u3055\u3089\u306b\u5024\u3092\u52a0\u5de5\u3057\u305f\u3044\u5834\u5408\u306b\u3082 Option \u306a\u3069\u3067\u304a\u99b4\u67d3\u307f\u306e\u66f8\u304d\u65b9\u304c\u3067\u304d\u308b\u3002\n\nJedisTest5.scala\npackage com.zaneli.redis.jedis\n\nimport redis.clients.jedis.HostAndPort\n\nimport scala.util.{Failure, Success}\n\nobject JedisTest5 extends App {\n\n  import scalaz.Scalaz._\n\n  val nodes = Set(6379, 6380, 6381).map { port =>\n    new HostAndPort(\"192.168.53.52\", port)\n  }\n  val cluster = new JedisPipelinedCluster(nodes)\n  val result = cluster.pipelined { cp =>\n    val v1 = cp.get(\"key1\")\n    val v2 = cp.get(\"key2\")\n    val v3 = cp.get(\"key3\")\n    cp.sync()\n    List(v1, v2, v3).map(_.map(_ + \"!!\").get)\n  }\n  result match {\n    case Success(xs) => xs.foreach(println) // \u300cvalue1!!\u300d\u300cvalue2!!\u300d\u300cvalue3!!\u300d\u51fa\u529b\n    case Failure(e) => e.printStackTrace()\n  }\n}\n\n\n\nscalaz.Monad \u306e\u5c0e\u5165\npackage object \u306e\u5b9a\u7fa9\u3092\u3053\u306e\u3088\u3046\u306b\u5909\u66f4\u3002\n\npackage.scala\npackage com.zaneli.redis\n\nimport redis.clients.jedis.{Builder, Response}\n\nimport scalaz.Monad\n\npackage object jedis {\n\n  implicit val responseMonad = new Monad[Response] {\n    override def point[A](a: => A): Response[A] = {\n      val r = new Response(new Builder[A] {\n        override def build(o: scala.Any): A = o.asInstanceOf[A]\n      })\n      r.set(a)\n      r\n    }\n\n    override def bind[A, B](fa: Response[A])(f: A => Response[B]): Response[B] = {\n      val r = new Response[B](new Builder[B] {\n        override def build(o: scala.Any): B = f(o.asInstanceOf[Response[A]].get).get\n      })\n      r.set(fa)\n      r\n    }\n  }\n}\n\n\n\u3053\u308c\u3067 for {...} yield {...} \u306e\u4e2d\u3067\u4f7f\u3048\u308b\u3002\n\nJedisTest6.scala\npackage com.zaneli.redis.jedis\n\nimport redis.clients.jedis.HostAndPort\n\nimport scala.util.{Failure, Success}\n\nobject JedisTest6 extends App {\n\n  import scalaz.Scalaz._\n\n  val nodes = Set(6379, 6380, 6381).map { port =>\n    new HostAndPort(\"192.168.53.52\", port)\n  }\n  val cluster = new JedisPipelinedCluster(nodes)\n  val result = cluster.pipelined { cp =>\n    val r1 = cp.get(\"key1\")\n    val r2 = cp.get(\"key2\")\n    val r3 = cp.get(\"key3\")\n    cp.sync()\n    val r = for {\n      v1 <- r1\n      v2 <- r2\n      v3 <- r3\n    } yield {\n      v1 + v2 + v3\n    }\n    r.get\n  }\n  result match {\n    case Success(x) => println(x) // \u300cvalue1value2value3\u300d\u51fa\u529b\n    case Failure(e) => e.printStackTrace()\n  }\n}\n\n\nList \u306e Response \u3092 Response \u306e List \u306b\u3067\u304d\u308b\u3002\n\nJedisTest7.scala\npackage com.zaneli.redis.jedis\n\nimport redis.clients.jedis.HostAndPort\n\nobject JedisTest7 extends App {\n\n  import scalaz.Scalaz._\n\n  val nodes = Set(6379, 6380, 6381).map { port =>\n    new HostAndPort(\"192.168.53.52\", port)\n  }\n  val cluster = new JedisPipelinedCluster(nodes)\n  val result = cluster.pipelined { cp =>\n    val r1 = cp.get(\"key1\")\n    val r2 = cp.get(\"key2\")\n    val r3 = cp.get(\"key3\")\n    cp.sync()\n    responseMonad.sequence(List(r1, r2, r3)).get()\n  }\n  result match {\n    case scala.util.Success(x) => println(x) // \u300cList(value1, value2, value3)\u300d\u51fa\u529b\n    case scala.util.Failure(e) => e.printStackTrace()\n  }\n}\n\n\n\u4ee5\u4e0b\u306e2\u30a8\u30f3\u30c8\u30ea\u306e\u7d9a\u304d\u3082\u306e\u3002\n\n* [Jedis\u30d1\u30a4\u30d7\u30e9\u30a4\u30f3\u51e6\u7406\u3092(\u7121\u7406\u3084\u308a)Redis Cluster\u5bfe\u5fdc\u3055\u305b\u308b](http://qiita.com/zaneli@github/items/c5adce0abc374bbc5b2f)\n* [\u7d9a\u30fbJedis\u30d1\u30a4\u30d7\u30e9\u30a4\u30f3\u51e6\u7406\u3092(\u7121\u7406\u3084\u308a)Redis Cluster\u5bfe\u5fdc\u3055\u305b\u308b](http://qiita.com/zaneli@github/items/6cb8d4e0b16621e2e1b7)\n\n### redis.clients.jedis.Response \u306b\u3064\u3044\u3066\u304a\u3055\u3089\u3044\n\nJedis\u306e [`Pipeline`](https://github.com/xetorthio/jedis/blob/8a45aa30a6277ee37f706c339024e4411da5c7d8/src/main/java/redis/clients/jedis/Pipeline.java) \u3092\u4f7f\u3046\u3068\u3001`get`, `set` \u306a\u3069\u306e\u5404\u51e6\u7406\u306f [`Response`](https://github.com/xetorthio/jedis/blob/8a45aa30a6277ee37f706c339024e4411da5c7d8/src/main/java/redis/clients/jedis/Response.java) \u306b\u5305\u307e\u308c\u305f\u8fd4\u308a\u5024\u3068\u3057\u3066\u53d6\u5f97\u3055\u308c\u3001`sync` \u5f8c\u306b `get` \u3059\u308b\u3053\u3068\u3067\u5b9f\u969b\u306e\u5024\u304c\u53d6\u5f97\u3055\u308c\u308b\u3002\n\n```scala\nusing(new Jedis(\"192.168.53.52\", 6379)) { jedis =>\n  val p = jedis.pipelined()\n  val v2 = p.get(\"key2\")\n  val v3 = p.get(\"key3\")\n  p.sync()\n  println((v2.get, v3.get))\n}\n```\n\n`sync` \u547c\u3073\u51fa\u3057\u524d\u306b `get` \u3057\u3088\u3046\u3068\u3059\u308b\u3068 `JedisDataException: Please close pipeline or multi block before calling this method.` \u304c\u767a\u751f\u3059\u308b\u3002\n\n### ClusteredPipeline \u30ea\u30d5\u30a1\u30af\u30bf\u30ea\u30f3\u30b0\u6848\n\n\u3055\u3066\u3001[\u524d\u56de](http://qiita.com/zaneli@github/items/6cb8d4e0b16621e2e1b7)\u304b\u3089\u306e\u7d9a\u304d\u3067\u3001`ClusteredPipeline` \u306b\u5404\u8aad\u307f\u66f8\u304d\u30e1\u30bd\u30c3\u30c9\u306e\u8ffd\u52a0\u3092\u691c\u8a0e\u3059\u308b\u3002\n\u3053\u3093\u306a\u611f\u3058\u306b\u3057\u305f\u304b\u3063\u305f\u304c\u2026\n\n```\npackage com.zaneli.redis.jedis\n\nimport org.apache.commons.pool2.impl.GenericObjectPoolConfig\nimport redis.clients.jedis.{HostAndPort, Jedis, JedisSlotBasedConnectionHandler, JedisPool, Pipeline, Response}\nimport redis.clients.util.JedisClusterCRC16\n\nimport scala.collection.JavaConversions._\nimport scala.collection.mutable\nimport scala.language.reflectiveCalls\nimport scala.util.Try\n\nclass ClusteredPipeline(nodes: Set[HostAndPort], config: GenericObjectPoolConfig, timeout: Int) extends AutoCloseable {\n\n  private[this] case class Connection(jedis: Jedis, pipeline: Pipeline)\n\n  private[this] val connections: mutable.Map[JedisPool, Connection] = mutable.Map.empty\n\n  private[this] val handler = new JedisSlotBasedConnectionHandler(nodes, config, timeout) {\n    def getSlotPool(slot: Int): JedisPool = {\n      cache.getSlotPool(slot)\n    }\n    def getConnection(pool: JedisPool): Jedis = {\n      if (pool != null) pool.getResource() else getConnection()\n    }\n  }\n\n  def get(key: String): Response[String] = {\n    exec(key)(_.get(key))\n  }\n\n  def set(key: String, value: String): Response[String] = {\n    exec(key)(_.set(key, value))\n  }\n\n  def lrange(key: String, start: Long, end: Long): Response[JList[String]] = {\n    exec(key)(_.lrange(key, start, end))\n  }\n\n  def hgetAll(key: String): Response[Map[String, String]] = {\n    exec(key)(_.hgetAll(key))\n  }\n\n  private[this] def exec[A](key: String)(cmd: Pipeline => Response[A]): Response[A] = {\n    val slot = JedisClusterCRC16.getSlot(key)\n    val pool = handler.getSlotPool(slot)\n    val pipeline = getPipeline(pool)\n    cmd(pipeline)\n  }\n\n  private[this] def getPipeline(pool: JedisPool): Pipeline = {\n    connections.get(pool).map(_.pipeline).getOrElse {\n      val j = handler.getConnection(pool)\n      val p = j.pipelined()\n      connections.put(pool, Connection(j, p))\n      p\n    }\n  }\n\n  def sync(): Unit = {\n    connections.values.foreach(_.pipeline.sync())\n  }\n\n  override def close(): Unit = {\n    connections.values.foreach(j => Try(j.jedis.close()))\n    connections.clear()\n  }\n}\n```\n\n\u3053\u308c\u306f\u4ee5\u4e0b\u306e\u30b3\u30f3\u30d1\u30a4\u30eb\u30a8\u30e9\u30fc\u306b\u306a\u308b\u3002\n\n```\n[error]  found   : redis.clients.jedis.Response[java.util.List[String]]\n[error]  required: redis.clients.jedis.Response[scala.collection.immutable.List[String]]\n[error]     exec(key)(_.lrange(key, start, end))\n[error]                       ^\n[error]  found   : redis.clients.jedis.Response[java.util.Map[String,String]]\n[error]  required: redis.clients.jedis.Response[scala.collection.immutable.Map[String,String]]\n[error]     exec(key)(_.hgetAll(key))\n[error]                        ^\n[error] two errors found\n```\n\n\u4ed5\u65b9\u306a\u304f\u3001`import java.util.{List => JList, Map => JMap}` \u307f\u305f\u3044\u306a\u30a4\u30f3\u30dd\u30fc\u30c8\u3092\u8ffd\u52a0\u3057\u3066\u3001\n`def lrange(key: String, start: Long, end: Long): Response[JList[String]]`\n`def hgetAll(key: String): Response[JMap[String, String]]`\n\u3068\u3059\u308b\u3053\u3068\u3067\u30b3\u30f3\u30d1\u30a4\u30eb\u306f\u901a\u308b\u304c\u3001\u547c\u3073\u51fa\u3057\u5074\u3067Scala\u306e\u30b3\u30ec\u30af\u30b7\u30e7\u30f3\u306b\u5909\u63db\u3057\u305f\u308a\u30b4\u30cb\u30e7\u30b4\u30cb\u30e7\u3059\u308b\u306e\u3082\u4e0d\u4fbf\u306a\u306e\u3067\n\u3082\u3046\u5c11\u3057\u4f55\u3068\u304b\u3067\u304d\u306a\u3044\u3082\u306e\u304b\u3002\n`Functor`\u306b\u3057\u3066\u3001`map`\u3067\u5024\u306e\u5909\u63db\u3092\u884c\u3048\u306a\u3044\u304b\u8a66\u307f\u308b\u3053\u3068\u306b\u3059\u308b\u3002\n\n### scalaz.Functor \u306e\u5c0e\u5165\n\n\u3053\u3093\u306a package object \u3092\u4f5c\u308b\u3002\n\n```scala:package.scala\npackage com.zaneli.redis\n\nimport redis.clients.jedis.{Builder, Response}\n\nimport scalaz.Functor\n\npackage object jedis {\n\n  implicit val responseFunctor = new Functor[Response] {\n    def map[A, B](fa: Response[A])(f: A => B): Response[B] = {\n      val r = new Response[B](new Builder[B] {\n        override def build(o: scala.Any): B = f(o.asInstanceOf[Response[A]].get)\n      })\n      r.set(fa)\n      r\n    }\n  }\n}\n```\n\n`ClusteredPipeline` \u306f\u3053\u3046\u306a\u308b\u3002\n\n```scala:ClusteredPipeline.scala(\u4e00\u90e8\u629c\u7c8b)\n...\n\nimport scala.collection.JavaConversions._\n\n...\n\nclass ClusteredPipeline(nodes: Set[HostAndPort], config: GenericObjectPoolConfig, timeout: Int) extends AutoCloseable {\n\n  import scalaz.Scalaz._\n\n  ...\n\n  def lrange(key: String, start: Long, end: Long): Response[List[String]] = {\n    exec(key)(_.lrange(key, start, end).map(_.toList))\n  }\n\n  def hgetAll(key: String): Response[Map[String, String]] = {\n    exec(key)(_.hgetAll(key).map(_.toMap))\n  }\n\n  ...\n}\n```\n\n\u3053\u308c\u3067Scala\u306e `List`, `Map` \u3068\u3057\u3066\u6271\u3046\u3053\u3068\u304c\u3067\u304d\u308b\u3002\n\u307e\u305f\u3001\u547c\u3073\u51fa\u3057\u5143\u3067\u3055\u3089\u306b\u5024\u3092\u52a0\u5de5\u3057\u305f\u3044\u5834\u5408\u306b\u3082 `Option` \u306a\u3069\u3067\u304a\u99b4\u67d3\u307f\u306e\u66f8\u304d\u65b9\u304c\u3067\u304d\u308b\u3002\n\n```scala:JedisTest5.scala\npackage com.zaneli.redis.jedis\n\nimport redis.clients.jedis.HostAndPort\n\nimport scala.util.{Failure, Success}\n\nobject JedisTest5 extends App {\n\n  import scalaz.Scalaz._\n\n  val nodes = Set(6379, 6380, 6381).map { port =>\n    new HostAndPort(\"192.168.53.52\", port)\n  }\n  val cluster = new JedisPipelinedCluster(nodes)\n  val result = cluster.pipelined { cp =>\n    val v1 = cp.get(\"key1\")\n    val v2 = cp.get(\"key2\")\n    val v3 = cp.get(\"key3\")\n    cp.sync()\n    List(v1, v2, v3).map(_.map(_ + \"!!\").get)\n  }\n  result match {\n    case Success(xs) => xs.foreach(println) // \u300cvalue1!!\u300d\u300cvalue2!!\u300d\u300cvalue3!!\u300d\u51fa\u529b\n    case Failure(e) => e.printStackTrace()\n  }\n}\n```\n\n### scalaz.Monad \u306e\u5c0e\u5165\n\npackage object \u306e\u5b9a\u7fa9\u3092\u3053\u306e\u3088\u3046\u306b\u5909\u66f4\u3002\n\n```scala:package.scala\npackage com.zaneli.redis\n\nimport redis.clients.jedis.{Builder, Response}\n\nimport scalaz.Monad\n\npackage object jedis {\n\n  implicit val responseMonad = new Monad[Response] {\n    override def point[A](a: => A): Response[A] = {\n      val r = new Response(new Builder[A] {\n        override def build(o: scala.Any): A = o.asInstanceOf[A]\n      })\n      r.set(a)\n      r\n    }\n\n    override def bind[A, B](fa: Response[A])(f: A => Response[B]): Response[B] = {\n      val r = new Response[B](new Builder[B] {\n        override def build(o: scala.Any): B = f(o.asInstanceOf[Response[A]].get).get\n      })\n      r.set(fa)\n      r\n    }\n  }\n}\n```\n\n\u3053\u308c\u3067 `for {...} yield {...}` \u306e\u4e2d\u3067\u4f7f\u3048\u308b\u3002\n\n```scala:JedisTest6.scala\npackage com.zaneli.redis.jedis\n\nimport redis.clients.jedis.HostAndPort\n\nimport scala.util.{Failure, Success}\n\nobject JedisTest6 extends App {\n\n  import scalaz.Scalaz._\n\n  val nodes = Set(6379, 6380, 6381).map { port =>\n    new HostAndPort(\"192.168.53.52\", port)\n  }\n  val cluster = new JedisPipelinedCluster(nodes)\n  val result = cluster.pipelined { cp =>\n    val r1 = cp.get(\"key1\")\n    val r2 = cp.get(\"key2\")\n    val r3 = cp.get(\"key3\")\n    cp.sync()\n    val r = for {\n      v1 <- r1\n      v2 <- r2\n      v3 <- r3\n    } yield {\n      v1 + v2 + v3\n    }\n    r.get\n  }\n  result match {\n    case Success(x) => println(x) // \u300cvalue1value2value3\u300d\u51fa\u529b\n    case Failure(e) => e.printStackTrace()\n  }\n}\n```\n\n`List` \u306e `Response` \u3092 `Response` \u306e `List` \u306b\u3067\u304d\u308b\u3002\n\n```scala:JedisTest7.scala\npackage com.zaneli.redis.jedis\n\nimport redis.clients.jedis.HostAndPort\n\nobject JedisTest7 extends App {\n\n  import scalaz.Scalaz._\n\n  val nodes = Set(6379, 6380, 6381).map { port =>\n    new HostAndPort(\"192.168.53.52\", port)\n  }\n  val cluster = new JedisPipelinedCluster(nodes)\n  val result = cluster.pipelined { cp =>\n    val r1 = cp.get(\"key1\")\n    val r2 = cp.get(\"key2\")\n    val r3 = cp.get(\"key3\")\n    cp.sync()\n    responseMonad.sequence(List(r1, r2, r3)).get()\n  }\n  result match {\n    case scala.util.Success(x) => println(x) // \u300cList(value1, value2, value3)\u300d\u51fa\u529b\n    case scala.util.Failure(e) => e.printStackTrace()\n  }\n}\n```\n", "tags": ["Scala", "scalaz", "Redis", "Jedis"]}