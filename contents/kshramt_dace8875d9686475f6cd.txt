{"context": " More than 1 year has passed since last update.LANG=C make -p\u306b\u3088\u3063\u3066\u51fa\u529b\u3055\u308c\u305fMakefile\u306e\u30c7\u30fc\u30bf\u30d9\u30fc\u30b9\u3092\u30d1\u30fc\u30b9\u3057\u3066\uff0c\u4f9d\u5b58\u95a2\u4fc2\u3092DOT\u5f62\u5f0f\u3067\u51fa\u529b\u3057\u307e\u3059\uff0e\n\u518d\u5e30\u7684\u306amake\u306e\u547c\u3073\u51fa\u3057\u306b\u3082\u5bfe\u5fdc\u3057\u3066\u3044\u307e\u3059\uff0e\nGNU Make\u3092\u4eee\u5b9a\u3057\u3066\u3044\u307e\u3059\uff0e\nLANG=C make -p | python3 make_p_to_json.py | python3 json_to_dot.py | dot -Tpdf >| workflow.pdf\n\n\u306e\u3088\u3046\u306b\u5229\u7528\u3057\u307e\u3059\uff0e\n\u305f\u3068\u3048\u3070\uff0csjackman/uniqtag-paper\u306b\u9069\u7528\u3059\u308b\u3068\uff0c\u4ee5\u4e0b\u306e\u3088\u3046\u306aPDF\u304c\u5f97\u3089\u308c\u307e\u3059\uff0e\n\n\nmake_p_to_json.py\n\nMakefile\u306b\u8a18\u8ff0\u3055\u308c\u305f\u4f9d\u5b58\u95a2\u4fc2\u3092\n[{\"target1\": [\"dep1\", \"dep2\", ...], ...}, ...]\n\n\u3068\u3044\u3046\u69cb\u9020\u306eJSON\u5f62\u5f0f\u3067\u51fa\u529b\u3057\u307e\u3059\uff0e\n\u4e00\u756a\u5916\u5074\u306e\u914d\u5217\u306e\u5404\u8981\u7d20\u306f\uff0cmake\u3092\u518d\u5e30\u7684\u306b\u547c\u3073\u51fa\u3057\u3066\u3044\u308b\u5834\u5408\u306b\u5bfe\u5fdc\u3057\u307e\u3059\uff0e\nLANG=C make -p | python3 make_p_to_json.py > graph.json\n\n\u306e\u69d8\u306b\u5229\u7528\u3057\u307e\u3059\uff0e\n#!/usr/bin/python\n\nimport sys\nimport json\nimport re\n\n\ndef main(args):\n    _parse_args(args)\n    json.dump(parse_make_p(sys.stdin), sys.stdout)\n\n\ndef parse_make_p(fp, graphs=None):\n    if graphs is None:\n        graphs = []\n    for l in fp:\n        if l.startswith('# Make data base, printed on '):\n            graphs.append(_parse_db(fp))\n    if not graphs:\n        raise ValueError(\"{} seems not connected to `LANG=C make -p`\".format(fp))\n    return graphs\n\n\ndef _parse_db(fp):\n    for l in fp:\n        if l.startswith('# Files'):\n            fp.readline() # skip the first empty line\n            return _parse_entries(fp)\n    return {}\n\n\ndef _parse_entries(fp):\n    deps_graph = {}\n    for l in fp:\n        if l.startswith('# files hash-table stats:'):\n            return deps_graph\n        elif l.startswith('# Not a target:'):\n            _skip_until_next_entry(fp)\n        elif l.startswith(\"# makefile (from '\"):\n            fp.readline() # skip information on target specific variable value\n        else:\n            _parse_entry(l, deps_graph)\n            _skip_until_next_entry(fp)\n    return deps_graph\n\n\n\nTARGET_SPLIT_REGEX = re.compile(r':{1,2} *')\ndef _parse_entry(l, deps_graph):\n    target, deps = TARGET_SPLIT_REGEX.split(l, 1)\n    deps_graph[target] = [dep for dep in deps.split() if dep != '|']\n\n\ndef _skip_until_next_entry(fp):\n    for l in fp:\n        if _is_new_entry(l):\n            return\n\n\ndef _is_new_entry(s):\n    return s.startswith('\\n')\n\n\ndef _parse_args(args):\n    if len(args) != 1:\n        print(\"# parse Makefile's database and print dependency graph in JSON format\")\n        print(\"LANG=C gmake -p | {} | json_to_dot.py | dot -Tpdf >| workflow.pdf\".format(args[0]))\n        sys.exit(1)\n\n\nif __name__ == '__main__':\n    main(sys.argv)\n\n\njson_to_dot.py\n\nmake_p_to_json.py\u304c\u51fa\u529b\u3057\u305fJSON\u3092DOT\u5f62\u5f0f\u306b\u5909\u63db\u3057\u307e\u3059\uff0e\npython3 json_to_dot.py < graph.json | dot -Tpdf > workflow.pdf\n\n\u306e\u69d8\u306b\u5229\u7528\u3057\u307e\u3059\uff0e\n#!/usr/bin/python\n\nimport sys\nimport json\n\n\nclass Id(object):\n\n    def __init__(self):\n        super().__init__()\n        self._i = 0\n\n    @property\n    def i(self):\n        self._i += 1\n        return self._i\n\n\ndef main(args):\n    _parse_args(args)\n    print(\"\"\"\ndigraph G {\n   graph [rankdir=LR]\n   node [shape=plaintext]\n    edge [color=\"#00000088\"]\n    \"\"\")\n    i = Id()\n    for graph in json.load(sys.stdin):\n        print_single_graph(graph, i)\n    print(\"}\")\n\n\ndef print_single_graph(graph, i):\n    name_to_node = {}\n    print(\"subgraph cluster{}{{\".format(i.i))\n    for target, deps in graph.items():\n        target_str = _escape(target)\n        _register_node(target_str, i, name_to_node)\n        target_node = name_to_node[target_str]\n        for dep_str in (_escape(dep) for dep in deps):\n            _register_node(dep_str, i, name_to_node)\n            print('{} -> {}'.format(target_node, name_to_node[dep_str]))\n    print(\"}\")\n\n\ndef _register_node(name, i, name_to_node):\n    if not (name in name_to_node):\n        node = 'n{}'.format(i.i)\n        name_to_node[name] = node\n        print('{}[label={}]'.format(node, name))\n\n\ndef _escape(s):\n    return '\"{}\"'.format(s.replace('\"', r'\\\"'))\n\n\ndef _parse_args(args):\n    if len(args) != 1:\n        print('# convert a dependency graph stored in JSON format to DOT format')\n        print('{} < deps.json | dot -Tpdf >| workflow.pdf'.format(args[0]))\n        sys.exit(1)\n\n\nif __name__ == '__main__':\n    main(sys.argv)\n\n\n\u5fc5\u8981\u306a\u3082\u306e\n\nGNU Make\nPython 3\nGraphviz\n\n\nLicense\nGPL version 3.\n`LANG=C make -p`\u306b\u3088\u3063\u3066\u51fa\u529b\u3055\u308c\u305f`Makefile`\u306e\u30c7\u30fc\u30bf\u30d9\u30fc\u30b9\u3092\u30d1\u30fc\u30b9\u3057\u3066\uff0c\u4f9d\u5b58\u95a2\u4fc2\u3092DOT\u5f62\u5f0f\u3067\u51fa\u529b\u3057\u307e\u3059\uff0e\n\u518d\u5e30\u7684\u306a`make`\u306e\u547c\u3073\u51fa\u3057\u306b\u3082\u5bfe\u5fdc\u3057\u3066\u3044\u307e\u3059\uff0e\nGNU Make\u3092\u4eee\u5b9a\u3057\u3066\u3044\u307e\u3059\uff0e\n\n```bash\nLANG=C make -p | python3 make_p_to_json.py | python3 json_to_dot.py | dot -Tpdf >| workflow.pdf\n```\n\n\u306e\u3088\u3046\u306b\u5229\u7528\u3057\u307e\u3059\uff0e\n\u305f\u3068\u3048\u3070\uff0c[sjackman/uniqtag-paper](https://github.com/sjackman/uniqtag-paper)\u306b\u9069\u7528\u3059\u308b\u3068\uff0c\u4ee5\u4e0b\u306e\u3088\u3046\u306aPDF\u304c\u5f97\u3089\u308c\u307e\u3059\uff0e\n\n![workflow.png](https://qiita-image-store.s3.amazonaws.com/0/8802/a0f05473-f84e-20a0-75b8-94033115f1c9.png)\n\n## `make_p_to_json.py`\n\n`Makefile`\u306b\u8a18\u8ff0\u3055\u308c\u305f\u4f9d\u5b58\u95a2\u4fc2\u3092\n\n```json\n[{\"target1\": [\"dep1\", \"dep2\", ...], ...}, ...]\n```\n\n\u3068\u3044\u3046\u69cb\u9020\u306eJSON\u5f62\u5f0f\u3067\u51fa\u529b\u3057\u307e\u3059\uff0e\n\u4e00\u756a\u5916\u5074\u306e\u914d\u5217\u306e\u5404\u8981\u7d20\u306f\uff0c`make`\u3092\u518d\u5e30\u7684\u306b\u547c\u3073\u51fa\u3057\u3066\u3044\u308b\u5834\u5408\u306b\u5bfe\u5fdc\u3057\u307e\u3059\uff0e\n\n```bash\nLANG=C make -p | python3 make_p_to_json.py > graph.json\n```\n\n\u306e\u69d8\u306b\u5229\u7528\u3057\u307e\u3059\uff0e\n\n```py3\n#!/usr/bin/python\n\nimport sys\nimport json\nimport re\n\n\ndef main(args):\n    _parse_args(args)\n    json.dump(parse_make_p(sys.stdin), sys.stdout)\n\n\ndef parse_make_p(fp, graphs=None):\n    if graphs is None:\n        graphs = []\n    for l in fp:\n        if l.startswith('# Make data base, printed on '):\n            graphs.append(_parse_db(fp))\n    if not graphs:\n        raise ValueError(\"{} seems not connected to `LANG=C make -p`\".format(fp))\n    return graphs\n\n\ndef _parse_db(fp):\n    for l in fp:\n        if l.startswith('# Files'):\n            fp.readline() # skip the first empty line\n            return _parse_entries(fp)\n    return {}\n\n\ndef _parse_entries(fp):\n    deps_graph = {}\n    for l in fp:\n        if l.startswith('# files hash-table stats:'):\n            return deps_graph\n        elif l.startswith('# Not a target:'):\n            _skip_until_next_entry(fp)\n        elif l.startswith(\"# makefile (from '\"):\n            fp.readline() # skip information on target specific variable value\n        else:\n            _parse_entry(l, deps_graph)\n            _skip_until_next_entry(fp)\n    return deps_graph\n\n\n\nTARGET_SPLIT_REGEX = re.compile(r':{1,2} *')\ndef _parse_entry(l, deps_graph):\n    target, deps = TARGET_SPLIT_REGEX.split(l, 1)\n    deps_graph[target] = [dep for dep in deps.split() if dep != '|']\n\n\ndef _skip_until_next_entry(fp):\n    for l in fp:\n        if _is_new_entry(l):\n            return\n\n\ndef _is_new_entry(s):\n    return s.startswith('\\n')\n\n\ndef _parse_args(args):\n    if len(args) != 1:\n        print(\"# parse Makefile's database and print dependency graph in JSON format\")\n        print(\"LANG=C gmake -p | {} | json_to_dot.py | dot -Tpdf >| workflow.pdf\".format(args[0]))\n        sys.exit(1)\n\n\nif __name__ == '__main__':\n    main(sys.argv)\n```\n\n## `json_to_dot.py`\n\n`make_p_to_json.py`\u304c\u51fa\u529b\u3057\u305fJSON\u3092DOT\u5f62\u5f0f\u306b\u5909\u63db\u3057\u307e\u3059\uff0e\n\n```bash\npython3 json_to_dot.py < graph.json | dot -Tpdf > workflow.pdf\n```\n\n\u306e\u69d8\u306b\u5229\u7528\u3057\u307e\u3059\uff0e\n\n```py3\n#!/usr/bin/python\n\nimport sys\nimport json\n\n\nclass Id(object):\n\n    def __init__(self):\n        super().__init__()\n        self._i = 0\n\n    @property\n    def i(self):\n        self._i += 1\n        return self._i\n\n\ndef main(args):\n    _parse_args(args)\n    print(\"\"\"\ndigraph G {\n   graph [rankdir=LR]\n   node [shape=plaintext]\n    edge [color=\"#00000088\"]\n    \"\"\")\n    i = Id()\n    for graph in json.load(sys.stdin):\n        print_single_graph(graph, i)\n    print(\"}\")\n\n\ndef print_single_graph(graph, i):\n    name_to_node = {}\n    print(\"subgraph cluster{}{{\".format(i.i))\n    for target, deps in graph.items():\n        target_str = _escape(target)\n        _register_node(target_str, i, name_to_node)\n        target_node = name_to_node[target_str]\n        for dep_str in (_escape(dep) for dep in deps):\n            _register_node(dep_str, i, name_to_node)\n            print('{} -> {}'.format(target_node, name_to_node[dep_str]))\n    print(\"}\")\n\n\ndef _register_node(name, i, name_to_node):\n    if not (name in name_to_node):\n        node = 'n{}'.format(i.i)\n        name_to_node[name] = node\n        print('{}[label={}]'.format(node, name))\n\n\ndef _escape(s):\n    return '\"{}\"'.format(s.replace('\"', r'\\\"'))\n\n\ndef _parse_args(args):\n    if len(args) != 1:\n        print('# convert a dependency graph stored in JSON format to DOT format')\n        print('{} < deps.json | dot -Tpdf >| workflow.pdf'.format(args[0]))\n        sys.exit(1)\n\n\nif __name__ == '__main__':\n    main(sys.argv)\n```\n\n## \u5fc5\u8981\u306a\u3082\u306e\n\n- GNU Make\n- Python 3\n- Graphviz\n\n## License\n\nGPL version 3.\n", "tags": ["Makefile"]}