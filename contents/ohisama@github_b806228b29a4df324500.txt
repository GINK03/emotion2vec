{"context": " More than 1 year has passed since last update.\n\n.NET Framework \u30a2\u30bb\u30f3\u30d6\u30e9 \u30ea\u30d5\u30a1\u30ec\u30f3\u30b9\nadd                     Add two values, returning a new value\nadd.ovf                 Add signed integer values with overflow check\nadd.ovf.un              Add unsigned integer values with overflow check\nand                     Bitwise AND of two integral values, returns an integral value\narglist                 Return argument list handle for the current method\nbeq <int32 (target)>    Branch to target if equal\nbeq.s <int8 (target)>   Branch to target if equal, short form\nbge <int32 (target)>    Branch to target if greater than or equal to\nbge.s <int8 (target)>   Branch to target if greater than or equal to, short form\nbge.un <int32 (target)> Branch to target if greater than or equal to (unsigned or unordered)\nbge.un.s <int8 (target)>Branch to target if greater than or equal to (unsigned or unordered), short form\nbgt <int32 (target)>    Branch to target if greater than\nbgt.s <int8 (target)>   Branch to target if greater than, short form\nbgt.un <int32 (target)> Branch to target if greater than (unsigned or unordered)\nbgt.un.s <int8 (target)>Branch to target if greater than (unsigned or unordered), short form\nble <int32 (target)>    Branch to target if less than or equal to\nble.s <int8 (target)>   Branch to target if less than or equal to, short form\nble.un <int32 (target)> Branch to target if less than or equal to (unsigned or unordered)\nble.un.s <int8 (target)>Branch to target if less than or equal to (unsigned or unordered), short form\nblt <int32 (target)>    Branch to target if less than\nblt.s <int8 (target)>   Branch to target if less than, short form\nblt.un <int32 (target)> Branch to target if less than (unsigned or unordered)\nblt.un.s <int8 (target)>Branch to target if less than (unsigned or unordered), short form\nbne.un <int32 (target)> Branch to target if unequal or unordered\nbne.un.s <int8 (target)>Branch to target if unequal or unordered, short form\nbox <typeTok>           Convert a boxable value to its boxed form\nbr <int32 (target)>     Branch to target\nbr.s <int8 (target)>    Branch to target, short form\nbreak                   Inform a debugger that a breakpoint has been reached\nbrfalse <int32 (target)>Branch to target if value is zero (false)\nbrfalse.s <int8 (target)>Branch to target if value is zero (false), short form\nbrinst <int32 (target)> Branch to target if value is a non-null object reference (alias for brtrue)\nbrinst.s <int8 (target)>Branch to target if value is a non-null object reference, short form (alias for brtrue.s)\nbrnull <int32 (target)> Branch to target if value is null (alias for brfalse)\nbrnull.s <int8 (target)>Branch to target if value is null (alias for brfalse.s), short form\nbrtrue <int32 (target)> Branch to target if value is non-zero (true)\nbrtrue.s <int8 (target)>Branch to target if value is non-zero (true), short form\nbrzero <int32 (target)> Branch to target if value is zero (alias for brfalse)\nbrzero.s <int8 (target)>Branch to target if value is zero (alias for brfalse.s), short form\ncall <method>           Call method described by method\ncalli <callsitedescr>   Call method indicated on the stack with arguments described by callsitedescr\ncallvirt <method>       Call a method associated with an object\ncastclass <class>       Cast obj to class\nceq                     Push 1 (of type int32) if value1 equals value2, else push 0\ncgt                     Push 1 (of type int32) if value1 > value2, else push 0. \ncgt.un                  Push 1 (of type int32) if value1 > value2, unsigned or unordered, else push 0\nckfinite                Throw ArithmeticException if value is not a finite number\nclt                     Push 1 (of type int32) if value1 < value2, else push 0\nclt.un                  Push 1 (of type int32) if value1 < value2, unsigned or unordered, else push 0\nconstrained. <thisType> Call a virtual method on a type constrained to be type T\nconv.i                  Convert to native int, pushing native int on stack\nconv.i1                 Convert to int8, pushing int32 on stack\nconv.i2                 Convert to int16, pushing int32 on stack\nconv.i4                 Convert to int32, pushing int32 on stack\nconv.i8                 Convert to int64, pushing int64 on stack\nconv.ovf.i              Convert to a native int (on the stack as native int) and throw an exception on overflow\nconv.ovf.i.un           Convert unsigned to a native int (on the stack as native int) and throw an exception on overflow\nconv.ovf.i1             Convert to an int8 (on the stack as int32) and throw an exception on overflow\nconv.ovf.i1.un          Convert unsigned to an int8 (on the stack as int32) and throw an exception on overflow\nconv.ovf.i2             Convert to an int16 (on the stack as int32) and throw an exception on overflow\nconv.ovf.i2.un          Convert unsigned to an int16 (on the stack as int32) and throw an exception on overflow\nconv.ovf.i4             Convert to an int32 (on the stack as int32) and throw an exception on overflow\nconv.ovf.i4.un          Convert unsigned to an int32 (on the stack as int32) and throw an exception on overflow\nconv.ovf.i8             Convert to an int64 (on the stack as int64) and throw an exception on overflow\nconv.ovf.i8.un          Convert unsigned to an int64 (on the stack as int64) and throw an exception on overflow\nconv.ovf.u              Convert to a native unsigned int (on the stack as native int) and throw an exception on overflow\nconv.ovf.u.un           Convert unsigned to a native unsigned int (on the stack as native int) and throw an exception on overflow\nconv.ovf.u1             Convert to an unsigned int8 (on the stack as int32) and throw an exception on overflow\nconv.ovf.u1.un          Convert unsigned to an unsigned int8 (on the stack as int32) and throw an exception on overflow\nconv.ovf.u2             Convert to an unsigned int16 (on the stack as int32) and throw an exception on overflow\nconv.ovf.u2.un          Convert unsigned to an unsigned int16 (on the stack as int32) and throw an exception on overflow\nconv.ovf.u4             Convert to an unsigned int32 (on the stack as int32) and throw an exception on overflow\nconv.ovf.u4.un          Convert unsigned to an unsigned int32 (on the stack as int32) and throw an exception on overflow\nconv.ovf.u8             Convert to an unsigned int64 (on the stack as int64) and throw an exception on overflow\nconv.ovf.u8.un          Convert unsigned to an unsigned int64 (on the stack as int64) and throw an exception on overflow\nconv.r.un               Convert unsigned integer to floating-point, pushing F on stack\nconv.r4                 Convert to float32, pushing F on stack\nconv.r8                 Convert to float64, pushing F on stack\nconv.u                  Convert to native unsigned int, pushing native int on stack\nconv.u1                 Convert to unsigned int8, pushing int32 on stack\nconv.u2                 Convert to unsigned int16, pushing int32 on stack\nconv.u4                 Convert to unsigned int32, pushing int32 on stack\nconv.u8                 Convert to unsigned int64, pushing int64 on stack\ncpblk                   Copy data from memory to memory\ncpobj <typeTok>         Copy a value type from src to dest\ndiv                     Divide two values to return a quotient or floating-point result\ndiv.un                  Divide two values, unsigned, returning a quotient\ndup                     Duplicate the value on the top of the stack\nendfault                End fault clause of an exception block\nendfilter               End an exception handling filter clause\nendfinally              End finally clause of an exception block\ninitblk                 Set all bytes in a block of memory to a given byte value\ninitobj <typeTok>       Initialize the value at address dest\nisinst <class>          Test if obj is an instance of class, returning null or an instance of that class or interface\njmp <method>            Exit current method and jump to the specified method\nldarg <uint16 (num)>    Load argument numbered num onto the stack\nldarg.0                 Load argument 0 onto the stack\nldarg.1                 Load argument 1 onto the stack\nldarg.2                 Load argument 2 onto the stack\nldarg.3                 Load argument 3 onto the stack\nldarg.s <uint8 (num)>   Load argument numbered num onto the stack, short form\nldarga <uint16 (argNum)>Fetch the address of argument argNum\nldarga.s <uint8 (argNum)>Fetch the address of argument argNum, short form\nldc.i4 <int32 (num)>    Push num of type int32 onto the stack as int32\nldc.i4.0                Push 0 onto the stack as int32\nldc.i4.1                Push 1 onto the stack as int32\nldc.i4.2                Push 2 onto the stack as int32\nldc.i4.3                Push 3 onto the stack as int32\nldc.i4.4                Push 4 onto the stack as int32\nldc.i4.5                Push 5 onto the stack as int32\nldc.i4.6                Push 6 onto the stack as int32\nldc.i4.7                Push 7 onto the stack as int32\nldc.i4.8                Push 8 onto the stack as int32\nldc.i4.m1               Push -1 onto the stack as int32\nldc.i4.M1               Push -1 of type int32 onto the stack as int32 (alias for ldc.i4.m1)\nldc.i4.s <int8 (num)>   Push num onto the stack as int32, short form\nldc.i8 <int64 (num)>    Push num of type int64 onto the stack as int64\nldc.r4 <float32 (num)>  Push num of type float32 onto the stack as F\nldc.r8 <float64 (num)>  Push num of type float64 onto the stack as F\nldelem <typeTok>        Load the element at index onto the top of the stack\nldelem.i                Load the element with type native int at index onto the top of the stack as a native int\nldelem.i1               Load the element with type int8 at index onto the top of the stack as an int32\nldelem.i2               Load the element with type int16 at index onto the top of the stack as an int32\nldelem.i4               Load the element with type int32 at index onto the top of the stack as an int32\nldelem.i8               Load the element with type int64 at index onto the top of the stack as an int64\nldelem.r4               Load the element with type float32 at index onto the top of the stack as an F\nldelem.r8               Load the element with type float64 at index onto the top of the stack as an F\nldelem.ref              Load the element at index onto the top of the stack as an O. The type of the O is the same as the element type of the array pushed on the CIL stack\nldelem.u1               Load the element with type unsigned int8 at index onto the top of the stack as an int32\nldelem.u2               Load the element with type unsigned int16 at index onto the top of the stack as an int32\nldelem.u4               Load the element with type unsigned int32 at index onto the top of the stack as an int32\nldelem.u8               Load the element with type unsigned int64 at index onto the top of the stack as an int64 (alias for ldelem.i8)\nldelema <class>         Load the address of element at index onto the top of the stack\nldfld <field>           Push the value of field of object (or value type) obj, onto the stack\nldflda <field>          Push the address of field of object obj on the stack\nldftn <method>          Push a pointer to a method referenced by method, on the stack\nldind.i                 Indirect load value of type native int as native int on the stack\nldind.i1                Indirect load value of type int8 as int32 on the stack\nldind.i2                Indirect load value of type int16 as int32 on the stack\nldind.i4                Indirect load value of type int32 as int32 on the stack\nldind.i8                Indirect load value of type int64 as int64 on the stack\nldind.r4                Indirect load value of type float32 as F on the stack\nldind.r8                Indirect load value of type float64 as F on the stack\nldind.ref               Indirect load value of type object ref as O on the stack\nldind.u1                Indirect load value of type unsigned int8 as int32 on the stack\nldind.u2                Indirect load value of type unsigned int16 as int32 on the stack\nldind.u4                Indirect load value of type unsigned int32 as int32 on the stack\nldind.u8                Indirect load value of type unsigned int64 as int64 on the stack (alias for ldind.i8)\nldlen                   Push the length (of type native unsigned int) of array on the stack\nldloc <uint16 (indx)>   Load local variable of index indx onto stack\nldloc.0                 Load local variable 0 onto stack\nldloc.1                 Load local variable 1 onto stack\nldloc.2                 Load local variable 2 onto stack\nldloc.3                 Load local variable 3 onto stack\nldloc.s <uint8 (indx)>  Load local variable of index indx onto stack, short form\nldloca <uint16 (indx)>  Load address of local variable with index indx\nldloca.s <uint8 (indx)> Load address of local variable with index indx, short form\nldnull                  Push a null reference on the stack\nldobj <typeTok>         Copy the value stored at address src to the stack\nldsfld <field>          Push the value of field on the stack\nldsflda <field>         Push the address of the static field, field, on the stack\nldstr <string>          Push a string object for the literal string\nldtoken <token>         Convert metadata token to its runtime representation\nldvirtftn <method>      Push address of virtual method on the stack\nleave <int32 (target)>  Exit a protected region of code\nleave.s <int8 (target)> Exit a protected region of code, short form\nlocalloc                Allocate space from the local memory pool\nmkrefany <class>        Push a typed reference to ptr of type class onto the stack\nmul                     Multiply values\nmul.ovf                 Multiply signed integer values. Signed result shall fit in same size\nmul.ovf.un              Multiply unsigned integer values. Unsigned result shall fit in same size\nneg                     Negate value\nnewarr <etype>          Create a new array with elements of type etype\nnewobj <ctor>           Allocate an uninitialized object or value type and call ctor\nno. {\n typecheck,\n rangecheck,\n nullcheck\n}                       The specified fault check(s) normally performed as part of the execution of the subsequent instruction can/shall be skipped\nnop                     Do nothing (No operation)\nnot                     Bitwise complement (logical not)\nor                      Bitwise OR of two integer values, returns an integer\npop                     Pop value from the stack\nreadonly.               Specify that the subsequent array address operation performs no type check at runtime, and that it returns a controlled-mutability managed pointer\nrefanytype              Push the type token stored in a typed reference\nrefanyval <type>        Push the address stored in a typed reference\nrem                     Remainder when dividing one value by another\nrem.un                  Remainder when dividing one unsigned value by another\nret                     Return from method, possibly with a value\nrethrow                 Rethrow the current exception\nshl                     Shift an integer left (shifting in zeros), return an integer\nshr                     Shift an integer right (shift in sign), return an integer\nshr.un                  Shift an integer right (shift in zero), return an integer\nsizeof <typeTok>        Push the size, in bytes, of a type as an unsigned int32\nstarg <uint16 (num)>    Store value to the argument numbered num\nstarg.s <uint8 (num)>   Store value to the argument numbered num, short form\nstelem <typeTok>        Replace array element at index with the value on the stack\nstelem.i                Replace array element at index with the i value on the stack\nstelem.i1               Replace array element at index with the int8 value on the stack\nstelem.i2               Replace array element at index with the int16 value on the stack\nstelem.i4               Replace array element at index with the int32 value on the stack\nstelem.i8               Replace array element at index with the int64 value on the stack\nstelem.r4               Replace array element at index with the float32 value on the stack\nstelem.r8               Replace array element at index with the float64 value on the stack\nstelem.ref              Replace array element at index with the ref value on the stack\nstfld <field>           Replace the value of field of the object obj with value\nstind.i                 Store value of type native int into memory at address\nstind.i1                Store value of type int8 into memory at address\nstind.i2                Store value of type int16 into memory at address\nstind.i4                Store value of type int32 into memory at address\nstind.i8                Store value of type int64 into memory at address\nstind.r4                Store value of type float32 into memory at address\nstind.r8                Store value of type float64 into memory at address\nstind.ref               Store value of type object ref (type O) into memory at address\nstloc <uint16 (indx)>   Pop a value from stack into local variable indx\nstloc.0                 Pop a value from stack into local variable 0\nstloc.1                 Pop a value from stack into local variable 1\nstloc.2                 Pop a value from stack into local variable 2\nstloc.3                 Pop a value from stack into local variable 3\nstloc.s <uint8 (indx)>  Pop a value from stack into local variable indx, short form\nstobj <typeTok>         Store a value of type typeTok at an address\nstsfld <field>          Replace the value of field with val\nsub                     Subtract value2 from value1, returning a new value\nsub.ovf                 Subtract native int from a native int. Signed result shall fit in same size\nsub.ovf.un              Subtract native unsigned int from a native unsigned int. Unsigned result shall fit in same size\nswitch <uint32, int32, int32 (t1..tN)>Jump to one of n values\ntail.                   Subsequent call terminates current method\nthrow                   Throw an exception\nunaligned. (alignment)  Subsequent pointer instruction might be unaligned\nunbox <valuetype>       Extract a value-type from obj, its boxed representation\nunbox.any <typeTok>     Extract a value-type from obj, its boxed representation\nvolatile.               Subsequent pointer reference is volatile\nxor                     Bitwise XOR of integer values, returns an integer\n\n#.NET Framework \u30a2\u30bb\u30f3\u30d6\u30e9 \u30ea\u30d5\u30a1\u30ec\u30f3\u30b9\n```\nadd\t\t\t\t\t\tAdd two values, returning a new value\nadd.ovf\t\t\t\t\tAdd signed integer values with overflow check\nadd.ovf.un\t\t\t\tAdd unsigned integer values with overflow check\nand\t\t\t\t\t\tBitwise AND of two integral values, returns an integral value\narglist\t\t\t\t\tReturn argument list handle for the current method\nbeq <int32 (target)>\tBranch to target if equal\nbeq.s <int8 (target)>\tBranch to target if equal, short form\nbge <int32 (target)>\tBranch to target if greater than or equal to\nbge.s <int8 (target)>\tBranch to target if greater than or equal to, short form\nbge.un <int32 (target)>\tBranch to target if greater than or equal to (unsigned or unordered)\nbge.un.s <int8 (target)>Branch to target if greater than or equal to (unsigned or unordered), short form\nbgt <int32 (target)>\tBranch to target if greater than\nbgt.s <int8 (target)>\tBranch to target if greater than, short form\nbgt.un <int32 (target)>\tBranch to target if greater than (unsigned or unordered)\nbgt.un.s <int8 (target)>Branch to target if greater than (unsigned or unordered), short form\nble <int32 (target)>\tBranch to target if less than or equal to\nble.s <int8 (target)>\tBranch to target if less than or equal to, short form\nble.un <int32 (target)>\tBranch to target if less than or equal to (unsigned or unordered)\nble.un.s <int8 (target)>Branch to target if less than or equal to (unsigned or unordered), short form\nblt <int32 (target)>\tBranch to target if less than\nblt.s <int8 (target)>\tBranch to target if less than, short form\nblt.un <int32 (target)>\tBranch to target if less than (unsigned or unordered)\nblt.un.s <int8 (target)>Branch to target if less than (unsigned or unordered), short form\nbne.un <int32 (target)>\tBranch to target if unequal or unordered\nbne.un.s <int8 (target)>Branch to target if unequal or unordered, short form\nbox <typeTok>\t\t\tConvert a boxable value to its boxed form\nbr <int32 (target)>\t\tBranch to target\nbr.s <int8 (target)>\tBranch to target, short form\nbreak\t\t\t\t\tInform a debugger that a breakpoint has been reached\nbrfalse <int32 (target)>Branch to target if value is zero (false)\nbrfalse.s <int8 (target)>Branch to target if value is zero (false), short form\nbrinst <int32 (target)>\tBranch to target if value is a non-null object reference (alias for brtrue)\nbrinst.s <int8 (target)>Branch to target if value is a non-null object reference, short form (alias for brtrue.s)\nbrnull <int32 (target)>\tBranch to target if value is null (alias for brfalse)\nbrnull.s <int8 (target)>Branch to target if value is null (alias for brfalse.s), short form\nbrtrue <int32 (target)>\tBranch to target if value is non-zero (true)\nbrtrue.s <int8 (target)>Branch to target if value is non-zero (true), short form\nbrzero <int32 (target)>\tBranch to target if value is zero (alias for brfalse)\nbrzero.s <int8 (target)>Branch to target if value is zero (alias for brfalse.s), short form\ncall <method>\t\t\tCall method described by method\ncalli <callsitedescr>\tCall method indicated on the stack with arguments described by callsitedescr\ncallvirt <method>\t\tCall a method associated with an object\ncastclass <class>\t\tCast obj to class\nceq\t\t\t\t\t\tPush 1 (of type int32) if value1 equals value2, else push 0\ncgt\t\t\t\t\t\tPush 1 (of type int32) if value1 > value2, else push 0.\t\ncgt.un\t\t\t\t\tPush 1 (of type int32) if value1 > value2, unsigned or unordered, else push 0\nckfinite\t\t\t\tThrow ArithmeticException if value is not a finite number\nclt\t\t\t\t\t\tPush 1 (of type int32) if value1 < value2, else push 0\nclt.un\t\t\t\t\tPush 1 (of type int32) if value1 < value2, unsigned or unordered, else push 0\nconstrained. <thisType>\tCall a virtual method on a type constrained to be type T\nconv.i\t\t\t\t\tConvert to native int, pushing native int on stack\nconv.i1\t\t\t\t\tConvert to int8, pushing int32 on stack\nconv.i2\t\t\t\t\tConvert to int16, pushing int32 on stack\nconv.i4\t\t\t\t\tConvert to int32, pushing int32 on stack\nconv.i8\t\t\t\t\tConvert to int64, pushing int64 on stack\nconv.ovf.i\t\t\t\tConvert to a native int (on the stack as native int) and throw an exception on overflow\nconv.ovf.i.un\t\t\tConvert unsigned to a native int (on the stack as native int) and throw an exception on overflow\nconv.ovf.i1\t\t\t\tConvert to an int8 (on the stack as int32) and throw an exception on overflow\nconv.ovf.i1.un\t\t\tConvert unsigned to an int8 (on the stack as int32) and throw an exception on overflow\nconv.ovf.i2\t\t\t\tConvert to an int16 (on the stack as int32) and throw an exception on overflow\nconv.ovf.i2.un\t\t\tConvert unsigned to an int16 (on the stack as int32) and throw an exception on overflow\nconv.ovf.i4\t\t\t\tConvert to an int32 (on the stack as int32) and throw an exception on overflow\nconv.ovf.i4.un\t\t\tConvert unsigned to an int32 (on the stack as int32) and throw an exception on overflow\nconv.ovf.i8\t\t\t\tConvert to an int64 (on the stack as int64) and throw an exception on overflow\nconv.ovf.i8.un\t\t\tConvert unsigned to an int64 (on the stack as int64) and throw an exception on overflow\nconv.ovf.u\t\t\t\tConvert to a native unsigned int (on the stack as native int) and throw an exception on overflow\nconv.ovf.u.un\t\t\tConvert unsigned to a native unsigned int (on the stack as native int) and throw an exception on overflow\nconv.ovf.u1\t\t\t\tConvert to an unsigned int8 (on the stack as int32) and throw an exception on overflow\nconv.ovf.u1.un\t\t\tConvert unsigned to an unsigned int8 (on the stack as int32) and throw an exception on overflow\nconv.ovf.u2\t\t\t\tConvert to an unsigned int16 (on the stack as int32) and throw an exception on overflow\nconv.ovf.u2.un\t\t\tConvert unsigned to an unsigned int16 (on the stack as int32) and throw an exception on overflow\nconv.ovf.u4\t\t\t\tConvert to an unsigned int32 (on the stack as int32) and throw an exception on overflow\nconv.ovf.u4.un\t\t\tConvert unsigned to an unsigned int32 (on the stack as int32) and throw an exception on overflow\nconv.ovf.u8\t\t\t\tConvert to an unsigned int64 (on the stack as int64) and throw an exception on overflow\nconv.ovf.u8.un\t\t\tConvert unsigned to an unsigned int64 (on the stack as int64) and throw an exception on overflow\nconv.r.un\t\t\t\tConvert unsigned integer to floating-point, pushing F on stack\nconv.r4\t\t\t\t\tConvert to float32, pushing F on stack\nconv.r8\t\t\t\t\tConvert to float64, pushing F on stack\nconv.u\t\t\t\t\tConvert to native unsigned int, pushing native int on stack\nconv.u1\t\t\t\t\tConvert to unsigned int8, pushing int32 on stack\nconv.u2\t\t\t\t\tConvert to unsigned int16, pushing int32 on stack\nconv.u4\t\t\t\t\tConvert to unsigned int32, pushing int32 on stack\nconv.u8\t\t\t\t\tConvert to unsigned int64, pushing int64 on stack\ncpblk\t\t\t\t\tCopy data from memory to memory\ncpobj <typeTok>\t\t\tCopy a value type from src to dest\ndiv\t\t\t\t\t\tDivide two values to return a quotient or floating-point result\ndiv.un\t\t\t\t\tDivide two values, unsigned, returning a quotient\ndup\t\t\t\t\t\tDuplicate the value on the top of the stack\nendfault\t\t\t\tEnd fault clause of an exception block\nendfilter\t\t\t\tEnd an exception handling filter clause\nendfinally\t\t\t\tEnd finally clause of an exception block\ninitblk\t\t\t\t\tSet all bytes in a block of memory to a given byte value\ninitobj <typeTok>\t\tInitialize the value at address dest\nisinst <class>\t\t\tTest if obj is an instance of class, returning null or an instance of that class or interface\njmp <method>\t\t\tExit current method and jump to the specified method\nldarg <uint16 (num)>\tLoad argument numbered num onto the stack\nldarg.0\t\t\t\t\tLoad argument 0 onto the stack\nldarg.1\t\t\t\t\tLoad argument 1 onto the stack\nldarg.2\t\t\t\t\tLoad argument 2 onto the stack\nldarg.3\t\t\t\t\tLoad argument 3 onto the stack\nldarg.s <uint8 (num)>\tLoad argument numbered num onto the stack, short form\nldarga <uint16 (argNum)>Fetch the address of argument argNum\nldarga.s <uint8 (argNum)>Fetch the address of argument argNum, short form\nldc.i4 <int32 (num)>\tPush num of type int32 onto the stack as int32\nldc.i4.0\t\t\t\tPush 0 onto the stack as int32\nldc.i4.1\t\t\t\tPush 1 onto the stack as int32\nldc.i4.2\t\t\t\tPush 2 onto the stack as int32\nldc.i4.3\t\t\t\tPush 3 onto the stack as int32\nldc.i4.4\t\t\t\tPush 4 onto the stack as int32\nldc.i4.5\t\t\t\tPush 5 onto the stack as int32\nldc.i4.6\t\t\t\tPush 6 onto the stack as int32\nldc.i4.7\t\t\t\tPush 7 onto the stack as int32\nldc.i4.8\t\t\t\tPush 8 onto the stack as int32\nldc.i4.m1\t\t\t\tPush -1 onto the stack as int32\nldc.i4.M1\t\t\t\tPush -1 of type int32 onto the stack as int32 (alias for ldc.i4.m1)\nldc.i4.s <int8 (num)>\tPush num onto the stack as int32, short form\nldc.i8 <int64 (num)>\tPush num of type int64 onto the stack as int64\nldc.r4 <float32 (num)>\tPush num of type float32 onto the stack as F\nldc.r8 <float64 (num)>\tPush num of type float64 onto the stack as F\nldelem <typeTok>\t\tLoad the element at index onto the top of the stack\nldelem.i\t\t\t\tLoad the element with type native int at index onto the top of the stack as a native int\nldelem.i1\t\t\t\tLoad the element with type int8 at index onto the top of the stack as an int32\nldelem.i2\t\t\t\tLoad the element with type int16 at index onto the top of the stack as an int32\nldelem.i4\t\t\t\tLoad the element with type int32 at index onto the top of the stack as an int32\nldelem.i8\t\t\t\tLoad the element with type int64 at index onto the top of the stack as an int64\nldelem.r4\t\t\t\tLoad the element with type float32 at index onto the top of the stack as an F\nldelem.r8\t\t\t\tLoad the element with type float64 at index onto the top of the stack as an F\nldelem.ref\t\t\t\tLoad the element at index onto the top of the stack as an O. The type of the O is the same as the element type of the array pushed on the CIL stack\nldelem.u1\t\t\t\tLoad the element with type unsigned int8 at index onto the top of the stack as an int32\nldelem.u2\t\t\t\tLoad the element with type unsigned int16 at index onto the top of the stack as an int32\nldelem.u4\t\t\t\tLoad the element with type unsigned int32 at index onto the top of the stack as an int32\nldelem.u8\t\t\t\tLoad the element with type unsigned int64 at index onto the top of the stack as an int64 (alias for ldelem.i8)\nldelema <class>\t\t\tLoad the address of element at index onto the top of the stack\nldfld <field>\t\t\tPush the value of field of object (or value type) obj, onto the stack\nldflda <field>\t\t\tPush the address of field of object obj on the stack\nldftn <method>\t\t\tPush a pointer to a method referenced by method, on the stack\nldind.i\t\t\t\t\tIndirect load value of type native int as native int on the stack\nldind.i1\t\t\t\tIndirect load value of type int8 as int32 on the stack\nldind.i2\t\t\t\tIndirect load value of type int16 as int32 on the stack\nldind.i4\t\t\t\tIndirect load value of type int32 as int32 on the stack\nldind.i8\t\t\t\tIndirect load value of type int64 as int64 on the stack\nldind.r4\t\t\t\tIndirect load value of type float32 as F on the stack\nldind.r8\t\t\t\tIndirect load value of type float64 as F on the stack\nldind.ref\t\t\t\tIndirect load value of type object ref as O on the stack\nldind.u1\t\t\t\tIndirect load value of type unsigned int8 as int32 on the stack\nldind.u2\t\t\t\tIndirect load value of type unsigned int16 as int32 on the stack\nldind.u4\t\t\t\tIndirect load value of type unsigned int32 as int32 on the stack\nldind.u8\t\t\t\tIndirect load value of type unsigned int64 as int64 on the stack (alias for ldind.i8)\nldlen\t\t\t\t\tPush the length (of type native unsigned int) of array on the stack\nldloc <uint16 (indx)>\tLoad local variable of index indx onto stack\nldloc.0\t\t\t\t\tLoad local variable 0 onto stack\nldloc.1\t\t\t\t\tLoad local variable 1 onto stack\nldloc.2\t\t\t\t\tLoad local variable 2 onto stack\nldloc.3\t\t\t\t\tLoad local variable 3 onto stack\nldloc.s <uint8 (indx)>\tLoad local variable of index indx onto stack, short form\nldloca <uint16 (indx)>\tLoad address of local variable with index indx\nldloca.s <uint8 (indx)>\tLoad address of local variable with index indx, short form\nldnull\t\t\t\t\tPush a null reference on the stack\nldobj <typeTok>\t\t\tCopy the value stored at address src to the stack\nldsfld <field>\t\t\tPush the value of field on the stack\nldsflda <field>\t\t\tPush the address of the static field, field, on the stack\nldstr <string>\t\t\tPush a string object for the literal string\nldtoken <token>\t\t\tConvert metadata token to its runtime representation\nldvirtftn <method>\t\tPush address of virtual method on the stack\nleave <int32 (target)>\tExit a protected region of code\nleave.s <int8 (target)>\tExit a protected region of code, short form\nlocalloc\t\t\t\tAllocate space from the local memory pool\nmkrefany <class>\t\tPush a typed reference to ptr of type class onto the stack\nmul\t\t\t\t\t\tMultiply values\nmul.ovf\t\t\t\t\tMultiply signed integer values. Signed result shall fit in same size\nmul.ovf.un\t\t\t\tMultiply unsigned integer values. Unsigned result shall fit in same size\nneg\t\t\t\t\t\tNegate value\nnewarr <etype>\t\t\tCreate a new array with elements of type etype\nnewobj <ctor>\t\t\tAllocate an uninitialized object or value type and call ctor\nno. {\n typecheck,\n rangecheck,\n nullcheck\n}\t\t\t\t\t\tThe specified fault check(s) normally performed as part of the execution of the subsequent instruction can/shall be skipped\nnop\t\t\t\t\t\tDo nothing (No operation)\nnot\t\t\t\t\t\tBitwise complement (logical not)\nor\t\t\t\t\t\tBitwise OR of two integer values, returns an integer\npop\t\t\t\t\t\tPop value from the stack\nreadonly.\t\t\t\tSpecify that the subsequent array address operation performs no type check at runtime, and that it returns a controlled-mutability managed pointer\nrefanytype\t\t\t\tPush the type token stored in a typed reference\nrefanyval <type>\t\tPush the address stored in a typed reference\nrem\t\t\t\t\t\tRemainder when dividing one value by another\nrem.un\t\t\t\t\tRemainder when dividing one unsigned value by another\nret\t\t\t\t\t\tReturn from method, possibly with a value\nrethrow\t\t\t\t\tRethrow the current exception\nshl\t\t\t\t\t\tShift an integer left (shifting in zeros), return an integer\nshr\t\t\t\t\t\tShift an integer right (shift in sign), return an integer\nshr.un\t\t\t\t\tShift an integer right (shift in zero), return an integer\nsizeof <typeTok>\t\tPush the size, in bytes, of a type as an unsigned int32\nstarg <uint16 (num)>\tStore value to the argument numbered num\nstarg.s <uint8 (num)>\tStore value to the argument numbered num, short form\nstelem <typeTok>\t\tReplace array element at index with the value on the stack\nstelem.i\t\t\t\tReplace array element at index with the i value on the stack\nstelem.i1\t\t\t\tReplace array element at index with the int8 value on the stack\nstelem.i2\t\t\t\tReplace array element at index with the int16 value on the stack\nstelem.i4\t\t\t\tReplace array element at index with the int32 value on the stack\nstelem.i8\t\t\t\tReplace array element at index with the int64 value on the stack\nstelem.r4\t\t\t\tReplace array element at index with the float32 value on the stack\nstelem.r8\t\t\t\tReplace array element at index with the float64 value on the stack\nstelem.ref\t\t\t\tReplace array element at index with the ref value on the stack\nstfld <field>\t\t\tReplace the value of field of the object obj with value\nstind.i\t\t\t\t\tStore value of type native int into memory at address\nstind.i1\t\t\t\tStore value of type int8 into memory at address\nstind.i2\t\t\t\tStore value of type int16 into memory at address\nstind.i4\t\t\t\tStore value of type int32 into memory at address\nstind.i8\t\t\t\tStore value of type int64 into memory at address\nstind.r4\t\t\t\tStore value of type float32 into memory at address\nstind.r8\t\t\t\tStore value of type float64 into memory at address\nstind.ref\t\t\t\tStore value of type object ref (type O) into memory at address\nstloc <uint16 (indx)>\tPop a value from stack into local variable indx\nstloc.0\t\t\t\t\tPop a value from stack into local variable 0\nstloc.1\t\t\t\t\tPop a value from stack into local variable 1\nstloc.2\t\t\t\t\tPop a value from stack into local variable 2\nstloc.3\t\t\t\t\tPop a value from stack into local variable 3\nstloc.s <uint8 (indx)>\tPop a value from stack into local variable indx, short form\nstobj <typeTok>\t\t\tStore a value of type typeTok at an address\nstsfld <field>\t\t\tReplace the value of field with val\nsub\t\t\t\t\t\tSubtract value2 from value1, returning a new value\nsub.ovf\t\t\t\t\tSubtract native int from a native int. Signed result shall fit in same size\nsub.ovf.un\t\t\t\tSubtract native unsigned int from a native unsigned int. Unsigned result shall fit in same size\nswitch <uint32, int32, int32 (t1..tN)>Jump to one of n values\ntail.\t\t\t\t\tSubsequent call terminates current method\nthrow\t\t\t\t\tThrow an exception\nunaligned. (alignment)\tSubsequent pointer instruction might be unaligned\nunbox <valuetype>\t\tExtract a value-type from obj, its boxed representation\nunbox.any <typeTok>\t\tExtract a value-type from obj, its boxed representation\nvolatile.\t\t\t\tSubsequent pointer reference is volatile\nxor\t\t\t\t\t\tBitwise XOR of integer values, returns an integer\n```\n", "tags": [".NETFramework", "\u30a2\u30bb\u30f3\u30d6\u30e9"]}