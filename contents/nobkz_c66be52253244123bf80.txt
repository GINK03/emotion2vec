{"context": " More than 1 year has passed since last update.todo : \u3042\u3068\u3067\u3001\u30e2\u30b8\u30e5\u30fc\u30eb\u306e\u69cb\u6210\u56f3\u3067\u3082\u4f5c\u308b\u304b....\n\nRiak Core\u3092\u8aad\u3080\nRiak Core\u3092\u8aad\u3093\u3067\u3044\u308b\u3002chash\u7de8\u3067\u3042\u308b\u3002\n\nchash\u3092\u8aad\u3080\nhttps://github.com/basho/riak_core/blob/develop/src/chash.erl\nConsistent Hashing\u3060\u305d\u3046\u3060\u3002\u4e00\u8cab\u3057\u305f\u30cf\u30c3\u30b7\u30e5\u3068\u3044\u3046\u3053\u3068\u3089\u3057\u3044\u3002\n\n\u578b\u3068\u30ec\u30b3\u30fc\u30c9\n-type chash() :: {num_partitions(), [node_entry()]}.\n\n\u3055\u3066\u3053\u308c\u304c\u3001chash\u578b\u3002\u30d1\u30fc\u30c6\u30a3\u30b7\u30e7\u30f3\u306e\u6570\u3068\u3001node_entry\u306e\u30ea\u30b9\u30c8\u304b\u306a?\n%% A Node is the unique identifier for the owner of a given partition.\n%% An Erlang Pid works well here, but the chash module allows it to\n%% be any term.\n-type chash_node() :: term().\n\n\u30d1\u30fc\u30c6\u30a3\u30b7\u30e7\u30f3\u306e\u30aa\u30fc\u30ca\u30fc\u306b\u3068\u3063\u3066\u306e\u3001\u8b58\u5225\u5b50\u3067\u3042\u308b\u3068\u3044\u3046\u308f\u3051\u306d\u3002pid\u306f\u826f\u3044\u3093\u3060\u3051\u3069\u3001\u578b\u306a\u4f55\u3067\u3082\u3044\u3044\u3093\u3088\u3063\u3066\u3053\u3068\u304b\u3002\n%% Indices into the ring, used as keys for object location, are binary\n%% representations of 160-bit integers.\n-type index() :: <<_:160>>.\n-type index_as_int() :: integer().\n\n\u30ea\u30f3\u30b0\u5185\u306e\u3001\u30aa\u30d6\u30b8\u30a7\u30af\u30c8\u306e\u4f4d\u7f6e\u306e\u305f\u3081\u306e\u3001\u30ad\u30fc\u3068\u3057\u3066\u3001\u578b\u3002\n-type node_entry() :: {index_as_int(), chash_node()}.\n-type num_partitions() :: pos_integer().\n\nnode_entry\u306f\u3001\u30a4\u30f3\u30c7\u30c3\u30af\u30b9\u3068\u3001chash_node\u306e\u578b\u3002num_partitions\u306f\u6b63\u306e\u6574\u6570\u306a\u3093\u3060\u306a\u3002\n\n\u30c6\u30b9\u30c8\u3092\u8aad\u3080\n\u4eca\u56de\u306f\u3001\u306a\u3093\u3068\u306a\u304f\u30c6\u30b9\u30c8\u304b\u3089\u8aad\u3093\u3067\u884c\u304f\u3002\n\nupdate_test()\nupdate_test() ->\n    Node = 'old@host', NewNode = 'new@host',\n\n    % Create a fresh ring...\n    CHash = chash:fresh(5, Node),\n    GetNthIndex = fun(N, {_, Nodes}) -> {Index, _} = lists:nth(N, Nodes), Index end,\n\n    % Test update...\n    FirstIndex = GetNthIndex(1, CHash),\n    ThirdIndex = GetNthIndex(3, CHash),\n    {5, [{_, NewNode}, {_, Node}, {_, Node}, {_, Node}, {_, Node}, {_, Node}]} = update(FirstIndex, NewNode, CHash),\n    {5, [{_, Node}, {_, Node}, {_, NewNode}, {_, Node}, {_, Node}, {_, Node}]} = update(ThirdIndex, NewNode, CHash).\n\n\u4e00\u5fdc\u3001\u3053\u3053\u3067\u3001\u4f7f\u308f\u308c\u3066\u3044\u308b\u95a2\u6570spec\u3068\u304b\u3092\u3001\u8abf\u3079\u3066\u304a\u304f\n-spec fresh(NumPartitions :: num_partitions(), SeedNode :: chash_node()) -> chash().\n\nfresh\u306f\u3001\u30d5\u30ec\u30c3\u30b7\u30e5\u306achash\u3092\u4f5c\u308b\u308f\u3051\u3067\u3059\u306d\u30fc\u3002\u30d1\u30fc\u30c6\u30a3\u30b7\u30e7\u30f3\u306e\u6570\u3068\u3001\u30b7\u30fc\u30c9\u30ce\u30fc\u30c9\u3092\u53d6\u308b\u3093\u3067\u3064\u306d\u3002\n-spec update(IndexAsInt :: index_as_int(), Name :: chash_node(), CHash :: chash()) -> chash().\n\n\u307e\u3041\u3001update\u3059\u308b\u3093\u3067\u3059\u3088\u3002\n\u3093\u3067\u3001\u30c6\u30b9\u30c8\u306f\u3001chash\u306e\u30a4\u30f3\u30c7\u30c3\u30af\u30b9\u306e\u4f4d\u7f6e\u306b\u3042\u308b\u3001\u30ce\u30fc\u30c9\u304c\u66f4\u65b0\u3055\u308c\u3066\u3044\u308b\u304b\u3069\u3046\u304b\u306e\u30c6\u30b9\u30c8\u306a\u3093\u3067\u3064\u306a\u3002\n\nmax_n_test\n-spec max_n(N :: integer(), CHash :: chash()) -> integer().\n\n...\n\nmax_n_test() ->\n    CHash = chash:fresh(8, the_node),\n    ?assertEqual(1, max_n(1,CHash)),\n    ?assertEqual(8, max_n(11,CHash)).\n\n\u306f\u3044\u3001\u307e\u3041\u3001n\u304c\u30d1\u30fc\u30c6\u30a3\u30b7\u30e7\u30f3\u306e\u6570\u3092\u8d85\u3048\u306a\u3044\u3088\u3046\u306b\u3059\u308b\u3084\u3064\u3067\u3064\u306d\u3002\n\nsimple_size_test\nsimple_size_test() ->\n    ?assertEqual(8, length(chash:nodes(chash:fresh(8,the_node)))).\n\n\u3068\u304f\u306b\u3001\u30b3\u30e1\u30f3\u30c8\u3057\u306a\u304f\u3066\u3082\u3001\u5206\u304b\u308b\u306a\u3002\u307e\u3041\u3001node\u306e\u30ea\u30b9\u30c8\u3092\u53d6\u3063\u3066\u306e\u3001\u9577\u3055\u306e\u30c6\u30b9\u30c8\u3002\n\nsuccessors_length_test\nsuccessors_length_test() ->\n    ?assertEqual(8, length(chash:successors(chash:key_of(0),\n                                            chash:fresh(8,the_node)))).\n\n\u9806\u5217\u304c\u3042\u3063\u3066\u306d\u3063\u3066\u3053\u3068\u304b\u306d\u3002\n\ninverse_pred_test\ninverse_pred_test() ->\n    CHash = chash:fresh(8,the_node),\n    S = [I || {I,_} <- chash:successors(chash:key_of(4),CHash)],\n    P = [I || {I,_} <- chash:predecessors(chash:key_of(4),CHash)],\n    ?assertEqual(S,lists:reverse(P)).\n\n\u307e\u3041\u3001\u9806\u5217\u304c\u3042\u3063\u3066\u3001successors\u3068predecessors\u306f\u9806\u65b9\u5411\u304b\u3001\u9006\u65b9\u5411\u3063\u3066\u3053\u3068\u304b\u306d\u3002\n\nmerge_test\nmerge_test() ->\n    CHashA = chash:fresh(8,node_one),\n    CHashB = chash:update(0,node_one,chash:fresh(8,node_two)),\n    CHash = chash:merge_rings(CHashA,CHashB),\n    ?assertEqual(node_one,chash:lookup(0,CHash)).\n\n\u30de\u30fc\u30b8\u3059\u308b\u3093\u3088\u3002\n\n\u5b9f\u88c5\u3092\u8aad\u3080\n\u3055\u3066\u3001\u5b9f\u88c5\u3092\u8aad\u3093\u3067\u3044\u304f\u3088\u3002\n\ncontains_name\n%% @doc Return true if named Node owns any partitions in the ring, else false.\n-spec contains_name(Name :: chash_node(), CHash :: chash()) -> boolean().\ncontains_name(Name, CHash) ->\n    {_NumPartitions, Nodes} = CHash,\n    [X || {_,X} <- Nodes, X == Name] =/= [].\n\nchash\u306b\u3001\u540d\u524d\u304c\u542b\u307e\u308c\u3066\u3044\u308b\u304b\u3092\u8abf\u3079\u308b\u3093\u3088\u3002\u307e\u3041\u3001\u30ea\u30b9\u30c8\u5185\u5305\u8868\u8a18\u3067\u3084\u3063\u3066\u308b\u3002\n\nfresh\u3068ring_increment\n-define(RINGTOP, trunc(math:pow(2,160)-1)).  % SHA-1 space\n\n...\n\n%% @doc Create a brand new ring.  The size and seednode are specified;\n%%      initially all partitions are owned by the seednode.  If NumPartitions\n%%      is not much larger than the intended eventual number of\n%%       participating nodes, then performance will suffer.\n-spec fresh(NumPartitions :: num_partitions(), SeedNode :: chash_node()) -> chash().\nfresh(NumPartitions, SeedNode) ->\n    Inc = ring_increment(NumPartitions),\n    {NumPartitions, [{IndexAsInt, SeedNode} ||\n           IndexAsInt <- lists:seq(0,(?RINGTOP-1),Inc)]}.\n\n...\n\n%% @doc Return increment between ring indexes given\n%% the number of ring partitions.\n-spec ring_increment(NumPartitions :: pos_integer()) -> pos_integer().\nring_increment(NumPartitions) ->\n    ?RINGTOP div NumPartitions.\n\n\u306a\u308b\u307b\u3069\u3002SHA1\u3060\u304b\u3089\u3001160\u30d3\u30c3\u30c8\u3002\u3093\u3067\u30012\u306e160\u4e57\u3002\u305d\u308c\u3092\u3001\u30d1\u30fc\u30c6\u30a3\u30b7\u30e7\u30f3\u3067\u5206\u5272\u3057\u3066\u3001\u305d\u308c\u3092\u30a4\u30f3\u30af\u30ea\u30e1\u30f3\u30c8\u306e\u5024\u3068\u3057\u3066\u3001\u30a4\u30f3\u30c7\u30c3\u30af\u30b9\u306e\u5024\u3092\u6c7a\u5b9a\u3057\u3066\u3044\u308b\u306e\u306d\u3002\n\nlookup\n%% @doc Find the Node that owns the partition identified by IndexAsInt.\n-spec lookup(IndexAsInt :: index_as_int(), CHash :: chash()) -> chash_node().\nlookup(IndexAsInt, CHash) ->\n    {_NumPartitions, Nodes} = CHash,\n    {IndexAsInt, X} = proplists:lookup(IndexAsInt, Nodes),\n    X.\n\n\u3053\u308c\u3082\u3001\u7c21\u5358\u3060\u306a\u3002\u30a4\u30f3\u30c7\u30c3\u30af\u30b9\u304b\u3089\u53d6\u3063\u3066\u304f\u308b\u3060\u3051\u3067\u3057\u3087?\n\nkey_of\n-ifndef(old_hash).\nsha(Bin) ->\n    crypto:hash(sha, Bin).\n-else.\nsha(Bin) ->\n    crypto:sha(Bin).\n-endif.\n\n...\n\n%% @doc Given any term used to name an object, produce that object's key\n%%      into the ring.  Two names with the same SHA-1 hash value are\n%%      considered the same name.\n-spec key_of(ObjectName :: term()) -> index().\nkey_of(ObjectName) ->    \n    sha(term_to_binary(ObjectName)).\n\n\u307e\u3041\u3001\u30cf\u30c3\u30b7\u30e5\u95a2\u6570\u8aad\u3093\u3067\u308b\u3060\u3051\u3060\u306a\u3002\n\nmembers\n%% @doc Return all Nodes that own any partitions in the ring.\n-spec members(CHash :: chash()) -> [chash_node()].\nmembers(CHash) ->\n    {_NumPartitions, Nodes} = CHash,\n    lists:usort([X || {_Idx,X} <- Nodes]).\n\n\u30ce\u30fc\u30c9\u306e\u30e1\u30f3\u30d0\u30fc\u5168\u90e8\u306e\u30ea\u30b9\u30c8\u3092\u3064\u304f\u308b\u3002\n\nmerge_ring\n%% @doc Return a randomized merge of two rings.\n%%      If multiple nodes are actively claiming nodes in the same\n%%      time period, churn will occur.  Be prepared to live with it.\n-spec merge_rings(CHashA :: chash(), CHashB :: chash()) -> chash().\nmerge_rings(CHashA,CHashB) ->\n    {NumPartitions, NodesA} = CHashA,\n    {NumPartitions, NodesB} = CHashB,\n    {NumPartitions, [{I,random_node(A,B)} || \n           {{I,A},{I,B}} <- lists:zip(NodesA,NodesB)]}.\n\nring\u3092\u30de\u30fc\u30b8\u3059\u308b\u3002\u524d\u63d0\u3068\u3057\u3066\u30d1\u30fc\u30c6\u30a3\u30b7\u30e7\u30f3\u306e\u6570\u304c\u540c\u3058\u306echash\u540c\u58eb\u3092\u30de\u30fc\u30b8\u3059\u308b\u3002\u306a\u3093\u304b\u3001\u30e9\u30f3\u30c0\u30e0\u306bnode\u3092\u9078\u629e\u3059\u308b\u3002\n\nnext_index\n%% @doc Given the integer representation of a chash key,\n%%      return the next ring index integer value.\n-spec next_index(IntegerKey :: integer(), CHash :: chash()) -> index_as_int().\nnext_index(IntegerKey, {NumPartitions, _}) ->\n        Inc = ring_increment(NumPartitions),\n        (((IntegerKey div Inc) + 1) rem NumPartitions) * Inc.\n\n\u6b21\u306e\u30a4\u30f3\u30c7\u30c3\u30af\u30b9\u3092\u8fd4\u3059\u95a2\u6570\u3002\n\nnodes\n%% @doc Return the entire set of NodeEntries in the ring.\n-spec nodes(CHash :: chash()) -> [node_entry()].\nnodes(CHash) ->\n    {_NumPartitions, Nodes} = CHash,\n    Nodes.\n\n\u7c21\u5358\u3002\n\nordered_from\n%% @doc Given an object key, return all NodeEntries in order starting at Index.\n-spec ordered_from(Index :: index(), CHash :: chash()) -> [node_entry()].\nordered_from(Index, {NumPartitions, Nodes}) ->\n    <<IndexAsInt:160/integer>> = Index,\n    Inc = ring_increment(NumPartitions),\n    {A, B} = lists:split((IndexAsInt div Inc)+1, Nodes),\n    B ++ A.\n\n\u307b\u3049\u30fc\u3002ring\u3060\u304b\u3089\u3001\u306a\u3093\u304b\u3001\u30b0\u30eb\u30b0\u30eb\u5468\u308b\u30a4\u30e1\u30fc\u30b8\u304c\u3057\u3066\u826f\u3044\u306a\u3002\n\npredecessors\u3068successors\n%% @doc Given an object key, return all NodeEntries in reverse order\n%%      starting at Index.\n-spec predecessors(Index :: index() | index_as_int(), CHash :: chash()) -> [node_entry()].\npredecessors(Index, CHash) ->\n    {NumPartitions, _Nodes} = CHash,\n    predecessors(Index, CHash, NumPartitions).\n%% @doc Given an object key, return the next N NodeEntries in reverse order\n%%      starting at Index.\n-spec predecessors(Index :: index() | index_as_int(), CHash :: chash(), N :: integer())\n                  -> [node_entry()].\npredecessors(Index, CHash, N) when is_integer(Index) ->\n    predecessors(<<Index:160/integer>>, CHash, N);\npredecessors(Index, CHash, N) ->\n    Num = max_n(N, CHash),\n    {Res, _} = lists:split(Num, lists:reverse(ordered_from(Index,CHash))),\n    Res.\n\n...\n\n\n%% @doc Given an object key, return all NodeEntries in order starting at Index.\n-spec successors(Index :: index(), CHash :: chash()) -> [node_entry()].\nsuccessors(Index, CHash) ->\n    {NumPartitions, _Nodes} = CHash,\n    successors(Index, CHash, NumPartitions).\n\n%% @doc Given an object key, return the next N NodeEntries in order\n%%      starting at Index.\n-spec successors(Index :: index(), CHash :: chash(), N :: integer())\n                -> [node_entry()].\nsuccessors(Index, CHash, N) ->\n    Num = max_n(N, CHash),\n    Ordered = ordered_from(Index, CHash),\n    {NumPartitions, _Nodes} = CHash,\n    if Num =:= NumPartitions ->\n        Ordered;\n       true ->\n        {Res, _} = lists:split(Num, Ordered),\n        Res\n    end.\n\n\nsize\n%% @doc Return the number of partitions in the ring.\n-spec size(CHash :: chash()) -> integer().\nsize(CHash) ->\n    {_NumPartitions,Nodes} = CHash,\n    length(Nodes).\n\n\u5b9f\u88c5\u306f\u7c21\u5358\u3002\n\nupdate\n%% @doc Make the partition beginning at IndexAsInt owned by Name'd node.\n-spec update(IndexAsInt :: index_as_int(), Name :: chash_node(), CHash :: chash())\n            -> chash().\nupdate(IndexAsInt, Name, CHash) ->\n    {NumPartitions, Nodes} = CHash,\n    NewNodes = lists:keyreplace(IndexAsInt, 1, Nodes, {IndexAsInt, Name}),\n    {NumPartitions, NewNodes}.\n\n\u7c21\u5358\u3067\u3064\u306d\u3002\ntodo : \u3042\u3068\u3067\u3001\u30e2\u30b8\u30e5\u30fc\u30eb\u306e\u69cb\u6210\u56f3\u3067\u3082\u4f5c\u308b\u304b....\n\n# Riak Core\u3092\u8aad\u3080\n\nRiak Core\u3092\u8aad\u3093\u3067\u3044\u308b\u3002chash\u7de8\u3067\u3042\u308b\u3002\n\n## chash\u3092\u8aad\u3080\n\nhttps://github.com/basho/riak_core/blob/develop/src/chash.erl\n\nConsistent Hashing\u3060\u305d\u3046\u3060\u3002\u4e00\u8cab\u3057\u305f\u30cf\u30c3\u30b7\u30e5\u3068\u3044\u3046\u3053\u3068\u3089\u3057\u3044\u3002\n\n## \u578b\u3068\u30ec\u30b3\u30fc\u30c9\n\n```erlang\n-type chash() :: {num_partitions(), [node_entry()]}.\n```\n\n\u3055\u3066\u3053\u308c\u304c\u3001chash\u578b\u3002\u30d1\u30fc\u30c6\u30a3\u30b7\u30e7\u30f3\u306e\u6570\u3068\u3001node_entry\u306e\u30ea\u30b9\u30c8\u304b\u306a?\n\n```erlang\n%% A Node is the unique identifier for the owner of a given partition.\n%% An Erlang Pid works well here, but the chash module allows it to\n%% be any term.\n-type chash_node() :: term().\n```\n\n\u30d1\u30fc\u30c6\u30a3\u30b7\u30e7\u30f3\u306e\u30aa\u30fc\u30ca\u30fc\u306b\u3068\u3063\u3066\u306e\u3001\u8b58\u5225\u5b50\u3067\u3042\u308b\u3068\u3044\u3046\u308f\u3051\u306d\u3002pid\u306f\u826f\u3044\u3093\u3060\u3051\u3069\u3001\u578b\u306a\u4f55\u3067\u3082\u3044\u3044\u3093\u3088\u3063\u3066\u3053\u3068\u304b\u3002\n\n```erlang\n%% Indices into the ring, used as keys for object location, are binary\n%% representations of 160-bit integers.\n-type index() :: <<_:160>>.\n-type index_as_int() :: integer().\n```\n\n\u30ea\u30f3\u30b0\u5185\u306e\u3001\u30aa\u30d6\u30b8\u30a7\u30af\u30c8\u306e\u4f4d\u7f6e\u306e\u305f\u3081\u306e\u3001\u30ad\u30fc\u3068\u3057\u3066\u3001\u578b\u3002\n\n```erlang\n-type node_entry() :: {index_as_int(), chash_node()}.\n-type num_partitions() :: pos_integer().\n```\n\nnode_entry\u306f\u3001\u30a4\u30f3\u30c7\u30c3\u30af\u30b9\u3068\u3001chash_node\u306e\u578b\u3002num_partitions\u306f\u6b63\u306e\u6574\u6570\u306a\u3093\u3060\u306a\u3002\n\n## \u30c6\u30b9\u30c8\u3092\u8aad\u3080\n\n\u4eca\u56de\u306f\u3001\u306a\u3093\u3068\u306a\u304f\u30c6\u30b9\u30c8\u304b\u3089\u8aad\u3093\u3067\u884c\u304f\u3002\n\n\n### update_test()\n\n```erlang\nupdate_test() ->\n    Node = 'old@host', NewNode = 'new@host',\n    \n    % Create a fresh ring...\n    CHash = chash:fresh(5, Node),\n    GetNthIndex = fun(N, {_, Nodes}) -> {Index, _} = lists:nth(N, Nodes), Index end,\n    \n    % Test update...\n    FirstIndex = GetNthIndex(1, CHash),\n    ThirdIndex = GetNthIndex(3, CHash),\n    {5, [{_, NewNode}, {_, Node}, {_, Node}, {_, Node}, {_, Node}, {_, Node}]} = update(FirstIndex, NewNode, CHash),\n    {5, [{_, Node}, {_, Node}, {_, NewNode}, {_, Node}, {_, Node}, {_, Node}]} = update(ThirdIndex, NewNode, CHash).\n```\n\n\n\u4e00\u5fdc\u3001\u3053\u3053\u3067\u3001\u4f7f\u308f\u308c\u3066\u3044\u308b\u95a2\u6570spec\u3068\u304b\u3092\u3001\u8abf\u3079\u3066\u304a\u304f\n\n```erlang \n-spec fresh(NumPartitions :: num_partitions(), SeedNode :: chash_node()) -> chash().\n```\n\nfresh\u306f\u3001\u30d5\u30ec\u30c3\u30b7\u30e5\u306achash\u3092\u4f5c\u308b\u308f\u3051\u3067\u3059\u306d\u30fc\u3002\u30d1\u30fc\u30c6\u30a3\u30b7\u30e7\u30f3\u306e\u6570\u3068\u3001\u30b7\u30fc\u30c9\u30ce\u30fc\u30c9\u3092\u53d6\u308b\u3093\u3067\u3064\u306d\u3002\n\n```erlang\n-spec update(IndexAsInt :: index_as_int(), Name :: chash_node(), CHash :: chash()) -> chash().\n```\n\n\u307e\u3041\u3001update\u3059\u308b\u3093\u3067\u3059\u3088\u3002\n\n\u3093\u3067\u3001\u30c6\u30b9\u30c8\u306f\u3001chash\u306e\u30a4\u30f3\u30c7\u30c3\u30af\u30b9\u306e\u4f4d\u7f6e\u306b\u3042\u308b\u3001\u30ce\u30fc\u30c9\u304c\u66f4\u65b0\u3055\u308c\u3066\u3044\u308b\u304b\u3069\u3046\u304b\u306e\u30c6\u30b9\u30c8\u306a\u3093\u3067\u3064\u306a\u3002\n\n### max_n_test\n\n```erlang \n-spec max_n(N :: integer(), CHash :: chash()) -> integer().\n\n...\n\nmax_n_test() ->\n    CHash = chash:fresh(8, the_node),\n    ?assertEqual(1, max_n(1,CHash)),\n    ?assertEqual(8, max_n(11,CHash)).\n```\n\n\u306f\u3044\u3001\u307e\u3041\u3001n\u304c\u30d1\u30fc\u30c6\u30a3\u30b7\u30e7\u30f3\u306e\u6570\u3092\u8d85\u3048\u306a\u3044\u3088\u3046\u306b\u3059\u308b\u3084\u3064\u3067\u3064\u306d\u3002\n\n### simple_size_test\n\n```erlang\nsimple_size_test() ->\n    ?assertEqual(8, length(chash:nodes(chash:fresh(8,the_node)))).\n```\n\n\u3068\u304f\u306b\u3001\u30b3\u30e1\u30f3\u30c8\u3057\u306a\u304f\u3066\u3082\u3001\u5206\u304b\u308b\u306a\u3002\u307e\u3041\u3001node\u306e\u30ea\u30b9\u30c8\u3092\u53d6\u3063\u3066\u306e\u3001\u9577\u3055\u306e\u30c6\u30b9\u30c8\u3002\n\n### successors_length_test\n\n```erlang \nsuccessors_length_test() ->\n    ?assertEqual(8, length(chash:successors(chash:key_of(0),\n                                            chash:fresh(8,the_node)))).\n```\n\n\u9806\u5217\u304c\u3042\u3063\u3066\u306d\u3063\u3066\u3053\u3068\u304b\u306d\u3002\n\n### inverse_pred_test\n\n```erlang\ninverse_pred_test() ->\n    CHash = chash:fresh(8,the_node),\n    S = [I || {I,_} <- chash:successors(chash:key_of(4),CHash)],\n    P = [I || {I,_} <- chash:predecessors(chash:key_of(4),CHash)],\n    ?assertEqual(S,lists:reverse(P)).\n````\n\n\u307e\u3041\u3001\u9806\u5217\u304c\u3042\u3063\u3066\u3001successors\u3068predecessors\u306f\u9806\u65b9\u5411\u304b\u3001\u9006\u65b9\u5411\u3063\u3066\u3053\u3068\u304b\u306d\u3002\n\n### merge_test\n\n```erlang\nmerge_test() ->\n    CHashA = chash:fresh(8,node_one),\n    CHashB = chash:update(0,node_one,chash:fresh(8,node_two)),\n    CHash = chash:merge_rings(CHashA,CHashB),\n    ?assertEqual(node_one,chash:lookup(0,CHash)).\n```\n\n\u30de\u30fc\u30b8\u3059\u308b\u3093\u3088\u3002\n\n## \u5b9f\u88c5\u3092\u8aad\u3080\n\n\u3055\u3066\u3001\u5b9f\u88c5\u3092\u8aad\u3093\u3067\u3044\u304f\u3088\u3002\n### contains_name\n```erlang\n%% @doc Return true if named Node owns any partitions in the ring, else false.\n-spec contains_name(Name :: chash_node(), CHash :: chash()) -> boolean().\ncontains_name(Name, CHash) ->\n    {_NumPartitions, Nodes} = CHash,\n    [X || {_,X} <- Nodes, X == Name] =/= [].\n```\n\nchash\u306b\u3001\u540d\u524d\u304c\u542b\u307e\u308c\u3066\u3044\u308b\u304b\u3092\u8abf\u3079\u308b\u3093\u3088\u3002\u307e\u3041\u3001\u30ea\u30b9\u30c8\u5185\u5305\u8868\u8a18\u3067\u3084\u3063\u3066\u308b\u3002\n\n### fresh\u3068ring_increment\n\n```erlang\n-define(RINGTOP, trunc(math:pow(2,160)-1)).  % SHA-1 space\n\n...\n\n%% @doc Create a brand new ring.  The size and seednode are specified;\n%%      initially all partitions are owned by the seednode.  If NumPartitions\n%%      is not much larger than the intended eventual number of\n%%       participating nodes, then performance will suffer.\n-spec fresh(NumPartitions :: num_partitions(), SeedNode :: chash_node()) -> chash().\nfresh(NumPartitions, SeedNode) ->\n    Inc = ring_increment(NumPartitions),\n    {NumPartitions, [{IndexAsInt, SeedNode} ||\n           IndexAsInt <- lists:seq(0,(?RINGTOP-1),Inc)]}.\n\n...\n\n%% @doc Return increment between ring indexes given\n%% the number of ring partitions.\n-spec ring_increment(NumPartitions :: pos_integer()) -> pos_integer().\nring_increment(NumPartitions) ->\n    ?RINGTOP div NumPartitions.\n```\n\n\u306a\u308b\u307b\u3069\u3002SHA1\u3060\u304b\u3089\u3001160\u30d3\u30c3\u30c8\u3002\u3093\u3067\u30012\u306e160\u4e57\u3002\u305d\u308c\u3092\u3001\u30d1\u30fc\u30c6\u30a3\u30b7\u30e7\u30f3\u3067\u5206\u5272\u3057\u3066\u3001\u305d\u308c\u3092\u30a4\u30f3\u30af\u30ea\u30e1\u30f3\u30c8\u306e\u5024\u3068\u3057\u3066\u3001\u30a4\u30f3\u30c7\u30c3\u30af\u30b9\u306e\u5024\u3092\u6c7a\u5b9a\u3057\u3066\u3044\u308b\u306e\u306d\u3002\n\n### lookup\n\n```erlang\n%% @doc Find the Node that owns the partition identified by IndexAsInt.\n-spec lookup(IndexAsInt :: index_as_int(), CHash :: chash()) -> chash_node().\nlookup(IndexAsInt, CHash) ->\n    {_NumPartitions, Nodes} = CHash,\n    {IndexAsInt, X} = proplists:lookup(IndexAsInt, Nodes),\n    X.\n```\n\n\u3053\u308c\u3082\u3001\u7c21\u5358\u3060\u306a\u3002\u30a4\u30f3\u30c7\u30c3\u30af\u30b9\u304b\u3089\u53d6\u3063\u3066\u304f\u308b\u3060\u3051\u3067\u3057\u3087?\n\n### key_of\n\n```erlang\n-ifndef(old_hash).\nsha(Bin) ->\n    crypto:hash(sha, Bin).\n-else.\nsha(Bin) ->\n    crypto:sha(Bin).\n-endif.\n\n...\n \n%% @doc Given any term used to name an object, produce that object's key\n%%      into the ring.  Two names with the same SHA-1 hash value are\n%%      considered the same name.\n-spec key_of(ObjectName :: term()) -> index().\nkey_of(ObjectName) ->    \n    sha(term_to_binary(ObjectName)).\n```\n\n\u307e\u3041\u3001\u30cf\u30c3\u30b7\u30e5\u95a2\u6570\u8aad\u3093\u3067\u308b\u3060\u3051\u3060\u306a\u3002\n\n### members\n\n```erlang\n%% @doc Return all Nodes that own any partitions in the ring.\n-spec members(CHash :: chash()) -> [chash_node()].\nmembers(CHash) ->\n    {_NumPartitions, Nodes} = CHash,\n    lists:usort([X || {_Idx,X} <- Nodes]).\n```\n\n\u30ce\u30fc\u30c9\u306e\u30e1\u30f3\u30d0\u30fc\u5168\u90e8\u306e\u30ea\u30b9\u30c8\u3092\u3064\u304f\u308b\u3002\n\n### merge_ring\n\n```erlang\n%% @doc Return a randomized merge of two rings.\n%%      If multiple nodes are actively claiming nodes in the same\n%%      time period, churn will occur.  Be prepared to live with it.\n-spec merge_rings(CHashA :: chash(), CHashB :: chash()) -> chash().\nmerge_rings(CHashA,CHashB) ->\n    {NumPartitions, NodesA} = CHashA,\n    {NumPartitions, NodesB} = CHashB,\n    {NumPartitions, [{I,random_node(A,B)} || \n           {{I,A},{I,B}} <- lists:zip(NodesA,NodesB)]}.\n```\n\nring\u3092\u30de\u30fc\u30b8\u3059\u308b\u3002\u524d\u63d0\u3068\u3057\u3066\u30d1\u30fc\u30c6\u30a3\u30b7\u30e7\u30f3\u306e\u6570\u304c\u540c\u3058\u306echash\u540c\u58eb\u3092\u30de\u30fc\u30b8\u3059\u308b\u3002\u306a\u3093\u304b\u3001\u30e9\u30f3\u30c0\u30e0\u306bnode\u3092\u9078\u629e\u3059\u308b\u3002\n\n### next_index\n\n```erlang\n%% @doc Given the integer representation of a chash key,\n%%      return the next ring index integer value.\n-spec next_index(IntegerKey :: integer(), CHash :: chash()) -> index_as_int().\nnext_index(IntegerKey, {NumPartitions, _}) ->\n        Inc = ring_increment(NumPartitions),\n        (((IntegerKey div Inc) + 1) rem NumPartitions) * Inc.\n```\n\n\u6b21\u306e\u30a4\u30f3\u30c7\u30c3\u30af\u30b9\u3092\u8fd4\u3059\u95a2\u6570\u3002\n\n### nodes\n\n```erlang\n%% @doc Return the entire set of NodeEntries in the ring.\n-spec nodes(CHash :: chash()) -> [node_entry()].\nnodes(CHash) ->\n    {_NumPartitions, Nodes} = CHash,\n    Nodes.\n```\n\n\u7c21\u5358\u3002\n\n### ordered_from\n\n```erlang\n%% @doc Given an object key, return all NodeEntries in order starting at Index.\n-spec ordered_from(Index :: index(), CHash :: chash()) -> [node_entry()].\nordered_from(Index, {NumPartitions, Nodes}) ->\n    <<IndexAsInt:160/integer>> = Index,\n    Inc = ring_increment(NumPartitions),\n    {A, B} = lists:split((IndexAsInt div Inc)+1, Nodes),\n    B ++ A.\n```\n\n\u307b\u3049\u30fc\u3002ring\u3060\u304b\u3089\u3001\u306a\u3093\u304b\u3001\u30b0\u30eb\u30b0\u30eb\u5468\u308b\u30a4\u30e1\u30fc\u30b8\u304c\u3057\u3066\u826f\u3044\u306a\u3002\n\n### predecessors\u3068successors\n\n```erlang\n%% @doc Given an object key, return all NodeEntries in reverse order\n%%      starting at Index.\n-spec predecessors(Index :: index() | index_as_int(), CHash :: chash()) -> [node_entry()].\npredecessors(Index, CHash) ->\n    {NumPartitions, _Nodes} = CHash,\n    predecessors(Index, CHash, NumPartitions).\n%% @doc Given an object key, return the next N NodeEntries in reverse order\n%%      starting at Index.\n-spec predecessors(Index :: index() | index_as_int(), CHash :: chash(), N :: integer())\n                  -> [node_entry()].\npredecessors(Index, CHash, N) when is_integer(Index) ->\n    predecessors(<<Index:160/integer>>, CHash, N);\npredecessors(Index, CHash, N) ->\n    Num = max_n(N, CHash),\n    {Res, _} = lists:split(Num, lists:reverse(ordered_from(Index,CHash))),\n    Res.\n\n...\n\n\n%% @doc Given an object key, return all NodeEntries in order starting at Index.\n-spec successors(Index :: index(), CHash :: chash()) -> [node_entry()].\nsuccessors(Index, CHash) ->\n    {NumPartitions, _Nodes} = CHash,\n    successors(Index, CHash, NumPartitions).\n\n%% @doc Given an object key, return the next N NodeEntries in order\n%%      starting at Index.\n-spec successors(Index :: index(), CHash :: chash(), N :: integer())\n                -> [node_entry()].\nsuccessors(Index, CHash, N) ->\n    Num = max_n(N, CHash),\n    Ordered = ordered_from(Index, CHash),\n    {NumPartitions, _Nodes} = CHash,\n    if Num =:= NumPartitions ->\n\t    Ordered;\n       true ->\n\t    {Res, _} = lists:split(Num, Ordered),\n\t    Res\n    end.\n```\n\n### size\n\n```erlang\n%% @doc Return the number of partitions in the ring.\n-spec size(CHash :: chash()) -> integer().\nsize(CHash) ->\n    {_NumPartitions,Nodes} = CHash,\n    length(Nodes).\n```\n\n\u5b9f\u88c5\u306f\u7c21\u5358\u3002\n\n### update\n\n```erlang\n%% @doc Make the partition beginning at IndexAsInt owned by Name'd node.\n-spec update(IndexAsInt :: index_as_int(), Name :: chash_node(), CHash :: chash())\n            -> chash().\nupdate(IndexAsInt, Name, CHash) ->\n    {NumPartitions, Nodes} = CHash,\n    NewNodes = lists:keyreplace(IndexAsInt, 1, Nodes, {IndexAsInt, Name}),\n    {NumPartitions, NewNodes}.\n```\n\n\u7c21\u5358\u3067\u3064\u306d\u3002\n", "tags": ["Erlang", "riak", "riak_core"]}