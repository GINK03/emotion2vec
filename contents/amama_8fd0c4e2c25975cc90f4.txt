{"context": " More than 1 year has passed since last update.\n\n12\u65e5\u76ee\n\u3084\u308b\u304d\u304c\u3067\u306a\u3044\n\n2.3.4\n\u300c\u30b3\u30f3\u30d1\u30a4\u30eb\u300d\u306f\u30b9\u30c6\u30fc\u30c8\u30de\u30b7\u30f3\u306b\u5fc5\u8981\u306a\u60c5\u5831\u3092\u63c3\u3048\u308b\u3053\u3068.\n\u3064\u307e\u308a,\u5165\u529b\u304b\u3089\u521d\u671f\u72b6\u614b\u3092\u4f5c\u308b\u3053\u3068\u3057\u304b\u3057\u306a\u3044.\n\n2.3.5\n\u3080\u3064\u304b\u3057\u3044\nTaking a step\u304c\u308f\u304b\u3089\u306a\u3044\nimport Language\nimport Utils\n\nrunProg :: String -> String\nrunProg = showResults . eval . compile . parse\n\ncompile :: CoreProgram -> TiState\n\neval :: TiState -> [TiState]\n\nshowResults :: [TiState] -> String\n\ntype TiState = (TiStack, TiDump, TiHeap, TiGlobals, TiStats)\ntype TiStack = [Addr]\ndata TiDump = DummyTiDump\ninitialTiDump = DummyTiDump\ntype TiHeap = Heap Node\ndata Node = NAp Addr Addr -- Application\n    | NSupercomb Name [Name] CoreExpr -- Supercombinator\n    | NNum Int\n\ntype TiGlobals = ASSOC Name Addr\ntiStatInitial :: TiStats\ntiStatIncSteps :: TiStats -> TiStats\ntiStatGetSteps :: TiStats -> Int\ntype TiStats = Int\ntiStatInitial = 0\ntiStatIncSteps s = s+1\ntiStatGetSteps s = s\n\napplyToStats :: (TiStats -> TiStats) -> TiState -> TiState\napplyToStats stats_fun (stack, dump, heap, sc_defs, stats) = (stack, dump, heap, sc_defs, stats_fun stats)\ncompile program = (initial_stack, initialTiDump, initial_heap, globals, tiStatInitial)\n    where\n    sc_defs = program ++ preludeDefs ++ extraPreludeDefs\n    (initial_heap, globals) = buildInitialHeap sc_defs\n    initial_stack = [address_of_main]\n    address_of_main = aLookup globals \"main\" (error \"main is not defined\")\n\nextraPreludeDefs = []\n\nbuildInitialHeap :: [CoreScDefn] -> (TiHeap, TiGlobals)\nbuildInitialHeap sc_defs = mapAccuml allocateSc hInitial sc_defs\n\nallocateSc :: TiHeap -> CoreScDefn -> (TiHeap, (Name, Addr))\nallocateSc heap (name, args, body) = (heap', (name, addr))\n    where\n    (heap', addr) = hAlloc heap (NSupercomb name args body)\n\neval state = state : rest_states\n    where\n    rest_states | tiFinal state = []\n                | otherwise = eval next_state\n    next_state = doAdmin (step state)\n\ndoAdmin :: TiState -> TiState\ndoAdmin state = applyToStats tiStatIncSteps state\n\ntiFinal :: TiState -> Bool\ntiFinal ([sole_addr], dump, heap, globals, stats) = isDataNode (hLookup heap sole_addr)\ntiFinal ([], dump, heap, globals, stats) = error \"Empty stack!\"\ntiFinal state = False -- Stack contains more than one item\n\nisDataNode :: Node -> Bool\nisDataNode (NNum n) = True\nisDataNode node = False\n\nstep :: TiState -> TiState\nstep state = dispatch (hLookup heap (hd stack))\n    where\n    (stack, dump, heap, globals, stats) = state\n    dispatch (NNum n) = numStep state n\n    dispatch (NAp a1 a2) = apStep state a1 a2\n    dispatch (NSupercomb sc args body) = scStep state sc args body\n\nnumStep :: TiState -> Int -> TiState\nnumStep state n = error \"Number applied as a function!\"\n\napStep :: TiState -> Addr -> Addr -> TiState\napStep (stack, dump, heap, globals, stats) a1 a2 = (a1 : stack, dump, heap, globals, stats)\n\n\nmain :: IO ()\n--main = putStrLn $ iDisplay $ pprExpr (ELet nonRecursive [(\"att\", ENum 2)] (EAp (EAp (EVar \"+\") (EVar \"att\")) (EVar \"1\")))\nmain = putStrLn( pprint $ parse  \"f=3;\\ng x y = let z = x in z ;\\nh x = case (let y = x in y) of\\n<1> -> 2 ;\\n<2> -> 5;\\n i = g (1 + 2 * 3) (5 - 1 / 2)\")\n--main = putStrLn $ show $ pOneOrMoreWithSep (pLit \"x\") (pLit \";\") [(1,\"x\"),(1,\";\"),(1,\"x\") ,(1,\";\"),(2,\"x\"),(2,\";\"),(2,\"x\"),(2,\";\"),(2,\"x\") ]\n--main = putStrLn $ show $ pExpr [(2,\"let\"),(2,\"z\"),(2,\"=\"),(2,\"x\"),(2,\"in\"),(2,\"z\")]\n--main = putStrLn $ pprint $ syntax [(1,\"f\"),(1,\"=\"),(1,\"3\") ,(1,\";\"),(2,\"g\"),(2,\"x\"),(2,\"y\"),(2,\"=\"), (2,\"let\"),(2,\"z\"),(2,\"=\"),(2,\"x\"),(2,\"in\"),(2,\"z\"),(2,\";\"),(3,\"h\"),(3,\"x\"),(3,\"=\"),(3,\"case\"),(3,\"(\"),(3,\"let\"),(3,\"y\"),(3,\"=\"),(3,\"x\"),(3,\"in\"),(3,\"y\"),(3,\")\"),(3,\"of\"),(4,\"<\"),(4,\"1\"),(4,\">\"),(4,\"->\"),(4,\"2\"),(4,\";\"),(5,\"<\"),(5,\"2\"),(5,\">\"),(5,\"->\"),(5,\"5\")]\n\n58\u30da\u30fc\u30b8\u307e\u3067\u8aad\u3093\u3060\n# 12\u65e5\u76ee\n\n\u3084\u308b\u304d\u304c\u3067\u306a\u3044\n\n## 2.3.4\n\u300c\u30b3\u30f3\u30d1\u30a4\u30eb\u300d\u306f\u30b9\u30c6\u30fc\u30c8\u30de\u30b7\u30f3\u306b\u5fc5\u8981\u306a\u60c5\u5831\u3092\u63c3\u3048\u308b\u3053\u3068.\n\u3064\u307e\u308a,\u5165\u529b\u304b\u3089\u521d\u671f\u72b6\u614b\u3092\u4f5c\u308b\u3053\u3068\u3057\u304b\u3057\u306a\u3044.\n\n## 2.3.5\n\u3080\u3064\u304b\u3057\u3044\nTaking a step\u304c\u308f\u304b\u3089\u306a\u3044\n\n```hs\nimport Language\nimport Utils\n\nrunProg :: String -> String\nrunProg = showResults . eval . compile . parse\n\ncompile :: CoreProgram -> TiState\n\neval :: TiState -> [TiState]\n\nshowResults :: [TiState] -> String\n\ntype TiState = (TiStack, TiDump, TiHeap, TiGlobals, TiStats)\ntype TiStack = [Addr]\ndata TiDump = DummyTiDump\ninitialTiDump = DummyTiDump\ntype TiHeap = Heap Node\ndata Node = NAp Addr Addr -- Application\n    | NSupercomb Name [Name] CoreExpr -- Supercombinator\n    | NNum Int\n\ntype TiGlobals = ASSOC Name Addr\ntiStatInitial :: TiStats\ntiStatIncSteps :: TiStats -> TiStats\ntiStatGetSteps :: TiStats -> Int\ntype TiStats = Int\ntiStatInitial = 0\ntiStatIncSteps s = s+1\ntiStatGetSteps s = s\n\napplyToStats :: (TiStats -> TiStats) -> TiState -> TiState\napplyToStats stats_fun (stack, dump, heap, sc_defs, stats) = (stack, dump, heap, sc_defs, stats_fun stats)\ncompile program = (initial_stack, initialTiDump, initial_heap, globals, tiStatInitial)\n    where\n    sc_defs = program ++ preludeDefs ++ extraPreludeDefs\n    (initial_heap, globals) = buildInitialHeap sc_defs\n    initial_stack = [address_of_main]\n    address_of_main = aLookup globals \"main\" (error \"main is not defined\")\n\nextraPreludeDefs = []\n\nbuildInitialHeap :: [CoreScDefn] -> (TiHeap, TiGlobals)\nbuildInitialHeap sc_defs = mapAccuml allocateSc hInitial sc_defs\n\nallocateSc :: TiHeap -> CoreScDefn -> (TiHeap, (Name, Addr))\nallocateSc heap (name, args, body) = (heap', (name, addr))\n    where\n    (heap', addr) = hAlloc heap (NSupercomb name args body)\n\neval state = state : rest_states\n    where\n    rest_states | tiFinal state = []\n                | otherwise = eval next_state\n    next_state = doAdmin (step state)\n\ndoAdmin :: TiState -> TiState\ndoAdmin state = applyToStats tiStatIncSteps state\n\ntiFinal :: TiState -> Bool\ntiFinal ([sole_addr], dump, heap, globals, stats) = isDataNode (hLookup heap sole_addr)\ntiFinal ([], dump, heap, globals, stats) = error \"Empty stack!\"\ntiFinal state = False -- Stack contains more than one item\n\nisDataNode :: Node -> Bool\nisDataNode (NNum n) = True\nisDataNode node = False\n\nstep :: TiState -> TiState\nstep state = dispatch (hLookup heap (hd stack))\n    where\n    (stack, dump, heap, globals, stats) = state\n    dispatch (NNum n) = numStep state n\n    dispatch (NAp a1 a2) = apStep state a1 a2\n    dispatch (NSupercomb sc args body) = scStep state sc args body\n\nnumStep :: TiState -> Int -> TiState\nnumStep state n = error \"Number applied as a function!\"\n\napStep :: TiState -> Addr -> Addr -> TiState\napStep (stack, dump, heap, globals, stats) a1 a2 = (a1 : stack, dump, heap, globals, stats)\n\n\nmain :: IO ()\n--main = putStrLn $ iDisplay $ pprExpr (ELet nonRecursive [(\"att\", ENum 2)] (EAp (EAp (EVar \"+\") (EVar \"att\")) (EVar \"1\")))\nmain = putStrLn( pprint $ parse  \"f=3;\\ng x y = let z = x in z ;\\nh x = case (let y = x in y) of\\n<1> -> 2 ;\\n<2> -> 5;\\n i = g (1 + 2 * 3) (5 - 1 / 2)\")\n--main = putStrLn $ show $ pOneOrMoreWithSep (pLit \"x\") (pLit \";\") [(1,\"x\"),(1,\";\"),(1,\"x\") ,(1,\";\"),(2,\"x\"),(2,\";\"),(2,\"x\"),(2,\";\"),(2,\"x\") ]\n--main = putStrLn $ show $ pExpr [(2,\"let\"),(2,\"z\"),(2,\"=\"),(2,\"x\"),(2,\"in\"),(2,\"z\")]\n--main = putStrLn $ pprint $ syntax [(1,\"f\"),(1,\"=\"),(1,\"3\") ,(1,\";\"),(2,\"g\"),(2,\"x\"),(2,\"y\"),(2,\"=\"), (2,\"let\"),(2,\"z\"),(2,\"=\"),(2,\"x\"),(2,\"in\"),(2,\"z\"),(2,\";\"),(3,\"h\"),(3,\"x\"),(3,\"=\"),(3,\"case\"),(3,\"(\"),(3,\"let\"),(3,\"y\"),(3,\"=\"),(3,\"x\"),(3,\"in\"),(3,\"y\"),(3,\")\"),(3,\"of\"),(4,\"<\"),(4,\"1\"),(4,\">\"),(4,\"->\"),(4,\"2\"),(4,\";\"),(5,\"<\"),(5,\"2\"),(5,\">\"),(5,\"->\"),(5,\"5\")]\n```\n\n**58\u30da\u30fc\u30b8\u307e\u3067\u8aad\u3093\u3060**\n", "tags": ["\u30a4\u30f3\u30d7\u30ea\u30e1\u30f3\u30c6\u30a3\u30f3\u30b0\u30d5\u30a1\u30f3\u30af\u30b7\u30e7\u30ca\u30eb\u30e9\u30f3\u30b2\u30fc\u30b8\u30ba"]}