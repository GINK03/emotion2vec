{"context": " More than 1 year has passed since last update.\n\n\u30b3\u30fc\u30c9\u5b9f\u88c5\u4f8b\n\n\u7279\u7570\u5024\u5206\u89e3\uff08SVD\uff09 \u306e\u30b3\u30fc\u30c9\u5b9f\u88c5\u306b\u3064\u3044\u3066\u306f\u3001\u548c\u6587\u30fb\u82f1\u6587\u3068\u3082\u306b\u3001\u30a6\u30a7\u30d6\u4e0a\u306b\u30b3\u30fc\u30c9\u63b2\u8f09\u4e8b\u4f8b\u306b\u4e4f\u3057\u3044\u3002Python\u30b3\u30fc\u30c9\u306b\u5909\u63db\u3059\u308b\u4e0a\u3067\u624b\u3054\u308d\u306a\u30b9\u30af\u30ea\u30d7\u30c8\u3092\u8abf\u67fb\u4e2d\u3067\u3059\u3002__\n\n\u9014\u4e2d\u7d4c\u904e\u5831\u544a\u307e\u3067\u3001\u308f\u305a\u304b\u306b\u898b\u3064\u304b\u3063\u305f\u30b3\u30fc\u30c9\u63b2\u8f09URL\u3068\u63b2\u8f09\u30b3\u30fc\u30c9\u3092\u8a18\u3057\u307e\u3059\u3002\n\nNumerical Recipes  \n\n\nC++ source code\n///\n// Driver for Singular Value Decomposition routine\n// for Numerical Recipes Version 3\n//\n// Data file format:\n//        First line is a comment line (a throwaway)\n//        Second line has number of rows and number of columns\n//        Successive lines have elements in row-major order\n//\n// davekw7x\n//\n\n//\n// Put whatever path you need for the NR3 source files\n#include \"../code/nr3.h\"\n#include \"../code/svd.h\"\n\nint main(int argc, char **argv)\n{\n    const char *inname = \"matrx.dat\";\n    int numRows, numCols;\n    string inLine;\n\n    if (argc > 1) {\n        inname = argv[1];\n    }\n\n    ifstream inFile(inname);\n    if (!inFile) {\n        cout << \"Can't open file \" << inname << \" for reading.\" << endl;\n        exit(EXIT_FAILURE);\n    }\n    else {\n        cout << \"Opened file \" << inname << \" for reading.\" << endl;\n    }\n    // Read and discard first line\n    getline(inFile, inLine);\n\n    // Second line has number of rows and columns\n    getline(inFile, inLine); // Will discard rest of line\n\n    stringstream ss(inLine);\n    ss >> numRows >> numCols;\n\n    if (!inFile || !ss) {\n        cout << \"Invalid input: Can't read number of rows and columns.\" << endl;\n        exit(EXIT_FAILURE);\n    }\n    cout << \"Reading matrix with \" << numRows \n         << \" rows and \" << numCols << \" columns.\"\n         << endl;\n\n    MatDoub a(numRows,numCols);\n\n\n    // Read the matrix elements\n    for (int i = 0; i < a.nrows(); i++) {\n        for (int j = 0; j < a.ncols(); j++) {\n          inFile >> a[i][j];\n          if (!inFile) {\n              cout << \"Problem reading a[\" << i << \"][\" << j << \"]\" << endl;\n              exit(EXIT_FAILURE);\n          }\n        }\n    }\n    //\n    // Instantiation performs the svd decomposition\n    SVD svd(a);\n\n    // All we are really interested in are the svd values,\n    // i.e. the vector that represents the diagonal of\n    // the matrix \"w,\" but I'll print out all of the\n    // decomposition matrix elements for check purposes.\n    //\n    cout << \"*********After decomposition***********\" << endl;\n    cout << \"Matrix svd.u\" << endl;\n    cout << fixed << setprecision(6);\n\n    for (int i=0; i < svd.u.nrows(); i++) {\n        for (int j = 0; j < svd.u.ncols(); j++) {\n            cout << setw(12) << svd.u[i][j];\n        }\n        cout << endl;\n    }\n\n    // These are what we are really interested in:\n    cout << \"Diagonal of matrix w (svd.w)\" << endl;\n    for (int ii = 0; ii < svd.w.size(); ii++) {\n        cout << setw(12) << svd.w[ii];\n    }\n\n    cout << endl << \"Matrix v-transpose (svd.v)\" << endl;\n    for (int i = 0; i < svd.v.nrows(); i++) {\n        for (int j = 0; j < svd.v.ncols(); j++) {\n            cout << setw(12) << svd.v[j][i];\n        }\n        cout << endl;\n    }\n\n    cout << endl << \"Check the product against the original matrix:\" << endl;\n    cout << \"Original matrix:\" << endl;\n    for (int i = 0; i < a.nrows(); i++) {\n        for (int j = 0; j < a.ncols(); j++) {\n            cout << setw(12) << a[i][j];\n        }\n        cout << endl;\n    }\n\n    //\n    // A short-hand calculation, depending on our intimate\n    // knowledge of the nature of the matrices and our\n    // familiarity with matrix operations, namely the fact\n    // that w is diagonal.\n    //\n    cout << \"Product u*w*(v-transpose):\" << endl;\n    for (int i = 0; i < numRows; i++) {\n        for (int j = 0; j < numCols; j++) {\n            a[i][j] = 0.0;\n            for (int k = 0; k < numCols; k++) {\n                a[i][j] += svd.u[i][k] * svd.w[k] * svd.v[j][k];\n            }\n        }\n    }\n\n    for (int i = 0; i < a.nrows(); i++) {\n        for (int j = 0;j < numCols; j++) {\n            cout << setw(12) << a[i][j];\n        }\n        cout << endl;\n    }\n    inFile.close();\n\n    return 0;\n}\n\n\n\n\nNumerical Recipes in C\nThe Art of Scientific Computing\nSecond Edition\n\n\nSVD Algorithm\nHere is the algorithm for constructing the singular value decomposition of any\nmatrix. See \u00a711.2\u2013\u00a711.3, and also [4-5], for discussion relating to the underlying\nmethod\n\n\nsouce\n#include <math.h>\n#include \"nrutil.h\"\nvoid svdcmp(float **a, int m, int n, float w[], float **v)\nGiven a matrix a[1..m][1..n], this routine computes its singular value decomposition, A =\nU \u00b7W \u00b7V T . The matrix U replaces a on output. The diagonal matrix of singular values W is output\nas a vector w[1..n]. The matrix V (not the transpose V T ) is output as v[1..n][1..n].\n{\nfloat pythag(float a, float b);\nint flag,i,its,j,jj,k,l,nm;\nfloat anorm,c,f,g,h,s,scale,x,y,z,*rv1;\nrv1=vector(1,n);\ng=scale=anorm=0.0; Householder reduction to bidiagonal form.\nfor (i=1;i<=n;i++) {\nl=i+1;\nrv1[i]=scale*g;\ng=s=scale=0.0;\nif (i <= m) {\nfor (k=i;k<=m;k++) scale += fabs(a[k][i]);\nif (scale) {\nfor (k=i;k<=m;k++) {\na[k][i] /= scale;\ns += a[k][i]*a[k][i];\n}\nf=a[i][i];\ng = -SIGN(sqrt(s),f);\nh=f*g-s;\na[i][i]=f-g;\nfor (j=l;j<=n;j++) {\nfor (s=0.0,k=i;k<=m;k++) s += a[k][i]*a[k][j];\nf=s/h;\nfor (k=i;k<=m;k++) a[k][j] += f*a[k][i];\n}\nfor (k=i;k<=m;k++) a[k][i] *= scale;\n}\n}\nw[i]=scale *g;\ng=s=scale=0.0;\nif (i <= m && i != n) {\nfor (k=l;k<=n;k++) scale += fabs(a[i][k]);\nif (scale) {\nfor (k=l;k<=n;k++) {\na[i][k] /= scale;\ns += a[i][k]*a[i][k];\n}\nf=a[i][l];\ng = -SIGN(sqrt(s),f);\nh=f*g-s;\na[i][l]=f-g;\nfor (k=l;k<=n;k++) rv1[k]=a[i][k]/h;\nfor (j=l;j<=m;j++) {\nfor (s=0.0,k=l;k<=n;k++) s += a[j][k]*a[i][k];\nfor (k=l;k<=n;k++) a[j][k] += s*rv1[k];\n}\nfor (k=l;k<=n;k++) a[i][k] *= scale;\n}\n}\nanorm=FMAX(anorm,(fabs(w[i])+fabs(rv1[i])));\n}\nfor (i=n;i>=1;i--) { Accumulation of right-hand transformations.\nif (i < n) {\nif (g) {\nfor (j=l;j<=n;j++) Double division to avoid possible underflow.\nv[j][i]=(a[i][j]/a[i][l])/g;\nfor (j=l;j<=n;j++) {\nfor (s=0.0,k=l;k<=n;k++) s += a[i][k]*v[k][j];\nfor (k=l;k<=n;k++) v[k][j] += s*v[k][i];\n}\n}\nfor (j=l;j<=n;j++) v[i][j]=v[j][i]=0.0;\n}\nv[i][i]=1.0;\ng=rv1[i];\nl=i;\n}\nfor (i=IMIN(m,n);i>=1;i--) { Accumulation of left-hand transformations.\nl=i+1;\ng=w[i];\nfor (j=l;j<=n;j++) a[i][j]=0.0;\nif (g) {\ng=1.0/g;\nfor (j=l;j<=n;j++) {\nfor (s=0.0,k=l;k<=m;k++) s += a[k][i]*a[k][j];\nf=(s/a[i][i])*g;\nfor (k=i;k<=m;k++) a[k][j] += f*a[k][i];\n}\nfor (j=i;j<=m;j++) a[j][i] *= g;\n} else for (j=i;j<=m;j++) a[j][i]=0.0;\n++a[i][i];\n}\nfor (k=n;k>=1;k--) { Diagonalization of the bidiagonal form: Loop over\nfor (its=1;its<=30;its++) { singular values, and over allowed iterations.\nflag=1;\nfor (l=k;l>=1;l--) { Test for splitting.\nnm=l-1; Note that rv1[1] is always zero.\nif ((float)(fabs(rv1[l])+anorm) == anorm) {\nflag=0;\nbreak;\n}\nif ((float)(fabs(w[nm])+anorm) == anorm) break;\n}\nif (flag) {\nc=0.0; Cancellation of rv1[l], if l > 1.\ns=1.0;\nfor (i=l;i<=k;i++) {\nf=s*rv1[i];\nrv1[i]=c*rv1[i];\nif ((float)(fabs(f)+anorm) == anorm) break;\ng=w[i];\nh=pythag(f,g);\nw[i]=h;\nh=1.0/h;\nc=g*h;\ns = -f*h;\nfor (j=1;j<=m;j++) {\ny=a[j][nm];\nz=a[j][i];\na[j][nm]=y*c+z*s;\na[j][i]=z*c-y*s;\n}\n}\n}\nz=w[k];\nif (l == k) { Convergence.\nif (z < 0.0) { Singular value is made nonnegative.\nw[k] = -z;\nfor (j=1;j<=n;j++) v[j][k] = -v[j][k];\n}\nbreak;\n}\nif (its == 30) nrerror(\"no convergence in 30 svdcmp iterations\");\nx=w[l]; Shift from bottom 2-by-2 minor.\nnm=k-1;\ny=w[nm];\ng=rv1[nm];\nh=rv1[k];\nf=((y-z)*(y+z)+(g-h)*(g+h))/(2.0*h*y);\ng=pythag(f,1.0);\nf=((x-z)*(x+z)+h*((y/(f+SIGN(g,f)))-h))/x;\nc=s=1.0; Next QR transformation:\nfor (j=l;j<=nm;j++) {\ni=j+1;\ng=rv1[i];\ny=w[i];\nh=s*g;\ng=c*g;\nz=pythag(f,h);\nrv1[j]=z;\nc=f/z;\ns=h/z;\nf=x*c+g*s;\ng = g*c-x*s;\nh=y*s;\ny *= c;\nfor (jj=1;jj<=n;jj++) {\nx=v[jj][j];\nz=v[jj][i];\nv[jj][j]=x*c+z*s;\nv[jj][i]=z*c-x*s;\n}\nz=pythag(f,h);\nw[j]=z; Rotation can be arbitrary if z = 0.\nif (z) {\nz=1.0/z;\nc=f*z;\ns=h*z;\n}\nf=c*g+s*y;\nx=c*y-s*g;\nfor (jj=1;jj<=m;jj++) {\ny=a[jj][j];\nz=a[jj][i];\na[jj][j]=y*c+z*s;\na[jj][i]=z*c-y*s;\n}\n}\nrv1[l]=0.0;\nrv1[k]=f;\nw[k]=x;\n}\n}\nfree_vector(rv1,1,n);\n}\n#include <math.h>\n#include \"nrutil.h\"\nfloat pythag(float a, float b)\nComputes (a2 + b2)1/2 without destructive underflow or overflow.\n{\nfloat absa,absb;\nabsa=fabs(a);\nabsb=fabs(b);\nif (absa > absb) return absa*sqrt(1.0+SQR(absb/absa));\ne\n\n\n\n\nPython \u306e\u30e2\u30b8\u30e5\u30fc\u30eb\u3092\u7528\u3044\u305f\u30b3\u30fc\u30c9\u4f8b\n\n\n\u304a\u3063\u3071\u3044\u305d\u3093\uff01 python\u3092\u6570\u5024\u8a08\u7b97\u306b\u4f7f\u3046\u3068\u304d\u306e\u30c6\u30af\u30cb\u30c3\u30af\u3068\u304b\u3092\u307e\u3068\u3081\u3066\u3044\u304d\u305f\u3044\u3002\u300cpython\u3067\u7279\u7570\u5024\u5206\u89e3\u300d\n\u97f3\u697d\u30d7\u30ed\u30b0\u30e9\u30df\u30f3\u30b0\u306e\u8d85\u5165\u9580\uff08\u4eee\uff09 Python / \u97f3\u697d\u60c5\u5831\u51e6\u7406 \u521d\u5fc3\u8005\u304c\u3001\u521d\u5fc3\u8005\u306b\u3082\u5206\u304b\u308b\u3088\u3046\u306a\u8a18\u4e8b\u3092\u66f8\u304d\u305f\u3044\u3002\u300c\u3010Python\u3011SciPy\u306e\u7279\u7570\u5024\u5206\u89e3\u3068\u3082\u3046\u3061\u3087\u3063\u3068\u901f\u3044\u7279\u7570\u5024\u5206\u89e3\u3010SVD\u3011\u300d\n\u7d71\u8a08\u5b66\u901f\u5831 \u300cPython/NumPy\u3067\u7279\u7570\u5024\u5206\u89e3(SVD)\u300d\n\n\n\u7279\u7570\u5024\u5206\u89e3\u306e\u5229\u7528\u5834\u9762\uff08\u30c7\u30fc\u30bf\u89e3\u6790\u30a8\u30f3\u30b8\u30f3\u5185\u3067\u306e\u4f7f\u7528\u4f8b\uff09\n\n1.\u81ea\u7136\u8a00\u8a9e\u51e6\u7406 _(NLP: Natural Language Processing)\n1-1. \u6f5c\u5728\u7684\u610f\u5473\u5206\u6790 (LSA)\n\u672a\u6765\u306f\u50d5\u4ee5\u5916\u306e\u624b\u306e\u4e2d \u300cSciPy\u3092\u7528\u3044\u3066\u6f5c\u5728\u7684\u610f\u5473\u89e3\u6790(LSA)\u300d\n\n\u81ea\u7136\u8a00\u8a9e\u51e6\u7406\u306e\u6280\u6cd5\u306e\uff11\u3064\u306b\u3001\u6f5c\u5728\u7684\u610f\u5473\u89e3\u6790(LSA)\u3068\u3044\u3046\u3082\u306e\u304c\u3042\u308b\u3002\n\u5358\u8a9e\u6587\u66f8\u884c\u5217\uff21\u304c\u3042\u3063\u305f\u5834\u5408\u3001\u7279\u7570\u5024\u5206\u89e3(SVD)\u306b\u3088\u308a\n\uff21=\uff35\u03a3\uff36\n\u306b\u5206\u89e3\u3057\u3001\u7279\u7570\u5024\u3092\u5927\u304d\u3044\u307b\u3046\u304b\u3089k\u500b\u4f7f\u3063\u3066\n\u3000\uff21k=\uff35k\u03a3k\uff36k\n\u306e\u3088\u3046\u306b\u968e\u6570\u306e\u4f4e\u6e1b\u3092\u884c\u3046\u3053\u3068\u3067\u3001\u968e\u6570k\u306e\uff21\u3078\u306e\u8fd1\u4f3c\u3092\u6700\u5c0f\u8aa4\u5dee\u3067\u5f97\u308b\u3053\u3068\u304c\u3067\u304d\u308b\u3002\n\u3064\u307e\u308a\u7279\u7570\u5024\u5206\u89e3\u306e\u8a08\u7b97\u3055\u3048\u3067\u304d\u3066\u3057\u307e\u3048\u3070LSA\u3082\u3059\u3050\u3067\u304d\u308b\u308f\u3051\u3060\u304c\u3001\npython\u306e\u6570\u5024\u89e3\u6790\u30e2\u30b8\u30e5\u30fc\u30ebScipy\u306b\u304b\u304b\u308c\u3070\u7279\u7570\u5024\u5206\u89e3\u3082\u3042\u3063\u3068\u3044\u3046\u9593\u3067\u3042\u308b\u3002\n\nHatena::Diary \u3042\u3089\u3073\u304d\u65e5\u8a18\u3000\u300c\u7279\u7570\u5024\u5206\u89e3\u3068LSI\u306e\u610f\u5473\u300d\nHatena::Diary \u3042\u3089\u3073\u304d\u65e5\u8a18 \u300c\u6f5c\u5728\u7684\u610f\u5473\u30a4\u30f3\u30c7\u30ad\u30b7\u30f3\u30b0\uff08LSI\uff09\u5fb9\u5e95\u5165\u9580\u300d\n\n\u30002.\u591a\u5909\u91cf\u89e3\u6790\n1-2. \u4e3b\u6210\u5206\u5206\u6790 (PCA)\nold school magic \u6a5f\u68b0\u5b66\u7fd2\u3068\u7d71\u8a08\u3068\u30d7\u30ed\u30b0\u30e9\u30df\u30f3\u30b0\u306b\u3064\u3044\u3066\u3061\u3087\u3063\u3068\u305a\u3064\u52c9\u5f37\u3057\u3066\u3044\u304d\u307e\u3059\u3002 \u300cPython\u3067\u4e3b\u6210\u5206\u5206\u6790\u300d\n\n(\u5b9f\u969b\u306b\u306f\u3001scikit-learn\u306e\u4e3b\u6210\u5206\u5206\u6790\u306f\u7279\u7570\u5024\u5206\u89e3\u3068\u8a00\u3046\u624b\u6cd5\u3067\u4e3b\u6210\u5206\u5206\u6790\u3092\u884c\u3063\u3066\u3044\u307e\u3059\u3002)\n\n\n### \u30b3\u30fc\u30c9\u5b9f\u88c5\u4f8b\n\n#### __\u7279\u7570\u5024\u5206\u89e3\uff08SVD\uff09__ \u306e\u30b3\u30fc\u30c9\u5b9f\u88c5\u306b\u3064\u3044\u3066\u306f\u3001\u548c\u6587\u30fb\u82f1\u6587\u3068\u3082\u306b\u3001\u30a6\u30a7\u30d6\u4e0a\u306b\u30b3\u30fc\u30c9\u63b2\u8f09\u4e8b\u4f8b\u306b\u4e4f\u3057\u3044\u3002_Python_\u30b3\u30fc\u30c9\u306b\u5909\u63db\u3059\u308b\u4e0a\u3067\u624b\u3054\u308d\u306a\u30b9\u30af\u30ea\u30d7\u30c8\u3092\u8abf\u67fb\u4e2d\u3067\u3059\u3002__\n\n#### \u9014\u4e2d\u7d4c\u904e\u5831\u544a\u307e\u3067\u3001\u308f\u305a\u304b\u306b\u898b\u3064\u304b\u3063\u305f\u30b3\u30fc\u30c9\u63b2\u8f09URL\u3068\u63b2\u8f09\u30b3\u30fc\u30c9\u3092\u8a18\u3057\u307e\u3059\u3002\n\n* [Numerical Recipes  ](http://www.nr.com/forum/showthread.php?t=2185)\n\n```{C++:C++ source code}\n///\n// Driver for Singular Value Decomposition routine\n// for Numerical Recipes Version 3\n//\n// Data file format:\n//        First line is a comment line (a throwaway)\n//        Second line has number of rows and number of columns\n//        Successive lines have elements in row-major order\n//\n// davekw7x\n//\n\n//\n// Put whatever path you need for the NR3 source files\n#include \"../code/nr3.h\"\n#include \"../code/svd.h\"\n\nint main(int argc, char **argv)\n{\n    const char *inname = \"matrx.dat\";\n    int numRows, numCols;\n    string inLine;\n\n    if (argc > 1) {\n        inname = argv[1];\n    }\n\n    ifstream inFile(inname);\n    if (!inFile) {\n        cout << \"Can't open file \" << inname << \" for reading.\" << endl;\n        exit(EXIT_FAILURE);\n    }\n    else {\n        cout << \"Opened file \" << inname << \" for reading.\" << endl;\n    }\n    // Read and discard first line\n    getline(inFile, inLine);\n\n    // Second line has number of rows and columns\n    getline(inFile, inLine); // Will discard rest of line\n\n    stringstream ss(inLine);\n    ss >> numRows >> numCols;\n\n    if (!inFile || !ss) {\n        cout << \"Invalid input: Can't read number of rows and columns.\" << endl;\n        exit(EXIT_FAILURE);\n    }\n    cout << \"Reading matrix with \" << numRows \n         << \" rows and \" << numCols << \" columns.\"\n         << endl;\n\n    MatDoub a(numRows,numCols);\n\n\n    // Read the matrix elements\n    for (int i = 0; i < a.nrows(); i++) {\n        for (int j = 0; j < a.ncols(); j++) {\n          inFile >> a[i][j];\n          if (!inFile) {\n              cout << \"Problem reading a[\" << i << \"][\" << j << \"]\" << endl;\n              exit(EXIT_FAILURE);\n          }\n        }\n    }\n    //\n    // Instantiation performs the svd decomposition\n    SVD svd(a);\n\n    // All we are really interested in are the svd values,\n    // i.e. the vector that represents the diagonal of\n    // the matrix \"w,\" but I'll print out all of the\n    // decomposition matrix elements for check purposes.\n    //\n    cout << \"*********After decomposition***********\" << endl;\n    cout << \"Matrix svd.u\" << endl;\n    cout << fixed << setprecision(6);\n\n    for (int i=0; i < svd.u.nrows(); i++) {\n        for (int j = 0; j < svd.u.ncols(); j++) {\n            cout << setw(12) << svd.u[i][j];\n        }\n        cout << endl;\n    }\n\n    // These are what we are really interested in:\n    cout << \"Diagonal of matrix w (svd.w)\" << endl;\n    for (int ii = 0; ii < svd.w.size(); ii++) {\n        cout << setw(12) << svd.w[ii];\n    }\n\n    cout << endl << \"Matrix v-transpose (svd.v)\" << endl;\n    for (int i = 0; i < svd.v.nrows(); i++) {\n        for (int j = 0; j < svd.v.ncols(); j++) {\n            cout << setw(12) << svd.v[j][i];\n        }\n        cout << endl;\n    }\n\n    cout << endl << \"Check the product against the original matrix:\" << endl;\n    cout << \"Original matrix:\" << endl;\n    for (int i = 0; i < a.nrows(); i++) {\n        for (int j = 0; j < a.ncols(); j++) {\n            cout << setw(12) << a[i][j];\n        }\n        cout << endl;\n    }\n\n    //\n    // A short-hand calculation, depending on our intimate\n    // knowledge of the nature of the matrices and our\n    // familiarity with matrix operations, namely the fact\n    // that w is diagonal.\n    //\n    cout << \"Product u*w*(v-transpose):\" << endl;\n    for (int i = 0; i < numRows; i++) {\n        for (int j = 0; j < numCols; j++) {\n            a[i][j] = 0.0;\n            for (int k = 0; k < numCols; k++) {\n                a[i][j] += svd.u[i][k] * svd.w[k] * svd.v[j][k];\n            }\n        }\n    }\n\n    for (int i = 0; i < a.nrows(); i++) {\n        for (int j = 0;j < numCols; j++) {\n            cout << setw(12) << a[i][j];\n        }\n        cout << endl;\n    }\n    inFile.close();\n\n    return 0;\n}\n```\n\n\n\n___\n\n\n\n* __[Numerical Recipes in C\nThe Art of Scientific Computing\nSecond Edition](http://www2.units.it/ipl/students_area/imm2/files/Numerical_Recipes.pdf)__\n\n> __SVD Algorithm__\n>\n>Here is the algorithm for constructing the singular value decomposition of any\nmatrix. See \u00a711.2\u2013\u00a711.3, and also [4-5], for discussion relating to the underlying\nmethod\n\n```{C:souce}\n#include <math.h>\n#include \"nrutil.h\"\nvoid svdcmp(float **a, int m, int n, float w[], float **v)\nGiven a matrix a[1..m][1..n], this routine computes its singular value decomposition, A =\nU \u00b7W \u00b7V T . The matrix U replaces a on output. The diagonal matrix of singular values W is output\nas a vector w[1..n]. The matrix V (not the transpose V T ) is output as v[1..n][1..n].\n{\nfloat pythag(float a, float b);\nint flag,i,its,j,jj,k,l,nm;\nfloat anorm,c,f,g,h,s,scale,x,y,z,*rv1;\nrv1=vector(1,n);\ng=scale=anorm=0.0; Householder reduction to bidiagonal form.\nfor (i=1;i<=n;i++) {\nl=i+1;\nrv1[i]=scale*g;\ng=s=scale=0.0;\nif (i <= m) {\nfor (k=i;k<=m;k++) scale += fabs(a[k][i]);\nif (scale) {\nfor (k=i;k<=m;k++) {\na[k][i] /= scale;\ns += a[k][i]*a[k][i];\n}\nf=a[i][i];\ng = -SIGN(sqrt(s),f);\nh=f*g-s;\na[i][i]=f-g;\nfor (j=l;j<=n;j++) {\nfor (s=0.0,k=i;k<=m;k++) s += a[k][i]*a[k][j];\nf=s/h;\nfor (k=i;k<=m;k++) a[k][j] += f*a[k][i];\n}\nfor (k=i;k<=m;k++) a[k][i] *= scale;\n}\n}\nw[i]=scale *g;\ng=s=scale=0.0;\nif (i <= m && i != n) {\nfor (k=l;k<=n;k++) scale += fabs(a[i][k]);\nif (scale) {\nfor (k=l;k<=n;k++) {\na[i][k] /= scale;\ns += a[i][k]*a[i][k];\n}\nf=a[i][l];\ng = -SIGN(sqrt(s),f);\nh=f*g-s;\na[i][l]=f-g;\nfor (k=l;k<=n;k++) rv1[k]=a[i][k]/h;\nfor (j=l;j<=m;j++) {\nfor (s=0.0,k=l;k<=n;k++) s += a[j][k]*a[i][k];\nfor (k=l;k<=n;k++) a[j][k] += s*rv1[k];\n}\nfor (k=l;k<=n;k++) a[i][k] *= scale;\n}\n}\nanorm=FMAX(anorm,(fabs(w[i])+fabs(rv1[i])));\n}\nfor (i=n;i>=1;i--) { Accumulation of right-hand transformations.\nif (i < n) {\nif (g) {\nfor (j=l;j<=n;j++) Double division to avoid possible underflow.\nv[j][i]=(a[i][j]/a[i][l])/g;\nfor (j=l;j<=n;j++) {\nfor (s=0.0,k=l;k<=n;k++) s += a[i][k]*v[k][j];\nfor (k=l;k<=n;k++) v[k][j] += s*v[k][i];\n}\n}\nfor (j=l;j<=n;j++) v[i][j]=v[j][i]=0.0;\n}\nv[i][i]=1.0;\ng=rv1[i];\nl=i;\n}\nfor (i=IMIN(m,n);i>=1;i--) { Accumulation of left-hand transformations.\nl=i+1;\ng=w[i];\nfor (j=l;j<=n;j++) a[i][j]=0.0;\nif (g) {\ng=1.0/g;\nfor (j=l;j<=n;j++) {\nfor (s=0.0,k=l;k<=m;k++) s += a[k][i]*a[k][j];\nf=(s/a[i][i])*g;\nfor (k=i;k<=m;k++) a[k][j] += f*a[k][i];\n}\nfor (j=i;j<=m;j++) a[j][i] *= g;\n} else for (j=i;j<=m;j++) a[j][i]=0.0;\n++a[i][i];\n}\nfor (k=n;k>=1;k--) { Diagonalization of the bidiagonal form: Loop over\nfor (its=1;its<=30;its++) { singular values, and over allowed iterations.\nflag=1;\nfor (l=k;l>=1;l--) { Test for splitting.\nnm=l-1; Note that rv1[1] is always zero.\nif ((float)(fabs(rv1[l])+anorm) == anorm) {\nflag=0;\nbreak;\n}\nif ((float)(fabs(w[nm])+anorm) == anorm) break;\n}\nif (flag) {\nc=0.0; Cancellation of rv1[l], if l > 1.\ns=1.0;\nfor (i=l;i<=k;i++) {\nf=s*rv1[i];\nrv1[i]=c*rv1[i];\nif ((float)(fabs(f)+anorm) == anorm) break;\ng=w[i];\nh=pythag(f,g);\nw[i]=h;\nh=1.0/h;\nc=g*h;\ns = -f*h;\nfor (j=1;j<=m;j++) {\ny=a[j][nm];\nz=a[j][i];\na[j][nm]=y*c+z*s;\na[j][i]=z*c-y*s;\n}\n}\n}\nz=w[k];\nif (l == k) { Convergence.\nif (z < 0.0) { Singular value is made nonnegative.\nw[k] = -z;\nfor (j=1;j<=n;j++) v[j][k] = -v[j][k];\n}\nbreak;\n}\nif (its == 30) nrerror(\"no convergence in 30 svdcmp iterations\");\nx=w[l]; Shift from bottom 2-by-2 minor.\nnm=k-1;\ny=w[nm];\ng=rv1[nm];\nh=rv1[k];\nf=((y-z)*(y+z)+(g-h)*(g+h))/(2.0*h*y);\ng=pythag(f,1.0);\nf=((x-z)*(x+z)+h*((y/(f+SIGN(g,f)))-h))/x;\nc=s=1.0; Next QR transformation:\nfor (j=l;j<=nm;j++) {\ni=j+1;\ng=rv1[i];\ny=w[i];\nh=s*g;\ng=c*g;\nz=pythag(f,h);\nrv1[j]=z;\nc=f/z;\ns=h/z;\nf=x*c+g*s;\ng = g*c-x*s;\nh=y*s;\ny *= c;\nfor (jj=1;jj<=n;jj++) {\nx=v[jj][j];\nz=v[jj][i];\nv[jj][j]=x*c+z*s;\nv[jj][i]=z*c-x*s;\n}\nz=pythag(f,h);\nw[j]=z; Rotation can be arbitrary if z = 0.\nif (z) {\nz=1.0/z;\nc=f*z;\ns=h*z;\n}\nf=c*g+s*y;\nx=c*y-s*g;\nfor (jj=1;jj<=m;jj++) {\ny=a[jj][j];\nz=a[jj][i];\na[jj][j]=y*c+z*s;\na[jj][i]=z*c-y*s;\n}\n}\nrv1[l]=0.0;\nrv1[k]=f;\nw[k]=x;\n}\n}\nfree_vector(rv1,1,n);\n}\n#include <math.h>\n#include \"nrutil.h\"\nfloat pythag(float a, float b)\nComputes (a2 + b2)1/2 without destructive underflow or overflow.\n{\nfloat absa,absb;\nabsa=fabs(a);\nabsb=fabs(b);\nif (absa > absb) return absa*sqrt(1.0+SQR(absb/absa));\ne\n```\n\n___\n\n\n### __Python \u306e\u30e2\u30b8\u30e5\u30fc\u30eb\u3092\u7528\u3044\u305f\u30b3\u30fc\u30c9\u4f8b__\n\n* [\u304a\u3063\u3071\u3044\u305d\u3093\uff01 python\u3092\u6570\u5024\u8a08\u7b97\u306b\u4f7f\u3046\u3068\u304d\u306e\u30c6\u30af\u30cb\u30c3\u30af\u3068\u304b\u3092\u307e\u3068\u3081\u3066\u3044\u304d\u305f\u3044\u3002\u300cpython\u3067\u7279\u7570\u5024\u5206\u89e3\u300d](http://oppython.hatenablog.com/entry/2014/01/21/003245)\n* [\u97f3\u697d\u30d7\u30ed\u30b0\u30e9\u30df\u30f3\u30b0\u306e\u8d85\u5165\u9580\uff08\u4eee\uff09 Python / \u97f3\u697d\u60c5\u5831\u51e6\u7406 \u521d\u5fc3\u8005\u304c\u3001\u521d\u5fc3\u8005\u306b\u3082\u5206\u304b\u308b\u3088\u3046\u306a\u8a18\u4e8b\u3092\u66f8\u304d\u305f\u3044\u3002\u300c\u3010Python\u3011SciPy\u306e\u7279\u7570\u5024\u5206\u89e3\u3068\u3082\u3046\u3061\u3087\u3063\u3068\u901f\u3044\u7279\u7570\u5024\u5206\u89e3\u3010SVD\u3011\u300d](http://yukara-13.hatenablog.com/entry/2014/11/16/200645)\n* [\u7d71\u8a08\u5b66\u901f\u5831 \u300cPython/NumPy\u3067\u7279\u7570\u5024\u5206\u89e3(SVD)\u300d](http://tokeigaku.blog.jp/python/numpy/%E7%89%B9%E7%95%B0%E5%80%A4%E5%88%86%E8%A7%A3)\n\n\n### __\u7279\u7570\u5024\u5206\u89e3\u306e\u5229\u7528\u5834\u9762\uff08\u30c7\u30fc\u30bf\u89e3\u6790\u30a8\u30f3\u30b8\u30f3\u5185\u3067\u306e\u4f7f\u7528\u4f8b\uff09__\n\n   __1.\u81ea\u7136\u8a00\u8a9e\u51e6\u7406 _(NLP: Natural Language Processing)__\n         __1-1.__ \u6f5c\u5728\u7684\u610f\u5473\u5206\u6790 __(LSA)__\n [\u672a\u6765\u306f\u50d5\u4ee5\u5916\u306e\u624b\u306e\u4e2d \u300cSciPy\u3092\u7528\u3044\u3066\u6f5c\u5728\u7684\u610f\u5473\u89e3\u6790(LSA)\u300d](http://d.hatena.ne.jp/billest/20090819/1250635423)\n\n> \u81ea\u7136\u8a00\u8a9e\u51e6\u7406\u306e\u6280\u6cd5\u306e\uff11\u3064\u306b\u3001\u6f5c\u5728\u7684\u610f\u5473\u89e3\u6790(LSA)\u3068\u3044\u3046\u3082\u306e\u304c\u3042\u308b\u3002\n>            \n>\u5358\u8a9e\u6587\u66f8\u884c\u5217\uff21\u304c\u3042\u3063\u305f\u5834\u5408\u3001\u7279\u7570\u5024\u5206\u89e3(SVD)\u306b\u3088\u308a\n>\n>\uff21=\uff35\u03a3\uff36\n>\n>\u306b\u5206\u89e3\u3057\u3001\u7279\u7570\u5024\u3092\u5927\u304d\u3044\u307b\u3046\u304b\u3089k\u500b\u4f7f\u3063\u3066\n>\n>\n>\u3000\uff21k=\uff35k\u03a3k\uff36k\n>\n>\u306e\u3088\u3046\u306b\u968e\u6570\u306e\u4f4e\u6e1b\u3092\u884c\u3046\u3053\u3068\u3067\u3001\u968e\u6570k\u306e\uff21\u3078\u306e\u8fd1\u4f3c\u3092\u6700\u5c0f\u8aa4\u5dee\u3067\u5f97\u308b\u3053\u3068\u304c\u3067\u304d\u308b\u3002\n>\n>\u3064\u307e\u308a\u7279\u7570\u5024\u5206\u89e3\u306e\u8a08\u7b97\u3055\u3048\u3067\u304d\u3066\u3057\u307e\u3048\u3070LSA\u3082\u3059\u3050\u3067\u304d\u308b\u308f\u3051\u3060\u304c\u3001\n>python\u306e\u6570\u5024\u89e3\u6790\u30e2\u30b8\u30e5\u30fc\u30ebScipy\u306b\u304b\u304b\u308c\u3070\u7279\u7570\u5024\u5206\u89e3\u3082\u3042\u3063\u3068\u3044\u3046\u9593\u3067\u3042\u308b\u3002\n>\n\n[Hatena::Diary \u3042\u3089\u3073\u304d\u65e5\u8a18\u3000\u300c\u7279\u7570\u5024\u5206\u89e3\u3068LSI\u306e\u610f\u5473\u300d](http://d.hatena.ne.jp/a_bicky/20100905/1283660172)\n\n[Hatena::Diary \u3042\u3089\u3073\u304d\u65e5\u8a18 \u300c\u6f5c\u5728\u7684\u610f\u5473\u30a4\u30f3\u30c7\u30ad\u30b7\u30f3\u30b0\uff08LSI\uff09\u5fb9\u5e95\u5165\u9580\u300d](http://d.hatena.ne.jp/a_bicky/20120324/1332591498)\n\n\n\n___\n\n\n\n\n\n\u3000__2.\u591a\u5909\u91cf\u89e3\u6790__\n    __1-2.__ \u4e3b\u6210\u5206\u5206\u6790 __(PCA)__\n       [old school magic \u6a5f\u68b0\u5b66\u7fd2\u3068\u7d71\u8a08\u3068\u30d7\u30ed\u30b0\u30e9\u30df\u30f3\u30b0\u306b\u3064\u3044\u3066\u3061\u3087\u3063\u3068\u305a\u3064\u52c9\u5f37\u3057\u3066\u3044\u304d\u307e\u3059\u3002 \u300cPython\u3067\u4e3b\u6210\u5206\u5206\u6790\u300d](http://breakbee.hatenablog.jp/entry/2014/07/13/191803)\n> (\u5b9f\u969b\u306b\u306f\u3001scikit-learn\u306e\u4e3b\u6210\u5206\u5206\u6790\u306f\u7279\u7570\u5024\u5206\u89e3\u3068\u8a00\u3046\u624b\u6cd5\u3067\u4e3b\u6210\u5206\u5206\u6790\u3092\u884c\u3063\u3066\u3044\u307e\u3059\u3002)\n", "tags": ["Python", "\u6570\u5024\u8a08\u7b97", "\u6570\u5b66", "statistics", "\u7d71\u8a08\u5b66"]}