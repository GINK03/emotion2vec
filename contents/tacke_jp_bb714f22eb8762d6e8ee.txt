{"context": " More than 1 year has passed since last update.\u5bfe\u8a71\u74b0\u5883\u306f\u4fbf\u5229\u3067\u3059\u304c\u3001Haskell\u3067\u306f\u5f37\u3044\u9759\u7684\u578b\u4ed8\u3051\u30fb\u7d14\u7c8b\u95a2\u6570\u578b\u3068\u3044\u3046\u8a00\u8a9e\u306e\u6027\u8cea\u304b\u3089\u3001\n\u30b3\u30f3\u30d1\u30a4\u30e9\u3068\u5bfe\u8a71\u74b0\u5883\u3068\u3067\u306f\u5c11\u3005\u4f7f\u3044\u52dd\u624b\u304c\u9055\u3044\u307e\u3059\u3002\n\u3053\u3053\u3067\u306f\u3001Haskell\u521d\u5fc3\u8005\u304cghci\u3092\u4f7f\u3046\u3068\u304d\u306b\u9665\u308a\u304c\u3061\u306a4\u3064\u306e\u843d\u3068\u3057\u7a74\u306b\u3064\u3044\u3066\u7d39\u4ecb\u3057\u307e\u3059\u3002\n\n1. \u5f0f\u3092\u5b9a\u7fa9\u3057\u3088\u3046\u3068\u3057\u305f\u3089 parse error on input \uff40='\n\n[\u539f\u56e0] ghci\u306f\u30a4\u30f3\u30bf\u30d7\u30ea\u30bf\u306a\u306e\u3067\u3001\u4e0e\u3048\u3089\u308c\u305f\u5f0f\u5168\u4f53\u3092\u8a55\u4fa1\u3057\u3088\u3046\u3068\u3059\u308b\nPrelude> hoge = \"foo\"\n\n<interactive>:5:6: parse error on input `='\n\n[\u89e3\u6c7a\u65b9\u6cd5] let\u69cb\u6587\u3092\u5229\u7528\u3059\u308b\nPrelude> let hoge = \"foo\"\nPrelude> hoge\n\"foo\"\n\n\n2. \u5f0f\u3092\u8a55\u4fa1\u3057\u3088\u3046\u3068\u3057\u305f\u3089 No instance for (Show Hoge)\n\n\nghci\u306fIO\u30e2\u30ca\u30c9\u306e\u4e2d\u306b\u3044\u3066\u3001\u5f0f\u3092\u4e0e\u3048\u308b\u305f\u3073print (\u5f0f)\u3092\u5b9f\u884c\u3057\u3066\u3044\u308b\n\u5f0f\u3092\u8868\u793a\u53ef\u80fd\u306b\u3059\u308b\u305f\u3081\u306b\u306f\u3001\u578b\u304cShow\u30af\u30e9\u30b9\u306e\u30a4\u30f3\u30b9\u30bf\u30f3\u30b9\u3067\u3042\u308b\u5fc5\u8981\u304c\u3042\u308b\n(print\u306f\u578bShow a => a -> IO ()\u3092\u6301\u3064\u3002)\n\n[\u539f\u56e01] \u81ea\u5206\u3067\u5b9a\u7fa9\u3057\u305f\u4ee3\u6570\u7684\u30c7\u30fc\u30bf\u578b\u304cShow\u30af\u30e9\u30b9\u306b\u5c5e\u3057\u3066\u3044\u306a\u3044\nPrelude>  data Tree a = Branch (Tree a) (Tree a) | Leaf a\nPrelude> Leaf \"hoge\"\n\n<interactive>:5:1:\n    No instance for (Show (main::Interactive.Tree [Char]))\n      arising from a use of `print'\n    Possible fix:\n      add an instance declaration for\n      (Show (main::Interactive.Tree [Char]))\n    In a stmt of an interactive GHCi command: print it\n\n[\u89e3\u6c7a\u65b9\u6cd5] deriving Show\u3092\u3064\u3051\u3066\u81ea\u52d5\u7684\u306bShow\u30af\u30e9\u30b9\u306e\u30a4\u30f3\u30b9\u30bf\u30f3\u30b9\u306b\u306a\u308b\u3088\u3046\u306b\u3059\u308b\nPrelude> data Tree a = Branch (Tree a) (Tree a) | Leaf a deriving Show\nPrelude> Leaf \"hoge\"\nLeaf \"hoge\"\n\n[\u539f\u56e02] \u7c21\u7d04\u7d50\u679c\u306e\u578b\u304c\u95a2\u6570\nPrelude> let addOne = (+1)\nPrelude> addOne\n\n<interactive>:15:1:\n    No instance for (Show (Integer -> Integer))\n      arising from a use of `print'\n    Possible fix:\n      add an instance declaration for (Show (Integer -> Integer))\n    In a stmt of an interactive GHCi command: print it\n\n[\u89e3\u6c7a\u65b9\u6cd5] \u8ae6\u3081\u308b or \u95a2\u6570\u9069\u7528\u3057\u305f\u7d50\u679c\u3092\u8868\u793a\u3059\u308b\u3088\u3046\u306b\u3059\u308b\n\n3. do\u5f0f\u3092\u66f8\u3053\u3046\u3068\u3057\u3066\u6539\u884c\u3057\u305f\u3089 Empty 'do' block (\u307e\u305f\u306f\u8907\u6570\u884c\u306b\u6e21\u308b\u5f0f\u304c\u66f8\u3051\u306a\u3044)\n[\u539f\u56e0] \u4e00\u884c\u305a\u3064\u5b9f\u884c\u3055\u308c\u308b\u5bfe\u8a71\u74b0\u5883\u3067\u306f\u3001\u30a4\u30f3\u30c7\u30f3\u30c8\u8a18\u6cd5\u3067\u306fdo\u5f0f\u306e\u7d42\u7aef\u3092\u5224\u65ad\u3067\u304d\u306a\u3044\n-- parseAtom :: Parser LispVal\nparseAtom = do\n first <- letter <|> symbol\n rest <- many (letter <|> digit <|> symbol)\n let atom = first:rest\n return $ case atom of \n  \"#t\" -> Bool True\n  \"#f\" -> Bool False\n  _ -> Atom atom\n\n\n\u3053\u306e\u3088\u3046\u306a\u5f0f\u3092ghci\u3067\u5b9a\u7fa9\u3057\u3088\u3046\u3068\u3057\u3066\u3001\n\u4e00\u884c\u76ee\u3092\u5165\u308c\u3066\u6539\u884c\u3057\u305f\u3068\u3053\u308d\u3067\u3001\nPrelude> let parseAtom = do\n\n<interactive>:12:17: Empty 'do' block\n\n\u3068\u306a\u308b\u3002\n[\u89e3\u6c7a\u65b9\u6cd51] brace\u8a18\u6cd5\u3092\u5229\u7528\u3057\u3066\u9811\u5f35\u3063\u3066\u4e00\u884c\u306b\u53ce\u3081\u308b\nbrace\u3067\u56f2\u3048\u3070\u3001;\u304c\u30c7\u30ea\u30df\u30bf\u3068\u3057\u3066\u4f7f\u3048\u308b\u3002\nlet parseAtom = do { \n first <- letter <|> symbol; rest <- many (letter <|> digit <|> symbol); let {atom = first:rest}; return $ case atom of { \"#t\" -> Bool True; \"#f\" -> Bool False; _ -> Atom atom } } :: Parser LispVal -- \u3053\u3053\u307e\u3067\u6539\u884c\u306a\u3057\n\n\u3053\u306e\u3088\u3046\u306b\u9811\u5f35\u3063\u3066\u4e00\u884c\u306b\u53ce\u3081\u308c\u3070do\u69cb\u6587\u3092ghci\u3067\u5229\u7528\u3067\u304d\u308b\u3002\ncase\u69cb\u6587\u3082brace\u8a18\u6cd5\u3067\u8a18\u8ff0\u3067\u304d\u308b\u3002\n\u3061\u306a\u307f\u306b\u3001brace\u8a18\u6cd5\u306e\u5834\u5408\u3001do\u69cb\u6587\u306e\u4e2d\u3067let\u69cb\u6587\u3092\u5229\u7528\u3059\u308b\u5834\u5408\u3001\u3082\u3046\u4e00\u6bb5{ ~ }\u3067\u56f2\u3063\u3066\u3084\u3089\u306a\u304d\u3083\u3044\u3051\u306a\u3044\u3002\n(http://stackoverflow.com/questions/15273158/how-do-i-use-a-let-within-a-do-block-in-ghci)\n[\u89e3\u6c7a\u65b9\u6cd52] ghci\u306emultiline\u30b3\u30de\u30f3\u30c9\u3092\u5b9f\u884c\u3059\u308b\n\n\n:\u304b\u3089\u59cb\u307e\u308b\u884c\u306fghci\u306e\u30b3\u30de\u30f3\u30c9\n\n:{\u3068:}\u306e\u30bb\u30c3\u30c8\u3068\u306a\u3063\u305fmultiline\u30b3\u30de\u30f3\u30c9\u3092\u5229\u7528\u3059\u308b\u3053\u3068\u3067\u3001\u8907\u6570\u884c\u306b\u6e21\u308b\u5f0f\u3092\u8a18\u8ff0\u3067\u304d\u308b\n\nghci> :{\nghci| let parseAtom = do\nghci|      first <- letter <|> symbol\nghci|      rest <- many (letter <|> digit <|> symbol)\nghci|      let atom = first:rest\nghci|      return $ case atom of \nghci|       \"#t\" -> Bool True\nghci|       \"#f\" -> Bool False\nghci|       _ -> Atom atom\nghci| :}  :: Parser LispVal\n\n\u3053\u306e\u5834\u5408\u3001\u4e00\u884c\u76ee\u306eparseAtom\u306e\u5148\u982d\u3088\u308a\u3082\u4e8c\u884c\u76ee\u4ee5\u964d\u304c\u53f3\u5074\u306b\u30a4\u30f3\u30c7\u30f3\u30c8\u3055\u308c\u3066\u3044\u306a\u3044\u3068\u3001\n\u30a4\u30f3\u30b5\u30a4\u30c9\u30eb\u30fc\u30eb\u306b\u3088\u308a\u69cb\u6587\u30a8\u30e9\u30fc\u3068\u306a\u308b\u3002\u3069\u3053\u304b\u304b\u3089\u30bd\u30fc\u30b9\u3092\u30b3\u30d4\u30da\u3057\u3088\u3046\u3068\u3059\u308b\u5834\u5408\u3001\u5148\u982d\u306blet\u3092\u52a0\u3048\u305f\u3060\u3051\u3067\u5b9f\u884c\u3057\u3088\u3046\u3068\u3059\u308b\u3068\u69cb\u6587\u30a8\u30e9\u30fc\u306b\u306a\u308b\u306e\u3067\u3001\u4e8c\u884c\u76ee\u4ee5\u964d\u306e\u5404\u884c\u30924\u6587\u5b57\u5206\u30a4\u30f3\u30c7\u30f3\u30c8\u3059\u308b\u5fc5\u8981\u304c\u3042\u308b\u3002\n\n4. \u5f0f\u3092\u8a55\u4fa1\u3057\u3088\u3046\u3068\u3057\u305f\u3089 Ambiguous type variable   in the constraint\n\n[\u539f\u56e0] \u3042\u306a\u305f\u304c\u8a55\u4fa1\u3057\u3088\u3046\u3068\u3057\u3066\u3044\u308b\u5f0f\u306b\u306f\u6587\u8108\u304c\u8db3\u3089\u306a\u3044\n\nHaskell\u306e\u3088\u3046\u306aHM\u578b\u306e\u9759\u7684\u578b\u4ed8\u3051\u8a00\u8a9e\u306f\u5f0f\u306b\u591a\u76f8\u6027\u304c\u3042\u308a\u3001\u578b\u63a8\u8ad6\u3092\u884c\u3046\u3053\u3068\u3067\u6700\u7d42\u7684\u306a\u578b\u304c\u6c7a\u5b9a\u3055\u308c\u308b\n\u30bd\u30fc\u30b9\u30b3\u30fc\u30c9\u306e\u4e00\u90e8\u3092\u629c\u304d\u51fa\u3057\u3066\u30a4\u30f3\u30bf\u30d7\u30ea\u30bf\u3067\u5b9f\u884c\u3059\u308b\u3060\u3051\u3067\u306f\u3001\u578b\u3092\u63a8\u8ad6\u3059\u308b\u306e\u306b\u60c5\u5831\u304c\u8db3\u3089\u306a\u3044\u5834\u5408\u304c\u3042\u308b\n\n[\u89e3\u6c7a\u65b9\u6cd5] \u578b\u6ce8\u91c8\u3092\u4e0e\u3048\u308b\nlet hogehoge = fugafuga :: Hoge let\u69cb\u6587\u306e\u672b\u5c3e\u306b\u578b\u6ce8\u91c8\u3092\u66f8\u3051\u308b\nmultiline\u30b3\u30de\u30f3\u30c9\u3092\u5229\u7528\u3057let\u5f0f\u3067\u9577\u3044\u95a2\u6570\u3092\u5b9a\u7fa9\u7528\u3068\u3059\u308b\u5834\u5408\u306f\u3001\nPrelude> :{\nPrelude | let parseString = do\nPrelude |                     char '\"'\nPrelude |                     x <- many (noneOf \"\\\"\")\nPrelude |                     char '\"'\nPrelude |                     return $ String x :: Parser LispVal\nPrelude | :}\n\n\u3053\u3093\u306a\u611f\u3058\u3002\u5f0fx\u306e\u307f\u3092\u6ce8\u91c8\u3057\u3066\u3044\u308b\u3088\u3046\u306b\u898b\u3048\u308b\u304c\u3001\u3061\u3083\u3093\u3068let\u3067\u5b9a\u7fa9\u3057\u305f\u5f0f\u5168\u4f53\u306e\u578b\u3092\u6ce8\u91c8\u3057\u3066\u3044\u308b\u3002\n\n\u5bfe\u8a71\u74b0\u5883\u306f\u4fbf\u5229\u3067\u3059\u304c\u3001Haskell\u3067\u306f\u5f37\u3044\u9759\u7684\u578b\u4ed8\u3051\u30fb\u7d14\u7c8b\u95a2\u6570\u578b\u3068\u3044\u3046\u8a00\u8a9e\u306e\u6027\u8cea\u304b\u3089\u3001\n\u30b3\u30f3\u30d1\u30a4\u30e9\u3068\u5bfe\u8a71\u74b0\u5883\u3068\u3067\u306f\u5c11\u3005\u4f7f\u3044\u52dd\u624b\u304c\u9055\u3044\u307e\u3059\u3002\n\u3053\u3053\u3067\u306f\u3001Haskell\u521d\u5fc3\u8005\u304c`ghci`\u3092\u4f7f\u3046\u3068\u304d\u306b\u9665\u308a\u304c\u3061\u306a4\u3064\u306e\u843d\u3068\u3057\u7a74\u306b\u3064\u3044\u3066\u7d39\u4ecb\u3057\u307e\u3059\u3002\n\n##  1. \u5f0f\u3092\u5b9a\u7fa9\u3057\u3088\u3046\u3068\u3057\u305f\u3089 `parse error on input \uff40='`\n\n<b>[\u539f\u56e0] ghci\u306f\u30a4\u30f3\u30bf\u30d7\u30ea\u30bf\u306a\u306e\u3067\u3001\u4e0e\u3048\u3089\u308c\u305f\u5f0f\u5168\u4f53\u3092\u8a55\u4fa1\u3057\u3088\u3046\u3068\u3059\u308b</b>\n\n```\nPrelude> hoge = \"foo\"\n\n<interactive>:5:6: parse error on input `='\n```\n\n<b>[\u89e3\u6c7a\u65b9\u6cd5] `let`\u69cb\u6587\u3092\u5229\u7528\u3059\u308b</b>\n\n```\nPrelude> let hoge = \"foo\"\nPrelude> hoge\n\"foo\"\n```\n\n\n\n## 2. \u5f0f\u3092\u8a55\u4fa1\u3057\u3088\u3046\u3068\u3057\u305f\u3089 `No instance for (Show Hoge)`\n\n* ghci\u306fIO\u30e2\u30ca\u30c9\u306e\u4e2d\u306b\u3044\u3066\u3001\u5f0f\u3092\u4e0e\u3048\u308b\u305f\u3073`print (\u5f0f)`\u3092\u5b9f\u884c\u3057\u3066\u3044\u308b\n* \u5f0f\u3092\u8868\u793a\u53ef\u80fd\u306b\u3059\u308b\u305f\u3081\u306b\u306f\u3001\u578b\u304c`Show`\u30af\u30e9\u30b9\u306e\u30a4\u30f3\u30b9\u30bf\u30f3\u30b9\u3067\u3042\u308b\u5fc5\u8981\u304c\u3042\u308b\n(`print`\u306f\u578b`Show a => a -> IO ()`\u3092\u6301\u3064\u3002)\n\n\n<b>[\u539f\u56e01] \u81ea\u5206\u3067\u5b9a\u7fa9\u3057\u305f\u4ee3\u6570\u7684\u30c7\u30fc\u30bf\u578b\u304c`Show`\u30af\u30e9\u30b9\u306b\u5c5e\u3057\u3066\u3044\u306a\u3044</b>\n\n```\nPrelude>  data Tree a = Branch (Tree a) (Tree a) | Leaf a\nPrelude> Leaf \"hoge\"\n\n<interactive>:5:1:\n    No instance for (Show (main::Interactive.Tree [Char]))\n      arising from a use of `print'\n    Possible fix:\n      add an instance declaration for\n      (Show (main::Interactive.Tree [Char]))\n    In a stmt of an interactive GHCi command: print it\n```\n\n<b>[\u89e3\u6c7a\u65b9\u6cd5] `deriving Show`\u3092\u3064\u3051\u3066\u81ea\u52d5\u7684\u306b`Show`\u30af\u30e9\u30b9\u306e\u30a4\u30f3\u30b9\u30bf\u30f3\u30b9\u306b\u306a\u308b\u3088\u3046\u306b\u3059\u308b</b>\n\n```\nPrelude> data Tree a = Branch (Tree a) (Tree a) | Leaf a deriving Show\nPrelude> Leaf \"hoge\"\nLeaf \"hoge\"\n```\n\n\n<b>[\u539f\u56e02] \u7c21\u7d04\u7d50\u679c\u306e\u578b\u304c\u95a2\u6570</b>\n\n```\nPrelude> let addOne = (+1)\nPrelude> addOne\n\n<interactive>:15:1:\n    No instance for (Show (Integer -> Integer))\n      arising from a use of `print'\n    Possible fix:\n      add an instance declaration for (Show (Integer -> Integer))\n    In a stmt of an interactive GHCi command: print it\n```\n\n<b>[\u89e3\u6c7a\u65b9\u6cd5] \u8ae6\u3081\u308b or \u95a2\u6570\u9069\u7528\u3057\u305f\u7d50\u679c\u3092\u8868\u793a\u3059\u308b\u3088\u3046\u306b\u3059\u308b</b>\n\n\n## 3. do\u5f0f\u3092\u66f8\u3053\u3046\u3068\u3057\u3066\u6539\u884c\u3057\u305f\u3089 `Empty 'do' block` (\u307e\u305f\u306f\u8907\u6570\u884c\u306b\u6e21\u308b\u5f0f\u304c\u66f8\u3051\u306a\u3044)\n\n\n<b>[\u539f\u56e0] \u4e00\u884c\u305a\u3064\u5b9f\u884c\u3055\u308c\u308b\u5bfe\u8a71\u74b0\u5883\u3067\u306f\u3001\u30a4\u30f3\u30c7\u30f3\u30c8\u8a18\u6cd5\u3067\u306fdo\u5f0f\u306e\u7d42\u7aef\u3092\u5224\u65ad\u3067\u304d\u306a\u3044</b>\n\n```haskell\n-- parseAtom :: Parser LispVal\nparseAtom = do\n first <- letter <|> symbol\n rest <- many (letter <|> digit <|> symbol)\n let atom = first:rest\n return $ case atom of \n  \"#t\" -> Bool True\n  \"#f\" -> Bool False\n  _ -> Atom atom\n\n```\n\u3053\u306e\u3088\u3046\u306a\u5f0f\u3092ghci\u3067\u5b9a\u7fa9\u3057\u3088\u3046\u3068\u3057\u3066\u3001\n\u4e00\u884c\u76ee\u3092\u5165\u308c\u3066\u6539\u884c\u3057\u305f\u3068\u3053\u308d\u3067\u3001\n\n```\nPrelude> let parseAtom = do\n\n<interactive>:12:17: Empty 'do' block\n```\n\u3068\u306a\u308b\u3002\n\n<b>[\u89e3\u6c7a\u65b9\u6cd51] brace\u8a18\u6cd5\u3092\u5229\u7528\u3057\u3066\u9811\u5f35\u3063\u3066\u4e00\u884c\u306b\u53ce\u3081\u308b</b>\n\nbrace\u3067\u56f2\u3048\u3070\u3001`;`\u304c\u30c7\u30ea\u30df\u30bf\u3068\u3057\u3066\u4f7f\u3048\u308b\u3002\n\n```\nlet parseAtom = do { \n first <- letter <|> symbol; rest <- many (letter <|> digit <|> symbol); let {atom = first:rest}; return $ case atom of { \"#t\" -> Bool True; \"#f\" -> Bool False; _ -> Atom atom } } :: Parser LispVal -- \u3053\u3053\u307e\u3067\u6539\u884c\u306a\u3057\n```\n\n\u3053\u306e\u3088\u3046\u306b\u9811\u5f35\u3063\u3066\u4e00\u884c\u306b\u53ce\u3081\u308c\u3070`do`\u69cb\u6587\u3092`ghci`\u3067\u5229\u7528\u3067\u304d\u308b\u3002\n`case`\u69cb\u6587\u3082brace\u8a18\u6cd5\u3067\u8a18\u8ff0\u3067\u304d\u308b\u3002\n\u3061\u306a\u307f\u306b\u3001brace\u8a18\u6cd5\u306e\u5834\u5408\u3001`do`\u69cb\u6587\u306e\u4e2d\u3067`let`\u69cb\u6587\u3092\u5229\u7528\u3059\u308b\u5834\u5408\u3001\u3082\u3046\u4e00\u6bb5`{` ~ `}`\u3067\u56f2\u3063\u3066\u3084\u3089\u306a\u304d\u3083\u3044\u3051\u306a\u3044\u3002\n(http://stackoverflow.com/questions/15273158/how-do-i-use-a-let-within-a-do-block-in-ghci)\n\n<b>[\u89e3\u6c7a\u65b9\u6cd52] ghci\u306e`multiline`\u30b3\u30de\u30f3\u30c9\u3092\u5b9f\u884c\u3059\u308b</b>\n\n* `:`\u304b\u3089\u59cb\u307e\u308b\u884c\u306fghci\u306e\u30b3\u30de\u30f3\u30c9\n* `:{`\u3068`:}`\u306e\u30bb\u30c3\u30c8\u3068\u306a\u3063\u305f`multiline`\u30b3\u30de\u30f3\u30c9\u3092\u5229\u7528\u3059\u308b\u3053\u3068\u3067\u3001\u8907\u6570\u884c\u306b\u6e21\u308b\u5f0f\u3092\u8a18\u8ff0\u3067\u304d\u308b\n\n```\nghci> :{\nghci| let parseAtom = do\nghci|      first <- letter <|> symbol\nghci|      rest <- many (letter <|> digit <|> symbol)\nghci|      let atom = first:rest\nghci|      return $ case atom of \nghci|       \"#t\" -> Bool True\nghci|       \"#f\" -> Bool False\nghci|       _ -> Atom atom\nghci| :}  :: Parser LispVal\n```\n\n\u3053\u306e\u5834\u5408\u3001\u4e00\u884c\u76ee\u306e`parseAtom`\u306e\u5148\u982d\u3088\u308a\u3082\u4e8c\u884c\u76ee\u4ee5\u964d\u304c\u53f3\u5074\u306b\u30a4\u30f3\u30c7\u30f3\u30c8\u3055\u308c\u3066\u3044\u306a\u3044\u3068\u3001\n\u30a4\u30f3\u30b5\u30a4\u30c9\u30eb\u30fc\u30eb\u306b\u3088\u308a\u69cb\u6587\u30a8\u30e9\u30fc\u3068\u306a\u308b\u3002\u3069\u3053\u304b\u304b\u3089\u30bd\u30fc\u30b9\u3092\u30b3\u30d4\u30da\u3057\u3088\u3046\u3068\u3059\u308b\u5834\u5408\u3001\u5148\u982d\u306b`let `\u3092\u52a0\u3048\u305f\u3060\u3051\u3067\u5b9f\u884c\u3057\u3088\u3046\u3068\u3059\u308b\u3068\u69cb\u6587\u30a8\u30e9\u30fc\u306b\u306a\u308b\u306e\u3067\u3001\u4e8c\u884c\u76ee\u4ee5\u964d\u306e\u5404\u884c\u30924\u6587\u5b57\u5206\u30a4\u30f3\u30c7\u30f3\u30c8\u3059\u308b\u5fc5\u8981\u304c\u3042\u308b\u3002\n\n## 4. \u5f0f\u3092\u8a55\u4fa1\u3057\u3088\u3046\u3068\u3057\u305f\u3089 `Ambiguous type variable   in the constraint`\n\n\n<b>[\u539f\u56e0] \u3042\u306a\u305f\u304c\u8a55\u4fa1\u3057\u3088\u3046\u3068\u3057\u3066\u3044\u308b\u5f0f\u306b\u306f\u6587\u8108\u304c\u8db3\u3089\u306a\u3044</b>\n\n* Haskell\u306e\u3088\u3046\u306aHM\u578b\u306e\u9759\u7684\u578b\u4ed8\u3051\u8a00\u8a9e\u306f\u5f0f\u306b\u591a\u76f8\u6027\u304c\u3042\u308a\u3001\u578b\u63a8\u8ad6\u3092\u884c\u3046\u3053\u3068\u3067\u6700\u7d42\u7684\u306a\u578b\u304c\u6c7a\u5b9a\u3055\u308c\u308b\n* \u30bd\u30fc\u30b9\u30b3\u30fc\u30c9\u306e\u4e00\u90e8\u3092\u629c\u304d\u51fa\u3057\u3066\u30a4\u30f3\u30bf\u30d7\u30ea\u30bf\u3067\u5b9f\u884c\u3059\u308b\u3060\u3051\u3067\u306f\u3001\u578b\u3092\u63a8\u8ad6\u3059\u308b\u306e\u306b\u60c5\u5831\u304c\u8db3\u3089\u306a\u3044\u5834\u5408\u304c\u3042\u308b\n\n<b>[\u89e3\u6c7a\u65b9\u6cd5] \u578b\u6ce8\u91c8\u3092\u4e0e\u3048\u308b</b>\n\n`let hogehoge = fugafuga :: Hoge` `let`\u69cb\u6587\u306e\u672b\u5c3e\u306b\u578b\u6ce8\u91c8\u3092\u66f8\u3051\u308b\n\n`multiline`\u30b3\u30de\u30f3\u30c9\u3092\u5229\u7528\u3057let\u5f0f\u3067\u9577\u3044\u95a2\u6570\u3092\u5b9a\u7fa9\u7528\u3068\u3059\u308b\u5834\u5408\u306f\u3001\n\n```\nPrelude> :{\nPrelude | let parseString = do\nPrelude |                     char '\"'\nPrelude |                     x <- many (noneOf \"\\\"\")\nPrelude |                     char '\"'\nPrelude |                     return $ String x :: Parser LispVal\nPrelude | :}\n```\n\n\u3053\u3093\u306a\u611f\u3058\u3002\u5f0f`x`\u306e\u307f\u3092\u6ce8\u91c8\u3057\u3066\u3044\u308b\u3088\u3046\u306b\u898b\u3048\u308b\u304c\u3001\u3061\u3083\u3093\u3068let\u3067\u5b9a\u7fa9\u3057\u305f\u5f0f\u5168\u4f53\u306e\u578b\u3092\u6ce8\u91c8\u3057\u3066\u3044\u308b\u3002\n", "tags": ["ghc", "ghci", "Haskell"]}