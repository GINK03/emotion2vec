{"context": "\u6628\u65e5\u306f\u30a4\u30f3\u30b9\u30c8\u30fc\u30eb\u307e\u3067\u306f\u3067\u304d\u308b\u3088\u3046\u306b\u306a\u3063\u305f\u3051\u3069\u3001\u8d77\u52d5\u3067\u304d\u306a\u304b\u3063\u305f\u306e\u3067\n$ cloudmonkey\nTraceback (most recent call last):\n  File \"/Users/kentaro/porting/ven/bin/cloudmonkey\", line 9, in <module>\n    load_entry_point('cloudmonkey', 'console_scripts', 'cloudmonkey')()\n  File \"/Users/kentaro/porting/ven/lib/python3.5/site-packages/pkg_resources/__init__.py\", line 542, in load_entry_point\n    return get_distribution(dist).load_entry_point(group, name)\n  File \"/Users/kentaro/porting/ven/lib/python3.5/site-packages/pkg_resources/__init__.py\", line 2569, in load_entry_point\n    return ep.load()\n  File \"/Users/kentaro/porting/ven/lib/python3.5/site-packages/pkg_resources/__init__.py\", line 2229, in load\n    return self.resolve()\n  File \"/Users/kentaro/porting/ven/lib/python3.5/site-packages/pkg_resources/__init__.py\", line 2235, in resolve\n    module = __import__(self.module_name, fromlist=['__name__'], level=0)\n  File \"/Users/kentaro/porting/cloudstack-cloudmonkey/cloudmonkey/cloudmonkey.py\", line 48\n    except ImportError, e:\n                      ^\nSyntaxError: invalid syntax\n\n\u30a8\u30e9\u30fc\u306e\u51fa\u3066\u3044\u308bcloudmonkey.py\u3000\u3092\u5909\u63db\n$ futurize --stage1 -w cloudmonkey/cloudmonkey.py\nRefactoringTool: Skipping optional fixer: idioms\nRefactoringTool: Skipping optional fixer: ws_comma\nRefactoringTool: Refactored cloudmonkey/cloudmonkey.py\n--- cloudmonkey/cloudmonkey.py  (original)\n+++ cloudmonkey/cloudmonkey.py  (refactored)\n@@ -17,6 +17,9 @@\n # specific language governing permissions and limitations\n # under the License.\n\n+from __future__ import print_function\n+from __future__ import absolute_import\n+from functools import reduce\n try:\n     import argcomplete\n     import argparse\n@@ -32,26 +35,26 @@\n     import time\n     import types\n\n-    from cachemaker import loadcache, savecache, monkeycache, splitverbsubject\n-    from config import __version__, __description__, __projecturl__\n-    from config import display_types\n-    from config import read_config, write_config, config_file, default_profile\n+    from .cachemaker import loadcache, savecache, monkeycache, splitverbsubject\n+    from .config import __version__, __description__, __projecturl__\n+    from .config import display_types\n+    from .config import read_config, write_config, config_file, default_profile\n     from dicttoxml import dicttoxml\n     from optparse import OptionParser\n     from prettytable import PrettyTable\n-    from printer import monkeyprint\n-    from requester import monkeyrequest\n-    from requester import login\n-    from requester import logout\n+    from .printer import monkeyprint\n+    from .requester import monkeyrequest\n+    from .requester import login\n+    from .requester import logout\n     from urlparse import urlparse\n     from xml.dom.minidom import parseString\n-except ImportError, e:\n+except ImportError as e:\n     print(\"Import error in %s : %s\" % (__name__, e))\n     import sys\n     sys.exit()\n\n try:\n-    from precache import apicache\n+    from .precache import apicache\n except ImportError:\n     apicache = {'count': 0, 'verbs': [], 'asyncapis': []}\n\n@@ -63,8 +66,8 @@\n     os.environ['TERM'] = 'vt100'\n try:\n     import readline\n-except ImportError, e:\n-    print(\"Module readline not found, autocompletions will fail\", e)\n+except ImportError as e:\n+    print((\"Module readline not found, autocompletions will fail\", e))\n else:\n     import rlcompleter\n     readline_doc = getattr(readline, '__doc__', '')\n@@ -114,7 +117,7 @@\n         try:\n             if os.path.exists(self.history_file):\n                 readline.read_history_file(self.history_file)\n-        except IOError, e:\n+        except IOError as e:\n             logger.debug(u\"Error: Unable to read history. \" + unicode(e))\n         atexit.register(readline.write_history_file, self.history_file)\n\n@@ -148,7 +151,7 @@\n     def cmdloop(self, intro=None):\n         self.interpreterMode = True\n         print(self.intro)\n-        print \"Using management server profile:\", self.profile, \"\\n\"\n+        print(\"Using management server profile:\", self.profile, \"\\n\")\n         while True:\n             try:\n                 super(CloudMonkeyShell, self).cmdloop(intro=\"\")\n@@ -197,7 +200,7 @@\n                         args_partition = args.partition(\" \")\n                         cmd = self.apicache[verb][args_partition[0]]['name']\n                         args = args_partition[2]\n-                    except KeyError, e:\n+                    except KeyError as e:\n                         if default_handler:\n                             default_handler(args)\n                         else:\n@@ -216,12 +219,12 @@\n         output = u\"\"\n         try:\n             for arg in args:\n-                if isinstance(type(arg), types.NoneType) or not arg:\n+                if isinstance(type(arg), type(None)) or not arg:\n                     continue\n                 if not (isinstance(arg, str) or isinstance(arg, unicode)):\n                     arg = unicode(arg)\n                 output += arg\n-        except Exception, e:\n+        except Exception as e:\n             print(str(e))\n\n         output = output.encode(\"utf-8\")\n@@ -232,7 +235,7 @@\n                 sys.stderr.write(output + \"\\n\")\n                 sys.stderr.flush()\n             else:\n-                print output\n+                print(output)\n\n     def print_result(self, result, result_filter=[]):\n         if not result or len(result) == 0:\n@@ -297,7 +300,7 @@\n                 if isinstance(result[0], dict):\n                     keys = result[0].keys()\n                     writer = csv.DictWriter(sys.stdout, keys)\n-                    print ','.join(keys)\n+                    print(','.join(keys))\n                     for item in result:\n                         row = {}\n                         for k in keys:\n@@ -312,7 +315,7 @@\n             elif isinstance(result, dict):\n                 keys = result.keys()\n                 writer = csv.DictWriter(sys.stdout, keys)\n-                print ','.join(keys)\n+                print(','.join(keys))\n                 writer.writerow(result)\n\n         def print_result_tabular(result):\n@@ -428,7 +431,7 @@\n         try:\n             args = args.strip()\n             args.decode(\"utf-8\")\n-        except UnicodeError, ignore:\n+        except UnicodeError as ignore:\n             args = args.encode(\"utf-8\")\n\n         if self.pipe_runner(args):\n@@ -444,12 +447,12 @@\n         args = []\n         while True:\n             try:\n-                next_val = lexp.next()\n+                next_val = next(lexp)\n                 if not next_val:\n                     break\n                 next_val = next_val.decode(\"utf-8\")\n                 args.append(next_val.replace(u'\\x00', u''))\n-            except ValueError, err:\n+            except ValueError as err:\n                 self.monkeyprint(\"Command parsing error: \", err)\n                 return\n\n@@ -600,14 +603,14 @@\n                             return\n                         uuids = self.update_param_cache(api, response)\n                     if len(uuids) > 1:\n-                        print\n+                        print()\n                         options = sorted(self.param_cache[api][\"options\"],\n                                          key=lambda x: x[1])\n                         for option in options:\n                             uuid = option[0]\n                             name = option[1]\n                             if uuid.startswith(value):\n-                                print uuid, name\n+                                print(uuid, name)\n                     autocompletions = map(lambda x: x + \" \", uuids)\n                     search_string = value\n\n@@ -662,7 +665,7 @@\n         allowed_blank_keys = [\"username\", \"password\", \"apikey\", \"secretkey\",\n                               \"domain\"]\n         if key not in allowed_blank_keys and not value:\n-            print \"Blank value of %s is not allowed\" % key\n+            print(\"Blank value of %s is not allowed\" % key)\n             return\n\n         self.prompt = self.get_prompt()\n@@ -671,19 +674,19 @@\n             key = 'url'\n             self.url = \"%s://%s:%s%s\" % (self.protocol, self.host,\n                                          self.port, self.path)\n-            print \"This option has been deprecated, please set 'url' instead\"\n-            print \"This server url will be used:\", self.url\n+            print(\"This option has been deprecated, please set 'url' instead\")\n+            print(\"This server url will be used:\", self.url)\n         write_config(self.get_attr, self.config_file)\n         read_config(self.get_attr, self.set_attr, self.config_file)\n         self.init_credential_store()\n         if key.strip() == 'profile' and self.interpreterMode:\n-            print \"\\nLoaded server profile '%s' with options:\" % value\n+            print(\"\\nLoaded server profile '%s' with options:\" % value)\n             for option in default_profile.keys():\n                 value = self.get_attr(option)\n                 if option in [\"password\", \"apikey\", \"secretkey\"] and value:\n                     value = value[:2] + \"XXX\" + value[4:6] + \"YYY...(hidden)\"\n-                print \"    %s = %s\" % (option, value)\n-            print\n+                print(\"    %s = %s\" % (option, value))\n+            print()\n\n     def complete_set(self, text, line, begidx, endidx):\n         mline = line.partition(\" \")[2].lstrip().partition(\" \")\n@@ -714,7 +717,7 @@\n             session, sessionkey = login(self.url, self.username, self.password)\n             self.credentials['session'] = session\n             self.credentials['sessionkey'] = sessionkey\n-        except Exception, e:\n+        except Exception as e:\n             self.monkeyprint(\"Error: Login failed to the server: \", unicode(e))\n\n     def do_logout(self, args):\n@@ -723,7 +726,7 @@\n         \"\"\"\n         try:\n             logout(self.url, self.credentials.get('session'))\n-        except Exception, e:\n+        except Exception as e:\n             pass\n         self.credentials['session'] = None\n         self.credentials['sessionkey'] = None\n@@ -775,7 +778,7 @@\n                 startIdx = 1\n         elif historyArg == \"clear\" or historyArg == \"c\":\n             readline.clear_history()\n-            print \"CloudMonkey history cleared\"\n+            print(\"CloudMonkey history cleared\")\n             return\n         elif len(historyArg) > 1 and historyArg[0] == \"!\" and historyArg[1:].isdigit():\n             command = readline.get_history_item(long(historyArg[1:]))\nRefactoringTool: Files that were modified:\nRefactoringTool: cloudmonkey/cloudmonkey.py\n\n\u3059\u3054\u3044\u91cf\u3060\u306a\u3041\n$ futurize --stage2 -w cloudmonkey/cloudmonkey.py\nRefactoringTool: Refactored cloudmonkey/cloudmonkey.py\n--- cloudmonkey/cloudmonkey.py  (original)\n+++ cloudmonkey/cloudmonkey.py  (refactored)\n@@ -19,6 +19,13 @@\n\n from __future__ import print_function\n from __future__ import absolute_import\n+from future import standard_library\n+standard_library.install_aliases()\n+from builtins import map\n+from builtins import next\n+from builtins import filter\n+from builtins import str\n+from builtins import range\n from functools import reduce\n try:\n     import argcomplete\n@@ -46,7 +53,7 @@\n     from .requester import monkeyrequest\n     from .requester import login\n     from .requester import logout\n-    from urlparse import urlparse\n+    from urllib.parse import urlparse\n     from xml.dom.minidom import parseString\n except ImportError as e:\n     print(\"Import error in %s : %s\" % (__name__, e))\n@@ -109,16 +116,15 @@\n         self.init_credential_store()\n         logging.basicConfig(filename=self.log_file,\n                             level=logging.DEBUG, format=log_fmt)\n-        logger.debug(\"Loaded config fields:\\n%s\" % map(lambda x: \"%s=%s\" %\n-                                                       (x, getattr(self, x)),\n-                                                       self.config_options))\n+        logger.debug(\"Loaded config fields:\\n%s\" % [\"%s=%s\" %\n+                                                       (x, getattr(self, x)) for x in self.config_options])\n         cmd.Cmd.__init__(self)\n\n         try:\n             if os.path.exists(self.history_file):\n                 readline.read_history_file(self.history_file)\n         except IOError as e:\n-            logger.debug(u\"Error: Unable to read history. \" + unicode(e))\n+            logger.debug(u\"Error: Unable to read history. \" + str(e))\n         atexit.register(readline.write_history_file, self.history_file)\n\n     def init_credential_store(self):\n@@ -221,8 +227,8 @@\n             for arg in args:\n                 if isinstance(type(arg), type(None)) or not arg:\n                     continue\n-                if not (isinstance(arg, str) or isinstance(arg, unicode)):\n-                    arg = unicode(arg)\n+                if not (isinstance(arg, str) or isinstance(arg, str)):\n+                    arg = str(arg)\n                 output += arg\n         except Exception as e:\n             print(str(e))\n@@ -249,7 +255,7 @@\n             if result_filter:\n                 for res in result_filter:\n                     tfilter[res] = 1\n-                for okey, oval in result.iteritems():\n+                for okey, oval in result.items():\n                     if isinstance(oval, dict):\n                         for tkey in oval:\n                             if tkey not in tfilter:\n@@ -289,8 +295,8 @@\n             if \"count\" in result:\n                 result.pop(\"count\")\n\n-            if len(result.keys()) == 1:\n-                item = result[result.keys()[0]]\n+            if len(list(result.keys())) == 1:\n+                item = result[list(result.keys())[0]]\n                 if isinstance(item, list):\n                     result = item\n                 elif isinstance(item, dict):\n@@ -298,7 +304,7 @@\n\n             if isinstance(result, list) and len(result) > 0:\n                 if isinstance(result[0], dict):\n-                    keys = result[0].keys()\n+                    keys = list(result[0].keys())\n                     writer = csv.DictWriter(sys.stdout, keys)\n                     print(','.join(keys))\n                     for item in result:\n@@ -307,13 +313,13 @@\n                             if k not in item:\n                                 row[k] = None\n                             else:\n-                                if type(item[k]) is unicode:\n+                                if type(item[k]) is str:\n                                     row[k] = item[k].encode('utf8')\n                                 else:\n                                     row[k] = item[k]\n                         writer.writerow(row)\n             elif isinstance(result, dict):\n-                keys = result.keys()\n+                keys = list(result.keys())\n                 writer = csv.DictWriter(sys.stdout, keys)\n                 print(','.join(keys))\n                 writer.writerow(result)\n@@ -327,8 +333,7 @@\n             toprow = []\n             if not result:\n                 return\n-            toprow = set(reduce(lambda x, y: x + y, map(lambda x: x.keys(),\n-                         filter(lambda x: isinstance(x, dict), result))))\n+            toprow = set(reduce(lambda x, y: x + y, [list(x.keys()) for x in [x for x in result if isinstance(x, dict)]]))\n             printer = print_table(printer, toprow)\n             for node in result:\n                 if not node:\n@@ -336,13 +341,13 @@\n                 for key in toprow:\n                     if key not in node:\n                         node[key] = ''\n-                row = map(lambda x: node[x], toprow)\n+                row = [node[x] for x in toprow]\n                 if printer and row:\n                     printer.add_row(row)\n             print_table(printer, toprow)\n\n         def print_result_as_dict(result):\n-            for key in sorted(result.keys(), key=lambda x:\n+            for key in sorted(list(result.keys()), key=lambda x:\n                               x not in ['id', 'count', 'name'] and x):\n                 if isinstance(result[key], list):\n                     self.monkeyprint(key + \":\")\n@@ -351,7 +356,7 @@\n                     self.monkeyprint(key + \":\")\n                     print_result_as_dict(result[key])\n                 else:\n-                    value = unicode(result[key])\n+                    value = str(result[key])\n                     self.monkeyprint(key, \" = \", value)\n\n         def print_result_as_list(result):\n@@ -404,20 +409,20 @@\n         if not api:\n             return\n         logger.debug(\"Updating param cache for %s API\" % api)\n-        responsekey = filter(lambda x: 'response' in x, result.keys())[0]\n+        responsekey = filter(lambda x: 'response' in x, list(result.keys()))[0]\n         result = result[responsekey]\n         options = []\n         uuids = []\n-        for key in result.keys():\n+        for key in list(result.keys()):\n             if isinstance(result[key], list):\n                 for element in result[key]:\n-                    if 'id' in element.keys():\n-                        uuid = unicode(element['id'])\n+                    if 'id' in list(element.keys()):\n+                        uuid = str(element['id'])\n                         name = \"\"\n                         keyspace = [\"name\", \"displayname\",\n                                     \"username\", \"description\"]\n                         for name_key in keyspace:\n-                            if name_key in element.keys():\n+                            if name_key in list(element.keys()):\n                                 name = element[name_key]\n                                 break\n                         options.append((uuid, name,))\n@@ -462,15 +467,13 @@\n\n         field_filter = []\n         if 'filter' in args_dict:\n-            field_filter = filter(lambda x: x.strip() != '',\n-                                  args_dict.pop('filter').split(','))\n+            field_filter = [x for x in args_dict.pop('filter').split(',') if x.strip() != '']\n             field_filter = list(set(field_filter))\n\n         missing = []\n         if verb in self.apicache and subject in self.apicache[verb]:\n-            missing = filter(lambda x: x not in [key.split('[')[0].lower()\n-                                                 for key in args_dict],\n-                             self.apicache[verb][subject]['requiredparams'])\n+            missing = [x for x in self.apicache[verb][subject]['requiredparams'] if x not in [key.split('[')[0].lower()\n+                                                 for key in args_dict]]\n\n         if len(missing) > 0:\n             self.monkeyprint(\"Missing arguments: \", ' '.join(missing))\n@@ -484,13 +487,13 @@\n         result = self.make_request(apiname, args_dict, isasync)\n\n         if not result or not isinstance(result, dict):\n-            if isinstance(result, unicode):\n+            if isinstance(result, str):\n                 result = result.decode(\"utf-8\")\n             logger.debug(\"Invalid command result: %s\" % result)\n             return\n\n         try:\n-            responsekeys = filter(lambda x: 'response' in x, result.keys())\n+            responsekeys = [x for x in list(result.keys()) if 'response' in x]\n             for responsekey in responsekeys:\n                 self.print_result(result[responsekey], field_filter)\n             if apiname.startswith(\"list\") and \"id\" not in args_dict:\n@@ -513,13 +516,10 @@\n         search_string = \"\"\n\n         if separator != \" \":   # Complete verb subjects\n-            autocompletions = map(lambda x: x + \" \",\n-                                  self.apicache[verb].keys())\n+            autocompletions = [x + \" \" for x in list(self.apicache[verb].keys())]\n             search_string = subject\n         else:                  # Complete subject params\n-            autocompletions = map(lambda x: x + \"=\",\n-                                  map(lambda x: x['name'],\n-                                      self.apicache[verb][subject]['params']))\n+            autocompletions = [x + \"=\" for x in [x['name'] for x in self.apicache[verb][subject]['params']]]\n             search_string = text\n             if self.paramcompletion == 'true':\n                 param = line[:endidx].split(\" \")[-1]\n@@ -528,25 +528,19 @@\n                 param = param[:idx]\n                 if param == \"filter\":\n                     response_params = self.apicache[verb][subject][\"response\"]\n-                    used = filter(lambda x: x.strip() != \"\",\n-                                  value.split(\",\")[:-1])\n-                    unused = map(lambda x: x['name'] + \",\", filter(lambda x:\n-                                 \"name\" in x and x[\"name\"] not in used,\n-                                 response_params))\n+                    used = [x for x in value.split(\",\")[:-1] if x.strip() != \"\"]\n+                    unused = [x['name'] + \",\" for x in [x for x in response_params if \"name\" in x and x[\"name\"] not in used]]\n                     last_value = value.split(\",\")[-1]\n                     if last_value:\n-                        unused = filter(lambda x: x.startswith(last_value),\n-                                        unused)\n+                        unused = [x for x in unused if x.startswith(last_value)]\n                     suffix = \",\".join(used)\n                     if suffix:\n                         suffix += \",\"\n                     global normal_readline\n                     if normal_readline:\n-                        return filter(lambda x: x.startswith(last_value),\n-                                      map(lambda x: x, unused))\n+                        return [x for x in [x for x in unused] if x.startswith(last_value)]\n                     else:  # OSX fix\n-                        return filter(lambda x: x.startswith(value),\n-                                      map(lambda x: suffix + x, unused))\n+                        return [x for x in [suffix + x for x in unused] if x.startswith(value)]\n                 elif len(value) < 36 and idx != -1:\n                     api = None\n                     logger.debug(\"[Paramcompl] For %s %s %s=\" % (verb, subject,\n@@ -574,10 +568,9 @@\n                         params = self.apicache[verb][subject]['params']\n                         arg = filter(lambda x: x['name'] == param, params)[0]\n                         if \"type\" in arg and arg[\"type\"] == \"boolean\":\n-                            return filter(lambda x: x.startswith(value),\n-                                          [\"true \", \"false \"])\n+                            return [x for x in [\"true \", \"false \"] if x.startswith(value)]\n                         related = arg['related']\n-                        apis = filter(lambda x: 'list' in x, related)\n+                        apis = [x for x in related if 'list' in x]\n                         logger.debug(\"[Paramcompl] Related APIs: %s\" % apis)\n                         if len(apis) > 0:\n                             api = apis[0]\n@@ -589,7 +582,7 @@\n                     uuids = []\n                     cache_burst_ts = int(time.time()) - 900\n                     logger.debug(\"Trying paramcompletion using API: %s\" % api)\n-                    if api in self.param_cache.keys() and \\\n+                    if api in list(self.param_cache.keys()) and \\\n                         len(self.param_cache[api][\"options\"]) > 0 and \\\n                             self.param_cache[api][\"ts\"] > cache_burst_ts:\n                         for option in self.param_cache[api][\"options\"]:\n@@ -611,7 +604,7 @@\n                             name = option[1]\n                             if uuid.startswith(value):\n                                 print(uuid, name)\n-                    autocompletions = map(lambda x: x + \" \", uuids)\n+                    autocompletions = [x + \" \" for x in uuids]\n                     search_string = value\n\n         if subject != \"\" and line.split(\" \")[-1].find('=') == -1:\n@@ -681,7 +674,7 @@\n         self.init_credential_store()\n         if key.strip() == 'profile' and self.interpreterMode:\n             print(\"\\nLoaded server profile '%s' with options:\" % value)\n-            for option in default_profile.keys():\n+            for option in list(default_profile.keys()):\n                 value = self.get_attr(option)\n                 if option in [\"password\", \"apikey\", \"secretkey\"] and value:\n                     value = value[:2] + \"XXX\" + value[4:6] + \"YYY...(hidden)\"\n@@ -718,7 +711,7 @@\n             self.credentials['session'] = session\n             self.credentials['sessionkey'] = sessionkey\n         except Exception as e:\n-            self.monkeyprint(\"Error: Login failed to the server: \", unicode(e))\n+            self.monkeyprint(\"Error: Login failed to the server: \", str(e))\n\n     def do_logout(self, args):\n         \"\"\"\n@@ -773,7 +766,7 @@\n         numLen = len(str(endIdx))\n         historyArg = args.split(' ')[0]\n         if historyArg.isdigit():\n-            startIdx = endIdx - long(historyArg)\n+            startIdx = endIdx - int(historyArg)\n             if startIdx < 1:\n                 startIdx = 1\n         elif historyArg == \"clear\" or historyArg == \"c\":\n@@ -781,11 +774,11 @@\n             print(\"CloudMonkey history cleared\")\n             return\n         elif len(historyArg) > 1 and historyArg[0] == \"!\" and historyArg[1:].isdigit():\n-            command = readline.get_history_item(long(historyArg[1:]))\n+            command = readline.get_history_item(int(historyArg[1:]))\n             readline.set_startup_hook(lambda: readline.insert_text(command))\n             self.hook_count = 1\n             return\n-        for idx in xrange(startIdx, endIdx):\n+        for idx in range(startIdx, endIdx):\n             self.monkeyprint(\"%s %s\" % (str(idx).rjust(numLen),\n                                         readline.get_history_item(idx)))\n\nRefactoringTool: Files that were modified:\nRefactoringTool: cloudmonkey/cloudmonkey.py\n\n$ cloudmonkey\nTraceback (most recent call last):\n  File \"/Users/kentaro/porting/ven/bin/cloudmonkey\", line 9, in <module>\n    load_entry_point('cloudmonkey', 'console_scripts', 'cloudmonkey')()\n  File \"/Users/kentaro/porting/ven/lib/python3.5/site-packages/pkg_resources/__init__.py\", line 542, in load_entry_point\n    return get_distribution(dist).load_entry_point(group, name)\n  File \"/Users/kentaro/porting/ven/lib/python3.5/site-packages/pkg_resources/__init__.py\", line 2569, in load_entry_point\n    return ep.load()\n  File \"/Users/kentaro/porting/ven/lib/python3.5/site-packages/pkg_resources/__init__.py\", line 2229, in load\n    return self.resolve()\n  File \"/Users/kentaro/porting/ven/lib/python3.5/site-packages/pkg_resources/__init__.py\", line 2235, in resolve\n    module = __import__(self.module_name, fromlist=['__name__'], level=0)\n  File \"/Users/kentaro/porting/cloudstack-cloudmonkey/cloudmonkey/cloudmonkey.py\", line 45, in <module>\n    from .cachemaker import loadcache, savecache, monkeycache, splitverbsubject\n  File \"/Users/kentaro/porting/cloudstack-cloudmonkey/cloudmonkey/cachemaker.py\", line 25\n    except ImportError, e:\n                      ^\nSyntaxError: invalid syntax\n\n\u4eca\u5ea6\u306fcachemaker.py\n$ futurize --stage1 -w cloudmonkey/cachemaker.py\nRefactoringTool: Skipping optional fixer: idioms\nRefactoringTool: Skipping optional fixer: ws_comma\nRefactoringTool: Refactored cloudmonkey/cachemaker.py\n--- cloudmonkey/cachemaker.py   (original)\n+++ cloudmonkey/cachemaker.py   (refactored)\n@@ -16,15 +16,17 @@\n # specific language governing permissions and limitations\n # under the License.\n\n+from __future__ import print_function\n+from __future__ import absolute_import\n try:\n     import json\n     import os\n     import types\n\n-    from config import config_fields\n-except ImportError, e:\n+    from .config import config_fields\n+except ImportError as e:\n     import sys\n-    print \"ImportError\", e\n+    print(\"ImportError\", e)\n     sys.exit(1)\n\n\n@@ -73,8 +75,8 @@\n     f.close()\n     try:\n         apicache = json.loads(data)\n-    except ValueError, e:\n-        print \"Error processing json:\", json_file, e\n+    except ValueError as e:\n+        print(\"Error processing json:\", json_file, e)\n         return {}\n     return apicache\n\n@@ -83,16 +85,16 @@\n     \"\"\"\n     Feed this a dictionary of api bananas, it spits out processed cache\n     \"\"\"\n-    if isinstance(type(apis), types.NoneType) or apis is None:\n+    if isinstance(type(apis), type(None)) or apis is None:\n         return {}\n\n     responsekey = filter(lambda x: 'response' in x, apis.keys())\n\n     if len(responsekey) == 0:\n-        print \"[monkeycache] Invalid dictionary, has no response\"\n+        print(\"[monkeycache] Invalid dictionary, has no response\")\n         return None\n     if len(responsekey) != 1:\n-        print \"[monkeycache] Multiple responsekeys, chosing first one\"\n+        print(\"[monkeycache] Multiple responsekeys, chosing first one\")\n\n     responsekey = responsekey[0]\n     verbs = set()\n@@ -102,7 +104,7 @@\n\n     apilist = getvalue(apis[responsekey], 'api')\n     if apilist is None:\n-        print \"[monkeycache] Server response issue, no apis found\"\n+        print(\"[monkeycache] Server response issue, no apis found\")\n\n     for api in apilist:\n         name = getvalue(api, 'name')\n@@ -174,9 +176,9 @@\n\n if __name__ == \"__main__\":\n     cache_file = config_fields['core']['cache_file']\n-    print \"[cachemaker] Pre-caching using user's cloudmonkey cache\", cache_file\n+    print(\"[cachemaker] Pre-caching using user's cloudmonkey cache\", cache_file)\n     if os.path.exists(cache_file):\n         main(cache_file)\n     else:\n-        print \"[cachemaker] Unable to cache apis, file not found\", cache_file\n-        print \"[cachemaker] Run cloudmonkey sync to generate cache\"\n+        print(\"[cachemaker] Unable to cache apis, file not found\", cache_file)\n+        print(\"[cachemaker] Run cloudmonkey sync to generate cache\")\nRefactoringTool: Files that were modified:\nRefactoringTool: cloudmonkey/cachemaker.py\n\n$ futurize --stage2 -w cloudmonkey/cachemaker.py\nRefactoringTool: Refactored cloudmonkey/cachemaker.py\n--- cloudmonkey/cachemaker.py   (original)\n+++ cloudmonkey/cachemaker.py   (refactored)\n@@ -39,7 +39,7 @@\n\n def splitcsvstring(string):\n     if string is not None:\n-        return filter(lambda x: x.strip() != '', string.split(','))\n+        return [x for x in string.split(',') if x.strip() != '']\n     else:\n         return []\n\n@@ -88,7 +88,7 @@\n     if isinstance(type(apis), type(None)) or apis is None:\n         return {}\n\n-    responsekey = filter(lambda x: 'response' in x, apis.keys())\n+    responsekey = [x for x in list(apis.keys()) if 'response' in x]\n\n     if len(responsekey) == 0:\n         print(\"[monkeycache] Invalid dictionary, has no response\")\nRefactoringTool: Files that were modified:\nRefactoringTool: cloudmonkey/cachemaker.py\n\n$ cloudmonkey\nTraceback (most recent call last):\n  File \"/Users/kentaro/porting/ven/bin/cloudmonkey\", line 9, in <module>\n    load_entry_point('cloudmonkey', 'console_scripts', 'cloudmonkey')()\n  File \"/Users/kentaro/porting/ven/lib/python3.5/site-packages/pkg_resources/__init__.py\", line 542, in load_entry_point\n    return get_distribution(dist).load_entry_point(group, name)\n  File \"/Users/kentaro/porting/ven/lib/python3.5/site-packages/pkg_resources/__init__.py\", line 2569, in load_entry_point\n    return ep.load()\n  File \"/Users/kentaro/porting/ven/lib/python3.5/site-packages/pkg_resources/__init__.py\", line 2229, in load\n    return self.resolve()\n  File \"/Users/kentaro/porting/ven/lib/python3.5/site-packages/pkg_resources/__init__.py\", line 2235, in resolve\n    module = __import__(self.module_name, fromlist=['__name__'], level=0)\n  File \"/Users/kentaro/porting/cloudstack-cloudmonkey/cloudmonkey/cloudmonkey.py\", line 52, in <module>\n    from .printer import monkeyprint\n  File \"/Users/kentaro/porting/cloudstack-cloudmonkey/cloudmonkey/printer.py\", line 27\n    except ImportError, e:\n                      ^\nSyntaxError: invalid syntax\n\n$ futurize --stage1 -w cloudmonkey/printer.py\nRefactoringTool: Skipping optional fixer: idioms\nRefactoringTool: Skipping optional fixer: ws_comma\nRefactoringTool: Refactored cloudmonkey/printer.py\n--- cloudmonkey/printer.py      (original)\n+++ cloudmonkey/printer.py      (refactored)\n@@ -16,6 +16,7 @@\n # specific language governing permissions and limitations\n # under the License.\n\n+from __future__ import print_function\n try:\n     from pygments import highlight\n     from pygments.console import ansiformat\n@@ -24,8 +25,8 @@\n     from pygments.token import *\n\n     import sys\n-except ImportError, e:\n-    print e\n+except ImportError as e:\n+    print(e)\n\n\n MONKEY_COLORS = {\nRefactoringTool: Files that were modified:\nRefactoringTool: cloudmonkey/printer.py\n\n\n$ futurize --stage2 -w cloudmonkey/printer.py\nRefactoringTool: No files need to be modified.\n\n$ cloudmonkey\nTraceback (most recent call last):\n  File \"/Users/kentaro/porting/ven/bin/cloudmonkey\", line 9, in <module>\n    load_entry_point('cloudmonkey', 'console_scripts', 'cloudmonkey')()\n  File \"/Users/kentaro/porting/ven/lib/python3.5/site-packages/pkg_resources/__init__.py\", line 542, in load_entry_point\n    return get_distribution(dist).load_entry_point(group, name)\n  File \"/Users/kentaro/porting/ven/lib/python3.5/site-packages/pkg_resources/__init__.py\", line 2569, in load_entry_point\n    return ep.load()\n  File \"/Users/kentaro/porting/ven/lib/python3.5/site-packages/pkg_resources/__init__.py\", line 2229, in load\n    return self.resolve()\n  File \"/Users/kentaro/porting/ven/lib/python3.5/site-packages/pkg_resources/__init__.py\", line 2235, in resolve\n    module = __import__(self.module_name, fromlist=['__name__'], level=0)\n  File \"/Users/kentaro/porting/cloudstack-cloudmonkey/cloudmonkey/cloudmonkey.py\", line 53, in <module>\n    from .requester import monkeyrequest\n  File \"/Users/kentaro/porting/cloudstack-cloudmonkey/cloudmonkey/requester.py\", line 36\n    except ImportError, e:\n                      ^\nSyntaxError: invalid syntax\n\n$ futurize --stage1 -w cloudmonkey/requester.py\nRefactoringTool: Skipping optional fixer: idioms\nRefactoringTool: Skipping optional fixer: ws_comma\nRefactoringTool: Refactored cloudmonkey/requester.py\n--- cloudmonkey/requester.py    (original)\n+++ cloudmonkey/requester.py    (refactored)\n@@ -17,6 +17,7 @@\n # specific language governing permissions and limitations\n # under the License.\n\n+from __future__ import print_function\n try:\n     import base64\n     import hashlib\n@@ -33,8 +34,8 @@\n     from datetime import datetime, timedelta\n     from requests_toolbelt import SSLAdapter\n     from urllib2 import HTTPError, URLError\n-except ImportError, e:\n-    print \"Import error in %s : %s\" % (__name__, e)\n+except ImportError as e:\n+    print(\"Import error in %s : %s\" % (__name__, e))\n     import sys\n     sys.exit()\n\n@@ -74,7 +75,7 @@\n\n     try:\n         resp = session.post(url, params=args, verify=verifysslcert)\n-    except requests.exceptions.ConnectionError, e:\n+    except requests.exceptions.ConnectionError as e:\n         writeError(\"Connection refused by server: %s\" % e)\n         return None, None\n\n@@ -197,7 +198,7 @@\n         try:\n             return make_request_with_password(command, args, logger, url,\n                                               credentials, verifysslcert)\n-        except (requests.exceptions.ConnectionError, Exception), e:\n+        except (requests.exceptions.ConnectionError, Exception) as e:\n             return None, e\n\n     def sign_request(params, secret_key):\n@@ -231,9 +232,9 @@\n         elif response.status_code != 200 and response.status_code != 401:\n             error = \"{0}: {1}\".format(response.status_code,\n                                       response.headers.get('X-Description'))\n-    except requests.exceptions.ConnectionError, e:\n+    except requests.exceptions.ConnectionError as e:\n         return None, \"Connection refused by server: %s\" % e\n-    except Exception, pokemon:\n+    except Exception as pokemon:\n         error = pokemon.message\n\n     logger_debug(logger, \"Response received: %s\" % result)\n@@ -263,7 +264,7 @@\n     def process_json(response):\n         try:\n             response = json.loads(response, \"utf-8\")\n-        except ValueError, e:\n+        except ValueError as e:\n             logger_debug(logger, \"Error processing json: %s\" % e)\n             writeError(\"Error processing json: %s\" % e)\n             response = None\n@@ -292,7 +293,7 @@\n         while timeout > 0:\n             interval = 2\n             while interval > 0:\n-                sys.stdout.write(u\"%s\\r\" % cursor.next())\n+                sys.stdout.write(u\"%s\\r\" % next(cursor))\n                 sys.stdout.flush()\n                 time.sleep(0.1)\n                 interval -= 0.1\nRefactoringTool: Files that were modified:\nRefactoringTool: cloudmonkey/requester.py\n\n$ futurize --stage2 -w cloudmonkey/requester.py\nRefactoringTool: Refactored cloudmonkey/requester.py\n--- cloudmonkey/requester.py    (original)\n+++ cloudmonkey/requester.py    (refactored)\n@@ -18,6 +18,12 @@\n # under the License.\n\n from __future__ import print_function\n+from future import standard_library\n+standard_library.install_aliases()\n+from builtins import filter\n+from builtins import zip\n+from builtins import next\n+from builtins import str\n try:\n     import base64\n     import hashlib\n@@ -28,12 +34,12 @@\n     import ssl\n     import sys\n     import time\n-    import urllib\n-    import urllib2\n+    import urllib.request, urllib.parse, urllib.error\n+    import urllib.request, urllib.error, urllib.parse\n\n     from datetime import datetime, timedelta\n     from requests_toolbelt import SSLAdapter\n-    from urllib2 import HTTPError, URLError\n+    from urllib.error import HTTPError, URLError\n except ImportError as e:\n     print(\"Import error in %s : %s\" % (__name__, e))\n     import sys\n@@ -183,9 +189,9 @@\n         expirationtime = datetime.utcnow() + timedelta(seconds=int(expires))\n         args[\"expires\"] = expirationtime.strftime('%Y-%m-%dT%H:%M:%S+0000')\n\n-    for key in args.keys():\n+    for key in list(args.keys()):\n         value = args[key]\n-        if isinstance(value, unicode):\n+        if isinstance(value, str):\n             value = value.encode(\"utf-8\")\n         args[key] = value\n         if not key:\n@@ -202,12 +208,12 @@\n             return None, e\n\n     def sign_request(params, secret_key):\n-        request = zip(params.keys(), params.values())\n+        request = list(zip(list(params.keys()), list(params.values())))\n         request.sort(key=lambda x: x[0].lower())\n         hash_str = \"&\".join(\n             [\"=\".join(\n                 [r[0].lower(),\n-                 urllib.quote_plus(str(r[1]), safe=\"*\").lower()\n+                 urllib.parse.quote_plus(str(r[1]), safe=\"*\").lower()\n                  .replace(\"+\", \"%20\").replace(\"%3A\", \":\")]\n             ) for r in request]\n         )\n@@ -275,12 +281,12 @@\n     if not response or not isinstance(response, dict):\n         return response, error\n\n-    m = list(v for v in response.keys() if 'response' in v.lower())\n+    m = list(v for v in list(response.keys()) if 'response' in v.lower())\n     if not m:\n         return response, 'Invalid response received: %s' % response\n\n     isasync = isasync and (asyncblock == \"true\" or asyncblock == \"True\")\n-    responsekey = filter(lambda x: 'response' in x, response.keys())[0]\n+    responsekey = filter(lambda x: 'response' in x, list(response.keys()))[0]\n\n     if isasync and 'jobid' in response[responsekey]:\n         jobid = response[responsekey]['jobid']\n@@ -306,7 +312,7 @@\n                 return response, error\n\n             response = process_json(response)\n-            responsekeys = filter(lambda x: 'response' in x, response.keys())\n+            responsekeys = [x for x in list(response.keys()) if 'response' in x]\n\n             if len(responsekeys) < 1:\n                 continue\nRefactoringTool: Files that were modified:\nRefactoringTool: cloudmonkey/requester.py\n\n\n$ cloudmonkey\n\u2601 Apache CloudStack \ud83d\udc35 cloudmonkey 5.3.3. Type help or ? to list commands.\n\nUsing management server profile: local\n\n(local) \ud83d\udc35 >\n\n\u30aa\u30aa\u30aa\u30aa\u30aa\u30aa\u30fc\u30fc\n\u30e4\u30c3\u30bf\u30a1\u30fc\n\u8d77\u52d5\u3057\u305f\u3041\n(local) \ud83d\udc35 >?\n\nDocumented commands (type help <topic>):\n========================================\nEOF        change     disable       history  prepare    reset    start\nactivate   clean      disassociate  import   query      resize   stop\nadd        configure  enable        issue    quit       restart  suspend\napi        copy       exit          ldap     reboot     restore  sync\narchive    create     expunge       list     reconnect  revert   update\nassign     dedicate   extract       lock     recover    revoke   upgrade\nassociate  delete     find          login    register   saml     upload\nattach     deploy     generate      logout   release    scale\nauthorize  destroy    get           mark     remove     set\ncancel     detach     help          migrate  replace    shell\n\nhelp\u3082\u51fa\u529b\u3055\u308c\u308b\u307f\u305f\u3044\u3000\u266a\n\u3067\u3082\u8a2d\u5b9a\u3057\u3066\u307f\u308b\u3068\u30a8\u30e9\u30fc\u3067\u7d42\u4e86\n(local) \ud83d\udc35 > set url https://comp-api.jp-e1.cloudn-service.com/client/api\n(local) \ud83d\udc35 > exit\nTraceback (most recent call last):\n  File \"/Users/kentaro/porting/ven/bin/cloudmonkey\", line 9, in <module>\n    load_entry_point('cloudmonkey', 'console_scripts', 'cloudmonkey')()\n  File \"/Users/kentaro/porting/cloudstack-cloudmonkey/cloudmonkey/cloudmonkey.py\", line 920, in main\n    shell.cmdloop()\n  File \"/Users/kentaro/porting/cloudstack-cloudmonkey/cloudmonkey/cloudmonkey.py\", line 163, in cmdloop\n    super(CloudMonkeyShell, self).cmdloop(intro=\"\")\n  File \"/usr/local/Cellar/python3/3.5.2_1/Frameworks/Python.framework/Versions/3.5/lib/python3.5/cmd.py\", line 138, in cmdloop\n    stop = self.onecmd(line)\n  File \"/usr/local/Cellar/python3/3.5.2_1/Frameworks/Python.framework/Versions/3.5/lib/python3.5/cmd.py\", line 217, in onecmd\n    return func(arg)\n  File \"/Users/kentaro/porting/cloudstack-cloudmonkey/cloudmonkey/cloudmonkey.py\", line 841, in do_exit\n    return self.do_quit(args)\n  File \"/Users/kentaro/porting/cloudstack-cloudmonkey/cloudmonkey/cloudmonkey.py\", line 847, in do_quit\n    self.monkeyprint(\"Bye!\")\n  File \"/Users/kentaro/porting/cloudstack-cloudmonkey/cloudmonkey/cloudmonkey.py\", line 238, in monkeyprint\n    monkeyprint(output)\n  File \"/Users/kentaro/porting/cloudstack-cloudmonkey/cloudmonkey/printer.py\", line 122, in monkeyprint\n    if text.startswith(\"Error\"):\nTypeError: startswith first arg must be bytes or a tuple of bytes, not str\n\n\n\u30d8\u30eb\u30d7\u306f\u52d5\u3044\u3066\u308b\u3093\u3060\u3051\u3069\u306a\u3041\n(local) \ud83d\udc35 > ? set\n\n        Set config for cloudmonkey. For example, options can be:\n        url, auth, log_file, history_file\n        You may also edit your ~/.cloudmonkey_config instead of using set.\n\n        Example:\n        set url http://localhost:8080/client/api\n        set prompt \ud83d\udc35 cloudmonkey>\n        set log_file /var/log/cloudmonkey.log\n\n\u3069\u3053\u306b\u30a8\u30e9\u30fc\u304c\u308b\u306e\u304b\u306a\u3041\n\u30ed\u30b0\u306b\u306f\u4f55\u3082\u6b8b\u3063\u3066\u306a\u3044\u304b\u3089\u30d5\u30a1\u30a4\u30eb\u306e\u66f8\u304d\u8fbc\u307f\u304b\u306a\u3041\n$ ls ~/.cloudmonkey/log\n\n/Users/kentaro/.cloudmonkey/log\n\n\u3053\u306e\u3042\u305f\u308a\u304c\u602a\u3057\u3044\uff1f\uff1f\n\n File \"/Users/kentaro/porting/cloudstack-cloudmonkey/cloudmonkey/config.py\", line 141, in write_config\n    config.write(cfg)\n\n\u30d7\u30ed\u30b8\u30a7\u30af\u30c8\u3067config.write\uff08\uff09\u3092\u691c\u7d22\u3057\u3066\u3082\u3001\u3053\u306e\uff11\u884c\u3057\u304b\u306a\u3044\u306e\u3067\n\n  File \"/Users/kentaro/porting/cloudstack-cloudmonkey/cloudmonkey/config.py\", line 214, in read_config\n    write_config(get_attr, config_file)\n\n1\u884c\u9061\u308b\u3068\u3053\u306e\u884c\u3089\u3057\u3044\nwrite_config(get_attr, config_file)\n\nwrite_config\u306f\u3000config.py \u304b\u3089\u6765\u3066\u3044\u308b\u307f\u305f\u3044\n    from .config import read_config, write_config, config_file, default_profile\n\n\u7d50\u5c40\u3000\u3053\u3053\u306b\u305f\u3069\u308a\u7740\u304f\u307f\u305f\u3044\npy\nTypeError: a bytes-like object is required, not 'str'\n\n\u66f8\u304d\u8fbc\u3082\u3046\u3068\u3057\u3066\u3044\u308b\u3001\u30d5\u30a1\u30a4\u30eb\u304c\u30d0\u30a4\u30ca\u30ea\u3058\u3083\u306a\u3044\u3068\u3044\u3051\u306a\u3044\uff1f\npython2 \u3068python3\u306e\u5dee\u3068\u3057\u3066\u30d5\u30a1\u30a4\u30eb\u306e\u958b\u3051\u65b9\u306b\u5dee\u304c\u3042\u308a\u3001\u30d0\u30a4\u30ca\u30ea\u306e\u5834\u5408\u306f\u3000b \u3092\u8ffd\u52a0\u3059\u308b\u307f\u305f\u3044\u3002\ndef write_config(get_attr, config_file):\n    global config_fields, mandatory_sections\n    global default_profile, default_profile_name\n    config = ConfigParser()\n    if os.path.exists(config_file):\n        try:\n            with open(config_file, 'r') as cfg:\n                config.read_file(cfg)\n        except IOError as e:\n            print(\"Error: config_file not found\", e)\n\n\u3092\ndef write_config(get_attr, config_file):\n    global config_fields, mandatory_sections\n    global default_profile, default_profile_name\n    config = ConfigParser()\n    if os.path.exists(config_file):\n        try:\n            with open(config_file, 'rb') as cfg:\n                config.read_file(cfg)\n        except IOError as e:\n            print(\"Error: config_file not found\", e)\n\n\u306b\u3057\u3066\u307f\u305f\u3068\u3053\u308d!!!\ncloudmonkey\nSelected profile (local) does not exist, using default values\nMissing configuration was set using default values for keys:\n`asyncblock = true, history_file = /Users/kentaro/.cloudmonkey/history, profile = local, log_file = /Users/kentaro/.cloudmonkey/log, cache_file = /Users/kentaro/.cloudmonkey/cache, paramcompletion = true, prompt = \ud83d\udc35 > , display = default, color = true` in /Users/kentaro/.cloudmonkey/config\n\u2601 Apache CloudStack \ud83d\udc35 cloudmonkey 5.3.3. Type help or ? to list commands.\n\nUsing management server profile: local\n\n(local) \ud83d\udc35 >\n\n\u8d77\u52d5\u306b\u6210\u529f\u3000\uff01\uff01\uff01\n(local) \ud83d\udc35 > help\n\nDocumented commands (type help <topic>):\n========================================\nEOF        change     disable       history  prepare    reset    start\nactivate   clean      disassociate  import   query      resize   stop\nadd        configure  enable        issue    quit       restart  suspend\napi        copy       exit          ldap     reboot     restore  sync\narchive    create     expunge       list     reconnect  revert   update\nassign     dedicate   extract       lock     recover    revoke   upgrade\nassociate  delete     find          login    register   saml     upload\nattach     deploy     generate      logout   release    scale\nauthorize  destroy    get           mark     remove     set\ncancel     detach     help          migrate  replace    shell\n\n(local) \ud83d\udc35 > exit\nTraceback (most recent call last):\n  File \"/Users/kentaro/porting/ven/bin/cloudmonkey\", line 9, in <module>\n    load_entry_point('cloudmonkey', 'console_scripts', 'cloudmonkey')()\n  File \"/Users/kentaro/porting/cloudstack-cloudmonkey/cloudmonkey/cloudmonkey.py\", line 920, in main\n    shell.cmdloop()\n  File \"/Users/kentaro/porting/cloudstack-cloudmonkey/cloudmonkey/cloudmonkey.py\", line 163, in cmdloop\n    super(CloudMonkeyShell, self).cmdloop(intro=\"\")\n  File \"/usr/local/Cellar/python3/3.5.2_1/Frameworks/Python.framework/Versions/3.5/lib/python3.5/cmd.py\", line 138, in cmdloop\n    stop = self.onecmd(line)\n  File \"/usr/local/Cellar/python3/3.5.2_1/Frameworks/Python.framework/Versions/3.5/lib/python3.5/cmd.py\", line 217, in onecmd\n    return func(arg)\n  File \"/Users/kentaro/porting/cloudstack-cloudmonkey/cloudmonkey/cloudmonkey.py\", line 841, in do_exit\n    return self.do_quit(args)\n  File \"/Users/kentaro/porting/cloudstack-cloudmonkey/cloudmonkey/cloudmonkey.py\", line 847, in do_quit\n    self.monkeyprint(\"Bye!\")\n  File \"/Users/kentaro/porting/cloudstack-cloudmonkey/cloudmonkey/cloudmonkey.py\", line 238, in monkeyprint\n    monkeyprint(output)\n  File \"/Users/kentaro/porting/cloudstack-cloudmonkey/cloudmonkey/printer.py\", line 122, in monkeyprint\n    if text.startswith(\"Error\"):\nTypeError: startswith first arg must be bytes or a tuple of bytes, not str\n\n\u30d8\u30eb\u30d7\u306f\u8868\u793a\u3055\u308c\u308b\u3051\u3069\u3001\u7d42\u4e86\u3059\u3089\u3067\u304d\u306a\u3044\u307f\u305f\u3044...\n\u4eca\u65e5\u306f\u3053\u3053\u307e\u3067\n\u6628\u65e5\u306f\u30a4\u30f3\u30b9\u30c8\u30fc\u30eb\u307e\u3067\u306f\u3067\u304d\u308b\u3088\u3046\u306b\u306a\u3063\u305f\u3051\u3069\u3001\u8d77\u52d5\u3067\u304d\u306a\u304b\u3063\u305f\u306e\u3067\n\n$ cloudmonkey\n\n```\nTraceback (most recent call last):\n  File \"/Users/kentaro/porting/ven/bin/cloudmonkey\", line 9, in <module>\n    load_entry_point('cloudmonkey', 'console_scripts', 'cloudmonkey')()\n  File \"/Users/kentaro/porting/ven/lib/python3.5/site-packages/pkg_resources/__init__.py\", line 542, in load_entry_point\n    return get_distribution(dist).load_entry_point(group, name)\n  File \"/Users/kentaro/porting/ven/lib/python3.5/site-packages/pkg_resources/__init__.py\", line 2569, in load_entry_point\n    return ep.load()\n  File \"/Users/kentaro/porting/ven/lib/python3.5/site-packages/pkg_resources/__init__.py\", line 2229, in load\n    return self.resolve()\n  File \"/Users/kentaro/porting/ven/lib/python3.5/site-packages/pkg_resources/__init__.py\", line 2235, in resolve\n    module = __import__(self.module_name, fromlist=['__name__'], level=0)\n  File \"/Users/kentaro/porting/cloudstack-cloudmonkey/cloudmonkey/cloudmonkey.py\", line 48\n    except ImportError, e:\n                      ^\nSyntaxError: invalid syntax\n```\n\n\u30a8\u30e9\u30fc\u306e\u51fa\u3066\u3044\u308bcloudmonkey.py\u3000\u3092\u5909\u63db\n\n$ futurize --stage1 -w cloudmonkey/cloudmonkey.py\n\n```\nRefactoringTool: Skipping optional fixer: idioms\nRefactoringTool: Skipping optional fixer: ws_comma\nRefactoringTool: Refactored cloudmonkey/cloudmonkey.py\n--- cloudmonkey/cloudmonkey.py \t(original)\n+++ cloudmonkey/cloudmonkey.py \t(refactored)\n@@ -17,6 +17,9 @@\n # specific language governing permissions and limitations\n # under the License.\n\n+from __future__ import print_function\n+from __future__ import absolute_import\n+from functools import reduce\n try:\n     import argcomplete\n     import argparse\n@@ -32,26 +35,26 @@\n     import time\n     import types\n\n-    from cachemaker import loadcache, savecache, monkeycache, splitverbsubject\n-    from config import __version__, __description__, __projecturl__\n-    from config import display_types\n-    from config import read_config, write_config, config_file, default_profile\n+    from .cachemaker import loadcache, savecache, monkeycache, splitverbsubject\n+    from .config import __version__, __description__, __projecturl__\n+    from .config import display_types\n+    from .config import read_config, write_config, config_file, default_profile\n     from dicttoxml import dicttoxml\n     from optparse import OptionParser\n     from prettytable import PrettyTable\n-    from printer import monkeyprint\n-    from requester import monkeyrequest\n-    from requester import login\n-    from requester import logout\n+    from .printer import monkeyprint\n+    from .requester import monkeyrequest\n+    from .requester import login\n+    from .requester import logout\n     from urlparse import urlparse\n     from xml.dom.minidom import parseString\n-except ImportError, e:\n+except ImportError as e:\n     print(\"Import error in %s : %s\" % (__name__, e))\n     import sys\n     sys.exit()\n\n try:\n-    from precache import apicache\n+    from .precache import apicache\n except ImportError:\n     apicache = {'count': 0, 'verbs': [], 'asyncapis': []}\n\n@@ -63,8 +66,8 @@\n     os.environ['TERM'] = 'vt100'\n try:\n     import readline\n-except ImportError, e:\n-    print(\"Module readline not found, autocompletions will fail\", e)\n+except ImportError as e:\n+    print((\"Module readline not found, autocompletions will fail\", e))\n else:\n     import rlcompleter\n     readline_doc = getattr(readline, '__doc__', '')\n@@ -114,7 +117,7 @@\n         try:\n             if os.path.exists(self.history_file):\n                 readline.read_history_file(self.history_file)\n-        except IOError, e:\n+        except IOError as e:\n             logger.debug(u\"Error: Unable to read history. \" + unicode(e))\n         atexit.register(readline.write_history_file, self.history_file)\n\n@@ -148,7 +151,7 @@\n     def cmdloop(self, intro=None):\n         self.interpreterMode = True\n         print(self.intro)\n-        print \"Using management server profile:\", self.profile, \"\\n\"\n+        print(\"Using management server profile:\", self.profile, \"\\n\")\n         while True:\n             try:\n                 super(CloudMonkeyShell, self).cmdloop(intro=\"\")\n@@ -197,7 +200,7 @@\n                         args_partition = args.partition(\" \")\n                         cmd = self.apicache[verb][args_partition[0]]['name']\n                         args = args_partition[2]\n-                    except KeyError, e:\n+                    except KeyError as e:\n                         if default_handler:\n                             default_handler(args)\n                         else:\n@@ -216,12 +219,12 @@\n         output = u\"\"\n         try:\n             for arg in args:\n-                if isinstance(type(arg), types.NoneType) or not arg:\n+                if isinstance(type(arg), type(None)) or not arg:\n                     continue\n                 if not (isinstance(arg, str) or isinstance(arg, unicode)):\n                     arg = unicode(arg)\n                 output += arg\n-        except Exception, e:\n+        except Exception as e:\n             print(str(e))\n\n         output = output.encode(\"utf-8\")\n@@ -232,7 +235,7 @@\n                 sys.stderr.write(output + \"\\n\")\n                 sys.stderr.flush()\n             else:\n-                print output\n+                print(output)\n\n     def print_result(self, result, result_filter=[]):\n         if not result or len(result) == 0:\n@@ -297,7 +300,7 @@\n                 if isinstance(result[0], dict):\n                     keys = result[0].keys()\n                     writer = csv.DictWriter(sys.stdout, keys)\n-                    print ','.join(keys)\n+                    print(','.join(keys))\n                     for item in result:\n                         row = {}\n                         for k in keys:\n@@ -312,7 +315,7 @@\n             elif isinstance(result, dict):\n                 keys = result.keys()\n                 writer = csv.DictWriter(sys.stdout, keys)\n-                print ','.join(keys)\n+                print(','.join(keys))\n                 writer.writerow(result)\n\n         def print_result_tabular(result):\n@@ -428,7 +431,7 @@\n         try:\n             args = args.strip()\n             args.decode(\"utf-8\")\n-        except UnicodeError, ignore:\n+        except UnicodeError as ignore:\n             args = args.encode(\"utf-8\")\n\n         if self.pipe_runner(args):\n@@ -444,12 +447,12 @@\n         args = []\n         while True:\n             try:\n-                next_val = lexp.next()\n+                next_val = next(lexp)\n                 if not next_val:\n                     break\n                 next_val = next_val.decode(\"utf-8\")\n                 args.append(next_val.replace(u'\\x00', u''))\n-            except ValueError, err:\n+            except ValueError as err:\n                 self.monkeyprint(\"Command parsing error: \", err)\n                 return\n\n@@ -600,14 +603,14 @@\n                             return\n                         uuids = self.update_param_cache(api, response)\n                     if len(uuids) > 1:\n-                        print\n+                        print()\n                         options = sorted(self.param_cache[api][\"options\"],\n                                          key=lambda x: x[1])\n                         for option in options:\n                             uuid = option[0]\n                             name = option[1]\n                             if uuid.startswith(value):\n-                                print uuid, name\n+                                print(uuid, name)\n                     autocompletions = map(lambda x: x + \" \", uuids)\n                     search_string = value\n\n@@ -662,7 +665,7 @@\n         allowed_blank_keys = [\"username\", \"password\", \"apikey\", \"secretkey\",\n                               \"domain\"]\n         if key not in allowed_blank_keys and not value:\n-            print \"Blank value of %s is not allowed\" % key\n+            print(\"Blank value of %s is not allowed\" % key)\n             return\n\n         self.prompt = self.get_prompt()\n@@ -671,19 +674,19 @@\n             key = 'url'\n             self.url = \"%s://%s:%s%s\" % (self.protocol, self.host,\n                                          self.port, self.path)\n-            print \"This option has been deprecated, please set 'url' instead\"\n-            print \"This server url will be used:\", self.url\n+            print(\"This option has been deprecated, please set 'url' instead\")\n+            print(\"This server url will be used:\", self.url)\n         write_config(self.get_attr, self.config_file)\n         read_config(self.get_attr, self.set_attr, self.config_file)\n         self.init_credential_store()\n         if key.strip() == 'profile' and self.interpreterMode:\n-            print \"\\nLoaded server profile '%s' with options:\" % value\n+            print(\"\\nLoaded server profile '%s' with options:\" % value)\n             for option in default_profile.keys():\n                 value = self.get_attr(option)\n                 if option in [\"password\", \"apikey\", \"secretkey\"] and value:\n                     value = value[:2] + \"XXX\" + value[4:6] + \"YYY...(hidden)\"\n-                print \"    %s = %s\" % (option, value)\n-            print\n+                print(\"    %s = %s\" % (option, value))\n+            print()\n\n     def complete_set(self, text, line, begidx, endidx):\n         mline = line.partition(\" \")[2].lstrip().partition(\" \")\n@@ -714,7 +717,7 @@\n             session, sessionkey = login(self.url, self.username, self.password)\n             self.credentials['session'] = session\n             self.credentials['sessionkey'] = sessionkey\n-        except Exception, e:\n+        except Exception as e:\n             self.monkeyprint(\"Error: Login failed to the server: \", unicode(e))\n\n     def do_logout(self, args):\n@@ -723,7 +726,7 @@\n         \"\"\"\n         try:\n             logout(self.url, self.credentials.get('session'))\n-        except Exception, e:\n+        except Exception as e:\n             pass\n         self.credentials['session'] = None\n         self.credentials['sessionkey'] = None\n@@ -775,7 +778,7 @@\n                 startIdx = 1\n         elif historyArg == \"clear\" or historyArg == \"c\":\n             readline.clear_history()\n-            print \"CloudMonkey history cleared\"\n+            print(\"CloudMonkey history cleared\")\n             return\n         elif len(historyArg) > 1 and historyArg[0] == \"!\" and historyArg[1:].isdigit():\n             command = readline.get_history_item(long(historyArg[1:]))\nRefactoringTool: Files that were modified:\nRefactoringTool: cloudmonkey/cloudmonkey.py\n```\n\n\u3059\u3054\u3044\u91cf\u3060\u306a\u3041\n\n$ futurize --stage2 -w cloudmonkey/cloudmonkey.py\n\n```\nRefactoringTool: Refactored cloudmonkey/cloudmonkey.py\n--- cloudmonkey/cloudmonkey.py \t(original)\n+++ cloudmonkey/cloudmonkey.py \t(refactored)\n@@ -19,6 +19,13 @@\n\n from __future__ import print_function\n from __future__ import absolute_import\n+from future import standard_library\n+standard_library.install_aliases()\n+from builtins import map\n+from builtins import next\n+from builtins import filter\n+from builtins import str\n+from builtins import range\n from functools import reduce\n try:\n     import argcomplete\n@@ -46,7 +53,7 @@\n     from .requester import monkeyrequest\n     from .requester import login\n     from .requester import logout\n-    from urlparse import urlparse\n+    from urllib.parse import urlparse\n     from xml.dom.minidom import parseString\n except ImportError as e:\n     print(\"Import error in %s : %s\" % (__name__, e))\n@@ -109,16 +116,15 @@\n         self.init_credential_store()\n         logging.basicConfig(filename=self.log_file,\n                             level=logging.DEBUG, format=log_fmt)\n-        logger.debug(\"Loaded config fields:\\n%s\" % map(lambda x: \"%s=%s\" %\n-                                                       (x, getattr(self, x)),\n-                                                       self.config_options))\n+        logger.debug(\"Loaded config fields:\\n%s\" % [\"%s=%s\" %\n+                                                       (x, getattr(self, x)) for x in self.config_options])\n         cmd.Cmd.__init__(self)\n\n         try:\n             if os.path.exists(self.history_file):\n                 readline.read_history_file(self.history_file)\n         except IOError as e:\n-            logger.debug(u\"Error: Unable to read history. \" + unicode(e))\n+            logger.debug(u\"Error: Unable to read history. \" + str(e))\n         atexit.register(readline.write_history_file, self.history_file)\n\n     def init_credential_store(self):\n@@ -221,8 +227,8 @@\n             for arg in args:\n                 if isinstance(type(arg), type(None)) or not arg:\n                     continue\n-                if not (isinstance(arg, str) or isinstance(arg, unicode)):\n-                    arg = unicode(arg)\n+                if not (isinstance(arg, str) or isinstance(arg, str)):\n+                    arg = str(arg)\n                 output += arg\n         except Exception as e:\n             print(str(e))\n@@ -249,7 +255,7 @@\n             if result_filter:\n                 for res in result_filter:\n                     tfilter[res] = 1\n-                for okey, oval in result.iteritems():\n+                for okey, oval in result.items():\n                     if isinstance(oval, dict):\n                         for tkey in oval:\n                             if tkey not in tfilter:\n@@ -289,8 +295,8 @@\n             if \"count\" in result:\n                 result.pop(\"count\")\n\n-            if len(result.keys()) == 1:\n-                item = result[result.keys()[0]]\n+            if len(list(result.keys())) == 1:\n+                item = result[list(result.keys())[0]]\n                 if isinstance(item, list):\n                     result = item\n                 elif isinstance(item, dict):\n@@ -298,7 +304,7 @@\n\n             if isinstance(result, list) and len(result) > 0:\n                 if isinstance(result[0], dict):\n-                    keys = result[0].keys()\n+                    keys = list(result[0].keys())\n                     writer = csv.DictWriter(sys.stdout, keys)\n                     print(','.join(keys))\n                     for item in result:\n@@ -307,13 +313,13 @@\n                             if k not in item:\n                                 row[k] = None\n                             else:\n-                                if type(item[k]) is unicode:\n+                                if type(item[k]) is str:\n                                     row[k] = item[k].encode('utf8')\n                                 else:\n                                     row[k] = item[k]\n                         writer.writerow(row)\n             elif isinstance(result, dict):\n-                keys = result.keys()\n+                keys = list(result.keys())\n                 writer = csv.DictWriter(sys.stdout, keys)\n                 print(','.join(keys))\n                 writer.writerow(result)\n@@ -327,8 +333,7 @@\n             toprow = []\n             if not result:\n                 return\n-            toprow = set(reduce(lambda x, y: x + y, map(lambda x: x.keys(),\n-                         filter(lambda x: isinstance(x, dict), result))))\n+            toprow = set(reduce(lambda x, y: x + y, [list(x.keys()) for x in [x for x in result if isinstance(x, dict)]]))\n             printer = print_table(printer, toprow)\n             for node in result:\n                 if not node:\n@@ -336,13 +341,13 @@\n                 for key in toprow:\n                     if key not in node:\n                         node[key] = ''\n-                row = map(lambda x: node[x], toprow)\n+                row = [node[x] for x in toprow]\n                 if printer and row:\n                     printer.add_row(row)\n             print_table(printer, toprow)\n\n         def print_result_as_dict(result):\n-            for key in sorted(result.keys(), key=lambda x:\n+            for key in sorted(list(result.keys()), key=lambda x:\n                               x not in ['id', 'count', 'name'] and x):\n                 if isinstance(result[key], list):\n                     self.monkeyprint(key + \":\")\n@@ -351,7 +356,7 @@\n                     self.monkeyprint(key + \":\")\n                     print_result_as_dict(result[key])\n                 else:\n-                    value = unicode(result[key])\n+                    value = str(result[key])\n                     self.monkeyprint(key, \" = \", value)\n\n         def print_result_as_list(result):\n@@ -404,20 +409,20 @@\n         if not api:\n             return\n         logger.debug(\"Updating param cache for %s API\" % api)\n-        responsekey = filter(lambda x: 'response' in x, result.keys())[0]\n+        responsekey = filter(lambda x: 'response' in x, list(result.keys()))[0]\n         result = result[responsekey]\n         options = []\n         uuids = []\n-        for key in result.keys():\n+        for key in list(result.keys()):\n             if isinstance(result[key], list):\n                 for element in result[key]:\n-                    if 'id' in element.keys():\n-                        uuid = unicode(element['id'])\n+                    if 'id' in list(element.keys()):\n+                        uuid = str(element['id'])\n                         name = \"\"\n                         keyspace = [\"name\", \"displayname\",\n                                     \"username\", \"description\"]\n                         for name_key in keyspace:\n-                            if name_key in element.keys():\n+                            if name_key in list(element.keys()):\n                                 name = element[name_key]\n                                 break\n                         options.append((uuid, name,))\n@@ -462,15 +467,13 @@\n\n         field_filter = []\n         if 'filter' in args_dict:\n-            field_filter = filter(lambda x: x.strip() != '',\n-                                  args_dict.pop('filter').split(','))\n+            field_filter = [x for x in args_dict.pop('filter').split(',') if x.strip() != '']\n             field_filter = list(set(field_filter))\n\n         missing = []\n         if verb in self.apicache and subject in self.apicache[verb]:\n-            missing = filter(lambda x: x not in [key.split('[')[0].lower()\n-                                                 for key in args_dict],\n-                             self.apicache[verb][subject]['requiredparams'])\n+            missing = [x for x in self.apicache[verb][subject]['requiredparams'] if x not in [key.split('[')[0].lower()\n+                                                 for key in args_dict]]\n\n         if len(missing) > 0:\n             self.monkeyprint(\"Missing arguments: \", ' '.join(missing))\n@@ -484,13 +487,13 @@\n         result = self.make_request(apiname, args_dict, isasync)\n\n         if not result or not isinstance(result, dict):\n-            if isinstance(result, unicode):\n+            if isinstance(result, str):\n                 result = result.decode(\"utf-8\")\n             logger.debug(\"Invalid command result: %s\" % result)\n             return\n\n         try:\n-            responsekeys = filter(lambda x: 'response' in x, result.keys())\n+            responsekeys = [x for x in list(result.keys()) if 'response' in x]\n             for responsekey in responsekeys:\n                 self.print_result(result[responsekey], field_filter)\n             if apiname.startswith(\"list\") and \"id\" not in args_dict:\n@@ -513,13 +516,10 @@\n         search_string = \"\"\n\n         if separator != \" \":   # Complete verb subjects\n-            autocompletions = map(lambda x: x + \" \",\n-                                  self.apicache[verb].keys())\n+            autocompletions = [x + \" \" for x in list(self.apicache[verb].keys())]\n             search_string = subject\n         else:                  # Complete subject params\n-            autocompletions = map(lambda x: x + \"=\",\n-                                  map(lambda x: x['name'],\n-                                      self.apicache[verb][subject]['params']))\n+            autocompletions = [x + \"=\" for x in [x['name'] for x in self.apicache[verb][subject]['params']]]\n             search_string = text\n             if self.paramcompletion == 'true':\n                 param = line[:endidx].split(\" \")[-1]\n@@ -528,25 +528,19 @@\n                 param = param[:idx]\n                 if param == \"filter\":\n                     response_params = self.apicache[verb][subject][\"response\"]\n-                    used = filter(lambda x: x.strip() != \"\",\n-                                  value.split(\",\")[:-1])\n-                    unused = map(lambda x: x['name'] + \",\", filter(lambda x:\n-                                 \"name\" in x and x[\"name\"] not in used,\n-                                 response_params))\n+                    used = [x for x in value.split(\",\")[:-1] if x.strip() != \"\"]\n+                    unused = [x['name'] + \",\" for x in [x for x in response_params if \"name\" in x and x[\"name\"] not in used]]\n                     last_value = value.split(\",\")[-1]\n                     if last_value:\n-                        unused = filter(lambda x: x.startswith(last_value),\n-                                        unused)\n+                        unused = [x for x in unused if x.startswith(last_value)]\n                     suffix = \",\".join(used)\n                     if suffix:\n                         suffix += \",\"\n                     global normal_readline\n                     if normal_readline:\n-                        return filter(lambda x: x.startswith(last_value),\n-                                      map(lambda x: x, unused))\n+                        return [x for x in [x for x in unused] if x.startswith(last_value)]\n                     else:  # OSX fix\n-                        return filter(lambda x: x.startswith(value),\n-                                      map(lambda x: suffix + x, unused))\n+                        return [x for x in [suffix + x for x in unused] if x.startswith(value)]\n                 elif len(value) < 36 and idx != -1:\n                     api = None\n                     logger.debug(\"[Paramcompl] For %s %s %s=\" % (verb, subject,\n@@ -574,10 +568,9 @@\n                         params = self.apicache[verb][subject]['params']\n                         arg = filter(lambda x: x['name'] == param, params)[0]\n                         if \"type\" in arg and arg[\"type\"] == \"boolean\":\n-                            return filter(lambda x: x.startswith(value),\n-                                          [\"true \", \"false \"])\n+                            return [x for x in [\"true \", \"false \"] if x.startswith(value)]\n                         related = arg['related']\n-                        apis = filter(lambda x: 'list' in x, related)\n+                        apis = [x for x in related if 'list' in x]\n                         logger.debug(\"[Paramcompl] Related APIs: %s\" % apis)\n                         if len(apis) > 0:\n                             api = apis[0]\n@@ -589,7 +582,7 @@\n                     uuids = []\n                     cache_burst_ts = int(time.time()) - 900\n                     logger.debug(\"Trying paramcompletion using API: %s\" % api)\n-                    if api in self.param_cache.keys() and \\\n+                    if api in list(self.param_cache.keys()) and \\\n                         len(self.param_cache[api][\"options\"]) > 0 and \\\n                             self.param_cache[api][\"ts\"] > cache_burst_ts:\n                         for option in self.param_cache[api][\"options\"]:\n@@ -611,7 +604,7 @@\n                             name = option[1]\n                             if uuid.startswith(value):\n                                 print(uuid, name)\n-                    autocompletions = map(lambda x: x + \" \", uuids)\n+                    autocompletions = [x + \" \" for x in uuids]\n                     search_string = value\n\n         if subject != \"\" and line.split(\" \")[-1].find('=') == -1:\n@@ -681,7 +674,7 @@\n         self.init_credential_store()\n         if key.strip() == 'profile' and self.interpreterMode:\n             print(\"\\nLoaded server profile '%s' with options:\" % value)\n-            for option in default_profile.keys():\n+            for option in list(default_profile.keys()):\n                 value = self.get_attr(option)\n                 if option in [\"password\", \"apikey\", \"secretkey\"] and value:\n                     value = value[:2] + \"XXX\" + value[4:6] + \"YYY...(hidden)\"\n@@ -718,7 +711,7 @@\n             self.credentials['session'] = session\n             self.credentials['sessionkey'] = sessionkey\n         except Exception as e:\n-            self.monkeyprint(\"Error: Login failed to the server: \", unicode(e))\n+            self.monkeyprint(\"Error: Login failed to the server: \", str(e))\n\n     def do_logout(self, args):\n         \"\"\"\n@@ -773,7 +766,7 @@\n         numLen = len(str(endIdx))\n         historyArg = args.split(' ')[0]\n         if historyArg.isdigit():\n-            startIdx = endIdx - long(historyArg)\n+            startIdx = endIdx - int(historyArg)\n             if startIdx < 1:\n                 startIdx = 1\n         elif historyArg == \"clear\" or historyArg == \"c\":\n@@ -781,11 +774,11 @@\n             print(\"CloudMonkey history cleared\")\n             return\n         elif len(historyArg) > 1 and historyArg[0] == \"!\" and historyArg[1:].isdigit():\n-            command = readline.get_history_item(long(historyArg[1:]))\n+            command = readline.get_history_item(int(historyArg[1:]))\n             readline.set_startup_hook(lambda: readline.insert_text(command))\n             self.hook_count = 1\n             return\n-        for idx in xrange(startIdx, endIdx):\n+        for idx in range(startIdx, endIdx):\n             self.monkeyprint(\"%s %s\" % (str(idx).rjust(numLen),\n                                         readline.get_history_item(idx)))\n\nRefactoringTool: Files that were modified:\nRefactoringTool: cloudmonkey/cloudmonkey.py\n```\n\n$ cloudmonkey\n\n```\nTraceback (most recent call last):\n  File \"/Users/kentaro/porting/ven/bin/cloudmonkey\", line 9, in <module>\n    load_entry_point('cloudmonkey', 'console_scripts', 'cloudmonkey')()\n  File \"/Users/kentaro/porting/ven/lib/python3.5/site-packages/pkg_resources/__init__.py\", line 542, in load_entry_point\n    return get_distribution(dist).load_entry_point(group, name)\n  File \"/Users/kentaro/porting/ven/lib/python3.5/site-packages/pkg_resources/__init__.py\", line 2569, in load_entry_point\n    return ep.load()\n  File \"/Users/kentaro/porting/ven/lib/python3.5/site-packages/pkg_resources/__init__.py\", line 2229, in load\n    return self.resolve()\n  File \"/Users/kentaro/porting/ven/lib/python3.5/site-packages/pkg_resources/__init__.py\", line 2235, in resolve\n    module = __import__(self.module_name, fromlist=['__name__'], level=0)\n  File \"/Users/kentaro/porting/cloudstack-cloudmonkey/cloudmonkey/cloudmonkey.py\", line 45, in <module>\n    from .cachemaker import loadcache, savecache, monkeycache, splitverbsubject\n  File \"/Users/kentaro/porting/cloudstack-cloudmonkey/cloudmonkey/cachemaker.py\", line 25\n    except ImportError, e:\n                      ^\nSyntaxError: invalid syntax\n```\n\n\u4eca\u5ea6\u306fcachemaker.py\n\n$ futurize --stage1 -w cloudmonkey/cachemaker.py\n\n```\nRefactoringTool: Skipping optional fixer: idioms\nRefactoringTool: Skipping optional fixer: ws_comma\nRefactoringTool: Refactored cloudmonkey/cachemaker.py\n--- cloudmonkey/cachemaker.py  \t(original)\n+++ cloudmonkey/cachemaker.py  \t(refactored)\n@@ -16,15 +16,17 @@\n # specific language governing permissions and limitations\n # under the License.\n\n+from __future__ import print_function\n+from __future__ import absolute_import\n try:\n     import json\n     import os\n     import types\n\n-    from config import config_fields\n-except ImportError, e:\n+    from .config import config_fields\n+except ImportError as e:\n     import sys\n-    print \"ImportError\", e\n+    print(\"ImportError\", e)\n     sys.exit(1)\n\n\n@@ -73,8 +75,8 @@\n     f.close()\n     try:\n         apicache = json.loads(data)\n-    except ValueError, e:\n-        print \"Error processing json:\", json_file, e\n+    except ValueError as e:\n+        print(\"Error processing json:\", json_file, e)\n         return {}\n     return apicache\n\n@@ -83,16 +85,16 @@\n     \"\"\"\n     Feed this a dictionary of api bananas, it spits out processed cache\n     \"\"\"\n-    if isinstance(type(apis), types.NoneType) or apis is None:\n+    if isinstance(type(apis), type(None)) or apis is None:\n         return {}\n\n     responsekey = filter(lambda x: 'response' in x, apis.keys())\n\n     if len(responsekey) == 0:\n-        print \"[monkeycache] Invalid dictionary, has no response\"\n+        print(\"[monkeycache] Invalid dictionary, has no response\")\n         return None\n     if len(responsekey) != 1:\n-        print \"[monkeycache] Multiple responsekeys, chosing first one\"\n+        print(\"[monkeycache] Multiple responsekeys, chosing first one\")\n\n     responsekey = responsekey[0]\n     verbs = set()\n@@ -102,7 +104,7 @@\n\n     apilist = getvalue(apis[responsekey], 'api')\n     if apilist is None:\n-        print \"[monkeycache] Server response issue, no apis found\"\n+        print(\"[monkeycache] Server response issue, no apis found\")\n\n     for api in apilist:\n         name = getvalue(api, 'name')\n@@ -174,9 +176,9 @@\n\n if __name__ == \"__main__\":\n     cache_file = config_fields['core']['cache_file']\n-    print \"[cachemaker] Pre-caching using user's cloudmonkey cache\", cache_file\n+    print(\"[cachemaker] Pre-caching using user's cloudmonkey cache\", cache_file)\n     if os.path.exists(cache_file):\n         main(cache_file)\n     else:\n-        print \"[cachemaker] Unable to cache apis, file not found\", cache_file\n-        print \"[cachemaker] Run cloudmonkey sync to generate cache\"\n+        print(\"[cachemaker] Unable to cache apis, file not found\", cache_file)\n+        print(\"[cachemaker] Run cloudmonkey sync to generate cache\")\nRefactoringTool: Files that were modified:\nRefactoringTool: cloudmonkey/cachemaker.py\n```\n\n$ futurize --stage2 -w cloudmonkey/cachemaker.py\n\n```\nRefactoringTool: Refactored cloudmonkey/cachemaker.py\n--- cloudmonkey/cachemaker.py  \t(original)\n+++ cloudmonkey/cachemaker.py  \t(refactored)\n@@ -39,7 +39,7 @@\n\n def splitcsvstring(string):\n     if string is not None:\n-        return filter(lambda x: x.strip() != '', string.split(','))\n+        return [x for x in string.split(',') if x.strip() != '']\n     else:\n         return []\n\n@@ -88,7 +88,7 @@\n     if isinstance(type(apis), type(None)) or apis is None:\n         return {}\n\n-    responsekey = filter(lambda x: 'response' in x, apis.keys())\n+    responsekey = [x for x in list(apis.keys()) if 'response' in x]\n\n     if len(responsekey) == 0:\n         print(\"[monkeycache] Invalid dictionary, has no response\")\nRefactoringTool: Files that were modified:\nRefactoringTool: cloudmonkey/cachemaker.py\n```\n\n$ cloudmonkey\n\n```\nTraceback (most recent call last):\n  File \"/Users/kentaro/porting/ven/bin/cloudmonkey\", line 9, in <module>\n    load_entry_point('cloudmonkey', 'console_scripts', 'cloudmonkey')()\n  File \"/Users/kentaro/porting/ven/lib/python3.5/site-packages/pkg_resources/__init__.py\", line 542, in load_entry_point\n    return get_distribution(dist).load_entry_point(group, name)\n  File \"/Users/kentaro/porting/ven/lib/python3.5/site-packages/pkg_resources/__init__.py\", line 2569, in load_entry_point\n    return ep.load()\n  File \"/Users/kentaro/porting/ven/lib/python3.5/site-packages/pkg_resources/__init__.py\", line 2229, in load\n    return self.resolve()\n  File \"/Users/kentaro/porting/ven/lib/python3.5/site-packages/pkg_resources/__init__.py\", line 2235, in resolve\n    module = __import__(self.module_name, fromlist=['__name__'], level=0)\n  File \"/Users/kentaro/porting/cloudstack-cloudmonkey/cloudmonkey/cloudmonkey.py\", line 52, in <module>\n    from .printer import monkeyprint\n  File \"/Users/kentaro/porting/cloudstack-cloudmonkey/cloudmonkey/printer.py\", line 27\n    except ImportError, e:\n                      ^\nSyntaxError: invalid syntax\n```\n\n$ futurize --stage1 -w cloudmonkey/printer.py\n\n```\nRefactoringTool: Skipping optional fixer: idioms\nRefactoringTool: Skipping optional fixer: ws_comma\nRefactoringTool: Refactored cloudmonkey/printer.py\n--- cloudmonkey/printer.py     \t(original)\n+++ cloudmonkey/printer.py     \t(refactored)\n@@ -16,6 +16,7 @@\n # specific language governing permissions and limitations\n # under the License.\n\n+from __future__ import print_function\n try:\n     from pygments import highlight\n     from pygments.console import ansiformat\n@@ -24,8 +25,8 @@\n     from pygments.token import *\n\n     import sys\n-except ImportError, e:\n-    print e\n+except ImportError as e:\n+    print(e)\n\n\n MONKEY_COLORS = {\nRefactoringTool: Files that were modified:\nRefactoringTool: cloudmonkey/printer.py\n\n```\n\n$ futurize --stage2 -w cloudmonkey/printer.py\n\n```\nRefactoringTool: No files need to be modified.\n```\n\n$ cloudmonkey\n\n```\nTraceback (most recent call last):\n  File \"/Users/kentaro/porting/ven/bin/cloudmonkey\", line 9, in <module>\n    load_entry_point('cloudmonkey', 'console_scripts', 'cloudmonkey')()\n  File \"/Users/kentaro/porting/ven/lib/python3.5/site-packages/pkg_resources/__init__.py\", line 542, in load_entry_point\n    return get_distribution(dist).load_entry_point(group, name)\n  File \"/Users/kentaro/porting/ven/lib/python3.5/site-packages/pkg_resources/__init__.py\", line 2569, in load_entry_point\n    return ep.load()\n  File \"/Users/kentaro/porting/ven/lib/python3.5/site-packages/pkg_resources/__init__.py\", line 2229, in load\n    return self.resolve()\n  File \"/Users/kentaro/porting/ven/lib/python3.5/site-packages/pkg_resources/__init__.py\", line 2235, in resolve\n    module = __import__(self.module_name, fromlist=['__name__'], level=0)\n  File \"/Users/kentaro/porting/cloudstack-cloudmonkey/cloudmonkey/cloudmonkey.py\", line 53, in <module>\n    from .requester import monkeyrequest\n  File \"/Users/kentaro/porting/cloudstack-cloudmonkey/cloudmonkey/requester.py\", line 36\n    except ImportError, e:\n                      ^\nSyntaxError: invalid syntax\n```\n\n$ futurize --stage1 -w cloudmonkey/requester.py\n\n```\nRefactoringTool: Skipping optional fixer: idioms\nRefactoringTool: Skipping optional fixer: ws_comma\nRefactoringTool: Refactored cloudmonkey/requester.py\n--- cloudmonkey/requester.py   \t(original)\n+++ cloudmonkey/requester.py   \t(refactored)\n@@ -17,6 +17,7 @@\n # specific language governing permissions and limitations\n # under the License.\n\n+from __future__ import print_function\n try:\n     import base64\n     import hashlib\n@@ -33,8 +34,8 @@\n     from datetime import datetime, timedelta\n     from requests_toolbelt import SSLAdapter\n     from urllib2 import HTTPError, URLError\n-except ImportError, e:\n-    print \"Import error in %s : %s\" % (__name__, e)\n+except ImportError as e:\n+    print(\"Import error in %s : %s\" % (__name__, e))\n     import sys\n     sys.exit()\n\n@@ -74,7 +75,7 @@\n\n     try:\n         resp = session.post(url, params=args, verify=verifysslcert)\n-    except requests.exceptions.ConnectionError, e:\n+    except requests.exceptions.ConnectionError as e:\n         writeError(\"Connection refused by server: %s\" % e)\n         return None, None\n\n@@ -197,7 +198,7 @@\n         try:\n             return make_request_with_password(command, args, logger, url,\n                                               credentials, verifysslcert)\n-        except (requests.exceptions.ConnectionError, Exception), e:\n+        except (requests.exceptions.ConnectionError, Exception) as e:\n             return None, e\n\n     def sign_request(params, secret_key):\n@@ -231,9 +232,9 @@\n         elif response.status_code != 200 and response.status_code != 401:\n             error = \"{0}: {1}\".format(response.status_code,\n                                       response.headers.get('X-Description'))\n-    except requests.exceptions.ConnectionError, e:\n+    except requests.exceptions.ConnectionError as e:\n         return None, \"Connection refused by server: %s\" % e\n-    except Exception, pokemon:\n+    except Exception as pokemon:\n         error = pokemon.message\n\n     logger_debug(logger, \"Response received: %s\" % result)\n@@ -263,7 +264,7 @@\n     def process_json(response):\n         try:\n             response = json.loads(response, \"utf-8\")\n-        except ValueError, e:\n+        except ValueError as e:\n             logger_debug(logger, \"Error processing json: %s\" % e)\n             writeError(\"Error processing json: %s\" % e)\n             response = None\n@@ -292,7 +293,7 @@\n         while timeout > 0:\n             interval = 2\n             while interval > 0:\n-                sys.stdout.write(u\"%s\\r\" % cursor.next())\n+                sys.stdout.write(u\"%s\\r\" % next(cursor))\n                 sys.stdout.flush()\n                 time.sleep(0.1)\n                 interval -= 0.1\nRefactoringTool: Files that were modified:\nRefactoringTool: cloudmonkey/requester.py\n```\n\n$ futurize --stage2 -w cloudmonkey/requester.py\n\n```\nRefactoringTool: Refactored cloudmonkey/requester.py\n--- cloudmonkey/requester.py   \t(original)\n+++ cloudmonkey/requester.py   \t(refactored)\n@@ -18,6 +18,12 @@\n # under the License.\n\n from __future__ import print_function\n+from future import standard_library\n+standard_library.install_aliases()\n+from builtins import filter\n+from builtins import zip\n+from builtins import next\n+from builtins import str\n try:\n     import base64\n     import hashlib\n@@ -28,12 +34,12 @@\n     import ssl\n     import sys\n     import time\n-    import urllib\n-    import urllib2\n+    import urllib.request, urllib.parse, urllib.error\n+    import urllib.request, urllib.error, urllib.parse\n\n     from datetime import datetime, timedelta\n     from requests_toolbelt import SSLAdapter\n-    from urllib2 import HTTPError, URLError\n+    from urllib.error import HTTPError, URLError\n except ImportError as e:\n     print(\"Import error in %s : %s\" % (__name__, e))\n     import sys\n@@ -183,9 +189,9 @@\n         expirationtime = datetime.utcnow() + timedelta(seconds=int(expires))\n         args[\"expires\"] = expirationtime.strftime('%Y-%m-%dT%H:%M:%S+0000')\n\n-    for key in args.keys():\n+    for key in list(args.keys()):\n         value = args[key]\n-        if isinstance(value, unicode):\n+        if isinstance(value, str):\n             value = value.encode(\"utf-8\")\n         args[key] = value\n         if not key:\n@@ -202,12 +208,12 @@\n             return None, e\n\n     def sign_request(params, secret_key):\n-        request = zip(params.keys(), params.values())\n+        request = list(zip(list(params.keys()), list(params.values())))\n         request.sort(key=lambda x: x[0].lower())\n         hash_str = \"&\".join(\n             [\"=\".join(\n                 [r[0].lower(),\n-                 urllib.quote_plus(str(r[1]), safe=\"*\").lower()\n+                 urllib.parse.quote_plus(str(r[1]), safe=\"*\").lower()\n                  .replace(\"+\", \"%20\").replace(\"%3A\", \":\")]\n             ) for r in request]\n         )\n@@ -275,12 +281,12 @@\n     if not response or not isinstance(response, dict):\n         return response, error\n\n-    m = list(v for v in response.keys() if 'response' in v.lower())\n+    m = list(v for v in list(response.keys()) if 'response' in v.lower())\n     if not m:\n         return response, 'Invalid response received: %s' % response\n\n     isasync = isasync and (asyncblock == \"true\" or asyncblock == \"True\")\n-    responsekey = filter(lambda x: 'response' in x, response.keys())[0]\n+    responsekey = filter(lambda x: 'response' in x, list(response.keys()))[0]\n\n     if isasync and 'jobid' in response[responsekey]:\n         jobid = response[responsekey]['jobid']\n@@ -306,7 +312,7 @@\n                 return response, error\n\n             response = process_json(response)\n-            responsekeys = filter(lambda x: 'response' in x, response.keys())\n+            responsekeys = [x for x in list(response.keys()) if 'response' in x]\n\n             if len(responsekeys) < 1:\n                 continue\nRefactoringTool: Files that were modified:\nRefactoringTool: cloudmonkey/requester.py\n```\n\n\b\n$ cloudmonkey\n\n```\n\u2601 Apache CloudStack \ud83d\udc35 cloudmonkey 5.3.3. Type help or ? to list commands.\n\nUsing management server profile: local\n\n(local) \ud83d\udc35 >\n```\n\n\u30aa\u30aa\u30aa\u30aa\u30aa\u30aa\u30fc\u30fc\n\u30e4\u30c3\u30bf\u30a1\u30fc\n\n\u8d77\u52d5\u3057\u305f\u3041\n\n```\n(local) \ud83d\udc35 >?\n\nDocumented commands (type help <topic>):\n========================================\nEOF        change     disable       history  prepare    reset    start\nactivate   clean      disassociate  import   query      resize   stop\nadd        configure  enable        issue    quit       restart  suspend\napi        copy       exit          ldap     reboot     restore  sync\narchive    create     expunge       list     reconnect  revert   update\nassign     dedicate   extract       lock     recover    revoke   upgrade\nassociate  delete     find          login    register   saml     upload\nattach     deploy     generate      logout   release    scale\nauthorize  destroy    get           mark     remove     set\ncancel     detach     help          migrate  replace    shell\n```\n\nhelp\u3082\u51fa\u529b\u3055\u308c\u308b\u307f\u305f\u3044\u3000\u266a\n\n\u3067\u3082\u8a2d\u5b9a\u3057\u3066\u307f\u308b\u3068\u30a8\u30e9\u30fc\u3067\u7d42\u4e86\n\n```\n(local) \ud83d\udc35 > set url https://comp-api.jp-e1.cloudn-service.com/client/api\n(local) \ud83d\udc35 > exit\nTraceback (most recent call last):\n  File \"/Users/kentaro/porting/ven/bin/cloudmonkey\", line 9, in <module>\n    load_entry_point('cloudmonkey', 'console_scripts', 'cloudmonkey')()\n  File \"/Users/kentaro/porting/cloudstack-cloudmonkey/cloudmonkey/cloudmonkey.py\", line 920, in main\n    shell.cmdloop()\n  File \"/Users/kentaro/porting/cloudstack-cloudmonkey/cloudmonkey/cloudmonkey.py\", line 163, in cmdloop\n    super(CloudMonkeyShell, self).cmdloop(intro=\"\")\n  File \"/usr/local/Cellar/python3/3.5.2_1/Frameworks/Python.framework/Versions/3.5/lib/python3.5/cmd.py\", line 138, in cmdloop\n    stop = self.onecmd(line)\n  File \"/usr/local/Cellar/python3/3.5.2_1/Frameworks/Python.framework/Versions/3.5/lib/python3.5/cmd.py\", line 217, in onecmd\n    return func(arg)\n  File \"/Users/kentaro/porting/cloudstack-cloudmonkey/cloudmonkey/cloudmonkey.py\", line 841, in do_exit\n    return self.do_quit(args)\n  File \"/Users/kentaro/porting/cloudstack-cloudmonkey/cloudmonkey/cloudmonkey.py\", line 847, in do_quit\n    self.monkeyprint(\"Bye!\")\n  File \"/Users/kentaro/porting/cloudstack-cloudmonkey/cloudmonkey/cloudmonkey.py\", line 238, in monkeyprint\n    monkeyprint(output)\n  File \"/Users/kentaro/porting/cloudstack-cloudmonkey/cloudmonkey/printer.py\", line 122, in monkeyprint\n    if text.startswith(\"Error\"):\nTypeError: startswith first arg must be bytes or a tuple of bytes, not str\n\n```\n\n\u30d8\u30eb\u30d7\u306f\u52d5\u3044\u3066\u308b\u3093\u3060\u3051\u3069\u306a\u3041\n\n\n```\n(local) \ud83d\udc35 > ? set\n\n        Set config for cloudmonkey. For example, options can be:\n        url, auth, log_file, history_file\n        You may also edit your ~/.cloudmonkey_config instead of using set.\n\n        Example:\n        set url http://localhost:8080/client/api\n        set prompt \ud83d\udc35 cloudmonkey>\n        set log_file /var/log/cloudmonkey.log\n```\n\n\u3069\u3053\u306b\u30a8\u30e9\u30fc\u304c\u308b\u306e\u304b\u306a\u3041\n\n\u30ed\u30b0\u306b\u306f\u4f55\u3082\u6b8b\u3063\u3066\u306a\u3044\u304b\u3089\u30d5\u30a1\u30a4\u30eb\u306e\u66f8\u304d\u8fbc\u307f\u304b\u306a\u3041\n\n```sh\n\b$ ls ~/.cloudmonkey/log\n```\n\n````control\n/Users/kentaro/.cloudmonkey/log\n```\n\n\u3053\u306e\u3042\u305f\u308a\u304c\u602a\u3057\u3044\uff1f\uff1f\n\n```control\n\n File \"/Users/kentaro/porting/cloudstack-cloudmonkey/cloudmonkey/config.py\", line 141, in write_config\n    config.write(cfg)\n```\n\n\u30d7\u30ed\u30b8\u30a7\u30af\u30c8\u3067config.write\uff08\uff09\u3092\u691c\u7d22\u3057\u3066\u3082\u3001\u3053\u306e\uff11\u884c\u3057\u304b\u306a\u3044\u306e\u3067\n\n```control\n\n  File \"/Users/kentaro/porting/cloudstack-cloudmonkey/cloudmonkey/config.py\", line 214, in read_config\n    write_config(get_attr, config_file)\n```\n\n1\u884c\u9061\u308b\u3068\u3053\u306e\u884c\u3089\u3057\u3044\n\n```control\nwrite_config(get_attr, config_file)\n```\n\nwrite_config\u306f\u3000config\b.py \u304b\u3089\u6765\u3066\u3044\u308b\u307f\u305f\u3044\n\n```py\n    from .config import read_config, write_config, config_file, default_profile\n```\n\n\u7d50\u5c40\u3000\u3053\u3053\u306b\u305f\u3069\u308a\u7740\u304f\u307f\u305f\u3044\n```py\nTypeError: a bytes-like object is required, not 'str'\n```\n\n\u66f8\u304d\u8fbc\u3082\u3046\u3068\u3057\u3066\u3044\u308b\u3001\u30d5\u30a1\u30a4\u30eb\u304c\u30d0\u30a4\u30ca\u30ea\u3058\u3083\u306a\u3044\u3068\u3044\u3051\u306a\u3044\uff1f\npython2 \u3068python3\u306e\u5dee\u3068\u3057\u3066\u30d5\u30a1\u30a4\u30eb\u306e\u958b\u3051\u65b9\u306b\u5dee\u304c\u3042\u308a\u3001\u30d0\u30a4\u30ca\u30ea\u306e\u5834\u5408\u306f\b\u3000b \u3092\u8ffd\u52a0\u3059\u308b\u307f\u305f\u3044\u3002\n\n```py\ndef write_config(get_attr, config_file):\n    global config_fields, mandatory_sections\n    global default_profile, default_profile_name\n    config = ConfigParser()\n    if os.path.exists(config_file):\n        try:\n            with open(config_file, 'r') as cfg:\n                config.read_file(cfg)\n        except IOError as e:\n            print(\"Error: config_file not found\", e)\n```\n\u3092\n\n```py\ndef write_config(get_attr, config_file):\n    global config_fields, mandatory_sections\n    global default_profile, default_profile_name\n    config = ConfigParser()\n    if os.path.exists(config_file):\n        try:\n            with open(config_file, 'rb') as cfg:\n                config.read_file(cfg)\n        except IOError as e:\n            print(\"Error: config_file not found\", e)\n```\n\n\u306b\u3057\u3066\u307f\u305f\u3068\u3053\u308d!!!\n\n```sh\ncloudmonkey\nSelected profile (local) does not exist, using default values\nMissing configuration was set using default values for keys:\n`asyncblock = true, history_file = /Users/kentaro/.cloudmonkey/history, profile = local, log_file = /Users/kentaro/.cloudmonkey/log, cache_file = /Users/kentaro/.cloudmonkey/cache, paramcompletion = true, prompt = \ud83d\udc35 > , display = default, color = true` in /Users/kentaro/.cloudmonkey/config\n\u2601 Apache CloudStack \ud83d\udc35 cloudmonkey 5.3.3. Type help or ? to list commands.\n\nUsing management server profile: local\n\n(local) \ud83d\udc35 >\n```\n\n\u8d77\u52d5\u306b\u6210\u529f\u3000\uff01\uff01\uff01\n\n```sh\n(local) \ud83d\udc35 > help\n\nDocumented commands (type help <topic>):\n========================================\nEOF        change     disable       history  prepare    reset    start\nactivate   clean      disassociate  import   query      resize   stop\nadd        configure  enable        issue    quit       restart  suspend\napi        copy       exit          ldap     reboot     restore  sync\narchive    create     expunge       list     reconnect  revert   update\nassign     dedicate   extract       lock     recover    revoke   upgrade\nassociate  delete     find          login    register   saml     upload\nattach     deploy     generate      logout   release    scale\nauthorize  destroy    get           mark     remove     set\ncancel     detach     help          migrate  replace    shell\n\n(local) \ud83d\udc35 > exit\nTraceback (most recent call last):\n  File \"/Users/kentaro/porting/ven/bin/cloudmonkey\", line 9, in <module>\n    load_entry_point('cloudmonkey', 'console_scripts', 'cloudmonkey')()\n  File \"/Users/kentaro/porting/cloudstack-cloudmonkey/cloudmonkey/cloudmonkey.py\", line 920, in main\n    shell.cmdloop()\n  File \"/Users/kentaro/porting/cloudstack-cloudmonkey/cloudmonkey/cloudmonkey.py\", line 163, in cmdloop\n    super(CloudMonkeyShell, self).cmdloop(intro=\"\")\n  File \"/usr/local/Cellar/python3/3.5.2_1/Frameworks/Python.framework/Versions/3.5/lib/python3.5/cmd.py\", line 138, in cmdloop\n    stop = self.onecmd(line)\n  File \"/usr/local/Cellar/python3/3.5.2_1/Frameworks/Python.framework/Versions/3.5/lib/python3.5/cmd.py\", line 217, in onecmd\n    return func(arg)\n  File \"/Users/kentaro/porting/cloudstack-cloudmonkey/cloudmonkey/cloudmonkey.py\", line 841, in do_exit\n    return self.do_quit(args)\n  File \"/Users/kentaro/porting/cloudstack-cloudmonkey/cloudmonkey/cloudmonkey.py\", line 847, in do_quit\n    self.monkeyprint(\"Bye!\")\n  File \"/Users/kentaro/porting/cloudstack-cloudmonkey/cloudmonkey/cloudmonkey.py\", line 238, in monkeyprint\n    monkeyprint(output)\n  File \"/Users/kentaro/porting/cloudstack-cloudmonkey/cloudmonkey/printer.py\", line 122, in monkeyprint\n    if text.startswith(\"Error\"):\nTypeError: startswith first arg must be bytes or a tuple of bytes, not str\n```\n\n\u30d8\u30eb\u30d7\u306f\u8868\u793a\u3055\u308c\u308b\u3051\u3069\u3001\u7d42\u4e86\u3059\u3089\u3067\u304d\u306a\u3044\u307f\u305f\u3044\b...\n\n\u4eca\u65e5\u306f\u3053\u3053\u307e\u3067\n", "tags": ["Python", "python3", "CloudStack", "AWS", "Cloudn"]}