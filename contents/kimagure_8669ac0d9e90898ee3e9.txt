{"context": " More than 1 year has passed since last update.I got the idea to write this post from answering a question on StackOverflow about how to reuse data from an Observable: http://stackoverflow.com/questions/34657154/angular2-observable-scan-once-then-subscribe-by-many-async/34785866\nIf you've used RxJS a bit, but not much, you've probably mostly dealt with a single observer to an Observable. That's fine, really, but what happens when you try to add more observers to an Observable? Do you find that each observer sees a \"reset\" version of the state you want?\nThat's probably because you're using a \"Cold\" Observable, which is what you get by default. It makes sense when you look at how Observables work:\nvar numbers = Rx.Observable.create(observer => {\n  console.log('observer subscribed');\n  observer.next(Math.random());\n  observer.next(Math.random());\n  observer.next(Math.random());\n});\n\nnumbers.subscribe(i => console.log(`sub1: ${i}`));\nnumbers.subscribe(i => console.log(`sub2: ${i}`));\n\nGiven what I just told you, you should know that the output of these subscriptions will not be the same, and that you will see \"observer subscribed\" twice:\n\"observer subscribed\"\n\"sub1: 0.7506911975797266\"\n\"sub1: 0.99208431574516\"\n\"sub1: 0.42133050598204136\"\n\"observer subscribed\"\n\"sub2: 0.7750216415151954\"\n\"sub2: 0.530988305574283\"\n\"sub2: 0.6986252819187939\"\n\nSo this will inevitably come up in situations where you have a counter or something like that:\nvar subject = new Rx.Subject();\n\nvar scan = subject.startWith(0).scan((count, change) => count + change);\n\nscan.subscribe(count => console.log(`sub1: ${count}`));\n\nsubject.next(1);\nsubject.next(1);\nsubject.next(1);\n\nscan.subscribe(count => console.log(`sub2: ${count}`));\n\nsubject.next(1);\nsubject.next(1);\nsubject.next(1);\n\n/* output:\n\"sub1: 0\"\n\"sub1: 1\"\n\"sub1: 2\"\n\"sub1: 3\"\n\"sub2: 0\"\n\"sub1: 4\"\n\"sub2: 1\"\n\"sub1: 5\"\n\"sub2: 2\"\n\"sub1: 6\"\n\"sub2: 3\"\n*/\n\nThere's a variety of solutions out there, but the simplest by far is to just use a ReplaySubject. This way, you replay the last X number of values you want when you subscribe, and you can just use the same source of data across various subscribers. Like so:\nvar subject = new Rx.Subject();\n\nvar scan = subject.startWith(0).scan((count, change) => count + change);\n\nvar replaySubject = new Rx.ReplaySubject(1);\n\nscan.subscribe(replaySubject);\n\nreplaySubject.subscribe(count => console.log(`sub1: ${count}`));\n\nsubject.next(1);\nsubject.next(1);\nsubject.next(1);\n\nreplaySubject.subscribe(count => console.log(`sub2: ${count}`));\n\nsubject.next(1);\nsubject.next(1);\nsubject.next(1);\n\n/* output:\n\"sub1: 0\"\n\"sub1: 1\"\n\"sub1: 2\"\n\"sub1: 3\"\n\"sub2: 3\"\n\"sub1: 4\"\n\"sub2: 4\"\n\"sub1: 5\"\n\"sub2: 5\"\n\"sub1: 6\"\n\"sub2: 6\"\n*/\n\nOf course, this means that your original scan Observable is eagerly computed, even when you don't really need it. In this case, you might consider using refCount on a published Observable so that you're not subscribed to the original Observable when you don't need to be. Be aware though: this may not do what you want.\nvar subject = new Rx.Subject();\n\nvar scan = subject.startWith(0).scan((count, change) => count + change);\n\nvar refCounted = scan.publish().refCount();\n\nsubject.next(1);\nsubject.next(1);\nsubject.next(1);\n\nvar subscription = refCounted.subscribe(count => console.log(`sub: ${count}`));\n\nsubject.next(1);\nsubject.next(1);\nsubject.next(1);\n\nsubscription.unsubscribe();\n\nsubject.next(1);\nsubject.next(1);\nsubject.next(1);\n\nvar subscription = refCounted.subscribe(count => console.log(`sub: ${count}`));\n\nsubject.next(1);\nsubject.next(1);\nsubject.next(1);\n\n/* output:\n\"sub: 0\"\n\"sub: 1\"\n\"sub: 2\"\n\"sub: 3\"\n\"sub: 0\" <-- pay attention to this value!\n\"sub: 1\"\n\"sub: 2\"\n\"sub: 3\"\n*/\n\n\nConclusion\nIf you enjoyed this post, or want more clarification, you might enjoy these:\n\nAndre's vide on Cold vs Hot Observables: https://egghead.io/lessons/rxjs-demystifying-cold-and-hot-observables-in-rxjs\n\nPaul Taylor's talk from Reactive 2015 on RxJS: https://youtu.be/QhjALubBQPg?t=385 (especially this timestamp)\n\n\nI got the idea to write this post from answering a question on StackOverflow about how to reuse data from an Observable: http://stackoverflow.com/questions/34657154/angular2-observable-scan-once-then-subscribe-by-many-async/34785866\n\nIf you've used RxJS a bit, but not much, you've probably mostly dealt with a single observer to an Observable. That's fine, really, but what happens when you try to add more observers to an Observable? Do you find that each observer sees a \"reset\" version of the state you want?\n\nThat's probably because you're using a \"Cold\" Observable, which is what you get by default. It makes sense when you look at how Observables work:\n\n```js\nvar numbers = Rx.Observable.create(observer => {\n  console.log('observer subscribed');\n  observer.next(Math.random());\n  observer.next(Math.random());\n  observer.next(Math.random());\n});\n\nnumbers.subscribe(i => console.log(`sub1: ${i}`));\nnumbers.subscribe(i => console.log(`sub2: ${i}`));\n```\n\nGiven what I just told you, you should know that the output of these subscriptions will not be the same, and that you will see \"observer subscribed\" twice:\n\n```\n\"observer subscribed\"\n\"sub1: 0.7506911975797266\"\n\"sub1: 0.99208431574516\"\n\"sub1: 0.42133050598204136\"\n\"observer subscribed\"\n\"sub2: 0.7750216415151954\"\n\"sub2: 0.530988305574283\"\n\"sub2: 0.6986252819187939\"\n```\n\nSo this will inevitably come up in situations where you have a counter or something like that:\n\n```js\nvar subject = new Rx.Subject();\n\nvar scan = subject.startWith(0).scan((count, change) => count + change);\n\nscan.subscribe(count => console.log(`sub1: ${count}`));\n\nsubject.next(1);\nsubject.next(1);\nsubject.next(1);\n\nscan.subscribe(count => console.log(`sub2: ${count}`));\n\nsubject.next(1);\nsubject.next(1);\nsubject.next(1);\n\n/* output:\n\"sub1: 0\"\n\"sub1: 1\"\n\"sub1: 2\"\n\"sub1: 3\"\n\"sub2: 0\"\n\"sub1: 4\"\n\"sub2: 1\"\n\"sub1: 5\"\n\"sub2: 2\"\n\"sub1: 6\"\n\"sub2: 3\"\n*/\n```\n\nThere's a variety of solutions out there, but the simplest by far is to just use a `ReplaySubject`. This way, you replay the last X number of values you want when you subscribe, and you can just use the same source of data across various subscribers. Like so:\n\n```js\nvar subject = new Rx.Subject();\n\nvar scan = subject.startWith(0).scan((count, change) => count + change);\n\nvar replaySubject = new Rx.ReplaySubject(1);\n\nscan.subscribe(replaySubject);\n\nreplaySubject.subscribe(count => console.log(`sub1: ${count}`));\n\nsubject.next(1);\nsubject.next(1);\nsubject.next(1);\n\nreplaySubject.subscribe(count => console.log(`sub2: ${count}`));\n\nsubject.next(1);\nsubject.next(1);\nsubject.next(1);\n\n/* output:\n\"sub1: 0\"\n\"sub1: 1\"\n\"sub1: 2\"\n\"sub1: 3\"\n\"sub2: 3\"\n\"sub1: 4\"\n\"sub2: 4\"\n\"sub1: 5\"\n\"sub2: 5\"\n\"sub1: 6\"\n\"sub2: 6\"\n*/\n```\n\nOf course, this means that your original `scan` Observable is eagerly computed, even when you don't really need it. In this case, you might consider using `refCount` on a `publish`ed Observable so that you're not subscribed to the original Observable when you don't need to be. Be aware though: **this may not do what you want.**\n\n```js\nvar subject = new Rx.Subject();\n\nvar scan = subject.startWith(0).scan((count, change) => count + change);\n\nvar refCounted = scan.publish().refCount();\n\nsubject.next(1);\nsubject.next(1);\nsubject.next(1);\n\nvar subscription = refCounted.subscribe(count => console.log(`sub: ${count}`));\n\nsubject.next(1);\nsubject.next(1);\nsubject.next(1);\n\nsubscription.unsubscribe();\n\nsubject.next(1);\nsubject.next(1);\nsubject.next(1);\n\nvar subscription = refCounted.subscribe(count => console.log(`sub: ${count}`));\n\nsubject.next(1);\nsubject.next(1);\nsubject.next(1);\n\n/* output:\n\"sub: 0\"\n\"sub: 1\"\n\"sub: 2\"\n\"sub: 3\"\n\"sub: 0\" <-- pay attention to this value!\n\"sub: 1\"\n\"sub: 2\"\n\"sub: 3\"\n*/\n```\n\n## Conclusion\n\nIf you enjoyed this post, or want more clarification, you might enjoy these:\n\n* Andre's vide on Cold vs Hot Observables: https://egghead.io/lessons/rxjs-demystifying-cold-and-hot-observables-in-rxjs\n* Paul Taylor's talk from Reactive 2015 on RxJS: https://youtu.be/QhjALubBQPg?t=385 (especially this timestamp)\n", "tags": ["RxJS", "JavaScript"]}