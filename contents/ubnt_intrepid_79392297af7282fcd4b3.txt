{"context": "$n$\u756a\u714e\u3058\u3060\u308d\u3046\u304c\u6c17\u306b\u3057\u306a\u3044\n\u30cd\u30bf\u5143:\n\nhttp://qiita.com/shuetsu@github/items/ac21e597265d6bb906dc\netc.\n\nextern crate rustc_serialize;\n\nuse rustc_serialize::json::Json;\nuse std::collections::HashMap;\nuse std::ops::{Add, Sub, Mul, Div};\n\nstruct Evaluator(HashMap<String, f64>);\n\nimpl Evaluator {\n  fn new() -> Evaluator { Evaluator(HashMap::new()) }\n\n  fn get(&self, key: &str) -> f64 { *self.0.get(key).unwrap() }\n\n  fn set(&mut self, key: &str, val: f64) { self.0.insert(key.to_owned(), val); }\n\n  fn substitute(&mut self, expr: &Json) -> f64 {\n    match *expr {\n      Json::Array(_) => self.eval(expr).as_f64().unwrap(),\n      Json::F64(i) => i,\n      Json::I64(i) => i as f64,\n      Json::U64(i) => i as f64,\n      _ => panic!(\"cannot substitute: {:?} (env: {:?})\", expr, self.0)\n    }\n  }\n\n  fn eval(&mut self, input: &Json) -> Json {\n    let input = input.as_array().expect(\"'input' should be an array\").as_slice();\n\n    let token = input[0].as_string().unwrap();\n    let args = &input[1..];\n\n    match token {\n      \"step\" => self.eval_step(args).unwrap(),\n      \"until\" => self.eval_until(args),\n\n      \"get\" => self.eval_get(args),\n      \"set\" => self.eval_set(args),\n\n      \"==\" => self.eval_cmp(args, |l, r| l == r),\n      \"!=\" => self.eval_cmp(args, |l, r| l != r),\n      \">\" => self.eval_cmp(args, |l, r| l > r),\n      \">=\" => self.eval_cmp(args, |l, r| l >= r),\n      \"<\" => self.eval_cmp(args, |l, r| l < r),\n      \"<=\" => self.eval_cmp(args, |l, r| l <= r),\n\n      \"+\" => self.eval_binop(args, Add::add),\n      \"-\" => self.eval_binop(args, Sub::sub),\n      \"*\" => self.eval_binop(args, Mul::mul),\n      \"/\" => self.eval_binop(args, Div::div),\n\n      _ => panic!(\"invalid token: {:?}\", token)\n    }\n  }\n\n  fn eval_step(&mut self, lines: &[Json]) -> Result<Json, String> {\n    let mut ret = Ok(Json::Null);\n    for line in lines {\n      ret = Ok(self.eval(&line));\n    }\n    ret\n  }\n\n  fn eval_until(&mut self, args: &[Json]) -> Json {\n    loop {\n      let c = self.eval(&args[0]);\n      if c.is_boolean() && c.as_boolean().unwrap() {\n        return Json::Null;\n      }\n      self.eval(&args[1]);\n    }\n  }\n\n  fn eval_get(&mut self, args: &[Json]) -> Json {\n    let key = args[0].as_string().unwrap();\n    Json::F64(self.get(key))\n  }\n\n  fn eval_set(&mut self, args: &[Json]) -> Json {\n    let key = args[0].as_string().unwrap();\n    let val = self.substitute(&args[1]);\n    self.set(key, val);\n    Json::Null\n  }\n\n  fn eval_cmp<C>(&mut self, args: &[Json], cmp: C) -> Json\n    where C: Fn(f64, f64) -> bool\n  {\n    let lhs = self.substitute(&args[0]);\n    let rhs = self.substitute(&args[1]);\n    Json::Boolean(cmp(lhs, rhs))\n  }\n\n  fn eval_binop<O>(&mut self, args: &[Json], op: O) -> Json\n    where O: Fn(f64, f64) -> f64\n  {\n    let lhs = self.substitute(&args[0]);\n    let rhs = self.substitute(&args[1]);\n    Json::F64(op(lhs, rhs))\n  }\n}\n\nfn main() {\n  let source = r#\"\n[\"step\",\n  [\"set\", \"i\", 10],\n  [\"set\", \"sum\", 0],\n  [\"until\", [\"==\", [\"get\", \"i\"], 0], [\n    \"step\",\n    [\"set\", \"sum\", [\"+\", [\"get\", \"sum\"], [\"get\", \"i\"]]],\n    [\"set\", \"i\", [\"+\", [\"get\", \"i\"], -1]]\n  ]],\n  [\"get\", \"sum\"]\n]\n\"#;\n  let input =Json::from_str(source).unwrap();\n\n  let mut e = Evaluator::new();\n\n  println!(\"{:?}\", e.eval(&input));\n}\n\n\n\u5b9f\u884c\u7d50\u679c\n$ cargo run -q\nI64(55)\n\n\n\u305d\u306e\u4ed6\u30d7\u30ed\u30b8\u30a7\u30af\u30c8\u306e\u69cb\u6210\u306a\u3069\u306f\u3053\u3061\u3089\u3092\u3054\u53c2\u8003\u304f\u3060\u3055\u3044\uff0e\n\n\u304a\u308f\u308a\u306b\nrustc_serialize \u4fbf\u5229\uff0e\n\n\u5909\u66f4\u5c65\u6b74\n\n2016-10-01T02:22+0900 \u30b3\u30fc\u30c9\u306e\u5dee\u3057\u66ff\u3048\n2016-10-01T16:57+0900 @tatsuya6502 \u6c0f\u306e\u6307\u6458\u3092\u53d7\u3051\u4e00\u90e8\u4fee\u6b63\n\n$n$\u756a\u714e\u3058\u3060\u308d\u3046\u304c\u6c17\u306b\u3057\u306a\u3044\n\n\u30cd\u30bf\u5143:\n\n* http://qiita.com/shuetsu@github/items/ac21e597265d6bb906dc\n\n* etc.\n\n```rust\nextern crate rustc_serialize;\n\nuse rustc_serialize::json::Json;\nuse std::collections::HashMap;\nuse std::ops::{Add, Sub, Mul, Div};\n\nstruct Evaluator(HashMap<String, f64>);\n\nimpl Evaluator {\n  fn new() -> Evaluator { Evaluator(HashMap::new()) }\n\n  fn get(&self, key: &str) -> f64 { *self.0.get(key).unwrap() }\n\n  fn set(&mut self, key: &str, val: f64) { self.0.insert(key.to_owned(), val); }\n\n  fn substitute(&mut self, expr: &Json) -> f64 {\n    match *expr {\n      Json::Array(_) => self.eval(expr).as_f64().unwrap(),\n      Json::F64(i) => i,\n      Json::I64(i) => i as f64,\n      Json::U64(i) => i as f64,\n      _ => panic!(\"cannot substitute: {:?} (env: {:?})\", expr, self.0)\n    }\n  }\n\n  fn eval(&mut self, input: &Json) -> Json {\n    let input = input.as_array().expect(\"'input' should be an array\").as_slice();\n\n    let token = input[0].as_string().unwrap();\n    let args = &input[1..];\n\n    match token {\n      \"step\" => self.eval_step(args).unwrap(),\n      \"until\" => self.eval_until(args),\n\n      \"get\" => self.eval_get(args),\n      \"set\" => self.eval_set(args),\n\n      \"==\" => self.eval_cmp(args, |l, r| l == r),\n      \"!=\" => self.eval_cmp(args, |l, r| l != r),\n      \">\" => self.eval_cmp(args, |l, r| l > r),\n      \">=\" => self.eval_cmp(args, |l, r| l >= r),\n      \"<\" => self.eval_cmp(args, |l, r| l < r),\n      \"<=\" => self.eval_cmp(args, |l, r| l <= r),\n\n      \"+\" => self.eval_binop(args, Add::add),\n      \"-\" => self.eval_binop(args, Sub::sub),\n      \"*\" => self.eval_binop(args, Mul::mul),\n      \"/\" => self.eval_binop(args, Div::div),\n\n      _ => panic!(\"invalid token: {:?}\", token)\n    }\n  }\n\n  fn eval_step(&mut self, lines: &[Json]) -> Result<Json, String> {\n    let mut ret = Ok(Json::Null);\n    for line in lines {\n      ret = Ok(self.eval(&line));\n    }\n    ret\n  }\n\n  fn eval_until(&mut self, args: &[Json]) -> Json {\n    loop {\n      let c = self.eval(&args[0]);\n      if c.is_boolean() && c.as_boolean().unwrap() {\n        return Json::Null;\n      }\n      self.eval(&args[1]);\n    }\n  }\n\n  fn eval_get(&mut self, args: &[Json]) -> Json {\n    let key = args[0].as_string().unwrap();\n    Json::F64(self.get(key))\n  }\n\n  fn eval_set(&mut self, args: &[Json]) -> Json {\n    let key = args[0].as_string().unwrap();\n    let val = self.substitute(&args[1]);\n    self.set(key, val);\n    Json::Null\n  }\n\n  fn eval_cmp<C>(&mut self, args: &[Json], cmp: C) -> Json\n    where C: Fn(f64, f64) -> bool\n  {\n    let lhs = self.substitute(&args[0]);\n    let rhs = self.substitute(&args[1]);\n    Json::Boolean(cmp(lhs, rhs))\n  }\n\n  fn eval_binop<O>(&mut self, args: &[Json], op: O) -> Json\n    where O: Fn(f64, f64) -> f64\n  {\n    let lhs = self.substitute(&args[0]);\n    let rhs = self.substitute(&args[1]);\n    Json::F64(op(lhs, rhs))\n  }\n}\n\nfn main() {\n  let source = r#\"\n[\"step\",\n  [\"set\", \"i\", 10],\n  [\"set\", \"sum\", 0],\n  [\"until\", [\"==\", [\"get\", \"i\"], 0], [\n    \"step\",\n    [\"set\", \"sum\", [\"+\", [\"get\", \"sum\"], [\"get\", \"i\"]]],\n    [\"set\", \"i\", [\"+\", [\"get\", \"i\"], -1]]\n  ]],\n  [\"get\", \"sum\"]\n]\n\"#;\n  let input =Json::from_str(source).unwrap();\n\n  let mut e = Evaluator::new();\n\n  println!(\"{:?}\", e.eval(&input));\n}\n```\n\n```txt:\u5b9f\u884c\u7d50\u679c\n$ cargo run -q\nI64(55)\n```\n\n\u305d\u306e\u4ed6\u30d7\u30ed\u30b8\u30a7\u30af\u30c8\u306e\u69cb\u6210\u306a\u3069\u306f[\u3053\u3061\u3089](https://github.com/ubnt-intrepid/orslang)\u3092\u3054\u53c2\u8003\u304f\u3060\u3055\u3044\uff0e\n\n# \u304a\u308f\u308a\u306b\n`rustc_serialize` \u4fbf\u5229\uff0e\n\n# \u5909\u66f4\u5c65\u6b74\n* 2016-10-01T02:22+0900 \u30b3\u30fc\u30c9\u306e\u5dee\u3057\u66ff\u3048\n* 2016-10-01T16:57+0900 @tatsuya6502 \u6c0f\u306e\u6307\u6458\u3092\u53d7\u3051\u4e00\u90e8\u4fee\u6b63\n", "tags": ["rust"]}