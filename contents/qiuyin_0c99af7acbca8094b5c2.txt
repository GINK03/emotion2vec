{"tags": ["Clojure"], "context": "\n\nwith 4 step\n\nsudo docker run -it --name brave -v pathOnHost:pathOnContainer -d clojure tail -f /dev/null\nsudo docker exec -it brave /bin/bash\nlein repl (in the container terminal)\n\nenjoy!  \nStart learning from a awesome and free online book.\u3000\nhttp://www.braveclojure.com/getting-started\n\nControl Flow\n\nif\n(if boolean-form\n    then-form\n    optional-else-form)\n\nIf you omit the else branch and the Boolean expression is false, Clojure returns nil.\n\ndo\nThe do operator lets you wrap up multiple forms in parentheses and run each of them.\n(if true\n  (do (println \"Success!\")\n      \"By Zeus's hammer!\")\n  (do (println \"Failure!\")\n      \"By Aquaman's trident!\"))\n\n\nwhen\nis like a combination of if and do, but without else branch.\n(when boolean-form\n    then-form1\n    then-form2)\n\nIf condition is true, the then-form1 and then-form2 will run. \nIf condition is false, nothing will run and return nil.\n\nnil, true false\nBoth nil and false are used to represent logical falsiness, whereas all other values are logically truthy.\n\nequality\n(= 1 1)\n(= nil nil)\n\n\nBoolean operators and and or\n\nor  returns either the first truthy value or the last value.\nand returns either the first falsy  value or the last value.\n\ndef\nBest practice: you should treat def as if it's defining constants.\n\nHash map\ncreate hash maps\n{:key1 \"x\" :key2 \"y\"}\n(hash-map :key1 \"x\" :key2 \"y\")\n\n\nGet value from map\n(get {:key1 \"x\" :key2 \"y\"} :key1)\n(get {:key1 \"x\" :key2 \"y\"} :key3)\n(get {:key1 \"x\" :key2 \"y\"} :key3 \"default\") ;with default value\n({:key1 \"x\" :key2 \"y\"} :key3 (throw (Exception. \"my exception message\")))\n(get-in {:a 0 :b {:c \"ho hum\"}} [:b :c]) ;get nested value\n({:key1 \"x\" :key2 \"y\"} :key1) ; treat the map like a function\n(:key1 {:key1 \"x\" :key2 \"y\"}) ; treat keyword like a function\n\n\nVector\nis similar to an Array.\n[ 1 2 3 ]\n(vector 1 2 3)\n(get [3 2 1] 1) ; get the second element\n(get [3 2 1] 4) ; return nil\n(nth [3 2 1] 4) ; throw IndexOutOfBoundsException\n(conj [1 2 3] 4) ; 4 is added to the end of a vector\n\n\nList\n'(1 2 3 4)\n(list 1 \"two\" {3 4})\n(nth '(1 2 3 4) 3)\n(get '(1 2 3 4) 3) ; this will return nil, never use get with list!!\n(conj '(1 2 3 4) 5) ; 5 is added to the beginning of a list\n\n\nSet\n#{1 2 3 3 3}\n(hash-set 1 1 2 2)\n(set [1 3 3]) ; create sets from vectors and lists\n(set '(1 2 3))\n(contains? #{:a :b} :b) ; return true or false\n(:a #{:a :b}) ; get itself or nil\n(get #{:a :b} nil)\n(get #{:a nil} nil)\n\nDo not use contains? to lists and vectors. see the doc\n\nfunction call\nclojure evaluates all function arguments recursively before passing them to the function.\n\nspecial forms(definitions and if expressions)\nthey don't always evaluate all of their operands.\n\ndefine function(arity overloading)\n(defn x-chop\n  \"Describe the kind of chop you're inflicting on someone\"\n  ([name chop-type]\n     (str \"I \" chop-type \" chop \" name \"! Take that!\"))\n  ([name]\n     (x-chop name \"karate\")))\n\n\nvariable-arity functions\n(defn favorite-things\n  [name & things]\n  (str \"Hi, \" name \", here are my favorite things: \"\n       (clojure.string/join \", \" things)))\n\n(favorite-things \"Doreen\" \"gum\" \"shoes\" \"kara-te\")\n\n\ndestructing(vector,list)\n(defn my-first\n[[first]]\nfirst)\n\n(my-first [\"x\" \"2\"])\n\n(defn my-rest\n[[first & rest]]\nrest)\n\n(my-first [\"x\" \"2\"])\n\n\ndestructing(map)\n(defn xxxx\n[{lat :lat lng :lng}]\n(println lat)\n(println lng))\n\n(defn xxxx\n[{:keys[lat lng] :as location}]\n(println lat)\n(println lng))\n\n(xxxx {:lat 32 :lng 45})\n\n\nAnonymous Functions\n(fn [x y]\n(+ x y))\n\n#(+ %1 %2) ; %1 or % is the first argument\n           ; %2 is the second argument, and so on.\n           ; %& is the rest arguments\n\n\n\nlet (let it be)\nlet will introduce a new scope.\n(def x 0)\n(let [x (inc x)] x) ; return 1\nx ; return 0, not changed\n\nmain uses: 1.name things\n           2.evaluate an expression only once and reuse the result.\n             (like a network API call, the expression has side effects)\n(let [[part & remaining] remaining-asym-parts]\n  (recur remaining\n         (into final-body-parts\n               (set [part (matching-part part)]))))\n\n\nloop\n(loop [iteration 0]\n  (println (str \"Iteration \" iteration))\n  (if (> iteration 3)\n    (println \"Goodbye!\")\n    (recur (inc iteration))))\n\n\nRegular expressions\n#\"regular-expression\"\n(re-find #\"^left-\" \"left-eye\")\n(clojure.string/replace \"left-eye\" #\"^left-\" \"right-\")\n\n\nsequence abstraction\nAs long as a data structure(like list, vector, set, map) responds to the core sequence operations (the functions first, rest, and cons, which we\u2019ll look at more closely in a moment), it will work with map, reduce, and oodles of other sequence functions for free. \n\nconvert to seq\n(seq '(1 2 3))\n; => (1 2 3)\n\n(seq [1 2 3])\n; => (1 2 3)\n\n(seq #{1 2 3})\n; => (1 2 3)\n\n(seq {:name \"Bill Compton\" :occupation \"Dead mopey guy\"})\n; => ([:name \"Bill Compton\"] [:occupation \"Dead mopey guy\"])\n\n\nconvert the seq back into a map\n(into {} (seq {:a 1 :b 2 :c 3})); \n\n\nmap function\n(map inc [1 2 3])\n(map str [\"a\" \"b\" \"c\"] [\"A\" \"B\" \"C\"]) ; => (\"aA\" \"bB\" \"cC\")\n(map #(% 12) [inc #(+ % 2)  #(+ % 3)]) ; functions is data!\n\n\nreduce function\n(reduce (fn [new-map [key val]]\n          (assoc new-map key (inc val)))\n        {}\n        {:max 30 :min 10})\n; => {:max 31, :min 11}\n\n\ntake drop take-while drop-while filter\ntake: take the first n elements of the sequence\ndrop: return the sequence with the first n elements removed\ntake-while: take until the predicate function is false\ndrop-while: drop until the predicate function is false, and return remained.\nfilter: return all elements that test true for a predicate function.\nsome: return the first truthy value returned by a predicate function.\n(take 3 [1 2 3 4 5 6 7 8 9 10])\n; => (1 2 3)\n\n(drop 3 [1 2 3 4 5 6 7 8 9 10])\n; => (4 5 6 7 8 9 10)\n(take-while #(< (:month %) 3) food-journal)\n(drop-while #(< (:month %) 3) food-journal)\n\n(some #(> (:critter %) 3) food-journal) ; => true\n(some #(and (> (:critter %) 3) %) food-journal); => {:month 3 :day 1 :human 4.2 :critter 3.3}\n\n\nsort sort-by\n(sort [3 1 2])\n(sort-by count [\"aaa\" \"c\" \"bb\"])\n\n\nconcat\nconcat simply appends the members of one sequence to the end of another\n(concat [1 2] [3 4])\n\n\nlazy Seqs\n\nA lazy seq is a seq whose members aren\u2019t computed until you try to access them. Computing a seq\u2019s members is called realizing the seq. \nA lazy seq as consisting of two parts: a recipe for how to realize the elements of a sequence and the elements that have been realized so far. \n\n(defn heavy-compute\n  [x]\n  (Thread/sleep 1000)\n  (inc x))\n(def result (map heavy-compute (range 1 1000)))\n(time (first result)) ; \"Elapsed time: 32004.460656 msecs\"\n\n\ninfinite Sequences\n(take 8 (repeat \"na\"))\n(take 3 (repeatedly (fn [] (rand-int 10))))\n(defn even-numbers\n  ([] (even-numbers 0))\n  ([n] (cons n (lazy-seq (even-numbers (+ n 2))))))\n(defn even-numbers\n  ([] (even-numbers 0))\n  ([n] (lazy-seq (cons n (even-numbers (+ n 2))))))\n\n\nCollection Abstraction\nThe sequence abstraction is about operating on members individually, whereas the collection abstraction is about the data structure as a whole. For example, the collection functions count, empty?, and every? aren\u2019t about any individual element; they\u2019re about the whole:\n\ninto\n\nAdding all the elements from the second to the first.\nAs you now know, many seq functions return a seq rather than the original data structure. You\u2019ll probably want to convert the return value back into the original value, and into lets you do that:\n\n(map identity {:sunlight-reaction \"Glitter!\"})\n; => ([:sunlight-reaction \"Glitter!\"])\n\n(into {} (map identity {:sunlight-reaction \"Glitter!\"}))\n; => {:sunlight-reaction \"Glitter!\"}\n\n(map identity [:garlic :sesame-oil :fried-eggs])\n; => (:garlic :sesame-oil :fried-eggs)\n\n(into [] (map identity [:garlic :sesame-oil :fried-eggs]))\n; => [:garlic :sesame-oil :fried-eggs]\n\n\nconj\n(conj [0] [1]) ; => [0 [1]]\n(into [0] [1]) ; => [0 1]\n(conj [0] 1) ; => [0 1]\n\n(conj [0] 1 2 3 4) ; => [0 1 2 3 4]\n(conj {:time \"midnight\"} [:place \"ye olde cemetarium\"]) ; => {:place \"ye olde cemetarium\" :time \"midnight\"}\n\n(defn my-conj\n  [target & additions]\n  (into target additions)) ; define conj in terms of into\n\n\napply\napply explodes a seqable data structure so it can be passed to a function that expects a rest parameter. \n(max 0 1 2)\n(apply max [0 1 2])\n\n\npartial\npartial takes a function and any number of arguments. It then returns a new function. \n```clj\n(def add10 (partial + 10))\n(add10 3)\n(defn my-partial\npartialized-fn & args)\n```\n\ncomplement\nTakes a fn f and returns a fn that takes the same arguments as f,\nhas the same effects, if any, and returns the opposite truth value.\n(def not-empty? (complement empty?))\n\n\nPure Functions\nA function is pure if it meets two qualifications:\n\nIt always returns the same result if given the same arguments. This is called referential transparency.\nIt can\u2019t cause any side effects. That is, the function can\u2019t make any changes that are observable outside the function itself\u2014for example, by changing an externally accessible mutable object or writing to a file.\n\n\ncomp\nComposing functions is so common that Clojure provides a function, comp, for creating a new function from the composition of any number of functions. \nusing comp on the functions f1, f2, ... fn, creates a new function g such that g(x1, x2, ... xn) equals f1( f2( fn(x1, x2, ... xn))). One detail to note here is that the first function applied\u2014* in the code shown here\u2014can take any number of arguments, whereas the remaining functions must be able to take only one argument.\n((comp inc *) 2 3)\n\n(def character\n  {:name \"Smooches McCutes\"\n   :attributes {:intelligence 10\n                :strength 4\n                :dexterity 5}})\n(def c-int (comp :intelligence :attributes))\n\n\nmemoize\nAnother cool thing you can do with pure functions is memoize them so that Clojure remembers the result of a particular function call.\n\nexclude var in cljs.core\n(ns hello.core\n    (:refer-clojure :exclude [map]))\n\n# with 4 step\n1. sudo docker run -it --name brave -v pathOnHost:pathOnContainer -d clojure tail -f /dev/null\n2. sudo docker exec -it brave /bin/bash\n3. lein repl (in the container terminal)\n\nenjoy! :smile: \nStart learning from a awesome and free online book.\u3000\nhttp://www.braveclojure.com/getting-started\n\n# Control Flow\n## if\n```clj\n(if boolean-form\n    then-form\n    optional-else-form)\n```\nIf you omit the _else_ branch and the Boolean expression is _false_, Clojure returns _nil_.\n## do\nThe **do** operator lets you **wrap up multiple forms** in parentheses and run each of them.\n\n```clj\n(if true\n  (do (println \"Success!\")\n      \"By Zeus's hammer!\")\n  (do (println \"Failure!\")\n      \"By Aquaman's trident!\"))\n```\n##when\nis like a **combination of if and do**, but without else branch.\n\n```clj\n(when boolean-form\n    then-form1\n    then-form2)\n```\nIf condition is true, the _then-form1_ and _then-form2_ will run. \nIf condition is false, nothing will run and return nil.\n\n##nil, true false\nBoth **nil** and **false** are used to represent logical falsiness, whereas all other values are logically truthy.\n\n##equality\n\n```clj\n(= 1 1)\n(= nil nil)\n```\n##Boolean operators **and** and **or**\n_or_  returns either the first truthy value or the last value.\n_and_ returns either the first falsy  value or the last value.\n\n##def\nBest practice: you should treat **def** as if it's defining constants.\n\n##Hash map\ncreate hash maps\n\n```clj\n{:key1 \"x\" :key2 \"y\"}\n(hash-map :key1 \"x\" :key2 \"y\")\n```\n\n## Get value from map\n\n```clj\n(get {:key1 \"x\" :key2 \"y\"} :key1)\n(get {:key1 \"x\" :key2 \"y\"} :key3)\n(get {:key1 \"x\" :key2 \"y\"} :key3 \"default\") ;with default value\n({:key1 \"x\" :key2 \"y\"} :key3 (throw (Exception. \"my exception message\")))\n(get-in {:a 0 :b {:c \"ho hum\"}} [:b :c]) ;get nested value\n({:key1 \"x\" :key2 \"y\"} :key1) ; treat the map like a function\n(:key1 {:key1 \"x\" :key2 \"y\"}) ; treat keyword like a function\n```\n\n##Vector\nis similar to an Array.\n\n```clj\n[ 1 2 3 ]\n(vector 1 2 3)\n(get [3 2 1] 1) ; get the second element\n(get [3 2 1] 4) ; return nil\n(nth [3 2 1] 4) ; throw IndexOutOfBoundsException\n(conj [1 2 3] 4) ; 4 is added to the end of a vector\n```\n##List\n\n\n```clj\n'(1 2 3 4)\n(list 1 \"two\" {3 4})\n(nth '(1 2 3 4) 3)\n(get '(1 2 3 4) 3) ; this will return nil, never use get with list!!\n(conj '(1 2 3 4) 5) ; 5 is added to the beginning of a list\n```\n\n##Set\n```clj\n#{1 2 3 3 3}\n(hash-set 1 1 2 2)\n(set [1 3 3]) ; create sets from vectors and lists\n(set '(1 2 3))\n(contains? #{:a :b} :b) ; return true or false\n(:a #{:a :b}) ; get itself or nil\n(get #{:a :b} nil)\n(get #{:a nil} nil)\n```\n **Do not use contains? to lists and vectors.** [see the doc](https://clojuredocs.org/clojure.core/contains_q)\n\n##function call\n_clojure evaluates all function arguments recursively before passing them to the function_.\n\n##special forms(definitions and _if_ expressions)\n_they don't always evaluate all of their operands_.\n\n##define function(arity overloading)\n\n```clj\n(defn x-chop\n  \"Describe the kind of chop you're inflicting on someone\"\n  ([name chop-type]\n     (str \"I \" chop-type \" chop \" name \"! Take that!\"))\n  ([name]\n     (x-chop name \"karate\")))\n```\n\n##variable-arity functions\n\n```clj\n(defn favorite-things\n  [name & things]\n  (str \"Hi, \" name \", here are my favorite things: \"\n       (clojure.string/join \", \" things)))\n\n(favorite-things \"Doreen\" \"gum\" \"shoes\" \"kara-te\")\n```\n\n##destructing(vector,list)\n\n```clj\n(defn my-first\n[[first]]\nfirst)\n\n(my-first [\"x\" \"2\"])\n\n(defn my-rest\n[[first & rest]]\nrest)\n\n(my-first [\"x\" \"2\"])\n```\n\n##destructing(map)\n\n```clj\n(defn xxxx\n[{lat :lat lng :lng}]\n(println lat)\n(println lng))\n\n(defn xxxx\n[{:keys[lat lng] :as location}]\n(println lat)\n(println lng))\n\n(xxxx {:lat 32 :lng 45})\n```\n\n##Anonymous Functions\n```clj\n(fn [x y]\n(+ x y))\n\n#(+ %1 %2) ; %1 or % is the first argument\n           ; %2 is the second argument, and so on.\n           ; %& is the rest arguments\n\n```\n\n##let (_let it be_)\n**let** will introduce a new scope.\n\n```clj\n(def x 0)\n(let [x (inc x)] x) ; return 1\nx ; return 0, not changed\n```\nmain uses: 1.name things\n           2.evaluate an expression only once and reuse the result.\n             (like a network API call, the expression has side effects)\n\n```clj\n(let [[part & remaining] remaining-asym-parts]\n  (recur remaining\n         (into final-body-parts\n               (set [part (matching-part part)]))))\n```  \n\n## loop\n\n\n```clj\n(loop [iteration 0]\n  (println (str \"Iteration \" iteration))\n  (if (> iteration 3)\n    (println \"Goodbye!\")\n    (recur (inc iteration))))\n```\n\n## Regular expressions\n\n```clj\n#\"regular-expression\"\n(re-find #\"^left-\" \"left-eye\")\n(clojure.string/replace \"left-eye\" #\"^left-\" \"right-\")\n```\n\n## sequence abstraction\nAs long as a data structure(like **list, vector, set, map**) responds to the core sequence operations (the functions **first, rest, and cons**, which we\u2019ll look at more closely in a moment), it will work with **map, reduce**, and oodles of other sequence functions for free. \n## convert to seq\n\n```clj\n(seq '(1 2 3))\n; => (1 2 3)\n\n(seq [1 2 3])\n; => (1 2 3)\n\n(seq #{1 2 3})\n; => (1 2 3)\n\n(seq {:name \"Bill Compton\" :occupation \"Dead mopey guy\"})\n; => ([:name \"Bill Compton\"] [:occupation \"Dead mopey guy\"])\n```\n\n## convert the seq back into a map\n```clj\n(into {} (seq {:a 1 :b 2 :c 3})); \n```\n## map function\n```clj\n(map inc [1 2 3])\n(map str [\"a\" \"b\" \"c\"] [\"A\" \"B\" \"C\"]) ; => (\"aA\" \"bB\" \"cC\")\n(map #(% 12) [inc #(+ % 2)  #(+ % 3)]) ; functions is data!\n```\n## reduce function\n```clj\n(reduce (fn [new-map [key val]]\n          (assoc new-map key (inc val)))\n        {}\n        {:max 30 :min 10})\n; => {:max 31, :min 11}\n```\n\n# take drop take-while drop-while filter\ntake: take the first n elements of the sequence\ndrop: return the sequence with the first n elements removed\ntake-while: take until the predicate function is false\ndrop-while: drop until the predicate function is false, and return remained.\nfilter: return all elements that test true for a predicate function.\nsome: return the first truthy value returned by a predicate function.\n\n```clj\n(take 3 [1 2 3 4 5 6 7 8 9 10])\n; => (1 2 3)\n\n(drop 3 [1 2 3 4 5 6 7 8 9 10])\n; => (4 5 6 7 8 9 10)\n(take-while #(< (:month %) 3) food-journal)\n(drop-while #(< (:month %) 3) food-journal)\n\n(some #(> (:critter %) 3) food-journal) ; => true\n(some #(and (> (:critter %) 3) %) food-journal); => {:month 3 :day 1 :human 4.2 :critter 3.3}\n```\n\n## sort sort-by\n\n```clj\n(sort [3 1 2])\n(sort-by count [\"aaa\" \"c\" \"bb\"])\n```\n\n## concat\nconcat simply appends the members of one sequence to the end of another\n\n```clj\n(concat [1 2] [3 4])\n```\n\n## lazy Seqs\n* A lazy seq is a seq whose members aren\u2019t computed until you try to access them. Computing a seq\u2019s members is called realizing the seq. \n* A lazy seq as consisting of two parts: a recipe for how to realize the elements of a sequence and the elements that have been realized so far. \n\n```clj\n(defn heavy-compute\n  [x]\n  (Thread/sleep 1000)\n  (inc x))\n(def result (map heavy-compute (range 1 1000)))\n(time (first result)) ; \"Elapsed time: 32004.460656 msecs\"\n```\n## infinite Sequences\n```clj\n(take 8 (repeat \"na\"))\n(take 3 (repeatedly (fn [] (rand-int 10))))\n(defn even-numbers\n  ([] (even-numbers 0))\n  ([n] (cons n (lazy-seq (even-numbers (+ n 2))))))\n(defn even-numbers\n  ([] (even-numbers 0))\n  ([n] (lazy-seq (cons n (even-numbers (+ n 2))))))\n```\n\n## Collection Abstraction\nThe sequence abstraction is about operating on members individually, whereas the collection abstraction is about the data structure as a whole. For example, the collection functions **count, empty?, and every?** aren\u2019t about any individual element; they\u2019re about the whole:\n\n### into\n* Adding all the *elements* from the second to the first.\n* As you now know, many seq functions return a seq rather than the original data structure. You\u2019ll probably want to convert the return value back into the original value, and into lets you do that:\n\n```clj\n(map identity {:sunlight-reaction \"Glitter!\"})\n; => ([:sunlight-reaction \"Glitter!\"])\n\n(into {} (map identity {:sunlight-reaction \"Glitter!\"}))\n; => {:sunlight-reaction \"Glitter!\"}\n\n(map identity [:garlic :sesame-oil :fried-eggs])\n; => (:garlic :sesame-oil :fried-eggs)\n\n(into [] (map identity [:garlic :sesame-oil :fried-eggs]))\n; => [:garlic :sesame-oil :fried-eggs]\n```\n\n###conj\n```clj\n(conj [0] [1]) ; => [0 [1]]\n(into [0] [1]) ; => [0 1]\n(conj [0] 1) ; => [0 1]\n\n(conj [0] 1 2 3 4) ; => [0 1 2 3 4]\n(conj {:time \"midnight\"} [:place \"ye olde cemetarium\"]) ; => {:place \"ye olde cemetarium\" :time \"midnight\"}\n\n(defn my-conj\n  [target & additions]\n  (into target additions)) ; define conj in terms of into\n```\n\n## apply\napply explodes a seqable data structure so it can be passed to a function that expects a rest parameter. \n\n```clj\n(max 0 1 2)\n(apply max [0 1 2])\n```\n\n## partial\npartial takes a function and any number of arguments. It then returns a new function. \n```clj\n(def add10 (partial + 10))\n(add10 3)\n\n(defn my-partial\n  [partialized-fn & args]\n  (fn [& more-args]\n    (apply partialized-fn (into args more-args))))\n```\n\n## complement\nTakes a fn f and returns a fn that takes the same arguments as f,\nhas the same effects, if any, and returns the opposite truth value.\n\n```clj\n(def not-empty? (complement empty?))\n```\n## Pure Functions\nA function is pure if it meets two qualifications:\n\n* It always returns the same result if given the same arguments. This is called referential transparency.\n* It can\u2019t cause any side effects. That is, the function can\u2019t make any changes that are observable outside the function itself\u2014for example, by changing an externally accessible mutable object or writing to a file.\n\n## comp\nComposing functions is so common that Clojure provides a function, comp, for creating a new function from the composition of any number of functions. \nusing comp on the functions f1, f2, ... fn, creates a new function g such that g(x1, x2, ... xn) equals f1( f2( fn(x1, x2, ... xn))). One detail to note here is that the first function applied\u2014* in the code shown here\u2014can take any number of arguments, **whereas the remaining functions must be able to take only one argument**.\n\n```clj\n((comp inc *) 2 3)\n\n(def character\n  {:name \"Smooches McCutes\"\n   :attributes {:intelligence 10\n                :strength 4\n                :dexterity 5}})\n(def c-int (comp :intelligence :attributes))\n```\n\n## memoize\nAnother cool thing you can do with **pure functions** is memoize them so that Clojure remembers the result of a particular function call.\n\n## exclude **var** in cljs.core\n```\n(ns hello.core\n    (:refer-clojure :exclude [map]))\n```\n"}