{"context": "\nbit_counter.c\n#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n\n///////////////////////////////////////\n// TYPE DEFINITION\n/////////////////////\ntypedef struct ST_32_BITFIELD\n{\n    unsigned char   lsb  : 1;\n    long int        rest : 30;\n    unsigned char   msb  : 1;\n}ST_32_BITFIELD;\n\ntypedef union UN_UL_VAL\n{\n    ST_32_BITFIELD st_32bitfield;\n    long int value;\n} UN_UL_VAL;\n\ntypedef enum EM_COUNT_METHOD\n{\n  EM_COUNT_METHOD_BUNKATSU_TOUCHI,\n  EM_COUNT_METHOD_BITFIELD,\n  EM_COUNT_METHOD_MAX\n} EM_COUNT_METHOD;\n\n///////////////////////////////////////\n// MACRO & DEFINITION\n/////////////////////\n#define STR_BUNKATSU_TOUCHI \"BUNKATSU_TOUCHI\"\n#define STR_BITFIELD \"BITFIELD\"\n#define STR_UNKNOWN  \"Unknown\"\n\n///////////////////////////////////////\n// Internal functions\n/////////////////////\nstatic void showUsage(void);\nstatic unsigned int count_by_bunkatsu_touchi_method(unsigned int);\nstatic unsigned int count_by_bitfield(unsigned int);\nstatic char* methodToString(EM_COUNT_METHOD);\n\nstatic void showUsage(void)\n{\n  printf(\"USAGE: ./a.out\\n\");\n  printf(\"\\t -c : input unsigned int value in decimal format. (mandatory argument).\\n\");\n  printf(\"\\t -m : select count method.\\n\");\n  printf(\"\\t         0:bunkatsu(default)    1:bitf\\n\");\n}\n\n//\u5358\u7d14\u306b\u30ab\u30a6\u30f3\u30c8\u3059\u308b\u5834\u5408\u306f\u3001\u5206\u5272\u7d71\u6cbb\u6cd5\u3060\u3068\u304b\u3001popcount\u3060\u3068\u304b\u3092\u5f37\u304f\u63a8\u5968\u3002\n//\u3053\u308c\u306f\u5206\u5272\u7d71\u6cbb\u6cd5\u3067\u306e\u4f8b\u3067\u3059\u3002\u539f\u5178\u306fPage\u4e0b\u8a18\u306b\u8a18\u8f09\u3055\u305b\u3066\u9802\u3044\u3066\u304a\u308a\u307e\u3059\u3002\nstatic unsigned int count_by_bunkatsu_touchi_method(unsigned int x)\n{\n    unsigned int _x = x;\n    _x = _x - ((_x >> 1) & 0x55555555);\n    _x = (_x & 0x33333333) + ((_x >> 2) & 0x33333333);\n    _x = (_x + (_x >> 4)) & 0x0f0f0f0f;\n    _x = _x + (_x >> 8);\n    _x = _x + (_x >> 16);\n    _x = _x & 0x0000003F;\n\n     return _x;\n}\n\n//\u30a2\u30d7\u30ea\u306e\u7279\u6027\u4e0a\u3001\u30ab\u30a6\u30f3\u30c8\u3064\u3044\u3067\u306b\n//\u3054\u3061\u3087\u3054\u3061\u3087\u3059\u308b\u5fc5\u8981\u304c\u3042\u308b\u306a\u3089\u3001\u3053\u3046\u3044\u3046\u3084\u308a\u65b9\u3082\u3042\u308b\u3002\n//\u305f\u3060\u3057\u3001\u3053\u306e\u30b3\u30fc\u30c9\u306f\u30ab\u30a6\u30f3\u30c8\u3059\u308b\u3053\u3068\u3057\u304b\u66f8\u3044\u3066\u306a\u3044\u3067\u3059\u30e8\u3002\nstatic unsigned int count_by_bitfield(unsigned int x)\n{\n    UN_UL_VAL un_val = {0};\n    un_val.value = x;\n    long int count = 0;\n\n    for(int i = 0; i < 32; i++, un_val.value >>= 1)\n    {\n      //        printf(\"lsb:%d value=%ld \\n\",un_val.st_32bitfield.lsb, un_val.value);\n\n        if(1 == un_val.st_32bitfield.lsb)\n        {\n        count++;\n        }\n   }\n\n    return count;\n}\n\nstatic char* methodToString(EM_COUNT_METHOD _em_method)\n{\n  char* result = NULL;\n\n    switch(_em_method)\n    {\n        case(EM_COUNT_METHOD_BUNKATSU_TOUCHI):\n    {\n      result = STR_BUNKATSU_TOUCHI;\n      break;\n    }\n    case(EM_COUNT_METHOD_BITFIELD):\n    {\n      result = STR_BITFIELD;\n      break;\n    }\n        default:\n    {\n        result = STR_UNKNOWN;\n    }\n    }\n    return result;\n}\n\nint main(int argc,char *argv[]) {\n\n    long int target = 0;\n    EM_COUNT_METHOD em_method = EM_COUNT_METHOD_BUNKATSU_TOUCHI;//default\n    int initCompFlag = 0;\n    unsigned int countResult = 0;\n\n    if((argc < 2) || (0 == argc%2))\n    {\n      showUsage();\n      exit(0);\n    }\n    else\n    {\n        for (int i=1; i < argc; i++)\n    {\n        if(0 == strncmp(argv[i], \"-c\", 4))\n        {\n            target = strtol(argv[++i], NULL, 10);\n        initCompFlag = 1;\n        }\n        else if(0 == strncmp(argv[i], \"-m\", 4))\n        {\n            em_method = strtol(argv[++i], NULL, 10);\n        }\n        else\n        {\n            showUsage();\n            exit(0);\n        }\n    }\n\n    //confirm initialization status.\n    if(1 == initCompFlag)\n    {\n        printf(\"evaluation target value is = %ld\\n\", target);\n            printf(\"count method is = %s.\\n\", methodToString(em_method));\n        if((EM_COUNT_METHOD_BUNKATSU_TOUCHI != em_method) &&\n           (EM_COUNT_METHOD_BITFIELD != em_method))\n        {\n            printf(\"method:%d is invalid.\\n\", em_method);      \n            showUsage();\n            exit(0);                \n        }\n    }\n    else //including : 0 == init_comp_flag\n    {\n        showUsage();\n        exit(0);\n    }\n\n    }\n\n    switch(em_method)\n    {\n        case(EM_COUNT_METHOD_BUNKATSU_TOUCHI):\n    {\n        countResult = count_by_bunkatsu_touchi_method(target);\n        break;\n    }\n    case(EM_COUNT_METHOD_BITFIELD):\n    {\n            countResult = count_by_bitfield(target);\n         break;\n    }\n        default:\n    {\n        printf(\"method:%d is invalid.\\n\", em_method);      \n        showUsage();\n        exit(0);\n    }\n    }\n\n    printf(\"# of true bit is %u\\n\",countResult);\n\n    return EXIT_SUCCESS;\n}\n\n\n\u3053\u3093\u306a\u611f\u3058\u3067\u3069\u3046\u3067\u3057\u3087\u3046\u3002\u3002\u3002\n\u6ce8\u610f\u3068\u3057\u3066\u3001bitfield\u69cb\u9020\u4f53\u3092\u5b9a\u7fa9\u3059\u308b\u3068\u304d\u306b\u30011bit\u306e\u90e8\u5206(\u672c\u4f8b\u3060\u3068\u3001msb, lsb)\u3092\u7b26\u53f7\u6709\u308a\u578b\u3067\u5b9a\u7fa9\u3059\u308b\u3068\u3001\n\u8a55\u4fa1\u3059\u308b\u3068\u304d\u306b\u30de\u30a4\u30ca\u30b9\u306e\u5024\u306b\u306a\u3063\u3066\u3057\u307e\u3046\u306e\u3067\u3001count\u304c\u5897\u3048\u306a\u3044\u30d7\u30ed\u30b0\u30e9\u30e0\u306b\u306a\u308a\u307e\u3059\u3002\nOct/18/2016:\n\u203b\u3054\u6307\u6458\u304c\u3042\u308a\u307e\u3057\u305f\u306e\u3067\u3001\u5206\u5272\u7d71\u6cbb\u6cd5\u3067\u306e\u30ab\u30a6\u30f3\u30c8\u65b9\u6cd5\u30b5\u30f3\u30d7\u30eb\u30b3\u30fc\u30c9\u3068\u3001\u3054\u3061\u3083\u3054\u3061\u3083\u8a00\u3044\u8a33\u30b3\u30e1\u30f3\u30c8\u3082\u3064\u3051\u3066\u307f\u307e\u3057\u305f\u3002\n\u5206\u5272\u7d71\u6cbb\u6cd5\u306e\u30b3\u30fc\u30c9\u3092\u3054\u7d39\u4ecb\u3057\u3066\u304f\u3060\u3055\u3063\u3066\u3044\u308bURL\uff1ahttps://www.kaeruspoon.net/articles/720\n```cpp:bit_counter.c\n#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n\n///////////////////////////////////////\n// TYPE DEFINITION\n/////////////////////\ntypedef struct ST_32_BITFIELD\n{\n    unsigned char   lsb  : 1;\n    long int        rest : 30;\n    unsigned char   msb  : 1;\n}ST_32_BITFIELD;\n\ntypedef union UN_UL_VAL\n{\n    ST_32_BITFIELD st_32bitfield;\n    long int value;\n} UN_UL_VAL;\n\ntypedef enum EM_COUNT_METHOD\n{\n  EM_COUNT_METHOD_BUNKATSU_TOUCHI,\n  EM_COUNT_METHOD_BITFIELD,\n  EM_COUNT_METHOD_MAX\n} EM_COUNT_METHOD;\n\n///////////////////////////////////////\n// MACRO & DEFINITION\n/////////////////////\n#define STR_BUNKATSU_TOUCHI \"BUNKATSU_TOUCHI\"\n#define STR_BITFIELD \"BITFIELD\"\n#define STR_UNKNOWN  \"Unknown\"\n\n///////////////////////////////////////\n// Internal functions\n/////////////////////\nstatic void showUsage(void);\nstatic unsigned int count_by_bunkatsu_touchi_method(unsigned int);\nstatic unsigned int count_by_bitfield(unsigned int);\nstatic char* methodToString(EM_COUNT_METHOD);\n\nstatic void showUsage(void)\n{\n  printf(\"USAGE: ./a.out\\n\");\n  printf(\"\\t -c : input unsigned int value in decimal format. (mandatory argument).\\n\");\n  printf(\"\\t -m : select count method.\\n\");\n  printf(\"\\t         0:bunkatsu(default)    1:bitf\\n\");\n}\n\n//\u5358\u7d14\u306b\u30ab\u30a6\u30f3\u30c8\u3059\u308b\u5834\u5408\u306f\u3001\u5206\u5272\u7d71\u6cbb\u6cd5\u3060\u3068\u304b\u3001popcount\u3060\u3068\u304b\u3092\u5f37\u304f\u63a8\u5968\u3002\n//\u3053\u308c\u306f\u5206\u5272\u7d71\u6cbb\u6cd5\u3067\u306e\u4f8b\u3067\u3059\u3002\u539f\u5178\u306fPage\u4e0b\u8a18\u306b\u8a18\u8f09\u3055\u305b\u3066\u9802\u3044\u3066\u304a\u308a\u307e\u3059\u3002\nstatic unsigned int count_by_bunkatsu_touchi_method(unsigned int x)\n{\n    unsigned int _x = x;\n    _x = _x - ((_x >> 1) & 0x55555555);\n    _x = (_x & 0x33333333) + ((_x >> 2) & 0x33333333);\n    _x = (_x + (_x >> 4)) & 0x0f0f0f0f;\n    _x = _x + (_x >> 8);\n    _x = _x + (_x >> 16);\n    _x = _x & 0x0000003F;\n\n     return _x;\n}\n\n//\u30a2\u30d7\u30ea\u306e\u7279\u6027\u4e0a\u3001\u30ab\u30a6\u30f3\u30c8\u3064\u3044\u3067\u306b\n//\u3054\u3061\u3087\u3054\u3061\u3087\u3059\u308b\u5fc5\u8981\u304c\u3042\u308b\u306a\u3089\u3001\u3053\u3046\u3044\u3046\u3084\u308a\u65b9\u3082\u3042\u308b\u3002\n//\u305f\u3060\u3057\u3001\u3053\u306e\u30b3\u30fc\u30c9\u306f\u30ab\u30a6\u30f3\u30c8\u3059\u308b\u3053\u3068\u3057\u304b\u66f8\u3044\u3066\u306a\u3044\u3067\u3059\u30e8\u3002\nstatic unsigned int count_by_bitfield(unsigned int x)\n{\n    UN_UL_VAL un_val = {0};\n    un_val.value = x;\n    long int count = 0;\n\n    for(int i = 0; i < 32; i++, un_val.value >>= 1)\n    {\n      //        printf(\"lsb:%d value=%ld \\n\",un_val.st_32bitfield.lsb, un_val.value);\n\n        if(1 == un_val.st_32bitfield.lsb)\n        {\n\t    count++;\n        }\n   }\n\n    return count;\n}\n\nstatic char* methodToString(EM_COUNT_METHOD _em_method)\n{\n  char* result = NULL;\n  \n    switch(_em_method)\n    {\n        case(EM_COUNT_METHOD_BUNKATSU_TOUCHI):\n\t{\n\t  result = STR_BUNKATSU_TOUCHI;\n\t  break;\n\t}\n\tcase(EM_COUNT_METHOD_BITFIELD):\n\t{\n\t  result = STR_BITFIELD;\n\t  break;\n\t}\n        default:\n\t{\n\t    result = STR_UNKNOWN;\n\t}\n    }\n    return result;\n}\n\nint main(int argc,char *argv[]) {\n\n    long int target = 0;\n    EM_COUNT_METHOD em_method = EM_COUNT_METHOD_BUNKATSU_TOUCHI;//default\n    int initCompFlag = 0;\n    unsigned int countResult = 0;\n\n    if((argc < 2) || (0 == argc%2))\n    {\n      showUsage();\n      exit(0);\n    }\n    else\n    {\n        for (int i=1; i < argc; i++)\n  \t{\n  \t    if(0 == strncmp(argv[i], \"-c\", 4))\n\t    {\n\t        target = strtol(argv[++i], NULL, 10);\n\t\tinitCompFlag = 1;\n\t    }\n\t    else if(0 == strncmp(argv[i], \"-m\", 4))\n\t    {\n\t        em_method = strtol(argv[++i], NULL, 10);\n\t    }\n\t    else\n\t    {\n\t        showUsage();\n\t        exit(0);\n\t    }\n\t}\n\n\t//confirm initialization status.\n\tif(1 == initCompFlag)\n\t{\n\t    printf(\"evaluation target value is = %ld\\n\", target);\n            printf(\"count method is = %s.\\n\", methodToString(em_method));\n\t    if((EM_COUNT_METHOD_BUNKATSU_TOUCHI != em_method) &&\n\t       (EM_COUNT_METHOD_BITFIELD != em_method))\n\t    {\n        \tprintf(\"method:%d is invalid.\\n\", em_method);      \n\t        showUsage();\n\t        exit(0);\t        \t\n\t    }\n\t}\n\telse //including : 0 == init_comp_flag\n\t{\n\t    showUsage();\n\t    exit(0);\n\t}\n\t    \n    }\n\n    switch(em_method)\n    {\n        case(EM_COUNT_METHOD_BUNKATSU_TOUCHI):\n\t{\n\t    countResult = count_by_bunkatsu_touchi_method(target);\n\t    break;\n\t}\n\tcase(EM_COUNT_METHOD_BITFIELD):\n\t{\n      \t    countResult = count_by_bitfield(target);\n\t     break;\n\t}\n        default:\n\t{\n\t    printf(\"method:%d is invalid.\\n\", em_method);      \n\t    showUsage();\n\t    exit(0);\n\t}\n    }\n\n    printf(\"# of true bit is %u\\n\",countResult);\n    \n    return EXIT_SUCCESS;\n}\n```\n\n\u3053\u3093\u306a\u611f\u3058\u3067\u3069\u3046\u3067\u3057\u3087\u3046\u3002\u3002\u3002\n\u6ce8\u610f\u3068\u3057\u3066\u3001bitfield\u69cb\u9020\u4f53\u3092\u5b9a\u7fa9\u3059\u308b\u3068\u304d\u306b\u30011bit\u306e\u90e8\u5206(\u672c\u4f8b\u3060\u3068\u3001msb, lsb)\u3092\u7b26\u53f7\u6709\u308a\u578b\u3067\u5b9a\u7fa9\u3059\u308b\u3068\u3001\n\u8a55\u4fa1\u3059\u308b\u3068\u304d\u306b\u30de\u30a4\u30ca\u30b9\u306e\u5024\u306b\u306a\u3063\u3066\u3057\u307e\u3046\u306e\u3067\u3001count\u304c\u5897\u3048\u306a\u3044\u30d7\u30ed\u30b0\u30e9\u30e0\u306b\u306a\u308a\u307e\u3059\u3002\n\nOct/18/2016:\n\u203b\u3054\u6307\u6458\u304c\u3042\u308a\u307e\u3057\u305f\u306e\u3067\u3001\u5206\u5272\u7d71\u6cbb\u6cd5\u3067\u306e\u30ab\u30a6\u30f3\u30c8\u65b9\u6cd5\u30b5\u30f3\u30d7\u30eb\u30b3\u30fc\u30c9\u3068\u3001\u3054\u3061\u3083\u3054\u3061\u3083\u8a00\u3044\u8a33\u30b3\u30e1\u30f3\u30c8\u3082\u3064\u3051\u3066\u307f\u307e\u3057\u305f\u3002\n\u5206\u5272\u7d71\u6cbb\u6cd5\u306e\u30b3\u30fc\u30c9\u3092\u3054\u7d39\u4ecb\u3057\u3066\u304f\u3060\u3055\u3063\u3066\u3044\u308bURL\uff1ahttps://www.kaeruspoon.net/articles/720\n", "tags": ["bitfield", "C\u8a00\u8a9e", "C++"]}