{"context": " More than 1 year has passed since last update.\n\n\u306f\u3058\u3081\u306b\nProlog \u5074\u304b\u3089 Ruby \u306e\u30e1\u30bd\u30c3\u30c9\u3092\u547c\u3073\u51fa\u3059\u3001\u3068\u3044\u3046\u306e\u3092\u3084\u3063\u3066\u307f\u307e\u3057\u305f\u3002\n\u52d5\u4f5c\u74b0\u5883\n\nUbuntu Linux 14.04\nRuby 2.1.5 p273\nSWI-Prolog version 6.6.4 for amd64\n\u30b9\u30af\u30ea\u30d7\u30c8\u985e\n\n\nruby-client.pro  (Prolog \u30d7\u30ed\u30b0\u30e9\u30e0) \u203b\u30af\u30e9\u30a4\u30a2\u30f3\u30c8 (\u672c\u7a3f\u672b\u5c3e\u306b\u63b2\u8f09)\nserver.pro (Prolog \u30d7\u30ed\u30b0\u30e9\u30e0)       \u203bProlog \u30b5\u30fc\u30d0\nprolog_server.rb (Ruby\u30b9\u30af\u30ea\u30d7\u30c8)    \u203b\u30b5\u30fc\u30d0 (\u672c\u7a3f\u672b\u5c3e\u306b\u63b2\u8f09)\nprolog_parser.rb (Ruby\u30b9\u30af\u30ea\u30d7\u30c8)    \u203b\u30df\u30cb Prolog \u30d1\u30fc\u30b5\nprolog_proxy.rb (Ruby\u30b9\u30af\u30ea\u30d7\u30c8)     \u203bProlog \u30b5\u30fc\u30d0\u3068\u901a\u4fe1\u7528\n\n\n\nruby_client.pro\u3001prolog_server.rb \u4ee5\u5916\u306f\u3001\u4ee5\u4e0b\u306e\u8a18\u4e8b\u306e\u6d41\u7528\u3067\u3059\u3002\n\u8a73\u7d30\u306f\u305d\u3061\u3089\u3092\u3054\u89a7\u304f\u3060\u3055\u3044\u3002\n\n\nRuby: Prolog\u3067\u7ffb\u8a33\u300c\u6642\u306e\u877f\u306f\u3072\u3068\u3064\u306e\u77e2\u3092\u597d\u3080\u300d \n\n\n\u30c7\u30e2 (\u305d\u306e1)\n\n\u4e0a\u306e\u56f3\u306e\u3088\u3046\u306b Ruby \u30b5\u30fc\u30d0\u306b Prolog \u304b\u3089 TCP \u3067\u30e1\u30c3\u30bb\u30fc\u30b8\u3092\u9001\u4fe1\u3057\u307e\u3059\u3002\nRuby \u30b5\u30fc\u30d0\u306b\u306f\u30c7\u30e2\u7528\u306e\u30ec\u30b7\u30fc\u30d0\u30aa\u30d6\u30b8\u30a7\u30af\u30c8(dummy_receiver)\u304c\u4ed5\u8fbc\u307e\u308c\u3066\u3044\u307e\u3059\u3002\ndummy_receiver \u306f\u5f15\u6570\u3092 puts \u3059\u308b\u3060\u3051\u306e\u30e1\u30bd\u30c3\u30c9 foo,bar,baz \u3092\u6301\u3063\u3066\u3044\u307e\u3059\u3002\n\u3067\u306f\u3001Ruby \u30b5\u30fc\u30d0\u3092\u958b\u59cb\u3055\u305b\u307e\u3059\u3002\n$ ruby prolog_server.rb    # \u30c7\u30d5\u30a9\u30eb\u30c8\u3067\u30dd\u30fc\u30c8 53340/tcp \u3092 LISTEN\n                           # \u8d77\u52d5\u3057\u305f\u307e\u307e\u306b\u306a\u308b\u3002\u505c\u6b62\u3059\u308b\u306b\u306f Ctrl-C\n                           # --log \u30ed\u30b0\u30d5\u30a1\u30a4\u30eb\u540d \u3092\u4ed8\u3051\u3066\u8d77\u52d5\u3059\u308b\u3068\u30ed\u30b0\u51fa\u529b\u3057\u307e\u3059\n\n\u30af\u30e9\u30a4\u30a2\u30f3\u30c8\u30d7\u30ed\u30b0\u30e9\u30e0\u3092\u8aad\u307f\u8fbc\u3093\u3067 SWI-Prolog \u3092\u8d77\u52d5\u3057\u307e\u3059\u3002\n$ swipl -l ruby_client.pro\n      :\n  (Prolog \u304c\u8d77\u52d5\u3059\u308b)\n\nRuby \u30b5\u30fc\u30d0\u306e\u30e1\u30bd\u30c3\u30c9\u3092\u547c\u3073\u51fa\u3059\u306b\u306f\u3001\u4ee5\u4e0b\u306e\u8ff0\u8a9e\u3092\u4f7f\u3044\u307e\u3059\u3002(\u4f7f\u308f\u306a\u304f\u3066\u3082\u3067\u304d\u307e\u3059\u304c)\n  ruby(Pred)               % ruby/1 : Host = 'localhost', Port = 53340\n  ruby(Pred, Port)         % ruby/2 : Host = 'localhost'\n  ruby(Pred, Port, Host)   % ruby/3\n\nSWI-Prolog \u306e\u30d7\u30ed\u30f3\u30d7\u30c8\u304b\u3089\u3001\u3084\u3063\u3066\u307f\u307e\u3059\u3002\n?- ruby(foo).                 % \u30a2\u30c8\u30e0\u306e\u5834\u5408\u3001\u5f15\u6570\u306a\u3057\u3067\u30e1\u30bd\u30c3\u30c9\u3092\u547c\u3073\u51fa\u3059\ntrue.\n\n?- ruby(bar(a,b,c)).          % \u8ff0\u8a9e\u306e\u5834\u5408\u3001\u8ff0\u8a9e\u306e\u5f15\u6570\u3092\u6e21\u3057\u3066\u30e1\u30bd\u30c3\u30c9\u3092\u547c\u3073\u51fa\u3059\ntrue.\n\n?- ruby(baz(a,f(x,y),[1,2,3],\"ABC\")).\ntrue.\n\n?- ruby(1).                   % 1 \u306f\u30a2\u30c8\u30e0/\u8ff0\u8a9e\u4ee5\u5916\u306a\u306e\u3067\u7121\u8996\u3055\u308c\u308b\ntrue.\n\n\u4e0a\u3092\u5b9f\u884c\u306b\u3088\u308a\u3001Ruby \u30b5\u30fc\u30d0\u5074\u3067\u4ee5\u4e0b\u306e\u3088\u3046\u306b\u8868\u793a\u3055\u308c\u307e\u3059\u3002\n$ ruby prolog_server.rb\ncall method: foo(), args = 0\ncall method: bar(a,b,c), args = 3\ncall method: baz(a,{:f=>[:x, :y]},1,2,3,65,66,67), args = 4   # puts \u306a\u306e\u3067\u3053\u3046\u898b\u3048\u307e\u3059\u304c\u3001\u5f15\u6570\u306f 4 \u500b\u3067\u3059\u3002\n\n\u30e1\u30c3\u30bb\u30fc\u30b8\u306b\u5bfe\u5fdc\u3059\u308b\u30e1\u30bd\u30c3\u30c9\u304c\u547c\u3073\u51fa\u3055\u308c\u307e\u3059\u3002\n\u5f15\u6570\u306f\u3001\u30df\u30cb Prolog \u30d1\u30fc\u30b5\u306e\u89e3\u91c8(Ruby\u8868\u73fe)\u3067\u6e21\u3055\u308c\u307e\u3059\u3002\nruby(1) \u306e\u3088\u3046\u306b\u3001\u30a2\u30c8\u30e0/\u8ff0\u8a9e\u4ee5\u5916\u306e\u3082\u306e\u306f\u7121\u8996\u3055\u308c\u307e\u3059\u3002\n\n\n\u30c7\u30e2 (\u305d\u306e2: Prolog \u3082\u30b5\u30fc\u30d0\u306b\u3059\u308b)\n\n\nRuby: Prolog\u3067\u7ffb\u8a33\u300c\u6642\u306e\u877f\u306f\u3072\u3068\u3064\u306e\u77e2\u3092\u597d\u3080\u300d \n\n\u4e0a\u306e\u8a18\u4e8b\u3067\u3057\u305f\u3088\u3046\u306b Prolog \u3082\u30b5\u30fc\u30d0\u306b\u3057\u3066\u307f\u308b\u3053\u3068\u3082\u3067\u304d\u307e\u3059\u3002\n\nRuby \u30b5\u30fc\u30d0\u306e\u8d77\u52d5\u306f\u30c7\u30e2(\u305d\u306e1)\u3068\u540c\u3058\u3067\u3059\u3002\n$ ruby prolog_server.rb    # \u30c7\u30d5\u30a9\u30eb\u30c8\u3067\u30dd\u30fc\u30c8 53340/tcp \u3092 LISTEN\n                           # \u8d77\u52d5\u3057\u305f\u307e\u307e\u306b\u306a\u308b\u3002\u505c\u6b62\u3059\u308b\u306b\u306f Ctrl-C\n\n\u7d9a\u3044\u3066 Prolog \u30b5\u30fc\u30d0\u3092\u8d77\u52d5\u3057\u307e\u3059\u3002\n$ swipl -l server.pro -g 'create_sserver(53330).'  # \u8d77\u52d5\u3057\u305f\u307e\u307e\u306b\u306a\u308b\n\nProlog \u30b5\u30fc\u30d0\u3078\u306e\u901a\u4fe1\u306f Prolog::Proxy \u3067\u884c\u3044\u307e\u3059\u3002\npry \u3092\u4f7f\u3044\u307e\u3059\u3002ruby-client.pro \u304c\u3042\u308b\u30c7\u30a3\u30ec\u30af\u30c8\u30ea\u3067 pry \u3092\u8d77\u52d5\u3057\u307e\u3059\u3002\n$ pry -r prolog_proxy        # prolog_proxy.rb \u3092 require \u3057\u307e\u3059\u3002\n    :\n\nload \u30e1\u30bd\u30c3\u30c9\u3067 Prolog \u30b5\u30fc\u30d0\u306b ruby-client.pro \u306e\u5185\u5bb9\u3092\u6d41\u3057\u8fbc\u307f\u307e\u3059\u3002\n\u305d\u306e\u5f8c\u3067 Prolog \u30b5\u30fc\u30d0\u306b ruby/1 \u3092\u554f\u3044\u5408\u308f\u305b\u307e\u3059\u3002\n[1] pry(main)> cd Prolog::Proxy\n[2] pry(Prolog::Proxy):1> load ['ruby-client.pro']\n=> [\"./ruby-client.pro\"]\n[3] pry(Prolog::Proxy):1> q 'ruby(foo(a,b))'\n=> \"[ruby(foo(a,b))]\"\n\nRuby \u30b5\u30fc\u30d0\u3067 dummy_receiver \u306e foo \u304c\u547c\u3073\u51fa\u3055\u308c\u3001\u4ee5\u4e0b\u306e\u3088\u3046\u306b\u8868\u793a\u3055\u308c\u307e\u3059\u3002\n(Ruby \u30b5\u30fc\u30d0\u304c\u8d77\u52d5\u3057\u3066\u3044\u308b\u30bf\u30fc\u30df\u30ca\u30eb)\ncall method: foo(a,b), args = 2\n\n\n\u30c7\u30e2 (\u305d\u306e3: Proxy \u3092 drb \u30c7\u30fc\u30e2\u30f3\u306b\u3059\u308b)\n\n\nRuby: Prolog\u3067\u7ffb\u8a33\u300c\u6642\u306e\u877f\u306f\u3072\u3068\u3064\u306e\u77e2\u3092\u597d\u3080\u300d \n\n\u4e0a\u306e\u8a18\u4e8b\u3067\u3057\u305f\u3088\u3046\u306b Proxy \u3092 drb \u30c7\u30fc\u30e2\u30f3\u3057\u3066\u307f\u307e\u3059\u3002\n\u30ea\u30e2\u30fc\u30c8\u306e Ruby \u304b\u3089 drb \u3067 Proxy \u306b\u30a2\u30af\u30bb\u30b9\u3057\u3066 Prolog \u30b5\u30fc\u30d0\u3092\u64cd\u4f5c\u3067\u304d\u307e\u3059\u3002\n\n\u57fa\u672c\u7684\u306b\u4e0a\u306e\u8a18\u4e8b\u3068\u540c\u3058\u3053\u3068\u3092\u3057\u3066\u3044\u308b\u306e\u3067\u624b\u9806\u306e\u307f\u63b2\u8f09\u3057\u307e\u3059\u3002\n: \u30bf\u30fc\u30df\u30ca\u30eb#1 : Ruby \u30b5\u30fc\u30d0\u8d77\u52d5\n$ ruby prolog_server.rb\n                                # \u8d77\u52d5\u3057\u305f\u307e\u307e\u306b\u306a\u308b\n\n: \u30bf\u30fc\u30df\u30ca\u30eb#2 : Prolog \u30b5\u30fc\u30d0\u8d77\u52d5\n$ swipl -l server.pro -g 'create_server(53330).'\n                                # \u8d77\u52d5\u3057\u305f\u307e\u307e\u306b\u306a\u308b\n\n: \u30bf\u30fc\u30df\u30ca\u30eb#3 : Prolog \u30b5\u30fc\u30d0\u306b ruby_client \u3092\u30ed\u30fc\u30c9\n$ ruby -r prolog_proxy -e 'Prolog::Proxy.load [\"ruby-client.pro\"]'\n\n: \u30bf\u30fc\u30df\u30ca\u30eb#4 : Proxy \u30c7\u30fc\u30e2\u30f3(drb\u30b5\u30fc\u30d3\u30b9)\u8d77\u52d5\n$ ruby prolog_proxy.rb --drb --daemon  # \u30d0\u30c3\u30af\u30b0\u30e9\u30f3\u30c9\u3067\u8d77\u52d5\n\n: \u30bf\u30fc\u30df\u30ca\u30eb#5 (\u30ea\u30e2\u30fc\u30c8) : pry \u3067\u64cd\u4f5c\n$ pry -r drb             # drb \u3092 require\n    :\n[1] pry(main)> px = DRbObject.new_with_uri 'druby://:53331'\n=> ...\n[2] pry(main)> px.q 'ruby(foo(x))'\n=> \"[ruby(foo(x))]\"\n\n\u4e0a\u306e\u64cd\u4f5c\u306b\u3088\u308a\u3001\u30bf\u30fc\u30df\u30ca\u30eb#1 \u3067 Ruby \u30b5\u30fc\u30d0\u306e\u51e6\u7406\u7d50\u679c\u304c\u51fa\u529b\u3055\u308c\u307e\u3059\u3002\n    :\ncall method: foo(x), args = 1\n\n\n\u30b5\u30fc\u30d0\u3078\u306e\u30ec\u30b7\u30fc\u30d0\u306e\u8a2d\u5b9a\u306e\u4ed5\u65b9\n\u30b5\u30fc\u30d0\u306b\u306f\u3001\u4efb\u610f\u306e\u30ec\u30b7\u30fc\u30d0\u30aa\u30d6\u30b8\u30a7\u30af\u30c8\u3092\u8a2d\u5b9a\u3067\u304d\u307e\u3059\u3002\nrequire 'prolog_server'\n\nclass MyClass       # \u30ec\u30b7\u30fc\u30d0\u306b\u3059\u308b\u30aa\u30d6\u30b8\u30a7\u30af\u30c8\u306e\u30af\u30e9\u30b9\u5b9a\u7fa9\n  # \u9069\u5f53\u306b\u30e1\u30bd\u30c3\u30c9\u5b9a\u7fa9\u3059\u308b\n  # def hoge(...) ... \u3068\u3059\u308b\u3068 Prolog\u5074\u304b\u3089 `?- ruby(hoge(...)).` \u3067\u547c\u3073\u51fa\u305b\u308b\nend\nmy_receiver = MyClass.new\n\n\u4e0a\u306e\u3088\u3046\u306b\u4f5c\u3063\u305f\u30ec\u30b7\u30fc\u30d0(my_receiver) \u3092\u4ee5\u4e0b\u306e\u3044\u305a\u308c\u304b\u306e\u65b9\u6cd5\u3067\u6307\u5b9a\u3057\u307e\u3059\u3002\nth = Prolog::Server.start(my_receiver)\nth.join            # \u623b\u308a\u5024\u306f\u30b5\u30fc\u30d0\u306e Thread \u30aa\u30d6\u30b8\u30a7\u30af\u30c8\u306a\u306e\u3067 join \u3067\u304d\u308b\n\nProlog::Server.daemon(my_receiver)  # \u3053\u306e\u5834\u5408\u3001\u30c7\u30fc\u30e2\u30f3\u306b\u306a\u308b\n\nserver = Prolog::Server.new         # \u30a4\u30f3\u30b9\u30bf\u30f3\u30b9\u3092\u4f5c\u3063\u3066\u6307\u5b9a\u3059\u308b\u65b9\u6cd5\nth = server.start(my_receiver)\nth.join\n\nserver = Prolog::Server.new\nserver.daemon(my_receiver)          # \u3053\u306e\u5834\u5408\u3001\u30c7\u30fc\u30e2\u30f3\u306b\u306a\u308b\n\n\u30ec\u30b7\u30fc\u30d0\u306e\u30e1\u30bd\u30c3\u30c9\u547c\u3073\u51fa\u3057\u6642\u306e\u4f8b\u5916\u3092\u30cf\u30f3\u30c9\u30eb\u3059\u308b\u5834\u5408\u306f\u3001\u4ee5\u4e0b\u306e\u3088\u3046\u306b\u3057\u307e\u3059\u3002\nserver = Prolog::Server.new             \n       # on_error \u3067\u30cf\u30f3\u30c9\u30e9\u3092\u6307\u5b9a\u3059\u308b\u3002\u5f15\u6570\u306f\u30ad\u30e3\u30d7\u30c1\u30e3\u3059\u308b\u4f8b\u5916\u30bf\u30a4\u30d7\nserver.on_error(NoMethodError) {|e| puts \"Exception: #{e.class}\" }\nth = server.start(my_receiver)\nth.join\n\n\n\u30d0\u30a4\u30c8\u914d\u5217\u3068\u6587\u5b57\u5217\u306e\u5909\u63db\nSWI-Prolog \u306f\u5f15\u6570\u306e\u6587\u5b57\u5217\u3092\u9001\u4fe1\u3059\u308b\u6642\u306b\u3001\u6574\u6570(\u30d0\u30a4\u30c8\u5024)\u306e\u30ea\u30b9\u30c8\u3068\u3057\u3066\u9001\u308b\u3088\u3046\u3067\u3059\u3002\n[63] pry(Prolog::Proxy):1> q 'ruby(foo(\"ABC\"))'\n=> \"[ruby(foo([65,66,67]))]\"\n\nRuby \u30b5\u30fc\u30d0\u306e\u30df\u30cb Prolog \u30d1\u30fc\u30b5\u306f\u3001\u6587\u5b57\u5217\u306f String \u306b\u3001\u30ea\u30b9\u30c8\u306f Array \u306b\u5909\u63db\u3059\u308b\u306e\u3067\u3001\u30ec\u30b7\u30fc\u30d0\u306e\u5f15\u6570\u306b\u306f\u6574\u6570(\u30d0\u30a4\u30c8\u5024)\u306e Array \u3068\u3057\u3066\u6e21\u3055\u308c\u307e\u3059\u3002\n\u30d0\u30a4\u30c8\u914d\u5217\u3068\u6587\u5b57\u5217\u306e\u5909\u63db\u304c\u5fc5\u8981\u306a\u5834\u5408\u306f\u3001\u30ec\u30b7\u30fc\u30d0\u3067\u884c\u3044\u307e\u3059\u3002\n# \u5909\u63db\u306e\u4f8b\np [65,66,67].pack \"C*\"       #=> \"ABC\"\np \"ABC\".unpack \"C*\"          #=> [65, 66, 67]\n\n# \u30d0\u30a4\u30c8\u306e\u914d\u5217\u304b\u5224\u5b9a\u3059\u308b\u4f8b\narg = [65,66,67]\n\np arg.kind_of?(Array) && arg.all? {|n| (0..255).include? n }    #=> true\n\n\u3061\u306a\u307f\u306b\u3001\u62d9\u7a3f\u300cRuby: method_missing \u3092\u4f7f\u3063\u3066\u307f\u305f\u300d\u306e KindOfTest \u3092\u4f7f\u3046\u3068\u5224\u5b9a\u306f\u4ee5\u4e0b\u306e\u3088\u3046\u306b\u3067\u304d\u307e\u3059\u3002\nrequire 'kind_of_test'\nclass Object ; include KindOfTest ; end\n\np [65,66,67].array? &:byte?          #=> true\np [65,66,67,256].array? &:byte?      #=> false\n\n\n\u30b9\u30af\u30ea\u30d7\u30c8\n\u30af\u30e9\u30a4\u30a2\u30f3\u30c8 (Prolog \u30d7\u30ed\u30b0\u30e9\u30e0)\n\nruby_client.pro\nruby(Req) :- ruby(Req, 53340).\nruby(Req, Port) :- ruby(Req, 'localhost', Port).\nruby(Req, Host, Port) :- create_client(Req, Host, Port).\n\ncreate_client(Req, Host, Port) :-\n    setup_call_catcher_cleanup(tcp_socket(Socket),\n                               tcp_connect(Socket, Host:Port),\n                               exception(_),\n                               tcp_close_socket(Socket)),\n    setup_call_cleanup(tcp_open_socket(Socket, In, Out),\n                       request_to_server(Req, In, Out),\n                       close_client_connection(In, Out)).\n\nclose_client_connection(In, Out) :-\n    close(In, [force(true)]),\n    close(Out, [force(true)]).\n\nrequest_to_server(Req, _, Out) :-\n    write(Out, Req).\n\n\n\u30b5\u30fc\u30d0 (Ruby \u30b9\u30af\u30ea\u30d7\u30c8)\n\nprolog_server.rb\nrequire 'socket'\nrequire 'resolv-replace'\nrequire 'logger'\nrequire 'prolog_parser'\n\nmodule Prolog\n  class Server\n    HOST, PORT = '0.0.0.0', 53340\n\n    def self.daemon(*args, &block)\n      new(*args, &block).daemon\n    end\n\n    def self.start(*args, &block)\n      new(*args, &block).start\n    end\n\n    class ServerLogger < Logger\n      def level=(x)\n        x = Logger.const_get(x) if %i(DEBUG INFO WARN ERROR FATAL).include?(x)\n        super(x)\n      end\n    end\n\n    attr_accessor :log\n    attr_writer :logger\n    def logger; @logger ||= (log ? ServerLogger.new(log) : null) ; end\n\n    attr_accessor :host, :port, :receiver\n\n    def initialize(receiver=nil, port:nil,host:nil, logger:nil,log:nil, &block)\n      tap {|my| my.receiver, my.port, my.host, my.logger, my.log =\n                   receiver,    port,    host,    logger,    log }\n\n      instance_eval(&block) if block\n    end\n\n    attr_reader :thread\n\n    def daemon(*args, &block)\n      stop\n\n      logger.info \"start daemon\"\n      Process.daemon\n      service_loop *args, &block\n    end\n\n    def start(*args, &block)\n      stop\n\n      logger.info \"start server: pid = #{$$}\"\n      @thread = Thread.new { service_loop *args, &block }\n    end\n\n    def stop\n      return unless @thread\n\n      logger.info \"stop server: pid = #{$$}\"\n      @thread.kill rescue nil\n      @thread = nil\n    end\n\n    private\n    def service_loop(receiver=nil, port:nil, host:nil)\n      port     ||= (self.port     || PORT)\n      host     ||= (self.host     || HOST)\n      receiver ||= (self.receiver || null)\n\n      logger.info \"accept loop: host = #{host}, port = #{port}\"\n\n      Socket.tcp_server_loop(host, port) do |conn, *|\n        Thread.new do\n          begin\n            serivce(receiver, conn)\n          ensure\n            conn.close\n          end\n        end\n      end\n    end\n\n    def serivce(receiver, conn)\n      msg = conn.read           ; logger.debug \"request(raw) : #{msg}\"\n      req = Prolog.to_ruby(msg) ; logger.debug \"request(ruby): #{req}\"\n\n      pred?(req) ? receiver.send(req.keys.first, *req.values.first) :\n      atom?(req) ? receiver.send(req)                               : nil\n    rescue Exception => e\n      logger.error \"exception: #{e}\"\n      error_notify(e)\n    end\n\n    def pred?(x)\n      x.kind_of?(Hash)               &&\n      x.size == 1                    &&\n      x.keys.first.kind_of?(Symbol)  &&\n      x.values.first.kind_of?(Array)\n    end\n\n    def atom?(x)\n      x.kind_of?(Symbol)\n    end\n\n    def null\n      @null ||= Class.new{ def method_missing(*) ; end }.new\n    end\n\n    public\n    def on_error(exception_type=Exception, &block)\n      handlers[exception_type] << block if block\n    end\n\n    private\n    def handlers\n      @handlers ||= Hash.new {|h, k| h[k] = [] }\n    end\n\n    def error_notify(exception)\n      handlers.select{|type, *| exception.kind_of? type }.values.reduce(:+)\n              .each  {|handler| handler.(exception) }\n    end\n  end\nend\n\nif __FILE__ == $0\n  require 'optparse'\n  require 'ostruct'\n\n  class DummyReceiver\n    def foo(*args)\n      puts \"call method: foo(#{args * ','}), args = #{args.count}\"\n    end\n    def bar(*args)\n      puts \"call method: bar(#{args * ','}), args = #{args.count}\"\n    end\n    def baz(*args)\n      puts \"call method: baz(#{args * ','}), args = #{args.count}\"\n    end\n  end\n\n  dummy_receiver = DummyReceiver.new\n\n  opt = OpenStruct.new ARGV.getopts '', 'port:','host:','log:','daemon'\n\n  if opt.daemon\n    # (\u6ce8\u610f) \u30c7\u30fc\u30e2\u30f3\u306b\u3059\u308b\u3068\u6a19\u6e96\u51fa\u529b\u306a\u3069\u304c\u5207\u308a\u96e2\u3055\u308c\u307e\u3059\n    Prolog::Server.daemon(dummy_receiver,\n                          port:opt.port, host:opt.host, log:opt.log)\n  else\n    server = Prolog::Server.new(dummy_receiver,\n                                port:opt.port, host:opt.host, log:opt.log)\n    server.on_error {|e| puts e }\n    server.logger.level = :DEBUG\n    server.start.join\n  end\nend\n\n\n# \u306f\u3058\u3081\u306b\nProlog \u5074\u304b\u3089 Ruby \u306e\u30e1\u30bd\u30c3\u30c9\u3092\u547c\u3073\u51fa\u3059\u3001\u3068\u3044\u3046\u306e\u3092\u3084\u3063\u3066\u307f\u307e\u3057\u305f\u3002\n\n\u52d5\u4f5c\u74b0\u5883\n\n- Ubuntu Linux 14.04\n- Ruby 2.1.5 p273\n- SWI-Prolog version 6.6.4 for amd64\n- \u30b9\u30af\u30ea\u30d7\u30c8\u985e\n  - ruby-client.pro  (Prolog \u30d7\u30ed\u30b0\u30e9\u30e0) \u203b\u30af\u30e9\u30a4\u30a2\u30f3\u30c8 (\u672c\u7a3f\u672b\u5c3e\u306b\u63b2\u8f09)\n  - server.pro (Prolog \u30d7\u30ed\u30b0\u30e9\u30e0)       \u203bProlog \u30b5\u30fc\u30d0\n  - prolog_server.rb (Ruby\u30b9\u30af\u30ea\u30d7\u30c8)    \u203b\u30b5\u30fc\u30d0 (\u672c\u7a3f\u672b\u5c3e\u306b\u63b2\u8f09)\n  - prolog_parser.rb (Ruby\u30b9\u30af\u30ea\u30d7\u30c8)    \u203b\u30df\u30cb Prolog \u30d1\u30fc\u30b5\n  - prolog_proxy.rb (Ruby\u30b9\u30af\u30ea\u30d7\u30c8)     \u203bProlog \u30b5\u30fc\u30d0\u3068\u901a\u4fe1\u7528\n\nruby_client.pro\u3001prolog_server.rb \u4ee5\u5916\u306f\u3001\u4ee5\u4e0b\u306e\u8a18\u4e8b\u306e\u6d41\u7528\u3067\u3059\u3002\n\u8a73\u7d30\u306f\u305d\u3061\u3089\u3092\u3054\u89a7\u304f\u3060\u3055\u3044\u3002\n\n- [Ruby: Prolog\u3067\u7ffb\u8a33\u300c\u6642\u306e\u877f\u306f\u3072\u3068\u3064\u306e\u77e2\u3092\u597d\u3080\u300d][Qiita#1] \n\n\n# \u30c7\u30e2 (\u305d\u306e1)\n\n![prolog_ruby-2.png](https://qiita-image-store.s3.amazonaws.com/0/60624/7de55cb8-da5f-29d5-efb6-a2570d6d89a3.png)\n\n\u4e0a\u306e\u56f3\u306e\u3088\u3046\u306b Ruby \u30b5\u30fc\u30d0\u306b Prolog \u304b\u3089 TCP \u3067\u30e1\u30c3\u30bb\u30fc\u30b8\u3092\u9001\u4fe1\u3057\u307e\u3059\u3002\nRuby \u30b5\u30fc\u30d0\u306b\u306f\u30c7\u30e2\u7528\u306e\u30ec\u30b7\u30fc\u30d0\u30aa\u30d6\u30b8\u30a7\u30af\u30c8(dummy_receiver)\u304c\u4ed5\u8fbc\u307e\u308c\u3066\u3044\u307e\u3059\u3002\ndummy_receiver \u306f\u5f15\u6570\u3092 puts \u3059\u308b\u3060\u3051\u306e\u30e1\u30bd\u30c3\u30c9 foo,bar,baz \u3092\u6301\u3063\u3066\u3044\u307e\u3059\u3002\n\n\u3067\u306f\u3001Ruby \u30b5\u30fc\u30d0\u3092\u958b\u59cb\u3055\u305b\u307e\u3059\u3002\n\n```shell-session\n$ ruby prolog_server.rb    # \u30c7\u30d5\u30a9\u30eb\u30c8\u3067\u30dd\u30fc\u30c8 53340/tcp \u3092 LISTEN\n                           # \u8d77\u52d5\u3057\u305f\u307e\u307e\u306b\u306a\u308b\u3002\u505c\u6b62\u3059\u308b\u306b\u306f Ctrl-C\n                           # --log \u30ed\u30b0\u30d5\u30a1\u30a4\u30eb\u540d \u3092\u4ed8\u3051\u3066\u8d77\u52d5\u3059\u308b\u3068\u30ed\u30b0\u51fa\u529b\u3057\u307e\u3059\n```\n\n\u30af\u30e9\u30a4\u30a2\u30f3\u30c8\u30d7\u30ed\u30b0\u30e9\u30e0\u3092\u8aad\u307f\u8fbc\u3093\u3067 SWI-Prolog \u3092\u8d77\u52d5\u3057\u307e\u3059\u3002\n\n```shell-session\n$ swipl -l ruby_client.pro\n      :\n  (Prolog \u304c\u8d77\u52d5\u3059\u308b)\n```\n\nRuby \u30b5\u30fc\u30d0\u306e\u30e1\u30bd\u30c3\u30c9\u3092\u547c\u3073\u51fa\u3059\u306b\u306f\u3001\u4ee5\u4e0b\u306e\u8ff0\u8a9e\u3092\u4f7f\u3044\u307e\u3059\u3002(\u4f7f\u308f\u306a\u304f\u3066\u3082\u3067\u304d\u307e\u3059\u304c)\n\n```prolog\n  ruby(Pred)               % ruby/1 : Host = 'localhost', Port = 53340\n  ruby(Pred, Port)         % ruby/2 : Host = 'localhost'\n  ruby(Pred, Port, Host)   % ruby/3\n```\n\nSWI-Prolog \u306e\u30d7\u30ed\u30f3\u30d7\u30c8\u304b\u3089\u3001\u3084\u3063\u3066\u307f\u307e\u3059\u3002\n\n```prolog\n?- ruby(foo).                 % \u30a2\u30c8\u30e0\u306e\u5834\u5408\u3001\u5f15\u6570\u306a\u3057\u3067\u30e1\u30bd\u30c3\u30c9\u3092\u547c\u3073\u51fa\u3059\ntrue.\n\n?- ruby(bar(a,b,c)).          % \u8ff0\u8a9e\u306e\u5834\u5408\u3001\u8ff0\u8a9e\u306e\u5f15\u6570\u3092\u6e21\u3057\u3066\u30e1\u30bd\u30c3\u30c9\u3092\u547c\u3073\u51fa\u3059\ntrue.\n\n?- ruby(baz(a,f(x,y),[1,2,3],\"ABC\")).\ntrue.\n\n?- ruby(1).                   % 1 \u306f\u30a2\u30c8\u30e0/\u8ff0\u8a9e\u4ee5\u5916\u306a\u306e\u3067\u7121\u8996\u3055\u308c\u308b\ntrue.\n```\n\n\u4e0a\u3092\u5b9f\u884c\u306b\u3088\u308a\u3001Ruby \u30b5\u30fc\u30d0\u5074\u3067\u4ee5\u4e0b\u306e\u3088\u3046\u306b\u8868\u793a\u3055\u308c\u307e\u3059\u3002\n\n```\n$ ruby prolog_server.rb\ncall method: foo(), args = 0\ncall method: bar(a,b,c), args = 3\ncall method: baz(a,{:f=>[:x, :y]},1,2,3,65,66,67), args = 4   # puts \u306a\u306e\u3067\u3053\u3046\u898b\u3048\u307e\u3059\u304c\u3001\u5f15\u6570\u306f 4 \u500b\u3067\u3059\u3002\n```\n\n\u30e1\u30c3\u30bb\u30fc\u30b8\u306b\u5bfe\u5fdc\u3059\u308b\u30e1\u30bd\u30c3\u30c9\u304c\u547c\u3073\u51fa\u3055\u308c\u307e\u3059\u3002\n\u5f15\u6570\u306f\u3001\u30df\u30cb Prolog \u30d1\u30fc\u30b5\u306e\u89e3\u91c8(Ruby\u8868\u73fe)\u3067\u6e21\u3055\u308c\u307e\u3059\u3002\n`ruby(1)` \u306e\u3088\u3046\u306b\u3001\u30a2\u30c8\u30e0/\u8ff0\u8a9e\u4ee5\u5916\u306e\u3082\u306e\u306f\u7121\u8996\u3055\u308c\u307e\u3059\u3002\n\n---\n\n# \u30c7\u30e2 (\u305d\u306e2: Prolog \u3082\u30b5\u30fc\u30d0\u306b\u3059\u308b)\n\n- [Ruby: Prolog\u3067\u7ffb\u8a33\u300c\u6642\u306e\u877f\u306f\u3072\u3068\u3064\u306e\u77e2\u3092\u597d\u3080\u300d][Qiita#1] \n\n\u4e0a\u306e\u8a18\u4e8b\u3067\u3057\u305f\u3088\u3046\u306b Prolog \u3082\u30b5\u30fc\u30d0\u306b\u3057\u3066\u307f\u308b\u3053\u3068\u3082\u3067\u304d\u307e\u3059\u3002\n\n![prolog_ruby.png](https://qiita-image-store.s3.amazonaws.com/0/60624/c00a3fa5-46ed-294b-b63c-79c876fea24a.png)\n\nRuby \u30b5\u30fc\u30d0\u306e\u8d77\u52d5\u306f\u30c7\u30e2(\u305d\u306e1)\u3068\u540c\u3058\u3067\u3059\u3002\n\n```shell-session\n$ ruby prolog_server.rb    # \u30c7\u30d5\u30a9\u30eb\u30c8\u3067\u30dd\u30fc\u30c8 53340/tcp \u3092 LISTEN\n                           # \u8d77\u52d5\u3057\u305f\u307e\u307e\u306b\u306a\u308b\u3002\u505c\u6b62\u3059\u308b\u306b\u306f Ctrl-C\n```\n\n\u7d9a\u3044\u3066 Prolog \u30b5\u30fc\u30d0\u3092\u8d77\u52d5\u3057\u307e\u3059\u3002\n\n```shell-session\n$ swipl -l server.pro -g 'create_sserver(53330).'  # \u8d77\u52d5\u3057\u305f\u307e\u307e\u306b\u306a\u308b\n```\n\nProlog \u30b5\u30fc\u30d0\u3078\u306e\u901a\u4fe1\u306f Prolog::Proxy \u3067\u884c\u3044\u307e\u3059\u3002\npry \u3092\u4f7f\u3044\u307e\u3059\u3002ruby-client.pro \u304c\u3042\u308b\u30c7\u30a3\u30ec\u30af\u30c8\u30ea\u3067 pry \u3092\u8d77\u52d5\u3057\u307e\u3059\u3002\n\n```shell-session\n$ pry -r prolog_proxy        # prolog_proxy.rb \u3092 require \u3057\u307e\u3059\u3002\n    :\n```\n\nload \u30e1\u30bd\u30c3\u30c9\u3067 Prolog \u30b5\u30fc\u30d0\u306b ruby-client.pro \u306e\u5185\u5bb9\u3092\u6d41\u3057\u8fbc\u307f\u307e\u3059\u3002\n\u305d\u306e\u5f8c\u3067 Prolog \u30b5\u30fc\u30d0\u306b ruby/1 \u3092\u554f\u3044\u5408\u308f\u305b\u307e\u3059\u3002\n\n```rb\n[1] pry(main)> cd Prolog::Proxy\n[2] pry(Prolog::Proxy):1> load ['ruby-client.pro']\n=> [\"./ruby-client.pro\"]\n[3] pry(Prolog::Proxy):1> q 'ruby(foo(a,b))'\n=> \"[ruby(foo(a,b))]\"\n```\n\nRuby \u30b5\u30fc\u30d0\u3067 dummy_receiver \u306e foo \u304c\u547c\u3073\u51fa\u3055\u308c\u3001\u4ee5\u4e0b\u306e\u3088\u3046\u306b\u8868\u793a\u3055\u308c\u307e\u3059\u3002\n\n```shell-session\n(Ruby \u30b5\u30fc\u30d0\u304c\u8d77\u52d5\u3057\u3066\u3044\u308b\u30bf\u30fc\u30df\u30ca\u30eb)\ncall method: foo(a,b), args = 2\n```\n\n# \u30c7\u30e2 (\u305d\u306e3: Proxy \u3092 drb \u30c7\u30fc\u30e2\u30f3\u306b\u3059\u308b)\n\n- [Ruby: Prolog\u3067\u7ffb\u8a33\u300c\u6642\u306e\u877f\u306f\u3072\u3068\u3064\u306e\u77e2\u3092\u597d\u3080\u300d][Qiita#1] \n\n\u4e0a\u306e\u8a18\u4e8b\u3067\u3057\u305f\u3088\u3046\u306b Proxy \u3092 drb \u30c7\u30fc\u30e2\u30f3\u3057\u3066\u307f\u307e\u3059\u3002\n\u30ea\u30e2\u30fc\u30c8\u306e Ruby \u304b\u3089 drb \u3067 Proxy \u306b\u30a2\u30af\u30bb\u30b9\u3057\u3066 Prolog \u30b5\u30fc\u30d0\u3092\u64cd\u4f5c\u3067\u304d\u307e\u3059\u3002\n\n![Prolog-Ruby-mini.png](https://qiita-image-store.s3.amazonaws.com/0/60624/3f8b7e35-bb8d-888b-793b-818c0407bbc2.png)\n\n\u57fa\u672c\u7684\u306b\u4e0a\u306e\u8a18\u4e8b\u3068\u540c\u3058\u3053\u3068\u3092\u3057\u3066\u3044\u308b\u306e\u3067\u624b\u9806\u306e\u307f\u63b2\u8f09\u3057\u307e\u3059\u3002\n\n```shell-session\n: \u30bf\u30fc\u30df\u30ca\u30eb#1 : Ruby \u30b5\u30fc\u30d0\u8d77\u52d5\n$ ruby prolog_server.rb\n                                # \u8d77\u52d5\u3057\u305f\u307e\u307e\u306b\u306a\u308b\n```\n```shell-session\n: \u30bf\u30fc\u30df\u30ca\u30eb#2 : Prolog \u30b5\u30fc\u30d0\u8d77\u52d5\n$ swipl -l server.pro -g 'create_server(53330).'\n                                # \u8d77\u52d5\u3057\u305f\u307e\u307e\u306b\u306a\u308b\n```\n```shell-session\n: \u30bf\u30fc\u30df\u30ca\u30eb#3 : Prolog \u30b5\u30fc\u30d0\u306b ruby_client \u3092\u30ed\u30fc\u30c9\n$ ruby -r prolog_proxy -e 'Prolog::Proxy.load [\"ruby-client.pro\"]'\n```\n```shell-session\n: \u30bf\u30fc\u30df\u30ca\u30eb#4 : Proxy \u30c7\u30fc\u30e2\u30f3(drb\u30b5\u30fc\u30d3\u30b9)\u8d77\u52d5\n$ ruby prolog_proxy.rb --drb --daemon  # \u30d0\u30c3\u30af\u30b0\u30e9\u30f3\u30c9\u3067\u8d77\u52d5\n```\n```shell-session\n: \u30bf\u30fc\u30df\u30ca\u30eb#5 (\u30ea\u30e2\u30fc\u30c8) : pry \u3067\u64cd\u4f5c\n$ pry -r drb             # drb \u3092 require\n    :\n[1] pry(main)> px = DRbObject.new_with_uri 'druby://:53331'\n=> ...\n[2] pry(main)> px.q 'ruby(foo(x))'\n=> \"[ruby(foo(x))]\"\n```\n\n\u4e0a\u306e\u64cd\u4f5c\u306b\u3088\u308a\u3001\u30bf\u30fc\u30df\u30ca\u30eb#1 \u3067 Ruby \u30b5\u30fc\u30d0\u306e\u51e6\u7406\u7d50\u679c\u304c\u51fa\u529b\u3055\u308c\u307e\u3059\u3002\n\n```shell-session\n    :\ncall method: foo(x), args = 1\n```\n\n# \u30b5\u30fc\u30d0\u3078\u306e\u30ec\u30b7\u30fc\u30d0\u306e\u8a2d\u5b9a\u306e\u4ed5\u65b9\n\u30b5\u30fc\u30d0\u306b\u306f\u3001\u4efb\u610f\u306e\u30ec\u30b7\u30fc\u30d0\u30aa\u30d6\u30b8\u30a7\u30af\u30c8\u3092\u8a2d\u5b9a\u3067\u304d\u307e\u3059\u3002\n\n```rb\nrequire 'prolog_server'\n\nclass MyClass       # \u30ec\u30b7\u30fc\u30d0\u306b\u3059\u308b\u30aa\u30d6\u30b8\u30a7\u30af\u30c8\u306e\u30af\u30e9\u30b9\u5b9a\u7fa9\n  # \u9069\u5f53\u306b\u30e1\u30bd\u30c3\u30c9\u5b9a\u7fa9\u3059\u308b\n  # def hoge(...) ... \u3068\u3059\u308b\u3068 Prolog\u5074\u304b\u3089 `?- ruby(hoge(...)).` \u3067\u547c\u3073\u51fa\u305b\u308b\nend\nmy_receiver = MyClass.new\n````\n\n\u4e0a\u306e\u3088\u3046\u306b\u4f5c\u3063\u305f\u30ec\u30b7\u30fc\u30d0(my_receiver) \u3092\u4ee5\u4e0b\u306e\u3044\u305a\u308c\u304b\u306e\u65b9\u6cd5\u3067\u6307\u5b9a\u3057\u307e\u3059\u3002\n\n```rb\nth = Prolog::Server.start(my_receiver)\nth.join            # \u623b\u308a\u5024\u306f\u30b5\u30fc\u30d0\u306e Thread \u30aa\u30d6\u30b8\u30a7\u30af\u30c8\u306a\u306e\u3067 join \u3067\u304d\u308b\n```\n```rb\nProlog::Server.daemon(my_receiver)  # \u3053\u306e\u5834\u5408\u3001\u30c7\u30fc\u30e2\u30f3\u306b\u306a\u308b\n```\n```rb\nserver = Prolog::Server.new         # \u30a4\u30f3\u30b9\u30bf\u30f3\u30b9\u3092\u4f5c\u3063\u3066\u6307\u5b9a\u3059\u308b\u65b9\u6cd5\nth = server.start(my_receiver)\nth.join\n```\n```rb\nserver = Prolog::Server.new\nserver.daemon(my_receiver)          # \u3053\u306e\u5834\u5408\u3001\u30c7\u30fc\u30e2\u30f3\u306b\u306a\u308b\n```\n\n\u30ec\u30b7\u30fc\u30d0\u306e\u30e1\u30bd\u30c3\u30c9\u547c\u3073\u51fa\u3057\u6642\u306e\u4f8b\u5916\u3092\u30cf\u30f3\u30c9\u30eb\u3059\u308b\u5834\u5408\u306f\u3001\u4ee5\u4e0b\u306e\u3088\u3046\u306b\u3057\u307e\u3059\u3002\n\n```rb\nserver = Prolog::Server.new             \n       # on_error \u3067\u30cf\u30f3\u30c9\u30e9\u3092\u6307\u5b9a\u3059\u308b\u3002\u5f15\u6570\u306f\u30ad\u30e3\u30d7\u30c1\u30e3\u3059\u308b\u4f8b\u5916\u30bf\u30a4\u30d7\nserver.on_error(NoMethodError) {|e| puts \"Exception: #{e.class}\" }\nth = server.start(my_receiver)\nth.join\n```\n\n# \u30d0\u30a4\u30c8\u914d\u5217\u3068\u6587\u5b57\u5217\u306e\u5909\u63db\nSWI-Prolog \u306f\u5f15\u6570\u306e\u6587\u5b57\u5217\u3092\u9001\u4fe1\u3059\u308b\u6642\u306b\u3001\u6574\u6570(\u30d0\u30a4\u30c8\u5024)\u306e\u30ea\u30b9\u30c8\u3068\u3057\u3066\u9001\u308b\u3088\u3046\u3067\u3059\u3002\n\n```rb\n[63] pry(Prolog::Proxy):1> q 'ruby(foo(\"ABC\"))'\n=> \"[ruby(foo([65,66,67]))]\"\n```\n\nRuby \u30b5\u30fc\u30d0\u306e\u30df\u30cb Prolog \u30d1\u30fc\u30b5\u306f\u3001\u6587\u5b57\u5217\u306f String \u306b\u3001\u30ea\u30b9\u30c8\u306f Array \u306b\u5909\u63db\u3059\u308b\u306e\u3067\u3001\u30ec\u30b7\u30fc\u30d0\u306e\u5f15\u6570\u306b\u306f\u6574\u6570(\u30d0\u30a4\u30c8\u5024)\u306e Array \u3068\u3057\u3066\u6e21\u3055\u308c\u307e\u3059\u3002\n\n\u30d0\u30a4\u30c8\u914d\u5217\u3068\u6587\u5b57\u5217\u306e\u5909\u63db\u304c\u5fc5\u8981\u306a\u5834\u5408\u306f\u3001\u30ec\u30b7\u30fc\u30d0\u3067\u884c\u3044\u307e\u3059\u3002\n\n```rb\n# \u5909\u63db\u306e\u4f8b\np [65,66,67].pack \"C*\"       #=> \"ABC\"\np \"ABC\".unpack \"C*\"          #=> [65, 66, 67]\n```\n```rb\n# \u30d0\u30a4\u30c8\u306e\u914d\u5217\u304b\u5224\u5b9a\u3059\u308b\u4f8b\narg = [65,66,67]\n\np arg.kind_of?(Array) && arg.all? {|n| (0..255).include? n }    #=> true\n```\n\n\u3061\u306a\u307f\u306b\u3001\u62d9\u7a3f\u300c[Ruby: method_missing \u3092\u4f7f\u3063\u3066\u307f\u305f][Qiita#2]\u300d\u306e KindOfTest \u3092\u4f7f\u3046\u3068\u5224\u5b9a\u306f\u4ee5\u4e0b\u306e\u3088\u3046\u306b\u3067\u304d\u307e\u3059\u3002\n\n```rb\nrequire 'kind_of_test'\nclass Object ; include KindOfTest ; end\n\np [65,66,67].array? &:byte?          #=> true\np [65,66,67,256].array? &:byte?      #=> false\n```\n\n# \u30b9\u30af\u30ea\u30d7\u30c8\n\n\u30af\u30e9\u30a4\u30a2\u30f3\u30c8 (Prolog \u30d7\u30ed\u30b0\u30e9\u30e0)\n\n```prolog:ruby_client.pro\nruby(Req) :- ruby(Req, 53340).\nruby(Req, Port) :- ruby(Req, 'localhost', Port).\nruby(Req, Host, Port) :- create_client(Req, Host, Port).\n\ncreate_client(Req, Host, Port) :-\n    setup_call_catcher_cleanup(tcp_socket(Socket),\n                               tcp_connect(Socket, Host:Port),\n                               exception(_),\n                               tcp_close_socket(Socket)),\n    setup_call_cleanup(tcp_open_socket(Socket, In, Out),\n                       request_to_server(Req, In, Out),\n                       close_client_connection(In, Out)).\n\nclose_client_connection(In, Out) :-\n    close(In, [force(true)]),\n    close(Out, [force(true)]).\n\nrequest_to_server(Req, _, Out) :-\n    write(Out, Req).\n```\n\n\u30b5\u30fc\u30d0 (Ruby \u30b9\u30af\u30ea\u30d7\u30c8)\n\n```rb:prolog_server.rb\nrequire 'socket'\nrequire 'resolv-replace'\nrequire 'logger'\nrequire 'prolog_parser'\n\nmodule Prolog\n  class Server\n    HOST, PORT = '0.0.0.0', 53340\n\n    def self.daemon(*args, &block)\n      new(*args, &block).daemon\n    end\n\n    def self.start(*args, &block)\n      new(*args, &block).start\n    end\n\n    class ServerLogger < Logger\n      def level=(x)\n        x = Logger.const_get(x) if %i(DEBUG INFO WARN ERROR FATAL).include?(x)\n        super(x)\n      end\n    end\n\n    attr_accessor :log\n    attr_writer :logger\n    def logger; @logger ||= (log ? ServerLogger.new(log) : null) ; end\n\n    attr_accessor :host, :port, :receiver\n\n    def initialize(receiver=nil, port:nil,host:nil, logger:nil,log:nil, &block)\n      tap {|my| my.receiver, my.port, my.host, my.logger, my.log =\n                   receiver,    port,    host,    logger,    log }\n\n      instance_eval(&block) if block\n    end\n\n    attr_reader :thread\n    \n    def daemon(*args, &block)\n      stop\n\n      logger.info \"start daemon\"\n      Process.daemon\n      service_loop *args, &block\n    end\n\n    def start(*args, &block)\n      stop\n\n      logger.info \"start server: pid = #{$$}\"\n      @thread = Thread.new { service_loop *args, &block }\n    end\n\n    def stop\n      return unless @thread\n\n      logger.info \"stop server: pid = #{$$}\"\n      @thread.kill rescue nil\n      @thread = nil\n    end\n\n    private\n    def service_loop(receiver=nil, port:nil, host:nil)\n      port     ||= (self.port     || PORT)\n      host     ||= (self.host     || HOST)\n      receiver ||= (self.receiver || null)\n\n      logger.info \"accept loop: host = #{host}, port = #{port}\"\n\n      Socket.tcp_server_loop(host, port) do |conn, *|\n        Thread.new do\n          begin\n            serivce(receiver, conn)\n          ensure\n            conn.close\n          end\n        end\n      end\n    end\n\n    def serivce(receiver, conn)\n      msg = conn.read           ; logger.debug \"request(raw) : #{msg}\"\n      req = Prolog.to_ruby(msg) ; logger.debug \"request(ruby): #{req}\"\n\n      pred?(req) ? receiver.send(req.keys.first, *req.values.first) :\n      atom?(req) ? receiver.send(req)                               : nil\n    rescue Exception => e\n      logger.error \"exception: #{e}\"\n      error_notify(e)\n    end\n\n    def pred?(x)\n      x.kind_of?(Hash)               &&\n      x.size == 1                    &&\n      x.keys.first.kind_of?(Symbol)  &&\n      x.values.first.kind_of?(Array)\n    end\n\n    def atom?(x)\n      x.kind_of?(Symbol)\n    end\n\n    def null\n      @null ||= Class.new{ def method_missing(*) ; end }.new\n    end\n\n    public\n    def on_error(exception_type=Exception, &block)\n      handlers[exception_type] << block if block\n    end\n\n    private\n    def handlers\n      @handlers ||= Hash.new {|h, k| h[k] = [] }\n    end\n\n    def error_notify(exception)\n      handlers.select{|type, *| exception.kind_of? type }.values.reduce(:+)\n              .each  {|handler| handler.(exception) }\n    end\n  end\nend\n\nif __FILE__ == $0\n  require 'optparse'\n  require 'ostruct'\n\n  class DummyReceiver\n    def foo(*args)\n      puts \"call method: foo(#{args * ','}), args = #{args.count}\"\n    end\n    def bar(*args)\n      puts \"call method: bar(#{args * ','}), args = #{args.count}\"\n    end\n    def baz(*args)\n      puts \"call method: baz(#{args * ','}), args = #{args.count}\"\n    end\n  end\n\n  dummy_receiver = DummyReceiver.new\n\n  opt = OpenStruct.new ARGV.getopts '', 'port:','host:','log:','daemon'\n\n  if opt.daemon\n    # (\u6ce8\u610f) \u30c7\u30fc\u30e2\u30f3\u306b\u3059\u308b\u3068\u6a19\u6e96\u51fa\u529b\u306a\u3069\u304c\u5207\u308a\u96e2\u3055\u308c\u307e\u3059\n    Prolog::Server.daemon(dummy_receiver,\n                          port:opt.port, host:opt.host, log:opt.log)\n  else\n    server = Prolog::Server.new(dummy_receiver,\n                                port:opt.port, host:opt.host, log:opt.log)\n    server.on_error {|e| puts e }\n    server.logger.level = :DEBUG\n    server.start.join\n  end\nend\n```\n\n[Qiita#1]: http://qiita.com/lnznt/items/72abba6b045ef4ffafae\n[Qiita#2]: http://qiita.com/lnznt/items/ee2f7763ee882826da63\n", "tags": ["Prolog", "Ruby"]}