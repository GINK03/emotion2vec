{"tags": ["CommonLisp", "lisp"], "context": " More than 1 year has passed since last update.\u306f\u3044\u306f\u3044\u30fc\u3002@nobkz\u3067\u3059\u3002\n\nLisp\u3067\u30e2\u30ca\u30c9\u3084\u3063\u3066\u307f\u305f\u8a71\n\u306f\u3044\u306f\u3044\u3002\u306a\u3093\u3068\u306a\u304fLisp\u3067\u30e2\u30ca\u30c9\u3084\u3063\u305f\u8a71\u3092\u66f8\u304d\u307e\u3059\u3002\n\noptima\u3092load\n\u306f\u3044\u306f\u3044\n(ql:quickload :optima)\n\n\n\u30e2\u30ca\u30c9\u306ereturn\u95a2\u6570\u3068bind\u3092\u307e\u305adefgeneric\u30e1\u30bd\u30c3\u30c9\u3068\u3059\u308b\u3002\n;; return\n(defgeneric ret (type x))\n\n;; >>=\n(defgeneric bind (m func))\n\n\nOption\u30e2\u30ca\u30c9\u3092\u3064\u304f\u308b\nOption\u30e2\u30ca\u30c9\u3068\u304b\u306b\u3064\u3044\u3066\u306f\u307f\u306a\u3055\u3093\u3054\u5b58\u77e5\u3067\u3059\u306d\u3002\n\u306f\u3044\u306f\u3044\u30fc\u3002Haskell\u3067\u306fMaybe\u3068\u3044\u3046\u3001\u5024\u304c\u3042\u308b\u304b\u306a\u3044\u304b\u306e\u578b\u304c\u3042\u308a\u307e\u3057\u3066\u3001\u305d\u308c\u3092\u3064\u304f\u308a\u307e\u3059\u3002\n\u69cb\u9020\u4f53\u3067\u3064\u304f\u308a\u307e\u3057\u305f\u3002\n(defstruct option)\n(defstruct (just (:constructor just (content))\n         (:include option))\n  content)\n(defstruct (none (:constructor none)\n         (:include option)))\n\n\nOption\u306eret\u3068bind\u3092\u5b9f\u88c5\u3059\u308b\n\u306f\u3044\u306f\u3044\u3001\u3053\u3093\u306a\u611f\u3058\u306b\u306a\u308a\u307e\u3059\u3002\n(defmethod ret ((type (eql 'option)) x)\n  (just x))\n\n(defmethod bind ((m option) proc-returning-option)\n  (match m\n    ((just :content x) (funcall proc-returning-option x))\n    ((none) (none))))\n\n\n\u3064\u304b\u3063\u3066\u307f\u308b\u3002\n\u7c21\u5358\u306b\u3084\u3063\u3066\u307f\u308b\u3068...\n(bind (ret 'option 1) (lambda (x) (ret 'option (+ x 1)))) \n;; -> #S(JUST :CONTENT 2)\n\n(bind (none) (lambda (x) (ret 'option (+ x 1))))\n ;; ->  #S(NONE)\n\n\u3055\u3066\u7c21\u5358\u306b\u3059\u308b\u305f\u308120\u3092\u8d85\u3048\u308b\u3068\u3001\u5931\u6557\u3059\u308b\u8a08\u7b97\u3092\u3084\u3063\u3066\u307f\u308b\u3002(\u3064\u307e\u308a\u3001\u8a08\u7b97\u3057\u306620\u3092\u8d85\u3048\u305f\u3068\u304dnone\u3092\u8fd4\u3057\u3001\u6210\u529f\u3059\u308b\u3068\u3001just\u3092\u8fd4\u3059\u8a08\u7b97\u3092\u3064\u304f\u308b\u3002)\n\u307e\u305a add-option20\u3092\u3064\u304f\u308b\u3002\n(defun add-option20 (x) \n  (lambda (y) \n    (let ((ans (+ x y)))\n      (if (< ans 20)\n      (just ans)\n      (none)))))\n\nbind\u3067\u7d44\u307f\u5408\u305b\u308b\u3002\n(bind (ret 'option 1) (add-option20 1))\n;; -> #S(JUST :CONTENT 2)\n\n(bind (ret 'option 10) (add-option20 10))\n;; -> #S(NONE)\n\n(bind \n (bind \n  (bind (ret 'option 1) \n    (add-option20 1)) \n  (add-option20 1)) \n (add-option20 1))\n;; -> #S(JUST :CONTENT 4)\n\n(bind \n (bind \n  (bind (ret 'option 1) \n    (add-option20 1)) \n  (add-option20 20)) \n (add-option20 1))\n;; -> #S(NONE)\n\n\n\nbind\u304c\u9762\u5012\u306a\u306e\u3067\u3001binds\u3092\u4f5c\u3063\u305f\u3002\n\u6bce\u56debind\u3001bind\u3068\u66f8\u304f\u306e\u9762\u5012\u306a\u306e\u3067\u3001\u3053\u3093\u306a\u306e\u4f5c\u3063\u305f\u30fc\u3002\n(defun binds (m &rest funcs)\n  (if funcs\n      (reduce #'bind (cons m funcs))\n      m))\n\n\u3064\u304b\u3063\u3066\u307f\u308b\u3002\n(binds (ret 'option 1) \n       (add-option20 1) \n       (add-option20 1) \n       (add-option20 1))\n;; -> #S(JUST :CONTENT 4)\n\n(binds (ret 'option 1) \n       (add-option20 1) \n       (add-option20 20) \n       (add-option20 1))\n;; -> #S(NONE)\n\n\u826f\u3044\u611f\u3058\u3067\u3059\u306d\u3002\n\ndo\u8a18\u6cd5\u307d\u3044\u3082\u306e\u3092\u3064\u304f\u3063\u305f\u30fc\u3002\n\u3053\u3093\u306a\u611f\u3058\u3002\n(defmacro do-monad (type &body body)\n  (let ((_ (gensym)))\n    (let ((first (car body))\n      (rest (cdr body)))\n      (let ((ret-first (ret-add-types type first)))\n    (match ret-first\n      ((list 'setm arg monad-proc)\n       `(binds ,monad-proc\n           ,(if rest\n            `(lambda (,arg)\n               (do-monad ,type ,@rest)))))\n      (_\n       (if (null rest)\n           ret-first\n           `(binds ,ret-first\n               (lambda (,_)\n             (declare (ignore ,_))\n             (do-monad ,type ,@rest))))))))))\n\n(defun ret-add-types (type list)\n  (let ((first (car list))\n    (rest (cdr list)))\n    (cond ((null list) nil)\n      ((eq first 'do-monad) list)\n      ((eq first 'ret)\n       `(ret ,type ,@(ret-add-types type rest)))\n      ((listp first)\n       (cons (ret-add-types type first)\n         (ret-add-types type rest)))\n      (t (cons first (ret-add-types type rest))))))\n\n\u307e\u3060\u5b8c\u5168\u306a\u5b9f\u88c5\u3058\u3083\u306a\u3044\u3051\u3069\u3001\u3068\u308a\u3042\u3048\u305a\u7c21\u5358\u306ado\u8a18\u6cd5\u306f\u5b9f\u88c5\u3067\u304d\u308b\u3002\n\n\u3064\u304b\u3063\u3066\u307f\u308b\u3002\n(do-monad 'option \n  (setm x (ret 10)) \n  (funcall (add-option20 x) 1))\n\n;; -> #S(JUST :CONTENT 11)\n\n(do-monad 'option \n  (setm x (ret 10)) \n  (none)\n  (funcall (add-option20 x) 1))\n;; -> #S(NONE)\n\n\nState\u30e2\u30ca\u30c9\u3092\u3064\u304f\u3063\u3066\u307f\u308b\u3002\nState\u30e2\u30ca\u30c9\u306f\u4e00\u3064\u95a2\u6570\u5024\u3092\u6301\u3061\u307e\u3059\u3002\u305d\u306eState\u306e\u95a2\u6570\u5024\u306f\u3001\u72b6\u614b\u3092\u53d6\u308a\u3001 \u65b0\u3057\u3044\u72b6\u614b\u3068\u5024\u3092\u8fd4\u3059\u95a2\u6570\u3067\u306a\u304f\u3066\u306f\u306a\u308a\u307e\u305b\u3093\u3002\nlisp\u3067\u306f\u3001\u300c\u72b6\u614b\u3092\u53d6\u308a\u3001 \u65b0\u3057\u3044\u72b6\u614b\u3068\u5024\u3092\u8fd4\u3059\u95a2\u6570\u300d\u3068\u3044\u3046\u30c7\u30fc\u30bf\u6307\u5b9a\u306f\u3067\u304d\u306a\u3044\u306e\u3067\u3001\u3053\u3053\u3067\u306f\u300c\u65b0\u3057\u3044\u72b6\u614b\u3068\u5024\u300d\u3092\u6301\u3064transite-result\u3092\u5b9a\u7fa9\u3057\u3066\u3044\u307e\u3059\u3002\n\u305d\u3057\u3066\u3001State\u30e2\u30ca\u30c9\u9077\u79fb\u95a2\u6570\u3092\u9069\u7528\u3059\u308brun-trasit\u3092\u5b9a\u7fa9\u3057\u3066\u3044\u307e\u3059\u3002\n;; state monad\n(defstruct (transition (:constructor transition (proc)))\n  proc)\n\n(defstruct (transited-result\n         (:constructor transited-result\n               (value state)))\n  value\n  state)\n\n(defun run-transit (transit state)\n  (funcall (transition-proc transit) state))\n\n\u3068\u3059\u308b\u3068ret \u3068 bind\u306f\u3053\u3046\u306a\u308a\u307e\u3059\n(defmethod ret ((type (eql 'transition)) x)\n  (transition\n   (lambda (state) \n     (transited-result x state))))\n\n(defmethod bind ((transition transition) proc-returning-transition)\n  (transition\n   (lambda (state)\n     (let* ((first-transited-result \n         (run-transit transition state))\n        (new-transition \n         (funcall proc-returning-transition\n              (transited-result-value first-transited-result))))\n       (run-transit new-transition\n        (transited-result-state first-transited-result))))))\n\n\n\u3064\u304b\u3063\u3066\u307f\u308b\n;; state-example\n(defun transit-push (a)\n  (transition\n   (lambda (state)\n     (transited-result nil (cons a state)))))\n\n(defun transit-pop ()\n  (transition\n   (lambda (state)\n     (transited-result (car state) (cdr state)))))\n\n(defun fib-transit1 ()\n  (do-monad 'transition \n    (setm x (transit-pop))\n    (setm y (transit-pop))\n    (transit-push y)\n    (transit-push x)\n    (transit-push (+ x y))\n    (ret (+ x y))))\n\n(defun fib-transit5 ()\n  (do-monad 'transition\n    (fib-transit1)\n    (fib-transit1)\n    (fib-transit1)\n    (fib-transit1)\n    (fib-transit1)))\n\n(run-transit (fib-transit5) '(1 1))\n;; -> #S(TRANSITED-RESULT :VALUE 13 :STATE (13 8 5 3 2 1 1))\n\n\n\u30e2\u30ca\u30c7\u30a3\u30c3\u30afParsec\u307d\u3044\u306e\n\u8aac\u660e\u3059\u3093\u306e\u30c0\u30eb\u304f\u306a\u3063\u3066\u304d\u305f...\n ;; parser \n(defstruct (parser (:constructor parser (proc)))\n  proc)\n\n(defun parse (parser text)\n  (funcall (parser-proc parser) text))\n\n(defstruct (parse-result (:constructor parse-result (value text)))\n  value text)\n\n(defstruct (failed-result (:constructor failed-result (msg)))\n  msg)\n\n(defmethod ret ((type (eql 'parser)) x) \n  (parser \n   (lambda (text)\n     (parse-result x text))))\n\n(defmethod bind ((parser parser) proc-returning-parser)\n  (parser\n   (lambda (text)\n     (let ((parse-result \n        (parse parser text)))\n       (match parse-result\n     ((failed-result :msg _)\n      parse-result)\n     ((parse-result :value value :text text)\n      (let ((new-parser \n         (funcall proc-returning-parser value)))\n        (parse new-parser text))))))))\n\n(defun item ()\n  (parser \n   (lambda (text)\n     (if (string= text \"\")\n     (failed-result \"getiing text error\")\n     (parse-result (subseq text 0 1)\n               (subseq text 1 \n                   (length text)))))))\n\n(defun failure (msg)\n  (parser (lambda (text)\n        (declare (ignore text))\n        (failed-result msg))))\n\n(defun spaces ()\n  (parser (lambda (text)\n        (parse-result nil (front-space-delete text)))))\n\n(defun front-space-delete (text)\n  (let ((result \n     (position-if-not (lambda (s) (string= s \" \")) text)))\n    (if result\n    (subseq text result (length text)) \n    \"\")))\n\n(defun number ()\n  (do-monad 'parser\n    (setm c (item))\n    (if (find c \"1234567890\" :test #'string=)\n    (ret (parse-integer c))\n    (failure \"not number\"))))\n\n(defun eof ()\n  (parser\n   (lambda (text)\n     (if (string= text \"\")\n     (parse-result nil \"\")\n     (failed-result \"not end\")))))\n\n(defun plus ()\n  (do-monad 'parser\n    (setm c (item))\n    (if (string= c \"+\")\n    (ret t)\n    (failure \"not + at plus\"))))\n\n(defun my-parser1 ()\n  (do-monad 'parser\n    (spaces)\n    (setm x (number))\n    (spaces)\n    (plus)\n    (spaces)\n    (setm y (number))\n    (spaces)\n    (ret (+ x y))))\n\n(parse (my-parser1) \"1 + 1\")\n;; -> #S(PARSE-RESULT :VALUE 2 :TEXT \"\")\n\n\n\u8ab2\u984c\n\nlifting\u3001\u30e2\u30ca\u30c9\u5909\u63db\u5b50\u306e\u5b9f\u88c5\ndo\u8a18\u6cd5\u306e\u3001\u6587\u8108\u6307\u5b9a\u3092\u7121\u304f\u3059\u3002(\u95a2\u6570\u3088\u308a\u3001\u624b\u7d9a\u304d\u306e\u3068\u3057\u3066\u8003\u3048\u305f\u3089\u53ef\u80fd?)\n\n\u306f\u3044\u306f\u3044\u30fc\u3002@nobkz\u3067\u3059\u3002\n\n# Lisp\u3067\u30e2\u30ca\u30c9\u3084\u3063\u3066\u307f\u305f\u8a71\n\n\u306f\u3044\u306f\u3044\u3002\u306a\u3093\u3068\u306a\u304fLisp\u3067\u30e2\u30ca\u30c9\u3084\u3063\u305f\u8a71\u3092\u66f8\u304d\u307e\u3059\u3002\n\n## optima\u3092load\n\n\u306f\u3044\u306f\u3044\n\n```cl\n(ql:quickload :optima)\n```\n\n## \u30e2\u30ca\u30c9\u306ereturn\u95a2\u6570\u3068bind\u3092\u307e\u305adefgeneric\u30e1\u30bd\u30c3\u30c9\u3068\u3059\u308b\u3002\n\n```cl\n;; return\n(defgeneric ret (type x))\n\n;; >>=\n(defgeneric bind (m func))\n```\n\n\n## Option\u30e2\u30ca\u30c9\u3092\u3064\u304f\u308b\n\nOption\u30e2\u30ca\u30c9\u3068\u304b\u306b\u3064\u3044\u3066\u306f\u307f\u306a\u3055\u3093\u3054\u5b58\u77e5\u3067\u3059\u306d\u3002\n\n\u306f\u3044\u306f\u3044\u30fc\u3002Haskell\u3067\u306fMaybe\u3068\u3044\u3046\u3001\u5024\u304c\u3042\u308b\u304b\u306a\u3044\u304b\u306e\u578b\u304c\u3042\u308a\u307e\u3057\u3066\u3001\u305d\u308c\u3092\u3064\u304f\u308a\u307e\u3059\u3002\n\u69cb\u9020\u4f53\u3067\u3064\u304f\u308a\u307e\u3057\u305f\u3002\n\n```cl\n(defstruct option)\n(defstruct (just (:constructor just (content))\n\t\t (:include option))\n  content)\n(defstruct (none (:constructor none)\n\t\t (:include option)))\n```\n\n### Option\u306eret\u3068bind\u3092\u5b9f\u88c5\u3059\u308b\n\n\u306f\u3044\u306f\u3044\u3001\u3053\u3093\u306a\u611f\u3058\u306b\u306a\u308a\u307e\u3059\u3002\n\n```cl\n(defmethod ret ((type (eql 'option)) x)\n  (just x))\n\n(defmethod bind ((m option) proc-returning-option)\n  (match m\n    ((just :content x) (funcall proc-returning-option x))\n    ((none) (none))))\n```\n\n### \u3064\u304b\u3063\u3066\u307f\u308b\u3002\n\n\u7c21\u5358\u306b\u3084\u3063\u3066\u307f\u308b\u3068...\n\n```cl\n(bind (ret 'option 1) (lambda (x) (ret 'option (+ x 1)))) \n;; -> #S(JUST :CONTENT 2)\n\n(bind (none) (lambda (x) (ret 'option (+ x 1))))\n ;; ->  #S(NONE)\n```\n\n\u3055\u3066\u7c21\u5358\u306b\u3059\u308b\u305f\u308120\u3092\u8d85\u3048\u308b\u3068\u3001\u5931\u6557\u3059\u308b\u8a08\u7b97\u3092\u3084\u3063\u3066\u307f\u308b\u3002(\u3064\u307e\u308a\u3001\u8a08\u7b97\u3057\u306620\u3092\u8d85\u3048\u305f\u3068\u304dnone\u3092\u8fd4\u3057\u3001\u6210\u529f\u3059\u308b\u3068\u3001just\u3092\u8fd4\u3059\u8a08\u7b97\u3092\u3064\u304f\u308b\u3002)\n\n\u307e\u305a add-option20\u3092\u3064\u304f\u308b\u3002\n\n```cl\n(defun add-option20 (x) \n  (lambda (y) \n    (let ((ans (+ x y)))\n      (if (< ans 20)\n\t  (just ans)\n\t  (none)))))\n```\n\nbind\u3067\u7d44\u307f\u5408\u305b\u308b\u3002\n\n```cl\n(bind (ret 'option 1) (add-option20 1))\n;; -> #S(JUST :CONTENT 2)\n\n(bind (ret 'option 10) (add-option20 10))\n;; -> #S(NONE)\n\n(bind \n (bind \n  (bind (ret 'option 1) \n\t(add-option20 1)) \n  (add-option20 1)) \n (add-option20 1))\n;; -> #S(JUST :CONTENT 4)\n\n(bind \n (bind \n  (bind (ret 'option 1) \n\t(add-option20 1)) \n  (add-option20 20)) \n (add-option20 1))\n;; -> #S(NONE)\n \n```\n\n## bind\u304c\u9762\u5012\u306a\u306e\u3067\u3001binds\u3092\u4f5c\u3063\u305f\u3002\n\n\u6bce\u56debind\u3001bind\u3068\u66f8\u304f\u306e\u9762\u5012\u306a\u306e\u3067\u3001\u3053\u3093\u306a\u306e\u4f5c\u3063\u305f\u30fc\u3002\n\n```cl\n(defun binds (m &rest funcs)\n  (if funcs\n      (reduce #'bind (cons m funcs))\n      m))\n```\n\n\u3064\u304b\u3063\u3066\u307f\u308b\u3002\n\n```cl\n(binds (ret 'option 1) \n       (add-option20 1) \n       (add-option20 1) \n       (add-option20 1))\n;; -> #S(JUST :CONTENT 4)\n\n(binds (ret 'option 1) \n       (add-option20 1) \n       (add-option20 20) \n       (add-option20 1))\n;; -> #S(NONE)\n```\n\n\u826f\u3044\u611f\u3058\u3067\u3059\u306d\u3002\n\n## do\u8a18\u6cd5\u307d\u3044\u3082\u306e\u3092\u3064\u304f\u3063\u305f\u30fc\u3002\n\n\u3053\u3093\u306a\u611f\u3058\u3002\n\n```cl\n(defmacro do-monad (type &body body)\n  (let ((_ (gensym)))\n    (let ((first (car body))\n\t  (rest (cdr body)))\n      (let ((ret-first (ret-add-types type first)))\n\t(match ret-first\n\t  ((list 'setm arg monad-proc)\n\t   `(binds ,monad-proc\n\t\t   ,(if rest\n\t\t\t`(lambda (,arg)\n\t\t\t   (do-monad ,type ,@rest)))))\n\t  (_\n\t   (if (null rest)\n\t       ret-first\n \t       `(binds ,ret-first\n\t\t       (lambda (,_)\n\t\t\t (declare (ignore ,_))\n\t\t\t (do-monad ,type ,@rest))))))))))\n\n(defun ret-add-types (type list)\n  (let ((first (car list))\n\t(rest (cdr list)))\n    (cond ((null list) nil)\n\t  ((eq first 'do-monad) list)\n\t  ((eq first 'ret)\n\t   `(ret ,type ,@(ret-add-types type rest)))\n\t  ((listp first)\n\t   (cons (ret-add-types type first)\n\t\t (ret-add-types type rest)))\n\t  (t (cons first (ret-add-types type rest))))))\n```\n\n\u307e\u3060\u5b8c\u5168\u306a\u5b9f\u88c5\u3058\u3083\u306a\u3044\u3051\u3069\u3001\u3068\u308a\u3042\u3048\u305a\u7c21\u5358\u306ado\u8a18\u6cd5\u306f\u5b9f\u88c5\u3067\u304d\u308b\u3002\n\n### \u3064\u304b\u3063\u3066\u307f\u308b\u3002\n\n```cl\n(do-monad 'option \n  (setm x (ret 10)) \n  (funcall (add-option20 x) 1))\n\n;; -> #S(JUST :CONTENT 11)\n\n(do-monad 'option \n  (setm x (ret 10)) \n  (none)\n  (funcall (add-option20 x) 1))\n;; -> #S(NONE)\n```\n\n## State\u30e2\u30ca\u30c9\u3092\u3064\u304f\u3063\u3066\u307f\u308b\u3002\n\nState\u30e2\u30ca\u30c9\u306f\u4e00\u3064\u95a2\u6570\u5024\u3092\u6301\u3061\u307e\u3059\u3002\u305d\u306eState\u306e\u95a2\u6570\u5024\u306f\u3001\u72b6\u614b\u3092\u53d6\u308a\u3001 \u65b0\u3057\u3044\u72b6\u614b\u3068\u5024\u3092\u8fd4\u3059\u95a2\u6570\u3067\u306a\u304f\u3066\u306f\u306a\u308a\u307e\u305b\u3093\u3002\n\nlisp\u3067\u306f\u3001\u300c\u72b6\u614b\u3092\u53d6\u308a\u3001 \u65b0\u3057\u3044\u72b6\u614b\u3068\u5024\u3092\u8fd4\u3059\u95a2\u6570\u300d\u3068\u3044\u3046\u30c7\u30fc\u30bf\u6307\u5b9a\u306f\u3067\u304d\u306a\u3044\u306e\u3067\u3001\u3053\u3053\u3067\u306f\u300c\u65b0\u3057\u3044\u72b6\u614b\u3068\u5024\u300d\u3092\u6301\u3064transite-result\u3092\u5b9a\u7fa9\u3057\u3066\u3044\u307e\u3059\u3002\n\n\u305d\u3057\u3066\u3001State\u30e2\u30ca\u30c9\u9077\u79fb\u95a2\u6570\u3092\u9069\u7528\u3059\u308brun-trasit\u3092\u5b9a\u7fa9\u3057\u3066\u3044\u307e\u3059\u3002\n\n```cl\n;; state monad\n(defstruct (transition (:constructor transition (proc)))\n  proc)\n\n(defstruct (transited-result\n\t     (:constructor transited-result\n\t\t\t   (value state)))\n  value\n  state)\n\n(defun run-transit (transit state)\n  (funcall (transition-proc transit) state))\n```\n\n\u3068\u3059\u308b\u3068ret \u3068 bind\u306f\u3053\u3046\u306a\u308a\u307e\u3059\n\n```cl\n(defmethod ret ((type (eql 'transition)) x)\n  (transition\n   (lambda (state) \n     (transited-result x state))))\n\n(defmethod bind ((transition transition) proc-returning-transition)\n  (transition\n   (lambda (state)\n     (let* ((first-transited-result \n\t     (run-transit transition state))\n\t    (new-transition \n\t     (funcall proc-returning-transition\n\t\t      (transited-result-value first-transited-result))))\n       (run-transit new-transition\n\t\t(transited-result-state first-transited-result))))))\n```\n\n\n### \u3064\u304b\u3063\u3066\u307f\u308b\n\n```cl\n;; state-example\n(defun transit-push (a)\n  (transition\n   (lambda (state)\n     (transited-result nil (cons a state)))))\n\n(defun transit-pop ()\n  (transition\n   (lambda (state)\n     (transited-result (car state) (cdr state)))))\n\n(defun fib-transit1 ()\n  (do-monad 'transition \n    (setm x (transit-pop))\n    (setm y (transit-pop))\n    (transit-push y)\n    (transit-push x)\n    (transit-push (+ x y))\n    (ret (+ x y))))\n\n(defun fib-transit5 ()\n  (do-monad 'transition\n    (fib-transit1)\n    (fib-transit1)\n    (fib-transit1)\n    (fib-transit1)\n    (fib-transit1)))\n\n(run-transit (fib-transit5) '(1 1))\n;; -> #S(TRANSITED-RESULT :VALUE 13 :STATE (13 8 5 3 2 1 1))\n```\n\n## \u30e2\u30ca\u30c7\u30a3\u30c3\u30afParsec\u307d\u3044\u306e\n\n\u8aac\u660e\u3059\u3093\u306e\u30c0\u30eb\u304f\u306a\u3063\u3066\u304d\u305f...\n\n```cl\n ;; parser \n(defstruct (parser (:constructor parser (proc)))\n  proc)\n\n(defun parse (parser text)\n  (funcall (parser-proc parser) text))\n\n(defstruct (parse-result (:constructor parse-result (value text)))\n  value text)\n\n(defstruct (failed-result (:constructor failed-result (msg)))\n  msg)\n\n(defmethod ret ((type (eql 'parser)) x) \n  (parser \n   (lambda (text)\n     (parse-result x text))))\n\n(defmethod bind ((parser parser) proc-returning-parser)\n  (parser\n   (lambda (text)\n     (let ((parse-result \n\t    (parse parser text)))\n       (match parse-result\n\t ((failed-result :msg _)\n\t  parse-result)\n\t ((parse-result :value value :text text)\n\t  (let ((new-parser \n\t\t (funcall proc-returning-parser value)))\n\t    (parse new-parser text))))))))\n\n(defun item ()\n  (parser \n   (lambda (text)\n     (if (string= text \"\")\n\t (failed-result \"getiing text error\")\n\t (parse-result (subseq text 0 1)\n\t\t       (subseq text 1 \n\t\t\t       (length text)))))))\n\n(defun failure (msg)\n  (parser (lambda (text)\n\t    (declare (ignore text))\n\t    (failed-result msg))))\n\n(defun spaces ()\n  (parser (lambda (text)\n\t    (parse-result nil (front-space-delete text)))))\n\n(defun front-space-delete (text)\n  (let ((result \n\t (position-if-not (lambda (s) (string= s \" \")) text)))\n    (if result\n\t(subseq text result (length text)) \n\t\"\")))\n\n(defun number ()\n  (do-monad 'parser\n    (setm c (item))\n    (if (find c \"1234567890\" :test #'string=)\n\t(ret (parse-integer c))\n\t(failure \"not number\"))))\n\n(defun eof ()\n  (parser\n   (lambda (text)\n     (if (string= text \"\")\n\t (parse-result nil \"\")\n\t (failed-result \"not end\")))))\n\n(defun plus ()\n  (do-monad 'parser\n    (setm c (item))\n    (if (string= c \"+\")\n\t(ret t)\n\t(failure \"not + at plus\"))))\n\n(defun my-parser1 ()\n  (do-monad 'parser\n    (spaces)\n    (setm x (number))\n    (spaces)\n    (plus)\n    (spaces)\n    (setm y (number))\n    (spaces)\n    (ret (+ x y))))\n\n(parse (my-parser1) \"1 + 1\")\n;; -> #S(PARSE-RESULT :VALUE 2 :TEXT \"\")\n```\n\n## \u8ab2\u984c\n\n* lifting\u3001\u30e2\u30ca\u30c9\u5909\u63db\u5b50\u306e\u5b9f\u88c5\n* do\u8a18\u6cd5\u306e\u3001\u6587\u8108\u6307\u5b9a\u3092\u7121\u304f\u3059\u3002(\u95a2\u6570\u3088\u308a\u3001\u624b\u7d9a\u304d\u306e\u3068\u3057\u3066\u8003\u3048\u305f\u3089\u53ef\u80fd?)\n"}