{"tags": ["AVR"], "context": " More than 1 year has passed since last update.Here is my hardware and software design of a dual function decoder for DCC, model train digital command control. The assumed usage is to control LEDs.\n\nABSTRACT\n\nMicroprocessor: Atmel 8-bit AVR ATtiny10: 1024 bytes flash. 32 bytes SRAM. No EEPROM.\nPartial conformance with NMRA's DCC standards. Functionality of F0, FL in NMRA, follows Digitrax's behavior.\nRecords the time of DCC signal edges on the PB1 pin using the Input Capture Unit of 16-bit Timer/Counter0.\nToggles the level of the PB0 and PB3 pins to control the LED intensities by PWM. Output Compare Unit of 16-bit Timer/Counter0 is used for this functionality. The processor's own PWM capability is not used because one of the two PWM available pins is overlapped with the Input Capture Pin.\n\n\nCIRCUIT\n\n\nCODE\nBuild environment:\n\nAtmel Studio 6 (Version: 6.1.2730 - Service Pack 2)\nAtmel AVR 8-bit GNU Toolchain - 3.4.3.1072 (gcc-4.8.1)\n\nBuild result:\n\nProgram Memory Usage : 1022 bytes 99.8 % Full\nData Memory Usage : 12 bytes 37.5 % Full\n\n/*\n    Copyright (C) 2014 Takuya Nishida\n\n    Permission is hereby granted, free of charge, to any person obtaining a copy\n    of this software and associated documentation files (the \"Software\"), to deal\n    in the Software without restriction, including without limitation the rights\n    to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n    copies of the Software, and to permit persons to whom the Software is\n    furnished to do so, subject to the following conditions:\n\n    The above copyright notice and this permission notice shall be included in\n    all copies or substantial portions of the Software.\n\n    THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n    THE SOFTWARE.\n*/\n\n#define F_CPU 8000000UL\n\n#include <avr/io.h>\n#include <avr/interrupt.h>\n#include <avr/sleep.h>\n\n// Configuration Values\n\n#define DECODER_ADDRESS 0003\n#define FUNCTION_A_0_4_1 0b00001\n#define FUNCTION_A_12_5 0b00000000\n#define FUNCTION_B_0_4_1 0b00100\n#define FUNCTION_B_12_5 0b00000000\n#define INTENSITY_A 0x8000\n#define INTENSITY_B 0x8000\n#define SWITCHING_RATE_A 0x0100\n#define SWITCHING_RATE_B 0x0800\n\n// Constants\n\n#define PORTB_BIT_A _BV(0)\n#define PORTB_BIT_B _BV(2)\n#define FLAGS_BIT_0_ACCEPTED _BV(0)\n#define FLAGS_BIT_1_ACCEPTED _BV(1)\n#define FLAGS_DATA_BYTES_START_OR_END _BV(2)\n#define FLAGS_FORWARD _BV(3)\n#define MAX_PACKET_BYTES 4\n#define INVALID_BIT_INDEX (8 * MAX_PACKET_BYTES)\n#define INPUT_CAPTURE_PRESCALE 2\n\n// Do not initialize variables with values except for zero\n// in order to eliminate the setup code for the data memory.\n\nstatic unsigned short lastEdgeTime;\nstatic unsigned char flags;\nstatic unsigned char timerOverflown;\nstatic unsigned char continuous1;\nstatic unsigned char bitIndex;\nstatic unsigned char packet[MAX_PACKET_BYTES];\nstatic unsigned char functions0_4_1;\nstatic unsigned char functions12_5;\n\n// Maximum stack usage is 13 bytes. Check .lss to count PUSHes.\n\nint main(void)\n{\n    // System clock division factor = 1\n    CCP = 0xD8;\n    CLKPSR = 0x00;\n    // Analog comparator disabled\n    ACSR = _BV(ACD);\n    // Shut down ADC\n    PRR = _BV(PRADC);\n    // In the case of power loss, the level of RESET remains HIGH because of\n    // the capacitor. Meanwhile, Vcc becomes lower to the level that\n    // the processor becomes unstable.\n    // VLM causes reset interrupt if Vcc level becomes lower than VLM1L, 1.4V.\n    VLMCSR = _BV(VLMIE) | _BV(VLM0);\n    // Input capture noise canceler activated. Timer not prescaled\n    TCCR0B = _BV(ICNC0) | _BV(CS00);\n    // Interrupts enabled\n    TIMSK0 = _BV(ICIE0) | _BV(TOIE0) | _BV(OCIE0A) | _BV(OCIE0B);\n    // Data direction\n    DDRB = PORTB_BIT_A | PORTB_BIT_B;\n    // In the idle mode, CLKio is still active to drive the timer\n    set_sleep_mode(SLEEP_MODE_IDLE);\n    // Initialize variables\n    bitIndex = INVALID_BIT_INDEX;\n    // Start the loop\n    sei();\n    sleep_enable();\n    for (;;) {\n        sleep_cpu();\n    }\n    return 0;\n}\n\nISR(TIM0_CAPT_vect) {\n    unsigned char f = flags; // Copy to a local variable to reduce the data memory access\n    // Scale by 2 to accept the longest legitimate duration for bit 0\n    unsigned short edgeTime = ICR0 >> 1;\n    if (timerOverflown & 0x01) {\n        edgeTime |= 0x8000;\n    }\n    unsigned short duration = edgeTime - lastEdgeTime;\n    lastEdgeTime = edgeTime;\n    if (duration >= (unsigned short)(52L * F_CPU / 1000000L / INPUT_CAPTURE_PRESCALE) &&\n        duration <= (unsigned short)(64L * F_CPU / 1000000L / INPUT_CAPTURE_PRESCALE)) {\n        // Edge for a bit 1 detected\n        f &= ~FLAGS_BIT_0_ACCEPTED;\n        f ^= FLAGS_BIT_1_ACCEPTED;\n        // Check if it is the second edge\n        if (!(f & FLAGS_BIT_1_ACCEPTED)) {\n            if (f & FLAGS_DATA_BYTES_START_OR_END) {\n                // Date Byte End Bit detected\n                f &= ~FLAGS_DATA_BYTES_START_OR_END;\n                // Ignore the Error Detection Data Byte to save the code size\n                // Extract the address and instruction\n                union {\n                    unsigned short s;\n                    unsigned char ch[2];\n                } address;\n                unsigned char instruction;\n                unsigned char p0 = packet[0], p1 = packet[1], p2 = packet[2];\n                if (/*p0 != 0xFF && */(p0 & 0xC0) == 0xC0) { // omit checking broadcast to save the code size\n                    address.ch[1] = p0 & 0x3F; // MSB\n                    address.ch[0] = p1; // LSB\n                    instruction = p2;\n                } else {\n                    address.s = (unsigned short)p0;\n                    instruction = p1;\n                }\n                // Update variables according to the instruction\n                if (address.s == DECODER_ADDRESS) {\n                    switch (instruction & 0xE0) {\n                    case 0x80:\n                        functions0_4_1 = instruction & 0x1F;\n                        break;\n                    case 0xA0:\n                        if (instruction & 0x10) {\n                            functions12_5 = (functions12_5 & 0xF0) | (instruction & 0x0F);\n                        } else {\n                            functions12_5 = (functions12_5 & 0x0F) | (instruction << 4);\n                        }\n                        break;\n                    case 0x40:\n                        f &= ~FLAGS_FORWARD;\n                        break;\n                    case 0x60:\n                        f |= FLAGS_FORWARD;\n                        break;\n                    }\n                }\n                bitIndex = INVALID_BIT_INDEX;\n            } else if (bitIndex != INVALID_BIT_INDEX) {\n                // Received a bit of the packet\n                packet[bitIndex / 8] |= (1 << (7 - (bitIndex % 8)));\n                ++bitIndex;\n                if (bitIndex % 8 == 0) {\n                    f |= FLAGS_DATA_BYTES_START_OR_END;\n                }\n            }\n            // Wait for the preamble\n            if (continuous1 < 0x80) { // must be 0x80 to generate SBRC Rd, 7\n                ++continuous1;\n            }\n        }\n    } else if (duration >= (unsigned short)(90L * F_CPU / 1000000L / INPUT_CAPTURE_PRESCALE) &&\n        duration <= (unsigned short)(10000L * F_CPU / 1000000L / INPUT_CAPTURE_PRESCALE)) {\n        // Edge for a bit 0 detected\n        f &= ~FLAGS_BIT_1_ACCEPTED;\n        f ^= FLAGS_BIT_0_ACCEPTED;\n        // Check if it is the second edge\n        if (!(f & FLAGS_BIT_0_ACCEPTED)) {\n            if (f & FLAGS_DATA_BYTES_START_OR_END) {\n                // Date Byte Start Bit detected\n                f &= ~FLAGS_DATA_BYTES_START_OR_END;\n            } else if (bitIndex != INVALID_BIT_INDEX) {\n                // Received a bit of the packet\n                packet[bitIndex / 8] &= ~(1 << (7 - (bitIndex % 8)));\n                ++bitIndex;\n                if (bitIndex % 8 == 0) {\n                    f |= FLAGS_DATA_BYTES_START_OR_END;\n                }\n            }\n            // Check if it is the end of preamble\n            if (continuous1 > 12) {\n                bitIndex = 0;\n                f &= ~FLAGS_DATA_BYTES_START_OR_END;\n            }\n            continuous1 = 0;\n        }\n    } else {\n        // Clear the states in case of invalid duration\n        f &= ~(FLAGS_BIT_0_ACCEPTED | FLAGS_BIT_1_ACCEPTED);\n        bitIndex = INVALID_BIT_INDEX;\n        continuous1 = 0;\n    }\n    flags = f;\n    // Next time, we want an opposite edge.\n    TCCR0B ^= _BV(ICES0);\n}\n\nISR(TIM0_OVF_vect) {\n    // Count the pseudo MSByte of the timer.\n    // MSBit is saturated after 0x80 * 0x10000 Timer0 clocks, 1.04 sec.\n    timerOverflown = (timerOverflown + 1) | (timerOverflown & 0x80);\n    // Adjust each pulse width according to the function status\n    if ((functions0_4_1 & (!(flags & FLAGS_FORWARD) ? 0xEF : 0xFF) & FUNCTION_A_0_4_1) ||\n        (functions12_5 & FUNCTION_A_12_5)) {\n        if (INTENSITY_A - OCR0A < SWITCHING_RATE_A || !(timerOverflown & 0x80)) {\n            // In case of power loss, intensity is immediately restored.\n            OCR0A = INTENSITY_A;\n        } else {\n            OCR0A += SWITCHING_RATE_A;\n        }\n    } else {\n        if (OCR0A < SWITCHING_RATE_A) {\n            OCR0A = 0;\n        } else {\n            OCR0A -= SWITCHING_RATE_A;\n        }\n    }\n    if ((functions0_4_1 & ((flags & FLAGS_FORWARD) ? 0xEF : 0xFF) & FUNCTION_B_0_4_1) ||\n        (functions12_5 & FUNCTION_B_12_5)) {\n        if (INTENSITY_B - OCR0B < SWITCHING_RATE_B || !(timerOverflown & 0x80)) {\n            // In case of power loss, intensity is immediately restored.\n            OCR0B = INTENSITY_B;\n        } else {\n            OCR0B += SWITCHING_RATE_B;\n        }\n    } else {\n        if (OCR0B < SWITCHING_RATE_B) {\n            OCR0B = 0;\n        } else {\n            OCR0B -= SWITCHING_RATE_B;\n        }\n    }\n    // Do not set HIGH when the pulse width is zero.\n    if (OCR0A > 0) {\n        PORTB |= PORTB_BIT_A;\n    }\n    if (OCR0B > 0) {\n        PORTB |= PORTB_BIT_B;\n    }\n}\n\nISR(TIM0_COMPA_vect) {\n    // If OCR0 is close to the max value,\n    // the timer could have been overflowed at this moment \n    // because the priority of this interrupt is lower than the others.\n    // So, turn off the output only if the timer is not overflowed yet.\n    if (OCR0A <= TCNT0) {\n        PORTB &= ~PORTB_BIT_A;\n    }\n}\n\nISR(TIM0_COMPB_vect) {\n    // If OCR0 is close to the max value,\n    // the timer could have been overflowed at this moment\n    // because the priority of this interrupt is lower than the others.\n    // So, turn off the output only if the timer is not overflowed yet.\n    if (OCR0B <= TCNT0) {\n        PORTB &= ~PORTB_BIT_B;\n    }\n}\n\nNOTE: I found a bug in the code above. In rare condition, it should fail to calculate the right value of the pulse width, and it leads to missing a packet. It happens because timerOverflown and ICR0 are not in sync. When the timer overflows at the same time a signal edge is detected, TIM0_CAPT_vect is called before timerOverflown is updated in TIM0_OVF_vect. \n\nAFTERTHOUGHTS\nI do not think this design is feasible for a mobile function decoder on a train. Lack of EEPROM critically limits its applications. Though there are some workarounds as follows, I would rather turn to ATtiny25, ATtiny45 or ATtiny85 instead of complicated tweaks.\n\nPros\nTiny board dimensions thanks to an ATtiny10's SOT-23 package.\n\nCons\nNot to mention a lack of features of reading/writing configuration variables, it cannot even retain the status of its functions when it loses power due to poor electrical contact between rails and wheels.\nIf sending packets from the command station repeated for all the trains, it would not be a problem. But actually it seems the command station sends packets only for the train that it has a throttle of. Therefore, it is fatal and unrecoverable that the decoder loses its status in momentary power loss.\n\nWorkarounds for cons\nThe capacitor helps a little to keep supplying the power to the processor during power loss. But from my experiment, a capacitor as large as 100uF only serves the power for around half a second.\nOr, it may be possible to let the command station to keep sending packets for all the trains.\nHow about a backup battery? Hmm, I think this is where to stop.\nHere is my hardware and software design of a dual function decoder for DCC, model train digital command control. The assumed usage is to control LEDs.\n\n# ABSTRACT\n\n- Microprocessor: Atmel 8-bit AVR ATtiny10: 1024 bytes flash. 32 bytes SRAM. No EEPROM.\n- Partial conformance with [NMRA's DCC standards](http://www.nmra.org/standards/DCC/standards_rps/DCCStds.html). Functionality of F0, FL in NMRA, follows Digitrax's behavior.\n- Records the time of DCC signal edges on the PB1 pin using the Input Capture Unit of 16-bit Timer/Counter0.\n- Toggles the level of the PB0 and PB3 pins to control the LED intensities by PWM. Output Compare Unit of 16-bit Timer/Counter0 is used for this functionality. The processor's own PWM capability is not used because one of the two PWM available pins is overlapped with the Input Capture Pin.\n\n# CIRCUIT\n\n![functiondecoder-circuit.png](https://qiita-image-store.s3.amazonaws.com/0/12670/ffa3221f-d22a-e32e-5ed3-b4461f838f9d.png)\n\n# CODE\n\nBuild environment:\n\n- Atmel Studio 6 (Version: 6.1.2730 - Service Pack 2)\n- [Atmel AVR 8-bit GNU Toolchain - 3.4.3.1072 (gcc-4.8.1)](http://www.atmel.com/tools/ATMELAVRTOOLCHAINFORWINDOWS.aspx)\n\nBuild result:\n\n- Program Memory Usage : 1022 bytes 99.8 % Full\n- Data Memory Usage : 12 bytes 37.5 % Full\n\n```c\n/*\n\tCopyright (C) 2014 Takuya Nishida\n\n\tPermission is hereby granted, free of charge, to any person obtaining a copy\n\tof this software and associated documentation files (the \"Software\"), to deal\n\tin the Software without restriction, including without limitation the rights\n\tto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n\tcopies of the Software, and to permit persons to whom the Software is\n\tfurnished to do so, subject to the following conditions:\n\n\tThe above copyright notice and this permission notice shall be included in\n\tall copies or substantial portions of the Software.\n\n\tTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n\tIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n\tFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n\tAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n\tLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n\tOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n\tTHE SOFTWARE.\n*/\n\n#define F_CPU 8000000UL\n\n#include <avr/io.h>\n#include <avr/interrupt.h>\n#include <avr/sleep.h>\n\n// Configuration Values\n\n#define DECODER_ADDRESS 0003\n#define FUNCTION_A_0_4_1 0b00001\n#define FUNCTION_A_12_5 0b00000000\n#define FUNCTION_B_0_4_1 0b00100\n#define FUNCTION_B_12_5 0b00000000\n#define INTENSITY_A 0x8000\n#define INTENSITY_B 0x8000\n#define SWITCHING_RATE_A 0x0100\n#define SWITCHING_RATE_B 0x0800\n\n// Constants\n\n#define PORTB_BIT_A _BV(0)\n#define PORTB_BIT_B _BV(2)\n#define FLAGS_BIT_0_ACCEPTED _BV(0)\n#define FLAGS_BIT_1_ACCEPTED _BV(1)\n#define FLAGS_DATA_BYTES_START_OR_END _BV(2)\n#define FLAGS_FORWARD _BV(3)\n#define MAX_PACKET_BYTES 4\n#define INVALID_BIT_INDEX (8 * MAX_PACKET_BYTES)\n#define INPUT_CAPTURE_PRESCALE 2\n\n// Do not initialize variables with values except for zero\n// in order to eliminate the setup code for the data memory.\n\nstatic unsigned short lastEdgeTime;\nstatic unsigned char flags;\nstatic unsigned char timerOverflown;\nstatic unsigned char continuous1;\nstatic unsigned char bitIndex;\nstatic unsigned char packet[MAX_PACKET_BYTES];\nstatic unsigned char functions0_4_1;\nstatic unsigned char functions12_5;\n\n// Maximum stack usage is 13 bytes. Check .lss to count PUSHes.\n\nint main(void)\n{\n\t// System clock division factor = 1\n\tCCP = 0xD8;\n\tCLKPSR = 0x00;\n\t// Analog comparator disabled\n\tACSR = _BV(ACD);\n\t// Shut down ADC\n\tPRR = _BV(PRADC);\n\t// In the case of power loss, the level of RESET remains HIGH because of\n\t// the capacitor. Meanwhile, Vcc becomes lower to the level that\n\t// the processor becomes unstable.\n\t// VLM causes reset interrupt if Vcc level becomes lower than VLM1L, 1.4V.\n\tVLMCSR = _BV(VLMIE) | _BV(VLM0);\n\t// Input capture noise canceler activated. Timer not prescaled\n\tTCCR0B = _BV(ICNC0) | _BV(CS00);\n\t// Interrupts enabled\n\tTIMSK0 = _BV(ICIE0) | _BV(TOIE0) | _BV(OCIE0A) | _BV(OCIE0B);\n\t// Data direction\n\tDDRB = PORTB_BIT_A | PORTB_BIT_B;\n\t// In the idle mode, CLKio is still active to drive the timer\n\tset_sleep_mode(SLEEP_MODE_IDLE);\n\t// Initialize variables\n\tbitIndex = INVALID_BIT_INDEX;\n\t// Start the loop\n\tsei();\n\tsleep_enable();\n\tfor (;;) {\n\t\tsleep_cpu();\n\t}\n\treturn 0;\n}\n\nISR(TIM0_CAPT_vect) {\n\tunsigned char f = flags; // Copy to a local variable to reduce the data memory access\n\t// Scale by 2 to accept the longest legitimate duration for bit 0\n\tunsigned short edgeTime = ICR0 >> 1;\n\tif (timerOverflown & 0x01) {\n\t\tedgeTime |= 0x8000;\n\t}\n\tunsigned short duration = edgeTime - lastEdgeTime;\n\tlastEdgeTime = edgeTime;\n\tif (duration >= (unsigned short)(52L * F_CPU / 1000000L / INPUT_CAPTURE_PRESCALE) &&\n\t\tduration <= (unsigned short)(64L * F_CPU / 1000000L / INPUT_CAPTURE_PRESCALE)) {\n\t\t// Edge for a bit 1 detected\n\t\tf &= ~FLAGS_BIT_0_ACCEPTED;\n\t\tf ^= FLAGS_BIT_1_ACCEPTED;\n\t\t// Check if it is the second edge\n\t\tif (!(f & FLAGS_BIT_1_ACCEPTED)) {\n\t\t\tif (f & FLAGS_DATA_BYTES_START_OR_END) {\n\t\t\t\t// Date Byte End Bit detected\n\t\t\t\tf &= ~FLAGS_DATA_BYTES_START_OR_END;\n\t\t\t\t// Ignore the Error Detection Data Byte to save the code size\n\t\t\t\t// Extract the address and instruction\n\t\t\t\tunion {\n\t\t\t\t\tunsigned short s;\n\t\t\t\t\tunsigned char ch[2];\n\t\t\t\t} address;\n\t\t\t\tunsigned char instruction;\n\t\t\t\tunsigned char p0 = packet[0], p1 = packet[1], p2 = packet[2];\n\t\t\t\tif (/*p0 != 0xFF && */(p0 & 0xC0) == 0xC0) { // omit checking broadcast to save the code size\n\t\t\t\t\taddress.ch[1] = p0 & 0x3F; // MSB\n\t\t\t\t\taddress.ch[0] = p1; // LSB\n\t\t\t\t\tinstruction = p2;\n\t\t\t\t} else {\n\t\t\t\t\taddress.s = (unsigned short)p0;\n\t\t\t\t\tinstruction = p1;\n\t\t\t\t}\n\t\t\t\t// Update variables according to the instruction\n\t\t\t\tif (address.s == DECODER_ADDRESS) {\n\t\t\t\t\tswitch (instruction & 0xE0) {\n\t\t\t\t\tcase 0x80:\n\t\t\t\t\t\tfunctions0_4_1 = instruction & 0x1F;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 0xA0:\n\t\t\t\t\t\tif (instruction & 0x10) {\n\t\t\t\t\t\t\tfunctions12_5 = (functions12_5 & 0xF0) | (instruction & 0x0F);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tfunctions12_5 = (functions12_5 & 0x0F) | (instruction << 4);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 0x40:\n\t\t\t\t\t\tf &= ~FLAGS_FORWARD;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 0x60:\n\t\t\t\t\t\tf |= FLAGS_FORWARD;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbitIndex = INVALID_BIT_INDEX;\n\t\t\t} else if (bitIndex != INVALID_BIT_INDEX) {\n\t\t\t\t// Received a bit of the packet\n\t\t\t\tpacket[bitIndex / 8] |= (1 << (7 - (bitIndex % 8)));\n\t\t\t\t++bitIndex;\n\t\t\t\tif (bitIndex % 8 == 0) {\n\t\t\t\t\tf |= FLAGS_DATA_BYTES_START_OR_END;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Wait for the preamble\n\t\t\tif (continuous1 < 0x80) { // must be 0x80 to generate SBRC Rd, 7\n\t\t\t\t++continuous1;\n\t\t\t}\n\t\t}\n\t} else if (duration >= (unsigned short)(90L * F_CPU / 1000000L / INPUT_CAPTURE_PRESCALE) &&\n\t\tduration <= (unsigned short)(10000L * F_CPU / 1000000L / INPUT_CAPTURE_PRESCALE)) {\n\t\t// Edge for a bit 0 detected\n\t\tf &= ~FLAGS_BIT_1_ACCEPTED;\n\t\tf ^= FLAGS_BIT_0_ACCEPTED;\n\t\t// Check if it is the second edge\n\t\tif (!(f & FLAGS_BIT_0_ACCEPTED)) {\n\t\t\tif (f & FLAGS_DATA_BYTES_START_OR_END) {\n\t\t\t\t// Date Byte Start Bit detected\n\t\t\t\tf &= ~FLAGS_DATA_BYTES_START_OR_END;\n\t\t\t} else if (bitIndex != INVALID_BIT_INDEX) {\n\t\t\t\t// Received a bit of the packet\n\t\t\t\tpacket[bitIndex / 8] &= ~(1 << (7 - (bitIndex % 8)));\n\t\t\t\t++bitIndex;\n\t\t\t\tif (bitIndex % 8 == 0) {\n\t\t\t\t\tf |= FLAGS_DATA_BYTES_START_OR_END;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Check if it is the end of preamble\n\t\t\tif (continuous1 > 12) {\n\t\t\t\tbitIndex = 0;\n\t\t\t\tf &= ~FLAGS_DATA_BYTES_START_OR_END;\n\t\t\t}\n\t\t\tcontinuous1 = 0;\n\t\t}\n\t} else {\n\t\t// Clear the states in case of invalid duration\n\t\tf &= ~(FLAGS_BIT_0_ACCEPTED | FLAGS_BIT_1_ACCEPTED);\n\t\tbitIndex = INVALID_BIT_INDEX;\n\t\tcontinuous1 = 0;\n\t}\n\tflags = f;\n\t// Next time, we want an opposite edge.\n\tTCCR0B ^= _BV(ICES0);\n}\n\nISR(TIM0_OVF_vect) {\n\t// Count the pseudo MSByte of the timer.\n\t// MSBit is saturated after 0x80 * 0x10000 Timer0 clocks, 1.04 sec.\n\ttimerOverflown = (timerOverflown + 1) | (timerOverflown & 0x80);\n\t// Adjust each pulse width according to the function status\n\tif ((functions0_4_1 & (!(flags & FLAGS_FORWARD) ? 0xEF : 0xFF) & FUNCTION_A_0_4_1) ||\n\t\t(functions12_5 & FUNCTION_A_12_5)) {\n\t\tif (INTENSITY_A - OCR0A < SWITCHING_RATE_A || !(timerOverflown & 0x80)) {\n\t\t\t// In case of power loss, intensity is immediately restored.\n\t\t\tOCR0A = INTENSITY_A;\n\t\t} else {\n\t\t\tOCR0A += SWITCHING_RATE_A;\n\t\t}\n\t} else {\n\t\tif (OCR0A < SWITCHING_RATE_A) {\n\t\t\tOCR0A = 0;\n\t\t} else {\n\t\t\tOCR0A -= SWITCHING_RATE_A;\n\t\t}\n\t}\n\tif ((functions0_4_1 & ((flags & FLAGS_FORWARD) ? 0xEF : 0xFF) & FUNCTION_B_0_4_1) ||\n\t\t(functions12_5 & FUNCTION_B_12_5)) {\n\t\tif (INTENSITY_B - OCR0B < SWITCHING_RATE_B || !(timerOverflown & 0x80)) {\n\t\t\t// In case of power loss, intensity is immediately restored.\n\t\t\tOCR0B = INTENSITY_B;\n\t\t} else {\n\t\t\tOCR0B += SWITCHING_RATE_B;\n\t\t}\n\t} else {\n\t\tif (OCR0B < SWITCHING_RATE_B) {\n\t\t\tOCR0B = 0;\n\t\t} else {\n\t\t\tOCR0B -= SWITCHING_RATE_B;\n\t\t}\n\t}\n\t// Do not set HIGH when the pulse width is zero.\n\tif (OCR0A > 0) {\n\t\tPORTB |= PORTB_BIT_A;\n\t}\n\tif (OCR0B > 0) {\n\t\tPORTB |= PORTB_BIT_B;\n\t}\n}\n\nISR(TIM0_COMPA_vect) {\n\t// If OCR0 is close to the max value,\n\t// the timer could have been overflowed at this moment \n\t// because the priority of this interrupt is lower than the others.\n\t// So, turn off the output only if the timer is not overflowed yet.\n\tif (OCR0A <= TCNT0) {\n\t\tPORTB &= ~PORTB_BIT_A;\n\t}\n}\n\nISR(TIM0_COMPB_vect) {\n\t// If OCR0 is close to the max value,\n\t// the timer could have been overflowed at this moment\n\t// because the priority of this interrupt is lower than the others.\n\t// So, turn off the output only if the timer is not overflowed yet.\n\tif (OCR0B <= TCNT0) {\n\t\tPORTB &= ~PORTB_BIT_B;\n\t}\n}\n```\n\n **NOTE: I found a bug in the code above. In rare condition, it should fail to calculate the right value of the pulse width, and it leads to missing a packet. It happens because timerOverflown and ICR0 are not in sync. When the timer overflows at the same time a signal edge is detected, TIM0_CAPT_vect is called before timerOverflown is updated in TIM0_OVF_vect.** \n\n# AFTERTHOUGHTS\n\nI do not think this design is feasible for a mobile function decoder on a train. Lack of EEPROM critically limits its applications. Though there are some workarounds as follows, I would rather turn to ATtiny25, ATtiny45 or ATtiny85 instead of complicated tweaks.\n\n## Pros\n\nTiny board dimensions thanks to an ATtiny10's SOT-23 package.\n\n## Cons\n\nNot to mention a lack of features of reading/writing configuration variables, it cannot even retain the status of its functions when it loses power due to poor electrical contact between rails and wheels.\n\nIf sending packets from the command station repeated for all the trains, it would not be a problem. But actually it seems the command station sends packets only for the train that it has a throttle of. Therefore, it is fatal and unrecoverable that the decoder loses its status in momentary power loss.\n\n## Workarounds for cons\n\nThe capacitor helps a little to keep supplying the power to the processor during power loss. But from my experiment, a capacitor as large as 100uF only serves the power for around half a second.\n\nOr, it may be possible to let the command station to keep sending packets for all the trains.\n\nHow about a backup battery? Hmm, I think this is where to stop.\n"}