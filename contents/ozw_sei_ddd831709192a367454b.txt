{"context": " More than 1 year has passed since last update.\nplayhatenaauth.scala\npackage controllers\n\nimport play.api._\nimport play.api.libs.ws.WS\nimport play.api.mvc._\nimport play.api.Play.current\nimport scala.concurrent.Await\n\nobject Application extends Controller {\n  val hatenaApiKey = \"XXXXXX\"\n  val hatenaSecretKey = \"XXXXX\"\n  val hatenaCallbackUrl = \"http://localhost:9000/hatena/redirect\"\n\n  def index = Action {\n    Ok(views.html.index(hatenaUrl))\n  }\n\n  def hatenaRedirectReceiver(cert: String) = Action {\n    val requestAuthUrl = \"http://auth.hatena.ne.jp/api/auth.json\"\n\n    val params = Map(\"api_key\" -> hatenaApiKey, \"cert\" -> cert, \"api_sig\" -> buildSignature(Some(cert)))\n    val url = requestAuthUrl + params.map(p => p._1 + \"=\" + p._2).mkString(\"?\", \"&\", \"\")\n    import scala.concurrent.duration._\n    Ok(Await.result(WS.url(url).get, 10.second).json)\n  }\n\n  private def hatenaUrl = {\n    val sig = buildSignature()\n    val url = s\"http://auth.hatena.ne.jp/auth?api_key=${hatenaApiKey}&api_sig=${sig}\"\n    Logger.info(s\"\u306f\u3066\u306a\u306b\u30ea\u30af\u30a8\u30b9\u30c8\u3059\u308burl request_url:${url}\")\n    url\n  }\n\n  private def buildSignature(cert: Option[String] = None): String = {\n    cert match {\n      case Some(c) =>\n        val hashedPassword = s\"${hatenaSecretKey + \"api_key\" + hatenaApiKey + \"cert\" + c}\"\n        encrypt(hashedPassword)\n\n      case None =>\n        val hashedPassword = s\"${hatenaSecretKey + \"api_key\" + hatenaApiKey}\"\n        encrypt(hashedPassword)\n    }\n  }\n\n  private def encrypt(code: String): String = {\n    import java.security.MessageDigest\n    val digestedBytes = MessageDigest.getInstance(\"MD5\").digest(code.getBytes)\n    digestedBytes.map(\"%02x\".format(_)).mkString\n  }\n}\n\n\n\n\n```playhatenaauth.scala\npackage controllers\n\nimport play.api._\nimport play.api.libs.ws.WS\nimport play.api.mvc._\nimport play.api.Play.current\nimport scala.concurrent.Await\n\nobject Application extends Controller {\n  val hatenaApiKey = \"XXXXXX\"\n  val hatenaSecretKey = \"XXXXX\"\n  val hatenaCallbackUrl = \"http://localhost:9000/hatena/redirect\"\n\n  def index = Action {\n    Ok(views.html.index(hatenaUrl))\n  }\n\n  def hatenaRedirectReceiver(cert: String) = Action {\n    val requestAuthUrl = \"http://auth.hatena.ne.jp/api/auth.json\"\n\n    val params = Map(\"api_key\" -> hatenaApiKey, \"cert\" -> cert, \"api_sig\" -> buildSignature(Some(cert)))\n    val url = requestAuthUrl + params.map(p => p._1 + \"=\" + p._2).mkString(\"?\", \"&\", \"\")\n    import scala.concurrent.duration._\n    Ok(Await.result(WS.url(url).get, 10.second).json)\n  }\n\n  private def hatenaUrl = {\n    val sig = buildSignature()\n    val url = s\"http://auth.hatena.ne.jp/auth?api_key=${hatenaApiKey}&api_sig=${sig}\"\n    Logger.info(s\"\u306f\u3066\u306a\u306b\u30ea\u30af\u30a8\u30b9\u30c8\u3059\u308burl request_url:${url}\")\n    url\n  }\n\n  private def buildSignature(cert: Option[String] = None): String = {\n    cert match {\n      case Some(c) =>\n        val hashedPassword = s\"${hatenaSecretKey + \"api_key\" + hatenaApiKey + \"cert\" + c}\"\n        encrypt(hashedPassword)\n\n      case None =>\n        val hashedPassword = s\"${hatenaSecretKey + \"api_key\" + hatenaApiKey}\"\n        encrypt(hashedPassword)\n    }\n  }\n\n  private def encrypt(code: String): String = {\n    import java.security.MessageDigest\n    val digestedBytes = MessageDigest.getInstance(\"MD5\").digest(code.getBytes)\n    digestedBytes.map(\"%02x\".format(_)).mkString\n  }\n}\n\n```\n", "tags": ["PlayFramework", "Scala", "Play2", "Hatena", "Play"]}