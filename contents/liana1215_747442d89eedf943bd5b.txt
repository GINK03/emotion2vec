{"context": "\u65e5\u672c\u8a9e\u306f\u6bcd\u56fd\u8a9e\u3067\u306f\u7121\u3044\uff0b\u52c9\u5f37\u4e2d\u3067\u3059\u3002\u3000\u8aa4\u308a\u306e\u53ef\u80fd\u6027\u3082\u3042\u308a\u307e\u3059\u306e\u3067\u3054\u4e01\u5be7\u306b\u3054\u6307\u5c0e\u3092\u304a\u9858\u3044\u81f4\u3057\u307e\u3059\u3002\n\n\u6982\u8981\n\u30b9\u30bf\u30f3\u30d5\u30a9\u30fc\u30c9\u5927\u5b66\u767a\u4fe1\u306eMOOC\uff08\u5927\u898f\u6a21\u30aa\u30fc\u30d7\u30f3\u30aa\u30f3\u30e9\u30a4\u30f3\u8b1b\u5ea7\uff09\u3092\u3082\u3068\u306b\u3057\u305f\u554f\u984c\u306b\u6311\u6226\u3002\u3000\u5b9f\u969b\u306b\u306f\u4e0b\u8a18\u306e\u30ea\u30f3\u30af\u3092\u8fbf\u308c\u3070\u554f\u984c\u8aac\u660e\u3092\u898b\u308c\u307e\u3059\u3002\nhttps://see.stanford.edu/materials/icspacs106b/H16-Assign2ADTs.pdf\n\u30a4\u30f3\u30c8\u30ed\u7684\u306a\u5185\u5bb9\u306a\u306e\u3067\u5b9f\u88c5\u3059\u308b\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0\u306f\u6700\u9069\u3067\u306f\u306a\u3044\u3067\u3059\u304c\u3001\u79c1\u307f\u305f\u3044\u306a\u521d\u5fc3\u8005\u306b\u306f\u3061\u3087\u3046\u3069\u826f\u304b\u3063\u305f\u3067\u3059\u3002\u3000\u6539\u5584\u3059\u308b\u53ef\u80fd\u6027\u306f\u3044\u304f\u3089\u3067\u3082\u3042\u308a\u3001\u3055\u3089\u306a\u308b\u8ab2\u984c\u306b\u3082\u7e4b\u3052\u3089\u308c\u307e\u3059\u3002\n\u6ce8\u610f\u70b9\u3068\u3057\u3066\u306f\u3001\u5b9f\u969b\u306b\u53d7\u3051\u308b\u751f\u5f92\u306f\u6559\u6388\u304c\u63d0\u4f9b\u3057\u3066\u304f\u308c\u308b\u3042\u3089\u3086\u308b\u306aADT\uff08\u62bd\u8c61\u30c7\u30fc\u30bf\u578b\uff09\u306b\u30a2\u30af\u30bb\u30b9\u304c\u53ef\u80fd\u3067\u3042\u308a\u3001\u5916\u90e8\u306e\u4eba\u306f\u591a\u5c11\u8ffd\u52a0\u3067\u30a4\u30f3\u30d7\u30ea\u30e1\u30f3\u30c6\u30fc\u30b7\u30e7\u30f3\u3092\u5de5\u592b\u3059\u308b\u5fc5\u8981\u304c\u3042\u308a\u307e\u3059\u3002\u3000\u500b\u4eba\u7684\u306b\u306f\u307b\u307cvector\u30b3\u30f3\u30c6\u30ca\u306e\u307f\u3067\u5b8c\u6210\u3002\n\nAldous-Broder \u30a2\u30eb\u30b4\u30ea\u30ba\u30e0\n\u5b9f\u88c5\u3057\u305f\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0\u306fAldous-Broder\u3067\u3001\u3056\u3063\u304f\u308a\u5185\u5bb9\u3092\u8aac\u660e\u3059\u308b\u3068\uff1a\n1. \u3059\u3079\u3066\u306e\u30bb\u30eb\u306f'excluded'\u3068\u59cb\u3081\u307e\u305a\u306f\u30e9\u30f3\u30c0\u30e0\u306b\u3042\u308b\u30bb\u30eb\u3092\u9078\u3073'included'\u3068\u3057\u3066\u30de\u30fc\u30af\u3002\u3000\u3055\u3089\u306b'current'\u3068\u3057\u3066\u6271\u3046\u3002\n2. \u30bb\u30eb\u306e\u5468\u8fba\uff08\u659c\u3081\u306f\u7121\u8996\uff09\u306b\u3042\u308b\u30bb\u30eb\u3092\u30e9\u30f3\u30c0\u30e0\u306b\u9078\u3073\u3001'excluded'\u3067\u3042\u308c\u3070\u30bb\u30eb\u3068\u30bb\u30eb\u306e\u9593\u306e\u58c1\u3092\u6d88\u3057\u3001\u9078\u3093\u3060\u30bb\u30eb\u306e\u30b9\u30c6\u30fc\u30bf\u30b9\u3092'include'\u306b\u63db\u3048\u308b\u3002\n3. \u9078\u3093\u3060\u30bb\u30eb\u306f\u65b0\u305f\u306a'current'\u3068\u3057\u3066\u6271\u3046\u3002\n4. \u3059\u3079\u3066\u306e\u30bb\u30eb\u304c'include'\u3055\u308c\u308b\u307e\u30671-3\u3092\u5b9f\u65bd\n\u5229\u70b9\u306f\u5206\u304b\u308a\u3084\u3059\u3044\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0\u3067\u3042\u308a\u307e\u3059\u304c\u3001\u904b\u304c\u60aa\u3051\u308c\u3070\u5927\u5909\u975e\u52b9\u7387\u3068\u3082\u8a00\u308f\u308c\u3066\u308b\u3088\u3046\u3067\u3059\u3002\u30bb\u30eb\u306e\u6570\u304c\u5897\u3048\u308c\u3070\u5897\u3048\u308b\u307b\u3069\u6700\u5f8c\u306e\u30bb\u30eb\u3092'include'\u3059\u308b\u306e\u306b\u975e\u5e38\u306b\u6642\u9593\u304c\u304b\u304b\u308b\u53ef\u80fd\u6027\u3082\u3042\u308b\u3068\u306e\u3053\u3068\u3067\u3059\u3002 \u500b\u4eba\u7684\u306b\u306f\u6570\u5b66\u529b\u304c\u4e0d\u8db3\u3057\u3066\u308b\u3053\u3068\u3067\u7406\u89e3\u3067\u304d\u3066\u304a\u3089\u305a\u3067\u3059\u304c\u3001\u6570\u5b66\u306b\u5f37\u3044\u65b9\u306f\u3000Generating Random Spanning Trees by Andrei Broder \u306e\u8ad6\u6587\u306b\u6311\u6226\u3057\u3066\u304f\u3060\u3055\u3044\u3002\n\n\u5b9f\u88c5\n\u4e0a\u8a18\u306e1-4\u306b\u305d\u3063\u3066\u5de5\u592b\u3057\u306a\u304c\u3089\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0\u3092\u5b9f\u65bd\u3002\u3000\n\u6ce8\u610f\u70b9\uff1a\n1. \u79c1\u306e\u4f8b\u306f\u58c1\u3092\u6d88\u3059\u306e\u3067\u306a\u304f\u30c1\u30e3\u30f3\u30cd\u30eb\uff08\u30bb\u30eb\u3068\u30bb\u30eb\u306e\u9593\u306e\u30d1\u30b9\uff09\u3092\u8ffd\u52a0\u3002\u3000\n2. runAldousBroder\u30e1\u30bd\u30c3\u30c9\u306f\u3001parameter\u3068\u3057\u3066\u308f\u305f\u3059maze\u306e\u5b9a\u7fa9\u306b\u304b\u3051\u307e\u3059\u3002\n\u5fc5\u8981\u3068\u3055\u308c\u308b\u30d8\u30c3\u30c0\u30fc\u30d5\u30a1\u30a4\u30eb\u3002\u3000\n#include <iostream>\n#include <algorithm>\n#include <vector>\n\n\u30bb\u30eb\u3068\u30c1\u30e3\u30f3\u30cd\u30eb\u306f\u4e0b\u8a18\u3069\u3046\u308a\u306b\u5b9a\u7fa9\u3002\u3000\nstruct Cell {\n    uint32_t row;\n    uint32_t col;\n};\n\nstruct Channel {\n    Cell src;\n    Cell dst;\n};\n\nAldous-Broder \u30a2\u30eb\u30b4\u30ea\u30ba\u30e0\u3092\u5b9f\u88c5\u3002\u3000\u4e0a\u8a18\u3067\u5b9a\u7fa9\u3055\u308c\u305fChannel\u578b\u306evector\u30b3\u30f3\u30c6\u30ca\u304c\u30ea\u30bf\u30fc\u30f3\u3055\u308c\u308b\u3002\nstd::vector<Channel>\nrunAldousBroder(std::vector<std::vector<std::vector<uint32_t>>> & maze)\n{\n    std::random_device rd;\n    std::mt19937 gen(rd());\n    uint32_t maze_size = maze.size();\n    std::uniform_int_distribution<> dist(0,maze_size-1);\n    std::uniform_int_distribution<> neighbor(0,3);\n    std::vector<std::vector<uint32_t>> visited(maze_size,\n                                               std::vector<uint32_t>(maze_size));\n    std::vector<Channel> channels;\n\n    uint32_t r         = dist(gen);\n    uint32_t c         = dist(gen);\n    visited[r][c]      = 1;                              //mark initial point as visited     \n    uint32_t remaining = maze_size * maze_size - 1;\n    int count          = 0;\n\n    while (remaining > 0) {\n        uint32_t n_index = neighbor(gen);\n        Cell neighbor_cell;\n        while(!checkNeighborExists(maze, r, c, n_index)) {\n            n_index = neighbor(gen);\n        }\n        neighbor_cell = getNeigborLocation(r,c,n_index);\n        if (!visited[neighbor_cell.row][neighbor_cell.col]) {\n            Channel channel;\n            channel.src.row = r;\n            channel.src.col = c;\n            channel.dst.row = neighbor_cell.row;\n            channel.dst.col = neighbor_cell.col;\n            channels.push_back(channel);                 //add channel to vector of channels\n\n            visited[neighbor_cell.row][neighbor_cell.col] = 1;\n            remaining--;\n        }\n        r = neighbor_cell.row;\n        c = neighbor_cell.col;\n\n        count++;\n    }\n    for (int i = 0; i < channels.size(); i++) {\n        std::cout << channels[i].src.row << \",\" << channels[i].src.col << \" -> \"\n                  << channels[i].dst.row << \",\" << channels[i].dst.col << std::endl;\n    }\n    std::cout << \"Steps taken to construct maze: \" << count << std::endl;\n    return channels;\n} \n\n\u8ffd\u52a0\u3067\u5fc5\u8981\u3068\u3055\u308c\u308b\u30e1\u30bd\u30c3\u30c9\u3002\nbool\ncheckNeighborExists(std::vector<std::vector<std::vector<uint32_t>>> const maze,\n                    uint32_t r, uint32_t c, uint32_t n_index)\n{\n    return maze[r][c][n_index];\n}\n\n\nCell\ngetNeigborLocation(uint32_t r, uint32_t c, uint32_t index)\n{\n    uint32_t r_n = r;\n    uint32_t c_n = c;\n    Cell n;\n\n    switch (index) {\n        case 0: r_n = r - 1; break;\n        case 1: c_n = c + 1; break;\n        case 2: r_n = r + 1; break;\n        case 3: c_n = c - 1; break;\n    }\n    n.row = r_n;\n    n.col = c_n;\n    return n;\n}\n\nGithub: \u5b8c\u6210\u3057\u305f\u30bd\u30fc\u30b9\n\u7d50\u679c\u306f\u4e0b\u8a18\u3069\u3046\u308a\u3067\u540c\u3058\u5927\u304d\u3055\u30672\u56de\u5b9f\u65bd\u3002\n\u4f8b1:\nInput size of maze: 3\n1,1 -> 1,0\n1,0 -> 0,0\n0,0 -> 0,1\n0,1 -> 0,2\n0,2 -> 1,2\n1,2 -> 2,2\n2,2 -> 2,1\n2,1 -> 2,0\nSteps taken to construct maze: 38\n\n\u4f8b2:\nInput size of maze: 3\n0,0 -> 0,1\n0,1 -> 1,1\n1,1 -> 1,2\n1,2 -> 2,2\n2,2 -> 2,1\n2,1 -> 2,0\n2,0 -> 1,0\n1,2 -> 0,2\nSteps taken to construct maze: 62\n\n\n\u6b21\u56de\n\nGraphics\u3092\u52a0\u3048\u308b\u3002\n\u4f5c\u6210\u3057\u305f\u8ff7\u8def\u3092\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0\u3067solve\u3059\u308b\u3002\n\n\u65e5\u672c\u8a9e\u306f\u6bcd\u56fd\u8a9e\u3067\u306f\u7121\u3044\uff0b\u52c9\u5f37\u4e2d\u3067\u3059\u3002\u3000\u8aa4\u308a\u306e\u53ef\u80fd\u6027\u3082\u3042\u308a\u307e\u3059\u306e\u3067\u3054\u4e01\u5be7\u306b\u3054\u6307\u5c0e\u3092\u304a\u9858\u3044\u81f4\u3057\u307e\u3059\u3002\n\n#\u6982\u8981\n\u30b9\u30bf\u30f3\u30d5\u30a9\u30fc\u30c9\u5927\u5b66\u767a\u4fe1\u306eMOOC\uff08\u5927\u898f\u6a21\u30aa\u30fc\u30d7\u30f3\u30aa\u30f3\u30e9\u30a4\u30f3\u8b1b\u5ea7\uff09\u3092\u3082\u3068\u306b\u3057\u305f\u554f\u984c\u306b\u6311\u6226\u3002\u3000\u5b9f\u969b\u306b\u306f\u4e0b\u8a18\u306e\u30ea\u30f3\u30af\u3092\u8fbf\u308c\u3070\u554f\u984c\u8aac\u660e\u3092\u898b\u308c\u307e\u3059\u3002\n\nhttps://see.stanford.edu/materials/icspacs106b/H16-Assign2ADTs.pdf\n\n\u30a4\u30f3\u30c8\u30ed\u7684\u306a\u5185\u5bb9\u306a\u306e\u3067\u5b9f\u88c5\u3059\u308b\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0\u306f\u6700\u9069\u3067\u306f\u306a\u3044\u3067\u3059\u304c\u3001\u79c1\u307f\u305f\u3044\u306a\u521d\u5fc3\u8005\u306b\u306f\u3061\u3087\u3046\u3069\u826f\u304b\u3063\u305f\u3067\u3059\u3002\u3000\u6539\u5584\u3059\u308b\u53ef\u80fd\u6027\u306f\u3044\u304f\u3089\u3067\u3082\u3042\u308a\u3001\u3055\u3089\u306a\u308b\u8ab2\u984c\u306b\u3082\u7e4b\u3052\u3089\u308c\u307e\u3059\u3002\n\n\u6ce8\u610f\u70b9\u3068\u3057\u3066\u306f\u3001\u5b9f\u969b\u306b\u53d7\u3051\u308b\u751f\u5f92\u306f\u6559\u6388\u304c\u63d0\u4f9b\u3057\u3066\u304f\u308c\u308b\u3042\u3089\u3086\u308b\u306aADT\uff08\u62bd\u8c61\u30c7\u30fc\u30bf\u578b\uff09\u306b\u30a2\u30af\u30bb\u30b9\u304c\u53ef\u80fd\u3067\u3042\u308a\u3001\u5916\u90e8\u306e\u4eba\u306f\u591a\u5c11\u8ffd\u52a0\u3067\u30a4\u30f3\u30d7\u30ea\u30e1\u30f3\u30c6\u30fc\u30b7\u30e7\u30f3\u3092\u5de5\u592b\u3059\u308b\u5fc5\u8981\u304c\u3042\u308a\u307e\u3059\u3002\u3000\u500b\u4eba\u7684\u306b\u306f\u307b\u307cvector\u30b3\u30f3\u30c6\u30ca\u306e\u307f\u3067\u5b8c\u6210\u3002\n\n#Aldous-Broder \u30a2\u30eb\u30b4\u30ea\u30ba\u30e0\n\u5b9f\u88c5\u3057\u305f\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0\u306fAldous-Broder\u3067\u3001\u3056\u3063\u304f\u308a\u5185\u5bb9\u3092\u8aac\u660e\u3059\u308b\u3068\uff1a\n1. \u3059\u3079\u3066\u306e\u30bb\u30eb\u306f'excluded'\u3068\u59cb\u3081\u307e\u305a\u306f\u30e9\u30f3\u30c0\u30e0\u306b\u3042\u308b\u30bb\u30eb\u3092\u9078\u3073'included'\u3068\u3057\u3066\u30de\u30fc\u30af\u3002\u3000\u3055\u3089\u306b'current'\u3068\u3057\u3066\u6271\u3046\u3002\n2. \u30bb\u30eb\u306e\u5468\u8fba\uff08\u659c\u3081\u306f\u7121\u8996\uff09\u306b\u3042\u308b\u30bb\u30eb\u3092\u30e9\u30f3\u30c0\u30e0\u306b\u9078\u3073\u3001'excluded'\u3067\u3042\u308c\u3070\u30bb\u30eb\u3068\u30bb\u30eb\u306e\u9593\u306e\u58c1\u3092\u6d88\u3057\u3001\u9078\u3093\u3060\u30bb\u30eb\u306e\u30b9\u30c6\u30fc\u30bf\u30b9\u3092'include'\u306b\u63db\u3048\u308b\u3002\n3. \u9078\u3093\u3060\u30bb\u30eb\u306f\u65b0\u305f\u306a'current'\u3068\u3057\u3066\u6271\u3046\u3002\n4. \u3059\u3079\u3066\u306e\u30bb\u30eb\u304c'include'\u3055\u308c\u308b\u307e\u30671-3\u3092\u5b9f\u65bd\n\n\u5229\u70b9\u306f\u5206\u304b\u308a\u3084\u3059\u3044\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0\u3067\u3042\u308a\u307e\u3059\u304c\u3001\u904b\u304c\u60aa\u3051\u308c\u3070\u5927\u5909\u975e\u52b9\u7387\u3068\u3082\u8a00\u308f\u308c\u3066\u308b\u3088\u3046\u3067\u3059\u3002\u30bb\u30eb\u306e\u6570\u304c\u5897\u3048\u308c\u3070\u5897\u3048\u308b\u307b\u3069\u6700\u5f8c\u306e\u30bb\u30eb\u3092'include'\u3059\u308b\u306e\u306b\u975e\u5e38\u306b\u6642\u9593\u304c\u304b\u304b\u308b\u53ef\u80fd\u6027\u3082\u3042\u308b\u3068\u306e\u3053\u3068\u3067\u3059\u3002 \u500b\u4eba\u7684\u306b\u306f\u6570\u5b66\u529b\u304c\u4e0d\u8db3\u3057\u3066\u308b\u3053\u3068\u3067\u7406\u89e3\u3067\u304d\u3066\u304a\u3089\u305a\u3067\u3059\u304c\u3001\u6570\u5b66\u306b\u5f37\u3044\u65b9\u306f\u3000[Generating Random Spanning Trees by Andrei Broder](https://www.cs.cmu.edu/~15859n/RelatedWork/Broder-GenRanSpanningTrees.pdf) \u306e\u8ad6\u6587\u306b\u6311\u6226\u3057\u3066\u304f\u3060\u3055\u3044\u3002\n\n\n#\u5b9f\u88c5\n\n\u4e0a\u8a18\u306e1-4\u306b\u305d\u3063\u3066\u5de5\u592b\u3057\u306a\u304c\u3089\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0\u3092\u5b9f\u65bd\u3002\u3000\n\u6ce8\u610f\u70b9\uff1a\n1. \u79c1\u306e\u4f8b\u306f\u58c1\u3092\u6d88\u3059\u306e\u3067\u306a\u304f\u30c1\u30e3\u30f3\u30cd\u30eb\uff08\u30bb\u30eb\u3068\u30bb\u30eb\u306e\u9593\u306e\u30d1\u30b9\uff09\u3092\u8ffd\u52a0\u3002\u3000\n2. runAldousBroder\u30e1\u30bd\u30c3\u30c9\u306f\u3001parameter\u3068\u3057\u3066\u308f\u305f\u3059maze\u306e\u5b9a\u7fa9\u306b\u304b\u3051\u307e\u3059\u3002\n\n\n\u5fc5\u8981\u3068\u3055\u308c\u308b\u30d8\u30c3\u30c0\u30fc\u30d5\u30a1\u30a4\u30eb\u3002\u3000\n\n```cpp\n#include <iostream>\n#include <algorithm>\n#include <vector>\n```\n\n\u30bb\u30eb\u3068\u30c1\u30e3\u30f3\u30cd\u30eb\u306f\u4e0b\u8a18\u3069\u3046\u308a\u306b\u5b9a\u7fa9\u3002\u3000\n\n```cpp\nstruct Cell {\n    uint32_t row;\n    uint32_t col;\n};\n\nstruct Channel {\n    Cell src;\n    Cell dst;\n};\n```\n\nAldous-Broder \u30a2\u30eb\u30b4\u30ea\u30ba\u30e0\u3092\u5b9f\u88c5\u3002\u3000\u4e0a\u8a18\u3067\u5b9a\u7fa9\u3055\u308c\u305fChannel\u578b\u306evector\u30b3\u30f3\u30c6\u30ca\u304c\u30ea\u30bf\u30fc\u30f3\u3055\u308c\u308b\u3002\n\n```cpp\nstd::vector<Channel>\nrunAldousBroder(std::vector<std::vector<std::vector<uint32_t>>> & maze)\n{\n    std::random_device rd;\n    std::mt19937 gen(rd());\n    uint32_t maze_size = maze.size();\n    std::uniform_int_distribution<> dist(0,maze_size-1);\n    std::uniform_int_distribution<> neighbor(0,3);\n    std::vector<std::vector<uint32_t>> visited(maze_size,\n                                               std::vector<uint32_t>(maze_size));\n    std::vector<Channel> channels;\n\n    uint32_t r         = dist(gen);\n    uint32_t c         = dist(gen);\n    visited[r][c]      = 1;                              //mark initial point as visited     \n    uint32_t remaining = maze_size * maze_size - 1;\n    int count          = 0;\n\n    while (remaining > 0) {\n        uint32_t n_index = neighbor(gen);\n        Cell neighbor_cell;\n        while(!checkNeighborExists(maze, r, c, n_index)) {\n            n_index = neighbor(gen);\n        }\n        neighbor_cell = getNeigborLocation(r,c,n_index);\n        if (!visited[neighbor_cell.row][neighbor_cell.col]) {\n            Channel channel;\n            channel.src.row = r;\n            channel.src.col = c;\n            channel.dst.row = neighbor_cell.row;\n            channel.dst.col = neighbor_cell.col;\n            channels.push_back(channel);                 //add channel to vector of channels\n\n            visited[neighbor_cell.row][neighbor_cell.col] = 1;\n            remaining--;\n        }\n        r = neighbor_cell.row;\n        c = neighbor_cell.col;\n\n        count++;\n    }\n    for (int i = 0; i < channels.size(); i++) {\n        std::cout << channels[i].src.row << \",\" << channels[i].src.col << \" -> \"\n                  << channels[i].dst.row << \",\" << channels[i].dst.col << std::endl;\n    }\n    std::cout << \"Steps taken to construct maze: \" << count << std::endl;\n    return channels;\n} \n```\n\n\u8ffd\u52a0\u3067\u5fc5\u8981\u3068\u3055\u308c\u308b\u30e1\u30bd\u30c3\u30c9\u3002\n\n```cpp\nbool\ncheckNeighborExists(std::vector<std::vector<std::vector<uint32_t>>> const maze,\n                    uint32_t r, uint32_t c, uint32_t n_index)\n{\n    return maze[r][c][n_index];\n}\n\n\nCell\ngetNeigborLocation(uint32_t r, uint32_t c, uint32_t index)\n{\n    uint32_t r_n = r;\n    uint32_t c_n = c;\n    Cell n;\n\n    switch (index) {\n        case 0: r_n = r - 1; break;\n        case 1: c_n = c + 1; break;\n        case 2: r_n = r + 1; break;\n        case 3: c_n = c - 1; break;\n    }\n    n.row = r_n;\n    n.col = c_n;\n    return n;\n}\n```\n\nGithub: [\u5b8c\u6210\u3057\u305f\u30bd\u30fc\u30b9](https://github.com/liana1215/stnfd-cpp/blob/master/projects/maze-runner/build-maze.cpp)\n\n\n\u7d50\u679c\u306f\u4e0b\u8a18\u3069\u3046\u308a\u3067\u540c\u3058\u5927\u304d\u3055\u30672\u56de\u5b9f\u65bd\u3002\n\n\n\u4f8b1:\n\n```\nInput size of maze: 3\n1,1 -> 1,0\n1,0 -> 0,0\n0,0 -> 0,1\n0,1 -> 0,2\n0,2 -> 1,2\n1,2 -> 2,2\n2,2 -> 2,1\n2,1 -> 2,0\nSteps taken to construct maze: 38\n```\n\n\u4f8b2:\n\n```\nInput size of maze: 3\n0,0 -> 0,1\n0,1 -> 1,1\n1,1 -> 1,2\n1,2 -> 2,2\n2,2 -> 2,1\n2,1 -> 2,0\n2,0 -> 1,0\n1,2 -> 0,2\nSteps taken to construct maze: 62\n```\n\n#\u6b21\u56de\n1. Graphics\u3092\u52a0\u3048\u308b\u3002\n2. \u4f5c\u6210\u3057\u305f\u8ff7\u8def\u3092\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0\u3067solve\u3059\u308b\u3002\n\n\n", "tags": ["C++", "aldous-broder", "Maze", "Beginner", "MOOC"]}