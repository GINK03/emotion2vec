{"context": " More than 1 year has passed since last update.\u5fc5\u8981\u3067\u3082\u306a\u3093\u3067\u3082\u306a\u304b\u3063\u305f\u306e\u3067\u3059\u304c\u3001cl-ppcre\u306eregister-groups-bind\u3068\u3001Allegro\u306eregexp:re-lambda\u306e\u52d5\u4f5c\u306e\u9055\u3044\u3092\u8abf\u3079\u3066\u305f\u3089\u3067\u304d\u307e\u3057\u305f\u3002\u8272\u3005\u7121\u7406\u304c\u3042\u308a\u307e\u3059\u3002\n(in-package :ppcre)\n\n;;; http://www.franz.com/support/documentation/9.0/doc/operators/excl/re-lambda.htm\n\n(defun normalize-var-list-re (list)\n  ;; (var integer) -- var binds to integer-th submatch (0 for whole).\n  ;; (var string/symbol) -- var binds to the submatch named by string/symbol.\n  ;; var -- var binds to the submatch named by var.\n  (mapcar (lambda (e) (if (consp e)\n                          (list (car e) (etypecase (cadr e)\n                                          (symbol (string (cadr e)))\n                                          ((or integer string) (cadr e))))\n                          (list e (string e))))\n          list))\n\n\n(defun list-flatten (tree)\n  (let ((result '()))\n    (labels ((*scan (item)\n               (if (consp item)\n                   (map nil #'*scan item)\n                   (push item result))))\n      (*scan tree))\n    (nreverse result)))\n\n\n(defun regname-pos-alist (regex-tree)\n  ;; TODO: \u307e\u3042\u5b89\u76f4\u306bflatten\u3057\u3066\u51fa\u73fe\u3057\u305f\u9806\u756a\u3067\u3059\u308f\n  (let ((u (list-flatten regex-tree)))\n    (do ((e u (cdr e))\n         (ans '() )\n         (cnt 1))\n        ((endp e) ans)\n      (case (car e)\n        ((:named-register) \n         (push `(,(cadr e) ,cnt) ans)\n         (incf cnt))\n        ((:register :nop))))))\n\n\n(defun regpos (pos-designator alist)\n  (etypecase pos-designator\n    (integer pos-designator)\n    (string (second (assoc pos-designator alist :test #'string=)))))\n\n\n(defmacro re-lambda (regex var-list &body body\n                     &aux start end sharedp\n                          (*allow-named-registers* t)\n                          (regname.pos (regname-pos-alist (parse-string regex))))\n  (with-unique-names (match-start match-end reg-starts reg-ends\n                      start-index substr-fn target-string\n                      if-does-not-match )\n    `(lambda (,target-string\n              &key ((:if-does-not-match ,if-does-not-match) NIL))\n       (multiple-value-bind (,match-start ,match-end ,reg-starts ,reg-ends)\n                            (scan (let ((*allow-named-registers* t))\n                                    (create-scanner (parse-string ,regex)))\n                                  ,target-string :start (or ,start 0)\n                                  :end (or ,end (length ,target-string)))\n         (declare (ignore ,match-end))\n         (if ,match-start            \n             (let* ,(list*\n                     `(,substr-fn (if ,sharedp\n                                      #'nsubseq\n                                      #'subseq ))\n                     (loop :for (var pos) :in (normalize-var-list-re var-list)\n                           :when var\n                             :collect (cond ((eql 0 pos)\n                                             `(,var (funcall ,substr-fn\n                                                             ,target-string\n                                                             ,match-start\n                                                             ,match-end )))\n                                            ((setq pos (regpos pos regname.pos))\n                                             (let ((pos (1- pos)))\n                                               `(,var (let ((,start-index\n                                                             (aref ,reg-starts ,pos ) ))\n                                                        (if ,start-index\n                                                            (funcall ,substr-fn\n                                                                     ,target-string\n                                                                     ,start-index\n                                                                     (aref ,reg-ends ,pos ) )\n                                                            nil )))))\n                                            (T `(,var nil)) )))\n               ,@body )\n             ,if-does-not-match )))))\n\n(funcall (RE-LAMBDA \"(?<Z>.)(?<Z>.)(?<X>.)(?<Y>.)\" ((a 0) z x y) (LIST a z x y))\n         \"defabcz\"\n         :if-does-not-match t)\n;=>  (\"defa\" \"e\" \"f\" \"a\")\n\n\n(funcall (re-lambda \"(abc|def)(.*)\" ((a 0) (b 1) (c 2))\n           (list a b c))\n         \"defabc\")\n;=>  (\"defabc\" \"def\" \"abc\")\n\n(funcall (re-lambda \"(?<FOO>[a-z]+)(?<BAR>\\\\d+)\" (foo bar)\n           (list foo bar))\n         \"   acl70beta \")\n;=>  (\"acl\" \"70\")\n\n\n;;; \u30b5\u30dd\u30fc\u30c8\u3057\u3066\u307e\u305b\u3093\n(funcall (re-lambda \"cde\" ((a 0 :before) (b 0) (c 0 :after))\n           (list a b c))\n         \"abcdefg\")\n;=>  (\"cde\" \"cde\" \"cde\")\n\n;;; Allegro: regex2\n;=> (\"ab\" \"cde\" \"fg\")\n\n\u5fc5\u8981\u3067\u3082\u306a\u3093\u3067\u3082\u306a\u304b\u3063\u305f\u306e\u3067\u3059\u304c\u3001cl-ppcre\u306eregister-groups-bind\u3068\u3001Allegro\u306eregexp:re-lambda\u306e\u52d5\u4f5c\u306e\u9055\u3044\u3092\u8abf\u3079\u3066\u305f\u3089\u3067\u304d\u307e\u3057\u305f\u3002\u8272\u3005\u7121\u7406\u304c\u3042\u308a\u307e\u3059\u3002\n\n```cl\n(in-package :ppcre)\n\n;;; http://www.franz.com/support/documentation/9.0/doc/operators/excl/re-lambda.htm\n\n(defun normalize-var-list-re (list)\n  ;; (var integer) -- var binds to integer-th submatch (0 for whole).\n  ;; (var string/symbol) -- var binds to the submatch named by string/symbol.\n  ;; var -- var binds to the submatch named by var.\n  (mapcar (lambda (e) (if (consp e)\n                          (list (car e) (etypecase (cadr e)\n                                          (symbol (string (cadr e)))\n                                          ((or integer string) (cadr e))))\n                          (list e (string e))))\n          list))\n\n\n(defun list-flatten (tree)\n  (let ((result '()))\n    (labels ((*scan (item)\n               (if (consp item)\n                   (map nil #'*scan item)\n                   (push item result))))\n      (*scan tree))\n    (nreverse result)))\n\n\n(defun regname-pos-alist (regex-tree)\n  ;; TODO: \u307e\u3042\u5b89\u76f4\u306bflatten\u3057\u3066\u51fa\u73fe\u3057\u305f\u9806\u756a\u3067\u3059\u308f\n  (let ((u (list-flatten regex-tree)))\n    (do ((e u (cdr e))\n         (ans '() )\n         (cnt 1))\n        ((endp e) ans)\n      (case (car e)\n        ((:named-register) \n         (push `(,(cadr e) ,cnt) ans)\n         (incf cnt))\n        ((:register :nop))))))\n\n\n(defun regpos (pos-designator alist)\n  (etypecase pos-designator\n    (integer pos-designator)\n    (string (second (assoc pos-designator alist :test #'string=)))))\n\n\n(defmacro re-lambda (regex var-list &body body\n                     &aux start end sharedp\n                          (*allow-named-registers* t)\n                          (regname.pos (regname-pos-alist (parse-string regex))))\n  (with-unique-names (match-start match-end reg-starts reg-ends\n                      start-index substr-fn target-string\n                      if-does-not-match )\n    `(lambda (,target-string\n              &key ((:if-does-not-match ,if-does-not-match) NIL))\n       (multiple-value-bind (,match-start ,match-end ,reg-starts ,reg-ends)\n                            (scan (let ((*allow-named-registers* t))\n                                    (create-scanner (parse-string ,regex)))\n                                  ,target-string :start (or ,start 0)\n                                  :end (or ,end (length ,target-string)))\n         (declare (ignore ,match-end))\n         (if ,match-start            \n             (let* ,(list*\n                     `(,substr-fn (if ,sharedp\n                                      #'nsubseq\n                                      #'subseq ))\n                     (loop :for (var pos) :in (normalize-var-list-re var-list)\n                           :when var\n                             :collect (cond ((eql 0 pos)\n                                             `(,var (funcall ,substr-fn\n                                                             ,target-string\n                                                             ,match-start\n                                                             ,match-end )))\n                                            ((setq pos (regpos pos regname.pos))\n                                             (let ((pos (1- pos)))\n                                               `(,var (let ((,start-index\n                                                             (aref ,reg-starts ,pos ) ))\n                                                        (if ,start-index\n                                                            (funcall ,substr-fn\n                                                                     ,target-string\n                                                                     ,start-index\n                                                                     (aref ,reg-ends ,pos ) )\n                                                            nil )))))\n                                            (T `(,var nil)) )))\n               ,@body )\n             ,if-does-not-match )))))\n```\n\n```cl\n(funcall (RE-LAMBDA \"(?<Z>.)(?<Z>.)(?<X>.)(?<Y>.)\" ((a 0) z x y) (LIST a z x y))\n         \"defabcz\"\n         :if-does-not-match t)\n;=>  (\"defa\" \"e\" \"f\" \"a\")\n\n\n(funcall (re-lambda \"(abc|def)(.*)\" ((a 0) (b 1) (c 2))\n           (list a b c))\n         \"defabc\")\n;=>  (\"defabc\" \"def\" \"abc\")\n\n(funcall (re-lambda \"(?<FOO>[a-z]+)(?<BAR>\\\\d+)\" (foo bar)\n           (list foo bar))\n         \"   acl70beta \")\n;=>  (\"acl\" \"70\")\n\n\n;;; \u30b5\u30dd\u30fc\u30c8\u3057\u3066\u307e\u305b\u3093\n(funcall (re-lambda \"cde\" ((a 0 :before) (b 0) (c 0 :after))\n           (list a b c))\n         \"abcdefg\")\n;=>  (\"cde\" \"cde\" \"cde\")\n\n;;; Allegro: regex2\n;=> (\"ab\" \"cde\" \"fg\")\n```\n", "tags": ["common-lisp"]}