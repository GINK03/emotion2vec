{"context": " More than 1 year has passed since last update.wc \u30b3\u30de\u30f3\u30c9\u306b\u5f15\u304d\u7d9a\u304d\u3001\u307e\u305f\u4f5c\u308a\u307e\u3057\u305f\u3002\n\u4f8b\u306b\u3088\u3063\u3066\u4f8b\u306e\u3068\u304a\u308a\u3067\u3059\u3002\n' \u540d\u524d\n'     seq - \u5358\u8abf\u5897\u52a0 (\u6e1b\u5c11) \u3059\u308b\u6570\u5024\u5217\u3092\u8868\u793a\u3059\u308b\n' \n' \u66f8\u5f0f\n'     seq [/w] [/s SEP] [/equal-width] [/separator SEP] <LAST | FIRST LAST | FIRST INCR LAST>\n' \n'     seq [/?] [/help] [/v] [/version]\n' \n' \u8aac\u660e\n'     seq \u306f FIRST \u304b\u3089 LAST \u307e\u3067\u3001INCR \u305a\u3064\u52a0\u3048\u305f\u6570\u5024\u3092\u8868\u793a\u3059\u308b\u3002 \n'     LAST \u307e\u305f\u306f INCR \u304c\u7701\u7565\u3055\u308c\u305f\u5834\u5408\u3001\u30c7\u30d5\u30a9\u30eb\u30c8\u306f 1 \u306b\u306a\u308b\u3002\n' \n' \u30aa\u30d7\u30b7\u30e7\u30f3\n'     /s SEP, /separator SEP\n'         \u6570\u5024\u3092 SEP \u3067\u533a\u5207\u308b\u3002(\u30c7\u30d5\u30a9\u30eb\u30c8: \u2018\\n\u2019)\n' \n'     /w, /equal-width\n'         \u6841\u6570\u3092\u63c3\u3048\u308b\u305f\u3081\u306b (\u5148\u982d\u3092) 0 \u3067\u57cb\u3081\u308b\u3002\n' \n'     /?, /help\n'         \u4f7f\u7528\u6cd5\u306e\u30e1\u30c3\u30bb\u30fc\u30b8\u3092\u6a19\u6e96\u51fa\u529b\u306b\u8868\u793a\u3057\u3001\u6b63\u5e38\u7d42\u4e86\u3059\u308b\u3002\n' \n'     /v, /version\n'         \u30d0\u30fc\u30b8\u30e7\u30f3\u60c5\u5831\u3092\u6a19\u6e96\u51fa\u529b\u306b\u8868\u793a\u3057\u3001\u6b63\u5e38\u7d42\u4e86\u3059\u308b\u3002\n' \n' \u6ce8\u610f\n'     \u5c0f\u6570\u5024\u306f\u6b63\u78ba\u306b\u8a08\u7b97\u3067\u304d\u306a\u3044\u3002\n' ==============================================================================\noption explicit\n\n' ==========\n' parameters\n' ==========\ndim sep, width\nsep = Chr(10)\nwidth = false\n\n\n' ========================\n' parse arguments(options)\n' ========================\ndim arg, i\ndo while i < WScript.Arguments.Count\n    arg = WScript.Arguments.Item(i)\n    if Left(arg, 1) <> \"/\" then exit do\n\n    select case arg\n    'case \"/f\", \"/format\"\n    case \"/s\", \"/separator\"\n        i = i + 1\n        if i >= WScript.Arguments.Count then call WScript.Quit(1)\n        sep = WScript.Arguments.Item(i)\n    case \"/w\", \"/equal-width\"\n        width = true\n    case \"/?\", \"/help\"\n        call WScript.Echo(\"\u5358\u8abf\u5897\u52a0 (\u6e1b\u5c11) \u3059\u308b\u6570\u5024\u5217\u3092\u8868\u793a\u3059\u308b\")\n        call WScript.Echo(\"Usage: seq [/w] [/s SEP] [/equal-width] [/separator SEP] <LAST | FIRST LAST | FIRST INCR LAST>\")\n        call WScript.Echo(\"Usage: seq [/?] [/help] [/v] [/version]\")\n        call WScript.Quit(0)\n    case \"/v\", \"/version\"\n        call WScript.Echo(\"seq version 0.1\")\n        call WScript.Quit(0)\n    end select\n    i = i + 1\nloop\n\n\n' ==================================\n' parse arguments(first, last, incr)\n' ==================================\ndim first, incr, last\nfirst = 1\nincr = 1\nlast = 1\nselect case WScript.Arguments.Count - i\ncase 1\n    last = WScript.Arguments.Item(i)\ncase 2\n    first = WScript.Arguments.Item(i)\n    last = WScript.Arguments.Item(i + 1)\ncase 3\n    first = WScript.Arguments.Item(i)\n    incr = WScript.Arguments.Item(i + 1)\n    last = WScript.Arguments.Item(i + 2)\ncase else\n    call WScript.StdErr.WriteLine(\"seq: missing operand\")\n    call WScript.StdErr.WriteLine(\"seq /? \u3092\u5b9f\u884c\u3057\u3066\u304f\u3060\u3055\u3044\")\n    call WScript.Quit(1)\nend select\n\n\n' ==========\n' calc width\n' ==========\ndim inte, deci\ninte = max(len_inte(first), len_inte(incr), len_inte(last)) ' largest integer part length\ndeci = max(len_deci(first), len_deci(incr), len_deci(last)) ' largest decimal part length\n\n\n' ====================\n' arguments error trap\n' ====================\non error resume next\nfirst = cdbl(first)\nif err.number <> 0 then call WScript.StdErr.WriteLine(\"seq: invalid number argument: \" & first): call WScript.Quit(1)\n\nlast = cdbl(last)\nif err.number <> 0 then call WScript.StdErr.WriteLine(\"seq: invalid number argument: \" & last): call WScript.Quit(1)\n\nincr = cdbl(incr)\nif err.number <> 0 then call WScript.StdErr.WriteLine(\"seq: invalid number argument: \" & incr): call WScript.Quit(1)\non error goto 0\n\nif cdbl(incr) = 0 then call WScript.Quit(1)\nif cdbl(first) > cdbl(last) and cdbl(incr) > 0 then call WScript.Quit(1)\nif cdbl(first) < cdbl(last) and cdbl(incr) < 0 then call WScript.Quit(1)\n\n\n' ===============\n' output sequence\n' ===============\ndim distance, progress, stdout\nset stdout = WScript.Stdout\ni = first\ndistance = abs(last - first)\nprogress = 0 ' \u9032\u6357\u30c0\u30e1\u3067\u3059\uff1e\uff1c\ndo while progress <= distance\n    if width then\n        call printf(cstr(i), inte, deci)\n    else\n        call stdout.Write(i)\n    end if\n    call stdout.Write(sep)\n    i = round(i + incr, deci)\n    progress = abs(first - i)\nloop\n\n\n' ================\n' define functions\n' ================\nfunction max(byval a, byval b, byval c)\n    max = a\n    if max < b then max = b\n    if max < c then max = c\nend function\n\nfunction len_inte(byval strnum)\n    dim point\n    point = inStr(strnum, \".\")\n    if point > 0 then\n        len_inte = point - 1\n    else\n        len_inte = len(strnum)\n    end if\nend function\n\nfunction len_deci(byval strnum)\n    dim point\n    point = inStr(strnum, \".\")\n    if point > 0 then\n        len_deci = len(strnum) - point\n    else\n        len_deci = 0\n    end if\nend function\n\nfunction printf(byval num, byval inte_length, byval deci_length)\n    dim sign, inte, deci\n    sign = 1\n    inte = fix(num)\n    deci = round(num - inte, deci_length)\n\n    if num < 0 then sign = -1: inte = -inte\n\n    dim stdout\n    set stdout = WScript.Stdout\n    if sign < 0 then\n        call stdout.Write(\"-\")\n        call stdout.Write(lpad(cstr(inte), inte_length - 1))\n    else\n        call stdout.Write(lpad(cstr(inte), inte_length))\n    end if\n\n    if deci <> 0 then\n        call stdout.Write(\".\")\n        call stdout.Write(rpad(mid(abs(cstr(deci)), 3), deci_length))\n    elseif deci_length > 0 then\n        call stdout.Write(\".\")\n        call stdout.Write(rpad(\"0\", deci_length))\n    end if\nend function\n\nfunction lpad(byval str, byval length)\n    lpad = str\n    do while len(lpad) < length\n        lpad = \"0\" & lpad\n    loop\nend function\n\nfunction rpad(byval str, byval length)\n    rpad = str\n    do while len(rpad) < length\n        rpad = rpad & \"0\"\n    loop\nend function\n\nwc \u30b3\u30de\u30f3\u30c9\u306b\u5f15\u304d\u7d9a\u304d\u3001\u307e\u305f\u4f5c\u308a\u307e\u3057\u305f\u3002\n\n\u4f8b\u306b\u3088\u3063\u3066\u4f8b\u306e\u3068\u304a\u308a\u3067\u3059\u3002\n\n```vbnet\n' \u540d\u524d\n'     seq - \u5358\u8abf\u5897\u52a0 (\u6e1b\u5c11) \u3059\u308b\u6570\u5024\u5217\u3092\u8868\u793a\u3059\u308b\n' \n' \u66f8\u5f0f\n'     seq [/w] [/s SEP] [/equal-width] [/separator SEP] <LAST | FIRST LAST | FIRST INCR LAST>\n' \n'     seq [/?] [/help] [/v] [/version]\n' \n' \u8aac\u660e\n'     seq \u306f FIRST \u304b\u3089 LAST \u307e\u3067\u3001INCR \u305a\u3064\u52a0\u3048\u305f\u6570\u5024\u3092\u8868\u793a\u3059\u308b\u3002 \n'     LAST \u307e\u305f\u306f INCR \u304c\u7701\u7565\u3055\u308c\u305f\u5834\u5408\u3001\u30c7\u30d5\u30a9\u30eb\u30c8\u306f 1 \u306b\u306a\u308b\u3002\n' \n' \u30aa\u30d7\u30b7\u30e7\u30f3\n'     /s SEP, /separator SEP\n'         \u6570\u5024\u3092 SEP \u3067\u533a\u5207\u308b\u3002(\u30c7\u30d5\u30a9\u30eb\u30c8: \u2018\\n\u2019)\n' \n'     /w, /equal-width\n'         \u6841\u6570\u3092\u63c3\u3048\u308b\u305f\u3081\u306b (\u5148\u982d\u3092) 0 \u3067\u57cb\u3081\u308b\u3002\n' \n'     /?, /help\n'         \u4f7f\u7528\u6cd5\u306e\u30e1\u30c3\u30bb\u30fc\u30b8\u3092\u6a19\u6e96\u51fa\u529b\u306b\u8868\u793a\u3057\u3001\u6b63\u5e38\u7d42\u4e86\u3059\u308b\u3002\n' \n'     /v, /version\n'         \u30d0\u30fc\u30b8\u30e7\u30f3\u60c5\u5831\u3092\u6a19\u6e96\u51fa\u529b\u306b\u8868\u793a\u3057\u3001\u6b63\u5e38\u7d42\u4e86\u3059\u308b\u3002\n' \n' \u6ce8\u610f\n'     \u5c0f\u6570\u5024\u306f\u6b63\u78ba\u306b\u8a08\u7b97\u3067\u304d\u306a\u3044\u3002\n' ==============================================================================\noption explicit\n\n' ==========\n' parameters\n' ==========\ndim sep, width\nsep = Chr(10)\nwidth = false\n\n\n' ========================\n' parse arguments(options)\n' ========================\ndim arg, i\ndo while i < WScript.Arguments.Count\n    arg = WScript.Arguments.Item(i)\n    if Left(arg, 1) <> \"/\" then exit do\n    \n    select case arg\n    'case \"/f\", \"/format\"\n    case \"/s\", \"/separator\"\n        i = i + 1\n        if i >= WScript.Arguments.Count then call WScript.Quit(1)\n        sep = WScript.Arguments.Item(i)\n    case \"/w\", \"/equal-width\"\n        width = true\n    case \"/?\", \"/help\"\n        call WScript.Echo(\"\u5358\u8abf\u5897\u52a0 (\u6e1b\u5c11) \u3059\u308b\u6570\u5024\u5217\u3092\u8868\u793a\u3059\u308b\")\n        call WScript.Echo(\"Usage: seq [/w] [/s SEP] [/equal-width] [/separator SEP] <LAST | FIRST LAST | FIRST INCR LAST>\")\n        call WScript.Echo(\"Usage: seq [/?] [/help] [/v] [/version]\")\n        call WScript.Quit(0)\n    case \"/v\", \"/version\"\n        call WScript.Echo(\"seq version 0.1\")\n        call WScript.Quit(0)\n    end select\n    i = i + 1\nloop\n\n\n' ==================================\n' parse arguments(first, last, incr)\n' ==================================\ndim first, incr, last\nfirst = 1\nincr = 1\nlast = 1\nselect case WScript.Arguments.Count - i\ncase 1\n    last = WScript.Arguments.Item(i)\ncase 2\n    first = WScript.Arguments.Item(i)\n    last = WScript.Arguments.Item(i + 1)\ncase 3\n    first = WScript.Arguments.Item(i)\n    incr = WScript.Arguments.Item(i + 1)\n    last = WScript.Arguments.Item(i + 2)\ncase else\n    call WScript.StdErr.WriteLine(\"seq: missing operand\")\n    call WScript.StdErr.WriteLine(\"seq /? \u3092\u5b9f\u884c\u3057\u3066\u304f\u3060\u3055\u3044\")\n    call WScript.Quit(1)\nend select\n\n\n' ==========\n' calc width\n' ==========\ndim inte, deci\ninte = max(len_inte(first), len_inte(incr), len_inte(last)) ' largest integer part length\ndeci = max(len_deci(first), len_deci(incr), len_deci(last)) ' largest decimal part length\n\n\n' ====================\n' arguments error trap\n' ====================\non error resume next\nfirst = cdbl(first)\nif err.number <> 0 then call WScript.StdErr.WriteLine(\"seq: invalid number argument: \" & first): call WScript.Quit(1)\n\nlast = cdbl(last)\nif err.number <> 0 then call WScript.StdErr.WriteLine(\"seq: invalid number argument: \" & last): call WScript.Quit(1)\n\nincr = cdbl(incr)\nif err.number <> 0 then call WScript.StdErr.WriteLine(\"seq: invalid number argument: \" & incr): call WScript.Quit(1)\non error goto 0\n\nif cdbl(incr) = 0 then call WScript.Quit(1)\nif cdbl(first) > cdbl(last) and cdbl(incr) > 0 then call WScript.Quit(1)\nif cdbl(first) < cdbl(last) and cdbl(incr) < 0 then call WScript.Quit(1)\n\n\n' ===============\n' output sequence\n' ===============\ndim distance, progress, stdout\nset stdout = WScript.Stdout\ni = first\ndistance = abs(last - first)\nprogress = 0 ' \u9032\u6357\u30c0\u30e1\u3067\u3059\uff1e\uff1c\ndo while progress <= distance\n    if width then\n        call printf(cstr(i), inte, deci)\n    else\n        call stdout.Write(i)\n    end if\n    call stdout.Write(sep)\n    i = round(i + incr, deci)\n    progress = abs(first - i)\nloop\n\n\n' ================\n' define functions\n' ================\nfunction max(byval a, byval b, byval c)\n    max = a\n    if max < b then max = b\n    if max < c then max = c\nend function\n\nfunction len_inte(byval strnum)\n    dim point\n    point = inStr(strnum, \".\")\n    if point > 0 then\n        len_inte = point - 1\n    else\n        len_inte = len(strnum)\n    end if\nend function\n\nfunction len_deci(byval strnum)\n    dim point\n    point = inStr(strnum, \".\")\n    if point > 0 then\n        len_deci = len(strnum) - point\n    else\n        len_deci = 0\n    end if\nend function\n\nfunction printf(byval num, byval inte_length, byval deci_length)\n    dim sign, inte, deci\n    sign = 1\n    inte = fix(num)\n    deci = round(num - inte, deci_length)\n    \n    if num < 0 then sign = -1: inte = -inte\n    \n    dim stdout\n    set stdout = WScript.Stdout\n    if sign < 0 then\n        call stdout.Write(\"-\")\n        call stdout.Write(lpad(cstr(inte), inte_length - 1))\n    else\n        call stdout.Write(lpad(cstr(inte), inte_length))\n    end if\n    \n    if deci <> 0 then\n        call stdout.Write(\".\")\n        call stdout.Write(rpad(mid(abs(cstr(deci)), 3), deci_length))\n    elseif deci_length > 0 then\n        call stdout.Write(\".\")\n        call stdout.Write(rpad(\"0\", deci_length))\n    end if\nend function\n\nfunction lpad(byval str, byval length)\n    lpad = str\n    do while len(lpad) < length\n        lpad = \"0\" & lpad\n    loop\nend function\n\nfunction rpad(byval str, byval length)\n    rpad = str\n    do while len(rpad) < length\n        rpad = rpad & \"0\"\n    loop\nend function\n```\n", "tags": ["VBScript", "Windows"]}