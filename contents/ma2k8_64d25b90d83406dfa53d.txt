{"context": " More than 1 year has passed since last update.\n\n\u7b2c4\u7ae0 \u4f8b\u5916\u3092\u4f7f\u308f\u306a\u3044\u30a8\u30e9\u30fc\u51e6\u7406\n\u5168\u4f53\u7684\u306a\u8003\u3048\u305f\u65b9\u3068\u3057\u3066\u306f\u3001\u5931\u6557\u3084\u4f8b\u5916\u3092\u901a\u5e38\u306e\u5024\u3067\u8868\u3057\u3001\u30a8\u30e9\u30fc\u51e6\u7406\u3068\u30ea\u30ab\u30d0\u30ea\u306b\u5171\u901a\u3059\u308b\u30d1\u30bf\u30fc\u30f3\u3092\u9ad8\u968e\u95a2\u6570\u3068\u3057\u3066\u62bd\u51fa\u3059\u308b\n\u8a55\u4fa1\u3055\u308c\u306a\u3044\u5f0f\u3092\u30b5\u30f3\u30af(thunk)\u3068\u547c\u3076\u3002\ni: => Int\u69cb\u6587\u3067\u6e21\u3059\u9ad8\u968e\u95a2\u6570\u306f\u30c7\u30d5\u30a9\u30eb\u30c8\u30ad\u30e3\u30c3\u30b7\u30e5\u3055\u308c\u306a\u3044\u3002\u3064\u307e\u308a\u53c2\u7167\u3055\u308c\u308b\u305f\u3073\u306b\u5b9f\u884c\u3055\u308c\u308b\u3002\n\u30ad\u30e3\u30c3\u30b7\u30e5\u3057\u305f\u3044\u5834\u5408\u306flazy val\u3067\u53c2\u7167\u3059\u308b\u3053\u3068\u306b\u3088\u308a\u3001\u660e\u793a\u7684\u306b\u30ad\u30e3\u30c3\u30b7\u30e5\u3059\u308b\u3002\nScala\u306e\u975e\u6b63\u683c\u95a2\u6570\u306f\u5f15\u6570\u3092\u5024\u6e21\u3057\u3067\u306f\u306a\u304f\u540d\u524d\u6e21\u3057\u3067\u53d7\u3051\u53d6\u308b\u3002\n\nEXERCISE 4.1\n// Q\n\u30ea\u30b9\u30c84\uff704\u306e\u3059\u3079\u3066\u306e\u95a2\u6570\u3092Option\u3067\u5b9f\u88c5\u305b\u3088\u3002\n\u5404\u95a2\u6570\u3092\u5b9f\u88c5\u3059\u308b\u3068\u304d\u306b\u3001\u305d\u306e\u95a2\u6570\u306e\u610f\u5473\u3068\u3001\u305d\u308c\u3092\u4f7f\u7528\u3059\u308b\u3067\u3042\u308d\u3046\u72b6\u6cc1\u306b\u3064\u3044\u3066\u8003\u3048\u308b\u3053\u3068\u3002\n\u3069\u306e\u95a2\u6570\u3092\u3044\u3064\u4f7f\u7528\u3059\u308b\u304b\u306b\u3064\u3044\u3066\u306f\u3001\u5f8c\u307b\u3069\u8003\u5bdf\u3059\u308b\u3002\n\u30d2\u30f3\u30c8\u306f\u4ee5\u4e0b\u306e\u3068\u304a\u308a\u3002\n - \u30d1\u30bf\u30fc\u30f3\u30de\u30c3\u30c1\u30f3\u30b0\u3092\u4f7f\u7528\u3057\u3066\u3082\u69cb\u308f\u306a\u3044\u304c\u3001\n\u3000  map\u3068getOrElse\u3092\u9664\u304f\u95a2\u6570\u306f\u3059\u3079\u3066\u30d1\u30bf\u30fc\u30f3\u30de\u30c3\u30c1\u30f3\u30b0\u306b\u983c\u3089\u306a\u304f\u3066\u3082\u5b9f\u88c5\u3067\u304d\u308b\u306f\u305a\u3067\u3042\u308b\u3002\n -  map,flatMap\u306e\u5b9f\u88c5\u306f\u3001\u904e\u591a\u30b7\u30b0\u30cd\u30c1\u30e3\u306e\u60c5\u5831\u306b\u57fa\u3065\u3044\u3066\u5145\u5206\u306b\u6c7a\u5b9a\u3067\u304d\u308b\u306f\u305a\u3067\u3042\u308b\u3002\n -  getOrElse\u306fOption\u304cNone\u306e\u30d0\u30a2\u30a2\u30a4\u306f\u3001\u6307\u5b9a\u3055\u308c\u305f\u30c7\u30d5\u30a9\u30eb\u30c8\u5024\u3092\u8fd4\u3059\u3002\n -  orElse\u306f\u30011\u3064\u76ee\u306eOption\u304c\u5b9a\u7fa9\u3055\u308c\u3066\u3044\u308b\u5834\u5408\u306f\u305d\u308c\u3092\u8fd4\u3057\u3001\u305d\u3046\u3067\u306a\u3044\u5834\u5408\u306f2\u3064\u76ee\u306eOption\u3092\u8fd4\u3059\u3002\n\n// answer\n  def map[B](f: A => B): Option[B] = this match {\n    case None => None\n    case Some(x) => Some(f(x))\n  }\n\n def getOrElse[B>:A](default: => B): B = this match {\n    case None => default\n    case Some(x) => x  \n  }\n\n def flatMap[B](f: A => Option[B]): Option[B] = map(f).getOrElse(None)\n\n def orElse[B>:A](ob: => Option[B]): Option[B] = this match {\n    case None => ob\n    case Some(x) => Some(x)  \n  }\n\n  def filter(f: A => Boolean): Option[A] = this match {\n    case Some(x) if f(x) => Some(x)\n    case None => None\n  }\n\n// \u516c\u5f0f\u306eanswer\n def map[B](f: A => B): Option[B] = this match {\n    case None => None\n    case Some(a) => Some(f(a))\n  }\n\n  def getOrElse[B>:A](default: => B): B = this match {\n    case None => default\n    case Some(a) => a\n  }\n\n  def flatMap[B](f: A => Option[B]): Option[B] =\n    map(f) getOrElse None\n\n  /*\n  Of course, we can also implement `flatMap` with explicit pattern matching.\n  */\n  def flatMap_1[B](f: A => Option[B]): Option[B] = this match {\n    case None => None\n    case Some(a) => f(a)\n  }\n\n  def orElse[B>:A](ob: => Option[B]) =\n    this map (Some(_)) getOrElse ob\n\n  /*\n  Again, we can implement this with explicit pattern matching.\n  */\n  def orElse_1[B>:A](ob: => Option[B]): Option[B] = this match {\n    case None => ob\n    case _ => this\n  }\n\n  def filter(f: A => Boolean): Option[A] = this match {\n    case Some(a) if f(a) => this\n    case _ => None\n  }\n  /*\n  This can also be defined in terms of `flatMap`.\n  */\n  def filter_1(f: A => Boolean): Option[A] =\n    flatMap(a => if (f(a)) Some(a) else None)\n\norElse,filter\u306f\u8ae6\u3081\u3066match case\u3067\u5b9f\u88c5\n\nEXERCISE 4.2\n// Q\nflatMap\u3092\u30d9\u30fc\u30b9\u3068\u3057\u3066variance\u95a2\u6570\u3092\u5b9f\u88c5\u305b\u3088\u3002\n\u30b7\u30fc\u30b1\u30f3\u30b9\u306e\u5e73\u5747\u3092m\u3001\u30b7\u30fc\u30b1\u30f3\u30b9\u306e\u5404\u8981\u7d20\u3092x\u3068\u3059\u308c\u3070\u3001\u5206\u6563\u306fmath.pow(x - m, 2)\u306e\u5e73\u5747\u3068\u306a\u308b\u3002\ndef variance(xs: Seq[Double]): Option[Double]\n\n// answer\n\n\n// \u516c\u5f0f\u306eanswer\n  def mean(xs: Seq[Double]): Option[Double] =\n    if (xs.isEmpty) None\n    else Some(xs.sum / xs.length)\n\n  def variance(xs: Seq[Double]): Option[Double] =\n    mean(xs) flatMap (m => mean(xs.map(x => math.pow(x - m, 2))))\n\n\n\u304e\u3076\n\nEXERCISE 4.3\n// Q\n2\u9805\u95a2\u6570\u3092\u4f7f\u3063\u3066\u3001Option\u578b\u306e2\u3064\u306e\u5024\u3092\u7d50\u5408\u3059\u308b\u7dcf\u79f0\u95a2\u6570map2\u3092\u8a18\u8ff0\u305b\u3088\u3002\n\u3069\u3061\u3089\u304b\u306eOption\u5024\u304cNone\u306e\u5834\u5408\u306f\u3001\u623b\u308a\u5024\u3082None\u306b\u306a\u308b\u3002\n\u30b7\u30b0\u30cd\u30c1\u30e3\u306f\u4ee5\u4e0b\u306e\u3068\u304a\u308a\u3002\ndef map2[A,B,C](a: Option[A], b: Option[B])(f: (A, B) => C): Option[C]\n\n// answer\n  def map2[A,B,C](a: Option[A], b: Option[B])(f: (A, B) => C): Option[C] = (a,b) match {\n    case (Some(x), Some(y)) => Some(f(x,y))\n    case _ => None\n  }\n\n// \u516c\u5f0f\u306eanswer\ndef map2[A,B,C](a: Option[A], b: Option[B])(f: (A, B) => C): Option[C] =\n    a flatMap (aa => b map (bb => f(aa, bb)))\n\n\u516c\u5f0f\u306eflatMap & map\u306e\u307b\u3046\u304c\u304b\u3063\u3053\u3044\u3044\n\nEXERCISE 4.4\n// Q\nOption\u306e\u30ea\u30b9\u30c8\u30921\u3064\u306eOption\u306b\u307e\u3068\u3081\u308bsequence\u95a2\u6570\u3092\u8a18\u8ff0\u305b\u3088\u3002\n\u65b0\u3057\u3044Option\u306b\u306f\u3001\u5143\u306e\u30ea\u30b9\u30c8\u306b\u542b\u307e\u308c\u3066\u3044\u308b\u3059\u3079\u3066\u306eSome\u5024\u306e\u30ea\u30b9\u30c8\u304c\u542b\u307e\u308c\u308b\u3002\n\u5143\u306e\u30ea\u30b9\u30c8\u306bNone\u304c1\u3064\u3067\u3082\u542b\u307e\u308c\u3066\u3044\u305f\u5834\u5408\u3001\u3053\u306e\u95a2\u6570\u306e\u7d50\u679c\u306fNone\u306b\u306a\u308b\u3002\n\u305d\u308c\u4ee5\u5916\u306e\u5834\u5408\u306f\u3001\u3059\u3079\u3066\u306e\u5024\u306e\u30ea\u30b9\u30c8\u3092\u542b\u3093\u3060Some\u306b\u306a\u308b\u3002\u30b7\u30b0\u30cd\u30c1\u30e3\u306f\u4ee5\u4e0b\u306e\u3068\u304a\u308a\u3002\ndef sequence[A](a: List[Option[A]]): Option[List[A]]\n\n// answer\n def sequence[A](a: List[Option[A]]): Option[List[A]] = {\n    @annotation.tailrec\n    def loop(l: List[Option[A]], x: Option[List[A]]): Option[List[A]] = {\n      l match {\n        case Some(h) :: List() => x.map(h :: _)\n        case Some(h) :: t => loop(t, x.map(h :: _))\n        case None :: _ => None\n        case _ => println(\"_\"); None\n      }\n    }\n    loop(a, Some(List())).map(_.reverse)\n  }\n\n// \u516c\u5f0f\u306eanswer\n  def sequence[A](a: List[Option[A]]): Option[List[A]] =\n    a match {\n      case Nil => Some(Nil)\n      case h :: t => h flatMap (hh => sequence(t) map (hh :: _))\n    }\n  /*\n  It can also be implemented using `foldRight` and `map2`. The type annotation on `foldRight` is needed here; otherwise\n  Scala wrongly infers the result type of the fold as `Some[Nil.type]` and reports a type error (try it!). This is an\n  unfortunate consequence of Scala using subtyping to encode algebraic data types.\n  */\n  def sequence_1[A](a: List[Option[A]]): Option[List[A]] =\n    a.foldRight[Option[List[A]]](Some(Nil))((x,y) => map2(x,y)(_ :: _))\n\n\n2\u56de\u8d70\u67fb\u3057\u3066\u3044\u3066\u30a4\u30b1\u3066\u306a\u3044\u3002\u3002\n\nEXERCISE 4.5\n// Q\ntraverse\u95a2\u6570\u3092\u5b9f\u88c5\u305b\u3088\u3002map\u3068sequence\u3092\u5229\u7528\u3059\u308c\u3070\u7c21\u5358\u3060\u304c\u3001\u30ea\u30b9\u30c8\u30921\u56de\u3060\u3051\u8abf\u3079\u308b\u3001\u3088\u308a\u52b9\u7387\u306e\u3088\u3044\u5b9f\u88c5\u306b\u3059\u308b\u3053\u3068\u3002\n\u8981\u3059\u308b\u306b\u3001traverse\u306e\u89b3\u70b9\u304b\u3089sequence\u3092\u5b9f\u88c5\u3059\u308c\u3070\u826f\u3044\u3002\n\n// answer\n  def traverse[E,B,C](a: List[A])(f: A => Either[E,B]): Either[E,List[B]] =\n    a match {\n      case Nil => Right(Nil)\n      case h :: t => (f(h) map2 traverse(t)(f))(_ :: _) \n  }\n\n// \u516c\u5f0f\u306eanswer\n  def traverse[E,A,B](es: List[A])(f: A => Either[E, B]): Either[E, List[B]] = \n    es match {\n      case Nil => Right(Nil)\n      case h::t => (f(h) map2 traverse(t)(f))(_ :: _)\n    }\n\n  def traverse_1[E,A,B](es: List[A])(f: A => Either[E, B]): Either[E, List[B]] = \n    es.foldRight[Either[E,List[B]]](Right(Nil))((a, b) => f(a).map2(b)(_ :: _))\n\n4.4\u3092\u53c2\u8003\u306b\u3057\u305f\u3002\n\nEXERCISE 4.6\n// Q\nRight\u5024\u3092\u64cd\u4f5c\u3059\u308bmap,flatMap,orElse,map2\u3092Either\u306b\u8ffd\u52a0\u305b\u3088\u3002\ntrait Either[+E,+A] {\n def map[B](f: A => B): Either[E, B] = sys.error(\"todo\")\n\n def flatMap[EE >: E, B](f: A => Either[EE, B]): Either[EE, B] = sys.error(\"todo\")\n\n def orElse[EE >: E, B >: A](b: => Either[EE, B]): Either[EE, B] = sys.error(\"todo\")\n\n def map2[EE >: E, B, C](b: Either[EE, B])(f: (A, B) => C): Either[EE, C] = sys.error(\"todo\")\n}\n// answer\n trait Either[+E, +A] {\n  def map[B](f: A => B): Either[E, B] = this match {\n    case Right(x) => Right(f(x))\n    case Left(e) => Left(e)\n  }\n\n  def flatMap[EE >: E, B](f: A => Either[EE, B]): Either[EE, B] = this match {\n    case Right(x) => f(x)\n    case Left(e) => Left(e)\n  }\n\n\n  def orElse[EE >: E, B >: A](b: => Either[EE, B]): Either[EE, B] = this match {\n    case Right(x) => this\n    case Left(e) => b\n  }\n\n  def map2[EE >: E, B, C](b: Either[EE, B])(f: (A, B) => C): Either[EE, C] = for { x <- this; y <- b } yield f(x,y)\n\n}\n// \u516c\u5f0f\u306eanswer\nsealed trait Either[+E,+A] {\n def map[B](f: A => B): Either[E, B] = \n   this match {\n     case Right(a) => Right(f(a))\n     case Left(e) => Left(e)\n   }\n\n def flatMap[EE >: E, B](f: A => Either[EE, B]): Either[EE, B] =\n   this match {\n     case Left(e) => Left(e)\n     case Right(a) => f(a)\n   }\n def orElse[EE >: E, AA >: A](b: => Either[EE, AA]): Either[EE, AA] =\n   this match {\n     case Left(_) => b\n     case Right(a) => Right(a)\n   }\n def map2[EE >: E, B, C](b: Either[EE, B])(f: (A, B) => C): \n   Either[EE, C] = for { a <- this; b1 <- b } yield f(a,b1)\n}\n\nmap2\u304c\u5408\u3063\u3066\u305f\u306e\u6c17\u6301\u3061\u826f\u3044^q^\n\nEXERCISE 4.7\n// Q\nEither\u3067sequence\u3068traverse\u3092\u5b9f\u88c5\u305b\u3088\u3002\n\u3053\u308c\u3089\u306f\u3001\u30a8\u30e9\u30fc\u304c\u767a\u751f\u3057\u305f\u5834\u5408\u306b\u3001\u6700\u521d\u306b\u691c\u51fa\u3055\u308c\u305f\u30a8\u30e9\u30fc\u3092\u8fd4\u3059\u3082\u306e\u3068\u3059\u308b\u3002\n\ndef sequence[E,A](es: List[Either[E,A]]): Either[E,List[A]]\ndef traverse[E,A,B](as: List[A])(f: A => Either[E,B]): Either[E,List[B]]\n\n// answer\n  def traverse[E, A, B](es: List[A])(f: A => Either[E, B]): Either[E, List[B]] =\n    es match {\n      case Nil => Right(Nil)\n      case h :: t => (f(h) map2 traverse(t)(f))(_ :: _)\n    }\n\n  def sequence[E, A](es: List[Either[E, A]]): Either[E, List[A]] =\n    es match {\n      case Nil => Right(Nil)\n      case Left(h) :: _  => Left(h)\n      case h :: t => h flatMap (hh => sequence(t) map (hh :: _))\n    }\n\n// \u516c\u5f0f\u306eanswer\n  def traverse[E,A,B](es: List[A])(f: A => Either[E, B]): Either[E, List[B]] = \n    es match {\n      case Nil => Right(Nil)\n      case h::t => (f(h) map2 traverse(t)(f))(_ :: _)\n    }\n\n  def traverse_1[E,A,B](es: List[A])(f: A => Either[E, B]): Either[E, List[B]] = \n    es.foldRight[Either[E,List[B]]](Right(Nil))((a, b) => f(a).map2(b)(_ :: _))\n\n  def sequence[E,A](es: List[Either[E,A]]): Either[E,List[A]] = \n    traverse(es)(x => x)\n\n\nsequence\u304b\u3063\u3053\u3088\u3044\u30fb\u30fb\u3002\n\nEXERCISE 4.8\n// Q\n\u30ea\u30b9\u30c84-10\u306e\u5b9f\u88c5\u3067\u306f\u3001\u540d\u524d\u3068\u5e74\u9f62\u304c\u4e21\u65b9\u3068\u3082\u7121\u52b9\u3067\u3042\u3063\u305f\u3068\u3057\u3066\u3082\u3001map2\u306f\u30a8\u30e9\u30fc\u30921\u3064\u3057\u304b\u5831\u544a\u3067\u304d\u306a\u3044\u3002\n\u4e21\u65b9\u306e\u30a8\u30e9\u30fc\u3092\u5831\u544a\u3059\u308b\u306b\u306f\u3001\u4f55\u3092\u5909\u66f4\u3059\u308b\u5fc5\u8981\u304c\u3042\u308b\u304b\u3002\nmap2\u3092\u5909\u66f4\u3059\u308b\u306e\u304b\u3001\u305d\u308c\u3068\u3082mkPerson\u306e\u30b7\u30b0\u30cd\u30c1\u30e3\u3092\u5909\u66f4\u3059\u308b\u306e\u304b\u3002\n\u3042\u308b\u3044\u306f\u3001\u65b0\u3057\u3044\u69cb\u9020\u3092\u8ffd\u52a0\u3057\u3066\u3001\u3053\u306e\u8981\u4ef6\u3092Either\u3088\u308a\u3082\u52b9\u679c\u7684\u306b\u6e80\u305f\u3059\u65b0\u3057\u3044\u30c7\u30fc\u30bf\u578b\u3092\u4f5c\u6210\u3059\u308b\u3053\u3068\u306f\u53ef\u80fd\u304b\u3002\n\u305d\u306e\u30c7\u30fc\u30bf\u578b\u3067\u306f\u3001orElse\u3001travase\u3001sequence\u306e\u632f\u308b\u821e\u3044\u306f\u3069\u306e\u3088\u3046\u306b\u5909\u5316\u3059\u308b\u304b\u3002\n\n// \u516c\u5f0f\u306eanswer\nThere are a number of variations on Option and Either. If we want to accumulate multiple errors, a simple\napproach is a new data type that lets us keep a list of errors in the data constructor that represents failures:\ntrait Partial[+A,+B]\ncase class Errors+A extends Partial[A,Nothing]\ncase class Success+B extends Partial[Nothing,B]\nThere is a type very similar to this called Validation in the Scalaz library. You can implement map, map2,\nsequence, and so on for this type in such a way that errors are accumulated when possible (flatMap is unable to\naccumulate errors--can you see why?). This idea can even be generalized further--we don't need to accumulate failing\nvalues into a list; we can accumulate values using any user-supplied binary function.\nIt's also possible to use Either[List[E],_] directly to accumulate errors, using different implementations of\nhelper functions like map2 and sequence.\n\n\n\n\n# \u7b2c4\u7ae0 \u4f8b\u5916\u3092\u4f7f\u308f\u306a\u3044\u30a8\u30e9\u30fc\u51e6\u7406\n\n\u5168\u4f53\u7684\u306a\u8003\u3048\u305f\u65b9\u3068\u3057\u3066\u306f\u3001\u5931\u6557\u3084\u4f8b\u5916\u3092\u901a\u5e38\u306e\u5024\u3067\u8868\u3057\u3001\u30a8\u30e9\u30fc\u51e6\u7406\u3068\u30ea\u30ab\u30d0\u30ea\u306b\u5171\u901a\u3059\u308b\u30d1\u30bf\u30fc\u30f3\u3092\u9ad8\u968e\u95a2\u6570\u3068\u3057\u3066\u62bd\u51fa\u3059\u308b\n\n\u8a55\u4fa1\u3055\u308c\u306a\u3044\u5f0f\u3092\u30b5\u30f3\u30af(thunk)\u3068\u547c\u3076\u3002\n\ni: => Int\u69cb\u6587\u3067\u6e21\u3059\u9ad8\u968e\u95a2\u6570\u306f\u30c7\u30d5\u30a9\u30eb\u30c8\u30ad\u30e3\u30c3\u30b7\u30e5\u3055\u308c\u306a\u3044\u3002\u3064\u307e\u308a\u53c2\u7167\u3055\u308c\u308b\u305f\u3073\u306b\u5b9f\u884c\u3055\u308c\u308b\u3002\n\u30ad\u30e3\u30c3\u30b7\u30e5\u3057\u305f\u3044\u5834\u5408\u306flazy val\u3067\u53c2\u7167\u3059\u308b\u3053\u3068\u306b\u3088\u308a\u3001\u660e\u793a\u7684\u306b\u30ad\u30e3\u30c3\u30b7\u30e5\u3059\u308b\u3002\n\nScala\u306e\u001e\u975e\u6b63\u683c\u95a2\u6570\u306f\u5f15\u6570\u3092\u5024\u6e21\u3057\u3067\u306f\u306a\u304f\u540d\u524d\u6e21\u3057\u3067\u53d7\u3051\u53d6\u308b\u3002\n\n\n## EXERCISE 4.1\n\n```\n// Q\n\u30ea\u30b9\u30c84\uff704\u306e\u3059\u3079\u3066\u306e\u95a2\u6570\u3092Option\u3067\u5b9f\u88c5\u305b\u3088\u3002\n\u5404\u95a2\u6570\u3092\u5b9f\u88c5\u3059\u308b\u3068\u304d\u306b\u3001\u305d\u306e\u95a2\u6570\u306e\u610f\u5473\u3068\u3001\u305d\u308c\u3092\u4f7f\u7528\u3059\u308b\u3067\u3042\u308d\u3046\u72b6\u6cc1\u306b\u3064\u3044\u3066\u8003\u3048\u308b\u3053\u3068\u3002\n\u3069\u306e\u95a2\u6570\u3092\u3044\u3064\u4f7f\u7528\u3059\u308b\u304b\u306b\u3064\u3044\u3066\u306f\u3001\u5f8c\u307b\u3069\u8003\u5bdf\u3059\u308b\u3002\n\u30d2\u30f3\u30c8\u306f\u4ee5\u4e0b\u306e\u3068\u304a\u308a\u3002\n - \u30d1\u30bf\u30fc\u30f3\u30de\u30c3\u30c1\u30f3\u30b0\u3092\u4f7f\u7528\u3057\u3066\u3082\u69cb\u308f\u306a\u3044\u304c\u3001\n\u3000  map\u3068getOrElse\u3092\u9664\u304f\u95a2\u6570\u306f\u3059\u3079\u3066\u30d1\u30bf\u30fc\u30f3\u30de\u30c3\u30c1\u30f3\u30b0\u306b\u983c\u3089\u306a\u304f\u3066\u3082\u5b9f\u88c5\u3067\u304d\u308b\u306f\u305a\u3067\u3042\u308b\u3002\n -  map,flatMap\u306e\u5b9f\u88c5\u306f\u3001\u904e\u591a\u30b7\u30b0\u30cd\u30c1\u30e3\u306e\u60c5\u5831\u306b\u57fa\u3065\u3044\u3066\u5145\u5206\u306b\u6c7a\u5b9a\u3067\u304d\u308b\u306f\u305a\u3067\u3042\u308b\u3002\n -  getOrElse\u306fOption\u304cNone\u306e\u30d0\u30a2\u30a2\u30a4\u306f\u3001\u6307\u5b9a\u3055\u308c\u305f\u30c7\u30d5\u30a9\u30eb\u30c8\u5024\u3092\u8fd4\u3059\u3002\n -  orElse\u306f\u30011\u3064\u76ee\u306eOption\u304c\u5b9a\u7fa9\u3055\u308c\u3066\u3044\u308b\u5834\u5408\u306f\u305d\u308c\u3092\u8fd4\u3057\u3001\u305d\u3046\u3067\u306a\u3044\u5834\u5408\u306f2\u3064\u76ee\u306eOption\u3092\u8fd4\u3059\u3002\n\n// answer\n  def map[B](f: A => B): Option[B] = this match {\n    case None => None\n    case Some(x) => Some(f(x))\n  }\n\n def getOrElse[B>:A](default: => B): B = this match {\n    case None => default\n    case Some(x) => x  \n  }\n\n def flatMap[B](f: A => Option[B]): Option[B] = map(f).getOrElse(None)\n\n def orElse[B>:A](ob: => Option[B]): Option[B] = this match {\n    case None => ob\n    case Some(x) => Some(x)  \n  }\n\n  def filter(f: A => Boolean): Option[A] = this match {\n    case Some(x) if f(x) => Some(x)\n    case None => None\n  }\n\n// \u516c\u5f0f\u306eanswer\n def map[B](f: A => B): Option[B] = this match {\n    case None => None\n    case Some(a) => Some(f(a))\n  }\n\n  def getOrElse[B>:A](default: => B): B = this match {\n    case None => default\n    case Some(a) => a\n  }\n\n  def flatMap[B](f: A => Option[B]): Option[B] =\n    map(f) getOrElse None\n\n  /*\n  Of course, we can also implement `flatMap` with explicit pattern matching.\n  */\n  def flatMap_1[B](f: A => Option[B]): Option[B] = this match {\n    case None => None\n    case Some(a) => f(a)\n  }\n\n  def orElse[B>:A](ob: => Option[B]) =\n    this map (Some(_)) getOrElse ob\n\n  /*\n  Again, we can implement this with explicit pattern matching.\n  */\n  def orElse_1[B>:A](ob: => Option[B]): Option[B] = this match {\n    case None => ob\n    case _ => this\n  }\n\n  def filter(f: A => Boolean): Option[A] = this match {\n    case Some(a) if f(a) => this\n    case _ => None\n  }\n  /*\n  This can also be defined in terms of `flatMap`.\n  */\n  def filter_1(f: A => Boolean): Option[A] =\n    flatMap(a => if (f(a)) Some(a) else None)\n```\n\norElse,filter\u306f\u8ae6\u3081\u3066match case\u3067\u5b9f\u88c5\n\n\n## EXERCISE 4.2\n\n```\n// Q\nflatMap\u3092\u30d9\u30fc\u30b9\u3068\u3057\u3066variance\u95a2\u6570\u3092\u5b9f\u88c5\u305b\u3088\u3002\n\u30b7\u30fc\u30b1\u30f3\u30b9\u306e\u5e73\u5747\u3092m\u3001\u30b7\u30fc\u30b1\u30f3\u30b9\u306e\u5404\u8981\u7d20\u3092x\u3068\u3059\u308c\u3070\u3001\u5206\u6563\u306fmath.pow(x - m, 2)\u306e\u5e73\u5747\u3068\u306a\u308b\u3002\ndef variance(xs: Seq[Double]): Option[Double]\n\n// answer\n\n\n// \u516c\u5f0f\u306eanswer\n  def mean(xs: Seq[Double]): Option[Double] =\n    if (xs.isEmpty) None\n    else Some(xs.sum / xs.length)\n\n  def variance(xs: Seq[Double]): Option[Double] =\n    mean(xs) flatMap (m => mean(xs.map(x => math.pow(x - m, 2))))\n\n```\n\n\u304e\u3076\n\n\n## EXERCISE 4.3\n\n```\n// Q\n2\u9805\u95a2\u6570\u3092\u4f7f\u3063\u3066\u3001Option\u578b\u306e2\u3064\u306e\u5024\u3092\u7d50\u5408\u3059\u308b\u7dcf\u79f0\u95a2\u6570map2\u3092\u8a18\u8ff0\u305b\u3088\u3002\n\u3069\u3061\u3089\u304b\u306eOption\u5024\u304cNone\u306e\u5834\u5408\u306f\u3001\u623b\u308a\u5024\u3082None\u306b\u306a\u308b\u3002\n\u30b7\u30b0\u30cd\u30c1\u30e3\u306f\u4ee5\u4e0b\u306e\u3068\u304a\u308a\u3002\ndef map2[A,B,C](a: Option[A], b: Option[B])(f: (A, B) => C): Option[C]\n\n// answer\n  def map2[A,B,C](a: Option[A], b: Option[B])(f: (A, B) => C): Option[C] = (a,b) match {\n    case (Some(x), Some(y)) => Some(f(x,y))\n    case _ => None\n  }\n\n// \u516c\u5f0f\u306eanswer\ndef map2[A,B,C](a: Option[A], b: Option[B])(f: (A, B) => C): Option[C] =\n    a flatMap (aa => b map (bb => f(aa, bb)))\n```\n\n\u516c\u5f0f\u306eflatMap & map\u306e\u307b\u3046\u304c\u304b\u3063\u3053\u3044\u3044\n\n\n## EXERCISE 4.4\n\n```\n// Q\nOption\u306e\u30ea\u30b9\u30c8\u30921\u3064\u306eOption\u306b\u307e\u3068\u3081\u308bsequence\u95a2\u6570\u3092\u8a18\u8ff0\u305b\u3088\u3002\n\u65b0\u3057\u3044Option\u306b\u306f\u3001\u5143\u306e\u30ea\u30b9\u30c8\u306b\u542b\u307e\u308c\u3066\u3044\u308b\u3059\u3079\u3066\u306eSome\u5024\u306e\u30ea\u30b9\u30c8\u304c\u542b\u307e\u308c\u308b\u3002\n\u5143\u306e\u30ea\u30b9\u30c8\u306bNone\u304c1\u3064\u3067\u3082\u542b\u307e\u308c\u3066\u3044\u305f\u5834\u5408\u3001\u3053\u306e\u95a2\u6570\u306e\u7d50\u679c\u306fNone\u306b\u306a\u308b\u3002\n\u305d\u308c\u4ee5\u5916\u306e\u5834\u5408\u306f\u3001\u3059\u3079\u3066\u306e\u5024\u306e\u30ea\u30b9\u30c8\u3092\u542b\u3093\u3060Some\u306b\u306a\u308b\u3002\u30b7\u30b0\u30cd\u30c1\u30e3\u306f\u4ee5\u4e0b\u306e\u3068\u304a\u308a\u3002\ndef sequence[A](a: List[Option[A]]): Option[List[A]]\n\n// answer\n def sequence[A](a: List[Option[A]]): Option[List[A]] = {\n    @annotation.tailrec\n    def loop(l: List[Option[A]], x: Option[List[A]]): Option[List[A]] = {\n      l match {\n        case Some(h) :: List() => x.map(h :: _)\n        case Some(h) :: t => loop(t, x.map(h :: _))\n        case None :: _ => None\n        case _ => println(\"_\"); None\n      }\n    }\n    loop(a, Some(List())).map(_.reverse)\n  }\n\n// \u516c\u5f0f\u306eanswer\n  def sequence[A](a: List[Option[A]]): Option[List[A]] =\n    a match {\n      case Nil => Some(Nil)\n      case h :: t => h flatMap (hh => sequence(t) map (hh :: _))\n    }\n  /*\n  It can also be implemented using `foldRight` and `map2`. The type annotation on `foldRight` is needed here; otherwise\n  Scala wrongly infers the result type of the fold as `Some[Nil.type]` and reports a type error (try it!). This is an\n  unfortunate consequence of Scala using subtyping to encode algebraic data types.\n  */\n  def sequence_1[A](a: List[Option[A]]): Option[List[A]] =\n    a.foldRight[Option[List[A]]](Some(Nil))((x,y) => map2(x,y)(_ :: _))\n\n```\n\n2\u56de\u8d70\u67fb\u3057\u3066\u3044\u3066\u30a4\u30b1\u3066\u306a\u3044\u3002\u3002\n\n\n## EXERCISE 4.5\n\n```\n// Q\ntraverse\u95a2\u6570\u3092\u5b9f\u88c5\u305b\u3088\u3002map\u3068sequence\u3092\u5229\u7528\u3059\u308c\u3070\u7c21\u5358\u3060\u304c\u3001\u30ea\u30b9\u30c8\u30921\u56de\u3060\u3051\u8abf\u3079\u308b\u3001\u3088\u308a\u52b9\u7387\u306e\u3088\u3044\u5b9f\u88c5\u306b\u3059\u308b\u3053\u3068\u3002\n\u8981\u3059\u308b\u306b\u3001traverse\u306e\u89b3\u70b9\u304b\u3089sequence\u3092\u5b9f\u88c5\u3059\u308c\u3070\u826f\u3044\u3002\n\n// answer\n  def traverse[E,B,C](a: List[A])(f: A => Either[E,B]): Either[E,List[B]] =\n    a match {\n      case Nil => Right(Nil)\n      case h :: t => (f(h) map2 traverse(t)(f))(_ :: _) \n  }\n\n// \u516c\u5f0f\u306eanswer\n  def traverse[E,A,B](es: List[A])(f: A => Either[E, B]): Either[E, List[B]] = \n    es match {\n      case Nil => Right(Nil)\n      case h::t => (f(h) map2 traverse(t)(f))(_ :: _)\n    }\n  \n  def traverse_1[E,A,B](es: List[A])(f: A => Either[E, B]): Either[E, List[B]] = \n    es.foldRight[Either[E,List[B]]](Right(Nil))((a, b) => f(a).map2(b)(_ :: _))\n```\n\n4.4\u3092\u53c2\u8003\u306b\u3057\u305f\u3002\n\n## EXERCISE 4.6\n\n```\n// Q\nRight\u5024\u3092\u64cd\u4f5c\u3059\u308bmap,flatMap,orElse,map2\u3092Either\u306b\u8ffd\u52a0\u305b\u3088\u3002\ntrait Either[+E,+A] {\n def map[B](f: A => B): Either[E, B] = sys.error(\"todo\")\n\n def flatMap[EE >: E, B](f: A => Either[EE, B]): Either[EE, B] = sys.error(\"todo\")\n\n def orElse[EE >: E, B >: A](b: => Either[EE, B]): Either[EE, B] = sys.error(\"todo\")\n\n def map2[EE >: E, B, C](b: Either[EE, B])(f: (A, B) => C): Either[EE, C] = sys.error(\"todo\")\n}\n// answer\n trait Either[+E, +A] {\n  def map[B](f: A => B): Either[E, B] = this match {\n    case Right(x) => Right(f(x))\n    case Left(e) => Left(e)\n  }\n\n  def flatMap[EE >: E, B](f: A => Either[EE, B]): Either[EE, B] = this match {\n    case Right(x) => f(x)\n    case Left(e) => Left(e)\n  }\n\n\n  def orElse[EE >: E, B >: A](b: => Either[EE, B]): Either[EE, B] = this match {\n    case Right(x) => this\n    case Left(e) => b\n  }\n\n  def map2[EE >: E, B, C](b: Either[EE, B])(f: (A, B) => C): Either[EE, C] = for { x <- this; y <- b } yield f(x,y)\n\n}\n// \u516c\u5f0f\u306eanswer\nsealed trait Either[+E,+A] {\n def map[B](f: A => B): Either[E, B] = \n   this match {\n     case Right(a) => Right(f(a))\n     case Left(e) => Left(e)\n   }\n   \n def flatMap[EE >: E, B](f: A => Either[EE, B]): Either[EE, B] =\n   this match {\n     case Left(e) => Left(e)\n     case Right(a) => f(a)\n   }\n def orElse[EE >: E, AA >: A](b: => Either[EE, AA]): Either[EE, AA] =\n   this match {\n     case Left(_) => b\n     case Right(a) => Right(a)\n   }\n def map2[EE >: E, B, C](b: Either[EE, B])(f: (A, B) => C): \n   Either[EE, C] = for { a <- this; b1 <- b } yield f(a,b1)\n}\n```\n\nmap2\u304c\u5408\u3063\u3066\u305f\u306e\u6c17\u6301\u3061\u826f\u3044^q^\n\n\n## EXERCISE 4.7\n\n```\n// Q\nEither\u3067sequence\u3068traverse\u3092\u5b9f\u88c5\u305b\u3088\u3002\n\u3053\u308c\u3089\u306f\u3001\u30a8\u30e9\u30fc\u304c\u767a\u751f\u3057\u305f\u5834\u5408\u306b\u3001\u6700\u521d\u306b\u691c\u51fa\u3055\u308c\u305f\u30a8\u30e9\u30fc\u3092\u8fd4\u3059\u3082\u306e\u3068\u3059\u308b\u3002\n\ndef sequence[E,A](es: List[Either[E,A]]): Either[E,List[A]]\ndef traverse[E,A,B](as: List[A])(f: A => Either[E,B]): Either[E,List[B]]\n\n// answer\n  def traverse[E, A, B](es: List[A])(f: A => Either[E, B]): Either[E, List[B]] =\n    es match {\n      case Nil => Right(Nil)\n      case h :: t => (f(h) map2 traverse(t)(f))(_ :: _)\n    }\n\n  def sequence[E, A](es: List[Either[E, A]]): Either[E, List[A]] =\n    es match {\n      case Nil => Right(Nil)\n      case Left(h) :: _  => Left(h)\n      case h :: t => h flatMap (hh => sequence(t) map (hh :: _))\n    }\n\n// \u516c\u5f0f\u306eanswer\n  def traverse[E,A,B](es: List[A])(f: A => Either[E, B]): Either[E, List[B]] = \n    es match {\n      case Nil => Right(Nil)\n      case h::t => (f(h) map2 traverse(t)(f))(_ :: _)\n    }\n  \n  def traverse_1[E,A,B](es: List[A])(f: A => Either[E, B]): Either[E, List[B]] = \n    es.foldRight[Either[E,List[B]]](Right(Nil))((a, b) => f(a).map2(b)(_ :: _))\n  \n  def sequence[E,A](es: List[Either[E,A]]): Either[E,List[A]] = \n    traverse(es)(x => x)\n\n```\n\nsequence\u304b\u3063\u3053\u3088\u3044\u30fb\u30fb\u3002\n\n## EXERCISE 4.8\n\n```\n// Q\n\u30ea\u30b9\u30c84-10\u306e\u5b9f\u88c5\u3067\u306f\u3001\u540d\u524d\u3068\u5e74\u9f62\u304c\u4e21\u65b9\u3068\u3082\u7121\u52b9\u3067\u3042\u3063\u305f\u3068\u3057\u3066\u3082\u3001map2\u306f\u30a8\u30e9\u30fc\u30921\u3064\u3057\u304b\u5831\u544a\u3067\u304d\u306a\u3044\u3002\n\u4e21\u65b9\u306e\u30a8\u30e9\u30fc\u3092\u5831\u544a\u3059\u308b\u306b\u306f\u3001\u4f55\u3092\u5909\u66f4\u3059\u308b\u5fc5\u8981\u304c\u3042\u308b\u304b\u3002\nmap2\u3092\u5909\u66f4\u3059\u308b\u306e\u304b\u3001\u305d\u308c\u3068\u3082mkPerson\u306e\u30b7\u30b0\u30cd\u30c1\u30e3\u3092\u5909\u66f4\u3059\u308b\u306e\u304b\u3002\n\u3042\u308b\u3044\u306f\u3001\u65b0\u3057\u3044\u69cb\u9020\u3092\u8ffd\u52a0\u3057\u3066\u3001\u3053\u306e\u8981\u4ef6\u3092Either\u3088\u308a\u3082\u52b9\u679c\u7684\u306b\u6e80\u305f\u3059\u65b0\u3057\u3044\u30c7\u30fc\u30bf\u578b\u3092\u4f5c\u6210\u3059\u308b\u3053\u3068\u306f\u53ef\u80fd\u304b\u3002\n\u305d\u306e\u30c7\u30fc\u30bf\u578b\u3067\u306f\u3001orElse\u3001travase\u3001sequence\u306e\u632f\u308b\u821e\u3044\u306f\u3069\u306e\u3088\u3046\u306b\u5909\u5316\u3059\u308b\u304b\u3002\n\n// \u516c\u5f0f\u306eanswer\nThere are a number of variations on Option and Either. If we want to accumulate multiple errors, a simple\napproach is a new data type that lets us keep a list of errors in the data constructor that represents failures:\ntrait Partial[+A,+B]\ncase class Errors+A extends Partial[A,Nothing]\ncase class Success+B extends Partial[Nothing,B]\nThere is a type very similar to this called Validation in the Scalaz library. You can implement map, map2,\nsequence, and so on for this type in such a way that errors are accumulated when possible (flatMap is unable to\naccumulate errors--can you see why?). This idea can even be generalized further--we don't need to accumulate failing\nvalues into a list; we can accumulate values using any user-supplied binary function.\nIt's also possible to use Either[List[E],_] directly to accumulate errors, using different implementations of\nhelper functions like map2 and sequence.\n\n\n```\n", "tags": ["Scala", "\u95a2\u6570\u578b\u30d7\u30ed\u30b0\u30e9\u30df\u30f3\u30b0"]}