{"context": " More than 1 year has passed since last update.\n\nR\u306e\u95a2\u6570\u306e\u30bd\u30fc\u30b9\u30b3\u30fc\u30c9\u306e\u4e2d\u8eab\u3092\u898b\u308b\u65b9\u6cd5\n\n\u3010\u6982\u8981\u3011\n\n\u901a\u5e38\u3001\u95a2\u6570(\"\u5f15\u6570\") \u3068\u3044\u3046\u3088\u3046\u306b\u95a2\u6570\u540d\u306e\u5f8c\u308d\u306b\u62ec\u5f27\u3092\u3064\u3051\u3066\u3044\u307e\u3059\u3002\n\n\u62ec\u5f27\u3092\u8a18\u8ff0\u305b\u305a\u306b\u95a2\u6570\u540d\u3060\u3051\u3092\u5165\u529b\u3057\u3066 Enter \u30ad\u30fc\u3092\u62bc\u3059\u3068\u3001\u95a2\u6570\u306e\u4e2d\u8eab\u306e\u30bd\u30fc\u30b9\u30b3\u30fc\u30c9\u3092\u8868\u793a\u3055\u305b\u308b\u3053\u3068\u304c\u3067\u304d\u307e\u3059\n\n\u95a2\u6570\u540d library()\n\nlibrary\n\n## function (package, help, pos = 2, lib.loc = NULL, character.only = FALSE, \n##     logical.return = FALSE, warn.conflicts = TRUE, quietly = FALSE, \n##     verbose = getOption(\"verbose\")) \n## {\n##     testRversion <- function(pkgInfo, pkgname, pkgpath) {\n##         if (is.null(built <- pkgInfo$Built)) \n##             stop(gettextf(\"package %s has not been installed properly\\n\", \n##                 sQuote(pkgname)), call. = FALSE, domain = NA)\n##         R_version_built_under <- as.numeric_version(built$R)\n##         if (R_version_built_under < \"3.0.0\") \n##             stop(gettextf(\"package %s was built before R 3.0.0: please re-install it\", \n##                 sQuote(pkgname)), call. = FALSE, domain = NA)\n##         current <- getRversion()\n##         if (length(Rdeps <- pkgInfo$Rdepends2)) {\n##             for (dep in Rdeps) if (length(dep) > 1L) {\n##                 target <- dep$version\n##                 res <- if (is.character(target)) {\n##                   do.call(dep$op, list(as.numeric(R.version[[\"svn rev\"]]), \n##                     as.numeric(sub(\"^r\", \"\", dep$version))))\n##                 }\n##                 else {\n##                   do.call(dep$op, list(current, as.numeric_version(target)))\n##                 }\n##                 if (!res) \n##                   stop(gettextf(\"This is R %s, package %s needs %s %s\", \n##                     current, sQuote(pkgname), dep$op, target), \n##                     call. = FALSE, domain = NA)\n##             }\n##         }\n##         if (R_version_built_under > current) \n##             warning(gettextf(\"package %s was built under R version %s\", \n##                 sQuote(pkgname), as.character(built$R)), call. = FALSE, \n##                 domain = NA)\n##         platform <- built$Platform\n##         r_arch <- .Platform$r_arch\n##         if (.Platform$OS.type == \"unix\") {\n##             if (!nzchar(r_arch) && length(grep(\"\\\\w\", platform)) && \n##                 !testPlatformEquivalence(platform, R.version$platform)) \n##                 stop(gettextf(\"package %s was built for %s\", \n##                   sQuote(pkgname), platform), call. = FALSE, \n##                   domain = NA)\n##         }\n##         else {\n##             if (nzchar(platform) && !grepl(\"mingw\", platform)) \n##                 stop(gettextf(\"package %s was built for %s\", \n##                   sQuote(pkgname), platform), call. = FALSE, \n##                   domain = NA)\n##         }\n##         if (nzchar(r_arch) && file.exists(file.path(pkgpath, \n##             \"libs\")) && !file.exists(file.path(pkgpath, \"libs\", \n##             r_arch))) \n##             stop(gettextf(\"package %s is not installed for 'arch = %s'\", \n##                 sQuote(pkgname), r_arch), call. = FALSE, domain = NA)\n##     }\n##     checkLicense <- function(pkg, pkgInfo, pkgPath) {\n##         L <- tools:::analyze_license(pkgInfo$DESCRIPTION[\"License\"])\n##         if (!L$is_empty && !L$is_verified) {\n##             site_file <- path.expand(file.path(R.home(\"etc\"), \n##                 \"licensed.site\"))\n##             if (file.exists(site_file) && pkg %in% readLines(site_file)) \n##                 return()\n##             personal_file <- path.expand(\"~/.R/licensed\")\n##             if (file.exists(personal_file)) {\n##                 agreed <- readLines(personal_file)\n##                 if (pkg %in% agreed) \n##                   return()\n##             }\n##             else agreed <- character()\n##             if (!interactive()) \n##                 stop(gettextf(\"package %s has a license that you need to accept in an interactive session\", \n##                   sQuote(pkg)), domain = NA)\n##             lfiles <- file.path(pkgpath, c(\"LICENSE\", \"LICENCE\"))\n##             lfiles <- lfiles[file.exists(lfiles)]\n##             if (length(lfiles)) {\n##                 message(gettextf(\"package %s has a license that you need to accept after viewing\", \n##                   sQuote(pkg)), domain = NA)\n##                 readline(\"press RETURN to view license\")\n##                 encoding <- pkgInfo$DESCRIPTION[\"Encoding\"]\n##                 if (is.na(encoding)) \n##                   encoding <- \"\"\n##                 if (encoding == \"latin1\") \n##                   encoding <- \"cp1252\"\n##                 file.show(lfiles[1L], encoding = encoding)\n##             }\n##             else {\n##                 message(gettextf(\"package %s has a license that you need to accept:\\naccording to the DESCRIPTION file it is\", \n##                   sQuote(pkg)), domain = NA)\n##                 message(pkgInfo$DESCRIPTION[\"License\"], domain = NA)\n##             }\n##             choice <- menu(c(\"accept\", \"decline\"), title = paste(\"License for\", \n##                 sQuote(pkg)))\n##             if (choice != 1) \n##                 stop(gettextf(\"license for package %s not accepted\", \n##                   sQuote(package)), domain = NA, call. = FALSE)\n##             dir.create(dirname(personal_file), showWarnings = FALSE)\n##             writeLines(c(agreed, pkg), personal_file)\n##         }\n##     }\n##     checkNoGenerics <- function(env, pkg) {\n##         nenv <- env\n##         ns <- .getNamespace(as.name(pkg))\n##         if (!is.null(ns)) \n##             nenv <- asNamespace(ns)\n##         if (exists(\".noGenerics\", envir = nenv, inherits = FALSE)) \n##             TRUE\n##         else {\n##             length(objects(env, pattern = \"^\\\\.__[MT]\", all.names = TRUE)) == \n##                 0L\n##         }\n##     }\n##     checkConflicts <- function(package, pkgname, pkgpath, nogenerics, \n##         env) {\n##         dont.mind <- c(\"last.dump\", \"last.warning\", \".Last.value\", \n##             \".Random.seed\", \".Last.lib\", \".onDetach\", \".packageName\", \n##             \".noGenerics\", \".required\", \".no_S3_generics\", \".Depends\", \n##             \".requireCachedGenerics\")\n##         sp <- search()\n##         lib.pos <- match(pkgname, sp)\n##         ob <- objects(lib.pos, all.names = TRUE)\n##         if (!nogenerics) {\n##             these <- ob[substr(ob, 1L, 6L) == \".__T__\"]\n##             gen <- gsub(\".__T__(.*):([^:]+)\", \"\\\\1\", these)\n##             from <- gsub(\".__T__(.*):([^:]+)\", \"\\\\2\", these)\n##             gen <- gen[from != package]\n##             ob <- ob[!(ob %in% gen)]\n##         }\n##         fst <- TRUE\n##         ipos <- seq_along(sp)[-c(lib.pos, match(c(\"Autoloads\", \n##             \"CheckExEnv\"), sp, 0L))]\n##         for (i in ipos) {\n##             obj.same <- match(objects(i, all.names = TRUE), ob, \n##                 nomatch = 0L)\n##             if (any(obj.same > 0)) {\n##                 same <- ob[obj.same]\n##                 same <- same[!(same %in% dont.mind)]\n##                 Classobjs <- grep(\"^\\\\.__\", same)\n##                 if (length(Classobjs)) \n##                   same <- same[-Classobjs]\n##                 same.isFn <- function(where) vapply(same, exists, \n##                   NA, where = where, mode = \"function\", inherits = FALSE)\n##                 same <- same[same.isFn(i) == same.isFn(lib.pos)]\n##                 not.Ident <- function(ch, TRAFO = identity, ...) vapply(ch, \n##                   function(.) !identical(TRAFO(get(., i)), TRAFO(get(., \n##                     lib.pos)), ...), NA)\n##                 if (length(same)) \n##                   same <- same[not.Ident(same)]\n##                 if (length(same) && identical(sp[i], \"package:base\")) \n##                   same <- same[not.Ident(same, ignore.environment = TRUE)]\n##                 if (length(same)) {\n##                   if (fst) {\n##                     fst <- FALSE\n##                     packageStartupMessage(gettextf(\"\\nAttaching package: %s\\n\", \n##                       sQuote(package)), domain = NA)\n##                   }\n##                   objs <- strwrap(paste(same, collapse = \", \"), \n##                     indent = 4, exdent = 4)\n##                   msg <- sprintf(ngettext(length(objs), \"The following object is masked %s %s:\\n\\n%s\\n\", \n##                     \"The following objects are masked %s %s:\\n\\n%s\\n\"), \n##                     if (i < lib.pos) \n##                       \"_by_\"\n##                     else \"from\", sQuote(sp[i]), paste(objs, collapse = \"\\n\"))\n##                   packageStartupMessage(msg)\n##                 }\n##             }\n##         }\n##     }\n##     if (verbose && quietly) \n##         message(\"'verbose' and 'quietly' are both true; being verbose then ..\")\n##     if (!missing(package)) {\n##         if (is.null(lib.loc)) \n##             lib.loc <- .libPaths()\n##         lib.loc <- lib.loc[file.info(lib.loc)$isdir %in% TRUE]\n##         if (!character.only) \n##             package <- as.character(substitute(package))\n##         if (length(package) != 1L) \n##             stop(\"'package' must be of length 1\")\n##         if (is.na(package) || (package == \"\")) \n##             stop(\"invalid package name\")\n##         pkgname <- paste(\"package\", package, sep = \":\")\n##         newpackage <- is.na(match(pkgname, search()))\n##         if (newpackage) {\n##             pkgpath <- find.package(package, lib.loc, quiet = TRUE, \n##                 verbose = verbose)\n##             if (length(pkgpath) == 0L) {\n##                 txt <- if (length(lib.loc)) \n##                   gettextf(\"there is no package called %s\", sQuote(package))\n##                 else gettext(\"no library trees found in 'lib.loc'\")\n##                 if (logical.return) {\n##                   warning(txt, domain = NA)\n##                   return(FALSE)\n##                 }\n##                 else stop(txt, domain = NA)\n##             }\n##             which.lib.loc <- normalizePath(dirname(pkgpath), \n##                 \"/\", TRUE)\n##             pfile <- system.file(\"Meta\", \"package.rds\", package = package, \n##                 lib.loc = which.lib.loc)\n##             if (!nzchar(pfile)) \n##                 stop(gettextf(\"%s is not a valid installed package\", \n##                   sQuote(package)), domain = NA)\n##             pkgInfo <- readRDS(pfile)\n##             testRversion(pkgInfo, package, pkgpath)\n##             if (!package %in% c(\"datasets\", \"grDevices\", \"graphics\", \n##                 \"methods\", \"splines\", \"stats\", \"stats4\", \"tcltk\", \n##                 \"tools\", \"utils\") && isTRUE(getOption(\"checkPackageLicense\", \n##                 FALSE))) \n##                 checkLicense(package, pkgInfo, pkgpath)\n##             if (is.character(pos)) {\n##                 npos <- match(pos, search())\n##                 if (is.na(npos)) {\n##                   warning(gettextf(\"%s not found on search path, using pos = 2\", \n##                     sQuote(pos)), domain = NA)\n##                   pos <- 2\n##                 }\n##                 else pos <- npos\n##             }\n##             .getRequiredPackages2(pkgInfo, quietly = quietly)\n##             deps <- unique(names(pkgInfo$Depends))\n##             if (packageHasNamespace(package, which.lib.loc)) {\n##                 tt <- try({\n##                   ns <- loadNamespace(package, c(which.lib.loc, \n##                     lib.loc))\n##                   env <- attachNamespace(ns, pos = pos, deps)\n##                 })\n##                 if (inherits(tt, \"try-error\")) \n##                   if (logical.return) \n##                     return(FALSE)\n##                   else stop(gettextf(\"package or namespace load failed for %s\", \n##                     sQuote(package)), call. = FALSE, domain = NA)\n##                 else {\n##                   on.exit(detach(pos = pos))\n##                   nogenerics <- !.isMethodsDispatchOn() || checkNoGenerics(env, \n##                     package)\n##                   if (warn.conflicts && !exists(\".conflicts.OK\", \n##                     envir = env, inherits = FALSE)) \n##                     checkConflicts(package, pkgname, pkgpath, \n##                       nogenerics, ns)\n##                   on.exit()\n##                   if (logical.return) \n##                     return(TRUE)\n##                   else return(invisible(.packages()))\n##                 }\n##             }\n##             else stop(gettextf(\"package %s does not have a namespace and should be re-installed\", \n##                 sQuote(package)), domain = NA)\n##         }\n##         if (verbose && !newpackage) \n##             warning(gettextf(\"package %s already present in search()\", \n##                 sQuote(package)), domain = NA)\n##     }\n##     else if (!missing(help)) {\n##         if (!character.only) \n##             help <- as.character(substitute(help))\n##         pkgName <- help[1L]\n##         pkgPath <- find.package(pkgName, lib.loc, verbose = verbose)\n##         docFiles <- c(file.path(pkgPath, \"Meta\", \"package.rds\"), \n##             file.path(pkgPath, \"INDEX\"))\n##         if (file.exists(vignetteIndexRDS <- file.path(pkgPath, \n##             \"Meta\", \"vignette.rds\"))) \n##             docFiles <- c(docFiles, vignetteIndexRDS)\n##         pkgInfo <- vector(\"list\", 3L)\n##         readDocFile <- function(f) {\n##             if (basename(f) %in% \"package.rds\") {\n##                 txt <- readRDS(f)$DESCRIPTION\n##                 if (\"Encoding\" %in% names(txt)) {\n##                   to <- if (Sys.getlocale(\"LC_CTYPE\") == \"C\") \n##                     \"ASCII//TRANSLIT\"\n##                   else \"\"\n##                   tmp <- try(iconv(txt, from = txt[\"Encoding\"], \n##                     to = to))\n##                   if (!inherits(tmp, \"try-error\")) \n##                     txt <- tmp\n##                   else warning(\"'DESCRIPTION' has an 'Encoding' field and re-encoding is not possible\", \n##                     call. = FALSE)\n##                 }\n##                 nm <- paste0(names(txt), \":\")\n##                 formatDL(nm, txt, indent = max(nchar(nm, \"w\")) + \n##                   3)\n##             }\n##             else if (basename(f) %in% \"vignette.rds\") {\n##                 txt <- readRDS(f)\n##                 if (is.data.frame(txt) && nrow(txt)) \n##                   cbind(basename(gsub(\"\\\\.[[:alpha:]]+$\", \"\", \n##                     txt$File)), paste(txt$Title, paste0(rep.int(\"(source\", \n##                     NROW(txt)), ifelse(txt$PDF != \"\", \", pdf\", \n##                     \"\"), \")\")))\n##                 else NULL\n##             }\n##             else readLines(f)\n##         }\n##         for (i in which(file.exists(docFiles))) pkgInfo[[i]] <- readDocFile(docFiles[i])\n##         y <- list(name = pkgName, path = pkgPath, info = pkgInfo)\n##         class(y) <- \"packageInfo\"\n##         return(y)\n##     }\n##     else {\n##         if (is.null(lib.loc)) \n##             lib.loc <- .libPaths()\n##         db <- matrix(character(), nrow = 0L, ncol = 3L)\n##         nopkgs <- character()\n##         for (lib in lib.loc) {\n##             a <- .packages(all.available = TRUE, lib.loc = lib)\n##             for (i in sort(a)) {\n##                 file <- system.file(\"Meta\", \"package.rds\", package = i, \n##                   lib.loc = lib)\n##                 title <- if (file != \"\") {\n##                   txt <- readRDS(file)\n##                   if (is.list(txt)) \n##                     txt <- txt$DESCRIPTION\n##                   if (\"Encoding\" %in% names(txt)) {\n##                     to <- if (Sys.getlocale(\"LC_CTYPE\") == \"C\") \n##                       \"ASCII//TRANSLIT\"\n##                     else \"\"\n##                     tmp <- try(iconv(txt, txt[\"Encoding\"], to, \n##                       \"?\"))\n##                     if (!inherits(tmp, \"try-error\")) \n##                       txt <- tmp\n##                     else warning(\"'DESCRIPTION' has an 'Encoding' field and re-encoding is not possible\", \n##                       call. = FALSE)\n##                   }\n##                   txt[\"Title\"]\n##                 }\n##                 else NA\n##                 if (is.na(title)) \n##                   title <- \" ** No title available ** \"\n##                 db <- rbind(db, cbind(i, lib, title))\n##             }\n##             if (length(a) == 0L) \n##                 nopkgs <- c(nopkgs, lib)\n##         }\n##         dimnames(db) <- list(NULL, c(\"Package\", \"LibPath\", \"Title\"))\n##         if (length(nopkgs) && !missing(lib.loc)) {\n##             pkglist <- paste(sQuote(nopkgs), collapse = \", \")\n##             msg <- sprintf(ngettext(length(nopkgs), \"library %s contains no packages\", \n##                 \"libraries %s contain no packages\"), pkglist)\n##             warning(msg, domain = NA)\n##         }\n##         y <- list(header = NULL, results = db, footer = NULL)\n##         class(y) <- \"libraryIQR\"\n##         return(y)\n##     }\n##     if (logical.return) \n##         TRUE\n##     else invisible(.packages())\n## }\n## <bytecode: 0x0000000006b09310>\n## <environment: namespace:base>\n\n\n\u95a2\u6570\u540d require()\n\nrequire\n\n## function (package, lib.loc = NULL, quietly = FALSE, warn.conflicts = TRUE, \n##     character.only = FALSE) \n## {\n##     if (!character.only) \n##         package <- as.character(substitute(package))\n##     loaded <- paste(\"package\", package, sep = \":\") %in% search()\n##     if (!loaded) {\n##         if (!quietly) \n##             packageStartupMessage(gettextf(\"Loading required package: %s\", \n##                 package), domain = NA)\n##         value <- tryCatch(library(package, lib.loc = lib.loc, \n##             character.only = TRUE, logical.return = TRUE, warn.conflicts = warn.conflicts, \n##             quietly = quietly), error = function(e) e)\n##         if (inherits(value, \"error\")) {\n##             if (!quietly) {\n##                 msg <- conditionMessage(value)\n##                 cat(\"Failed with error:  \", sQuote(msg), \"\\n\", \n##                   file = stderr(), sep = \"\")\n##                 .Internal(printDeferredWarnings())\n##             }\n##             return(invisible(FALSE))\n##         }\n##         if (!value) \n##             return(invisible(FALSE))\n##     }\n##     else value <- TRUE\n##     invisible(value)\n## }\n## <bytecode: 0x0000000006e18828>\n## <environment: namespace:base>\n\n\n\u95a2\u6570\u540d cor()\n\ncor\n\n## function (x, y = NULL, use = \"everything\", method = c(\"pearson\", \n##     \"kendall\", \"spearman\")) \n## {\n##     na.method <- pmatch(use, c(\"all.obs\", \"complete.obs\", \"pairwise.complete.obs\", \n##         \"everything\", \"na.or.complete\"))\n##     if (is.na(na.method)) \n##         stop(\"invalid 'use' argument\")\n##     method <- match.arg(method)\n##     if (is.data.frame(y)) \n##         y <- as.matrix(y)\n##     if (is.data.frame(x)) \n##         x <- as.matrix(x)\n##     if (!is.matrix(x) && is.null(y)) \n##         stop(\"supply both 'x' and 'y' or a matrix-like 'x'\")\n##     if (!(is.numeric(x) || is.logical(x))) \n##         stop(\"'x' must be numeric\")\n##     stopifnot(is.atomic(x))\n##     if (!is.null(y)) {\n##         if (!(is.numeric(y) || is.logical(y))) \n##             stop(\"'y' must be numeric\")\n##         stopifnot(is.atomic(y))\n##     }\n##     Rank <- function(u) {\n##         if (length(u) == 0L) \n##             u\n##         else if (is.matrix(u)) {\n##             if (nrow(u) > 1L) \n##                 apply(u, 2L, rank, na.last = \"keep\")\n##             else row(u)\n##         }\n##         else rank(u, na.last = \"keep\")\n##     }\n##     if (method == \"pearson\") \n##         .Call(C_cor, x, y, na.method, FALSE)\n##     else if (na.method %in% c(2L, 5L)) {\n##         if (is.null(y)) {\n##             .Call(C_cor, Rank(na.omit(x)), NULL, na.method, method == \n##                 \"kendall\")\n##         }\n##         else {\n##             nas <- attr(na.omit(cbind(x, y)), \"na.action\")\n##             dropNA <- function(x, nas) {\n##                 if (length(nas)) {\n##                   if (is.matrix(x)) \n##                     x[-nas, , drop = FALSE]\n##                   else x[-nas]\n##                 }\n##                 else x\n##             }\n##             .Call(C_cor, Rank(dropNA(x, nas)), Rank(dropNA(y, \n##                 nas)), na.method, method == \"kendall\")\n##         }\n##     }\n##     else if (na.method != 3L) {\n##         x <- Rank(x)\n##         if (!is.null(y)) \n##             y <- Rank(y)\n##         .Call(C_cor, x, y, na.method, method == \"kendall\")\n##     }\n##     else {\n##         if (is.null(y)) {\n##             ncy <- ncx <- ncol(x)\n##             if (ncx == 0) \n##                 stop(\"'x' is empty\")\n##             r <- matrix(0, nrow = ncx, ncol = ncy)\n##             for (i in seq_len(ncx)) {\n##                 for (j in seq_len(i)) {\n##                   x2 <- x[, i]\n##                   y2 <- x[, j]\n##                   ok <- complete.cases(x2, y2)\n##                   x2 <- rank(x2[ok])\n##                   y2 <- rank(y2[ok])\n##                   r[i, j] <- if (any(ok)) \n##                     .Call(C_cor, x2, y2, 1L, method == \"kendall\")\n##                   else NA\n##                 }\n##             }\n##             r <- r + t(r) - diag(diag(r))\n##             rownames(r) <- colnames(x)\n##             colnames(r) <- colnames(x)\n##             r\n##         }\n##         else {\n##             if (length(x) == 0L || length(y) == 0L) \n##                 stop(\"both 'x' and 'y' must be non-empty\")\n##             matrix_result <- is.matrix(x) || is.matrix(y)\n##             if (!is.matrix(x)) \n##                 x <- matrix(x, ncol = 1L)\n##             if (!is.matrix(y)) \n##                 y <- matrix(y, ncol = 1L)\n##             ncx <- ncol(x)\n##             ncy <- ncol(y)\n##             r <- matrix(0, nrow = ncx, ncol = ncy)\n##             for (i in seq_len(ncx)) {\n##                 for (j in seq_len(ncy)) {\n##                   x2 <- x[, i]\n##                   y2 <- y[, j]\n##                   ok <- complete.cases(x2, y2)\n##                   x2 <- rank(x2[ok])\n##                   y2 <- rank(y2[ok])\n##                   r[i, j] <- if (any(ok)) \n##                     .Call(C_cor, x2, y2, 1L, method == \"kendall\")\n##                   else NA\n##                 }\n##             }\n##             rownames(r) <- colnames(x)\n##             colnames(r) <- colnames(y)\n##             if (matrix_result) \n##                 r\n##             else drop(r)\n##         }\n##     }\n## }\n## <bytecode: 0x00000000080a9410>\n## <environment: namespace:stats>\n\n\n\u95a2\u6570\u540d lm()\n\nlm\n\n## function (formula, data, subset, weights, na.action, method = \"qr\", \n##     model = TRUE, x = FALSE, y = FALSE, qr = TRUE, singular.ok = TRUE, \n##     contrasts = NULL, offset, ...) \n## {\n##     ret.x <- x\n##     ret.y <- y\n##     cl <- match.call()\n##     mf <- match.call(expand.dots = FALSE)\n##     m <- match(c(\"formula\", \"data\", \"subset\", \"weights\", \"na.action\", \n##         \"offset\"), names(mf), 0L)\n##     mf <- mf[c(1L, m)]\n##     mf$drop.unused.levels <- TRUE\n##     mf[[1L]] <- as.name(\"model.frame\")\n##     mf <- eval(mf, parent.frame())\n##     if (method == \"model.frame\") \n##         return(mf)\n##     else if (method != \"qr\") \n##         warning(gettextf(\"method = '%s' is not supported. Using 'qr'\", \n##             method), domain = NA)\n##     mt <- attr(mf, \"terms\")\n##     y <- model.response(mf, \"numeric\")\n##     w <- as.vector(model.weights(mf))\n##     if (!is.null(w) && !is.numeric(w)) \n##         stop(\"'weights' must be a numeric vector\")\n##     offset <- as.vector(model.offset(mf))\n##     if (!is.null(offset)) {\n##         if (length(offset) != NROW(y)) \n##             stop(gettextf(\"number of offsets is %d, should equal %d (number of observations)\", \n##                 length(offset), NROW(y)), domain = NA)\n##     }\n##     if (is.empty.model(mt)) {\n##         x <- NULL\n##         z <- list(coefficients = if (is.matrix(y)) matrix(, 0, \n##             3) else numeric(), residuals = y, fitted.values = 0 * \n##             y, weights = w, rank = 0L, df.residual = if (!is.null(w)) sum(w != \n##             0) else if (is.matrix(y)) nrow(y) else length(y))\n##         if (!is.null(offset)) {\n##             z$fitted.values <- offset\n##             z$residuals <- y - offset\n##         }\n##     }\n##     else {\n##         x <- model.matrix(mt, mf, contrasts)\n##         z <- if (is.null(w)) \n##             lm.fit(x, y, offset = offset, singular.ok = singular.ok, \n##                 ...)\n##         else lm.wfit(x, y, w, offset = offset, singular.ok = singular.ok, \n##             ...)\n##     }\n##     class(z) <- c(if (is.matrix(y)) \"mlm\", \"lm\")\n##     z$na.action <- attr(mf, \"na.action\")\n##     z$offset <- offset\n##     z$contrasts <- attr(x, \"contrasts\")\n##     z$xlevels <- .getXlevels(mt, mf)\n##     z$call <- cl\n##     z$terms <- mt\n##     if (model) \n##         z$model <- mf\n##     if (ret.x) \n##         z$x <- x\n##     if (ret.y) \n##         z$y <- y\n##     if (!qr) \n##         z$qr <- NULL\n##     z\n## }\n## <bytecode: 0x0000000008044ad8>\n## <environment: namespace:stats>\n\n\n\u95a2\u6570\u540d nls()\n\nnls\n\n## function (formula, data = parent.frame(), start, control = nls.control(), \n##     algorithm = c(\"default\", \"plinear\", \"port\"), trace = FALSE, \n##     subset, weights, na.action, model = FALSE, lower = -Inf, \n##     upper = Inf, ...) \n## {\n##     formula <- as.formula(formula)\n##     algorithm <- match.arg(algorithm)\n##     if (!is.list(data) && !is.environment(data)) \n##         stop(\"'data' must be a list or an environment\")\n##     mf <- match.call()\n##     varNames <- all.vars(formula)\n##     if (length(formula) == 2L) {\n##         formula[[3L]] <- formula[[2L]]\n##         formula[[2L]] <- 0\n##     }\n##     form2 <- formula\n##     form2[[2L]] <- 0\n##     varNamesRHS <- all.vars(form2)\n##     mWeights <- missing(weights)\n##     pnames <- if (missing(start)) {\n##         if (!is.null(attr(data, \"parameters\"))) {\n##             names(attr(data, \"parameters\"))\n##         }\n##         else {\n##             cll <- formula[[length(formula)]]\n##             func <- get(as.character(cll[[1L]]))\n##             if (!is.null(pn <- attr(func, \"pnames\"))) \n##                 as.character(as.list(match.call(func, call = cll))[-1L][pn])\n##         }\n##     }\n##     else names(start)\n##     env <- environment(formula)\n##     if (is.null(env)) \n##         env <- parent.frame()\n##     if (length(pnames)) \n##         varNames <- varNames[is.na(match(varNames, pnames))]\n##     lenVar <- function(var) tryCatch(length(eval(as.name(var), \n##         data, env)), error = function(e) -1)\n##     if (length(varNames)) {\n##         n <- sapply(varNames, lenVar)\n##         if (any(not.there <- n == -1)) {\n##             nnn <- names(n[not.there])\n##             if (missing(start)) {\n##                 if (algorithm == \"plinear\") \n##                   stop(\"no starting values specified\")\n##                 warning(\"No starting values specified for some parameters.\\n\", \n##                   \"Initializing \", paste(sQuote(nnn), collapse = \", \"), \n##                   \" to '1.'.\\n\", \"Consider specifying 'start' or using a selfStart model\", \n##                   domain = NA)\n##                 start <- setNames(as.list(rep(1, length(nnn))), \n##                   nnn)\n##                 varNames <- varNames[i <- is.na(match(varNames, \n##                   nnn))]\n##                 n <- n[i]\n##             }\n##             else stop(gettextf(\"parameters without starting value in 'data': %s\", \n##                 paste(nnn, collapse = \", \")), domain = NA)\n##         }\n##     }\n##     else {\n##         if (length(pnames) && any((np <- sapply(pnames, lenVar)) == \n##             -1)) {\n##             message(sprintf(ngettext(sum(np == -1), \"fitting parameter %s without any variables\", \n##                 \"fitting parameters %s without any variables\"), \n##                 paste(sQuote(pnames[np == -1]), collapse = \", \")), \n##                 domain = NA)\n##             n <- integer()\n##         }\n##         else stop(\"no parameters to fit\")\n##     }\n##     respLength <- length(eval(formula[[2L]], data, env))\n##     if (length(n) > 0L) {\n##         varIndex <- n%%respLength == 0\n##         if (is.list(data) && diff(range(n[names(n) %in% names(data)])) > \n##             0) {\n##             mf <- data\n##             if (!missing(subset)) \n##                 warning(\"argument 'subset' will be ignored\")\n##             if (!missing(na.action)) \n##                 warning(\"argument 'na.action' will be ignored\")\n##             if (missing(start)) \n##                 start <- getInitial(formula, mf)\n##             startEnv <- new.env(hash = FALSE, parent = environment(formula))\n##             for (i in names(start)) assign(i, start[[i]], envir = startEnv)\n##             rhs <- eval(formula[[3L]], data, startEnv)\n##             n <- NROW(rhs)\n##             wts <- if (mWeights) \n##                 rep(1, n)\n##             else eval(substitute(weights), data, environment(formula))\n##         }\n##         else {\n##             mf$formula <- as.formula(paste(\"~\", paste(varNames[varIndex], \n##                 collapse = \"+\")), env = environment(formula))\n##             mf$start <- mf$control <- mf$algorithm <- mf$trace <- mf$model <- NULL\n##             mf$lower <- mf$upper <- NULL\n##             mf[[1L]] <- as.name(\"model.frame\")\n##             mf <- eval.parent(mf)\n##             n <- nrow(mf)\n##             mf <- as.list(mf)\n##             wts <- if (!mWeights) \n##                 model.weights(mf)\n##             else rep(1, n)\n##         }\n##         if (any(wts < 0 | is.na(wts))) \n##             stop(\"missing or negative weights not allowed\")\n##     }\n##     else {\n##         varIndex <- logical()\n##         mf <- list(0)\n##         wts <- numeric()\n##     }\n##     if (missing(start)) \n##         start <- getInitial(formula, mf)\n##     for (var in varNames[!varIndex]) mf[[var]] <- eval(as.name(var), \n##         data, env)\n##     varNamesRHS <- varNamesRHS[varNamesRHS %in% varNames[varIndex]]\n##     m <- switch(algorithm, plinear = nlsModel.plinear(formula, \n##         mf, start, wts), port = nlsModel(formula, mf, start, \n##         wts, upper), nlsModel(formula, mf, start, wts))\n##     ctrl <- nls.control()\n##     if (!missing(control)) {\n##         control <- as.list(control)\n##         ctrl[names(control)] <- control\n##     }\n##     if (algorithm != \"port\") {\n##         if (!missing(lower) || !missing(upper)) \n##             warning(\"upper and lower bounds ignored unless algorithm = \\\"port\\\"\")\n##         convInfo <- .Call(C_nls_iter, m, ctrl, trace)\n##         nls.out <- list(m = m, convInfo = convInfo, data = substitute(data), \n##             call = match.call())\n##     }\n##     else {\n##         pfit <- nls_port_fit(m, start, lower, upper, control, \n##             trace, give.v = TRUE)\n##         iv <- pfit[[\"iv\"]]\n##         msg.nls <- port_msg(iv[1L])\n##         conv <- (iv[1L] %in% 3:6)\n##         if (!conv) {\n##             msg <- paste(\"Convergence failure:\", msg.nls)\n##             if (ctrl$warnOnly) \n##                 warning(msg)\n##             else stop(msg)\n##         }\n##         v. <- port_get_named_v(pfit[[\"v\"]])\n##         cInfo <- list(isConv = conv, finIter = iv[31L], finTol = v.[[\"NREDUC\"]], \n##             nEval = c(`function` = iv[6L], gradient = iv[30L]), \n##             stopCode = iv[1L], stopMessage = msg.nls)\n##         cl <- match.call()\n##         cl$lower <- lower\n##         cl$upper <- upper\n##         nls.out <- list(m = m, data = substitute(data), call = cl, \n##             convInfo = cInfo, convergence = as.integer(!conv), \n##             message = msg.nls)\n##     }\n##     nls.out$call$algorithm <- algorithm\n##     nls.out$call$control <- ctrl\n##     nls.out$call$trace <- trace\n##     nls.out$na.action <- attr(mf, \"na.action\")\n##     nls.out$dataClasses <- attr(attr(mf, \"terms\"), \"dataClasses\")[varNamesRHS]\n##     if (model) \n##         nls.out$model <- mf\n##     if (!mWeights) \n##         nls.out$weights <- wts\n##     nls.out$control <- control\n##     class(nls.out) <- \"nls\"\n##     nls.out\n## }\n## <bytecode: 0x0000000008039d78>\n## <environment: namespace:stats>\n\n\n\u95a2\u6570\u540d glm()\n\nglm\n\n## function (formula, family = gaussian, data, weights, subset, \n##     na.action, start = NULL, etastart, mustart, offset, control = list(...), \n##     model = TRUE, method = \"glm.fit\", x = FALSE, y = TRUE, contrasts = NULL, \n##     ...) \n## {\n##     call <- match.call()\n##     if (is.character(family)) \n##         family <- get(family, mode = \"function\", envir = parent.frame())\n##     if (is.function(family)) \n##         family <- family()\n##     if (is.null(family$family)) {\n##         print(family)\n##         stop(\"'family' not recognized\")\n##     }\n##     if (missing(data)) \n##         data <- environment(formula)\n##     mf <- match.call(expand.dots = FALSE)\n##     m <- match(c(\"formula\", \"data\", \"subset\", \"weights\", \"na.action\", \n##         \"etastart\", \"mustart\", \"offset\"), names(mf), 0L)\n##     mf <- mf[c(1L, m)]\n##     mf$drop.unused.levels <- TRUE\n##     mf[[1L]] <- as.name(\"model.frame\")\n##     mf <- eval(mf, parent.frame())\n##     if (identical(method, \"model.frame\")) \n##         return(mf)\n##     if (!is.character(method) && !is.function(method)) \n##         stop(\"invalid 'method' argument\")\n##     if (identical(method, \"glm.fit\")) \n##         control <- do.call(\"glm.control\", control)\n##     mt <- attr(mf, \"terms\")\n##     Y <- model.response(mf, \"any\")\n##     if (length(dim(Y)) == 1L) {\n##         nm <- rownames(Y)\n##         dim(Y) <- NULL\n##         if (!is.null(nm)) \n##             names(Y) <- nm\n##     }\n##     X <- if (!is.empty.model(mt)) \n##         model.matrix(mt, mf, contrasts)\n##     else matrix(, NROW(Y), 0L)\n##     weights <- as.vector(model.weights(mf))\n##     if (!is.null(weights) && !is.numeric(weights)) \n##         stop(\"'weights' must be a numeric vector\")\n##     if (!is.null(weights) && any(weights < 0)) \n##         stop(\"negative weights not allowed\")\n##     offset <- as.vector(model.offset(mf))\n##     if (!is.null(offset)) {\n##         if (length(offset) != NROW(Y)) \n##             stop(gettextf(\"number of offsets is %d should equal %d (number of observations)\", \n##                 length(offset), NROW(Y)), domain = NA)\n##     }\n##     mustart <- model.extract(mf, \"mustart\")\n##     etastart <- model.extract(mf, \"etastart\")\n##     fit <- eval(call(if (is.function(method)) \"method\" else method, \n##         x = X, y = Y, weights = weights, start = start, etastart = etastart, \n##         mustart = mustart, offset = offset, family = family, \n##         control = control, intercept = attr(mt, \"intercept\") > \n##             0L))\n##     if (length(offset) && attr(mt, \"intercept\") > 0L) {\n##         fit2 <- eval(call(if (is.function(method)) \"method\" else method, \n##             x = X[, \"(Intercept)\", drop = FALSE], y = Y, weights = weights, \n##             offset = offset, family = family, control = control, \n##             intercept = TRUE))\n##         if (!fit2$converged) \n##             warning(\"fitting to calculate the null deviance did not converge -- increase 'maxit'?\")\n##         fit$null.deviance <- fit2$deviance\n##     }\n##     if (model) \n##         fit$model <- mf\n##     fit$na.action <- attr(mf, \"na.action\")\n##     if (x) \n##         fit$x <- X\n##     if (!y) \n##         fit$y <- NULL\n##     fit <- c(fit, list(call = call, formula = formula, terms = mt, \n##         data = data, offset = offset, control = control, method = method, \n##         contrasts = attr(X, \"contrasts\"), xlevels = .getXlevels(mt, \n##             mf)))\n##     class(fit) <- c(fit$class, c(\"glm\", \"lm\"))\n##     fit\n## }\n## <bytecode: 0x0000000008279d20>\n## <environment: namespace:stats>\n\n\n\u95a2\u6570\u540d glmmML()\n\n### \u30d1\u30c3\u30b1\u30fc\u30b8\u306e\u7528\u610f\ninstall.packages(\"glmmML\")\nrequire(glmmML)\n\n### \u30d1\u30c3\u30b1\u30fc\u30b8\u306e\u7528\u610f\u7d42\u4e86\n\nglmmML\n\n## function (formula, family = binomial, data, cluster, weights, \n##     cluster.weights, subset, na.action, offset, prior = c(\"gaussian\", \n##         \"logistic\", \"cauchy\"), start.coef = NULL, start.sigma = NULL, \n##     fix.sigma = FALSE, x = FALSE, control = list(epsilon = 1e-08, \n##         maxit = 200, trace = FALSE), method = c(\"Laplace\", \"ghq\"), \n##     n.points = 8, boot = 0) \n## {\n##     method <- method[1]\n##     if (method == \"laplace\") \n##         method <- \"Laplace\"\n##     if (method == \"GHQ\") \n##         method <- \"ghq\"\n##     if (!(method %in% c(\"Laplace\", \"ghq\"))) \n##         stop(\"Wrong method\")\n##     if (is.list(control)) {\n##         if (is.null(control$epsilon)) \n##             control$epsilon <- 1e-08\n##         if (is.null(control$maxit)) \n##             control$maxit <- 200\n##         if (is.null(control$trace)) \n##             control$trace <- FALSE\n##     }\n##     else {\n##         stop(\"control must be a list\")\n##     }\n##     method <- as.numeric(method[1] == \"Laplace\")\n##     if (method) \n##         n.points <- 1\n##     a.prior <- prior[1]\n##     if (!(a.prior %in% c(\"gaussian\", \"logistic\", \"cauchy\"))) \n##         stop(\"Prior distribution not known\")\n##     if (a.prior == \"gaussian\") \n##         prior <- 0\n##     else if (a.prior == \"logistic\") \n##         prior <- 1\n##     else prior <- 2\n##     cl <- match.call()\n##     if (is.character(family)) \n##         family <- get(family)\n##     if (is.function(family)) \n##         family <- family()\n##     if (is.null(family$family)) {\n##         print(family)\n##         stop(\"`family' not recognized\")\n##     }\n##     if (missing(data)) \n##         data <- environment(formula)\n##     mf <- match.call(expand.dots = FALSE)\n##     mf$family <- mf$start.coef <- mf$start.sigma <- mf$fix.sigma <- NULL\n##     mf$weights <- mf$cluster.weights <- NULL\n##     mf$control <- mf$maxit <- mf$boot <- NULL\n##     mf$n.points <- mf$method <- mf$prior <- NULL\n##     mf[[1]] <- as.name(\"model.frame\")\n##     mf <- eval(mf, environment(formula))\n##     mt <- attr(mf, \"terms\")\n##     xvars <- as.character(attr(mt, \"variables\"))[-1]\n##     if ((yvar <- attr(mt, \"response\")) > 0) \n##         xvars <- xvars[-yvar]\n##     xlev <- if (length(xvars) > 0) {\n##         xlev <- lapply(mf[xvars], levels)\n##         xlev[!sapply(xlev, is.null)]\n##     }\n##     X <- if (!is.empty.model(mt)) \n##         model.matrix(mt, mf, contrasts)\n##     p <- NCOL(X)\n##     Y <- model.response(mf, \"numeric\")\n##     offset <- model.offset(mf)\n##     cluster <- mf$\"(cluster)\"\n##     no.cluster <- (missing(cluster) || is.null(cluster) || (length(unique(cluster)) <= \n##         1))\n##     if (no.cluster) {\n##         warning(\"No (or constant) 'cluster'; consider using 'glm'\")\n##         return(NULL)\n##     }\n##     if (!is.null(offset) && length(offset) != NROW(Y)) \n##         stop(paste(\"Number of offsets is\", length(offset), \", should equal\", \n##             NROW(Y), \"(number of observations)\"))\n##     if (missing(weights)) \n##         weights <- rep.int(1, NROW(Y))\n##     if (any(weights < 0)) \n##         stop(\"negative weights not allowed\")\n##     if (missing(cluster.weights)) \n##         cluster.weights <- rep.int(1, length(cluster))\n##     if (any(cluster.weights < 0)) \n##         stop(\"negative cluster weights not allowed\")\n##     if (n.points <= 0) \n##         n.points <- 1\n##     fit <- glmmML.fit(X, Y, weights, cluster.weights, start.coef, \n##         start.sigma, fix.sigma, cluster, offset, family, method, \n##         n.points, control, intercept = (attr(mt, \"intercept\") > \n##             0), boot, prior)\n##     if (!fit$convergence) \n##         warning(\"'vmmin' did not converge. Increase 'maxit'?\")\n##     bdim <- p + 1\n##     res <- list()\n##     res$boot <- boot\n##     res$converged <- as.logical(fit$convergence)\n##     res$coefficients <- fit$beta\n##     res$coef.sd <- fit$beta.sd\n##     res$sigma <- abs(fit$sigma)\n##     res$sigma.sd <- fit$sigma.sd\n##     res$variance <- fit$variance\n##     res$aic <- fit$aic\n##     names(res$coef.sd) <- names(res$coefficients)\n##     res$bootP <- fit$bootP\n##     res$deviance <- fit$deviance\n##     res$df.residual <- fit$df.residual\n##     res$cluster.null.deviance <- fit$cluster.null.deviance\n##     res$cluster.null.df <- fit$cluster.null.df\n##     res$posterior.modes <- fit$post.mode\n##     res$prior <- a.prior\n##     res$terms <- mt\n##     res$info <- fit$info\n##     res$call <- cl\n##     if (x) \n##         res$x <- X\n##     names(res$coefficients) <- c(colnames(X))\n##     class(res) <- \"glmmML\"\n##     res\n## }\n## <environment: namespace:glmmML>\n\n\n\u95a2\u6570\u540d read.transactions()\n\n### \u30d1\u30c3\u30b1\u30fc\u30b8\u306e\u7528\u610f\ninstall.packages(\"arules\")\nrequire(arules)\n\n### \u30d1\u30c3\u30b1\u30fc\u30b8\u306e\u7528\u610f\u7d42\u4e86\n\nread.transactions\n\n## function (file, format = c(\"basket\", \"single\"), sep = NULL, cols = NULL, \n##     rm.duplicates = FALSE, encoding = \"unknown\") \n## {\n##     format <- match.arg(format)\n##     if (format == \"basket\") {\n##         if (is.null(sep)) \n##             sep <- \"[ \\t]+\"\n##         data <- strsplit(readLines(file, encoding = encoding), \n##             split = sep)\n##         if (!is.null(cols)) {\n##             if (!(is(cols, \"numeric\") && (length(cols) == 1))) \n##                 stop(\"'cols' must be a numeric scalar for 'basket'.\")\n##             cols <- as(cols, \"integer\")\n##             names(data) <- sapply(data, \"[\", cols)\n##             data <- lapply(data, \"[\", -cols)\n##         }\n##         if (rm.duplicates) \n##             data <- .rm.duplicates(data)\n##         return(as(data, \"transactions\"))\n##     }\n##     skip <- 0\n##     if (is(cols, \"character\") && (length(cols) == 2)) {\n##         colnames <- scan(file = file, what = \"\", sep = sep, quiet = TRUE, \n##             nlines = 1)\n##         cols <- match(cols, colnames)\n##         if (any(is.na(cols))) \n##             stop(\"'cols' does not match 2 entries in header of file.\")\n##         skip <- 1\n##     }\n##     if (!(is(cols, \"numeric\") && (length(cols) == 2))) \n##         stop(\"'cols' must be a numeric or character vector of length 2 for 'single'.\")\n##     cols <- as(cols, \"integer\")\n##     what <- vector(\"list\", length = max(cols))\n##     what[cols] <- \"\"\n##     entries <- scan(file = file, sep = sep, what = what, flush = TRUE, \n##         quiet = TRUE, skip = skip)\n##     entries <- split(entries[[cols[2]]], entries[[cols[1]]])\n##     if (rm.duplicates) \n##         entries <- .rm.duplicates(entries)\n##     as(entries, \"transactions\")\n## }\n## <environment: namespace:arules>\n\n\n\u95a2\u6570\u540d MCMCmetrop1R()\n\n\n\uff08\u4f7f\u3044\u65b9\u53c2\u8003\uff09\n Taglibro de H \uff08\u8a18\u4e8b\uff09\u300cMCMC\u306e\u52c9\u5f37(1)\u3000[\u7d71\u8a08]\u300d\n\n### \u30d1\u30c3\u30b1\u30fc\u30b8\u306e\u7528\u610f\ninstall.packages(\"MCMCpack\")\nrequire(MCMCpack)\n\n### \u30d1\u30c3\u30b1\u30fc\u30b8\u306e\u7528\u610f\u7d42\u4e86\n\nMCMCmetrop1R\n\n\n## function (fun, theta.init, burnin = 500, mcmc = 20000, thin = 1, \n##     tune = 1, verbose = 0, seed = NA, logfun = TRUE, force.samp = FALSE, \n##     V = NULL, optim.method = \"BFGS\", optim.lower = -Inf, optim.upper = Inf, \n##     optim.control = list(fnscale = -1, trace = 0, REPORT = 10, \n##         maxit = 500), ...) \n## {\n##     check.offset(list(...))\n##     check.mcmc.parameters(burnin, mcmc, thin)\n##     tune <- vector.tune(tune, length(theta.init))\n##     seeds <- form.seeds(seed)\n##     lecuyer <- seeds[[1]]\n##     seed.array <- seeds[[2]]\n##     lecuyer.stream <- seeds[[3]]\n##     userfun <- function(ttt) fun(ttt, ...)\n##     my.env <- environment(fun = userfun)\n##     if (logfun) {\n##         maxfun <- fun\n##     }\n##     else if (logfun == FALSE) {\n##         maxfun <- function(ttt, ...) log(fun(ttt, ...))\n##     }\n##     else {\n##         cat(\"logfun not a logical value.\\n\")\n##         stop(\"Respecifiy and call MCMCmetrop1R() again. \\n\", \n##             call. = FALSE)\n##     }\n##     if (is.null(V)) {\n##         opt.out <- optim(theta.init, maxfun, control = optim.control, \n##             lower = optim.lower, upper = optim.upper, method = optim.method, \n##             hessian = TRUE, ...)\n##         if (opt.out$convergence != 0) {\n##             warning(\"Mode and Hessian were not found with call to optim().\\nSampling proceeded anyway. \\n\")\n##         }\n##         CC <- NULL\n##         try(CC <- chol(-1 * opt.out$hessian), silent = TRUE)\n##         hess.new <- opt.out$hessian\n##         hess.flag <- 0\n##         if (force.samp == TRUE) {\n##             if (max(diag(opt.out$hessian) == 0)) {\n##                 for (i in 1:nrow(hess.new)) {\n##                   if (hess.new[i, i] == 0) {\n##                     hess.new[i, i] <- -1e-06\n##                   }\n##                 }\n##             }\n##             while (is.null(CC)) {\n##                 hess.flag <- 1\n##                 hess.new <- hess.new - diag(diag(0.01 * abs(opt.out$hessian)))\n##                 try(CC <- chol(-1 * hess.new), silent = TRUE)\n##             }\n##         }\n##         else {\n##             if (is.null(CC)) {\n##                 hess.flag <- 2\n##             }\n##         }\n##         if (hess.flag == 1) {\n##             warning(\"Hessian from call to optim() not negative definite.\\nSampling proceeded after enforcing negative definiteness. \\n\")\n##         }\n##         if (hess.flag == 2) {\n##             cat(\"Hessian from call to optim() not negative definite.\\n\")\n##             cat(\"Sampling (as specified) cannot proceed.\\n\")\n##             stop(\"Check data and fun() and call MCMCmetrop1R() again. \\n\", \n##                 call. = FALSE)\n##         }\n##         V <- tune %*% solve(-1 * hess.new) %*% tune\n##     }\n##     else {\n##         if (nrow(V) != ncol(V) || nrow(V) != length(theta.init)) {\n##             cat(\"V not of appropriate dimension.\\n\")\n##             stop(\"Check V and theta.init and call MCMCmetrop1R() again. \\n\", \n##                 call. = FALSE)\n##         }\n##         CC <- NULL\n##         try(CC <- chol(V), silent = TRUE)\n##         if (is.null(CC)) {\n##             cat(\"V not positive definite.\\n\")\n##             stop(\"Check V and call MCMCmetrop1R() again. \\n\", \n##                 call. = FALSE)\n##         }\n##         V <- tune %*% V %*% tune\n##     }\n##     sample <- .Call(\"MCMCmetrop1R_cc\", userfun, as.double(theta.init), \n##         my.env, as.integer(burnin), as.integer(mcmc), as.integer(thin), \n##         as.integer(verbose), lecuyer = as.integer(lecuyer), seedarray = as.integer(seed.array), \n##         lecuyerstream = as.integer(lecuyer.stream), as.logical(logfun), \n##         as.matrix(V), PACKAGE = \"MCMCpack\")\n##     sample <- mcmc(data = sample, start = burnin + 1, end = burnin + \n##         mcmc, thin = thin)\n##     return(sample)\n## }\n## <environment: namespace:MCMCpack>\n\nR\u306e\u95a2\u6570\u306e\u30bd\u30fc\u30b9\u30b3\u30fc\u30c9\u306e\u4e2d\u8eab\u3092\u898b\u308b\u65b9\u6cd5\n========================================================\n\n# \u3010\u6982\u8981\u3011\n\n## \u901a\u5e38\u3001\u95a2\u6570(\"\u5f15\u6570\") \u3068\u3044\u3046\u3088\u3046\u306b\u95a2\u6570\u540d\u306e\u5f8c\u308d\u306b\u62ec\u5f27\u3092\u3064\u3051\u3066\u3044\u307e\u3059\u3002\n## \u62ec\u5f27\u3092\u8a18\u8ff0\u305b\u305a\u306b\u95a2\u6570\u540d\u3060\u3051\u3092\u5165\u529b\u3057\u3066 _Enter_ \u30ad\u30fc\u3092\u62bc\u3059\u3068\u3001\u95a2\u6570\u306e\u4e2d\u8eab\u306e\u30bd\u30fc\u30b9\u30b3\u30fc\u30c9\u3092\u8868\u793a\u3055\u305b\u308b\u3053\u3068\u304c\u3067\u304d\u307e\u3059\n\n# \u95a2\u6570\u540d _library()_\n\n```{r}\nlibrary\n```\n\n```\n## function (package, help, pos = 2, lib.loc = NULL, character.only = FALSE, \n##     logical.return = FALSE, warn.conflicts = TRUE, quietly = FALSE, \n##     verbose = getOption(\"verbose\")) \n## {\n##     testRversion <- function(pkgInfo, pkgname, pkgpath) {\n##         if (is.null(built <- pkgInfo$Built)) \n##             stop(gettextf(\"package %s has not been installed properly\\n\", \n##                 sQuote(pkgname)), call. = FALSE, domain = NA)\n##         R_version_built_under <- as.numeric_version(built$R)\n##         if (R_version_built_under < \"3.0.0\") \n##             stop(gettextf(\"package %s was built before R 3.0.0: please re-install it\", \n##                 sQuote(pkgname)), call. = FALSE, domain = NA)\n##         current <- getRversion()\n##         if (length(Rdeps <- pkgInfo$Rdepends2)) {\n##             for (dep in Rdeps) if (length(dep) > 1L) {\n##                 target <- dep$version\n##                 res <- if (is.character(target)) {\n##                   do.call(dep$op, list(as.numeric(R.version[[\"svn rev\"]]), \n##                     as.numeric(sub(\"^r\", \"\", dep$version))))\n##                 }\n##                 else {\n##                   do.call(dep$op, list(current, as.numeric_version(target)))\n##                 }\n##                 if (!res) \n##                   stop(gettextf(\"This is R %s, package %s needs %s %s\", \n##                     current, sQuote(pkgname), dep$op, target), \n##                     call. = FALSE, domain = NA)\n##             }\n##         }\n##         if (R_version_built_under > current) \n##             warning(gettextf(\"package %s was built under R version %s\", \n##                 sQuote(pkgname), as.character(built$R)), call. = FALSE, \n##                 domain = NA)\n##         platform <- built$Platform\n##         r_arch <- .Platform$r_arch\n##         if (.Platform$OS.type == \"unix\") {\n##             if (!nzchar(r_arch) && length(grep(\"\\\\w\", platform)) && \n##                 !testPlatformEquivalence(platform, R.version$platform)) \n##                 stop(gettextf(\"package %s was built for %s\", \n##                   sQuote(pkgname), platform), call. = FALSE, \n##                   domain = NA)\n##         }\n##         else {\n##             if (nzchar(platform) && !grepl(\"mingw\", platform)) \n##                 stop(gettextf(\"package %s was built for %s\", \n##                   sQuote(pkgname), platform), call. = FALSE, \n##                   domain = NA)\n##         }\n##         if (nzchar(r_arch) && file.exists(file.path(pkgpath, \n##             \"libs\")) && !file.exists(file.path(pkgpath, \"libs\", \n##             r_arch))) \n##             stop(gettextf(\"package %s is not installed for 'arch = %s'\", \n##                 sQuote(pkgname), r_arch), call. = FALSE, domain = NA)\n##     }\n##     checkLicense <- function(pkg, pkgInfo, pkgPath) {\n##         L <- tools:::analyze_license(pkgInfo$DESCRIPTION[\"License\"])\n##         if (!L$is_empty && !L$is_verified) {\n##             site_file <- path.expand(file.path(R.home(\"etc\"), \n##                 \"licensed.site\"))\n##             if (file.exists(site_file) && pkg %in% readLines(site_file)) \n##                 return()\n##             personal_file <- path.expand(\"~/.R/licensed\")\n##             if (file.exists(personal_file)) {\n##                 agreed <- readLines(personal_file)\n##                 if (pkg %in% agreed) \n##                   return()\n##             }\n##             else agreed <- character()\n##             if (!interactive()) \n##                 stop(gettextf(\"package %s has a license that you need to accept in an interactive session\", \n##                   sQuote(pkg)), domain = NA)\n##             lfiles <- file.path(pkgpath, c(\"LICENSE\", \"LICENCE\"))\n##             lfiles <- lfiles[file.exists(lfiles)]\n##             if (length(lfiles)) {\n##                 message(gettextf(\"package %s has a license that you need to accept after viewing\", \n##                   sQuote(pkg)), domain = NA)\n##                 readline(\"press RETURN to view license\")\n##                 encoding <- pkgInfo$DESCRIPTION[\"Encoding\"]\n##                 if (is.na(encoding)) \n##                   encoding <- \"\"\n##                 if (encoding == \"latin1\") \n##                   encoding <- \"cp1252\"\n##                 file.show(lfiles[1L], encoding = encoding)\n##             }\n##             else {\n##                 message(gettextf(\"package %s has a license that you need to accept:\\naccording to the DESCRIPTION file it is\", \n##                   sQuote(pkg)), domain = NA)\n##                 message(pkgInfo$DESCRIPTION[\"License\"], domain = NA)\n##             }\n##             choice <- menu(c(\"accept\", \"decline\"), title = paste(\"License for\", \n##                 sQuote(pkg)))\n##             if (choice != 1) \n##                 stop(gettextf(\"license for package %s not accepted\", \n##                   sQuote(package)), domain = NA, call. = FALSE)\n##             dir.create(dirname(personal_file), showWarnings = FALSE)\n##             writeLines(c(agreed, pkg), personal_file)\n##         }\n##     }\n##     checkNoGenerics <- function(env, pkg) {\n##         nenv <- env\n##         ns <- .getNamespace(as.name(pkg))\n##         if (!is.null(ns)) \n##             nenv <- asNamespace(ns)\n##         if (exists(\".noGenerics\", envir = nenv, inherits = FALSE)) \n##             TRUE\n##         else {\n##             length(objects(env, pattern = \"^\\\\.__[MT]\", all.names = TRUE)) == \n##                 0L\n##         }\n##     }\n##     checkConflicts <- function(package, pkgname, pkgpath, nogenerics, \n##         env) {\n##         dont.mind <- c(\"last.dump\", \"last.warning\", \".Last.value\", \n##             \".Random.seed\", \".Last.lib\", \".onDetach\", \".packageName\", \n##             \".noGenerics\", \".required\", \".no_S3_generics\", \".Depends\", \n##             \".requireCachedGenerics\")\n##         sp <- search()\n##         lib.pos <- match(pkgname, sp)\n##         ob <- objects(lib.pos, all.names = TRUE)\n##         if (!nogenerics) {\n##             these <- ob[substr(ob, 1L, 6L) == \".__T__\"]\n##             gen <- gsub(\".__T__(.*):([^:]+)\", \"\\\\1\", these)\n##             from <- gsub(\".__T__(.*):([^:]+)\", \"\\\\2\", these)\n##             gen <- gen[from != package]\n##             ob <- ob[!(ob %in% gen)]\n##         }\n##         fst <- TRUE\n##         ipos <- seq_along(sp)[-c(lib.pos, match(c(\"Autoloads\", \n##             \"CheckExEnv\"), sp, 0L))]\n##         for (i in ipos) {\n##             obj.same <- match(objects(i, all.names = TRUE), ob, \n##                 nomatch = 0L)\n##             if (any(obj.same > 0)) {\n##                 same <- ob[obj.same]\n##                 same <- same[!(same %in% dont.mind)]\n##                 Classobjs <- grep(\"^\\\\.__\", same)\n##                 if (length(Classobjs)) \n##                   same <- same[-Classobjs]\n##                 same.isFn <- function(where) vapply(same, exists, \n##                   NA, where = where, mode = \"function\", inherits = FALSE)\n##                 same <- same[same.isFn(i) == same.isFn(lib.pos)]\n##                 not.Ident <- function(ch, TRAFO = identity, ...) vapply(ch, \n##                   function(.) !identical(TRAFO(get(., i)), TRAFO(get(., \n##                     lib.pos)), ...), NA)\n##                 if (length(same)) \n##                   same <- same[not.Ident(same)]\n##                 if (length(same) && identical(sp[i], \"package:base\")) \n##                   same <- same[not.Ident(same, ignore.environment = TRUE)]\n##                 if (length(same)) {\n##                   if (fst) {\n##                     fst <- FALSE\n##                     packageStartupMessage(gettextf(\"\\nAttaching package: %s\\n\", \n##                       sQuote(package)), domain = NA)\n##                   }\n##                   objs <- strwrap(paste(same, collapse = \", \"), \n##                     indent = 4, exdent = 4)\n##                   msg <- sprintf(ngettext(length(objs), \"The following object is masked %s %s:\\n\\n%s\\n\", \n##                     \"The following objects are masked %s %s:\\n\\n%s\\n\"), \n##                     if (i < lib.pos) \n##                       \"_by_\"\n##                     else \"from\", sQuote(sp[i]), paste(objs, collapse = \"\\n\"))\n##                   packageStartupMessage(msg)\n##                 }\n##             }\n##         }\n##     }\n##     if (verbose && quietly) \n##         message(\"'verbose' and 'quietly' are both true; being verbose then ..\")\n##     if (!missing(package)) {\n##         if (is.null(lib.loc)) \n##             lib.loc <- .libPaths()\n##         lib.loc <- lib.loc[file.info(lib.loc)$isdir %in% TRUE]\n##         if (!character.only) \n##             package <- as.character(substitute(package))\n##         if (length(package) != 1L) \n##             stop(\"'package' must be of length 1\")\n##         if (is.na(package) || (package == \"\")) \n##             stop(\"invalid package name\")\n##         pkgname <- paste(\"package\", package, sep = \":\")\n##         newpackage <- is.na(match(pkgname, search()))\n##         if (newpackage) {\n##             pkgpath <- find.package(package, lib.loc, quiet = TRUE, \n##                 verbose = verbose)\n##             if (length(pkgpath) == 0L) {\n##                 txt <- if (length(lib.loc)) \n##                   gettextf(\"there is no package called %s\", sQuote(package))\n##                 else gettext(\"no library trees found in 'lib.loc'\")\n##                 if (logical.return) {\n##                   warning(txt, domain = NA)\n##                   return(FALSE)\n##                 }\n##                 else stop(txt, domain = NA)\n##             }\n##             which.lib.loc <- normalizePath(dirname(pkgpath), \n##                 \"/\", TRUE)\n##             pfile <- system.file(\"Meta\", \"package.rds\", package = package, \n##                 lib.loc = which.lib.loc)\n##             if (!nzchar(pfile)) \n##                 stop(gettextf(\"%s is not a valid installed package\", \n##                   sQuote(package)), domain = NA)\n##             pkgInfo <- readRDS(pfile)\n##             testRversion(pkgInfo, package, pkgpath)\n##             if (!package %in% c(\"datasets\", \"grDevices\", \"graphics\", \n##                 \"methods\", \"splines\", \"stats\", \"stats4\", \"tcltk\", \n##                 \"tools\", \"utils\") && isTRUE(getOption(\"checkPackageLicense\", \n##                 FALSE))) \n##                 checkLicense(package, pkgInfo, pkgpath)\n##             if (is.character(pos)) {\n##                 npos <- match(pos, search())\n##                 if (is.na(npos)) {\n##                   warning(gettextf(\"%s not found on search path, using pos = 2\", \n##                     sQuote(pos)), domain = NA)\n##                   pos <- 2\n##                 }\n##                 else pos <- npos\n##             }\n##             .getRequiredPackages2(pkgInfo, quietly = quietly)\n##             deps <- unique(names(pkgInfo$Depends))\n##             if (packageHasNamespace(package, which.lib.loc)) {\n##                 tt <- try({\n##                   ns <- loadNamespace(package, c(which.lib.loc, \n##                     lib.loc))\n##                   env <- attachNamespace(ns, pos = pos, deps)\n##                 })\n##                 if (inherits(tt, \"try-error\")) \n##                   if (logical.return) \n##                     return(FALSE)\n##                   else stop(gettextf(\"package or namespace load failed for %s\", \n##                     sQuote(package)), call. = FALSE, domain = NA)\n##                 else {\n##                   on.exit(detach(pos = pos))\n##                   nogenerics <- !.isMethodsDispatchOn() || checkNoGenerics(env, \n##                     package)\n##                   if (warn.conflicts && !exists(\".conflicts.OK\", \n##                     envir = env, inherits = FALSE)) \n##                     checkConflicts(package, pkgname, pkgpath, \n##                       nogenerics, ns)\n##                   on.exit()\n##                   if (logical.return) \n##                     return(TRUE)\n##                   else return(invisible(.packages()))\n##                 }\n##             }\n##             else stop(gettextf(\"package %s does not have a namespace and should be re-installed\", \n##                 sQuote(package)), domain = NA)\n##         }\n##         if (verbose && !newpackage) \n##             warning(gettextf(\"package %s already present in search()\", \n##                 sQuote(package)), domain = NA)\n##     }\n##     else if (!missing(help)) {\n##         if (!character.only) \n##             help <- as.character(substitute(help))\n##         pkgName <- help[1L]\n##         pkgPath <- find.package(pkgName, lib.loc, verbose = verbose)\n##         docFiles <- c(file.path(pkgPath, \"Meta\", \"package.rds\"), \n##             file.path(pkgPath, \"INDEX\"))\n##         if (file.exists(vignetteIndexRDS <- file.path(pkgPath, \n##             \"Meta\", \"vignette.rds\"))) \n##             docFiles <- c(docFiles, vignetteIndexRDS)\n##         pkgInfo <- vector(\"list\", 3L)\n##         readDocFile <- function(f) {\n##             if (basename(f) %in% \"package.rds\") {\n##                 txt <- readRDS(f)$DESCRIPTION\n##                 if (\"Encoding\" %in% names(txt)) {\n##                   to <- if (Sys.getlocale(\"LC_CTYPE\") == \"C\") \n##                     \"ASCII//TRANSLIT\"\n##                   else \"\"\n##                   tmp <- try(iconv(txt, from = txt[\"Encoding\"], \n##                     to = to))\n##                   if (!inherits(tmp, \"try-error\")) \n##                     txt <- tmp\n##                   else warning(\"'DESCRIPTION' has an 'Encoding' field and re-encoding is not possible\", \n##                     call. = FALSE)\n##                 }\n##                 nm <- paste0(names(txt), \":\")\n##                 formatDL(nm, txt, indent = max(nchar(nm, \"w\")) + \n##                   3)\n##             }\n##             else if (basename(f) %in% \"vignette.rds\") {\n##                 txt <- readRDS(f)\n##                 if (is.data.frame(txt) && nrow(txt)) \n##                   cbind(basename(gsub(\"\\\\.[[:alpha:]]+$\", \"\", \n##                     txt$File)), paste(txt$Title, paste0(rep.int(\"(source\", \n##                     NROW(txt)), ifelse(txt$PDF != \"\", \", pdf\", \n##                     \"\"), \")\")))\n##                 else NULL\n##             }\n##             else readLines(f)\n##         }\n##         for (i in which(file.exists(docFiles))) pkgInfo[[i]] <- readDocFile(docFiles[i])\n##         y <- list(name = pkgName, path = pkgPath, info = pkgInfo)\n##         class(y) <- \"packageInfo\"\n##         return(y)\n##     }\n##     else {\n##         if (is.null(lib.loc)) \n##             lib.loc <- .libPaths()\n##         db <- matrix(character(), nrow = 0L, ncol = 3L)\n##         nopkgs <- character()\n##         for (lib in lib.loc) {\n##             a <- .packages(all.available = TRUE, lib.loc = lib)\n##             for (i in sort(a)) {\n##                 file <- system.file(\"Meta\", \"package.rds\", package = i, \n##                   lib.loc = lib)\n##                 title <- if (file != \"\") {\n##                   txt <- readRDS(file)\n##                   if (is.list(txt)) \n##                     txt <- txt$DESCRIPTION\n##                   if (\"Encoding\" %in% names(txt)) {\n##                     to <- if (Sys.getlocale(\"LC_CTYPE\") == \"C\") \n##                       \"ASCII//TRANSLIT\"\n##                     else \"\"\n##                     tmp <- try(iconv(txt, txt[\"Encoding\"], to, \n##                       \"?\"))\n##                     if (!inherits(tmp, \"try-error\")) \n##                       txt <- tmp\n##                     else warning(\"'DESCRIPTION' has an 'Encoding' field and re-encoding is not possible\", \n##                       call. = FALSE)\n##                   }\n##                   txt[\"Title\"]\n##                 }\n##                 else NA\n##                 if (is.na(title)) \n##                   title <- \" ** No title available ** \"\n##                 db <- rbind(db, cbind(i, lib, title))\n##             }\n##             if (length(a) == 0L) \n##                 nopkgs <- c(nopkgs, lib)\n##         }\n##         dimnames(db) <- list(NULL, c(\"Package\", \"LibPath\", \"Title\"))\n##         if (length(nopkgs) && !missing(lib.loc)) {\n##             pkglist <- paste(sQuote(nopkgs), collapse = \", \")\n##             msg <- sprintf(ngettext(length(nopkgs), \"library %s contains no packages\", \n##                 \"libraries %s contain no packages\"), pkglist)\n##             warning(msg, domain = NA)\n##         }\n##         y <- list(header = NULL, results = db, footer = NULL)\n##         class(y) <- \"libraryIQR\"\n##         return(y)\n##     }\n##     if (logical.return) \n##         TRUE\n##     else invisible(.packages())\n## }\n## <bytecode: 0x0000000006b09310>\n## <environment: namespace:base>\n```\n\n# \u95a2\u6570\u540d _require()_\n\n```{r}\nrequire\n```\n\n```\n## function (package, lib.loc = NULL, quietly = FALSE, warn.conflicts = TRUE, \n##     character.only = FALSE) \n## {\n##     if (!character.only) \n##         package <- as.character(substitute(package))\n##     loaded <- paste(\"package\", package, sep = \":\") %in% search()\n##     if (!loaded) {\n##         if (!quietly) \n##             packageStartupMessage(gettextf(\"Loading required package: %s\", \n##                 package), domain = NA)\n##         value <- tryCatch(library(package, lib.loc = lib.loc, \n##             character.only = TRUE, logical.return = TRUE, warn.conflicts = warn.conflicts, \n##             quietly = quietly), error = function(e) e)\n##         if (inherits(value, \"error\")) {\n##             if (!quietly) {\n##                 msg <- conditionMessage(value)\n##                 cat(\"Failed with error:  \", sQuote(msg), \"\\n\", \n##                   file = stderr(), sep = \"\")\n##                 .Internal(printDeferredWarnings())\n##             }\n##             return(invisible(FALSE))\n##         }\n##         if (!value) \n##             return(invisible(FALSE))\n##     }\n##     else value <- TRUE\n##     invisible(value)\n## }\n## <bytecode: 0x0000000006e18828>\n## <environment: namespace:base>\n```\n\n\n# \u95a2\u6570\u540d _cor()_\n\n```{r}\ncor\n```\n\n```\n## function (x, y = NULL, use = \"everything\", method = c(\"pearson\", \n##     \"kendall\", \"spearman\")) \n## {\n##     na.method <- pmatch(use, c(\"all.obs\", \"complete.obs\", \"pairwise.complete.obs\", \n##         \"everything\", \"na.or.complete\"))\n##     if (is.na(na.method)) \n##         stop(\"invalid 'use' argument\")\n##     method <- match.arg(method)\n##     if (is.data.frame(y)) \n##         y <- as.matrix(y)\n##     if (is.data.frame(x)) \n##         x <- as.matrix(x)\n##     if (!is.matrix(x) && is.null(y)) \n##         stop(\"supply both 'x' and 'y' or a matrix-like 'x'\")\n##     if (!(is.numeric(x) || is.logical(x))) \n##         stop(\"'x' must be numeric\")\n##     stopifnot(is.atomic(x))\n##     if (!is.null(y)) {\n##         if (!(is.numeric(y) || is.logical(y))) \n##             stop(\"'y' must be numeric\")\n##         stopifnot(is.atomic(y))\n##     }\n##     Rank <- function(u) {\n##         if (length(u) == 0L) \n##             u\n##         else if (is.matrix(u)) {\n##             if (nrow(u) > 1L) \n##                 apply(u, 2L, rank, na.last = \"keep\")\n##             else row(u)\n##         }\n##         else rank(u, na.last = \"keep\")\n##     }\n##     if (method == \"pearson\") \n##         .Call(C_cor, x, y, na.method, FALSE)\n##     else if (na.method %in% c(2L, 5L)) {\n##         if (is.null(y)) {\n##             .Call(C_cor, Rank(na.omit(x)), NULL, na.method, method == \n##                 \"kendall\")\n##         }\n##         else {\n##             nas <- attr(na.omit(cbind(x, y)), \"na.action\")\n##             dropNA <- function(x, nas) {\n##                 if (length(nas)) {\n##                   if (is.matrix(x)) \n##                     x[-nas, , drop = FALSE]\n##                   else x[-nas]\n##                 }\n##                 else x\n##             }\n##             .Call(C_cor, Rank(dropNA(x, nas)), Rank(dropNA(y, \n##                 nas)), na.method, method == \"kendall\")\n##         }\n##     }\n##     else if (na.method != 3L) {\n##         x <- Rank(x)\n##         if (!is.null(y)) \n##             y <- Rank(y)\n##         .Call(C_cor, x, y, na.method, method == \"kendall\")\n##     }\n##     else {\n##         if (is.null(y)) {\n##             ncy <- ncx <- ncol(x)\n##             if (ncx == 0) \n##                 stop(\"'x' is empty\")\n##             r <- matrix(0, nrow = ncx, ncol = ncy)\n##             for (i in seq_len(ncx)) {\n##                 for (j in seq_len(i)) {\n##                   x2 <- x[, i]\n##                   y2 <- x[, j]\n##                   ok <- complete.cases(x2, y2)\n##                   x2 <- rank(x2[ok])\n##                   y2 <- rank(y2[ok])\n##                   r[i, j] <- if (any(ok)) \n##                     .Call(C_cor, x2, y2, 1L, method == \"kendall\")\n##                   else NA\n##                 }\n##             }\n##             r <- r + t(r) - diag(diag(r))\n##             rownames(r) <- colnames(x)\n##             colnames(r) <- colnames(x)\n##             r\n##         }\n##         else {\n##             if (length(x) == 0L || length(y) == 0L) \n##                 stop(\"both 'x' and 'y' must be non-empty\")\n##             matrix_result <- is.matrix(x) || is.matrix(y)\n##             if (!is.matrix(x)) \n##                 x <- matrix(x, ncol = 1L)\n##             if (!is.matrix(y)) \n##                 y <- matrix(y, ncol = 1L)\n##             ncx <- ncol(x)\n##             ncy <- ncol(y)\n##             r <- matrix(0, nrow = ncx, ncol = ncy)\n##             for (i in seq_len(ncx)) {\n##                 for (j in seq_len(ncy)) {\n##                   x2 <- x[, i]\n##                   y2 <- y[, j]\n##                   ok <- complete.cases(x2, y2)\n##                   x2 <- rank(x2[ok])\n##                   y2 <- rank(y2[ok])\n##                   r[i, j] <- if (any(ok)) \n##                     .Call(C_cor, x2, y2, 1L, method == \"kendall\")\n##                   else NA\n##                 }\n##             }\n##             rownames(r) <- colnames(x)\n##             colnames(r) <- colnames(y)\n##             if (matrix_result) \n##                 r\n##             else drop(r)\n##         }\n##     }\n## }\n## <bytecode: 0x00000000080a9410>\n## <environment: namespace:stats>\n```\n\n# \u95a2\u6570\u540d _lm()_ \n\n```{r}\nlm\n```\n\n```\n## function (formula, data, subset, weights, na.action, method = \"qr\", \n##     model = TRUE, x = FALSE, y = FALSE, qr = TRUE, singular.ok = TRUE, \n##     contrasts = NULL, offset, ...) \n## {\n##     ret.x <- x\n##     ret.y <- y\n##     cl <- match.call()\n##     mf <- match.call(expand.dots = FALSE)\n##     m <- match(c(\"formula\", \"data\", \"subset\", \"weights\", \"na.action\", \n##         \"offset\"), names(mf), 0L)\n##     mf <- mf[c(1L, m)]\n##     mf$drop.unused.levels <- TRUE\n##     mf[[1L]] <- as.name(\"model.frame\")\n##     mf <- eval(mf, parent.frame())\n##     if (method == \"model.frame\") \n##         return(mf)\n##     else if (method != \"qr\") \n##         warning(gettextf(\"method = '%s' is not supported. Using 'qr'\", \n##             method), domain = NA)\n##     mt <- attr(mf, \"terms\")\n##     y <- model.response(mf, \"numeric\")\n##     w <- as.vector(model.weights(mf))\n##     if (!is.null(w) && !is.numeric(w)) \n##         stop(\"'weights' must be a numeric vector\")\n##     offset <- as.vector(model.offset(mf))\n##     if (!is.null(offset)) {\n##         if (length(offset) != NROW(y)) \n##             stop(gettextf(\"number of offsets is %d, should equal %d (number of observations)\", \n##                 length(offset), NROW(y)), domain = NA)\n##     }\n##     if (is.empty.model(mt)) {\n##         x <- NULL\n##         z <- list(coefficients = if (is.matrix(y)) matrix(, 0, \n##             3) else numeric(), residuals = y, fitted.values = 0 * \n##             y, weights = w, rank = 0L, df.residual = if (!is.null(w)) sum(w != \n##             0) else if (is.matrix(y)) nrow(y) else length(y))\n##         if (!is.null(offset)) {\n##             z$fitted.values <- offset\n##             z$residuals <- y - offset\n##         }\n##     }\n##     else {\n##         x <- model.matrix(mt, mf, contrasts)\n##         z <- if (is.null(w)) \n##             lm.fit(x, y, offset = offset, singular.ok = singular.ok, \n##                 ...)\n##         else lm.wfit(x, y, w, offset = offset, singular.ok = singular.ok, \n##             ...)\n##     }\n##     class(z) <- c(if (is.matrix(y)) \"mlm\", \"lm\")\n##     z$na.action <- attr(mf, \"na.action\")\n##     z$offset <- offset\n##     z$contrasts <- attr(x, \"contrasts\")\n##     z$xlevels <- .getXlevels(mt, mf)\n##     z$call <- cl\n##     z$terms <- mt\n##     if (model) \n##         z$model <- mf\n##     if (ret.x) \n##         z$x <- x\n##     if (ret.y) \n##         z$y <- y\n##     if (!qr) \n##         z$qr <- NULL\n##     z\n## }\n## <bytecode: 0x0000000008044ad8>\n## <environment: namespace:stats>\n```\n\n# \u95a2\u6570\u540d _nls()_\n\n```{r}\nnls\n```\n\n```\n## function (formula, data = parent.frame(), start, control = nls.control(), \n##     algorithm = c(\"default\", \"plinear\", \"port\"), trace = FALSE, \n##     subset, weights, na.action, model = FALSE, lower = -Inf, \n##     upper = Inf, ...) \n## {\n##     formula <- as.formula(formula)\n##     algorithm <- match.arg(algorithm)\n##     if (!is.list(data) && !is.environment(data)) \n##         stop(\"'data' must be a list or an environment\")\n##     mf <- match.call()\n##     varNames <- all.vars(formula)\n##     if (length(formula) == 2L) {\n##         formula[[3L]] <- formula[[2L]]\n##         formula[[2L]] <- 0\n##     }\n##     form2 <- formula\n##     form2[[2L]] <- 0\n##     varNamesRHS <- all.vars(form2)\n##     mWeights <- missing(weights)\n##     pnames <- if (missing(start)) {\n##         if (!is.null(attr(data, \"parameters\"))) {\n##             names(attr(data, \"parameters\"))\n##         }\n##         else {\n##             cll <- formula[[length(formula)]]\n##             func <- get(as.character(cll[[1L]]))\n##             if (!is.null(pn <- attr(func, \"pnames\"))) \n##                 as.character(as.list(match.call(func, call = cll))[-1L][pn])\n##         }\n##     }\n##     else names(start)\n##     env <- environment(formula)\n##     if (is.null(env)) \n##         env <- parent.frame()\n##     if (length(pnames)) \n##         varNames <- varNames[is.na(match(varNames, pnames))]\n##     lenVar <- function(var) tryCatch(length(eval(as.name(var), \n##         data, env)), error = function(e) -1)\n##     if (length(varNames)) {\n##         n <- sapply(varNames, lenVar)\n##         if (any(not.there <- n == -1)) {\n##             nnn <- names(n[not.there])\n##             if (missing(start)) {\n##                 if (algorithm == \"plinear\") \n##                   stop(\"no starting values specified\")\n##                 warning(\"No starting values specified for some parameters.\\n\", \n##                   \"Initializing \", paste(sQuote(nnn), collapse = \", \"), \n##                   \" to '1.'.\\n\", \"Consider specifying 'start' or using a selfStart model\", \n##                   domain = NA)\n##                 start <- setNames(as.list(rep(1, length(nnn))), \n##                   nnn)\n##                 varNames <- varNames[i <- is.na(match(varNames, \n##                   nnn))]\n##                 n <- n[i]\n##             }\n##             else stop(gettextf(\"parameters without starting value in 'data': %s\", \n##                 paste(nnn, collapse = \", \")), domain = NA)\n##         }\n##     }\n##     else {\n##         if (length(pnames) && any((np <- sapply(pnames, lenVar)) == \n##             -1)) {\n##             message(sprintf(ngettext(sum(np == -1), \"fitting parameter %s without any variables\", \n##                 \"fitting parameters %s without any variables\"), \n##                 paste(sQuote(pnames[np == -1]), collapse = \", \")), \n##                 domain = NA)\n##             n <- integer()\n##         }\n##         else stop(\"no parameters to fit\")\n##     }\n##     respLength <- length(eval(formula[[2L]], data, env))\n##     if (length(n) > 0L) {\n##         varIndex <- n%%respLength == 0\n##         if (is.list(data) && diff(range(n[names(n) %in% names(data)])) > \n##             0) {\n##             mf <- data\n##             if (!missing(subset)) \n##                 warning(\"argument 'subset' will be ignored\")\n##             if (!missing(na.action)) \n##                 warning(\"argument 'na.action' will be ignored\")\n##             if (missing(start)) \n##                 start <- getInitial(formula, mf)\n##             startEnv <- new.env(hash = FALSE, parent = environment(formula))\n##             for (i in names(start)) assign(i, start[[i]], envir = startEnv)\n##             rhs <- eval(formula[[3L]], data, startEnv)\n##             n <- NROW(rhs)\n##             wts <- if (mWeights) \n##                 rep(1, n)\n##             else eval(substitute(weights), data, environment(formula))\n##         }\n##         else {\n##             mf$formula <- as.formula(paste(\"~\", paste(varNames[varIndex], \n##                 collapse = \"+\")), env = environment(formula))\n##             mf$start <- mf$control <- mf$algorithm <- mf$trace <- mf$model <- NULL\n##             mf$lower <- mf$upper <- NULL\n##             mf[[1L]] <- as.name(\"model.frame\")\n##             mf <- eval.parent(mf)\n##             n <- nrow(mf)\n##             mf <- as.list(mf)\n##             wts <- if (!mWeights) \n##                 model.weights(mf)\n##             else rep(1, n)\n##         }\n##         if (any(wts < 0 | is.na(wts))) \n##             stop(\"missing or negative weights not allowed\")\n##     }\n##     else {\n##         varIndex <- logical()\n##         mf <- list(0)\n##         wts <- numeric()\n##     }\n##     if (missing(start)) \n##         start <- getInitial(formula, mf)\n##     for (var in varNames[!varIndex]) mf[[var]] <- eval(as.name(var), \n##         data, env)\n##     varNamesRHS <- varNamesRHS[varNamesRHS %in% varNames[varIndex]]\n##     m <- switch(algorithm, plinear = nlsModel.plinear(formula, \n##         mf, start, wts), port = nlsModel(formula, mf, start, \n##         wts, upper), nlsModel(formula, mf, start, wts))\n##     ctrl <- nls.control()\n##     if (!missing(control)) {\n##         control <- as.list(control)\n##         ctrl[names(control)] <- control\n##     }\n##     if (algorithm != \"port\") {\n##         if (!missing(lower) || !missing(upper)) \n##             warning(\"upper and lower bounds ignored unless algorithm = \\\"port\\\"\")\n##         convInfo <- .Call(C_nls_iter, m, ctrl, trace)\n##         nls.out <- list(m = m, convInfo = convInfo, data = substitute(data), \n##             call = match.call())\n##     }\n##     else {\n##         pfit <- nls_port_fit(m, start, lower, upper, control, \n##             trace, give.v = TRUE)\n##         iv <- pfit[[\"iv\"]]\n##         msg.nls <- port_msg(iv[1L])\n##         conv <- (iv[1L] %in% 3:6)\n##         if (!conv) {\n##             msg <- paste(\"Convergence failure:\", msg.nls)\n##             if (ctrl$warnOnly) \n##                 warning(msg)\n##             else stop(msg)\n##         }\n##         v. <- port_get_named_v(pfit[[\"v\"]])\n##         cInfo <- list(isConv = conv, finIter = iv[31L], finTol = v.[[\"NREDUC\"]], \n##             nEval = c(`function` = iv[6L], gradient = iv[30L]), \n##             stopCode = iv[1L], stopMessage = msg.nls)\n##         cl <- match.call()\n##         cl$lower <- lower\n##         cl$upper <- upper\n##         nls.out <- list(m = m, data = substitute(data), call = cl, \n##             convInfo = cInfo, convergence = as.integer(!conv), \n##             message = msg.nls)\n##     }\n##     nls.out$call$algorithm <- algorithm\n##     nls.out$call$control <- ctrl\n##     nls.out$call$trace <- trace\n##     nls.out$na.action <- attr(mf, \"na.action\")\n##     nls.out$dataClasses <- attr(attr(mf, \"terms\"), \"dataClasses\")[varNamesRHS]\n##     if (model) \n##         nls.out$model <- mf\n##     if (!mWeights) \n##         nls.out$weights <- wts\n##     nls.out$control <- control\n##     class(nls.out) <- \"nls\"\n##     nls.out\n## }\n## <bytecode: 0x0000000008039d78>\n## <environment: namespace:stats>\n```\n# \u95a2\u6570\u540d _glm()_\n\n```{r}\nglm\n```\n\n```\n## function (formula, family = gaussian, data, weights, subset, \n##     na.action, start = NULL, etastart, mustart, offset, control = list(...), \n##     model = TRUE, method = \"glm.fit\", x = FALSE, y = TRUE, contrasts = NULL, \n##     ...) \n## {\n##     call <- match.call()\n##     if (is.character(family)) \n##         family <- get(family, mode = \"function\", envir = parent.frame())\n##     if (is.function(family)) \n##         family <- family()\n##     if (is.null(family$family)) {\n##         print(family)\n##         stop(\"'family' not recognized\")\n##     }\n##     if (missing(data)) \n##         data <- environment(formula)\n##     mf <- match.call(expand.dots = FALSE)\n##     m <- match(c(\"formula\", \"data\", \"subset\", \"weights\", \"na.action\", \n##         \"etastart\", \"mustart\", \"offset\"), names(mf), 0L)\n##     mf <- mf[c(1L, m)]\n##     mf$drop.unused.levels <- TRUE\n##     mf[[1L]] <- as.name(\"model.frame\")\n##     mf <- eval(mf, parent.frame())\n##     if (identical(method, \"model.frame\")) \n##         return(mf)\n##     if (!is.character(method) && !is.function(method)) \n##         stop(\"invalid 'method' argument\")\n##     if (identical(method, \"glm.fit\")) \n##         control <- do.call(\"glm.control\", control)\n##     mt <- attr(mf, \"terms\")\n##     Y <- model.response(mf, \"any\")\n##     if (length(dim(Y)) == 1L) {\n##         nm <- rownames(Y)\n##         dim(Y) <- NULL\n##         if (!is.null(nm)) \n##             names(Y) <- nm\n##     }\n##     X <- if (!is.empty.model(mt)) \n##         model.matrix(mt, mf, contrasts)\n##     else matrix(, NROW(Y), 0L)\n##     weights <- as.vector(model.weights(mf))\n##     if (!is.null(weights) && !is.numeric(weights)) \n##         stop(\"'weights' must be a numeric vector\")\n##     if (!is.null(weights) && any(weights < 0)) \n##         stop(\"negative weights not allowed\")\n##     offset <- as.vector(model.offset(mf))\n##     if (!is.null(offset)) {\n##         if (length(offset) != NROW(Y)) \n##             stop(gettextf(\"number of offsets is %d should equal %d (number of observations)\", \n##                 length(offset), NROW(Y)), domain = NA)\n##     }\n##     mustart <- model.extract(mf, \"mustart\")\n##     etastart <- model.extract(mf, \"etastart\")\n##     fit <- eval(call(if (is.function(method)) \"method\" else method, \n##         x = X, y = Y, weights = weights, start = start, etastart = etastart, \n##         mustart = mustart, offset = offset, family = family, \n##         control = control, intercept = attr(mt, \"intercept\") > \n##             0L))\n##     if (length(offset) && attr(mt, \"intercept\") > 0L) {\n##         fit2 <- eval(call(if (is.function(method)) \"method\" else method, \n##             x = X[, \"(Intercept)\", drop = FALSE], y = Y, weights = weights, \n##             offset = offset, family = family, control = control, \n##             intercept = TRUE))\n##         if (!fit2$converged) \n##             warning(\"fitting to calculate the null deviance did not converge -- increase 'maxit'?\")\n##         fit$null.deviance <- fit2$deviance\n##     }\n##     if (model) \n##         fit$model <- mf\n##     fit$na.action <- attr(mf, \"na.action\")\n##     if (x) \n##         fit$x <- X\n##     if (!y) \n##         fit$y <- NULL\n##     fit <- c(fit, list(call = call, formula = formula, terms = mt, \n##         data = data, offset = offset, control = control, method = method, \n##         contrasts = attr(X, \"contrasts\"), xlevels = .getXlevels(mt, \n##             mf)))\n##     class(fit) <- c(fit$class, c(\"glm\", \"lm\"))\n##     fit\n## }\n## <bytecode: 0x0000000008279d20>\n## <environment: namespace:stats>\n```\n\n# \u95a2\u6570\u540d _glmmML()_\n\n```{r}\n### \u30d1\u30c3\u30b1\u30fc\u30b8\u306e\u7528\u610f\ninstall.packages(\"glmmML\")\nrequire(glmmML)\n\n### \u30d1\u30c3\u30b1\u30fc\u30b8\u306e\u7528\u610f\u7d42\u4e86\n\nglmmML\n```\n\n```\n## function (formula, family = binomial, data, cluster, weights, \n##     cluster.weights, subset, na.action, offset, prior = c(\"gaussian\", \n##         \"logistic\", \"cauchy\"), start.coef = NULL, start.sigma = NULL, \n##     fix.sigma = FALSE, x = FALSE, control = list(epsilon = 1e-08, \n##         maxit = 200, trace = FALSE), method = c(\"Laplace\", \"ghq\"), \n##     n.points = 8, boot = 0) \n## {\n##     method <- method[1]\n##     if (method == \"laplace\") \n##         method <- \"Laplace\"\n##     if (method == \"GHQ\") \n##         method <- \"ghq\"\n##     if (!(method %in% c(\"Laplace\", \"ghq\"))) \n##         stop(\"Wrong method\")\n##     if (is.list(control)) {\n##         if (is.null(control$epsilon)) \n##             control$epsilon <- 1e-08\n##         if (is.null(control$maxit)) \n##             control$maxit <- 200\n##         if (is.null(control$trace)) \n##             control$trace <- FALSE\n##     }\n##     else {\n##         stop(\"control must be a list\")\n##     }\n##     method <- as.numeric(method[1] == \"Laplace\")\n##     if (method) \n##         n.points <- 1\n##     a.prior <- prior[1]\n##     if (!(a.prior %in% c(\"gaussian\", \"logistic\", \"cauchy\"))) \n##         stop(\"Prior distribution not known\")\n##     if (a.prior == \"gaussian\") \n##         prior <- 0\n##     else if (a.prior == \"logistic\") \n##         prior <- 1\n##     else prior <- 2\n##     cl <- match.call()\n##     if (is.character(family)) \n##         family <- get(family)\n##     if (is.function(family)) \n##         family <- family()\n##     if (is.null(family$family)) {\n##         print(family)\n##         stop(\"`family' not recognized\")\n##     }\n##     if (missing(data)) \n##         data <- environment(formula)\n##     mf <- match.call(expand.dots = FALSE)\n##     mf$family <- mf$start.coef <- mf$start.sigma <- mf$fix.sigma <- NULL\n##     mf$weights <- mf$cluster.weights <- NULL\n##     mf$control <- mf$maxit <- mf$boot <- NULL\n##     mf$n.points <- mf$method <- mf$prior <- NULL\n##     mf[[1]] <- as.name(\"model.frame\")\n##     mf <- eval(mf, environment(formula))\n##     mt <- attr(mf, \"terms\")\n##     xvars <- as.character(attr(mt, \"variables\"))[-1]\n##     if ((yvar <- attr(mt, \"response\")) > 0) \n##         xvars <- xvars[-yvar]\n##     xlev <- if (length(xvars) > 0) {\n##         xlev <- lapply(mf[xvars], levels)\n##         xlev[!sapply(xlev, is.null)]\n##     }\n##     X <- if (!is.empty.model(mt)) \n##         model.matrix(mt, mf, contrasts)\n##     p <- NCOL(X)\n##     Y <- model.response(mf, \"numeric\")\n##     offset <- model.offset(mf)\n##     cluster <- mf$\"(cluster)\"\n##     no.cluster <- (missing(cluster) || is.null(cluster) || (length(unique(cluster)) <= \n##         1))\n##     if (no.cluster) {\n##         warning(\"No (or constant) 'cluster'; consider using 'glm'\")\n##         return(NULL)\n##     }\n##     if (!is.null(offset) && length(offset) != NROW(Y)) \n##         stop(paste(\"Number of offsets is\", length(offset), \", should equal\", \n##             NROW(Y), \"(number of observations)\"))\n##     if (missing(weights)) \n##         weights <- rep.int(1, NROW(Y))\n##     if (any(weights < 0)) \n##         stop(\"negative weights not allowed\")\n##     if (missing(cluster.weights)) \n##         cluster.weights <- rep.int(1, length(cluster))\n##     if (any(cluster.weights < 0)) \n##         stop(\"negative cluster weights not allowed\")\n##     if (n.points <= 0) \n##         n.points <- 1\n##     fit <- glmmML.fit(X, Y, weights, cluster.weights, start.coef, \n##         start.sigma, fix.sigma, cluster, offset, family, method, \n##         n.points, control, intercept = (attr(mt, \"intercept\") > \n##             0), boot, prior)\n##     if (!fit$convergence) \n##         warning(\"'vmmin' did not converge. Increase 'maxit'?\")\n##     bdim <- p + 1\n##     res <- list()\n##     res$boot <- boot\n##     res$converged <- as.logical(fit$convergence)\n##     res$coefficients <- fit$beta\n##     res$coef.sd <- fit$beta.sd\n##     res$sigma <- abs(fit$sigma)\n##     res$sigma.sd <- fit$sigma.sd\n##     res$variance <- fit$variance\n##     res$aic <- fit$aic\n##     names(res$coef.sd) <- names(res$coefficients)\n##     res$bootP <- fit$bootP\n##     res$deviance <- fit$deviance\n##     res$df.residual <- fit$df.residual\n##     res$cluster.null.deviance <- fit$cluster.null.deviance\n##     res$cluster.null.df <- fit$cluster.null.df\n##     res$posterior.modes <- fit$post.mode\n##     res$prior <- a.prior\n##     res$terms <- mt\n##     res$info <- fit$info\n##     res$call <- cl\n##     if (x) \n##         res$x <- X\n##     names(res$coefficients) <- c(colnames(X))\n##     class(res) <- \"glmmML\"\n##     res\n## }\n## <environment: namespace:glmmML>\n```\n\n# \u95a2\u6570\u540d _read.transactions()_\n\n```{r}\n### \u30d1\u30c3\u30b1\u30fc\u30b8\u306e\u7528\u610f\ninstall.packages(\"arules\")\nrequire(arules)\n\n### \u30d1\u30c3\u30b1\u30fc\u30b8\u306e\u7528\u610f\u7d42\u4e86\n\nread.transactions\n```\n\n```\n## function (file, format = c(\"basket\", \"single\"), sep = NULL, cols = NULL, \n##     rm.duplicates = FALSE, encoding = \"unknown\") \n## {\n##     format <- match.arg(format)\n##     if (format == \"basket\") {\n##         if (is.null(sep)) \n##             sep <- \"[ \\t]+\"\n##         data <- strsplit(readLines(file, encoding = encoding), \n##             split = sep)\n##         if (!is.null(cols)) {\n##             if (!(is(cols, \"numeric\") && (length(cols) == 1))) \n##                 stop(\"'cols' must be a numeric scalar for 'basket'.\")\n##             cols <- as(cols, \"integer\")\n##             names(data) <- sapply(data, \"[\", cols)\n##             data <- lapply(data, \"[\", -cols)\n##         }\n##         if (rm.duplicates) \n##             data <- .rm.duplicates(data)\n##         return(as(data, \"transactions\"))\n##     }\n##     skip <- 0\n##     if (is(cols, \"character\") && (length(cols) == 2)) {\n##         colnames <- scan(file = file, what = \"\", sep = sep, quiet = TRUE, \n##             nlines = 1)\n##         cols <- match(cols, colnames)\n##         if (any(is.na(cols))) \n##             stop(\"'cols' does not match 2 entries in header of file.\")\n##         skip <- 1\n##     }\n##     if (!(is(cols, \"numeric\") && (length(cols) == 2))) \n##         stop(\"'cols' must be a numeric or character vector of length 2 for 'single'.\")\n##     cols <- as(cols, \"integer\")\n##     what <- vector(\"list\", length = max(cols))\n##     what[cols] <- \"\"\n##     entries <- scan(file = file, sep = sep, what = what, flush = TRUE, \n##         quiet = TRUE, skip = skip)\n##     entries <- split(entries[[cols[2]]], entries[[cols[1]]])\n##     if (rm.duplicates) \n##         entries <- .rm.duplicates(entries)\n##     as(entries, \"transactions\")\n## }\n## <environment: namespace:arules>\n```\n\n\n# \u95a2\u6570\u540d _MCMCmetrop1R()_\n\n#### \uff08\u4f7f\u3044\u65b9\u53c2\u8003\uff09\n[ _Taglibro de H_ \uff08\u8a18\u4e8b\uff09\u300cMCMC\u306e\u52c9\u5f37(1)\u3000[\u7d71\u8a08]\u300d](http://ito-hi.blog.so-net.ne.jp/2005-12-25)\n\n```{r}\n\n### \u30d1\u30c3\u30b1\u30fc\u30b8\u306e\u7528\u610f\ninstall.packages(\"MCMCpack\")\nrequire(MCMCpack)\n\n### \u30d1\u30c3\u30b1\u30fc\u30b8\u306e\u7528\u610f\u7d42\u4e86\n\nMCMCmetrop1R\n\n```\n\n```\n## function (fun, theta.init, burnin = 500, mcmc = 20000, thin = 1, \n##     tune = 1, verbose = 0, seed = NA, logfun = TRUE, force.samp = FALSE, \n##     V = NULL, optim.method = \"BFGS\", optim.lower = -Inf, optim.upper = Inf, \n##     optim.control = list(fnscale = -1, trace = 0, REPORT = 10, \n##         maxit = 500), ...) \n## {\n##     check.offset(list(...))\n##     check.mcmc.parameters(burnin, mcmc, thin)\n##     tune <- vector.tune(tune, length(theta.init))\n##     seeds <- form.seeds(seed)\n##     lecuyer <- seeds[[1]]\n##     seed.array <- seeds[[2]]\n##     lecuyer.stream <- seeds[[3]]\n##     userfun <- function(ttt) fun(ttt, ...)\n##     my.env <- environment(fun = userfun)\n##     if (logfun) {\n##         maxfun <- fun\n##     }\n##     else if (logfun == FALSE) {\n##         maxfun <- function(ttt, ...) log(fun(ttt, ...))\n##     }\n##     else {\n##         cat(\"logfun not a logical value.\\n\")\n##         stop(\"Respecifiy and call MCMCmetrop1R() again. \\n\", \n##             call. = FALSE)\n##     }\n##     if (is.null(V)) {\n##         opt.out <- optim(theta.init, maxfun, control = optim.control, \n##             lower = optim.lower, upper = optim.upper, method = optim.method, \n##             hessian = TRUE, ...)\n##         if (opt.out$convergence != 0) {\n##             warning(\"Mode and Hessian were not found with call to optim().\\nSampling proceeded anyway. \\n\")\n##         }\n##         CC <- NULL\n##         try(CC <- chol(-1 * opt.out$hessian), silent = TRUE)\n##         hess.new <- opt.out$hessian\n##         hess.flag <- 0\n##         if (force.samp == TRUE) {\n##             if (max(diag(opt.out$hessian) == 0)) {\n##                 for (i in 1:nrow(hess.new)) {\n##                   if (hess.new[i, i] == 0) {\n##                     hess.new[i, i] <- -1e-06\n##                   }\n##                 }\n##             }\n##             while (is.null(CC)) {\n##                 hess.flag <- 1\n##                 hess.new <- hess.new - diag(diag(0.01 * abs(opt.out$hessian)))\n##                 try(CC <- chol(-1 * hess.new), silent = TRUE)\n##             }\n##         }\n##         else {\n##             if (is.null(CC)) {\n##                 hess.flag <- 2\n##             }\n##         }\n##         if (hess.flag == 1) {\n##             warning(\"Hessian from call to optim() not negative definite.\\nSampling proceeded after enforcing negative definiteness. \\n\")\n##         }\n##         if (hess.flag == 2) {\n##             cat(\"Hessian from call to optim() not negative definite.\\n\")\n##             cat(\"Sampling (as specified) cannot proceed.\\n\")\n##             stop(\"Check data and fun() and call MCMCmetrop1R() again. \\n\", \n##                 call. = FALSE)\n##         }\n##         V <- tune %*% solve(-1 * hess.new) %*% tune\n##     }\n##     else {\n##         if (nrow(V) != ncol(V) || nrow(V) != length(theta.init)) {\n##             cat(\"V not of appropriate dimension.\\n\")\n##             stop(\"Check V and theta.init and call MCMCmetrop1R() again. \\n\", \n##                 call. = FALSE)\n##         }\n##         CC <- NULL\n##         try(CC <- chol(V), silent = TRUE)\n##         if (is.null(CC)) {\n##             cat(\"V not positive definite.\\n\")\n##             stop(\"Check V and call MCMCmetrop1R() again. \\n\", \n##                 call. = FALSE)\n##         }\n##         V <- tune %*% V %*% tune\n##     }\n##     sample <- .Call(\"MCMCmetrop1R_cc\", userfun, as.double(theta.init), \n##         my.env, as.integer(burnin), as.integer(mcmc), as.integer(thin), \n##         as.integer(verbose), lecuyer = as.integer(lecuyer), seedarray = as.integer(seed.array), \n##         lecuyerstream = as.integer(lecuyer.stream), as.logical(logfun), \n##         as.matrix(V), PACKAGE = \"MCMCpack\")\n##     sample <- mcmc(data = sample, start = burnin + 1, end = burnin + \n##         mcmc, thin = thin)\n##     return(sample)\n## }\n## <environment: namespace:MCMCpack>\n```\n", "tags": ["R", "\u95a2\u6570", "\u30bd\u30fc\u30b9\u30b3\u30fc\u30c9", "\u30e9\u30a4\u30d6\u30e9\u30ea", "\u30d1\u30c3\u30b1\u30fc\u30b8"]}