{"context": " More than 1 year has passed since last update.Spray 1.3.1\u3067Server-sent events\u3059\u308b\u4f8b\u3002suin/scala-playground\u3092\u30c1\u30a7\u30c3\u30af\u30a2\u30a6\u30c8\u3059\u308b\u3068\u5b9f\u969b\u306b\u52d5\u304b\u3059\u3053\u3068\u304c\u3067\u304d\u307e\u3059\u3002\n// Spray\u3067Server-Sent Events\u3092\u5b9f\u88c5\u3059\u308b\u30b5\u30f3\u30d7\u30eb\npackage playground.spray.example1\n\nimport akka.actor._\nimport akka.io.IO\nimport akka.pattern.ask\nimport akka.util.Timeout\nimport org.joda.time.DateTime\nimport spray.can.Http\nimport spray.http.CacheDirectives.`no-cache`\nimport spray.http.HttpCharsets.`UTF-8`\nimport spray.http.HttpHeaders.`Cache-Control`\nimport spray.http.{ ChunkedMessageEnd, ChunkedResponseStart, ContentType, HttpEntity, HttpResponse, HttpResponsePart, MediaType, MediaTypes, MessageChunk }\nimport spray.routing.HttpService\n\nimport scala.collection.mutable\nimport scala.concurrent.ExecutionContext.Implicits.global\nimport scala.concurrent.duration._\n\n// ServerSentEventsStreamer\u306b\u30a4\u30d9\u30f3\u30c8\u9001\u4fe1\u306a\u3069\u3092\u547d\u4ee4\u3059\u308b\u305f\u3081\u306e\u30d7\u30ed\u30c8\u30b3\u30eb\nobject ServerSentEventsStreamerProtocol {\n  case class SendEvent(id: Option[Long] = None, event: Option[String] = None, data: String)\n  case object StopStreaming\n}\n\n// Server-Sent Events\u306e\u30ec\u30b9\u30dd\u30f3\u30b9\u3092\u9001\u4fe1\u3059\u308b\u62bd\u8c61\u30af\u30e9\u30b9\nclass ServerSentEventsStreamer(client: ActorRef) extends Actor with ActorLogging {\n  import ServerSentEventsStreamerProtocol._\n\n  private object StartStreaming\n  private trait ClientStatus\n  private object ClientReady extends ClientStatus\n  private object ClientBusy extends ClientStatus\n  private object SendBlank\n\n  private val `text/event-stream` = MediaTypes.register(MediaType.custom(\"text/event-stream\"))\n  private val EOL = \"\\n\"\n\n  private var clientStatus: ClientStatus = ClientReady\n  private var goingToStop = false\n  private val messageQueue = mutable.Queue[HttpResponsePart]()\n\n  self ! StartStreaming\n\n  // Some proxy servers drop HTTP connections after a short timeout.\n  // To protect against such proxy servers, send blank every 15 seconds.\n  private val timer = context.system.scheduler.schedule(15 seconds, 15 seconds, self, SendBlank)\n\n  final override def receive: Receive = {\n    case StartStreaming =>\n      log.info(\"[SSE] start streaming\")\n      val streamStart = \":\" + (\" \" * 2048) + EOL + EOL // 2 kB padding for IE\n      val responseStart = HttpResponse(\n        entity = HttpEntity(ContentType(`text/event-stream`, `UTF-8`), streamStart),\n        headers = List(`Cache-Control`(`no-cache`))\n      )\n      sendOrEnqueue(ChunkedResponseStart(responseStart))\n\n    case event: SendEvent =>\n      log.info(\"[SSE] received event: {}\", event)\n      sendOrEnqueue(MessageChunk(stringifyEvent(event)))\n\n    case ClientReady =>\n      if (goingToStop && messageQueue.isEmpty) {\n        stopStreaming()\n      }\n\n      if (messageQueue.nonEmpty) {\n        val message = messageQueue.dequeue()\n        log.info(\"[SSE] dequeue and send message, as client is ready: {}\", message)\n        sendMessageNow(message)\n      } else {\n        log.info(\"[SSE] client is ready\")\n        clientStatus = ClientReady\n      }\n\n    case SendBlank =>\n      log.info(\"[SSE] send blank\")\n      sendOrEnqueue(MessageChunk(\":\" + EOL + EOL))\n\n    case StopStreaming =>\n      log.info(\"[SSE] going to stop streaming\")\n      sendOrEnqueue(ChunkedMessageEnd)\n      goingToStop = true\n\n    case x: Http.ConnectionClosed =>\n      log.info(\"[SSE] HTTP connection was closed\")\n      stopStreaming()\n\n    case other @ _ => receiveCommand(other)\n  }\n\n  protected def receiveCommand: Receive = PartialFunction.empty\n\n  private def sendOrEnqueue(message: HttpResponsePart): Unit = {\n    if (clientStatus == ClientReady) {\n      log.info(\"[SSE] send message right now, as client is ready: {}\", message)\n      sendMessageNow(message)\n    } else {\n      log.info(\"[SSE] enqueue message, as client is busy: {}\", message)\n      messageQueue.enqueue(message)\n    }\n  }\n\n  private def sendMessageNow(message: HttpResponsePart): Unit = {\n    client ! message.withAck(ClientReady)\n    clientStatus = ClientBusy\n  }\n\n  private def stringifyEvent(event: SendEvent): String = Seq[String](\n    event.id.map(\"id:\" + _).getOrElse(\"\"),\n    event.event.map(\"event:\" + _).getOrElse(\"\"),\n    event.data.split(EOL).map(\"data:\" + _).mkString(EOL)\n  ).filter(_.nonEmpty).mkString(EOL) + EOL + EOL\n\n  private def stopStreaming(): Unit = {\n    log.info(\"[SSE] streamer stopped\")\n    timer.cancel()\n    self ! PoisonPill\n  }\n}\n\nclass CurrentTimeStreamer(client: ActorRef) extends ServerSentEventsStreamer(client) {\n  import ServerSentEventsStreamerProtocol._\n  private val timer = context.system.scheduler.schedule(0 seconds, 1 seconds, self, \"time\")\n\n  override protected def receiveCommand: Receive = {\n    case \"time\" =>\n      val now = DateTime.now\n      self ! SendEvent(\n        id = Some(now.getMillis),\n        data = now.toString\n      )\n  }\n\n  override def postStop(): Unit = {\n    super.postStop()\n    timer.cancel()\n  }\n}\n\nclass MyHttpServiceActor extends Actor with MyHttpService {\n  def actorRefFactory = context\n  def receive = runRoute(myRoute)\n}\n\ntrait MyHttpService extends HttpService {\n  val myRoute = get { context =>\n    // context\u3092\u53d7\u3051\u53d6\u308a\u3001context.responder\u3092SSEStreamer\u306b\u6e21\u3059\n    actorRefFactory.actorOf(Props(\n      classOf[CurrentTimeStreamer],\n      context.responder\n    ))\n  }\n}\n\nobject ServerSentEventsExample extends App {\n  implicit val system = ActorSystem(\"sse-example\")\n  val service = system.actorOf(Props[MyHttpServiceActor], \"my-http\")\n  implicit val timeout = Timeout(5.seconds)\n  IO(Http) ? Http.Bind(service, interface = \"localhost\", port = 9000)\n}\n\n\nSpray 1.3.1\u3067Server-sent events\u3059\u308b\u4f8b\u3002[suin/scala-playground](https://github.com/suin/scala-playground)\u3092\u30c1\u30a7\u30c3\u30af\u30a2\u30a6\u30c8\u3059\u308b\u3068\u5b9f\u969b\u306b\u52d5\u304b\u3059\u3053\u3068\u304c\u3067\u304d\u307e\u3059\u3002\n\n```scala\n// Spray\u3067Server-Sent Events\u3092\u5b9f\u88c5\u3059\u308b\u30b5\u30f3\u30d7\u30eb\npackage playground.spray.example1\n\nimport akka.actor._\nimport akka.io.IO\nimport akka.pattern.ask\nimport akka.util.Timeout\nimport org.joda.time.DateTime\nimport spray.can.Http\nimport spray.http.CacheDirectives.`no-cache`\nimport spray.http.HttpCharsets.`UTF-8`\nimport spray.http.HttpHeaders.`Cache-Control`\nimport spray.http.{ ChunkedMessageEnd, ChunkedResponseStart, ContentType, HttpEntity, HttpResponse, HttpResponsePart, MediaType, MediaTypes, MessageChunk }\nimport spray.routing.HttpService\n\nimport scala.collection.mutable\nimport scala.concurrent.ExecutionContext.Implicits.global\nimport scala.concurrent.duration._\n\n// ServerSentEventsStreamer\u306b\u30a4\u30d9\u30f3\u30c8\u9001\u4fe1\u306a\u3069\u3092\u547d\u4ee4\u3059\u308b\u305f\u3081\u306e\u30d7\u30ed\u30c8\u30b3\u30eb\nobject ServerSentEventsStreamerProtocol {\n  case class SendEvent(id: Option[Long] = None, event: Option[String] = None, data: String)\n  case object StopStreaming\n}\n\n// Server-Sent Events\u306e\u30ec\u30b9\u30dd\u30f3\u30b9\u3092\u9001\u4fe1\u3059\u308b\u62bd\u8c61\u30af\u30e9\u30b9\nclass ServerSentEventsStreamer(client: ActorRef) extends Actor with ActorLogging {\n  import ServerSentEventsStreamerProtocol._\n\n  private object StartStreaming\n  private trait ClientStatus\n  private object ClientReady extends ClientStatus\n  private object ClientBusy extends ClientStatus\n  private object SendBlank\n\n  private val `text/event-stream` = MediaTypes.register(MediaType.custom(\"text/event-stream\"))\n  private val EOL = \"\\n\"\n\n  private var clientStatus: ClientStatus = ClientReady\n  private var goingToStop = false\n  private val messageQueue = mutable.Queue[HttpResponsePart]()\n\n  self ! StartStreaming\n\n  // Some proxy servers drop HTTP connections after a short timeout.\n  // To protect against such proxy servers, send blank every 15 seconds.\n  private val timer = context.system.scheduler.schedule(15 seconds, 15 seconds, self, SendBlank)\n\n  final override def receive: Receive = {\n    case StartStreaming =>\n      log.info(\"[SSE] start streaming\")\n      val streamStart = \":\" + (\" \" * 2048) + EOL + EOL // 2 kB padding for IE\n      val responseStart = HttpResponse(\n        entity = HttpEntity(ContentType(`text/event-stream`, `UTF-8`), streamStart),\n        headers = List(`Cache-Control`(`no-cache`))\n      )\n      sendOrEnqueue(ChunkedResponseStart(responseStart))\n\n    case event: SendEvent =>\n      log.info(\"[SSE] received event: {}\", event)\n      sendOrEnqueue(MessageChunk(stringifyEvent(event)))\n\n    case ClientReady =>\n      if (goingToStop && messageQueue.isEmpty) {\n        stopStreaming()\n      }\n\n      if (messageQueue.nonEmpty) {\n        val message = messageQueue.dequeue()\n        log.info(\"[SSE] dequeue and send message, as client is ready: {}\", message)\n        sendMessageNow(message)\n      } else {\n        log.info(\"[SSE] client is ready\")\n        clientStatus = ClientReady\n      }\n\n    case SendBlank =>\n      log.info(\"[SSE] send blank\")\n      sendOrEnqueue(MessageChunk(\":\" + EOL + EOL))\n\n    case StopStreaming =>\n      log.info(\"[SSE] going to stop streaming\")\n      sendOrEnqueue(ChunkedMessageEnd)\n      goingToStop = true\n\n    case x: Http.ConnectionClosed =>\n      log.info(\"[SSE] HTTP connection was closed\")\n      stopStreaming()\n\n    case other @ _ => receiveCommand(other)\n  }\n\n  protected def receiveCommand: Receive = PartialFunction.empty\n\n  private def sendOrEnqueue(message: HttpResponsePart): Unit = {\n    if (clientStatus == ClientReady) {\n      log.info(\"[SSE] send message right now, as client is ready: {}\", message)\n      sendMessageNow(message)\n    } else {\n      log.info(\"[SSE] enqueue message, as client is busy: {}\", message)\n      messageQueue.enqueue(message)\n    }\n  }\n\n  private def sendMessageNow(message: HttpResponsePart): Unit = {\n    client ! message.withAck(ClientReady)\n    clientStatus = ClientBusy\n  }\n\n  private def stringifyEvent(event: SendEvent): String = Seq[String](\n    event.id.map(\"id:\" + _).getOrElse(\"\"),\n    event.event.map(\"event:\" + _).getOrElse(\"\"),\n    event.data.split(EOL).map(\"data:\" + _).mkString(EOL)\n  ).filter(_.nonEmpty).mkString(EOL) + EOL + EOL\n\n  private def stopStreaming(): Unit = {\n    log.info(\"[SSE] streamer stopped\")\n    timer.cancel()\n    self ! PoisonPill\n  }\n}\n\nclass CurrentTimeStreamer(client: ActorRef) extends ServerSentEventsStreamer(client) {\n  import ServerSentEventsStreamerProtocol._\n  private val timer = context.system.scheduler.schedule(0 seconds, 1 seconds, self, \"time\")\n\n  override protected def receiveCommand: Receive = {\n    case \"time\" =>\n      val now = DateTime.now\n      self ! SendEvent(\n        id = Some(now.getMillis),\n        data = now.toString\n      )\n  }\n\n  override def postStop(): Unit = {\n    super.postStop()\n    timer.cancel()\n  }\n}\n\nclass MyHttpServiceActor extends Actor with MyHttpService {\n  def actorRefFactory = context\n  def receive = runRoute(myRoute)\n}\n\ntrait MyHttpService extends HttpService {\n  val myRoute = get { context =>\n    // context\u3092\u53d7\u3051\u53d6\u308a\u3001context.responder\u3092SSEStreamer\u306b\u6e21\u3059\n    actorRefFactory.actorOf(Props(\n      classOf[CurrentTimeStreamer],\n      context.responder\n    ))\n  }\n}\n\nobject ServerSentEventsExample extends App {\n  implicit val system = ActorSystem(\"sse-example\")\n  val service = system.actorOf(Props[MyHttpServiceActor], \"my-http\")\n  implicit val timeout = Timeout(5.seconds)\n  IO(Http) ? Http.Bind(service, interface = \"localhost\", port = 9000)\n}\n```\n", "tags": ["spray", "Server-Sent-Events", "Scala", "SSE"]}