{"context": " More than 1 year has passed since last update.\u6a19\u6e96\u5165\u529b\u304b\u3089\u554f\u984c\u3092\u53d7\u3051\u53d6\u308a\u30a2\u30af\u30bf\u30fc\u3066\u3099\u4e26\u5217\u306b\u7b54\u3048\u89e3\u3044\u3066\u6a19\u6e96\u51fa\u529b\u306b\u5410\u304d\u51fa\u3059\u7528\nRust\u304b\u308f\u3044\u3044\u3088Rust\n\ntemplate.rs\nuse std;\n\nimport core::io;\nimport io::reader;\nimport io::reader_util;\nimport std::sort;\n\nimpl read_util for reader{  \n  fn read_valid_char() -> char {\n    let mut c;\n    do {\n      c = self.read_char();\n    } while c == '\\n' || c == ' ';\n    ret c;\n  }\n\n  fn read_valid_line() -> str{\n    let mut line;\n    do {\n      line = self.read_line();\n    } while line == \"\";\n    ret line;\n  }\n\n  fn read_uint() -> uint{\n    let raw_uint = self.read_valid_line();\n    ret option::get(uint::from_str(raw_uint));\n  }\n  fn read_int() -> int{\n    ret option::get(int::from_str(self.read_line()));\n  }\n  fn read_uints() -> [uint]{\n    fn to_uint(&&s: str) -> uint{\n      ret option::get(uint::from_str(s));\n    }\n    let line = self.read_line();\n    ret vec::map(str::split_char(line, ' '), to_uint);\n  }\n  fn read_ints() -> [int]{\n    fn to_int(&&s: str) -> int{\n      ret option::get(int::from_str(s));\n    }\n    let line = self.read_valid_line();\n    ret vec::map(str::split_char(line, ' '), to_int);\n  }\n}\n\n#[doc=\"input data type\"]\ntype input = {\n  mut index: uint,\n  w: uint, \n  h: uint, \n  board: [str]\n};\n\n\n#[doc=\"build input data from stdin\"]\nfn fetch(stdin: io::reader) -> input {\n  let s = stdin.read_uint();\n  let v1 = stdin.read_ints();\n  let v2 = stdin.read_ints();\n\n  ret {\n    mut index: 0u, \n    s : s, \n    v1: v1, \n    v2: v2\n  };\n}\n\n#[doc=\"output status\"]\nenum out_status {\n  ready,\n  start, \n  solved((uint, str))\n}\n\n\nfn solve(in: input) -> str {\n  log(error, #fmt(\"idx.%u start solved\", in.index));\n\n  let mut v1 = in.v1;\n  let mut v2 = in.v2;\n  fn le(&&a: int, &&b: int) -> bool { int::le(a, b) }\n  fn ge(&&a: int, &&b: int) -> bool { int::ge(a, b) }\n\n  v1 = sort::merge_sort(le, v1);\n  v2 = sort::merge_sort(ge, v2);\n\n  fn times(&&x: int, &&y: int) -> int { ret x * y; }\n  fn sum(&&accum: int, &&a: int) -> int { ret accum+a; }\n  ret int::to_str(vec::foldl(0, vec::map2(v1, v2, times), sum), 10u);\n\n}\n\nfn main() {\n  let stdin = io::stdin();\n  let n = stdin.read_uint();\n  let mut inputs : [input] = [];\n  let mut outputs = vec::to_mut(vec::from_elem(n, \"\"));\n\n  let port = comm::port();\n  let chan = comm::chan(port);\n\n  log(error, #fmt(\"n: %u\", n));\n  uint::range(0u, n) {|i| \n    let in = fetch(stdin);\n    in.index = i;\n    inputs += [in];\n\n    task::spawn{||\n      build_actor(in, chan);\n    }\n  }\n\n  iter::repeat(n) {||\n    alt check comm::recv(port){\n     solved((idx, res)) {\n      outputs[idx] = res;\n     }\n     _ {\n      log(error, \"what?\");\n     }\n    }\n  }\n\n  vec::iteri(outputs){|i, res|\n    io::println(#fmt(\"Case #%u: %s\", i+1u, res));\n  }\n}\n\nfn build_actor(in: input, chan: comm::chan<out_status>) {\n  let res = solve(in);\n  comm::send(chan, solved((in.index, res)));\n}\n\n\n\u2191\u3066\u3099\u60f3\u5b9a\u3057\u3066\u308b\u554f\u984c\u306f2008 Round1A A\u306e\n2\n3\n1 3 -5\n-2 4 1\n5\n1 2 3 4 5\n1 0 1 0 1\n\u3068\u3044\u3046\u3088\u3046\u306a\u5f62\u5f0f\u306e\u3082\u306e\n\n\u6a19\u6e96\u5165\u529b\u304b\u3089\u554f\u984c\u3092\u53d7\u3051\u53d6\u308a\u30a2\u30af\u30bf\u30fc\u3066\u3099\u4e26\u5217\u306b\u7b54\u3048\u89e3\u3044\u3066\u6a19\u6e96\u51fa\u529b\u306b\u5410\u304d\u51fa\u3059\u7528\n[Rust](http://www.rust-lang.org/)\u304b\u308f\u3044\u3044\u3088[Rust](http://www.rust-lang.org/)\n\n```template.rs\nuse std;\n\nimport core::io;\nimport io::reader;\nimport io::reader_util;\nimport std::sort;\n\nimpl read_util for reader{  \n  fn read_valid_char() -> char {\n    let mut c;\n    do {\n      c = self.read_char();\n    } while c == '\\n' || c == ' ';\n    ret c;\n  }\n\n  fn read_valid_line() -> str{\n    let mut line;\n    do {\n      line = self.read_line();\n    } while line == \"\";\n    ret line;\n  }\n\n  fn read_uint() -> uint{\n    let raw_uint = self.read_valid_line();\n    ret option::get(uint::from_str(raw_uint));\n  }\n  fn read_int() -> int{\n    ret option::get(int::from_str(self.read_line()));\n  }\n  fn read_uints() -> [uint]{\n    fn to_uint(&&s: str) -> uint{\n      ret option::get(uint::from_str(s));\n    }\n    let line = self.read_line();\n    ret vec::map(str::split_char(line, ' '), to_uint);\n  }\n  fn read_ints() -> [int]{\n    fn to_int(&&s: str) -> int{\n      ret option::get(int::from_str(s));\n    }\n    let line = self.read_valid_line();\n    ret vec::map(str::split_char(line, ' '), to_int);\n  }\n}\n\n#[doc=\"input data type\"]\ntype input = {\n  mut index: uint,\n  w: uint, \n  h: uint, \n  board: [str]\n};\n\n\n#[doc=\"build input data from stdin\"]\nfn fetch(stdin: io::reader) -> input {\n  let s = stdin.read_uint();\n  let v1 = stdin.read_ints();\n  let v2 = stdin.read_ints();\n\n  ret {\n    mut index: 0u, \n    s : s, \n    v1: v1, \n    v2: v2\n  };\n}\n\n#[doc=\"output status\"]\nenum out_status {\n  ready,\n  start, \n  solved((uint, str))\n}\n\n\nfn solve(in: input) -> str {\n  log(error, #fmt(\"idx.%u start solved\", in.index));\n  \n  let mut v1 = in.v1;\n  let mut v2 = in.v2;\n  fn le(&&a: int, &&b: int) -> bool { int::le(a, b) }\n  fn ge(&&a: int, &&b: int) -> bool { int::ge(a, b) }\n  \n  v1 = sort::merge_sort(le, v1);\n  v2 = sort::merge_sort(ge, v2);\n\n  fn times(&&x: int, &&y: int) -> int { ret x * y; }\n  fn sum(&&accum: int, &&a: int) -> int { ret accum+a; }\n  ret int::to_str(vec::foldl(0, vec::map2(v1, v2, times), sum), 10u);\n\n}\n\nfn main() {\n  let stdin = io::stdin();\n  let n = stdin.read_uint();\n  let mut inputs : [input] = [];\n  let mut outputs = vec::to_mut(vec::from_elem(n, \"\"));\n\n  let port = comm::port();\n  let chan = comm::chan(port);\n\n  log(error, #fmt(\"n: %u\", n));\n  uint::range(0u, n) {|i| \n    let in = fetch(stdin);\n    in.index = i;\n    inputs += [in];\n    \n    task::spawn{||\n      build_actor(in, chan);\n    }\n  }\n  \n  iter::repeat(n) {||\n    alt check comm::recv(port){\n     solved((idx, res)) {\n      outputs[idx] = res;\n     }\n     _ {\n      log(error, \"what?\");\n     }\n    }\n  }\n\n  vec::iteri(outputs){|i, res|\n    io::println(#fmt(\"Case #%u: %s\", i+1u, res));\n  }\n}\n\nfn build_actor(in: input, chan: comm::chan<out_status>) {\n  let res = solve(in);\n  comm::send(chan, solved((in.index, res)));\n}\n```\n\n\u2191\u3066\u3099\u60f3\u5b9a\u3057\u3066\u308b\u554f\u984c\u306f2008 Round1A A\u306e\n\n2\n3\n1 3 -5\n-2 4 1\n5\n1 2 3 4 5\n1 0 1 0 1\n\n\u3068\u3044\u3046\u3088\u3046\u306a\u5f62\u5f0f\u306e\u3082\u306e\n", "tags": ["rust", "gcj"]}