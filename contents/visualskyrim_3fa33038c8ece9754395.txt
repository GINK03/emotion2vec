{"context": " More than 1 year has passed since last update.Ref:\n1 - Ebean and the OptimisticLockException\n2 - http://www.avaje.org/occ.html\n\nThe problem\nRecently, I have suffered a wired problem when using Ebean to update item. When I update it by doing following:\nSomeEntity entity = SomeEntity.find.byId(siteId);\nif (entity == null) {\n    // throw exception or send signal\n}\nentity.setTextAttr(\"A big text here\");\nentity.save();\n\nThen when I run this code, the save() statement give me a exception:\njavax.persistence.OptimisticLockException: Data has changed\n\nThe update code is pretty simple, and so does the definition of SomeEntity.\ncreate table SomeEntity (\n  id                        varchar(255) not null,\n  textAttr                  TEXT)\n;\n\n\nOptimisticLock\n(If you just want a quick solution, refer to the next section)\nAccording to avaje's document, OptimisticLock is a mechanism to avoid lost of updates when these updates occur in the same time on the same data.\nThis mechanism is very simple: check if old data has been changed. If the attributes before updated have been changed by other threads, the update will be abort by throwing OptimisticLockException.\nThere are two ways for Ebean to decide whether the old data has been changed:\n\ncheck all the attributes.(default way)\ncheck one special attribute defined by user named as Version Attribute.\n\nThe first one is how problem came out. When I performed save(), the Ebean actually mapped it into following sql:\nUPDATE some_entity SET text_attr = 'new value' WHERE id = 'item id' AND text_attr = 'old value';\n\nThis sql seems innocent, and it works well in the most time. However sometimes it can fail even if on one has changed the data. That is because sometimes database saves data as different value(to optimise the storing I guess). This could happen to double or text type of data. This will cause the where clause above fails, and make this update exceptional.\nAs an example mentioned by this post:\n\nIt can happen that you retrieve in your Java code something like 0.46712538003907 but in fact, in the database, the data stored is something like 0.467125380039068. When updating, the Java value will be included in the WHERE clause and, as it doesn\u2019t match the value stored in the database, the update will fail.\n\n\nSolution: Version Attribute\nBy adding Version Attribute to the model, you can specify Ebean only use this column to decide whether old value has been changed.\npublic class SomeEntity extends Model {\n    @Id\n    public String Id;\n\n    @Column(columnDefinition = \"MEDIUMTEXT\")\n    @Constraints.Required\n    public String TextAttr;\n\n    @Version\n    @Column(columnDefinition = \"timestamp default '2014-10-06 21:17:06'\")\n    public Timestamp lastUpdate; // here\n}\n\nYou don't need to change anything in the updating code. Now if you perform an update, the sql statement will be:\nUPDATE some_entity SET text_attr = 'new value' WHERE last_update = '2014-10-06 21:17:06';\n\nAnd problem should be solved.\n\nNote that OptimisticLock only happen in READ_COMMITTED Isolation level. So if you use transaction when update somehow, you might just walk around this problem.\nRef:\n\n1 - [Ebean and the OptimisticLockException](http://blog.matthieuguillermin.fr/2012/11/ebean-and-the-optimisticlockexception/)\n2 - [http://www.avaje.org/occ.html](http://www.avaje.org/occ.html)\n\n# The problem\n\nRecently, I have suffered a wired problem when using *Ebean* to update item. When I update it by doing following:\n\n```scala\nSomeEntity entity = SomeEntity.find.byId(siteId);\nif (entity == null) {\n    // throw exception or send signal\n}\nentity.setTextAttr(\"A big text here\");\nentity.save();\n```\n\nThen when I run this code, the `save()` statement give me a exception:\n\n```\njavax.persistence.OptimisticLockException: Data has changed\n```\n\nThe update code is pretty simple, and so does the definition of *SomeEntity*.\n\n```\ncreate table SomeEntity (\n  id                        varchar(255) not null,\n  textAttr                  TEXT)\n;\n```\n\n# OptimisticLock\n\n(If you just want a quick solution, refer to the next section)\n\nAccording to [avaje's document](http://www.avaje.org/occ.html), **OptimisticLock** is a mechanism to avoid lost of updates when these updates occur in the same time on the same data.\n\nThis mechanism is very simple: check if old data has been changed. If the attributes before updated have been changed by other threads, the update will be abort by throwing **OptimisticLockException**.\n\nThere are two ways for Ebean to decide whether the old data has been changed:\n\n- check all the attributes.(default way)\n- check one special attribute defined by user named as **Version Attribute**.\n\nThe first one is how problem came out. When I performed `save()`, the Ebean actually mapped it into following sql:\n\n```sql\nUPDATE some_entity SET text_attr = 'new value' WHERE id = 'item id' AND text_attr = 'old value';\n```\n\nThis sql seems innocent, and it works well in the most time. However sometimes it can fail even if on one has changed the data. That is because sometimes database saves data as different value(to optimise the storing I guess). This could happen to ***double*** or ***text*** type of data. This will cause the where clause above fails, and make this update exceptional.\n\n\nAs an example mentioned by [this post](http://blog.matthieuguillermin.fr/2012/11/ebean-and-the-optimisticlockexception/):\n\n> It can happen that you retrieve in your Java code something like 0.46712538003907 but in fact, in the database, the data stored is something like 0.467125380039068. When updating, the Java value will be included in the WHERE clause and, as it doesn\u2019t match the value stored in the database, the update will fail.\n\n\n# Solution: Version Attribute\n\nBy adding ***Version Attribute*** to the model, you can specify Ebean only use this column to decide whether old value has been changed.\n\n```java\npublic class SomeEntity extends Model {\n    @Id\n    public String Id;\n\n    @Column(columnDefinition = \"MEDIUMTEXT\")\n    @Constraints.Required\n    public String TextAttr;\n\n    @Version\n    @Column(columnDefinition = \"timestamp default '2014-10-06 21:17:06'\")\n    public Timestamp lastUpdate; // here\n}\n```\n\nYou don't need to change anything in the updating code. Now if you perform an update, the sql statement will be:\n\n\n```sql\nUPDATE some_entity SET text_attr = 'new value' WHERE last_update = '2014-10-06 21:17:06';\n```\n\nAnd problem should be solved.\n\n***\n\nNote that OptimisticLock only happen in READ_COMMITTED Isolation level. So if you use transaction when update somehow, you might just walk around this problem.\n", "tags": ["Java", "Ebean", "ORM"]}