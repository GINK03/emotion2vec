{"context": "\n\n\u306f\u3058\u3081\u306b\nC\u8a00\u8a9e\u3067IFTTT\u306eMaker\u30c1\u30a7\u30f3\u30cd\u30eb\u306bProxy\u8d8a\u3048\u3067\u30a2\u30af\u30bb\u30b9\u3059\u308b\u65b9\u6cd5\n\n\u30b3\u30fc\u30c9\nhttp://qiita.com/edo_m18/items/cef278d0c14d1371db3b \u3092\u53c2\u8003\u306b\u3057\u3066\u3044\u307e\u3059\u3002\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <sys/types.h>\n#include <netdb.h>\n#include <netinet/in.h>\n#include <sys/param.h>\n#include <unistd.h>\n\n#define proxy_url \"*******\" //Proxy\u30b5\u30fc\u30d0\u306e\u540d\u524d\u3092\u5165\u529b\n#define proxy_port 8080\n\n#define BUF_LEN 256\n\nstruct URL {\n    char host[BUF_LEN];\n    char path[BUF_LEN];\n    char query[BUF_LEN];\n    char fragment[BUF_LEN];\n    unsigned short port;\n};\n\nint main(int argc, char **argv) {\n\n    // \u30bd\u30b1\u30c3\u30c8\u306e\u305f\u3081\u306e\u30d5\u30a1\u30a4\u30eb\u30c7\u30a3\u30b9\u30af\u30ea\u30d7\u30bf\n    int s;\n\n    // IP\u30a2\u30c9\u30ec\u30b9\u306e\u89e3\u6c7a\n    struct addrinfo hints, *res;\n    struct sockaddr_in *addr_in;\n    struct in_addr addr;\n    int err;\n\n    // \u30b5\u30fc\u30d0\u306b\u9001\u308bHTTP\u30d7\u30ed\u30c8\u30b3\u30eb\u7528\u30d0\u30c3\u30d5\u30a1\n    char send_buf[BUF_LEN];\n    struct URL url = {\n         \"maker.ifttt.com\",\n         \"/trigger/*****/with/key/*******\",\"\",\"\",80\n    }; //\u5185\u5bb9\u306f\u9069\u5b9c\u5909\u66f4\n\n    printf(\"http://%s%s%s \u3092\u53d6\u5f97\u3057\u307e\u3059\u3002\\n\\n\", url.host, url.path, url.query);\n\n     // 0\u30af\u30ea\u30a2\n     memset(&hints, 0, sizeof(hints));\n     hints.ai_socktype = SOCK_STREAM;\n     hints.ai_family   = AF_INET;\n\n     char *serviceType = \"http\";\n\n#ifdef proxy_url\n    if ((err = getaddrinfo(proxy_url, serviceType, &hints, &res)) != 0){\n        printf(\"error %d\\n\", err);\n        return 1;\n    }\n#else\n    if ((err = getaddrinfo(url.host, serviceType, &hints, &res)) != 0) {\n        printf(\"error %d\\n\", err);\n        return 1;\n    }\n#endif\n\n    // \u30bd\u30b1\u30c3\u30c8\u751f\u6210\n    if ((s = socket(res->ai_family, res->ai_socktype,res->ai_protocol)) <0) {\n         fprintf(stderr, \"\u30bd\u30b1\u30c3\u30c8\u306e\u751f\u6210\u306b\u5931\u6557\u3057\u307e\u3057\u305f\u3002\\n\");\n         return 1;\n     }\n\n#ifdef proxy_port\n     addr_in = (struct sockaddr_in *)(res -> ai_addr);\n     addr_in -> sin_port=htons(proxy_port); #endif\n\n     // \u30b5\u30fc\u30d0\u306b\u63a5\u7d9a\n     if (connect(s, res->ai_addr, res->ai_addrlen) != 0) {\n         fprintf(stderr, \"connect\u306b\u5931\u6557\u3057\u307e\u3057\u305f\u3002\\n\");\n         return 1;\n     }\n\n     // HTTP\u30d7\u30ed\u30c8\u30b3\u30eb\u306e\u958b\u59cb \uff06\u30b5\u30fc\u30d0\u306b\u9001\u4fe1\n#ifdef proxy_url\n    sprintf(send_buf, \"POST http://%s%s%s HTTP/1.0\\r\\n\", url.host, url.path, url.query); #else\n    sprintf(send_buf, \"POST %s%s HTTP/1.0\\r\\n\", url.path, url.query);\n#endif\n    write(s, send_buf, strlen(send_buf));\n    sprintf(send_buf, \"Host: %s:%d\\r\\n\", url.host, url.port);\n    write(s, send_buf, strlen(send_buf));\n\n    sprintf(send_buf, \"\\r\\n\");\n    write(s, send_buf, strlen(send_buf));\n    // \u53d7\u4fe1\u304c\u7d42\u308f\u308b\u307e\u3067\u30eb\u30fc\u30d7\n    while(1) {\n        char buf[BUF_LEN];\n        int read_size;\n        read_size = read(s, buf, BUF_LEN);\n\n        if (read_size > 0) {\n            write(1, buf, read_size);\n        }\n        else {\n            break;\n        }\n    }\n\n    // \u30bd\u30b1\u30c3\u30c8\u3092\u9589\u3058\u308b\n    close(s);\n    return 0;\n}\n\n\n#\u306f\u3058\u3081\u306b\nC\u8a00\u8a9e\u3067IFTTT\u306eMaker\u30c1\u30a7\u30f3\u30cd\u30eb\u306bProxy\u8d8a\u3048\u3067\u30a2\u30af\u30bb\u30b9\u3059\u308b\u65b9\u6cd5\n\n#\u30b3\u30fc\u30c9\nhttp://qiita.com/edo_m18/items/cef278d0c14d1371db3b \u3092\u53c2\u8003\u306b\u3057\u3066\u3044\u307e\u3059\u3002\n\n```\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <sys/types.h>\n#include <netdb.h>\n#include <netinet/in.h>\n#include <sys/param.h>\n#include <unistd.h>\n\n#define proxy_url \"*******\" //Proxy\u30b5\u30fc\u30d0\u306e\u540d\u524d\u3092\u5165\u529b\n#define proxy_port 8080\n\n#define BUF_LEN 256\n\nstruct URL {\n    char host[BUF_LEN];\n    char path[BUF_LEN];\n    char query[BUF_LEN];\n    char fragment[BUF_LEN];\n    unsigned short port;\n};\n\nint main(int argc, char **argv) {\n\n    // \u30bd\u30b1\u30c3\u30c8\u306e\u305f\u3081\u306e\u30d5\u30a1\u30a4\u30eb\u30c7\u30a3\u30b9\u30af\u30ea\u30d7\u30bf\n    int s;\n\n    // IP\u30a2\u30c9\u30ec\u30b9\u306e\u89e3\u6c7a\n    struct addrinfo hints, *res;\n    struct sockaddr_in *addr_in;\n    struct in_addr addr;\n    int err;\n\n    // \u30b5\u30fc\u30d0\u306b\u9001\u308bHTTP\u30d7\u30ed\u30c8\u30b3\u30eb\u7528\u30d0\u30c3\u30d5\u30a1\n    char send_buf[BUF_LEN];\n    struct URL url = {\n         \"maker.ifttt.com\",\n         \"/trigger/*****/with/key/*******\",\"\",\"\",80\n    }; //\u5185\u5bb9\u306f\u9069\u5b9c\u5909\u66f4\n\n    printf(\"http://%s%s%s \u3092\u53d6\u5f97\u3057\u307e\u3059\u3002\\n\\n\", url.host, url.path, url.query);\n\n     // 0\u30af\u30ea\u30a2\n     memset(&hints, 0, sizeof(hints));\n     hints.ai_socktype = SOCK_STREAM;\n     hints.ai_family   = AF_INET;\n\n     char *serviceType = \"http\";\n\n#ifdef proxy_url\n    if ((err = getaddrinfo(proxy_url, serviceType, &hints, &res)) != 0){\n        printf(\"error %d\\n\", err);\n        return 1;\n    }\n#else\n    if ((err = getaddrinfo(url.host, serviceType, &hints, &res)) != 0) {\n        printf(\"error %d\\n\", err);\n        return 1;\n    }\n#endif\n\n    // \u30bd\u30b1\u30c3\u30c8\u751f\u6210\n    if ((s = socket(res->ai_family, res->ai_socktype,res->ai_protocol)) <0) {\n         fprintf(stderr, \"\u30bd\u30b1\u30c3\u30c8\u306e\u751f\u6210\u306b\u5931\u6557\u3057\u307e\u3057\u305f\u3002\\n\");\n         return 1;\n     }\n\n#ifdef proxy_port\n     addr_in = (struct sockaddr_in *)(res -> ai_addr);\n     addr_in -> sin_port=htons(proxy_port); #endif\n\n     // \u30b5\u30fc\u30d0\u306b\u63a5\u7d9a\n     if (connect(s, res->ai_addr, res->ai_addrlen) != 0) {\n         fprintf(stderr, \"connect\u306b\u5931\u6557\u3057\u307e\u3057\u305f\u3002\\n\");\n         return 1;\n     }\n\n     // HTTP\u30d7\u30ed\u30c8\u30b3\u30eb\u306e\u958b\u59cb \uff06\u30b5\u30fc\u30d0\u306b\u9001\u4fe1\n#ifdef proxy_url\n    sprintf(send_buf, \"POST http://%s%s%s HTTP/1.0\\r\\n\", url.host, url.path, url.query); #else\n    sprintf(send_buf, \"POST %s%s HTTP/1.0\\r\\n\", url.path, url.query);\n#endif\n    write(s, send_buf, strlen(send_buf));\n    sprintf(send_buf, \"Host: %s:%d\\r\\n\", url.host, url.port);\n    write(s, send_buf, strlen(send_buf));\n\n    sprintf(send_buf, \"\\r\\n\");\n    write(s, send_buf, strlen(send_buf));\n    // \u53d7\u4fe1\u304c\u7d42\u308f\u308b\u307e\u3067\u30eb\u30fc\u30d7\n    while(1) {\n        char buf[BUF_LEN];\n        int read_size;\n        read_size = read(s, buf, BUF_LEN);\n\n        if (read_size > 0) {\n            write(1, buf, read_size);\n        }\n        else {\n            break;\n        }\n    }\n\n    // \u30bd\u30b1\u30c3\u30c8\u3092\u9589\u3058\u308b\n    close(s);\n    return 0;\n}\n\n```\n", "tags": ["C", "ifttt", "proxy", "HttpClient"]}