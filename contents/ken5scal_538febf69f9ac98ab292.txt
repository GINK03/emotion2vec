{"context": "Go\u3067AES\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0(CBC\u30e2\u30fc\u30c9)\u3092\u4f7f\u3063\u305f\u5b9f\u88c5\u3092\u3059\u308b\u306e\u7d9a\u304d\nAES\u306f\u30d6\u30ed\u30c3\u30af\u6697\u53f7\u3067\u3042\u308b\u305f\u3081\u300116\u306e\u500d\u6570\u30d0\u30a4\u30c8\u306e\u5e73\u6587\u306b\u3057\u304b\u9069\u7528\u3067\u304d\u306a\u3044\u3002\u305d\u3046\u3067\u306a\u3044\u5e73\u6587\u3092AES\u3067\u6697\u53f7\u5316\u3059\u308b\u306b\u306f\u8ffd\u52a0\u306e\u30c7\u30fc\u30bf(\u30d1\u30c7\u30a3\u30f3\u30b0)\u3092\u4ed8\u4e0e\u3057\u306616\u306e\u500d\u6570\u30d0\u30a4\u30c8\u306b\u3057\u3066\u3084\u308b\u5fc5\u8981\u304c\u3042\u308b\u3002AES\u3092\u542b\u3081\u305f\u5171\u901a\u9375\u65b9\u5f0f\u306e\u30d1\u30c7\u30a3\u30f3\u30b0\u306b\u306f\u3044\u304f\u3064\u304b\u7a2e\u985e\u304c\u3042\u3063\u3066\u3001Wiki\u306b\u3088\u308b\u3068\u4ee5\u4e0b\u306e\u901a\u308a\u3067\u3042\u308b\u3002\n* Bit Padding, Byte Padding, ANSI X.923, ISO 10126, PKCS#7, ISO/IEC 7816-4, Zero padding\n\u767d\u72b6\u3059\u308b\u3068\u3001\u5404\u3005\u304c\u4f55\u306b\u9069\u3057\u3066\u3044\u308b\u304b\u306f\u308f\u304b\u3089\u306a\u3044\u3057\u3001\u8abf\u3079\u308b\u6c17\u529b\u3082\u306a\u304b\u3063\u305f\u3002\u305f\u3060PKCS #7\u306f\u3001RSA\u516c\u958b\u9375\u65b9\u5f0f\u3067\u4f7f\u308f\u308c\u3066\u3044\u305f\u306f\u305a\u306a\u306e\u3067\u3001\u4fe1\u983c\u3068\u5b9f\u7e3e\u3067\u305d\u308c\u3092\u4f7f\u3063\u3066\u307f\u3088\u3046\u3068\u601d\u3046\u3002\u305f\u3060\u3001Go\u306e\u5834\u5408\u306f\u3001Padding\u95a2\u4fc2\u306e\u30d1\u30c3\u30b1\u30fc\u30b8\u304c\u5bb9\u6613\u3055\u308c\u3066\u306a\u3044\u306e\u3067\u3001\u81ea\u524d\u5b9f\u88c5\u3059\u308b\u3053\u3068\u306b\u306a\u308b\u3002\u30e1\u30f3\u30c9\u30af\u30b5\u30a4\n\nPKCS7\u306b\u3088\u308b\u5b9f\u88c5\nPKCS7\u306e\u30d1\u30c7\u30a3\u30f3\u30b0\u306f\u3001RFC5652\u306b\u3042\u308b\u901a\u308a\u3001\u8ffd\u52a0\u3057\u305f\u3044\u30d1\u30c7\u30a3\u30f3\u30b0\u9577\u3092\u5024\u306b\u3057\u305f\u30d0\u30a4\u30c8\u3092\u8ffd\u52a0\u3059\u308b\u5f62\u306b\u306a\u308b\u3002\u6570\u5f0f\u306b\u3059\u308b\u3068\u3001\u4ee5\u4e0b\u306e\u3068\u304a\u308a\u3002\n\nk-(lth mod k)\n\nk\u306f\u30d6\u30ed\u30c3\u30af\u30b5\u30a4\u30ba\u3067\u3042\u308a\u3001AES\u306e\u5834\u5408\u306f16\u306b\u306a\u308b\u3002lth\u306f\u5e73\u6587\uff08\u30d0\u30a4\u30c8)\u306e\u9577\u3055\u306b\u306a\u308b\u3002\u4e0a\u8a18\u3067\u5c0e\u304d\u3060\u3057\u305f\u3082\u306e\u304c\u3001\u30d1\u30c7\u30a3\u30f3\u30b0\u306e\u5024\u306b\u306a\u308b\u3002\u4f8b\u3048\u3070(lth mod k)=1\u3060\u3068\u3057\u305f\u3089\u300101\u304c\u30d1\u30c7\u30a3\u30f3\u30b0\u306b\u306a\u308a\u3001(lth mod k)=2\u3060\u3068\u3057\u305f\u3089\u300102 02\u304c\u30d1\u30c7\u30a3\u30f3\u30b0\u306b\u306a\u308b\u3002\u305f\u3060\u3001(lth mod k)=0\u306e\u5834\u5408\u300116 16.....16\u304c\u30d1\u30c7\u30a3\u30f3\u30b0\u306b\u306a\u308b\u3002\u3053\u308c\u3092Go\u3067\u5b9f\u88c5\u3059\u308b\u3068\u4ee5\u4e0b\u306e\u901a\u308a\u3002\nfunc PadByPkcs7(data []byte) []byte {\n    padSize := aes.BlockSize\n    if len(data) % aes.BlockSize != 0 {\n        padSize = aes.BlockSize - (len(data)) % aes.BlockSize\n    }\n\n    pad := bytes.Repeat([]byte{byte(padSize)}, padSize)\n    return append(data, pad...) // Dots represent it unpack Slice(pad) into individual bytes\n}\n\nfunc UnPadByPkcs7(data []byte) []byte {\n    padSize := int(data[len(data) - 1])\n    return data[:len(data) - padSize]\n}\n\nfunc EncryptByCBCMode(key []byte, plainText string) ([]byte, error) {\n    //if len(plainText) % aes.BlockSize != 0 { <-\u3044\u3089\u306a\u304f\u306a\u3063\u305f\n    //  panic(\"Plain text must be multiple of 128bit\")\n    //}\n\n    block, err := aes.NewCipher(key); if err != nil {\n        return nil, err\n    }\n\n    paddedPlaintext := PadByPkcs7([]byte(plainText))\n    fmt.Printf(\"Padded Plain Text in byte format: %v\\n\", paddedPlaintext)\n    cipherText := make([]byte, aes.BlockSize + len(paddedPlaintext)) // cipher text must be larger than plaintext\n    iv := cipherText[:aes.BlockSize] // Unique iv is required\n    _, err = rand.Read(iv); if err != nil {\n        return nil, err\n    }\n\n    cbc := cipher.NewCBCEncrypter(block, iv)\n    cbc.CryptBlocks(cipherText[aes.BlockSize:], paddedPlaintext)\n    cipherTextBase64 := base64.StdEncoding.EncodeToString(cipherText)\n    return []byte(cipherTextBase64), nil\n}\n\nfunc DecryptByCBCMode(key []byte, cipherTextBase64 []byte) (string, error) {\n    block, err := aes.NewCipher(key); if err != nil {\n        return \"\", err\n    }\n\n    cipherText, _ := base64.StdEncoding.DecodeString(string(cipherTextBase64))\n\n    if len(cipherText) < aes.BlockSize {\n        panic(\"cipher text must be longer than blocksize\")\n    } else if len(cipherText) % aes.BlockSize != 0 {\n        panic(\"cipher text must be multiple of blocksize(128bit)\")\n    }\n    iv := cipherText[:aes.BlockSize] // assuming iv is stored in the first block of ciphertext\n    cipherText = cipherText[aes.BlockSize:]\n    plainText := make([]byte, len(cipherText))\n\n    cbc := cipher.NewCBCDecrypter(block, iv)\n    cbc.CryptBlocks(plainText, cipherText)\n    return string(UnPadByPkcs7(plainText)), nil\n}\n\nfunc main() {\n    plainText = \"12345\" // Padding\u3057\u306a\u3044\u3068\u30a8\u30e9\u30fc\u306b\u306a\u308b\u5e73\u6587\n    cipherText, _ = EncryptByCBCMode(key, plainText)\n    fmt.Printf(\"Plaintext %v is encrypted into %v:\\n\", plainText, cipherText)\n    decryptedText,_ = DecryptByCBCMode(key, cipherText)\n    fmt.Printf(\"Decrypted Text: %v\\n \", decryptedText)\n}\n>> \n                                                  |-> \u3053\u3063\u304b\u3089\u30d1\u30c7\u30a3\u30f3\u30b0\nPadded Plain Text in byte format: [49 50 51 52 53 11 11 11 11 11 11 11 11 11 11 11]\nPlaintext 12345 is encrypted into [116 51 109 107 87 53 103 43 86 65 114 73 104 99 75 97 85 76 121 71 109 90 122 70 83 122 90 120 98 102 112 72 43 74 111 69 48 76 79 97 98 69 56 61]:\nDecrypted Text: 12345\n\n\u4ee5\u4e0a\u3002\n\n\u304a\u307e\u3051 - \u30d1\u30c7\u30a3\u30f3\u30b0\u306b\u5bfe\u3059\u308b\u653b\u6483\n\u6697\u53f7\u6587+\u30d1\u30c7\u30a3\u30f3\u30b0\u3092\u7e70\u308a\u8fd4\u3057\u9001\u308b\u3053\u3068\u3067\u5e73\u6587\u3092\u4e00\u90e8\u63a8\u6e2c\u3067\u304d\u3066\u3057\u307e\u3046\u653b\u6483\u624b\u6cd5(\u30d1\u30c7\u30a3\u30f3\u30b0\u30aa\u30e9\u30af\u30eb\u653b\u6483)\u304c\u3042\u308b\u3002SSL3.0\u306b\u304a\u3051\u308b\u8106\u5f31\u6027(POODLE)\u306f\u3053\u308c\u3092\u5229\u7528\u3057\u305f\u3082\u306e\u306b\u306a\u308b\u3002\u3053\u306e\u653b\u6483\u3092\u9632\u3050\u305f\u3081\u306b\u306f\u3001\u5fa9\u53f7\u3057\u3088\u3046\u3068\u3057\u3066\u3044\u308b\u6697\u53f7\u6587\u304c\u6b63\u3057\u3044\u30b5\u30d6\u30b8\u30a7\u30af\u30c8\u306b\u3088\u3063\u3066\u751f\u6210\u3055\u308c\u305f\u3082\u306e\u304b\u3092\u8a8d\u8a3c\u308c\u3070\u3088\u3044(MAC)\u3002MAC\u306f\u53c8\u4eca\u5f8c\u66f8\u304f\u3064\u3082\u308a\u3002\n[Go\u3067AES\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0(CBC\u30e2\u30fc\u30c9)\u3092\u4f7f\u3063\u305f\u5b9f\u88c5\u3092\u3059\u308b](http://qiita.com/ken5scal/items/22efdace02b199f7007f)\u306e\u7d9a\u304d\n\nAES\u306f\u30d6\u30ed\u30c3\u30af\u6697\u53f7\u3067\u3042\u308b\u305f\u3081\u300116\u306e\u500d\u6570\u30d0\u30a4\u30c8\u306e\u5e73\u6587\u306b\u3057\u304b\u9069\u7528\u3067\u304d\u306a\u3044\u3002\u305d\u3046\u3067\u306a\u3044\u5e73\u6587\u3092AES\u3067\u6697\u53f7\u5316\u3059\u308b\u306b\u306f\u8ffd\u52a0\u306e\u30c7\u30fc\u30bf(\u30d1\u30c7\u30a3\u30f3\u30b0)\u3092\u4ed8\u4e0e\u3057\u306616\u306e\u500d\u6570\u30d0\u30a4\u30c8\u306b\u3057\u3066\u3084\u308b\u5fc5\u8981\u304c\u3042\u308b\u3002AES\u3092\u542b\u3081\u305f\u5171\u901a\u9375\u65b9\u5f0f\u306e\u30d1\u30c7\u30a3\u30f3\u30b0\u306b\u306f\u3044\u304f\u3064\u304b\u7a2e\u985e\u304c\u3042\u3063\u3066\u3001Wiki\u306b\u3088\u308b\u3068\u4ee5\u4e0b\u306e\u901a\u308a\u3067\u3042\u308b\u3002\n* Bit Padding, Byte Padding, ANSI X.923, ISO 10126, PKCS#7, ISO/IEC 7816-4, Zero padding\n\n\u767d\u72b6\u3059\u308b\u3068\u3001\u5404\u3005\u304c\u4f55\u306b\u9069\u3057\u3066\u3044\u308b\u304b\u306f\u308f\u304b\u3089\u306a\u3044\u3057\u3001\u8abf\u3079\u308b\u6c17\u529b\u3082\u306a\u304b\u3063\u305f\u3002\u305f\u3060PKCS #7\u306f\u3001RSA\u516c\u958b\u9375\u65b9\u5f0f\u3067\u4f7f\u308f\u308c\u3066\u3044\u305f\u306f\u305a\u306a\u306e\u3067\u3001\u4fe1\u983c\u3068\u5b9f\u7e3e\u3067\u305d\u308c\u3092\u4f7f\u3063\u3066\u307f\u3088\u3046\u3068\u601d\u3046\u3002\u305f\u3060\u3001Go\u306e\u5834\u5408\u306f\u3001Padding\u95a2\u4fc2\u306e\u30d1\u30c3\u30b1\u30fc\u30b8\u304c\u5bb9\u6613\u3055\u308c\u3066\u306a\u3044\u306e\u3067\u3001\u81ea\u524d\u5b9f\u88c5\u3059\u308b\u3053\u3068\u306b\u306a\u308b\u3002~~\u30e1\u30f3\u30c9\u30af\u30b5\u30a4~~\n\n#PKCS7\u306b\u3088\u308b\u5b9f\u88c5\nPKCS7\u306e\u30d1\u30c7\u30a3\u30f3\u30b0\u306f\u3001[RFC5652](https://tools.ietf.org/html/rfc5652#section-6.3)\u306b\u3042\u308b\u901a\u308a\u3001\u8ffd\u52a0\u3057\u305f\u3044\u30d1\u30c7\u30a3\u30f3\u30b0\u9577\u3092\u5024\u306b\u3057\u305f\u30d0\u30a4\u30c8\u3092\u8ffd\u52a0\u3059\u308b\u5f62\u306b\u306a\u308b\u3002\u6570\u5f0f\u306b\u3059\u308b\u3068\u3001\u4ee5\u4e0b\u306e\u3068\u304a\u308a\u3002\n\n* k-(lth mod k)\n\nk\u306f\u30d6\u30ed\u30c3\u30af\u30b5\u30a4\u30ba\u3067\u3042\u308a\u3001AES\u306e\u5834\u5408\u306f16\u306b\u306a\u308b\u3002lth\u306f\u5e73\u6587\uff08\u30d0\u30a4\u30c8)\u306e\u9577\u3055\u306b\u306a\u308b\u3002\u4e0a\u8a18\u3067\u5c0e\u304d\u3060\u3057\u305f\u3082\u306e\u304c\u3001\u30d1\u30c7\u30a3\u30f3\u30b0\u306e\u5024\u306b\u306a\u308b\u3002\u4f8b\u3048\u3070(lth mod k)=1\u3060\u3068\u3057\u305f\u3089\u300101\u304c\u30d1\u30c7\u30a3\u30f3\u30b0\u306b\u306a\u308a\u3001(lth mod k)=2\u3060\u3068\u3057\u305f\u3089\u300102 02\u304c\u30d1\u30c7\u30a3\u30f3\u30b0\u306b\u306a\u308b\u3002\u305f\u3060\u3001(lth mod k)=0\u306e\u5834\u5408\u300116 16.....16\u304c\u30d1\u30c7\u30a3\u30f3\u30b0\u306b\u306a\u308b\u3002\u3053\u308c\u3092Go\u3067\u5b9f\u88c5\u3059\u308b\u3068\u4ee5\u4e0b\u306e\u901a\u308a\u3002\n\n```\nfunc PadByPkcs7(data []byte) []byte {\n\tpadSize := aes.BlockSize\n\tif len(data) % aes.BlockSize != 0 {\n\t\tpadSize = aes.BlockSize - (len(data)) % aes.BlockSize\n\t}\n\n\tpad := bytes.Repeat([]byte{byte(padSize)}, padSize)\n\treturn append(data, pad...) // Dots represent it unpack Slice(pad) into individual bytes\n}\n\nfunc UnPadByPkcs7(data []byte) []byte {\n\tpadSize := int(data[len(data) - 1])\n\treturn data[:len(data) - padSize]\n}\n\nfunc EncryptByCBCMode(key []byte, plainText string) ([]byte, error) {\n\t//if len(plainText) % aes.BlockSize != 0 { <-\u3044\u3089\u306a\u304f\u306a\u3063\u305f\n\t//\tpanic(\"Plain text must be multiple of 128bit\")\n\t//}\n\n\tblock, err := aes.NewCipher(key); if err != nil {\n\t\treturn nil, err\n\t}\n\n\tpaddedPlaintext := PadByPkcs7([]byte(plainText))\n\tfmt.Printf(\"Padded Plain Text in byte format: %v\\n\", paddedPlaintext)\n\tcipherText := make([]byte, aes.BlockSize + len(paddedPlaintext)) // cipher text must be larger than plaintext\n\tiv := cipherText[:aes.BlockSize] // Unique iv is required\n\t_, err = rand.Read(iv); if err != nil {\n\t\treturn nil, err\n\t}\n\n\tcbc := cipher.NewCBCEncrypter(block, iv)\n\tcbc.CryptBlocks(cipherText[aes.BlockSize:], paddedPlaintext)\n\tcipherTextBase64 := base64.StdEncoding.EncodeToString(cipherText)\n\treturn []byte(cipherTextBase64), nil\n}\n\nfunc DecryptByCBCMode(key []byte, cipherTextBase64 []byte) (string, error) {\n\tblock, err := aes.NewCipher(key); if err != nil {\n\t\treturn \"\", err\n\t}\n\n\tcipherText, _ := base64.StdEncoding.DecodeString(string(cipherTextBase64))\n\n\tif len(cipherText) < aes.BlockSize {\n\t\tpanic(\"cipher text must be longer than blocksize\")\n\t} else if len(cipherText) % aes.BlockSize != 0 {\n\t\tpanic(\"cipher text must be multiple of blocksize(128bit)\")\n\t}\n\tiv := cipherText[:aes.BlockSize] // assuming iv is stored in the first block of ciphertext\n\tcipherText = cipherText[aes.BlockSize:]\n\tplainText := make([]byte, len(cipherText))\n\n\tcbc := cipher.NewCBCDecrypter(block, iv)\n\tcbc.CryptBlocks(plainText, cipherText)\n\treturn string(UnPadByPkcs7(plainText)), nil\n}\n```\n\n```\nfunc main() {\n\tplainText = \"12345\" // Padding\u3057\u306a\u3044\u3068\u30a8\u30e9\u30fc\u306b\u306a\u308b\u5e73\u6587\n\tcipherText, _ = EncryptByCBCMode(key, plainText)\n\tfmt.Printf(\"Plaintext %v is encrypted into %v:\\n\", plainText, cipherText)\n\tdecryptedText,_ = DecryptByCBCMode(key, cipherText)\n\tfmt.Printf(\"Decrypted Text: %v\\n \", decryptedText)\n}\n>> \n                                                  |-> \u3053\u3063\u304b\u3089\u30d1\u30c7\u30a3\u30f3\u30b0\nPadded Plain Text in byte format: [49 50 51 52 53 11 11 11 11 11 11 11 11 11 11 11]\nPlaintext 12345 is encrypted into [116 51 109 107 87 53 103 43 86 65 114 73 104 99 75 97 85 76 121 71 109 90 122 70 83 122 90 120 98 102 112 72 43 74 111 69 48 76 79 97 98 69 56 61]:\nDecrypted Text: 12345\n```\n\u4ee5\u4e0a\u3002\n\n# \u304a\u307e\u3051 - \u30d1\u30c7\u30a3\u30f3\u30b0\u306b\u5bfe\u3059\u308b\u653b\u6483\n\u6697\u53f7\u6587+\u30d1\u30c7\u30a3\u30f3\u30b0\u3092\u7e70\u308a\u8fd4\u3057\u9001\u308b\u3053\u3068\u3067\u5e73\u6587\u3092\u4e00\u90e8\u63a8\u6e2c\u3067\u304d\u3066\u3057\u307e\u3046\u653b\u6483\u624b\u6cd5(\u30d1\u30c7\u30a3\u30f3\u30b0\u30aa\u30e9\u30af\u30eb\u653b\u6483)\u304c\u3042\u308b\u3002SSL3.0\u306b\u304a\u3051\u308b\u8106\u5f31\u6027(POODLE)\u306f\u3053\u308c\u3092\u5229\u7528\u3057\u305f\u3082\u306e\u306b\u306a\u308b\u3002\u3053\u306e\u653b\u6483\u3092\u9632\u3050\u305f\u3081\u306b\u306f\u3001\u5fa9\u53f7\u3057\u3088\u3046\u3068\u3057\u3066\u3044\u308b\u6697\u53f7\u6587\u304c\u6b63\u3057\u3044\u30b5\u30d6\u30b8\u30a7\u30af\u30c8\u306b\u3088\u3063\u3066\u751f\u6210\u3055\u308c\u305f\u3082\u306e\u304b\u3092\u8a8d\u8a3c\u308c\u3070\u3088\u3044(MAC)\u3002MAC\u306f\u53c8\u4eca\u5f8c\u66f8\u304f\u3064\u3082\u308a\u3002\n", "tags": ["Go1.7.1", "\u30bb\u30ad\u30e5\u30ea\u30c6\u30a3", "\u6697\u53f7", "Security"]}