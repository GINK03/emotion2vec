{"context": " More than 1 year has passed since last update.\u300cSoftware Foundations\u300d\u306eLogic_J\u3067\u5b9a\u5f0f\u5316\u3055\u308c\u305f\u9ce9\u306e\u5de3\u539f\u7406\u306e\u8a3c\u660e\u3002\n\npigeonhole_principle.v\n(*  (* Logic_J.v \u306e\u72ec\u81ea(<=)\u3092\u4f7f\u3046\u5834\u5408\u306f\u3053\u306e\u4e2d\u8eab\u304c\u5fc5\u8981 *)\nLemma lt_irrefl : forall n, ~ n < n.\nProof.\n induction n.\n  intro. inversion H.\n\n  intro. destruct IHn.\n  apply Sn_le_Sm__n_le_m. apply H.\nQed.\n\nLemma lt_not_le: forall n m : nat, n < m -> ~ m <= n.\nProof.\n intros.\n induction H.\n  apply lt_irrefl.\n\n  intro. destruct IHle. inversion H0.\n   apply le_S. apply le_n.\n\n   rewrite <- H2 in H0. apply le_S. apply Sn_le_Sm__n_le_m. apply H0.\nQed. \n*)\n\nLemma aux1 : forall {X:Type} (x:X) xs l1 l2, (forall a, appears_in a (x :: xs ) -> appears_in a (l1++(x::l2))) -> ~repeats (x::xs) -> forall a, appears_in a xs -> appears_in a (l1++l2).\nProof.\n intros.\n destruct (appears_in_app l1 (x::l2) a (H a (ai_later a x xs H1))).\n  apply app_appears_in. left. apply H2.\n\n  apply app_appears_in. right.\n  inversion H2.\n   destruct H0. rewrite <- H4. apply RP_hd. apply H1.\n\n   apply H4.\nQed.\n\nLemma aux2 : forall {X:Type} xs ys,\n  (forall a:X, appears_in a xs -> appears_in a ys) ->\n  ~ repeats xs -> length xs <= length ys.\nProof.\n intros X xs. induction xs; intros.\n  apply O_le_n.  \n\n  destruct (appears_in_app_split _ _ (H x (ai_here _ _))) as [l1].\n  destruct H1 as [l2].\n  rewrite H1. rewrite app_length. simpl. \n  rewrite <- plus_n_Sm. apply n_le_m__Sn_le_Sm. rewrite <- app_length.\n  apply IHxs. (*\u3053\u3053\u3067(l1++l2)\u306b\u3064\u3044\u3066IH\u3092\u4f7f\u3046*)\n   intros. rewrite H1 in H. apply (aux1 _ _ _ _ H H0). apply H2.\n\n   intro. destruct H0. apply RP_tl. apply H2.\nQed.\n\nTheorem pigeonhole_principle: forall {X:Type} (l1 l2:list X),\n  excluded_middle ->\n  (forall x, appears_in x l1 -> appears_in x l2) ->\n  length l2 < length l1 ->\n  repeats l1.\nProof.\n intros.\n Check(H (repeats l1)).\n destruct (H (repeats l1)); [assumption |]. (* \u80cc\u7406\u6cd5 *)\n destruct (lt_not_le _ _ H1).\n apply aux2; [apply H0 | apply H2].\nQed.\n\n\n\u300c[Software Foundations](http://proofcafe.org/sf/)\u300d\u306e[Logic_J](http://proofcafe.org/sf/Logic_J.html)\u3067\u5b9a\u5f0f\u5316\u3055\u308c\u305f\u9ce9\u306e\u5de3\u539f\u7406\u306e\u8a3c\u660e\u3002\n\n```coq:pigeonhole_principle.v\n(*  (* Logic_J.v \u306e\u72ec\u81ea(<=)\u3092\u4f7f\u3046\u5834\u5408\u306f\u3053\u306e\u4e2d\u8eab\u304c\u5fc5\u8981 *)\nLemma lt_irrefl : forall n, ~ n < n.\nProof.\n induction n.\n  intro. inversion H.\n\n  intro. destruct IHn.\n  apply Sn_le_Sm__n_le_m. apply H.\nQed.\n\nLemma lt_not_le: forall n m : nat, n < m -> ~ m <= n.\nProof.\n intros.\n induction H.\n  apply lt_irrefl.\n\n  intro. destruct IHle. inversion H0.\n   apply le_S. apply le_n.\n\n   rewrite <- H2 in H0. apply le_S. apply Sn_le_Sm__n_le_m. apply H0.\nQed. \n*)\n\nLemma aux1 : forall {X:Type} (x:X) xs l1 l2, (forall a, appears_in a (x :: xs ) -> appears_in a (l1++(x::l2))) -> ~repeats (x::xs) -> forall a, appears_in a xs -> appears_in a (l1++l2).\nProof.\n intros.\n destruct (appears_in_app l1 (x::l2) a (H a (ai_later a x xs H1))).\n  apply app_appears_in. left. apply H2.\n\n  apply app_appears_in. right.\n  inversion H2.\n   destruct H0. rewrite <- H4. apply RP_hd. apply H1.\n\n   apply H4.\nQed.\n\nLemma aux2 : forall {X:Type} xs ys,\n  (forall a:X, appears_in a xs -> appears_in a ys) ->\n  ~ repeats xs -> length xs <= length ys.\nProof.\n intros X xs. induction xs; intros.\n  apply O_le_n.  \n\n  destruct (appears_in_app_split _ _ (H x (ai_here _ _))) as [l1].\n  destruct H1 as [l2].\n  rewrite H1. rewrite app_length. simpl. \n  rewrite <- plus_n_Sm. apply n_le_m__Sn_le_Sm. rewrite <- app_length.\n  apply IHxs. (*\u3053\u3053\u3067(l1++l2)\u306b\u3064\u3044\u3066IH\u3092\u4f7f\u3046*)\n   intros. rewrite H1 in H. apply (aux1 _ _ _ _ H H0). apply H2.\n   \n   intro. destruct H0. apply RP_tl. apply H2.\nQed.\n\nTheorem pigeonhole_principle: forall {X:Type} (l1 l2:list X),\n  excluded_middle ->\n  (forall x, appears_in x l1 -> appears_in x l2) ->\n  length l2 < length l1 ->\n  repeats l1.\nProof.\n intros.\n Check(H (repeats l1)).\n destruct (H (repeats l1)); [assumption |]. (* \u80cc\u7406\u6cd5 *)\n destruct (lt_not_le _ _ H1).\n apply aux2; [apply H0 | apply H2].\nQed.\n```", "tags": ["Coq8.3pl4", "ProofCafe"]}