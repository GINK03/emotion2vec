{"context": " More than 1 year has passed since last update.Effective Akka\u306e\u4e2d\u3067\u3001\u300cask\u3092\u4f7f\u3046\u3088\u308a\u3082\u306a\u308b\u3079\u304ftell\u3092\u4f7f\u3044\u306a\u3055\u3044\u300d\u3068\u8a00\u308f\u308c\u308b\u7406\u7531\u306e\u4e00\u3064\u3068\u3057\u3066\u30b3\u30b9\u30c8\u304c\u6319\u3052\u3089\u308c\u3066\u3044\u305f\u3051\u308c\u3069\u3082\u3001\u5b9f\u969b\u306e\u3068\u3053\u308d\u3069\u308c\u3060\u3051\u30b3\u30b9\u30c8\u304c\u9055\u3046\u306e\u304b\u3068\u3044\u3046\u3068\u3053\u308d\u3092future\u30d9\u30fc\u30b9\u306e\u30b3\u30fc\u30c9(\u2252 ask)\u3068tell\u30d9\u30fc\u30b9\u306e\u30b3\u30fc\u30c9\u3092\u4f5c\u3063\u3066\u78ba\u304b\u3081\u3066\u307f\u305f\u3002\n\nfuture\u30d9\u30fc\u30b9\u306e\u30b5\u30f3\u30d7\u30eb\u30b3\u30fc\u30c9\nimport java.lang.management.ManagementFactory\n\nimport scala.concurrent.{Await, ExecutionContext, Future}\nimport scala.concurrent.duration.Duration\nimport scala.concurrent.forkjoin.ForkJoinPool\nimport scala.util.Random\n\nobject FutureSeqSample extends App {\n  val pid = ManagementFactory.getRuntimeMXBean.getName.split('@').head\n  println(s\"jmap -histo:live ${pid}\")\n  val forkJoinExecutor = new ForkJoinPool(10)\n  implicit val ec = ExecutionContext.fromExecutor(forkJoinExecutor)\n\n  val futures = for (i <- 1 to 100000) yield {\n    Future {\n      Thread.sleep(300000000L)\n      Random.nextInt()\n    }\n  }\n  val f = Future.sequence(futures)\n  f onSuccess {\n    case seq => println(s\"sum is ${seq.reduceLeft(_+_)}\")\n  }\n  Await.result(f, Duration.Inf)\n  Thread.sleep(30000000L)\n}\n\n\ntell\u30d9\u30fc\u30b9\u306e\u30b5\u30f3\u30d7\u30eb\u30b3\u30fc\u30c9\nimport java.lang.management.ManagementFactory\n\nimport scala.concurrent.Await\nimport scala.concurrent.duration.{Duration, DurationInt}\nimport scala.util.{Random, Success}\n\nimport akka.actor.{Actor, ActorRef, ActorSystem, Props, Stash, actorRef2Scala}\nimport akka.pattern.ask\nimport akka.routing.RoundRobinPool\nimport akka.util.Timeout\n\nobject ActorSeqSample extends App {\n  val pid = ManagementFactory.getRuntimeMXBean.getName.split('@').head\n  println(s\"jmap -histo:live ${pid}\")\n\n  implicit val timeout = Timeout(100 seconds)\n  val system = ActorSystem()\n  import system.dispatcher\n\n  val executor = system.actorOf(Props[Executor])\n  val result = executor ? Start(100000)\n  result.mapTo[CalculateResult] onComplete {\n    case Success(sum) => println(s\"sum is ${sum.n}\")\n    case _ => // \u3053\u306e\u30b5\u30f3\u30d7\u30eb\u3067\u306f\u5931\u6557\u3057\u306a\u3044\n  }\n  Await.result(result, Duration.Inf)\n  Thread.sleep(300000L)\n}\n\ncase class Start(n: Int)\ncase class CalculateResult(n: Int)\n\nclass Executor extends Actor with Stash {\n  var sum = 0\n  var resultCount = 0\n  var maxCount = 0\n  val randomIntActors = context.actorOf(new RoundRobinPool(10).props(Props[RandomIntActor]))\n\n  def receive: Actor.Receive = {\n    case Start(n) =>\n      for (i <- 1 to n) {\n        randomIntActors ! \"do it\"  \n      }\n      sum = 0\n      resultCount = 0\n      maxCount = n\n      context become calculate(sender)\n  }\n\n  def calculate(originalSender: ActorRef): Actor.Receive = {\n    case CalculateResult(n) =>\n      println(n)\n      resultCount += 1\n      if (resultCount >= maxCount) {\n        originalSender ! CalculateResult(sum)\n        context.unbecome()\n        unstashAll()\n      }\n    case _ => stash()\n  }\n}\n\nclass RandomIntActor extends Actor {\n  def receive = {\n    case msg =>\n      Thread.sleep(3000000L)\n      sender ! CalculateResult(Random.nextInt())\n  }\n}\n\n\n\u8a08\u6e2c\u7d50\u679c(jmap)\n\nfuture\n\n>jmap -histo:live 10208 | find \"00\"\n   1:        200001        3200016  scala.concurrent.impl.Promise$DefaultPromise\n   2:        100010        2400240  scala.collection.immutable.$colon$colon\n   3:        100003        2400072  scala.concurrent.impl.CallbackRunnable\n   4:        100001        2400024  scala.concurrent.impl.ExecutionContextImpl$AdaptedForkJoinTask\n   5:        100000        2400000  scala.concurrent.Future$$anonfun$flatMap$1\n   6:        100000        2400000  scala.concurrent.Future$$anonfun$sequence$1$$anonfun$apply$10\n   7:        100000        2400000  scala.concurrent.impl.Future$PromiseCompletingRunnable\n   8:        100000        1600000  future.samples.FutureSeqSample$$anonfun$2$$anonfun$apply$1\n\n\ntell\n\n>jmap -histo:live 5540 | find \"00\"\n   1:        100007        2400168  java.util.concurrent.ConcurrentLinkedQueue$Node\n   2:        100000        2400000  akka.dispatch.Envelope\n\n\u30b5\u30f3\u30d7\u30eb\u306f10\u4e07\u56de\u306e\u6f14\u7b97\u547d\u4ee4\u3067\u3059\u304c\u3001future\u30d9\u30fc\u30b9\u3067\u3084\u308d\u3046\u3068\u3057\u305f\u5834\u5408\u3001\u305d\u306e\u6642\u70b9\u3067\u7d50\u679c\u3092\u53d7\u3051\u53d6\u308b\u305f\u3081\u306e\u69d8\u3005\u306a\u30aa\u30d6\u30b8\u30a7\u30af\u30c8\u304c\u4f5c\u3089\u308c\u3066\u3057\u307e\u3046\u3051\u308c\u3069\u3082\u3001tell\u30d9\u30fc\u30b9\u5834\u5408\u306fmailbox\u306b\u30e1\u30c3\u30bb\u30fc\u30b8\u3092\u5165\u308c\u308b\u30b3\u30b9\u30c8\u304f\u3089\u3044\u3057\u304b\u304b\u304b\u3063\u3066\u3044\u306a\u3044\u3001\u3068\u3044\u3046\u3053\u3068\u304c\u8a00\u3048\u305d\u3046\u3067\u3059\u3002\nEffective Akka\u306e\u4e2d\u3067\u3001\u300cask\u3092\u4f7f\u3046\u3088\u308a\u3082\u306a\u308b\u3079\u304ftell\u3092\u4f7f\u3044\u306a\u3055\u3044\u300d\u3068\u8a00\u308f\u308c\u308b\u7406\u7531\u306e\u4e00\u3064\u3068\u3057\u3066\u30b3\u30b9\u30c8\u304c\u6319\u3052\u3089\u308c\u3066\u3044\u305f\u3051\u308c\u3069\u3082\u3001\u5b9f\u969b\u306e\u3068\u3053\u308d\u3069\u308c\u3060\u3051\u30b3\u30b9\u30c8\u304c\u9055\u3046\u306e\u304b\u3068\u3044\u3046\u3068\u3053\u308d\u3092future\u30d9\u30fc\u30b9\u306e\u30b3\u30fc\u30c9(\u2252 ask)\u3068tell\u30d9\u30fc\u30b9\u306e\u30b3\u30fc\u30c9\u3092\u4f5c\u3063\u3066\u78ba\u304b\u3081\u3066\u307f\u305f\u3002\n\n##### future\u30d9\u30fc\u30b9\u306e\u30b5\u30f3\u30d7\u30eb\u30b3\u30fc\u30c9\n```scala\nimport java.lang.management.ManagementFactory\n\nimport scala.concurrent.{Await, ExecutionContext, Future}\nimport scala.concurrent.duration.Duration\nimport scala.concurrent.forkjoin.ForkJoinPool\nimport scala.util.Random\n\nobject FutureSeqSample extends App {\n  val pid = ManagementFactory.getRuntimeMXBean.getName.split('@').head\n  println(s\"jmap -histo:live ${pid}\")\n  val forkJoinExecutor = new ForkJoinPool(10)\n  implicit val ec = ExecutionContext.fromExecutor(forkJoinExecutor)\n\n  val futures = for (i <- 1 to 100000) yield {\n    Future {\n      Thread.sleep(300000000L)\n      Random.nextInt()\n    }\n  }\n  val f = Future.sequence(futures)\n  f onSuccess {\n    case seq => println(s\"sum is ${seq.reduceLeft(_+_)}\")\n  }\n  Await.result(f, Duration.Inf)\n  Thread.sleep(30000000L)\n}\n```\n\n##### tell\u30d9\u30fc\u30b9\u306e\u30b5\u30f3\u30d7\u30eb\u30b3\u30fc\u30c9\n```scala\nimport java.lang.management.ManagementFactory\n\nimport scala.concurrent.Await\nimport scala.concurrent.duration.{Duration, DurationInt}\nimport scala.util.{Random, Success}\n\nimport akka.actor.{Actor, ActorRef, ActorSystem, Props, Stash, actorRef2Scala}\nimport akka.pattern.ask\nimport akka.routing.RoundRobinPool\nimport akka.util.Timeout\n\nobject ActorSeqSample extends App {\n  val pid = ManagementFactory.getRuntimeMXBean.getName.split('@').head\n  println(s\"jmap -histo:live ${pid}\")\n\n  implicit val timeout = Timeout(100 seconds)\n  val system = ActorSystem()\n  import system.dispatcher\n  \n  val executor = system.actorOf(Props[Executor])\n  val result = executor ? Start(100000)\n  result.mapTo[CalculateResult] onComplete {\n    case Success(sum) => println(s\"sum is ${sum.n}\")\n    case _ => // \u3053\u306e\u30b5\u30f3\u30d7\u30eb\u3067\u306f\u5931\u6557\u3057\u306a\u3044\n  }\n  Await.result(result, Duration.Inf)\n  Thread.sleep(300000L)\n}\n\ncase class Start(n: Int)\ncase class CalculateResult(n: Int)\n\nclass Executor extends Actor with Stash {\n  var sum = 0\n  var resultCount = 0\n  var maxCount = 0\n  val randomIntActors = context.actorOf(new RoundRobinPool(10).props(Props[RandomIntActor]))\n  \n  def receive: Actor.Receive = {\n    case Start(n) =>\n      for (i <- 1 to n) {\n        randomIntActors ! \"do it\"  \n      }\n      sum = 0\n      resultCount = 0\n      maxCount = n\n      context become calculate(sender)\n  }\n  \n  def calculate(originalSender: ActorRef): Actor.Receive = {\n    case CalculateResult(n) =>\n      println(n)\n      resultCount += 1\n      if (resultCount >= maxCount) {\n        originalSender ! CalculateResult(sum)\n        context.unbecome()\n        unstashAll()\n      }\n    case _ => stash()\n  }\n}\n\nclass RandomIntActor extends Actor {\n  def receive = {\n    case msg =>\n      Thread.sleep(3000000L)\n      sender ! CalculateResult(Random.nextInt())\n  }\n}\n```\n\n##### \u8a08\u6e2c\u7d50\u679c(jmap)\n- future\n\n```\n>jmap -histo:live 10208 | find \"00\"\n   1:        200001        3200016  scala.concurrent.impl.Promise$DefaultPromise\n   2:        100010        2400240  scala.collection.immutable.$colon$colon\n   3:        100003        2400072  scala.concurrent.impl.CallbackRunnable\n   4:        100001        2400024  scala.concurrent.impl.ExecutionContextImpl$AdaptedForkJoinTask\n   5:        100000        2400000  scala.concurrent.Future$$anonfun$flatMap$1\n   6:        100000        2400000  scala.concurrent.Future$$anonfun$sequence$1$$anonfun$apply$10\n   7:        100000        2400000  scala.concurrent.impl.Future$PromiseCompletingRunnable\n   8:        100000        1600000  future.samples.FutureSeqSample$$anonfun$2$$anonfun$apply$1\n```\n- tell\n\n```\n>jmap -histo:live 5540 | find \"00\"\n   1:        100007        2400168  java.util.concurrent.ConcurrentLinkedQueue$Node\n   2:        100000        2400000  akka.dispatch.Envelope\n```\n\n\u30b5\u30f3\u30d7\u30eb\u306f10\u4e07\u56de\u306e\u6f14\u7b97\u547d\u4ee4\u3067\u3059\u304c\u3001future\u30d9\u30fc\u30b9\u3067\u3084\u308d\u3046\u3068\u3057\u305f\u5834\u5408\u3001\u305d\u306e\u6642\u70b9\u3067\u7d50\u679c\u3092\u53d7\u3051\u53d6\u308b\u305f\u3081\u306e\u69d8\u3005\u306a\u30aa\u30d6\u30b8\u30a7\u30af\u30c8\u304c\u4f5c\u3089\u308c\u3066\u3057\u307e\u3046\u3051\u308c\u3069\u3082\u3001tell\u30d9\u30fc\u30b9\u5834\u5408\u306fmailbox\u306b\u30e1\u30c3\u30bb\u30fc\u30b8\u3092\u5165\u308c\u308b\u30b3\u30b9\u30c8\u304f\u3089\u3044\u3057\u304b\u304b\u304b\u3063\u3066\u3044\u306a\u3044\u3001\u3068\u3044\u3046\u3053\u3068\u304c\u8a00\u3048\u305d\u3046\u3067\u3059\u3002\n", "tags": ["Akka", "Scala"]}