{"context": "\u53c2\u7167: \u30b0\u30ec\u30a4\u30b3\u30fc\u30c9(Wikipedia)\n\u7a7a\u9593\u30b3\u30fc\u30c9\u5316\u6cd5\u306a\u3093\u304b\u3067\u30b0\u30ec\u30a4\u30b3\u30fc\u30c9\u753b\u50cf\u3092\u4f7f\u3044\u305f\u3044\u3053\u3068\u304c\u591a\u3005\u3042\u308b\uff0e\u306e\u3067\uff0cOpenCV/C++\u3067\u306e\u5b9f\u88c5\u4f8b\uff0e\noffset\u3092\u4e0e\u3048\u3066\u4e2d\u592e\u306b\u5bc4\u305b\u3066\u3044\u308b\u306e\u3067\uff0c\u5fc5\u8981\u304c\u306a\u3051\u308c\u3070offset\u3092\u6d88\u3059\uff0e\n#include <vector>\n#include <cmath>\n#include <opencv2/opencv.hpp>\n\nint main()\n{\n    const cv::Size im_size(1280, 800);\n\n    std::vector<cv::Mat> im_vec;\n    std::vector<int> graycode(im_size.width);\n\n    const int bit_num = static_cast<int>(std::ceil(std::log2(im_size.width))) - 1;\n    const int offset = static_cast<int>(std::pow(2, bit_num) - im_size.width) / 2;\n\n    // generate gray code\n    for (int px = 0; px < im_size.width; ++px)\n    {\n        // shift to center\n        const int bit = px + offset;\n\n        // gray code\n        graycode[px] = bit ^ (bit >> 1);\n    }\n\n    // make images\n    for (int i = 0; i < bit_num; ++i)\n    {\n        cv::Mat im = cv::Mat::zeros(im_size, CV_8U);\n\n        for (int py = 0; py < im_size.height; ++py)\n        {\n            uchar* const im_ptr = im.ptr<uchar>(py);\n\n            for (int px = 0; px < im_size.width; ++px)\n            {\n                // extract i-th bit\n                const uchar val = ((graycode[px] >> (bit_num - i - 1)) & 0x01);\n                im_ptr[px] = val * 255;\n            }\n        }\n        im_vec.push_back(im.clone());\n    }\n\n    // show\n    for (const auto& im : im_vec)\n    {\n        cv::imshow(\"im\", im);\n        cv::waitKey(-1);\n    }\n}\n\n\u53c2\u7167: [\u30b0\u30ec\u30a4\u30b3\u30fc\u30c9(Wikipedia)](https://ja.wikipedia.org/wiki/%E3%82%B0%E3%83%AC%E3%82%A4%E3%82%B3%E3%83%BC%E3%83%89)\n\n\u7a7a\u9593\u30b3\u30fc\u30c9\u5316\u6cd5\u306a\u3093\u304b\u3067\u30b0\u30ec\u30a4\u30b3\u30fc\u30c9\u753b\u50cf\u3092\u4f7f\u3044\u305f\u3044\u3053\u3068\u304c\u591a\u3005\u3042\u308b\uff0e\u306e\u3067\uff0cOpenCV/C++\u3067\u306e\u5b9f\u88c5\u4f8b\uff0e\noffset\u3092\u4e0e\u3048\u3066\u4e2d\u592e\u306b\u5bc4\u305b\u3066\u3044\u308b\u306e\u3067\uff0c\u5fc5\u8981\u304c\u306a\u3051\u308c\u3070offset\u3092\u6d88\u3059\uff0e\n\n```cpp:\n#include <vector>\n#include <cmath>\n#include <opencv2/opencv.hpp>\n\nint main()\n{\n\tconst cv::Size im_size(1280, 800);\n\n\tstd::vector<cv::Mat> im_vec;\n\tstd::vector<int> graycode(im_size.width);\n\n\tconst int bit_num = static_cast<int>(std::ceil(std::log2(im_size.width))) - 1;\n\tconst int offset = static_cast<int>(std::pow(2, bit_num) - im_size.width) / 2;\n\n\t// generate gray code\n\tfor (int px = 0; px < im_size.width; ++px)\n\t{\n\t\t// shift to center\n\t\tconst int bit = px + offset;\n\n\t\t// gray code\n\t\tgraycode[px] = bit ^ (bit >> 1);\n\t}\n\n\t// make images\n\tfor (int i = 0; i < bit_num; ++i)\n\t{\n\t\tcv::Mat im = cv::Mat::zeros(im_size, CV_8U);\n\n\t\tfor (int py = 0; py < im_size.height; ++py)\n\t\t{\n\t\t\tuchar* const im_ptr = im.ptr<uchar>(py);\n\n\t\t\tfor (int px = 0; px < im_size.width; ++px)\n\t\t\t{\n\t\t\t\t// extract i-th bit\n\t\t\t\tconst uchar val = ((graycode[px] >> (bit_num - i - 1)) & 0x01);\n\t\t\t\tim_ptr[px] = val * 255;\n\t\t\t}\n\t\t}\n\t\tim_vec.push_back(im.clone());\n\t}\n\n\t// show\n\tfor (const auto& im : im_vec)\n\t{\n\t\tcv::imshow(\"im\", im);\n\t\tcv::waitKey(-1);\n\t}\n}\n```\n", "tags": ["OpenCV", "C++"]}