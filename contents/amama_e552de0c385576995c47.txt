{"context": " More than 1 year has passed since last update.\n\n11\u65e5\u76ee\n\u30cd\u30c3\u30c8\u74b0\u5883\u304c\u306a\u304f\u30662\u65e5\u9593\u304c\u7a7a\u3044\u305f.\u9811\u5f35\u3063\u3066\u7d99\u7d9a\u3057\u3066\u8aad\u3080.\n\n2.3.2\n\u306a\u3093\u304b\u8457\u8005\u306b\u3088\u308b\u3068parse\u306f\u30c1\u30e3\u30d7\u30bf\u30fc1\u3067\u5b9a\u7fa9\u3055\u308c\u305flanguage\u30e2\u30b8\u30e5\u30fc\u30eb\u306b\u5165\u308c\u305f\u3064\u3082\u308a\u3060\u3063\u305f\u3089\u3057\u3044.\n\u30c1\u30e3\u30d7\u30bf\u30fc1\u3067\u4f5c\u3063\u305f\u95a2\u6570\u3092\u5168\u90e8Language.hs\u306b\u7a81\u3063\u8fbc\u3080.\n\u9069\u5f53\u306bmodule Language\u3068\u304b\u3057\u3066\u3042\u3052\u308b.\nutils\u306b\u5fc5\u8981\u306a\u3082\u306e\u304c\u5165\u3063\u3066\u308b\u304b\u3089import\u3057\u3066\u306d,\u3063\u3066\u3081\u3063\u3061\u3083\u305a\u308b\u304f\u306a\u3044\u3067\u3059\u304b.\ndiff\u3068\u3063\u305f\u3084\u30fc\u3064\n\nLanguage.hs\n+module Language where\n +import Utils\n  import Data.Char\n\n  data Expr a\n @@ -25,10 +27,10 @@ recursive = True\n  nonRecursive = False\n\n  bindersOf :: [(a,b)] -> [a]\n -bindersOf defns = [name | (name, rhs) <- defns]\n +bindersOf defns = [name | (name, _) <- defns]\n\n  rhssOf :: [(a,b)] -> [b]\n -rhssOf defns = [rhs | (name, rhs) <- defns]\n +rhssOf defns = [rhs | (_, rhs) <- defns]\n\n  type Alter a = (Int, [a], Expr a)\n  type CoreAlt = Alter Name\n @@ -69,7 +71,7 @@ iNil = INil\n  iAppend seq1 INil = seq1\n  iAppend INil seq2 = seq2\n  iAppend seq1 seq2 = IAppend seq1 seq2\n -iNum n = iStr (show n)\n +iNum n = iStr (shownum n)\n  iIndent seq1 = IIndent seq1\n  iNewline = INewline\n  iStr str = if elem '\\n' str then (IStr (takeWhile (/= '\\n') str)) `iAppend` iNewline `iAppend` (IStr (tail (dropWhile (/= '\\n') str))) else IStr str\n @@ -80,9 +82,9 @@ iConcat (car:cdr) = car `iAppend` (iConcat cdr)\n  iConcat [] = iNil\n  iFWNum :: Int -> Int -> Iseq\n  iFWNum width n\n -    = iStr (replicate (width - length digits) ' ' ++ digits)\n +    = iStr (space (width - length digits) ++ digits)\n      where\n -    digits = show n\n +    digits = shownum n\n  iLayn :: [Iseq] -> Iseq\n  iLayn seqs = iConcat (map lay_item (zip [1..] seqs))\n                  where\n @@ -155,7 +157,7 @@ pprScDefn (name, var, expr)\n  flatten :: Int -> [(Iseq, Int)] -> String\n  flatten _ [] = \"\"\n  flatten _ ((INewline, indent) : seqs)\n -    = '\\n' : (replicate indent ' ') ++ (flatten indent seqs)\n +    = '\\n' : (space indent) ++ (flatten indent seqs)\n  flatten col ((IIndent seq1, indent) : seqs) -- TODO: indent properly\n      = flatten col ((seq1, col) : seqs)\n  flatten col ((IStr seq1, _) : seqs)\n @@ -250,7 +252,6 @@ pExpr =     pApply (pOneOrMore pAexpr) mk_ap\n      `pAlt`  pAexpr\n      where\n      mk_ap e = foldl1 EAp e\n -    mk_binop exp1 op exp2 = EAp (EAp op exp1) exp2\n      mk_let _ defns _ e = ELet nonRecursive  defns  e\n      mk_letrec _ defns _ e = ELet nonRecursive defns e\n      mk_case _ e _ a = ECase e a\n @@ -335,10 +336,3 @@ assembleOp :: CoreExpr -> PartialExpr -> CoreExpr\n  assembleOp e1 NoOp = e1\n  assembleOp e1 (FoundOp op e2) = EAp (EAp (EVar op) e1) e2\n\n -main :: IO ()\n ---main = putStrLn $ iDisplay $ pprExpr (ELet nonRecursive [(\"att\", ENum 2)] (EAp (EAp (EVar \"+\") (EVar \"att\")) (EVar \"1\")))\n -main = putStrLn( pprint $ parse  \"f=3;\\ng x y = let z = x in z ;\\nh x = case (let y = x in y) of\\n<1> -> 2 ;\\n<2> -> 5;\\n i = g (1 + 2 * 3) (5 - 1 / 2)\")\n ---main = putStrLn $ show $ pOneOrMoreWithSep (pLit \"x\") (pLit \";\") [(1,\"x\"),(1,\";\"),(1,\"x\") ,(1,\";\"),(2,\"x\"),(2,\";\"),(2,\"x\"),(2,\";\"),(2,\"x\") ]\n ---main = putStrLn $ show $ pExpr [(2,\"let\"),(2,\"z\"),(2,\"=\"),(2,\"x\"),(2,\"in\"),(2,\"z\")]\n ---main = putStrLn $ pprint $ syntax [(1,\"f\"),(1,\"=\"),(1,\"3\") ,(1,\";\"),(2,\"g\"),(2,\"x\"),(2,\"y\"),(2,\"=\"), (2,\"let\"),(2,\"z\"),(2,\"=\"),(2,\"x\"),(2,\"in\"),(2,\"z\"),(2,\";\"),(3,\"h\"),(3,\"x\"),(3,\"=\"),(3,\"case\"),(3,\"(\"),(3,\"let\"),(3,\"y\"),(3,\"=\"),(3,\"x\"),(3,\"in\"),(3,\"y\"),(3,\")\"),(3,\"of\"),(4,\"<\"),(4,\"1\"),(4,\">\"),(4,\"->\"),(4,\"2\"),(4,\";\"),(5,\"<\"),(5,\"2\"),(5,\">\"),(5,\"->\"),(5,\"5\")]\n\n\nwaring\u6f70\u3057\u305f\u3084\u30fc\u3064\n\nUtils.hs\nmodule Utils where\n-- The following definitions are used to make some synonyms for routines\n-- in the Gofer prelude to be more Miranda compatible\nshownum :: Show a => a -> String\nshownum n = show n\nhd :: [a] -> a\nhd = head -- in Gofer standard prelude\ntl :: [a] -> [a]\ntl = tail -- in Gofer standard prelude\nzip2 :: [a] -> [b] -> [(a,b)]\nzip2 = zip -- in Gofer standard prelude\n-- can\u2019t do anything about # = length, since # not binary.\nhInitial :: Heap a\nhAlloc :: Heap a -> a -> (Heap a, Addr)\nhUpdate :: Heap a -> Addr -> a -> Heap a\nhFree :: Heap a -> Addr -> Heap a\nhLookup :: Heap a -> Addr -> a\nhAddresses :: Heap a -> [Addr]\nhSize :: Heap a -> Int\nhNull :: Addr\nhIsnull :: Addr -> Bool\nshowaddr :: Addr -> [Char]\ntype Heap a = (Int, [Int], [(Int, a)])\ntype Addr = Int\nhInitial = (0, [1..], [])\nhAlloc (size, (next:free), cts) n = ((size+1, free, (next,n) : cts),next)\nhAlloc (_, [], _ ) _ = error \"mel\"\nhUpdate (size, free, cts) a n = (size, free, (a,n) : remove cts a)\nhFree (size, free, cts) a = (size-1, a:free, remove cts a)\nhLookup (_, _, cts) a = aLookup cts a (error (\"can\u2019t find node \" ++ showaddr a ++ \" in heap\"))\n\nhAddresses (_, _, cts) = [addr | (addr, _) <- cts]\n\nhSize (size, _, _) = size\nhNull = 0\nhIsnull a = a == 0\nshowaddr a = \"#\" ++ shownum a -- Print # to identify addresses\nremove :: [(Int,a)] -> Int -> [(Int,a)]\nremove [] a = error (\"Attempt to update or free nonexistent address #\" ++ shownum a)\nremove ((a', n):cts) a = if a == a' then cts else (a',n) : remove cts a\n\ntype ASSOC a b = [(a,b)]\naLookup :: Eq a => [(a, t)] -> a -> t -> t\naLookup [] _ def = def\naLookup ((k,v):bs) k' def = if k == k' then v else aLookup bs k' def\naDomain :: ASSOC a b -> [a]\naDomain alist = [key | (key, _) <- alist]\n\naRange :: ASSOC a b -> [b]\naRange alist = [val | (_, val) <- alist]\naEmpty :: [a]\naEmpty = []\ngetName :: NameSupply -> [Char] -> (NameSupply, [Char])\ngetNames :: NameSupply -> [[Char]] -> (NameSupply, [[Char]])\ninitialNameSupply :: NameSupply\ntype NameSupply = Int\ninitialNameSupply = 0\ngetName name_supply prefix = (name_supply+1, makeName prefix name_supply)\ngetNames name_supply prefixes = (name_supply + length prefixes, zipWith makeName prefixes [name_supply..])\nmakeName :: Show a => [Char] -> a -> [Char]\nmakeName prefix ns = prefix ++ \"_\" ++ shownum ns\nsetFromList :: (Ord a) => [a] -> Set a\nsetToList :: (Ord a) => Set a -> [a]\nsetUnion :: (Ord a) => Set a -> Set a -> Set a\nsetIntersection :: (Ord a) => Set a -> Set a -> Set a\nsetSubtraction :: (Ord a) => Set a -> Set a -> Set a\nsetElementOf :: (Ord a) => a -> Set a -> Bool\nsetEmpty :: (Ord a) => Set a\nsetIsEmpty :: (Ord a) => Set a -> Bool\nsetSingleton :: (Ord a) => a -> Set a\nsetUnionList :: (Ord a) => [Set a] -> Set a\ntype Set a = [a] -- Ordered by the sort function\nsetEmpty = []\nsetIsEmpty s = null s\nsetSingleton x = [x]\nsetFromList = rmdup . sort\n    where\n    rmdup [] = []\n    rmdup [x] = [x]\n    rmdup (x:y:xs) = if x == y then rmdup (y:xs) else x: rmdup (y:xs)\nsetToList xs = xs\nsetUnion [] [] = []\nsetUnion [] (b:bs) = (b:bs)\nsetUnion (a:as) [] = (a:as)\nsetUnion (a:as) (b:bs)\n    | a < b = a: setUnion as (b:bs)\n    | a == b = a: setUnion as bs\n    | a > b = b: setUnion (a:as) bs\n    | otherwise = error \"bourne\"\nsetIntersection [] [] = []\nsetIntersection [] (_:_) = []\nsetIntersection (_:_) [] = []\nsetIntersection (a:as) (b:bs)\n    | a < b = setIntersection as (b:bs)\n    | a == b = a: setIntersection as bs\n    | a > b = setIntersection (a:as) bs\n    | otherwise = error \"tas\"\nsetSubtraction [] [] = []\nsetSubtraction [] (_:_) = []\nsetSubtraction (a:as) [] = (a:as)\nsetSubtraction (a:as) (b:bs) | a < b = a: setSubtraction as (b:bs)\n    | a == b = setSubtraction as bs\n    | a > b = setSubtraction (a:as) bs\n    | otherwise = error \"menia\"\nsetElementOf _ [] = False\nsetElementOf x (y:ys) = x==y || (x>y && setElementOf x ys)\nsetUnionList = foldll setUnion setEmpty\nfirst :: (t, t1) -> t\nfirst (a, _) = a\nsecond :: (t, t1) -> t1\nsecond (_, b) = b\n-- zipWith is defined in standard prelude\nfoldll :: (a -> b -> a) -> a -> [b] -> a\nfoldll = foldl -- in Gofer standard prelude.\nmapAccuml :: (a -> b -> (a, c)) -- Function of accumulator and element\n-- input list, returning new\n-- accumulator and element of result list\n    -> a -- Initial accumulator\n    -> [b] -- Input list\n    -> (a, [c]) -- Final accumulator and result list\n\nmapAccuml _ acc [] = (acc, [])\nmapAccuml f acc (x:xs) = (acc2, x':xs')\n    where\n    (acc1, x') = f acc x\n    (acc2, xs') = mapAccuml f acc1 xs\nsort :: Ord a => [a] -> [a]\nsort [] = []\nsort [x] = [x]\nsort (x:xs) = [ y | y <- xs, y < x] ++ x : [ y | y <- xs, y >= x ]\nspace :: Int -> [Char]\nspace n = take n (repeat ' ')\n\n\n\u3084\u308b\u6c17\u304c\u3067\u306a\u3044\u306e\u3067\u7d42\u308f\u308a.\u3061\u3087\u3063\u3068\u307e\u305a\u3044\u306e\u3067\u306a\u3093\u3068\u304b\u3059\u308b.\n\u3042\u3057\u305f\u7a7a\u767d\u6587\u5b57\u3092\u3044\u3044\u611f\u3058\u306b\u3059\u308b\n2.3.3\u307e\u3067\u306e\u30bd\u30fc\u30b9\u30b3\u30fc\u30c9\u3092\u6574\u7406\u3057\u305f.\n# 11\u65e5\u76ee\n\n\u30cd\u30c3\u30c8\u74b0\u5883\u304c\u306a\u304f\u30662\u65e5\u9593\u304c\u7a7a\u3044\u305f.\u9811\u5f35\u3063\u3066\u7d99\u7d9a\u3057\u3066\u8aad\u3080.\n\n## 2.3.2\n\u306a\u3093\u304b\u8457\u8005\u306b\u3088\u308b\u3068parse\u306f\u30c1\u30e3\u30d7\u30bf\u30fc1\u3067\u5b9a\u7fa9\u3055\u308c\u305flanguage\u30e2\u30b8\u30e5\u30fc\u30eb\u306b\u5165\u308c\u305f\u3064\u3082\u308a\u3060\u3063\u305f\u3089\u3057\u3044.\n\u30c1\u30e3\u30d7\u30bf\u30fc1\u3067\u4f5c\u3063\u305f\u95a2\u6570\u3092\u5168\u90e8Language.hs\u306b\u7a81\u3063\u8fbc\u3080.\n\u9069\u5f53\u306bmodule Language\u3068\u304b\u3057\u3066\u3042\u3052\u308b.\nutils\u306b\u5fc5\u8981\u306a\u3082\u306e\u304c\u5165\u3063\u3066\u308b\u304b\u3089import\u3057\u3066\u306d,\u3063\u3066\u3081\u3063\u3061\u3083\u305a\u308b\u304f\u306a\u3044\u3067\u3059\u304b.\ndiff\u3068\u3063\u305f\u3084\u30fc\u3064\n\n```hs:Language.hs\n+module Language where\n +import Utils\n  import Data.Char\n  \n  data Expr a\n @@ -25,10 +27,10 @@ recursive = True\n  nonRecursive = False\n  \n  bindersOf :: [(a,b)] -> [a]\n -bindersOf defns = [name | (name, rhs) <- defns]\n +bindersOf defns = [name | (name, _) <- defns]\n  \n  rhssOf :: [(a,b)] -> [b]\n -rhssOf defns = [rhs | (name, rhs) <- defns]\n +rhssOf defns = [rhs | (_, rhs) <- defns]\n  \n  type Alter a = (Int, [a], Expr a)\n  type CoreAlt = Alter Name\n @@ -69,7 +71,7 @@ iNil = INil\n  iAppend seq1 INil = seq1\n  iAppend INil seq2 = seq2\n  iAppend seq1 seq2 = IAppend seq1 seq2\n -iNum n = iStr (show n)\n +iNum n = iStr (shownum n)\n  iIndent seq1 = IIndent seq1\n  iNewline = INewline\n  iStr str = if elem '\\n' str then (IStr (takeWhile (/= '\\n') str)) `iAppend` iNewline `iAppend` (IStr (tail (dropWhile (/= '\\n') str))) else IStr str\n @@ -80,9 +82,9 @@ iConcat (car:cdr) = car `iAppend` (iConcat cdr)\n  iConcat [] = iNil\n  iFWNum :: Int -> Int -> Iseq\n  iFWNum width n\n -    = iStr (replicate (width - length digits) ' ' ++ digits)\n +    = iStr (space (width - length digits) ++ digits)\n      where\n -    digits = show n\n +    digits = shownum n\n  iLayn :: [Iseq] -> Iseq\n  iLayn seqs = iConcat (map lay_item (zip [1..] seqs))\n                  where\n @@ -155,7 +157,7 @@ pprScDefn (name, var, expr)\n  flatten :: Int -> [(Iseq, Int)] -> String\n  flatten _ [] = \"\"\n  flatten _ ((INewline, indent) : seqs)\n -    = '\\n' : (replicate indent ' ') ++ (flatten indent seqs)\n +    = '\\n' : (space indent) ++ (flatten indent seqs)\n  flatten col ((IIndent seq1, indent) : seqs) -- TODO: indent properly\n      = flatten col ((seq1, col) : seqs)\n  flatten col ((IStr seq1, _) : seqs)\n @@ -250,7 +252,6 @@ pExpr =     pApply (pOneOrMore pAexpr) mk_ap\n      `pAlt`  pAexpr\n      where\n      mk_ap e = foldl1 EAp e\n -    mk_binop exp1 op exp2 = EAp (EAp op exp1) exp2\n      mk_let _ defns _ e = ELet nonRecursive  defns  e\n      mk_letrec _ defns _ e = ELet nonRecursive defns e\n      mk_case _ e _ a = ECase e a\n @@ -335,10 +336,3 @@ assembleOp :: CoreExpr -> PartialExpr -> CoreExpr\n  assembleOp e1 NoOp = e1\n  assembleOp e1 (FoundOp op e2) = EAp (EAp (EVar op) e1) e2\n  \n -main :: IO ()\n ---main = putStrLn $ iDisplay $ pprExpr (ELet nonRecursive [(\"att\", ENum 2)] (EAp (EAp (EVar \"+\") (EVar \"att\")) (EVar \"1\")))\n -main = putStrLn( pprint $ parse  \"f=3;\\ng x y = let z = x in z ;\\nh x = case (let y = x in y) of\\n<1> -> 2 ;\\n<2> -> 5;\\n i = g (1 + 2 * 3) (5 - 1 / 2)\")\n ---main = putStrLn $ show $ pOneOrMoreWithSep (pLit \"x\") (pLit \";\") [(1,\"x\"),(1,\";\"),(1,\"x\") ,(1,\";\"),(2,\"x\"),(2,\";\"),(2,\"x\"),(2,\";\"),(2,\"x\") ]\n ---main = putStrLn $ show $ pExpr [(2,\"let\"),(2,\"z\"),(2,\"=\"),(2,\"x\"),(2,\"in\"),(2,\"z\")]\n ---main = putStrLn $ pprint $ syntax [(1,\"f\"),(1,\"=\"),(1,\"3\") ,(1,\";\"),(2,\"g\"),(2,\"x\"),(2,\"y\"),(2,\"=\"), (2,\"let\"),(2,\"z\"),(2,\"=\"),(2,\"x\"),(2,\"in\"),(2,\"z\"),(2,\";\"),(3,\"h\"),(3,\"x\"),(3,\"=\"),(3,\"case\"),(3,\"(\"),(3,\"let\"),(3,\"y\"),(3,\"=\"),(3,\"x\"),(3,\"in\"),(3,\"y\"),(3,\")\"),(3,\"of\"),(4,\"<\"),(4,\"1\"),(4,\">\"),(4,\"->\"),(4,\"2\"),(4,\";\"),(5,\"<\"),(5,\"2\"),(5,\">\"),(5,\"->\"),(5,\"5\")]\n```\n\nwaring\u6f70\u3057\u305f\u3084\u30fc\u3064\n\n```hs:Utils.hs\nmodule Utils where\n-- The following definitions are used to make some synonyms for routines\n-- in the Gofer prelude to be more Miranda compatible\nshownum :: Show a => a -> String\nshownum n = show n\nhd :: [a] -> a\nhd = head -- in Gofer standard prelude\ntl :: [a] -> [a]\ntl = tail -- in Gofer standard prelude\nzip2 :: [a] -> [b] -> [(a,b)]\nzip2 = zip -- in Gofer standard prelude\n-- can\u2019t do anything about # = length, since # not binary.\nhInitial :: Heap a\nhAlloc :: Heap a -> a -> (Heap a, Addr)\nhUpdate :: Heap a -> Addr -> a -> Heap a\nhFree :: Heap a -> Addr -> Heap a\nhLookup :: Heap a -> Addr -> a\nhAddresses :: Heap a -> [Addr]\nhSize :: Heap a -> Int\nhNull :: Addr\nhIsnull :: Addr -> Bool\nshowaddr :: Addr -> [Char]\ntype Heap a = (Int, [Int], [(Int, a)])\ntype Addr = Int\nhInitial = (0, [1..], [])\nhAlloc (size, (next:free), cts) n = ((size+1, free, (next,n) : cts),next)\nhAlloc (_, [], _ ) _ = error \"mel\"\nhUpdate (size, free, cts) a n = (size, free, (a,n) : remove cts a)\nhFree (size, free, cts) a = (size-1, a:free, remove cts a)\nhLookup (_, _, cts) a = aLookup cts a (error (\"can\u2019t find node \" ++ showaddr a ++ \" in heap\"))\n\nhAddresses (_, _, cts) = [addr | (addr, _) <- cts]\n\nhSize (size, _, _) = size\nhNull = 0\nhIsnull a = a == 0\nshowaddr a = \"#\" ++ shownum a -- Print # to identify addresses\nremove :: [(Int,a)] -> Int -> [(Int,a)]\nremove [] a = error (\"Attempt to update or free nonexistent address #\" ++ shownum a)\nremove ((a', n):cts) a = if a == a' then cts else (a',n) : remove cts a\n\ntype ASSOC a b = [(a,b)]\naLookup :: Eq a => [(a, t)] -> a -> t -> t\naLookup [] _ def = def\naLookup ((k,v):bs) k' def = if k == k' then v else aLookup bs k' def\naDomain :: ASSOC a b -> [a]\naDomain alist = [key | (key, _) <- alist]\n\naRange :: ASSOC a b -> [b]\naRange alist = [val | (_, val) <- alist]\naEmpty :: [a]\naEmpty = []\ngetName :: NameSupply -> [Char] -> (NameSupply, [Char])\ngetNames :: NameSupply -> [[Char]] -> (NameSupply, [[Char]])\ninitialNameSupply :: NameSupply\ntype NameSupply = Int\ninitialNameSupply = 0\ngetName name_supply prefix = (name_supply+1, makeName prefix name_supply)\ngetNames name_supply prefixes = (name_supply + length prefixes, zipWith makeName prefixes [name_supply..])\nmakeName :: Show a => [Char] -> a -> [Char]\nmakeName prefix ns = prefix ++ \"_\" ++ shownum ns\nsetFromList :: (Ord a) => [a] -> Set a\nsetToList :: (Ord a) => Set a -> [a]\nsetUnion :: (Ord a) => Set a -> Set a -> Set a\nsetIntersection :: (Ord a) => Set a -> Set a -> Set a\nsetSubtraction :: (Ord a) => Set a -> Set a -> Set a\nsetElementOf :: (Ord a) => a -> Set a -> Bool\nsetEmpty :: (Ord a) => Set a\nsetIsEmpty :: (Ord a) => Set a -> Bool\nsetSingleton :: (Ord a) => a -> Set a\nsetUnionList :: (Ord a) => [Set a] -> Set a\ntype Set a = [a] -- Ordered by the sort function\nsetEmpty = []\nsetIsEmpty s = null s\nsetSingleton x = [x]\nsetFromList = rmdup . sort\n    where\n    rmdup [] = []\n    rmdup [x] = [x]\n    rmdup (x:y:xs) = if x == y then rmdup (y:xs) else x: rmdup (y:xs)\nsetToList xs = xs\nsetUnion [] [] = []\nsetUnion [] (b:bs) = (b:bs)\nsetUnion (a:as) [] = (a:as)\nsetUnion (a:as) (b:bs)\n    | a < b = a: setUnion as (b:bs)\n    | a == b = a: setUnion as bs\n    | a > b = b: setUnion (a:as) bs\n    | otherwise = error \"bourne\"\nsetIntersection [] [] = []\nsetIntersection [] (_:_) = []\nsetIntersection (_:_) [] = []\nsetIntersection (a:as) (b:bs)\n    | a < b = setIntersection as (b:bs)\n    | a == b = a: setIntersection as bs\n    | a > b = setIntersection (a:as) bs\n    | otherwise = error \"tas\"\nsetSubtraction [] [] = []\nsetSubtraction [] (_:_) = []\nsetSubtraction (a:as) [] = (a:as)\nsetSubtraction (a:as) (b:bs) | a < b = a: setSubtraction as (b:bs)\n    | a == b = setSubtraction as bs\n    | a > b = setSubtraction (a:as) bs\n    | otherwise = error \"menia\"\nsetElementOf _ [] = False\nsetElementOf x (y:ys) = x==y || (x>y && setElementOf x ys)\nsetUnionList = foldll setUnion setEmpty\nfirst :: (t, t1) -> t\nfirst (a, _) = a\nsecond :: (t, t1) -> t1\nsecond (_, b) = b\n-- zipWith is defined in standard prelude\nfoldll :: (a -> b -> a) -> a -> [b] -> a\nfoldll = foldl -- in Gofer standard prelude.\nmapAccuml :: (a -> b -> (a, c)) -- Function of accumulator and element\n-- input list, returning new\n-- accumulator and element of result list\n    -> a -- Initial accumulator\n    -> [b] -- Input list\n    -> (a, [c]) -- Final accumulator and result list\n\nmapAccuml _ acc [] = (acc, [])\nmapAccuml f acc (x:xs) = (acc2, x':xs')\n    where\n    (acc1, x') = f acc x\n    (acc2, xs') = mapAccuml f acc1 xs\nsort :: Ord a => [a] -> [a]\nsort [] = []\nsort [x] = [x]\nsort (x:xs) = [ y | y <- xs, y < x] ++ x : [ y | y <- xs, y >= x ]\nspace :: Int -> [Char]\nspace n = take n (repeat ' ')\n```\n\n\u3084\u308b\u6c17\u304c\u3067\u306a\u3044\u306e\u3067\u7d42\u308f\u308a.\u3061\u3087\u3063\u3068\u307e\u305a\u3044\u306e\u3067\u306a\u3093\u3068\u304b\u3059\u308b.\n\u3042\u3057\u305f\u7a7a\u767d\u6587\u5b57\u3092\u3044\u3044\u611f\u3058\u306b\u3059\u308b\n\n**2.3.3\u307e\u3067\u306e\u30bd\u30fc\u30b9\u30b3\u30fc\u30c9\u3092\u6574\u7406\u3057\u305f.**\n", "tags": ["\u30a4\u30f3\u30d7\u30ea\u30e1\u30f3\u30c6\u30a3\u30f3\u30b0\u30d5\u30a1\u30f3\u30af\u30b7\u30e7\u30ca\u30eb\u30e9\u30f3\u30b2\u30fc\u30b8\u30ba"]}