{"context": " More than 1 year has passed since last update.\n\n7\u65e5\u76ee\n\n38\u30da\u30fc\u30b8\n\u66f8\u304d\u7d42\u3048\u305f\u306e\u3067\u30b3\u30f3\u30d1\u30a4\u30eb\u3059\u308b.\n\u3044\u308d\u3044\u308dwarning\u304c\u51fa\u308b\u306e\u3067\u3067\u304d\u308b\u3060\u3051\u6f70\u3059.\nsyntax\u304c\u58ca\u308c\u3066\u308b\u306e\u3067\u76f4\u3059.pExpr\u304c\u307e\u305a\u3044\u3063\u307d\u3044.\n\u30d0\u30b0\u3063\u3066\u305f\u306epAp\u3068pBinop\u306e\u305b\u3044\u3060\u3063\u305f\u3057,\u3084\u3063\u3071\u308a\u8457\u8005\u3082\u308f\u304b\u3063\u3066\u5b9f\u88c5\u3057\u308d\u3063\u3066\u8a00\u3063\u3066\u305f\u3093\u3060\u306a.\u6ce8\u610f\u66f8\u304d\u306b\u3053\u306e2\u3064\u3092\u5b9f\u88c5\u3059\u308b\u306a\u3063\u3066\u66f8\u3044\u3066\u3042\u3063\u305f.\n\u305d\u3057\u3066\u8f1d\u304f\"Syntax Error\"! \u30d8\u30a3!\n\u306a\u3093\u3068\u304b\nf = 3;\ng x y = let\nz = x\nin z;\nh x = case let\ny = x\nin y\n<1> -> 2;\n<2> -> 5\n\n\u3092\u6b63\u3057\u304f\u30d1\u30fc\u30b9\u3067\u304d\u308b\u3088\u3046\u306b\u306a\u3063\u305f.\u3084\u3063\u305f\u30fc.\n\u66f8\u3044\u305f\u30bd\u30fc\u30b9\u304c300\u884c\u8d85\u3048\u3066\u304d\u305f\u306e\u3067\u3053\u308c\u304b\u3089diff\u3092\u53d6\u308b.\n\u4eca\u65e5\u306f\u4e00\u5fdc\u5b8c\u5168\u7248\u3092\u8cbc\u308b.\nExercise 1.21\u304c\u7d42\u308f\u3063\u305f.\u6b21\u306f1.22\u3092\u3084\u308b.\nimport Data.Char\n\ndata Expr a\n    = EVar Name -- Variables\n    | ENum Int -- Numbers\n    | EConstr Int Int -- Constructor tag arity\n    | EAp (Expr a) (Expr a) -- Applications\n    | ELet -- Let(rec) expressions\n        IsRec -- boolean with True = recursive,\n        [(a, Expr a)] -- Definitions\n        (Expr a) -- Body of let(rec)\n    | ECase -- Case expression\n        (Expr a) -- Expression to scrutinise\n        [Alter a] -- Alternatives\n    | ELam [a] (Expr a) -- Lambda abstractions\n    deriving(Show)\n\ntype CoreExpr = Expr Name\n\ntype Name = String\n\ntype IsRec = Bool\nrecursive, nonRecursive :: IsRec\nrecursive = True\nnonRecursive = False\n\nbindersOf :: [(a,b)] -> [a]\nbindersOf defns = [name | (name, rhs) <- defns]\n\nrhssOf :: [(a,b)] -> [b]\nrhssOf defns = [rhs | (name, rhs) <- defns]\n\ntype Alter a = (Int, [a], Expr a)\ntype CoreAlt = Alter Name\n\nisAtomicExpr :: Expr a -> Bool\nisAtomicExpr (EVar _) = True\nisAtomicExpr (ENum _) = True\nisAtomicExpr _ = False\n\ntype Program a = [ScDefn a]\ntype CoreProgram = Program Name\n\ntype ScDefn a = (Name, [a], Expr a)\ntype CoreScDefn = ScDefn Name\n\npreludeDefs :: CoreProgram\npreludeDefs\n    = [ (\"I\", [\"x\"], EVar \"x\"),\n        (\"K\", [\"x\",\"y\"], EVar \"x\"),\n        (\"F\",[\"x\",\"y\"], EVar \"y\"),\n        (\"S\", [\"x\",\"y\",\"z\"], EAp (EAp (EVar \"x\") (EVar \"z\")) (EAp (EVar \"y\") (EVar \"z\"))),\n        (\"C\", [\"x\",\"y\",\"z\"], EAp (EVar \"x\") (EAp (EVar \"y\") (EVar \"z\"))),\n        (\"B\", [\"x\",\"y\",\"z\"], EAp (EAp (EVar \"x\") (EVar \"z\")) (EVar \"y\")), \n        (\"W\", [\"x\", \"y\"], EAp (EAp (EVar \"x\") (EVar \"y\")) (EVar \"y\")) ]\n\ndata Iseq = INil\n            | IStr String\n            | IAppend Iseq Iseq\n            | IIndent Iseq\n            | INewline        \niNil :: Iseq -- The empty iseq\niStr :: String -> Iseq -- Turn a string into an iseq\niNum :: Int -> Iseq\niAppend :: Iseq -> Iseq -> Iseq -- Append two iseqs\niNewline :: Iseq -- New line with indentation\niIndent :: Iseq -> Iseq -- Indent an iseq\niNil = INil\niAppend seq1 INil = seq1\niAppend INil seq2 = seq2\niAppend seq1 seq2 = IAppend seq1 seq2\niNum n = iStr (show n)\niIndent seq1 = IIndent seq1\niNewline = INewline\niStr str = if elem '\\n' str then (IStr (takeWhile (/= '\\n') str)) `iAppend` iNewline `iAppend` (IStr (tail (dropWhile (/= '\\n') str))) else IStr str \niDisplay seq1 = flatten 0 [(seq1, 0)]\niDisplay :: Iseq -> String -- Turn an iseq into a string\niConcat :: [Iseq] -> Iseq\niConcat (car:cdr) = car `iAppend` (iConcat cdr)\niConcat [] = iNil\niFWNum :: Int -> Int -> Iseq\niFWNum width n\n    = iStr (replicate (width - length digits) ' ' ++ digits)\n    where\n    digits = show n\niLayn :: [Iseq] -> Iseq\niLayn seqs = iConcat (map lay_item (zip [1..] seqs))\n                where\n                lay_item (n, seq1)\n                    = iConcat [ iFWNum 4 n, iStr \") \", iIndent seq1, iNewline ]\niInterleave :: Iseq -> [Iseq] -> Iseq\niInterleave  _ [s] = s\niInterleave sep (car:cdr) = car `iAppend` sep `iAppend` (iInterleave sep cdr)\niInterleave INil s = iConcat s\niInterleave _ [] = iNil\n\nbinop :: [String]\nbinop = [\"+\", \"-\", \"*\", \"/\", \"<\", \"<=\", \"==\", \"\u02dc=\", \">=\", \">\", \"&\", \"|\"]\n\npprExpr :: CoreExpr -> Iseq\npprExpr (EVar v) = iStr v\npprExpr (ENum n) = iNum n\npprExpr (EConstr tag arity) = iConcat [ (iStr \"Pack{\"), (iNum tag), (iStr \", \"), (iNum arity), (iStr \"}\") ]\npprExpr (EAp (EAp (EVar biop) e1) e2)  --TODO: 1.5.5 \u30ab\u30c3\u30b3\u3092\u3044\u3044\u611f\u3058\u306b\u3059\u308b\n    | elem biop binop\n    = iConcat [ pprAExpr e1, iStr (\" \" ++ biop ++ \" \"), pprAExpr e2 ]\npprExpr (EAp e1 e2) = (pprExpr e1) `iAppend` (iStr \" \") `iAppend` (pprAExpr e2)\npprExpr (ELet isrec defns expr)\n    = iConcat [ iStr keyword, iNewline,\n                iIndent (pprDefns defns), iNewline,\n                iStr \"in \", pprExpr expr ]\n        where\n        keyword = if isrec then \"letrec\" else \"let\"\npprExpr (ECase expr alters)\n    = iConcat [ iStr \"case\", iStr \" \", pprExpr expr, iNewline,\n                iIndent (pprAlters alters), iNewline ]\npprExpr (ELam var expr)\n    = iConcat [iConcat (map iStr var), iStr \". \", pprExpr expr]\n\npprDefns :: [(Name, CoreExpr)] -> Iseq\npprDefns defns = iInterleave sep (map pprDefn defns)\n                    where\n                    sep = iConcat [ iStr \";\", iNewline ]\n\npprDefn :: (Name, CoreExpr) -> Iseq\npprDefn (name, expr) = iConcat [ iStr name, iStr \" = \", iIndent (pprExpr expr) ]\n\npprint :: CoreProgram -> String\npprint prog = iDisplay (pprProgram prog)\n\npprAlters :: [(Int, [Name], Expr Name)] -> Iseq\npprAlters alters\n    = iInterleave sep (map pprAlter alters)\n    where\n    sep = iConcat [ iStr \";\", iNewline ]\n\npprAlter :: (Int, [Name], Expr Name) -> Iseq\npprAlter (tag, var, expr)\n    = iConcat [iStr \"<\", iNum tag, iStr \">\", iStr (unwords var), iStr \" -> \", iIndent (pprExpr expr) ]\n\npprAExpr :: CoreExpr -> Iseq\npprAExpr e | isAtomicExpr e = pprExpr e\npprAExpr e | otherwise =  (iStr \"(\") `iAppend` pprExpr e `iAppend` (iStr \")\")\n\npprProgram :: CoreProgram -> Iseq\npprProgram scdefns\n    = iInterleave sep (map pprScDefn scdefns)\n    where\n    sep = iConcat [ iStr \";\", iNewline ]\n\npprScDefn :: CoreScDefn -> Iseq\npprScDefn (name, var, expr)\n    = iConcat [iStr name, if (var == []) then iNil else iStr \" \", iStr (unwords var), iStr \" = \", pprExpr expr]\n\nflatten :: Int -> [(Iseq, Int)] -> String\nflatten _ [] = \"\"\nflatten _ ((INewline, indent) : seqs)\n    = '\\n' : (replicate indent ' ') ++ (flatten indent seqs)\nflatten col ((IIndent seq1, indent) : seqs) -- TODO: indent properly\n    = flatten col ((seq1, col) : seqs)\nflatten col ((IStr seq1, _) : seqs)\n    = seq1 ++ (flatten col seqs)\nflatten col ((INil, _) : seqs)\n    = flatten col seqs\nflatten col ((IAppend seq1 seq2, indent) : seqs)\n    = flatten col ((seq1, indent) : (seq2, indent) : seqs)\n\ntype Token = (Int, String)\ntwoCharOps :: [String]\ntwoCharOps = [\"==\", \"\u02dc=\", \">=\", \"<=\", \"->\"]\nclex :: Int -> String -> [Token]\nclex _ [] = []\nclex n (c1:c2:cs) | c1 == '|' && c2 == '|' = clex n (dropWhile (/= '\\n') cs)\nclex n (c1:c2:cs) | elem (c1:c2:[]) twoCharOps =(n, (c1:c2:[])) : clex n cs\nclex n (c:cs) |  c == '\\n' = clex (n + 1) cs\nclex n (c:cs) | isSpace c = clex n cs\nclex n (c:cs) | isDigit c = (n, num_token) : clex n rest_cs\n            where\n            num_token = c : takeWhile isDigit cs\n            rest_cs = dropWhile isDigit cs\nclex n (c:cs) | isAlpha c = (n, var_tok) : clex n rest_cs\n            where\n            isIdChar d = isAlpha d || isDigit d || (d == '_')\n            var_tok = c : takeWhile isIdChar cs\n            rest_cs = dropWhile isIdChar cs\nclex n (c:cs) = (n, [c]) : clex n cs\n\ntype Parser a = [Token] -> [(a, [Token])]\npLit :: String -> Parser String\npLit s = pSat (== s)\n\nkeywords :: [String]\nkeywords = [\"let\", \"letrec\", \"case\", \"in\", \"of\", \"Pack\"]\npVar :: Parser String\npVar = pSat (\\s@(x:_) -> isAlpha x && notElem s keywords)\n\npNum :: Parser Int\npNum = pApply (pSat (\\(x:_) -> isDigit x)) (\\x -> read x :: Int)\n\npAlt :: Parser a -> Parser a -> Parser a\npAlt p1 p2 toks = (p1 toks) ++ (p2 toks)\n\npThen :: (a -> b -> c) -> Parser a -> Parser b -> Parser c\npThen combine p1 p2 toks\n    = [ (combine v1 v2, toks2) | (v1,toks1) <- p1 toks, (v2,toks2) <- p2 toks1]\n\npThen3 :: (a -> b -> c -> d) -> Parser a -> Parser b -> Parser c -> Parser d\npThen3 combine p1 p2 p3 tokens\n    = [(combine v1 v2 v3, tokens3) | (v1, tokens1) <- p1 tokens, (v2, tokens2) <- p2 tokens1, (v3, tokens3) <- p3 tokens2]\n\n\npThen4 :: (a -> b -> c -> d -> e) -> Parser a -> Parser b -> Parser c -> Parser d -> Parser e\npThen4 combine p1 p2 p3 p4 tokens\n    = [(combine v1 v2 v3 v4, tokens4) | (v1, tokens1) <- p1 tokens, (v2, tokens2) <- p2 tokens1, (v3, tokens3) <- p3 tokens2, (v4, tokens4) <- p4 tokens3]\n\npZeroOrMore :: Parser a -> Parser [a]\npZeroOrMore p = (pOneOrMore p) `pAlt` (pEmpty [])\n\npEmpty :: a -> Parser a\npEmpty s toks = [(s, toks)]\n\npOneOrMore :: Parser a -> Parser [a]\npOneOrMore p = (take 1) . (pThen (:) p (pZeroOrMore p))\n\npApply :: Parser a -> (a -> b) -> Parser b\npApply a f toks = [(f b, tokens) | (b, tokens) <- a toks]\n\npOneOrMoreWithSep :: Parser a -> Parser b -> Parser [a]\npOneOrMoreWithSep a b = (take 1) . (pThen (:) a ((pThen (\\_ x -> x) b (pOneOrMoreWithSep a b)) `pAlt` (pEmpty [])))\n\npSat :: (String -> Bool) -> Parser String\npSat pd = pSatpred\n    where   pSatpred ((_, tok):toks) = if pd tok then [(tok, toks)] else []\n            pSatpred [] = []\n\npProgram :: Parser CoreProgram\npProgram = pOneOrMoreWithSep pSc (pLit \";\")\n\npSc :: Parser CoreScDefn\npSc = pThen4 mk_sc pVar (pZeroOrMore pVar) (pLit \"=\") pExpr\n    where mk_sc name arg _ expr = (name, arg, expr)\n\npExpr :: Parser CoreExpr\npExpr =     --pThen mk_ap pExpr pAexpr\n    --`pAlt`  pThen3 mk_binop pExpr (pApply pBinop EVar) pExpr\n    --`pAlt`  \n    pThen4 mk_let (pLit \"let\") pDefns (pLit \"in\") pExpr\n    `pAlt`  pThen4 mk_letrec (pLit \"letrec\") pDefns (pLit \"in\") pExpr\n    `pAlt`  pThen4 mk_case (pLit \"case\") pExpr (pLit \"of\") pAlts\n    `pAlt`  pThen4 mk_lam (pLit \"\\\\\") (pOneOrMore pVar) (pLit \".\") pExpr\n    `pAlt`  pAexpr\n    where\n    mk_ap e a = EAp e a\n    mk_binop exp1 op exp2 = EAp (EAp op exp1) exp2\n    mk_let _ defns _ e = ELet nonRecursive  defns  e\n    mk_letrec _ defns _ e = ELet nonRecursive defns e\n    mk_case _ e _ a = ECase e a\n    mk_lam _ v _ e = ELam v e\n\npAexpr :: Parser CoreExpr\npAexpr =    pApply pVar EVar\n    `pAlt`  pApply pNum ENum\n    `pAlt`  pThen mk_pack2 (pThen4 mk_pack (pThen (\\_ _ -> pEmpty []) (pLit \"Pack\") (pLit \"{\")) pNum (pLit \",\") pNum) (pLit \"}\")\n    `pAlt`  pThen3 mk_pexpr (pLit \"(\") pExpr (pLit \")\")\n    where\n    mk_pack _ n1 _ n2 = EConstr n1 n2\n    mk_pack2 p _ = p\n    mk_pexpr _ e _ = e\n\npDefns :: Parser [(Name, Expr Name)]\npDefns = pOneOrMoreWithSep pDefn (pLit \";\")\n\npDefn :: Parser (Name, Expr Name)\npDefn = pThen3 mk_defn pVar (pLit \"=\") pExpr\n        where\n        mk_defn v _ e = (v, e)\n\npAlts :: Parser [CoreAlt]\npAlts = pOneOrMoreWithSep pAlter (pLit \";\")\n\npAlter :: Parser CoreAlt\npAlter = pThen4 mk_alter (pThen3 mk_tag (pLit \"<\") pNum (pLit \">\")) (pZeroOrMore pVar) (pLit \"->\") pExpr\n        where\n        mk_tag _ n _ = n\n        mk_alter n v _ e = (n, v, e)\n\npBinop :: Parser String\npBinop = pArithop `pAlt` pRelop `pAlt` pBoolop\n\npArithop :: Parser String\npArithop = (pLit \"+\") `pAlt` (pLit \"-\") `pAlt` (pLit \"*\") `pAlt` (pLit \"//\")\n\npRelop :: Parser String\npRelop = (pLit \"<\") `pAlt` (pLit \"<=\") `pAlt` (pLit \"==\") `pAlt` (pLit \"~=\") `pAlt` (pLit \">=\") `pAlt` (pLit \">\")\n\npBoolop :: Parser String\npBoolop = (pLit \"&\") `pAlt` (pLit \"|\")\n\nsyntax :: [Token] -> CoreProgram\nsyntax = take_first_parse . pProgram\n    where\n    take_first_parse ((prog, []) : _) = prog\n    take_first_parse (_ : others) = take_first_parse others\n    take_first_parse _ = error \"Syntax error\"\n\nparse :: String -> CoreProgram\nparse = syntax . clex 1\n\nmain :: IO ()\n--main = putStrLn $ iDisplay $ pprExpr (ELet nonRecursive [(\"att\", ENum 2)] (EAp (EAp (EVar \"+\") (EVar \"att\")) (EVar \"1\")))\nmain = putStrLn( pprint $ parse  \"f=3;\\ng x y = let z = x in z ;\\nh x = case (let y = x in y) of\\n<1> -> 2 ;\\n<2> -> 5\")\n--main = putStrLn $ show $ pOneOrMoreWithSep (pLit \"x\") (pLit \";\") [(1,\"x\"),(1,\";\"),(1,\"x\") ,(1,\";\"),(2,\"x\"),(2,\";\"),(2,\"x\"),(2,\";\"),(2,\"x\") ]\n--main = putStrLn $ show $ pExpr [(2,\"let\"),(2,\"z\"),(2,\"=\"),(2,\"x\"),(2,\"in\"),(2,\"z\")]\n--main = putStrLn $ pprint $ syntax [(1,\"f\"),(1,\"=\"),(1,\"3\") ,(1,\";\"),(2,\"g\"),(2,\"x\"),(2,\"y\"),(2,\"=\"), (2,\"let\"),(2,\"z\"),(2,\"=\"),(2,\"x\"),(2,\"in\"),(2,\"z\"),(2,\";\"),(3,\"h\"),(3,\"x\"),(3,\"=\"),(3,\"case\"),(3,\"(\"),(3,\"let\"),(3,\"y\"),(3,\"=\"),(3,\"x\"),(3,\"in\"),(3,\"y\"),(3,\")\"),(3,\"of\"),(4,\"<\"),(4,\"1\"),(4,\">\"),(4,\"->\"),(4,\"2\"),(4,\";\"),(5,\"<\"),(5,\"2\"),(5,\">\"),(5,\"->\"),(5,\"5\")]\n\n# 7\u65e5\u76ee\n\n## 38\u30da\u30fc\u30b8\n\n\u66f8\u304d\u7d42\u3048\u305f\u306e\u3067\u30b3\u30f3\u30d1\u30a4\u30eb\u3059\u308b.\n\u3044\u308d\u3044\u308dwarning\u304c\u51fa\u308b\u306e\u3067\u3067\u304d\u308b\u3060\u3051\u6f70\u3059.\nsyntax\u304c\u58ca\u308c\u3066\u308b\u306e\u3067\u76f4\u3059.pExpr\u304c\u307e\u305a\u3044\u3063\u307d\u3044.\n\u30d0\u30b0\u3063\u3066\u305f\u306epAp\u3068pBinop\u306e\u305b\u3044\u3060\u3063\u305f\u3057,\u3084\u3063\u3071\u308a\u8457\u8005\u3082\u308f\u304b\u3063\u3066\u5b9f\u88c5\u3057\u308d\u3063\u3066\u8a00\u3063\u3066\u305f\u3093\u3060\u306a.\u6ce8\u610f\u66f8\u304d\u306b\u3053\u306e2\u3064\u3092\u5b9f\u88c5\u3059\u308b\u306a\u3063\u3066\u66f8\u3044\u3066\u3042\u3063\u305f.\n\u305d\u3057\u3066\u8f1d\u304f\"Syntax Error\"! \u30d8\u30a3!\n\n\u306a\u3093\u3068\u304b\n\n```\nf = 3;\ng x y = let\nz = x\nin z;\nh x = case let\ny = x\nin y\n<1> -> 2;\n<2> -> 5\n```\n\n\u3092\u6b63\u3057\u304f\u30d1\u30fc\u30b9\u3067\u304d\u308b\u3088\u3046\u306b\u306a\u3063\u305f.\u3084\u3063\u305f\u30fc.\n\n\u66f8\u3044\u305f\u30bd\u30fc\u30b9\u304c300\u884c\u8d85\u3048\u3066\u304d\u305f\u306e\u3067\u3053\u308c\u304b\u3089diff\u3092\u53d6\u308b.\n\u4eca\u65e5\u306f\u4e00\u5fdc\u5b8c\u5168\u7248\u3092\u8cbc\u308b.\n\n**Exercise 1.21\u304c\u7d42\u308f\u3063\u305f.\u6b21\u306f1.22\u3092\u3084\u308b.**\n\n```hs\nimport Data.Char\n\ndata Expr a\n    = EVar Name -- Variables\n    | ENum Int -- Numbers\n    | EConstr Int Int -- Constructor tag arity\n    | EAp (Expr a) (Expr a) -- Applications\n    | ELet -- Let(rec) expressions\n        IsRec -- boolean with True = recursive,\n        [(a, Expr a)] -- Definitions\n        (Expr a) -- Body of let(rec)\n    | ECase -- Case expression\n        (Expr a) -- Expression to scrutinise\n        [Alter a] -- Alternatives\n    | ELam [a] (Expr a) -- Lambda abstractions\n    deriving(Show)\n\ntype CoreExpr = Expr Name\n\ntype Name = String\n \ntype IsRec = Bool\nrecursive, nonRecursive :: IsRec\nrecursive = True\nnonRecursive = False\n\nbindersOf :: [(a,b)] -> [a]\nbindersOf defns = [name | (name, rhs) <- defns]\n\nrhssOf :: [(a,b)] -> [b]\nrhssOf defns = [rhs | (name, rhs) <- defns]\n\ntype Alter a = (Int, [a], Expr a)\ntype CoreAlt = Alter Name\n\nisAtomicExpr :: Expr a -> Bool\nisAtomicExpr (EVar _) = True\nisAtomicExpr (ENum _) = True\nisAtomicExpr _ = False\n\ntype Program a = [ScDefn a]\ntype CoreProgram = Program Name\n\ntype ScDefn a = (Name, [a], Expr a)\ntype CoreScDefn = ScDefn Name\n\npreludeDefs :: CoreProgram\npreludeDefs\n    = [ (\"I\", [\"x\"], EVar \"x\"),\n        (\"K\", [\"x\",\"y\"], EVar \"x\"),\n        (\"F\",[\"x\",\"y\"], EVar \"y\"),\n        (\"S\", [\"x\",\"y\",\"z\"], EAp (EAp (EVar \"x\") (EVar \"z\")) (EAp (EVar \"y\") (EVar \"z\"))),\n        (\"C\", [\"x\",\"y\",\"z\"], EAp (EVar \"x\") (EAp (EVar \"y\") (EVar \"z\"))),\n        (\"B\", [\"x\",\"y\",\"z\"], EAp (EAp (EVar \"x\") (EVar \"z\")) (EVar \"y\")), \n        (\"W\", [\"x\", \"y\"], EAp (EAp (EVar \"x\") (EVar \"y\")) (EVar \"y\")) ]\n\ndata Iseq = INil\n            | IStr String\n            | IAppend Iseq Iseq\n            | IIndent Iseq\n            | INewline        \niNil :: Iseq -- The empty iseq\niStr :: String -> Iseq -- Turn a string into an iseq\niNum :: Int -> Iseq\niAppend :: Iseq -> Iseq -> Iseq -- Append two iseqs\niNewline :: Iseq -- New line with indentation\niIndent :: Iseq -> Iseq -- Indent an iseq\niNil = INil\niAppend seq1 INil = seq1\niAppend INil seq2 = seq2\niAppend seq1 seq2 = IAppend seq1 seq2\niNum n = iStr (show n)\niIndent seq1 = IIndent seq1\niNewline = INewline\niStr str = if elem '\\n' str then (IStr (takeWhile (/= '\\n') str)) `iAppend` iNewline `iAppend` (IStr (tail (dropWhile (/= '\\n') str))) else IStr str \niDisplay seq1 = flatten 0 [(seq1, 0)]\niDisplay :: Iseq -> String -- Turn an iseq into a string\niConcat :: [Iseq] -> Iseq\niConcat (car:cdr) = car `iAppend` (iConcat cdr)\niConcat [] = iNil\niFWNum :: Int -> Int -> Iseq\niFWNum width n\n    = iStr (replicate (width - length digits) ' ' ++ digits)\n    where\n    digits = show n\niLayn :: [Iseq] -> Iseq\niLayn seqs = iConcat (map lay_item (zip [1..] seqs))\n                where\n                lay_item (n, seq1)\n                    = iConcat [ iFWNum 4 n, iStr \") \", iIndent seq1, iNewline ]\niInterleave :: Iseq -> [Iseq] -> Iseq\niInterleave  _ [s] = s\niInterleave sep (car:cdr) = car `iAppend` sep `iAppend` (iInterleave sep cdr)\niInterleave INil s = iConcat s\niInterleave _ [] = iNil\n\nbinop :: [String]\nbinop = [\"+\", \"-\", \"*\", \"/\", \"<\", \"<=\", \"==\", \"\u02dc=\", \">=\", \">\", \"&\", \"|\"]\n\npprExpr :: CoreExpr -> Iseq\npprExpr (EVar v) = iStr v\npprExpr (ENum n) = iNum n\npprExpr (EConstr tag arity) = iConcat [ (iStr \"Pack{\"), (iNum tag), (iStr \", \"), (iNum arity), (iStr \"}\") ]\npprExpr (EAp (EAp (EVar biop) e1) e2)  --TODO: 1.5.5 \u30ab\u30c3\u30b3\u3092\u3044\u3044\u611f\u3058\u306b\u3059\u308b\n    | elem biop binop\n    = iConcat [ pprAExpr e1, iStr (\" \" ++ biop ++ \" \"), pprAExpr e2 ]\npprExpr (EAp e1 e2) = (pprExpr e1) `iAppend` (iStr \" \") `iAppend` (pprAExpr e2)\npprExpr (ELet isrec defns expr)\n    = iConcat [ iStr keyword, iNewline,\n                iIndent (pprDefns defns), iNewline,\n                iStr \"in \", pprExpr expr ]\n        where\n        keyword = if isrec then \"letrec\" else \"let\"\npprExpr (ECase expr alters)\n    = iConcat [ iStr \"case\", iStr \" \", pprExpr expr, iNewline,\n                iIndent (pprAlters alters), iNewline ]\npprExpr (ELam var expr)\n    = iConcat [iConcat (map iStr var), iStr \". \", pprExpr expr]\n\npprDefns :: [(Name, CoreExpr)] -> Iseq\npprDefns defns = iInterleave sep (map pprDefn defns)\n                    where\n                    sep = iConcat [ iStr \";\", iNewline ]\n\npprDefn :: (Name, CoreExpr) -> Iseq\npprDefn (name, expr) = iConcat [ iStr name, iStr \" = \", iIndent (pprExpr expr) ]\n\npprint :: CoreProgram -> String\npprint prog = iDisplay (pprProgram prog)\n\npprAlters :: [(Int, [Name], Expr Name)] -> Iseq\npprAlters alters\n    = iInterleave sep (map pprAlter alters)\n    where\n    sep = iConcat [ iStr \";\", iNewline ]\n\npprAlter :: (Int, [Name], Expr Name) -> Iseq\npprAlter (tag, var, expr)\n    = iConcat [iStr \"<\", iNum tag, iStr \">\", iStr (unwords var), iStr \" -> \", iIndent (pprExpr expr) ]\n\npprAExpr :: CoreExpr -> Iseq\npprAExpr e | isAtomicExpr e = pprExpr e\npprAExpr e | otherwise =  (iStr \"(\") `iAppend` pprExpr e `iAppend` (iStr \")\")\n\npprProgram :: CoreProgram -> Iseq\npprProgram scdefns\n    = iInterleave sep (map pprScDefn scdefns)\n    where\n    sep = iConcat [ iStr \";\", iNewline ]\n\npprScDefn :: CoreScDefn -> Iseq\npprScDefn (name, var, expr)\n    = iConcat [iStr name, if (var == []) then iNil else iStr \" \", iStr (unwords var), iStr \" = \", pprExpr expr]\n\nflatten :: Int -> [(Iseq, Int)] -> String\nflatten _ [] = \"\"\nflatten _ ((INewline, indent) : seqs)\n    = '\\n' : (replicate indent ' ') ++ (flatten indent seqs)\nflatten col ((IIndent seq1, indent) : seqs) -- TODO: indent properly\n    = flatten col ((seq1, col) : seqs)\nflatten col ((IStr seq1, _) : seqs)\n    = seq1 ++ (flatten col seqs)\nflatten col ((INil, _) : seqs)\n    = flatten col seqs\nflatten col ((IAppend seq1 seq2, indent) : seqs)\n    = flatten col ((seq1, indent) : (seq2, indent) : seqs)\n    \ntype Token = (Int, String)\ntwoCharOps :: [String]\ntwoCharOps = [\"==\", \"\u02dc=\", \">=\", \"<=\", \"->\"]\nclex :: Int -> String -> [Token]\nclex _ [] = []\nclex n (c1:c2:cs) | c1 == '|' && c2 == '|' = clex n (dropWhile (/= '\\n') cs)\nclex n (c1:c2:cs) | elem (c1:c2:[]) twoCharOps =(n, (c1:c2:[])) : clex n cs\nclex n (c:cs) |  c == '\\n' = clex (n + 1) cs\nclex n (c:cs) | isSpace c = clex n cs\nclex n (c:cs) | isDigit c = (n, num_token) : clex n rest_cs\n            where\n            num_token = c : takeWhile isDigit cs\n            rest_cs = dropWhile isDigit cs\nclex n (c:cs) | isAlpha c = (n, var_tok) : clex n rest_cs\n            where\n            isIdChar d = isAlpha d || isDigit d || (d == '_')\n            var_tok = c : takeWhile isIdChar cs\n            rest_cs = dropWhile isIdChar cs\nclex n (c:cs) = (n, [c]) : clex n cs\n\ntype Parser a = [Token] -> [(a, [Token])]\npLit :: String -> Parser String\npLit s = pSat (== s)\n\nkeywords :: [String]\nkeywords = [\"let\", \"letrec\", \"case\", \"in\", \"of\", \"Pack\"]\npVar :: Parser String\npVar = pSat (\\s@(x:_) -> isAlpha x && notElem s keywords)\n\npNum :: Parser Int\npNum = pApply (pSat (\\(x:_) -> isDigit x)) (\\x -> read x :: Int)\n\npAlt :: Parser a -> Parser a -> Parser a\npAlt p1 p2 toks = (p1 toks) ++ (p2 toks)\n\npThen :: (a -> b -> c) -> Parser a -> Parser b -> Parser c\npThen combine p1 p2 toks\n    = [ (combine v1 v2, toks2) | (v1,toks1) <- p1 toks, (v2,toks2) <- p2 toks1]\n\npThen3 :: (a -> b -> c -> d) -> Parser a -> Parser b -> Parser c -> Parser d\npThen3 combine p1 p2 p3 tokens\n    = [(combine v1 v2 v3, tokens3) | (v1, tokens1) <- p1 tokens, (v2, tokens2) <- p2 tokens1, (v3, tokens3) <- p3 tokens2]\n\n\npThen4 :: (a -> b -> c -> d -> e) -> Parser a -> Parser b -> Parser c -> Parser d -> Parser e\npThen4 combine p1 p2 p3 p4 tokens\n    = [(combine v1 v2 v3 v4, tokens4) | (v1, tokens1) <- p1 tokens, (v2, tokens2) <- p2 tokens1, (v3, tokens3) <- p3 tokens2, (v4, tokens4) <- p4 tokens3]\n\npZeroOrMore :: Parser a -> Parser [a]\npZeroOrMore p = (pOneOrMore p) `pAlt` (pEmpty [])\n\npEmpty :: a -> Parser a\npEmpty s toks = [(s, toks)]\n\npOneOrMore :: Parser a -> Parser [a]\npOneOrMore p = (take 1) . (pThen (:) p (pZeroOrMore p))\n\npApply :: Parser a -> (a -> b) -> Parser b\npApply a f toks = [(f b, tokens) | (b, tokens) <- a toks]\n\npOneOrMoreWithSep :: Parser a -> Parser b -> Parser [a]\npOneOrMoreWithSep a b = (take 1) . (pThen (:) a ((pThen (\\_ x -> x) b (pOneOrMoreWithSep a b)) `pAlt` (pEmpty [])))\n\npSat :: (String -> Bool) -> Parser String\npSat pd = pSatpred\n    where   pSatpred ((_, tok):toks) = if pd tok then [(tok, toks)] else []\n            pSatpred [] = []\n\npProgram :: Parser CoreProgram\npProgram = pOneOrMoreWithSep pSc (pLit \";\")\n\npSc :: Parser CoreScDefn\npSc = pThen4 mk_sc pVar (pZeroOrMore pVar) (pLit \"=\") pExpr\n    where mk_sc name arg _ expr = (name, arg, expr)\n\npExpr :: Parser CoreExpr\npExpr =     --pThen mk_ap pExpr pAexpr\n    --`pAlt`  pThen3 mk_binop pExpr (pApply pBinop EVar) pExpr\n    --`pAlt`  \n    pThen4 mk_let (pLit \"let\") pDefns (pLit \"in\") pExpr\n    `pAlt`  pThen4 mk_letrec (pLit \"letrec\") pDefns (pLit \"in\") pExpr\n    `pAlt`  pThen4 mk_case (pLit \"case\") pExpr (pLit \"of\") pAlts\n    `pAlt`  pThen4 mk_lam (pLit \"\\\\\") (pOneOrMore pVar) (pLit \".\") pExpr\n    `pAlt`  pAexpr\n    where\n    mk_ap e a = EAp e a\n    mk_binop exp1 op exp2 = EAp (EAp op exp1) exp2\n    mk_let _ defns _ e = ELet nonRecursive  defns  e\n    mk_letrec _ defns _ e = ELet nonRecursive defns e\n    mk_case _ e _ a = ECase e a\n    mk_lam _ v _ e = ELam v e\n\npAexpr :: Parser CoreExpr\npAexpr =    pApply pVar EVar\n    `pAlt`  pApply pNum ENum\n    `pAlt`  pThen mk_pack2 (pThen4 mk_pack (pThen (\\_ _ -> pEmpty []) (pLit \"Pack\") (pLit \"{\")) pNum (pLit \",\") pNum) (pLit \"}\")\n    `pAlt`  pThen3 mk_pexpr (pLit \"(\") pExpr (pLit \")\")\n    where\n    mk_pack _ n1 _ n2 = EConstr n1 n2\n    mk_pack2 p _ = p\n    mk_pexpr _ e _ = e\n\npDefns :: Parser [(Name, Expr Name)]\npDefns = pOneOrMoreWithSep pDefn (pLit \";\")\n\npDefn :: Parser (Name, Expr Name)\npDefn = pThen3 mk_defn pVar (pLit \"=\") pExpr\n        where\n        mk_defn v _ e = (v, e)\n\npAlts :: Parser [CoreAlt]\npAlts = pOneOrMoreWithSep pAlter (pLit \";\")\n\npAlter :: Parser CoreAlt\npAlter = pThen4 mk_alter (pThen3 mk_tag (pLit \"<\") pNum (pLit \">\")) (pZeroOrMore pVar) (pLit \"->\") pExpr\n        where\n        mk_tag _ n _ = n\n        mk_alter n v _ e = (n, v, e)\n\npBinop :: Parser String\npBinop = pArithop `pAlt` pRelop `pAlt` pBoolop\n\npArithop :: Parser String\npArithop = (pLit \"+\") `pAlt` (pLit \"-\") `pAlt` (pLit \"*\") `pAlt` (pLit \"//\")\n\npRelop :: Parser String\npRelop = (pLit \"<\") `pAlt` (pLit \"<=\") `pAlt` (pLit \"==\") `pAlt` (pLit \"~=\") `pAlt` (pLit \">=\") `pAlt` (pLit \">\")\n\npBoolop :: Parser String\npBoolop = (pLit \"&\") `pAlt` (pLit \"|\")\n\nsyntax :: [Token] -> CoreProgram\nsyntax = take_first_parse . pProgram\n    where\n    take_first_parse ((prog, []) : _) = prog\n    take_first_parse (_ : others) = take_first_parse others\n    take_first_parse _ = error \"Syntax error\"\n\nparse :: String -> CoreProgram\nparse = syntax . clex 1\n\nmain :: IO ()\n--main = putStrLn $ iDisplay $ pprExpr (ELet nonRecursive [(\"att\", ENum 2)] (EAp (EAp (EVar \"+\") (EVar \"att\")) (EVar \"1\")))\nmain = putStrLn( pprint $ parse  \"f=3;\\ng x y = let z = x in z ;\\nh x = case (let y = x in y) of\\n<1> -> 2 ;\\n<2> -> 5\")\n--main = putStrLn $ show $ pOneOrMoreWithSep (pLit \"x\") (pLit \";\") [(1,\"x\"),(1,\";\"),(1,\"x\") ,(1,\";\"),(2,\"x\"),(2,\";\"),(2,\"x\"),(2,\";\"),(2,\"x\") ]\n--main = putStrLn $ show $ pExpr [(2,\"let\"),(2,\"z\"),(2,\"=\"),(2,\"x\"),(2,\"in\"),(2,\"z\")]\n--main = putStrLn $ pprint $ syntax [(1,\"f\"),(1,\"=\"),(1,\"3\") ,(1,\";\"),(2,\"g\"),(2,\"x\"),(2,\"y\"),(2,\"=\"), (2,\"let\"),(2,\"z\"),(2,\"=\"),(2,\"x\"),(2,\"in\"),(2,\"z\"),(2,\";\"),(3,\"h\"),(3,\"x\"),(3,\"=\"),(3,\"case\"),(3,\"(\"),(3,\"let\"),(3,\"y\"),(3,\"=\"),(3,\"x\"),(3,\"in\"),(3,\"y\"),(3,\")\"),(3,\"of\"),(4,\"<\"),(4,\"1\"),(4,\">\"),(4,\"->\"),(4,\"2\"),(4,\";\"),(5,\"<\"),(5,\"2\"),(5,\">\"),(5,\"->\"),(5,\"5\")]\n```\n", "tags": ["\u30a4\u30f3\u30d7\u30ea\u30e1\u30f3\u30c6\u30a3\u30f3\u30b0\u30d5\u30a1\u30f3\u30af\u30b7\u30e7\u30ca\u30eb\u30e9\u30f3\u30b2\u30fc\u30b8\u30ba"]}