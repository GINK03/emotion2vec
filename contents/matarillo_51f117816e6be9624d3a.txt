{"context": " More than 1 year has passed since last update.\u79fb\u690d\u3064\u3044\u3067\u306bNode\u578b\u306e\u5b9a\u7fa9\u3092\u30ea\u30b9\u30c8\u306e\u7d44\u304b\u3089\u7d44\u306e\u30ea\u30b9\u30c8\u306b\u5909\u3048\u3066\u307f\u305f\u3002\n\u30ea\u30b9\u30c8\u306e\u7d44\u3060\u3068\u9577\u3055\u304c\u7570\u306a\u308b\u30ea\u30b9\u30c8\u3092\u8a31\u5bb9\u3057\u3066\u3057\u307e\u3046\u3053\u3068\u306b\u306a\u308b\u304c\u3001\u7d44\u306e\u30ea\u30b9\u30c8\u306a\u3089\u305d\u306e\u5fc3\u914d\u306f\u306a\u3044\u3002\n\uff08\u8ffd\u8a18\uff09\u73fe\u5728\u306eF#\u3060\u3068\u5185\u5305\u8868\u8a18\u304c\u9045\u3044\u307f\u305f\u3044\u306a\u306e\u3067\u3001\u5185\u5305\u8868\u8a18\u3092\u3084\u3081\u3066\u307f\u305f\u3002thx rst76\n\nmain.fs\ntype Point =\n    {X: int; Y: int;}\n    static member ( + ) (p: Point, q: Point) = {X = p.X + q.X; Y = p.Y + q.Y;}\n    static member ( - ) (p: Point, q: Point) = {X = p.X - q.X; Y = p.Y - q.Y;}\n\ntype Pair = Point * Point\n\ntype Node = Pair list\n\nlet move ((f, b) : Pair) (p : Point) : Pair =\n    (f + p, b - p)\n\nlet moves ((pf, pb) : Pair) ((qf, qb) : Pair) : Pair list =\n    let forward : Point = pf - qf\n    let left : Point = {X = forward.Y; Y = -forward.X;}\n    let right : Point = {X = -forward.Y; Y = forward.X;}\n    List.map (move (pf, pb)) [forward; left; right;]\n\nlet nexts (n: Node) : Node list =\n    match n with\n    | p1::p0::ps -> List.map (fun p2 -> p2::n) (moves p1 p0)\n    | _ -> []\n\nlet exists (p : Point) (ps : Pair list) =\n    List.exists (fun (pf, pb) -> p = pf || p = pb) ps\n\nlet solve (size: int) : Node list =\n    let center : Point = {X = size/2; Y = size/2;}\n    let p0 : Pair = (center, center)\n    let p1 : Pair = move p0 {X = 0; Y = 1;}\n    let initial : Node = [p1; p0;]\n\n    let atboundary (p : Point) : bool =\n        (p.X = 0) || (p.X = size) || (p.Y = 0) || (p.Y = size)\n\n    let rec solutions (n : Node) : Node list =\n        match n with\n        | (pf, pb)::ps when atboundary pf -> [n]\n        | (pf, pb)::ps when exists pf ps -> []\n        | p::ps -> List.collect solutions (nexts n)\n        | _ -> []\n\n    solutions initial\n\nprintfn \"%d\" (List.length (solve 8))\n\n\n\u79fb\u690d\u3064\u3044\u3067\u306bNode\u578b\u306e\u5b9a\u7fa9\u3092\u30ea\u30b9\u30c8\u306e\u7d44\u304b\u3089\u7d44\u306e\u30ea\u30b9\u30c8\u306b\u5909\u3048\u3066\u307f\u305f\u3002\n\u30ea\u30b9\u30c8\u306e\u7d44\u3060\u3068\u9577\u3055\u304c\u7570\u306a\u308b\u30ea\u30b9\u30c8\u3092\u8a31\u5bb9\u3057\u3066\u3057\u307e\u3046\u3053\u3068\u306b\u306a\u308b\u304c\u3001\u7d44\u306e\u30ea\u30b9\u30c8\u306a\u3089\u305d\u306e\u5fc3\u914d\u306f\u306a\u3044\u3002\n\uff08\u8ffd\u8a18\uff09\u73fe\u5728\u306eF#\u3060\u3068\u5185\u5305\u8868\u8a18\u304c\u9045\u3044\u307f\u305f\u3044\u306a\u306e\u3067\u3001\u5185\u5305\u8868\u8a18\u3092\u3084\u3081\u3066\u307f\u305f\u3002thx rst76\n\n```fsharp:main.fs\ntype Point =\n    {X: int; Y: int;}\n    static member ( + ) (p: Point, q: Point) = {X = p.X + q.X; Y = p.Y + q.Y;}\n    static member ( - ) (p: Point, q: Point) = {X = p.X - q.X; Y = p.Y - q.Y;}\n\ntype Pair = Point * Point\n\ntype Node = Pair list\n\nlet move ((f, b) : Pair) (p : Point) : Pair =\n    (f + p, b - p)\n\nlet moves ((pf, pb) : Pair) ((qf, qb) : Pair) : Pair list =\n    let forward : Point = pf - qf\n    let left : Point = {X = forward.Y; Y = -forward.X;}\n    let right : Point = {X = -forward.Y; Y = forward.X;}\n    List.map (move (pf, pb)) [forward; left; right;]\n\nlet nexts (n: Node) : Node list =\n    match n with\n    | p1::p0::ps -> List.map (fun p2 -> p2::n) (moves p1 p0)\n    | _ -> []\n\nlet exists (p : Point) (ps : Pair list) =\n    List.exists (fun (pf, pb) -> p = pf || p = pb) ps\n\nlet solve (size: int) : Node list =\n    let center : Point = {X = size/2; Y = size/2;}\n    let p0 : Pair = (center, center)\n    let p1 : Pair = move p0 {X = 0; Y = 1;}\n    let initial : Node = [p1; p0;]\n\n    let atboundary (p : Point) : bool =\n        (p.X = 0) || (p.X = size) || (p.Y = 0) || (p.Y = size)\n\n    let rec solutions (n : Node) : Node list =\n        match n with\n        | (pf, pb)::ps when atboundary pf -> [n]\n        | (pf, pb)::ps when exists pf ps -> []\n        | p::ps -> List.collect solutions (nexts n)\n        | _ -> []\n\n    solutions initial\n\nprintfn \"%d\" (List.length (solve 8))\n```", "tags": ["F#"]}