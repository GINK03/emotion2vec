{"tags": ["yhpg", "\u3069\u3046\u66f8\u304f"], "context": " More than 1 year has passed since last update.\u7b2c\u56db\u56de\u30aa\u30d5\u30e9\u30a4\u30f3\u30ea\u30a2\u30eb\u30bf\u30a4\u30e0\u3069\u3046\u66f8\u304f\u306e\u53c2\u8003\u554f\u984c (http://qiita.com/items/9c514267214d3917edf2)\n\u3092Java\u3067\u89e3\u304d\u307e\u3057\u305f\u3002\n\u5358\u7d14\u306a\u6570\u3048\u4e0a\u3052\u3067\u3001\u6240\u8981\u6642\u9593\u306f3\u6642\u9593\u7a0b\u5ea6\u3002\n\nCountRoute.java\nimport java.util.List;\nimport java.util.ArrayList;\n\npublic class CountRoute {\n\n    private final List<List<Point>> closed;\n    private final Point start;\n    private final Point goal;\n\n    public CountRoute(String closedData) {\n        closed = parseClosedEdge(closedData);\n        start = Point.getInstance(0, 0);\n        goal = Point.getInstance(Point.SIZE-1, Point.SIZE-1);\n    }\n\n    private List<List<Point>> parseClosedEdge(String closedData) {\n        List<List<Point>> ret = new ArrayList<List<Point>>();\n        for ( String closedEdge : closedData.split(\" \") ) {\n            List<Point> list = new ArrayList<Point>();\n            for ( char c : closedEdge.toCharArray() ) {\n                int index = c - 'a';\n                list.add(Point.getInstance(index/Point.SIZE, index%Point.SIZE));\n            }\n            ret.add(list);\n        }\n        return ret;\n    }\n\n    private boolean isClosedEdge(Point prev, Point p) {\n        if ( closed == null ) {\n            return false;\n        }\n        for ( List<Point> list : closed ) {\n            if ( list.contains(prev) && list.contains(p) ) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    public int count() {\n        List<Point> passed = new ArrayList<Point>();\n        return move(null, start, passed);\n    }\n\n    private int move(Point prev, Point p, List<Point> passed) {\n        if ( p == null || passed.contains(p) || isClosedEdge(prev, p) ) {\n            return 0;\n        }\n        if ( goal.equals(p) ) {\n            return 1;\n        }\n        int num = 0;\n        passed.add(p);\n        num += move( p, p.up(), passed );\n        num += move( p, p.left(), passed );\n        num += move( p, p.right(), passed );\n        num += move( p, p.down(), passed );\n        passed.remove(p);\n        return num;\n    }\n\n    public static void main(String[] args) {\n        for ( String[] test : testData ) {\n            int result = new CountRoute(test[0]).count();\n            System.out.println( test[0] );\n            if ( result != Integer.parseInt(test[1]) ) {\n                System.out.println( \"***Error*** \" + test[1] + \"->\" );\n            }\n            System.out.println( result );\n        }\n    }\n\n    private static final String testData[][] = {\n        { \"\", \"8512\", },\n        { \"af\", \"4256\", },\n        { \"xy\", \"4256\", },\n        { \"pq qr rs st di in ns sx\", \"184\", },\n        { \"af pq qr rs st di in ns sx\", \"92\", },\n        { \"bg ch di ij no st\", \"185\", },\n        { \"bc af ch di no kp mr ns ot pu rs\", \"16\", },\n        { \"ab af\", \"0\", },\n        { \"ty xy\", \"0\", },\n        { \"bg ch ej gh lm lq mr ot rs sx\", \"11\", },\n        { \"ty ch hi mn kp mr rs sx\", \"18\", },\n        { \"xy ch hi mn kp mr rs sx\", \"32\", },\n        { \"ch hi mn kp mr rs sx\", \"50\", },\n        { \"ab cd uv wx\", \"621\", },\n        { \"gh mn st lq qr\", \"685\", },\n        { \"fg gl lm mr rs\", \"171\", },\n    };\n}\n\n\n\n\nPoint.java\nclass Point {\n    public static final int SIZE = 5;\n\n    private final int x;\n    private final int y;\n    private Point(int x, int y) {\n        this.x = x;\n        this.y = y;\n    }\n\n    public static Point getInstance(int x, int y) {\n        if ( x < 0 || x >= SIZE || y < 0 || y >= SIZE ) {\n            return null;\n        }\n        return new Point(x, y);\n    }\n\n    public Point up() { return getInstance(x, y-1); }\n    public Point left() { return getInstance(x-1, y); }\n    public Point right() { return getInstance(x+1, y); }\n    public Point down() { return getInstance(x, y+1); }\n\n    @Override public boolean equals(Object o) {\n        if ( !(o instanceof Point) ) {\n            return false;\n        }\n        Point p = (Point)o;\n        return this.x == p.x && this.y == p.y;\n    }\n    @Override public int hashCode() {\n        int result = 17;\n        result = result*31 + x;\n        result = result*31 + y;\n        return result;\n    }\n\n    @Override public String toString() {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"Point: x = \");\n        sb.append(x);\n        sb.append(\", y = \");\n        sb.append(y);\n        return sb.toString();\n    }\n}\n\n\n\u7b2c\u56db\u56de\u30aa\u30d5\u30e9\u30a4\u30f3\u30ea\u30a2\u30eb\u30bf\u30a4\u30e0\u3069\u3046\u66f8\u304f\u306e\u53c2\u8003\u554f\u984c (http://qiita.com/items/9c514267214d3917edf2)\n\u3092Java\u3067\u89e3\u304d\u307e\u3057\u305f\u3002\n\n\u5358\u7d14\u306a\u6570\u3048\u4e0a\u3052\u3067\u3001\u6240\u8981\u6642\u9593\u306f3\u6642\u9593\u7a0b\u5ea6\u3002\n\n``` CountRoute.java\nimport java.util.List;\nimport java.util.ArrayList;\n\npublic class CountRoute {\n\n    private final List<List<Point>> closed;\n    private final Point start;\n    private final Point goal;\n\n    public CountRoute(String closedData) {\n        closed = parseClosedEdge(closedData);\n        start = Point.getInstance(0, 0);\n        goal = Point.getInstance(Point.SIZE-1, Point.SIZE-1);\n    }\n\n    private List<List<Point>> parseClosedEdge(String closedData) {\n        List<List<Point>> ret = new ArrayList<List<Point>>();\n        for ( String closedEdge : closedData.split(\" \") ) {\n            List<Point> list = new ArrayList<Point>();\n            for ( char c : closedEdge.toCharArray() ) {\n                int index = c - 'a';\n                list.add(Point.getInstance(index/Point.SIZE, index%Point.SIZE));\n            }\n            ret.add(list);\n        }\n        return ret;\n    }\n\n    private boolean isClosedEdge(Point prev, Point p) {\n        if ( closed == null ) {\n            return false;\n        }\n        for ( List<Point> list : closed ) {\n            if ( list.contains(prev) && list.contains(p) ) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    public int count() {\n        List<Point> passed = new ArrayList<Point>();\n        return move(null, start, passed);\n    }\n\n    private int move(Point prev, Point p, List<Point> passed) {\n        if ( p == null || passed.contains(p) || isClosedEdge(prev, p) ) {\n            return 0;\n        }\n        if ( goal.equals(p) ) {\n            return 1;\n        }\n        int num = 0;\n        passed.add(p);\n        num += move( p, p.up(), passed );\n        num += move( p, p.left(), passed );\n        num += move( p, p.right(), passed );\n        num += move( p, p.down(), passed );\n        passed.remove(p);\n        return num;\n    }\n\n    public static void main(String[] args) {\n        for ( String[] test : testData ) {\n            int result = new CountRoute(test[0]).count();\n            System.out.println( test[0] );\n            if ( result != Integer.parseInt(test[1]) ) {\n                System.out.println( \"***Error*** \" + test[1] + \"->\" );\n            }\n            System.out.println( result );\n        }\n    }\n    \n    private static final String testData[][] = {\n        { \"\", \"8512\", },\n        { \"af\", \"4256\", },\n        { \"xy\", \"4256\", },\n        { \"pq qr rs st di in ns sx\", \"184\", },\n        { \"af pq qr rs st di in ns sx\", \"92\", },\n        { \"bg ch di ij no st\", \"185\", },\n        { \"bc af ch di no kp mr ns ot pu rs\", \"16\", },\n        { \"ab af\", \"0\", },\n        { \"ty xy\", \"0\", },\n        { \"bg ch ej gh lm lq mr ot rs sx\", \"11\", },\n        { \"ty ch hi mn kp mr rs sx\", \"18\", },\n        { \"xy ch hi mn kp mr rs sx\", \"32\", },\n        { \"ch hi mn kp mr rs sx\", \"50\", },\n        { \"ab cd uv wx\", \"621\", },\n        { \"gh mn st lq qr\", \"685\", },\n        { \"fg gl lm mr rs\", \"171\", },\n    };\n}\n\n```\n\n``` Point.java\nclass Point {\n    public static final int SIZE = 5;\n\n    private final int x;\n    private final int y;\n    private Point(int x, int y) {\n        this.x = x;\n        this.y = y;\n    }\n\n    public static Point getInstance(int x, int y) {\n        if ( x < 0 || x >= SIZE || y < 0 || y >= SIZE ) {\n            return null;\n        }\n        return new Point(x, y);\n    }\n\n    public Point up() { return getInstance(x, y-1); }\n    public Point left() { return getInstance(x-1, y); }\n    public Point right() { return getInstance(x+1, y); }\n    public Point down() { return getInstance(x, y+1); }\n\n    @Override public boolean equals(Object o) {\n        if ( !(o instanceof Point) ) {\n            return false;\n        }\n        Point p = (Point)o;\n        return this.x == p.x && this.y == p.y;\n    }\n    @Override public int hashCode() {\n        int result = 17;\n        result = result*31 + x;\n        result = result*31 + y;\n        return result;\n    }\n\n    @Override public String toString() {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"Point: x = \");\n        sb.append(x);\n        sb.append(\", y = \");\n        sb.append(y);\n        return sb.toString();\n    }\n}\n```\n"}