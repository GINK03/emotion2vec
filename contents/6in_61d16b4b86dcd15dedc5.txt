{"context": "\n\n\u6982\u8981\nnim\u306e\u30b3\u30ec\u30af\u30b7\u30e7\u30f3\u64cd\u4f5c\u3092\u30b3\u30c4\u30b3\u30c4\u3068\u3002\n* algorithm\n* tables\n* sets\n* lists\n* queues\n* critbits\n* intsets\n\n\u4ee5\u4e0b\u30e1\u30e2\n\n\u540c\u3058\u5024\u3067\u57cb\u3081\u308b(fill)\nimport algorithm,tables,hashes,math\nimport sets,lists,critbits,sequtils,queues,intsets,strutils\nblock:\n  var ary : array[0..3,int]\n  # \u7bc4\u56f2\u6307\u5b9a\u306a\u3057\n  fill(ary,1)\n  for x in ary:\n    echo x\n  # \u7bc4\u56f2\u6307\u5b9a\n  fill(ary,0,3,5)\n  for x in ary:\n    echo x\n\n(stdout)\n1\n1\n1\n1\n5\n5\n5\n5\n\n\n\u30ea\u30d0\u30fc\u30b9\nimport algorithm,tables,hashes,math\nimport sets,lists,critbits,sequtils,queues,intsets,strutils\nblock:\n  var ary = @[1,2,3,4]\n  echo ary\n  ary.reverse\n  echo ary\n  var ary2 = ary.reversed\n  echo ary2\n\n(stdout)\n@[1, 2, 3, 4]\n@[4, 3, 2, 1]\n@[1, 2, 3, 4]\n\n\n\u691c\u7d22(\u30d0\u30a4\u30ca\u30ea\u30b5\u30fc\u30c1)\nimport algorithm,tables,hashes,math\nimport sets,lists,critbits,sequtils,queues,intsets,strutils\nblock:\n  var ary = @[1,2,3,4,5,6,7,8,9]\n  echo ary.binarySearch(8)\n  echo ary.smartBinarySearch(3)\n\n(stdout)\n7\n2\n\n\nlowerBound\nimport algorithm,tables,hashes,math\nimport sets,lists,critbits,sequtils,queues,intsets,strutils\nblock:\n  var ary = @[1,2,3,4,5,6]\n  for x in 0..10 :\n    echo x,\" \",ary.lowerBound(x)\n\n(stdout)\n0 0\n1 0\n2 1\n3 2\n4 3\n5 4\n6 5\n7 6\n8 6\n9 6\n10 6\n\n\n\u30bd\u30fc\u30c8\nimport algorithm,tables,hashes,math\nimport sets,lists,critbits,sequtils,queues,intsets,strutils\nblock:\n  # cmp\u95a2\u6570\u3067\u30bd\u30fc\u30c8\n  var ary = @[3,4,1,8,6,5,7,0,1]\n  echo ary\n  ary.sort(system.cmp[int])\n  echo ary\n\n(stdout)\n@[3, 4, 1, 8, 6, 5, 7, 0, 1]\n@[0, 1, 1, 3, 4, 5, 6, 7, 8]\n\n\n\u30bd\u30fc\u30c8(proc\u3092\u6e21\u3059)\nimport algorithm,tables,hashes,math\nimport sets,lists,critbits,sequtils,queues,intsets,strutils\nblock:\n  var ary = @[3,4,1,8,6,5,7,0,1]\n  ary.sort( proc (x,y:int) : int = cmp(x,y) )\n  echo ary\n\n(stdout)\n@[0, 1, 1, 3, 4, 5, 6, 7, 8]\n\n\n\u30bd\u30fc\u30c8(do\u3092\u4f7f\u3063\u305f\u30bd\u30fc\u30c8)\nimport algorithm,tables,hashes,math\nimport sets,lists,critbits,sequtils,queues,intsets,strutils\nblock:\n  var ary = @[3,4,1,8,6,5,7,0,1]\n  ary.sort do (x,y:int) -> int : result = cmp(x,y)\n  echo ary\n\n(stdout)\n@[0, 1, 1, 3, 4, 5, 6, 7, 8]\n\n\n\u30bd\u30fc\u30c8(sorted)\nimport algorithm,tables,hashes,math\nimport sets,lists,critbits,sequtils,queues,intsets,strutils\nblock:\n  # do\u3092\u4f7f\u3063\u305f\u30bd\u30fc\u30c8\n  var ary = @[3,4,1,8,6,5,7,0,1]\n  var ary2 = ary.sorted do (x,y:int) -> int :\n    result = cmp(x,y)\n  echo \"original=\",ary\n  echo \"sorted  =\",ary2\n  echo ary.isSorted(system.cmp[int])\n  echo ary2.isSorted(system.cmp[int])\n\n(stdout)\noriginal=@[3, 4, 1, 8, 6, 5, 7, 0, 1]\nsorted  =@[0, 1, 1, 3, 4, 5, 6, 7, 8]\nfalse\ntrue\n\n\n\u9806\u5217 (prevPermutation)\nimport algorithm,tables,hashes,math\nimport sets,lists,critbits,sequtils,queues,intsets,strutils\nblock:\n  var ary = @[1,2,4,3]\n  ary.prevPermutation\n  echo ary\n\n(stdout)\n@[1, 2, 3, 4]\n\n\ntemplate\u3092\u4f7f\u3063\u305f\u30bd\u30fc\u30c8\nimport algorithm,tables,hashes,math\nimport sets,lists,critbits,sequtils,queues,intsets,strutils\nblock:\n  var ary = @[3,4,1,8,6,5,7,0,1]\n  echo ary.sortedByIt(it)\n\n(stdout)\n@[0, 1, 1, 3, 4, 5, 6, 7, 8]\n\n\nhashes\u306b\u3088\u308b\u30cf\u30c3\u30b7\u30e5\u3092\u53d6\u5f97\nimport algorithm,tables,hashes,math\nimport sets,lists,critbits,sequtils,queues,intsets,strutils\nblock:\n  var name1 = \"Mr.\u30b9\u30dd\u30c3\u30af\"\n  var name2 = \"Mr.\u30b9\u30dd\u30c3\u30af\"\n  echo name1.hash == name2.hash\n\n(stdout)\ntrue\n\n\ntables \u30b5\u30f3\u30d7\u30eb\nimport algorithm,tables,hashes,math\nimport sets,lists,critbits,sequtils,queues,intsets,strutils\n#[\ntable\u306f\u3001\u30cf\u30c3\u30b7\u30e5\u30ad\u30fc\u3092\u62e1\u5f35\u3057\u305f\u3082\u306e\u3063\u307d\u3044\u3067\u3059\u3002\n\u72ec\u81ea\u69cb\u9020\u4f53\uff1f\u3092\u30ad\u30fc\u306b\u3059\u308b\u5834\u5408\u306f\u3001hash\u95a2\u6570\u3092\u5b9f\u88c5\u3057\u306a\u3044\u3068\u52d5\u4f5c\u3057\u306a\u3044\u3088\u3046\u3067\u3059\u3002\n]#\ntype\n  Person = object\n    firstName, lastName: string\nproc hash(x: Person): Hash =\n  ## Piggyback on the already available string hash proc.\n  ##\n  ## Without this proc nothing works!\n  result = x.firstName.hash !& x.lastName.hash\n  result = !$result\nproc `$`(x: Person) : string =\n  result = x.firstName\nblock:\n  var\n    salaries: Table[Person,int] = initTable[Person, int]()\n    p1, p2, p3: Person\n  p1.firstName = \"Steven\"\n  p1.lastName = \"Rogers\"\n  salaries[p1] = 30_000\n  p2.firstName = \"Tony\"\n  p2.lastName = \"Stark\"\n  salaries[p2] = 40_000\n  p3.firstName = \"Bruce\"\n  p3.lastName = \"Banner\"\n  echo \"contains=\",salaries.contains(p1)\n  echo \"get value=\",salaries[p1]\n  echo \"length=\",salaries.len\n  echo \"get or default=\", salaries.getOrDefault(p3)\n  ### toTable\u3092\u4f7f\u3063\u305f\u521d\u671f\u5316\n  let salaries2: Table[Person,int] = {p1:30_000,p2:40_000}.toTable\n  echo salaries == salaries2\n  #salaries2[p3] = 10_000\n  let salaries3: OrderedTable[Person,int] = {p1:30_000,p2:40_000}.toOrderedTable\n  for k,v in salaries :\n    echo k\n  for k,v in salaries2 :\n    echo k\n  for k,v in salaries3 :\n    echo k\n\n(stdout)\ncontains=true\nget value=30000\nlength=2\nget or default=0\ntrue\nSteven\nTony\nSteven\nTony\nSteven\nTony\n\n\nCOuntTable\u3000\u30ad\u30fc\u306e\u307f\u3067\u3001\u305d\u306e\u6570\u3092\u30ab\u30a6\u30f3\u30c8\u3059\u308b\nimport algorithm,tables,hashes,math\nimport sets,lists,critbits,sequtils,queues,intsets,strutils\nblock:\n  var count = initCountTable[string]()\n  count.inc(\"DEC\")\n  count.inc(\"DEC\")\n  count.inc(\"ABC\")\n  count.inc(\"ABC\")\n  count.inc(\"ABC\")\n  echo count\n  count.sort\n  echo count\n\n(stdout)\n{ABC: 3, DEC: 2}\n{ABC: 3, DEC: 2}\n\n\nHashSet\nimport algorithm,tables,hashes,math\nimport sets,lists,critbits,sequtils,queues,intsets,strutils\nblock:\n  # initSet\u3067\u521d\u671f\u5316\n  var hashSet1: HashSet[string] = initSet[string]()\n  hashSet1.incl(\"key1\")\n  hashSet1.incl(\"key2\")\n  echo \"hashSet1=>\",hashSet1\n  echo \"contains=>\",hashSet1.contains(\"key1\")\n  # \u53d6\u308a\u9664\u304f\n  hashSet1.excl(\"key1\")\n  hashSet1.excl(\"key2\")\n  echo \"hashSet1=>\",hashSet1\n  # \u518d\u3073\u8ffd\u52a0\n  hashSet1.incl(\"key1\")\n  hashSet1.incl(\"key2\")\n  # toSet\u3067\u521d\u671f\u5316\n  var hashSet2 = [\"key1\",\"key2\"].toSet\n  echo \"hashSet2=>\",hashSet2\n  echo \"equals  =>\",hashSet1 == hashSet2\n  for x in hashSet1.items :\n    echo \"item=>\",x\n\n(stdout)\nhashSet1=>{key2, key1}\ncontains=>true\nhashSet1=>{}\nhashSet2=>{key2, key1}\nequals  =>true\nitem=>key2\nitem=>key1\n\n\nOrderedHashSet(\u5024\u3092\u8ffd\u52a0\u3057\u305f\u9806\u756a\u3092\u4fdd\u6301)\nimport algorithm,tables,hashes,math\nimport sets,lists,critbits,sequtils,queues,intsets,strutils\nblock:\n  # initOrderedSet\u3067\u521d\u671f\u5316\n  var hashSet1: OrderedSet[string] = initOrderedSet[string]()\n  hashSet1.incl(\"key1\")\n  hashSet1.incl(\"key2\")\n  echo \"hashSet1=>\",hashSet1\n  # toOrderedSet\u3067\u521d\u671f\u5316\n  var hashSet2: OrderedSet[string] = [\"key1\",\"key2\"].toOrderedSet\n  echo \"hashSet2=>\",hashSet2\n  #echo hashSet1 == hashSet2\n  var hashSet3: OrderedSet[string] = initOrderedSet[string]()\n  hashSet3.incl(\"key1\")\n  hashSet3.incl(\"key2\")\n  echo \"equals=>\",hashSet1 == hashSet3\n\n(stdout)\nhashSet1=>{key1, key2}\nhashSet2=>{key1, key2}\nequals=>true\n\n\n\u53cc\u65b9\u5411\u30ea\u30f3\u30af\u30ea\u30b9\u30c8\nimport algorithm,tables,hashes,math\nimport sets,lists,critbits,sequtils,queues,intsets,strutils\nblock:\n  var list1 : DoublyLinkedList[int] = initDoublyLinkedList[int]()\n  # \u672b\u5c3e\u306b\u8ffd\u52a0\n  list1.append(1)\n  list1.append(2)\n  list1.append(3)\n  list1.append(4)\n  echo \"list1=>\",list1\n  # \u5148\u982d\u306b\u8ffd\u52a0\n  list1.prepend(4)\n  list1.prepend(5)\n  list1.prepend(6)\n  list1.prepend(7)\n  echo \"list1=>\",list1\n  # \u691c\u7d22\n  echo \"find=>\",list1.find(7).value\n  # \u524a\u9664\n  list1.remove(list1.find(7))\n  echo \"list1=>\",list1\n\n(stdout)\nlist1=>[1, 2, 3, 4]\nlist1=>[7, 6, 5, 4, 1, 2, 3, 4]\nfind=>7\nlist1=>[6, 5, 4, 1, 2, 3, 4]\n\n\nQueue\nimport algorithm,tables,hashes,math\nimport sets,lists,critbits,sequtils,queues,intsets,strutils\nblock:\n  var q : Queue[string] = initQueue[string]()\n  q.enqueue(\"abc\")\n  q.add(\"def\")\n  q.add(\"ghi\")\n  echo \"len=>\",q.len\n  echo \"q  =>\",q\n  var v = q.dequeue()\n  echo \"v  =>\",v\n  echo \"q  =>\",q\n  for v in q :\n    echo \"val=>\",v\n  echo \"q  =>\",q\n\n(stdout)\nlen=>3\nq  =>[abc, def, ghi]\nv  =>abc\nq  =>[def, ghi]\nval=>def\nval=>ghi\nq  =>[def, ghi]\n\n\nCrit-Bit \u30cf\u30c3\u30b7\u30e5 ( http://blog.livedoor.jp/dankogai/archives/51853853.html )\nimport algorithm,tables,hashes,math\nimport sets,lists,critbits,sequtils,queues,intsets,strutils\nblock:\n  var r: CritBitTree[string]\n  r[\"abc\"] = \"ABC\"\n  r[\"def\"] = \"DEF\"\n  echo \"tree=>\",r.contains(\"abc\")\n  for x in r.keys :\n    echo \"key=>\",x\n  for k,v in r :\n    echo \"key=>\",k,\" val=>\",v\n\n(stdout)\ntree=>true\nkey=>abc\nkey=>def\nkey=>abc val=>ABC\nkey=>def val=>DEF\n\n\nintsets\nimport algorithm,tables,hashes,math\nimport sets,lists,critbits,sequtils,queues,intsets,strutils\nblock:\n  var intSet: IntSet = initIntSet()\n  # \u30ad\u30fc\u3092\u8ffd\u52a0\n  intSet.incl 1\n  intSet.incl 2\n  # \u30c0\u30f3\u30d7\n  echo intSet\n  for x in intSet.items :\n    echo \"key=>\",x\n  # \u683c\u7d0d\u3055\u308c\u3066\u3044\u308b\u304b\uff1f\n  echo \"contains(1)=>\",intSet.contains(1)\n  intSet.excl 1\n  echo \"contains(1)=>\",intSet.contains(1)\n  # containsOrIncl\u3092\u8a66\u3059\n  echo \"contains(3)=>\",intSet.contains(3)\n  echo \"           =>\",intSet.containsOrIncl(3)\n  echo \"contains(3)=>\",intSet.contains(3)\n\n(stdout)\n{1, 2}\nkey=>1\nkey=>2\ncontains(1)=>true\ncontains(1)=>false\ncontains(3)=>false\n           =>false\ncontains(3)=>true\n\n\nsequtils.concat\nimport algorithm,tables,hashes,math\nimport sets,lists,critbits,sequtils,queues,intsets,strutils\nblock:\n  # \u30b5\u30f3\u30d7\u30eb\u306e\u307e\u3093\u307e\n  let\n    s1 = @[1, 2, 3]\n    s2 = @[4, 5]\n    s3 = @[6, 7]\n    total = concat(s1, s2, s3)\n  echo total\n\n(stdout)\n@[1, 2, 3, 4, 5, 6, 7]\n\n\nsequtils.cycle\nimport algorithm,tables,hashes,math\nimport sets,lists,critbits,sequtils,queues,intsets,strutils\nblock:\n  let\n    s = @[1, 2, 3]\n    total = s.cycle(3)\n  echo total\n\n(stdout)\n@[1, 2, 3, 1, 2, 3, 1, 2, 3]\n\n\nsequtils.repeat\nimport algorithm,tables,hashes,math\nimport sets,lists,critbits,sequtils,queues,intsets,strutils\nblock:\n  let\n    total1 = repeat(5, 3)\n    total2 = repeat(@[1,2,3], 3)\n  echo \"total1=>\",total1\n  echo \"total2=>\",total2\n\n(stdout)\ntotal1=>@[5, 5, 5]\ntotal2=>@[@[1, 2, 3], @[1, 2, 3], @[1, 2, 3]]\n\n\nsequtils.deduplicate\nimport algorithm,tables,hashes,math\nimport sets,lists,critbits,sequtils,queues,intsets,strutils\nblock:\n  let\n    dup1 = @[1, 1, 3, 4, 2, 2, 8, 1, 4]\n    dup2 = @[\"a\", \"a\", \"c\", \"d\", \"d\"]\n    unique1 = deduplicate(dup1)\n    unique2 = deduplicate(dup2)\n  echo \"unique1=>\",unique1\n  echo \"unique2=>\",unique2\n\n(stdout)\nunique1=>@[1, 3, 4, 2, 8]\nunique2=>@[a, c, d]\n\n\nsequtils.zip\nimport algorithm,tables,hashes,math\nimport sets,lists,critbits,sequtils,queues,intsets,strutils\nblock:\n  let\n    short = @[1, 2, 3]\n    long = @[6, 5, 4, 3, 2, 1]\n    words = @[\"one\", \"two\", \"three\"]\n    zip1 = zip(short, long)\n    zip2 = zip(short, words)\n  echo \"zip1=>\", zip1\n  echo \"zip2=>\", zip2\n  echo \"zip1[2].b=>\", zip1[2].b\n  echo \"zip2[2].b=>\", zip2[2].b\n\n(stdout)\nzip1=>@[(a: 1, b: 6), (a: 2, b: 5), (a: 3, b: 4)]\nzip2=>@[(a: 1, b: one), (a: 2, b: two), (a: 3, b: three)]\nzip1[2].b=>4\nzip2[2].b=>three\n\n\nsequtils.distribute\nimport algorithm,tables,hashes,math\nimport sets,lists,critbits,sequtils,queues,intsets,strutils\nblock:\n  let numbers = @[1, 2, 3, 4, 5, 6, 7]\n  echo \"(2      )=>\",numbers.distribute(2)\n  echo \"(2,false)=>\",numbers.distribute(2, false)\n  echo \"(3      )=>\",numbers.distribute(3)\n  echo \"(3,false)=>\",numbers.distribute(3, false)\n  echo \"(4      )=>\",numbers.distribute(4)\n  echo \"(4,false)=>\",numbers.distribute(4, false)\n  echo \"(5      )=>\",numbers.distribute(5)\n  echo \"(5,false)=>\",numbers.distribute(5, false)\n  echo \"(6      )=>\",numbers.distribute(6)\n  echo \"(6,false)=>\",numbers.distribute(6, false)\n\n(stdout)\n(2      )=>@[@[1, 2, 3, 4], @[5, 6, 7]]\n(2,false)=>@[@[1, 2, 3, 4], @[5, 6, 7]]\n(3      )=>@[@[1, 2, 3], @[4, 5], @[6, 7]]\n(3,false)=>@[@[1, 2, 3], @[4, 5, 6], @[7]]\n(4      )=>@[@[1, 2], @[3, 4], @[5, 6], @[7]]\n(4,false)=>@[@[1, 2], @[3, 4], @[5, 6], @[7]]\n(5      )=>@[@[1, 2], @[3, 4], @[5], @[6], @[7]]\n(5,false)=>@[@[1, 2], @[3, 4], @[5, 6], @[7], @[]]\n(6      )=>@[@[1, 2], @[3], @[4], @[5], @[6], @[7]]\n(6,false)=>@[@[1, 2], @[3, 4], @[5, 6], @[7], @[], @[]]\n\n\nsequtils.map\nimport algorithm,tables,hashes,math\nimport sets,lists,critbits,sequtils,queues,intsets,strutils\nblock:\n  let\n    a = @[1, 2, 3, 4]\n    b = map(a, proc(x: int): string = $x)\n    c = a.map do (x:int) -> string : $(x+1)\n  echo \"b=>\",b\n  echo \"c=>\",c\n\n(stdout)\nb=>@[1, 2, 3, 4]\nc=>@[2, 3, 4, 5]\n\n\nsequtils.apply(var \u5f15\u6570\u304c\u6e21\u3055\u308c\u308b) deprecated\u3089\u3057\u3044\u3067\u3059\u3002\nimport algorithm,tables,hashes,math\nimport sets,lists,critbits,sequtils,queues,intsets,strutils\nblock:\n  var a = @[\"1\", \"2\", \"3\", \"4\"]\n  echo a\n  map(a, proc(x: var string) = x &= \"42\")\n  echo a\n\n(stdout)\n@[1, 2, 3, 4]\n@[142, 242, 342, 442]\n\n\nsequtils.filter\nimport algorithm,tables,hashes,math\nimport sets,lists,critbits,sequtils,queues,intsets,strutils\nblock:\n  let\n    colors = @[\"red\", \"yellow\", \"black\"]\n    f1 = filter(colors, proc(x: string) : bool = x.len < 6)\n    f2 = filter(colors) do (x: string) -> bool : x.len > 5\n  echo \"f1=>\",f1\n  echo \"f2=>\",f2\n  echo \"abc\".startsWith(\"a\")\n  let f3 = colors.map(\n    proc(x:string)  : string = x & \" is color\"\n  ).filter(\n    proc (x:string) : bool = x.find(\"black\") != -1\n  )\n  echo f3\n\n(stdout)\nf1=>@[red, black]\nf2=>@[yellow]\ntrue\n@[black is color]\n\n\nsequtils.keepIf\nimport algorithm,tables,hashes,math\nimport sets,lists,critbits,sequtils,queues,intsets,strutils\nblock:\n  var floats = @[13.0, 12.5, 5.8, 2.0, 6.1, 9.9, 10.1]\n  keepIf(floats, proc(x: float): bool = x > 10)\n  echo \"floats=>\",floats\n\n(stdout)\nfloats=>@[13.0, 12.5, 10.1]\n\n\nsequtils.delete\nimport algorithm,tables,hashes,math\nimport sets,lists,critbits,sequtils,queues,intsets,strutils\nblock:\n  let outcome = @[1,1,1,1,1,1,1,1]\n  var dest = @[1,1,1,2,2,2,2,2,2,1,1,1,1,1]\n  dest.delete(3, 8)\n  echo \"outcom=>\",outcome\n\n(stdout)\noutcom=>@[1, 1, 1, 1, 1, 1, 1, 1]\n\n\nsequtils.insert\nimport algorithm,tables,hashes,math\nimport sets,lists,critbits,sequtils,queues,intsets,strutils\nblock:\n  var dest = @[1,1,1,1,1,1,1,1]\n  let\n    src = @[2,2,2,2,2,2]\n    outcome = @[1,1,1,2,2,2,2,2,2,1,1,1,1,1]\n  dest.insert(src, 3)\n  echo \"dest=>\",dest\n\n(stdout)\ndest=>@[1, 1, 1, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1]\n\n\nsequtils.all \u3059\u3079\u3066\u306e\u8981\u7d20\u306b\u305f\u3044\u3057\u3066\u6761\u4ef6\u3092\u6e80\u305f\u3059\u304b\u3069\u3046\u304b\u3092\u30c1\u30a7\u30c3\u30af\nimport algorithm,tables,hashes,math\nimport sets,lists,critbits,sequtils,queues,intsets,strutils\nblock:\n  let numbers = @[1, 4, 5, 8, 9, 7, 4]\n  echo all(numbers, proc (x: int): bool = return x < 10)\n  echo all(numbers, proc (x: int): bool = return x < 9)\n\n(stdout)\ntrue\nfalse\n\n\nsequtils.any \u3069\u308c\u304b\uff11\u3064\u306e\u8981\u7d20\u306b\u305f\u3044\u3057\u3066\u6761\u4ef6\u3092\u6e80\u305f\u3059\u304b\u3069\u3046\u304b\u3092\u30c1\u30a7\u30c3\u30af\nimport algorithm,tables,hashes,math\nimport sets,lists,critbits,sequtils,queues,intsets,strutils\nblock:\n  let numbers = @[1, 4, 5, 8, 9, 7, 4]\n  echo any(numbers, proc (x: int): bool = return x < 10)\n  echo any(numbers, proc (x: int): bool = return x > 9)\n## sequtils \u30de\u30af\u30ed\n\n(stdout)\ntrue\nfalse\n\n\nfilterIt\nimport algorithm,tables,hashes,math\nimport sets,lists,critbits,sequtils,queues,intsets,strutils\nblock:\n  let\n    temperatures = @[-272.15, -2.0, 24.5, 44.31, 99.9, -113.44]\n    acceptable = filterIt(temperatures, it < 50 and it > -10)\n    notAcceptable = filterIt(temperatures, it > 50 or it < -10)\n  echo \"acceptable   =>\",acceptable\n  echo \"notAcceptable=>\",notAcceptable\n\n(stdout)\nacceptable   =>@[-2.0, 24.5, 44.31]\nnotAcceptable=>@[-272.15, 99.90000000000001, -113.44]\n\n\nkeepIfIf\nimport algorithm,tables,hashes,math\nimport sets,lists,critbits,sequtils,queues,intsets,strutils\nblock:\n  var candidates = @[\"foo\", \"bar\", \"baz\", \"foobar\"]\n  keepItIf(candidates, it.len == 3 and it[0] == 'b')\n  echo \"candidates=>\",candidates\n\n(stdout)\ncandidates=>@[bar, baz]\n\n\nallIt\nimport algorithm,tables,hashes,math\nimport sets,lists,critbits,sequtils,queues,intsets,strutils\nblock:\n  let numbers = @[1, 4, 5, 8, 9, 7, 4]\n  echo \"numbers=>\",allIt(numbers, it < 10)\n  echo \"numbers=>\",allIt(numbers, it < 9)\n\n(stdout)\nnumbers=>true\nnumbers=>false\n\n\nanyIt\nimport algorithm,tables,hashes,math\nimport sets,lists,critbits,sequtils,queues,intsets,strutils\nblock:\n  let numbers = @[1, 4, 5, 8, 9, 7, 4]\n  echo \"numbers=>\",anyIt(numbers, it > 8)\n  echo \"numbers=>\",anyIt(numbers, it > 9)\n\n(stdout)\nnumbers=>true\nnumbers=>false\n\n\ntoSeq\nimport algorithm,tables,hashes,math\nimport sets,lists,critbits,sequtils,queues,intsets,strutils\nblock:\n  let\n    numeric = @[1, 2, 3, 4, 5, 6, 7, 8, 9]\n    odd_numbers = toSeq(filter(numeric) do (x: int) -> bool:\n      if x mod 2 == 1:\n        result = true)\n  echo \"odd_numbers\", odd_numbers\n\n(stdout)\nodd_numbers@[1, 3, 5, 7, 9]\n\n\nfoldl\nimport algorithm,tables,hashes,math\nimport sets,lists,critbits,sequtils,queues,intsets,strutils\nblock:\n  let\n    numbers = @[5, 9, 11]\n    addition = foldl(numbers, a + b)\n    subtraction = foldl(numbers, a - b)\n    multiplication = foldl(numbers, a * b)\n    words = @[\"nim\", \"is\", \"cool\"]\n    concatenation = foldl(words, a & b)\n  echo addition , \" Addition is (((5)+9)+11)\"\n  echo subtraction  , \" Subtraction is (((5)-9)-11)\"\n  echo multiplication , \" Multiplication is (((5)*9)*11)\"\n  echo concatenation\n\n(stdout)\n25 Addition is (((5)+9)+11)\n-15 Subtraction is (((5)-9)-11)\n495 Multiplication is (((5)*9)*11)\nnimiscool\n\n\nfoldl \u521d\u671f\u5024\u3042\u308a\nimport algorithm,tables,hashes,math\nimport sets,lists,critbits,sequtils,queues,intsets,strutils\nblock:\n  let\n    numbers = @[0, 8, 1, 5]\n    digits = foldl(numbers, a & (chr(b + ord('0'))), \"\")\n  echo digits\n\n(stdout)\n\n\nfoldr\nimport algorithm,tables,hashes,math\nimport sets,lists,critbits,sequtils,queues,intsets,strutils\nblock:\n  let\n    numbers = @[5, 9, 11]\n    addition = foldr(numbers, a + b)\n    subtraction = foldr(numbers, a - b)\n    multiplication = foldr(numbers, a * b)\n    words = @[\"nim\", \"is\", \"cool\"]\n    concatenation = foldr(words, a & b)\n  echo addition , \" Addition is (5+(9+(11)))\"\n  echo subtraction , \" Subtraction is (5-(9-(11)))\"\n  echo multiplication, \" Multiplication is (5*(9*(11)))\"\n  echo concatenation\n\n(stdout)\n25 Addition is (5+(9+(11)))\n7 Subtraction is (5-(9-(11)))\n495 Multiplication is (5*(9*(11)))\nnimiscool\n\n\nmapIt\nimport algorithm,tables,hashes,math\nimport sets,lists,critbits,sequtils,queues,intsets,strutils\nblock:\n  let\n    nums = @[1, 2, 3, 4]\n    strings = nums.mapIt(4 * it)\n  echo \"strings=>\",strings\n\n(stdout)\nstrings=>@[4, 8, 12, 16]\n\n\nmapIt\nimport algorithm,tables,hashes,math\nimport sets,lists,critbits,sequtils,queues,intsets,strutils\nblock:\n  let\n    nums = @[1, 2, 3, 4]\n    strings = nums.mapIt(4 * it)\n  echo \"strings=>\",strings\n\n(stdout)\nstrings=>@[4, 8, 12, 16]\n\n\napplyIt(\u81ea\u5206\u81ea\u8eab\u306b\u9069\u7528)\nimport algorithm,tables,hashes,math\nimport sets,lists,critbits,sequtils,queues,intsets,strutils\nblock:\n  var nums = @[1, 2, 3, 4]\n  nums.applyIt(it * 3)\n  echo nums[0] + nums[3]\n\n(stdout)\n15\n\n\nnewSeqWith\nimport algorithm,tables,hashes,math\nimport sets,lists,critbits,sequtils,queues,intsets,strutils\nimport random\nblock:\n  var seq2D = newSeqWith(4, newSeq[bool](4))\n  seq2D[0][0] = true\n  seq2D[1][0] = true\n  seq2D[0][1] = true\n  echo seq2D\n  var seqRand = newSeqWith(4, random(4))\n  echo seqRand\n\n(stdout)\n\n# \u6982\u8981\nnim\u306e\u30b3\u30ec\u30af\u30b7\u30e7\u30f3\u64cd\u4f5c\u3092\u30b3\u30c4\u30b3\u30c4\u3068\u3002\n* algorithm\n* tables\n* sets\n* lists\n* queues\n* critbits\n* intsets\n## \u4ee5\u4e0b\u30e1\u30e2\n### \u540c\u3058\u5024\u3067\u57cb\u3081\u308b(fill)\n```nim\nimport algorithm,tables,hashes,math\nimport sets,lists,critbits,sequtils,queues,intsets,strutils\nblock:\n  var ary : array[0..3,int]\n  # \u7bc4\u56f2\u6307\u5b9a\u306a\u3057\n  fill(ary,1)\n  for x in ary:\n    echo x\n  # \u7bc4\u56f2\u6307\u5b9a\n  fill(ary,0,3,5)\n  for x in ary:\n    echo x\n```\n```\n(stdout)\n1\n1\n1\n1\n5\n5\n5\n5\n```\n### \u30ea\u30d0\u30fc\u30b9\n```nim\nimport algorithm,tables,hashes,math\nimport sets,lists,critbits,sequtils,queues,intsets,strutils\nblock:\n  var ary = @[1,2,3,4]\n  echo ary\n  ary.reverse\n  echo ary\n  var ary2 = ary.reversed\n  echo ary2\n```\n```\n(stdout)\n@[1, 2, 3, 4]\n@[4, 3, 2, 1]\n@[1, 2, 3, 4]\n```\n### \u691c\u7d22(\u30d0\u30a4\u30ca\u30ea\u30b5\u30fc\u30c1)\n```nim\nimport algorithm,tables,hashes,math\nimport sets,lists,critbits,sequtils,queues,intsets,strutils\nblock:\n  var ary = @[1,2,3,4,5,6,7,8,9]\n  echo ary.binarySearch(8)\n  echo ary.smartBinarySearch(3)\n```\n```\n(stdout)\n7\n2\n```\n### lowerBound\n```nim\nimport algorithm,tables,hashes,math\nimport sets,lists,critbits,sequtils,queues,intsets,strutils\nblock:\n  var ary = @[1,2,3,4,5,6]\n  for x in 0..10 :\n    echo x,\" \",ary.lowerBound(x)\n```\n```\n(stdout)\n0 0\n1 0\n2 1\n3 2\n4 3\n5 4\n6 5\n7 6\n8 6\n9 6\n10 6\n```\n### \u30bd\u30fc\u30c8\n```nim\nimport algorithm,tables,hashes,math\nimport sets,lists,critbits,sequtils,queues,intsets,strutils\nblock:\n  # cmp\u95a2\u6570\u3067\u30bd\u30fc\u30c8\n  var ary = @[3,4,1,8,6,5,7,0,1]\n  echo ary\n  ary.sort(system.cmp[int])\n  echo ary\n```\n```\n(stdout)\n@[3, 4, 1, 8, 6, 5, 7, 0, 1]\n@[0, 1, 1, 3, 4, 5, 6, 7, 8]\n```\n### \u30bd\u30fc\u30c8(proc\u3092\u6e21\u3059)\n```nim\nimport algorithm,tables,hashes,math\nimport sets,lists,critbits,sequtils,queues,intsets,strutils\nblock:\n  var ary = @[3,4,1,8,6,5,7,0,1]\n  ary.sort( proc (x,y:int) : int = cmp(x,y) )\n  echo ary\n```\n```\n(stdout)\n@[0, 1, 1, 3, 4, 5, 6, 7, 8]\n```\n### \u30bd\u30fc\u30c8(do\u3092\u4f7f\u3063\u305f\u30bd\u30fc\u30c8)\n```nim\nimport algorithm,tables,hashes,math\nimport sets,lists,critbits,sequtils,queues,intsets,strutils\nblock:\n  var ary = @[3,4,1,8,6,5,7,0,1]\n  ary.sort do (x,y:int) -> int : result = cmp(x,y)\n  echo ary\n```\n```\n(stdout)\n@[0, 1, 1, 3, 4, 5, 6, 7, 8]\n```\n### \u30bd\u30fc\u30c8(sorted)\n```nim\nimport algorithm,tables,hashes,math\nimport sets,lists,critbits,sequtils,queues,intsets,strutils\nblock:\n  # do\u3092\u4f7f\u3063\u305f\u30bd\u30fc\u30c8\n  var ary = @[3,4,1,8,6,5,7,0,1]\n  var ary2 = ary.sorted do (x,y:int) -> int :\n    result = cmp(x,y)\n  echo \"original=\",ary\n  echo \"sorted  =\",ary2\n  echo ary.isSorted(system.cmp[int])\n  echo ary2.isSorted(system.cmp[int])\n```\n```\n(stdout)\noriginal=@[3, 4, 1, 8, 6, 5, 7, 0, 1]\nsorted  =@[0, 1, 1, 3, 4, 5, 6, 7, 8]\nfalse\ntrue\n```\n### \u9806\u5217 (prevPermutation)\n```nim\nimport algorithm,tables,hashes,math\nimport sets,lists,critbits,sequtils,queues,intsets,strutils\nblock:\n  var ary = @[1,2,4,3]\n  ary.prevPermutation\n  echo ary\n```\n```\n(stdout)\n@[1, 2, 3, 4]\n```\n### template\u3092\u4f7f\u3063\u305f\u30bd\u30fc\u30c8\n```nim\nimport algorithm,tables,hashes,math\nimport sets,lists,critbits,sequtils,queues,intsets,strutils\nblock:\n  var ary = @[3,4,1,8,6,5,7,0,1]\n  echo ary.sortedByIt(it)\n```\n```\n(stdout)\n@[0, 1, 1, 3, 4, 5, 6, 7, 8]\n```\n### hashes\u306b\u3088\u308b\u30cf\u30c3\u30b7\u30e5\u3092\u53d6\u5f97\n```nim\nimport algorithm,tables,hashes,math\nimport sets,lists,critbits,sequtils,queues,intsets,strutils\nblock:\n  var name1 = \"Mr.\u30b9\u30dd\u30c3\u30af\"\n  var name2 = \"Mr.\u30b9\u30dd\u30c3\u30af\"\n  echo name1.hash == name2.hash\n```\n```\n(stdout)\ntrue\n```\n### tables \u30b5\u30f3\u30d7\u30eb\n```nim\nimport algorithm,tables,hashes,math\nimport sets,lists,critbits,sequtils,queues,intsets,strutils\n#[\ntable\u306f\u3001\u30cf\u30c3\u30b7\u30e5\u30ad\u30fc\u3092\u62e1\u5f35\u3057\u305f\u3082\u306e\u3063\u307d\u3044\u3067\u3059\u3002\n\u72ec\u81ea\u69cb\u9020\u4f53\uff1f\u3092\u30ad\u30fc\u306b\u3059\u308b\u5834\u5408\u306f\u3001hash\u95a2\u6570\u3092\u5b9f\u88c5\u3057\u306a\u3044\u3068\u52d5\u4f5c\u3057\u306a\u3044\u3088\u3046\u3067\u3059\u3002\n]#\ntype\n  Person = object\n    firstName, lastName: string\nproc hash(x: Person): Hash =\n  ## Piggyback on the already available string hash proc.\n  ##\n  ## Without this proc nothing works!\n  result = x.firstName.hash !& x.lastName.hash\n  result = !$result\nproc `$`(x: Person) : string =\n  result = x.firstName\nblock:\n  var\n    salaries: Table[Person,int] = initTable[Person, int]()\n    p1, p2, p3: Person\n  p1.firstName = \"Steven\"\n  p1.lastName = \"Rogers\"\n  salaries[p1] = 30_000\n  p2.firstName = \"Tony\"\n  p2.lastName = \"Stark\"\n  salaries[p2] = 40_000\n  p3.firstName = \"Bruce\"\n  p3.lastName = \"Banner\"\n  echo \"contains=\",salaries.contains(p1)\n  echo \"get value=\",salaries[p1]\n  echo \"length=\",salaries.len\n  echo \"get or default=\", salaries.getOrDefault(p3)\n  ### toTable\u3092\u4f7f\u3063\u305f\u521d\u671f\u5316\n  let salaries2: Table[Person,int] = {p1:30_000,p2:40_000}.toTable\n  echo salaries == salaries2\n  #salaries2[p3] = 10_000\n  let salaries3: OrderedTable[Person,int] = {p1:30_000,p2:40_000}.toOrderedTable\n  for k,v in salaries :\n    echo k\n  for k,v in salaries2 :\n    echo k\n  for k,v in salaries3 :\n    echo k\n```\n```\n(stdout)\ncontains=true\nget value=30000\nlength=2\nget or default=0\ntrue\nSteven\nTony\nSteven\nTony\nSteven\nTony\n```\n### COuntTable\u3000\u30ad\u30fc\u306e\u307f\u3067\u3001\u305d\u306e\u6570\u3092\u30ab\u30a6\u30f3\u30c8\u3059\u308b\n```nim\nimport algorithm,tables,hashes,math\nimport sets,lists,critbits,sequtils,queues,intsets,strutils\nblock:\n  var count = initCountTable[string]()\n  count.inc(\"DEC\")\n  count.inc(\"DEC\")\n  count.inc(\"ABC\")\n  count.inc(\"ABC\")\n  count.inc(\"ABC\")\n  echo count\n  count.sort\n  echo count\n```\n```\n(stdout)\n{ABC: 3, DEC: 2}\n{ABC: 3, DEC: 2}\n```\n### HashSet\n```nim\nimport algorithm,tables,hashes,math\nimport sets,lists,critbits,sequtils,queues,intsets,strutils\nblock:\n  # initSet\u3067\u521d\u671f\u5316\n  var hashSet1: HashSet[string] = initSet[string]()\n  hashSet1.incl(\"key1\")\n  hashSet1.incl(\"key2\")\n  echo \"hashSet1=>\",hashSet1\n  echo \"contains=>\",hashSet1.contains(\"key1\")\n  # \u53d6\u308a\u9664\u304f\n  hashSet1.excl(\"key1\")\n  hashSet1.excl(\"key2\")\n  echo \"hashSet1=>\",hashSet1\n  # \u518d\u3073\u8ffd\u52a0\n  hashSet1.incl(\"key1\")\n  hashSet1.incl(\"key2\")\n  # toSet\u3067\u521d\u671f\u5316\n  var hashSet2 = [\"key1\",\"key2\"].toSet\n  echo \"hashSet2=>\",hashSet2\n  echo \"equals  =>\",hashSet1 == hashSet2\n  for x in hashSet1.items :\n    echo \"item=>\",x\n```\n```\n(stdout)\nhashSet1=>{key2, key1}\ncontains=>true\nhashSet1=>{}\nhashSet2=>{key2, key1}\nequals  =>true\nitem=>key2\nitem=>key1\n```\n### OrderedHashSet(\u5024\u3092\u8ffd\u52a0\u3057\u305f\u9806\u756a\u3092\u4fdd\u6301)\n```nim\nimport algorithm,tables,hashes,math\nimport sets,lists,critbits,sequtils,queues,intsets,strutils\nblock:\n  # initOrderedSet\u3067\u521d\u671f\u5316\n  var hashSet1: OrderedSet[string] = initOrderedSet[string]()\n  hashSet1.incl(\"key1\")\n  hashSet1.incl(\"key2\")\n  echo \"hashSet1=>\",hashSet1\n  # toOrderedSet\u3067\u521d\u671f\u5316\n  var hashSet2: OrderedSet[string] = [\"key1\",\"key2\"].toOrderedSet\n  echo \"hashSet2=>\",hashSet2\n  #echo hashSet1 == hashSet2\n  var hashSet3: OrderedSet[string] = initOrderedSet[string]()\n  hashSet3.incl(\"key1\")\n  hashSet3.incl(\"key2\")\n  echo \"equals=>\",hashSet1 == hashSet3\n```\n```\n(stdout)\nhashSet1=>{key1, key2}\nhashSet2=>{key1, key2}\nequals=>true\n```\n### \u53cc\u65b9\u5411\u30ea\u30f3\u30af\u30ea\u30b9\u30c8\n```nim\nimport algorithm,tables,hashes,math\nimport sets,lists,critbits,sequtils,queues,intsets,strutils\nblock:\n  var list1 : DoublyLinkedList[int] = initDoublyLinkedList[int]()\n  # \u672b\u5c3e\u306b\u8ffd\u52a0\n  list1.append(1)\n  list1.append(2)\n  list1.append(3)\n  list1.append(4)\n  echo \"list1=>\",list1\n  # \u5148\u982d\u306b\u8ffd\u52a0\n  list1.prepend(4)\n  list1.prepend(5)\n  list1.prepend(6)\n  list1.prepend(7)\n  echo \"list1=>\",list1\n  # \u691c\u7d22\n  echo \"find=>\",list1.find(7).value\n  # \u524a\u9664\n  list1.remove(list1.find(7))\n  echo \"list1=>\",list1\n```\n```\n(stdout)\nlist1=>[1, 2, 3, 4]\nlist1=>[7, 6, 5, 4, 1, 2, 3, 4]\nfind=>7\nlist1=>[6, 5, 4, 1, 2, 3, 4]\n```\n### Queue\n```nim\nimport algorithm,tables,hashes,math\nimport sets,lists,critbits,sequtils,queues,intsets,strutils\nblock:\n  var q : Queue[string] = initQueue[string]()\n  q.enqueue(\"abc\")\n  q.add(\"def\")\n  q.add(\"ghi\")\n  echo \"len=>\",q.len\n  echo \"q  =>\",q\n  var v = q.dequeue()\n  echo \"v  =>\",v\n  echo \"q  =>\",q\n  for v in q :\n    echo \"val=>\",v\n  echo \"q  =>\",q\n```\n```\n(stdout)\nlen=>3\nq  =>[abc, def, ghi]\nv  =>abc\nq  =>[def, ghi]\nval=>def\nval=>ghi\nq  =>[def, ghi]\n```\n### Crit-Bit \u30cf\u30c3\u30b7\u30e5 ( http://blog.livedoor.jp/dankogai/archives/51853853.html )\n```nim\nimport algorithm,tables,hashes,math\nimport sets,lists,critbits,sequtils,queues,intsets,strutils\nblock:\n  var r: CritBitTree[string]\n  r[\"abc\"] = \"ABC\"\n  r[\"def\"] = \"DEF\"\n  echo \"tree=>\",r.contains(\"abc\")\n  for x in r.keys :\n    echo \"key=>\",x\n  for k,v in r :\n    echo \"key=>\",k,\" val=>\",v\n```\n```\n(stdout)\ntree=>true\nkey=>abc\nkey=>def\nkey=>abc val=>ABC\nkey=>def val=>DEF\n```\n### intsets\n```nim\nimport algorithm,tables,hashes,math\nimport sets,lists,critbits,sequtils,queues,intsets,strutils\nblock:\n  var intSet: IntSet = initIntSet()\n  # \u30ad\u30fc\u3092\u8ffd\u52a0\n  intSet.incl 1\n  intSet.incl 2\n  # \u30c0\u30f3\u30d7\n  echo intSet\n  for x in intSet.items :\n    echo \"key=>\",x\n  # \u683c\u7d0d\u3055\u308c\u3066\u3044\u308b\u304b\uff1f\n  echo \"contains(1)=>\",intSet.contains(1)\n  intSet.excl 1\n  echo \"contains(1)=>\",intSet.contains(1)\n  # containsOrIncl\u3092\u8a66\u3059\n  echo \"contains(3)=>\",intSet.contains(3)\n  echo \"           =>\",intSet.containsOrIncl(3)\n  echo \"contains(3)=>\",intSet.contains(3)\n```\n```\n(stdout)\n{1, 2}\nkey=>1\nkey=>2\ncontains(1)=>true\ncontains(1)=>false\ncontains(3)=>false\n           =>false\ncontains(3)=>true\n```\n### sequtils.concat\n```nim\nimport algorithm,tables,hashes,math\nimport sets,lists,critbits,sequtils,queues,intsets,strutils\nblock:\n  # \u30b5\u30f3\u30d7\u30eb\u306e\u307e\u3093\u307e\n  let\n    s1 = @[1, 2, 3]\n    s2 = @[4, 5]\n    s3 = @[6, 7]\n    total = concat(s1, s2, s3)\n  echo total\n```\n```\n(stdout)\n@[1, 2, 3, 4, 5, 6, 7]\n```\n### sequtils.cycle\n```nim\nimport algorithm,tables,hashes,math\nimport sets,lists,critbits,sequtils,queues,intsets,strutils\nblock:\n  let\n    s = @[1, 2, 3]\n    total = s.cycle(3)\n  echo total\n```\n```\n(stdout)\n@[1, 2, 3, 1, 2, 3, 1, 2, 3]\n```\n### sequtils.repeat\n```nim\nimport algorithm,tables,hashes,math\nimport sets,lists,critbits,sequtils,queues,intsets,strutils\nblock:\n  let\n    total1 = repeat(5, 3)\n    total2 = repeat(@[1,2,3], 3)\n  echo \"total1=>\",total1\n  echo \"total2=>\",total2\n```\n```\n(stdout)\ntotal1=>@[5, 5, 5]\ntotal2=>@[@[1, 2, 3], @[1, 2, 3], @[1, 2, 3]]\n```\n### sequtils.deduplicate\n```nim\nimport algorithm,tables,hashes,math\nimport sets,lists,critbits,sequtils,queues,intsets,strutils\nblock:\n  let\n    dup1 = @[1, 1, 3, 4, 2, 2, 8, 1, 4]\n    dup2 = @[\"a\", \"a\", \"c\", \"d\", \"d\"]\n    unique1 = deduplicate(dup1)\n    unique2 = deduplicate(dup2)\n  echo \"unique1=>\",unique1\n  echo \"unique2=>\",unique2\n```\n```\n(stdout)\nunique1=>@[1, 3, 4, 2, 8]\nunique2=>@[a, c, d]\n```\n### sequtils.zip\n```nim\nimport algorithm,tables,hashes,math\nimport sets,lists,critbits,sequtils,queues,intsets,strutils\nblock:\n  let\n    short = @[1, 2, 3]\n    long = @[6, 5, 4, 3, 2, 1]\n    words = @[\"one\", \"two\", \"three\"]\n    zip1 = zip(short, long)\n    zip2 = zip(short, words)\n  echo \"zip1=>\", zip1\n  echo \"zip2=>\", zip2\n  echo \"zip1[2].b=>\", zip1[2].b\n  echo \"zip2[2].b=>\", zip2[2].b\n```\n```\n(stdout)\nzip1=>@[(a: 1, b: 6), (a: 2, b: 5), (a: 3, b: 4)]\nzip2=>@[(a: 1, b: one), (a: 2, b: two), (a: 3, b: three)]\nzip1[2].b=>4\nzip2[2].b=>three\n```\n### sequtils.distribute\n```nim\nimport algorithm,tables,hashes,math\nimport sets,lists,critbits,sequtils,queues,intsets,strutils\nblock:\n  let numbers = @[1, 2, 3, 4, 5, 6, 7]\n  echo \"(2      )=>\",numbers.distribute(2)\n  echo \"(2,false)=>\",numbers.distribute(2, false)\n  echo \"(3      )=>\",numbers.distribute(3)\n  echo \"(3,false)=>\",numbers.distribute(3, false)\n  echo \"(4      )=>\",numbers.distribute(4)\n  echo \"(4,false)=>\",numbers.distribute(4, false)\n  echo \"(5      )=>\",numbers.distribute(5)\n  echo \"(5,false)=>\",numbers.distribute(5, false)\n  echo \"(6      )=>\",numbers.distribute(6)\n  echo \"(6,false)=>\",numbers.distribute(6, false)\n```\n```\n(stdout)\n(2      )=>@[@[1, 2, 3, 4], @[5, 6, 7]]\n(2,false)=>@[@[1, 2, 3, 4], @[5, 6, 7]]\n(3      )=>@[@[1, 2, 3], @[4, 5], @[6, 7]]\n(3,false)=>@[@[1, 2, 3], @[4, 5, 6], @[7]]\n(4      )=>@[@[1, 2], @[3, 4], @[5, 6], @[7]]\n(4,false)=>@[@[1, 2], @[3, 4], @[5, 6], @[7]]\n(5      )=>@[@[1, 2], @[3, 4], @[5], @[6], @[7]]\n(5,false)=>@[@[1, 2], @[3, 4], @[5, 6], @[7], @[]]\n(6      )=>@[@[1, 2], @[3], @[4], @[5], @[6], @[7]]\n(6,false)=>@[@[1, 2], @[3, 4], @[5, 6], @[7], @[], @[]]\n```\n### sequtils.map\n```nim\nimport algorithm,tables,hashes,math\nimport sets,lists,critbits,sequtils,queues,intsets,strutils\nblock:\n  let\n    a = @[1, 2, 3, 4]\n    b = map(a, proc(x: int): string = $x)\n    c = a.map do (x:int) -> string : $(x+1)\n  echo \"b=>\",b\n  echo \"c=>\",c\n```\n```\n(stdout)\nb=>@[1, 2, 3, 4]\nc=>@[2, 3, 4, 5]\n```\n### sequtils.apply(var \u5f15\u6570\u304c\u6e21\u3055\u308c\u308b) deprecated\u3089\u3057\u3044\u3067\u3059\u3002\n```nim\nimport algorithm,tables,hashes,math\nimport sets,lists,critbits,sequtils,queues,intsets,strutils\nblock:\n  var a = @[\"1\", \"2\", \"3\", \"4\"]\n  echo a\n  map(a, proc(x: var string) = x &= \"42\")\n  echo a\n```\n```\n(stdout)\n@[1, 2, 3, 4]\n@[142, 242, 342, 442]\n```\n### sequtils.filter\n```nim\nimport algorithm,tables,hashes,math\nimport sets,lists,critbits,sequtils,queues,intsets,strutils\nblock:\n  let\n    colors = @[\"red\", \"yellow\", \"black\"]\n    f1 = filter(colors, proc(x: string) : bool = x.len < 6)\n    f2 = filter(colors) do (x: string) -> bool : x.len > 5\n  echo \"f1=>\",f1\n  echo \"f2=>\",f2\n  echo \"abc\".startsWith(\"a\")\n  let f3 = colors.map(\n    proc(x:string)  : string = x & \" is color\"\n  ).filter(\n    proc (x:string) : bool = x.find(\"black\") != -1\n  )\n  echo f3\n```\n```\n(stdout)\nf1=>@[red, black]\nf2=>@[yellow]\ntrue\n@[black is color]\n```\n### sequtils.keepIf\n```nim\nimport algorithm,tables,hashes,math\nimport sets,lists,critbits,sequtils,queues,intsets,strutils\nblock:\n  var floats = @[13.0, 12.5, 5.8, 2.0, 6.1, 9.9, 10.1]\n  keepIf(floats, proc(x: float): bool = x > 10)\n  echo \"floats=>\",floats\n```\n```\n(stdout)\nfloats=>@[13.0, 12.5, 10.1]\n```\n### sequtils.delete\n```nim\nimport algorithm,tables,hashes,math\nimport sets,lists,critbits,sequtils,queues,intsets,strutils\nblock:\n  let outcome = @[1,1,1,1,1,1,1,1]\n  var dest = @[1,1,1,2,2,2,2,2,2,1,1,1,1,1]\n  dest.delete(3, 8)\n  echo \"outcom=>\",outcome\n```\n```\n(stdout)\noutcom=>@[1, 1, 1, 1, 1, 1, 1, 1]\n```\n### sequtils.insert\n```nim\nimport algorithm,tables,hashes,math\nimport sets,lists,critbits,sequtils,queues,intsets,strutils\nblock:\n  var dest = @[1,1,1,1,1,1,1,1]\n  let\n    src = @[2,2,2,2,2,2]\n    outcome = @[1,1,1,2,2,2,2,2,2,1,1,1,1,1]\n  dest.insert(src, 3)\n  echo \"dest=>\",dest\n```\n```\n(stdout)\ndest=>@[1, 1, 1, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1]\n```\n### sequtils.all \u3059\u3079\u3066\u306e\u8981\u7d20\u306b\u305f\u3044\u3057\u3066\u6761\u4ef6\u3092\u6e80\u305f\u3059\u304b\u3069\u3046\u304b\u3092\u30c1\u30a7\u30c3\u30af\n```nim\nimport algorithm,tables,hashes,math\nimport sets,lists,critbits,sequtils,queues,intsets,strutils\nblock:\n  let numbers = @[1, 4, 5, 8, 9, 7, 4]\n  echo all(numbers, proc (x: int): bool = return x < 10)\n  echo all(numbers, proc (x: int): bool = return x < 9)\n```\n```\n(stdout)\ntrue\nfalse\n```\n### sequtils.any \u3069\u308c\u304b\uff11\u3064\u306e\u8981\u7d20\u306b\u305f\u3044\u3057\u3066\u6761\u4ef6\u3092\u6e80\u305f\u3059\u304b\u3069\u3046\u304b\u3092\u30c1\u30a7\u30c3\u30af\n```nim\nimport algorithm,tables,hashes,math\nimport sets,lists,critbits,sequtils,queues,intsets,strutils\nblock:\n  let numbers = @[1, 4, 5, 8, 9, 7, 4]\n  echo any(numbers, proc (x: int): bool = return x < 10)\n  echo any(numbers, proc (x: int): bool = return x > 9)\n## sequtils \u30de\u30af\u30ed\n```\n```\n(stdout)\ntrue\nfalse\n```\n### filterIt\n```nim\nimport algorithm,tables,hashes,math\nimport sets,lists,critbits,sequtils,queues,intsets,strutils\nblock:\n  let\n    temperatures = @[-272.15, -2.0, 24.5, 44.31, 99.9, -113.44]\n    acceptable = filterIt(temperatures, it < 50 and it > -10)\n    notAcceptable = filterIt(temperatures, it > 50 or it < -10)\n  echo \"acceptable   =>\",acceptable\n  echo \"notAcceptable=>\",notAcceptable\n```\n```\n(stdout)\nacceptable   =>@[-2.0, 24.5, 44.31]\nnotAcceptable=>@[-272.15, 99.90000000000001, -113.44]\n```\n### keepIfIf\n```nim\nimport algorithm,tables,hashes,math\nimport sets,lists,critbits,sequtils,queues,intsets,strutils\nblock:\n  var candidates = @[\"foo\", \"bar\", \"baz\", \"foobar\"]\n  keepItIf(candidates, it.len == 3 and it[0] == 'b')\n  echo \"candidates=>\",candidates\n```\n```\n(stdout)\ncandidates=>@[bar, baz]\n```\n### allIt\n```nim\nimport algorithm,tables,hashes,math\nimport sets,lists,critbits,sequtils,queues,intsets,strutils\nblock:\n  let numbers = @[1, 4, 5, 8, 9, 7, 4]\n  echo \"numbers=>\",allIt(numbers, it < 10)\n  echo \"numbers=>\",allIt(numbers, it < 9)\n```\n```\n(stdout)\nnumbers=>true\nnumbers=>false\n```\n### anyIt\n```nim\nimport algorithm,tables,hashes,math\nimport sets,lists,critbits,sequtils,queues,intsets,strutils\nblock:\n  let numbers = @[1, 4, 5, 8, 9, 7, 4]\n  echo \"numbers=>\",anyIt(numbers, it > 8)\n  echo \"numbers=>\",anyIt(numbers, it > 9)\n```\n```\n(stdout)\nnumbers=>true\nnumbers=>false\n```\n### toSeq\n```nim\nimport algorithm,tables,hashes,math\nimport sets,lists,critbits,sequtils,queues,intsets,strutils\nblock:\n  let\n    numeric = @[1, 2, 3, 4, 5, 6, 7, 8, 9]\n    odd_numbers = toSeq(filter(numeric) do (x: int) -> bool:\n      if x mod 2 == 1:\n        result = true)\n  echo \"odd_numbers\", odd_numbers\n```\n```\n(stdout)\nodd_numbers@[1, 3, 5, 7, 9]\n```\n### foldl\n```nim\nimport algorithm,tables,hashes,math\nimport sets,lists,critbits,sequtils,queues,intsets,strutils\nblock:\n  let\n    numbers = @[5, 9, 11]\n    addition = foldl(numbers, a + b)\n    subtraction = foldl(numbers, a - b)\n    multiplication = foldl(numbers, a * b)\n    words = @[\"nim\", \"is\", \"cool\"]\n    concatenation = foldl(words, a & b)\n  echo addition , \" Addition is (((5)+9)+11)\"\n  echo subtraction  , \" Subtraction is (((5)-9)-11)\"\n  echo multiplication , \" Multiplication is (((5)*9)*11)\"\n  echo concatenation\n```\n```\n(stdout)\n25 Addition is (((5)+9)+11)\n-15 Subtraction is (((5)-9)-11)\n495 Multiplication is (((5)*9)*11)\nnimiscool\n```\n### foldl \u521d\u671f\u5024\u3042\u308a\n```nim\nimport algorithm,tables,hashes,math\nimport sets,lists,critbits,sequtils,queues,intsets,strutils\nblock:\n  let\n    numbers = @[0, 8, 1, 5]\n    digits = foldl(numbers, a & (chr(b + ord('0'))), \"\")\n  echo digits\n```\n```\n(stdout)\n```\n### foldr\n```nim\nimport algorithm,tables,hashes,math\nimport sets,lists,critbits,sequtils,queues,intsets,strutils\nblock:\n  let\n    numbers = @[5, 9, 11]\n    addition = foldr(numbers, a + b)\n    subtraction = foldr(numbers, a - b)\n    multiplication = foldr(numbers, a * b)\n    words = @[\"nim\", \"is\", \"cool\"]\n    concatenation = foldr(words, a & b)\n  echo addition , \" Addition is (5+(9+(11)))\"\n  echo subtraction , \" Subtraction is (5-(9-(11)))\"\n  echo multiplication, \" Multiplication is (5*(9*(11)))\"\n  echo concatenation\n```\n```\n(stdout)\n25 Addition is (5+(9+(11)))\n7 Subtraction is (5-(9-(11)))\n495 Multiplication is (5*(9*(11)))\nnimiscool\n```\n### mapIt\n```nim\nimport algorithm,tables,hashes,math\nimport sets,lists,critbits,sequtils,queues,intsets,strutils\nblock:\n  let\n    nums = @[1, 2, 3, 4]\n    strings = nums.mapIt(4 * it)\n  echo \"strings=>\",strings\n```\n```\n(stdout)\nstrings=>@[4, 8, 12, 16]\n```\n### mapIt\n```nim\nimport algorithm,tables,hashes,math\nimport sets,lists,critbits,sequtils,queues,intsets,strutils\nblock:\n  let\n    nums = @[1, 2, 3, 4]\n    strings = nums.mapIt(4 * it)\n  echo \"strings=>\",strings\n```\n```\n(stdout)\nstrings=>@[4, 8, 12, 16]\n```\n### applyIt(\u81ea\u5206\u81ea\u8eab\u306b\u9069\u7528)\n```nim\nimport algorithm,tables,hashes,math\nimport sets,lists,critbits,sequtils,queues,intsets,strutils\nblock:\n  var nums = @[1, 2, 3, 4]\n  nums.applyIt(it * 3)\n  echo nums[0] + nums[3]\n```\n```\n(stdout)\n15\n```\n### newSeqWith\n```nim\nimport algorithm,tables,hashes,math\nimport sets,lists,critbits,sequtils,queues,intsets,strutils\nimport random\nblock:\n  var seq2D = newSeqWith(4, newSeq[bool](4))\n  seq2D[0][0] = true\n  seq2D[1][0] = true\n  seq2D[0][1] = true\n  echo seq2D\n  var seqRand = newSeqWith(4, random(4))\n  echo seqRand\n```\n```\n(stdout)\n```\n", "tags": ["Nim"]}