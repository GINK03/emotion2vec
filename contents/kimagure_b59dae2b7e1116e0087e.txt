{"context": " More than 1 year has passed since last update.Continuing from where we left off in part 2, I want to talk about Pure Render Mixin and \"pure\" components.\n\nPure Render Mixin\nFacebook documentation on this mixin is surprisingly good, check it out here first. The whole code can be seen on Github, and it's pretty nicely simple.\n\nReactComponentWithPureRenderMixin\nshallowEqual\n\nThe main thing you should keep in mind is that if any of the old props/state are not equal to the new props/state i.e. props.myProperty !== newProps.myProperty\nThis works because it uses the lifecycle method ShouldComponentUpdate to return a boolean. If true, React will go ahead and rerun the render method in the component (and, consequently, call on the children to render themselves based on the props passed in).\nYou don't have to bring in the heavy React.addons to use this though, just bring it in specifically. After going through the React publish cycle, the pure render mixin will be exposed through react/lib/ReactComponentWithPureRenderMixin.js, like so:\n/** @jsx React.DOM **/\nvar React = require('react');\nvar ReactComponentWithPureRenderMixin = require('react/lib/ReactComponentWithPureRenderMixin');\n\nmodule.exports = React.createClass({\n  mixin: [ReactComponentWithPureRenderMixin],\n\n  render: function () {\n    return (\n      <td className=\"example-table-element\">\n        {this.props.children}\n      </td>\n    );\n  }\n});\n\nThat's about it, just make sure your component doesn't do anything that makes render not an idempotent function of props and state.\n\nWhat's next?\nPart 4\nNext time, we'll talk about problems with using Pure Render Mixin for computed elements and profiling performance in our application.\n\nContinuing from where we left off in part 2, I want to talk about Pure Render Mixin and \"pure\" components.\n\n\n## Pure Render Mixin\n\nFacebook documentation on this mixin is surprisingly good, check it out [here](http://facebook.github.io/react/docs/pure-render-mixin.html) first. The whole code can be seen on Github, and it's pretty nicely simple.\n\n* [ReactComponentWithPureRenderMixin](https://github.com/facebook/react/blob/5d3b12bb3bd6a092cf00ede07b8255a8399c2e58/src/addons/ReactComponentWithPureRenderMixin.js)\n\n* [shallowEqual](https://github.com/facebook/react/blob/5d3b12bb3bd6a092cf00ede07b8255a8399c2e58/src/utils/shallowEqual.js)\n\nThe main thing you should keep in mind is that if any of the old props/state are not equal to the new props/state i.e. `props.myProperty !== newProps.myProperty`\n\nThis works because it uses the lifecycle method `ShouldComponentUpdate` to return a boolean. If true, React will go ahead and rerun the `render` method in the component (and, consequently, call on the children to render themselves based on the props passed in).\n\nYou don't have to bring in the heavy React.addons to use this though, just bring it in specifically. After going through the React publish cycle, the pure render mixin will be exposed through `react/lib/ReactComponentWithPureRenderMixin.js`, like so:\n\n```js\n/** @jsx React.DOM **/\nvar React = require('react');\nvar ReactComponentWithPureRenderMixin = require('react/lib/ReactComponentWithPureRenderMixin');\n\nmodule.exports = React.createClass({\n  mixin: [ReactComponentWithPureRenderMixin],\n\n  render: function () {\n    return (\n      <td className=\"example-table-element\">\n        {this.props.children}\n      </td>\n    );\n  }\n});\n```\n\nThat's about it, just make sure your component doesn't do anything that makes `render` not an idempotent function of `props` and `state`.\n\n\n## What's next?\n\n[Part 4](http://qiita.com/kimagure/items/ce3e889399f4ac416223)\n\nNext time, we'll talk about problems with using Pure Render Mixin for computed elements and profiling performance in our application.\n", "tags": ["JavaScript", "flux", "reactjs"]}