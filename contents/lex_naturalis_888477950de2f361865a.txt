{"tags": ["Haskell", "\u30ac\u30e9\u30af\u30bf", "\u60c5\u5f31"], "context": " More than 1 year has passed since last update.\u3068\u3044\u3046\u308f\u3051\u3067\u3001\u30e9\u30a4\u30d5\u30fb\u30b2\u30fc\u30e0\u3092Repa\u30e9\u30a4\u30d6\u30e9\u30ea\u3092\u4f7f\u3063\u3066\u66f8\u304d\u306a\u304a\u3057\u3066\u307f\u305f\uff08Repa\u306e\u914d\u5217\u306e\u5b9f\u4f53\u306fData.Vector\u3067\u305d\u308c\u3092\u30e9\u30c3\u30d7\u3057\u3066\u3044\u308b\uff09\u3002\u30c7\u30a3\u30ec\u30a4\u306a\u3057\u3067\u5b9f\u884c\u3059\u308b\u3068\u3001IArray\uff08DiffUArray\uff09\u7248\u3068\u6bd4\u3079\u3066\u3001\u624b\u5143\u306e200*50\u7a0b\u5ea6\u4eee\u60f3\u30bf\u30fc\u30df\u30ca\u30eb\u3067\u6982\u306d\uff14\u301c\uff15\u500d\u306e\u5b9f\u884c\u6642\u9593\u306e\u5dee\u304c\u51fa\u3066\u3044\u308b\u3002\u5f53\u305f\u308a\u524d\u3060\u304c\u3001\u3084\u3063\u3071\u308a\u65e9\u3044\u3002Repa\u306e\u4f7f\u3044\u65b9\u3082\u898b\u3066\u306e\u901a\u308a\uff08\u672c\u683c\u7684\u306a\u884c\u5217\u8a08\u7b97\u3092\u3059\u308b\u306e\u3067\u3082\u306a\u3051\u308c\u3070\uff09\u305d\u308c\u307b\u3069\u96e3\u3057\u3044\u308f\u3051\u3067\u306f\u306a\u3044\u306e\u3067\u3001\u6614\u304b\u3089Haskell\u306b\u3042\u308b\u3068\u306f\u3044\u3048\u3001IArray\u3068\u304b\u4f7f\u3046\u7406\u7531\u306f\u306a\u3055\u305d\u3046\u3060\u3002\n\u4f7f\u7528\u3057\u3066\u3044\u308b\u30e9\u30a4\u30d6\u30e9\u30ea\u306frepa,repa-algorithms,ncurses\u306a\u306e\u3067\u8a66\u3057\u3066\u307f\u305f\u3051\u308c\u3070cabal\u3067\u3053\u308c\u3089\u306e\u30d1\u30c3\u30b1\u30fc\u30b8\u3092\u30a4\u30f3\u30b9\u30c8\u30fc\u30eb\u3057\u3066\u304f\u3060\u3055\u3044\u3002\u4f7f\u3044\u65b9\u306f\u30b3\u30fc\u30c9\u306b\u304b\u304b\u308c\u3066\u3044\u308b\u901a\u308a\uff1a\n./LifeGame 250\n\n\u3067\u30b9\u30c6\u30c3\u30d7\u9593\u306b250ms\u306e\u30b9\u30ea\u30fc\u30d7\u3092\u631f\u3080\u3002\u7d42\u4e86\u3057\u305f\u3044\u3068\u304d\u306fENTER\u30ad\u30fc\u3092\u62bc\u4e0b\u3002\n\nLifeGame_Repa_NCurses.hs\nmodule Main where\n\nimport Control.Monad (forM_)\nimport Control.Monad.IO.Class (liftIO)\nimport Control.Monad.ST (runST)\nimport System.Random (getStdRandom,random)\nimport System.Environment (getArgs)\nimport System.Exit (exitSuccess)\nimport UI.NCurses\nimport qualified Data.Array.Repa as R\nimport Data.Array.Repa.Algorithms.Randomish (randomishIntArray)\n\n\ntype Field = R.Array R.U R.DIM2 Int\n\ninitialize :: (Int,Int) -> IO Field\ninitialize (x,y) = do\n  seed <- getStdRandom random\n  return $ randomishIntArray (R.Z R.:.x R.:.y) 0 1 seed\n\naggregate :: Field -> Field\naggregate f = runST $ do\n  R.computeP $ R.traverse f id (\\ _ sh -> count f sh)   \n\ncount :: Field -> R.DIM2 -> Int\ncount f (R.Z R.:.x R.:.y) = sum $ map\n  (\\(i,j) -> (R.!) f (R.Z R.:.i R.:.j)) $\n  [(i,j)|i<-[x-1,x,x+1],j<-[y-1,y,y+1],0<=i,i<=(xmax-1),0<=j,j<=(ymax-1)]\n    where (R.Z R.:.xmax R.:.ymax) = R.extent f\n\nstep :: Field -> Field\nstep f = runST $ do\n  R.computeP $ R.zipWith survival f (aggregate f)\n    where survival x y = if x == 1 \n           then case y of {3->1; 4->1; _->0;}\n           else case y of {3->1; _->0;}\n\ndrawField :: Field -> Update ()\ndrawField f = do\n let (R.Z R.:. xmax R.:. ymax) = R.extent f\n forM_ [(x,y)|x<-[0..(xmax-1)],y<-[0..(ymax-1)]] $ \\(x,y) -> do\n   moveCursor (fromIntegral x) (fromIntegral y)\n   drawString $ case f R.! (R.Z R.:. x R.:. y) of {1->\"o\";_->\" \";}\n\n\n\nmain :: IO ()\nmain = do\n  [arg] <- getArgs -- \u5f15\u6570\u306f\u753b\u9762\u306e\u66f4\u65b0\u9593\u9694(\u30df\u30ea\u79d2)\n  let delaytime = read arg\n  runCurses $ do\n    (x,y) <- screenSize\n    f <- liftIO $ initialize (fromIntegral (x-1), fromIntegral y)\n    let series = iterate step f\n    setEcho False\n    setCursorMode CursorInvisible\n    cid <- newColorID ColorGreen ColorBlack 1\n    w <- defaultWindow\n    updateWindow w $ setColor cid\n    forM_ series $ \\c -> do \n      updateWindow w $ drawField c\n      render\n      listenTo w delaytime \n        (\\ev -> ev == EventCharacter '\\n') -- Enter\u30ad\u30fc\u62bc\u4e0b\u3067\u7d42\u4e86\n\nlistenTo :: Window -> Int -> (Event -> Bool) -> Curses ()\nlistenTo w n p = do\n  ev <- getEvent w (Just $ fromIntegral n)\n  case ev of\n    Nothing -> return ()\n    Just ev' -> if p ev' then liftIO exitSuccess else return ()\n\n\n\u3068\u3044\u3046\u308f\u3051\u3067\u3001\u30e9\u30a4\u30d5\u30fb\u30b2\u30fc\u30e0\u3092Repa\u30e9\u30a4\u30d6\u30e9\u30ea\u3092\u4f7f\u3063\u3066\u66f8\u304d\u306a\u304a\u3057\u3066\u307f\u305f\uff08Repa\u306e\u914d\u5217\u306e\u5b9f\u4f53\u306fData.Vector\u3067\u305d\u308c\u3092\u30e9\u30c3\u30d7\u3057\u3066\u3044\u308b\uff09\u3002\u30c7\u30a3\u30ec\u30a4\u306a\u3057\u3067\u5b9f\u884c\u3059\u308b\u3068\u3001IArray\uff08DiffUArray\uff09\u7248\u3068\u6bd4\u3079\u3066\u3001\u624b\u5143\u306e200*50\u7a0b\u5ea6\u4eee\u60f3\u30bf\u30fc\u30df\u30ca\u30eb\u3067\u6982\u306d\uff14\u301c\uff15\u500d\u306e\u5b9f\u884c\u6642\u9593\u306e\u5dee\u304c\u51fa\u3066\u3044\u308b\u3002\u5f53\u305f\u308a\u524d\u3060\u304c\u3001\u3084\u3063\u3071\u308a\u65e9\u3044\u3002Repa\u306e\u4f7f\u3044\u65b9\u3082\u898b\u3066\u306e\u901a\u308a\uff08\u672c\u683c\u7684\u306a\u884c\u5217\u8a08\u7b97\u3092\u3059\u308b\u306e\u3067\u3082\u306a\u3051\u308c\u3070\uff09\u305d\u308c\u307b\u3069\u96e3\u3057\u3044\u308f\u3051\u3067\u306f\u306a\u3044\u306e\u3067\u3001\u6614\u304b\u3089Haskell\u306b\u3042\u308b\u3068\u306f\u3044\u3048\u3001IArray\u3068\u304b\u4f7f\u3046\u7406\u7531\u306f\u306a\u3055\u305d\u3046\u3060\u3002\n\n\u4f7f\u7528\u3057\u3066\u3044\u308b\u30e9\u30a4\u30d6\u30e9\u30ea\u306f`repa`,`repa-algorithms`,`ncurses`\u306a\u306e\u3067\u8a66\u3057\u3066\u307f\u305f\u3051\u308c\u3070cabal\u3067\u3053\u308c\u3089\u306e\u30d1\u30c3\u30b1\u30fc\u30b8\u3092\u30a4\u30f3\u30b9\u30c8\u30fc\u30eb\u3057\u3066\u304f\u3060\u3055\u3044\u3002\u4f7f\u3044\u65b9\u306f\u30b3\u30fc\u30c9\u306b\u304b\u304b\u308c\u3066\u3044\u308b\u901a\u308a\uff1a\n\n```\n./LifeGame 250\n```\n\n\u3067\u30b9\u30c6\u30c3\u30d7\u9593\u306b250ms\u306e\u30b9\u30ea\u30fc\u30d7\u3092\u631f\u3080\u3002\u7d42\u4e86\u3057\u305f\u3044\u3068\u304d\u306fENTER\u30ad\u30fc\u3092\u62bc\u4e0b\u3002\n\n```hs:LifeGame_Repa_NCurses.hs\nmodule Main where\n\nimport Control.Monad (forM_)\nimport Control.Monad.IO.Class (liftIO)\nimport Control.Monad.ST (runST)\nimport System.Random (getStdRandom,random)\nimport System.Environment (getArgs)\nimport System.Exit (exitSuccess)\nimport UI.NCurses\nimport qualified Data.Array.Repa as R\nimport Data.Array.Repa.Algorithms.Randomish (randomishIntArray)\n\n\ntype Field = R.Array R.U R.DIM2 Int\n\ninitialize :: (Int,Int) -> IO Field\ninitialize (x,y) = do\n  seed <- getStdRandom random\n  return $ randomishIntArray (R.Z R.:.x R.:.y) 0 1 seed\n\naggregate :: Field -> Field\naggregate f = runST $ do\n  R.computeP $ R.traverse f id (\\ _ sh -> count f sh)\t\n\ncount :: Field -> R.DIM2 -> Int\ncount f (R.Z R.:.x R.:.y) = sum $ map\n  (\\(i,j) -> (R.!) f (R.Z R.:.i R.:.j)) $\n  [(i,j)|i<-[x-1,x,x+1],j<-[y-1,y,y+1],0<=i,i<=(xmax-1),0<=j,j<=(ymax-1)]\n    where (R.Z R.:.xmax R.:.ymax) = R.extent f\n\nstep :: Field -> Field\nstep f = runST $ do\n  R.computeP $ R.zipWith survival f (aggregate f)\n    where survival x y = if x == 1 \n    \t   then case y of {3->1; 4->1; _->0;}\n    \t   else case y of {3->1; _->0;}\n\ndrawField :: Field -> Update ()\ndrawField f = do\n let (R.Z R.:. xmax R.:. ymax) = R.extent f\n forM_ [(x,y)|x<-[0..(xmax-1)],y<-[0..(ymax-1)]] $ \\(x,y) -> do\n   moveCursor (fromIntegral x) (fromIntegral y)\n   drawString $ case f R.! (R.Z R.:. x R.:. y) of {1->\"o\";_->\" \";}\n\n\n\nmain :: IO ()\nmain = do\n  [arg] <- getArgs -- \u5f15\u6570\u306f\u753b\u9762\u306e\u66f4\u65b0\u9593\u9694(\u30df\u30ea\u79d2)\n  let delaytime = read arg\n  runCurses $ do\n    (x,y) <- screenSize\n    f <- liftIO $ initialize (fromIntegral (x-1), fromIntegral y)\n    let series = iterate step f\n    setEcho False\n    setCursorMode CursorInvisible\n    cid <- newColorID ColorGreen ColorBlack 1\n    w <- defaultWindow\n    updateWindow w $ setColor cid\n    forM_ series $ \\c -> do \n      updateWindow w $ drawField c\n      render\n      listenTo w delaytime \n        (\\ev -> ev == EventCharacter '\\n') -- Enter\u30ad\u30fc\u62bc\u4e0b\u3067\u7d42\u4e86\n\nlistenTo :: Window -> Int -> (Event -> Bool) -> Curses ()\nlistenTo w n p = do\n  ev <- getEvent w (Just $ fromIntegral n)\n  case ev of\n    Nothing -> return ()\n    Just ev' -> if p ev' then liftIO exitSuccess else return ()\n```\n"}