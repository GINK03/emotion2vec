{"context": "\u3000\u3042\u308a\u305d\u3046\u3067\u610f\u5916\u3068\u7121\u304b\u3063\u305f\u306e\u3067\u3001\u8272\u76f8\u74b0\u306e\u30ab\u30e9\u30fc\u30d4\u30c3\u30ab\u30fc\u306eWidget\u3092\u4f5c\u6210\u3057\u307e\u3057\u305f\u3002\n\u3000\u5f53\u521d\u3001C\u8a00\u8a9e\u306e\u30ce\u30ea\u3067\u4f4e\u30ec\u30d9\u30eb\u306e\u51e6\u7406\u3092\u8a18\u8ff0\u3057\u305f\u3068\u3053\u308d\u3001\u9ad8\u89e3\u50cf\u5ea6\u30e2\u30cb\u30bf\u7528\u306e\u52d5\u4f5c\u78ba\u8a8d\u3067\u62e1\u5927\u8868\u793a\u3059\u308b\u3068\u30b9\u30ed\u30fc\u30e2\u30fc\u30b7\u30e7\u30f3\u306b\u306a\u3063\u3066\u3057\u307e\u3044\u3001Qt\u306e\u30e9\u30a4\u30d6\u30e9\u30ea\u3084Python\u6d41\u306e\u6700\u9069\u5316\u3092\u3057\u305f\u3089\u3001\u554f\u984c\u306a\u304f\u52d5\u4f5c\u3059\u308b\u3088\u3046\u306b\u306a\u308a\u307e\u3057\u305f\u3002\nPython\u3092\u4f7f\u3046\u306a\u3089\u3001Python\u306e\u6d41\u5100\u3092\u899a\u3048\u308d\u3063\u3066\u3053\u3068\u3067\u3059\u306d\u3002\n\u3000\u4e2d\u592e\u306e\u5f69\u5ea6\u3001\u660e\u5ea6\u306e\u30ab\u30e9\u30fc\u30dc\u30c3\u30af\u30b9\u306e\u30b0\u30e9\u30c7\u30fc\u30b7\u30e7\u30f3\u306f\u3001\u5f69\u5ea6\u3068\u900f\u660e\u5ea6\u306e\uff12\u3064\u306e\u30b0\u30e9\u30c7\u30fc\u30b7\u30e7\u30f3\u3092\u5408\u6210\u3057\u3066\u5b9f\u73fe\u3057\u3066\u3044\u307e\u3059\u3002\u6d77\u5916\u306e\u63b2\u793a\u677f\u3067\u7d39\u4ecb\u3055\u308c\u3066\u3044\u305f\u65b9\u6cd5\u3067\u3059\u3002\n\u3000PyPI\u306b\u767b\u9332\u3057\u307e\u3057\u305f\u3002pip\u7b49\u3067install\u3067\u304d\u307e\u3059\u3002\n\u3000\u30bd\u30fc\u30b9\u3092GitHub\u306b\u767b\u9332\u3057\u307e\u3057\u305f\u3002\nhttps://github.com/tokyo-noctambulist/colorpicker.git\n(2017/03/07 \u66f4\u65b0) \n\u3000\u3000\u03b1\u5024\u3092\u7834\u58ca\u3057\u3066\u3044\u305f\u30d0\u30b0\u3092\u4fee\u6b63\u3002\n\u3000\u3000\u8272\u898b\u672c\u3001\u8272\u76f8\u74b0\u306b\u03b1\u5024\u3092\u53cd\u6620\u3057\u3066BG\u3092\u30bf\u30a4\u30eb\u5857\u308a\u3059\u308b\u3088\u3046\u306b\u5909\u66f4\n\u3000\u3000\u8272\u6307\u5b9a\u6642\u306b\u3001\u5024\u3092\u53c2\u7167\u6e21\u3057\u3092copy\u306b\u5909\u66f4\n\n\u30b5\u30f3\u30d7\u30eb\n\n\u3000sample.py\u3067\u306f\u3001\uff12\u3064\u306e\u8272\u76f8\u74b0\u3092\u9023\u52d5\u3055\u305b\u3066\u8868\u793a\u3057\u3066\u3044\u307e\u3059\u3002\n\n\n\u7c21\u6613\u8aac\u660e\n\u3000PyPI\u306b\u767b\u9332\u3057\u307e\u3057\u305f\u3002pip\u7b49\u3067install\u3067\u304d\u307e\u3059\u3002\n\nfunction\npip install colorpicker #install\n\nfrom colorpicker import *\n\ncolorCircle = QHueCircleWidget(self)\ncolor = colorCircle.getColor() #\u8272\u3092\u53ce\u5f97\ncolorCircle.setColor(QColor(255,100,10,200)) #\u8272\u3092\u30bb\u30c3\u30c8\n\ncolorCircle.colorChanged.connect(onUpdateColor) #signal-slot\n\n\nresize()\u3067\u3001\u30b5\u30a4\u30ba\u3092\u5909\u66f4\u3067\u304d\u307e\u3059\u3002\n\u305f\u3060\u3057\u3001\u7e26\u6a2a\u6bd4\u3092\uff11\u5bfe\uff11\u306b\u3057\u306a\u3044\u3068\u6b63\u5e38\u306b\u52d5\u4f5c\u3057\u307e\u305b\u3093\u3002\uff08\u6955\u5186\u72b6\u614b\u306b\u672a\u5bfe\u5fdc orz\uff09\n\n\nQHueCircleWidget.py\n# coding:utf-8\nfrom __future__ import division, print_function, unicode_literals, absolute_import\n# noinspection PyUnresolvedReferences\nfrom future_builtins import *\n\nfrom PySide.QtGui import *\nfrom PySide.QtCore import *\n\nimport math\n\nclass QHueCircleWidget(QGraphicsView):\n    PRESS_NONE = 0\n    PRESS_BOX = 1\n    PRESS_CIRCLE = 2\n\n    colorChanged = Signal(str)\n\n    def __init__(self, parent):\n        super(QHueCircleWidget, self).__init__(parent)\n        self.scene = QGraphicsScene(self)\n        self.setScene(self.scene)\n        self.rectF = None\n        self.press_mode = self.PRESS_NONE\n        self.color = QColor()\n        self.color.setHsv(0, 255, 255, 255)\n        self.setColor(self.color)\n        self.bg_brush = QBrush(self.create_bg_pixmap())\n\n        # self.setFixedSize(200,200)\n        self.setSizePolicy(QSizePolicy.Fixed, QSizePolicy.Fixed)\n        self.setSizePolicy(QSizePolicy.Minimum, QSizePolicy.Minimum)\n        self.setMinimumSize(200, 200)\n\n\n    def drawBackground(self, painter, rect):\n        \"\"\"\n        :type rect: QRectF\n        :type painter: QPainter\n        \"\"\"\n        painter.save()\n\n        painter.translate(rect.center())\n        painter.setRenderHint(QPainter.Antialiasing, True)\n        self.rectF = rect\n        self.rectToParam()\n        painter.setPen(QPen(Qt.black, 1))\n        # draw select color\n        painter.setBrush(self.bg_brush)\n        painter.drawEllipse(-self.half_width, -self.half_height, self.width / 8, self.height / 8)\n        painter.setBrush(self.color)\n        painter.drawEllipse(-self.half_width, -self.half_height, self.width / 8, self.height / 8)\n        # hue color circle\n        painter.setBrush(self.bg_brush)\n        painter.drawEllipse(0 - self.half_width, 0 - self.half_height, self.width, self.height)\n        color = QColor()\n        gradient = QConicalGradient(0, 0, 0)\n        for _ in range(11):\n            color.setHsv((10 - _) * 36, 255, 255, self.color.alpha())\n            gradient.setColorAt(0.1 * _, color)\n        painter.setBrush(gradient)\n        painter.drawEllipse(0 - self.half_width, 0 - self.half_height, self.width, self.height)\n        # center delete circle\n        mini_circle_width = self.width * 3 / 4\n        mini_circle_height = self.height * 3 / 4\n        painter.setBrush(QPalette().brush(QPalette.Midlight))\n        painter.drawEllipse(0 - mini_circle_width / 2, 0 - mini_circle_height / 2 , mini_circle_width, mini_circle_height)\n        # center box saturation\n        gradient = QLinearGradient(-self.quarter_width, 0, self.quarter_width, 0)\n        color.setHsv(self.color.hue(), 0, 255, 255)\n        gradient.setColorAt(0.0, color)\n        color.setHsv(self.color.hue(), 255, 255, 255)\n        gradient.setColorAt(1.0, color)\n        painter.setBrush(gradient)\n        painter.drawRect(-self.quarter_width, -self.quarter_height, self.half_width, self.half_height)\n\n        painter.restore()\n\n    def drawForeground(self, painter, rect):\n        \"\"\"\n        :type rect: QRectF\n        :type painter: QPainter\n        \"\"\"\n        painter.save()\n\n        painter.translate(rect.center())\n        painter.setRenderHint(QPainter.Antialiasing, True)\n        # center box value\n        gradient = QLinearGradient(0, -self.quarter_height, 0, self.quarter_height)\n        color = QColor()\n        color.setHsv(0, 0, 0, 0)\n        gradient.setColorAt(0.0, color)\n        color.setHsv(0, 0, 0, 255)\n        gradient.setColorAt(1.0, color)\n        painter.setBrush(gradient)\n        painter.drawRect(-self.quarter_width, -self.quarter_height, self.half_width, self.half_height)\n        # lupe for Saturation / Value\n        painter.setPen(QPen(QColor(255, 255, 255, 255), 1))\n        painter.drawEllipse(self.sv_x - 3, self.sv_y - 3, 7, 7)\n        painter.setPen(QPen(QColor(0, 0, 0, 255), 1))\n        painter.drawEllipse(self.sv_x - 2, self.sv_y - 2, 5, 5)\n        # lupe for Hue\n        painter.setPen(QPen(QColor(0, 0, 0, 255), 1))\n        painter.setBrush(QColor(255, 255, 255, 0))\n        painter.rotate(self.color.hue())\n        painter.drawRect(self.width * 3 / 8, -4, self.width / 8, 8)\n\n        painter.restore()\n\n    def mouseMoveEvent(self, event):\n        self.clickToColor(event)\n\n    def mousePressEvent(self, event):\n        if event.button() == Qt.LeftButton:\n            self.rectToParam()\n            if self.hitBox(event.x(), event.y()):\n                self.press_mode = self.PRESS_BOX\n                self.clickToColor(event)\n            elif self.hitCircle(event.x(), event.y()):\n                self.press_mode = self.PRESS_CIRCLE\n                self.clickToColor(event)\n            else:\n                self.press_mode = self.PRESS_NONE\n\n    def clickToColor(self, event):\n        if self.press_mode == self.PRESS_BOX:\n            self.clickToBox(event)\n        elif self.press_mode == self.PRESS_CIRCLE:\n            self.clickCircle(event)\n\n        self.colorChanged.emit('colorChanged')\n        self.scene.update()\n\n    def hitBox(self, x, y):\n        rect = QRect(self.quarter_width, self.quarter_height, self.width * 2 / 4, self.height * 2 / 4)\n        return rect.contains(x, y)\n\n    def hitCircle(self, x, y):\n        path = QPainterPath()\n        path.addEllipse(0, 0, self.width, self.height)\n\n        path2 = QPainterPath()\n        path2.addEllipse(self.quarter_width / 2., self.quarter_height / 2., self.width / 4. * 3., self.height / 4. * 3.)\n\n        pos = QPointF(x, y)\n        return path.contains(pos) and not path2.contains(pos)\n\n    def clickToBox(self, event):\n        if not self.hitBox(event.x(), event.y()):\n            return\n\n        x = event.x()\n        y = event.y()\n\n        col_sat = 255 * (x - self.quarter_width) / self.half_width\n        col_sat = 0 if col_sat < 0 else col_sat\n        col_sat = 255 if col_sat > 255 else col_sat\n\n        col_val = 255 * (self.half_height - (y - self.quarter_height)) / self.half_height\n        col_val = 0 if col_val < 0 else col_val\n        col_val = 255 if col_val > 255 else col_val\n\n        self.color.setHsv(\n            self.color.hue(),\n            col_sat,\n            col_val,\n            self.color.alpha()\n        )\n        self.sv_x = x - self.half_width\n        self.sv_y = y - self.half_height\n\n    def clickCircle(self, event):\n        x = event.x()\n        y = event.y()\n\n        k = int(math.degrees(math.atan2(x - self.half_width, self.half_height - y)))\n        self.color.setHsv(\n            (k - 90) % 360,\n            self.color.saturation(),\n            self.color.value(),\n            self.color.alpha()\n        )\n        self.hue_x = x - self.half_width\n        self.hue_y = y - self.half_height\n\n    def getColor(self):\n        return(self.color)\n\n    def setColor(self, color):\n        self.color = QColor(color)\n        if self.rectF == None:\n            self.sv_x = 0\n            self.sv_y = 0\n            self.hue_x = 0\n            self.hue_y = 0\n            self.scene.update()\n        else:\n            self.rectToParam()\n            # SV\n            self.sv_x = color.saturation() * self.half_width / 255 - self.quarter_width\n            self.sv_y = (255 - color.value()) * self.half_height / 255 - self.quarter_height\n            # Hue\n            radian = ((color.hue()) % 360) * math.pi / 180\n            self.hue_x = math.cos(radian) * self.half_width\n            self.hue_y = math.sin(radian) * self.half_height\n        self.scene.update()\n\n    def rectToParam(self):\n        if self.rectF == None:\n            rect = QRectF(0, 0, 200, 200)\n        else:\n            rect = self.rectF\n\n        self.width = rect.toRect().width()\n        self.half_width = self.width / 2\n        self.quarter_width = self.width / 4\n\n        self.height = rect.toRect().height()\n        self.half_height = self.height / 2\n        self.quarter_height = self.height / 4\n\n    @staticmethod\n    def create_bg_pixmap(color1=None, color2=None):\n        \"\"\"\n        :rtype: QPixmap\n        \"\"\"\n        pixmap = QPixmap(QSize(16, 16))\n        color1 = color1 or QColor(128, 128, 128)\n        color2 = color2 or QColor(168, 168, 168)\n\n        painter = QPainter(pixmap)\n        painter.save()\n        brush1 = QBrush(color1)\n        brush2 = QBrush(color2)\n        painter.fillRect(0, 0, 8, 8, brush1)\n        painter.fillRect(8, 8, 8, 8, brush1)\n        painter.fillRect(8, 0, 8, 8, brush2)\n        painter.fillRect(0, 8, 8, 8, brush2)\n        painter.restore()\n        painter.end()\n\n        return pixmap\n\n\n\nsample.py\nfrom __future__ import division, print_function, unicode_literals, absolute_import\n\nfrom PySide.QtGui import *\nfrom PySide.QtCore import *\nimport sys\n\nclass MainWindow(QMainWindow):\n    def __init__(self, parent=None):\n        super(MainWindow, self).__init__(parent)\n        self.resize(700, 500)\n\n        self.colorCircle1 = QHueCircleWidget(self)\n\n        self.colorCircle2 = QHueCircleWidget(self)\n        self.colorCircle2.resize(400, 400)\n        self.colorCircle2.move(260, 50)\n\n        # alpha color sample\n        color = QColor(255, 0, 0, 100)\n        self.colorCircle1.setColor(color)\n        self.colorCircle2.setColor(color)\n\n        self.colorCircle1.colorChanged.connect(self.onUpdateColor1)\n        self.colorCircle2.colorChanged.connect(self.onUpdateColor2)\n\n    @Slot()\n    def onUpdateColor1(self):\n        color = self.colorCircle1.getColor()\n        self.colorCircle2.setColor(color)\n\n    @Slot()\n    def onUpdateColor2(self):\n        color = self.colorCircle2.getColor()\n        self.colorCircle1.setColor(color)\n\ndef main():\n    app = QApplication(sys.argv)\n    main_window = MainWindow()\n    main_window.show()\n    sys.exit(app.exec_())\n\nif __name__ == \"__main__\":\n    main()\n\n\n\n\u3000\u3042\u308a\u305d\u3046\u3067\u610f\u5916\u3068\u7121\u304b\u3063\u305f\u306e\u3067\u3001\u8272\u76f8\u74b0\u306e\u30ab\u30e9\u30fc\u30d4\u30c3\u30ab\u30fc\u306eWidget\u3092\u4f5c\u6210\u3057\u307e\u3057\u305f\u3002\n\u3000\u5f53\u521d\u3001C\u8a00\u8a9e\u306e\u30ce\u30ea\u3067\u4f4e\u30ec\u30d9\u30eb\u306e\u51e6\u7406\u3092\u8a18\u8ff0\u3057\u305f\u3068\u3053\u308d\u3001\u9ad8\u89e3\u50cf\u5ea6\u30e2\u30cb\u30bf\u7528\u306e\u52d5\u4f5c\u78ba\u8a8d\u3067\u62e1\u5927\u8868\u793a\u3059\u308b\u3068\u30b9\u30ed\u30fc\u30e2\u30fc\u30b7\u30e7\u30f3\u306b\u306a\u3063\u3066\u3057\u307e\u3044\u3001Qt\u306e\u30e9\u30a4\u30d6\u30e9\u30ea\u3084Python\u6d41\u306e\u6700\u9069\u5316\u3092\u3057\u305f\u3089\u3001\u554f\u984c\u306a\u304f\u52d5\u4f5c\u3059\u308b\u3088\u3046\u306b\u306a\u308a\u307e\u3057\u305f\u3002\nPython\u3092\u4f7f\u3046\u306a\u3089\u3001Python\u306e\u6d41\u5100\u3092\u899a\u3048\u308d\u3063\u3066\u3053\u3068\u3067\u3059\u306d\u3002\n\n\u3000\u4e2d\u592e\u306e\u5f69\u5ea6\u3001\u660e\u5ea6\u306e\u30ab\u30e9\u30fc\u30dc\u30c3\u30af\u30b9\u306e\u30b0\u30e9\u30c7\u30fc\u30b7\u30e7\u30f3\u306f\u3001\u5f69\u5ea6\u3068\u900f\u660e\u5ea6\u306e\uff12\u3064\u306e\u30b0\u30e9\u30c7\u30fc\u30b7\u30e7\u30f3\u3092\u5408\u6210\u3057\u3066\u5b9f\u73fe\u3057\u3066\u3044\u307e\u3059\u3002\u6d77\u5916\u306e\u63b2\u793a\u677f\u3067\u7d39\u4ecb\u3055\u308c\u3066\u3044\u305f\u65b9\u6cd5\u3067\u3059\u3002\n\n\u3000PyPI\u306b\u767b\u9332\u3057\u307e\u3057\u305f\u3002pip\u7b49\u3067install\u3067\u304d\u307e\u3059\u3002\n\u3000\u30bd\u30fc\u30b9\u3092GitHub\u306b\u767b\u9332\u3057\u307e\u3057\u305f\u3002\nhttps://github.com/tokyo-noctambulist/colorpicker.git\n\n(2017/03/07 \u66f4\u65b0) \n\u3000\u3000\u03b1\u5024\u3092\u7834\u58ca\u3057\u3066\u3044\u305f\u30d0\u30b0\u3092\u4fee\u6b63\u3002\n\u3000\u3000\u8272\u898b\u672c\u3001\u8272\u76f8\u74b0\u306b\u03b1\u5024\u3092\u53cd\u6620\u3057\u3066BG\u3092\u30bf\u30a4\u30eb\u5857\u308a\u3059\u308b\u3088\u3046\u306b\u5909\u66f4\n\u3000\u3000\u8272\u6307\u5b9a\u6642\u306b\u3001\u5024\u3092\u53c2\u7167\u6e21\u3057\u3092copy\u306b\u5909\u66f4\n\n###\u30b5\u30f3\u30d7\u30eb\n![image](https://qiita-image-store.s3.amazonaws.com/0/164171/85403aa2-f3ba-90dc-cb97-cf28169826b2.png)\n\n\n\u3000sample.py\u3067\u306f\u3001\uff12\u3064\u306e\u8272\u76f8\u74b0\u3092\u9023\u52d5\u3055\u305b\u3066\u8868\u793a\u3057\u3066\u3044\u307e\u3059\u3002\n\n***\n###\u7c21\u6613\u8aac\u660e\n\n\u3000PyPI\u306b\u767b\u9332\u3057\u307e\u3057\u305f\u3002pip\u7b49\u3067install\u3067\u304d\u307e\u3059\u3002\n\n```python:function\npip install colorpicker #install\n\nfrom colorpicker import *\n\ncolorCircle = QHueCircleWidget(self)\ncolor = colorCircle.getColor() #\u8272\u3092\u53ce\u5f97\ncolorCircle.setColor(QColor(255,100,10,200)) #\u8272\u3092\u30bb\u30c3\u30c8\n\ncolorCircle.colorChanged.connect(onUpdateColor) #signal-slot\n```\n\nresize()\u3067\u3001\u30b5\u30a4\u30ba\u3092\u5909\u66f4\u3067\u304d\u307e\u3059\u3002\n\u305f\u3060\u3057\u3001\u7e26\u6a2a\u6bd4\u3092\uff11\u5bfe\uff11\u306b\u3057\u306a\u3044\u3068\u6b63\u5e38\u306b\u52d5\u4f5c\u3057\u307e\u305b\u3093\u3002\uff08\u6955\u5186\u72b6\u614b\u306b\u672a\u5bfe\u5fdc orz\uff09\n\n***\n```python:QHueCircleWidget.py\n# coding:utf-8\nfrom __future__ import division, print_function, unicode_literals, absolute_import\n# noinspection PyUnresolvedReferences\nfrom future_builtins import *\n\nfrom PySide.QtGui import *\nfrom PySide.QtCore import *\n\nimport math\n\nclass QHueCircleWidget(QGraphicsView):\n    PRESS_NONE = 0\n    PRESS_BOX = 1\n    PRESS_CIRCLE = 2\n\n    colorChanged = Signal(str)\n\n    def __init__(self, parent):\n        super(QHueCircleWidget, self).__init__(parent)\n        self.scene = QGraphicsScene(self)\n        self.setScene(self.scene)\n        self.rectF = None\n        self.press_mode = self.PRESS_NONE\n        self.color = QColor()\n        self.color.setHsv(0, 255, 255, 255)\n        self.setColor(self.color)\n        self.bg_brush = QBrush(self.create_bg_pixmap())\n\n        # self.setFixedSize(200,200)\n        self.setSizePolicy(QSizePolicy.Fixed, QSizePolicy.Fixed)\n        self.setSizePolicy(QSizePolicy.Minimum, QSizePolicy.Minimum)\n        self.setMinimumSize(200, 200)\n\n\n    def drawBackground(self, painter, rect):\n        \"\"\"\n        :type rect: QRectF\n        :type painter: QPainter\n        \"\"\"\n        painter.save()\n\n        painter.translate(rect.center())\n        painter.setRenderHint(QPainter.Antialiasing, True)\n        self.rectF = rect\n        self.rectToParam()\n        painter.setPen(QPen(Qt.black, 1))\n        # draw select color\n        painter.setBrush(self.bg_brush)\n        painter.drawEllipse(-self.half_width, -self.half_height, self.width / 8, self.height / 8)\n        painter.setBrush(self.color)\n        painter.drawEllipse(-self.half_width, -self.half_height, self.width / 8, self.height / 8)\n        # hue color circle\n        painter.setBrush(self.bg_brush)\n        painter.drawEllipse(0 - self.half_width, 0 - self.half_height, self.width, self.height)\n        color = QColor()\n        gradient = QConicalGradient(0, 0, 0)\n        for _ in range(11):\n            color.setHsv((10 - _) * 36, 255, 255, self.color.alpha())\n            gradient.setColorAt(0.1 * _, color)\n        painter.setBrush(gradient)\n        painter.drawEllipse(0 - self.half_width, 0 - self.half_height, self.width, self.height)\n        # center delete circle\n        mini_circle_width = self.width * 3 / 4\n        mini_circle_height = self.height * 3 / 4\n        painter.setBrush(QPalette().brush(QPalette.Midlight))\n        painter.drawEllipse(0 - mini_circle_width / 2, 0 - mini_circle_height / 2 , mini_circle_width, mini_circle_height)\n        # center box saturation\n        gradient = QLinearGradient(-self.quarter_width, 0, self.quarter_width, 0)\n        color.setHsv(self.color.hue(), 0, 255, 255)\n        gradient.setColorAt(0.0, color)\n        color.setHsv(self.color.hue(), 255, 255, 255)\n        gradient.setColorAt(1.0, color)\n        painter.setBrush(gradient)\n        painter.drawRect(-self.quarter_width, -self.quarter_height, self.half_width, self.half_height)\n\n        painter.restore()\n\n    def drawForeground(self, painter, rect):\n        \"\"\"\n        :type rect: QRectF\n        :type painter: QPainter\n        \"\"\"\n        painter.save()\n\n        painter.translate(rect.center())\n        painter.setRenderHint(QPainter.Antialiasing, True)\n        # center box value\n        gradient = QLinearGradient(0, -self.quarter_height, 0, self.quarter_height)\n        color = QColor()\n        color.setHsv(0, 0, 0, 0)\n        gradient.setColorAt(0.0, color)\n        color.setHsv(0, 0, 0, 255)\n        gradient.setColorAt(1.0, color)\n        painter.setBrush(gradient)\n        painter.drawRect(-self.quarter_width, -self.quarter_height, self.half_width, self.half_height)\n        # lupe for Saturation / Value\n        painter.setPen(QPen(QColor(255, 255, 255, 255), 1))\n        painter.drawEllipse(self.sv_x - 3, self.sv_y - 3, 7, 7)\n        painter.setPen(QPen(QColor(0, 0, 0, 255), 1))\n        painter.drawEllipse(self.sv_x - 2, self.sv_y - 2, 5, 5)\n        # lupe for Hue\n        painter.setPen(QPen(QColor(0, 0, 0, 255), 1))\n        painter.setBrush(QColor(255, 255, 255, 0))\n        painter.rotate(self.color.hue())\n        painter.drawRect(self.width * 3 / 8, -4, self.width / 8, 8)\n\n        painter.restore()\n\n    def mouseMoveEvent(self, event):\n        self.clickToColor(event)\n\n    def mousePressEvent(self, event):\n        if event.button() == Qt.LeftButton:\n            self.rectToParam()\n            if self.hitBox(event.x(), event.y()):\n                self.press_mode = self.PRESS_BOX\n                self.clickToColor(event)\n            elif self.hitCircle(event.x(), event.y()):\n                self.press_mode = self.PRESS_CIRCLE\n                self.clickToColor(event)\n            else:\n                self.press_mode = self.PRESS_NONE\n\n    def clickToColor(self, event):\n        if self.press_mode == self.PRESS_BOX:\n            self.clickToBox(event)\n        elif self.press_mode == self.PRESS_CIRCLE:\n            self.clickCircle(event)\n\n        self.colorChanged.emit('colorChanged')\n        self.scene.update()\n\n    def hitBox(self, x, y):\n        rect = QRect(self.quarter_width, self.quarter_height, self.width * 2 / 4, self.height * 2 / 4)\n        return rect.contains(x, y)\n\n    def hitCircle(self, x, y):\n        path = QPainterPath()\n        path.addEllipse(0, 0, self.width, self.height)\n\n        path2 = QPainterPath()\n        path2.addEllipse(self.quarter_width / 2., self.quarter_height / 2., self.width / 4. * 3., self.height / 4. * 3.)\n\n        pos = QPointF(x, y)\n        return path.contains(pos) and not path2.contains(pos)\n\n    def clickToBox(self, event):\n        if not self.hitBox(event.x(), event.y()):\n            return\n\n        x = event.x()\n        y = event.y()\n\n        col_sat = 255 * (x - self.quarter_width) / self.half_width\n        col_sat = 0 if col_sat < 0 else col_sat\n        col_sat = 255 if col_sat > 255 else col_sat\n\n        col_val = 255 * (self.half_height - (y - self.quarter_height)) / self.half_height\n        col_val = 0 if col_val < 0 else col_val\n        col_val = 255 if col_val > 255 else col_val\n\n        self.color.setHsv(\n            self.color.hue(),\n            col_sat,\n            col_val,\n            self.color.alpha()\n        )\n        self.sv_x = x - self.half_width\n        self.sv_y = y - self.half_height\n\n    def clickCircle(self, event):\n        x = event.x()\n        y = event.y()\n\n        k = int(math.degrees(math.atan2(x - self.half_width, self.half_height - y)))\n        self.color.setHsv(\n            (k - 90) % 360,\n            self.color.saturation(),\n            self.color.value(),\n            self.color.alpha()\n        )\n        self.hue_x = x - self.half_width\n        self.hue_y = y - self.half_height\n\n    def getColor(self):\n        return(self.color)\n\n    def setColor(self, color):\n        self.color = QColor(color)\n        if self.rectF == None:\n            self.sv_x = 0\n            self.sv_y = 0\n            self.hue_x = 0\n            self.hue_y = 0\n            self.scene.update()\n        else:\n            self.rectToParam()\n            # SV\n            self.sv_x = color.saturation() * self.half_width / 255 - self.quarter_width\n            self.sv_y = (255 - color.value()) * self.half_height / 255 - self.quarter_height\n            # Hue\n            radian = ((color.hue()) % 360) * math.pi / 180\n            self.hue_x = math.cos(radian) * self.half_width\n            self.hue_y = math.sin(radian) * self.half_height\n        self.scene.update()\n\n    def rectToParam(self):\n        if self.rectF == None:\n            rect = QRectF(0, 0, 200, 200)\n        else:\n            rect = self.rectF\n\n        self.width = rect.toRect().width()\n        self.half_width = self.width / 2\n        self.quarter_width = self.width / 4\n\n        self.height = rect.toRect().height()\n        self.half_height = self.height / 2\n        self.quarter_height = self.height / 4\n\n    @staticmethod\n    def create_bg_pixmap(color1=None, color2=None):\n        \"\"\"\n        :rtype: QPixmap\n        \"\"\"\n        pixmap = QPixmap(QSize(16, 16))\n        color1 = color1 or QColor(128, 128, 128)\n        color2 = color2 or QColor(168, 168, 168)\n\n        painter = QPainter(pixmap)\n        painter.save()\n        brush1 = QBrush(color1)\n        brush2 = QBrush(color2)\n        painter.fillRect(0, 0, 8, 8, brush1)\n        painter.fillRect(8, 8, 8, 8, brush1)\n        painter.fillRect(8, 0, 8, 8, brush2)\n        painter.fillRect(0, 8, 8, 8, brush2)\n        painter.restore()\n        painter.end()\n\n        return pixmap\n```\n\n```python:sample.py\nfrom __future__ import division, print_function, unicode_literals, absolute_import\n\nfrom PySide.QtGui import *\nfrom PySide.QtCore import *\nimport sys\n\nclass MainWindow(QMainWindow):\n    def __init__(self, parent=None):\n        super(MainWindow, self).__init__(parent)\n        self.resize(700, 500)\n\n        self.colorCircle1 = QHueCircleWidget(self)\n\n        self.colorCircle2 = QHueCircleWidget(self)\n        self.colorCircle2.resize(400, 400)\n        self.colorCircle2.move(260, 50)\n\n        # alpha color sample\n        color = QColor(255, 0, 0, 100)\n        self.colorCircle1.setColor(color)\n        self.colorCircle2.setColor(color)\n\n        self.colorCircle1.colorChanged.connect(self.onUpdateColor1)\n        self.colorCircle2.colorChanged.connect(self.onUpdateColor2)\n\n    @Slot()\n    def onUpdateColor1(self):\n        color = self.colorCircle1.getColor()\n        self.colorCircle2.setColor(color)\n\n    @Slot()\n    def onUpdateColor2(self):\n        color = self.colorCircle2.getColor()\n        self.colorCircle1.setColor(color)\n\ndef main():\n    app = QApplication(sys.argv)\n    main_window = MainWindow()\n    main_window.show()\n    sys.exit(app.exec_())\n\nif __name__ == \"__main__\":\n    main()\n\n```\n", "tags": ["Python", "Qt", "\u30ab\u30e9\u30fc\u30d4\u30c3\u30ab\u30fc", "\u30d1\u30ec\u30c3\u30c8\u30c4\u30fc\u30eb"]}