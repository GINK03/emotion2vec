{"context": " More than 1 year has passed since last update.Wireshark\u3084tcpdump -w\u3067\u51fa\u529b\u3055\u308c\u308bpcap\u30d5\u30a1\u30a4\u30eb\u3092\u3053\u306d\u3053\u306d\u3067\u304d\u308b\u4f55\u304b\u3002\n\u306a\u304b\u306a\u304b\u3044\u3044\u306e\u304c\u306a\u3044\u306e\u3067\u4f5c\u3063\u3066\u307f\u3088\u3046\u3068\u601d\u3044\u307e\u3057\u305f\u3002\njNetPcap\u3068\u304b\u4f7f\u3046\u306e\u96e3\u3057\u304f\u3066\u3081\u3093\u3069\u305d\u3046\u3060\u3057\u3001Clojure\u306e\u30d0\u30a4\u30ca\u30ea\u30d1\u30fc\u30b5\u3068\u3057\u3066\u306fbuffy\u3068\u304b\u3042\u308a\u307e\u3059\u304c\u3001\u75d2\u3044\u6240\u306b\u624b\u304c\u5c4a\u304d\u307e\u305b\u3093\u3002\n\u305d\u3053\u3067\u3001\u7c21\u5358\u306b\u4f7f\u3048\u308b\u30d0\u30a4\u30ca\u30ea\u30d1\u30fc\u30b5\u3092\u4f5c\u3063\u3066\u3001\u30d1\u30b1\u30c3\u30c8\u30ad\u30e3\u30d7\u30c1\u30e3\u3092\u8aad\u307f\u66f8\u304d\u3067\u304d\u308b\u4f55\u304b\u3092\u4f5c\u308d\u3046\u3068\u3044\u3046\u308f\u3051\u3067\u3059\u3002\n\n\u65b9\u91dd\n\u6a5f\u80fd\u3068\u3057\u3066\u5b9f\u73fe\u3057\u305f\u3044\u3082\u306e\n\n\u30b5\u30a4\u30ba\u8a08\u7b97\uff1a\u96fb\u6587\u5185\u306e\u30b5\u30a4\u30ba\u30d5\u30a3\u30fc\u30eb\u30c9\u3092\u3082\u3068\u306b\u3001\u53ef\u5909\u30b5\u30a4\u30ba\u306e\u30d5\u30a3\u30fc\u30eb\u30c9\u3092\u7c21\u5358\u306b\u6271\u3044\u305f\u3044\n\u30d3\u30c3\u30c8\u30d5\u30a3\u30fc\u30eb\u30c9\uff1aIP\u30d8\u30c3\u30c0\u3068\u304b\u306b\u3042\u308b4\u30d3\u30c3\u30c8\u306e\u30d5\u30a3\u30fc\u30eb\u30c9\u3092\u6574\u6570\u3068\u3057\u3066\u7c21\u5358\u306b\u6271\u3044\u305f\u3044\n\u30d0\u30ea\u30c7\u30fc\u30b7\u30e7\u30f3\uff1a\u8aad\u307f\u8fbc\u3093\u3067\u3044\u308b\u30d0\u30a4\u30ca\u30ea\u304c\u9014\u4e2d\u3067\u9593\u9055\u3063\u3066\u3044\u306a\u3044\u304b\u7c21\u5358\u306b\u78ba\u8a8d\u3067\u304d\u308b\u4ed5\u7d44\u307f\u304c\u307b\u3057\u3044\n\u5206\u5c90\uff1aIP\u30d1\u30b1\u30c3\u30c8\u3068ARP\u30d1\u30b1\u30c3\u30c8\u3068\u304b\u3067\u5206\u5c90\u3057\u3066\u51e6\u7406\u3067\u304d\u308b\u3088\u3046\u306b\u3057\u305f\u3044\nunsigned\u3092\u6271\u3044\u305f\u3044\n\u30a8\u30f3\u30c7\u30a3\u30a2\u30f3\uff1apcap\u30d5\u30a1\u30a4\u30eb\u306eGlobalHeader\u3084RecordHeader\u306e\u90e8\u5206\u304cLE\u3067\u96fb\u6587\u306e\u90e8\u5206\u304cBE\u3060\u3063\u305f\u308a\u3059\u308b\u306e\u3067\n\n\u3053\u308c\u3089\u306e\u6a5f\u80fd\u3092\u7c21\u5358\u306b\u30a8\u30ec\u30ac\u30f3\u30c8\u306b\u5b9f\u88c5\u3057\u305f\u3044\u30fb\u30fb\u30fb\u3067\u3059\n\n\u30d0\u30a4\u30ca\u30ea\u30d5\u30ec\u30fc\u30e0\u306e\u5b9a\u7fa9\n\u30d0\u30a4\u30ca\u30ea\u30d5\u30ec\u30fc\u30e0\u306b\u3064\u3044\u3066\u3001\u30d5\u30a3\u30fc\u30eb\u30c9\u3054\u3068\u306b\u578b:\u30b5\u30a4\u30ba \u540d\u524d:\u30d0\u30ea\u30c7\u30fc\u30b7\u30e7\u30f3\u95a2\u6570\u3092\u5b9a\u7fa9\u3067\u304d\u308b\u3053\u3068\u3092\u76ee\u6307\u3057\u307e\u3059\u3002\n\u30b5\u30a4\u30ba\u3068\u30d0\u30ea\u30c7\u30fc\u30b7\u30e7\u30f3\u95a2\u6570\u306f\u7701\u7565\u53ef\u80fd\u3068\u3057\u307e\u3059\u3002\nTCP\u30d8\u30c3\u30c0\u306e\u5b9a\u7fa9\u3068\u3057\u3066\u306f\u3001\u4ee5\u4e0b\u306e\u3088\u3046\u306b\u306a\u308a\u307e\u3059\u3002\n\ntcpheader.clj\n(def-frame :TcpHeader\n  :uint16 :SourcePort\n  :uint16 :DestinationPort\n  :int32 :SequenceNumber\n  :int32 :AcknowledgmentNumber\n  [4 3 9] [:DataOffset:ge5? :Reserved:zero? :ControlBits]\n  :uint16 :Window\n  :int16 :Checksum\n  :int16 :UrgentPointer\n  \"int32:(- DataOffset 5)\" :Options)\n\n\n\u578b\u306f\u6574\u6570\u3092\u8868\u3059int8 uint8 int16 uint16 int32 uint32\u3068\u3001\u30d3\u30c3\u30c8\u30d5\u30a3\u30fc\u30eb\u30c9\u3092\u8868\u3059\u30d9\u30af\u30bf[\uff5e]\u3068\u3001\u30d0\u30a4\u30ca\u30ea\u3092\u8868\u3059bytes\u3092\u6271\u3048\u308b\u3088\u3046\u306b\u3057\u307e\u3059\u3002\n\u203b\u30d3\u30c3\u30c8\u30d5\u30a3\u30fc\u30eb\u30c9\u306f\u5408\u8a08\u304c8\u306e\u500d\u6570\u304b\u3064\u5408\u8a08\u304c64\u307e\u3067\u306e\u5236\u9650\u3042\u308a\n\u30b5\u30a4\u30ba\u306b\u3064\u3044\u3066\u306f\u3001(- DataOffset 5)\u306e\u3088\u3046\u306b\u524d\u306e\u307b\u3046\u306b\u3042\u308b\u30d5\u30a3\u30fc\u30eb\u30c9\u306e\u5024\u3092\u53c2\u7167\u3057\u3066\u8a2d\u5b9a\u3067\u304d\u308b\u3088\u3046\u306b\u3057\u307e\u3059\u3002\n\u203b\u6574\u6570\u3067\u306a\u304ftrue/false\u3067\u306e\u6307\u5b9a\u3082\u3042\u308b\u3051\u3069\u5f8c\u307b\u3069\u30fb\u30fb\u30fb\n\u30d0\u30ea\u30c7\u30fc\u30b7\u30e7\u30f3\u95a2\u6570\u306f(def-validator :ge5? #(<= 5 %))\u306e\u3088\u3046\u306b\u3057\u3066\u3042\u3089\u304b\u3058\u3081\u5b9a\u7fa9\u3057\u3066\u4f7f\u3048\u308b\u3088\u3046\u306b\u3057\u307e\u3059\u3002\n\u4ee5\u4e0b\u3001\u3053\u308c\u3089\u306e\u5b9a\u7fa9\u65b9\u6cd5\u3067\u3082\u3063\u3066\u30d0\u30a4\u30ca\u30ea\u30d5\u30ec\u30fc\u30e0\u306e\u5b9a\u7fa9\u3092\u3057\u3066\u3044\u304d\u307e\u3059\u3002\n\npcap\u30d5\u30a1\u30a4\u30eb\u306e\u30d8\u30c3\u30c0\npcap\u30d5\u30a1\u30a4\u30eb\u306b\u306f1\u3064\u306eGlobalHeader\u304c\u5148\u982d\u306b\u3042\u308a\u3001\u305d\u306e\u5f8c\u306b\u30d1\u30b1\u30c3\u30c8\u3054\u3068\u306bRecordHeader\u3068\u30d1\u30b1\u30c3\u30c8\u5185\u5bb9\u304c\u7d9a\u3044\u3066\u3044\u304d\u307e\u3059\u3002\n\npcap-header.clj\n(def-frame :GlobalHeaderFirst\n  :uint32 :magic_number) ;magic number\n\n(def-frame :GlobalHeaderRest\n  :uint16 :version_major ;major version number\n  :uint16 :version_minor ;minor version number\n  :int32 :thiszone       ;GMT to local correction\n  :uint32 :sigfigs       ;accuracy of timestamps\n  :uint32 :snaplen       ;max length of captured packets, in octets\n  :uint32 :network)      ;data link type\n\n(def-frame :RecordHeader\n  :uint32 :ts_sec    ;timestamp seconds\n  :uint32 :ts_usec   ;timestamp microseconds\n  :uint32 :incl_len  ;number of octets of packet saved in file\n  :uint32 :orig_len) ;actual length of packet\n\n\nGlobalHeader\u306emagic_number\u304c0xd4c3b2a1\u306e\u5834\u5408\u3001GlobalHeader\u3068RecordHeader\u306e\u90e8\u5206\u304c\u30ea\u30c8\u30eb\u30a8\u30f3\u30c7\u30a3\u30a2\u30f3\u306b\u306a\u308a\u307e\u3059\u3002\uff08\u96fb\u6587\u306f\u30d3\u30c3\u30b0\u30a8\u30f3\u30c7\u30a3\u30a2\u30f3\uff09\n\u203b\u30d1\u30b1\u30c3\u30c8\u5185\u5bb9\u306e\u5b9a\u7fa9\u306b\u3064\u3044\u3066\u306f\u5f8c\u307b\u3069\n\n\u30cd\u30c3\u30c8\u30ef\u30fc\u30af\u30d8\u30c3\u30c0\u306e\u5b9a\u7fa9\n\u4e0a\u306eGlobalHeaderRest\u306enetwork\u304c1\u306e\u3068\u304d\u3001\u30d1\u30b1\u30c3\u30c8\u5185\u5bb9\u306b\u306fEthernet\u30d5\u30ec\u30fc\u30e0\u304c\u5165\u3063\u3066\u3044\u307e\u3059\u3002\u305d\u306e\u524d\u63d0\u3067\u9032\u3081\u307e\u3059\u3002\nEthernet\u3068IPv4\u3068TCP\u30d8\u30c3\u30c0\u306e\u5b9a\u7fa9\u306f\u4ee5\u4e0b\u306e\u3068\u304a\u308a\n\nheader.clj\n(def-frame :Ethernet2Header\n  :int8:6 :DestinationAddress\n  :int8:6 :SourceAddress\n  :uint16 :EtherType)\n\n(def-frame :Ipv4Header\n  [4 4] [\"Version:#(= 4 %)\" :IHL:ge5?]\n  :int8 :TOS\n  :uint16 :TL\n  :int16 :Identification\n  [3 13] [:Flags :FragmentOffset]\n  :uint8 :TTL\n  :uint8 :Protocol\n  :int16 :HeaderChecksum\n  :uint8:4 :SourceAddress\n  :uint8:4 :DestinationAddress\n  \"int32:(- IHL 5)\" :Options)\n\n(def-frame :TcpHeader\n  :uint16 :SourcePort\n  :uint16 :DestinationPort\n  :int32 :SequenceNumber\n  :int32 :AcknowledgmentNumber\n  [4 3 9] [:DataOffset:ge5? :Reserved:zero? :ControlBits]\n  :uint16 :Window\n  :int16 :Checksum\n  :int16 :UrgentPointer\n  \"int32:(- DataOffset 5)\" :Options)\n\n\n\n\u30d1\u30b1\u30c3\u30c8\u5185\u5bb9\u306e\u90e8\u5206\u306e\u5b9a\u7fa9\n\nether.clj\n(def-frame :EtherRecord\n  :RecordHeader :header\n  :Ethernet2Frame :ether)\n\n(def-frame :Ethernet2Frame\n  :Ethernet2Header :header\n  \"Ipv4Frame:(= EtherType 0x0800)\" :ipv4\n  \"ArpFrame:(= EtherType 0x0806)\" :arp\n  \"bytes:(if (not-any? #(= EtherType %) [0x0800 0x0806]) (- incl_len 14) false)\" :unknown)\n\n\nEthernet\u30d5\u30ec\u30fc\u30e0\u3068\u3057\u3066\u3001IPv4\u3068ARP\u30d5\u30ec\u30fc\u30e0\u3092\u6271\u3046\u4f8b\u3067\u3059\u3002\n\u30b5\u30a4\u30ba\u306e\u90e8\u5206\u3092true/false\u3067\u6307\u5b9a\u3059\u308b\u3068\u914d\u5217\u3067\u306a\u3044\u578b\u3092\u8868\u3059\u3088\u3046\u306b\u3057\u3066\u3001\u5206\u5c90\u3092\u5b9f\u73fe\u3067\u304d\u308b\u3088\u3046\u306b\u3057\u3066\u3044\u307e\u3059\u3002\nEtherType\u306fEthernet2Header\u306e\u4e2d\u3067\u5b9a\u7fa9\u3055\u308c\u3066\u3044\u3066\u3001\u305d\u306e\u5024\u306b\u3088\u3063\u3066\u5206\u5c90\u3059\u308b\u3068\u3044\u3046\u3053\u3068\u3067\u3059\u3002\n\u6b8b\u308a\u306f\u4ee5\u4e0b\u306e\u3068\u304a\u308a\n\nbody.clj\n(def-frame :Ipv4Frame\n  :Ipv4Header :header\n  \"IcmpFrame:(= Protocol 1)\" :icmp\n  \"TcpFrame:(= Protocol 6)\" :tcp\n  \"bytes:(if (not-any? #(= Protocol %) [1 6]) (- incl_len 14 (* 4 IHL)) false)\" :unknown)\n\n(def-frame :ArpFrame\n  :uint16 :HTYPE\n  :uint16 :PTYPE\n  :uint8 :HLEN\n  :uint8 :PLEN\n  :int16 :OPER\n  :int8:6 :SHA\n  :uint8:4 :SPA\n  :int8:6 :THA\n  :uint8:4 :TPA\n  \"bytes:(- incl_len 42)\" :padding)\n\n(def-frame :TcpFrame\n  :TcpHeader :header\n  \"bytes:(- incl_len 14 (* 4 (+ IHL DataOffset)))\" :payload)\n\n(def-frame :IcmpFrame\n  :uint8 :type\n  :int8 :code\n  :int16 :checksum\n  \"bytes:(- incl_len 18 (* 4 IHL))\" :others)\n\n\n\n\u5b9f\u73fe\u3059\u308b\u305f\u3081\u306e\u30b3\u30fc\u30c9\n\u4ee5\u4e0a\u306e\u3088\u3046\u306a\u5b9a\u7fa9\u306b\u3082\u3068\u3065\u3044\u3066\u3001\u30d0\u30a4\u30ca\u30ea\u3092\u8aad\u307f\u8fbc\u3093\u3067\u30de\u30c3\u30d7\u3092\u51fa\u529b\u3059\u308b\u6a5f\u80fd\u3068\u3001\u9006\u306b\u30de\u30c3\u30d7\u304b\u3089\u30d0\u30a4\u30ca\u30ea\u3092\u66f8\u304d\u8fbc\u3080\u6a5f\u80fd\u304c\u3001\u7a7a\u884c\u5165\u308c\u3066\u3082250\u884c\u7a0b\u5ea6\u3067\u3067\u304d\u307e\u3057\u305f\u3002\n\uff03\u3082\u3063\u3068\u77ed\u304f\u30a8\u30ec\u30ac\u30f3\u30c8\u306a\u66f8\u304d\u65b9\u3067\u304d\u308c\u3070\u3044\u3044\u306a\u3042\n\uff03\u3042\u3093\u307e\u308a\u30c6\u30b9\u30c8\u3067\u304d\u3066\u306a\u3044\u3051\u3069\u30fb\u30fb\u30fb\n\u4f7f\u3044\u65b9\u306f\n\nsample.clj\n(def pcap (io/input-stream \"sample.pcap\"))\n(read-binary-frame pcap :GlobalHeaderFirst)\n(read-binary-frame pcap :GlobalHeaderRest :le-frames [:GlobalHeaderRest])\n(read-binary-frame pcap :EtherRecord :le-frames [:RecordHeader])\n\n\n\u306e\u3088\u3046\u306a\u611f\u3058\u3067\u3059\u3002\uff08\u5b9f\u969b\u306b\u306f:EtherRecord\u306e\u8aad\u307f\u8fbc\u307f\u3092\u8907\u6570\u56de\u3059\u308b\u3053\u3068\u306b\u306a\u308a\u307e\u3059\uff09\n\u307e\u305a\u306f\u3001\u30e6\u30fc\u30c6\u30a3\u30ea\u30c6\u30a3\u7cfb\u306e\u95a2\u6570\u3092\u5b9a\u7fa9\u3057\u307e\u3059\u3002\n\nutil.clj\n(ns bin-parser.util)\n\n(def << bit-shift-left)\n(def >> bit-shift-right)\n(def >>> unsigned-bit-shift-right)\n\n(defn bit-mask [value bit]\n  {:pre [(<= 1 bit 64)]}\n  (bit-and value (>>> -1 (- 64 bit))))\n\n(defn constantly-true [& _] true)\n(defn ->symbol [x] (symbol (name x)))\n(defn map->vec [map] (vec (apply concat map)))\n\n(defn exact-get [map key]\n  (if-let [[k v] (find map key)]\n    v\n    (throw (IllegalArgumentException. (str key \" not found\")))))\n\n(defmacro bswap! [x f & args]\n  `(set! ~x (~f ~x ~@args)))\n\n(defn areverse-byte [^bytes bytea]\n  (let [len (alength bytea)]\n    (areduce bytea i ret (byte-array len)\n             (do (aset-byte ret (- len i 1) (aget bytea i)) ret))))\n\n(defn unsigned [^bytes bytea]\n  {:pre [(<= 1 (alength bytea) 7)]}\n  (areduce bytea i ret 0\n           (bit-or (<< ret 8) (bit-and 0xff (aget bytea i)))))\n\n(defn signed [^bytes bytea]\n  {:pre [(<= 1 (alength bytea) 8)]}\n  (areduce bytea i ret (if (neg? (aget bytea 0)) -1 0)\n           (bit-or (<< ret 8) (bit-and 0xff (aget bytea i)))))\n\n(defn ^bytes ->bytes [^long len ^long value]\n  {:pre [(<= 1 len 8)]}\n  (byte-array\n   (reduce (fn [a i] (conj a (>> value (* (- len i 1) 8)))) [] (range len))))\n\n(defn split-once [string sep]\n  (let [s (name string)\n        i (.indexOf s sep)]\n    (if (neg? i)\n      [s nil]\n      [(subs s 0 i) (subs s (+ i (count sep)))])))\n\n\nexact-get\u306fget\u3067\u304d\u306a\u304b\u3063\u305f\u3089\u4f8b\u5916\u3092\u6295\u3052\u308b\u3084\u3064\u3067\u3059\u3002\nbswap!\u306f\u52d5\u7684\u5909\u6570(binding\u3092\u4f7f\u3046\u30a2\u30ec)\u7528\u306eswap!\u3067\u3059\u3002\nareverse-byte\u306fbyte\u914d\u5217\u7528\u306ereverse\u3067\u3059\u3002\nunsigned\u3068signed\u306fbyte\u914d\u5217\u304b\u3089\u6574\u6570\u3078\u306e\u5909\u63db\u3067\u3059\u3002\n->bytes\u306f\u6574\u6570\u304b\u3089\u6307\u5b9a\u9577\u306ebyte\u914d\u5217\u3078\u306e\u5909\u63db\u3067\u3059\u3002\nsplit-once\u306f\u6587\u5b57\u5217\u30921\u56de\u3060\u3051split\u3059\u308b\u3084\u3064\u3067\u3059\u3002\n\u3053\u3053\u307e\u3067\u3067\u7d0450\u884c\n\n\u30d5\u30ec\u30fc\u30e0\u5b9a\u7fa9\u90e8\u5206\u306e\u30b3\u30fc\u30c9\nframes\u306fdef-frame\u3057\u305f\u3068\u304d\u306e\u5b9a\u7fa9\u306e\u4fdd\u5b58\u5834\u6240\u3067\u3059\u3002\nsize-symbols\u306f\u30b5\u30a4\u30ba\u306e\u90e8\u5206\u306esymbol\u3092\u4fdd\u5b58\u3057\u3066\u304a\u304f\u5834\u6240\u3067\u3059\u3002\n(- DataOffset 5)\u3068\u30b5\u30a4\u30ba\u5b9a\u7fa9\u304c\u3042\u3063\u305f\u3089-\u3068DataOffset\u304c\u5165\u308a\u307e\u3059\u3002\uff08-\u306f\u4e0d\u8981\u306a\u3093\u3060\u3051\u3069\uff09\nvalidators\u306fdef-validator\u3057\u305f\u3068\u304d\u306e\u5b9a\u7fa9\u306e\u4fdd\u5b58\u5834\u6240\u3067\u3059\u3002\n\ncore_1.clj\n(ns bin-parser.core\n  (:require [bin-parser.util :refer :all])\n  (:import [java.io InputStream OutputStream IOException]))\n\n(def ^:private frames (atom {}))\n(def ^:private size-symbols (atom #{}))\n(def ^:private validators (atom {}))\n\n;; Frame\n(defn def-validator [validator-name f]\n  (swap! validators assoc (->symbol validator-name) f))\n\n(defn- split-field-item [item]\n  (let [[base suffix] (split-once item \":\")\n        suffix (when suffix (read-string suffix))]\n    [(keyword base) suffix]))\n\n(defn- split-field-name [item]\n  (let [[base func] (split-field-item item)\n        func (if (nil? func)\n               constantly-true\n               (eval (list 'let (map->vec @validators) func)))]\n    [base func]))\n\n(defn- check-bits [bit-pattern names]\n  {:pre [(zero? (mod (apply + bit-pattern) 8))\n         (<= (apply + bit-pattern) 64)\n         (= (count bit-pattern) (count names))]}\n  true)\n\n(defn- find-size-symbols [field-type]\n  (let [[_ size] (split-field-item field-type)]\n    (swap! size-symbols into (filter symbol? (flatten size)))))\n\n(defn def-frame [frame-name & field-type+names]\n  {:pre [(even? (count field-type+names))]}\n  (let [fields (partition 2 field-type+names)\n        array (volatile! [])]\n    (doseq [[type name] fields]\n      (if (sequential? type)\n        (check-bits type name)\n        (find-size-symbols type))\n      (let [field (if (sequential? type)\n                    (list* type nil (apply map list (map split-field-name name)))\n                    (concat (split-field-item type) (split-field-name name)))]\n        (vswap! array conj (vec field))))\n    (swap! frames assoc (keyword frame-name) @array)))\n\n\n\u3053\u3053\u307e\u3067\u3067\u7d04100\u884c\n\n\u8aad\u307f\u8fbc\u307f\u3068\u66f8\u304d\u8fbc\u307f\u90e8\u5206\n\u6b8b\u308a\u7d04150\u884c\u3067\u3059\u304c\u3001\u5168\u90e8\u8aac\u660e\u306f\u96e3\u3057\u3044\u306e\u3067\u3044\u304f\u3064\u304b\u3060\u3051\u3002\n*env*\u306b\u306fsize-symbols\u306b\u5b58\u5728\u3059\u308b\u30d5\u30a3\u30fc\u30eb\u30c9\u306e\u5024\u3092:vars\u306b\u5165\u308c\u3066\u3044\u304f\u3053\u3068\u3067\u3001\u30b5\u30a4\u30ba\u306e\u8a08\u7b97(\u89e3\u6c7a)\u3092\u3067\u304d\u308b\u3088\u3046\u306b\u3057\u3066\u3044\u307e\u3059\u3002\nread-field\u3067(bswap! *env* assoc :error th)\u306e\u3088\u3046\u306b\u3057\u3066\u3001read-frame\u306edoseq\u3067:while (not (:error *env*))\u306e\u3088\u3046\u306b\u3057\u3066\u3044\u308b\u306e\u306f\u3001\u8aad\u307f\u8fbc\u307f\u9014\u4e2d\u3067\u30a8\u30e9\u30fc\u304c\u8d77\u3053\u3063\u305f\u6642\u306b\u3001\u3069\u3053\u307e\u3067\u8aad\u307f\u8fbc\u3081\u3066\u308b\u304b\u30c7\u30d0\u30c3\u30b0\u3057\u3084\u3059\u304f\u3059\u308b\u305f\u3081\u3067\u3059\u3002\n\ncore_2.clj\n;; Read/Write\n(def ^:private primitives\n  {:int8 [1 nil]\n   :uint8 [1 :unsigned]\n   :int16 [2 nil]\n   :uint16 [2 :unsigned]\n   :int32 [4 nil]\n   :uint32 [4 :unsigned]})\n\n(declare ^:private ^:dynamic *env*)\n\n(defn- get-frame-fields [frame-name]\n  (exact-get @frames (keyword frame-name)))\n\n(defn- calc-size [[_ size :as field]]\n  (let [size (if (nil? size) true size)]\n    (assoc field 1 (eval (list 'let (map->vec (:vars *env*)) size)))))\n\n(defn- add-var [field-name value]\n  (let [sym (->symbol field-name)]\n    (when (contains? @size-symbols sym)\n      (bswap! *env* assoc-in [:vars sym] value))))\n\n(defn- set-invalid-error [n v]\n  (bswap! *env* assoc :error\n          (IllegalArgumentException. (str \"invalid \" n \" value \" v))))\n\n(defn- map+ [wrap? f c1 & colls]\n  (if (sequential? c1)\n    (apply map f c1 colls)\n    (let [v (apply f c1 colls)]\n      (if wrap? [v] v))))\n\n;; Read\n(defn- read-bytes [size]\n  (let [^InputStream in (:in *env*)\n        bytea (byte-array size)\n        len (.read in bytea)]\n    (when (not= len size) (throw (IOException. (str len \" != \" size))))\n    bytea))\n\n(declare read-frame)\n(defn- read-one [[type]]\n  (if-let [[size unsigned?] (get primitives type)]\n    (let [bytea (read-bytes size)\n          bytea (if (:le? *env*) (areverse-byte bytea) bytea)]\n      (if unsigned? (unsigned bytea) (signed bytea)))\n    (read-frame type)))\n\n(defn- read-array [[type size :as field]]\n  (if (= type :bytes)\n    (read-bytes size)\n    (mapv (fn [_] (read-one field)) (range size))))\n\n(defn- read-bits [[bit-pattern]]\n  (let [bit-size (apply + bit-pattern)\n        byte-size (/ bit-size 8)\n        bytea (read-bytes byte-size)\n        offsets (map #(- bit-size %) (reductions + bit-pattern))]\n    (map #(-> (signed bytea) (>> %1) (bit-mask %2)) offsets bit-pattern)))\n\n(defn- read-field [[type size :as field]]\n  (try\n    ((cond\n      (sequential? type) read-bits\n      (integer? size) read-array\n      :else read-one) field)\n    (catch Throwable th\n      (bswap! *env* assoc :error th)\n      nil)))\n\n(defn- read-frame [frame-name]\n  (bswap! *env* assoc :le? ((:le-frames *env*) (keyword frame-name)))\n  (let [obj (volatile! {})]\n    (doseq [field (get-frame-fields frame-name)\n            :let [[type size name func :as field] (calc-size field)]\n            :when size\n            :let [value (read-field field)]\n            :while (not (:error *env*))\n            [n f v] (map+ true list name func value)]\n      (if (f v)\n        (do (vswap! obj assoc n v) (add-var n v))\n        (set-invalid-error n v)))\n    @obj))\n\n(defn read-binary-frame [in-stream frame-name & {:keys [:le-frames]}]\n  (binding [*env* {:in in-stream :vars {} :le-frames (set le-frames)}]\n    (let [value (read-frame frame-name)]\n      (when-let [e (:error *env*)]\n        (throw e))\n      value)))\n\n;; Write\n(defn- write-bytes [^bytes bytea]\n  (let [^OutputStream out (:out *env*)]\n    (.write out bytea)))\n\n(declare write-frame)\n(defn- write-one [[type] value]\n  (if-let [[size unsigned?] (get primitives type)]\n    (let [bytea (->bytes size value)\n          bytea (if (:le? *env*) (areverse-byte bytea) bytea)]\n      (write-bytes bytea))\n    (write-frame type value)))\n\n(defn- write-array [[type size :as field] value]\n  (assert (= (count value) size))\n  (if (= type :bytes)\n    (write-bytes value)\n    (doseq [v value]\n      (write-one field v))))\n\n(defn- write-bits [[bit-pattern] values]\n  (let [bit-size (apply + bit-pattern)\n        byte-size (/ bit-size 8)\n        offsets (map #(- bit-size %) (reductions + bit-pattern))\n        v (apply bit-or (map #(-> (bit-mask %1 %2) (<< %3))\n                             values bit-pattern offsets))]\n    (write-bytes (->bytes byte-size v))))\n\n(defn- write-field [[type size :as field] value]\n  ((cond\n    (sequential? type) write-bits\n    (integer? size) write-array\n    :else write-one) field value))\n\n(defn- write-frame [frame-name obj]\n  (bswap! *env* assoc :le? ((:le-frames *env*) (keyword frame-name)))\n  (doseq [field (get-frame-fields frame-name)\n          :let [[type size name func :as field] (calc-size field)]\n          :when size\n          :while (not (:error *env*))\n          :let [value (map+ false #(get obj %) name)]]\n    (doseq [[n f v] (map+ true list name func value)]\n      (if (f v)\n        (add-var n v)\n        (set-invalid-error n v)))\n    (when-not (:error *env*)\n      (write-field field value))))\n\n(defn write-binary-frame [out-stream frame-name obj & {:keys [:le-frames]}]\n  (binding [*env* {:out out-stream :vars {} :le-frames (set le-frames)}]\n    (write-frame frame-name obj)\n    (when-let [e (:error *env*)]\n      (throw e))))\n\n\n\n\u4f5c\u3063\u3066\u307f\u305f\u611f\u60f3\u306a\u3069\n\u9069\u5f53\u306b\u66f8\u304f\u5206\u306b\u306f\u3044\u3044\u306e\u3067\u3059\u304c\u3001\u304d\u308c\u3044\u306b\u66f8\u304f\u306e\u306f\u96e3\u3057\u3044\u306a\u3042\u3068\u601d\u3044\u307e\u3057\u305f\u3002\nClojure\u3067\u30b3\u30fc\u30c9\u3092\u5927\u91cf\u306b\u66f8\u304f\u5834\u5408\u306e\u30d9\u30b9\u30c8\u30d7\u30e9\u30af\u30c6\u30a3\u30b9\u306e\u3088\u3046\u306a\u3082\u306e\u3063\u3066\u3042\u308b\u3093\u3067\u3057\u3087\u3046\u304b\uff1f\n\u82e5\u5e72\u3001\u884c\u3092\u77ed\u304f\u3059\u308b\u305f\u3081\u306b\u6c4e\u7528\u5316\u3057\u3059\u304e\u3066\u3044\u308b\u3088\u3046\u306a\u6c17\u3082\u3057\u3066\u3044\u307e\u3059\u3002\n\u3053\u308c\u3089\u306b\u3064\u3044\u3066\u4f55\u304b\u306e\u53c2\u8003\u306b\u306a\u308c\u3070\u5e78\u3044\u3067\u3059\u3002\nWireshark\u3084`tcpdump -w`\u3067\u51fa\u529b\u3055\u308c\u308bpcap\u30d5\u30a1\u30a4\u30eb\u3092\u3053\u306d\u3053\u306d\u3067\u304d\u308b\u4f55\u304b\u3002\n\u306a\u304b\u306a\u304b\u3044\u3044\u306e\u304c\u306a\u3044\u306e\u3067\u4f5c\u3063\u3066\u307f\u3088\u3046\u3068\u601d\u3044\u307e\u3057\u305f\u3002\njNetPcap\u3068\u304b\u4f7f\u3046\u306e\u96e3\u3057\u304f\u3066\u3081\u3093\u3069\u305d\u3046\u3060\u3057\u3001Clojure\u306e\u30d0\u30a4\u30ca\u30ea\u30d1\u30fc\u30b5\u3068\u3057\u3066\u306fbuffy\u3068\u304b\u3042\u308a\u307e\u3059\u304c\u3001\u75d2\u3044\u6240\u306b\u624b\u304c\u5c4a\u304d\u307e\u305b\u3093\u3002\n\n\u305d\u3053\u3067\u3001\u7c21\u5358\u306b\u4f7f\u3048\u308b\u30d0\u30a4\u30ca\u30ea\u30d1\u30fc\u30b5\u3092\u4f5c\u3063\u3066\u3001\u30d1\u30b1\u30c3\u30c8\u30ad\u30e3\u30d7\u30c1\u30e3\u3092\u8aad\u307f\u66f8\u304d\u3067\u304d\u308b\u4f55\u304b\u3092\u4f5c\u308d\u3046\u3068\u3044\u3046\u308f\u3051\u3067\u3059\u3002\n\n# \u65b9\u91dd\n\n\u6a5f\u80fd\u3068\u3057\u3066\u5b9f\u73fe\u3057\u305f\u3044\u3082\u306e\n\n* \u30b5\u30a4\u30ba\u8a08\u7b97\uff1a\u96fb\u6587\u5185\u306e\u30b5\u30a4\u30ba\u30d5\u30a3\u30fc\u30eb\u30c9\u3092\u3082\u3068\u306b\u3001\u53ef\u5909\u30b5\u30a4\u30ba\u306e\u30d5\u30a3\u30fc\u30eb\u30c9\u3092\u7c21\u5358\u306b\u6271\u3044\u305f\u3044\n* \u30d3\u30c3\u30c8\u30d5\u30a3\u30fc\u30eb\u30c9\uff1aIP\u30d8\u30c3\u30c0\u3068\u304b\u306b\u3042\u308b4\u30d3\u30c3\u30c8\u306e\u30d5\u30a3\u30fc\u30eb\u30c9\u3092\u6574\u6570\u3068\u3057\u3066\u7c21\u5358\u306b\u6271\u3044\u305f\u3044\n* \u30d0\u30ea\u30c7\u30fc\u30b7\u30e7\u30f3\uff1a\u8aad\u307f\u8fbc\u3093\u3067\u3044\u308b\u30d0\u30a4\u30ca\u30ea\u304c\u9014\u4e2d\u3067\u9593\u9055\u3063\u3066\u3044\u306a\u3044\u304b\u7c21\u5358\u306b\u78ba\u8a8d\u3067\u304d\u308b\u4ed5\u7d44\u307f\u304c\u307b\u3057\u3044\n* \u5206\u5c90\uff1aIP\u30d1\u30b1\u30c3\u30c8\u3068ARP\u30d1\u30b1\u30c3\u30c8\u3068\u304b\u3067\u5206\u5c90\u3057\u3066\u51e6\u7406\u3067\u304d\u308b\u3088\u3046\u306b\u3057\u305f\u3044\n* unsigned\u3092\u6271\u3044\u305f\u3044\n* \u30a8\u30f3\u30c7\u30a3\u30a2\u30f3\uff1apcap\u30d5\u30a1\u30a4\u30eb\u306eGlobalHeader\u3084RecordHeader\u306e\u90e8\u5206\u304cLE\u3067\u96fb\u6587\u306e\u90e8\u5206\u304cBE\u3060\u3063\u305f\u308a\u3059\u308b\u306e\u3067\n\n\u3053\u308c\u3089\u306e\u6a5f\u80fd\u3092\u7c21\u5358\u306b\u30a8\u30ec\u30ac\u30f3\u30c8\u306b\u5b9f\u88c5\u3057\u305f\u3044\u30fb\u30fb\u30fb\u3067\u3059\n\n# \u30d0\u30a4\u30ca\u30ea\u30d5\u30ec\u30fc\u30e0\u306e\u5b9a\u7fa9\n\n\u30d0\u30a4\u30ca\u30ea\u30d5\u30ec\u30fc\u30e0\u306b\u3064\u3044\u3066\u3001\u30d5\u30a3\u30fc\u30eb\u30c9\u3054\u3068\u306b`\u578b:\u30b5\u30a4\u30ba` `\u540d\u524d:\u30d0\u30ea\u30c7\u30fc\u30b7\u30e7\u30f3\u95a2\u6570`\u3092\u5b9a\u7fa9\u3067\u304d\u308b\u3053\u3068\u3092\u76ee\u6307\u3057\u307e\u3059\u3002\n\u30b5\u30a4\u30ba\u3068\u30d0\u30ea\u30c7\u30fc\u30b7\u30e7\u30f3\u95a2\u6570\u306f\u7701\u7565\u53ef\u80fd\u3068\u3057\u307e\u3059\u3002\nTCP\u30d8\u30c3\u30c0\u306e\u5b9a\u7fa9\u3068\u3057\u3066\u306f\u3001\u4ee5\u4e0b\u306e\u3088\u3046\u306b\u306a\u308a\u307e\u3059\u3002\n\n```tcpheader.clj\n(def-frame :TcpHeader\n  :uint16 :SourcePort\n  :uint16 :DestinationPort\n  :int32 :SequenceNumber\n  :int32 :AcknowledgmentNumber\n  [4 3 9] [:DataOffset:ge5? :Reserved:zero? :ControlBits]\n  :uint16 :Window\n  :int16 :Checksum\n  :int16 :UrgentPointer\n  \"int32:(- DataOffset 5)\" :Options)\n```\n\n\u578b\u306f\u6574\u6570\u3092\u8868\u3059`int8` `uint8` `int16` `uint16` `int32` `uint32`\u3068\u3001\u30d3\u30c3\u30c8\u30d5\u30a3\u30fc\u30eb\u30c9\u3092\u8868\u3059\u30d9\u30af\u30bf`[\uff5e]`\u3068\u3001\u30d0\u30a4\u30ca\u30ea\u3092\u8868\u3059`bytes`\u3092\u6271\u3048\u308b\u3088\u3046\u306b\u3057\u307e\u3059\u3002\n\u203b\u30d3\u30c3\u30c8\u30d5\u30a3\u30fc\u30eb\u30c9\u306f\u5408\u8a08\u304c8\u306e\u500d\u6570\u304b\u3064\u5408\u8a08\u304c64\u307e\u3067\u306e\u5236\u9650\u3042\u308a\n\n\u30b5\u30a4\u30ba\u306b\u3064\u3044\u3066\u306f\u3001`(- DataOffset 5)`\u306e\u3088\u3046\u306b\u524d\u306e\u307b\u3046\u306b\u3042\u308b\u30d5\u30a3\u30fc\u30eb\u30c9\u306e\u5024\u3092\u53c2\u7167\u3057\u3066\u8a2d\u5b9a\u3067\u304d\u308b\u3088\u3046\u306b\u3057\u307e\u3059\u3002\n\u203b\u6574\u6570\u3067\u306a\u304ftrue/false\u3067\u306e\u6307\u5b9a\u3082\u3042\u308b\u3051\u3069\u5f8c\u307b\u3069\u30fb\u30fb\u30fb\n\n\u30d0\u30ea\u30c7\u30fc\u30b7\u30e7\u30f3\u95a2\u6570\u306f`(def-validator :ge5? #(<= 5 %))`\u306e\u3088\u3046\u306b\u3057\u3066\u3042\u3089\u304b\u3058\u3081\u5b9a\u7fa9\u3057\u3066\u4f7f\u3048\u308b\u3088\u3046\u306b\u3057\u307e\u3059\u3002\n\n\u4ee5\u4e0b\u3001\u3053\u308c\u3089\u306e\u5b9a\u7fa9\u65b9\u6cd5\u3067\u3082\u3063\u3066\u30d0\u30a4\u30ca\u30ea\u30d5\u30ec\u30fc\u30e0\u306e\u5b9a\u7fa9\u3092\u3057\u3066\u3044\u304d\u307e\u3059\u3002\n\n# pcap\u30d5\u30a1\u30a4\u30eb\u306e\u30d8\u30c3\u30c0\n\npcap\u30d5\u30a1\u30a4\u30eb\u306b\u306f1\u3064\u306eGlobalHeader\u304c\u5148\u982d\u306b\u3042\u308a\u3001\u305d\u306e\u5f8c\u306b\u30d1\u30b1\u30c3\u30c8\u3054\u3068\u306bRecordHeader\u3068\u30d1\u30b1\u30c3\u30c8\u5185\u5bb9\u304c\u7d9a\u3044\u3066\u3044\u304d\u307e\u3059\u3002\n\n```pcap-header.clj\n(def-frame :GlobalHeaderFirst\n  :uint32 :magic_number) ;magic number\n\n(def-frame :GlobalHeaderRest\n  :uint16 :version_major ;major version number\n  :uint16 :version_minor ;minor version number\n  :int32 :thiszone       ;GMT to local correction\n  :uint32 :sigfigs       ;accuracy of timestamps\n  :uint32 :snaplen       ;max length of captured packets, in octets\n  :uint32 :network)      ;data link type\n\n(def-frame :RecordHeader\n  :uint32 :ts_sec    ;timestamp seconds\n  :uint32 :ts_usec   ;timestamp microseconds\n  :uint32 :incl_len  ;number of octets of packet saved in file\n  :uint32 :orig_len) ;actual length of packet\n```\n\nGlobalHeader\u306emagic_number\u304c0xd4c3b2a1\u306e\u5834\u5408\u3001GlobalHeader\u3068RecordHeader\u306e\u90e8\u5206\u304c\u30ea\u30c8\u30eb\u30a8\u30f3\u30c7\u30a3\u30a2\u30f3\u306b\u306a\u308a\u307e\u3059\u3002\uff08\u96fb\u6587\u306f\u30d3\u30c3\u30b0\u30a8\u30f3\u30c7\u30a3\u30a2\u30f3\uff09\n\u203b\u30d1\u30b1\u30c3\u30c8\u5185\u5bb9\u306e\u5b9a\u7fa9\u306b\u3064\u3044\u3066\u306f\u5f8c\u307b\u3069\n\n# \u30cd\u30c3\u30c8\u30ef\u30fc\u30af\u30d8\u30c3\u30c0\u306e\u5b9a\u7fa9\n\n\u4e0a\u306eGlobalHeaderRest\u306enetwork\u304c1\u306e\u3068\u304d\u3001\u30d1\u30b1\u30c3\u30c8\u5185\u5bb9\u306b\u306fEthernet\u30d5\u30ec\u30fc\u30e0\u304c\u5165\u3063\u3066\u3044\u307e\u3059\u3002\u305d\u306e\u524d\u63d0\u3067\u9032\u3081\u307e\u3059\u3002\n\nEthernet\u3068IPv4\u3068TCP\u30d8\u30c3\u30c0\u306e\u5b9a\u7fa9\u306f\u4ee5\u4e0b\u306e\u3068\u304a\u308a\n\n```header.clj\n(def-frame :Ethernet2Header\n  :int8:6 :DestinationAddress\n  :int8:6 :SourceAddress\n  :uint16 :EtherType)\n\n(def-frame :Ipv4Header\n  [4 4] [\"Version:#(= 4 %)\" :IHL:ge5?]\n  :int8 :TOS\n  :uint16 :TL\n  :int16 :Identification\n  [3 13] [:Flags :FragmentOffset]\n  :uint8 :TTL\n  :uint8 :Protocol\n  :int16 :HeaderChecksum\n  :uint8:4 :SourceAddress\n  :uint8:4 :DestinationAddress\n  \"int32:(- IHL 5)\" :Options)\n\n(def-frame :TcpHeader\n  :uint16 :SourcePort\n  :uint16 :DestinationPort\n  :int32 :SequenceNumber\n  :int32 :AcknowledgmentNumber\n  [4 3 9] [:DataOffset:ge5? :Reserved:zero? :ControlBits]\n  :uint16 :Window\n  :int16 :Checksum\n  :int16 :UrgentPointer\n  \"int32:(- DataOffset 5)\" :Options)\n```\n\n# \u30d1\u30b1\u30c3\u30c8\u5185\u5bb9\u306e\u90e8\u5206\u306e\u5b9a\u7fa9\n\n```ether.clj\n(def-frame :EtherRecord\n  :RecordHeader :header\n  :Ethernet2Frame :ether)\n\n(def-frame :Ethernet2Frame\n  :Ethernet2Header :header\n  \"Ipv4Frame:(= EtherType 0x0800)\" :ipv4\n  \"ArpFrame:(= EtherType 0x0806)\" :arp\n  \"bytes:(if (not-any? #(= EtherType %) [0x0800 0x0806]) (- incl_len 14) false)\" :unknown)\n```\n\nEthernet\u30d5\u30ec\u30fc\u30e0\u3068\u3057\u3066\u3001IPv4\u3068ARP\u30d5\u30ec\u30fc\u30e0\u3092\u6271\u3046\u4f8b\u3067\u3059\u3002\n\u30b5\u30a4\u30ba\u306e\u90e8\u5206\u3092true/false\u3067\u6307\u5b9a\u3059\u308b\u3068\u914d\u5217\u3067\u306a\u3044\u578b\u3092\u8868\u3059\u3088\u3046\u306b\u3057\u3066\u3001\u5206\u5c90\u3092\u5b9f\u73fe\u3067\u304d\u308b\u3088\u3046\u306b\u3057\u3066\u3044\u307e\u3059\u3002\nEtherType\u306fEthernet2Header\u306e\u4e2d\u3067\u5b9a\u7fa9\u3055\u308c\u3066\u3044\u3066\u3001\u305d\u306e\u5024\u306b\u3088\u3063\u3066\u5206\u5c90\u3059\u308b\u3068\u3044\u3046\u3053\u3068\u3067\u3059\u3002\n\n\u6b8b\u308a\u306f\u4ee5\u4e0b\u306e\u3068\u304a\u308a\n\n```body.clj\n(def-frame :Ipv4Frame\n  :Ipv4Header :header\n  \"IcmpFrame:(= Protocol 1)\" :icmp\n  \"TcpFrame:(= Protocol 6)\" :tcp\n  \"bytes:(if (not-any? #(= Protocol %) [1 6]) (- incl_len 14 (* 4 IHL)) false)\" :unknown)\n\n(def-frame :ArpFrame\n  :uint16 :HTYPE\n  :uint16 :PTYPE\n  :uint8 :HLEN\n  :uint8 :PLEN\n  :int16 :OPER\n  :int8:6 :SHA\n  :uint8:4 :SPA\n  :int8:6 :THA\n  :uint8:4 :TPA\n  \"bytes:(- incl_len 42)\" :padding)\n\n(def-frame :TcpFrame\n  :TcpHeader :header\n  \"bytes:(- incl_len 14 (* 4 (+ IHL DataOffset)))\" :payload)\n\n(def-frame :IcmpFrame\n  :uint8 :type\n  :int8 :code\n  :int16 :checksum\n  \"bytes:(- incl_len 18 (* 4 IHL))\" :others)\n```\n\n# \u5b9f\u73fe\u3059\u308b\u305f\u3081\u306e\u30b3\u30fc\u30c9\n\u4ee5\u4e0a\u306e\u3088\u3046\u306a\u5b9a\u7fa9\u306b\u3082\u3068\u3065\u3044\u3066\u3001\u30d0\u30a4\u30ca\u30ea\u3092\u8aad\u307f\u8fbc\u3093\u3067\u30de\u30c3\u30d7\u3092\u51fa\u529b\u3059\u308b\u6a5f\u80fd\u3068\u3001\u9006\u306b\u30de\u30c3\u30d7\u304b\u3089\u30d0\u30a4\u30ca\u30ea\u3092\u66f8\u304d\u8fbc\u3080\u6a5f\u80fd\u304c\u3001\u7a7a\u884c\u5165\u308c\u3066\u3082250\u884c\u7a0b\u5ea6\u3067\u3067\u304d\u307e\u3057\u305f\u3002\n\uff03\u3082\u3063\u3068\u77ed\u304f\u30a8\u30ec\u30ac\u30f3\u30c8\u306a\u66f8\u304d\u65b9\u3067\u304d\u308c\u3070\u3044\u3044\u306a\u3042\n\uff03\u3042\u3093\u307e\u308a\u30c6\u30b9\u30c8\u3067\u304d\u3066\u306a\u3044\u3051\u3069\u30fb\u30fb\u30fb\n\n\u4f7f\u3044\u65b9\u306f\n\n```sample.clj\n(def pcap (io/input-stream \"sample.pcap\"))\n(read-binary-frame pcap :GlobalHeaderFirst)\n(read-binary-frame pcap :GlobalHeaderRest :le-frames [:GlobalHeaderRest])\n(read-binary-frame pcap :EtherRecord :le-frames [:RecordHeader])\n```\n\n\u306e\u3088\u3046\u306a\u611f\u3058\u3067\u3059\u3002\uff08\u5b9f\u969b\u306b\u306f:EtherRecord\u306e\u8aad\u307f\u8fbc\u307f\u3092\u8907\u6570\u56de\u3059\u308b\u3053\u3068\u306b\u306a\u308a\u307e\u3059\uff09\n\n\u307e\u305a\u306f\u3001\u30e6\u30fc\u30c6\u30a3\u30ea\u30c6\u30a3\u7cfb\u306e\u95a2\u6570\u3092\u5b9a\u7fa9\u3057\u307e\u3059\u3002\n\n```util.clj\n(ns bin-parser.util)\n\n(def << bit-shift-left)\n(def >> bit-shift-right)\n(def >>> unsigned-bit-shift-right)\n\n(defn bit-mask [value bit]\n  {:pre [(<= 1 bit 64)]}\n  (bit-and value (>>> -1 (- 64 bit))))\n\n(defn constantly-true [& _] true)\n(defn ->symbol [x] (symbol (name x)))\n(defn map->vec [map] (vec (apply concat map)))\n\n(defn exact-get [map key]\n  (if-let [[k v] (find map key)]\n    v\n    (throw (IllegalArgumentException. (str key \" not found\")))))\n\n(defmacro bswap! [x f & args]\n  `(set! ~x (~f ~x ~@args)))\n\n(defn areverse-byte [^bytes bytea]\n  (let [len (alength bytea)]\n    (areduce bytea i ret (byte-array len)\n             (do (aset-byte ret (- len i 1) (aget bytea i)) ret))))\n\n(defn unsigned [^bytes bytea]\n  {:pre [(<= 1 (alength bytea) 7)]}\n  (areduce bytea i ret 0\n           (bit-or (<< ret 8) (bit-and 0xff (aget bytea i)))))\n\n(defn signed [^bytes bytea]\n  {:pre [(<= 1 (alength bytea) 8)]}\n  (areduce bytea i ret (if (neg? (aget bytea 0)) -1 0)\n           (bit-or (<< ret 8) (bit-and 0xff (aget bytea i)))))\n\n(defn ^bytes ->bytes [^long len ^long value]\n  {:pre [(<= 1 len 8)]}\n  (byte-array\n   (reduce (fn [a i] (conj a (>> value (* (- len i 1) 8)))) [] (range len))))\n\n(defn split-once [string sep]\n  (let [s (name string)\n        i (.indexOf s sep)]\n    (if (neg? i)\n      [s nil]\n      [(subs s 0 i) (subs s (+ i (count sep)))])))\n```\n\n`exact-get`\u306fget\u3067\u304d\u306a\u304b\u3063\u305f\u3089\u4f8b\u5916\u3092\u6295\u3052\u308b\u3084\u3064\u3067\u3059\u3002\n`bswap!`\u306f\u52d5\u7684\u5909\u6570(binding\u3092\u4f7f\u3046\u30a2\u30ec)\u7528\u306eswap!\u3067\u3059\u3002\n`areverse-byte`\u306fbyte\u914d\u5217\u7528\u306ereverse\u3067\u3059\u3002\n`unsigned`\u3068`signed`\u306fbyte\u914d\u5217\u304b\u3089\u6574\u6570\u3078\u306e\u5909\u63db\u3067\u3059\u3002\n`->bytes`\u306f\u6574\u6570\u304b\u3089\u6307\u5b9a\u9577\u306ebyte\u914d\u5217\u3078\u306e\u5909\u63db\u3067\u3059\u3002\n`split-once`\u306f\u6587\u5b57\u5217\u30921\u56de\u3060\u3051split\u3059\u308b\u3084\u3064\u3067\u3059\u3002\n\n\u3053\u3053\u307e\u3067\u3067\u7d0450\u884c\n\n# \u30d5\u30ec\u30fc\u30e0\u5b9a\u7fa9\u90e8\u5206\u306e\u30b3\u30fc\u30c9\n\n`frames`\u306f`def-frame`\u3057\u305f\u3068\u304d\u306e\u5b9a\u7fa9\u306e\u4fdd\u5b58\u5834\u6240\u3067\u3059\u3002\n`size-symbols`\u306f\u30b5\u30a4\u30ba\u306e\u90e8\u5206\u306esymbol\u3092\u4fdd\u5b58\u3057\u3066\u304a\u304f\u5834\u6240\u3067\u3059\u3002\n`(- DataOffset 5)`\u3068\u30b5\u30a4\u30ba\u5b9a\u7fa9\u304c\u3042\u3063\u305f\u3089`-`\u3068`DataOffset`\u304c\u5165\u308a\u307e\u3059\u3002\uff08`-`\u306f\u4e0d\u8981\u306a\u3093\u3060\u3051\u3069\uff09\n`validators`\u306f`def-validator`\u3057\u305f\u3068\u304d\u306e\u5b9a\u7fa9\u306e\u4fdd\u5b58\u5834\u6240\u3067\u3059\u3002\n\n```core_1.clj\n(ns bin-parser.core\n  (:require [bin-parser.util :refer :all])\n  (:import [java.io InputStream OutputStream IOException]))\n\n(def ^:private frames (atom {}))\n(def ^:private size-symbols (atom #{}))\n(def ^:private validators (atom {}))\n\n;; Frame\n(defn def-validator [validator-name f]\n  (swap! validators assoc (->symbol validator-name) f))\n\n(defn- split-field-item [item]\n  (let [[base suffix] (split-once item \":\")\n        suffix (when suffix (read-string suffix))]\n    [(keyword base) suffix]))\n\n(defn- split-field-name [item]\n  (let [[base func] (split-field-item item)\n        func (if (nil? func)\n               constantly-true\n               (eval (list 'let (map->vec @validators) func)))]\n    [base func]))\n\n(defn- check-bits [bit-pattern names]\n  {:pre [(zero? (mod (apply + bit-pattern) 8))\n         (<= (apply + bit-pattern) 64)\n         (= (count bit-pattern) (count names))]}\n  true)\n\n(defn- find-size-symbols [field-type]\n  (let [[_ size] (split-field-item field-type)]\n    (swap! size-symbols into (filter symbol? (flatten size)))))\n\n(defn def-frame [frame-name & field-type+names]\n  {:pre [(even? (count field-type+names))]}\n  (let [fields (partition 2 field-type+names)\n        array (volatile! [])]\n    (doseq [[type name] fields]\n      (if (sequential? type)\n        (check-bits type name)\n        (find-size-symbols type))\n      (let [field (if (sequential? type)\n                    (list* type nil (apply map list (map split-field-name name)))\n                    (concat (split-field-item type) (split-field-name name)))]\n        (vswap! array conj (vec field))))\n    (swap! frames assoc (keyword frame-name) @array)))\n```\n\n\u3053\u3053\u307e\u3067\u3067\u7d04100\u884c\n\n# \u8aad\u307f\u8fbc\u307f\u3068\u66f8\u304d\u8fbc\u307f\u90e8\u5206\n\n\u6b8b\u308a\u7d04150\u884c\u3067\u3059\u304c\u3001\u5168\u90e8\u8aac\u660e\u306f\u96e3\u3057\u3044\u306e\u3067\u3044\u304f\u3064\u304b\u3060\u3051\u3002\n`*env*`\u306b\u306f`size-symbols`\u306b\u5b58\u5728\u3059\u308b\u30d5\u30a3\u30fc\u30eb\u30c9\u306e\u5024\u3092`:vars`\u306b\u5165\u308c\u3066\u3044\u304f\u3053\u3068\u3067\u3001\u30b5\u30a4\u30ba\u306e\u8a08\u7b97(\u89e3\u6c7a)\u3092\u3067\u304d\u308b\u3088\u3046\u306b\u3057\u3066\u3044\u307e\u3059\u3002\n`read-field`\u3067`(bswap! *env* assoc :error th)`\u306e\u3088\u3046\u306b\u3057\u3066\u3001`read-frame`\u306e`doseq`\u3067`:while (not (:error *env*))`\u306e\u3088\u3046\u306b\u3057\u3066\u3044\u308b\u306e\u306f\u3001\u8aad\u307f\u8fbc\u307f\u9014\u4e2d\u3067\u30a8\u30e9\u30fc\u304c\u8d77\u3053\u3063\u305f\u6642\u306b\u3001\u3069\u3053\u307e\u3067\u8aad\u307f\u8fbc\u3081\u3066\u308b\u304b\u30c7\u30d0\u30c3\u30b0\u3057\u3084\u3059\u304f\u3059\u308b\u305f\u3081\u3067\u3059\u3002\n\n```core_2.clj\n;; Read/Write\n(def ^:private primitives\n  {:int8 [1 nil]\n   :uint8 [1 :unsigned]\n   :int16 [2 nil]\n   :uint16 [2 :unsigned]\n   :int32 [4 nil]\n   :uint32 [4 :unsigned]})\n\n(declare ^:private ^:dynamic *env*)\n\n(defn- get-frame-fields [frame-name]\n  (exact-get @frames (keyword frame-name)))\n\n(defn- calc-size [[_ size :as field]]\n  (let [size (if (nil? size) true size)]\n    (assoc field 1 (eval (list 'let (map->vec (:vars *env*)) size)))))\n\n(defn- add-var [field-name value]\n  (let [sym (->symbol field-name)]\n    (when (contains? @size-symbols sym)\n      (bswap! *env* assoc-in [:vars sym] value))))\n\n(defn- set-invalid-error [n v]\n  (bswap! *env* assoc :error\n          (IllegalArgumentException. (str \"invalid \" n \" value \" v))))\n\n(defn- map+ [wrap? f c1 & colls]\n  (if (sequential? c1)\n    (apply map f c1 colls)\n    (let [v (apply f c1 colls)]\n      (if wrap? [v] v))))\n\n;; Read\n(defn- read-bytes [size]\n  (let [^InputStream in (:in *env*)\n        bytea (byte-array size)\n        len (.read in bytea)]\n    (when (not= len size) (throw (IOException. (str len \" != \" size))))\n    bytea))\n\n(declare read-frame)\n(defn- read-one [[type]]\n  (if-let [[size unsigned?] (get primitives type)]\n    (let [bytea (read-bytes size)\n          bytea (if (:le? *env*) (areverse-byte bytea) bytea)]\n      (if unsigned? (unsigned bytea) (signed bytea)))\n    (read-frame type)))\n\n(defn- read-array [[type size :as field]]\n  (if (= type :bytes)\n    (read-bytes size)\n    (mapv (fn [_] (read-one field)) (range size))))\n\n(defn- read-bits [[bit-pattern]]\n  (let [bit-size (apply + bit-pattern)\n        byte-size (/ bit-size 8)\n        bytea (read-bytes byte-size)\n        offsets (map #(- bit-size %) (reductions + bit-pattern))]\n    (map #(-> (signed bytea) (>> %1) (bit-mask %2)) offsets bit-pattern)))\n\n(defn- read-field [[type size :as field]]\n  (try\n    ((cond\n      (sequential? type) read-bits\n      (integer? size) read-array\n      :else read-one) field)\n    (catch Throwable th\n      (bswap! *env* assoc :error th)\n      nil)))\n\n(defn- read-frame [frame-name]\n  (bswap! *env* assoc :le? ((:le-frames *env*) (keyword frame-name)))\n  (let [obj (volatile! {})]\n    (doseq [field (get-frame-fields frame-name)\n            :let [[type size name func :as field] (calc-size field)]\n            :when size\n            :let [value (read-field field)]\n            :while (not (:error *env*))\n            [n f v] (map+ true list name func value)]\n      (if (f v)\n        (do (vswap! obj assoc n v) (add-var n v))\n        (set-invalid-error n v)))\n    @obj))\n\n(defn read-binary-frame [in-stream frame-name & {:keys [:le-frames]}]\n  (binding [*env* {:in in-stream :vars {} :le-frames (set le-frames)}]\n    (let [value (read-frame frame-name)]\n      (when-let [e (:error *env*)]\n        (throw e))\n      value)))\n\n;; Write\n(defn- write-bytes [^bytes bytea]\n  (let [^OutputStream out (:out *env*)]\n    (.write out bytea)))\n\n(declare write-frame)\n(defn- write-one [[type] value]\n  (if-let [[size unsigned?] (get primitives type)]\n    (let [bytea (->bytes size value)\n          bytea (if (:le? *env*) (areverse-byte bytea) bytea)]\n      (write-bytes bytea))\n    (write-frame type value)))\n\n(defn- write-array [[type size :as field] value]\n  (assert (= (count value) size))\n  (if (= type :bytes)\n    (write-bytes value)\n    (doseq [v value]\n      (write-one field v))))\n\n(defn- write-bits [[bit-pattern] values]\n  (let [bit-size (apply + bit-pattern)\n        byte-size (/ bit-size 8)\n        offsets (map #(- bit-size %) (reductions + bit-pattern))\n        v (apply bit-or (map #(-> (bit-mask %1 %2) (<< %3))\n                             values bit-pattern offsets))]\n    (write-bytes (->bytes byte-size v))))\n\n(defn- write-field [[type size :as field] value]\n  ((cond\n    (sequential? type) write-bits\n    (integer? size) write-array\n    :else write-one) field value))\n\n(defn- write-frame [frame-name obj]\n  (bswap! *env* assoc :le? ((:le-frames *env*) (keyword frame-name)))\n  (doseq [field (get-frame-fields frame-name)\n          :let [[type size name func :as field] (calc-size field)]\n          :when size\n          :while (not (:error *env*))\n          :let [value (map+ false #(get obj %) name)]]\n    (doseq [[n f v] (map+ true list name func value)]\n      (if (f v)\n        (add-var n v)\n        (set-invalid-error n v)))\n    (when-not (:error *env*)\n      (write-field field value))))\n\n(defn write-binary-frame [out-stream frame-name obj & {:keys [:le-frames]}]\n  (binding [*env* {:out out-stream :vars {} :le-frames (set le-frames)}]\n    (write-frame frame-name obj)\n    (when-let [e (:error *env*)]\n      (throw e))))\n```\n\n# \u4f5c\u3063\u3066\u307f\u305f\u611f\u60f3\u306a\u3069\n\n\u9069\u5f53\u306b\u66f8\u304f\u5206\u306b\u306f\u3044\u3044\u306e\u3067\u3059\u304c\u3001\u304d\u308c\u3044\u306b\u66f8\u304f\u306e\u306f\u96e3\u3057\u3044\u306a\u3042\u3068\u601d\u3044\u307e\u3057\u305f\u3002\nClojure\u3067\u30b3\u30fc\u30c9\u3092\u5927\u91cf\u306b\u66f8\u304f\u5834\u5408\u306e\u30d9\u30b9\u30c8\u30d7\u30e9\u30af\u30c6\u30a3\u30b9\u306e\u3088\u3046\u306a\u3082\u306e\u3063\u3066\u3042\u308b\u3093\u3067\u3057\u3087\u3046\u304b\uff1f\n\u82e5\u5e72\u3001\u884c\u3092\u77ed\u304f\u3059\u308b\u305f\u3081\u306b\u6c4e\u7528\u5316\u3057\u3059\u304e\u3066\u3044\u308b\u3088\u3046\u306a\u6c17\u3082\u3057\u3066\u3044\u307e\u3059\u3002\n\u3053\u308c\u3089\u306b\u3064\u3044\u3066\u4f55\u304b\u306e\u53c2\u8003\u306b\u306a\u308c\u3070\u5e78\u3044\u3067\u3059\u3002\n", "tags": ["Clojure", "Network"]}