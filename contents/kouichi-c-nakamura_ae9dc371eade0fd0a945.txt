{"context": "If you are impatient, you might want to put up a progress bar or waitbar() during long for loop in MATLAB. However, you should avoid use of waitbar() or you have to use it efficiently. MATLAB's drawing is notoriously slow. waitbar() suffers from it. \n\nwaitbar() may be suitable when ...\n1. You really need elaborated progress message during runtime.\n2. You need a Cancel button during the process.\n3. In the for loop, the number of iterations is relatively small.\n4. One iteration takes quite a long time (eg. > a few minuntes).\nOtherwise, you should think of using simple frpintf() instead. It's not really cool in appearance, but it is much faster if you only want to know where you are in the iterations.\nHere is a comparison between fprintf() and waitbar(). \n\n% waitbarVAfprintf\n\ntrials = 10;\n\nelapsed1 = zeros(10,1);\nfor j = 1:10\n    clear n\n    tic\n    n = 1000;\n    fprintf('%d to go\\n',n)\n    for i = 1:n\n        fprintf('*')\n    end\n    fprintf('\\n')\n    elapsed1(j) = toc;\nend\n\nelapsed2 = zeros(10,1);\nfor j = 1:10\n    clear n\n    tic\n    n = 1000;\n    for i = 1:n\n        if round(i/n*100) > round((i-1)/n*100)\n            fprintf('*')\n        end\n    end\n    fprintf('\\n')\n    elapsed2(j) = toc;\nend\n\nelapsed3 = zeros(10,1);\nfor j = 1:10\n    clear n wbmsg wb\n    tic\n    n = 1000;\n    for i = 1:n\n        wbmsg = sprintf('In progress: %.1f%%', i/n*100);\n        if ~exist('wb', 'var')\n            wb = waitbar((i-1)/n, wbmsg);\n        else\n            waitbar((i-1)/n, wb, wbmsg);\n        end\n    end\n    delete(wb) % cannot use 'close'!!!\n    elapsed3(j) = toc;\nend\n\nelapsed4 = zeros(10,1);\nfor j = 1:10\n    clear n wbmsg wb\n    tic\n    n = 1000;\n    for i = 1:n\n        if round(i/n*100) > round((i-1)/n*100)\n            wbmsg = sprintf('In progress: %.1f%%', i/n*100);\n            if ~exist('wb', 'var')\n                wb = waitbar((i-1)/n, wbmsg);\n            else\n                waitbar((i-1)/n, wb, wbmsg);\n            end\n        end\n    end\n    delete(wb) % cannot use 'close'!!!\n    elapsed4(j) = toc;\nend\n\n%%\nfprintf('1. fprintf: %f %s %f msec per cycle\\n',...\n    mean(elapsed1),char(177),std(elapsed1));\nfprintf('2. fprintf for each %%: %f %s %f msec per cycle\\n',...\n    mean(elapsed2),char(177),std(elapsed2));\nfprintf('3. waitbar: %f %s %f msec per cycle\\n',...\n    mean(elapsed3),char(177),std(elapsed3));\nfprintf('4. waitbar for each %%: %f %s %f msec per cycle\\n',...\n    mean(elapsed4),char(177),std(elapsed4));\n\nfprintf('fprintf is %.1f-fold faster than waitbar updating at every cycle\\n',...\n    mean(elapsed3./elapsed1));\nfprintf('fprintf for each %% is %.1f-fold faster than waitbar for each %%\\n',...\n    mean(elapsed4./elapsed2));\n\nfprintf('fprintf for each %% is %.1f-fold faster than frpintf updating at every cycle\\n',...\n    mean(elapsed1./elapsed2));\nfprintf('waitbar for each %% is %.1f-fold faster than waitbar updating at every cycle\\n',...\n    mean(elapsed3./elapsed4));\n\nfprintf('fprintf for each %% is %.1f-fold faster than waitbar updating at every cycle\\n',...\n    mean(elapsed3./elapsed2));\n\n\nResults look like this.\n\nfprintf is 360.9-fold faster than waitbar updating at every cycle\nfprintf for each % is 510.3-fold faster than waitbar for each %\nfprintf for each % is 10.7-fold faster than frpintf updating at every cycle\nwaitbar for each % is 7.5-fold faster than waitbar updating at every cycle\nfprintf for each % is 3829.7-fold faster than waitbar updating at every cycle\n\n\nLook, fprintf() printing * in Command Window for each iteration (i.e. you'll see 1,000 *s in the end) is 361-fold faster than waitbar().\nWhen printing or updating only at every 1% increment in progress, fprintf() is 510-fold faster than waitbar().\nfprintf() printing * only at every 1% increment in progress (i.e. you'll see only 100 *s in the end) is 3,830-fold faster than waitbar() updating at every iteration  !!!\nConclusion: You should know that waitbar() is slow. In order to use waitbar() efficiently, it is recommended that you only update waitbar() for a certain number of iterations rather than updating it in every iteration.\n\nn = 1000;\nfor i = 1:n\n    if round(i/n*100) > round((i-1)/n*100)\n        wbmsg = sprintf('In progress: %.1f%%', i/n*100);\n        if ~exist('wb', 'var')\n            wb = waitbar((i-1)/n, wbmsg);\n        else\n            waitbar((i-1)/n, wb, wbmsg);\n        end\n    end\nend\n\n\nIf you are impatient, you might want to put up a progress bar or [`waitbar()`](http://www.mathworks.com/help/matlab/ref/waitbar.html) during long `for` loop in MATLAB. However, you should avoid use of `waitbar()` or you have to use it efficiently. MATLAB's drawing is notoriously slow. `waitbar()` suffers from it. \n\n![waitbar.png](https://qiita-image-store.s3.amazonaws.com/0/109898/b470ed88-19ae-5dbd-90d4-8d5c20c54685.png)\n\n`waitbar()` may be suitable when ...\n1. You really need elaborated progress message during runtime.\n2. You need a Cancel button during the process.\n3. In the `for` loop, the number of iterations is relatively small.\n4. One iteration takes quite a long time (eg. > a few minuntes).\n\nOtherwise, you should think of using simple `frpintf()` instead. It's not really cool in appearance, but it is much faster if you only want to know where you are in the iterations.\n\nHere is a comparison between `fprintf()` and `waitbar()`. \n\n```matlab\n\n% waitbarVAfprintf\n\ntrials = 10;\n\nelapsed1 = zeros(10,1);\nfor j = 1:10\n    clear n\n    tic\n    n = 1000;\n    fprintf('%d to go\\n',n)\n    for i = 1:n\n        fprintf('*')\n    end\n    fprintf('\\n')\n    elapsed1(j) = toc;\nend\n\nelapsed2 = zeros(10,1);\nfor j = 1:10\n    clear n\n    tic\n    n = 1000;\n    for i = 1:n\n        if round(i/n*100) > round((i-1)/n*100)\n            fprintf('*')\n        end\n    end\n    fprintf('\\n')\n    elapsed2(j) = toc;\nend\n\nelapsed3 = zeros(10,1);\nfor j = 1:10\n    clear n wbmsg wb\n    tic\n    n = 1000;\n    for i = 1:n\n        wbmsg = sprintf('In progress: %.1f%%', i/n*100);\n        if ~exist('wb', 'var')\n            wb = waitbar((i-1)/n, wbmsg);\n        else\n            waitbar((i-1)/n, wb, wbmsg);\n        end\n    end\n    delete(wb) % cannot use 'close'!!!\n    elapsed3(j) = toc;\nend\n\nelapsed4 = zeros(10,1);\nfor j = 1:10\n    clear n wbmsg wb\n    tic\n    n = 1000;\n    for i = 1:n\n        if round(i/n*100) > round((i-1)/n*100)\n            wbmsg = sprintf('In progress: %.1f%%', i/n*100);\n            if ~exist('wb', 'var')\n                wb = waitbar((i-1)/n, wbmsg);\n            else\n                waitbar((i-1)/n, wb, wbmsg);\n            end\n        end\n    end\n    delete(wb) % cannot use 'close'!!!\n    elapsed4(j) = toc;\nend\n\n%%\nfprintf('1. fprintf: %f %s %f msec per cycle\\n',...\n    mean(elapsed1),char(177),std(elapsed1));\nfprintf('2. fprintf for each %%: %f %s %f msec per cycle\\n',...\n    mean(elapsed2),char(177),std(elapsed2));\nfprintf('3. waitbar: %f %s %f msec per cycle\\n',...\n    mean(elapsed3),char(177),std(elapsed3));\nfprintf('4. waitbar for each %%: %f %s %f msec per cycle\\n',...\n    mean(elapsed4),char(177),std(elapsed4));\n\nfprintf('fprintf is %.1f-fold faster than waitbar updating at every cycle\\n',...\n    mean(elapsed3./elapsed1));\nfprintf('fprintf for each %% is %.1f-fold faster than waitbar for each %%\\n',...\n    mean(elapsed4./elapsed2));\n \nfprintf('fprintf for each %% is %.1f-fold faster than frpintf updating at every cycle\\n',...\n    mean(elapsed1./elapsed2));\nfprintf('waitbar for each %% is %.1f-fold faster than waitbar updating at every cycle\\n',...\n    mean(elapsed3./elapsed4));\n \nfprintf('fprintf for each %% is %.1f-fold faster than waitbar updating at every cycle\\n',...\n    mean(elapsed3./elapsed2));\n\n```\n\nResults look like this.\n\n```\n\nfprintf is 360.9-fold faster than waitbar updating at every cycle\nfprintf for each % is 510.3-fold faster than waitbar for each %\nfprintf for each % is 10.7-fold faster than frpintf updating at every cycle\nwaitbar for each % is 7.5-fold faster than waitbar updating at every cycle\nfprintf for each % is 3829.7-fold faster than waitbar updating at every cycle\n\n```\n\nLook, `fprintf()` printing `*` in Command Window for each iteration (i.e. you'll see 1,000 `*`s in the end) is **361-fold faster** than `waitbar()`.\n\nWhen printing or updating only at every 1% increment in progress, `fprintf()` is **510-fold faster** than `waitbar()`.\n\n`fprintf()` printing `*` only at every 1% increment in progress (i.e. you'll see only 100 `*`s in the end) is **3,830-fold faster** than `waitbar()` updating at every iteration  !!!\n\n\n**Conclusion**: You should know that `waitbar()` is slow. In order to use `waitbar()` efficiently, it is recommended that you only update `waitbar()` for a certain number of iterations rather than updating it in every iteration.\n\n```matlab\n\nn = 1000;\nfor i = 1:n\n    if round(i/n*100) > round((i-1)/n*100)\n        wbmsg = sprintf('In progress: %.1f%%', i/n*100);\n        if ~exist('wb', 'var')\n            wb = waitbar((i-1)/n, wbmsg);\n        else\n            waitbar((i-1)/n, wb, wbmsg);\n        end\n    end\nend\n\n```\n", "tags": ["matlab", "waitbar", "fprintf"]}