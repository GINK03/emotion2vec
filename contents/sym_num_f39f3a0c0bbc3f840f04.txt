{"context": "\n\n\u306f\u3058\u3081\u306b\nISLisp\u51e6\u7406\u7cfb\u3092\u81ea\u4f5c\u3057\u305f\u3068\u304d\u306bISLisp\u898f\u683c\u306b\u9069\u5408\u3057\u3066\u3044\u308b\u304b\u3069\u3046\u304b\u306e\u691c\u67fb\u306b\u304a\u4f7f\u3044\u304f\u3060\u3055\u3044\u3002\n\n\u5229\u7528\u65b9\u6cd5\n\u30b3\u30fc\u30c9\u3092\u30d5\u30a1\u30a4\u30eb\u306b\u30bb\u30fc\u30d6\u3057\u3001\u51e6\u7406\u7cfb\u304b\u3089\u30ed\u30fc\u30c9\u3057\u3066\u304f\u3060\u3055\u3044\u3002\u7d50\u679c\u304c\u753b\u9762\u8868\u793a\u3055\u308c\u307e\u3059\u3002\n\n\u7bc4\u56f2\n\u5236\u5fa1\u306e\u7279\u6b8a\u5f62\u5f0f\u306e\u90e8\u5206\u3092\u30c6\u30b9\u30c8\u3057\u3066\u3044\u307e\u3059\u3002\n\n\u51fa\u5178\nISLisp\u691c\u8a3c\u30b7\u30b9\u30c6\u30e0\nhttp://islisp.org/jp/verification-jp.html\n\n\u30b3\u30fc\u30c9\n;\n(defmacro test(form1 form2 :rest pred)\n  (cond ((null pred)\n         `(if (equal ,form1 ',form2)\n              (format (standard-output) \"\" ',form1)\n              ;;(format (standard-output) \"~S is ok~%\" ',form1)\n              (format (standard-output) \"~S is bad~%\" ',form1)))\n        ((and (not (null pred))(consp form1))\n         `(if (,@pred ,form1 ',form2)\n              (format (standard-output) \"\" ',form1)\n              ;;(format (standard-output) \"~S is ok~%\" ',form1)\n              (format (standard-output) \"~S is bad~%\" ',form1)))))\n\n;;; ;;\n(test #2a((a b c) (d e f)) #2a((a b c) (d e f)) equal)\n(test #1a(a b c) #(a b c) equal)\n(test #0a1 #0a1 equal)\n(test #\\a #\\a equal)\n(test 145932 145932 equal)\n(test \"abc\" \"abc\" equal)\n(test #(a b c) #(a b c) equal)\n(test (quote a) a equal)\n(test (quote #(a b c)) #(a b c) equal)\n(test (quote (+ 1 2)) (+ 1 2) equal)\n(test '() nil equal)\n(test 'a a equal)\n(test '#(a b c) #(a b c) equal)\n(test '(car l) (car l) equal)\n(test '(+ 1 2) (+ 1 2) equal)\n(test '(quote a) (quote a) equal)\n(test ''a (quote a) equal)\n(test (car ''a) quote equal)\n(defglobal x 0)\n(test x 0 eql)\n(test (let ((x 1)) x) 1 eql)\n(test x 0 eql)\n(defglobal x 2)\n(test (+ x 1) 3 equal)\n(test (setq x 4) 4 equal)\n(test (+ x 1) 5 equal)\n(test (let ((x 1)) (setq x 2) x) 2 equal)\n(test (+ x 1) 5 equal)\n\n(defglobal x 2)\n(test (+ x 1) 3 equal)\n(test (setf x 4) 4 equal)\n(test (+ x 1) 5 equal)\n(test (let ((x 1)) (setf x 2) x) 2 equal)\n(test (+ x 1) 5 equal)\n(setq x '(1 . 2))\n(test (setf (car x) 2) 2 equal)\n(test x (2 . 2) equal)\n\n(defmacro first (spot) `(car ,spot))\n(defglobal x '(10 20))\n(test (first x) 10 equal)\n(test (setf (first x) 2) 2)\n(test x (2 20) equal)\n;;;\n(defmacro first2 (spot) `(first ,spot))\n(defglobal x '(10 20))\n(test (first2 x) 10 equal)\n(test (setf (first2 x) 2) 2)\n(test x (2 20) equal)\n;;;\n(defmacro last (spot) `(cdr ,spot))\n(defglobal x '(10 20))\n(test (last x) (20) equal)\n(test (setf (last x) 2) 2)\n(test x (10 . 2) equal)\n;;;\n(defmacro last2 (spot) `(last ,spot))\n(defglobal x '(10 20))\n(test (last2 x) (20) equal)\n(test (setf (last2 x) 2) 2)\n(test x (10 . 2) equal)\n;;;\n(defmacro my-dynamic (spot) `(dynamic ,spot))\n(defdynamic x 3)\n(test (my-dynamic x) 3 equal)\n(test (setf (my-dynamic x) 2) 2)\n(test (my-dynamic x) 2 equal)\n;;;\n(defmacro my-dynamic2 (spot) `(my-dynamic ,spot))\n(defdynamic x 3)\n(test (my-dynamic x) 3 equal)\n(test (setf (my-dynamic2 x) 2) 2)\n(test (my-dynamic2 x) 2 equal)\n;;;\n(defmacro my-elt (seq z) `(elt ,seq ,z))\n(defglobal x '(10 20 30))\n(test (my-elt x 0) 10)\n(test (my-elt x 1) 20)\n(test (my-elt x 2) 30)\n(test (setf (my-elt x 1) 2) 2)\n(test x (10 2 30) equal)\n;;;\n(defmacro my-elt2 (seq z) `(my-elt ,seq ,z))\n(defglobal x '(10 20 30))\n(test (my-elt2 x 0) 10)\n(test (my-elt2 x 1) 20)\n(test (my-elt2 x 2) 30)\n(test (setf (my-elt2 x 1) 2) 2)\n(test x (10 2 30) equal)\n\n(defglobal x 0)\n(defmacro p () 'x)\n(test (setf (p) 9) 9)\n(test x 9)\n(test (let ()) nil)\n(test (let () 1) 1 equal)\n(test (let () 1 2) 2 equal)\n(test (let ((x 2) (y 3))\n   (* x y)) 6 equal)\n(test (let ((x 2) (y 3))\n   (let ((x 7)\n     (z (+ x y)))\n     (* z x))) 35 equal)\n(test (let ((x 1) (y 2))\n   (let ((x y) (y x))\n     (list x y))) (2 1) equal)\n\n(test (let ((x 2) (y 3))\n   (let* ((x 7)\n      (z (+ x y)))\n     (* z x))) 70 equal)\n(test (let ((x 1) (y 2))\n   (let* ((x y) (y x))\n     (list x y))) (2 2) equal)\n\n(let* ((z 1)) z)\n\n (let* ((y 1)\n        (l (lambda () y))\n    (z 2))\n   (setq x (cons l (lambda () z))))\n(test (funcall (car x)) 1)\n(test (funcall (cdr x)) 2)\n;;;\n(defglobal x ())\n(let* ((y 1)\n        (l (lambda () y))\n    (y 2))\n   (setq x (cons l (lambda () y))))\n(test (funcall (car x)) 1)\n(test (funcall (cdr x)) 2)\n(defdynamic x 3)\n(test (dynamic x) 3 equal)\n\n(defdynamic x 3)\n(test (dynamic x) 3 equal)\n(test (setf (dynamic x) 4) 4 equal)\n(test (dynamic x) 4 equal)\n\n(defun foo-1 (x)\n     (dynamic-let ((y x))\n              (bar-1 1)))\n(defun bar-1 (x)\n     (+ x (dynamic y)))\n(test (foo-1 2) 3 equal)\n\n;;;\n(defdynamic dynx 1)\n(test (dynamic-let ((dynx 2)) (dynamic dynx)) 2)\n(test (dynamic dynx) 1)\n;;;\n(test (if 1 2 3) 2 eql)\n(test (if 1 2) 2 eql)\n(test (if nil 2 3) 3 eql)\n(test (if nil 2) nil)\n(test (if (> 3 2) 'yes 'no) yes)\n(test (if (> 2 3) 'yes 'no) no)\n(test (if (> 2 3) 'yes) nil)\n(test (if (> 3 2) (- 3 2) (+ 3 2)) 1 eql)\n(test (let ((x 7))\n   (if (< x 0) x (- x))) -7 eql)\n\n(test (cond) nil equal)\n(test (cond (t)) t)\n(test (cond (1)) 1 eql)\n(test (cond ((> 3 2) 'greater)\n       ((< 3 2) 'less)) greater)\n(test (cond ((> 3 3) 'greater)\n       ((< 3 3) 'less)) nil)\n(test (cond ((> 3 3) 'greater)\n       ((< 3 3) 'less)\n       (t 'equal)) equal) \n\n(test (case 'a ((a b c)) (t 1)) nil)\n(test (case 'a ((a b c) 0) (t 1)) 0 eql)\n(test (case 'a ((a b c) 0 1) (t 1)) 1 eql)\n(test (case 'z ((a b c) 0) (t)) nil)\n(test (case 'z ((a b c) 0) (t 0)) 0 eql)\n(test (case 'z ((a b c) 0) (t 0 1)) 1 eql)\n(test (case 'd ((a b c) 0) ((z) 1)) nil)\n;;;\n(test (case (* 2 3)\n       ((2 3 5 7) 'prime)\n       ((4 6 8 9) 'composite)) composite)\n(test (case (car '(c d))\n       ((a) 'a)\n       ((b) 'b)) nil)\n(test (case (car '(c d))\n       ((a e i o u) 'vowel)\n       ((y) 'semivowel)\n       (t 'consonant)) consonant)\n\n(test (let ((char #\\u))\n   (case char\n     ((#\\a #\\e #\\i #\\o #\\u) 'vowels)\n     (t 'consonates))) vowels)\n\n(test (case-using #'string= \"a\" ((\"a\" \"b\" \"c\")) (t 2)) nil)\n(test (case-using #'string= \"a\" ((\"a\" \"b\" \"c\") 0) (t 2)) 0 equal)\n(test (case-using #'string= \"a\" ((\"a\" \"b\" \"c\") 0 1) (t 2)) 1 equal)\n(test (case-using #'string= \"z\" ((\"a\" \"b\" \"c\") 2) (t)) nil)\n(test (case-using #'string= \"z\" ((\"a\" \"b\" \"c\") 2) (t 0)) 0 equal)\n(test (case-using #'string= \"z\" ((\"a\" \"b\" \"c\") 2) (t 0 1)) 1 equal)\n(test (case-using #'string= \"d\" ((\"a\" \"b\" \"c\") 0) ((\"z\") 1)) nil)\n\n;;;\n(test (case-using #'= (+ 1.0 1.0)\n         ((1) 'one)\n         ((2) 'two)\n         (t 'more)) two)\n(test (case-using #'string= \"bar\"\n         ((\"foo\") 1)\n         ((\"bar\") 2)) 2 eql)\n\n;;;\n(test (progn) nil)\n(test (progn 1) 1 eql)\n(test (progn 1 2) 2 eql)\n;;;\n(test (progn (defglobal *global-x* 1) (defglobal *global-y* 2)) *global-y*)\n(test *global-x* 1 eql)\n(test *global-y* 2 eql)\n;;;\n(defglobal x 0)\n(test (progn\n   (setq x 5)\n   (+ x 1)) 6 eql)\n\n;\n(test (while nil) nil)\n(test (while nil 1) nil)\n(test (let ((x '()) (i 5))\n   (while (> i 0)\n     (setq x (cons i x))\n     (setq i (- i 1)))\n   x) (1 2 3 4 5) equal)\n\n;;; \u5f15\u6570\u306e\u500b\u6570\n\n(test (for () (t)) nil)\n(test (for () (t t)) t)\n(test (for () (t 1)) 1 eql)\n(test (for () (t 1 2)) 2 eql)\n(test (for ((vec (vector 0 0 0 0 0))\n       (i 0 (+ i 1)))\n      ((= i 5) vec)\n      (setf (elt vec i) i)) #(0 1 2 3 4) equal)\n\n(test (let ((x '(1 3 5 7 9)))\n   (for ((x x (cdr x))\n     (sum 0 (+ sum (car x))))\n    ((null x) sum))) 25 eql)\n;;; \u5f15\u6570\u306e\u500b\u6570\n\n(defglobal x nil)\n(for ((i 0 (+ i 1)))\n        ((= i 10))\n        (if (= i 0) (setq x (lambda () i))))\n(test (funcall x) 10 eql)\n\n\n(test (block x) nil)\n(test (block nil) nil)\n(test (block x 1) 1 eql)\n(test (block x 1 2) 2 eql)\n;;;\n(defglobal x nil)\n(test (block b\n    (setq x (cons 1 x))\n    (setq x (cons 2 x))\n    999) 999 eql)\n(test x (2 1) equal)\n;;;\n(defglobal x nil)\n(test (block b\n    (setq x (cons 1 x))\n    (return-from b 888)\n    (setq x (cons 2 x))\n    999) 888 eql)\n(test x (1) equal)\n;;;\n(defglobal x nil)\n(defun terminate-1 (x) (return-from b x))\n(test (block x\n    (+ 10 (return-from x 6) 22)) ;;; Bad programming style\n 6 eql)\n(defun f1 ()\n   (block b\n      (let ((f (lambda () (return-from b 'exit))))\n        ;; big computation\n        (f2 f))))\n\n(defun f2 (g)\n   ;; big computation\n   (funcall g))\n(test (f1) exit)\n(test (block sum-block\n    (for ((x '(1 a 2 3) (cdr x))\n          (sum 0 (+ sum (car x))))\n         ((null x) sum)\n         (cond ((not (numberp (car x))) (return-from sum-block 0)))))\n 0 eql)\n\n(defun bar-2 (x y)\n   (let ((foo #'car))\n     (let ((result\n        (block bl\n           (setq foo (lambda () (return-from bl 'first-exit)))\n           (if x (return-from bl 'second-exit) 'third-exit))))\n       (if y (funcall foo) nil)\n       result)))\n(test (bar-2 t nil) second-exit)\n(test (bar-2 nil nil) third-exit)\n\n;;; closure\n(test (block b\n    (lambda () 1)\n    (return-from b 999)) 999 eql)\n(test (block b\n    (lambda () 1)\n    (lambda () 2)\n    (return-from b 999)) 999 eql)\n(test (block b\n    ((lambda (x) (return-from b x)) 999)) 999 eql)\n\n(test (catch 'a) nil)\n(test (catch 'a 1) 1 eql)\n(test (catch 'a 1 2) 2 eql)\n;;;\n(defglobal x nil)\n(test (catch 'c\n   (setq x (cons 1 x))\n   (setq x (cons 2 x))\n   999) 999 eql)\n(test x (2 1) equal)\n;;;\n(defglobal x nil)\n(test (catch 'c\n   (setq x (cons 1 x))\n   (throw 'c 888)\n   (setq x (cons 2 x))\n   999) 888 eql)\n(test x (1) equal)\n\n;;;\n(defglobal x nil)\n(defun terminate-2 (x) (throw 'c x))\n(test (catch 'c\n   (setq x (cons 1 x))\n   (terminate-2 777)\n   (setq x (cons 2 x))\n   999) 777 eql)\n(test x (1) equal)\n;;;\n(defun foo-3 (x)\n   (catch 'block-sum (bar-3 x)))\n\n(defun bar-3 (x)\n   (for ((l x (cdr l))\n     (sum 0 (+ sum (car l))))\n    ((null l) sum)\n    (cond ((not (numberp (car l))) (throw 'block-sum 0)))))\n\n(test (foo-3 '(1 2 3 4)) 10 eql)\n(test (foo-3 '(1 2 a 4)) 0 eql)\n;;; closure\n(test (catch 'c\n    (lambda () 1)\n    (throw 'c 999)) 999 eql)\n(test (catch 'c\n    (lambda () 1)\n    (lambda () 2)\n    (throw 'c 999)) 999 eql)\n(test (catch 'c\n    ((lambda (x) (throw 'c x)) 999)) 999 eql)\n\n(test (tagbody) nil)\n(test (tagbody 1) nil)\n(test (tagbody 1 2) nil)\n(test (let ((x ()))\n   (tagbody\n    (setq x (cons 1 x))\n    (setq x (cons 2 x))\n    (setq x (cons 3 x)))\n   x) (3 2 1) equal)\n(test (let ((x ()))\n   (tagbody\n    (setq x (cons 1 x))\n    tag     (setq x (cons 2 x))\n    (setq x (cons 3 x)))\n   x) (3 2 1) equal)\n(test (let ((x ()))\n   (tagbody\n    (setq x (cons 1 x))\n    (go tag)\n    (setq x (cons 2 x))\n    tag     (setq x (cons 3 x)))\n   x) (3 1) equal)\n\n;;; \n;;; (test (let ((x ()))\n;;;    (tagbody\n;;;     (setq x (cons 1 x))\n;;;     (lambda () 1)\n;;;     (go tag1)\n;;;     (setq x (cons 2 x))\n;;;     tag1\n;;;     (setq x (cons 3 x)))\n;;;    x) (3 1) equal)\n;;; (test (let ((x ()))\n;;;    (tagbody\n;;;     (setq x (cons 1 x))\n;;;     (lambda () 1)\n;;;     (lambda () 2)\n;;;     (go tag1)\n;;;     (setq x (cons 2 x))\n;;;     tag1\n;;;     (setq x (cons 3 x)))\n;;;    x) (3 1) equal)\n;;; (test (let ((x ()))\n;;;    (tagbody\n;;;     (setq x (cons 1 x))\n;;;     ((lambda () (go tag1)))\n;;;     (setq x (cons 2 x))\n;;;     tag1\n;;;     (setq x (cons 3 x)))\n;;;    x) (3 1) equal)\n;;; \n(test (unwind-protect 1) 1 eql)\n;;; ;;;\n(defglobal x nil)\n(test (unwind-protect\n     (progn (setq x (cons 1 x)) x)\n   (setq x (cons 2 x))\n   (setq x (cons 3 x))) (1) equal)\n(test x (3 2 1) equal)\n;;; ;;;\n(defglobal x nil)\n(test (catch 'c\n  (unwind-protect\n      (progn (setq x (cons 1 x))\n         (throw 'c 777)\n         888)\n    (setq x (cons 2 x))\n    999)) 777 eql)\n(test x (2 1) equal)\n;;;\n(defglobal x nil)\n(defun nest1 (y)\n     (unwind-protect\n         (progn (setq x (cons 1 x))\n            (nest2 y))\n       (setq x (cons 2 x))))\n(defun nest2 (y)\n     (unwind-protect\n         (progn (setq x (cons 3 x))\n            (throw 'exit y))\n       (setq x (cons 4 x))))\n(test (catch 'exit\n   (nest1 777)) 777 eql)\n(test x (2 4 3 1) equal)\n;;;\n(defun foo-4 (x)\n   (catch 'duplicates\n     (unwind-protect (bar-4 x)\n       (for ((l x (cdr l)))\n        ((null l) (remove-property l 'label) 'unused)\n        (remove-property (car l) 'label)))))\n\n(defun bar-4 (l)\n   (cond ((and (symbolp l) (property l 'label))\n      (throw 'duplicates 'found))\n     ((symbolp l) (setf (property l 'label) t))\n     ((bar-4 (car l)) (bar-4 (cdr l)))\n     (t nil)))\n\n(test (foo-4 '(a b c)) t)\n(test (property 'a 'label) nil)\n(test (foo-4 '(a b a c)) found)\n(test (property 'a 'label) nil)\n\n(defun test ()\n   (catch 'outer (test2)))\n\n(defun test2 ()\n   (block inner\n      (test3 (lambda ()\n           (return-from inner 7)))))\n\n(defun test3 (fun)\n   (unwind-protect (test4) (funcall fun)))\n\n(defun test4 ()\n   (throw 'outer 6))\n\n\n#\u306f\u3058\u3081\u306b\nISLisp\u51e6\u7406\u7cfb\u3092\u81ea\u4f5c\u3057\u305f\u3068\u304d\u306bISLisp\u898f\u683c\u306b\u9069\u5408\u3057\u3066\u3044\u308b\u304b\u3069\u3046\u304b\u306e\u691c\u67fb\u306b\u304a\u4f7f\u3044\u304f\u3060\u3055\u3044\u3002\n\n#\u5229\u7528\u65b9\u6cd5\n\u30b3\u30fc\u30c9\u3092\u30d5\u30a1\u30a4\u30eb\u306b\u30bb\u30fc\u30d6\u3057\u3001\u51e6\u7406\u7cfb\u304b\u3089\u30ed\u30fc\u30c9\u3057\u3066\u304f\u3060\u3055\u3044\u3002\u7d50\u679c\u304c\u753b\u9762\u8868\u793a\u3055\u308c\u307e\u3059\u3002\n\n#\u7bc4\u56f2\n\u5236\u5fa1\u306e\u7279\u6b8a\u5f62\u5f0f\u306e\u90e8\u5206\u3092\u30c6\u30b9\u30c8\u3057\u3066\u3044\u307e\u3059\u3002\n\n#\u51fa\u5178\nISLisp\u691c\u8a3c\u30b7\u30b9\u30c6\u30e0\nhttp://islisp.org/jp/verification-jp.html\n\n\n\n\n#\u30b3\u30fc\u30c9\n\n```\n;\n(defmacro test(form1 form2 :rest pred)\n  (cond ((null pred)\n         `(if (equal ,form1 ',form2)\n              (format (standard-output) \"\" ',form1)\n              ;;(format (standard-output) \"~S is ok~%\" ',form1)\n              (format (standard-output) \"~S is bad~%\" ',form1)))\n        ((and (not (null pred))(consp form1))\n         `(if (,@pred ,form1 ',form2)\n              (format (standard-output) \"\" ',form1)\n              ;;(format (standard-output) \"~S is ok~%\" ',form1)\n              (format (standard-output) \"~S is bad~%\" ',form1)))))\n        \n;;; ;;\n(test #2a((a b c) (d e f)) #2a((a b c) (d e f)) equal)\n(test #1a(a b c) #(a b c) equal)\n(test #0a1 #0a1 equal)\n(test #\\a #\\a equal)\n(test 145932 145932 equal)\n(test \"abc\" \"abc\" equal)\n(test #(a b c) #(a b c) equal)\n(test (quote a) a equal)\n(test (quote #(a b c)) #(a b c) equal)\n(test (quote (+ 1 2)) (+ 1 2) equal)\n(test '() nil equal)\n(test 'a a equal)\n(test '#(a b c) #(a b c) equal)\n(test '(car l) (car l) equal)\n(test '(+ 1 2) (+ 1 2) equal)\n(test '(quote a) (quote a) equal)\n(test ''a (quote a) equal)\n(test (car ''a) quote equal)\n(defglobal x 0)\n(test x 0 eql)\n(test (let ((x 1)) x) 1 eql)\n(test x 0 eql)\n(defglobal x 2)\n(test (+ x 1) 3 equal)\n(test (setq x 4) 4 equal)\n(test (+ x 1) 5 equal)\n(test (let ((x 1)) (setq x 2) x) 2 equal)\n(test (+ x 1) 5 equal)\n\n(defglobal x 2)\n(test (+ x 1) 3 equal)\n(test (setf x 4) 4 equal)\n(test (+ x 1) 5 equal)\n(test (let ((x 1)) (setf x 2) x) 2 equal)\n(test (+ x 1) 5 equal)\n(setq x '(1 . 2))\n(test (setf (car x) 2) 2 equal)\n(test x (2 . 2) equal)\n\n(defmacro first (spot) `(car ,spot))\n(defglobal x '(10 20))\n(test (first x) 10 equal)\n(test (setf (first x) 2) 2)\n(test x (2 20) equal)\n;;;\n(defmacro first2 (spot) `(first ,spot))\n(defglobal x '(10 20))\n(test (first2 x) 10 equal)\n(test (setf (first2 x) 2) 2)\n(test x (2 20) equal)\n;;;\n(defmacro last (spot) `(cdr ,spot))\n(defglobal x '(10 20))\n(test (last x) (20) equal)\n(test (setf (last x) 2) 2)\n(test x (10 . 2) equal)\n;;;\n(defmacro last2 (spot) `(last ,spot))\n(defglobal x '(10 20))\n(test (last2 x) (20) equal)\n(test (setf (last2 x) 2) 2)\n(test x (10 . 2) equal)\n;;;\n(defmacro my-dynamic (spot) `(dynamic ,spot))\n(defdynamic x 3)\n(test (my-dynamic x) 3 equal)\n(test (setf (my-dynamic x) 2) 2)\n(test (my-dynamic x) 2 equal)\n;;;\n(defmacro my-dynamic2 (spot) `(my-dynamic ,spot))\n(defdynamic x 3)\n(test (my-dynamic x) 3 equal)\n(test (setf (my-dynamic2 x) 2) 2)\n(test (my-dynamic2 x) 2 equal)\n;;;\n(defmacro my-elt (seq z) `(elt ,seq ,z))\n(defglobal x '(10 20 30))\n(test (my-elt x 0) 10)\n(test (my-elt x 1) 20)\n(test (my-elt x 2) 30)\n(test (setf (my-elt x 1) 2) 2)\n(test x (10 2 30) equal)\n;;;\n(defmacro my-elt2 (seq z) `(my-elt ,seq ,z))\n(defglobal x '(10 20 30))\n(test (my-elt2 x 0) 10)\n(test (my-elt2 x 1) 20)\n(test (my-elt2 x 2) 30)\n(test (setf (my-elt2 x 1) 2) 2)\n(test x (10 2 30) equal)\n\n(defglobal x 0)\n(defmacro p () 'x)\n(test (setf (p) 9) 9)\n(test x 9)\n(test (let ()) nil)\n(test (let () 1) 1 equal)\n(test (let () 1 2) 2 equal)\n(test (let ((x 2) (y 3))\n   (* x y)) 6 equal)\n(test (let ((x 2) (y 3))\n   (let ((x 7)\n\t (z (+ x y)))\n     (* z x))) 35 equal)\n(test (let ((x 1) (y 2))\n   (let ((x y) (y x))\n     (list x y))) (2 1) equal)\n\n(test (let ((x 2) (y 3))\n   (let* ((x 7)\n\t  (z (+ x y)))\n     (* z x))) 70 equal)\n(test (let ((x 1) (y 2))\n   (let* ((x y) (y x))\n     (list x y))) (2 2) equal)\n\n(let* ((z 1)) z)\n\n (let* ((y 1)\n        (l (lambda () y))\n\t(z 2))\n   (setq x (cons l (lambda () z))))\n(test (funcall (car x)) 1)\n(test (funcall (cdr x)) 2)\n;;;\n(defglobal x ())\n(let* ((y 1)\n        (l (lambda () y))\n\t(y 2))\n   (setq x (cons l (lambda () y))))\n(test (funcall (car x)) 1)\n(test (funcall (cdr x)) 2)\n(defdynamic x 3)\n(test (dynamic x) 3 equal)\n\n(defdynamic x 3)\n(test (dynamic x) 3 equal)\n(test (setf (dynamic x) 4) 4 equal)\n(test (dynamic x) 4 equal)\n\n(defun foo-1 (x)\n\t (dynamic-let ((y x))\n\t\t      (bar-1 1)))\n(defun bar-1 (x)\n\t (+ x (dynamic y)))\n(test (foo-1 2) 3 equal)\n\n;;;\n(defdynamic dynx 1)\n(test (dynamic-let ((dynx 2)) (dynamic dynx)) 2)\n(test (dynamic dynx) 1)\n;;;\n(test (if 1 2 3) 2 eql)\n(test (if 1 2) 2 eql)\n(test (if nil 2 3) 3 eql)\n(test (if nil 2) nil)\n(test (if (> 3 2) 'yes 'no) yes)\n(test (if (> 2 3) 'yes 'no) no)\n(test (if (> 2 3) 'yes) nil)\n(test (if (> 3 2) (- 3 2) (+ 3 2)) 1 eql)\n(test (let ((x 7))\n   (if (< x 0) x (- x))) -7 eql)\n\n(test (cond) nil equal)\n(test (cond (t)) t)\n(test (cond (1)) 1 eql)\n(test (cond ((> 3 2) 'greater)\n       ((< 3 2) 'less)) greater)\n(test (cond ((> 3 3) 'greater)\n       ((< 3 3) 'less)) nil)\n(test (cond ((> 3 3) 'greater)\n       ((< 3 3) 'less)\n       (t 'equal)) equal) \n\n(test (case 'a ((a b c)) (t 1)) nil)\n(test (case 'a ((a b c) 0) (t 1)) 0 eql)\n(test (case 'a ((a b c) 0 1) (t 1)) 1 eql)\n(test (case 'z ((a b c) 0) (t)) nil)\n(test (case 'z ((a b c) 0) (t 0)) 0 eql)\n(test (case 'z ((a b c) 0) (t 0 1)) 1 eql)\n(test (case 'd ((a b c) 0) ((z) 1)) nil)\n;;;\n(test (case (* 2 3)\n       ((2 3 5 7) 'prime)\n       ((4 6 8 9) 'composite)) composite)\n(test (case (car '(c d))\n       ((a) 'a)\n       ((b) 'b)) nil)\n(test (case (car '(c d))\n       ((a e i o u) 'vowel)\n       ((y) 'semivowel)\n       (t 'consonant)) consonant)\n\n(test (let ((char #\\u))\n   (case char\n\t ((#\\a #\\e #\\i #\\o #\\u) 'vowels)\n\t (t 'consonates))) vowels)\n\n(test (case-using #'string= \"a\" ((\"a\" \"b\" \"c\")) (t 2)) nil)\n(test (case-using #'string= \"a\" ((\"a\" \"b\" \"c\") 0) (t 2)) 0 equal)\n(test (case-using #'string= \"a\" ((\"a\" \"b\" \"c\") 0 1) (t 2)) 1 equal)\n(test (case-using #'string= \"z\" ((\"a\" \"b\" \"c\") 2) (t)) nil)\n(test (case-using #'string= \"z\" ((\"a\" \"b\" \"c\") 2) (t 0)) 0 equal)\n(test (case-using #'string= \"z\" ((\"a\" \"b\" \"c\") 2) (t 0 1)) 1 equal)\n(test (case-using #'string= \"d\" ((\"a\" \"b\" \"c\") 0) ((\"z\") 1)) nil)\n\n;;;\n(test (case-using #'= (+ 1.0 1.0)\n\t     ((1) 'one)\n\t     ((2) 'two)\n\t     (t 'more)) two)\n(test (case-using #'string= \"bar\"\n\t     ((\"foo\") 1)\n\t     ((\"bar\") 2)) 2 eql)\n\n;;;\n(test (progn) nil)\n(test (progn 1) 1 eql)\n(test (progn 1 2) 2 eql)\n;;;\n(test (progn (defglobal *global-x* 1) (defglobal *global-y* 2)) *global-y*)\n(test *global-x* 1 eql)\n(test *global-y* 2 eql)\n;;;\n(defglobal x 0)\n(test (progn\n   (setq x 5)\n   (+ x 1)) 6 eql)\n\n;\n(test (while nil) nil)\n(test (while nil 1) nil)\n(test (let ((x '()) (i 5))\n   (while (> i 0)\n     (setq x (cons i x))\n     (setq i (- i 1)))\n   x) (1 2 3 4 5) equal)\n\n;;; \u5f15\u6570\u306e\u500b\u6570\n\n(test (for () (t)) nil)\n(test (for () (t t)) t)\n(test (for () (t 1)) 1 eql)\n(test (for () (t 1 2)) 2 eql)\n(test (for ((vec (vector 0 0 0 0 0))\n       (i 0 (+ i 1)))\n      ((= i 5) vec)\n      (setf (elt vec i) i)) #(0 1 2 3 4) equal)\n\n(test (let ((x '(1 3 5 7 9)))\n   (for ((x x (cdr x))\n\t (sum 0 (+ sum (car x))))\n\t((null x) sum))) 25 eql)\n;;; \u5f15\u6570\u306e\u500b\u6570\n\n(defglobal x nil)\n(for ((i 0 (+ i 1)))\n\t    ((= i 10))\n\t    (if (= i 0) (setq x (lambda () i))))\n(test (funcall x) 10 eql)\n\n\n(test (block x) nil)\n(test (block nil) nil)\n(test (block x 1) 1 eql)\n(test (block x 1 2) 2 eql)\n;;;\n(defglobal x nil)\n(test (block b\n\t(setq x (cons 1 x))\n\t(setq x (cons 2 x))\n\t999) 999 eql)\n(test x (2 1) equal)\n;;;\n(defglobal x nil)\n(test (block b\n\t(setq x (cons 1 x))\n\t(return-from b 888)\n\t(setq x (cons 2 x))\n\t999) 888 eql)\n(test x (1) equal)\n;;;\n(defglobal x nil)\n(defun terminate-1 (x) (return-from b x))\n(test (block x\n\t(+ 10 (return-from x 6) 22)) ;;; Bad programming style\n 6 eql)\n(defun f1 ()\n   (block b\n\t  (let ((f (lambda () (return-from b 'exit))))\n\t    ;; big computation\n\t    (f2 f))))\n\n(defun f2 (g)\n   ;; big computation\n   (funcall g))\n(test (f1) exit)\n(test (block sum-block\n\t(for ((x '(1 a 2 3) (cdr x))\n\t      (sum 0 (+ sum (car x))))\n\t     ((null x) sum)\n\t     (cond ((not (numberp (car x))) (return-from sum-block 0)))))\n 0 eql)\n\n(defun bar-2 (x y)\n   (let ((foo #'car))\n     (let ((result\n\t    (block bl\n\t\t   (setq foo (lambda () (return-from bl 'first-exit)))\n\t\t   (if x (return-from bl 'second-exit) 'third-exit))))\n       (if y (funcall foo) nil)\n       result)))\n(test (bar-2 t nil) second-exit)\n(test (bar-2 nil nil) third-exit)\n\n;;; closure\n(test (block b\n\t(lambda () 1)\n\t(return-from b 999)) 999 eql)\n(test (block b\n\t(lambda () 1)\n\t(lambda () 2)\n\t(return-from b 999)) 999 eql)\n(test (block b\n\t((lambda (x) (return-from b x)) 999)) 999 eql)\n\n(test (catch 'a) nil)\n(test (catch 'a 1) 1 eql)\n(test (catch 'a 1 2) 2 eql)\n;;;\n(defglobal x nil)\n(test (catch 'c\n   (setq x (cons 1 x))\n   (setq x (cons 2 x))\n   999) 999 eql)\n(test x (2 1) equal)\n;;;\n(defglobal x nil)\n(test (catch 'c\n   (setq x (cons 1 x))\n   (throw 'c 888)\n   (setq x (cons 2 x))\n   999) 888 eql)\n(test x (1) equal)\n\n;;;\n(defglobal x nil)\n(defun terminate-2 (x) (throw 'c x))\n(test (catch 'c\n   (setq x (cons 1 x))\n   (terminate-2 777)\n   (setq x (cons 2 x))\n   999) 777 eql)\n(test x (1) equal)\n;;;\n(defun foo-3 (x)\n   (catch 'block-sum (bar-3 x)))\n\n(defun bar-3 (x)\n   (for ((l x (cdr l))\n\t (sum 0 (+ sum (car l))))\n\t((null l) sum)\n\t(cond ((not (numberp (car l))) (throw 'block-sum 0)))))\n\n(test (foo-3 '(1 2 3 4)) 10 eql)\n(test (foo-3 '(1 2 a 4)) 0 eql)\n;;; closure\n(test (catch 'c\n\t(lambda () 1)\n\t(throw 'c 999)) 999 eql)\n(test (catch 'c\n\t(lambda () 1)\n\t(lambda () 2)\n\t(throw 'c 999)) 999 eql)\n(test (catch 'c\n\t((lambda (x) (throw 'c x)) 999)) 999 eql)\n\n(test (tagbody) nil)\n(test (tagbody 1) nil)\n(test (tagbody 1 2) nil)\n(test (let ((x ()))\n   (tagbody\n    (setq x (cons 1 x))\n    (setq x (cons 2 x))\n    (setq x (cons 3 x)))\n   x) (3 2 1) equal)\n(test (let ((x ()))\n   (tagbody\n    (setq x (cons 1 x))\n    tag\t\t(setq x (cons 2 x))\n    (setq x (cons 3 x)))\n   x) (3 2 1) equal)\n(test (let ((x ()))\n   (tagbody\n    (setq x (cons 1 x))\n    (go tag)\n    (setq x (cons 2 x))\n    tag\t\t(setq x (cons 3 x)))\n   x) (3 1) equal)\n\n;;; \n;;; (test (let ((x ()))\n;;;    (tagbody\n;;;     (setq x (cons 1 x))\n;;;     (lambda () 1)\n;;;     (go tag1)\n;;;     (setq x (cons 2 x))\n;;;     tag1\n;;;     (setq x (cons 3 x)))\n;;;    x) (3 1) equal)\n;;; (test (let ((x ()))\n;;;    (tagbody\n;;;     (setq x (cons 1 x))\n;;;     (lambda () 1)\n;;;     (lambda () 2)\n;;;     (go tag1)\n;;;     (setq x (cons 2 x))\n;;;     tag1\n;;;     (setq x (cons 3 x)))\n;;;    x) (3 1) equal)\n;;; (test (let ((x ()))\n;;;    (tagbody\n;;;     (setq x (cons 1 x))\n;;;     ((lambda () (go tag1)))\n;;;     (setq x (cons 2 x))\n;;;     tag1\n;;;     (setq x (cons 3 x)))\n;;;    x) (3 1) equal)\n;;; \n(test (unwind-protect 1) 1 eql)\n;;; ;;;\n(defglobal x nil)\n(test (unwind-protect\n     (progn (setq x (cons 1 x)) x)\n   (setq x (cons 2 x))\n   (setq x (cons 3 x))) (1) equal)\n(test x (3 2 1) equal)\n;;; ;;;\n(defglobal x nil)\n(test (catch 'c\n  (unwind-protect\n      (progn (setq x (cons 1 x))\n\t     (throw 'c 777)\n\t     888)\n    (setq x (cons 2 x))\n    999)) 777 eql)\n(test x (2 1) equal)\n;;;\n(defglobal x nil)\n(defun nest1 (y)\n\t (unwind-protect\n\t     (progn (setq x (cons 1 x))\n\t\t    (nest2 y))\n\t   (setq x (cons 2 x))))\n(defun nest2 (y)\n\t (unwind-protect\n\t     (progn (setq x (cons 3 x))\n\t\t    (throw 'exit y))\n\t   (setq x (cons 4 x))))\n(test (catch 'exit\n   (nest1 777)) 777 eql)\n(test x (2 4 3 1) equal)\n;;;\n(defun foo-4 (x)\n   (catch 'duplicates\n     (unwind-protect (bar-4 x)\n       (for ((l x (cdr l)))\n\t    ((null l) (remove-property l 'label) 'unused)\n\t    (remove-property (car l) 'label)))))\n\n(defun bar-4 (l)\n   (cond ((and (symbolp l) (property l 'label))\n\t  (throw 'duplicates 'found))\n\t ((symbolp l) (setf (property l 'label) t))\n\t ((bar-4 (car l)) (bar-4 (cdr l)))\n\t (t nil)))\n\n(test (foo-4 '(a b c)) t)\n(test (property 'a 'label) nil)\n(test (foo-4 '(a b a c)) found)\n(test (property 'a 'label) nil)\n\n(defun test ()\n   (catch 'outer (test2)))\n\n(defun test2 ()\n   (block inner\n\t  (test3 (lambda ()\n\t\t   (return-from inner 7)))))\n\n(defun test3 (fun)\n   (unwind-protect (test4) (funcall fun)))\n\n(defun test4 ()\n   (throw 'outer 6))\n\n```\n", "tags": ["ISLisp", "lisp"]}