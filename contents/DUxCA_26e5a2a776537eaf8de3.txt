{"tags": ["purescript-0.7", "purescript"], "context": " More than 1 year has passed since last update.Haskell \u8d85\u5165\u9580\u306e\u554f\u984c\u3092PureScript 0.7 \u3067\u3084\u3063\u3066\u307f\u307e\u3057\u305f\u3002\n\u3010\u89e3\u7b54\u4f8b\u3011Haskell \u8d85\u5165\u9580\u306eHaskell\u3067\u306e\u89e3\u7b54\u4f8b\u3068\u4e26\u3079\u3066\u6bd4\u3079\u3066\u307f\u307e\u3057\u3087\u3046\u3002\n\n\u30d5\u30a3\u30dc\u30ca\u30c3\u30c1\u6570\n\n\u3010\u554f1\u3011\u4efb\u610f\u306en\u756a\u76ee\u306e\u30d5\u30a3\u30dc\u30ca\u30c3\u30c1\u6570\u3092\u8a08\u7b97\u3059\u308b\u95a2\u6570fib\u3092\u30d1\u30bf\u30fc\u30f3\u30de\u30c3\u30c1\u3067\u5b9f\u88c5\u3057\u3066\u304f\u3060\u3055\u3044\u3002\n\u3010\u554f2\u3011\u554f1\u3067\u5b9f\u88c5\u3057\u305f\u95a2\u6570\u3092\u30ac\u30fc\u30c9\u3067\u66f8\u304d\u76f4\u3057\u3066\u304f\u3060\u3055\u3044\u3002\n\u3010\u554f3\u3011\u554f1\u3067\u5b9f\u88c5\u3057\u305f\u95a2\u6570\u3092case-of\u3067\u66f8\u304d\u76f4\u3057\u3066\u304f\u3060\u3055\u3044\u3002\n\n\nHaskell\nfib 0 = 0\nfib 1 = 1\nfib n | n > 1 = fib (n - 2) + fib (n - 1)\n\n\n\nHaskell\nfib n\n    | n == 0 = 0\n    | n == 1 = 1\n    | n >  1 = fib (n - 2) + fib (n - 1)\n\n\n\nHaskell\nfib n = case n of\n    0 -> 0\n    1 -> 1\n    _ | n > 1 -> fib (n - 2) + fib (n - 1)\n\n\n\nPureScript\nmodule Q1 where\n\nimport Prelude\nimport Control.Monad.Eff\nimport Control.Monad.Eff.Console\n\n-- | using patern match\nfib :: Int -> Int\nfib n\n  | n == 0 = 1\n  | n == 1 = 1\n  | n >  1 = fib (n - 2) + fib (n - 1)\n\n-- | using guards\nfib2 :: Int -> Int\nfib2 n\n  | n == 0 = 1\n  | n == 1 = 1\n  | n >  1 = fib2 (n - 2) + fib2 (n - 1)\n\n-- | using case of\nfib3 :: Int -> Int\nfib3 n = case n of\n    0 -> 1\n    1 -> 1\n    _ | n > 1 -> fib3 (n - 2) + fib3 (n - 1)\n\n-- | > Q1.main\n-- | 89\n-- | 89\n-- | 89\n-- | unit\nmain:: forall a. Eff (console :: CONSOLE | a) Unit\nmain = do\n  print $ fib 10\n  print $ fib2 10\n  print $ fib3 10\n\n\n\u3053\u3053\u307e\u3067\u306f\u9806\u8abf\u3067\u3059\u306d\u3002\n\n\u518d\u5b9f\u88c5\n\n\u3010\u554f4\u3011sum, product, take, drop, reverse\u3068\u540c\u3058\u6a5f\u80fd\u306e\u95a2\u6570\u3092\u518d\u5b9f\u88c5\u3057\u3066\u304f\u3060\u3055\u3044\u3002\u95a2\u6570\u540d\u306b\u306f'\u3092\u4ed8\u3051\u3066\u304f\u3060\u3055\u3044\u3002\n\n\nHaskell\nsum' []     = 0\nsum' (x:xs) = x + sum' xs\n\nproduct' []     = 1\nproduct' (x:xs) = x * product' xs\n\ntake' _ []        = []\ntake' n _ | n < 1 = []\ntake' n (x:xs)    = x : take' (n - 1) xs\n\ndrop' _ []         = []\ndrop' n xs | n < 1 = xs\ndrop' n (_:xs)     = drop' (n - 1) xs\n\nreverse' []     = []\nreverse' (x:xs) = reverse' xs ++ [x]\n\n\n\nPureScript\nmodule Q2 where\n\nimport Prelude\nimport Control.Monad.Eff\nimport Control.Monad.Eff.Console\nimport Data.Foldable\nimport Data.Array\nimport Data.Maybe\nimport Data.Int\n\nsum' :: forall a. (Ring a)=> Array a -> a\nsum' arr = case uncons arr of\n  Just { head: x, tail: xs } -> x + sum' xs\n  Nothing -> zero\n\nproduct' :: forall a. (Ring a)=>  Array a -> a\nproduct' arr = case uncons arr of\n  Just { head: x, tail: xs } -> x * product' xs\n  Nothing -> one\n\ntake' :: forall a. Int -> Array a -> Array a\ntake' 0 arr = []\ntake' n arr = case uncons arr of\n  Just { head: x, tail: xs } -> x : take' (n - 1) xs\n  Nothing -> []\n\ndrop' :: forall a. Int -> Array a -> Array a\ndrop' 0 arr = arr\ndrop' n arr = case uncons arr of\n  Just { head: x, tail: xs } -> drop' (n - 1) xs\n  Nothing -> []\n\nreverse' :: forall a. Array a -> Array a\nreverse' arr = case uncons arr of\n  Just { head: x, tail: xs } -> (reverse' xs) `snoc` x\n  Nothing -> []\n\n-- | > Q2.main\n-- | 15\n-- | 120\n-- | [3]\n-- | [1,2]\n-- | [5,4,3,2,1]\n-- | unit\nmain:: forall a. Eff (console :: CONSOLE | a) Unit\nmain = do\n  print $ show $ sum' $ range 1 5\n  print $ product' $ range 1 5\n  print $ drop' 2 [1, 2, 3]\n  print $ take' 2 [1, 2, 3]\n  print $ reverse' $ range 1 5\n\n\nPureScript 0.7\u3067(x:xs)\u3068\u3044\u3046\u7cd6\u8863\u69cb\u6587\u304c\u5ec3\u6b62\u3055\u308c\u305f\u305f\u3081\u3001\u660e\u793a\u7684\u306bArray\u3092\u6271\u308f\u306a\u3051\u308c\u3070\u306a\u3089\u306a\u304f\u306a\u308a\u307e\u3057\u305f\u3002\n\n\u8ffd\u8a18\n\u30b3\u30e1\u30f3\u30c8\u6b04\u3067\u306ekakkun61\u3055\u3093\u306bArray\u3088\u308a\u3082Sequence\u3084List\u4f7f\u3063\u305f\u65b9\u304c\u826f\u3044\u306e\u3067\u306f\uff1f\u3068\u3044\u3046\u6307\u6458\u3092\u53d7\u3051\u305f\u306e\u3067\u3053\u308c\u3089\u3082\u66f8\u3044\u3066\u307f\u307e\u3057\u305f\n\nPureScript\nmodule Q2 where\n\nimport Prelude hiding (map, append)\nimport Control.Monad.Eff\nimport Control.Monad.Eff.Console\nimport Data.Foldable\nimport Data.Array (range)\nimport qualified Data.Sequence as S\nimport Data.Maybe\nimport Data.Int\nimport Data.Tuple\nimport qualified Data.List as L\n\nsum' :: forall a. (Ring a)=> S.Seq a -> a\nsum' arr = case S.uncons arr of\n  Just tpl ->\n    let x = fst tpl\n        xs = snd tpl in\n      x + sum' xs\n  Nothing -> zero\n\nproduct' :: forall a. (Ring a)=> L.List a -> a\nproduct' arr = case L.uncons arr of\n  Just { head: x, tail: xs } -> x * product' xs\n  Nothing -> one\n\nmain:: forall a. Eff (console :: CONSOLE | a) Unit\nmain = do\n  print $ show $ sum' $ S.toSeq [1,2]\n  print $ product' $ L.toList $ range 1 5\n\n\n\n\u968e\u4e57\n\n\u3010\u554f5\u3011product\u3092\u4f7f\u3063\u3066fact\uff08\u968e\u4e57\uff09\u3092\u5b9f\u88c5\u3057\u3066\u304f\u3060\u3055\u3044\u3002\n\n\nHaskell\nfact n = product [1..n]\n\n\n\nPureScript\nmodule Q3 where\n\nimport Prelude\nimport Control.Monad.Eff\nimport Control.Monad.Eff.Console\nimport Data.Foldable\nimport Data.Array\n\nfact :: Int -> Int\nfact n = product $ range 1 n\n\n-- | ```purescript\n-- | > Q3.main\n-- | 120\n-- | unit\n-- | ```\nmain:: forall a. Eff (console :: CONSOLE | a) Unit\nmain = do\n  print $ fact 5\n\n\n\n\u5782\u7dda\u306e\u4ea4\u70b9\n\n\u3010\u554f6\u3011\u70b9 $(p,q)$ \u304b\u3089\u76f4\u7dda $ax+by=c$ \u306b\u4e0b\u3057\u305f\u5782\u7dda\u306e\u4ea4\u70b9\u3092\u6c42\u3081\u308b\u95a2\u6570perpPoint\u3092\u4f5c\u6210\u3057\u3066\u304f\u3060\u3055\u3044\u3002a\u3068b\u304c\u4e21\u65b9\u30bc\u30ed\u306b\u306a\u308b\u3068\u89e3\u306a\u3057\u3067\u3059\u304c\u3001\u30c1\u30a7\u30c3\u30af\u305b\u305a\u306b\u7121\u8996\u3057\u3066\u304f\u3060\u3055\u3044\u3002\n\n\nHaskell\nperpPoint (p, q) (a, b, c) = (x, y)\n    where\n        x = (a * c + b * d) / (a * a + b * b)\n        y = (b * c - a * d) / (a * a + b * b)\n        d = b * p - a * q\n\n\n\nPureScript\nmodule Q4 where\n\nimport Prelude\nimport Control.Monad.Eff\nimport Control.Monad.Eff.Console\nimport Data.Tuple\nimport Data.Tuple.Nested\n\n-- | usage:\n-- | ```purescript\n-- | >  Hoge.perpPoint (Data.Tuple.Nested.tuple3 1.0 (-1.0) 0.0) $ Data.Tuple.Nested.tuple2 0.0 2.0\n-- | Tuple (1.0) (1.0)\n-- | ```\nperpPoint :: forall a. (Num a)=> Tuple3 a a a -> Tuple2 a a -> Tuple2 a a\nperpPoint tri dou =\n  tuple2 x y\n  where\n    a = fst $ fst tri\n    b = snd $ fst tri\n    c = snd tri\n    p = fst dou\n    q = snd dou\n    d = b*p - a*q\n    y = (b*c - a*d)/(a*a + b*b)\n    x = (a*c + b*d)/(a*a + b*b)\n\nmain:: forall a. Eff (console :: CONSOLE | a) Unit\nmain = do\n  print $ perpPoint (tuple3 1.0 (-1.0) 0.0) $ tuple2 0.0 2.0\n\n\n\u30bf\u30d7\u30eb\u3082\u7cd6\u8863\u69cb\u6587\u306a\u3044\u306e\u3067\u8f9b\u3044\u3067\u3059\u3002\n\nROT13\n\n\u3010\u554f7\u3011ROT13\u3092\u5b9f\u88c5\u3057\u3066\u304f\u3060\u3055\u3044\u3002\n\n\nHaskell\nrot13ch ch\n    |  'A' <= ch && ch <= 'M'\n    || 'a' <= ch && ch <= 'm' = chr $ ord ch + 13\n    |  'N' <= ch && ch <= 'Z'\n    || 'n' <= ch && ch <= 'z' = chr $ ord ch - 13\n    | otherwise = ch\n\nrot13 \"\"     = \"\"\nrot13 (x:xs) = rot13ch x : rot13 xs\n\n\n\nPureScript\nmodule Q5 where\n\nimport Prelude\nimport Control.Monad.Eff\nimport Control.Monad.Eff.Console\nimport Data.Char\nimport qualified Data.String as Str\nimport Data.Array\nimport Data.Maybe\n\nrot13 :: String -> String\nrot13 \"\" = \"\"\nrot13 str = case Str.uncons str of\n  Just { head: chr, tail: _str } -> (toString $ rot13ch chr) ++ rot13 _str\n  Nothing -> \"\"\n\nrot13ch :: Char -> Char\nrot13ch = \\chr ->\n  let n = toCharCode chr in\n  case n of\n      _ | 65  <= n && n < 78  -> fromCharCode (n + 13)\n      _ | 78  <= n && n < 90  -> fromCharCode (n - 13)\n      _ | 97  <= n && n < 110 -> fromCharCode (n + 13)\n      _ | 110 <= n && n < 123 -> fromCharCode (n - 13)\n      _ | otherwise           -> chr\n\n-- | > Q5.main\n-- | \"Uryyb, Jbeyq!\"\n-- | \"Hello, World!\"\n-- | unit\nmain:: forall a. Eff (console :: CONSOLE | a) Unit\nmain = do\n  let hello13 = rot13 \"Hello, World!\"\n  print hello13\n  print $ rot13 hello13\n\n\n\n\u30d0\u30d6\u30eb\u30bd\u30fc\u30c8\n\n\u3010\u554f8\u3011\u30d0\u30d6\u30eb\u30bd\u30fc\u30c8\u3092\u5b9f\u88c5\u3057\u3066\u304f\u3060\u3055\u3044\u3002\n\n\nHaskell\nbswap [x] = [x]\nbswap (x:xs)\n    | x > y     = y:x:ys\n    | otherwise = x:y:ys\n    where\n        (y:ys) = bswap xs\n\nbsort [] = []\nbsort xs = y : bsort ys\n    where\n        (y:ys) = bswap xs\n\n\n\nPureScript\nmodule Q6 where\n\nimport Prelude\nimport Control.Monad.Eff.Console\nimport Control.Monad.Eff\nimport Data.Array\nimport Data.Maybe\n\n-- | bubble sort\n-- | ```purescript\n-- | > Hoge.bsort [5.0,1.0,3.0,2.0,4.0,0.0]\n-- | [0.0,1.0,2.0,3.0,4.0,5.0]\n-- | ```\nbsort :: forall a. (Ord a)=> Array a -> Array a\nbsort xs =\n  case uncons $ bswap xs of\n    Just { head: y, tail: ys } -> y : bsort ys\n    Nothing -> []\n\n-- | ```purescript\n-- | Hoge.bswap [5.0,1.0,3.0,2.0,4.0,0.0]\n-- | [0.0,5.0,1.0,3.0,2.0,4.0]\n-- | ```\nbswap :: forall a. (Ord a)=> Array a -> Array a\nbswap xs = case uncons xs of\n  Nothing -> xs\n  Just { head: y, tail: ys } ->\n    let zs = bswap ys in\n    case uncons zs of\n      Nothing -> xs\n      Just { head: a, tail: as } ->\n        if y > a\n        then a:y:as\n        else y:a:as\n\n-- | ```purescript\n-- | > Q6.main\n-- | [1,4,3,2,5]\n-- | [1,2,3,4,5]\n-- | [1,2,3,4,5]\n-- | [1,2,3,4,5,6,7,8,9]\n-- | unit\n-- | ```\nmain:: forall a. Eff (console :: CONSOLE | a) Unit\nmain = do\n  print $ bswap [4, 3, 1, 5, 2]\n  print $ bsort [4, 3, 1, 5, 2]\n  print $ bsort [5, 4, 3, 2, 1]\n  print $ bsort [4, 6, 9, 8, 3, 5, 1, 7, 2]\n\n\n\u914d\u5217\u306e\u30d1\u30bf\u30fc\u30f3\u30de\u30c3\u30c1\u304c\u3067\u304d\u306a\u3044\u306e\u3067\u3064\u3089\u3044\u3002\n\n\u30de\u30fc\u30b8\u30bd\u30fc\u30c8\n\n\u3010\u554f9\u3011\u30de\u30fc\u30b8\u30bd\u30fc\u30c8\u3092\u5b9f\u88c5\u3057\u3066\u304f\u3060\u3055\u3044\u3002\n\n\nHaskell\nmerge xs [] = xs\nmerge [] ys = ys\nmerge (x:xs) (y:ys)\n    | x < y     = x : merge xs (y:ys)\n    | otherwise = y : merge (x:xs) ys\n\nmsort []  = []\nmsort [x] = [x]\nmsort xs  = merge (msort (take h xs)) (msort (drop h xs))\n    where\n        h = (length xs) `div` 2\n\n\n\nPureScript\nmodule Q7 where\n\nimport Prelude\nimport Control.Monad.Eff\nimport Control.Monad.Eff.Console\nimport Data.Array\nimport Data.Maybe\n\nmerge :: forall a. (Ord a)=> Array a -> Array a -> Array a\nmerge xs ys\n  | length ys == 0 = xs\n  | length xs == 0 = ys\n  | otherwise      =\n    case uncons xs of\n      Nothing -> []\n      Just {head: a, tail: as} ->\n        case uncons ys of\n          Nothing -> []\n          Just {head: b, tail: bs} ->\n            if a < b\n            then a : merge as (b:bs)\n            else b : merge (a:as) bs\n\nmsort :: forall a. (Ord a)=> Array a -> Array a\nmsort xs\n  | length xs == 0 = []\n  | length xs == 1 = xs\n  | otherwise      = merge (msort (take h xs)) (msort (drop h xs))\n  where\n    h = (length xs) `div` 2\n\n-- | ```purescript\n-- | > Q7.main\n-- | [1,2,3,4,5,6,7,8,9]\n-- | unit\n-- | ```\nmain:: forall a. Eff (console :: CONSOLE | a) Unit\nmain = do\n  print $ msort [4, 6, 9, 8, 3, 5, 1, 7, 2]\n\n\n\u914d\u5217\u306e\u30d1\u30bf\u30fc\u30f3\u30de\u30c3\u30c1\u304c\u3067\u304d\u306a\u3044\u306e\u3067\u3064\u3089\u3044\u3002\n\n\u76f4\u89d2\u4e09\u89d2\u5f62\u306e\u4e09\u8fba\n\n\u3010\u554f11\u3011\u4e09\u8fba\u306e\u9577\u3055\u304c\u540420\u4ee5\u4e0b\u306e\u6574\u6570\u3067\u69cb\u6210\u3055\u308c\u308b\u76f4\u89d2\u4e09\u89d2\u5f62\u3092\u5217\u6319\u3057\u3066\u304f\u3060\u3055\u3044\u3002\u4e26\u3073\u9806\u306b\u3088\u308b\u91cd\u8907\u3092\u6392\u9664\u3059\u308b\u5fc5\u8981\u306f\u3042\u308a\u307e\u305b\u3093\u3002\n\n\nHaskell\nmain = do\n    print [(a, b, c)\n          | a <- [1..20], b <- [1..20], c <- [1..20]\n          , a * a + b * b == c * c\n          ]\n\n\n\nPureScript\nmodule Q9 where\n\nimport Prelude\nimport Control.Monad.Eff\nimport Control.Monad.Eff.Console\nimport Data.Foldable\nimport Data.Array\nimport Data.Tuple\nimport Data.Tuple.Nested\n\n-- | right triangle\n-- | ```purescript\n-- | > Hoge.triangle\n-- | \"[Tuple (Tuple (3) (4)) (5),Tuple (Tuple (4) (3)) (5),Tuple (Tuple (5) (12)) (13),Tuple (Tuple (6) (8)) (10),Tuple (Tuple (8) (6)) (10),Tuple (Tuple (8) (15)) (17),Tuple (Tuple (9) (12)) (15),Tuple (Tuple (12) (5)) (13),Tuple (Tuple (12) (9)) (15),Tuple (Tuple (12) (16)) (20),Tuple (Tuple (15) (8)) (17),Tuple (Tuple (16) (12)) (20)]\"\n-- | unit\n-- | ```\ntriangle :: forall a. Eff (console :: CONSOLE | a) Unit\ntriangle = do\n  print $ show z\n  where\n    x = (range 1 20)\n    y = concat $\n      concat $\n        map (\\i ->\n          map (\\j ->\n            map (\\k ->\n              tuple3 i j k) x) x) x\n    z = filter (\\tri ->\n      let a = fst $ fst tri\n          b = snd $ fst tri\n          c = snd $ tri in\n          a*a + b*b == c*c\n      ) y\n\n\n\u914d\u5217\u5185\u5305\u8868\u8a18\u304c\u306a\u3044\u306e\u304c\u3064\u3089\u3044\u3067\u3059\u3002\n\n\u8ffd\u8a18\n\u30b3\u30e1\u30f3\u30c8\u6b04\u306b\u3066kakkun61\u3055\u3093\u306e\u901a\u308a\u914d\u5217\u5185\u5305\u8868\u8a18\u306b\u3064\u3044\u3066\u306e\u8a18\u4e8b\u304c\u3042\u3063\u305f\u306e\u3067\u53c2\u8003\u306b\u3057\u3066\u4f5c\u3063\u3066\u307f\u305f\u3089\u3001\u3060\u3044\u3076\u30de\u30b7\u306b\u306a\u308a\u307e\u3057\u305f\u3002\u306a\u308b\u307b\u3069\n\nPureScript\ntriangle :: forall a. Eff (console :: CONSOLE | a) Unit\ntriangle = do\n  print $ show do\n    a <- range 1 20\n    b <- range 1 20\n    c <- range 1 20\n    if a*a + b*b == c*c then return $ tuple3 a b c else []\n\n\n\n\u9023\u7d61\n\u3082\u3063\u3068\u826f\u3044\u65b9\u6cd5\u304c\u3042\u308a\u307e\u3057\u305f\u3089\u30b3\u30e1\u30f3\u30c8\u304f\u3060\u3055\u3044\n\n[Haskell \u8d85\u5165\u9580](http://qiita.com/7shi/items/145f1234f8ec2af923ef)\u306e\u554f\u984c\u3092PureScript 0.7 \u3067\u3084\u3063\u3066\u307f\u307e\u3057\u305f\u3002\n[\u3010\u89e3\u7b54\u4f8b\u3011Haskell \u8d85\u5165\u9580](http://qiita.com/7shi/items/0ece8c3394e1328267ed)\u306eHaskell\u3067\u306e\u89e3\u7b54\u4f8b\u3068\u4e26\u3079\u3066\u6bd4\u3079\u3066\u307f\u307e\u3057\u3087\u3046\u3002\n\n## \u30d5\u30a3\u30dc\u30ca\u30c3\u30c1\u6570\n> \u3010\u554f1\u3011\u4efb\u610f\u306en\u756a\u76ee\u306e\u30d5\u30a3\u30dc\u30ca\u30c3\u30c1\u6570\u3092\u8a08\u7b97\u3059\u308b\u95a2\u6570fib\u3092\u30d1\u30bf\u30fc\u30f3\u30de\u30c3\u30c1\u3067\u5b9f\u88c5\u3057\u3066\u304f\u3060\u3055\u3044\u3002\n> \u3010\u554f2\u3011\u554f1\u3067\u5b9f\u88c5\u3057\u305f\u95a2\u6570\u3092\u30ac\u30fc\u30c9\u3067\u66f8\u304d\u76f4\u3057\u3066\u304f\u3060\u3055\u3044\u3002\n> \u3010\u554f3\u3011\u554f1\u3067\u5b9f\u88c5\u3057\u305f\u95a2\u6570\u3092`case-of`\u3067\u66f8\u304d\u76f4\u3057\u3066\u304f\u3060\u3055\u3044\u3002\n\n```hs:Haskell\nfib 0 = 0\nfib 1 = 1\nfib n | n > 1 = fib (n - 2) + fib (n - 1)\n```\n\n```hs:Haskell\nfib n\n    | n == 0 = 0\n    | n == 1 = 1\n    | n >  1 = fib (n - 2) + fib (n - 1)\n```\n\n```hs:Haskell\nfib n = case n of\n    0 -> 0\n    1 -> 1\n    _ | n > 1 -> fib (n - 2) + fib (n - 1)\n```\n\n```hs:PureScript\nmodule Q1 where\n\nimport Prelude\nimport Control.Monad.Eff\nimport Control.Monad.Eff.Console\n\n-- | using patern match\nfib :: Int -> Int\nfib n\n  | n == 0 = 1\n  | n == 1 = 1\n  | n >  1 = fib (n - 2) + fib (n - 1)\n\n-- | using guards\nfib2 :: Int -> Int\nfib2 n\n  | n == 0 = 1\n  | n == 1 = 1\n  | n >  1 = fib2 (n - 2) + fib2 (n - 1)\n\n-- | using case of\nfib3 :: Int -> Int\nfib3 n = case n of\n    0 -> 1\n    1 -> 1\n    _ | n > 1 -> fib3 (n - 2) + fib3 (n - 1)\n\n-- | > Q1.main\n-- | 89\n-- | 89\n-- | 89\n-- | unit\nmain:: forall a. Eff (console :: CONSOLE | a) Unit\nmain = do\n  print $ fib 10\n  print $ fib2 10\n  print $ fib3 10\n```\n\n\u3053\u3053\u307e\u3067\u306f\u9806\u8abf\u3067\u3059\u306d\u3002\n\n\n# \u518d\u5b9f\u88c5\n> \u3010\u554f4\u3011`sum`, `product`, `take`, `drop`, `reverse`\u3068\u540c\u3058\u6a5f\u80fd\u306e\u95a2\u6570\u3092\u518d\u5b9f\u88c5\u3057\u3066\u304f\u3060\u3055\u3044\u3002\u95a2\u6570\u540d\u306b\u306f'\u3092\u4ed8\u3051\u3066\u304f\u3060\u3055\u3044\u3002\n\n```hs:Haskell\nsum' []     = 0\nsum' (x:xs) = x + sum' xs\n\nproduct' []     = 1\nproduct' (x:xs) = x * product' xs\n\ntake' _ []        = []\ntake' n _ | n < 1 = []\ntake' n (x:xs)    = x : take' (n - 1) xs\n\ndrop' _ []         = []\ndrop' n xs | n < 1 = xs\ndrop' n (_:xs)     = drop' (n - 1) xs\n\nreverse' []     = []\nreverse' (x:xs) = reverse' xs ++ [x]\n```\n\n```hs:PureScript\nmodule Q2 where\n\nimport Prelude\nimport Control.Monad.Eff\nimport Control.Monad.Eff.Console\nimport Data.Foldable\nimport Data.Array\nimport Data.Maybe\nimport Data.Int\n\nsum' :: forall a. (Ring a)=> Array a -> a\nsum' arr = case uncons arr of\n  Just { head: x, tail: xs } -> x + sum' xs\n  Nothing -> zero\n\nproduct' :: forall a. (Ring a)=>  Array a -> a\nproduct' arr = case uncons arr of\n  Just { head: x, tail: xs } -> x * product' xs\n  Nothing -> one\n\ntake' :: forall a. Int -> Array a -> Array a\ntake' 0 arr = []\ntake' n arr = case uncons arr of\n  Just { head: x, tail: xs } -> x : take' (n - 1) xs\n  Nothing -> []\n\ndrop' :: forall a. Int -> Array a -> Array a\ndrop' 0 arr = arr\ndrop' n arr = case uncons arr of\n  Just { head: x, tail: xs } -> drop' (n - 1) xs\n  Nothing -> []\n\nreverse' :: forall a. Array a -> Array a\nreverse' arr = case uncons arr of\n  Just { head: x, tail: xs } -> (reverse' xs) `snoc` x\n  Nothing -> []\n\n-- | > Q2.main\n-- | 15\n-- | 120\n-- | [3]\n-- | [1,2]\n-- | [5,4,3,2,1]\n-- | unit\nmain:: forall a. Eff (console :: CONSOLE | a) Unit\nmain = do\n  print $ show $ sum' $ range 1 5\n  print $ product' $ range 1 5\n  print $ drop' 2 [1, 2, 3]\n  print $ take' 2 [1, 2, 3]\n  print $ reverse' $ range 1 5\n```\n\n[PureScript 0.7\u3067(x:xs)\u3068\u3044\u3046\u7cd6\u8863\u69cb\u6587\u304c\u5ec3\u6b62\u3055\u308c\u305f](https://github.com/purescript/purescript/wiki/0.7-Migration-Guide)\u305f\u3081\u3001\u660e\u793a\u7684\u306bArray\u3092\u6271\u308f\u306a\u3051\u308c\u3070\u306a\u3089\u306a\u304f\u306a\u308a\u307e\u3057\u305f\u3002\n\n## \u8ffd\u8a18\n\n\u30b3\u30e1\u30f3\u30c8\u6b04\u3067\u306ekakkun61\u3055\u3093\u306bArray\u3088\u308a\u3082Sequence\u3084List\u4f7f\u3063\u305f\u65b9\u304c\u826f\u3044\u306e\u3067\u306f\uff1f\u3068\u3044\u3046\u6307\u6458\u3092\u53d7\u3051\u305f\u306e\u3067\u3053\u308c\u3089\u3082\u66f8\u3044\u3066\u307f\u307e\u3057\u305f\n\n```hs:PureScript\nmodule Q2 where\n\nimport Prelude hiding (map, append)\nimport Control.Monad.Eff\nimport Control.Monad.Eff.Console\nimport Data.Foldable\nimport Data.Array (range)\nimport qualified Data.Sequence as S\nimport Data.Maybe\nimport Data.Int\nimport Data.Tuple\nimport qualified Data.List as L\n\nsum' :: forall a. (Ring a)=> S.Seq a -> a\nsum' arr = case S.uncons arr of\n  Just tpl ->\n    let x = fst tpl\n        xs = snd tpl in\n      x + sum' xs\n  Nothing -> zero\n\nproduct' :: forall a. (Ring a)=> L.List a -> a\nproduct' arr = case L.uncons arr of\n  Just { head: x, tail: xs } -> x * product' xs\n  Nothing -> one\n\nmain:: forall a. Eff (console :: CONSOLE | a) Unit\nmain = do\n  print $ show $ sum' $ S.toSeq [1,2]\n  print $ product' $ L.toList $ range 1 5\n```\n\n# \u968e\u4e57\n\n> \u3010\u554f5\u3011`product`\u3092\u4f7f\u3063\u3066`fact`\uff08\u968e\u4e57\uff09\u3092\u5b9f\u88c5\u3057\u3066\u304f\u3060\u3055\u3044\u3002\n\n```hs:Haskell\nfact n = product [1..n]\n```\n\n```hs:PureScript\nmodule Q3 where\n\nimport Prelude\nimport Control.Monad.Eff\nimport Control.Monad.Eff.Console\nimport Data.Foldable\nimport Data.Array\n\nfact :: Int -> Int\nfact n = product $ range 1 n\n\n-- | ```purescript\n-- | > Q3.main\n-- | 120\n-- | unit\n-- | ```\nmain:: forall a. Eff (console :: CONSOLE | a) Unit\nmain = do\n  print $ fact 5\n```\n\n# \u5782\u7dda\u306e\u4ea4\u70b9\n\n> \u3010\u554f6\u3011\u70b9 $(p,q)$ \u304b\u3089\u76f4\u7dda $ax+by=c$ \u306b\u4e0b\u3057\u305f\u5782\u7dda\u306e\u4ea4\u70b9\u3092\u6c42\u3081\u308b\u95a2\u6570perpPoint\u3092\u4f5c\u6210\u3057\u3066\u304f\u3060\u3055\u3044\u3002a\u3068b\u304c\u4e21\u65b9\u30bc\u30ed\u306b\u306a\u308b\u3068\u89e3\u306a\u3057\u3067\u3059\u304c\u3001\u30c1\u30a7\u30c3\u30af\u305b\u305a\u306b\u7121\u8996\u3057\u3066\u304f\u3060\u3055\u3044\u3002\n\n```hs:Haskell\nperpPoint (p, q) (a, b, c) = (x, y)\n    where\n        x = (a * c + b * d) / (a * a + b * b)\n        y = (b * c - a * d) / (a * a + b * b)\n        d = b * p - a * q\n```\n\n```hs:PureScript\nmodule Q4 where\n\nimport Prelude\nimport Control.Monad.Eff\nimport Control.Monad.Eff.Console\nimport Data.Tuple\nimport Data.Tuple.Nested\n\n-- | usage:\n-- | ```purescript\n-- | >  Hoge.perpPoint (Data.Tuple.Nested.tuple3 1.0 (-1.0) 0.0) $ Data.Tuple.Nested.tuple2 0.0 2.0\n-- | Tuple (1.0) (1.0)\n-- | ```\nperpPoint :: forall a. (Num a)=> Tuple3 a a a -> Tuple2 a a -> Tuple2 a a\nperpPoint tri dou =\n  tuple2 x y\n  where\n    a = fst $ fst tri\n    b = snd $ fst tri\n    c = snd tri\n    p = fst dou\n    q = snd dou\n    d = b*p - a*q\n    y = (b*c - a*d)/(a*a + b*b)\n    x = (a*c + b*d)/(a*a + b*b)\n\nmain:: forall a. Eff (console :: CONSOLE | a) Unit\nmain = do\n  print $ perpPoint (tuple3 1.0 (-1.0) 0.0) $ tuple2 0.0 2.0\n```\n\n\u30bf\u30d7\u30eb\u3082\u7cd6\u8863\u69cb\u6587\u306a\u3044\u306e\u3067\u8f9b\u3044\u3067\u3059\u3002\n\n# ROT13\n> \u3010\u554f7\u3011[ROT13](http://ja.wikipedia.org/wiki/ROT13)\u3092\u5b9f\u88c5\u3057\u3066\u304f\u3060\u3055\u3044\u3002\n\n```hs:Haskell\nrot13ch ch\n    |  'A' <= ch && ch <= 'M'\n    || 'a' <= ch && ch <= 'm' = chr $ ord ch + 13\n    |  'N' <= ch && ch <= 'Z'\n    || 'n' <= ch && ch <= 'z' = chr $ ord ch - 13\n    | otherwise = ch\n\nrot13 \"\"     = \"\"\nrot13 (x:xs) = rot13ch x : rot13 xs\n```\n\n```hs:PureScript\nmodule Q5 where\n\nimport Prelude\nimport Control.Monad.Eff\nimport Control.Monad.Eff.Console\nimport Data.Char\nimport qualified Data.String as Str\nimport Data.Array\nimport Data.Maybe\n\nrot13 :: String -> String\nrot13 \"\" = \"\"\nrot13 str = case Str.uncons str of\n  Just { head: chr, tail: _str } -> (toString $ rot13ch chr) ++ rot13 _str\n  Nothing -> \"\"\n\nrot13ch :: Char -> Char\nrot13ch = \\chr ->\n  let n = toCharCode chr in\n  case n of\n      _ | 65  <= n && n < 78  -> fromCharCode (n + 13)\n      _ | 78  <= n && n < 90  -> fromCharCode (n - 13)\n      _ | 97  <= n && n < 110 -> fromCharCode (n + 13)\n      _ | 110 <= n && n < 123 -> fromCharCode (n - 13)\n      _ | otherwise           -> chr\n\n-- | > Q5.main\n-- | \"Uryyb, Jbeyq!\"\n-- | \"Hello, World!\"\n-- | unit\nmain:: forall a. Eff (console :: CONSOLE | a) Unit\nmain = do\n  let hello13 = rot13 \"Hello, World!\"\n  print hello13\n  print $ rot13 hello13\n```\n\n\n# \u30d0\u30d6\u30eb\u30bd\u30fc\u30c8\n\n> \u3010\u554f8\u3011[\u30d0\u30d6\u30eb\u30bd\u30fc\u30c8](http://www.ics.kagoshima-u.ac.jp/~fuchida/edu/algorithm/sort-algorithm/bubble-sort.html)\u3092\u5b9f\u88c5\u3057\u3066\u304f\u3060\u3055\u3044\u3002\n\n```hs:Haskell\nbswap [x] = [x]\nbswap (x:xs)\n    | x > y     = y:x:ys\n    | otherwise = x:y:ys\n    where\n        (y:ys) = bswap xs\n\nbsort [] = []\nbsort xs = y : bsort ys\n    where\n        (y:ys) = bswap xs\n```\n\n```hs:PureScript\nmodule Q6 where\n\nimport Prelude\nimport Control.Monad.Eff.Console\nimport Control.Monad.Eff\nimport Data.Array\nimport Data.Maybe\n\n-- | bubble sort\n-- | ```purescript\n-- | > Hoge.bsort [5.0,1.0,3.0,2.0,4.0,0.0]\n-- | [0.0,1.0,2.0,3.0,4.0,5.0]\n-- | ```\nbsort :: forall a. (Ord a)=> Array a -> Array a\nbsort xs =\n  case uncons $ bswap xs of\n    Just { head: y, tail: ys } -> y : bsort ys\n    Nothing -> []\n\n-- | ```purescript\n-- | Hoge.bswap [5.0,1.0,3.0,2.0,4.0,0.0]\n-- | [0.0,5.0,1.0,3.0,2.0,4.0]\n-- | ```\nbswap :: forall a. (Ord a)=> Array a -> Array a\nbswap xs = case uncons xs of\n  Nothing -> xs\n  Just { head: y, tail: ys } ->\n    let zs = bswap ys in\n    case uncons zs of\n      Nothing -> xs\n      Just { head: a, tail: as } ->\n        if y > a\n        then a:y:as\n        else y:a:as\n\n-- | ```purescript\n-- | > Q6.main\n-- | [1,4,3,2,5]\n-- | [1,2,3,4,5]\n-- | [1,2,3,4,5]\n-- | [1,2,3,4,5,6,7,8,9]\n-- | unit\n-- | ```\nmain:: forall a. Eff (console :: CONSOLE | a) Unit\nmain = do\n  print $ bswap [4, 3, 1, 5, 2]\n  print $ bsort [4, 3, 1, 5, 2]\n  print $ bsort [5, 4, 3, 2, 1]\n  print $ bsort [4, 6, 9, 8, 3, 5, 1, 7, 2]\n```\n\n\u914d\u5217\u306e\u30d1\u30bf\u30fc\u30f3\u30de\u30c3\u30c1\u304c\u3067\u304d\u306a\u3044\u306e\u3067\u3064\u3089\u3044\u3002\n\n\n# \u30de\u30fc\u30b8\u30bd\u30fc\u30c8\n> \u3010\u554f9\u3011\u30de\u30fc\u30b8\u30bd\u30fc\u30c8\u3092\u5b9f\u88c5\u3057\u3066\u304f\u3060\u3055\u3044\u3002\n\n```hs:Haskell\nmerge xs [] = xs\nmerge [] ys = ys\nmerge (x:xs) (y:ys)\n    | x < y     = x : merge xs (y:ys)\n    | otherwise = y : merge (x:xs) ys\n\nmsort []  = []\nmsort [x] = [x]\nmsort xs  = merge (msort (take h xs)) (msort (drop h xs))\n    where\n        h = (length xs) `div` 2\n```\n\n```hs:PureScript\nmodule Q7 where\n\nimport Prelude\nimport Control.Monad.Eff\nimport Control.Monad.Eff.Console\nimport Data.Array\nimport Data.Maybe\n\nmerge :: forall a. (Ord a)=> Array a -> Array a -> Array a\nmerge xs ys\n  | length ys == 0 = xs\n  | length xs == 0 = ys\n  | otherwise      =\n    case uncons xs of\n      Nothing -> []\n      Just {head: a, tail: as} ->\n        case uncons ys of\n          Nothing -> []\n          Just {head: b, tail: bs} ->\n            if a < b\n            then a : merge as (b:bs)\n            else b : merge (a:as) bs\n\nmsort :: forall a. (Ord a)=> Array a -> Array a\nmsort xs\n  | length xs == 0 = []\n  | length xs == 1 = xs\n  | otherwise      = merge (msort (take h xs)) (msort (drop h xs))\n  where\n    h = (length xs) `div` 2\n\n-- | ```purescript\n-- | > Q7.main\n-- | [1,2,3,4,5,6,7,8,9]\n-- | unit\n-- | ```\nmain:: forall a. Eff (console :: CONSOLE | a) Unit\nmain = do\n  print $ msort [4, 6, 9, 8, 3, 5, 1, 7, 2]\n```\n\n\u914d\u5217\u306e\u30d1\u30bf\u30fc\u30f3\u30de\u30c3\u30c1\u304c\u3067\u304d\u306a\u3044\u306e\u3067\u3064\u3089\u3044\u3002\n\n\n# \u76f4\u89d2\u4e09\u89d2\u5f62\u306e\u4e09\u8fba\n> \u3010\u554f11\u3011\u4e09\u8fba\u306e\u9577\u3055\u304c\u540420\u4ee5\u4e0b\u306e\u6574\u6570\u3067\u69cb\u6210\u3055\u308c\u308b\u76f4\u89d2\u4e09\u89d2\u5f62\u3092\u5217\u6319\u3057\u3066\u304f\u3060\u3055\u3044\u3002\u4e26\u3073\u9806\u306b\u3088\u308b\u91cd\u8907\u3092\u6392\u9664\u3059\u308b\u5fc5\u8981\u306f\u3042\u308a\u307e\u305b\u3093\u3002\n\n```hs:Haskell\nmain = do\n    print [(a, b, c)\n          | a <- [1..20], b <- [1..20], c <- [1..20]\n          , a * a + b * b == c * c\n          ]\n```\n\n```hs:PureScript\nmodule Q9 where\n\nimport Prelude\nimport Control.Monad.Eff\nimport Control.Monad.Eff.Console\nimport Data.Foldable\nimport Data.Array\nimport Data.Tuple\nimport Data.Tuple.Nested\n\n-- | right triangle\n-- | ```purescript\n-- | > Hoge.triangle\n-- | \"[Tuple (Tuple (3) (4)) (5),Tuple (Tuple (4) (3)) (5),Tuple (Tuple (5) (12)) (13),Tuple (Tuple (6) (8)) (10),Tuple (Tuple (8) (6)) (10),Tuple (Tuple (8) (15)) (17),Tuple (Tuple (9) (12)) (15),Tuple (Tuple (12) (5)) (13),Tuple (Tuple (12) (9)) (15),Tuple (Tuple (12) (16)) (20),Tuple (Tuple (15) (8)) (17),Tuple (Tuple (16) (12)) (20)]\"\n-- | unit\n-- | ```\ntriangle :: forall a. Eff (console :: CONSOLE | a) Unit\ntriangle = do\n  print $ show z\n  where\n    x = (range 1 20)\n    y = concat $\n      concat $\n        map (\\i ->\n          map (\\j ->\n            map (\\k ->\n              tuple3 i j k) x) x) x\n    z = filter (\\tri ->\n      let a = fst $ fst tri\n          b = snd $ fst tri\n          c = snd $ tri in\n          a*a + b*b == c*c\n      ) y\n```\n\n\u914d\u5217\u5185\u5305\u8868\u8a18\u304c\u306a\u3044\u306e\u304c\u3064\u3089\u3044\u3067\u3059\u3002\n\n## \u8ffd\u8a18\n\u30b3\u30e1\u30f3\u30c8\u6b04\u306b\u3066kakkun61\u3055\u3093\u306e\u901a\u308a[\u914d\u5217\u5185\u5305\u8868\u8a18](http://hiruberuto.bitbucket.org/purescript/chapter08.html)\u306b\u3064\u3044\u3066\u306e\u8a18\u4e8b\u304c\u3042\u3063\u305f\u306e\u3067\u53c2\u8003\u306b\u3057\u3066\u4f5c\u3063\u3066\u307f\u305f\u3089\u3001\u3060\u3044\u3076\u30de\u30b7\u306b\u306a\u308a\u307e\u3057\u305f\u3002\u306a\u308b\u307b\u3069\n\n```hs:PureScript\ntriangle :: forall a. Eff (console :: CONSOLE | a) Unit\ntriangle = do\n  print $ show do\n    a <- range 1 20\n    b <- range 1 20\n    c <- range 1 20\n    if a*a + b*b == c*c then return $ tuple3 a b c else []\n```\n# \u9023\u7d61\n\n\u3082\u3063\u3068\u826f\u3044\u65b9\u6cd5\u304c\u3042\u308a\u307e\u3057\u305f\u3089\u30b3\u30e1\u30f3\u30c8\u304f\u3060\u3055\u3044\n"}