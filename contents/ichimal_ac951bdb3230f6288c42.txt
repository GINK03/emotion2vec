{"tags": ["common-lisp"], "context": " More than 1 year has passed since last update.\u3068\u3044\u3046\u308f\u3051\u3067\u3001named-let\u306e\u4e9c\u7a2e\u3068\u3057\u3066local-function\u306a\u308b\u3082\u306e\u3092\u7d44\u3093\u3067\u307f\u305f\u3002\nlocal-function \u3067\u5b9a\u7fa9\u3059\u308b\u5c40\u6240\u95a2\u6570f\u306e\u4e2d\u3067\n(no-return (f ...))\n\u3068\u3059\u308b\u3068\u3001C\u8a00\u8a9e\u3067\u3044\u3046for\u6587\u4e2d\u3067\u306econtinue\u3092\u4e00\u822c\u5316\u3057\u305f\u3088\u3046\u306a\u52d5\u4f5c\u3092\u3059\u308b\u3002\n\u672c\u6765\u306e\u76ee\u6a19\u306f\u8907\u6570\u306e(\u5c40\u6240)\u95a2\u6570\u7fa4\u3067\u76f8\u4e92\u306b\u884c\u304d\u6765\u3067\u304d\u308b\u3082\u306e\u3060\u304c\u3001\u305d\u308c\u306fnamed-let\u3067\u306f\u306a\u304flabels\u306e\u4e9c\u7a2e\u3068\u3057\u3066\u69cb\u6210\u3059\u308b\u3079\u304d\u304b\u3002\n(defvar *local-function-verbose-debug* nil\n  \"To enable dissassemble each internal function definition in a LOCAL-FUNCTION macro\" )\n\n#+clisp   ; for clisp interpreter\n(defvar *local-function-force-eliminate-tail-call* nil\n  \"To enable force to eliminate tail call\" )\n\n(defmacro local-function (name (&rest bindings) &body body)\n  \"LOCAL-FUNCTION enables to describe and execute recuresive local function\n  which is similar to the named-let in Scheme language.\n\n  LOCAL-FUNCTION supports NO-RETURN function call feature, which will be\n  translated into a GO expression.\n  NO-RETUREN can be located anywhere upon local-function body.\n\n  NOTE: jus on this implementation, NO-RETURN not supported to call other\n  functions.\n\n  NOTE: TCO for non NO-RETURN style recursive call is not guaranteed.\n\n  LOCAL-FUNCTION also supports GLOBAL-EXIT-FROM-LOCAL-FUNCTION, similar to\n  RETURN, for global exit from a local function.\n\n  e.g.\n  (defun fx (x)\n    (declare (integer x))\n    (local-function f ((i x)) (sum 0)\n      (declare (integer i sum))\n      (when (> i 0)\n        (no-return (f (the integer (1- i)) (the integer (+ sum i)))) )\n      (format t \\\"~&SUM is ~a~%\\\" sum)\n      (global-exit-from-local-function sum) ))  ; or, just sum\n\n  will be expanded to\n\n  (defun fx (x)\n    (declare (integer x))\n    (block #1=#:G1\n      (labels\n        ((f (i sum) (declare (integer i sum))\n           (tagbody #2=#:G2\n             (return-from f\n               (progn\n                 (if (> i 0)\n                   (progn\n                     (psetq i (the integer (1- i))\n                            sum (the integer (+ sum i)))\n                     (go #2#) ))\n                 (format t \\\"~&SUM is ~a~%\\\" sum)\n                 (return-from #1# sum) )))))    ; or, just sum\n        (f x 0) )))\n\n  and enable to execute pseudo recursive call deeper than deeper.\n\n  > (fx 100000000)\n  SUM is 5000000050000000\n  5000000050000000\n  > \"\n  ;; helper functions\n  (labels ((valid-binding-p (binding)\n             \"check valid LET binding or not\"\n             (or (and (symbolp binding) binding)\n                 (and (consp binding)\n                      (symbolp (car binding))\n                      (null (cddr binding)) )))\n           ;;\n           (separate-pairs (lst)\n             \"separate LET style variable bindings\"\n             (loop for elm in lst\n                   for (var val) = (if (valid-binding-p elm)\n                                     (if (symbolp elm) (list elm) elm)\n                                     (error \"invalid binding form: ~a\" elm) )\n                   collect var into var-acc\n                   collect val into val-acc\n                   finally (return (values var-acc val-acc)) ))\n           ;;\n           (declare-p (form)\n             (and (consp form)\n                  (symbolp (car form))\n                  (eq (car form) 'cl:declare) ))\n           ;;\n           (separate-declarations (form)\n             \"separate declarations and a documentation from entire body.\n              this helper function returns 3 lists with VALUES;\n              list of documentations, list of declarations and list of forms.\"\n             (if (atom form)\n               (values nil nil form)\n               (loop for elm in form with body-p = nil\n                     ;; check documentations\n                     if (and (not body-p) (stringp elm))\n                       collect elm into acc-doc\n                     ;; check declarations\n                     else if (declare-p elm)\n                       if body-p\n                         do (error \"invalid location for declarations: ~a\" elm)\n                       else\n                         collect (cdr elm) into acc-decl\n                       end\n                     ;; collect body\n                     else\n                       collect elm into acc-form and do (setq body-p 1)\n                     end\n                     finally (return (values acc-doc acc-decl acc-form)) )))\n             ;;\n             #+clisp  ; optional; just for TCO manually\n             (eliminate-tail-recursion (start-tag lambda-list tail-form)\n               ;; leave form as it is when force-elimination not required\n               (unless *local-function-force-eliminate-tail-call*\n                 (return-from eliminate-tail-recursion tail-form) )\n               ;; check and eliminate tail recursions\n               (let ((form (macroexpand tail-form)))\n                 (when form\n                   (if (listp form)\n                     (if (eq (car form) name)\n                       ;; eliminate a tail recursive call\n                       `(progn\n                          (psetq ,@(mapcan (lambda (var val) `(,var ,val))\n                                           lambda-list (cdr form) ))\n                          (go ,start-tag) )\n                       ;; check some sort of forms\n                       (case (car form)\n                         ((if)\n                          ;; process conditional expr\n                          `(if ,(cadr form)\n                             ,@(mapcar (lambda (elm)\n                                         (eliminate-tail-recursion\n                                           start-tag lambda-list elm ))\n                                       (cddr form) )))\n                         ((let let* block tagbody progn catch the)\n                          ;; process block code\n                          `(,@(butlast form)\n                             ,(eliminate-tail-recursion\n                                start-tag lambda-list\n                                (car (last form)) )))\n                         ((flet labels) form) ; reserved\n                         ((progn) form)       ; reserved\n                         (otherwise form) ))  ; not tail recursive, maybe\n                     ;; not a list\n                     form )) )))\n    ;; do parse local-function\n    (multiple-value-bind (lambda-list init-params) (separate-pairs bindings)\n      (let ((gs (mapcar (lambda (x) (gensym (symbol-name x))) lambda-list))\n            (exit-val  (gensym \"EXIT-VALUE-\"))\n            (block-tag (gensym \"BLOCK-TAG-\"))\n            (start-tag (gensym \"START-TAG-\"))\n            (nr-fn     (gensym \"NO-RETURN-FN-\")) )\n        (multiple-value-bind (doc decls body) (separate-declarations body)\n          ;; make customized macrolets\n          `(macrolet ((no-return ((,nr-fn ,@gs))\n                        \"to be translated into GO expr with update\"\n                        (unless (eq ,nr-fn ',name)\n                          (error\n                            \"not supported general TCO: jump from ~a into ~a\"\n                            ',name ,nr-fn ))\n                        `(progn\n                           (psetq ,@(mapcan ,(lambda (var val) `(,var ,val))\n                                            ',lambda-list (list ,@gs) ))\n                           (go ,',start-tag) ))\n                      ;;\n                      (global-exit-from-local-function (,exit-val)\n                        \"for global exit from LOCAL-FUNCTION execution\"\n                        `(return-from ,',block-tag ,,exit-val) ))\n             ;; expand local-function\n             ;; global block for a LOCAL-FUNCTION expr\n             (block ,block-tag  ; for global exit from a local function\n               (labels ((,name ,lambda-list\n                          ;; allocate declarations and a documentation\n                          (declare ,@(mapcan #'identity decls))\n                          ,@doc\n                          ;; allocate function body\n                          (tagbody\n                            ,start-tag  ; for no-return and tail recursion\n                            (return-from ,name\n                              (progn\n                                ,@(butlast body)\n                                ,(eliminate-tail-recursion\n                                   start-tag lambda-list\n                                   (car (last body)) ))) )))\n                 ;; for debug\n                 ,@(when *local-function-verbose-debug*\n                     `((disassemble #',name) (terpri)) )\n                 ;; execute local function\n                 (,name ,@init-params) ))))))))\n\n\n\n\u3068\u3044\u3046\u308f\u3051\u3067\u3001named-let\u306e\u4e9c\u7a2e\u3068\u3057\u3066local-function\u306a\u308b\u3082\u306e\u3092\u7d44\u3093\u3067\u307f\u305f\u3002\nlocal-function \u3067\u5b9a\u7fa9\u3059\u308b\u5c40\u6240\u95a2\u6570f\u306e\u4e2d\u3067\n(no-return (f ...))\n\u3068\u3059\u308b\u3068\u3001C\u8a00\u8a9e\u3067\u3044\u3046for\u6587\u4e2d\u3067\u306econtinue\u3092\u4e00\u822c\u5316\u3057\u305f\u3088\u3046\u306a\u52d5\u4f5c\u3092\u3059\u308b\u3002\n\n\u672c\u6765\u306e\u76ee\u6a19\u306f\u8907\u6570\u306e(\u5c40\u6240)\u95a2\u6570\u7fa4\u3067\u76f8\u4e92\u306b\u884c\u304d\u6765\u3067\u304d\u308b\u3082\u306e\u3060\u304c\u3001\u305d\u308c\u306fnamed-let\u3067\u306f\u306a\u304flabels\u306e\u4e9c\u7a2e\u3068\u3057\u3066\u69cb\u6210\u3059\u308b\u3079\u304d\u304b\u3002\n\n```cl\n(defvar *local-function-verbose-debug* nil\n  \"To enable dissassemble each internal function definition in a LOCAL-FUNCTION macro\" )\n\n#+clisp   ; for clisp interpreter\n(defvar *local-function-force-eliminate-tail-call* nil\n  \"To enable force to eliminate tail call\" )\n\n(defmacro local-function (name (&rest bindings) &body body)\n  \"LOCAL-FUNCTION enables to describe and execute recuresive local function\n  which is similar to the named-let in Scheme language.\n  \n  LOCAL-FUNCTION supports NO-RETURN function call feature, which will be\n  translated into a GO expression.\n  NO-RETUREN can be located anywhere upon local-function body.\n  \n  NOTE: jus on this implementation, NO-RETURN not supported to call other\n  functions.\n\n  NOTE: TCO for non NO-RETURN style recursive call is not guaranteed.\n\n  LOCAL-FUNCTION also supports GLOBAL-EXIT-FROM-LOCAL-FUNCTION, similar to\n  RETURN, for global exit from a local function.\n\n  e.g.\n  (defun fx (x)\n    (declare (integer x))\n    (local-function f ((i x)) (sum 0)\n      (declare (integer i sum))\n      (when (> i 0)\n        (no-return (f (the integer (1- i)) (the integer (+ sum i)))) )\n      (format t \\\"~&SUM is ~a~%\\\" sum)\n      (global-exit-from-local-function sum) ))  ; or, just sum\n\n  will be expanded to\n\n  (defun fx (x)\n    (declare (integer x))\n    (block #1=#:G1\n      (labels\n        ((f (i sum) (declare (integer i sum))\n           (tagbody #2=#:G2\n             (return-from f\n               (progn\n                 (if (> i 0)\n                   (progn\n                     (psetq i (the integer (1- i))\n                            sum (the integer (+ sum i)))\n                     (go #2#) ))\n                 (format t \\\"~&SUM is ~a~%\\\" sum)\n                 (return-from #1# sum) )))))    ; or, just sum\n        (f x 0) )))\n\n  and enable to execute pseudo recursive call deeper than deeper.\n\n  > (fx 100000000)\n  SUM is 5000000050000000\n  5000000050000000\n  > \"\n  ;; helper functions\n  (labels ((valid-binding-p (binding)\n             \"check valid LET binding or not\"\n             (or (and (symbolp binding) binding)\n                 (and (consp binding)\n                      (symbolp (car binding))\n                      (null (cddr binding)) )))\n           ;;\n           (separate-pairs (lst)\n             \"separate LET style variable bindings\"\n             (loop for elm in lst\n                   for (var val) = (if (valid-binding-p elm)\n                                     (if (symbolp elm) (list elm) elm)\n                                     (error \"invalid binding form: ~a\" elm) )\n                   collect var into var-acc\n                   collect val into val-acc\n                   finally (return (values var-acc val-acc)) ))\n           ;;\n           (declare-p (form)\n             (and (consp form)\n                  (symbolp (car form))\n                  (eq (car form) 'cl:declare) ))\n           ;;\n           (separate-declarations (form)\n             \"separate declarations and a documentation from entire body.\n              this helper function returns 3 lists with VALUES;\n              list of documentations, list of declarations and list of forms.\"\n             (if (atom form)\n               (values nil nil form)\n               (loop for elm in form with body-p = nil\n                     ;; check documentations\n                     if (and (not body-p) (stringp elm))\n                       collect elm into acc-doc\n                     ;; check declarations\n                     else if (declare-p elm)\n                       if body-p\n                         do (error \"invalid location for declarations: ~a\" elm)\n                       else\n                         collect (cdr elm) into acc-decl\n                       end\n                     ;; collect body\n                     else\n                       collect elm into acc-form and do (setq body-p 1)\n                     end\n                     finally (return (values acc-doc acc-decl acc-form)) )))\n             ;;\n             #+clisp  ; optional; just for TCO manually\n             (eliminate-tail-recursion (start-tag lambda-list tail-form)\n               ;; leave form as it is when force-elimination not required\n               (unless *local-function-force-eliminate-tail-call*\n                 (return-from eliminate-tail-recursion tail-form) )\n               ;; check and eliminate tail recursions\n               (let ((form (macroexpand tail-form)))\n                 (when form\n                   (if (listp form)\n                     (if (eq (car form) name)\n                       ;; eliminate a tail recursive call\n                       `(progn\n                          (psetq ,@(mapcan (lambda (var val) `(,var ,val))\n                                           lambda-list (cdr form) ))\n                          (go ,start-tag) )\n                       ;; check some sort of forms\n                       (case (car form)\n                         ((if)\n                          ;; process conditional expr\n                          `(if ,(cadr form)\n                             ,@(mapcar (lambda (elm)\n                                         (eliminate-tail-recursion\n                                           start-tag lambda-list elm ))\n                                       (cddr form) )))\n                         ((let let* block tagbody progn catch the)\n                          ;; process block code\n                          `(,@(butlast form)\n                             ,(eliminate-tail-recursion\n                                start-tag lambda-list\n                                (car (last form)) )))\n                         ((flet labels) form) ; reserved\n                         ((progn) form)       ; reserved\n                         (otherwise form) ))  ; not tail recursive, maybe\n                     ;; not a list\n                     form )) )))\n    ;; do parse local-function\n    (multiple-value-bind (lambda-list init-params) (separate-pairs bindings)\n      (let ((gs (mapcar (lambda (x) (gensym (symbol-name x))) lambda-list))\n            (exit-val  (gensym \"EXIT-VALUE-\"))\n            (block-tag (gensym \"BLOCK-TAG-\"))\n            (start-tag (gensym \"START-TAG-\"))\n            (nr-fn     (gensym \"NO-RETURN-FN-\")) )\n        (multiple-value-bind (doc decls body) (separate-declarations body)\n          ;; make customized macrolets\n          `(macrolet ((no-return ((,nr-fn ,@gs))\n                        \"to be translated into GO expr with update\"\n                        (unless (eq ,nr-fn ',name)\n                          (error\n                            \"not supported general TCO: jump from ~a into ~a\"\n                            ',name ,nr-fn ))\n                        `(progn\n                           (psetq ,@(mapcan ,(lambda (var val) `(,var ,val))\n                                            ',lambda-list (list ,@gs) ))\n                           (go ,',start-tag) ))\n                      ;;\n                      (global-exit-from-local-function (,exit-val)\n                        \"for global exit from LOCAL-FUNCTION execution\"\n                        `(return-from ,',block-tag ,,exit-val) ))\n             ;; expand local-function\n             ;; global block for a LOCAL-FUNCTION expr\n             (block ,block-tag  ; for global exit from a local function\n               (labels ((,name ,lambda-list\n                          ;; allocate declarations and a documentation\n                          (declare ,@(mapcan #'identity decls))\n                          ,@doc\n                          ;; allocate function body\n                          (tagbody\n                            ,start-tag  ; for no-return and tail recursion\n                            (return-from ,name\n                              (progn\n                                ,@(butlast body)\n                                ,(eliminate-tail-recursion\n                                   start-tag lambda-list\n                                   (car (last body)) ))) )))\n                 ;; for debug\n                 ,@(when *local-function-verbose-debug*\n                     `((disassemble #',name) (terpri)) )\n                 ;; execute local function\n                 (,name ,@init-params) ))))))))\n\n```"}