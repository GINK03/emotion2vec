{"tags": ["GLKit", "OpenGLES", "iOS", "Swift3.0"], "context": "GLKViewController\u30c6\u30f3\u30d7\u30ec\u30fc\u30c8\u304b\u3089\u30b7\u30a7\u30fc\u30c0\u3092\u4f7f\u3063\u3066\u3044\u308b\u90e8\u5206\u3092\u6b8b\u3057\u3001\u30c7\u30fc\u30bf\u3092\u4e09\u89d2\u5f62\u304c\u56de\u8ee2\u3059\u308b\u3060\u3051\u306b\u5909\u3048\u3066\u307f\u305f\u3082\u306e\u3092\u4f5c\u3063\u3066\u307f\u307e\u3057\u305f\u3002Swift3\u3067\u3059\u3002\n\u9802\u70b9\u30b7\u30a7\u30fc\u30c0\n\nShader.vsh\nattribute vec4 position;\n\nuniform mat4 modelViewProjectionMatrix;\n\nvoid main()\n{\n    gl_Position = modelViewProjectionMatrix * position;\n}\n\n\n\u30d5\u30e9\u30b0\u30e1\u30f3\u30c8\u30b7\u30a7\u30fc\u30c0\n\nShader.fsh\nvoid main()\n{\n    gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);\n}\n\n\nGLKViewController\u672c\u4f53\n\nGameViewController.swift\nimport GLKit\nimport OpenGLES\n\nfunc BUFFER_OFFSET(_ i: Int) -> UnsafeRawPointer? {\n    return UnsafeRawPointer(bitPattern: i)\n}\n\n\nlet UNIFORM_MODELVIEWPROJECTION_MATRIX = 0\nvar uniforms = [GLint](repeating: 0, count: 1)\n\nclass GameViewController: GLKViewController {\n\n    var program: GLuint = 0\n\n    var modelViewProjectionMatrix:GLKMatrix4 = GLKMatrix4Identity\n    var rotation: Float = 0.0\n\n    var vertexArray: GLuint = 0\n    var vertexBuffer: GLuint = 0\n\n    var context: EAGLContext? = nil\n\n    deinit {\n        self.tearDownGL()\n\n        if EAGLContext.current() === self.context {\n            EAGLContext.setCurrent(nil)\n        }\n    }\n\n    override func viewDidLoad() {\n        super.viewDidLoad()\n\n        self.context = EAGLContext(api: .openGLES2)\n\n        if !(self.context != nil) {\n            print(\"Failed to create ES context\")\n        }\n\n        let view = self.view as! GLKView\n        view.context = self.context!\n        view.drawableDepthFormat = .format24\n\n        self.setupGL()\n    }\n\n    override func didReceiveMemoryWarning() {\n        super.didReceiveMemoryWarning()\n\n        if self.isViewLoaded && (self.view.window != nil) {\n            self.view = nil\n\n            self.tearDownGL()\n\n            if EAGLContext.current() === self.context {\n                EAGLContext.setCurrent(nil)\n            }\n            self.context = nil\n        }\n    }\n\n    func setupGL() {\n        EAGLContext.setCurrent(self.context)\n\n        if(self.loadShaders() == false) {\n            print(\"Failed to load shaders\")\n        }\n\n\n        glEnable(GLenum(GL_DEPTH_TEST))\n\n        glGenVertexArraysOES(1, &vertexArray)\n        glBindVertexArrayOES(vertexArray)\n\n        glGenBuffers(1, &vertexBuffer)\n        glBindBuffer(GLenum(GL_ARRAY_BUFFER), vertexBuffer)\n        glBufferData(GLenum(GL_ARRAY_BUFFER), GLsizeiptr(MemoryLayout<GLfloat>.size * gVertexData.count), &gVertexData, GLenum(GL_STATIC_DRAW))\n\n        glEnableVertexAttribArray(GLuint(GLKVertexAttrib.position.rawValue))\n        glVertexAttribPointer(GLuint(GLKVertexAttrib.position.rawValue),\n                              3,\n                              GLenum(GL_FLOAT),\n                              GLboolean(GL_FALSE),\n                              GLsizei(MemoryLayout<GLfloat>.size)*3,\n                              BUFFER_OFFSET(0))\n\n        glBindVertexArrayOES(0)\n    }\n\n    func tearDownGL() {\n        EAGLContext.setCurrent(self.context)\n\n        glDeleteBuffers(1, &vertexBuffer)\n        glDeleteVertexArraysOES(1, &vertexArray)\n\n        if program != 0 {\n            glDeleteProgram(program)\n            program = 0\n        }\n    }\n\n    // MARK: - GLKView and GLKViewController delegate methods\n\n    func update() {\n        let aspect = fabsf(Float(self.view.bounds.size.width / self.view.bounds.size.height))\n        let projectionMatrix = GLKMatrix4MakePerspective(GLKMathDegreesToRadians(65.0), aspect, 0.1, 100.0)\n\n        var baseModelViewMatrix = GLKMatrix4MakeTranslation(0.0, 0.0, -4.0)\n        baseModelViewMatrix = GLKMatrix4Rotate(baseModelViewMatrix, rotation, 0.0, 1.0, 0.0)\n\n\n        // Compute the model view matrix for the object rendered with ES2\n        var modelViewMatrix = GLKMatrix4MakeTranslation(0.0, 0.0, 1.5)\n        modelViewMatrix = GLKMatrix4Rotate(modelViewMatrix, rotation, 1.0, 1.0, 1.0)\n        modelViewMatrix = GLKMatrix4Multiply(baseModelViewMatrix, modelViewMatrix)\n\n        modelViewProjectionMatrix = GLKMatrix4Multiply(projectionMatrix, modelViewMatrix)\n\n        rotation += Float(self.timeSinceLastUpdate * 0.5)\n    }\n\n    override func glkView(_ view: GLKView, drawIn rect: CGRect) {\n        glClearColor(0.65, 0.65, 0.65, 1.0)\n        glClear(GLbitfield(GL_COLOR_BUFFER_BIT) | GLbitfield(GL_DEPTH_BUFFER_BIT))\n\n        glBindVertexArrayOES(vertexArray)\n\n        // Render the object again with ES2\n        glUseProgram(program)\n\n        withUnsafePointer(to: &modelViewProjectionMatrix, {\n            $0.withMemoryRebound(to: Float.self, capacity: 4*4, {\n                glUniformMatrix4fv(uniforms[UNIFORM_MODELVIEWPROJECTION_MATRIX], 1, 0, $0)\n            })\n        })\n\n        glDrawArrays(GLenum(GL_TRIANGLES), 0, Int32(gVertexData.count/3))\n    }\n\n    // MARK: -  OpenGL ES 2 shader compilation\n\n    func loadShaders() -> Bool {\n        var vertShader: GLuint = 0\n        var fragShader: GLuint = 0\n        var vertShaderPathname: String\n        var fragShaderPathname: String\n\n        // Create shader program.\n        program = glCreateProgram()\n\n        // Create and compile vertex shader.\n        vertShaderPathname = Bundle.main.path(forResource: \"Shader\", ofType: \"vsh\")!\n        if self.compileShader(&vertShader, type: GLenum(GL_VERTEX_SHADER), file: vertShaderPathname) == false {\n            print(\"Failed to compile vertex shader\")\n            return false\n        }\n\n        // Create and compile fragment shader.\n        fragShaderPathname = Bundle.main.path(forResource: \"Shader\", ofType: \"fsh\")!\n        if !self.compileShader(&fragShader, type: GLenum(GL_FRAGMENT_SHADER), file: fragShaderPathname) {\n            print(\"Failed to compile fragment shader\")\n            return false\n        }\n\n        // Attach vertex shader to program.\n        glAttachShader(program, vertShader)\n\n        // Attach fragment shader to program.\n        glAttachShader(program, fragShader)\n\n        // Bind attribute locations.\n        // This needs to be done prior to linking.\n        glBindAttribLocation(program, GLuint(GLKVertexAttrib.position.rawValue), \"position\")\n\n        // Link program.\n        if !self.linkProgram(program) {\n            print(\"Failed to link program: \\(program)\")\n\n            if vertShader != 0 {\n                glDeleteShader(vertShader)\n                vertShader = 0\n            }\n            if fragShader != 0 {\n                glDeleteShader(fragShader)\n                fragShader = 0\n            }\n            if program != 0 {\n                glDeleteProgram(program)\n                program = 0\n            }\n\n            return false\n        }\n\n        // Get uniform locations.\n        uniforms[UNIFORM_MODELVIEWPROJECTION_MATRIX] = glGetUniformLocation(program, \"modelViewProjectionMatrix\")\n\n        // Release vertex and fragment shaders.\n        if vertShader != 0 {\n            glDetachShader(program, vertShader)\n            glDeleteShader(vertShader)\n        }\n        if fragShader != 0 {\n            glDetachShader(program, fragShader)\n            glDeleteShader(fragShader)\n        }\n\n        return true\n    }\n\n\n    func compileShader(_ shader: inout GLuint, type: GLenum, file: String) -> Bool {\n        var status: GLint = 0\n        var source: UnsafePointer<Int8>\n        do {\n            source = try NSString(contentsOfFile: file, encoding: String.Encoding.utf8.rawValue).utf8String!\n        } catch {\n            print(\"Failed to load vertex shader\")\n            return false\n        }\n        var castSource:UnsafePointer<GLchar>? = UnsafePointer<GLchar>(source)\n\n        shader = glCreateShader(type)\n        glShaderSource(shader, 1, &castSource, nil)\n        glCompileShader(shader)\n\n        //#if defined(DEBUG)\n        //        var logLength: GLint = 0\n        //        glGetShaderiv(shader, GLenum(GL_INFO_LOG_LENGTH), &logLength)\n        //        if logLength > 0 {\n        //            var log = UnsafeMutablePointer<GLchar>(malloc(Int(logLength)))\n        //            glGetShaderInfoLog(shader, logLength, &logLength, log)\n        //            NSLog(\"Shader compile log: \\n%s\", log)\n        //            free(log)\n        //        }\n        //#endif\n\n        glGetShaderiv(shader, GLenum(GL_COMPILE_STATUS), &status)\n        if status == 0 {\n            glDeleteShader(shader)\n            return false\n        }\n        return true\n    }\n\n    func linkProgram(_ prog: GLuint) -> Bool {\n        var status: GLint = 0\n        glLinkProgram(prog)\n\n        //#if defined(DEBUG)\n        //        var logLength: GLint = 0\n        //        glGetShaderiv(shader, GLenum(GL_INFO_LOG_LENGTH), &logLength)\n        //        if logLength > 0 {\n        //            var log = UnsafeMutablePointer<GLchar>(malloc(Int(logLength)))\n        //            glGetShaderInfoLog(shader, logLength, &logLength, log)\n        //            NSLog(\"Shader compile log: \\n%s\", log)\n        //            free(log)\n        //        }\n        //#endif\n\n        glGetProgramiv(prog, GLenum(GL_LINK_STATUS), &status)\n        if status == 0 {\n            return false\n        }\n\n        return true\n    }\n\n    func validateProgram(_ prog: GLuint) -> Bool {\n        var logLength: GLsizei = 0\n        var status: GLint = 0\n\n        glValidateProgram(prog)\n        glGetProgramiv(prog, GLenum(GL_INFO_LOG_LENGTH), &logLength)\n        if logLength > 0 {\n            var log: [GLchar] = [GLchar](repeating: 0, count: Int(logLength))\n            glGetProgramInfoLog(prog, logLength, &logLength, &log)\n            print(\"Program validate log: \\n\\(log)\")\n        }\n\n        glGetProgramiv(prog, GLenum(GL_VALIDATE_STATUS), &status)\n        var returnVal = true\n        if status == 0 {\n            returnVal = false\n        }\n        return returnVal\n    }\n}\n\nvar gVertexData: [GLfloat] = [\n    -0.5, -0.0, 0.0,\n    0.5,-0.5,0.0,\n    -0.5,0.5,0.0\n]\n\n\n\n\nGLKViewController\u30c6\u30f3\u30d7\u30ec\u30fc\u30c8\u304b\u3089\u30b7\u30a7\u30fc\u30c0\u3092\u4f7f\u3063\u3066\u3044\u308b\u90e8\u5206\u3092\u6b8b\u3057\u3001\u30c7\u30fc\u30bf\u3092\u4e09\u89d2\u5f62\u304c\u56de\u8ee2\u3059\u308b\u3060\u3051\u306b\u5909\u3048\u3066\u307f\u305f\u3082\u306e\u3092\u4f5c\u3063\u3066\u307f\u307e\u3057\u305f\u3002Swift3\u3067\u3059\u3002\n\n\u9802\u70b9\u30b7\u30a7\u30fc\u30c0\n\n```Shader.vsh\nattribute vec4 position;\n\nuniform mat4 modelViewProjectionMatrix;\n\nvoid main()\n{\n    gl_Position = modelViewProjectionMatrix * position;\n}\n```\n\n\u30d5\u30e9\u30b0\u30e1\u30f3\u30c8\u30b7\u30a7\u30fc\u30c0\n\n```Shader.fsh\nvoid main()\n{\n    gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);\n}\n```\n\n\nGLKViewController\u672c\u4f53\n\n```GameViewController.swift\nimport GLKit\nimport OpenGLES\n\nfunc BUFFER_OFFSET(_ i: Int) -> UnsafeRawPointer? {\n    return UnsafeRawPointer(bitPattern: i)\n}\n\n\nlet UNIFORM_MODELVIEWPROJECTION_MATRIX = 0\nvar uniforms = [GLint](repeating: 0, count: 1)\n\nclass GameViewController: GLKViewController {\n    \n    var program: GLuint = 0\n    \n    var modelViewProjectionMatrix:GLKMatrix4 = GLKMatrix4Identity\n    var rotation: Float = 0.0\n    \n    var vertexArray: GLuint = 0\n    var vertexBuffer: GLuint = 0\n    \n    var context: EAGLContext? = nil\n    \n    deinit {\n        self.tearDownGL()\n        \n        if EAGLContext.current() === self.context {\n            EAGLContext.setCurrent(nil)\n        }\n    }\n    \n    override func viewDidLoad() {\n        super.viewDidLoad()\n        \n        self.context = EAGLContext(api: .openGLES2)\n        \n        if !(self.context != nil) {\n            print(\"Failed to create ES context\")\n        }\n        \n        let view = self.view as! GLKView\n        view.context = self.context!\n        view.drawableDepthFormat = .format24\n        \n        self.setupGL()\n    }\n    \n    override func didReceiveMemoryWarning() {\n        super.didReceiveMemoryWarning()\n        \n        if self.isViewLoaded && (self.view.window != nil) {\n            self.view = nil\n            \n            self.tearDownGL()\n            \n            if EAGLContext.current() === self.context {\n                EAGLContext.setCurrent(nil)\n            }\n            self.context = nil\n        }\n    }\n    \n    func setupGL() {\n        EAGLContext.setCurrent(self.context)\n        \n        if(self.loadShaders() == false) {\n            print(\"Failed to load shaders\")\n        }\n        \n        \n        glEnable(GLenum(GL_DEPTH_TEST))\n        \n        glGenVertexArraysOES(1, &vertexArray)\n        glBindVertexArrayOES(vertexArray)\n        \n        glGenBuffers(1, &vertexBuffer)\n        glBindBuffer(GLenum(GL_ARRAY_BUFFER), vertexBuffer)\n        glBufferData(GLenum(GL_ARRAY_BUFFER), GLsizeiptr(MemoryLayout<GLfloat>.size * gVertexData.count), &gVertexData, GLenum(GL_STATIC_DRAW))\n        \n        glEnableVertexAttribArray(GLuint(GLKVertexAttrib.position.rawValue))\n        glVertexAttribPointer(GLuint(GLKVertexAttrib.position.rawValue),\n                              3,\n                              GLenum(GL_FLOAT),\n                              GLboolean(GL_FALSE),\n                              GLsizei(MemoryLayout<GLfloat>.size)*3,\n                              BUFFER_OFFSET(0))\n        \n        glBindVertexArrayOES(0)\n    }\n    \n    func tearDownGL() {\n        EAGLContext.setCurrent(self.context)\n        \n        glDeleteBuffers(1, &vertexBuffer)\n        glDeleteVertexArraysOES(1, &vertexArray)\n        \n        if program != 0 {\n            glDeleteProgram(program)\n            program = 0\n        }\n    }\n    \n    // MARK: - GLKView and GLKViewController delegate methods\n    \n    func update() {\n        let aspect = fabsf(Float(self.view.bounds.size.width / self.view.bounds.size.height))\n        let projectionMatrix = GLKMatrix4MakePerspective(GLKMathDegreesToRadians(65.0), aspect, 0.1, 100.0)\n                \n        var baseModelViewMatrix = GLKMatrix4MakeTranslation(0.0, 0.0, -4.0)\n        baseModelViewMatrix = GLKMatrix4Rotate(baseModelViewMatrix, rotation, 0.0, 1.0, 0.0)\n        \n        \n        // Compute the model view matrix for the object rendered with ES2\n        var modelViewMatrix = GLKMatrix4MakeTranslation(0.0, 0.0, 1.5)\n        modelViewMatrix = GLKMatrix4Rotate(modelViewMatrix, rotation, 1.0, 1.0, 1.0)\n        modelViewMatrix = GLKMatrix4Multiply(baseModelViewMatrix, modelViewMatrix)\n        \n        modelViewProjectionMatrix = GLKMatrix4Multiply(projectionMatrix, modelViewMatrix)\n        \n        rotation += Float(self.timeSinceLastUpdate * 0.5)\n    }\n    \n    override func glkView(_ view: GLKView, drawIn rect: CGRect) {\n        glClearColor(0.65, 0.65, 0.65, 1.0)\n        glClear(GLbitfield(GL_COLOR_BUFFER_BIT) | GLbitfield(GL_DEPTH_BUFFER_BIT))\n        \n        glBindVertexArrayOES(vertexArray)\n        \n        // Render the object again with ES2\n        glUseProgram(program)\n        \n        withUnsafePointer(to: &modelViewProjectionMatrix, {\n            $0.withMemoryRebound(to: Float.self, capacity: 4*4, {\n                glUniformMatrix4fv(uniforms[UNIFORM_MODELVIEWPROJECTION_MATRIX], 1, 0, $0)\n            })\n        })\n        \n        glDrawArrays(GLenum(GL_TRIANGLES), 0, Int32(gVertexData.count/3))\n    }\n    \n    // MARK: -  OpenGL ES 2 shader compilation\n    \n    func loadShaders() -> Bool {\n        var vertShader: GLuint = 0\n        var fragShader: GLuint = 0\n        var vertShaderPathname: String\n        var fragShaderPathname: String\n        \n        // Create shader program.\n        program = glCreateProgram()\n        \n        // Create and compile vertex shader.\n        vertShaderPathname = Bundle.main.path(forResource: \"Shader\", ofType: \"vsh\")!\n        if self.compileShader(&vertShader, type: GLenum(GL_VERTEX_SHADER), file: vertShaderPathname) == false {\n            print(\"Failed to compile vertex shader\")\n            return false\n        }\n        \n        // Create and compile fragment shader.\n        fragShaderPathname = Bundle.main.path(forResource: \"Shader\", ofType: \"fsh\")!\n        if !self.compileShader(&fragShader, type: GLenum(GL_FRAGMENT_SHADER), file: fragShaderPathname) {\n            print(\"Failed to compile fragment shader\")\n            return false\n        }\n        \n        // Attach vertex shader to program.\n        glAttachShader(program, vertShader)\n        \n        // Attach fragment shader to program.\n        glAttachShader(program, fragShader)\n        \n        // Bind attribute locations.\n        // This needs to be done prior to linking.\n        glBindAttribLocation(program, GLuint(GLKVertexAttrib.position.rawValue), \"position\")\n        \n        // Link program.\n        if !self.linkProgram(program) {\n            print(\"Failed to link program: \\(program)\")\n            \n            if vertShader != 0 {\n                glDeleteShader(vertShader)\n                vertShader = 0\n            }\n            if fragShader != 0 {\n                glDeleteShader(fragShader)\n                fragShader = 0\n            }\n            if program != 0 {\n                glDeleteProgram(program)\n                program = 0\n            }\n            \n            return false\n        }\n        \n        // Get uniform locations.\n        uniforms[UNIFORM_MODELVIEWPROJECTION_MATRIX] = glGetUniformLocation(program, \"modelViewProjectionMatrix\")\n        \n        // Release vertex and fragment shaders.\n        if vertShader != 0 {\n            glDetachShader(program, vertShader)\n            glDeleteShader(vertShader)\n        }\n        if fragShader != 0 {\n            glDetachShader(program, fragShader)\n            glDeleteShader(fragShader)\n        }\n        \n        return true\n    }\n    \n    \n    func compileShader(_ shader: inout GLuint, type: GLenum, file: String) -> Bool {\n        var status: GLint = 0\n        var source: UnsafePointer<Int8>\n        do {\n            source = try NSString(contentsOfFile: file, encoding: String.Encoding.utf8.rawValue).utf8String!\n        } catch {\n            print(\"Failed to load vertex shader\")\n            return false\n        }\n        var castSource:UnsafePointer<GLchar>? = UnsafePointer<GLchar>(source)\n        \n        shader = glCreateShader(type)\n        glShaderSource(shader, 1, &castSource, nil)\n        glCompileShader(shader)\n        \n        //#if defined(DEBUG)\n        //        var logLength: GLint = 0\n        //        glGetShaderiv(shader, GLenum(GL_INFO_LOG_LENGTH), &logLength)\n        //        if logLength > 0 {\n        //            var log = UnsafeMutablePointer<GLchar>(malloc(Int(logLength)))\n        //            glGetShaderInfoLog(shader, logLength, &logLength, log)\n        //            NSLog(\"Shader compile log: \\n%s\", log)\n        //            free(log)\n        //        }\n        //#endif\n        \n        glGetShaderiv(shader, GLenum(GL_COMPILE_STATUS), &status)\n        if status == 0 {\n            glDeleteShader(shader)\n            return false\n        }\n        return true\n    }\n    \n    func linkProgram(_ prog: GLuint) -> Bool {\n        var status: GLint = 0\n        glLinkProgram(prog)\n        \n        //#if defined(DEBUG)\n        //        var logLength: GLint = 0\n        //        glGetShaderiv(shader, GLenum(GL_INFO_LOG_LENGTH), &logLength)\n        //        if logLength > 0 {\n        //            var log = UnsafeMutablePointer<GLchar>(malloc(Int(logLength)))\n        //            glGetShaderInfoLog(shader, logLength, &logLength, log)\n        //            NSLog(\"Shader compile log: \\n%s\", log)\n        //            free(log)\n        //        }\n        //#endif\n        \n        glGetProgramiv(prog, GLenum(GL_LINK_STATUS), &status)\n        if status == 0 {\n            return false\n        }\n        \n        return true\n    }\n    \n    func validateProgram(_ prog: GLuint) -> Bool {\n        var logLength: GLsizei = 0\n        var status: GLint = 0\n        \n        glValidateProgram(prog)\n        glGetProgramiv(prog, GLenum(GL_INFO_LOG_LENGTH), &logLength)\n        if logLength > 0 {\n            var log: [GLchar] = [GLchar](repeating: 0, count: Int(logLength))\n            glGetProgramInfoLog(prog, logLength, &logLength, &log)\n            print(\"Program validate log: \\n\\(log)\")\n        }\n        \n        glGetProgramiv(prog, GLenum(GL_VALIDATE_STATUS), &status)\n        var returnVal = true\n        if status == 0 {\n            returnVal = false\n        }\n        return returnVal\n    }\n}\n\nvar gVertexData: [GLfloat] = [\n    -0.5, -0.0, 0.0,\n    0.5,-0.5,0.0,\n    -0.5,0.5,0.0\n]\n\n\n```\n"}