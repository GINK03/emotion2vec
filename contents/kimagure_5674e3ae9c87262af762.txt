{"tags": ["purescript", "Node.js", "JavaScript"], "context": "For whatever reason, I decided at 27:00 Friday that I should make a program that would get audio from videos of a Youtube channel. This article will go over the details on why and how I made this with Purescript (and some FFI).\n\nWhy\nSome Youtubers basically make podcasts with their videos, and so while they make gestures to better communicate their topics, the audio is the only content you'd really be interested in. I knew I could use youtube-dl to download the audio from these, and I could just scrape the channel page HTML with cheerio which I could get by fetching.\nI knew I could do this using these node libraries, and that I wanted to use Purescript to model my problem and help me write code that would be mechanically correct. Of course, this correctness guarantee does not fully extend to my Foreign Function Interface (FFI) code, but being able to guarantee that the rest of the program would work correctly is amazing.\n\nHow\n\nSetup\n\nOf course, I had to use a combination of tools. I used pulp to generate my project, and bower to install the modules: pulp init ytcasts && cd ytcasts && bower i -S purescript-aff purescript-affjax purescript-node-fs-aff\nThen in my project I had to make sure my node dependencies would be in order: npm init && npm i -S cheerio sqlite3 xhr2.\nAs you can see, I decided to use sqlite3 to keep track of what files were downloaded, and I had to install xhr2 so that purescript-affjax could use it for XHR.\nI set a simple schema for my DB: sqlite3 ./data\nCREATE TABLE downloads (link varchar(20) primary key, title varchar, created datetime);\n\n\nCode\n\n\"Affects\"\nI use purescript-aff for asynchronous controls. This allows me to wrote code using do blocks for what looks like synchronous code, running each asynchronous effect/\"Aff\" and getting the value back. For example, to use my sqlite database, I need to manage async processes in creating the database connection, running a query and returning its results, and closing the connection. This looks like this:\nlaunchAff do\n  conn <- newDB \"./data\"\n  rows <- queryDB conn \"SELECT 1 from downloads where link = ?\" [cast.link]\n  closeDB conn\n\nAnd these are backed up by definitions that look like this:\nnewDB :: forall e. FilePath -> Aff (db :: DBEffects | e) DBConnection\nnewDB path = makeAff (\\e s -> runFn2 _newDB path s)\n\nThis looks very complicated at first, but we can just break down the parts we need to understand. newDB is a function where you pass in a filepath (for our sqlite database file), which will return an Aff with the effects of DBEffects named \"db\" and any other effects in our system yielding DBConnection.\nThe definition uses makeAff to turn the implementation _newDB into an Aff by applying the path argument and a success callback.\nOf course, we then need to look at how DBEffects, DBConnection, and _newDB are defined.\n\nforeign data types\nThe data types are actually part of the outer system, so we define them as foreign imports:\nforeign import data DBConnection :: *\nforeign import data DBEffects :: !\n\nThe * is a kind of all types with values. In this case, as a single *, this just means that DBConnection is a data type constructed on its own, but you might remember seeing that List has the kind * -> *, which means that a type argument is supplied to create a type, like List Int.\nThe ! is a kind for effects, allowing me to identify effects in my program of DBEffects. This is useful for marking which functions will have which effects.\n\nFFI\nforeign import _newDB :: forall e.\n  Fn2\n    FilePath\n    (DBConnection -> Eff (db :: DBEffects | e) Unit)\n  (Eff (db :: DBEffects | e) Unit)\n\nHere I am importing _newDB and using Fn2 to mark that my foreign function takes two arguments, which is why above I have runFn2, for marking that I am using an uncurried function with two arguments. The second argument is for a callback which will take DBConnection as an argument and produces an effect. The actual implementation on the JS side looks like this:\nexports._newDB = function (filename, cb) {\n  return function () {\n    cb(new sqlite3.Database(filename))();\n  }\n}\n\nSo we export the function, and it has two arguments. It returns a function for what will be then executed for these provided arguments, and the callback is also called with the resolving value and then that result is called again for running the effect. It can be a little confusing, but this extra reading might be very helpful: https://leanpub.com/purescript/read#leanpub-auto-the-foreign-function-interface\n\nReading my config file\nWith the purescript-node-fs-aff library I installed, it's very easy to read a text file:\ntype Config =\n  { targets :: Array URL }\n\nforeign import parseConfig :: String -> Config\n\nmain = launchAff do\n  config <- parseConfig <$> readTextFile UTF8 \"./config.json\"\n\nOkay, so config is what's being set when everything right of <- runs, but what is on the right? <$> is the operator alias for map (or fmap in Haskell), which is implemented for all types implementing the Functor typeclass. While I could tell you that functors are homomorphisms between categories, the better explanation is that this is like your normal Array#map method, but with a twist: instead of just working on Array a, it works for any f a where f has an implementation for Functor defining map.\nSo by mapping parseConfig to the result of my config file's text, I'm able to get the configuration for my program, essentially turning Aff String into Aff Config.\n\nFetching my casts\nWe can get the gist of my program just by looking at what I have in my main function and the signatures of my other functions, so let's do that first:\ntype Cast =\n  { title :: String\n  , link :: URL\n  }\n\ndata CastStatus\n  = CastAlreadyDownloaded\n  | CastDownloaded Cast\n\ndownloadCasts :: forall e.\n  DBConnection ->\n  String ->\n  Aff (ajax :: AJAX, fs :: FS, db :: DBEffects | e) (Array CastStatus)\n\n-- launch the Affs in my program\nmain = launchAff do\n  -- get my config\n  config <- parseConfig <$> readTextFile UTF8 \"./config.json\"\n\n  -- connect to the DB\n  conn <- newDB \"./data\"\n\n  -- get target statuses for each target by downloading the casts in it\n  targetStatuses <- for config.targets $ downloadCasts conn\n\n  -- for each target, just run the Aff for reporting cast statuses\n  for_ targetStatuses $ reportTargetStatus\n\n  -- disconnect from the DB\n  closeDB conn\n\n  where\n    -- report the status for each cast\n    -- note that traverse and for are the same but with arguments flipped\n    reportTargetStatus =\n      traverse_ reportStatus\n\n    -- report the status\n    reportStatus status =\n      case status of\n        -- we don't care if it's already downloaded\n        CastAlreadyDownloaded -> pure unit\n\n        -- if it was downloaded just now, let's see the info\n        CastDownloaded cast -> log $ \"downloaded \" <> cast.title <> \" from \" <> cast.link\n\nAnd that's really the bulk of it! The details that don't matter as much are in the implementations:\ntype HTMLString = String\n\nforeign import getCasts :: HTMLString -> Array Cast\n\ndownloadCasts conn url = do\n  -- fetch the page\n  res :: AffjaxResponse String <- Affjax.get url\n\n  -- get the casts out of the page\n  let casts = getCasts res.response\n\n  -- download each of the casts in the page\n  for casts $ downloadCast conn\n\nin which getCasts looks like this:\nexports.getCasts = function(string) {\n  var $ = cheerio.load(string);\n  var casts = [];\n  $('.channels-browse-content-grid a.spf-link').each(function () {\n    var $this = $(this);\n    casts.push({\n      title: $this.text(),\n      link : 'https://www.youtube.com' + $this.attr('href')\n    });\n  });\n  return casts;\n}\n\nAnd then for downloading each cast:\ndownloadCast conn cast = do\n  -- check if we already have this cast in our DB\n  exists <- (\\rows -> 1 == length rows) <$> queryDB conn \"SELECT 1 from downloads where link = ?\" [cast.link]\n\n  case exists of\n    -- \"return\" that we have already downloaded this\n    -- that is, take the value and wrap it up in Aff\n    true -> pure CastAlreadyDownloaded\n\n    false -> do\n      -- download it now!\n      runDownload cast.link\n\n      -- add it to the DB that we downloaded it\n      queryDB conn \"INSERT INTO downloads (link, title, created) VALUES ($1, $2, datetime('now'));\" [cast.link, cast.title]\n\n      -- \"return\" that we've downloaded it\n      pure $ CastDownloaded cast\n\nAs you can see, my downloadCast function is a bit of a facade, just like how you might have implemented something similar with Promises in JS by either returning your cached value or returning a new promise that will do the work and cache your result.\n_runDownload looks like this:\nexports._runDownload = function (url, cb) {\n  return function () {\n    console.log('downloading ', url);\n    exec('youtube-dl -o downloads/%\\\\(title\\\\)s.%\\\\(ext\\\\)s -x ' + url, function (err) {\n      if (err) {\n        throw err;\n      } else {\n        cb()();\n      }\n    });\n  }\n}\n\n\nConclusion\nHopefully I've convinced you now that you can use existing libraries with Aff and/or you can implement things in FFI to write node programs and that this language is not actually hard. Give it a try sometime -- it'll be fun.\nThe complete repo can be found here: https://github.com/justinwoo/ytcasts/\nPlease let me know if you have corrections/suggestions/feedback: @jusrin00. Thanks for reading!\nThis post was written 25:00-27:00 Saturday and may not make sense in some places.\n\nLinks\n\nMy repo: https://github.com/justinwoo/ytcasts/\n\nPurescript By Example: https://leanpub.com/purescript/read\n\npurescript-aff: https://github.com/slamdata/purescript-aff\n\n\nFor whatever reason, I decided at 27:00 Friday that I should make a program that would get audio from videos of a Youtube channel. This article will go over the details on why and how I made this with Purescript (and some FFI).\n\n## Why\n\nSome Youtubers basically make podcasts with their videos, and so while they make gestures to better communicate their topics, the audio is the only content you'd really be interested in. I knew I could use youtube-dl to download the audio from these, and I could just scrape the channel page HTML with cheerio which I could get by fetching.\n\nI knew I could do this using these node libraries, and that I wanted to use Purescript to model my problem and help me write code that would be mechanically correct. Of course, this correctness guarantee does not fully extend to my Foreign Function Interface (FFI) code, but being able to guarantee that the rest of the program would work correctly is amazing.\n\n## How\n\n### Setup\n\u0013\nOf course, I had to use a combination of tools. I used pulp to generate my project, and bower to install the modules: `pulp init ytcasts && cd ytcasts && bower i -S purescript-aff purescript-affjax purescript-node-fs-aff`\n\nThen in my project I had to make sure my node dependencies would be in order: `npm init && npm i -S cheerio sqlite3 xhr2`.\n\nAs you can see, I decided to use sqlite3 to keep track of what files were downloaded, and I had to install xhr2 so that purescript-affjax could use it for XHR.\n\nI set a simple schema for my DB: `sqlite3 ./data`\n\n```sql\nCREATE TABLE downloads (link varchar(20) primary key, title varchar, created datetime);\n```\n\n### Code\n\n#### \"Affects\"\n\nI use [purescript-aff](https://github.com/slamdata/purescript-aff) for asynchronous controls. This allows me to wrote code using do blocks for what looks like synchronous code, running each asynchronous effect/\"Aff\" and getting the value back. For example, to use my sqlite database, I need to manage async processes in creating the database connection, running a query and returning its results, and closing the connection. This looks like this:\n\n```haskell\nlaunchAff do\n  conn <- newDB \"./data\"\n  rows <- queryDB conn \"SELECT 1 from downloads where link = ?\" [cast.link]\n  closeDB conn\n```\n\nAnd these are backed up by definitions that look like this:\n\n```haskell\nnewDB :: forall e. FilePath -> Aff (db :: DBEffects | e) DBConnection\nnewDB path = makeAff (\\e s -> runFn2 _newDB path s)\n```\n\nThis looks very complicated at first, but we can just break down the parts we need to understand. `newDB` is a function where you pass in a filepath (for our sqlite database file), which will return an Aff with the effects of DBEffects named \"db\" and any other effects in our system yielding DBConnection.\n\nThe definition uses `makeAff` to turn the implementation `_newDB` into an Aff by applying the path argument and a success callback.\n\nOf course, we then need to look at how `DBEffects`, `DBConnection`, and `_newDB` are defined.\n\n### foreign data types\n\nThe data types are actually part of the outer system, so we define them as foreign imports:\n\n```haskell\nforeign import data DBConnection :: *\nforeign import data DBEffects :: !\n```\n\nThe `*` is a kind of all types with values. In this case, as a single `*`, this just means that DBConnection is a data type constructed on its own, but you might remember seeing that `List` has the kind `* -> *`, which means that a type argument is supplied to create a type, like `List Int`.\n\nThe `!` is a kind for effects, allowing me to identify effects in my program of DBEffects. This is useful for marking which functions will have which effects.\n\n### FFI\n\n```haskell\nforeign import _newDB :: forall e.\n  Fn2\n    FilePath\n    (DBConnection -> Eff (db :: DBEffects | e) Unit)\n  (Eff (db :: DBEffects | e) Unit)\n```\n\nHere I am importing `_newDB` and using `Fn2` to mark that my foreign function takes two arguments, which is why above I have `runFn2`, for marking that I am using an uncurried function with two arguments. The second argument is for a callback which will take DBConnection as an argument and produces an effect. The actual implementation on the JS side looks like this:\n\n```javascript\nexports._newDB = function (filename, cb) {\n  return function () {\n    cb(new sqlite3.Database(filename))();\n  }\n}\n```\n\nSo we export the function, and it has two arguments. It returns a function for what will be then executed for these provided arguments, and the callback is also called with the resolving value and then that result is called again for running the effect. It can be a little confusing, but this extra reading might be very helpful: https://leanpub.com/purescript/read#leanpub-auto-the-foreign-function-interface\n\n### Reading my config file\n\nWith the purescript-node-fs-aff library I installed, it's very easy to read a text file:\n\n```haskell\ntype Config =\n  { targets :: Array URL }\n\nforeign import parseConfig :: String -> Config\n\nmain = launchAff do\n  config <- parseConfig <$> readTextFile UTF8 \"./config.json\"\n```\n\nOkay, so config is what's being set when everything right of `<-` runs, but what is on the right? `<$>` is the operator alias for `map` (or `fmap` in Haskell), which is implemented for all types implementing the `Functor` typeclass. While I could tell you that functors are homomorphisms between categories, the better explanation is that this is like your normal `Array#map` method, but with a twist: instead of just working on `Array a`, it works for any `f a` where `f` has an implementation for `Functor` defining `map`.\n\nSo by mapping `parseConfig` to the result of my config file's text, I'm able to get the configuration for my program, essentially turning `Aff String` into `Aff Config`.\n\n### Fetching my casts\n\nWe can get the gist of my program just by looking at what I have in my main function and the signatures of my other functions, so let's do that first:\n\n```haskell\ntype Cast =\n  { title :: String\n  , link :: URL\n  }\n\ndata CastStatus\n  = CastAlreadyDownloaded\n  | CastDownloaded Cast\n\ndownloadCasts :: forall e.\n  DBConnection ->\n  String ->\n  Aff (ajax :: AJAX, fs :: FS, db :: DBEffects | e) (Array CastStatus)\n\n-- launch the Affs in my program\nmain = launchAff do\n  -- get my config\n  config <- parseConfig <$> readTextFile UTF8 \"./config.json\"\n\n  -- connect to the DB\n  conn <- newDB \"./data\"\n\n  -- get target statuses for each target by downloading the casts in it\n  targetStatuses <- for config.targets $ downloadCasts conn\n\n  -- for each target, just run the Aff for reporting cast statuses\n  for_ targetStatuses $ reportTargetStatus\n\n  -- disconnect from the DB\n  closeDB conn\n\n  where\n    -- report the status for each cast\n    -- note that traverse and for are the same but with arguments flipped\n    reportTargetStatus =\n      traverse_ reportStatus\n\n    -- report the status\n    reportStatus status =\n      case status of\n        -- we don't care if it's already downloaded\n        CastAlreadyDownloaded -> pure unit\n\n        -- if it was downloaded just now, let's see the info\n        CastDownloaded cast -> log $ \"downloaded \" <> cast.title <> \" from \" <> cast.link\n```\n\nAnd that's really the bulk of it! The details that don't matter as much are in the implementations:\n\n```haskell\ntype HTMLString = String\n\nforeign import getCasts :: HTMLString -> Array Cast\n\ndownloadCasts conn url = do\n  -- fetch the page\n  res :: AffjaxResponse String <- Affjax.get url\n\n  -- get the casts out of the page\n  let casts = getCasts res.response\n\n  -- download each of the casts in the page\n  for casts $ downloadCast conn\n```\n\nin which getCasts looks like this:\n\n```javascript\nexports.getCasts = function(string) {\n  var $ = cheerio.load(string);\n  var casts = [];\n  $('.channels-browse-content-grid a.spf-link').each(function () {\n    var $this = $(this);\n    casts.push({\n      title: $this.text(),\n      link : 'https://www.youtube.com' + $this.attr('href')\n    });\n  });\n  return casts;\n}\n```\n\nAnd then for downloading each cast:\n\n```haskell\ndownloadCast conn cast = do\n  -- check if we already have this cast in our DB\n  exists <- (\\rows -> 1 == length rows) <$> queryDB conn \"SELECT 1 from downloads where link = ?\" [cast.link]\n\n  case exists of\n    -- \"return\" that we have already downloaded this\n    -- that is, take the value and wrap it up in Aff\n    true -> pure CastAlreadyDownloaded\n\n    false -> do\n      -- download it now!\n      runDownload cast.link\n\n      -- add it to the DB that we downloaded it\n      queryDB conn \"INSERT INTO downloads (link, title, created) VALUES ($1, $2, datetime('now'));\" [cast.link, cast.title]\n\n      -- \"return\" that we've downloaded it\n      pure $ CastDownloaded cast\n```\n\nAs you can see, my `downloadCast` function is a bit of a facade, just like how you might have implemented something similar with Promises in JS by either returning your cached value or returning a new promise that will do the work and cache your result.\n\n`_runDownload` looks like this:\n\n```javascript\nexports._runDownload = function (url, cb) {\n  return function () {\n    console.log('downloading ', url);\n    exec('youtube-dl -o downloads/%\\\\(title\\\\)s.%\\\\(ext\\\\)s -x ' + url, function (err) {\n      if (err) {\n        throw err;\n      } else {\n        cb()();\n      }\n    });\n  }\n}\n```\n\n## Conclusion\n\nHopefully I've convinced you now that you can use existing libraries with Aff and/or you can implement things in FFI to write node programs and that this language is not actually hard. Give it a try sometime -- it'll be fun.\n\nThe complete repo can be found here: https://github.com/justinwoo/ytcasts/\n\nPlease let me know if you have corrections/suggestions/feedback: [@jusrin00](http://twitter.com/jusrin00). Thanks for reading!\n\n*This post was written 25:00-27:00 Saturday and may not make sense in some places.*\n\n## Links\n\n* My repo: https://github.com/justinwoo/ytcasts/\n* Purescript By Example: https://leanpub.com/purescript/read\n* purescript-aff: https://github.com/slamdata/purescript-aff\n"}