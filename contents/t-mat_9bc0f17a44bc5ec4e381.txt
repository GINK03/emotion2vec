{"context": " More than 1 year has passed since last update.Qiita\u521d\u6295\u7a3f\u3067\u3059\u3002\n\u3068\u308a\u3042\u3048\u305a\u3001\u4f55\u304b\u6295\u7a3f\u3057\u305f\u3044\u3068\u601d\u3044\u3001\u6614\u4f5c\u3063\u305f\u3001\u306f\u3066\u306a\u30d6\u30c3\u30af\u30de\u30fc\u30af\u3092TreeMap\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0\u3067\u8868\u793a\u3059\u308bWeb\u30a2\u30d7\u30ea\u3092\u30ea\u30d5\u30a1\u30a4\u30f3\u3057\u3066\u307f\u307e\u3057\u305f\u3002 \n\u30c7\u30fc\u30bf\u306eTreeMap\u8868\u793a\u306f\u300c\u30d3\u30b8\u30e5\u30a2\u30e9\u30a4\u30b8\u30f3\u30b0\u30c7\u30fc\u30bf\u300d\u3067\u7d39\u4ecb\u3055\u308c\u3066\u3044\u305f\u624b\u6cd5\u3067\u3001\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0\u306fTreemaps for space-constrained visualization of hierarchies\u3067\u8a73\u3057\u304f\u89e3\u8aac\u3055\u308c\u3066\u3044\u307e\u3059\u3002\nGoogle Feed API\u3067\u53d6\u5f97\u3057\u305f\u306f\u3066\u306a\u30d6\u30c3\u30af\u30de\u30fc\u30af\u306e\u30db\u30c3\u30c8\u30a8\u30f3\u30c8\u30ea\u3092\u5143\u306bTreeMap\u30c7\u30fc\u30bf\u3092\u4f5c\u6210\u3057\u3001Processing.js\u3067\u63cf\u753b\u3057\u3066\u3044\u307e\u3059\u3002\n\u4e00\u5fdc\u3001JSBin\u306b\u3082\u30bd\u30fc\u30b9\u30b3\u30fc\u30c9\u3092\u767b\u9332\u3057\u307e\u3057\u305f\u3002\n\nhatena_treemap.html\n<html lang=\"jp\" class=\"ui-mobile landscape\">\n<head>\n<meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\" />\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\n<meta http-equiv=\"X-UA-Compatible\" content=\"IE=8\"/>\n<base href=\".\">\n<title>Hatemap</title>\n<style type=\"text/css\">\n#toptitle{\n    width:600px;\n    margin: 0 auto;\n    font-family: Georgia, Times, serif;\n    font-size: 24px;\n    font-weight: bold;\n    color: #ffffff;\n    background-color: #cccccc;\n    vertical-align : bottom;\n    line-height: 38px;\n}\n</style>\n<script src=\"http://ajax.googleapis.com/ajax/libs/jquery/2.1.3/jquery.min.js\"></script>\n<script type=\"text/javascript\" src=\"https://cdnjs.cloudflare.com/ajax/libs/processing.js/1.4.8/processing.js\"></script>\n<script type=\"text/javascript\" src=\"https://www.google.com/jsapi\"></script>\n<script type=\"text/javascript\">\nvar scwidth;\nvar scheight;\nvar proc;\nvar root;\nvar tmp=[];\nvar urls=[\n    ['http://feeds.feedburner.com/hatena/b/hotentry'],\n    ['http://b.hatena.ne.jp/hotentry/social.rss',\n        'http://b.hatena.ne.jp/hotentry/economics.rss',\n        'http://b.hatena.ne.jp/hotentry/life.rss',\n        'http://b.hatena.ne.jp/hotentry/entertainment.rss',\n        'http://b.hatena.ne.jp/hotentry/knowledge.rss',\n        'http://b.hatena.ne.jp/hotentry/it.rss',\n        'http://b.hatena.ne.jp/hotentry/game.rss',\n        'http://b.hatena.ne.jp/hotentry/fun.rss'],\n    ['http://b.hatena.ne.jp/entrylist?sort=hot&threshold=&mode=rss&']\n];\n\ngoogle.load(\"feeds\", \"1\");\n\n$(document).ready(function(){\n    scwidth=600;\n    scheight=600;\n    $(\"#canvas\").attr(\"width\",scwidth);\n    $(\"#canvas\").attr(\"height\",scheight);\n    initLayer();\n    $(\"#layer\").css(\"font-size\",\"16px\");\n    $(\"#layer\").css(\"padding\",\"10px 0px 0px 10px\");\n    var canvas = document.getElementById('canvas');\n    var codeElm = document.getElementById('processing-code');\n    var code = codeElm.textContent || codeElm.innerText;\n    proc=new Processing(canvas, code);\n    var list=[];\n    for(var i=0;i<urls[2].length;i++)list[i]=urls[2][i];\n    hatebu_Init(list);\n});\n\nvar initLayer=function(){\n    var off=$(\"#canvas\").offset();\n    var ox=off.left;\n    var oy=off.top+20;  \n    $(\"#layer\").css(\"z-index\",\"0\");\n    $(\"#layer\").css(\"position\",\"absolute\");\n    $(\"#layer\").css(\"top\",oy+10+\"px\");\n    $(\"#layer\").css(\"line-height\",\"20px\");\n    $(\"#layer\").css(\"left\",(ox+20)+\"px\");\n    $(\"#layer\").css(\"width\",(scwidth-40)+\"px\");\n    var mm=Math.max(300,(scheight*0.45));\n    $(\"#layer\").css(\"height\",mm+\"px\");\n    $(\"#layer\").css(\"background-color\",\"#ffffff\");\n    $(\"#layer\").css(\"opacity\",\"0.9\");\n    $(\"#layer\").css(\"display\",\"none\");\n};\n\nvar hatebu_Init=function(list){\n    page=0;\n    numOfBookmark=0;\n    tmp=[];\n    root={name:\"TOP\",size:0};\n    root.array=[];\n    var now=new Date();\n    var q=now.getMonth();\n    var q2=now.getDate();\n    var q3=now.getHours();\n    hatebu_Analyze(list,q+\"0\"+q2+\"0\"+q3);\n};\n\nvar hatebu_Analyze=function(list,dummy){\n    startLoading();\n    var url=list.shift();\n    if(dummy)url=url+\"?\"+dummy;\n    var feed = new google.feeds.Feed(url);\n    feed.setNumEntries(100);\n    feed.setResultFormat(google.feeds.Feed.MIXED_FORMAT);   \n    feed.load(function(result) {\n        if (!result.error) {\n            var entries = result.feed.entries;\n            if(entries.length>0){\n                for (var i = 0; i < entries.length; i++) {\n                    var obj=new Object();\n                    obj.name=entries[i].title;\n                    obj.link=entries[i].link;\n                    obj.content=entries[i].content;\n                    var category=$(entries[i].xmlNode.getElementsByTagNameNS(\"http://purl.org/dc/elements/1.1/\",\"subject\")[0]).text();\n                    if(!tmp[category]){\n                        tmp[category]={name:category};\n                        tmp[category].size=0;\n                        tmp[category].array=[];\n                        root.array.push(tmp[category]);\n                    }\n                    obj.size=parseInt($(entries[i].xmlNode.getElementsByTagNameNS(\"http://www.hatena.ne.jp/info/xmlns#\",\"bookmarkcount\")[0]).text());\n                    tmp[category].array.push(obj);\n                }\n            }\n        }else{\n            alert(\"\u30a8\u30f3\u30c8\u30ea\u304c\u898b\u3064\u304b\u308a\u307e\u305b\u3093\u3067\u3057\u305f\u3002\");\n            return;\n        }\n        if(list.length>0){\n            hatebu_Analyze(list,dummy);\n        }else{\n            proc.setRoot(root);\n        }\n    });\n};\n\nvar startLoading=function(){\n    closeLayer();\n    proc.loading();\n};\n\nvar showLayer=function(html,link){\n    initLayer();\n    var code=html.replace(\"blockquote\",\"div\");\n    setTimeout(function(){\n        $(\"#layer\").css(\"display\",\"inline\");\n        $(\"#layer\").html(code);\n\n        var msg=$(\"#layer div\").text();\n        var aa=$(\"#layer div p a\").text();\n        msg=msg.replace(aa,\"\");\n        msg=msg.replace(\"\u7d9a\u304d\u3092\u8aad\u3080\",\"\");\n        msg=replaceAll(msg,\"\\n\",\"\");\n        msg=replaceAll(msg,\" \",\"\");\n        $(\"#layer div cite a\").attr(\"target\",\"_blank\");\n        var name=$(\"#layer div p a img:first\").attr(\"src\");\n        if(name&&name.indexOf(\"http://b.hatena.ne.jp/\")==-1)\n            $(\"#layer div p a img:first\").attr(\"height\",\"90px\");\n        $(\"#layer div p a\").attr(\"target\",\"_blank\");\n        if($(\"#layer div p\").length>=4){\n            $(\"#layer div p:last\").remove();\n        }\n    },500);\n};\n\nvar closeLayer=function(){\n    $(\"#layer\").css(\"display\",\"none\");\n    $(\"#layer\").empty();\n};\n\nvar arraycopy=function(src,srcPos,dest,destPos,length){\n    while (length > 0){\n     dest[destPos] = src[srcPos];\n     srcPos++;\n     destPos++;\n     length--;\n    }\n};\n\nvar replaceAll=function(expression, org, dest){\n    return expression.split(org).join(dest);\n};\n</script>\n\n<script id=\"processing-code\" type=\"application/processing\">\nBoundsIntegrator zoomBounds;\nGroupItem rootItem;\nLeafItem rolloverItem;\nGroupItem taggedItem;\nLeafItem zoomItem;\nfinal int PIVOT_BY_MIDDLE = 1;\nfinal int PIVOT_BY_SPLIT_SIZE = 2;\nfinal int PIVOT_BY_BIGGEST = 3;\nboolean isLoading=false;\nfloat ATTRACTION = 0.8f;\nfloat DAMPING = 0.4f;\nint alphaL=25;\n\nvoid setup() {\n    size(scwidth,scheight);\n    PFont font=createFont(\"FFScala\", 24);\n    textFont(font);\n    textSize(16);\n    zoomBounds = new BoundsIntegrator(0, 0, width, height);\n    rectMode(CORNERS);\n    smooth();\n    noStroke();\n    textMode(SCREEN);\n}\n\nvoid setRoot(array) {\n    closeLayer();\n    GroupItem tm = new GroupItem(null, array, 0, 0);\n    tm.setBounds(0, 0, width, height);\n    tm.contentsVisible = true;\n    rootItem = tm;\n    rootItem.zoomIn();\n    rootItem.updateColors();\n    isLoading=false;\n}\n\nvoid loading(){\n    isLoading=true;\n}\n\nvoid drawLoading(){\n    background(0);\n    frameRate(10);\n    noStroke();\n    int r=5;\n    int rr=10;\n    int sx=scwidth/2-rr*2;\n    int sy=scheight/2-rr*2;\n    fill(126,126,126,alphaL);alphaL=(alphaL+10)%256;\n    ellipse(sx+3*rr, sy+0*rr, 2*r, 2*r);\n    fill(126,126,126,alphaL);alphaL=(alphaL+25)%256;\n    ellipse(sx+5*rr, sy+1*rr, 2*r, 2*r);\n    fill(126,126,126,alphaL);alphaL=(alphaL+25)%256;\n    ellipse(sx+6*rr, sy+3*rr, 2*r, 2*r);\n    fill(126,126,126,alphaL);alphaL=(alphaL+25)%256;\n    ellipse(sx+5*rr, sy+5*rr, 2*r, 2*r);\n    fill(126,126,126,alphaL);alphaL=(alphaL+25)%256;\n    ellipse(sx+3*rr, sy+6*rr, 2*r, 2*r);\n    fill(126,126,126,alphaL);alphaL=(alphaL+25)%256;\n    ellipse(sx+1*rr, sy+5*rr, 2*r, 2*r);\n    fill(126,126,126,alphaL);alphaL=(alphaL+25)%256;\n    ellipse(sx+0*rr, sy+3*rr, 2*r, 2*r);\n    fill(126,126,126,alphaL);alphaL=(alphaL+25)%256;\n    ellipse(sx+1*rr, sy+1*rr, 2*r, 2*r);\n}\n\nvoid draw() {\n    if(isLoading){\n        drawLoading();\n        return;\n    }\n    background(0);\n    frameRate(30);\n    zoomBounds.update();\n    rolloverItem = null;\n    taggedItem = null;\n    if (rootItem != null) rootItem.draw();\n    if (rolloverItem != null) rolloverItem.drawTitleBar();\n    if (taggedItem != null) taggedItem.drawTag();\n}\n\nvoid mousePressed() {\n    if (zoomItem != null) {\n        zoomItem.mousePressed();\n    }\n}\n\nvoid zoomOut(){\n    if (zoomItem != null) {\n        mouseButton=RIGHT;\n        zoomItem.mousePressed();\n    }\n}\n\nclass BoundsIntegrator {\n    float valueX, velocityX, accelerationX;\n    float valueY, velocityY, accelerationY;\n    float valueW, velocityW, accelerationW;\n    float valueH, velocityH, accelerationH;\n    float damping;\n    float attraction;\n    boolean targeting;\n    float targetX, targetY, targetW, targetH;\n\n    BoundsIntegrator(float x, float y, float w, float h) {\n        this.valueX = x;\n        this.valueY = y;\n        this.valueW = w;\n        this.valueH = h;\n        this.damping = DAMPING;\n        this.attraction = ATTRACTION;\n    }\n\n    void set(float x, float y, float w, float h) {\n        this.valueX = x;\n        this.valueY = y;\n        this.valueW = w;\n        this.valueH = h;\n    }\n\n    float getX() {\n        return valueX;\n    }\n\n    float getY() {\n        return valueY;\n    }\n\n    float getW() {\n        return valueW;\n    }\n\n    float getH() {\n        return valueH;\n    }\n\n    float spanX(float pointX, float start, float span) {\n        if (valueW != 0) {\n            float n = (pointX - valueX) / valueW;\n            return start + n*span;\n        } else {\n            return Float.NaN;\n        }\n    }\n\n    float spanY(float pointY, float start, float span) {\n        if (valueH != 0) {\n            float n = (pointY - valueY) / valueH;\n            return start + n*span;\n        } else {\n            return Float.NaN;\n        }\n    }\n\n    void setAttraction(float a) {\n        attraction = a;\n    }\n\n    void setDamping(float d) {\n        damping = d;\n    }\n\n    boolean update() {\n        if (targeting) {\n            accelerationX += attraction * (targetX - valueX);\n            velocityX = (velocityX + accelerationX) * damping;\n            valueX += velocityX;\n            accelerationX = 0;\n            boolean updated = (Math.abs(velocityX) > 0.0001f);\n            accelerationY += attraction * (targetY - valueY);\n            velocityY = (velocityY + accelerationY) * damping;\n            valueY += velocityY;\n            accelerationY = 0;\n            updated |= (Math.abs(velocityY) > 0.0001f);\n            accelerationW += attraction * (targetW - valueW);\n            velocityW = (velocityW + accelerationW) * damping;\n            valueW += velocityW;\n            accelerationW = 0;\n            updated |= (Math.abs(velocityW) > 0.0001f);\n            accelerationH += attraction * (targetH - valueH);\n            velocityH = (velocityH + accelerationH) * damping;\n            valueH += velocityH;\n            accelerationH = 0;\n            updated |= (Math.abs(velocityH) > 0.0001f);\n        }\n        return false;\n    }\n\n    void target(float tx, float ty, float tw, float th) {\n        targeting = true;\n        targetX = tx;\n        targetY = ty; \n        targetW = tw;\n        targetH = th;\n    }\n\n    void targetLocation(float tx, float ty) {\n        targeting = true;\n        targetX = tx;\n        targetY = ty;\n    }\n\n    void targetSize(float tw, float th) {\n        targeting = true;\n        targetW = tw;\n        targetH = th;\n    }\n\n    void targetX(float tx) {\n        targeting = true;\n        targetX = tx;\n    }\n\n    void targetY(float ty) {\n        targeting = true;\n        targetY = ty;\n    }\n\n    void targetW(float tw) {\n        targeting = true;\n        targetW = tw;\n    }\n\n    void targetH(float th) {\n        targeting = true;\n        targetH = th;\n    }\n}\n\nclass LeafItem extends SimpleMapItem {\n    GroupItem parent;    \n    Object obj;\n    String name;\n    int level;\n    color c;\n    float hue;\n    float brightness;\n    float textPadding = 8;\n    float boxLeft, boxTop;\n    float boxRight, boxBottom;\n\n    LeafItem(GroupItem parent, Object obj, int level, int order) {\n        this.parent = parent;\n        this.obj = obj;\n        this.order = order;\n        this.level = level;\n        name=obj.name;\n        if(name.length>30)name=name.substring(0,30)+\"...\";\n        size = obj.size;\n    }\n    void updateColors() {\n        if (parent != null) {\n            hue = map(order, 0, parent.getItemCount(), 0, 360);\n        }\n        brightness = Math.min(100.0/((float)level*0.8),100.0);      \n        colorMode(HSB, 360, 100, 100);\n        if (parent == zoomItem) {\n            c = color(hue, 60, 60);\n        } else if (parent != null) {\n            color pc = color(parent.hue, 60, 60);\n            c = color(hue, brightness, brightness);\n            colorMode(RGB, 255);\n            c=blendColor(c,pc,SCREEN)\n        }\n        colorMode(RGB, 255);\n    }\n\n    void calcBox() {\n        boxLeft = zoomBounds.spanX(x, 0, width);\n        boxRight = zoomBounds.spanX(x+w, 0, width);\n        boxTop = zoomBounds.spanY(y, 0, height);\n        boxBottom = zoomBounds.spanY(y+h, 0, height);\n    }\n\n    void draw() {\n        calcBox();\n        if(mouseInside()){\n            fill(c,255);\n        }else{\n            fill(c,200);\n        }\n//      fill(c);\n        rect(boxLeft, boxTop, boxRight, boxBottom);\n        stroke(128);\n        rect(boxLeft, boxTop, boxRight, boxBottom);\n        if (textFits()) {\n            drawTitle();\n            drawTitle3();\n        }else if(textFits2()){\n            drawTitle2(14);\n            drawTitle3();\n        } else if (mouseInside()) {\n            rolloverItem = this;\n        }else{\n            textSize(12);\n            if(textFits2()){\n                drawTitle2(12);     \n            }else{\n                textSize(10);\n                if(textFits2())drawTitle2(10)\n            }\n            drawTitle3();\n        }\n    }\n\n    void drawTitleBar(){\n        if (textFits()) {\n            drawTitle();\n            drawTitle3();\n        }else if (textFits3()) {\n            drawTitle();\n            drawTitle3();   \n        }else if(textFits2()){\n            drawTitle2(14);\n            drawTitle3();\n        }else{\n            textSize(12);\n            if(textFits2()){\n                drawTitle2(12);     \n            }else{\n                textSize(10);\n                drawTitle2(10)\n            }\n            drawTitle3();\n        }\n        textSize(16);\n    }\n\n    void drawTitle() {\n        fill(255, 200);\n        textAlign(LEFT);\n        text(name, boxLeft + textPadding, boxBottom - textPadding);\n    }\n\n    void drawTitle2(int n) {\n        fill(255, 200);\n        textSize(n);\n        float ascent = textAscent();\n        text(name,boxLeft + textPadding, boxBottom -ascent - textPadding*2,boxRight-boxLeft,ascent + textPadding*2);\n        textSize(16);\n    }\n    void drawTitle3() {\n        if(zoomItem!=this){\n            fill(255, 200);\n            float middleX = (boxLeft + boxRight) / 2;\n            float middleY = (boxTop + boxBottom) / 2;\n            String tp=this.size;\n            int ww=(boxRight-boxLeft)/2;\n            ww=(int)Math.min(ww,(boxBottom-boxTop)/2);\n            if(ww>=192){\n                textSize(128);\n            }else if(ww>=96){\n                textSize(64);\n            }else if(ww>=48){\n                textSize(32);\n            }else if(ww>=24){\n                textSize(16);\n            }else if(ww>=18){\n                textSize(12);   \n            }else if(ww>=12){\n                textSize(8);            \n            }else{\n                return ;\n            }\n            float ascent = textAscent();\n            text(tp, boxLeft+5,boxTop+ascent+5);\n            textSize(16);\n        }\n    }\n\n    boolean textFits() {\n        int s=64;\n        while(s>16){\n            textSize(s);\n            if(checkTextFits(name)){\n                return true;\n            }else{\n                s *=0.75;\n            }\n        }\n        return false;\n    }\n\n    boolean checkTextFits(String n){\n        float wide = textWidth(n) + textPadding*2;\n        float high = textAscent() + textDescent() + textPadding*2;\n        return (boxRight - boxLeft > wide) && (boxBottom - boxTop > high);\n    }\n\n    boolean textFits2() {\n        int l=name.length()/2;\n        if(l%2!=0)l++;\n        String n2=name.substring(0,l);\n        float wide = textWidth(n2) + textPadding*4;\n        float high = textAscent()*3 + textDescent()*3 + textPadding*6;\n        return (boxRight - boxLeft > wide) && (boxBottom - boxTop > high); \n    }\n\n    boolean textFits3() {\n        float wide = textWidth(name) + textPadding*2;\n        return (boxRight - boxLeft > wide); \n    }\n\n    boolean mouseInside() {\n        return (mouseX > boxLeft && mouseX < boxRight && \n            mouseY > boxTop && mouseY < boxBottom);    \n    }\n\n    boolean mousePressed() {\n        if (mouseInside()) {\n            if (mouseButton == LEFT) {\n                if(parent.contentsVisible){\n                    if(parent.isZoom){\n                        if(zoomItem!=this){\n                            zoomItem = this;\n                            zoomBounds.target(x, y, w, h);\n                            showLayer(obj.content,obj.link);\n                        }else{\n                            showLayer(obj.content,obj.link);\n                        }\n                    }else{\n                        parent.zoomIn();\n                    }\n                }else{\n                    parent.zoomIn();\n                }\n                return true;\n            } else if (mouseButton == RIGHT) {\n                if(zoomItem == this){\n                    zoomItem = parent;\n                    parent.zoomIn();\n                }else if (parent == zoomItem) {\n                    parent.zoomOut();\n                } else {\n                    parent.hideContents();\n                }\n                closeLayer();\n                return true;\n            }\n        }\n        return false;\n    }\n}\n\nclass GroupItem extends LeafItem implements MapModel {\n    MapLayout algorithm = new SquarifiedLayout();\n    Mappable[] items;\n    boolean contentsVisible;\n    boolean layoutValid;\n    float darkness;\n    boolean isZoom=false;\n    GroupItem(GroupItem parent, Object folder, int level, int order) {\n        super(parent, folder, level, order);\n        ArrayList contents = folder.array;\n        if (contents) {\n            contents = sort(contents);\n            items = new Mappable[contents.length];\n            int count = 0;\n            for (int i = 0; i < contents.length; i++) {\n                if (contents[i].array) {\n                    GroupItem newItem = new GroupItem(this, contents[i], level+1, count);\n                    items[count++] = newItem;\n                    size += newItem.getSize();\n                } else {\n                    LeafItem newItem = new LeafItem(this, contents[i], level+1, count);\n                    items[count++] = newItem;\n                    size += newItem.getSize();\n                }\n            }\n            if (count != items.length) {\n                items = (Mappable[]) subset(items, 0, count);\n            }\n        } else {\n            items = new Mappable[0];\n        }\n    }\n\n    void updateColors() {\n        super.updateColors();\n        for (int i = 0; i < items.length; i++) {\n            LeafItem fi = (LeafItem) items[i];\n            fi.updateColors();\n        }\n    }\n\n    void checkLayout() {\n        if (!layoutValid) {\n            if (getItemCount() != 0) {\n                algorithm.layout(this, bounds);\n            }\n            layoutValid = true;\n        }\n    }\n\n    boolean mousePressed() {\n        if (mouseInside()) {\n            if (contentsVisible) {\n                for (int i = 0; i < items.length; i++) {\n                    LeafItem fi = (LeafItem) items[i];\n                    if (fi.mousePressed()) {\n                        return true;\n                    }\n                }\n            } else {\n                if (mouseButton == LEFT) {\n                    if (parent == zoomItem) {\n                        showContents();\n                    } else {\n                        parent.zoomIn();\n                    }            \n                } else if (mouseButton == RIGHT) {\n                    if (parent == zoomItem) {\n                        parent.zoomOut();\n                    } else {\n                        parent.hideContents();\n                    }\n                }\n                return true;\n            }\n        }\n        return false;\n    }\n\n    void zoomOut() {\n        if (parent != null) {\n            for (int i = 0; i < items.length; i++) {\n                if (items[i] instanceof GroupItem) {\n                    ((GroupItem)items[i]).hideContents();\n                }\n            }\n            parent.zoomIn();\n        }\n        isZoom=false;\n    }\n\n    void zoomIn() {\n        zoomItem = this;\n        zoomBounds.target(x, y, w, h);\n        isZoom=true;\n    }\n\n    void showContents() {\n        contentsVisible = true;\n    }\n\n    void hideContents() {\n        if (parent != null)contentsVisible = false;\n    }\n\n    void draw() {\n        checkLayout();\n        calcBox();\n        if (contentsVisible) {\n            for (int i = 0; i < items.length; i++) {\n                items[i].draw();\n            }\n        } else {\n            super.draw();\n        }\n        if (contentsVisible) {\n            if (mouseInside()) {\n                if (parent == zoomItem) {\n                    taggedItem = this;\n                }\n            }\n        }\n        if (mouseInside()) {\n            darkness *= 0.05;\n        } else {\n            darkness += (150 - darkness) * 0.05;\n        }\n        darkness=Math.min(darkness,80);\n        if (parent == zoomItem) {\n            colorMode(RGB, 255);\n            fill(0, darkness);\n            rect(boxLeft, boxTop, boxRight, boxBottom);\n        }\n    }\n\n    void drawTitle() {\n        if (!contentsVisible) super.drawTitle();\n    }\n\n    void drawTag() {\n        float boxHeight = textAscent() + textPadding*2;\n        if (boxBottom - boxTop > boxHeight*2) {\n            fill(0, 128);\n            rect(boxLeft, boxTop, boxRight, boxTop+boxHeight);\n            fill(255);\n            textAlign(LEFT, TOP);\n            text(name, boxLeft+textPadding, boxTop+textPadding);\n        } else if (boxTop > boxHeight) {\n            fill(0, 128);\n            rect(boxLeft, boxTop-boxHeight, boxRight, boxTop);\n            fill(255);\n            text(name, boxLeft+textPadding, boxTop-textPadding);\n        } else if (boxBottom + boxHeight < height) {\n            fill(0, 128);\n            rect(boxLeft, boxBottom, boxRight, boxBottom+boxHeight);\n            fill(255);\n            textAlign(LEFT, TOP);\n            text(name, boxLeft+textPadding, boxBottom+textPadding);\n        }\n    }\n\n    Mappable[] getItems() {\n        return items;\n    }\n\n    int getItemCount() {\n        return items.length;\n    }\n}\n\nclass Rect{\n    double x,y,w,h;\n\n    Rect(){\n        this(0,0,1,1);\n    }\n\n    Rect(Rect r){\n        setRect(r.x, r.y, r.w, r.h);\n    }\n\n    Rect(double x, double y, double w, double h){\n        setRect(x, y, w, h);\n    }\n\n    void setRect(double x, double y, double w, double h) {\n        this.x = x;\n        this.y = y;\n        this.w = w;\n        this.h = h;\n    }\n\n    double aspectRatio(){\n        return Math.max(w/h, h/w);\n    }\n\n    double distance(Rect r){\n        return Math.sqrt((r.x-x)*(r.x-x)+\n                    (r.y-y)*(r.y-y)+\n                    (r.w-w)*(r.w-w)+\n                    (r.h-h)*(r.h-h));\n    }\n\n    Rect copy(){\n        return new Rect(x,y,w,h);\n    }\n\n    String toString(){\n        return \"Rect: \"+x+\", \"+y+\", \"+w+\", \"+h;\n    }\n}\ninterface MapModel{\n    Mappable[] getItems();\n}\n\ninterface MapLayout{\n    void layout(MapModel model, Rect bounds);\n    void layout(MapModel model, double x, double y, double w, double h);\n}\n\ninterface Mappable {\n    double getSize();\n    void setSize(double size);\n    Rect getBounds();\n    void setBounds(Rect bounds);\n    void setBounds(double x, double y, double w, double h);\n    int getOrder();\n    void setOrder(int order);\n    int getDepth();\n    void setDepth(int depth);\n    void draw();\n}\n\nclass SimpleMapItem implements Mappable {\n    double size;\n    Rect bounds;\n    int order = 0;\n    int depth;\n    float x, y, w, h;\n\n    SimpleMapItem() {\n        this(1, 0);\n    }\n\n    SimpleMapItem(double size, int order) {\n        this.size = size;\n        this.order = order;\n        bounds = new Rect();\n    }\n\n    double getSize() {\n        return size;\n    }\n\n    void setSize(double size) {\n        this.size = size;\n    }\n\n    void incrementSize() {\n        size++;\n    }\n\n    Rect getBounds() {\n        return bounds;\n    }\n\n    void setBounds(Rect bounds) {\n        this.bounds = bounds;\n        x = (float) bounds.x;\n        y = (float) bounds.y;\n        w = (float) bounds.w;\n        h = (float) bounds.h;\n    }\n\n    void setBounds(double bx, double by, double bw, double bh) {\n        setBounds(new Rect(bx, by, bw, bh));\n    }\n\n    int getOrder() {\n        return order;\n    }\n\n    void setOrder(int order) {\n        this.order = order;\n    }\n\n    void setDepth(int depth) {\n        this.depth = depth;\n    }\n\n    int getDepth() {\n        return depth;\n    }\n\n    void draw() {}\n}\n\nclass SquarifiedLayout implements MapLayout{\n    int VERTICAL=0, HORIZONTAL=1;\n    int ASCENDING=0, DESCENDING=1;\n\n    void layout(MapModel model, Rect bounds){\n        layout(model.getItems(),bounds);\n    }\n    void layout(MapModel model, double x, double y, double w, double h){\n        layout(model, new Rect(x, y, w, h));\n    }\n\n    void layout(Mappable[] items, Rect bounds){\n        if(!items.length)items=items.getItems();\n        layout(sortDescending(items),0,items.length-1,bounds);\n    }\n\n    void layout(Mappable[] items, int start, int end, Rect bounds){\n        if (start>end) return;\n        if (end-start<2){\n            layoutBest(items,start,end,bounds);\n            return;\n        }\n        double x=bounds.x, y=bounds.y, w=bounds.w, h=bounds.h;\n        double total=sum(items, start, end);\n        int mid=start;\n        double a=items[start].getSize()/total;\n        double b=a;\n        if (w<h){\n            while (mid<=end){\n                double aspect=normAspect(h,w,a,b);\n                double q=items[mid].getSize()/total;\n                if (normAspect(h,w,a,b+q)>aspect) break;\n                mid++;\n                b+=q;\n            }\n            layoutBest(items,start,mid,new Rect(x,y,w,h*b));\n            layout(items,mid+1,end,new Rect(x,y+h*b,w,h*(1-b)));\n        }else{\n            while (mid<=end){\n                double aspect=normAspect(w,h,a,b);\n                double q=items[mid].getSize()/total;\n                if (normAspect(w,h,a,b+q)>aspect) break;\n                mid++;\n                b+=q;\n            }\n            layoutBest(items,start,mid,new Rect(x,y,w*b,h));\n            layout(items,mid+1,end,new Rect(x+w*b,y,w*(1-b),h));\n        }\n    }\n\n    void layoutBest(Mappable[] items, int start, int end, Rect bounds){\n        sliceLayout(items,start,end,bounds,\n            bounds.w>bounds.h ? HORIZONTAL : VERTICAL, ASCENDING);\n    }\n\n    void layoutBest(Mappable[] items, int start, int end, Rect bounds, int order){\n        sliceLayout(items,start,end,bounds,\n            bounds.w>bounds.h ? HORIZONTAL : VERTICAL, order);\n    }\n\n    double aspect(double big, double small, double a, double b){\n        return (big*b)/(small*a/b);\n    }\n\n    double normAspect(double big, double small, double a, double b){\n        double x=aspect(big,small,a,b);\n        if (x<1) return 1/x;\n        return x;\n    }\n\n    double sum(Mappable[] items, int start, int end){\n        double s=0;\n        for (int i=start; i<=end; i++)\n            s+=items[i].getSize();\n        return s;\n    }\n\n    String getName(){\n        return \"Squarified\";\n    }\n\n    public String getDescription(){\n        return \"Algorithm used by J.J. van Wijk.\";\n    }\n\n    double totalSize(Mappable[] items){\n        return totalSize(items,0,items.length-1);\n    }\n\n    double totalSize(Mappable[] items, int start, int end){\n        double sum=0;\n        for (int i=start; i<=end; i++)\n            sum+=items[i].getSize();\n        return sum;\n    }\n\n    Mappable[] sortDescending(Mappable[] items){\n        Mappable[] s=new Mappable[items.length];\n        arraycopy(items,0,s,0,items.length);\n        int n=s.length;\n        boolean outOfOrder=true;\n        while (outOfOrder){\n            outOfOrder=false;\n            for (int i=0; i<n-1; i++){\n                boolean wrong=(s[i].getSize()<s[i+1].getSize());\n                if (wrong){\n                    Mappable temp=s[i];\n                    s[i]=s[i+1];\n                    s[i+1]=temp;\n                    outOfOrder=true;\n                }\n            }\n        }\n        return s;\n    }\n\n    void sliceLayout(Mappable[] items, int start, int end, Rect bounds, int orientation){\n        sliceLayout(items,start,end,bounds,orientation,ASCENDING);\n    }\n\n    void sliceLayout(Mappable[] items, int start, int end, Rect bounds, int orientation, int order){\n        double total=totalSize(items, start, end);\n        double a=0;\n        boolean vertical=orientation==VERTICAL;\n        for (int i=start; i<=end; i++){\n            Rect r=new Rect();\n            double b=items[i].getSize()/total;\n            if (vertical){\n                r.x=bounds.x;\n                r.w=bounds.w;\n                if (order==ASCENDING){\n                    r.y=bounds.y+bounds.h*a;\n                }else{\n                    r.y=bounds.y+bounds.h*(1-a-b);\n                }\n                r.h=bounds.h*b;\n            }else{\n                if (order==ASCENDING){\n                    r.x=bounds.x+bounds.w*a;\n                }else{\n                    r.x=bounds.x+bounds.w*(1-a-b);\n                }\n                r.w=bounds.w*b;\n                r.y=bounds.y;\n                r.h=bounds.h;\n            }\n            items[i].setBounds(r);\n            a+=b;\n        }\n    }\n}\n</script>\n</head>\n<body>\n    <div id=\"toptitle\">\u3000\u306f\u3066\u306a\u30d6\u30c3\u30af\u30de\u30fc\u30af TreeMap</div><br />\n    <div><center><canvas id=\"canvas\"></canvas></center></div>\n    <div id=\"layer\"></div>\n</body>\n</html>\n\n\nQiita\u521d\u6295\u7a3f\u3067\u3059\u3002\n\n\u3068\u308a\u3042\u3048\u305a\u3001\u4f55\u304b\u6295\u7a3f\u3057\u305f\u3044\u3068\u601d\u3044\u3001\u6614\u4f5c\u3063\u305f\u3001\u306f\u3066\u306a\u30d6\u30c3\u30af\u30de\u30fc\u30af\u3092TreeMap\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0\u3067\u8868\u793a\u3059\u308bWeb\u30a2\u30d7\u30ea\u3092\u30ea\u30d5\u30a1\u30a4\u30f3\u3057\u3066\u307f\u307e\u3057\u305f\u3002 \n\n\u30c7\u30fc\u30bf\u306eTreeMap\u8868\u793a\u306f\u300c\u30d3\u30b8\u30e5\u30a2\u30e9\u30a4\u30b8\u30f3\u30b0\u30c7\u30fc\u30bf\u300d\u3067\u7d39\u4ecb\u3055\u308c\u3066\u3044\u305f\u624b\u6cd5\u3067\u3001\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0\u306f[Treemaps for space-constrained visualization of hierarchies](http://www.cs.umd.edu/hcil/treemap-history/)\u3067\u8a73\u3057\u304f\u89e3\u8aac\u3055\u308c\u3066\u3044\u307e\u3059\u3002\n\nGoogle Feed API\u3067\u53d6\u5f97\u3057\u305f\u306f\u3066\u306a\u30d6\u30c3\u30af\u30de\u30fc\u30af\u306e\u30db\u30c3\u30c8\u30a8\u30f3\u30c8\u30ea\u3092\u5143\u306bTreeMap\u30c7\u30fc\u30bf\u3092\u4f5c\u6210\u3057\u3001Processing.js\u3067\u63cf\u753b\u3057\u3066\u3044\u307e\u3059\u3002\n\n\u4e00\u5fdc\u3001[JSBin](http://jsbin.com/bodupa/2/edit?html,output)\u306b\u3082\u30bd\u30fc\u30b9\u30b3\u30fc\u30c9\u3092\u767b\u9332\u3057\u307e\u3057\u305f\u3002\n\n```lang:hatena_treemap.html\n<html lang=\"jp\" class=\"ui-mobile landscape\">\n<head>\n<meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\" />\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\n<meta http-equiv=\"X-UA-Compatible\" content=\"IE=8\"/>\n<base href=\".\">\n<title>Hatemap</title>\n<style type=\"text/css\">\n#toptitle{\n\twidth:600px;\n\tmargin: 0 auto;\n\tfont-family: Georgia, Times, serif;\n\tfont-size: 24px;\n\tfont-weight: bold;\n\tcolor: #ffffff;\n\tbackground-color: #cccccc;\n\tvertical-align : bottom;\n\tline-height: 38px;\n}\n</style>\n<script src=\"http://ajax.googleapis.com/ajax/libs/jquery/2.1.3/jquery.min.js\"></script>\n<script type=\"text/javascript\" src=\"https://cdnjs.cloudflare.com/ajax/libs/processing.js/1.4.8/processing.js\"></script>\n<script type=\"text/javascript\" src=\"https://www.google.com/jsapi\"></script>\n<script type=\"text/javascript\">\nvar scwidth;\nvar scheight;\nvar proc;\nvar root;\nvar tmp=[];\nvar urls=[\n\t['http://feeds.feedburner.com/hatena/b/hotentry'],\n\t['http://b.hatena.ne.jp/hotentry/social.rss',\n\t\t'http://b.hatena.ne.jp/hotentry/economics.rss',\n\t\t'http://b.hatena.ne.jp/hotentry/life.rss',\n\t\t'http://b.hatena.ne.jp/hotentry/entertainment.rss',\n\t\t'http://b.hatena.ne.jp/hotentry/knowledge.rss',\n\t\t'http://b.hatena.ne.jp/hotentry/it.rss',\n\t\t'http://b.hatena.ne.jp/hotentry/game.rss',\n\t\t'http://b.hatena.ne.jp/hotentry/fun.rss'],\n\t['http://b.hatena.ne.jp/entrylist?sort=hot&threshold=&mode=rss&']\n];\n\ngoogle.load(\"feeds\", \"1\");\n\n$(document).ready(function(){\n\tscwidth=600;\n\tscheight=600;\n\t$(\"#canvas\").attr(\"width\",scwidth);\n\t$(\"#canvas\").attr(\"height\",scheight);\n\tinitLayer();\n\t$(\"#layer\").css(\"font-size\",\"16px\");\n\t$(\"#layer\").css(\"padding\",\"10px 0px 0px 10px\");\n\tvar canvas = document.getElementById('canvas');\n\tvar codeElm = document.getElementById('processing-code');\n\tvar code = codeElm.textContent || codeElm.innerText;\n\tproc=new Processing(canvas, code);\n\tvar list=[];\n\tfor(var i=0;i<urls[2].length;i++)list[i]=urls[2][i];\n\thatebu_Init(list);\n});\n\nvar initLayer=function(){\n\tvar off=$(\"#canvas\").offset();\n\tvar ox=off.left;\n\tvar oy=off.top+20;\t\n\t$(\"#layer\").css(\"z-index\",\"0\");\n\t$(\"#layer\").css(\"position\",\"absolute\");\n\t$(\"#layer\").css(\"top\",oy+10+\"px\");\n\t$(\"#layer\").css(\"line-height\",\"20px\");\n\t$(\"#layer\").css(\"left\",(ox+20)+\"px\");\n\t$(\"#layer\").css(\"width\",(scwidth-40)+\"px\");\n\tvar mm=Math.max(300,(scheight*0.45));\n\t$(\"#layer\").css(\"height\",mm+\"px\");\n\t$(\"#layer\").css(\"background-color\",\"#ffffff\");\n\t$(\"#layer\").css(\"opacity\",\"0.9\");\n\t$(\"#layer\").css(\"display\",\"none\");\n};\n\nvar hatebu_Init=function(list){\n\tpage=0;\n\tnumOfBookmark=0;\n\ttmp=[];\n\troot={name:\"TOP\",size:0};\n\troot.array=[];\n\tvar now=new Date();\n\tvar q=now.getMonth();\n\tvar q2=now.getDate();\n\tvar q3=now.getHours();\n\thatebu_Analyze(list,q+\"0\"+q2+\"0\"+q3);\n};\n\nvar hatebu_Analyze=function(list,dummy){\n\tstartLoading();\n\tvar url=list.shift();\n\tif(dummy)url=url+\"?\"+dummy;\n\tvar feed = new google.feeds.Feed(url);\n\tfeed.setNumEntries(100);\n\tfeed.setResultFormat(google.feeds.Feed.MIXED_FORMAT);\t\n\tfeed.load(function(result) {\n\t\tif (!result.error) {\n\t\t\tvar entries = result.feed.entries;\n\t\t\tif(entries.length>0){\n\t\t\t\tfor (var i = 0; i < entries.length; i++) {\n\t\t\t\t\tvar obj=new Object();\n\t\t\t\t\tobj.name=entries[i].title;\n\t\t\t\t\tobj.link=entries[i].link;\n\t\t\t\t\tobj.content=entries[i].content;\n\t\t\t\t\tvar category=$(entries[i].xmlNode.getElementsByTagNameNS(\"http://purl.org/dc/elements/1.1/\",\"subject\")[0]).text();\n\t\t\t\t\tif(!tmp[category]){\n\t\t\t\t\t\ttmp[category]={name:category};\n\t\t\t\t\t\ttmp[category].size=0;\n\t\t\t\t\t\ttmp[category].array=[];\n\t\t\t\t\t\troot.array.push(tmp[category]);\n\t\t\t\t\t}\n\t\t\t\t\tobj.size=parseInt($(entries[i].xmlNode.getElementsByTagNameNS(\"http://www.hatena.ne.jp/info/xmlns#\",\"bookmarkcount\")[0]).text());\n\t\t\t\t\ttmp[category].array.push(obj);\n\t\t\t\t}\n\t\t\t}\n\t\t}else{\n\t\t\talert(\"\u30a8\u30f3\u30c8\u30ea\u304c\u898b\u3064\u304b\u308a\u307e\u305b\u3093\u3067\u3057\u305f\u3002\");\n\t\t\treturn;\n\t\t}\n\t\tif(list.length>0){\n\t\t\thatebu_Analyze(list,dummy);\n\t\t}else{\n\t\t\tproc.setRoot(root);\n\t\t}\n\t});\n};\n\nvar startLoading=function(){\n\tcloseLayer();\n\tproc.loading();\n};\n\nvar showLayer=function(html,link){\n\tinitLayer();\n\tvar code=html.replace(\"blockquote\",\"div\");\n\tsetTimeout(function(){\n\t\t$(\"#layer\").css(\"display\",\"inline\");\n\t\t$(\"#layer\").html(code);\n\t\t\n\t\tvar msg=$(\"#layer div\").text();\n\t\tvar aa=$(\"#layer div p a\").text();\n\t\tmsg=msg.replace(aa,\"\");\n\t\tmsg=msg.replace(\"\u7d9a\u304d\u3092\u8aad\u3080\",\"\");\n\t\tmsg=replaceAll(msg,\"\\n\",\"\");\n\t\tmsg=replaceAll(msg,\" \",\"\");\n\t\t$(\"#layer div cite a\").attr(\"target\",\"_blank\");\n\t\tvar name=$(\"#layer div p a img:first\").attr(\"src\");\n\t\tif(name&&name.indexOf(\"http://b.hatena.ne.jp/\")==-1)\n\t\t\t$(\"#layer div p a img:first\").attr(\"height\",\"90px\");\n\t\t$(\"#layer div p a\").attr(\"target\",\"_blank\");\n\t\tif($(\"#layer div p\").length>=4){\n\t\t\t$(\"#layer div p:last\").remove();\n\t\t}\n\t},500);\n};\n\nvar closeLayer=function(){\n\t$(\"#layer\").css(\"display\",\"none\");\n\t$(\"#layer\").empty();\n};\n\nvar arraycopy=function(src,srcPos,dest,destPos,length){\n\twhile (length > 0){\n\t dest[destPos] = src[srcPos];\n\t srcPos++;\n\t destPos++;\n\t length--;\n\t}\n};\n\nvar replaceAll=function(expression, org, dest){\n\treturn expression.split(org).join(dest);\n};\n</script>\n\n<script id=\"processing-code\" type=\"application/processing\">\nBoundsIntegrator zoomBounds;\nGroupItem rootItem;\nLeafItem rolloverItem;\nGroupItem taggedItem;\nLeafItem zoomItem;\nfinal int PIVOT_BY_MIDDLE = 1;\nfinal int PIVOT_BY_SPLIT_SIZE = 2;\nfinal int PIVOT_BY_BIGGEST = 3;\nboolean isLoading=false;\nfloat ATTRACTION = 0.8f;\nfloat DAMPING = 0.4f;\nint alphaL=25;\n\nvoid setup() {\n\tsize(scwidth,scheight);\n\tPFont font=createFont(\"FFScala\", 24);\n\ttextFont(font);\n\ttextSize(16);\n\tzoomBounds = new BoundsIntegrator(0, 0, width, height);\n\trectMode(CORNERS);\n\tsmooth();\n\tnoStroke();\n\ttextMode(SCREEN);\n}\n\nvoid setRoot(array) {\n\tcloseLayer();\n\tGroupItem tm = new GroupItem(null, array, 0, 0);\n\ttm.setBounds(0, 0, width, height);\n\ttm.contentsVisible = true;\n\trootItem = tm;\n\trootItem.zoomIn();\n\trootItem.updateColors();\n\tisLoading=false;\n}\n\nvoid loading(){\n\tisLoading=true;\n}\n\nvoid drawLoading(){\n\tbackground(0);\n\tframeRate(10);\n\tnoStroke();\n\tint r=5;\n\tint rr=10;\n\tint sx=scwidth/2-rr*2;\n\tint sy=scheight/2-rr*2;\n\tfill(126,126,126,alphaL);alphaL=(alphaL+10)%256;\n\tellipse(sx+3*rr, sy+0*rr, 2*r, 2*r);\n\tfill(126,126,126,alphaL);alphaL=(alphaL+25)%256;\n\tellipse(sx+5*rr, sy+1*rr, 2*r, 2*r);\n\tfill(126,126,126,alphaL);alphaL=(alphaL+25)%256;\n\tellipse(sx+6*rr, sy+3*rr, 2*r, 2*r);\n\tfill(126,126,126,alphaL);alphaL=(alphaL+25)%256;\n\tellipse(sx+5*rr, sy+5*rr, 2*r, 2*r);\n\tfill(126,126,126,alphaL);alphaL=(alphaL+25)%256;\n\tellipse(sx+3*rr, sy+6*rr, 2*r, 2*r);\n\tfill(126,126,126,alphaL);alphaL=(alphaL+25)%256;\n\tellipse(sx+1*rr, sy+5*rr, 2*r, 2*r);\n\tfill(126,126,126,alphaL);alphaL=(alphaL+25)%256;\n\tellipse(sx+0*rr, sy+3*rr, 2*r, 2*r);\n\tfill(126,126,126,alphaL);alphaL=(alphaL+25)%256;\n\tellipse(sx+1*rr, sy+1*rr, 2*r, 2*r);\n}\n\nvoid draw() {\n\tif(isLoading){\n\t\tdrawLoading();\n\t\treturn;\n\t}\n\tbackground(0);\n\tframeRate(30);\n\tzoomBounds.update();\n\trolloverItem = null;\n\ttaggedItem = null;\n\tif (rootItem != null) rootItem.draw();\n\tif (rolloverItem != null) rolloverItem.drawTitleBar();\n\tif (taggedItem != null) taggedItem.drawTag();\n}\n\nvoid mousePressed() {\n\tif (zoomItem != null) {\n\t\tzoomItem.mousePressed();\n\t}\n}\n\nvoid zoomOut(){\n\tif (zoomItem != null) {\n\t\tmouseButton=RIGHT;\n\t\tzoomItem.mousePressed();\n\t}\n}\n\nclass BoundsIntegrator {\n\tfloat valueX, velocityX, accelerationX;\n\tfloat valueY, velocityY, accelerationY;\n\tfloat valueW, velocityW, accelerationW;\n\tfloat valueH, velocityH, accelerationH;\n\tfloat damping;\n\tfloat attraction;\n\tboolean targeting;\n\tfloat targetX, targetY, targetW, targetH;\n\n\tBoundsIntegrator(float x, float y, float w, float h) {\n\t\tthis.valueX = x;\n\t\tthis.valueY = y;\n\t\tthis.valueW = w;\n\t\tthis.valueH = h;\n\t\tthis.damping = DAMPING;\n\t\tthis.attraction = ATTRACTION;\n\t}\n\n\tvoid set(float x, float y, float w, float h) {\n\t\tthis.valueX = x;\n\t\tthis.valueY = y;\n\t\tthis.valueW = w;\n\t\tthis.valueH = h;\n\t}\n   \n\tfloat getX() {\n\t\treturn valueX;\n\t}\n\n\tfloat getY() {\n\t\treturn valueY;\n\t}\n  \n\tfloat getW() {\n\t\treturn valueW;\n\t}\n\n\tfloat getH() {\n\t\treturn valueH;\n\t}\n\n\tfloat spanX(float pointX, float start, float span) {\n\t\tif (valueW != 0) {\n\t\t\tfloat n = (pointX - valueX) / valueW;\n\t\t\treturn start + n*span;\n\t\t} else {\n\t\t\treturn Float.NaN;\n\t\t}\n\t}\n\t\n\tfloat spanY(float pointY, float start, float span) {\n\t\tif (valueH != 0) {\n\t\t\tfloat n = (pointY - valueY) / valueH;\n\t\t\treturn start + n*span;\n\t\t} else {\n\t\t\treturn Float.NaN;\n\t\t}\n\t}\n\t\n\tvoid setAttraction(float a) {\n\t\tattraction = a;\n\t}\n\n\tvoid setDamping(float d) {\n\t\tdamping = d;\n\t}\n\t\n\tboolean update() {\n\t\tif (targeting) {\n\t\t\taccelerationX += attraction * (targetX - valueX);\n\t\t\tvelocityX = (velocityX + accelerationX) * damping;\n\t\t\tvalueX += velocityX;\n\t\t\taccelerationX = 0;\n\t\t\tboolean updated = (Math.abs(velocityX) > 0.0001f);\n\t\t\taccelerationY += attraction * (targetY - valueY);\n\t\t\tvelocityY = (velocityY + accelerationY) * damping;\n\t\t\tvalueY += velocityY;\n\t\t\taccelerationY = 0;\n\t\t\tupdated |= (Math.abs(velocityY) > 0.0001f);\n\t\t\taccelerationW += attraction * (targetW - valueW);\n\t\t\tvelocityW = (velocityW + accelerationW) * damping;\n\t\t\tvalueW += velocityW;\n\t\t\taccelerationW = 0;\n\t\t\tupdated |= (Math.abs(velocityW) > 0.0001f);\n\t\t\taccelerationH += attraction * (targetH - valueH);\n\t\t\tvelocityH = (velocityH + accelerationH) * damping;\n\t\t\tvalueH += velocityH;\n\t\t\taccelerationH = 0;\n\t\t\tupdated |= (Math.abs(velocityH) > 0.0001f);\n\t\t}\n\t\treturn false;\n\t}\n\n\tvoid target(float tx, float ty, float tw, float th) {\n\t\ttargeting = true;\n\t\ttargetX = tx;\n\t\ttargetY = ty; \n\t\ttargetW = tw;\n\t\ttargetH = th;\n\t}\n\n\tvoid targetLocation(float tx, float ty) {\n\t\ttargeting = true;\n\t\ttargetX = tx;\n\t\ttargetY = ty;\n\t}\n\n\tvoid targetSize(float tw, float th) {\n\t\ttargeting = true;\n\t\ttargetW = tw;\n\t\ttargetH = th;\n\t}\n\n\tvoid targetX(float tx) {\n\t\ttargeting = true;\n\t\ttargetX = tx;\n\t}\n\n\tvoid targetY(float ty) {\n\t\ttargeting = true;\n\t\ttargetY = ty;\n\t}\n\t\n\tvoid targetW(float tw) {\n\t\ttargeting = true;\n\t\ttargetW = tw;\n\t}\n\t\n\tvoid targetH(float th) {\n\t\ttargeting = true;\n\t\ttargetH = th;\n\t}\n}\n\nclass LeafItem extends SimpleMapItem {\n\tGroupItem parent;    \n\tObject obj;\n\tString name;\n\tint level;\n\tcolor c;\n\tfloat hue;\n\tfloat brightness;\n\tfloat textPadding = 8;\n\tfloat boxLeft, boxTop;\n\tfloat boxRight, boxBottom;\n\n\tLeafItem(GroupItem parent, Object obj, int level, int order) {\n\t\tthis.parent = parent;\n\t\tthis.obj = obj;\n\t\tthis.order = order;\n\t\tthis.level = level;\n\t\tname=obj.name;\n\t\tif(name.length>30)name=name.substring(0,30)+\"...\";\n\t\tsize = obj.size;\n\t}\n\tvoid updateColors() {\n\t\tif (parent != null) {\n\t\t\thue = map(order, 0, parent.getItemCount(), 0, 360);\n\t\t}\n\t\tbrightness = Math.min(100.0/((float)level*0.8),100.0);\t\t\n\t\tcolorMode(HSB, 360, 100, 100);\n\t\tif (parent == zoomItem) {\n\t\t\tc = color(hue, 60, 60);\n\t\t} else if (parent != null) {\n\t\t\tcolor pc = color(parent.hue, 60, 60);\n\t\t\tc = color(hue, brightness, brightness);\n\t\t\tcolorMode(RGB, 255);\n\t\t\tc=blendColor(c,pc,SCREEN)\n\t\t}\n\t\tcolorMode(RGB, 255);\n\t}\n\t\n\tvoid calcBox() {\n\t\tboxLeft = zoomBounds.spanX(x, 0, width);\n\t\tboxRight = zoomBounds.spanX(x+w, 0, width);\n\t\tboxTop = zoomBounds.spanY(y, 0, height);\n\t\tboxBottom = zoomBounds.spanY(y+h, 0, height);\n\t}\n\n\tvoid draw() {\n\t\tcalcBox();\n\t\tif(mouseInside()){\n\t\t\tfill(c,255);\n\t\t}else{\n\t\t\tfill(c,200);\n\t\t}\n//\t\tfill(c);\n\t\trect(boxLeft, boxTop, boxRight, boxBottom);\n\t\tstroke(128);\n\t\trect(boxLeft, boxTop, boxRight, boxBottom);\n\t\tif (textFits()) {\n\t\t\tdrawTitle();\n\t\t\tdrawTitle3();\n\t\t}else if(textFits2()){\n\t\t\tdrawTitle2(14);\n\t\t\tdrawTitle3();\n\t\t} else if (mouseInside()) {\n\t\t\trolloverItem = this;\n\t\t}else{\n\t\t\ttextSize(12);\n\t\t\tif(textFits2()){\n\t\t\t\tdrawTitle2(12);\t\t\n\t\t\t}else{\n\t\t\t\ttextSize(10);\n\t\t\t\tif(textFits2())drawTitle2(10)\n\t\t\t}\n\t\t\tdrawTitle3();\n\t\t}\n\t}\n\t\n\tvoid drawTitleBar(){\n\t\tif (textFits()) {\n\t\t\tdrawTitle();\n\t\t\tdrawTitle3();\n\t\t}else if (textFits3()) {\n\t\t\tdrawTitle();\n\t\t\tdrawTitle3();\t\n\t\t}else if(textFits2()){\n\t\t\tdrawTitle2(14);\n\t\t\tdrawTitle3();\n\t\t}else{\n\t\t\ttextSize(12);\n\t\t\tif(textFits2()){\n\t\t\t\tdrawTitle2(12);\t\t\n\t\t\t}else{\n\t\t\t\ttextSize(10);\n\t\t\t\tdrawTitle2(10)\n\t\t\t}\n\t\t\tdrawTitle3();\n\t\t}\n\t\ttextSize(16);\n\t}\n\n\tvoid drawTitle() {\n\t\tfill(255, 200);\n\t\ttextAlign(LEFT);\n\t\ttext(name, boxLeft + textPadding, boxBottom - textPadding);\n\t}\n\n\tvoid drawTitle2(int n) {\n\t\tfill(255, 200);\n\t\ttextSize(n);\n\t\tfloat ascent = textAscent();\n\t\ttext(name,boxLeft + textPadding, boxBottom -ascent - textPadding*2,boxRight-boxLeft,ascent + textPadding*2);\n\t\ttextSize(16);\n\t}\n\tvoid drawTitle3() {\n\t\tif(zoomItem!=this){\n\t\t\tfill(255, 200);\n\t\t\tfloat middleX = (boxLeft + boxRight) / 2;\n\t\t\tfloat middleY = (boxTop + boxBottom) / 2;\n\t\t\tString tp=this.size;\n\t\t\tint ww=(boxRight-boxLeft)/2;\n\t\t\tww=(int)Math.min(ww,(boxBottom-boxTop)/2);\n\t\t\tif(ww>=192){\n\t\t\t\ttextSize(128);\n\t\t\t}else if(ww>=96){\n\t\t\t\ttextSize(64);\n\t\t\t}else if(ww>=48){\n\t\t\t\ttextSize(32);\n\t\t\t}else if(ww>=24){\n\t\t\t\ttextSize(16);\n\t\t\t}else if(ww>=18){\n\t\t\t\ttextSize(12);\t\n\t\t\t}else if(ww>=12){\n\t\t\t\ttextSize(8);\t\t\t\n\t\t\t}else{\n\t\t\t\treturn ;\n\t\t\t}\n\t\t\tfloat ascent = textAscent();\n\t\t\ttext(tp, boxLeft+5,boxTop+ascent+5);\n\t\t\ttextSize(16);\n\t\t}\n\t}\n\t\n\tboolean textFits() {\n\t\tint s=64;\n\t\twhile(s>16){\n\t\t\ttextSize(s);\n\t\t\tif(checkTextFits(name)){\n\t\t\t\treturn true;\n\t\t\t}else{\n\t\t\t\ts *=0.75;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\tboolean checkTextFits(String n){\n\t\tfloat wide = textWidth(n) + textPadding*2;\n\t\tfloat high = textAscent() + textDescent() + textPadding*2;\n\t\treturn (boxRight - boxLeft > wide) && (boxBottom - boxTop > high);\n\t}\n\t\n\tboolean textFits2() {\n\t\tint l=name.length()/2;\n\t\tif(l%2!=0)l++;\n\t\tString n2=name.substring(0,l);\n\t\tfloat wide = textWidth(n2) + textPadding*4;\n\t\tfloat high = textAscent()*3 + textDescent()*3 + textPadding*6;\n\t\treturn (boxRight - boxLeft > wide) && (boxBottom - boxTop > high); \n\t}\n\t\n\tboolean textFits3() {\n\t\tfloat wide = textWidth(name) + textPadding*2;\n\t\treturn (boxRight - boxLeft > wide); \n\t}\n\t\n\tboolean mouseInside() {\n\t\treturn (mouseX > boxLeft && mouseX < boxRight && \n\t\t\tmouseY > boxTop && mouseY < boxBottom);    \n\t}\n\t\n\tboolean mousePressed() {\n\t\tif (mouseInside()) {\n\t\t\tif (mouseButton == LEFT) {\n\t\t\t\tif(parent.contentsVisible){\n\t\t\t\t\tif(parent.isZoom){\n\t\t\t\t\t\tif(zoomItem!=this){\n\t\t\t\t\t\t\tzoomItem = this;\n\t\t\t\t\t\t\tzoomBounds.target(x, y, w, h);\n\t\t\t\t\t\t\tshowLayer(obj.content,obj.link);\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tshowLayer(obj.content,obj.link);\n\t\t\t\t\t\t}\n\t\t\t\t\t}else{\n\t\t\t\t\t\tparent.zoomIn();\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tparent.zoomIn();\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t} else if (mouseButton == RIGHT) {\n\t\t\t\tif(zoomItem == this){\n\t\t\t\t\tzoomItem = parent;\n\t\t\t\t\tparent.zoomIn();\n\t\t\t\t}else if (parent == zoomItem) {\n\t\t\t\t\tparent.zoomOut();\n\t\t\t\t} else {\n\t\t\t\t\tparent.hideContents();\n\t\t\t\t}\n\t\t\t\tcloseLayer();\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n}\n\nclass GroupItem extends LeafItem implements MapModel {\n\tMapLayout algorithm = new SquarifiedLayout();\n\tMappable[] items;\n\tboolean contentsVisible;\n\tboolean layoutValid;\n\tfloat darkness;\n\tboolean isZoom=false;\n\tGroupItem(GroupItem parent, Object folder, int level, int order) {\n\t\tsuper(parent, folder, level, order);\n\t\tArrayList contents = folder.array;\n\t\tif (contents) {\n\t\t\tcontents = sort(contents);\n\t\t\titems = new Mappable[contents.length];\n\t\t\tint count = 0;\n\t\t\tfor (int i = 0; i < contents.length; i++) {\n\t\t\t\tif (contents[i].array) {\n\t\t\t\t\tGroupItem newItem = new GroupItem(this, contents[i], level+1, count);\n\t\t\t\t\titems[count++] = newItem;\n\t\t\t\t\tsize += newItem.getSize();\n\t\t\t\t} else {\n\t\t\t\t\tLeafItem newItem = new LeafItem(this, contents[i], level+1, count);\n\t\t\t\t\titems[count++] = newItem;\n\t\t\t\t\tsize += newItem.getSize();\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (count != items.length) {\n\t\t\t\titems = (Mappable[]) subset(items, 0, count);\n\t\t\t}\n\t\t} else {\n\t\t\titems = new Mappable[0];\n\t\t}\n\t}\n\n\tvoid updateColors() {\n\t\tsuper.updateColors();\n\t\tfor (int i = 0; i < items.length; i++) {\n\t\t\tLeafItem fi = (LeafItem) items[i];\n\t\t\tfi.updateColors();\n\t\t}\n\t}\n\n\tvoid checkLayout() {\n\t\tif (!layoutValid) {\n\t\t\tif (getItemCount() != 0) {\n\t\t\t\talgorithm.layout(this, bounds);\n\t\t\t}\n\t\t\tlayoutValid = true;\n\t\t}\n\t}\n\n\tboolean mousePressed() {\n\t\tif (mouseInside()) {\n\t\t\tif (contentsVisible) {\n\t\t\t\tfor (int i = 0; i < items.length; i++) {\n\t\t\t\t\tLeafItem fi = (LeafItem) items[i];\n\t\t\t\t\tif (fi.mousePressed()) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (mouseButton == LEFT) {\n\t\t\t\t\tif (parent == zoomItem) {\n\t\t\t\t\t\tshowContents();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tparent.zoomIn();\n\t\t\t\t\t}            \n\t\t\t\t} else if (mouseButton == RIGHT) {\n\t\t\t\t\tif (parent == zoomItem) {\n\t\t\t\t\t\tparent.zoomOut();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tparent.hideContents();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\tvoid zoomOut() {\n\t\tif (parent != null) {\n\t\t\tfor (int i = 0; i < items.length; i++) {\n\t\t\t\tif (items[i] instanceof GroupItem) {\n\t\t\t\t\t((GroupItem)items[i]).hideContents();\n\t\t\t\t}\n\t\t\t}\n\t\t\tparent.zoomIn();\n\t\t}\n\t\tisZoom=false;\n\t}\n\n\tvoid zoomIn() {\n\t\tzoomItem = this;\n\t\tzoomBounds.target(x, y, w, h);\n\t\tisZoom=true;\n\t}\n\n\tvoid showContents() {\n\t\tcontentsVisible = true;\n\t}\n\n\tvoid hideContents() {\n\t\tif (parent != null)contentsVisible = false;\n\t}\n\n\tvoid draw() {\n\t\tcheckLayout();\n\t\tcalcBox();\n\t\tif (contentsVisible) {\n\t\t\tfor (int i = 0; i < items.length; i++) {\n\t\t\t\titems[i].draw();\n\t\t\t}\n\t\t} else {\n\t\t\tsuper.draw();\n\t\t}\n\t\tif (contentsVisible) {\n\t\t\tif (mouseInside()) {\n\t\t\t\tif (parent == zoomItem) {\n\t\t\t\t\ttaggedItem = this;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (mouseInside()) {\n\t\t\tdarkness *= 0.05;\n\t\t} else {\n\t\t\tdarkness += (150 - darkness) * 0.05;\n\t\t}\n\t\tdarkness=Math.min(darkness,80);\n\t\tif (parent == zoomItem) {\n\t\t\tcolorMode(RGB, 255);\n\t\t\tfill(0, darkness);\n\t\t\trect(boxLeft, boxTop, boxRight, boxBottom);\n\t\t}\n\t}\n\n\tvoid drawTitle() {\n\t\tif (!contentsVisible) super.drawTitle();\n\t}\n\n\tvoid drawTag() {\n\t\tfloat boxHeight = textAscent() + textPadding*2;\n\t\tif (boxBottom - boxTop > boxHeight*2) {\n\t\t\tfill(0, 128);\n\t\t\trect(boxLeft, boxTop, boxRight, boxTop+boxHeight);\n\t\t\tfill(255);\n\t\t\ttextAlign(LEFT, TOP);\n\t\t\ttext(name, boxLeft+textPadding, boxTop+textPadding);\n\t\t} else if (boxTop > boxHeight) {\n\t\t\tfill(0, 128);\n\t\t\trect(boxLeft, boxTop-boxHeight, boxRight, boxTop);\n\t\t\tfill(255);\n\t\t\ttext(name, boxLeft+textPadding, boxTop-textPadding);\n\t\t} else if (boxBottom + boxHeight < height) {\n\t\t\tfill(0, 128);\n\t\t\trect(boxLeft, boxBottom, boxRight, boxBottom+boxHeight);\n\t\t\tfill(255);\n\t\t\ttextAlign(LEFT, TOP);\n\t\t\ttext(name, boxLeft+textPadding, boxBottom+textPadding);\n\t\t}\n\t}\n\n\tMappable[] getItems() {\n\t\treturn items;\n\t}\n\n\tint getItemCount() {\n\t\treturn items.length;\n\t}\n}\n\nclass Rect{\n\tdouble x,y,w,h;\n\n\tRect(){\n\t\tthis(0,0,1,1);\n\t}\n\n\tRect(Rect r){\n\t\tsetRect(r.x, r.y, r.w, r.h);\n\t}\n\n\tRect(double x, double y, double w, double h){\n\t\tsetRect(x, y, w, h);\n\t}\n\n\tvoid setRect(double x, double y, double w, double h) {\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t\tthis.w = w;\n\t\tthis.h = h;\n    }\n\n\tdouble aspectRatio(){\n\t\treturn Math.max(w/h, h/w);\n\t}\n\n\tdouble distance(Rect r){\n\t\treturn Math.sqrt((r.x-x)*(r.x-x)+\n\t\t\t\t\t(r.y-y)*(r.y-y)+\n\t\t\t\t\t(r.w-w)*(r.w-w)+\n\t\t\t\t\t(r.h-h)*(r.h-h));\n\t}\n\n\tRect copy(){\n\t\treturn new Rect(x,y,w,h);\n\t}\n\n\tString toString(){\n\t\treturn \"Rect: \"+x+\", \"+y+\", \"+w+\", \"+h;\n\t}\n}\ninterface MapModel{\n\tMappable[] getItems();\n}\n\ninterface MapLayout{\n\tvoid layout(MapModel model, Rect bounds);\n\tvoid layout(MapModel model, double x, double y, double w, double h);\n}\n\ninterface Mappable {\n\tdouble getSize();\n\tvoid setSize(double size);\n\tRect getBounds();\n\tvoid setBounds(Rect bounds);\n\tvoid setBounds(double x, double y, double w, double h);\n\tint getOrder();\n\tvoid setOrder(int order);\n\tint getDepth();\n\tvoid setDepth(int depth);\n\tvoid draw();\n}\n\nclass SimpleMapItem implements Mappable {\n\tdouble size;\n\tRect bounds;\n\tint order = 0;\n\tint depth;\n\tfloat x, y, w, h;\n  \n\tSimpleMapItem() {\n\t\tthis(1, 0);\n\t}\n\n\tSimpleMapItem(double size, int order) {\n\t\tthis.size = size;\n\t\tthis.order = order;\n\t\tbounds = new Rect();\n\t}\n\n\tdouble getSize() {\n\t\treturn size;\n\t}\n\n\tvoid setSize(double size) {\n\t\tthis.size = size;\n\t}\n\n\tvoid incrementSize() {\n\t\tsize++;\n\t}\n\n\tRect getBounds() {\n\t\treturn bounds;\n\t}\n\n\tvoid setBounds(Rect bounds) {\n\t\tthis.bounds = bounds;\n\t\tx = (float) bounds.x;\n\t\ty = (float) bounds.y;\n\t\tw = (float) bounds.w;\n\t\th = (float) bounds.h;\n\t}\n\n\tvoid setBounds(double bx, double by, double bw, double bh) {\n\t\tsetBounds(new Rect(bx, by, bw, bh));\n\t}\n\n\tint getOrder() {\n\t\treturn order;\n\t}\n\n\tvoid setOrder(int order) {\n\t\tthis.order = order;\n\t}\n\n\tvoid setDepth(int depth) {\n\t\tthis.depth = depth;\n\t}\n\n\tint getDepth() {\n\t\treturn depth;\n\t}\n  \n\tvoid draw() {}\n}\n\nclass SquarifiedLayout implements MapLayout{\n\tint VERTICAL=0, HORIZONTAL=1;\n\tint ASCENDING=0, DESCENDING=1;\n\n\tvoid layout(MapModel model, Rect bounds){\n\t\tlayout(model.getItems(),bounds);\n\t}\n\tvoid layout(MapModel model, double x, double y, double w, double h){\n\t\tlayout(model, new Rect(x, y, w, h));\n\t}\n\t\n\tvoid layout(Mappable[] items, Rect bounds){\n\t\tif(!items.length)items=items.getItems();\n\t\tlayout(sortDescending(items),0,items.length-1,bounds);\n\t}\n\t\n\tvoid layout(Mappable[] items, int start, int end, Rect bounds){\n\t\tif (start>end) return;\n\t\tif (end-start<2){\n\t\t\tlayoutBest(items,start,end,bounds);\n\t\t\treturn;\n\t\t}\n\t\tdouble x=bounds.x, y=bounds.y, w=bounds.w, h=bounds.h;\n\t\tdouble total=sum(items, start, end);\n\t\tint mid=start;\n\t\tdouble a=items[start].getSize()/total;\n\t\tdouble b=a;\n\t\tif (w<h){\n\t\t\twhile (mid<=end){\n\t\t\t\tdouble aspect=normAspect(h,w,a,b);\n\t\t\t\tdouble q=items[mid].getSize()/total;\n\t\t\t\tif (normAspect(h,w,a,b+q)>aspect) break;\n\t\t\t\tmid++;\n\t\t\t\tb+=q;\n\t\t\t}\n\t\t\tlayoutBest(items,start,mid,new Rect(x,y,w,h*b));\n\t\t\tlayout(items,mid+1,end,new Rect(x,y+h*b,w,h*(1-b)));\n\t\t}else{\n\t\t\twhile (mid<=end){\n\t\t\t\tdouble aspect=normAspect(w,h,a,b);\n\t\t\t\tdouble q=items[mid].getSize()/total;\n\t\t\t\tif (normAspect(w,h,a,b+q)>aspect) break;\n\t\t\t\tmid++;\n\t\t\t\tb+=q;\n\t\t\t}\n\t\t\tlayoutBest(items,start,mid,new Rect(x,y,w*b,h));\n\t\t\tlayout(items,mid+1,end,new Rect(x+w*b,y,w*(1-b),h));\n\t\t}\n\t}\n\n\tvoid layoutBest(Mappable[] items, int start, int end, Rect bounds){\n\t\tsliceLayout(items,start,end,bounds,\n\t\t\tbounds.w>bounds.h ? HORIZONTAL : VERTICAL, ASCENDING);\n\t}\n\n\tvoid layoutBest(Mappable[] items, int start, int end, Rect bounds, int order){\n\t\tsliceLayout(items,start,end,bounds,\n\t\t\tbounds.w>bounds.h ? HORIZONTAL : VERTICAL, order);\n\t}\n\t\n\tdouble aspect(double big, double small, double a, double b){\n\t\treturn (big*b)/(small*a/b);\n\t}\n    \n\tdouble normAspect(double big, double small, double a, double b){\n\t\tdouble x=aspect(big,small,a,b);\n\t\tif (x<1) return 1/x;\n\t\treturn x;\n\t}\n    \n\tdouble sum(Mappable[] items, int start, int end){\n\t\tdouble s=0;\n\t\tfor (int i=start; i<=end; i++)\n\t\t\ts+=items[i].getSize();\n\t\treturn s;\n\t}\n    \n\tString getName(){\n\t\treturn \"Squarified\";\n\t}\n    \n\tpublic String getDescription(){\n\t\treturn \"Algorithm used by J.J. van Wijk.\";\n\t}\n\t\n\tdouble totalSize(Mappable[] items){\n\t\treturn totalSize(items,0,items.length-1);\n\t}\n\n\tdouble totalSize(Mappable[] items, int start, int end){\n\t\tdouble sum=0;\n\t\tfor (int i=start; i<=end; i++)\n\t\t\tsum+=items[i].getSize();\n\t\treturn sum;\n\t}\n    \n\tMappable[] sortDescending(Mappable[] items){\n\t\tMappable[] s=new Mappable[items.length];\n\t\tarraycopy(items,0,s,0,items.length);\n\t\tint n=s.length;\n\t\tboolean outOfOrder=true;\n\t\twhile (outOfOrder){\n\t\t\toutOfOrder=false;\n\t\t\tfor (int i=0; i<n-1; i++){\n\t\t\t\tboolean wrong=(s[i].getSize()<s[i+1].getSize());\n\t\t\t\tif (wrong){\n\t\t\t\t\tMappable temp=s[i];\n\t\t\t\t\ts[i]=s[i+1];\n\t\t\t\t\ts[i+1]=temp;\n\t\t\t\t\toutOfOrder=true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn s;\n\t}\n\n\tvoid sliceLayout(Mappable[] items, int start, int end, Rect bounds, int orientation){\n\t\tsliceLayout(items,start,end,bounds,orientation,ASCENDING);\n\t}\n    \n\tvoid sliceLayout(Mappable[] items, int start, int end, Rect bounds, int orientation, int order){\n\t\tdouble total=totalSize(items, start, end);\n\t\tdouble a=0;\n\t\tboolean vertical=orientation==VERTICAL;\n\t\tfor (int i=start; i<=end; i++){\n\t\t\tRect r=new Rect();\n\t\t\tdouble b=items[i].getSize()/total;\n\t\t\tif (vertical){\n\t\t\t\tr.x=bounds.x;\n\t\t\t\tr.w=bounds.w;\n\t\t\t\tif (order==ASCENDING){\n\t\t\t\t\tr.y=bounds.y+bounds.h*a;\n\t\t\t\t}else{\n\t\t\t\t\tr.y=bounds.y+bounds.h*(1-a-b);\n\t\t\t\t}\n\t\t\t\tr.h=bounds.h*b;\n\t\t\t}else{\n\t\t\t\tif (order==ASCENDING){\n\t\t\t\t\tr.x=bounds.x+bounds.w*a;\n\t\t\t\t}else{\n\t\t\t\t\tr.x=bounds.x+bounds.w*(1-a-b);\n\t\t\t\t}\n\t\t\t\tr.w=bounds.w*b;\n\t\t\t\tr.y=bounds.y;\n\t\t\t\tr.h=bounds.h;\n\t\t\t}\n\t\t\titems[i].setBounds(r);\n\t\t\ta+=b;\n\t\t}\n\t}\n}\n</script>\n</head>\n<body>\n\t<div id=\"toptitle\">\u3000\u306f\u3066\u306a\u30d6\u30c3\u30af\u30de\u30fc\u30af TreeMap</div><br />\n\t<div><center><canvas id=\"canvas\"></canvas></center></div>\n\t<div id=\"layer\"></div>\n</body>\n</html>\n```\n", "tags": ["HTML5", "processing"]}