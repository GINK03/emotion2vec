{"tags": ["Linux", "kernel", "Wi-Fi", "802.11"], "context": "cfg80211_ops \u306e\u3088\u304f\u4f7f\u3044\u305d\u3046\u306a\u95a2\u6570\u306b\u3064\u3044\u3066\u8abf\u3079\u3066\u307f\u307e\u3057\u305f\u3002\ncfg80211\u306fLinux Kernel\u306eWi-Fi\u8a2d\u5b9a\uff08AP\u3068\u306e\u63a5\u7d9a\u3001\u30b9\u30ad\u30e3\u30f3\u306a\u3069\uff09\u3092\u3059\u308b\u30ab\u30fc\u30cd\u30eb\u306e\u6a5f\u80fd\u3067\u3059\u3002\n\u30c9\u30e9\u30a4\u30d0\u307e\u305f\u306fmac80211\u306b\u5bfe\u3057\u3066\u306fcfg80211_ops\u3068\u3044\u3046\u95a2\u6570\u30dd\u30a4\u30f3\u30bf\u306e\u69cb\u9020\u4f53\u3092\u4f7f\u3063\u3066\u3084\u308a\u3068\u308a\u3057\u307e\u3059\u3002\n(FullMAC\u306e\u5834\u5408\u306fcfg80211\u306e\u76f4\u4e0b\u306b\u30c9\u30e9\u30a4\u30d0\u304c\u3042\u308b\u3002SoftMAC\u306e\u5834\u5408\u306fcfg80211\u306e\u4e0b\u306bmac80211\u304c\u3042\u308a\u3001\u305d\u306e\u4e0b\u306b\u30c9\u30e9\u30a4\u30d0\u304c\u3042\u308b\u3002)\n\u30a2\u30d7\u30ea\u304b\u3089\u306fioctl\u3092\u4f7f\u3063\u3066nl80211\u7d4c\u7531\u3067\u30a2\u30af\u30bb\u30b9\u3057\u307e\u3059\u3002\nLinux\u306eWi-Fi\u30c9\u30e9\u30a4\u30d0\u3092\u4e0a\u304b\u3089\u8aad\u3080\u5834\u5408\u306f\u3001\u5236\u5fa1\u7cfb\u306e\u64cd\u4f5c\u306fcfg80211_ops\u304b\u3089\u8aad\u3093\u3067\u3044\u304d\u307e\u3059\u3002\n\u30c7\u30fc\u30bf\u9001\u53d7\u4fe1\u306e\u5834\u5408\u306fnetdev\u95a2\u9023\u304b\u3089\u8aad\u307f\u307e\u3059\u3002\ncfg80211_ops\u306f\u95a2\u6570\u304c\u591a\u3059\u304e\u306a\u306e\u3067\u3001\u307e\u305a\u8aad\u3080\u3079\u304d\u95a2\u6570\u3092\u30d4\u30c3\u30af\u30a2\u30c3\u30d7\u3057\u3066\u307f\u307e\u3057\u305f\u3002\n\u4eca\u56de\u306fSTA\u306e\u307f\u3068\u3057\u307e\u3057\u305f\u3002\n\n\n\u30bd\u30fc\u30b9\u30b3\u30fc\u30c9\n\nhttps://github.com/torvalds/linux/blob/master/include/net/cfg80211.h\n\u30c9\u30e9\u30a4\u30d0\u306e cfg80211_ops \u3092\u5b9f\u88c5\u3057\u3066\u3044\u308b\u90e8\u5206\nmac80211\u306ecfg80211_ops\u3092\u5b9f\u88c5\u3057\u3066\u3044\u308b\u90e8\u5206\n\n\ncfg80211_ops \u306eSTA\u3067\u3088\u304f\u4f7f\u3046\u95a2\u6570\n\nconnect\n\n\u5f15\u6570sme\u3067\u6307\u5b9a\u3057\u305fAP\u306b\u63a5\u7d9a\u3059\u308b\n\u7d50\u679c\u306f cfg80211_connect_result()\u3067\u30b3\u30fc\u30eb\u30d0\u30c3\u30af\u3059\u308b\u3002\n\u5f15\u6570\n\n\nwiphy Wireless device\u306e\u30a4\u30f3\u30b9\u30bf\u30f3\u30b9\ndev \u30cd\u30c3\u30c8\u30ef\u30fc\u30af\u30a4\u30f3\u30bf\u30fc\u30d5\u30a7\u30a4\u30b9\u306b\u5bfe\u5fdc\u3059\u308bnetdev\nsme SSID BSSID\u306a\u3069AP\u3092\u8b58\u5225\u3067\u304d\u308b\u60c5\u5831\u3068scan\u7d50\u679c\u306e\u60c5\u5831\u306a\u3069\n\n\n\n * @connect: Connect to the ESS with the specified parameters. When connected,\n *  call cfg80211_connect_result() with status code %WLAN_STATUS_SUCCESS.\n *  If the connection fails for some reason, call cfg80211_connect_result()\n *  with the status from the AP. The driver is allowed to roam to other\n *  BSSes within the ESS when the other BSS matches the connect parameters.\n *  When such roaming is initiated by the driver, the driver is expected to\n *  verify that the target matches the configured security parameters and\n *  to use Reassociation Request frame instead of Association Request frame.\n *  The connect function can also be used to request the driver to perform\n *  a specific roam when connected to an ESS. In that case, the prev_bssid\n *  parameter is set to the BSSID of the currently associated BSS as an\n *  indication of requesting reassociation. In both the driver-initiated and\n *  new connect() call initiated roaming cases, the result of roaming is\n *  indicated with a call to cfg80211_roamed() or cfg80211_roamed_bss().\n *  (invoked with the wireless_dev mutex held)\n\n    int (*connect)(struct wiphy *wiphy, struct net_device *dev,\n               struct cfg80211_connect_params *sme);\n\n\ndisconnect\n\nAP \u3068\u306e\u63a5\u7d9a\u3092\u5207\u65ad\u3059\u308b\u3002\n\u5f15\u6570\n\n\nwiphy Wireless device\u306e\u30a4\u30f3\u30b9\u30bf\u30f3\u30b9\ndev \u30cd\u30c3\u30c8\u30ef\u30fc\u30af\u30a4\u30f3\u30bf\u30fc\u30d5\u30a7\u30a4\u30b9\u306b\u5bfe\u5fdc\u3059\u308bnetdev\nreason_code \u5207\u65ad\u8981\u6c42\u306b\u542b\u3081\u308b\u5207\u65ad\u7406\u7531\n\n\n\n * @disconnect: Disconnect from the BSS/ESS.\n *  (invoked with the wireless_dev mutex held)\n\n    int (*disconnect)(struct wiphy *wiphy, struct net_device *dev,\n                  u16 reason_code);\n\n\nscan\n\nAP\u306a\u3069\u3092\u63a2\u3059\u305f\u3081\u306b\u30b9\u30ad\u30e3\u30f3\u3059\u308b\u3002\n\u30b9\u30ad\u30e3\u30f3\u7d50\u679c\u306f\u3001cfg80211_scan_done()\u3067\u30b3\u30fc\u30eb\u30d0\u30c3\u30af\u3059\u308b\u3002\n\u5f15\u6570\n\n\nwiphy Wireless device\u306e\u30a4\u30f3\u30b9\u30bf\u30f3\u30b9\nrequest Scan\u306e\u8a2d\u5b9a channel,band,ssid\u306a\u3069\n\n\n\n * @scan: Request to do a scan. If returning zero, the scan request is given\n *  the driver, and will be valid until passed to cfg80211_scan_done().\n *  For scan results, call cfg80211_inform_bss(); you can call this outside\n *  the scan/scan_done bracket too.\n\n    int (*scan)(struct wiphy *wiphy,\n            struct cfg80211_scan_request *request);\n\n\nadd_key\n\nWEP,WPA\u306a\u3069\u306e\u6697\u53f7\u30ad\u30fc\u3092\u8ffd\u52a0\u3059\u308b\u3002\n\u5f15\u6570\n\n\nwiphy Wireless device\u306e\u30a4\u30f3\u30b9\u30bf\u30f3\u30b9\ndev \u30cd\u30c3\u30c8\u30ef\u30fc\u30af\u30a4\u30f3\u30bf\u30fc\u30d5\u30a7\u30a4\u30b9\u306b\u5bfe\u5fdc\u3059\u308bnetdev\nkey_index key\u306eid\npairwise \u4eca\u306f\u4f7f\u3063\u3066\u3044\u306a\u3044\u5834\u5408\u304c\u591a\u3044\u3088\u3046\u3067\u3059\u3002\nmac_addr \u76f8\u624b\u306eMAC\u30a2\u30c9\u30ec\u30b9 NULL\u306a\u3089group key\u3068\u3057\u3066\u6271\u3046\nparams \u9375\u3068\u6697\u53f7\u306e\u7a2e\u985e\u306a\u3069\u306e\u60c5\u5831\n\n\n\n * @add_key: add a key with the given parameters. @mac_addr will be %NULL\n *  when adding a group key.\n\n    int (*add_key)(struct wiphy *wiphy, struct net_device *netdev,\n               u8 key_index, bool pairwise, const u8 *mac_addr,\n               struct key_params *params);\n\n\ndel_key\n\nWEP,WPA\u306a\u3069\u306e\u6697\u53f7\u30ad\u30fc\u3092\u524a\u9664\u3059\u308b\n\u5f15\u6570\n\n\nwiphy Wireless device\u306e\u30a4\u30f3\u30b9\u30bf\u30f3\u30b9\ndev \u30cd\u30c3\u30c8\u30ef\u30fc\u30af\u30a4\u30f3\u30bf\u30fc\u30d5\u30a7\u30a4\u30b9\u306b\u5bfe\u5fdc\u3059\u308bnetdev\nkey_index key\u306eid\npairwise \u4eca\u306f\u4f7f\u3063\u3066\u3044\u306a\u3044\u5834\u5408\u304c\u591a\u3044\u3088\u3046\u3067\u3059\u3002\nmac_addr MAC\u30a2\u30c9\u30ec\u30b9 NULL\u306a\u3089group key\u3068\u3057\u3066\u6271\u3046\n\n\n\n * @del_key: remove a key given the @mac_addr (%NULL for a group key)\n *  and @key_index, return -ENOENT if the key doesn't exist.\n\n    int (*del_key)(struct wiphy *wiphy, struct net_device *netdev,\n               u8 key_index, bool pairwise, const u8 *mac_addr);\n\n\nset_default_kery\n\nadd_key\u3067\u8ffd\u52a0\u3057\u305f\u9375\u306e\u3046\u3061\u3001\u3069\u308c\u3092\u30c7\u30d5\u30a9\u30eb\u30c8\u3067\u4f7f\u3046\u304b\u3092\u8a2d\u5b9a\u3059\u308b\u3002\n\u5f15\u6570\n\n\nwiphy Wireless device\u306e\u30a4\u30f3\u30b9\u30bf\u30f3\u30b9\ndev \u30cd\u30c3\u30c8\u30ef\u30fc\u30af\u30a4\u30f3\u30bf\u30fc\u30d5\u30a7\u30a4\u30b9\u306b\u5bfe\u5fdc\u3059\u308bnetdev\nkey_index key\u306eid\nunicast TRUE\u306a\u3089\u30e6\u30cb\u30ad\u30e3\u30b9\u30c8\u9375\nmulticast\u3000TRUE\u306a\u3089\u30de\u30eb\u30c1\u30ad\u30e3\u30b9\u30c8\u9375\n\n\n\n * @set_default_key: set the default key on an interface\n\n    int (*set_default_key)(struct wiphy *wiphy,\n                   struct net_device *netdev,\n                   u8 key_index, bool unicast, bool multicast);\n\n\ncfg80211_ops \u306e\u3088\u304f\u4f7f\u3044\u305d\u3046\u306a\u95a2\u6570\u306b\u3064\u3044\u3066\u8abf\u3079\u3066\u307f\u307e\u3057\u305f\u3002\n\ncfg80211\u306fLinux Kernel\u306eWi-Fi\u8a2d\u5b9a\uff08AP\u3068\u306e\u63a5\u7d9a\u3001\u30b9\u30ad\u30e3\u30f3\u306a\u3069\uff09\u3092\u3059\u308b\u30ab\u30fc\u30cd\u30eb\u306e\u6a5f\u80fd\u3067\u3059\u3002\n\u30c9\u30e9\u30a4\u30d0\u307e\u305f\u306fmac80211\u306b\u5bfe\u3057\u3066\u306fcfg80211_ops\u3068\u3044\u3046\u95a2\u6570\u30dd\u30a4\u30f3\u30bf\u306e\u69cb\u9020\u4f53\u3092\u4f7f\u3063\u3066\u3084\u308a\u3068\u308a\u3057\u307e\u3059\u3002\n(FullMAC\u306e\u5834\u5408\u306fcfg80211\u306e\u76f4\u4e0b\u306b\u30c9\u30e9\u30a4\u30d0\u304c\u3042\u308b\u3002SoftMAC\u306e\u5834\u5408\u306fcfg80211\u306e\u4e0b\u306bmac80211\u304c\u3042\u308a\u3001\u305d\u306e\u4e0b\u306b\u30c9\u30e9\u30a4\u30d0\u304c\u3042\u308b\u3002)\n\u30a2\u30d7\u30ea\u304b\u3089\u306fioctl\u3092\u4f7f\u3063\u3066nl80211\u7d4c\u7531\u3067\u30a2\u30af\u30bb\u30b9\u3057\u307e\u3059\u3002\n\nLinux\u306eWi-Fi\u30c9\u30e9\u30a4\u30d0\u3092\u4e0a\u304b\u3089\u8aad\u3080\u5834\u5408\u306f\u3001\u5236\u5fa1\u7cfb\u306e\u64cd\u4f5c\u306fcfg80211_ops\u304b\u3089\u8aad\u3093\u3067\u3044\u304d\u307e\u3059\u3002\n\u30c7\u30fc\u30bf\u9001\u53d7\u4fe1\u306e\u5834\u5408\u306fnetdev\u95a2\u9023\u304b\u3089\u8aad\u307f\u307e\u3059\u3002\ncfg80211_ops\u306f\u95a2\u6570\u304c\u591a\u3059\u304e\u306a\u306e\u3067\u3001\u307e\u305a\u8aad\u3080\u3079\u304d\u95a2\u6570\u3092\u30d4\u30c3\u30af\u30a2\u30c3\u30d7\u3057\u3066\u307f\u307e\u3057\u305f\u3002\n\u4eca\u56de\u306fSTA\u306e\u307f\u3068\u3057\u307e\u3057\u305f\u3002\n\n![Untitled.png](https://qiita-image-store.s3.amazonaws.com/0/42120/ee1fc464-6d5c-0fcb-406c-e5b2385710e2.png)\n\n\n# \u30bd\u30fc\u30b9\u30b3\u30fc\u30c9\n* https://github.com/torvalds/linux/blob/master/include/net/cfg80211.h\n* \u30c9\u30e9\u30a4\u30d0\u306e cfg80211_ops \u3092\u5b9f\u88c5\u3057\u3066\u3044\u308b\u90e8\u5206\n* mac80211\u306ecfg80211_ops\u3092\u5b9f\u88c5\u3057\u3066\u3044\u308b\u90e8\u5206\n\n\n# cfg80211_ops \u306eSTA\u3067\u3088\u304f\u4f7f\u3046\u95a2\u6570\n## connect\n* \u5f15\u6570sme\u3067\u6307\u5b9a\u3057\u305fAP\u306b\u63a5\u7d9a\u3059\u308b\n* \u7d50\u679c\u306f cfg80211_connect_result()\u3067\u30b3\u30fc\u30eb\u30d0\u30c3\u30af\u3059\u308b\u3002\n* \u5f15\u6570\n    * wiphy Wireless device\u306e\u30a4\u30f3\u30b9\u30bf\u30f3\u30b9\n    * dev \u30cd\u30c3\u30c8\u30ef\u30fc\u30af\u30a4\u30f3\u30bf\u30fc\u30d5\u30a7\u30a4\u30b9\u306b\u5bfe\u5fdc\u3059\u308bnetdev\n    * sme SSID BSSID\u306a\u3069AP\u3092\u8b58\u5225\u3067\u304d\u308b\u60c5\u5831\u3068scan\u7d50\u679c\u306e\u60c5\u5831\u306a\u3069\n\n```\n * @connect: Connect to the ESS with the specified parameters. When connected,\n *\tcall cfg80211_connect_result() with status code %WLAN_STATUS_SUCCESS.\n *\tIf the connection fails for some reason, call cfg80211_connect_result()\n *\twith the status from the AP. The driver is allowed to roam to other\n *\tBSSes within the ESS when the other BSS matches the connect parameters.\n *\tWhen such roaming is initiated by the driver, the driver is expected to\n *\tverify that the target matches the configured security parameters and\n *\tto use Reassociation Request frame instead of Association Request frame.\n *\tThe connect function can also be used to request the driver to perform\n *\ta specific roam when connected to an ESS. In that case, the prev_bssid\n *\tparameter is set to the BSSID of the currently associated BSS as an\n *\tindication of requesting reassociation. In both the driver-initiated and\n *\tnew connect() call initiated roaming cases, the result of roaming is\n *\tindicated with a call to cfg80211_roamed() or cfg80211_roamed_bss().\n *\t(invoked with the wireless_dev mutex held)\n```\n```c\n\tint\t(*connect)(struct wiphy *wiphy, struct net_device *dev,\n\t\t\t   struct cfg80211_connect_params *sme);\n```\n## disconnect\n* AP \u3068\u306e\u63a5\u7d9a\u3092\u5207\u65ad\u3059\u308b\u3002\n* \u5f15\u6570\n    * wiphy Wireless device\u306e\u30a4\u30f3\u30b9\u30bf\u30f3\u30b9\n    * dev \u30cd\u30c3\u30c8\u30ef\u30fc\u30af\u30a4\u30f3\u30bf\u30fc\u30d5\u30a7\u30a4\u30b9\u306b\u5bfe\u5fdc\u3059\u308bnetdev\n    * reason_code \u5207\u65ad\u8981\u6c42\u306b\u542b\u3081\u308b\u5207\u65ad\u7406\u7531\n\n```\n * @disconnect: Disconnect from the BSS/ESS.\n *\t(invoked with the wireless_dev mutex held)\n```\n```c\n\tint\t(*disconnect)(struct wiphy *wiphy, struct net_device *dev,\n\t\t\t      u16 reason_code);\n```\n\n## scan\n* AP\u306a\u3069\u3092\u63a2\u3059\u305f\u3081\u306b\u30b9\u30ad\u30e3\u30f3\u3059\u308b\u3002\n* \u30b9\u30ad\u30e3\u30f3\u7d50\u679c\u306f\u3001cfg80211_scan_done()\u3067\u30b3\u30fc\u30eb\u30d0\u30c3\u30af\u3059\u308b\u3002\n* \u5f15\u6570\n    * wiphy Wireless device\u306e\u30a4\u30f3\u30b9\u30bf\u30f3\u30b9\n    * request Scan\u306e\u8a2d\u5b9a channel,band,ssid\u306a\u3069\n\n```\n * @scan: Request to do a scan. If returning zero, the scan request is given\n *\tthe driver, and will be valid until passed to cfg80211_scan_done().\n *\tFor scan results, call cfg80211_inform_bss(); you can call this outside\n *\tthe scan/scan_done bracket too.\n```\n```\n\tint\t(*scan)(struct wiphy *wiphy,\n\t\t\tstruct cfg80211_scan_request *request);\n```\n\n## add_key\n* WEP,WPA\u306a\u3069\u306e\u6697\u53f7\u30ad\u30fc\u3092\u8ffd\u52a0\u3059\u308b\u3002\n* \u5f15\u6570\n    * wiphy Wireless device\u306e\u30a4\u30f3\u30b9\u30bf\u30f3\u30b9\n    * dev \u30cd\u30c3\u30c8\u30ef\u30fc\u30af\u30a4\u30f3\u30bf\u30fc\u30d5\u30a7\u30a4\u30b9\u306b\u5bfe\u5fdc\u3059\u308bnetdev\n    * key_index key\u306eid\n    * pairwise \u4eca\u306f\u4f7f\u3063\u3066\u3044\u306a\u3044\u5834\u5408\u304c\u591a\u3044\u3088\u3046\u3067\u3059\u3002\n    * mac_addr \u76f8\u624b\u306eMAC\u30a2\u30c9\u30ec\u30b9 NULL\u306a\u3089group key\u3068\u3057\u3066\u6271\u3046\n    * params \u9375\u3068\u6697\u53f7\u306e\u7a2e\u985e\u306a\u3069\u306e\u60c5\u5831\n\n```\n * @add_key: add a key with the given parameters. @mac_addr will be %NULL\n *\twhen adding a group key.\n```\n\n```\n\tint\t(*add_key)(struct wiphy *wiphy, struct net_device *netdev,\n\t\t\t   u8 key_index, bool pairwise, const u8 *mac_addr,\n\t\t\t   struct key_params *params);\n```\n\n## del_key\n* WEP,WPA\u306a\u3069\u306e\u6697\u53f7\u30ad\u30fc\u3092\u524a\u9664\u3059\u308b\n* \u5f15\u6570\n    * wiphy Wireless device\u306e\u30a4\u30f3\u30b9\u30bf\u30f3\u30b9\n    * dev \u30cd\u30c3\u30c8\u30ef\u30fc\u30af\u30a4\u30f3\u30bf\u30fc\u30d5\u30a7\u30a4\u30b9\u306b\u5bfe\u5fdc\u3059\u308bnetdev\n    * key_index key\u306eid\n    * pairwise \u4eca\u306f\u4f7f\u3063\u3066\u3044\u306a\u3044\u5834\u5408\u304c\u591a\u3044\u3088\u3046\u3067\u3059\u3002\n    * mac_addr MAC\u30a2\u30c9\u30ec\u30b9 NULL\u306a\u3089group key\u3068\u3057\u3066\u6271\u3046\n\n```\n * @del_key: remove a key given the @mac_addr (%NULL for a group key)\n *\tand @key_index, return -ENOENT if the key doesn't exist.\n```\n```\n\tint\t(*del_key)(struct wiphy *wiphy, struct net_device *netdev,\n\t\t\t   u8 key_index, bool pairwise, const u8 *mac_addr);\n```\n\n## set_default_kery\n* add_key\u3067\u8ffd\u52a0\u3057\u305f\u9375\u306e\u3046\u3061\u3001\u3069\u308c\u3092\u30c7\u30d5\u30a9\u30eb\u30c8\u3067\u4f7f\u3046\u304b\u3092\u8a2d\u5b9a\u3059\u308b\u3002\n* \u5f15\u6570\n    * wiphy Wireless device\u306e\u30a4\u30f3\u30b9\u30bf\u30f3\u30b9\n    * dev \u30cd\u30c3\u30c8\u30ef\u30fc\u30af\u30a4\u30f3\u30bf\u30fc\u30d5\u30a7\u30a4\u30b9\u306b\u5bfe\u5fdc\u3059\u308bnetdev\n    * key_index key\u306eid\n    * unicast TRUE\u306a\u3089\u30e6\u30cb\u30ad\u30e3\u30b9\u30c8\u9375\n    * multicast\u3000TRUE\u306a\u3089\u30de\u30eb\u30c1\u30ad\u30e3\u30b9\u30c8\u9375\n\n```\n * @set_default_key: set the default key on an interface\n```\n```\n\tint\t(*set_default_key)(struct wiphy *wiphy,\n\t\t\t\t   struct net_device *netdev,\n\t\t\t\t   u8 key_index, bool unicast, bool multicast);\n```\n\n"}