{"context": "\n\n\u6982\u8981\nARM Thumb \u3067\u3059\u300232bit\u3067\u306f\u3001\u3042\u308a\u307e\u305b\u3093\u3002\nMOVS Rd, #<imm>     N Z     Rd := imm imm range 0-255.\nMOVS Rd, Rm         N Z     Rd := Rm Synonym of LSLS Rd, Rm, #0\nMOV  Rd, Rm                 Rd := Rm Not Lo to Lo.\nMOV  Rd, Rm                 Rd := Rm Any register to any register.\nADDS Rd, Rn, #<imm> N Z C V Rd := Rn + imm imm range 0-7.\nADDS Rd, Rn, Rm     N Z C V Rd := Rn + Rm\nADD  Rd, Rd, Rm             Rd := Rd + Rm Not Lo to Lo.\nADD  Rd, Rd, Rm             Rd := Rd + Rm Any register to any register.\nADDS Rd, Rd, #<imm> N Z C V Rd := Rd + imm imm range 0-255.\nADCS Rd, Rd, Rm     N Z C V Rd := Rd + Rm + C-bit\nADD  SP, SP, #<imm>         SP := SP + imm imm range 0-508 (word-aligned).\nADD  Rd, SP, #<imm>         Rd := SP + imm imm range 0-1020 (word-aligned).\nADR  Rd, <label>            Rd := label label range PC to PC+1020 (word-aligned).\nSUBS Rd, Rn, Rm     N Z C V Rd := Rn \u2013 Rm\nSUBS Rd, Rn, #<imm> N Z C V Rd := Rn \u2013 imm imm range 0-7.\nSUBS Rd, Rd, #<imm> N Z C V Rd := Rd \u2013 imm imm range 0-255.\nSBCS Rd, Rd, Rm     N Z C V Rd := Rd \u2013 Rm \u2013 NOT C-bit\nSUB  SP, SP, #<imm>         SP := SP \u2013 imm imm range 0-508 (word-aligned).\nRSBS Rd, Rn, #0     N Z C V Rd := \u2013 Rn Synonym: NEGS Rd, Rn\nMULS Rd, Rm, Rd     N Z * * Rd := Rm * Rd * C and V flags unpredictable in \u00a74T,\nCMP  Rn, Rm         N Z C V update APSR flags on Rn \u2013 Rm Can be Lo to Lo, Lo to Hi, Hi to Lo, or Hi to Hi.\nCMN  Rn, Rm         N Z C V update APSR flags on Rn + Rm\nCMP  Rn, #<imm>     N Z C V update APSR flags on Rn \u2013 imm imm range 0-255.\nANDS Rd, Rd, Rm     N Z     Rd := Rd AND Rm\nEORS Rd, Rd, Rm     N Z     Rd := Rd EOR Rm\nORRS Rd, Rd, Rm     N Z     Rd := Rd OR Rm\nBICS Rd, Rd, Rm     N Z     Rd := Rd AND NOT Rm\nMVNS Rd, Rd, Rm     N Z     Rd := NOT Rm\nTST  Rn, Rm         N Z     update APSR flags on Rn AND Rm\nLSLS Rd, Rm, #<shift> N Z C* Rd := Rm << shift Allowed shifts 0-31. * C flag unaffected if shift is 0.\nLSLS Rd, Rd, Rs     N Z C*  Rd := Rd << Rs[7:0] * C flag unaffected if Rs[7:0] is 0.\nLSRS Rd, Rm, #<shift> N Z C Rd := Rm >> shift Allowed shifts 1-32.\nLSRS Rd, Rd, Rs     N Z C*  Rd := Rd >> Rs[7:0] * C flag unaffected if Rs[7:0] is 0.\nASRS Rd, Rm, #<shift> N Z C Rd := Rm ASR shift Allowed shifts 1-32.\nASRS Rd, Rd, Rs     N Z C*  Rd := Rd ASR Rs[7:0] * C flag unaffected if Rs[7:0] is 0.\nRORS Rd, Rd, Rs     N Z C*  Rd := Rd ROR Rs[7:0] * C flag unaffected if Rs[7:0] is 0.\nLDR  Rd, [Rn, #<imm>]       Rd := [Rn + imm] imm range 0-124, multiple of 4.\nLDRH Rd, [Rn, #<imm>]       Rd := ZeroExtend([Rn + imm][15:0]) Clears bits 31:16. imm range 0-62, even.\nLDRB Rd, [Rn, #<imm>]       Rd := ZeroExtend([Rn + imm][7:0]) Clears bits 31:8. imm range 0-31.\nLDR  Rd, [Rn, Rm]           Rd := [Rn + Rm]\nLDRH Rd, [Rn, Rm]           Rd := ZeroExtend([Rn + Rm][15:0]) Clears bits 31:16\nLDRSH Rd, [Rn, Rm]          Rd := SignExtend([Rn + Rm][15:0]) Sets bits 31:16 to bit 15\nLDRB Rd, [Rn, Rm]           Rd := ZeroExtend([Rn + Rm][7:0]) Clears bits 31:8\nLDRSB Rd, [Rn, Rm]          Rd := SignExtend([Rn + Rm][7:0]) Sets bits 31:8 to bit 7\nLDR  Rd, <label>            Rd := [label] label range PC to PC+1020 (word-aligned).\nLDR  Rd, [SP, #<imm>]       Rd := [SP + imm] imm range 0-1020, multiple of 4.\nLDM  Rn!, <loreglist>       Loads list of registers (not including Rn) Always updates base register, Increment After.\nLDM  Rn, <loreglist>        Loads list of registers (including Rn) Never updates base register, Increment After.\nSTR  Rd, [Rn, #<imm>]       [Rn + imm] := Rd imm range 0-124, multiple of 4.\nSTRH Rd, [Rn, #<imm>]       [Rn + imm][15:0] := Rd[15:0] Ignores Rd[31:16]. imm range 0-62, even.\nSTRB Rd, [Rn, #<imm>]       [Rn + imm][7:0] := Rd[7:0] Ignores Rd[31:8]. imm range 0-31.\nSTR  Rd, [Rn, Rm]           [Rn + Rm] := Rd\nSTRH Rd, [Rn, Rm]           [Rn + Rm][15:0] := Rd[15:0] Ignores Rd[31:16]\nSTRB Rd, [Rn, Rm]           [Rn + Rm][7:0] := Rd[7:0] Ignores Rd[31:8]\nSTR  Rd, [SP, #<imm>]       [SP + imm] := Rd imm range 0-1020, multiple of 4.\nSTM  Rn!, <loreglist>       Stores list of registers Always updates base register, Increment After.\nPUSH <loreglist>            Push registers onto full descending stack\nPUSH <loreglist+LR>         Push LR and registers onto full descending stack\nPOP  <loreglist>            Pop registers from full descending stack\nPOP  <loreglist+PC>         Pop registers, branch to address loaded to PC\nPOP  <loreglist+PC>         Pop, branch, and change to ARM state if address[0] = 0\nIT{pattern} {cond}          Makes up to four following instructions conditional,\nB{cond} <label>             If {cond} then PC := label label must be within \u2013 252 to + 258 bytes of current instruction.\nB    <label>                PC := label label must be within \u00b12KB of current instruction.\nBL   <label>                LR := address of next instruction, PC := label This is a 32-bit instruction.\nBX   Rm                     PC := Rm AND 0xFFFFFFFE Change to ARM state if Rm[0] = 0.\nBLX  <label>                LR := address of next instruction, PC := label\nBLX  Rm                     LR := address of next instruction, PC := Rm AND 0xFFFFFFFE\nSXTH Rd, Rm                 Rd[31:0] := SignExtend(Rm[15:0])\nSXTB Rd, Rm                 Rd[31:0] := SignExtend(Rm[7:0])\nUXTH Rd, Rm                 Rd[31:0] := ZeroExtend(Rm[15:0])\nUXTB Rd, Rm                 Rd[31:0] := ZeroExtend(Rm[7:0])\nREV  Rd, Rm                 Rd[31:24] := Rm[7:0], Rd[23:16] := Rm[15:8], Rd[15:8] := Rm[23:16], Rd[7:0] := Rm[31:24]\nREV16 Rd, Rm                Rd[15:8] := Rm[7:0], Rd[7:0] := Rm[15:8], Rd[31:24] := Rm[23:16], Rd[23:16] := Rm[31:24]\nREVSH Rd, Rm                Rd[15:8] := Rm[7:0], Rd[7:0] := Rm[15:8], Rd[31:16] := Rm[7] * &FFFF\nSVC <immed_8>           Supervisor Call processor exception 8-bit immediate value encoded in instruction. Formerly SWI.\nCPSID <iflags>          Disable specified interrupts\nCPSIE <iflags>          Enable specified interrupts\nSETEND <endianness>     Sets endianness for loads and saves. <endianness> can be BE (Big Endian) or LE (Little Endian).\nBKPT <immed_8>          Prefetch abort or enter debug state 8-bit immediate value encoded in instruction.\nNOP                     None, might not even consume any time. Real NOP available in ARM v6K and above.\nSEV                     Signal event in multiprocessor system. Executes as NOP in Thumb-2.\nWFE                     Wait for event, IRQ, FIQ, Imprecise abort, or Debug entry request. Executes as NOP in Thumb-2. \nWFI                     Wait for IRQ, FIQ, Imprecise abort, or Debug entry request. Executes as NOP in Thumb-2. \nYIELD                   Yield control to alternative thread.\n\n\n\n#\u6982\u8981\nARM Thumb \u3067\u3059\u300232bit\u3067\u306f\u3001\u3042\u308a\u307e\u305b\u3093\u3002\n\n```\nMOVS Rd, #<imm> \tN Z \tRd := imm imm range 0-255.\nMOVS Rd, Rm \t\tN Z \tRd := Rm Synonym of LSLS Rd, Rm, #0\nMOV  Rd, Rm \t\t\t\tRd := Rm Not Lo to Lo.\nMOV  Rd, Rm \t\t\t\tRd := Rm Any register to any register.\nADDS Rd, Rn, #<imm> N Z C V Rd := Rn + imm imm range 0-7.\nADDS Rd, Rn, Rm \tN Z C V Rd := Rn + Rm\nADD  Rd, Rd, Rm \t\t\tRd := Rd + Rm Not Lo to Lo.\nADD  Rd, Rd, Rm \t\t\tRd := Rd + Rm Any register to any register.\nADDS Rd, Rd, #<imm> N Z C V Rd := Rd + imm imm range 0-255.\nADCS Rd, Rd, Rm \tN Z C V Rd := Rd + Rm + C-bit\nADD  SP, SP, #<imm> \t\tSP := SP + imm imm range 0-508 (word-aligned).\nADD  Rd, SP, #<imm> \t\tRd := SP + imm imm range 0-1020 (word-aligned).\nADR  Rd, <label> \t\t\tRd := label label range PC to PC+1020 (word-aligned).\nSUBS Rd, Rn, Rm \tN Z C V Rd := Rn \u2013 Rm\nSUBS Rd, Rn, #<imm> N Z C V Rd := Rn \u2013 imm imm range 0-7.\nSUBS Rd, Rd, #<imm> N Z C V Rd := Rd \u2013 imm imm range 0-255.\nSBCS Rd, Rd, Rm \tN Z C V Rd := Rd \u2013 Rm \u2013 NOT C-bit\nSUB  SP, SP, #<imm> \t\tSP := SP \u2013 imm imm range 0-508 (word-aligned).\nRSBS Rd, Rn, #0 \tN Z C V Rd := \u2013 Rn Synonym: NEGS Rd, Rn\nMULS Rd, Rm, Rd \tN Z * * Rd := Rm * Rd * C and V flags unpredictable in \u00a74T,\nCMP  Rn, Rm \t\tN Z C V update APSR flags on Rn \u2013 Rm Can be Lo to Lo, Lo to Hi, Hi to Lo, or Hi to Hi.\nCMN  Rn, Rm \t\tN Z C V update APSR flags on Rn + Rm\nCMP  Rn, #<imm> \tN Z C V update APSR flags on Rn \u2013 imm imm range 0-255.\nANDS Rd, Rd, Rm \tN Z \tRd := Rd AND Rm\nEORS Rd, Rd, Rm \tN Z \tRd := Rd EOR Rm\nORRS Rd, Rd, Rm \tN Z \tRd := Rd OR Rm\nBICS Rd, Rd, Rm \tN Z \tRd := Rd AND NOT Rm\nMVNS Rd, Rd, Rm \tN Z \tRd := NOT Rm\nTST  Rn, Rm \t\tN Z \tupdate APSR flags on Rn AND Rm\nLSLS Rd, Rm, #<shift> N Z C* Rd := Rm << shift Allowed shifts 0-31. * C flag unaffected if shift is 0.\nLSLS Rd, Rd, Rs \tN Z C* \tRd := Rd << Rs[7:0] * C flag unaffected if Rs[7:0] is 0.\nLSRS Rd, Rm, #<shift> N Z C Rd := Rm >> shift Allowed shifts 1-32.\nLSRS Rd, Rd, Rs \tN Z C* \tRd := Rd >> Rs[7:0] * C flag unaffected if Rs[7:0] is 0.\nASRS Rd, Rm, #<shift> N Z C Rd := Rm ASR shift Allowed shifts 1-32.\nASRS Rd, Rd, Rs \tN Z C* \tRd := Rd ASR Rs[7:0] * C flag unaffected if Rs[7:0] is 0.\nRORS Rd, Rd, Rs \tN Z C* \tRd := Rd ROR Rs[7:0] * C flag unaffected if Rs[7:0] is 0.\nLDR  Rd, [Rn, #<imm>] \t\tRd := [Rn + imm] imm range 0-124, multiple of 4.\nLDRH Rd, [Rn, #<imm>] \t\tRd := ZeroExtend([Rn + imm][15:0]) Clears bits 31:16. imm range 0-62, even.\nLDRB Rd, [Rn, #<imm>] \t\tRd := ZeroExtend([Rn + imm][7:0]) Clears bits 31:8. imm range 0-31.\nLDR  Rd, [Rn, Rm] \t\t\tRd := [Rn + Rm]\nLDRH Rd, [Rn, Rm] \t\t\tRd := ZeroExtend([Rn + Rm][15:0]) Clears bits 31:16\nLDRSH Rd, [Rn, Rm] \t\t\tRd := SignExtend([Rn + Rm][15:0]) Sets bits 31:16 to bit 15\nLDRB Rd, [Rn, Rm] \t\t\tRd := ZeroExtend([Rn + Rm][7:0]) Clears bits 31:8\nLDRSB Rd, [Rn, Rm] \t\t\tRd := SignExtend([Rn + Rm][7:0]) Sets bits 31:8 to bit 7\nLDR  Rd, <label> \t\t\tRd := [label] label range PC to PC+1020 (word-aligned).\nLDR  Rd, [SP, #<imm>] \t\tRd := [SP + imm] imm range 0-1020, multiple of 4.\nLDM  Rn!, <loreglist> \t\tLoads list of registers (not including Rn) Always updates base register, Increment After.\nLDM  Rn, <loreglist> \t\tLoads list of registers (including Rn) Never updates base register, Increment After.\nSTR  Rd, [Rn, #<imm>] \t\t[Rn + imm] := Rd imm range 0-124, multiple of 4.\nSTRH Rd, [Rn, #<imm>] \t\t[Rn + imm][15:0] := Rd[15:0] Ignores Rd[31:16]. imm range 0-62, even.\nSTRB Rd, [Rn, #<imm>] \t\t[Rn + imm][7:0] := Rd[7:0] Ignores Rd[31:8]. imm range 0-31.\nSTR  Rd, [Rn, Rm] \t\t\t[Rn + Rm] := Rd\nSTRH Rd, [Rn, Rm] \t\t\t[Rn + Rm][15:0] := Rd[15:0] Ignores Rd[31:16]\nSTRB Rd, [Rn, Rm] \t\t\t[Rn + Rm][7:0] := Rd[7:0] Ignores Rd[31:8]\nSTR  Rd, [SP, #<imm>] \t\t[SP + imm] := Rd imm range 0-1020, multiple of 4.\nSTM  Rn!, <loreglist> \t\tStores list of registers Always updates base register, Increment After.\nPUSH <loreglist> \t\t\tPush registers onto full descending stack\nPUSH <loreglist+LR> \t\tPush LR and registers onto full descending stack\nPOP  <loreglist> \t\t\tPop registers from full descending stack\nPOP  <loreglist+PC> \t\tPop registers, branch to address loaded to PC\nPOP  <loreglist+PC> \t\tPop, branch, and change to ARM state if address[0] = 0\nIT{pattern} {cond} \t\t\tMakes up to four following instructions conditional,\nB{cond} <label> \t\t\tIf {cond} then PC := label label must be within \u2013 252 to + 258 bytes of current instruction.\nB    <label> \t\t\t\tPC := label label must be within \u00b12KB of current instruction.\nBL   <label> \t\t\t\tLR := address of next instruction, PC := label This is a 32-bit instruction.\nBX   Rm \t\t\t\t\tPC := Rm AND 0xFFFFFFFE Change to ARM state if Rm[0] = 0.\nBLX  <label> \t\t\t\tLR := address of next instruction, PC := label\nBLX  Rm \t\t\t\t\tLR := address of next instruction, PC := Rm AND 0xFFFFFFFE\nSXTH Rd, Rm \t\t\t\tRd[31:0] := SignExtend(Rm[15:0])\nSXTB Rd, Rm \t\t\t\tRd[31:0] := SignExtend(Rm[7:0])\nUXTH Rd, Rm \t\t\t\tRd[31:0] := ZeroExtend(Rm[15:0])\nUXTB Rd, Rm \t\t\t\tRd[31:0] := ZeroExtend(Rm[7:0])\nREV  Rd, Rm \t\t\t\tRd[31:24] := Rm[7:0], Rd[23:16] := Rm[15:8], Rd[15:8] := Rm[23:16], Rd[7:0] := Rm[31:24]\nREV16 Rd, Rm \t\t\t\tRd[15:8] := Rm[7:0], Rd[7:0] := Rm[15:8], Rd[31:24] := Rm[23:16], Rd[23:16] := Rm[31:24]\nREVSH Rd, Rm \t\t\t\tRd[15:8] := Rm[7:0], Rd[7:0] := Rm[15:8], Rd[31:16] := Rm[7] * &FFFF\nSVC <immed_8> \t\t\tSupervisor Call processor exception 8-bit immediate value encoded in instruction. Formerly SWI.\nCPSID <iflags> \t\t\tDisable specified interrupts\nCPSIE <iflags> \t\t\tEnable specified interrupts\nSETEND <endianness> \tSets endianness for loads and saves. <endianness> can be BE (Big Endian) or LE (Little Endian).\nBKPT <immed_8> \t\t\tPrefetch abort or enter debug state 8-bit immediate value encoded in instruction.\nNOP \t\t\t\t\tNone, might not even consume any time. Real NOP available in ARM v6K and above.\nSEV \t\t\t\t\tSignal event in multiprocessor system. Executes as NOP in Thumb-2.\nWFE \t\t\t\t\tWait for event, IRQ, FIQ, Imprecise abort, or Debug entry request. Executes as NOP in Thumb-2. \nWFI \t\t\t\t\tWait for IRQ, FIQ, Imprecise abort, or Debug entry request. Executes as NOP in Thumb-2. \nYIELD \t\t\t\t\tYield control to alternative thread.\n\n\n```\n", "tags": ["ARM", "\u30a2\u30bb\u30f3\u30d6\u30e9"]}