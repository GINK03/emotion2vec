{"context": "\n\n\u305d\u3082\u305d\u3082@FunctionalInterface\u3067\u3042\u308b\u5fc5\u8981\u306f\u3042\u308b\u306e\u304b\n\u306a\u3044\u3067\u3059\u3002\u30bb\u30df\u30b3\u30ed\u30f3\u306e\u5c11\u306a\u3055\u3068\u62ec\u5f27\u306e\u591a\u3055\u3092\u697d\u3057\u3080\u3082\u306e\u3068\u601d\u3063\u3066\u304f\u3060\u3055\u3044\u3002\n\u666e\u901a\u306f\u3053\u3053\u306e\u8a18\u4e8b\u306e\u3082\u306e\u3084Functionnal Java\u306eP(roducts)\u3092\u4f7f\u3046\u306e\u304c\u826f\u3044\u3068\u601d\u3044\u307e\u3059\u3002\n\u8ffd\u8a18: Java8\u3067\u4f7f\u3046\u306a\u3089\u305d\u306e\u3082\u306e\u305a\u3070\u308a\u306eJavaTuples\u306e\u307b\u3046\u304c\u4f7f\u3044\u3084\u3059\u3044\u304b\u3082\u3002\n\nTuple\u306e\u524d\u306b\ninterface \u3060\u3068 toString \u3068 equals \u304c\u5b9f\u88c5\u3067\u304d\u306a\u3044\u306e\u3067\u4ed5\u8fbc\u307f\u304c\u5fc5\u8981\u3067\u3059\u3002\n\nShow.java\n@FunctionalInterface\npublic interface Show {\n    String show();\n    static String show(Object object) {\n        return object instanceof Show\n            ? Show.class.cast(object).show()\n            : java.util.Objects.toString(object, \"\");\n    }\n    static void print(Object object) {\n        System.out.print(show(object));\n    }\n    static void println(Object object) {\n        System.out.println(show(object));\n    }\n}\n\n\n\nEq.java\nimport java.util.function.Supplier;\n@FunctionalInterface\npublic interface Eq {\n    boolean eq(Eq that);\n    static boolean eq(Object o1, Object o2) {\n        return o1 instanceof Eq\n            && o2 instanceof Eq\n                ? Eq.class.cast(o1).eq(Eq.class.cast(o2))\n                : o1 != null && o2 != null && o1.equals(o2)\n            || o1 == o2;\n    }\n    static <T extends Eq & Show> Supplier<T> concrete(final T self) {\n        return new Supplier<T>() {\n            @Override\n            public T get() {\n                return self;\n            }\n            @Override\n            public boolean equals(Object that) {\n                return eq(self, that);\n            }\n            @Override\n            public int hashCode() {\n                return self.show().hashCode();\n            }\n        };\n    }\n}\n\n\n\nTuple!\nConsumer -> Function \u306e\u5909\u63db\u30c6\u30af\u30cb\u30c3\u30af\u306f\u3044\u308d\u3044\u308d\u5fdc\u7528\u304c\u52b9\u304d\u305d\u3046\u3067\u3059\u3002\n\u3057\u304b\u3057\u3053\u306e private X value; \u306e\u6c17\u6301\u3061\u60aa\u3055\u306f\u3069\u3046\u306b\u304b\u306a\u3089\u306a\u3044\u306e\u304b\u3002\n\nTuple.java\nimport java.util.function.BiConsumer;\nimport java.util.function.BiFunction;\nimport java.util.function.Consumer;\nimport java.util.function.Function;\nimport java.util.function.Supplier;\n@FunctionalInterface\npublic interface Tuple<F, S> extends\n    Show, Eq, Consumer<BiConsumer<? super F, ? super S>> {\n    default <X> X apply(BiFunction<F, S, X> f) {\n        return new Supplier<X>() {\n            private X value;\n            public X get() {\n                accept((fst, snd) -> value = f.apply(fst, snd));\n                return value;\n            }\n        }.get();\n    }\n    default <X> X apply(Function<F, Function<S, X>> f) {\n        return this.<X>apply((fst, snd) -> f.apply(fst).apply(snd));\n    }\n    default F fst() {\n        return apply((fst, snd) -> fst);\n    }\n    default S snd() {\n        return apply((fst, snd) -> snd);\n    }\n    default boolean eq(Eq that) {\n        return that instanceof Tuple\n            && eq(Tuple.class.cast(that));\n    }\n    default boolean eq(Tuple<?, ?> that) {\n        return Eq.eq(this.fst(), that.fst())\n            && Eq.eq(this.snd(), that.snd());\n    }\n    default String show() {\n        return String.format(\"(%s,%s)\", Show.show(fst()),\n            Show.show(snd()));\n    }\n    static <F, S> Tuple<F, S> of(F fst, S snd) {\n        return c -> c.accept(fst, snd);\n    }\n    static void main(String[] args) {\n        System.out\n            .println(Show.show(of(\"foo\", of(1, true))));\n        System.out.println(Eq.eq(\n            of(\"foo\", of(1, true)),\n            of(\"foo\", of(1, true))));\n        System.out.println(Eq.eq(\n            of(\"foo\", of(1, true)),\n            of(\"foo\", of(2, true))));\n    }\n}\n\n\n\u3061\u3083\u3093\u3068 Tuple \u3057\u3066\u307e\u3059\u3002\n\n(foo,(1,true))\ntrue\nfalse\n\n\nTuple \u3068\u304d\u305f\u3089 zip ...\u306e\u524d\u306b\nStream\u304b\u3089\u3044\u304d\u306a\u308a zip \u3057\u3088\u3046\u3068\u3059\u308b\u3068 Iterator \u3092\u6271\u3046\u306f\u3081\u306b\u306a\u3063\u3066 Functional \u3067\u306f\u306a\u3044\u306e\u3067 Tuple \u3092\u5229\u7528\u3057\u305f\u30ea\u30b9\u30c8\u3092\u4f5c\u308a\u307e\u3059\u3002\u4e2d\u8eab\u306e\u6709\u7121\u3092\u793a\u3059\u305f\u3081\u306b\u307e\u305a\u306fEither\u304c\u5fc5\u8981\u306b\u306a\u308a\u307e\u3059\u3002\n\nEither.java\nimport java.util.function.BiConsumer;\nimport java.util.function.Consumer;\nimport java.util.function.Function;\nimport java.util.function.Supplier;\n@FunctionalInterface\npublic interface Either<L,R> \n    extends Show, Eq, BiConsumer<Consumer<L>,Consumer<R>>{\n    default <X> X resolve(Function<L,X> fL, Function<R,X> fR) {\n        return new Supplier<X>() {\n            private X value;\n            public X get() {\n                accept(v -> value = fL.apply(v),\n                       v -> value = fR.apply(v));\n                return value;\n            }\n        }.get();\n    }\n    default String show() {\n        return resolve(Show::show, Show::show);\n    }\n    default boolean eq(Eq that) {\n        return that instanceof Either\n            && eq(Either.class.cast(that));\n    }\n    default boolean eq(Either<?,?> that) {\n        return resolve(L1 -> that.resolve(\n                       L2 -> Eq.eq(L1, L2)\n                     , R2 -> false)\n                     , R1 -> that.resolve(\n                       L2 -> false\n                     , R2 -> Eq.eq(R1, R2)));\n    }\n    static <L,R> Either<L,R> L(L value) {\n        return (cL, cR) -> cL.accept(value);\n    }\n    static <L,R> Either<L,R> R(R value) {\n        return (cL, cR) -> cR.accept(value);\n    }\n    static void main(String[] args) {\n        System.out.println(Either.L(\"fail\").show());\n        System.out.println(Either.R(1).show());\n        System.out.println(Eq.eq(Either.R(1), Either.R(1)));\n        System.out.println(Eq.eq(Either.L(\"fail\"), Either.R(1)));\n        System.out.println(Eq.eq(Either.L(\"fail\"), Either.L(\"fail\")));\n    }\n}\n\n\n\nfail\n1\ntrue\nfalse\ntrue\n\nTuple\u306e\u5144\u5f1f\u306e\u3088\u3046\u306a\u30b3\u30fc\u30c9\u3067\u3059\u304c\u3084\u3063\u3071\u308a private X value; \u304c\u5b9f\u306b\u306e\u6c17\u6301\u3061\u60aa\u3044\u3067\u3059\u3002\n\n\u3055\u3042 zip \u306e\u6642\u9593\u3060\uff01\n\u30ea\u30b9\u30c8\u306f\u3053\u3046\u306a\u308a\u307e\u3059\u3002\n\nLst.java\nimport java.util.function.BiFunction;\nimport java.util.function.Function;\nimport java.util.stream.Stream;\n@FunctionalInterface\npublic interface Lst<I> extends\n    Either<Function<I, I>, Tuple<I, Lst<I>>>, Function<I, Lst<I>> {\n    default Lst<I> apply(I i) {\n        return (cL, cR) -> cR.accept(c -> c.accept(i, this));\n    }\n    default <O> Function<O, O> foldR(BiFunction<O, I, O> f) {\n        return resolve(\n            eL -> Function.identity(),\n            eR -> eR.apply(\n                fst -> \n                snd -> snd.foldR(f).compose(o -> f.apply(o, fst))));\n    }\n    default <O> Function<O, O> foldL(BiFunction<O, I, O> f) {\n        return resolve(\n            eL -> Function.identity(),\n            eR -> eR.apply(\n                fst ->\n                snd -> snd.foldL(f).andThen(o -> f.apply(o, fst))));\n    }\n    default Stream<I> toStreamR() {\n        return this.<Stream.Builder<I>> foldL(\n            (is, i) -> is.add(i)).apply(Stream.builder()).build();\n    }\n    default Stream<I> toStreamL() {\n        return this.<Stream.Builder<I>> foldR(\n            (is, i) -> is.add(i)).apply(Stream.builder()).build();\n    }\n    default String show() {\n        return resolve(eL -> \"()\", eR -> eR.show());\n    }\n    static <I> Lst<I> of() {\n        return (cL, cR) -> cL.accept(Function.identity());\n    }\n    static <I> Lst<I> of(I i) {\n        return (cL, cR) -> cR.accept(c -> c.accept(i, of()));\n    }\n    static <I> Lst<I> of(Stream<I> stream) {\n        return stream.<Function<Lst<I>, Lst<I>>>map(i -> s -> s.apply(i))\n            .reduce(Function.identity(), (f, g) -> f.compose(g)).apply(of());\n    }\n    static <I> Lst<I> reverseOf(Stream<I> stream) {\n        return stream.<Function<Lst<I>, Lst<I>>>map(i -> s -> s.apply(i))\n            .reduce(Function.identity(), (f, g) -> f.andThen(g)).apply(of());\n    }\n    static <F,S> Lst<Tuple<F,S>> zip(Lst<F> f, Lst<S> s) {\n        return f.resolve(fL -> Lst.of(), fR ->\n               s.resolve(sL -> Lst.of(), sR ->\n                   zip(fR.snd(), sR.snd()).apply(Tuple.of(fR.fst(), sR.fst()))));\n\n    }\n    static void main(String[] args) {\n        System.out.println(Eq.eq(Lst.of(), Lst.of()));\n        System.out.println(Lst.of(Stream.of(1, 2, 3, 4, 5)).show());\n        System.out.println(Lst.reverseOf(Stream.of(\"foo\", \"bar\", \"baz\")).show());\n        Lst.<Integer> of()\n            .apply(1)\n            .apply(2)\n            .apply(3)\n            .apply(4)\n            .apply(5)\n            .toStreamL()\n            .forEach(System.out::print);\n        Lst.<String> of()\n            .apply(\"\\n\")\n            .apply(\"foo\")\n            .apply(\"bar\")\n            .apply(\"baz\")\n            .apply(\"\\n\")\n            .toStreamR()\n            .forEach(System.out::print);\n\n        zip(Lst.of(Stream.of(\"foo\", \"bar\", \"baz\")),\n        zip(Lst.of(Stream.of(1, 2, 3, 4, 5)),\n            Lst.of(Stream.of(true, false, true, false))))\n        .toStreamL().forEach(Show::println);\n    }\n}\n\n\n\ntrue\n(1,(2,(3,(4,(5,())))))\n(baz,(bar,(foo,())))\n54321\nfoobarbaz\n(foo,(1,true))\n(bar,(2,false))\n(baz,(3,true))\n\n\u3061\u3083\u3093\u3068\u30ea\u30b9\u30c8\u3082zip\u3082\u3057\u3066\u307e\u3059\u3002\napply \u3067\u5148\u982d\u304c\u4f38\u3073\u308b\u306e\u3068 toStream().forEch(System.out::print) \u3068\u51fa\u6765\u7121\u3044\u306e\u306f\u3054\u611b\u5b0c\u3002\n\n\u304a\u308f\u308a\u306b\n\u30bb\u30df\u30b3\u30ed\u30f3\u30ec\u30b9\u306f\u5909\u614b\u306e\u6240\u696d\u3060\u3068\u601d\u3044\u307e\u3059\u304c@FunctionalInterface\u7e1b\u308a\uff08\u30d5\u30a3\u30fc\u30eb\u30c9\u5909\u6570\u4f7f\u3048\u306a\u3044private X value;\u304c\u30d5\u30a3\u30fc\u30eb\u30c9\u5909\u6570\u3067\u3057\u305f\uff09\u306f\u7d50\u69cb\u697d\u3057\u3044\u304b\u3082\u3057\u308c\u307e\u305b\u3093\u3002\n\u73fe\u72b6\u3067\u306f java.util.Map \u306e\u30ad\u30fc\u306b\u4f7f\u3048\u306a\u3044\u6b20\u70b9\u304c\u3042\u308b\u306e\u3067\u305d\u306e\u3046\u3061 <X> X lookup(Lst<Tuple<Eq,X>> map, Eq key) \u3082\u66f8\u304f\u304b\u3082\u3057\u308c\u307e\u305b\u3093\u3002\n# \u305d\u3082\u305d\u3082`@FunctionalInterface`\u3067\u3042\u308b\u5fc5\u8981\u306f\u3042\u308b\u306e\u304b\n\n__\u306a\u3044\u3067\u3059\u3002__\u30bb\u30df\u30b3\u30ed\u30f3\u306e\u5c11\u306a\u3055\u3068\u62ec\u5f27\u306e\u591a\u3055\u3092\u697d\u3057\u3080\u3082\u306e\u3068\u601d\u3063\u3066\u304f\u3060\u3055\u3044\u3002\n\n\u666e\u901a\u306f[\u3053\u3053\u306e\u8a18\u4e8b](http://qiita.com/KIchiro/items/e63d91d5a61069c0278b)\u306e\u3082\u306e\u3084[Functionnal Java](http://www.functionaljava.org/)\u306e[P(roducts)](http://www.functionaljava.org/javadoc/4.6/functionaljava/fj/P.html)\u3092\u4f7f\u3046\u306e\u304c\u826f\u3044\u3068\u601d\u3044\u307e\u3059\u3002\n\n\u8ffd\u8a18: Java8\u3067\u4f7f\u3046\u306a\u3089\u305d\u306e\u3082\u306e\u305a\u3070\u308a\u306e[JavaTuples](http://www.javatuples.org/)\u306e\u307b\u3046\u304c\u4f7f\u3044\u3084\u3059\u3044\u304b\u3082\u3002\n\n# Tuple\u306e\u524d\u306b\n\ninterface \u3060\u3068 `toString` \u3068 `equals` \u304c\u5b9f\u88c5\u3067\u304d\u306a\u3044\u306e\u3067\u4ed5\u8fbc\u307f\u304c\u5fc5\u8981\u3067\u3059\u3002\n\n```Show.java\n@FunctionalInterface\npublic interface Show {\n    String show();\n    static String show(Object object) {\n        return object instanceof Show\n            ? Show.class.cast(object).show()\n            : java.util.Objects.toString(object, \"\");\n    }\n    static void print(Object object) {\n        System.out.print(show(object));\n    }\n    static void println(Object object) {\n        System.out.println(show(object));\n    }\n}\n```\n\n```Eq.java\nimport java.util.function.Supplier;\n@FunctionalInterface\npublic interface Eq {\n    boolean eq(Eq that);\n    static boolean eq(Object o1, Object o2) {\n        return o1 instanceof Eq\n            && o2 instanceof Eq\n                ? Eq.class.cast(o1).eq(Eq.class.cast(o2))\n                : o1 != null && o2 != null && o1.equals(o2)\n            || o1 == o2;\n    }\n    static <T extends Eq & Show> Supplier<T> concrete(final T self) {\n        return new Supplier<T>() {\n            @Override\n            public T get() {\n                return self;\n            }\n            @Override\n            public boolean equals(Object that) {\n                return eq(self, that);\n            }\n            @Override\n            public int hashCode() {\n                return self.show().hashCode();\n            }\n        };\n    }\n}\n```\n\n# Tuple!\n\nConsumer -> Function \u306e\u5909\u63db\u30c6\u30af\u30cb\u30c3\u30af\u306f\u3044\u308d\u3044\u308d\u5fdc\u7528\u304c\u52b9\u304d\u305d\u3046\u3067\u3059\u3002\n\u3057\u304b\u3057\u3053\u306e `private X value;` \u306e\u6c17\u6301\u3061\u60aa\u3055\u306f\u3069\u3046\u306b\u304b\u306a\u3089\u306a\u3044\u306e\u304b\u3002\n\n```Tuple.java\nimport java.util.function.BiConsumer;\nimport java.util.function.BiFunction;\nimport java.util.function.Consumer;\nimport java.util.function.Function;\nimport java.util.function.Supplier;\n@FunctionalInterface\npublic interface Tuple<F, S> extends\n    Show, Eq, Consumer<BiConsumer<? super F, ? super S>> {\n    default <X> X apply(BiFunction<F, S, X> f) {\n        return new Supplier<X>() {\n            private X value;\n            public X get() {\n                accept((fst, snd) -> value = f.apply(fst, snd));\n                return value;\n            }\n        }.get();\n    }\n    default <X> X apply(Function<F, Function<S, X>> f) {\n        return this.<X>apply((fst, snd) -> f.apply(fst).apply(snd));\n    }\n    default F fst() {\n        return apply((fst, snd) -> fst);\n    }\n    default S snd() {\n        return apply((fst, snd) -> snd);\n    }\n    default boolean eq(Eq that) {\n        return that instanceof Tuple\n            && eq(Tuple.class.cast(that));\n    }\n    default boolean eq(Tuple<?, ?> that) {\n        return Eq.eq(this.fst(), that.fst())\n            && Eq.eq(this.snd(), that.snd());\n    }\n    default String show() {\n        return String.format(\"(%s,%s)\", Show.show(fst()),\n            Show.show(snd()));\n    }\n    static <F, S> Tuple<F, S> of(F fst, S snd) {\n        return c -> c.accept(fst, snd);\n    }\n    static void main(String[] args) {\n        System.out\n            .println(Show.show(of(\"foo\", of(1, true))));\n        System.out.println(Eq.eq(\n            of(\"foo\", of(1, true)),\n            of(\"foo\", of(1, true))));\n        System.out.println(Eq.eq(\n            of(\"foo\", of(1, true)),\n            of(\"foo\", of(2, true))));\n    }\n}\n```\n\n\u3061\u3083\u3093\u3068 Tuple \u3057\u3066\u307e\u3059\u3002\n\n>(foo,(1,true))\n>true\n>false\n\n# Tuple \u3068\u304d\u305f\u3089 zip ...\u306e\u524d\u306b\n\nStream\u304b\u3089\u3044\u304d\u306a\u308a zip \u3057\u3088\u3046\u3068\u3059\u308b\u3068 Iterator \u3092\u6271\u3046\u306f\u3081\u306b\u306a\u3063\u3066 Functional \u3067\u306f\u306a\u3044\u306e\u3067 Tuple \u3092\u5229\u7528\u3057\u305f\u30ea\u30b9\u30c8\u3092\u4f5c\u308a\u307e\u3059\u3002\u4e2d\u8eab\u306e\u6709\u7121\u3092\u793a\u3059\u305f\u3081\u306b\u307e\u305a\u306fEither\u304c\u5fc5\u8981\u306b\u306a\u308a\u307e\u3059\u3002\n\n```Either.java\nimport java.util.function.BiConsumer;\nimport java.util.function.Consumer;\nimport java.util.function.Function;\nimport java.util.function.Supplier;\n@FunctionalInterface\npublic interface Either<L,R> \n    extends Show, Eq, BiConsumer<Consumer<L>,Consumer<R>>{\n    default <X> X resolve(Function<L,X> fL, Function<R,X> fR) {\n        return new Supplier<X>() {\n            private X value;\n            public X get() {\n                accept(v -> value = fL.apply(v),\n                       v -> value = fR.apply(v));\n                return value;\n            }\n        }.get();\n    }\n    default String show() {\n        return resolve(Show::show, Show::show);\n    }\n    default boolean eq(Eq that) {\n        return that instanceof Either\n            && eq(Either.class.cast(that));\n    }\n    default boolean eq(Either<?,?> that) {\n        return resolve(L1 -> that.resolve(\n                       L2 -> Eq.eq(L1, L2)\n                     , R2 -> false)\n                     , R1 -> that.resolve(\n                       L2 -> false\n                     , R2 -> Eq.eq(R1, R2)));\n    }\n    static <L,R> Either<L,R> L(L value) {\n        return (cL, cR) -> cL.accept(value);\n    }\n    static <L,R> Either<L,R> R(R value) {\n        return (cL, cR) -> cR.accept(value);\n    }\n    static void main(String[] args) {\n        System.out.println(Either.L(\"fail\").show());\n        System.out.println(Either.R(1).show());\n        System.out.println(Eq.eq(Either.R(1), Either.R(1)));\n        System.out.println(Eq.eq(Either.L(\"fail\"), Either.R(1)));\n        System.out.println(Eq.eq(Either.L(\"fail\"), Either.L(\"fail\")));\n    }\n}\n```\n\n>fail\n>1\n>true\n>false\n>true\n\nTuple\u306e\u5144\u5f1f\u306e\u3088\u3046\u306a\u30b3\u30fc\u30c9\u3067\u3059\u304c\u3084\u3063\u3071\u308a `private X value;` \u304c\u5b9f\u306b\u306e\u6c17\u6301\u3061\u60aa\u3044\u3067\u3059\u3002\n\n# \u3055\u3042 zip \u306e\u6642\u9593\u3060\uff01\n\n\u30ea\u30b9\u30c8\u306f\u3053\u3046\u306a\u308a\u307e\u3059\u3002\n\n```Lst.java\nimport java.util.function.BiFunction;\nimport java.util.function.Function;\nimport java.util.stream.Stream;\n@FunctionalInterface\npublic interface Lst<I> extends\n    Either<Function<I, I>, Tuple<I, Lst<I>>>, Function<I, Lst<I>> {\n    default Lst<I> apply(I i) {\n        return (cL, cR) -> cR.accept(c -> c.accept(i, this));\n    }\n    default <O> Function<O, O> foldR(BiFunction<O, I, O> f) {\n        return resolve(\n            eL -> Function.identity(),\n            eR -> eR.apply(\n                fst -> \n                snd -> snd.foldR(f).compose(o -> f.apply(o, fst))));\n    }\n    default <O> Function<O, O> foldL(BiFunction<O, I, O> f) {\n        return resolve(\n            eL -> Function.identity(),\n            eR -> eR.apply(\n                fst ->\n                snd -> snd.foldL(f).andThen(o -> f.apply(o, fst))));\n    }\n    default Stream<I> toStreamR() {\n        return this.<Stream.Builder<I>> foldL(\n            (is, i) -> is.add(i)).apply(Stream.builder()).build();\n    }\n    default Stream<I> toStreamL() {\n        return this.<Stream.Builder<I>> foldR(\n            (is, i) -> is.add(i)).apply(Stream.builder()).build();\n    }\n    default String show() {\n        return resolve(eL -> \"()\", eR -> eR.show());\n    }\n    static <I> Lst<I> of() {\n        return (cL, cR) -> cL.accept(Function.identity());\n    }\n    static <I> Lst<I> of(I i) {\n        return (cL, cR) -> cR.accept(c -> c.accept(i, of()));\n    }\n    static <I> Lst<I> of(Stream<I> stream) {\n        return stream.<Function<Lst<I>, Lst<I>>>map(i -> s -> s.apply(i))\n            .reduce(Function.identity(), (f, g) -> f.compose(g)).apply(of());\n    }\n    static <I> Lst<I> reverseOf(Stream<I> stream) {\n        return stream.<Function<Lst<I>, Lst<I>>>map(i -> s -> s.apply(i))\n            .reduce(Function.identity(), (f, g) -> f.andThen(g)).apply(of());\n    }\n    static <F,S> Lst<Tuple<F,S>> zip(Lst<F> f, Lst<S> s) {\n        return f.resolve(fL -> Lst.of(), fR ->\n               s.resolve(sL -> Lst.of(), sR ->\n                   zip(fR.snd(), sR.snd()).apply(Tuple.of(fR.fst(), sR.fst()))));\n                       \n    }\n    static void main(String[] args) {\n        System.out.println(Eq.eq(Lst.of(), Lst.of()));\n        System.out.println(Lst.of(Stream.of(1, 2, 3, 4, 5)).show());\n        System.out.println(Lst.reverseOf(Stream.of(\"foo\", \"bar\", \"baz\")).show());\n        Lst.<Integer> of()\n            .apply(1)\n            .apply(2)\n            .apply(3)\n            .apply(4)\n            .apply(5)\n            .toStreamL()\n            .forEach(System.out::print);\n        Lst.<String> of()\n            .apply(\"\\n\")\n            .apply(\"foo\")\n            .apply(\"bar\")\n            .apply(\"baz\")\n            .apply(\"\\n\")\n            .toStreamR()\n            .forEach(System.out::print);\n        \n        zip(Lst.of(Stream.of(\"foo\", \"bar\", \"baz\")),\n        zip(Lst.of(Stream.of(1, 2, 3, 4, 5)),\n            Lst.of(Stream.of(true, false, true, false))))\n        .toStreamL().forEach(Show::println);\n    }\n}\n```\n\n>true\n>(1,(2,(3,(4,(5,())))))\n>(baz,(bar,(foo,())))\n>54321\n>foobarbaz\n>(foo,(1,true))\n>(bar,(2,false))\n>(baz,(3,true))\n\n\u3061\u3083\u3093\u3068\u30ea\u30b9\u30c8\u3082zip\u3082\u3057\u3066\u307e\u3059\u3002\napply \u3067\u5148\u982d\u304c\u4f38\u3073\u308b\u306e\u3068 toStream().forEch(System.out::print) \u3068\u51fa\u6765\u7121\u3044\u306e\u306f\u3054\u611b\u5b0c\u3002\n\n# \u304a\u308f\u308a\u306b\n\n\u30bb\u30df\u30b3\u30ed\u30f3\u30ec\u30b9\u306f\u5909\u614b\u306e\u6240\u696d\u3060\u3068\u601d\u3044\u307e\u3059\u304c`@FunctionalInterface`\u7e1b\u308a\uff08~~\u30d5\u30a3\u30fc\u30eb\u30c9\u5909\u6570\u4f7f\u3048\u306a\u3044~~`private X value;`\u304c\u30d5\u30a3\u30fc\u30eb\u30c9\u5909\u6570\u3067\u3057\u305f\uff09\u306f\u7d50\u69cb\u697d\u3057\u3044\u304b\u3082\u3057\u308c\u307e\u305b\u3093\u3002\n\n~~\u73fe\u72b6\u3067\u306f java.util.Map \u306e\u30ad\u30fc\u306b\u4f7f\u3048\u306a\u3044\u6b20\u70b9\u304c\u3042\u308b\u306e\u3067~~\u305d\u306e\u3046\u3061 `<X> X lookup(Lst<Tuple<Eq,X>> map, Eq key)` \u3082\u66f8\u304f\u304b\u3082\u3057\u308c\u307e\u305b\u3093\u3002\n\n", "tags": ["Java", "FunctionalProgramming", "Generics"]}