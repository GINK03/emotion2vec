{"context": "modeling with distance functions\u306e\u8ddd\u96e2\u95a2\u6570\u306e\u4e00\u89a7\u306b\u6cbf\u3063\u3066\u8a18\u4e8b\u3092\u66f8\u3044\u3066\u3044\u307e\u3059.\n\n\nPlane\u306e\u6570\u5f0f\nn_{x}x+n_{y}y+n_{z}z=n_{w}\n\n\u3067,\nn_{x}:x\u65b9\u5411\u306e\u50be\u304d, n_{y}:y\u65b9\u5411\u306e\u50be\u304d, n_{z}:z\u65b9\u5411\u306e\u50be\u304d \\\\\n-n_{w}/n_{y}:y\u8ef8\u306e\u9ad8\u3055 \\\\\n(n_{x},n_{y},n_{z}):\u6cd5\u7dda\u30d9\u30af\u30c8\u30eb\n\n\u5c0e\u51fa\u306f\u3001\u3053\u306e\u8a18\u4e8b\u3092\u53c2\u8003\u306b\u5e73\u9762\u306e\u65b9\u7a0b\u5f0f\u3068\u305d\u306e\uff13\u901a\u308a\u306e\u6c42\u3081\u65b9\n\nPlane\u306e\u8ddd\u96e2\u95a2\u6570\u306f\nvec4 n = vec4(\u3010x\u65b9\u5411\u306e\u50be\u304d\u3011, \u3010y\u65b9\u5411\u306e\u50be\u304d\u3011, \u3010z\u65b9\u5411\u306e\u50be\u304d\u3011, 1.0);\nreturn dot(p,n.xyz) + n.w;\n\n\u4eca\u56de\u306e\u95a2\u6570\u306f\u5358\u7d14\u306b floor \u3092\u66f8\u304f\u3068\u304d\u306b\u4f7f\u3046\u95a2\u6570\u306a\u306e\u3067\u3001\u7279\u306b\u8aac\u660e\u306f\u3042\u308a\u307e\u305b\u3093.\n\u5f37\u3044\u3066\u8a00\u3046\u306a\u3089\u3001\u30ab\u30e1\u30e9\u306b\u5e73\u884c\u306b\u3057\u3057\u305f\u3044\u5834\u5408, vec4 n = vec4(0.0, 1.0, 0.0, 1.0); \u3068\u5b9a\u3081\u308c\u3070\u304d\u3063\u3061\u308a\u5e8a\u304c\u6577\u3051\u307e\u3059.\n\u3068\u308a\u3042\u3048\u305a\u3001\u306a\u3093\u304b\u4f5c\u3063\u3066\u307f\u308b.\n\n\u6708\n\n\n\u30d0\u30a6\u30f3\u30c9\u3055\u305b\u3066\u307f\u305f.\n\n\u30bd\u30fc\u30b9\n// ============================================================================\n// Plane function\n// ============================================================================\n\nprecision mediump float;\nuniform vec2  resolution;    // resolution (512.0, 512.0)\nuniform vec2  mouse;         // mouse      (-1.0 ~ 1.0)\nuniform float time;          // time       (1second == 1.0)\nuniform sampler2D prevScene; // previous scene texture\n\n// Plane\u306e\u8ddd\u96e2\u95a2\u6570\nfloat sdPlane(vec3 p){\n  // Plane\u306e\u8ddd\u96e2\u95a2\u6570\n  // n must be normalized\n  vec4 n = vec4(0.0, 1.0, 0.0, 1.0);\n  return dot(p, n.xyz) + n.w;\n}\n\n// \u7403\nfloat dSphere(vec3 p){\n    // \u30d0\u30a6\u30f3\u30c9\u306e\u8868\u73fe\n    p = vec3(p.x+2.0, p.y+2.0-1.25*cos(time) ,p.z-2.0);\n    return length(vec3(p.x-3.0, p.y-3.0, p.z))-0.7;\n}\n\n// \u8ddd\u96e2\u95a2\u6570\u3092\u547c\u3073\u51fa\u3059\u30cf\u30d6\u95a2\u6570\nfloat distanceHub(vec3 p){\n    // return sdPlane(p);\n    return min(sdPlane(p), dSphere(p));\n}\n\n// \u6cd5\u7dda\u3092\u751f\u6210\u3059\u308b\nvec3 genNormal(vec3 p){\n    float d = 0.001;\n    return normalize(vec3(\n        distanceHub(p + vec3(  d, 0.0, 0.0)) - distanceHub(p + vec3( -d, 0.0, 0.0)),\n        distanceHub(p + vec3(0.0,   d, 0.0)) - distanceHub(p + vec3(0.0,  -d, 0.0)),\n        distanceHub(p + vec3(0.0, 0.0,   d)) - distanceHub(p + vec3(0.0, 0.0,  -d))\n    ));\n}\n\nvoid main(){\n    // \u30b9\u30af\u30ea\u30fc\u30f3\u30b9\u30da\u30fc\u30b9\u3092\u8003\u616e\u3057\u3066\u5ea7\u6a19\u3092\u6b63\u898f\u5316\u3059\u308b\n    vec2 p = (gl_FragCoord.xy * 2.0 - resolution) / min(resolution.x, resolution.y);\n    // \u30ab\u30e1\u30e9\u3092\u5b9a\u7fa9\u3059\u308b\n    vec3 cPos = vec3(0.0,  0.0,  5.0); // \u30ab\u30e1\u30e9\u306e\u4f4d\u7f6e\n    vec3 cDir = vec3(0.0,  0.0, -1.0); // \u30ab\u30e1\u30e9\u306e\u5411\u304d(\u8996\u7dda)\n    vec3 cUp  = vec3(0.0,  1.0,  0.0); // \u30ab\u30e1\u30e9\u306e\u4e0a\u65b9\u5411\n    vec3 cSide = cross(cDir, cUp);     // \u5916\u7a4d\u3092\u4f7f\u3063\u3066\u6a2a\u65b9\u5411\u3092\u7b97\u51fa\n    float targetDepth = 1.0;           // \u30d5\u30a9\u30fc\u30ab\u30b9\u3059\u308b\u6df1\u5ea6\n    // \u30ab\u30e1\u30e9\u306e\u60c5\u5831\u304b\u3089\u30ec\u30a4\u3092\u5b9a\u7fa9\u3059\u308b\n    vec3 ray = normalize(cSide * p.x + cUp * p.y + cDir * targetDepth);\n    // \u30de\u30fc\u30c1\u30f3\u30b0\u30eb\u30fc\u30d7\u3092\u7d44\u3080\n    float dist = 0.0;  // \u30ec\u30a4\u3068\u30aa\u30d6\u30b8\u30a7\u30af\u30c8\u9593\u306e\u6700\u77ed\u8ddd\u96e2\n    float rLen = 0.0;  // \u30ec\u30a4\u306b\u7d99\u304e\u8db3\u3059\u9577\u3055\n    vec3  rPos = cPos; // \u30ec\u30a4\u306e\u5148\u7aef\u4f4d\u7f6e(\u521d\u671f\u4f4d\u7f6e)\n    for(int i = 0; i < 32; ++i){\n        dist = distanceHub(rPos);\n        rLen += dist;\n        rPos = cPos + ray * rLen;\n    }\n    // \u30ec\u30a4\u3068\u30aa\u30d6\u30b8\u30a7\u30af\u30c8\u306e\u8ddd\u96e2\u3092\u78ba\u8a8d\n    if(abs(dist) < 0.001){\n        // \u6cd5\u7dda\u3092\u7b97\u51fa\n        vec3 normal = genNormal(rPos);\n        // \u30e9\u30a4\u30c8\u30d9\u30af\u30c8\u30eb\u306e\u5b9a\u7fa9\n        vec3 light = normalize(vec3(1.0, 1.0, 1.0));\n        // \u30e9\u30a4\u30c8\u30d9\u30af\u30c8\u30eb\u3068\u306e\u5185\u7a4d\u3092\u53d6\u308b\n        float diff = max(dot(normal, light), 0.1);\n        gl_FragColor = vec4(vec3(diff, diff, diff), 1.0);\n    }else{\n        // \u885d\u7a81\u3057\u306a\u304b\u3063\u305f\u5834\u5408\u306f\u305d\u306e\u307e\u307e\u9ed2\n        gl_FragColor = vec4(vec3(0.0, 0.0, 0.0), 1.0);\n    }\n}\n\n[modeling with distance functions](http://iquilezles.org/www/articles/distfunctions/distfunctions.htm)\u306e\u8ddd\u96e2\u95a2\u6570\u306e\u4e00\u89a7\u306b\u6cbf\u3063\u3066\u8a18\u4e8b\u3092\u66f8\u3044\u3066\u3044\u307e\u3059.\n\n![image01.PNG](https://qiita-image-store.s3.amazonaws.com/0/102634/791cee87-a967-7d32-0ae3-479b9651d47b.png)\n\n\n# Plane\u306e\u6570\u5f0f\n\n```math\nn_{x}x+n_{y}y+n_{z}z=n_{w}\n```\n\u3067,\n\n```math\nn_{x}:x\u65b9\u5411\u306e\u50be\u304d, n_{y}:y\u65b9\u5411\u306e\u50be\u304d, n_{z}:z\u65b9\u5411\u306e\u50be\u304d \\\\\n-n_{w}/n_{y}:y\u8ef8\u306e\u9ad8\u3055 \\\\\n(n_{x},n_{y},n_{z}):\u6cd5\u7dda\u30d9\u30af\u30c8\u30eb\n```\n\n\u5c0e\u51fa\u306f\u3001\u3053\u306e\u8a18\u4e8b\u3092\u53c2\u8003\u306b[\u5e73\u9762\u306e\u65b9\u7a0b\u5f0f\u3068\u305d\u306e\uff13\u901a\u308a\u306e\u6c42\u3081\u65b9](http://mathtrain.jp/heimen)\n\n# Plane\u306e\u8ddd\u96e2\u95a2\u6570\u306f\n\n```c++\nvec4 n = vec4(\u3010x\u65b9\u5411\u306e\u50be\u304d\u3011, \u3010y\u65b9\u5411\u306e\u50be\u304d\u3011, \u3010z\u65b9\u5411\u306e\u50be\u304d\u3011, 1.0);\nreturn dot(p,n.xyz) + n.w;\n```\n\n\u4eca\u56de\u306e\u95a2\u6570\u306f\u5358\u7d14\u306b `floor` \u3092\u66f8\u304f\u3068\u304d\u306b\u4f7f\u3046\u95a2\u6570\u306a\u306e\u3067\u3001\u7279\u306b\u8aac\u660e\u306f\u3042\u308a\u307e\u305b\u3093.\n\n\u5f37\u3044\u3066\u8a00\u3046\u306a\u3089\u3001\u30ab\u30e1\u30e9\u306b\u5e73\u884c\u306b\u3057\u3057\u305f\u3044\u5834\u5408, `vec4 n = vec4(0.0, 1.0, 0.0, 1.0);` \u3068\u5b9a\u3081\u308c\u3070\u304d\u3063\u3061\u308a\u5e8a\u304c\u6577\u3051\u307e\u3059.\n\n\u3068\u308a\u3042\u3048\u305a\u3001\u306a\u3093\u304b\u4f5c\u3063\u3066\u307f\u308b.\n\n# \u6708\n\n![\u6708\u3082\u3069\u304d.PNG](https://qiita-image-store.s3.amazonaws.com/0/102634/56d74f5c-6bc9-a0f6-2f97-1c815ae6bfa0.png)\n\n## \u30d0\u30a6\u30f3\u30c9\u3055\u305b\u3066\u307f\u305f.\n\n![transform.gif](https://qiita-image-store.s3.amazonaws.com/0/102634/56446157-e75a-deb2-039c-c0d32119ea52.gif)\n\n[\u30bd\u30fc\u30b9](https://github.com/muripoLife/RayMarchingDistanceFunction/blob/master/09/fsp.frag)\n\n```c++\n// ============================================================================\n// Plane function\n// ============================================================================\n\nprecision mediump float;\nuniform vec2  resolution;    // resolution (512.0, 512.0)\nuniform vec2  mouse;         // mouse      (-1.0 ~ 1.0)\nuniform float time;          // time       (1second == 1.0)\nuniform sampler2D prevScene; // previous scene texture\n\n// Plane\u306e\u8ddd\u96e2\u95a2\u6570\nfloat sdPlane(vec3 p){\n  // Plane\u306e\u8ddd\u96e2\u95a2\u6570\n  // n must be normalized\n  vec4 n = vec4(0.0, 1.0, 0.0, 1.0);\n  return dot(p, n.xyz) + n.w;\n}\n\n// \u7403\nfloat dSphere(vec3 p){\n    // \u30d0\u30a6\u30f3\u30c9\u306e\u8868\u73fe\n    p = vec3(p.x+2.0, p.y+2.0-1.25*cos(time) ,p.z-2.0);\n    return length(vec3(p.x-3.0, p.y-3.0, p.z))-0.7;\n}\n\n// \u8ddd\u96e2\u95a2\u6570\u3092\u547c\u3073\u51fa\u3059\u30cf\u30d6\u95a2\u6570\nfloat distanceHub(vec3 p){\n    // return sdPlane(p);\n    return min(sdPlane(p), dSphere(p));\n}\n\n// \u6cd5\u7dda\u3092\u751f\u6210\u3059\u308b\nvec3 genNormal(vec3 p){\n    float d = 0.001;\n    return normalize(vec3(\n        distanceHub(p + vec3(  d, 0.0, 0.0)) - distanceHub(p + vec3( -d, 0.0, 0.0)),\n        distanceHub(p + vec3(0.0,   d, 0.0)) - distanceHub(p + vec3(0.0,  -d, 0.0)),\n        distanceHub(p + vec3(0.0, 0.0,   d)) - distanceHub(p + vec3(0.0, 0.0,  -d))\n    ));\n}\n\nvoid main(){\n    // \u30b9\u30af\u30ea\u30fc\u30f3\u30b9\u30da\u30fc\u30b9\u3092\u8003\u616e\u3057\u3066\u5ea7\u6a19\u3092\u6b63\u898f\u5316\u3059\u308b\n    vec2 p = (gl_FragCoord.xy * 2.0 - resolution) / min(resolution.x, resolution.y);\n    // \u30ab\u30e1\u30e9\u3092\u5b9a\u7fa9\u3059\u308b\n    vec3 cPos = vec3(0.0,  0.0,  5.0); // \u30ab\u30e1\u30e9\u306e\u4f4d\u7f6e\n    vec3 cDir = vec3(0.0,  0.0, -1.0); // \u30ab\u30e1\u30e9\u306e\u5411\u304d(\u8996\u7dda)\n    vec3 cUp  = vec3(0.0,  1.0,  0.0); // \u30ab\u30e1\u30e9\u306e\u4e0a\u65b9\u5411\n    vec3 cSide = cross(cDir, cUp);     // \u5916\u7a4d\u3092\u4f7f\u3063\u3066\u6a2a\u65b9\u5411\u3092\u7b97\u51fa\n    float targetDepth = 1.0;           // \u30d5\u30a9\u30fc\u30ab\u30b9\u3059\u308b\u6df1\u5ea6\n    // \u30ab\u30e1\u30e9\u306e\u60c5\u5831\u304b\u3089\u30ec\u30a4\u3092\u5b9a\u7fa9\u3059\u308b\n    vec3 ray = normalize(cSide * p.x + cUp * p.y + cDir * targetDepth);\n    // \u30de\u30fc\u30c1\u30f3\u30b0\u30eb\u30fc\u30d7\u3092\u7d44\u3080\n    float dist = 0.0;  // \u30ec\u30a4\u3068\u30aa\u30d6\u30b8\u30a7\u30af\u30c8\u9593\u306e\u6700\u77ed\u8ddd\u96e2\n    float rLen = 0.0;  // \u30ec\u30a4\u306b\u7d99\u304e\u8db3\u3059\u9577\u3055\n    vec3  rPos = cPos; // \u30ec\u30a4\u306e\u5148\u7aef\u4f4d\u7f6e(\u521d\u671f\u4f4d\u7f6e)\n    for(int i = 0; i < 32; ++i){\n        dist = distanceHub(rPos);\n        rLen += dist;\n        rPos = cPos + ray * rLen;\n    }\n    // \u30ec\u30a4\u3068\u30aa\u30d6\u30b8\u30a7\u30af\u30c8\u306e\u8ddd\u96e2\u3092\u78ba\u8a8d\n    if(abs(dist) < 0.001){\n        // \u6cd5\u7dda\u3092\u7b97\u51fa\n        vec3 normal = genNormal(rPos);\n        // \u30e9\u30a4\u30c8\u30d9\u30af\u30c8\u30eb\u306e\u5b9a\u7fa9\n        vec3 light = normalize(vec3(1.0, 1.0, 1.0));\n        // \u30e9\u30a4\u30c8\u30d9\u30af\u30c8\u30eb\u3068\u306e\u5185\u7a4d\u3092\u53d6\u308b\n        float diff = max(dot(normal, light), 0.1);\n        gl_FragColor = vec4(vec3(diff, diff, diff), 1.0);\n    }else{\n        // \u885d\u7a81\u3057\u306a\u304b\u3063\u305f\u5834\u5408\u306f\u305d\u306e\u307e\u307e\u9ed2\n        gl_FragColor = vec4(vec3(0.0, 0.0, 0.0), 1.0);\n    }\n}\n```\n", "tags": ["\u6570\u5b66", "GLSL"]}