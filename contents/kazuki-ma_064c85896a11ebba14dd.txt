{"tags": ["LeapMotion", "OpenCV", "C++"], "context": " More than 1 year has passed since last update.\u30e2\u30c1\u30d9\u30fc\u30b7\u30e7\u30f3\uff1aLeapMotion \u306e\u753b\u50cf\u6b6a\u307f\u3092\u9664\u53bb\u3057\u305f\u3044\uff0e\n\u5236\u7d04\u6761\u4ef6\uff1aGPU \u306b\u66f8\u304b\u305b\u308b\u306e\u3068\u304b\u3081\u3093\u3069\u304f\u3055\u3044\u306e\u3067\u304a\u624b\u8efd\u306b\u3044\u304d\u305f\u3044\uff0e\n\n\n\nBefore\nAfter\n\n\n\n\n\n\n\n\n\n\n\n\n\n\u2191\u6211\u304c\u5bb6\u306e\u30cf\u30e0\u30b9\u30bf\u30fc\u30b1\u30fc\u30b8\n\nCode\n#include \"stdafx.h\"\n#include <Leap.h>\n#include <opencv2\\opencv.hpp>\n\ncv::Mat warp(Leap::Image image) {\n    cv::Mat_<cv::Vec3b> out(cv::Size(640, 480));\n    const cv::Mat_<unsigned char> cvImage = cv::Mat(image.height(), image.width(), CV_8UC1, image.dataPointer());\n\n    out.forEach([&](cv::Vec3b& pixel, const int pos[])-> void {\n        float y = (float)pos[0] / out.rows;\n        float x = (float)(pos[1] - 120) / out.rows;\n\n        const Leap::Vector v(\n            (x - image.rayOffsetX()) / image.rayScaleX() / 4 * 2,\n            // \u516c\u5f0f\u30b5\u30a4\u30c8\u3067\u306f tan\u03b8 = 4 \u307e\u3067\u304c\u7bc4\u56f2\u3063\u3066\u8a00\u3063\u3066\u305f\u3051\u3069\uff0c\u305d\u3093\u306a\u306b\u7121\u3044\u3068\u601d\u3046\uff0e\n            (y - image.rayOffsetY()) / image.rayScaleY() / 4 * 2,\n            0);\n\n        const auto warped = image.warp(v);\n\n        if (warped.x > 0 && warped.x < (cvImage.cols - 1)\n            && warped.y > 0 && warped.y < (cvImage.rows - 1)) {\n            // std::cout << warped << std::endl;\n            pixel = cv::Vec3b::all(cvImage(warped.y, warped.x));\n        }\n        else {\n            pixel = cv::Vec3b(0, 255, 0);\n        }\n    });\n\n    return out;\n}\n\nint main()\n{\n    Leap::Controller controller;\n    controller.setPolicy(Leap::Controller::POLICY_IMAGES);\n    controller.setPolicy(Leap::Controller::POLICY_BACKGROUND_FRAMES);\n\n    while (cv::waitKey(1) != 'q') {\n        const auto frame = controller.frame();\n        if (!frame.isValid()) {\n            std::cout << \"Frame is Invalid\" << std::endl;\n            continue;\n        }\n\n        const auto imageList = frame.images();\n\n        if (imageList.isEmpty()) {\n            std::cout << \"imageList.isEmpty()\" << std::endl;\n            continue;\n        }\n\n        const auto imageL = warp(imageList[0]);\n        cv::imshow(\"imageL\", imageL);\n    }\n    return 0;\n}\n\n\nDepth Map \u304c\u6b32\u3057\u3044\u306a\u3089 Intel RealSence \u306e\u307b\u3046\u304c\u3044\u3044\u3067\u3059\u306d\u2026\u2026\n\u30e2\u30c1\u30d9\u30fc\u30b7\u30e7\u30f3\uff1aLeapMotion \u306e\u753b\u50cf\u6b6a\u307f\u3092\u9664\u53bb\u3057\u305f\u3044\uff0e\n\n\u5236\u7d04\u6761\u4ef6\uff1aGPU \u306b\u66f8\u304b\u305b\u308b\u306e\u3068\u304b\u3081\u3093\u3069\u304f\u3055\u3044\u306e\u3067\u304a\u624b\u8efd\u306b\u3044\u304d\u305f\u3044\uff0e\n\n|Before      |After      |\n|------------|-----------|\n|![after.png](https://qiita-image-store.s3.amazonaws.com/0/52956/d60e83a5-43a4-b798-ae0a-dfd87e4bec46.png)|![before.png](https://qiita-image-store.s3.amazonaws.com/0/52956/f542beb2-1712-695e-a2e0-430f96b39705.png)\n|\n\n\u2191\u6211\u304c\u5bb6\u306e\u30cf\u30e0\u30b9\u30bf\u30fc\u30b1\u30fc\u30b8\n\n# Code\n\n```cpp\n#include \"stdafx.h\"\n#include <Leap.h>\n#include <opencv2\\opencv.hpp>\n\ncv::Mat warp(Leap::Image image) {\n\tcv::Mat_<cv::Vec3b> out(cv::Size(640, 480));\n\tconst cv::Mat_<unsigned char> cvImage = cv::Mat(image.height(), image.width(), CV_8UC1, image.dataPointer());\n\n\tout.forEach([&](cv::Vec3b& pixel, const int pos[])-> void {\n\t\tfloat y = (float)pos[0] / out.rows;\n\t\tfloat x = (float)(pos[1] - 120) / out.rows;\n\n\t\tconst Leap::Vector v(\n\t\t\t(x - image.rayOffsetX()) / image.rayScaleX() / 4 * 2,\n\t\t\t// \u516c\u5f0f\u30b5\u30a4\u30c8\u3067\u306f tan\u03b8 = 4 \u307e\u3067\u304c\u7bc4\u56f2\u3063\u3066\u8a00\u3063\u3066\u305f\u3051\u3069\uff0c\u305d\u3093\u306a\u306b\u7121\u3044\u3068\u601d\u3046\uff0e\n\t\t\t(y - image.rayOffsetY()) / image.rayScaleY() / 4 * 2,\n\t\t\t0);\n\n\t\tconst auto warped = image.warp(v);\n\n\t\tif (warped.x > 0 && warped.x < (cvImage.cols - 1)\n\t\t\t&& warped.y > 0 && warped.y < (cvImage.rows - 1)) {\n\t\t\t// std::cout << warped << std::endl;\n\t\t\tpixel = cv::Vec3b::all(cvImage(warped.y, warped.x));\n\t\t}\n\t\telse {\n\t\t\tpixel = cv::Vec3b(0, 255, 0);\n\t\t}\n\t});\n\n\treturn out;\n}\n\nint main()\n{\n\tLeap::Controller controller;\n\tcontroller.setPolicy(Leap::Controller::POLICY_IMAGES);\n\tcontroller.setPolicy(Leap::Controller::POLICY_BACKGROUND_FRAMES);\n\n\twhile (cv::waitKey(1) != 'q') {\n\t\tconst auto frame = controller.frame();\n\t\tif (!frame.isValid()) {\n\t\t\tstd::cout << \"Frame is Invalid\" << std::endl;\n\t\t\tcontinue;\n\t\t}\n\n\t\tconst auto imageList = frame.images();\n\n\t\tif (imageList.isEmpty()) {\n\t\t\tstd::cout << \"imageList.isEmpty()\" << std::endl;\n\t\t\tcontinue;\n\t\t}\n\n\t\tconst auto imageL = warp(imageList[0]);\n\t\tcv::imshow(\"imageL\", imageL);\n\t}\n\treturn 0;\n}\n\n```\n\nDepth Map \u304c\u6b32\u3057\u3044\u306a\u3089 Intel RealSence \u306e\u307b\u3046\u304c\u3044\u3044\u3067\u3059\u306d\u2026\u2026\n"}