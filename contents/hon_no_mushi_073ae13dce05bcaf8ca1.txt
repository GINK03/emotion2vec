{"tags": ["libjpeg", "OpenCV", "jpeg"], "context": "OpenCV\u3067JPEG\u306e\u81ea\u52d5\u56de\u8ee2\u3067\u304d\u308b\u306e\u304b\u3001\u3068\u3044\u3046\u5bbf\u984c\u304c\u3067\u305f\u306e\u3067\u3001\u56de\u7b54\u3092\u3002\u3042\u3001\u5927\u90e8\u5206\u306flibjpeg\u306e\u30de\u30af\u30ed\u4f7f\u3063\u3066\u3044\u307e\u3059\u306e\u3067\u306e\u3067\u3002\n\u4f7f\u3044\u65b9\u306f\u3001\nimread(filename , 128 + 1);\u3068\u304bimread(filename , 128 + 3);\u3067\u3059\u306d\u3002\nflags\u306b-1\u3092\u6307\u5b9a\u3059\u308b\u4e8b\u3082\u3067\u304d\u308b\u306f\u305a\u3067\u3059\u304c\u3001\u307e\u3042JPEG\u753b\u50cf\u3060\u304b\u3089\u6c17\u306b\u3057\u306a\u3044\uff08PNG\u753b\u50cf\u306a\u3089\u3070\u900f\u904e\u30c1\u30e3\u30cd\u30eb\u3082\u8aad\u3081\u308b\u306f\u305a\uff09\u3002\n\u3042\u3068\u306f90\u5ea6\u5358\u4f4d\u306e\u56de\u8ee2\u304c\u3082\u3063\u3068\u901f\u3044\u30ed\u30b8\u30c3\u30af\u306b\u306a\u3063\u3066\u3044\u308c\u3070\u306a\u3042\u2026\u2026\u3068\u5606\u304f\u3070\u304b\u308a\u3067\u3059\u3002\n\npatch.patch\nanobiidae@anobiidae-virtual-machine:~/opencv2$ diff opencv-2.4.11/modules/highgui/src opencv-2.4.11.auto/modules/highgui/src/ -c\n\u5171\u901a\u306e\u30b5\u30d6\u30c7\u30a3\u30ec\u30af\u30c8\u30ea\u30fc: opencv-2.4.11/modules/highgui/src/files_Qt \u3068 opencv-2.4.11.auto/modules/highgui/src/files_Qt\ndiff -c opencv-2.4.11/modules/highgui/src/grfmt_jpeg.cpp opencv-2.4.11.auto/modules/highgui/src/grfmt_jpeg.cpp\n*** opencv-2.4.11/modules/highgui/src/grfmt_jpeg.cpp    2015-02-25 21:10:31.000000000 +0900\n--- opencv-2.4.11.auto/modules/highgui/src/grfmt_jpeg.cpp   2015-08-13 08:32:11.492022640 +0900\n***************\n*** 102,107 ****\n--- 102,108 ----\n      jpeg_decompress_struct cinfo; // IJG JPEG codec structure\n      JpegErrorMgr jerr; // error processing manager state\n      JpegSource source; // memory buffer source\n+     int m_orientation; // Orientation\n  };\n\n  /////////////////////// Error processing /////////////////////\n***************\n*** 167,172 ****\n--- 168,342 ----\n      longjmp( err_mgr->setjmp_buffer, 1 );\n  }\n\n+ /*\n+  * Parse the DHT table.\n+  * This macro comes from jpeg9a (jdmarker.c).\n+  */\n+ \n+ #define MAKESTMT(stuff)       do { stuff } while (0)\n+ /*\n+  * Macros for fetching data from the data source module.\n+  *\n+  * At all times, cinfo->src->next_input_byte and ->bytes_in_buffer reflect\n+  * the current restart point; we update them only when we have reached a\n+  * suitable place to restart if a suspension occurs.\n+  */\n+ \n+ /* Declare and initialize local copies of input pointer/count */\n+ #define INPUT_VARS(cinfo)  \\\n+   struct jpeg_source_mgr * datasrc = (cinfo)->src;  \\\n+   const JOCTET * next_input_byte = datasrc->next_input_byte;  \\\n+   size_t bytes_in_buffer = datasrc->bytes_in_buffer\n+ \n+ /* Unload the local copies --- do this only at a restart boundary */\n+ #define INPUT_SYNC(cinfo)  \\\n+   ( datasrc->next_input_byte = next_input_byte,  \\\n+     datasrc->bytes_in_buffer = bytes_in_buffer )\n+ \n+ /* Reload the local copies --- used only in MAKE_BYTE_AVAIL */\n+ #define INPUT_RELOAD(cinfo)  \\\n+   ( next_input_byte = datasrc->next_input_byte,  \\\n+     bytes_in_buffer = datasrc->bytes_in_buffer )\n+ \n+ /* Internal macro for INPUT_BYTE and INPUT_2BYTES: make a byte available.\n+  * Note we do *not* do INPUT_SYNC before calling fill_input_buffer,\n+  * but we must reload the local copies after a successful fill.\n+  */\n+ #define MAKE_BYTE_AVAIL(cinfo,action)  \\\n+   if (bytes_in_buffer == 0) {  \\\n+     if (! (*datasrc->fill_input_buffer) (cinfo))  \\\n+       { action; }  \\\n+     INPUT_RELOAD(cinfo);  \\\n+   }\n+ \n+ /* Read a byte into variable V.\n+  * If must suspend, take the specified action (typically \"return FALSE\").\n+  */\n+ #define INPUT_BYTE(cinfo,V,action)  \\\n+   MAKESTMT( MAKE_BYTE_AVAIL(cinfo,action); \\\n+         bytes_in_buffer--; \\\n+         V = GETJOCTET(*next_input_byte++); )\n+ \n+ /* As above, but read two bytes interpreted as an unsigned 16-bit integer.\n+  * V should be declared unsigned int or perhaps INT32.\n+  */\n+ #define INPUT_2BYTES(cinfo,V,action)  \\\n+   MAKESTMT( MAKE_BYTE_AVAIL(cinfo,action); \\\n+         bytes_in_buffer--; \\\n+         V = ((unsigned int) GETJOCTET(*next_input_byte++)) << 8; \\\n+         MAKE_BYTE_AVAIL(cinfo,action); \\\n+         bytes_in_buffer--; \\\n+         V += GETJOCTET(*next_input_byte++); )\n+ \n+ /* As above, but read four bytes interpreted as an unsigned 32-bit integer.\n+  * V should be declared unsigned int.\n+  */\n+ #define INPUT_4BYTES(cinfo,V,action)  \\\n+   MAKESTMT( MAKE_BYTE_AVAIL(cinfo,action); \\\n+         bytes_in_buffer--; \\\n+         V = ((unsigned int) GETJOCTET(*next_input_byte++)) << 24; \\\n+         MAKE_BYTE_AVAIL(cinfo,action); \\\n+         bytes_in_buffer--; \\\n+         V += (GETJOCTET(*next_input_byte++)) << 16; \\\n+         MAKE_BYTE_AVAIL(cinfo,action); \\\n+         bytes_in_buffer--; \\\n+         V += (GETJOCTET(*next_input_byte++)) << 8; \\\n+         MAKE_BYTE_AVAIL(cinfo,action); \\\n+         bytes_in_buffer--; \\\n+         V += (GETJOCTET(*next_input_byte++)); )\n+ /*\n+  * Routines for processing APPn and COM markers.\n+  * These are either saved in memory or discarded, per application request.\n+  * APP0 and APP14 are specially checked to see if they are\n+  * JFIF and Adobe markers, respectively.\n+  */\n+ \n+ #define APP1_DATA_LEN 10  /* Length of interesting data in APP14 */\n+ \n+ #define SWAP_2BYTES(V) \\\n+   { V = (!isLE)?V:( ((V >> 8) & 0xff) | (V << 8 ) ); }\n+ #define SWAP_4BYTES(V) \\\n+   { V = (!isLE)?V:( ((V >> 24) & 0xff) | ((V >> 8) & 0xff00) | ((V << 8) & 0xff0000) | (V << 24 ) ); }\n+ \n+ METHODDEF(int)\n+ proc_exif(j_decompress_ptr cinfo)\n+ {\n+   bool isLE = false;\n+   INT32 length;\n+   JOCTET b[APP1_DATA_LEN];\n+   unsigned int i, numtoread;\n+   INPUT_VARS(cinfo);\n+ \n+   INPUT_2BYTES(cinfo, length, return FALSE);\n+   length -= 2;\n+ \n+   /* get the interesting part of the marker data */\n+   if (length >= APP1_DATA_LEN)\n+     numtoread = APP1_DATA_LEN;\n+   else if (length > 0)\n+     numtoread = (unsigned int) length;\n+   else\n+     numtoread = 0;\n+   for (i = 0; i < numtoread; i++)\n+     INPUT_BYTE(cinfo, b[i], return FALSE);\n+   length -= numtoread;\n+ \n+   if ( memcmp(b,\"Exif\\0\\0\",6) != 0 ) {\n+     printf(\"Exif tag is not alive\\n\");\n+     goto exit;\n+   }\n+ \n+   if ( memcmp(b+6,\"MM\",2) == 0 ) {\n+     isLE = false;\n+   }else{\n+     printf(\"Endian is not MM\\n\");\n+     goto exit;\n+   }\n+ \n+   unsigned int ifd_offset;\n+  INPUT_4BYTES(cinfo, ifd_offset, return FALSE);\n+  SWAP_4BYTES(ifd_offset);\n+  length -= 4;\n+  if(ifd_offset != 8 ) {\n+    printf(\"IFD should be next to header\");\n+    goto exit;\n+  }\n+ \n+  {\n+    int tag_num;\n+    INPUT_2BYTES(cinfo, tag_num, return FALSE ); SWAP_2BYTES(tag_num);\n+    length-=2;\n+    for(; tag_num > 0 ; tag_num -- )\n+    {\n+      int tag_tag, tag_type, tag_count;\n+      int tag_offset, tag_dmy; \n+ \n+      INPUT_2BYTES(cinfo, tag_tag,    return FALSE ); SWAP_2BYTES(tag_tag);\n+      INPUT_2BYTES(cinfo, tag_type,   return FALSE ); SWAP_2BYTES(tag_type);\n+      INPUT_4BYTES(cinfo, tag_count,  return FALSE ); SWAP_4BYTES(tag_count);\n+      if(tag_type == 0x03 /* short */)\n+      {\n+        INPUT_2BYTES(cinfo, tag_offset, return FALSE ); SWAP_2BYTES(tag_offset);\n+        INPUT_2BYTES(cinfo, tag_dmy,    return FALSE );\n+      }else{\n+        INPUT_4BYTES(cinfo, tag_offset, return FALSE ); SWAP_4BYTES(tag_offset);\n+      }\n+      if(tag_tag == 274 /* Orientation */ ){\n+         JpegState* state = (JpegState*)cinfo; // HACKME!\n+         state->m_orientation = tag_offset;\n+      }\n+      length -= 12;\n+    }\n+  }\n+ \n+ exit:\n+   /* skip any remaining data -- could be lots */\n+   INPUT_SYNC(cinfo);\n+   if (length > 0)\n+     (*cinfo->src->skip_input_data) (cinfo, (long) length);\n+ \n+   return TRUE;\n+ }\n\n  /////////////////////// JpegDecoder ///////////////////\n\n***************\n*** 220,225 ****\n--- 390,396 ----\n      m_state = state;\n      state->cinfo.err = jpeg_std_error(&state->jerr.pub);\n      state->jerr.pub.error_exit = error_exit;\n+     state->m_orientation = 1; // default;\n\n      if( setjmp( state->jerr.setjmp_buffer ) == 0 )\n      {\n***************\n*** 240,250 ****\n--- 411,423 ----\n\n          if (state->cinfo.src != 0)\n          {\n+                   jpeg_set_marker_processor( &state->cinfo, JPEG_APP0+1, proc_exif );\n              jpeg_read_header( &state->cinfo, TRUE );\n\n              m_width = state->cinfo.image_width;\n              m_height = state->cinfo.image_height;\n              m_type = state->cinfo.num_components > 1 ? CV_8UC3 : CV_8UC1;\n+             m_orientation = state->m_orientation;\n              result = true;\n          }\n      }\n***************\n*** 450,455 ****\n--- 623,630 ----\n                                                JPOOL_IMAGE, m_width*4, 1 );\n\n              uchar* data = img.data;\n+             if(*data == 0){ m_orientation = 1; }\n+ \n              for( ; m_height--; data += step )\n              {\n                  jpeg_read_scanlines( cinfo, buffer, 1 );\n***************\n*** 470,475 ****\n--- 645,678 ----\n              }\n              result = true;\n              jpeg_finish_decompress( cinfo );\n+ \n+             {\n+               struct {\n+                 bool isFlip;\n+                 int  rotateAngle;\n+               } tLUT[] = {\n+                 {false,0},\n+                 {false,  0},{true ,  0},{false,180},{true ,180},\n+                 {true , 90},{false, 90},{true ,270},{false ,270},\n+               };\n+ \n+               printf(\"FLAG=%d\\n\", m_orientation );\n+ \n+               if(tLUT[m_orientation].rotateAngle == 90){\n+                 transpose(img,img);\n+                 flip(img,img, 1);\n+               }\n+               if(tLUT[m_orientation].rotateAngle == 180){\n+                 flip(img,img,-1);\n+               }\n+               if(tLUT[m_orientation].rotateAngle == 270){\n+                 transpose(img, img);\n+                 flip(img,img,0);\n+               }\n+               if(tLUT[m_orientation].isFlip == true ){\n+                 flip(img,img, 1);\n+               }\n+             }\n          }\n      }\n\ndiff -c opencv-2.4.11/modules/highgui/src/grfmt_jpeg.hpp opencv-2.4.11.auto/modules/highgui/src/grfmt_jpeg.hpp\n*** opencv-2.4.11/modules/highgui/src/grfmt_jpeg.hpp    2015-02-25 21:10:31.000000000 +0900\n--- opencv-2.4.11.auto/modules/highgui/src/grfmt_jpeg.hpp   2015-08-13 07:23:17.984141888 +0900\n***************\n*** 67,75 ****\n      ImageDecoder newDecoder() const;\n\n  protected:\n- \n      FILE* m_f;\n      void* m_state;\n  };\n\n\n--- 67,75 ----\n      ImageDecoder newDecoder() const;\n\n  protected:\n      FILE* m_f;\n      void* m_state;\n+     int   m_orientation;\n  };\n\n\ndiff -c opencv-2.4.11/modules/highgui/src/loadsave.cpp opencv-2.4.11.auto/modules/highgui/src/loadsave.cpp\n*** opencv-2.4.11/modules/highgui/src/loadsave.cpp  2015-02-25 21:10:31.000000000 +0900\n--- opencv-2.4.11.auto/modules/highgui/src/loadsave.cpp 2015-08-13 08:29:48.204026773 +0900\n***************\n*** 242,247 ****\n--- 242,250 ----\n          temp = cvarrToMat(image);\n      }\n\n+     // Auto-rotation flag is stored at first bytes\n+     data->at<unsigned char>(0,0) = flags >> 7; \n+ \n      if( !decoder->readData( *data ))\n      {\n          cvReleaseImage( &image );\n\n\nOpenCV\u3067JPEG\u306e\u81ea\u52d5\u56de\u8ee2\u3067\u304d\u308b\u306e\u304b\u3001\u3068\u3044\u3046\u5bbf\u984c\u304c\u3067\u305f\u306e\u3067\u3001\u56de\u7b54\u3092\u3002\u3042\u3001\u5927\u90e8\u5206\u306flibjpeg\u306e\u30de\u30af\u30ed\u4f7f\u3063\u3066\u3044\u307e\u3059\u306e\u3067\u306e\u3067\u3002\n\n\u4f7f\u3044\u65b9\u306f\u3001\n`imread(filename , 128 + 1);`\u3068\u304b`imread(filename , 128 + 3);`\u3067\u3059\u306d\u3002\n\nflags\u306b-1\u3092\u6307\u5b9a\u3059\u308b\u4e8b\u3082\u3067\u304d\u308b\u306f\u305a\u3067\u3059\u304c\u3001\u307e\u3042JPEG\u753b\u50cf\u3060\u304b\u3089\u6c17\u306b\u3057\u306a\u3044\uff08PNG\u753b\u50cf\u306a\u3089\u3070\u900f\u904e\u30c1\u30e3\u30cd\u30eb\u3082\u8aad\u3081\u308b\u306f\u305a\uff09\u3002\n\n\u3042\u3068\u306f90\u5ea6\u5358\u4f4d\u306e\u56de\u8ee2\u304c\u3082\u3063\u3068\u901f\u3044\u30ed\u30b8\u30c3\u30af\u306b\u306a\u3063\u3066\u3044\u308c\u3070\u306a\u3042\u2026\u2026\u3068\u5606\u304f\u3070\u304b\u308a\u3067\u3059\u3002\n\n```c:patch.patch\nanobiidae@anobiidae-virtual-machine:~/opencv2$ diff opencv-2.4.11/modules/highgui/src opencv-2.4.11.auto/modules/highgui/src/ -c\n\u5171\u901a\u306e\u30b5\u30d6\u30c7\u30a3\u30ec\u30af\u30c8\u30ea\u30fc: opencv-2.4.11/modules/highgui/src/files_Qt \u3068 opencv-2.4.11.auto/modules/highgui/src/files_Qt\ndiff -c opencv-2.4.11/modules/highgui/src/grfmt_jpeg.cpp opencv-2.4.11.auto/modules/highgui/src/grfmt_jpeg.cpp\n*** opencv-2.4.11/modules/highgui/src/grfmt_jpeg.cpp\t2015-02-25 21:10:31.000000000 +0900\n--- opencv-2.4.11.auto/modules/highgui/src/grfmt_jpeg.cpp\t2015-08-13 08:32:11.492022640 +0900\n***************\n*** 102,107 ****\n--- 102,108 ----\n      jpeg_decompress_struct cinfo; // IJG JPEG codec structure\n      JpegErrorMgr jerr; // error processing manager state\n      JpegSource source; // memory buffer source\n+     int m_orientation; // Orientation\n  };\n  \n  /////////////////////// Error processing /////////////////////\n***************\n*** 167,172 ****\n--- 168,342 ----\n      longjmp( err_mgr->setjmp_buffer, 1 );\n  }\n  \n+ /*\n+  * Parse the DHT table.\n+  * This macro comes from jpeg9a (jdmarker.c).\n+  */\n+ \n+ #define MAKESTMT(stuff)\t\tdo { stuff } while (0)\n+ /*\n+  * Macros for fetching data from the data source module.\n+  *\n+  * At all times, cinfo->src->next_input_byte and ->bytes_in_buffer reflect\n+  * the current restart point; we update them only when we have reached a\n+  * suitable place to restart if a suspension occurs.\n+  */\n+ \n+ /* Declare and initialize local copies of input pointer/count */\n+ #define INPUT_VARS(cinfo)  \\\n+ \tstruct jpeg_source_mgr * datasrc = (cinfo)->src;  \\\n+ \tconst JOCTET * next_input_byte = datasrc->next_input_byte;  \\\n+ \tsize_t bytes_in_buffer = datasrc->bytes_in_buffer\n+ \n+ /* Unload the local copies --- do this only at a restart boundary */\n+ #define INPUT_SYNC(cinfo)  \\\n+ \t( datasrc->next_input_byte = next_input_byte,  \\\n+ \t  datasrc->bytes_in_buffer = bytes_in_buffer )\n+ \n+ /* Reload the local copies --- used only in MAKE_BYTE_AVAIL */\n+ #define INPUT_RELOAD(cinfo)  \\\n+ \t( next_input_byte = datasrc->next_input_byte,  \\\n+ \t  bytes_in_buffer = datasrc->bytes_in_buffer )\n+ \n+ /* Internal macro for INPUT_BYTE and INPUT_2BYTES: make a byte available.\n+  * Note we do *not* do INPUT_SYNC before calling fill_input_buffer,\n+  * but we must reload the local copies after a successful fill.\n+  */\n+ #define MAKE_BYTE_AVAIL(cinfo,action)  \\\n+ \tif (bytes_in_buffer == 0) {  \\\n+ \t  if (! (*datasrc->fill_input_buffer) (cinfo))  \\\n+ \t    { action; }  \\\n+ \t  INPUT_RELOAD(cinfo);  \\\n+ \t}\n+ \n+ /* Read a byte into variable V.\n+  * If must suspend, take the specified action (typically \"return FALSE\").\n+  */\n+ #define INPUT_BYTE(cinfo,V,action)  \\\n+ \tMAKESTMT( MAKE_BYTE_AVAIL(cinfo,action); \\\n+ \t\t  bytes_in_buffer--; \\\n+ \t\t  V = GETJOCTET(*next_input_byte++); )\n+ \n+ /* As above, but read two bytes interpreted as an unsigned 16-bit integer.\n+  * V should be declared unsigned int or perhaps INT32.\n+  */\n+ #define INPUT_2BYTES(cinfo,V,action)  \\\n+ \tMAKESTMT( MAKE_BYTE_AVAIL(cinfo,action); \\\n+ \t\t  bytes_in_buffer--; \\\n+ \t\t  V = ((unsigned int) GETJOCTET(*next_input_byte++)) << 8; \\\n+ \t\t  MAKE_BYTE_AVAIL(cinfo,action); \\\n+ \t\t  bytes_in_buffer--; \\\n+ \t\t  V += GETJOCTET(*next_input_byte++); )\n+ \n+ /* As above, but read four bytes interpreted as an unsigned 32-bit integer.\n+  * V should be declared unsigned int.\n+  */\n+ #define INPUT_4BYTES(cinfo,V,action)  \\\n+ \tMAKESTMT( MAKE_BYTE_AVAIL(cinfo,action); \\\n+ \t\t  bytes_in_buffer--; \\\n+ \t\t  V = ((unsigned int) GETJOCTET(*next_input_byte++)) << 24; \\\n+ \t\t  MAKE_BYTE_AVAIL(cinfo,action); \\\n+ \t\t  bytes_in_buffer--; \\\n+ \t\t  V += (GETJOCTET(*next_input_byte++)) << 16; \\\n+ \t\t  MAKE_BYTE_AVAIL(cinfo,action); \\\n+ \t\t  bytes_in_buffer--; \\\n+ \t\t  V += (GETJOCTET(*next_input_byte++)) << 8; \\\n+ \t\t  MAKE_BYTE_AVAIL(cinfo,action); \\\n+ \t\t  bytes_in_buffer--; \\\n+ \t\t  V += (GETJOCTET(*next_input_byte++)); )\n+ /*\n+  * Routines for processing APPn and COM markers.\n+  * These are either saved in memory or discarded, per application request.\n+  * APP0 and APP14 are specially checked to see if they are\n+  * JFIF and Adobe markers, respectively.\n+  */\n+ \n+ #define APP1_DATA_LEN\t10\t/* Length of interesting data in APP14 */\n+ \n+ #define SWAP_2BYTES(V) \\\n+ \t{ V = (!isLE)?V:( ((V >> 8) & 0xff) | (V << 8 ) ); }\n+ #define SWAP_4BYTES(V) \\\n+ \t{ V = (!isLE)?V:( ((V >> 24) & 0xff) | ((V >> 8) & 0xff00) | ((V << 8) & 0xff0000) | (V << 24 ) ); }\n+ \n+ METHODDEF(int)\n+ proc_exif(j_decompress_ptr cinfo)\n+ {\n+   bool isLE = false;\n+   INT32 length;\n+   JOCTET b[APP1_DATA_LEN];\n+   unsigned int i, numtoread;\n+   INPUT_VARS(cinfo);\n+ \n+   INPUT_2BYTES(cinfo, length, return FALSE);\n+   length -= 2;\n+ \n+   /* get the interesting part of the marker data */\n+   if (length >= APP1_DATA_LEN)\n+     numtoread = APP1_DATA_LEN;\n+   else if (length > 0)\n+     numtoread = (unsigned int) length;\n+   else\n+     numtoread = 0;\n+   for (i = 0; i < numtoread; i++)\n+     INPUT_BYTE(cinfo, b[i], return FALSE);\n+   length -= numtoread;\n+ \n+   if ( memcmp(b,\"Exif\\0\\0\",6) != 0 ) {\n+     printf(\"Exif tag is not alive\\n\");\n+     goto exit;\n+   }\n+ \n+   if ( memcmp(b+6,\"MM\",2) == 0 ) {\n+     isLE = false;\n+   }else{\n+     printf(\"Endian is not MM\\n\");\n+     goto exit;\n+   }\n+ \n+  \tunsigned int ifd_offset;\n+  INPUT_4BYTES(cinfo, ifd_offset, return FALSE);\n+  SWAP_4BYTES(ifd_offset);\n+  length -= 4;\n+  if(ifd_offset != 8 ) {\n+    printf(\"IFD should be next to header\");\n+    goto exit;\n+  }\n+ \n+  {\n+    int tag_num;\n+    INPUT_2BYTES(cinfo, tag_num, return FALSE ); SWAP_2BYTES(tag_num);\n+    length-=2;\n+    for(; tag_num > 0 ; tag_num -- )\n+    {\n+      int tag_tag, tag_type, tag_count;\n+      int tag_offset, tag_dmy; \n+ \n+      INPUT_2BYTES(cinfo, tag_tag,    return FALSE ); SWAP_2BYTES(tag_tag);\n+      INPUT_2BYTES(cinfo, tag_type,   return FALSE ); SWAP_2BYTES(tag_type);\n+      INPUT_4BYTES(cinfo, tag_count,  return FALSE ); SWAP_4BYTES(tag_count);\n+      if(tag_type == 0x03 /* short */)\n+      {\n+        INPUT_2BYTES(cinfo, tag_offset, return FALSE ); SWAP_2BYTES(tag_offset);\n+        INPUT_2BYTES(cinfo, tag_dmy,    return FALSE );\n+      }else{\n+        INPUT_4BYTES(cinfo, tag_offset, return FALSE ); SWAP_4BYTES(tag_offset);\n+      }\n+      if(tag_tag == 274 /* Orientation */ ){\n+         JpegState* state = (JpegState*)cinfo; // HACKME!\n+         state->m_orientation = tag_offset;\n+      }\n+      length -= 12;\n+    }\n+  }\n+ \n+ exit:\n+   /* skip any remaining data -- could be lots */\n+   INPUT_SYNC(cinfo);\n+   if (length > 0)\n+     (*cinfo->src->skip_input_data) (cinfo, (long) length);\n+ \n+   return TRUE;\n+ }\n  \n  /////////////////////// JpegDecoder ///////////////////\n  \n***************\n*** 220,225 ****\n--- 390,396 ----\n      m_state = state;\n      state->cinfo.err = jpeg_std_error(&state->jerr.pub);\n      state->jerr.pub.error_exit = error_exit;\n+     state->m_orientation = 1; // default;\n  \n      if( setjmp( state->jerr.setjmp_buffer ) == 0 )\n      {\n***************\n*** 240,250 ****\n--- 411,423 ----\n  \n          if (state->cinfo.src != 0)\n          {\n+ \t\t\t\t    jpeg_set_marker_processor( &state->cinfo, JPEG_APP0+1, proc_exif );\n              jpeg_read_header( &state->cinfo, TRUE );\n  \n              m_width = state->cinfo.image_width;\n              m_height = state->cinfo.image_height;\n              m_type = state->cinfo.num_components > 1 ? CV_8UC3 : CV_8UC1;\n+             m_orientation = state->m_orientation;\n              result = true;\n          }\n      }\n***************\n*** 450,455 ****\n--- 623,630 ----\n                                                JPOOL_IMAGE, m_width*4, 1 );\n  \n              uchar* data = img.data;\n+             if(*data == 0){ m_orientation = 1; }\n+ \n              for( ; m_height--; data += step )\n              {\n                  jpeg_read_scanlines( cinfo, buffer, 1 );\n***************\n*** 470,475 ****\n--- 645,678 ----\n              }\n              result = true;\n              jpeg_finish_decompress( cinfo );\n+ \n+             {\n+               struct {\n+                 bool isFlip;\n+                 int  rotateAngle;\n+               } tLUT[] = {\n+                 {false,0},\n+                 {false,  0},{true ,  0},{false,180},{true ,180},\n+                 {true , 90},{false, 90},{true ,270},{false ,270},\n+               };\n+ \n+               printf(\"FLAG=%d\\n\", m_orientation );\n+ \n+               if(tLUT[m_orientation].rotateAngle == 90){\n+                 transpose(img,img);\n+                 flip(img,img, 1);\n+               }\n+               if(tLUT[m_orientation].rotateAngle == 180){\n+                 flip(img,img,-1);\n+               }\n+               if(tLUT[m_orientation].rotateAngle == 270){\n+                 transpose(img, img);\n+                 flip(img,img,0);\n+               }\n+               if(tLUT[m_orientation].isFlip == true ){\n+                 flip(img,img, 1);\n+               }\n+             }\n          }\n      }\n  \ndiff -c opencv-2.4.11/modules/highgui/src/grfmt_jpeg.hpp opencv-2.4.11.auto/modules/highgui/src/grfmt_jpeg.hpp\n*** opencv-2.4.11/modules/highgui/src/grfmt_jpeg.hpp\t2015-02-25 21:10:31.000000000 +0900\n--- opencv-2.4.11.auto/modules/highgui/src/grfmt_jpeg.hpp\t2015-08-13 07:23:17.984141888 +0900\n***************\n*** 67,75 ****\n      ImageDecoder newDecoder() const;\n  \n  protected:\n- \n      FILE* m_f;\n      void* m_state;\n  };\n  \n  \n--- 67,75 ----\n      ImageDecoder newDecoder() const;\n  \n  protected:\n      FILE* m_f;\n      void* m_state;\n+     int   m_orientation;\n  };\n  \n  \ndiff -c opencv-2.4.11/modules/highgui/src/loadsave.cpp opencv-2.4.11.auto/modules/highgui/src/loadsave.cpp\n*** opencv-2.4.11/modules/highgui/src/loadsave.cpp\t2015-02-25 21:10:31.000000000 +0900\n--- opencv-2.4.11.auto/modules/highgui/src/loadsave.cpp\t2015-08-13 08:29:48.204026773 +0900\n***************\n*** 242,247 ****\n--- 242,250 ----\n          temp = cvarrToMat(image);\n      }\n  \n+     // Auto-rotation flag is stored at first bytes\n+     data->at<unsigned char>(0,0) = flags >> 7; \n+ \n      if( !decoder->readData( *data ))\n      {\n          cvReleaseImage( &image );\n```\n"}