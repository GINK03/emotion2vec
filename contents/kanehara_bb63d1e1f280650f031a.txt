{"context": "\n\nRabbitMQ \u30c1\u30e5\u30fc\u30c8\u30ea\u30a2\u30eb\uff14 C\u30d0\u30fc\u30b8\u30e7\u30f3\nRabbitMQ \u30c1\u30e5\u30fc\u30c8\u30ea\u30a2\u30eb https://www.rabbitmq.com/getstarted.html \u306e\u30d1\u30fc\u30c8\uff14 Routing \u306ePython\u7248\u306e\u30d7\u30ed\u30b0\u30e9\u30e0\u3092C\u30e9\u30a4\u30d6\u30e9\u30ea https://github.com/alanxz/rabbitmq-c \u3092\u4f7f\u3063\u3066\u66f8\u3044\u305f\u3082\u306e\u3067\u3059\u3002RabbitMQ\u306e\u8aac\u660e\u7b49\u306f\u3001\u5143\u306e\u30c1\u30e5\u30fc\u30c8\u30ea\u30a2\u30eb\u3092\u53c2\u7167\u3057\u3066\u304f\u3060\u3055\u3044\u3002\n\n\u9001\u4fe1\namqp_basic_publish()\u3067\u3001\u30e1\u30c3\u30bb\u30fc\u30b8\u3092\u30d1\u30d6\u30ea\u30c3\u30b7\u30e5\u3059\u308b\u969b\u306b\u3001routing_key\u30d1\u30e9\u30e1\u30fc\u30bf\u3092\u8a2d\u5b9a\u3059\u308b\u3002\n\u6700\u7d42\u7684\u306a\u30d7\u30ed\u30b0\u30e9\u30e0\u306f\u3001\u4ee5\u4e0b\u306e\u3068\u304a\u308a\u3002\n\nemit.cc\n#include <stdlib.h>\n#include <stdio.h>\n#include <string>\n#include <amqp.h>\n#include <amqp_tcp_socket.h>\n#include <amqp_framing.h>\n\nint  main (int argc, char** argv) {\n    std::string  message;\n    std::string  severity;\n    if (argc > 1) {\n        severity.assign (argv[1]);\n    } else {\n        severity.assign (\"info\");\n    }\n    for (int i = 2; i < argc; i ++) {\n        if (i > 2)\n            message.append (1, ' ');\n        message.append (argv[i]);\n    }\n\n    amqp_connection_state_t  conn = amqp_new_connection ();\n\n    amqp_socket_t*  socket = amqp_tcp_socket_new (conn);\n\n    int  rc_sock = amqp_socket_open (socket, \"localhost\", 5672);\n    if (rc_sock != AMQP_STATUS_OK) {\n        fprintf (stderr, \"connection failure.\\n\");\n        exit (1);\n    }\n\n    amqp_rpc_reply_t  rc_login = amqp_login (conn, \"/\", AMQP_DEFAULT_MAX_CHANNELS, AMQP_DEFAULT_FRAME_SIZE, AMQP_DEFAULT_HEARTBEAT, AMQP_SASL_METHOD_PLAIN, \"guest\", \"guest\");\n    if (rc_login.reply_type != AMQP_RESPONSE_NORMAL) {\n        if (rc_login.reply_type == AMQP_RESPONSE_SERVER_EXCEPTION) {\n            if (rc_login.reply.id == AMQP_CONNECTION_CLOSE_METHOD) {\n                amqp_connection_close_t*  m = (amqp_connection_close_t *) rc_login.reply.decoded;\n                fwrite (m->reply_text.bytes, 1, m->reply_text.len, stderr);\n                fprintf (stderr, \"\\n\");\n            }\n        }\n        exit (1);\n    }\n\n    amqp_channel_t  channel = 1;\n    amqp_channel_open_ok_t*  rc_channel = amqp_channel_open (conn, channel);\n\n    amqp_bytes_t  exchange = amqp_cstring_bytes (\"direct_logs\");\n    amqp_bytes_t  exchtype = amqp_cstring_bytes (\"direct\");\n    amqp_exchange_declare_ok_t*  dcok = amqp_exchange_declare (conn, channel, exchange, exchtype, false, false, false, false, amqp_empty_table);\n\n    amqp_bytes_t  bsvr = {severity.length (), (void*)severity.data ()};\n    amqp_bytes_t  bmsg = {message.length (), (void*)message.data ()};\n    int  rc_pub = amqp_basic_publish (conn, channel, exchange, bsvr, false, false, NULL, bmsg);\n\n    amqp_rpc_reply_t  rc_chclose = amqp_channel_close (conn, channel, AMQP_REPLY_SUCCESS);\n    amqp_rpc_reply_t  rc_conclose = amqp_connection_close (conn, AMQP_REPLY_SUCCESS);\n    amqp_destroy_connection (conn);\n\n    return 0;\n}\n\n\n\n\u53d7\u4fe1\namqp_exchange_declare\uff08\uff09\u3067\u3001\u30c0\u30a4\u30ec\u30af\u30c8\u30a8\u30af\u30b9\u30c1\u30a7\u30f3\u30b8\u3092\u4f5c\u6210\u3057\u3001amqp_queue_bind()\u3067\u3001\u30d0\u30a4\u30f3\u30c7\u30a3\u30f3\u30b0\u3092\u8a2d\u5b9a\u3059\u308b\u969b\u306brouting\uff3fkey\u30d1\u30e9\u30e1\u30fc\u30bf\u3092\u6307\u5b9a\u3059\u308b\u3002\n\u6700\u7d42\u7684\u306a\u30d7\u30ed\u30b0\u30e9\u30e0\u306f\u3001\u4ee5\u4e0b\u306e\u3068\u304a\u308a\u3002\n\nlog.cc\n#include <stdlib.h>\n#include <stdio.h>\n#include <amqp_tcp_socket.h>\n#include <amqp.h>\n#include <amqp_framing.h>\n\nvoid  callback (amqp_connection_state_t* conn, amqp_envelope_t* envelope, amqp_bytes_t body) {\n    printf (\" [x] \");\n    fwrite (envelope->routing_key.bytes, 1, envelope->routing_key.len, stdout);\n    printf (\":\");\n    fwrite (body.bytes, 1, body.len, stdout);\n    printf (\"\\n\");\n}\n\nint  main (int argc, char** argv) {\n    if (argc < 2) {\n        fprintf (stderr, \"usage: %s [info] [warning] [error]\\n\", argv[0]);\n        exit (1);\n    }\n\n    amqp_connection_state_t  conn = amqp_new_connection ();\n\n    amqp_socket_t*  socket = amqp_tcp_socket_new (conn);\n\n    int  rc_sock = amqp_socket_open (socket, \"localhost\", 5672);\n    if (rc_sock != AMQP_STATUS_OK) {\n        fprintf (stderr, \"connection failure.\\n\");\n        exit (1);\n    }\n\n    amqp_rpc_reply_t  rc_login = amqp_login (conn, \"/\", AMQP_DEFAULT_MAX_CHANNELS, AMQP_DEFAULT_FRAME_SIZE, AMQP_DEFAULT_HEARTBEAT, AMQP_SASL_METHOD_PLAIN, \"guest\", \"guest\");\n    if (rc_login.reply_type != AMQP_RESPONSE_NORMAL) {\n        if (rc_login.reply_type == AMQP_RESPONSE_SERVER_EXCEPTION) {\n            if (rc_login.reply.id == AMQP_CONNECTION_CLOSE_METHOD) {\n                amqp_connection_close_t*  m = (amqp_connection_close_t *) rc_login.reply.decoded;\n                fwrite (m->reply_text.bytes, 1, m->reply_text.len, stderr);\n                fprintf (stderr, \"\\n\");\n            }\n        }\n        exit (1);\n    }\n\n    amqp_channel_t  channel = 1;\n    amqp_channel_open_ok_t*  rc_channel = amqp_channel_open (conn, channel);\n\n    amqp_bytes_t  exchange = amqp_cstring_bytes (\"direct_logs\");\n    amqp_bytes_t  exchtype = amqp_cstring_bytes (\"direct\");\n    amqp_exchange_declare_ok_t*  rc_exch = amqp_exchange_declare (conn, channel, exchange, exchtype, false, false, false, false, amqp_empty_table);\n\n    amqp_queue_declare_ok_t*  rc_dcl = amqp_queue_declare (conn, channel, amqp_empty_bytes, false, false, true/*exclusive*/, false, amqp_empty_table);\n\n    for (int i = 1; i < argc; i ++) {\n        amqp_bytes_t  routing_key = amqp_cstring_bytes (argv[i]);\n        amqp_queue_bind_ok_t*  rc_bind = amqp_queue_bind (conn, channel, rc_dcl->queue, exchange, routing_key, amqp_empty_table);\n    }\n\n    amqp_basic_consume_ok_t*  rc_con = amqp_basic_consume (conn, channel, rc_dcl->queue, amqp_empty_bytes, false, true/*no ack*/, false, amqp_empty_table);\n\n    printf (\" [*] Waiting for messages. To exit press CTRL+C\\n\");\n\n    while (1) {\n        amqp_maybe_release_buffers (conn);\n        amqp_envelope_t  envelope;\n        amqp_rpc_reply_t  rc_msg = amqp_consume_message (conn, &envelope, NULL, 0);\n        switch (rc_msg.reply_type) {\n        case AMQP_RESPONSE_NORMAL:\n            callback (&conn, &envelope, envelope.message.body);\n            break;\n        case AMQP_RESPONSE_LIBRARY_EXCEPTION:\n            if (rc_msg.library_error == AMQP_STATUS_UNEXPECTED_STATE) {\n                amqp_frame_t  frame;\n                if (amqp_simple_wait_frame (conn, &frame) != AMQP_STATUS_OK) {\n                    goto Ex1;\n                }\n                if (frame.frame_type == AMQP_FRAME_METHOD) {\n                    switch (frame.payload.method.id) {\n                    case AMQP_BASIC_ACK_METHOD:\n                        break;\n                    case AMQP_BASIC_RETURN_METHOD: {\n                        amqp_message_t  message;\n                        amqp_rpc_reply_t  rc_read = amqp_read_message (conn, frame.channel, &message, 0);\n                        if (rc_read.reply_type != AMQP_RESPONSE_NORMAL) {\n                            goto Ex1;\n                        }\n                        amqp_destroy_message (&message);\n                        break;\n                    }\n                    case AMQP_CHANNEL_CLOSE_METHOD:\n                        goto Ex1;\n                    case AMQP_CONNECTION_CLOSE_METHOD:\n                        goto Ex1;\n                    default:\n                        fprintf (stderr ,\"An unexpected method was received %d\\n\", frame.payload.method.id);\n                        goto Ex1;\n                    }\n                }\n            }\n            break;\n        default:;\n        }\n        amqp_destroy_envelope (&envelope);\n    }\n\n Ex1:;\n    amqp_rpc_reply_t  rc_chclose = amqp_channel_close (conn, channel, AMQP_REPLY_SUCCESS);\n    amqp_rpc_reply_t  rc_conclose = amqp_connection_close (conn, AMQP_REPLY_SUCCESS);\n    amqp_destroy_connection (conn);\n\n    return 0;\n}\n\n\n#RabbitMQ \u30c1\u30e5\u30fc\u30c8\u30ea\u30a2\u30eb\uff14 C\u30d0\u30fc\u30b8\u30e7\u30f3\n\nRabbitMQ \u30c1\u30e5\u30fc\u30c8\u30ea\u30a2\u30eb https://www.rabbitmq.com/getstarted.html \u306e\u30d1\u30fc\u30c8\uff14 Routing \u306ePython\u7248\u306e\u30d7\u30ed\u30b0\u30e9\u30e0\u3092C\u30e9\u30a4\u30d6\u30e9\u30ea https://github.com/alanxz/rabbitmq-c \u3092\u4f7f\u3063\u3066\u66f8\u3044\u305f\u3082\u306e\u3067\u3059\u3002RabbitMQ\u306e\u8aac\u660e\u7b49\u306f\u3001\u5143\u306e\u30c1\u30e5\u30fc\u30c8\u30ea\u30a2\u30eb\u3092\u53c2\u7167\u3057\u3066\u304f\u3060\u3055\u3044\u3002\n\n##\u9001\u4fe1\n\namqp_basic_publish()\u3067\u3001\u30e1\u30c3\u30bb\u30fc\u30b8\u3092\u30d1\u30d6\u30ea\u30c3\u30b7\u30e5\u3059\u308b\u969b\u306b\u3001routing_key\u30d1\u30e9\u30e1\u30fc\u30bf\u3092\u8a2d\u5b9a\u3059\u308b\u3002\n\n\u6700\u7d42\u7684\u306a\u30d7\u30ed\u30b0\u30e9\u30e0\u306f\u3001\u4ee5\u4e0b\u306e\u3068\u304a\u308a\u3002\n\n```cpp:emit.cc\n#include <stdlib.h>\n#include <stdio.h>\n#include <string>\n#include <amqp.h>\n#include <amqp_tcp_socket.h>\n#include <amqp_framing.h>\n\nint  main (int argc, char** argv) {\n    std::string  message;\n    std::string  severity;\n    if (argc > 1) {\n        severity.assign (argv[1]);\n    } else {\n        severity.assign (\"info\");\n    }\n    for (int i = 2; i < argc; i ++) {\n        if (i > 2)\n            message.append (1, ' ');\n        message.append (argv[i]);\n    }\n\n    amqp_connection_state_t  conn = amqp_new_connection ();\n\n    amqp_socket_t*  socket = amqp_tcp_socket_new (conn);\n\n    int  rc_sock = amqp_socket_open (socket, \"localhost\", 5672);\n    if (rc_sock != AMQP_STATUS_OK) {\n        fprintf (stderr, \"connection failure.\\n\");\n        exit (1);\n    }\n\n    amqp_rpc_reply_t  rc_login = amqp_login (conn, \"/\", AMQP_DEFAULT_MAX_CHANNELS, AMQP_DEFAULT_FRAME_SIZE, AMQP_DEFAULT_HEARTBEAT, AMQP_SASL_METHOD_PLAIN, \"guest\", \"guest\");\n    if (rc_login.reply_type != AMQP_RESPONSE_NORMAL) {\n        if (rc_login.reply_type == AMQP_RESPONSE_SERVER_EXCEPTION) {\n            if (rc_login.reply.id == AMQP_CONNECTION_CLOSE_METHOD) {\n                amqp_connection_close_t*  m = (amqp_connection_close_t *) rc_login.reply.decoded;\n                fwrite (m->reply_text.bytes, 1, m->reply_text.len, stderr);\n                fprintf (stderr, \"\\n\");\n            }\n        }\n        exit (1);\n    }\n\n    amqp_channel_t  channel = 1;\n    amqp_channel_open_ok_t*  rc_channel = amqp_channel_open (conn, channel);\n\n    amqp_bytes_t  exchange = amqp_cstring_bytes (\"direct_logs\");\n    amqp_bytes_t  exchtype = amqp_cstring_bytes (\"direct\");\n    amqp_exchange_declare_ok_t*  dcok = amqp_exchange_declare (conn, channel, exchange, exchtype, false, false, false, false, amqp_empty_table);\n\n    amqp_bytes_t  bsvr = {severity.length (), (void*)severity.data ()};\n    amqp_bytes_t  bmsg = {message.length (), (void*)message.data ()};\n    int  rc_pub = amqp_basic_publish (conn, channel, exchange, bsvr, false, false, NULL, bmsg);\n\n    amqp_rpc_reply_t  rc_chclose = amqp_channel_close (conn, channel, AMQP_REPLY_SUCCESS);\n    amqp_rpc_reply_t  rc_conclose = amqp_connection_close (conn, AMQP_REPLY_SUCCESS);\n    amqp_destroy_connection (conn);\n\n    return 0;\n}\n```\n\n##\u53d7\u4fe1\n\namqp_exchange_declare\uff08\uff09\u3067\u3001\u30c0\u30a4\u30ec\u30af\u30c8\u30a8\u30af\u30b9\u30c1\u30a7\u30f3\u30b8\u3092\u4f5c\u6210\u3057\u3001amqp_queue_bind()\u3067\u3001\u30d0\u30a4\u30f3\u30c7\u30a3\u30f3\u30b0\u3092\u8a2d\u5b9a\u3059\u308b\u969b\u306brouting\uff3fkey\u30d1\u30e9\u30e1\u30fc\u30bf\u3092\u6307\u5b9a\u3059\u308b\u3002\n\n\u6700\u7d42\u7684\u306a\u30d7\u30ed\u30b0\u30e9\u30e0\u306f\u3001\u4ee5\u4e0b\u306e\u3068\u304a\u308a\u3002\n\n```cpp:log.cc\n#include <stdlib.h>\n#include <stdio.h>\n#include <amqp_tcp_socket.h>\n#include <amqp.h>\n#include <amqp_framing.h>\n\nvoid  callback (amqp_connection_state_t* conn, amqp_envelope_t* envelope, amqp_bytes_t body) {\n    printf (\" [x] \");\n    fwrite (envelope->routing_key.bytes, 1, envelope->routing_key.len, stdout);\n    printf (\":\");\n    fwrite (body.bytes, 1, body.len, stdout);\n    printf (\"\\n\");\n}\n\nint  main (int argc, char** argv) {\n    if (argc < 2) {\n        fprintf (stderr, \"usage: %s [info] [warning] [error]\\n\", argv[0]);\n        exit (1);\n    }\n\n    amqp_connection_state_t  conn = amqp_new_connection ();\n\n    amqp_socket_t*  socket = amqp_tcp_socket_new (conn);\n\n    int  rc_sock = amqp_socket_open (socket, \"localhost\", 5672);\n    if (rc_sock != AMQP_STATUS_OK) {\n        fprintf (stderr, \"connection failure.\\n\");\n        exit (1);\n    }\n\n    amqp_rpc_reply_t  rc_login = amqp_login (conn, \"/\", AMQP_DEFAULT_MAX_CHANNELS, AMQP_DEFAULT_FRAME_SIZE, AMQP_DEFAULT_HEARTBEAT, AMQP_SASL_METHOD_PLAIN, \"guest\", \"guest\");\n    if (rc_login.reply_type != AMQP_RESPONSE_NORMAL) {\n        if (rc_login.reply_type == AMQP_RESPONSE_SERVER_EXCEPTION) {\n            if (rc_login.reply.id == AMQP_CONNECTION_CLOSE_METHOD) {\n                amqp_connection_close_t*  m = (amqp_connection_close_t *) rc_login.reply.decoded;\n                fwrite (m->reply_text.bytes, 1, m->reply_text.len, stderr);\n                fprintf (stderr, \"\\n\");\n            }\n        }\n        exit (1);\n    }\n\n    amqp_channel_t  channel = 1;\n    amqp_channel_open_ok_t*  rc_channel = amqp_channel_open (conn, channel);\n\n    amqp_bytes_t  exchange = amqp_cstring_bytes (\"direct_logs\");\n    amqp_bytes_t  exchtype = amqp_cstring_bytes (\"direct\");\n    amqp_exchange_declare_ok_t*  rc_exch = amqp_exchange_declare (conn, channel, exchange, exchtype, false, false, false, false, amqp_empty_table);\n\n    amqp_queue_declare_ok_t*  rc_dcl = amqp_queue_declare (conn, channel, amqp_empty_bytes, false, false, true/*exclusive*/, false, amqp_empty_table);\n\n    for (int i = 1; i < argc; i ++) {\n        amqp_bytes_t  routing_key = amqp_cstring_bytes (argv[i]);\n        amqp_queue_bind_ok_t*  rc_bind = amqp_queue_bind (conn, channel, rc_dcl->queue, exchange, routing_key, amqp_empty_table);\n    }\n\n    amqp_basic_consume_ok_t*  rc_con = amqp_basic_consume (conn, channel, rc_dcl->queue, amqp_empty_bytes, false, true/*no ack*/, false, amqp_empty_table);\n\n    printf (\" [*] Waiting for messages. To exit press CTRL+C\\n\");\n\n    while (1) {\n        amqp_maybe_release_buffers (conn);\n        amqp_envelope_t  envelope;\n        amqp_rpc_reply_t  rc_msg = amqp_consume_message (conn, &envelope, NULL, 0);\n        switch (rc_msg.reply_type) {\n        case AMQP_RESPONSE_NORMAL:\n            callback (&conn, &envelope, envelope.message.body);\n            break;\n        case AMQP_RESPONSE_LIBRARY_EXCEPTION:\n            if (rc_msg.library_error == AMQP_STATUS_UNEXPECTED_STATE) {\n                amqp_frame_t  frame;\n                if (amqp_simple_wait_frame (conn, &frame) != AMQP_STATUS_OK) {\n                    goto Ex1;\n                }\n                if (frame.frame_type == AMQP_FRAME_METHOD) {\n                    switch (frame.payload.method.id) {\n                    case AMQP_BASIC_ACK_METHOD:\n                        break;\n                    case AMQP_BASIC_RETURN_METHOD: {\n                        amqp_message_t  message;\n                        amqp_rpc_reply_t  rc_read = amqp_read_message (conn, frame.channel, &message, 0);\n                        if (rc_read.reply_type != AMQP_RESPONSE_NORMAL) {\n                            goto Ex1;\n                        }\n                        amqp_destroy_message (&message);\n                        break;\n                    }\n                    case AMQP_CHANNEL_CLOSE_METHOD:\n                        goto Ex1;\n                    case AMQP_CONNECTION_CLOSE_METHOD:\n                        goto Ex1;\n                    default:\n                        fprintf (stderr ,\"An unexpected method was received %d\\n\", frame.payload.method.id);\n                        goto Ex1;\n                    }\n                }\n            }\n            break;\n        default:;\n        }\n        amqp_destroy_envelope (&envelope);\n    }\n\n Ex1:;\n    amqp_rpc_reply_t  rc_chclose = amqp_channel_close (conn, channel, AMQP_REPLY_SUCCESS);\n    amqp_rpc_reply_t  rc_conclose = amqp_connection_close (conn, AMQP_REPLY_SUCCESS);\n    amqp_destroy_connection (conn);\n\n    return 0;\n}\n```\n", "tags": ["RabbitMQ", "C"]}