{"context": " More than 1 year has passed since last update.Phoenix\u306b\u95a2\u3059\u308b\u8cc7\u6599\u306f\u9650\u3089\u308c\u3066\u3044\u308b\u306e\u3067\u65ad\u7247\u7684\u306a\u3082\u306e\u3092\u53ce\u96c6\u3057\u3066\u3044\u308b\uff0e\n\u4eba\u306b\u898b\u305b\u308b\u3082\u306e\u3067\u306f\u306a\u3044\uff0e\u30e1\u30a4\u30f3\u306b\u53c2\u8003\u306b\u3057\u3066\u3044\u308b\u8cc7\u6599\u306f\u4e0b\u306e\u30ea\u30f3\u30af\nhttp://www.phoenixframework.org/ \nphoenix\u3092\u30a4\u30f3\u30b9\u30c8\u30fc\u30eb\u3057\u305f\u5f8c\u306bmy_app\u3068\u3044\u3046\u30d7\u30ed\u30b8\u30a7\u30af\u30c8\u3092~/Projects/\u306b\u4f5c\u308b\n$ mix local.hex\n$ mix archive.install https://github.com/phoenixframework/phoenix/releases/download/v0.13.1/phoenix_new-0.13.1.ez\n$ mix phoenix.new ~/Projects/my_app --no-brunch\n$ cd ~/Projects/my_app\n$ iex -S mix phoenix.server\nRunning Elixir.HelloPhoenix.Router with Cowboy on port 4000\n\n\nLet's say we have a read-only posts resource. We could define it like this.\n\nresources \"posts\", PostController, only: [:index, :show]\n\n\nRunning $ mix phoenix.routes shows that we now only have the routes to the index and show actions defined.\n\npost_path  GET     /posts                         HelloPhoenix.PostsController.index/2\n\npost_path  GET     /posts/:id                     HelloPhoenix.PostsController.show/2\n\n\nSimilarly, if we have a comments resource, and we don't want to provide a route to delete one, we could define a route like this.\nresources \"comments\", CommentController, except: [:delete]\n\n\nRunning$ mix phoenix.routes now shows that we have all the routes except the DELETE request to the delete action.\n\n\u3069\u306e\u30c7\u30a3\u30ec\u30af\u30c8\u30ea\u304b\u3089\u3067\u3082 $ mix phoenix.new\u3000../projectX\u304c\u4f7f\u3048\u308b\u3088\u3046\u306b\u4e0b\u306e\u30b3\u30de\u30f3\u30c9\u3067phoenix 0.13\u30d0\u30fc\u30b8\u30e7\u30f3\u3092\u30a4\u30f3\u30b9\u30c8\u30fc\u30eb\n$ mix archive.install https://github.com/phoenixframework/phoenix/releases/download/v0.13.1/phoenix_new-0.13.1.ez\n\n\u4e0b\u306e\u30b3\u30de\u30f3\u30c9\u306e\u7d50\u679c\u306e\u4e2d\u306bpage_path\u3068\u304bpost_path\u3068\u304b\u306fController\u306e\u540d\u524d\u306b\u57fa\u3065\u3044\u3066\u81ea\u52d5\u7684\u751f\u6210\u3055\u308c\u305f\u3082\u306e\u3067\u3059\u3002\nPhoenix.Router\u30da\u30fc\u30b8\u306b\u3053\u308c\u306b\u3064\u3044\u3066\u66f8\u3044\u3066\u3044\u307e\u3059\u3002\n\nPhoenix automatically generates a module Helpers inside your router which contains named helpers to help developers generate and keep their routes up to date.\nHelpers are automatically generated based on the controller name.\n\n$ mix phoenix.routes\npage_path  GET     /                ElixirFriends.PageController.index/2\npost_path  GET     /posts           ElixirFriends.PostController.index/2\npost_path  GET     /posts/:id/edit  ElixirFriends.PostController.edit/2\npost_path  GET     /posts/new       ElixirFriends.PostController.new/2\npost_path  GET     /posts/:id       ElixirFriends.PostController.show/2\npost_path  POST    /posts           ElixirFriends.PostController.create/2\npost_path  PATCH   /posts/:id       ElixirFriends.PostController.update/2\n           PUT     /posts/:id       ElixirFriends.PostController.update/2\npost_path  DELETE  /posts/:id       ElixirFriends.PostController.delete/2\n\n\nphoenix\u306e\u30b8\u30a7\u30cd\u30ec\u30fc\u30bf\u30fc\u3067\u30c7\u30fc\u30bf\u30e2\u30c7\u30eb\u3092\u4f5c\u308a\u307e\u3059\u3002\n$ mix phoenix.gen.html Post posts image_url:string content:string source_url:string\n* creating priv/repo/migrations/20150606011714_create_post.exs\n* creating web/models/post.ex\n* creating test/models/post_test.exs\n* creating web/controllers/post_controller.ex\n* creating web/templates/post/edit.html.eex\n* creating web/templates/post/form.html.eex\n* creating web/templates/post/index.html.eex\n* creating web/templates/post/new.html.eex\n* creating web/templates/post/show.html.eex\n* creating web/views/post_view.ex\n* creating test/controllers/post_controller_test.exs\n\nAdd the resource to the proper scope in web/router.ex:\n\n    resources \"/posts\", PostController\n\nand then update your repository by running migrations:\n\n    $ mix ecto.migrate\n\npriv/repo/migrations/\u30c7\u30a3\u30ec\u30af\u30c8\u30ea\u4e0b\u306b\u30c6\u30fc\u30d6\u30eb\u4f5c\u6210\u3059\u308b\u305f\u3081\u306e\u30e2\u30b8\u30e5\u30fc\u30eb\u304c\u4f5c\u6210\u3055\u308c\u307e\u3059\u3002\nweb/models/post.ex\u30d5\u30a1\u30a4\u30eb\u306bPost\u30e2\u30b8\u30e5\u30fc\u30eb\u304c\u751f\u6210\u3055\u308c\u3001posts\u30b9\u30ad\u30fc\u30de\u304c\u5b9a\u7fa9\u3055\u308c\u307e\u3059\u3002\n$ mix ecto.create\u30b3\u30de\u30f3\u30c9\u5b9f\u884c\u3059\u308b\u3068elixir_friends_dev\u30c7\u30fc\u30bf\u30d9\u30fc\u30b9\u304c\u4f5c\u6210\u3055\u308c\u307e\u3059\u3002elixir_friends_dev\u306fconfig/config.exs\u306b\u5b9a\u7fa9\u3055\u308c\u3066\u3044\u307e\u3059\u3002\n$ mix ecto.migrate\u30b3\u30de\u30f3\u30c9\u3092\u5b9f\u884c\u3059\u308b\u3068priv/repo/migrations/\u30c7\u30a3\u30ec\u30af\u30c8\u30ea\u4e0b\u306e\u30d5\u30a1\u30a4\u30eb\u3092\u5229\u7528\u3057\u3066\u3001\u4e0b\u306e\u3088\u3046\u306a\u30c6\u30fc\u30d6\u30eb\uff08posts)\u304c\u4f5c\u6210\u3055\u308c\u307e\u3059\u3002\nYou are now connected to database \"elixir_friends_dev\" as user \"wang\".\nelixir_friends_dev=# \\d\nNo relations found.\nelixir_friends_dev=# \\d\n                List of relations\n Schema |       Name        |   Type   |  Owner\n--------+-------------------+----------+----------\n public | posts             | table    | postgres\n public | posts_id_seq      | sequence | postgres\n public | schema_migrations | table    | postgres\n(3 rows)\n\n\nPhoenix views have several important jobs. They render templates. \nIn order to render any templates for our HelloController, we need a HelloView.\nWe can define functions in any individual view in web/views. Functions defined in an individual view will only be available to templates which that view renders. For example, functions defined in the PageView will only be available to templates in web/templates/page.\n\nPhoenix generates a main application view at web/view.ex. Functions we define there are visible to every view module and every template in our application.\n\nThe Phoenix PubSub layer consists of the Phoenix.PubSub module and a variety of modules for different adapters and their Genservers. These modules contain functions which are the nuts and bolts of organizing Channel communication - subscribing to topics, unsubscribing from topics, and broadcasting messages on a topic.\nChannels use them under the hood to do much of their work. As end users, we shouldn't have any need to use them directly in our applications.\n\nTopics are string identifiers - names that the various layers use in order to make sure messages end up in the right place. As we saw above, topics can use wildcards. This allows for a useful \"topic:subtopic\" convention. Often, you'll compose topics using record IDs from your model layer, such as \"users:123\".\n\nEvery keyword passed to render in the controller is available as an assign within the template, so you can use <%= @message %> in the eex template that is rendered in the controller example.\nAll controller actions take two arguments. The first is conn, a struct which holds a ton of data about the request. The second is params, which are the request parameters. \ndefmodule App.PageController do\n  use Phoenix.Controller\n\n  plug :action\n\n  def index(conn, _params) do\n    render conn, \"index\", message: \"hello\"\n  end\nend\n\n\nBy default, eex is supported. To add haml support, simply include the following in your mix.exs deps:\n{:phoenix_haml, \"~> 0.1.0\"}\n\nand add the PhoenixHaml.Engine to your config/config.exs\nconfig :phoenix, :template_engines,\n  haml: PhoenixHaml.Engine\n\n\nWe can implement a channel by creating a module in the channels directory and by using Phoenix.Channel:\ndefmodule App.MyChannel do\n  use Phoenix.Channel\nend\n\nThe first thing to do is to implement the join function to authorize sockets on this Channel's topic:\ndefmodule App.MyChannel do\n  use Phoenix.Channel\n\n  def join(socket, \"topic\", message) do\n    {:ok, socket}\n  end\n\n  def join(socket, _no, _message) do\n    {:error, socket, :unauthorized}\n  end\nend\n\njoin events are specially treated. When {:ok, socket} is returned from the Channel, the socket is subscribed to the channel and authorized to pubsub on the channel/topic pair. When {:error, socket, reason} is returned, the socket is denied pubsub access.\n\nYou can use plug in your projects in two steps:\nAdd plug and your webserver of choice (currently cowboy) to your mix.exs dependencies:\ndef deps do\n  [{:cowboy, \"~> 1.0.0\"},\n   {:plug, \"~> 0.8.0\"}]\nend\n\nList both :cowboy and :plug as your application dependencies:\ndef application do\n  [applications: [:cowboy, :plug]]\nend\n\n\nA plug takes two shapes. It is a function that receives a connection and a set of options as arguments and returns the connection or it is a module that provides an init/1 function to initialize options and implement the call/2 function, receiving the connection and the initialized options, and returning the connection.\nAs per the specification above, a connection is represented by the Plug.Conn struct:\n%Plug.Conn{host: \"www.example.com\",\n           path_info: [\"bar\", \"baz\"],\n           ...}\n\nPlug.Static - serves static files;\n\nChannels are based on a simple idea - sending and receiving messages. Senders broadcast messages about topics. Receivers subscribe to topics so that they can get those messages. Senders and receivers can switch roles on the same topic at any time.\nA channel will use a socket underneath to send responses and receive events. As said, sockets are bidirectional, which mean you can receive events (similar to requests in your controller). You handle events with pattern matching directly on the event name and message map.\n\nPrints all routes for the default or a given router.\n$ mix phoenix.routes\nCompiled web/views/page_view.ex\nGenerated chatty.app\npage_path  GET  /  Chatty.PageController.index/2\n\n\nControllers are used to group common functionality in the same (pluggable) module.\nFor example, the route:\nget \"/users/:id\", UserController, :show\n\nwill invoke the show/2 action in the UserController:\ndefmodule UserController do\n  use Phoenix.Controller\n\n  plug :action\n\n  def show(conn, %{\"id\" => id}) do\n    user = Repo.get(User, id)\n    render conn, \"show.html\", user: user\n  end\nend\n\nAn action is just a regular function that receives the connection and the request parameters as arguments. The connection is a Plug.Conn struct, as specified by the Plug library.\nConnection\nA controller by default provides many convenience functions for manipulating the connection, rendering templates, and more.\nThose functions are imported from two modules:\nPlug.Conn - a bunch of low-level functions to work with the connection\nPhoenix.Controller - functions provided by Phoenix to support rendering, and other Phoenix specific behaviour\n\nbroadcast(socket, event, message) (function)\nbroadcast(channel, topic, event, message) (function)\n\nBroadcast event, serializable as JSON to topic namedspaced by channel\nExamples\niex> Channel.broadcast \"rooms\", \"global\", \"new:message\", %{id: 1, content: \"hello\"}\n:ok\niex> Channel.broadcast socket, \"new:message\", %{id: 1, content: \"hello\"}\n:ok\n\n\nplug/2 support guards, allowing a developer to configure a plug to only run in some particular action:\nplug :log_message, \"before action\" when action in [:show, :edit]\nplug :action\nplug :log_message, \"after action\" when not action in [:index]\n\nThe first plug will run only when action is show and edit, while the second will always run except for the index action.\nThose guards work like regular Elixir guards and the only variables accessible in the guard are conn, the action as an atom and the controller as an alias.\n\nLike routers, controllers are plugs, but they are wired to dispatch to a particular function which is called an action.\nFor example, the route:\nget \"/users/:id\", UserController, :show\n\nwill invoke UserController as a plug:\nUserController.call(conn, :show)\n\nwhich will trigger the plug pipeline and which will eventually invoke the inner action plug that dispatches to the show/2 function in the UserController.\nAs controllers are plugs, they implement both init/1 and call/2, and it also provides a function named action/2 which is responsible for dispatching the appropriate action in the middle of the plug stack (and is also overridable).\n\nweb/controllers/page_controller.ex\u306b\u3042\u308bmsg\u306f\nweb/templates/page/index.html.eex\u306e\u4e2d\u306b\u547c\u3073\u51fa\u3059\u3053\u3068\u304c\u3067\u304d\u308b\ndef index(conn, _params) do\n  render conn, \"index.html\", msg: \"user-input-message\"\n  end\nend\n\n\u4e0b\u306e\u30b3\u30fc\u30c9\u307f\u305f\u3044\u306a\u3084\u308a\u65b9\u3067\n<input type=\"text\" id=\"<%= @msg %>\" />\n\n\ninfo.html\u753b\u9762\u4e00\u3064\u8ffd\u52a0\u3057\u305f\u3044\u3068\u304d\u306b\uff0c\u307e\u305a web/router.ex\u3092\u958b\u3044\u3066\uff0c\u30eb\u30fc\u30c8\u3092\u8ffd\u52a0\u3059\u308b\n\n\u305d\u3057\u3066web/controllers/page_controller.ex\u306binfo\u95a2\u6570\u4e00\u3064\u8ffd\u52a0\n\n\u3053\u308c\u3089\u306b\u3042\u308f\u305b\u3066web/templates/page\u306e\u4e0b\u306b\ninformation.html.eex\u3092\u8ffd\u52a0\u3059\u308b\u3068\u3044\u3044\n\nPut this line into your router.ex file inside the scope \"/\" do block: resources \"users\", Chatty.UserController.\nThen go to the root of your project, and run \n$ mix phoenix.routes\n\nGenerated chatty.app\n page_path  GET     /                  Chatty.PageController.index/2\nhello_path  GET     /hello             Chatty.HelloController.index/2\nhello_path  GET     /hello/:messenger  Chatty.HelloController.show/2\n user_path  GET     /users             Chatty.UserController.index/2\n user_path  GET     /users/:id/edit    Chatty.UserController.edit/2\n user_path  GET     /users/new         Chatty.UserController.new/2\n user_path  GET     /users/:id         Chatty.UserController.show/2\n user_path  POST    /users             Chatty.UserController.create/2\n user_path  PATCH   /users/:id         Chatty.UserController.update/2\n            PUT     /users/:id         Chatty.UserController.update/2\n user_path  DELETE  /users/:id         Chatty.UserController.destroy/2\n\niex(9)> Chatty.Router.Helpers.user_path(:show, 17, admin: true, active: false)\n\"/users/17?admin=true&active=false\"\n\n\nPhoenix\u306b\u95a2\u3059\u308b\u8cc7\u6599\u306f\u9650\u3089\u308c\u3066\u3044\u308b\u306e\u3067\u65ad\u7247\u7684\u306a\u3082\u306e\u3092\u53ce\u96c6\u3057\u3066\u3044\u308b\uff0e\n\u4eba\u306b\u898b\u305b\u308b\u3082\u306e\u3067\u306f\u306a\u3044\uff0e\u30e1\u30a4\u30f3\u306b\u53c2\u8003\u306b\u3057\u3066\u3044\u308b\u8cc7\u6599\u306f\u4e0b\u306e\u30ea\u30f3\u30af\n`http://www.phoenixframework.org/` \n\n\nphoenix\u3092\u30a4\u30f3\u30b9\u30c8\u30fc\u30eb\u3057\u305f\u5f8c\u306bmy_app\u3068\u3044\u3046\u30d7\u30ed\u30b8\u30a7\u30af\u30c8\u3092~/Projects/\u306b\u4f5c\u308b\n\n```\n$ mix local.hex\n$ mix archive.install https://github.com/phoenixframework/phoenix/releases/download/v0.13.1/phoenix_new-0.13.1.ez\n$ mix phoenix.new ~/Projects/my_app --no-brunch\n$ cd ~/Projects/my_app\n$ iex -S mix phoenix.server\nRunning Elixir.HelloPhoenix.Router with Cowboy on port 4000\n```\n\n----\n\nLet's say we have a read-only posts resource. We could define it like this.\n\n\n\n```\n\nresources \"posts\", PostController, only: [:index, :show]\n\n```\n\nRunning `$ mix phoenix.routes` shows that we now only have the routes to the index and show actions defined.\n\n\n\n```\n\npost_path  GET     /posts                         HelloPhoenix.PostsController.index/2\n\npost_path  GET     /posts/:id                     HelloPhoenix.PostsController.show/2\n\n```\n\nSimilarly, if we have a comments resource, and we don't want to provide a route to delete one, we could define a route like this.\n\n```\nresources \"comments\", CommentController, except: [:delete]\n\n```\nRunning` $ mix phoenix.routes` now shows that we have all the routes except the DELETE request to the delete action.\n\n---\n\u3069\u306e\u30c7\u30a3\u30ec\u30af\u30c8\u30ea\u304b\u3089\u3067\u3082 `$ mix phoenix.new\u3000../projectX`\u304c\u4f7f\u3048\u308b\u3088\u3046\u306b\u4e0b\u306e\u30b3\u30de\u30f3\u30c9\u3067phoenix 0.13\u30d0\u30fc\u30b8\u30e7\u30f3\u3092\u30a4\u30f3\u30b9\u30c8\u30fc\u30eb\n\n`$ mix archive.install https://github.com/phoenixframework/phoenix/releases/download/v0.13.1/phoenix_new-0.13.1.ez`\n\n----\n\n\u4e0b\u306e\u30b3\u30de\u30f3\u30c9\u306e\u7d50\u679c\u306e\u4e2d\u306b`page_path`\u3068\u304b`post_path`\u3068\u304b\u306f`Controller`\u306e\u540d\u524d\u306b\u57fa\u3065\u3044\u3066\u81ea\u52d5\u7684\u751f\u6210\u3055\u308c\u305f\u3082\u306e\u3067\u3059\u3002\n[Phoenix.Router](http://hexdocs.pm/phoenix/Phoenix.Router.html)\u30da\u30fc\u30b8\u306b\u3053\u308c\u306b\u3064\u3044\u3066\u66f8\u3044\u3066\u3044\u307e\u3059\u3002\n\n>Phoenix automatically generates a module Helpers inside your router which contains named helpers to help developers generate and keep their routes up to date.\nHelpers are automatically generated based on the controller name.\n\n```\n$ mix phoenix.routes\npage_path  GET     /                ElixirFriends.PageController.index/2\npost_path  GET     /posts           ElixirFriends.PostController.index/2\npost_path  GET     /posts/:id/edit  ElixirFriends.PostController.edit/2\npost_path  GET     /posts/new       ElixirFriends.PostController.new/2\npost_path  GET     /posts/:id       ElixirFriends.PostController.show/2\npost_path  POST    /posts           ElixirFriends.PostController.create/2\npost_path  PATCH   /posts/:id       ElixirFriends.PostController.update/2\n           PUT     /posts/:id       ElixirFriends.PostController.update/2\npost_path  DELETE  /posts/:id       ElixirFriends.PostController.delete/2\n```\n---\nphoenix\u306e\u30b8\u30a7\u30cd\u30ec\u30fc\u30bf\u30fc\u3067\u30c7\u30fc\u30bf\u30e2\u30c7\u30eb\u3092\u4f5c\u308a\u307e\u3059\u3002\n\n```\n$ mix phoenix.gen.html Post posts image_url:string content:string source_url:string\n* creating priv/repo/migrations/20150606011714_create_post.exs\n* creating web/models/post.ex\n* creating test/models/post_test.exs\n* creating web/controllers/post_controller.ex\n* creating web/templates/post/edit.html.eex\n* creating web/templates/post/form.html.eex\n* creating web/templates/post/index.html.eex\n* creating web/templates/post/new.html.eex\n* creating web/templates/post/show.html.eex\n* creating web/views/post_view.ex\n* creating test/controllers/post_controller_test.exs\n\nAdd the resource to the proper scope in web/router.ex:\n\n    resources \"/posts\", PostController\n\nand then update your repository by running migrations:\n\n    $ mix ecto.migrate\n```\n\n`priv/repo/migrations/`\u30c7\u30a3\u30ec\u30af\u30c8\u30ea\u4e0b\u306b\u30c6\u30fc\u30d6\u30eb\u4f5c\u6210\u3059\u308b\u305f\u3081\u306e\u30e2\u30b8\u30e5\u30fc\u30eb\u304c\u4f5c\u6210\u3055\u308c\u307e\u3059\u3002\n\n`web/models/post.ex`\u30d5\u30a1\u30a4\u30eb\u306b`Post`\u30e2\u30b8\u30e5\u30fc\u30eb\u304c\u751f\u6210\u3055\u308c\u3001`posts`\u30b9\u30ad\u30fc\u30de\u304c\u5b9a\u7fa9\u3055\u308c\u307e\u3059\u3002\n\n`$ mix ecto.create`\u30b3\u30de\u30f3\u30c9\u5b9f\u884c\u3059\u308b\u3068`elixir_friends_dev`\u30c7\u30fc\u30bf\u30d9\u30fc\u30b9\u304c\u4f5c\u6210\u3055\u308c\u307e\u3059\u3002`elixir_friends_dev`\u306f`config/config.exs`\u306b\u5b9a\u7fa9\u3055\u308c\u3066\u3044\u307e\u3059\u3002\n\n`$ mix ecto.migrate`\u30b3\u30de\u30f3\u30c9\u3092\u5b9f\u884c\u3059\u308b\u3068`priv/repo/migrations/`\u30c7\u30a3\u30ec\u30af\u30c8\u30ea\u4e0b\u306e\u30d5\u30a1\u30a4\u30eb\u3092\u5229\u7528\u3057\u3066\u3001\u4e0b\u306e\u3088\u3046\u306a\u30c6\u30fc\u30d6\u30eb\uff08posts)\u304c\u4f5c\u6210\u3055\u308c\u307e\u3059\u3002\n\n```\nYou are now connected to database \"elixir_friends_dev\" as user \"wang\".\nelixir_friends_dev=# \\d\nNo relations found.\nelixir_friends_dev=# \\d\n                List of relations\n Schema |       Name        |   Type   |  Owner\n--------+-------------------+----------+----------\n public | posts             | table    | postgres\n public | posts_id_seq      | sequence | postgres\n public | schema_migrations | table    | postgres\n(3 rows)\n```\n\n-----\n\nPhoenix views have several important jobs. They render templates. \nIn order to render any templates for our `HelloController`, we need a `HelloView`.\nWe can define functions in any individual view in **web/views**. Functions defined in an individual view will only be available to templates which that view renders. For example, functions defined in the **PageView** will only be available to templates in **web/templates/page**.\n\n----\n\nPhoenix generates a main application view at web/view.ex. Functions we define there are visible to every view module and every template in our application.\n\n----\n\n\nThe Phoenix PubSub layer consists of the Phoenix.PubSub module and a variety of modules for different adapters and their Genservers. These modules contain functions which are the nuts and bolts of organizing Channel communication - subscribing to topics, unsubscribing from topics, and broadcasting messages on a topic.\nChannels use them under the hood to do much of their work. As end users, we shouldn't have any need to use them directly in our applications.\n\n---\n\nTopics are string identifiers - names that the various layers use in order to make sure messages end up in the right place. As we saw above, topics can use wildcards. This allows for a useful \"topic:subtopic\" convention. Often, you'll compose topics using record IDs from your model layer, such as \"users:123\".\n\n---\n\n\nEvery keyword passed to render in the controller is available as an assign within the template, so you can use `<%= @message %>` in the eex template that is rendered in the controller example.\nAll controller actions take two arguments. The first is `conn`, a struct which holds a ton of data about the request. The second is `params`, which are the request parameters. \n\n```\ndefmodule App.PageController do\n  use Phoenix.Controller\n\n  plug :action\n\n  def index(conn, _params) do\n    render conn, \"index\", message: \"hello\"\n  end\nend\n```\n\n----\n\nBy default, eex is supported. To add haml support, simply include the following in your mix.exs deps:\n\n```\n{:phoenix_haml, \"~> 0.1.0\"}\n```\nand add the PhoenixHaml.Engine to your config/config.exs\n\n```\nconfig :phoenix, :template_engines,\n  haml: PhoenixHaml.Engine\n```\n\n----\n\nWe can implement a channel by creating a module in the channels directory and by using Phoenix.Channel:\n\n```\ndefmodule App.MyChannel do\n  use Phoenix.Channel\nend\n```\n\nThe first thing to do is to implement the join function to authorize sockets on this Channel's topic:\n\n```\ndefmodule App.MyChannel do\n  use Phoenix.Channel\n\n  def join(socket, \"topic\", message) do\n    {:ok, socket}\n  end\n\n  def join(socket, _no, _message) do\n    {:error, socket, :unauthorized}\n  end\nend\n```\n\njoin events are specially treated. When {:ok, socket} is returned from the Channel, the socket is subscribed to the channel and authorized to pubsub on the channel/topic pair. When {:error, socket, reason} is returned, the socket is denied pubsub access.\n\n----\n\nYou can use plug in your projects in two steps:\n\nAdd plug and your webserver of choice (currently cowboy) to your mix.exs dependencies:\n\n```\ndef deps do\n  [{:cowboy, \"~> 1.0.0\"},\n   {:plug, \"~> 0.8.0\"}]\nend\n```\n\nList both :cowboy and :plug as your application dependencies:\n\n```\ndef application do\n  [applications: [:cowboy, :plug]]\nend\n```\n\n----\n\nA plug takes two shapes. It is a function that receives a connection and a set of options as arguments and returns the connection or it is a module that provides an init/1 function to initialize options and implement the call/2 function, receiving the connection and the initialized options, and returning the connection.\n\nAs per the specification above, a connection is represented by the Plug.Conn struct:\n\n```\n%Plug.Conn{host: \"www.example.com\",\n           path_info: [\"bar\", \"baz\"],\n           ...}\n```\nPlug.Static - serves static files;\n\n----\n Channels are based on a simple idea - sending and receiving messages. Senders broadcast messages about topics. Receivers subscribe to topics so that they can get those messages. Senders and receivers can switch roles on the same topic at any time.\n\nA channel will use a socket underneath to send responses and receive events. As said, sockets are bidirectional, which mean you can receive events (similar to requests in your controller). You handle events with pattern matching directly on the event name and message map.\n\n----\n\nPrints all routes for the default or a given router.\n\n```\n$ mix phoenix.routes\nCompiled web/views/page_view.ex\nGenerated chatty.app\npage_path  GET  /  Chatty.PageController.index/2\n```\n\n----\n\nControllers are used to group common functionality in the same (pluggable) module.\n\nFor example, the route:\n\n```\nget \"/users/:id\", UserController, :show\n```\nwill invoke the show/2 action in the UserController:\n\n```\ndefmodule UserController do\n  use Phoenix.Controller\n\n  plug :action\n\n  def show(conn, %{\"id\" => id}) do\n    user = Repo.get(User, id)\n    render conn, \"show.html\", user: user\n  end\nend\n```\nAn action is just a regular function that receives the connection and the request parameters as arguments. The connection is a Plug.Conn struct, as specified by the Plug library.\n\nConnection\nA controller by default provides many convenience functions for manipulating the connection, rendering templates, and more.\n\nThose functions are imported from two modules:\n\nPlug.Conn - a bunch of low-level functions to work with the connection\nPhoenix.Controller - functions provided by Phoenix to support rendering, and other Phoenix specific behaviour\n\n----\n\n```\nbroadcast(socket, event, message) (function)\nbroadcast(channel, topic, event, message) (function)\n```\nBroadcast event, serializable as JSON to topic namedspaced by channel\n\nExamples\n\n```\niex> Channel.broadcast \"rooms\", \"global\", \"new:message\", %{id: 1, content: \"hello\"}\n:ok\niex> Channel.broadcast socket, \"new:message\", %{id: 1, content: \"hello\"}\n:ok\n```\n---\n\nplug/2 support guards, allowing a developer to configure a plug to only run in some particular action:\n\n```\nplug :log_message, \"before action\" when action in [:show, :edit]\nplug :action\nplug :log_message, \"after action\" when not action in [:index]\n```\n\nThe first plug will run only when action is show and edit, while the second will always run except for the index action.\n\nThose guards work like regular Elixir guards and the only variables accessible in the guard are conn, the action as an atom and the controller as an alias.\n\n---\n\nLike routers, controllers are plugs, but they are wired to dispatch to a particular function which is called an action.\n\nFor example, the route:\n\n```\nget \"/users/:id\", UserController, :show\n```\nwill invoke UserController as a plug:\n\n```\nUserController.call(conn, :show)\n```\nwhich will trigger the plug pipeline and which will eventually invoke the inner action plug that dispatches to the show/2 function in the UserController.\n\nAs controllers are plugs, they implement both init/1 and call/2, and it also provides a function named action/2 which is responsible for dispatching the appropriate action in the middle of the plug stack (and is also overridable).\n\n----\n\nweb/controllers/page_controller.ex\u306b\u3042\u308bmsg\u306f\nweb/templates/page/index.html.eex\u306e\u4e2d\u306b\u547c\u3073\u51fa\u3059\u3053\u3068\u304c\u3067\u304d\u308b\n\n```\ndef index(conn, _params) do\n  render conn, \"index.html\", msg: \"user-input-message\"\n  end\nend\n```\n\u4e0b\u306e\u30b3\u30fc\u30c9\u307f\u305f\u3044\u306a\u3084\u308a\u65b9\u3067\n\n```\n<input type=\"text\" id=\"<%= @msg %>\" />\n```\n\n----\n\ninfo.html\u753b\u9762\u4e00\u3064\u8ffd\u52a0\u3057\u305f\u3044\u3068\u304d\u306b\uff0c\u307e\u305a web/router.ex\u3092\u958b\u3044\u3066\uff0c\u30eb\u30fc\u30c8\u3092\u8ffd\u52a0\u3059\u308b\n\n![Screen Shot 2014-11-29 at 10.32.17 PM.png](https://qiita-image-store.s3.amazonaws.com/0/54698/c946782f-7348-b00e-55c3-ca187e35c3e1.png)\n\n\u305d\u3057\u3066web/controllers/page_controller.ex\u306binfo\u95a2\u6570\u4e00\u3064\u8ffd\u52a0\n\n![Screen Shot 2014-11-29 at 10.34.07 PM.png](https://qiita-image-store.s3.amazonaws.com/0/54698/3e40d5af-5699-d8ae-7e89-570a843791fa.png)\n\n\u3053\u308c\u3089\u306b\u3042\u308f\u305b\u3066web/templates/page\u306e\u4e0b\u306b\ninformation.html.eex\u3092\u8ffd\u52a0\u3059\u308b\u3068\u3044\u3044\n\n----\n\nPut this line into your router.ex file inside the scope \"/\" do block: resources \"users\", Chatty.UserController.\n\nThen go to the root of your project, and run \n\n```\n$ mix phoenix.routes\n\nGenerated chatty.app\n page_path  GET     /                  Chatty.PageController.index/2\nhello_path  GET     /hello             Chatty.HelloController.index/2\nhello_path  GET     /hello/:messenger  Chatty.HelloController.show/2\n user_path  GET     /users             Chatty.UserController.index/2\n user_path  GET     /users/:id/edit    Chatty.UserController.edit/2\n user_path  GET     /users/new         Chatty.UserController.new/2\n user_path  GET     /users/:id         Chatty.UserController.show/2\n user_path  POST    /users             Chatty.UserController.create/2\n user_path  PATCH   /users/:id         Chatty.UserController.update/2\n            PUT     /users/:id         Chatty.UserController.update/2\n user_path  DELETE  /users/:id         Chatty.UserController.destroy/2\n```\n\n```\niex(9)> Chatty.Router.Helpers.user_path(:show, 17, admin: true, active: false)\n\"/users/17?admin=true&active=false\"\n```\n\n-----\n\n", "tags": ["Phoenix"]}