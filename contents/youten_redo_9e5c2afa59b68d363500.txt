{"context": " More than 1 year has passed since last update.\n\n\u30b3\u30fc\u30c9\u4f8b\n\u3061\u3087\u3063\u3068bit\u5358\u4f4d\u3067\u30ae\u30c1\u30ae\u30c1\u306b\u3064\u307e\u3063\u305fUDP\u30d1\u30b1\u30c3\u30c8\u306e\u30b7\u30ea\u30a2\u30e9\u30a4\u30ba/\u30c7\u30b7\u30ea\u30a2\u30e9\u30a4\u30ba\u306a\u611f\u3058\u306e\u30b3\u30fc\u30c9\u304cAndroid\u3067\u5fc5\u8981\u306b\u306a\u3063\u3066\u3001nio\uff08New I/O\u3068\u3084\u3089\uff09\u3092\u4f7f\u3063\u3066Android\u30c7\u30d0\u30a4\u30b9\u4e0a\u3067UDP broadcast\u3092\u9001\u4fe1\u3057\u3066\u81ea\u5206\u3067\u53d7\u4fe1\u3059\u308b\u30c6\u30b9\u30c8\u30b3\u30fc\u30c9\u3092\u66f8\u3044\u3066\u307f\u305f\u3068\u3053\u308d\u3001Java 6\u306aAndroid Java\u3068Oracle\u306aJava 7\u3068\u306e\u5dee\u3060\u3063\u305f\u308a\u3001UDP\u3068TCP\u306e\u5dee\u3060\u3063\u305f\u308a\u3001\u30e6\u30cb\u30ad\u30e3\u30b9\u30c8\u3068\u30d6\u30ed\u30fc\u30c9\u30ad\u30e3\u30b9\u30c8\u306e\u5dee\u3060\u3063\u305f\u308a\u3001ByteBuffer\u3092\u3061\u3083\u3093\u3068\u7406\u89e3\u3057\u3066\u3044\u306a\u3044\u3042\u305f\u308a\u306e\u7f60\u3092\u8e0f\u307f\u306b\u8e0f\u307f\u307e\u304f\u3063\u3066\u6ce3\u3044\u305f\u306e\u3067\u3001\u3084\u3063\u3068\u52d5\u3044\u305f\u30c6\u30b9\u30c8\u30b3\u30fc\u30c9\u3092\u6b8b\u3057\u3066\u304a\u304d\u307e\u3059\u3002\n\nUdpTest.java\npackage youten.redo.udpbroadcast;\n\nimport android.support.test.runner.AndroidJUnit4;\n\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\n\nimport java.io.IOException;\nimport java.net.InetAddress;\nimport java.net.InetSocketAddress;\nimport java.net.InterfaceAddress;\nimport java.net.NetworkInterface;\nimport java.net.SocketException;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.DatagramChannel;\nimport java.util.Enumeration;\nimport java.util.concurrent.CountDownLatch;\nimport java.util.concurrent.TimeUnit;\n\nimport static junit.framework.Assert.assertEquals;\nimport static junit.framework.Assert.fail;\n\n/**\n * Android\u30c7\u30d0\u30a4\u30b9\u4e0a\u3067UDP broadcast\u3092\u9001\u4fe1\u3057\u3066\u81ea\u5206\u3067\u53d7\u4fe1\u3059\u308b\u30c6\u30b9\u30c8\u30b3\u30fc\u30c9\n */\n@RunWith(AndroidJUnit4.class)\npublic class UdpTest {\n    private static final int PORT = 8888;\n\n    @Test\n    public void testUdp() throws Exception {\n        // PC\uff08JDK\uff09\u74b0\u5883\u3060\u3068\u3053\u306e\u8a2d\u5b9a\u6709\u7121\u3067\u8fd4\u3063\u3066\u304f\u308bbroadcastAddress\u304c\u5909\u5316\u3059\u308b\u3002\n        // System.setProperty(\"java.net.preferIPv4Stack\", \"true\");\n\n        // \u30d6\u30ed\u30fc\u30c9\u30ad\u30e3\u30b9\u30c8\u30a2\u30c9\u30ec\u30b9\u306f\u6b63\u78ba\u306b\u8a18\u8f09\u3059\u308b\u5fc5\u8981\u304c\u3042\u308b\u3002\n        // \u9001\u4fe1\u6642\u306b\u4f8b\u5916\u306b\u306a\u3063\u305f\u308a\u53d7\u4fe1\u3067\u304d\u306a\u304b\u3063\u305f\u308a\u3059\u308b\u3002\n        String broadcastAddress = getBroadcastAddress();\n        System.out.println(\"broadcast=\" + broadcastAddress);\n\n        final CountDownLatch latch = new CountDownLatch(1);\n        final int COUNT = 5; // 5\u56de \"Hello\"\u3092\u9001\u4fe1\n\n        // \u53d7\u4fe1\u5074\u30b9\u30ec\u30c3\u30c9\n        new Thread(new Runnable() {\n            @Override\n            public void run() {\n                try {\n                    DatagramChannel recvCh = DatagramChannel.open();\n                    // recvCh.configureBlocking(true); \u521d\u671f\u5024\u304ctrue\u306a\u306e\u3067\u547c\u3076\u5fc5\u8981\u306f\u306a\u3044\u3002\n                    // recvCh.socket().setBroadcast(true); \u53d7\u4fe1\u5074\u306b\u306f\u4e0d\u8981\u3001\u547c\u3076\u5fc5\u8981\u306f\u306a\u3044\u3002\n                    // recvCh.socket().setReuseAddress(true); \u547c\u3076\u5fc5\u8981\u306f\u306a\u3044\u6a21\u69d8\u3002\n                    recvCh.socket().bind(new InetSocketAddress(PORT));\n                    // \u3053\u3053\u3067connect()\u3057\u3066\u306f\u30c0\u30e1\u3002NotYetConnectedException\u3082\u672c\u4ef6\u306b\u306f\u95a2\u4fc2\u306a\u3044\u3002\n\n                    ByteBuffer recvBuf = ByteBuffer.allocate(1024);\n                    for (int i = 0; i < COUNT; i++) {\n                        // \u3053\u3053\u3067receive()\u3058\u3083\u306a\u304f\u3066read()\u3059\u308b\u306e\u306f\u9593\u9055\u3044\u3002\n                        recvCh.receive(recvBuf);\n                        System.out.println(\"receive\");\n                        recvBuf.flip();\n                        int limit = recvBuf.limit();\n                        System.out.println(\"limit=\" + limit);\n                        String hello = new String(recvBuf.array(), recvBuf.position(), limit, \"UTF-8\");\n                        assertEquals(\"Hello\", hello);\n                        recvBuf.clear();\n                    }\n\n                    latch.countDown();\n                    recvCh.close();\n                    System.out.println(\"recvCh close\");\n                } catch (IOException e) {\n                    fail();\n                }\n            }\n        }).start();\n\n        // \u9001\u4fe1\u5074\n        DatagramChannel sendCh = DatagramChannel.open();\n        // recvCh.configureBlocking(true); \u521d\u671f\u5024\u304ctrue\u306a\u306e\u3067\u547c\u3076\u5fc5\u8981\u306f\u306a\u3044\u3002\n        // recvCh.socket().setReuseAddress(true); \u9001\u4fe1\u5074\u306f\u95a2\u4fc2\u306a\u3044\u306e\u3067\u4e0d\u8981\u3002\n        // JDK\u3067\u306f\u4e0d\u8981\u3060\u3063\u305f\u304cAndroid\u3067\u306f\u5fc5\u8981\u3001SocketException EACCES\u304c\u767a\u751f\u3059\u308b\u3002\n        sendCh.socket().setBroadcast(true);\n\n        // ByteBuffer#allocate()+put()\u306e\u5834\u5408\u306f\u9001\u4fe1\u524d\u306bflip()\u304c\u5fc5\u8981\u3060\u304c\u3001\n        // wrap()\u306fflip()\u304c\u4e0d\u8981\u306a\u3053\u3068\u306b\u6ce8\u610f\uff08flip()\u6e08\u307f\u3068\u3044\u3046\u8a00\u3044\u65b9\u304c\u6b63\u3057\u3044\u304b\u3082\uff09\n        ByteBuffer sendBuf = ByteBuffer.wrap(\"Hello\".getBytes(\"UTF-8\"));\n        InetSocketAddress portISA = new InetSocketAddress(broadcastAddress, PORT);\n        for (int i = 0; i < COUNT; i++) {\n            mySleep(200);\n            sendCh.send(sendBuf, portISA);\n            System.out.println(\"send\");\n            sendBuf.clear();\n        }\n        sendCh.close();\n        System.out.println(\"sendCh close\");\n\n        latch.await(30, TimeUnit.SECONDS);\n        assertEquals(0, latch.getCount());\n    }\n\n    // \u53c2\u8003\uff1ahttp://stackoverflow.com/questions/2993874/android-broadcast-address\n    // \u3053\u306e\u30e1\u30bd\u30c3\u30c9\u306f\u898b\u3064\u304b\u3063\u305f\u9806\u306b\u8fd4\u3059\u305f\u3081\u3001WiFi\u5074\u306b\u9650\u5b9a\u3057\u305f\u3044\u969b\u306b\u306f\n    // Android\u306eAPI\u5074WiFiManager\u3042\u305f\u308a\u304b\u3089\u53d6\u5f97\u3059\u308b\u5fc5\u8981\u304c\u3042\u308b\u3002\n    // \u53c2\u8003\uff1ahttps://code.google.com/p/boxeeremote/wiki/AndroidUDP\n    private static final String getBroadcastAddress() {\n        try {\n            for (Enumeration<NetworkInterface> niEnum = NetworkInterface.getNetworkInterfaces(); niEnum.hasMoreElements(); ) {\n                NetworkInterface ni = niEnum.nextElement();\n                if (!ni.isLoopback()) {\n                    for (InterfaceAddress interfaceAddress : ni.getInterfaceAddresses()) {\n                        if (interfaceAddress != null) {\n                            InetAddress broadcastAddress = interfaceAddress.getBroadcast();\n                            if (broadcastAddress != null) {\n                                return broadcastAddress.toString().substring(1);\n                            }\n                        }\n                    }\n                }\n            }\n        } catch (SocketException e) {\n            // ignore;\n        }\n        return null;\n    }\n\n    private static void mySleep(long ms) {\n        try {\n            Thread.sleep(ms);\n        } catch (InterruptedException e) {\n            // ignore;\n        }\n    }\n}\n\n\nJava\u306enio\u7684\u306b\u30a4\u30de\u30a4\u30c1\u306a\u6c17\u914d\u3082\u3059\u308b\u305f\u3081\u3001\u305d\u306e\u3042\u305f\u308a\u8b58\u8005\u30b3\u30e1\u30f3\u30c8\u3092\u3044\u305f\u3060\u3051\u308b\u3068\u559c\u3073\u307e\u3059\u3002\n\nsleep\uff08\u30c7\u30a3\u30b9\u30d7\u30ec\u30a4\u30aa\u30d5\uff09\u6642\u306eUDP\u53d7\u4fe1\u306f\u3067\u304d\u306a\u3044\n\u95a2\u9023\u3057\u3066\u3001Android\u306fSleep\u6642\u306eUDP\u53d7\u4fe1\u306f\u3067\u304d\u306a\u3044\uff08\u5168\u3066\u306e\u6a5f\u7a2e\u3067\u306f\u306a\u3044\uff1f\uff09\u3053\u3068\u306b\u7559\u610f\u3057\u3066\u304f\u3060\u3055\u3044\u3002\nGoogle Group\uff1a\u65e5\u672cAndroid\u306e\u4f1a\uff1a\u7aef\u672b\u30b9\u30ea\u30fc\u30d7\u6642\u306eDiagramSocket\u53d7\u4fe1\u306b\u3064\u3044\u3066\nhttps://groups.google.com/forum/#!topic/android-group-japan/T5M7MqxpnnE\nStack Overflow\uff1aSome devices don't receive UDP broadcasts when screen off\nhttp://stackoverflow.com/questions/19673354/some-devices-dont-receive-udp-broadcasts-when-screen-off\n# \u30b3\u30fc\u30c9\u4f8b\n\n\u3061\u3087\u3063\u3068bit\u5358\u4f4d\u3067\u30ae\u30c1\u30ae\u30c1\u306b\u3064\u307e\u3063\u305fUDP\u30d1\u30b1\u30c3\u30c8\u306e\u30b7\u30ea\u30a2\u30e9\u30a4\u30ba/\u30c7\u30b7\u30ea\u30a2\u30e9\u30a4\u30ba\u306a\u611f\u3058\u306e\u30b3\u30fc\u30c9\u304cAndroid\u3067\u5fc5\u8981\u306b\u306a\u3063\u3066\u3001nio\uff08New I/O\u3068\u3084\u3089\uff09\u3092\u4f7f\u3063\u3066Android\u30c7\u30d0\u30a4\u30b9\u4e0a\u3067UDP broadcast\u3092\u9001\u4fe1\u3057\u3066\u81ea\u5206\u3067\u53d7\u4fe1\u3059\u308b\u30c6\u30b9\u30c8\u30b3\u30fc\u30c9\u3092\u66f8\u3044\u3066\u307f\u305f\u3068\u3053\u308d\u3001Java 6\u306aAndroid Java\u3068Oracle\u306aJava 7\u3068\u306e\u5dee\u3060\u3063\u305f\u308a\u3001UDP\u3068TCP\u306e\u5dee\u3060\u3063\u305f\u308a\u3001\u30e6\u30cb\u30ad\u30e3\u30b9\u30c8\u3068\u30d6\u30ed\u30fc\u30c9\u30ad\u30e3\u30b9\u30c8\u306e\u5dee\u3060\u3063\u305f\u308a\u3001ByteBuffer\u3092\u3061\u3083\u3093\u3068\u7406\u89e3\u3057\u3066\u3044\u306a\u3044\u3042\u305f\u308a\u306e\u7f60\u3092\u8e0f\u307f\u306b\u8e0f\u307f\u307e\u304f\u3063\u3066\u6ce3\u3044\u305f\u306e\u3067\u3001\u3084\u3063\u3068\u52d5\u3044\u305f\u30c6\u30b9\u30c8\u30b3\u30fc\u30c9\u3092\u6b8b\u3057\u3066\u304a\u304d\u307e\u3059\u3002\n\n```java:UdpTest.java\npackage youten.redo.udpbroadcast;\n\nimport android.support.test.runner.AndroidJUnit4;\n\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\n\nimport java.io.IOException;\nimport java.net.InetAddress;\nimport java.net.InetSocketAddress;\nimport java.net.InterfaceAddress;\nimport java.net.NetworkInterface;\nimport java.net.SocketException;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.DatagramChannel;\nimport java.util.Enumeration;\nimport java.util.concurrent.CountDownLatch;\nimport java.util.concurrent.TimeUnit;\n\nimport static junit.framework.Assert.assertEquals;\nimport static junit.framework.Assert.fail;\n\n/**\n * Android\u30c7\u30d0\u30a4\u30b9\u4e0a\u3067UDP broadcast\u3092\u9001\u4fe1\u3057\u3066\u81ea\u5206\u3067\u53d7\u4fe1\u3059\u308b\u30c6\u30b9\u30c8\u30b3\u30fc\u30c9\n */\n@RunWith(AndroidJUnit4.class)\npublic class UdpTest {\n    private static final int PORT = 8888;\n\n    @Test\n    public void testUdp() throws Exception {\n        // PC\uff08JDK\uff09\u74b0\u5883\u3060\u3068\u3053\u306e\u8a2d\u5b9a\u6709\u7121\u3067\u8fd4\u3063\u3066\u304f\u308bbroadcastAddress\u304c\u5909\u5316\u3059\u308b\u3002\n        // System.setProperty(\"java.net.preferIPv4Stack\", \"true\");\n\n        // \u30d6\u30ed\u30fc\u30c9\u30ad\u30e3\u30b9\u30c8\u30a2\u30c9\u30ec\u30b9\u306f\u6b63\u78ba\u306b\u8a18\u8f09\u3059\u308b\u5fc5\u8981\u304c\u3042\u308b\u3002\n        // \u9001\u4fe1\u6642\u306b\u4f8b\u5916\u306b\u306a\u3063\u305f\u308a\u53d7\u4fe1\u3067\u304d\u306a\u304b\u3063\u305f\u308a\u3059\u308b\u3002\n        String broadcastAddress = getBroadcastAddress();\n        System.out.println(\"broadcast=\" + broadcastAddress);\n\n        final CountDownLatch latch = new CountDownLatch(1);\n        final int COUNT = 5; // 5\u56de \"Hello\"\u3092\u9001\u4fe1\n\n        // \u53d7\u4fe1\u5074\u30b9\u30ec\u30c3\u30c9\n        new Thread(new Runnable() {\n            @Override\n            public void run() {\n                try {\n                    DatagramChannel recvCh = DatagramChannel.open();\n                    // recvCh.configureBlocking(true); \u521d\u671f\u5024\u304ctrue\u306a\u306e\u3067\u547c\u3076\u5fc5\u8981\u306f\u306a\u3044\u3002\n                    // recvCh.socket().setBroadcast(true); \u53d7\u4fe1\u5074\u306b\u306f\u4e0d\u8981\u3001\u547c\u3076\u5fc5\u8981\u306f\u306a\u3044\u3002\n                    // recvCh.socket().setReuseAddress(true); \u547c\u3076\u5fc5\u8981\u306f\u306a\u3044\u6a21\u69d8\u3002\n                    recvCh.socket().bind(new InetSocketAddress(PORT));\n                    // \u3053\u3053\u3067connect()\u3057\u3066\u306f\u30c0\u30e1\u3002NotYetConnectedException\u3082\u672c\u4ef6\u306b\u306f\u95a2\u4fc2\u306a\u3044\u3002\n\n                    ByteBuffer recvBuf = ByteBuffer.allocate(1024);\n                    for (int i = 0; i < COUNT; i++) {\n                        // \u3053\u3053\u3067receive()\u3058\u3083\u306a\u304f\u3066read()\u3059\u308b\u306e\u306f\u9593\u9055\u3044\u3002\n                        recvCh.receive(recvBuf);\n                        System.out.println(\"receive\");\n                        recvBuf.flip();\n                        int limit = recvBuf.limit();\n                        System.out.println(\"limit=\" + limit);\n                        String hello = new String(recvBuf.array(), recvBuf.position(), limit, \"UTF-8\");\n                        assertEquals(\"Hello\", hello);\n                        recvBuf.clear();\n                    }\n\n                    latch.countDown();\n                    recvCh.close();\n                    System.out.println(\"recvCh close\");\n                } catch (IOException e) {\n                    fail();\n                }\n            }\n        }).start();\n\n        // \u9001\u4fe1\u5074\n        DatagramChannel sendCh = DatagramChannel.open();\n        // recvCh.configureBlocking(true); \u521d\u671f\u5024\u304ctrue\u306a\u306e\u3067\u547c\u3076\u5fc5\u8981\u306f\u306a\u3044\u3002\n        // recvCh.socket().setReuseAddress(true); \u9001\u4fe1\u5074\u306f\u95a2\u4fc2\u306a\u3044\u306e\u3067\u4e0d\u8981\u3002\n        // JDK\u3067\u306f\u4e0d\u8981\u3060\u3063\u305f\u304cAndroid\u3067\u306f\u5fc5\u8981\u3001SocketException EACCES\u304c\u767a\u751f\u3059\u308b\u3002\n        sendCh.socket().setBroadcast(true);\n\n        // ByteBuffer#allocate()+put()\u306e\u5834\u5408\u306f\u9001\u4fe1\u524d\u306bflip()\u304c\u5fc5\u8981\u3060\u304c\u3001\n        // wrap()\u306fflip()\u304c\u4e0d\u8981\u306a\u3053\u3068\u306b\u6ce8\u610f\uff08flip()\u6e08\u307f\u3068\u3044\u3046\u8a00\u3044\u65b9\u304c\u6b63\u3057\u3044\u304b\u3082\uff09\n        ByteBuffer sendBuf = ByteBuffer.wrap(\"Hello\".getBytes(\"UTF-8\"));\n        InetSocketAddress portISA = new InetSocketAddress(broadcastAddress, PORT);\n        for (int i = 0; i < COUNT; i++) {\n            mySleep(200);\n            sendCh.send(sendBuf, portISA);\n            System.out.println(\"send\");\n            sendBuf.clear();\n        }\n        sendCh.close();\n        System.out.println(\"sendCh close\");\n\n        latch.await(30, TimeUnit.SECONDS);\n        assertEquals(0, latch.getCount());\n    }\n\n    // \u53c2\u8003\uff1ahttp://stackoverflow.com/questions/2993874/android-broadcast-address\n    // \u3053\u306e\u30e1\u30bd\u30c3\u30c9\u306f\u898b\u3064\u304b\u3063\u305f\u9806\u306b\u8fd4\u3059\u305f\u3081\u3001WiFi\u5074\u306b\u9650\u5b9a\u3057\u305f\u3044\u969b\u306b\u306f\n    // Android\u306eAPI\u5074WiFiManager\u3042\u305f\u308a\u304b\u3089\u53d6\u5f97\u3059\u308b\u5fc5\u8981\u304c\u3042\u308b\u3002\n    // \u53c2\u8003\uff1ahttps://code.google.com/p/boxeeremote/wiki/AndroidUDP\n    private static final String getBroadcastAddress() {\n        try {\n            for (Enumeration<NetworkInterface> niEnum = NetworkInterface.getNetworkInterfaces(); niEnum.hasMoreElements(); ) {\n                NetworkInterface ni = niEnum.nextElement();\n                if (!ni.isLoopback()) {\n                    for (InterfaceAddress interfaceAddress : ni.getInterfaceAddresses()) {\n                        if (interfaceAddress != null) {\n                            InetAddress broadcastAddress = interfaceAddress.getBroadcast();\n                            if (broadcastAddress != null) {\n                                return broadcastAddress.toString().substring(1);\n                            }\n                        }\n                    }\n                }\n            }\n        } catch (SocketException e) {\n            // ignore;\n        }\n        return null;\n    }\n\n    private static void mySleep(long ms) {\n        try {\n            Thread.sleep(ms);\n        } catch (InterruptedException e) {\n            // ignore;\n        }\n    }\n}\n```\n\nJava\u306enio\u7684\u306b\u30a4\u30de\u30a4\u30c1\u306a\u6c17\u914d\u3082\u3059\u308b\u305f\u3081\u3001\u305d\u306e\u3042\u305f\u308a\u8b58\u8005\u30b3\u30e1\u30f3\u30c8\u3092\u3044\u305f\u3060\u3051\u308b\u3068\u559c\u3073\u307e\u3059\u3002\n\n# sleep\uff08\u30c7\u30a3\u30b9\u30d7\u30ec\u30a4\u30aa\u30d5\uff09\u6642\u306eUDP\u53d7\u4fe1\u306f\u3067\u304d\u306a\u3044\n\n\u95a2\u9023\u3057\u3066\u3001Android\u306fSleep\u6642\u306eUDP\u53d7\u4fe1\u306f\u3067\u304d\u306a\u3044\uff08\u5168\u3066\u306e\u6a5f\u7a2e\u3067\u306f\u306a\u3044\uff1f\uff09\u3053\u3068\u306b\u7559\u610f\u3057\u3066\u304f\u3060\u3055\u3044\u3002\n\nGoogle Group\uff1a\u65e5\u672cAndroid\u306e\u4f1a\uff1a\u7aef\u672b\u30b9\u30ea\u30fc\u30d7\u6642\u306eDiagramSocket\u53d7\u4fe1\u306b\u3064\u3044\u3066\nhttps://groups.google.com/forum/#!topic/android-group-japan/T5M7MqxpnnE\nStack Overflow\uff1aSome devices don't receive UDP broadcasts when screen off\nhttp://stackoverflow.com/questions/19673354/some-devices-dont-receive-udp-broadcasts-when-screen-off\n", "tags": ["Android", "udp", "nio", "broadcast"]}