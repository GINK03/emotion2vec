{"tags": ["Arduino", "AVR"], "context": " More than 1 year has passed since last update.Here is a design of model train detector and speedometer I'm working on.\n\nABSTRACT\n\nMicroprocessor module: Arduino UNO R3\nDetecting trains by photo-reflectors, which lighten IR LED and monitor the change of current caused by IR reflection.\n74151 Logic ICs for channel selection. Arduino 8 pins for sensor input, and 3 pins for channel selection output. 8 x 2^3 = 64 sensors supported.\nRepeated reflection test to improve the reliability.\nSpeedometer capability by calculating the reflection interval.\nTransmitting the packet to the PC is with the help of LocoShield.\n\n\n\nDETECTOR\n\nREQUIREMENTS\n\nMax. Train Speed: 130km/h(actual speed) / 150(model scale) = 240mm/s\nLength of Reflection Sheet beneath Trains: 4mm\nMax. # of sensors: 64\n\n\nSPECS\n\nMin. Reflection Sheet Passing Duration: 4mm / 240mm/s = 16ms\nIR Pulse Length: 0.5ms for each ON/OFF\nReflection Test Repeats: 10 times. Each test increases/decreases the counter between 0 to 10 to avoid jittering.\nDetection Time: 0.5ms x 10 = 5ms < 16ms (requirements fulfilled)\n\n\nDESIGN\n\nStarts scanning sensors 0.2ms after LED switches ON/OFF.\nSends out LocoNet packets while waiting for the scanning time.\nTakes 0.3ms (experimented) to scan all the sensor.\nI(L)~0.40mA (experimented).\nIC=(Vc-VCEsat)/R=0.47mA, large enough for 74HC input.\nIBmin>IC/hFE=0.011mA to saturate TR.\n(I(L)-IBmin)*R>VBEsat to drive TR, hence R>2.13k\nWhen LED gets turned ON, TR is likely to be OFF. The larger R increases IB, which leads to TR's faster turning ON.\nWhen LED gets turned OFF, TR will be eventually turned OFF after a short while. To make Tr<100us, R<10k. Actual Tr is faster due to the remaining TR activity.\n\n\nCIRCUIT\n\n\nBOARDS\nSensor Unit x 64\n\nLED Driver and Sensor Amplifier Board x 2\n\nLocoNet Board x 1\n\n\nSPEEDOMETER\n\n\nREQUIREMENTS\n\nMax. acceleration: 10km/h/s (actual), 18.5mm/s/s (N scaled)\nMax. length of reflection sheet: 20mm\nCurrent thresholds of sensors vary due to the anomalies of electronic components.\nDelay of digital output after crossing the threshold: 5ms\nOccasional missed sensing allowed. Erroneous sensed values not allowed.\n\n\nDESIGN\n\nReflection sheet: 4mm IR-reflecting white area separated by 8mm IR-absorbing black gap. The black gap is long enough to decrease the sensor current under the threshold when the sheet passes at the maximum velocity.\nRecords the latest 4 L/H switching times.\nWhen switching to H, velocities, V1 and V2, are estimated: V1=12mm/BW, V2=12mm/WB\nAt max. acceleration from velocity 0, passing duration for 12mm, T: 18.5*T^2/2=12mm, T=1.14s\nMax. difference between V1 and V2: 18.5mm/s/s * T = 21.09mm/s\nIf |V1 - V2| > 22mm/s, the estimation is considered unreliable, hence the result is ignored.\nIf B > BW * ((8mm+R)/12mm) or B > WB * ((8mm+R)/12mm), it is likely B does not correspond to the 8mm gap but another black area, hence the result is ignored. Relaxing term R=3.\nEstimated velocity: (V1 + V2) / 2\n\n\nCODE\nDraft code.\n#define LCDDEBUG 0\n#define STAYON 0\n\n#include <LocoNet.h>\n\n#if LCDDEBUG\n#include <LiquidCrystal.h>\nstatic LiquidCrystal lcd(12, 11, 5, 4, 3, 2);\n#endif\n\nstatic const byte SENSOR_PIN_COUNT = 8;\nstatic volatile byte *const sensorDDR = &DDRD;\nstatic volatile byte *const sensorPIN = &PIND;\nstatic volatile byte *const sensorPORT = &PORTD;\nstatic volatile byte *const irDDR = &DDRC;\nstatic volatile byte *const irPORT = &PORTC;\nstatic const byte irBit = 0;\nstatic volatile byte *const errorDDR = &DDRC;\nstatic volatile byte *const errorPIN = &PINC;\nstatic volatile byte *const errorPORT = &PORTC;\nstatic const byte errorBit = 1;\nstatic volatile byte *const channelDDR = &DDRB;\nstatic volatile byte *const channelPORT = &PORTB;\nstatic const byte selA = 2;\nstatic const byte selB = 3; \nstatic const byte selC = 4;\nstatic const byte ledPin = 13;\nstatic const byte grayCode[8] = { 0, 1, 3, 2, 6, 7, 5, 4 };\nstatic const byte grayBits[8] = { selC, selA, selB, selA, selC, selA, selB, selA };\nstatic const byte grayState[8] = { LOW, HIGH, HIGH, LOW, HIGH, HIGH, LOW, LOW };\nstatic const unsigned int PULSE_DURATION = 200;\nstatic const byte TEST_TIMES = 10;\nstatic const byte ENTER_SENT_MASK = 0x80;\nstatic const byte PASSING_MASK = 0x40;\nstatic const byte COUNT_MASK = 0x3F;\nstatic const int BLINK_QUEUE_SIZE = 4;\n\nstatic byte irState = LOW;\nstatic byte correctCounts[SENSOR_PIN_COUNT * 8];\nstatic unsigned long blinkTimes[SENSOR_PIN_COUNT * 8 * BLINK_QUEUE_SIZE] = { 0 };\nstatic byte blinkIndexes[SENSOR_PIN_COUNT * 8] = { 0 };\nstatic byte sensorToSend = 0;\nstatic boolean inError = false;\n\nvoid setup() {\n  LocoNet.init(9);\n  cli();\n  *sensorDDR = 0x00; // input\n  *sensorPORT = 0x00; // disables pull-up\n  *irDDR |= _BV(irBit); // output\n  *irPORT &= ~_BV(irBit); // LOW\n  *errorDDR &= ~_BV(errorBit); // input\n  *errorPORT &= ~_BV(errorBit); // disables pull-up\n  *channelDDR |= _BV(selA) | _BV(selB) | _BV(selC); // output\n  *channelPORT &= ~(_BV(selA) | _BV(selB)); // LOW\n  *channelPORT |= _BV(selC); // HIGH\n  sei();\n  pinMode(ledPin, OUTPUT);\n  digitalWrite(ledPin, LOW);\n#if LCDDEBUG\n  lcd.begin(16, 2);\n  lcd.print(TEST_TIMES);\n#endif\n  for (byte sensor = 0; sensor < SENSOR_PIN_COUNT * 8; ++sensor) {\n    correctCounts[sensor] = TEST_TIMES;\n  }\n}\n\nvoid loop() {\n  // check error\n  byte error = (*errorPIN) & _BV(errorBit);\n  if ((error != 0) && !inError) {\n    // turn off IR LED\n    irState = LOW;\n    cli();\n    *irPORT &= ~_BV(irBit);\n    sei();\n    // power off rail\n    lnMsg msg;\n    msg.data[0] = OPC_GPOFF;\n    LocoNet.send(&msg);\n  }\n  inError = (error != 0);\n  if (inError) {\n    return;\n  }\n  // switch IR\n#if STAYON\n  irState = HIGH;\n  cli();\n  *irPORT |= _BV(irBit);\n  sei();\n#else\n  irState ^= HIGH;\n  cli();\n  *irPORT ^= _BV(irBit);\n  sei();\n#endif\n  // send LocoNet packet\n  unsigned long start = micros();\n  unsigned long elapsed = 0;\n  for (byte i = 0, sensor = sensorToSend; i < SENSOR_PIN_COUNT * 8; ++i, ++sensor) {\n    if (sensor == SENSOR_PIN_COUNT * 8) {\n      sensor = 0;\n    }\n    elapsed = micros() - start;\n    if (elapsed >= PULSE_DURATION) {\n      sensorToSend = sensor;\n      break;\n    }\n    byte count = correctCounts[sensor] & COUNT_MASK;\n    byte sent = correctCounts[sensor] & ENTER_SENT_MASK;\n    if (count == 0 && !sent) {\n      // send the Enter packet when repeated test are passed and the packet has not yet been sent.\n      int address = (int)sensor + 1;\n      byte sw1 = (address - 1) >> 1;\n      byte sw2 = (((address - 1) >> 8) & 0x0F) | OPC_SW_REP_INPUTS | (((address - 1) & 0x1) ? OPC_INPUT_REP_SW : 0);\n      LocoNet.send(OPC_INPUT_REP, sw1, sw2 | OPC_INPUT_REP_HI);\n      // do not send the Enter packet again\n      correctCounts[sensor] |= ENTER_SENT_MASK;\n    } else if (count >= TEST_TIMES && sent) {\n      // sent the Leave packet when the Enter packet has been sent and the tests are failed.\n      int address = (int)sensor + 1;\n      byte sw1 = (address - 1) >> 1;\n      byte sw2 = (((address - 1) >> 8) & 0x0F) | OPC_SW_REP_INPUTS | (((address - 1) & 0x1) ? OPC_INPUT_REP_SW : 0);\n      LocoNet.send(OPC_INPUT_REP, sw1, sw2 | 0);\n      // do not send the Leave packet again\n      correctCounts[sensor] &= ~ENTER_SENT_MASK;\n      // calculate the speed\n      byte index = blinkIndexes[sensor];\n      unsigned long *queue = blinkTimes + sensor * BLINK_QUEUE_SIZE;\n      unsigned long whiteblack = queue[(index + 2) % BLINK_QUEUE_SIZE] - queue[(index) % BLINK_QUEUE_SIZE];\n      unsigned long blackwhite = queue[(index + 3) % BLINK_QUEUE_SIZE] - queue[(index + 1) % BLINK_QUEUE_SIZE];\n      unsigned long black = queue[(index + 2) % BLINK_QUEUE_SIZE] - queue[(index + 1) % BLINK_QUEUE_SIZE];\n      unsigned int v2mmPerSec = 12UL * 1000000UL / whiteblack;\n      unsigned int v1mmPerSec = 12UL * 1000000UL / blackwhite;\n#if LCDDEBUG\n      lcd.clear();\n      lcd.setCursor(0, 0);\n      lcd.print(whiteblack / 1000UL);\n//        lcd.print(v2mmPerSec);\n      lcd.setCursor(8, 0);\n      lcd.print(black / 1000UL);\n      lcd.setCursor(0, 1);\n      lcd.print(blackwhite / 1000UL);\n//        lcd.print(v1mmPerSec);*/\n#endif\n      if (abs((int)(v1mmPerSec - v2mmPerSec)) < 22 && black <= min(blackwhite, whiteblack) * 11UL / 12UL) {\n        unsigned int v = (v1mmPerSec + v2mmPerSec) / 2;\n        LocoNet.send(0xBE, (v >> 7) & 0x7F, v & 0x7F);\n#if LCDDEBUG\n        lcd.setCursor(8, 1);\n        lcd.print(v * 150 * 3600UL / 1000000UL);\n#endif\n      }\n    }\n    digitalWrite(ledPin, count == 0 ? HIGH : LOW);\n  }\n  // wait for pulse length\n  if (PULSE_DURATION > elapsed) {\n    delayMicroseconds(PULSE_DURATION - elapsed);\n  }\n  // test the reflection  \n  for (byte gray = 0; gray < 8; ++gray) {\n    cli();\n    *channelPORT ^= _BV(grayBits[gray]); // switch the channel\n    sei();\n    byte channel = grayCode[gray];\n    byte sensorValue = *sensorPIN;\n    for (byte pin = 0; pin < SENSOR_PIN_COUNT; ++pin) {\n      byte sensor = channel + pin * 8;\n      byte count = correctCounts[sensor];\n      if (((sensorValue & _BV(pin)) != 0) != irState) {\n        if ((count & COUNT_MASK) > 0) {\n          count = (count & ~COUNT_MASK) | ((count & COUNT_MASK) - 1);\n          if (count == 0) {\n            if (!(count & PASSING_MASK)) {\n              count |= PASSING_MASK;\n              blinkTimes[sensor * BLINK_QUEUE_SIZE + blinkIndexes[sensor]] = micros();\n              blinkIndexes[sensor] = (blinkIndexes[sensor] + 1) % BLINK_QUEUE_SIZE;\n            }\n          }\n        }\n      } else {\n        if ((count & COUNT_MASK) < TEST_TIMES) {\n          // even when not reflected, each one of two tests is likely to be passed\n          count = (count & ~COUNT_MASK) | ((count & COUNT_MASK) + 2);\n          if (count >= TEST_TIMES) {\n            if (count & PASSING_MASK) {\n              count &= ~PASSING_MASK;\n              blinkTimes[sensor * BLINK_QUEUE_SIZE + blinkIndexes[sensor]] = micros();\n              blinkIndexes[sensor] = (blinkIndexes[sensor] + 1) % BLINK_QUEUE_SIZE;\n            }\n          }\n        }\n      }\n      correctCounts[sensor] = count;\n    }\n  }\n}\n\nvoid printFixedDigits(unsigned long x) {\n#if LCDDEBUG\n  lcd.setCursor(0, 1);\n  lcd.print(x / 10000000 % 10);\n  lcd.print(x / 1000000 % 10);\n  lcd.print(x / 100000 % 10);\n  lcd.print(x / 10000 % 10);\n  lcd.print(x / 1000 % 10);\n  lcd.print(x / 100 % 10);\n  lcd.print(x / 10 % 10);\n  lcd.print(x / 1 % 10);\n#endif\n}\n\nHere is a design of model train detector and speedometer I'm working on.\n\n# ABSTRACT\n\n- Microprocessor module: Arduino UNO R3\n- Detecting trains by photo-reflectors, which lighten IR LED and monitor the change of current caused by IR reflection.\n- 74151 Logic ICs for channel selection. Arduino 8 pins for sensor input, and 3 pins for channel selection output. 8 x 2^3 = 64 sensors supported.\n- Repeated reflection test to improve the reliability.\n- Speedometer capability by calculating the reflection interval.\n- Transmitting the packet to the PC is with the help of [LocoShield](http://www.scuba.net/wiki/index.php/LocoShield).\n\n![speedometer.jpg](https://qiita-image-store.s3.amazonaws.com/0/12670/ad845a05-74f1-0bec-bab4-e5773e9ca48a.jpeg)\n\n# DETECTOR\n\n## REQUIREMENTS\n\n- Max. Train Speed: 130km/h(actual speed) / 150(model scale) = 240mm/s\n- Length of Reflection Sheet beneath Trains: 4mm\n- Max. # of sensors: 64\n\n## SPECS\n\n- Min. Reflection Sheet Passing Duration: 4mm / 240mm/s = 16ms\n- IR Pulse Length: 0.5ms for each ON/OFF\n- Reflection Test Repeats: 10 times. Each test increases/decreases the counter between 0 to 10 to avoid jittering.\n- Detection Time: 0.5ms x 10 = 5ms < 16ms (requirements fulfilled)\n\n## DESIGN\n\n- Starts scanning sensors 0.2ms after LED switches ON/OFF.\n- Sends out LocoNet packets while waiting for the scanning time.\n- Takes 0.3ms (experimented) to scan all the sensor.\n- I(L)~0.40mA (experimented).\n- IC=(Vc-VCEsat)/R=0.47mA, large enough for 74HC input.\n- IBmin>IC/hFE=0.011mA to saturate TR.\n- (I(L)-IBmin)*R>VBEsat to drive TR, hence R>2.13k\n- When LED gets turned ON, TR is likely to be OFF. The larger R increases IB, which leads to TR's faster turning ON.\n- When LED gets turned OFF, TR will be eventually turned OFF after a short while. To make Tr<100us, R<10k. Actual Tr is faster due to the remaining TR activity.\n\n## CIRCUIT\n\n![detector-circuit.png](https://qiita-image-store.s3.amazonaws.com/0/12670/741b2ad8-cf81-3d9d-9ec2-d7d7a49f5a0d.png)\n\n\n## BOARDS\n\nSensor Unit x 64\n![detector-sensor-board.png](https://qiita-image-store.s3.amazonaws.com/0/12670/18f7de57-0ae7-b168-3d6f-a94daac7295a.png)\n\nLED Driver and Sensor Amplifier Board x 2\n![detector-board.png](https://qiita-image-store.s3.amazonaws.com/0/12670/7ed96ab2-41bb-9387-b80b-35cfd2b8dadd.png)\n\nLocoNet Board x 1\n![detector-loconet-board.png](https://qiita-image-store.s3.amazonaws.com/0/12670/4e8d21e6-8a11-8ede-16b5-9d6cbce60e56.png)\n\n# SPEEDOMETER\n\n![speedometer-design.png](https://qiita-image-store.s3.amazonaws.com/0/12670/289b58aa-a58c-940b-488e-b291247f02e0.png)\n\n## REQUIREMENTS\n\n- Max. acceleration: 10km/h/s (actual), 18.5mm/s/s (N scaled)\n- Max. length of reflection sheet: 20mm\n- Current thresholds of sensors vary due to the anomalies of electronic components.\n- Delay of digital output after crossing the threshold: 5ms\n- Occasional missed sensing allowed. Erroneous sensed values not allowed.\n\n## DESIGN\n\n- Reflection sheet: 4mm IR-reflecting white area separated by 8mm IR-absorbing black gap. The black gap is long enough to decrease the sensor current under the threshold when the sheet passes at the maximum velocity.\n- Records the latest 4 L/H switching times.\n- When switching to H, velocities, V1 and V2, are estimated: V1=12mm/BW, V2=12mm/WB\n- At max. acceleration from velocity 0, passing duration for 12mm, T: 18.5*T^2/2=12mm, T=1.14s\n- Max. difference between V1 and V2: 18.5mm/s/s * T = 21.09mm/s\n- If |V1 - V2| > 22mm/s, the estimation is considered unreliable, hence the result is ignored.\n- If B > BW * ((8mm+R)/12mm) or B > WB * ((8mm+R)/12mm), it is likely B does not correspond to the 8mm gap but another black area, hence the result is ignored. Relaxing term R=3.\n- Estimated velocity: (V1 + V2) / 2\n\n# CODE\n\nDraft code.\n\n```c\n#define LCDDEBUG 0\n#define STAYON 0\n\n#include <LocoNet.h>\n\n#if LCDDEBUG\n#include <LiquidCrystal.h>\nstatic LiquidCrystal lcd(12, 11, 5, 4, 3, 2);\n#endif\n\nstatic const byte SENSOR_PIN_COUNT = 8;\nstatic volatile byte *const sensorDDR = &DDRD;\nstatic volatile byte *const sensorPIN = &PIND;\nstatic volatile byte *const sensorPORT = &PORTD;\nstatic volatile byte *const irDDR = &DDRC;\nstatic volatile byte *const irPORT = &PORTC;\nstatic const byte irBit = 0;\nstatic volatile byte *const errorDDR = &DDRC;\nstatic volatile byte *const errorPIN = &PINC;\nstatic volatile byte *const errorPORT = &PORTC;\nstatic const byte errorBit = 1;\nstatic volatile byte *const channelDDR = &DDRB;\nstatic volatile byte *const channelPORT = &PORTB;\nstatic const byte selA = 2;\nstatic const byte selB = 3; \nstatic const byte selC = 4;\nstatic const byte ledPin = 13;\nstatic const byte grayCode[8] = { 0, 1, 3, 2, 6, 7, 5, 4 };\nstatic const byte grayBits[8] = { selC, selA, selB, selA, selC, selA, selB, selA };\nstatic const byte grayState[8] = { LOW, HIGH, HIGH, LOW, HIGH, HIGH, LOW, LOW };\nstatic const unsigned int PULSE_DURATION = 200;\nstatic const byte TEST_TIMES = 10;\nstatic const byte ENTER_SENT_MASK = 0x80;\nstatic const byte PASSING_MASK = 0x40;\nstatic const byte COUNT_MASK = 0x3F;\nstatic const int BLINK_QUEUE_SIZE = 4;\n\nstatic byte irState = LOW;\nstatic byte correctCounts[SENSOR_PIN_COUNT * 8];\nstatic unsigned long blinkTimes[SENSOR_PIN_COUNT * 8 * BLINK_QUEUE_SIZE] = { 0 };\nstatic byte blinkIndexes[SENSOR_PIN_COUNT * 8] = { 0 };\nstatic byte sensorToSend = 0;\nstatic boolean inError = false;\n\nvoid setup() {\n  LocoNet.init(9);\n  cli();\n  *sensorDDR = 0x00; // input\n  *sensorPORT = 0x00; // disables pull-up\n  *irDDR |= _BV(irBit); // output\n  *irPORT &= ~_BV(irBit); // LOW\n  *errorDDR &= ~_BV(errorBit); // input\n  *errorPORT &= ~_BV(errorBit); // disables pull-up\n  *channelDDR |= _BV(selA) | _BV(selB) | _BV(selC); // output\n  *channelPORT &= ~(_BV(selA) | _BV(selB)); // LOW\n  *channelPORT |= _BV(selC); // HIGH\n  sei();\n  pinMode(ledPin, OUTPUT);\n  digitalWrite(ledPin, LOW);\n#if LCDDEBUG\n  lcd.begin(16, 2);\n  lcd.print(TEST_TIMES);\n#endif\n  for (byte sensor = 0; sensor < SENSOR_PIN_COUNT * 8; ++sensor) {\n    correctCounts[sensor] = TEST_TIMES;\n  }\n}\n\nvoid loop() {\n  // check error\n  byte error = (*errorPIN) & _BV(errorBit);\n  if ((error != 0) && !inError) {\n    // turn off IR LED\n    irState = LOW;\n    cli();\n    *irPORT &= ~_BV(irBit);\n    sei();\n    // power off rail\n    lnMsg msg;\n    msg.data[0] = OPC_GPOFF;\n    LocoNet.send(&msg);\n  }\n  inError = (error != 0);\n  if (inError) {\n    return;\n  }\n  // switch IR\n#if STAYON\n  irState = HIGH;\n  cli();\n  *irPORT |= _BV(irBit);\n  sei();\n#else\n  irState ^= HIGH;\n  cli();\n  *irPORT ^= _BV(irBit);\n  sei();\n#endif\n  // send LocoNet packet\n  unsigned long start = micros();\n  unsigned long elapsed = 0;\n  for (byte i = 0, sensor = sensorToSend; i < SENSOR_PIN_COUNT * 8; ++i, ++sensor) {\n    if (sensor == SENSOR_PIN_COUNT * 8) {\n      sensor = 0;\n    }\n    elapsed = micros() - start;\n    if (elapsed >= PULSE_DURATION) {\n      sensorToSend = sensor;\n      break;\n    }\n    byte count = correctCounts[sensor] & COUNT_MASK;\n    byte sent = correctCounts[sensor] & ENTER_SENT_MASK;\n    if (count == 0 && !sent) {\n      // send the Enter packet when repeated test are passed and the packet has not yet been sent.\n      int address = (int)sensor + 1;\n      byte sw1 = (address - 1) >> 1;\n      byte sw2 = (((address - 1) >> 8) & 0x0F) | OPC_SW_REP_INPUTS | (((address - 1) & 0x1) ? OPC_INPUT_REP_SW : 0);\n      LocoNet.send(OPC_INPUT_REP, sw1, sw2 | OPC_INPUT_REP_HI);\n      // do not send the Enter packet again\n      correctCounts[sensor] |= ENTER_SENT_MASK;\n    } else if (count >= TEST_TIMES && sent) {\n      // sent the Leave packet when the Enter packet has been sent and the tests are failed.\n      int address = (int)sensor + 1;\n      byte sw1 = (address - 1) >> 1;\n      byte sw2 = (((address - 1) >> 8) & 0x0F) | OPC_SW_REP_INPUTS | (((address - 1) & 0x1) ? OPC_INPUT_REP_SW : 0);\n      LocoNet.send(OPC_INPUT_REP, sw1, sw2 | 0);\n      // do not send the Leave packet again\n      correctCounts[sensor] &= ~ENTER_SENT_MASK;\n      // calculate the speed\n      byte index = blinkIndexes[sensor];\n      unsigned long *queue = blinkTimes + sensor * BLINK_QUEUE_SIZE;\n      unsigned long whiteblack = queue[(index + 2) % BLINK_QUEUE_SIZE] - queue[(index) % BLINK_QUEUE_SIZE];\n      unsigned long blackwhite = queue[(index + 3) % BLINK_QUEUE_SIZE] - queue[(index + 1) % BLINK_QUEUE_SIZE];\n      unsigned long black = queue[(index + 2) % BLINK_QUEUE_SIZE] - queue[(index + 1) % BLINK_QUEUE_SIZE];\n      unsigned int v2mmPerSec = 12UL * 1000000UL / whiteblack;\n      unsigned int v1mmPerSec = 12UL * 1000000UL / blackwhite;\n#if LCDDEBUG\n      lcd.clear();\n      lcd.setCursor(0, 0);\n      lcd.print(whiteblack / 1000UL);\n//        lcd.print(v2mmPerSec);\n      lcd.setCursor(8, 0);\n      lcd.print(black / 1000UL);\n      lcd.setCursor(0, 1);\n      lcd.print(blackwhite / 1000UL);\n//        lcd.print(v1mmPerSec);*/\n#endif\n      if (abs((int)(v1mmPerSec - v2mmPerSec)) < 22 && black <= min(blackwhite, whiteblack) * 11UL / 12UL) {\n        unsigned int v = (v1mmPerSec + v2mmPerSec) / 2;\n        LocoNet.send(0xBE, (v >> 7) & 0x7F, v & 0x7F);\n#if LCDDEBUG\n        lcd.setCursor(8, 1);\n        lcd.print(v * 150 * 3600UL / 1000000UL);\n#endif\n      }\n    }\n    digitalWrite(ledPin, count == 0 ? HIGH : LOW);\n  }\n  // wait for pulse length\n  if (PULSE_DURATION > elapsed) {\n    delayMicroseconds(PULSE_DURATION - elapsed);\n  }\n  // test the reflection  \n  for (byte gray = 0; gray < 8; ++gray) {\n    cli();\n    *channelPORT ^= _BV(grayBits[gray]); // switch the channel\n    sei();\n    byte channel = grayCode[gray];\n    byte sensorValue = *sensorPIN;\n    for (byte pin = 0; pin < SENSOR_PIN_COUNT; ++pin) {\n      byte sensor = channel + pin * 8;\n      byte count = correctCounts[sensor];\n      if (((sensorValue & _BV(pin)) != 0) != irState) {\n        if ((count & COUNT_MASK) > 0) {\n          count = (count & ~COUNT_MASK) | ((count & COUNT_MASK) - 1);\n          if (count == 0) {\n            if (!(count & PASSING_MASK)) {\n              count |= PASSING_MASK;\n              blinkTimes[sensor * BLINK_QUEUE_SIZE + blinkIndexes[sensor]] = micros();\n              blinkIndexes[sensor] = (blinkIndexes[sensor] + 1) % BLINK_QUEUE_SIZE;\n            }\n          }\n        }\n      } else {\n        if ((count & COUNT_MASK) < TEST_TIMES) {\n          // even when not reflected, each one of two tests is likely to be passed\n          count = (count & ~COUNT_MASK) | ((count & COUNT_MASK) + 2);\n          if (count >= TEST_TIMES) {\n            if (count & PASSING_MASK) {\n              count &= ~PASSING_MASK;\n              blinkTimes[sensor * BLINK_QUEUE_SIZE + blinkIndexes[sensor]] = micros();\n              blinkIndexes[sensor] = (blinkIndexes[sensor] + 1) % BLINK_QUEUE_SIZE;\n            }\n          }\n        }\n      }\n      correctCounts[sensor] = count;\n    }\n  }\n}\n\nvoid printFixedDigits(unsigned long x) {\n#if LCDDEBUG\n  lcd.setCursor(0, 1);\n  lcd.print(x / 10000000 % 10);\n  lcd.print(x / 1000000 % 10);\n  lcd.print(x / 100000 % 10);\n  lcd.print(x / 10000 % 10);\n  lcd.print(x / 1000 % 10);\n  lcd.print(x / 100 % 10);\n  lcd.print(x / 10 % 10);\n  lcd.print(x / 1 % 10);\n#endif\n}\n```\n"}