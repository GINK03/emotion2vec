{"context": " More than 1 year has passed since last update.\n\n\u3053\u306e\u9593\u3001Linux\u3082\u304f\u3082\u304f\u4f1a\u306b\u884c\u3063\u3066\u304d\u307e\u3057\u305f\u3002\n2\u70b9\u5f8c\u6094\u3057\u307e\u3057\u305f\u3002\u6669\u98ef\u3092\u4e8b\u524d\u306b\u98df\u3079\u3066\u304a\u3051\u3070\u3088\u304b\u3063\u305f\u3068\u3044\u3046\u70b9\u304c\u3072\u3068\u3064\u3001\u3082\u3046\u3072\u3068\u3064\u306f\u3082\u3063\u3068\u30d0\u30c3\u30c6\u30ea\u30fc\u306e\u6301\u3061\u304c\u826f\u3044\u30ce\u30fc\u30c8PC\u3092\u8cb7\u3046\u3079\u304d\u3067\u3059\u3002\nMBA\u6301\u3064\u4eba\u304c\u5897\u3048\u3064\u3064\u3042\u308b\u306e\u3082\u308f\u304b\u308a\u307e\u3059...\u3002\n\u307e\u3042\u3001\u305d\u308c\u306f\u63aa\u3044\u3066\u3002\u3082\u304f\u3082\u304f\u4f1a\u3067\u30bd\u30fc\u30b9\u8aad\u3093\u3060\u8a18\u9332\u3092\u6b8b\u3057\u307e\u3059\u3002\n\nACPI\u5468\u308a\n\u7d44\u307f\u8fbc\u307f\u3068\u304b\u3067\u3053\u306e\u3042\u305f\u308a\u306b\u95a2\u308f\u3063\u305f\u4eba\u306f\u3001\u8272\u3005\u3068\u9762\u5012\u306a\u3053\u3068\u306b\u306a\u308a\u307e\u3059(\u7b11)\u3002\u3061\u3087\u3063\u3068\u30d0\u30b0\u308b\u3068\u30b9\u30c8\u30fc\u30eb\u3059\u308b\u3001\u307e\u3055\u306b\u30b9\u30da\u30e9\u30f3\u30ab\u30fc\u306e\u3088\u3046\u306a\u4e16\u754c\u304c\u5c55\u958b\u3055\u308c\u307e\u3059\u3002\n\u79c1\u306f\u8077\u696d\u67c4NetBSD\u304c\u30e1\u30a4\u30f3\u3067\u3059\u304c\u3001Linux\u306f\u3069\u3046\u306a\u3063\u3066\u308b\u306e\u304b\u306a\u30fc\u3001\u3068\u6c17\u306b\u306a\u3063\u305f\u6b21\u7b2c\u3002\n\u30ad\u30fc\u30ef\u30fc\u30c9\u3067\u601d\u3044\u3064\u304f\u306e\u306f...Power Management\u30e2\u30fc\u30c9\u306e\u4e00\u3064\u3001S3 State\u3092\u30ad\u30fc\u30ef\u30fc\u30c9\u306b\u30bd\u30fc\u30b9\u306e\u5728\u308a\u51e6\u3092\u63a2\u3063\u3066\u307f\u307e\u3059\u3002\neria@eria-thinkpad:~/source/linux-3.19 % grep -rIi \"S3 state\" *\narch/x86/include/asm/cpufeature.h:#define X86_FEATURE_NONSTOP_TSC_S3 ( 3*32+30) /* TSC doesn't stop in S3 state */\ndrivers/ide/Kconfig:      machines ACPI support is required to properly handle ACPI S3 states.\nkernel/power/Kconfig:     suspend-to-RAM state (e.g. the ACPI S3 state).\n\nkernel/power\u306e\u4e0b\u3092\u8997\u3051\u3070\u826f\u3055\u305d\u3046\u3067\u3059\u3002\neria@eria-thinkpad:~/source/linux-3.19/kernel/power % ls\nKconfig         console.c       poweroff.c      suspend.c       wakelock.c\nMakefile        hibernate.c     process.c       suspend_test.c\nautosleep.c     main.c          qos.c           swap.c\nblock_io.c      power.h         snapshot.c      user.c\neria@eria-thinkpad:~/source/linux-3.19/kernel/power % pwd\n/usr/home/eria/source/linux-3.19/kernel/power\n\n\u3055\u3063\u305d\u304f\u30bd\u30fc\u30b9\u3092\u30c1\u30e9\u898b\u3057\u307e\u3057\u3087\u3046\u3002(\u66f8\u304d\u5fd8\u308c\u307e\u3057\u305f\u304c\u3001\u30bd\u30fc\u30b9\u306e\u30d0\u30fc\u30b8\u30e7\u30f3\u306f\u30013.19\u3092\u57fa\u306b\u3057\u3066\u3044\u307e\u3059\u3002)\n\u307e\u305a\u306f\u3001\u6700\u521d\u306b\u898b\u308d\u3068\u3044\u308f\u3093\u3070\u304b\u308a\u306e\u3001main.c\u3092\u898b\u307e\u3059\u3002\n\nkernel/power/main.c\n#ifdef CONFIG_PM_SLEEP\n\n/* Routines for PM-transition notifications */\n\nstatic BLOCKING_NOTIFIER_HEAD(pm_chain_head);\n\nint register_pm_notifier(struct notifier_block *nb)\n{\n    return blocking_notifier_chain_register(&pm_chain_head, nb);\n}\nEXPORT_SYMBOL_GPL(register_pm_notifier);\n\nint unregister_pm_notifier(struct notifier_block *nb)\n{\n    return blocking_notifier_chain_unregister(&pm_chain_head, nb);\n}\nEXPORT_SYMBOL_GPL(unregister_pm_notifier);\n\nint pm_notifier_call_chain(unsigned long val)\n{\n    int ret = blocking_notifier_call_chain(&pm_chain_head, val, NULL);\n\n    return notifier_to_errno(ret);\n}\n\n/* \u7565 */\n\n/* If set, devices may be suspended and resumed asynchronously. */\nint pm_async_enabled = 1;\n\nstatic ssize_t pm_async_show(struct kobject *kobj, struct kobj_attribute *attr,\n                 char *buf)\n{\n    return sprintf(buf, \"%d\\n\", pm_async_enabled);\n}\n\nstatic ssize_t pm_async_store(struct kobject *kobj, struct kobj_attribute *attr,\n                  const char *buf, size_t n)\n{\n    unsigned long val;\n\n    if (kstrtoul(buf, 10, &val))\n        return -EINVAL;\n\n    if (val > 1)\n        return -EINVAL;\n\n    pm_async_enabled = val;\n    return n;\n}\n\n\nsuspend\u3068resume\u3001BSD\u7cfb\u306eACPI\u5b9f\u88c5\u8aad\u3093\u3060\u7d4c\u9a13\u304b\u3089\u3001Power Management\u30e2\u30fc\u30c9\u9077\u79fb\u6642\u306b\u547c\u3070\u308c\u308b\u30d5\u30c3\u30af\u95a2\u6570\u3068\u63a8\u5b9a\u3002\n(main.c\u8aad\u3093\u3067\u3001\u30b0\u30ed\u30fc\u30d0\u30eb\u5909\u6570\u306e\u5225\u30b3\u30fc\u30c9\u304b\u3089\u306e\u76f4\u30a2\u30af\u30bb\u30b9\u306f\u500b\u4eba\u7684\u306b\u6c17\u306b\u306a\u3063\u305f\u30fb\u30fb\u30fb)\n\u6b21\u306b\u6765\u308b\u306e\u306f\u3001ifdef\u306e\u30e9\u30d9\u30eb\u540d\u304b\u3089\u30c7\u30d0\u30c3\u30b0\u30b3\u30fc\u30c9\u3068\u601d\u308f\u308c\u308b\u306e\u3067\u3001\u7701\u7565\u3057\u307e\u3059\u3002\n\nkernel/power/main.c\nstruct kobject *power_kobj;\n\n\n/**\n * state - control system sleep states.\n *\n * show() returns available sleep state labels, which may be \"mem\", \"standby\",\n * \"freeze\" and \"disk\" (hibernation).  See Documentation/power/states.txt for a\n * description of what they mean.\n *\n * store() accepts one of those strings, translates it into the proper\n * enumerated value, and initiates a suspend transition.\n */\n\n\nshow()\u306f\u5358\u306a\u308b\u60c5\u5831\u8868\u793a\u3068\u601d\u308f\u308c\u3001\u8aad\u3093\u3067\u3082\u3042\u307e\u308a\u9762\u767d\u304f\u306a\u3055\u305d\u3046\u3067\u3059\u3002\u306a\u306e\u3067\u3001\u6b21\u306estore()\u3092\u8aad\u307f\u307e\u3059\u3002\n\nkernel/power/main.c\nstatic ssize_t state_store(struct kobject *kobj, struct kobj_attribute *attr,\n               const char *buf, size_t n)\n{\n    suspend_state_t state;\n    int error;\n\n    error = pm_autosleep_lock();\n    if (error)\n        return error;\n\n    if (pm_autosleep_state() > PM_SUSPEND_ON) {\n        error = -EBUSY;\n        goto out;\n    }\n\n    state = decode_state(buf, n);\n    if (state < PM_SUSPEND_MAX)\n        error = pm_suspend(state);\n    else if (state == PM_SUSPEND_MAX)\n        error = hibernate();\n    else\n        error = -EINVAL;\n\n out:\n    pm_autosleep_unlock();\n    return error ? error : n;\n}\n\n\n\u3064\u307e\u308a\u3001state\u304cPM_SUSPEND_MAX\u306a\u3089\u3001hibernate()\u304c\u547c\u3070\u308c\u3001\u305d\u3046\u3067\u306a\u3044\u306e\u306a\u3089pm_suspend()\u304c\u547c\u3070\u308c\u308b\u5b9f\u306b\u7c21\u5358\u306a\u30b3\u30fc\u30c9\u3002\n\u4eca\u306f\u63aa\u3044\u3066\u3001main.c\u3092\u5148\u306b\u9032\u3080\u3002\n\u30b3\u30e1\u30f3\u30c8\u304c\u9577\u3044\u3002\n\nkernel/power/main.c\n/*\n * The 'wakeup_count' attribute, along with the functions defined in\n * drivers/base/power/wakeup.c, provides a means by which wakeup events can be\n * handled in a non-racy way.\n *\n\n\n\u3053\u306e\u8a18\u8ff0\u3067\u3001Linux\u306ePower Management\u6a5f\u80fd\u306fkernel\u306e\u6a5f\u80fd\u3060\u3051\u3067\u306a\u304f\u3001\u30c9\u30e9\u30a4\u30d0\u304c\u4ecb\u5728\u3057\u3066\u3044\u305d\u3046\u306a\u3053\u3068\u304c\u308f\u304b\u308b\u3002\n\nkernel/power/main.c\n * If a wakeup event occurs when the system is in a sleep state, it simply is\n * woken up.  In turn, if an event that would wake the system up from a sleep\n * handled in a non-racy way.\n *\n * If a wakeup event occurs when the system is in a sleep state, it simply is\n * woken up.  In turn, if an event that would wake the system up from a sleep\n * state occurs when it is undergoing a transition to that sleep state, the\n * transition should be aborted.  Moreover, if such an event occurs when the\n * system is in the working state, an attempt to start a transition to the\n * given sleep state should fail during certain period after the detection of\n *\n * If a wakeup event occurs when the system is in a sleep state, it simply is\n * woken up.  In turn, if an event that would wake the system up from a sleep\n * state occurs when it is undergoing a transition to that sleep state, the\n * transition should be aborted.  Moreover, if such an event occurs when the\n * system is in the working state, an attempt to start a transition to the\n * given sleep state should fail during certain period after the detection of\n * the event.  Using the 'state' attribute alone is not sufficient to satisfy\n * these requirements, because a wakeup event may occur exactly when 'state'\n * is being written to and may be delivered to user space right before it is\n * frozen, so the event will remain only partially processed until the system is\n * woken up by another event.  In particular, it won't cause the transition to\n * a sleep state to be aborted.\n *\n * This difficulty may be overcome if user space uses 'wakeup_count' before\n * writing to 'state'.  It first should read from 'wakeup_count' and store\n * the read value.  Then, after carrying out its own preparations for the system\n * transition to a sleep state, it should write the stored value to\n * 'wakeup_count'.  If that fails, at least one wakeup event has occurred since\n * 'wakeup_count' was read and 'state' should not be written to.  Otherwise, it\n * is allowed to write to 'state', but the transition will be aborted if there\n * are any wakeup events detected after 'wakeup_count' was written to.\n */\n\n\n\u8d85\u9577\u3044\u304c\u3001\u8981\u3059\u308b\u306b\u300cWake -> sleep\u306b\u9077\u79fb\u3059\u308b\u9014\u4e2d\u306eWakeup\u30a4\u30d9\u30f3\u30c8...sleep\u9077\u79fb\u3092\u30a2\u30dc\u30fc\u30c8\u3059\u3079\u304d\u300d\u300cWorking state\u6642\u306bWakeup\u30a4\u30d9\u30f3\u30c8\u304c\u8d77\u304d\u305f\u3089\u3001sleep\u306b\u9077\u79fb\u3059\u3079\u304d\u3067\u306a\u3044\u300d\u3068\u3044\u3046\u3053\u3068\u3002\n\u8981\u3059\u308b\u306bPower Management\u306e\u72b6\u614b\u9077\u79fb\u6642\u306b\u3001\u3055\u3089\u306b\u72b6\u614b\u9077\u79fb\u306e\u8981\u56e0\u3068\u306a\u308b\u30a4\u30d9\u30f3\u30c8\u304c\u8d77\u304d\u305f\u3068\u304d\u306e\u30dd\u30ea\u30b7\u30fc\u304c\u8ff0\u3079\u3089\u308c\u3066\u3044\u307e\u3059\u3002\n\u30e6\u30fc\u30b6\u304c\u30b7\u30b9\u30c6\u30e0\u3092\u4f7f\u3046\u306e\u3060\u304b\u3089\u3001\u6975\u529b\u4f7f\u3048\u308b\u3088\u3046\u306a\u72b6\u614b\u306b\u3059\u3079\u3057\u3001\u3068\u3044\u3046\u30dd\u30ea\u30b7\u30fc\u304c\u8aad\u307f\u53d6\u308c\u307e\u3059\u306d\u3002\n\u30b3\u30e1\u30f3\u30c8\u306e\u7d9a\u304d\u8aad\u307f\u307e\u3059\u3002\n\nkernel/power/main.c\n * This difficulty may be overcome if user space uses 'wakeup_count' before\n * writing to 'state'.  It first should read from 'wakeup_count' and store\n * the read value.  Then, after carrying out its own preparations for the system\n * transition to a sleep state, it should write the stored value to\n * 'wakeup_count'.  \n\n\n\u3053\u3053\u304b\u3089\u4f3a\u3048\u308b\u3053\u3068\u306f\u3001\u300c\u4f55\u3089\u304b\u306e\u30e6\u30fc\u30b6\u30d7\u30ed\u30bb\u30b9\u304c\u3001Power Management\u306e\u5236\u5fa1\u306b\u95a2\u308f\u3063\u3066\u3044\u308b\u3002\u305d\u3057\u3066\u3001\u72b6\u614b\u9077\u79fb\u306e\u30cf\u30f3\u30c9\u30ea\u30f3\u30b0\u306fwakeup_count\u3068state\u3092\u4f7f\u3063\u3066\u30e6\u30fc\u30b6\u30d7\u30ed\u30bb\u30b9\u304c\u884c\u3063\u3066\u3044\u308b\u3068\u3044\u3046\u3053\u3068\u300d\u304c\u8aad\u307f\u53d6\u308c\u307e\u3059\u3002\n\u4ed5\u69d8\u66f8\u304c\u306a\u3044\u30bd\u30d5\u30c8\u3092\u8aad\u3080\u969b\u306b\u3001\u30b3\u30e1\u30f3\u30c8\u306f\u9762\u5012\u81ed\u304c\u3089\u305a\u306b\u8aad\u3080\u3002\n\u7279\u306bOSS\u306e\u30b3\u30fc\u30c9\u5185\u306e\u9577\u3044\u30b3\u30e1\u30f3\u30c8\u306f\u6b8b\u5ff5SIer\u306e\u300ci\u306b1\u3092\u4ee3\u5165\u3059\u308b\u300d\u7684\u306a\u30b3\u30e1\u30f3\u30c8\u3068\u9055\u3044\u3001\u4f55\u3089\u304b\u306e\u91cd\u8981\u306a\u610f\u5473\u304c\u3042\u308b\u3068\u5fc3\u5f97\u308b\u3068\u3053\u308d\u3001\u5927\u4e8b\u3067\u3059\u306d\u3002\n\nkernel/power/main.c\nstatic ssize_t wakeup_count_store(struct kobject *kobj,\n                struct kobj_attribute *attr,\n                const char *buf, size_t n)\n{\n/* \u7565 */\n    if (sscanf(buf, \"%u\", &val) == 1) {\n        if (pm_save_wakeup_count(val))\n            error = n;\n        else\n            pm_print_active_wakeup_sources();\n    }\n\n\n\n\u57fa\u672c\u306f\u53d7\u3051\u53d6\u3063\u305fsigned integer\u3092wakeup_count\u3068\u3044\u3046\u30d1\u30e9\u30e1\u30fc\u30bf\u306b\u30bb\u30c3\u30c8\u3059\u308b\u3068\u3044\u3046\u3053\u3068\u306d\u3002\u3053\u308c\u304c\u4f55\u304b\u306f\u4eca\u5f8c\u308f\u304b\u3063\u3066\u304f\u308b\u3067\u3057\u3087\u3046\u3002\n\nkernel/power/main.c\n#ifdef CONFIG_PM_AUTOSLEEP\n\n\n\u3053\u306eifdef\u3067\u56f2\u307e\u308c\u3066\u3044\u308b\u30b3\u30fc\u30c9\u306f\u4f55\u3060\u308d\u3046\u304b\u3002\n\u3084\u3063\u3066\u3044\u308b\u3053\u3068\u306f\u5148\u306b\u8a18\u8f09\u3057\u305fshow\u3068set\u3068\u3042\u307e\u308a\u5909\u308f\u3089\u306a\u3044\u3002\n\u3053\u306e\u3088\u3046\u306a\u611f\u3058\u3067\u3001\u6570\u500b\u306eifdef\u304c\u4e26\u3073\u3001\u540c\u3058\u3088\u3046\u306a\u3053\u3068\u304c\u7e70\u308a\u8fd4\u3055\u308c\u3066\u3044\u308b\u3002\n\nkernel/power/main.c\nstatic struct attribute * g[] = {\n    &state_attr.attr,\n#ifdef CONFIG_PM_TRACE\n    &pm_trace_attr.attr,\n    &pm_trace_dev_match_attr.attr,\n#endif\n#ifdef CONFIG_PM_SLEEP\n    &pm_async_attr.attr,\n    &wakeup_count_attr.attr,\n#ifdef CONFIG_PM_AUTOSLEEP\n    &autosleep_attr.attr,\n#endif\n#ifdef CONFIG_PM_WAKELOCKS\n    &wake_lock_attr.attr,\n    &wake_unlock_attr.attr,\n#endif\n#ifdef CONFIG_PM_DEBUG\n    &pm_test_attr.attr,\n#endif\n#ifdef CONFIG_PM_SLEEP_DEBUG\n    &pm_print_times_attr.attr,\n#endif\n#ifdef CONFIG_FREEZER\n    &pm_freeze_timeout_attr.attr,\n#endif\n    NULL,\n};\n\n\n\u3053\u308c\u3067\u540c\u3058\u3088\u3046\u306a\u5b9f\u88c5\u304c\u7d9a\u304f\u8b0e\u304c\u89e3\u3051\u305f\u3002show()\u3068set()\u3092\u95a2\u6570\u30dd\u30a4\u30f3\u30bf\u4f7f\u3063\u3066\u547c\u3073\u5206\u3051\u3066\u3044\u308b\u3002\n\u3053\u308c\u3089I/F\u3092sysfs\u3092\u7528\u3044\u3066\u30e6\u30fc\u30b6\u30e9\u30f3\u30c9\u306b\u898b\u305b\u3066\u3044\u308b\u306e\u304c\u3001\u4ee5\u4e0b\u306e\u521d\u671f\u5316\u30b3\u30fc\u30c9\u3067\u3042\u308b\u3068\u601d\u308f\u308c\u308b\u3002\n\nkernel/power/main.c\nstatic struct attribute_group attr_group = {\n    .attrs = g,\n};\n\nstruct workqueue_struct *pm_wq;\nEXPORT_SYMBOL_GPL(pm_wq);\n\nstatic int __init pm_start_workqueue(void)\n{\n    pm_wq = alloc_workqueue(\"pm\", WQ_FREEZABLE, 0);\n\n    return pm_wq ? 0 : -ENOMEM;\n}\n\nstatic int __init pm_init(void)\n{\n    int error = pm_start_workqueue();\n    if (error)\n        return error;\n    hibernate_image_size_init();\n    hibernate_reserved_size_init();\n    hibernate_reserved_size_init();\n    power_kobj = kobject_create_and_add(\"power\", NULL);\n    if (!power_kobj)\n        return -ENOMEM;\n    error = sysfs_create_group(power_kobj, &attr_group);\n    if (error)\n        return error;\n    pm_print_times_init();\n    return pm_autosleep_init();\n}\n\n\nsysfs\u306f\u3001\u4ee5\u4e0b\u306e\u3068\u304a\u308a\u3001BSD\u306esysctl\u306e\u3088\u3046\u306a\u3082\u306e\u3067\u3059\u3002\nhttp://ja.wikipedia.org/wiki/Sysfs\n\u3042\u3068\u3001kobject\u3082\u4ee5\u4e0b\u88dc\u8db3\u3057\u307e\u3059\u3002\nhttp://wiki.bit-hive.com/north/pg/sysfs%A4%C8kobject\nhttp://dev.ariel-networks.com/Members/ohyama/i-o-30b930b130e530fc30e9306e-sysfs-30a830f330c830ea306b306430443066306e307e30683081/\n\u300csysfs \u306e\u30c7\u30a3\u30ec\u30af\u30c8\u30ea\u30d5\u30a1\u30a4\u30eb\u306f kobject \u3068\u3044\u3046\u30c7\u30fc\u30bf\u69cb\u9020\u3067\u8868\u73fe\u3055\u308c\u3001\u5404 kobject \u306b\u5c5e\u6027 (attribute) \u60c5\u5831\u304c\u3076\u3089\u4e0b\u304c\u308a\u3001\u3053\u308c\u304c\u30d5\u30a1\u30a4\u30eb\u3068\u3044\u3046\u5f62\u3067\u30e6\u30fc\u30b6\u306b\u63d0\u4f9b\u3055\u308c\u3066\u3044\u307e\u3059\u3002\u300d\u3068\u3044\u3046\u8a18\u8ff0\u304b\u3089\u3001\u5148\u306e\u63a8\u5b9a\u306f\u6b63\u3057\u305d\u3046\u3067\u3059\u3002\n\nDocumentation\n\u96f0\u56f2\u6c17\u306f\u4f55\u3068\u306a\u304f\u3064\u304b\u3081\u3066\u304d\u305f\u304c\u3001\u66f4\u306b\u305d\u308c\u3092\u660e\u78ba\u306b\u3057\u305f\u3044\u3067\u3059\u3002\n\u305d\u3053\u3067\u3001\u5148\u306e\u30b3\u30e1\u30f3\u30c8\u5185\u3067\u8a00\u53ca\u3055\u308c\u3066\u3044\u305fDocumentation\u3092\u8aad\u3093\u3067\u307f\u307e\u3059\u3002\n\nDocumentation/power/states.txt\nstate:      Suspend-To-Idle\nACPI state: S0\nLabel:      \"freeze\"\n\n\n\u3053\u308c\u306f\u3001Linux\u5185\u3067\u30b5\u30dd\u30fc\u30c8\u3055\u308c\u3066\u3044\u308bPower State\u306e\u8aac\u660e\u3067\u3001\u300cSuspend-To-Idle\u300d\u306e\u8aac\u660e\u3067\u3059\u3002ACPI state\u306fS0\u306a\u306e\u3067\u3001ACPI\u304b\u3089\u898b\u308b\u3068\u7701\u30a8\u30cd\u72b6\u614b\u3067\u306f\u3042\u308a\u307e\u305b\u3093\u3002\n\u3064\u307e\u308a\u3001Suspend-To-Idle\u306fACPI\u5168\u304f\u95a2\u4fc2\u3042\u308a\u307e\u305b\u3093\u3002\n\nDocumentation/power/states.txt\nmore energy to be saved relative to runtime idle by freezing user space and putting all I/O devices into low-power states\n\n\n\u4e0a\u8a18\u306efreezing user space\u306e\u8a71\u306f\u3059\u3054\u304f\u6c17\u306b\u306a\u308a\u307e\u3059\u3002\u5358\u306bidle-thread\u304c\u52d5\u3044\u3066\u307e\u3059\u3088\u7684\u306a\u8a71\u306a\u306e\u304b\u3001\u305d\u308c\u3068\u3082\u30e6\u30fc\u30b6\u30e9\u30f3\u30c9\u306e\u30d7\u30ed\u30bb\u30b9\u3092\u672c\u5f53\u306b\u52d5\u3051\u306a\u304f(=\u30b9\u30b1\u30b8\u30e5\u30fc\u30ea\u30f3\u30b0\u3055\u308c\u306a\u304f)\u3059\u308b\u306e\u304b\u306f\u308f\u304b\u308a\u307e\u305b\u3093\u3002\n\nDocumentation/power/states.txt\nState:      Standby / Power-On Suspend\nACPI State: S1\nLabel:      \"standby\"\n\nIn addition to freezing user space and putting all I/O devices into low-power states, which is done for Suspend-To-Idle too, nonboot CPUs are taken offline and all low-level system functions are suspended during transitions into this state.\n\n\n\u4f7f\u3063\u3066\u306a\u3044\u30b3\u30a2\u3092offline\u3001low level system\u6a5f\u80fd\u3068\u6b62\u3081\u308b\u3088\u3046\u306a\u8a18\u8f09\u304c\u3042\u308a\u307e\u3059\u3002\u30d6\u30fc\u30c8\u306b\u4f7f\u308f\u308c\u305f\u30b3\u30a2\u306e\u307f\u3092\u6d3b\u304b\u3057\u3001\u5f8c\u306e\u30b3\u30a2\u3092\u505c\u6b62\u3059\u308b\u3088\u3046\u306b\u3082\u898b\u3048\u307e\u3059\u3002\n\u6b21\u306f\u3001S3 state\u3002\u3044\u308f\u3086\u308bSuspend-To-RAM\u3067\u3001\u5e73\u305f\u304f\u8a00\u3048\u3070CPU\u3092OFF\u3057\u3001RAM\u3092\u30bb\u30eb\u30d5\u30ea\u30d5\u30ec\u30c3\u30b7\u30e5\u30e2\u30fc\u30c9\u3068\u3044\u3044\u3046\u30e2\u30fc\u30c9\u306b\u9077\u79fb\u3055\u305b\u3001RAM\u306e\u5185\u5bb9\u3092\u6b8b\u3059\u3088\u3046\u306b\u3057\u307e\u3059\u3002\n\u3042\u3068\u3001S4 state\u306fSuspend-To-Disk\u3002RAM\u306e\u5185\u5bb9\u3092\u30c7\u30a3\u30b9\u30af\u306b\u66f8\u3044\u3066\u96fb\u6e90\u3092\u5207\u308b\u3088\u3046\u306a\u30e2\u30fc\u30c9\u3067\u3059\u3002\n\u3053\u3053\u306b\u8a00\u53ca\u304c\u3042\u308b\u300cfirmware\u300d\u3084\u300canother operating system\u300d\u306f\u73fe\u6642\u70b9\u3067\u306f\u3088\u304f\u308f\u304b\u308a\u307e\u305b\u3093\u3002\n\nDocumentation/power/states.txt\nState:      Suspend-to-RAM\nACPI State: S3\nLabel:      \"mem\"\n\nThis state, if supported, offers significant power savings as everything in the system is put into a low-power state, except for memory, which should be placed into the self-refresh mode to retain its contents.  \n\nState:      Suspend-to-disk\nACPI State: S4\nLabel:      \"disk\"\n\nSTD can be handled by the firmware or the kernel. If it is handled by the firmware, it usually requires a dedicated partition that must be setup via another operating system for it to use. Despite the inconvenience, this method requires minimal work by the kernel, since\u3000the firmware will also handle restoring memory contents on resume.\n\n\n\u4ee5\u4e0bsuspend-to-swap\u306e\u4ed5\u7d44\u307f\u306e\u3072\u3068\u3064\u3067\u3042\u308b\u300cswsusp\u300d\u3082\u6c17\u306b\u306a\u308a\u307e\u3059\u3002\u7279\u306bswap\u3068\u3069\u306e\u3088\u3046\u306b\u7d71\u5408\u3055\u308c\u3001\u9055\u3044(\u5236\u7d04)\u306f\u4f55\u304b\u3068\u3044\u3046\u3068\u3053\u308d\u3082\u8208\u5473\u6df1\u3044\u3067\u3059\u3002\n\nDocumentation/power/states.txt\nFor suspend-to-disk, a mechanism called 'swsusp' (Swap Suspend) is used to write memory contents to free swap space. swsusp has some restrictive requirements, but should work in most cases. \n\n\n\u6700\u5f8c\u306b\u3001swsusp\u306e\u5236\u7d04\u56de\u907f\u306e\u305f\u3081\u306b\u3001\u4ee5\u4e0b\u306e\u3088\u3046\u306bsuspend-to-disk\u306e\u307b\u3068\u3093\u3069\u3092\u30e6\u30fc\u30b6\u30d7\u30ed\u30bb\u30b9\u306b\u3084\u3089\u305b\u308b\u7684\u306a\u8a71\u3082\u3042\u308a\u307e\u3059\u304c\u30fb\u30fb\u30fb\u306a\u3093\u304b\u9b54\u7a9f\u7684\u306a\u5302\u3044\u3082\u3057\u307e\u3059\u3002\n\nDocumentation/power/states.txt\nAlternatively, userspace can do most of the actual suspend to disk work, see userland-swsusp.txt.\n\n\n\n\u6700\u5f8c\u306b\nPower Management\u7cfb\u306e\u51e6\u7406\u306f\u610f\u5916\u3068\u6587\u66f8\u304c\u5c11\u306a\u3044\u3088\u3046\u306a\u6c17\u304c\u3057\u305f\u306e\u3067\u3001\u5c11\u3057\u3055\u308f\u308a\u3092\u66f8\u304d\u307e\u3057\u305f\u3002\u30b9\u30ad\u30de\u6642\u9593\u3092\u898b\u3064\u3051\u3064\u3064\u8aad\u3093\u3067\u3044\u304d\u305f\u3044\u306a\u3001\u3068\u601d\u3044\u307e\u3059\u3002\n## \u3053\u306e\u9593\u3001Linux\u3082\u304f\u3082\u304f\u4f1a\u306b\u884c\u3063\u3066\u304d\u307e\u3057\u305f\u3002\n2\u70b9\u5f8c\u6094\u3057\u307e\u3057\u305f\u3002\u6669\u98ef\u3092\u4e8b\u524d\u306b\u98df\u3079\u3066\u304a\u3051\u3070\u3088\u304b\u3063\u305f\u3068\u3044\u3046\u70b9\u304c\u3072\u3068\u3064\u3001\u3082\u3046\u3072\u3068\u3064\u306f\u3082\u3063\u3068\u30d0\u30c3\u30c6\u30ea\u30fc\u306e\u6301\u3061\u304c\u826f\u3044\u30ce\u30fc\u30c8PC\u3092\u8cb7\u3046\u3079\u304d\u3067\u3059\u3002\nMBA\u6301\u3064\u4eba\u304c\u5897\u3048\u3064\u3064\u3042\u308b\u306e\u3082\u308f\u304b\u308a\u307e\u3059...\u3002\n\u307e\u3042\u3001\u305d\u308c\u306f\u63aa\u3044\u3066\u3002\u3082\u304f\u3082\u304f\u4f1a\u3067\u30bd\u30fc\u30b9\u8aad\u3093\u3060\u8a18\u9332\u3092\u6b8b\u3057\u307e\u3059\u3002\n\n##ACPI\u5468\u308a\n\n\u7d44\u307f\u8fbc\u307f\u3068\u304b\u3067\u3053\u306e\u3042\u305f\u308a\u306b\u95a2\u308f\u3063\u305f\u4eba\u306f\u3001\u8272\u3005\u3068\u9762\u5012\u306a\u3053\u3068\u306b\u306a\u308a\u307e\u3059(\u7b11)\u3002\u3061\u3087\u3063\u3068\u30d0\u30b0\u308b\u3068\u30b9\u30c8\u30fc\u30eb\u3059\u308b\u3001\u307e\u3055\u306b\u30b9\u30da\u30e9\u30f3\u30ab\u30fc\u306e\u3088\u3046\u306a\u4e16\u754c\u304c\u5c55\u958b\u3055\u308c\u307e\u3059\u3002\n\u79c1\u306f\u8077\u696d\u67c4NetBSD\u304c\u30e1\u30a4\u30f3\u3067\u3059\u304c\u3001Linux\u306f\u3069\u3046\u306a\u3063\u3066\u308b\u306e\u304b\u306a\u30fc\u3001\u3068\u6c17\u306b\u306a\u3063\u305f\u6b21\u7b2c\u3002\n\n\u30ad\u30fc\u30ef\u30fc\u30c9\u3067\u601d\u3044\u3064\u304f\u306e\u306f...Power Management\u30e2\u30fc\u30c9\u306e\u4e00\u3064\u3001S3 State\u3092\u30ad\u30fc\u30ef\u30fc\u30c9\u306b\u30bd\u30fc\u30b9\u306e\u5728\u308a\u51e6\u3092\u63a2\u3063\u3066\u307f\u307e\u3059\u3002\n\n```\neria@eria-thinkpad:~/source/linux-3.19 % grep -rIi \"S3 state\" *\narch/x86/include/asm/cpufeature.h:#define X86_FEATURE_NONSTOP_TSC_S3 ( 3*32+30) /* TSC doesn't stop in S3 state */\ndrivers/ide/Kconfig:      machines ACPI support is required to properly handle ACPI S3 states.\nkernel/power/Kconfig:     suspend-to-RAM state (e.g. the ACPI S3 state).\n```\n\nkernel/power\u306e\u4e0b\u3092\u8997\u3051\u3070\u826f\u3055\u305d\u3046\u3067\u3059\u3002\n\n```\neria@eria-thinkpad:~/source/linux-3.19/kernel/power % ls\nKconfig         console.c       poweroff.c      suspend.c       wakelock.c\nMakefile        hibernate.c     process.c       suspend_test.c\nautosleep.c     main.c          qos.c           swap.c\nblock_io.c      power.h         snapshot.c      user.c\neria@eria-thinkpad:~/source/linux-3.19/kernel/power % pwd\n/usr/home/eria/source/linux-3.19/kernel/power\n```\n\n\u3055\u3063\u305d\u304f\u30bd\u30fc\u30b9\u3092\u30c1\u30e9\u898b\u3057\u307e\u3057\u3087\u3046\u3002(\u66f8\u304d\u5fd8\u308c\u307e\u3057\u305f\u304c\u3001\u30bd\u30fc\u30b9\u306e\u30d0\u30fc\u30b8\u30e7\u30f3\u306f\u30013.19\u3092\u57fa\u306b\u3057\u3066\u3044\u307e\u3059\u3002)\n\u307e\u305a\u306f\u3001\u6700\u521d\u306b\u898b\u308d\u3068\u3044\u308f\u3093\u3070\u304b\u308a\u306e\u3001main.c\u3092\u898b\u307e\u3059\u3002\n\n```c:kernel/power/main.c\n#ifdef CONFIG_PM_SLEEP\n\n/* Routines for PM-transition notifications */\n\nstatic BLOCKING_NOTIFIER_HEAD(pm_chain_head);\n\nint register_pm_notifier(struct notifier_block *nb)\n{\n    return blocking_notifier_chain_register(&pm_chain_head, nb);\n}\nEXPORT_SYMBOL_GPL(register_pm_notifier);\n\nint unregister_pm_notifier(struct notifier_block *nb)\n{\n    return blocking_notifier_chain_unregister(&pm_chain_head, nb);\n}\nEXPORT_SYMBOL_GPL(unregister_pm_notifier);\n\nint pm_notifier_call_chain(unsigned long val)\n{\n    int ret = blocking_notifier_call_chain(&pm_chain_head, val, NULL);\n\n    return notifier_to_errno(ret);\n}\n\n/* \u7565 */\n\n/* If set, devices may be suspended and resumed asynchronously. */\nint pm_async_enabled = 1;\n\nstatic ssize_t pm_async_show(struct kobject *kobj, struct kobj_attribute *attr,\n                 char *buf)\n{\n    return sprintf(buf, \"%d\\n\", pm_async_enabled);\n}\n\nstatic ssize_t pm_async_store(struct kobject *kobj, struct kobj_attribute *attr,\n                  const char *buf, size_t n)\n{\n    unsigned long val;\n\n    if (kstrtoul(buf, 10, &val))\n        return -EINVAL;\n\n    if (val > 1)\n        return -EINVAL;\n\n    pm_async_enabled = val;\n    return n;\n}\n```\n\nsuspend\u3068resume\u3001BSD\u7cfb\u306eACPI\u5b9f\u88c5\u8aad\u3093\u3060\u7d4c\u9a13\u304b\u3089\u3001Power Management\u30e2\u30fc\u30c9\u9077\u79fb\u6642\u306b\u547c\u3070\u308c\u308b\u30d5\u30c3\u30af\u95a2\u6570\u3068\u63a8\u5b9a\u3002\n(main.c\u8aad\u3093\u3067\u3001\u30b0\u30ed\u30fc\u30d0\u30eb\u5909\u6570\u306e\u5225\u30b3\u30fc\u30c9\u304b\u3089\u306e\u76f4\u30a2\u30af\u30bb\u30b9\u306f\u500b\u4eba\u7684\u306b\u6c17\u306b\u306a\u3063\u305f\u30fb\u30fb\u30fb)\n\n\u6b21\u306b\u6765\u308b\u306e\u306f\u3001ifdef\u306e\u30e9\u30d9\u30eb\u540d\u304b\u3089\u30c7\u30d0\u30c3\u30b0\u30b3\u30fc\u30c9\u3068\u601d\u308f\u308c\u308b\u306e\u3067\u3001\u7701\u7565\u3057\u307e\u3059\u3002\n\n```c:kernel/power/main.c\nstruct kobject *power_kobj;\n\n\n/**\n * state - control system sleep states.\n *\n * show() returns available sleep state labels, which may be \"mem\", \"standby\",\n * \"freeze\" and \"disk\" (hibernation).  See Documentation/power/states.txt for a\n * description of what they mean.\n *\n * store() accepts one of those strings, translates it into the proper\n * enumerated value, and initiates a suspend transition.\n */\n```\n\nshow()\u306f\u5358\u306a\u308b\u60c5\u5831\u8868\u793a\u3068\u601d\u308f\u308c\u3001\u8aad\u3093\u3067\u3082\u3042\u307e\u308a\u9762\u767d\u304f\u306a\u3055\u305d\u3046\u3067\u3059\u3002\u306a\u306e\u3067\u3001\u6b21\u306estore()\u3092\u8aad\u307f\u307e\u3059\u3002\n\n```c:kernel/power/main.c\nstatic ssize_t state_store(struct kobject *kobj, struct kobj_attribute *attr,\n               const char *buf, size_t n)\n{\n    suspend_state_t state;\n    int error;\n\n    error = pm_autosleep_lock();\n    if (error)\n        return error;\n\n    if (pm_autosleep_state() > PM_SUSPEND_ON) {\n        error = -EBUSY;\n        goto out;\n    }\n\n    state = decode_state(buf, n);\n    if (state < PM_SUSPEND_MAX)\n        error = pm_suspend(state);\n    else if (state == PM_SUSPEND_MAX)\n        error = hibernate();\n    else\n        error = -EINVAL;\n\n out:\n    pm_autosleep_unlock();\n    return error ? error : n;\n}\n```\n\n\u3064\u307e\u308a\u3001state\u304cPM_SUSPEND_MAX\u306a\u3089\u3001hibernate()\u304c\u547c\u3070\u308c\u3001\u305d\u3046\u3067\u306a\u3044\u306e\u306a\u3089pm_suspend()\u304c\u547c\u3070\u308c\u308b\u5b9f\u306b\u7c21\u5358\u306a\u30b3\u30fc\u30c9\u3002\n\n\u4eca\u306f\u63aa\u3044\u3066\u3001main.c\u3092\u5148\u306b\u9032\u3080\u3002\n\u30b3\u30e1\u30f3\u30c8\u304c\u9577\u3044\u3002\n\n```c:kernel/power/main.c\n/*\n * The 'wakeup_count' attribute, along with the functions defined in\n * drivers/base/power/wakeup.c, provides a means by which wakeup events can be\n * handled in a non-racy way.\n *\n```\n\n\u3053\u306e\u8a18\u8ff0\u3067\u3001Linux\u306ePower Management\u6a5f\u80fd\u306fkernel\u306e\u6a5f\u80fd\u3060\u3051\u3067\u306a\u304f\u3001\u30c9\u30e9\u30a4\u30d0\u304c\u4ecb\u5728\u3057\u3066\u3044\u305d\u3046\u306a\u3053\u3068\u304c\u308f\u304b\u308b\u3002\n\n```c:kernel/power/main.c\n * If a wakeup event occurs when the system is in a sleep state, it simply is\n * woken up.  In turn, if an event that would wake the system up from a sleep\n * handled in a non-racy way.\n *\n * If a wakeup event occurs when the system is in a sleep state, it simply is\n * woken up.  In turn, if an event that would wake the system up from a sleep\n * state occurs when it is undergoing a transition to that sleep state, the\n * transition should be aborted.  Moreover, if such an event occurs when the\n * system is in the working state, an attempt to start a transition to the\n * given sleep state should fail during certain period after the detection of\n *\n * If a wakeup event occurs when the system is in a sleep state, it simply is\n * woken up.  In turn, if an event that would wake the system up from a sleep\n * state occurs when it is undergoing a transition to that sleep state, the\n * transition should be aborted.  Moreover, if such an event occurs when the\n * system is in the working state, an attempt to start a transition to the\n * given sleep state should fail during certain period after the detection of\n * the event.  Using the 'state' attribute alone is not sufficient to satisfy\n * these requirements, because a wakeup event may occur exactly when 'state'\n * is being written to and may be delivered to user space right before it is\n * frozen, so the event will remain only partially processed until the system is\n * woken up by another event.  In particular, it won't cause the transition to\n * a sleep state to be aborted.\n *\n * This difficulty may be overcome if user space uses 'wakeup_count' before\n * writing to 'state'.  It first should read from 'wakeup_count' and store\n * the read value.  Then, after carrying out its own preparations for the system\n * transition to a sleep state, it should write the stored value to\n * 'wakeup_count'.  If that fails, at least one wakeup event has occurred since\n * 'wakeup_count' was read and 'state' should not be written to.  Otherwise, it\n * is allowed to write to 'state', but the transition will be aborted if there\n * are any wakeup events detected after 'wakeup_count' was written to.\n */\n```\n\n\u8d85\u9577\u3044\u304c\u3001\u8981\u3059\u308b\u306b\u300cWake -> sleep\u306b\u9077\u79fb\u3059\u308b\u9014\u4e2d\u306eWakeup\u30a4\u30d9\u30f3\u30c8...sleep\u9077\u79fb\u3092\u30a2\u30dc\u30fc\u30c8\u3059\u3079\u304d\u300d\u300cWorking state\u6642\u306bWakeup\u30a4\u30d9\u30f3\u30c8\u304c\u8d77\u304d\u305f\u3089\u3001sleep\u306b\u9077\u79fb\u3059\u3079\u304d\u3067\u306a\u3044\u300d\u3068\u3044\u3046\u3053\u3068\u3002\n\u8981\u3059\u308b\u306bPower Management\u306e\u72b6\u614b\u9077\u79fb\u6642\u306b\u3001\u3055\u3089\u306b\u72b6\u614b\u9077\u79fb\u306e\u8981\u56e0\u3068\u306a\u308b\u30a4\u30d9\u30f3\u30c8\u304c\u8d77\u304d\u305f\u3068\u304d\u306e\u30dd\u30ea\u30b7\u30fc\u304c\u8ff0\u3079\u3089\u308c\u3066\u3044\u307e\u3059\u3002\n\u30e6\u30fc\u30b6\u304c\u30b7\u30b9\u30c6\u30e0\u3092\u4f7f\u3046\u306e\u3060\u304b\u3089\u3001\u6975\u529b\u4f7f\u3048\u308b\u3088\u3046\u306a\u72b6\u614b\u306b\u3059\u3079\u3057\u3001\u3068\u3044\u3046\u30dd\u30ea\u30b7\u30fc\u304c\u8aad\u307f\u53d6\u308c\u307e\u3059\u306d\u3002\n\u30b3\u30e1\u30f3\u30c8\u306e\u7d9a\u304d\u8aad\u307f\u307e\u3059\u3002\n\n```c:kernel/power/main.c\n * This difficulty may be overcome if user space uses 'wakeup_count' before\n * writing to 'state'.  It first should read from 'wakeup_count' and store\n * the read value.  Then, after carrying out its own preparations for the system\n * transition to a sleep state, it should write the stored value to\n * 'wakeup_count'.  \n```\n\n\u3053\u3053\u304b\u3089\u4f3a\u3048\u308b\u3053\u3068\u306f\u3001\u300c\u4f55\u3089\u304b\u306e\u30e6\u30fc\u30b6\u30d7\u30ed\u30bb\u30b9\u304c\u3001Power Management\u306e\u5236\u5fa1\u306b\u95a2\u308f\u3063\u3066\u3044\u308b\u3002\u305d\u3057\u3066\u3001\u72b6\u614b\u9077\u79fb\u306e\u30cf\u30f3\u30c9\u30ea\u30f3\u30b0\u306fwakeup_count\u3068state\u3092\u4f7f\u3063\u3066\u30e6\u30fc\u30b6\u30d7\u30ed\u30bb\u30b9\u304c\u884c\u3063\u3066\u3044\u308b\u3068\u3044\u3046\u3053\u3068\u300d\u304c\u8aad\u307f\u53d6\u308c\u307e\u3059\u3002\n\u4ed5\u69d8\u66f8\u304c\u306a\u3044\u30bd\u30d5\u30c8\u3092\u8aad\u3080\u969b\u306b\u3001\u30b3\u30e1\u30f3\u30c8\u306f\u9762\u5012\u81ed\u304c\u3089\u305a\u306b\u8aad\u3080\u3002\n\u7279\u306bOSS\u306e\u30b3\u30fc\u30c9\u5185\u306e\u9577\u3044\u30b3\u30e1\u30f3\u30c8\u306f\u6b8b\u5ff5SIer\u306e\u300ci\u306b1\u3092\u4ee3\u5165\u3059\u308b\u300d\u7684\u306a\u30b3\u30e1\u30f3\u30c8\u3068\u9055\u3044\u3001\u4f55\u3089\u304b\u306e\u91cd\u8981\u306a\u610f\u5473\u304c\u3042\u308b\u3068\u5fc3\u5f97\u308b\u3068\u3053\u308d\u3001\u5927\u4e8b\u3067\u3059\u306d\u3002\n\n```c:kernel/power/main.c\nstatic ssize_t wakeup_count_store(struct kobject *kobj,\n                struct kobj_attribute *attr,\n                const char *buf, size_t n)\n{\n/* \u7565 */\n    if (sscanf(buf, \"%u\", &val) == 1) {\n        if (pm_save_wakeup_count(val))\n            error = n;\n        else\n            pm_print_active_wakeup_sources();\n    }\n\n```\n\n\u57fa\u672c\u306f\u53d7\u3051\u53d6\u3063\u305fsigned integer\u3092wakeup_count\u3068\u3044\u3046\u30d1\u30e9\u30e1\u30fc\u30bf\u306b\u30bb\u30c3\u30c8\u3059\u308b\u3068\u3044\u3046\u3053\u3068\u306d\u3002\u3053\u308c\u304c\u4f55\u304b\u306f\u4eca\u5f8c\u308f\u304b\u3063\u3066\u304f\u308b\u3067\u3057\u3087\u3046\u3002\n\n```c:kernel/power/main.c\n#ifdef CONFIG_PM_AUTOSLEEP\n```\n\n\u3053\u306eifdef\u3067\u56f2\u307e\u308c\u3066\u3044\u308b\u30b3\u30fc\u30c9\u306f\u4f55\u3060\u308d\u3046\u304b\u3002\n\u3084\u3063\u3066\u3044\u308b\u3053\u3068\u306f\u5148\u306b\u8a18\u8f09\u3057\u305fshow\u3068set\u3068\u3042\u307e\u308a\u5909\u308f\u3089\u306a\u3044\u3002\n\u3053\u306e\u3088\u3046\u306a\u611f\u3058\u3067\u3001\u6570\u500b\u306eifdef\u304c\u4e26\u3073\u3001\u540c\u3058\u3088\u3046\u306a\u3053\u3068\u304c\u7e70\u308a\u8fd4\u3055\u308c\u3066\u3044\u308b\u3002\n\n```c:kernel/power/main.c\nstatic struct attribute * g[] = {\n    &state_attr.attr,\n#ifdef CONFIG_PM_TRACE\n    &pm_trace_attr.attr,\n    &pm_trace_dev_match_attr.attr,\n#endif\n#ifdef CONFIG_PM_SLEEP\n    &pm_async_attr.attr,\n    &wakeup_count_attr.attr,\n#ifdef CONFIG_PM_AUTOSLEEP\n    &autosleep_attr.attr,\n#endif\n#ifdef CONFIG_PM_WAKELOCKS\n    &wake_lock_attr.attr,\n    &wake_unlock_attr.attr,\n#endif\n#ifdef CONFIG_PM_DEBUG\n    &pm_test_attr.attr,\n#endif\n#ifdef CONFIG_PM_SLEEP_DEBUG\n    &pm_print_times_attr.attr,\n#endif\n#ifdef CONFIG_FREEZER\n    &pm_freeze_timeout_attr.attr,\n#endif\n    NULL,\n};\n```\n\n\u3053\u308c\u3067\u540c\u3058\u3088\u3046\u306a\u5b9f\u88c5\u304c\u7d9a\u304f\u8b0e\u304c\u89e3\u3051\u305f\u3002show()\u3068set()\u3092\u95a2\u6570\u30dd\u30a4\u30f3\u30bf\u4f7f\u3063\u3066\u547c\u3073\u5206\u3051\u3066\u3044\u308b\u3002\n\u3053\u308c\u3089I/F\u3092sysfs\u3092\u7528\u3044\u3066\u30e6\u30fc\u30b6\u30e9\u30f3\u30c9\u306b\u898b\u305b\u3066\u3044\u308b\u306e\u304c\u3001\u4ee5\u4e0b\u306e\u521d\u671f\u5316\u30b3\u30fc\u30c9\u3067\u3042\u308b\u3068\u601d\u308f\u308c\u308b\u3002\n\n```c:kernel/power/main.c\nstatic struct attribute_group attr_group = {\n    .attrs = g,\n};\n\nstruct workqueue_struct *pm_wq;\nEXPORT_SYMBOL_GPL(pm_wq);\n\nstatic int __init pm_start_workqueue(void)\n{\n    pm_wq = alloc_workqueue(\"pm\", WQ_FREEZABLE, 0);\n\n    return pm_wq ? 0 : -ENOMEM;\n}\n\nstatic int __init pm_init(void)\n{\n    int error = pm_start_workqueue();\n    if (error)\n        return error;\n    hibernate_image_size_init();\n    hibernate_reserved_size_init();\n    hibernate_reserved_size_init();\n    power_kobj = kobject_create_and_add(\"power\", NULL);\n    if (!power_kobj)\n        return -ENOMEM;\n    error = sysfs_create_group(power_kobj, &attr_group);\n    if (error)\n        return error;\n    pm_print_times_init();\n    return pm_autosleep_init();\n}\n```\n\nsysfs\u306f\u3001\u4ee5\u4e0b\u306e\u3068\u304a\u308a\u3001BSD\u306esysctl\u306e\u3088\u3046\u306a\u3082\u306e\u3067\u3059\u3002\nhttp://ja.wikipedia.org/wiki/Sysfs\n\n\u3042\u3068\u3001kobject\u3082\u4ee5\u4e0b\u88dc\u8db3\u3057\u307e\u3059\u3002\nhttp://wiki.bit-hive.com/north/pg/sysfs%A4%C8kobject\nhttp://dev.ariel-networks.com/Members/ohyama/i-o-30b930b130e530fc30e9306e-sysfs-30a830f330c830ea306b306430443066306e307e30683081/\n\n\u300csysfs \u306e\u30c7\u30a3\u30ec\u30af\u30c8\u30ea\u30d5\u30a1\u30a4\u30eb\u306f kobject \u3068\u3044\u3046\u30c7\u30fc\u30bf\u69cb\u9020\u3067\u8868\u73fe\u3055\u308c\u3001\u5404 kobject \u306b\u5c5e\u6027 (attribute) \u60c5\u5831\u304c\u3076\u3089\u4e0b\u304c\u308a\u3001\u3053\u308c\u304c\u30d5\u30a1\u30a4\u30eb\u3068\u3044\u3046\u5f62\u3067\u30e6\u30fc\u30b6\u306b\u63d0\u4f9b\u3055\u308c\u3066\u3044\u307e\u3059\u3002\u300d\u3068\u3044\u3046\u8a18\u8ff0\u304b\u3089\u3001\u5148\u306e\u63a8\u5b9a\u306f\u6b63\u3057\u305d\u3046\u3067\u3059\u3002\n\n## Documentation\n\u96f0\u56f2\u6c17\u306f\u4f55\u3068\u306a\u304f\u3064\u304b\u3081\u3066\u304d\u305f\u304c\u3001\u66f4\u306b\u305d\u308c\u3092\u660e\u78ba\u306b\u3057\u305f\u3044\u3067\u3059\u3002\n\u305d\u3053\u3067\u3001\u5148\u306e\u30b3\u30e1\u30f3\u30c8\u5185\u3067\u8a00\u53ca\u3055\u308c\u3066\u3044\u305fDocumentation\u3092\u8aad\u3093\u3067\u307f\u307e\u3059\u3002\n\n```:Documentation/power/states.txt\nstate:      Suspend-To-Idle\nACPI state: S0\nLabel:      \"freeze\"\n```\n\n\u3053\u308c\u306f\u3001Linux\u5185\u3067\u30b5\u30dd\u30fc\u30c8\u3055\u308c\u3066\u3044\u308bPower State\u306e\u8aac\u660e\u3067\u3001\u300cSuspend-To-Idle\u300d\u306e\u8aac\u660e\u3067\u3059\u3002ACPI state\u306fS0\u306a\u306e\u3067\u3001**ACPI\u304b\u3089\u898b\u308b\u3068**\u7701\u30a8\u30cd\u72b6\u614b\u3067\u306f\u3042\u308a\u307e\u305b\u3093\u3002\n\u3064\u307e\u308a\u3001Suspend-To-Idle\u306fACPI\u5168\u304f\u95a2\u4fc2\u3042\u308a\u307e\u305b\u3093\u3002\n\n```:Documentation/power/states.txt\nmore energy to be saved relative to runtime idle by freezing user space and putting all I/O devices into low-power states\n```\n\n\u4e0a\u8a18\u306efreezing user space\u306e\u8a71\u306f\u3059\u3054\u304f\u6c17\u306b\u306a\u308a\u307e\u3059\u3002\u5358\u306bidle-thread\u304c\u52d5\u3044\u3066\u307e\u3059\u3088\u7684\u306a\u8a71\u306a\u306e\u304b\u3001\u305d\u308c\u3068\u3082\u30e6\u30fc\u30b6\u30e9\u30f3\u30c9\u306e\u30d7\u30ed\u30bb\u30b9\u3092\u672c\u5f53\u306b\u52d5\u3051\u306a\u304f(=\u30b9\u30b1\u30b8\u30e5\u30fc\u30ea\u30f3\u30b0\u3055\u308c\u306a\u304f)\u3059\u308b\u306e\u304b\u306f\u308f\u304b\u308a\u307e\u305b\u3093\u3002\n\n```:Documentation/power/states.txt\nState:      Standby / Power-On Suspend\nACPI State: S1\nLabel:      \"standby\"\n\nIn addition to freezing user space and putting all I/O devices into low-power states, which is done for Suspend-To-Idle too, nonboot CPUs are taken offline and all low-level system functions are suspended during transitions into this state.\n```\n\n\u4f7f\u3063\u3066\u306a\u3044\u30b3\u30a2\u3092offline\u3001low level system\u6a5f\u80fd\u3068\u6b62\u3081\u308b\u3088\u3046\u306a\u8a18\u8f09\u304c\u3042\u308a\u307e\u3059\u3002\u30d6\u30fc\u30c8\u306b\u4f7f\u308f\u308c\u305f\u30b3\u30a2\u306e\u307f\u3092\u6d3b\u304b\u3057\u3001\u5f8c\u306e\u30b3\u30a2\u3092\u505c\u6b62\u3059\u308b\u3088\u3046\u306b\u3082\u898b\u3048\u307e\u3059\u3002\n\n\u6b21\u306f\u3001S3 state\u3002\u3044\u308f\u3086\u308bSuspend-To-RAM\u3067\u3001\u5e73\u305f\u304f\u8a00\u3048\u3070CPU\u3092OFF\u3057\u3001RAM\u3092\u30bb\u30eb\u30d5\u30ea\u30d5\u30ec\u30c3\u30b7\u30e5\u30e2\u30fc\u30c9\u3068\u3044\u3044\u3046\u30e2\u30fc\u30c9\u306b\u9077\u79fb\u3055\u305b\u3001RAM\u306e\u5185\u5bb9\u3092\u6b8b\u3059\u3088\u3046\u306b\u3057\u307e\u3059\u3002\n\n\u3042\u3068\u3001S4 state\u306fSuspend-To-Disk\u3002RAM\u306e\u5185\u5bb9\u3092\u30c7\u30a3\u30b9\u30af\u306b\u66f8\u3044\u3066\u96fb\u6e90\u3092\u5207\u308b\u3088\u3046\u306a\u30e2\u30fc\u30c9\u3067\u3059\u3002\n\u3053\u3053\u306b\u8a00\u53ca\u304c\u3042\u308b\u300cfirmware\u300d\u3084\u300canother operating system\u300d\u306f\u73fe\u6642\u70b9\u3067\u306f\u3088\u304f\u308f\u304b\u308a\u307e\u305b\u3093\u3002\n\n```:Documentation/power/states.txt\nState:      Suspend-to-RAM\nACPI State: S3\nLabel:      \"mem\"\n\nThis state, if supported, offers significant power savings as everything in the system is put into a low-power state, except for memory, which should be placed into the self-refresh mode to retain its contents.  \n\nState:      Suspend-to-disk\nACPI State: S4\nLabel:      \"disk\"\n\nSTD can be handled by the firmware or the kernel. If it is handled by the firmware, it usually requires a dedicated partition that must be setup via another operating system for it to use. Despite the inconvenience, this method requires minimal work by the kernel, since\u3000the firmware will also handle restoring memory contents on resume.\n```\n\n\u4ee5\u4e0bsuspend-to-swap\u306e\u4ed5\u7d44\u307f\u306e\u3072\u3068\u3064\u3067\u3042\u308b\u300cswsusp\u300d\u3082\u6c17\u306b\u306a\u308a\u307e\u3059\u3002\u7279\u306bswap\u3068\u3069\u306e\u3088\u3046\u306b\u7d71\u5408\u3055\u308c\u3001\u9055\u3044(\u5236\u7d04)\u306f\u4f55\u304b\u3068\u3044\u3046\u3068\u3053\u308d\u3082\u8208\u5473\u6df1\u3044\u3067\u3059\u3002\n\n```:Documentation/power/states.txt\nFor suspend-to-disk, a mechanism called 'swsusp' (Swap Suspend) is used to write memory contents to free swap space. swsusp has some restrictive requirements, but should work in most cases. \n```\n\n\u6700\u5f8c\u306b\u3001swsusp\u306e\u5236\u7d04\u56de\u907f\u306e\u305f\u3081\u306b\u3001\u4ee5\u4e0b\u306e\u3088\u3046\u306bsuspend-to-disk\u306e\u307b\u3068\u3093\u3069\u3092\u30e6\u30fc\u30b6\u30d7\u30ed\u30bb\u30b9\u306b\u3084\u3089\u305b\u308b\u7684\u306a\u8a71\u3082\u3042\u308a\u307e\u3059\u304c\u30fb\u30fb\u30fb\u306a\u3093\u304b\u9b54\u7a9f\u7684\u306a\u5302\u3044\u3082\u3057\u307e\u3059\u3002\n\n```:Documentation/power/states.txt\nAlternatively, userspace can do most of the actual suspend to disk work, see userland-swsusp.txt.\n```\n\n## \u6700\u5f8c\u306b\nPower Management\u7cfb\u306e\u51e6\u7406\u306f\u610f\u5916\u3068\u6587\u66f8\u304c\u5c11\u306a\u3044\u3088\u3046\u306a\u6c17\u304c\u3057\u305f\u306e\u3067\u3001\u5c11\u3057\u3055\u308f\u308a\u3092\u66f8\u304d\u307e\u3057\u305f\u3002\u30b9\u30ad\u30de\u6642\u9593\u3092\u898b\u3064\u3051\u3064\u3064\u8aad\u3093\u3067\u3044\u304d\u305f\u3044\u306a\u3001\u3068\u601d\u3044\u307e\u3059\u3002\n", "tags": ["Linux", "Power", "kernel", "kernelvm"]}