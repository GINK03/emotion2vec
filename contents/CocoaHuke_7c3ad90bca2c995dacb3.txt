{"context": " More than 1 year has passed since last update.CVE-2015-5774 Analyze\n2015-9-18 bycocoa\n\u304a\u304b\u3052\u3067\u79c1\u306e\u30dd\u30b9\u30c8\u3092\u898b\u3066\u3001\u79c1\u306fqitta\u306b\u3064\u3044\u3066\u3044\u304f\u3064\u304b\u8cea\u554f\u304c\u3042\u308a\u307e\u3059\u3001\u79c1\u306eLine id cocoahuke\u3067\u3059\n\u76d8\u53e4(blog.pangu.io)\u4e5f\u8bb2\u89e3\u4e86\u8fd9\u4e2a\u6f0f\u6d1e.\u4f46\u4e0d\u662f\u5f88\u8be6\u7ec6.\u56e0\u4e3a\u8fd9\u4e2a\u6f0f\u6d1e\u6bd4\u8f83\u7b80\u5355.\u9f13\u52b1\u5927\u5bb6\u53cd\u7f16\u8bd1taig,\u6bd5\u7adf\u5177\u4f53\u5f88\u591a\u4e1c\u897f\u8fd8\u662f\u5728\u6c47\u7f16\u91cc\u5b66\u4e60.\u8fd9\u91cc\u4ec5\u7ed9\u51fa\u8fd9\u4e2a\u6f0f\u6d1e\u7684\u5206\u6790:\n\u5148\u9006\u5411\u7684\u5206\u6790\u5427:\n\u6f0f\u6d1e\u5b58\u5728\u4e8eIOHIDResourceDeviceUserClient\u7684methods\u4e2d\u7b2c\u4e09\u4e2a\u51fd\u6570_postReportResult\nconst IOExternalMethodDispatch IOHIDResourceDeviceUserClient::_methods[kIOHIDResourceDeviceUserClientMethodCount] = \n{\n. . . . . .\n{   // kIOHIDResourceDeviceUserClientMethodPostReportResult\n        (IOExternalMethodAction) &IOHIDResourceDeviceUserClient::_postReportResult,\n        kIOHIDResourceUserClientResponseIndexCount, -1, /* 1 scalar input: the result, 1 struct input : the buffer */\n        0, 0\n}\n}\n\nIOReturn IOHIDResourceDeviceUserClient::postReportResult(IOExternalMethodArguments * arguments)\n{\n    OSObject * tokenObj = (OSObject*)arguments->scalarInput[kIOHIDResourceUserClientResponseIndexToken];\n\n    if ( tokenObj && _pending->containsObject(tokenObj) ) {\n        OSData * data = OSDynamicCast(OSData, tokenObj);\n        if ( data ) {\n            __ReportResult * pResult = (__ReportResult*)data->getBytesNoCopy();\n\n            // RY: HIGHLY UNLIKELY > 4K\n            if ( pResult->descriptor && arguments->structureInput ) {\n                pResult->descriptor->writeBytes(0, arguments->structureInput, arguments->structureInputSize);\n\n                // 12978252:  If we get an IOBMD passed in, set the length to be the # of bytes that were transferred\n                IOBufferMemoryDescriptor * buffer = OSDynamicCast(IOBufferMemoryDescriptor, pResult->descriptor);\n                if (buffer)\n                    buffer->setLength((vm_size_t)arguments->structureInputSize);\n\n            }\n\n            pResult->ret = (IOReturn)arguments->scalarInput[kIOHIDResourceUserClientResponseIndexResult];\n\n            _commandGate->commandWakeup(data);\n        }\n\n    }\n\n    return kIOReturnSuccess;\n}\n\n\u5176\u4e2d\u4e00\u53e5\n\nif (buffer)\n    buffer->setLength((vm_size_t)arguments->structureInputSize);\n\n\u6ca1\u6709\u7ecf\u8fc7\u68c0\u67e5\u7684\u7528\u6237\u6001\u4f20\u6765\u7684\u53c2\u6570\u76f4\u63a5\u7528\u5728\u4e86setLength(\u4e0d\u5206\u914d,\u91cd\u65b0\u8bbe\u7f6e\u7f13\u51b2\u533a\u7684\u957f\u5ea6),\u6240\u4ee5\u4e0a\u9762\u7684writeBytes\u672c\u6765\u662f\u5b89\u5168\u5199\u5165.\u4f1a\u68c0\u67e5\u5199\u5165\u7684\u5927\u5c0f\u662f\u5426\u5c0f\u4e8eIOBufferMemoryDescriptor\u5bf9\u8c61\u5185\u90e8\u7684_length\u53d8\u91cf.\nIOByteCount IOMemoryDescriptor::writeBytes\n                (IOByteCount inoffset, const void *bytes, IOByteCount length)\n{\n    . . . . . .\n    // Assert that this entire I/O is withing the available range\n    assert(offset <= _length);\n    assert(offset + length <= _length);//check \n    . . . . . .\n}\n\n\u55ef,\u90a3\u4e48\u6211\u4eec\u56de\u5230postReportResult\u51fd\u6570,\u60f3\u8981\u53ef\u4ee5\u8bbe\u7f6ebuffer\u7684\u957f\u5ea6\u7684\u6761\u4ef6\u662fbuffer\u5b58\u5728.\u8fd9\u4e2a\u7f13\u51b2\u533a\u7684\u521d\u59cb\u5316\u5728\u5176\u4ed6\u5730\u65b9.\nIOBufferMemoryDescriptor * buffer = OSDynamicCast(IOBufferMemoryDescriptor, pResult->descriptor);\nif (buffer)\n                    buffer->setLength((vm_size_t)arguments->structureInputSize);\n\n\u90a3\u4e48\u5177\u4f53\u70b9:\nOSObject * tokenObj = (OSObject*)arguments->scalarInput[kIOHIDResourceUserClientResponseIndexToken];\n\n    if ( tokenObj && _pending->containsObject(tokenObj) ) {\n        OSData * data = OSDynamicCast(OSData, tokenObj);\n        if ( data ) {\n            __ReportResult * pResult = (__ReportResult*)data->getBytesNoCopy();\n\n            // RY: HIGHLY UNLIKELY > 4K\n            if ( pResult->descriptor && arguments->structureInput ) {\n                pResult->descriptor->writeBytes(0, arguments->structureInput, arguments->structureInputSize);\n\n                // 12978252:  If we get an IOBMD passed in, set the length to be the # of bytes that were transferred\n                pResult->descriptor\n                IOBufferMemoryDescriptor * buffer = OSDynamicCast(IOBufferMemoryDescriptor,pResult->descriptor);\n                //\u53ef\u4ee5\u77e5\u9053\u5728_pending\u4e2d\u5b58\u5728tokenObj\n\nok.\u5230\u8fd9\u91cc\u4e3a\u6b62.\u6b63\u5411\u5206\u6790:\n\u5148\u9700\u8981\u521b\u5efa\u4e00\u4e2aIOHIDDevice\u5bf9\u8c61.\u521b\u5efaIOHIDDevice\u5bf9\u8c61\nconst IOExternalMethodDispatch IOHIDResourceDeviceUserClient::_methods[kIOHIDResourceDeviceUserClientMethodCount] = {\n    {   // kIOHIDResourceDeviceUserClientMethodCreate\n        (IOExternalMethodAction) &IOHIDResourceDeviceUserClient::_createDevice,\n        1, -1, /* 1 struct input : the report descriptor */\n        0, 0\n    }\n. . . . . .\n}\n\n\u521b\u5efa\u65f6\u9700\u8981\u4f20\u5165\u4e00\u4e2astruct.\u8fd9\u4e2astruct\u662f\u6709\u683c\u5f0f\u5316\u7684.\u770b\u4e0b\u9762\u53ef\u4ee5\u77e5\u9053\u662f\u4e00\u4e2aXML\u7684\u6570\u636e.\u89e3\u6790\u540e\u4e3a\u4e00\u4e2a\u5b57\u5178\u5bf9\u8c61,\u5b57\u5178\u5bf9\u8c61\u91cc\u6709\u5f88\u591a\u4e0d\u540ckey\u5bf9\u5e94\u7740\u4e0d\u540c\u6570\u636e.\u89e3\u6790\u51fd\u6570\u5728IOHIDReportDescriptorParser.c\u7684PrintHIDDescriptor\u51fd\u6570\nIOHIDReportDescriptorParser.c\u7684PrintHIDDescriptor\u51fd\u6570\nIOReturn IOHIDResourceDeviceUserClient::createDevice(IOExternalMethodArguments * arguments)\n{\n    IOMemoryDescriptor *    propertiesDesc      = NULL;\n    void *                  propertiesData      = NULL;\n    IOByteCount             propertiesLength    = 0;\n    OSObject *              object              = NULL;\n    IOReturn                result;\n\n    // Report descriptor is static and thus can only be set on creation\n    require_action(_device==NULL, exit, result=kIOReturnInternalError);\n\n    // Let's deal with our device properties from data\n    propertiesDesc = createMemoryDescriptorFromInputArguments(arguments); //\u4e3a\u7528\u6237\u6001\u53c2\u6570\u521d\u59cb\u5316IOMemoryDescriptor\n    require_action(propertiesDesc, exit, result=kIOReturnNoMemory);\n\n    propertiesLength = propertiesDesc->getLength();\n    require_action(propertiesLength, exit, result=kIOReturnNoResources);\n\n    propertiesData = IOMalloc(propertiesLength);\n    require_action(propertiesData, exit, result=kIOReturnNoMemory);\n\n    propertiesDesc->readBytes(0, propertiesData, propertiesLength);\n\n    require_action(strnlen((const char *) propertiesData, propertiesLength) < propertiesLength, exit, result=kIOReturnInternalError);//ERROR POINT\n\n    object = OSUnserializeXML((const char *)propertiesData, propertiesLength);\n    require_action(object, exit, result=kIOReturnInternalError);\n\n    _properties = OSDynamicCast(OSDictionary, object); //\u5c06\u7528\u6237\u6001\u4f20\u6765\u7684XML\u89e3\u6790\u51fa\u7684\u5b57\u5178\u8d4b\u7ed9_properties\n    require_action(_properties, exit, result=kIOReturnNoMemory);\n\n    _properties->retain();\n\n    if ( arguments->scalarInput[0] )\n        result = createAndStartDeviceAsync();\n    else\n        result = createAndStartDevice(); //\u4f1a\u8fdb\u5165\u8fd9\u91cc.\n\n    require_noerr(result, exit);\n\nexit:\n\n    if ( object )\n        object->release();\n\n    if ( propertiesData && propertiesLength )\n        IOFree(propertiesData, propertiesLength);\n\n    if ( propertiesDesc )\n        propertiesDesc->release();\n\n    return result;\n}\n\n\u6b63\u5e38\u6267\u884c\u4f1a\u8fdb\u5165createAndStartDevice\u51fd\u6570.\nIOReturn IOHIDResourceDeviceUserClient::createAndStartDevice()\n{\n    IOReturn    result;\n    OSNumber *  number = NULL;\n\n    number = OSDynamicCast(OSNumber, _properties->getObject(kIOHIDRequestTimeoutKey));\n    if ( number )\n        _maxClientTimeoutUS = number->unsigned32BitValue();\n\n    // If after all the unwrapping we have a dictionary, let's create the device\n    _device = IOHIDUserDevice::withProperties(_properties); //\n    require_action(_device, exit, result=kIOReturnNoResources);\n\n    require_action(_device->attach(this), exit, result=kIOReturnInternalError);\n\n    require_action(_device->start(this), exit, _device->detach(this); result=kIOReturnInternalError);\n\n    result = kIOReturnSuccess;\n\nexit:\n    if ( result!=kIOReturnSuccess ) {\n        IOLog(\"%s: result=0x%08x\\n\", __FUNCTION__, result);\n        OSSafeReleaseNULL(_device);\n    }\n    return result;\n}\n\n\u53ef\u4ee5\u770b\u5230\u521d\u59cb\u5316\u4e86\u4e00\u4e2aIOHIDUserDevice\u5bf9\u8c61.attach,start\u51fd\u6570\u662f\u7ee7\u627f\u81eaIOHIDDevice.\nbool IOHIDDevice::start( IOService * provider )\n{   . . . . . .\n    // Call handleStart() before fetching the report descriptor.\n    require_action(handleStart(provider), error, result=false); //\u8c03\u7528handleStart\u4e3a_provider\u8d4b\u503c(IOHIDResourceDeviceUserClient)\n    // Fetch report descriptor for the device, and parse it.\n    require_noerr_action(newReportDescriptor(&reportDescriptor), error, result=false); \n    require_action(reportDescriptor, error, result=false); //check\n    . . . . . . \n}\n\nbool IOHIDUserDevice::handleStart( IOService * provider )\n{   . . . . . . \n    _provider = OSDynamicCast(IOHIDResourceDeviceUserClient, provider);\n    . . . . . .\n}\n\nIOReturn IOHIDUserDevice::newReportDescriptor(IOMemoryDescriptor ** descriptor ) const\n{\n    OSData *                    data;\n\n    data = OSDynamicCast(OSData, _properties->getObject(kIOHIDReportDescriptorKey));\n    if ( !data )\n        return kIOReturnError;\n\n    *descriptor = IOBufferMemoryDescriptor::withBytes(data->getBytesNoCopy(), data->getLength(), kIODirectionNone); //\u62f7\u8d1d\u4ece\u7528\u6237\u6001\u4f20\u6765\u7684\u6570\u636e(key\u4e3akIOHIDReportDescriptorKey)\n\n    return kIOReturnSuccess;\n}\n\n\u7136\u540e\u6211\u4eec\u5728\u521b\u5efa\u5b8c\u540e\u6839\u636eIOHIDUserDevice\u8c03\u7528\u5ba2\u6237\u7aef\u7684updateElementValues\u51fd\u6570\n\u8bb0\u5f97\u4e4b\u524d\u8c03\u7528IOHIDResourceDeviceUserClient::clientMemoryForType\u521b\u5efa_queue\u5bf9\u8c61.\nconst IOExternalMethodDispatch IOHIDLibUserClient::\nsMethods[kIOHIDLibUserClientNumCommands] = {\n{   . . . . . . \n    //    kIOHIDLibUserClientUpdateElementValues\n    (IOExternalMethodAction) &IOHIDLibUserClient::_updateElementValues,\n    kIOUCVariableStructureSize, 0,\n    0, 0\n    },\n    . . . . . . \n}\n\nIOReturn IOHIDLibUserClient::_updateElementValues (IOHIDLibUserClient * target, void * reference __unused, IOExternalMethodArguments * arguments)\n{\n    return target->updateElementValues(arguments->scalarInput, arguments->scalarInputCount);\n}\n\nIOReturn IOHIDLibUserClient::updateElementValues (const uint64_t * lCookies, uint32_t cookieCount)\n{\n    IOReturn    ret = kIOReturnError;\n\n    if (fNub && !isInactive()) {\n        uint32_t    cookies[cookieCount];\n\n        deflate_vec(cookies, cookieCount, lCookies, cookieCount);\n\n        ret = fNub->updateElementValues((IOHIDElementCookie *)cookies, cookieCount);\n    }\n\n    return ret;\n}\n\ndeflate_vec\u4f1a\u628a\u7528\u6237\u6001\u4f20\u6765\u7684ICookies\u6574\u7406\u6210cookies\u6570\u7ec4. \nfNub\u4e3aIOHIDDevice\uff0c\u800cIOHIDUserDevice\u7ee7\u627f\u81eaIOHIDDevice, IOHIDUserDevice\u4e0b\u7684\u51fd\u6570\u591a\u4e3a\u83b7\u53d6\u5b57\u5178\u4e2d\u7684\u5404\u79cdkey\u76f8\u5e94\u7684\u503c. \u7ee7\u627f\u81eaIOHIDDevice\u51fd\u6570\u4f7f\u7528\u8fd9\u4e9b\u503c.key\u7684\u5b8f\u6765\u81eaIOHIDKeys.h\n\u6240\u4ee5\u4f1a\u8c03\u7528\u5230IOHIDDevice\u7684updateElementValues\nIOReturn IOHIDDevice::updateElementValues(IOHIDElementCookie *cookies, UInt32 cookieCount) {\n    IOMemoryDescriptor *    report = NULL;\n    IOHIDElementPrivate *       element = NULL;\n    IOHIDReportType     reportType;\n    IOByteCount         maxReportLength;\n    UInt8           reportID;\n    UInt32          index;\n    IOReturn            ret = kIOReturnError;\n\n    maxReportLength = max(_maxOutputReportSize,\n                            max(_maxFeatureReportSize, _maxInputReportSize));\n\n    // Allocate a mem descriptor with the maxReportLength.\n    // This way, we only have to allocate one mem discriptor\n    report = IOBufferMemoryDescriptor::withCapacity(maxReportLength, kIODirectionNone); //\u8fd9\u91cc\u521d\u59cb\u5316\u4e86IOBufferMemoryDescriptor \n    . . . . . . \n    for (index = 0; index < cookieCount; index++) { \n        element = GetElement(cookies[index]);\n\n        if (element == NULL)\n            continue;\n\n        if ( element->getTransactionState()\n                != kIOHIDTransactionStatePending )\n            continue;\n\n        if ( !element->getReportType(&reportType) )\n            continue;\n\n        reportID = element->getReportID();\n        // calling down into our subclass, so lets unlock\n        WORKLOOP_UNLOCK;\n\n        report->prepare();\n        ret = getReport(report, reportType, reportID); //\u8c03\u7528IOHIDUserDevice::getReport\n        report->complete();\n\n        WORKLOOP_LOCK;\n\n        if ( ret != kIOReturnSuccess ) //ret\u6765\u81eaIOHIDResourceDeviceUserClient::getReport\n            break;\n       . . . . . . \n}\n\n\u4f5c\u4e3afor\u5faa\u73af\u7684\u6761\u4ef6.\u7528\u6237\u6001\u4f20\u6765\u7684cookieCount\u4e00\u5b9a\u8981\u5927\u4e8e2.cookies\u7684\u503c\u4e5f\u662f\u53ef\u63a7\u7684.\nupdateElementValues\u51fd\u6570\u5206\u914d\u4e86IOBufferMemoryDescriptor,\u6700\u540e\u8c03\u7528\u4e86getReport,\u8fd9\u91cc\u6307IOHIDUserDevice\u7684getReport\n\u56e0\u4e3a\u4e00\u76f4\u5728\u505aIOHIDUserDevice\u5185\u7684\u64cd\u4f5c. updateElementValues\u662f\u7ee7\u627f\u81eaIOHIDDevice\nIOReturn IOHIDUserDevice::getReport(IOMemoryDescriptor    *report,\n                                    IOHIDReportType        reportType,\n                                    IOOptionBits        options )\n{\n    return _provider->getReport(report, reportType, options); //\u8c03\u7528IOHIDResourceDeviceUserClient\u7684getReport\n}\n//\u8fd8\u8bb0\u5f97_provider\u54ea\u6765\u7684\u5417? \u5c31\u662fIOHIDResourceDeviceUserClient.\u6240\u4ee5\u5e76\u628a\u5206\u914d\u7684IOBufferMemoryDescriptor\u4f20\u8fc7\u53bb.\nIOReturn IOHIDResourceDeviceUserClient::getReport(IOMemoryDescriptor *report, IOHIDReportType reportType, IOOptionBits options)\n{\n    ReportGatedArguments    arguments   = {report, reportType, options};\n    IOReturn                result;\n\n    require_action(!isInactive(), exit, result=kIOReturnOffline);\n\n    result = _commandGate->runAction(OSMemberFunctionCast(IOCommandGate::Action, this, &IOHIDResourceDeviceUserClient::getReportGated), &arguments);\nexit:\n    return result;\n}\n\nIOReturn IOHIDResourceDeviceUserClient::getReportGated(ReportGatedArguments * arguments)\n{\n    IOHIDResourceDataQueueHeader    header;\n    __ReportResult                  result;\n    AbsoluteTime                    ts;\n    IOReturn                        ret;\n    OSData *                        retData = NULL;\n\n    require_action(!isInactive(), exit, ret=kIOReturnOffline);\n\n    result.descriptor = arguments->report; //\u7ed3\u6784\u4f53\u6307\u5411\u5df2\u7ecf\u5206\u914d\u7684IOMemoryDescriptor\n\n    retData = OSData::withBytesNoCopy(&result, sizeof(__ReportResult)); //retData\u4e3a__ReportResult\u7ed3\u6784\u4f53\n    require_action(retData, exit, ret=kIOReturnNoMemory);\n\n    header.direction   = kIOHIDResourceReportDirectionIn;\n    header.type        = arguments->reportType;\n    header.reportID    = arguments->options&0xff;\n    header.length      = (uint32_t)arguments->report->getLength();\n    header.token       = (intptr_t)retData;\n\n    _pending->setObject(retData); //\u5f80_pending\u6dfb\u52a0__ReportResult\n\n    require_action(_queue && _queue->enqueueReport(&header), exit, ret=kIOReturnNoMemory);\n\n    // if we successfully enqueue, let's sleep till we get a result from postReportResult\n    clock_interval_to_deadline(kMicrosecondScale, _maxClientTimeoutUS, &ts);\n    switch ( _commandGate->commandSleep(retData, ts, THREAD_ABORTSAFE) ) {\n        case THREAD_AWAKENED:\n            ret = result.ret; //\u8fd4\u56de\u503c\n            break;\n        case THREAD_TIMED_OUT:\n            ret = kIOReturnTimeout;\n            break;\n        default:\n            ret = kIOReturnError;\n            break;\n    }\n}\n\ntypedef struct {\n    IOReturn                ret;\n    IOMemoryDescriptor *    descriptor;\n} __ReportResult;\n\n\u7136\u540e\u8c03\u7528IOHIDResourceDeviceUserClient\u7684\u4e09\u53f7\u5904\u7406\u51fd\u6570postReportResult\n\u7528\u6237\u6001\u4f20\u5165\u7684scalarInput\u4e3a\u6574\u5f62\u6570\u7ec4.\ntypedef enum {\n    kIOHIDResourceUserClientResponseIndexResult = 0,\n    kIOHIDResourceUserClientResponseIndexToken,\n    kIOHIDResourceUserClientResponseIndexCount\n} IOHIDResourceUserClientResponseIndex;\n\nIOReturn IOHIDResourceDeviceUserClient::postReportResult(IOExternalMethodArguments * arguments)\n{\n    OSObject * tokenObj = (OSObject*)arguments->scalarInput[kIOHIDResourceUserClientResponseIndexToken];\n\n    if ( tokenObj && _pending->containsObject(tokenObj) ) {\n        OSData * data = OSDynamicCast(OSData, tokenObj);\n        if ( data ) {\n            __ReportResult * pResult = (__ReportResult*)data->getBytesNoCopy();\n\n            // RY: HIGHLY UNLIKELY > 4K\n            if ( pResult->descriptor && arguments->structureInput ) {\n                pResult->descriptor->writeBytes(0, arguments->structureInput, arguments->structureInputSize);\n\n                // 12978252:  If we get an IOBMD passed in, set the length to be the # of bytes that were transferred\n                IOBufferMemoryDescriptor * buffer = OSDynamicCast(IOBufferMemoryDescriptor, pResult->descriptor);\n                if (buffer)\n                    buffer->setLength((vm_size_t)arguments->structureInputSize);\n\n            }\n\n            pResult->ret = (IOReturn)arguments->scalarInput[kIOHIDResourceUserClientResponseIndexResult]; \n            //\u4f5c\u4e3aIOHIDResourceDeviceUserClient::getReportGated\u7684\u8fd4\u56de\u503c.\u4e0d\u60f3\u8ba9for\u5faa\u73af\u65ad\u5c31\u4f200(KERN_SUCCESS)\n\n            _commandGate->commandWakeup(data);\n        }\n\n    }\n\n    return kIOReturnSuccess;\n}\n\n\u7136\u540e\u81f3\u5c11\u4e24\u6b21\u8c03\u7528postReportResult,\u7b2c\u4e00\u6b21\u4f1a\u5c06buffer\u7684\u957f\u5ea6\u8bbe\u4e3a\u4efb\u610f\u503c,\u7b2c\u4e8c\u6b21\u5199\u5165\u65f6\u5c31\u6709\u6ea2\u51fa\u7684\u53ef\u80fd\n\u5230\u6b64\u4e3a\u6b62.\u903b\u8f91\u8fd8\u662f\u6709\u4e9b\u4e71,\u6700\u597d\u81ea\u5df1\u7ed3\u5408IOHIDFamily\u7684\u6e90\u7801\u5206\u6790.\u5b9e\u9645\u4f7f\u7528\u8bf7\u81ea\u884c\u5206\u6790\u592a\u6781\u5427.^ ^\n\u5229\u7528\u4ee3\u7801\n\nCVE-2015-5774 Analyze\n\n2015-9-18 bycocoa\n\n\u304a\u304b\u3052\u3067\u79c1\u306e\u30dd\u30b9\u30c8\u3092\u898b\u3066\u3001\u79c1\u306fqitta\u306b\u3064\u3044\u3066\u3044\u304f\u3064\u304b\u8cea\u554f\u304c\u3042\u308a\u307e\u3059\u3001\u79c1\u306eLine id cocoahuke\u3067\u3059\n\n\u76d8\u53e4(blog.pangu.io)\u4e5f\u8bb2\u89e3\u4e86\u8fd9\u4e2a\u6f0f\u6d1e.\u4f46\u4e0d\u662f\u5f88\u8be6\u7ec6.\u56e0\u4e3a\u8fd9\u4e2a\u6f0f\u6d1e\u6bd4\u8f83\u7b80\u5355.\u9f13\u52b1\u5927\u5bb6\u53cd\u7f16\u8bd1taig,\u6bd5\u7adf\u5177\u4f53\u5f88\u591a\u4e1c\u897f\u8fd8\u662f\u5728\u6c47\u7f16\u91cc\u5b66\u4e60.\u8fd9\u91cc\u4ec5\u7ed9\u51fa\u8fd9\u4e2a\u6f0f\u6d1e\u7684\u5206\u6790:\n\u5148\u9006\u5411\u7684\u5206\u6790\u5427:  \n\u6f0f\u6d1e\u5b58\u5728\u4e8eIOHIDResourceDeviceUserClient\u7684methods\u4e2d\u7b2c\u4e09\u4e2a\u51fd\u6570_postReportResult\n\n```\nconst IOExternalMethodDispatch IOHIDResourceDeviceUserClient::_methods[kIOHIDResourceDeviceUserClientMethodCount] = \n{\n. . . . . .\n{   // kIOHIDResourceDeviceUserClientMethodPostReportResult\n        (IOExternalMethodAction) &IOHIDResourceDeviceUserClient::_postReportResult,\n        kIOHIDResourceUserClientResponseIndexCount, -1, /* 1 scalar input: the result, 1 struct input : the buffer */\n        0, 0\n}\n}\n```\n\n```\nIOReturn IOHIDResourceDeviceUserClient::postReportResult(IOExternalMethodArguments * arguments)\n{\n    OSObject * tokenObj = (OSObject*)arguments->scalarInput[kIOHIDResourceUserClientResponseIndexToken];\n    \n    if ( tokenObj && _pending->containsObject(tokenObj) ) {\n        OSData * data = OSDynamicCast(OSData, tokenObj);\n        if ( data ) {\n            __ReportResult * pResult = (__ReportResult*)data->getBytesNoCopy();\n            \n            // RY: HIGHLY UNLIKELY > 4K\n            if ( pResult->descriptor && arguments->structureInput ) {\n                pResult->descriptor->writeBytes(0, arguments->structureInput, arguments->structureInputSize);\n \n                // 12978252:  If we get an IOBMD passed in, set the length to be the # of bytes that were transferred\n                IOBufferMemoryDescriptor * buffer = OSDynamicCast(IOBufferMemoryDescriptor, pResult->descriptor);\n                if (buffer)\n                    buffer->setLength((vm_size_t)arguments->structureInputSize);\n            \n            }\n                \n            pResult->ret = (IOReturn)arguments->scalarInput[kIOHIDResourceUserClientResponseIndexResult];\n  \n            _commandGate->commandWakeup(data);\n        }\n            \n    }\n \n    return kIOReturnSuccess;\n}\n```\n\u5176\u4e2d\u4e00\u53e5\n```\nif (buffer)\n    buffer->setLength((vm_size_t)arguments->structureInputSize);\n```\n\n\u6ca1\u6709\u7ecf\u8fc7\u68c0\u67e5\u7684\u7528\u6237\u6001\u4f20\u6765\u7684\u53c2\u6570\u76f4\u63a5\u7528\u5728\u4e86setLength(\u4e0d\u5206\u914d,\u91cd\u65b0\u8bbe\u7f6e\u7f13\u51b2\u533a\u7684\u957f\u5ea6),\u6240\u4ee5\u4e0a\u9762\u7684writeBytes\u672c\u6765\u662f\u5b89\u5168\u5199\u5165.\u4f1a\u68c0\u67e5\u5199\u5165\u7684\u5927\u5c0f\u662f\u5426\u5c0f\u4e8eIOBufferMemoryDescriptor\u5bf9\u8c61\u5185\u90e8\u7684_length\u53d8\u91cf.\n\n```\nIOByteCount IOMemoryDescriptor::writeBytes\n                (IOByteCount inoffset, const void *bytes, IOByteCount length)\n{\n    . . . . . .\n    // Assert that this entire I/O is withing the available range\n    assert(offset <= _length);\n    assert(offset + length <= _length);//check \n    . . . . . .\n}\n```\n\u55ef,\u90a3\u4e48\u6211\u4eec\u56de\u5230postReportResult\u51fd\u6570,\u60f3\u8981\u53ef\u4ee5\u8bbe\u7f6ebuffer\u7684\u957f\u5ea6\u7684\u6761\u4ef6\u662fbuffer\u5b58\u5728.\u8fd9\u4e2a\u7f13\u51b2\u533a\u7684\u521d\u59cb\u5316\u5728\u5176\u4ed6\u5730\u65b9.\n\n```\nIOBufferMemoryDescriptor * buffer = OSDynamicCast(IOBufferMemoryDescriptor, pResult->descriptor);\nif (buffer)\n                    buffer->setLength((vm_size_t)arguments->structureInputSize);\n```\n\n\u90a3\u4e48\u5177\u4f53\u70b9:\n\n```\nOSObject * tokenObj = (OSObject*)arguments->scalarInput[kIOHIDResourceUserClientResponseIndexToken];\n    \n    if ( tokenObj && _pending->containsObject(tokenObj) ) {\n        OSData * data = OSDynamicCast(OSData, tokenObj);\n        if ( data ) {\n            __ReportResult * pResult = (__ReportResult*)data->getBytesNoCopy();\n             \n            // RY: HIGHLY UNLIKELY > 4K\n            if ( pResult->descriptor && arguments->structureInput ) {\n                pResult->descriptor->writeBytes(0, arguments->structureInput, arguments->structureInputSize);\n \n                // 12978252:  If we get an IOBMD passed in, set the length to be the # of bytes that were transferred\n                pResult->descriptor\n                IOBufferMemoryDescriptor * buffer = OSDynamicCast(IOBufferMemoryDescriptor,pResult->descriptor);\n                //\u53ef\u4ee5\u77e5\u9053\u5728_pending\u4e2d\u5b58\u5728tokenObj\n```\n\nok.\u5230\u8fd9\u91cc\u4e3a\u6b62.\u6b63\u5411\u5206\u6790:\n\u5148\u9700\u8981\u521b\u5efa\u4e00\u4e2aIOHIDDevice\u5bf9\u8c61.\u521b\u5efaIOHIDDevice\u5bf9\u8c61\n\n```\nconst IOExternalMethodDispatch IOHIDResourceDeviceUserClient::_methods[kIOHIDResourceDeviceUserClientMethodCount] = {\n    {   // kIOHIDResourceDeviceUserClientMethodCreate\n        (IOExternalMethodAction) &IOHIDResourceDeviceUserClient::_createDevice,\n        1, -1, /* 1 struct input : the report descriptor */\n        0, 0\n    }\n. . . . . .\n}\n```\n\n\u521b\u5efa\u65f6\u9700\u8981\u4f20\u5165\u4e00\u4e2astruct.\u8fd9\u4e2astruct\u662f\u6709\u683c\u5f0f\u5316\u7684.\u770b\u4e0b\u9762\u53ef\u4ee5\u77e5\u9053\u662f\u4e00\u4e2aXML\u7684\u6570\u636e.\u89e3\u6790\u540e\u4e3a\u4e00\u4e2a\u5b57\u5178\u5bf9\u8c61,\u5b57\u5178\u5bf9\u8c61\u91cc\u6709\u5f88\u591a\u4e0d\u540ckey\u5bf9\u5e94\u7740\u4e0d\u540c\u6570\u636e.\u89e3\u6790\u51fd\u6570\u5728IOHIDReportDescriptorParser.c\u7684PrintHIDDescriptor\u51fd\u6570\n\n```\nIOHIDReportDescriptorParser.c\u7684PrintHIDDescriptor\u51fd\u6570\nIOReturn IOHIDResourceDeviceUserClient::createDevice(IOExternalMethodArguments * arguments)\n{\n    IOMemoryDescriptor *    propertiesDesc      = NULL;\n    void *                  propertiesData      = NULL;\n    IOByteCount             propertiesLength    = 0;\n    OSObject *              object              = NULL;\n    IOReturn                result;\n    \n    // Report descriptor is static and thus can only be set on creation\n    require_action(_device==NULL, exit, result=kIOReturnInternalError);\n    \n    // Let's deal with our device properties from data\n    propertiesDesc = createMemoryDescriptorFromInputArguments(arguments); //\u4e3a\u7528\u6237\u6001\u53c2\u6570\u521d\u59cb\u5316IOMemoryDescriptor\n    require_action(propertiesDesc, exit, result=kIOReturnNoMemory);\n    \n    propertiesLength = propertiesDesc->getLength();\n    require_action(propertiesLength, exit, result=kIOReturnNoResources);\n    \n    propertiesData = IOMalloc(propertiesLength);\n    require_action(propertiesData, exit, result=kIOReturnNoMemory);\n    \n    propertiesDesc->readBytes(0, propertiesData, propertiesLength);\n    \n    require_action(strnlen((const char *) propertiesData, propertiesLength) < propertiesLength, exit, result=kIOReturnInternalError);//ERROR POINT\n \n    object = OSUnserializeXML((const char *)propertiesData, propertiesLength);\n    require_action(object, exit, result=kIOReturnInternalError);\n \n    _properties = OSDynamicCast(OSDictionary, object); //\u5c06\u7528\u6237\u6001\u4f20\u6765\u7684XML\u89e3\u6790\u51fa\u7684\u5b57\u5178\u8d4b\u7ed9_properties\n    require_action(_properties, exit, result=kIOReturnNoMemory);\n    \n    _properties->retain();\n    \n    if ( arguments->scalarInput[0] )\n        result = createAndStartDeviceAsync();\n    else\n        result = createAndStartDevice(); //\u4f1a\u8fdb\u5165\u8fd9\u91cc.\n     \n    require_noerr(result, exit);\n \nexit:\n    \n    if ( object )\n        object->release();\n    \n    if ( propertiesData && propertiesLength )\n        IOFree(propertiesData, propertiesLength);\n \n    if ( propertiesDesc )\n        propertiesDesc->release();\n    \n    return result;\n}\n```\n\n\u6b63\u5e38\u6267\u884c\u4f1a\u8fdb\u5165createAndStartDevice\u51fd\u6570.\n\n```\nIOReturn IOHIDResourceDeviceUserClient::createAndStartDevice()\n{\n    IOReturn    result;\n    OSNumber *  number = NULL;\n    \n    number = OSDynamicCast(OSNumber, _properties->getObject(kIOHIDRequestTimeoutKey));\n    if ( number )\n        _maxClientTimeoutUS = number->unsigned32BitValue();\n \n    // If after all the unwrapping we have a dictionary, let's create the device\n    _device = IOHIDUserDevice::withProperties(_properties); //\n    require_action(_device, exit, result=kIOReturnNoResources);\n    \n    require_action(_device->attach(this), exit, result=kIOReturnInternalError);\n    \n    require_action(_device->start(this), exit, _device->detach(this); result=kIOReturnInternalError);\n    \n    result = kIOReturnSuccess;\n    \nexit:\n    if ( result!=kIOReturnSuccess ) {\n        IOLog(\"%s: result=0x%08x\\n\", __FUNCTION__, result);\n        OSSafeReleaseNULL(_device);\n    }\n    return result;\n}\n```\n\n\u53ef\u4ee5\u770b\u5230\u521d\u59cb\u5316\u4e86\u4e00\u4e2aIOHIDUserDevice\u5bf9\u8c61.attach,start\u51fd\u6570\u662f\u7ee7\u627f\u81eaIOHIDDevice.\n\n```\nbool IOHIDDevice::start( IOService * provider )\n{   . . . . . .\n    // Call handleStart() before fetching the report descriptor.\n    require_action(handleStart(provider), error, result=false); //\u8c03\u7528handleStart\u4e3a_provider\u8d4b\u503c(IOHIDResourceDeviceUserClient)\n    // Fetch report descriptor for the device, and parse it.\n    require_noerr_action(newReportDescriptor(&reportDescriptor), error, result=false); \n    require_action(reportDescriptor, error, result=false); //check\n    . . . . . . \n}\n \nbool IOHIDUserDevice::handleStart( IOService * provider )\n{   . . . . . . \n    _provider = OSDynamicCast(IOHIDResourceDeviceUserClient, provider);\n    . . . . . .\n}\n \nIOReturn IOHIDUserDevice::newReportDescriptor(IOMemoryDescriptor ** descriptor ) const\n{\n    OSData *                    data;\n    \n    data = OSDynamicCast(OSData, _properties->getObject(kIOHIDReportDescriptorKey));\n    if ( !data )\n        return kIOReturnError;\n            \n    *descriptor = IOBufferMemoryDescriptor::withBytes(data->getBytesNoCopy(), data->getLength(), kIODirectionNone); //\u62f7\u8d1d\u4ece\u7528\u6237\u6001\u4f20\u6765\u7684\u6570\u636e(key\u4e3akIOHIDReportDescriptorKey)\n \n    return kIOReturnSuccess;\n}\n```\n\n\u7136\u540e\u6211\u4eec\u5728\u521b\u5efa\u5b8c\u540e\u6839\u636eIOHIDUserDevice\u8c03\u7528\u5ba2\u6237\u7aef\u7684updateElementValues\u51fd\u6570\n\u8bb0\u5f97\u4e4b\u524d\u8c03\u7528IOHIDResourceDeviceUserClient::clientMemoryForType\u521b\u5efa_queue\u5bf9\u8c61.\n\n```\nconst IOExternalMethodDispatch IOHIDLibUserClient::\nsMethods[kIOHIDLibUserClientNumCommands] = {\n{   . . . . . . \n    //    kIOHIDLibUserClientUpdateElementValues\n    (IOExternalMethodAction) &IOHIDLibUserClient::_updateElementValues,\n    kIOUCVariableStructureSize, 0,\n    0, 0\n    },\n    . . . . . . \n}\n```\n\n```\nIOReturn IOHIDLibUserClient::_updateElementValues (IOHIDLibUserClient * target, void * reference __unused, IOExternalMethodArguments * arguments)\n{\n    return target->updateElementValues(arguments->scalarInput, arguments->scalarInputCount);\n}\n \nIOReturn IOHIDLibUserClient::updateElementValues (const uint64_t * lCookies, uint32_t cookieCount)\n{\n    IOReturn    ret = kIOReturnError;\n    \n    if (fNub && !isInactive()) {\n        uint32_t    cookies[cookieCount];\n        \n        deflate_vec(cookies, cookieCount, lCookies, cookieCount);\n        \n        ret = fNub->updateElementValues((IOHIDElementCookie *)cookies, cookieCount);\n    }\n    \n    return ret;\n}\n```\n\ndeflate_vec\u4f1a\u628a\u7528\u6237\u6001\u4f20\u6765\u7684ICookies\u6574\u7406\u6210cookies\u6570\u7ec4. \nfNub\u4e3aIOHIDDevice\uff0c\u800cIOHIDUserDevice\u7ee7\u627f\u81eaIOHIDDevice, IOHIDUserDevice\u4e0b\u7684\u51fd\u6570\u591a\u4e3a\u83b7\u53d6\u5b57\u5178\u4e2d\u7684\u5404\u79cdkey\u76f8\u5e94\u7684\u503c. \u7ee7\u627f\u81eaIOHIDDevice\u51fd\u6570\u4f7f\u7528\u8fd9\u4e9b\u503c.key\u7684\u5b8f\u6765\u81eaIOHIDKeys.h  \n\u6240\u4ee5\u4f1a\u8c03\u7528\u5230IOHIDDevice\u7684updateElementValues\n\n```\nIOReturn IOHIDDevice::updateElementValues(IOHIDElementCookie *cookies, UInt32 cookieCount) {\n    IOMemoryDescriptor *\treport = NULL;\n    IOHIDElementPrivate *\t\telement = NULL;\n    IOHIDReportType\t\treportType;\n    IOByteCount\t\t\tmaxReportLength;\n    UInt8\t\t\treportID;\n    UInt32\t\t\tindex;\n    IOReturn\t\t\tret = kIOReturnError;\n \n    maxReportLength = max(_maxOutputReportSize,\n                            max(_maxFeatureReportSize, _maxInputReportSize));\n \n    // Allocate a mem descriptor with the maxReportLength.\n    // This way, we only have to allocate one mem discriptor\n    report = IOBufferMemoryDescriptor::withCapacity(maxReportLength, kIODirectionNone); //\u8fd9\u91cc\u521d\u59cb\u5316\u4e86IOBufferMemoryDescriptor \n    . . . . . . \n    for (index = 0; index < cookieCount; index++) { \n        element = GetElement(cookies[index]);\n         \n        if (element == NULL)\n            continue;\n \n        if ( element->getTransactionState()\n                != kIOHIDTransactionStatePending )\n            continue;\n \n        if ( !element->getReportType(&reportType) )\n            continue;\n \n        reportID = element->getReportID();\n        // calling down into our subclass, so lets unlock\n        WORKLOOP_UNLOCK;\n        \n        report->prepare();\n        ret = getReport(report, reportType, reportID); //\u8c03\u7528IOHIDUserDevice::getReport\n        report->complete();\n        \n        WORKLOOP_LOCK;\n \n        if ( ret != kIOReturnSuccess ) //ret\u6765\u81eaIOHIDResourceDeviceUserClient::getReport\n            break;\n       . . . . . . \n}\n```\n\n\u4f5c\u4e3afor\u5faa\u73af\u7684\u6761\u4ef6.\u7528\u6237\u6001\u4f20\u6765\u7684cookieCount\u4e00\u5b9a\u8981\u5927\u4e8e2.cookies\u7684\u503c\u4e5f\u662f\u53ef\u63a7\u7684.  \nupdateElementValues\u51fd\u6570\u5206\u914d\u4e86IOBufferMemoryDescriptor,\u6700\u540e\u8c03\u7528\u4e86getReport,\u8fd9\u91cc\u6307IOHIDUserDevice\u7684getReport  \n\u56e0\u4e3a\u4e00\u76f4\u5728\u505aIOHIDUserDevice\u5185\u7684\u64cd\u4f5c. updateElementValues\u662f\u7ee7\u627f\u81eaIOHIDDevice\n\n```\nIOReturn IOHIDUserDevice::getReport(IOMemoryDescriptor    *report,\n                                    IOHIDReportType        reportType,\n                                    IOOptionBits        options )\n{\n    return _provider->getReport(report, reportType, options); //\u8c03\u7528IOHIDResourceDeviceUserClient\u7684getReport\n}\n//\u8fd8\u8bb0\u5f97_provider\u54ea\u6765\u7684\u5417? \u5c31\u662fIOHIDResourceDeviceUserClient.\u6240\u4ee5\u5e76\u628a\u5206\u914d\u7684IOBufferMemoryDescriptor\u4f20\u8fc7\u53bb.\nIOReturn IOHIDResourceDeviceUserClient::getReport(IOMemoryDescriptor *report, IOHIDReportType reportType, IOOptionBits options)\n{\n    ReportGatedArguments    arguments   = {report, reportType, options};\n    IOReturn                result;\n    \n    require_action(!isInactive(), exit, result=kIOReturnOffline);\n \n    result = _commandGate->runAction(OSMemberFunctionCast(IOCommandGate::Action, this, &IOHIDResourceDeviceUserClient::getReportGated), &arguments);\nexit:\n    return result;\n}\n```\n\n```\nIOReturn IOHIDResourceDeviceUserClient::getReportGated(ReportGatedArguments * arguments)\n{\n    IOHIDResourceDataQueueHeader    header;\n    __ReportResult                  result;\n    AbsoluteTime                    ts;\n    IOReturn                        ret;\n    OSData *                        retData = NULL;\n    \n    require_action(!isInactive(), exit, ret=kIOReturnOffline);\n    \n    result.descriptor = arguments->report; //\u7ed3\u6784\u4f53\u6307\u5411\u5df2\u7ecf\u5206\u914d\u7684IOMemoryDescriptor\n    \n    retData = OSData::withBytesNoCopy(&result, sizeof(__ReportResult)); //retData\u4e3a__ReportResult\u7ed3\u6784\u4f53\n    require_action(retData, exit, ret=kIOReturnNoMemory);\n    \n    header.direction   = kIOHIDResourceReportDirectionIn;\n    header.type        = arguments->reportType;\n    header.reportID    = arguments->options&0xff;\n    header.length      = (uint32_t)arguments->report->getLength();\n    header.token       = (intptr_t)retData;\n \n    _pending->setObject(retData); //\u5f80_pending\u6dfb\u52a0__ReportResult\n    \n    require_action(_queue && _queue->enqueueReport(&header), exit, ret=kIOReturnNoMemory);\n    \n    // if we successfully enqueue, let's sleep till we get a result from postReportResult\n    clock_interval_to_deadline(kMicrosecondScale, _maxClientTimeoutUS, &ts);\n    switch ( _commandGate->commandSleep(retData, ts, THREAD_ABORTSAFE) ) {\n        case THREAD_AWAKENED:\n            ret = result.ret; //\u8fd4\u56de\u503c\n            break;\n        case THREAD_TIMED_OUT:\n            ret = kIOReturnTimeout;\n            break;\n        default:\n            ret = kIOReturnError;\n            break;\n    }\n}\n```\n\n```\ntypedef struct {\n    IOReturn                ret;\n    IOMemoryDescriptor *    descriptor;\n} __ReportResult;\n```\n\n\u7136\u540e\u8c03\u7528IOHIDResourceDeviceUserClient\u7684\u4e09\u53f7\u5904\u7406\u51fd\u6570postReportResult  \n\u7528\u6237\u6001\u4f20\u5165\u7684scalarInput\u4e3a\u6574\u5f62\u6570\u7ec4.\n\n```\ntypedef enum {\n    kIOHIDResourceUserClientResponseIndexResult = 0,\n    kIOHIDResourceUserClientResponseIndexToken,\n    kIOHIDResourceUserClientResponseIndexCount\n} IOHIDResourceUserClientResponseIndex;\n  \nIOReturn IOHIDResourceDeviceUserClient::postReportResult(IOExternalMethodArguments * arguments)\n{\n    OSObject * tokenObj = (OSObject*)arguments->scalarInput[kIOHIDResourceUserClientResponseIndexToken];\n    \n    if ( tokenObj && _pending->containsObject(tokenObj) ) {\n        OSData * data = OSDynamicCast(OSData, tokenObj);\n        if ( data ) {\n            __ReportResult * pResult = (__ReportResult*)data->getBytesNoCopy();\n            \n            // RY: HIGHLY UNLIKELY > 4K\n            if ( pResult->descriptor && arguments->structureInput ) {\n                pResult->descriptor->writeBytes(0, arguments->structureInput, arguments->structureInputSize);\n  \n                // 12978252:  If we get an IOBMD passed in, set the length to be the # of bytes that were transferred\n                IOBufferMemoryDescriptor * buffer = OSDynamicCast(IOBufferMemoryDescriptor, pResult->descriptor);\n                if (buffer)\n                    buffer->setLength((vm_size_t)arguments->structureInputSize);\n            \n            }\n                \n            pResult->ret = (IOReturn)arguments->scalarInput[kIOHIDResourceUserClientResponseIndexResult]; \n            //\u4f5c\u4e3aIOHIDResourceDeviceUserClient::getReportGated\u7684\u8fd4\u56de\u503c.\u4e0d\u60f3\u8ba9for\u5faa\u73af\u65ad\u5c31\u4f200(KERN_SUCCESS)\n \n            _commandGate->commandWakeup(data);\n        }\n            \n    }\n \n    return kIOReturnSuccess;\n}\n```\n\n\u7136\u540e\u81f3\u5c11\u4e24\u6b21\u8c03\u7528postReportResult,\u7b2c\u4e00\u6b21\u4f1a\u5c06buffer\u7684\u957f\u5ea6\u8bbe\u4e3a\u4efb\u610f\u503c,\u7b2c\u4e8c\u6b21\u5199\u5165\u65f6\u5c31\u6709\u6ea2\u51fa\u7684\u53ef\u80fd\n\n\u5230\u6b64\u4e3a\u6b62.\u903b\u8f91\u8fd8\u662f\u6709\u4e9b\u4e71,\u6700\u597d\u81ea\u5df1\u7ed3\u5408IOHIDFamily\u7684\u6e90\u7801\u5206\u6790.\u5b9e\u9645\u4f7f\u7528\u8bf7\u81ea\u884c\u5206\u6790\u592a\u6781\u5427.^ ^  \n[\u5229\u7528\u4ee3\u7801]({{ site.baseurl }}/2015/09/18/CVE-2015-5774Code)\n", "tags": ["iOS", "JailBreak", "cve", "C++", "Objective-C"]}