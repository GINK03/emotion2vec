{"context": "OpenBSD\u306eif_urtwn.c \u3092\u8aad\u3093\u3067\u307f\u307e\u3057\u305f\u3002\nif_urtwn.c\u306fRealtek\u306eWi-Fi\u30c1\u30c3\u30d7\u306e\u30c7\u30d0\u30a4\u30b9\u30c9\u30e9\u30a4\u30d0\u3067\u3059\u3002\n\u524d\u56de \u300cOpenBSD\u306eif_rsu.c\u3092\u8aad\u3080\u300d\u3067if_rsu.c\u3092\u3061\u3087\u3063\u3068\u8aad\u3093\u3067\u307f\u305f\u306e\u3067\u3001if_urwtn.c\u3082\u8aad\u3093\u3067\u307f\u307e\u3057\u305f\u3002\nif_urtwn.c \u306fsoftmac\u306a\u30c9\u30e9\u30a4\u30d0\u306a\u306e\u3067\u3001AP\u63a5\u7d9a\u306a\u3069\u306eMAC\u51e6\u7406\u306f\u30c9\u30e9\u30a4\u30d0\u3088\u308a\u4e0a\u5074\u3067\u51e6\u7406\u3059\u308b\u69cb\u6210\u3067\u3057\u305f\u3002\n\n\u30bd\u30fc\u30b9\u30b3\u30fc\u30c9\n\nhttp://cvsweb.openbsd.org/cgi-bin/cvsweb/src/sys/dev/usb/if_urtwn.c?rev=1.65&content-type=text/x-cvsweb-markup\nhttp://cvsweb.openbsd.org/cgi-bin/cvsweb/src/sys/dev/ic/rtwn.c?rev=1.9&content-type=text/x-cvsweb-markup\nrtwn.c\u306f\u30db\u30b9\u30c8\u30a4\u30f3\u30bf\u30d5\u30a7\u30fc\u30b9\u306b\u4f9d\u5b58\u3057\u306a\u3044\u90e8\u5206\u306e\u30b3\u30fc\u30c9\u3067\u3059\u3002PCIE, CardBus\u3001USB\u3067\u5171\u901a\u306a\u30b3\u30fc\u30c9\u3067\u3059\u3002\nrsu.c\u306b\u6bd4\u3079\u3066\u3001\u30bd\u30fc\u30b9\u30b3\u30fc\u30c9\u306e\u884c\u6570\u304c\u500d\u304f\u3089\u3044\u306b\u306a\u3063\u3066\u3044\u307e\u3059\u3002\u3000\u3067\u3082\u3001Linux\u30c9\u30e9\u30a4\u30d0\u3088\u308a\u306f\u5168\u7136\u30b3\u30fc\u30c9\u304c\u5c11\u306a\u3044\u306e\u3067\u3001\u697d\u306b\u8aad\u3081\u307e\u3059\u3002\n\n\n\u5bfe\u5fdc\u30c1\u30c3\u30d7\n\nRTL8188CTV\nRTL8188CU\nRTL8188CUS\nRTL8188ETV\nRTL8188EU\nRTL8192CU\n\n\n\u30a8\u30f3\u30c9\u30dd\u30a4\u30f3\u30c8\n\n\u9001\u4fe1\u30a8\u30f3\u30c9\u30dd\u30a4\u30f3\u30c8\n\n\u30c7\u30fc\u30bf\u9001\u4fe1\u7528\u306b\u30a8\u30f3\u30c9\u30dd\u30a4\u30f3\u30c8\u3092\u4f7f\u3046\u3002\n11e\u306eAC\u306b\u5fdc\u3058\u3066endpoint\u3092\u9078\u629e\u3059\u308b\u3002 \n\u9001\u4fe1\u30a8\u30f3\u30c9\u30dd\u30a4\u30f3\u30c8\u306e\u7dcf\u6570ntx\u306f\u30c1\u30c3\u30d7\u306b\u3088\u3063\u3066\u7570\u306a\u308b\u3002\n\n    /* Map 802.11 access categories to USB pipes. */\n    sc->ac2idx[EDCA_AC_BK] =\n    sc->ac2idx[EDCA_AC_BE] = (ntx == 3) ? 2 : ((ntx == 2) ? 1 : 0);\n    sc->ac2idx[EDCA_AC_VI] = (ntx == 3) ? 1 : 0;\n    sc->ac2idx[EDCA_AC_VO] = 0; /* Always use highest prio. */\n\n\n\u53d7\u4fe1\u30a8\u30f3\u30c9\u30dd\u30a4\u30f3\u30c8\n\n\u4e0d\u660e\n\n\n\u30b3\u30de\u30f3\u30c9\n\n\u30b3\u30de\u30f3\u30c9\u306f\u30b3\u30f3\u30c8\u30ed\u30fc\u30eb\u8ee2\u9001\u3092\u4f7f\u3046\u3002\n## \u30b3\u30de\u30f3\u30c9\u9001\u4fe1\n\u30b3\u30de\u30f3\u30c9\u3092\u66f8\u304d\u8fbc\u3080\u30a2\u30c9\u30ec\u30b9\u306fsc->fwcur\u3067\u7ba1\u7406\n\u30b3\u30de\u30f3\u30c9\u9001\u4fe1\u53ef\u80fd\u304b\u3069\u3046\u304b\u3092\u78ba\u8a8d\u3002\n\u30b3\u30de\u30f3\u30c9\u3092\u7528\u610f\nrtwn_write_2()\u3068rtwn_write_4()\u3067\u8a08\uff16\u30d0\u30a4\u30c8\u3092\u66f8\u304d\u8fbc\u307f\nsc->fwcur\u3092\u30a2\u30c3\u30d7\u30c7\u30fc\u30c8\n\nint\nrtwn_fw_cmd(struct rtwn_softc *sc, uint8_t id, const void *buf, int len)\n{\n    struct r92c_fw_cmd cmd;\n    int ntries;\n\n    /* Wait for current FW box to be empty. */\n    for (ntries = 0; ntries < 100; ntries++) {\n        if (!(rtwn_read_1(sc, R92C_HMETFR) & (1 << sc->fwcur)))\n            break;\n        DELAY(1);\n    }\n    if (ntries == 100) {\n        printf(\"%s: could not send firmware command %d\\n\",\n            sc->sc_pdev->dv_xname, id);\n        return (ETIMEDOUT);\n    }\n    memset(&cmd, 0, sizeof(cmd));\n    cmd.id = id;\n    if (len > 3)\n        cmd.id |= R92C_CMD_FLAG_EXT;\n    KASSERT(len <= sizeof(cmd.msg));\n    memcpy(cmd.msg, buf, len);\n\n    /* Write the first word last since that will trigger the FW. */\n    rtwn_write_2(sc, R92C_HMEBOX_EXT(sc->fwcur), *((uint8_t *)&cmd + 4));\n    rtwn_write_4(sc, R92C_HMEBOX(sc->fwcur), *((uint8_t *)&cmd + 0));\n\n    sc->fwcur = (sc->fwcur + 1) % R92C_H2C_NBOX;\n\n    if (sc->chip & RTWN_CHIP_PCI) {\n        /* Give firmware some time for processing. */\n        DELAY(2000);\n    }\n\n    return (0);\n}\n\n\nAP\u306b\u63a5\u7d9a\n\n\u3053\u306e\u30c9\u30e9\u30a4\u30d0\u3067\u306f\u3001AP\u306b\u63a5\u7d9a\u3059\u308b\u51e6\u7406\u306f\u5b9f\u88c5\u3055\u308c\u3066\u3044\u306a\u3044\u3002\n\u3068\u3044\u3046\u3053\u3068\u306f\u3001AP\u306b\u63a5\u7d9a\u3059\u308b\u51e6\u7406\u306f\u30ab\u30fc\u30cd\u30eb\u306eieee80211\u30ec\u30a4\u30e4\u3067\u30bd\u30d5\u30c8\u7684\u306b\u5b9f\u88c5\u3055\u308c\u3066\u3044\u308b\u3088\u3046\u3067\u3059\u3002\nieee80211_proto.c \u306bAuth\u30d5\u30ec\u30fc\u30e0\u3001Association Req\u30d5\u30ec\u30fc\u30e0\u3001Association Resp\u30d5\u30ec\u30fc\u30e0\u306e\u51e6\u7406\u304c\u3042\u308b\u306e\u3067\u3001\u305d\u3061\u3089\u3067\u884c\u3063\u3066\u3044\u308b\u3088\u3046\u3067\u3059\u3002\n\n\n\u30c7\u30fc\u30bf\u9001\u4fe1\n\nWPA\u306a\u3089 ieee80211_encrypt()\u3067\u6697\u53f7\u5316\u3059\u308b\nqid\u304b\u3089endpoint\u3092\u9078\u629e\nTX\u30d0\u30c3\u30d5\u30a1\u304b\u3089\u53d6\u5f97\nTX\u30c7\u30b9\u30af\u30ea\u30d7\u30bf\u3092\u7528\u610f\n\u30de\u30eb\u30c1\u30ad\u30e3\u30b9\u30c8\u306a\u3089\u3001\u30de\u30eb\u30c1\u30ad\u30e3\u30b9\u30c8\u9001\u4fe1\u7528\u306e\u8a2d\u5b9a\u3092\u3059\u308b\u3002(AP\u306e\u307f)\nTX\u30c7\u30b9\u30af\u30ea\u30d7\u30bf\u306b\u30b7\u30fc\u30b1\u30f3\u30b9\u756a\u53f7\u3092\u4ed8\u52a0\n\u9001\u4fe1\u30c7\u30fc\u30bf\u3092\u30d0\u30c3\u30d5\u30a1\u306b\u30b3\u30d4\u30fc\nusbd_setup_xfer\uff08\uff09\u3068usbd_transfer()\u3067USB\u306b\u8ee2\u9001\u3059\u308b\u3002\n\nint\nurtwn_tx(void *cookie, struct mbuf *m, struct ieee80211_node *ni)\n{\n    struct urtwn_softc *sc = cookie;\n    struct ieee80211com *ic = &sc->sc_sc.sc_ic;\n    struct ieee80211_frame *wh;\n    struct ieee80211_key *k = NULL;\n    struct urtwn_tx_data *data;\n    struct r92c_tx_desc_usb *txd;\n    struct usbd_pipe *pipe;\n    uint16_t qos, sum;\n    uint8_t raid, type, tid, qid;\n    int i, hasqos, xferlen, error;\n\n    wh = mtod(m, struct ieee80211_frame *);\n    type = wh->i_fc[0] & IEEE80211_FC0_TYPE_MASK;\n\n    if (wh->i_fc[1] & IEEE80211_FC1_PROTECTED) {\n        k = ieee80211_get_txkey(ic, wh, ni);\n        if ((m = ieee80211_encrypt(ic, m, k)) == NULL)\n            return (ENOBUFS);\n        wh = mtod(m, struct ieee80211_frame *);\n    }\n\n    if ((hasqos = ieee80211_has_qos(wh))) {\n        qos = ieee80211_get_qos(wh);\n        tid = qos & IEEE80211_QOS_TID;\n        qid = ieee80211_up_to_ac(ic, tid);\n    } else if (type != IEEE80211_FC0_TYPE_DATA) {\n        /* Use AC VO for management frames. */\n        qid = EDCA_AC_VO;\n    } else\n        qid = EDCA_AC_BE;\n\n    /* Get the USB pipe to use for this AC. */\n    pipe = sc->tx_pipe[sc->ac2idx[qid]];\n\n    /* Grab a Tx buffer from our free list. */\n    data = TAILQ_FIRST(&sc->tx_free_list);\n    TAILQ_REMOVE(&sc->tx_free_list, data, next);\n\n    /* Fill Tx descriptor. */\n    txd = (struct r92c_tx_desc_usb *)data->buf;\n    memset(txd, 0, sizeof(*txd));\n\n    txd->txdw0 |= htole32(\n        SM(R92C_TXDW0_PKTLEN, m->m_pkthdr.len) |\n        SM(R92C_TXDW0_OFFSET, sizeof(*txd)) |\n        R92C_TXDW0_OWN | R92C_TXDW0_FSG | R92C_TXDW0_LSG);\n    if (IEEE80211_IS_MULTICAST(wh->i_addr1))\n        txd->txdw0 |= htole32(R92C_TXDW0_BMCAST);\n\n#ifdef notyet\n    if (k != NULL) {\n        switch (k->k_cipher) {\n        case IEEE80211_CIPHER_WEP40:\n        case IEEE80211_CIPHER_WEP104:\n        case IEEE80211_CIPHER_TKIP:\n            cipher = R92C_TXDW1_CIPHER_RC4;\n            break;\n        case IEEE80211_CIPHER_CCMP:\n            cipher = R92C_TXDW1_CIPHER_AES;\n            break;\n        default:\n            cipher = R92C_TXDW1_CIPHER_NONE;\n        }\n        txd->txdw1 |= htole32(SM(R92C_TXDW1_CIPHER, cipher));\n    }\n#endif\n    if (!IEEE80211_IS_MULTICAST(wh->i_addr1) &&\n        type == IEEE80211_FC0_TYPE_DATA) {\n        if (ic->ic_curmode == IEEE80211_MODE_11B ||\n            (sc->sc_sc.sc_flags & RTWN_FLAG_FORCE_RAID_11B))\n            raid = R92C_RAID_11B;\n        else\n            raid = R92C_RAID_11BG;\n        if (sc->sc_sc.chip & RTWN_CHIP_88E) {\n            txd->txdw1 |= htole32(\n                SM(R88E_TXDW1_MACID, R92C_MACID_BSS) |\n                SM(R92C_TXDW1_QSEL, R92C_TXDW1_QSEL_BE) |\n                SM(R92C_TXDW1_RAID, raid));\n            txd->txdw2 |= htole32(R88E_TXDW2_AGGBK);\n        } else {\n            txd->txdw1 |= htole32(\n                SM(R92C_TXDW1_MACID, R92C_MACID_BSS) |\n                SM(R92C_TXDW1_QSEL, R92C_TXDW1_QSEL_BE) |\n                SM(R92C_TXDW1_RAID, raid) | R92C_TXDW1_AGGBK);\n        }\n\n        if (ic->ic_flags & IEEE80211_F_USEPROT) {\n            if (ic->ic_protmode == IEEE80211_PROT_CTSONLY) {\n                txd->txdw4 |= htole32(R92C_TXDW4_CTS2SELF |\n                    R92C_TXDW4_HWRTSEN);\n            } else if (ic->ic_protmode == IEEE80211_PROT_RTSCTS) {\n                txd->txdw4 |= htole32(R92C_TXDW4_RTSEN |\n                    R92C_TXDW4_HWRTSEN);\n            }\n        }\n        /* Send RTS at OFDM24. */\n        txd->txdw4 |= htole32(SM(R92C_TXDW4_RTSRATE, 8));\n        txd->txdw5 |= htole32(0x0001ff00);\n        /* Send data at OFDM54. */\n        txd->txdw5 |= htole32(SM(R92C_TXDW5_DATARATE, 11));\n\n    } else {\n        txd->txdw1 |= htole32(\n            SM(R92C_TXDW1_MACID, 0) |\n            SM(R92C_TXDW1_QSEL, R92C_TXDW1_QSEL_MGNT) |\n            SM(R92C_TXDW1_RAID, R92C_RAID_11B));\n\n        /* Force CCK1. */\n        txd->txdw4 |= htole32(R92C_TXDW4_DRVRATE);\n        txd->txdw5 |= htole32(SM(R92C_TXDW5_DATARATE, 0));\n    }\n    /* Set sequence number (already little endian). */\n    txd->txdseq |= *(uint16_t *)wh->i_seq;\n\n    if (!hasqos) {\n        /* Use HW sequence numbering for non-QoS frames. */\n        txd->txdw4  |= htole32(R92C_TXDW4_HWSEQ);\n        txd->txdseq |= htole16(0x8000);     /* WTF? */\n    } else\n        txd->txdw4 |= htole32(R92C_TXDW4_QOS);\n\n    /* Compute Tx descriptor checksum. */\n    sum = 0;\n    for (i = 0; i < sizeof(*txd) / 2; i++)\n        sum ^= ((uint16_t *)txd)[i];\n    txd->txdsum = sum;  /* NB: already little endian. */\n\n#if NBPFILTER > 0\n    if (__predict_false(sc->sc_drvbpf != NULL)) {\n        struct urtwn_tx_radiotap_header *tap = &sc->sc_txtap;\n        struct mbuf mb;\n\n        tap->wt_flags = 0;\n        tap->wt_chan_freq = htole16(ic->ic_bss->ni_chan->ic_freq);\n        tap->wt_chan_flags = htole16(ic->ic_bss->ni_chan->ic_flags);\n\n        mb.m_data = (caddr_t)tap;\n        mb.m_len = sc->sc_txtap_len;\n        mb.m_next = m;\n        mb.m_nextpkt = NULL;\n        mb.m_type = 0;\n        mb.m_flags = 0;\n        bpf_mtap(sc->sc_drvbpf, &mb, BPF_DIRECTION_OUT);\n    }\n#endif\n\n    xferlen = sizeof(*txd) + m->m_pkthdr.len;\n    m_copydata(m, 0, m->m_pkthdr.len, (caddr_t)&txd[1]);\n    m_freem(m);\n\n    data->pipe = pipe;\n    usbd_setup_xfer(data->xfer, pipe, data, data->buf, xferlen,\n        USBD_FORCE_SHORT_XFER | USBD_NO_COPY, URTWN_TX_TIMEOUT,\n        urtwn_txeof);\n    error = usbd_transfer(data->xfer);\n    if (__predict_false(error != USBD_IN_PROGRESS && error != 0)) {\n        /* Put this Tx buffer back to our free list. */\n        TAILQ_INSERT_TAIL(&sc->tx_free_list, data, next);\n        return (error);\n    }\n    ieee80211_release_node(ic, ni);\n    return (0);\n}\n\nOpenBSD\u306eif_urtwn.c \u3092\u8aad\u3093\u3067\u307f\u307e\u3057\u305f\u3002\n\nif_urtwn.c\u306fRealtek\u306eWi-Fi\u30c1\u30c3\u30d7\u306e\u30c7\u30d0\u30a4\u30b9\u30c9\u30e9\u30a4\u30d0\u3067\u3059\u3002\n\n\u524d\u56de [\u300cOpenBSD\u306eif_rsu.c\u3092\u8aad\u3080\u300d](http://qiita.com/eggman/items/efa941c3ab8a13975a7b)\u3067if_rsu.c\u3092\u3061\u3087\u3063\u3068\u8aad\u3093\u3067\u307f\u305f\u306e\u3067\u3001if_urwtn.c\u3082\u8aad\u3093\u3067\u307f\u307e\u3057\u305f\u3002\n\nif_urtwn.c \u306fsoftmac\u306a\u30c9\u30e9\u30a4\u30d0\u306a\u306e\u3067\u3001AP\u63a5\u7d9a\u306a\u3069\u306eMAC\u51e6\u7406\u306f\u30c9\u30e9\u30a4\u30d0\u3088\u308a\u4e0a\u5074\u3067\u51e6\u7406\u3059\u308b\u69cb\u6210\u3067\u3057\u305f\u3002\n\n\n# \u30bd\u30fc\u30b9\u30b3\u30fc\u30c9\n* http://cvsweb.openbsd.org/cgi-bin/cvsweb/src/sys/dev/usb/if_urtwn.c?rev=1.65&content-type=text/x-cvsweb-markup\n* http://cvsweb.openbsd.org/cgi-bin/cvsweb/src/sys/dev/ic/rtwn.c?rev=1.9&content-type=text/x-cvsweb-markup\n* rtwn.c\u306f\u30db\u30b9\u30c8\u30a4\u30f3\u30bf\u30d5\u30a7\u30fc\u30b9\u306b\u4f9d\u5b58\u3057\u306a\u3044\u90e8\u5206\u306e\u30b3\u30fc\u30c9\u3067\u3059\u3002PCIE, CardBus\u3001USB\u3067\u5171\u901a\u306a\u30b3\u30fc\u30c9\u3067\u3059\u3002\n* rsu.c\u306b\u6bd4\u3079\u3066\u3001\u30bd\u30fc\u30b9\u30b3\u30fc\u30c9\u306e\u884c\u6570\u304c\u500d\u304f\u3089\u3044\u306b\u306a\u3063\u3066\u3044\u307e\u3059\u3002\u3000\u3067\u3082\u3001Linux\u30c9\u30e9\u30a4\u30d0\u3088\u308a\u306f\u5168\u7136\u30b3\u30fc\u30c9\u304c\u5c11\u306a\u3044\u306e\u3067\u3001\u697d\u306b\u8aad\u3081\u307e\u3059\u3002\n\n# \u5bfe\u5fdc\u30c1\u30c3\u30d7\n* RTL8188CTV\n* RTL8188CU\n* RTL8188CUS\n* RTL8188ETV\n* RTL8188EU\n* RTL8192CU\n\n# \u30a8\u30f3\u30c9\u30dd\u30a4\u30f3\u30c8\n## \u9001\u4fe1\u30a8\u30f3\u30c9\u30dd\u30a4\u30f3\u30c8\n* \u30c7\u30fc\u30bf\u9001\u4fe1\u7528\u306b\u30a8\u30f3\u30c9\u30dd\u30a4\u30f3\u30c8\u3092\u4f7f\u3046\u3002\n* 11e\u306eAC\u306b\u5fdc\u3058\u3066endpoint\u3092\u9078\u629e\u3059\u308b\u3002 \n* \u9001\u4fe1\u30a8\u30f3\u30c9\u30dd\u30a4\u30f3\u30c8\u306e\u7dcf\u6570ntx\u306f\u30c1\u30c3\u30d7\u306b\u3088\u3063\u3066\u7570\u306a\u308b\u3002\n\n```c\n\t/* Map 802.11 access categories to USB pipes. */\n\tsc->ac2idx[EDCA_AC_BK] =\n\tsc->ac2idx[EDCA_AC_BE] = (ntx == 3) ? 2 : ((ntx == 2) ? 1 : 0);\n\tsc->ac2idx[EDCA_AC_VI] = (ntx == 3) ? 1 : 0;\n\tsc->ac2idx[EDCA_AC_VO] = 0;\t/* Always use highest prio. */\n```\n\n## \u53d7\u4fe1\u30a8\u30f3\u30c9\u30dd\u30a4\u30f3\u30c8\n* \u4e0d\u660e\n\n# \u30b3\u30de\u30f3\u30c9\n* \u30b3\u30de\u30f3\u30c9\u306f\u30b3\u30f3\u30c8\u30ed\u30fc\u30eb\u8ee2\u9001\u3092\u4f7f\u3046\u3002\n## \u30b3\u30de\u30f3\u30c9\u9001\u4fe1\n* \u30b3\u30de\u30f3\u30c9\u3092\u66f8\u304d\u8fbc\u3080\u30a2\u30c9\u30ec\u30b9\u306fsc->fwcur\u3067\u7ba1\u7406\n* \u30b3\u30de\u30f3\u30c9\u9001\u4fe1\u53ef\u80fd\u304b\u3069\u3046\u304b\u3092\u78ba\u8a8d\u3002\n* \u30b3\u30de\u30f3\u30c9\u3092\u7528\u610f\n* rtwn_write_2()\u3068rtwn_write_4()\u3067\u8a08\uff16\u30d0\u30a4\u30c8\u3092\u66f8\u304d\u8fbc\u307f\n* sc->fwcur\u3092\u30a2\u30c3\u30d7\u30c7\u30fc\u30c8\n\n```c\nint\nrtwn_fw_cmd(struct rtwn_softc *sc, uint8_t id, const void *buf, int len)\n{\n\tstruct r92c_fw_cmd cmd;\n\tint ntries;\n\n\t/* Wait for current FW box to be empty. */\n\tfor (ntries = 0; ntries < 100; ntries++) {\n\t\tif (!(rtwn_read_1(sc, R92C_HMETFR) & (1 << sc->fwcur)))\n\t\t\tbreak;\n\t\tDELAY(1);\n\t}\n\tif (ntries == 100) {\n\t\tprintf(\"%s: could not send firmware command %d\\n\",\n\t\t    sc->sc_pdev->dv_xname, id);\n\t\treturn (ETIMEDOUT);\n\t}\n\tmemset(&cmd, 0, sizeof(cmd));\n\tcmd.id = id;\n\tif (len > 3)\n\t\tcmd.id |= R92C_CMD_FLAG_EXT;\n\tKASSERT(len <= sizeof(cmd.msg));\n\tmemcpy(cmd.msg, buf, len);\n\n\t/* Write the first word last since that will trigger the FW. */\n\trtwn_write_2(sc, R92C_HMEBOX_EXT(sc->fwcur), *((uint8_t *)&cmd + 4));\n\trtwn_write_4(sc, R92C_HMEBOX(sc->fwcur), *((uint8_t *)&cmd + 0));\n\n\tsc->fwcur = (sc->fwcur + 1) % R92C_H2C_NBOX;\n\n\tif (sc->chip & RTWN_CHIP_PCI) {\n\t\t/* Give firmware some time for processing. */\n\t\tDELAY(2000);\n\t}\n\n\treturn (0);\n}\n```\n\n\n# AP\u306b\u63a5\u7d9a\n* \u3053\u306e\u30c9\u30e9\u30a4\u30d0\u3067\u306f\u3001AP\u306b\u63a5\u7d9a\u3059\u308b\u51e6\u7406\u306f\u5b9f\u88c5\u3055\u308c\u3066\u3044\u306a\u3044\u3002\n* \u3068\u3044\u3046\u3053\u3068\u306f\u3001AP\u306b\u63a5\u7d9a\u3059\u308b\u51e6\u7406\u306f\u30ab\u30fc\u30cd\u30eb\u306eieee80211\u30ec\u30a4\u30e4\u3067\u30bd\u30d5\u30c8\u7684\u306b\u5b9f\u88c5\u3055\u308c\u3066\u3044\u308b\u3088\u3046\u3067\u3059\u3002\n* ieee80211_proto.c \u306bAuth\u30d5\u30ec\u30fc\u30e0\u3001Association Req\u30d5\u30ec\u30fc\u30e0\u3001Association Resp\u30d5\u30ec\u30fc\u30e0\u306e\u51e6\u7406\u304c\u3042\u308b\u306e\u3067\u3001\u305d\u3061\u3089\u3067\u884c\u3063\u3066\u3044\u308b\u3088\u3046\u3067\u3059\u3002\n\n# \u30c7\u30fc\u30bf\u9001\u4fe1\n* WPA\u306a\u3089 ieee80211_encrypt()\u3067\u6697\u53f7\u5316\u3059\u308b\n* qid\u304b\u3089endpoint\u3092\u9078\u629e\n* TX\u30d0\u30c3\u30d5\u30a1\u304b\u3089\u53d6\u5f97\n* TX\u30c7\u30b9\u30af\u30ea\u30d7\u30bf\u3092\u7528\u610f\n* \u30de\u30eb\u30c1\u30ad\u30e3\u30b9\u30c8\u306a\u3089\u3001\u30de\u30eb\u30c1\u30ad\u30e3\u30b9\u30c8\u9001\u4fe1\u7528\u306e\u8a2d\u5b9a\u3092\u3059\u308b\u3002(AP\u306e\u307f)\n* TX\u30c7\u30b9\u30af\u30ea\u30d7\u30bf\u306b\u30b7\u30fc\u30b1\u30f3\u30b9\u756a\u53f7\u3092\u4ed8\u52a0\n* \u9001\u4fe1\u30c7\u30fc\u30bf\u3092\u30d0\u30c3\u30d5\u30a1\u306b\u30b3\u30d4\u30fc\n* usbd_setup_xfer\uff08\uff09\u3068usbd_transfer()\u3067USB\u306b\u8ee2\u9001\u3059\u308b\u3002\n\n```c\nint\nurtwn_tx(void *cookie, struct mbuf *m, struct ieee80211_node *ni)\n{\n\tstruct urtwn_softc *sc = cookie;\n\tstruct ieee80211com *ic = &sc->sc_sc.sc_ic;\n\tstruct ieee80211_frame *wh;\n\tstruct ieee80211_key *k = NULL;\n\tstruct urtwn_tx_data *data;\n\tstruct r92c_tx_desc_usb *txd;\n\tstruct usbd_pipe *pipe;\n\tuint16_t qos, sum;\n\tuint8_t raid, type, tid, qid;\n\tint i, hasqos, xferlen, error;\n\n\twh = mtod(m, struct ieee80211_frame *);\n\ttype = wh->i_fc[0] & IEEE80211_FC0_TYPE_MASK;\n\n\tif (wh->i_fc[1] & IEEE80211_FC1_PROTECTED) {\n\t\tk = ieee80211_get_txkey(ic, wh, ni);\n\t\tif ((m = ieee80211_encrypt(ic, m, k)) == NULL)\n\t\t\treturn (ENOBUFS);\n\t\twh = mtod(m, struct ieee80211_frame *);\n\t}\n\n\tif ((hasqos = ieee80211_has_qos(wh))) {\n\t\tqos = ieee80211_get_qos(wh);\n\t\ttid = qos & IEEE80211_QOS_TID;\n\t\tqid = ieee80211_up_to_ac(ic, tid);\n\t} else if (type != IEEE80211_FC0_TYPE_DATA) {\n\t\t/* Use AC VO for management frames. */\n\t\tqid = EDCA_AC_VO;\n\t} else\n\t\tqid = EDCA_AC_BE;\n\n\t/* Get the USB pipe to use for this AC. */\n\tpipe = sc->tx_pipe[sc->ac2idx[qid]];\n\n\t/* Grab a Tx buffer from our free list. */\n\tdata = TAILQ_FIRST(&sc->tx_free_list);\n\tTAILQ_REMOVE(&sc->tx_free_list, data, next);\n\n\t/* Fill Tx descriptor. */\n\ttxd = (struct r92c_tx_desc_usb *)data->buf;\n\tmemset(txd, 0, sizeof(*txd));\n\n\ttxd->txdw0 |= htole32(\n\t    SM(R92C_TXDW0_PKTLEN, m->m_pkthdr.len) |\n\t    SM(R92C_TXDW0_OFFSET, sizeof(*txd)) |\n\t    R92C_TXDW0_OWN | R92C_TXDW0_FSG | R92C_TXDW0_LSG);\n\tif (IEEE80211_IS_MULTICAST(wh->i_addr1))\n\t\ttxd->txdw0 |= htole32(R92C_TXDW0_BMCAST);\n\n#ifdef notyet\n\tif (k != NULL) {\n\t\tswitch (k->k_cipher) {\n\t\tcase IEEE80211_CIPHER_WEP40:\n\t\tcase IEEE80211_CIPHER_WEP104:\n\t\tcase IEEE80211_CIPHER_TKIP:\n\t\t\tcipher = R92C_TXDW1_CIPHER_RC4;\n\t\t\tbreak;\n\t\tcase IEEE80211_CIPHER_CCMP:\n\t\t\tcipher = R92C_TXDW1_CIPHER_AES;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tcipher = R92C_TXDW1_CIPHER_NONE;\n\t\t}\n\t\ttxd->txdw1 |= htole32(SM(R92C_TXDW1_CIPHER, cipher));\n\t}\n#endif\n\tif (!IEEE80211_IS_MULTICAST(wh->i_addr1) &&\n\t    type == IEEE80211_FC0_TYPE_DATA) {\n\t\tif (ic->ic_curmode == IEEE80211_MODE_11B ||\n\t\t    (sc->sc_sc.sc_flags & RTWN_FLAG_FORCE_RAID_11B))\n\t\t\traid = R92C_RAID_11B;\n\t\telse\n\t\t\traid = R92C_RAID_11BG;\n\t\tif (sc->sc_sc.chip & RTWN_CHIP_88E) {\n\t\t\ttxd->txdw1 |= htole32(\n\t\t\t    SM(R88E_TXDW1_MACID, R92C_MACID_BSS) |\n\t\t\t    SM(R92C_TXDW1_QSEL, R92C_TXDW1_QSEL_BE) |\n\t\t\t    SM(R92C_TXDW1_RAID, raid));\n\t\t\ttxd->txdw2 |= htole32(R88E_TXDW2_AGGBK);\n\t\t} else {\n\t\t\ttxd->txdw1 |= htole32(\n\t\t\t    SM(R92C_TXDW1_MACID, R92C_MACID_BSS) |\n\t\t\t    SM(R92C_TXDW1_QSEL, R92C_TXDW1_QSEL_BE) |\n\t\t\t    SM(R92C_TXDW1_RAID, raid) | R92C_TXDW1_AGGBK);\n\t\t}\n\n\t\tif (ic->ic_flags & IEEE80211_F_USEPROT) {\n\t\t\tif (ic->ic_protmode == IEEE80211_PROT_CTSONLY) {\n\t\t\t\ttxd->txdw4 |= htole32(R92C_TXDW4_CTS2SELF |\n\t\t\t\t    R92C_TXDW4_HWRTSEN);\n\t\t\t} else if (ic->ic_protmode == IEEE80211_PROT_RTSCTS) {\n\t\t\t\ttxd->txdw4 |= htole32(R92C_TXDW4_RTSEN |\n\t\t\t\t    R92C_TXDW4_HWRTSEN);\n\t\t\t}\n\t\t}\n\t\t/* Send RTS at OFDM24. */\n\t\ttxd->txdw4 |= htole32(SM(R92C_TXDW4_RTSRATE, 8));\n\t\ttxd->txdw5 |= htole32(0x0001ff00);\n\t\t/* Send data at OFDM54. */\n\t\ttxd->txdw5 |= htole32(SM(R92C_TXDW5_DATARATE, 11));\n\n\t} else {\n\t\ttxd->txdw1 |= htole32(\n\t\t    SM(R92C_TXDW1_MACID, 0) |\n\t\t    SM(R92C_TXDW1_QSEL, R92C_TXDW1_QSEL_MGNT) |\n\t\t    SM(R92C_TXDW1_RAID, R92C_RAID_11B));\n\n\t\t/* Force CCK1. */\n\t\ttxd->txdw4 |= htole32(R92C_TXDW4_DRVRATE);\n\t\ttxd->txdw5 |= htole32(SM(R92C_TXDW5_DATARATE, 0));\n\t}\n\t/* Set sequence number (already little endian). */\n\ttxd->txdseq |= *(uint16_t *)wh->i_seq;\n\n\tif (!hasqos) {\n\t\t/* Use HW sequence numbering for non-QoS frames. */\n\t\ttxd->txdw4  |= htole32(R92C_TXDW4_HWSEQ);\n\t\ttxd->txdseq |= htole16(0x8000);\t\t/* WTF? */\n\t} else\n\t\ttxd->txdw4 |= htole32(R92C_TXDW4_QOS);\n\n\t/* Compute Tx descriptor checksum. */\n\tsum = 0;\n\tfor (i = 0; i < sizeof(*txd) / 2; i++)\n\t\tsum ^= ((uint16_t *)txd)[i];\n\ttxd->txdsum = sum;\t/* NB: already little endian. */\n\n#if NBPFILTER > 0\n\tif (__predict_false(sc->sc_drvbpf != NULL)) {\n\t\tstruct urtwn_tx_radiotap_header *tap = &sc->sc_txtap;\n\t\tstruct mbuf mb;\n\n\t\ttap->wt_flags = 0;\n\t\ttap->wt_chan_freq = htole16(ic->ic_bss->ni_chan->ic_freq);\n\t\ttap->wt_chan_flags = htole16(ic->ic_bss->ni_chan->ic_flags);\n\n\t\tmb.m_data = (caddr_t)tap;\n\t\tmb.m_len = sc->sc_txtap_len;\n\t\tmb.m_next = m;\n\t\tmb.m_nextpkt = NULL;\n\t\tmb.m_type = 0;\n\t\tmb.m_flags = 0;\n\t\tbpf_mtap(sc->sc_drvbpf, &mb, BPF_DIRECTION_OUT);\n\t}\n#endif\n\n\txferlen = sizeof(*txd) + m->m_pkthdr.len;\n\tm_copydata(m, 0, m->m_pkthdr.len, (caddr_t)&txd[1]);\n\tm_freem(m);\n\n\tdata->pipe = pipe;\n\tusbd_setup_xfer(data->xfer, pipe, data, data->buf, xferlen,\n\t    USBD_FORCE_SHORT_XFER | USBD_NO_COPY, URTWN_TX_TIMEOUT,\n\t    urtwn_txeof);\n\terror = usbd_transfer(data->xfer);\n\tif (__predict_false(error != USBD_IN_PROGRESS && error != 0)) {\n\t\t/* Put this Tx buffer back to our free list. */\n\t\tTAILQ_INSERT_TAIL(&sc->tx_free_list, data, next);\n\t\treturn (error);\n\t}\n\tieee80211_release_node(ic, ni);\n\treturn (0);\n}\n```\n", "tags": ["Wi-Fi", "OpenBSD"]}