{"context": " More than 1 year has passed since last update.collide()\u95a2\u6570\u306e\u4e2d\u306b\u5168\u3066\u304c\u8a70\u307e\u3063\u3066\u3044\u307e\u3059\u3002\n\nParticle.pde\nclass Particle\n{\n  PVector pos;\n  PVector vel;\n  float   damping;\n  float   radius;\n  float   startTime, lifeSpan;\n  color   col;\n  float   alpha;\n  boolean dead;\n\n  // constructor\n  Particle( float _x, float _y, float _r, color _c )\n  {\n    pos    = new PVector( _x, _y );\n    radius = _r;\n\n    float strength = 0.1;\n    float angle    = random( TWO_PI );\n    vel            = new PVector( ( cos( angle ) * strength ), ( sin( angle ) * strength ) );\n\n    damping        = 0.6;\n\n    // birth time\n    startTime = millis();\n\n    // lifespan ( 10sec ~ 30sec )\n    lifeSpan  = random( 10000, 30000 );\n\n    col       = _c;\n    alpha     = 255;\n    dead      = false;\n  }\n\n  // update\n  void update()\n  {\n    // add gravity\n//    vel.y += 0.2;\n//    vel.y *= 1.002;\n\n    // decelerate\n    vel.mult( 0.99 );\n\n    // update position\n    pos.add( vel );\n\n    // bounce off\n    if( pos.x < radius )\n    {\n      pos.x += abs( pos.x - radius );\n      vel.x *= -damping;\n    }\n    else if( pos.x > ( width - radius ) )\n    {\n      pos.x -= ( pos.x - ( width - radius ) );\n      vel.x *= -damping;\n    }\n    if( pos.y < radius )\n    {\n      pos.y += abs( pos.y - radius );\n      vel.y *= -damping;\n    }\n    else if( pos.y > ( height - radius ) )\n    {\n      pos.y -= ( pos.y - ( height - radius ) );\n      vel.y *= -damping;\n    }\n\n    // over the lifespan\n    if( millis() > ( startTime + lifeSpan ) )\n    {\n      dead = true;\n//      alpha -= ( alpha / 10 );\n//      \n//      if( alpha < 1 )\n//      {\n//        dead = true;\n//      }\n    }\n  }\n\n  // draw\n  void draw()\n  {\n    fill( col, alpha );\n    ellipse( pos.x, pos.y, ( radius * 2 ), ( radius * 2 ) );\n  }\n}\n\n\n\ncollisionOfParticles.pde\n// ArrayList of particle\nArrayList< Particle > ps;\n\n////////////////////////////////////////\n// setup\n////////////////////////////////////////\nvoid setup()\n{\n  // set window size, and set renderer P2D\n  size( 400, 400, P2D );\n\n  // for fullscreen ( command + shift + R )\n//  size( displayWidth, displayHeight, P2D );\n\n  // enable resizing the window\n  frame.setResizable( true );\n\n  // enable smoothing\n  smooth();\n\n  // set color mode HSB\n  colorMode( HSB, 255 );\n\n  background( 255 );\n\n  // create instance of ArrayList\n  ps = new ArrayList< Particle >();\n}\n\n\n////////////////////////////////////////\n// draw\n////////////////////////////////////////\nvoid draw()\n{\n  background( 255 );\n  noStroke();\n\n  // add a particle\n  if( mousePressed )\n  {\n    ps.add( new Particle( mouseX, mouseY, random( 4, 10 ), color( ( frameCount * 0.1 ) % 255,  120, 255 ) ) );\n  }\n\n  // update particle position\n  for( Particle p : ps )\n  {\n    p.update();\n  }\n\n  // collision of particles\n  collide();\n\n  // remove and draw particles\n  for( int i = ( ps.size() - 1 ); i >= 0; --i )\n  {\n    Particle p = ps.get( i );\n\n    if( p.dead )\n    {\n      ps.remove( i );\n    }\n\n    p.draw();\n  }\n}\n\n\n\n\n////////////////////////////////////////\n// collide\n////////////////////////////////////////\nvoid collide()\n{\n  for( int i = 0; i < ps.size(); ++i )\n  {\n    for( int j = ( i + 1 ); j < ps.size(); ++j )\n    {\n      Particle p1 = ps.get( i );\n      Particle p2 = ps.get( j );\n\n      // vector from p1 to p2\n      PVector diff   = PVector.sub( p2.pos, p1.pos );\n\n      // distance from p1 to p2\n      float dist     = diff.mag();\n\n      // correct distance\n      float shortest = ( p1.radius + p2.radius );\n\n      if( dist < shortest )\n      {\n        diff.normalize();\n        diff.mult( ( shortest - dist ) * 0.5 );\n\n        PVector v1 = diff.get();\n        PVector v2 = PVector.mult( diff.get(), -1 );\n\n        // move to the correct position\n        p1.pos.add( v2 );\n        p2.pos.add( v1 );\n\n        // scale down the velocity\n        float vScale = 0.4;\n        PVector vv1  = PVector.mult( v1.get(), vScale );\n        PVector vv2  = PVector.mult( v2.get(), vScale );\n\n        // add velocity\n        p1.vel.add( vv2 );\n        p2.vel.add( vv1 );\n      }\n    }\n  }\n}\n\n\n\n\n////////////////////////////////////////\n// mousePressed\n////////////////////////////////////////\nvoid mousePressed()\n{\n\n}\n\n\n////////////////////////////////////////\n// keyPressed\n////////////////////////////////////////\nvoid keyPressed()\n{\n  if( key == ' ' )\n  {\n    // clear particles\n    ps.clear();\n  }\n}\n\n\ngravity\u3092\u6709\u52b9\u306b\u3059\u308b\u3068\u8352\u3076\u3063\u3066\u3057\u307e\u3046\u306e\u306f\u3069\u3046\u3057\u3066\u3060\u308d\u3046\u3002\u3002\ncollide()\u95a2\u6570\u306e\u4e2d\u306b\u5168\u3066\u304c\u8a70\u307e\u3063\u3066\u3044\u307e\u3059\u3002\n\n```java:Particle.pde\nclass Particle\n{\n  PVector pos;\n  PVector vel;\n  float   damping;\n  float   radius;\n  float   startTime, lifeSpan;\n  color   col;\n  float   alpha;\n  boolean dead;\n  \n  // constructor\n  Particle( float _x, float _y, float _r, color _c )\n  {\n    pos    = new PVector( _x, _y );\n    radius = _r;\n    \n    float strength = 0.1;\n    float angle    = random( TWO_PI );\n    vel            = new PVector( ( cos( angle ) * strength ), ( sin( angle ) * strength ) );\n    \n    damping        = 0.6;\n    \n    // birth time\n    startTime = millis();\n    \n    // lifespan ( 10sec ~ 30sec )\n    lifeSpan  = random( 10000, 30000 );\n    \n    col       = _c;\n    alpha     = 255;\n    dead      = false;\n  }\n  \n  // update\n  void update()\n  {\n    // add gravity\n//    vel.y += 0.2;\n//    vel.y *= 1.002;\n    \n    // decelerate\n    vel.mult( 0.99 );\n    \n    // update position\n    pos.add( vel );\n    \n    // bounce off\n    if( pos.x < radius )\n    {\n      pos.x += abs( pos.x - radius );\n      vel.x *= -damping;\n    }\n    else if( pos.x > ( width - radius ) )\n    {\n      pos.x -= ( pos.x - ( width - radius ) );\n      vel.x *= -damping;\n    }\n    if( pos.y < radius )\n    {\n      pos.y += abs( pos.y - radius );\n      vel.y *= -damping;\n    }\n    else if( pos.y > ( height - radius ) )\n    {\n      pos.y -= ( pos.y - ( height - radius ) );\n      vel.y *= -damping;\n    }\n    \n    // over the lifespan\n    if( millis() > ( startTime + lifeSpan ) )\n    {\n      dead = true;\n//      alpha -= ( alpha / 10 );\n//      \n//      if( alpha < 1 )\n//      {\n//        dead = true;\n//      }\n    }\n  }\n  \n  // draw\n  void draw()\n  {\n    fill( col, alpha );\n    ellipse( pos.x, pos.y, ( radius * 2 ), ( radius * 2 ) );\n  }\n}\n```\n\n```java:collisionOfParticles.pde\n// ArrayList of particle\nArrayList< Particle > ps;\n\n////////////////////////////////////////\n// setup\n////////////////////////////////////////\nvoid setup()\n{\n  // set window size, and set renderer P2D\n  size( 400, 400, P2D );\n  \n  // for fullscreen ( command + shift + R )\n//  size( displayWidth, displayHeight, P2D );\n  \n  // enable resizing the window\n  frame.setResizable( true );\n  \n  // enable smoothing\n  smooth();\n  \n  // set color mode HSB\n  colorMode( HSB, 255 );\n  \n  background( 255 );\n  \n  // create instance of ArrayList\n  ps = new ArrayList< Particle >();\n}\n\n\n////////////////////////////////////////\n// draw\n////////////////////////////////////////\nvoid draw()\n{\n  background( 255 );\n  noStroke();\n  \n  // add a particle\n  if( mousePressed )\n  {\n    ps.add( new Particle( mouseX, mouseY, random( 4, 10 ), color( ( frameCount * 0.1 ) % 255,  120, 255 ) ) );\n  }\n  \n  // update particle position\n  for( Particle p : ps )\n  {\n    p.update();\n  }\n  \n  // collision of particles\n  collide();\n  \n  // remove and draw particles\n  for( int i = ( ps.size() - 1 ); i >= 0; --i )\n  {\n    Particle p = ps.get( i );\n    \n    if( p.dead )\n    {\n      ps.remove( i );\n    }\n    \n    p.draw();\n  }\n}\n\n\n\n\n////////////////////////////////////////\n// collide\n////////////////////////////////////////\nvoid collide()\n{\n  for( int i = 0; i < ps.size(); ++i )\n  {\n    for( int j = ( i + 1 ); j < ps.size(); ++j )\n    {\n      Particle p1 = ps.get( i );\n      Particle p2 = ps.get( j );\n      \n      // vector from p1 to p2\n      PVector diff   = PVector.sub( p2.pos, p1.pos );\n      \n      // distance from p1 to p2\n      float dist     = diff.mag();\n      \n      // correct distance\n      float shortest = ( p1.radius + p2.radius );\n      \n      if( dist < shortest )\n      {\n        diff.normalize();\n        diff.mult( ( shortest - dist ) * 0.5 );\n        \n        PVector v1 = diff.get();\n        PVector v2 = PVector.mult( diff.get(), -1 );\n        \n        // move to the correct position\n        p1.pos.add( v2 );\n        p2.pos.add( v1 );\n        \n        // scale down the velocity\n        float vScale = 0.4;\n        PVector vv1  = PVector.mult( v1.get(), vScale );\n        PVector vv2  = PVector.mult( v2.get(), vScale );\n        \n        // add velocity\n        p1.vel.add( vv2 );\n        p2.vel.add( vv1 );\n      }\n    }\n  }\n}\n\n\n\n\n////////////////////////////////////////\n// mousePressed\n////////////////////////////////////////\nvoid mousePressed()\n{\n  \n}\n\n\n////////////////////////////////////////\n// keyPressed\n////////////////////////////////////////\nvoid keyPressed()\n{\n  if( key == ' ' )\n  {\n    // clear particles\n    ps.clear();\n  }\n}\n```\n\ngravity\u3092\u6709\u52b9\u306b\u3059\u308b\u3068\u8352\u3076\u3063\u3066\u3057\u307e\u3046\u306e\u306f\u3069\u3046\u3057\u3066\u3060\u308d\u3046\u3002\u3002\n", "tags": ["processing"]}