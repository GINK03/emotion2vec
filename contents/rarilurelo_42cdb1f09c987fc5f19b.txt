{"context": "\n\n\u52d5\u6a5f\nKeras\u3092\u66f8\u304f\u6a5f\u4f1a\u304c\u3042\u3063\u305f\u306e\u3067\u548c\u8a33\u3057\u307e\u3057\u305f.\n\nGetting started with the Keras Sequential model\nSequential model\u306f\u5c64\u3092\u7a4d\u307f\u91cd\u306d\u3066\u4f5c\u308b.\nSequential\u306e\u30b3\u30f3\u30b9\u30c8\u30e9\u30af\u30bf\u306b\u5c64\u306e\u30a4\u30f3\u30b9\u30bf\u30f3\u30b9\u3092\u4e0e\u3048\u308b\u3053\u3068\u3067Sequential\u3092\u4f5c\u308b\u3053\u3068\u304c\u3067\u304d\u308b.\u4e0b\u306eDense,Activation\u304c\u4e0e\u3048\u3089\u308c\u308b\u5c64(\u3061\u306a\u307f\u306bDense\u306f\u3044\u308f\u3086\u308bFull connected\u306aNeural Network).\nfrom Keras.models import Sequential\nmodel = Sequential([\n    Dense(32, input_dim=784),\n    Activation('relu'),\n    Dense(10),\n    Activation('softmax'),\n])\n\n\u307e\u305f,.add()\u30e1\u30bd\u30c3\u30c9\u3092\u4f7f\u3063\u3066\u5c64\u3092\u8ffd\u52a0\u3059\u308b\u3053\u3068\u3082\u3067\u304d\u308b.\nmodel = Sequential()\nmodel.add(Dense(32, input_dim=784))\nmodel.add(Activation('relu'))\n\n\nSpecifying the input shape\n\u30e2\u30c7\u30eb\u306f\u30a4\u30f3\u30d7\u30c3\u30c8\u306e\u6b21\u5143\u6570\u3067\u3069\u3093\u306a\u3082\u306e\u304c\u6765\u308b\u306e\u304b\u308f\u304b\u3089\u306a\u3044\u3068\u3044\u3051\u306a\u3044.\n\u305d\u306e\u305f\u3081Sequential model\u306e\u6700\u521d\u306e\u5c64\u306b\u306f\u30a4\u30f3\u30d7\u30c3\u30c8\u6b21\u5143\u306e\u60c5\u5831\u3092\u4e0e\u3048\u308b\u5fc5\u8981\u304c\u3042\u308b\uff08\u305d\u308c\u4ee5\u5916\u306e\u5c64\u306f\u81ea\u52d5\u7684\u306b\u6b21\u5143\u6570\u3092\u63a8\u8ad6\u3067\u304d\u308b\uff09.\n\u3053\u308c\u3092\u884c\u3046\u305f\u3081\u306b\uff13\u3064\u306e\u65b9\u6cd5\u304c\u3042\u308b.\n\ninput_shape\u5f15\u6570\u306b\u6e21\u3059.tuple\u3067\u6e21\u3059.\u6574\u6570\u3067\u306f\u306a\u304f\u3066None\u3067\u6e21\u3059\u3068\u6b63\u306e\u6570\u306a\u3089\u306a\u3093\u3067\u3082\u3088\u3044\u3068\u89e3\u91c8\u3055\u308c\u308b.\u30d0\u30c3\u30c1\u30b5\u30a4\u30ba\u306f\u542b\u307e\u308c\u3066\u3044\u306a\u3044.\nbatch_input_shape\u5f15\u6570\u3067\u6e21\u3059.\u3053\u308c\u306f\u30d0\u30c3\u30c1\u30b5\u30a4\u30ba\u304c\u542b\u307e\u308c\u3066\u3044\u308b.\u30d0\u30c3\u30c1\u30b5\u30a4\u30ba\u3092\u56fa\u5b9a\u3057\u305f\u3044\u6642\u306b\u6709\u52b9\u306a\u624b\u6cd5\u3068\u306a\u308b.\nDense\u306a\u3069\u306e\u4e8c\u6b21\u5143\u306e\u5c64\u306finput_dim\u5f15\u6570\u3067\u6b21\u5143\u6570\u3092\u6307\u5b9a\u3067\u304d\u308b.\u4e09\u6b21\u5143\u306e\u5c64\u3067\u306finput_dim\u5f15\u6570\u306e\u4ed6\u306binput_length\u5f15\u6570\u3092\u6307\u5b9a\u3059\u308b.\n\n\u3053\u308c\u3089\u3092\u30b3\u30fc\u30c9\u306b\u843d\u3068\u3057\u8fbc\u3093\u3060\u306e\u304c\u4ee5\u4e0b\u3067\u3042\u308b.\n\nmodel = Sequential()\nmodel.add(Dense(32, input_shape=(784,)))\n\nmodel = Sequential()\nmodel.add(Dense(32, batch_input_shape=(None, 784)))\n# note that batch dimension is \"None\" here,(\u30d0\u30c3\u30c1\u30b5\u30a4\u30ba\u304cNone\u306b\u306a\u3063\u3066\u3044\u308b\u304c)\n# so the model will be able to process batches of any size(\u3053\u308c\u3067\u30d0\u30c3\u30c1\u30b5\u30a4\u30ba\u304c\u3069\u3093\u306a\u3082\u306e\u3067\u3082\u5b66\u7fd2\u3067\u304d\u308b)\n\nmodel = Sequential()\nmodel.add(Dense(32, input_dim=784))\n\n\n\u305d\u3057\u3066\u6b21\u306e\uff13\u3064\u3082\u540c\u69d8\u306e\u610f\u5473\u3092\u6301\u3064\u30b3\u30fc\u30c9\u3068\u306a\u308b.\n\nmodel = Sequential()\nmodel.add(LSTM(32, input_shape=(10, 64)))\n\nmodel = Sequential()\nmodel.add(LSTM(32, batch_input_shape=(None, 10, 64)))\n\nmodel = Sequential()\nmodel.add(LSTM(32, input_length=10, input_dim=64))\n\n\n\nThe Merge layer\n\u5e7e\u3064\u304b\u306eSequential\u306e\u30a4\u30f3\u30b9\u30bf\u30f3\u30b9\u3092\u7d71\u5408\u3057,\uff11\u3064\u306e\u30a2\u30a6\u30c8\u30d7\u30c3\u30c8\u3092\u51fa\u529b\u3059\u308b\u3088\u3046\u306b\u3059\u308b\u3053\u3068\u304c\u3067\u304d\u308b.\n\u51fa\u529b\u306eSequential\u306f\u65b0\u305f\u306aSequential\u306b\u5c64\u3068\u3057\u3066\u7a4d\u307f\u91cd\u306d\u308b\u3053\u3068\u304c\u3067\u304d\u308b.\n\u4ee5\u4e0b\u304c\u5b9f\u4f8b\u3068,\u5c64\u306e\u6982\u5ff5\u56f3\u3067\u3042\u308b.\nfrom keras.layers import Merge\n\nleft_branch = Sequential()\nleft_branch.add(Dense(32, input_dim=784))\n\nright_branch = Sequential()\nright_branch.add(Dense(32, input_dim=784))\n\nmerged = Merge([left_branch, right_branch], mode='concat')\n\nfinal_model = Sequential()\nfinal_model.add(merged)\nfinal_model.add(Dense(10, activation='softmax'))\n\n\nMerge\u306f\u3044\u304f\u3064\u304b\u306emode\u304c\u7528\u610f\u3055\u308c\u3066\u3044\u3066,\uff12\u3064\u306e\u30c6\u30f3\u30bd\u30eb\u306eMerge\u306e\u4ed5\u65b9\u3092\u8a18\u8ff0\u3067\u304d\u308b.\n+ sum(default): \u8981\u7d20\u6bce\u306b\u8db3\u3057\u5408\u308f\u305b\u308b.\n+ concat: \u30c6\u30f3\u30bd\u30eb\u3092\u9023\u7d50\u3059\u308b.\u9023\u7d50\u3059\u308b\u6b21\u5143\u3092concat_axis\u5f15\u6570\u3067\u6307\u5b9a\u3059\u308b.\n+ mul: \u8981\u7d20\u6bce\u306b\u639b\u3051\u5408\u308f\u305b\u308b.\n+ ave: \u30c6\u30f3\u30bd\u30eb\u306e\u5e73\u5747.\n+ dot: \u5185\u7a4d.\u3069\u306e\u6b21\u5143\u306b\u5bfe\u3057\u3066\u5185\u7a4d\u3092\u3068\u308b\u304bdot_axes\u5f15\u6570\u3067\u6307\u5b9a\u3059\u308b.\n+ cos: \u4e8c\u6b21\u5143\u30c6\u30f3\u30bd\u30eb\u306b\u5bfe\u3057\u3066cosine proximity\u3092\u3068\u308b.\nmode\u5f15\u6570\u306b\u306flambda\u5f0f\u306a\u3069\u3092\u4f7f\u3063\u3066\u4efb\u610f\u306e\u8a08\u7b97\u5f0f\u3092\u8a18\u8ff0\u3067\u304d\u308b.\nmerged = Merge([left_branch, right_branch], mode=lambda x, y: x - y)\n\nSequential\u3068Merge\u3067\u8868\u3059\u3053\u3068\u306e\u3067\u304d\u306a\u3044\u8907\u96d1\u306a\u30e2\u30c7\u30eb\u3092\u69cb\u7bc9\u3059\u308b\u5834\u5408\u306fthe function API\u3092\u53c2\u7167\u3059\u308b\u5fc5\u8981\u304c\u3042\u308b.\n\nCompilation\n\u30e2\u30c7\u30eb\u3092\u5b66\u7fd2\u3055\u305b\u308b\u524d\u306b\u5b66\u7fd2\u30d7\u30ed\u30bb\u30b9\u306e\u8a2d\u5b9a\u3092\u884c\u3046\u5fc5\u8981\u304c\u3042\u308b.\ncompile\u30e1\u30bd\u30c3\u30c9\u306b\u3088\u3063\u3066\u304a\u3053\u306a\u308f\u308c\u308b.compile\u30e1\u30bd\u30c3\u30c9\u306f\u4ee5\u4e0b\u306e\uff13\u3064\u306e\u5f15\u6570\u3092\u3068\u308b.\n+ \u6700\u9069\u5316\u624b\u6cd5.optimizer\u5f15\u6570.rmsprop\u3084adagrad\u306a\u3069Optimizerclass\u306e\u30a4\u30f3\u30b9\u30bf\u30f3\u30b9\u3092\u6307\u5b9a\u3059\u308b.optimizers\u53c2\u7167.\n+ \u640d\u5931\u95a2\u6570.model\u306f\u3053\u306e\u95a2\u6570\u3092\u6700\u5c0f\u5316\u3059\u308b\u3088\u3046\u306b\u5b66\u7fd2\u3059\u308b.objectives\u53c2\u7167.\n+ \u7cbe\u5ea6(metrics).\u5206\u985e\u30bf\u30b9\u30af\u306b\u304a\u3044\u3066metrics=['accuracy']\u3068\u3057\u3066\u7cbe\u5ea6\u3092\u8a08\u7b97\u3059\u308b.\u73fe\u72b6accuracy\u306e\u307f\u5b9f\u88c5\u3055\u308c\u3066\u3044\u308b.\n# for a multi-class classification problem\nmodel.compile(optimizer='rmsprop',\n              loss='categorical_crossentropy',\n              metrics=['accuracy'])\n\n# for a binary classification problem\nmodel.compile(optimizer='rmsprop',\n              loss='binary_crossentropy',\n              metrics=['accuracy'])\n\n# for a mean squared error regression problem\nmodel.compile(optimizer='rmsprop',\n              loss='mse')\n\n\nTraining\nKeras\u3067\u306fNumpy\u914d\u5217\u306e\u30a4\u30f3\u30d7\u30c3\u30c8\u3068\u30e9\u30d9\u30eb\u3067\u5b66\u7fd2\u304c\u884c\u308f\u308c\u308b.\n\u5b66\u7fd2\u30d5\u30a7\u30fc\u30ba\u3067\u306ffit\u95a2\u6570\u304c\u3088\u304f\u4f7f\u308f\u308c\u308b.\n# for a single-input model with 2 classes(binary):(\u4e8c\u30af\u30e9\u30b9\u5206\u985e)\n\nmodel = Sequential()\nmodel.add(Dense(1, input_dim=784, activation='softmax'))\nmodel.compile(optimizer='rmsprop',\n              loss='binary_crossentropy',\n              metrics=['accuracy'])\n\n# generate dummy data(\u9069\u5f53\u306a\u30a4\u30f3\u30d7\u30c3\u30c8\u30c7\u30fc\u30bf\u3092\u4f5c\u308b)\nimport numpy as np\ndata = np.random.random((1000, 784))\nlabels = np.random.randint(2, size=(1000, 1))\n\n# train the model, interating on the data in batches(\u30d0\u30c3\u30c1\u30b5\u30a4\u30ba\uff13\uff12\u3067\u5b66\u7fd2\u3092\u884c\u3046)\n# of 32 samples\nmodel.fit(data, labels, nb_epoch=10, batch_size=32)\n\n# for a multi-input model with 10 classes:(\uff11\uff10\u30af\u30e9\u30b9\u5206\u985e)\n\nleft_branch = Sequential()\nleft_branch.add(Dense(32, input_dim=784))\n\nright_branch = Sequential()\nright_branch.add(Dense(32, input_dim=784))\n\nmerged = Merge([left_branch, right_branch], mode='concat')\n\nmodel = Sequential()\nmodel.add(merged)\nmodel.add(Dense(10, activation='softmax'))\n\nmodel.compile(optimizer='rmsprop',\n              loss='categorical_crossentropy',\n              metrics=['accuracy'])\n\n# generate dummy data(\u9069\u5f53\u306a\u30a4\u30f3\u30d7\u30c3\u30c8\u30c7\u30fc\u30bf\u4f5c\u6210)\nimport numpy as np\nfrom keras.utils.np_utils import to_categorical\ndata_1 = np.random.random((1000, 784))\ndata_2 = np.random.random((1000, 784))\n\n# these are integers between 0 and 9(\uff10\u304b\u3089\uff19\u306e\u6574\u6570\u5024\u3092\u751f\u6210)\nlabels = np.random.randint(10, size=(1000, 1))\n# we convert the labels to a binary matrix of size (1000, 10)(\u591a\u30af\u30e9\u30b9\u5206\u985e\u30bf\u30b9\u30af\u306b\u4f7f\u3048\u308b\u3088\u3046\u306b1-hot vector\u306b\u5909\u63db)\n# for use with categorical_crossentropy\nlabels = to_categorical(labels, 10)\n\n# train the model\n#note that we are passing a list of Numpy arrays as training data\n# since the model has 2 inputs(\uff12\u3064\u306e\u30a4\u30f3\u30d7\u30c3\u30c8\u3092\u5f15\u6570\u3067\u3068\u308b)\nmodel.fit([data_1, data_2], labels, nb_epoch=10, batch_size=32)\n\n\nExamples\n\u3044\u304f\u3064\u304b\u306e\u5b9f\u88c5\u4f8b\u304c\u306e\u3063\u3066\u3044\u307e\u3059.\u672c\u5bb6Keras\u3092\u78ba\u8a8d\u3057\u3066\u304f\u3060\u3055\u3044.\n# \u52d5\u6a5f\nKeras\u3092\u66f8\u304f\u6a5f\u4f1a\u304c\u3042\u3063\u305f\u306e\u3067\u548c\u8a33\u3057\u307e\u3057\u305f.\n# Getting started with the Keras Sequential model\nSequential model\u306f\u5c64\u3092\u7a4d\u307f\u91cd\u306d\u3066\u4f5c\u308b.\nSequential\u306e\u30b3\u30f3\u30b9\u30c8\u30e9\u30af\u30bf\u306b\u5c64\u306e\u30a4\u30f3\u30b9\u30bf\u30f3\u30b9\u3092\u4e0e\u3048\u308b\u3053\u3068\u3067Sequential\u3092\u4f5c\u308b\u3053\u3068\u304c\u3067\u304d\u308b.\u4e0b\u306e`Dense`,`Activation`\u304c\u4e0e\u3048\u3089\u308c\u308b\u5c64(\u3061\u306a\u307f\u306bDense\u306f\u3044\u308f\u3086\u308bFull connected\u306aNeural Network).\n\n```\nfrom Keras.models import Sequential\nmodel = Sequential([\n\tDense(32, input_dim=784),\n\tActivation('relu'),\n\tDense(10),\n\tActivation('softmax'),\n])\n```\n\n\u307e\u305f,`.add()`\u30e1\u30bd\u30c3\u30c9\u3092\u4f7f\u3063\u3066\u5c64\u3092\u8ffd\u52a0\u3059\u308b\u3053\u3068\u3082\u3067\u304d\u308b.\n\n```\nmodel = Sequential()\nmodel.add(Dense(32, input_dim=784))\nmodel.add(Activation('relu'))\n```\n\n### Specifying the input shape\n\u30e2\u30c7\u30eb\u306f\u30a4\u30f3\u30d7\u30c3\u30c8\u306e\u6b21\u5143\u6570\u3067\u3069\u3093\u306a\u3082\u306e\u304c\u6765\u308b\u306e\u304b\u308f\u304b\u3089\u306a\u3044\u3068\u3044\u3051\u306a\u3044.\n\u305d\u306e\u305f\u3081Sequential model\u306e\u6700\u521d\u306e\u5c64\u306b\u306f\u30a4\u30f3\u30d7\u30c3\u30c8\u6b21\u5143\u306e\u60c5\u5831\u3092\u4e0e\u3048\u308b\u5fc5\u8981\u304c\u3042\u308b\uff08\u305d\u308c\u4ee5\u5916\u306e\u5c64\u306f\u81ea\u52d5\u7684\u306b\u6b21\u5143\u6570\u3092\u63a8\u8ad6\u3067\u304d\u308b\uff09.\n\u3053\u308c\u3092\u884c\u3046\u305f\u3081\u306b\uff13\u3064\u306e\u65b9\u6cd5\u304c\u3042\u308b.\n\n1. input_shape\u5f15\u6570\u306b\u6e21\u3059.tuple\u3067\u6e21\u3059.\u6574\u6570\u3067\u306f\u306a\u304f\u3066None\u3067\u6e21\u3059\u3068\u6b63\u306e\u6570\u306a\u3089\u306a\u3093\u3067\u3082\u3088\u3044\u3068\u89e3\u91c8\u3055\u308c\u308b.\u30d0\u30c3\u30c1\u30b5\u30a4\u30ba\u306f\u542b\u307e\u308c\u3066\u3044\u306a\u3044.\n2. batch_input_shape\u5f15\u6570\u3067\u6e21\u3059.\u3053\u308c\u306f\u30d0\u30c3\u30c1\u30b5\u30a4\u30ba\u304c\u542b\u307e\u308c\u3066\u3044\u308b.\u30d0\u30c3\u30c1\u30b5\u30a4\u30ba\u3092\u56fa\u5b9a\u3057\u305f\u3044\u6642\u306b\u6709\u52b9\u306a\u624b\u6cd5\u3068\u306a\u308b.\n3. Dense\u306a\u3069\u306e\u4e8c\u6b21\u5143\u306e\u5c64\u306finput_dim\u5f15\u6570\u3067\u6b21\u5143\u6570\u3092\u6307\u5b9a\u3067\u304d\u308b.\u4e09\u6b21\u5143\u306e\u5c64\u3067\u306finput_dim\u5f15\u6570\u306e\u4ed6\u306binput_length\u5f15\u6570\u3092\u6307\u5b9a\u3059\u308b.\n\n\u3053\u308c\u3089\u3092\u30b3\u30fc\u30c9\u306b\u843d\u3068\u3057\u8fbc\u3093\u3060\u306e\u304c\u4ee5\u4e0b\u3067\u3042\u308b.\n\n1. \n```\n\tmodel = Sequential()\n\tmodel.add(Dense(32, input_shape=(784,)))\n```\n\n2. \n```\n\tmodel = Sequential()\n\tmodel.add(Dense(32, batch_input_shape=(None, 784)))\n\t# note that batch dimension is \"None\" here,(\u30d0\u30c3\u30c1\u30b5\u30a4\u30ba\u304cNone\u306b\u306a\u3063\u3066\u3044\u308b\u304c)\n\t# so the model will be able to process batches of any size(\u3053\u308c\u3067\u30d0\u30c3\u30c1\u30b5\u30a4\u30ba\u304c\u3069\u3093\u306a\u3082\u306e\u3067\u3082\u5b66\u7fd2\u3067\u304d\u308b)\n```\n\n3. \n```\n\tmodel = Sequential()\n\tmodel.add(Dense(32, input_dim=784))\n```\n\n\u305d\u3057\u3066\u6b21\u306e\uff13\u3064\u3082\u540c\u69d8\u306e\u610f\u5473\u3092\u6301\u3064\u30b3\u30fc\u30c9\u3068\u306a\u308b.\n\n1. \n```\n\tmodel = Sequential()\n\tmodel.add(LSTM(32, input_shape=(10, 64)))\n```\n\n2. \n```\n\tmodel = Sequential()\n\tmodel.add(LSTM(32, batch_input_shape=(None, 10, 64)))\n```\n\n3. \n```\n\tmodel = Sequential()\n\tmodel.add(LSTM(32, input_length=10, input_dim=64))\n```\n\n### The Merge layer\n\u5e7e\u3064\u304b\u306eSequential\u306e\u30a4\u30f3\u30b9\u30bf\u30f3\u30b9\u3092\u7d71\u5408\u3057,\uff11\u3064\u306e\u30a2\u30a6\u30c8\u30d7\u30c3\u30c8\u3092\u51fa\u529b\u3059\u308b\u3088\u3046\u306b\u3059\u308b\u3053\u3068\u304c\u3067\u304d\u308b.\n\u51fa\u529b\u306eSequential\u306f\u65b0\u305f\u306aSequential\u306b\u5c64\u3068\u3057\u3066\u7a4d\u307f\u91cd\u306d\u308b\u3053\u3068\u304c\u3067\u304d\u308b.\n\u4ee5\u4e0b\u304c\u5b9f\u4f8b\u3068,\u5c64\u306e\u6982\u5ff5\u56f3\u3067\u3042\u308b.\n\n```\nfrom keras.layers import Merge\n\nleft_branch = Sequential()\nleft_branch.add(Dense(32, input_dim=784))\n\nright_branch = Sequential()\nright_branch.add(Dense(32, input_dim=784))\n\nmerged = Merge([left_branch, right_branch], mode='concat')\n\nfinal_model = Sequential()\nfinal_model.add(merged)\nfinal_model.add(Dense(10, activation='softmax'))\n```\n\n![two_branches_sequential_model.png](https://qiita-image-store.s3.amazonaws.com/0/121302/8f25ee50-2e78-35ff-b9d8-674a9b50a795.png)\n\n\nMerge\u306f\u3044\u304f\u3064\u304b\u306emode\u304c\u7528\u610f\u3055\u308c\u3066\u3044\u3066,\uff12\u3064\u306e\u30c6\u30f3\u30bd\u30eb\u306eMerge\u306e\u4ed5\u65b9\u3092\u8a18\u8ff0\u3067\u304d\u308b.\n+ `sum`(default): \u8981\u7d20\u6bce\u306b\u8db3\u3057\u5408\u308f\u305b\u308b.\n+ `concat`: \u30c6\u30f3\u30bd\u30eb\u3092\u9023\u7d50\u3059\u308b.\u9023\u7d50\u3059\u308b\u6b21\u5143\u3092`concat_axis`\u5f15\u6570\u3067\u6307\u5b9a\u3059\u308b.\n+ `mul`: \u8981\u7d20\u6bce\u306b\u639b\u3051\u5408\u308f\u305b\u308b.\n+ `ave`: \u30c6\u30f3\u30bd\u30eb\u306e\u5e73\u5747.\n+ `dot`: \u5185\u7a4d.\u3069\u306e\u6b21\u5143\u306b\u5bfe\u3057\u3066\u5185\u7a4d\u3092\u3068\u308b\u304b`dot_axes`\u5f15\u6570\u3067\u6307\u5b9a\u3059\u308b.\n+ `cos`: \u4e8c\u6b21\u5143\u30c6\u30f3\u30bd\u30eb\u306b\u5bfe\u3057\u3066cosine proximity\u3092\u3068\u308b.\n\nmode\u5f15\u6570\u306b\u306flambda\u5f0f\u306a\u3069\u3092\u4f7f\u3063\u3066\u4efb\u610f\u306e\u8a08\u7b97\u5f0f\u3092\u8a18\u8ff0\u3067\u304d\u308b.\n\n```\nmerged = Merge([left_branch, right_branch], mode=lambda x, y: x - y)\n```\n\nSequential\u3068Merge\u3067\u8868\u3059\u3053\u3068\u306e\u3067\u304d\u306a\u3044\u8907\u96d1\u306a\u30e2\u30c7\u30eb\u3092\u69cb\u7bc9\u3059\u308b\u5834\u5408\u306f[the function API](http://keras.io/getting-started/functional-api-guide)\u3092\u53c2\u7167\u3059\u308b\u5fc5\u8981\u304c\u3042\u308b.\n\n### Compilation\n\u30e2\u30c7\u30eb\u3092\u5b66\u7fd2\u3055\u305b\u308b\u524d\u306b\u5b66\u7fd2\u30d7\u30ed\u30bb\u30b9\u306e\u8a2d\u5b9a\u3092\u884c\u3046\u5fc5\u8981\u304c\u3042\u308b.\n`compile`\u30e1\u30bd\u30c3\u30c9\u306b\u3088\u3063\u3066\u304a\u3053\u306a\u308f\u308c\u308b.`compile`\u30e1\u30bd\u30c3\u30c9\u306f\u4ee5\u4e0b\u306e\uff13\u3064\u306e\u5f15\u6570\u3092\u3068\u308b.\n+ \u6700\u9069\u5316\u624b\u6cd5.`optimizer`\u5f15\u6570.`rmsprop`\u3084`adagrad`\u306a\u3069`Optimizer`class\u306e\u30a4\u30f3\u30b9\u30bf\u30f3\u30b9\u3092\u6307\u5b9a\u3059\u308b.[optimizers](http://keras.io/optimizers)\u53c2\u7167.\n+ \u640d\u5931\u95a2\u6570.model\u306f\u3053\u306e\u95a2\u6570\u3092\u6700\u5c0f\u5316\u3059\u308b\u3088\u3046\u306b\u5b66\u7fd2\u3059\u308b.[objectives](http://keras.io/objectives)\u53c2\u7167.\n+ \u7cbe\u5ea6(metrics).\u5206\u985e\u30bf\u30b9\u30af\u306b\u304a\u3044\u3066`metrics=['accuracy']`\u3068\u3057\u3066\u7cbe\u5ea6\u3092\u8a08\u7b97\u3059\u308b.\u73fe\u72b6`accuracy`\u306e\u307f\u5b9f\u88c5\u3055\u308c\u3066\u3044\u308b.\n\n\n```\n# for a multi-class classification problem\nmodel.compile(optimizer='rmsprop',\n\t\t\t  loss='categorical_crossentropy',\n\t\t\t  metrics=['accuracy'])\n\n# for a binary classification problem\nmodel.compile(optimizer='rmsprop',\n\t\t\t  loss='binary_crossentropy',\n\t\t\t  metrics=['accuracy'])\n\n# for a mean squared error regression problem\nmodel.compile(optimizer='rmsprop',\n\t\t\t  loss='mse')\n```\n\n### Training\nKeras\u3067\u306fNumpy\u914d\u5217\u306e\u30a4\u30f3\u30d7\u30c3\u30c8\u3068\u30e9\u30d9\u30eb\u3067\u5b66\u7fd2\u304c\u884c\u308f\u308c\u308b.\n\u5b66\u7fd2\u30d5\u30a7\u30fc\u30ba\u3067\u306f`fit`\u95a2\u6570\u304c\u3088\u304f\u4f7f\u308f\u308c\u308b.\n\n```\n# for a single-input model with 2 classes(binary):(\u4e8c\u30af\u30e9\u30b9\u5206\u985e)\n\nmodel = Sequential()\nmodel.add(Dense(1, input_dim=784, activation='softmax'))\nmodel.compile(optimizer='rmsprop',\n\t\t\t  loss='binary_crossentropy',\n\t\t\t  metrics=['accuracy'])\n\n# generate dummy data(\u9069\u5f53\u306a\u30a4\u30f3\u30d7\u30c3\u30c8\u30c7\u30fc\u30bf\u3092\u4f5c\u308b)\nimport numpy as np\ndata = np.random.random((1000, 784))\nlabels = np.random.randint(2, size=(1000, 1))\n\n# train the model, interating on the data in batches(\u30d0\u30c3\u30c1\u30b5\u30a4\u30ba\uff13\uff12\u3067\u5b66\u7fd2\u3092\u884c\u3046)\n# of 32 samples\nmodel.fit(data, labels, nb_epoch=10, batch_size=32)\n```\n\n```\n# for a multi-input model with 10 classes:(\uff11\uff10\u30af\u30e9\u30b9\u5206\u985e)\n\nleft_branch = Sequential()\nleft_branch.add(Dense(32, input_dim=784))\n\nright_branch = Sequential()\nright_branch.add(Dense(32, input_dim=784))\n\nmerged = Merge([left_branch, right_branch], mode='concat')\n\nmodel = Sequential()\nmodel.add(merged)\nmodel.add(Dense(10, activation='softmax'))\n\nmodel.compile(optimizer='rmsprop',\n\t\t\t  loss='categorical_crossentropy',\n\t\t\t  metrics=['accuracy'])\n\n# generate dummy data(\u9069\u5f53\u306a\u30a4\u30f3\u30d7\u30c3\u30c8\u30c7\u30fc\u30bf\u4f5c\u6210)\nimport numpy as np\nfrom keras.utils.np_utils import to_categorical\ndata_1 = np.random.random((1000, 784))\ndata_2 = np.random.random((1000, 784))\n\n# these are integers between 0 and 9(\uff10\u304b\u3089\uff19\u306e\u6574\u6570\u5024\u3092\u751f\u6210)\nlabels = np.random.randint(10, size=(1000, 1))\n# we convert the labels to a binary matrix of size (1000, 10)(\u591a\u30af\u30e9\u30b9\u5206\u985e\u30bf\u30b9\u30af\u306b\u4f7f\u3048\u308b\u3088\u3046\u306b1-hot vector\u306b\u5909\u63db)\n# for use with categorical_crossentropy\nlabels = to_categorical(labels, 10)\n\n# train the model\n#note that we are passing a list of Numpy arrays as training data\n# since the model has 2 inputs(\uff12\u3064\u306e\u30a4\u30f3\u30d7\u30c3\u30c8\u3092\u5f15\u6570\u3067\u3068\u308b)\nmodel.fit([data_1, data_2], labels, nb_epoch=10, batch_size=32)\n```\n\n### Examples\n\u3044\u304f\u3064\u304b\u306e\u5b9f\u88c5\u4f8b\u304c\u306e\u3063\u3066\u3044\u307e\u3059.\u672c\u5bb6[Keras](http://keras.io/getting-started/sequential-model-guide/)\u3092\u78ba\u8a8d\u3057\u3066\u304f\u3060\u3055\u3044.\n\n", "tags": ["Keras", "Python", "DeepLearning", "Sequential", "model"]}