{"context": " More than 1 year has passed since last update.Lisp\u306e\u52c9\u5f37\u304c\u3066\u3089CoffeeScript\u3067\u4f5c\u3063\u3066\u307f\u307e\u3057\u305f\u3002\n\u4ed5\u69d8\u306f http://ja.wikipedia.org/wiki/LISP \u3084 http://ja.wikipedia.org/wiki/\u7d14LISP \u3092\u53c2\u8003\u306b\u30b0\u30b0\u308a\u306a\u304c\u3089\u3084\u3063\u305f\u306e\u3067\u3001\u9055\u3046\u3068\u3053\u308d\u304c\u3042\u308b\u304b\u3082\u3057\u308c\u307e\u305b\u3093\u3002\n\u30bd\u30fc\u30b9\u306f https://github.com/long-long-float/lisp-js/tree/limit200 \u3067\u3001 http://long-long-float.github.io/lisp-js/index.html \u3067\u5b9f\u969b\u306b\u52d5\u304b\u3059\u3053\u3068\u304c\u3067\u304d\u307e\u3059\u3002\nclass Symbol\n  constructor: (@name) ->\n  toString: -> @name\n\nclass Nil\n  toString: -> 'nil'\nnil = new Nil\nclass T\n  toString: -> 't'\nt = new T\n\nclass List\n  constructor: (@values) ->\n  toString: -> \"(#{@values.map((v) -> v.toString()).join(' ')})\"\n\nclass CallFun\n  constructor: (@funname, @args) ->\n  toString: -> \"(#{@funname} #{@values.map((v) -> v.toString()).join(' ')})\"\n\nSF_NAMES = ['cond', 'quote', 'lambda', 'defun']\nclass SpecialForm\n  constructor: (@name, @args) ->\n  toString: -> \"(#{@name} #{@args.map((v) -> v.toString()).join(' ')})\"\n\nclass Lambda\n  constructor: (@params, @body) ->\n\nclass Environment\n  constructor: (@variables) ->\n  get: (name) ->\n    val = @variables[name]\n    throw \"undefined #{name}\" unless val\n    return val\n  set: (name, val) -> @variables[name] = val\n\nisAtom = (val) ->\n  typeof val == 'string' or typeof val == 'number' or\n    val instanceof Nil or val instanceof T\n\nenvstack = []\ncurrentEnv = ->\n  throw \"envstack is empty\" unless envstack.length > 0\n  envstack[envstack.length - 1]\n\nclass @Parser\n  skip: ->\n    @pos++ while @code[@pos]?.match /[ \\r\\n\\t]/\n\n  isEOF: ->\n    @pos == @code.length\n\n  expects: (pattern, throwing = false) ->\n    valid = @code[@pos] && (pattern instanceof RegExp and pattern.test @code[@pos]) || pattern == @code[@pos...@pos + pattern.length]\n    if !valid && throwing\n      throw \"unexpected \\\"#{@code[@pos]}\\\", expects \\\"#{pattern}\\\"\"\n\n    return valid\n\n  forwards: (pattern) ->\n    @expects pattern, true\n    @code[@pos]\n    @pos += if pattern instanceof RegExp then 1 else pattern.length\n\n  forwards_if: (pattern) ->\n    @forwards pattern if @expects pattern\n\n  atom: ->\n    #number\n    if @expects /[0-9]/\n      num = ''\n      num += @code[@pos++] while @expects /[0-9]/\n      return parseInt(num)\n\n    #string\n    if @forwards_if '\"'\n      str = ''\n      str += @code[@pos++] until @expects '\"'\n      @forwards '\"'\n      return str\n\n    return nil if @forwards_if 'nil'\n    return t if @forwards_if 't'\n\n    #var\n    return new Symbol(@symbol())\n\n  symbol: ->\n    ret = ''\n    ret += @code[@pos++] while @expects /[\\w!#$%&=-~^|*+<>?_]/\n    return ret\n\n  list: ->\n    @forwards '('\n    values = []\n    until @expects(')') or @isEOF()\n      values.push @expr()\n      @skip()\n    @forwards ')'\n    return new List(values)\n\n  call_fun: ->\n    @forwards '('\n    args = []\n    funname = @expr()\n\n    isSF = SF_NAMES.indexOf(funname.name) != -1\n    until @expects(')') or @isEOF()\n      @skip()\n      args.push @expr(isSF)\n\n    @forwards ')'\n\n    klass = if isSF then SpecialForm else CallFun\n    return new klass(funname, args)\n\n  expr: (isSF) ->\n    if @expects(\"'\") or isSF #value\n      @forwards \"'\" unless isSF\n      if @expects '(' #list\n        return @list()\n      else #atom\n        return @atom()\n    else if @expects '(' #calling function or special form\n      return @call_fun()\n    else #atom\n      return @atom()\n\n  program: ->\n    ret = []\n    until @isEOF()\n      @skip()\n      ret.push @expr()\n    return ret\n\n  parse: (@code) ->\n    @pos = 0\n    @program()\n\nclass Evaluator\n  exec_lambda: (lambda, args) ->\n    envstack.push new Environment(lambda.params.values.reduce(\n      ((env, param, index) -> env[param.name] = args[index]; env), {}))\n    [name, args...] = lambda.body.values\n    ret = @eval_expr(new CallFun(name, args))\n    envstack.pop()\n    return ret\n\n  eval_expr: (expr) ->\n    switch expr.constructor.name\n      when 'SpecialForm'\n        args = expr.args\n        {\n          'cond': => args.filter((arg) => !(@eval_expr(arg.values[0]) instanceof Nil))[0]?.values[1] || nil\n          'quote': -> args[0]\n          'lambda': -> new Lambda(args[0], args[1])\n          'defun': -> currentEnv().set(args[0].name, new Lambda(args[1], args[2]))\n        }[expr.name.name]()\n\n      when 'CallFun'\n        args = expr.args.map (arg) => @eval_expr(arg)\n        funname = if expr.funname instanceof SpecialForm then @eval_expr(expr.funname) else expr.funname\n        switch funname.constructor.name\n          when 'Lambda'\n            @exec_lambda(funname)\n          when 'Symbol'\n            funcs = {\n              '+': -> args.reduce(((sum, n) -> sum + n), 0),\n              'car': -> args[0].values[0]\n              'cdr': -> new List args[0].values[1..]\n              'cons': -> new List [args[0], args[1].values...]\n              'eq': -> if args[0] == args[1] then t else nil\n              'atom': -> if isAtom(args[0]) then t else nil\n            }\n            if funs = funcs[funname.name]\n              funs()\n            else\n              if lambda = currentEnv().get(funname.name)\n                @exec_lambda(lambda, args)\n              else\n                throw \"undefined function : #{funname.name}\"\n          else\n            throw \"#{JSON.stringify(funname)}(#{funname.constructor.name}) is not a function\"\n      when 'Symbol'\n        currentEnv().get(expr.name)\n      else\n        expr\n\n  eval: (ast) ->\n    envstack.push new Environment({})\n    ast.map((expr) => @eval_expr(expr)).pop().toString()\n\nclass @Lisp\n  @eval: (code) ->\n    ast = (new Parser).parse(code)\n    {ast: ast, body: (new Evaluator).eval(ast)}\n\n#support script tag\n$ ->\n  $('script[type=\"text/lisp\"]').each ->\n    Lisp.eval $(this).text()\n\n\n\u8aac\u660e\n\u4eca\u56de\u306f\u52c9\u5f37\u76ee\u7684\u3060\u3063\u305f\u306e\u3067\u30d1\u30fc\u30b5\u30fc\u306f\u624b\u66f8\u304d\u3057\u307e\u3057\u305f\u3002\u518d\u5e30\u4e0b\u964d\u30d1\u30fc\u30b5\u30fc\u3067\u3059\u3002Parser\u30af\u30e9\u30b9\u304c\u3053\u306e\u5f79\u5272\u3092\u62c5\u3063\u3066\u3044\u307e\u3059\u3002\u5185\u90e8\u8868\u73fe\u3068\u3057\u3066Symbol, Nil\u7b49\u306e\u30af\u30e9\u30b9\u3092\u4f5c\u308a\u307e\u3057\u305f\u3002\n\u5185\u90e8\u8868\u73fe\u306b\u5909\u63db\u3057\u305f\u3089Evaluator\u30af\u30e9\u30b9\u304c\u8a55\u4fa1\u3057\u307e\u3059\u3002\u518d\u5e30\u3067\u666e\u901a\u306b\u3084\u3063\u3066\u3044\u308b\u3060\u3051\u3067\u3059\u3002\n\n\u77ed\u304f\u3059\u308b\u305f\u3081\u306b\n\u304d\u308a\u306e\u3044\u3044200\u884c\u306b\u3059\u308b\u305f\u3081\u306b\u3084\u3063\u305f\u3053\u3068\n\u3053\u306e\u6642\u70b9\u3067\u3001247\u884c\n\n\u4f55\u5ea6\u3082\u767b\u5834\u3059\u308b\u90e8\u5206\u3092\u95a2\u6570\u3068\u3057\u3066\u62bd\u51fa\u3059\u308b\n\u57fa\u672c\u4e2d\u306e\u57fa\u672c\u3067\u3059\u306d\u3002\nif @expects xxx\n  @forwards xxx\n  #...\n\n\u304c\u7d50\u69cb\u591a\u304b\u3063\u305f\u306e\u3067\u3001forwards_if\u3092\u4f5c\u3063\u3066\u3001\nif @forwards_if xxx\n  #...\n\n\u306b\u66f8\u304d\u63db\u3048\u307e\u3057\u305f\u3002\u3064\u3044\u3067\u306b\u3001\u5f8c\u7f6eif\u306b\u7f6e\u304d\u63db\u3048\u307e\u3057\u305f\u3002\n#nil\nif @expects 'nil'\n  @forwards_str 'nil'\n  return nil\n\n\u3092\nreturn nil if @forwards_if 'nil'\n\n\u306b\u3057\u307e\u3057\u305f\u3002\n\u3053\u306e\u6642\u70b9\u3067\u3001221\u884c\n\nSwitch\u6587 -> function\u3092\u5024\u3068\u3057\u305f\u30aa\u30d6\u30b8\u30a7\u30af\u30c8\nswitch\u6587\u306f\u884c\u6570\u3092\u98df\u3046\u3068\u3044\u3046\u4e8b\u304c\u5206\u304b\u308a\u307e\u3057\u305f\u3002\u5177\u4f53\u7684\u306b\u306f\u3001\nswitch x\n  when 'hoge'\n    console.log 'hoge~'\n  when 'piyo'\n    console.log 'piyo~'\n  when 'foo'\n    console.log 'foo~'\n\n\u3092\n{\n  hoge: -> console.log 'hoge~'\n  piyo: -> console.log 'piyo~'\n  foo -> console.log 'foo~'\n}[x]()\n\n\u306b\u3057\u307e\u3057\u305f\u3002when\u306e\u6570\u3060\u3051\u884c\u6570\u304c\u6e1b\u308a\u307e\u3059\u3002\n\u3042\u3068cons\u306e\u5b9f\u88c5\u3092\nnewList = args[1].values[..]\nnewList.unshift(args[0])\nnew List newList\n\n\u304b\u3089\nnew List [args[0], args[1].values...]\n\n\u306b\u66f8\u304d\u63db\u3048\u307e\u3057\u305f\u3002CoffeeScript\u306f\u3053\u3046\u3044\u3046\u4fbf\u5229\u306a\u69cb\u6587\u304c\u591a\u3044\u3067\u3059\u306d\uff01\n\u3053\u306e\u6642\u70b9\u3067\u3001204\u884c\n\nmap\u3092\u4f7f\u3046\nfor expr in ast\n  ret = @eval_expr(expr)\n  return ret.toString()\n\n\u3092\nast.map((expr) => @eval_expr(expr)).pop().toString()\n\n\u306b\u3057\u305f\u3002\u914d\u5217\u306e\u672b\u5c3e\u3092\u3068\u308b\u30e1\u30bd\u30c3\u30c9\u304c\u898b\u5f53\u305f\u3089\u306a\u304b\u3063\u305f\u306e\u3067pop\u3092\u3064\u304b\u3044\u307e\u3057\u305f\u3002\u3053\u3053\u3067\u3064\u3044\u306b200\u884c\uff01\n\n\u611f\u60f3\n\u51e6\u7406\u7cfb\u3068\u3057\u3066\u306f\u6700\u4f4e\u9650\u3060\u304c\u3001\u601d\u3063\u305f\u3088\u308a\u3042\u3063\u3055\u308a\u3067\u304d\u307e\u3057\u305f\u3002\u7279\u306b\u30d1\u30fc\u30b5\u30fc\u3092\u624b\u66f8\u304d\u3067\u66f8\u3044\u305f\u306e\u306f\u521d\u3081\u3066\u3060\u3063\u305f\u306e\u3067\u3059\u304c\u3001\u7279\u306b\u3064\u307e\u308b\u3053\u3068\u306a\u304f\u3067\u304d\u3066\u3057\u307e\u3044\u307e\u3057\u305f\u3002\u3068\u3044\u3046\u3053\u3068\u3067\u3001\u521d\u3081\u3066\u4f5c\u308b\u51e6\u7406\u7cfb\u3068\u3057\u3066Lisp\u3092\u52e7\u3081\u3066\u307f\u305f\u3044\u3068\u601d\u3044\u307e\u3057\u305f\u3002\n\u30d1\u30fc\u30b5\u30fc\u3092\u5b9f\u88c5\u3057\u3066\u304b\u3089\u307f\u3064\u3051\u305f\u306e\u3067\u3059\u304c\u3001((Python\u3067) \u66f8\u304f (Lisp) \u30a4\u30f3\u30bf\u30d7\u30ea\u30bf)\u306f\u308f\u305a\u304b90\u884c\u3067\u5b9f\u88c5\u3057\u3066\u3044\u307e\u3059\u3002\u30bd\u30fc\u30b9\u3092\u898b\u308b\u3068\u30d1\u30fc\u30b9\u306f\u30b9\u30da\u30fc\u30b9\u3067\u5206\u5272\u3057\u3066\u3044\u308b\u307f\u305f\u3044\u3067\u3059\u3002\u8ce2\u3044\uff01\nLisp\u306e\u52c9\u5f37\u304c\u3066\u3089CoffeeScript\u3067\u4f5c\u3063\u3066\u307f\u307e\u3057\u305f\u3002\n\n\u4ed5\u69d8\u306f http://ja.wikipedia.org/wiki/LISP \u3084 http://ja.wikipedia.org/wiki/\u7d14LISP \u3092\u53c2\u8003\u306b\u30b0\u30b0\u308a\u306a\u304c\u3089\u3084\u3063\u305f\u306e\u3067\u3001\u9055\u3046\u3068\u3053\u308d\u304c\u3042\u308b\u304b\u3082\u3057\u308c\u307e\u305b\u3093\u3002\n\n\u30bd\u30fc\u30b9\u306f https://github.com/long-long-float/lisp-js/tree/limit200 \u3067\u3001 http://long-long-float.github.io/lisp-js/index.html \u3067\u5b9f\u969b\u306b\u52d5\u304b\u3059\u3053\u3068\u304c\u3067\u304d\u307e\u3059\u3002\n\n```coffeescript\nclass Symbol\n  constructor: (@name) ->\n  toString: -> @name\n\nclass Nil\n  toString: -> 'nil'\nnil = new Nil\nclass T\n  toString: -> 't'\nt = new T\n\nclass List\n  constructor: (@values) ->\n  toString: -> \"(#{@values.map((v) -> v.toString()).join(' ')})\"\n\nclass CallFun\n  constructor: (@funname, @args) ->\n  toString: -> \"(#{@funname} #{@values.map((v) -> v.toString()).join(' ')})\"\n\nSF_NAMES = ['cond', 'quote', 'lambda', 'defun']\nclass SpecialForm\n  constructor: (@name, @args) ->\n  toString: -> \"(#{@name} #{@args.map((v) -> v.toString()).join(' ')})\"\n\nclass Lambda\n  constructor: (@params, @body) ->\n\nclass Environment\n  constructor: (@variables) ->\n  get: (name) ->\n    val = @variables[name]\n    throw \"undefined #{name}\" unless val\n    return val\n  set: (name, val) -> @variables[name] = val\n\nisAtom = (val) ->\n  typeof val == 'string' or typeof val == 'number' or\n    val instanceof Nil or val instanceof T\n\nenvstack = []\ncurrentEnv = ->\n  throw \"envstack is empty\" unless envstack.length > 0\n  envstack[envstack.length - 1]\n\nclass @Parser\n  skip: ->\n    @pos++ while @code[@pos]?.match /[ \\r\\n\\t]/\n\n  isEOF: ->\n    @pos == @code.length\n\n  expects: (pattern, throwing = false) ->\n    valid = @code[@pos] && (pattern instanceof RegExp and pattern.test @code[@pos]) || pattern == @code[@pos...@pos + pattern.length]\n    if !valid && throwing\n      throw \"unexpected \\\"#{@code[@pos]}\\\", expects \\\"#{pattern}\\\"\"\n\n    return valid\n\n  forwards: (pattern) ->\n    @expects pattern, true\n    @code[@pos]\n    @pos += if pattern instanceof RegExp then 1 else pattern.length\n\n  forwards_if: (pattern) ->\n    @forwards pattern if @expects pattern\n\n  atom: ->\n    #number\n    if @expects /[0-9]/\n      num = ''\n      num += @code[@pos++] while @expects /[0-9]/\n      return parseInt(num)\n\n    #string\n    if @forwards_if '\"'\n      str = ''\n      str += @code[@pos++] until @expects '\"'\n      @forwards '\"'\n      return str\n\n    return nil if @forwards_if 'nil'\n    return t if @forwards_if 't'\n\n    #var\n    return new Symbol(@symbol())\n\n  symbol: ->\n    ret = ''\n    ret += @code[@pos++] while @expects /[\\w!#$%&=-~^|*+<>?_]/\n    return ret\n\n  list: ->\n    @forwards '('\n    values = []\n    until @expects(')') or @isEOF()\n      values.push @expr()\n      @skip()\n    @forwards ')'\n    return new List(values)\n\n  call_fun: ->\n    @forwards '('\n    args = []\n    funname = @expr()\n\n    isSF = SF_NAMES.indexOf(funname.name) != -1\n    until @expects(')') or @isEOF()\n      @skip()\n      args.push @expr(isSF)\n\n    @forwards ')'\n\n    klass = if isSF then SpecialForm else CallFun\n    return new klass(funname, args)\n\n  expr: (isSF) ->\n    if @expects(\"'\") or isSF #value\n      @forwards \"'\" unless isSF\n      if @expects '(' #list\n        return @list()\n      else #atom\n        return @atom()\n    else if @expects '(' #calling function or special form\n      return @call_fun()\n    else #atom\n      return @atom()\n\n  program: ->\n    ret = []\n    until @isEOF()\n      @skip()\n      ret.push @expr()\n    return ret\n\n  parse: (@code) ->\n    @pos = 0\n    @program()\n\nclass Evaluator\n  exec_lambda: (lambda, args) ->\n    envstack.push new Environment(lambda.params.values.reduce(\n      ((env, param, index) -> env[param.name] = args[index]; env), {}))\n    [name, args...] = lambda.body.values\n    ret = @eval_expr(new CallFun(name, args))\n    envstack.pop()\n    return ret\n\n  eval_expr: (expr) ->\n    switch expr.constructor.name\n      when 'SpecialForm'\n        args = expr.args\n        {\n          'cond': => args.filter((arg) => !(@eval_expr(arg.values[0]) instanceof Nil))[0]?.values[1] || nil\n          'quote': -> args[0]\n          'lambda': -> new Lambda(args[0], args[1])\n          'defun': -> currentEnv().set(args[0].name, new Lambda(args[1], args[2]))\n        }[expr.name.name]()\n\n      when 'CallFun'\n        args = expr.args.map (arg) => @eval_expr(arg)\n        funname = if expr.funname instanceof SpecialForm then @eval_expr(expr.funname) else expr.funname\n        switch funname.constructor.name\n          when 'Lambda'\n            @exec_lambda(funname)\n          when 'Symbol'\n            funcs = {\n              '+': -> args.reduce(((sum, n) -> sum + n), 0),\n              'car': -> args[0].values[0]\n              'cdr': -> new List args[0].values[1..]\n              'cons': -> new List [args[0], args[1].values...]\n              'eq': -> if args[0] == args[1] then t else nil\n              'atom': -> if isAtom(args[0]) then t else nil\n            }\n            if funs = funcs[funname.name]\n              funs()\n            else\n              if lambda = currentEnv().get(funname.name)\n                @exec_lambda(lambda, args)\n              else\n                throw \"undefined function : #{funname.name}\"\n          else\n            throw \"#{JSON.stringify(funname)}(#{funname.constructor.name}) is not a function\"\n      when 'Symbol'\n        currentEnv().get(expr.name)\n      else\n        expr\n\n  eval: (ast) ->\n    envstack.push new Environment({})\n    ast.map((expr) => @eval_expr(expr)).pop().toString()\n\nclass @Lisp\n  @eval: (code) ->\n    ast = (new Parser).parse(code)\n    {ast: ast, body: (new Evaluator).eval(ast)}\n\n#support script tag\n$ ->\n  $('script[type=\"text/lisp\"]').each ->\n    Lisp.eval $(this).text()\n```\n\n## \u8aac\u660e\n\n\u4eca\u56de\u306f\u52c9\u5f37\u76ee\u7684\u3060\u3063\u305f\u306e\u3067\u30d1\u30fc\u30b5\u30fc\u306f\u624b\u66f8\u304d\u3057\u307e\u3057\u305f\u3002\u518d\u5e30\u4e0b\u964d\u30d1\u30fc\u30b5\u30fc\u3067\u3059\u3002Parser\u30af\u30e9\u30b9\u304c\u3053\u306e\u5f79\u5272\u3092\u62c5\u3063\u3066\u3044\u307e\u3059\u3002\u5185\u90e8\u8868\u73fe\u3068\u3057\u3066Symbol, Nil\u7b49\u306e\u30af\u30e9\u30b9\u3092\u4f5c\u308a\u307e\u3057\u305f\u3002\n\n\u5185\u90e8\u8868\u73fe\u306b\u5909\u63db\u3057\u305f\u3089Evaluator\u30af\u30e9\u30b9\u304c\u8a55\u4fa1\u3057\u307e\u3059\u3002\u518d\u5e30\u3067\u666e\u901a\u306b\u3084\u3063\u3066\u3044\u308b\u3060\u3051\u3067\u3059\u3002\n\n## \u77ed\u304f\u3059\u308b\u305f\u3081\u306b\n\n\u304d\u308a\u306e\u3044\u3044200\u884c\u306b\u3059\u308b\u305f\u3081\u306b\u3084\u3063\u305f\u3053\u3068\n\n\u3053\u306e\u6642\u70b9\u3067\u3001247\u884c\n\n### \u4f55\u5ea6\u3082\u767b\u5834\u3059\u308b\u90e8\u5206\u3092\u95a2\u6570\u3068\u3057\u3066\u62bd\u51fa\u3059\u308b\n\n\u57fa\u672c\u4e2d\u306e\u57fa\u672c\u3067\u3059\u306d\u3002\n\n```coffeescript\nif @expects xxx\n  @forwards xxx\n  #...\n```\n\n\u304c\u7d50\u69cb\u591a\u304b\u3063\u305f\u306e\u3067\u3001`forwards_if`\u3092\u4f5c\u3063\u3066\u3001\n\n```coffeescript\nif @forwards_if xxx\n  #...\n```\n\n\u306b\u66f8\u304d\u63db\u3048\u307e\u3057\u305f\u3002\u3064\u3044\u3067\u306b\u3001\u5f8c\u7f6eif\u306b\u7f6e\u304d\u63db\u3048\u307e\u3057\u305f\u3002\n\n```coffeescript\n#nil\nif @expects 'nil'\n  @forwards_str 'nil'\n  return nil\n```\n\n\u3092\n\n```coffeescript\nreturn nil if @forwards_if 'nil'\n```\n\n\u306b\u3057\u307e\u3057\u305f\u3002\n\n\u3053\u306e\u6642\u70b9\u3067\u3001221\u884c\n\n### Switch\u6587 -> function\u3092\u5024\u3068\u3057\u305f\u30aa\u30d6\u30b8\u30a7\u30af\u30c8\n\nswitch\u6587\u306f\u884c\u6570\u3092\u98df\u3046\u3068\u3044\u3046\u4e8b\u304c\u5206\u304b\u308a\u307e\u3057\u305f\u3002\u5177\u4f53\u7684\u306b\u306f\u3001\n\n```coffeescript\nswitch x\n  when 'hoge'\n    console.log 'hoge~'\n  when 'piyo'\n    console.log 'piyo~'\n  when 'foo'\n    console.log 'foo~'\n```\n\n\u3092\n\n```coffeescript\n{\n  hoge: -> console.log 'hoge~'\n  piyo: -> console.log 'piyo~'\n  foo -> console.log 'foo~'\n}[x]()\n```\n\n\u306b\u3057\u307e\u3057\u305f\u3002when\u306e\u6570\u3060\u3051\u884c\u6570\u304c\u6e1b\u308a\u307e\u3059\u3002\n\n\u3042\u3068cons\u306e\u5b9f\u88c5\u3092\n\n```coffeescript\nnewList = args[1].values[..]\nnewList.unshift(args[0])\nnew List newList\n```\n\n\u304b\u3089\n\n```coffeescript\nnew List [args[0], args[1].values...]\n```\n\n\u306b\u66f8\u304d\u63db\u3048\u307e\u3057\u305f\u3002CoffeeScript\u306f\u3053\u3046\u3044\u3046\u4fbf\u5229\u306a\u69cb\u6587\u304c\u591a\u3044\u3067\u3059\u306d\uff01\n\n\u3053\u306e\u6642\u70b9\u3067\u3001204\u884c\n\n### map\u3092\u4f7f\u3046\n\n```coffeescript\nfor expr in ast\n  ret = @eval_expr(expr)\n  return ret.toString()\n```\n\n\u3092\n\n```coffeescript\nast.map((expr) => @eval_expr(expr)).pop().toString()\n```\n\n\u306b\u3057\u305f\u3002\u914d\u5217\u306e\u672b\u5c3e\u3092\u3068\u308b\u30e1\u30bd\u30c3\u30c9\u304c\u898b\u5f53\u305f\u3089\u306a\u304b\u3063\u305f\u306e\u3067pop\u3092\u3064\u304b\u3044\u307e\u3057\u305f\u3002\u3053\u3053\u3067\u3064\u3044\u306b200\u884c\uff01\n\n## \u611f\u60f3\n\n\u51e6\u7406\u7cfb\u3068\u3057\u3066\u306f\u6700\u4f4e\u9650\u3060\u304c\u3001\u601d\u3063\u305f\u3088\u308a\u3042\u3063\u3055\u308a\u3067\u304d\u307e\u3057\u305f\u3002\u7279\u306b\u30d1\u30fc\u30b5\u30fc\u3092\u624b\u66f8\u304d\u3067\u66f8\u3044\u305f\u306e\u306f\u521d\u3081\u3066\u3060\u3063\u305f\u306e\u3067\u3059\u304c\u3001\u7279\u306b\u3064\u307e\u308b\u3053\u3068\u306a\u304f\u3067\u304d\u3066\u3057\u307e\u3044\u307e\u3057\u305f\u3002\u3068\u3044\u3046\u3053\u3068\u3067\u3001\u521d\u3081\u3066\u4f5c\u308b\u51e6\u7406\u7cfb\u3068\u3057\u3066Lisp\u3092\u52e7\u3081\u3066\u307f\u305f\u3044\u3068\u601d\u3044\u307e\u3057\u305f\u3002\n\n\u30d1\u30fc\u30b5\u30fc\u3092\u5b9f\u88c5\u3057\u3066\u304b\u3089\u307f\u3064\u3051\u305f\u306e\u3067\u3059\u304c\u3001[((Python\u3067) \u66f8\u304f (Lisp) \u30a4\u30f3\u30bf\u30d7\u30ea\u30bf)](http://www.aoky.net/articles/peter_norvig/lispy.htm)\u306f\u308f\u305a\u304b90\u884c\u3067\u5b9f\u88c5\u3057\u3066\u3044\u307e\u3059\u3002\u30bd\u30fc\u30b9\u3092\u898b\u308b\u3068\u30d1\u30fc\u30b9\u306f\u30b9\u30da\u30fc\u30b9\u3067\u5206\u5272\u3057\u3066\u3044\u308b\u307f\u305f\u3044\u3067\u3059\u3002\u8ce2\u3044\uff01", "tags": ["lisp", "CoffeeScript1.7.1"]}