{"context": " More than 1 year has passed since last update.\n\n\u6982\u8981\n\u6a5f\u68b0\u5b66\u7fd2\u3001\u753b\u50cf\u51e6\u7406\u3001\u30b3\u30f3\u30d4\u30e5\u30fc\u30bf\u30fc\u30a2\u30cb\u30e1\u30fc\u30b7\u30e7\u30f3\u7b49\u3001\u3044\u308d\u3044\u308d\u306a\u5834\u9762\u3067\u4f7f\u7528\u3055\u308c\u308b\u884c\u5217\u8a08\u7b97\u3002\u305d\u306e\u884c\u5217\u8a08\u7b97\u3092\u3042\u3048\u3066Scala(\u4e00\u90e8\u3001Java\u3067\u3059)\u3067\u3084\u308a\u305f\u3068\u3044\u3046\u3068\u3044\u3046\u306e\u304c\u4eca\u56de\u306e\u8da3\u65e8\u3067\u3059\u3002\u4eca\u56de\u306f\u3001\u6570\u3042\u308b\u884c\u5217\u8a08\u7b97\u306e\u30aa\u30fc\u30d7\u30f3\u30bd\u30fc\u30b9\u306e\u4e2d\u304b\u3089LAPACK\u3092\u4f7f\u3063\u3066\u307f\u307e\u3057\u305f\u3002\n\nLAPACK\nhttp://www.netlib.org/lapack/\n\u3061\u306a\u307f\u306b\u3001LAPACK\u306f\u3001\u5927\u898f\u6a21\u306a\u758e\u884c\u5217\u306e\u8a08\u7b97\u306b\u306f\u5411\u3044\u3066\u307e\u305b\u3093\uff08\uff0a\u79c1\u500b\u4eba\u7684\u306b\u601d\u3063\u305f\u3060\u3051\u306a\u306e\u3067\u3001\u3082\u3057\u9593\u9055\u3048\u3066\u305f\u3089\u3001\u3054\u6307\u6458\u304a\u9858\u3044\u3057\u307e\u3059\u3002\uff09\n\nLAPACK\u306e\u4f9d\u5b58\u95a2\u4fc2\nSBT\u3092\u4f7f\u3063\u3066\u3044\u308c\u3070\u3001\u4ee5\u4e0b\u3092build.sbt\u306b\u8ffd\u52a0\u3059\u308b\u3060\u3051\u3067\u3001\u4f7f\u7528\u3067\u304d\u307e\u3059(*\u6ce8\u610f: \u9069\u5b9c\u9069\u5207\u306a\u30d0\u30fc\u30b8\u30e7\u30f3\u3092\u3057\u3066\u3057\u3066\u304f\u3060\u3055\u3044)\n\"com.googlecode.netlib-java\" % \"netlib-java\" % \"1.0\" \n\n\u6d3b\u7528\u4f8b\n\u4eca\u56de\u306f\u3001\u753b\u50cf\u51e6\u7406\u3067\u57fa\u672c\u306e\u5c04\u5f71\u5909\u63db\u3092LAPACK\u3092\u4f7f\u3063\u3066\u3001\u6c42\u3081\u3066\u307f\u305f\u3044\u3068\u601d\u3044\u307e\u3059\u3002\nhttps://github.com/mmaioe/cameracalibration\n\u4ee5\u4e0a\u306eGit\u306b\u30b5\u30f3\u30d7\u30eb\u30d7\u30ed\u30b0\u30e9\u30e0\u3092\u4e57\u305b\u307e\u3057\u305f\u3002IntelliJ\u3092\u4f7f\u7528\u3057\u3066\u3044\u308b\u65b9\u306f\u3001clone\u3057\u3066\u3001Sbt\u30d7\u30ed\u30b8\u30a7\u30af\u30c8\u3068\u3057\u3066\u3001Import\u3059\u308c\u3070\u4f7f\u3048\u307e\u3059\u3002\n\n\u30db\u30e2\u30b0\u30e9\u30d5\u30a3\u884c\u5217\n\u30db\u30e2\u30b0\u30e9\u30d5\u30a3\u884c\u5217\u306b\u95a2\u3059\u308b\u8a18\u4e8b\u306f\u3001\u30cd\u30c3\u30c8\u4e0a\u306b\u591a\u6570\u5b58\u5728\u3057\u3001\u591a\u304f\u306e\u5fdc\u7528\u4f8b\u304c\u3042\u308a\u307e\u3059\u3002\u4ee5\u4e0b\u306e\u30d6\u30ed\u30b0\u306a\u3069\u3067\u3082\u3001\u305d\u306e\u5fdc\u7528\u4f8b\u304c\u307f\u308c\u307e\u3059\u3002\nhttp://blog.livedoor.jp/ryo_ogawa/archives/3109950.html\nhttp://www.cuspy.org/diary/2012-06-29\n\n4\u70b9\u304b\u3089\u30db\u30e2\u30b0\u30e9\u30d5\u30a3\u884c\u5217\u8a08\u7b97\n\u30db\u30e2\u30b0\u30e9\u30d5\u30a3\u884c\u5217\u306e\u8a08\u7b97\u306f\u3001\uff14\u3064\u306e\u70b9\u304c\u3042\u308c\u3070\u8a08\u7b97\u3067\u304d\u307e\u3059\u3002\u3053\u306e\u3053\u3068\u306f\u3001\u591a\u304f\u306e\u30cd\u30c3\u30c8\u4e0a\u306e\u6587\u732e\u3067\u3082\u307f\u308c\u308b\u306e\u3067\u3001\u662f\u975e\u691c\u7d22\u3057\u3066\u307f\u3066\u304f\u3060\u3055\u3044\u3002\nhttp://shogo82148.github.io/homepage/memo/geometry/homography/\n\nHomography.scala\npackage mmaioe.com.cameracalibration\n\nimport mmaioe.com.linearsystem.LinearSolver\n\n/**\n * Created by maoito on 12/19/15.\n */\nobject Homography {\n  /**\n   *\n   * p1_* belongs to the samge image\n   * p2_* belongs to the same image\n   *\n   * p1_i and p2_i should be a pair of corresponding points\n   * @param p1_1\n   * @param p1_2\n   * @param p1_3\n   * @param p1_4\n   * @param p2_1\n   * @param p2_2\n   * @param p2_3\n   * @param p2_4\n   */\n  def solve(\n             p1_1: {val x:Double; val y:Double; },\n             p1_2: {val x:Double; val y:Double; },\n             p1_3: {val x:Double; val y:Double; },\n             p1_4: {val x:Double; val y:Double; },\n             p2_1: {val x:Double; val y:Double; },\n             p2_2: {val x:Double; val y:Double; },\n             p2_3: {val x:Double; val y:Double; },\n             p2_4: {val x:Double; val y:Double; }\n             ):List[List[Double]]={\n    val homography = LinearSolver.solveWithSquareMatrix(\n      Array(\n        Array(p1_1.x, p1_1.y, 1, 0,      0,      0, -p1_1.x*p2_1.x, -p1_1.y*p2_1.x),\n        Array(0,      0,      0, p1_1.x, p1_1.y, 1, -p1_1.x*p2_1.y, -p1_1.y*p2_1.y),\n        Array(p1_2.x, p1_2.y, 1, 0,      0,      0, -p1_2.x*p2_2.x, -p1_2.y*p2_2.x),\n        Array(0,      0,      0, p1_2.x, p1_2.y, 1, -p1_2.x*p2_2.y, -p1_2.y*p2_2.y),\n        Array(p1_3.x, p1_3.y, 1, 0,      0,      0, -p1_3.x*p2_3.x, -p1_3.y*p2_3.x),\n        Array(0,      0,      0, p1_3.x, p1_3.y, 1, -p1_3.x*p2_3.y, -p1_3.y*p2_3.y),\n        Array(p1_4.x, p1_4.y, 1, 0,      0,      0, -p1_4.x*p2_4.x, -p1_4.y*p2_4.x),\n        Array(0,      0,      0, p1_4.x, p1_4.y, 1, -p1_4.x*p2_4.y, -p1_4.y*p2_4.y)\n      )\n      ,\n      Array(p2_1.x,p2_1.y,p2_2.x,p2_2.y,p2_3.x,p2_3.y,p2_4.x,p2_4.y)\n    )\n\n    return List[List[Double]](\n      List(homography(0),homography(1),homography(2)),\n      List(homography(3),homography(4),homography(5)),\n      List(homography(6),homography(7),1)\n    )\n  }\n\n  def multiply(homography:List[List[Double]], point: List[Double]): List[Int] ={\n    var threePoint:collection.mutable.ListBuffer[Double] = collection.mutable.ListBuffer[Double]()++point\n    threePoint += 1\n\n    val new_point:collection.mutable.ListBuffer[Int] = collection.mutable.ListBuffer[Int]()\n    (0 until 2).foreach{\n      i =>\n        var sum = 0.0\n        (0 until 3).foreach{\n          j =>\n            sum += homography(i)(j) * threePoint(j);\n        }\n        if(sum - sum.toInt > 0.5) sum = sum.toInt+1\n        else                      sum = sum.toInt\n\n        new_point += sum.toInt\n    }\n\n    return new_point.toList\n  }\n}\n\n\n\n\nImage.java\npackage mmaioe.com.image;\n\nimport javax.imageio.ImageIO;\nimport java.awt.*;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\n\n/**\n * Created by maoito on 12/19/15.\n */\npublic class Image {\n    public BufferedImage image;\n    public String fileName;\n\n\n    public Image(String fileName){\n        InputStream is = null;\n        this.fileName = fileName;\n        try {\n            is = new FileInputStream(fileName);\n            image = ImageIO.read(is);\n        } catch (IOException e) {\n            throw new RuntimeException(\"failed to read \"+fileName);\n        } finally {\n            if (is != null) try { is.close(); } catch (IOException e) {\n                throw  new RuntimeException(\"failed to close FileInputStream\");\n            }\n        }\n    }\n    public Image(int width, int height){\n        this.image = new BufferedImage(width,height,BufferedImage.TYPE_INT_RGB);\n    }\n\n    public Color getRGBColor(int x,int y){\n        return new Color(image.getRGB(x, y));\n    }\n\n    public void setColor(int x,int y, Color c){\n        image.setRGB(x, y, c.getRGB());\n    }\n\n    public int width(){\n        return image.getWidth();\n    }\n    public int height(){\n        return image.getHeight();\n    }\n\n    public void writeImage(String fileName){\n        try{\n            ImageIO.write(image, \"jpg\", new File(fileName));\n        }catch(Exception e){\n            throw new RuntimeException(\"failed to write image to \"+fileName);\n        }\n    }\n}\n\n\n\nLinearSolver.java\npackage mmaioe.com.linearsystem;\n\nimport org.netlib.lapack.Dgesv;\nimport org.netlib.util.intW;\n\n/**\n * Created by maoito on 12/19/15.\n */\npublic class LinearSolver {\n    /**\n     *\n     * @param _A\n     * @param _B\n     * @return\n     */\n    public static double[] solveWithSquareMatrix(double[][] _A, double[] _B) {\n        int N = _A.length;\n        int NRHS = 1;\n        int LDA = _A.length;\n        int LDB = _B.length;\n\n        double[] A = new double[_A.length*_A.length];\n        double[] B = _B;\n\n        intW info = new intW(0);\n\n        int[] IPIV = new int[_A.length];\n        for(int i=0;i<IPIV.length;i++) IPIV[i] = 0;\n\n        for(int i=0;i<_A.length;i++){\n            for(int j=0;j<_A[i].length;j++){\n                A[i+j*_A.length] = _A[i][j];\n            }\n        }\n\n        //Solve Ah = B\n        Dgesv.dgesv(N, NRHS, A, 0, LDA, IPIV, 0, B, 0, LDB, info);\n\n        return B;\n    }\n\n}\n\n\n\n\u9069\u7528\u4f8b\n\u5909\u63db\u3057\u305f\u753b\u50cf\u3092\u898b\u305b\u3089\u308c\u306a\u3044\u306e\u306f\u6b8b\u5ff5\u3067\u3059\u304c\u3001\u4ee5\u4e0b\u306b\u4f7f\u7528\u4f8b\u306e\u30d7\u30ed\u30b0\u30e9\u30e0\u3092\u8cbc\u308a\u307e\u3059\u3002\u4eca\u56de\u306e\u30d7\u30ed\u30b0\u30e9\u30e0\u3067\u306f\u3001\u5358\u7d14\u306b\u5c04\u5f71\u5909\u63db\u3057\u305f\u306e\u307f\u3067\u3001\u88dc\u9593\u306a\u3069\u306f\u304a\u3053\u306a\u3063\u3066\u3044\u307e\u305b\u3093\u3002\n\nTest.scala\n\nimport mmaioe.com.cameracalibration.Homography\nimport mmaioe.com.image.Image\n\n/**\n * Created by maoito on 12/19/15.\n */\nobject Test {\n  def main(args: Array[String]) {\n    val image = new Image(\"/Users/XXXX/DSC01018.JPG\")\n\n    println(image.height()+\",\"+image.width())\n\n\n    val homography = Homography.solve(\n      new {val x:Double = 0; val y:Double=0; },\n      new {val x:Double = 0; val y:Double=5; },\n      new {val x:Double = 5; val y:Double=0; },\n      new {val x:Double = 5; val y:Double=5; },\n      new {val x:Double = 0; val y:Double=0; },\n      new {val x:Double = 2; val y:Double=6; },\n      new {val x:Double = 4; val y:Double= -1; },\n      new {val x:Double = 6; val y:Double=4; }\n    )\n\n    val newImage = new Image(image.width()*2,image.height()*2)\n\n    val base_x=900\n    val base_y=900\n    (0 until image.width()).foreach{\n      x =>\n        (0 until image.height()).foreach{\n          y =>\n            val new_point = Homography.multiply(homography,List(x,y))\n\n            if(0 <= new_point(0)+base_x && new_point(0)+base_x < newImage.width() && 0 <= new_point(1)+base_y && new_point(1)+base_y < newImage.height()){\n              newImage.setColor(new_point(0)+base_x,new_point(1)+base_y,image.getRGBColor(x,y))\n            }\n        }\n    }\n\n    newImage.writeImage(\"homographied.png\")\n  }\n}\n\n\n# \u6982\u8981\n\u6a5f\u68b0\u5b66\u7fd2\u3001\u753b\u50cf\u51e6\u7406\u3001\u30b3\u30f3\u30d4\u30e5\u30fc\u30bf\u30fc\u30a2\u30cb\u30e1\u30fc\u30b7\u30e7\u30f3\u7b49\u3001\u3044\u308d\u3044\u308d\u306a\u5834\u9762\u3067\u4f7f\u7528\u3055\u308c\u308b\u884c\u5217\u8a08\u7b97\u3002\u305d\u306e\u884c\u5217\u8a08\u7b97\u3092\u3042\u3048\u3066Scala(\u4e00\u90e8\u3001Java\u3067\u3059)\u3067\u3084\u308a\u305f\u3068\u3044\u3046\u3068\u3044\u3046\u306e\u304c\u4eca\u56de\u306e\u8da3\u65e8\u3067\u3059\u3002\u4eca\u56de\u306f\u3001\u6570\u3042\u308b\u884c\u5217\u8a08\u7b97\u306e\u30aa\u30fc\u30d7\u30f3\u30bd\u30fc\u30b9\u306e\u4e2d\u304b\u3089LAPACK\u3092\u4f7f\u3063\u3066\u307f\u307e\u3057\u305f\u3002\n\n# LAPACK\nhttp://www.netlib.org/lapack/\n\n\u3061\u306a\u307f\u306b\u3001LAPACK\u306f\u3001\u5927\u898f\u6a21\u306a\u758e\u884c\u5217\u306e\u8a08\u7b97\u306b\u306f\u5411\u3044\u3066\u307e\u305b\u3093\uff08\uff0a\u79c1\u500b\u4eba\u7684\u306b\u601d\u3063\u305f\u3060\u3051\u306a\u306e\u3067\u3001\u3082\u3057\u9593\u9055\u3048\u3066\u305f\u3089\u3001\u3054\u6307\u6458\u304a\u9858\u3044\u3057\u307e\u3059\u3002\uff09\n\n# LAPACK\u306e\u4f9d\u5b58\u95a2\u4fc2\nSBT\u3092\u4f7f\u3063\u3066\u3044\u308c\u3070\u3001\u4ee5\u4e0b\u3092build.sbt\u306b\u8ffd\u52a0\u3059\u308b\u3060\u3051\u3067\u3001\u4f7f\u7528\u3067\u304d\u307e\u3059(*\u6ce8\u610f: \u9069\u5b9c\u9069\u5207\u306a\u30d0\u30fc\u30b8\u30e7\u30f3\u3092\u3057\u3066\u3057\u3066\u304f\u3060\u3055\u3044)\n\n\"com.googlecode.netlib-java\" % \"netlib-java\" % \"1.0\" \n\n# \u6d3b\u7528\u4f8b\n\u4eca\u56de\u306f\u3001\u753b\u50cf\u51e6\u7406\u3067\u57fa\u672c\u306e\u5c04\u5f71\u5909\u63db\u3092LAPACK\u3092\u4f7f\u3063\u3066\u3001\u6c42\u3081\u3066\u307f\u305f\u3044\u3068\u601d\u3044\u307e\u3059\u3002\n\nhttps://github.com/mmaioe/cameracalibration\n\n\u4ee5\u4e0a\u306eGit\u306b\u30b5\u30f3\u30d7\u30eb\u30d7\u30ed\u30b0\u30e9\u30e0\u3092\u4e57\u305b\u307e\u3057\u305f\u3002IntelliJ\u3092\u4f7f\u7528\u3057\u3066\u3044\u308b\u65b9\u306f\u3001clone\u3057\u3066\u3001Sbt\u30d7\u30ed\u30b8\u30a7\u30af\u30c8\u3068\u3057\u3066\u3001Import\u3059\u308c\u3070\u4f7f\u3048\u307e\u3059\u3002\n\n## \u30db\u30e2\u30b0\u30e9\u30d5\u30a3\u884c\u5217\n\u30db\u30e2\u30b0\u30e9\u30d5\u30a3\u884c\u5217\u306b\u95a2\u3059\u308b\u8a18\u4e8b\u306f\u3001\u30cd\u30c3\u30c8\u4e0a\u306b\u591a\u6570\u5b58\u5728\u3057\u3001\u591a\u304f\u306e\u5fdc\u7528\u4f8b\u304c\u3042\u308a\u307e\u3059\u3002\u4ee5\u4e0b\u306e\u30d6\u30ed\u30b0\u306a\u3069\u3067\u3082\u3001\u305d\u306e\u5fdc\u7528\u4f8b\u304c\u307f\u308c\u307e\u3059\u3002\n\nhttp://blog.livedoor.jp/ryo_ogawa/archives/3109950.html\nhttp://www.cuspy.org/diary/2012-06-29\n\n## 4\u70b9\u304b\u3089\u30db\u30e2\u30b0\u30e9\u30d5\u30a3\u884c\u5217\u8a08\u7b97\n\u30db\u30e2\u30b0\u30e9\u30d5\u30a3\u884c\u5217\u306e\u8a08\u7b97\u306f\u3001\uff14\u3064\u306e\u70b9\u304c\u3042\u308c\u3070\u8a08\u7b97\u3067\u304d\u307e\u3059\u3002\u3053\u306e\u3053\u3068\u306f\u3001\u591a\u304f\u306e\u30cd\u30c3\u30c8\u4e0a\u306e\u6587\u732e\u3067\u3082\u307f\u308c\u308b\u306e\u3067\u3001\u662f\u975e\u691c\u7d22\u3057\u3066\u307f\u3066\u304f\u3060\u3055\u3044\u3002\n\nhttp://shogo82148.github.io/homepage/memo/geometry/homography/\n\n```scala:Homography.scala\npackage mmaioe.com.cameracalibration\n\nimport mmaioe.com.linearsystem.LinearSolver\n\n/**\n * Created by maoito on 12/19/15.\n */\nobject Homography {\n  /**\n   *\n   * p1_* belongs to the samge image\n   * p2_* belongs to the same image\n   *\n   * p1_i and p2_i should be a pair of corresponding points\n   * @param p1_1\n   * @param p1_2\n   * @param p1_3\n   * @param p1_4\n   * @param p2_1\n   * @param p2_2\n   * @param p2_3\n   * @param p2_4\n   */\n  def solve(\n             p1_1: {val x:Double; val y:Double; },\n             p1_2: {val x:Double; val y:Double; },\n             p1_3: {val x:Double; val y:Double; },\n             p1_4: {val x:Double; val y:Double; },\n             p2_1: {val x:Double; val y:Double; },\n             p2_2: {val x:Double; val y:Double; },\n             p2_3: {val x:Double; val y:Double; },\n             p2_4: {val x:Double; val y:Double; }\n             ):List[List[Double]]={\n    val homography = LinearSolver.solveWithSquareMatrix(\n      Array(\n        Array(p1_1.x, p1_1.y, 1, 0,      0,      0, -p1_1.x*p2_1.x, -p1_1.y*p2_1.x),\n        Array(0,      0,      0, p1_1.x, p1_1.y, 1, -p1_1.x*p2_1.y, -p1_1.y*p2_1.y),\n        Array(p1_2.x, p1_2.y, 1, 0,      0,      0, -p1_2.x*p2_2.x, -p1_2.y*p2_2.x),\n        Array(0,      0,      0, p1_2.x, p1_2.y, 1, -p1_2.x*p2_2.y, -p1_2.y*p2_2.y),\n        Array(p1_3.x, p1_3.y, 1, 0,      0,      0, -p1_3.x*p2_3.x, -p1_3.y*p2_3.x),\n        Array(0,      0,      0, p1_3.x, p1_3.y, 1, -p1_3.x*p2_3.y, -p1_3.y*p2_3.y),\n        Array(p1_4.x, p1_4.y, 1, 0,      0,      0, -p1_4.x*p2_4.x, -p1_4.y*p2_4.x),\n        Array(0,      0,      0, p1_4.x, p1_4.y, 1, -p1_4.x*p2_4.y, -p1_4.y*p2_4.y)\n      )\n      ,\n      Array(p2_1.x,p2_1.y,p2_2.x,p2_2.y,p2_3.x,p2_3.y,p2_4.x,p2_4.y)\n    )\n\n    return List[List[Double]](\n      List(homography(0),homography(1),homography(2)),\n      List(homography(3),homography(4),homography(5)),\n      List(homography(6),homography(7),1)\n    )\n  }\n\n  def multiply(homography:List[List[Double]], point: List[Double]): List[Int] ={\n    var threePoint:collection.mutable.ListBuffer[Double] = collection.mutable.ListBuffer[Double]()++point\n    threePoint += 1\n\n    val new_point:collection.mutable.ListBuffer[Int] = collection.mutable.ListBuffer[Int]()\n    (0 until 2).foreach{\n      i =>\n        var sum = 0.0\n        (0 until 3).foreach{\n          j =>\n            sum += homography(i)(j) * threePoint(j);\n        }\n        if(sum - sum.toInt > 0.5) sum = sum.toInt+1\n        else                      sum = sum.toInt\n\n        new_point += sum.toInt\n    }\n\n    return new_point.toList\n  }\n}\n\n```\n\n\n```java:Image.java\npackage mmaioe.com.image;\n\nimport javax.imageio.ImageIO;\nimport java.awt.*;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\n\n/**\n * Created by maoito on 12/19/15.\n */\npublic class Image {\n    public BufferedImage image;\n    public String fileName;\n\n\n    public Image(String fileName){\n        InputStream is = null;\n        this.fileName = fileName;\n        try {\n            is = new FileInputStream(fileName);\n            image = ImageIO.read(is);\n        } catch (IOException e) {\n            throw new RuntimeException(\"failed to read \"+fileName);\n        } finally {\n            if (is != null) try { is.close(); } catch (IOException e) {\n                throw  new RuntimeException(\"failed to close FileInputStream\");\n            }\n        }\n    }\n    public Image(int width, int height){\n        this.image = new BufferedImage(width,height,BufferedImage.TYPE_INT_RGB);\n    }\n\n    public Color getRGBColor(int x,int y){\n        return new Color(image.getRGB(x, y));\n    }\n\n    public void setColor(int x,int y, Color c){\n        image.setRGB(x, y, c.getRGB());\n    }\n\n    public int width(){\n        return image.getWidth();\n    }\n    public int height(){\n        return image.getHeight();\n    }\n\n    public void writeImage(String fileName){\n        try{\n            ImageIO.write(image, \"jpg\", new File(fileName));\n        }catch(Exception e){\n            throw new RuntimeException(\"failed to write image to \"+fileName);\n        }\n    }\n}\n```\n\n\n```java:LinearSolver.java\npackage mmaioe.com.linearsystem;\n\nimport org.netlib.lapack.Dgesv;\nimport org.netlib.util.intW;\n\n/**\n * Created by maoito on 12/19/15.\n */\npublic class LinearSolver {\n    /**\n     *\n     * @param _A\n     * @param _B\n     * @return\n     */\n    public static double[] solveWithSquareMatrix(double[][] _A, double[] _B) {\n        int N = _A.length;\n        int NRHS = 1;\n        int LDA = _A.length;\n        int LDB = _B.length;\n\n        double[] A = new double[_A.length*_A.length];\n        double[] B = _B;\n\n        intW info = new intW(0);\n\n        int[] IPIV = new int[_A.length];\n        for(int i=0;i<IPIV.length;i++) IPIV[i] = 0;\n\n        for(int i=0;i<_A.length;i++){\n            for(int j=0;j<_A[i].length;j++){\n                A[i+j*_A.length] = _A[i][j];\n            }\n        }\n\n        //Solve Ah = B\n        Dgesv.dgesv(N, NRHS, A, 0, LDA, IPIV, 0, B, 0, LDB, info);\n\n        return B;\n    }\n\n}\n```\n\n## \u9069\u7528\u4f8b\n\u5909\u63db\u3057\u305f\u753b\u50cf\u3092\u898b\u305b\u3089\u308c\u306a\u3044\u306e\u306f\u6b8b\u5ff5\u3067\u3059\u304c\u3001\u4ee5\u4e0b\u306b\u4f7f\u7528\u4f8b\u306e\u30d7\u30ed\u30b0\u30e9\u30e0\u3092\u8cbc\u308a\u307e\u3059\u3002\u4eca\u56de\u306e\u30d7\u30ed\u30b0\u30e9\u30e0\u3067\u306f\u3001\u5358\u7d14\u306b\u5c04\u5f71\u5909\u63db\u3057\u305f\u306e\u307f\u3067\u3001\u88dc\u9593\u306a\u3069\u306f\u304a\u3053\u306a\u3063\u3066\u3044\u307e\u305b\u3093\u3002\n\n```scala:Test.scala\n\nimport mmaioe.com.cameracalibration.Homography\nimport mmaioe.com.image.Image\n\n/**\n * Created by maoito on 12/19/15.\n */\nobject Test {\n  def main(args: Array[String]) {\n    val image = new Image(\"/Users/XXXX/DSC01018.JPG\")\n\n    println(image.height()+\",\"+image.width())\n\n\n    val homography = Homography.solve(\n      new {val x:Double = 0; val y:Double=0; },\n      new {val x:Double = 0; val y:Double=5; },\n      new {val x:Double = 5; val y:Double=0; },\n      new {val x:Double = 5; val y:Double=5; },\n      new {val x:Double = 0; val y:Double=0; },\n      new {val x:Double = 2; val y:Double=6; },\n      new {val x:Double = 4; val y:Double= -1; },\n      new {val x:Double = 6; val y:Double=4; }\n    )\n\n    val newImage = new Image(image.width()*2,image.height()*2)\n\n    val base_x=900\n    val base_y=900\n    (0 until image.width()).foreach{\n      x =>\n        (0 until image.height()).foreach{\n          y =>\n            val new_point = Homography.multiply(homography,List(x,y))\n\n            if(0 <= new_point(0)+base_x && new_point(0)+base_x < newImage.width() && 0 <= new_point(1)+base_y && new_point(1)+base_y < newImage.height()){\n              newImage.setColor(new_point(0)+base_x,new_point(1)+base_y,image.getRGBColor(x,y))\n            }\n        }\n    }\n\n    newImage.writeImage(\"homographied.png\")\n  }\n}\n```\n\n\n\n\n", "tags": ["Scala", "\u753b\u50cf\u51e6\u7406", "\u7dda\u5f62\u30b7\u30b9\u30c6\u30e0", "\u5c04\u5f71\u5909\u63db"]}