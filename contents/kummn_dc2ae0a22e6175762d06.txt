{"context": "\n(\u53c2\u8003) PT2\u3067\u5730\u30c7\u30b8\u3068\u885b\u661f\u653e\u9001\u3092\u9332\u753b\n\n(\u53c2\u8003) Linux/\u30c6\u30ec\u30d3\u95a2\u9023/PT2\n\n\n\nic card reader\u306einstall\n$ apt-get install pcscd pcsc-tools\n\n$ pcsc_scan\n    :\nJapanese Chijou Digital B-CAS Card (pay TV)\n\n\ndvb\u7248PT2\u30c9\u30e9\u30a4\u30d0\u3092\u524a\u9664\n$ lsmod | grep pt1\ndvb_core              122880  1 earth_pt1\n\n$ rmmod earth_pt1\n\n\u81ea\u52d5\u30ed\u30fc\u30c9\u3092\u7981\u6b62\n\n/etc/modprobe.d/blacklist.conf\nblacklist earth_pt1\n\n\nmercurial (hg) \u306einstall \n$ apt-get install mercurial\n\n\ndriver\u306e\u53d6\u5f97\u3068\u30d3\u30eb\u30c9\n$ hg clone http://hg.honeyplanet.jp/pt1.oyama/ pt1_driver_oyama\n# \u3042\u308b\u3044\u306f $ wget http://hg.honeyplanet.jp/pt1.oyama/archive/tip.tar.bz2\n\n\nPT1/PT2\u30c9\u30e9\u30a4\u30d0(\u65e7) http://hg.honeyplanet.jp/pt1/\n\nTS split\u5185\u8535\u7248 http://hg.honeyplanet.jp/pt1.oyama/\n\n\narib25\u30d5\u30a9\u30eb\u30c0\u3092\u5fa9\u6d3b\u3055\u305b\u308b\n$ hg revert -r c44e16dbb0e2 --all\n$ hg revert -r tip --all\n\nkernel4.2\u4ee5\u964d\u306fvmalloc.h\u304cio.h\u304b\u3089\u547c\u3070\u308c\u306a\u3044\u306e\u3067\uff0c\u30d1\u30c3\u30c1\u3092\u3042\u3066\u308b\uff0e\n\ndriver/pt1_pci.c\n--- pt1_pci.c.org       2016-11-27 19:07:47.986658497 +0900\n+++ pt1_pci.c   2016-11-27 19:13:06.821699691 +0900\n@@ -15,4 +15,7 @@\n #include <asm/uaccess.h>\n #include <linux/version.h>\n+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4,2,0)\n+  #include <linux/vmalloc.h>\n+#endif\n #include <linux/mutex.h>\n #if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,23)\n\n\n\u30c9\u30e9\u30a4\u30d0/arib25\u3092\u30a4\u30f3\u30b9\u30c8\u30fc\u30eb\n$ cd driver\n$ make\n$ make install\n$ modprobe pt1_drv\n$ lsmod | grep pt1_drv\n\n$ apt-get install libpcsclite-dev\n\n$ cd ../arib25/\n$ make\n$ make install\n\n\u203bDKMS\u3092\u4f7f\u3063\u3066kernel version up\u306e\u969b\u306b\u81ea\u52d5\u30d3\u30eb\u30c9\u3059\u308b\u65b9\u6cd5\u306f \u3053\u3061\u3089\u53c2\u7167\nrecpt1\u3092\u30ea\u30f3\u30af\u6642\u306binline\u306e\u53c2\u7167\u304c\u306a\u3044\u3068\u6012\u3089\u308c\u308b\u306e\u3067\uff0cinline\u3092\u524a\u9664\uff0e\n\nsrc/ushare.c\n-inline void\n+/*inline*/ void\n display_headers (void)\n\n\n\nsrc/trace.c\n-inline void\n+/*inline*/ void\n start_log (void)\n\n\n\u95a2\u9023\u30e2\u30b8\u30e5\u30fc\u30eb\u30a4\u30f3\u30b9\u30c8\u30fc\u30eb\u3057\u3066\uff0crecpt1\u3092\u30d3\u30eb\u30c9\n$ apt-get install ffmpeg libavformat-dev libdlna-dev libupnp-dev\n$ cd ..\n$ ./configure  --with-b25-dir=/usr/local --enable-b25\n$ cd src\n$ make\n$ make install\n\n\u4fe1\u53f7\u3092\u30c1\u30a7\u30c3\u30af\u3057\u3066\u9332\u753b\u3092\u30c1\u30a7\u30c3\u30af\n(channel\u306f src/channels/sample.recpt1-channels-* \u3042\u305f\u308a\u3092\u53c2\u8003\u306b)\n$ checksignal 21\ndevice = /dev/pt1video2\nC/N = 31.414479dB^C\n\n$ recpt1 --b25 --strip 21 10 test.mpg\nenable B25 strip\npid = 27975\ndevice = /dev/pt1video2\nRecording...\nRecorded 10sec\n\n\nchannel\u5272\u308a\u5f53\u3066 (@\u5343\u8449)\n\n\n\nBTN\nCH\n\u653e\u9001\u5c40\u540d\n\n\n\n\n1\n27\nNHK\u7dcf\u5408\n\n\n2\n26\nNHK\u6559\u80b2\n\n\n3\n30\n\u5343\u8449\u30c6\u30ec\u30d3\n\n\n4\n25\n\u65e5\u30c6\u30ec\n\n\n5\n24\nTV Asahi\n\n\n6\n22\nTBS\n\n\n7\n23\nTV Tokyo\n\n\n8\n21\nFuji TV\n\n\n9\n16\nTokyo MX1\n\n\n11\n28\n\u653e\u9001\u5927\u5b66\n\n\n\n\nhttp patch\u3092\u3042\u3066\u308b\n(\u53c2\u8003) recpt1\u306ehttp\u7248\u30d1\u30c3\u30c1\u3092\u9069\u7528\u3057\u3066\u307f\u305f\n$ recpt1 --b25 --strip --sid hd --http 8888\n\nVLC\u304b\u3089\u306f http://\u30b5\u30fc\u30d0\u306eIP\u30a2\u30c9\u30ec\u30b9:\u30dd\u30fc\u30c8\u756a\u53f7/\u30c1\u30e3\u30cd\u30eb\u756a\u53f7 \u3092\u6307\u5b9a\u3057\u3066\u63a5\u7d9a\u3059\u308b\uff0e\nsystemd\u306b\u767b\u9332\u3059\u308b\u305f\u3081\u30b5\u30fc\u30d3\u30b9\u3092\u8a18\u8ff0\u3057\u3066\u767b\u9332 (\u53c2\u8003) \n\u203brecpt1\u306ffork\u3059\u308b\u306e\u3067, type=forking \u306b\u3057\u306a\u3044\u3068\u3046\u307e\u304f\u52d5\u4f5c\u3057\u306a\u3044\u306e\u3067\u6ce8\u610f\n((\u53c2\u8003)Systemd\u5165\u9580(4) - service\u30bf\u30a4\u30d7Unit\u306e\u8a2d\u5b9a\u30d5\u30a1\u30a4\u30eb)\n\n/etc/systemd/system/recpt1-http.service\n[Unit]\nDescription = recpt1-http server\nAfter = network.target\n\n[Service]\nExecStart = /usr/local/bin/recpt1 --b25 --strip --sid hd --http 8888\nExecStop = /usr/bin/pkill recpt1\nRestart = no\nType = forking\n\n[Install]\nWantedBy = multi-user.target\n\n\n$ sytemctl list-unit-files --type=services | grep recpt1\nkuma-recpt1-http.service                   disabled\n\n# \u81ea\u52d5\u8d77\u52d5on\n$ sudo systemctl enable hello\n# \u8d77\u52d5\n$ sudo systemctl start hello\n\n\u30d1\u30c3\u30c1\u306f\u3053\u3061\u3089\n\nsrc/recpt1.c\n--- recpt1.c.org    2016-11-27 21:52:51.502723260 +0900\n+++ recpt1.c    2016-11-27 21:51:17.520258656 +0900\n@@ -22,6 +22,8 @@\n #include <netinet/in.h>\n\n #include <sys/ioctl.h>\n+#include <sys/socket.h>\n+#include <sys/uio.h>\n #include <pt1_ioctl.h>\n\n #include \"config.h\"\n@@ -869,7 +871,7 @@\n show_usage(char *cmd)\n {\n #ifdef HAVE_LIBARIB25\n-    fprintf(stderr, \"Usage: \\n%s [--b25 [--round N] [--strip] [--EMM]] [--udp [--addr hostname --port portnumber]] [--device devicefile] [--lnb voltage] [--sid SID1,SID2] [--es filename_suffix] [--start_time YYYYMMDDHHMISS] [--dlna] channel rectime destfile\\n\", cmd);\n+    fprintf(stderr, \"Usage: \\n%s [--b25 [--round N] [--strip] [--EMM]] [--udp [--addr hostname --port portnumber]] [--http portnumber] [--device devicefile] [--lnb voltage] [--sid SID1,SID2] [--es filename_suffix] [--start_time YYYYMMDDHHMISS] [--dlna] channel rectime destfile\\n\", cmd);\n #else\n     fprintf(stderr, \"Usage: \\n%s [--strip] [--EMM]] [--udp [--addr hostname --port portnumber]] [--device devicefile] [--lnb voltage] [--sid SID1,SID2] [--es filename_suffix] [--start_time YYYYMMDDHHMISS] [--dlna] channel rectime destfile\\n\", cmd);\n #endif\n@@ -892,6 +894,7 @@\n     fprintf(stderr, \"--udp:               Turn on udp broadcasting\\n\");\n     fprintf(stderr, \"  --addr hostname:   Hostname or address to connect\\n\");\n     fprintf(stderr, \"  --port portnumber: Port number to connect\\n\");\n+    fprintf(stderr, \"--http portnumber:   Turn on http broadcasting (run as a daemon)\\n\");\n     fprintf(stderr, \"--device devicefile: Specify devicefile to use\\n\");\n     fprintf(stderr, \"--lnb voltage:       Specify LNB voltage (0, 11, 15)\\n\");\n     fprintf(stderr, \"--sid SID1,SID2,...: Specify SID number in CSV format (101,102,...)\\n\");\n@@ -1033,6 +1036,34 @@\n     return 0; /* success */\n }\n\n+//read 1st line from socket\n+int read_line(int socket, char *p){\n+    int len = 0;\n+    while (1){\n+        int ret;\n+        ret = read(socket, p, 1);\n+        if ( ret == -1 ){\n+            perror(\"read\");\n+            // Connection reset by peer\n+            if ( errno == 104 ){\n+                return -1;\n+            }\n+            exit(1);\n+        } else if ( ret == 0 ){\n+            break;\n+        }\n+        if ( *p == '\\n' ){\n+            p++;\n+            len++;\n+            break;\n+        }\n+        p++;\n+        len++;\n+    }\n+    *p = '\\0';\n+    return len;\n+}\n+\n\n int\n main(int argc, char **argv)\n@@ -1074,6 +1105,7 @@\n         { \"udp\",       0, NULL, 'u'},\n         { \"addr\",      1, NULL, 'a'},\n         { \"port\",      1, NULL, 'p'},\n+        { \"http\",      1, NULL, 'H'},\n         { \"device\",    1, NULL, 'd'},\n         { \"help\",      0, NULL, 'h'},\n         { \"version\",   0, NULL, 'v'},\n@@ -1090,6 +1122,7 @@\n\n     boolean use_b25 = FALSE;\n     boolean use_udp = FALSE;\n+    boolean use_http = FALSE;\n     boolean fileless = FALSE;\n     boolean use_stdout = FALSE;\n     boolean use_splitter = FALSE;\n@@ -1097,6 +1130,7 @@\n     boolean use_dlna = FALSE;\n     char *host_to = NULL;\n     int port_to = 1234;\n+    int port_http = 12345;\n     sock_data *sockdata = NULL;\n     char *device = NULL;\n     int val;\n@@ -1105,7 +1139,7 @@\n     char *es_name_prefix = NULL;\n     char *start_time = NULL;\n\n-    while((result = getopt_long(argc, argv, \"br:smn:ua:p:d:hvli:y:c\",\n+    while((result = getopt_long(argc, argv, \"br:smn:ua:H:p:d:hvli:y:c\",\n                                 long_options, &option_index)) != -1) {\n         switch(result) {\n         case 'b':\n@@ -1125,6 +1159,11 @@\n             host_to = \"localhost\";\n             fprintf(stderr, \"enable UDP broadcasting\\n\");\n             break;\n+        case 'H':\n+            use_http = TRUE;\n+            port_http = atoi(optarg);\n+            fprintf(stderr, \"creating a http daemon\\n\");\n+            break;\n         case 'h':\n             fprintf(stderr, \"\\n\");\n             show_usage(argv[0]);\n@@ -1195,6 +1234,234 @@\n         }\n     }\n\n+    //http broadcasting\n+    if(use_http){\n+        fprintf(stderr, \"run as a daemon..\\n\");\n+        if(daemon(1,1)){\n+            perror(\"failed to start\");\n+            exit(1);\n+        }\n+        fprintf(stderr, \"pid = %d\\n\", getpid());\n+\n+        int connected_socket, listening_socket;\n+        struct sockaddr_in sin;\n+        unsigned int len;\n+        int ret;\n+        int sock_optval = 1;\n+\n+        listening_socket = socket(AF_INET, SOCK_STREAM, 0);\n+        if ( listening_socket == -1 ){\n+            perror(\"socket\");\n+            exit(1);\n+        }\n+\n+        if ( setsockopt(listening_socket, SOL_SOCKET, SO_REUSEADDR,\n+            &sock_optval, sizeof(sock_optval)) == -1 ){\n+            perror(\"setsockopt\");\n+            exit(1);\n+        }\n+\n+        sin.sin_family = AF_INET;\n+        sin.sin_port = htons(port_http);\n+        sin.sin_addr.s_addr = htonl(INADDR_ANY);\n+\n+        if ( bind(listening_socket, (struct sockaddr *)&sin, sizeof(sin)) < 0 ){\n+            perror(\"bind\");\n+            exit(1);\n+        }\n+\n+        ret = listen(listening_socket, SOMAXCONN);\n+        if ( ret == -1 ){\n+            perror(\"listen\");\n+            exit(1);\n+        }\n+        fprintf(stderr,\"listening at port %d\\n\", port_http);\n+\n+        /* initialize decoder */\n+        if(use_b25) {\n+            dec = b25_startup(&dopt);\n+            if(!dec) {\n+                fprintf(stderr, \"Cannot start b25 decoder\\n\");\n+                fprintf(stderr, \"Fall back to encrypted recording\\n\");\n+                use_b25 = FALSE;\n+            }\n+        }\n+        //set rectime to the infinite\n+        if(parse_time(\"-\",&tdata) != 0){\n+            return 1;\n+        }\n+\n+        while(1){\n+            struct hostent *peer_host;\n+            struct sockaddr_in peer_sin;\n+\n+            len = sizeof(peer_sin);\n+\n+            connected_socket = accept(listening_socket, (struct sockaddr *)&peer_sin, &len);\n+            if ( connected_socket == -1 ){\n+                perror(\"accept\");\n+                exit(1);\n+            }\n+\n+            int error;\n+            char hbuf[NI_MAXHOST], nhbuf[NI_MAXHOST], sbuf[NI_MAXSERV];\n+            error =  getnameinfo((struct sockaddr *)&peer_sin, sizeof(peer_sin), hbuf, sizeof(hbuf), NULL, 0, 0);\n+            if(error) {\n+                fprintf(stderr, \"getnameinfo(): %s\\n\", gai_strerror(error));\n+                exit(1);\n+            }\n+            error =  getnameinfo((struct sockaddr *)&peer_sin, sizeof(peer_sin), nhbuf, sizeof(nhbuf), sbuf, sizeof(sbuf), NI_NUMERICHOST | NI_NUMERICSERV);\n+            if(error) {\n+                fprintf(stderr, \"getnameinfo(): %s\\n\", gai_strerror(error));\n+                exit(1);\n+            }\n+            fprintf(stderr,\"connect from: %s [%s] port %s\\n\", hbuf, nhbuf, sbuf);\n+\n+            int read_size;\n+\n+            char buf[256];\n+            read_size = read_line(connected_socket, buf);\n+        if ( read_size != -1 ){\n+            fprintf(stderr,\"request command is %s\\n\",buf);\n+            char s0[256],s1[256],s2[256];\n+            sscanf(buf,\"%s%s%s\",s0,s1,s2);\n+            char delim[] = \"/\";\n+            char *channel = strtok(s1,delim);\n+            char *sidflg = strtok(NULL,delim);\n+            if(sidflg)\n+                sid_list = sidflg;\n+            fprintf(stderr,\"channel is %s\\n\",channel);\n+\n+            /* initialize splitter */\n+            if(use_splitter) {\n+                splitter = split_startup(sid_list);\n+                if(splitter->sid_list == NULL) {\n+                    fprintf(stderr, \"Cannot start TS splitter\\n\");\n+                    return 1;\n+                }\n+            }\n+            char header[] =  \"HTTP/1.1 200 OK\\r\\nContent-Type: application/octet-stream\\r\\nCache-Control: no-cache\\r\\n\\r\\n\";\n+            ret = write(connected_socket, header, strlen(header));\n+\n+            //set write target to http\n+            tdata.wfd = connected_socket;\n+\n+            //tune\n+            if(tune(channel, &tdata, device) != 0){\n+                fprintf(stderr, \"Tuner cannot start recording\\n\");\n+                continue;\n+            }\n+            /* prepare thread data */\n+            tdata.queue = p_queue;\n+            tdata.decoder = dec;\n+            tdata.splitter = splitter;\n+            tdata.sock_data = sockdata;\n+\n+            /* spawn signal handler thread */\n+            init_signal_handlers(&signal_thread, &tdata);\n+\n+            /* spawn reader thread */\n+            tdata.signal_thread = signal_thread;\n+            pthread_create(&reader_thread, NULL, reader_func, &tdata);\n+\n+            /* spawn ipc thread */\n+            key_t key;\n+            key = (key_t)(getpid());\n+\n+            if ((tdata.msqid = msgget(key, IPC_CREAT | 0666)) < 0) {\n+                perror(\"msgget\");\n+            }\n+            pthread_create(&ipc_thread, NULL, mq_recv, &tdata);\n+\n+            /* start recording */\n+            if(ioctl(tdata.tfd, START_REC, 0) < 0) {\n+                fprintf(stderr, \"Tuner cannot start recording\\n\");\n+                exit(1);\n+            }\n+\n+            fprintf(stderr, \"Broadcasting...\\n\");\n+\n+            time(&tdata.start_time);\n+\n+            /* read from tuner */\n+            while(1) {\n+                if(f_exit)\n+                    break;\n+\n+                time(&cur_time);\n+                bufptr = malloc(sizeof(BUFSZ));\n+                if(!bufptr) {\n+                    f_exit = TRUE;\n+                    break;\n+                }\n+                bufptr->size = read(tdata.tfd, bufptr->buffer, MAX_READ_SIZE);\n+                if(bufptr->size <= 0) {\n+                    if((cur_time - tdata.start_time) >= tdata.recsec && !tdata.indefinite) {\n+                        f_exit = TRUE;\n+                        enqueue(p_queue, NULL);\n+                        break;\n+                    }\n+                    else {\n+                        continue;\n+                    }\n+                }\n+                enqueue(p_queue, bufptr);\n+\n+                /* stop recording */\n+                time(&cur_time);\n+                if((cur_time - tdata.start_time) >= tdata.recsec && !tdata.indefinite) {\n+                    ioctl(tdata.tfd, STOP_REC, 0);\n+                    /* read remaining data */\n+                    while(1) {\n+                        bufptr = malloc(sizeof(BUFSZ));\n+                        if(!bufptr) {\n+                            f_exit = TRUE;\n+                            break;\n+                        }\n+                        bufptr->size = read(tdata.tfd, bufptr->buffer, MAX_READ_SIZE);\n+                        if(bufptr->size <= 0) {\n+                            f_exit = TRUE;\n+                            enqueue(p_queue, NULL);\n+                            break;\n+                        }\n+                        enqueue(p_queue, bufptr);\n+                    }\n+                    break;\n+                }\n+            }\n+\n+            /* delete message queue*/\n+            msgctl(tdata.msqid, IPC_RMID, NULL);\n+\n+            pthread_kill(signal_thread, SIGUSR1);\n+\n+            /* wait for threads */\n+            pthread_join(reader_thread, NULL);\n+            pthread_join(signal_thread, NULL);\n+            pthread_join(ipc_thread, NULL);\n+\n+            /* close tuner */\n+            if(close_tuner(&tdata) != 0)\n+                return 1;\n+\n+            //reset queue\n+            destroy_queue(p_queue);\n+            p_queue = create_queue(MAX_QUEUE);\n+\n+            /* close splitter */\n+            if(use_splitter) {\n+                split_shutdown(splitter);\n+            }\n+ \n+        }\n+            /* close http socket */\n+            close(tdata.wfd);\n+\n+            fprintf(stderr,\"connection closed. still listening at port %d\\n\",port_http);\n+            f_exit = FALSE;\n+        }\n+    }\n+\n     if(argc - optind < 3) {\n         if(argc - optind == 2 &&\n               (use_udp|use_dlna|use_esout) ) {\n\n\n\u3055\u3089\u306bhttp\u306e\u969b\u306epid\u3092 /tmp/recpt1.pid \u306b\u8a18\u9332\u3059\u308b\u3088\u3046\u306b\u4fee\u6b63\u3057\u3066\uff0cPIDFile\u3092\u8a2d\u5b9a\u3057\uff0cRestart=always \u306b\u3059\u308b\u3068\uff0c\u843d\u3061\u305f\u6642\u81ea\u52d5\u3067systemd\u3067\u518d\u8d77\u52d5\u3055\u308c\u308b\uff0e\n\nsrc/recpt1.c\n        fprintf(stderr, \"pid = %d\\n\", getpid());\n+       FILE* fp = fopen(\"/tmp/recpt1.pid\", \"w\");\n+       fprintf(fp, \"%d\\n\", getpid());\n+       fclose(fp);\n\n\n\n/etc/systemd/system/recpt1-http.service\n[Unit]\nDescription = recpt1-http server\nAfter = network.target\n\n[Service]\nExecStart = /usr/local/bin/recpt1 --b25 --strip --sid hd --http 8888\nExecStop = /usr/bin/pkill recpt1\nExeStopPost = /bin/rm /tmp/recpt1.pid\nRestart = always\nType = forking\nPIDFile = /tmp/recpt1.pid\n#PrivateTmp = true\n\n[Install]\nWantedBy = multi-user.target\n\n\nPrivateTmp\u3092\u6709\u52b9\u306b\u3059\u308b\u3068\uff0c\u5916\u90e8\u304b\u3089\u30a2\u30af\u30bb\u30b9\u3067\u304d\u306a\u3044\u306e\u3067\u7121\u52b9\u306b\u3059\u308b\uff0e\n(PIDFile\u3067\u6307\u5b9a\u3057\u3066\u3082\u898b\u3064\u304b\u3089\u306a\u3044)\n* (\u53c2\u8003) [PT2\u3067\u5730\u30c7\u30b8\u3068\u885b\u661f\u653e\u9001\u3092\u9332\u753b](https://tech.nosuz.jp/2016/05/record-braodcast-by-pt2/)\n* (\u53c2\u8003) [Linux/\u30c6\u30ec\u30d3\u95a2\u9023/PT2](http://baalzephon.no-ip.org/tech/index.php?Linux%2F%E3%83%86%E3%83%AC%E3%83%93%E9%96%A2%E9%80%A3%2FPT2)\n\n\n## ic card reader\u306einstall\n\n```\n$ apt-get install pcscd pcsc-tools\n\n$ pcsc_scan\n    :\nJapanese Chijou Digital B-CAS Card (pay TV)\n```\n\n## dvb\u7248PT2\u30c9\u30e9\u30a4\u30d0\u3092\u524a\u9664\n\n```\n$ lsmod | grep pt1\ndvb_core              122880  1 earth_pt1\n\n$ rmmod earth_pt1\n```\n\n\u81ea\u52d5\u30ed\u30fc\u30c9\u3092\u7981\u6b62\n\n```shell-session:/etc/modprobe.d/blacklist.conf\nblacklist earth_pt1\n```\n\nmercurial (hg) \u306einstall \n\n```\n$ apt-get install mercurial\n```\n\n## driver\u306e\u53d6\u5f97\u3068\u30d3\u30eb\u30c9\n\n```\n$ hg clone http://hg.honeyplanet.jp/pt1.oyama/ pt1_driver_oyama\n# \u3042\u308b\u3044\u306f $ wget http://hg.honeyplanet.jp/pt1.oyama/archive/tip.tar.bz2\n```\n\n* PT1/PT2\u30c9\u30e9\u30a4\u30d0(\u65e7) http://hg.honeyplanet.jp/pt1/\n* TS split\u5185\u8535\u7248 http://hg.honeyplanet.jp/pt1.oyama/\n\narib25\u30d5\u30a9\u30eb\u30c0\u3092\u5fa9\u6d3b\u3055\u305b\u308b\n\n```\n$ hg revert -r c44e16dbb0e2 --all\n$ hg revert -r tip --all\n```\n\nkernel4.2\u4ee5\u964d\u306fvmalloc.h\u304cio.h\u304b\u3089\u547c\u3070\u308c\u306a\u3044\u306e\u3067\uff0c\u30d1\u30c3\u30c1\u3092\u3042\u3066\u308b\uff0e\n\n```cpp:driver/pt1_pci.c\n--- pt1_pci.c.org       2016-11-27 19:07:47.986658497 +0900\n+++ pt1_pci.c   2016-11-27 19:13:06.821699691 +0900\n@@ -15,4 +15,7 @@\n #include <asm/uaccess.h>\n #include <linux/version.h>\n+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4,2,0)\n+  #include <linux/vmalloc.h>\n+#endif\n #include <linux/mutex.h>\n #if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,23)\n```\n\n\u30c9\u30e9\u30a4\u30d0/arib25\u3092\u30a4\u30f3\u30b9\u30c8\u30fc\u30eb\n\n```\n$ cd driver\n$ make\n$ make install\n$ modprobe pt1_drv\n$ lsmod | grep pt1_drv\n\n$ apt-get install libpcsclite-dev\n\n$ cd ../arib25/\n$ make\n$ make install\n```\n\n\u203bDKMS\u3092\u4f7f\u3063\u3066kernel version up\u306e\u969b\u306b\u81ea\u52d5\u30d3\u30eb\u30c9\u3059\u308b\u65b9\u6cd5\u306f [\u3053\u3061\u3089\u53c2\u7167](https://tech.nosuz.jp/2016/05/record-braodcast-by-pt2/)\n\nrecpt1\u3092\u30ea\u30f3\u30af\u6642\u306binline\u306e\u53c2\u7167\u304c\u306a\u3044\u3068\u6012\u3089\u308c\u308b\u306e\u3067\uff0cinline\u3092\u524a\u9664\uff0e\n\n```cpp:src/ushare.c\n-inline void\n+/*inline*/ void\n display_headers (void)\n```\n\n```cpp:src/trace.c\n-inline void\n+/*inline*/ void\n start_log (void)\n```\n\n\u95a2\u9023\u30e2\u30b8\u30e5\u30fc\u30eb\u30a4\u30f3\u30b9\u30c8\u30fc\u30eb\u3057\u3066\uff0crecpt1\u3092\u30d3\u30eb\u30c9\n\n```\n$ apt-get install ffmpeg libavformat-dev libdlna-dev libupnp-dev\n$ cd ..\n$ ./configure  --with-b25-dir=/usr/local --enable-b25\n$ cd src\n$ make\n$ make install\n```\n\n\u4fe1\u53f7\u3092\u30c1\u30a7\u30c3\u30af\u3057\u3066\u9332\u753b\u3092\u30c1\u30a7\u30c3\u30af\n(channel\u306f `src/channels/sample.recpt1-channels-*` \u3042\u305f\u308a\u3092\u53c2\u8003\u306b)\n\n```\n$ checksignal 21\ndevice = /dev/pt1video2\nC/N = 31.414479dB^C\n\n$ recpt1 --b25 --strip 21 10 test.mpg\nenable B25 strip\npid = 27975\ndevice = /dev/pt1video2\nRecording...\nRecorded 10sec\n```\n\n## channel\u5272\u308a\u5f53\u3066 (@\u5343\u8449)\n\n|BTN| CH| \u653e\u9001\u5c40\u540d|\n|-----|-----|---------|\n|1|27|NHK\u7dcf\u5408|\n|2|26|NHK\u6559\u80b2|\n|3|30|\u5343\u8449\u30c6\u30ec\u30d3|\n|4|25|\u65e5\u30c6\u30ec|\n|5|24|TV Asahi|\n|6|22|TBS|\n|7|23|TV Tokyo|\n|8|21|Fuji TV|\n|9|16|Tokyo MX1|\n|11|28|\u653e\u9001\u5927\u5b66|\n\n## http patch\u3092\u3042\u3066\u308b\n\n(\u53c2\u8003) [recpt1\u306ehttp\u7248\u30d1\u30c3\u30c1\u3092\u9069\u7528\u3057\u3066\u307f\u305f](http://papa3camel.blogspot.jp/2012/07/recpt1http.html)\n\n```shell-session\n$ recpt1 --b25 --strip --sid hd --http 8888\n```\n\nVLC\u304b\u3089\u306f http://\u30b5\u30fc\u30d0\u306eIP\u30a2\u30c9\u30ec\u30b9:\u30dd\u30fc\u30c8\u756a\u53f7/\u30c1\u30e3\u30cd\u30eb\u756a\u53f7 \u3092\u6307\u5b9a\u3057\u3066\u63a5\u7d9a\u3059\u308b\uff0e\n\nsystemd\u306b\u767b\u9332\u3059\u308b\u305f\u3081\u30b5\u30fc\u30d3\u30b9\u3092\u8a18\u8ff0\u3057\u3066\u767b\u9332 ([\u53c2\u8003](http://qiita.com/DQNEO/items/0b5d0bc5d3cf407cb7ff)) \n**\u203brecpt1\u306ffork\u3059\u308b\u306e\u3067, type=forking \u306b\u3057\u306a\u3044\u3068\u3046\u307e\u304f\u52d5\u4f5c\u3057\u306a\u3044\u306e\u3067\u6ce8\u610f**\n((\u53c2\u8003)[Systemd\u5165\u9580(4) - service\u30bf\u30a4\u30d7Unit\u306e\u8a2d\u5b9a\u30d5\u30a1\u30a4\u30eb](http://enakai00.hatenablog.com/entry/20130917/1379374797))\n\n```shell-session:/etc/systemd/system/recpt1-http.service\n[Unit]\nDescription = recpt1-http server\nAfter = network.target\n\n[Service]\nExecStart = /usr/local/bin/recpt1 --b25 --strip --sid hd --http 8888\nExecStop = /usr/bin/pkill recpt1\nRestart = no\nType = forking\n\n[Install]\nWantedBy = multi-user.target\n```\n\n```shell-session\n$ sytemctl list-unit-files --type=services | grep recpt1\nkuma-recpt1-http.service                   disabled\n\n# \u81ea\u52d5\u8d77\u52d5on\n$ sudo systemctl enable hello\n# \u8d77\u52d5\n$ sudo systemctl start hello\n```\n\n\u30d1\u30c3\u30c1\u306f\u3053\u3061\u3089\n\n```cpp:src/recpt1.c\n--- recpt1.c.org\t2016-11-27 21:52:51.502723260 +0900\n+++ recpt1.c\t2016-11-27 21:51:17.520258656 +0900\n@@ -22,6 +22,8 @@\n #include <netinet/in.h>\n \n #include <sys/ioctl.h>\n+#include <sys/socket.h>\n+#include <sys/uio.h>\n #include <pt1_ioctl.h>\n \n #include \"config.h\"\n@@ -869,7 +871,7 @@\n show_usage(char *cmd)\n {\n #ifdef HAVE_LIBARIB25\n-    fprintf(stderr, \"Usage: \\n%s [--b25 [--round N] [--strip] [--EMM]] [--udp [--addr hostname --port portnumber]] [--device devicefile] [--lnb voltage] [--sid SID1,SID2] [--es filename_suffix] [--start_time YYYYMMDDHHMISS] [--dlna] channel rectime destfile\\n\", cmd);\n+    fprintf(stderr, \"Usage: \\n%s [--b25 [--round N] [--strip] [--EMM]] [--udp [--addr hostname --port portnumber]] [--http portnumber] [--device devicefile] [--lnb voltage] [--sid SID1,SID2] [--es filename_suffix] [--start_time YYYYMMDDHHMISS] [--dlna] channel rectime destfile\\n\", cmd);\n #else\n     fprintf(stderr, \"Usage: \\n%s [--strip] [--EMM]] [--udp [--addr hostname --port portnumber]] [--device devicefile] [--lnb voltage] [--sid SID1,SID2] [--es filename_suffix] [--start_time YYYYMMDDHHMISS] [--dlna] channel rectime destfile\\n\", cmd);\n #endif\n@@ -892,6 +894,7 @@\n     fprintf(stderr, \"--udp:               Turn on udp broadcasting\\n\");\n     fprintf(stderr, \"  --addr hostname:   Hostname or address to connect\\n\");\n     fprintf(stderr, \"  --port portnumber: Port number to connect\\n\");\n+    fprintf(stderr, \"--http portnumber:   Turn on http broadcasting (run as a daemon)\\n\");\n     fprintf(stderr, \"--device devicefile: Specify devicefile to use\\n\");\n     fprintf(stderr, \"--lnb voltage:       Specify LNB voltage (0, 11, 15)\\n\");\n     fprintf(stderr, \"--sid SID1,SID2,...: Specify SID number in CSV format (101,102,...)\\n\");\n@@ -1033,6 +1036,34 @@\n     return 0; /* success */\n }\n \n+//read 1st line from socket\n+int read_line(int socket, char *p){\n+    int len = 0;\n+    while (1){\n+        int ret;\n+        ret = read(socket, p, 1);\n+        if ( ret == -1 ){\n+            perror(\"read\");\n+            // Connection reset by peer\n+            if ( errno == 104 ){\n+                return -1;\n+            }\n+            exit(1);\n+        } else if ( ret == 0 ){\n+            break;\n+        }\n+        if ( *p == '\\n' ){\n+            p++;\n+            len++;\n+            break;\n+        }\n+        p++;\n+        len++;\n+    }\n+    *p = '\\0';\n+    return len;\n+}\n+\n \n int\n main(int argc, char **argv)\n@@ -1074,6 +1105,7 @@\n         { \"udp\",       0, NULL, 'u'},\n         { \"addr\",      1, NULL, 'a'},\n         { \"port\",      1, NULL, 'p'},\n+        { \"http\",      1, NULL, 'H'},\n         { \"device\",    1, NULL, 'd'},\n         { \"help\",      0, NULL, 'h'},\n         { \"version\",   0, NULL, 'v'},\n@@ -1090,6 +1122,7 @@\n \n     boolean use_b25 = FALSE;\n     boolean use_udp = FALSE;\n+    boolean use_http = FALSE;\n     boolean fileless = FALSE;\n     boolean use_stdout = FALSE;\n     boolean use_splitter = FALSE;\n@@ -1097,6 +1130,7 @@\n     boolean use_dlna = FALSE;\n     char *host_to = NULL;\n     int port_to = 1234;\n+    int port_http = 12345;\n     sock_data *sockdata = NULL;\n     char *device = NULL;\n     int val;\n@@ -1105,7 +1139,7 @@\n     char *es_name_prefix = NULL;\n     char *start_time = NULL;\n \n-    while((result = getopt_long(argc, argv, \"br:smn:ua:p:d:hvli:y:c\",\n+    while((result = getopt_long(argc, argv, \"br:smn:ua:H:p:d:hvli:y:c\",\n                                 long_options, &option_index)) != -1) {\n         switch(result) {\n         case 'b':\n@@ -1125,6 +1159,11 @@\n             host_to = \"localhost\";\n             fprintf(stderr, \"enable UDP broadcasting\\n\");\n             break;\n+        case 'H':\n+            use_http = TRUE;\n+            port_http = atoi(optarg);\n+            fprintf(stderr, \"creating a http daemon\\n\");\n+            break;\n         case 'h':\n             fprintf(stderr, \"\\n\");\n             show_usage(argv[0]);\n@@ -1195,6 +1234,234 @@\n         }\n     }\n \n+    //http broadcasting\n+    if(use_http){\n+        fprintf(stderr, \"run as a daemon..\\n\");\n+        if(daemon(1,1)){\n+            perror(\"failed to start\");\n+            exit(1);\n+        }\n+        fprintf(stderr, \"pid = %d\\n\", getpid());\n+\n+        int connected_socket, listening_socket;\n+        struct sockaddr_in sin;\n+        unsigned int len;\n+        int ret;\n+        int sock_optval = 1;\n+\n+        listening_socket = socket(AF_INET, SOCK_STREAM, 0);\n+        if ( listening_socket == -1 ){\n+            perror(\"socket\");\n+            exit(1);\n+        }\n+\n+        if ( setsockopt(listening_socket, SOL_SOCKET, SO_REUSEADDR,\n+            &sock_optval, sizeof(sock_optval)) == -1 ){\n+            perror(\"setsockopt\");\n+            exit(1);\n+        }\n+\n+        sin.sin_family = AF_INET;\n+        sin.sin_port = htons(port_http);\n+        sin.sin_addr.s_addr = htonl(INADDR_ANY);\n+\n+        if ( bind(listening_socket, (struct sockaddr *)&sin, sizeof(sin)) < 0 ){\n+            perror(\"bind\");\n+            exit(1);\n+        }\n+\n+        ret = listen(listening_socket, SOMAXCONN);\n+        if ( ret == -1 ){\n+            perror(\"listen\");\n+            exit(1);\n+        }\n+        fprintf(stderr,\"listening at port %d\\n\", port_http);\n+\n+        /* initialize decoder */\n+        if(use_b25) {\n+            dec = b25_startup(&dopt);\n+            if(!dec) {\n+                fprintf(stderr, \"Cannot start b25 decoder\\n\");\n+                fprintf(stderr, \"Fall back to encrypted recording\\n\");\n+                use_b25 = FALSE;\n+            }\n+        }\n+        //set rectime to the infinite\n+        if(parse_time(\"-\",&tdata) != 0){\n+            return 1;\n+        }\n+\n+        while(1){\n+            struct hostent *peer_host;\n+            struct sockaddr_in peer_sin;\n+\n+            len = sizeof(peer_sin);\n+\n+            connected_socket = accept(listening_socket, (struct sockaddr *)&peer_sin, &len);\n+            if ( connected_socket == -1 ){\n+                perror(\"accept\");\n+                exit(1);\n+            }\n+\n+            int error;\n+            char hbuf[NI_MAXHOST], nhbuf[NI_MAXHOST], sbuf[NI_MAXSERV];\n+            error =  getnameinfo((struct sockaddr *)&peer_sin, sizeof(peer_sin), hbuf, sizeof(hbuf), NULL, 0, 0);\n+            if(error) {\n+                fprintf(stderr, \"getnameinfo(): %s\\n\", gai_strerror(error));\n+                exit(1);\n+            }\n+            error =  getnameinfo((struct sockaddr *)&peer_sin, sizeof(peer_sin), nhbuf, sizeof(nhbuf), sbuf, sizeof(sbuf), NI_NUMERICHOST | NI_NUMERICSERV);\n+            if(error) {\n+                fprintf(stderr, \"getnameinfo(): %s\\n\", gai_strerror(error));\n+                exit(1);\n+            }\n+            fprintf(stderr,\"connect from: %s [%s] port %s\\n\", hbuf, nhbuf, sbuf);\n+\n+            int read_size;\n+\n+            char buf[256];\n+            read_size = read_line(connected_socket, buf);\n+        if ( read_size != -1 ){\n+            fprintf(stderr,\"request command is %s\\n\",buf);\n+            char s0[256],s1[256],s2[256];\n+            sscanf(buf,\"%s%s%s\",s0,s1,s2);\n+            char delim[] = \"/\";\n+            char *channel = strtok(s1,delim);\n+            char *sidflg = strtok(NULL,delim);\n+            if(sidflg)\n+                sid_list = sidflg;\n+            fprintf(stderr,\"channel is %s\\n\",channel);\n+\n+            /* initialize splitter */\n+            if(use_splitter) {\n+                splitter = split_startup(sid_list);\n+                if(splitter->sid_list == NULL) {\n+                    fprintf(stderr, \"Cannot start TS splitter\\n\");\n+                    return 1;\n+                }\n+            }\n+            char header[] =  \"HTTP/1.1 200 OK\\r\\nContent-Type: application/octet-stream\\r\\nCache-Control: no-cache\\r\\n\\r\\n\";\n+            ret = write(connected_socket, header, strlen(header));\n+\n+            //set write target to http\n+            tdata.wfd = connected_socket;\n+\n+            //tune\n+            if(tune(channel, &tdata, device) != 0){\n+                fprintf(stderr, \"Tuner cannot start recording\\n\");\n+                continue;\n+            }\n+            /* prepare thread data */\n+            tdata.queue = p_queue;\n+            tdata.decoder = dec;\n+            tdata.splitter = splitter;\n+            tdata.sock_data = sockdata;\n+\n+            /* spawn signal handler thread */\n+            init_signal_handlers(&signal_thread, &tdata);\n+\n+            /* spawn reader thread */\n+            tdata.signal_thread = signal_thread;\n+            pthread_create(&reader_thread, NULL, reader_func, &tdata);\n+\n+            /* spawn ipc thread */\n+            key_t key;\n+            key = (key_t)(getpid());\n+\n+            if ((tdata.msqid = msgget(key, IPC_CREAT | 0666)) < 0) {\n+                perror(\"msgget\");\n+            }\n+            pthread_create(&ipc_thread, NULL, mq_recv, &tdata);\n+\n+            /* start recording */\n+            if(ioctl(tdata.tfd, START_REC, 0) < 0) {\n+                fprintf(stderr, \"Tuner cannot start recording\\n\");\n+                exit(1);\n+            }\n+\n+            fprintf(stderr, \"Broadcasting...\\n\");\n+\n+            time(&tdata.start_time);\n+\n+            /* read from tuner */\n+            while(1) {\n+                if(f_exit)\n+                    break;\n+\n+                time(&cur_time);\n+                bufptr = malloc(sizeof(BUFSZ));\n+                if(!bufptr) {\n+                    f_exit = TRUE;\n+                    break;\n+                }\n+                bufptr->size = read(tdata.tfd, bufptr->buffer, MAX_READ_SIZE);\n+                if(bufptr->size <= 0) {\n+                    if((cur_time - tdata.start_time) >= tdata.recsec && !tdata.indefinite) {\n+                        f_exit = TRUE;\n+                        enqueue(p_queue, NULL);\n+                        break;\n+                    }\n+                    else {\n+                        continue;\n+                    }\n+                }\n+                enqueue(p_queue, bufptr);\n+\n+                /* stop recording */\n+                time(&cur_time);\n+                if((cur_time - tdata.start_time) >= tdata.recsec && !tdata.indefinite) {\n+                    ioctl(tdata.tfd, STOP_REC, 0);\n+                    /* read remaining data */\n+                    while(1) {\n+                        bufptr = malloc(sizeof(BUFSZ));\n+                        if(!bufptr) {\n+                            f_exit = TRUE;\n+                            break;\n+                        }\n+                        bufptr->size = read(tdata.tfd, bufptr->buffer, MAX_READ_SIZE);\n+                        if(bufptr->size <= 0) {\n+                            f_exit = TRUE;\n+                            enqueue(p_queue, NULL);\n+                            break;\n+                        }\n+                        enqueue(p_queue, bufptr);\n+                    }\n+                    break;\n+                }\n+            }\n+\n+            /* delete message queue*/\n+            msgctl(tdata.msqid, IPC_RMID, NULL);\n+\n+            pthread_kill(signal_thread, SIGUSR1);\n+\n+            /* wait for threads */\n+            pthread_join(reader_thread, NULL);\n+            pthread_join(signal_thread, NULL);\n+            pthread_join(ipc_thread, NULL);\n+\n+            /* close tuner */\n+            if(close_tuner(&tdata) != 0)\n+                return 1;\n+\n+            //reset queue\n+            destroy_queue(p_queue);\n+            p_queue = create_queue(MAX_QUEUE);\n+\n+            /* close splitter */\n+            if(use_splitter) {\n+                split_shutdown(splitter);\n+            }\n+ \n+        }\n+            /* close http socket */\n+            close(tdata.wfd);\n+\n+            fprintf(stderr,\"connection closed. still listening at port %d\\n\",port_http);\n+            f_exit = FALSE;\n+        }\n+    }\n+\n     if(argc - optind < 3) {\n         if(argc - optind == 2 &&\n               (use_udp|use_dlna|use_esout) ) {\n```\n\n\u3055\u3089\u306bhttp\u306e\u969b\u306epid\u3092 /tmp/recpt1.pid \u306b\u8a18\u9332\u3059\u308b\u3088\u3046\u306b\u4fee\u6b63\u3057\u3066\uff0cPIDFile\u3092\u8a2d\u5b9a\u3057\uff0cRestart=always \u306b\u3059\u308b\u3068\uff0c\u843d\u3061\u305f\u6642\u81ea\u52d5\u3067systemd\u3067\u518d\u8d77\u52d5\u3055\u308c\u308b\uff0e\n\n```cpp:src/recpt1.c\n        fprintf(stderr, \"pid = %d\\n\", getpid());\n+       FILE* fp = fopen(\"/tmp/recpt1.pid\", \"w\");\n+       fprintf(fp, \"%d\\n\", getpid());\n+       fclose(fp);\n```\n```shell-session:/etc/systemd/system/recpt1-http.service\n[Unit]\nDescription = recpt1-http server\nAfter = network.target\n\n[Service]\nExecStart = /usr/local/bin/recpt1 --b25 --strip --sid hd --http 8888\nExecStop = /usr/bin/pkill recpt1\nExeStopPost = /bin/rm /tmp/recpt1.pid\nRestart = always\nType = forking\nPIDFile = /tmp/recpt1.pid\n#PrivateTmp = true\n\n[Install]\nWantedBy = multi-user.target\n```\n\nPrivateTmp\u3092\u6709\u52b9\u306b\u3059\u308b\u3068\uff0c\u5916\u90e8\u304b\u3089\u30a2\u30af\u30bb\u30b9\u3067\u304d\u306a\u3044\u306e\u3067\u7121\u52b9\u306b\u3059\u308b\uff0e\n(PIDFile\u3067\u6307\u5b9a\u3057\u3066\u3082\u898b\u3064\u304b\u3089\u306a\u3044)\n\n", "tags": ["Linux", "ubuntu16.04"]}