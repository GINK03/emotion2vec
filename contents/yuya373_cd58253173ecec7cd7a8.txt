{"context": " More than 1 year has passed since last update.\n\nEstablish connection\n\nConnectionHandling#establish_connection\n\n    def establish_connection(spec = nil)\n      spec     ||= DEFAULT_ENV.call.to_sym\n      resolver =   ConnectionAdapters::ConnectionSpecification::Resolver.new configurations\n      spec     =   resolver.spec(spec)\n\n      unless respond_to?(spec.adapter_method)\n        raise AdapterNotFound, \"database configuration specifies nonexistent #{spec.config[:adapter]} adapter\"\n      end\n\n      remove_connection\n      connection_handler.establish_connection self, spec\n    end\n\n\n\n\nConnectionHandling\n\n    RAILS_ENV   = -> { (Rails.env if defined?(Rails)) || ENV[\"RAILS_ENV\"] || ENV[\"RACK_ENV\"] }\n    DEFAULT_ENV = -> { RAILS_ENV.call || \"default_env\" }\n\n\n\n\nActiveRecord\n\n$ pp configurations\n\n{\"default\"=>\n  {\"adapter\"=>\"mysql2\",\n   \"encoding\"=>\"utf8\",\n   \"reconnect\"=>false,\n   \"pool\"=>5,\n   \"username\"=>\"root\",\n   \"password\"=>nil},\n \"development\"=>\n  {\"adapter\"=>\"mysql2\",\n   \"encoding\"=>\"utf8\",\n   \"reconnect\"=>false,\n   \"pool\"=>5,\n   \"username\"=>\"root\",\n   \"password\"=>nil,\n   \"database\"=>\"hogehoge_development\"},\n ...  \n\n\n\n\nConnectionAdapter\n\n        def spec(config)\n          spec = resolve(config).symbolize_keys\n\n          raise(AdapterNotSpecified, \"database configuration does not specify adapter\") unless spec.key?(:adapter)\n\n          path_to_adapter = \"active_record/connection_adapters/#{spec[:adapter]}_adapter\"\n          begin\n            require path_to_adapter\n          rescue Gem::LoadError => e\n            raise Gem::LoadError, \"Specified '#{spec[:adapter]}' for database adapter, but the gem is not loaded. Add `gem '#{e.name}'` to your Gemfile (and ensure its version is at the minimum required by ActiveRecord).\"\n          rescue LoadError => e\n            raise LoadError, \"Could not load '#{path_to_adapter}'. Make sure that the adapter in config/database.yml is valid. If you use an adapter other than 'mysql', 'mysql2', 'postgresql' or 'sqlite3' add the necessary adapter gem to the Gemfile.\", e.backtrace\n          end\n\n          adapter_method = \"#{spec[:adapter]}_connection\"\n          ConnectionSpecification.new(spec, adapter_method)\n        end\n\n\n\nConnectionAdapter\n\n      def initialize(config, adapter_method)\n        @config, @adapter_method = config, adapter_method\n      end\n\n\n\n\nActiveRecord\n\n      def self.connection_handler\n        ActiveRecord::RuntimeRegistry.connection_handler || default_connection_handler\n      end\n\n\n\n\nActiveRecord\n  # This is a thread locals registry for Active Record. For example:\n  #\n  #   ActiveRecord::RuntimeRegistry.connection_handler\n  #\n  # returns the connection handler local to the current thread.\n  #\n  # See the documentation of <tt>ActiveSupport::PerThreadRegistry</tt>\n  # for further details.\n  class RuntimeRegistry # :nodoc:\n    extend ActiveSupport::PerThreadRegistry\n\n    attr_accessor :connection_handler, :sql_runtime, :connection_id\n\n    [:connection_handler, :sql_runtime, :connection_id].each do |val|\n      class_eval %{ def self.#{val}; instance.#{val}; end }, __FILE__, __LINE__\n      class_eval %{ def self.#{val}=(x); instance.#{val}=x; end }, __FILE__, __LINE__\n    end\n  end\n\n\n\nConnectionAdapter\n\n    # ConnectionHandler is a collection of ConnectionPool objects. It is used\n    # for keeping separate connection pools for Active Record models that connect\n    # to different databases.\n    #\n    # For example, suppose that you have 5 models, with the following hierarchy:\n    #\n    #   class Author < ActiveRecord::Base\n    #   end\n    #\n    #   class BankAccount < ActiveRecord::Base\n    #   end\n    #\n    #   class Book < ActiveRecord::Base\n    #     establish_connection \"library_db\"\n    #   end\n    #\n    #   class ScaryBook < Book\n    #   end\n    #\n    #   class GoodBook < Book\n    #   end\n    #\n    # And a database.yml that looked like this:\n    #\n    #   development:\n    #     database: my_application\n    #     host: localhost\n    #\n    #   library_db:\n    #     database: library\n    #     host: some.library.org\n    #\n    # Your primary database in the development environment is \"my_application\"\n    # but the Book model connects to a separate database called \"library_db\"\n    # (this can even be a database on a different machine).\n    #\n    # Book, ScaryBook and GoodBook will all use the same connection pool to\n    # \"library_db\" while Author, BankAccount, and any other models you create\n    # will use the default connection pool to \"my_application\".\n    #\n    # The various connection pools are managed by a single instance of\n    # ConnectionHandler accessible via ActiveRecord::Base.connection_handler.\n    # All Active Record models use this handler to determine the connection pool that they\n    # should use.\n\n      def establish_connection(owner, spec)\n        @class_to_pool.clear\n        raise RuntimeError, \"Anonymous class is not allowed.\" unless owner.name\n        owner_to_pool[owner.name] = ConnectionAdapters::ConnectionPool.new(spec)\n      end\n\n\n\n\nConnectionAdapter\n\n    # Connection pool base class for managing Active Record database\n    # connections.\n    #\n    # == Introduction\n    #\n    # A connection pool synchronizes thread access to a limited number of\n    # database connections. The basic idea is that each thread checks out a\n    # database connection from the pool, uses that connection, and checks the\n    # connection back in. ConnectionPool is completely thread-safe, and will\n    # ensure that a connection cannot be used by two threads at the same time,\n    # as long as ConnectionPool's contract is correctly followed. It will also\n    # handle cases in which there are more threads than connections: if all\n    # connections have been checked out, and a thread tries to checkout a\n    # connection anyway, then ConnectionPool will wait until some other thread\n    # has checked in a connection.\n    #\n    # == Obtaining (checking out) a connection\n    #\n    # Connections can be obtained and used from a connection pool in several\n    # ways:\n    #\n    # 1. Simply use ActiveRecord::Base.connection as with Active Record 2.1 and\n    #    earlier (pre-connection-pooling). Eventually, when you're done with\n    #    the connection(s) and wish it to be returned to the pool, you call\n    #    ActiveRecord::Base.clear_active_connections!. This will be the\n    #    default behavior for Active Record when used in conjunction with\n    #    Action Pack's request handling cycle.\n    # 2. Manually check out a connection from the pool with\n    #    ActiveRecord::Base.connection_pool.checkout. You are responsible for\n    #    returning this connection to the pool when finished by calling\n    #    ActiveRecord::Base.connection_pool.checkin(connection).\n    # 3. Use ActiveRecord::Base.connection_pool.with_connection(&block), which\n    #    obtains a connection, yields it as the sole argument to the block,\n    #    and returns it to the pool after the block completes.\n    #\n    # Connections in the pool are actually AbstractAdapter objects (or objects\n    # compatible with AbstractAdapter's interface).\n    #\n    # == Options\n    #\n    # There are several connection-pooling-related options that you can add to\n    # your database connection configuration:\n    #\n    # * +pool+: number indicating size of connection pool (default 5)\n    # * +checkout_timeout+: number of seconds to block and wait for a connection\n    #   before giving up and raising a timeout error (default 5 seconds).\n    # * +reaping_frequency+: frequency in seconds to periodically run the\n    #   Reaper, which attempts to find and recover connections from dead\n    #   threads, which can occur if a programmer forgets to close a\n    #   connection at the end of a thread or a thread dies unexpectedly.\n    #   Regardless of this setting, the Reaper will be invoked before every\n    #   blocking wait. (Default nil, which means don't schedule the Reaper).\n\n\n      # Creates a new ConnectionPool object. +spec+ is a ConnectionSpecification\n      # object which describes database connection information (e.g. adapter,\n      # host name, username, password, etc), as well as the maximum size for\n      # this ConnectionPool.\n      #\n      # The default ConnectionPool maximum size is 5.\n      def initialize(spec)\n        super()\n\n        @spec = spec\n\n        @checkout_timeout = (spec.config[:checkout_timeout] && spec.config[:checkout_timeout].to_f) || 5\n        @reaper  = Reaper.new self, spec.config[:reaping_frequency]\n        @reaper.run\n\n        # default max pool size to 5\n        @size = (spec.config[:pool] && spec.config[:pool].to_i) || 5\n\n        # The cache of reserved connections mapped to threads\n        @reserved_connections = ThreadSafe::Cache.new(:initial_capacity => @size)\n\n        @connections         = []\n        @automatic_reconnect = true\n\n        @available = Queue.new self\n      end\n\n\n\n\nConnectionAdapters\n\n      # Every +frequency+ seconds, the reaper will call +reap+ on +pool+.\n      # A reaper instantiated with a nil frequency will never reap the\n      # connection pool.\n      #\n      # Configure the frequency by setting \"reaping_frequency\" in your\n      # database yaml file.\n      class Reaper\n        attr_reader :pool, :frequency\n\n        def initialize(pool, frequency)\n          @pool      = pool\n          @frequency = frequency\n        end\n\n        def run\n          return unless frequency\n          Thread.new(frequency, pool) { |t, p|\n            while true\n              sleep t\n              p.reap\n            end\n          }\n        end\n      end\n\n\n\n\nConnectionAdapters\n\n      # Threadsafe, fair, FIFO queue.  Meant to be used by ConnectionPool\n      # with which it shares a Monitor.  But could be a generic Queue.\n      #\n      # The Queue in stdlib's 'thread' could replace this class except\n      # stdlib's doesn't support waiting with a timeout.\n      class Queue\n        def initialize(lock = Monitor.new)\n          @lock = lock\n          @cond = @lock.new_cond\n          @num_waiting = 0\n          @queue = []\n        end\n\n\n\n\nUsing connection\n\nQuerying#find_by_sql\n    def find_by_sql(sql, binds = [])\n      result_set = connection.select_all(sanitize_sql(sql), \"#{name} Load\", binds)\n      column_types = result_set.column_types.dup\n      columns_hash.each_key { |k| column_types.delete k }\n      message_bus = ActiveSupport::Notifications.instrumenter\n\n      payload = {\n        record_count: result_set.length,\n        class_name: name\n      }\n\n      message_bus.instrument('instantiation.active_record', payload) do\n        result_set.map { |record| instantiate(record, column_types) }\n      end\n    end\n\n\n\nConnectionAdapters\n      # Retrieve the connection associated with the current thread, or call\n      # #checkout to obtain one if necessary.\n      #\n      # #connection can be called any number of times; the connection is\n      # held in a hash keyed by the thread id.\n      def connection\n        # this is correctly done double-checked locking\n        # (ThreadSafe::Cache's lookups have volatile semantics)\n        @reserved_connections[current_connection_id] || synchronize do\n          @reserved_connections[current_connection_id] ||= checkout\n        end\n      end\n\n\n\nConnectionAdapters\n      # Check-out a database connection from the pool, indicating that you want\n      # to use it. You should call #checkin when you no longer need this.\n      #\n      # This is done by either returning and leasing existing connection, or by\n      # creating a new connection and leasing it.\n      #\n      # If all connections are leased and the pool is at capacity (meaning the\n      # number of currently leased connections is greater than or equal to the\n      # size limit set), an ActiveRecord::ConnectionTimeoutError exception will be raised.\n      #\n      # Returns: an AbstractAdapter object.\n      #\n      # Raises:\n      # - ConnectionTimeoutError: no connection can be obtained from the pool.\n      def checkout\n        synchronize do\n          conn = acquire_connection\n          conn.lease\n          checkout_and_verify(conn)\n        end\n      end\n\n\n\nConnectionAdapters\n      # Acquire a connection by one of 1) immediately removing one\n      # from the queue of available connections, 2) creating a new\n      # connection if the pool is not at capacity, 3) waiting on the\n      # queue for a connection to become available.\n      #\n      # Raises:\n      # - ConnectionTimeoutError if a connection could not be acquired\n      def acquire_connection\n        if conn = @available.poll\n          conn\n        elsif @connections.size < @size\n          checkout_new_connection\n        else\n          reap\n          @available.poll(@checkout_timeout)\n        end\n      end\n\n\n\nConnectionAdapters\n      def checkout_new_connection\n        raise ConnectionNotEstablished unless @automatic_reconnect\n\n        c = new_connection\n        c.pool = self\n        @connections << c\n        c\n      end\n\n\n\nConnectionAdapsers\n      def new_connection\n        Base.send(spec.adapter_method, spec.config)\n      end\n\n\n\nConnectionHandling#mysql2_connection\n    # Establishes a connection to the database that's used by all Active Record objects.\n    def mysql2_connection(config)\n      config = config.symbolize_keys\n\n      config[:username] = 'root' if config[:username].nil?\n\n      if Mysql2::Client.const_defined? :FOUND_ROWS\n        config[:flags] = Mysql2::Client::FOUND_ROWS\n      end\n\n      client = Mysql2::Client.new(config)\n      options = [config[:host], config[:username], config[:password], config[:database], config[:port], config[:socket], 0]\n      ConnectionAdapters::Mysql2Adapter.new(client, logger, options, config)\n    rescue Mysql2::Error => error\n      if error.message.include?(\"Unknown database\")\n        raise ActiveRecord::NoDatabaseError.new(error.message, error)\n      else\n        raise\n      end\n    end\n  end\n\n\n\nConnectionAdapters\n        # Remove the head of the queue.\n        #\n        # If +timeout+ is not given, remove and return the head the\n        # queue if the number of available elements is strictly\n        # greater than the number of threads currently waiting (that\n        # is, don't jump ahead in line).  Otherwise, return nil.\n        #\n        # If +timeout+ is given, block if there is no element\n        # available, waiting up to +timeout+ seconds for an element to\n        # become available.\n        #\n        # Raises:\n        # - ConnectionTimeoutError if +timeout+ is given and no element\n        # becomes available within +timeout+ seconds,\n        def poll(timeout = nil)\n          synchronize do\n            if timeout\n              no_wait_poll || wait_poll(timeout)\n            else\n              no_wait_poll\n            end\n          end\n        end\n\n\n\nConnectionAdapters\n        # Remove and return the head the queue if the number of\n        # available elements is strictly greater than the number of\n        # threads currently waiting.  Otherwise, return nil.\n        def no_wait_poll\n          remove if can_remove_no_wait?\n        end\n\n\n\nConnectionAdapters\n        # A thread can remove an element from the queue without\n        # waiting if and only if the number of currently available\n        # connections is strictly greater than the number of waiting\n        # threads.\n        def can_remove_no_wait?\n          @queue.size > @num_waiting\n        end\n\n\n\nConnectionAdapters\n        # Removes and returns the head of the queue if possible, or nil.\n        def remove\n          @queue.shift\n        end\n\n\n\nConnectionPool\n      def checkout_and_verify(c)\n        c._run_checkout_callbacks do\n          c.verify!\n        end\n        c\n      end\n\n\n\nConnectionAdapters\n      # Returns an ActiveRecord::Result instance.\n      def select_all(arel, name = nil, binds = [])\n        arel, binds = binds_from_relation arel, binds\n        select(to_sql(arel, binds), name, binds)\n      end\n\n\n\n## Establish connection\n\n```ruby:ConnectionHandling#establish_connection\n\n    def establish_connection(spec = nil)\n      spec     ||= DEFAULT_ENV.call.to_sym\n      resolver =   ConnectionAdapters::ConnectionSpecification::Resolver.new configurations\n      spec     =   resolver.spec(spec)\n\n      unless respond_to?(spec.adapter_method)\n        raise AdapterNotFound, \"database configuration specifies nonexistent #{spec.config[:adapter]} adapter\"\n      end\n\n      remove_connection\n      connection_handler.establish_connection self, spec\n    end\n    \n```\n\n```ruby:ConnectionHandling\n\n    RAILS_ENV   = -> { (Rails.env if defined?(Rails)) || ENV[\"RAILS_ENV\"] || ENV[\"RACK_ENV\"] }\n    DEFAULT_ENV = -> { RAILS_ENV.call || \"default_env\" }\n    \n```\n\n```ruby:ActiveRecord::Core.configurations\n\n$ pp configurations\n\n{\"default\"=>\n  {\"adapter\"=>\"mysql2\",\n   \"encoding\"=>\"utf8\",\n   \"reconnect\"=>false,\n   \"pool\"=>5,\n   \"username\"=>\"root\",\n   \"password\"=>nil},\n \"development\"=>\n  {\"adapter\"=>\"mysql2\",\n   \"encoding\"=>\"utf8\",\n   \"reconnect\"=>false,\n   \"pool\"=>5,\n   \"username\"=>\"root\",\n   \"password\"=>nil,\n   \"database\"=>\"hogehoge_development\"},\n ...  \n \n```\n\n```ruby:ConnectionAdapter::ConnectionSpecification::Resolver#spec\n\n        def spec(config)\n          spec = resolve(config).symbolize_keys\n\n          raise(AdapterNotSpecified, \"database configuration does not specify adapter\") unless spec.key?(:adapter)\n\n          path_to_adapter = \"active_record/connection_adapters/#{spec[:adapter]}_adapter\"\n          begin\n            require path_to_adapter\n          rescue Gem::LoadError => e\n            raise Gem::LoadError, \"Specified '#{spec[:adapter]}' for database adapter, but the gem is not loaded. Add `gem '#{e.name}'` to your Gemfile (and ensure its version is at the minimum required by ActiveRecord).\"\n          rescue LoadError => e\n            raise LoadError, \"Could not load '#{path_to_adapter}'. Make sure that the adapter in config/database.yml is valid. If you use an adapter other than 'mysql', 'mysql2', 'postgresql' or 'sqlite3' add the necessary adapter gem to the Gemfile.\", e.backtrace\n          end\n\n          adapter_method = \"#{spec[:adapter]}_connection\"\n          ConnectionSpecification.new(spec, adapter_method)\n        end\n```\n\n\n```ruby:ConnectionAdapter::ConnectionSpecification#initialize\n      \n      def initialize(config, adapter_method)\n        @config, @adapter_method = config, adapter_method\n      end\n      \n```\n\n```ruby:ActiveRecord::Core.connection_handler\n\n      def self.connection_handler\n        ActiveRecord::RuntimeRegistry.connection_handler || default_connection_handler\n      end\n      \n```\n\n```ruby:ActiveRecord::RuntimeRegistry\n  # This is a thread locals registry for Active Record. For example:\n  #\n  #   ActiveRecord::RuntimeRegistry.connection_handler\n  #\n  # returns the connection handler local to the current thread.\n  #\n  # See the documentation of <tt>ActiveSupport::PerThreadRegistry</tt>\n  # for further details.\n  class RuntimeRegistry # :nodoc:\n    extend ActiveSupport::PerThreadRegistry\n\n    attr_accessor :connection_handler, :sql_runtime, :connection_id\n\n    [:connection_handler, :sql_runtime, :connection_id].each do |val|\n      class_eval %{ def self.#{val}; instance.#{val}; end }, __FILE__, __LINE__\n      class_eval %{ def self.#{val}=(x); instance.#{val}=x; end }, __FILE__, __LINE__\n    end\n  end\n```\n\n```ruby:ConnectionAdapter::ConnectionHandler#establish_connection\n\n    # ConnectionHandler is a collection of ConnectionPool objects. It is used\n    # for keeping separate connection pools for Active Record models that connect\n    # to different databases.\n    #\n    # For example, suppose that you have 5 models, with the following hierarchy:\n    #\n    #   class Author < ActiveRecord::Base\n    #   end\n    #\n    #   class BankAccount < ActiveRecord::Base\n    #   end\n    #\n    #   class Book < ActiveRecord::Base\n    #     establish_connection \"library_db\"\n    #   end\n    #\n    #   class ScaryBook < Book\n    #   end\n    #\n    #   class GoodBook < Book\n    #   end\n    #\n    # And a database.yml that looked like this:\n    #\n    #   development:\n    #     database: my_application\n    #     host: localhost\n    #\n    #   library_db:\n    #     database: library\n    #     host: some.library.org\n    #\n    # Your primary database in the development environment is \"my_application\"\n    # but the Book model connects to a separate database called \"library_db\"\n    # (this can even be a database on a different machine).\n    #\n    # Book, ScaryBook and GoodBook will all use the same connection pool to\n    # \"library_db\" while Author, BankAccount, and any other models you create\n    # will use the default connection pool to \"my_application\".\n    #\n    # The various connection pools are managed by a single instance of\n    # ConnectionHandler accessible via ActiveRecord::Base.connection_handler.\n    # All Active Record models use this handler to determine the connection pool that they\n    # should use.\n\n      def establish_connection(owner, spec)\n        @class_to_pool.clear\n        raise RuntimeError, \"Anonymous class is not allowed.\" unless owner.name\n        owner_to_pool[owner.name] = ConnectionAdapters::ConnectionPool.new(spec)\n      end\n      \n```\n\n```ruby:ConnectionAdapter::ConnectionPool#initialize\n\n    # Connection pool base class for managing Active Record database\n    # connections.\n    #\n    # == Introduction\n    #\n    # A connection pool synchronizes thread access to a limited number of\n    # database connections. The basic idea is that each thread checks out a\n    # database connection from the pool, uses that connection, and checks the\n    # connection back in. ConnectionPool is completely thread-safe, and will\n    # ensure that a connection cannot be used by two threads at the same time,\n    # as long as ConnectionPool's contract is correctly followed. It will also\n    # handle cases in which there are more threads than connections: if all\n    # connections have been checked out, and a thread tries to checkout a\n    # connection anyway, then ConnectionPool will wait until some other thread\n    # has checked in a connection.\n    #\n    # == Obtaining (checking out) a connection\n    #\n    # Connections can be obtained and used from a connection pool in several\n    # ways:\n    #\n    # 1. Simply use ActiveRecord::Base.connection as with Active Record 2.1 and\n    #    earlier (pre-connection-pooling). Eventually, when you're done with\n    #    the connection(s) and wish it to be returned to the pool, you call\n    #    ActiveRecord::Base.clear_active_connections!. This will be the\n    #    default behavior for Active Record when used in conjunction with\n    #    Action Pack's request handling cycle.\n    # 2. Manually check out a connection from the pool with\n    #    ActiveRecord::Base.connection_pool.checkout. You are responsible for\n    #    returning this connection to the pool when finished by calling\n    #    ActiveRecord::Base.connection_pool.checkin(connection).\n    # 3. Use ActiveRecord::Base.connection_pool.with_connection(&block), which\n    #    obtains a connection, yields it as the sole argument to the block,\n    #    and returns it to the pool after the block completes.\n    #\n    # Connections in the pool are actually AbstractAdapter objects (or objects\n    # compatible with AbstractAdapter's interface).\n    #\n    # == Options\n    #\n    # There are several connection-pooling-related options that you can add to\n    # your database connection configuration:\n    #\n    # * +pool+: number indicating size of connection pool (default 5)\n    # * +checkout_timeout+: number of seconds to block and wait for a connection\n    #   before giving up and raising a timeout error (default 5 seconds).\n    # * +reaping_frequency+: frequency in seconds to periodically run the\n    #   Reaper, which attempts to find and recover connections from dead\n    #   threads, which can occur if a programmer forgets to close a\n    #   connection at the end of a thread or a thread dies unexpectedly.\n    #   Regardless of this setting, the Reaper will be invoked before every\n    #   blocking wait. (Default nil, which means don't schedule the Reaper).\n\n\n      # Creates a new ConnectionPool object. +spec+ is a ConnectionSpecification\n      # object which describes database connection information (e.g. adapter,\n      # host name, username, password, etc), as well as the maximum size for\n      # this ConnectionPool.\n      #\n      # The default ConnectionPool maximum size is 5.\n      def initialize(spec)\n        super()\n\n        @spec = spec\n\n        @checkout_timeout = (spec.config[:checkout_timeout] && spec.config[:checkout_timeout].to_f) || 5\n        @reaper  = Reaper.new self, spec.config[:reaping_frequency]\n        @reaper.run\n\n        # default max pool size to 5\n        @size = (spec.config[:pool] && spec.config[:pool].to_i) || 5\n\n        # The cache of reserved connections mapped to threads\n        @reserved_connections = ThreadSafe::Cache.new(:initial_capacity => @size)\n\n        @connections         = []\n        @automatic_reconnect = true\n\n        @available = Queue.new self\n      end\n      \n```\n\n```ruby:ConnectionAdapters::ConnectionPool::Reaper\n\n      # Every +frequency+ seconds, the reaper will call +reap+ on +pool+.\n      # A reaper instantiated with a nil frequency will never reap the\n      # connection pool.\n      #\n      # Configure the frequency by setting \"reaping_frequency\" in your\n      # database yaml file.\n      class Reaper\n        attr_reader :pool, :frequency\n\n        def initialize(pool, frequency)\n          @pool      = pool\n          @frequency = frequency\n        end\n\n        def run\n          return unless frequency\n          Thread.new(frequency, pool) { |t, p|\n            while true\n              sleep t\n              p.reap\n            end\n          }\n        end\n      end\n\n```\n\n```ruby:ConnectionAdapters::ConnectionPool::Queue\n\n      # Threadsafe, fair, FIFO queue.  Meant to be used by ConnectionPool\n      # with which it shares a Monitor.  But could be a generic Queue.\n      #\n      # The Queue in stdlib's 'thread' could replace this class except\n      # stdlib's doesn't support waiting with a timeout.\n      class Queue\n        def initialize(lock = Monitor.new)\n          @lock = lock\n          @cond = @lock.new_cond\n          @num_waiting = 0\n          @queue = []\n        end\n\n```\n\n## Using connection\n\n```ruby:Querying#find_by_sql\n    def find_by_sql(sql, binds = [])\n      result_set = connection.select_all(sanitize_sql(sql), \"#{name} Load\", binds)\n      column_types = result_set.column_types.dup\n      columns_hash.each_key { |k| column_types.delete k }\n      message_bus = ActiveSupport::Notifications.instrumenter\n\n      payload = {\n        record_count: result_set.length,\n        class_name: name\n      }\n\n      message_bus.instrument('instantiation.active_record', payload) do\n        result_set.map { |record| instantiate(record, column_types) }\n      end\n    end\n```\n\n```ruby:ConnectionAdapters::ConnectionPool#connection\n      # Retrieve the connection associated with the current thread, or call\n      # #checkout to obtain one if necessary.\n      #\n      # #connection can be called any number of times; the connection is\n      # held in a hash keyed by the thread id.\n      def connection\n        # this is correctly done double-checked locking\n        # (ThreadSafe::Cache's lookups have volatile semantics)\n        @reserved_connections[current_connection_id] || synchronize do\n          @reserved_connections[current_connection_id] ||= checkout\n        end\n      end\n```\n\n```ruby:ConnectionAdapters::ConnectionPool#checkout\n      # Check-out a database connection from the pool, indicating that you want\n      # to use it. You should call #checkin when you no longer need this.\n      #\n      # This is done by either returning and leasing existing connection, or by\n      # creating a new connection and leasing it.\n      #\n      # If all connections are leased and the pool is at capacity (meaning the\n      # number of currently leased connections is greater than or equal to the\n      # size limit set), an ActiveRecord::ConnectionTimeoutError exception will be raised.\n      #\n      # Returns: an AbstractAdapter object.\n      #\n      # Raises:\n      # - ConnectionTimeoutError: no connection can be obtained from the pool.\n      def checkout\n        synchronize do\n          conn = acquire_connection\n          conn.lease\n          checkout_and_verify(conn)\n        end\n      end\n```\n\n```ruby:ConnectionAdapters::ConnectionPool#acquire_connection\n      # Acquire a connection by one of 1) immediately removing one\n      # from the queue of available connections, 2) creating a new\n      # connection if the pool is not at capacity, 3) waiting on the\n      # queue for a connection to become available.\n      #\n      # Raises:\n      # - ConnectionTimeoutError if a connection could not be acquired\n      def acquire_connection\n        if conn = @available.poll\n          conn\n        elsif @connections.size < @size\n          checkout_new_connection\n        else\n          reap\n          @available.poll(@checkout_timeout)\n        end\n      end\n```\n\n```ruby:ConnectionAdapters::ConnectionPool#checkout_new_connection\n      def checkout_new_connection\n        raise ConnectionNotEstablished unless @automatic_reconnect\n\n        c = new_connection\n        c.pool = self\n        @connections << c\n        c\n      end\n```\n\n```ruby:ConnectionAdapsers::ConnectionPool#new_connection\n      def new_connection\n        Base.send(spec.adapter_method, spec.config)\n      end\n```\n\n```ruby:ConnectionHandling#mysql2_connection\n    # Establishes a connection to the database that's used by all Active Record objects.\n    def mysql2_connection(config)\n      config = config.symbolize_keys\n\n      config[:username] = 'root' if config[:username].nil?\n\n      if Mysql2::Client.const_defined? :FOUND_ROWS\n        config[:flags] = Mysql2::Client::FOUND_ROWS\n      end\n\n      client = Mysql2::Client.new(config)\n      options = [config[:host], config[:username], config[:password], config[:database], config[:port], config[:socket], 0]\n      ConnectionAdapters::Mysql2Adapter.new(client, logger, options, config)\n    rescue Mysql2::Error => error\n      if error.message.include?(\"Unknown database\")\n        raise ActiveRecord::NoDatabaseError.new(error.message, error)\n      else\n        raise\n      end\n    end\n  end\n```\n\n```ruby:ConnectionAdapters::ConnectionPool::Queue#pool\n        # Remove the head of the queue.\n        #\n        # If +timeout+ is not given, remove and return the head the\n        # queue if the number of available elements is strictly\n        # greater than the number of threads currently waiting (that\n        # is, don't jump ahead in line).  Otherwise, return nil.\n        #\n        # If +timeout+ is given, block if there is no element\n        # available, waiting up to +timeout+ seconds for an element to\n        # become available.\n        #\n        # Raises:\n        # - ConnectionTimeoutError if +timeout+ is given and no element\n        # becomes available within +timeout+ seconds,\n        def poll(timeout = nil)\n          synchronize do\n            if timeout\n              no_wait_poll || wait_poll(timeout)\n            else\n              no_wait_poll\n            end\n          end\n        end\n```\n\n```ruby:ConnectionAdapters::ConnectionPool::Queue#no_wait_poll\n        # Remove and return the head the queue if the number of\n        # available elements is strictly greater than the number of\n        # threads currently waiting.  Otherwise, return nil.\n        def no_wait_poll\n          remove if can_remove_no_wait?\n        end\n```\n\n```ruby:ConnectionAdapters::ConnectionPool::Queue#can_remove_no_wait?\n        # A thread can remove an element from the queue without\n        # waiting if and only if the number of currently available\n        # connections is strictly greater than the number of waiting\n        # threads.\n        def can_remove_no_wait?\n          @queue.size > @num_waiting\n        end\n```\n\n```ruby:ConnectionAdapters::ConnectionPool::Queue#remove\n        # Removes and returns the head of the queue if possible, or nil.\n        def remove\n          @queue.shift\n        end\n```\n\n```ruby:ConnectionPool::ConnectionAdapter#checkout_and_verify\n      def checkout_and_verify(c)\n        c._run_checkout_callbacks do\n          c.verify!\n        end\n        c\n      end\n```\n\n```ruby:ConnectionAdapters::DatabaseStatemants#select_all\n      # Returns an ActiveRecord::Result instance.\n      def select_all(arel, name = nil, binds = [])\n        arel, binds = binds_from_relation arel, binds\n        select(to_sql(arel, binds), name, binds)\n      end\n```\n", "tags": ["ActiveRecord"]}