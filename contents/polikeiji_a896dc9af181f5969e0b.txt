{"context": "\u30e1\u30e2\u3002\nUnity\u30d5\u30a9\u30fc\u30e9\u30e0\u304b\u3089\u306e\u30b3\u30d4\u30da\u3002\nAdjustable Character Spacing - free script\n\u65b0\u3057\u3044uGUI\u3067\u306f\u3001\u6587\u5b57\u9593\u306e\u8abf\u6574\u306f\u3067\u304d\u306a\u3044\u307f\u305f\u3044\u3067\u3001\u4e0a\u306e\u30d5\u30a9\u30fc\u30e9\u30e0\u3067\u306f\u3001\u30c6\u30ad\u30b9\u30c8\u306b\u9069\u7528\u3059\u308b\u30b9\u30af\u30ea\u30d7\u30c8\u3092\u89aa\u5207\u306a\u4eba\u304c\u66f8\u3044\u3066\u304f\u308c\u3066\u308b\u3002\nUnity\u306e\u30d0\u30fc\u30b8\u30e7\u30f3\u3054\u3068\u3067\u3001\u4ed5\u69d8\u304c\u9055\u3046\u307f\u305f\u3044\u3067\u3001\u4e0a\u306e\u30d5\u30a9\u30fc\u30e9\u30e0\u3067\u306f\u3001Unity\u306e\u30d0\u30fc\u30b8\u30e7\u30f3\u304c\u4e0a\u304c\u308b\u5ea6\u306b\u3001\u30b9\u30af\u30ea\u30d7\u30c8\u3092\u4fee\u6b63\u3057\u3066\u304f\u308c\u3066\u308b\u3002\n\u4ee5\u4e0b\u30015.3.3\u3067\u52d5\u304b\u305b\u305f\u30b9\u30af\u30ea\u30d7\u30c8\uff08\u8ee2\u8f09\u5143\uff09\u3002\nAssets\u306b\u30a4\u30f3\u30dd\u30fc\u30c8\u3057\u3066\u3001\u30c6\u30ad\u30b9\u30c8\u306b\u30c9\u30e9\u30c3\u30b0\u3057\u3066\u3001\u30b3\u30f3\u30dd\u30fc\u30cd\u30f3\u30c8\u3068\u3057\u3066\u8ffd\u52a0\u3059\u308c\u3070\u4f7f\u3048\u308b\u3002\nusing UnityEngine;\nusing System.Collections;\nusing System.Collections.Generic;\nusing System.Text.RegularExpressions;\n\n/*\nhttp://forum.unity3d.com/threads/adjustable-character-spacing-free-script.288277/\nUnity 5.1 and 5.2.2+ compatible\nProduces an simple tracking/letter-spacing effect on UI Text components.\nSet the spacing parameter to adjust letter spacing.\n\nNegative values cuddle the text up tighter than normal. Go too far and it'll look odd.\nPositive values spread the text out more than normal. This will NOT respect the text area you've defined.\nZero spacing will present the font with no changes.\nRelies on counting off characters in your Text component's text property and\nmatching those against the quads passed in via the verts array. This is really\nrather primative, but I can't see any better way at the moment. It means that\nall sorts of things can break the effect...\n\nThis component should be placed higher in component list than any other vertex\nmodifiers that alter the total number of verticies. Eg, place this ABOVE Shadow\nor Outline effects. If you don't, the outline/shadow won't match the position\nof the letters properly. If you place the outline/shadow effect second however,\nit will just work on the altered vertices from this component, and function\nas expected.\n\nThis component works best if you don't allow text to automatically wrap. It also\nblows up outside of the given text area. Basically, it's a cheap and dirty effect,\nnot a clever text layout engine. It can't affect how Unity chooses to break up\nyour lines. If you manually use line breaks however, it should detect those and\nfunction more or less as you'd expect.\n\nThe spacing parameter is measured in pixels multiplied by the font size. This was\nchosen such that when you adjust the font size, it does not change the visual spacing\nthat you've dialed in. There's also a scale factor of 1/100 in this number to\nbring it into a comfortable adjustable range. There's no limit on this parameter,\nbut obviously some values will look quite strange.\n\nNow component works with RichText. You need to remember to turn on RichText via the checkbox (text.supportRichText)\nand turn on component's [useRichText] checkbox.\n*/\n\nnamespace UnityEngine.UI\n{\n    [AddComponentMenu(\"UI/Effects/Letter Spacing\", 15)]\n    #if UNITY_5 && !UNITY_5_0 && !UNITY_5_1\n    public class LetterSpacing : BaseMeshEffect\n    #else\n    public class LetterSpacing : BaseVertexEffect\n    #endif\n    {\n        private const string SupportedTagRegexPattersn = @\"<b>|</b>|<i>|</i>|<size=.*?>|</size>|<color=.*?>|</color>|<material=.*?>|</material>\";\n        [SerializeField]\n        private bool useRichText;\n\n        [SerializeField]\n        private float m_spacing = 0f;\n\n        protected LetterSpacing() { }\n\n        #if UNITY_EDITOR\n        protected override void OnValidate()\n        {\n            spacing = m_spacing;\n            base.OnValidate();\n        }\n        #endif\n\n        public float spacing\n        {\n            get { return m_spacing; }\n            set\n            {\n                if (m_spacing == value) return;\n                m_spacing = value;\n                if (graphic != null) graphic.SetVerticesDirty();\n            }\n        }\n\n        #if UNITY_5 && !UNITY_5_0 && !UNITY_5_1\n\n        /**\n        * Note: Unity 5.2.1 ModifyMesh(Mesh mesh) used VertexHelper.FillMesh(mesh);\n        * For performance reasons, ModifyMesh(VertexHelper vh) was introduced\n        * @see http://forum.unity3d.com/threads/unity-5-2-ui-performance-seems-much-worse.353650/\n        */\n        public override void ModifyMesh(VertexHelper vh)\n        {\n            if (!this.IsActive())\n                return;\n\n            List<UIVertex> list = new List<UIVertex>();\n            vh.GetUIVertexStream(list);\n\n            ModifyVertices(list);\n\n            vh.Clear();\n            vh.AddUIVertexTriangleStream(list);\n        }\n\n        public void ModifyVertices(List<UIVertex> verts)\n        {\n            if (!IsActive()) return;\n\n            Text text = GetComponent<Text>();\n            if (text == null)\n            {\n                Debug.LogWarning(\"LetterSpacing: Missing Text component\");\n                return;\n            }\n\n            string[] lines = text.text.Split('\\n');\n            Vector3 pos;\n            float letterOffset = spacing * (float)text.fontSize / 100f;\n            float alignmentFactor = 0;\n            int glyphIdx = 0;  // character index from the beginning of the text, including RichText tags and line breaks\n\n            bool isRichText = useRichText && text.supportRichText;\n            IEnumerator matchedTagCollection = null; // when using RichText this will collect all tags (index, length, value)\n            Match currentMatchedTag = null;\n\n            switch (text.alignment)\n            {\n            case TextAnchor.LowerLeft:\n            case TextAnchor.MiddleLeft:\n            case TextAnchor.UpperLeft:\n                alignmentFactor = 0f;\n                break;\n\n            case TextAnchor.LowerCenter:\n            case TextAnchor.MiddleCenter:\n            case TextAnchor.UpperCenter:\n                alignmentFactor = 0.5f;\n                break;\n\n            case TextAnchor.LowerRight:\n            case TextAnchor.MiddleRight:\n            case TextAnchor.UpperRight:\n                alignmentFactor = 1f;\n                break;\n            }\n\n            for (int lineIdx = 0; lineIdx < lines.Length; lineIdx++)\n            {\n                string line = lines[lineIdx];\n                int lineLength = line.Length;\n\n                if (isRichText)\n                {\n                    matchedTagCollection = GetRegexMatchedTagCollection(line, out lineLength);\n                    currentMatchedTag = null;\n                    if (matchedTagCollection.MoveNext())\n                    {\n                        currentMatchedTag = (Match)matchedTagCollection.Current;\n                    }\n                }\n\n                float lineOffset = (lineLength - 1) * letterOffset * alignmentFactor;\n\n                for (int charIdx = 0, actualCharIndex = 0; charIdx < line.Length; charIdx++, actualCharIndex++)\n                {\n                    if (isRichText)\n                    {\n                        if (currentMatchedTag != null && currentMatchedTag.Index == charIdx)\n                        {\n                            // skip matched RichText tag\n                            charIdx += currentMatchedTag.Length - 1;  // -1 because next iteration will increment charIdx\n                            actualCharIndex--;                        // tag is not an actual character, cancel counter increment on this iteration\n                            glyphIdx += currentMatchedTag.Length;     // glyph index is not incremented in for loop so skip entire length\n\n                            // prepare next tag to detect\n                            currentMatchedTag = null;\n                            if (matchedTagCollection.MoveNext())\n                            {\n                                currentMatchedTag = (Match)matchedTagCollection.Current;\n                            }\n\n                            continue;\n                        }\n                    }\n\n                    int idx1 = glyphIdx * 6 + 0;\n                    int idx2 = glyphIdx * 6 + 1;\n                    int idx3 = glyphIdx * 6 + 2;\n                    int idx4 = glyphIdx * 6 + 3;\n                    int idx5 = glyphIdx * 6 + 4;\n                    int idx6 = glyphIdx * 6 + 5;\n\n                    // Check for truncated text (doesn't generate verts for all characters)\n                    if (idx6 > verts.Count - 1) return;\n\n                    UIVertex vert1 = verts[idx1];\n                    UIVertex vert2 = verts[idx2];\n                    UIVertex vert3 = verts[idx3];\n                    UIVertex vert4 = verts[idx4];\n                    UIVertex vert5 = verts[idx5];\n                    UIVertex vert6 = verts[idx6];\n\n                    pos = Vector3.right * (letterOffset * actualCharIndex - lineOffset);\n\n                    vert1.position += pos;\n                    vert2.position += pos;\n                    vert3.position += pos;\n                    vert4.position += pos;\n                    vert5.position += pos;\n                    vert6.position += pos;\n\n                    verts[idx1] = vert1;\n                    verts[idx2] = vert2;\n                    verts[idx3] = vert3;\n                    verts[idx4] = vert4;\n                    verts[idx5] = vert5;\n                    verts[idx6] = vert6;\n\n                    glyphIdx++;\n                }\n\n                // Offset for carriage return character that still generates verts\n                glyphIdx++;\n            }\n        }\n        #else\n        public override void ModifyVertices(List<UIVertex> verts)\n        {\n        if (!IsActive()) return;\n\n        Text text = GetComponent<Text>();\n        if (text == null)\n        {\n        Debug.LogWarning(\"LetterSpacing: Missing Text component\");\n        return;\n        }\n\n        string[] lines = text.text.Split('\\n');\n        Vector3  pos;\n        float    letterOffset    = spacing * (float)text.fontSize / 100f;\n        float    alignmentFactor = 0;\n        int      glyphIdx        = 0;\n\n        bool isRichText = useRichText && text.supportRichText;\n        IEnumerator matchedTagCollection = null; //when using RichText this will collect all tags (index, length, value)\n        Match currentMatchedTag = null;\n\n        switch (text.alignment)\n        {\n        case TextAnchor.LowerLeft:\n        case TextAnchor.MiddleLeft:\n        case TextAnchor.UpperLeft:\n        alignmentFactor = 0f;\n        break;\n\n        case TextAnchor.LowerCenter:\n        case TextAnchor.MiddleCenter:\n        case TextAnchor.UpperCenter:\n        alignmentFactor = 0.5f;\n        break;\n\n        case TextAnchor.LowerRight:\n        case TextAnchor.MiddleRight:\n        case TextAnchor.UpperRight:\n        alignmentFactor = 1f;\n        break;\n        }\n\n        for (int lineIdx = 0; lineIdx < lines.Length; lineIdx++)\n        {\n        string line = lines[lineIdx];\n\n        int lineLength = line.Length;\n\n        if (isRichText)\n        {\n        matchedTagCollection = GetRegexMatchedTagCollection(line, out lineLength);\n        currentMatchedTag = null;\n        if (matchedTagCollection.MoveNext())\n        {\n        currentMatchedTag = (Match)matchedTagCollection.Current;\n        }\n        }\n\n        float lineOffset = (lineLength -1) * letterOffset * alignmentFactor;\n\n        for (int charIdx = 0, charPositionIndex =0; charIdx < line.Length; charIdx++, charPositionIndex++)\n        {\n        if (isRichText)\n        {\n        if (currentMatchedTag != null && currentMatchedTag.Index == charIdx)\n        {\n        // skip rich text tag matched (-1 because each iteration already increments the indices)\n        charIdx += currentMatchedTag.Length - 1;\n        glyphIdx += currentMatchedTag.Length - 1;\n        charPositionIndex--;\n        currentMatchedTag = null;\n        if (matchedTagCollection.MoveNext())\n        {\n        currentMatchedTag = (Match)matchedTagCollection.Current;\n        }\n        }\n        }\n\n        int idx1 = glyphIdx * 4 + 0;\n        int idx2 = glyphIdx * 4 + 1;\n        int idx3 = glyphIdx * 4 + 2;\n        int idx4 = glyphIdx * 4 + 3;\n\n        // Check for truncated text (doesn't generate verts for all characters)\n        if (idx4 > verts.Count - 1) return;\n\n        UIVertex vert1 = verts[idx1];\n        UIVertex vert2 = verts[idx2];\n        UIVertex vert3 = verts[idx3];\n        UIVertex vert4 = verts[idx4];\n\n        pos = Vector3.right * (letterOffset * charPositionIndex - lineOffset);\n\n        vert1.position += pos;\n        vert2.position += pos;\n        vert3.position += pos;\n        vert4.position += pos;\n\n        verts[idx1] = vert1;\n        verts[idx2] = vert2;\n        verts[idx3] = vert3;\n        verts[idx4] = vert4;\n\n        glyphIdx++;\n        }\n\n        // Offset for carriage return character that still generates verts\n        glyphIdx++;\n        }\n        }\n        #endif\n\n        private IEnumerator GetRegexMatchedTagCollection(string line, out int lineLengthWithoutTags)\n        {\n            MatchCollection matchedTagCollection = Regex.Matches(line,SupportedTagRegexPattersn);\n            lineLengthWithoutTags = 0;\n            int tagsLength = 0;\n\n            if (matchedTagCollection.Count > 0)\n            {\n                foreach (Match matchedTag in matchedTagCollection)\n                {\n                    tagsLength += matchedTag.Length;\n                }\n            }\n            lineLengthWithoutTags = line.Length - tagsLength;\n            return matchedTagCollection.GetEnumerator();\n        }\n    }\n}\n\n\u30e1\u30e2\u3002\n\nUnity\u30d5\u30a9\u30fc\u30e9\u30e0\u304b\u3089\u306e\u30b3\u30d4\u30da\u3002\n[Adjustable Character Spacing - free script](http://forum.unity3d.com/threads/adjustable-character-spacing-free-script.288277/)\n\n\u65b0\u3057\u3044uGUI\u3067\u306f\u3001\u6587\u5b57\u9593\u306e\u8abf\u6574\u306f\u3067\u304d\u306a\u3044\u307f\u305f\u3044\u3067\u3001\u4e0a\u306e\u30d5\u30a9\u30fc\u30e9\u30e0\u3067\u306f\u3001\u30c6\u30ad\u30b9\u30c8\u306b\u9069\u7528\u3059\u308b\u30b9\u30af\u30ea\u30d7\u30c8\u3092\u89aa\u5207\u306a\u4eba\u304c\u66f8\u3044\u3066\u304f\u308c\u3066\u308b\u3002\n\nUnity\u306e\u30d0\u30fc\u30b8\u30e7\u30f3\u3054\u3068\u3067\u3001\u4ed5\u69d8\u304c\u9055\u3046\u307f\u305f\u3044\u3067\u3001\u4e0a\u306e\u30d5\u30a9\u30fc\u30e9\u30e0\u3067\u306f\u3001Unity\u306e\u30d0\u30fc\u30b8\u30e7\u30f3\u304c\u4e0a\u304c\u308b\u5ea6\u306b\u3001\u30b9\u30af\u30ea\u30d7\u30c8\u3092\u4fee\u6b63\u3057\u3066\u304f\u308c\u3066\u308b\u3002\n\n\u4ee5\u4e0b\u30015.3.3\u3067\u52d5\u304b\u305b\u305f\u30b9\u30af\u30ea\u30d7\u30c8\uff08[\u8ee2\u8f09\u5143](http://forum.unity3d.com/threads/adjustable-character-spacing-free-script.288277/#post-2524726)\uff09\u3002\n`Assets`\u306b\u30a4\u30f3\u30dd\u30fc\u30c8\u3057\u3066\u3001\u30c6\u30ad\u30b9\u30c8\u306b\u30c9\u30e9\u30c3\u30b0\u3057\u3066\u3001\u30b3\u30f3\u30dd\u30fc\u30cd\u30f3\u30c8\u3068\u3057\u3066\u8ffd\u52a0\u3059\u308c\u3070\u4f7f\u3048\u308b\u3002\n\n```csharp\nusing UnityEngine;\nusing System.Collections;\nusing System.Collections.Generic;\nusing System.Text.RegularExpressions;\n\n/*\nhttp://forum.unity3d.com/threads/adjustable-character-spacing-free-script.288277/\nUnity 5.1 and 5.2.2+ compatible\nProduces an simple tracking/letter-spacing effect on UI Text components.\nSet the spacing parameter to adjust letter spacing.\n\nNegative values cuddle the text up tighter than normal. Go too far and it'll look odd.\nPositive values spread the text out more than normal. This will NOT respect the text area you've defined.\nZero spacing will present the font with no changes.\nRelies on counting off characters in your Text component's text property and\nmatching those against the quads passed in via the verts array. This is really\nrather primative, but I can't see any better way at the moment. It means that\nall sorts of things can break the effect...\n\nThis component should be placed higher in component list than any other vertex\nmodifiers that alter the total number of verticies. Eg, place this ABOVE Shadow\nor Outline effects. If you don't, the outline/shadow won't match the position\nof the letters properly. If you place the outline/shadow effect second however,\nit will just work on the altered vertices from this component, and function\nas expected.\n\nThis component works best if you don't allow text to automatically wrap. It also\nblows up outside of the given text area. Basically, it's a cheap and dirty effect,\nnot a clever text layout engine. It can't affect how Unity chooses to break up\nyour lines. If you manually use line breaks however, it should detect those and\nfunction more or less as you'd expect.\n\nThe spacing parameter is measured in pixels multiplied by the font size. This was\nchosen such that when you adjust the font size, it does not change the visual spacing\nthat you've dialed in. There's also a scale factor of 1/100 in this number to\nbring it into a comfortable adjustable range. There's no limit on this parameter,\nbut obviously some values will look quite strange.\n\nNow component works with RichText. You need to remember to turn on RichText via the checkbox (text.supportRichText)\nand turn on component's [useRichText] checkbox.\n*/\n\nnamespace UnityEngine.UI\n{\n\t[AddComponentMenu(\"UI/Effects/Letter Spacing\", 15)]\n\t#if UNITY_5 && !UNITY_5_0 && !UNITY_5_1\n\tpublic class LetterSpacing : BaseMeshEffect\n\t#else\n\tpublic class LetterSpacing : BaseVertexEffect\n\t#endif\n\t{\n\t\tprivate const string SupportedTagRegexPattersn = @\"<b>|</b>|<i>|</i>|<size=.*?>|</size>|<color=.*?>|</color>|<material=.*?>|</material>\";\n\t\t[SerializeField]\n\t\tprivate bool useRichText;\n\n\t\t[SerializeField]\n\t\tprivate float m_spacing = 0f;\n\n\t\tprotected LetterSpacing() { }\n\n\t\t#if UNITY_EDITOR\n\t\tprotected override void OnValidate()\n\t\t{\n\t\t\tspacing = m_spacing;\n\t\t\tbase.OnValidate();\n\t\t}\n\t\t#endif\n\n\t\tpublic float spacing\n\t\t{\n\t\t\tget { return m_spacing; }\n\t\t\tset\n\t\t\t{\n\t\t\t\tif (m_spacing == value) return;\n\t\t\t\tm_spacing = value;\n\t\t\t\tif (graphic != null) graphic.SetVerticesDirty();\n\t\t\t}\n\t\t}\n\n\t\t#if UNITY_5 && !UNITY_5_0 && !UNITY_5_1\n\n\t\t/**\n        * Note: Unity 5.2.1 ModifyMesh(Mesh mesh) used VertexHelper.FillMesh(mesh);\n        * For performance reasons, ModifyMesh(VertexHelper vh) was introduced\n        * @see http://forum.unity3d.com/threads/unity-5-2-ui-performance-seems-much-worse.353650/\n        */\n\t\tpublic override void ModifyMesh(VertexHelper vh)\n\t\t{\n\t\t\tif (!this.IsActive())\n\t\t\t\treturn;\n\n\t\t\tList<UIVertex> list = new List<UIVertex>();\n\t\t\tvh.GetUIVertexStream(list);\n\n\t\t\tModifyVertices(list);\n\n\t\t\tvh.Clear();\n\t\t\tvh.AddUIVertexTriangleStream(list);\n\t\t}\n\n\t\tpublic void ModifyVertices(List<UIVertex> verts)\n\t\t{\n\t\t\tif (!IsActive()) return;\n\n\t\t\tText text = GetComponent<Text>();\n\t\t\tif (text == null)\n\t\t\t{\n\t\t\t\tDebug.LogWarning(\"LetterSpacing: Missing Text component\");\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tstring[] lines = text.text.Split('\\n');\n\t\t\tVector3 pos;\n\t\t\tfloat letterOffset = spacing * (float)text.fontSize / 100f;\n\t\t\tfloat alignmentFactor = 0;\n\t\t\tint glyphIdx = 0;  // character index from the beginning of the text, including RichText tags and line breaks\n\n\t\t\tbool isRichText = useRichText && text.supportRichText;\n\t\t\tIEnumerator matchedTagCollection = null; // when using RichText this will collect all tags (index, length, value)\n\t\t\tMatch currentMatchedTag = null;\n\n\t\t\tswitch (text.alignment)\n\t\t\t{\n\t\t\tcase TextAnchor.LowerLeft:\n\t\t\tcase TextAnchor.MiddleLeft:\n\t\t\tcase TextAnchor.UpperLeft:\n\t\t\t\talignmentFactor = 0f;\n\t\t\t\tbreak;\n\n\t\t\tcase TextAnchor.LowerCenter:\n\t\t\tcase TextAnchor.MiddleCenter:\n\t\t\tcase TextAnchor.UpperCenter:\n\t\t\t\talignmentFactor = 0.5f;\n\t\t\t\tbreak;\n\n\t\t\tcase TextAnchor.LowerRight:\n\t\t\tcase TextAnchor.MiddleRight:\n\t\t\tcase TextAnchor.UpperRight:\n\t\t\t\talignmentFactor = 1f;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tfor (int lineIdx = 0; lineIdx < lines.Length; lineIdx++)\n\t\t\t{\n\t\t\t\tstring line = lines[lineIdx];\n\t\t\t\tint lineLength = line.Length;\n\n\t\t\t\tif (isRichText)\n\t\t\t\t{\n\t\t\t\t\tmatchedTagCollection = GetRegexMatchedTagCollection(line, out lineLength);\n\t\t\t\t\tcurrentMatchedTag = null;\n\t\t\t\t\tif (matchedTagCollection.MoveNext())\n\t\t\t\t\t{\n\t\t\t\t\t\tcurrentMatchedTag = (Match)matchedTagCollection.Current;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfloat lineOffset = (lineLength - 1) * letterOffset * alignmentFactor;\n\n\t\t\t\tfor (int charIdx = 0, actualCharIndex = 0; charIdx < line.Length; charIdx++, actualCharIndex++)\n\t\t\t\t{\n\t\t\t\t\tif (isRichText)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (currentMatchedTag != null && currentMatchedTag.Index == charIdx)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t// skip matched RichText tag\n\t\t\t\t\t\t\tcharIdx += currentMatchedTag.Length - 1;  // -1 because next iteration will increment charIdx\n\t\t\t\t\t\t\tactualCharIndex--;\t\t\t\t\t\t  // tag is not an actual character, cancel counter increment on this iteration\n\t\t\t\t\t\t\tglyphIdx += currentMatchedTag.Length;\t  // glyph index is not incremented in for loop so skip entire length\n\n\t\t\t\t\t\t\t// prepare next tag to detect\n\t\t\t\t\t\t\tcurrentMatchedTag = null;\n\t\t\t\t\t\t\tif (matchedTagCollection.MoveNext())\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tcurrentMatchedTag = (Match)matchedTagCollection.Current;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tint idx1 = glyphIdx * 6 + 0;\n\t\t\t\t\tint idx2 = glyphIdx * 6 + 1;\n\t\t\t\t\tint idx3 = glyphIdx * 6 + 2;\n\t\t\t\t\tint idx4 = glyphIdx * 6 + 3;\n\t\t\t\t\tint idx5 = glyphIdx * 6 + 4;\n\t\t\t\t\tint idx6 = glyphIdx * 6 + 5;\n\n\t\t\t\t\t// Check for truncated text (doesn't generate verts for all characters)\n\t\t\t\t\tif (idx6 > verts.Count - 1) return;\n\n\t\t\t\t\tUIVertex vert1 = verts[idx1];\n\t\t\t\t\tUIVertex vert2 = verts[idx2];\n\t\t\t\t\tUIVertex vert3 = verts[idx3];\n\t\t\t\t\tUIVertex vert4 = verts[idx4];\n\t\t\t\t\tUIVertex vert5 = verts[idx5];\n\t\t\t\t\tUIVertex vert6 = verts[idx6];\n\n\t\t\t\t\tpos = Vector3.right * (letterOffset * actualCharIndex - lineOffset);\n\n\t\t\t\t\tvert1.position += pos;\n\t\t\t\t\tvert2.position += pos;\n\t\t\t\t\tvert3.position += pos;\n\t\t\t\t\tvert4.position += pos;\n\t\t\t\t\tvert5.position += pos;\n\t\t\t\t\tvert6.position += pos;\n\n\t\t\t\t\tverts[idx1] = vert1;\n\t\t\t\t\tverts[idx2] = vert2;\n\t\t\t\t\tverts[idx3] = vert3;\n\t\t\t\t\tverts[idx4] = vert4;\n\t\t\t\t\tverts[idx5] = vert5;\n\t\t\t\t\tverts[idx6] = vert6;\n\n\t\t\t\t\tglyphIdx++;\n\t\t\t\t}\n\n\t\t\t\t// Offset for carriage return character that still generates verts\n\t\t\t\tglyphIdx++;\n\t\t\t}\n\t\t}\n\t\t#else\n\t\tpublic override void ModifyVertices(List<UIVertex> verts)\n\t\t{\n\t\tif (!IsActive()) return;\n\n\t\tText text = GetComponent<Text>();\n\t\tif (text == null)\n\t\t{\n\t\tDebug.LogWarning(\"LetterSpacing: Missing Text component\");\n\t\treturn;\n\t\t}\n\n\t\tstring[] lines = text.text.Split('\\n');\n\t\tVector3  pos;\n\t\tfloat    letterOffset    = spacing * (float)text.fontSize / 100f;\n\t\tfloat    alignmentFactor = 0;\n\t\tint      glyphIdx        = 0;\n\n\t\tbool isRichText = useRichText && text.supportRichText;\n\t\tIEnumerator matchedTagCollection = null; //when using RichText this will collect all tags (index, length, value)\n\t\tMatch currentMatchedTag = null;\n\n\t\tswitch (text.alignment)\n\t\t{\n\t\tcase TextAnchor.LowerLeft:\n\t\tcase TextAnchor.MiddleLeft:\n\t\tcase TextAnchor.UpperLeft:\n\t\talignmentFactor = 0f;\n\t\tbreak;\n\n\t\tcase TextAnchor.LowerCenter:\n\t\tcase TextAnchor.MiddleCenter:\n\t\tcase TextAnchor.UpperCenter:\n\t\talignmentFactor = 0.5f;\n\t\tbreak;\n\n\t\tcase TextAnchor.LowerRight:\n\t\tcase TextAnchor.MiddleRight:\n\t\tcase TextAnchor.UpperRight:\n\t\talignmentFactor = 1f;\n\t\tbreak;\n\t\t}\n\n\t\tfor (int lineIdx = 0; lineIdx < lines.Length; lineIdx++)\n\t\t{\n\t\tstring line = lines[lineIdx];\n\n\t\tint lineLength = line.Length;\n\n\t\tif (isRichText)\n\t\t{\n\t\tmatchedTagCollection = GetRegexMatchedTagCollection(line, out lineLength);\n\t\tcurrentMatchedTag = null;\n\t\tif (matchedTagCollection.MoveNext())\n\t\t{\n\t\tcurrentMatchedTag = (Match)matchedTagCollection.Current;\n\t\t}\n\t\t}\n\n\t\tfloat lineOffset = (lineLength -1) * letterOffset * alignmentFactor;\n\n\t\tfor (int charIdx = 0, charPositionIndex =0; charIdx < line.Length; charIdx++, charPositionIndex++)\n\t\t{\n\t\tif (isRichText)\n\t\t{\n\t\tif (currentMatchedTag != null && currentMatchedTag.Index == charIdx)\n\t\t{\n\t\t// skip rich text tag matched (-1 because each iteration already increments the indices)\n\t\tcharIdx += currentMatchedTag.Length - 1;\n\t\tglyphIdx += currentMatchedTag.Length - 1;\n\t\tcharPositionIndex--;\n\t\tcurrentMatchedTag = null;\n\t\tif (matchedTagCollection.MoveNext())\n\t\t{\n\t\tcurrentMatchedTag = (Match)matchedTagCollection.Current;\n\t\t}\n\t\t}\n\t\t}\n\n\t\tint idx1 = glyphIdx * 4 + 0;\n\t\tint idx2 = glyphIdx * 4 + 1;\n\t\tint idx3 = glyphIdx * 4 + 2;\n\t\tint idx4 = glyphIdx * 4 + 3;\n\n\t\t// Check for truncated text (doesn't generate verts for all characters)\n\t\tif (idx4 > verts.Count - 1) return;\n\n\t\tUIVertex vert1 = verts[idx1];\n\t\tUIVertex vert2 = verts[idx2];\n\t\tUIVertex vert3 = verts[idx3];\n\t\tUIVertex vert4 = verts[idx4];\n\n\t\tpos = Vector3.right * (letterOffset * charPositionIndex - lineOffset);\n\n\t\tvert1.position += pos;\n\t\tvert2.position += pos;\n\t\tvert3.position += pos;\n\t\tvert4.position += pos;\n\n\t\tverts[idx1] = vert1;\n\t\tverts[idx2] = vert2;\n\t\tverts[idx3] = vert3;\n\t\tverts[idx4] = vert4;\n\n\t\tglyphIdx++;\n\t\t}\n\n\t\t// Offset for carriage return character that still generates verts\n\t\tglyphIdx++;\n\t\t}\n\t\t}\n\t\t#endif\n\n\t\tprivate IEnumerator GetRegexMatchedTagCollection(string line, out int lineLengthWithoutTags)\n\t\t{\n\t\t\tMatchCollection matchedTagCollection = Regex.Matches(line,SupportedTagRegexPattersn);\n\t\t\tlineLengthWithoutTags = 0;\n\t\t\tint tagsLength = 0;\n\n\t\t\tif (matchedTagCollection.Count > 0)\n\t\t\t{\n\t\t\t\tforeach (Match matchedTag in matchedTagCollection)\n\t\t\t\t{\n\t\t\t\t\ttagsLength += matchedTag.Length;\n\t\t\t\t}\n\t\t\t}\n\t\t\tlineLengthWithoutTags = line.Length - tagsLength;\n\t\t\treturn matchedTagCollection.GetEnumerator();\n\t\t}\n\t}\n}\n```\n", "tags": ["Unity", "uGUI"]}