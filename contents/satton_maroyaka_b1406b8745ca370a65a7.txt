{"tags": ["Ruby", "Rails", "ActiveRecord"], "context": " \u3053\u306e\u8a18\u4e8b\u306f\u6700\u7d42\u66f4\u65b0\u65e5\u304b\u30891\u5e74\u4ee5\u4e0a\u304c\u7d4c\u904e\u3057\u3066\u3044\u307e\u3059\u3002\n\nForeigner\n\n\u6982\u8981\nForeigner \u306f migrations \u306b\u5916\u90e8\u30ad\u30fc\u5236\u7d04\u3092(\u4ed8\u52a0|\u524a\u9664)\u3059\u308b\u70ba\u306e\u30e1\u30bd\u30c3\u30c9\u3092\u3061\u3087\u3053\u3063\u3068\u63d0\u4f9b\u3059\u308bgem\u3002\u4e0b\u8a18\u306eDB\u30a2\u30c0\u30d7\u30bf\u3092\u30b5\u30dd\u30fc\u30c8\u3057\u3066\u3044\u308b\u3002\n\nmysql2\npostgres\nsqlite (foreign key methods are a no-op)\n\n\n\u30a4\u30f3\u30b9\u30c8\u30fc\u30eb\nGemfile\u306b\u8ffd\u52a0:\n  gem 'foreigner'\n\n\nAPI\u306e\u4f8b\nForeigner \u306f2\u3064\u306e methods \u3092 migrations \u306b\u8ffd\u52a0\u3059\u308b\u3002\n\nadd_foreign_key(from_table, to_table, options)\nremove_foreign_key(from_table, options)\n\n(Options\u306e\u8a73\u7d30\u306f connection_adapters/abstract/schema_statements.rb\u306b\u8a18\u8f09):\n\u672c\u6587\u672b\u306b\u8a18\u8f09\u3059\u308b\u3002\n\nmodel\u306e\u4f8b\n\n  class Comment < ActiveRecord::Base\n    belongs_to :post\n  end\n\n  class Post < ActiveRecord::Base\n    has_many :comments, dependent: :delete_all\n  end\n\n\n  #Post has many Commnets.\n  #Post\u3092\u524a\u9664\u3059\u308b\u3068\u3001\u305d\u308c\u306b\u7d10\u3065\u304fComments\u3082\u3059\u3079\u3066\u524a\u9664\u3055\u308c\u308b\u3002\n\n\u3053\u306e\u5834\u5408\u3001Comment\u306bPost\u3078\u306e\u5916\u90e8\u30ad\u30fc\u3092\u8a2d\u3051\u308b\u3002\n\nmigration\u306e\u4f8b\nmigration\u306badd_foreign_key\u3092\u8ffd\u8a18\u3002\n  add_foreign_key(:comments, :posts)\n\nmigration\u3067 :dependent \u30aa\u30d7\u30b7\u30e7\u30f3\u3092\u8a18\u8ff0\u3059\u308b\u3068\u3001model\u3067\u306e has_many \u3067dependent:\u30aa\u30d7\u30b7\u30e7\u30f3\u306e\u4ee3\u308f\u308a\u306b\u306a\u308b\u3002\n  add_foreign_key(:comments, :posts, dependent: :delete)\n\ncolumn:\u30aa\u30d7\u30b7\u30e7\u30f3\u3067\u5916\u90e8\u30ad\u30fc\u3068\u306a\u308b\u30ab\u30e9\u30e0\u540d\u3092\u6307\u5b9a\u3059\u308b\u3002\n  add_foreign_key(:comments, :posts, column: 'article_id')\n\n\u3055\u3089\u306b\u3001name:\u30aa\u30d7\u30b7\u30e7\u30f3\u3067\u5236\u7d04\u306b\u5236\u7d04\u540d\u79f0\u3092\u4ed8\u4e0e\u3067\u304d\u308b\u3002\n  add_foreign_key(:comments, :posts, name: 'comment_article_foreign_key')\n\n\u5916\u90e8\u30ad\u30fc\u5236\u7d04\u3092\u524a\u9664\u3059\u308b\u3068\u304d\u306b\u306f\u3001:name\u3067\u3064\u3051\u305f\u5236\u7d04\u540d\u79f0\u3082\u6307\u5b9a\u3059\u308b\u4e8b\u3002\n  remove_foreign_key(:comments, name: 'comment_article_foreign_key')\n\n\n\u30c6\u30fc\u30d6\u30eb\u30e1\u30bd\u30c3\u30c9\u306e\u5909\u66f4\nForeigner \u306fActiverecord\u306ecreate_table \u3068 change_table\u306b\u30e1\u30bd\u30c3\u30c9\u3092\u8ffd\u52a0\u3059\u308b\u3002\nforeign key\u306e\u8ffd\u52a0\n  create_table :products do |t|\n    t.string :name\n    t.integer :factory_id\n    t.foreign_key :factories\n    #t.foreign_key :\u5916\u90e8\u53c2\u7167\u5148\u306emodel\u540d\n  end\n\n  change_table :comments do |t|\n    t.foreign_key :posts, dependent: :delete\n  end\n\n\u4e0d\u8981\u306a\u5916\u90e8\u30ad\u30fc\u3092\u524a\u9664:\n  change_table :comments do |t|\n    t.remove_foreign_key :users\n  end\n\n\nDatabase-specific options\n\u500b\u5225\u306eDBMS\u306e\u30aa\u30d7\u30b7\u30e7\u30f3\u6307\u5b9a\u306b\u306f\u3001foreigner\u306f\u5bfe\u5fdc\u3059\u308b\u4e88\u5b9a\u306f\u306a\u3044\u3002 :options\u306b\u3066\u5404\u81ea\u76f4\u63a5\u8a18\u8ff0\u3059\u308b\u4e8b\u3002\n  add_foreign_key(:comments, :posts, options: 'ON UPDATE DEFERRED')\n\n\n\u30e9\u30a4\u30bb\u30f3\u30b9\n\u4e0b\u8a18\u306e\u901a\u308a\u3002\nCopyright (c) 2012 Matthew Higgins, released under the MIT license\n\nforeigner/connection_adapters/abstract/schema_statements.rb\nmodule Foreigner\n  module ConnectionAdapters\n    module SchemaStatements\n      def self.included(base)\n        base::AbstractAdapter.class_eval do\n          include Foreigner::ConnectionAdapters::AbstractAdapter\n        end\n      end\n    end\n\n    module AbstractAdapter\n      def create_table(table_name, *args, &block)\n        definition = nil\n        super do |td|\n          definition = td # This is my trick to get the definition\n          block.call(td) unless block.nil?\n        end\n        definition.foreign_keys.each do |to_table, options_list|\n          options_list.each do |options|\n            add_foreign_key(table_name, to_table, options)\n          end\n        end\n      end\n\n      def supports_foreign_keys?\n        false\n      end\n\n      # Checks to see if a foreign key exists on a table for a given constraint.\n      #\n      #   # Check a foreign key exists\n      #   foreign_key_exists?(:suppliers, :companies)\n      #\n      #   # Check a foreign key with a custom name exists\n      #   foreign_key_exists?(:suppliers, name: \"fk_company_id\")\n      #\n      #   # Check a foreign key on a column\n      #   foreign_key_exists?(:suppliers, column: \"company_id\")\n      #\n      def foreign_key_exists?(table_name, options)\n      end\n\n      # Adds a new foreign key to the +from_table+, referencing the primary key of +to_table+\n      #\n      # The foreign key will be named after the from and to tables unless you pass\n      # <tt>:name</tt> as an option.\n      #\n      # ===== Examples\n      # ====== Creating a foreign key\n      #  add_foreign_key(:comments, :posts)\n      # generates\n      #  ALTER TABLE `comments` ADD CONSTRAINT\n      #     `comments_post_id_fk` FOREIGN KEY (`post_id`) REFERENCES `posts` (`id`)\n      #\n      # ====== Creating a named foreign key\n      #  add_foreign_key(:comments, :posts, name: 'comments_belongs_to_posts')\n      # generates\n      #  ALTER TABLE `comments` ADD CONSTRAINT\n      #     `comments_belongs_to_posts` FOREIGN KEY (`post_id`) REFERENCES `posts` (`id`)\n      #\n      # ====== Creating a cascading foreign_key on a custom column\n      #  add_foreign_key(:people, :people, column: 'best_friend_id', dependent: :nullify)\n      # generates\n      #  ALTER TABLE `people` ADD CONSTRAINT\n      #     `people_best_friend_id_fk` FOREIGN KEY (`best_friend_id`) REFERENCES `people` (`id`)\n      #     ON DELETE SET NULL\n      #\n      # === Supported options\n      # [:column]\n      #   Specify the column name on the from_table that references the to_table. By default this is guessed\n      #   to be the singular name of the to_table with \"_id\" suffixed. So a to_table of :posts will use \"post_id\"\n      #   as the default <tt>:column</tt>.\n      # [:primary_key]\n      #   Specify the column name on the to_table that is referenced by this foreign key. By default this is\n      #   assumed to be \"id\".\n      # [:name]\n      #   Specify the name of the foreign key constraint. This defaults to use from_table and foreign key column.\n      # [:dependent]\n      #   If set to <tt>:delete</tt>, the associated records in from_table are deleted when records in to_table table are deleted.\n      #   If set to <tt>:nullify</tt>, the foreign key column is set to +NULL+.\n      # [:options]\n      #   Any extra options you want appended to the foreign key definition.\n      def add_foreign_key(from_table, to_table, options = {})\n      end\n\n      # Remove the given foreign key from the table.\n      #\n      # ===== Examples\n      # ====== Remove the suppliers_company_id_fk in the suppliers table.\n      #   remove_foreign_key :suppliers, :companies\n      # ====== Remove the foreign key named accounts_branch_id_fk in the accounts table.\n      #   remove_foreign_key :accounts, column: :branch_id\n      # ====== Remove the foreign key named party_foreign_key in the accounts table.\n      #   remove_foreign_key :accounts, name: :party_foreign_key\n      def remove_foreign_key(from_table, options)\n      end\n\n      # Return the foreign keys for the schema_dumper\n      def foreign_keys(table_name)\n        []\n      end\n    end\n  end\nend\n\n# Foreigner\n## \u6982\u8981\n\nForeigner \u306f migrations \u306b\u5916\u90e8\u30ad\u30fc\u5236\u7d04\u3092(\u4ed8\u52a0|\u524a\u9664)\u3059\u308b\u70ba\u306e\u30e1\u30bd\u30c3\u30c9\u3092\u3061\u3087\u3053\u3063\u3068\u63d0\u4f9b\u3059\u308bgem\u3002\u4e0b\u8a18\u306eDB\u30a2\u30c0\u30d7\u30bf\u3092\u30b5\u30dd\u30fc\u30c8\u3057\u3066\u3044\u308b\u3002\n\n* mysql2\n* postgres\n* sqlite (foreign key methods are a no-op)\n\n\n## \u30a4\u30f3\u30b9\u30c8\u30fc\u30eb\n\nGemfile\u306b\u8ffd\u52a0:\n\n```ruby\n  gem 'foreigner'\n```\n## API\u306e\u4f8b\n\nForeigner \u306f2\u3064\u306e methods \u3092 migrations \u306b\u8ffd\u52a0\u3059\u308b\u3002\n\n* `add_foreign_key(from_table, to_table, options)`\n* `remove_foreign_key(from_table, options)`\n\n(Options\u306e\u8a73\u7d30\u306f `connection_adapters/abstract/schema_statements.rb`\u306b\u8a18\u8f09):\n\u672c\u6587\u672b\u306b\u8a18\u8f09\u3059\u308b\u3002\n\n##model\u306e\u4f8b\n\n```ruby\n\n  class Comment < ActiveRecord::Base\n    belongs_to :post\n  end\n\n  class Post < ActiveRecord::Base\n    has_many :comments, dependent: :delete_all\n  end\n\n\n  #Post has many Commnets.\n  #Post\u3092\u524a\u9664\u3059\u308b\u3068\u3001\u305d\u308c\u306b\u7d10\u3065\u304fComments\u3082\u3059\u3079\u3066\u524a\u9664\u3055\u308c\u308b\u3002\n```  \n\n\u3053\u306e\u5834\u5408\u3001Comment\u306bPost\u3078\u306e\u5916\u90e8\u30ad\u30fc\u3092\u8a2d\u3051\u308b\u3002\n\n##migration\u306e\u4f8b\nmigration\u306b`add_foreign_key`\u3092\u8ffd\u8a18\u3002\n\n```ruby\n  add_foreign_key(:comments, :posts)\n```\n\nmigration\u3067 `:dependent` \u30aa\u30d7\u30b7\u30e7\u30f3\u3092\u8a18\u8ff0\u3059\u308b\u3068\u3001model\u3067\u306e `has_many` \u3067`dependent:`\u30aa\u30d7\u30b7\u30e7\u30f3\u306e\u4ee3\u308f\u308a\u306b\u306a\u308b\u3002\n\n```ruby\n  add_foreign_key(:comments, :posts, dependent: :delete)\n```\n\n`column:`\u30aa\u30d7\u30b7\u30e7\u30f3\u3067\u5916\u90e8\u30ad\u30fc\u3068\u306a\u308b\u30ab\u30e9\u30e0\u540d\u3092\u6307\u5b9a\u3059\u308b\u3002\n\n\n```ruby\n  add_foreign_key(:comments, :posts, column: 'article_id')\n```\n\n\u3055\u3089\u306b\u3001`name:`\u30aa\u30d7\u30b7\u30e7\u30f3\u3067\u5236\u7d04\u306b\u5236\u7d04\u540d\u79f0\u3092\u4ed8\u4e0e\u3067\u304d\u308b\u3002\n\n```ruby\n  add_foreign_key(:comments, :posts, name: 'comment_article_foreign_key')\n```\n\u5916\u90e8\u30ad\u30fc\u5236\u7d04\u3092\u524a\u9664\u3059\u308b\u3068\u304d\u306b\u306f\u3001`:name`\u3067\u3064\u3051\u305f\u5236\u7d04\u540d\u79f0\u3082\u6307\u5b9a\u3059\u308b\u4e8b\u3002\n\n```ruby\n  remove_foreign_key(:comments, name: 'comment_article_foreign_key')\n```\n\n## \u30c6\u30fc\u30d6\u30eb\u30e1\u30bd\u30c3\u30c9\u306e\u5909\u66f4\n\nForeigner \u306fActiverecord\u306e`create_table` \u3068 `change_table`\u306b\u30e1\u30bd\u30c3\u30c9\u3092\u8ffd\u52a0\u3059\u308b\u3002\n\n`foreign key`\u306e\u8ffd\u52a0\n\n```ruby\n  create_table :products do |t|\n    t.string :name\n    t.integer :factory_id\n    t.foreign_key :factories\n    #t.foreign_key :\u5916\u90e8\u53c2\u7167\u5148\u306emodel\u540d\n  end\n```\n\n```ruby\n  change_table :comments do |t|\n    t.foreign_key :posts, dependent: :delete\n  end\n```\n\n\u4e0d\u8981\u306a\u5916\u90e8\u30ad\u30fc\u3092\u524a\u9664:\n\n```ruby\n  change_table :comments do |t|\n    t.remove_foreign_key :users\n  end\n```\n## Database-specific options\n\n\u500b\u5225\u306eDBMS\u306e\u30aa\u30d7\u30b7\u30e7\u30f3\u6307\u5b9a\u306b\u306f\u3001foreigner\u306f\u5bfe\u5fdc\u3059\u308b\u4e88\u5b9a\u306f\u306a\u3044\u3002 `:options`\u306b\u3066\u5404\u81ea\u76f4\u63a5\u8a18\u8ff0\u3059\u308b\u4e8b\u3002\n\n```ruby\n  add_foreign_key(:comments, :posts, options: 'ON UPDATE DEFERRED')\n```\n\n## \u30e9\u30a4\u30bb\u30f3\u30b9\n\u4e0b\u8a18\u306e\u901a\u308a\u3002\nCopyright (c) 2012 Matthew Higgins, released under the MIT license\n\n##foreigner/connection_adapters/abstract/schema_statements.rb\n\n```rb\nmodule Foreigner\n  module ConnectionAdapters\n    module SchemaStatements\n      def self.included(base)\n        base::AbstractAdapter.class_eval do\n          include Foreigner::ConnectionAdapters::AbstractAdapter\n        end\n      end\n    end\n\n    module AbstractAdapter\n      def create_table(table_name, *args, &block)\n        definition = nil\n        super do |td|\n          definition = td # This is my trick to get the definition\n          block.call(td) unless block.nil?\n        end\n        definition.foreign_keys.each do |to_table, options_list|\n          options_list.each do |options|\n            add_foreign_key(table_name, to_table, options)\n          end\n        end\n      end\n\n      def supports_foreign_keys?\n        false\n      end\n\n      # Checks to see if a foreign key exists on a table for a given constraint.\n      #\n      #   # Check a foreign key exists\n      #   foreign_key_exists?(:suppliers, :companies)\n      #\n      #   # Check a foreign key with a custom name exists\n      #   foreign_key_exists?(:suppliers, name: \"fk_company_id\")\n      #\n      #   # Check a foreign key on a column\n      #   foreign_key_exists?(:suppliers, column: \"company_id\")\n      #\n      def foreign_key_exists?(table_name, options)\n      end\n\n      # Adds a new foreign key to the +from_table+, referencing the primary key of +to_table+\n      #\n      # The foreign key will be named after the from and to tables unless you pass\n      # <tt>:name</tt> as an option.\n      #\n      # ===== Examples\n      # ====== Creating a foreign key\n      #  add_foreign_key(:comments, :posts)\n      # generates\n      #  ALTER TABLE `comments` ADD CONSTRAINT\n      #     `comments_post_id_fk` FOREIGN KEY (`post_id`) REFERENCES `posts` (`id`)\n      #\n      # ====== Creating a named foreign key\n      #  add_foreign_key(:comments, :posts, name: 'comments_belongs_to_posts')\n      # generates\n      #  ALTER TABLE `comments` ADD CONSTRAINT\n      #     `comments_belongs_to_posts` FOREIGN KEY (`post_id`) REFERENCES `posts` (`id`)\n      #\n      # ====== Creating a cascading foreign_key on a custom column\n      #  add_foreign_key(:people, :people, column: 'best_friend_id', dependent: :nullify)\n      # generates\n      #  ALTER TABLE `people` ADD CONSTRAINT\n      #     `people_best_friend_id_fk` FOREIGN KEY (`best_friend_id`) REFERENCES `people` (`id`)\n      #     ON DELETE SET NULL\n      #\n      # === Supported options\n      # [:column]\n      #   Specify the column name on the from_table that references the to_table. By default this is guessed\n      #   to be the singular name of the to_table with \"_id\" suffixed. So a to_table of :posts will use \"post_id\"\n      #   as the default <tt>:column</tt>.\n      # [:primary_key]\n      #   Specify the column name on the to_table that is referenced by this foreign key. By default this is\n      #   assumed to be \"id\".\n      # [:name]\n      #   Specify the name of the foreign key constraint. This defaults to use from_table and foreign key column.\n      # [:dependent]\n      #   If set to <tt>:delete</tt>, the associated records in from_table are deleted when records in to_table table are deleted.\n      #   If set to <tt>:nullify</tt>, the foreign key column is set to +NULL+.\n      # [:options]\n      #   Any extra options you want appended to the foreign key definition.\n      def add_foreign_key(from_table, to_table, options = {})\n      end\n\n      # Remove the given foreign key from the table.\n      #\n      # ===== Examples\n      # ====== Remove the suppliers_company_id_fk in the suppliers table.\n      #   remove_foreign_key :suppliers, :companies\n      # ====== Remove the foreign key named accounts_branch_id_fk in the accounts table.\n      #   remove_foreign_key :accounts, column: :branch_id\n      # ====== Remove the foreign key named party_foreign_key in the accounts table.\n      #   remove_foreign_key :accounts, name: :party_foreign_key\n      def remove_foreign_key(from_table, options)\n      end\n\n      # Return the foreign keys for the schema_dumper\n      def foreign_keys(table_name)\n        []\n      end\n    end\n  end\nend\n```"}