{"context": "\u4eca\u3055\u3089\u611f\u304c\u5f37\u3044\u304c\uff0c\u95a2\u6570\u578b\u30d7\u30ed\u30b0\u30e9\u30df\u30f3\u30b0Rust\u306e\u30d1\u30bf\u30fc\u30f3\u30de\u30c3\u30c1\u306b\u6163\u308c\u308b\u305f\u3081\u306b\u3084\u3063\u3066\u307f\u305f\uff0e\n\u203b\u30cd\u30bf\u5143\n\nhttp://qiita.com/esumii/items/0eeb30f35c2a9da4ab8a\n\nhttp://qiita.com/nobsun/items/5a88d37745e8d89a154a (Haskell\u7248)\n\n\u62bd\u8c61\u69cb\u6587\u306e\u5b9a\u7fa9\u306f\u4ee5\u4e0b\u306e\u901a\u308a\uff0eBox<T> \u306fC++\u3060\u3068 unique_ptr<T> \u306b\u5bfe\u5fdc\u3059\u308b\u3082\u306e\uff08\u3060\u3068\u5927\u96d1\u628a\u306b\u7406\u89e3\u3057\u3066\u3044\u308b\uff09\uff0e\n#[derive(Clone)]\npub enum Expr {\n    Int(i64),\n    Sub(Box<Expr>, Box<Expr>),\n    If(Box<Expr>, Box<Expr>, Box<Expr>, Box<Expr>),\n    App(Box<Expr>, Box<Expr>),\n    Var(String),\n    Fun(String, Box<Expr>),\n}\n\n\u8a55\u4fa1\u5668\u306e\u5b9f\u88c5\u306f\u6b21\u306e\u3088\u3046\u306b\u306a\u3063\u305f\uff0e\u30d1\u30bf\u30fc\u30f3\u30de\u30c3\u30c1\u304c\u3042\u308b\u304a\u304b\u3052\u3067\u30cd\u30bf\u5143\u3084Haskell\u306b\u3088\u308b\u5b9f\u88c5\u306b\u8fd1\u3044\u5f62\u3067\u8a18\u8ff0\u3067\u304d\u3066\u3044\u308b\u304c\uff0c\u305d\u308c\u3067\u3082\u82e5\u5e72\u884c\u6570\u304c\u591a\u304f\u306a\u3063\u3066\u3057\u307e\u3063\u305f...\nuse Expr::*;\n\npub fn eval(expr: Expr) -> Option<Expr> {\n    match expr {\n        Int(i) => Some(Int(i)),\n\n        Var(_) => None,\n\n        Sub(e1, e2) => {\n            let i = match get!(eval(*e1)) {\n                Int(x) => x,\n                _ => return None,\n            };\n            let j = match get!(eval(*e2)) {\n                Int(x) => x,\n                _ => return None,\n            };\n            Some(Int(i - j))\n        }\n\n        If(e1, e2, e3, e4) => {\n            let i = match get!(eval(*e1)) {\n                Int(x) => x,\n                _ => return None,\n            };\n            let j = match get!(eval(*e2)) {\n                Int(x) => x,\n                _ => return None,\n            };\n            if i <= j {\n                eval(*e3)\n            } else {\n                eval(*e4)\n            }\n        }\n\n        Fun(x, e) => Some(Fun(x, e)),\n\n        App(e1, e2) => {\n            let (x, e) = match get!(eval(*e1)) {\n                Fun(x, e) => (x, e),\n                _ => return None,\n            };\n            let v = get!(eval(*e2));\n            let ee = get!(subst(*e, x, v));\n            eval(ee)\n        }\n    }\n}\n\nfn subst(expr: Expr, x: String, v: Expr) -> Option<Expr> {\n    match expr {\n        Int(i) => Some(Int(i)),\n\n        Var(y) => {\n            if x == y {\n                Some(v)\n            } else {\n                Some(Var(y))\n            }\n        }\n\n        Sub(e1, e2) => {\n            let i = get!(subst(*e1, x.clone(), v.clone()));\n            let j = get!(subst(*e2, x.clone(), v.clone()));\n            Some(Sub(Box::new(i), Box::new(j)))\n        }\n\n        If(e1, e2, e3, e4) => {\n            let i = get!(subst(*e1, x.clone(), v.clone()));\n            let j = get!(subst(*e2, x.clone(), v.clone()));\n            let k = get!(subst(*e3, x.clone(), v.clone()));\n            let l = get!(subst(*e4, x.clone(), v.clone()));\n            Some(If(Box::new(i), Box::new(j), Box::new(k), Box::new(l)))\n        }\n\n        Fun(y, e) => {\n            if x == y {\n                Some(Fun(y, e))\n            } else {\n                Some(Fun(y, Box::new(get!(subst(*e, x, v)))))\n            }\n        }\n\n        App(e1, e2) => {\n            let i = get!(subst(*e1, x.clone(), v.clone()));\n            let j = get!(subst(*e2, x.clone(), v.clone()));\n            Some(App(Box::new(i), Box::new(j)))\n        }\n    }\n}\n\n\u968f\u6240\u3067\u51fa\u3066\u304f\u308b get! \u306f Option<T> \u7528\u306b\u5b9a\u7fa9\u3057\u305f try! \u306e\u3088\u3046\u306b\u4f7f\u3048\u308b\u30de\u30af\u30ed\u3067\u3042\u308a\uff0c\u6b21\u306e\u3088\u3046\u306b\u5b9a\u7fa9\u3057\u305f\uff08Result<T,E> \u4f7f\u3048\u3070\u3044\u3044\u3093\u3058\u3083\uff09\uff0e\nmacro_rules! get (\n    ($e:expr) => (\n        match $e {\n            Some(x) => x,\n            None => return None,\n        }\n    )\n);\n\n\u30c6\u30b9\u30c8\u30b3\u30fc\u30c9\uff0e\nfn main() {\n    let tashizan = _plus(_int(1), _int(2));\n\n    let def_function = _let(\"abs\",\n                            _fun(\"x\", _if(_var(\"x\"), _int(0), _negate(_var(\"x\")), _var(\"x\"))),\n                            _app(_var(\"abs\"), _int(-42)));\n\n    print_eval(\"tashizan\", tashizan);\n    print_eval(\"def_function\", def_function);\n}\n\npub fn _int(i: i64) -> Expr {\n    Int(i)\n}\n\npub fn _var(v: &str) -> Expr {\n    Var(v.to_string())\n}\n\npub fn _sub(e1: Expr, e2: Expr) -> Expr {\n    Sub(Box::new(e1), Box::new(e2))\n}\n\npub fn _if(e1: Expr, e2: Expr, e3: Expr, e4: Expr) -> Expr {\n    If(Box::new(e1), Box::new(e2), Box::new(e3), Box::new(e4))\n}\n\npub fn _app(e1: Expr, e2: Expr) -> Expr {\n    App(Box::new(e1), Box::new(e2))\n}\n\npub fn _fun(v: &str, e: Expr) -> Expr {\n    Fun(v.to_string(), Box::new(e))\n}\n\npub fn _negate(e: Expr) -> Expr {\n    _sub(_int(0), e)\n}\n\npub fn _plus(e1: Expr, e2: Expr) -> Expr {\n    _sub(e1, _negate(e2))\n}\n\npub fn _let(x: &str, e1: Expr, e2: Expr) -> Expr {\n    _app(_fun(x, e2), e1)\n}\n\npub fn print_eval(name: &str, expr: Expr) {\n    print!(\"eval {}: \", name);\n    match eval(expr).unwrap() {\n        Int(i) => println!(\"{}\", i),\n        _ => panic!(\"evaluation failed.!\"),\n    }\n}\n\n\n(\u8ffd\u8a18) \u74b0\u5883\u30fb\u30af\u30ed\u30fc\u30b8\u30e3\u3092\u4f7f\u7528\u3057\u305f\u5834\u5408 \u3082\u3084\u3063\u3066\u307f\u305f\uff0e\nuse std::collections::HashMap;\n\ntype Env = HashMap<String, Value>;\n\n#[derive(Clone)]\npub enum Value {\n    VInt(i64),\n    VClosure(String, Expr, Env),\n}\nuse Value::*;\n\npub fn eval(expr: Expr, env: &Env) -> Result<Value, ()> {\n    match expr {\n        Int(i) => Ok(VInt(i)),\n\n        Var(x) => env.get(&x).cloned().ok_or_else(|| ()),\n\n        Sub(e1, e2) => {\n            let i = match try!(eval(*e1, env)) {\n                VInt(x) => x,\n                _ => return Err(()),\n            };\n            let j = match try!(eval(*e2, env)) {\n                VInt(x) => x,\n                _ => return Err(()),\n            };\n            Ok(VInt(i - j))\n        }\n\n        If(e1, e2, e3, e4) => {\n            let i = match try!(eval(*e1, env)) {\n                VInt(x) => x,\n                _ => return Err(()),\n            };\n            let j = match try!(eval(*e2, env)) {\n                VInt(x) => x,\n                _ => return Err(()),\n            };\n            if i <= j {\n                eval(*e3, env)\n            } else {\n                eval(*e4, env)\n            }\n        }\n\n        Fun(x, e) => Ok(VClosure(x, *e, env.clone())),\n\n        App(e1, e2) => {\n            let (x, e, mut env_) = match try!(eval(*e1, env)) {\n                VClosure(x, e, env) => (x, e, env),\n                _ => return Err(()),\n            };\n            let v = try!(eval(*e2, env));\n            env_.insert(x, v);\n            eval(e, &env_)\n        }\n    }\n}\n\n\u4eca\u3055\u3089\u611f\u304c\u5f37\u3044\u304c\uff0c~~\u95a2\u6570\u578b\u30d7\u30ed\u30b0\u30e9\u30df\u30f3\u30b0~~Rust\u306e\u30d1\u30bf\u30fc\u30f3\u30de\u30c3\u30c1\u306b\u6163\u308c\u308b\u305f\u3081\u306b\u3084\u3063\u3066\u307f\u305f\uff0e\n\n\u203b\u30cd\u30bf\u5143\n\n* http://qiita.com/esumii/items/0eeb30f35c2a9da4ab8a\n* http://qiita.com/nobsun/items/5a88d37745e8d89a154a (Haskell\u7248)\n\n\u62bd\u8c61\u69cb\u6587\u306e\u5b9a\u7fa9\u306f\u4ee5\u4e0b\u306e\u901a\u308a\uff0e`Box<T>` \u306fC++\u3060\u3068 `unique_ptr<T>` \u306b\u5bfe\u5fdc\u3059\u308b\u3082\u306e\uff08\u3060\u3068\u5927\u96d1\u628a\u306b\u7406\u89e3\u3057\u3066\u3044\u308b\uff09\uff0e\n\n```rust\n#[derive(Clone)]\npub enum Expr {\n    Int(i64),\n    Sub(Box<Expr>, Box<Expr>),\n    If(Box<Expr>, Box<Expr>, Box<Expr>, Box<Expr>),\n    App(Box<Expr>, Box<Expr>),\n    Var(String),\n    Fun(String, Box<Expr>),\n}\n```\n\n\u8a55\u4fa1\u5668\u306e\u5b9f\u88c5\u306f\u6b21\u306e\u3088\u3046\u306b\u306a\u3063\u305f\uff0e\u30d1\u30bf\u30fc\u30f3\u30de\u30c3\u30c1\u304c\u3042\u308b\u304a\u304b\u3052\u3067\u30cd\u30bf\u5143\u3084Haskell\u306b\u3088\u308b\u5b9f\u88c5\u306b\u8fd1\u3044\u5f62\u3067\u8a18\u8ff0\u3067\u304d\u3066\u3044\u308b\u304c\uff0c\u305d\u308c\u3067\u3082\u82e5\u5e72\u884c\u6570\u304c\u591a\u304f\u306a\u3063\u3066\u3057\u307e\u3063\u305f...\n\n```rust\nuse Expr::*;\n\npub fn eval(expr: Expr) -> Option<Expr> {\n    match expr {\n        Int(i) => Some(Int(i)),\n\n        Var(_) => None,\n\n        Sub(e1, e2) => {\n            let i = match get!(eval(*e1)) {\n                Int(x) => x,\n                _ => return None,\n            };\n            let j = match get!(eval(*e2)) {\n                Int(x) => x,\n                _ => return None,\n            };\n            Some(Int(i - j))\n        }\n\n        If(e1, e2, e3, e4) => {\n            let i = match get!(eval(*e1)) {\n                Int(x) => x,\n                _ => return None,\n            };\n            let j = match get!(eval(*e2)) {\n                Int(x) => x,\n                _ => return None,\n            };\n            if i <= j {\n                eval(*e3)\n            } else {\n                eval(*e4)\n            }\n        }\n\n        Fun(x, e) => Some(Fun(x, e)),\n\n        App(e1, e2) => {\n            let (x, e) = match get!(eval(*e1)) {\n                Fun(x, e) => (x, e),\n                _ => return None,\n            };\n            let v = get!(eval(*e2));\n            let ee = get!(subst(*e, x, v));\n            eval(ee)\n        }\n    }\n}\n\nfn subst(expr: Expr, x: String, v: Expr) -> Option<Expr> {\n    match expr {\n        Int(i) => Some(Int(i)),\n\n        Var(y) => {\n            if x == y {\n                Some(v)\n            } else {\n                Some(Var(y))\n            }\n        }\n\n        Sub(e1, e2) => {\n            let i = get!(subst(*e1, x.clone(), v.clone()));\n            let j = get!(subst(*e2, x.clone(), v.clone()));\n            Some(Sub(Box::new(i), Box::new(j)))\n        }\n\n        If(e1, e2, e3, e4) => {\n            let i = get!(subst(*e1, x.clone(), v.clone()));\n            let j = get!(subst(*e2, x.clone(), v.clone()));\n            let k = get!(subst(*e3, x.clone(), v.clone()));\n            let l = get!(subst(*e4, x.clone(), v.clone()));\n            Some(If(Box::new(i), Box::new(j), Box::new(k), Box::new(l)))\n        }\n\n        Fun(y, e) => {\n            if x == y {\n                Some(Fun(y, e))\n            } else {\n                Some(Fun(y, Box::new(get!(subst(*e, x, v)))))\n            }\n        }\n\n        App(e1, e2) => {\n            let i = get!(subst(*e1, x.clone(), v.clone()));\n            let j = get!(subst(*e2, x.clone(), v.clone()));\n            Some(App(Box::new(i), Box::new(j)))\n        }\n    }\n}\n```\n\n\u968f\u6240\u3067\u51fa\u3066\u304f\u308b `get!` \u306f `Option<T>` \u7528\u306b\u5b9a\u7fa9\u3057\u305f `try!` \u306e\u3088\u3046\u306b\u4f7f\u3048\u308b\u30de\u30af\u30ed\u3067\u3042\u308a\uff0c\u6b21\u306e\u3088\u3046\u306b\u5b9a\u7fa9\u3057\u305f\uff08~~`Result<T,E>` \u4f7f\u3048\u3070\u3044\u3044\u3093\u3058\u3083~~\uff09\uff0e\n\n```rust\nmacro_rules! get (\n    ($e:expr) => (\n        match $e {\n            Some(x) => x,\n            None => return None,\n        }\n    )\n);\n```\n\n\u30c6\u30b9\u30c8\u30b3\u30fc\u30c9\uff0e\n\n```rust\nfn main() {\n    let tashizan = _plus(_int(1), _int(2));\n\n    let def_function = _let(\"abs\",\n                            _fun(\"x\", _if(_var(\"x\"), _int(0), _negate(_var(\"x\")), _var(\"x\"))),\n                            _app(_var(\"abs\"), _int(-42)));\n\n    print_eval(\"tashizan\", tashizan);\n    print_eval(\"def_function\", def_function);\n}\n\npub fn _int(i: i64) -> Expr {\n    Int(i)\n}\n\npub fn _var(v: &str) -> Expr {\n    Var(v.to_string())\n}\n\npub fn _sub(e1: Expr, e2: Expr) -> Expr {\n    Sub(Box::new(e1), Box::new(e2))\n}\n\npub fn _if(e1: Expr, e2: Expr, e3: Expr, e4: Expr) -> Expr {\n    If(Box::new(e1), Box::new(e2), Box::new(e3), Box::new(e4))\n}\n\npub fn _app(e1: Expr, e2: Expr) -> Expr {\n    App(Box::new(e1), Box::new(e2))\n}\n\npub fn _fun(v: &str, e: Expr) -> Expr {\n    Fun(v.to_string(), Box::new(e))\n}\n\npub fn _negate(e: Expr) -> Expr {\n    _sub(_int(0), e)\n}\n\npub fn _plus(e1: Expr, e2: Expr) -> Expr {\n    _sub(e1, _negate(e2))\n}\n\npub fn _let(x: &str, e1: Expr, e2: Expr) -> Expr {\n    _app(_fun(x, e2), e1)\n}\n\npub fn print_eval(name: &str, expr: Expr) {\n    print!(\"eval {}: \", name);\n    match eval(expr).unwrap() {\n        Int(i) => println!(\"{}\", i),\n        _ => panic!(\"evaluation failed.!\"),\n    }\n}\n```\n\n---\n\n(\u8ffd\u8a18) [\u74b0\u5883\u30fb\u30af\u30ed\u30fc\u30b8\u30e3\u3092\u4f7f\u7528\u3057\u305f\u5834\u5408](http://qiita.com/esumii/items/f077b951171e4f15c347) \u3082\u3084\u3063\u3066\u307f\u305f\uff0e\n\n```rust\nuse std::collections::HashMap;\n\ntype Env = HashMap<String, Value>;\n\n#[derive(Clone)]\npub enum Value {\n    VInt(i64),\n    VClosure(String, Expr, Env),\n}\nuse Value::*;\n\npub fn eval(expr: Expr, env: &Env) -> Result<Value, ()> {\n    match expr {\n        Int(i) => Ok(VInt(i)),\n\n        Var(x) => env.get(&x).cloned().ok_or_else(|| ()),\n\n        Sub(e1, e2) => {\n            let i = match try!(eval(*e1, env)) {\n                VInt(x) => x,\n                _ => return Err(()),\n            };\n            let j = match try!(eval(*e2, env)) {\n                VInt(x) => x,\n                _ => return Err(()),\n            };\n            Ok(VInt(i - j))\n        }\n\n        If(e1, e2, e3, e4) => {\n            let i = match try!(eval(*e1, env)) {\n                VInt(x) => x,\n                _ => return Err(()),\n            };\n            let j = match try!(eval(*e2, env)) {\n                VInt(x) => x,\n                _ => return Err(()),\n            };\n            if i <= j {\n                eval(*e3, env)\n            } else {\n                eval(*e4, env)\n            }\n        }\n\n        Fun(x, e) => Ok(VClosure(x, *e, env.clone())),\n\n        App(e1, e2) => {\n            let (x, e, mut env_) = match try!(eval(*e1, env)) {\n                VClosure(x, e, env) => (x, e, env),\n                _ => return Err(()),\n            };\n            let v = try!(eval(*e2, env));\n            env_.insert(x, v);\n            eval(e, &env_)\n        }\n    }\n}\n```\n", "tags": ["rust"]}