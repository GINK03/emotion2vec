{"tags": ["C++", "C++11"], "context": " \u3053\u306e\u8a18\u4e8b\u306f\u6700\u7d42\u66f4\u65b0\u65e5\u304b\u30891\u5e74\u4ee5\u4e0a\u304c\u7d4c\u904e\u3057\u3066\u3044\u307e\u3059\u3002\u306b\u308f\u304b\u306bC++\u3092\u52c9\u5f37\u3057\u306a\u3044\u3068\u3044\u3051\u306a\u304f\u306a\u3063\u305f\u306e\u3067\u5fd8\u308c\u305d\u3046\u306a\u70b9\u3092\u30e1\u30e2\u3002\nC++11\u524d\u63d0\u3001\u30b5\u30f3\u30d7\u30eb\u30b3\u30fc\u30c9\u306fg++ 4.8.1\u3067\u52d5\u4f5c\u78ba\u8a8d\u3002\n\n\u6587\u6cd5\n\nconst\n\n\nconst int * const i;: \u5de6\u306econst\u306f\u30dd\u30a4\u30f3\u30bf\u306e\u6307\u793a\u5148\u306e\u9818\u57df\u306b\u66f8\u304d\u8fbc\u3081\u306a\u3044\u3053\u3068\u3092\u3001\u53f3\u306econst\u306f\u30dd\u30a4\u30f3\u30bf\u5909\u6570\u306b\u66f8\u304d\u8fbc\u3081\u306a\u3044\u3053\u3068\u3092\u793a\u3059\u3002\nconst\u30e1\u30f3\u30d0\u95a2\u6570: \u30e1\u30f3\u30d0\u5909\u6570\u3092\u66f8\u304d\u63db\u3048\u306a\u3044\u610f\u5473\u3067\u306econst\u306f\u4eee\u5f15\u6570\u5217\u306e\u5f8c\u306b\u7f6e\u304f\u3002\n\n\nconst_method.cpp\nclass Hoge {\n  int x;\npublic:\n  int getX() const {\n    return x;\n  }\n};\n\n\n\n\u6bd4\u8f03\u53ef\u80fd\u306a\u30af\u30e9\u30b9\u3092\u4f5c\u308b\n\ncomparable.cpp\n#include<iostream>\n#include<vector>\n#include<algorithm>\n\nclass Hoge {\npublic:\n  int x;\n  Hoge(int x) {this->x = x;}\n  bool operator<(Hoge other) const{ // const\u5fc5\u9808\u306a\u306e\u3067\u6ce8\u610f!\n    return this->x < other.x;\n  }\n};\n\nint main() {\n  std::vector<Hoge> v = {2, 0, 1};\n  std::for_each(v.begin(), v.end(), [](const Hoge &hoge){std::cout << hoge.x << std::endl;}); // 2 0 1\n  std::sort(v.begin(), v.end()); // operator<\u306b\u5f93\u3063\u3066\u30bd\u30fc\u30c8\n  std::for_each(v.begin(), v.end(), [](const Hoge &hoge){std::cout << hoge.x << std::endl;}); // 0 1 2\n}\n\n\nfriend\u95a2\u6570\u3092\u4f7f\u3046\u65b9\u6cd5\u3082\u3042\u308b\u304c\u6c17\u306b\u98df\u308f\u306a\u3044\u306e\u3067\u7701\u7565\u3002\n\nauto, decltype\n\u3053\u308c\u306e\u304a\u304b\u3052\u3067\u3051\u3063\u3053\u3046C++\u304c\u597d\u304d\u306b\u306a\u308a\u307e\u3057\u305f\u3002\u30a4\u30c6\u30ec\u30fc\u30bf\u306e\u578b\u3092\u3054\u3061\u3083\u3054\u3061\u3083\u66f8\u304b\u306a\u304f\u3066\u3088\u304b\u3063\u305f\u308a\u3001\u30a4\u30a4\u30cd!\n\nauto.cpp\n#include<iostream>\n#include<vector>\nint main() {\n  std::vector<int> v = {1, 2, 3};\n  for(auto iter = v.begin(); iter != v.end(); ++iter) { // iter++\u3088\u308a++iter\u306e\u307b\u3046\u304c\u30d1\u30d5\u30a9\u30fc\u30de\u30f3\u30b9\u4e0a\u3044\u3044\u3089\u3057\u3044\n    std::cout << *iter << std::endl; // 1 2 3\n  }\n}\n\n\n\ndecltype.cpp\n#include <iostream>\n#include <boost/type_index.hpp>\n\ntemplate<typename T1, typename T2>\nauto sum(T1 x, T2 y) ->decltype(x+y) {\n  std::cout << \"T1:\" << boost::typeindex::type_id_with_cvr<T1>().pretty_name() << std::endl;\n  std::cout << \"T2:\" << boost::typeindex::type_id_with_cvr<T2>().pretty_name() << std::endl;\n  std::cout << \"ret: \" << boost::typeindex::type_id_with_cvr<decltype(x+y)>().pretty_name() << std::endl;\n  return x+y;\n}\n\nint main() {\n  std::cout << sum('0', '1') << std::endl; // T1: char, T2: char, ret: int, 97\n  std::cout << sum((unsigned int)1, (unsigned int)1) << std::endl; // T1: unsigned int, T2: unsigned int, ret: unsigned int, 2\n  std::cout << sum((unsigned int)1, -2) << std::endl; // T1: unsigned int, T2: int, ret: unsigned int, 4294967295 (!!!!)\n  std::cout << sum(1, 1.1) << std::endl; // T1: int, T2: double, ret: double, 2.1\n  std::cout << sum(std::string(\"foo\"), std::string(\"bar\")) << std::endl; // foobar\n}\n\n\n\n\u7bc4\u56f2\u30d9\u30fc\u30b9for\u6587\njava\u306b\u3042\u308b\u3088\u3046\u306a\u3084\u3064\u3067\u3059\u306d\u3002\n\nrange_for.cpp\n#include <iostream>\n#include <vector>\n\nint main() {\n  std::string str = \"foobar\";\n  std::vector<int> vec = {0, 1, 2};\n  for(auto i : str) {std::cout << i << std::endl;} // f, o, o, b, a, r\n  for(auto i : vec) {std::cout << i << std::endl;} // 0, 1, 2\n}\n\n\n\ntypeid\u6f14\u7b97\u5b50\n\ntypeid.cpp\n#include <iostream>\n#include <typeinfo>\n#include <vector>\n\nint main() {\n  char c;\n  short s;\n  int i;\n  long l;\n  float f;\n  double d;\n  std::string str;\n  std::vector<int> v;\n  std::cout << typeid(c).name() << std::endl; // c\n  std::cout << typeid(s).name() << std::endl; // s\n  std::cout << typeid(i).name() << std::endl; // i\n  std::cout << typeid(l).name() << std::endl; // l\n  std::cout << typeid(f).name() << std::endl; // f\n  std::cout << typeid(d).name() << std::endl; // d\n  std::cout << typeid(str).name() << std::endl; // Ss\n  std::cout << typeid(v).name() << std::endl; // St6vectorIiSaIiEE\n}\n\n\n\n\u30e9\u30e0\u30c0\u5f0f\nSTL\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0\u3068\u7d44\u307f\u5408\u308f\u305b\u3066\u4f7f\u3046\u3068\u6c17\u6301\u3061\u304c\u826f\u3044\u3002auto\u578b\u306e\u5909\u6570\u306b\u4ee3\u5165\u3082\u3067\u304d\u308b\u3088!\n\u3088\u308a\u8a73\u3057\u3044\u8aac\u660e\u306f\u3001\u3053\u3053\u304cgood\u3002\n\nlambda.cpp\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\nint main() {\n  int a[10];\n  std::generate(a, a+10, [](){static int i = 0; return i++;});\n  std::for_each(a, a+10, [](const int &i){std::cout << i << std::endl;}); // 0 1 2 ...\n  std::sort(a, a+10, [](const int &i, const int &j) {return i > j;}); // \u9006\u9806\u30bd\u30fc\u30c8\u3002\n  std::sort(a, a+10, std::greater<int>()); // \u4e0a\u306e\u884c\u3068\u540c\u3058\u3002 std::less<int>() \u3082\u3042\u308b\n  std::for_each(a, a+10, [](const int &i){std::cout << i << std::endl;}); // 9 8 7 ...\n\n  auto print = [](std::string x){std::cout << x << std::endl;};\n  print(\"hoge\"); // hoge\n}\n\n\n\n\u30ad\u30e3\u30b9\u30c8\n\nstatic_cast: \u6697\u9ed9\u578b\u5909\u63db\u304c\u5b58\u5728\u3059\u308b\u5834\u5408\u306e\u307f\u6709\u52b9\u3002\u305d\u308c\u4ee5\u5916\u306f\u30b3\u30f3\u30d1\u30a4\u30eb\u30a8\u30e9\u30fc\u3002cv(const, volatile)\u4fee\u98fe\u5b50\u3092\u3064\u3051\u308b\u3053\u3068\u306f\u3067\u304d\u308b\u304c\u5916\u3059\u3053\u3068\u306f\u3067\u304d\u306a\u3044\u3002\ndynamic_cast: \u5b9f\u884c\u6642\u306b\u30ad\u30e3\u30b9\u30c8\u53ef\u304b\u3069\u3046\u304b\u5224\u65ad\u3002\u30ad\u30e3\u30b9\u30c8\u3067\u304d\u306a\u3044\u5834\u5408\u30dd\u30a4\u30f3\u30bf\u306a\u3089NULL\u304c\u8fd4\u308a\u3001\u53c2\u7167\u306a\u3089std::bad_cast\u304cthrow\u3055\u308c\u308b\u3002dynamic_cast\u304c\u53ef\u80fd\u304b\u3069\u3046\u304b\u306f\u5b9f\u884c\u6642\u306b\u5224\u65ad\u3055\u308c\u308b\u306e\u3067\u30d1\u30d5\u30a9\u30fc\u30de\u30f3\u30b9\u306b\u306f\u6ce8\u610f\u304c\u5fc5\u8981\u3002\n\n-- \u57fa\u672c\u4f7f\u3063\u3066\u306f\u3044\u3051\u306a\u3044\u58c1 --\n\nconst_cast: cv\u4fee\u98fe\u5b50\u3092\u5916\u305b\u308b\u306e\u306f const_cast \u5148\u751f\u3060\u3051\uff01\u826f\u3044\u5b50\u306fconst\u3092\u5916\u3057\u3061\u3083\u3060\u3081\u3060\u3088\uff01\nreinterpret_cast: \u30dd\u30a4\u30f3\u30bf\u3068\u53c2\u7167\u306b\u3064\u3044\u3066\u306f\u3001\u9055\u3046\u578b\u306e\u30dd\u30a4\u30f3\u30bf\u307e\u305f\u306f\u53c2\u7167\u3078\u306e\u5909\u63db\u304c\u3067\u304d\u308b(\u5371\u967a!)\u3002\u30dd\u30a4\u30f3\u30bf\u3068\u6574\u6570\u306e\u76f8\u4e92\u5909\u63db\u3082\u3067\u304d\u308b\u3002\n\n\ncast.cpp\n\n#include <iostream>\n\nint main() {\n  const double d = 12.345;\n  const double &rd = d;\n\n  std::cout << static_cast<int>(d) << std::endl; // 12\u3002\u6697\u9ed9\u306e\u578b\u5909\u63db\u304c\u5b58\u5728\u3059\u308b\u306e\u3067\u5408\u6cd5\n  std::cout << std::hex << *reinterpret_cast<const unsigned long *>(&d) << std::dec << std::endl; // 4028b0a3d70a3d71 = 12.345 \u3092\u8868\u3059\u30d3\u30c3\u30c8\u5217\n  std::cout << std::hex << reinterpret_cast<const unsigned long &>(rd) << std::dec << std::endl; // \u540c\u4e0a\n  double *pd = const_cast<double *>(&d); // const \u4fee\u98fe\u5b50\u3092\u5916\u3059: \u3084\u3063\u3066\u306f\u3044\u3051\u306a\u3044\n  *pd = 54.321; // const \u3060\u3063\u305f\u306f\u305a\u306e\u9818\u57df\u306b\u7121\u7406\u3084\u308a\u66f8\u304d\u8fbc\u3093\u3067\u3057\u307e\u3063\u305f\n  std::cout << *pd << std::endl; // 54.321\n  std::cout << d << std::endl; // \u79c1\u306e\u51e6\u7406\u7cfb\u3067\u306f 12.345\u3002\u6050\u3089\u304f\u30b3\u30f3\u30d1\u30a4\u30eb\u6642\u306b\u5024\u304c\u56fa\u5b9a\u3055\u308c\u3066\u3044\u308b\u305f\u3081\u3002\n}\n\n\n\n\u30a2\u30af\u30bb\u30b9\u5236\u5fa1\u3068\u7d99\u627f\n\u30e1\u30f3\u30d0\u306e\u30a2\u30af\u30bb\u30b9\u5236\u5fa1\n\nprivate: \u5b50\u5b6b\u306b\u3082\u4ed6\u4eba\u306b\u3082\u7d76\u5bfe\u898b\u305b\u306a\u3044\u3002\u53cb\u9054\u306b\u306f\u898b\u305b\u308b\u3002\nprotected: \u53cb\u9054\u3068\u5b50\u4f9b\u306b\u306f\u898b\u305b\u308b\u3002\u5b6b\u306b\u306f\u81ea\u5206\u304b\u3089\u306f\u898b\u305b\u306a\u3044\u304c\u3001\u5b50\u304c\u5b6b\u306b\u898b\u305b\u308b\u304b\u3082\u3002\npublic: \u8ab0\u306b\u3067\u3082\u898b\u305b\u308b\u3002\n\n\u7d99\u627f\u4fee\u98fe\u5b50\n\nprivate: \u81ea\u5206\u306epublic\u30e1\u30f3\u30d0\u3082protected\u30e1\u30f3\u30d0\u3082\u5b50\u306eprivate\u30e1\u30f3\u30d0\u3068\u3059\u308b\nprotected: \u81ea\u5206\u306epublic\u30e1\u30f3\u30d0\u3082protected\u30e1\u30f3\u30d0\u3082\u5b50\u306eprotected\u30e1\u30f3\u30d0\u3068\u3059\u308b\u3002\npublic: \u81ea\u5206\u306epublic\u30e1\u30f3\u30d0\u306f\u5b50\u306epublic\u30e1\u30f3\u30d0\u3001\u81ea\u5206\u306eprotected\u30e1\u30f3\u30d0\u306f\u5b50\u306eprotected\u30e1\u30f3\u30d0\u3068\u3059\u308b\u3002\n\n\u4fee\u98fe\u5b50\u3092\u7701\u7565\u3057\u305f\u5834\u5408\u306f\u3001\u6d3e\u751f\u30af\u30e9\u30b9\u304cclass\u30ad\u30fc\u30ef\u30fc\u30c9\u3067\u5ba3\u8a00\u3055\u308c\u3066\u3044\u308b\u5834\u5408\u306fprivate\u7d99\u627f\u3001struct\u30ad\u30fc\u30ef\u30fc\u30c9\u3067\u5ba3\u8a00\u3055\u308c\u3066\u3044\u308b\u5834\u5408\u306fpublic\u7d99\u627f\u3068\u306a\u308b\u3002\n\u3082\u3061\u308d\u3093\u3084\u308b\u3079\u304d\u3067\u306f\u306a\u3044\u304c\u3001class\u3092struct\u3067\u7d99\u627f\u3059\u308b\u3053\u3068\u3082\u3067\u304d\u308b\u3088\u3046\u3060\u3002(clang6.0\u3067\u78ba\u8a8d)\n\u30b3\u30f3\u30b9\u30c8\u30e9\u30af\u30bf\n\n\u57fa\u5e95\u30af\u30e9\u30b9\u304b\u3089\u7d99\u627f\u3057\u305f\u30c7\u30fc\u30bf\u30e1\u30f3\u30d0\u306e\u521d\u671f\u5316\u306f\u76f4\u63a5\u57fa\u5e95\u30af\u30e9\u30b9\u306e\u30b3\u30f3\u30b9\u30c8\u30e9\u30af\u30bf\u306b\u59d4\u306d\u308b\u306e\u304c\u539f\u5247\u3002\n\n\nderived_constructor.cpp\n#include <iostream>\n\nclass Parent {\n  int i;\npublic:\n  Parent(int i):i(i){};\n};\n\nclass Child : Parent {\n  int j;\npublic:\n  Child(int i, int j):Parent(i), j(j){};\n};\n\nint main() {\n  Child c(1, 2);\n  Parent p = c; // slicing : Parent \u30af\u30e9\u30b9\u306e\u30c7\u30fc\u30bf\u30e1\u30f3\u30d0\u3060\u3051\u304c\u30b3\u30d4\u30fc\u3055\u308c\u308b                                                                            \n}\n\n\n\n\u4eee\u60f3\u95a2\u6570\u3068dynamic_cast\n\n\u975e\u4eee\u60f3\u95a2\u6570\u306f\u9759\u7684\u7d50\u5408\u3001\u4eee\u60f3\u95a2\u6570\u306f\u4eee\u60f3\u95a2\u6570\u30c6\u30fc\u30d6\u30eb\u306b\u3088\u308b\u52d5\u7684\u7d50\u5408\n\u30c0\u30a6\u30f3\u30ad\u30e3\u30b9\u30c8\u306f\u57fa\u672c\u4e0d\u8a31\u53ef\u3060\u304c\u3001\u30aa\u30d6\u30b8\u30a7\u30af\u30c8\u306e\u5b9f\u4f53\u304c\u30c0\u30a6\u30f3\u30ad\u30e3\u30b9\u30c8\u5148\u306e\u6d3e\u751f\u30af\u30e9\u30b9\u306e\u5834\u5408\u306f\u53ef\n\n\ndynamic_cast.cpp\n#include <iostream>\n\nclass Parent {\npublic:\n  void func1() {std::cout << \"My static type is parent\" << std::endl;};\n  virtual void func2() {std::cout << \"My dynamic type is parent\" << std::endl;};\n};\n\nclass Child : public Parent {\npublic:\n  void func1() {std::cout << \"My static type is child\" << std::endl;};\n  void func2() {std::cout << \"My dynamic type is child\" << std::endl;};\n};\n\nint main() {\n  Parent *p1 = new Child();\n  Parent *p2 = new Parent();\n  Child *c1 = dynamic_cast<Child *>(p1);\n  Child *c2 = dynamic_cast<Child *>(p2);\n  p1->func1(); // My static type is parent\n  p1->func2(); // My dynamic type is child\n  p2->func1(); // My static type is parent\n  p2->func2(); // My dynamic type is parent\n  c1->func1(); // My static type is child\n  c1->func2(); // My dynamic type is child\n  // c2->func1(); // segmentation fault, because c2 is NULL\n  // c2->func2(); // segmentation fault, because c2 is NULL\n}\n\n\n\n\u591a\u91cd\u7d99\u627f\n\n\u57fa\u5e95\u30af\u30e9\u30b9\u306e\u30b3\u30f3\u30b9\u30c8\u30e9\u30af\u30bf\u306e\u547c\u3073\u51fa\u3057\u9806\u306f\u57fa\u5e95\u6307\u5b9a\u5b50\u306e\u4e26\u3073\u9806\n\u57fa\u5e95\u30af\u30e9\u30b9\u306e\u30e1\u30f3\u30d0\u540d\u304c\u304b\u3076\u3063\u305f\u3089::\u3067\u660e\u793a\u7684\u306b\u3069\u3063\u3061\u304b\u3092\u6307\u5b9a\n\u30af\u30ed\u30b9\u30ad\u30e3\u30b9\u30c8: dynamic_cast\u6f14\u7b97\u5b50\u3067\u591a\u91cd\u7d99\u627f\u306e\u57fa\u5e95\u30af\u30e9\u30b9\u9593\u3067\u306e\u30ad\u30e3\u30b9\u30c8\u304c\u53ef\u80fd\u3002\n\n\nmultiple_inheritance.cpp\n#include <iostream>\n\nclass Base1 {\npublic:\n  Base1(){std::cout << \"Initializing Base1\" << std::endl;}\n  void func() {std::cout << \"I am Base1\" << std::endl;};\n  void func1() {std::cout << \"Base1 specific implementation\" << std::endl;}\n  virtual void vfunc1() = 0;\n};\n\nclass Base2 {\npublic:\n  Base2(){std::cout << \"Initializing Base2\" << std::endl;}\n  void func() {std::cout << \"I am Base2\" << std::endl;};\n  void func2() {std::cout << \"Base2 specific implementation\" << std::endl;}\n  virtual void vfunc2() = 0;\n};\n\nclass Derived : public Base1, public Base2{ // \u30b3\u30f3\u30b9\u30c8\u30e9\u30af\u30bf\u306e\u547c\u3073\u51fa\u3057\u9806\u306f\u57fa\u5e95\u6307\u5b9a\u3057\u4e26\u3073\u306e\u5ba3\u8a00\u9806\n  void vfunc1() {std::cout << \"Derived implementation of vfunc1\" << std::endl;};\n  void vfunc2() {std::cout << \"Derived implementation of vfunc2\" << std::endl;};\n};\n\nint main() {\n  Derived derived; // Initializing Base1, Initializing Base2\n  derived.Base1::func(); // I am Base1\n  derived.Base2::func(); // I am Base2\n  Base1 *pb1 = new Derived();\n  pb1->func1(); // Base1 specific implementation\n  pb1->vfunc1(); // Derived implementation of vfunc1\n  Base2 *pb2 = dynamic_cast<Base2 *>(pb1); // cross cast\n  pb2->func2(); // Base2 specific implementation\n  pb2->vfunc2(); // Derived implementation ov vfunc2                                                                                                          \n}\n\n\n\u4eee\u60f3\u7d99\u627f\u3068\u3044\u3046\u306e\u3082\u3042\u308b\u3089\u3057\u3044\u304c\u3084\u3084\u3053\u3057\u3059\u304e\u3066\u6483\u6c88\u3002\n\nexplicit \u30b3\u30f3\u30b9\u30c8\u30e9\u30af\u30bf\n\u5f15\u6570\u30921\u3064\u3060\u3051\u3068\u308b\u30b3\u30f3\u30b9\u30c8\u30e9\u30af\u30bf\u3092\u5909\u63db\u30b3\u30f3\u30b9\u30c8\u30e9\u30af\u30bf(converting constructor)\u3068\u547c\u3076\u3002\n\u5909\u63db\u30b3\u30f3\u30b9\u30c8\u30e9\u30af\u30bf\u3092explicit\u5ba3\u8a00\u3059\u308b\u3053\u3068\u3067\u6697\u9ed9\u306e\u578b\u5909\u63db\u3092\u7981\u6b62\u3067\u304d\u308b\u3002\n\n\u95a2\u6570\u30dd\u30a4\u30f3\u30bf\n\u5927\u90e8\u5206\u306fC++\u3068\u3044\u3046\u304bC\u306e\u8a71\u3060\u304c\u3001\u3088\u304f\u66f8\u5f0f\u3092\u5fd8\u308c\u308b\u3002\n\nfunc_ptr.cpp\n#include <iostream>\n\nint _single(int i) {return i * 1;}\nint _double(int i) {return i * 2;}\nint _triple(int i) {return i * 3;}\nclass Hoge {\n  int i;\npublic:\n  Hoge(int i): i(i) {};\n  int _single() const {return i * 1;}\n  int _double() const {return i * 2;}\n  int _triple() const {return i * 3;}\n};\n\nint main() {\n  int (*funcPtr)(int) = _single;\n  int (*funcPtrs[])(int) = {_single, _double, _triple};\n  std::cout << funcPtr(1) << std::endl; // 1\n  for(int i = 0; i < 3; i++) {\n    std::cout << funcPtrs[i](1) << std::endl; // 1, 2, 3\n  }\n  // typedef \u3059\u308b\u306e\u304c\u4e00\u822c\u7684\n  typedef int(*FP)(int);\n  FP fp = _double;\n  FP fps[] = {_double, _triple, _single};\n  std::cout << fp(1) << std::endl; // 2\n  for(int i = 0; i < 3; i++) {\n    std::cout << fps[i](1) << std::endl; // 2, 3, 1\n  }\n  // \u30af\u30e9\u30b9\u306e\u30e1\u30f3\u30d0\u95a2\u6570\u3078\u306e\u95a2\u6570\u30dd\u30a4\u30f3\u30bf\n  typedef int(Hoge::*FPHoge)() const;\n  FPHoge fph = &Hoge::_triple;\n  FPHoge fphs[] = {&Hoge::_triple, &Hoge::_single, &Hoge::_double};\n  Hoge hoge(100);\n  std::cout << (hoge.*fph)() << std::endl; // 300\n  for(int i = 0; i < 3; i++) {\n    std::cout << (hoge.*fphs[i])() << std::endl; // 300, 100, 200\n  }\n  Hoge *phoge = new Hoge(200);\n  std::cout << (phoge->*fph)() << std::endl; // 600\n  for(int i = 0; i < 3; i++) {\n    std::cout << (phoge->*fphs[i])() << std::endl; // 600, 200, 400\n  }\n}\n\n\n\n\u305d\u306e\u4ed6tips\n\n(C++11) \u30d8\u30c3\u30c0\u306b\u30d3\u30c3\u30c8\u5e45\u6307\u5b9a\u306e\u6574\u6570\u578b\u306e\u5b9a\u7fa9\u304c\u3042\u308b\u3002std::int8_t\u306a\u3069\n(C++11) \u30b9\u30b3\u30fc\u30d7\u4ed8\u304d enum \u540d\u524d\u7a7a\u9593\u306e\u885d\u7a81\u3092 enum struct Hoge{A, B, C};\u3068\u5ba3\u8a00\u3057Hoge::A\u3068\u3057\u3066\u4f7f\u7528\u3059\u308b\u3053\u3068\u3067\u56de\u907f\u3067\u304d\u308b\u3002\n\n\n\n\u6a19\u6e96\u30e9\u30a4\u30d6\u30e9\u30ea\n\niostream\u306e\u6841\u6570\u6307\u5b9a\n\niomanip.cpp\n#include <iostream>\n#include <iomanip>\n\nint main() {\n  std::cout << std::setw(2) << std::setfill('0') << 2 << std::endl; // 02\n  std::cout << true << \", \" << std::boolalpha << true << \", \"\n            << std::noboolalpha << true << std::endl; // 1, true, 1\n  std::cout.setf(std::ios_base::fixed);\n  std::cout << std::setprecision(2) << 1.111111 << std::endl; // 1.11\n  std::cout << \"0x\" << std::setw(8) << std::hex << 65535 << std::dec << std::endl; // 0x0000ffff\n}\n\n\n\nchrono \u3067\u306e\u51e6\u7406\u6642\u9593\u8a08\u6e2c\n\nchrono.cpp\n#include <iostream>\n#include <chrono>\n\nint main() {\n  auto start = std::chrono::system_clock::now();\n  // \u91cd\u3044\u51e6\u7406\n  auto end = std::chrono::system_clock::now();\n\n  auto elapsed = end - start;\n  std::cout << std::chrono::duration_cast<std::chrono::milliseconds>(elapsed).count() << std::endl; // ms \u5358\u4f4d\n}\n\n\n\n\u30b3\u30ec\u30af\u30b7\u30e7\u30f3\u306e\u548c\n\nsum.cpp\n#include <iostream>\n#include <algorithm>\n\nint main() {\n  int a[10];\n  std::generate(a, a+10, [](){static int i = 0; return i++;}); // 0, 1, 2, ..., 9\n  std::cout << std::accumulate(a, a+10, 0, [](int a, int b) {return a+b;}); // 45\n}\n\n\n\n\u4e71\u6570\n\nrandom.cpp\n#include <iostream>\n#include <random>\n\nint main() {\n  std::random_device rand; // \u30cf\u30fc\u30c9\u30a6\u30a7\u30a2\u7531\u6765\u306e\u975e\u6c7a\u5b9a\u8ad6\u7684\u4e71\u6570\u3092(\u4f7f\u3048\u308c\u3070)\u4f7f\u3046\u3002\u591a\u5c11\u9045\u3044\u3002\n  std::mt19937 mt(rand()); // \u30e1\u30eb\u30bb\u30f3\u30cc\u30c4\u30a4\u30b9\u30bf (Mersenne twister)\n  std::cout << std::hex << mt() << std::dec << std::endl; // \u4e00\u69d8\u5206\u5e03\u3001\u7bc4\u56f2\u306f [0, 0xffffffff]\n  std::uniform_int_distribution<int> dice6(1, 6);\n  std::cout << std::hex << dice6(mt) << std::endl; // \u96e2\u6563\u4e00\u69d8\u5206\u5e03(discrete uniform distribution)\u3001\u7bc4\u56f2\u306f [1, 6]\n  std::uniform_real_distribution<double> continuous(0.0, 1.0);\n  std::cout << std::hex << continuous(mt) << std::endl; // \u9023\u7d9a\u4e00\u69d8\u5206\u5e03(continuous uniform distribution)\u3001\u7bc4\u56f2\u306f [0, 1)\n  std::normal_distribution<double> normal(0.0, 1.0); // \u30b3\u30f3\u30b9\u30c8\u30e9\u30af\u30bf\u306e\u5f15\u6570\u306f (mean, stdiv)\n  std::cout << normal(mt) << std::endl; // \u6a19\u6e96\u6b63\u898f\u5206\u5e03 (standard normal distribution)\n}\n\n\n\n\u6b63\u898f\u8868\u73fe\n\nregex.cpp\n#include <iostream>\n#include <regex>\n\nint main() {\n  std::string str = \"foo0bar1\";\n  std::regex re(\"(.+?)(\\\\d)\");\n  std::smatch result;\n  if(std::regex_search(str, result, re)) {\n    for(auto g : result) {\n      std::cout << g << std::endl; // foo0, foo, 0 (\u30de\u30c3\u30c1\u5168\u4f53, \u5404group)\n    }\n  }\n  std::cout << std::regex_replace(str, re, \"$2$1\") << std::endl; // 0foo1bar\n}\n\n\n\n\u30ea\u30d5\u30a1\u30ec\u30f3\u30b9\ncpprefjp\n\u306b\u308f\u304b\u306bC++\u3092\u52c9\u5f37\u3057\u306a\u3044\u3068\u3044\u3051\u306a\u304f\u306a\u3063\u305f\u306e\u3067\u5fd8\u308c\u305d\u3046\u306a\u70b9\u3092\u30e1\u30e2\u3002\n\nC++11\u524d\u63d0\u3001\u30b5\u30f3\u30d7\u30eb\u30b3\u30fc\u30c9\u306fg++ 4.8.1\u3067\u52d5\u4f5c\u78ba\u8a8d\u3002\n\n## \u6587\u6cd5\n### const\n* `const int * const i;`: \u5de6\u306econst\u306f\u30dd\u30a4\u30f3\u30bf\u306e\u6307\u793a\u5148\u306e\u9818\u57df\u306b\u66f8\u304d\u8fbc\u3081\u306a\u3044\u3053\u3068\u3092\u3001\u53f3\u306econst\u306f\u30dd\u30a4\u30f3\u30bf\u5909\u6570\u306b\u66f8\u304d\u8fbc\u3081\u306a\u3044\u3053\u3068\u3092\u793a\u3059\u3002\n* const\u30e1\u30f3\u30d0\u95a2\u6570: \u30e1\u30f3\u30d0\u5909\u6570\u3092\u66f8\u304d\u63db\u3048\u306a\u3044\u610f\u5473\u3067\u306econst\u306f\u4eee\u5f15\u6570\u5217\u306e\u5f8c\u306b\u7f6e\u304f\u3002\n\n``` c++:const_method.cpp\nclass Hoge {\n  int x;\npublic:\n  int getX() const {\n    return x;\n  }\n};\n```\n\n### \u6bd4\u8f03\u53ef\u80fd\u306a\u30af\u30e9\u30b9\u3092\u4f5c\u308b\n``` c++:comparable.cpp\n#include<iostream>\n#include<vector>\n#include<algorithm>\n\nclass Hoge {\npublic:\n  int x;\n  Hoge(int x) {this->x = x;}\n  bool operator<(Hoge other) const{ // const\u5fc5\u9808\u306a\u306e\u3067\u6ce8\u610f!\n    return this->x < other.x;\n  }\n};\n\nint main() {\n  std::vector<Hoge> v = {2, 0, 1};\n  std::for_each(v.begin(), v.end(), [](const Hoge &hoge){std::cout << hoge.x << std::endl;}); // 2 0 1\n  std::sort(v.begin(), v.end()); // operator<\u306b\u5f93\u3063\u3066\u30bd\u30fc\u30c8\n  std::for_each(v.begin(), v.end(), [](const Hoge &hoge){std::cout << hoge.x << std::endl;}); // 0 1 2\n}\n```\nfriend\u95a2\u6570\u3092\u4f7f\u3046\u65b9\u6cd5\u3082\u3042\u308b\u304c\u6c17\u306b\u98df\u308f\u306a\u3044\u306e\u3067\u7701\u7565\u3002\n\n### auto, decltype\n\u3053\u308c\u306e\u304a\u304b\u3052\u3067\u3051\u3063\u3053\u3046C++\u304c\u597d\u304d\u306b\u306a\u308a\u307e\u3057\u305f\u3002\u30a4\u30c6\u30ec\u30fc\u30bf\u306e\u578b\u3092\u3054\u3061\u3083\u3054\u3061\u3083\u66f8\u304b\u306a\u304f\u3066\u3088\u304b\u3063\u305f\u308a\u3001\u30a4\u30a4\u30cd!\n\n```c++:auto.cpp\n#include<iostream>\n#include<vector>\nint main() {\n  std::vector<int> v = {1, 2, 3};\n  for(auto iter = v.begin(); iter != v.end(); ++iter) { // iter++\u3088\u308a++iter\u306e\u307b\u3046\u304c\u30d1\u30d5\u30a9\u30fc\u30de\u30f3\u30b9\u4e0a\u3044\u3044\u3089\u3057\u3044\n    std::cout << *iter << std::endl; // 1 2 3\n  }\n}\n```\n\n```cpp:decltype.cpp\n#include <iostream>\n#include <boost/type_index.hpp>\n\ntemplate<typename T1, typename T2>\nauto sum(T1 x, T2 y) ->decltype(x+y) {\n  std::cout << \"T1:\" << boost::typeindex::type_id_with_cvr<T1>().pretty_name() << std::endl;\n  std::cout << \"T2:\" << boost::typeindex::type_id_with_cvr<T2>().pretty_name() << std::endl;\n  std::cout << \"ret: \" << boost::typeindex::type_id_with_cvr<decltype(x+y)>().pretty_name() << std::endl;\n  return x+y;\n}\n\nint main() {\n  std::cout << sum('0', '1') << std::endl; // T1: char, T2: char, ret: int, 97\n  std::cout << sum((unsigned int)1, (unsigned int)1) << std::endl; // T1: unsigned int, T2: unsigned int, ret: unsigned int, 2\n  std::cout << sum((unsigned int)1, -2) << std::endl; // T1: unsigned int, T2: int, ret: unsigned int, 4294967295 (!!!!)\n  std::cout << sum(1, 1.1) << std::endl; // T1: int, T2: double, ret: double, 2.1\n  std::cout << sum(std::string(\"foo\"), std::string(\"bar\")) << std::endl; // foobar\n}\n```\n\n### \u7bc4\u56f2\u30d9\u30fc\u30b9for\u6587\njava\u306b\u3042\u308b\u3088\u3046\u306a\u3084\u3064\u3067\u3059\u306d\u3002\n\n```cpp:range_for.cpp\n#include <iostream>\n#include <vector>\n\nint main() {\n  std::string str = \"foobar\";\n  std::vector<int> vec = {0, 1, 2};\n  for(auto i : str) {std::cout << i << std::endl;} // f, o, o, b, a, r\n  for(auto i : vec) {std::cout << i << std::endl;} // 0, 1, 2\n}\n```\n\n### typeid\u6f14\u7b97\u5b50\n``` c++:typeid.cpp\n#include <iostream>\n#include <typeinfo>\n#include <vector>\n\nint main() {\n  char c;\n  short s;\n  int i;\n  long l;\n  float f;\n  double d;\n  std::string str;\n  std::vector<int> v;\n  std::cout << typeid(c).name() << std::endl; // c\n  std::cout << typeid(s).name() << std::endl; // s\n  std::cout << typeid(i).name() << std::endl; // i\n  std::cout << typeid(l).name() << std::endl; // l\n  std::cout << typeid(f).name() << std::endl; // f\n  std::cout << typeid(d).name() << std::endl; // d\n  std::cout << typeid(str).name() << std::endl; // Ss\n  std::cout << typeid(v).name() << std::endl; // St6vectorIiSaIiEE\n}\n```\n\n\n### \u30e9\u30e0\u30c0\u5f0f\nSTL\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0\u3068\u7d44\u307f\u5408\u308f\u305b\u3066\u4f7f\u3046\u3068\u6c17\u6301\u3061\u304c\u826f\u3044\u3002auto\u578b\u306e\u5909\u6570\u306b\u4ee3\u5165\u3082\u3067\u304d\u308b\u3088!\n\u3088\u308a\u8a73\u3057\u3044\u8aac\u660e\u306f\u3001[\u3053\u3053](http://cpplover.blogspot.jp/2009/11/lambda.html)\u304cgood\u3002\n\n``` c++:lambda.cpp\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\nint main() {\n  int a[10];\n  std::generate(a, a+10, [](){static int i = 0; return i++;});\n  std::for_each(a, a+10, [](const int &i){std::cout << i << std::endl;}); // 0 1 2 ...\n  std::sort(a, a+10, [](const int &i, const int &j) {return i > j;}); // \u9006\u9806\u30bd\u30fc\u30c8\u3002\n  std::sort(a, a+10, std::greater<int>()); // \u4e0a\u306e\u884c\u3068\u540c\u3058\u3002 std::less<int>() \u3082\u3042\u308b\n  std::for_each(a, a+10, [](const int &i){std::cout << i << std::endl;}); // 9 8 7 ...\n\n  auto print = [](std::string x){std::cout << x << std::endl;};\n  print(\"hoge\"); // hoge\n}\n```\n\n### \u30ad\u30e3\u30b9\u30c8\n* static_cast: \u6697\u9ed9\u578b\u5909\u63db\u304c\u5b58\u5728\u3059\u308b\u5834\u5408\u306e\u307f\u6709\u52b9\u3002\u305d\u308c\u4ee5\u5916\u306f\u30b3\u30f3\u30d1\u30a4\u30eb\u30a8\u30e9\u30fc\u3002cv(const, volatile)\u4fee\u98fe\u5b50\u3092\u3064\u3051\u308b\u3053\u3068\u306f\u3067\u304d\u308b\u304c\u5916\u3059\u3053\u3068\u306f\u3067\u304d\u306a\u3044\u3002\n* dynamic_cast: \u5b9f\u884c\u6642\u306b\u30ad\u30e3\u30b9\u30c8\u53ef\u304b\u3069\u3046\u304b\u5224\u65ad\u3002\u30ad\u30e3\u30b9\u30c8\u3067\u304d\u306a\u3044\u5834\u5408\u30dd\u30a4\u30f3\u30bf\u306a\u3089NULL\u304c\u8fd4\u308a\u3001\u53c2\u7167\u306a\u3089`std::bad_cast`\u304cthrow\u3055\u308c\u308b\u3002dynamic_cast\u304c\u53ef\u80fd\u304b\u3069\u3046\u304b\u306f\u5b9f\u884c\u6642\u306b\u5224\u65ad\u3055\u308c\u308b\u306e\u3067\u30d1\u30d5\u30a9\u30fc\u30de\u30f3\u30b9\u306b\u306f\u6ce8\u610f\u304c\u5fc5\u8981\u3002\n\n-- \u57fa\u672c\u4f7f\u3063\u3066\u306f\u3044\u3051\u306a\u3044\u58c1 --\n\n* const_cast: cv\u4fee\u98fe\u5b50\u3092\u5916\u305b\u308b\u306e\u306f const_cast \u5148\u751f\u3060\u3051\uff01\u826f\u3044\u5b50\u306fconst\u3092\u5916\u3057\u3061\u3083\u3060\u3081\u3060\u3088\uff01\n* reinterpret_cast: \u30dd\u30a4\u30f3\u30bf\u3068\u53c2\u7167\u306b\u3064\u3044\u3066\u306f\u3001\u9055\u3046\u578b\u306e\u30dd\u30a4\u30f3\u30bf\u307e\u305f\u306f\u53c2\u7167\u3078\u306e\u5909\u63db\u304c\u3067\u304d\u308b(\u5371\u967a!)\u3002\u30dd\u30a4\u30f3\u30bf\u3068\u6574\u6570\u306e\u76f8\u4e92\u5909\u63db\u3082\u3067\u304d\u308b\u3002\n\n```cpp:cast.cpp\n\n#include <iostream>\n\nint main() {\n  const double d = 12.345;\n  const double &rd = d;\n\n  std::cout << static_cast<int>(d) << std::endl; // 12\u3002\u6697\u9ed9\u306e\u578b\u5909\u63db\u304c\u5b58\u5728\u3059\u308b\u306e\u3067\u5408\u6cd5\n  std::cout << std::hex << *reinterpret_cast<const unsigned long *>(&d) << std::dec << std::endl; // 4028b0a3d70a3d71 = 12.345 \u3092\u8868\u3059\u30d3\u30c3\u30c8\u5217\n  std::cout << std::hex << reinterpret_cast<const unsigned long &>(rd) << std::dec << std::endl; // \u540c\u4e0a\n  double *pd = const_cast<double *>(&d); // const \u4fee\u98fe\u5b50\u3092\u5916\u3059: \u3084\u3063\u3066\u306f\u3044\u3051\u306a\u3044\n  *pd = 54.321; // const \u3060\u3063\u305f\u306f\u305a\u306e\u9818\u57df\u306b\u7121\u7406\u3084\u308a\u66f8\u304d\u8fbc\u3093\u3067\u3057\u307e\u3063\u305f\n  std::cout << *pd << std::endl; // 54.321\n  std::cout << d << std::endl; // \u79c1\u306e\u51e6\u7406\u7cfb\u3067\u306f 12.345\u3002\u6050\u3089\u304f\u30b3\u30f3\u30d1\u30a4\u30eb\u6642\u306b\u5024\u304c\u56fa\u5b9a\u3055\u308c\u3066\u3044\u308b\u305f\u3081\u3002\n}\n```\n\n### \u30a2\u30af\u30bb\u30b9\u5236\u5fa1\u3068\u7d99\u627f\n**\u30e1\u30f3\u30d0\u306e\u30a2\u30af\u30bb\u30b9\u5236\u5fa1\b**\n\n* private: \u5b50\u5b6b\u306b\u3082\u4ed6\u4eba\u306b\u3082\u7d76\u5bfe\u898b\u305b\u306a\u3044\u3002\u53cb\u9054\u306b\u306f\u898b\u305b\u308b\u3002\n* protected: \u53cb\u9054\u3068\u5b50\u4f9b\u306b\u306f\u898b\u305b\u308b\u3002\u5b6b\u306b\u306f\u81ea\u5206\u304b\u3089\u306f\u898b\u305b\u306a\u3044\u304c\u3001\u5b50\u304c\u5b6b\u306b\u898b\u305b\u308b\u304b\u3082\u3002\n* public: \u8ab0\u306b\u3067\u3082\u898b\u305b\u308b\u3002\n\n**\u7d99\u627f\u4fee\u98fe\u5b50**\n\n* private: \u81ea\u5206\u306epublic\u30e1\u30f3\u30d0\u3082protected\u30e1\u30f3\u30d0\u3082\u5b50\u306eprivate\u30e1\u30f3\u30d0\u3068\u3059\u308b\n* protected: \u81ea\u5206\u306epublic\u30e1\u30f3\u30d0\u3082protected\u30e1\u30f3\u30d0\u3082\u5b50\u306eprotected\u30e1\u30f3\u30d0\u3068\u3059\u308b\u3002\n* public: \u81ea\u5206\u306epublic\u30e1\u30f3\u30d0\u306f\u5b50\u306epublic\u30e1\u30f3\u30d0\u3001\u81ea\u5206\u306eprotected\u30e1\u30f3\u30d0\u306f\u5b50\u306eprotected\u30e1\u30f3\u30d0\u3068\u3059\u308b\u3002\n\n\u4fee\u98fe\u5b50\u3092\u7701\u7565\u3057\u305f\u5834\u5408\u306f\u3001\u6d3e\u751f\u30af\u30e9\u30b9\u304cclass\u30ad\u30fc\u30ef\u30fc\u30c9\u3067\u5ba3\u8a00\u3055\u308c\u3066\u3044\u308b\u5834\u5408\u306fprivate\u7d99\u627f\u3001struct\u30ad\u30fc\u30ef\u30fc\u30c9\u3067\u5ba3\u8a00\u3055\u308c\u3066\u3044\u308b\u5834\u5408\u306fpublic\u7d99\u627f\u3068\u306a\u308b\u3002\n\u3082\u3061\u308d\u3093\u3084\u308b\u3079\u304d\u3067\u306f\u306a\u3044\u304c\u3001class\u3092struct\u3067\u7d99\u627f\u3059\u308b\u3053\u3068\u3082\u3067\u304d\u308b\u3088\u3046\u3060\u3002(clang6.0\u3067\u78ba\u8a8d)\n\n**\u30b3\u30f3\u30b9\u30c8\u30e9\u30af\u30bf**\n\n* \u57fa\u5e95\u30af\u30e9\u30b9\u304b\u3089\u7d99\u627f\u3057\u305f\u30c7\u30fc\u30bf\u30e1\u30f3\u30d0\u306e\u521d\u671f\u5316\u306f\u76f4\u63a5\u57fa\u5e95\u30af\u30e9\u30b9\u306e\u30b3\u30f3\u30b9\u30c8\u30e9\u30af\u30bf\u306b\u59d4\u306d\u308b\u306e\u304c\u539f\u5247\u3002\n\n```cpp:derived_constructor.cpp\n#include <iostream>\n\nclass Parent {\n  int i;\npublic:\n  Parent(int i):i(i){};\n};\n\nclass Child : Parent {\n  int j;\npublic:\n  Child(int i, int j):Parent(i), j(j){};\n};\n\nint main() {\n  Child c(1, 2);\n  Parent p = c; // slicing : Parent \u30af\u30e9\u30b9\u306e\u30c7\u30fc\u30bf\u30e1\u30f3\u30d0\u3060\u3051\u304c\u30b3\u30d4\u30fc\u3055\u308c\u308b                                                                            \n}\n```\n\n### \u4eee\u60f3\u95a2\u6570\u3068dynamic_cast\n* \u975e\u4eee\u60f3\u95a2\u6570\u306f\u9759\u7684\u7d50\u5408\u3001\u4eee\u60f3\u95a2\u6570\u306f\u4eee\u60f3\u95a2\u6570\u30c6\u30fc\u30d6\u30eb\u306b\u3088\u308b\u52d5\u7684\u7d50\u5408\n* \u30c0\u30a6\u30f3\u30ad\u30e3\u30b9\u30c8\u306f\u57fa\u672c\u4e0d\u8a31\u53ef\u3060\u304c\u3001\u30aa\u30d6\u30b8\u30a7\u30af\u30c8\u306e\u5b9f\u4f53\u304c\u30c0\u30a6\u30f3\u30ad\u30e3\u30b9\u30c8\u5148\u306e\u6d3e\u751f\u30af\u30e9\u30b9\u306e\u5834\u5408\u306f\u53ef\n\n``` cpp:dynamic_cast.cpp\n#include <iostream>\n\nclass Parent {\npublic:\n  void func1() {std::cout << \"My static type is parent\" << std::endl;};\n  virtual void func2() {std::cout << \"My dynamic type is parent\" << std::endl;};\n};\n\nclass Child : public Parent {\npublic:\n  void func1() {std::cout << \"My static type is child\" << std::endl;};\n  void func2() {std::cout << \"My dynamic type is child\" << std::endl;};\n};\n\nint main() {\n  Parent *p1 = new Child();\n  Parent *p2 = new Parent();\n  Child *c1 = dynamic_cast<Child *>(p1);\n  Child *c2 = dynamic_cast<Child *>(p2);\n  p1->func1(); // My static type is parent\n  p1->func2(); // My dynamic type is child\n  p2->func1(); // My static type is parent\n  p2->func2(); // My dynamic type is parent\n  c1->func1(); // My static type is child\n  c1->func2(); // My dynamic type is child\n  // c2->func1(); // segmentation fault, because c2 is NULL\n  // c2->func2(); // segmentation fault, because c2 is NULL\n}\n```\n\n### \u591a\u91cd\u7d99\u627f\n\n* \u57fa\u5e95\u30af\u30e9\u30b9\u306e\u30b3\u30f3\u30b9\u30c8\u30e9\u30af\u30bf\u306e\u547c\u3073\u51fa\u3057\u9806\u306f\u57fa\u5e95\u6307\u5b9a\b\u5b50\u306e\u4e26\u3073\u9806\n* \u57fa\u5e95\u30af\u30e9\u30b9\u306e\u30e1\u30f3\u30d0\u540d\u304c\u304b\u3076\u3063\u305f\u3089::\u3067\u660e\u793a\u7684\u306b\u3069\u3063\u3061\u304b\u3092\u6307\u5b9a\n* \u30af\u30ed\u30b9\u30ad\u30e3\u30b9\u30c8: dynamic_cast\u6f14\u7b97\u5b50\u3067\u591a\u91cd\u7d99\u627f\u306e\u57fa\u5e95\u30af\u30e9\u30b9\u9593\u3067\u306e\u30ad\u30e3\u30b9\u30c8\u304c\u53ef\u80fd\u3002\n\n```cpp:multiple_inheritance.cpp\n#include <iostream>\n\nclass Base1 {\npublic:\n  Base1(){std::cout << \"Initializing Base1\" << std::endl;}\n  void func() {std::cout << \"I am Base1\" << std::endl;};\n  void func1() {std::cout << \"Base1 specific implementation\" << std::endl;}\n  virtual void vfunc1() = 0;\n};\n\nclass Base2 {\npublic:\n  Base2(){std::cout << \"Initializing Base2\" << std::endl;}\n  void func() {std::cout << \"I am Base2\" << std::endl;};\n  void func2() {std::cout << \"Base2 specific implementation\" << std::endl;}\n  virtual void vfunc2() = 0;\n};\n\nclass Derived : public Base1, public Base2{ // \u30b3\u30f3\u30b9\u30c8\u30e9\u30af\u30bf\u306e\u547c\u3073\u51fa\u3057\u9806\u306f\u57fa\u5e95\u6307\u5b9a\u3057\u4e26\u3073\u306e\u5ba3\u8a00\u9806\n  void vfunc1() {std::cout << \"Derived implementation of vfunc1\" << std::endl;};\n  void vfunc2() {std::cout << \"Derived implementation of vfunc2\" << std::endl;};\n};\n\nint main() {\n  Derived derived; // Initializing Base1, Initializing Base2\n  derived.Base1::func(); // I am Base1\n  derived.Base2::func(); // I am Base2\n  Base1 *pb1 = new Derived();\n  pb1->func1(); // Base1 specific implementation\n  pb1->vfunc1(); // Derived implementation of vfunc1\n  Base2 *pb2 = dynamic_cast<Base2 *>(pb1); // cross cast\n  pb2->func2(); // Base2 specific implementation\n  pb2->vfunc2(); // Derived implementation ov vfunc2                                                                                                          \n}\n```\n\n\u4eee\u60f3\u7d99\u627f\u3068\u3044\u3046\u306e\u3082\u3042\u308b\u3089\u3057\u3044\u304c\u3084\u3084\u3053\u3057\u3059\u304e\u3066\u6483\u6c88\u3002\n\n### explicit \u30b3\u30f3\u30b9\u30c8\u30e9\u30af\u30bf\n\u5f15\u6570\u30921\u3064\u3060\u3051\u3068\u308b\u30b3\u30f3\u30b9\u30c8\u30e9\u30af\u30bf\u3092\u5909\u63db\u30b3\u30f3\u30b9\u30c8\u30e9\u30af\u30bf(converting constructor)\u3068\u547c\u3076\u3002\n\u5909\u63db\u30b3\u30f3\u30b9\u30c8\u30e9\u30af\u30bf\u3092explicit\u5ba3\u8a00\u3059\u308b\u3053\u3068\u3067\u6697\u9ed9\u306e\u578b\u5909\u63db\u3092\u7981\u6b62\u3067\u304d\u308b\u3002\n\n### \u95a2\u6570\u30dd\u30a4\u30f3\u30bf\n\u5927\u90e8\u5206\u306fC++\u3068\u3044\u3046\u304bC\u306e\u8a71\u3060\u304c\u3001\u3088\u304f\u66f8\u5f0f\u3092\u5fd8\u308c\u308b\u3002\n\n```cpp:func_ptr.cpp\n#include <iostream>\n\nint _single(int i) {return i * 1;}\nint _double(int i) {return i * 2;}\nint _triple(int i) {return i * 3;}\nclass Hoge {\n  int i;\npublic:\n  Hoge(int i): i(i) {};\n  int _single() const {return i * 1;}\n  int _double() const {return i * 2;}\n  int _triple() const {return i * 3;}\n};\n\nint main() {\n  int (*funcPtr)(int) = _single;\n  int (*funcPtrs[])(int) = {_single, _double, _triple};\n  std::cout << funcPtr(1) << std::endl; // 1\n  for(int i = 0; i < 3; i++) {\n    std::cout << funcPtrs[i](1) << std::endl; // 1, 2, 3\n  }\n  // typedef \u3059\u308b\u306e\u304c\u4e00\u822c\u7684\n  typedef int(*FP)(int);\n  FP fp = _double;\n  FP fps[] = {_double, _triple, _single};\n  std::cout << fp(1) << std::endl; // 2\n  for(int i = 0; i < 3; i++) {\n    std::cout << fps[i](1) << std::endl; // 2, 3, 1\n  }\n  // \u30af\u30e9\u30b9\u306e\u30e1\u30f3\u30d0\u95a2\u6570\u3078\u306e\u95a2\u6570\u30dd\u30a4\u30f3\u30bf\n  typedef int(Hoge::*FPHoge)() const;\n  FPHoge fph = &Hoge::_triple;\n  FPHoge fphs[] = {&Hoge::_triple, &Hoge::_single, &Hoge::_double};\n  Hoge hoge(100);\n  std::cout << (hoge.*fph)() << std::endl; // 300\n  for(int i = 0; i < 3; i++) {\n    std::cout << (hoge.*fphs[i])() << std::endl; // 300, 100, 200\n  }\n  Hoge *phoge = new Hoge(200);\n  std::cout << (phoge->*fph)() << std::endl; // 600\n  for(int i = 0; i < 3; i++) {\n    std::cout << (phoge->*fphs[i])() << std::endl; // 600, 200, 400\n  }\n}\n```\n\n### \u305d\u306e\u4ed6tips\n* (C++11) <cstdint>\u30d8\u30c3\u30c0\u306b\u30d3\u30c3\u30c8\u5e45\u6307\u5b9a\u306e\u6574\u6570\u578b\u306e\u5b9a\u7fa9\u304c\u3042\u308b\u3002std::int8_t\u306a\u3069\n* (C++11) \u30b9\u30b3\u30fc\u30d7\u4ed8\u304d enum \u540d\u524d\u7a7a\u9593\u306e\u885d\u7a81\u3092 enum struct Hoge{A, B, C};\u3068\u5ba3\u8a00\u3057Hoge::A\u3068\u3057\u3066\u4f7f\u7528\u3059\u308b\u3053\u3068\u3067\u56de\u907f\u3067\u304d\u308b\u3002\n* \n\n## \u6a19\u6e96\u30e9\u30a4\u30d6\u30e9\u30ea\n### iostream\u306e\u6841\u6570\u6307\u5b9a\n``` c++:iomanip.cpp\n#include <iostream>\n#include <iomanip>\n\nint main() {\n  std::cout << std::setw(2) << std::setfill('0') << 2 << std::endl; // 02\n  std::cout << true << \", \" << std::boolalpha << true << \", \"\n            << std::noboolalpha << true << std::endl; // 1, true, 1\n  std::cout.setf(std::ios_base::fixed);\n  std::cout << std::setprecision(2) << 1.111111 << std::endl; // 1.11\n  std::cout << \"0x\" << std::setw(8) << std::hex << 65535 << std::dec << std::endl; // 0x0000ffff\n}\n```\n\n### chrono \u3067\u306e\u51e6\u7406\u6642\u9593\u8a08\u6e2c\n``` c++:chrono.cpp\n#include <iostream>\n#include <chrono>\n\nint main() {\n  auto start = std::chrono::system_clock::now();\n  // \u91cd\u3044\u51e6\u7406\n  auto end = std::chrono::system_clock::now();\n\n  auto elapsed = end - start;\n  std::cout << std::chrono::duration_cast<std::chrono::milliseconds>(elapsed).count() << std::endl; // ms \u5358\u4f4d\n}\n```\n\n### \u30b3\u30ec\u30af\u30b7\u30e7\u30f3\u306e\u548c\n\n``` c++:sum.cpp\n#include <iostream>\n#include <algorithm>\n\nint main() {\n  int a[10];\n  std::generate(a, a+10, [](){static int i = 0; return i++;}); // 0, 1, 2, ..., 9\n  std::cout << std::accumulate(a, a+10, 0, [](int a, int b) {return a+b;}); // 45\n}\n```\n\n### \u4e71\u6570\n``` c++:random.cpp\n#include <iostream>\n#include <random>\n\nint main() {\n  std::random_device rand; // \u30cf\u30fc\u30c9\u30a6\u30a7\u30a2\u7531\u6765\u306e\u975e\u6c7a\u5b9a\u8ad6\u7684\u4e71\u6570\u3092(\u4f7f\u3048\u308c\u3070)\u4f7f\u3046\u3002\u591a\u5c11\u9045\u3044\u3002\n  std::mt19937 mt(rand()); // \u30e1\u30eb\u30bb\u30f3\u30cc\u30c4\u30a4\u30b9\u30bf (Mersenne twister)\n  std::cout << std::hex << mt() << std::dec << std::endl; // \u4e00\u69d8\u5206\u5e03\u3001\u7bc4\u56f2\u306f [0, 0xffffffff]\n  std::uniform_int_distribution<int> dice6(1, 6);\n  std::cout << std::hex << dice6(mt) << std::endl; // \u96e2\u6563\u4e00\u69d8\u5206\u5e03(discrete uniform distribution)\u3001\u7bc4\u56f2\u306f [1, 6]\n  std::uniform_real_distribution<double> continuous(0.0, 1.0);\n  std::cout << std::hex << continuous(mt) << std::endl; // \u9023\u7d9a\u4e00\u69d8\u5206\u5e03(continuous uniform distribution)\u3001\u7bc4\u56f2\u306f [0, 1)\n  std::normal_distribution<double> normal(0.0, 1.0); // \u30b3\u30f3\u30b9\u30c8\u30e9\u30af\u30bf\u306e\u5f15\u6570\u306f (mean, stdiv)\n  std::cout << normal(mt) << std::endl; // \u6a19\u6e96\u6b63\u898f\u5206\u5e03 (standard normal distribution)\n}\n```\n\n### \u6b63\u898f\u8868\u73fe\n\n```cpp:regex.cpp\n#include <iostream>\n#include <regex>\n\nint main() {\n  std::string str = \"foo0bar1\";\n  std::regex re(\"(.+?)(\\\\d)\");\n  std::smatch result;\n  if(std::regex_search(str, result, re)) {\n    for(auto g : result) {\n      std::cout << g << std::endl; // foo0, foo, 0 (\u30de\u30c3\u30c1\u5168\u4f53, \u5404group)\n    }\n  }\n  std::cout << std::regex_replace(str, re, \"$2$1\") << std::endl; // 0foo1bar\n}\n```\n\n## \u30ea\u30d5\u30a1\u30ec\u30f3\u30b9\n[cpprefjp](http://cpprefjp.github.io/)\n"}