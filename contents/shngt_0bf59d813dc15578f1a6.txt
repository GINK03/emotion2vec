{"context": "\n\nPython+OpenCV\u3067\u9854\u691c\u51fa\uff08\u56de\u8ee2\u4e0d\u5909\uff09\n\u753b\u50cf\u3092\u56de\u8ee2\u3055\u305b\u306a\u304c\u3089\u9854\u691c\u51fa\n\u4e00\u756a\u3044\u3044\u89d2\u5ea6\u306e\u8abf\u6574\u7b49\u306f\u884c\u3063\u3066\u3044\u306a\u3044\n\u5fc5\u8981\u306a\u3089\u4ee5\u4e0b\u3092\u53c2\u8003\u306b\nHeroku + OpenCV\u3067\u7c21\u6613\u9854\u691c\u51faAPI\nFace Detection using Haar Cascades\n\u5165\u529b\u753b\u50cf\u3067\u306f\u306a\u304f\u3001\u30d5\u30a3\u30eb\u30bf\u306e\u307b\u3046\u3092\u56de\u8ee2\u3055\u305b\u3066\u81ea\u52d5\u3067\u691c\u51fa\u3057\u3066\u307b\u3057\u3044\u2026\u2026\n\n\u306f\u307e\u308a\u30dd\u30a4\u30f3\u30c8\n\u753b\u50cf\u51e6\u7406\u306b\u6163\u308c\u3066\u3044\u308b\u4eba\u306a\u3089\u5f53\u305f\u308a\u524d\u306a\u306e\u304b\u3082\u3057\u308c\u306a\u3044\u304c\u3001\u307b\u3068\u3093\u3069\u3084\u3063\u305f\u3053\u3068\u304c\u306a\u3044\u306e\u3067\u7d50\u69cb\u306f\u307e\u3063\u305f\n\u753b\u50cf\u306e\u9ad8\u3055\u3084\u5e45\u3092\u53d6\u5f97\u30fb\u6307\u5b9a\u3059\u308b\u3068\u304d\u306b\u9806\u756a\u304c\u9055\u3046\u3053\u3068\u304c\u3042\u308b\n\nshape\u2026\u9ad8\u3055\uff08rows\uff09\u3001\u5e45\uff08columns\uff09\n\u30a4\u30f3\u30c7\u30c3\u30af\u30b9\u3067\u30b9\u30e9\u30a4\u30b9\u2026[\u9ad8\u3055\u4e0b\u9650\uff08y\uff09 : \u9ad8\u3055\u4e0a\u9650\uff08y+h\uff09, \u5e45\u4e0b\u9650\uff08x\uff09 : \u5e45\u4e0a\u9650\uff08x+w\uff09]\nOpenCV\u306e\u5ea7\u6a19\u6307\u5b9a\uff08\u4e2d\u5fc3\u70b9\u3068\u304b\uff09\u2026\uff08\u6a2a\uff08x\uff09, \u7e26\uff08y\uff09\uff09\n\n\u30c7\u30a3\u30b9\u30d7\u30ec\u30a4\u306e\u5ea7\u6a19\u7cfb\u306fy\u8ef8\u304c\u4e0b\u65b9\u5411\u306a\u306e\u306b\u89d2\u5ea6\u306f\u53cd\u6642\u8a08\u56de\u308a\u306a\u306e\u3067\u3001\u666e\u901a\u306ey\u8ef8\u304c\u4e0a\u65b9\u5411\u306e\u5ea7\u6a19\u7cfb\u306b\u5909\u63db\u3059\u308b\u3068\u6642\u8a08\u56de\u308a\u306b\u56de\u3063\u3066\u3044\u308b\n\n\u30b3\u30fc\u30c9\n\nface_rotate_detect.py\n# -*- coding: utf-8 -*-\n\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nimport cv2, os, sys, imghdr, shutil, math\nimport numpy as np\n\nCWD = os.getcwd()\nDIR_ORIGIN = CWD + '/images/'\nDIR_DESTINATION = CWD + '/faces/'\n\nclassifier = cv2.CascadeClassifier('{python_dir}/{classifier_dir}/haarcascade_frontalface_alt2.xml'.format(\n    python_dir = os.path.split(sys.executable)[0],\n    classifier_dir = '../share/OpenCV/haarcascades',\n))\n\ndef getFaces(path_full):\n    results = []\n    image = cv2.imread(path_full)\n    gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)\n    rows, cols, colors = image.shape\n    center = tuple(np.array([cols, rows]))\n    # get rotations\n    for angle in range(-90, 91, 5):\n        radian = np.deg2rad(angle)\n        output_height = int(np.absolute(cols * np.sin(radian)) + np.absolute(rows * np.cos(radian)))\n        output_width = int(np.absolute(cols * np.cos(radian)) + np.absolute(rows * np.sin(radian)))\n        output_size = tuple(np.array([output_width, output_height]))\n        # rotate\n        Matrix = cv2.getRotationMatrix2D(center, degree, 1.0)\n        # translate\n        Matrix[0, 2] += (output_width - width) * 0.5\n        Matrix[1, 2] += (output_height - height) * 0.5\n        # warp affine\n        rotated = cv2.warpAffine(gray, Matrix, output_size, flags = cv2.INTER_LINEAR)\n        # detect faces\n        faces = classifier.detectMultiScale(rotated)\n        if len(faces):\n            rotated_color = cv2.warpAffine(image, Matrix, output_size, flags = cv2.INTER_LINEAR)\n            for x, y, w, h in faces:\n                results.append(rotated_color[y : y + h, x : x + w])\n    return results\n\ndef saveFaces(faces):\n    global count\n\n    for face in faces:\n        cv2.imwrite(\n            '{dir_destination}{count}.jpg'.format(dir_destination = DIR_DESTINATION, count = count),\n            face,\n            [cv2.IMWRITE_JPEG_QUALITY, 100]\n        )\n        count += 1\n\ncount = 1\nfor path, subdirs, files in os.walk(DIR_ORIGIN):\n    for name in files:\n        path_full = os.path.join(path, name)\n        if imghdr.what(path_full) in ['jpeg']:\n            saveFaces(getFaces(path_full))\n            print(path_full)\n\n\n# Python+OpenCV\u3067\u9854\u691c\u51fa\uff08\u56de\u8ee2\u4e0d\u5909\uff09\n\n\u753b\u50cf\u3092\u56de\u8ee2\u3055\u305b\u306a\u304c\u3089\u9854\u691c\u51fa\n\u4e00\u756a\u3044\u3044\u89d2\u5ea6\u306e\u8abf\u6574\u7b49\u306f\u884c\u3063\u3066\u3044\u306a\u3044\n\u5fc5\u8981\u306a\u3089\u4ee5\u4e0b\u3092\u53c2\u8003\u306b\n\n[Heroku + OpenCV\u3067\u7c21\u6613\u9854\u691c\u51faAPI](http://memo.sugyan.com/entry/20151203/1449137219)\n\n[Face Detection using Haar Cascades](http://docs.opencv.org/3.0.0/d7/d8b/tutorial_py_face_detection.html)\n\n\u5165\u529b\u753b\u50cf\u3067\u306f\u306a\u304f\u3001\u30d5\u30a3\u30eb\u30bf\u306e\u307b\u3046\u3092\u56de\u8ee2\u3055\u305b\u3066\u81ea\u52d5\u3067\u691c\u51fa\u3057\u3066\u307b\u3057\u3044\u2026\u2026\n\n## \u306f\u307e\u308a\u30dd\u30a4\u30f3\u30c8\n\n\u753b\u50cf\u51e6\u7406\u306b\u6163\u308c\u3066\u3044\u308b\u4eba\u306a\u3089\u5f53\u305f\u308a\u524d\u306a\u306e\u304b\u3082\u3057\u308c\u306a\u3044\u304c\u3001\u307b\u3068\u3093\u3069\u3084\u3063\u305f\u3053\u3068\u304c\u306a\u3044\u306e\u3067\u7d50\u69cb\u306f\u307e\u3063\u305f\n\n\u753b\u50cf\u306e\u9ad8\u3055\u3084\u5e45\u3092\u53d6\u5f97\u30fb\u6307\u5b9a\u3059\u308b\u3068\u304d\u306b\u9806\u756a\u304c\u9055\u3046\u3053\u3068\u304c\u3042\u308b\n\n- shape\u2026\u9ad8\u3055\uff08rows\uff09\u3001\u5e45\uff08columns\uff09\n- \u30a4\u30f3\u30c7\u30c3\u30af\u30b9\u3067\u30b9\u30e9\u30a4\u30b9\u2026[\u9ad8\u3055\u4e0b\u9650\uff08y\uff09 : \u9ad8\u3055\u4e0a\u9650\uff08y+h\uff09, \u5e45\u4e0b\u9650\uff08x\uff09 : \u5e45\u4e0a\u9650\uff08x+w\uff09]\n- OpenCV\u306e\u5ea7\u6a19\u6307\u5b9a\uff08\u4e2d\u5fc3\u70b9\u3068\u304b\uff09\u2026\uff08\u6a2a\uff08x\uff09, \u7e26\uff08y\uff09\uff09\n\n\u30c7\u30a3\u30b9\u30d7\u30ec\u30a4\u306e\u5ea7\u6a19\u7cfb\u306fy\u8ef8\u304c\u4e0b\u65b9\u5411\u306a\u306e\u306b\u89d2\u5ea6\u306f\u53cd\u6642\u8a08\u56de\u308a\u306a\u306e\u3067\u3001\u666e\u901a\u306ey\u8ef8\u304c\u4e0a\u65b9\u5411\u306e\u5ea7\u6a19\u7cfb\u306b\u5909\u63db\u3059\u308b\u3068\u6642\u8a08\u56de\u308a\u306b\u56de\u3063\u3066\u3044\u308b\n\n## \u30b3\u30fc\u30c9\n\n```python:face_rotate_detect.py\n# -*- coding: utf-8 -*-\n\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nimport cv2, os, sys, imghdr, shutil, math\nimport numpy as np\n\nCWD = os.getcwd()\nDIR_ORIGIN = CWD + '/images/'\nDIR_DESTINATION = CWD + '/faces/'\n\nclassifier = cv2.CascadeClassifier('{python_dir}/{classifier_dir}/haarcascade_frontalface_alt2.xml'.format(\n    python_dir = os.path.split(sys.executable)[0],\n    classifier_dir = '../share/OpenCV/haarcascades',\n))\n\ndef getFaces(path_full):\n    results = []\n    image = cv2.imread(path_full)\n    gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)\n    rows, cols, colors = image.shape\n    center = tuple(np.array([cols, rows]))\n    # get rotations\n    for angle in range(-90, 91, 5):\n        radian = np.deg2rad(angle)\n        output_height = int(np.absolute(cols * np.sin(radian)) + np.absolute(rows * np.cos(radian)))\n        output_width = int(np.absolute(cols * np.cos(radian)) + np.absolute(rows * np.sin(radian)))\n        output_size = tuple(np.array([output_width, output_height]))\n        # rotate\n        Matrix = cv2.getRotationMatrix2D(center, degree, 1.0)\n        # translate\n        Matrix[0, 2] += (output_width - width) * 0.5\n        Matrix[1, 2] += (output_height - height) * 0.5\n        # warp affine\n        rotated = cv2.warpAffine(gray, Matrix, output_size, flags = cv2.INTER_LINEAR)\n        # detect faces\n        faces = classifier.detectMultiScale(rotated)\n        if len(faces):\n            rotated_color = cv2.warpAffine(image, Matrix, output_size, flags = cv2.INTER_LINEAR)\n            for x, y, w, h in faces:\n                results.append(rotated_color[y : y + h, x : x + w])\n    return results\n\ndef saveFaces(faces):\n    global count\n\n    for face in faces:\n        cv2.imwrite(\n            '{dir_destination}{count}.jpg'.format(dir_destination = DIR_DESTINATION, count = count),\n            face,\n            [cv2.IMWRITE_JPEG_QUALITY, 100]\n        )\n        count += 1\n\ncount = 1\nfor path, subdirs, files in os.walk(DIR_ORIGIN):\n    for name in files:\n        path_full = os.path.join(path, name)\n        if imghdr.what(path_full) in ['jpeg']:\n            saveFaces(getFaces(path_full))\n            print(path_full)\n```\n", "tags": ["OpenCV", "Python"]}