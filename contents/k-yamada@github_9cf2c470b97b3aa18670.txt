{"context": "\n\nReactiveX/RxSwift\n\nGitHubSignupViewController2.swift\n\nclass GitHubSignupViewController2 : ViewController {\n    @IBOutlet weak var usernameOutlet: UITextField!\n    @IBOutlet weak var usernameValidationOutlet: UILabel!\n\n    @IBOutlet weak var passwordOutlet: UITextField!\n    @IBOutlet weak var passwordValidationOutlet: UILabel!\n\n    @IBOutlet weak var repeatedPasswordOutlet: UITextField!\n    @IBOutlet weak var repeatedPasswordValidationOutlet: UILabel!\n\n    @IBOutlet weak var signupOutlet: UIButton!\n    @IBOutlet weak var signingUpOulet: UIActivityIndicatorView!\n\n    override func viewDidLoad() {\n        super.viewDidLoad()\n\n        let viewModel = GithubSignupViewModel2(\n            input: (\n                username: usernameOutlet.rx.text.asDriver(),\n                password: passwordOutlet.rx.text.asDriver(),\n                repeatedPassword: repeatedPasswordOutlet.rx.text.asDriver(),\n                loginTaps: signupOutlet.rx.tap.asDriver()\n            ),\n            dependency: (\n                API: GitHubDefaultAPI.sharedAPI,\n                validationService: GitHubDefaultValidationService.sharedValidationService,\n                wireframe: DefaultWireframe.sharedInstance\n            )\n        )\n\n        // bind results to  {\n        viewModel.signupEnabled\n            .drive(onNext: { [weak self] valid  in\n                self?.signupOutlet.isEnabled = valid\n                self?.signupOutlet.alpha = valid ? 1.0 : 0.5\n            })\n            .addDisposableTo(disposeBag)\n\n        viewModel.validatedUsername\n            .drive(usernameValidationOutlet.rx.validationResult)\n            .addDisposableTo(disposeBag)\n\n        viewModel.validatedPassword\n            .drive(passwordValidationOutlet.rx.validationResult)\n            .addDisposableTo(disposeBag)\n\n        viewModel.validatedPasswordRepeated\n            .drive(repeatedPasswordValidationOutlet.rx.validationResult)\n            .addDisposableTo(disposeBag)\n\n        viewModel.signingIn\n            .drive(signingUpOulet.rx.animating)\n            .addDisposableTo(disposeBag)\n\n        viewModel.signedIn\n            .drive(onNext: { signedIn in\n                print(\"User signed in \\(signedIn)\")\n            })\n            .addDisposableTo(disposeBag)\n        //}\n\n        let tapBackground = UITapGestureRecognizer()\n        tapBackground.rx.event\n            .subscribe(onNext: { [weak self] _ in\n                self?.view.endEditing(true)\n            })\n            .addDisposableTo(disposeBag)\n        view.addGestureRecognizer(tapBackground)\n    }\n\n    // This is one of the reasons why it's a good idea for disposal to be detached from allocations.\n    // If resources weren't disposed before view controller is being deallocated, signup alert view\n    // could be presented on top of the wrong screen or could crash your app if it was being presented \n    // while navigation stack is popping.\n\n    // This will work well with UINavigationController, but has an assumption that view controller will\n    // never be added as a child view controller. If we didn't recreate the dispose bag here,\n    // then our resources would never be properly released.\n    override func willMove(toParentViewController parent: UIViewController?) {\n        if let parent = parent {\n            assert(parent as? UINavigationController != nil, \"Please read comments\")\n        }\n        else {\n            self.disposeBag = DisposeBag()\n        }\n    }\n\n}\n\nGithubSignupViewModel2.swift\n\nclass GithubSignupViewModel2 {\n    // outputs {\n\n    //\n    let validatedUsername: Driver<ValidationResult>\n    let validatedPassword: Driver<ValidationResult>\n    let validatedPasswordRepeated: Driver<ValidationResult>\n\n    // Is signup button enabled\n    let signupEnabled: Driver<Bool>\n\n    // Has user signed in\n    let signedIn: Driver<Bool>\n\n    // Is signing process in progress\n    let signingIn: Driver<Bool>\n\n    // }\n\n    init(\n        input: (\n            username: Driver<String>,\n            password: Driver<String>,\n            repeatedPassword: Driver<String>,\n            loginTaps: Driver<Void>\n        ),\n        dependency: (\n            API: GitHubAPI,\n            validationService: GitHubValidationService,\n            wireframe: Wireframe\n        )\n    ) {\n        let API = dependency.API\n        let validationService = dependency.validationService\n        let wireframe = dependency.wireframe\n\n        /**\n         Notice how no subscribe call is being made.\n         Everything is just a definition.\n         Pure transformation of input sequences to output sequences.\n\n         When using `Driver`, underlying observable sequence elements are shared because\n         driver automagically adds \"shareReplay(1)\" under the hood.\n\n             .observeOn(MainScheduler.instance)\n             .catchErrorJustReturn(.Failed(message: \"Error contacting server\"))\n\n         ... are squashed into single `.asDriver(onErrorJustReturn: .Failed(message: \"Error contacting server\"))`\n        */\n\n        validatedUsername = input.username\n            .flatMapLatest { username in\n                return validationService.validateUsername(username)\n                    .asDriver(onErrorJustReturn: .failed(message: \"Error contacting server\"))\n            }\n\n        validatedPassword = input.password\n            .map { password in\n                return validationService.validatePassword(password)\n            }\n\n        validatedPasswordRepeated = Driver.combineLatest(input.password, input.repeatedPassword, resultSelector: validationService.validateRepeatedPassword)\n\n        let signingIn = ActivityIndicator()\n        self.signingIn = signingIn.asDriver()\n\n        let usernameAndPassword = Driver.combineLatest(input.username, input.password) { ($0, $1) }\n\n        signedIn = input.loginTaps.withLatestFrom(usernameAndPassword)\n            .flatMapLatest { (username, password) in\n                return API.signup(username, password: password)\n                    .trackActivity(signingIn)\n                    .asDriver(onErrorJustReturn: false)\n            }\n            .flatMapLatest { loggedIn -> Driver<Bool> in\n                let message = loggedIn ? \"Mock: Signed in to GitHub.\" : \"Mock: Sign in to GitHub failed\"\n                return wireframe.promptFor(message, cancelAction: \"OK\", actions: [])\n                    // propagate original value\n                    .map { _ in\n                        loggedIn\n                    }\n                    .asDriver(onErrorJustReturn: false)\n            }\n\n\n        signupEnabled = Driver.combineLatest(\n            validatedUsername,\n            validatedPassword,\n            validatedPasswordRepeated,\n            signingIn\n        )   { username, password, repeatPassword, signingIn in\n                username.isValid &&\n                password.isValid &&\n                repeatPassword.isValid &&\n                !signingIn\n            }\n            .distinctUntilChanged()\n    }\n}\n\n\nsergdort/RxMarvel\n\nHeroesListViewController.swift\n\nclass HeroesListViewController: RxTableViewController {\n   lazy var searchDataSource = RxTableViewSectionedReloadDataSource<HeroCellSection>()\n   lazy var dataSource = RxTableViewSectionedReloadDataSource<HeroCellSection>()\n   lazy var searchContentController = UITableViewController()\n   lazy var searchCotroller: UISearchController = {\n      return UISearchController(searchResultsController: self.searchContentController)\n   }()\n\n   @IBOutlet var rightBarButton: UIBarButtonItem!\n\n   override func viewDidLoad() {\n      super.viewDidLoad()\n      setupDataSource()\n      setupBindings()\n   }\n\n}\n\n//   MARK:Private\n\nextension HeroesListViewController {\n\n   private func setupBindings() {\n      tableView.tableHeaderView = searchCotroller.searchBar\n      let input = HeroListViewModel.Input(searchQuery: searchCotroller.searchBar.rx_text.asObservable(),\n                                          nextPageTrigger: tableView.rx_nextPageTriger,\n                                          searchNextPageTrigger: searchContentController.tableView.rx_nextPageTriger,\n                                          dismissTrigger: rightBarButton.rx_tap.asDriver())\n    let viewModel = HeroListViewModel(input: input,\n                                        api: DefaultHeroAPI())\n\n      viewModel.mainTableItems\n         .drive(tableView.rx_itemsWithDataSource(dataSource))\n         .addDisposableTo(disposableBag)\n\n      viewModel.searchTableItems\n         .drive(searchContentController.tableView.rx_itemsWithDataSource(searchDataSource))\n         .addDisposableTo(disposableBag)\n\n      viewModel.dismissTrigger.asDriver(onErrorJustReturn: ())\n         .driveNext { [weak self] in\n            self?.dismissViewControllerAnimated(true, completion: nil)\n         }\n         .addDisposableTo(disposableBag)\n   }\n\n   private func setupDataSource() {\n      dataSource.configureCell = BindableCellFactory<HeroListTableViewCell, HeroCellData>.configureCellFromNib\n      searchDataSource.configureCell = BindableCellFactory<HeroListTableViewCell, HeroCellData>.configureCellFromNib\n      tableView.dataSource = nil\n      searchContentController.tableView.dataSource = nil\n   }\n\n}\n\nHeroListViewModel.swift\nclass HeroListViewModel {\n    struct Input {\n        let searchQuery: Observable<String>\n        let nextPageTrigger: Observable<Void>\n        let searchNextPageTrigger: Observable<Void>\n        let dismissTrigger: Driver<Void>\n    }\n   let mainTableItems: Driver<[HeroCellSection]>\n   let searchTableItems: Driver<[HeroCellSection]>\n   let dismissTrigger: Driver<Void>\n\n    init(input: Input, api: HeroAPI, scheduler: SchedulerType = MainScheduler.instance) {\n\n\n    searchTableItems = input.searchQuery\n        .filter { !$0.isEmpty }.debug(\"filter\")\n        .throttle(0.3, scheduler: scheduler)//2\n        .debug(\"throttle\")\n        .flatMapLatest { //3\n            return api.searchItems($0,\n                batch: Batch.initial,\n                endPoint: EndPoint.Characters,\n                nextBatchTrigger: input.searchNextPageTrigger)\n               .catchError { _ in\n                  return Observable.empty()\n               }\n        }\n        .map { //4\n            return $0.map(HeroCellData.init)\n        }\n        .map {//5\n            return [HeroCellSection(items: $0)]\n        }\n        .asDriver(onErrorJustReturn: [])\n\n\n      mainTableItems = api\n        .paginateItems(Batch.initial,\n            endPoint: EndPoint.Characters,\n            nextBatchTrigger: input.nextPageTrigger)\n        .map {\n            return [HeroCellSection(items: $0.map(HeroCellData.init))]\n        }\n        .asDriver(onErrorJustReturn: [])\n\n\n      dismissTrigger = input.dismissTrigger\n   }\n}\n\n\ndevxoul/RxTodo\n\nTaskEditViewController.swift\nfinal class TaskEditViewController: BaseViewController {\n\n    // MARK: Constants\n\n    struct Metric {\n        static let padding = 15.f\n        static let titleInputCornerRadius = 5.f\n        static let titleInputBorderWidth = 1 / UIScreen.mainScreen().scale\n    }\n\n    struct Font {\n        static let titleLabel = UIFont.systemFontOfSize(14)\n    }\n\n    struct Color {\n        static let titleInputBorder = UIColor.lightGrayColor()\n    }\n\n\n    // MARK: Properties\n\n    let cancelBarButtonItem = UIBarButtonItem(barButtonSystemItem: .Cancel, target: nil, action: Selector())\n    let doneBarButtonItem = UIBarButtonItem(barButtonSystemItem: .Done, target: nil, action: Selector())\n    let titleInput = UITextField().then {\n        $0.autocorrectionType = .No\n        $0.font = Font.titleLabel\n        $0.layer.cornerRadius = Metric.titleInputCornerRadius\n        $0.layer.borderWidth = Metric.titleInputBorderWidth\n        $0.layer.borderColor = Color.titleInputBorder.CGColor\n    }\n\n\n    // MARK: Initializing\n\n    init(viewModel: TaskEditViewModelType) {\n        super.init()\n        self.navigationItem.leftBarButtonItem = self.cancelBarButtonItem\n        self.navigationItem.rightBarButtonItem = self.doneBarButtonItem\n        self.configure(viewModel)\n    }\n\n    required convenience init?(coder aDecoder: NSCoder) {\n        fatalError(\"init(coder:) has not been implemented\")\n    }\n\n\n    // MARK: View Life Cycle\n\n    override func viewDidLoad() {\n        super.viewDidLoad()\n        self.view.backgroundColor = .whiteColor()\n        self.view.addSubview(self.titleInput)\n    }\n\n    override func viewDidAppear(animated: Bool) {\n        super.viewDidAppear(animated)\n        self.titleInput.becomeFirstResponder()\n    }\n\n    override func setupConstraints() {\n        self.titleInput.snp_makeConstraints { make in\n            make.top.equalTo(20 + 44 + Metric.padding)\n            make.left.equalTo(Metric.padding)\n            make.right.equalTo(-Metric.padding)\n        }\n    }\n\n\n    // MARK: Configuring\n\n    private func configure(viewModel: TaskEditViewModelType) {\n        // 2-Way Binding\n        (self.titleInput.rx_text <-> viewModel.title)\n            .addDisposableTo(self.disposeBag)\n\n        // Input\n        self.cancelBarButtonItem.rx_tap\n            .bindTo(viewModel.cancelButtonDidTap)\n            .addDisposableTo(self.disposeBag)\n\n        self.doneBarButtonItem.rx_tap\n            .bindTo(viewModel.doneButtonDidTap)\n            .addDisposableTo(self.disposeBag)\n\n        // Output\n        viewModel.navigationBarTitle\n            .drive(self.navigationItem.rx_title)\n            .addDisposableTo(self.disposeBag)\n\n        viewModel.doneButtonEnabled\n            .drive(self.doneBarButtonItem.rx_enabled)\n            .addDisposableTo(self.disposeBag)\n\n        viewModel.presentCancelAlert\n            .driveNext { [weak self] title, message, leaveTitle, stayTitle in\n                guard let `self` = self else { return }\n                let alertController = UIAlertController(title: title, message: message, preferredStyle: .Alert)\n                let actions = [\n                    UIAlertAction(title: leaveTitle, style: .Destructive) { _ in\n                        viewModel.alertLeaveButtonDidTap.onNext()\n                    },\n                    UIAlertAction(title: stayTitle, style: .Default) { _ in\n                        self.titleInput.becomeFirstResponder()\n                        viewModel.alertStayButtonDidTap.onNext()\n                    }\n                ]\n                actions.forEach(alertController.addAction)\n                self.view.endEditing(true)\n                self.presentViewController(alertController, animated: true, completion: nil)\n            }\n            .addDisposableTo(self.disposeBag)\n\n        viewModel.dismissViewController\n            .driveNext { [weak self] in\n                self?.view.endEditing(true)\n                self?.dismissViewControllerAnimated(true, completion: nil)\n            }\n            .addDisposableTo(self.disposeBag)\n    }\n\n}\n\nTaskEditViewModel.swift\n\nenum TaskEditViewMode {\n    case New\n    case Edit(Task)\n}\n\nprotocol TaskEditViewModelType {\n\n    // 2-Way Binding\n    var title: Variable<String> { get }\n\n    // Input\n    var cancelButtonDidTap: PublishSubject<Void> { get }\n    var doneButtonDidTap: PublishSubject<Void> { get }\n    var alertLeaveButtonDidTap: PublishSubject<Void> { get }\n    var alertStayButtonDidTap: PublishSubject<Void> { get }\n    var memo: PublishSubject<String> { get }\n\n    // Output\n    var navigationBarTitle: Driver<String?> { get }\n    var doneButtonEnabled: Driver<Bool> { get }\n    var presentCancelAlert: Driver<(String, String, String, String)> { get }\n    var dismissViewController: Driver<Void> { get }\n\n}\n\nstruct TaskEditViewModel: TaskEditViewModelType {\n\n    // MARK: 2-Way Binding\n\n    var title: Variable<String>\n\n\n    // MARK: Input\n\n    let cancelButtonDidTap = PublishSubject<Void>()\n    let doneButtonDidTap = PublishSubject<Void>()\n    let alertLeaveButtonDidTap = PublishSubject<Void>()\n    let alertStayButtonDidTap = PublishSubject<Void>()\n    let memo = PublishSubject<String>()\n\n\n    // MARK: Output\n\n    let navigationBarTitle: Driver<String?>\n    let doneButtonEnabled: Driver<Bool>\n    let presentCancelAlert: Driver<(String, String, String, String)>\n    let dismissViewController: Driver<Void>\n\n\n    // MARK: Private\n\n    let disposeBag = DisposeBag()\n\n\n    // MARK: Initializing\n\n    init(mode: TaskEditViewMode) {\n        switch mode {\n        case .New:\n            self.navigationBarTitle = .just(\"New\")\n            self.title = Variable(\"\")\n\n        case .Edit(let task):\n            self.navigationBarTitle = .just(\"Edit\")\n            self.title = Variable(task.title)\n        }\n\n        self.doneButtonEnabled = self.title.asDriver()\n            .map { !$0.isEmpty }\n            .asDriver(onErrorJustReturn: false)\n            .startWith(false)\n            .distinctUntilChanged()\n\n        let needsPresentCancelAlert = self.cancelButtonDidTap.asDriver()\n            .withLatestFrom(self.title.asDriver())\n            .map { title -> Bool in\n                switch mode {\n                case .New: return !title.isEmpty\n                case .Edit(let task): return title != task.title\n                }\n            }\n\n        self.presentCancelAlert = needsPresentCancelAlert\n            .filter { $0 }\n            .map { _ in\n                let title = \"Really?\"\n                let message = \"Changes will be lost.\"\n                return (title, message, \"Leave\", \"Stay\")\n            }\n\n        let didDone = self.doneButtonDidTap.asDriver()\n            .withLatestFrom(self.doneButtonEnabled).filter { $0 }\n            .map { _ in Void() }\n\n        switch mode {\n        case .New:\n            didDone\n                .withLatestFrom(self.title.asDriver())\n                .map { title in\n                    Task(title: title)\n                }\n                .drive(Task.didCreate)\n                .addDisposableTo(self.disposeBag)\n\n        case .Edit(let task):\n            didDone\n                .withLatestFrom(self.title.asDriver())\n                .map { title in\n                    task.then {\n                        $0.title = title\n                    }\n                }\n                .drive(Task.didUpdate)\n                .addDisposableTo(self.disposeBag)\n        }\n\n        self.dismissViewController = Driver.of(self.alertLeaveButtonDidTap.asDriver(), didDone,\n                                               needsPresentCancelAlert.filter { !$0 }.map { _ in Void() }).merge()\n    }\n\n}\n\n\n\n\n# [ReactiveX/RxSwift](https://github.com/ReactiveX/RxSwift)\n\n[GitHubSignupViewController2.swift](https://github.com/ReactiveX/RxSwift/blob/master/RxExample/RxExample/Examples/GitHubSignup/UsingDriver/GitHubSignupViewController2.swift)\n\n```swift\n\nclass GitHubSignupViewController2 : ViewController {\n    @IBOutlet weak var usernameOutlet: UITextField!\n    @IBOutlet weak var usernameValidationOutlet: UILabel!\n    \n    @IBOutlet weak var passwordOutlet: UITextField!\n    @IBOutlet weak var passwordValidationOutlet: UILabel!\n    \n    @IBOutlet weak var repeatedPasswordOutlet: UITextField!\n    @IBOutlet weak var repeatedPasswordValidationOutlet: UILabel!\n    \n    @IBOutlet weak var signupOutlet: UIButton!\n    @IBOutlet weak var signingUpOulet: UIActivityIndicatorView!\n\n    override func viewDidLoad() {\n        super.viewDidLoad()\n\n        let viewModel = GithubSignupViewModel2(\n            input: (\n                username: usernameOutlet.rx.text.asDriver(),\n                password: passwordOutlet.rx.text.asDriver(),\n                repeatedPassword: repeatedPasswordOutlet.rx.text.asDriver(),\n                loginTaps: signupOutlet.rx.tap.asDriver()\n            ),\n            dependency: (\n                API: GitHubDefaultAPI.sharedAPI,\n                validationService: GitHubDefaultValidationService.sharedValidationService,\n                wireframe: DefaultWireframe.sharedInstance\n            )\n        )\n\n        // bind results to  {\n        viewModel.signupEnabled\n            .drive(onNext: { [weak self] valid  in\n                self?.signupOutlet.isEnabled = valid\n                self?.signupOutlet.alpha = valid ? 1.0 : 0.5\n            })\n            .addDisposableTo(disposeBag)\n\n        viewModel.validatedUsername\n            .drive(usernameValidationOutlet.rx.validationResult)\n            .addDisposableTo(disposeBag)\n\n        viewModel.validatedPassword\n            .drive(passwordValidationOutlet.rx.validationResult)\n            .addDisposableTo(disposeBag)\n\n        viewModel.validatedPasswordRepeated\n            .drive(repeatedPasswordValidationOutlet.rx.validationResult)\n            .addDisposableTo(disposeBag)\n\n        viewModel.signingIn\n            .drive(signingUpOulet.rx.animating)\n            .addDisposableTo(disposeBag)\n\n        viewModel.signedIn\n            .drive(onNext: { signedIn in\n                print(\"User signed in \\(signedIn)\")\n            })\n            .addDisposableTo(disposeBag)\n        //}\n\n        let tapBackground = UITapGestureRecognizer()\n        tapBackground.rx.event\n            .subscribe(onNext: { [weak self] _ in\n                self?.view.endEditing(true)\n            })\n            .addDisposableTo(disposeBag)\n        view.addGestureRecognizer(tapBackground)\n    }\n   \n    // This is one of the reasons why it's a good idea for disposal to be detached from allocations.\n    // If resources weren't disposed before view controller is being deallocated, signup alert view\n    // could be presented on top of the wrong screen or could crash your app if it was being presented \n    // while navigation stack is popping.\n    \n    // This will work well with UINavigationController, but has an assumption that view controller will\n    // never be added as a child view controller. If we didn't recreate the dispose bag here,\n    // then our resources would never be properly released.\n    override func willMove(toParentViewController parent: UIViewController?) {\n        if let parent = parent {\n            assert(parent as? UINavigationController != nil, \"Please read comments\")\n        }\n        else {\n            self.disposeBag = DisposeBag()\n        }\n    }\n\n}\n```\n\n[GithubSignupViewModel2.swift](https://github.com/ReactiveX/RxSwift/blob/master/RxExample/RxExample/Examples/GitHubSignup/UsingDriver/GithubSignupViewModel2.swift)\n\n```swift\n\nclass GithubSignupViewModel2 {\n    // outputs {\n\n    //\n    let validatedUsername: Driver<ValidationResult>\n    let validatedPassword: Driver<ValidationResult>\n    let validatedPasswordRepeated: Driver<ValidationResult>\n\n    // Is signup button enabled\n    let signupEnabled: Driver<Bool>\n\n    // Has user signed in\n    let signedIn: Driver<Bool>\n\n    // Is signing process in progress\n    let signingIn: Driver<Bool>\n\n    // }\n\n    init(\n        input: (\n            username: Driver<String>,\n            password: Driver<String>,\n            repeatedPassword: Driver<String>,\n            loginTaps: Driver<Void>\n        ),\n        dependency: (\n            API: GitHubAPI,\n            validationService: GitHubValidationService,\n            wireframe: Wireframe\n        )\n    ) {\n        let API = dependency.API\n        let validationService = dependency.validationService\n        let wireframe = dependency.wireframe\n\n        /**\n         Notice how no subscribe call is being made.\n         Everything is just a definition.\n         Pure transformation of input sequences to output sequences.\n\n         When using `Driver`, underlying observable sequence elements are shared because\n         driver automagically adds \"shareReplay(1)\" under the hood.\n\n             .observeOn(MainScheduler.instance)\n             .catchErrorJustReturn(.Failed(message: \"Error contacting server\"))\n\n         ... are squashed into single `.asDriver(onErrorJustReturn: .Failed(message: \"Error contacting server\"))`\n        */\n\n        validatedUsername = input.username\n            .flatMapLatest { username in\n                return validationService.validateUsername(username)\n                    .asDriver(onErrorJustReturn: .failed(message: \"Error contacting server\"))\n            }\n\n        validatedPassword = input.password\n            .map { password in\n                return validationService.validatePassword(password)\n            }\n\n        validatedPasswordRepeated = Driver.combineLatest(input.password, input.repeatedPassword, resultSelector: validationService.validateRepeatedPassword)\n\n        let signingIn = ActivityIndicator()\n        self.signingIn = signingIn.asDriver()\n\n        let usernameAndPassword = Driver.combineLatest(input.username, input.password) { ($0, $1) }\n\n        signedIn = input.loginTaps.withLatestFrom(usernameAndPassword)\n            .flatMapLatest { (username, password) in\n                return API.signup(username, password: password)\n                    .trackActivity(signingIn)\n                    .asDriver(onErrorJustReturn: false)\n            }\n            .flatMapLatest { loggedIn -> Driver<Bool> in\n                let message = loggedIn ? \"Mock: Signed in to GitHub.\" : \"Mock: Sign in to GitHub failed\"\n                return wireframe.promptFor(message, cancelAction: \"OK\", actions: [])\n                    // propagate original value\n                    .map { _ in\n                        loggedIn\n                    }\n                    .asDriver(onErrorJustReturn: false)\n            }\n\n\n        signupEnabled = Driver.combineLatest(\n            validatedUsername,\n            validatedPassword,\n            validatedPasswordRepeated,\n            signingIn\n        )   { username, password, repeatPassword, signingIn in\n                username.isValid &&\n                password.isValid &&\n                repeatPassword.isValid &&\n                !signingIn\n            }\n            .distinctUntilChanged()\n    }\n}\n```\n\n# [sergdort/RxMarvel](https://github.com/sergdort/RxMarvel)\n\n[HeroesListViewController.swift](https://github.com/sergdort/RxMarvel/blob/master/FunctionalMarvel/ViewControllers/HeroesListViewController.swift)\n\n```swift\n\nclass HeroesListViewController: RxTableViewController {\n   lazy var searchDataSource = RxTableViewSectionedReloadDataSource<HeroCellSection>()\n   lazy var dataSource = RxTableViewSectionedReloadDataSource<HeroCellSection>()\n   lazy var searchContentController = UITableViewController()\n   lazy var searchCotroller: UISearchController = {\n      return UISearchController(searchResultsController: self.searchContentController)\n   }()\n   \n   @IBOutlet var rightBarButton: UIBarButtonItem!\n   \n   override func viewDidLoad() {\n      super.viewDidLoad()\n      setupDataSource()\n      setupBindings()\n   }\n   \n}\n\n//   MARK:Private\n\nextension HeroesListViewController {\n   \n   private func setupBindings() {\n      tableView.tableHeaderView = searchCotroller.searchBar\n      let input = HeroListViewModel.Input(searchQuery: searchCotroller.searchBar.rx_text.asObservable(),\n                                          nextPageTrigger: tableView.rx_nextPageTriger,\n                                          searchNextPageTrigger: searchContentController.tableView.rx_nextPageTriger,\n                                          dismissTrigger: rightBarButton.rx_tap.asDriver())\n    let viewModel = HeroListViewModel(input: input,\n                                        api: DefaultHeroAPI())\n    \n      viewModel.mainTableItems\n         .drive(tableView.rx_itemsWithDataSource(dataSource))\n         .addDisposableTo(disposableBag)\n      \n      viewModel.searchTableItems\n         .drive(searchContentController.tableView.rx_itemsWithDataSource(searchDataSource))\n         .addDisposableTo(disposableBag)\n      \n      viewModel.dismissTrigger.asDriver(onErrorJustReturn: ())\n         .driveNext { [weak self] in\n            self?.dismissViewControllerAnimated(true, completion: nil)\n         }\n         .addDisposableTo(disposableBag)\n   }\n   \n   private func setupDataSource() {\n      dataSource.configureCell = BindableCellFactory<HeroListTableViewCell, HeroCellData>.configureCellFromNib\n      searchDataSource.configureCell = BindableCellFactory<HeroListTableViewCell, HeroCellData>.configureCellFromNib\n      tableView.dataSource = nil\n      searchContentController.tableView.dataSource = nil\n   }\n   \n}\n```\n\n[HeroListViewModel.swift](https://github.com/sergdort/RxMarvel/blob/master/FunctionalMarvel/ViewModels/HeroListViewModel.swift)\n\n```swift\nclass HeroListViewModel {\n    struct Input {\n        let searchQuery: Observable<String>\n        let nextPageTrigger: Observable<Void>\n        let searchNextPageTrigger: Observable<Void>\n        let dismissTrigger: Driver<Void>\n    }\n   let mainTableItems: Driver<[HeroCellSection]>\n   let searchTableItems: Driver<[HeroCellSection]>\n   let dismissTrigger: Driver<Void>\n   \n    init(input: Input, api: HeroAPI, scheduler: SchedulerType = MainScheduler.instance) {\n    \n    \n    searchTableItems = input.searchQuery\n        .filter { !$0.isEmpty }.debug(\"filter\")\n        .throttle(0.3, scheduler: scheduler)//2\n        .debug(\"throttle\")\n        .flatMapLatest { //3\n            return api.searchItems($0,\n                batch: Batch.initial,\n                endPoint: EndPoint.Characters,\n                nextBatchTrigger: input.searchNextPageTrigger)\n               .catchError { _ in\n                  return Observable.empty()\n               }\n        }\n        .map { //4\n            return $0.map(HeroCellData.init)\n        }\n        .map {//5\n            return [HeroCellSection(items: $0)]\n        }\n        .asDriver(onErrorJustReturn: [])\n    \n\n      mainTableItems = api\n        .paginateItems(Batch.initial,\n            endPoint: EndPoint.Characters,\n            nextBatchTrigger: input.nextPageTrigger)\n        .map {\n            return [HeroCellSection(items: $0.map(HeroCellData.init))]\n        }\n        .asDriver(onErrorJustReturn: [])\n\n    \n      dismissTrigger = input.dismissTrigger\n   }\n}\n```\n\n# [devxoul/RxTodo](https://github.com/devxoul/RxTodo)\n\n[TaskEditViewController.swift](https://github.com/devxoul/RxTodo/blob/master/RxTodo/Sources/ViewControllers/TaskEditViewController.swift)\n\n```swift\nfinal class TaskEditViewController: BaseViewController {\n\n    // MARK: Constants\n\n    struct Metric {\n        static let padding = 15.f\n        static let titleInputCornerRadius = 5.f\n        static let titleInputBorderWidth = 1 / UIScreen.mainScreen().scale\n    }\n\n    struct Font {\n        static let titleLabel = UIFont.systemFontOfSize(14)\n    }\n\n    struct Color {\n        static let titleInputBorder = UIColor.lightGrayColor()\n    }\n\n\n    // MARK: Properties\n\n    let cancelBarButtonItem = UIBarButtonItem(barButtonSystemItem: .Cancel, target: nil, action: Selector())\n    let doneBarButtonItem = UIBarButtonItem(barButtonSystemItem: .Done, target: nil, action: Selector())\n    let titleInput = UITextField().then {\n        $0.autocorrectionType = .No\n        $0.font = Font.titleLabel\n        $0.layer.cornerRadius = Metric.titleInputCornerRadius\n        $0.layer.borderWidth = Metric.titleInputBorderWidth\n        $0.layer.borderColor = Color.titleInputBorder.CGColor\n    }\n\n\n    // MARK: Initializing\n\n    init(viewModel: TaskEditViewModelType) {\n        super.init()\n        self.navigationItem.leftBarButtonItem = self.cancelBarButtonItem\n        self.navigationItem.rightBarButtonItem = self.doneBarButtonItem\n        self.configure(viewModel)\n    }\n    \n    required convenience init?(coder aDecoder: NSCoder) {\n        fatalError(\"init(coder:) has not been implemented\")\n    }\n\n\n    // MARK: View Life Cycle\n\n    override func viewDidLoad() {\n        super.viewDidLoad()\n        self.view.backgroundColor = .whiteColor()\n        self.view.addSubview(self.titleInput)\n    }\n\n    override func viewDidAppear(animated: Bool) {\n        super.viewDidAppear(animated)\n        self.titleInput.becomeFirstResponder()\n    }\n\n    override func setupConstraints() {\n        self.titleInput.snp_makeConstraints { make in\n            make.top.equalTo(20 + 44 + Metric.padding)\n            make.left.equalTo(Metric.padding)\n            make.right.equalTo(-Metric.padding)\n        }\n    }\n\n\n    // MARK: Configuring\n\n    private func configure(viewModel: TaskEditViewModelType) {\n        // 2-Way Binding\n        (self.titleInput.rx_text <-> viewModel.title)\n            .addDisposableTo(self.disposeBag)\n\n        // Input\n        self.cancelBarButtonItem.rx_tap\n            .bindTo(viewModel.cancelButtonDidTap)\n            .addDisposableTo(self.disposeBag)\n\n        self.doneBarButtonItem.rx_tap\n            .bindTo(viewModel.doneButtonDidTap)\n            .addDisposableTo(self.disposeBag)\n\n        // Output\n        viewModel.navigationBarTitle\n            .drive(self.navigationItem.rx_title)\n            .addDisposableTo(self.disposeBag)\n\n        viewModel.doneButtonEnabled\n            .drive(self.doneBarButtonItem.rx_enabled)\n            .addDisposableTo(self.disposeBag)\n\n        viewModel.presentCancelAlert\n            .driveNext { [weak self] title, message, leaveTitle, stayTitle in\n                guard let `self` = self else { return }\n                let alertController = UIAlertController(title: title, message: message, preferredStyle: .Alert)\n                let actions = [\n                    UIAlertAction(title: leaveTitle, style: .Destructive) { _ in\n                        viewModel.alertLeaveButtonDidTap.onNext()\n                    },\n                    UIAlertAction(title: stayTitle, style: .Default) { _ in\n                        self.titleInput.becomeFirstResponder()\n                        viewModel.alertStayButtonDidTap.onNext()\n                    }\n                ]\n                actions.forEach(alertController.addAction)\n                self.view.endEditing(true)\n                self.presentViewController(alertController, animated: true, completion: nil)\n            }\n            .addDisposableTo(self.disposeBag)\n\n        viewModel.dismissViewController\n            .driveNext { [weak self] in\n                self?.view.endEditing(true)\n                self?.dismissViewControllerAnimated(true, completion: nil)\n            }\n            .addDisposableTo(self.disposeBag)\n    }\n\n}\n```\n\n\n[TaskEditViewModel.swift](https://github.com/devxoul/RxTodo/blob/master/RxTodo/Sources/ViewControllers/TaskEditViewModel.swift)\n\n```swift\n\nenum TaskEditViewMode {\n    case New\n    case Edit(Task)\n}\n\nprotocol TaskEditViewModelType {\n\n    // 2-Way Binding\n    var title: Variable<String> { get }\n\n    // Input\n    var cancelButtonDidTap: PublishSubject<Void> { get }\n    var doneButtonDidTap: PublishSubject<Void> { get }\n    var alertLeaveButtonDidTap: PublishSubject<Void> { get }\n    var alertStayButtonDidTap: PublishSubject<Void> { get }\n    var memo: PublishSubject<String> { get }\n\n    // Output\n    var navigationBarTitle: Driver<String?> { get }\n    var doneButtonEnabled: Driver<Bool> { get }\n    var presentCancelAlert: Driver<(String, String, String, String)> { get }\n    var dismissViewController: Driver<Void> { get }\n\n}\n\nstruct TaskEditViewModel: TaskEditViewModelType {\n\n    // MARK: 2-Way Binding\n\n    var title: Variable<String>\n\n\n    // MARK: Input\n\n    let cancelButtonDidTap = PublishSubject<Void>()\n    let doneButtonDidTap = PublishSubject<Void>()\n    let alertLeaveButtonDidTap = PublishSubject<Void>()\n    let alertStayButtonDidTap = PublishSubject<Void>()\n    let memo = PublishSubject<String>()\n\n\n    // MARK: Output\n\n    let navigationBarTitle: Driver<String?>\n    let doneButtonEnabled: Driver<Bool>\n    let presentCancelAlert: Driver<(String, String, String, String)>\n    let dismissViewController: Driver<Void>\n\n\n    // MARK: Private\n\n    let disposeBag = DisposeBag()\n\n\n    // MARK: Initializing\n\n    init(mode: TaskEditViewMode) {\n        switch mode {\n        case .New:\n            self.navigationBarTitle = .just(\"New\")\n            self.title = Variable(\"\")\n\n        case .Edit(let task):\n            self.navigationBarTitle = .just(\"Edit\")\n            self.title = Variable(task.title)\n        }\n\n        self.doneButtonEnabled = self.title.asDriver()\n            .map { !$0.isEmpty }\n            .asDriver(onErrorJustReturn: false)\n            .startWith(false)\n            .distinctUntilChanged()\n\n        let needsPresentCancelAlert = self.cancelButtonDidTap.asDriver()\n            .withLatestFrom(self.title.asDriver())\n            .map { title -> Bool in\n                switch mode {\n                case .New: return !title.isEmpty\n                case .Edit(let task): return title != task.title\n                }\n            }\n\n        self.presentCancelAlert = needsPresentCancelAlert\n            .filter { $0 }\n            .map { _ in\n                let title = \"Really?\"\n                let message = \"Changes will be lost.\"\n                return (title, message, \"Leave\", \"Stay\")\n            }\n\n        let didDone = self.doneButtonDidTap.asDriver()\n            .withLatestFrom(self.doneButtonEnabled).filter { $0 }\n            .map { _ in Void() }\n\n        switch mode {\n        case .New:\n            didDone\n                .withLatestFrom(self.title.asDriver())\n                .map { title in\n                    Task(title: title)\n                }\n                .drive(Task.didCreate)\n                .addDisposableTo(self.disposeBag)\n\n        case .Edit(let task):\n            didDone\n                .withLatestFrom(self.title.asDriver())\n                .map { title in\n                    task.then {\n                        $0.title = title\n                    }\n                }\n                .drive(Task.didUpdate)\n                .addDisposableTo(self.disposeBag)\n        }\n\n        self.dismissViewController = Driver.of(self.alertLeaveButtonDidTap.asDriver(), didDone,\n                                               needsPresentCancelAlert.filter { !$0 }.map { _ in Void() }).merge()\n    }\n\n}\n\n```\n", "tags": ["RxSwift"]}