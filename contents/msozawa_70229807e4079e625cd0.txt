{"context": "\u3053\u3093\u306b\u3061\u306f\u3002\n\u4ee5\u524d\u3001\u4eee\u60f3\u30a2\u30d7\u30e9\u30a4\u30a2\u30f3\u30b9\u306e\u691c\u8a3c\u306e\u305f\u3081\u3001C\u306e\u30bd\u30b1\u30c3\u30c8\u30e9\u30a4\u30d6\u30e9\u30ea\u3092\u4f7f\u3063\u3066TCP\u30b5\u30fc\u30d0\u3092\u4f5c\u3063\u305f\u3082\u306e\u304c\u3042\u308a\u307e\u3057\u305f\u3002\u3054\u304f\u3054\u304f\u4e00\u822c\u7684\u306a\u30bd\u30b1\u30c3\u30c8\u30d7\u30ed\u30b0\u30e9\u30e0\u3067\u4e14\u3064\u3001\u4f8b\u306b\u3088\u3063\u3066\u30c4\u30fc\u30eb\u306e\u305f\u3081\u3042\u307e\u308a\u30d0\u30c3\u30d5\u30a1\u30b5\u30a4\u30ba\u7b49\u306e\u8003\u616e\u3084\u5b9a\u6570\u5b9a\u7fa9\u3082\u3057\u304d\u308c\u3066\u3044\u307e\u305b\u3093\u304c\u3001\u53c2\u8003\u306b\u306a\u308b\u65b9\u304c\u3044\u308c\u3070\u5e78\u3044\u3067\u3059\u3002\n\u3064\u3044\u3067\u306b\u3001HEX/ASCII\u30c0\u30f3\u30d7\u3082\u51fa\u3059\u3088\u3046\u306b\u3057\u3066\u3044\u307e\u3059\u3002\n\n\u30b3\u30fc\u30c9\u30b5\u30f3\u30d7\u30eb\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <unistd.h>\n\n#define  BUFSIZE  2048\n#define  OK          0\n#define  NG         -1\n\n\n/* display string HEX dump and ascii */\nvoid dumpStr( char * pcStr )\n{\n    char sBuf[2048];\n    int  iCnt = 0;\n    int  iCnt2 = 0;\n    char sDispBuf[80];\n\n    memset( sBuf, 0x00, sizeof(sBuf) );\n    if ( pcStr != NULL ) {\n        strcpy( sBuf, pcStr ); \n    }\n    memset( sDispBuf, ' ', sizeof(sDispBuf) );\n    sDispBuf[sizeof(sDispBuf)-1] = 0x00;\n\n    while ( 1 )\n    {\n        if ( sBuf[iCnt] == '\\0' ) {\n            printf( \"%s\\n\", sDispBuf );\n            break;\n        }\n\n        sprintf( &sDispBuf[iCnt2 * 3], \"%2.02x \", sBuf[iCnt] );\n        sDispBuf[(iCnt2*3)+3] = ' ';\n        if ( \n          ( sBuf[iCnt] == '\\r' ) || \n          ( sBuf[iCnt] == ' ' ) || \n          ( sBuf[iCnt] == '\\t' ) || \n          ( sBuf[iCnt] == '\\n' ) )\n        {\n            sDispBuf[iCnt2+50] = '.';\n        } else {\n            sDispBuf[iCnt2+50] = sBuf[iCnt];\n        }\n\n        iCnt ++;\n        iCnt2 ++;\n\n        if ( ( iCnt % 16 ) == 0 ) {\n            printf( \"%s\\n\", sDispBuf );\n            memset( sDispBuf, ' ', sizeof(sDispBuf) );\n            sDispBuf[sizeof(sDispBuf)-1] = 0x00;\n            iCnt2 = 0;\n        }\n    }\n\n    return;\n}\n\n\n/* main() */\nint main( int ac, char *av[] )\n{\n    int iSoc;\n    struct sockaddr_in stAddr;\n    struct sockaddr_in stClient;\n    socklen_t iLen;\n    int iClSoc;\n    struct timeval stTO;\n    int iPort = 0;\n\n    char sBuf [BUFSIZE];\n\n    stTO.tv_sec = 1;\n    stTO.tv_usec = 0;\n\n    /* parameter check */\n    if ( ac != 2 ) {\n        perror( \"you must set 1st parameter as port number.\" );\n        return ( NG );\n    } else {\n        if ( ( iPort = atoi( av[1] ) ) == 0 ) {\n            perror( \"you must set 1st parameter as port number.\" );\n            return ( NG );\n        }\n    }\n\n    /* create listen socket */\n    iSoc = socket( AF_INET, SOCK_STREAM, 0 );\n    if ( iSoc < 0 )\n    {\n        perror( \"socket()\" );\n        return ( NG );\n    }\n\n    stAddr.sin_family = AF_INET;\n    stAddr.sin_port = htons( iPort );\n    stAddr.sin_addr.s_addr = INADDR_ANY;\n\n    /* set socket option */\n    setsockopt( iSoc, SOL_SOCKET, SO_REUSEADDR, (const char *)&stTO, sizeof(struct timeval) );\n\n    /* bind address to socket */\n    if ( bind( iSoc, (struct sockaddr *)&stAddr, sizeof(stAddr) ) != 0 )\n    {\n        perror( \"bind()\" );\n        return ( NG );\n    }\n\n    /* listen using socket */\n    if ( listen( iSoc, 10 ) != 0 )\n    {\n        perror( \"listen()\" );\n        return ( NG );\n    }\n\n    while ( 1 )\n    {\n        /* accept from client */\n        iLen = sizeof( stClient );\n        iClSoc = accept( iSoc, (struct sockaddr *)&stClient, &iLen );\n        if ( iClSoc < 0 )\n        {\n            perror( \"accept()\" );\n            break;\n        }\n\n        memset( sBuf, 0x00, sizeof(sBuf) );\n        recv( iClSoc, sBuf, sizeof(sBuf), 0 );\n#if 0\n        printf( \"%s\", sBuf );\n#else\n        dumpStr( sBuf );\n#endif\n\n        send( iClSoc, sBuf, (int)strlen( sBuf ), 0 );\n\n        close( iClSoc );\n    }\n\n    close( iSoc );\n\n    return OK;\n}\n\n\n\u5b9f\u884c\u7d50\u679c\nPC\u306e\u30d6\u30e9\u30a6\u30b6\u304b\u3089\u3001[IP\u30a2\u30c9\u30ec\u30b9:\u30dd\u30fc\u30c8\u756a\u53f7]\u6307\u5b9a\u3067\u30a2\u30af\u30bb\u30b9\u3057\u3066\u307f\u307e\u3059\u3002\n$ ./tcps_command 12345\n47 45 54 20 2f 20 48 54 54 50 2f 31 2e 31 0d 0a   GET./.HTTP/1.1..             \n48 6f 73 74 3a 20 31 32 37 2e 30 2e 30 2e 31 3a   Host:.127.0.0.1:             \n31 32 33 34 35 0d 0a 43 6f 6e 6e 65 63 74 69 6f   12345..Connectio             \n6e 3a 20 6b 65 65 70 2d 61 6c 69 76 65 0d 0a 55   n:.keep-alive..U             \n70 67 72 61 64 65 2d 49 6e 73 65 63 75 72 65 2d   pgrade-Insecure-             \n52 65 71 75 65 73 74 73 3a 20 31 0d 0a 55 73 65   Requests:.1..Use             \n72 2d 41 67 65 6e 74 3a 20 4d 6f 7a 69 6c 6c 61   r-Agent:.Mozilla             \n2f 35 2e 30 20 28 4d 61 63 69 6e 74 6f 73 68 3b   /5.0.(Macintosh;             \n20 49 6e 74 65 6c 20 4d 61 63 20 4f 53 20 58 20   .Intel.Mac.OS.X.   \n(\u4ee5\u4e0b\u7565)\n\n\u5de6\u5074\u306bHEX\u30c0\u30f3\u30d7\u3001\u53f3\u5074\u306bASCII\u3067\u51fa\u529b\u3057\u307e\u3059\u3002\n\u4e0d\u53ef\u8996\u6587\u5b57\uff08\u30bf\u30d6\u3001\u30b9\u30da\u30fc\u30b9\u3001\u5fa9\u5e30\u3001\u6539\u884c\uff09\u306f'.'\u306b\u7f6e\u304d\u63db\u3048\u3066\u51fa\u3059\u3088\u3046\u306b\u3057\u3066\u3044\u307e\u3059\u3002\n\u305d\u308c\u3067\u306f\u3002\n\u3053\u3093\u306b\u3061\u306f\u3002\n\n\u4ee5\u524d\u3001\u4eee\u60f3\u30a2\u30d7\u30e9\u30a4\u30a2\u30f3\u30b9\u306e\u691c\u8a3c\u306e\u305f\u3081\u3001C\u306e\u30bd\u30b1\u30c3\u30c8\u30e9\u30a4\u30d6\u30e9\u30ea\u3092\u4f7f\u3063\u3066TCP\u30b5\u30fc\u30d0\u3092\u4f5c\u3063\u305f\u3082\u306e\u304c\u3042\u308a\u307e\u3057\u305f\u3002\u3054\u304f\u3054\u304f\u4e00\u822c\u7684\u306a\u30bd\u30b1\u30c3\u30c8\u30d7\u30ed\u30b0\u30e9\u30e0\u3067\u4e14\u3064\u3001\u4f8b\u306b\u3088\u3063\u3066\u30c4\u30fc\u30eb\u306e\u305f\u3081\u3042\u307e\u308a\u30d0\u30c3\u30d5\u30a1\u30b5\u30a4\u30ba\u7b49\u306e\u8003\u616e\u3084\u5b9a\u6570\u5b9a\u7fa9\u3082\u3057\u304d\u308c\u3066\u3044\u307e\u305b\u3093\u304c\u3001\u53c2\u8003\u306b\u306a\u308b\u65b9\u304c\u3044\u308c\u3070\u5e78\u3044\u3067\u3059\u3002\n\u3064\u3044\u3067\u306b\u3001HEX/ASCII\u30c0\u30f3\u30d7\u3082\u51fa\u3059\u3088\u3046\u306b\u3057\u3066\u3044\u307e\u3059\u3002\n\n# \u30b3\u30fc\u30c9\u30b5\u30f3\u30d7\u30eb\n\n```C\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <unistd.h>\n\n#define  BUFSIZE  2048\n#define  OK          0\n#define  NG         -1\n\n\n/* display string HEX dump and ascii */\nvoid dumpStr( char * pcStr )\n{\n    char sBuf[2048];\n    int  iCnt = 0;\n    int  iCnt2 = 0;\n    char sDispBuf[80];\n\n    memset( sBuf, 0x00, sizeof(sBuf) );\n    if ( pcStr != NULL ) {\n        strcpy( sBuf, pcStr ); \n    }\n    memset( sDispBuf, ' ', sizeof(sDispBuf) );\n    sDispBuf[sizeof(sDispBuf)-1] = 0x00;\n\n    while ( 1 )\n    {\n        if ( sBuf[iCnt] == '\\0' ) {\n            printf( \"%s\\n\", sDispBuf );\n            break;\n        }\n\n        sprintf( &sDispBuf[iCnt2 * 3], \"%2.02x \", sBuf[iCnt] );\n        sDispBuf[(iCnt2*3)+3] = ' ';\n        if ( \n          ( sBuf[iCnt] == '\\r' ) || \n          ( sBuf[iCnt] == ' ' ) || \n          ( sBuf[iCnt] == '\\t' ) || \n          ( sBuf[iCnt] == '\\n' ) )\n        {\n            sDispBuf[iCnt2+50] = '.';\n        } else {\n            sDispBuf[iCnt2+50] = sBuf[iCnt];\n        }\n    \n        iCnt ++;\n        iCnt2 ++;\n\n        if ( ( iCnt % 16 ) == 0 ) {\n            printf( \"%s\\n\", sDispBuf );\n            memset( sDispBuf, ' ', sizeof(sDispBuf) );\n            sDispBuf[sizeof(sDispBuf)-1] = 0x00;\n            iCnt2 = 0;\n        }\n    }\n\n    return;\n}\n\n\n/* main() */\nint main( int ac, char *av[] )\n{\n    int iSoc;\n    struct sockaddr_in stAddr;\n    struct sockaddr_in stClient;\n    socklen_t iLen;\n    int iClSoc;\n    struct timeval stTO;\n    int iPort = 0;\n\n    char sBuf [BUFSIZE];\n\n    stTO.tv_sec = 1;\n    stTO.tv_usec = 0;\n\n    /* parameter check */\n    if ( ac != 2 ) {\n        perror( \"you must set 1st parameter as port number.\" );\n        return ( NG );\n    } else {\n        if ( ( iPort = atoi( av[1] ) ) == 0 ) {\n            perror( \"you must set 1st parameter as port number.\" );\n            return ( NG );\n        }\n    }\n\n    /* create listen socket */\n    iSoc = socket( AF_INET, SOCK_STREAM, 0 );\n    if ( iSoc < 0 )\n    {\n        perror( \"socket()\" );\n        return ( NG );\n    }\n\n    stAddr.sin_family = AF_INET;\n    stAddr.sin_port = htons( iPort );\n    stAddr.sin_addr.s_addr = INADDR_ANY;\n\n    /* set socket option */\n    setsockopt( iSoc, SOL_SOCKET, SO_REUSEADDR, (const char *)&stTO, sizeof(struct timeval) );\n\n    /* bind address to socket */\n    if ( bind( iSoc, (struct sockaddr *)&stAddr, sizeof(stAddr) ) != 0 )\n    {\n        perror( \"bind()\" );\n        return ( NG );\n    }\n\n    /* listen using socket */\n    if ( listen( iSoc, 10 ) != 0 )\n    {\n        perror( \"listen()\" );\n        return ( NG );\n    }\n\n    while ( 1 )\n    {\n        /* accept from client */\n        iLen = sizeof( stClient );\n        iClSoc = accept( iSoc, (struct sockaddr *)&stClient, &iLen );\n        if ( iClSoc < 0 )\n        {\n            perror( \"accept()\" );\n            break;\n        }\n\n        memset( sBuf, 0x00, sizeof(sBuf) );\n        recv( iClSoc, sBuf, sizeof(sBuf), 0 );\n#if 0\n        printf( \"%s\", sBuf );\n#else\n        dumpStr( sBuf );\n#endif\n\n        send( iClSoc, sBuf, (int)strlen( sBuf ), 0 );\n\n        close( iClSoc );\n    }\n\n    close( iSoc );\n\n    return OK;\n}\n```\n\n# \u5b9f\u884c\u7d50\u679c\n\nPC\u306e\u30d6\u30e9\u30a6\u30b6\u304b\u3089\u3001[IP\u30a2\u30c9\u30ec\u30b9:\u30dd\u30fc\u30c8\u756a\u53f7]\u6307\u5b9a\u3067\u30a2\u30af\u30bb\u30b9\u3057\u3066\u307f\u307e\u3059\u3002\n\n```\n$ ./tcps_command 12345\n47 45 54 20 2f 20 48 54 54 50 2f 31 2e 31 0d 0a   GET./.HTTP/1.1..             \n48 6f 73 74 3a 20 31 32 37 2e 30 2e 30 2e 31 3a   Host:.127.0.0.1:             \n31 32 33 34 35 0d 0a 43 6f 6e 6e 65 63 74 69 6f   12345..Connectio             \n6e 3a 20 6b 65 65 70 2d 61 6c 69 76 65 0d 0a 55   n:.keep-alive..U             \n70 67 72 61 64 65 2d 49 6e 73 65 63 75 72 65 2d   pgrade-Insecure-             \n52 65 71 75 65 73 74 73 3a 20 31 0d 0a 55 73 65   Requests:.1..Use             \n72 2d 41 67 65 6e 74 3a 20 4d 6f 7a 69 6c 6c 61   r-Agent:.Mozilla             \n2f 35 2e 30 20 28 4d 61 63 69 6e 74 6f 73 68 3b   /5.0.(Macintosh;             \n20 49 6e 74 65 6c 20 4d 61 63 20 4f 53 20 58 20   .Intel.Mac.OS.X.   \n(\u4ee5\u4e0b\u7565)\n```\n\n\u5de6\u5074\u306bHEX\u30c0\u30f3\u30d7\u3001\u53f3\u5074\u306bASCII\u3067\u51fa\u529b\u3057\u307e\u3059\u3002\n\u4e0d\u53ef\u8996\u6587\u5b57\uff08\u30bf\u30d6\u3001\u30b9\u30da\u30fc\u30b9\u3001\u5fa9\u5e30\u3001\u6539\u884c\uff09\u306f'.'\u306b\u7f6e\u304d\u63db\u3048\u3066\u51fa\u3059\u3088\u3046\u306b\u3057\u3066\u3044\u307e\u3059\u3002\n\n\u305d\u308c\u3067\u306f\u3002\n", "tags": ["C", "TCP"]}