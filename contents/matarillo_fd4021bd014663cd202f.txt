{"context": " More than 1 year has passed since last update.1\u6642\u9593\u4ee5\u5185\u306b\u89e3\u3051\u306a\u3051\u308c\u3070\u30d7\u30ed\u30b0\u30e9\u30de\u5931\u683c\u3068\u306a\u3063\u3066\u3057\u307e\u30465\u3064\u306e\u554f\u984c\u304c\u8a71\u984c\u306b - \u30bd\u30d5\u30c8\u30a2\u30f3\u30c6\u30ca\u30d6\u30ed\u30b0\n\u6b63\u76f4\u306b\u8a00\u3048\u3070\u30011\u6642\u9593\u3067\u306f\u66f8\u3051\u307e\u305b\u3093\u3067\u3057\u305f\u3002\u8981\u7df4\u7fd2\u3067\u3059\u306d\u3002\n\n\u554f\u984c1\n\nfor\u30eb\u30fc\u30d7\u3001while\u30eb\u30fc\u30d7\u3001\u304a\u3088\u3073\u518d\u5e30\u3092\u4f7f\u7528\u3057\u3066\u3001\u30ea\u30b9\u30c8\u5185\u306e\u6570\u5b57\u306e\u5408\u8a08\u3092\u8a08\u7b97\u3059\u308b3\u3064\u306e\u95a2\u6570\u3092\u8a18\u8ff0\u305b\u3088\u3002\n\nF#\u306f\u30df\u30e5\u30fc\u30bf\u30d6\u30eb\u306a\u5909\u6570\u3082\u5b9a\u7fa9\u3067\u304d\u308b\u306e\u3067\u3001for\u30eb\u30fc\u30d7\u3068while\u30eb\u30fc\u30d7\u3067\u306f\u305d\u306e\u3088\u3046\u306a\u66f8\u304d\u65b9\u3092\u308f\u3056\u3068\u3057\u307e\u3057\u305f\u3002\nlet q1_for xs =\n    let mutable sum = 0\n    for i in xs do sum <- sum + i\n    sum\n\nlet q1_while xs =\n    let mutable sum = 0\n    let mutable ys = xs\n    while not (List.isEmpty []) do\n        sum <- sum + List.head ys\n        ys <- List.tail ys\n    sum\n\nlet q1_recc xs =\n    let rec q1_recc acc = function\n    | []    -> acc\n    | y::ys -> q1_recc (acc + y) ys\n    q1_recc 0 xs\n\n\u3067\u3082\u3075\u3064\u3046\u306f List.sum \u95a2\u6570\u3067\u4e00\u767a\u3067\u3059\u3088\u306d\u3002\n\n\u554f\u984c2\n\n\u4ea4\u4e92\u306b\u8981\u7d20\u3092\u53d6\u308b\u3053\u3068\u3067\u30012\u3064\u306e\u30ea\u30b9\u30c8\u3092\u7d50\u5408\u3059\u308b\u95a2\u6570\u3092\u8a18\u8ff0\u305b\u3088\u3002\u4f8b\u3048\u3070 [a, b, c] \u3068 [1, 2, 3] \u3068\u3044\u30462\u3064\u306e\u30ea\u30b9\u30c8\u3092\u4e0e\u3048\u308b\u3068\u3001\u95a2\u6570\u306f [a, 1, b, 2, c, 3] \u3092\u8fd4\u3059\u3002\n\nlet q2_flatZip xs ys =\n    List.zip xs ys |> List.collect (fun (x,y) -> [x; y])\n\n\n\u554f\u984c3\n\n\u6700\u521d\u306e100\u500b\u306e\u30d5\u30a3\u30dc\u30ca\u30c3\u30c1\u6570\u306e\u30ea\u30b9\u30c8\u3092\u8a08\u7b97\u3059\u308b\u95a2\u6570\u3092\u8a18\u8ff0\u305b\u3088\u3002\u5b9a\u7fa9\u3067\u306f\u3001\u30d5\u30a3\u30dc\u30ca\u30c3\u30c1\u6570\u5217\u306e\u6700\u521d\u306e2\u3064\u306e\u6570\u5b57\u306f0\u30681\u3067\u3001\u6b21\u306e\u6570\u306f\u524d\u306e2\u3064\u306e\u5408\u8a08\u3068\u306a\u308b\u3002\u4f8b\u3048\u3070\u6700\u521d\u306e10\u500b\u306e\u30d5\u30a3\u30dc\u30ca\u30c3\u30c1\u6570\u5217\u306f\u30010, 1, 1, 2, 3, 5, 8, 13, 21, 34\u3068\u306a\u308b\u3002\n\n100\u500b\u3068\u3044\u3046\u3053\u3068\u306a\u306e\u3067\u3001\u7b26\u53f7\u306a\u305764\u30d3\u30c3\u30c8\u6574\u6570\u3092\u4f7f\u3044\u307e\u3057\u305f\u3002\nlet q3_fib100 =\n    let fib = Seq.unfold (fun (a, b) -> Some(a, (b, a+b))) (0UL, 1UL)\n    fib |> Seq.take 100 |> Seq.toList\n\n\n\u554f\u984c4\n\n\u6b63\u306e\u6574\u6570\u306e\u30ea\u30b9\u30c8\u3092\u4e0e\u3048\u3089\u308c\u305f\u3068\u304d\u3001\u6570\u3092\u4e26\u3073\u66ff\u3048\u3066\u53ef\u80fd\u306a\u6700\u5927\u6570\u3092\u8fd4\u3059\u95a2\u6570\u3092\u8a18\u8ff0\u305b\u3088\u3002\u4f8b\u3048\u3070\u3001 [50, 2, 1, 9] \u304c\u4e0e\u3048\u3089\u308c\u305f\u6642\u300195021 \u304c\u7b54\u3048\u3068\u306a\u308b\u3002\n\n\u52b9\u7387\u3088\u304f\u8a08\u7b97\u3059\u308b\u65b9\u6cd5\u3092\u8003\u3048\u3066\u3044\u305f\u3089\u6642\u9593\u3092\u305f\u304f\u3055\u3093\u4f7f\u3063\u3066\u3057\u307e\u3063\u305f\u306e\u3067\u3042\u304d\u3089\u3081\u307e\u3057\u305f\u3002\u3059\u3079\u3066\u306e\u5019\u88dc\u3092\u6570\u3048\u4e0a\u3052\u3066\u3001\u964d\u9806\u306b\u30bd\u30fc\u30c8\u3057\u3066\u5148\u982d\u3092\u53d6\u308b\u3088\u3046\u306b\u3057\u307e\u3057\u305f\u3002\nlet q4_biggest (xs: int list) =\n    let rec select = function\n        | []    -> []\n        | [x]   -> [(x,[])]\n        | x::xs -> (x,xs) :: List.map (fun (y,ys) -> (y,x::ys)) (select xs)\n    let mapAdd x = List.map (fun xs -> x::xs)\n    let rec perm = function\n        | [] -> [[]]\n        | xs -> select xs\n                |> List.collect (fun (y,ys) -> mapAdd y (perm ys))\n    perm xs\n    |> List.map (List.collect (fun i -> i.ToString() |> Seq.toList))\n    |> List.sortWith (fun x y -> Operators.compare y x)\n    |> List.head\n    |> System.String.Concat\n    |> (string >> int)\n\n\uff08\u8ffd\u8a18\uff09\u4e0a\u306e\u89e3\u6cd5\u306f\u6570\u5024\u3092\u6587\u5b57\u5217\u5316\u3057\u3066\u6841\u3092\u53d6\u308a\u51fa\u3057\u305f\u308a\u3001\u307e\u305f\u6587\u5b57\u5217\u306b\u623b\u3057\u3066\u6570\u5024\u5316\u3057\u305f\u308a\u3057\u3066\u3044\u308b\u306e\u304c\u7f8e\u3057\u304f\u306a\u3044\u306e\u3067\u3001\u6587\u5b57\u5217\u3092\u4f7f\u308f\u306a\u3044\u3088\u3046\u306b\u76f4\u3057\u307e\u3057\u305f\u3002\nlet q4_biggest =\n    let rec select = function\n        | []    -> []\n        | [x]   -> [(x,[])]\n        | x::xs -> (x,xs) :: List.map (fun (y,ys) -> (y,x::ys)) (select xs)\n    let mapAdd x = List.map (fun xs -> x::xs)\n    let rec perm = function\n        | [] -> [[]]\n        | xs -> select xs\n                |> List.collect (fun (y,ys) -> mapAdd y (perm ys))\n    let digits x =\n        let rec digits x = if x < 10 then [x] else (x%10) :: digits (x/10)\n        digits x |> List.rev\n    perm\n    >> List.map (List.collect digits)\n    >> List.sortWith (fun x y -> Operators.compare y x)\n    >> List.head\n    >> List.reduce (fun x y -> 10*x+y)\n\n\n\u554f\u984c5\n\n1, 2, \u2026, 9\u306e\u6570\u3092\u3053\u306e\u9806\u5e8f\u3067\u3001\u201d+\u201d\u3001\u201d-\u201c\u3001\u307e\u305f\u306f\u306a\u306a\u306b\u3082\u305b\u305a\u7d50\u679c\u304c100\u3068\u306a\u308b\u3042\u3089\u3086\u308b\u7d44\u5408\u305b\u3092\u51fa\u529b\u3059\u308b\u30d7\u30ed\u30b0\u30e9\u30e0\u3092\u8a18\u8ff0\u305b\u3088\u3002\u4f8b\u3048\u3070\u30011 + 2 + 34 \u2013 5 + 67 \u2013 8 + 9 = 100\u3068\u306a\u308b\u3002\n\n\u3053\u3061\u3089\u3082\u5168\u3066\u306e\u5019\u88dc\u3092\u6570\u3048\u4e0a\u3052\u3066\u3001\u6761\u4ef6\u306b\u5408\u3046\u3082\u306e\u306e\u307f\u6b8b\u3059\u3088\u3046\u306b\u30d5\u30a3\u30eb\u30bf\u3057\u307e\u3057\u305f\u3002\nlet q5_list100 =\n    let all : (char * int) list list =\n        let rec ops = function\n        | 0 -> [[]]\n        | i -> List.collect (fun xs -> ['+'::xs; '-'::xs; ' '::xs]) (ops (i - 1))\n        ops 8\n        |> List.map (fun xs -> List.zip (' '::xs) [1..9])\n    let answerIs100 : (char * int) list list =\n        let calc =\n            let initial = ((+), 0, 0)\n            let folder (f, s, r) (c, x) =\n                match c with\n                | '+' -> ((+), f s r,      x)\n                | '-' -> ((-), f s r,      x)\n                | _   -> (  f,     s, 10*r+x)\n            List.fold folder initial\n            >> fun (f, s, r) -> f s r\n        List.filter (fun xs -> calc xs = 100) all\n    let toString : (char * int) list -> string =\n        let toChar x = char (int '0' + x)\n        let initial = []\n        let folder cs (c, x) =\n            match c with\n            |'+'|'-' -> toChar x :: c :: cs\n            | _      -> toChar x :: cs\n        List.fold folder initial\n        >> List.rev\n        >> System.String.Concat\n    List.map toString answerIs100\n\n[1\u6642\u9593\u4ee5\u5185\u306b\u89e3\u3051\u306a\u3051\u308c\u3070\u30d7\u30ed\u30b0\u30e9\u30de\u5931\u683c\u3068\u306a\u3063\u3066\u3057\u307e\u30465\u3064\u306e\u554f\u984c\u304c\u8a71\u984c\u306b - \u30bd\u30d5\u30c8\u30a2\u30f3\u30c6\u30ca\u30d6\u30ed\u30b0](http://www.softantenna.com/wp/software/5-programming-problems/)\n\n\u6b63\u76f4\u306b\u8a00\u3048\u3070\u30011\u6642\u9593\u3067\u306f\u66f8\u3051\u307e\u305b\u3093\u3067\u3057\u305f\u3002\u8981\u7df4\u7fd2\u3067\u3059\u306d\u3002\n\n#\u554f\u984c1\n> for\u30eb\u30fc\u30d7\u3001while\u30eb\u30fc\u30d7\u3001\u304a\u3088\u3073\u518d\u5e30\u3092\u4f7f\u7528\u3057\u3066\u3001\u30ea\u30b9\u30c8\u5185\u306e\u6570\u5b57\u306e\u5408\u8a08\u3092\u8a08\u7b97\u3059\u308b3\u3064\u306e\u95a2\u6570\u3092\u8a18\u8ff0\u305b\u3088\u3002\n\nF#\u306f\u30df\u30e5\u30fc\u30bf\u30d6\u30eb\u306a\u5909\u6570\u3082\u5b9a\u7fa9\u3067\u304d\u308b\u306e\u3067\u3001for\u30eb\u30fc\u30d7\u3068while\u30eb\u30fc\u30d7\u3067\u306f\u305d\u306e\u3088\u3046\u306a\u66f8\u304d\u65b9\u3092\u308f\u3056\u3068\u3057\u307e\u3057\u305f\u3002\n\n```fsharp\nlet q1_for xs =\n    let mutable sum = 0\n    for i in xs do sum <- sum + i\n    sum\n\nlet q1_while xs =\n    let mutable sum = 0\n    let mutable ys = xs\n    while not (List.isEmpty []) do\n        sum <- sum + List.head ys\n        ys <- List.tail ys\n    sum\n\nlet q1_recc xs =\n    let rec q1_recc acc = function\n    | []    -> acc\n    | y::ys -> q1_recc (acc + y) ys\n    q1_recc 0 xs\n```\n\n\u3067\u3082\u3075\u3064\u3046\u306f `List.sum` \u95a2\u6570\u3067\u4e00\u767a\u3067\u3059\u3088\u306d\u3002\n\n#\u554f\u984c2\n\n> \u4ea4\u4e92\u306b\u8981\u7d20\u3092\u53d6\u308b\u3053\u3068\u3067\u30012\u3064\u306e\u30ea\u30b9\u30c8\u3092\u7d50\u5408\u3059\u308b\u95a2\u6570\u3092\u8a18\u8ff0\u305b\u3088\u3002\u4f8b\u3048\u3070 `[a, b, c]` \u3068 `[1, 2, 3]` \u3068\u3044\u30462\u3064\u306e\u30ea\u30b9\u30c8\u3092\u4e0e\u3048\u308b\u3068\u3001\u95a2\u6570\u306f `[a, 1, b, 2, c, 3]` \u3092\u8fd4\u3059\u3002\n\n```fsharp\nlet q2_flatZip xs ys =\n    List.zip xs ys |> List.collect (fun (x,y) -> [x; y])\n```\n\n#\u554f\u984c3\n\n> \u6700\u521d\u306e100\u500b\u306e\u30d5\u30a3\u30dc\u30ca\u30c3\u30c1\u6570\u306e\u30ea\u30b9\u30c8\u3092\u8a08\u7b97\u3059\u308b\u95a2\u6570\u3092\u8a18\u8ff0\u305b\u3088\u3002\u5b9a\u7fa9\u3067\u306f\u3001\u30d5\u30a3\u30dc\u30ca\u30c3\u30c1\u6570\u5217\u306e\u6700\u521d\u306e2\u3064\u306e\u6570\u5b57\u306f0\u30681\u3067\u3001\u6b21\u306e\u6570\u306f\u524d\u306e2\u3064\u306e\u5408\u8a08\u3068\u306a\u308b\u3002\u4f8b\u3048\u3070\u6700\u521d\u306e10\u500b\u306e\u30d5\u30a3\u30dc\u30ca\u30c3\u30c1\u6570\u5217\u306f\u30010, 1, 1, 2, 3, 5, 8, 13, 21, 34\u3068\u306a\u308b\u3002\n\n100\u500b\u3068\u3044\u3046\u3053\u3068\u306a\u306e\u3067\u3001\u7b26\u53f7\u306a\u305764\u30d3\u30c3\u30c8\u6574\u6570\u3092\u4f7f\u3044\u307e\u3057\u305f\u3002\n\n```fsharp\nlet q3_fib100 =\n    let fib = Seq.unfold (fun (a, b) -> Some(a, (b, a+b))) (0UL, 1UL)\n    fib |> Seq.take 100 |> Seq.toList\n```\n\n#\u554f\u984c4\n\n> \u6b63\u306e\u6574\u6570\u306e\u30ea\u30b9\u30c8\u3092\u4e0e\u3048\u3089\u308c\u305f\u3068\u304d\u3001\u6570\u3092\u4e26\u3073\u66ff\u3048\u3066\u53ef\u80fd\u306a\u6700\u5927\u6570\u3092\u8fd4\u3059\u95a2\u6570\u3092\u8a18\u8ff0\u305b\u3088\u3002\u4f8b\u3048\u3070\u3001 `[50, 2, 1, 9]` \u304c\u4e0e\u3048\u3089\u308c\u305f\u6642\u3001`95021` \u304c\u7b54\u3048\u3068\u306a\u308b\u3002\n\n\u52b9\u7387\u3088\u304f\u8a08\u7b97\u3059\u308b\u65b9\u6cd5\u3092\u8003\u3048\u3066\u3044\u305f\u3089\u6642\u9593\u3092\u305f\u304f\u3055\u3093\u4f7f\u3063\u3066\u3057\u307e\u3063\u305f\u306e\u3067\u3042\u304d\u3089\u3081\u307e\u3057\u305f\u3002\u3059\u3079\u3066\u306e\u5019\u88dc\u3092\u6570\u3048\u4e0a\u3052\u3066\u3001\u964d\u9806\u306b\u30bd\u30fc\u30c8\u3057\u3066\u5148\u982d\u3092\u53d6\u308b\u3088\u3046\u306b\u3057\u307e\u3057\u305f\u3002\n\n```fsharp\nlet q4_biggest (xs: int list) =\n    let rec select = function\n        | []    -> []\n        | [x]   -> [(x,[])]\n        | x::xs -> (x,xs) :: List.map (fun (y,ys) -> (y,x::ys)) (select xs)\n    let mapAdd x = List.map (fun xs -> x::xs)\n    let rec perm = function\n        | [] -> [[]]\n        | xs -> select xs\n                |> List.collect (fun (y,ys) -> mapAdd y (perm ys))\n    perm xs\n    |> List.map (List.collect (fun i -> i.ToString() |> Seq.toList))\n    |> List.sortWith (fun x y -> Operators.compare y x)\n    |> List.head\n    |> System.String.Concat\n    |> (string >> int)\n```\n\n\uff08\u8ffd\u8a18\uff09\u4e0a\u306e\u89e3\u6cd5\u306f\u6570\u5024\u3092\u6587\u5b57\u5217\u5316\u3057\u3066\u6841\u3092\u53d6\u308a\u51fa\u3057\u305f\u308a\u3001\u307e\u305f\u6587\u5b57\u5217\u306b\u623b\u3057\u3066\u6570\u5024\u5316\u3057\u305f\u308a\u3057\u3066\u3044\u308b\u306e\u304c\u7f8e\u3057\u304f\u306a\u3044\u306e\u3067\u3001\u6587\u5b57\u5217\u3092\u4f7f\u308f\u306a\u3044\u3088\u3046\u306b\u76f4\u3057\u307e\u3057\u305f\u3002\n\n```fsharp\nlet q4_biggest =\n    let rec select = function\n        | []    -> []\n        | [x]   -> [(x,[])]\n        | x::xs -> (x,xs) :: List.map (fun (y,ys) -> (y,x::ys)) (select xs)\n    let mapAdd x = List.map (fun xs -> x::xs)\n    let rec perm = function\n        | [] -> [[]]\n        | xs -> select xs\n                |> List.collect (fun (y,ys) -> mapAdd y (perm ys))\n    let digits x =\n        let rec digits x = if x < 10 then [x] else (x%10) :: digits (x/10)\n        digits x |> List.rev\n    perm\n    >> List.map (List.collect digits)\n    >> List.sortWith (fun x y -> Operators.compare y x)\n    >> List.head\n    >> List.reduce (fun x y -> 10*x+y)\n```\n\n#\u554f\u984c5\n\n> 1, 2, \u2026, 9\u306e\u6570\u3092\u3053\u306e\u9806\u5e8f\u3067\u3001\u201d+\u201d\u3001\u201d-\u201c\u3001\u307e\u305f\u306f\u306a\u306a\u306b\u3082\u305b\u305a\u7d50\u679c\u304c100\u3068\u306a\u308b\u3042\u3089\u3086\u308b\u7d44\u5408\u305b\u3092\u51fa\u529b\u3059\u308b\u30d7\u30ed\u30b0\u30e9\u30e0\u3092\u8a18\u8ff0\u305b\u3088\u3002\u4f8b\u3048\u3070\u30011 + 2 + 34 \u2013 5 + 67 \u2013 8 + 9 = 100\u3068\u306a\u308b\u3002\n\n\u3053\u3061\u3089\u3082\u5168\u3066\u306e\u5019\u88dc\u3092\u6570\u3048\u4e0a\u3052\u3066\u3001\u6761\u4ef6\u306b\u5408\u3046\u3082\u306e\u306e\u307f\u6b8b\u3059\u3088\u3046\u306b\u30d5\u30a3\u30eb\u30bf\u3057\u307e\u3057\u305f\u3002\n\n```fsharp\nlet q5_list100 =\n    let all : (char * int) list list =\n        let rec ops = function\n        | 0 -> [[]]\n        | i -> List.collect (fun xs -> ['+'::xs; '-'::xs; ' '::xs]) (ops (i - 1))\n        ops 8\n        |> List.map (fun xs -> List.zip (' '::xs) [1..9])\n    let answerIs100 : (char * int) list list =\n        let calc =\n            let initial = ((+), 0, 0)\n            let folder (f, s, r) (c, x) =\n                match c with\n                | '+' -> ((+), f s r,      x)\n                | '-' -> ((-), f s r,      x)\n                | _   -> (  f,     s, 10*r+x)\n            List.fold folder initial\n            >> fun (f, s, r) -> f s r\n        List.filter (fun xs -> calc xs = 100) all\n    let toString : (char * int) list -> string =\n        let toChar x = char (int '0' + x)\n        let initial = []\n        let folder cs (c, x) =\n            match c with\n            |'+'|'-' -> toChar x :: c :: cs\n            | _      -> toChar x :: cs\n        List.fold folder initial\n        >> List.rev\n        >> System.String.Concat\n    List.map toString answerIs100\n```\n", "tags": ["F#"]}