{"context": " More than 1 year has passed since last update.\u524d\u56de2\u672c\u306e\u76f4\u7dda\u304b\u3089\u3067\u304d\u308b\u30d9\u30b8\u30a7\u66f2\u7dda\u3092\u63cf\u304d\u307e\u3057\u305f\u304c\u3001\u3055\u3089\u306b\u5225\u306e\u76f4\u7dda\u3092\u5897\u3084\u3059\u3053\u3068\u3067\u3001\n1\u672c\u76ee\u30682\u672c\u76ee\u306e\u30d9\u30b8\u30a7\u66f2\u7dda\u30012\u672c\u76ee\u30683\u672c\u76ee\u306e\u30d9\u30b8\u30a7\u66f2\u7dda\u304c\u3067\u304d\u307e\u3059\u3002\n\u3053\u306e\u4e8c\u3064\u306e\u30d9\u30b8\u30a7\u66f2\u7dda\u306e\u8ecc\u8de1\u3092\u7dda\u3067\u7e4b\u3044\u3067\u3001\u540c\u3058\u304f\u7b49\u5206\u5272\u3059\u308b\u30683\u3064\u3081\u306e\u30d9\u30b8\u30a7\u66f2\u7dda\u304c\u3067\u304d\u307e\u3059\u3002\n\u305d\u3057\u306610\u500b\u307e\u3067\u5897\u3084\u3057\u3066\u307f\u308b\u3068\u3053\u3093\u306a\u611f\u3058\u306b\u306a\u308a\u307e\u3057\u305f\u3002\n\nint order;\nint count;\nint col_num;\n\nfloat steps;\nfloat diffs;\nfloat cpx[];\nfloat cpy[];\nfloat tempx[][];\nfloat tempy[][];\nfloat bzx[][][];\nfloat bzy[][][];\nfloat col_val;\n\nboolean step_flag;\nboolean draw_flag;\n\nvoid setup () {\n\n    size (1200, 800);\n    colorMode (HSB, 256);\n    background (0);\n    frameRate (60);\n    strokeWeight (0.5);\n\n    order = 10;\n    count = 0;\n    steps = 0.00;\n    diffs = 0.01;\n\n    cpx = new float[order + 1];\n    cpy = new float[order + 1];\n    tempx = new float[order][int (1 / diffs)];\n    tempy = new float[order][int (1 / diffs)];\n    bzx = new float[order][order][int (1 / diffs)];\n    bzy = new float[order][order][int (1 / diffs)];\n\n    step_flag = false;\n    draw_flag = false;\n\n}\n\nvoid draw () {\n\n    if (step_flag == true &amp;&amp; count &lt; int (1 / diffs)) {\n\n        for (int i = 0; i &lt; order; i++) {\n\n            tempx[i][count] = (cpx[i + 1] * (1 - steps)) + (cpx[i] * steps);\n            tempy[i][count] = (cpy[i + 1] * (1 - steps)) + (cpy[i] * steps);\n\n            if (i &gt; 0) {\n\n                stroke (255, 40);\n                line (tempx[i - 1][count], tempy[i - 1][count], tempx[i][count], tempy[i][count]);\n\n                for (int j = 0; j &lt; order; j++) {\n                    if (j == 0) {\n                        bzx[j][i][count] = (tempx[i][count] * (1 - steps)) + (tempx[i - 1][count] * steps);\n                        bzy[j][i][count] = (tempy[i][count] * (1 - steps)) + (tempy[i - 1][count] * steps);\n                    } else {\n                        bzx[j][i][count] = (bzx[j - 1][i][count] * (1 - steps)) + (bzx[j - 1][i - 1][count] * steps);\n                        bzy[j][i][count] = (bzy[j - 1][i][count] * (1 - steps)) + (bzy[j - 1][i - 1][count] * steps);\n                    }\n                    if (count &gt; 0) {\n                        if (i &gt; j) {\n                            col_val = map (j, 0, order, 0, 220);\n                            stroke (col_val, 255, 255);\n                            //stroke (255 / (j + 1), 255 / (j + 1), 255 / (j + 1));\n                            line (bzx[j][i][count - 1], bzy[j][i][count - 1], bzx[j][i][count], bzy[j][i][count]);\n                        }\n                    }\n                    if (count == int (1 / diffs) - 1) {\n                        if (i &gt; j) {\n                            col_val = map (j, 0, order, 0, 220);\n                            stroke (col_val, 255, 255);\n                            //stroke (255 / (j + 1), 255 / (j + 1), 255 / (j + 1));\n                            line (bzx[j][i][count], bzy[j][i][count], cpx[i - j - 1], cpy[i - j - 1]);\n                        }\n                    }\n                }\n\n            }\n\n        }\n\n        steps += diffs;\n        count += 1;\n\n    } else {\n\n        step_flag = false;\n\n    }\n\n}\n\nvoid mouseReleased () {\n\n    background (0);\n    steps = 0;\n    count = 0;\n    cpx = new float[order + 1];\n    cpy = new float[order + 1];\n    for (int i = 0; i &lt;= order; i++) {\n        cpx[i] = random (width);\n        cpy[i] = random (height);\n        if (i &gt; 0) {\n            stroke (255, 80);\n            line (cpx[i], cpy[i], cpx[i - 1], cpy[i - 1]);\n        }\n    }\n    step_flag = true;\n\n}\n\n\u524d\u56de2\u672c\u306e\u76f4\u7dda\u304b\u3089\u3067\u304d\u308b\u30d9\u30b8\u30a7\u66f2\u7dda\u3092\u63cf\u304d\u307e\u3057\u305f\u304c\u3001\u3055\u3089\u306b\u5225\u306e\u76f4\u7dda\u3092\u5897\u3084\u3059\u3053\u3068\u3067\u3001\n1\u672c\u76ee\u30682\u672c\u76ee\u306e\u30d9\u30b8\u30a7\u66f2\u7dda\u30012\u672c\u76ee\u30683\u672c\u76ee\u306e\u30d9\u30b8\u30a7\u66f2\u7dda\u304c\u3067\u304d\u307e\u3059\u3002\n\u3053\u306e\u4e8c\u3064\u306e\u30d9\u30b8\u30a7\u66f2\u7dda\u306e\u8ecc\u8de1\u3092\u7dda\u3067\u7e4b\u3044\u3067\u3001\u540c\u3058\u304f\u7b49\u5206\u5272\u3059\u308b\u30683\u3064\u3081\u306e\u30d9\u30b8\u30a7\u66f2\u7dda\u304c\u3067\u304d\u307e\u3059\u3002\n\u305d\u3057\u306610\u500b\u307e\u3067\u5897\u3084\u3057\u3066\u307f\u308b\u3068\u3053\u3093\u306a\u611f\u3058\u306b\u306a\u308a\u307e\u3057\u305f\u3002\n![20141211.jpg](https://qiita-image-store.s3.amazonaws.com/0/75611/6d13c7c1-5fa9-9727-0330-c0241518bbe6.jpeg)\n\n~~~java\nint order;\nint count;\nint col_num;\n \nfloat steps;\nfloat diffs;\nfloat cpx[];\nfloat cpy[];\nfloat tempx[][];\nfloat tempy[][];\nfloat bzx[][][];\nfloat bzy[][][];\nfloat col_val;\n \nboolean step_flag;\nboolean draw_flag;\n \nvoid setup () {\n \n    size (1200, 800);\n    colorMode (HSB, 256);\n    background (0);\n    frameRate (60);\n    strokeWeight (0.5);\n \n    order = 10;\n    count = 0;\n    steps = 0.00;\n    diffs = 0.01;\n \n    cpx = new float[order + 1];\n    cpy = new float[order + 1];\n    tempx = new float[order][int (1 / diffs)];\n    tempy = new float[order][int (1 / diffs)];\n    bzx = new float[order][order][int (1 / diffs)];\n    bzy = new float[order][order][int (1 / diffs)];\n \n    step_flag = false;\n    draw_flag = false;\n \n}\n \nvoid draw () {\n \n    if (step_flag == true &amp;&amp; count &lt; int (1 / diffs)) {\n \n        for (int i = 0; i &lt; order; i++) {\n \n            tempx[i][count] = (cpx[i + 1] * (1 - steps)) + (cpx[i] * steps);\n            tempy[i][count] = (cpy[i + 1] * (1 - steps)) + (cpy[i] * steps);\n \n            if (i &gt; 0) {\n \n                stroke (255, 40);\n                line (tempx[i - 1][count], tempy[i - 1][count], tempx[i][count], tempy[i][count]);\n \n                for (int j = 0; j &lt; order; j++) {\n                    if (j == 0) {\n                        bzx[j][i][count] = (tempx[i][count] * (1 - steps)) + (tempx[i - 1][count] * steps);\n                        bzy[j][i][count] = (tempy[i][count] * (1 - steps)) + (tempy[i - 1][count] * steps);\n                    } else {\n                        bzx[j][i][count] = (bzx[j - 1][i][count] * (1 - steps)) + (bzx[j - 1][i - 1][count] * steps);\n                        bzy[j][i][count] = (bzy[j - 1][i][count] * (1 - steps)) + (bzy[j - 1][i - 1][count] * steps);\n                    }\n                    if (count &gt; 0) {\n                        if (i &gt; j) {\n                            col_val = map (j, 0, order, 0, 220);\n                            stroke (col_val, 255, 255);\n                            //stroke (255 / (j + 1), 255 / (j + 1), 255 / (j + 1));\n                            line (bzx[j][i][count - 1], bzy[j][i][count - 1], bzx[j][i][count], bzy[j][i][count]);\n                        }\n                    }\n                    if (count == int (1 / diffs) - 1) {\n                        if (i &gt; j) {\n                            col_val = map (j, 0, order, 0, 220);\n                            stroke (col_val, 255, 255);\n                            //stroke (255 / (j + 1), 255 / (j + 1), 255 / (j + 1));\n                            line (bzx[j][i][count], bzy[j][i][count], cpx[i - j - 1], cpy[i - j - 1]);\n                        }\n                    }\n                }\n \n            }\n             \n        }\n \n        steps += diffs;\n        count += 1;\n \n    } else {\n \n        step_flag = false;\n \n    }\n \n}\n \nvoid mouseReleased () {\n \n    background (0);\n    steps = 0;\n    count = 0;\n    cpx = new float[order + 1];\n    cpy = new float[order + 1];\n    for (int i = 0; i &lt;= order; i++) {\n        cpx[i] = random (width);\n        cpy[i] = random (height);\n        if (i &gt; 0) {\n            stroke (255, 80);\n            line (cpx[i], cpy[i], cpx[i - 1], cpy[i - 1]);\n        }\n    }\n    step_flag = true;\n \n}\n~~~\n", "tags": ["processing"]}