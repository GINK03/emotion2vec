{"tags": ["adamTaylor"], "context": "MicroZed Chronicles \u30ea\u30b9\u30c8 http://adiuvoengineering.com/?page_id=285\n@ Adam Taylor blog\nhttps://forums.xilinx.com/t5/Xcell-Daily-Blog/The-Zynq-PS-PL-Part-Four-Adam-Taylor-s-MicroZed-Chronicles-Part/ba-p/428548\n\nThe first test is to add together the two contents stored within register 2 and 3 using command 1 in register 0:\nreg0 = 1\nreg1 = 67\nreg2 = 35\nreg3 = 102\n\n\u30bd\u30fc\u30b9\u306b\u304a\u3044\u3066\u53ef\u7b97\u51e6\u7406\u3092\u3057\u3066\u3044\u308b\u90e8\u5206\u304c\u307e\u3060\u3088\u304f\u5206\u304b\u3063\u3066\u3044\u306a\u3044\u3002\n\u3068\u308a\u3042\u3048\u305a\u3001\u4e0a\u8a18\u306e\u30ec\u30b8\u30b9\u30bf\u3092\u8868\u793a\u7528\u306b\u8aad\u8fbc\u307f\u3057\u3066\u3044\u305d\u3046\u306a\u306e\u306f\n\nAdams_Perihperal_v1_0_S00_AXI.vhd\n    process (slv_reg0, slv_reg1, slv_reg2, slv_reg3, axi_araddr, S_AXI_ARESETN, slv_reg_rden)\n    variable loc_addr :std_logic_vector(OPT_MEM_ADDR_BITS downto 0);\n    begin\n      if S_AXI_ARESETN = '0' then\n        reg_data_out  <= (others => '1');\n      else\n        -- Address decoding for reading registers\n        loc_addr := axi_araddr(ADDR_LSB + OPT_MEM_ADDR_BITS downto ADDR_LSB);\n        case loc_addr is\n          when b\"00\" =>\n            reg_data_out <= slv_reg0;\n          when b\"01\" =>\n            reg_data_out <= slv_reg1;\n          when b\"10\" =>\n            reg_data_out <= slv_reg2;\n          when b\"11\" =>\n            reg_data_out <= slv_reg3;\n          when others =>\n            reg_data_out  <= (others => '0');\n        end case;\n      end if;\n    end process; \n\n    -- Output register or memory read data\n    process( S_AXI_ACLK ) is\n    begin\n      if (rising_edge (S_AXI_ACLK)) then\n        if ( S_AXI_ARESETN = '0' ) then\n          axi_rdata  <= (others => '0');\n        else\n          if (slv_reg_rden = '1') then\n            -- When there is a valid read address (S_AXI_ARVALID) with \n            -- acceptance of read address by the slave (axi_arready), \n            -- output the read dada \n            -- Read address mux\n              axi_rdata <= reg_data_out;     -- register read data\n          end if;   \n        end if;\n      end if;\n    end process;\n\n\n\u30bd\u30fc\u30b9\u306e\u8a73\u7d30\u306f\u4eca\u306f\u308f\u304b\u3089\u306a\u304f\u3066\u3044\u3044\u304c\u3001\u6d41\u308c\u306f\u628a\u63e1\u3057\u305f\u3044\u3002\n\n(\u8ffd\u8a18 2016/05/27)\nVHDL\u306e\u5165\u9580\u66f8\u3092\u8aad\u307f\u7d42\u3048\u3066\u3001\u6587\u6cd5\u3092\u3042\u308b\u7a0b\u5ea6\u5206\u304b\u308b\u3088\u3046\u306b\u306a\u3063\u3066\u30bd\u30fc\u30b9\u3092\u8aad\u3093\u3060\u304c\u3001\u4e0a\u8a18\u306e\u51e6\u7406\u304c\u898b\u3064\u304b\u3089\u306a\u3044\u3002\nMicroZed Chronicles \u30ea\u30b9\u30c8 http://adiuvoengineering.com/?page_id=285\n@ Adam Taylor blog\nhttps://forums.xilinx.com/t5/Xcell-Daily-Blog/The-Zynq-PS-PL-Part-Four-Adam-Taylor-s-MicroZed-Chronicles-Part/ba-p/428548\n\n> The first test is to add together the two contents stored within register 2 and 3 using command 1 in register 0:\n\n> reg0 = 1\nreg1 = 67\nreg2 = 35\nreg3 = 102\n\n\u30bd\u30fc\u30b9\u306b\u304a\u3044\u3066\u53ef\u7b97\u51e6\u7406\u3092\u3057\u3066\u3044\u308b\u90e8\u5206\u304c\u307e\u3060\u3088\u304f\u5206\u304b\u3063\u3066\u3044\u306a\u3044\u3002\n\n\u3068\u308a\u3042\u3048\u305a\u3001\u4e0a\u8a18\u306e\u30ec\u30b8\u30b9\u30bf\u3092\u8868\u793a\u7528\u306b\u8aad\u8fbc\u307f\u3057\u3066\u3044\u305d\u3046\u306a\u306e\u306f\n\n```Adams_Perihperal_v1_0_S00_AXI.vhd\n\tprocess (slv_reg0, slv_reg1, slv_reg2, slv_reg3, axi_araddr, S_AXI_ARESETN, slv_reg_rden)\n\tvariable loc_addr :std_logic_vector(OPT_MEM_ADDR_BITS downto 0);\n\tbegin\n\t  if S_AXI_ARESETN = '0' then\n\t    reg_data_out  <= (others => '1');\n\t  else\n\t    -- Address decoding for reading registers\n\t    loc_addr := axi_araddr(ADDR_LSB + OPT_MEM_ADDR_BITS downto ADDR_LSB);\n\t    case loc_addr is\n\t      when b\"00\" =>\n\t        reg_data_out <= slv_reg0;\n\t      when b\"01\" =>\n\t        reg_data_out <= slv_reg1;\n\t      when b\"10\" =>\n\t        reg_data_out <= slv_reg2;\n\t      when b\"11\" =>\n\t        reg_data_out <= slv_reg3;\n\t      when others =>\n\t        reg_data_out  <= (others => '0');\n\t    end case;\n\t  end if;\n\tend process; \n\n\t-- Output register or memory read data\n\tprocess( S_AXI_ACLK ) is\n\tbegin\n\t  if (rising_edge (S_AXI_ACLK)) then\n\t    if ( S_AXI_ARESETN = '0' ) then\n\t      axi_rdata  <= (others => '0');\n\t    else\n\t      if (slv_reg_rden = '1') then\n\t        -- When there is a valid read address (S_AXI_ARVALID) with \n\t        -- acceptance of read address by the slave (axi_arready), \n\t        -- output the read dada \n\t        -- Read address mux\n\t          axi_rdata <= reg_data_out;     -- register read data\n\t      end if;   \n\t    end if;\n\t  end if;\n\tend process;\n```\n\n\u30bd\u30fc\u30b9\u306e\u8a73\u7d30\u306f\u4eca\u306f\u308f\u304b\u3089\u306a\u304f\u3066\u3044\u3044\u304c\u3001\u6d41\u308c\u306f\u628a\u63e1\u3057\u305f\u3044\u3002\n\n<hr>\n(\u8ffd\u8a18 2016/05/27)\nVHDL\u306e\u5165\u9580\u66f8\u3092\u8aad\u307f\u7d42\u3048\u3066\u3001\u6587\u6cd5\u3092\u3042\u308b\u7a0b\u5ea6\u5206\u304b\u308b\u3088\u3046\u306b\u306a\u3063\u3066\u30bd\u30fc\u30b9\u3092\u8aad\u3093\u3060\u304c\u3001\u4e0a\u8a18\u306e\u51e6\u7406\u304c\u898b\u3064\u304b\u3089\u306a\u3044\u3002\n\n"}