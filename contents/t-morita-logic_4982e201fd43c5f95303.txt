{"context": "\n\nrails\u30a4\u30f3\u30b9\u30c8\u30fc\u30eb\n$ gem update --system\n$ gem install --no-ri --no-rdoc rails\n$ gem install bundler\n\n\n\u30d0\u30fc\u30b8\u30e7\u30f3\u78ba\u8a8d\n$ rails -v\n\n\nRails \u30a2\u30d7\u30ea\u30b1\u30fc\u30b7\u30e7\u30f3\u3092\u4f5c\u6210\nrails new \uff1c\u30a2\u30d7\u30ea\u30b1\u30fc\u30b7\u30e7\u30f3\u540d\uff1e\n\nunicorn\n## unicorn\u306e\u30a4\u30f3\u30b9\u30c8\u30fc\u30eb\nGemfile\u306b\u4e0b\u8a18\u306e\u8a18\u8f09\u3092\u3057\u3066\u3001bundle install\u30b3\u30de\u30f3\u30c9\u3092\u5b9f\u884c\u3059\u308b\ngem 'unicorn'\n\n\u4e0b\u8a18\u306eunicorn\u306e\u516c\u5f0f\u30b5\u30a4\u30c8\u306b\u30b5\u30f3\u30d7\u30eb\u8a2d\u5b9a\u30d5\u30a1\u30a4\u30eb\u304c\u30c0\u30a6\u30f3\u30ed\u30fc\u30c9\u3067\u304d\u308b\u305f\u3081\u3001\u3053\u306e\u30b5\u30a4\u30c8\u304b\u3089\u30b5\u30f3\u30d7\u30eb\u3092\u30c0\u30a6\u30f3\u30ed\u30fc\u30c9\u3057\u3066\u81ea\u5206\u306e\u74b0\u5883\u306b\u5408\u308f\u305b\u3066\u30ab\u30b9\u30bf\u30de\u30a4\u30ba\u3057\u3066\u4e0b\u3055\u3044\u3002\nhttps://unicorn.bogomips.org/Unicorn/Configurator.html\n\nnginx\u306e\u8a2d\u5b9a\u30d5\u30a1\u30a4\u30eb\n/etc/nginx/conf.d/local.conf\n# This is example contains the bare mininum to get nginx going with\n# unicorn servers.  Generally these configuration settings\n# are applicable to other HTTP application servers (and not just Ruby\n# ones), so if you have one working well for proxying another app\n# server, feel free to continue using it.\n#\n# The only setting we feel strongly about is the fail_timeout=0\n# directive in the \"upstream\" block.  max_fails=0 also has the same\n# effect as fail_timeout=0 for current versions of nginx and may be\n# used in its place.\n#\n# Users are strongly encouraged to refer to nginx documentation for more\n# details and search for other example configs.\n\n# you generally only need one nginx worker unless you're serving\n# large amounts of static files which require blocking disk reads\nworker_processes 1;\n\n# # drop privileges, root is needed on most systems for binding to port 80\n# # (or anything < 1024).  Capability-based security may be available for\n# # your system and worth checking out so you won't need to be root to\n# # start nginx to bind on 80\n# user nobody nobody; # for systems with \"nobody\" as a group instead\n\n# Feel free to change all paths to suite your needs here, of course\n#pid /path/to/nginx.pid;\nerror_log /var/log/nginx/hogehoge_error.log;  # \u3053\u3053\u3092\u4fee\u6b63\n\nevents {\n  worker_connections 1024; # increase if you have lots of clients\n  accept_mutex off; # \"on\" if nginx worker_processes > 1\n  # use epoll; # enable for Linux 2.6+\n  # use kqueue; # enable for FreeBSD, OSX\n}\n\nhttp {\n  # nginx will find this file in the config directory set at nginx build time\n  include mime.types;\n\n  # fallback in case we can't determine a type\n  default_type application/octet-stream;\n\n  # click tracking!\n  access_log /path/to/nginx.access.log combined;   # \u3053\u3053\u3092\u4fee\u6b63\n\n  # you generally want to serve static files with nginx since\n  # unicorn is not and will never be optimized for it\n  sendfile on;\n\n  tcp_nopush on; # off may be better for *some* Comet/long-poll stuff\n  tcp_nodelay off; # on may be better for some Comet/long-poll stuff\n\n  # we haven't checked to see if Rack::Deflate on the app server is\n  # faster or not than doing compression via nginx.  It's easier\n  # to configure it all in one place here for static files and also\n  # to disable gzip for clients who don't get gzip/deflate right.\n  # There are other gzip settings that may be needed used to deal with\n  # bad clients out there, see http://wiki.nginx.org/NginxHttpGzipModule\n  gzip on;\n  gzip_http_version 1.0;\n  gzip_proxied any;\n  gzip_min_length 500;\n  gzip_disable \"MSIE [1-6]\\.\";\n  gzip_types text/plain text/html text/xml text/css\n             text/comma-separated-values\n             text/javascript application/x-javascript\n             application/atom+xml;\n\n  # this can be any application server, not just unicorn\n  upstream app_server {\n    # fail_timeout=0 means we always retry an upstream even if it failed\n    # to return a good HTTP response (in case the unicorn master nukes a\n    # single worker for timing out).\n\n    # for UNIX domain socket setups:\n    server unix:/usr/share/nginx/[\u30a2\u30d7\u30ea\u30b1\u30fc\u30b7\u30e7\u30f3\u540d]/shared/.unicorn.sock fail_timeout=0;  # \u3053\u3053\u3092\u4fee\u6b63\n\n    # for TCP setups, point these to your backend servers\n    # server 192.168.0.7:8080 fail_timeout=0;\n    # server 192.168.0.8:8080 fail_timeout=0;\n    # server 192.168.0.9:8080 fail_timeout=0;\n  }\n\n  server {\n    # enable one of the following if you're on Linux or FreeBSD\n    # listen 80 default deferred; # for Linux\n    # listen 80 default accept_filter=httpready; # for FreeBSD\n\n    # If you have IPv6, you'll likely want to have two separate listeners.\n    # One on IPv4 only (the default), and another on IPv6 only instead\n    # of a single dual-stack listener.  A dual-stack listener will make\n    # for ugly IPv4 addresses in $remote_addr (e.g \":ffff:10.0.0.1\"\n    # instead of just \"10.0.0.1\") and potentially trigger bugs in\n    # some software.\n    # listen [::]:80 ipv6only=on; # deferred or accept_filter recommended\n\n    client_max_body_size 4G;\n    server_name _;\n\n    # ~2 seconds is often enough for most folks to parse HTML/CSS and\n    # retrieve needed images/icons/frames, connections are cheap in\n    # nginx so increasing this is generally safe...\n    keepalive_timeout 5;\n\n    # path for static files\n    root /usr/share/nginx/[\u30a2\u30d7\u30ea\u30b1\u30fc\u30b7\u30e7\u30f3\u540d]/public;\n\n    # Prefer to serve static files directly from nginx to avoid unnecessary\n    # data copies from the application server.\n    #\n    # try_files directive appeared in in nginx 0.7.27 and has stabilized\n    # over time.  Older versions of nginx (e.g. 0.6.x) requires\n    # \"if (!-f $request_filename)\" which was less efficient:\n    # http://bogomips.org/unicorn.git/tree/examples/nginx.conf?id=v3.3.1#n127\n    try_files $uri/index.html $uri.html $uri @app;\n\n    location @app {\n      # an HTTP header important enough to have its own Wikipedia entry:\n      #   http://en.wikipedia.org/wiki/X-Forwarded-For\n      proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n\n      # enable this if you forward HTTPS traffic to unicorn,\n      # this helps Rack set the proper URL scheme for doing redirects:\n      # proxy_set_header X-Forwarded-Proto $scheme;\n\n      # pass the Host: header from the client right along so redirects\n      # can be set properly within the Rack application\n      proxy_set_header Host $http_host;\n\n      # we don't want nginx trying to do something clever with\n      # redirects, we set the Host: header above already.\n      proxy_redirect off;\n\n      # It's also safe to set if you're using only serving fast clients\n      # with unicorn + nginx, but not slow clients.  You normally want\n      # nginx to buffer responses to slow clients, even with Rails 3.1\n      # streaming because otherwise a slow client can become a bottleneck\n      # of unicorn.\n      #\n      # The Rack application may also set \"X-Accel-Buffering (yes|no)\"\n      # in the response headers do disable/enable buffering on a\n      # per-response basis.\n      # proxy_buffering off;\n\n      proxy_pass http://app_server;   # \u3053\u3053\u3092\u4fee\u6b63\n    }\n\n    # Rails error pages\n    error_page 500 502 503 504 /500.html;\n    location = /500.html {\n      root /usr/share/nginx/[\u30a2\u30d7\u30ea\u30b1\u30fc\u30b7\u30e7\u30f3\u540d]/public;   # \u3053\u3053\u3092\u4fee\u6b63\n    }\n  }\n}\n\n\nunicorn\u306e\u8a2d\u5b9a\u30d5\u30a1\u30a4\u30eb\n# Sample verbose configuration file for Unicorn (not Rack)\n#\n# This configuration file documents many features of Unicorn\n# that may not be needed for some applications. See\n# http://unicorn.bogomips.org/examples/unicorn.conf.minimal.rb\n# for a much simpler configuration file.\n#\n# See http://unicorn.bogomips.org/Unicorn/Configurator.html for complete\n# documentation.\n\n# Use at least one worker per core if you're on a dedicated server,\n# more will usually help for _short_ waits on databases/caches.\nworker_processes 4\n\n# Since Unicorn is never exposed to outside clients, it does not need to\n# run on the standard HTTP port (80), there is no reason to start Unicorn\n# as root unless it's from system init scripts.\n# If running the master process as root and the workers as an unprivileged\n# user, do this to switch euid/egid in the workers (also chowns logs):\n# user \"unprivileged_user\", \"unprivileged_group\"\n\n# Help ensure your application will always spawn in the symlinked\n# \"current\" directory that Capistrano sets up.\nworking_directory \"/usr/share/nginx/[\u30a2\u30d7\u30ea\u30b1\u30fc\u30b7\u30e7\u30f3\u540d]\" # available in 0.94.0+\u3000# \u3053\u3053\u4fee\u6b63\n\n# listen on both a Unix domain socket and a TCP port,\n# we use a shorter backlog for quicker failover when busy\nlisten \"/usr/share/nginx/[\u30a2\u30d7\u30ea\u30b1\u30fc\u30b7\u30e7\u30f3\u540d]/shared/.unicorn.sock\", :backlog => 64\u3000# \u3053\u3053\u4fee\u6b63\nlisten 8080, :tcp_nopush => true  \n\n# nuke workers after 30 seconds instead of 60 seconds (the default)\ntimeout 30\n\n# feel free to point this anywhere accessible on the filesystem\npid \"/usr/share/nginx/[\u30a2\u30d7\u30ea\u30b1\u30fc\u30b7\u30e7\u30f3\u540d]/shared/pids/unicorn.pid\"\u3000#\u3000\u3053\u3053\u4fee\u6b63 \n\n# By default, the Unicorn logger will write to stderr.\n# Additionally, ome applications/frameworks log to stderr or stdout,\n# so prevent them from going to /dev/null when daemonized here:\nstderr_path \"/usr/share/nginx/[\u30a2\u30d7\u30ea\u30b1\u30fc\u30b7\u30e7\u30f3\u540d]/shared/log/unicorn.stderr.log\"\u3000# \u3053\u3053\u4fee\u6b63\u3000\nstdout_path \"/usr/share/nginx/[\u30a2\u30d7\u30ea\u30b1\u30fc\u30b7\u30e7\u30f3\u540d]/shared/log/unicorn.stdout.log\"\u3000# \u3053\u3053\u4fee\u6b63\n\n# combine Ruby 2.0.0+ with \"preload_app true\" for memory savings\npreload_app true\n\n# Enable this flag to have unicorn test client connections by writing the\n# beginning of the HTTP headers before calling the application.  This\n# prevents calling the application for connections that have disconnected\n# while queued.  This is only guaranteed to detect clients on the same\n# host unicorn runs on, and unlikely to detect disconnects even on a\n# fast LAN.\ncheck_client_connection false\n\n# local variable to guard against running a hook multiple times\nrun_once = true\n\nbefore_fork do |server, worker|\n  # the following is highly recomended for Rails + \"preload_app true\"\n  # as there's no need for the master process to hold a connection\n  defined?(ActiveRecord::Base) and\n    ActiveRecord::Base.connection.disconnect!\n\n  # Occasionally, it may be necessary to run non-idempotent code in the\n  # master before forking.  Keep in mind the above disconnect! example\n  # is idempotent and does not need a guard.\n  if run_once\n    # do_something_once_here ...\n    run_once = false # prevent from firing again\n  end\n\n  # The following is only recommended for memory/DB-constrained\n  # installations.  It is not needed if your system can house\n  # twice as many worker_processes as you have configured.\n  #\n  # # This allows a new master process to incrementally\n  # # phase out the old master process with SIGTTOU to avoid a\n  # # thundering herd (especially in the \"preload_app false\" case)\n  # # when doing a transparent upgrade.  The last worker spawned\n  # # will then kill off the old master process with a SIGQUIT.\n  # old_pid = \"#{server.config[:pid]}.oldbin\"\n  # if old_pid != server.pid\n  #   begin\n  #     sig = (worker.nr + 1) >= server.worker_processes ? :QUIT : :TTOU\n  #     Process.kill(sig, File.read(old_pid).to_i)\n  #   rescue Errno::ENOENT, Errno::ESRCH\n  #   end\n  # end\n  #\n  # Throttle the master from forking too quickly by sleeping.  Due\n  # to the implementation of standard Unix signal handlers, this\n  # helps (but does not completely) prevent identical, repeated signals\n  # from being lost when the receiving process is busy.\n  # sleep 1\nend\n\nafter_fork do |server, worker|\n  # per-process listener ports for debugging/admin/migrations\n  # addr = \"127.0.0.1:#{9293 + worker.nr}\"\n  # server.listen(addr, :tries => -1, :delay => 5, :tcp_nopush => true)\n\n  # the following is *required* for Rails + \"preload_app true\",\n  defined?(ActiveRecord::Base) and\n    ActiveRecord::Base.establish_connection\n\n  # if preload_app is true, then you may also want to check and\n  # restart any other shared sockets/descriptors such as Memcached,\n  # and Redis.  TokyoCabinet file handles are safe to reuse\n  # between any number of forked children (assuming your kernel\n  # correctly implements pread()/pwrite() system calls)\nend\n\n\nunicon\u8d77\u52d5\nbundle exec unicorn_rails -c config/unicorn.conf.rb -E production -D\n\n## rails\u30a4\u30f3\u30b9\u30c8\u30fc\u30eb\n```\n$ gem update --system\n$ gem install --no-ri --no-rdoc rails\n$ gem install bundler\n```\n\n## \u30d0\u30fc\u30b8\u30e7\u30f3\u78ba\u8a8d\n\n```\n$ rails -v\n```\n\n## Rails \u30a2\u30d7\u30ea\u30b1\u30fc\u30b7\u30e7\u30f3\u3092\u4f5c\u6210\n\n```\nrails new \uff1c\u30a2\u30d7\u30ea\u30b1\u30fc\u30b7\u30e7\u30f3\u540d\uff1e\n```\n\nunicorn\n\n```\n## unicorn\u306e\u30a4\u30f3\u30b9\u30c8\u30fc\u30eb\nGemfile\u306b\u4e0b\u8a18\u306e\u8a18\u8f09\u3092\u3057\u3066\u3001bundle install\u30b3\u30de\u30f3\u30c9\u3092\u5b9f\u884c\u3059\u308b\ngem 'unicorn'\n```\n\n\u4e0b\u8a18\u306eunicorn\u306e\u516c\u5f0f\u30b5\u30a4\u30c8\u306b\u30b5\u30f3\u30d7\u30eb\u8a2d\u5b9a\u30d5\u30a1\u30a4\u30eb\u304c\u30c0\u30a6\u30f3\u30ed\u30fc\u30c9\u3067\u304d\u308b\u305f\u3081\u3001\u3053\u306e\u30b5\u30a4\u30c8\u304b\u3089\u30b5\u30f3\u30d7\u30eb\u3092\u30c0\u30a6\u30f3\u30ed\u30fc\u30c9\u3057\u3066\u81ea\u5206\u306e\u74b0\u5883\u306b\u5408\u308f\u305b\u3066\u30ab\u30b9\u30bf\u30de\u30a4\u30ba\u3057\u3066\u4e0b\u3055\u3044\u3002\nhttps://unicorn.bogomips.org/Unicorn/Configurator.html\n\n### nginx\u306e\u8a2d\u5b9a\u30d5\u30a1\u30a4\u30eb\n\n/etc/nginx/conf.d/local.conf\n\n```\n# This is example contains the bare mininum to get nginx going with\n# unicorn servers.  Generally these configuration settings\n# are applicable to other HTTP application servers (and not just Ruby\n# ones), so if you have one working well for proxying another app\n# server, feel free to continue using it.\n#\n# The only setting we feel strongly about is the fail_timeout=0\n# directive in the \"upstream\" block.  max_fails=0 also has the same\n# effect as fail_timeout=0 for current versions of nginx and may be\n# used in its place.\n#\n# Users are strongly encouraged to refer to nginx documentation for more\n# details and search for other example configs.\n\n# you generally only need one nginx worker unless you're serving\n# large amounts of static files which require blocking disk reads\nworker_processes 1;\n\n# # drop privileges, root is needed on most systems for binding to port 80\n# # (or anything < 1024).  Capability-based security may be available for\n# # your system and worth checking out so you won't need to be root to\n# # start nginx to bind on 80\n# user nobody nobody; # for systems with \"nobody\" as a group instead\n\n# Feel free to change all paths to suite your needs here, of course\n#pid /path/to/nginx.pid;\nerror_log /var/log/nginx/hogehoge_error.log;  # \u3053\u3053\u3092\u4fee\u6b63\n\nevents {\n  worker_connections 1024; # increase if you have lots of clients\n  accept_mutex off; # \"on\" if nginx worker_processes > 1\n  # use epoll; # enable for Linux 2.6+\n  # use kqueue; # enable for FreeBSD, OSX\n}\n\nhttp {\n  # nginx will find this file in the config directory set at nginx build time\n  include mime.types;\n\n  # fallback in case we can't determine a type\n  default_type application/octet-stream;\n\n  # click tracking!\n  access_log /path/to/nginx.access.log combined;   # \u3053\u3053\u3092\u4fee\u6b63\n\n  # you generally want to serve static files with nginx since\n  # unicorn is not and will never be optimized for it\n  sendfile on;\n\n  tcp_nopush on; # off may be better for *some* Comet/long-poll stuff\n  tcp_nodelay off; # on may be better for some Comet/long-poll stuff\n\n  # we haven't checked to see if Rack::Deflate on the app server is\n  # faster or not than doing compression via nginx.  It's easier\n  # to configure it all in one place here for static files and also\n  # to disable gzip for clients who don't get gzip/deflate right.\n  # There are other gzip settings that may be needed used to deal with\n  # bad clients out there, see http://wiki.nginx.org/NginxHttpGzipModule\n  gzip on;\n  gzip_http_version 1.0;\n  gzip_proxied any;\n  gzip_min_length 500;\n  gzip_disable \"MSIE [1-6]\\.\";\n  gzip_types text/plain text/html text/xml text/css\n             text/comma-separated-values\n             text/javascript application/x-javascript\n             application/atom+xml;\n\n  # this can be any application server, not just unicorn\n  upstream app_server {\n    # fail_timeout=0 means we always retry an upstream even if it failed\n    # to return a good HTTP response (in case the unicorn master nukes a\n    # single worker for timing out).\n\n    # for UNIX domain socket setups:\n    server unix:/usr/share/nginx/[\u30a2\u30d7\u30ea\u30b1\u30fc\u30b7\u30e7\u30f3\u540d]/shared/.unicorn.sock fail_timeout=0;  # \u3053\u3053\u3092\u4fee\u6b63\n\n    # for TCP setups, point these to your backend servers\n    # server 192.168.0.7:8080 fail_timeout=0;\n    # server 192.168.0.8:8080 fail_timeout=0;\n    # server 192.168.0.9:8080 fail_timeout=0;\n  }\n\n  server {\n    # enable one of the following if you're on Linux or FreeBSD\n    # listen 80 default deferred; # for Linux\n    # listen 80 default accept_filter=httpready; # for FreeBSD\n\n    # If you have IPv6, you'll likely want to have two separate listeners.\n    # One on IPv4 only (the default), and another on IPv6 only instead\n    # of a single dual-stack listener.  A dual-stack listener will make\n    # for ugly IPv4 addresses in $remote_addr (e.g \":ffff:10.0.0.1\"\n    # instead of just \"10.0.0.1\") and potentially trigger bugs in\n    # some software.\n    # listen [::]:80 ipv6only=on; # deferred or accept_filter recommended\n\n    client_max_body_size 4G;\n    server_name _;\n\n    # ~2 seconds is often enough for most folks to parse HTML/CSS and\n    # retrieve needed images/icons/frames, connections are cheap in\n    # nginx so increasing this is generally safe...\n    keepalive_timeout 5;\n\n    # path for static files\n    root /usr/share/nginx/[\u30a2\u30d7\u30ea\u30b1\u30fc\u30b7\u30e7\u30f3\u540d]/public;\n\n    # Prefer to serve static files directly from nginx to avoid unnecessary\n    # data copies from the application server.\n    #\n    # try_files directive appeared in in nginx 0.7.27 and has stabilized\n    # over time.  Older versions of nginx (e.g. 0.6.x) requires\n    # \"if (!-f $request_filename)\" which was less efficient:\n    # http://bogomips.org/unicorn.git/tree/examples/nginx.conf?id=v3.3.1#n127\n    try_files $uri/index.html $uri.html $uri @app;\n\n    location @app {\n      # an HTTP header important enough to have its own Wikipedia entry:\n      #   http://en.wikipedia.org/wiki/X-Forwarded-For\n      proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n\n      # enable this if you forward HTTPS traffic to unicorn,\n      # this helps Rack set the proper URL scheme for doing redirects:\n      # proxy_set_header X-Forwarded-Proto $scheme;\n\n      # pass the Host: header from the client right along so redirects\n      # can be set properly within the Rack application\n      proxy_set_header Host $http_host;\n\n      # we don't want nginx trying to do something clever with\n      # redirects, we set the Host: header above already.\n      proxy_redirect off;\n\n      # It's also safe to set if you're using only serving fast clients\n      # with unicorn + nginx, but not slow clients.  You normally want\n      # nginx to buffer responses to slow clients, even with Rails 3.1\n      # streaming because otherwise a slow client can become a bottleneck\n      # of unicorn.\n      #\n      # The Rack application may also set \"X-Accel-Buffering (yes|no)\"\n      # in the response headers do disable/enable buffering on a\n      # per-response basis.\n      # proxy_buffering off;\n\n      proxy_pass http://app_server;   # \u3053\u3053\u3092\u4fee\u6b63\n    }\n\n    # Rails error pages\n    error_page 500 502 503 504 /500.html;\n    location = /500.html {\n      root /usr/share/nginx/[\u30a2\u30d7\u30ea\u30b1\u30fc\u30b7\u30e7\u30f3\u540d]/public;   # \u3053\u3053\u3092\u4fee\u6b63\n    }\n  }\n}\n```\n\n\n### unicorn\u306e\u8a2d\u5b9a\u30d5\u30a1\u30a4\u30eb\n\n```\n# Sample verbose configuration file for Unicorn (not Rack)\n#\n# This configuration file documents many features of Unicorn\n# that may not be needed for some applications. See\n# http://unicorn.bogomips.org/examples/unicorn.conf.minimal.rb\n# for a much simpler configuration file.\n#\n# See http://unicorn.bogomips.org/Unicorn/Configurator.html for complete\n# documentation.\n\n# Use at least one worker per core if you're on a dedicated server,\n# more will usually help for _short_ waits on databases/caches.\nworker_processes 4\n\n# Since Unicorn is never exposed to outside clients, it does not need to\n# run on the standard HTTP port (80), there is no reason to start Unicorn\n# as root unless it's from system init scripts.\n# If running the master process as root and the workers as an unprivileged\n# user, do this to switch euid/egid in the workers (also chowns logs):\n# user \"unprivileged_user\", \"unprivileged_group\"\n\n# Help ensure your application will always spawn in the symlinked\n# \"current\" directory that Capistrano sets up.\nworking_directory \"/usr/share/nginx/[\u30a2\u30d7\u30ea\u30b1\u30fc\u30b7\u30e7\u30f3\u540d]\" # available in 0.94.0+\u3000# \u3053\u3053\u4fee\u6b63\n\n# listen on both a Unix domain socket and a TCP port,\n# we use a shorter backlog for quicker failover when busy\nlisten \"/usr/share/nginx/[\u30a2\u30d7\u30ea\u30b1\u30fc\u30b7\u30e7\u30f3\u540d]/shared/.unicorn.sock\", :backlog => 64\u3000# \u3053\u3053\u4fee\u6b63\nlisten 8080, :tcp_nopush => true  \n\n# nuke workers after 30 seconds instead of 60 seconds (the default)\ntimeout 30\n\n# feel free to point this anywhere accessible on the filesystem\npid \"/usr/share/nginx/[\u30a2\u30d7\u30ea\u30b1\u30fc\u30b7\u30e7\u30f3\u540d]/shared/pids/unicorn.pid\"\u3000#\u3000\u3053\u3053\u4fee\u6b63 \n\n# By default, the Unicorn logger will write to stderr.\n# Additionally, ome applications/frameworks log to stderr or stdout,\n# so prevent them from going to /dev/null when daemonized here:\nstderr_path \"/usr/share/nginx/[\u30a2\u30d7\u30ea\u30b1\u30fc\u30b7\u30e7\u30f3\u540d]/shared/log/unicorn.stderr.log\"\u3000# \u3053\u3053\u4fee\u6b63\u3000\nstdout_path \"/usr/share/nginx/[\u30a2\u30d7\u30ea\u30b1\u30fc\u30b7\u30e7\u30f3\u540d]/shared/log/unicorn.stdout.log\"\u3000# \u3053\u3053\u4fee\u6b63\n\n# combine Ruby 2.0.0+ with \"preload_app true\" for memory savings\npreload_app true\n\n# Enable this flag to have unicorn test client connections by writing the\n# beginning of the HTTP headers before calling the application.  This\n# prevents calling the application for connections that have disconnected\n# while queued.  This is only guaranteed to detect clients on the same\n# host unicorn runs on, and unlikely to detect disconnects even on a\n# fast LAN.\ncheck_client_connection false\n\n# local variable to guard against running a hook multiple times\nrun_once = true\n\nbefore_fork do |server, worker|\n  # the following is highly recomended for Rails + \"preload_app true\"\n  # as there's no need for the master process to hold a connection\n  defined?(ActiveRecord::Base) and\n    ActiveRecord::Base.connection.disconnect!\n\n  # Occasionally, it may be necessary to run non-idempotent code in the\n  # master before forking.  Keep in mind the above disconnect! example\n  # is idempotent and does not need a guard.\n  if run_once\n    # do_something_once_here ...\n    run_once = false # prevent from firing again\n  end\n\n  # The following is only recommended for memory/DB-constrained\n  # installations.  It is not needed if your system can house\n  # twice as many worker_processes as you have configured.\n  #\n  # # This allows a new master process to incrementally\n  # # phase out the old master process with SIGTTOU to avoid a\n  # # thundering herd (especially in the \"preload_app false\" case)\n  # # when doing a transparent upgrade.  The last worker spawned\n  # # will then kill off the old master process with a SIGQUIT.\n  # old_pid = \"#{server.config[:pid]}.oldbin\"\n  # if old_pid != server.pid\n  #   begin\n  #     sig = (worker.nr + 1) >= server.worker_processes ? :QUIT : :TTOU\n  #     Process.kill(sig, File.read(old_pid).to_i)\n  #   rescue Errno::ENOENT, Errno::ESRCH\n  #   end\n  # end\n  #\n  # Throttle the master from forking too quickly by sleeping.  Due\n  # to the implementation of standard Unix signal handlers, this\n  # helps (but does not completely) prevent identical, repeated signals\n  # from being lost when the receiving process is busy.\n  # sleep 1\nend\n\nafter_fork do |server, worker|\n  # per-process listener ports for debugging/admin/migrations\n  # addr = \"127.0.0.1:#{9293 + worker.nr}\"\n  # server.listen(addr, :tries => -1, :delay => 5, :tcp_nopush => true)\n\n  # the following is *required* for Rails + \"preload_app true\",\n  defined?(ActiveRecord::Base) and\n    ActiveRecord::Base.establish_connection\n\n  # if preload_app is true, then you may also want to check and\n  # restart any other shared sockets/descriptors such as Memcached,\n  # and Redis.  TokyoCabinet file handles are safe to reuse\n  # between any number of forked children (assuming your kernel\n  # correctly implements pread()/pwrite() system calls)\nend\n```\n\n### unicon\u8d77\u52d5\n```\nbundle exec unicorn_rails -c config/unicorn.conf.rb -E production -D\n```\n", "tags": ["Ruby", "Rails", "unicorn"]}