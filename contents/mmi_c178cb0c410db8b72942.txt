{"context": "BitVisor\u304b\u3089\u30b2\u30b9\u30c8\u306e\u30c7\u30fc\u30bf\u3092\u8aad\u307f\u305f\u3044\u3068\u304b\uff0c\u3042\u308b\u3044\u306fBitVisor\u304b\u3089\u4f55\u304b\u30c7\u30fc\u30bf\u3092\u30b2\u30b9\u30c8\u306b\u9001\u308a\u305f\u3044\u3068\u304b\uff0c\u305d\u306e\u4ed6\u8af8\u3005\u306e\u7406\u7531\u3067BitVisor\u304b\u3089\u30b2\u30b9\u30c8\u306e\u30e1\u30e2\u30ea\u9818\u57df\u3092\u53c2\u7167\u3057\u305f\u3044\u3053\u3068\u304c\u3042\u308b\u3068\u601d\u3044\u307e\u3059\uff0e\n\u4eca\u56de\u3044\u304f\u3064\u304b\u306e\u65b9\u6cd5\u306b\u3064\u3044\u3066\u307e\u3068\u3081\u305f\u3044\u3068\u601d\u3044\u307e\u3059\uff0e\n\u306a\u304a\uff0c\u4ee5\u4e0b\u306e\u6587\u7ae0\u306f\u7c21\u7565\u5316\u3084\u5b9f\u9a13\u74b0\u5883\u7b49\u306e\u7406\u7531\u304b\u3089\u57fa\u672c\u7684\u306bIntel 64\u304b\u3064\u30b2\u30b9\u30c8OS\u3068\u3057\u3066GNU/Linux\u3092\u4eee\u5b9a\u3057\u3066\u3044\u307e\u3059\uff0e\u3054\u4e86\u627f\u304f\u3060\u3055\u3044\uff0e\n\n\u76ee\u6b21\n\nVMCALL\u306e\u30ec\u30b8\u30b9\u30bf\u6e21\u3057\u3067\u9811\u5f35\u308b\n\u30b2\u30b9\u30c8\u306e\u7269\u7406\u30a2\u30c9\u30ec\u30b9\u3092\u4f1d\u3048\u308b (\u30ab\u30fc\u30cd\u30eb\u7de8)\n\u30b2\u30b9\u30c8\u306e\u7269\u7406\u30a2\u30c9\u30ec\u30b9\u3092\u4f1d\u3048\u308b (\u30e6\u30fc\u30b6\u30e9\u30f3\u30c9\u7de8)\n\u30b2\u30b9\u30c8\u306e\u4eee\u60f3\u30c9\u30ec\u30b9\u3092\u4f1d\u3048\u308b\n\n\nVMCALL\u306e\u30ec\u30b8\u30b9\u30bf\u6e21\u3057\u3067\u9811\u5f35\u308b\n\u6587\u7ae0\u5192\u982d\u3067\u30e1\u30e2\u30ea\u9818\u57df\u3092\u53c2\u7167\u3059\u308b\u3068\u8a00\u3063\u3066\u304a\u304d\u306a\u304c\u3089\u3044\u304d\u306a\u308a\u305d\u308c\u306b\u53cd\u3059\u308b\u5185\u5bb9\u3067\u3059\u304c\uff0c\u5c11\u91cf\u306e\u30c7\u30fc\u30bf\u306e\u3084\u308a\u3068\u308a\u304c\u76ee\u7684\u3067\u3042\u308c\u3070VMCALL\uff08AMD\u306a\u3089VMMCALL\uff09\u306b\u3088\u308b\u30ec\u30b8\u30b9\u30bf\u6e21\u3057\u3067\u5341\u5206\u304b\u3082\u3057\u308c\u307e\u305b\u3093\uff0e\u5b9f\u969bdbgsh\u306f\u305d\u3046\u3044\u3046\u98a8\u306b\u5b9f\u88c5\u3055\u308c\u3066\u3044\u305f\u6c17\u304c\u3057\u307e\u3059\uff0e\nVMCALL\u3067\u547c\u3070\u308c\u308bBitVisor\u306e\u95a2\u6570\u3067\u306f\u4ee5\u4e0b\u306e\u3088\u3046\u306bcurrent->vmctrl.read_general_reg()\u3067\u547c\u3073\u51fa\u3057\u5143\u306e\u30ec\u30b8\u30b9\u30bf\u306e\u5024\u304c\u53d6\u5f97\u3067\u304d\u307e\u3059\uff0e\u307e\u305f\u623b\u308a\u5024\u306frax\u30ec\u30b8\u30b9\u30bf\u306b\u8a2d\u5b9a\u3057\u307e\u3059\uff0e\n#include \"current.h\"\n#include \"initfunc.h\"\n#include \"printf.h\"\n#include \"vmmcall.h\"\n\nstatic void\nfoo(void)\n{\n    ulong rbx, rcx, rdx;\n\n    current->vmctl.read_general_reg(GENERAL_REG_RBX, &rbx);\n    current->vmctl.read_general_reg(GENERAL_REG_RCX, &rcx);\n    current->vmctl.read_general_reg(GENERAL_REG_RDX, &rdx);\n\n    printf(\"rbx = %ld\\n\", rbx);\n    printf(\"rcx = %ld\\n\", rcx);\n    printf(\"rdx = %ld\\n\", rdx);\n\n    current->vmctl.write_general_reg(GENERAL_REG_RAX, (ulong)10);\n}\n\nstatic void\nvmmcall_foo_init(void)\n{\n    vmmcall_register(\"foo\", foo);\n}\n\nINITFUNC(\"vmmcal0\", vmmcall_foo_init);\n\n\u547c\u3073\u51fa\u3057\u5074\u306ftools/common/call_vmm.h\u3092\u5229\u7528\u3059\u308c\u3070\u4ee5\u4e0b\u306e\u3088\u3046\u306b\u7c21\u5358\u306b\u30ec\u30b8\u30b9\u30bf\u306b\u5024\u3092\u8a2d\u5b9a\u3057\u3066VMCALL\u3067\u304d\u307e\u3059\uff0e\n#include <stdio.h>\n#include <stdlib.h>\n#include \"../common/call_vmm.h\"\n\nint\nmain (int argc, char **argv)\n{\n    call_vmm_function_t f;\n    call_vmm_arg_t a;\n    call_vmm_ret_t r;\n\n    CALL_VMM_GET_FUNCTION (\"foo\", &f);\n    if (!call_vmm_function_callable (&f)) {\n        fprintf (stderr, \"vmmcall \\\"foo\\\" failed\\n\");\n        exit (1);\n    }\n\n    a.rbx = (long)1;\n    a.rcx = (long)2;\n    a.rdx = (long)3;\n    call_vmm_call_function (&f, &a, &r);\n    printf(\"ret: %ld\\n\", r.rax);\n    return 0;\n}\n\nVMCALL\u306b\u3064\u3044\u3066\u306f\u4ee5\u4e0b\u306b\u8a18\u4e8b\u304c\u3042\u308a\u307e\u3059\n- BitVisor\u306eVMM\u547c\u3073\u51fa\u3057API\n\n\u30b2\u30b9\u30c8\u306e\u7269\u7406\u30a2\u30c9\u30ec\u30b9\u3092\u4f1d\u3048\u308b (\u30ab\u30fc\u30cd\u30eb\u7de8)\n\u30b2\u30b9\u30c8\u306e\u30e1\u30e2\u30ea\u9818\u57df\u3092BitVisor\u304b\u3089\u53c2\u7167\u3059\u308b\u65b9\u6cd5\u3068\u3057\u3066\u306f\uff0c\u30b2\u30b9\u30c8\u306e\u7269\u7406\u30a2\u30c9\u30ec\u30b9\u3092BitVisor\u306b\u4f1d\u3048\uff0c\u305d\u308c\u3092BitVisor\u304c\u53c2\u7167\u3059\u308b\u65b9\u6cd5\u304c\u3042\u308a\u307e\u3059\uff0e\u3061\u306a\u307f\u306b\uff0c\u30b2\u30b9\u30c8\u306e\u7269\u7406\u30a2\u30c9\u30ec\u30b9\u3068\u30db\u30b9\u30c8\u306e\u7269\u7406\u30a2\u30c9\u30ec\u30b9\u306e\u5bfe\u5fdc\u306f\u57fa\u672c\u7684\u306bpass through\u3067\u3059\uff08BitVisor\u3067\u3059\u3057\u306d\uff09\uff0e\u305f\u3060\u3057\u30b2\u30b9\u30c8\u304cBitVisor\u304c\u4f7f\u7528\u3057\u3066\u3044\u308b\u9818\u57df\u306b\u30a2\u30af\u30bb\u30b9\u3059\u308b\u3068\u56f0\u308b\u306e\u3067\uff0c\u305d\u3053\u3060\u3051ROM\u306b\u507d\u88c5\u3057\u3066\u3044\u308b\u3088\u3046\u3067\u3059\uff08core/gmm_pass.c:gmm_pass_gp2hp()\uff09\uff0e\n\u3053\u306e\u65b9\u6cd5\u3092\u4f7f\u7528\u3059\u308b\u5834\u5408\uff0c\u307e\u305aVMCALL\u306e\u5f15\u6570\u3068\u3057\u3066\uff0c\u30e1\u30e2\u30ea\u306e\u7269\u7406\u30a2\u30c9\u30ec\u30b9\u53ca\u3073\u305d\u306e\u9577\u3055\u3092\u6e21\u3057\u307e\u3059\uff0eLinux\u306e\u30ab\u30fc\u30cd\u30eb\u5185\u3067\u306fkmalloc()\u3067\u9023\u7d9a\u3057\u305f\u7269\u7406\u30e1\u30e2\u30ea\u9818\u57df\u304c\u53d6\u5f97\u3067\u304d\u307e\u3059\uff0e\u3055\u3089\u306b\uff0cvirt_to_phys()\u95a2\u6570\u3092\u4f7f\u3046\u3053\u3068\u3067\u7269\u7406\u30a2\u30c9\u30ec\u30b9\u304c\u53d6\u5f97\u3067\u304d\u307e\u3059\uff0e\u3053\u306e\u3068\u304d\u5bfe\u8c61\u306e\u30e1\u30e2\u30ea\u9818\u57df\u304c\u30b9\u30ef\u30c3\u30d7\u30a2\u30a6\u30c8\u3055\u308c\u3066\u3057\u307e\u3046\u3068\u56f0\u3063\u305f\u3053\u3068\u306b\u306a\u308a\u307e\u3059\u304c\uff0ckmalloc()\u3067\u53d6\u5f97\u3057\u305f\u30e1\u30e2\u30ea\u9818\u57df\u306f\u30b9\u30ef\u30c3\u30d7\u3055\u308c\u306a\u3044\u3053\u3068\u304c\u4fdd\u8a3c\u3055\u308c\u3066\u3044\u308b\u305f\u3081\uff0c\u5b89\u5fc3\u3057\u3066\u4f7f\u3048\u307e\u3059\uff0e\n\u4f5c\u6210\u3059\u308b\u30ab\u30fc\u30cd\u30eb\u30e2\u30b8\u30e5\u30fc\u30eb\u306e\u4f8b\uff08\u304b\u306a\u308a\u51e6\u7406\u3092\u7c21\u5358\u5316\u3057\u3066\u3044\u307e\u3059\uff0e\uff09:\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/slab.h>\n\nstatic int __init\nfoo_init (void)\n{\n    ulong phys;\n    ulong len = 1024;\n    char *buf;\n    u32 callnum;\n\n    asm volatile (\"vmcall\"\n                  : \"=a\" (callnum)\n                  : \"a\" (0), \"b\" (\"foo\"));\n\n    if (callnum == 0) {\n        printk (\"[foo] vmcall foo failed.\\n\");\n        return -EINVAL;\n    }\n\n    buf = (char *)kmalloc (len, GFP_KERNEL);\n\n    if (!buf) {\n        printk (\"foo: kmalloc failed.\\n\");\n        return -ENOMEM;\n    }\n    buf[0] = 'a'; buf[1] = 'b'; buf[2] = 'c'; buf[3] = '\\0';\n    phys = virt_to_phys (buf);\n\n    printk(\"[foo] buf: %s\\n\",buf);\n    asm volatile (\"vmcall\"\n                  :\n                  : \"a\" (callnum), \"b\" (phys)\n                  , \"c\" (len));\n\n    printk(\"[foo] buf: %s\\n\",buf);\n    return 0;\n}\n\nstatic void __exit\nfoo_exit(void)\n{\n    printk(\"[foo] exit\\n\");\n}\n\nmodule_init (foo_init);\nmodule_exit (foo_exit);\n\nVMCALL\u3067\u547c\u3073\u51fa\u3055\u308c\u308b\u95a2\u6570\u306f\uff0c\u4ee5\u4e0b\u306e\u3088\u3046\u306bmapmem_gphys()\u95a2\u6570\u3067\u30b2\u30b9\u30c8\u306e\u7269\u7406\u30a2\u30c9\u30ec\u30b9\u3092BitVisor\u304b\u3089\u53c2\u7167\u3059\u308b\u3053\u3068\u304c\u3067\u304d\u307e\u3059\uff0e\nstatic void\nfoo(void)\n{\n    ulong physaddr, bufsize;\n    u8 *buf;\n\n    current->vmctl.read_general_reg(GENERAL_REG_RBX, &physaddr);\n    current->vmctl.read_general_reg(GENERAL_REG_RCX, &bufsize);\n\n    buf = mapmem_gphys (physaddr, bufsize, MAPMEM_WRITE);\n    if(buf == NULL){\n        printf(\"[vmmcall foo] mapmem_gphys error: %ld, %ld\\n\", physaddr, bufsize);\n        current->vmctl.write_general_reg(GENERAL_REG_RAX, (ulong)1);\n        return;\n    }\n\n    printf(\"[vmmcall foo] buf = %s\\n\", buf);\n    buf[0] = 'f'; buf[1] = 'o'; buf[2] = 'o'; buf[3] = '\\0';\n\n    unmapmem(buf, bufsize);\n    current->vmctl.write_general_reg(GENERAL_REG_RAX, (ulong)0);\n}\n\nstatic void\nvmmcall_foo_init(void)\n{\n    vmmcall_register(\"foo\", foo);\n}\n\nINITFUNC(\"vmmcal0\", vmmcall_foo_init);\n\n\u5b9f\u884c\u4f8b:\n$ cd <\u30e2\u30b8\u30e5\u30fc\u30eb\u306e\u30c7\u30a3\u30ec\u30af\u30c8\u30ea>\n$ make -C /lib/modules/`uname -r`/build SUBDIRS=`pwd` modules\n$ sudo insmod foo.ko\n$ dmesg | tail -n2\n[  953.088991] [foo] buf: abc\n[  953.093051] [foo] buf: foo\n\n\u3053\u306e\u3088\u3046\u306b\u30ab\u30fc\u30cd\u30eb\u5185\u306e\u30e1\u30e2\u30ea\u9818\u57df\u3092BitVisor\u304b\u3089\u53c2\u7167\u3059\u308b\u65b9\u6cd5\u306f\uff0cBitVisor\u306ecore/vmmcall_log.c\u304a\u3088\u3073tools/log/\u304c\u53c2\u8003\u306b\u306a\u308a\u307e\u3059\uff0e\n\n\u30b2\u30b9\u30c8\u306e\u7269\u7406\u30a2\u30c9\u30ec\u30b9\u3092\u4f1d\u3048\u308b (\u30e6\u30fc\u30b6\u30e9\u30f3\u30c9\u7de8)\n\u30e6\u30fc\u30b6\u30e9\u30f3\u30c9\u3067\u7269\u7406\u30a2\u30c9\u30ec\u30b9\u3092\u4f1d\u3048\u308b\u65b9\u6cd5\u306f\uff0c\u57fa\u672c\u7684\u306b\u306f\u30ab\u30fc\u30cd\u30eb\u3067\u3084\u308b\u3053\u3068\u3068\u540c\u3058\u3067\u3059\u304c\uff0c\u3044\u304f\u3064\u304b\u554f\u984c\u304c\u3042\u308a\u307e\u3059\uff0e\n\n\nvirt_to_phys()\u304c\u4f7f\u3048\u306a\u3044\n\nmalloc()\u3067\u78ba\u4fdd\u3057\u305f\u9818\u57df\u304c\u7269\u7406\u7684\u306b\u9023\u7d9a\u3068\u306f\u9650\u3089\u306a\u3044\n\u78ba\u4fdd\u3057\u305f\u30e1\u30e2\u30ea\u9818\u57df\u304c\u30b9\u30ef\u30c3\u30d7\u30a2\u30a6\u30c8\u3055\u308c\u308b\u53ef\u80fd\u6027\u304c\u3042\u308b\n\n1.\u306b\u3064\u3044\u3066\u306f\uff0c/proc/self/pagemap\u3092\u53c2\u7167\u3059\u308b\u3053\u3068\u3067\u89e3\u6c7a\u3067\u304d\u307e\u3059\uff0e\n2.\u306b\u3064\u3044\u3066\u306f\uff0c\u3053\u308c\u306f\u30ab\u30fc\u30cd\u30eb\u5185\u3067vmalloc()\u3092\u5229\u7528\u3057\u305f\u3068\u304d\u3082\u540c\u69d8\u306e\u554f\u984c\u304c\u3042\u308a\u307e\u3059\u304c\uff0c\u5bfe\u7b56\u3068\u3057\u3066\u306f\uff0c\u30da\u30fc\u30b8\u5358\u4f4d\u3054\u3068\u306bVMCALL\u3092\u547c\u3073\u51fa\u3059\u3068\u304b\uff0c\u3042\u308b\u3044\u306f\u7269\u7406\u30da\u30fc\u30b8\u306e\u30ea\u30b9\u30c8\u3092VMCALL\u3067\u6e21\u3057\uff0cBitVisor\u5074\u3067\u30da\u30fc\u30b8\u3054\u3068\u306b\u51e6\u7406\u3059\u308b\u306a\u3069\u306e\u65b9\u6cd5\u304c\u3042\u308b\u304b\u3068\u601d\u3044\u307e\u3059\uff0e\n3.\u306b\u3064\u3044\u3066\u306f\uff0cLinux\u3067\u3042\u308c\u3070mlock(2)\u3092\u4f7f\u7528\u3067\u304d\u307e\u3059\uff0e \u9069\u5f53\u306b\u3084\u308b\u306a\u3089VMCALL\u76f4\u524d\u306b\u5bfe\u8c61\u30e1\u30e2\u30ea\u9818\u57df\u306b\u30a2\u30af\u30bb\u30b9\u3057\u3066\u304a\u3051\u3070\u306a\u3093\u3068\u304b\u306a\u308b\u304b\u3082\u3057\u308c\u307e\u305b\u3093 \uff08\u305a\u3063\u3068\u305d\u306e\u9818\u57df\u3092BitVisor\u5074\u304c\u4fdd\u6301\u3057\u3066\u53c2\u7167\u3059\u308b\u611f\u3058\u3060\u3068\u554f\u984c\u304c\u8d77\u304d\u3084\u3059\u3044\u3067\u3059\u304b\u306d\uff09\uff0e\n\u4ee5\u4e0b\uff0c\u7c21\u5358\u306a\u4f8b\u3092\u793a\u3057\u307e\u3059\uff0e\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <inttypes.h>\n#include <sys/mman.h>\n\n// http://stackoverflow.com/a/28987409\nuintptr_t vtop(uintptr_t vaddr) {\n    FILE *pagemap;\n    intptr_t paddr = 0;\n    int offset = (vaddr / sysconf(_SC_PAGESIZE)) * sizeof(uint64_t);\n    uint64_t e;\n\n    // https://www.kernel.org/doc/Documentation/vm/pagemap.txt\n    if ((pagemap = fopen(\"/proc/self/pagemap\", \"r\"))) {\n        if (lseek(fileno(pagemap), offset, SEEK_SET) == offset) {\n            if (fread(&e, sizeof(uint64_t), 1, pagemap)) {\n                if (e & (1ULL << 63)) { // page present ?\n                    paddr = e & ((1ULL << 54) - 1); // pfn mask\n                    paddr = paddr * sysconf(_SC_PAGESIZE);\n                    // add offset within page\n                    paddr = paddr | (vaddr & (sysconf(_SC_PAGESIZE) - 1));\n                }\n            }\n        }\n        fclose(pagemap);\n    }\n    return paddr;\n}\n\nint main(){\n    char *buf;\n    unsigned callnum;\n    uintptr_t phys;\n    unsigned len = sysconf(_SC_PAGESIZE);\n\n    buf = (char *)malloc(len);\n    if(buf == NULL){\n        printf(\"malloc failed\\n\");\n        return 1;\n    }\n    mlock(buf, len);\n    phys = vtop((uintptr_t)buf);\n\n    buf[0] = 'a'; buf[1] = 'b'; buf[2] = 'c'; buf[3] = '\\0';\n    printf(\"buf: %s\\n\",buf);\n\n    asm volatile (\"vmcall\"\n                  : \"=a\" (callnum)\n                  : \"a\" (0), \"b\" (\"foo\"));\n\n    if (callnum == 0) {\n        printf (\"vmcall foo failed.\\n\");\n        return 1;\n    }\n    asm volatile (\"vmcall\"\n                  :\n                  : \"a\" (callnum), \"b\" (phys)\n                  , \"c\" (len));\n\n    printf(\"buf: %s\\n\",buf);\n\n    munlock(buf, len);\n    free(buf);\n\n    return 0;\n}\n\n\n\u5b9f\u884c\u4f8b\n$ sudo ./call_foo\nbuf: abc\nbuf: foo\n\n\u306a\u304a\uff0cLinux4.0\u4ee5\u964d\uff0c/proc/self/pagemap\u306e\u30a2\u30af\u30bb\u30b9\u306b\u306fCAP_SYS_ADMIN\u30b1\u30fc\u30d1\u30d3\u30ea\u30c6\u30a3\u304c\u5fc5\u8981\u306b\u306a\u3063\u305f\u3088\u3046\u3067\uff0c\u8981\u3059\u308b\u306b\u5b9f\u884c\u306b\u306f\u5b9f\u8cea\u7684\u306b\u7ba1\u7406\u8005\u6a29\u9650\u304c\u5fc5\u8981\u3067\u3059\uff0e\n\n\u30b2\u30b9\u30c8\u306e\u4eee\u60f3\u30c9\u30ec\u30b9\u3092\u4f1d\u3048\u308b\n\u3055\u3066\uff0c\u4eca\u307e\u3067\u30b2\u30b9\u30c8\u5074\u3067\u7269\u7406\u30a2\u30c9\u30ec\u30b9\u3092\u53d6\u5f97\u3057\uff0c\u305d\u308c\u3092BitVisor\u306b\u4f1d\u3048\u308b\u3053\u3068\u3067\u30e1\u30e2\u30ea\u53c2\u7167\u3092\u304a\u3053\u306a\u3044\u307e\u3057\u305f\u304c\uff0c\u5b9f\u3092\u3044\u3046\u3068BitVisor\u306b\u306f\u30b2\u30b9\u30c8\u306e\u4eee\u60f3\u30a2\u30c9\u30ec\u30b9\u3092\u81ea\u5206\u3067\u89e3\u6c7a\u3057\u3066\u30e1\u30e2\u30ea\u306e\u8aad\u307f\u66f8\u304d\u3092\u3059\u308b\u6a5f\u80fd\u304c\u3042\u308a\u307e\u3059\uff0e\n\u5177\u4f53\u7684\u306a\u95a2\u6570\u306f\uff0ccore/cpu_mmu.c\u5185\u306e\uff0c{read,write}_linearaddr_{b,w,l,q}\u3067\u3059\uff0e\n\u4f8b:\n#include \"current.h\"\n#include \"initfunc.h\"\n#include \"printf.h\"\n#include \"vmmcall.h\"\n#include \"mm.h\"\n#include \"cpu_mmu.h\"\n\nstatic void\nfoo(void)\n{\n    ulong addr, len;\n    int i;\n    char c;\n\n    current->vmctl.read_general_reg(GENERAL_REG_RBX, &addr);\n    current->vmctl.read_general_reg(GENERAL_REG_RCX, &len);\n\n    for(i = 0; i < len; i++){\n        read_linearaddr_b (addr + i, &c);\n        printf(\"[vmmcall foo] %c\\n\", c);\n    }\n    write_linearaddr_b (addr + 0, 'f');\n    write_linearaddr_b (addr + 1, 'o');\n    write_linearaddr_b (addr + 2, 'o');\n    write_linearaddr_b (addr + 3, '\\0');\n\n    current->vmctl.write_general_reg(GENERAL_REG_RAX, (ulong)0);\n}\n\nstatic void\nvmmcall_foo_init(void)\n{\n    vmmcall_register(\"foo\", foo);\n}\n\nINITFUNC(\"vmmcal0\", vmmcall_foo_init);\n\n#include <stdio.h>\n#include <stdlib.h>\n#include \"../common/call_vmm.h\"\n\nint main (int argc, char **argv)\n{\n    call_vmm_function_t f;\n    call_vmm_arg_t a;\n    call_vmm_ret_t r;\n\n    char buf[] = \"abc\";\n    printf(\"buf: %s\\n\",buf);\n\n    CALL_VMM_GET_FUNCTION (\"foo\", &f);\n    if (!call_vmm_function_callable (&f)) {\n        fprintf (stderr, \"vmmcall \\\"foo\\\" failed\\n\");\n        exit (1);\n    }\n    a.rbx = (unsigned long)buf;\n    a.rcx = 3;\n    call_vmm_call_function (&f, &a, &r);\n    printf(\"buf: %s\\n\",buf);\n    return 0;\n}\n\n\uff08\u672c\u5f53\u306fbuf\u306b\u95a2\u3057\u3066mlock\u3057\u306a\u3044\u3068\u30b9\u30ef\u30c3\u30d7\u30a2\u30a6\u30c8\u3055\u308c\u308b\u53ef\u80fd\u6027\u304c\u3042\u308a\u307e\u3059\u304c\uff0c\u624b\u629c\u304d\u3057\u3066\u307e\u3059\uff09\n$ gcc -o foo foo.c ../common/call_vmm.c\n$ ./foo\nbuf: abc\nbuf: foo\n\nread_linearaddr_b\u95a2\u6570\u306f\uff0c\u30b2\u30b9\u30c8\u306eCR3\u30ec\u30b8\u30b9\u30bf\u3092\u53c2\u7167\u3057\u3066\u305d\u3053\u304b\u3089PTE\u3092\u8aad\u307f\u51fa\u3057\uff0c\u7269\u7406\u30a2\u30c9\u30ec\u30b9\u3092\u6c42\u3081\uff0c\u305d\u308c\u3092mapmem()\u3057\u3066\u30c7\u30fc\u30bf\u3092\u8aad\u307f\u51fa\u3057\u3066\u3044\u307e\u3059\uff0e\u3053\u306e\u95a2\u6570\u3092\u5229\u7528\u3059\u308b\u3053\u3068\u3067\u30b2\u30b9\u30c8\u306e\u4eee\u60f3\u30a2\u30c9\u30ec\u30b9\u3092\u4f7f\u3063\u3066\u30c7\u30fc\u30bf\u306e\u8aad\u307f\u66f8\u304d\u304c\u3067\u304d\u307e\u3059\u304c\uff0c\u539f\u7406\u4e0a1\u30d0\u30a4\u30c8\uff08\u3042\u308b\u3044\u306f2/4/8\u30d0\u30a4\u30c8)\u306e\u30a2\u30af\u30bb\u30b9\u306e\u5ea6\u306bPTE\u3092\u89e3\u6c7a\u3059\u308b\u3053\u3068\u306b\u306a\u308b\u306e\u3067\uff0c\u5927\u91cf\u306e\u30c7\u30fc\u30bf\u306e\u3084\u308a\u3068\u308a\u3059\u308b\u969b\u306f\u9045\u304f\u306a\u308b\u304b\u3082\u3057\u308c\u307e\u305b\u3093\uff0e\nread_linearaddr_b\u3092\u3061\u3087\u3063\u3068\u6539\u826f\u3059\u308c\u3070\u52b9\u7387\u826f\u304f\u9023\u7d9a\u3057\u305f\u9818\u57df\u3092\u30a2\u30af\u30bb\u30b9\u3059\u308b\u3088\u3046\u306b\u3059\u308b\u3053\u3068\u306f\u53ef\u80fd\u3060\u3068\u601d\u3044\u307e\u3059\uff0e\u3069\u3046\u3057\u3066\u305d\u3046\u3057\u305f\u95a2\u6570\u304c\u306a\u3044\u306e\u304b\u3068\u3044\u3046\u3068\uff0c\u7d50\u5c40\u306e\u3068\u3053\u308d\u30b2\u30b9\u30c8\u306e\u30da\u30fc\u30b8\u4e0d\u5728\u306e\u3068\u304d\u3069\u3046\u3059\u308b\u304b\u3068\u3044\u3046\u554f\u984c\u304c\u3042\u308b\u306e\u3067\uff0c\u30b7\u30f3\u30d7\u30eb\u306a1\u30d0\u30a4\u30c8\u3054\u3068\u306e\u8aad\u307f\u51fa\u3057\u306e\u307f\u5b9f\u88c5\u3057\u3066\u3044\u308b\u306e\u304b\u306a\u3068\u601d\u3044\u307e\u3057\u305f\uff0e\n(2016-12-23 \u8ffd\u8a18:)\nBitVisor\u306e\u30e1\u30fc\u30ea\u30f3\u30b0\u30ea\u30b9\u30c8\u306b\u30b3\u30d4\u30fc\u9ad8\u901f\u5316\u306e\u30d1\u30c3\u30c1\u304c\u6295\u3052\u3089\u308c\u3066\u3044\u305f\u306e\u3092\u767a\u898b\u3057\u307e\u3057\u305f\uff0e\n[BitVisor-devel:30] BitVisor-copy patch : http://www.bitvisor.org/archives/bitvisor-devel/2012-February/000029.html\n\u3053\u306e\u30d1\u30c3\u30c1\u306f\u30b2\u30b9\u30c8\u306e\u4eee\u60f3\u30a2\u30c9\u30ec\u30b9\u3068\u30b3\u30d4\u30fc\u9577\u3092\u53d7\u3051\u53d6\u308a\uff0c\u30da\u30fc\u30b8\u5358\u4f4d\u3054\u3068\u306b\u30a2\u30c9\u30ec\u30b9\u89e3\u6c7a\u3057\u3066\u30b3\u30d4\u30fc\u3092\u3057\u3066\u3044\u308b\u3088\u3046\u3067\u3059\uff0e\u7d50\u5c40\u30b2\u30b9\u30c8\u306e\u30da\u30fc\u30b8\u4e0d\u5728\u5bfe\u5fdc\u3092\u3069\u3046\u3059\u308b\u304b\u3068\u3044\u3046\u554f\u984c\u306e\u305f\u3081\u30de\u30fc\u30b8\u3055\u308c\u3066\u3044\u306a\u3044\u3088\u3046\u3067\u3059\u304c\uff0c\u9ad8\u901f\u306b\u30b2\u30b9\u30c8\u304b\u3089\u30b3\u30d4\u30fc\u3057\u305f\u3044\u5834\u5408\u306b\u3053\u306e\u30d1\u30c3\u30c1\u306f\u53c2\u8003\u306b\u306a\u308b\u304b\u3082\u3057\u308c\u307e\u305b\u3093\uff0e\nBitVisor\u304b\u3089\u30b2\u30b9\u30c8\u306e\u30c7\u30fc\u30bf\u3092\u8aad\u307f\u305f\u3044\u3068\u304b\uff0c\u3042\u308b\u3044\u306fBitVisor\u304b\u3089\u4f55\u304b\u30c7\u30fc\u30bf\u3092\u30b2\u30b9\u30c8\u306b\u9001\u308a\u305f\u3044\u3068\u304b\uff0c\u305d\u306e\u4ed6\u8af8\u3005\u306e\u7406\u7531\u3067BitVisor\u304b\u3089\u30b2\u30b9\u30c8\u306e\u30e1\u30e2\u30ea\u9818\u57df\u3092\u53c2\u7167\u3057\u305f\u3044\u3053\u3068\u304c\u3042\u308b\u3068\u601d\u3044\u307e\u3059\uff0e\n\u4eca\u56de\u3044\u304f\u3064\u304b\u306e\u65b9\u6cd5\u306b\u3064\u3044\u3066\u307e\u3068\u3081\u305f\u3044\u3068\u601d\u3044\u307e\u3059\uff0e\n\n\n\u306a\u304a\uff0c\u4ee5\u4e0b\u306e\u6587\u7ae0\u306f\u7c21\u7565\u5316\u3084\u5b9f\u9a13\u74b0\u5883\u7b49\u306e\u7406\u7531\u304b\u3089\u57fa\u672c\u7684\u306bIntel 64\u304b\u3064\u30b2\u30b9\u30c8OS\u3068\u3057\u3066GNU/Linux\u3092\u4eee\u5b9a\u3057\u3066\u3044\u307e\u3059\uff0e\u3054\u4e86\u627f\u304f\u3060\u3055\u3044\uff0e\n\n## \u76ee\u6b21\n\n<!-- START doctoc generated TOC please keep comment here to allow auto update -->\n<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->\n\n\n- [VMCALL\u306e\u30ec\u30b8\u30b9\u30bf\u6e21\u3057\u3067\u9811\u5f35\u308b](#vmcall%E3%81%AE%E3%83%AC%E3%82%B8%E3%82%B9%E3%82%BF%E6%B8%A1%E3%81%97%E3%81%A7%E9%A0%91%E5%BC%B5%E3%82%8B)\n- [\u30b2\u30b9\u30c8\u306e\u7269\u7406\u30a2\u30c9\u30ec\u30b9\u3092\u4f1d\u3048\u308b (\u30ab\u30fc\u30cd\u30eb\u7de8)](#%E3%82%B2%E3%82%B9%E3%83%88%E3%81%AE%E7%89%A9%E7%90%86%E3%82%A2%E3%83%89%E3%83%AC%E3%82%B9%E3%82%92%E4%BC%9D%E3%81%88%E3%82%8B-%E3%82%AB%E3%83%BC%E3%83%8D%E3%83%AB%E7%B7%A8)\n- [\u30b2\u30b9\u30c8\u306e\u7269\u7406\u30a2\u30c9\u30ec\u30b9\u3092\u4f1d\u3048\u308b (\u30e6\u30fc\u30b6\u30e9\u30f3\u30c9\u7de8)](#%E3%82%B2%E3%82%B9%E3%83%88%E3%81%AE%E7%89%A9%E7%90%86%E3%82%A2%E3%83%89%E3%83%AC%E3%82%B9%E3%82%92%E4%BC%9D%E3%81%88%E3%82%8B-%E3%83%A6%E3%83%BC%E3%82%B6%E3%83%A9%E3%83%B3%E3%83%89%E7%B7%A8)\n- [\u30b2\u30b9\u30c8\u306e\u4eee\u60f3\u30c9\u30ec\u30b9\u3092\u4f1d\u3048\u308b](#%E3%82%B2%E3%82%B9%E3%83%88%E3%81%AE%E4%BB%AE%E6%83%B3%E3%83%89%E3%83%AC%E3%82%B9%E3%82%92%E4%BC%9D%E3%81%88%E3%82%8B)\n\n<!-- END doctoc generated TOC please keep comment here to allow auto update -->\n\n## VMCALL\u306e\u30ec\u30b8\u30b9\u30bf\u6e21\u3057\u3067\u9811\u5f35\u308b\n\u6587\u7ae0\u5192\u982d\u3067\u30e1\u30e2\u30ea\u9818\u57df\u3092\u53c2\u7167\u3059\u308b\u3068\u8a00\u3063\u3066\u304a\u304d\u306a\u304c\u3089\u3044\u304d\u306a\u308a\u305d\u308c\u306b\u53cd\u3059\u308b\u5185\u5bb9\u3067\u3059\u304c\uff0c\u5c11\u91cf\u306e\u30c7\u30fc\u30bf\u306e\u3084\u308a\u3068\u308a\u304c\u76ee\u7684\u3067\u3042\u308c\u3070VMCALL\uff08AMD\u306a\u3089VMMCALL\uff09\u306b\u3088\u308b\u30ec\u30b8\u30b9\u30bf\u6e21\u3057\u3067\u5341\u5206\u304b\u3082\u3057\u308c\u307e\u305b\u3093\uff0e\u5b9f\u969bdbgsh\u306f\u305d\u3046\u3044\u3046\u98a8\u306b\u5b9f\u88c5\u3055\u308c\u3066\u3044\u305f\u6c17\u304c\u3057\u307e\u3059\uff0e\n\nVMCALL\u3067\u547c\u3070\u308c\u308bBitVisor\u306e\u95a2\u6570\u3067\u306f\u4ee5\u4e0b\u306e\u3088\u3046\u306b`current->vmctrl.read_general_reg()`\u3067\u547c\u3073\u51fa\u3057\u5143\u306e\u30ec\u30b8\u30b9\u30bf\u306e\u5024\u304c\u53d6\u5f97\u3067\u304d\u307e\u3059\uff0e\u307e\u305f\u623b\u308a\u5024\u306frax\u30ec\u30b8\u30b9\u30bf\u306b\u8a2d\u5b9a\u3057\u307e\u3059\uff0e\n\n```c\n#include \"current.h\"\n#include \"initfunc.h\"\n#include \"printf.h\"\n#include \"vmmcall.h\"\n\nstatic void\nfoo(void)\n{\n    ulong rbx, rcx, rdx;\n\n    current->vmctl.read_general_reg(GENERAL_REG_RBX, &rbx);\n    current->vmctl.read_general_reg(GENERAL_REG_RCX, &rcx);\n    current->vmctl.read_general_reg(GENERAL_REG_RDX, &rdx);\n\n    printf(\"rbx = %ld\\n\", rbx);\n    printf(\"rcx = %ld\\n\", rcx);\n    printf(\"rdx = %ld\\n\", rdx);\n\n    current->vmctl.write_general_reg(GENERAL_REG_RAX, (ulong)10);\n}\n\nstatic void\nvmmcall_foo_init(void)\n{\n    vmmcall_register(\"foo\", foo);\n}\n\nINITFUNC(\"vmmcal0\", vmmcall_foo_init);\n```\n\n\u547c\u3073\u51fa\u3057\u5074\u306f`tools/common/call_vmm.h`\u3092\u5229\u7528\u3059\u308c\u3070\u4ee5\u4e0b\u306e\u3088\u3046\u306b\u7c21\u5358\u306b\u30ec\u30b8\u30b9\u30bf\u306b\u5024\u3092\u8a2d\u5b9a\u3057\u3066VMCALL\u3067\u304d\u307e\u3059\uff0e\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n#include \"../common/call_vmm.h\"\n\nint\nmain (int argc, char **argv)\n{\n    call_vmm_function_t f;\n    call_vmm_arg_t a;\n    call_vmm_ret_t r;\n\n    CALL_VMM_GET_FUNCTION (\"foo\", &f);\n    if (!call_vmm_function_callable (&f)) {\n        fprintf (stderr, \"vmmcall \\\"foo\\\" failed\\n\");\n        exit (1);\n    }\n\n    a.rbx = (long)1;\n    a.rcx = (long)2;\n    a.rdx = (long)3;\n    call_vmm_call_function (&f, &a, &r);\n    printf(\"ret: %ld\\n\", r.rax);\n    return 0;\n}\n```\n\nVMCALL\u306b\u3064\u3044\u3066\u306f\u4ee5\u4e0b\u306b\u8a18\u4e8b\u304c\u3042\u308a\u307e\u3059\n- [BitVisor\u306eVMM\u547c\u3073\u51fa\u3057API](http://qiita.com/hdk_2/items/c8c47ac91ab59b75549c)\n\n## \u30b2\u30b9\u30c8\u306e\u7269\u7406\u30a2\u30c9\u30ec\u30b9\u3092\u4f1d\u3048\u308b (\u30ab\u30fc\u30cd\u30eb\u7de8)\n\u30b2\u30b9\u30c8\u306e\u30e1\u30e2\u30ea\u9818\u57df\u3092BitVisor\u304b\u3089\u53c2\u7167\u3059\u308b\u65b9\u6cd5\u3068\u3057\u3066\u306f\uff0c\u30b2\u30b9\u30c8\u306e\u7269\u7406\u30a2\u30c9\u30ec\u30b9\u3092BitVisor\u306b\u4f1d\u3048\uff0c\u305d\u308c\u3092BitVisor\u304c\u53c2\u7167\u3059\u308b\u65b9\u6cd5\u304c\u3042\u308a\u307e\u3059\uff0e\u3061\u306a\u307f\u306b\uff0c\u30b2\u30b9\u30c8\u306e\u7269\u7406\u30a2\u30c9\u30ec\u30b9\u3068\u30db\u30b9\u30c8\u306e\u7269\u7406\u30a2\u30c9\u30ec\u30b9\u306e\u5bfe\u5fdc\u306f\u57fa\u672c\u7684\u306bpass through\u3067\u3059\uff08BitVisor\u3067\u3059\u3057\u306d\uff09\uff0e\u305f\u3060\u3057\u30b2\u30b9\u30c8\u304cBitVisor\u304c\u4f7f\u7528\u3057\u3066\u3044\u308b\u9818\u57df\u306b\u30a2\u30af\u30bb\u30b9\u3059\u308b\u3068\u56f0\u308b\u306e\u3067\uff0c\u305d\u3053\u3060\u3051ROM\u306b\u507d\u88c5\u3057\u3066\u3044\u308b\u3088\u3046\u3067\u3059\uff08`core/gmm_pass.c:gmm_pass_gp2hp()`\uff09\uff0e\n\n\n\u3053\u306e\u65b9\u6cd5\u3092\u4f7f\u7528\u3059\u308b\u5834\u5408\uff0c\u307e\u305aVMCALL\u306e\u5f15\u6570\u3068\u3057\u3066\uff0c\u30e1\u30e2\u30ea\u306e\u7269\u7406\u30a2\u30c9\u30ec\u30b9\u53ca\u3073\u305d\u306e\u9577\u3055\u3092\u6e21\u3057\u307e\u3059\uff0eLinux\u306e\u30ab\u30fc\u30cd\u30eb\u5185\u3067\u306f`kmalloc()`\u3067\u9023\u7d9a\u3057\u305f\u7269\u7406\u30e1\u30e2\u30ea\u9818\u57df\u304c\u53d6\u5f97\u3067\u304d\u307e\u3059\uff0e\u3055\u3089\u306b\uff0c`virt_to_phys()`\u95a2\u6570\u3092\u4f7f\u3046\u3053\u3068\u3067\u7269\u7406\u30a2\u30c9\u30ec\u30b9\u304c\u53d6\u5f97\u3067\u304d\u307e\u3059\uff0e\u3053\u306e\u3068\u304d\u5bfe\u8c61\u306e\u30e1\u30e2\u30ea\u9818\u57df\u304c\u30b9\u30ef\u30c3\u30d7\u30a2\u30a6\u30c8\u3055\u308c\u3066\u3057\u307e\u3046\u3068\u56f0\u3063\u305f\u3053\u3068\u306b\u306a\u308a\u307e\u3059\u304c\uff0c`kmalloc()`\u3067\u53d6\u5f97\u3057\u305f\u30e1\u30e2\u30ea\u9818\u57df\u306f\u30b9\u30ef\u30c3\u30d7\u3055\u308c\u306a\u3044\u3053\u3068\u304c\u4fdd\u8a3c\u3055\u308c\u3066\u3044\u308b\u305f\u3081\uff0c\u5b89\u5fc3\u3057\u3066\u4f7f\u3048\u307e\u3059\uff0e\n\n\n\u4f5c\u6210\u3059\u308b\u30ab\u30fc\u30cd\u30eb\u30e2\u30b8\u30e5\u30fc\u30eb\u306e\u4f8b\uff08\u304b\u306a\u308a\u51e6\u7406\u3092\u7c21\u5358\u5316\u3057\u3066\u3044\u307e\u3059\uff0e\uff09:\n\n```c\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/slab.h>\n\nstatic int __init\nfoo_init (void)\n{\n    ulong phys;\n    ulong len = 1024;\n    char *buf;\n    u32 callnum;\n\n    asm volatile (\"vmcall\"\n                  : \"=a\" (callnum)\n                  : \"a\" (0), \"b\" (\"foo\"));\n\n    if (callnum == 0) {\n        printk (\"[foo] vmcall foo failed.\\n\");\n        return -EINVAL;\n    }\n\n    buf = (char *)kmalloc (len, GFP_KERNEL);\n\n    if (!buf) {\n        printk (\"foo: kmalloc failed.\\n\");\n        return -ENOMEM;\n    }\n    buf[0] = 'a'; buf[1] = 'b'; buf[2] = 'c'; buf[3] = '\\0';\n    phys = virt_to_phys (buf);\n\n    printk(\"[foo] buf: %s\\n\",buf);\n    asm volatile (\"vmcall\"\n                  :\n                  : \"a\" (callnum), \"b\" (phys)\n                  , \"c\" (len));\n\n    printk(\"[foo] buf: %s\\n\",buf);\n    return 0;\n}\n\nstatic void __exit\nfoo_exit(void)\n{\n    printk(\"[foo] exit\\n\");\n}\n\nmodule_init (foo_init);\nmodule_exit (foo_exit);\n```\n\nVMCALL\u3067\u547c\u3073\u51fa\u3055\u308c\u308b\u95a2\u6570\u306f\uff0c\u4ee5\u4e0b\u306e\u3088\u3046\u306b`mapmem_gphys()`\u95a2\u6570\u3067\u30b2\u30b9\u30c8\u306e\u7269\u7406\u30a2\u30c9\u30ec\u30b9\u3092BitVisor\u304b\u3089\u53c2\u7167\u3059\u308b\u3053\u3068\u304c\u3067\u304d\u307e\u3059\uff0e\n\n```c\nstatic void\nfoo(void)\n{\n    ulong physaddr, bufsize;\n    u8 *buf;\n\n    current->vmctl.read_general_reg(GENERAL_REG_RBX, &physaddr);\n    current->vmctl.read_general_reg(GENERAL_REG_RCX, &bufsize);\n\n    buf = mapmem_gphys (physaddr, bufsize, MAPMEM_WRITE);\n    if(buf == NULL){\n        printf(\"[vmmcall foo] mapmem_gphys error: %ld, %ld\\n\", physaddr, bufsize);\n        current->vmctl.write_general_reg(GENERAL_REG_RAX, (ulong)1);\n        return;\n    }\n\n    printf(\"[vmmcall foo] buf = %s\\n\", buf);\n    buf[0] = 'f'; buf[1] = 'o'; buf[2] = 'o'; buf[3] = '\\0';\n\n    unmapmem(buf, bufsize);\n    current->vmctl.write_general_reg(GENERAL_REG_RAX, (ulong)0);\n}\n\nstatic void\nvmmcall_foo_init(void)\n{\n    vmmcall_register(\"foo\", foo);\n}\n\nINITFUNC(\"vmmcal0\", vmmcall_foo_init);\n```\n\n\u5b9f\u884c\u4f8b:\n\n```\n$ cd <\u30e2\u30b8\u30e5\u30fc\u30eb\u306e\u30c7\u30a3\u30ec\u30af\u30c8\u30ea>\n$ make -C /lib/modules/`uname -r`/build SUBDIRS=`pwd` modules\n$ sudo insmod foo.ko\n$ dmesg | tail -n2\n[  953.088991] [foo] buf: abc\n[  953.093051] [foo] buf: foo\n```\n\n\u3053\u306e\u3088\u3046\u306b\u30ab\u30fc\u30cd\u30eb\u5185\u306e\u30e1\u30e2\u30ea\u9818\u57df\u3092BitVisor\u304b\u3089\u53c2\u7167\u3059\u308b\u65b9\u6cd5\u306f\uff0cBitVisor\u306e`core/vmmcall_log.c`\u304a\u3088\u3073`tools/log/`\u304c\u53c2\u8003\u306b\u306a\u308a\u307e\u3059\uff0e\n\n## \u30b2\u30b9\u30c8\u306e\u7269\u7406\u30a2\u30c9\u30ec\u30b9\u3092\u4f1d\u3048\u308b (\u30e6\u30fc\u30b6\u30e9\u30f3\u30c9\u7de8)\n\u30e6\u30fc\u30b6\u30e9\u30f3\u30c9\u3067\u7269\u7406\u30a2\u30c9\u30ec\u30b9\u3092\u4f1d\u3048\u308b\u65b9\u6cd5\u306f\uff0c\u57fa\u672c\u7684\u306b\u306f\u30ab\u30fc\u30cd\u30eb\u3067\u3084\u308b\u3053\u3068\u3068\u540c\u3058\u3067\u3059\u304c\uff0c\u3044\u304f\u3064\u304b\u554f\u984c\u304c\u3042\u308a\u307e\u3059\uff0e\n\n1. `virt_to_phys()`\u304c\u4f7f\u3048\u306a\u3044\n2. `malloc()`\u3067\u78ba\u4fdd\u3057\u305f\u9818\u57df\u304c\u7269\u7406\u7684\u306b\u9023\u7d9a\u3068\u306f\u9650\u3089\u306a\u3044\n3. \u78ba\u4fdd\u3057\u305f\u30e1\u30e2\u30ea\u9818\u57df\u304c\u30b9\u30ef\u30c3\u30d7\u30a2\u30a6\u30c8\u3055\u308c\u308b\u53ef\u80fd\u6027\u304c\u3042\u308b\n\n1.\u306b\u3064\u3044\u3066\u306f\uff0c[`/proc/self/pagemap`](https://www.kernel.org/doc/Documentation/vm/pagemap.txt)\u3092\u53c2\u7167\u3059\u308b\u3053\u3068\u3067\u89e3\u6c7a\u3067\u304d\u307e\u3059\uff0e\n\n2.\u306b\u3064\u3044\u3066\u306f\uff0c\u3053\u308c\u306f\u30ab\u30fc\u30cd\u30eb\u5185\u3067`vmalloc()`\u3092\u5229\u7528\u3057\u305f\u3068\u304d\u3082\u540c\u69d8\u306e\u554f\u984c\u304c\u3042\u308a\u307e\u3059\u304c\uff0c\u5bfe\u7b56\u3068\u3057\u3066\u306f\uff0c\u30da\u30fc\u30b8\u5358\u4f4d\u3054\u3068\u306bVMCALL\u3092\u547c\u3073\u51fa\u3059\u3068\u304b\uff0c\u3042\u308b\u3044\u306f\u7269\u7406\u30da\u30fc\u30b8\u306e\u30ea\u30b9\u30c8\u3092VMCALL\u3067\u6e21\u3057\uff0cBitVisor\u5074\u3067\u30da\u30fc\u30b8\u3054\u3068\u306b\u51e6\u7406\u3059\u308b\u306a\u3069\u306e\u65b9\u6cd5\u304c\u3042\u308b\u304b\u3068\u601d\u3044\u307e\u3059\uff0e\n\n3.\u306b\u3064\u3044\u3066\u306f\uff0cLinux\u3067\u3042\u308c\u3070[`mlock(2)`](http://man7.org/linux/man-pages/man2/mlock.2.html)\u3092\u4f7f\u7528\u3067\u304d\u307e\u3059\uff0e \u9069\u5f53\u306b\u3084\u308b\u306a\u3089VMCALL\u76f4\u524d\u306b\u5bfe\u8c61\u30e1\u30e2\u30ea\u9818\u57df\u306b\u30a2\u30af\u30bb\u30b9\u3057\u3066\u304a\u3051\u3070\u306a\u3093\u3068\u304b\u306a\u308b\u304b\u3082\u3057\u308c\u307e\u305b\u3093 \uff08\u305a\u3063\u3068\u305d\u306e\u9818\u57df\u3092BitVisor\u5074\u304c\u4fdd\u6301\u3057\u3066\u53c2\u7167\u3059\u308b\u611f\u3058\u3060\u3068\u554f\u984c\u304c\u8d77\u304d\u3084\u3059\u3044\u3067\u3059\u304b\u306d\uff09\uff0e\n\n\u4ee5\u4e0b\uff0c\u7c21\u5358\u306a\u4f8b\u3092\u793a\u3057\u307e\u3059\uff0e\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <inttypes.h>\n#include <sys/mman.h>\n\n// http://stackoverflow.com/a/28987409\nuintptr_t vtop(uintptr_t vaddr) {\n    FILE *pagemap;\n    intptr_t paddr = 0;\n    int offset = (vaddr / sysconf(_SC_PAGESIZE)) * sizeof(uint64_t);\n    uint64_t e;\n\n    // https://www.kernel.org/doc/Documentation/vm/pagemap.txt\n    if ((pagemap = fopen(\"/proc/self/pagemap\", \"r\"))) {\n        if (lseek(fileno(pagemap), offset, SEEK_SET) == offset) {\n            if (fread(&e, sizeof(uint64_t), 1, pagemap)) {\n                if (e & (1ULL << 63)) { // page present ?\n                    paddr = e & ((1ULL << 54) - 1); // pfn mask\n                    paddr = paddr * sysconf(_SC_PAGESIZE);\n                    // add offset within page\n                    paddr = paddr | (vaddr & (sysconf(_SC_PAGESIZE) - 1));\n                }\n            }\n        }\n        fclose(pagemap);\n    }\n    return paddr;\n}\n\nint main(){\n    char *buf;\n    unsigned callnum;\n    uintptr_t phys;\n    unsigned len = sysconf(_SC_PAGESIZE);\n\n    buf = (char *)malloc(len);\n    if(buf == NULL){\n        printf(\"malloc failed\\n\");\n        return 1;\n    }\n    mlock(buf, len);\n    phys = vtop((uintptr_t)buf);\n\n    buf[0] = 'a'; buf[1] = 'b'; buf[2] = 'c'; buf[3] = '\\0';\n    printf(\"buf: %s\\n\",buf);\n\n    asm volatile (\"vmcall\"\n                  : \"=a\" (callnum)\n                  : \"a\" (0), \"b\" (\"foo\"));\n\n    if (callnum == 0) {\n        printf (\"vmcall foo failed.\\n\");\n        return 1;\n    }\n    asm volatile (\"vmcall\"\n                  :\n                  : \"a\" (callnum), \"b\" (phys)\n                  , \"c\" (len));\n\n    printf(\"buf: %s\\n\",buf);\n\n    munlock(buf, len);\n    free(buf);\n\n    return 0;\n}\n\n```\n\n\u5b9f\u884c\u4f8b\n\n```\n$ sudo ./call_foo\nbuf: abc\nbuf: foo\n```\n\n\u306a\u304a\uff0cLinux4.0\u4ee5\u964d\uff0c`/proc/self/pagemap`\u306e\u30a2\u30af\u30bb\u30b9\u306b\u306f`CAP_SYS_ADMIN`\u30b1\u30fc\u30d1\u30d3\u30ea\u30c6\u30a3\u304c\u5fc5\u8981\u306b\u306a\u3063\u305f\u3088\u3046\u3067\uff0c\u8981\u3059\u308b\u306b\u5b9f\u884c\u306b\u306f\u5b9f\u8cea\u7684\u306b\u7ba1\u7406\u8005\u6a29\u9650\u304c\u5fc5\u8981\u3067\u3059\uff0e\n\n## \u30b2\u30b9\u30c8\u306e\u4eee\u60f3\u30c9\u30ec\u30b9\u3092\u4f1d\u3048\u308b\n\u3055\u3066\uff0c\u4eca\u307e\u3067\u30b2\u30b9\u30c8\u5074\u3067\u7269\u7406\u30a2\u30c9\u30ec\u30b9\u3092\u53d6\u5f97\u3057\uff0c\u305d\u308c\u3092BitVisor\u306b\u4f1d\u3048\u308b\u3053\u3068\u3067\u30e1\u30e2\u30ea\u53c2\u7167\u3092\u304a\u3053\u306a\u3044\u307e\u3057\u305f\u304c\uff0c\u5b9f\u3092\u3044\u3046\u3068BitVisor\u306b\u306f\u30b2\u30b9\u30c8\u306e\u4eee\u60f3\u30a2\u30c9\u30ec\u30b9\u3092\u81ea\u5206\u3067\u89e3\u6c7a\u3057\u3066\u30e1\u30e2\u30ea\u306e\u8aad\u307f\u66f8\u304d\u3092\u3059\u308b\u6a5f\u80fd\u304c\u3042\u308a\u307e\u3059\uff0e\n\n\u5177\u4f53\u7684\u306a\u95a2\u6570\u306f\uff0c`core/cpu_mmu.c`\u5185\u306e\uff0c`{read,write}_linearaddr_{b,w,l,q}`\u3067\u3059\uff0e\n\n\u4f8b:\n\n```c\n#include \"current.h\"\n#include \"initfunc.h\"\n#include \"printf.h\"\n#include \"vmmcall.h\"\n#include \"mm.h\"\n#include \"cpu_mmu.h\"\n\nstatic void\nfoo(void)\n{\n    ulong addr, len;\n    int i;\n    char c;\n\n    current->vmctl.read_general_reg(GENERAL_REG_RBX, &addr);\n    current->vmctl.read_general_reg(GENERAL_REG_RCX, &len);\n\n    for(i = 0; i < len; i++){\n        read_linearaddr_b (addr + i, &c);\n        printf(\"[vmmcall foo] %c\\n\", c);\n    }\n    write_linearaddr_b (addr + 0, 'f');\n    write_linearaddr_b (addr + 1, 'o');\n    write_linearaddr_b (addr + 2, 'o');\n    write_linearaddr_b (addr + 3, '\\0');\n\n    current->vmctl.write_general_reg(GENERAL_REG_RAX, (ulong)0);\n}\n\nstatic void\nvmmcall_foo_init(void)\n{\n    vmmcall_register(\"foo\", foo);\n}\n\nINITFUNC(\"vmmcal0\", vmmcall_foo_init);\n```\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n#include \"../common/call_vmm.h\"\n\nint main (int argc, char **argv)\n{\n    call_vmm_function_t f;\n    call_vmm_arg_t a;\n    call_vmm_ret_t r;\n\n    char buf[] = \"abc\";\n    printf(\"buf: %s\\n\",buf);\n\n    CALL_VMM_GET_FUNCTION (\"foo\", &f);\n    if (!call_vmm_function_callable (&f)) {\n        fprintf (stderr, \"vmmcall \\\"foo\\\" failed\\n\");\n        exit (1);\n    }\n    a.rbx = (unsigned long)buf;\n    a.rcx = 3;\n    call_vmm_call_function (&f, &a, &r);\n    printf(\"buf: %s\\n\",buf);\n    return 0;\n}\n```\n\n\uff08\u672c\u5f53\u306fbuf\u306b\u95a2\u3057\u3066mlock\u3057\u306a\u3044\u3068\u30b9\u30ef\u30c3\u30d7\u30a2\u30a6\u30c8\u3055\u308c\u308b\u53ef\u80fd\u6027\u304c\u3042\u308a\u307e\u3059\u304c\uff0c\u624b\u629c\u304d\u3057\u3066\u307e\u3059\uff09\n\n```\n$ gcc -o foo foo.c ../common/call_vmm.c\n$ ./foo\nbuf: abc\nbuf: foo\n```\n\n`read_linearaddr_b`\u95a2\u6570\u306f\uff0c\u30b2\u30b9\u30c8\u306eCR3\u30ec\u30b8\u30b9\u30bf\u3092\u53c2\u7167\u3057\u3066\u305d\u3053\u304b\u3089PTE\u3092\u8aad\u307f\u51fa\u3057\uff0c\u7269\u7406\u30a2\u30c9\u30ec\u30b9\u3092\u6c42\u3081\uff0c\u305d\u308c\u3092`mapmem()`\u3057\u3066\u30c7\u30fc\u30bf\u3092\u8aad\u307f\u51fa\u3057\u3066\u3044\u307e\u3059\uff0e\u3053\u306e\u95a2\u6570\u3092\u5229\u7528\u3059\u308b\u3053\u3068\u3067\u30b2\u30b9\u30c8\u306e\u4eee\u60f3\u30a2\u30c9\u30ec\u30b9\u3092\u4f7f\u3063\u3066\u30c7\u30fc\u30bf\u306e\u8aad\u307f\u66f8\u304d\u304c\u3067\u304d\u307e\u3059\u304c\uff0c\u539f\u7406\u4e0a1\u30d0\u30a4\u30c8\uff08\u3042\u308b\u3044\u306f2/4/8\u30d0\u30a4\u30c8)\u306e\u30a2\u30af\u30bb\u30b9\u306e\u5ea6\u306bPTE\u3092\u89e3\u6c7a\u3059\u308b\u3053\u3068\u306b\u306a\u308b\u306e\u3067\uff0c\u5927\u91cf\u306e\u30c7\u30fc\u30bf\u306e\u3084\u308a\u3068\u308a\u3059\u308b\u969b\u306f\u9045\u304f\u306a\u308b\u304b\u3082\u3057\u308c\u307e\u305b\u3093\uff0e\n\n\n`read_linearaddr_b`\u3092\u3061\u3087\u3063\u3068\u6539\u826f\u3059\u308c\u3070\u52b9\u7387\u826f\u304f\u9023\u7d9a\u3057\u305f\u9818\u57df\u3092\u30a2\u30af\u30bb\u30b9\u3059\u308b\u3088\u3046\u306b\u3059\u308b\u3053\u3068\u306f\u53ef\u80fd\u3060\u3068\u601d\u3044\u307e\u3059\uff0e\u3069\u3046\u3057\u3066\u305d\u3046\u3057\u305f\u95a2\u6570\u304c\u306a\u3044\u306e\u304b\u3068\u3044\u3046\u3068\uff0c\u7d50\u5c40\u306e\u3068\u3053\u308d\u30b2\u30b9\u30c8\u306e\u30da\u30fc\u30b8\u4e0d\u5728\u306e\u3068\u304d\u3069\u3046\u3059\u308b\u304b\u3068\u3044\u3046\u554f\u984c\u304c\u3042\u308b\u306e\u3067\uff0c\u30b7\u30f3\u30d7\u30eb\u306a1\u30d0\u30a4\u30c8\u3054\u3068\u306e\u8aad\u307f\u51fa\u3057\u306e\u307f\u5b9f\u88c5\u3057\u3066\u3044\u308b\u306e\u304b\u306a\u3068\u601d\u3044\u307e\u3057\u305f\uff0e\n\n\n\n*(2016-12-23 \u8ffd\u8a18:)*\nBitVisor\u306e\u30e1\u30fc\u30ea\u30f3\u30b0\u30ea\u30b9\u30c8\u306b\u30b3\u30d4\u30fc\u9ad8\u901f\u5316\u306e\u30d1\u30c3\u30c1\u304c\u6295\u3052\u3089\u308c\u3066\u3044\u305f\u306e\u3092\u767a\u898b\u3057\u307e\u3057\u305f\uff0e\n\n[BitVisor-devel:30] BitVisor-copy patch : http://www.bitvisor.org/archives/bitvisor-devel/2012-February/000029.html\n\n\u3053\u306e\u30d1\u30c3\u30c1\u306f\u30b2\u30b9\u30c8\u306e\u4eee\u60f3\u30a2\u30c9\u30ec\u30b9\u3068\u30b3\u30d4\u30fc\u9577\u3092\u53d7\u3051\u53d6\u308a\uff0c\u30da\u30fc\u30b8\u5358\u4f4d\u3054\u3068\u306b\u30a2\u30c9\u30ec\u30b9\u89e3\u6c7a\u3057\u3066\u30b3\u30d4\u30fc\u3092\u3057\u3066\u3044\u308b\u3088\u3046\u3067\u3059\uff0e\u7d50\u5c40\u30b2\u30b9\u30c8\u306e\u30da\u30fc\u30b8\u4e0d\u5728\u5bfe\u5fdc\u3092\u3069\u3046\u3059\u308b\u304b\u3068\u3044\u3046\u554f\u984c\u306e\u305f\u3081\u30de\u30fc\u30b8\u3055\u308c\u3066\u3044\u306a\u3044\u3088\u3046\u3067\u3059\u304c\uff0c\u9ad8\u901f\u306b\u30b2\u30b9\u30c8\u304b\u3089\u30b3\u30d4\u30fc\u3057\u305f\u3044\u5834\u5408\u306b\u3053\u306e\u30d1\u30c3\u30c1\u306f\u53c2\u8003\u306b\u306a\u308b\u304b\u3082\u3057\u308c\u307e\u305b\u3093\uff0e\n", "tags": ["BitVisor"]}