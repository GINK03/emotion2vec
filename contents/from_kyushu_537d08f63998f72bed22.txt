{"context": "\u6a2a\u6d5c\u3078\u306a\u3061\u3087\u3053\u30d7\u30ed\u30b0\u30e9\u30df\u30f3\u30b0\u52c9\u5f37\u4f1a\u306b\u3066\u904e\u53bb\u306b\u51fa\u984c\u3055\u308c\u305f\u3068\u3042\u308b\u4e16\u754c\u306e\u30bf\u30af\u30b7\u30fc\u6599\u91d1\u3092\u89e3\u3044\u3066\u307f\u305f\u3002\n\u56de\u7b54\u306b\u304b\u304b\u3063\u305f\u6642\u9593\u306f40\u5206\u7a0b\u5ea6\u3002\n[from,to].sort.join.to_sym\u304c\u975e\u5e38\u306b\u6c17\u306b\u98df\u308f\u306a\u3044\u304c\u3001sort\u3057\u306a\u304f\u3066\u3082\u3088\u3044\u3088\u3046\u306bROUTE\u306b\u9006\u9806\u3082\u6301\u3064\u306e\u306f\u304a\u304b\u3057\u306a\u8a71\u306a\u306e\u3067\u59a5\u5354\u3057\u305f\u3002\nclass Taxi\n  FIRSTRIDE = [[995, 400], [845, 350]]\n  ROUTE     = {\n    AB: [1090, 0], AC: [180,  0], AD: [540,  1], BC: [960,  0], BG: [1270, 0],\n    CD: [400,  1], CF: [200,  0], DE: [720,  1], DF: [510,  1], EG: [1050, 1],\n    FG: [230,  1]\n  }\n  ADD_FARE  = [60, 50]\n\n  def drive input\n    input.each_char.each_cons(2).inject(FIRSTRIDE[[?A, ?B, ?C].include?(input[0]) ? 0 : 1]){|(left, fare), (from, to)|\n      range, meter_type = ROUTE[[from,to].sort.join.to_sym]\n      c = range <= left ? 0 : ((range - left) / 200.0).ceil\n      [(left + 200 * c) - range, fare + ADD_FARE[meter_type] * c]\n    }[1]\n  end\nend\n\ntest = <<_TEST\n/*0*/ test( \"ADFC\", \"510\" );    \n/*1*/ test( \"CFDA\", \"500\" );    \n/*2*/ test( \"AB\", \"460\" );    \n/*3*/ test( \"BA\", \"460\" );    \n/*4*/ test( \"CD\", \"400\" );    \n/*5*/ test( \"DC\", \"350\" );    \n/*6*/ test( \"BG\", \"520\" );    \n/*7*/ test( \"GB\", \"530\" );    \n/*8*/ test( \"FDA\", \"450\" );    \n/*9*/ test( \"ADF\", \"450\" );    \n/*10*/ test( \"FDACB\", \"750\" );    \n/*11*/ test( \"BCADF\", \"710\" );    \n/*12*/ test( \"EDACB\", \"800\" );    \n/*13*/ test( \"BCADE\", \"810\" );    \n/*14*/ test( \"EGFCADE\", \"920\" );    \n/*15*/ test( \"EDACFGE\", \"910\" );    \n/*16*/ test( \"ABCDA\", \"960\" );    \n/*17*/ test( \"ADCBA\", \"1000\" );    \n/*18*/ test( \"BADCFGB\", \"1180\" );    \n/*19*/ test( \"BGFCDAB\", \"1180\" );    \n/*20*/ test( \"CDFC\", \"460\" );    \n/*21*/ test( \"CFDC\", \"450\" );    \n/*22*/ test( \"ABGEDA\", \"1420\" );    \n/*23*/ test( \"ADEGBA\", \"1470\" );    \n/*24*/ test( \"CFGB\", \"640\" );    \n/*25*/ test( \"BGFC\", \"630\" );    \n/*26*/ test( \"ABGEDFC\", \"1480\" );    \n/*27*/ test( \"CFDEGBA\", \"1520\" );    \n/*28*/ test( \"CDFGEDABG\", \"1770\" );    \n/*29*/ test( \"GBADEGFDC\", \"1680\" );\n_TEST\n\nrequire 'minitest/autorun'\n\ndescribe 'Taxi' do\n  taxi = Taxi.new\n  test.split(\"\\n\").each do |line|\n    t, n, input, expect = line.match(/^\\/\\*(\\d+)\\*\\/\\s*test\\(\\s*\"([^\"]+)\",\\s*\"([^\"]+)\"\\s*\\);*\\s*$/).to_a\n    it input do\n      assert_equal expect, taxi.drive(input).to_s\n    end\n  end\nend\n\n\n[\u6a2a\u6d5c\u3078\u306a\u3061\u3087\u3053\u30d7\u30ed\u30b0\u30e9\u30df\u30f3\u30b0\u52c9\u5f37\u4f1a](https://yhpg.doorkeeper.jp/)\u306b\u3066\u904e\u53bb\u306b\u51fa\u984c\u3055\u308c\u305f[\u3068\u3042\u308b\u4e16\u754c\u306e\u30bf\u30af\u30b7\u30fc\u6599\u91d1](http://nabetani.sakura.ne.jp/hena/ord30taxi/)\u3092\u89e3\u3044\u3066\u307f\u305f\u3002\n\u56de\u7b54\u306b\u304b\u304b\u3063\u305f\u6642\u9593\u306f40\u5206\u7a0b\u5ea6\u3002\n\n`[from,to].sort.join.to_sym`\u304c\u975e\u5e38\u306b\u6c17\u306b\u98df\u308f\u306a\u3044\u304c\u3001`sort`\u3057\u306a\u304f\u3066\u3082\u3088\u3044\u3088\u3046\u306b`ROUTE`\u306b\u9006\u9806\u3082\u6301\u3064\u306e\u306f\u304a\u304b\u3057\u306a\u8a71\u306a\u306e\u3067\u59a5\u5354\u3057\u305f\u3002\n\n```ruby\nclass Taxi\n  FIRSTRIDE = [[995, 400], [845, 350]]\n  ROUTE     = {\n    AB: [1090, 0], AC: [180,  0], AD: [540,  1], BC: [960,  0], BG: [1270, 0],\n    CD: [400,  1], CF: [200,  0], DE: [720,  1], DF: [510,  1], EG: [1050, 1],\n    FG: [230,  1]\n  }\n  ADD_FARE  = [60, 50]\n\n  def drive input\n    input.each_char.each_cons(2).inject(FIRSTRIDE[[?A, ?B, ?C].include?(input[0]) ? 0 : 1]){|(left, fare), (from, to)|\n      range, meter_type = ROUTE[[from,to].sort.join.to_sym]\n      c = range <= left ? 0 : ((range - left) / 200.0).ceil\n      [(left + 200 * c) - range, fare + ADD_FARE[meter_type] * c]\n    }[1]\n  end\nend\n\ntest = <<_TEST\n/*0*/ test( \"ADFC\", \"510\" );    \n/*1*/ test( \"CFDA\", \"500\" );    \n/*2*/ test( \"AB\", \"460\" );    \n/*3*/ test( \"BA\", \"460\" );    \n/*4*/ test( \"CD\", \"400\" );    \n/*5*/ test( \"DC\", \"350\" );    \n/*6*/ test( \"BG\", \"520\" );    \n/*7*/ test( \"GB\", \"530\" );    \n/*8*/ test( \"FDA\", \"450\" );    \n/*9*/ test( \"ADF\", \"450\" );    \n/*10*/ test( \"FDACB\", \"750\" );    \n/*11*/ test( \"BCADF\", \"710\" );    \n/*12*/ test( \"EDACB\", \"800\" );    \n/*13*/ test( \"BCADE\", \"810\" );    \n/*14*/ test( \"EGFCADE\", \"920\" );    \n/*15*/ test( \"EDACFGE\", \"910\" );    \n/*16*/ test( \"ABCDA\", \"960\" );    \n/*17*/ test( \"ADCBA\", \"1000\" );    \n/*18*/ test( \"BADCFGB\", \"1180\" );    \n/*19*/ test( \"BGFCDAB\", \"1180\" );    \n/*20*/ test( \"CDFC\", \"460\" );    \n/*21*/ test( \"CFDC\", \"450\" );    \n/*22*/ test( \"ABGEDA\", \"1420\" );    \n/*23*/ test( \"ADEGBA\", \"1470\" );    \n/*24*/ test( \"CFGB\", \"640\" );    \n/*25*/ test( \"BGFC\", \"630\" );    \n/*26*/ test( \"ABGEDFC\", \"1480\" );    \n/*27*/ test( \"CFDEGBA\", \"1520\" );    \n/*28*/ test( \"CDFGEDABG\", \"1770\" );    \n/*29*/ test( \"GBADEGFDC\", \"1680\" );\n_TEST\n\nrequire 'minitest/autorun'\n\ndescribe 'Taxi' do\n  taxi = Taxi.new\n  test.split(\"\\n\").each do |line|\n    t, n, input, expect = line.match(/^\\/\\*(\\d+)\\*\\/\\s*test\\(\\s*\"([^\"]+)\",\\s*\"([^\"]+)\"\\s*\\);*\\s*$/).to_a\n    it input do\n      assert_equal expect, taxi.drive(input).to_s\n    end\n  end\nend\n```\n", "tags": ["Ruby", "\u3069\u3046\u66f8\u304f", "yhpg"]}