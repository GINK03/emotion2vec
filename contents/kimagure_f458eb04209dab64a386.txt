{"context": " More than 1 year has passed since last update.The purpose of this article is just to show some really basic differences between using React with Javascript and using Om with Clojurescript. There are, of course, better ways to do what I'm going to show here, so please comment and suggest corrections as you see fit (here or twitter).\nAt the end of the day, your team/organization should probably weigh the benefits and the costs of using one or the other.\n\nBasic Component Definition\nKeep in mind that in CLJS/Om, you can take advantage of immutable data structures to get pure rendering out of the box, so there won't be wasted rendering (if you scope props correctly). With JS/React, you'll have to add PureRenderMixin or something to achieve the same and be disciplined in how you modify state. See my other boring post about this: http://qiita.com/kimagure/items/c38444713ea48a6f02e8 (or go straight to the demo: http://jsbin.com/cobiyi/1/edit?js,output)\n\nApplication state and root\nvar appState = {\n  columns: [{\n    id: 'name',\n    title: \"Name\"\n  }, {\n    id: 'episode',\n    title: \"Episode\"\n  }, {\n    id: 'lastViewed',\n    title: \"Last Viewed\"\n  }],\n  rows: [{\n    id: 1,\n    name: 'dfsds',\n    episode: 1,\n    lastViewed: \"20-Jan-14\"\n  }, {\n    id: 2,\n    name: \"sdfsdfsd\",\n    episode: 2,\n    lastViewed: \"21-Jan-14\"\n  }, {\n    id: 3,\n    name: \"vcxvcsd\",\n    episode: 5,\n    lastViewed: \"14-Jan-14\"\n  }]\n};\n\nfunction renderApp(state) {\n  React.render(<TrackerTable appState={state}/>, document.getElementById('app'));\n}\n\n(def app-state\n  (atom\n    {:columns [{:id :name :title \"Name\"}\n               {:id :episode :title \"Episode\"}\n               {:id :last-viewed :title \"Last Viewed\"}]\n     :rows [{:id 1 :name \"dfsds\" :episode 1 :last-viewed \"20-Jan-14\"}\n            {:id 2 :name \"sdfsdfsd\" :episode 2 :last-viewed \"21-Jan-14\"}\n            {:id 3 :name \"vcxvcsd\" :episode 5 :last-viewed \"14-Jan-14\"}]}))\n\n(om/root\n  (fn [app owner]\n    (reify om/IRender\n      (render [_]\n        (om/build tracker-table app))))\n  app-state\n  {:target (. js/document (getElementById \"app\"))})\n\n\nMain table\nJS version calls React.createClass and passes in an object, uses JSX that is transformed to plain JS targeting the specific methods per version of React.\nvar TrackerTable = React.createClass({\n  render: function () {\n    var columns = this.props.columns;\n    var rows = this.props.rows;\n    return (\n      <table>\n        <TrackerHeader columns={columns}/>\n        <TrackerBody columns={columns} rows={rows}/>\n      </table>\n    );\n  }\n});\n\nCLJS version defines a function that implements om/IRender.\n(defn tracker-table [props]\n  \"my tracker table\"\n  (reify om/IRender\n    (render [_]\n      (dom/table\n        #js {}\n        (om/build tracker-header (:columns props))\n        (om/build tracker-body props)))))\n\n\nTable row\nThese two do the same thing.\n// var PureRenderMixin = require('react/lib/ReactComponentWithPureRenderMixin');\nvar TrackerRow = React.createClass({\n  // mixins: [PureRenderMixin],\n  render: function () {\n    var row = this.props.row;\n    var columns = this.props.columns.map(function (column) {\n      var id = column.id;\n      return (\n        <td key={id}>\n          {row[id]}\n        </td>\n      );\n    });\n    return (\n      <tr>\n        {columns}\n      </tr>\n    );\n  }\n});\n\n(defn tracker-row [props]\n  \"my tracker row\"\n  (let [{columns :columns row :row} props]\n    (reify om/IRender\n      (render [_]\n        (apply\n          dom/tr\n          #js {:key (:id row)}\n          (map\n            #(let [{id :id} %]\n              (dom/td #js {:key id} (id row)))\n            columns))))))\n\n\nState update\n// This version if you care about pure render\n// You can also do this using react/lib/update: http://facebook.github.io/react/docs/update.html\nvar assign = require('react/lib/Object.assign');\n\nvar newRows = appState.rows.slice();\nnewRows.push({\n  id: 4,\n  name: \"hello\",\n  episode: 4,\n  lastViewed: \"22-Jan-14\"\n});\n\nvar newAppState = assign({}, appState, {\n  rows: newRows\n});\n\n// otherwise, appState.rows.push({...}); renderApp(appState);\n\n// explicitly call renderApp since there's no binding between app-state and our App\nrenderApp(appState);\n// you can use 'flux' or Backbone Models or whatever instead from your root if you want to\n\n;; updating the atom will update our application, yay\n(swap!\n  app-state assoc :rows\n  (conj (:rows @app-state)\n        {:id 4 :name \"hello\" :episode 4 :last-viewed \"22-Jan-14\"}))\n\nSee the original CLJS source here: https://github.com/kimagure/tracker-om/blob/master/src/tracker_om/core.cljs\n\nThe purpose of this article is just to show some really basic differences between using React with Javascript and using Om with Clojurescript. There are, of course, better ways to do what I'm going to show here, so please comment and suggest corrections as you see fit (here or twitter).\n\nAt the end of the day, your team/organization should probably weigh the benefits and the costs of using one or the other.\n\n# Basic Component Definition\n\nKeep in mind that in CLJS/Om, you can take advantage of immutable data structures to get pure rendering out of the box, so there won't be wasted rendering (if you scope props correctly). With JS/React, you'll have to add `PureRenderMixin` or something to achieve the same and be disciplined in how you modify state. See my other boring post about this: http://qiita.com/kimagure/items/c38444713ea48a6f02e8 (or go straight to the demo: http://jsbin.com/cobiyi/1/edit?js,output)\n\n## Application state and root\n\n```js\nvar appState = {\n  columns: [{\n    id: 'name',\n    title: \"Name\"\n  }, {\n    id: 'episode',\n    title: \"Episode\"\n  }, {\n    id: 'lastViewed',\n    title: \"Last Viewed\"\n  }],\n  rows: [{\n    id: 1,\n    name: 'dfsds',\n    episode: 1,\n    lastViewed: \"20-Jan-14\"\n  }, {\n    id: 2,\n    name: \"sdfsdfsd\",\n    episode: 2,\n    lastViewed: \"21-Jan-14\"\n  }, {\n    id: 3,\n    name: \"vcxvcsd\",\n    episode: 5,\n    lastViewed: \"14-Jan-14\"\n  }]\n};\n\nfunction renderApp(state) {\n  React.render(<TrackerTable appState={state}/>, document.getElementById('app'));\n}\n```\n\n```cljs\n(def app-state\n  (atom\n    {:columns [{:id :name :title \"Name\"}\n               {:id :episode :title \"Episode\"}\n               {:id :last-viewed :title \"Last Viewed\"}]\n     :rows [{:id 1 :name \"dfsds\" :episode 1 :last-viewed \"20-Jan-14\"}\n            {:id 2 :name \"sdfsdfsd\" :episode 2 :last-viewed \"21-Jan-14\"}\n            {:id 3 :name \"vcxvcsd\" :episode 5 :last-viewed \"14-Jan-14\"}]}))\n\n(om/root\n  (fn [app owner]\n    (reify om/IRender\n      (render [_]\n        (om/build tracker-table app))))\n  app-state\n  {:target (. js/document (getElementById \"app\"))})\n```\n\n## Main table\n\nJS version calls `React.createClass` and passes in an object, uses JSX that is transformed to plain JS targeting the specific methods per version of React.\n\n```js\nvar TrackerTable = React.createClass({\n  render: function () {\n    var columns = this.props.columns;\n    var rows = this.props.rows;\n    return (\n      <table>\n        <TrackerHeader columns={columns}/>\n        <TrackerBody columns={columns} rows={rows}/>\n      </table>\n    );\n  }\n});\n```\n\nCLJS version defines a function that implements om/IRender.\n\n```cljs\n(defn tracker-table [props]\n  \"my tracker table\"\n  (reify om/IRender\n    (render [_]\n      (dom/table\n        #js {}\n        (om/build tracker-header (:columns props))\n        (om/build tracker-body props)))))\n```\n\n## Table row\n\nThese two do the same thing.\n\n```js\n// var PureRenderMixin = require('react/lib/ReactComponentWithPureRenderMixin');\nvar TrackerRow = React.createClass({\n  // mixins: [PureRenderMixin],\n  render: function () {\n    var row = this.props.row;\n    var columns = this.props.columns.map(function (column) {\n      var id = column.id;\n      return (\n        <td key={id}>\n          {row[id]}\n        </td>\n      );\n    });\n    return (\n      <tr>\n        {columns}\n      </tr>\n    );\n  }\n});\n```\n\n```cljs\n(defn tracker-row [props]\n  \"my tracker row\"\n  (let [{columns :columns row :row} props]\n    (reify om/IRender\n      (render [_]\n        (apply\n          dom/tr\n          #js {:key (:id row)}\n          (map\n            #(let [{id :id} %]\n              (dom/td #js {:key id} (id row)))\n            columns))))))\n```\n\n## State update\n\n```js\n// This version if you care about pure render\n// You can also do this using react/lib/update: http://facebook.github.io/react/docs/update.html\nvar assign = require('react/lib/Object.assign');\n\nvar newRows = appState.rows.slice();\nnewRows.push({\n  id: 4,\n  name: \"hello\",\n  episode: 4,\n  lastViewed: \"22-Jan-14\"\n});\n\nvar newAppState = assign({}, appState, {\n  rows: newRows\n});\n\n// otherwise, appState.rows.push({...}); renderApp(appState);\n\n// explicitly call renderApp since there's no binding between app-state and our App\nrenderApp(appState);\n// you can use 'flux' or Backbone Models or whatever instead from your root if you want to\n```\n\n```cljs\n;; updating the atom will update our application, yay\n(swap!\n  app-state assoc :rows\n  (conj (:rows @app-state)\n        {:id 4 :name \"hello\" :episode 4 :last-viewed \"22-Jan-14\"}))\n```\n\nSee the original CLJS source here: https://github.com/kimagure/tracker-om/blob/master/src/tracker_om/core.cljs\n", "tags": ["ClojureScript", "reactjs", "OM", "JavaScript"]}