{"context": " More than 1 year has passed since last update.\n\n\u571f\u7ba1\u578b\u30e1\u30c3\u30b7\u30e5\u3092\u4f5c\u308b\u30b9\u30af\u30ea\u30d7\u30c8\n\u305d\u3046\u305d\u3046\u4f7f\u3046\u4eba\u3082\u3044\u306a\u3044\u3068\u601d\u3044\u307e\u3059\u304c\u3001\u571f\u7ba1\u3067\u3059\u3002\u63a5\u5408\u90e8\u3082\u3042\u308a\u307e\u3059\u3002\nUnity\u7528\u3067\u3059\u304c\u3001\u7ffb\u8a33\u3059\u308c\u3070\u4ed6\u306e\u74b0\u5883\u3067\u3082\u4f7f\u3048\u308b\u306f\u305a\u3067\u3059\u3002\n\n\u203b\u5f62\u72b6\u3092\u4fee\u6b63\u3057\u305f\"version2\"\u3092\u8ffd\u52a0\u3057\u307e\u3057\u305f\u3002\n\u3088\u308a\u571f\u7ba1\u3089\u3057\u304f\u306a\u3063\u3066\u304a\u308a\u307e\u3059\u3002\n\n\u672c\u4f53\n\u9069\u5f53\u306a\u30af\u30e9\u30b9\u306b\u4e0b\u306e\u30e1\u30bd\u30c3\u30c9\u3092\u8cbc\u308a\u3064\u3051\u3066\u547c\u3073\u51fa\u3059\u3068\u571f\u7ba1\u578b\u306e\u30e1\u30c3\u30b7\u30e5\u304c\u51fa\u6765\u4e0a\u304c\u308a\u307e\u3059\u3002\n\nversion1\n    // create a pipe mesh with inside surface\n    static public Mesh CreateStraightPipe(float radius, float length, float edgeLength, float thickness, int definition)\n    {\n        Mesh mesh = new Mesh();\n\n        int vertCount = (definition+1) * 20;\n\n        Vector3[] positions = new Vector3[vertCount];\n        Vector3[] normals = new Vector3[vertCount];\n        Vector2[] uvs = new Vector2[vertCount];\n        Color[] colors = new Color[vertCount];\n\n        float halfThickness = thickness * 0.5f;\n        float halfLength = length * 0.5f;\n        // greater edge. (radius, length)\n        Vector2 [] sectionPos = new Vector2[10];\n        sectionPos[0] = new Vector2(radius + thickness, -halfLength);\n        sectionPos[1] = new Vector2(radius + thickness, -halfLength + edgeLength);\n        sectionPos[2] = new Vector2(radius + halfThickness, -halfLength + edgeLength);\n        sectionPos[3] = new Vector2(radius + halfThickness, halfLength - edgeLength);\n        sectionPos[4] = new Vector2(radius, halfLength-edgeLength);\n        sectionPos[5] = new Vector2(radius, halfLength);\n        sectionPos[6] = new Vector2(radius-halfThickness, halfLength);\n        sectionPos[7] = new Vector2(radius - halfThickness, -halfLength + edgeLength);\n        sectionPos[8] = new Vector2(radius, -halfLength + edgeLength);\n        sectionPos[9] = new Vector2(radius, -halfLength);\n\n        Vector2[] sectionNormal = new Vector2[10];\n        sectionNormal[0] = new Vector2(1.0f, 0.0f);\n        sectionNormal[1] = new Vector2(0.0f, 1.0f);\n        sectionNormal[2] = new Vector2(1.0f, 0.0f);\n        sectionNormal[3] = new Vector2(0.0f, 1.0f);\n        sectionNormal[4] = new Vector2(1.0f, 0.0f);\n        sectionNormal[5] = new Vector2(0.0f, 1.0f);\n        sectionNormal[6] = new Vector2(-1.0f, 0.0f);\n        sectionNormal[7] = new Vector2(0.0f, -1.0f);\n        sectionNormal[8] = new Vector2(-1.0f, 0.0f);\n        sectionNormal[9] = new Vector2(0.0f, -1.0f);\n\n        for (int i = 0; i < definition+1; ++i )\n        {\n            float theta = ((float)i)*Mathf.PI * 2.0f / definition;\n            float u = ((float)i) / definition;\n\n            for (int j = 0; j < 20; ++j)\n            {\n                int idx = i * 20 + j;\n\n                int posIdx = ((j + 1) % 20) / 2;\n                int normalIdx = j / 2;\n                float v = ((j+1)/2) / 10.0f;\n\n                {\n                    float r = sectionPos[posIdx].x;\n                    float l = sectionPos[posIdx].y;\n                    positions[idx] = new Vector3(r * Mathf.Cos(theta), l, r * Mathf.Sin(theta));\n                }\n\n                {\n                    float r = sectionNormal[normalIdx].x;\n                    float l = sectionNormal[normalIdx].y;\n                    normals[idx] = new Vector3(r * Mathf.Cos(theta), l, r * Mathf.Sin(theta));\n                }\n\n                uvs[idx] = new Vector2(u, v);\n                colors[idx] = Color.white;\n            }\n        }\n\n        // indices\n        int [] indices = new int[definition*10*6];\n        for (int i = 0; i < definition; ++i )\n        {\n            for( int j=0; j<10;++j)\n            {\n                int baseIdx = (i * 10 + j)*6;\n\n                int baseVert1 = i * 20 + j * 2;\n                int baseVert2 = baseVert1 + 20;\n\n                indices[baseIdx + 0] = baseVert1;\n                indices[baseIdx + 1] = baseVert1+1;\n                indices[baseIdx + 2] = baseVert2;\n                indices[baseIdx + 3] = baseVert2+1;\n                indices[baseIdx + 4] = baseVert2;\n                indices[baseIdx + 5] = baseVert1+1;\n            }\n        }\n\n        mesh.vertices = positions;\n        mesh.normals = normals;\n        mesh.colors = colors;\n        mesh.uv = uvs;\n        mesh.SetIndices(indices, MeshTopology.Triangles, 0);\n\n        return mesh;\n    }\n\n\n\nversion2\n   static public Mesh CreateStraightPipe2(float radius, float length, float edgeLength, float thickness, int definition)\n    {\n        Mesh mesh = new Mesh();\n\n        int vertCount = (definition + 1) * 16;\n\n        Vector3[] positions = new Vector3[vertCount];\n        Vector3[] normals = new Vector3[vertCount];\n        Vector2[] uvs = new Vector2[vertCount];\n        Color[] colors = new Color[vertCount];\n\n        float halfThickness = thickness * 0.5f;\n        float halfLength = length * 0.5f;\n        // greater edge. (radius, length)\n        Vector2[] sectionPos = new Vector2[8];\n        sectionPos[0] = new Vector2(radius + halfThickness*3.0f, -halfLength);\n        sectionPos[1] = new Vector2(radius + halfThickness * 3.0f, -halfLength + edgeLength+thickness);\n        sectionPos[2] = new Vector2(radius + halfThickness, -halfLength + edgeLength+thickness);\n        sectionPos[3] = new Vector2(radius + halfThickness, halfLength);\n        sectionPos[4] = new Vector2(radius - halfThickness, halfLength);\n        sectionPos[5] = new Vector2(radius - halfThickness, -halfLength + edgeLength);\n        sectionPos[6] = new Vector2(radius + halfThickness, -halfLength + edgeLength);\n        sectionPos[7] = new Vector2(radius + halfThickness, -halfLength);\n\n        Vector2[] sectionNormal = new Vector2[8];\n        sectionNormal[0] = new Vector2(1.0f, 0.0f);\n        sectionNormal[1] = new Vector2(0.0f, 1.0f);\n        sectionNormal[2] = new Vector2(1.0f, 0.0f);\n        sectionNormal[3] = new Vector2(0.0f, 1.0f);\n        sectionNormal[4] = new Vector2(-1.0f, 0.0f);\n        sectionNormal[5] = new Vector2(0.0f, -1.0f);\n        sectionNormal[6] = new Vector2(-1.0f, 0.0f);\n        sectionNormal[7] = new Vector2(0.0f, -1.0f);\n\n        for (int i = 0; i < definition + 1; ++i)\n        {\n            float theta = ((float)i) * Mathf.PI * 2.0f / definition;\n            float u = ((float)i) / definition;\n\n            for (int j = 0; j < 16; ++j)\n            {\n                int idx = i * 16 + j;\n\n                int posIdx = ((j + 1) % 16) / 2;\n                int normalIdx = j / 2;\n                float v = ((j + 1) / 2) / 8.0f;\n\n                {\n                    float r = sectionPos[posIdx].x;\n                    float l = sectionPos[posIdx].y;\n                    positions[idx] = new Vector3(r * Mathf.Cos(theta), l, r * Mathf.Sin(theta));\n                }\n\n                {\n                    float r = sectionNormal[normalIdx].x;\n                    float l = sectionNormal[normalIdx].y;\n                    normals[idx] = new Vector3(r * Mathf.Cos(theta), l, r * Mathf.Sin(theta));\n                }\n\n                uvs[idx] = new Vector2(u, v);\n                colors[idx] = Color.white;\n            }\n        }\n\n        // indices\n        int[] indices = new int[definition * 8 * 6];\n        for (int i = 0; i < definition; ++i)\n        {\n            for (int j = 0; j < 8; ++j)\n            {\n                int baseIdx = (i * 8 + j) * 6;\n\n                int baseVert1 = i * 16 + j * 2;\n                int baseVert2 = baseVert1 + 16;\n\n                indices[baseIdx + 0] = baseVert1;\n                indices[baseIdx + 1] = baseVert1 + 1;\n                indices[baseIdx + 2] = baseVert2;\n                indices[baseIdx + 3] = baseVert2 + 1;\n                indices[baseIdx + 4] = baseVert2;\n                indices[baseIdx + 5] = baseVert1 + 1;\n            }\n        }\n\n        mesh.vertices = positions;\n        mesh.normals = normals;\n        mesh.colors = colors;\n        mesh.uv = uvs;\n        mesh.SetIndices(indices, MeshTopology.Triangles, 0);\n\n        return mesh;\n    }\n\n\n\n\u547c\u3073\u51fa\u3057\u5074\u306e\u4f8b\nCreate->Cube\u3068\u304b\u3067\u4f5c\u3063\u305f\u3084\u3064\u306b\u30a2\u30bf\u30c3\u30c1\u3059\u308b\u3068\u3088\u3044\u3067\u3059\u3002\n\nsample\nusing UnityEngine;\nusing System.Collections;\n\n[RequireComponent(typeof(MeshFilter))]\npublic class CreateStraightPipe : MonoBehaviour {\n\n    public int definition=16;\n    public float length=2.0f;\n    public float edgeLength=0.1f;\n    public float radius=0.5f;\n    public float thickness = 0.03f;\n\n    public bool useVersion2 = true;\n\n    [ContextMenu(\"Build\")]\n    public void Build()\n    {\n        MeshFilter filter = GetComponent<MeshFilter>();\n\n        if (!useVersion2)\n        {\n            filter.sharedMesh = MeshUtils.CreateStraightPipe(radius, length, edgeLength, thickness, definition);\n        }\n        else\n        {\n            filter.sharedMesh = MeshUtils.CreateStraightPipe2(radius, length, edgeLength, thickness, definition);\n        }\n    }\n}\n\n\n#\u571f\u7ba1\u578b\u30e1\u30c3\u30b7\u30e5\u3092\u4f5c\u308b\u30b9\u30af\u30ea\u30d7\u30c8\n\u305d\u3046\u305d\u3046\u4f7f\u3046\u4eba\u3082\u3044\u306a\u3044\u3068\u601d\u3044\u307e\u3059\u304c\u3001\u571f\u7ba1\u3067\u3059\u3002\u63a5\u5408\u90e8\u3082\u3042\u308a\u307e\u3059\u3002\nUnity\u7528\u3067\u3059\u304c\u3001\u7ffb\u8a33\u3059\u308c\u3070\u4ed6\u306e\u74b0\u5883\u3067\u3082\u4f7f\u3048\u308b\u306f\u305a\u3067\u3059\u3002\n![pipe.PNG](https://qiita-image-store.s3.amazonaws.com/0/61553/cabfc037-ba2f-e005-9ec9-25a1a618d074.png)\n\n\u203b\u5f62\u72b6\u3092\u4fee\u6b63\u3057\u305f\"version2\"\u3092\u8ffd\u52a0\u3057\u307e\u3057\u305f\u3002\n\u3088\u308a\u571f\u7ba1\u3089\u3057\u304f\u306a\u3063\u3066\u304a\u308a\u307e\u3059\u3002\n\n#\u672c\u4f53\n\u9069\u5f53\u306a\u30af\u30e9\u30b9\u306b\u4e0b\u306e\u30e1\u30bd\u30c3\u30c9\u3092\u8cbc\u308a\u3064\u3051\u3066\u547c\u3073\u51fa\u3059\u3068\u571f\u7ba1\u578b\u306e\u30e1\u30c3\u30b7\u30e5\u304c\u51fa\u6765\u4e0a\u304c\u308a\u307e\u3059\u3002\n\n\n```cs:version1\n    // create a pipe mesh with inside surface\n    static public Mesh CreateStraightPipe(float radius, float length, float edgeLength, float thickness, int definition)\n    {\n        Mesh mesh = new Mesh();\n\n        int vertCount = (definition+1) * 20;\n\n        Vector3[] positions = new Vector3[vertCount];\n        Vector3[] normals = new Vector3[vertCount];\n        Vector2[] uvs = new Vector2[vertCount];\n        Color[] colors = new Color[vertCount];\n\n        float halfThickness = thickness * 0.5f;\n        float halfLength = length * 0.5f;\n        // greater edge. (radius, length)\n        Vector2 [] sectionPos = new Vector2[10];\n        sectionPos[0] = new Vector2(radius + thickness, -halfLength);\n        sectionPos[1] = new Vector2(radius + thickness, -halfLength + edgeLength);\n        sectionPos[2] = new Vector2(radius + halfThickness, -halfLength + edgeLength);\n        sectionPos[3] = new Vector2(radius + halfThickness, halfLength - edgeLength);\n        sectionPos[4] = new Vector2(radius, halfLength-edgeLength);\n        sectionPos[5] = new Vector2(radius, halfLength);\n        sectionPos[6] = new Vector2(radius-halfThickness, halfLength);\n        sectionPos[7] = new Vector2(radius - halfThickness, -halfLength + edgeLength);\n        sectionPos[8] = new Vector2(radius, -halfLength + edgeLength);\n        sectionPos[9] = new Vector2(radius, -halfLength);\n\n        Vector2[] sectionNormal = new Vector2[10];\n        sectionNormal[0] = new Vector2(1.0f, 0.0f);\n        sectionNormal[1] = new Vector2(0.0f, 1.0f);\n        sectionNormal[2] = new Vector2(1.0f, 0.0f);\n        sectionNormal[3] = new Vector2(0.0f, 1.0f);\n        sectionNormal[4] = new Vector2(1.0f, 0.0f);\n        sectionNormal[5] = new Vector2(0.0f, 1.0f);\n        sectionNormal[6] = new Vector2(-1.0f, 0.0f);\n        sectionNormal[7] = new Vector2(0.0f, -1.0f);\n        sectionNormal[8] = new Vector2(-1.0f, 0.0f);\n        sectionNormal[9] = new Vector2(0.0f, -1.0f);\n\n        for (int i = 0; i < definition+1; ++i )\n        {\n            float theta = ((float)i)*Mathf.PI * 2.0f / definition;\n            float u = ((float)i) / definition;\n\n            for (int j = 0; j < 20; ++j)\n            {\n                int idx = i * 20 + j;\n\n                int posIdx = ((j + 1) % 20) / 2;\n                int normalIdx = j / 2;\n                float v = ((j+1)/2) / 10.0f;\n\n                {\n                    float r = sectionPos[posIdx].x;\n                    float l = sectionPos[posIdx].y;\n                    positions[idx] = new Vector3(r * Mathf.Cos(theta), l, r * Mathf.Sin(theta));\n                }\n\n                {\n                    float r = sectionNormal[normalIdx].x;\n                    float l = sectionNormal[normalIdx].y;\n                    normals[idx] = new Vector3(r * Mathf.Cos(theta), l, r * Mathf.Sin(theta));\n                }\n\n                uvs[idx] = new Vector2(u, v);\n                colors[idx] = Color.white;\n            }\n        }\n        \n        // indices\n        int [] indices = new int[definition*10*6];\n        for (int i = 0; i < definition; ++i )\n        {\n            for( int j=0; j<10;++j)\n            {\n                int baseIdx = (i * 10 + j)*6;\n\n                int baseVert1 = i * 20 + j * 2;\n                int baseVert2 = baseVert1 + 20;\n\n                indices[baseIdx + 0] = baseVert1;\n                indices[baseIdx + 1] = baseVert1+1;\n                indices[baseIdx + 2] = baseVert2;\n                indices[baseIdx + 3] = baseVert2+1;\n                indices[baseIdx + 4] = baseVert2;\n                indices[baseIdx + 5] = baseVert1+1;\n            }\n        }\n\n        mesh.vertices = positions;\n        mesh.normals = normals;\n        mesh.colors = colors;\n        mesh.uv = uvs;\n        mesh.SetIndices(indices, MeshTopology.Triangles, 0);\n        \n        return mesh;\n    }\n```\n\n```cs:version2\n   static public Mesh CreateStraightPipe2(float radius, float length, float edgeLength, float thickness, int definition)\n    {\n        Mesh mesh = new Mesh();\n\n        int vertCount = (definition + 1) * 16;\n\n        Vector3[] positions = new Vector3[vertCount];\n        Vector3[] normals = new Vector3[vertCount];\n        Vector2[] uvs = new Vector2[vertCount];\n        Color[] colors = new Color[vertCount];\n\n        float halfThickness = thickness * 0.5f;\n        float halfLength = length * 0.5f;\n        // greater edge. (radius, length)\n        Vector2[] sectionPos = new Vector2[8];\n        sectionPos[0] = new Vector2(radius + halfThickness*3.0f, -halfLength);\n        sectionPos[1] = new Vector2(radius + halfThickness * 3.0f, -halfLength + edgeLength+thickness);\n        sectionPos[2] = new Vector2(radius + halfThickness, -halfLength + edgeLength+thickness);\n        sectionPos[3] = new Vector2(radius + halfThickness, halfLength);\n        sectionPos[4] = new Vector2(radius - halfThickness, halfLength);\n        sectionPos[5] = new Vector2(radius - halfThickness, -halfLength + edgeLength);\n        sectionPos[6] = new Vector2(radius + halfThickness, -halfLength + edgeLength);\n        sectionPos[7] = new Vector2(radius + halfThickness, -halfLength);\n\n        Vector2[] sectionNormal = new Vector2[8];\n        sectionNormal[0] = new Vector2(1.0f, 0.0f);\n        sectionNormal[1] = new Vector2(0.0f, 1.0f);\n        sectionNormal[2] = new Vector2(1.0f, 0.0f);\n        sectionNormal[3] = new Vector2(0.0f, 1.0f);\n        sectionNormal[4] = new Vector2(-1.0f, 0.0f);\n        sectionNormal[5] = new Vector2(0.0f, -1.0f);\n        sectionNormal[6] = new Vector2(-1.0f, 0.0f);\n        sectionNormal[7] = new Vector2(0.0f, -1.0f);\n\n        for (int i = 0; i < definition + 1; ++i)\n        {\n            float theta = ((float)i) * Mathf.PI * 2.0f / definition;\n            float u = ((float)i) / definition;\n\n            for (int j = 0; j < 16; ++j)\n            {\n                int idx = i * 16 + j;\n\n                int posIdx = ((j + 1) % 16) / 2;\n                int normalIdx = j / 2;\n                float v = ((j + 1) / 2) / 8.0f;\n\n                {\n                    float r = sectionPos[posIdx].x;\n                    float l = sectionPos[posIdx].y;\n                    positions[idx] = new Vector3(r * Mathf.Cos(theta), l, r * Mathf.Sin(theta));\n                }\n\n                {\n                    float r = sectionNormal[normalIdx].x;\n                    float l = sectionNormal[normalIdx].y;\n                    normals[idx] = new Vector3(r * Mathf.Cos(theta), l, r * Mathf.Sin(theta));\n                }\n\n                uvs[idx] = new Vector2(u, v);\n                colors[idx] = Color.white;\n            }\n        }\n\n        // indices\n        int[] indices = new int[definition * 8 * 6];\n        for (int i = 0; i < definition; ++i)\n        {\n            for (int j = 0; j < 8; ++j)\n            {\n                int baseIdx = (i * 8 + j) * 6;\n\n                int baseVert1 = i * 16 + j * 2;\n                int baseVert2 = baseVert1 + 16;\n\n                indices[baseIdx + 0] = baseVert1;\n                indices[baseIdx + 1] = baseVert1 + 1;\n                indices[baseIdx + 2] = baseVert2;\n                indices[baseIdx + 3] = baseVert2 + 1;\n                indices[baseIdx + 4] = baseVert2;\n                indices[baseIdx + 5] = baseVert1 + 1;\n            }\n        }\n\n        mesh.vertices = positions;\n        mesh.normals = normals;\n        mesh.colors = colors;\n        mesh.uv = uvs;\n        mesh.SetIndices(indices, MeshTopology.Triangles, 0);\n\n        return mesh;\n    }\n```\n\n#\u547c\u3073\u51fa\u3057\u5074\u306e\u4f8b\nCreate->Cube\u3068\u304b\u3067\u4f5c\u3063\u305f\u3084\u3064\u306b\u30a2\u30bf\u30c3\u30c1\u3059\u308b\u3068\u3088\u3044\u3067\u3059\u3002\n\n```cs:sample\nusing UnityEngine;\nusing System.Collections;\n\n[RequireComponent(typeof(MeshFilter))]\npublic class CreateStraightPipe : MonoBehaviour {\n\n    public int definition=16;\n    public float length=2.0f;\n    public float edgeLength=0.1f;\n    public float radius=0.5f;\n    public float thickness = 0.03f;\n\n    public bool useVersion2 = true;\n\n    [ContextMenu(\"Build\")]\n    public void Build()\n    {\n        MeshFilter filter = GetComponent<MeshFilter>();\n\n        if (!useVersion2)\n        {\n            filter.sharedMesh = MeshUtils.CreateStraightPipe(radius, length, edgeLength, thickness, definition);\n        }\n        else\n        {\n            filter.sharedMesh = MeshUtils.CreateStraightPipe2(radius, length, edgeLength, thickness, definition);\n        }\n    }\n}\n```\n", "tags": ["unity5", "Unity"]}