{"tags": ["Swift", "SpriteKitBeta4"], "context": " More than 1 year has passed since last update.\n\n\u3010CJumpTo\u30a2\u30cb\u30e1\u30fc\u30b7\u30e7\u30f3\u3011\n\u7c21\u5358\u306aJumpTo\u3092\u66f8\u3044\u3066\u307f\u307e\u3057\u305f\u3002\u3053\u308c\u306b\u30b8\u30e3\u30f3\u30d7\u76ee\u7684\u5730\u307e\u3067\u306e\u9593\u306b\u4f55\u56de\u30b8\u30e3\u30f3\u30d7\u3059\u308b\u306e\u304b\u306a\u3069Cocos2D\u306eCCJumpTo\u3001CCJumpBy\u7684\u306a\u6a5f\u80fd\u3092\u304b\u3051\u308c\u3070\u3068\u601d\u3063\u3066\u3044\u307e\u3059\u3002\n\nCJumpTo.swift\nimport SpriteKit\n\nclass CJumpTo: SKNode {\n\n    init(sprite: SKSpriteNode, targetPoint: CGPoint, height: CGFloat, duration: NSTimeInterval) {\n        super.init()\n\n        let startPoint = sprite.position\n\n        var bezierPath: UIBezierPath = UIBezierPath()\n        bezierPath.moveToPoint(startPoint)\n        var controlPoint: CGPoint = CGPoint()\n        controlPoint.x = startPoint.x + (targetPoint.x - startPoint.x)/2\n        controlPoint.y = startPoint.y + height\n        bezierPath.addQuadCurveToPoint(targetPoint, controlPoint: controlPoint)\n\n        let jumpAction = SKAction.followPath(bezierPath.CGPath, asOffset:false, orientToPath:false, duration: 0.2)\n        jumpAction.timingMode = .EaseIn\n        let scaleA = SKAction.scaleTo(1.2, duration: 0.1)\n        let scaleB = SKAction.scaleTo(1.0, duration: 0.1)\n        let scaleSequence = SKAction.sequence([scaleA,scaleB])\n        let sequence = SKAction.group([jumpAction, scaleSequence])\n        sprite.runAction(sequence)\n    }\n}\n\n\n\n\n\u4f7f\u7528\u4f8b\n    override func touchesBegan(touches: NSSet, withEvent event: UIEvent) {\n        for touch: AnyObject in touches {\n            let location = touch.locationInNode(self)\n            let previousLocation = touch.previousLocationInNode(self)\n\n            CJumpTo(sprite: theSprite, targetPoint: location, height: 50, duration: 1.0)\n        }\n    }\n\n\n\n\n\u3010CJumpTo\u30fbiOS/OSX\u5bfe\u5fdc\u3011\nOSX\u3068iOS\u306e\u4e21\u5074\u3067\u4f7f\u3048\u308b\u30d0\u30fc\u30b8\u30e7\u30f3\u3082\u4f5c\u3063\u3066\u307f\u307e\u3057\u305f\u3002\n\nCJumpTo.swift\nimport SpriteKit\n\nclass CJumpTo: SKNode {\n\n    init(sprite: SKSpriteNode, targetPoint: CGPoint, height: CGFloat, duration: NSTimeInterval) {\n        super.init()\n\n        let startPoint = sprite.position\n        var finalPath: CGPath!\n\n        var controlPoint = CGPoint()\n        controlPoint.x = startPoint.x + (targetPoint.x - startPoint.x)/2\n        controlPoint.y = startPoint.y + height\n\n        #if os(iOS)\n\n            // iOS Support\n            let bezierPath: UIBezierPath = UIBezierPath()\n            bezierPath.moveToPoint(startPoint)\n            bezierPath.addQuadCurveToPoint(targetPoint, controlPoint: controlPoint)\n            finalPath = bezierPath.CGPath\n\n            #else\n\n            // OSX Support\n            var path = CGPathCreateMutable()\n            CGPathMoveToPoint(path, nil, startPoint.x, startPoint.y)\n            CGPathAddQuadCurveToPoint(path, nil, controlPoint.x, controlPoint.y, targetPoint.x, targetPoint.y)\n            finalPath = path\n\n        #endif\n\n        let jumpAction = SKAction.followPath(finalPath, asOffset:false, orientToPath:false, duration: duration)\n        jumpAction.timingMode = .EaseIn\n        let scaleA = SKAction.scaleTo(1.3, duration: (duration/4)*3)\n        let scaleB = SKAction.scaleTo(1.0, duration: (duration/4)*1)\n        let scaleSequence = SKAction.sequence([scaleA,scaleB])\n        let sequence = SKAction.group([jumpAction, scaleSequence])\n        sprite.runAction(sequence)\n\n    }\n}\n\n\n\n\u4f7f\u7528\u4f8b\n    override func touchesBegan(touches: NSSet, withEvent event: UIEvent) {\n        for touch: AnyObject in touches {\n            let location = touch.locationInNode(self)\n            let previousLocation = touch.previousLocationInNode(self)\n\n            CJumpTo(sprite: theSprite, targetPoint: location, height: 50, duration: 1.0)\n        }\n    }\n\n\n\n##\u3010CJumpTo\u30a2\u30cb\u30e1\u30fc\u30b7\u30e7\u30f3\u3011\n\u7c21\u5358\u306aJumpTo\u3092\u66f8\u3044\u3066\u307f\u307e\u3057\u305f\u3002\u3053\u308c\u306b\u30b8\u30e3\u30f3\u30d7\u76ee\u7684\u5730\u307e\u3067\u306e\u9593\u306b\u4f55\u56de\u30b8\u30e3\u30f3\u30d7\u3059\u308b\u306e\u304b\u306a\u3069Cocos2D\u306eCCJumpTo\u3001CCJumpBy\u7684\u306a\u6a5f\u80fd\u3092\u304b\u3051\u308c\u3070\u3068\u601d\u3063\u3066\u3044\u307e\u3059\u3002\n\n```swift:CJumpTo.swift\nimport SpriteKit\n\nclass CJumpTo: SKNode {\n\t\n\tinit(sprite: SKSpriteNode, targetPoint: CGPoint, height: CGFloat, duration: NSTimeInterval) {\n\t\tsuper.init()\n\n\t\tlet startPoint = sprite.position\n\n\t\tvar bezierPath: UIBezierPath = UIBezierPath()\n\t\tbezierPath.moveToPoint(startPoint)\n\t\tvar controlPoint: CGPoint = CGPoint()\n\t\tcontrolPoint.x = startPoint.x + (targetPoint.x - startPoint.x)/2\n\t\tcontrolPoint.y = startPoint.y + height\n\t\tbezierPath.addQuadCurveToPoint(targetPoint, controlPoint: controlPoint)\n\t\t\n\t\tlet jumpAction = SKAction.followPath(bezierPath.CGPath, asOffset:false, orientToPath:false, duration: 0.2)\n\t\tjumpAction.timingMode = .EaseIn\n\t\tlet scaleA = SKAction.scaleTo(1.2, duration: 0.1)\n\t\tlet scaleB = SKAction.scaleTo(1.0, duration: 0.1)\n\t\tlet scaleSequence = SKAction.sequence([scaleA,scaleB])\n\t\tlet sequence = SKAction.group([jumpAction, scaleSequence])\n\t\tsprite.runAction(sequence)\n\t}\n}\n\n```\n\n```swift:\u4f7f\u7528\u4f8b\n\toverride func touchesBegan(touches: NSSet, withEvent event: UIEvent) {\n\t\tfor touch: AnyObject in touches {\n\t\t\tlet location = touch.locationInNode(self)\n\t\t\tlet previousLocation = touch.previousLocationInNode(self)\n\t\t\t\n\t\t\tCJumpTo(sprite: theSprite, targetPoint: location, height: 50, duration: 1.0)\n\t\t}\n\t}\n\n```\n\n##\u3010CJumpTo\u30fbiOS/OSX\u5bfe\u5fdc\u3011\nOSX\u3068iOS\u306e\u4e21\u5074\u3067\u4f7f\u3048\u308b\u30d0\u30fc\u30b8\u30e7\u30f3\u3082\u4f5c\u3063\u3066\u307f\u307e\u3057\u305f\u3002\n\n```swift:CJumpTo.swift\nimport SpriteKit\n\nclass CJumpTo: SKNode {\n\t\n\tinit(sprite: SKSpriteNode, targetPoint: CGPoint, height: CGFloat, duration: NSTimeInterval) {\n\t\tsuper.init()\n\n\t\tlet startPoint = sprite.position\n\t\tvar finalPath: CGPath!\n\n\t\tvar controlPoint = CGPoint()\n\t\tcontrolPoint.x = startPoint.x + (targetPoint.x - startPoint.x)/2\n\t\tcontrolPoint.y = startPoint.y + height\n\n\t\t#if os(iOS)\n\t\t\t\n\t\t\t// iOS Support\n\t\t\tlet bezierPath: UIBezierPath = UIBezierPath()\n\t\t\tbezierPath.moveToPoint(startPoint)\n\t\t\tbezierPath.addQuadCurveToPoint(targetPoint, controlPoint: controlPoint)\n\t\t\tfinalPath = bezierPath.CGPath\n\t\t\t\n\t\t\t#else\n\t\t\t\n\t\t\t// OSX Support\n\t\t\tvar path = CGPathCreateMutable()\n\t\t\tCGPathMoveToPoint(path, nil, startPoint.x, startPoint.y)\n\t\t\tCGPathAddQuadCurveToPoint(path, nil, controlPoint.x, controlPoint.y, targetPoint.x, targetPoint.y)\n\t\t\tfinalPath = path\n\t\t\t\n\t\t#endif\n\n\t\tlet jumpAction = SKAction.followPath(finalPath, asOffset:false, orientToPath:false, duration: duration)\n\t\tjumpAction.timingMode = .EaseIn\n\t\tlet scaleA = SKAction.scaleTo(1.3, duration: (duration/4)*3)\n\t\tlet scaleB = SKAction.scaleTo(1.0, duration: (duration/4)*1)\n\t\tlet scaleSequence = SKAction.sequence([scaleA,scaleB])\n\t\tlet sequence = SKAction.group([jumpAction, scaleSequence])\n\t\tsprite.runAction(sequence)\n\n\t}\n}\n```\n\n\n```swift:\u4f7f\u7528\u4f8b\n\toverride func touchesBegan(touches: NSSet, withEvent event: UIEvent) {\n\t\tfor touch: AnyObject in touches {\n\t\t\tlet location = touch.locationInNode(self)\n\t\t\tlet previousLocation = touch.previousLocationInNode(self)\n\t\t\t\n\t\t\tCJumpTo(sprite: theSprite, targetPoint: location, height: 50, duration: 1.0)\n\t\t}\n\t}\n\n```\n"}