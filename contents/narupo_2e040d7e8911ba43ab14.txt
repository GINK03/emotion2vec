{"context": " More than 1 year has passed since last update.\n\nQt Creator \u3067 GLSL\nQt Creator \u3067 GLSL \u3092\u4f7f\u3063\u3066\u307f\u305f\u306e\u3067\u30e1\u30e2\u3002\n\nResult\n\n\nProject\nIDE \u3067\u500b\u4eba\u7684\u306b\u56f0\u308b\u306e\u304c\u30d7\u30ed\u30b8\u30a7\u30af\u30c8\u69cb\u6210\u306e\u30e1\u30e2\u308a\u65b9\u3002\n\u753b\u50cf\u306b\u3057\u305f\u3002\n\n\nmain.cpp\ndialog.h\ndialog.cpp\n\n\u306f\u30c7\u30d5\u30a9\u30eb\u30c8\u306e\u30d5\u30a1\u30a4\u30eb\u3002\n\nmygl.*\n\nmygl.hpp\n/**\n * Attribute and Uniform Reference: http://doc.qt.io/qt-5/qopenglshaderprogram.html\n */\n\n#ifndef MYGL_H\n#define MYGL_H\n\n#pragma comment(lib, \"OpenGL32.lib\")\n#pragma comment(lib, \"glu32.lib\")\n\n#include <QGL>\n#include <QGLWidget>\n\n#include <QGLBuffer>\n#include <QGLShaderProgram>\n#include <QMatrix4x4>\n\n#include <QDebug>\n#include <QWidget>\n#include <QTimer>\n#include <QMap>\n\nstruct Attribute {\n    int location;\n    int size;\n};\n\nstruct Uniform {\n    int location;\n};\n\nclass MyGL : public QGLWidget\n{\n    Q_OBJECT\n\npublic:\n    MyGL(QWidget* parent = nullptr);\n\n    virtual void initializeGL();\n    virtual void paintGL();\n    virtual void resizeGL(int w, int h);\n\nprivate:\n    bool prepareShaderProgram(\n            QString const& vertexShaderPath,\n            QString const& fragmentShaderPath);\n\nprivate:\n    QTimer timer_;\n    QGLShaderProgram program_;\n    QGLBuffer vertexBuffer_;\n\n    QMatrix4x4 mvpMat_,\n               pMat_,\n               vMat_,\n               mMat_;\n\n    QMap<QString, Attribute> attribs_;\n    QMap<QString, Uniform> uniforms_;\n};\n\n#endif // MYGL_H\n\n\n\n\nmygl.cpp\n#include \"mygl.h\"\n\nMyGL::MyGL(QWidget* parent)\n    : QGLWidget(parent)\n    , timer_()\n    , program_()\n    , vertexBuffer_(QGLBuffer::VertexBuffer)\n    , mvpMat_()\n    , pMat_()\n    , vMat_()\n    , mMat_()\n    , attribs_()\n    , uniforms_()\n{\n    connect(&timer_, SIGNAL(timeout()), this, SLOT(updateGL()));\n    timer_.start(16.666666);\n}\n\nvoid MyGL::initializeGL()\n{\n    // Init OpenGL\n    glClearColor( 0.5f, 0.5f, 0.5f, 1.0f);\n\n    // Triangle vertices for VBO\n    float points[] {\n         0.0f, 1.0f, 0.0f, 1.0f,\n        -1.0f, 0.0f, 0.0f, 1.0f,\n         1.0f, 0.0f, 0.0f, 1.0f,\n    };\n\n    // Ready VBO\n    vertexBuffer_.create();\n    vertexBuffer_.setUsagePattern(QGLBuffer::StaticDraw);\n    if (!vertexBuffer_.bind()) {\n        qWarning() << \"VBO: Failed to bind\";\n        return;\n    }\n\n    // Set vertices to VBO\n    vertexBuffer_.allocate(points, 3 * 4 * sizeof(float));\n\n    // Shader Program from source files\n    if (!prepareShaderProgram(\":/my.vs\", \":/my.fs\")) {\n        qWarning() << \"Failed to prepareShaderProgram\";\n        return;\n    }\n    if (!program_.bind()) {\n        qWarning() << \"Program: Failed to bind\";\n        return;\n    }\n\n    // Enable Attribute in Shader Program\n    program_.setAttributeBuffer(\"vertex_in_vs\", GL_FLOAT, 0, 4);\n    program_.enableAttributeArray(\"vertex_in_vs\");\n\n    // Get Location from Shader Program\n    attribs_[\"frame\"].location = program_.attributeLocation(\"frame\");\n    attribs_[\"frame\"].size = 1;\n    uniforms_[\"mvpMat\"].location = program_.uniformLocation(\"mvpMat\");\n}\n\nvoid MyGL::paintGL()\n{\n    static float frame = 0.0f;\n\n    // Viewport\n    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);\n    glViewport( 0, 0, size().width(), size().height());\n\n    // Projection\n    auto w = static_cast<double>(size().width());\n    auto h = static_cast<double>(size().height());\n\n    pMat_.setToIdentity();\n    pMat_.perspective(60.f, w/h, 0.001f, 120.0f);\n\n    // Viewing\n    vMat_.setToIdentity();\n    vMat_.lookAt({0,0,5}, {0,0,0}, {0,1,0});\n\n    // Update MVP Matrix\n    mvpMat_ = pMat_ * vMat_;\n\n    // Modeling\n    static float angle = 0.f;\n    mMat_.setToIdentity();\n    mMat_.rotate(angle, 0.f, 0.f, 1.f);\n    angle += 1.f;\n    if (angle >= 360.f)\n        angle = 0.f;\n\n    // Update MVP Matrix\n    mvpMat_ *= mMat_;\n\n    // Render\n    program_.setAttributeValue(attribs_[\"frame\"].location, frame);\n    program_.setUniformValue(uniforms_[\"mvpMat\"].location, mvpMat_);\n    glDrawArrays(GL_TRIANGLES, 0, 3);\n\n    frame += 1.f;\n}\n\nvoid MyGL::resizeGL(int w, int h)\n{\n    glViewport( 0, 0, w, h);\n}\n\nbool MyGL::prepareShaderProgram(const QString &vertexShaderPath, const QString &fragmentShaderPath)\n{\n    bool res;\n\n    // Add shader from source files\n    res = program_.addShaderFromSourceFile(QGLShader::Vertex, vertexShaderPath);\n    if (!res) {\n        qWarning() << program_.log();\n    }\n    res = program_.addShaderFromSourceFile(QGLShader::Fragment, fragmentShaderPath);\n    if (!res) {\n        qWarning() << program_.log();\n    }\n\n    // Link\n    res = program_.link();\n    if (!res) {\n        qWarning() << \"Failed to link: \" << program_.log();\n    }\n\n    return res;\n}\n\n\n\nQt \u304c\u30af\u30e9\u30b9\u3092\u7528\u610f\u3057\u3066\u304f\u308c\u3066\u3044\u308b\u304a\u304b\u3052\u3067\u30b9\u30c3\u30ad\u30ea\u3068\u66f8\u3051\u308b\u3002\n\u30aa\u30da\u30ec\u30fc\u30bf\u30fc\u306e\u30aa\u30fc\u30d0\u30fc\u30ed\u30fc\u30c9\u3067\u884c\u5217\u306e\u6f14\u7b97\u3082\u898b\u305f\u76ee\u304c\u308f\u304b\u308a\u3084\u3059\u3044\u3002\u30ad\u30e5\u30fc\u30c8\u3002\n\nShader\nVertex Shader\n\nmy.vs\nattribute vec4 vertex_in_vs;\nattribute float frame;\nuniform mat4 mvpMat;\nvarying float varFrame;\n\nvoid main(void) {\n    varFrame = frame;\n    gl_Position = mvpMat * vertex_in_vs;\n}\n\n\n\nFragment Shader\n\nmy.fs\n#version 330\nlayout(location = 0, index = 0) out vec4 fragColor;\nvarying float varFrame;\n\nvoid main(void) {\n    fragColor = vec4(abs(cos(varFrame/100.0)), abs(cos(varFrame/200.0)), abs(cos(varFrame/300.0)), 1.0);\n}\n\n\n\n\u30b7\u30a7\u30fc\u30c0\u30fc\u306f\u30ea\u30bd\u30fc\u30b9\u306b\u767b\u9332\u3059\u308b\u3002\n\nReference\nYoutube - Qt Creator + OpenGL\nwgld\n[\u9023\u8f09]\u3084\u3063\u3066\u307f\u308c\u3070\u8d85\u7c21\u5358\uff01 WebGL \u3068 GLSL \u3067\u59cb\u3081\u308b\u3001\u306f\u3058\u3081\u3066\u306e\u30b7\u30a7\u30fc\u30c0\u30b3\u30fc\u30c7\u30a3\u30f3\u30b0\uff08\uff11\uff09\nHow to use OpenGL Core Profile with Qt\n# Qt Creator \u3067 GLSL\n\nQt Creator \u3067 GLSL \u3092\u4f7f\u3063\u3066\u307f\u305f\u306e\u3067\u30e1\u30e2\u3002\n\n## Result\n\n![sample.gif](https://qiita-image-store.s3.amazonaws.com/0/41479/8db41c72-6d24-db1c-988b-e06ecd1139ec.gif)\n\n## Project\n\nIDE \u3067\u500b\u4eba\u7684\u306b\u56f0\u308b\u306e\u304c\u30d7\u30ed\u30b8\u30a7\u30af\u30c8\u69cb\u6210\u306e\u30e1\u30e2\u308a\u65b9\u3002\n\u753b\u50cf\u306b\u3057\u305f\u3002\n\n![proj.png](https://qiita-image-store.s3.amazonaws.com/0/41479/95c830a0-897c-4e57-463b-61277180ccd0.png)\n\n* main.cpp\n* dialog.h\n* dialog.cpp\n\n\u306f\u30c7\u30d5\u30a9\u30eb\u30c8\u306e\u30d5\u30a1\u30a4\u30eb\u3002\n\n## mygl.*\n\n```cpp:mygl.hpp\n/**\n * Attribute and Uniform Reference: http://doc.qt.io/qt-5/qopenglshaderprogram.html\n */\n\n#ifndef MYGL_H\n#define MYGL_H\n\n#pragma comment(lib, \"OpenGL32.lib\")\n#pragma comment(lib, \"glu32.lib\")\n\n#include <QGL>\n#include <QGLWidget>\n\n#include <QGLBuffer>\n#include <QGLShaderProgram>\n#include <QMatrix4x4>\n\n#include <QDebug>\n#include <QWidget>\n#include <QTimer>\n#include <QMap>\n\nstruct Attribute {\n    int location;\n    int size;\n};\n\nstruct Uniform {\n    int location;\n};\n\nclass MyGL : public QGLWidget\n{\n    Q_OBJECT\n\npublic:\n    MyGL(QWidget* parent = nullptr);\n\n    virtual void initializeGL();\n    virtual void paintGL();\n    virtual void resizeGL(int w, int h);\n\nprivate:\n    bool prepareShaderProgram(\n            QString const& vertexShaderPath,\n            QString const& fragmentShaderPath);\n\nprivate:\n    QTimer timer_;\n    QGLShaderProgram program_;\n    QGLBuffer vertexBuffer_;\n\n    QMatrix4x4 mvpMat_,\n               pMat_,\n               vMat_,\n               mMat_;\n\n    QMap<QString, Attribute> attribs_;\n    QMap<QString, Uniform> uniforms_;\n};\n\n#endif // MYGL_H\n\n```\n\n```cpp:mygl.cpp\n#include \"mygl.h\"\n\nMyGL::MyGL(QWidget* parent)\n    : QGLWidget(parent)\n    , timer_()\n    , program_()\n    , vertexBuffer_(QGLBuffer::VertexBuffer)\n    , mvpMat_()\n    , pMat_()\n    , vMat_()\n    , mMat_()\n    , attribs_()\n    , uniforms_()\n{\n    connect(&timer_, SIGNAL(timeout()), this, SLOT(updateGL()));\n    timer_.start(16.666666);\n}\n\nvoid MyGL::initializeGL()\n{\n    // Init OpenGL\n    glClearColor( 0.5f, 0.5f, 0.5f, 1.0f);\n\n    // Triangle vertices for VBO\n    float points[] {\n         0.0f, 1.0f, 0.0f, 1.0f,\n        -1.0f, 0.0f, 0.0f, 1.0f,\n         1.0f, 0.0f, 0.0f, 1.0f,\n    };\n\n    // Ready VBO\n    vertexBuffer_.create();\n    vertexBuffer_.setUsagePattern(QGLBuffer::StaticDraw);\n    if (!vertexBuffer_.bind()) {\n        qWarning() << \"VBO: Failed to bind\";\n        return;\n    }\n\n    // Set vertices to VBO\n    vertexBuffer_.allocate(points, 3 * 4 * sizeof(float));\n\n    // Shader Program from source files\n    if (!prepareShaderProgram(\":/my.vs\", \":/my.fs\")) {\n        qWarning() << \"Failed to prepareShaderProgram\";\n        return;\n    }\n    if (!program_.bind()) {\n        qWarning() << \"Program: Failed to bind\";\n        return;\n    }\n\n    // Enable Attribute in Shader Program\n    program_.setAttributeBuffer(\"vertex_in_vs\", GL_FLOAT, 0, 4);\n    program_.enableAttributeArray(\"vertex_in_vs\");\n\n    // Get Location from Shader Program\n    attribs_[\"frame\"].location = program_.attributeLocation(\"frame\");\n    attribs_[\"frame\"].size = 1;\n    uniforms_[\"mvpMat\"].location = program_.uniformLocation(\"mvpMat\");\n}\n\nvoid MyGL::paintGL()\n{\n    static float frame = 0.0f;\n\n    // Viewport\n    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);\n    glViewport( 0, 0, size().width(), size().height());\n\n    // Projection\n    auto w = static_cast<double>(size().width());\n    auto h = static_cast<double>(size().height());\n\n    pMat_.setToIdentity();\n    pMat_.perspective(60.f, w/h, 0.001f, 120.0f);\n\n    // Viewing\n    vMat_.setToIdentity();\n    vMat_.lookAt({0,0,5}, {0,0,0}, {0,1,0});\n\n    // Update MVP Matrix\n    mvpMat_ = pMat_ * vMat_;\n\n    // Modeling\n    static float angle = 0.f;\n    mMat_.setToIdentity();\n    mMat_.rotate(angle, 0.f, 0.f, 1.f);\n    angle += 1.f;\n    if (angle >= 360.f)\n        angle = 0.f;\n\n    // Update MVP Matrix\n    mvpMat_ *= mMat_;\n\n    // Render\n    program_.setAttributeValue(attribs_[\"frame\"].location, frame);\n    program_.setUniformValue(uniforms_[\"mvpMat\"].location, mvpMat_);\n    glDrawArrays(GL_TRIANGLES, 0, 3);\n\n    frame += 1.f;\n}\n\nvoid MyGL::resizeGL(int w, int h)\n{\n    glViewport( 0, 0, w, h);\n}\n\nbool MyGL::prepareShaderProgram(const QString &vertexShaderPath, const QString &fragmentShaderPath)\n{\n    bool res;\n\n    // Add shader from source files\n    res = program_.addShaderFromSourceFile(QGLShader::Vertex, vertexShaderPath);\n    if (!res) {\n        qWarning() << program_.log();\n    }\n    res = program_.addShaderFromSourceFile(QGLShader::Fragment, fragmentShaderPath);\n    if (!res) {\n        qWarning() << program_.log();\n    }\n\n    // Link\n    res = program_.link();\n    if (!res) {\n        qWarning() << \"Failed to link: \" << program_.log();\n    }\n\n    return res;\n}\n\n```\n\nQt \u304c\u30af\u30e9\u30b9\u3092\u7528\u610f\u3057\u3066\u304f\u308c\u3066\u3044\u308b\u304a\u304b\u3052\u3067\u30b9\u30c3\u30ad\u30ea\u3068\u66f8\u3051\u308b\u3002\n\u30aa\u30da\u30ec\u30fc\u30bf\u30fc\u306e\u30aa\u30fc\u30d0\u30fc\u30ed\u30fc\u30c9\u3067\u884c\u5217\u306e\u6f14\u7b97\u3082\u898b\u305f\u76ee\u304c\u308f\u304b\u308a\u3084\u3059\u3044\u3002\u30ad\u30e5\u30fc\u30c8\u3002\n\n## Shader\n\nVertex Shader\n\n```glsl:my.vs\nattribute vec4 vertex_in_vs;\nattribute float frame;\nuniform mat4 mvpMat;\nvarying float varFrame;\n\nvoid main(void) {\n    varFrame = frame;\n    gl_Position = mvpMat * vertex_in_vs;\n}\n\n```\n\nFragment Shader\n\n```glsl:my.fs\n#version 330\nlayout(location = 0, index = 0) out vec4 fragColor;\nvarying float varFrame;\n\nvoid main(void) {\n    fragColor = vec4(abs(cos(varFrame/100.0)), abs(cos(varFrame/200.0)), abs(cos(varFrame/300.0)), 1.0);\n}\n\n```\n\n\u30b7\u30a7\u30fc\u30c0\u30fc\u306f\u30ea\u30bd\u30fc\u30b9\u306b\u767b\u9332\u3059\u308b\u3002\n\n\n## Reference\n\n[Youtube - Qt Creator + OpenGL](https://www.youtube.com/watch?v=1nzHSkY4K18)\n[wgld](http://wgld.org/)\n[[\u9023\u8f09]\u3084\u3063\u3066\u307f\u308c\u3070\u8d85\u7c21\u5358\uff01 WebGL \u3068 GLSL \u3067\u59cb\u3081\u308b\u3001\u306f\u3058\u3081\u3066\u306e\u30b7\u30a7\u30fc\u30c0\u30b3\u30fc\u30c7\u30a3\u30f3\u30b0\uff08\uff11\uff09](http://qiita.com/doxas/items/b8221e92a2bfdc6fc211)\n[How to use OpenGL Core Profile with Qt](https://wiki.qt.io/How_to_use_OpenGL_Core_Profile_with_Qt)\n", "tags": ["Qt", "QtCreator", "OpenGL", "GLSL"]}