{"context": "\n\nParameterized Derived Type \u3092\u5229\u7528\u3057\u305f BMP I/O\n\u524d\u56de \u306e\u767a\u5c55\u3068\u3057\u3066\u300124bit BMP \u30d5\u30a1\u30a4\u30eb\u306e I/O \u3092\u884c\u3046\u30eb\u30fc\u30c1\u30f3\u3092 Parameterized Derived Type \u3092\u5229\u7528\u3059\u308b\u5f62\u306b\u66f8\u304d\u76f4\u3057\u307e\u3057\u305f\u3002\n\u3084\u3063\u3066\u307f\u308b\u3068\u3001\u8272\u3005\u4e9b\u7d30\u306a\u3053\u3068\u3067\u8e93\u304d\u307e\u3057\u305f\u304c\u3001PGI \u306e\u30b5\u30a4\u30c8\u306b\u3042\u308b\u8a18\u4e8b Object-Oriented Programming in Fortran 2003 Part 3: Parameterized Derived Types \u304c\u53c2\u8003\u3068\u306a\u308a\u307e\u3057\u305f\u3002\nParameterized Derived Type \u3067 len \u5c5e\u6027\u3067\u914d\u5217\u3092\u78ba\u4fdd\u3059\u308b\u3088\u3046\u306a\u5834\u5408\u3001\u81ea\u5206\u3067\u4ee3\u5165\u7528\u306e\u95a2\u6570\u3068\u30a4\u30f3\u30bf\u30fc\u30d5\u30a7\u30fc\u30b9\u3001\u30b3\u30f3\u30b9\u30c8\u30e9\u30af\u30bf\u7528\u306e\u30b5\u30d6\u30eb\u30fc\u30c1\u30f3\u3068\u30a4\u30f3\u30bf\u30fc\u30d5\u30a7\u30fc\u30b9\u3092\u7528\u610f\u3057\u3066\u304a\u304b\u306a\u3051\u308c\u3070\u3044\u3051\u306a\u3044\u3088\u3046\u3067\u3059\u3002\u3053\u308c\u306f\u3001allocatable \u5c5e\u6027\u306e\u914d\u5217\u3092\u6301\u3064\u6d3e\u751f\u578b\u306f\u3001\u6a19\u6e96\u306e\u4ee3\u5165\u6587\u3067\u306f\u81ea\u52d5 allocate \u304c\u51fa\u6765\u306a\u3044\u3053\u3068\u3068\u540c\u3058\u3088\u3046\u306a\u3082\u306e\u3060\u3068\u601d\u308f\u308c\u307e\u3059\u3002\n\u30a4\u30f3\u30bf\u30fc\u30d5\u30a7\u30fc\u30b9\u3092\u7528\u610f\u3057\u3066\u304a\u304b\u306a\u3044\u3068\u3001\u57fa\u672c\u7684\u306b\u4ee3\u5165\u306e\u4ee3\u308f\u308a\u306b allocate(a, source = b) \u306e\u5f62\u3092\u7528\u3044\u308b\u3053\u3068\u306b\u306a\u308a\u307e\u3059\u3002\u307e\u305f\u3001\u305d\u306e\u4ed6\u3053\u307e\u3054\u307e\u3068\u3057\u305f\u66f8\u304d\u65b9\u306e\u9055\u3044\u3067\u3001\u5b9f\u884c\u6642\u30a8\u30e9\u30fc\u3067\u306e\u9813\u6b7b\u306a\u3069\u3001\u4ed5\u69d8\u306a\u306e\u304b\u30b3\u30f3\u30d1\u30a4\u30e9\u306e\u30d0\u30b0\u306a\u306e\u304b\u3088\u304f\u5206\u304b\u3089\u306a\u3044\u52d5\u4f5c\u3092\u7d4c\u9a13\u3057\u307e\u3057\u305f\u3002\u307e\u3060\u5b8c\u5168\u306b\u306f\u7406\u89e3\u3057\u3066\u3044\u307e\u305b\u3093\u3002\n\n\u5b9f\u884c\u4f8b\u3000\n\u3053\u3053\u3067\u306f BMP \u30d5\u30a1\u30a4\u30eb\u3092\u8aad\u307f\u8fbc\u3093\u3067\u3001\u753b\u50cf\u3092\u4e0a\u4e0b\u53cd\u8ee2\u3057\u3066\u3044\u307e\u3059\u3002\u30b3\u30f3\u30d1\u30a4\u30e9\u306f\u3001\u73fe\u5728\u30d9\u30fc\u30bf\u30c6\u30b9\u30c8\u4e2d\u306e Intel Visual Fortran v.17.0 \u3092\u7528\u3044\u3066\u3044\u307e\u3059\u3002\n\n BMP size: 326 x 404\n\u7d9a\u884c\u3059\u308b\u306b\u306f\u4f55\u304b\u30ad\u30fc\u3092\u62bc\u3057\u3066\u304f\u3060\u3055\u3044 . . .\n\n\n\n\uff08\u9b54\u6cd5\u3064\u304b\u3044\u30d7\u30ea\u30ad\u30e5\u30a2\uff01\u3088\u308a\uff09\n\n\u30d7\u30ed\u30b0\u30e9\u30e0\nBMP \u30d5\u30a1\u30a4\u30eb\u306e\u8aad\u307f\u8fbc\u307f\u306f\u3001OO \u5f0f\u306b\u51fa\u6765\u306a\u3044\u306e\u3067\u666e\u901a\u306e\u30b5\u30d6\u30eb\u30fc\u30c1\u30f3\u5f62\u5f0f\u3067\u8aad\u307f\u8fbc\u3093\u3067\u3044\u307e\u3059\u3002\uff08\u4ee3\u5165\u306e\u5f62\u3067\u3001BMP \u6d3e\u751f\u578b\u306e\u5272\u308a\u4ed8\u3051\u3068\u30d5\u30a1\u30a4\u30eb\u8aad\u307f\u8fbc\u307f\u3092\u540c\u6642\u306b\u3084\u308b\u3053\u3068\u3082\u3067\u304d\u305f\u306e\u3067\u3059\u304c\u3001\u305d\u306e\u5834\u5408 module \u5074\u3067\u306f\u306a\u304f\u3001\u30e1\u30a4\u30f3\u30d7\u30ed\u30b0\u30e9\u30e0\u5074\u306e\u5185\u90e8\u95a2\u6570\u3068\u3057\u3066\u95a2\u6570\u3092\u7528\u610f\u3057\u3066\u3084\u3089\u306d\u3070\u306a\u3089\u306a\u308a\u307e\u305b\u3093\u3067\u3057\u305f\u3002\u6d3e\u751f\u578b\u306e\u5185\u90e8\u306e\u914d\u5217\u306e\u5272\u308a\u4ed8\u3051\u306e\u554f\u984c\u306a\u306e\u3067\u3059\u304c\u3001\u4eca\u306e\u3068\u3053\u308d\u3001\u3053\u306e\u7406\u7531\u304c\u3088\u304f\u5206\u304b\u308a\u307e\u305b\u3093\u3002\uff09\n    module m_bmp\n      implicit none\n      type :: t_bmp_file_header\n        sequence  \n        integer(2) :: bfType = transfer('BM', 0_2, 1) ! BitMap\n        integer(4) :: bfSize          ! file size in bytes\n        integer(2) :: bfReserved1 = 0 ! always 0\n        integer(2) :: bfReserved2 = 0 ! always 0\n        integer(4) :: bfOffBits\n      end type t_bmp_file_header\n      !\n      type :: t_bmp_info_header\n        sequence\n        integer(4) :: biSize          = Z'28' ! size of bmp_info_header ; 40bytes \n        integer(4) :: biWidth\n        integer(4) :: biHeight\n        integer(2) :: biPlanes        = 1 ! always 1\n        integer(2) :: biBitCount\n        integer(4) :: biCompression   = 0 !0:nocompression,1:8bitRLE,2:4bitRLE,3:bitfield\n        integer(4) :: biSizeImage\n        integer(4) :: biXPelsPerMeter = 3780 ! 96dpi\n        integer(4) :: biYPelsPerMeter = 3780 ! 96dpi \n        integer(4) :: biClrUsed       = 0\n        integer(4) :: biClrImportant  = 0 \n      end type t_bmp_info_header\n      !\n      type :: t_rgb\n        sequence\n        character :: b = 0, g = 0, r = 0\n      end type t_rgb \n\n      type :: t_bmp(nx, ny)\n        integer, len :: nx = 0, ny = 0  \n        type (t_rgb) :: rgb(nx, ny) \n      contains \n        procedure :: wr => wr_bmp\n      end type  \n      !\n      interface assignment(=)\n        module procedure :: assign_bmp\n      end interface assignment(=) \n\n      interface t_bmp\n        module procedure :: construct_bmp\n      end interface t_bmp\n    contains   \n      subroutine wr_bmp(bmp, fn)\n        class (t_bmp(*, *)), intent(in) :: bmp\n        character (len = *), intent(in) :: fn\n        type (t_bmp_file_header) :: bmp_file_header\n        type (t_bmp_info_header) :: bmp_info_header\n        integer :: i, j\n        associate(nx => bmp%nx, ny => bmp%ny)\n          bmp_file_header%bfSize      = 14 + 40 + 0 + (3 * nx + mod(nx, 4)) * ny\n          bmp_file_header%bfOffBits   = 14 + 40\n          bmp_info_header%biWidth     = nx\n          bmp_info_header%biHeight    = ny\n          bmp_info_header%biBitCount  = 24 \n          bmp_info_header%biSizeImage = (3 * nx + mod(nx, 4)) * ny\n          open(9, file = fn//'.bmp', access = 'stream', status = 'unknown')\n          write(9) bmp_file_header\n          write(9) bmp_info_header\n          write(9) (bmp%rgb(:, i), (achar(0), j = 1, mod(nx, 4)), i = 1, ny)\n          close(9)\n        end associate\n      end subroutine wr_bmp\n\n      subroutine rd_bmp(bmp, fn)\n        character (len = *), intent(in) :: fn\n        type (t_bmp(:, :)) , intent(out), allocatable :: bmp\n        type (t_bmp_file_header) :: bmp_file_header\n        type (t_bmp_info_header) :: bmp_info_header\n        integer :: i, j\n        character :: dummy\n        associate(nx => bmp_info_header%biWidth, ny => bmp_info_header%biHeight)\n          open(10, file = fn//'.bmp', access = 'stream', status = 'old')\n          read(10) bmp_file_header\n          read(10) bmp_info_header\n          bmp = t_bmp(nx, ny)\n          read(10) (bmp%rgb(:, i), (dummy, j = 1, mod(nx, 4)), i = 1, ny)\n          close(10)\n        end associate\n      end subroutine rd_bmp\n\n      function construct_bmp(nx, ny) result(res)\n        integer, intent(in) :: nx, ny\n        type (t_bmp(:, :)), allocatable :: res\n        allocate(t_bmp(nx, ny)::res)\n      end function construct_bmp    \n\n      function read_bmp(fn) result(res)\n        character (len = *), intent(in) :: fn\n        type (t_bmp(:, :)), allocatable :: res\n        call rd_bmp(res, fn)\n      end function read_bmp    \n\n      subroutine assign_bmp(dest, src) \n        type (t_bmp(:, :)), intent(out), allocatable :: dest\n        type (t_bmp(*, *)), intent(in ) :: src\n        allocate(dest, source = src)\n      end subroutine assign_bmp    \n    end module m_bmp\n\n    program bmp_RW\n      use m_bmp\n      implicit none\n      type (t_bmp(:, :)), allocatable :: pic0, pic1\n      call rd_bmp(pic0, 'mirai')\n      print *, 'BMP size:', pic0%nx, 'x', pic0%ny\n      pic1 = pic0                          ! allocate(pic1, source = pic0)\n      pic1%rgb = pic0%rgb(:, pic0%ny:1:-1) ! reverse\n      call pic1%wr('reverse')      \n      deallocate(pic0, pic1)\n    end program bmp_RW\n\n#Parameterized Derived Type \u3092\u5229\u7528\u3057\u305f BMP I/O\n[\u524d\u56de](http://qiita.com/cure_honey/items/1a501f4a72b113a9bc07) \u306e\u767a\u5c55\u3068\u3057\u3066\u300124bit BMP \u30d5\u30a1\u30a4\u30eb\u306e I/O \u3092\u884c\u3046\u30eb\u30fc\u30c1\u30f3\u3092 Parameterized Derived Type \u3092\u5229\u7528\u3059\u308b\u5f62\u306b\u66f8\u304d\u76f4\u3057\u307e\u3057\u305f\u3002\n\n\u3084\u3063\u3066\u307f\u308b\u3068\u3001\u8272\u3005\u4e9b\u7d30\u306a\u3053\u3068\u3067\u8e93\u304d\u307e\u3057\u305f\u304c\u3001PGI \u306e\u30b5\u30a4\u30c8\u306b\u3042\u308b\u8a18\u4e8b [Object-Oriented Programming in Fortran 2003 Part 3: Parameterized Derived Types](https://www.pgroup.com/lit/articles/insider/v5n2a4.htm) \u304c\u53c2\u8003\u3068\u306a\u308a\u307e\u3057\u305f\u3002\n\nParameterized Derived Type \u3067 len \u5c5e\u6027\u3067\u914d\u5217\u3092\u78ba\u4fdd\u3059\u308b\u3088\u3046\u306a\u5834\u5408\u3001\u81ea\u5206\u3067\u4ee3\u5165\u7528\u306e\u95a2\u6570\u3068\u30a4\u30f3\u30bf\u30fc\u30d5\u30a7\u30fc\u30b9\u3001\u30b3\u30f3\u30b9\u30c8\u30e9\u30af\u30bf\u7528\u306e\u30b5\u30d6\u30eb\u30fc\u30c1\u30f3\u3068\u30a4\u30f3\u30bf\u30fc\u30d5\u30a7\u30fc\u30b9\u3092\u7528\u610f\u3057\u3066\u304a\u304b\u306a\u3051\u308c\u3070\u3044\u3051\u306a\u3044\u3088\u3046\u3067\u3059\u3002\u3053\u308c\u306f\u3001allocatable \u5c5e\u6027\u306e\u914d\u5217\u3092\u6301\u3064\u6d3e\u751f\u578b\u306f\u3001\u6a19\u6e96\u306e\u4ee3\u5165\u6587\u3067\u306f\u81ea\u52d5 allocate \u304c\u51fa\u6765\u306a\u3044\u3053\u3068\u3068\u540c\u3058\u3088\u3046\u306a\u3082\u306e\u3060\u3068\u601d\u308f\u308c\u307e\u3059\u3002\n\n\u30a4\u30f3\u30bf\u30fc\u30d5\u30a7\u30fc\u30b9\u3092\u7528\u610f\u3057\u3066\u304a\u304b\u306a\u3044\u3068\u3001\u57fa\u672c\u7684\u306b\u4ee3\u5165\u306e\u4ee3\u308f\u308a\u306b allocate(a, source = b) \u306e\u5f62\u3092\u7528\u3044\u308b\u3053\u3068\u306b\u306a\u308a\u307e\u3059\u3002\u307e\u305f\u3001\u305d\u306e\u4ed6\u3053\u307e\u3054\u307e\u3068\u3057\u305f\u66f8\u304d\u65b9\u306e\u9055\u3044\u3067\u3001\u5b9f\u884c\u6642\u30a8\u30e9\u30fc\u3067\u306e\u9813\u6b7b\u306a\u3069\u3001\u4ed5\u69d8\u306a\u306e\u304b\u30b3\u30f3\u30d1\u30a4\u30e9\u306e\u30d0\u30b0\u306a\u306e\u304b\u3088\u304f\u5206\u304b\u3089\u306a\u3044\u52d5\u4f5c\u3092\u7d4c\u9a13\u3057\u307e\u3057\u305f\u3002\u307e\u3060\u5b8c\u5168\u306b\u306f\u7406\u89e3\u3057\u3066\u3044\u307e\u305b\u3093\u3002\n\n##\u5b9f\u884c\u4f8b\u3000\n\u3053\u3053\u3067\u306f BMP \u30d5\u30a1\u30a4\u30eb\u3092\u8aad\u307f\u8fbc\u3093\u3067\u3001\u753b\u50cf\u3092\u4e0a\u4e0b\u53cd\u8ee2\u3057\u3066\u3044\u307e\u3059\u3002\u30b3\u30f3\u30d1\u30a4\u30e9\u306f\u3001\u73fe\u5728\u30d9\u30fc\u30bf\u30c6\u30b9\u30c8\u4e2d\u306e Intel Visual Fortran v.17.0 \u3092\u7528\u3044\u3066\u3044\u307e\u3059\u3002\n```\n BMP size: 326 x 404\n\u7d9a\u884c\u3059\u308b\u306b\u306f\u4f55\u304b\u30ad\u30fc\u3092\u62bc\u3057\u3066\u304f\u3060\u3055\u3044 . . .\n```\n![mirai.png](https://qiita-image-store.s3.amazonaws.com/0/44522/97b37f63-6d79-3f98-cba3-1d3993cfbf9c.png)\n\n![reverse.png](https://qiita-image-store.s3.amazonaws.com/0/44522/f294900b-b2c2-458c-a038-3ac2a0f55c38.png)\n\uff08\u9b54\u6cd5\u3064\u304b\u3044\u30d7\u30ea\u30ad\u30e5\u30a2\uff01\u3088\u308a\uff09\n##\u30d7\u30ed\u30b0\u30e9\u30e0\nBMP \u30d5\u30a1\u30a4\u30eb\u306e\u8aad\u307f\u8fbc\u307f\u306f\u3001OO \u5f0f\u306b\u51fa\u6765\u306a\u3044\u306e\u3067\u666e\u901a\u306e\u30b5\u30d6\u30eb\u30fc\u30c1\u30f3\u5f62\u5f0f\u3067\u8aad\u307f\u8fbc\u3093\u3067\u3044\u307e\u3059\u3002\uff08\u4ee3\u5165\u306e\u5f62\u3067\u3001BMP \u6d3e\u751f\u578b\u306e\u5272\u308a\u4ed8\u3051\u3068\u30d5\u30a1\u30a4\u30eb\u8aad\u307f\u8fbc\u307f\u3092\u540c\u6642\u306b\u3084\u308b\u3053\u3068\u3082\u3067\u304d\u305f\u306e\u3067\u3059\u304c\u3001\u305d\u306e\u5834\u5408 module \u5074\u3067\u306f\u306a\u304f\u3001\u30e1\u30a4\u30f3\u30d7\u30ed\u30b0\u30e9\u30e0\u5074\u306e\u5185\u90e8\u95a2\u6570\u3068\u3057\u3066\u95a2\u6570\u3092\u7528\u610f\u3057\u3066\u3084\u3089\u306d\u3070\u306a\u3089\u306a\u308a\u307e\u305b\u3093\u3067\u3057\u305f\u3002\u6d3e\u751f\u578b\u306e\u5185\u90e8\u306e\u914d\u5217\u306e\u5272\u308a\u4ed8\u3051\u306e\u554f\u984c\u306a\u306e\u3067\u3059\u304c\u3001\u4eca\u306e\u3068\u3053\u308d\u3001\u3053\u306e\u7406\u7531\u304c\u3088\u304f\u5206\u304b\u308a\u307e\u305b\u3093\u3002\uff09\n\n```fortran\n    module m_bmp\n      implicit none\n      type :: t_bmp_file_header\n        sequence  \n        integer(2) :: bfType = transfer('BM', 0_2, 1) ! BitMap\n        integer(4) :: bfSize          ! file size in bytes\n        integer(2) :: bfReserved1 = 0 ! always 0\n        integer(2) :: bfReserved2 = 0 ! always 0\n        integer(4) :: bfOffBits\n      end type t_bmp_file_header\n      !\n      type :: t_bmp_info_header\n        sequence\n        integer(4) :: biSize          = Z'28' ! size of bmp_info_header ; 40bytes \n        integer(4) :: biWidth\n        integer(4) :: biHeight\n        integer(2) :: biPlanes        = 1 ! always 1\n        integer(2) :: biBitCount\n        integer(4) :: biCompression   = 0 !0:nocompression,1:8bitRLE,2:4bitRLE,3:bitfield\n        integer(4) :: biSizeImage\n        integer(4) :: biXPelsPerMeter = 3780 ! 96dpi\n        integer(4) :: biYPelsPerMeter = 3780 ! 96dpi \n        integer(4) :: biClrUsed       = 0\n        integer(4) :: biClrImportant  = 0 \n      end type t_bmp_info_header\n      !\n      type :: t_rgb\n        sequence\n        character :: b = 0, g = 0, r = 0\n      end type t_rgb \n      \n      type :: t_bmp(nx, ny)\n        integer, len :: nx = 0, ny = 0  \n        type (t_rgb) :: rgb(nx, ny) \n      contains \n        procedure :: wr => wr_bmp\n      end type  \n      !\n      interface assignment(=)\n        module procedure :: assign_bmp\n      end interface assignment(=) \n      \n      interface t_bmp\n        module procedure :: construct_bmp\n      end interface t_bmp\n    contains   \n      subroutine wr_bmp(bmp, fn)\n        class (t_bmp(*, *)), intent(in) :: bmp\n        character (len = *), intent(in) :: fn\n        type (t_bmp_file_header) :: bmp_file_header\n        type (t_bmp_info_header) :: bmp_info_header\n        integer :: i, j\n        associate(nx => bmp%nx, ny => bmp%ny)\n          bmp_file_header%bfSize      = 14 + 40 + 0 + (3 * nx + mod(nx, 4)) * ny\n          bmp_file_header%bfOffBits   = 14 + 40\n          bmp_info_header%biWidth     = nx\n          bmp_info_header%biHeight    = ny\n          bmp_info_header%biBitCount  = 24 \n          bmp_info_header%biSizeImage = (3 * nx + mod(nx, 4)) * ny\n          open(9, file = fn//'.bmp', access = 'stream', status = 'unknown')\n          write(9) bmp_file_header\n          write(9) bmp_info_header\n          write(9) (bmp%rgb(:, i), (achar(0), j = 1, mod(nx, 4)), i = 1, ny)\n          close(9)\n        end associate\n      end subroutine wr_bmp\n      \n      subroutine rd_bmp(bmp, fn)\n        character (len = *), intent(in) :: fn\n        type (t_bmp(:, :)) , intent(out), allocatable :: bmp\n        type (t_bmp_file_header) :: bmp_file_header\n        type (t_bmp_info_header) :: bmp_info_header\n        integer :: i, j\n        character :: dummy\n        associate(nx => bmp_info_header%biWidth, ny => bmp_info_header%biHeight)\n          open(10, file = fn//'.bmp', access = 'stream', status = 'old')\n          read(10) bmp_file_header\n          read(10) bmp_info_header\n          bmp = t_bmp(nx, ny)\n          read(10) (bmp%rgb(:, i), (dummy, j = 1, mod(nx, 4)), i = 1, ny)\n          close(10)\n        end associate\n      end subroutine rd_bmp\n      \n      function construct_bmp(nx, ny) result(res)\n        integer, intent(in) :: nx, ny\n        type (t_bmp(:, :)), allocatable :: res\n        allocate(t_bmp(nx, ny)::res)\n      end function construct_bmp    \n\n      function read_bmp(fn) result(res)\n        character (len = *), intent(in) :: fn\n        type (t_bmp(:, :)), allocatable :: res\n        call rd_bmp(res, fn)\n      end function read_bmp    \n\n      subroutine assign_bmp(dest, src) \n        type (t_bmp(:, :)), intent(out), allocatable :: dest\n        type (t_bmp(*, *)), intent(in ) :: src\n        allocate(dest, source = src)\n      end subroutine assign_bmp    \n    end module m_bmp\n    \n    program bmp_RW\n      use m_bmp\n      implicit none\n      type (t_bmp(:, :)), allocatable :: pic0, pic1\n      call rd_bmp(pic0, 'mirai')\n      print *, 'BMP size:', pic0%nx, 'x', pic0%ny\n      pic1 = pic0                          ! allocate(pic1, source = pic0)\n      pic1%rgb = pic0%rgb(:, pic0%ny:1:-1) ! reverse\n      call pic1%wr('reverse')      \n      deallocate(pic0, pic1)\n    end program bmp_RW\n```\n", "tags": ["Fortran", "Fortran2003"]}