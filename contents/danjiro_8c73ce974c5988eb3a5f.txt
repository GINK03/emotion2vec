{"context": "\u30a2\u30cb\u30e1\u4f5c\u6210\u30d5\u30ea\u30fc\u30bd\u30d5\u30c8\u300c9VAe\u304d\u3085\u3046\u3079\u3048\u300d\u306b\u3001\u30ef\u30b3\u30e0\u306e\u30da\u30f3\u30bf\u30d6\u30ec\u30c3\u30c8\u306e\u7b46\u5727\u306b\u5fdc\u3058\u3066\u3001\u592a\u3055\u304c\u5909\u5316\u3059\u308b\u7dda\u3092\u642d\u8f09\u3057\u307e\u3057\u305f\u3002\u7b46\u5727\u306b\u5fdc\u3058\u3066\u592a\u3055\u304c\u5909\u5316\u3059\u308b\u7dda\u3092\u3001\u7c21\u5358\u306a\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0\u3067\u5b9f\u73fe\u3057\u3066\u3044\u308b\u306e\u3067\u7d39\u4ecb\u3057\u307e\u3059\u3002\n\n\u30d7\u30ed\u30b8\u30a7\u30af\u30c8\u306f\u3001https://github.com/dnjiro/wacom9va \u304b\u3089\u53d6\u5f97\u3067\u304d\u307e\u3059\u3002\n\nVer.0.5.0\n\n\u592a\u3055\u304c\u5909\u308f\u308b\u7dda\u3092\u3072\u304f\u30d7\u30ed\u30b0\u30e9\u30e0\n\nMac / Linux\u3067\u3001Wacom\u30da\u30f3\u30bf\u30d6\u30ec\u30c3\u30c8\u306e\u7b46\u5727\u3092\u691c\u77e5\u3057\u3066\u7dda\u3092\u3072\u304f\u9069\u5f53\u306a\u30b5\u30f3\u30d7\u30eb\u30d7\u30ed\u30b0\u30e9\u30e0\u304c\u898b\u3064\u304b\u3089\u305a\u3001\u3044\u308d\u3044\u308d\u8a66\u884c\u932f\u8aa4\u3092\u7e70\u308a\u8fd4\u3057\u305f\u306e\u3067\u3001\u7d50\u679c\u3092\u30b7\u30a7\u30a2\u3057\u307e\u3059\u3002\n\u3053\u306e\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0\u306f\u4ee5\u4e0b\u306e\u30d5\u30ea\u30fc\u30bd\u30d5\u30c89VAe\u304d\u3085\u3046\u3079\u3048\u306b\u642d\u8f09\u3057\u3066\u3044\u307e\u3059\u3002\n\n\n\n\n\u30c0\u30a6\u30f3\u30ed\u30fc\u30c9\u306f\u30ea\u30f3\u30af\u5148\u306e  \u3092\u30af\u30ea\u30c3\u30af\u3002\n\u30d9\u30af\u30bf\u30fc\u304b\u3089\u30c0\u30a6\u30f3\u30ed\u30fc\u30c9\n\n\n\n\n9va-win (Windows\u7248)\n9va-win (\u30d9\u30af\u30bf\u30fc)\n\n\n9va-mac (Macintosh\u7248)\n9va-mac (\u30d9\u30af\u30bf\u30fc)\n\n\n9va-pi (\u30e9\u30ba\u30d9\u30ea\u30fc\u30d1\u30a4\u7248)\n\n\n\n9va-pi (Ubuntu/ Linux X86 32bit\u7248)\n\n\n\n\u304f\u308f\u3057\u3044\u30a4\u30f3\u30b9\u30c8\u30fc\u30eb\u65b9\u6cd5\u306f\u3053\u3061\u3089\n\n\n\n\u30ad\u30c3\u30ba\u30d7\u30e9\u30b6\u7248\uff08Windows \u5b50\u4f9b\u7528\uff09\u306f\u3053\u3061\u3089\n\n\n\n\n\n\u30b5\u30f3\u30d7\u30eb\u30d7\u30ed\u30b0\u30e9\u30e0\u306e\u4ed5\u69d8\n\n\u30ef\u30b3\u30e0\u30da\u30f3\u30bf\u30d6\u30ec\u30c3\u30c8\u3092\u4f7f\u3063\u3066\u3001\u30a6\u30a3\u30f3\u30c9\u30a6\u306e\u4e2d\u306b\u6bdb\u7b46\u306e\u3088\u3046\u306a\u7dda\u3092\u3072\u304f\u3053\u3068\u304c\u3067\u304d\u307e\u3059\u3002\n\u30de\u30a6\u30b9\u30db\u30a4\u30fc\u30eb\u3084\u3001\uff12\u672c\u6307\u30b9\u30af\u30ed\u30fc\u30eb\uff08Macintosh\uff09\u3092\u4f7f\u3063\u3066\u3001\u753b\u9762\u3092\u4e0a\u4e0b\u306b\u30b9\u30af\u30ed\u30fc\u30eb\u3055\u305b\u308c\u3070\u3001\u7121\u9650\u306b\u3064\u3065\u3044\u305f\u30ed\u30fc\u30eb\u306b\u66f8\u304f\u3053\u3068\u304c\u3067\u304d\u307e\u3059\u3002\n\n\nLinux\u7248 \u30d7\u30ed\u30b0\u30e9\u30e0\n\n\u30d3\u30eb\u30c9\u306b\u306f Gtk+3 \u958b\u767a\u7528\u30d8\u30c3\u30c0, \u5b9f\u884c\u306b\u306f X server Wacom input \u30c9\u30e9\u30a4\u30d0\u30fc\u304c\u5fc5\u8981\u3067\u3059\u3002\u53d6\u5f97\u4f8b\n$ sudo apt-get install libgtk-3-dev  $ sudo apt-get install xserver-xorg-input-wacom\n\n\n//  main.c\n//  wacom9va\n//\n//  Created by user on 17/02/26.\n//  Copyright __EVA*Project__ 2017. All rights reserved.\n//  you need libgtk-3-dev, xserver-xorg-input-wacom\n\n#include <gtk/gtk.h>\n#include <gdk/gdk.h>\n#include <math.h>\n\n#define Max(x,y)        ((x)>=(y) ? (x) : (y))\n#define Abs(x)          ((x)>=0   ? (x) : -(x))\n\n\nint     m_index = 0;        // Number of input strokes\nint     isDown = 0;         // 1= mouse button down 0= up\nint     whDelta = 0;        // Scroll Offset (Changed by mouse wheel)\n\n// Stroke data\n#define AnLINEMAX  1000     //Maximum strokes number \n#define AnLPNTMAX  250      //Maximum points number in one stroke\n\nint     m_points[AnLINEMAX];                // Number of points\nint     m_pointX[AnLINEMAX][AnLPNTMAX];     // x\nint     m_pointY[AnLINEMAX][AnLPNTMAX];     // y\nint     m_pressure[AnLINEMAX][AnLPNTMAX];   // pressure\n\n\nGtkWidget *window;\ncairo_surface_t *offscreen=NULL;\nint offWidth = 0;\nint offHeight = 0;\nint offDelta = 0;\n\n//--------------------------------------------------------------------\nvoid     asSetPoint(cairo_t *qp, int pnt, int x, int y)\n{\n    if(!pnt) cairo_move_to(qp, x, y - whDelta );\n    else     cairo_line_to(qp, x, y - whDelta );\n}\n\n//--------------------------------------------------------------------\nvoid     MakeBrushLine(cairo_t *qp, int in, int pnt)\n{\n    int x1,y1,w1,u1,x2,y2,w2,u2,v1,v2, dir, kk;\n    double aPI = 3.1415926535897932;\n    double qq, pi8 = aPI/12;\n\n    kk=0;\n    x2 = m_pointX[in][pnt];\n    y2 = m_pointY[in][pnt];\n    w2 = m_pressure[in][pnt];   \n    w2 = Max(1,w2);\n    v2 = (w2*1732/2000);u2=Max(1,w2/2);\n    dir = 0;    \n    for(;pnt>0;){\n        x1 = m_pointX[in][pnt-1];\n        y1 = m_pointY[in][pnt-1];\n        w1 = m_pressure[in][pnt-1];\n        w1 = Max(1,w1);\n        v1 = (w1*1732/2000);u1=Max(1,w1/2);\n        qq = atan2((double)y2-y1,(double)x2-x1);\n        for(;qq<0;) qq+=2*aPI;\n        dir = (int)((qq+pi8) / pi8/2);\n        switch(dir){ //no break in following lines\n            case 0: asSetPoint(qp, kk, x1   , y1+w1); if(++kk==7) break;\n            case 1: asSetPoint(qp, kk, x1-u1, y1+v1); if(++kk==7) break;\n            case 2: asSetPoint(qp, kk, x1-v1, y1+u1); if(++kk==7) break;\n            case 3: asSetPoint(qp, kk, x1-w1, y1   ); if(++kk==7) break;\n            case 4: asSetPoint(qp, kk, x1-v1, y1-u1); if(++kk==7) break;\n            case 5: asSetPoint(qp, kk, x1-u1, y1-v1); if(++kk==7) break;\n            case 6: asSetPoint(qp, kk, x1   , y1-w1); if(++kk==7) break;\n            case 7: asSetPoint(qp, kk, x1+u1, y1-v1); if(++kk==7) break;\n            case 8: asSetPoint(qp, kk, x1+v1, y1-u1); if(++kk==7) break;\n            case 9: asSetPoint(qp, kk, x1+w1, y1   ); if(++kk==7) break;\n            case 10:asSetPoint(qp, kk, x1+v1, y1+u1); if(++kk==7) break;\n            default:asSetPoint(qp, kk, x1+u1, y1+v1); if(++kk==7) break;\n                asSetPoint(qp, kk, x1   , y1+w1); if(++kk==7) break;\n                asSetPoint(qp, kk, x1-u1, y1+v1); if(++kk==7) break;\n                asSetPoint(qp, kk, x1-v1, y1+u1); if(++kk==7) break;\n                asSetPoint(qp, kk, x1-w1, y1   ); if(++kk==7) break;\n                asSetPoint(qp, kk, x1-v1, y1-u1); if(++kk==7) break;\n                asSetPoint(qp, kk, x1-u1, y1-v1); if(++kk==7) break;\n                asSetPoint(qp, kk, x1   , y1-w1); if(++kk==7) break;\n        }\n        break;\n    }\n    switch(dir){  //no break in following lines\n            case 0: asSetPoint(qp, kk, x2,    y2-w2); if(++kk==14) break;\n            case 1: asSetPoint(qp, kk, x2+u2, y2-v2); if(++kk==14) break;\n            case 2: asSetPoint(qp, kk, x2+v2, y2-u2); if(++kk==14) break;\n            case 3: asSetPoint(qp, kk, x2+w2, y2)   ; if(++kk==14) break;\n            case 4: asSetPoint(qp, kk, x2+v2, y2+u2); if(++kk==14) break;\n            case 5: asSetPoint(qp, kk, x2+u2, y2+v2); if(++kk==14) break;\n            case 6: asSetPoint(qp, kk, x2,    y2+w2); if(++kk==14) break;\n            case 7: asSetPoint(qp, kk, x2-u2, y2+v2); if(++kk==14) break;\n            case 8: asSetPoint(qp, kk, x2-v2, y2+u2); if(++kk==14) break;\n            case 9: asSetPoint(qp, kk, x2-w2, y2)   ; if(++kk==14) break;\n            case 10:asSetPoint(qp, kk, x2-v2, y2-u2); if(++kk==14) break;\n            default:asSetPoint(qp, kk, x2-u2, y2-v2); if(++kk==14) break;\n                asSetPoint(qp, kk, x2,    y2-w2); if(++kk==14) break;\n                asSetPoint(qp, kk, x2+u2, y2-v2); if(++kk==14) break;\n                asSetPoint(qp, kk, x2+v2, y2-u2); if(++kk==14) break;\n                asSetPoint(qp, kk, x2+w2, y2)   ; if(++kk==14) break;\n                asSetPoint(qp, kk, x2+v2, y2+u2); if(++kk==14) break;\n                asSetPoint(qp, kk, x2+u2, y2+v2); if(++kk==14) break;\n                asSetPoint(qp, kk, x2,    y2+w2); if(++kk==14) break;\n    }\n}\n\n//--------------------------------------------------------------------\nvoid AddPolygonPoint(int in, int x, int y, int prs)\n{    \n    if( in < AnLINEMAX ){\n        int pnt = m_points[in];\n        if( pnt < AnLPNTMAX ){\n            m_pointX[in][pnt] = x;\n            m_pointY[in][pnt] = y + whDelta;\n            m_pressure[in][pnt] = prs;\n            m_points[in]++;\n        }\n    }\n}\n\n\ngboolean cb_expose_event(GtkWidget *widget, cairo_t *cr, gpointer data)\n{\n    int in, pnt;\n    int ww = gdk_window_get_width(gtk_widget_get_window(widget));\n    int hh = gdk_window_get_height(gtk_widget_get_window(widget));\n    if(offWidth!=ww || offHeight!=hh || offDelta != whDelta){//Resize offscreen\n        if(offscreen != NULL){\n            cairo_surface_destroy(offscreen);\n        }\n        offscreen = cairo_surface_create_similar(cairo_get_target(cr), \n                         CAIRO_CONTENT_COLOR_ALPHA, ww, hh);\n        offWidth  = ww;\n        offHeight = hh;\n        offDelta  = whDelta;\n        {   \n            cairo_t *qp = cairo_create(offscreen);\n            cairo_set_line_width(qp, 0);\n            cairo_set_source_rgb (qp, 0., 1., 0.);\n            cairo_new_path (qp);        \n            for(in=0; in < m_index; in++){\n                for(pnt=0; pnt< m_points[in]; pnt++){ \n                    MakeBrushLine(qp, in, pnt);\n                }\n            }\n            cairo_fill (qp);\n            cairo_destroy(qp);    \n        }\n    }\n    cairo_set_source_surface(cr, offscreen, 0, 0);\n    cairo_paint (cr);\n    return FALSE;\n}\n\ngint cb_motion_notify_event( GtkWidget *widget, GdkEventMotion *event, gpointer user_data )\n{\n    if(offscreen){\n        if(isDown){\n            gdouble pressure =0;\n            if(!gdk_event_get_axis ((GdkEvent *)event, GDK_AXIS_PRESSURE, &pressure)){\n                pressure =0;\n            }\n            AddPolygonPoint(m_index-1, event->x, event->y, pressure * 16);\n        }\n    }\n    return TRUE;\n}\n\n\ngint cb_button_press_event( GtkWidget *widget, GdkEventMotion *event, gpointer user_data )\n{\n    isDown = 1;\n    m_points[m_index] = m_pointX[m_index][0] = m_pointY[m_index][0] = 0;\n    m_index++;\n    return TRUE;\n}\n\ngint cb_button_release_event( GtkWidget *widget, GdkEventMotion *event, gpointer user_data )\n{\n    isDown = 0;\n    { int in,pnt; //Draw line on offscreen \n            cairo_t *qp = cairo_create(offscreen);\n            cairo_set_line_width(qp, 0.);\n            cairo_set_source_rgb (qp, 0., 1., 0.);\n            cairo_new_path (qp);\n\n            in = m_index-1;\n            for(pnt=0; pnt< m_points[in]; pnt++){ \n                    MakeBrushLine(qp, in, pnt);\n            }\n\n            cairo_fill (qp);\n            cairo_destroy(qp);    \n            gdk_window_invalidate_rect(gtk_widget_get_window(widget),NULL,FALSE);\n    }\n    return TRUE;\n}\n\ngint cb_scroll_event( GtkWidget *widget, GdkEventScroll *event, gpointer user_data )\n{\n    switch ( event->direction ) { \n    case GDK_SCROLL_DOWN:   whDelta += 10; break;   \n    case GDK_SCROLL_UP:     whDelta -= 10; break;   \n    }\n    gdk_window_invalidate_rect(gtk_widget_get_window(widget),NULL,FALSE);\n    return TRUE;\n}\n\nint main(int argc, char *argv[])\n{\n    gtk_init(&argc, &argv);\n    window = gtk_window_new(GTK_WINDOW_TOPLEVEL);\n\n    g_signal_connect(window, \"destroy\", G_CALLBACK(gtk_main_quit), NULL);\n    g_signal_connect(window, \"motion_notify_event\", G_CALLBACK( cb_motion_notify_event ), NULL );\n    g_signal_connect(window, \"button_press_event\", G_CALLBACK( cb_button_press_event ), NULL );\n    g_signal_connect(window, \"button_release_event\", G_CALLBACK( cb_button_release_event ), NULL );\n    g_signal_connect(window, \"draw\", G_CALLBACK(cb_expose_event), NULL);\n    g_signal_connect(window, \"scroll_event\",G_CALLBACK( cb_scroll_event ), NULL );\n    gtk_widget_set_events( window, GDK_EXPOSURE_MASK \n      | GDK_POINTER_MOTION_MASK | GDK_BUTTON_PRESS_MASK | GDK_BUTTON_RELEASE_MASK\n      | GDK_SCROLL_MASK \n      );\n\n\n    gtk_widget_set_app_paintable(window, TRUE);\n    gtk_widget_show(window);\n    gtk_main();\n\n    if(offscreen != NULL){\n        cairo_surface_destroy(offscreen);\n    }\n    return 0;\n}\n\n\n\u8aac\u660e\n\n\u7dda\u306e\u30c7\u30fc\u30bf\u306f\u3001\u4ee5\u4e0b\u306e\u914d\u5217\u306b\u683c\u7d0d\u3055\u308c\u3066\u3044\u307e\u3059\u3002AnLINEMAX\u672c\u306e\u7dda\u304c\u5165\u529b\u3067\u304d\u307e\u3059\u3002\u5404\u30b9\u30c8\u30ed\u30fc\u30af\u306e\u70b9\u6570\u3092\u683c\u7d0d\u3057\u305f\u914d\u5217\u304c m_points[AnLINEMAX]\u3067\u3059\u3002\uff11\u672c\u306e\u30b9\u30c8\u30ed\u30fc\u30af\u306f\u6700\u5927AnLPNTMAX\u70b9\u307e\u3067\u3068\u3057\u3066\u3044\u307e\u3059\u3002\n\nint     m_points[AnLINEMAX];                // Number of points\nint     m_pointX[AnLINEMAX][AnLPNTMAX];     // x\nint     m_pointY[AnLINEMAX][AnLPNTMAX];     // y\nint     m_pressure[AnLINEMAX][AnLPNTMAX];   // pressure\n\n\n\n\u592a\u3055\u304c\u5909\u308f\u308b\u7dda\u3092\u63cf\u753b\u3057\u3066\u3044\u308b\u306e\u306f\u3001DrawPage() \u3001MakeBrushLine() \u3001asSetPoint()\u3067\u3059\u3002\n\u5404\u5ea7\u6a19\u70b9\u306e\u5468\u56f2\u306b\u7dda\u306e\u592a\u3055\u306b\u5bfe\u5fdc\u3057\u305f\uff11\uff12\u89d2\u5f62\u3092\u63cf\u753b\u3057\u3001\u305d\u308c\u305e\u308c\u3092\uff12\u672c\u306e\u7dda\u3067\u3064\u306a\u3044\u3067\u4e2d\u3092\u5857\u308a\u3064\u3076\u3057\u307e\u3059\u3002\u7dda\u306e\u65b9\u5411\u306b\u5fdc\u3058\u3066\uff12\u672c\u306e\u7dda\u3092\u3069\u3053\u306b\u3072\u304f\u304b\u3092\u6c42\u3081\u3066\u3044\u308b\u306e\u304c\u3001MakeBrushLine() \u3067\u3059\u3002asSetPoint()\u3067\u30d1\u30b9\u3092\u751f\u6210\u3057\u3001DrawPage()\u3000\u306e\u4e2d\u306e\u3000CGContextDrawPath()\u3000\u3067\u63cf\u753b\u3057\u3066\u3044\u307e\u3059\u3002\n\u7b46\u5727\u306e\u691c\u51fa\u306f\u3001\u95a2\u6570cb_motion_notify_event() \u306e\u4e2d\u3067\u3001gdk_event_get_axis ((GdkEvent *)event, GDK_AXIS_PRESSURE, &pressure) \u3092\u5b9f\u884c\u3057\u3066\u53d6\u5f97\u3057\u3066\u3044\u307e\u3059\u3002\n\n\n\nMacintosh\u7248\n\n\u7c21\u7565\u5316\u306e\u305f\u3081\u3001\u30a6\u30a3\u30f3\u30c9\u30a6\u306e\u4f4d\u7f6e\u3084\u30b5\u30a4\u30ba\u306e\u5909\u66f4\u306e\u51e6\u7406\u306f\u7701\u3044\u3066\u3044\u307e\u3059\u3002\n\u6bce\u56de\u5168\u30c7\u30fc\u30bf\u3092\u66f8\u304d\u306a\u304a\u3057\u3066\u3044\u308b\u305f\u3081\u3001\u7dda\u306e\u6570\u304c\u5897\u3048\u308b\u3068\u5fdc\u7b54\u304c\u60aa\u304f\u306a\u308a\u307e\u3059\u3002\n\u9ad8\u901f\u5316\u3059\u308b\u306b\u306f\u3001\u4e0a\u306eLinux\u7248\u306e\u3088\u3046\u306b\u30aa\u30d5\u30b9\u30af\u30ea\u30fc\u30f3\u306b\u3044\u3063\u305f\u3093\u63cf\u753b\u3057\u3066\u304b\u3089\u3001\u5fc5\u8981\u306a\u9818\u57df\u3060\u3051\u8ee2\u9001\u3059\u308c\u3070\u3088\u3044\u3067\u3057\u3087\u3046\u3002\n\n\n//\n//  main.c\n//  wacom9va\n//\n//  Created by user on 17/02/01.\n//  Copyright __EVA*Project__ 2017. All rights reserved.\n//\n\n#include <Carbon/Carbon.h>\n\n#define kCSkDocViewClassID  CFSTR( \"com.9vae.wacomtest.view\" )\n\n\nstatic OSStatus        HandleNewWindow();\nstatic OSStatus        WindowEventHandler( EventHandlerCallRef inCaller, EventRef inEvent, void* inRefcon );\nstatic IBNibRef        sNibRef;\n\nenum { \n    kDocumentViewSignature  = 'CskV',\n    kDocumentBoundsParam    = 'Boun'\n};\n\n\n#define Max(x,y)        ((x)>=(y) ? (x) : (y))\n#define Abs(x)          ((x)>=0   ? (x) : -(x))\n\nstruct CGrgba {\n    CGFloat   r;\n    CGFloat   g;\n    CGFloat   b;\n    CGFloat   a;\n};\ntypedef struct CGrgba CGrgba;\n\nstruct CanvasData {\n    HIViewRef       theView;\n};\ntypedef struct CanvasData   CanvasData;\n\nHIViewRef           theScrollView;\n\n\nRect    m_bounds;           // Bounding rectangle of window\nint     m_index = 0;        // Number of input strokes\nint     m_press;            // Pressure\nint     m_scrollY = 0;      // Scroll Offset (Changed by mouse wheel)\nint     isDown = 0;         // 1= mouse button down 0= up\n\n// Stroke data\n#define AnLINEMAX  1000     //Maximum strokes number \n#define AnLPNTMAX  250      //Maximum points number in one stroke\n\nint     m_points[AnLINEMAX];                // Number of points\nint     m_pointX[AnLINEMAX][AnLPNTMAX];     // x\nint     m_pointY[AnLINEMAX][AnLPNTMAX];     // y\nint     m_pressure[AnLINEMAX][AnLPNTMAX];   // pressure\n\nCGMutablePathRef    m_path;\n\n\n//--------------------------------------------------------------------\nvoid     asSetPoint(int pnt, int x, int y)\n{\n    if(!pnt) CGPathMoveToPoint(m_path , NULL, x, y +m_scrollY);\n    else     CGPathAddLineToPoint(m_path , NULL, x, y +m_scrollY);\n}\n\n//--------------------------------------------------------------------\nvoid     MakeBrushLine(int in, int pnt)\n{\n    int x1,y1,w1,u1,x2,y2,w2,u2,v1,v2, dir, kk;\n    double aPI = 3.1415926535897932;\n    double qq, pi8 = aPI/12;\n\n    kk=0;\n    x2 = m_pointX[in][pnt];\n    y2 = m_pointY[in][pnt];\n    w2 = m_pressure[in][pnt];   \n    w2 = Max(1,w2);\n    v2 = (w2*1732/2000);u2=Max(1,w2/2);\n    dir = 0;    \n    for(;pnt>0;){\n        x1 = m_pointX[in][pnt-1];\n        y1 = m_pointY[in][pnt-1]; if(Abs(y1-y2)>m_bounds.bottom/2) break;\n        w1 = m_pressure[in][pnt-1];\n        w1 = Max(1,w1);\n        v1 = (w1*1732/2000);u1=Max(1,w1/2);\n        qq = atan2((double)y2-y1,(double)x2-x1);\n        for(;qq<0;) qq+=2*aPI;\n        dir = (int)((qq+pi8) / pi8/2);\n        switch(dir){ //no break in following lines\n            case 0: asSetPoint(kk, x1   , y1+w1); if(++kk==7) break;\n            case 1: asSetPoint(kk, x1-u1, y1+v1); if(++kk==7) break;\n            case 2: asSetPoint(kk, x1-v1, y1+u1); if(++kk==7) break;\n            case 3: asSetPoint(kk, x1-w1, y1   ); if(++kk==7) break;\n            case 4: asSetPoint(kk, x1-v1, y1-u1); if(++kk==7) break;\n            case 5: asSetPoint(kk, x1-u1, y1-v1); if(++kk==7) break;\n            case 6: asSetPoint(kk, x1   , y1-w1); if(++kk==7) break;\n            case 7: asSetPoint(kk, x1+u1, y1-v1); if(++kk==7) break;\n            case 8: asSetPoint(kk, x1+v1, y1-u1); if(++kk==7) break;\n            case 9: asSetPoint(kk, x1+w1, y1   ); if(++kk==7) break;\n            case 10:asSetPoint(kk, x1+v1, y1+u1); if(++kk==7) break;\n            default:asSetPoint(kk, x1+u1, y1+v1); if(++kk==7) break;\n                asSetPoint(kk, x1   , y1+w1); if(++kk==7) break;\n                asSetPoint(kk, x1-u1, y1+v1); if(++kk==7) break;\n                asSetPoint(kk, x1-v1, y1+u1); if(++kk==7) break;\n                asSetPoint(kk, x1-w1, y1   ); if(++kk==7) break;\n                asSetPoint(kk, x1-v1, y1-u1); if(++kk==7) break;\n                asSetPoint(kk, x1-u1, y1-v1); if(++kk==7) break;\n                asSetPoint(kk, x1   , y1-w1); if(++kk==7) break;\n        }\n        break;\n    }\n    switch(dir){  //no break in following lines\n            case 0: asSetPoint(kk, x2,    y2-w2); if(++kk==14) break;\n            case 1: asSetPoint(kk, x2+u2, y2-v2); if(++kk==14) break;\n            case 2: asSetPoint(kk, x2+v2, y2-u2); if(++kk==14) break;\n            case 3: asSetPoint(kk, x2+w2, y2)   ; if(++kk==14) break;\n            case 4: asSetPoint(kk, x2+v2, y2+u2); if(++kk==14) break;\n            case 5: asSetPoint(kk, x2+u2, y2+v2); if(++kk==14) break;\n            case 6: asSetPoint(kk, x2,    y2+w2); if(++kk==14) break;\n            case 7: asSetPoint(kk, x2-u2, y2+v2); if(++kk==14) break;\n            case 8: asSetPoint(kk, x2-v2, y2+u2); if(++kk==14) break;\n            case 9: asSetPoint(kk, x2-w2, y2)   ; if(++kk==14) break;\n            case 10:asSetPoint(kk, x2-v2, y2-u2); if(++kk==14) break;\n            default:asSetPoint(kk, x2-u2, y2-v2); if(++kk==14) break;\n                asSetPoint(kk, x2,    y2-w2); if(++kk==14) break;\n                asSetPoint(kk, x2+u2, y2-v2); if(++kk==14) break;\n                asSetPoint(kk, x2+v2, y2-u2); if(++kk==14) break;\n                asSetPoint(kk, x2+w2, y2)   ; if(++kk==14) break;\n                asSetPoint(kk, x2+v2, y2+u2); if(++kk==14) break;\n                asSetPoint(kk, x2+u2, y2+v2); if(++kk==14) break;\n                asSetPoint(kk, x2,    y2+w2); if(++kk==14) break;\n    }\n}\n\n//--------------------------------------------------------------------\nCGColorSpaceRef GetGenericRGBColorSpace(void)\n{\n    static CGColorSpaceRef genericRGBColorSpace = NULL;\n    if (genericRGBColorSpace == NULL){\n        genericRGBColorSpace = CGColorSpaceCreateWithName(kCGColorSpaceGenericRGB);\n    }\n    return genericRGBColorSpace;\n}\n\n\n//--------------------------------------------------------------------\nvoid DrawPage(CGContextRef ctx)\n{    \n    int in,pnt;\n    const CGrgba blackColor     = { 0.0, 0.0, 0.0, 1.0 };\n    CGColorSpaceRef genericColorSpace  = GetGenericRGBColorSpace();\n\n    CGContextSaveGState(ctx);   // because SetContextStateForDrawObject is doing what it says it will\n    CGContextSetFillColorSpace(ctx, genericColorSpace); \n    CGContextSetStrokeColor( ctx, (CGFloat*)&blackColor);       \n    CGContextSetFillColor( ctx, (CGFloat*)&blackColor);     \n    CGContextBeginPath(ctx);            // reset current path to empty\n    for(in=0; in < m_index; in++){\n        m_path = CGPathCreateMutable();\n        for(pnt=0; pnt< m_points[in]; pnt++){ \n            MakeBrushLine(in, pnt);\n        }\n        CGContextAddPath(ctx, m_path);\n    }\n    CGContextDrawPath(ctx, kCGPathFillStroke);\n    CGContextRestoreGState(ctx);    // undo the changes for the specific obj drawing\n}\n\n//--------------------------------------------------------------------\nvoid AddPolygonPoint(int in, int x, int y, int prs)\n{    \n    if( in < AnLINEMAX ){\n        int pnt = m_points[in];\n        if( pnt < AnLPNTMAX ){\n            m_pointX[in][pnt] = x;\n            m_pointY[in][pnt] = y;\n            m_pressure[in][pnt] = prs;\n            m_points[in]++;\n        }\n    }\n}\n\n//--------------------------------------------------------------------------------------------\nint main(int argc, char* argv[])\n{\n    OSStatus                    err;\n    err = CreateNibReference( CFSTR(\"main\"), &sNibRef );\n    require_noerr( err, CantGetNibRef );\n\n    // Create a new window. \n    HandleNewWindow();\n\n    // Run the event loop\n    RunApplicationEventLoop();\n\nCantGetNibRef:\n    return err;\n}\n\n\n//--------------------------------------------------------------------------------------------\nDEFINE_ONE_SHOT_HANDLER_GETTER( WindowEventHandler )\n\n//--------------------------------------------------------------------------------------------\nstatic OSStatus\nHandleNewWindow()\n{\n    OSStatus     err;\n    WindowRef    window;\n    static HIObjectClassRef sMyViewClassRef = NULL;\n    EventRef    event;\n    HIViewRef   theView;\n    HIViewRef contentView;\n    OptionBits options = kHIScrollViewOptionsVertScroll | kHIScrollViewOptionsHorizScroll | kHIScrollViewOptionsAllowGrow;\n    const HIViewID viewID = { kDocumentViewSignature, 0 };\n\n\n    static const EventTypeSpec    kWindowEvents[] =\n    {\n        { kEventClassCommand, kEventCommandProcess },\n\n        { kEventClassHIObject, kEventHIObjectConstruct },\n        { kEventClassHIObject, kEventHIObjectInitialize },\n        { kEventClassHIObject, kEventHIObjectDestruct },\n        { kEventClassControl, kEventControlDraw },\n\n        { kEventClassMouse,     kEventMouseWheelMoved },\n        { kEventClassMouse,     kEventMouseDown },\n        { kEventClassMouse,     kEventMouseDragged },\n        { kEventClassMouse,     kEventMouseMoved },\n        { kEventClassMouse,     kEventMouseUp }                         \n    };\n\n    // Create a window. \"MainWindow\" is the name of the window object. This name is set in \n    // InterfaceBuilder when the nib is created.\n    err = CreateWindowFromNib( sNibRef, CFSTR(\"MainWindow\"), &window );\n    require_noerr( err, CantCreateWindow );\n\n    // Install a command handler on the window. We don't use this handler yet, but nearly all\n    // Carbon apps will need to handle commands, so this saves everyone a little typing.\n    InstallWindowEventHandler( window, GetWindowEventHandlerUPP(),\n                               GetEventTypeCount( kWindowEvents ), kWindowEvents,\n                               window, NULL );\n    // Position new windows in a staggered arrangement on the main screen\n    RepositionWindow( window, NULL, kWindowCascadeOnMainScreen );\n    GetWindowBounds(window,kWindowContentRgn,&m_bounds);            \n\n\n\n    //Create HIView\n    // Make scroll view\n    err = HIScrollViewCreate(options, &theScrollView);\n    require(err == noErr, CantCreateScrollView);\n\n    // Bind it to the window's contentView\n    HIRect bounds;\n    HIViewFindByID(HIViewGetRoot(window), kHIViewWindowContentID, &contentView);\n    HIViewAddSubview(contentView, theScrollView);\n    HIViewGetBounds(contentView, &bounds);\n    HIViewSetFrame(theScrollView, &bounds);\n    HIViewSetVisible(theScrollView, true);\n\n    err = HIObjectRegisterSubclass( kCSkDocViewClassID,\n                                   kHIViewClassID,          // base class ID\n                                   0,                   // option bits\n                                   WindowEventHandler,      // construct proc\n                                   GetEventTypeCount( kWindowEvents ),\n                                   kWindowEvents,\n                                   NULL,                // construct data,\n                                   &sMyViewClassRef );\n\n    // Make an initialization event\n    err = CreateEvent( NULL, kEventClassHIObject, kEventHIObjectInitialize, GetCurrentEventTime(), 0, &event ); \n    require_noerr( err, CantCreateEvent );\n\n    err = SetEventParameter(event, kDocumentBoundsParam, typeQDRectangle, sizeof(Rect), &m_bounds);\n    require_noerr( err, CantSetParameter );\n\n    err = HIObjectCreate(kCSkDocViewClassID, event, (HIObjectRef*)&theView);\n    require_noerr(err, CantCreate);\n    err = HIViewAddSubview(theScrollView, theView);\n\n    SetControlID(theView, &viewID);\n    HIViewSetVisible(theView, true);\n\n    // The window was created hidden, so show it\n    ShowWindow( window );\n\nCantCreate:\nCantSetParameter:\nCantCreateEvent:\n    ReleaseEvent( event );  \n\nCantCreateScrollView:\nCantCreateWindow:\n    return err;\n}\n\n//--------------------------------------------------------------------------------------------\nstatic OSStatus\nWindowEventHandler( EventHandlerCallRef inCaller, EventRef inEvent, void* inUserData )\n{\n    OSStatus    err = eventNotHandledErr;\n    unsigned long   ekind;\n    SInt32      whDelta = 0;\n    EventRecord eve;\n    WindowRef   wptr;\n    Point       where;\n    UInt32      modifiers;\n    CGContextRef ctx;\n    CanvasData  *data = (CanvasData *)inUserData;\n\n    ekind = GetEventKind(inEvent);\n\n    switch ( GetEventClass( inEvent ) ){    \n\n    case kEventClassHIObject:   // the boilerplate HIObject business\n        switch ( ekind ){\n        case kEventHIObjectConstruct:\n            data = (CanvasData*)malloc(sizeof(CanvasData)); \n            err = GetEventParameter( inEvent, kEventParamHIObjectInstance, typeHIObjectRef, NULL, sizeof(HIObjectRef*), NULL, &data->theView );\n            require_noerr( err, ParameterMissing );\n            SetEventParameter( inEvent, kEventParamHIObjectInstance, typeVoidPtr, sizeof(CanvasData), &data ); \n            break;\n\n        case kEventHIObjectDestruct:\n            free(inUserData);\n            break;\n        }\n        break;  // kEventClassHIObject\n\n\n    case kEventClassControl:    // draw, hit test and track\n        switch ( ekind ){\n        case kEventControlDraw:\n            GetEventParameter(inEvent, kEventParamCGContextRef, typeCGContextRef, NULL, sizeof(CGContextRef), NULL, &ctx);\n            //CallNextEventHandler(inCallRef, inEvent);     // Erase old content\n            DrawPage(ctx);\n            err = noErr;\n            break;\n        }           \n        break; //kEventClassControl\n\n\n    case kEventClassMouse:\n        { // Get Wacom Event     \n            UInt32 eventType;\n            struct TabletPointRec tabletPnt; \n            struct TabletProximityRec tabletTyp;\n\n            err = GetEventParameter(inEvent, \n                            kEventParamTabletEventType, typeUInt32, NULL,\n                            sizeof(eventType), NULL, &eventType);\n            if(err==noErr){ \n                switch( eventType ){\n                case kEventTabletPoint:\n                    err = GetEventParameter(inEvent, \n                            kEventParamTabletPointRec, typeTabletPointRec, NULL,\n                            sizeof(tabletPnt), NULL, &tabletPnt);\n                    if(err==noErr){\n                            m_press = tabletPnt.pressure;\n                    }\n                    break;\n                case kEventTabletProximity:\n                    err = GetEventParameter(inEvent, \n                            kEventParamTabletProximityRec, typeTabletProximityRec, NULL,\n                            sizeof(tabletTyp), NULL, &tabletTyp);\n                    if(err==noErr){\n                    }\n                    break;\n                }\n            }\n        }//Wacom Event\n        switch( ekind ){\n        case kEventMouseWheelMoved:\n            err = GetEventParameter(inEvent, kEventParamMouseWheelDelta, typeSInt32, NULL, sizeof(SInt32), NULL, &whDelta);\n            m_scrollY += whDelta*4;\n            /*no break*/\n        case kEventMouseUp:\n        case kEventMouseDown:\n        case kEventMouseDragged:\n        case kEventMouseMoved:\n            if(ekind==kEventMouseDown){\n                isDown = 1;\n                m_points[m_index] = m_pointX[m_index][0] = m_pointY[m_index][0] = 0;\n                m_index++;\n            }\n            if(ekind==kEventMouseUp){\n                isDown = 0;\n                m_press = 0;\n            }\n            ConvertEventRefToEventRecord(inEvent, &eve);\n\n            if(FindWindow(eve.where, &wptr)!=inContent && ekind!=kEventMouseUp){\n                break;\n            }\n            if(wptr != ActiveNonFloatingWindow()&& ekind!=kEventMouseUp){\n                break;\n            }\n            GetEventParameter(inEvent, kEventParamMouseLocation, typeQDPoint, NULL, sizeof(Point), NULL, &where);\n            GetEventParameter(inEvent, kEventParamKeyModifiers, typeUInt32, NULL, sizeof(UInt32), NULL, &modifiers);\n            if(isDown){\n                AddPolygonPoint(m_index-1, where.h, \n                                where.v - m_scrollY -m_bounds.top, 15*m_press/0x10000);\n            }\n            if(whDelta || isDown){\n                whDelta=0;\n                HIViewSetNeedsDisplay(theScrollView, true);             \n            }\n            break;\n        }          \n        break; //kEventClassMouse\n    default:\n        break;\n    }\nParameterMissing:   \n    return err;\n}\n\n\n\n\u8aac\u660e\n\n\u7dda\u306e\u30c7\u30fc\u30bf\u306f\u3001\u4ee5\u4e0b\u306e\u914d\u5217\u306b\u683c\u7d0d\u3055\u308c\u3066\u3044\u307e\u3059\u3002AnLINEMAX\u672c\u306e\u7dda\u304c\u5165\u529b\u3067\u304d\u307e\u3059\u3002\u5404\u30b9\u30c8\u30ed\u30fc\u30af\u306e\u70b9\u6570\u3092\u683c\u7d0d\u3057\u305f\u914d\u5217\u304c m_points[AnLINEMAX]\u3067\u3059\u3002\uff11\u672c\u306e\u30b9\u30c8\u30ed\u30fc\u30af\u306f\u6700\u5927AnLPNTMAX\u70b9\u307e\u3067\u3068\u3057\u3066\u3044\u307e\u3059\u3002\n\nint     m_points[AnLINEMAX];                // Number of points\nint     m_pointX[AnLINEMAX][AnLPNTMAX];     // x\nint     m_pointY[AnLINEMAX][AnLPNTMAX];     // y\nint     m_pressure[AnLINEMAX][AnLPNTMAX];   // pressure\n\n\n\n\u592a\u3055\u304c\u5909\u308f\u308b\u7dda\u3092\u63cf\u753b\u3057\u3066\u3044\u308b\u306e\u306f\u3001DrawPage() \u3001MakeBrushLine() \u3001asSetPoint()\u3067\u3059\u3002\n\u5404\u5ea7\u6a19\u70b9\u306e\u5468\u56f2\u306b\u7dda\u306e\u592a\u3055\u306b\u5bfe\u5fdc\u3057\u305f\uff11\uff12\u89d2\u5f62\u3092\u63cf\u753b\u3057\u3001\u305d\u308c\u305e\u308c\u3092\uff12\u672c\u306e\u7dda\u3067\u3064\u306a\u3044\u3067\u4e2d\u3092\u5857\u308a\u3064\u3076\u3057\u307e\u3059\u3002\u7dda\u306e\u65b9\u5411\u306b\u5fdc\u3058\u3066\uff12\u672c\u306e\u7dda\u3092\u3069\u3053\u306b\u3072\u304f\u304b\u3092\u6c42\u3081\u3066\u3044\u308b\u306e\u304c\u3001MakeBrushLine() \u3067\u3059\u3002asSetPoint()\u3067\u30d1\u30b9\u3092\u751f\u6210\u3057\u3001DrawPage()\u3000\u306e\u4e2d\u306e\u3000CGContextDrawPath()\u3000\u3067\u63cf\u753b\u3057\u3066\u3044\u307e\u3059\u3002\n\u7b46\u5727\u306e\u691c\u51fa\u306f\u3001\u95a2\u6570\u3000WindowEventHandler() \u306e\u4e2d\u3067\u3001\u30de\u30a6\u30b9\u30a4\u30d9\u30f3\u30c8 kEventClassMouse \u3092\u53d7\u3051\u53d6\u3063\u305f\u3068\u304d\u306b\u3001GetEventParameter(inEvent, kEventParamTabletEventType, typeUInt32, NULL, sizeof(eventType), NULL, &eventType);\n\u3092\u5b9f\u884c\u3057\u3066\u53d6\u5f97\u3057\u3066\u3044\u307e\u3059\u3002\n\n\n\n\n\u95a2\u9023\u8a18\u4e8b\n\n\u7121\u6599\u30bd\u30d5\u30c8\u3067\u30a2\u30cb\u30e1\u3092\u4f5c\u3063\u3066\u307f\u3088\u3046\uff089VAe \u304d\u3085\u3046\u3079\u3048\uff09\n\u30b9\u30af\u30e9\u30c3\u30c1\u3001\u30d3\u30b9\u30b1\u30c3\u30c8\u306e\u6b21\u306f 9VAe\uff1d\u7b2c\uff13\u306e\u30d7\u30ed\u30b0\u30e9\u30df\u30f3\u30b0\u5b66\u7fd2\u74b0\u5883\n9VAe\u304d\u3085\u3046\u3079\u3048\uff1a\u9577\u3044\u30a2\u30cb\u30e1\u3092\u4f5c\u308b\u65b9\u6cd5\n\u52d5\u304fLINE\u30b9\u30bf\u30f3\u30d7\u306eAPNG\u4f5c\u6210\uff1a\u7121\u6599\u30bd\u30d5\u30c89VAe\u304d\u3085\u3046\u3079\u3048\n9VAe\u304d\u3085\u3046\u3079\u3048\u300d\u3067\u7d75\u3092\u63cf\u304b\u305a\u306b\u4f5c\u308c\u308bGIF\u30a2\u30cb\u30e1\n9VAe\u304d\u3085\u3046\u3079\u3048\u3067\u4f5c\u6210\u3057\u305fSVG\u30a2\u30cb\u30e1\u30fc\u30b7\u30e7\u30f3\n \u30a2\u30cb\u30e1\u30bd\u30d5\u30c8 9VAe \u3092\u30ab\u30b9\u30bf\u30de\u30a4\u30ba\u3059\u308b\u65b9\u6cd5\n\n9VAe\u3092\u30ad\u30c3\u30ba\u30d7\u30e9\u30b6\u5927\u962a\u5411\u3051\u306b\u6539\u9020\u3059\u308b\n9VAe / 9svg \u30c7\u30fc\u30bf\u30d5\u30a9\u30fc\u30de\u30c3\u30c8\u89e3\u8aac\n\u30d5\u30ea\u30fc\u30bd\u30d5\u30c89VAe\u304d\u3085\u3046\u3079\u3048\u3067\u7c21\u5358\u30c7\u30b8\u30bf\u30eb\u30b5\u30a4\u30cd\u30fc\u30b8\n\n\u30a2\u30cb\u30e1\u4f5c\u6210\u30d5\u30ea\u30fc\u30bd\u30d5\u30c8\u300c9VAe\u304d\u3085\u3046\u3079\u3048\u300d\u306b\u3001\u30ef\u30b3\u30e0\u306e\u30da\u30f3\u30bf\u30d6\u30ec\u30c3\u30c8\u306e\u7b46\u5727\u306b\u5fdc\u3058\u3066\u3001\u592a\u3055\u304c\u5909\u5316\u3059\u308b\u7dda\u3092\u642d\u8f09\u3057\u307e\u3057\u305f\u3002\u7b46\u5727\u306b\u5fdc\u3058\u3066\u592a\u3055\u304c\u5909\u5316\u3059\u308b\u7dda\u3092\u3001\u7c21\u5358\u306a\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0\u3067\u5b9f\u73fe\u3057\u3066\u3044\u308b\u306e\u3067\u7d39\u4ecb\u3057\u307e\u3059\u3002\n\n- \u30d7\u30ed\u30b8\u30a7\u30af\u30c8\u306f\u3001[https://github.com/dnjiro/wacom9va](https://github.com/dnjiro/wacom9va) \u304b\u3089\u53d6\u5f97\u3067\u304d\u307e\u3059\u3002\n\nVer.0.5.0<br>![0500w600.gif](https://qiita-image-store.s3.amazonaws.com/0/67734/a3381c11-6aec-01cf-5762-fa804b676559.gif)\n\n\n# \u592a\u3055\u304c\u5909\u308f\u308b\u7dda\u3092\u3072\u304f\u30d7\u30ed\u30b0\u30e9\u30e0\n\n- Mac / Linux\u3067\u3001Wacom\u30da\u30f3\u30bf\u30d6\u30ec\u30c3\u30c8\u306e\u7b46\u5727\u3092\u691c\u77e5\u3057\u3066\u7dda\u3092\u3072\u304f\u9069\u5f53\u306a\u30b5\u30f3\u30d7\u30eb\u30d7\u30ed\u30b0\u30e9\u30e0\u304c\u898b\u3064\u304b\u3089\u305a\u3001\u3044\u308d\u3044\u308d\u8a66\u884c\u932f\u8aa4\u3092\u7e70\u308a\u8fd4\u3057\u305f\u306e\u3067\u3001\u7d50\u679c\u3092\u30b7\u30a7\u30a2\u3057\u307e\u3059\u3002\n- \u3053\u306e\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0\u306f\u4ee5\u4e0b\u306e\u30d5\u30ea\u30fc\u30bd\u30d5\u30c89VAe\u304d\u3085\u3046\u3079\u3048\u306b\u642d\u8f09\u3057\u3066\u3044\u307e\u3059\u3002\n\n\n|\u30c0\u30a6\u30f3\u30ed\u30fc\u30c9\u306f\u30ea\u30f3\u30af\u5148\u306e ![Untitled.png](https://qiita-image-store.s3.amazonaws.com/0/67734/dbea08ea-33e3-c9f2-aa04-73528cfa0f7f.png) \u3092\u30af\u30ea\u30c3\u30af\u3002|\u30d9\u30af\u30bf\u30fc\u304b\u3089\u30c0\u30a6\u30f3\u30ed\u30fc\u30c9|\n|:--|:--|\n|[**9va-win (Windows\u7248)**](https://drive.google.com/file/d/0B_jLDEPlHKVjWVIzYWxCVUZwNWM/view?usp=sharing)|[9va-win (\u30d9\u30af\u30bf\u30fc)](http://www.vector.co.jp/soft/dl/winnt/art/se515201.html)|\n|[**9va-mac (Macintosh\u7248)**](https://drive.google.com/file/d/0B_jLDEPlHKVjUE0wWkh4THVsOFk/view?usp=sharing)|[9va-mac (\u30d9\u30af\u30bf\u30fc)](http://www.vector.co.jp/soft/dl/mac/art/se515202.html)|\n| [**9va-pi (\u30e9\u30ba\u30d9\u30ea\u30fc\u30d1\u30a4\u7248)**](https://drive.google.com/file/d/0B_jLDEPlHKVjd0RPOFVWbWxwZkU/view?usp=sharing)||\n| [**9va-pi (Ubuntu/ Linux X86 32bit\u7248)**](https://drive.google.com/file/d/0B_jLDEPlHKVjTmU1M05GanZLWjg/view?usp=sharing)||\n|[\u304f\u308f\u3057\u3044\u30a4\u30f3\u30b9\u30c8\u30fc\u30eb\u65b9\u6cd5\u306f\u3053\u3061\u3089](http://qiita.com/danjiro/items/1debda10c37fd8a55927)||\n|[\u30ad\u30c3\u30ba\u30d7\u30e9\u30b6\u7248\uff08Windows \u5b50\u4f9b\u7528\uff09\u306f\u3053\u3061\u3089](http://9vae.blogspot.jp/p/9vae.html)||\n\n\n\n\n\n### \u30b5\u30f3\u30d7\u30eb\u30d7\u30ed\u30b0\u30e9\u30e0\u306e\u4ed5\u69d8\n\n- \u30ef\u30b3\u30e0\u30da\u30f3\u30bf\u30d6\u30ec\u30c3\u30c8\u3092\u4f7f\u3063\u3066\u3001\u30a6\u30a3\u30f3\u30c9\u30a6\u306e\u4e2d\u306b\u6bdb\u7b46\u306e\u3088\u3046\u306a\u7dda\u3092\u3072\u304f\u3053\u3068\u304c\u3067\u304d\u307e\u3059\u3002\n- \u30de\u30a6\u30b9\u30db\u30a4\u30fc\u30eb\u3084\u3001\uff12\u672c\u6307\u30b9\u30af\u30ed\u30fc\u30eb\uff08Macintosh\uff09\u3092\u4f7f\u3063\u3066\u3001\u753b\u9762\u3092\u4e0a\u4e0b\u306b\u30b9\u30af\u30ed\u30fc\u30eb\u3055\u305b\u308c\u3070\u3001\u7121\u9650\u306b\u3064\u3065\u3044\u305f\u30ed\u30fc\u30eb\u306b\u66f8\u304f\u3053\u3068\u304c\u3067\u304d\u307e\u3059\u3002\n\n#  Linux\u7248 \u30d7\u30ed\u30b0\u30e9\u30e0\n\n- \u30d3\u30eb\u30c9\u306b\u306f Gtk+3 \u958b\u767a\u7528\u30d8\u30c3\u30c0, \u5b9f\u884c\u306b\u306f X server Wacom input \u30c9\u30e9\u30a4\u30d0\u30fc\u304c\u5fc5\u8981\u3067\u3059\u3002\u53d6\u5f97\u4f8b<br>\n `$ sudo apt-get install libgtk-3-dev` <br> `$ sudo apt-get install xserver-xorg-input-wacom`\n\n```c\n//  main.c\n//  wacom9va\n//\n//  Created by user on 17/02/26.\n//  Copyright __EVA*Project__ 2017. All rights reserved.\n//  you need libgtk-3-dev, xserver-xorg-input-wacom\n\n#include <gtk/gtk.h>\n#include <gdk/gdk.h>\n#include <math.h>\n\n#define Max(x,y)        ((x)>=(y) ? (x) : (y))\n#define Abs(x)          ((x)>=0   ? (x) : -(x))\n\n\nint\t\tm_index = 0;\t\t// Number of input strokes\nint\t\tisDown = 0;\t\t\t// 1= mouse button down 0= up\nint\t\twhDelta = 0;\t\t// Scroll Offset (Changed by mouse wheel)\n\n// Stroke data\n#define AnLINEMAX  1000  \t//Maximum strokes number \n#define AnLPNTMAX  250  \t//Maximum points number in one stroke\n\nint\t\tm_points[AnLINEMAX];\t\t\t\t// Number of points\nint\t\tm_pointX[AnLINEMAX][AnLPNTMAX];\t\t// x\nint\t\tm_pointY[AnLINEMAX][AnLPNTMAX];\t\t// y\nint\t\tm_pressure[AnLINEMAX][AnLPNTMAX];\t// pressure\n\n\nGtkWidget *window;\ncairo_surface_t *offscreen=NULL;\nint offWidth = 0;\nint offHeight = 0;\nint\toffDelta = 0;\n\n//--------------------------------------------------------------------\nvoid\t asSetPoint(cairo_t *qp, int pnt, int x, int y)\n{\n\tif(!pnt) cairo_move_to(qp, x, y - whDelta );\n\telse     cairo_line_to(qp, x, y - whDelta );\n}\n\n//--------------------------------------------------------------------\nvoid\t MakeBrushLine(cairo_t *qp, int in, int pnt)\n{\n\tint x1,y1,w1,u1,x2,y2,w2,u2,v1,v2, dir, kk;\n\tdouble aPI = 3.1415926535897932;\n\tdouble qq, pi8 = aPI/12;\n\t\n\tkk=0;\n\tx2 = m_pointX[in][pnt];\n\ty2 = m_pointY[in][pnt];\n\tw2 = m_pressure[in][pnt];\t\n\tw2 = Max(1,w2);\n\tv2 = (w2*1732/2000);u2=Max(1,w2/2);\n\tdir = 0;\t\n\tfor(;pnt>0;){\n\t\tx1 = m_pointX[in][pnt-1];\n\t\ty1 = m_pointY[in][pnt-1];\n\t\tw1 = m_pressure[in][pnt-1];\n\t\tw1 = Max(1,w1);\n\t\tv1 = (w1*1732/2000);u1=Max(1,w1/2);\n\t\tqq = atan2((double)y2-y1,(double)x2-x1);\n\t\tfor(;qq<0;) qq+=2*aPI;\n\t\tdir = (int)((qq+pi8) / pi8/2);\n\t\tswitch(dir){ //no break in following lines\n\t\t\tcase 0: asSetPoint(qp, kk, x1   , y1+w1); if(++kk==7) break;\n\t\t\tcase 1: asSetPoint(qp, kk, x1-u1, y1+v1); if(++kk==7) break;\n\t\t\tcase 2: asSetPoint(qp, kk, x1-v1, y1+u1); if(++kk==7) break;\n\t\t\tcase 3: asSetPoint(qp, kk, x1-w1, y1   ); if(++kk==7) break;\n\t\t\tcase 4: asSetPoint(qp, kk, x1-v1, y1-u1); if(++kk==7) break;\n\t\t\tcase 5: asSetPoint(qp, kk, x1-u1, y1-v1); if(++kk==7) break;\n\t\t\tcase 6: asSetPoint(qp, kk, x1   , y1-w1); if(++kk==7) break;\n\t\t\tcase 7: asSetPoint(qp, kk, x1+u1, y1-v1); if(++kk==7) break;\n\t\t\tcase 8: asSetPoint(qp, kk, x1+v1, y1-u1); if(++kk==7) break;\n\t\t\tcase 9: asSetPoint(qp, kk, x1+w1, y1   ); if(++kk==7) break;\n\t\t\tcase 10:asSetPoint(qp, kk, x1+v1, y1+u1); if(++kk==7) break;\n\t\t\tdefault:asSetPoint(qp, kk, x1+u1, y1+v1); if(++kk==7) break;\n\t\t\t\tasSetPoint(qp, kk, x1   , y1+w1); if(++kk==7) break;\n\t\t\t\tasSetPoint(qp, kk, x1-u1, y1+v1); if(++kk==7) break;\n\t\t\t\tasSetPoint(qp, kk, x1-v1, y1+u1); if(++kk==7) break;\n\t\t\t\tasSetPoint(qp, kk, x1-w1, y1   ); if(++kk==7) break;\n\t\t\t\tasSetPoint(qp, kk, x1-v1, y1-u1); if(++kk==7) break;\n\t\t\t\tasSetPoint(qp, kk, x1-u1, y1-v1); if(++kk==7) break;\n\t\t\t\tasSetPoint(qp, kk, x1   , y1-w1); if(++kk==7) break;\n\t\t}\n\t\tbreak;\n\t}\n\tswitch(dir){  //no break in following lines\n\t\t\tcase 0: asSetPoint(qp, kk, x2,    y2-w2); if(++kk==14) break;\n\t\t\tcase 1: asSetPoint(qp, kk, x2+u2, y2-v2); if(++kk==14) break;\n\t\t\tcase 2: asSetPoint(qp, kk, x2+v2, y2-u2); if(++kk==14) break;\n\t\t\tcase 3: asSetPoint(qp, kk, x2+w2, y2)   ; if(++kk==14) break;\n\t\t\tcase 4: asSetPoint(qp, kk, x2+v2, y2+u2); if(++kk==14) break;\n\t\t\tcase 5: asSetPoint(qp, kk, x2+u2, y2+v2); if(++kk==14) break;\n\t\t\tcase 6: asSetPoint(qp, kk, x2,    y2+w2); if(++kk==14) break;\n\t\t\tcase 7: asSetPoint(qp, kk, x2-u2, y2+v2); if(++kk==14) break;\n\t\t\tcase 8: asSetPoint(qp, kk, x2-v2, y2+u2); if(++kk==14) break;\n\t\t\tcase 9: asSetPoint(qp, kk, x2-w2, y2)   ; if(++kk==14) break;\n\t\t\tcase 10:asSetPoint(qp, kk, x2-v2, y2-u2); if(++kk==14) break;\n\t\t\tdefault:asSetPoint(qp, kk, x2-u2, y2-v2); if(++kk==14) break;\n\t\t\t\tasSetPoint(qp, kk, x2,    y2-w2); if(++kk==14) break;\n\t\t\t\tasSetPoint(qp, kk, x2+u2, y2-v2); if(++kk==14) break;\n\t\t\t\tasSetPoint(qp, kk, x2+v2, y2-u2); if(++kk==14) break;\n\t\t\t\tasSetPoint(qp, kk, x2+w2, y2)   ; if(++kk==14) break;\n\t\t\t\tasSetPoint(qp, kk, x2+v2, y2+u2); if(++kk==14) break;\n\t\t\t\tasSetPoint(qp, kk, x2+u2, y2+v2); if(++kk==14) break;\n\t\t\t\tasSetPoint(qp, kk, x2,    y2+w2); if(++kk==14) break;\n\t}\n}\n\n//--------------------------------------------------------------------\nvoid AddPolygonPoint(int in, int x, int y, int prs)\n{    \n\tif( in < AnLINEMAX ){\n\t\tint pnt = m_points[in];\n\t\tif( pnt < AnLPNTMAX ){\n\t\t\tm_pointX[in][pnt] = x;\n\t\t\tm_pointY[in][pnt] = y + whDelta;\n\t\t\tm_pressure[in][pnt] = prs;\n\t\t\tm_points[in]++;\n\t\t}\n\t}\n}\n\n\ngboolean cb_expose_event(GtkWidget *widget, cairo_t *cr, gpointer data)\n{\n\tint in, pnt;\n\tint ww = gdk_window_get_width(gtk_widget_get_window(widget));\n\tint hh = gdk_window_get_height(gtk_widget_get_window(widget));\n    if(offWidth!=ww || offHeight!=hh || offDelta != whDelta){//Resize offscreen\n\t\tif(offscreen != NULL){\n\t\t\tcairo_surface_destroy(offscreen);\n\t\t}\n\t\toffscreen = cairo_surface_create_similar(cairo_get_target(cr), \n                         CAIRO_CONTENT_COLOR_ALPHA, ww, hh);\n\t\toffWidth  = ww;\n\t\toffHeight = hh;\n\t\toffDelta  = whDelta;\n\t\t{   \n\t\t\tcairo_t *qp = cairo_create(offscreen);\n\t\t\tcairo_set_line_width(qp, 0);\n\t\t\tcairo_set_source_rgb (qp, 0., 1., 0.);\n\t\t\tcairo_new_path (qp);\t\t\n\t\t\tfor(in=0; in < m_index; in++){\n\t\t\t\tfor(pnt=0; pnt< m_points[in]; pnt++){ \n\t\t\t\t\tMakeBrushLine(qp, in, pnt);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcairo_fill (qp);\n\t\t\tcairo_destroy(qp);    \n\t\t}\n\t}\n\tcairo_set_source_surface(cr, offscreen, 0, 0);\n\tcairo_paint (cr);\n    return FALSE;\n}\n\ngint cb_motion_notify_event( GtkWidget *widget, GdkEventMotion *event, gpointer user_data )\n{\n\tif(offscreen){\n\t\tif(isDown){\n\t\t\tgdouble pressure =0;\n\t\t\tif(!gdk_event_get_axis ((GdkEvent *)event, GDK_AXIS_PRESSURE, &pressure)){\n\t\t\t\tpressure =0;\n\t\t\t}\n\t\t\tAddPolygonPoint(m_index-1, event->x, event->y, pressure * 16);\n\t\t}\n\t}\n    return TRUE;\n}\n\n\ngint cb_button_press_event( GtkWidget *widget, GdkEventMotion *event, gpointer user_data )\n{\n\tisDown = 1;\n\tm_points[m_index] = m_pointX[m_index][0] = m_pointY[m_index][0] = 0;\n\tm_index++;\n    return TRUE;\n}\n\ngint cb_button_release_event( GtkWidget *widget, GdkEventMotion *event, gpointer user_data )\n{\n\tisDown = 0;\n\t{ int in,pnt; //Draw line on offscreen \n\t\t\tcairo_t *qp = cairo_create(offscreen);\n\t\t\tcairo_set_line_width(qp, 0.);\n\t\t\tcairo_set_source_rgb (qp, 0., 1., 0.);\n\t\t\tcairo_new_path (qp);\n\t\t\t\n\t\t\tin = m_index-1;\n\t\t\tfor(pnt=0; pnt< m_points[in]; pnt++){ \n\t\t\t\t\tMakeBrushLine(qp, in, pnt);\n\t\t\t}\n\t\t\t\n\t\t\tcairo_fill (qp);\n\t\t\tcairo_destroy(qp);    \n\t\t\tgdk_window_invalidate_rect(gtk_widget_get_window(widget),NULL,FALSE);\n\t}\n    return TRUE;\n}\n\ngint cb_scroll_event( GtkWidget *widget, GdkEventScroll *event, gpointer user_data )\n{\n\tswitch ( event->direction ) { \n\tcase GDK_SCROLL_DOWN:\twhDelta += 10; break;\t\n\tcase GDK_SCROLL_UP:\t    whDelta -= 10; break;\t\n\t}\n\tgdk_window_invalidate_rect(gtk_widget_get_window(widget),NULL,FALSE);\n\treturn TRUE;\n}\n\nint main(int argc, char *argv[])\n{\n    gtk_init(&argc, &argv);\n    window = gtk_window_new(GTK_WINDOW_TOPLEVEL);\n    \n    g_signal_connect(window, \"destroy\", G_CALLBACK(gtk_main_quit), NULL);\n    g_signal_connect(window, \"motion_notify_event\", G_CALLBACK( cb_motion_notify_event ), NULL );\n    g_signal_connect(window, \"button_press_event\", G_CALLBACK( cb_button_press_event ), NULL );\n    g_signal_connect(window, \"button_release_event\", G_CALLBACK( cb_button_release_event ), NULL );\n\tg_signal_connect(window, \"draw\", G_CALLBACK(cb_expose_event), NULL);\n\tg_signal_connect(window, \"scroll_event\",G_CALLBACK( cb_scroll_event ), NULL );\n    gtk_widget_set_events( window, GDK_EXPOSURE_MASK \n      | GDK_POINTER_MOTION_MASK | GDK_BUTTON_PRESS_MASK | GDK_BUTTON_RELEASE_MASK\n      | GDK_SCROLL_MASK \n      );\n\n\n    gtk_widget_set_app_paintable(window, TRUE);\n    gtk_widget_show(window);\n    gtk_main();\n\n\tif(offscreen != NULL){\n\t\tcairo_surface_destroy(offscreen);\n\t}\n    return 0;\n}\n```\n\n\n\n\n### \u8aac\u660e\n- \u7dda\u306e\u30c7\u30fc\u30bf\u306f\u3001\u4ee5\u4e0b\u306e\u914d\u5217\u306b\u683c\u7d0d\u3055\u308c\u3066\u3044\u307e\u3059\u3002AnLINEMAX\u672c\u306e\u7dda\u304c\u5165\u529b\u3067\u304d\u307e\u3059\u3002\u5404\u30b9\u30c8\u30ed\u30fc\u30af\u306e\u70b9\u6570\u3092\u683c\u7d0d\u3057\u305f\u914d\u5217\u304c m_points[AnLINEMAX]\u3067\u3059\u3002\uff11\u672c\u306e\u30b9\u30c8\u30ed\u30fc\u30af\u306f\u6700\u5927AnLPNTMAX\u70b9\u307e\u3067\u3068\u3057\u3066\u3044\u307e\u3059\u3002\n\n```c\nint     m_points[AnLINEMAX];                // Number of points\nint     m_pointX[AnLINEMAX][AnLPNTMAX];     // x\nint     m_pointY[AnLINEMAX][AnLPNTMAX];     // y\nint     m_pressure[AnLINEMAX][AnLPNTMAX];   // pressure\n\n```\n\n- \u592a\u3055\u304c\u5909\u308f\u308b\u7dda\u3092\u63cf\u753b\u3057\u3066\u3044\u308b\u306e\u306f\u3001DrawPage() \u3001MakeBrushLine() \u3001asSetPoint()\u3067\u3059\u3002\n- \u5404\u5ea7\u6a19\u70b9\u306e\u5468\u56f2\u306b\u7dda\u306e\u592a\u3055\u306b\u5bfe\u5fdc\u3057\u305f\uff11\uff12\u89d2\u5f62\u3092\u63cf\u753b\u3057\u3001\u305d\u308c\u305e\u308c\u3092\uff12\u672c\u306e\u7dda\u3067\u3064\u306a\u3044\u3067\u4e2d\u3092\u5857\u308a\u3064\u3076\u3057\u307e\u3059\u3002\u7dda\u306e\u65b9\u5411\u306b\u5fdc\u3058\u3066\uff12\u672c\u306e\u7dda\u3092\u3069\u3053\u306b\u3072\u304f\u304b\u3092\u6c42\u3081\u3066\u3044\u308b\u306e\u304c\u3001MakeBrushLine() \u3067\u3059\u3002asSetPoint()\u3067\u30d1\u30b9\u3092\u751f\u6210\u3057\u3001DrawPage()\u3000\u306e\u4e2d\u306e\u3000CGContextDrawPath()\u3000\u3067\u63cf\u753b\u3057\u3066\u3044\u307e\u3059\u3002\n- \u7b46\u5727\u306e\u691c\u51fa\u306f\u3001\u95a2\u6570cb_motion_notify_event() \u306e\u4e2d\u3067\u3001gdk_event_get_axis ((GdkEvent *)event, GDK_AXIS_PRESSURE, &pressure) \u3092\u5b9f\u884c\u3057\u3066\u53d6\u5f97\u3057\u3066\u3044\u307e\u3059\u3002    \n\n\n\n\n\n\n\n\n# Macintosh\u7248\n\n- \u7c21\u7565\u5316\u306e\u305f\u3081\u3001\u30a6\u30a3\u30f3\u30c9\u30a6\u306e\u4f4d\u7f6e\u3084\u30b5\u30a4\u30ba\u306e\u5909\u66f4\u306e\u51e6\u7406\u306f\u7701\u3044\u3066\u3044\u307e\u3059\u3002\n- \u6bce\u56de\u5168\u30c7\u30fc\u30bf\u3092\u66f8\u304d\u306a\u304a\u3057\u3066\u3044\u308b\u305f\u3081\u3001\u7dda\u306e\u6570\u304c\u5897\u3048\u308b\u3068\u5fdc\u7b54\u304c\u60aa\u304f\u306a\u308a\u307e\u3059\u3002\n- \u9ad8\u901f\u5316\u3059\u308b\u306b\u306f\u3001\u4e0a\u306eLinux\u7248\u306e\u3088\u3046\u306b\u30aa\u30d5\u30b9\u30af\u30ea\u30fc\u30f3\u306b\u3044\u3063\u305f\u3093\u63cf\u753b\u3057\u3066\u304b\u3089\u3001\u5fc5\u8981\u306a\u9818\u57df\u3060\u3051\u8ee2\u9001\u3059\u308c\u3070\u3088\u3044\u3067\u3057\u3087\u3046\u3002\n\n```c\n\n//\n//  main.c\n//  wacom9va\n//\n//  Created by user on 17/02/01.\n//  Copyright __EVA*Project__ 2017. All rights reserved.\n//\n\n#include <Carbon/Carbon.h>\n\n#define kCSkDocViewClassID\tCFSTR( \"com.9vae.wacomtest.view\" )\n\n\nstatic OSStatus        HandleNewWindow();\nstatic OSStatus        WindowEventHandler( EventHandlerCallRef inCaller, EventRef inEvent, void* inRefcon );\nstatic IBNibRef        sNibRef;\n\nenum { \n    kDocumentViewSignature\t= 'CskV',\n    kDocumentBoundsParam\t= 'Boun'\n};\n\n\n#define Max(x,y)        ((x)>=(y) ? (x) : (y))\n#define Abs(x)          ((x)>=0   ? (x) : -(x))\n\nstruct CGrgba {\n    CGFloat   r;\n    CGFloat   g;\n    CGFloat   b;\n    CGFloat   a;\n};\ntypedef struct CGrgba CGrgba;\n\nstruct CanvasData {\n    HIViewRef\t\ttheView;\n};\ntypedef struct CanvasData   CanvasData;\n\nHIViewRef\t\t\ttheScrollView;\n\n\nRect \tm_bounds;\t\t\t// Bounding rectangle of window\nint\t\tm_index = 0;\t\t// Number of input strokes\nint\t\tm_press;\t\t\t// Pressure\nint\t\tm_scrollY = 0;\t\t// Scroll Offset (Changed by mouse wheel)\nint\t\tisDown = 0;\t\t\t// 1= mouse button down 0= up\n\n// Stroke data\n#define AnLINEMAX  1000  \t//Maximum strokes number \n#define AnLPNTMAX  250  \t//Maximum points number in one stroke\n\nint\t\tm_points[AnLINEMAX];\t\t\t\t// Number of points\nint\t\tm_pointX[AnLINEMAX][AnLPNTMAX];\t\t// x\nint\t\tm_pointY[AnLINEMAX][AnLPNTMAX];\t\t// y\nint\t\tm_pressure[AnLINEMAX][AnLPNTMAX];\t// pressure\n\nCGMutablePathRef\tm_path;\n\n\n//--------------------------------------------------------------------\nvoid\t asSetPoint(int pnt, int x, int y)\n{\n\tif(!pnt) CGPathMoveToPoint(m_path , NULL, x, y +m_scrollY);\n\telse     CGPathAddLineToPoint(m_path , NULL, x, y +m_scrollY);\n}\n\n//--------------------------------------------------------------------\nvoid\t MakeBrushLine(int in, int pnt)\n{\n\tint x1,y1,w1,u1,x2,y2,w2,u2,v1,v2, dir, kk;\n\tdouble aPI = 3.1415926535897932;\n\tdouble qq, pi8 = aPI/12;\n\t\n\tkk=0;\n\tx2 = m_pointX[in][pnt];\n\ty2 = m_pointY[in][pnt];\n\tw2 = m_pressure[in][pnt];\t\n\tw2 = Max(1,w2);\n\tv2 = (w2*1732/2000);u2=Max(1,w2/2);\n\tdir = 0;\t\n\tfor(;pnt>0;){\n\t\tx1 = m_pointX[in][pnt-1];\n\t\ty1 = m_pointY[in][pnt-1]; if(Abs(y1-y2)>m_bounds.bottom/2) break;\n\t\tw1 = m_pressure[in][pnt-1];\n\t\tw1 = Max(1,w1);\n\t\tv1 = (w1*1732/2000);u1=Max(1,w1/2);\n\t\tqq = atan2((double)y2-y1,(double)x2-x1);\n\t\tfor(;qq<0;) qq+=2*aPI;\n\t\tdir = (int)((qq+pi8) / pi8/2);\n\t\tswitch(dir){ //no break in following lines\n\t\t\tcase 0: asSetPoint(kk, x1   , y1+w1); if(++kk==7) break;\n\t\t\tcase 1: asSetPoint(kk, x1-u1, y1+v1); if(++kk==7) break;\n\t\t\tcase 2: asSetPoint(kk, x1-v1, y1+u1); if(++kk==7) break;\n\t\t\tcase 3: asSetPoint(kk, x1-w1, y1   ); if(++kk==7) break;\n\t\t\tcase 4: asSetPoint(kk, x1-v1, y1-u1); if(++kk==7) break;\n\t\t\tcase 5: asSetPoint(kk, x1-u1, y1-v1); if(++kk==7) break;\n\t\t\tcase 6: asSetPoint(kk, x1   , y1-w1); if(++kk==7) break;\n\t\t\tcase 7: asSetPoint(kk, x1+u1, y1-v1); if(++kk==7) break;\n\t\t\tcase 8: asSetPoint(kk, x1+v1, y1-u1); if(++kk==7) break;\n\t\t\tcase 9: asSetPoint(kk, x1+w1, y1   ); if(++kk==7) break;\n\t\t\tcase 10:asSetPoint(kk, x1+v1, y1+u1); if(++kk==7) break;\n\t\t\tdefault:asSetPoint(kk, x1+u1, y1+v1); if(++kk==7) break;\n\t\t\t\tasSetPoint(kk, x1   , y1+w1); if(++kk==7) break;\n\t\t\t\tasSetPoint(kk, x1-u1, y1+v1); if(++kk==7) break;\n\t\t\t\tasSetPoint(kk, x1-v1, y1+u1); if(++kk==7) break;\n\t\t\t\tasSetPoint(kk, x1-w1, y1   ); if(++kk==7) break;\n\t\t\t\tasSetPoint(kk, x1-v1, y1-u1); if(++kk==7) break;\n\t\t\t\tasSetPoint(kk, x1-u1, y1-v1); if(++kk==7) break;\n\t\t\t\tasSetPoint(kk, x1   , y1-w1); if(++kk==7) break;\n\t\t}\n\t\tbreak;\n\t}\n\tswitch(dir){  //no break in following lines\n\t\t\tcase 0: asSetPoint(kk, x2,    y2-w2); if(++kk==14) break;\n\t\t\tcase 1: asSetPoint(kk, x2+u2, y2-v2); if(++kk==14) break;\n\t\t\tcase 2: asSetPoint(kk, x2+v2, y2-u2); if(++kk==14) break;\n\t\t\tcase 3: asSetPoint(kk, x2+w2, y2)   ; if(++kk==14) break;\n\t\t\tcase 4: asSetPoint(kk, x2+v2, y2+u2); if(++kk==14) break;\n\t\t\tcase 5: asSetPoint(kk, x2+u2, y2+v2); if(++kk==14) break;\n\t\t\tcase 6: asSetPoint(kk, x2,    y2+w2); if(++kk==14) break;\n\t\t\tcase 7: asSetPoint(kk, x2-u2, y2+v2); if(++kk==14) break;\n\t\t\tcase 8: asSetPoint(kk, x2-v2, y2+u2); if(++kk==14) break;\n\t\t\tcase 9: asSetPoint(kk, x2-w2, y2)   ; if(++kk==14) break;\n\t\t\tcase 10:asSetPoint(kk, x2-v2, y2-u2); if(++kk==14) break;\n\t\t\tdefault:asSetPoint(kk, x2-u2, y2-v2); if(++kk==14) break;\n\t\t\t\tasSetPoint(kk, x2,    y2-w2); if(++kk==14) break;\n\t\t\t\tasSetPoint(kk, x2+u2, y2-v2); if(++kk==14) break;\n\t\t\t\tasSetPoint(kk, x2+v2, y2-u2); if(++kk==14) break;\n\t\t\t\tasSetPoint(kk, x2+w2, y2)   ; if(++kk==14) break;\n\t\t\t\tasSetPoint(kk, x2+v2, y2+u2); if(++kk==14) break;\n\t\t\t\tasSetPoint(kk, x2+u2, y2+v2); if(++kk==14) break;\n\t\t\t\tasSetPoint(kk, x2,    y2+w2); if(++kk==14) break;\n\t}\n}\n\n//--------------------------------------------------------------------\nCGColorSpaceRef GetGenericRGBColorSpace(void)\n{\n    static CGColorSpaceRef genericRGBColorSpace = NULL;\n    if (genericRGBColorSpace == NULL){\n\t\tgenericRGBColorSpace = CGColorSpaceCreateWithName(kCGColorSpaceGenericRGB);\n    }\n    return genericRGBColorSpace;\n}\n\n\n//--------------------------------------------------------------------\nvoid DrawPage(CGContextRef ctx)\n{    \n   \tint in,pnt;\n\tconst CGrgba blackColor\t    = { 0.0, 0.0, 0.0, 1.0 };\n    CGColorSpaceRef genericColorSpace  = GetGenericRGBColorSpace();\n\t\n\tCGContextSaveGState(ctx);\t// because SetContextStateForDrawObject is doing what it says it will\n\tCGContextSetFillColorSpace(ctx, genericColorSpace); \n\tCGContextSetStrokeColor( ctx, (CGFloat*)&blackColor);\t\t\n\tCGContextSetFillColor( ctx, (CGFloat*)&blackColor);\t\t\n\tCGContextBeginPath(ctx);\t\t\t// reset current path to empty\n\tfor(in=0; in < m_index; in++){\n\t\tm_path = CGPathCreateMutable();\n\t\tfor(pnt=0; pnt< m_points[in]; pnt++){ \n\t\t\tMakeBrushLine(in, pnt);\n\t\t}\n\t\tCGContextAddPath(ctx, m_path);\n\t}\n\tCGContextDrawPath(ctx, kCGPathFillStroke);\n\tCGContextRestoreGState(ctx);\t// undo the changes for the specific obj drawing\n}\n\n//--------------------------------------------------------------------\nvoid AddPolygonPoint(int in, int x, int y, int prs)\n{    \n\tif( in < AnLINEMAX ){\n\t\tint pnt = m_points[in];\n\t\tif( pnt < AnLPNTMAX ){\n\t\t\tm_pointX[in][pnt] = x;\n\t\t\tm_pointY[in][pnt] = y;\n\t\t\tm_pressure[in][pnt] = prs;\n\t\t\tm_points[in]++;\n\t\t}\n\t}\n}\n\n//--------------------------------------------------------------------------------------------\nint main(int argc, char* argv[])\n{\n    OSStatus                    err;\n    err = CreateNibReference( CFSTR(\"main\"), &sNibRef );\n    require_noerr( err, CantGetNibRef );\n    \n    // Create a new window. \n    HandleNewWindow();\n    \n    // Run the event loop\n    RunApplicationEventLoop();\n\nCantGetNibRef:\n    return err;\n}\n\n\n//--------------------------------------------------------------------------------------------\nDEFINE_ONE_SHOT_HANDLER_GETTER( WindowEventHandler )\n\n//--------------------------------------------------------------------------------------------\nstatic OSStatus\nHandleNewWindow()\n{\n    OSStatus     err;\n    WindowRef    window;\n    static HIObjectClassRef sMyViewClassRef = NULL;\n    EventRef\tevent;\n    HIViewRef\ttheView;\n    HIViewRef contentView;\n    OptionBits options = kHIScrollViewOptionsVertScroll | kHIScrollViewOptionsHorizScroll | kHIScrollViewOptionsAllowGrow;\n    const HIViewID viewID = { kDocumentViewSignature, 0 };\n\t\n\t\n    static const EventTypeSpec    kWindowEvents[] =\n    {\n        { kEventClassCommand, kEventCommandProcess },\n\n\t\t{ kEventClassHIObject, kEventHIObjectConstruct },\n\t\t{ kEventClassHIObject, kEventHIObjectInitialize },\n\t\t{ kEventClassHIObject, kEventHIObjectDestruct },\n        { kEventClassControl, kEventControlDraw },\n\t\t\n\t\t{ kEventClassMouse,\t\tkEventMouseWheelMoved },\n\t\t{ kEventClassMouse,\t\tkEventMouseDown },\n\t\t{ kEventClassMouse,\t\tkEventMouseDragged },\n\t\t{ kEventClassMouse,\t\tkEventMouseMoved },\n\t\t{ kEventClassMouse,\t\tkEventMouseUp }\t\t\t\t\t\t\t\n    };\n    \n    // Create a window. \"MainWindow\" is the name of the window object. This name is set in \n    // InterfaceBuilder when the nib is created.\n    err = CreateWindowFromNib( sNibRef, CFSTR(\"MainWindow\"), &window );\n    require_noerr( err, CantCreateWindow );\n\n    // Install a command handler on the window. We don't use this handler yet, but nearly all\n    // Carbon apps will need to handle commands, so this saves everyone a little typing.\n    InstallWindowEventHandler( window, GetWindowEventHandlerUPP(),\n                               GetEventTypeCount( kWindowEvents ), kWindowEvents,\n                               window, NULL );\n    // Position new windows in a staggered arrangement on the main screen\n    RepositionWindow( window, NULL, kWindowCascadeOnMainScreen );\n\tGetWindowBounds(window,kWindowContentRgn,&m_bounds);\t\t\t\n\t\n\t\n\t\n\t//Create HIView\n    // Make scroll view\n    err = HIScrollViewCreate(options, &theScrollView);\n    require(err == noErr, CantCreateScrollView);\n\t\n    // Bind it to the window's contentView\n    HIRect bounds;\n    HIViewFindByID(HIViewGetRoot(window), kHIViewWindowContentID, &contentView);\n    HIViewAddSubview(contentView, theScrollView);\n    HIViewGetBounds(contentView, &bounds);\n    HIViewSetFrame(theScrollView, &bounds);\n    HIViewSetVisible(theScrollView, true);\n\t\n    err = HIObjectRegisterSubclass( kCSkDocViewClassID,\n\t\t\t\t\t\t\t\t   kHIViewClassID,\t\t\t// base class ID\n\t\t\t\t\t\t\t\t   0,\t\t\t\t\t// option bits\n\t\t\t\t\t\t\t\t   WindowEventHandler,\t\t// construct proc\n\t\t\t\t\t\t\t\t   GetEventTypeCount( kWindowEvents ),\n\t\t\t\t\t\t\t\t   kWindowEvents,\n\t\t\t\t\t\t\t\t   NULL,\t\t\t\t// construct data,\n\t\t\t\t\t\t\t\t   &sMyViewClassRef );\n\n    // Make an initialization event\n    err = CreateEvent( NULL, kEventClassHIObject, kEventHIObjectInitialize, GetCurrentEventTime(), 0, &event ); \n    require_noerr( err, CantCreateEvent );\n\t\n    err = SetEventParameter(event, kDocumentBoundsParam, typeQDRectangle, sizeof(Rect), &m_bounds);\n    require_noerr( err, CantSetParameter );\n\n    err = HIObjectCreate(kCSkDocViewClassID, event, (HIObjectRef*)&theView);\n    require_noerr(err, CantCreate);\n    err = HIViewAddSubview(theScrollView, theView);\n\t\n\tSetControlID(theView, &viewID);\n\tHIViewSetVisible(theView, true);\n\n    // The window was created hidden, so show it\n    ShowWindow( window );\n    \nCantCreate:\nCantSetParameter:\nCantCreateEvent:\n    ReleaseEvent( event );\t\n\t\nCantCreateScrollView:\nCantCreateWindow:\n    return err;\n}\n\n//--------------------------------------------------------------------------------------------\nstatic OSStatus\nWindowEventHandler( EventHandlerCallRef inCaller, EventRef inEvent, void* inUserData )\n{\n    OSStatus    err = eventNotHandledErr;\n    unsigned long\tekind;\n\tSInt32 \t\twhDelta = 0;\n\tEventRecord eve;\n\tWindowRef\twptr;\n\tPoint   \twhere;\n\tUInt32  \tmodifiers;\n\tCGContextRef ctx;\n\tCanvasData\t*data = (CanvasData\t*)inUserData;\n\t\n    ekind = GetEventKind(inEvent);\n\t\n    switch ( GetEventClass( inEvent ) ){\t\n\t\t\t\n\tcase kEventClassHIObject:   // the boilerplate HIObject business\n\t\tswitch ( ekind ){\n\t\tcase kEventHIObjectConstruct:\n\t\t\tdata = (CanvasData*)malloc(sizeof(CanvasData));\t\n\t\t\terr = GetEventParameter( inEvent, kEventParamHIObjectInstance, typeHIObjectRef, NULL, sizeof(HIObjectRef*), NULL, &data->theView );\n\t\t\trequire_noerr( err, ParameterMissing );\n\t\t\tSetEventParameter( inEvent, kEventParamHIObjectInstance, typeVoidPtr, sizeof(CanvasData), &data ); \n\t\t\tbreak;\n\t\t\t\t\n\t\tcase kEventHIObjectDestruct:\n\t\t\tfree(inUserData);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\t// kEventClassHIObject\n\t\t\t\n\t\t\t\n\tcase kEventClassControl:    // draw, hit test and track\n\t\tswitch ( ekind ){\n\t\tcase kEventControlDraw:\n\t\t\tGetEventParameter(inEvent, kEventParamCGContextRef, typeCGContextRef, NULL, sizeof(CGContextRef), NULL, &ctx);\n\t\t\t//CallNextEventHandler(inCallRef, inEvent);\t    // Erase old content\n\t\t\tDrawPage(ctx);\n\t\t\terr = noErr;\n\t\t\tbreak;\n\t\t}\t\t\t\n\t\tbreak; //kEventClassControl\n\t\t\n\t\t\t\n    case kEventClassMouse:\n    \t{ // Get Wacom Event\t \n\t\t\tUInt32 eventType;\n\t\t\tstruct TabletPointRec tabletPnt; \n\t\t\tstruct TabletProximityRec tabletTyp;\n\t\t\t\n\t\t\terr = GetEventParameter(inEvent, \n\t\t\t\t\t\t\tkEventParamTabletEventType, typeUInt32, NULL,\n\t\t\t\t\t\t\tsizeof(eventType), NULL, &eventType);\n\t\t\tif(err==noErr){ \n\t\t\t\tswitch( eventType ){\n\t\t\t\tcase kEventTabletPoint:\n\t\t\t\t\terr = GetEventParameter(inEvent, \n\t\t\t\t\t\t\tkEventParamTabletPointRec, typeTabletPointRec, NULL,\n\t\t\t\t\t\t\tsizeof(tabletPnt), NULL, &tabletPnt);\n\t\t\t\t\tif(err==noErr){\n\t\t\t\t\t\t\tm_press = tabletPnt.pressure;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase kEventTabletProximity:\n\t\t\t\t\terr = GetEventParameter(inEvent, \n\t\t\t\t\t\t\tkEventParamTabletProximityRec, typeTabletProximityRec, NULL,\n\t\t\t\t\t\t\tsizeof(tabletTyp), NULL, &tabletTyp);\n\t\t\t\t\tif(err==noErr){\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}//Wacom Event\n\t\tswitch( ekind ){\n\t\tcase kEventMouseWheelMoved:\n\t\t\terr = GetEventParameter(inEvent, kEventParamMouseWheelDelta, typeSInt32, NULL, sizeof(SInt32), NULL, &whDelta);\n\t\t\tm_scrollY += whDelta*4;\n\t\t\t/*no break*/\n\t\tcase kEventMouseUp:\n\t\tcase kEventMouseDown:\n\t\tcase kEventMouseDragged:\n\t\tcase kEventMouseMoved:\n\t\t\tif(ekind==kEventMouseDown){\n\t\t\t\tisDown = 1;\n\t\t\t\tm_points[m_index] = m_pointX[m_index][0] = m_pointY[m_index][0] = 0;\n\t\t\t\tm_index++;\n\t\t\t}\n\t\t\tif(ekind==kEventMouseUp){\n\t\t\t\tisDown = 0;\n\t\t\t\tm_press = 0;\n\t\t\t}\n\t\t\tConvertEventRefToEventRecord(inEvent, &eve);\n\n\t\t\tif(FindWindow(eve.where, &wptr)!=inContent && ekind!=kEventMouseUp){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(wptr != ActiveNonFloatingWindow()&& ekind!=kEventMouseUp){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tGetEventParameter(inEvent, kEventParamMouseLocation, typeQDPoint, NULL, sizeof(Point), NULL, &where);\n\t\t\tGetEventParameter(inEvent, kEventParamKeyModifiers, typeUInt32, NULL, sizeof(UInt32), NULL, &modifiers);\n\t\t\tif(isDown){\n\t\t\t\tAddPolygonPoint(m_index-1, where.h, \n\t\t\t\t\t\t\t\twhere.v - m_scrollY -m_bounds.top, 15*m_press/0x10000);\n\t\t\t}\n\t\t\tif(whDelta || isDown){\n\t\t\t\twhDelta=0;\n\t\t\t\tHIViewSetNeedsDisplay(theScrollView, true);\t\t\t\t\n\t\t\t}\n\t\t\tbreak;\n\t\t}\t\t   \n\t\tbreak; //kEventClassMouse\n   \tdefault:\n    \tbreak;\n    }\nParameterMissing:\t\n    return err;\n}\n\n```\n\n### \u8aac\u660e\n- \u7dda\u306e\u30c7\u30fc\u30bf\u306f\u3001\u4ee5\u4e0b\u306e\u914d\u5217\u306b\u683c\u7d0d\u3055\u308c\u3066\u3044\u307e\u3059\u3002AnLINEMAX\u672c\u306e\u7dda\u304c\u5165\u529b\u3067\u304d\u307e\u3059\u3002\u5404\u30b9\u30c8\u30ed\u30fc\u30af\u306e\u70b9\u6570\u3092\u683c\u7d0d\u3057\u305f\u914d\u5217\u304c m_points[AnLINEMAX]\u3067\u3059\u3002\uff11\u672c\u306e\u30b9\u30c8\u30ed\u30fc\u30af\u306f\u6700\u5927AnLPNTMAX\u70b9\u307e\u3067\u3068\u3057\u3066\u3044\u307e\u3059\u3002\n\n```c\nint     m_points[AnLINEMAX];                // Number of points\nint     m_pointX[AnLINEMAX][AnLPNTMAX];     // x\nint     m_pointY[AnLINEMAX][AnLPNTMAX];     // y\nint     m_pressure[AnLINEMAX][AnLPNTMAX];   // pressure\n\n```\n\n- \u592a\u3055\u304c\u5909\u308f\u308b\u7dda\u3092\u63cf\u753b\u3057\u3066\u3044\u308b\u306e\u306f\u3001DrawPage() \u3001MakeBrushLine() \u3001asSetPoint()\u3067\u3059\u3002\n- \u5404\u5ea7\u6a19\u70b9\u306e\u5468\u56f2\u306b\u7dda\u306e\u592a\u3055\u306b\u5bfe\u5fdc\u3057\u305f\uff11\uff12\u89d2\u5f62\u3092\u63cf\u753b\u3057\u3001\u305d\u308c\u305e\u308c\u3092\uff12\u672c\u306e\u7dda\u3067\u3064\u306a\u3044\u3067\u4e2d\u3092\u5857\u308a\u3064\u3076\u3057\u307e\u3059\u3002\u7dda\u306e\u65b9\u5411\u306b\u5fdc\u3058\u3066\uff12\u672c\u306e\u7dda\u3092\u3069\u3053\u306b\u3072\u304f\u304b\u3092\u6c42\u3081\u3066\u3044\u308b\u306e\u304c\u3001MakeBrushLine() \u3067\u3059\u3002asSetPoint()\u3067\u30d1\u30b9\u3092\u751f\u6210\u3057\u3001DrawPage()\u3000\u306e\u4e2d\u306e\u3000CGContextDrawPath()\u3000\u3067\u63cf\u753b\u3057\u3066\u3044\u307e\u3059\u3002\n- \u7b46\u5727\u306e\u691c\u51fa\u306f\u3001\u95a2\u6570\u3000WindowEventHandler() \u306e\u4e2d\u3067\u3001\u30de\u30a6\u30b9\u30a4\u30d9\u30f3\u30c8 kEventClassMouse \u3092\u53d7\u3051\u53d6\u3063\u305f\u3068\u304d\u306b\u3001GetEventParameter(inEvent, kEventParamTabletEventType, typeUInt32, NULL, sizeof(eventType), NULL, &eventType);\n\u3092\u5b9f\u884c\u3057\u3066\u53d6\u5f97\u3057\u3066\u3044\u307e\u3059\u3002    \n\n\n\n\n---\n# \u95a2\u9023\u8a18\u4e8b\n\n1. [\u7121\u6599\u30bd\u30d5\u30c8\u3067\u30a2\u30cb\u30e1\u3092\u4f5c\u3063\u3066\u307f\u3088\u3046\uff089VAe \u304d\u3085\u3046\u3079\u3048\uff09](http://qiita.com/danjiro/items/253e5a33a38599098274)\n3. [\u30b9\u30af\u30e9\u30c3\u30c1\u3001\u30d3\u30b9\u30b1\u30c3\u30c8\u306e\u6b21\u306f 9VAe\uff1d\u7b2c\uff13\u306e\u30d7\u30ed\u30b0\u30e9\u30df\u30f3\u30b0\u5b66\u7fd2\u74b0\u5883](http://qiita.com/danjiro/items/d856d393b3e138af123a)\n6. [9VAe\u304d\u3085\u3046\u3079\u3048\uff1a\u9577\u3044\u30a2\u30cb\u30e1\u3092\u4f5c\u308b\u65b9\u6cd5](http://qiita.com/danjiro/items/020cd885edb5eb3d9fb0)\n1. [\u52d5\u304fLINE\u30b9\u30bf\u30f3\u30d7\u306eAPNG\u4f5c\u6210\uff1a\u7121\u6599\u30bd\u30d5\u30c89VAe\u304d\u3085\u3046\u3079\u3048](http://qiita.com/danjiro/items/e4d9eb2b22f90ebd1e91)\n1. [9VAe\u304d\u3085\u3046\u3079\u3048\u300d\u3067\u7d75\u3092\u63cf\u304b\u305a\u306b\u4f5c\u308c\u308bGIF\u30a2\u30cb\u30e1](http://qiita.com/danjiro/items/7fa584a4336cda9c0a05)\n2. [9VAe\u304d\u3085\u3046\u3079\u3048\u3067\u4f5c\u6210\u3057\u305fSVG\u30a2\u30cb\u30e1\u30fc\u30b7\u30e7\u30f3](http://qiita.com/danjiro/items/1b4f6b5a520ade762116)\n1.  [\u30a2\u30cb\u30e1\u30bd\u30d5\u30c8 9VAe \u3092\u30ab\u30b9\u30bf\u30de\u30a4\u30ba\u3059\u308b\u65b9\u6cd5](http://qiita.com/danjiro/items/c5dc07671ffdbbb8a9a9)\n3. [9VAe\u3092\u30ad\u30c3\u30ba\u30d7\u30e9\u30b6\u5927\u962a\u5411\u3051\u306b\u6539\u9020\u3059\u308b](http://qiita.com/danjiro/items/bbb10e07a9775a938200)\n4. [9VAe / 9svg \u30c7\u30fc\u30bf\u30d5\u30a9\u30fc\u30de\u30c3\u30c8\u89e3\u8aac](http://qiita.com/danjiro/items/0d4ac334a7a97ddb4fe2)\n5. [\u30d5\u30ea\u30fc\u30bd\u30d5\u30c89VAe\u304d\u3085\u3046\u3079\u3048\u3067\u7c21\u5358\u30c7\u30b8\u30bf\u30eb\u30b5\u30a4\u30cd\u30fc\u30b8](http://qiita.com/danjiro/items/e3b7ac1ef24826f9ff3d)\n\n\n", "tags": ["\u30ef\u30b3\u30e0", "\u7b46\u5727", "9VAe", "\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0", "C"]}