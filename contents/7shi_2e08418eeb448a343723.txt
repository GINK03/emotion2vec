{"context": "HAR\u30d5\u30a1\u30a4\u30eb\uff08\u30d6\u30e9\u30a6\u30b6\u306e\u901a\u4fe1\u72b6\u6cc1\u3092\u30c0\u30f3\u30d7\u3057\u305fJSON\u30d5\u30a1\u30a4\u30eb\uff09\u304b\u3089\u30d5\u30a1\u30a4\u30eb\u3092\u62bd\u51fa\u3057\u307e\u3059\u3002\n\u3053\u306e\u8a18\u4e8b\u3067\u306f\u6b21\u306e\u8a18\u4e8b\u3067\u4f5c\u3063\u305fJSON\u30d1\u30fc\u30b5\u30fc\u3092\u4f7f\u7528\u3057\u307e\u3059\u3002\n\n\nJSON\u30d1\u30fc\u30b5\u30fc\u3092\u4f5c\u308b 2016.12.26\n\n\n\u8abf\u67fb\n\u3042\u308b\u7a0b\u5ea6\u5de8\u5927\u306aHAR\u30d5\u30a1\u30a4\u30eb\u306f\u5168\u5bb9\u3092\u628a\u63e1\u3057\u306b\u304f\u3044\u306e\u3067\u3001\u9805\u76ee\u3092\u5217\u6319\u3057\u3066\u773a\u3081\u307e\u3059\u3002\ntry\n    use sr = new StreamReader(\"Test.har\", Text.Encoding.UTF8)\n    use jp = new JSONParser(sr)\n    while jp.Read() do\n    let v = jp.Value\n    let v = if v.Length < 20 then v else v.[..19] + \"..\"\n    printfn \"%A %A %c %A\" (List.rev jp.Stack) jp.Name jp.Type v\nwith e ->\n    printf \"%A\" e\n\n\n\u5b9f\u884c\u7d50\u679c\n[] \"log\" { \"\"\n[\"log\"] \"version\" : \"1.1\"\n[\"log\"] \"creator\" { \"\"\n[\"log\"; \"creator\"] \"name\" : \"Firefox\"\n[\"log\"; \"creator\"] \"version\" : \"50.0\"\n[\"log\"] \"creator\" } \"\"\n[\"log\"] \"browser\" { \"\"\n[\"log\"; \"browser\"] \"name\" : \"Firefox\"\n[\"log\"; \"browser\"] \"version\" : \"50.0\"\n[\"log\"] \"browser\" } \"\"\n[\"log\"] \"pages\" [ \"\"\n[\"log\"; \"pages\"] \"\" { \"\"\n\uff08\u7565\uff09\n\n\n\u3053\u308c\u3092\u773a\u3081\u3066\u307f\u308b\u3068\u3001\u4e3b\u8981\u90e8\u306f\u4ee5\u4e0b\u306e\u69cb\u9020\u306b\u306a\u3063\u3066\u3044\u308b\u3053\u3068\u304c\u5206\u304b\u308a\u307e\u3057\u305f\u3002\nlog\n+ creator\n+ browser\n+ pages\n+ entries\n  + (entry)\n  | + request\n  | | + url\n  | + response\n  |   + headers\n  |   + cookies\n  |   + content\n  + (entry)\n  + ...\n\n\ncontent\u306e\u9805\u76ee\n\u30d5\u30a1\u30a4\u30eb\u306e\u5b9f\u4f53\u304c\u5165\u3063\u3066\u3044\u308b\u306e\u306f content \u3067\u3059\u3002\u3059\u3079\u3066\u306b\u540c\u3058\u9805\u76ee\u304c\u5b58\u5728\u3059\u308b\u308f\u3051\u3067\u306f\u306a\u3044\u3088\u3046\u306a\u306e\u3067\u3001\u5168\u90e8\u306e\u9805\u76ee\u3092\u30c1\u30a7\u30c3\u30af\u3057\u3066\u5217\u6319\u3057\u307e\u3059\u3002\ntry\n    use sr = new StreamReader(\"Test.har\", Text.Encoding.UTF8)\n    use jp = new JSONParser(sr)\n    seq {\n        while jp.Find \"content\" do\n        for _ in jp.Each() -> jp.Name }\n    |> Seq.distinct\n    |> Seq.sort\n    |> Seq.iter (printfn \"%s\")\nwith e ->\n    printf \"%A\" e\n\n\n\u5b9f\u884c\u7d50\u679c\ncomment\nencoding\nmimeType\nsize\ntext\n\n\ncomment \u306f\u30aa\u30d7\u30b7\u30e7\u30ca\u30eb\u306a\u3088\u3046\u3067\u3001\u307b\u3068\u3093\u3069\u5b58\u5728\u3057\u307e\u305b\u3093\u3002\n\n\u30d1\u30fc\u30b5\u30fc\u306e\u5b9f\u88c5\n\u30a8\u30f3\u30c8\u30ea\u30fc\u3092\u683c\u7d0d\u3059\u308b\u30ec\u30b3\u30fc\u30c9\u578b\u3092\u7528\u610f\u3057\u307e\u3059\u3002request \u306e url \u3068 response \u306e content \u3092\u8aad\u307f\u8fbc\u307f\u307e\u3059\u3002\ntype Entry = { url:string; size:int; mimeType:string; encoding:string; text:string }\n\nlet entry (jp:JSONParser) =\n    let mutable url, size, mimeType, encoding, text = \"\", 0, \"\", \"\", \"\"\n    for _ in jp.Each() do\n        match jp.Name with\n        | \"request\" ->\n            for _ in jp.Each() do\n            if jp.Name = \"url\" then url <- jp.Value\n        | \"response\" ->\n            for _ in jp.Each() do\n            if jp.Name = \"content\" then\n                for _ in jp.Each() do\n                match jp.Name with\n                | \"size\"     -> size <- Convert.ToInt32 jp.Value\n                | \"mimeType\" -> mimeType <- jp.Value\n                | \"encoding\" -> encoding <- jp.Value\n                | \"text\"     -> text     <- jp.Value\n                | _          -> ()\n        | _ -> ()\n    { url = url; size = size; mimeType = mimeType; encoding = encoding; text = text }\n\nJSON\u306e\u69cb\u9020\u3068\u540c\u3058\u3088\u3046\u306b\u30d1\u30fc\u30b5\u30fc\u3092\u66f8\u304d\u307e\u3059\u3002\u968e\u5c64\u3054\u3068\u306b jp.Each() \u3067\u30eb\u30fc\u30d7\u3092\u56de\u3057\u3066\u3044\u308b\u306e\u304c\u30dd\u30a4\u30f3\u30c8\u3067\u3059\u3002\n\n\u5024\u306e\u8abf\u67fb\nencoding \u3068 mimeType \u306e\u5024\u3092\u8abf\u3079\u307e\u3059\u3002\ntry\n    use sr = new StreamReader(\"Test.har\", Text.Encoding.UTF8)\n    use jp = new JSONParser(sr)\n    seq {\n        while jp.Find \"content\" do\n        for _ in jp.Each() do\n        match jp.Name with\n        | \"encoding\" | \"mimeType\" -> yield jp.Name, jp.Value\n        | _ -> () }\n    |> Seq.groupBy fst\n    |> Seq.iter (fun (n, vs) ->\n        printfn \"%s:\" n\n        vs\n        |> Seq.map snd\n        |> Seq.distinct\n        |> Seq.sort\n        |> Seq.iter (printfn \"  %s\"))\nwith e ->\n    printf \"%A\" e\n\n\n\u5b9f\u884c\u7d50\u679c\nmimeType:\n  image/jpeg\n  image/png\n  text/css; charset=UTF-8\n  text/html\n  text/html; charset=UTF-8\n  text/javascript\n  text/javascript; charset=UTF-8\nencoding:\n  base64\n\n\n\u30b5\u30fc\u30d0\u30fc\u306b\u3088\u3063\u3066 charset \u304c\u4ed8\u3044\u305f\u308a\u4ed8\u304b\u306a\u304b\u3063\u305f\u308a\u3057\u307e\u3059\u3002\u4eca\u56de\u306f\u7c21\u5358\u306e\u305f\u3081\u7121\u8996\u3057\u3066 UTF-8 \u3067\u7d71\u4e00\u3057\u307e\u3059\u3002\n\n\u62e1\u5f35\u5b50\u306e\u5909\u63db\nMIME\u30bf\u30a4\u30d7\u304b\u3089\u62e1\u5f35\u5b50\u306b\u5909\u63db\u3057\u307e\u3059\u3002\u7db2\u7f85\u3057\u304d\u308c\u306a\u3044\u305f\u3081\u4ee3\u8868\u7684\u306a\u3082\u306e\u3060\u3051\u3067\u3059\u3002\nlet mimeToExt (mime:string) =\n    match (mime.Split ';').[0].Trim().ToLower() with\n    | \"application/javascript\"   -> \".js\"\n    | \"application/json\"         -> \".json\"\n    | \"application/octet-stream\" -> \".bin\"\n    | \"application/x-javascript\" -> \".js\"\n    | \"binary/octet-stream\"      -> \".bin\"\n    | \"image/gif\"                -> \".gif\"\n    | \"image/jpeg\"               -> \".jpg\"\n    | \"image/png\"                -> \".png\"\n    | \"image/x-win-bitmap\"       -> \".bmp\"\n    | \"text/css\"                 -> \".css\"\n    | \"text/html\"                -> \".html\"\n    | \"text/javascript\"          -> \".js\"\n    | \"text/plain\"               -> \".txt\"\n    | \"text/xml\"                 -> \".xml\"\n    | _                          -> \"\"\n\n\n\u30d5\u30a1\u30a4\u30eb\u306e\u62bd\u51fa\n\u3053\u3053\u307e\u3067\u8abf\u3079\u308c\u3070\u30d5\u30a1\u30a4\u30eb\u304c\u62bd\u51fa\u3067\u304d\u307e\u3059\u3002\nlet extractHar (har:string) (outdir:string) =\n    if not <| Directory.Exists outdir then\n        Directory.CreateDirectory outdir |> ignore\n    use sr = new StreamReader(har, Text.Encoding.UTF8)\n    let jp = JSONParser sr\n    if not <| jp.Find \"entries\" then () else\n    use sw = new StreamWriter(Path.Combine(outdir, \"_index.tsv\"), false, Text.Encoding.UTF8)\n    seq {for _ in jp.Each() -> entry jp}\n    |> Seq.filter (fun e -> e.url.Length > 0 && e.text.Length > 0 && e.size > 0)\n    |> Seq.iteri (fun i e ->\n        let fn = string (i + 1) + mimeToExt e.mimeType\n        fprintfn sw \"%s\\t%d\\t%s\\t%s\\t%s\" fn e.size e.mimeType e.encoding e.url\n        let fn = Path.Combine(outdir, fn)\n        match e.encoding with\n        | \"base64\" ->\n            File.WriteAllBytes(fn, Convert.FromBase64String e.text)\n        | _ ->\n            File.WriteAllText(fn, e.text, Text.Encoding.UTF8))\n\n\u6b21\u306e\u3088\u3046\u306b\u4f7f\u7528\u3057\u307e\u3059\u3002\nextractHar \"\u5165\u529b.har\" \"\u51fa\u529b\u5148\u30d5\u30a9\u30eb\u30c0\"\n\n\u51fa\u529b\u5148\u30d5\u30a9\u30eb\u30c0\u306b\u306f _index.tsv \u3068\u3044\u3046\u30d5\u30a1\u30a4\u30eb\u4e00\u89a7\u304c\u51fa\u529b\u3055\u308c\u307e\u3059\u3002\n\n\u307e\u3068\u3081\n\u30b3\u30fc\u30c9\u5168\u4f53\u306f\u4ee5\u4e0b\u306b\u63b2\u8f09\u3057\u307e\u3059\u3002\n\nhttps://bitbucket.org/snippets/7shi/z4KKK\n\nHAR\u30d5\u30a1\u30a4\u30eb\uff08\u30d6\u30e9\u30a6\u30b6\u306e\u901a\u4fe1\u72b6\u6cc1\u3092\u30c0\u30f3\u30d7\u3057\u305fJSON\u30d5\u30a1\u30a4\u30eb\uff09\u304b\u3089\u30d5\u30a1\u30a4\u30eb\u3092\u62bd\u51fa\u3057\u307e\u3059\u3002\n\n\u3053\u306e\u8a18\u4e8b\u3067\u306f\u6b21\u306e\u8a18\u4e8b\u3067\u4f5c\u3063\u305fJSON\u30d1\u30fc\u30b5\u30fc\u3092\u4f7f\u7528\u3057\u307e\u3059\u3002\n\n* [JSON\u30d1\u30fc\u30b5\u30fc\u3092\u4f5c\u308b](http://qiita.com/7shi/items/04c2991239894687ef2f) 2016.12.26\n\n# \u8abf\u67fb\n\n\u3042\u308b\u7a0b\u5ea6\u5de8\u5927\u306aHAR\u30d5\u30a1\u30a4\u30eb\u306f\u5168\u5bb9\u3092\u628a\u63e1\u3057\u306b\u304f\u3044\u306e\u3067\u3001\u9805\u76ee\u3092\u5217\u6319\u3057\u3066\u773a\u3081\u307e\u3059\u3002\n\n```fsharp\ntry\n    use sr = new StreamReader(\"Test.har\", Text.Encoding.UTF8)\n    use jp = new JSONParser(sr)\n    while jp.Read() do\n    let v = jp.Value\n    let v = if v.Length < 20 then v else v.[..19] + \"..\"\n    printfn \"%A %A %c %A\" (List.rev jp.Stack) jp.Name jp.Type v\nwith e ->\n    printf \"%A\" e\n```\n```text:\u5b9f\u884c\u7d50\u679c\n[] \"log\" { \"\"\n[\"log\"] \"version\" : \"1.1\"\n[\"log\"] \"creator\" { \"\"\n[\"log\"; \"creator\"] \"name\" : \"Firefox\"\n[\"log\"; \"creator\"] \"version\" : \"50.0\"\n[\"log\"] \"creator\" } \"\"\n[\"log\"] \"browser\" { \"\"\n[\"log\"; \"browser\"] \"name\" : \"Firefox\"\n[\"log\"; \"browser\"] \"version\" : \"50.0\"\n[\"log\"] \"browser\" } \"\"\n[\"log\"] \"pages\" [ \"\"\n[\"log\"; \"pages\"] \"\" { \"\"\n\uff08\u7565\uff09\n```\n\n\u3053\u308c\u3092\u773a\u3081\u3066\u307f\u308b\u3068\u3001\u4e3b\u8981\u90e8\u306f\u4ee5\u4e0b\u306e\u69cb\u9020\u306b\u306a\u3063\u3066\u3044\u308b\u3053\u3068\u304c\u5206\u304b\u308a\u307e\u3057\u305f\u3002\n\n```text\nlog\n+ creator\n+ browser\n+ pages\n+ entries\n  + (entry)\n  | + request\n  | | + url\n  | + response\n  |   + headers\n  |   + cookies\n  |   + content\n  + (entry)\n  + ...\n```\n\n## content\u306e\u9805\u76ee\n\n\u30d5\u30a1\u30a4\u30eb\u306e\u5b9f\u4f53\u304c\u5165\u3063\u3066\u3044\u308b\u306e\u306f `content` \u3067\u3059\u3002\u3059\u3079\u3066\u306b\u540c\u3058\u9805\u76ee\u304c\u5b58\u5728\u3059\u308b\u308f\u3051\u3067\u306f\u306a\u3044\u3088\u3046\u306a\u306e\u3067\u3001\u5168\u90e8\u306e\u9805\u76ee\u3092\u30c1\u30a7\u30c3\u30af\u3057\u3066\u5217\u6319\u3057\u307e\u3059\u3002\n\n```fsharp\ntry\n    use sr = new StreamReader(\"Test.har\", Text.Encoding.UTF8)\n    use jp = new JSONParser(sr)\n    seq {\n        while jp.Find \"content\" do\n        for _ in jp.Each() -> jp.Name }\n    |> Seq.distinct\n    |> Seq.sort\n    |> Seq.iter (printfn \"%s\")\nwith e ->\n    printf \"%A\" e\n```\n```text:\u5b9f\u884c\u7d50\u679c\ncomment\nencoding\nmimeType\nsize\ntext\n```\n\n`comment` \u306f\u30aa\u30d7\u30b7\u30e7\u30ca\u30eb\u306a\u3088\u3046\u3067\u3001\u307b\u3068\u3093\u3069\u5b58\u5728\u3057\u307e\u305b\u3093\u3002\n\n### \u30d1\u30fc\u30b5\u30fc\u306e\u5b9f\u88c5\n\n\u30a8\u30f3\u30c8\u30ea\u30fc\u3092\u683c\u7d0d\u3059\u308b\u30ec\u30b3\u30fc\u30c9\u578b\u3092\u7528\u610f\u3057\u307e\u3059\u3002`request` \u306e `url` \u3068 `response` \u306e `content` \u3092\u8aad\u307f\u8fbc\u307f\u307e\u3059\u3002\n\n```fsharp\ntype Entry = { url:string; size:int; mimeType:string; encoding:string; text:string }\n\nlet entry (jp:JSONParser) =\n    let mutable url, size, mimeType, encoding, text = \"\", 0, \"\", \"\", \"\"\n    for _ in jp.Each() do\n        match jp.Name with\n        | \"request\" ->\n            for _ in jp.Each() do\n            if jp.Name = \"url\" then url <- jp.Value\n        | \"response\" ->\n            for _ in jp.Each() do\n            if jp.Name = \"content\" then\n                for _ in jp.Each() do\n                match jp.Name with\n                | \"size\"     -> size <- Convert.ToInt32 jp.Value\n                | \"mimeType\" -> mimeType <- jp.Value\n                | \"encoding\" -> encoding <- jp.Value\n                | \"text\"     -> text     <- jp.Value\n                | _          -> ()\n        | _ -> ()\n    { url = url; size = size; mimeType = mimeType; encoding = encoding; text = text }\n```\n\nJSON\u306e\u69cb\u9020\u3068\u540c\u3058\u3088\u3046\u306b\u30d1\u30fc\u30b5\u30fc\u3092\u66f8\u304d\u307e\u3059\u3002\u968e\u5c64\u3054\u3068\u306b `jp.Each()` \u3067\u30eb\u30fc\u30d7\u3092\u56de\u3057\u3066\u3044\u308b\u306e\u304c\u30dd\u30a4\u30f3\u30c8\u3067\u3059\u3002\n\n## \u5024\u306e\u8abf\u67fb\n\n`encoding` \u3068 `mimeType` \u306e\u5024\u3092\u8abf\u3079\u307e\u3059\u3002\n\n```fsharp\ntry\n    use sr = new StreamReader(\"Test.har\", Text.Encoding.UTF8)\n    use jp = new JSONParser(sr)\n    seq {\n        while jp.Find \"content\" do\n        for _ in jp.Each() do\n        match jp.Name with\n        | \"encoding\" | \"mimeType\" -> yield jp.Name, jp.Value\n        | _ -> () }\n    |> Seq.groupBy fst\n    |> Seq.iter (fun (n, vs) ->\n        printfn \"%s:\" n\n        vs\n        |> Seq.map snd\n        |> Seq.distinct\n        |> Seq.sort\n        |> Seq.iter (printfn \"  %s\"))\nwith e ->\n    printf \"%A\" e\n```\n```text:\u5b9f\u884c\u7d50\u679c\nmimeType:\n  image/jpeg\n  image/png\n  text/css; charset=UTF-8\n  text/html\n  text/html; charset=UTF-8\n  text/javascript\n  text/javascript; charset=UTF-8\nencoding:\n  base64\n```\n\n\u30b5\u30fc\u30d0\u30fc\u306b\u3088\u3063\u3066 `charset` \u304c\u4ed8\u3044\u305f\u308a\u4ed8\u304b\u306a\u304b\u3063\u305f\u308a\u3057\u307e\u3059\u3002\u4eca\u56de\u306f\u7c21\u5358\u306e\u305f\u3081\u7121\u8996\u3057\u3066 UTF-8 \u3067\u7d71\u4e00\u3057\u307e\u3059\u3002\n\n### \u62e1\u5f35\u5b50\u306e\u5909\u63db\n\nMIME\u30bf\u30a4\u30d7\u304b\u3089\u62e1\u5f35\u5b50\u306b\u5909\u63db\u3057\u307e\u3059\u3002\u7db2\u7f85\u3057\u304d\u308c\u306a\u3044\u305f\u3081\u4ee3\u8868\u7684\u306a\u3082\u306e\u3060\u3051\u3067\u3059\u3002\n\n```fsharp\nlet mimeToExt (mime:string) =\n    match (mime.Split ';').[0].Trim().ToLower() with\n    | \"application/javascript\"   -> \".js\"\n    | \"application/json\"         -> \".json\"\n    | \"application/octet-stream\" -> \".bin\"\n    | \"application/x-javascript\" -> \".js\"\n    | \"binary/octet-stream\"      -> \".bin\"\n    | \"image/gif\"                -> \".gif\"\n    | \"image/jpeg\"               -> \".jpg\"\n    | \"image/png\"                -> \".png\"\n    | \"image/x-win-bitmap\"       -> \".bmp\"\n    | \"text/css\"                 -> \".css\"\n    | \"text/html\"                -> \".html\"\n    | \"text/javascript\"          -> \".js\"\n    | \"text/plain\"               -> \".txt\"\n    | \"text/xml\"                 -> \".xml\"\n    | _                          -> \"\"\n```\n\n# \u30d5\u30a1\u30a4\u30eb\u306e\u62bd\u51fa\n\n\u3053\u3053\u307e\u3067\u8abf\u3079\u308c\u3070\u30d5\u30a1\u30a4\u30eb\u304c\u62bd\u51fa\u3067\u304d\u307e\u3059\u3002\n\n```fsharp\nlet extractHar (har:string) (outdir:string) =\n    if not <| Directory.Exists outdir then\n        Directory.CreateDirectory outdir |> ignore\n    use sr = new StreamReader(har, Text.Encoding.UTF8)\n    let jp = JSONParser sr\n    if not <| jp.Find \"entries\" then () else\n    use sw = new StreamWriter(Path.Combine(outdir, \"_index.tsv\"), false, Text.Encoding.UTF8)\n    seq {for _ in jp.Each() -> entry jp}\n    |> Seq.filter (fun e -> e.url.Length > 0 && e.text.Length > 0 && e.size > 0)\n    |> Seq.iteri (fun i e ->\n        let fn = string (i + 1) + mimeToExt e.mimeType\n        fprintfn sw \"%s\\t%d\\t%s\\t%s\\t%s\" fn e.size e.mimeType e.encoding e.url\n        let fn = Path.Combine(outdir, fn)\n        match e.encoding with\n        | \"base64\" ->\n            File.WriteAllBytes(fn, Convert.FromBase64String e.text)\n        | _ ->\n            File.WriteAllText(fn, e.text, Text.Encoding.UTF8))\n```\n\n\u6b21\u306e\u3088\u3046\u306b\u4f7f\u7528\u3057\u307e\u3059\u3002\n\n```fsharp\nextractHar \"\u5165\u529b.har\" \"\u51fa\u529b\u5148\u30d5\u30a9\u30eb\u30c0\"\n```\n\n\u51fa\u529b\u5148\u30d5\u30a9\u30eb\u30c0\u306b\u306f `_index.tsv` \u3068\u3044\u3046\u30d5\u30a1\u30a4\u30eb\u4e00\u89a7\u304c\u51fa\u529b\u3055\u308c\u307e\u3059\u3002\n\n# \u307e\u3068\u3081\n\n\u30b3\u30fc\u30c9\u5168\u4f53\u306f\u4ee5\u4e0b\u306b\u63b2\u8f09\u3057\u307e\u3059\u3002\n\n* https://bitbucket.org/snippets/7shi/z4KKK\n", "tags": ["F#", "JSON"]}