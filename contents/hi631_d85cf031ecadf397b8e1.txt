{"tags": ["Arduino", "camera", "ov7670"], "context": "\n\nArduino\u306b\u30ab\u30e1\u30e9\u30e2\u30b8\u30e5\u30fc\u30eb(OV7670 FiFo\u7121)\u3092\u3064\u306a\u3044\u3067\u307f\u305f\n\n\u6982\u8981\n\u3000\u753b\u50cf\u51e6\u7406\u3092\u7c21\u5358\u306b\u5b89\u4fa1\u306b\u3084\u308b\u624b\u6bb5\u306b\u3064\u3044\u3066\u691c\u8a0e\u3059\u308b\u3002\n\u3000(\u5b8c\u6210\u54c1\u3092\u8cfc\u5165\u3059\u308b\u306e\u304c\u4e00\u756a\u624b\u8efd\u3060\u304c\u3053\u308c\u3067\u306f\u9762\u767d\u304f\u306a\u3044)\n\u3000\u5b89\u4fa1\u306a\u30ab\u30e1\u30e9\u30e2\u30b8\u30e5\u30fc\u30eb\u3068\u3057\u3066OV7670(FiFo\u7121)\u304c\u6709\u308b\u304c\u3001\u307e\u3068\u3082\u306b\u3084\u308b\u306b\u306f20Mbps\u7a0b\u5ea6\u306e\u51e6\u7406\u80fd\u529b\u304c\u5fc5\u8981\u3068\u306a\u308b\u304c\u3001\u3053\u308c\u3092\u5b89\u4fa1\u3060\u304c\u975e\u529b(16M)\u306aArduino\u3067\u3069\u3053\u307e\u3067\u51fa\u6765\u308b\u304b\u8a66\u3057\u3066\u898b\u308b\u3002\n\n\u3084\u308b\u3053\u3068\n\u3000\u65e2\u306b\u5148\u4f8b\u304c\u6709\u308b\u306e\u3067\u3001\u3053\u308c\u306e\u8ffd\u8a66\u3068\u6a5f\u80fd\u5411\u4e0a\u3092\u76ee\u6307\u3059\u3002\n\u3000<\u5148\u4f8bURL>\n\u3000\u3000[OV7670 without FIFO very simple framecapture with Arduino, black/white]\n\u3000\u3000http://www.instructables.com/id/OV7670-Without-FIFO-Very-Simple-Framecapture-With-/\n\n\u8ffd\u8a66\u5185\u5bb9\n\uff11\uff0e\u30cf\u30fc\u30c9\u30a6\u30a7\u30a2(\u4e0a\u8a18URL\u3068\u540c\u3058\u69cb\u6210)\n\u3000(1)Arduino(uno)\n\u3000 \u3000uno\u306e\u30af\u30ed\u30fc\u30f3\n\u3000\u3000\u3000\u203b\u5b89\u304b\u3063\u305f\u306e\u3067\u8cb7\u3063\u305f\u304c\u3001\u30b7\u30ea\u30a2\u30eb\u306e\u30c9\u30e9\u30a4\u30d0\u306b\u96e3\u304c\u6709\u308a\u305d\u3046\n\u3000\u3000\u3000\u203b1Mbps\u3067\u306e\u901a\u4fe1\u306f\u51fa\u6765\u3066\u3044\u308b\u3002\n\n\u3000(2)\u30ab\u30e1\u30e9(ov7670)\u3068\u914d\u7dda\u4f8b\n\n\u3000(3)\u914d\u7dda\u56f3(\u4e0a\u8a18URL\u8a18\u8f09\u3068\u540c\u4e00)\n\n\uff12\uff0e\u30bd\u30d5\u30c8\u30a6\u30a7\u30a2\n\u3000\u4e0a\u8a18URL\u3068\u307b\u307c\u540c\u3058(\u4e00\u90e8\u5909\u66f4\u6709)\n\u3000\u300cuno_ov7670.ino\u300d\n//\n// Source code for application to transmit image from ov7670 to PC via USB\n// By Siarhei Charkes in 2015\n// http://privateblog.info \n//\n\n#include <stdint.h>\n#include <avr/io.h>\n#include <util/twi.h>\n#include <util/delay.h>\n#include <avr/pgmspace.h>\n\n#define F_CPU 16000000UL\n#define vga   0\n#define qvga  1\n#define qqvga   2\n#define yuv422  0\n#define rgb565  1\n#define bayerRGB  2\n#define camAddr_WR  0x42\n#define camAddr_RD  0x43\n\n/* Registers */\n#define REG_GAIN    0x00  /* Gain lower 8 bits (rest in vref) */\n#define REG_BLUE    0x01  /* blue gain */\n#define REG_RED       0x02  /* red gain */\n#define REG_VREF    0x03  /* Pieces of GAIN, VSTART, VSTOP */\n#define REG_COM1    0x04  /* Control 1 */\n#define COM1_CCIR656  0x40    /* CCIR656 enable */\n\n#define REG_BAVE    0x05  /* U/B Average level */\n#define REG_GbAVE   0x06  /* Y/Gb Average level */\n#define REG_AECHH   0x07  /* AEC MS 5 bits */\n#define REG_RAVE    0x08  /* V/R Average level */\n#define REG_COM2    0x09  /* Control 2 */\n#define COM2_SSLEEP         0x10  /* Soft sleep mode */\n#define REG_PID           0x0a  /* Product ID MSB */\n#define REG_VER           0x0b  /* Product ID LSB */\n#define REG_COM3    0x0c  /* Control 3 */\n#define COM3_SWAP         0x40  /* Byte swap */\n#define COM3_SCALEEN          0x08  /* Enable scaling */\n#define COM3_DCWEN          0x04  /* Enable downsamp/crop/window */\n#define REG_COM4    0x0d  /* Control 4 */\n#define REG_COM5    0x0e  /* All \"reserved\" */\n#define REG_COM6    0x0f  /* Control 6 */\n#define REG_AECH    0x10  /* More bits of AEC value */\n#define REG_CLKRC   0x11  /* Clocl control */\n#define CLK_EXT           0x40  /* Use external clock directly */\n#define CLK_SCALE   0x3f  /* Mask for internal clock scale */\n#define REG_COM7    0x12  /* Control 7 */ //REG mean address.\n#define COM7_RESET          0x80  /* Register reset */\n#define COM7_FMT_MASK         0x38\n#define COM7_FMT_VGA          0x00\n#define COM7_FMT_CIF          0x20  /* CIF format */\n#define COM7_FMT_QVGA         0x10  /* QVGA format */\n#define COM7_FMT_QCIF         0x08  /* QCIF format */\n#define COM7_RGB          0x04  /* bits 0 and 2 - RGB format */\n#define COM7_YUV          0x00  /* YUV */\n#define COM7_BAYER          0x01  /* Bayer format */\n#define COM7_PBAYER         0x05  /* \"Processed bayer\" */\n#define REG_COM8    0x13  /* Control 8 */\n#define COM8_FASTAEC          0x80  /* Enable fast AGC/AEC */\n#define COM8_AECSTEP          0x40  /* Unlimited AEC step size */\n#define COM8_BFILT    0x20  /* Band filter enable */\n#define COM8_AGC    0x04  /* Auto gain enable */\n#define COM8_AWB    0x02  /* White balance enable */\n#define COM8_AEC    0x01  /* Auto exposure enable */\n#define REG_COM9    0x14  /* Control 9- gain ceiling */\n#define REG_COM10   0x15  /* Control 10 */\n#define COM10_HSYNC         0x40  /* HSYNC instead of HREF */\n#define COM10_PCLK_HB         0x20  /* Suppress PCLK on horiz blank */\n#define COM10_HREF_REV          0x08  /* Reverse HREF */\n#define COM10_VS_LEAD         0x04  /* VSYNC on clock leading edge */\n#define COM10_VS_NEG          0x02  /* VSYNC negative */\n#define COM10_HS_NEG          0x01  /* HSYNC negative */\n#define REG_HSTART    0x17  /* Horiz start high bits */\n#define REG_HSTOP   0x18  /* Horiz stop high bits */\n#define REG_VSTART    0x19  /* Vert start high bits */\n#define REG_VSTOP   0x1a  /* Vert stop high bits */\n#define REG_PSHFT   0x1b  /* Pixel delay after HREF */\n#define REG_MIDH    0x1c  /* Manuf. ID high */\n#define REG_MIDL    0x1d  /* Manuf. ID low */\n#define REG_MVFP    0x1e  /* Mirror / vflip */\n#define MVFP_MIRROR         0x20  /* Mirror image */\n#define MVFP_FLIP   0x10  /* Vertical flip */\n\n#define REG_AEW           0x24  /* AGC upper limit */\n#define REG_AEB           0x25    /* AGC lower limit */\n#define REG_VPT           0x26  /* AGC/AEC fast mode op region */\n#define REG_HSYST   0x30  /* HSYNC rising edge delay */\n#define REG_HSYEN   0x31  /* HSYNC falling edge delay */\n#define REG_HREF    0x32  /* HREF pieces */\n#define REG_TSLB    0x3a  /* lots of stuff */\n#define TSLB_YLAST    0x04  /* UYVY or VYUY - see com13 */\n#define REG_COM11   0x3b  /* Control 11 */\n#define COM11_NIGHT         0x80  /* NIght mode enable */\n#define COM11_NMFR          0x60  /* Two bit NM frame rate */\n#define COM11_HZAUTO          0x10  /* Auto detect 50/60 Hz */\n#define COM11_50HZ          0x08  /* Manual 50Hz select */\n#define COM11_EXP   0x02\n#define REG_COM12   0x3c  /* Control 12 */\n#define COM12_HREF          0x80  /* HREF always */\n#define REG_COM13   0x3d  /* Control 13 */\n#define COM13_GAMMA         0x80  /* Gamma enable */\n#define COM13_UVSAT         0x40  /* UV saturation auto adjustment */\n#define COM13_UVSWAP          0x01  /* V before U - w/TSLB */\n#define REG_COM14   0x3e  /* Control 14 */\n#define COM14_DCWEN         0x10  /* DCW/PCLK-scale enable */\n#define REG_EDGE    0x3f  /* Edge enhancement factor */\n#define REG_COM15   0x40  /* Control 15 */\n#define COM15_R10F0         0x00  /* Data range 10 to F0 */\n#define COM15_R01FE         0x80  /*      01 to FE */\n#define COM15_R00FF         0xc0  /*      00 to FF */\n#define COM15_RGB565          0x10  /* RGB565 output */\n#define COM15_RGB555          0x30  /* RGB555 output */\n#define REG_COM16   0x41  /* Control 16 */\n#define COM16_AWBGAIN         0x08  /* AWB gain enable */\n#define REG_COM17   0x42  /* Control 17 */\n#define COM17_AECWIN          0xc0  /* AEC window - must match COM4 */\n#define COM17_CBAR          0x08  /* DSP Color bar */\n/*\n* This matrix defines how the colors are generated, must be\n* tweaked to adjust hue and saturation.\n*\n* Order: v-red, v-green, v-blue, u-red, u-green, u-blue\n* They are nine-bit signed quantities, with the sign bit\n* stored in0x58.Sign for v-red is bit 0, and up from there.\n*/\n#define REG_CMATRIX_BASE  0x4f\n#define CMATRIX_LEN           6\n#define REG_CMATRIX_SIGN  0x58\n#define REG_BRIGHT    0x55  /* Brightness */\n#define REG_CONTRAS         0x56  /* Contrast control */\n#define REG_GFIX    0x69  /* Fix gain control */\n#define REG_REG76   0x76  /* OV's name */\n#define R76_BLKPCOR         0x80  /* Black pixel correction enable */\n#define R76_WHTPCOR         0x40  /* White pixel correction enable */\n#define REG_RGB444          0x8c  /* RGB 444 control */\n#define R444_ENABLE         0x02  /* Turn on RGB444, overrides 5x5 */\n#define R444_RGBX   0x01  /* Empty nibble at end */\n#define REG_HAECC1    0x9f  /* Hist AEC/AGC control 1 */\n#define REG_HAECC2    0xa0  /* Hist AEC/AGC control 2 */\n#define REG_BD50MAX         0xa5  /* 50hz banding step limit */\n#define REG_HAECC3    0xa6  /* Hist AEC/AGC control 3 */\n#define REG_HAECC4    0xa7  /* Hist AEC/AGC control 4 */\n#define REG_HAECC5    0xa8  /* Hist AEC/AGC control 5 */\n#define REG_HAECC6    0xa9  /* Hist AEC/AGC control 6 */\n#define REG_HAECC7    0xaa  /* Hist AEC/AGC control 7 */\n#define REG_BD60MAX         0xab  /* 60hz banding step limit */\n#define REG_GAIN    0x00  /* Gain lower 8 bits (rest in vref) */\n#define REG_BLUE    0x01  /* blue gain */\n#define REG_RED           0x02  /* red gain */\n#define REG_VREF    0x03  /* Pieces of GAIN, VSTART, VSTOP */\n#define REG_COM1    0x04  /* Control 1 */\n#define COM1_CCIR656          0x40  /* CCIR656 enable */\n#define REG_BAVE    0x05  /* U/B Average level */\n#define REG_GbAVE   0x06  /* Y/Gb Average level */\n#define REG_AECHH   0x07  /* AEC MS 5 bits */\n#define REG_RAVE    0x08  /* V/R Average level */\n#define REG_COM2    0x09  /* Control 2 */\n#define COM2_SSLEEP         0x10  /* Soft sleep mode */\n#define REG_PID           0x0a  /* Product ID MSB */\n#define REG_VER           0x0b  /* Product ID LSB */\n#define REG_COM3    0x0c  /* Control 3 */\n#define COM3_SWAP         0x40  /* Byte swap */\n#define COM3_SCALEEN          0x08  /* Enable scaling */\n#define COM3_DCWEN          0x04  /* Enable downsamp/crop/window */\n#define REG_COM4    0x0d  /* Control 4 */\n#define REG_COM5    0x0e  /* All \"reserved\" */\n#define REG_COM6    0x0f  /* Control 6 */\n#define REG_AECH    0x10  /* More bits of AEC value */\n#define REG_CLKRC   0x11  /* Clocl control */\n#define CLK_EXT           0x40  /* Use external clock directly */\n#define CLK_SCALE   0x3f  /* Mask for internal clock scale */\n#define REG_COM7    0x12  /* Control 7 */\n#define COM7_RESET          0x80  /* Register reset */\n#define COM7_FMT_MASK         0x38\n#define COM7_FMT_VGA          0x00\n#define COM7_FMT_CIF          0x20  /* CIF format */\n#define COM7_FMT_QVGA         0x10  /* QVGA format */\n#define COM7_FMT_QCIF         0x08  /* QCIF format */\n#define COM7_RGB    0x04  /* bits 0 and 2 - RGB format */\n#define COM7_YUV    0x00  /* YUV */\n#define COM7_BAYER          0x01  /* Bayer format */\n#define COM7_PBAYER         0x05  /* \"Processed bayer\" */\n#define REG_COM8    0x13  /* Control 8 */\n#define COM8_FASTAEC          0x80  /* Enable fast AGC/AEC */\n#define COM8_AECSTEP          0x40  /* Unlimited AEC step size */\n#define COM8_BFILT    0x20  /* Band filter enable */\n#define COM8_AGC    0x04  /* Auto gain enable */\n#define COM8_AWB    0x02  /* White balance enable */\n#define COM8_AEC    0x01  /* Auto exposure enable */\n#define REG_COM9    0x14  /* Control 9- gain ceiling */\n#define REG_COM10   0x15  /* Control 10 */\n#define COM10_HSYNC         0x40  /* HSYNC instead of HREF */\n#define COM10_PCLK_HB         0x20  /* Suppress PCLK on horiz blank */\n#define COM10_HREF_REV          0x08  /* Reverse HREF */\n#define COM10_VS_LEAD           0x04  /* VSYNC on clock leading edge */\n#define COM10_VS_NEG          0x02  /* VSYNC negative */\n#define COM10_HS_NEG          0x01  /* HSYNC negative */\n#define REG_HSTART    0x17  /* Horiz start high bits */\n#define REG_HSTOP   0x18  /* Horiz stop high bits */\n#define REG_VSTART    0x19  /* Vert start high bits */\n#define REG_VSTOP   0x1a  /* Vert stop high bits */\n#define REG_PSHFT   0x1b  /* Pixel delay after HREF */\n#define REG_MIDH    0x1c  /* Manuf. ID high */\n#define REG_MIDL    0x1d  /* Manuf. ID low */\n#define REG_MVFP    0x1e  /* Mirror / vflip */\n#define MVFP_MIRROR         0x20  /* Mirror image */\n#define MVFP_FLIP   0x10  /* Vertical flip */\n#define REG_AEW           0x24  /* AGC upper limit */\n#define REG_AEB           0x25  /* AGC lower limit */\n#define REG_VPT           0x26  /* AGC/AEC fast mode op region */\n#define REG_HSYST   0x30  /* HSYNC rising edge delay */\n#define REG_HSYEN   0x31  /* HSYNC falling edge delay */\n#define REG_HREF    0x32  /* HREF pieces */\n#define REG_TSLB    0x3a  /* lots of stuff */\n#define TSLB_YLAST    0x04  /* UYVY or VYUY - see com13 */\n#define REG_COM11   0x3b  /* Control 11 */\n#define COM11_NIGHT         0x80  /* NIght mode enable */\n#define COM11_NMFR          0x60  /* Two bit NM frame rate */\n#define COM11_HZAUTO          0x10  /* Auto detect 50/60 Hz */\n#define COM11_50HZ          0x08  /* Manual 50Hz select */\n#define COM11_EXP   0x02\n#define REG_COM12   0x3c  /* Control 12 */\n#define COM12_HREF          0x80  /* HREF always */\n#define REG_COM13   0x3d  /* Control 13 */\n#define COM13_GAMMA         0x80  /* Gamma enable */\n#define COM13_UVSAT         0x40  /* UV saturation auto adjustment */\n#define COM13_UVSWAP          0x01  /* V before U - w/TSLB */\n#define REG_COM14   0x3e  /* Control 14 */\n#define COM14_DCWEN         0x10  /* DCW/PCLK-scale enable */\n#define REG_EDGE    0x3f  /* Edge enhancement factor */\n#define REG_COM15   0x40  /* Control 15 */\n#define COM15_R10F0         0x00  /* Data range 10 to F0 */\n#define COM15_R01FE         0x80  /*      01 to FE */\n#define COM15_R00FF         0xc0  /*      00 to FF */\n#define COM15_RGB565          0x10  /* RGB565 output */\n#define COM15_RGB555          0x30  /* RGB555 output */\n#define REG_COM16   0x41  /* Control 16 */\n#define COM16_AWBGAIN         0x08  /* AWB gain enable */\n#define REG_COM17   0x42  /* Control 17 */\n#define COM17_AECWIN          0xc0  /* AEC window - must match COM4 */\n#define COM17_CBAR          0x08  /* DSP Color bar */\n\n#define CMATRIX_LEN             6\n#define REG_BRIGHT    0x55  /* Brightness */\n#define REG_REG76   0x76  /* OV's name */\n#define R76_BLKPCOR         0x80  /* Black pixel correction enable */\n#define R76_WHTPCOR         0x40  /* White pixel correction enable */\n#define REG_RGB444          0x8c  /* RGB 444 control */\n#define R444_ENABLE         0x02  /* Turn on RGB444, overrides 5x5 */\n#define R444_RGBX   0x01  /* Empty nibble at end */\n#define REG_HAECC1    0x9f  /* Hist AEC/AGC control 1 */\n#define REG_HAECC2    0xa0  /* Hist AEC/AGC control 2 */\n#define REG_BD50MAX         0xa5  /* 50hz banding step limit */\n#define REG_HAECC3    0xa6  /* Hist AEC/AGC control 3 */\n#define REG_HAECC4    0xa7  /* Hist AEC/AGC control 4 */\n#define REG_HAECC5    0xa8  /* Hist AEC/AGC control 5 */\n#define REG_HAECC6    0xa9  /* Hist AEC/AGC control 6 */\n#define REG_HAECC7    0xaa  /* Hist AEC/AGC control 7 */\n#define REG_BD60MAX         0xab  /* 60hz banding step limit */\n#define MTX1            0x4f  /* Matrix Coefficient 1 */\n#define MTX2            0x50  /* Matrix Coefficient 2 */\n#define MTX3            0x51  /* Matrix Coefficient 3 */\n#define MTX4            0x52  /* Matrix Coefficient 4 */\n#define MTX5            0x53  /* Matrix Coefficient 5 */\n#define MTX6            0x54  /* Matrix Coefficient 6 */\n#define REG_CONTRAS         0x56  /* Contrast control */\n#define MTXS            0x58  /* Matrix Coefficient Sign */\n#define AWBC7           0x59  /* AWB Control 7 */\n#define AWBC8           0x5a  /* AWB Control 8 */\n#define AWBC9           0x5b  /* AWB Control 9 */\n#define AWBC10            0x5c  /* AWB Control 10 */\n#define AWBC11            0x5d  /* AWB Control 11 */\n#define AWBC12            0x5e  /* AWB Control 12 */\n#define REG_GFI           0x69  /* Fix gain control */\n#define GGAIN           0x6a  /* G Channel AWB Gain */\n#define DBLV            0x6b  \n#define AWBCTR3           0x6c  /* AWB Control 3 */\n#define AWBCTR2           0x6d  /* AWB Control 2 */\n#define AWBCTR1           0x6e  /* AWB Control 1 */\n#define AWBCTR0           0x6f  /* AWB Control 0 */\n\nstruct regval_list{\n  uint8_t reg_num;\n  uint16_t value;\n};\n\nconst struct regval_list qvga_ov7670[] PROGMEM = {\n  { REG_COM14, 0x19 },\n  { 0x72, 0x11 },\n  { 0x73, 0xf1 },\n\n  { REG_HSTART, 0x16 },\n  { REG_HSTOP, 0x04 },\n  { REG_HREF, 0xa4 },\n  { REG_VSTART, 0x02 },\n  { REG_VSTOP, 0x7a },\n  { REG_VREF, 0x0a },\n\n\n/*  { REG_HSTART, 0x16 },\n  { REG_HSTOP, 0x04 },\n  { REG_HREF, 0x24 },\n  { REG_VSTART, 0x02 },\n  { REG_VSTOP, 0x7a },\n  { REG_VREF, 0x0a },*/\n  { 0xff, 0xff }, /* END MARKER */\n};\n\nconst struct regval_list yuv422_ov7670[] PROGMEM = {\n  { REG_COM7, 0x0 },  /* Selects YUV mode */\n  { REG_RGB444, 0 },  /* No RGB444 please */\n  { REG_COM1, 0 },\n  { REG_COM15, COM15_R00FF },\n  { REG_COM9, 0x6A }, /* 128x gain ceiling; 0x8 is reserved bit */\n  { 0x4f, 0x80 },   /* \"matrix coefficient 1\" */\n  { 0x50, 0x80 },   /* \"matrix coefficient 2\" */\n  { 0x51, 0 },    /* vb */\n  { 0x52, 0x22 },   /* \"matrix coefficient 4\" */\n  { 0x53, 0x5e },   /* \"matrix coefficient 5\" */\n  { 0x54, 0x80 },   /* \"matrix coefficient 6\" */\n  { REG_COM13, COM13_UVSAT },\n  { 0xff, 0xff },   /* END MARKER */\n};\n\nconst struct regval_list ov7670_default_regs[] PROGMEM = {//from the linux driver\n  { REG_COM7, COM7_RESET },\n  { REG_TSLB, 0x04 }, /* OV */\n  { REG_COM7, 0 },  /* VGA */\n  /*\n  * Set the hardware window.  These values from OV don't entirely\n  * make sense - hstop is less than hstart.  But they work...\n  */\n  { REG_HSTART, 0x13 }, { REG_HSTOP, 0x01 },\n  { REG_HREF, 0xb6 }, { REG_VSTART, 0x02 },\n  { REG_VSTOP, 0x7a }, { REG_VREF, 0x0a },\n\n  { REG_COM3, 0 }, { REG_COM14, 0 },\n  /* Mystery scaling numbers */\n  { 0x70, 0x3a }, { 0x71, 0x35 },\n  { 0x72, 0x11 }, { 0x73, 0xf0 },\n  { 0xa2,/* 0x02 changed to 1*/1 }, { REG_COM10, 0x0 },\n  /* Gamma curve values */\n  { 0x7a, 0x20 }, { 0x7b, 0x10 },\n  { 0x7c, 0x1e }, { 0x7d, 0x35 },\n  { 0x7e, 0x5a }, { 0x7f, 0x69 },\n  { 0x80, 0x76 }, { 0x81, 0x80 },\n  { 0x82, 0x88 }, { 0x83, 0x8f },\n  { 0x84, 0x96 }, { 0x85, 0xa3 },\n  { 0x86, 0xaf }, { 0x87, 0xc4 },\n  { 0x88, 0xd7 }, { 0x89, 0xe8 },\n  /* AGC and AEC parameters.  Note we start by disabling those features,\n  then turn them only after tweaking the values. */\n  { REG_COM8, COM8_FASTAEC | COM8_AECSTEP },\n  { REG_GAIN, 0 }, { REG_AECH, 0 },\n  { REG_COM4, 0x40 }, /* magic reserved bit */\n  { REG_COM9, 0x18 }, /* 4x gain + magic rsvd bit */\n  { REG_BD50MAX, 0x05 }, { REG_BD60MAX, 0x07 },\n  { REG_AEW, 0x95 }, { REG_AEB, 0x33 },\n  { REG_VPT, 0xe3 }, { REG_HAECC1, 0x78 },\n  { REG_HAECC2, 0x68 }, { 0xa1, 0x03 }, /* magic */\n  { REG_HAECC3, 0xd8 }, { REG_HAECC4, 0xd8 },\n  { REG_HAECC5, 0xf0 }, { REG_HAECC6, 0x90 },\n  { REG_HAECC7, 0x94 },\n  { REG_COM8, COM8_FASTAEC | COM8_AECSTEP | COM8_AGC | COM8_AEC },\n  { 0x30, 0 }, { 0x31, 0 },//disable some delays\n  /* Almost all of these are magic \"reserved\" values.  */\n  { REG_COM5, 0x61 }, { REG_COM6, 0x4b },\n  { 0x16, 0x02 }, { REG_MVFP, 0x07 },\n  { 0x21, 0x02 }, { 0x22, 0x91 },\n  { 0x29, 0x07 }, { 0x33, 0x0b },\n  { 0x35, 0x0b }, { 0x37, 0x1d },\n  { 0x38, 0x71 }, { 0x39, 0x2a },\n  { REG_COM12, 0x78 }, { 0x4d, 0x40 },\n  { 0x4e, 0x20 }, { REG_GFIX, 0 },\n  /*{0x6b, 0x4a},*/{ 0x74, 0x10 },\n  { 0x8d, 0x4f }, { 0x8e, 0 },\n  { 0x8f, 0 }, { 0x90, 0 },\n  { 0x91, 0 }, { 0x96, 0 },\n  { 0x9a, 0 }, { 0xb0, 0x84 },\n  { 0xb1, 0x0c }, { 0xb2, 0x0e },\n  { 0xb3, 0x82 }, { 0xb8, 0x0a },\n\n  /* More reserved magic, some of which tweaks white balance */\n  { 0x43, 0x0a }, { 0x44, 0xf0 },\n  { 0x45, 0x34 }, { 0x46, 0x58 },\n  { 0x47, 0x28 }, { 0x48, 0x3a },\n  { 0x59, 0x88 }, { 0x5a, 0x88 },\n  { 0x5b, 0x44 }, { 0x5c, 0x67 },\n  { 0x5d, 0x49 }, { 0x5e, 0x0e },\n  { 0x6c, 0x0a }, { 0x6d, 0x55 },\n  { 0x6e, 0x11 }, { 0x6f, 0x9e }, /* it was 0x9F \"9e for advance AWB\" */\n  { 0x6a, 0x40 }, { REG_BLUE, 0x40 },\n  { REG_RED, 0x60 },\n  { REG_COM8, COM8_FASTAEC | COM8_AECSTEP | COM8_AGC | COM8_AEC | COM8_AWB },\n\n  /* Matrix coefficients */\n  { 0x4f, 0x80 }, { 0x50, 0x80 },\n  { 0x51, 0 },    { 0x52, 0x22 },\n  { 0x53, 0x5e }, { 0x54, 0x80 },\n  { 0x58, 0x9e },\n\n  { REG_COM16, COM16_AWBGAIN }, { REG_EDGE, 0 },\n  { 0x75, 0x05 }, { REG_REG76, 0xe1 },\n  { 0x4c, 0 },     { 0x77, 0x01 },\n  { REG_COM13, /*0xc3*/0x48 }, { 0x4b, 0x09 },\n  { 0xc9, 0x60 },   /*{REG_COM16, 0x38},*/\n  { 0x56, 0x40 },\n\n  { 0x34, 0x11 }, { REG_COM11, COM11_EXP | COM11_HZAUTO },\n  { 0xa4, 0x82/*Was 0x88*/ }, { 0x96, 0 },\n  { 0x97, 0x30 }, { 0x98, 0x20 },\n  { 0x99, 0x30 }, { 0x9a, 0x84 },\n  { 0x9b, 0x29 }, { 0x9c, 0x03 },\n  { 0x9d, 0x4c }, { 0x9e, 0x3f },\n  { 0x78, 0x04 },\n\n  /* Extra-weird stuff.  Some sort of multiplexor register */\n  { 0x79, 0x01 }, { 0xc8, 0xf0 },\n  { 0x79, 0x0f }, { 0xc8, 0x00 },\n  { 0x79, 0x10 }, { 0xc8, 0x7e },\n  { 0x79, 0x0a }, { 0xc8, 0x80 },\n  { 0x79, 0x0b }, { 0xc8, 0x01 },\n  { 0x79, 0x0c }, { 0xc8, 0x0f },\n  { 0x79, 0x0d }, { 0xc8, 0x20 },\n  { 0x79, 0x09 }, { 0xc8, 0x80 },\n  { 0x79, 0x02 }, { 0xc8, 0xc0 },\n  { 0x79, 0x03 }, { 0xc8, 0x40 },\n  { 0x79, 0x05 }, { 0xc8, 0x30 },\n  { 0x79, 0x26 },\n  { 0xff, 0xff }, /* END MARKER */\n};\n\n\nvoid error_led(void){\n  DDRB |= 32;//make sure led is output\n  while (1){//wait for reset\n    PORTB ^= 32;// toggle led\n    _delay_ms(100);\n  }\n}\n\nvoid twiStart(void){\n  TWCR = _BV(TWINT) | _BV(TWSTA) | _BV(TWEN);//send start\n  while (!(TWCR & (1 << TWINT)));//wait for start to be transmitted\n  if ((TWSR & 0xF8) != TW_START)\n    error_led();\n}\n\nvoid twiWriteByte(uint8_t DATA, uint8_t type){\n  TWDR = DATA;\n  TWCR = _BV(TWINT) | _BV(TWEN);\n  while (!(TWCR & (1 << TWINT))) {}\n  if ((TWSR & 0xF8) != type)\n    error_led();\n}\n\nvoid twiAddr(uint8_t addr, uint8_t typeTWI){\n  TWDR = addr;//send address\n  TWCR = _BV(TWINT) | _BV(TWEN);    /* clear interrupt to start transmission */\n  while ((TWCR & _BV(TWINT)) == 0); /* wait for transmission */\n  if ((TWSR & 0xF8) != typeTWI)\n    error_led();\n}\n\nvoid wrReg(uint8_t reg, uint8_t dat){\n  //send start condition\n  twiStart();\n  twiAddr(camAddr_WR, TW_MT_SLA_ACK);\n  twiWriteByte(reg, TW_MT_DATA_ACK);\n  twiWriteByte(dat, TW_MT_DATA_ACK);\n  TWCR = (1 << TWINT) | (1 << TWEN) | (1 << TWSTO);//send stop\n  _delay_ms(1);\n}\n\nstatic uint8_t twiRd(uint8_t nack){\n  if (nack){\n    TWCR = _BV(TWINT) | _BV(TWEN);\n    while ((TWCR & _BV(TWINT)) == 0); /* wait for transmission */\n    if ((TWSR & 0xF8) != TW_MR_DATA_NACK)\n      error_led();\n    return TWDR;\n  }\n  else{\n    TWCR = _BV(TWINT) | _BV(TWEN) | _BV(TWEA);\n    while ((TWCR & _BV(TWINT)) == 0); /* wait for transmission */\n    if ((TWSR & 0xF8) != TW_MR_DATA_ACK)\n      error_led();\n    return TWDR;\n  }\n}\n\nuint8_t rdReg(uint8_t reg){\n  uint8_t dat;\n  twiStart();\n  twiAddr(camAddr_WR, TW_MT_SLA_ACK);\n  twiWriteByte(reg, TW_MT_DATA_ACK);\n  TWCR = (1 << TWINT) | (1 << TWEN) | (1 << TWSTO);//send stop\n  _delay_ms(1);\n  twiStart();\n  twiAddr(camAddr_RD, TW_MR_SLA_ACK);\n  dat = twiRd(1);\n  TWCR = (1 << TWINT) | (1 << TWEN) | (1 << TWSTO);//send stop\n  _delay_ms(1);\n  return dat;\n}\n\nvoid wrSensorRegs8_8(const struct regval_list reglist[]){\n  uint8_t reg_addr, reg_val;\n  const struct regval_list *next = reglist;\n  while ((reg_addr != 0xff) | (reg_val != 0xff)){\n    reg_addr = pgm_read_byte(&next->reg_num);\n    reg_val = pgm_read_byte(&next->value);\n    wrReg(reg_addr, reg_val);\n    next++;\n  }\n}\n\nvoid setColor(void){\n  wrSensorRegs8_8(yuv422_ov7670);\n}\n\nvoid setRes(void){\n  wrReg(REG_COM3, 4); // REG_COM3 enable scaling\n  wrSensorRegs8_8(qvga_ov7670);\n}\n\nvoid camInit(void){\n  wrReg(0x12, 0x80);\n  _delay_ms(100);\n  wrSensorRegs8_8(ov7670_default_regs);\n  wrReg(REG_COM10, 32);//PCLK does not toggle on HBLANK.\n}\n\nvoid arduinoUnoInut(void) {\n  cli();//disable interrupts\n\n    /* Setup the 8mhz PWM clock\n  * This will be on pin 11*/\n  DDRB |= (1 << 3);//pin 11\n  ASSR &= ~(_BV(EXCLK) | _BV(AS2));\n  TCCR2A = (1 << COM2A0) | (1 << WGM21) | (1 << WGM20);\n  TCCR2B = (1 << WGM22) | (1 << CS20);\n  OCR2A = 0;//(F_CPU)/(2*(X+1))\n  DDRC &= ~15;//low d0-d3 camera\n  DDRD &= ~252;//d7-d4 and interrupt pins\n  _delay_ms(3000);\n\n    //set up twi for 100khz\n  TWSR &= ~3;//disable prescaler for TWI\n  TWBR = 72;//set to 100khz\n\n    //enable serial\n  UBRR0H = 0;\n  UBRR0L = 1;//0 = 2M baud rate. 1 = 1M baud. 3 = 0.5M. 7 = 250k 207 is 9600 baud rate.\n  UCSR0A |= 2;//double speed aysnc\n  UCSR0B = (1 << RXEN0) | (1 << TXEN0);//Enable receiver and transmitter\n  UCSR0C = 6;//async 1 stop bit 8bit char no parity bits\n}\nvoid smsg(const char * str){\n  while(*str != 0) {\n    while (!(UCSR0A & (1 << UDRE0)));\n    UDR0 = *str; str++;\n  }\n}\n\nvoid StringPgm(const char * str){\n  do{\n      while (!(UCSR0A & (1 << UDRE0)));//wait for byte to transmit\n      UDR0 = pgm_read_byte_near(str);\n      while (!(UCSR0A & (1 << UDRE0)));//wait for byte to transmit\n  } while (pgm_read_byte_near(++str));\n}\n\nstatic void captureImg(uint16_t wg, uint16_t hg){\n  uint16_t y, x;\n\n  //StringPgm(PSTR(\"*RDY*\"));\n\n  while (!(PIND & 8));//wait for high\n  while ((PIND & 8));//wait for low\n  UDR0 = 0xff; // Start Mark\n\n  y = hg;\n  while (y--){\n        x = wg;\n      //while (!(PIND & 256));//wait for high\n    while (x--){\n      while ((PIND & 4));//wait for low\n        while (!(UCSR0A & (1 << UDRE0)));//wait for byte to transmit\n        UDR0 = (PINC & 15) | (PIND & 240);\n      while (!(PIND & 4));//wait for high\n      while ((PIND & 4));//wait for low\n      while (!(PIND & 4));//wait for high\n    }\n    //  while ((PIND & 256));//wait for low\n  }\n  for( x=0; x<8; x++){ // End Mark\n    while (!(UCSR0A & (1 << UDRE0)));//wait for byte to transmit\n      UDR0 = 0; //(PINC & 15) | (PIND & 240);\n  }\n    _delay_ms(100);\n}\n\nvoid setup(){\n  arduinoUnoInut();\n  camInit();\n  setRes();\n  setColor();\n  wrReg(0x11, 11); //Earlier it had the value: wrReg(0x11, 12); New version works better for me :) !!!!\n}\n\nvoid loop(){\n  captureImg(320, 240);\n}\n\n\n\uff13\uff0e\u753b\u50cf\u30c7\u30fc\u30bf\n\u3000\u753b\u50cf\u306f\u4e0b\u8a18\u69cb\u6210\u306e\u30c7\u30fc\u30bf\u304c\u5468\u671f\u7684\u306b\u30b7\u30ea\u30a2\u30eb\u306b\u9001\u4fe1\u3055\u308c\u307e\u3059\u3002\n\u3000\u30c7\u30fc\u30bf\u30d5\u30a9\u30fc\u30de\u30c3\u30c8\u304c\u5148\u4f8b\u3068\u306f\u7570\u306a\u308a\u307e\u3059\u306e\u3067\u3001\u5148\u4f8b\u306b\u8a18\u8f09\u306e\u753b\u50cf\u8868\u793a\u30bd\u30d5\u30c8\u306f\u4f7f\u3048\u307e\u305b\u3093\u3002\n\u3000\u3053\u3061\u3089\u306b\u8a18\u8f09\u3057\u307e\u3057\u305f\u306e\u3067\u3001\u4f75\u305b\u3066\u304a\u8aad\u307f\u304f\u3060\u3055\u3044\u3002\n\u3000\uff3b\u305d\u306e\uff12\u3000\u753b\u50cf\u306e\u8868\u793a\uff3d\n\u3000(1)\u901a\u4fe1\u5f62\u5f0f\n\u3000\u3000\u30b7\u30ea\u30a2\u30eb\u901a\u4fe1\u30001Mbps 8bit 1stop NOPARITY \n\u3000\u3000\u30d5\u30a9\u30fc\u30de\u30c3\u30c8\n\u3000\u3000\u3000\u30d8\u30c3\u30c0\u30fc\u30000xff\n\u3000\u3000\u3000\u30c7\u30fc\u30bf\u672c\u4f53\u3000320 x 240 (\u30d0\u30a4\u30c8)\u3000\u203bQVGA\n\u3000\u3000\u3000\u30d5\u30c3\u30bf\u30fc\u3000\u30000x00 x 8 (\u30d0\u30a4\u30c8)\n\u3000(2)\u64ae\u5f71\u4f8b\n\n\u3000\u203b\u660e\u308b\u3055(AEC)\u304c\u5b89\u5b9a\u3059\u308b\u307e\u3067\u3001\u6570\u30d5\u30ec\u30fc\u30e0\u304b\u304b\u308a\u307e\u3059\u3002\n\n\u3068\u308a\u3042\u3048\u305a\u306e\u8a55\u4fa1\n\u3000(1)Arduino(uno)\u3067\u3082\u753b\u50cf\u51e6\u7406\u306f\u4e00\u5fdc\u53ef\u80fd\u304b\u306a\u3002\n\u3000(2)\u4f46\u3057\u3001\u753b\u50cf\u53d6\u5f97\u306b\u6642\u9593\u304c\u304b\u304b\u308b\u306e\u3067\u3001\u52d5\u304d\u306e\u6709\u308b\u753b\u50cf\u306f\u3076\u308c\u308b\u3002\n\n\u305d\u306e\u4ed6\n\u3000\u4e0a\u8a18\u8a18\u8f09\u306e\u30cf\u30fc\u30c9\u3001\u30bd\u30d5\u30c8\u306f\u7121\u4fdd\u8a3c\u3067\u3042\u308a\u3001\u5404\u81ea\u306e\u8cac\u4efb\u306b\u304a\u3044\u3066\u3054\u5229\u7528\u9858\u3044\u307e\u3059\u3002\n# Arduino\u306b\u30ab\u30e1\u30e9\u30e2\u30b8\u30e5\u30fc\u30eb(OV7670 FiFo\u7121)\u3092\u3064\u306a\u3044\u3067\u307f\u305f\n## \u6982\u8981\n\u3000\u753b\u50cf\u51e6\u7406\u3092\u7c21\u5358\u306b\u5b89\u4fa1\u306b\u3084\u308b\u624b\u6bb5\u306b\u3064\u3044\u3066\u691c\u8a0e\u3059\u308b\u3002\n\u3000(\u5b8c\u6210\u54c1\u3092\u8cfc\u5165\u3059\u308b\u306e\u304c\u4e00\u756a\u624b\u8efd\u3060\u304c\u3053\u308c\u3067\u306f\u9762\u767d\u304f\u306a\u3044)\n\u3000\u5b89\u4fa1\u306a\u30ab\u30e1\u30e9\u30e2\u30b8\u30e5\u30fc\u30eb\u3068\u3057\u3066OV7670(FiFo\u7121)\u304c\u6709\u308b\u304c\u3001\u307e\u3068\u3082\u306b\u3084\u308b\u306b\u306f20Mbps\u7a0b\u5ea6\u306e\u51e6\u7406\u80fd\u529b\u304c\u5fc5\u8981\u3068\u306a\u308b\u304c\u3001\u3053\u308c\u3092\u5b89\u4fa1\u3060\u304c\u975e\u529b(16M)\u306aArduino\u3067\u3069\u3053\u307e\u3067\u51fa\u6765\u308b\u304b\u8a66\u3057\u3066\u898b\u308b\u3002\n## \u3084\u308b\u3053\u3068\n\u3000\u65e2\u306b\u5148\u4f8b\u304c\u6709\u308b\u306e\u3067\u3001\u3053\u308c\u306e\u8ffd\u8a66\u3068\u6a5f\u80fd\u5411\u4e0a\u3092\u76ee\u6307\u3059\u3002\n\u3000<\u5148\u4f8bURL>\n\u3000\u3000[OV7670 without FIFO very simple framecapture with Arduino, black/white]\n\u3000\u3000http://www.instructables.com/id/OV7670-Without-FIFO-Very-Simple-Framecapture-With-/\n\n## \u8ffd\u8a66\u5185\u5bb9\n\uff11\uff0e\u30cf\u30fc\u30c9\u30a6\u30a7\u30a2(\u4e0a\u8a18URL\u3068\u540c\u3058\u69cb\u6210)\n\u3000(1)Arduino(uno)\n\u3000 \u3000uno\u306e\u30af\u30ed\u30fc\u30f3\n\u3000\u3000\u3000\u203b\u5b89\u304b\u3063\u305f\u306e\u3067\u8cb7\u3063\u305f\u304c\u3001\u30b7\u30ea\u30a2\u30eb\u306e\u30c9\u30e9\u30a4\u30d0\u306b\u96e3\u304c\u6709\u308a\u305d\u3046\n\u3000\u3000\u3000\u203b1Mbps\u3067\u306e\u901a\u4fe1\u306f\u51fa\u6765\u3066\u3044\u308b\u3002\n![Image1.jpg](https://qiita-image-store.s3.amazonaws.com/0/159764/ee6a3a94-c1bc-1183-6c59-5e66ec17313e.jpeg)\n\n\u3000(2)\u30ab\u30e1\u30e9(ov7670)\u3068\u914d\u7dda\u4f8b\n![Image2.jpg](https://qiita-image-store.s3.amazonaws.com/0/159764/2b15ea53-9834-74d2-1aae-a3e830c37770.jpeg)\n\n\u3000(3)\u914d\u7dda\u56f3(\u4e0a\u8a18URL\u8a18\u8f09\u3068\u540c\u4e00)\n![Image3.jpg](https://qiita-image-store.s3.amazonaws.com/0/159764/0b463767-5802-f7c0-de16-17341d7beaa3.jpeg)\n\n\uff12\uff0e\u30bd\u30d5\u30c8\u30a6\u30a7\u30a2\n\u3000\u4e0a\u8a18URL\u3068\u307b\u307c\u540c\u3058(\u4e00\u90e8\u5909\u66f4\u6709)\n\u3000\u300cuno_ov7670.ino\u300d\n\n```\n//\n// Source code for application to transmit image from ov7670 to PC via USB\n// By Siarhei Charkes in 2015\n// http://privateblog.info \n//\n\n#include <stdint.h>\n#include <avr/io.h>\n#include <util/twi.h>\n#include <util/delay.h>\n#include <avr/pgmspace.h>\n\n#define F_CPU 16000000UL\n#define vga   0\n#define qvga  1\n#define qqvga   2\n#define yuv422  0\n#define rgb565  1\n#define bayerRGB  2\n#define camAddr_WR  0x42\n#define camAddr_RD  0x43\n\n/* Registers */\n#define REG_GAIN    0x00  /* Gain lower 8 bits (rest in vref) */\n#define REG_BLUE    0x01  /* blue gain */\n#define REG_RED       0x02  /* red gain */\n#define REG_VREF    0x03  /* Pieces of GAIN, VSTART, VSTOP */\n#define REG_COM1    0x04  /* Control 1 */\n#define COM1_CCIR656  0x40    /* CCIR656 enable */\n\n#define REG_BAVE    0x05  /* U/B Average level */\n#define REG_GbAVE   0x06  /* Y/Gb Average level */\n#define REG_AECHH   0x07  /* AEC MS 5 bits */\n#define REG_RAVE    0x08  /* V/R Average level */\n#define REG_COM2    0x09  /* Control 2 */\n#define COM2_SSLEEP         0x10  /* Soft sleep mode */\n#define REG_PID           0x0a  /* Product ID MSB */\n#define REG_VER           0x0b  /* Product ID LSB */\n#define REG_COM3    0x0c  /* Control 3 */\n#define COM3_SWAP         0x40  /* Byte swap */\n#define COM3_SCALEEN          0x08  /* Enable scaling */\n#define COM3_DCWEN          0x04  /* Enable downsamp/crop/window */\n#define REG_COM4    0x0d  /* Control 4 */\n#define REG_COM5    0x0e  /* All \"reserved\" */\n#define REG_COM6    0x0f  /* Control 6 */\n#define REG_AECH    0x10  /* More bits of AEC value */\n#define REG_CLKRC   0x11  /* Clocl control */\n#define CLK_EXT           0x40  /* Use external clock directly */\n#define CLK_SCALE   0x3f  /* Mask for internal clock scale */\n#define REG_COM7    0x12  /* Control 7 */ //REG mean address.\n#define COM7_RESET          0x80  /* Register reset */\n#define COM7_FMT_MASK         0x38\n#define COM7_FMT_VGA          0x00\n#define COM7_FMT_CIF          0x20  /* CIF format */\n#define COM7_FMT_QVGA         0x10  /* QVGA format */\n#define COM7_FMT_QCIF         0x08  /* QCIF format */\n#define COM7_RGB          0x04  /* bits 0 and 2 - RGB format */\n#define COM7_YUV          0x00  /* YUV */\n#define COM7_BAYER          0x01  /* Bayer format */\n#define COM7_PBAYER         0x05  /* \"Processed bayer\" */\n#define REG_COM8    0x13  /* Control 8 */\n#define COM8_FASTAEC          0x80  /* Enable fast AGC/AEC */\n#define COM8_AECSTEP          0x40  /* Unlimited AEC step size */\n#define COM8_BFILT    0x20  /* Band filter enable */\n#define COM8_AGC    0x04  /* Auto gain enable */\n#define COM8_AWB    0x02  /* White balance enable */\n#define COM8_AEC    0x01  /* Auto exposure enable */\n#define REG_COM9    0x14  /* Control 9- gain ceiling */\n#define REG_COM10   0x15  /* Control 10 */\n#define COM10_HSYNC         0x40  /* HSYNC instead of HREF */\n#define COM10_PCLK_HB         0x20  /* Suppress PCLK on horiz blank */\n#define COM10_HREF_REV          0x08  /* Reverse HREF */\n#define COM10_VS_LEAD         0x04  /* VSYNC on clock leading edge */\n#define COM10_VS_NEG          0x02  /* VSYNC negative */\n#define COM10_HS_NEG          0x01  /* HSYNC negative */\n#define REG_HSTART    0x17  /* Horiz start high bits */\n#define REG_HSTOP   0x18  /* Horiz stop high bits */\n#define REG_VSTART    0x19  /* Vert start high bits */\n#define REG_VSTOP   0x1a  /* Vert stop high bits */\n#define REG_PSHFT   0x1b  /* Pixel delay after HREF */\n#define REG_MIDH    0x1c  /* Manuf. ID high */\n#define REG_MIDL    0x1d  /* Manuf. ID low */\n#define REG_MVFP    0x1e  /* Mirror / vflip */\n#define MVFP_MIRROR         0x20  /* Mirror image */\n#define MVFP_FLIP   0x10  /* Vertical flip */\n\n#define REG_AEW           0x24  /* AGC upper limit */\n#define REG_AEB           0x25    /* AGC lower limit */\n#define REG_VPT           0x26  /* AGC/AEC fast mode op region */\n#define REG_HSYST   0x30  /* HSYNC rising edge delay */\n#define REG_HSYEN   0x31  /* HSYNC falling edge delay */\n#define REG_HREF    0x32  /* HREF pieces */\n#define REG_TSLB    0x3a  /* lots of stuff */\n#define TSLB_YLAST    0x04  /* UYVY or VYUY - see com13 */\n#define REG_COM11   0x3b  /* Control 11 */\n#define COM11_NIGHT         0x80  /* NIght mode enable */\n#define COM11_NMFR          0x60  /* Two bit NM frame rate */\n#define COM11_HZAUTO          0x10  /* Auto detect 50/60 Hz */\n#define COM11_50HZ          0x08  /* Manual 50Hz select */\n#define COM11_EXP   0x02\n#define REG_COM12   0x3c  /* Control 12 */\n#define COM12_HREF          0x80  /* HREF always */\n#define REG_COM13   0x3d  /* Control 13 */\n#define COM13_GAMMA         0x80  /* Gamma enable */\n#define COM13_UVSAT         0x40  /* UV saturation auto adjustment */\n#define COM13_UVSWAP          0x01  /* V before U - w/TSLB */\n#define REG_COM14   0x3e  /* Control 14 */\n#define COM14_DCWEN         0x10  /* DCW/PCLK-scale enable */\n#define REG_EDGE    0x3f  /* Edge enhancement factor */\n#define REG_COM15   0x40  /* Control 15 */\n#define COM15_R10F0         0x00  /* Data range 10 to F0 */\n#define COM15_R01FE         0x80  /*      01 to FE */\n#define COM15_R00FF         0xc0  /*      00 to FF */\n#define COM15_RGB565          0x10  /* RGB565 output */\n#define COM15_RGB555          0x30  /* RGB555 output */\n#define REG_COM16   0x41  /* Control 16 */\n#define COM16_AWBGAIN         0x08  /* AWB gain enable */\n#define REG_COM17   0x42  /* Control 17 */\n#define COM17_AECWIN          0xc0  /* AEC window - must match COM4 */\n#define COM17_CBAR          0x08  /* DSP Color bar */\n/*\n* This matrix defines how the colors are generated, must be\n* tweaked to adjust hue and saturation.\n*\n* Order: v-red, v-green, v-blue, u-red, u-green, u-blue\n* They are nine-bit signed quantities, with the sign bit\n* stored in0x58.Sign for v-red is bit 0, and up from there.\n*/\n#define REG_CMATRIX_BASE  0x4f\n#define CMATRIX_LEN           6\n#define REG_CMATRIX_SIGN  0x58\n#define REG_BRIGHT    0x55  /* Brightness */\n#define REG_CONTRAS         0x56  /* Contrast control */\n#define REG_GFIX    0x69  /* Fix gain control */\n#define REG_REG76   0x76  /* OV's name */\n#define R76_BLKPCOR         0x80  /* Black pixel correction enable */\n#define R76_WHTPCOR         0x40  /* White pixel correction enable */\n#define REG_RGB444          0x8c  /* RGB 444 control */\n#define R444_ENABLE         0x02  /* Turn on RGB444, overrides 5x5 */\n#define R444_RGBX   0x01  /* Empty nibble at end */\n#define REG_HAECC1    0x9f  /* Hist AEC/AGC control 1 */\n#define REG_HAECC2    0xa0  /* Hist AEC/AGC control 2 */\n#define REG_BD50MAX         0xa5  /* 50hz banding step limit */\n#define REG_HAECC3    0xa6  /* Hist AEC/AGC control 3 */\n#define REG_HAECC4    0xa7  /* Hist AEC/AGC control 4 */\n#define REG_HAECC5    0xa8  /* Hist AEC/AGC control 5 */\n#define REG_HAECC6    0xa9  /* Hist AEC/AGC control 6 */\n#define REG_HAECC7    0xaa  /* Hist AEC/AGC control 7 */\n#define REG_BD60MAX         0xab  /* 60hz banding step limit */\n#define REG_GAIN    0x00  /* Gain lower 8 bits (rest in vref) */\n#define REG_BLUE    0x01  /* blue gain */\n#define REG_RED           0x02  /* red gain */\n#define REG_VREF    0x03  /* Pieces of GAIN, VSTART, VSTOP */\n#define REG_COM1    0x04  /* Control 1 */\n#define COM1_CCIR656          0x40  /* CCIR656 enable */\n#define REG_BAVE    0x05  /* U/B Average level */\n#define REG_GbAVE   0x06  /* Y/Gb Average level */\n#define REG_AECHH   0x07  /* AEC MS 5 bits */\n#define REG_RAVE    0x08  /* V/R Average level */\n#define REG_COM2    0x09  /* Control 2 */\n#define COM2_SSLEEP         0x10  /* Soft sleep mode */\n#define REG_PID           0x0a  /* Product ID MSB */\n#define REG_VER           0x0b  /* Product ID LSB */\n#define REG_COM3    0x0c  /* Control 3 */\n#define COM3_SWAP         0x40  /* Byte swap */\n#define COM3_SCALEEN          0x08  /* Enable scaling */\n#define COM3_DCWEN          0x04  /* Enable downsamp/crop/window */\n#define REG_COM4    0x0d  /* Control 4 */\n#define REG_COM5    0x0e  /* All \"reserved\" */\n#define REG_COM6    0x0f  /* Control 6 */\n#define REG_AECH    0x10  /* More bits of AEC value */\n#define REG_CLKRC   0x11  /* Clocl control */\n#define CLK_EXT           0x40  /* Use external clock directly */\n#define CLK_SCALE   0x3f  /* Mask for internal clock scale */\n#define REG_COM7    0x12  /* Control 7 */\n#define COM7_RESET          0x80  /* Register reset */\n#define COM7_FMT_MASK         0x38\n#define COM7_FMT_VGA          0x00\n#define COM7_FMT_CIF          0x20  /* CIF format */\n#define COM7_FMT_QVGA         0x10  /* QVGA format */\n#define COM7_FMT_QCIF         0x08  /* QCIF format */\n#define COM7_RGB    0x04  /* bits 0 and 2 - RGB format */\n#define COM7_YUV    0x00  /* YUV */\n#define COM7_BAYER          0x01  /* Bayer format */\n#define COM7_PBAYER         0x05  /* \"Processed bayer\" */\n#define REG_COM8    0x13  /* Control 8 */\n#define COM8_FASTAEC          0x80  /* Enable fast AGC/AEC */\n#define COM8_AECSTEP          0x40  /* Unlimited AEC step size */\n#define COM8_BFILT    0x20  /* Band filter enable */\n#define COM8_AGC    0x04  /* Auto gain enable */\n#define COM8_AWB    0x02  /* White balance enable */\n#define COM8_AEC    0x01  /* Auto exposure enable */\n#define REG_COM9    0x14  /* Control 9- gain ceiling */\n#define REG_COM10   0x15  /* Control 10 */\n#define COM10_HSYNC         0x40  /* HSYNC instead of HREF */\n#define COM10_PCLK_HB         0x20  /* Suppress PCLK on horiz blank */\n#define COM10_HREF_REV          0x08  /* Reverse HREF */\n#define COM10_VS_LEAD           0x04  /* VSYNC on clock leading edge */\n#define COM10_VS_NEG          0x02  /* VSYNC negative */\n#define COM10_HS_NEG          0x01  /* HSYNC negative */\n#define REG_HSTART    0x17  /* Horiz start high bits */\n#define REG_HSTOP   0x18  /* Horiz stop high bits */\n#define REG_VSTART    0x19  /* Vert start high bits */\n#define REG_VSTOP   0x1a  /* Vert stop high bits */\n#define REG_PSHFT   0x1b  /* Pixel delay after HREF */\n#define REG_MIDH    0x1c  /* Manuf. ID high */\n#define REG_MIDL    0x1d  /* Manuf. ID low */\n#define REG_MVFP    0x1e  /* Mirror / vflip */\n#define MVFP_MIRROR         0x20  /* Mirror image */\n#define MVFP_FLIP   0x10  /* Vertical flip */\n#define REG_AEW           0x24  /* AGC upper limit */\n#define REG_AEB           0x25  /* AGC lower limit */\n#define REG_VPT           0x26  /* AGC/AEC fast mode op region */\n#define REG_HSYST   0x30  /* HSYNC rising edge delay */\n#define REG_HSYEN   0x31  /* HSYNC falling edge delay */\n#define REG_HREF    0x32  /* HREF pieces */\n#define REG_TSLB    0x3a  /* lots of stuff */\n#define TSLB_YLAST    0x04  /* UYVY or VYUY - see com13 */\n#define REG_COM11   0x3b  /* Control 11 */\n#define COM11_NIGHT         0x80  /* NIght mode enable */\n#define COM11_NMFR          0x60  /* Two bit NM frame rate */\n#define COM11_HZAUTO          0x10  /* Auto detect 50/60 Hz */\n#define COM11_50HZ          0x08  /* Manual 50Hz select */\n#define COM11_EXP   0x02\n#define REG_COM12   0x3c  /* Control 12 */\n#define COM12_HREF          0x80  /* HREF always */\n#define REG_COM13   0x3d  /* Control 13 */\n#define COM13_GAMMA         0x80  /* Gamma enable */\n#define COM13_UVSAT         0x40  /* UV saturation auto adjustment */\n#define COM13_UVSWAP          0x01  /* V before U - w/TSLB */\n#define REG_COM14   0x3e  /* Control 14 */\n#define COM14_DCWEN         0x10  /* DCW/PCLK-scale enable */\n#define REG_EDGE    0x3f  /* Edge enhancement factor */\n#define REG_COM15   0x40  /* Control 15 */\n#define COM15_R10F0         0x00  /* Data range 10 to F0 */\n#define COM15_R01FE         0x80  /*      01 to FE */\n#define COM15_R00FF         0xc0  /*      00 to FF */\n#define COM15_RGB565          0x10  /* RGB565 output */\n#define COM15_RGB555          0x30  /* RGB555 output */\n#define REG_COM16   0x41  /* Control 16 */\n#define COM16_AWBGAIN         0x08  /* AWB gain enable */\n#define REG_COM17   0x42  /* Control 17 */\n#define COM17_AECWIN          0xc0  /* AEC window - must match COM4 */\n#define COM17_CBAR          0x08  /* DSP Color bar */\n\n#define CMATRIX_LEN             6\n#define REG_BRIGHT    0x55  /* Brightness */\n#define REG_REG76   0x76  /* OV's name */\n#define R76_BLKPCOR         0x80  /* Black pixel correction enable */\n#define R76_WHTPCOR         0x40  /* White pixel correction enable */\n#define REG_RGB444          0x8c  /* RGB 444 control */\n#define R444_ENABLE         0x02  /* Turn on RGB444, overrides 5x5 */\n#define R444_RGBX   0x01  /* Empty nibble at end */\n#define REG_HAECC1    0x9f  /* Hist AEC/AGC control 1 */\n#define REG_HAECC2    0xa0  /* Hist AEC/AGC control 2 */\n#define REG_BD50MAX         0xa5  /* 50hz banding step limit */\n#define REG_HAECC3    0xa6  /* Hist AEC/AGC control 3 */\n#define REG_HAECC4    0xa7  /* Hist AEC/AGC control 4 */\n#define REG_HAECC5    0xa8  /* Hist AEC/AGC control 5 */\n#define REG_HAECC6    0xa9  /* Hist AEC/AGC control 6 */\n#define REG_HAECC7    0xaa  /* Hist AEC/AGC control 7 */\n#define REG_BD60MAX         0xab  /* 60hz banding step limit */\n#define MTX1            0x4f  /* Matrix Coefficient 1 */\n#define MTX2            0x50  /* Matrix Coefficient 2 */\n#define MTX3            0x51  /* Matrix Coefficient 3 */\n#define MTX4            0x52  /* Matrix Coefficient 4 */\n#define MTX5            0x53  /* Matrix Coefficient 5 */\n#define MTX6            0x54  /* Matrix Coefficient 6 */\n#define REG_CONTRAS         0x56  /* Contrast control */\n#define MTXS            0x58  /* Matrix Coefficient Sign */\n#define AWBC7           0x59  /* AWB Control 7 */\n#define AWBC8           0x5a  /* AWB Control 8 */\n#define AWBC9           0x5b  /* AWB Control 9 */\n#define AWBC10            0x5c  /* AWB Control 10 */\n#define AWBC11            0x5d  /* AWB Control 11 */\n#define AWBC12            0x5e  /* AWB Control 12 */\n#define REG_GFI           0x69  /* Fix gain control */\n#define GGAIN           0x6a  /* G Channel AWB Gain */\n#define DBLV            0x6b  \n#define AWBCTR3           0x6c  /* AWB Control 3 */\n#define AWBCTR2           0x6d  /* AWB Control 2 */\n#define AWBCTR1           0x6e  /* AWB Control 1 */\n#define AWBCTR0           0x6f  /* AWB Control 0 */\n\nstruct regval_list{\n  uint8_t reg_num;\n  uint16_t value;\n};\n\nconst struct regval_list qvga_ov7670[] PROGMEM = {\n  { REG_COM14, 0x19 },\n  { 0x72, 0x11 },\n  { 0x73, 0xf1 },\n\n  { REG_HSTART, 0x16 },\n  { REG_HSTOP, 0x04 },\n  { REG_HREF, 0xa4 },\n  { REG_VSTART, 0x02 },\n  { REG_VSTOP, 0x7a },\n  { REG_VREF, 0x0a },\n\n\n/*  { REG_HSTART, 0x16 },\n  { REG_HSTOP, 0x04 },\n  { REG_HREF, 0x24 },\n  { REG_VSTART, 0x02 },\n  { REG_VSTOP, 0x7a },\n  { REG_VREF, 0x0a },*/\n  { 0xff, 0xff }, /* END MARKER */\n};\n\nconst struct regval_list yuv422_ov7670[] PROGMEM = {\n  { REG_COM7, 0x0 },  /* Selects YUV mode */\n  { REG_RGB444, 0 },  /* No RGB444 please */\n  { REG_COM1, 0 },\n  { REG_COM15, COM15_R00FF },\n  { REG_COM9, 0x6A }, /* 128x gain ceiling; 0x8 is reserved bit */\n  { 0x4f, 0x80 },   /* \"matrix coefficient 1\" */\n  { 0x50, 0x80 },   /* \"matrix coefficient 2\" */\n  { 0x51, 0 },    /* vb */\n  { 0x52, 0x22 },   /* \"matrix coefficient 4\" */\n  { 0x53, 0x5e },   /* \"matrix coefficient 5\" */\n  { 0x54, 0x80 },   /* \"matrix coefficient 6\" */\n  { REG_COM13, COM13_UVSAT },\n  { 0xff, 0xff },   /* END MARKER */\n};\n\nconst struct regval_list ov7670_default_regs[] PROGMEM = {//from the linux driver\n  { REG_COM7, COM7_RESET },\n  { REG_TSLB, 0x04 }, /* OV */\n  { REG_COM7, 0 },  /* VGA */\n  /*\n  * Set the hardware window.  These values from OV don't entirely\n  * make sense - hstop is less than hstart.  But they work...\n  */\n  { REG_HSTART, 0x13 }, { REG_HSTOP, 0x01 },\n  { REG_HREF, 0xb6 }, { REG_VSTART, 0x02 },\n  { REG_VSTOP, 0x7a }, { REG_VREF, 0x0a },\n\n  { REG_COM3, 0 }, { REG_COM14, 0 },\n  /* Mystery scaling numbers */\n  { 0x70, 0x3a }, { 0x71, 0x35 },\n  { 0x72, 0x11 }, { 0x73, 0xf0 },\n  { 0xa2,/* 0x02 changed to 1*/1 }, { REG_COM10, 0x0 },\n  /* Gamma curve values */\n  { 0x7a, 0x20 }, { 0x7b, 0x10 },\n  { 0x7c, 0x1e }, { 0x7d, 0x35 },\n  { 0x7e, 0x5a }, { 0x7f, 0x69 },\n  { 0x80, 0x76 }, { 0x81, 0x80 },\n  { 0x82, 0x88 }, { 0x83, 0x8f },\n  { 0x84, 0x96 }, { 0x85, 0xa3 },\n  { 0x86, 0xaf }, { 0x87, 0xc4 },\n  { 0x88, 0xd7 }, { 0x89, 0xe8 },\n  /* AGC and AEC parameters.  Note we start by disabling those features,\n  then turn them only after tweaking the values. */\n  { REG_COM8, COM8_FASTAEC | COM8_AECSTEP },\n  { REG_GAIN, 0 }, { REG_AECH, 0 },\n  { REG_COM4, 0x40 }, /* magic reserved bit */\n  { REG_COM9, 0x18 }, /* 4x gain + magic rsvd bit */\n  { REG_BD50MAX, 0x05 }, { REG_BD60MAX, 0x07 },\n  { REG_AEW, 0x95 }, { REG_AEB, 0x33 },\n  { REG_VPT, 0xe3 }, { REG_HAECC1, 0x78 },\n  { REG_HAECC2, 0x68 }, { 0xa1, 0x03 }, /* magic */\n  { REG_HAECC3, 0xd8 }, { REG_HAECC4, 0xd8 },\n  { REG_HAECC5, 0xf0 }, { REG_HAECC6, 0x90 },\n  { REG_HAECC7, 0x94 },\n  { REG_COM8, COM8_FASTAEC | COM8_AECSTEP | COM8_AGC | COM8_AEC },\n  { 0x30, 0 }, { 0x31, 0 },//disable some delays\n  /* Almost all of these are magic \"reserved\" values.  */\n  { REG_COM5, 0x61 }, { REG_COM6, 0x4b },\n  { 0x16, 0x02 }, { REG_MVFP, 0x07 },\n  { 0x21, 0x02 }, { 0x22, 0x91 },\n  { 0x29, 0x07 }, { 0x33, 0x0b },\n  { 0x35, 0x0b }, { 0x37, 0x1d },\n  { 0x38, 0x71 }, { 0x39, 0x2a },\n  { REG_COM12, 0x78 }, { 0x4d, 0x40 },\n  { 0x4e, 0x20 }, { REG_GFIX, 0 },\n  /*{0x6b, 0x4a},*/{ 0x74, 0x10 },\n  { 0x8d, 0x4f }, { 0x8e, 0 },\n  { 0x8f, 0 }, { 0x90, 0 },\n  { 0x91, 0 }, { 0x96, 0 },\n  { 0x9a, 0 }, { 0xb0, 0x84 },\n  { 0xb1, 0x0c }, { 0xb2, 0x0e },\n  { 0xb3, 0x82 }, { 0xb8, 0x0a },\n\n  /* More reserved magic, some of which tweaks white balance */\n  { 0x43, 0x0a }, { 0x44, 0xf0 },\n  { 0x45, 0x34 }, { 0x46, 0x58 },\n  { 0x47, 0x28 }, { 0x48, 0x3a },\n  { 0x59, 0x88 }, { 0x5a, 0x88 },\n  { 0x5b, 0x44 }, { 0x5c, 0x67 },\n  { 0x5d, 0x49 }, { 0x5e, 0x0e },\n  { 0x6c, 0x0a }, { 0x6d, 0x55 },\n  { 0x6e, 0x11 }, { 0x6f, 0x9e }, /* it was 0x9F \"9e for advance AWB\" */\n  { 0x6a, 0x40 }, { REG_BLUE, 0x40 },\n  { REG_RED, 0x60 },\n  { REG_COM8, COM8_FASTAEC | COM8_AECSTEP | COM8_AGC | COM8_AEC | COM8_AWB },\n\n  /* Matrix coefficients */\n  { 0x4f, 0x80 }, { 0x50, 0x80 },\n  { 0x51, 0 },    { 0x52, 0x22 },\n  { 0x53, 0x5e }, { 0x54, 0x80 },\n  { 0x58, 0x9e },\n\n  { REG_COM16, COM16_AWBGAIN }, { REG_EDGE, 0 },\n  { 0x75, 0x05 }, { REG_REG76, 0xe1 },\n  { 0x4c, 0 },     { 0x77, 0x01 },\n  { REG_COM13, /*0xc3*/0x48 }, { 0x4b, 0x09 },\n  { 0xc9, 0x60 },   /*{REG_COM16, 0x38},*/\n  { 0x56, 0x40 },\n\n  { 0x34, 0x11 }, { REG_COM11, COM11_EXP | COM11_HZAUTO },\n  { 0xa4, 0x82/*Was 0x88*/ }, { 0x96, 0 },\n  { 0x97, 0x30 }, { 0x98, 0x20 },\n  { 0x99, 0x30 }, { 0x9a, 0x84 },\n  { 0x9b, 0x29 }, { 0x9c, 0x03 },\n  { 0x9d, 0x4c }, { 0x9e, 0x3f },\n  { 0x78, 0x04 },\n\n  /* Extra-weird stuff.  Some sort of multiplexor register */\n  { 0x79, 0x01 }, { 0xc8, 0xf0 },\n  { 0x79, 0x0f }, { 0xc8, 0x00 },\n  { 0x79, 0x10 }, { 0xc8, 0x7e },\n  { 0x79, 0x0a }, { 0xc8, 0x80 },\n  { 0x79, 0x0b }, { 0xc8, 0x01 },\n  { 0x79, 0x0c }, { 0xc8, 0x0f },\n  { 0x79, 0x0d }, { 0xc8, 0x20 },\n  { 0x79, 0x09 }, { 0xc8, 0x80 },\n  { 0x79, 0x02 }, { 0xc8, 0xc0 },\n  { 0x79, 0x03 }, { 0xc8, 0x40 },\n  { 0x79, 0x05 }, { 0xc8, 0x30 },\n  { 0x79, 0x26 },\n  { 0xff, 0xff }, /* END MARKER */\n};\n\n\nvoid error_led(void){\n  DDRB |= 32;//make sure led is output\n  while (1){//wait for reset\n    PORTB ^= 32;// toggle led\n    _delay_ms(100);\n  }\n}\n\nvoid twiStart(void){\n  TWCR = _BV(TWINT) | _BV(TWSTA) | _BV(TWEN);//send start\n  while (!(TWCR & (1 << TWINT)));//wait for start to be transmitted\n  if ((TWSR & 0xF8) != TW_START)\n    error_led();\n}\n\nvoid twiWriteByte(uint8_t DATA, uint8_t type){\n  TWDR = DATA;\n  TWCR = _BV(TWINT) | _BV(TWEN);\n  while (!(TWCR & (1 << TWINT))) {}\n  if ((TWSR & 0xF8) != type)\n    error_led();\n}\n\nvoid twiAddr(uint8_t addr, uint8_t typeTWI){\n  TWDR = addr;//send address\n  TWCR = _BV(TWINT) | _BV(TWEN);    /* clear interrupt to start transmission */\n  while ((TWCR & _BV(TWINT)) == 0); /* wait for transmission */\n  if ((TWSR & 0xF8) != typeTWI)\n    error_led();\n}\n\nvoid wrReg(uint8_t reg, uint8_t dat){\n  //send start condition\n  twiStart();\n  twiAddr(camAddr_WR, TW_MT_SLA_ACK);\n  twiWriteByte(reg, TW_MT_DATA_ACK);\n  twiWriteByte(dat, TW_MT_DATA_ACK);\n  TWCR = (1 << TWINT) | (1 << TWEN) | (1 << TWSTO);//send stop\n  _delay_ms(1);\n}\n\nstatic uint8_t twiRd(uint8_t nack){\n  if (nack){\n    TWCR = _BV(TWINT) | _BV(TWEN);\n    while ((TWCR & _BV(TWINT)) == 0); /* wait for transmission */\n    if ((TWSR & 0xF8) != TW_MR_DATA_NACK)\n      error_led();\n    return TWDR;\n  }\n  else{\n    TWCR = _BV(TWINT) | _BV(TWEN) | _BV(TWEA);\n    while ((TWCR & _BV(TWINT)) == 0); /* wait for transmission */\n    if ((TWSR & 0xF8) != TW_MR_DATA_ACK)\n      error_led();\n    return TWDR;\n  }\n}\n\nuint8_t rdReg(uint8_t reg){\n  uint8_t dat;\n  twiStart();\n  twiAddr(camAddr_WR, TW_MT_SLA_ACK);\n  twiWriteByte(reg, TW_MT_DATA_ACK);\n  TWCR = (1 << TWINT) | (1 << TWEN) | (1 << TWSTO);//send stop\n  _delay_ms(1);\n  twiStart();\n  twiAddr(camAddr_RD, TW_MR_SLA_ACK);\n  dat = twiRd(1);\n  TWCR = (1 << TWINT) | (1 << TWEN) | (1 << TWSTO);//send stop\n  _delay_ms(1);\n  return dat;\n}\n\nvoid wrSensorRegs8_8(const struct regval_list reglist[]){\n  uint8_t reg_addr, reg_val;\n  const struct regval_list *next = reglist;\n  while ((reg_addr != 0xff) | (reg_val != 0xff)){\n    reg_addr = pgm_read_byte(&next->reg_num);\n    reg_val = pgm_read_byte(&next->value);\n    wrReg(reg_addr, reg_val);\n    next++;\n  }\n}\n\nvoid setColor(void){\n  wrSensorRegs8_8(yuv422_ov7670);\n}\n\nvoid setRes(void){\n  wrReg(REG_COM3, 4); // REG_COM3 enable scaling\n  wrSensorRegs8_8(qvga_ov7670);\n}\n\nvoid camInit(void){\n  wrReg(0x12, 0x80);\n  _delay_ms(100);\n  wrSensorRegs8_8(ov7670_default_regs);\n  wrReg(REG_COM10, 32);//PCLK does not toggle on HBLANK.\n}\n\nvoid arduinoUnoInut(void) {\n  cli();//disable interrupts\n  \n    /* Setup the 8mhz PWM clock\n  * This will be on pin 11*/\n  DDRB |= (1 << 3);//pin 11\n  ASSR &= ~(_BV(EXCLK) | _BV(AS2));\n  TCCR2A = (1 << COM2A0) | (1 << WGM21) | (1 << WGM20);\n  TCCR2B = (1 << WGM22) | (1 << CS20);\n  OCR2A = 0;//(F_CPU)/(2*(X+1))\n  DDRC &= ~15;//low d0-d3 camera\n  DDRD &= ~252;//d7-d4 and interrupt pins\n  _delay_ms(3000);\n  \n    //set up twi for 100khz\n  TWSR &= ~3;//disable prescaler for TWI\n  TWBR = 72;//set to 100khz\n  \n    //enable serial\n  UBRR0H = 0;\n  UBRR0L = 1;//0 = 2M baud rate. 1 = 1M baud. 3 = 0.5M. 7 = 250k 207 is 9600 baud rate.\n  UCSR0A |= 2;//double speed aysnc\n  UCSR0B = (1 << RXEN0) | (1 << TXEN0);//Enable receiver and transmitter\n  UCSR0C = 6;//async 1 stop bit 8bit char no parity bits\n}\nvoid smsg(const char * str){\n  while(*str != 0) {\n    while (!(UCSR0A & (1 << UDRE0)));\n    UDR0 = *str; str++;\n  }\n}\n\nvoid StringPgm(const char * str){\n  do{\n      while (!(UCSR0A & (1 << UDRE0)));//wait for byte to transmit\n      UDR0 = pgm_read_byte_near(str);\n      while (!(UCSR0A & (1 << UDRE0)));//wait for byte to transmit\n  } while (pgm_read_byte_near(++str));\n}\n\nstatic void captureImg(uint16_t wg, uint16_t hg){\n  uint16_t y, x;\n\n  //StringPgm(PSTR(\"*RDY*\"));\n\n  while (!(PIND & 8));//wait for high\n  while ((PIND & 8));//wait for low\n  UDR0 = 0xff; // Start Mark\n\n  y = hg;\n  while (y--){\n        x = wg;\n      //while (!(PIND & 256));//wait for high\n    while (x--){\n      while ((PIND & 4));//wait for low\n        while (!(UCSR0A & (1 << UDRE0)));//wait for byte to transmit\n        UDR0 = (PINC & 15) | (PIND & 240);\n      while (!(PIND & 4));//wait for high\n      while ((PIND & 4));//wait for low\n      while (!(PIND & 4));//wait for high\n    }\n    //  while ((PIND & 256));//wait for low\n  }\n  for( x=0; x<8; x++){ // End Mark\n    while (!(UCSR0A & (1 << UDRE0)));//wait for byte to transmit\n      UDR0 = 0; //(PINC & 15) | (PIND & 240);\n  }\n    _delay_ms(100);\n}\n\nvoid setup(){\n  arduinoUnoInut();\n  camInit();\n  setRes();\n  setColor();\n  wrReg(0x11, 11); //Earlier it had the value: wrReg(0x11, 12); New version works better for me :) !!!!\n}\n\nvoid loop(){\n  captureImg(320, 240);\n}\n\n```\n\n\uff13\uff0e\u753b\u50cf\u30c7\u30fc\u30bf\n\u3000\u753b\u50cf\u306f\u4e0b\u8a18\u69cb\u6210\u306e\u30c7\u30fc\u30bf\u304c\u5468\u671f\u7684\u306b\u30b7\u30ea\u30a2\u30eb\u306b\u9001\u4fe1\u3055\u308c\u307e\u3059\u3002\n\u3000\u30c7\u30fc\u30bf\u30d5\u30a9\u30fc\u30de\u30c3\u30c8\u304c\u5148\u4f8b\u3068\u306f\u7570\u306a\u308a\u307e\u3059\u306e\u3067\u3001\u5148\u4f8b\u306b\u8a18\u8f09\u306e\u753b\u50cf\u8868\u793a\u30bd\u30d5\u30c8\u306f\u4f7f\u3048\u307e\u305b\u3093\u3002\n\u3000\u3053\u3061\u3089\u306b\u8a18\u8f09\u3057\u307e\u3057\u305f\u306e\u3067\u3001\u4f75\u305b\u3066\u304a\u8aad\u307f\u304f\u3060\u3055\u3044\u3002\n\u3000[\uff3b\u305d\u306e\uff12\u3000\u753b\u50cf\u306e\u8868\u793a\uff3d](http://qiita.com/hi631/items/94fa041a13714377332f)\n\n\u3000(1)\u901a\u4fe1\u5f62\u5f0f\n\u3000\u3000\u30b7\u30ea\u30a2\u30eb\u901a\u4fe1\u30001Mbps 8bit 1stop NOPARITY \n\u3000\u3000\u30d5\u30a9\u30fc\u30de\u30c3\u30c8\n\u3000\u3000\u3000\u30d8\u30c3\u30c0\u30fc\u30000xff\n\u3000\u3000\u3000\u30c7\u30fc\u30bf\u672c\u4f53\u3000320 x 240 (\u30d0\u30a4\u30c8)\u3000\u203bQVGA\n\u3000\u3000\u3000\u30d5\u30c3\u30bf\u30fc\u3000\u30000x00 x 8 (\u30d0\u30a4\u30c8)\n\u3000(2)\u64ae\u5f71\u4f8b\n![image4.jpg](https://qiita-image-store.s3.amazonaws.com/0/159764/5c8227d5-18a0-0e84-0f78-abf0f3b110c2.jpeg)\n\u3000\u203b\u660e\u308b\u3055(AEC)\u304c\u5b89\u5b9a\u3059\u308b\u307e\u3067\u3001\u6570\u30d5\u30ec\u30fc\u30e0\u304b\u304b\u308a\u307e\u3059\u3002\n## \u3068\u308a\u3042\u3048\u305a\u306e\u8a55\u4fa1\n\u3000(1)Arduino(uno)\u3067\u3082\u753b\u50cf\u51e6\u7406\u306f\u4e00\u5fdc\u53ef\u80fd\u304b\u306a\u3002\n\u3000(2)\u4f46\u3057\u3001\u753b\u50cf\u53d6\u5f97\u306b\u6642\u9593\u304c\u304b\u304b\u308b\u306e\u3067\u3001\u52d5\u304d\u306e\u6709\u308b\u753b\u50cf\u306f\u3076\u308c\u308b\u3002\n\n## \u305d\u306e\u4ed6\n\u3000\u4e0a\u8a18\u8a18\u8f09\u306e\u30cf\u30fc\u30c9\u3001\u30bd\u30d5\u30c8\u306f\u7121\u4fdd\u8a3c\u3067\u3042\u308a\u3001\u5404\u81ea\u306e\u8cac\u4efb\u306b\u304a\u3044\u3066\u3054\u5229\u7528\u9858\u3044\u307e\u3059\u3002\n\n\n"}