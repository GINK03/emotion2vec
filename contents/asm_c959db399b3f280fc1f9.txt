{"context": "\n\nbefore_session hook failed: ArgumentError: invalid byte sequence in Windows-31J\n\u3053\u308c\u306b\u30a4\u30e9\u3063\u3068\u304d\u305f\u4eba\u306f\u5c11\u306a\u304f\u306a\u3044\u7b48\n\u975eWindows\u74b0\u5883\u306a\u3089\u3070\u3001UTF-8\u3067\u7d71\u4e00\u3059\u308c\u3070\u5927\u5206\u6e1b\u308b\u306f\u305a\u3067\u3059\u304c\n\n\u4e8b\u306e\u767a\u7aef\nbinding.pry \u306e\u76f4\u524d\u306b\u65e5\u672c\u8a9e\u30b3\u30e1\u30f3\u30c8\u304c\u5165\u3063\u3066\u3066\u8868\u793a\u3067\u304d\u306a\u304b\u3063\u305f\n\u4f55\u5ea6\u3082\u3053\u306e\u554f\u984c(default_external \u3068\u5225\u30a8\u30f3\u30b3\u30fc\u30c9\u306e\u30d5\u30a1\u30a4\u30eb\u306e\u8aad\u307f\u8fbc\u307f\u306b\u5931\u6557\u3059\u308b)\u306b\u76f4\u9762\u3057\u3066\n\u6b63\u76f4\u75b2\u308c\u305f\u306e\u3067\u3001\u3044\u3063\u305d\u30cf\u30c3\u30af\u3057\u3066\u3057\u307e\u304a\u3046\n\n\u5bfe\u7b56\n\n.pryrc\nrequire 'nkf'\n# Fix IO\nmodule IO_NKF\n  def read(path, length = nil, offset = 0, opts = {})\n    keys = opts.keys\n    return super unless (keys & %i[encoding external_encoding binmode]).empty?\n    return super if keys.include?(:mode) && opts[:mode].include?(':')\n    NKF_read path, length, offset, opts\n  end\n\n  def NKF_read(path, length = nil, offset = 0, opts = {})\n    len = length || 1024\n    enc = NKF_guess path, [1024, len].min, offset\n    read path, length, offset, NKF_opts(enc, opts)\n  end\n\n  def readlines(path, rs, limit, opts={})\n    keys = opts.keys\n    return super unless (keys & %i[encoding external_encoding binmode]).empty?\n    return super if keys.include?(:mode) && opts[:mode].include?(':')\n    NKF_readlines(path, rs, limit, opts)\n  end\n\n  def readlines(path, rs = $/, opts = {})\n    keys = opts.keys\n    return super unless (keys & %i[encoding external_encoding binmode]).empty?\n    return super if keys.include?(:mode) && opts[:mode].include?(':')\n    NKF_readlines(path, rs, opts)\n  end\n\n  def NKF_readlines(path, rs, limit, opts)\n    bin = binread(path, [1024, limit].min)\n    encode = NKF.guess bin\n    readlines path, rs, limit, NKF_opts(encode, opts)\n  end\n\n  def NKF_readlines(path, rs = $/, opts = {})\n    enc = NKF_guess path\n    readlines path, rs, NKF_opts(enc, opts)\n  end\n\n  def NKF_guess(path, limit = 1024, offset = 0)\n    encode = NKF.guess binread(path, limit, offset)\n    case encode\n    when NKF::JIS then nil\n    when NKF::EUC then Encoding::EUCJP\n    when NKF::SJIS then Encoding::CP932\n    when NKF::UNKNOWN then nil\n    when NKF::UTF8 then Encoding::UTF_8\n    when NKF::UTF16 then Encoding::UTF_16\n    end\n  end\n\n  def NKF_opts(enc, opts = {})\n    opts.dup.tap{|o|\n      o[:external_encoding] = enc\n    }\n  end\nend\n\n# \u30af\u30e9\u30b9\u30e1\u30bd\u30c3\u30c9\u3092prepend\u3059\u308b\u65b9\u6cd5\u3063\u3066\u3053\u308c\u3067\u3044\u3044\u306e\u304b\u306a\nIO.singleton_class.class_eval { self.prepend(IO_NKF) }\nEncoding.default_internal ||= Encoding::UTF_8\n\n\n\u30b3\u30ec\u3092pryrc\u306b\u4ed5\u8fbc\u3081\u3070\u3001\u30b3\u30fc\u30c9\u306e\u6587\u5b57\u30b3\u30fc\u30c9\u306b\u5de6\u53f3\u3055\u308c\u306b\u304f\u304f\u306a\u308a\u307e\u3059\n\u5f8c\u3067Gem\u5316\u3057\u3066\u307f\u308b\u304b\u3082\n\n\u65e2\u77e5\u306e\u554f\u984c\u70b9\n\nJIS\u3068\u5224\u5225\u3055\u308c\u305f\u5834\u5408\u3069\u3046\u3059\u308a\u3083\u3044\u3044\u3093\u3060\u308d\u3046\nBOM \u975e\u5bfe\u5fdc\nUTF32 \u975e\u5bfe\u5fdc\n\n\n\u6700\u5f8c\u306b\nFile.read(path) \u3092\u5916\u90e8\u30d5\u30a1\u30a4\u30eb\u306e\u8aad\u307f\u8fbc\u307f\u306b\u4f7f\u3063\u3066\u308b\u4eba\u306f\u7206\u767a\u3057\u308d\u30a8\u30f3\u30b3\u30fc\u30c7\u30a3\u30f3\u30b0\u3092\u8a2d\u5b9a\u3059\u308b\u5fc5\u8981\u304c\u306a\u3044\u306e\u304b\u304d\u3061\u3093\u3068\u8003\u3048\u3066\u304f\u3060\u3055\u3044\n# before_session hook failed: ArgumentError: invalid byte sequence in Windows-31J\n\n\u3053\u308c\u306b\u30a4\u30e9\u3063\u3068\u304d\u305f\u4eba\u306f\u5c11\u306a\u304f\u306a\u3044\u7b48\n\u975eWindows\u74b0\u5883\u306a\u3089\u3070\u3001UTF-8\u3067\u7d71\u4e00\u3059\u308c\u3070\u5927\u5206\u6e1b\u308b\u306f\u305a\u3067\u3059\u304c\n\n## \u4e8b\u306e\u767a\u7aef\nbinding.pry \u306e\u76f4\u524d\u306b\u65e5\u672c\u8a9e\u30b3\u30e1\u30f3\u30c8\u304c\u5165\u3063\u3066\u3066\u8868\u793a\u3067\u304d\u306a\u304b\u3063\u305f\n\u4f55\u5ea6\u3082\u3053\u306e\u554f\u984c(default_external \u3068\u5225\u30a8\u30f3\u30b3\u30fc\u30c9\u306e\u30d5\u30a1\u30a4\u30eb\u306e\u8aad\u307f\u8fbc\u307f\u306b\u5931\u6557\u3059\u308b)\u306b\u76f4\u9762\u3057\u3066\n\u6b63\u76f4\u75b2\u308c\u305f\u306e\u3067\u3001\u3044\u3063\u305d\u30cf\u30c3\u30af\u3057\u3066\u3057\u307e\u304a\u3046\n\n# \u5bfe\u7b56\n\n```rb:.pryrc\nrequire 'nkf'\n# Fix IO\nmodule IO_NKF\n  def read(path, length = nil, offset = 0, opts = {})\n    keys = opts.keys\n    return super unless (keys & %i[encoding external_encoding binmode]).empty?\n    return super if keys.include?(:mode) && opts[:mode].include?(':')\n    NKF_read path, length, offset, opts\n  end\n\n  def NKF_read(path, length = nil, offset = 0, opts = {})\n    len = length || 1024\n    enc = NKF_guess path, [1024, len].min, offset\n    read path, length, offset, NKF_opts(enc, opts)\n  end\n\n  def readlines(path, rs, limit, opts={})\n    keys = opts.keys\n    return super unless (keys & %i[encoding external_encoding binmode]).empty?\n    return super if keys.include?(:mode) && opts[:mode].include?(':')\n    NKF_readlines(path, rs, limit, opts)\n  end\n\n  def readlines(path, rs = $/, opts = {})\n    keys = opts.keys\n    return super unless (keys & %i[encoding external_encoding binmode]).empty?\n    return super if keys.include?(:mode) && opts[:mode].include?(':')\n    NKF_readlines(path, rs, opts)\n  end\n\n  def NKF_readlines(path, rs, limit, opts)\n    bin = binread(path, [1024, limit].min)\n    encode = NKF.guess bin\n    readlines path, rs, limit, NKF_opts(encode, opts)\n  end\n\n  def NKF_readlines(path, rs = $/, opts = {})\n    enc = NKF_guess path\n    readlines path, rs, NKF_opts(enc, opts)\n  end\n\n  def NKF_guess(path, limit = 1024, offset = 0)\n    encode = NKF.guess binread(path, limit, offset)\n    case encode\n    when NKF::JIS then nil\n    when NKF::EUC then Encoding::EUCJP\n    when NKF::SJIS then Encoding::CP932\n    when NKF::UNKNOWN then nil\n    when NKF::UTF8 then Encoding::UTF_8\n    when NKF::UTF16 then Encoding::UTF_16\n    end\n  end\n\n  def NKF_opts(enc, opts = {})\n    opts.dup.tap{|o|\n      o[:external_encoding] = enc\n    }\n  end\nend\n\n# \u30af\u30e9\u30b9\u30e1\u30bd\u30c3\u30c9\u3092prepend\u3059\u308b\u65b9\u6cd5\u3063\u3066\u3053\u308c\u3067\u3044\u3044\u306e\u304b\u306a\nIO.singleton_class.class_eval { self.prepend(IO_NKF) }\nEncoding.default_internal ||= Encoding::UTF_8\n```\n\n\u30b3\u30ec\u3092pryrc\u306b\u4ed5\u8fbc\u3081\u3070\u3001\u30b3\u30fc\u30c9\u306e\u6587\u5b57\u30b3\u30fc\u30c9\u306b\u5de6\u53f3\u3055\u308c\u306b\u304f\u304f\u306a\u308a\u307e\u3059\n\n\u5f8c\u3067Gem\u5316\u3057\u3066\u307f\u308b\u304b\u3082\n\n# \u65e2\u77e5\u306e\u554f\u984c\u70b9\n- JIS\u3068\u5224\u5225\u3055\u308c\u305f\u5834\u5408\u3069\u3046\u3059\u308a\u3083\u3044\u3044\u3093\u3060\u308d\u3046\n- BOM \u975e\u5bfe\u5fdc\n- UTF32 \u975e\u5bfe\u5fdc\n\n# \u6700\u5f8c\u306b\nFile.read(path) \u3092\u5916\u90e8\u30d5\u30a1\u30a4\u30eb\u306e\u8aad\u307f\u8fbc\u307f\u306b\u4f7f\u3063\u3066\u308b\u4eba\u306f~~\u7206\u767a\u3057\u308d~~\u30a8\u30f3\u30b3\u30fc\u30c7\u30a3\u30f3\u30b0\u3092\u8a2d\u5b9a\u3059\u308b\u5fc5\u8981\u304c\u306a\u3044\u306e\u304b\u304d\u3061\u3093\u3068\u8003\u3048\u3066\u304f\u3060\u3055\u3044\n", "tags": ["Ruby", "pry"]}