{"tags": ["common-lisp", "lisp"], "context": " \u3053\u306e\u8a18\u4e8b\u306f\u6700\u7d42\u66f4\u65b0\u65e5\u304b\u30891\u5e74\u4ee5\u4e0a\u304c\u7d4c\u904e\u3057\u3066\u3044\u307e\u3059\u3002(ql:quickload :bordeaux-threads)\n(ql:quickload :alexandria)\n(ql:quickload :iterate)\n(ql:quickload :cl-syntax-annot)\n\n(defpackage :thread-based-continuation\n  (:use :cl :bordeaux-threads :alexandria\n        :iterate\n        :cl-syntax))\n\n(in-package :thread-based-continuation)\n(use-syntax :annot)\n\n(defun permutations (n)\n  (let (acc)\n    (map-permutations\n     (lambda (permutation)\n       (push permutation acc))\n     (iota n))\n    acc))\n\n;; get all possible permutations, one by one\n\n(permutations 5)\n\n;; e.g.\n\n;; ((2 1 4 3 0) (1 2 4 3 0) (4 2 1 3 0) (2 4 1 3 0) (1 4 2 3 0) (4 1 2 3 0)\n;;  (3 1 4 2 0) (1 3 4 2 0) (4 3 1 2 0) (3 4 1 2 0) (1 4 3 2 0) (4 1 3 2 0)\n;;  (3 2 4 1 0) (2 3 4 1 0) (4 3 2 1 0) (3 4 2 1 0) (2 4 3 1 0) (4 2 3 1 0)\n;;  (3 2 1 4 0) (2 3 1 4 0) (1 3 2 4 0) (3 1 2 4 0) (2 1 3 4 0) (1 2 3 4 0)\n;;  (3 2 0 4 1) (2 3 0 4 1) (0 3 2 4 1) (3 0 2 4 1) (2 0 3 4 1) (0 2 3 4 1)\n;;  (4 2 0 3 1) (2 4 0 3 1) (0 4 2 3 1) (4 0 2 3 1) (2 0 4 3 1) (0 2 4 3 1)\n;;  (4 3 0 2 1) (3 4 0 2 1) (0 4 3 2 1) (4 0 3 2 1) (3 0 4 2 1) (0 3 4 2 1)\n;;  (4 3 2 0 1) (3 4 2 0 1) (2 4 3 0 1) (4 2 3 0 1) (3 2 4 0 1) (2 3 4 0 1)\n;;  (4 3 1 0 2) (3 4 1 0 2) (1 4 3 0 2) (4 1 3 0 2) (3 1 4 0 2) (1 3 4 0 2)\n;;  (0 3 1 4 2) (3 0 1 4 2) (1 0 3 4 2) (0 1 3 4 2) (3 1 0 4 2) (1 3 0 4 2)\n;;  (0 4 1 3 2) (4 0 1 3 2) (1 0 4 3 2) (0 1 4 3 2) (4 1 0 3 2) (1 4 0 3 2)\n;;  (0 4 3 1 2) (4 0 3 1 2) (3 0 4 1 2) (0 3 4 1 2) (4 3 0 1 2) (3 4 0 1 2)\n;;  (0 4 2 1 3) (4 0 2 1 3) (2 0 4 1 3) (0 2 4 1 3) (4 2 0 1 3) (2 4 0 1 3)\n;;  (1 4 2 0 3) (4 1 2 0 3) (2 1 4 0 3) (1 2 4 0 3) (4 2 1 0 3) (2 4 1 0 3)\n;;  (1 0 2 4 3) (0 1 2 4 3) (2 1 0 4 3) (1 2 0 4 3) (0 2 1 4 3) (2 0 1 4 3)\n;;  (1 0 4 2 3) (0 1 4 2 3) (4 1 0 2 3) (1 4 0 2 3) (0 4 1 2 3) (4 0 1 2 3)\n;;  (1 0 3 2 4) (0 1 3 2 4) (3 1 0 2 4) (1 3 0 2 4) (0 3 1 2 4) (3 0 1 2 4)\n;;  (2 0 3 1 4) (0 2 3 1 4) (3 2 0 1 4) (2 3 0 1 4) (0 3 2 1 4) (3 0 2 1 4)\n;;  (2 1 3 0 4) (1 2 3 0 4) (3 2 1 0 4) (2 3 1 0 4) (1 3 2 0 4) (3 1 2 0 4)\n;;  (2 1 0 3 4) (1 2 0 3 4) (0 2 1 3 4) (2 0 1 3 4) (1 0 2 3 4) (0 1 2 3 4))\n\n;; (permutations 10) ;; memory bloat !!!\n\n;; countermeasure\n\n@export\n(defun force (thunk)\n  (if (functionp thunk)\n      (funcall thunk)\n      thunk))\n\n@export\n(defmacro forcef (place)\n  (multiple-value-bind (vars vals store-vars writer reader)\n      (get-setf-expansion place)\n    @ignorable reader\n    `(let* (,@(iter (for var in vars)\n                    (for val in vals)\n                    (collect `(,var ,val)))\n            (,(car store-vars) (force ,reader)))\n       ,writer)))\n\n@export\n(defmacro lcons (a b)\n  \"cons whose car and cdr is lazy\"\n  `(cons (lambda () ,a)\n         (lambda () ,b)))\n\n(defmacro define-forced (name accessor &rest args)\n  `(defun ,name ,args\n     (forcef (,accessor ,@args))))\n\n(defmacro define-forced-many (&rest args-list)\n  `(progn\n     ,@(iter (for args in args-list)\n             (for forced = (symbolicate 'f (car args)))\n             (collect `(progn (export ',forced)\n                              (define-forced ,forced ,@args))))))\n\n(define-forced-many\n  (cdr lcons)\n  (car lcons)\n  (cddr lcons)\n  (cdddr lcons)\n  (cddddr lcons)\n  (caar lcons)\n  (caaar lcons)\n  (caaaar lcons)\n  (cadr lcons)\n  (cdar lcons)\n  (first lcons)\n  (second lcons)\n  (third lcons)\n  (fourth lcons)\n  (fifth lcons))\n\n\n@export\n(defmacro fpop (place)\n  (multiple-value-bind (vars vals store-vars writer reader)\n      (get-setf-expansion place)\n    @ignorable reader writer\n    (with-gensyms (list-head car)\n      `(let* (,@(mapcar #'list vars vals)\n              (,list-head ,reader))\n         (when ,list-head\n           (let* ((,car (fcar ,list-head))\n                  (,(car store-vars) (fcdr ,list-head))\n                  ,@(cdr store-vars))\n             ,writer\n             ,car))))))\n\n;; lazy eval + thread-based async continuation\n\n(defun permutations2 (n)\n  (let ((caller-cv (make-condition-variable :name \"caller\"))\n        (caller-lock (make-lock \"caller\"))\n        (callee-cv (make-condition-variable :name \"callee\"))\n        (callee-lock (make-lock \"callee\"))\n        (channel nil))\n    ;; I guess this thread should be properly destroyed when GC runs,\n    ;; with the aid of trivial-garbage or some kind.\n    ;; Otherwise it will cause the memory leakage\n    ;; (because there may be many waiting threads)\n    (make-thread\n     (lambda ()\n       (with-lock-held (caller-lock)\n         (map-permutations\n          (lambda (permutation)\n            (condition-wait caller-cv caller-lock)\n            (setf channel permutation)\n            (condition-notify callee-cv))\n          (iota n))))\n     :name \"callee\")\n    (labels ((rec ()\n               (lcons (with-lock-held (callee-lock)\n                        (condition-notify caller-cv)\n                        (condition-wait callee-cv callee-lock)\n                        channel)\n                      (rec))))\n      (rec))))\n\n(permutations2 10)\n\n;; (#<CLOSURE (LAMBDA # :IN PERMUTATIONS2) {1008B3A7FB}>\n;;  . #<CLOSURE (LAMBDA # :IN PERMUTATIONS2) {1008B3A82B}>)\n\n(defvar lazy-list *)\n\n;; THREAD-BASED-CONTINUATION> (fpop lazy-list)\n;; (0 1 2 3 4 5 6 7 8 9)\n;; THREAD-BASED-CONTINUATION> (fpop lazy-list)\n;; (1 0 2 3 4 5 6 7 8 9)\n;; THREAD-BASED-CONTINUATION> (fpop lazy-list)\n;; (2 0 1 3 4 5 6 7 8 9)\n;; THREAD-BASED-CONTINUATION> (fpop lazy-list)\n;; (0 2 1 3 4 5 6 7 8 9)\n;; THREAD-BASED-CONTINUATION> (fpop lazy-list)\n;; (1 2 0 3 4 5 6 7 8 9)\n;; THREAD-BASED-CONTINUATION> (fpop lazy-list)\n;; (2 1 0 3 4 5 6 7 8 9)\n;; THREAD-BASED-CONTINUATION> (fpop lazy-list)\n;; (3 1 2 0 4 5 6 7 8 9)\n\n\u304a\u307e\u3051\n@export\n(defmacro llist (a &rest args)\n  \"list using lcons\"\n  `(lcons ,a ,(when args `(llist ,@args))))\n\n@export\n(defmacro ltree (tree)\n  (if (consp tree)\n      `(llist ,@(mapcar (lambda (e) `(ltree ,e)) tree))\n      tree))\n\n\n\n```cl\n(ql:quickload :bordeaux-threads)\n(ql:quickload :alexandria)\n(ql:quickload :iterate)\n(ql:quickload :cl-syntax-annot)\n\n(defpackage :thread-based-continuation\n  (:use :cl :bordeaux-threads :alexandria\n        :iterate\n        :cl-syntax))\n\n(in-package :thread-based-continuation)\n(use-syntax :annot)\n\n(defun permutations (n)\n  (let (acc)\n    (map-permutations\n     (lambda (permutation)\n       (push permutation acc))\n     (iota n))\n    acc))\n\n;; get all possible permutations, one by one\n\n(permutations 5)\n\n;; e.g.\n\n;; ((2 1 4 3 0) (1 2 4 3 0) (4 2 1 3 0) (2 4 1 3 0) (1 4 2 3 0) (4 1 2 3 0)\n;;  (3 1 4 2 0) (1 3 4 2 0) (4 3 1 2 0) (3 4 1 2 0) (1 4 3 2 0) (4 1 3 2 0)\n;;  (3 2 4 1 0) (2 3 4 1 0) (4 3 2 1 0) (3 4 2 1 0) (2 4 3 1 0) (4 2 3 1 0)\n;;  (3 2 1 4 0) (2 3 1 4 0) (1 3 2 4 0) (3 1 2 4 0) (2 1 3 4 0) (1 2 3 4 0)\n;;  (3 2 0 4 1) (2 3 0 4 1) (0 3 2 4 1) (3 0 2 4 1) (2 0 3 4 1) (0 2 3 4 1)\n;;  (4 2 0 3 1) (2 4 0 3 1) (0 4 2 3 1) (4 0 2 3 1) (2 0 4 3 1) (0 2 4 3 1)\n;;  (4 3 0 2 1) (3 4 0 2 1) (0 4 3 2 1) (4 0 3 2 1) (3 0 4 2 1) (0 3 4 2 1)\n;;  (4 3 2 0 1) (3 4 2 0 1) (2 4 3 0 1) (4 2 3 0 1) (3 2 4 0 1) (2 3 4 0 1)\n;;  (4 3 1 0 2) (3 4 1 0 2) (1 4 3 0 2) (4 1 3 0 2) (3 1 4 0 2) (1 3 4 0 2)\n;;  (0 3 1 4 2) (3 0 1 4 2) (1 0 3 4 2) (0 1 3 4 2) (3 1 0 4 2) (1 3 0 4 2)\n;;  (0 4 1 3 2) (4 0 1 3 2) (1 0 4 3 2) (0 1 4 3 2) (4 1 0 3 2) (1 4 0 3 2)\n;;  (0 4 3 1 2) (4 0 3 1 2) (3 0 4 1 2) (0 3 4 1 2) (4 3 0 1 2) (3 4 0 1 2)\n;;  (0 4 2 1 3) (4 0 2 1 3) (2 0 4 1 3) (0 2 4 1 3) (4 2 0 1 3) (2 4 0 1 3)\n;;  (1 4 2 0 3) (4 1 2 0 3) (2 1 4 0 3) (1 2 4 0 3) (4 2 1 0 3) (2 4 1 0 3)\n;;  (1 0 2 4 3) (0 1 2 4 3) (2 1 0 4 3) (1 2 0 4 3) (0 2 1 4 3) (2 0 1 4 3)\n;;  (1 0 4 2 3) (0 1 4 2 3) (4 1 0 2 3) (1 4 0 2 3) (0 4 1 2 3) (4 0 1 2 3)\n;;  (1 0 3 2 4) (0 1 3 2 4) (3 1 0 2 4) (1 3 0 2 4) (0 3 1 2 4) (3 0 1 2 4)\n;;  (2 0 3 1 4) (0 2 3 1 4) (3 2 0 1 4) (2 3 0 1 4) (0 3 2 1 4) (3 0 2 1 4)\n;;  (2 1 3 0 4) (1 2 3 0 4) (3 2 1 0 4) (2 3 1 0 4) (1 3 2 0 4) (3 1 2 0 4)\n;;  (2 1 0 3 4) (1 2 0 3 4) (0 2 1 3 4) (2 0 1 3 4) (1 0 2 3 4) (0 1 2 3 4))\n\n;; (permutations 10) ;; memory bloat !!!\n\n;; countermeasure\n\n@export\n(defun force (thunk)\n  (if (functionp thunk)\n      (funcall thunk)\n      thunk))\n\n@export\n(defmacro forcef (place)\n  (multiple-value-bind (vars vals store-vars writer reader)\n      (get-setf-expansion place)\n    @ignorable reader\n    `(let* (,@(iter (for var in vars)\n                    (for val in vals)\n                    (collect `(,var ,val)))\n            (,(car store-vars) (force ,reader)))\n       ,writer)))\n\n@export\n(defmacro lcons (a b)\n  \"cons whose car and cdr is lazy\"\n  `(cons (lambda () ,a)\n         (lambda () ,b)))\n\n(defmacro define-forced (name accessor &rest args)\n  `(defun ,name ,args\n     (forcef (,accessor ,@args))))\n\n(defmacro define-forced-many (&rest args-list)\n  `(progn\n     ,@(iter (for args in args-list)\n             (for forced = (symbolicate 'f (car args)))\n             (collect `(progn (export ',forced)\n                              (define-forced ,forced ,@args))))))\n\n(define-forced-many\n  (cdr lcons)\n  (car lcons)\n  (cddr lcons)\n  (cdddr lcons)\n  (cddddr lcons)\n  (caar lcons)\n  (caaar lcons)\n  (caaaar lcons)\n  (cadr lcons)\n  (cdar lcons)\n  (first lcons)\n  (second lcons)\n  (third lcons)\n  (fourth lcons)\n  (fifth lcons))\n\n\n@export\n(defmacro fpop (place)\n  (multiple-value-bind (vars vals store-vars writer reader)\n      (get-setf-expansion place)\n    @ignorable reader writer\n    (with-gensyms (list-head car)\n      `(let* (,@(mapcar #'list vars vals)\n              (,list-head ,reader))\n         (when ,list-head\n           (let* ((,car (fcar ,list-head))\n                  (,(car store-vars) (fcdr ,list-head))\n                  ,@(cdr store-vars))\n             ,writer\n             ,car))))))\n\n;; lazy eval + thread-based async continuation\n\n(defun permutations2 (n)\n  (let ((caller-cv (make-condition-variable :name \"caller\"))\n        (caller-lock (make-lock \"caller\"))\n        (callee-cv (make-condition-variable :name \"callee\"))\n        (callee-lock (make-lock \"callee\"))\n        (channel nil))\n    ;; I guess this thread should be properly destroyed when GC runs,\n    ;; with the aid of trivial-garbage or some kind.\n    ;; Otherwise it will cause the memory leakage\n    ;; (because there may be many waiting threads)\n    (make-thread\n     (lambda ()\n       (with-lock-held (caller-lock)\n         (map-permutations\n          (lambda (permutation)\n            (condition-wait caller-cv caller-lock)\n            (setf channel permutation)\n            (condition-notify callee-cv))\n          (iota n))))\n     :name \"callee\")\n    (labels ((rec ()\n               (lcons (with-lock-held (callee-lock)\n                        (condition-notify caller-cv)\n                        (condition-wait callee-cv callee-lock)\n                        channel)\n                      (rec))))\n      (rec))))\n\n(permutations2 10)\n\n;; (#<CLOSURE (LAMBDA # :IN PERMUTATIONS2) {1008B3A7FB}>\n;;  . #<CLOSURE (LAMBDA # :IN PERMUTATIONS2) {1008B3A82B}>)\n\n(defvar lazy-list *)\n\n;; THREAD-BASED-CONTINUATION> (fpop lazy-list)\n;; (0 1 2 3 4 5 6 7 8 9)\n;; THREAD-BASED-CONTINUATION> (fpop lazy-list)\n;; (1 0 2 3 4 5 6 7 8 9)\n;; THREAD-BASED-CONTINUATION> (fpop lazy-list)\n;; (2 0 1 3 4 5 6 7 8 9)\n;; THREAD-BASED-CONTINUATION> (fpop lazy-list)\n;; (0 2 1 3 4 5 6 7 8 9)\n;; THREAD-BASED-CONTINUATION> (fpop lazy-list)\n;; (1 2 0 3 4 5 6 7 8 9)\n;; THREAD-BASED-CONTINUATION> (fpop lazy-list)\n;; (2 1 0 3 4 5 6 7 8 9)\n;; THREAD-BASED-CONTINUATION> (fpop lazy-list)\n;; (3 1 2 0 4 5 6 7 8 9)\n```\n\n\u304a\u307e\u3051\n\n```cl\n@export\n(defmacro llist (a &rest args)\n  \"list using lcons\"\n  `(lcons ,a ,(when args `(llist ,@args))))\n\n@export\n(defmacro ltree (tree)\n  (if (consp tree)\n      `(llist ,@(mapcar (lambda (e) `(ltree ,e)) tree))\n      tree))\n```\n\n"}