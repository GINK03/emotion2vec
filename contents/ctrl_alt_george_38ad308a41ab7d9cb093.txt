{"context": " More than 1 year has passed since last update.\n\namb\namb\u306f\u975e\u6c7a\u5b9a\u6027\u8a08\u7b97\u3092\u3057\u3066\u304f\u308c\u308b\u30ab\u30c3\u30b3\u30a4\u30a4\u30aa\u30da\u30ec\u30fc\u30bf\u3067\u3042\u308b\u3002\nRosetta Code\u306b\u3042\u308bAmb\u306e\u4f8b\u984c\u3092\u524d\u56de\u306e\u9650\u5b9a\u7d99\u7d9a\u3092\u5229\u7528\u3057\u3066\u89e3\u3044\u3066\u307f\u308b\u3002\n\n\u30b3\u30fc\u30c9\nNotUseAmb\u3092define\u3059\u308b\u3068\u4eca\u56de\u7528\u610f\u3057\u305famb\u306e\u4ee3\u308f\u308a\u306b\u30ea\u30b9\u30c8\u30e2\u30ca\u30c9\u3092\u4f7f\u3046\u3002\n\nopen FsControl.Core.Types\nopen FsControl.Core.TypeMethods\nopen FsControl.Core.TypeMethods.Applicative\nopen FsControl.Core.TypeMethods.Monad\n\n//https://github.com/gmpl/FsControl/blob/master/FsControl.Core/Samples/Haskell.fsx\nlet inline return' x = Inline.instance Pure x\nlet inline (>>=) x (f:_->'R) : 'R = Inline.instance (Bind, x) f \ntype DoNotationBuilder() =\n    member inline b.Return(x)    = return' x\n    member inline b.Bind(p,rest) = p >>= rest\n    member        b.Let (p,rest) = rest p\n    member    b.ReturnFrom(expr) = expr\nlet do' = new DoNotationBuilder()\n\n\n#if NotUseAmb\n#else\n\nlet runCont = Cont.run\n\n#endif\n\nlet callCC' = Cont.callCC\nlet inline when'  p s = if p then s else return' ()\nlet inline unless p s = when' (not p) s\n\nlet returnCont :'a->Cont<'b, 'a> = return'\n\n#if NotUseAmb\n\nlet amb (lst:List<_>) = lst\nlet require condition = if condition then [()] else []\nlet reset k = k\nlet runCont a b = b(a)\n\n#else\n\nlet reset e = returnCont <| runCont e id\nlet shift e = Cont <| fun k -> e (returnCont << k) |> runCont <| id\n\nlet amb lst = shift <| fun k -> do'{\n    lst\n    |> List.iter (fun x -> ignore <| do'{\n        do! (k x)\n    })\n    return ()\n}\nlet require condition = shift <| fun k -> do'{\n    if condition then\n        do! k ()\n        return ()\n    else\n        return ()\n}\n\n#endif\n\n[<EntryPoint>]\nlet main argv = \n\n    let isFollowedBy (a: string) (b: string) =\n        a.[a.Length - 1] = b.[0]\n\n    reset <| do'{\n        let! first = amb [\"the\"; \"that\"; \"a\"]\n        //printfn \"a1\"\n        let! second = amb [\"frog\"; \"elephant\"; \"thing\"]\n        //printfn \"a2\"\n        do! require(first |> isFollowedBy <| second)\n        //printfn \"r1\"\n        let! third = amb [\"walked\"; \"treaded\"; \"grows\"]\n        //printfn \"a3\"\n        do! require(second |> isFollowedBy <| third)\n        //printfn \"r2\"\n        let! forth = amb [\"slowly\"; \"quickly\"]\n        //printfn \"a4\"\n        do! require(third |> isFollowedBy <| forth)\n        //printfn \"r3\"\n        printfn \"%A\" (first, second, third, forth)\n        return ()\n    }\n    |> runCont <|\n        fun _ -> printfn \"end\"\n\n    0\n\n\n\n\u3064\u304b\nF#\u3063\u3066#define\u66f8\u3051\u306a\u3044\u306e\u306a^^;\n#amb\namb\u306f\u975e\u6c7a\u5b9a\u6027\u8a08\u7b97\u3092\u3057\u3066\u304f\u308c\u308b\u30ab\u30c3\u30b3\u30a4\u30a4\u30aa\u30da\u30ec\u30fc\u30bf\u3067\u3042\u308b\u3002\n[Rosetta Code\u306b\u3042\u308bAmb\u306e\u4f8b\u984c](http://rosettacode.org/wiki/Amb)\u3092[\u524d\u56de\u306e\u9650\u5b9a\u7d99\u7d9a](http://qiita.com/ctrl_alt_george/items/df35cd3cb16dfe97e09c)\u3092\u5229\u7528\u3057\u3066\u89e3\u3044\u3066\u307f\u308b\u3002\n\n#\u30b3\u30fc\u30c9\nNotUseAmb\u3092define\u3059\u308b\u3068\u4eca\u56de\u7528\u610f\u3057\u305famb\u306e\u4ee3\u308f\u308a\u306b\u30ea\u30b9\u30c8\u30e2\u30ca\u30c9\u3092\u4f7f\u3046\u3002\n\n```fsharp\n\nopen FsControl.Core.Types\nopen FsControl.Core.TypeMethods\nopen FsControl.Core.TypeMethods.Applicative\nopen FsControl.Core.TypeMethods.Monad\n\n//https://github.com/gmpl/FsControl/blob/master/FsControl.Core/Samples/Haskell.fsx\nlet inline return' x = Inline.instance Pure x\nlet inline (>>=) x (f:_->'R) : 'R = Inline.instance (Bind, x) f \ntype DoNotationBuilder() =\n    member inline b.Return(x)    = return' x\n    member inline b.Bind(p,rest) = p >>= rest\n    member        b.Let (p,rest) = rest p\n    member    b.ReturnFrom(expr) = expr\nlet do' = new DoNotationBuilder()\n\n\n#if NotUseAmb\n#else\n\nlet runCont = Cont.run\n\n#endif\n\nlet callCC' = Cont.callCC\nlet inline when'  p s = if p then s else return' ()\nlet inline unless p s = when' (not p) s\n\nlet returnCont :'a->Cont<'b, 'a> = return'\n\n#if NotUseAmb\n\nlet amb (lst:List<_>) = lst\nlet require condition = if condition then [()] else []\nlet reset k = k\nlet runCont a b = b(a)\n\n#else\n\nlet reset e = returnCont <| runCont e id\nlet shift e = Cont <| fun k -> e (returnCont << k) |> runCont <| id\n\nlet amb lst = shift <| fun k -> do'{\n    lst\n    |> List.iter (fun x -> ignore <| do'{\n        do! (k x)\n    })\n    return ()\n}\nlet require condition = shift <| fun k -> do'{\n    if condition then\n        do! k ()\n        return ()\n    else\n        return ()\n}\n\n#endif\n\n[<EntryPoint>]\nlet main argv = \n\n    let isFollowedBy (a: string) (b: string) =\n        a.[a.Length - 1] = b.[0]\n\n    reset <| do'{\n        let! first = amb [\"the\"; \"that\"; \"a\"]\n        //printfn \"a1\"\n        let! second = amb [\"frog\"; \"elephant\"; \"thing\"]\n        //printfn \"a2\"\n        do! require(first |> isFollowedBy <| second)\n        //printfn \"r1\"\n        let! third = amb [\"walked\"; \"treaded\"; \"grows\"]\n        //printfn \"a3\"\n        do! require(second |> isFollowedBy <| third)\n        //printfn \"r2\"\n        let! forth = amb [\"slowly\"; \"quickly\"]\n        //printfn \"a4\"\n        do! require(third |> isFollowedBy <| forth)\n        //printfn \"r3\"\n        printfn \"%A\" (first, second, third, forth)\n        return ()\n    }\n    |> runCont <|\n        fun _ -> printfn \"end\"\n\n    0\n\n```\n\n#\u3064\u304b\nF#\u3063\u3066#define\u66f8\u3051\u306a\u3044\u306e\u306a^^;", "tags": ["F#"]}