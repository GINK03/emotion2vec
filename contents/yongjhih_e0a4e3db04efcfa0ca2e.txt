{"context": " More than 1 year has passed since last update.\n\nNotRetrofit\n\n\n\n\n\n\n\n\nhttps://github.com/yongjhih/NotRetrofit\nNotRetrofit turns your REST API into a Java interface.\nsquare/retrofit is a great project. So, why reinvent the wheel? Retrofit 2 is the first to implement the full stack with generated code. The guiding principle is to generate code that mimics the code that traceable and performant as it can be.\ngoogle/dagger2 has also re-implemented square/dagger.\nNotRetrofit is a compile-time evolution approach to rest api conversion. Taking the approach started in Retrofit 1.x to its ultimate conclusion, NotRetrofit eliminates all reflection, and improves code clarity.\nNotRetrofit has implemented almost retrofit\u2019s features. And bonus:\n\n@RetryHeaders\nGlobal Headers\n@Converter\n\nFor retrofit1 users: Migration.\nAnd here is Live Demo.\n\nUsage\n@Retrofit(\"https://api.github.com\")\npublic abstract class GitHub {\n  @GET(\"/users/{user}/repos\")\n  public abstract List<Repo> repos(@Path(\"user\") String user);\n\n  public static GitHub create() {\n    return new Retrofit_GitHub();\n  }\n}\n\nGitHub github = GitHub.create();\n\nEach call on the generated instance of GitHub makes an HTTP request to the remote webserver.\nList<Repo> repos = github.repos(\"octocat\");\n\nUse annotations to describe the HTTP request:\n\nURL parameter replacement and query parameter support\nObject conversion to request body (e.g., JSON, protocol buffers)\nMultipart request body and file upload\n\n\nAPI Declaration\nAnnotations on the interface methods and its parameters indicate how a request will be handled.\n\nREQUEST METHOD\nEvery method must have an HTTP annotation that provides the request method and relative URL. There are five built-in annotations: GET, POST, PUT, DELETE, and HEAD. The relative URL of the resource is specified in the annotation.\n@GET(\"/users/list\")\n\nYou can also specify query parameters in the URL.\n@GET(\"/users/list?sort=desc\")\n\n\nURL MANIPULATION\nA request URL can be updated dynamically using replacement blocks and parameters on the method. A replacement block is an alphanumeric string surrounded by { and }. A corresponding parameter must be annotated with @Path using the same string.\n@GET(\"/group/{id}/users\")\nabstract Observable<List<User>> groupList(@Path(\"id\") int groupId);\n\nQuery parameters can also be added.\n@GET(\"/group/{id}/users\")\nabstract Observable<List<User>> groupList(@Path(\"id\") int groupId, @Query(\"sort\") String sort);\n\nFor complex query parameter combinations a Map can be used.\n@GET(\"/group/{id}/users\")\nabstract Observable<List<User>> groupList(@Path(\"id\") int groupId, @QueryMap Map<String, String> options);\n\n\nREQUEST BODY\nAn object can be specified for use as an HTTP request body with the @Body annotation.\n@POST(\"/users/new\")\nabstract Observable<User> createUser(@Body User user> cb);\n\nThe object will also be converted using the converter.\n\nFORM ENCODED AND MULTIPART\nMethods can also be declared to send form-encoded and multipart data.\nForm-encoded data is sent when @FormUrlEncoded is present on the method. Each key-value pair is annotated with @Field containing the name and the object providing the value.\n@FormUrlEncoded\n@POST(\"/user/edit\")\nabstract Observable<User> updateUser(@Field(\"first_name\") String first, @Field(\"last_name\") String last);\n\nMultipart requests are used when @Multipart is present on the method. Parts are declared using the @Part annotation.\n@Multipart\n@PUT(\"/user/photo\")\nabstract Observable<User> updateUser(@Part(\"photo\") TypedFile photo, @Part(\"description\") TypedString description);\n\nMultipart parts use the converter. In progress: or they can implement TypedOutput to handle their own serialization.\n\nHEADER MANIPULATION\nYou can set static headers for a method using the @Headers annotation.\n@Headers(\"Cache-Control: max-age=640000\")\n@GET(\"/widget/list\")\nabstract Observable<List<Widget>> widgetList();\n\n@Headers({\n    \"Accept: application/vnd.github.v3.full+json\",\n    \"User-Agent: Retrofit2\"\n})\n@GET(\"/users/{username}\")\nabstract Observable<User> getUser(@Path(\"username\") String username);\n\nNote that headers do not overwrite each other. All headers with the same name will be included in the request.\nA request Header can be updated dynamically using the @Header annotation. A corresponding parameter must be provided to the @Header. If the value is null, the header will be omitted. Otherwise, toString will be called on the value, and the result used.\n@GET(\"/user\")\nObservable<User> getUser(@Header(\"Authorization\") String authorization);\n\n\nGlobal Headers\nHeaders that need to be added to every request can be specified using @Headers on your service. The following code uses @Headers that will add a User-Agent header to every request.\n@Retrofit(\"https://api.github.com\")\n@Headers({\n    \"Accept: application/vnd.github.v3.full+json\",\n    \"User-Agent: Retrofit2\"\n})\nabstract class GitHub {\n    // ..\n}\n\n\nSYNCHRONOUS VS. ASYNCHRONOUS VS. OBSERVABLE\nMethods can be declared for either synchronous or asynchronous execution.\nA method with a return type will be executed synchronously.\n@GET(\"/user/{id}/photo\")\nPhoto getUserPhoto(@Path(\"id\") int id);\n\nAsynchronous execution requires the last parameter of the method be a Callback.\n@GET(\"/user/{id}/photo\")\nvoid getUserPhoto(@Path(\"id\") int id, Callback<Photo> cb);\n\nOn Android, callbacks will be executed on the main thread. For desktop applications callbacks will happen on the same thread that executed the HTTP request.\nRetrofit also integrates RxJava to support methods with a return type of rx.Observable\n@GET(\"/user/{id}/photo\")\nObservable<Photo> getUserPhoto(@Path(\"id\") int id);\n\nObservable requests are subscribed asynchronously and observed on the same thread that executed the HTTP request. To observe on a different thread (e.g. Android's main thread) call observeOn(Scheduler) on the returned Observable.\n\nRESPONSE OBJECT TYPE\nHTTP responses are automatically converted to a specified type using the RestAdapter's converter which defaults to JSON. The desired type is declared as the method return type or using the Callback or Observable.\n@GET(\"/users/list\")\nList<User> userList();\n\n@GET(\"/users/list\")\nvoid userList(Callback<List<User>> cb);\n\n@GET(\"/users/list\")\nObservable<List<User>> userList();\n\nFor access to the raw HTTP response use the Response type.\n@GET(\"/users/list\")\nResponse userList();\n\n@GET(\"/users/list\")\nvoid userList(Callback<Response> cb);\n\n@GET(\"/users/list\")\nObservable<Response> userList();\n\n\nTarget Configuration\nRetrofit\\_TARGET is the class through which your API interfaces are turned into callable objects. By default, Retrofit2 will give you sane defaults for your platform but it allows for customization.\n\nJSON CONVERSION\nRetrofit2 uses LoganSquare by default to convert HTTP bodies to and from JSON. If you want to specify behavior that is different from Gson's defaults (e.g. naming policies, date formats, custom types), provide a new Gson instance with your desired behavior when building a Retrofit_TARGET. Refer to the Gson documentation for more details on customization.\n\nCUSTOM GSON CONVERTER EXAMPLE\nThe following code creates a new Gson instance that will convert all fields from lower case with underscores to camel case and vice versa. It also registers a type adapter for the Date class. This DateTypeAdapter will be used anytime Gson encounters a Date field.\nThe gson instance is passed as a parameter to GsonConverter, which is a wrapper class for converting types.\npublic static class DateGsonConverter extends GsonConverter {\n    public DateGsonConverter() {\n        super(new com.google.gson.GsonBuilder()\n            .setFieldNamingPolicy(com.google.gson.FieldNamingPolicy.LOWER_CASE_WITH_UNDERSCORES)\n            .registerTypeAdapter(java.util.Date.class, new com.google.gson.internal.bind.DateTypeAdapter())\n            .create());\n    }\n}\n\n@Retrofit(\"https://api.github.com\")\n@Converter(DateGsonConverter.class)\nabstract class GitHub {\n    // ..\n}\n\nEach call on the generated GitHub will return objects converted using the Gson implementation provided to the Retrofit_GitHub.\n\nCUSTOM CONVERTER FOR METHOD\nSpecify another converter instance for one of methods by the following code:\n@Retrofit(\"https://api.github.com\")\n@Converter(DateGsonConverter.class)\nabstract class GitHub {\n    @GET(\"/users/{username}\")\n    @Converter(LoganSquareConverter.class)\n    abstract Observable<User> getUser(@Path(\"username\") String username);\n\n    // ..\n}\n\n\nCONTENT FORMAT AGNOSTIC\nIn addition to JSON, Retrofit can be configured to use other content formats. Retrofit provides alternate converters for XML (using Simple) and Protocol Buffers (using protobuf or Wire). Please see the retrofit-converters directory for the full listing of converters.\nThe following code shows how to use SimpleXMLConverter to communicate with an API that uses XML\n@Retrofit(\"https://api.github.com\")\n@Converter(SimpleXMLConverter.class)\nabstract class GitHub {\n    // ..\n}\n\n\nCUSTOM CONVERTERS\nIf you need to communicate with an API that uses a content-format that Retrofit does not support out of the box (e.g. YAML, txt, custom format) or you wish to use a different library to implement an existing format, you can easily create your own converter. Create a class that implements the Converter interface and pass in an instance when building your adapter.\n\nCUSTOM ERROR HANDLING\nIf you need custom error handling for requests, you may provide your own ErrorHandler. The following code shows how to throw a custom exception when a response returns a HTTP 401 status code\n@Retrofit(\"https://api.github.com\")\n@ErrorHandler(MyErrorHandler.class)\nclass GitHub {\n    // ..\n}\n\npublic class MyErrorHandler implements ErrorHandler {\n    @Override public Throwable handleError(RetrofitError cause) {\n        Response r = cause.getResponse();\n        if (r != null && r.getStatus() == 401) {\n            return new RuntimeException(\"401\", cause);\n        }\n        return cause;\n    }\n}\n\nNote that if the return exception is checked, it must be declared on the interface method. It is recommended that you pass the supplied RetrofitError as the cause to any new exceptions you throw.\n\nLOGGING\nIf you need to take a closer look at the requests and responses you can easily add logging levels to the Retrofit_GitHub with the LogLevel property. The possible logging levels are BASIC, FULL, HEADERS, and NONE.\nThe following code shows the addition of a full log level which will log the headers, body, and metadata for both requests and responses.\n@Retrofit(\"https://api.github.com\")\n@LogLevel(LogLevel.FULL)\nabstract class GitHub {\n    // ..\n}\n\n\nSupport @RetryHeaders\n\nExperiment feature\nFor Retry Stale example:\n@Retrofit(\"https://api.github.com\")\n@RetryHeaders(\"Cache-Control: max-age=640000\")\nabstract class GitHub {\n    // ..\n}\n\nRetry the request with cache if network issue.\n\nSupport @RequestInterceptor\n\n@Retrofit(\"https://api.github.com\")\n@RequestInterceptor(MyRequestInterceptor.class)\nabstract class GitHub {\n    // ..\n}\n\n\nMigration\n\nAdd @Retrofit(\"https://api.github.com\") line\nChange interface GitHub to abstract class GitHub\n\nAdd public static GitHub create() { return new Retrofit_GitHub(); }\n\n\nFor example:\n@Retrofit(\"https://api.github.com\") // 1. Add this line\nabstract class GitHub { // 2. Change to abstract class\n  @GET(\"/users/{user}/repos\")\n  List<Repo> listRepos(@Path(\"user\") String user);\n  public static GitHub create() { return new Retrofit_GitHub(); } // 3. Add creator\n}\n\nGithub github = GitHub.create();\n\nAnother way:\n@Retrofit(\"https://api.github.com\")\nabstract class GitHubBean implements GitHub {\n  public static GitHub create() { return new Retrofit_GitHub(); }\n}\n\nGithub github = GitHubBean.create();\n\n\nInstallation\nvia jcenter:\nrepositories {\n    jcenter()\n}\n\ndependencies {\n    compile 'com.infstory:retrofit:2.0.0'\n    apt 'com.infstory:retrofit-processor:2.0.0'\n}\n\nor via jitpack (in progress):\nrepositories {\n    jcenter()\n    mavne { url \"https://jitpack.io\" }\n}\n\ndependencies {\n    compile 'com.github.yongjhih.retrofit:retrofit:-SNAPSHOT'\n    apt 'com.github.yongjhih.retrofit:retrofit-processor:-SNAPSHOT'\n}\n\n\nLive Demo\n\nhttps://appetize.io/app/3trwbht63k0rkfmbxbt51h84cr\n\n\nTest\nTest github client:\n./gradlew clean :retrofit2-github:testDebug\n\nAll tests:\n./gradlew clean test\n\nGithub sample app:\n./gradlew clean :retrofit2-github-app:assembleDebug\n\n\nDevelopment\n\nSupport POST, DELTE, PUT: http://www.twitch.tv/yoandrew/v/7918907\n\n\n\nReferences\n\nhttp://square.github.io/retrofit/\nhttps://github.com/square/okhttp/wiki/Recipes\nhttp://square.github.io/okhttp/javadoc/com/squareup/okhttp/RequestBody.html\n\n\nSee Also\n\njw/retrofit-two? https://github.com/JakeWharton/u2020/compare/jw/retrofit-two\n\nsquare/jw/code-gen, 49407dbb19f48072ab5fce8a49f38606ce07bd27, 2013\n\n\nCredit\n\nSquare, Inc.\n\n\nLicense\nCopyright 2013 Square, Inc.\nCopyright 2015 8tory, Inc.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n\n# NotRetrofit\n\n[![Download](https://api.bintray.com/packages/yongjhih/maven/retrofit/images/download.svg)](https://bintray.com/yongjhih/maven/retrofit/_latestVersion)\n[![JitPack](https://img.shields.io/github/tag/yongjhih/retrofit.svg?label=JitPack)](https://jitpack.io/#yongjhih/retrofit)\n[![javadoc](https://img.shields.io/github/tag/yongjhih/retrofit.svg?label=javadoc)](https://jitpack.io/com/github/yongjhih/retrofit/2.0.0/javadoc/index.html)\n[![Build Status](https://travis-ci.org/yongjhih/retrofit.svg)](https://travis-ci.org/yongjhih/retrofit)\n[![Join the chat at https://gitter.im/yongjhih/retrofit](https://badges.gitter.im/Join%20Chat.svg)](https://gitter.im/yongjhih/retrofit?utm_source=badge&utm_medium=badge&utm_campaign=pr-badge&utm_content=badge)\n\n[![](https://github.com/yongjhih/retrofit/raw/master/art/medium-48.jpg)](https://medium.com/@yongjhih/retrofit2-aa2fffd1a3c0)\n\n![NotRetrofit](https://github.com/yongjhih/retrofit/raw/master/art/retrofit2.png)\n\n[![](https://github.com/yongjhih/retrofit/raw/master/art/screenshot-yongjhih.jpg)](https://appetize.io/app/3trwbht63k0rkfmbxbt51h84cr)\n\nhttps://github.com/yongjhih/NotRetrofit\n\nNotRetrofit turns your REST API into a Java interface.\n\nsquare/retrofit is a great project. So, why reinvent the wheel? Retrofit 2 is the first to implement the full stack with generated code. The guiding principle is to generate code that mimics the code that traceable and performant as it can be.\n\ngoogle/dagger2 has also re-implemented square/dagger.\n\nNotRetrofit is a compile-time evolution approach to rest api conversion. Taking the approach started in Retrofit 1.x to its ultimate conclusion, NotRetrofit eliminates all reflection, and improves code clarity.\n\nNotRetrofit has implemented almost retrofit\u2019s features. And bonus:\n\n* [@RetryHeaders](#support-retryheaders)\n* [Global Headers](#global-headers)\n* [@Converter](#custom-converter-for-method)\n\nFor retrofit1 users: [Migration](#migration).\n\nAnd here is [Live Demo](https://appetize.io/app/3trwbht63k0rkfmbxbt51h84cr).\n\n# Usage\n\n```java\n@Retrofit(\"https://api.github.com\")\npublic abstract class GitHub {\n  @GET(\"/users/{user}/repos\")\n  public abstract List<Repo> repos(@Path(\"user\") String user);\n\n  public static GitHub create() {\n    return new Retrofit_GitHub();\n  }\n}\n```\n\n```java\nGitHub github = GitHub.create();\n```\n\nEach call on the generated instance of GitHub makes an HTTP request to the remote webserver.\n\n```java\nList<Repo> repos = github.repos(\"octocat\");\n```\n\nUse annotations to describe the HTTP request:\n\n* URL parameter replacement and query parameter support\n* Object conversion to request body (e.g., JSON, protocol buffers)\n* Multipart request body and file upload\n\n## API Declaration\n\nAnnotations on the interface methods and its parameters indicate how a request will be handled.\n\n## REQUEST METHOD\n\nEvery method must have an HTTP annotation that provides the request method and relative URL. There are five built-in annotations: `GET`, `POST`, `PUT`, `DELETE`, and `HEAD`. The relative URL of the resource is specified in the annotation.\n\n```java\n@GET(\"/users/list\")\n```\n\nYou can also specify query parameters in the URL.\n\n```java\n@GET(\"/users/list?sort=desc\")\n```\n\n## URL MANIPULATION\n\nA request URL can be updated dynamically using replacement blocks and parameters on the method. A replacement block is an alphanumeric string surrounded by `{` and `}`. A corresponding parameter must be annotated with `@Path` using the same string.\n\n```java\n@GET(\"/group/{id}/users\")\nabstract Observable<List<User>> groupList(@Path(\"id\") int groupId);\n```\n\nQuery parameters can also be added.\n\n```java\n@GET(\"/group/{id}/users\")\nabstract Observable<List<User>> groupList(@Path(\"id\") int groupId, @Query(\"sort\") String sort);\n```\n\nFor complex query parameter combinations a `Map` can be used.\n\n```java\n@GET(\"/group/{id}/users\")\nabstract Observable<List<User>> groupList(@Path(\"id\") int groupId, @QueryMap Map<String, String> options);\n```\n\n## REQUEST BODY\n\nAn object can be specified for use as an HTTP request body with the `@Body` annotation.\n\n```java\n@POST(\"/users/new\")\nabstract Observable<User> createUser(@Body User user> cb);\n```\n\nThe object will also be converted using the converter.\n\n## FORM ENCODED AND MULTIPART\n\nMethods can also be declared to send form-encoded and multipart data.\n\nForm-encoded data is sent when `@FormUrlEncoded` is present on the method. Each key-value pair is annotated with `@Field` containing the name and the object providing the value.\n\n```java\n@FormUrlEncoded\n@POST(\"/user/edit\")\nabstract Observable<User> updateUser(@Field(\"first_name\") String first, @Field(\"last_name\") String last);\n```\n\nMultipart requests are used when `@Multipart` is present on the method. Parts are declared using the `@Part` annotation.\n\n```java\n@Multipart\n@PUT(\"/user/photo\")\nabstract Observable<User> updateUser(@Part(\"photo\") TypedFile photo, @Part(\"description\") TypedString description);\n```\n\nMultipart parts use the converter. In progress: or they can implement `TypedOutput` to handle their own serialization.\n\n## HEADER MANIPULATION\n\nYou can set static headers for a method using the `@Headers` annotation.\n\n```java\n@Headers(\"Cache-Control: max-age=640000\")\n@GET(\"/widget/list\")\nabstract Observable<List<Widget>> widgetList();\n```\n\n```java\n@Headers({\n    \"Accept: application/vnd.github.v3.full+json\",\n    \"User-Agent: Retrofit2\"\n})\n@GET(\"/users/{username}\")\nabstract Observable<User> getUser(@Path(\"username\") String username);\n```\n\nNote that headers do not overwrite each other. All headers with the same name will be included in the request.\n\nA request Header can be updated dynamically using the `@Header` annotation. A corresponding parameter must be provided to the `@Header`. If the value is null, the header will be omitted. Otherwise, `toString` will be called on the value, and the result used.\n\n```java\n@GET(\"/user\")\nObservable<User> getUser(@Header(\"Authorization\") String authorization);\n```\n\n### Global Headers\n\nHeaders that need to be added to every request can be specified using `@Headers` on your service. The following code uses `@Headers` that will add a User-Agent header to every request.\n\n```java\n@Retrofit(\"https://api.github.com\")\n@Headers({\n    \"Accept: application/vnd.github.v3.full+json\",\n    \"User-Agent: Retrofit2\"\n})\nabstract class GitHub {\n    // ..\n}\n```\n\n## SYNCHRONOUS VS. ASYNCHRONOUS VS. OBSERVABLE\n\nMethods can be declared for either synchronous or asynchronous execution.\n\nA method with a return type will be executed synchronously.\n\n```java\n@GET(\"/user/{id}/photo\")\nPhoto getUserPhoto(@Path(\"id\") int id);\n```\n\nAsynchronous execution requires the last parameter of the method be a `Callback`.\n\n```java\n@GET(\"/user/{id}/photo\")\nvoid getUserPhoto(@Path(\"id\") int id, Callback<Photo> cb);\n```\n\nOn Android, callbacks will be executed on the main thread. For desktop applications callbacks will happen on the same thread that executed the HTTP request.\n\nRetrofit also integrates [RxJava](https://github.com/ReactiveX/RxJava/wiki) to support methods with a return type of `rx.Observable`\n\n```java\n@GET(\"/user/{id}/photo\")\nObservable<Photo> getUserPhoto(@Path(\"id\") int id);\n```\n\nObservable requests are subscribed asynchronously and observed on the same thread that executed the HTTP request. To observe on a different thread (e.g. Android's main thread) call `observeOn(Scheduler)` on the returned `Observable`.\n\n## RESPONSE OBJECT TYPE\n\nHTTP responses are automatically converted to a specified type using the RestAdapter's converter which defaults to JSON. The desired type is declared as the method return type or using the Callback or Observable.\n\n```java\n@GET(\"/users/list\")\nList<User> userList();\n```\n\n```java\n@GET(\"/users/list\")\nvoid userList(Callback<List<User>> cb);\n```\n\n```java\n@GET(\"/users/list\")\nObservable<List<User>> userList();\n```\n\nFor access to the raw HTTP response use the Response type.\n\n```java\n@GET(\"/users/list\")\nResponse userList();\n```\n\n```java\n@GET(\"/users/list\")\nvoid userList(Callback<Response> cb);\n```\n\n```java\n@GET(\"/users/list\")\nObservable<Response> userList();\n```\n\n## Target Configuration\n\n`Retrofit\\_TARGET` is the class through which your API interfaces are turned into callable objects. By default, Retrofit2 will give you sane defaults for your platform but it allows for customization.\n\n### JSON CONVERSION\n\nRetrofit2 uses [LoganSquare](https://github.com/bluelinelabs/LoganSquare) by default to convert HTTP bodies to and from JSON. If you want to specify behavior that is different from Gson's defaults (e.g. naming policies, date formats, custom types), provide a new `Gson` instance with your desired behavior when building a `Retrofit_TARGET`. Refer to the [Gson documentation](https://sites.google.com/site/gson/gson-user-guide) for more details on customization.\n\n### CUSTOM GSON CONVERTER EXAMPLE\n\nThe following code creates a new Gson instance that will convert all fields from lower case with underscores to camel case and vice versa. It also registers a type adapter for the `Date` class. This `DateTypeAdapter` will be used anytime Gson encounters a `Date` field.\n\nThe gson instance is passed as a parameter to `GsonConverter`, which is a wrapper class for converting types.\n\n```java\npublic static class DateGsonConverter extends GsonConverter {\n    public DateGsonConverter() {\n        super(new com.google.gson.GsonBuilder()\n            .setFieldNamingPolicy(com.google.gson.FieldNamingPolicy.LOWER_CASE_WITH_UNDERSCORES)\n            .registerTypeAdapter(java.util.Date.class, new com.google.gson.internal.bind.DateTypeAdapter())\n            .create());\n    }\n}\n\n@Retrofit(\"https://api.github.com\")\n@Converter(DateGsonConverter.class)\nabstract class GitHub {\n    // ..\n}\n```\n\nEach call on the generated `GitHub` will return objects converted using the Gson implementation provided to the `Retrofit_GitHub`.\n\n### CUSTOM CONVERTER FOR METHOD\n\nSpecify another converter instance for one of methods by the following code:\n\n```java\n@Retrofit(\"https://api.github.com\")\n@Converter(DateGsonConverter.class)\nabstract class GitHub {\n    @GET(\"/users/{username}\")\n    @Converter(LoganSquareConverter.class)\n    abstract Observable<User> getUser(@Path(\"username\") String username);\n\n    // ..\n}\n```\n\n### CONTENT FORMAT AGNOSTIC\n\nIn addition to JSON, Retrofit can be configured to use other content formats. Retrofit provides alternate converters for XML (using [Simple](http://simple.sourceforge.net/)) and Protocol Buffers (using [protobuf](https://code.google.com/p/protobuf/) or [Wire](https://github.com/square/wire)). Please see the [retrofit-converters](https://github.com/square/retrofit/tree/master/retrofit-converters) directory for the full listing of converters.\n\nThe following code shows how to use `SimpleXMLConverter` to communicate with an API that uses XML\n\n```java\n@Retrofit(\"https://api.github.com\")\n@Converter(SimpleXMLConverter.class)\nabstract class GitHub {\n    // ..\n}\n```\n\n### CUSTOM CONVERTERS\n\nIf you need to communicate with an API that uses a content-format that Retrofit does not support out of the box (e.g. YAML, txt, custom format) or you wish to use a different library to implement an existing format, you can easily create your own converter. Create a class that implements the [`Converter` interface](https://github.com/square/retrofit/blob/master/retrofit/src/main/java/retrofit/converter/Converter.java) and pass in an instance when building your adapter.\n\n## CUSTOM ERROR HANDLING\n\nIf you need custom error handling for requests, you may provide your own ErrorHandler. The following code shows how to throw a custom exception when a response returns a HTTP 401 status code\n\n```java\n@Retrofit(\"https://api.github.com\")\n@ErrorHandler(MyErrorHandler.class)\nclass GitHub {\n    // ..\n}\n```\n\n```java\npublic class MyErrorHandler implements ErrorHandler {\n    @Override public Throwable handleError(RetrofitError cause) {\n        Response r = cause.getResponse();\n        if (r != null && r.getStatus() == 401) {\n            return new RuntimeException(\"401\", cause);\n        }\n        return cause;\n    }\n}\n```\n\nNote that if the return exception is checked, it must be declared on the interface method. It is recommended that you pass the supplied RetrofitError as the cause to any new exceptions you throw.\n\n## LOGGING\n\nIf you need to take a closer look at the requests and responses you can easily add logging levels to the `Retrofit_GitHub` with the `LogLevel` property. The possible logging levels are `BASIC`, `FULL`, `HEADERS`, and `NONE`.\n\nThe following code shows the addition of a full log level which will log the headers, body, and metadata for both requests and responses.\n\n```java\n@Retrofit(\"https://api.github.com\")\n@LogLevel(LogLevel.FULL)\nabstract class GitHub {\n    // ..\n}\n```\n\n## Support `@RetryHeaders`\n\n*Experiment feature*\n\nFor Retry Stale example:\n\n```java\n@Retrofit(\"https://api.github.com\")\n@RetryHeaders(\"Cache-Control: max-age=640000\")\nabstract class GitHub {\n    // ..\n}\n```\n\nRetry the request with cache if network issue.\n\n## Support `@RequestInterceptor`\n\n```java\n@Retrofit(\"https://api.github.com\")\n@RequestInterceptor(MyRequestInterceptor.class)\nabstract class GitHub {\n    // ..\n}\n```\n\n## Migration\n\n1. Add `@Retrofit(\"https://api.github.com\")` line\n2. Change `interface GitHub` to `abstract class GitHub`\n3. Add `public static GitHub create() { return new Retrofit_GitHub(); }`\n\nFor example:\n\n```java\n@Retrofit(\"https://api.github.com\") // 1. Add this line\nabstract class GitHub { // 2. Change to abstract class\n  @GET(\"/users/{user}/repos\")\n  List<Repo> listRepos(@Path(\"user\") String user);\n  public static GitHub create() { return new Retrofit_GitHub(); } // 3. Add creator\n}\n\nGithub github = GitHub.create();\n```\n\nAnother way:\n\n```java\n@Retrofit(\"https://api.github.com\")\nabstract class GitHubBean implements GitHub {\n  public static GitHub create() { return new Retrofit_GitHub(); }\n}\n\nGithub github = GitHubBean.create();\n```\n\n## Installation\n\nvia jcenter:\n\n```java\nrepositories {\n    jcenter()\n}\n\ndependencies {\n    compile 'com.infstory:retrofit:2.0.0'\n    apt 'com.infstory:retrofit-processor:2.0.0'\n}\n```\n\nor via jitpack (in progress):\n\n```java\nrepositories {\n    jcenter()\n    mavne { url \"https://jitpack.io\" }\n}\n\ndependencies {\n    compile 'com.github.yongjhih.retrofit:retrofit:-SNAPSHOT'\n    apt 'com.github.yongjhih.retrofit:retrofit-processor:-SNAPSHOT'\n}\n```\n\n## Live Demo\n\n* https://appetize.io/app/3trwbht63k0rkfmbxbt51h84cr\n\n## Test\n\nTest github client:\n\n```bash\n./gradlew clean :retrofit2-github:testDebug\n```\n\nAll tests:\n\n```bash\n./gradlew clean test\n```\n\nGithub sample app:\n\n```bash\n./gradlew clean :retrofit2-github-app:assembleDebug\n```\n\n## Development\n\n* Support POST, DELTE, PUT: http://www.twitch.tv/yoandrew/v/7918907\n\n## References\n\n* http://square.github.io/retrofit/\n* https://github.com/square/okhttp/wiki/Recipes\n* http://square.github.io/okhttp/javadoc/com/squareup/okhttp/RequestBody.html\n\n## See Also\n\n* jw/retrofit-two? https://github.com/JakeWharton/u2020/compare/jw/retrofit-two\n* square/jw/code-gen, 49407dbb19f48072ab5fce8a49f38606ce07bd27, 2013\n\n## Credit\n\n* Square, Inc.\n\n## License\n\n```\nCopyright 2013 Square, Inc.\nCopyright 2015 8tory, Inc.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n```\n", "tags": ["Retrofit", "RxJava"]}