{"context": "\n\nRabbitMQ \u30c1\u30e5\u30fc\u30c8\u30ea\u30a2\u30eb\uff11 C\u30d0\u30fc\u30b8\u30e7\u30f3\nRabbitMQ \u30c1\u30e5\u30fc\u30c8\u30ea\u30a2\u30eb https://www.rabbitmq.com/getstarted.html \u306ePython\u7248\u306e\u30d7\u30ed\u30b0\u30e9\u30e0\u3092\u4e0b\u6577\u304d\u306b\u3057\u3066\u3001C\u30e9\u30a4\u30d6\u30e9\u30ea https://github.com/alanxz/rabbitmq-c \u3092\u4f7f\u3063\u305f\u30d7\u30ed\u30b0\u30e9\u30e0\u3092\u66f8\u304d\u307e\u3059\u3002RabbitMQ\u306e\u8aac\u660e\u7b49\u306f\u3001\u5143\u306e\u30c1\u30e5\u30fc\u30c8\u30ea\u30a2\u30eb\u3092\u53c2\u7167\u3057\u3066\u304f\u3060\u3055\u3044\u3002\n\u30d7\u30ed\u30b0\u30e9\u30e0\u81ea\u4f53\u306f C++\u3092\u4f7f\u3063\u3066\u3044\u307e\u3059\u304c\u3001class\u5b9a\u7fa9\u306a\u3069\u3092\u4f7f\u3063\u3066\u3044\u306a\u3044\u306e\u3067\u3001C\u3067\u3082\u5927\u304d\u306a\u9055\u3044\u306f\u3042\u308a\u307e\u305b\u3093\u3002\u30a8\u30e9\u30fc\u30c1\u30a7\u30c3\u30af\u306e\u30b3\u30fc\u30c9\u306f\u3001\u9069\u5b9c\u8ffd\u52a0\u3057\u3066\u304f\u3060\u3055\u3044\u3002\n\n\u9001\u4fe1\nRabbitMQ\u30b5\u30fc\u30d0\u3068\u306e\u30b3\u30cd\u30af\u30b7\u30e7\u30f3\u3092\u78ba\u7acb\u3059\u308b\u305f\u3081\u306b\u3001\u307e\u305a\u30b3\u30cd\u30af\u30b7\u30e7\u30f3\u30aa\u30d6\u30b8\u30a7\u30af\u30c8\u3092\u4f5c\u6210\u3059\u308b\u3002\u30b3\u30cd\u30af\u30b7\u30e7\u30f3\u30aa\u30d6\u30b8\u30a7\u30af\u30c8\u306e\u4f7f\u7528\u7d42\u4e86\u5f8c\u306f\u3001amqp_destroy_connection()\u3067\u7834\u68c4\u3059\u308b\u3002\n\namqp.h\namqp_connection_state_t  amqp_new_connection(void);\nint  amqp_destroy_connection(amqp_connection_state_t state);\n\n\nRabbitMQ\u30b5\u30fc\u30d0\u306b\u63a5\u7d9a\u3059\u308b\u306b\u306f\u3001amqp_tcp_socket_new()\u3067\u30bd\u30b1\u30c3\u30c8\u3092\u4f5c\u6210\u3057\u3001amqp_socket_open()\u3067\u30db\u30b9\u30c8\u3001\u30dd\u30fc\u30c8\u756a\u53f7\u3092\u6307\u5b9a\u3057\u3066\u30b3\u30cd\u30af\u30b7\u30e7\u30f3\u3092\u5f35\u308b\u3002\n\namqp_tcp_socket.h\namqp_socket_t*  amqp_tcp_socket_new(amqp_connection_state_t state);\nint  amqp_socket_open(amqp_socket_t* socket, const char *host, int port);\n\n\n\u30b5\u30fc\u30d0\u306b\u63a5\u7d9a\u5f8c\u3001\u30d0\u30fc\u30c1\u30e3\u30eb\u30db\u30b9\u30c8\u3001\u8a8d\u8a3c\u65b9\u6cd5\u3001ID\u3001PW\u3092\u9001\u4fe1\u3057\u3066\u30ed\u30b0\u30a4\u30f3\u3059\u308b\u3002\n\namqp.h\namqp_rpc_reply_t  amqp_login(amqp_connection_state_t state,\n                             char const *vhost,\n                             int channel_max, int frame_max, int heartbeat,\n                             amqp_sasl_method_enum sasl_method, ...);\n\n\n\u6b63\u5e38\u7d42\u4e86\u306e\u5834\u5408\u3001\u623b\u308a\u5024\u306e amqp_rpc_reply_t \u306e\u30e1\u30f3\u30d0 reply_type \u306b AMQP_RESPONSE_NORMAL \u304c\u683c\u7d0d\u3055\u308c\u308b\u3002\n\u30ad\u30e5\u30fc\u3092\u4f5c\u6210\u3059\u308b\u306b\u306f\u3001amqp_queue_declare()\u3092\u4f7f\u3046\u3002\n\namqp_framing.h\namqp_queue_declare_ok_t*  amqp_queue_declare(amqp_connection_state_t state,\n                                             amqp_channel_t channel,\n                                             amqp_bytes_t queue,\n                                             amqp_boolean_t passive, amqp_boolean_t durable, amqp_boolean_t exclusive, amqp_boolean_t auto_delete,\n                                             amqp_table_t arguments);\n\n\n\u30ad\u30e5\u30fc\u540d\u306a\u3069\u306e\u30c6\u30ad\u30b9\u30c8\u30c7\u30fc\u30bf\u306f amqp_bytes_t\u69cb\u9020\u4f53\u3067\u6307\u5b9a\u3059\u308b\u3002\u3053\u306e\u69cb\u9020\u4f53\u306f\u3001\u30d0\u30a4\u30c8\u30c7\u30fc\u30bf\u306e\u9577\u3055\u3068\u30c7\u30fc\u30bf\u3078\u306e\u30dd\u30a4\u30f3\u30bf\u304b\u3089\u306a\u308b\u3002\u95a2\u6570\u3078\u306e\u53d7\u3051\u6e21\u3057\u3067\u306f\u3001\u3053\u306e\u69cb\u9020\u4f53\u304c\u30b3\u30d4\u30fc\u3055\u308c\u308b\u3002\n\namqp.h\ntypedef struct amqp_bytes_t_ {\n  size_t  len;   /* \u30d0\u30c3\u30d5\u30a1\u306e\u30d0\u30a4\u30c8\u6570 */\n  void*  bytes;  /* \u30d0\u30c3\u30d5\u30a1\u3078\u306e\u30dd\u30a4\u30f3\u30bf */\n} amqp_bytes_t;\n\n\nC\u6587\u5b57\u5217\u304b\u3089amqp_bytes_t\u69cb\u9020\u4f53\u3092\u751f\u6210\u3059\u308b\u306b\u306f\u3001amqp_cstring_bytes()\u95a2\u6570\u304c\u5229\u7528\u3067\u304d\u308b\u3002\nexchange\u3068routing_key\u3092\u6307\u5b9a\u3057\u3066\u3001\u30ad\u30e5\u30fc\u306eexchange\u306b\u30c7\u30fc\u30bf\u3092\u9001\u4fe1\u3059\u308b\u3002\n\namqp.h\nint  amqp_basic_publish(amqp_connection_state_t state, amqp_channel_t channel,\n                        amqp_bytes_t exchange, amqp_bytes_t routing_key,\n                        amqp_boolean_t mandatory, amqp_boolean_t immediate,\n                        amqp_basic_properties_t const* properties,\n                        amqp_bytes_t body);\n\n\n\u6700\u7d42\u7684\u306a\u30d7\u30ed\u30b0\u30e9\u30e0\u306f\u4ee5\u4e0b\u306e\u3068\u304a\u308a\u3002\n\nsend.cc\n#include <stdio.h>\n#include <stdlib.h>\n#include <amqp.h>\n#include <amqp_tcp_socket.h>\n#include <amqp_framing.h>\n\nint  main (int argc, char** argv) {\n    amqp_connection_state_t  conn = amqp_new_connection ();\n\n    amqp_socket_t*  socket = amqp_tcp_socket_new (conn);\n\n    int  rc_sock = amqp_socket_open (socket, \"localhost\", 5672);\n    if (rc_sock != AMQP_STATUS_OK) {\n        fprintf (stderr, \"connection failure.\\n\");\n        exit (1);\n    }\n\n    amqp_rpc_reply_t  rc_login = amqp_login (conn, \"/\", AMQP_DEFAULT_MAX_CHANNELS, AMQP_DEFAULT_FRAME_SIZE, AMQP_DEFAULT_HEARTBEAT, AMQP_SASL_METHOD_PLAIN, \"guest\", \"guest\");\n    if (rc_login.reply_type != AMQP_RESPONSE_NORMAL) {\n        if (rc_login.reply_type == AMQP_RESPONSE_SERVER_EXCEPTION) {\n            if (rc_login.reply.id == AMQP_CONNECTION_CLOSE_METHOD) {\n                amqp_connection_close_t *m = (amqp_connection_close_t *) rc_login.reply.decoded;\n                fwrite (m->reply_text.bytes, 1, m->reply_text.len, stderr);\n                fprintf (stderr, \"\\n\");\n            }\n        }\n        exit (1);\n    }\n\n    amqp_channel_t  channel = 1;\n    amqp_channel_open_ok_t*  rc_channel = amqp_channel_open (conn, channel);\n\n    amqp_bytes_t  queue = amqp_cstring_bytes (\"hello\");\n    amqp_queue_declare_ok_t*  rc_decl = amqp_queue_declare (conn, channel, queue, false, false, false, false, amqp_empty_table);\n\n    amqp_bytes_t  msg = amqp_cstring_bytes (\"Hello World!\");\n    int  rc_pub = amqp_basic_publish (conn, channel, amqp_empty_bytes, queue, false, false, NULL, msg);\n\n    amqp_rpc_reply_t  rc_chclose = amqp_channel_close (conn, channel, AMQP_REPLY_SUCCESS);\n    amqp_rpc_reply_t  rc_conclose = amqp_connection_close (conn, AMQP_REPLY_SUCCESS);\n    amqp_destroy_connection (conn);\n\n    return 0;\n}\n\n\n\n\u53d7\u4fe1\n\u30e9\u30a4\u30d6\u30e9\u30ea\u81ea\u4f53\u306b\u306f\u3001\u30a4\u30d9\u30f3\u30c8\u30eb\u30fc\u30d7\u3084\u30b3\u30fc\u30eb\u30d0\u30c3\u30af\u306e\u4ed5\u7d44\u307f\u306f\u7528\u610f\u3055\u308c\u3066\u3044\u306a\u3044\u304c\u3001Python\u30d7\u30ed\u30b0\u30e9\u30e0\u306e\u69cb\u9020\u306b\u306a\u3089\u3063\u3066\u3001\u30b3\u30fc\u30eb\u30d0\u30c3\u30af\u95a2\u6570\u3092\u7528\u610f\u3059\u308b\u3002\u3053\u3053\u3067\u306f\u3001\u30ad\u30e5\u30fc\u304b\u3089\u53d7\u3051\u53d6\u3063\u305f\u30e1\u30c3\u30bb\u30fc\u30b8\u30c7\u30fc\u30bf\u4ee5\u5916\u306b\u3001\u30b3\u30cd\u30af\u30b7\u30e7\u30f3\u30aa\u30d6\u30b8\u30a7\u30af\u30c8\u3068\u30e1\u30c3\u30bb\u30fc\u30b8\u30a8\u30f3\u30d9\u30ed\u30fc\u30d7\u3092\u5f15\u6570\u3068\u3059\u308b\u3002\nvoid  callback (amqp_connection_state_t* conn, amqp_envelope_t* envelope, amqp_bytes_t body);\n\namqp_basic_consume()\u3067\u53d7\u4fe1\u65b9\u6cd5\u3092\u6307\u5b9a\u3059\u308b\u3002no_ack\u30aa\u30d7\u30b7\u30e7\u30f3\u3092\u6307\u5b9a\u3059\u308b\u306b\u306f\u30016\u756a\u76ee\u306e\u30d1\u30e9\u30e1\u30fc\u30bf\u306eno_ack\u306btrue\u3092\u30bb\u30c3\u30c8\u3059\u308b\u3002\n\namqp_framing.h\namqp_basic_consume_ok_t*  amqp_basic_consume(amqp_connection_state_t state, amqp_channel_t channel,\n                                             amqp_bytes_t queue, amqp_bytes_t consumer_tag,\n                                             amqp_boolean_t no_local, amqp_boolean_t no_ack, amqp_boolean_t exclusive,\n                                             amqp_table_t arguments);\n\n\namqp_consume_message()\u3067\u30e1\u30c3\u30bb\u30fc\u30b8\u3092\u5f85\u3061\u53d7\u3051\u308b\u3002\u30e1\u30c3\u30bb\u30fc\u30b8\u4ee5\u5916\u306e\u30c7\u30fc\u30bf\u3092\u53d7\u4fe1\u3057\u305f\u5834\u5408\u3001\u9069\u5b9c\u51e6\u7406\u3059\u308b\u3002\n\namqp.h\namqp_rpc_reply_t  amqp_consume_message(amqp_connection_state_t state,\n                                       amqp_envelope_t *envelope,\n                                       struct timeval *timeout, int flags);\n\n\n\n\u6700\u7d42\u7684\u306a\u30d7\u30ed\u30b0\u30e9\u30e0\u306f\u4ee5\u4e0b\u306e\u3068\u304a\u308a\u3002\n\nrecv.cc\n#include <stdio.h>\n#include <stdlib.h>\n#include <amqp.h>\n#include <amqp_tcp_socket.h>\n#include <amqp_framing.h>\n\nvoid  callback (amqp_connection_state_t* conn, amqp_envelope_t* envelope, amqp_bytes_t body) {\n    printf (\" [x] Received \");\n    fwrite (body.bytes, 1, body.len, stdout);\n    printf (\"\\n\");\n}\n\nint  main (int argc, char** argv) {\n    amqp_connection_state_t  conn = amqp_new_connection ();\n\n    amqp_socket_t*  socket = amqp_tcp_socket_new (conn);\n\n    int  rc_sock = amqp_socket_open (socket, \"localhost\", 5672);\n    if (rc_sock != AMQP_STATUS_OK) {\n        fprintf (stderr, \"connection failure.\\n\");\n        exit (1);\n    }\n\n    amqp_rpc_reply_t  rc_login = amqp_login (conn, \"/\", AMQP_DEFAULT_MAX_CHANNELS, AMQP_DEFAULT_FRAME_SIZE, AMQP_DEFAULT_HEARTBEAT, AMQP_SASL_METHOD_PLAIN, \"guest\", \"guest\");\n    if (rc_login.reply_type != AMQP_RESPONSE_NORMAL) {\n        if (rc_login.reply_type == AMQP_RESPONSE_SERVER_EXCEPTION) {\n            if (rc_login.reply.id == AMQP_CONNECTION_CLOSE_METHOD) {\n                amqp_connection_close_t *m = (amqp_connection_close_t *) rc_login.reply.decoded;\n                fwrite (m->reply_text.bytes, 1, m->reply_text.len, stderr);\n                fprintf (stderr, \"\\n\");\n            }\n        }\n        exit (1);\n    }\n\n    amqp_channel_t  channel = 1;\n    amqp_channel_open_ok_t*  rc_channel = amqp_channel_open (conn, channel);\n\n    amqp_bytes_t  queue = amqp_cstring_bytes (\"hello\");\n    amqp_queue_declare_ok_t*  rc_decl = amqp_queue_declare (conn, channel, queue, false, false, false, false, amqp_empty_table);\n\n    amqp_basic_consume_ok_t*  rc_cons = amqp_basic_consume (conn, channel, queue, amqp_empty_bytes, false, true/*no_ack*/, false, amqp_empty_table);\n\n    printf (\" [*] Waiting for messages. To exit press CTRL+C\\n\");\n\n    while (1) {\n        amqp_maybe_release_buffers (conn);\n        amqp_envelope_t  envelope;\n        amqp_rpc_reply_t  rc_msg = amqp_consume_message (conn, &envelope, NULL, 0);\n        switch (rc_msg.reply_type) {\n        case AMQP_RESPONSE_NORMAL:\n            callback (&conn, &envelope, envelope.message.body);\n            break;\n        case AMQP_RESPONSE_LIBRARY_EXCEPTION:\n            if (rc_msg.library_error == AMQP_STATUS_UNEXPECTED_STATE) {\n                amqp_frame_t  frame;\n                if (amqp_simple_wait_frame (conn, &frame) != AMQP_STATUS_OK) {\n                    goto Ex1;\n                }\n                if (frame.frame_type == AMQP_FRAME_METHOD) {\n                    switch (frame.payload.method.id) {\n                    case AMQP_BASIC_ACK_METHOD:\n                        break;\n                    case AMQP_BASIC_RETURN_METHOD: {\n                        amqp_message_t  message;\n                        amqp_rpc_reply_t  rc_read = amqp_read_message (conn, frame.channel, &message, 0);\n                        if (rc_read.reply_type != AMQP_RESPONSE_NORMAL) {\n                            goto Ex1;\n                        }\n                        amqp_destroy_message (&message);\n                        break;\n                    }\n                    case AMQP_CHANNEL_CLOSE_METHOD:\n                        goto Ex1;\n                    case AMQP_CONNECTION_CLOSE_METHOD:\n                        goto Ex1;\n                    default:\n                        fprintf (stderr ,\"An unexpected method was received %d\\n\", frame.payload.method.id);\n                        goto Ex1;\n                    }\n                }\n            }\n            break;\n        default:;\n        }\n        amqp_destroy_envelope (&envelope);\n    }\n\n Ex1:;\n    amqp_rpc_reply_t  rc_chclose = amqp_channel_close (conn, channel, AMQP_REPLY_SUCCESS);\n    amqp_rpc_reply_t  rc_conclose = amqp_connection_close (conn, AMQP_REPLY_SUCCESS);\n    amqp_destroy_connection (conn);\n\n    return 0;\n}\n\n\n#RabbitMQ \u30c1\u30e5\u30fc\u30c8\u30ea\u30a2\u30eb\uff11 C\u30d0\u30fc\u30b8\u30e7\u30f3\nRabbitMQ \u30c1\u30e5\u30fc\u30c8\u30ea\u30a2\u30eb https://www.rabbitmq.com/getstarted.html \u306ePython\u7248\u306e\u30d7\u30ed\u30b0\u30e9\u30e0\u3092\u4e0b\u6577\u304d\u306b\u3057\u3066\u3001C\u30e9\u30a4\u30d6\u30e9\u30ea https://github.com/alanxz/rabbitmq-c \u3092\u4f7f\u3063\u305f\u30d7\u30ed\u30b0\u30e9\u30e0\u3092\u66f8\u304d\u307e\u3059\u3002RabbitMQ\u306e\u8aac\u660e\u7b49\u306f\u3001\u5143\u306e\u30c1\u30e5\u30fc\u30c8\u30ea\u30a2\u30eb\u3092\u53c2\u7167\u3057\u3066\u304f\u3060\u3055\u3044\u3002\n\n\u30d7\u30ed\u30b0\u30e9\u30e0\u81ea\u4f53\u306f C++\u3092\u4f7f\u3063\u3066\u3044\u307e\u3059\u304c\u3001class\u5b9a\u7fa9\u306a\u3069\u3092\u4f7f\u3063\u3066\u3044\u306a\u3044\u306e\u3067\u3001C\u3067\u3082\u5927\u304d\u306a\u9055\u3044\u306f\u3042\u308a\u307e\u305b\u3093\u3002\u30a8\u30e9\u30fc\u30c1\u30a7\u30c3\u30af\u306e\u30b3\u30fc\u30c9\u306f\u3001\u9069\u5b9c\u8ffd\u52a0\u3057\u3066\u304f\u3060\u3055\u3044\u3002\n\n##\u9001\u4fe1\nRabbitMQ\u30b5\u30fc\u30d0\u3068\u306e\u30b3\u30cd\u30af\u30b7\u30e7\u30f3\u3092\u78ba\u7acb\u3059\u308b\u305f\u3081\u306b\u3001\u307e\u305a\u30b3\u30cd\u30af\u30b7\u30e7\u30f3\u30aa\u30d6\u30b8\u30a7\u30af\u30c8\u3092\u4f5c\u6210\u3059\u308b\u3002\u30b3\u30cd\u30af\u30b7\u30e7\u30f3\u30aa\u30d6\u30b8\u30a7\u30af\u30c8\u306e\u4f7f\u7528\u7d42\u4e86\u5f8c\u306f\u3001amqp_destroy_connection()\u3067\u7834\u68c4\u3059\u308b\u3002\n\n```cpp:amqp.h\namqp_connection_state_t  amqp_new_connection(void);\nint  amqp_destroy_connection(amqp_connection_state_t state);\n```\n\nRabbitMQ\u30b5\u30fc\u30d0\u306b\u63a5\u7d9a\u3059\u308b\u306b\u306f\u3001amqp_tcp_socket_new()\u3067\u30bd\u30b1\u30c3\u30c8\u3092\u4f5c\u6210\u3057\u3001amqp_socket_open()\u3067\u30db\u30b9\u30c8\u3001\u30dd\u30fc\u30c8\u756a\u53f7\u3092\u6307\u5b9a\u3057\u3066\u30b3\u30cd\u30af\u30b7\u30e7\u30f3\u3092\u5f35\u308b\u3002\n\n```cpp:amqp_tcp_socket.h\namqp_socket_t*  amqp_tcp_socket_new(amqp_connection_state_t state);\nint  amqp_socket_open(amqp_socket_t* socket, const char *host, int port);\n```\n\n\u30b5\u30fc\u30d0\u306b\u63a5\u7d9a\u5f8c\u3001\u30d0\u30fc\u30c1\u30e3\u30eb\u30db\u30b9\u30c8\u3001\u8a8d\u8a3c\u65b9\u6cd5\u3001ID\u3001PW\u3092\u9001\u4fe1\u3057\u3066\u30ed\u30b0\u30a4\u30f3\u3059\u308b\u3002\n\n```cpp:amqp.h\namqp_rpc_reply_t  amqp_login(amqp_connection_state_t state,\n                             char const *vhost,\n                             int channel_max, int frame_max, int heartbeat,\n                             amqp_sasl_method_enum sasl_method, ...);\n```\n\n\u6b63\u5e38\u7d42\u4e86\u306e\u5834\u5408\u3001\u623b\u308a\u5024\u306e amqp_rpc_reply_t \u306e\u30e1\u30f3\u30d0 reply_type \u306b AMQP_RESPONSE_NORMAL \u304c\u683c\u7d0d\u3055\u308c\u308b\u3002\n\n\u30ad\u30e5\u30fc\u3092\u4f5c\u6210\u3059\u308b\u306b\u306f\u3001amqp_queue_declare()\u3092\u4f7f\u3046\u3002\n\n```cpp:amqp_framing.h\namqp_queue_declare_ok_t*  amqp_queue_declare(amqp_connection_state_t state,\n                                             amqp_channel_t channel,\n                                             amqp_bytes_t queue,\n                                             amqp_boolean_t passive, amqp_boolean_t durable, amqp_boolean_t exclusive, amqp_boolean_t auto_delete,\n                                             amqp_table_t arguments);\n```\n\n\u30ad\u30e5\u30fc\u540d\u306a\u3069\u306e\u30c6\u30ad\u30b9\u30c8\u30c7\u30fc\u30bf\u306f amqp_bytes_t\u69cb\u9020\u4f53\u3067\u6307\u5b9a\u3059\u308b\u3002\u3053\u306e\u69cb\u9020\u4f53\u306f\u3001\u30d0\u30a4\u30c8\u30c7\u30fc\u30bf\u306e\u9577\u3055\u3068\u30c7\u30fc\u30bf\u3078\u306e\u30dd\u30a4\u30f3\u30bf\u304b\u3089\u306a\u308b\u3002\u95a2\u6570\u3078\u306e\u53d7\u3051\u6e21\u3057\u3067\u306f\u3001\u3053\u306e\u69cb\u9020\u4f53\u304c\u30b3\u30d4\u30fc\u3055\u308c\u308b\u3002\n\n```cpp:amqp.h\ntypedef struct amqp_bytes_t_ {\n  size_t  len;   /* \u30d0\u30c3\u30d5\u30a1\u306e\u30d0\u30a4\u30c8\u6570 */\n  void*  bytes;  /* \u30d0\u30c3\u30d5\u30a1\u3078\u306e\u30dd\u30a4\u30f3\u30bf */\n} amqp_bytes_t;\n```\n\nC\u6587\u5b57\u5217\u304b\u3089amqp_bytes_t\u69cb\u9020\u4f53\u3092\u751f\u6210\u3059\u308b\u306b\u306f\u3001amqp_cstring_bytes()\u95a2\u6570\u304c\u5229\u7528\u3067\u304d\u308b\u3002\n\nexchange\u3068routing_key\u3092\u6307\u5b9a\u3057\u3066\u3001\u30ad\u30e5\u30fc\u306eexchange\u306b\u30c7\u30fc\u30bf\u3092\u9001\u4fe1\u3059\u308b\u3002\n\n```cpp:amqp.h\nint  amqp_basic_publish(amqp_connection_state_t state, amqp_channel_t channel,\n                        amqp_bytes_t exchange, amqp_bytes_t routing_key,\n                        amqp_boolean_t mandatory, amqp_boolean_t immediate,\n                        amqp_basic_properties_t const* properties,\n                        amqp_bytes_t body);\n```\n\n\u6700\u7d42\u7684\u306a\u30d7\u30ed\u30b0\u30e9\u30e0\u306f\u4ee5\u4e0b\u306e\u3068\u304a\u308a\u3002\n\n```cpp:send.cc\n#include <stdio.h>\n#include <stdlib.h>\n#include <amqp.h>\n#include <amqp_tcp_socket.h>\n#include <amqp_framing.h>\n\nint  main (int argc, char** argv) {\n    amqp_connection_state_t  conn = amqp_new_connection ();\n\n    amqp_socket_t*  socket = amqp_tcp_socket_new (conn);\n\n    int  rc_sock = amqp_socket_open (socket, \"localhost\", 5672);\n    if (rc_sock != AMQP_STATUS_OK) {\n        fprintf (stderr, \"connection failure.\\n\");\n        exit (1);\n    }\n\n    amqp_rpc_reply_t  rc_login = amqp_login (conn, \"/\", AMQP_DEFAULT_MAX_CHANNELS, AMQP_DEFAULT_FRAME_SIZE, AMQP_DEFAULT_HEARTBEAT, AMQP_SASL_METHOD_PLAIN, \"guest\", \"guest\");\n    if (rc_login.reply_type != AMQP_RESPONSE_NORMAL) {\n        if (rc_login.reply_type == AMQP_RESPONSE_SERVER_EXCEPTION) {\n            if (rc_login.reply.id == AMQP_CONNECTION_CLOSE_METHOD) {\n                amqp_connection_close_t *m = (amqp_connection_close_t *) rc_login.reply.decoded;\n                fwrite (m->reply_text.bytes, 1, m->reply_text.len, stderr);\n                fprintf (stderr, \"\\n\");\n            }\n        }\n        exit (1);\n    }\n\n    amqp_channel_t  channel = 1;\n    amqp_channel_open_ok_t*  rc_channel = amqp_channel_open (conn, channel);\n\n    amqp_bytes_t  queue = amqp_cstring_bytes (\"hello\");\n    amqp_queue_declare_ok_t*  rc_decl = amqp_queue_declare (conn, channel, queue, false, false, false, false, amqp_empty_table);\n\n    amqp_bytes_t  msg = amqp_cstring_bytes (\"Hello World!\");\n    int  rc_pub = amqp_basic_publish (conn, channel, amqp_empty_bytes, queue, false, false, NULL, msg);\n\n    amqp_rpc_reply_t  rc_chclose = amqp_channel_close (conn, channel, AMQP_REPLY_SUCCESS);\n    amqp_rpc_reply_t  rc_conclose = amqp_connection_close (conn, AMQP_REPLY_SUCCESS);\n    amqp_destroy_connection (conn);\n\n    return 0;\n}\n```\n\n##\u53d7\u4fe1\n\n\u30e9\u30a4\u30d6\u30e9\u30ea\u81ea\u4f53\u306b\u306f\u3001\u30a4\u30d9\u30f3\u30c8\u30eb\u30fc\u30d7\u3084\u30b3\u30fc\u30eb\u30d0\u30c3\u30af\u306e\u4ed5\u7d44\u307f\u306f\u7528\u610f\u3055\u308c\u3066\u3044\u306a\u3044\u304c\u3001Python\u30d7\u30ed\u30b0\u30e9\u30e0\u306e\u69cb\u9020\u306b\u306a\u3089\u3063\u3066\u3001\u30b3\u30fc\u30eb\u30d0\u30c3\u30af\u95a2\u6570\u3092\u7528\u610f\u3059\u308b\u3002\u3053\u3053\u3067\u306f\u3001\u30ad\u30e5\u30fc\u304b\u3089\u53d7\u3051\u53d6\u3063\u305f\u30e1\u30c3\u30bb\u30fc\u30b8\u30c7\u30fc\u30bf\u4ee5\u5916\u306b\u3001\u30b3\u30cd\u30af\u30b7\u30e7\u30f3\u30aa\u30d6\u30b8\u30a7\u30af\u30c8\u3068\u30e1\u30c3\u30bb\u30fc\u30b8\u30a8\u30f3\u30d9\u30ed\u30fc\u30d7\u3092\u5f15\u6570\u3068\u3059\u308b\u3002\n\n```cpp:\nvoid  callback (amqp_connection_state_t* conn, amqp_envelope_t* envelope, amqp_bytes_t body);\n```\n\namqp_basic_consume()\u3067\u53d7\u4fe1\u65b9\u6cd5\u3092\u6307\u5b9a\u3059\u308b\u3002no_ack\u30aa\u30d7\u30b7\u30e7\u30f3\u3092\u6307\u5b9a\u3059\u308b\u306b\u306f\u30016\u756a\u76ee\u306e\u30d1\u30e9\u30e1\u30fc\u30bf\u306eno_ack\u306btrue\u3092\u30bb\u30c3\u30c8\u3059\u308b\u3002\n\n```cpp:amqp_framing.h\namqp_basic_consume_ok_t*  amqp_basic_consume(amqp_connection_state_t state, amqp_channel_t channel,\n                                             amqp_bytes_t queue, amqp_bytes_t consumer_tag,\n                                             amqp_boolean_t no_local, amqp_boolean_t no_ack, amqp_boolean_t exclusive,\n                                             amqp_table_t arguments);\n```\n\namqp_consume_message()\u3067\u30e1\u30c3\u30bb\u30fc\u30b8\u3092\u5f85\u3061\u53d7\u3051\u308b\u3002\u30e1\u30c3\u30bb\u30fc\u30b8\u4ee5\u5916\u306e\u30c7\u30fc\u30bf\u3092\u53d7\u4fe1\u3057\u305f\u5834\u5408\u3001\u9069\u5b9c\u51e6\u7406\u3059\u308b\u3002\n\n```cpp:amqp.h\namqp_rpc_reply_t  amqp_consume_message(amqp_connection_state_t state,\n                                       amqp_envelope_t *envelope,\n                                       struct timeval *timeout, int flags);\n\n```\n\n\u6700\u7d42\u7684\u306a\u30d7\u30ed\u30b0\u30e9\u30e0\u306f\u4ee5\u4e0b\u306e\u3068\u304a\u308a\u3002\n\n```cpp:recv.cc\n#include <stdio.h>\n#include <stdlib.h>\n#include <amqp.h>\n#include <amqp_tcp_socket.h>\n#include <amqp_framing.h>\n\nvoid  callback (amqp_connection_state_t* conn, amqp_envelope_t* envelope, amqp_bytes_t body) {\n    printf (\" [x] Received \");\n    fwrite (body.bytes, 1, body.len, stdout);\n    printf (\"\\n\");\n}\n\nint  main (int argc, char** argv) {\n    amqp_connection_state_t  conn = amqp_new_connection ();\n\n    amqp_socket_t*  socket = amqp_tcp_socket_new (conn);\n\n    int  rc_sock = amqp_socket_open (socket, \"localhost\", 5672);\n    if (rc_sock != AMQP_STATUS_OK) {\n        fprintf (stderr, \"connection failure.\\n\");\n        exit (1);\n    }\n\n    amqp_rpc_reply_t  rc_login = amqp_login (conn, \"/\", AMQP_DEFAULT_MAX_CHANNELS, AMQP_DEFAULT_FRAME_SIZE, AMQP_DEFAULT_HEARTBEAT, AMQP_SASL_METHOD_PLAIN, \"guest\", \"guest\");\n    if (rc_login.reply_type != AMQP_RESPONSE_NORMAL) {\n        if (rc_login.reply_type == AMQP_RESPONSE_SERVER_EXCEPTION) {\n            if (rc_login.reply.id == AMQP_CONNECTION_CLOSE_METHOD) {\n                amqp_connection_close_t *m = (amqp_connection_close_t *) rc_login.reply.decoded;\n                fwrite (m->reply_text.bytes, 1, m->reply_text.len, stderr);\n                fprintf (stderr, \"\\n\");\n            }\n        }\n        exit (1);\n    }\n\n    amqp_channel_t  channel = 1;\n    amqp_channel_open_ok_t*  rc_channel = amqp_channel_open (conn, channel);\n\n    amqp_bytes_t  queue = amqp_cstring_bytes (\"hello\");\n    amqp_queue_declare_ok_t*  rc_decl = amqp_queue_declare (conn, channel, queue, false, false, false, false, amqp_empty_table);\n\n    amqp_basic_consume_ok_t*  rc_cons = amqp_basic_consume (conn, channel, queue, amqp_empty_bytes, false, true/*no_ack*/, false, amqp_empty_table);\n\n    printf (\" [*] Waiting for messages. To exit press CTRL+C\\n\");\n\n    while (1) {\n        amqp_maybe_release_buffers (conn);\n        amqp_envelope_t  envelope;\n        amqp_rpc_reply_t  rc_msg = amqp_consume_message (conn, &envelope, NULL, 0);\n        switch (rc_msg.reply_type) {\n        case AMQP_RESPONSE_NORMAL:\n            callback (&conn, &envelope, envelope.message.body);\n            break;\n        case AMQP_RESPONSE_LIBRARY_EXCEPTION:\n            if (rc_msg.library_error == AMQP_STATUS_UNEXPECTED_STATE) {\n                amqp_frame_t  frame;\n                if (amqp_simple_wait_frame (conn, &frame) != AMQP_STATUS_OK) {\n                    goto Ex1;\n                }\n                if (frame.frame_type == AMQP_FRAME_METHOD) {\n                    switch (frame.payload.method.id) {\n                    case AMQP_BASIC_ACK_METHOD:\n                        break;\n                    case AMQP_BASIC_RETURN_METHOD: {\n                        amqp_message_t  message;\n                        amqp_rpc_reply_t  rc_read = amqp_read_message (conn, frame.channel, &message, 0);\n                        if (rc_read.reply_type != AMQP_RESPONSE_NORMAL) {\n                            goto Ex1;\n                        }\n                        amqp_destroy_message (&message);\n                        break;\n                    }\n                    case AMQP_CHANNEL_CLOSE_METHOD:\n                        goto Ex1;\n                    case AMQP_CONNECTION_CLOSE_METHOD:\n                        goto Ex1;\n                    default:\n                        fprintf (stderr ,\"An unexpected method was received %d\\n\", frame.payload.method.id);\n                        goto Ex1;\n                    }\n                }\n            }\n            break;\n        default:;\n        }\n        amqp_destroy_envelope (&envelope);\n    }\n\n Ex1:;\n    amqp_rpc_reply_t  rc_chclose = amqp_channel_close (conn, channel, AMQP_REPLY_SUCCESS);\n    amqp_rpc_reply_t  rc_conclose = amqp_connection_close (conn, AMQP_REPLY_SUCCESS);\n    amqp_destroy_connection (conn);\n\n    return 0;\n}\n```\n", "tags": ["RabbitMQ", "C"]}