{"tags": ["Scala", "sbt", "macro", "metaprogramming", "parser_combinator"], "context": "Scala\u306e\u5206\u96e2\u3055\u308c\u3066\u3044\u308b\u6a19\u6e96\u30e9\u30a4\u30d6\u30e9\u30ea\u306a\u3069\u3092\u4f7f\u3046\u305f\u3081\u306ebuild.sbt\u8a2d\u5b9a\u30b3\u30d4\u30da\u96c6\u3002\n\nParser combinator\n\nbuild.sbt\nlibraryDependencies ++= Seq(\n  \"org.scala-lang.modules\" %% \"scala-parser-combinators\" % \"1.0.4\"\n)\n\n\n\ncode\nimport scala.util.parsing.combinator._\n\n// \u5927\u4f53\u306e\u5834\u5408\u306fRegexParsers\u3067OK\nclass MyParser extends RegexParsers { ... } \n\n\nversion\u304c\u5909\u308f\u3063\u3066\u308b\u53ef\u80fd\u6027\u3042\u308b\u306e\u3067\u3001\u6700\u65b0\u306f\u3053\u3061\u3089\u3092\u78ba\u8a8d\u3057\u3066\u304f\u3060\u3055\u3044\u3002\n\nReflection\n\nbuild.sbt\nlibraryDependencies ++= Seq(\n  \"org.scala-lang\" % \"scala-reflect\" % scalaVersion.value\n)\n\n\n\ncode\nimport scala.reflect.runtime.universe._\n\ndef hoge[T]()(implicit tt: TypeTag[T]) = {\n  val t: Type = tt.tpe\n}\n\n\n\nMacro\nMacro\u306f\u5225\u30d7\u30ed\u30b8\u30a7\u30af\u30c8\u306b\u3057\u3066\u304a\u304b\u306a\u3044\u3068\u4f7f\u3048\u306a\u3044\u306e\u3067\u3001\u5927\u4f53\u306e\u5834\u5408\u306f\u30b5\u30d6\u30d7\u30ed\u30b8\u30a7\u30af\u30c8\u5316\u3059\u308b\u3068\u601d\u3044\u307e\u3059\u3002\n\nbuild.sbt\nlazy val root = (project in file(\".\")).\n  dependsOn(macroProject)\n\nlazy val macroProject = (project in file(\"macro\")).settings(commonSettings:_*).\n  settings(\n    libraryDependencies ++= Seq(\n      \"org.scala-lang\" % \"scala-reflect\" % scalaVersion.value\n    )\n  ) \n\n\n\n\n\ncode\nimport scala.reflect.macros.Context\nimport scala.language.experimental.macros\n\nobject MyMacro {\n  def myImpl(c: Context)\n            (arg1: c.Expr[Boolean], arg2: c.Expr[Any]): c.Expr[String] = {\n    import c.universe._\n\n    c.Expr(q\"val a = 2;a.toString()\")\n  }\n}\n\n// usage\ndef myFunc(arg1: Boolean, args: Any) : String = macro MyMacro.myImpl\n\n\n\n\nScala meta\nScala meta\u306e\u5834\u5408\u306f\u3001compiler plugin\u3092\u4f7f\u7528\u3059\u308b\u3053\u3068\u306b\u306a\u308b\u306e\u3067\u3001\u305d\u306e\u8a2d\u5b9a\u3082\u5fc5\u8981\u3067\u3059\u3002\n\nbuild.sbt\nlazy val root = (project in file(\".\")).\n  dependsOn(scalaMetaProject)\n\nlazy val scalaMetaProject = (project in file(\"scala-meta\")).\n  settings(\n    libraryDependencies ++= Seq(\n      \"org.scalameta\" %% \"scalameta\" % \"1.3.0\"\n    ),\n    addCompilerPlugin(\n      \"org.scalameta\" % \"paradise\" % \"3.0.0-M5\" cross CrossVersion.full),\n    scalacOptions += \"-Xplugin-require:macroparadise\"\n  )\n\n\n\n\ncode\nimport scala.meta._\nimport scala.collection.immutable.Seq\n\nclass MyMeta extends scala.annotation.StaticAnnotation {\n\n  inline def apply(defn: Any): Any = meta {\n    defn match{\n      case cls: Defn.Class => ...\n      case func: Defn.Def => ...\n    }\n  }\n}\n\n//usage\n\n@MyMeta class ModifiedClass{\n  @MyMeta def hoge() = ...\n}\n\n\n\nmeta\u306f\u3001\u30a2\u30ce\u30c6\u30fc\u30b7\u30e7\u30f3\u306e\u5f62\u3067\u4f7f\u7528\u3057\u307e\u3059\u3002\u305d\u306e\u305f\u3081\u3001\u30a2\u30ce\u30c6\u30fc\u30b7\u30e7\u30f3\u3092\u4ed8\u3051\u308b\u4e8b\u306e\u3067\u304d\u308btrait,class,object,val,var,def\u306a\u3069\u307b\u307c\u5168\u3066\u306e\u30de\u30af\u30ed\u5316\u304c\u51fa\u6765\u308b\u3088\u3046\u306b\u306a\u3063\u3066\u3044\u307e\u3059\u3002\n\u6700\u65b0\u30d0\u30fc\u30b8\u30e7\u30f3\u3084\u8a2d\u5b9a\u65b9\u6cd5\u304c\u5909\u308f\u3063\u3066\u3044\u308b\u5834\u5408\u306f\u3001\u3053\u3053\u3092\u53c2\u8003\u306b\u3059\u308b\u3068\u826f\u3044\u3067\u3059\u3002\nhttps://github.com/scalameta/tutorial\n\nXML\n\nbuild.sbt\nlibraryDependencies ++= Seq(\n  \"org.scala-lang.modules\" %% \"scala-xml\" % \"1.0.6\"\n)\n\n\n\ncode\nval xml = <hello>world</hello>\n\n\n\u6700\u65b0\u30d0\u30fc\u30b8\u30e7\u30f3\u306f\u3053\u3061\u3089\u3067\u78ba\u8a8d\u3057\u3066\u4e0b\u3055\u3044\u3002\nScala\u306e\u5206\u96e2\u3055\u308c\u3066\u3044\u308b\u6a19\u6e96\u30e9\u30a4\u30d6\u30e9\u30ea\u306a\u3069\u3092\u4f7f\u3046\u305f\u3081\u306ebuild.sbt\u8a2d\u5b9a\u30b3\u30d4\u30da\u96c6\u3002\n\n## Parser combinator\n\n\n```scala:build.sbt\nlibraryDependencies ++= Seq(\n  \"org.scala-lang.modules\" %% \"scala-parser-combinators\" % \"1.0.4\"\n)\n```\n\n```scala:code\nimport scala.util.parsing.combinator._\n\n// \u5927\u4f53\u306e\u5834\u5408\u306fRegexParsers\u3067OK\nclass MyParser extends RegexParsers { ... } \n```\n\n\nversion\u304c\u5909\u308f\u3063\u3066\u308b\u53ef\u80fd\u6027\u3042\u308b\u306e\u3067\u3001\u6700\u65b0\u306f[\u3053\u3061\u3089](https://github.com/scala/scala-parser-combinators)\u3092\u78ba\u8a8d\u3057\u3066\u304f\u3060\u3055\u3044\u3002\n\n\n## Reflection\n\n```scala:build.sbt\nlibraryDependencies ++= Seq(\n  \"org.scala-lang\" % \"scala-reflect\" % scalaVersion.value\n)\n```\n\n```scala:code\nimport scala.reflect.runtime.universe._\n\ndef hoge[T]()(implicit tt: TypeTag[T]) = {\n  val t: Type = tt.tpe\n}\n```\n\n\n## Macro\n\nMacro\u306f\u5225\u30d7\u30ed\u30b8\u30a7\u30af\u30c8\u306b\u3057\u3066\u304a\u304b\u306a\u3044\u3068\u4f7f\u3048\u306a\u3044\u306e\u3067\u3001\u5927\u4f53\u306e\u5834\u5408\u306f\u30b5\u30d6\u30d7\u30ed\u30b8\u30a7\u30af\u30c8\u5316\u3059\u308b\u3068\u601d\u3044\u307e\u3059\u3002\n\n```scala:build.sbt\nlazy val root = (project in file(\".\")).\n  dependsOn(macroProject)\n\nlazy val macroProject = (project in file(\"macro\")).settings(commonSettings:_*).\n  settings(\n    libraryDependencies ++= Seq(\n      \"org.scala-lang\" % \"scala-reflect\" % scalaVersion.value\n    )\n  ) \n\n\n```\n\n```scala:code\nimport scala.reflect.macros.Context\nimport scala.language.experimental.macros\n\nobject MyMacro {\n  def myImpl(c: Context)\n            (arg1: c.Expr[Boolean], arg2: c.Expr[Any]): c.Expr[String] = {\n    import c.universe._\n\n    c.Expr(q\"val a = 2;a.toString()\")\n  }\n}\n\n// usage\ndef myFunc(arg1: Boolean, args: Any) : String = macro MyMacro.myImpl\n\n```\n\n\n## Scala meta\n\nScala meta\u306e\u5834\u5408\u306f\u3001compiler plugin\u3092\u4f7f\u7528\u3059\u308b\u3053\u3068\u306b\u306a\u308b\u306e\u3067\u3001\u305d\u306e\u8a2d\u5b9a\u3082\u5fc5\u8981\u3067\u3059\u3002\n\n```scala:build.sbt\nlazy val root = (project in file(\".\")).\n  dependsOn(scalaMetaProject)\n\nlazy val scalaMetaProject = (project in file(\"scala-meta\")).\n  settings(\n    libraryDependencies ++= Seq(\n      \"org.scalameta\" %% \"scalameta\" % \"1.3.0\"\n    ),\n    addCompilerPlugin(\n      \"org.scalameta\" % \"paradise\" % \"3.0.0-M5\" cross CrossVersion.full),\n    scalacOptions += \"-Xplugin-require:macroparadise\"\n  )\n\n```\n\n```scala:code\nimport scala.meta._\nimport scala.collection.immutable.Seq\n\nclass MyMeta extends scala.annotation.StaticAnnotation {\n\n  inline def apply(defn: Any): Any = meta {\n    defn match{\n      case cls: Defn.Class => ...\n      case func: Defn.Def => ...\n    }\n  }\n}\n\n//usage\n\n@MyMeta class ModifiedClass{\n  @MyMeta def hoge() = ...\n}\n\n```\n\nmeta\u306f\u3001\u30a2\u30ce\u30c6\u30fc\u30b7\u30e7\u30f3\u306e\u5f62\u3067\u4f7f\u7528\u3057\u307e\u3059\u3002\u305d\u306e\u305f\u3081\u3001\u30a2\u30ce\u30c6\u30fc\u30b7\u30e7\u30f3\u3092\u4ed8\u3051\u308b\u4e8b\u306e\u3067\u304d\u308btrait,class,object,val,var,def\u306a\u3069\u307b\u307c\u5168\u3066\u306e\u30de\u30af\u30ed\u5316\u304c\u51fa\u6765\u308b\u3088\u3046\u306b\u306a\u3063\u3066\u3044\u307e\u3059\u3002\n\n\u6700\u65b0\u30d0\u30fc\u30b8\u30e7\u30f3\u3084\u8a2d\u5b9a\u65b9\u6cd5\u304c\u5909\u308f\u3063\u3066\u3044\u308b\u5834\u5408\u306f\u3001\u3053\u3053\u3092\u53c2\u8003\u306b\u3059\u308b\u3068\u826f\u3044\u3067\u3059\u3002\nhttps://github.com/scalameta/tutorial\n\n\n## XML\n\n```scala:build.sbt\nlibraryDependencies ++= Seq(\n  \"org.scala-lang.modules\" %% \"scala-xml\" % \"1.0.6\"\n)\n```\n\n```scala:code\nval xml = <hello>world</hello>\n```\n\n\n\u6700\u65b0\u30d0\u30fc\u30b8\u30e7\u30f3\u306f[\u3053\u3061\u3089](https://github.com/scala/scala-module-dependency-sample)\u3067\u78ba\u8a8d\u3057\u3066\u4e0b\u3055\u3044\u3002\n\n"}