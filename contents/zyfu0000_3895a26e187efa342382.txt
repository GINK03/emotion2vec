{"context": " More than 1 year has passed since last update.\nSMDrawEllipse.h\nclass SMDrawEllipse : public Layer\n{\npublic:\n    static SMDrawEllipse* create();\n    void init(float rx, float ry,float a, int segs, Color4F color);\nprivate:\n    void draw(Renderer *renderer, const Mat4& transform, uint32_t flags);\n    void onDraw(const Mat4& transform, uint32_t flags);\n    CustomCommand _customCommand;\nprivate:\n    float rx;\n    float ry;\n    float a;\n    int   segs;\n    Color4F color;\n};\n\n\n\nSMDrawEllipse.cpp\n#include \"SMDrawEllipse.h\"\n\nSMDrawEllipse* SMDrawEllipse::create()\n{\n    return new SMDrawEllipse();\n}\n\nvoid SMDrawEllipse::init(float rx, float ry,float a, int segs, Color4F color)\n{\n    this->rx = rx;\n    this->ry = ry;\n    this->a = a;\n    this->segs = segs;\n    this->color = color;\n}\n\nvoid SMDrawEllipse::onDraw(const Mat4& transform, uint32_t flags)\n{\n    Director::getInstance()->pushMatrix(MATRIX_STACK_TYPE::MATRIX_STACK_MODELVIEW);\n    Director::getInstance()->loadMatrix(MATRIX_STACK_TYPE::MATRIX_STACK_MODELVIEW, transform);\n\n    GLProgram *s_shader = GLProgramCache::getInstance()->getGLProgram(GLProgram::SHADER_NAME_POSITION_U_COLOR);\n    s_shader->retain();\n\n    int s_colorLocation = s_shader->getUniformLocation(\"u_color\");\n    CHECK_GL_ERROR_DEBUG();\n\n\n    const float coef = 2.0f * (float)M_PI / segs;\n\n    int verticeCount = 2 * (segs + 1);\n\n    float* vertices = new float[verticeCount];\n    if(!vertices)\n    {\n        return;\n    }\n    memset(vertices, 0, sizeof(float) * verticeCount);\n\n    float rads, distance, angle, j, k;\n    for(int i = 0; i <= segs; ++i)\n    {\n        rads = i * coef;\n        distance = sqrt(pow(sinf(rads) * rx, 2) + pow(cosf(rads) * ry, 2));\n        angle = atan2(sinf(rads) * rx, cosf(rads) * ry);\n        j = distance * cosf(angle + a);\n        k = distance * sinf(angle + a);\n\n        vertices[i*2] = j * CC_CONTENT_SCALE_FACTOR();\n        vertices[i*2+1] = k * CC_CONTENT_SCALE_FACTOR();\n    }\n\n    s_shader->use();\n    s_shader->setUniformsForBuiltins();\n    s_shader->setUniformLocationWith4fv(s_colorLocation, (GLfloat*) &color.r, 1);\n\n    GL::enableVertexAttribs( GL::VERTEX_ATTRIB_FLAG_POSITION );\n#ifdef EMSCRIPTEN\n    setGLBufferData(vertices, 16);\n    glVertexAttribPointer(GLProgram::VERTEX_ATTRIB_POSITION, 2, GL_FLOAT, GL_FALSE, 0, 0);\n#else\n    glVertexAttribPointer(GLProgram::VERTEX_ATTRIB_POSITION, 2, GL_FLOAT, GL_FALSE, 0, vertices);\n#endif // EMSCRIPTEN\n    glDrawArrays(GL_LINE_LOOP, 0, (segs + 1));\n\n    CC_SAFE_DELETE_ARRAY(vertices);\n\n    CC_INCREMENT_GL_DRAWN_BATCHES_AND_VERTICES(1, (segs + 1));\n\n    Director::getInstance()->popMatrix(MATRIX_STACK_TYPE::MATRIX_STACK_MODELVIEW);\n}\n\nvoid SMDrawEllipse::draw(Renderer *renderer, const Mat4& transform, uint32_t flags)\n{\n    _customCommand.init(_globalZOrder);\n    _customCommand.func = CC_CALLBACK_0(SMDrawEllipse::onDraw, this, transform, flags);\n    renderer->addCommand(&_customCommand);\n}\n\n\n```cpp:SMDrawEllipse.h\nclass SMDrawEllipse : public Layer\n{\npublic:\n    static SMDrawEllipse* create();\n    void init(float rx, float ry,float a, int segs, Color4F color);\nprivate:\n    void draw(Renderer *renderer, const Mat4& transform, uint32_t flags);\n    void onDraw(const Mat4& transform, uint32_t flags);\n    CustomCommand _customCommand;\nprivate:\n    float rx;\n    float ry;\n    float a;\n    int   segs;\n    Color4F color;\n};\n```\n\n```cpp:SMDrawEllipse.cpp\n#include \"SMDrawEllipse.h\"\n\nSMDrawEllipse* SMDrawEllipse::create()\n{\n    return new SMDrawEllipse();\n}\n\nvoid SMDrawEllipse::init(float rx, float ry,float a, int segs, Color4F color)\n{\n    this->rx = rx;\n    this->ry = ry;\n    this->a = a;\n    this->segs = segs;\n    this->color = color;\n}\n\nvoid SMDrawEllipse::onDraw(const Mat4& transform, uint32_t flags)\n{\n    Director::getInstance()->pushMatrix(MATRIX_STACK_TYPE::MATRIX_STACK_MODELVIEW);\n    Director::getInstance()->loadMatrix(MATRIX_STACK_TYPE::MATRIX_STACK_MODELVIEW, transform);\n    \n    GLProgram *s_shader = GLProgramCache::getInstance()->getGLProgram(GLProgram::SHADER_NAME_POSITION_U_COLOR);\n    s_shader->retain();\n    \n    int s_colorLocation = s_shader->getUniformLocation(\"u_color\");\n    CHECK_GL_ERROR_DEBUG();\n    \n    \n    const float coef = 2.0f * (float)M_PI / segs;\n    \n    int verticeCount = 2 * (segs + 1);\n    \n    float* vertices = new float[verticeCount];\n    if(!vertices)\n    {\n        return;\n    }\n    memset(vertices, 0, sizeof(float) * verticeCount);\n    \n    float rads, distance, angle, j, k;\n    for(int i = 0; i <= segs; ++i)\n    {\n        rads = i * coef;\n        distance = sqrt(pow(sinf(rads) * rx, 2) + pow(cosf(rads) * ry, 2));\n        angle = atan2(sinf(rads) * rx, cosf(rads) * ry);\n        j = distance * cosf(angle + a);\n        k = distance * sinf(angle + a);\n        \n        vertices[i*2] = j * CC_CONTENT_SCALE_FACTOR();\n        vertices[i*2+1] = k * CC_CONTENT_SCALE_FACTOR();\n    }\n    \n    s_shader->use();\n    s_shader->setUniformsForBuiltins();\n    s_shader->setUniformLocationWith4fv(s_colorLocation, (GLfloat*) &color.r, 1);\n    \n    GL::enableVertexAttribs( GL::VERTEX_ATTRIB_FLAG_POSITION );\n#ifdef EMSCRIPTEN\n    setGLBufferData(vertices, 16);\n    glVertexAttribPointer(GLProgram::VERTEX_ATTRIB_POSITION, 2, GL_FLOAT, GL_FALSE, 0, 0);\n#else\n    glVertexAttribPointer(GLProgram::VERTEX_ATTRIB_POSITION, 2, GL_FLOAT, GL_FALSE, 0, vertices);\n#endif // EMSCRIPTEN\n    glDrawArrays(GL_LINE_LOOP, 0, (segs + 1));\n    \n    CC_SAFE_DELETE_ARRAY(vertices);\n    \n    CC_INCREMENT_GL_DRAWN_BATCHES_AND_VERTICES(1, (segs + 1));\n    \n    Director::getInstance()->popMatrix(MATRIX_STACK_TYPE::MATRIX_STACK_MODELVIEW);\n}\n\nvoid SMDrawEllipse::draw(Renderer *renderer, const Mat4& transform, uint32_t flags)\n{\n    _customCommand.init(_globalZOrder);\n    _customCommand.func = CC_CALLBACK_0(SMDrawEllipse::onDraw, this, transform, flags);\n    renderer->addCommand(&_customCommand);\n}\n```\n", "tags": ["cocos2d-x"]}