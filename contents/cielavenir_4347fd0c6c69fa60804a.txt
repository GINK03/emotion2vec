{"context": " More than 1 year has passed since last update.\n\n\nPermutation Iterator\nnext_permutation\nURL\n\n\n\n\nC&sharp;/Go/Python/Ruby/VB\n\n\u307e\u3068\u3081\u542b\u3080 http://qiita.com/cielavenir/items/ac96da5e3040c2edb78c\n\n\n\n\nBoo/C&sharp;/Nemerle/VB\nhttp://qiita.com/cielavenir/items/0e07a024049017f7dea2\n\n\n\nJava/Groovy/Scala/Fortran/Pascal\nhttp://qiita.com/cielavenir/items/4347fd0c6c69fa60804a\n\n\n\nD/Go/JavaScript/Lua/R\nhttp://qiita.com/cielavenir/items/9e821d04f574a6623d03\n\n\nPerl\nHSP/PHP/Python/Ruby\nhttp://qiita.com/cielavenir/items/006a878292c5be209231\n\n\n\nC++\n(github\u53c2\u7167)\n\n\n\nJava\n\u30b8\u30a7\u30cd\u30ea\u30af\u30b9\u306e\u4f7f\u3044\u65b9\u3067\u82e6\u52b4\u3057\u3066\u307e\u3059\u2026\u3002\nimport java.util.*;\nclass Main{\n    static <T> void reverse(List<T> a,int start,int size){\n        int end=start+size-1;\n        for(;start<end;start++){\n            T z=a.get(start);a.set(start,a.get(end));a.set(end,z);\n            end--;\n        }\n    }\n    static <T extends Comparable<? super T>> boolean next_permutation(List<T> a,int n){\n        if(n<0||a.size()<n)return false;\n        int i;\n        reverse(a,n,a.size()-n);\n        for(i=a.size()-2;i>=0;i--)if(a.get(i).compareTo(a.get(i+1))<0)break;\n        if(i<0){\n            reverse(a,0,a.size());\n            return false;\n        }\n        int k=i;\n        for(i=a.size()-1;i>=k+1;i--)if(a.get(k).compareTo(a.get(i))<0)break;\n        int l=i;\n        T z=a.get(k);a.set(k,a.get(l));a.set(l,z);\n        reverse(a,k+1,a.size()-(k+1));\n        return true;\n    }\n    static <T extends Comparable<? super T>> boolean next_permutation(List<T> a){\n        return next_permutation(a,a.size());\n    }\n\n    static final int N=6;\n    public static void main(String[]z){\n        int r=0,i;\n        List<Integer>e0=new ArrayList<Integer>(),f0=new ArrayList<Integer>();\n        for(i=0;i<N;i++){e0.add(0);f0.add(0);}\n        for(i=0;i<N;i++){e0.add(1);f0.add(1);}\n        int[] e=new int[N*2+1];\n        int[] f=new int[N*2+1];\n        do{\n            for(i=0;i<N*2;i++)e[i+1]=e[i]+e0.get(i);\n            do{\n                for(i=0;i<N*2;i++){\n                    f[i+1]=f[i]+f0.get(i);\n                    if(e[i]==f[i]&&e[i+1]==f[i+1])break;\n                }\n                if(i==N*2)r++;\n            }while(next_permutation(f0));\n        }while(next_permutation(e0));\n        System.out.println(r);\n    }\n}\n\nGroovy\nEnumerator\u306e\u6982\u5ff5\u304c\u306a\u3044\u3060\u3051\u3067\u3053\u3093\u306a\u306b\u6c5a\u304f\u306a\u308b\u306e\u306d\u2026\u3002\n\u203b\u7cbe\u67fb\u3057\u305f\u3068\u3053\u308d\u30011\u884c\u76ee\u3060\u3051&sharp;\u30b3\u30e1\u30f3\u30c8\u304c\u8a31\u5bb9\u3055\u308c\u308b\u3088\u3046\u3067\u3059\u304c\u3001\u8a18\u8ff0\u3057\u305f\u5834\u5408\u30b7\u30f3\u30bf\u30c3\u30af\u30b9\u30cf\u30a4\u30e9\u30a4\u30c8\u304c\u3046\u307e\u304f\u52d5\u304b\u306a\u304f\u306a\u308b\u3088\u3046\u3067\u3059\u3002\u306a\u306e\u3067\u3001\u30b3\u30fc\u30c9\u30d6\u30ed\u30c3\u30af\u304b\u3089\u306f\u524a\u9664\u3057\u307e\u3057\u305f\u3002chmod +x\u3057\u305f\u3044\u5834\u5408\u306f1\u884c\u76ee\u306b\n    #!/usr/bin/env groovy\n\u3092\u5225\u9014\u5165\u308c\u3066\u4e0b\u3055\u3044\u3002\ndef next_permutation(a,n=a.size){\n    if(n<0||a.size<n)return false\n    if(n<a.size)a[0..a.size()-1]=a[0..n-1]+a[n..-1].reverse()\n    k=(a.size-2..0).find{a[it]<a[it+1]}\n    if(k==null){\n        a[0..a.size()-1]=a.reverse()\n        return false\n    }\n    l=(a.size()-1..k+1).find{a[k]<a[it]}\n    z=a[k];a[k]=a[l];a[l]=z\n    a[0..a.size()-1]=a[0..k]+a[k+1..-1].reverse()\n    return true\n}\n\nN=6\ne0=([0]*N+[1]*N).sort()\nf0=([0]*N+[1]*N).sort()\n//\u5404P\u306f\u7d4c\u8def\u3092\u8868\u3059\u30021\u304c\u7e26\u30010\u304c\u6a2a\u3092\u8868\u3059\u3002\nr=0\ni=0\ne=[0]*(N*2+1)\nf=[0]*(N*2+1)\nwhile(true){\n    (N*2).times{e[it+1]=e[it]+e0[it]}\n    //\u6570\u5b66\u306e\u5ea7\u6a19\u7cfb\u306e\u3088\u3046\u306b\u5de6\u4e0b\u3092A\u3001\u53f3\u4e0a\u3092B\u3068\u3059\u308b\u3068\u3001e\u306e\u5404\u30a4\u30f3\u30c7\u30c3\u30af\u30b9i\u306b\u304a\u3044\u3066\u3001x\u5ea7\u6a19\u304ci-e[i]\u3001y\u5ea7\u6a19\u304ce[i]\u3068\u306a\u308b\u3002\n    while(true){\n        x=!(0..N*2-1).any{\n            f[it+1]=f[it]+f0[it]\n            //i\u756a\u76ee\u306e\u5ea7\u6a19\u3068i+1\u756a\u76ee\u306e\u5ea7\u6a19\u304c\u7b49\u3057\u3051\u308c\u3070\u3001\u300c\u9053\u306b\u91cd\u8907\u304c\u3042\u308b\u300d\u3068\u307f\u306a\u305b\u308b\u3002\n            e[it]==f[it] && e[it+1]==f[it+1]\n        }\n        if(x)r++\n        if(!next_permutation(f0))break;\n    }\n    if(!next_permutation(e0))break\n}\nprintln r // 100360\n\nScala\nchmod +x\u3057\u305f\u3044\u5834\u5408\u306f1\u884c\u76ee\u306b\n    #!/usr/bin/env scala\n    !#\n\u3092\u5165\u308c\u308c\u3070\u3088\u3044\u3067\u3059\u304c\u3001\u305d\u3046\u3059\u308b\u3068scalac\u3067\u30a8\u30e9\u30fc\u306b\u306a\u308b\u306e\u3067\u3001\u30b3\u30fc\u30c9\u30d6\u30ed\u30c3\u30af\u3067\u306f\u3084\u3063\u3066\u304a\u308a\u307e\u305b\u3093\u3002\nimport scala.util.control.Breaks\nobject Main{\n    def reverse[T](a: Array[T],start: Int,size: Int) = {\n        val end=start+size-1\n        for(i <- 0 to size/2-1){\n            val z=a(start+i)\n            a(start+i)=a(end-i)\n            a(end-i)=z\n        }\n    }\n    def next_permutation[T <% Ordered[T]](a: Array[T],n: Int): Boolean = {\n        if(n<0||a.size<n)return false\n        reverse(a,n,a.size-n)\n        var k = -1\n        val b = new Breaks\n        b.breakable{\n            for(i<-(a.size-2) to 0 by -1)if(a(i)<a(i+1)){k=i;b.break}\n        }\n        if(k<0){\n            reverse(a,0,a.size)\n            return false\n        }\n        var l = -1\n        b.breakable{\n            for(i<-a.size-1 to k+1 by -1)if(a(k).compare(a(i))<0){l=i;b.break}\n        }\n        val z=a(k);a(k)=a(l);a(l)=z\n        reverse(a,k+1,a.size-(k+1))\n        return true\n    }\n    def next_permutation[T <% Ordered[T]](a: Array[T]): Boolean = {\n        return next_permutation(a,a.size)\n    }\n    def main(args: Array[String]) = {\n        val N=6\n        val b = new Breaks\n        var r=0\n        val e0=new Array[Int](N*2)\n        val f0=new Array[Int](N*2)\n        for(i<-Range(0,N)){e0(N+i)=1;f0(N+i)=1}\n        val e=new Array[Int](N*2+1)\n        val f=new Array[Int](N*2+1)\n        do{\n            for(i<-Range(0,N*2))e(i+1)=e(i)+e0(i)\n            do{\n                var x = 1\n                b.breakable{\n                    for(i<-Range(0,N*2)){\n                        f(i+1)=f(i)+f0(i)\n                        if(e(i)==f(i)&&e(i+1)==f(i+1)){x=0;b.break}\n                    }\n                }\n                r+=x\n            }while(next_permutation(f0))\n        }while(next_permutation(e0))\n        println(r);\n    }\n}\n\nFortran\nimplicit none\ninterface\nsubroutine reverse(a_,start_,size_)\n    integer a_(*)\n    integer start_,size_\nend\nlogical function next_permutation(a_,n_)\n    integer a_(:)\n    integer n_\nend\nend interface\ninteger,parameter::N=6\ninteger r,i,x\ninteger e0(N*2)\ninteger f0(N*2)\ninteger e(N*2+1)\ninteger f(N*2+1)\ndo i=1,N\n    e0(i)=0\n    f0(i)=0\n    e0(N+i)=1\n    f0(N+i)=1\nenddo\nr=0\ne(1)=0\nf(1)=0\ndo while(.true.)\n    do i=1,N*2\n        e(i+1)=e(i)+e0(i)\n    enddo\n    do while(.true.)\n        x=1\n        do i=1,N*2\n            f(i+1)=f(i)+f0(i)\n            if((e(i).eq.f(i)).and.(e(i+1).eq.f(i+1))) then\n                x=0\n                exit\n            endif\n        enddo\n        r=r+x\n        if(.not.next_permutation(f0,size(f0))) exit\n    enddo\n    if(.not.next_permutation(e0,size(e0))) exit\nenddo\nwrite(*,\"(i0)\"),r\nend\n\nsubroutine reverse(a_,start_,size_)\n    integer a_(*)\n    integer start_,size_\n    integer end_,i_\n    integer z_\n    end_=start_+size_-1\n    do i_=0,size_/2-1\n        z_=a_(start_+i_)\n        a_(start_+i_)=a_(end_-i_)\n        a_(end_-i_)=z_\n    end do\nend\n\nlogical function next_permutation(a_,n_)\n    integer a_(:)\n    integer n_\n    integer i_,k_,l_\n    integer z_\n    next_permutation=.false.\n    if((0.le.n_).and.(n_.le.size(a_))) then\n        call reverse(a_,n_,size(a_)+1-n_)\n        i_=size(a_)-1\n        do while(i_.ge.1)\n            if(a_(i_).lt.a_(i_+1)) then\n                exit\n            endif\n            i_=i_-1\n        enddo\n        if(i_.lt.1) then\n            call reverse(a_,1,size(a_))\n        else\n            k_=i_\n            i_=size(a_)\n            do while(i_.ge.k_+1)\n                if(a_(k_).lt.a_(i_)) then\n                    exit\n                endif\n                i_=i_-1\n            enddo\n            l_=i_;\n            z_=a_(k_)\n            a_(k_)=a_(l_)\n            a_(l_)=z_\n            call reverse(a_,k_+1,size(a_)+1-(k_+1))\n            next_permutation=.true.\n        endif\n    endif\nend\n\nPascal\n{$apptype console} //Delphi6\nprogram CodeIQRoute;\nvar\nN:longint;\nr:longint;\ni:longint;\nx:longint;\ne0:array of longint;\nf0:array of longint;\ne:array of longint;\nf:array of longint;\n\nprocedure reverse(var a:array of longint;start:longint;size:longint);\nvar\n    en,i:longint;\n    z:longint;\nbegin\n    en:=start+size-1;\n    for i:=0 to trunc(size/2-1) do begin\n        z:=a[start+i];\n        a[start+i]:=a[en-i];\n        a[en-i]:=z;\n    end;\nend;\n\nfunction next_permutation(var a:array of longint;n:longint):boolean;\nvar\n    i,k,l:longint;\n    z:longint;\nbegin\n    next_permutation:=false;\n    if (0<=n) and (n<=length(a)) then begin\n        reverse(a,n,length(a)-n);\n        i:=length(a)-2;\n        while i>=0 do begin\n            if a[i]<a[i+1] then break;\n            i:=i-1;\n        end;\n        if i<0 then begin\n            reverse(a,0,length(a));\n        end else begin\n            k:=i;\n            i:=length(a)-1;\n            while i>=k+1 do begin\n                if a[k]<a[i] then break;\n                i:=i-1;\n            end;\n            l:=i;\n            z:=a[k];\n            a[k]:=a[l];\n            a[l]:=z;\n            reverse(a,k+1,length(a)-(k+1));\n            next_permutation:=true;\n        end;\n    end;\nend;\n\nbegin\nN:=6;\nr:=0;\nsetlength(e0,N*2);\nsetlength(f0,N*2);\nfor i:=0 to N-1 do begin\n    e0[N+i]:=1;\n    f0[N+i]:=1;\nend;\nsetlength(e,N*2+1);\nsetlength(f,N*2+1);\nrepeat\n    for i:=0 to N*2-1 do e[i+1]:=e[i]+e0[i];\n    repeat\n        x:=1;\n        for i:=0 to N*2-1 do begin\n            f[i+1]:=f[i]+f0[i];\n            if (e[i]=f[i]) and (e[i+1]=f[i+1]) then begin\n                x:=0;\n                break;\n            end;\n        end;\n        r:=r+x;\n    until not next_permutation(f0,length(f0));\nuntil not next_permutation(e0,length(e0));\nwriteln(r);\nend.\n\n|Permutation Iterator|next_permutation|URL|\n|:--|:--|:--|\n|C&sharp;/Go/Python/Ruby/VB||\u307e\u3068\u3081\u542b\u3080 http://qiita.com/cielavenir/items/ac96da5e3040c2edb78c|\n||Boo/C&sharp;/Nemerle/VB|http://qiita.com/cielavenir/items/0e07a024049017f7dea2|\n||Java/Groovy/Scala/Fortran/Pascal|http://qiita.com/cielavenir/items/4347fd0c6c69fa60804a|\n||D/Go/JavaScript/Lua/R|http://qiita.com/cielavenir/items/9e821d04f574a6623d03|\n|Perl|HSP/PHP/Python/Ruby|http://qiita.com/cielavenir/items/006a878292c5be209231|\n||C++|(github\u53c2\u7167)|\n\nJava\n\u30b8\u30a7\u30cd\u30ea\u30af\u30b9\u306e\u4f7f\u3044\u65b9\u3067\u82e6\u52b4\u3057\u3066\u307e\u3059\u2026\u3002\n\n```java\nimport java.util.*;\nclass Main{\n\tstatic <T> void reverse(List<T> a,int start,int size){\n\t\tint end=start+size-1;\n\t\tfor(;start<end;start++){\n\t\t\tT z=a.get(start);a.set(start,a.get(end));a.set(end,z);\n\t\t\tend--;\n\t\t}\n\t}\n\tstatic <T extends Comparable<? super T>> boolean next_permutation(List<T> a,int n){\n\t\tif(n<0||a.size()<n)return false;\n\t\tint i;\n\t\treverse(a,n,a.size()-n);\n\t\tfor(i=a.size()-2;i>=0;i--)if(a.get(i).compareTo(a.get(i+1))<0)break;\n\t\tif(i<0){\n\t\t\treverse(a,0,a.size());\n\t\t\treturn false;\n\t\t}\n\t\tint k=i;\n\t\tfor(i=a.size()-1;i>=k+1;i--)if(a.get(k).compareTo(a.get(i))<0)break;\n\t\tint l=i;\n\t\tT z=a.get(k);a.set(k,a.get(l));a.set(l,z);\n\t\treverse(a,k+1,a.size()-(k+1));\n\t\treturn true;\n\t}\n\tstatic <T extends Comparable<? super T>> boolean next_permutation(List<T> a){\n\t\treturn next_permutation(a,a.size());\n\t}\n\n\tstatic final int N=6;\n\tpublic static void main(String[]z){\n\t\tint r=0,i;\n\t\tList<Integer>e0=new ArrayList<Integer>(),f0=new ArrayList<Integer>();\n\t\tfor(i=0;i<N;i++){e0.add(0);f0.add(0);}\n\t\tfor(i=0;i<N;i++){e0.add(1);f0.add(1);}\n\t\tint[] e=new int[N*2+1];\n\t\tint[] f=new int[N*2+1];\n\t\tdo{\n\t\t\tfor(i=0;i<N*2;i++)e[i+1]=e[i]+e0.get(i);\n\t\t\tdo{\n\t\t\t\tfor(i=0;i<N*2;i++){\n\t\t\t\t\tf[i+1]=f[i]+f0.get(i);\n\t\t\t\t\tif(e[i]==f[i]&&e[i+1]==f[i+1])break;\n\t\t\t\t}\n\t\t\t\tif(i==N*2)r++;\n\t\t\t}while(next_permutation(f0));\n\t\t}while(next_permutation(e0));\n\t\tSystem.out.println(r);\n\t}\n}\n```\n\nGroovy\nEnumerator\u306e\u6982\u5ff5\u304c\u306a\u3044\u3060\u3051\u3067\u3053\u3093\u306a\u306b\u6c5a\u304f\u306a\u308b\u306e\u306d\u2026\u3002\n\u203b\u7cbe\u67fb\u3057\u305f\u3068\u3053\u308d\u30011\u884c\u76ee\u3060\u3051&sharp;\u30b3\u30e1\u30f3\u30c8\u304c\u8a31\u5bb9\u3055\u308c\u308b\u3088\u3046\u3067\u3059\u304c\u3001\u8a18\u8ff0\u3057\u305f\u5834\u5408\u30b7\u30f3\u30bf\u30c3\u30af\u30b9\u30cf\u30a4\u30e9\u30a4\u30c8\u304c\u3046\u307e\u304f\u52d5\u304b\u306a\u304f\u306a\u308b\u3088\u3046\u3067\u3059\u3002\u306a\u306e\u3067\u3001\u30b3\u30fc\u30c9\u30d6\u30ed\u30c3\u30af\u304b\u3089\u306f\u524a\u9664\u3057\u307e\u3057\u305f\u3002chmod +x\u3057\u305f\u3044\u5834\u5408\u306f1\u884c\u76ee\u306b\n    #!/usr/bin/env groovy\n\u3092\u5225\u9014\u5165\u308c\u3066\u4e0b\u3055\u3044\u3002\n\n```groovy\ndef next_permutation(a,n=a.size){\n\tif(n<0||a.size<n)return false\n\tif(n<a.size)a[0..a.size()-1]=a[0..n-1]+a[n..-1].reverse()\n\tk=(a.size-2..0).find{a[it]<a[it+1]}\n\tif(k==null){\n\t\ta[0..a.size()-1]=a.reverse()\n\t\treturn false\n\t}\n\tl=(a.size()-1..k+1).find{a[k]<a[it]}\n\tz=a[k];a[k]=a[l];a[l]=z\n\ta[0..a.size()-1]=a[0..k]+a[k+1..-1].reverse()\n\treturn true\n}\n\nN=6\ne0=([0]*N+[1]*N).sort()\nf0=([0]*N+[1]*N).sort()\n//\u5404P\u306f\u7d4c\u8def\u3092\u8868\u3059\u30021\u304c\u7e26\u30010\u304c\u6a2a\u3092\u8868\u3059\u3002\nr=0\ni=0\ne=[0]*(N*2+1)\nf=[0]*(N*2+1)\nwhile(true){\n\t(N*2).times{e[it+1]=e[it]+e0[it]}\n\t//\u6570\u5b66\u306e\u5ea7\u6a19\u7cfb\u306e\u3088\u3046\u306b\u5de6\u4e0b\u3092A\u3001\u53f3\u4e0a\u3092B\u3068\u3059\u308b\u3068\u3001e\u306e\u5404\u30a4\u30f3\u30c7\u30c3\u30af\u30b9i\u306b\u304a\u3044\u3066\u3001x\u5ea7\u6a19\u304ci-e[i]\u3001y\u5ea7\u6a19\u304ce[i]\u3068\u306a\u308b\u3002\n\twhile(true){\n\t\tx=!(0..N*2-1).any{\n\t\t\tf[it+1]=f[it]+f0[it]\n\t\t\t//i\u756a\u76ee\u306e\u5ea7\u6a19\u3068i+1\u756a\u76ee\u306e\u5ea7\u6a19\u304c\u7b49\u3057\u3051\u308c\u3070\u3001\u300c\u9053\u306b\u91cd\u8907\u304c\u3042\u308b\u300d\u3068\u307f\u306a\u305b\u308b\u3002\n\t\t\te[it]==f[it] && e[it+1]==f[it+1]\n\t\t}\n\t\tif(x)r++\n\t\tif(!next_permutation(f0))break;\n\t}\n\tif(!next_permutation(e0))break\n}\nprintln r // 100360\n```\n\nScala\nchmod +x\u3057\u305f\u3044\u5834\u5408\u306f1\u884c\u76ee\u306b\n    #!/usr/bin/env scala\n    !#\n\u3092\u5165\u308c\u308c\u3070\u3088\u3044\u3067\u3059\u304c\u3001\u305d\u3046\u3059\u308b\u3068scalac\u3067\u30a8\u30e9\u30fc\u306b\u306a\u308b\u306e\u3067\u3001\u30b3\u30fc\u30c9\u30d6\u30ed\u30c3\u30af\u3067\u306f\u3084\u3063\u3066\u304a\u308a\u307e\u305b\u3093\u3002\n\n```scala\nimport scala.util.control.Breaks\nobject Main{\n\tdef reverse[T](a: Array[T],start: Int,size: Int) = {\n\t\tval end=start+size-1\n\t\tfor(i <- 0 to size/2-1){\n\t\t\tval z=a(start+i)\n\t\t\ta(start+i)=a(end-i)\n\t\t\ta(end-i)=z\n\t\t}\n\t}\n\tdef next_permutation[T <% Ordered[T]](a: Array[T],n: Int): Boolean = {\n\t\tif(n<0||a.size<n)return false\n\t\treverse(a,n,a.size-n)\n\t\tvar k = -1\n\t\tval b = new Breaks\n\t\tb.breakable{\n\t\t\tfor(i<-(a.size-2) to 0 by -1)if(a(i)<a(i+1)){k=i;b.break}\n\t\t}\n\t\tif(k<0){\n\t\t\treverse(a,0,a.size)\n\t\t\treturn false\n\t\t}\n\t\tvar l = -1\n\t\tb.breakable{\n\t\t\tfor(i<-a.size-1 to k+1 by -1)if(a(k).compare(a(i))<0){l=i;b.break}\n\t\t}\n\t\tval z=a(k);a(k)=a(l);a(l)=z\n\t\treverse(a,k+1,a.size-(k+1))\n\t\treturn true\n\t}\n\tdef next_permutation[T <% Ordered[T]](a: Array[T]): Boolean = {\n\t\treturn next_permutation(a,a.size)\n\t}\n\tdef main(args: Array[String]) = {\n\t\tval N=6\n\t\tval b = new Breaks\n\t\tvar r=0\n\t\tval e0=new Array[Int](N*2)\n\t\tval f0=new Array[Int](N*2)\n\t\tfor(i<-Range(0,N)){e0(N+i)=1;f0(N+i)=1}\n\t\tval e=new Array[Int](N*2+1)\n\t\tval f=new Array[Int](N*2+1)\n\t\tdo{\n\t\t\tfor(i<-Range(0,N*2))e(i+1)=e(i)+e0(i)\n\t\t\tdo{\n\t\t\t\tvar x = 1\n\t\t\t\tb.breakable{\n\t\t\t\t\tfor(i<-Range(0,N*2)){\n\t\t\t\t\t\tf(i+1)=f(i)+f0(i)\n\t\t\t\t\t\tif(e(i)==f(i)&&e(i+1)==f(i+1)){x=0;b.break}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tr+=x\n\t\t\t}while(next_permutation(f0))\n\t\t}while(next_permutation(e0))\n\t\tprintln(r);\n\t}\n}\n```\n\nFortran\n\n```fortran\nimplicit none\ninterface\nsubroutine reverse(a_,start_,size_)\n\tinteger a_(*)\n\tinteger start_,size_\nend\nlogical function next_permutation(a_,n_)\n\tinteger a_(:)\n\tinteger n_\nend\nend interface\ninteger,parameter::N=6\ninteger r,i,x\ninteger e0(N*2)\ninteger f0(N*2)\ninteger e(N*2+1)\ninteger f(N*2+1)\ndo i=1,N\n\te0(i)=0\n\tf0(i)=0\n\te0(N+i)=1\n\tf0(N+i)=1\nenddo\nr=0\ne(1)=0\nf(1)=0\ndo while(.true.)\n\tdo i=1,N*2\n\t\te(i+1)=e(i)+e0(i)\n\tenddo\n\tdo while(.true.)\n\t\tx=1\n\t\tdo i=1,N*2\n\t\t\tf(i+1)=f(i)+f0(i)\n\t\t\tif((e(i).eq.f(i)).and.(e(i+1).eq.f(i+1))) then\n\t\t\t\tx=0\n\t\t\t\texit\n\t\t\tendif\n\t\tenddo\n\t\tr=r+x\n\t\tif(.not.next_permutation(f0,size(f0))) exit\n\tenddo\n\tif(.not.next_permutation(e0,size(e0))) exit\nenddo\nwrite(*,\"(i0)\"),r\nend\n\nsubroutine reverse(a_,start_,size_)\n\tinteger a_(*)\n\tinteger start_,size_\n\tinteger end_,i_\n\tinteger z_\n\tend_=start_+size_-1\n\tdo i_=0,size_/2-1\n\t\tz_=a_(start_+i_)\n\t\ta_(start_+i_)=a_(end_-i_)\n\t\ta_(end_-i_)=z_\n\tend do\nend\n\nlogical function next_permutation(a_,n_)\n\tinteger a_(:)\n\tinteger n_\n\tinteger i_,k_,l_\n\tinteger z_\n\tnext_permutation=.false.\n\tif((0.le.n_).and.(n_.le.size(a_))) then\n\t\tcall reverse(a_,n_,size(a_)+1-n_)\n\t\ti_=size(a_)-1\n\t\tdo while(i_.ge.1)\n\t\t\tif(a_(i_).lt.a_(i_+1)) then\n\t\t\t\texit\n\t\t\tendif\n\t\t\ti_=i_-1\n\t\tenddo\n\t\tif(i_.lt.1) then\n\t\t\tcall reverse(a_,1,size(a_))\n\t\telse\n\t\t\tk_=i_\n\t\t\ti_=size(a_)\n\t\t\tdo while(i_.ge.k_+1)\n\t\t\t\tif(a_(k_).lt.a_(i_)) then\n\t\t\t\t\texit\n\t\t\t\tendif\n\t\t\t\ti_=i_-1\n\t\t\tenddo\n\t\t\tl_=i_;\n\t\t\tz_=a_(k_)\n\t\t\ta_(k_)=a_(l_)\n\t\t\ta_(l_)=z_\n\t\t\tcall reverse(a_,k_+1,size(a_)+1-(k_+1))\n\t\t\tnext_permutation=.true.\n\t\tendif\n\tendif\nend\n```\n\nPascal\n\n```delphi\n{$apptype console} //Delphi6\nprogram CodeIQRoute;\nvar\nN:longint;\nr:longint;\ni:longint;\nx:longint;\ne0:array of longint;\nf0:array of longint;\ne:array of longint;\nf:array of longint;\n\nprocedure reverse(var a:array of longint;start:longint;size:longint);\nvar\n\ten,i:longint;\n\tz:longint;\nbegin\n\ten:=start+size-1;\n\tfor i:=0 to trunc(size/2-1) do begin\n\t\tz:=a[start+i];\n\t\ta[start+i]:=a[en-i];\n\t\ta[en-i]:=z;\n\tend;\nend;\n\nfunction next_permutation(var a:array of longint;n:longint):boolean;\nvar\n\ti,k,l:longint;\n\tz:longint;\nbegin\n\tnext_permutation:=false;\n\tif (0<=n) and (n<=length(a)) then begin\n\t\treverse(a,n,length(a)-n);\n\t\ti:=length(a)-2;\n\t\twhile i>=0 do begin\n\t\t\tif a[i]<a[i+1] then break;\n\t\t\ti:=i-1;\n\t\tend;\n\t\tif i<0 then begin\n\t\t\treverse(a,0,length(a));\n\t\tend else begin\n\t\t\tk:=i;\n\t\t\ti:=length(a)-1;\n\t\t\twhile i>=k+1 do begin\n\t\t\t\tif a[k]<a[i] then break;\n\t\t\t\ti:=i-1;\n\t\t\tend;\n\t\t\tl:=i;\n\t\t\tz:=a[k];\n\t\t\ta[k]:=a[l];\n\t\t\ta[l]:=z;\n\t\t\treverse(a,k+1,length(a)-(k+1));\n\t\t\tnext_permutation:=true;\n\t\tend;\n\tend;\nend;\n\nbegin\nN:=6;\nr:=0;\nsetlength(e0,N*2);\nsetlength(f0,N*2);\nfor i:=0 to N-1 do begin\n\te0[N+i]:=1;\n\tf0[N+i]:=1;\nend;\nsetlength(e,N*2+1);\nsetlength(f,N*2+1);\nrepeat\n\tfor i:=0 to N*2-1 do e[i+1]:=e[i]+e0[i];\n\trepeat\n\t\tx:=1;\n\t\tfor i:=0 to N*2-1 do begin\n\t\t\tf[i+1]:=f[i]+f0[i];\n\t\t\tif (e[i]=f[i]) and (e[i+1]=f[i+1]) then begin\n\t\t\t\tx:=0;\n\t\t\t\tbreak;\n\t\t\tend;\n\t\tend;\n\t\tr:=r+x;\n\tuntil not next_permutation(f0,length(f0));\nuntil not next_permutation(e0,length(e0));\nwriteln(r);\nend.\n```", "tags": ["Java", "Groovy", "Scala", "Fortran", "Pascal"]}