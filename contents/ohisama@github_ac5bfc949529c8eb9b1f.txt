{"tags": ["C++", "paiza"], "context": "\n\n\u6982\u8981\nC++\u3067\u30ba\u30f3\u30c9\u30b3\u30b2\u30c3\u30bf\u30fc\u3084\u3063\u3066\u307f\u305f\u3002\n\n\u5b9f\u969b\nhttps://paiza.io/projects/v9XrhBulkRzb5bItttJhVA\n\n\u30b5\u30f3\u30d7\u30eb\u30b3\u30fc\u30c9\n#include <stdio.h>\n#include <sys/socket.h>\n#include <arpa/inet.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <netdb.h>\n#include <string.h>\n#include <iostream>\nusing namespace std;\n\nint create_tcp_socket();\nchar * get_ip(char * host);\nchar * build_get_query(char * host, char * page);\n#define PORT        80\n#define USERAGENT   \"Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1)\"\nstring zundoko()\n{\n    struct sockaddr_in * remote;\n    int sock;\n    int tmpres;\n    char * ip;\n    char * get;\n    char buf[BUFSIZ + 1];\n    char * host = \"ohijs0.paas.jp-e1.cloudn-service.com\";\n    char * page = \"/zundoko\";\n    sock = create_tcp_socket();\n    ip = get_ip(host);\n    remote = (struct sockaddr_in *) malloc(sizeof(struct sockaddr_in *));\n    remote->sin_family = AF_INET;\n    tmpres = inet_pton(AF_INET, ip, (void *) (&(remote->sin_addr.s_addr)));\n    if (tmpres < 0)\n    {\n        perror(\"Can't set remote->sin_addr.s_addr\");\n        exit(1);\n    }\n    else if (tmpres == 0)\n    {\n        fprintf(stderr, \"%s is not a valid IP address\\n\", ip);\n        exit(1);\n    }\n    remote->sin_port = htons(PORT);\n    if (connect(sock, (struct sockaddr *) remote, sizeof(struct sockaddr)) < 0)\n    {\n        perror(\"Could not connect\");\n        exit(1);\n    }\n    get = build_get_query(host, page);\n    int sent = 0;\n    while (sent < strlen(get))\n    {\n        tmpres = send(sock, get + sent, strlen(get) - sent, 0);\n        if (tmpres == -1)\n        {\n            perror(\"Can't send query\");\n            exit(1);\n        }\n        sent += tmpres;\n    }\n    memset(buf, 0, sizeof(buf));\n    int htmlstart = 0;\n    char * htmlcontent;\n    while ((tmpres = recv(sock, buf, BUFSIZ, 0)) > 0)\n    {\n        if (htmlstart == 0)\n        {\n            htmlcontent = strstr(buf, \"\\r\\n\\r\\n\");\n            if (htmlcontent != NULL)\n            {\n                htmlstart = 1;\n                htmlcontent += 4;\n            }\n        }\n        else\n        {\n            htmlcontent = buf;\n        }\n        memset(buf, 0, tmpres);\n    }\n    if (tmpres < 0)\n    {\n        perror(\"Error receiving data\");\n    }\n    free(get);\n    free(remote);\n    free(ip);\n    close(sock);\n    return htmlcontent;\n}\nint create_tcp_socket()\n{\n    int sock;\n    if ((sock = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP)) < 0)\n    {\n        perror(\"Can't create TCP socket\");\n        exit(1);\n    }\n    return sock;\n}\nchar * get_ip(char * host)\n{\n    struct hostent * hent;\n    int iplen = 15;\n    char * ip = (char *) malloc(iplen + 1);\n    memset(ip, 0, iplen + 1);\n    if ((hent = gethostbyname(host)) == NULL)\n    {\n        herror(\"Can't get IP\");\n        exit(1);\n    }\n    if (inet_ntop(AF_INET, (void *) hent->h_addr_list[0], ip, iplen) == NULL)\n    {\n        perror(\"Can't resolve host\");\n        exit(1);\n    }\n    return ip;\n}\nchar * build_get_query(char * host, char * page)\n{\n    char * query;\n    char * getpage = page;\n    char * tpl = \"GET /%s HTTP/1.0\\r\\nHost: %s\\r\\nUser-Agent: %s\\r\\n\\r\\n\";\n    if (getpage[0] == '/')\n    {\n        getpage = getpage + 1;\n    }\n    query = (char *) malloc(strlen(host) + strlen(getpage) + strlen(USERAGENT) + strlen(tpl) - 5);\n    sprintf(query, tpl, getpage, host, USERAGENT);\n    return query;\n}\nint main()\n{\n    int z = 0;\n    int c = 0;\n    string s;\n    do \n    {\n        z = c ? (z + 1) : 0;\n        s = zundoko();\n        if (s == \"\u30ba\u30f3\") c = 1;\n        else c = 0;\n        c = (rand() >> 3) & 1;\n        printf(\"%s \", c ? \"\u30ba\u30f3\" : \"\u30c9\u30b3\");\n    } while (z < 4 || c);\n    printf(\"\u30ad\u30fb\u30e8\u30fb\u30b7!\");\n}\n\n\n#\u6982\u8981\nC++\u3067\u30ba\u30f3\u30c9\u30b3\u30b2\u30c3\u30bf\u30fc\u3084\u3063\u3066\u307f\u305f\u3002\n#\u5b9f\u969b\nhttps://paiza.io/projects/v9XrhBulkRzb5bItttJhVA\n#\u30b5\u30f3\u30d7\u30eb\u30b3\u30fc\u30c9\n```\n#include <stdio.h>\n#include <sys/socket.h>\n#include <arpa/inet.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <netdb.h>\n#include <string.h>\n#include <iostream>\nusing namespace std;\n\nint create_tcp_socket();\nchar * get_ip(char * host);\nchar * build_get_query(char * host, char * page);\n#define PORT        80\n#define USERAGENT   \"Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1)\"\nstring zundoko()\n{\n    struct sockaddr_in * remote;\n    int sock;\n    int tmpres;\n    char * ip;\n    char * get;\n    char buf[BUFSIZ + 1];\n    char * host = \"ohijs0.paas.jp-e1.cloudn-service.com\";\n    char * page = \"/zundoko\";\n    sock = create_tcp_socket();\n    ip = get_ip(host);\n    remote = (struct sockaddr_in *) malloc(sizeof(struct sockaddr_in *));\n    remote->sin_family = AF_INET;\n    tmpres = inet_pton(AF_INET, ip, (void *) (&(remote->sin_addr.s_addr)));\n    if (tmpres < 0)\n    {\n        perror(\"Can't set remote->sin_addr.s_addr\");\n        exit(1);\n    }\n    else if (tmpres == 0)\n    {\n        fprintf(stderr, \"%s is not a valid IP address\\n\", ip);\n        exit(1);\n    }\n    remote->sin_port = htons(PORT);\n    if (connect(sock, (struct sockaddr *) remote, sizeof(struct sockaddr)) < 0)\n    {\n        perror(\"Could not connect\");\n        exit(1);\n    }\n    get = build_get_query(host, page);\n    int sent = 0;\n    while (sent < strlen(get))\n    {\n        tmpres = send(sock, get + sent, strlen(get) - sent, 0);\n        if (tmpres == -1)\n        {\n            perror(\"Can't send query\");\n            exit(1);\n        }\n        sent += tmpres;\n    }\n    memset(buf, 0, sizeof(buf));\n    int htmlstart = 0;\n    char * htmlcontent;\n    while ((tmpres = recv(sock, buf, BUFSIZ, 0)) > 0)\n    {\n        if (htmlstart == 0)\n        {\n            htmlcontent = strstr(buf, \"\\r\\n\\r\\n\");\n            if (htmlcontent != NULL)\n            {\n                htmlstart = 1;\n                htmlcontent += 4;\n            }\n        }\n        else\n        {\n            htmlcontent = buf;\n        }\n        memset(buf, 0, tmpres);\n    }\n    if (tmpres < 0)\n    {\n        perror(\"Error receiving data\");\n    }\n    free(get);\n    free(remote);\n    free(ip);\n    close(sock);\n    return htmlcontent;\n}\nint create_tcp_socket()\n{\n    int sock;\n    if ((sock = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP)) < 0)\n    {\n        perror(\"Can't create TCP socket\");\n        exit(1);\n    }\n    return sock;\n}\nchar * get_ip(char * host)\n{\n    struct hostent * hent;\n    int iplen = 15;\n    char * ip = (char *) malloc(iplen + 1);\n    memset(ip, 0, iplen + 1);\n    if ((hent = gethostbyname(host)) == NULL)\n    {\n        herror(\"Can't get IP\");\n        exit(1);\n    }\n    if (inet_ntop(AF_INET, (void *) hent->h_addr_list[0], ip, iplen) == NULL)\n    {\n        perror(\"Can't resolve host\");\n        exit(1);\n    }\n    return ip;\n}\nchar * build_get_query(char * host, char * page)\n{\n    char * query;\n    char * getpage = page;\n    char * tpl = \"GET /%s HTTP/1.0\\r\\nHost: %s\\r\\nUser-Agent: %s\\r\\n\\r\\n\";\n    if (getpage[0] == '/')\n    {\n        getpage = getpage + 1;\n    }\n    query = (char *) malloc(strlen(host) + strlen(getpage) + strlen(USERAGENT) + strlen(tpl) - 5);\n    sprintf(query, tpl, getpage, host, USERAGENT);\n    return query;\n}\nint main()\n{\n    int z = 0;\n    int c = 0;\n    string s;\n    do \n    {\n        z = c ? (z + 1) : 0;\n        s = zundoko();\n        if (s == \"\u30ba\u30f3\") c = 1;\n        else c = 0;\n        c = (rand() >> 3) & 1;\n        printf(\"%s \", c ? \"\u30ba\u30f3\" : \"\u30c9\u30b3\");\n    } while (z < 4 || c);\n    printf(\"\u30ad\u30fb\u30e8\u30fb\u30b7!\");\n}\n\n```\n"}