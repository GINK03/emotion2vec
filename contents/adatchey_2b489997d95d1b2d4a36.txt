{"context": " More than 1 year has passed since last update.\u524d\u56de\u306e\u7d9a\u304d\u3067\u3059.\noperator==\u3067\u5024\u6bd4\u8f03\u3092\u3057\u3066\u3044\u306a\u304b\u3063\u305f\u306e\u3067, \u3067\u304d\u308b\u3088\u3046\u306b\u3057\u307e\u3057\u305f.\n\u672c\u5bb6\u306f\u3053\u3061\u3089: http://www.boost.org/doc/libs/1_57_0/doc/html/variant.html\n\nvariant_util.h\n//\n//  variant_util.h\n//  \u30e1\u30bf\u95a2\u6570\u7fa4\n//  Created by atosh on 2/22/15.\n//\n\n#ifndef VARIANT_UTIL_H_\n#define VARIANT_UTIL_H_\n\n#include <type_traits>\n\nnamespace fenf {\nnamespace detail {\n\ntemplate <typename T, typename... Rest>\nstruct max_size_t {\nprivate:\n    static const int kRestMax = max_size_t<Rest...>::value;\n\npublic:\n    static const int value = sizeof(T) > kRestMax ? sizeof(T) : kRestMax;\n};\n\ntemplate <typename T>\nstruct max_size_t<T> {\n    static const int value = sizeof(T);\n};\n\ntemplate <typename Target, typename T, typename... Rest>\nstruct contains_t {\n    static const bool value = (std::is_same<Target, T>::value) ? true : contains_t<Target, Rest...>::value;\n};\n\ntemplate <typename Target, typename T>\nstruct contains_t<Target, T> {\n    static const bool value = (std::is_same<Target, T>::value);\n};\n\ntemplate <int I, typename Target, typename T, typename... Rest>\nstruct index_of_impl_t {\n    static const int value = (std::is_same<Target, T>::value) ? I : index_of_impl_t<I + 1, Target, Rest...>::value;\n};\n\ntemplate <int I, typename Target, typename T>\nstruct index_of_impl_t<I, Target, T> {\n    static const int value = (std::is_same<Target, T>::value) ? I : -1;\n};\n\ntemplate <typename Target, typename... Types>\nstruct index_of_t {\n    static const int value = index_of_impl_t<0, Target, Types...>::value;\n};\n\ntemplate <int I, typename T, typename... Rest>\nstruct at_t {\n    using type = typename at_t<I - 1, Rest...>::type;\n};\n\ntemplate <typename T, typename... Rest>\nstruct at_t<0, T, Rest...> {\n    using type = T;\n};\n\n}  // namespace detail\n}  // namespace fenf\n\n#endif  // VARIANT_UTIL_H_\n\n\n\nvariant_visitor.h\n//\n//  variant_visitor.h\n//  apply_visitor \u306e\u5b9a\u7fa9\n//  Created by atosh on 2/22/15.\n//\n\n#ifndef VARIANT_VISITOR_H_\n#define VARIANT_VISITOR_H_\n\n#include <type_traits>\n#include <cstring>\n#include <sstream>\n\nnamespace fenf {\nnamespace detail {\n\ntemplate <class Visitor, class Variant>\ntypename std::result_of<Visitor(const Variant&)>::type\napply_visitor(Visitor visitor, const Variant& var)\n{\n    return visitor(var);\n}\n\ntemplate <class Visitor, class Variant>\ntypename std::result_of<Visitor(Variant&)>::type\napply_visitor(Visitor visitor, Variant& var)\n{\n    return visitor(var);\n}\n\n}  // namespace detail\n\nusing detail::apply_visitor;\n\n}  // namespace fenf\n\n#endif  // VARIANT_VISITOR_H_\n\n\n\nvariant.h\n//\n//  variant.h\n//  variant \u30af\u30e9\u30b9\u306e\u5b9a\u7fa9\n//  Created by atosh on 2/21/15.\n//\n\n#ifndef VARIANT_H_\n#define VARIANT_H_\n\n#include <cstring>\n#include <sstream>\n\n#include \"variant_util.h\"\n#include \"variant_visitor.h\"\n\nnamespace fenf {\nnamespace detail {\n\ntemplate <typename T>\nstruct get_visitor_t {\n    template <class Variant>\n    const T& operator()(const Variant& var) const\n    {\n        static_assert(Variant::template contains_t<T>::value, \"\");\n        return *reinterpret_cast<const T* const>(var.storage());\n    }\n};\n\ntemplate <typename T>\nstruct mutable_get_visitor_t {\n    template <class Variant>\n    T& operator()(Variant& var) const\n    {\n        static_assert(Variant::template contains_t<T>::value, \"\");\n        return *reinterpret_cast<T*>(var.mutable_storage());\n    }\n};\n\ntemplate <typename T>\nstruct assign_visitor_t {\n    const T& value_;\n    assign_visitor_t(const T& value) : value_(value)\n    {\n    }\n    template <class Variant>\n    void operator()(Variant& var) const\n    {\n        static_assert(Variant::template contains_t<T>::value, \"\");\n        static_assert(sizeof(T) <= Variant::kStorageSize, \"\");\n        var.mutable_which() = Variant::template index_of_t<T>::value;\n        std::memset(var.mutable_storage(), 0, Variant::kStorageSize);\n        new (var.mutable_storage()) T(value_);\n    }\n};\n\ntemplate <class Variant>\nstruct copy_visitor_t {\n    const Variant& other_;\n    copy_visitor_t(const Variant& other) : other_(other)\n    {\n    }\n    void operator()(Variant& var) const\n    {\n        std::memcpy(var.mutable_storage(), other_.storage(), Variant::kStorageSize);\n        var.mutable_which() = other_.which();\n    }\n};\n\ntemplate <int I, class Variant>\nstruct is_equal_visitor_t {\n    const Variant& other_;\n    is_equal_visitor_t(const Variant& other) : other_(other)\n    {\n    }\n    bool operator()(const Variant& var) const\n    {\n        // value\u306e\u578b\u306b\u4e00\u81f4\u3059\u308bVisitor\u3092\u518d\u5e30\u7684\u306b\u63a2\u3059\n        if (var.which() != I) {\n            return apply_visitor(is_equal_visitor_t<I - 1, Variant>(other_), var);\n        }\n        using T = typename Variant::template at_t<I>::type;\n        return var.template get<T>() == other_.template get<T>();\n    }\n};\n\ntemplate <class Variant>\nstruct is_equal_visitor_t<-1, Variant> {\n    is_equal_visitor_t(const Variant&)\n    {\n    }\n    bool operator()(const Variant&) const\n    {\n        return false;\n    }\n};\n\ntemplate <int I, class Variant>\nstruct to_string_visitor_t {\n    std::string operator()(const Variant& value) const\n    {\n        // value\u306e\u578b\u306b\u4e00\u81f4\u3059\u308bVisitor\u3092\u518d\u5e30\u7684\u306b\u63a2\u3059\n        if (value.which() != I) {\n            return apply_visitor(to_string_visitor_t<I - 1, Variant>(), value);\n        }\n        using T = typename Variant::template at_t<I>::type;\n        std::stringstream ss;\n        ss << apply_visitor(get_visitor_t<T>(), value);\n        return ss.str();\n    }\n};\n\ntemplate <class Variant>\nstruct to_string_visitor_t<-1, Variant> {\n    std::string operator()(const Variant& value) const\n    {\n        return \"\";\n    }\n};\n\n//! Variadic Template \u3092\u4f7f\u3063\u305f variant \u5b9f\u88c5\ntemplate <typename... Types>\nclass variant {\npublic:\n    static const int kNumTypes = sizeof...(Types);                //!< \u578b\u6570\n    static const int kStorageSize = max_size_t<Types...>::value;  //!< \u6700\u5927\u30b5\u30a4\u30ba\u3092\u6301\u3064\u578b\u306e\u30b5\u30a4\u30ba\n\n    //! \u6307\u5b9a\u3057\u305f\u578b\u304c\u542b\u307e\u308c\u3066\u3044\u308b\u304b\u8abf\u3079\u308b\u30e1\u30bf\u95a2\u6570\n    template <typename T>\n    using contains_t = contains_t<T, Types...>;\n    //! \u6307\u5b9a\u3057\u305f\u578b\u306e\u30a4\u30f3\u30c7\u30c3\u30af\u30b9\u3092\u8fd4\u3059\u30e1\u30bf\u95a2\u6570\n    template <typename T>\n    using index_of_t = index_of_t<T, Types...>;\n    //! \u6307\u5b9a\u3057\u305f\u30a4\u30f3\u30c7\u30c3\u30af\u30b9\u306e\u578b\u3092\u8fd4\u3059\u30e1\u30bf\u95a2\u6570\n    template <int I>\n    using at_t = at_t<I, Types...>;\n\n    variant() : which_(-1)\n    {\n        std::memset(storage_, 0, kStorageSize);\n    }\n    variant(const variant& other)\n    {\n        copy(other);\n    }\n    variant(variant&& other)\n    {\n        copy(other);\n    }\n    template <typename T>\n    variant(const T& value)\n    {\n        assign(value);\n    }\n    variant& operator=(const variant& other)\n    {\n        copy(other);\n        return *this;\n    }\n    variant& operator=(variant&& other)\n    {\n        copy(other);\n        return *this;\n    }\n    template <typename T>\n    variant& operator=(const T& value)\n    {\n        assign(value);\n        return *this;\n    }\n    bool operator==(const variant& other) const\n    {\n        if (which() != other.which()) {\n            return false;\n        }\n        return apply_visitor(is_equal_visitor_t<kNumTypes - 1, variant>(other), *this);\n    }\n    bool operator!=(const variant& other) const\n    {\n        return !(*this == other);\n    }\n    template <typename T>\n    const T&\n    get() const\n    {\n        return apply_visitor(get_visitor_t<T>(), *this);\n    }\n    template <typename T>\n    T&\n    get()\n    {\n        return apply_visitor(mutable_get_visitor_t<T>(), *this);\n    }\n    std::string\n    to_string() const\n    {\n        return apply_visitor(to_string_visitor_t<kNumTypes - 1, variant>(), *this);\n    }\n\n    int\n    which() const\n    {\n        return which_;\n    }\n    int&\n    mutable_which()\n    {\n        return which_;\n    }\n    const char* const\n    storage() const\n    {\n        return storage_;\n    }\n    char*\n    mutable_storage()\n    {\n        return storage_;\n    }\n\nprivate:\n    template <typename T>\n    void\n    assign(const T& value)\n    {\n        apply_visitor(assign_visitor_t<T>(value), *this);\n    }\n    void\n    assign(const char* const value)\n    {\n        assign<std::string>(value);\n    }\n    void\n    copy(const variant& other)\n    {\n        apply_visitor(copy_visitor_t<variant>(other), *this);\n    }\n\n    int which_;                   //!< \u73fe\u5728\u30bb\u30c3\u30c8\u3055\u308c\u3066\u3044\u308b\u5024\u306e\u578b\n    char storage_[kStorageSize];  //!< \u5024\u3092\u30bb\u30c3\u30c8\u3059\u308b\u9818\u57df\n};\n\n}  // namespace detail\n\nusing detail::variant;\n\n}  // namespace fenf\n\n#endif  // VARIANT_H_\n\n\n\nmain.cpp\n//\n//  main.cpp\n//\n//  Created by atosh on 2/21/15.\n//\n\n#include <iostream>\n#include <string>\n#include <cstdint>\n#include <cassert>\n\n#include \"variant.h\"\n\nint\nmain()\n{\n    typedef fenf::variant<int, double, std::string> var;\n    var a = 10;\n    var b = 20;\n    var c = 10;\n    var d = 3.14;\n    var e = \"foobar\";\n    var f = \"baz\";\n    var g = \"foobar\";\n    assert(!(a == b));\n    assert(a == c);\n    assert(!(a == d));\n    assert(!(a == e));\n    a.get<int>() += 10;  // mutate\n    assert(a == b);\n    assert(a.which() == 0);\n    a = 3.14;  // mutate\n    assert(a.which() == 1);\n    assert(a == d);\n    assert(e != f);\n    assert(e == g);\n\n    assert(a.to_string() == \"3.14\");\n    assert(b.to_string() == \"20\");\n    assert(e.to_string() == \"foobar\");\n\n    return 0;\n}\n\n\noperator== \u304c\u547c\u3070\u308c\u308b\u3068 is_equal_visitor_t::operator() \u3092\u547c\u3073\u307e\u3059.\nvariant::which_ \u306b\u5bfe\u5fdc\u3059\u308b\u578b\u306b\u30ad\u30e3\u30b9\u30c8\u3059\u308b\u5fc5\u8981\u304c\u3042\u308b\u306e\u3067, which_ \u306b\u4e00\u81f4\u3059\u308b\u30c6\u30f3\u30d7\u30ec\u30fc\u30c8\u5f15\u6570 I \u3092\u6301\u3063\u305f is_equal_visitor_t \u3092\u518d\u5e30\u7684\u306b\u7dda\u5f62\u63a2\u7d22\u3057\u307e\u3059.\n\u898b\u3064\u304b\u3063\u305f\u3089 I \u3092\u5f15\u6570\u306b\u53d6\u308a\u578b\u3092\u8fd4\u3059\u30e1\u30bf\u95a2\u6570 at_t \u3092\u4f7f\u3063\u3066\u30ad\u30e3\u30b9\u30c8\u3057, \u5024\u6bd4\u8f03\u3057\u307e\u3059.\n\u540c\u3058\u8981\u9818\u3067 to_string \u3082\u5b9f\u88c5\u3057\u3066\u307f\u307e\u3057\u305f.\n\u5b58\u5728\u3059\u308b\u554f\u984c\u3068\u3057\u3066 assign, copy \u304c\u4f8b\u5916\u5b89\u5168\u3067\u306a\u304f, \u30ea\u30fc\u30af\u3082\u3057\u307e\u3059. boost.variant \u306e\u89e3\u6c7a\u65b9\u6cd5\u306fmelpon\u6c0f\u306e\u8a18\u4e8b\u3067\u89e3\u8aac\u3055\u308c\u3066\u3044\u307e\u3059.\n\u307e\u305f storage_ \u306e\u30a2\u30e9\u30a4\u30e1\u30f3\u30c8\u306b\u95a2\u3059\u308b\u554f\u984c\u3082\u8003\u616e\u3057\u3066\u3044\u307e\u305b\u3093. Cryolite\u6c0f\u306e\u8a18\u4e8b\u3067\u89e3\u8aac\u3055\u308c\u3066\u3044\u307e\u3059.\n\u5b9f\u88c5\u306b\u3042\u305f\u308a Boost.\u8aad\u66f8\u4f1a \u306e\u30ce\u30fc\u30c8\u3092\u53c2\u8003\u306b\u3055\u305b\u3066\u3044\u305f\u3060\u304d\u307e\u3057\u305f.\n\n[\u524d\u56de](http://qiita.com/adatchey/items/e3338bbc82a940e1cc7b)\u306e\u7d9a\u304d\u3067\u3059.\noperator==\u3067\u5024\u6bd4\u8f03\u3092\u3057\u3066\u3044\u306a\u304b\u3063\u305f\u306e\u3067, \u3067\u304d\u308b\u3088\u3046\u306b\u3057\u307e\u3057\u305f.\n\n\u672c\u5bb6\u306f\u3053\u3061\u3089: http://www.boost.org/doc/libs/1_57_0/doc/html/variant.html\n\n```variant_util.h\n//\n//  variant_util.h\n//  \u30e1\u30bf\u95a2\u6570\u7fa4\n//  Created by atosh on 2/22/15.\n//\n\n#ifndef VARIANT_UTIL_H_\n#define VARIANT_UTIL_H_\n\n#include <type_traits>\n\nnamespace fenf {\nnamespace detail {\n\ntemplate <typename T, typename... Rest>\nstruct max_size_t {\nprivate:\n    static const int kRestMax = max_size_t<Rest...>::value;\n\npublic:\n    static const int value = sizeof(T) > kRestMax ? sizeof(T) : kRestMax;\n};\n\ntemplate <typename T>\nstruct max_size_t<T> {\n    static const int value = sizeof(T);\n};\n\ntemplate <typename Target, typename T, typename... Rest>\nstruct contains_t {\n    static const bool value = (std::is_same<Target, T>::value) ? true : contains_t<Target, Rest...>::value;\n};\n\ntemplate <typename Target, typename T>\nstruct contains_t<Target, T> {\n    static const bool value = (std::is_same<Target, T>::value);\n};\n\ntemplate <int I, typename Target, typename T, typename... Rest>\nstruct index_of_impl_t {\n    static const int value = (std::is_same<Target, T>::value) ? I : index_of_impl_t<I + 1, Target, Rest...>::value;\n};\n\ntemplate <int I, typename Target, typename T>\nstruct index_of_impl_t<I, Target, T> {\n    static const int value = (std::is_same<Target, T>::value) ? I : -1;\n};\n\ntemplate <typename Target, typename... Types>\nstruct index_of_t {\n    static const int value = index_of_impl_t<0, Target, Types...>::value;\n};\n\ntemplate <int I, typename T, typename... Rest>\nstruct at_t {\n    using type = typename at_t<I - 1, Rest...>::type;\n};\n\ntemplate <typename T, typename... Rest>\nstruct at_t<0, T, Rest...> {\n    using type = T;\n};\n\n}  // namespace detail\n}  // namespace fenf\n\n#endif  // VARIANT_UTIL_H_\n```\n\n```variant_visitor.h\n//\n//  variant_visitor.h\n//  apply_visitor \u306e\u5b9a\u7fa9\n//  Created by atosh on 2/22/15.\n//\n\n#ifndef VARIANT_VISITOR_H_\n#define VARIANT_VISITOR_H_\n\n#include <type_traits>\n#include <cstring>\n#include <sstream>\n\nnamespace fenf {\nnamespace detail {\n\ntemplate <class Visitor, class Variant>\ntypename std::result_of<Visitor(const Variant&)>::type\napply_visitor(Visitor visitor, const Variant& var)\n{\n    return visitor(var);\n}\n\ntemplate <class Visitor, class Variant>\ntypename std::result_of<Visitor(Variant&)>::type\napply_visitor(Visitor visitor, Variant& var)\n{\n    return visitor(var);\n}\n\n}  // namespace detail\n\nusing detail::apply_visitor;\n\n}  // namespace fenf\n\n#endif  // VARIANT_VISITOR_H_\n```\n\n```variant.h\n//\n//  variant.h\n//  variant \u30af\u30e9\u30b9\u306e\u5b9a\u7fa9\n//  Created by atosh on 2/21/15.\n//\n\n#ifndef VARIANT_H_\n#define VARIANT_H_\n\n#include <cstring>\n#include <sstream>\n\n#include \"variant_util.h\"\n#include \"variant_visitor.h\"\n\nnamespace fenf {\nnamespace detail {\n\ntemplate <typename T>\nstruct get_visitor_t {\n    template <class Variant>\n    const T& operator()(const Variant& var) const\n    {\n        static_assert(Variant::template contains_t<T>::value, \"\");\n        return *reinterpret_cast<const T* const>(var.storage());\n    }\n};\n\ntemplate <typename T>\nstruct mutable_get_visitor_t {\n    template <class Variant>\n    T& operator()(Variant& var) const\n    {\n        static_assert(Variant::template contains_t<T>::value, \"\");\n        return *reinterpret_cast<T*>(var.mutable_storage());\n    }\n};\n\ntemplate <typename T>\nstruct assign_visitor_t {\n    const T& value_;\n    assign_visitor_t(const T& value) : value_(value)\n    {\n    }\n    template <class Variant>\n    void operator()(Variant& var) const\n    {\n        static_assert(Variant::template contains_t<T>::value, \"\");\n        static_assert(sizeof(T) <= Variant::kStorageSize, \"\");\n        var.mutable_which() = Variant::template index_of_t<T>::value;\n        std::memset(var.mutable_storage(), 0, Variant::kStorageSize);\n        new (var.mutable_storage()) T(value_);\n    }\n};\n\ntemplate <class Variant>\nstruct copy_visitor_t {\n    const Variant& other_;\n    copy_visitor_t(const Variant& other) : other_(other)\n    {\n    }\n    void operator()(Variant& var) const\n    {\n        std::memcpy(var.mutable_storage(), other_.storage(), Variant::kStorageSize);\n        var.mutable_which() = other_.which();\n    }\n};\n\ntemplate <int I, class Variant>\nstruct is_equal_visitor_t {\n    const Variant& other_;\n    is_equal_visitor_t(const Variant& other) : other_(other)\n    {\n    }\n    bool operator()(const Variant& var) const\n    {\n        // value\u306e\u578b\u306b\u4e00\u81f4\u3059\u308bVisitor\u3092\u518d\u5e30\u7684\u306b\u63a2\u3059\n        if (var.which() != I) {\n            return apply_visitor(is_equal_visitor_t<I - 1, Variant>(other_), var);\n        }\n        using T = typename Variant::template at_t<I>::type;\n        return var.template get<T>() == other_.template get<T>();\n    }\n};\n\ntemplate <class Variant>\nstruct is_equal_visitor_t<-1, Variant> {\n    is_equal_visitor_t(const Variant&)\n    {\n    }\n    bool operator()(const Variant&) const\n    {\n        return false;\n    }\n};\n\ntemplate <int I, class Variant>\nstruct to_string_visitor_t {\n    std::string operator()(const Variant& value) const\n    {\n        // value\u306e\u578b\u306b\u4e00\u81f4\u3059\u308bVisitor\u3092\u518d\u5e30\u7684\u306b\u63a2\u3059\n        if (value.which() != I) {\n            return apply_visitor(to_string_visitor_t<I - 1, Variant>(), value);\n        }\n        using T = typename Variant::template at_t<I>::type;\n        std::stringstream ss;\n        ss << apply_visitor(get_visitor_t<T>(), value);\n        return ss.str();\n    }\n};\n\ntemplate <class Variant>\nstruct to_string_visitor_t<-1, Variant> {\n    std::string operator()(const Variant& value) const\n    {\n        return \"\";\n    }\n};\n\n//! Variadic Template \u3092\u4f7f\u3063\u305f variant \u5b9f\u88c5\ntemplate <typename... Types>\nclass variant {\npublic:\n    static const int kNumTypes = sizeof...(Types);                //!< \u578b\u6570\n    static const int kStorageSize = max_size_t<Types...>::value;  //!< \u6700\u5927\u30b5\u30a4\u30ba\u3092\u6301\u3064\u578b\u306e\u30b5\u30a4\u30ba\n\n    //! \u6307\u5b9a\u3057\u305f\u578b\u304c\u542b\u307e\u308c\u3066\u3044\u308b\u304b\u8abf\u3079\u308b\u30e1\u30bf\u95a2\u6570\n    template <typename T>\n    using contains_t = contains_t<T, Types...>;\n    //! \u6307\u5b9a\u3057\u305f\u578b\u306e\u30a4\u30f3\u30c7\u30c3\u30af\u30b9\u3092\u8fd4\u3059\u30e1\u30bf\u95a2\u6570\n    template <typename T>\n    using index_of_t = index_of_t<T, Types...>;\n    //! \u6307\u5b9a\u3057\u305f\u30a4\u30f3\u30c7\u30c3\u30af\u30b9\u306e\u578b\u3092\u8fd4\u3059\u30e1\u30bf\u95a2\u6570\n    template <int I>\n    using at_t = at_t<I, Types...>;\n\n    variant() : which_(-1)\n    {\n        std::memset(storage_, 0, kStorageSize);\n    }\n    variant(const variant& other)\n    {\n        copy(other);\n    }\n    variant(variant&& other)\n    {\n        copy(other);\n    }\n    template <typename T>\n    variant(const T& value)\n    {\n        assign(value);\n    }\n    variant& operator=(const variant& other)\n    {\n        copy(other);\n        return *this;\n    }\n    variant& operator=(variant&& other)\n    {\n        copy(other);\n        return *this;\n    }\n    template <typename T>\n    variant& operator=(const T& value)\n    {\n        assign(value);\n        return *this;\n    }\n    bool operator==(const variant& other) const\n    {\n        if (which() != other.which()) {\n            return false;\n        }\n        return apply_visitor(is_equal_visitor_t<kNumTypes - 1, variant>(other), *this);\n    }\n    bool operator!=(const variant& other) const\n    {\n        return !(*this == other);\n    }\n    template <typename T>\n    const T&\n    get() const\n    {\n        return apply_visitor(get_visitor_t<T>(), *this);\n    }\n    template <typename T>\n    T&\n    get()\n    {\n        return apply_visitor(mutable_get_visitor_t<T>(), *this);\n    }\n    std::string\n    to_string() const\n    {\n        return apply_visitor(to_string_visitor_t<kNumTypes - 1, variant>(), *this);\n    }\n\n    int\n    which() const\n    {\n        return which_;\n    }\n    int&\n    mutable_which()\n    {\n        return which_;\n    }\n    const char* const\n    storage() const\n    {\n        return storage_;\n    }\n    char*\n    mutable_storage()\n    {\n        return storage_;\n    }\n\nprivate:\n    template <typename T>\n    void\n    assign(const T& value)\n    {\n        apply_visitor(assign_visitor_t<T>(value), *this);\n    }\n    void\n    assign(const char* const value)\n    {\n        assign<std::string>(value);\n    }\n    void\n    copy(const variant& other)\n    {\n        apply_visitor(copy_visitor_t<variant>(other), *this);\n    }\n\n    int which_;                   //!< \u73fe\u5728\u30bb\u30c3\u30c8\u3055\u308c\u3066\u3044\u308b\u5024\u306e\u578b\n    char storage_[kStorageSize];  //!< \u5024\u3092\u30bb\u30c3\u30c8\u3059\u308b\u9818\u57df\n};\n\n}  // namespace detail\n\nusing detail::variant;\n\n}  // namespace fenf\n\n#endif  // VARIANT_H_\n```\n\n```main.cpp\n//\n//  main.cpp\n//\n//  Created by atosh on 2/21/15.\n//\n\n#include <iostream>\n#include <string>\n#include <cstdint>\n#include <cassert>\n\n#include \"variant.h\"\n\nint\nmain()\n{\n    typedef fenf::variant<int, double, std::string> var;\n    var a = 10;\n    var b = 20;\n    var c = 10;\n    var d = 3.14;\n    var e = \"foobar\";\n    var f = \"baz\";\n    var g = \"foobar\";\n    assert(!(a == b));\n    assert(a == c);\n    assert(!(a == d));\n    assert(!(a == e));\n    a.get<int>() += 10;  // mutate\n    assert(a == b);\n    assert(a.which() == 0);\n    a = 3.14;  // mutate\n    assert(a.which() == 1);\n    assert(a == d);\n    assert(e != f);\n    assert(e == g);\n\n    assert(a.to_string() == \"3.14\");\n    assert(b.to_string() == \"20\");\n    assert(e.to_string() == \"foobar\");\n\n    return 0;\n}\n```\n\noperator== \u304c\u547c\u3070\u308c\u308b\u3068 is_equal_visitor_t::operator() \u3092\u547c\u3073\u307e\u3059.\nvariant::which_ \u306b\u5bfe\u5fdc\u3059\u308b\u578b\u306b\u30ad\u30e3\u30b9\u30c8\u3059\u308b\u5fc5\u8981\u304c\u3042\u308b\u306e\u3067, which_ \u306b\u4e00\u81f4\u3059\u308b\u30c6\u30f3\u30d7\u30ec\u30fc\u30c8\u5f15\u6570 I \u3092\u6301\u3063\u305f is_equal_visitor_t \u3092\u518d\u5e30\u7684\u306b\u7dda\u5f62\u63a2\u7d22\u3057\u307e\u3059.\n\u898b\u3064\u304b\u3063\u305f\u3089 I \u3092\u5f15\u6570\u306b\u53d6\u308a\u578b\u3092\u8fd4\u3059\u30e1\u30bf\u95a2\u6570 at_t \u3092\u4f7f\u3063\u3066\u30ad\u30e3\u30b9\u30c8\u3057, \u5024\u6bd4\u8f03\u3057\u307e\u3059.\n\u540c\u3058\u8981\u9818\u3067 to_string \u3082\u5b9f\u88c5\u3057\u3066\u307f\u307e\u3057\u305f.\n\n\u5b58\u5728\u3059\u308b\u554f\u984c\u3068\u3057\u3066 assign, copy \u304c\u4f8b\u5916\u5b89\u5168\u3067\u306a\u304f, \u30ea\u30fc\u30af\u3082\u3057\u307e\u3059. boost.variant \u306e\u89e3\u6c7a\u65b9\u6cd5\u306f[melpon\u6c0f\u306e\u8a18\u4e8b](http://d.hatena.ne.jp/melpon/20090831)\u3067\u89e3\u8aac\u3055\u308c\u3066\u3044\u307e\u3059.\n\u307e\u305f storage_ \u306e\u30a2\u30e9\u30a4\u30e1\u30f3\u30c8\u306b\u95a2\u3059\u308b\u554f\u984c\u3082\u8003\u616e\u3057\u3066\u3044\u307e\u305b\u3093. [Cryolite\u6c0f\u306e\u8a18\u4e8b](http://d.hatena.ne.jp/Cryolite/20051102)\u3067\u89e3\u8aac\u3055\u308c\u3066\u3044\u307e\u3059.\n\n\u5b9f\u88c5\u306b\u3042\u305f\u308a [Boost.\u8aad\u66f8\u4f1a](http://www.co-meeting.com/p/boost-reading/50950eedab5c3725770003c4) \u306e\u30ce\u30fc\u30c8\u3092\u53c2\u8003\u306b\u3055\u305b\u3066\u3044\u305f\u3060\u304d\u307e\u3057\u305f.\n", "tags": ["C++", "C++11"]}