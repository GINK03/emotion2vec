{"context": "\u30d0\u30c3\u30af\u30a8\u30f3\u30c9\u306e\u30de\u30a4\u30af\u30ed\u30b5\u30fc\u30d3\u30b9\u3092\u53e9\u304d\u307e\u304f\u308b\u3088\u3046\u306a API \u3092\u4f5c\u308b\u5834\u5408\u3001\u30b5\u30fc\u30d6\u30ec\u30c3\u30c8\u30d9\u30fc\u30b9\u306e\u30b5\u30fc\u30d0\u30fc\u3088\u308a\u3082 Vert.x \u306e\u3088\u3046\u306a\u30df\u30c9\u30eb\u30a6\u30a7\u30a2\u3092\u4f7f\u3063\u305f\u307b\u3046\u304c\u6c17\u697d\u306b\u4f5c\u308c\u3066\u826f\u3044\u3067\u3059\u3088\u306d\u3002\u52e4\u52d9\u5148\u3067\u3082\u3061\u3087\u3053\u3061\u3087\u3053 Vert.x \u304c\u6d3b\u8e8d\u3057\u3066\u3044\u307e\u3059\u3002\nVert.x \u306f\u975e\u540c\u671f\u524d\u63d0\u306a\u306e\u3067\u3001\u4f7f\u3046\u3068\u304d\u306f\u3060\u3044\u305f\u3044 RxJava \u3092\u4f7f\u3046\u3053\u3068\u306b\u306a\u308b\u3068\u601d\u3046\u306e\u3067\u3059\u304c\u3001\u3046\u3063\u304b\u308a\u30b3\u30cd\u30af\u30b7\u30e7\u30f3\u304c\u30ea\u30fc\u30af\u3057\u3066\u3044\u305f\u3053\u3068\u304c\u3042\u3063\u305f\u306e\u3067\u3001\u6700\u8fd1\u306e JDBC \u63a5\u7d9a\u8a2d\u5b9a\u3092\u30e1\u30e2\u3057\u3066\u304a\u304d\u307e\u3059\u3002Observable.using \u304c\u809d\u3067\u3059\u3002\npublic interface JDBCMixin {\n\n    @Nonnull\n    default Observable<List<JsonObject>> query(@Nonnull String sql) {\n        return query(sql, null);\n    }\n\n    @Nonnull\n    default Observable<List<JsonObject>> query(@Nonnull String sql, @Nullable Object... args) {\n        return query(sql, identity(), args);\n    }\n\n    @Nonnull\n    default Observable<Optional<JsonObject>> queryOne(@Nonnull String sql, @Nonnull Object... args) {\n        return query(sql, rows -> rows.isEmpty() ? Optional.empty() : Optional.of(rows.iterator().next()), args);\n    }\n\n    @Nonnull\n    default <T> Observable<T> query(@Nonnull String sql, @Nonnull Func1<List<JsonObject>, T> mapper, @Nullable Object... args) {\n        return connect(\n            conn -> Optional\n                .ofNullable(args)\n                .map(params -> conn.queryWithParamsObservable(sql, new JsonArray(Arrays.asList(params))))\n                .orElse(conn.queryObservable(sql))\n                .map(ResultSet::getRows)\n                .map(mapper));\n    }\n\n    @Nonnull\n    default <T> Observable<T> connect(Func1<SQLConnection, Observable<T>> fn) {\n        return client().getConnectionObservable().flatMap(connection -> Observable.using(() -> connection, fn, SQLConnection::close));\n    }\n\n    @Nonnull\n    default <T> Func1<T, T> identity() {\n        return v -> v;\n    }\n\n    @Nonnull\n    JDBCClient client();\n\n}\n\n\u3053\u3093\u306a\u611f\u3058\u3067\u4f7f\u3044\u307e\u3059\u3002\npublic class CountryRepositoryImpl implements CountryRepository, JDBCMixin {\n\n    @Override\n    @Nonnull\n    public Observable<Optional<Country>> get(@Nonnull CountryId countryId) {\n        return queryOne(\"select * from countries where id = ?\", countryId.getValue()).map(row -> row.map(this::toCountry));\n    }\n\n}\n\n\u3061\u306a\u307f\u306b\u30b3\u30cd\u30af\u30b7\u30e7\u30f3\u30ea\u30fc\u30af\u306e\u691c\u77e5\u306b\u306f Hikari CP \u306e leakDetectionThreshold \u304c\u4fbf\u5229\u3067\u3057\u305f\uff08Vert.x \u3067\u3082 io.vertx.ext.jdbc.spi.impl.HikariCPDataSourceProvider \u3092\u4f7f\u3048\u3070 Hikari CP \u3092\u4f7f\u3046\u3053\u3068\u304c\u51fa\u6765\u307e\u3059\uff09\u3002\n\u30d0\u30c3\u30af\u30a8\u30f3\u30c9\u306e\u30de\u30a4\u30af\u30ed\u30b5\u30fc\u30d3\u30b9\u3092\u53e9\u304d\u307e\u304f\u308b\u3088\u3046\u306a API \u3092\u4f5c\u308b\u5834\u5408\u3001\u30b5\u30fc\u30d6\u30ec\u30c3\u30c8\u30d9\u30fc\u30b9\u306e\u30b5\u30fc\u30d0\u30fc\u3088\u308a\u3082 Vert.x \u306e\u3088\u3046\u306a\u30df\u30c9\u30eb\u30a6\u30a7\u30a2\u3092\u4f7f\u3063\u305f\u307b\u3046\u304c\u6c17\u697d\u306b\u4f5c\u308c\u3066\u826f\u3044\u3067\u3059\u3088\u306d\u3002\u52e4\u52d9\u5148\u3067\u3082\u3061\u3087\u3053\u3061\u3087\u3053 Vert.x \u304c\u6d3b\u8e8d\u3057\u3066\u3044\u307e\u3059\u3002\n\nVert.x \u306f\u975e\u540c\u671f\u524d\u63d0\u306a\u306e\u3067\u3001\u4f7f\u3046\u3068\u304d\u306f\u3060\u3044\u305f\u3044 RxJava \u3092\u4f7f\u3046\u3053\u3068\u306b\u306a\u308b\u3068\u601d\u3046\u306e\u3067\u3059\u304c\u3001\u3046\u3063\u304b\u308a\u30b3\u30cd\u30af\u30b7\u30e7\u30f3\u304c\u30ea\u30fc\u30af\u3057\u3066\u3044\u305f\u3053\u3068\u304c\u3042\u3063\u305f\u306e\u3067\u3001\u6700\u8fd1\u306e JDBC \u63a5\u7d9a\u8a2d\u5b9a\u3092\u30e1\u30e2\u3057\u3066\u304a\u304d\u307e\u3059\u3002`Observable.using` \u304c\u809d\u3067\u3059\u3002\n\n```java\npublic interface JDBCMixin {\n\n    @Nonnull\n    default Observable<List<JsonObject>> query(@Nonnull String sql) {\n        return query(sql, null);\n    }\n\n    @Nonnull\n    default Observable<List<JsonObject>> query(@Nonnull String sql, @Nullable Object... args) {\n        return query(sql, identity(), args);\n    }\n\n    @Nonnull\n    default Observable<Optional<JsonObject>> queryOne(@Nonnull String sql, @Nonnull Object... args) {\n        return query(sql, rows -> rows.isEmpty() ? Optional.empty() : Optional.of(rows.iterator().next()), args);\n    }\n\n    @Nonnull\n    default <T> Observable<T> query(@Nonnull String sql, @Nonnull Func1<List<JsonObject>, T> mapper, @Nullable Object... args) {\n        return connect(\n            conn -> Optional\n                .ofNullable(args)\n                .map(params -> conn.queryWithParamsObservable(sql, new JsonArray(Arrays.asList(params))))\n                .orElse(conn.queryObservable(sql))\n                .map(ResultSet::getRows)\n                .map(mapper));\n    }\n\n    @Nonnull\n    default <T> Observable<T> connect(Func1<SQLConnection, Observable<T>> fn) {\n        return client().getConnectionObservable().flatMap(connection -> Observable.using(() -> connection, fn, SQLConnection::close));\n    }\n\n    @Nonnull\n    default <T> Func1<T, T> identity() {\n        return v -> v;\n    }\n\n    @Nonnull\n    JDBCClient client();\n\n}\n```\n\n\u3053\u3093\u306a\u611f\u3058\u3067\u4f7f\u3044\u307e\u3059\u3002\n\n```java\npublic class CountryRepositoryImpl implements CountryRepository, JDBCMixin {\n\n    @Override\n    @Nonnull\n    public Observable<Optional<Country>> get(@Nonnull CountryId countryId) {\n        return queryOne(\"select * from countries where id = ?\", countryId.getValue()).map(row -> row.map(this::toCountry));\n    }\n\n}\n```\n\n\u3061\u306a\u307f\u306b\u30b3\u30cd\u30af\u30b7\u30e7\u30f3\u30ea\u30fc\u30af\u306e\u691c\u77e5\u306b\u306f Hikari CP \u306e `leakDetectionThreshold` \u304c\u4fbf\u5229\u3067\u3057\u305f\uff08Vert.x \u3067\u3082 `io.vertx.ext.jdbc.spi.impl.HikariCPDataSourceProvider` \u3092\u4f7f\u3048\u3070 Hikari CP \u3092\u4f7f\u3046\u3053\u3068\u304c\u51fa\u6765\u307e\u3059\uff09\u3002\n", "tags": ["Vert.x", "RxJava", "Java"]}