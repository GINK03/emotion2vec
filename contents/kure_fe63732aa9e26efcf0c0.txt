{"context": " More than 1 year has passed since last update.\u5e74\u672b\u5e74\u59cb\u306e\u52c9\u5f37/\u904a\u3073\u3067\u3001\u300e\u96c6\u5408\u77e5\u30d7\u30ed\u30b0\u30e9\u30df\u30f3\u30b0\u300f\u3092\u8aad\u3093\u3067\u3044\u308b\u9014\u4e2d\u306e\u30e1\u30e2\u3002\u30af\u30e9\u30b9\u30bf\u30ea\u30f3\u30b0\u3067\u904a\u3093\u3067\u307f\u3088\u3046\u304b\u3068\u601d\u3044\u3001PHP\u3067KMeans\u6cd5\u3092\u5b9f\u88c5\u3057\u3066\u307f\u305f\u3002\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0\u306e\u8aac\u660e\u3060\u3051\u8aad\u3093\u3067\u3001\u30b3\u30fc\u30c9\u306f\u307b\u3068\u3093\u3069\u8aad\u3093\u3067\u306a\u3044\u3051\u3069\uff08Python\u8aad\u3081\u306a\u3044\uff09\u3002\n\u8ddd\u96e2\u306e\u8a08\u7b97\u306b\u3064\u3044\u3066\u306f\u3001\uff08\u4eca\u306e\u3068\u3053\u308d\uff09\u30e6\u30fc\u30af\u30ea\u30c3\u30c9\u8ddd\u96e2\u3067\u306e\u8a08\u7b97\u306e\u307f\u5b9f\u88c5\u3002\nKMeans\u6cd5\u306e\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0\u306f\u4ee5\u4e0b\u306e\u3068\u304a\u308a\uff08Wikipedia\u3088\u308a\uff09\u3002\n\n\u30e1\u30a4\u30f3\u306e\u30ed\u30b8\u30c3\u30af\u90e8\u5206\u3092\u629c\u7c8b\u3002\u5168\u30b3\u30fc\u30c9\u306f\u4ee5\u4e0b\u3002\nhttps://github.com/kuredev/KMeans\n\nKMeans.php\n<?php\n\nerror_reporting(E_ALL & ~E_NOTICE);\n\nfunction __autoload($class_name) {\n    include $class_name . '.php';\n}\n\n/**\n * \n */\nclass KMeans implements KMeansInterface {\n\n    public function __construct() {}\n\n    /**\n     * \n     * @param array $dataArr\n     * @param type $k\n     * @param type $distanceName\n     * @return array\n     */\n    public function cluster(array $dataArr, $k, $distanceName) {\n        $vectorDimensionNum = count($dataArr[0]);\n        $clusterPointArr = array();\n        $savedClusterPointArr = array();\n        $dataPointArr = array();\n        foreach ($dataArr as $data) {\n            array_push($dataPointArr, new DataPoint($data));\n        }\n\n        //\u521d\u671f\u30af\u30e9\u30b9\u30bf\u30dd\u30a4\u30f3\u30c8\uff08\u4e2d\u5fc3\u70b9\uff09\u3092\u4f5c\u6210\n        while(1){\n            $randArr = $this->_getRandPointArr(\n                    $this->_getRange($dataPointArr,$vectorDimensionNum), \n                    $k, \n                    $vectorDimensionNum);\n            if($this->_chkDupValue($randArr) == false){\n                break;\n            }            \n        }\n        foreach ($randArr as $rand) {\n            array_push($clusterPointArr, new ClusterPoint($rand));\n        }\n\n        //\u5404\u30c7\u30fc\u30bf\u306e\u30af\u30e9\u30b9\u30bf\u3078\u306e\u5272\u308a\u5f53\u3066\n        $this->_belongCluster($clusterPointArr, $dataPointArr, $distanceName);\n        $this->_saveClusterPoint($clusterPointArr, $savedClusterPointArr);\n        while (1) {\n            //\u30af\u30e9\u30b9\u30bf\u306e\u4e2d\u5fc3\u3092\u3001\u5404\u30af\u30e9\u30b9\u30bf\u306e\u91cd\u5fc3\u306b\u79fb\u52d5\n            $this->_moveClusterPoint($clusterPointArr);\n            //\u30af\u30e9\u30b9\u30bf\u306e\u4e2d\u5fc3\u70b9\uff08Centroid\uff09\u304c\u5909\u5316\u3057\u3066\u3044\u306a\u304b\u3063\u305f\u3089\u3001\u7d42\u4e86\n            if (!$this->_chkMovedClusterPoint($clusterPointArr, $savedClusterPointArr)) {\n                break;\n            }\n            //\u5404\u30c7\u30fc\u30bf\u306e\u6240\u5c5e\u30af\u30e9\u30b9\u30bf\u3092\u5272\u308a\u5f53\u3066\u76f4\u3059\n            $this->_flushBelongCluster($clusterPointArr);\n            $this->_belongCluster($clusterPointArr, $dataPointArr, $distanceName);\n            $this->_saveClusterPoint($clusterPointArr, $savedClusterPointArr);\n        }\n\n        return $clusterPointArr;\n    }\n\n    /**\n     * \n     * @param type $clusterPointArr\n     */\n    private function _flushBelongCluster(&$clusterPointArr) {\n        foreach ($clusterPointArr as $clusterPoint) {\n            $clusterPoint->flushBelongDataPoints();\n        }\n    }\n\n    /**\n     * \u91cd\u8907\u304c\u3042\u3063\u305f\u3089true\n     * @param type $arr\n     * @return boolean\n     */\n    private function _chkDupValue($arr) {\n        $arrVCount = array_count_values($arr);\n        for ($i = 0; $i < count($arr); $i++) {\n            $key = $arr[$i];\n            $count = $arrVCount[$key];\n            if ($count > 1) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * \n     * @param type $clusterPointArr\n     * @param type $dataPointArr\n     * @param type $distanceName\n     */\n    private function _belongCluster($clusterPointArr, &$dataPointArr, $distanceName) {\n        foreach ($dataPointArr as $dataPoint) {\n            $dataPoint->belongCluster(\n                    $clusterPointArr, \n                    DistanceFactory::create($distanceName));\n        }\n    }\n\n    /**\n     * \n     * @param type $clusterPointArr\n     * @param type $savedClusterPointArr\n     */\n    private function _saveClusterPoint($clusterPointArr, &$savedClusterPointArr) {\n        for ($i = 0; $i < sizeof($clusterPointArr); $i++) {\n            $savedClusterPointArr[$i] = clone $clusterPointArr[$i];\n        }\n    }\n\n    /**\n     * \n     * @return boolean \u524d\u56de\u306e\u30dd\u30a4\u30f3\u30c8\u3068\u52d5\u3044\u3066\u3044\u305f\u3089true\n     */\n    private function _chkMovedClusterPoint($clusterPointArr, $savedClusterPointArr) {\n        for ($i = 0; $i < sizeof($clusterPointArr); $i++) {\n            $diff = array_diff(\n                    $clusterPointArr[$i]->getCoordinate(),\n                    $savedClusterPointArr[$i]->getCoordinate());\n            if ($diff != null) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    /**\n     * \n     * @param type $clusterPointArr\n     */\n    private function _moveClusterPoint(&$clusterPointArr) {\n        foreach ($clusterPointArr as $clusterPoint) {\n            $aveArr = $this->_calcAve($clusterPoint->getBelongDataPoints());\n            if($aveArr == null) continue;\n            $clusterPoint->moveCoodinate($aveArr);\n        }\n    }\n\n    /**\n     * \n     * @param type $dataPointArr\n     * @return type\n     */\n    private function _calcAve($dataPointArr) {\n        if($dataPointArr == null) return null;\n\n        $sumArr = array();\n        $arrSize = sizeof($dataPointArr[0]->getBelongClusterPoint()->getBelongDataPoints());//0\u306e\u5834\u5408\u30a8\u30e9\u30fc\u306b\u306a\u308b\n        foreach ($dataPointArr as $dataPoint) {\n            $sumArr = $this->_addArr($sumArr, $dataPoint->getCoordinate());\n        }\n        return $this->_divArr($sumArr, $arrSize);\n    }\n\n    private function _divArr($arr, $num) {\n        $result = array();\n        for ($i = 0; $i < sizeof($arr); $i++) {\n            $result[$i] = $arr[$i] / $num;\n        }\n        return $result;\n    }\n\n    /**\n     * \u914d\u5217\u540c\u58eb\uff08\u5404\u5024\uff09\u306e\u8db3\u3057\u7b97\n     * @param type $arr1\n     * @param type $arr2\n     */\n    private function _addArr($arr1, $arr2) {\n        $result = array();\n        for ($i = 0; $i < count($arr2); $i++) {\n            $result[$i] = $arr1[$i] + $arr2[$i];\n        }\n        return $result;\n    }\n\n    /**\n     * \n     * @param type $rangeArr\n     * @param type $k\n     * @return type\n     */\n    private function _getRandPointArr($rangeArr, $k, $vectorDimensionNum) {\n        $randArrArr = array();\n        for ($i = 0; $i < $k; $i++) {\n            $randArr = array(); //int array\n            for ($j = 0; $j < $vectorDimensionNum; $j++) {\n                $randArr[$j] = rand($rangeArr[$j][0], $rangeArr[$j][1]);\n            }\n            $randArrArr[$i] = $randArr;\n        }\n        return $randArrArr;\n    }\n\n    /**\n     * \n     * @param type $dataPointArr\n     * @param type $vectorDimensionNum\n     * @return type\n     */\n    private function _getRange($dataPointArr, $vectorDimensionNum) {\n        $n = $vectorDimensionNum;\n        $rangeArr = array();\n\n        for ($i = 0; $i < $n; $i++) {\n            //n\u8981\u7d20\u76ee\u306b\u3064\u3044\u3066\n            foreach ($dataPointArr as $dataPoint) {\n                $data = $dataPoint->getCoordinate()[$i];\n                //[]\u306b\u3064\u3044\u3066\n                if ($rangeArr[$i][0] === null || $rangeArr[$i][0] >= $data) {\n                    $rangeArr[$i][0] = $data;\n                }\n                if ($rangeArr[$i][1] === null || $rangeArr[$i][1] <= $data) {\n                    $rangeArr[$i][1] = $data;\n                }\n            }\n        }\n        return $rangeArr;\n    }\n}\n\n/**\n * Useage:\n$kmeans = new KMeans();\nvar_dump($kmeans->cluster(\n        array(\n            array(1,1,1),\n            array(1,1,0),\n            array(0,0,0),\n            array(0,0,1)\n        )\n        , 2, \"Euclid\"\n        ));\n*/\n\n\n\u5e74\u672b\u5e74\u59cb\u306e\u52c9\u5f37/\u904a\u3073\u3067\u3001<a href=\"http://www.amazon.co.jp/exec/obidos/ASIN/4873113644/kuredev-22/ref=nosim/\" name=\"amazletlink\" target=\"_blank\">\u300e\u96c6\u5408\u77e5\u30d7\u30ed\u30b0\u30e9\u30df\u30f3\u30b0\u300f</a>\u3092\u8aad\u3093\u3067\u3044\u308b\u9014\u4e2d\u306e\u30e1\u30e2\u3002\u30af\u30e9\u30b9\u30bf\u30ea\u30f3\u30b0\u3067\u904a\u3093\u3067\u307f\u3088\u3046\u304b\u3068\u601d\u3044\u3001PHP\u3067KMeans\u6cd5\u3092\u5b9f\u88c5\u3057\u3066\u307f\u305f\u3002\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0\u306e\u8aac\u660e\u3060\u3051\u8aad\u3093\u3067\u3001\u30b3\u30fc\u30c9\u306f\u307b\u3068\u3093\u3069\u8aad\u3093\u3067\u306a\u3044\u3051\u3069\uff08Python\u8aad\u3081\u306a\u3044\uff09\u3002\n\u8ddd\u96e2\u306e\u8a08\u7b97\u306b\u3064\u3044\u3066\u306f\u3001\uff08\u4eca\u306e\u3068\u3053\u308d\uff09\u30e6\u30fc\u30af\u30ea\u30c3\u30c9\u8ddd\u96e2\u3067\u306e\u8a08\u7b97\u306e\u307f\u5b9f\u88c5\u3002\n\nKMeans\u6cd5\u306e\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0\u306f\u4ee5\u4e0b\u306e\u3068\u304a\u308a\uff08Wikipedia\u3088\u308a\uff09\u3002\n\n![ScreenClip.png](https://qiita-image-store.s3.amazonaws.com/0/50690/07150e99-0b4f-e17a-ab9b-7985f2d38ea4.png)\n\n\u30e1\u30a4\u30f3\u306e\u30ed\u30b8\u30c3\u30af\u90e8\u5206\u3092\u629c\u7c8b\u3002\u5168\u30b3\u30fc\u30c9\u306f\u4ee5\u4e0b\u3002\nhttps://github.com/kuredev/KMeans\n\n\n```php:KMeans.php\n<?php\n\nerror_reporting(E_ALL & ~E_NOTICE);\n\nfunction __autoload($class_name) {\n    include $class_name . '.php';\n}\n\n/**\n * \n */\nclass KMeans implements KMeansInterface {\n\n    public function __construct() {}\n\n    /**\n     * \n     * @param array $dataArr\n     * @param type $k\n     * @param type $distanceName\n     * @return array\n     */\n    public function cluster(array $dataArr, $k, $distanceName) {\n        $vectorDimensionNum = count($dataArr[0]);\n        $clusterPointArr = array();\n        $savedClusterPointArr = array();\n        $dataPointArr = array();\n        foreach ($dataArr as $data) {\n            array_push($dataPointArr, new DataPoint($data));\n        }\n        \n        //\u521d\u671f\u30af\u30e9\u30b9\u30bf\u30dd\u30a4\u30f3\u30c8\uff08\u4e2d\u5fc3\u70b9\uff09\u3092\u4f5c\u6210\n        while(1){\n            $randArr = $this->_getRandPointArr(\n                    $this->_getRange($dataPointArr,$vectorDimensionNum), \n                    $k, \n                    $vectorDimensionNum);\n            if($this->_chkDupValue($randArr) == false){\n                break;\n            }            \n        }\n        foreach ($randArr as $rand) {\n            array_push($clusterPointArr, new ClusterPoint($rand));\n        }\n\n        //\u5404\u30c7\u30fc\u30bf\u306e\u30af\u30e9\u30b9\u30bf\u3078\u306e\u5272\u308a\u5f53\u3066\n        $this->_belongCluster($clusterPointArr, $dataPointArr, $distanceName);\n        $this->_saveClusterPoint($clusterPointArr, $savedClusterPointArr);\n        while (1) {\n            //\u30af\u30e9\u30b9\u30bf\u306e\u4e2d\u5fc3\u3092\u3001\u5404\u30af\u30e9\u30b9\u30bf\u306e\u91cd\u5fc3\u306b\u79fb\u52d5\n            $this->_moveClusterPoint($clusterPointArr);\n            //\u30af\u30e9\u30b9\u30bf\u306e\u4e2d\u5fc3\u70b9\uff08Centroid\uff09\u304c\u5909\u5316\u3057\u3066\u3044\u306a\u304b\u3063\u305f\u3089\u3001\u7d42\u4e86\n            if (!$this->_chkMovedClusterPoint($clusterPointArr, $savedClusterPointArr)) {\n                break;\n            }\n            //\u5404\u30c7\u30fc\u30bf\u306e\u6240\u5c5e\u30af\u30e9\u30b9\u30bf\u3092\u5272\u308a\u5f53\u3066\u76f4\u3059\n            $this->_flushBelongCluster($clusterPointArr);\n            $this->_belongCluster($clusterPointArr, $dataPointArr, $distanceName);\n            $this->_saveClusterPoint($clusterPointArr, $savedClusterPointArr);\n        }\n                \n        return $clusterPointArr;\n    }\n\n    /**\n     * \n     * @param type $clusterPointArr\n     */\n    private function _flushBelongCluster(&$clusterPointArr) {\n        foreach ($clusterPointArr as $clusterPoint) {\n            $clusterPoint->flushBelongDataPoints();\n        }\n    }\n\n    /**\n     * \u91cd\u8907\u304c\u3042\u3063\u305f\u3089true\n     * @param type $arr\n     * @return boolean\n     */\n    private function _chkDupValue($arr) {\n        $arrVCount = array_count_values($arr);\n        for ($i = 0; $i < count($arr); $i++) {\n            $key = $arr[$i];\n            $count = $arrVCount[$key];\n            if ($count > 1) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * \n     * @param type $clusterPointArr\n     * @param type $dataPointArr\n     * @param type $distanceName\n     */\n    private function _belongCluster($clusterPointArr, &$dataPointArr, $distanceName) {\n        foreach ($dataPointArr as $dataPoint) {\n            $dataPoint->belongCluster(\n                    $clusterPointArr, \n                    DistanceFactory::create($distanceName));\n        }\n    }\n\n    /**\n     * \n     * @param type $clusterPointArr\n     * @param type $savedClusterPointArr\n     */\n    private function _saveClusterPoint($clusterPointArr, &$savedClusterPointArr) {\n        for ($i = 0; $i < sizeof($clusterPointArr); $i++) {\n            $savedClusterPointArr[$i] = clone $clusterPointArr[$i];\n        }\n    }\n\n    /**\n     * \n     * @return boolean \u524d\u56de\u306e\u30dd\u30a4\u30f3\u30c8\u3068\u52d5\u3044\u3066\u3044\u305f\u3089true\n     */\n    private function _chkMovedClusterPoint($clusterPointArr, $savedClusterPointArr) {\n        for ($i = 0; $i < sizeof($clusterPointArr); $i++) {\n            $diff = array_diff(\n                    $clusterPointArr[$i]->getCoordinate(),\n                    $savedClusterPointArr[$i]->getCoordinate());\n            if ($diff != null) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    /**\n     * \n     * @param type $clusterPointArr\n     */\n    private function _moveClusterPoint(&$clusterPointArr) {\n        foreach ($clusterPointArr as $clusterPoint) {\n            $aveArr = $this->_calcAve($clusterPoint->getBelongDataPoints());\n            if($aveArr == null) continue;\n            $clusterPoint->moveCoodinate($aveArr);\n        }\n    }\n\n    /**\n     * \n     * @param type $dataPointArr\n     * @return type\n     */\n    private function _calcAve($dataPointArr) {\n        if($dataPointArr == null) return null;\n        \n        $sumArr = array();\n        $arrSize = sizeof($dataPointArr[0]->getBelongClusterPoint()->getBelongDataPoints());//0\u306e\u5834\u5408\u30a8\u30e9\u30fc\u306b\u306a\u308b\n        foreach ($dataPointArr as $dataPoint) {\n            $sumArr = $this->_addArr($sumArr, $dataPoint->getCoordinate());\n        }\n        return $this->_divArr($sumArr, $arrSize);\n    }\n\n    private function _divArr($arr, $num) {\n        $result = array();\n        for ($i = 0; $i < sizeof($arr); $i++) {\n            $result[$i] = $arr[$i] / $num;\n        }\n        return $result;\n    }\n\n    /**\n     * \u914d\u5217\u540c\u58eb\uff08\u5404\u5024\uff09\u306e\u8db3\u3057\u7b97\n     * @param type $arr1\n     * @param type $arr2\n     */\n    private function _addArr($arr1, $arr2) {\n        $result = array();\n        for ($i = 0; $i < count($arr2); $i++) {\n            $result[$i] = $arr1[$i] + $arr2[$i];\n        }\n        return $result;\n    }\n\n    /**\n     * \n     * @param type $rangeArr\n     * @param type $k\n     * @return type\n     */\n    private function _getRandPointArr($rangeArr, $k, $vectorDimensionNum) {\n        $randArrArr = array();\n        for ($i = 0; $i < $k; $i++) {\n            $randArr = array(); //int array\n            for ($j = 0; $j < $vectorDimensionNum; $j++) {\n                $randArr[$j] = rand($rangeArr[$j][0], $rangeArr[$j][1]);\n            }\n            $randArrArr[$i] = $randArr;\n        }\n        return $randArrArr;\n    }\n\n    /**\n     * \n     * @param type $dataPointArr\n     * @param type $vectorDimensionNum\n     * @return type\n     */\n    private function _getRange($dataPointArr, $vectorDimensionNum) {\n        $n = $vectorDimensionNum;\n        $rangeArr = array();\n\n        for ($i = 0; $i < $n; $i++) {\n            //n\u8981\u7d20\u76ee\u306b\u3064\u3044\u3066\n            foreach ($dataPointArr as $dataPoint) {\n                $data = $dataPoint->getCoordinate()[$i];\n                //[]\u306b\u3064\u3044\u3066\n                if ($rangeArr[$i][0] === null || $rangeArr[$i][0] >= $data) {\n                    $rangeArr[$i][0] = $data;\n                }\n                if ($rangeArr[$i][1] === null || $rangeArr[$i][1] <= $data) {\n                    $rangeArr[$i][1] = $data;\n                }\n            }\n        }\n        return $rangeArr;\n    }\n}\n\n/**\n * Useage:\n$kmeans = new KMeans();\nvar_dump($kmeans->cluster(\n        array(\n            array(1,1,1),\n            array(1,1,0),\n            array(0,0,0),\n            array(0,0,1)\n        )\n        , 2, \"Euclid\"\n        ));\n*/\n```\n", "tags": ["PHP", "\u7d71\u8a08\u5b66"]}