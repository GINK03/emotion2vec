{"tags": ["\u30a4\u30f3\u30d7\u30ea\u30e1\u30f3\u30c6\u30a3\u30f3\u30b0\u30d5\u30a1\u30f3\u30af\u30b7\u30e7\u30ca\u30eb\u30e9\u30f3\u30b2\u30fc\u30b8\u30ba"], "context": " More than 1 year has passed since last update.\n\n6\u65e5\u76ee\n\u3072\u305f\u3059\u3089\u30d1\u30fc\u30b5\u306e\u5b9f\u88c5\u3092\u3059\u308b\n\n33\u30da\u30fc\u30b8\u304b\u3089\npThen3 :: (a -> b -> c -> d) -> Parser a -> Parser b -> Parser c -> Parser d\npThen3 combine p1 p2 p3 tokens\n    = [(combine v1 v2 v3, tokens3) | (v1, tokens1) <- p1 tokens, (v2, tokens2) <- p2 tokens1, (v3, tokens3) <- p3 tokens2]\n\npThen4 :: (a -> b -> c -> d -> e) -> Parser a -> Parser b -> Parser c -> Parser d -> Parser e\npThen4 combine p1 p2 p3 p4 tokens\n    = [(combine v1 v2 v3 v4, tokens4) | (v1, tokens1) <- p1 tokens, (v2, tokens2) <- p2 tokens1, (v3, tokens3) <- p3 tokens2, (v4, tokens4) <- p4 tokens3]\n\npZeroOrMore :: Parser a -> Parser [a]\npZeroOrMore p = (pOneOrMore p) `pAlt` (pEmpty [])\n\npEmpty :: a -> Parser a\npEmpty s toks = [(s, toks)]\n\npOneOrMore :: Parser a -> Parser [a]\npOneOrMore p = (take 1) . (pThen (:) p (pZeroOrMore p))\n\npApply :: Parser a -> (a -> b) -> Parser b\npApply a f toks = [(f b, tokens) | (b, tokens) <- a toks]\n\npOneOrMoreWithSep :: Parser a -> Parser b -> Parser [a]\npOneOrMoreWithSep a b = pThen (:) a (pThen (\\_ x -> x) b (pOneOrMoreWithSep a b)) `pAlt` (pEmpty [])\n\npSat :: (String -> Bool) -> Parser String\npSat pd = pSatpred\n    where   pSatpred ((n, tok):toks) = if pd tok then [(tok, toks)] else []\n            pSatpred [] = []\n\npProgram :: Parser CoreProgram\npProgram = pOneOrMoreWithSep pSc (pLit \";\")\n\npSc :: Parser CoreScDefn\npSc = pThen4 mk_sc pVar (pZeroOrMore pVar) (pLit \"=\") pExpr\n    where mk_sc name arg _ expr = (name, arg, expr)\n\npExpr :: Parser CoreExpr\npExpr =     pThen mk_ap pExpr pAexpr\n    `pAlt`  pThen3 mk_binop pExpr pBinop pExpr\n    `pAlt`  pThen4 mk_let (pLit \"let\") pDefns (pLit \"=\") pExpr\n    `pAlt`  pThen4 mk_letrec (pLit \"letrec\") pDefns (pLit \"=\") pExpr\n    `pAlt`  pThen4 mk_case (pLit \"case\") pExpr (pLit \"of\") pAlts\n    `pAlt`  pThen4 mk_lam (pLit \"\\\\\") (pOneOrMore pVar) (pLit \".\") pExpr\n    `pAlt`  pAexpr\n    where \n\npAexpr :: Parser CoreExpr\npAexpr =    pVar\n    `pAlt`  pNum\n    `pAlt`  pThen mk_pack2 (pThen4 mk_pack (pThen (:) (pLit \"Pack\") (pLit \"{\")) pNum (pLit \",\") pNum) (pLit \"}\")\n    `pAlt`  pThen3 mk_pexpr (pLit \"(\") pExpr (pLit \")\")\n    where\n\npDefns :: Parser [(Name, Expr Name)]\npDefns = pOneOrMoreWithSep pDefn (pLit \";\")\n\npDefn :: Parser (Name, Expr Name)\npDefn = pThen3 mk_defn pVar (pLit \"=\") pExpr\n        where mk_defn\n\npAlts :: Parser [CoreAlt]\npAlts = pOneOrMoreWithSep pAlt (pLit \";\")\n\npAlt :: Parser CoreAlt\npAlt = pThen4 mk_alt (pThen3 mk_tag (pLit \"<\") pNum (pLit \">\")) (pZeroOrMore pVar) (pLit \"->\") pExpr\n        where\n\npBinop :: Parser String\npBinop = pArithop `pAlt` pRelop `pAlt` pBoolop\n\npArithop :: Parser String\npArithop = (pLit \"+\") `pAlt` (pLit \"-\") `pAlt` (pLit \"*\") `pAlt` (pLit \"//\")\n\npRelop :: Parser String\npRelop = (pLit \"<\") `pAlt` (pLit \"<=\") `pAlt` (pLit \"==\") `pAlt` (pLit \"~=\") `pAlt` (pLit \">=\") `pAlt` (pLit \">\")\n\npBoolop :: Parser String\npBoolop = (pLit \"&\") `pAlt` (pLit \"|\")\n\nsyntax :: [Token] -> CoreProgram\nsyntax = take_first_parse . pProgram\n    where\n    take_first_parse ((prog, []) : others) = prog\n    take_first_parse (parse : others) = take_first_parse others\n    take_first_parse other = error \"Syntax error\"\n\nparse :: String -> CoreProgram\nparse = syntax . clex\n\nmain :: IO ()\n--main = putStrLn $ iDisplay $ pprExpr (ELet nonRecursive [(\"att\", ENum 2)] (EAp (EAp (EVar \"+\") (EVar \"att\")) (EVar \"1\")))\nmain = putStrLn( show (pOneOrMore (pLit \"x\") (replicate 3 (1, \"x\"))))\n\n38\u30da\u30fc\u30b8\u306eExercise 1.20\u3092\u3084\u308a\u304b\u3051\u3067\u7d42\u308f\u3063\u305f\n# 6\u65e5\u76ee\n\n\u3072\u305f\u3059\u3089\u30d1\u30fc\u30b5\u306e\u5b9f\u88c5\u3092\u3059\u308b\n\n## 33\u30da\u30fc\u30b8\u304b\u3089\n\n```hs\npThen3 :: (a -> b -> c -> d) -> Parser a -> Parser b -> Parser c -> Parser d\npThen3 combine p1 p2 p3 tokens\n    = [(combine v1 v2 v3, tokens3) | (v1, tokens1) <- p1 tokens, (v2, tokens2) <- p2 tokens1, (v3, tokens3) <- p3 tokens2]\n\npThen4 :: (a -> b -> c -> d -> e) -> Parser a -> Parser b -> Parser c -> Parser d -> Parser e\npThen4 combine p1 p2 p3 p4 tokens\n    = [(combine v1 v2 v3 v4, tokens4) | (v1, tokens1) <- p1 tokens, (v2, tokens2) <- p2 tokens1, (v3, tokens3) <- p3 tokens2, (v4, tokens4) <- p4 tokens3]\n\npZeroOrMore :: Parser a -> Parser [a]\npZeroOrMore p = (pOneOrMore p) `pAlt` (pEmpty [])\n\npEmpty :: a -> Parser a\npEmpty s toks = [(s, toks)]\n\npOneOrMore :: Parser a -> Parser [a]\npOneOrMore p = (take 1) . (pThen (:) p (pZeroOrMore p))\n\npApply :: Parser a -> (a -> b) -> Parser b\npApply a f toks = [(f b, tokens) | (b, tokens) <- a toks]\n\npOneOrMoreWithSep :: Parser a -> Parser b -> Parser [a]\npOneOrMoreWithSep a b = pThen (:) a (pThen (\\_ x -> x) b (pOneOrMoreWithSep a b)) `pAlt` (pEmpty [])\n\npSat :: (String -> Bool) -> Parser String\npSat pd = pSatpred\n    where   pSatpred ((n, tok):toks) = if pd tok then [(tok, toks)] else []\n            pSatpred [] = []\n\npProgram :: Parser CoreProgram\npProgram = pOneOrMoreWithSep pSc (pLit \";\")\n\npSc :: Parser CoreScDefn\npSc = pThen4 mk_sc pVar (pZeroOrMore pVar) (pLit \"=\") pExpr\n    where mk_sc name arg _ expr = (name, arg, expr)\n\npExpr :: Parser CoreExpr\npExpr =     pThen mk_ap pExpr pAexpr\n    `pAlt`  pThen3 mk_binop pExpr pBinop pExpr\n    `pAlt`  pThen4 mk_let (pLit \"let\") pDefns (pLit \"=\") pExpr\n    `pAlt`  pThen4 mk_letrec (pLit \"letrec\") pDefns (pLit \"=\") pExpr\n    `pAlt`  pThen4 mk_case (pLit \"case\") pExpr (pLit \"of\") pAlts\n    `pAlt`  pThen4 mk_lam (pLit \"\\\\\") (pOneOrMore pVar) (pLit \".\") pExpr\n    `pAlt`  pAexpr\n    where \n\npAexpr :: Parser CoreExpr\npAexpr =    pVar\n    `pAlt`  pNum\n    `pAlt`  pThen mk_pack2 (pThen4 mk_pack (pThen (:) (pLit \"Pack\") (pLit \"{\")) pNum (pLit \",\") pNum) (pLit \"}\")\n    `pAlt`  pThen3 mk_pexpr (pLit \"(\") pExpr (pLit \")\")\n    where\n\npDefns :: Parser [(Name, Expr Name)]\npDefns = pOneOrMoreWithSep pDefn (pLit \";\")\n\npDefn :: Parser (Name, Expr Name)\npDefn = pThen3 mk_defn pVar (pLit \"=\") pExpr\n        where mk_defn\n\npAlts :: Parser [CoreAlt]\npAlts = pOneOrMoreWithSep pAlt (pLit \";\")\n\npAlt :: Parser CoreAlt\npAlt = pThen4 mk_alt (pThen3 mk_tag (pLit \"<\") pNum (pLit \">\")) (pZeroOrMore pVar) (pLit \"->\") pExpr\n        where\n\npBinop :: Parser String\npBinop = pArithop `pAlt` pRelop `pAlt` pBoolop\n\npArithop :: Parser String\npArithop = (pLit \"+\") `pAlt` (pLit \"-\") `pAlt` (pLit \"*\") `pAlt` (pLit \"//\")\n\npRelop :: Parser String\npRelop = (pLit \"<\") `pAlt` (pLit \"<=\") `pAlt` (pLit \"==\") `pAlt` (pLit \"~=\") `pAlt` (pLit \">=\") `pAlt` (pLit \">\")\n\npBoolop :: Parser String\npBoolop = (pLit \"&\") `pAlt` (pLit \"|\")\n\nsyntax :: [Token] -> CoreProgram\nsyntax = take_first_parse . pProgram\n    where\n    take_first_parse ((prog, []) : others) = prog\n    take_first_parse (parse : others) = take_first_parse others\n    take_first_parse other = error \"Syntax error\"\n\nparse :: String -> CoreProgram\nparse = syntax . clex\n\nmain :: IO ()\n--main = putStrLn $ iDisplay $ pprExpr (ELet nonRecursive [(\"att\", ENum 2)] (EAp (EAp (EVar \"+\") (EVar \"att\")) (EVar \"1\")))\nmain = putStrLn( show (pOneOrMore (pLit \"x\") (replicate 3 (1, \"x\"))))\n```\n\n**38\u30da\u30fc\u30b8\u306eExercise 1.20\u3092\u3084\u308a\u304b\u3051\u3067\u7d42\u308f\u3063\u305f**\n"}