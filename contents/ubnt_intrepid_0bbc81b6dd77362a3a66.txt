{"context": "1.15 \u306e\u30ea\u30ea\u30fc\u30b9\u6642\u304b\u3089\u6c17\u306b\u306a\u3063\u3066\u3044\u305f proc_macro \u306b\u3088\u308b custom derive \u306e\u5b9f\u88c5\u3092\u8a66\u3057\u3066\u307f\u307e\u3057\u305f\uff0e\n\u4eca\u56de\u306f\u4e0b\u306e\u30de\u30cb\u30e5\u30a2\u30eb\u3092\u53c2\u8003\u306b\u3057\u307e\u3057\u305f\uff0e\n\nProcedural Macros (and custom Derive)\nsyn - Rust\nquote - Rust\n\n\ncustom derive \u306e\u57fa\u672c\u69cb\u6210\ncustom derive \u306f\uff0c\u5b9f\u88c5\u3059\u308b\u5bfe\u8c61\u306e\u30c8\u30fc\u30af\u30f3\u7cfb\u5217\u304b\u3089\uff08\u8a72\u5f53\u3059\u308b trait \u306e\u5b9f\u88c5\u3092\u8a18\u8ff0\u3057\u305f\u30b3\u30fc\u30c9\u306e\uff09\u30c8\u30fc\u30af\u30f3\u7cfb\u5217\u3092\u8fd4\u3059 #[proc_macro_derive] \u5c5e\u6027\u306e\u3064\u3044\u305f\u95a2\u6570\u3068\u3057\u3066\u5b9f\u88c5\u3057\u307e\u3059\uff08\u95a2\u6570\u540d\u306e\u5236\u7d04\u306f\u3068\u304f\u306b\u306a\u3044\u307f\u305f\u3044\u3067\u3059\uff09\uff0e\u4f8b\u3048\u3070\uff0c#[derive(Hoge)] \u3068\u3044\u3046 custom derive \u3092\u5b9f\u88c5\u3059\u308b\u5834\u5408\u306f\u6b21\u306e\u3088\u3046\u306b\u306a\u308a\u307e\u3059\uff0e\n\ncustom_derive\u306e\u57fa\u672c\u5f62\nextern crate proc_macro;  // Cargo.toml \u3078\u306e\u8ffd\u8a18\u306f\u5fc5\u8981\u306a\u3044\n\nuse proc_macro::TokenStream;\n\n#[proc_macro_derive(Hoge)]\npub fn derive_hoge(input: TokenStream) -> TokenStream {\n  // \u3053\u3053\u306b\u5b9f\u4f53\u3092\u8a18\u8ff0\u3059\u308b\uff0e\n}\n\n\nTokenStream \u306e\u5b9f\u4f53\u306f libsyntax \u5185\u3067\u5b9a\u7fa9\u3055\u308c\u3066\u3044\u308b syntax::tokenstream::TokenStream \u3092\u30e9\u30c3\u30d7\u3057\u305f\u3082\u306e\u3067\u3042\u308a 1 \uff0c\u63d0\u4f9b\u3055\u308c\u3066\u3044\u308b\u30e1\u30bd\u30c3\u30c9\u304c\u6587\u5b57\u5217\u3078\u306e\u5909\u63db\u7a0b\u5ea6\u3057\u304b\u306a\u304f\u89e3\u6790\u7d50\u679c\u3092\u76f4\u63a5\u7528\u3044\u308b\u3053\u3068\u304c\u51fa\u6765\u306a\u3044\u3088\u3046\u306b\u306a\u3063\u3066\u3044\u307e\u3059 2\uff0e\u305d\u306e\u305f\u3081\u73fe\u72b6\u3067\u306f TokenStream \u3092\u4e00\u65e6\u6587\u5b57\u5217\u306b\u5909\u63db\u3057\u3066\u69cb\u6587\u89e3\u6790\u3057\u76f4\u3059\u3053\u3068\u304c\u5fc5\u8981\u3068\u306a\u308b\u4ed5\u69d8\u306b\u306a\u3063\u3066\u3044\u308b\u307f\u305f\u3044\u3067\u3059\uff0e\u3053\u306e\u969b\u306b\u5fc5\u8981\u3068\u306a\u308b Rust \u30b3\u30fc\u30c9\u306e\u69cb\u6587\u89e3\u6790\u5668\u306f syn \u3068\u3044\u3046 crate \u306b\u307e\u3068\u3081\u3089\u308c\u3066\u3044\u307e\u3059\uff0e\n\u307e\u305f\uff0c\u5c0e\u51fa\u3057\u305f\u30b3\u30fc\u30c9\u304b\u3089 TokenStream \u3092\u76f4\u63a5\u751f\u6210\u3059\u308b\u3053\u3068\u306f\u305b\u305a\uff0c quote \u3068\u3044\u3046 crate \u3092\u7528\u3044\u3066\u30c8\u30fc\u30af\u30f3\u5217\u3092\u751f\u6210\u3057\u305f\u5f8c\uff0cquote::Tokens::parse(&self) \u3092\u7528\u3044\u3066 TokenStream \u3092\u751f\u6210\u3057\u307e\u3059\uff0e\n\u4ee5\u4e0a\u306e\u70b9\u3092\u8e0f\u307e\u3048\u308b\u3068\uff0ccustom derive \u306e\u57fa\u672c\u7684\u306a\u30b3\u30fc\u30c9\u306f\u4ee5\u4e0b\u306e\u3088\u3046\u306a\u611f\u3058\u306b\u306a\u308a\u307e\u3059\uff0e\nextern crate proc_macro;\nextern crate syn;\n#[macro_use]\nextern crate quote;\n\n#[proc_macro_derive(Hoge)]\npub fn derive_hoge(input: TokenStream) -> TokenStream {\n  // input \u3092\u89e3\u6790\u3059\u308b\n  // parse_derive_input \u304c\u5165\u529b\u306b\u6587\u5b57\u5217\u3092\u53d7\u3051\u53d6\u308b\u306e\u3067\u6587\u5b57\u5217\u5316\u304c\u5fc5\u8981\n  let ast = syn::parse_derive_input(&input.to_string()).unwrap();\n\n  // ast \u304b\u3089\u5fc5\u8981\u306a\u60c5\u5831\u3092\u62bd\u51fa\u30fb\u5909\u63db\u3059\u308b\n  let name = &ast.ident;                      // \u69cb\u9020\u4f53\u306e\u540d\u524d\n  let body = impl_hogehoge_body(&ast.body);   // \u672c\u4f53\u90e8\u5206\u306e\u30b3\u30fc\u30c9\u3092\u89e3\u6790\u3059\u308b\n  ...\n\n  // \u5c0e\u51fa\u3055\u308c\u305f\u30b3\u30fc\u30c9\u3092\u751f\u6210\u3059\u308b\uff0e\n  // \u30de\u30af\u30ed\u5185\u3067 `#hogehoge` \u3068\u6307\u5b9a\u3059\u308b\u3053\u3068\u3067\u5909\u6570\u3092\u57cb\u3081\u8fbc\u3080\u3053\u3068\u304c\u3067\u304d\u308b\uff0e\n  let result: quote::Tokens = quote! {\n    impl Hogehoge for #name {\n      fn hogehoge(&self) {\n        println!(stringify!(#name));\n        #body\n      }\n    }\n  };\n\n  // \u751f\u6210\u3057\u305f\u30c8\u30fc\u30af\u30f3\u5217\u3092 TokenStream \u306b\u5909\u63db\u3059\u308b\n  result.parse().unwrap()\n}\n\nfn impl_hogehoge_body(body: &syn::Body) -> quote::Tokens {\n  // ...\n}\n\nquote!{} \u3068\u3044\u3046\u30de\u30af\u30ed\u304c\u7528\u610f\u3055\u308c\u3066\u304a\u308a\uff0c\u3053\u308c\u3092\u7528\u3044\u308b\u3053\u3068\u3067 quote::Tokens \u306e\u751f\u6210\u304c\u6bd4\u8f03\u7684\u5bb9\u6613\u306b\u884c\u3048\u308b\u3088\u3046\u306b\u306a\u3063\u3066\u3044\u307e\u3059\uff0equote!() \u5185\u3067\u6307\u5b9a\u3059\u308b\u5909\u6570\u306f quote::ToTokens \u3092\u5b9f\u88c5\u3057\u3066\u3044\u308b\u5fc5\u8981\u304c\u3042\u308b\u3089\u3057\u3044\u3067\u3059\uff0e\u305d\u306e\u4ed6\u8a73\u7d30\u306a\u4ed5\u69d8\u306f quote \u306e\u30de\u30cb\u30e5\u30a2\u30eb\u3092\u53c2\u7167\u3057\u3066\u4e0b\u3055\u3044...\n\n\u4f8b\u984c - clap \u306e\u30d1\u30fc\u30b5\u81ea\u52d5\u751f\u6210 3\n\n\u4f8b\u984c\u3068\u3057\u3066\uff0c clap \u306e\u30b5\u30d6\u30b3\u30de\u30f3\u30c9\u3092\u81ea\u52d5\u751f\u6210\u3059\u308b custom derive \u3092\u4f5c\u3063\u3066\u307f\u305f\u3044\u3068\u601d\u3044\u307e\u3059\uff0e\n\u306a\u304a\uff0c\u4eca\u56de\u306e\u5b9f\u9a13\u7d50\u679c\u306f\u4ee5\u4e0b\u306e\u30ea\u30dd\u30b8\u30c8\u30ea\u306b\u307e\u3068\u3081\u3066\u3044\u307e\u3059\uff0e\nhttps://github.com/ubnt-intrepid/custom-derive-example/tree/3c6f5d1f90c5e7d3cedeae329788b07f0a680d37\n\u4eca\u56de\u306f\uff0c\u6b21\u306e\u3088\u3046\u306a\u30b3\u30fc\u30c9\u3092\u76ee\u6a19\u306b\u3057\u307e\u3059\uff0e\n\ncustom_derive\u4f7f\u7528\u524d\nextern crate clap;\n\ntrait Subcommand {\n  fn app<'a, 'b: 'a>(name: &str) -> clap::App<'a, 'b>;\n}\n\n#[derive(Debug)]\nenum MyApp {\n  Foo(Foo),\n  Bar(Bar),\n}\n\nimpl Subcommand for MyApp {\n  fn app<'a, 'b: 'a>(name: &str) -> clap::App<'a, 'b> {\n    clap::App::new(name)\n      .subcommand(clap::SubCommand::with_name(\"foo\"))\n      .subcommand(clap::SubCommand::with_name(\"bar\"))\n  }\n}\n\nimpl<'a, 'b: 'a> From<&'b clap::ArgMatches<'a>> for MyApp {\n  fn from(m: &'b clap::ArgMatches<'a>) -> MyApp {\n    match m.subcommand() {\n      (\"foo\", _) => MyApp::Foo(Default::default()),\n      (\"bar\", _) => MyApp::Bar(Default::default()),\n      _ => unreachable!(),\n    }\n  }\n}\n\n#[derive(Debug, Default)]\nstruct Foo;\n\n#[derive(Debug, Default)]\nstruct Bar;\n\n\nfn main() {\n  let ref matches = MyApp::app(\"myapp\").get_matches();\n  let app: MyApp = matches.into();\n  println!(\"{:?}\", app);\n}\n\n\n\ncustom_derive\u4f7f\u7528\u5f8c\n#[macro_use]\nextern crate custom_derive;\nextern crate clap;\n\ntrait Subcommand {\n  fn app<'a, 'b: 'a>(name: &str) -> clap::App<'a, 'b>;\n}\n\n#[derive(Debug, Subcommand)]\nenum MyApp {\n  #[clap(name = \"foo\", help = \"Foo App\")]\n  Foo(Foo),\n  #[clap(name = \"bar\", help = \"Bar App\")]\n  Bar(Bar),\n}\n\n#[derive(Debug, Default)]\nstruct Foo;\n\n#[derive(Debug, Default)]\nstruct Bar;\n\n\nfn main() {\n  let ref matches = MyApp::app(\"myapp\").get_matches();\n  let app: MyApp = matches.into();\n  println!(\"{:?}\", app);\n}\n\n\n\n\u5b9f\u88c5\u7d50\u679c\n\u6700\u7d42\u7684\u306b\u3053\u3093\u306a\u611f\u3058\u306b\u306a\u308a\u307e\u3057\u305f\uff0e\nattribute \u3092\u81ea\u524d\u3067\u7528\u610f\u3057\u305f\u3044\u5834\u5408\u306b\u306f #[proc_macro_derive(Subcommand, attributes(clap))] \u306e\u3088\u3046\u306b\u4f7f\u7528\u3059\u308b attribute \u306e\u540d\u524d\u3092\u767b\u9332\u3059\u308b\u5fc5\u8981\u304c\u3042\u308a\u307e\u3059\uff0e\nextern crate proc_macro;\nextern crate syn;\n#[macro_use]\nextern crate quote;\n\nuse proc_macro::TokenStream;\n\n#[proc_macro_derive(Subcommand, attributes(clap))]\npub fn subcommand(input: TokenStream) -> TokenStream {\n  let ast = syn::parse_derive_input(&input.to_string()).unwrap();\n  let gen = impl_subcommand(&ast);\n  gen.parse().unwrap()\n}\n\nimpl_subcommand() \u306e\u5b9f\u88c5\u3092\u4e0b\u306b\u793a\u3057\u307e\u3059\uff0e\u57fa\u672c\u7684\u306b\u306f\uff0c\n\nast \u304b\u3089\u5fc5\u8981\u306a\u60c5\u5831\u3092\u53d6\u308a\u51fa\u3057\u5909\u6570\u306b\u675f\u7e1b\u3059\u308b\n\nquote! {} \u5185\u306b\u51fa\u529b\u3057\u305f\u3044\u30b3\u30fc\u30c9\u3092\u8a18\u8ff0\u3057\uff0c#hogehoge \u3067 ast \u304b\u3089\u53d6\u308a\u51fa\u3057\u305f\u60c5\u5831\u3092\u57cb\u3081\u8fbc\u3080\n\n\u3068\u3044\u3046\u306a\u51e6\u7406\u306e\u6d41\u308c\u3092\u30a4\u30e1\u30fc\u30b8\u3057\u3066\u5b9f\u88c5\u3057\u3066\u3044\u3051\u3070\u826f\u3044\u3068\u601d\u3044\u307e\u3059\uff0e\nfn impl_subcommand(ast: &syn::DeriveInput) -> quote::Tokens {\n  let ref variants = match ast.body {\n    syn::Body::Enum(ref variants) => variants,\n    syn::Body::Struct(_) => unreachable!(),\n  };\n\n  let name = &ast.ident;\n  let subcommand_apps = impl_subcommand_app(variants);\n  let subcommand_froms = impl_subcommand_from(name, variants);\n\n  quote! {\n    impl Subcommand for #name {\n      fn app<'a, 'b: 'a>(name: &str) -> clap::App<'a, 'b> {\n        clap::App::new(name)\n          .setting(clap::AppSettings::VersionlessSubcommands)\n          .setting(clap::AppSettings::SubcommandRequiredElseHelp)\n          #subcommand_apps\n      }\n    }\n    impl<'a, 'b:'a> From<&'b clap::ArgMatches<'a>> for #name {\n      fn from(m: &'b clap::ArgMatches<'a>) -> Self {\n        match m.subcommand() {\n          #subcommand_froms\n          _ => panic!(\"\"),\n        }\n      }\n    }\n  }\n}\n\nfn impl_subcommand_app(variants: &[syn::Variant]) -> quote::Tokens {\n  let variants = variants.into_iter()\n    .map(|v| {\n      let (name, help) = get_attr_name_and_help(&v);\n      let help = help.unwrap_or(\"Put help message\".to_owned());\n      quote! {\n        .subcommand(clap::SubCommand::with_name(#name).about(#help))\n      }\n    });\n\n  let mut tokens = quote::Tokens::new();\n  tokens.append_all(variants);\n  tokens\n}\n\nfn impl_subcommand_from(enumname: &syn::Ident, variants: &[syn::Variant]) -> quote::Tokens {\n  let variants = variants.into_iter()\n    .map(|v| {\n      let (name, _) = get_attr_name_and_help(&v);\n      let ident = &v.ident;\n      quote! { (#name, _) => #enumname :: #ident(Default::default()), }\n    });\n\n  let mut tokens = quote::Tokens::new();\n  tokens.append_all(variants);\n  tokens\n}\n\nget_attr_name_and_help() \u306e\u5b9f\u88c5\u306f\u4e0b\u306e\u3088\u3046\u306a\u611f\u3058\u3067\u3059\uff0e\u5404 variant \u306e attribute \u3092\u53d6\u308a\u51fa\u3059\u305f\u3081\u306b\u30cd\u30b9\u30c8\u304c\u6df1\u304f\u306a\u3063\u3066\u3057\u307e\u3044\u307e\u3057\u305f...\nfn get_attr_name_and_help(v: &syn::Variant) -> (String, Option<String>) {\n  use syn::{MetaItem, NestedMetaItem, Lit};\n\n  let mut name = None;\n  let mut help = None;\n\n  for attr in &v.attrs {\n    let attr: &syn::Attribute = attr;\n    if let MetaItem::List(ref ident, ref items) = attr.value {\n      if ident.as_ref() == \"clap\" {\n        for item in items {\n          if let NestedMetaItem::MetaItem(MetaItem::NameValue(ref ident,\n                                                              Lit::Str(ref value, _))) = *item {\n            match ident.as_ref() {\n              \"name\" => name = Some(value.to_owned()),\n              \"help\" => help = Some(value.to_owned()),\n              _ => unreachable!(),\n            }\n          } else {\n            unreachable!()\n          }\n        }\n      } else {\n        unreachable!()\n      }\n    } else {\n      unreachable!()\n    }\n  }\n\n  (name.unwrap_or_else(|| v.ident.as_ref().to_lowercase()), help)\n}\n\n\n\u304a\u308f\u308a\u306b\n\u7279\u6b8a\u306a\u4ed5\u69d8\u306f quote!() \u30de\u30af\u30ed\u3050\u3089\u3044\u3067\uff0c\u5f8c\u306f syn \u3068 quote \u306e\u30de\u30cb\u30e5\u30a2\u30eb\u3068\u306b\u3089\u3081\u3063\u3053\u3057\u3064\u3064\u6ce8\u610f\u6df1\u304f\u66f8\u3051\u3070\u901a\u5e38\u306e Rust \u3068\u540c\u3058\u611f\u899a\u3067 custom derive \u3092\u5b9f\u88c5\u3059\u308b\u3053\u3068\u304c\u3067\u304d\u305d\u3046\u3067\u3059\uff0e\n\u56fd\u5185\u5916\u306e\u60c5\u5831\u304c\u307e\u3060\u4e4f\u3057\u3044\u3053\u3068\u3092\u8003\u3048\u308b\u3068\u5c0e\u5165\u306e\u6577\u5c45\u306f\u307e\u3060\u5c11\u3057\u9ad8\u305d\u3046\u3067\u3059\u304c\uff0c\u8208\u5473\u306e\u3042\u308b\u65b9\u306f\u8a66\u3057\u3066\u307f\u308b\u3068\u826f\u3044\u306e\u3067\u306f\u306a\u3044\u3067\u3057\u3087\u3046\u304b\uff0e\n\n\n\n\nhttps://manishearth.github.io/rust-internals-docs/proc_macro/struct.TokenStream.html\u00a0\u21a9\n\n\n\u672c\u8a18\u4e8b\u57f7\u7b46\u6642\u306e\u60c5\u5831\u3067\u3042\u308a\uff0c\u4eca\u5f8c\u5909\u66f4\u3055\u308c\u308b\u53ef\u80fd\u6027\u306f\u3042\u308a\u307e\u3059\u304c...\u00a0\u21a9\n\n\nclap \u3092 custom derive \u306b\u5bfe\u5fdc\u3055\u305b\u308b\u63d0\u6848\u81ea\u4f53\u306f\u672c\u5bb6\u306e\u30d7\u30ed\u30b8\u30a7\u30af\u30c8\u3067\u7d76\u8cdb\u9032\u884c\u4e2d\u3067\u3059\uff08\u8a72\u5f53PR: https://github.com/kbknapp/clap-rs/pull/835 \uff09\u00a0\u21a9\n\n\n\n1.15 \u306e\u30ea\u30ea\u30fc\u30b9\u6642\u304b\u3089\u6c17\u306b\u306a\u3063\u3066\u3044\u305f proc_macro \u306b\u3088\u308b custom derive \u306e\u5b9f\u88c5\u3092\u8a66\u3057\u3066\u307f\u307e\u3057\u305f\uff0e\n\n\u4eca\u56de\u306f\u4e0b\u306e\u30de\u30cb\u30e5\u30a2\u30eb\u3092\u53c2\u8003\u306b\u3057\u307e\u3057\u305f\uff0e\n\n* [Procedural Macros (and custom Derive)](https://doc.rust-lang.org/beta/book/procedural-macros.html)\n* [syn - Rust](https://dtolnay.github.io/syn/syn/index.html)\n* [quote - Rust](https://dtolnay.github.io/syn/quote/index.html)\n\n## custom derive \u306e\u57fa\u672c\u69cb\u6210\ncustom derive \u306f\uff0c\u5b9f\u88c5\u3059\u308b\u5bfe\u8c61\u306e\u30c8\u30fc\u30af\u30f3\u7cfb\u5217\u304b\u3089\uff08\u8a72\u5f53\u3059\u308b trait \u306e\u5b9f\u88c5\u3092\u8a18\u8ff0\u3057\u305f\u30b3\u30fc\u30c9\u306e\uff09\u30c8\u30fc\u30af\u30f3\u7cfb\u5217\u3092\u8fd4\u3059 `#[proc_macro_derive]` \u5c5e\u6027\u306e\u3064\u3044\u305f\u95a2\u6570\u3068\u3057\u3066\u5b9f\u88c5\u3057\u307e\u3059\uff08\u95a2\u6570\u540d\u306e\u5236\u7d04\u306f\u3068\u304f\u306b\u306a\u3044\u307f\u305f\u3044\u3067\u3059\uff09\uff0e\u4f8b\u3048\u3070\uff0c`#[derive(Hoge)]` \u3068\u3044\u3046 custom derive \u3092\u5b9f\u88c5\u3059\u308b\u5834\u5408\u306f\u6b21\u306e\u3088\u3046\u306b\u306a\u308a\u307e\u3059\uff0e\n\n```rust:custom_derive\u306e\u57fa\u672c\u5f62\nextern crate proc_macro;  // Cargo.toml \u3078\u306e\u8ffd\u8a18\u306f\u5fc5\u8981\u306a\u3044\n\nuse proc_macro::TokenStream;\n\n#[proc_macro_derive(Hoge)]\npub fn derive_hoge(input: TokenStream) -> TokenStream {\n  // \u3053\u3053\u306b\u5b9f\u4f53\u3092\u8a18\u8ff0\u3059\u308b\uff0e\n}\n```\n\n`TokenStream` \u306e\u5b9f\u4f53\u306f `libsyntax` \u5185\u3067\u5b9a\u7fa9\u3055\u308c\u3066\u3044\u308b `syntax::tokenstream::TokenStream` \u3092\u30e9\u30c3\u30d7\u3057\u305f\u3082\u306e\u3067\u3042\u308a [^2] \uff0c\u63d0\u4f9b\u3055\u308c\u3066\u3044\u308b\u30e1\u30bd\u30c3\u30c9\u304c\u6587\u5b57\u5217\u3078\u306e\u5909\u63db\u7a0b\u5ea6\u3057\u304b\u306a\u304f\u89e3\u6790\u7d50\u679c\u3092\u76f4\u63a5\u7528\u3044\u308b\u3053\u3068\u304c\u51fa\u6765\u306a\u3044\u3088\u3046\u306b\u306a\u3063\u3066\u3044\u307e\u3059 [^3]\uff0e\u305d\u306e\u305f\u3081\u73fe\u72b6\u3067\u306f `TokenStream` \u3092\u4e00\u65e6\u6587\u5b57\u5217\u306b\u5909\u63db\u3057\u3066\u69cb\u6587\u89e3\u6790\u3057\u76f4\u3059\u3053\u3068\u304c\u5fc5\u8981\u3068\u306a\u308b\u4ed5\u69d8\u306b\u306a\u3063\u3066\u3044\u308b\u307f\u305f\u3044\u3067\u3059\uff0e\u3053\u306e\u969b\u306b\u5fc5\u8981\u3068\u306a\u308b Rust \u30b3\u30fc\u30c9\u306e\u69cb\u6587\u89e3\u6790\u5668\u306f `syn` \u3068\u3044\u3046 crate \u306b\u307e\u3068\u3081\u3089\u308c\u3066\u3044\u307e\u3059\uff0e\n\n\u307e\u305f\uff0c\u5c0e\u51fa\u3057\u305f\u30b3\u30fc\u30c9\u304b\u3089 `TokenStream` \u3092\u76f4\u63a5\u751f\u6210\u3059\u308b\u3053\u3068\u306f\u305b\u305a\uff0c `quote` \u3068\u3044\u3046 crate \u3092\u7528\u3044\u3066\u30c8\u30fc\u30af\u30f3\u5217\u3092\u751f\u6210\u3057\u305f\u5f8c\uff0c`quote::Tokens::parse(&self)` \u3092\u7528\u3044\u3066 `TokenStream` \u3092\u751f\u6210\u3057\u307e\u3059\uff0e\n\n[^2]: https://manishearth.github.io/rust-internals-docs/proc_macro/struct.TokenStream.html\n[^3]: \u672c\u8a18\u4e8b\u57f7\u7b46\u6642\u306e\u60c5\u5831\u3067\u3042\u308a\uff0c\u4eca\u5f8c\u5909\u66f4\u3055\u308c\u308b\u53ef\u80fd\u6027\u306f\u3042\u308a\u307e\u3059\u304c...\n\n\u4ee5\u4e0a\u306e\u70b9\u3092\u8e0f\u307e\u3048\u308b\u3068\uff0ccustom derive \u306e\u57fa\u672c\u7684\u306a\u30b3\u30fc\u30c9\u306f\u4ee5\u4e0b\u306e\u3088\u3046\u306a\u611f\u3058\u306b\u306a\u308a\u307e\u3059\uff0e\n\n```rust\nextern crate proc_macro;\nextern crate syn;\n#[macro_use]\nextern crate quote;\n\n#[proc_macro_derive(Hoge)]\npub fn derive_hoge(input: TokenStream) -> TokenStream {\n  // input \u3092\u89e3\u6790\u3059\u308b\n  // parse_derive_input \u304c\u5165\u529b\u306b\u6587\u5b57\u5217\u3092\u53d7\u3051\u53d6\u308b\u306e\u3067\u6587\u5b57\u5217\u5316\u304c\u5fc5\u8981\n  let ast = syn::parse_derive_input(&input.to_string()).unwrap();\n\n  // ast \u304b\u3089\u5fc5\u8981\u306a\u60c5\u5831\u3092\u62bd\u51fa\u30fb\u5909\u63db\u3059\u308b\n  let name = &ast.ident;                      // \u69cb\u9020\u4f53\u306e\u540d\u524d\n  let body = impl_hogehoge_body(&ast.body);   // \u672c\u4f53\u90e8\u5206\u306e\u30b3\u30fc\u30c9\u3092\u89e3\u6790\u3059\u308b\n  ...\n\n  // \u5c0e\u51fa\u3055\u308c\u305f\u30b3\u30fc\u30c9\u3092\u751f\u6210\u3059\u308b\uff0e\n  // \u30de\u30af\u30ed\u5185\u3067 `#hogehoge` \u3068\u6307\u5b9a\u3059\u308b\u3053\u3068\u3067\u5909\u6570\u3092\u57cb\u3081\u8fbc\u3080\u3053\u3068\u304c\u3067\u304d\u308b\uff0e\n  let result: quote::Tokens = quote! {\n    impl Hogehoge for #name {\n      fn hogehoge(&self) {\n        println!(stringify!(#name));\n        #body\n      }\n    }\n  };\n\n  // \u751f\u6210\u3057\u305f\u30c8\u30fc\u30af\u30f3\u5217\u3092 TokenStream \u306b\u5909\u63db\u3059\u308b\n  result.parse().unwrap()\n}\n\nfn impl_hogehoge_body(body: &syn::Body) -> quote::Tokens {\n  // ...\n}\n```\n\n`quote!{}` \u3068\u3044\u3046\u30de\u30af\u30ed\u304c\u7528\u610f\u3055\u308c\u3066\u304a\u308a\uff0c\u3053\u308c\u3092\u7528\u3044\u308b\u3053\u3068\u3067 `quote::Tokens` \u306e\u751f\u6210\u304c\u6bd4\u8f03\u7684\u5bb9\u6613\u306b\u884c\u3048\u308b\u3088\u3046\u306b\u306a\u3063\u3066\u3044\u307e\u3059\uff0e`quote!()` \u5185\u3067\u6307\u5b9a\u3059\u308b\u5909\u6570\u306f `quote::ToTokens` \u3092\u5b9f\u88c5\u3057\u3066\u3044\u308b\u5fc5\u8981\u304c\u3042\u308b\u3089\u3057\u3044\u3067\u3059\uff0e\u305d\u306e\u4ed6\u8a73\u7d30\u306a\u4ed5\u69d8\u306f `quote` \u306e\u30de\u30cb\u30e5\u30a2\u30eb\u3092\u53c2\u7167\u3057\u3066\u4e0b\u3055\u3044...\n\n\n## \u4f8b\u984c - clap \u306e\u30d1\u30fc\u30b5\u81ea\u52d5\u751f\u6210 [^1]\n\u4f8b\u984c\u3068\u3057\u3066\uff0c `clap` \u306e\u30b5\u30d6\u30b3\u30de\u30f3\u30c9\u3092\u81ea\u52d5\u751f\u6210\u3059\u308b custom derive \u3092\u4f5c\u3063\u3066\u307f\u305f\u3044\u3068\u601d\u3044\u307e\u3059\uff0e\n\u306a\u304a\uff0c\u4eca\u56de\u306e\u5b9f\u9a13\u7d50\u679c\u306f\u4ee5\u4e0b\u306e\u30ea\u30dd\u30b8\u30c8\u30ea\u306b\u307e\u3068\u3081\u3066\u3044\u307e\u3059\uff0e\n\nhttps://github.com/ubnt-intrepid/custom-derive-example/tree/3c6f5d1f90c5e7d3cedeae329788b07f0a680d37\n\n[^1]: clap \u3092 custom derive \u306b\u5bfe\u5fdc\u3055\u305b\u308b\u63d0\u6848\u81ea\u4f53\u306f\u672c\u5bb6\u306e\u30d7\u30ed\u30b8\u30a7\u30af\u30c8\u3067\u7d76\u8cdb\u9032\u884c\u4e2d\u3067\u3059\uff08\u8a72\u5f53PR: https://github.com/kbknapp/clap-rs/pull/835 \uff09\n\n\n\u4eca\u56de\u306f\uff0c\u6b21\u306e\u3088\u3046\u306a\u30b3\u30fc\u30c9\u3092\u76ee\u6a19\u306b\u3057\u307e\u3059\uff0e\n\n```rust:custom_derive\u4f7f\u7528\u524d\nextern crate clap;\n\ntrait Subcommand {\n  fn app<'a, 'b: 'a>(name: &str) -> clap::App<'a, 'b>;\n}\n\n#[derive(Debug)]\nenum MyApp {\n  Foo(Foo),\n  Bar(Bar),\n}\n\nimpl Subcommand for MyApp {\n  fn app<'a, 'b: 'a>(name: &str) -> clap::App<'a, 'b> {\n    clap::App::new(name)\n      .subcommand(clap::SubCommand::with_name(\"foo\"))\n      .subcommand(clap::SubCommand::with_name(\"bar\"))\n  }\n}\n\nimpl<'a, 'b: 'a> From<&'b clap::ArgMatches<'a>> for MyApp {\n  fn from(m: &'b clap::ArgMatches<'a>) -> MyApp {\n    match m.subcommand() {\n      (\"foo\", _) => MyApp::Foo(Default::default()),\n      (\"bar\", _) => MyApp::Bar(Default::default()),\n      _ => unreachable!(),\n    }\n  }\n}\n\n#[derive(Debug, Default)]\nstruct Foo;\n\n#[derive(Debug, Default)]\nstruct Bar;\n\n\nfn main() {\n  let ref matches = MyApp::app(\"myapp\").get_matches();\n  let app: MyApp = matches.into();\n  println!(\"{:?}\", app);\n}\n```\n\n```rust:custom_derive\u4f7f\u7528\u5f8c\n#[macro_use]\nextern crate custom_derive;\nextern crate clap;\n\ntrait Subcommand {\n  fn app<'a, 'b: 'a>(name: &str) -> clap::App<'a, 'b>;\n}\n\n#[derive(Debug, Subcommand)]\nenum MyApp {\n  #[clap(name = \"foo\", help = \"Foo App\")]\n  Foo(Foo),\n  #[clap(name = \"bar\", help = \"Bar App\")]\n  Bar(Bar),\n}\n\n#[derive(Debug, Default)]\nstruct Foo;\n\n#[derive(Debug, Default)]\nstruct Bar;\n\n\nfn main() {\n  let ref matches = MyApp::app(\"myapp\").get_matches();\n  let app: MyApp = matches.into();\n  println!(\"{:?}\", app);\n}\n```\n\n## \u5b9f\u88c5\u7d50\u679c\n\u6700\u7d42\u7684\u306b\u3053\u3093\u306a\u611f\u3058\u306b\u306a\u308a\u307e\u3057\u305f\uff0e\n\nattribute \u3092\u81ea\u524d\u3067\u7528\u610f\u3057\u305f\u3044\u5834\u5408\u306b\u306f `#[proc_macro_derive(Subcommand, attributes(clap))]` \u306e\u3088\u3046\u306b\u4f7f\u7528\u3059\u308b attribute \u306e\u540d\u524d\u3092\u767b\u9332\u3059\u308b\u5fc5\u8981\u304c\u3042\u308a\u307e\u3059\uff0e\n\n```rust\nextern crate proc_macro;\nextern crate syn;\n#[macro_use]\nextern crate quote;\n\nuse proc_macro::TokenStream;\n\n#[proc_macro_derive(Subcommand, attributes(clap))]\npub fn subcommand(input: TokenStream) -> TokenStream {\n  let ast = syn::parse_derive_input(&input.to_string()).unwrap();\n  let gen = impl_subcommand(&ast);\n  gen.parse().unwrap()\n}\n```\n\n`impl_subcommand()` \u306e\u5b9f\u88c5\u3092\u4e0b\u306b\u793a\u3057\u307e\u3059\uff0e\u57fa\u672c\u7684\u306b\u306f\uff0c\n\n1. ast \u304b\u3089\u5fc5\u8981\u306a\u60c5\u5831\u3092\u53d6\u308a\u51fa\u3057\u5909\u6570\u306b\u675f\u7e1b\u3059\u308b\n1. `quote! {}` \u5185\u306b\u51fa\u529b\u3057\u305f\u3044\u30b3\u30fc\u30c9\u3092\u8a18\u8ff0\u3057\uff0c`#hogehoge` \u3067 ast \u304b\u3089\u53d6\u308a\u51fa\u3057\u305f\u60c5\u5831\u3092\u57cb\u3081\u8fbc\u3080\n\n\u3068\u3044\u3046\u306a\u51e6\u7406\u306e\u6d41\u308c\u3092\u30a4\u30e1\u30fc\u30b8\u3057\u3066\u5b9f\u88c5\u3057\u3066\u3044\u3051\u3070\u826f\u3044\u3068\u601d\u3044\u307e\u3059\uff0e\n\n```rust\nfn impl_subcommand(ast: &syn::DeriveInput) -> quote::Tokens {\n  let ref variants = match ast.body {\n    syn::Body::Enum(ref variants) => variants,\n    syn::Body::Struct(_) => unreachable!(),\n  };\n\n  let name = &ast.ident;\n  let subcommand_apps = impl_subcommand_app(variants);\n  let subcommand_froms = impl_subcommand_from(name, variants);\n\n  quote! {\n    impl Subcommand for #name {\n      fn app<'a, 'b: 'a>(name: &str) -> clap::App<'a, 'b> {\n        clap::App::new(name)\n          .setting(clap::AppSettings::VersionlessSubcommands)\n          .setting(clap::AppSettings::SubcommandRequiredElseHelp)\n          #subcommand_apps\n      }\n    }\n    impl<'a, 'b:'a> From<&'b clap::ArgMatches<'a>> for #name {\n      fn from(m: &'b clap::ArgMatches<'a>) -> Self {\n        match m.subcommand() {\n          #subcommand_froms\n          _ => panic!(\"\"),\n        }\n      }\n    }\n  }\n}\n\nfn impl_subcommand_app(variants: &[syn::Variant]) -> quote::Tokens {\n  let variants = variants.into_iter()\n    .map(|v| {\n      let (name, help) = get_attr_name_and_help(&v);\n      let help = help.unwrap_or(\"Put help message\".to_owned());\n      quote! {\n        .subcommand(clap::SubCommand::with_name(#name).about(#help))\n      }\n    });\n\n  let mut tokens = quote::Tokens::new();\n  tokens.append_all(variants);\n  tokens\n}\n\nfn impl_subcommand_from(enumname: &syn::Ident, variants: &[syn::Variant]) -> quote::Tokens {\n  let variants = variants.into_iter()\n    .map(|v| {\n      let (name, _) = get_attr_name_and_help(&v);\n      let ident = &v.ident;\n      quote! { (#name, _) => #enumname :: #ident(Default::default()), }\n    });\n\n  let mut tokens = quote::Tokens::new();\n  tokens.append_all(variants);\n  tokens\n}\n```\n\n`get_attr_name_and_help()` \u306e\u5b9f\u88c5\u306f\u4e0b\u306e\u3088\u3046\u306a\u611f\u3058\u3067\u3059\uff0e\u5404 variant \u306e attribute \u3092\u53d6\u308a\u51fa\u3059\u305f\u3081\u306b\u30cd\u30b9\u30c8\u304c\u6df1\u304f\u306a\u3063\u3066\u3057\u307e\u3044\u307e\u3057\u305f...\n\n```rust\nfn get_attr_name_and_help(v: &syn::Variant) -> (String, Option<String>) {\n  use syn::{MetaItem, NestedMetaItem, Lit};\n\n  let mut name = None;\n  let mut help = None;\n\n  for attr in &v.attrs {\n    let attr: &syn::Attribute = attr;\n    if let MetaItem::List(ref ident, ref items) = attr.value {\n      if ident.as_ref() == \"clap\" {\n        for item in items {\n          if let NestedMetaItem::MetaItem(MetaItem::NameValue(ref ident,\n                                                              Lit::Str(ref value, _))) = *item {\n            match ident.as_ref() {\n              \"name\" => name = Some(value.to_owned()),\n              \"help\" => help = Some(value.to_owned()),\n              _ => unreachable!(),\n            }\n          } else {\n            unreachable!()\n          }\n        }\n      } else {\n        unreachable!()\n      }\n    } else {\n      unreachable!()\n    }\n  }\n\n  (name.unwrap_or_else(|| v.ident.as_ref().to_lowercase()), help)\n}\n```\n\n## \u304a\u308f\u308a\u306b\n\u7279\u6b8a\u306a\u4ed5\u69d8\u306f `quote!()` \u30de\u30af\u30ed\u3050\u3089\u3044\u3067\uff0c\u5f8c\u306f `syn` \u3068 `quote` \u306e\u30de\u30cb\u30e5\u30a2\u30eb\u3068\u306b\u3089\u3081\u3063\u3053\u3057\u3064\u3064\u6ce8\u610f\u6df1\u304f\u66f8\u3051\u3070\u901a\u5e38\u306e Rust \u3068\u540c\u3058\u611f\u899a\u3067 custom derive \u3092\u5b9f\u88c5\u3059\u308b\u3053\u3068\u304c\u3067\u304d\u305d\u3046\u3067\u3059\uff0e\n\n\u56fd\u5185\u5916\u306e\u60c5\u5831\u304c\u307e\u3060\u4e4f\u3057\u3044\u3053\u3068\u3092\u8003\u3048\u308b\u3068\u5c0e\u5165\u306e\u6577\u5c45\u306f\u307e\u3060\u5c11\u3057\u9ad8\u305d\u3046\u3067\u3059\u304c\uff0c\u8208\u5473\u306e\u3042\u308b\u65b9\u306f\u8a66\u3057\u3066\u307f\u308b\u3068\u826f\u3044\u306e\u3067\u306f\u306a\u3044\u3067\u3057\u3087\u3046\u304b\uff0e\n", "tags": ["rust", "proc_macro"]}