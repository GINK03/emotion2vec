{"context": "\n\n\u5206\u304b\u3089\u306a\u3044\u3053\u3068\nstruct IBaseFilter;\u3068\u5ba3\u8a00\u3057\u3066\u3044\u308b\u304c\u3001\u3069\u3053\u304b\u3089\u6765\u3066\u3044\u308b\u3082\u306e\u306a\u306e\u304b\u3002\n\u3053\u308c\u304c\u4f55\u8005\u306a\u306e\u304b\u304c\u5206\u304b\u3089\u306a\u3044\u3002\n/*M///////////////////////////////////////////////////////////////////////////////////////\n//\n//  IMPORTANT: READ BEFORE DOWNLOADING, COPYING, INSTALLING OR USING.\n//\n//  By downloading, copying, installing or using the software you agree to this license.\n//  If you do not agree to this license, do not download, install,\n//  copy or use the software.\n//\n//\n//                        Intel License Agreement\n//                For Open Source Computer Vision Library\n//\n// Copyright (C) 2000, Intel Corporation, all rights reserved.\n// Third party copyrights are property of their respective owners.\n//\n// Redistribution and use in source and binary forms, with or without modification,\n// are permitted provided that the following conditions are met:\n//\n//   * Redistribution's of source code must retain the above copyright notice,\n//     this list of conditions and the following disclaimer.\n//\n//   * Redistribution's in binary form must reproduce the above copyright notice,\n//     this list of conditions and the following disclaimer in the documentation\n//     and/or other materials provided with the distribution.\n//\n//   * The name of Intel Corporation may not be used to endorse or promote products\n//     derived from this software without specific prior written permission.\n//\n// This software is provided by the copyright holders and contributors \"as is\" and\n// any express or implied warranties, including, but not limited to, the implied\n// warranties of merchantability and fitness for a particular purpose are disclaimed.\n// In no event shall the Intel Corporation or contributors be liable for any direct,\n// indirect, incidental, special, exemplary, or consequential damages\n// (including, but not limited to, procurement of substitute goods or services;\n// loss of use, data, or profits; or business interruption) however caused\n// and on any theory of liability, whether in contract, strict liability,\n// or tort (including negligence or otherwise) arising in any way out of\n// the use of this software, even if advised of the possibility of such damage.\n//\n//M*/\n\n#include \"precomp.hpp\"\n\n#if (defined WIN32 || defined _WIN32) && defined HAVE_DSHOW\n#include \"cap_dshow.hpp\"\n\n/*\n   DirectShow-based Video Capturing module is based on\n   videoInput library by Theodore Watson:\n   http://muonics.net/school/spring05/videoInput/\n\n   Below is the original copyright\n*/\n\nVideo Capturing module\u306f\u3001videoInput library\u306b\u57fa\u3065\u3044\u3066\u3044\u308b\u3068\u8a00\u3063\u3066\u3044\u308b\u3002\n\n//THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n//IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n//FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n//AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n//LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n//OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n//THE SOFTWARE.\n\n//////////////////////////////////////////////////////////\n//Written by Theodore Watson - theo.watson@gmail.com    //\n//Do whatever you want with this code but if you find   //\n//a bug or make an improvement I would love to know!    //\n//                                                      //\n//Warning This code is experimental                     //\n//use at your own risk :)                               //\n//////////////////////////////////////////////////////////\n/////////////////////////////////////////////////////////\n/*                     Shoutouts\n\nThanks to:\n\n           Dillip Kumar Kara for crossbar code.\n           Zachary Lieberman for getting me into this stuff\n           and for being so generous with time and code.\n           The guys at Potion Design for helping me with VC++\n           Josh Fisher for being a serious C++ nerd :)\n           Golan Levin for helping me debug the strangest\n           and slowest bug in the world!\n\n           And all the people using this library who send in\n           bugs, suggestions and improvements who keep me working on\n           the next version - yeah thanks a lot ;)\n\n*/\n/////////////////////////////////////////////////////////\n\n#if defined _MSC_VER && _MSC_VER >= 100\n//'sprintf': name was marked as #pragma deprecated\n#pragma warning(disable: 4995)\n#endif\n\n#ifdef __MINGW32__\n// MinGW does not understand COM interfaces\n#pragma GCC diagnostic ignored \"-Wnon-virtual-dtor\"\n#endif\n\n#include <tchar.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <math.h>\n#include <string.h>\n#include <wchar.h>\n\n#include <vector>\n\n//Include Directshow stuff here so we don't worry about needing all the h files.\n#if defined _MSC_VER && _MSC_VER >= 1500\n#  include \"DShow.h\"\n#  include \"strmif.h\"\n#  include \"Aviriff.h\"\n#  include \"dvdmedia.h\"\n#  include \"bdaiface.h\"\n#else\n#  ifdef _MSC_VER\n#  define __extension__\n   typedef BOOL WINBOOL;\n#endif\n\n#include \"dshow/dshow.h\"\n#include \"dshow/dvdmedia.h\"\n#include \"dshow/bdatypes.h\"\n\ninterface IEnumPIDMap : public IUnknown\n{\npublic:\n    virtual HRESULT STDMETHODCALLTYPE Next(\n        /* [in] */ ULONG cRequest,\n        /* [size_is][out][in] */ PID_MAP *pPIDMap,\n        /* [out] */ ULONG *pcReceived) = 0;\n\n    virtual HRESULT STDMETHODCALLTYPE Skip(\n        /* [in] */ ULONG cRecords) = 0;\n\n    virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;\n\n    virtual HRESULT STDMETHODCALLTYPE Clone(\n        /* [out] */ IEnumPIDMap **ppIEnumPIDMap) = 0;\n};\n\n\u3053\u3053\u3067\u3001interface\u3068\u3044\u3046\u306e\u306fstruct\u3068define\u3055\u308c\u3066\u3044\u308b\u3089\u3057\u3044\u3002\n\u5b9a\u7fa9\u3055\u308c\u3066\u3044\u308b\u5834\u6240\u3092\u5f8c\u3067\u3061\u3083\u3093\u3068\u898b\u3064\u3051\u308b\u3002\n\n\ninterface IMPEG2PIDMap : public IUnknown\n{\n    virtual HRESULT STDMETHODCALLTYPE MapPID(\n        /* [in] */ ULONG culPID,\n        /* [in] */ ULONG *pulPID,\n        /* [in] */ MEDIA_SAMPLE_CONTENT MediaSampleContent) = 0;\n\n    virtual HRESULT STDMETHODCALLTYPE UnmapPID(\n        /* [in] */ ULONG culPID,\n        /* [in] */ ULONG *pulPID) = 0;\n\n    virtual HRESULT STDMETHODCALLTYPE EnumPIDMap(\n        /* [out] */ IEnumPIDMap **pIEnumPIDMap) = 0;\n};\n\n#endif\n\n//for threading\n#include <process.h>\n\n//this is for TryEnterCriticalSection\n#ifndef _WIN32_WINNT\n#define _WIN32_WINNT 0x400\n#endif\n\n\n/*\nMEDIASUBTYPE_I420 : TGUID ='{30323449-0000-0010-8000-00AA00389B71}';\nMEDIASUBTYPE_Y800 : TGUID ='{30303859-0000-0010-8000-00AA00389B71}';\nMEDIASUBTYPE_Y8   : TGUID ='{20203859-0000-0010-8000-00AA00389B71}';\nMEDIASUBTYPE_Y160 : TGUID ='{30363159-0000-0010-8000-00AA00389B71}';\nMEDIASUBTYPE_YV16 : TGUID ='{32315659-0000-0010-8000-00AA00389B71}';\nMEDIASUBTYPE_Y422 : TGUID ='{32323459-0000-0010-8000-00AA00389B71}';\nMEDIASUBTYPE_GREY : TGUID ='{59455247-0000-0010-8000-00AA00389B71}';\n*/\n\n#include <initguid.h>\n\nDEFINE_GUID(MEDIASUBTYPE_GREY, 0x59455247, 0x0000, 0x0010, 0x80, 0x00,\n    0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71);\nDEFINE_GUID(MEDIASUBTYPE_Y8, 0x20203859, 0x0000, 0x0010, 0x80, 0x00,\n    0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71);\nDEFINE_GUID(MEDIASUBTYPE_Y800, 0x30303859, 0x0000, 0x0010, 0x80, 0x00,\n    0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71);\n\nDEFINE_GUID(CLSID_CaptureGraphBuilder2,0xbf87b6e1,0x8c27,0x11d0,0xb3,0xf0,0x00,0xaa,0x00,0x37,0x61,0xc5);\nDEFINE_GUID(CLSID_FilterGraph,0xe436ebb3,0x524f,0x11ce,0x9f,0x53,0x00,0x20,0xaf,0x0b,0xa7,0x70);\nDEFINE_GUID(CLSID_NullRenderer,0xc1f400a4,0x3f08,0x11d3,0x9f,0x0b,0x00,0x60,0x08,0x03,0x9e,0x37);\nDEFINE_GUID(CLSID_SampleGrabber,0xc1f400a0,0x3f08,0x11d3,0x9f,0x0b,0x00,0x60,0x08,0x03,0x9e,0x37);\nDEFINE_GUID(CLSID_SystemDeviceEnum,0x62be5d10,0x60eb,0x11d0,0xbd,0x3b,0x00,0xa0,0xc9,0x11,0xce,0x86);\nDEFINE_GUID(CLSID_VideoInputDeviceCategory,0x860bb310,0x5d01,0x11d0,0xbd,0x3b,0x00,0xa0,0xc9,0x11,0xce,0x86);\nDEFINE_GUID(FORMAT_VideoInfo,0x05589f80,0xc356,0x11ce,0xbf,0x01,0x00,0xaa,0x00,0x55,0x59,0x5a);\nDEFINE_GUID(IID_IAMAnalogVideoDecoder,0xc6e13350,0x30ac,0x11d0,0xa1,0x8c,0x00,0xa0,0xc9,0x11,0x89,0x56);\nDEFINE_GUID(IID_IAMCameraControl,0xc6e13370,0x30ac,0x11d0,0xa1,0x8c,0x00,0xa0,0xc9,0x11,0x89,0x56);\nDEFINE_GUID(IID_IAMCrossbar,0xc6e13380,0x30ac,0x11d0,0xa1,0x8c,0x00,0xa0,0xc9,0x11,0x89,0x56);\nDEFINE_GUID(IID_IAMStreamConfig,0xc6e13340,0x30ac,0x11d0,0xa1,0x8c,0x00,0xa0,0xc9,0x11,0x89,0x56);\nDEFINE_GUID(IID_IAMVideoProcAmp,0xc6e13360,0x30ac,0x11d0,0xa1,0x8c,0x00,0xa0,0xc9,0x11,0x89,0x56);\nDEFINE_GUID(IID_IBaseFilter,0x56a86895,0x0ad4,0x11ce,0xb0,0x3a,0x00,0x20,0xaf,0x0b,0xa7,0x70);\nDEFINE_GUID(IID_ICaptureGraphBuilder2,0x93e5a4e0,0x2d50,0x11d2,0xab,0xfa,0x00,0xa0,0xc9,0xc6,0xe3,0x8d);\nDEFINE_GUID(IID_ICreateDevEnum,0x29840822,0x5b84,0x11d0,0xbd,0x3b,0x00,0xa0,0xc9,0x11,0xce,0x86);\nDEFINE_GUID(IID_IGraphBuilder,0x56a868a9,0x0ad4,0x11ce,0xb0,0x3a,0x00,0x20,0xaf,0x0b,0xa7,0x70);\nDEFINE_GUID(IID_IMPEG2PIDMap,0xafb6c2a1,0x2c41,0x11d3,0x8a,0x60,0x00,0x00,0xf8,0x1e,0x0e,0x4a);\nDEFINE_GUID(IID_IMediaControl,0x56a868b1,0x0ad4,0x11ce,0xb0,0x3a,0x00,0x20,0xaf,0x0b,0xa7,0x70);\nDEFINE_GUID(IID_IMediaFilter,0x56a86899,0x0ad4,0x11ce,0xb0,0x3a,0x00,0x20,0xaf,0x0b,0xa7,0x70);\nDEFINE_GUID(IID_ISampleGrabber,0x6b652fff,0x11fe,0x4fce,0x92,0xad,0x02,0x66,0xb5,0xd7,0xc7,0x8f);\nDEFINE_GUID(LOOK_UPSTREAM_ONLY,0xac798be0,0x98e3,0x11d1,0xb3,0xf1,0x00,0xaa,0x00,0x37,0x61,0xc5);\nDEFINE_GUID(MEDIASUBTYPE_AYUV,0x56555941,0x0000,0x0010,0x80,0x00,0x00,0xaa,0x00,0x38,0x9b,0x71);\nDEFINE_GUID(MEDIASUBTYPE_IYUV,0x56555949,0x0000,0x0010,0x80,0x00,0x00,0xaa,0x00,0x38,0x9b,0x71);\nDEFINE_GUID(MEDIASUBTYPE_RGB24,0xe436eb7d,0x524f,0x11ce,0x9f,0x53,0x00,0x20,0xaf,0x0b,0xa7,0x70);\nDEFINE_GUID(MEDIASUBTYPE_RGB32,0xe436eb7e,0x524f,0x11ce,0x9f,0x53,0x00,0x20,0xaf,0x0b,0xa7,0x70);\nDEFINE_GUID(MEDIASUBTYPE_RGB555,0xe436eb7c,0x524f,0x11ce,0x9f,0x53,0x00,0x20,0xaf,0x0b,0xa7,0x70);\nDEFINE_GUID(MEDIASUBTYPE_RGB565,0xe436eb7b,0x524f,0x11ce,0x9f,0x53,0x00,0x20,0xaf,0x0b,0xa7,0x70);\nDEFINE_GUID(MEDIASUBTYPE_I420,0x30323449,0x0000,0x0010,0x80,0x00,0x00,0xaa,0x00,0x38,0x9b,0x71);\nDEFINE_GUID(MEDIASUBTYPE_UYVY,0x59565955,0x0000,0x0010,0x80,0x00,0x00,0xaa,0x00,0x38,0x9b,0x71);\nDEFINE_GUID(MEDIASUBTYPE_Y211,0x31313259,0x0000,0x0010,0x80,0x00,0x00,0xaa,0x00,0x38,0x9b,0x71);\nDEFINE_GUID(MEDIASUBTYPE_Y411,0x31313459,0x0000,0x0010,0x80,0x00,0x00,0xaa,0x00,0x38,0x9b,0x71);\nDEFINE_GUID(MEDIASUBTYPE_Y41P,0x50313459,0x0000,0x0010,0x80,0x00,0x00,0xaa,0x00,0x38,0x9b,0x71);\nDEFINE_GUID(MEDIASUBTYPE_YUY2,0x32595559,0x0000,0x0010,0x80,0x00,0x00,0xaa,0x00,0x38,0x9b,0x71);\nDEFINE_GUID(MEDIASUBTYPE_YUYV,0x56595559,0x0000,0x0010,0x80,0x00,0x00,0xaa,0x00,0x38,0x9b,0x71);\nDEFINE_GUID(MEDIASUBTYPE_YV12,0x32315659,0x0000,0x0010,0x80,0x00,0x00,0xaa,0x00,0x38,0x9b,0x71);\nDEFINE_GUID(MEDIASUBTYPE_YVU9,0x39555659,0x0000,0x0010,0x80,0x00,0x00,0xaa,0x00,0x38,0x9b,0x71);\nDEFINE_GUID(MEDIASUBTYPE_YVYU,0x55595659,0x0000,0x0010,0x80,0x00,0x00,0xaa,0x00,0x38,0x9b,0x71);\nDEFINE_GUID(MEDIASUBTYPE_MJPG,0x47504A4D, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71); // MGB\nDEFINE_GUID(MEDIATYPE_Interleaved,0x73766169,0x0000,0x0010,0x80,0x00,0x00,0xaa,0x00,0x38,0x9b,0x71);\nDEFINE_GUID(MEDIATYPE_Video,0x73646976,0x0000,0x0010,0x80,0x00,0x00,0xaa,0x00,0x38,0x9b,0x71);\nDEFINE_GUID(PIN_CATEGORY_CAPTURE,0xfb6c4281,0x0353,0x11d1,0x90,0x5f,0x00,0x00,0xc0,0xcc,0x16,0xba);\nDEFINE_GUID(PIN_CATEGORY_PREVIEW,0xfb6c4282,0x0353,0x11d1,0x90,0x5f,0x00,0x00,0xc0,0xcc,0x16,0xba);\n\ninterface ISampleGrabberCB : public IUnknown\n{\n    virtual HRESULT STDMETHODCALLTYPE SampleCB(\n        double SampleTime,\n        IMediaSample *pSample) = 0;\n\n    virtual HRESULT STDMETHODCALLTYPE BufferCB(\n        double SampleTime,\n        BYTE *pBuffer,\n        LONG BufferLen) = 0;\n};\n\nISampleGrabberCB \u30a4\u30f3\u30bf\u30fc\u30d5\u30a7\u30a4\u30b9\u306f\u3001ISampleGrabber::SetCallback \u30e1\u30bd\u30c3\u30c9\u306b\u5bfe\u5fdc\u3059\u308b\u30b3\u30fc\u30eb\u30d0\u30c3\u30af \u30e1\u30bd\u30c3\u30c9\u3092\u63d0\u4f9b\u3059\u308b\u3002\u3053\u306e\u30e1\u30bd\u30c3\u30c9\u3092\u547c\u3073\u51fa\u3059\u30a2\u30d7\u30ea\u30b1\u30fc\u30b7\u30e7\u30f3\u3067\u306f\u3001\u3053\u306e\u30a4\u30f3\u30bf\u30fc\u30d5\u30a7\u30a4\u30b9\u3092\u5b9f\u88c5\u3059\u308b\u5fc5\u8981\u304c\u3042\u308b\u3002\u8a73\u7d30\u306b\u3064\u3044\u3066\u306f\u3001\uff62ISampleGrabber\uff63\u3092\u53c2\u7167\u3059\u308b\u3053\u3068\u3002\nIUnknown \u304b\u3089\u7d99\u627f\u3057\u305f\u30e1\u30bd\u30c3\u30c9\u306b\u52a0\u3048\u3066\u3001ISampleGrabber \u30a4\u30f3\u30bf\u30fc\u30d5\u30a7\u30a4\u30b9\u306f\u6b21\u306e\u30e1\u30bd\u30c3\u30c9\u3092\u516c\u958b\u3059\u308b\u3002\n\n\n\n\u30e1\u30bd\u30c3\u30c9\n\u8aac\u660e\n\n\n\n\nBufferCB\n\u30b5\u30f3\u30d7\u30eb\u30d0\u30c3\u30d5\u30a1\u3078\u306e\u30dd\u30a4\u30f3\u30bf\u3092\u53d7\u3051\u53d6\u308b\u30b3\u30fc\u30eb\u30d0\u30c3\u30af\u30e1\u30bd\u30c3\u30c9\u3002\n\n\nSampleCB\n\u30e1\u30c7\u30a3\u30a2\u30b5\u30f3\u30d7\u30eb\u3078\u306e\u30dd\u30a4\u30f3\u30bf\u3092\u53d7\u3051\u53d6\u308b\u30b3\u30fc\u30eb\u30d0\u30c3\u30af\u30e1\u30bd\u30c3\u30c9\u3002\n\n\n\ninterface ISampleGrabber : public IUnknown\n{\n    virtual HRESULT STDMETHODCALLTYPE SetOneShot(\n        BOOL OneShot) = 0;\n\n    virtual HRESULT STDMETHODCALLTYPE SetMediaType(\n        const AM_MEDIA_TYPE *pType) = 0;\n\n    virtual HRESULT STDMETHODCALLTYPE GetConnectedMediaType(\n        AM_MEDIA_TYPE *pType) = 0;\n\n    virtual HRESULT STDMETHODCALLTYPE SetBufferSamples(\n        BOOL BufferThem) = 0;\n\n    virtual HRESULT STDMETHODCALLTYPE GetCurrentBuffer(\n        LONG *pBufferSize,\n        LONG *pBuffer) = 0;\n\n    virtual HRESULT STDMETHODCALLTYPE GetCurrentSample(\n        IMediaSample **ppSample) = 0;\n\n    virtual HRESULT STDMETHODCALLTYPE SetCallback(\n        ISampleGrabberCB *pCallback,\n        LONG WhichMethodToCallback) = 0;\n};\n\n\nISampleGrabber \u30a4\u30f3\u30bf\u30fc\u30d5\u30a7\u30a4\u30b9\u306f\u3001\u30b5\u30f3\u30d7\u30eb \u30b0\u30e9\u30d0 \u30d5\u30a3\u30eb\u30bf\u306b\u3088\u3063\u3066\u516c\u958b\u3055\u308c\u308b\u3002\u30a2\u30d7\u30ea\u30b1\u30fc\u30b7\u30e7\u30f3\u306f\u3001\u3053\u306e\u30a4\u30f3\u30bf\u30fc\u30d5\u30a7\u30a4\u30b9\u3092\u4f7f\u3063\u3066\u3001\u30d5\u30a3\u30eb\u30bf \u30b0\u30e9\u30d5\u5185\u3092\u901a\u308b\u500b\u3005\u306e\u30e1\u30c7\u30a3\u30a2 \u30b5\u30f3\u30d7\u30eb\u3092\u53d6\u5f97\u3067\u304d\u308b\u3002\nIUnknown \u304b\u3089\u7d99\u627f\u3057\u305f\u30e1\u30bd\u30c3\u30c9\u306b\u52a0\u3048\u3066\u3001ISampleGrabber \u30a4\u30f3\u30bf\u30fc\u30d5\u30a7\u30a4\u30b9\u306f\u6b21\u306e\u30e1\u30bd\u30c3\u30c9\u3092\u516c\u958b\u3059\u308b\u3002\n\n\n\n\u30e1\u30bd\u30c3\u30c9\n\u8aac\u660e\n\n\n\n\nSetOneShot\n\u30b5\u30f3\u30d7\u30eb\u3092 1 \u3064\u53d7\u3051\u53d6\u3063\u305f\u3089\u30d5\u30a3\u30eb\u30bf\u304c\u30b0\u30e9\u30d5\u3092\u505c\u6b62\u3059\u3079\u304d\u304b\u3069\u3046\u304b\u3092\u6307\u5b9a\u3059\u308b\u3002\n\n\nSetMediaType\n\u30b5\u30f3\u30d7\u30eb \u30b0\u30e9\u30d0\u306e\u5165\u529b\u30d4\u30f3\u4e0a\u306e\u63a5\u7d9a\u306b\u4f7f\u3046\u30e1\u30c7\u30a3\u30a2 \u30bf\u30a4\u30d7\u3092\u6307\u5b9a\u3059\u308b\u3002\n\n\nGetConnectedMediaType\n\u30b5\u30f3\u30d7\u30eb \u30b0\u30e9\u30d0\u306e\u5165\u529b\u30d4\u30f3\u4e0a\u306e\u63a5\u7d9a\u306b\u4f7f\u3046\u30e1\u30c7\u30a3\u30a2 \u30bf\u30a4\u30d7\u3092\u53d6\u5f97\u3059\u308b\u3002\n\n\nSetBufferSamples\n\u30d5\u30a3\u30eb\u30bf\u5185\u3092\u901a\u308b\u30b5\u30f3\u30d7\u30eb\u3092\u30d0\u30c3\u30d5\u30a1\u306b\u30b3\u30d4\u30fc\u3059\u308b\u304b\u3069\u3046\u304b\u3092\u6307\u5b9a\u3059\u308b\u3002\n\n\nGetCurrentBuffer\n\u30d5\u30a3\u30eb\u30bf\u304c\u53d7\u3051\u53d6\u3063\u305f\u6700\u65b0\u30b5\u30f3\u30d7\u30eb\u306e\u30b3\u30d4\u30fc\u3092\u53d6\u5f97\u3059\u308b\u3002\n\n\nGetCurrentSample\n\u73fe\u5728\u306f\u5b9f\u88c5\u3055\u308c\u3066\u3044\u306a\u3044\u3002\n\n\nSetCallback\n\u30b5\u30f3\u30d7\u30eb\u5230\u7740\u6642\u306b\u547c\u3073\u51fa\u3059\u30b3\u30fc\u30eb\u30d0\u30c3\u30af \u30e1\u30bd\u30c3\u30c9\u3092\u6307\u5b9a\u3059\u308b\u3002\n\n\n\n\n#ifndef HEADER\n#define HEADER(p) (&(((VIDEOINFOHEADER*)(p))->bmiHeader))\n#endif\n\n//Example Usage\n/*\n    //create a videoInput object\n    videoInput VI;\n\n    //Prints out a list of available devices and returns num of devices found\n    int numDevices = VI.listDevices();\n\n    int device1 = 0;  //this could be any deviceID that shows up in listDevices\n    int device2 = 1;  //this could be any deviceID that shows up in listDevices\n\n    //if you want to capture at a different frame rate (default is 30)\n    //specify it here, you are not guaranteed to get this fps though.\n    //VI.setIdealFramerate(dev, 60);\n\n    //setup the first device - there are a number of options:\n\n    VI.setupDevice(device1);                           //setup the first device with the default settings\n    //VI.setupDevice(device1, VI_COMPOSITE);           //or setup device with specific connection type\n    //VI.setupDevice(device1, 320, 240);               //or setup device with specified video size\n    //VI.setupDevice(device1, 320, 240, VI_COMPOSITE); //or setup device with video size and connection type\n\n    //VI.setFormat(device1, VI_NTSC_M);                //if your card doesn't remember what format it should be\n                                                       //call this with the appropriate format listed above\n                                                       //NOTE: must be called after setupDevice!\n\n    //optionally setup a second (or third, fourth ...) device - same options as above\n    VI.setupDevice(device2);\n\n    //As requested width and height can not always be accomodated\n    //make sure to check the size once the device is setup\n\n    int width   = VI.getWidth(device1);\n    int height  = VI.getHeight(device1);\n    int size    = VI.getSize(device1);\n\n    unsigned char * yourBuffer1 = new unsigned char[size];\n    unsigned char * yourBuffer2 = new unsigned char[size];\n\n    //to get the data from the device first check if the data is new\n    if(VI.isFrameNew(device1)){\n        VI.getPixels(device1, yourBuffer1, false, false);   //fills pixels as a BGR (for openCV) unsigned char array - no flipping\n        VI.getPixels(device1, yourBuffer2, true, true);     //fills pixels as a RGB (for openGL) unsigned char array - flipping!\n    }\n\n    //same applies to device2 etc\n\n    //to get a settings dialog for the device\n    VI.showSettingsWindow(device1);\n\n\n    //Shut down devices properly\n    VI.stopDevice(device1);\n    VI.stopDevice(device2);\n*/\n\n\n//////////////////////////////////////   VARS AND DEFS   //////////////////////////////////\n\n\n//STUFF YOU CAN CHANGE\n\n#ifdef _DEBUG\n#include <strsafe.h>\n\n//change for verbose debug info\nstatic bool gs_verbose = true;\n\nstatic void DebugPrintOut(const char *format, ...)\n{\n    if (gs_verbose)\n    {\n        va_list args;\n        va_start(args, format);\n        if( ::IsDebuggerPresent() )\n        {\n            CHAR szMsg[512];\n            ::StringCbVPrintfA(szMsg, sizeof(szMsg), format, args);\n            ::OutputDebugStringA(szMsg);\n        }\n        else\n        {\n            vprintf(format, args);\n        }\n        va_end (args);\n    }\n}\n#else\n#define DebugPrintOut(...) void()\n#endif\n\n//if you need VI to use multi threaded com\n//#define VI_COM_MULTI_THREADED\n\n//STUFF YOU DON'T CHANGE\n\n//videoInput defines\n#define VI_VERSION      0.1995\n#define VI_MAX_CAMERAS  20\n#define VI_NUM_TYPES    20 //MGB\n#define VI_NUM_FORMATS  18 //DON'T TOUCH\n\n//defines for setPhyCon - tuner is not as well supported as composite and s-video\n#define VI_COMPOSITE 0\n#define VI_S_VIDEO   1\n#define VI_TUNER     2\n#define VI_USB       3\n#define VI_1394      4\n\n//defines for formats\n#define VI_NTSC_M   0\n#define VI_PAL_B    1\n#define VI_PAL_D    2\n#define VI_PAL_G    3\n#define VI_PAL_H    4\n#define VI_PAL_I    5\n#define VI_PAL_M    6\n#define VI_PAL_N    7\n#define VI_PAL_NC   8\n#define VI_SECAM_B  9\n#define VI_SECAM_D  10\n#define VI_SECAM_G  11\n#define VI_SECAM_H  12\n#define VI_SECAM_K  13\n#define VI_SECAM_K1 14\n#define VI_SECAM_L  15\n#define VI_NTSC_M_J 16\n#define VI_NTSC_433 17\n\n\n//allows us to directShow classes here with the includes in the cpp\nstruct ICaptureGraphBuilder2;\nstruct IGraphBuilder;\nstruct IBaseFilter;\n\n\u300ccpp\u306e\u4e2d\u306e\u30a4\u30f3\u30af\u30eb\u30fc\u30c9\u30d5\u30a1\u30a4\u30eb\u306b\u3088\u3063\u3066\u3053\u3053\u306b\u3042\u308bdirectshow classes\u304c\u4f7f\u3048\u308b\u3088\u3046\u306b\u306a\u308b\u300d\n\nstruct IAMCrossbar;\nstruct IMediaControl;\nstruct ISampleGrabber;\nstruct IMediaEventEx;\nstruct IAMStreamConfig;\nstruct _AMMediaType;\nclass SampleGrabberCallback;\ntypedef _AMMediaType AM_MEDIA_TYPE;\n\n//keeps track of how many instances of VI are being used\n//don't touch\n//static int comInitCount = 0;\n\n\n////////////////////////////////////////   VIDEO DEVICE   ///////////////////////////////////\n\nclass videoDevice{\n\n\n    public:\n\n        videoDevice();\n        void setSize(int w, int h);\n        void NukeDownstream(IBaseFilter *pBF);\n\nIBaseFilter\u3068\u3044\u3046\u578b\u306f\u305d\u3082\u305d\u3082\u4f55\u306a\u306e\u304b\uff1f\n\u3053\u306eIBaseFilter *pBF\u3068\u3044\u3046\u306e\u306b\u6ce8\u76ee\u3057\u3066\u3069\u3053\u304b\u3089\u6765\u308b\u306e\u304b\u3092\u78ba\u304b\u3081\u308b\u3002\n        void destroyGraph();\n        ~videoDevice();\n\n        int videoSize;\n        int width;\n        int height;\n\n        int tryWidth;\n        int tryHeight;\n        GUID tryVideoType;\n\n        ICaptureGraphBuilder2 *pCaptureGraph;    // Capture graph builder object\n        IGraphBuilder *pGraph;                    // Graph builder object\n        IMediaControl *pControl;                // Media control object\n        IBaseFilter *pVideoInputFilter;          // Video Capture filter\n\n\n\u3053\u306eVideo Capture filter\u3082\u3069\u3053\u306b\u884c\u3063\u3066\u3044\u308b\u306e\u304b\u8ffd\u8de1\u3059\u308b\u3002\n\n\n        IBaseFilter *pGrabberF;\n        IBaseFilter * pDestFilter;\n        IAMStreamConfig *streamConf;\n        ISampleGrabber * pGrabber;                // Grabs frame\n        AM_MEDIA_TYPE * pAmMediaType;\n\n        IMediaEventEx * pMediaEvent;\n\n        GUID videoType;\n        long formatType;\n\n        SampleGrabberCallback * sgCallback;\n\n        bool tryDiffSize;\n        bool useCrossbar;\n        bool readyToCapture;\n        bool sizeSet;\n        bool setupStarted;\n        bool specificFormat;\n        bool autoReconnect;\n        int  nFramesForReconnect;\n        unsigned long nFramesRunning;\n        int  connection;\n        int  storeConn;\n        int  myID;\n        long requestedFrameTime; //ie fps\n\n        char  nDeviceName[255];\n        WCHAR wDeviceName[255];\n\n        unsigned char * pixels;\n        char * pBuffer;\n\n};\n\n//////////////////////////////////////   VIDEO INPUT   /////////////////////////////////////\nclass videoInput{\n\n    public:\n        videoInput();\n        ~videoInput();\n\n        //turns off console messages - default is to print messages\n        static void setVerbose(bool _verbose);\n\n        //Functions in rough order they should be used.\n        static int listDevices(bool silent = false);\n\n        //needs to be called after listDevices - otherwise returns NULL\n        static char * getDeviceName(int deviceID);\n\n        //choose to use callback based capture - or single threaded\n        void setUseCallback(bool useCallback);\n\n        //call before setupDevice\n        //directshow will try and get the closest possible framerate to what is requested\n        void setIdealFramerate(int deviceID, int idealFramerate);\n\n        //some devices will stop delivering frames after a while - this method gives you the option to try and reconnect\n        //to a device if videoInput detects that a device has stopped delivering frames.\n        //you MUST CALL isFrameNew every app loop for this to have any effect\n        void setAutoReconnectOnFreeze(int deviceNumber, bool doReconnect, int numMissedFramesBeforeReconnect);\n\n        //Choose one of these five to setup your device\n        bool setupDevice(int deviceID);\n        bool setupDevice(int deviceID, int w, int h);\n        bool setupDeviceFourcc(int deviceID, int w, int h,int fourcc);\n\n        //These two are only for capture cards\n        //USB and Firewire cameras souldn't specify connection\n        bool setupDevice(int deviceID, int connection);\n        bool setupDevice(int deviceID, int w, int h, int connection);\n\n        bool setFourcc(int deviceNumber, int fourcc);\n\n        //If you need to you can set your NTSC/PAL/SECAM\n        //preference here. if it is available it will be used.\n        //see #defines above for available formats - eg VI_NTSC_M or VI_PAL_B\n        //should be called after setupDevice\n        //can be called multiple times\n        bool setFormat(int deviceNumber, int format);\n\n        //Tells you when a new frame has arrived - you should call this if you have specified setAutoReconnectOnFreeze to true\n        bool isFrameNew(int deviceID);\n\n        bool isDeviceSetup(int deviceID) const;\n\n        //Returns the pixels - flipRedAndBlue toggles RGB/BGR flipping - and you can flip the image too\n        unsigned char * getPixels(int deviceID, bool flipRedAndBlue = true, bool flipImage = false);\n\n        //Or pass in a buffer for getPixels to fill returns true if successful.\n        bool getPixels(int id, unsigned char * pixels, bool flipRedAndBlue = true, bool flipImage = false);\n\n        //Launches a pop up settings window\n        //For some reason in GLUT you have to call it twice each time.\n        void showSettingsWindow(int deviceID);\n\n        //Manual control over settings thanks.....\n        //These are experimental for now.\n        bool setVideoSettingFilter(int deviceID, long Property, long lValue, long Flags = 0, bool useDefaultValue = false);\n        bool setVideoSettingFilterPct(int deviceID, long Property, float pctValue, long Flags = 0);\n        bool getVideoSettingFilter(int deviceID, long Property, long &min, long &max, long &SteppingDelta, long &currentValue, long &flags, long &defaultValue);\n\n        bool setVideoSettingCamera(int deviceID, long Property, long lValue, long Flags = 0, bool useDefaultValue = false);\n        bool setVideoSettingCameraPct(int deviceID, long Property, float pctValue, long Flags = 0);\n        bool getVideoSettingCamera(int deviceID, long Property, long &min, long &max, long &SteppingDelta, long &currentValue, long &flags, long &defaultValue);\n\n        //bool setVideoSettingCam(int deviceID, long Property, long lValue, long Flags = NULL, bool useDefaultValue = false);\n\n        //get width, height and number of pixels\n        int  getWidth(int deviceID) const;\n        int  getHeight(int deviceID) const;\n        int  getSize(int deviceID) const;\n        int  getFourcc(int deviceID) const;\n        double getFPS(int deviceID) const;\n\n        //completely stops and frees a device\n        void stopDevice(int deviceID);\n\n        //as above but then sets it up with same settings\n        bool restartDevice(int deviceID);\n\n        //number of devices available\n        int  devicesFound;\n\n        // mapping from OpenCV CV_CAP_PROP to videoinput/dshow properties\n        int getVideoPropertyFromCV(int cv_property);\n        int getCameraPropertyFromCV(int cv_property);\n\n    private:\n        void setPhyCon(int deviceID, int conn);\n        void setAttemptCaptureSize(int deviceID, int w, int h,GUID mediaType=MEDIASUBTYPE_RGB24);\n        bool setup(int deviceID);\n        void processPixels(unsigned char * src, unsigned char * dst, int width, int height, bool bRGB, bool bFlip);\n        int  start(int deviceID, videoDevice * VD);\n        int  getDeviceCount();\n        void getMediaSubtypeAsString(GUID type, char * typeAsString);\n        GUID *getMediaSubtypeFromFourcc(int fourcc);\n        int   getFourccFromMediaSubtype(GUID type) const;\n\n        void getVideoPropertyAsString(int prop, char * propertyAsString);\n        void getCameraPropertyAsString(int prop, char * propertyAsString);\n\n        HRESULT getDevice(IBaseFilter **pSrcFilter, int deviceID, WCHAR * wDeviceName, char * nDeviceName);\n        static HRESULT ShowFilterPropertyPages(IBaseFilter *pFilter);\n        static HRESULT ShowStreamPropertyPages(IAMStreamConfig  *pStream);\n\n        HRESULT SaveGraphFile(IGraphBuilder *pGraph, WCHAR *wszPath);\n        HRESULT routeCrossbar(ICaptureGraphBuilder2 **ppBuild, IBaseFilter **pVidInFilter, int conType, GUID captureMode);\n\n        //don't touch\n        static bool comInit();\n        static bool comUnInit();\n\n        int  connection;\n        int  callbackSetCount;\n        bool bCallback;\n\n        GUID CAPTURE_MODE;\n\n        //Extra video subtypes\n        GUID MEDIASUBTYPE_Y800;\n        GUID MEDIASUBTYPE_Y8;\n        GUID MEDIASUBTYPE_GREY;\n\n        videoDevice * VDList[VI_MAX_CAMERAS];\n        GUID mediaSubtypes[VI_NUM_TYPES];\n        long formatTypes[VI_NUM_FORMATS];\n\n        static void __cdecl basicThread(void * objPtr);\n\n        static char deviceNames[VI_MAX_CAMERAS][255];\n\n};\n\n///////////////////////////  HANDY FUNCTIONS  /////////////////////////////\n\nstatic void MyFreeMediaType(AM_MEDIA_TYPE& mt){\n    if (mt.cbFormat != 0)\n    {\n        CoTaskMemFree((PVOID)mt.pbFormat);\n        mt.cbFormat = 0;\n        mt.pbFormat = NULL;\n    }\n    if (mt.pUnk != NULL)\n    {\n        // Unecessary because pUnk should not be used, but safest.\n        mt.pUnk->Release();\n        mt.pUnk = NULL;\n    }\n}\n\nstatic void MyDeleteMediaType(AM_MEDIA_TYPE *pmt)\n{\n    if (pmt != NULL)\n    {\n        MyFreeMediaType(*pmt);\n        CoTaskMemFree(pmt);\n    }\n}\n\n//////////////////////////////  CALLBACK  ////////////////////////////////\n\n//Callback class\nclass SampleGrabberCallback : public ISampleGrabberCB{\npublic:\n\n    //------------------------------------------------\n    SampleGrabberCallback(){\n        InitializeCriticalSection(&critSection);\n        freezeCheck = 0;\n\n\n        bufferSetup         = false;\n        newFrame            = false;\n        latestBufferLength  = 0;\n\n        hEvent = CreateEvent(NULL, true, false, NULL);\n    }\n\n\n    //------------------------------------------------\n    virtual ~SampleGrabberCallback(){\n        ptrBuffer = NULL;\n        DeleteCriticalSection(&critSection);\n        CloseHandle(hEvent);\n        if(bufferSetup){\n            delete[] pixels;\n        }\n    }\n\n\n    //------------------------------------------------\n    bool setupBuffer(int numBytesIn){\n        if(bufferSetup){\n            return false;\n        }else{\n            numBytes            = numBytesIn;\n            pixels              = new unsigned char[numBytes];\n            bufferSetup         = true;\n            newFrame            = false;\n            latestBufferLength  = 0;\n        }\n        return true;\n    }\n\n\n    //------------------------------------------------\n    STDMETHODIMP_(ULONG) AddRef() { return 1; }\n    STDMETHODIMP_(ULONG) Release() { return 2; }\n\n\n    //------------------------------------------------\n    STDMETHODIMP QueryInterface(REFIID, void **ppvObject){\n        *ppvObject = static_cast<ISampleGrabberCB*>(this);\n        return S_OK;\n    }\n\n\n    //This method is meant to have less overhead\n    //------------------------------------------------\n    STDMETHODIMP SampleCB(double , IMediaSample *pSample){\n        if(WaitForSingleObject(hEvent, 0) == WAIT_OBJECT_0) return S_OK;\n\n        HRESULT hr = pSample->GetPointer(&ptrBuffer);\n\n        if(hr == S_OK){\n            latestBufferLength = pSample->GetActualDataLength();\n              if(latestBufferLength == numBytes){\n                EnterCriticalSection(&critSection);\n                      memcpy(pixels, ptrBuffer, latestBufferLength);\n                    newFrame    = true;\n                    freezeCheck = 1;\n                LeaveCriticalSection(&critSection);\n                SetEvent(hEvent);\n            }else{\n                DebugPrintOut(\"ERROR: SampleCB() - buffer sizes do not match\\n\");\n            }\n        }\n\n        return S_OK;\n    }\n\n\n    //This method is meant to have more overhead\n    STDMETHODIMP BufferCB(double, BYTE *, long){\n        return E_NOTIMPL;\n    }\n\n    int freezeCheck;\n\n    int latestBufferLength;\n    int numBytes;\n    bool newFrame;\n    bool bufferSetup;\n    unsigned char * pixels;\n    unsigned char * ptrBuffer;\n    CRITICAL_SECTION critSection;\n    HANDLE hEvent;\n};\n\n\n//////////////////////////////  VIDEO DEVICE  ////////////////////////////////\n\n// ----------------------------------------------------------------------\n//    Should this class also be the callback?\n//\n// ----------------------------------------------------------------------\n\nvideoDevice::videoDevice(){\n\n     pCaptureGraph      = NULL;    // Capture graph builder object\n     pGraph             = NULL;    // Graph builder object\n     pControl           = NULL;    // Media control object\n     pVideoInputFilter  = NULL; // Video Capture filter\n     pGrabber           = NULL; // Grabs frame\n     pDestFilter        = NULL; // Null Renderer Filter\n     pGrabberF          = NULL; // Grabber Filter\n     pMediaEvent        = NULL;\n     streamConf         = NULL;\n     pAmMediaType       = NULL;\n\n     //This is our callback class that processes the frame.\n     sgCallback           = new SampleGrabberCallback();\n     sgCallback->newFrame = false;\n\n     //Default values for capture type\n     videoType          = MEDIASUBTYPE_RGB24;\n     connection         = PhysConn_Video_Composite;\n     storeConn          = 0;\n\n     videoSize          = 0;\n     width              = 0;\n     height             = 0;\n\n     tryWidth           = 640;\n     tryHeight          = 480;\n     tryVideoType = MEDIASUBTYPE_RGB24;\n     nFramesForReconnect= 10000;\n     nFramesRunning     = 0;\n     myID               = -1;\n\n     tryDiffSize        = true;\n     useCrossbar        = false;\n     readyToCapture     = false;\n     sizeSet            = false;\n     setupStarted       = false;\n     specificFormat     = false;\n     autoReconnect      = false;\n     requestedFrameTime = -1;\n\n     memset(wDeviceName, 0, sizeof(WCHAR) * 255);\n     memset(nDeviceName, 0, sizeof(char) * 255);\n\n}\n\n\n// ----------------------------------------------------------------------\n//    The only place we are doing new\n//\n// ----------------------------------------------------------------------\n\nvoid videoDevice::setSize(int w, int h){\n    if(sizeSet){\n        DebugPrintOut(\"SETUP: Error device size should not be set more than once\\n\");\n    }\n    else\n    {\n        width               = w;\n        height              = h;\n        videoSize           = w*h*3;\n        sizeSet             = true;\n        pixels              = new unsigned char[videoSize];\n        pBuffer             = new char[videoSize];\n\n        memset(pixels, 0 , videoSize);\n        sgCallback->setupBuffer(videoSize);\n\n    }\n}\n\n\n// ----------------------------------------------------------------------\n//    Borrowed from the SDK, use it to take apart the graph from\n//  the capture device downstream to the null renderer\n// ----------------------------------------------------------------------\n\n\n\u3053\u3053\u3067\u73fe\u308c\u308bIBaseFilter\u3068\u3044\u3046\u578b\u306f\u4f55\u8005\u306a\u306e\u304b\u8abf\u3079\u308b\u3002\n\nvoid videoDevice::NukeDownstream(IBaseFilter *pBF){\n    IPin *pP, *pTo;\n    ULONG u;\n    IEnumPins *pins = NULL;\n    PIN_INFO pininfo;\n    HRESULT hr = pBF->EnumPins(&pins);\n    pins->Reset();\n    while (hr == NOERROR)\n    {\n        hr = pins->Next(1, &pP, &u);\n        if (hr == S_OK && pP)\n        {\n            pP->ConnectedTo(&pTo);\n            if (pTo)\n            {\n                hr = pTo->QueryPinInfo(&pininfo);\n                if (hr == NOERROR)\n                {\n                    if (pininfo.dir == PINDIR_INPUT)\n                    {\n                        NukeDownstream(pininfo.pFilter);\n                        pGraph->Disconnect(pTo);\n                        pGraph->Disconnect(pP);\n                        pGraph->RemoveFilter(pininfo.pFilter);\n                    }\n                    pininfo.pFilter->Release();\n                    pininfo.pFilter = NULL;\n                }\n                pTo->Release();\n            }\n            pP->Release();\n        }\n    }\n    if (pins) pins->Release();\n}\n\n\n\u3053\u3053\u3067\u30d4\u30f3\u306b\u63a5\u7d9a\u3057\u3066\u3044\u308b\u306e\u3067\u306f\u306a\u3044\u304b\u3068\u601d\u3046\u3002\nIPin \u30a4\u30f3\u30bf\u30fc\u30d5\u30a7\u30a4\u30b9\n\u3053\u306e\u30a4\u30f3\u30bf\u30fc\u30d5\u30a7\u30a4\u30b9\u306f\u3059\u3079\u3066\u306e\u5165\u529b\u30d4\u30f3\u3001\u51fa\u529b\u30d4\u30f3\u306b\u3088\u3063\u3066\u516c\u958b\u3055\u308c\u308b\u3002\n\u30d5\u30a3\u30eb\u30bf \u30b0\u30e9\u30d5 \u30de\u30cd\u30fc\u30b8\u30e3\u306f\u3053\u306e\u30a4\u30f3\u30bf\u30fc\u30d5\u30a7\u30a4\u30b9\u3092\u4f7f\u3063\u3066\u30d4\u30f3\u3068\u63a5\u7d9a\u3057\u3001\u30d5\u30e9\u30c3\u30b7\u30e5\u51e6\u7406\u3092\u884c\u3046\u3002\u30a2\u30d7\u30ea\u30b1\u30fc\u30b7\u30e7\u30f3\u306f\u3053\u306e\u30a4\u30f3\u30bf\u30fc\u30d5\u30a7\u30a4\u30b9\u3092\u4f7f\u3063\u3066\u30d4\u30f3\u306e\u60c5\u5831\u3092\u554f\u3044\u5408\u308f\u305b\u308b\u3053\u3068\u304c\u3067\u304d\u308b\u3002\u30a2\u30d7\u30ea\u30b1\u30fc\u30b7\u30e7\u30f3\u306f\u3001Connect\u3001Disconnect\u3001BeginFlush\u3001EndFlush \u306a\u3069\u3001\u30d4\u30f3\u306e\u72b6\u614b\u3092\u5909\u66f4\u3059\u308b\u3088\u3046\u306a IPin \u30e1\u30bd\u30c3\u30c9\u3092\u6c7a\u3057\u3066\u547c\u3073\u51fa\u3055\u306a\u3044\u3053\u3068\u3002\u30d4\u30f3\u3092\u63a5\u7d9a\u3059\u308b\u306b\u306f\u3001\u30a2\u30d7\u30ea\u30b1\u30fc\u30b7\u30e7\u30f3\u306f IGraphBuilder \u5185\u306e\u30e1\u30bd\u30c3\u30c9\u3092\u4f7f\u308f\u306a\u3051\u308c\u3070\u306a\u3089\u306a\u3044\u3002\n\u30d5\u30a3\u30eb\u30bf\u958b\u767a\u8005 : CBasePin\u3001CBaseInputPin\u3001CBaseOutputPin \u306e\u5404\u30af\u30e9\u30b9\u306f\u3053\u306e\u30a4\u30f3\u30bf\u30fc\u30d5\u30a7\u30a4\u30b9\u3092\u5b9f\u88c5\u3059\u308b\u3002\u4ed6\u306e\u57fa\u5e95\u30af\u30e9\u30b9\u306f\u3053\u308c\u3089 3 \u3064\u306e\u30af\u30e9\u30b9\u304b\u3089\u6d3e\u751f\u3059\u308b\u3002\nIPin \u30a4\u30f3\u30bf\u30fc\u30d5\u30a7\u30a4\u30b9\u306f\u3001IUnknown \u304b\u3089\u7d99\u627f\u3059\u308b\u30e1\u30bd\u30c3\u30c9\u4ee5\u5916\u306b\u4ee5\u4e0b\u306e\u30e1\u30bd\u30c3\u30c9\u3082\u516c\u958b\u3059\u308b\u3002\n\n\n\n\u30e1\u30bd\u30c3\u30c9\n\u8aac\u660e\n\n\n\n\nConnect\n\u30d4\u30f3\u3092\u4ed6\u306e\u30d4\u30f3\u306b\u63a5\u7d9a\u3059\u308b\u3002\n\n\nReceiveConnection\n\u4ed6\u306e\u30d4\u30f3\u304b\u3089\u306e\u63a5\u7d9a\u3092\u8a31\u53ef\u3059\u308b\u3002\n\n\nDisconnect\n\u73fe\u5728\u306e\u30d4\u30f3\u63a5\u7d9a\u3092\u89e3\u9664\u3059\u308b\u3002\n\n\nConnectedTo\n\u3053\u306e\u30d4\u30f3\u306b\u63a5\u7d9a\u3057\u3066\u3044\u308b\u30d4\u30f3\u3092\u53d6\u5f97\u3059\u308b\u3002\n\n\nConnectionMediaType\n\u73fe\u5728\u306e\u30d4\u30f3\u63a5\u7d9a\u306e\u30e1\u30c7\u30a3\u30a2 \u30bf\u30a4\u30d7\u3092\u53d6\u5f97\u3059\u308b\u3002\n\n\nQueryPinInfo\n\u540d\u524d\u3001\u6240\u6709\u8005\u30d5\u30a3\u30eb\u30bf\u3001\u5411\u304d\u306a\u3069\u3001\u30d4\u30f3\u306b\u3064\u3044\u3066\u306e\u60c5\u5831\u3092\u53d6\u5f97\u3059\u308b\u3002\n\n\nQueryId\n\u30d4\u30f3\u8b58\u5225\u5b50\u3092\u53d6\u5f97\u3059\u308b\u3002\n\n\nQueryAccept\n\u6307\u5b9a\u3057\u305f\u30e1\u30c7\u30a3\u30a2 \u30bf\u30a4\u30d7\u3092\u30d4\u30f3\u304c\u53d7\u3051\u5165\u308c\u308b\u304b\u3069\u3046\u304b\u3092\u78ba\u8a8d\u3059\u308b\u3002\n\n\nEnumMediaTypes\n\u30d4\u30f3\u306e\u512a\u5148\u30e1\u30c7\u30a3\u30a2 \u30bf\u30a4\u30d7\u3092\u5217\u6319\u3059\u308b\u3002\n\n\nQueryInternalConnections\n(\u30d5\u30a3\u30eb\u30bf\u5185\u3067) \u5185\u90e8\u7684\u306b\u3053\u306e\u30d4\u30f3\u306b\u63a5\u7d9a\u3057\u3066\u3044\u308b\u30d4\u30f3\u3092\u53d6\u5f97\u3059\u308b\u3002\n\n\nEndOfStream\n\u8ffd\u52a0\u306e\u30c7\u30fc\u30bf\u304c\u306a\u3044\u3053\u3068\u3092\u30d4\u30f3\u306b\u901a\u77e5\u3059\u308b\u3002\n\n\nBeginFlush\n\u30d5\u30e9\u30c3\u30b7\u30e5\u51e6\u7406\u3092\u958b\u59cb\u3059\u308b\u3002\n\n\nEndFlush\n\u30d5\u30e9\u30c3\u30b7\u30e5\u51e6\u7406\u3092\u7d42\u4e86\u3059\u308b\u3002\n\n\nNewSegment\n\u3053\u306e\u547c\u3073\u51fa\u3057\u5f8c\u306b\u53d7\u3051\u53d6\u3063\u305f\u30e1\u30c7\u30a3\u30a2 \u30b5\u30f3\u30d7\u30eb\u304c\u3001\u30bb\u30b0\u30e1\u30f3\u30c8\u3068\u3057\u3066\u30b0\u30eb\u30fc\u30d7\u5316\u3055\u308c\u305f\u3053\u3068\u3092\u30d4\u30f3\u306b\u901a\u77e5\u3059\u308b\u3002\n\n\nQueryDirection\n\u30d4\u30f3\u306e\u5411\u304d (\u5165\u529b\u304b\u51fa\u529b\u304b) \u3092\u53d6\u5f97\u3059\u308b\u3002\n\n\n\n\n// ----------------------------------------------------------------------\n//    Also from SDK\n// ----------------------------------------------------------------------\n\nvoid videoDevice::destroyGraph(){\n    HRESULT hr = 0;\n     //int FuncRetval=0;\n     //int NumFilters=0;\n\n    int i = 0;\n    while (hr == NOERROR)\n    {\n        IEnumFilters * pEnum = 0;\n        ULONG cFetched;\n\n        // We must get the enumerator again every time because removing a filter from the graph\n        // invalidates the enumerator. We always get only the first filter from each enumerator.\n        hr = pGraph->EnumFilters(&pEnum);\n        if (FAILED(hr)) { DebugPrintOut(\"SETUP: pGraph->EnumFilters() failed.\\n\"); return; }\n\n        IBaseFilter * pFilter = NULL;\n        if (pEnum->Next(1, &pFilter, &cFetched) == S_OK)\n        {\n            FILTER_INFO FilterInfo;\n            memset(&FilterInfo, 0, sizeof(FilterInfo));\n            hr = pFilter->QueryFilterInfo(&FilterInfo);\n            FilterInfo.pGraph->Release();\n\n            int count = 0;\n            char buffer[255];\n            memset(buffer, 0, 255 * sizeof(char));\n\n            while( FilterInfo.achName[count] != 0x00 )\n            {\n                buffer[count] = (char)FilterInfo.achName[count];\n                count++;\n            }\n\n            DebugPrintOut(\"SETUP: removing filter %s...\\n\", buffer);\n            hr = pGraph->RemoveFilter(pFilter);\n            if (FAILED(hr)) { DebugPrintOut(\"SETUP: pGraph->RemoveFilter() failed.\\n\"); return; }\n            DebugPrintOut(\"SETUP: filter removed %s\\n\",buffer);\n\n            pFilter->Release();\n            pFilter = NULL;\n        }\n        else break;\n        pEnum->Release();\n        pEnum = NULL;\n        i++;\n    }\n\n return;\n}\n\n\n// ----------------------------------------------------------------------\n// Our deconstructor, attempts to tear down graph and release filters etc\n// Does checking to make sure it only is freeing if it needs to\n// Probably could be a lot cleaner! :)\n// ----------------------------------------------------------------------\n\nvideoDevice::~videoDevice(){\n\n    if(setupStarted){ DebugPrintOut(\"\\nSETUP: Disconnecting device %i\\n\", myID); }\n    else{\n        if(sgCallback){\n            sgCallback->Release();\n            delete sgCallback;\n        }\n        return;\n    }\n\n    HRESULT HR = NOERROR;\n\n    //Stop the callback and free it\n    if( (sgCallback) && (pGrabber) )\n    {\n        pGrabber->SetCallback(NULL, 1);\n        DebugPrintOut(\"SETUP: freeing Grabber Callback\\n\");\n        sgCallback->Release();\n\n        //delete our pixels\n        if(sizeSet){\n             delete[] pixels;\n             delete[] pBuffer;\n        }\n\n        delete sgCallback;\n    }\n\n    //Check to see if the graph is running, if so stop it.\n     if( (pControl) )\n    {\n        HR = pControl->Pause();\n        if (FAILED(HR)) DebugPrintOut(\"ERROR - Could not pause pControl\\n\");\n\n        HR = pControl->Stop();\n        if (FAILED(HR)) DebugPrintOut(\"ERROR - Could not stop pControl\\n\");\n    }\n\n    //Disconnect filters from capture device\n    if( (pVideoInputFilter) )NukeDownstream(pVideoInputFilter);\n\n    //Release and zero pointers to our filters etc\n    if( (pDestFilter) ){        DebugPrintOut(\"SETUP: freeing Renderer\\n\");\n                                (pDestFilter)->Release();\n                                (pDestFilter) = 0;\n    }\n    if( (pVideoInputFilter) ){  DebugPrintOut(\"SETUP: freeing Capture Source\\n\");\n                                (pVideoInputFilter)->Release();\n                                (pVideoInputFilter) = 0;\n    }\n    if( (pGrabberF) ){          DebugPrintOut(\"SETUP: freeing Grabber Filter\\n\");\n                                (pGrabberF)->Release();\n                                (pGrabberF) = 0;\n    }\n    if( (pGrabber) ){           DebugPrintOut(\"SETUP: freeing Grabber\\n\");\n                                (pGrabber)->Release();\n                                (pGrabber) = 0;\n    }\n    if( (pControl) ){           DebugPrintOut(\"SETUP: freeing Control\\n\");\n                                (pControl)->Release();\n                                (pControl) = 0;\n    }\n    if( (pMediaEvent) ){        DebugPrintOut(\"SETUP: freeing Media Event\\n\");\n                                (pMediaEvent)->Release();\n                                (pMediaEvent) = 0;\n    }\n    if( (streamConf) ){         DebugPrintOut(\"SETUP: freeing Stream\\n\");\n                                (streamConf)->Release();\n                                (streamConf) = 0;\n    }\n\n    if( (pAmMediaType) ){       DebugPrintOut(\"SETUP: freeing Media Type\\n\");\n                                MyDeleteMediaType(pAmMediaType);\n    }\n\n    if((pMediaEvent)){\n            DebugPrintOut(\"SETUP: freeing Media Event\\n\");\n            (pMediaEvent)->Release();\n            (pMediaEvent) = 0;\n    }\n\n    //Destroy the graph\n    if( (pGraph) )destroyGraph();\n\n    //Release and zero our capture graph and our main graph\n    if( (pCaptureGraph) ){      DebugPrintOut(\"SETUP: freeing Capture Graph\\n\");\n                                (pCaptureGraph)->Release();\n                                (pCaptureGraph) = 0;\n    }\n    if( (pGraph) ){             DebugPrintOut(\"SETUP: freeing Main Graph\\n\");\n                                (pGraph)->Release();\n                                (pGraph) = 0;\n    }\n\n    //delete our pointers\n    delete pDestFilter;\n    delete pVideoInputFilter;\n    delete pGrabberF;\n    delete pGrabber;\n    delete pControl;\n    delete streamConf;\n    delete pMediaEvent;\n    delete pCaptureGraph;\n    delete pGraph;\n\n    DebugPrintOut(\"SETUP: Device %i disconnected and freed\\n\\n\",myID);\n}\n\n\n//////////////////////////////  VIDEO INPUT  ////////////////////////////////\n////////////////////////////  PUBLIC METHODS  ///////////////////////////////\n\n\n// ----------------------------------------------------------------------\n// Constructor - creates instances of videoDevice and adds the various\n// media subtypes to check.\n// ----------------------------------------------------------------------\n\nvideoInput::videoInput(){\n    //start com\n    comInit();\n\n    devicesFound         = 0;\n    callbackSetCount     = 0;\n    bCallback            = true;\n\n    //setup a max no of device objects\n    for(int i=0; i<VI_MAX_CAMERAS; i++)  VDList[i] = new videoDevice();\n\n\n\u3053\u3053\u3067videoDevice\u306f\u65b0\u898f\u4f5c\u6210\u3057\u3066\u3044\u308b\u3088\u3046\u3060\u3002\n\n    DebugPrintOut(\"\\n***** VIDEOINPUT LIBRARY - %2.04f - TFW07 *****\\n\\n\",VI_VERSION);\n\n    //added for the pixelink firewire camera\n     //MEDIASUBTYPE_Y800 = (GUID)FOURCCMap(FCC('Y800'));\n     //MEDIASUBTYPE_Y8   = (GUID)FOURCCMap(FCC('Y8'));\n     //MEDIASUBTYPE_GREY = (GUID)FOURCCMap(FCC('GREY'));\n\n    //The video types we support\n    //in order of preference\n\n    mediaSubtypes[0]     = MEDIASUBTYPE_RGB24;\n    mediaSubtypes[1]     = MEDIASUBTYPE_RGB32;\n    mediaSubtypes[2]     = MEDIASUBTYPE_RGB555;\n    mediaSubtypes[3]     = MEDIASUBTYPE_RGB565;\n    mediaSubtypes[4]     = MEDIASUBTYPE_YUY2;\n    mediaSubtypes[5]     = MEDIASUBTYPE_YVYU;\n    mediaSubtypes[6]     = MEDIASUBTYPE_YUYV;\n    mediaSubtypes[7]     = MEDIASUBTYPE_IYUV;\n    mediaSubtypes[8]     = MEDIASUBTYPE_UYVY;\n    mediaSubtypes[9]     = MEDIASUBTYPE_YV12;\n    mediaSubtypes[10]    = MEDIASUBTYPE_YVU9;\n    mediaSubtypes[11]    = MEDIASUBTYPE_Y411;\n    mediaSubtypes[12]    = MEDIASUBTYPE_Y41P;\n    mediaSubtypes[13]    = MEDIASUBTYPE_Y211;\n    mediaSubtypes[14]    = MEDIASUBTYPE_AYUV;\n    mediaSubtypes[15]    = MEDIASUBTYPE_MJPG; // MGB\n\n    //non standard\n    mediaSubtypes[16]    = MEDIASUBTYPE_Y800;\n    mediaSubtypes[17]    = MEDIASUBTYPE_Y8;\n    mediaSubtypes[18]    = MEDIASUBTYPE_GREY;\n    mediaSubtypes[19]    = MEDIASUBTYPE_I420;\n\n    //The video formats we support\n    formatTypes[VI_NTSC_M]      = AnalogVideo_NTSC_M;\n    formatTypes[VI_NTSC_M_J]    = AnalogVideo_NTSC_M_J;\n    formatTypes[VI_NTSC_433]    = AnalogVideo_NTSC_433;\n\n    formatTypes[VI_PAL_B]       = AnalogVideo_PAL_B;\n    formatTypes[VI_PAL_D]       = AnalogVideo_PAL_D;\n    formatTypes[VI_PAL_G]       = AnalogVideo_PAL_G;\n    formatTypes[VI_PAL_H]       = AnalogVideo_PAL_H;\n    formatTypes[VI_PAL_I]       = AnalogVideo_PAL_I;\n    formatTypes[VI_PAL_M]       = AnalogVideo_PAL_M;\n    formatTypes[VI_PAL_N]       = AnalogVideo_PAL_N;\n    formatTypes[VI_PAL_NC]      = AnalogVideo_PAL_N_COMBO;\n\n    formatTypes[VI_SECAM_B]     = AnalogVideo_SECAM_B;\n    formatTypes[VI_SECAM_D]     = AnalogVideo_SECAM_D;\n    formatTypes[VI_SECAM_G]     = AnalogVideo_SECAM_G;\n    formatTypes[VI_SECAM_H]     = AnalogVideo_SECAM_H;\n    formatTypes[VI_SECAM_K]     = AnalogVideo_SECAM_K;\n    formatTypes[VI_SECAM_K1]    = AnalogVideo_SECAM_K1;\n    formatTypes[VI_SECAM_L]     = AnalogVideo_SECAM_L;\n\n}\n\n\n// ----------------------------------------------------------------------\n// static - set whether messages get printed to console or not\n//\n// ----------------------------------------------------------------------\n\nvoid videoInput::setVerbose(bool _verbose){\n#ifdef _DEBUG\n    gs_verbose = _verbose;\n#else\n    (void)_verbose; // Suppress 'unreferenced parameter' warning\n#endif\n}\n\n// ----------------------------------------------------------------------\n// change to use callback or regular capture\n// callback tells you when a new frame has arrived\n// but non-callback won't - but is single threaded\n// ----------------------------------------------------------------------\nvoid videoInput::setUseCallback(bool useCallback){\n    if(callbackSetCount == 0){\n        bCallback = useCallback;\n        callbackSetCount = 1;\n    }else{\n        DebugPrintOut(\"ERROR: setUseCallback can only be called before setup\\n\");\n    }\n}\n\n// ----------------------------------------------------------------------\n// Set the requested framerate - no guarantee you will get this\n//\n// ----------------------------------------------------------------------\n\nvoid videoInput::setIdealFramerate(int deviceNumber, int idealFramerate){\n    if(deviceNumber >= VI_MAX_CAMERAS || VDList[deviceNumber]->readyToCapture) return;\n\n    if( idealFramerate > 0 ){\n        VDList[deviceNumber]->requestedFrameTime = (unsigned long)(10000000 / idealFramerate);\n    }\n}\n\n\n// ----------------------------------------------------------------------\n// Set the requested framerate - no guarantee you will get this\n//\n// ----------------------------------------------------------------------\n\nvoid videoInput::setAutoReconnectOnFreeze(int deviceNumber, bool doReconnect, int numMissedFramesBeforeReconnect){\n    if(deviceNumber >= VI_MAX_CAMERAS) return;\n\n    VDList[deviceNumber]->autoReconnect            = doReconnect;\n    VDList[deviceNumber]->nFramesForReconnect    = numMissedFramesBeforeReconnect;\n\n}\n\n\n// ----------------------------------------------------------------------\n// Setup a device with the default settings\n//\n// ----------------------------------------------------------------------\n\nbool videoInput::setupDevice(int deviceNumber){\n    if(deviceNumber >= VI_MAX_CAMERAS || VDList[deviceNumber]->readyToCapture) return false;\n\n    if(setup(deviceNumber))return true;\n    return false;\n}\n\n\n// ----------------------------------------------------------------------\n// Setup a device with the default size but specify input type\n//\n// ----------------------------------------------------------------------\n\nbool videoInput::setupDevice(int deviceNumber, int _connection){\n    if(deviceNumber >= VI_MAX_CAMERAS || VDList[deviceNumber]->readyToCapture) return false;\n\n    setPhyCon(deviceNumber, _connection);\n    if(setup(deviceNumber))return true;\n    return false;\n}\n\n\n// ----------------------------------------------------------------------\n// Setup a device with the default connection but specify size\n//\n// ----------------------------------------------------------------------\n\nbool videoInput::setupDevice(int deviceNumber, int w, int h){\n    if(deviceNumber >= VI_MAX_CAMERAS || VDList[deviceNumber]->readyToCapture) return false;\n\n    setAttemptCaptureSize(deviceNumber,w,h);\n    if(setup(deviceNumber))return true;\n    return false;\n}\n\n// ----------------------------------------------------------------------\n// Setup a device with the default connection but specify size and image format\n//\n// Note:\n// Need a new name for this since signature clashes with \",int connection)\"\n// ----------------------------------------------------------------------\n\nbool videoInput::setupDeviceFourcc(int deviceNumber, int w, int h,int fourcc){\n    if(deviceNumber >= VI_MAX_CAMERAS || VDList[deviceNumber]->readyToCapture) return false;\n\n    if ( fourcc != -1 ) {\n        GUID *mediaType = getMediaSubtypeFromFourcc(fourcc);\n        if ( mediaType ) {\n            setAttemptCaptureSize(deviceNumber,w,h,*mediaType);\n        }\n    } else {\n        setAttemptCaptureSize(deviceNumber,w,h);\n    }\n    if(setup(deviceNumber))return true;\n    return false;\n}\n\n\n// ----------------------------------------------------------------------\n// Setup a device with specific size and connection\n//\n// ----------------------------------------------------------------------\n\nbool videoInput::setupDevice(int deviceNumber, int w, int h, int _connection){\n    if(deviceNumber >= VI_MAX_CAMERAS || VDList[deviceNumber]->readyToCapture) return false;\n\n    setAttemptCaptureSize(deviceNumber,w,h);\n    setPhyCon(deviceNumber, _connection);\n    if(setup(deviceNumber))return true;\n    return false;\n}\n\n\n// ----------------------------------------------------------------------\n// Setup the default video format of the device\n// Must be called after setup!\n// See #define formats in header file (eg VI_NTSC_M )\n//\n// ----------------------------------------------------------------------\n\nbool videoInput::setFormat(int deviceNumber, int format){\n    if(deviceNumber >= VI_MAX_CAMERAS || !VDList[deviceNumber]->readyToCapture) return false;\n\n    bool returnVal = false;\n\n    if(format >= 0 && format < VI_NUM_FORMATS){\n        VDList[deviceNumber]->formatType = formatTypes[format];\n        VDList[deviceNumber]->specificFormat = true;\n\n        if(VDList[deviceNumber]->specificFormat){\n\n            HRESULT hr = getDevice(&VDList[deviceNumber]->pVideoInputFilter, deviceNumber, VDList[deviceNumber]->wDeviceName, VDList[deviceNumber]->nDeviceName);\n            if(hr != S_OK){\n                return false;\n            }\n\n            IAMAnalogVideoDecoder *pVideoDec = NULL;\n               hr = VDList[deviceNumber]->pCaptureGraph->FindInterface(NULL, &MEDIATYPE_Video, VDList[deviceNumber]->pVideoInputFilter, IID_IAMAnalogVideoDecoder, (void **)&pVideoDec);\n\n\n            //in case the settings window some how freed them first\n            if(VDList[deviceNumber]->pVideoInputFilter)VDList[deviceNumber]->pVideoInputFilter->Release();\n            if(VDList[deviceNumber]->pVideoInputFilter)VDList[deviceNumber]->pVideoInputFilter = NULL;\n\n            if(FAILED(hr)){\n                DebugPrintOut(\"SETUP: couldn't set requested format\\n\");\n            }else{\n                long lValue = 0;\n                hr = pVideoDec->get_AvailableTVFormats(&lValue);\n                if( SUCCEEDED(hr) && (lValue & VDList[deviceNumber]->formatType) )\n                   {\n                       hr = pVideoDec->put_TVFormat(VDList[deviceNumber]->formatType);\n                    if( FAILED(hr) ){\n                        DebugPrintOut(\"SETUP: couldn't set requested format\\n\");\n                    }else{\n                        returnVal = true;\n                    }\n                   }\n\n                pVideoDec->Release();\n                pVideoDec = NULL;\n            }\n        }\n    }\n\n    return returnVal;\n}\n\n// ----------------------------------------------------------------------\n// Our static function for returning device names - thanks Peter!\n// Must call listDevices first.\n//\n// ----------------------------------------------------------------------\nchar videoInput::deviceNames[VI_MAX_CAMERAS][255]={{0}};\n\nchar * videoInput::getDeviceName(int deviceID){\n    if( deviceID >= VI_MAX_CAMERAS ){\n        return NULL;\n    }\n    return deviceNames[deviceID];\n}\n\n\n// ----------------------------------------------------------------------\n// Our static function for finding num devices available etc\n//\n// ----------------------------------------------------------------------\n\nint videoInput::listDevices(bool silent){\n\n    //COM Library Intialization\n    comInit();\n\n    if(!silent) DebugPrintOut(\"\\nVIDEOINPUT SPY MODE!\\n\\n\");\n\n\n    ICreateDevEnum *pDevEnum = NULL;\n    IEnumMoniker *pEnum = NULL;\n    int deviceCounter = 0;\n\n    HRESULT hr = CoCreateInstance(CLSID_SystemDeviceEnum, NULL,\n        CLSCTX_INPROC_SERVER, IID_ICreateDevEnum,\n        reinterpret_cast<void**>(&pDevEnum));\n\n\n    if (SUCCEEDED(hr))\n    {\n        // Create an enumerator for the video capture category.\n        hr = pDevEnum->CreateClassEnumerator(\n            CLSID_VideoInputDeviceCategory,\n            &pEnum, 0);\n\n       if(hr == S_OK){\n\n            if(!silent) DebugPrintOut(\"SETUP: Looking For Capture Devices\\n\");\n            IMoniker *pMoniker = NULL;\n\n            while (pEnum->Next(1, &pMoniker, NULL) == S_OK){\n\n                IPropertyBag *pPropBag;\n                hr = pMoniker->BindToStorage(0, 0, IID_IPropertyBag,\n                    (void**)(&pPropBag));\n\n                if (FAILED(hr)){\n                    pMoniker->Release();\n                    continue;  // Skip this one, maybe the next one will work.\n                }\n\n\n                 // Find the description or friendly name.\n                VARIANT varName;\n                VariantInit(&varName);\n                hr = pPropBag->Read(L\"Description\", &varName, 0);\n\n                if (FAILED(hr)) hr = pPropBag->Read(L\"FriendlyName\", &varName, 0);\n\n                if (SUCCEEDED(hr)){\n\n                    hr = pPropBag->Read(L\"FriendlyName\", &varName, 0);\n\n                    int count = 0;\n                    int maxLen = sizeof(deviceNames[0])/sizeof(deviceNames[0][0]) - 2;\n                    while( varName.bstrVal[count] != 0x00 && count < maxLen) {\n                        deviceNames[deviceCounter][count] = (char)varName.bstrVal[count];\n                        count++;\n                    }\n                    deviceNames[deviceCounter][count] = 0;\n\n                    if(!silent) DebugPrintOut(\"SETUP: %i) %s\\n\",deviceCounter, deviceNames[deviceCounter]);\n                }\n\n                pPropBag->Release();\n                pPropBag = NULL;\n\n                pMoniker->Release();\n                pMoniker = NULL;\n\n                deviceCounter++;\n            }\n\n            pDevEnum->Release();\n            pDevEnum = NULL;\n\n            pEnum->Release();\n            pEnum = NULL;\n        }\n\n         if(!silent) DebugPrintOut(\"SETUP: %i Device(s) found\\n\\n\", deviceCounter);\n    }\n\n    comUnInit();\n\n    return deviceCounter;\n}\n\n\n\u5229\u7528\u53ef\u80fd\u306a\u30c7\u30d0\u30a4\u30b9\u3092\u78ba\u8a8d\u3057\u3066\u3044\u308b\u3002\n\u305d\u3082\u305d\u3082\u3001\u30c7\u30d0\u30a4\u30b9\u306b\u63b2\u8f09\u3055\u308c\u306a\u3051\u308c\u3070\u306a\u3089\u306a\u3044\u3088\u3046\u3060\u3002\n\n\n// ----------------------------------------------------------------------\n//\n//\n// ----------------------------------------------------------------------\n\nint videoInput::getWidth(int id) const\n{\n    if(isDeviceSetup(id))\n    {\n        return VDList[id] ->width;\n    }\n\n    return 0;\n\n}\n\n\n// ----------------------------------------------------------------------\n//\n//\n// ----------------------------------------------------------------------\n\nint videoInput::getHeight(int id) const\n{\n    if(isDeviceSetup(id))\n    {\n        return VDList[id] ->height;\n    }\n\n    return 0;\n\n}\n\n// ----------------------------------------------------------------------\n//\n//\n// ----------------------------------------------------------------------\nint videoInput::getFourcc(int id) const\n{\n    if(isDeviceSetup(id))\n    {\n        return getFourccFromMediaSubtype(VDList[id]->videoType);\n    }\n\n    return 0;\n\n}\n\ndouble videoInput::getFPS(int id) const\n{\n    if(isDeviceSetup(id))\n    {\n        double frameTime= VDList[id]->requestedFrameTime;\n        if (frameTime>0) {\n            return (10000000.0 / frameTime);\n        }\n    }\n\n    return 0;\n\n}\n\n\n// ----------------------------------------------------------------------\n//\n//\n// ----------------------------------------------------------------------\n\nint videoInput::getSize(int id) const\n{\n    if(isDeviceSetup(id))\n    {\n        return VDList[id] ->videoSize;\n    }\n\n    return 0;\n\n}\n\n\n// ----------------------------------------------------------------------\n// Uses a supplied buffer\n// ----------------------------------------------------------------------\n\nbool videoInput::getPixels(int id, unsigned char * dstBuffer, bool flipRedAndBlue, bool flipImage){\n\n    bool success = false;\n\n    if(isDeviceSetup(id)){\n        if(bCallback){\n            //callback capture\n\n            DWORD result = WaitForSingleObject(VDList[id]->sgCallback->hEvent, 1000);\n            if( result != WAIT_OBJECT_0) return false;\n\n            //double paranoia - mutexing with both event and critical section\n            EnterCriticalSection(&VDList[id]->sgCallback->critSection);\n\n                unsigned char * src = VDList[id]->sgCallback->pixels;\n                unsigned char * dst = dstBuffer;\n                int height             = VDList[id]->height;\n                int width              = VDList[id]->width;\n\n                processPixels(src, dst, width, height, flipRedAndBlue, flipImage);\n                VDList[id]->sgCallback->newFrame = false;\n\n            LeaveCriticalSection(&VDList[id]->sgCallback->critSection);\n\n            ResetEvent(VDList[id]->sgCallback->hEvent);\n\n            success = true;\n\n        }\n        else{\n            //regular capture method\n            long bufferSize = VDList[id]->videoSize;\n            HRESULT hr = VDList[id]->pGrabber->GetCurrentBuffer(&bufferSize, (long *)VDList[id]->pBuffer);\n            if(hr==S_OK){\n                int numBytes = VDList[id]->videoSize;\n                if (numBytes == bufferSize){\n\n                    unsigned char * src = (unsigned char * )VDList[id]->pBuffer;\n                    unsigned char * dst = dstBuffer;\n                    int height             = VDList[id]->height;\n                    int width             = VDList[id]->width;\n\n                    processPixels(src, dst, width, height, flipRedAndBlue, flipImage);\n                    success = true;\n                }else{\n                    DebugPrintOut(\"ERROR: GetPixels() - bufferSizes do not match!\\n\");\n                }\n            }else{\n                DebugPrintOut(\"ERROR: GetPixels() - Unable to grab frame for device %i\\n\", id);\n            }\n        }\n    }\n\n    return success;\n}\n\n\n// ----------------------------------------------------------------------\n// Returns a buffer\n// ----------------------------------------------------------------------\nunsigned char * videoInput::getPixels(int id, bool flipRedAndBlue, bool flipImage){\n\n    if(isDeviceSetup(id)){\n           getPixels(id, VDList[id]->pixels, flipRedAndBlue, flipImage);\n    }\n\n    return VDList[id]->pixels;\n}\n\n\n\n// ----------------------------------------------------------------------\n//\n//\n// ----------------------------------------------------------------------\nbool videoInput::isFrameNew(int id){\n    if(!isDeviceSetup(id)) return false;\n    if(!bCallback)return true;\n\n    bool result = false;\n    bool freeze = false;\n\n    //again super paranoia!\n    EnterCriticalSection(&VDList[id]->sgCallback->critSection);\n        result = VDList[id]->sgCallback->newFrame;\n\n        //we need to give it some time at the begining to start up so lets check after 400 frames\n        if(VDList[id]->nFramesRunning > 400 && VDList[id]->sgCallback->freezeCheck > VDList[id]->nFramesForReconnect ){\n            freeze = true;\n        }\n\n        //we increment the freezeCheck var here - the callback resets it to 1\n        //so as long as the callback is running this var should never get too high.\n        //if the callback is not running then this number will get high and trigger the freeze action below\n        VDList[id]->sgCallback->freezeCheck++;\n    LeaveCriticalSection(&VDList[id]->sgCallback->critSection);\n\n    VDList[id]->nFramesRunning++;\n\n    if(freeze && VDList[id]->autoReconnect){\n        DebugPrintOut(\"ERROR: Device seems frozen - attempting to reconnect\\n\");\n        if( !restartDevice(VDList[id]->myID) ){\n            DebugPrintOut(\"ERROR: Unable to reconnect to device\\n\");\n        }else{\n            DebugPrintOut(\"SUCCESS: Able to reconnect to device\\n\");\n        }\n    }\n\n    return result;\n}\n\n\n// ----------------------------------------------------------------------\n//\n//\n// ----------------------------------------------------------------------\n\nbool videoInput::isDeviceSetup(int id) const\n{\n    if(id>=0 && id<devicesFound && VDList[id]->readyToCapture)return true;\n    else return false;\n}\n\n\n// ----------------------------------------------------------------------\n// Gives us a little pop up window to adjust settings\n// We do this in a seperate thread now!\n// ----------------------------------------------------------------------\n\n\nvoid __cdecl videoInput::basicThread(void * objPtr){\n\n    //get a reference to the video device\n    //not a copy as we need to free the filter\n    videoDevice * vd = *( (videoDevice **)(objPtr) );\n    ShowFilterPropertyPages(vd->pVideoInputFilter);\n\n\n\n    //now we free the filter and make sure it set to NULL\n    if(vd->pVideoInputFilter)vd->pVideoInputFilter->Release();\n    if(vd->pVideoInputFilter)vd->pVideoInputFilter = NULL;\n\n    return;\n}\n\nvoid videoInput::showSettingsWindow(int id){\n\n    if(isDeviceSetup(id)){\n        //HANDLE myTempThread;\n\n        //we reconnect to the device as we have freed our reference to it\n        //why have we freed our reference? because there seemed to be an issue\n        //with some mpeg devices if we didn't\n        HRESULT hr = getDevice(&VDList[id]->pVideoInputFilter, id, VDList[id]->wDeviceName, VDList[id]->nDeviceName);\n        if(hr == S_OK){\n            //myTempThread = (HANDLE)\n                _beginthread(basicThread, 0, (void *)&VDList[id]);\n        }\n    }\n}\n\n\n// Set a video signal setting using IAMVideoProcAmp\nbool videoInput::getVideoSettingFilter(int deviceID, long Property, long &min, long &max, long &SteppingDelta, long &currentValue, long &flags, long &defaultValue){\n    if( !isDeviceSetup(deviceID) )return false;\n\n    HRESULT hr;\n    //bool isSuccessful = false;\n\n    videoDevice * VD = VDList[deviceID];\n\n    hr = getDevice(&VD->pVideoInputFilter, deviceID, VD->wDeviceName, VD->nDeviceName);\n    if (FAILED(hr)){\n        DebugPrintOut(\"setVideoSetting - getDevice Error\\n\");\n        return false;\n    }\n\n    IAMVideoProcAmp *pAMVideoProcAmp = NULL;\n\n    hr = VD->pVideoInputFilter->QueryInterface(IID_IAMVideoProcAmp, (void**)&pAMVideoProcAmp);\n    if(FAILED(hr)){\n        DebugPrintOut(\"setVideoSetting - QueryInterface Error\\n\");\n        if(VD->pVideoInputFilter)VD->pVideoInputFilter->Release();\n        if(VD->pVideoInputFilter)VD->pVideoInputFilter = NULL;\n        return false;\n    }\n\n    char propStr[16];\n    getVideoPropertyAsString(Property,propStr);\n\n    DebugPrintOut(\"Setting video setting %s.\\n\", propStr);\n\n    pAMVideoProcAmp->GetRange(Property, &min, &max, &SteppingDelta, &defaultValue, &flags);\n    DebugPrintOut(\"Range for video setting %s: Min:%ld Max:%ld SteppingDelta:%ld Default:%ld Flags:%ld\\n\", propStr, min, max, SteppingDelta, defaultValue, flags);\n    pAMVideoProcAmp->Get(Property, &currentValue, &flags);\n\n    if(pAMVideoProcAmp)pAMVideoProcAmp->Release();\n    if(VD->pVideoInputFilter)VD->pVideoInputFilter->Release();\n    if(VD->pVideoInputFilter)VD->pVideoInputFilter = NULL;\n\n    return true;\n\n}\n\n\n// Set a video signal setting using IAMVideoProcAmp\nbool videoInput::setVideoSettingFilterPct(int deviceID, long Property, float pctValue, long Flags){\n    if( !isDeviceSetup(deviceID) )return false;\n\n    long min, max, currentValue, flags, defaultValue, stepAmnt;\n\n    if( !getVideoSettingFilter(deviceID, Property, min, max, stepAmnt, currentValue, flags, defaultValue) )return false;\n\n    if(pctValue > 1.0)pctValue = 1.0;\n    else if(pctValue < 0)pctValue = 0.0;\n\n    float range = (float)max - (float)min;\n    if(range <= 0)return false;\n    if(stepAmnt == 0) return false;\n\n    long value     = (long)( (float)min + range * pctValue );\n    long rasterValue = value;\n\n    //if the range is the stepAmnt then it is just a switch\n    //so we either set the value to low or high\n    if( range == stepAmnt ){\n        if( pctValue < 0.5)rasterValue = min;\n        else rasterValue = max;\n    }else{\n        //we need to rasterize the value to the stepping amnt\n        long mod         = value % stepAmnt;\n        float halfStep     = (float)stepAmnt * 0.5f;\n        if( mod < halfStep ) rasterValue -= mod;\n        else rasterValue += stepAmnt - mod;\n        DebugPrintOut(\"RASTER - pctValue is %f - value is %li - step is %li - mod is %li - rasterValue is %li\\n\", pctValue, value, stepAmnt, mod, rasterValue);\n    }\n\n    return setVideoSettingFilter(deviceID, Property, rasterValue, Flags, false);\n}\n\n\n// Set a video signal setting using IAMVideoProcAmp\nbool videoInput::setVideoSettingFilter(int deviceID, long Property, long lValue, long Flags, bool useDefaultValue){\n    if( !isDeviceSetup(deviceID) )return false;\n\n    HRESULT hr;\n    //bool isSuccessful = false;\n\n    char propStr[16];\n    getVideoPropertyAsString(Property,propStr);\n\n    videoDevice * VD = VDList[deviceID];\n\n    hr = getDevice(&VD->pVideoInputFilter, deviceID, VD->wDeviceName, VD->nDeviceName);\n    if (FAILED(hr)){\n        DebugPrintOut(\"setVideoSetting - getDevice Error\\n\");\n        return false;\n    }\n\n    IAMVideoProcAmp *pAMVideoProcAmp = NULL;\n\n    hr = VD->pVideoInputFilter->QueryInterface(IID_IAMVideoProcAmp, (void**)&pAMVideoProcAmp);\n    if(FAILED(hr)){\n        DebugPrintOut(\"setVideoSetting - QueryInterface Error\\n\");\n        if(VD->pVideoInputFilter)VD->pVideoInputFilter->Release();\n        if(VD->pVideoInputFilter)VD->pVideoInputFilter = NULL;\n        return false;\n    }\n\n    DebugPrintOut(\"Setting video setting %s.\\n\", propStr);\n    long CurrVal, Min, Max, SteppingDelta, Default, CapsFlags, AvailableCapsFlags = 0;\n\n\n    pAMVideoProcAmp->GetRange(Property, &Min, &Max, &SteppingDelta, &Default, &AvailableCapsFlags);\n    DebugPrintOut(\"Range for video setting %s: Min:%ld Max:%ld SteppingDelta:%ld Default:%ld Flags:%ld\\n\", propStr, Min, Max, SteppingDelta, Default, AvailableCapsFlags);\n    pAMVideoProcAmp->Get(Property, &CurrVal, &CapsFlags);\n\n    DebugPrintOut(\"Current value: %ld Flags %ld (%s)\\n\", CurrVal, CapsFlags, (CapsFlags == 1 ? \"Auto\" : (CapsFlags == 2 ? \"Manual\" : \"Unknown\")));\n\n    if (useDefaultValue) {\n        pAMVideoProcAmp->Set(Property, Default, VideoProcAmp_Flags_Auto);\n    }\n    else{\n        // Perhaps add a check that lValue and Flags are within the range aquired from GetRange above\n        pAMVideoProcAmp->Set(Property, lValue, Flags);\n    }\n\n    if(pAMVideoProcAmp)pAMVideoProcAmp->Release();\n    if(VD->pVideoInputFilter)VD->pVideoInputFilter->Release();\n    if(VD->pVideoInputFilter)VD->pVideoInputFilter = NULL;\n\n    return true;\n\n}\n\n\nbool videoInput::setVideoSettingCameraPct(int deviceID, long Property, float pctValue, long Flags){\n    if( !isDeviceSetup(deviceID) )return false;\n\n    long min, max, currentValue, flags, defaultValue, stepAmnt;\n\n    if( !getVideoSettingCamera(deviceID, Property, min, max, stepAmnt, currentValue, flags, defaultValue) )return false;\n\n    if(pctValue > 1.0)pctValue = 1.0;\n    else if(pctValue < 0)pctValue = 0.0;\n\n    float range = (float)max - (float)min;\n    if(range <= 0)return false;\n    if(stepAmnt == 0) return false;\n\n    long value     = (long)( (float)min + range * pctValue );\n    long rasterValue = value;\n\n    //if the range is the stepAmnt then it is just a switch\n    //so we either set the value to low or high\n    if( range == stepAmnt ){\n        if( pctValue < 0.5)rasterValue = min;\n        else rasterValue = max;\n    }else{\n        //we need to rasterize the value to the stepping amnt\n        long mod         = value % stepAmnt;\n        float halfStep     = (float)stepAmnt * 0.5f;\n        if( mod < halfStep ) rasterValue -= mod;\n        else rasterValue += stepAmnt - mod;\n        DebugPrintOut(\"RASTER - pctValue is %f - value is %li - step is %li - mod is %li - rasterValue is %li\\n\", pctValue, value, stepAmnt, mod, rasterValue);\n    }\n\n    return setVideoSettingCamera(deviceID, Property, rasterValue, Flags, false);\n}\n\n\nbool videoInput::setVideoSettingCamera(int deviceID, long Property, long lValue, long Flags, bool useDefaultValue){\n    IAMCameraControl *pIAMCameraControl;\n    if(isDeviceSetup(deviceID))\n    {\n        HRESULT hr;\n        hr = getDevice(&VDList[deviceID]->pVideoInputFilter, deviceID, VDList[deviceID]->wDeviceName, VDList[deviceID]->nDeviceName);\n\n        char propStr[16];\n        getCameraPropertyAsString(Property,propStr);\n\n        DebugPrintOut(\"Setting video setting %s.\\n\", propStr);\n        hr = VDList[deviceID]->pVideoInputFilter->QueryInterface(IID_IAMCameraControl, (void**)&pIAMCameraControl);\n        if (FAILED(hr)) {\n            DebugPrintOut(\"Error\\n\");\n            if(VDList[deviceID]->pVideoInputFilter)VDList[deviceID]->pVideoInputFilter->Release();\n            if(VDList[deviceID]->pVideoInputFilter)VDList[deviceID]->pVideoInputFilter = NULL;\n            return false;\n        }\n        else\n        {\n            long CurrVal, Min, Max, SteppingDelta, Default, CapsFlags, AvailableCapsFlags;\n            pIAMCameraControl->GetRange(Property, &Min, &Max, &SteppingDelta, &Default, &AvailableCapsFlags);\n            DebugPrintOut(\"Range for video setting %s: Min:%ld Max:%ld SteppingDelta:%ld Default:%ld Flags:%ld\\n\", propStr, Min, Max, SteppingDelta, Default, AvailableCapsFlags);\n            pIAMCameraControl->Get(Property, &CurrVal, &CapsFlags);\n            DebugPrintOut(\"Current value: %ld Flags %ld (%s)\\n\", CurrVal, CapsFlags, (CapsFlags == 1 ? \"Auto\" : (CapsFlags == 2 ? \"Manual\" : \"Unknown\")));\n            if (useDefaultValue) {\n                pIAMCameraControl->Set(Property, Default, CameraControl_Flags_Auto);\n            }\n            else\n            {\n                // Perhaps add a check that lValue and Flags are within the range aquired from GetRange above\n                pIAMCameraControl->Set(Property, lValue, Flags);\n            }\n            pIAMCameraControl->Release();\n            if(VDList[deviceID]->pVideoInputFilter)VDList[deviceID]->pVideoInputFilter->Release();\n            if(VDList[deviceID]->pVideoInputFilter)VDList[deviceID]->pVideoInputFilter = NULL;\n            return true;\n        }\n    }\n    return false;\n}\n\n\n\nbool videoInput::getVideoSettingCamera(int deviceID, long Property, long &min, long &max, long &SteppingDelta, long &currentValue, long &flags, long &defaultValue){\n    if( !isDeviceSetup(deviceID) )return false;\n\n    HRESULT hr;\n    //bool isSuccessful = false;\n\n    videoDevice * VD = VDList[deviceID];\n\n    hr = getDevice(&VD->pVideoInputFilter, deviceID, VD->wDeviceName, VD->nDeviceName);\n    if (FAILED(hr)){\n        DebugPrintOut(\"setVideoSetting - getDevice Error\\n\");\n        return false;\n    }\n\n    IAMCameraControl *pIAMCameraControl = NULL;\n\n    hr = VD->pVideoInputFilter->QueryInterface(IID_IAMCameraControl, (void**)&pIAMCameraControl);\n    if(FAILED(hr)){\n        DebugPrintOut(\"setVideoSetting - QueryInterface Error\\n\");\n        if(VD->pVideoInputFilter)VD->pVideoInputFilter->Release();\n        if(VD->pVideoInputFilter)VD->pVideoInputFilter = NULL;\n        return false;\n    }\n\n    char propStr[16];\n    getCameraPropertyAsString(Property,propStr);\n    DebugPrintOut(\"Setting video setting %s.\\n\", propStr);\n\n    pIAMCameraControl->GetRange(Property, &min, &max, &SteppingDelta, &defaultValue, &flags);\n    DebugPrintOut(\"Range for video setting %s: Min:%ld Max:%ld SteppingDelta:%ld Default:%ld Flags:%ld\\n\", propStr, min, max, SteppingDelta, defaultValue, flags);\n    pIAMCameraControl->Get(Property, &currentValue, &flags);\n\n    if(pIAMCameraControl)pIAMCameraControl->Release();\n    if(VD->pVideoInputFilter)VD->pVideoInputFilter->Release();\n    if(VD->pVideoInputFilter)VD->pVideoInputFilter = NULL;\n\n    return true;\n\n}\n\n\n// ----------------------------------------------------------------------\n// Shutsdown the device, deletes the object and creates a new object\n// so it is ready to be setup again\n// ----------------------------------------------------------------------\n\nvoid videoInput::stopDevice(int id){\n    if(id < VI_MAX_CAMERAS)\n    {\n        delete VDList[id];\n        VDList[id] = new videoDevice();\n    }\n\n}\n\n// ----------------------------------------------------------------------\n// Restarts the device with the same settings it was using\n//\n// ----------------------------------------------------------------------\n\nbool videoInput::restartDevice(int id){\n    if(isDeviceSetup(id))\n    {\n        int conn         = VDList[id]->storeConn;\n        int tmpW           = VDList[id]->width;\n        int tmpH           = VDList[id]->height;\n\n        bool bFormat    = VDList[id]->specificFormat;\n        long format     = VDList[id]->formatType;\n\n        int nReconnect    = VDList[id]->nFramesForReconnect;\n        bool bReconnect = VDList[id]->autoReconnect;\n\n        unsigned long avgFrameTime = VDList[id]->requestedFrameTime;\n\n        stopDevice(id);\n\n        //set our fps if needed\n        if( avgFrameTime != (unsigned long)-1){\n            VDList[id]->requestedFrameTime = avgFrameTime;\n        }\n\n        if( setupDevice(id, tmpW, tmpH, conn) ){\n            //reapply the format - ntsc / pal etc\n            if( bFormat ){\n                setFormat(id, format);\n            }\n            if( bReconnect ){\n                setAutoReconnectOnFreeze(id, true, nReconnect);\n            }\n            return true;\n        }\n    }\n    return false;\n}\n\n// ----------------------------------------------------------------------\n// Shuts down all devices, deletes objects and unitializes com if needed\n//\n// ----------------------------------------------------------------------\nvideoInput::~videoInput(){\n\n    for(int i = 0; i < VI_MAX_CAMERAS; i++)\n    {\n        delete VDList[i];\n    }\n    //Unitialize com\n    comUnInit();\n}\n\n\n//////////////////////////////  VIDEO INPUT  ////////////////////////////////\n////////////////////////////  PRIVATE METHODS  //////////////////////////////\n\n// ----------------------------------------------------------------------\n// We only should init com if it hasn't been done so by our apps thread\n// Use a static counter to keep track of other times it has been inited\n// (do we need to worry about multithreaded apps?)\n// ----------------------------------------------------------------------\n\nbool videoInput::comInit(){\n    /*HRESULT hr = NOERROR;\n\n    //no need for us to start com more than once\n    if(comInitCount == 0 ){\n\n        // Initialize the COM library.\n        //CoInitializeEx so videoInput can run in another thread\n    #ifdef VI_COM_MULTI_THREADED\n        hr = CoInitializeEx(NULL,COINIT_MULTITHREADED);\n    #else\n        hr = CoInitialize(NULL);\n    #endif\n        //this is the only case where there might be a problem\n        //if another library has started com as single threaded\n        //and we need it multi-threaded - send warning but don't fail\n        if( hr == RPC_E_CHANGED_MODE){\n             DebugPrintOut(\"SETUP - COM already setup - threaded VI might not be possible\\n\");\n        }\n    }\n\n    comInitCount++;*/\n    return true;\n}\n\n\n// ----------------------------------------------------------------------\n// Same as above but to unitialize com, decreases counter and frees com\n// if no one else is using it\n// ----------------------------------------------------------------------\n\nbool videoInput::comUnInit(){\n    /*if(comInitCount > 0)comInitCount--;        //decrease the count of instances using com\n\n       if(comInitCount == 0){\n           CoUninitialize();    //if there are no instances left - uninitialize com\n        return true;\n    }\n\n    return false;*/\n    return true;\n}\n\n\n// ----------------------------------------------------------------------\n// This is the size we ask for - we might not get it though :)\n//\n// ----------------------------------------------------------------------\n\nvoid videoInput::setAttemptCaptureSize(int id, int w, int h,GUID mediaType){\n\n    VDList[id]->tryWidth    = w;\n    VDList[id]->tryHeight   = h;\n    VDList[id]->tryDiffSize = true;\n    VDList[id]->tryVideoType = mediaType;\n\n}\n\n// ----------------------------------------------------------------------\n// Set the connection type\n// (maybe move to private?)\n// ----------------------------------------------------------------------\n\nvoid videoInput::setPhyCon(int id, int conn){\n\n    switch(conn){\n\n        case 0:\n            VDList[id]->connection = PhysConn_Video_Composite;\n            break;\n        case 1:\n            VDList[id]->connection = PhysConn_Video_SVideo;\n            break;\n        case 2:\n            VDList[id]->connection = PhysConn_Video_Tuner;\n            break;\n        case 3:\n            VDList[id]->connection = PhysConn_Video_USB;\n            break;\n        case 4:\n            VDList[id]->connection = PhysConn_Video_1394;\n            break;\n        default:\n            return; //if it is not these types don't set crossbar\n        break;\n    }\n\n    VDList[id]->storeConn    = conn;\n    VDList[id]->useCrossbar    = true;\n}\n\n\n\n\u4e0b\u306eint deviceNumber\u3068\u3044\u3046\u306e\u304c\u3069\u3053\u304b\u3089\u6765\u3066\u3044\u308b\u306e\u304b\u8abf\u3079\u308b\u3002\nsetup\u95a2\u6570\u304c\u4f7f\u308f\u308c\u3066\u3044\u308b\u5834\u6240\u3092\u63a2\u3059\u3002\n\n// ----------------------------------------------------------------------\n// Check that we are not trying to setup a non-existant device\n// Then start the graph building!\n// ----------------------------------------------------------------------\n\nbool videoInput::setup(int deviceNumber){\n    devicesFound = getDeviceCount();\n\n     if(deviceNumber>devicesFound-1)\n    {\n        DebugPrintOut(\"SETUP: device[%i] not found - you have %i devices available\\n\", deviceNumber, devicesFound);\n        if(devicesFound>=0) DebugPrintOut(\"SETUP: this means that the last device you can use is device[%i]\\n\",  devicesFound-1);\n        return false;\n    }\n\n    if(VDList[deviceNumber]->readyToCapture)\n    {\n        DebugPrintOut(\"SETUP: can't setup, device %i is currently being used\\n\",VDList[deviceNumber]->myID);\n        return false;\n    }\n\n    HRESULT hr = start(deviceNumber, VDList[deviceNumber]);\n    if(hr == S_OK)return true;\n    else return false;\n}\n\n\n// ----------------------------------------------------------------------\n// Does both vertical buffer flipping and bgr to rgb swapping\n// You have any combination of those.\n// ----------------------------------------------------------------------\n\nvoid videoInput::processPixels(unsigned char * src, unsigned char * dst, int width, int height, bool bRGB, bool bFlip){\n\n    int widthInBytes = width * 3;\n    int numBytes = widthInBytes * height;\n\n    if(!bRGB){\n\n        //int x = 0;\n        //int y = 0;\n\n        if(bFlip){\n            for(int y = 0; y < height; y++){\n                memcpy(dst + (y * widthInBytes), src + ( (height -y -1) * widthInBytes), widthInBytes);\n            }\n\n        }else{\n            memcpy(dst, src, numBytes);\n        }\n    }else{\n        if(bFlip){\n\n            int x = 0;\n            int y = (height - 1) * widthInBytes;\n            src += y;\n\n            for(int i = 0; i < numBytes; i+=3){\n                if(x >= width){\n                    x = 0;\n                    src -= widthInBytes*2;\n                }\n\n                *dst = *(src+2);\n                dst++;\n\n                *dst = *(src+1);\n                dst++;\n\n                *dst = *src;\n                dst++;\n\n                src+=3;\n                x++;\n            }\n        }\n        else{\n            for(int i = 0; i < numBytes; i+=3){\n                *dst = *(src+2);\n                dst++;\n\n                *dst = *(src+1);\n                dst++;\n\n                *dst = *src;\n                dst++;\n\n                src+=3;\n            }\n        }\n    }\n}\n\n\n//------------------------------------------------------------------------------------------\nvoid videoInput::getMediaSubtypeAsString(GUID type, char * typeAsString){\n\n    char tmpStr[8];\n    if( type == MEDIASUBTYPE_RGB24)     sprintf(tmpStr, \"RGB24\");\n    else if(type == MEDIASUBTYPE_RGB32) sprintf(tmpStr, \"RGB32\");\n    else if(type == MEDIASUBTYPE_RGB555)sprintf(tmpStr, \"RGB555\");\n    else if(type == MEDIASUBTYPE_RGB565)sprintf(tmpStr, \"RGB565\");\n    else if(type == MEDIASUBTYPE_YUY2)  sprintf(tmpStr, \"YUY2\");\n    else if(type == MEDIASUBTYPE_YVYU)  sprintf(tmpStr, \"YVYU\");\n    else if(type == MEDIASUBTYPE_YUYV)  sprintf(tmpStr, \"YUYV\");\n    else if(type == MEDIASUBTYPE_IYUV)  sprintf(tmpStr, \"IYUV\");\n    else if(type == MEDIASUBTYPE_UYVY)  sprintf(tmpStr, \"UYVY\");\n    else if(type == MEDIASUBTYPE_YV12)  sprintf(tmpStr, \"YV12\");\n    else if(type == MEDIASUBTYPE_YVU9)  sprintf(tmpStr, \"YVU9\");\n    else if(type == MEDIASUBTYPE_Y411)  sprintf(tmpStr, \"Y411\");\n    else if(type == MEDIASUBTYPE_Y41P)  sprintf(tmpStr, \"Y41P\");\n    else if(type == MEDIASUBTYPE_Y211)  sprintf(tmpStr, \"Y211\");\n    else if(type == MEDIASUBTYPE_AYUV)  sprintf(tmpStr, \"AYUV\");\n    else if(type == MEDIASUBTYPE_MJPG)  sprintf(tmpStr, \"MJPG\");\n    else if(type == MEDIASUBTYPE_Y800)  sprintf(tmpStr, \"Y800\");\n    else if(type == MEDIASUBTYPE_Y8)    sprintf(tmpStr, \"Y8\");\n    else if(type == MEDIASUBTYPE_GREY)  sprintf(tmpStr, \"GREY\");\n    else if(type == MEDIASUBTYPE_I420)  sprintf(tmpStr, \"I420\");\n    else sprintf(tmpStr, \"OTHER\");\n\n    memcpy(typeAsString, tmpStr, sizeof(char)*8);\n}\n\nint videoInput::getFourccFromMediaSubtype(GUID type) const\n{\n    return type.Data1;\n}\n\nGUID *videoInput::getMediaSubtypeFromFourcc(int fourcc){\n\n    for (int i=0;i<VI_NUM_TYPES;i++) {\n        if ( (unsigned long)(unsigned)fourcc == mediaSubtypes[i].Data1 ) {\n            return &mediaSubtypes[i];\n        }\n    }\n\n    return NULL;\n}\n\n\nvoid videoInput::getVideoPropertyAsString(int prop, char * propertyAsString){\n\n    char tmpStr[16];\n\n    if ( prop==VideoProcAmp_Brightness) sprintf(tmpStr, \"Brightness\");\n    else if ( prop==VideoProcAmp_Contrast) sprintf(tmpStr, \"Contrast\");\n    else if ( prop==VideoProcAmp_Saturation) sprintf(tmpStr, \"Saturation\");\n    else if ( prop==VideoProcAmp_Hue) sprintf(tmpStr, \"Hue\");\n    else if ( prop==VideoProcAmp_Gain) sprintf(tmpStr, \"Gain\");\n    else if ( prop==VideoProcAmp_Gamma) sprintf(tmpStr, \"Gamma\");\n    else if ( prop==VideoProcAmp_ColorEnable) sprintf(tmpStr, \"ColorEnable\");\n    else if ( prop==VideoProcAmp_Sharpness) sprintf(tmpStr, \"Sharpness\");\n    else sprintf(tmpStr, \"%u\",prop);\n\n    memcpy(propertyAsString, tmpStr, sizeof(char)*16);\n}\n\n\nint videoInput::getVideoPropertyFromCV(int cv_property){\n\n    // see VideoProcAmpProperty in strmif.h\n    switch (cv_property) {\n        case CV_CAP_PROP_BRIGHTNESS:\n            return VideoProcAmp_Brightness;\n\n        case CV_CAP_PROP_CONTRAST:\n            return VideoProcAmp_Contrast;\n\n        case CV_CAP_PROP_HUE:\n            return VideoProcAmp_Hue;\n\n        case CV_CAP_PROP_SATURATION:\n            return VideoProcAmp_Saturation;\n\n        case CV_CAP_PROP_SHARPNESS:\n            return VideoProcAmp_Sharpness;\n\n        case CV_CAP_PROP_GAMMA:\n            return VideoProcAmp_Gamma;\n\n        case CV_CAP_PROP_MONOCHROME:\n            return VideoProcAmp_ColorEnable;\n\n        case CV_CAP_PROP_WHITE_BALANCE_BLUE_U:\n            return VideoProcAmp_WhiteBalance;\n\n        case  CV_CAP_PROP_BACKLIGHT:\n            return VideoProcAmp_BacklightCompensation;\n\n        case CV_CAP_PROP_GAIN:\n            return VideoProcAmp_Gain;\n    }\n    return -1;\n}\n\nint videoInput::getCameraPropertyFromCV(int cv_property){\n\n    // see CameraControlProperty in strmif.h\n    switch (cv_property) {\n        case CV_CAP_PROP_PAN:\n            return CameraControl_Pan;\n\n        case CV_CAP_PROP_TILT:\n            return CameraControl_Tilt;\n\n        case CV_CAP_PROP_ROLL:\n            return CameraControl_Roll;\n\n        case CV_CAP_PROP_ZOOM:\n            return CameraControl_Zoom;\n\n        case CV_CAP_PROP_EXPOSURE:\n            return CameraControl_Exposure;\n\n        case CV_CAP_PROP_IRIS:\n            return CameraControl_Iris;\n\n        case CV_CAP_PROP_FOCUS:\n            return CameraControl_Focus;\n    }\n    return -1;\n}\n\nvoid videoInput::getCameraPropertyAsString(int prop, char * propertyAsString){\n\n    char tmpStr[16];\n\n    if ( prop==CameraControl_Pan) sprintf(tmpStr, \"Pan\");\n    else if ( prop==CameraControl_Tilt) sprintf(tmpStr, \"Tilt\");\n    else if ( prop==CameraControl_Roll) sprintf(tmpStr, \"Roll\");\n    else if ( prop==CameraControl_Zoom) sprintf(tmpStr, \"Zoom\");\n    else if ( prop==CameraControl_Exposure) sprintf(tmpStr, \"Exposure\");\n    else if ( prop==CameraControl_Iris) sprintf(tmpStr, \"Iris\");\n    else if ( prop==CameraControl_Focus) sprintf(tmpStr, \"Focus\");\n    else sprintf(tmpStr, \"%u\",prop);\n\n    memcpy(propertyAsString, tmpStr, sizeof(char)*16);\n}\n\n\n//-------------------------------------------------------------------------------------------\nstatic void findClosestSizeAndSubtype(videoDevice * VD, int widthIn, int heightIn, int &widthOut, int &heightOut, GUID & mediatypeOut){\n    HRESULT hr;\n\n    //find perfect match or closest size\n    int nearW                = 9999999;\n    int nearH                = 9999999;\n    //bool foundClosestMatch     = true;\n\n    int iCount = 0;\n    int iSize = 0;\n    hr = VD->streamConf->GetNumberOfCapabilities(&iCount, &iSize);\n\n    if (iSize == sizeof(VIDEO_STREAM_CONFIG_CAPS))\n    {\n        //For each format type RGB24 YUV2 etc\n        for (int iFormat = 0; iFormat < iCount; iFormat++)\n        {\n            VIDEO_STREAM_CONFIG_CAPS scc;\n            AM_MEDIA_TYPE *pmtConfig;\n            hr =  VD->streamConf->GetStreamCaps(iFormat, &pmtConfig, (BYTE*)&scc);\n\n            if (SUCCEEDED(hr)){\n\n                //his is how many diff sizes are available for the format\n                int stepX = scc.OutputGranularityX;\n                int stepY = scc.OutputGranularityY;\n\n                   int tempW = 999999;\n                   int tempH = 999999;\n\n                   //Don't want to get stuck in a loop\n                   if(stepX < 1 || stepY < 1) continue;\n\n                   //DebugPrintOut(\"min is %i %i max is %i %i - res is %i %i\\n\", scc.MinOutputSize.cx, scc.MinOutputSize.cy,  scc.MaxOutputSize.cx,  scc.MaxOutputSize.cy, stepX, stepY);\n                   //DebugPrintOut(\"min frame duration is %i  max duration is %i\\n\", scc.MinFrameInterval, scc.MaxFrameInterval);\n\n                   bool exactMatch     = false;\n                   bool exactMatchX    = false;\n                bool exactMatchY    = false;\n\n                for(int x = scc.MinOutputSize.cx; x <= scc.MaxOutputSize.cx; x+= stepX){\n                    //If we find an exact match\n                    if( widthIn == x ){\n                        exactMatchX = true;\n                        tempW = x;\n                    }\n                    //Otherwise lets find the closest match based on width\n                    else if( abs(widthIn-x) < abs(widthIn-tempW) ){\n                        tempW = x;\n                    }\n                }\n\n                for(int y = scc.MinOutputSize.cy; y <= scc.MaxOutputSize.cy; y+= stepY){\n                    //If we find an exact match\n                    if( heightIn == y){\n                        exactMatchY = true;\n                        tempH = y;\n                    }\n                    //Otherwise lets find the closest match based on height\n                    else if( abs(heightIn-y) < abs(heightIn-tempH) ){\n                        tempH = y;\n                    }\n                }\n\n                //see if we have an exact match!\n                if(exactMatchX && exactMatchY){\n                    //foundClosestMatch = false;\n                    exactMatch = true;\n\n                    widthOut        = widthIn;\n                    heightOut        = heightIn;\n                    mediatypeOut    = pmtConfig->subtype;\n                }\n\n                  //otherwise lets see if this filters closest size is the closest\n                  //available. the closest size is determined by the sum difference\n                //of the widths and heights\n                  else if( abs(widthIn - tempW) + abs(heightIn - tempH)  < abs(widthIn - nearW) + abs(heightIn - nearH) )\n                  {\n                      nearW = tempW;\n                      nearH = tempH;\n\n                    widthOut        = nearW;\n                    heightOut        = nearH;\n                    mediatypeOut    = pmtConfig->subtype;\n                  }\n\n                MyDeleteMediaType(pmtConfig);\n\n                //If we have found an exact match no need to search anymore\n                if(exactMatch)break;\n            }\n         }\n    }\n\n}\n\n\n//---------------------------------------------------------------------------------------------------\nstatic bool setSizeAndSubtype(videoDevice * VD, int attemptWidth, int attemptHeight, GUID mediatype){\n    VIDEOINFOHEADER *pVih =  reinterpret_cast<VIDEOINFOHEADER*>(VD->pAmMediaType->pbFormat);\n\n    //store current size\n    //int tmpWidth  = HEADER(pVih)->biWidth;\n    //int tmpHeight = HEADER(pVih)->biHeight;\n    AM_MEDIA_TYPE * tmpType = NULL;\n\n    HRESULT    hr = VD->streamConf->GetFormat(&tmpType);\n    if(hr != S_OK)return false;\n\n    //set new size:\n    //width and height\n    HEADER(pVih)->biWidth  = attemptWidth;\n    HEADER(pVih)->biHeight = attemptHeight;\n\n    VD->pAmMediaType->formattype = FORMAT_VideoInfo;\n    VD->pAmMediaType->majortype  = MEDIATYPE_Video;\n    VD->pAmMediaType->subtype     = mediatype;\n\n    //buffer size\n    if (mediatype == MEDIASUBTYPE_RGB24)\n    {\n        VD->pAmMediaType->lSampleSize = attemptWidth*attemptHeight*3;\n    }\n    else\n    {\n        // For compressed data, the value can be zero.\n        VD->pAmMediaType->lSampleSize = 0;\n    }\n\n    //set fps if requested\n    if( VD->requestedFrameTime != -1){\n        pVih->AvgTimePerFrame = VD->requestedFrameTime;\n    }\n\n    //okay lets try new size\n    hr = VD->streamConf->SetFormat(VD->pAmMediaType);\n    if(hr == S_OK){\n        if( tmpType != NULL )MyDeleteMediaType(tmpType);\n        return true;\n    }else{\n        VD->streamConf->SetFormat(tmpType);\n        if( tmpType != NULL )MyDeleteMediaType(tmpType);\n    }\n\n    return false;\n}\n\n\n\u5168\u3066\u304c\u8d77\u52d5\u3059\u308b\u5834\u6240\n\u7279\u5b9a\u306e\u30c7\u30d0\u30a4\u30b9\u306b\u5bfe\u3057\u3066\u30b0\u30e9\u30d5\u3092\u30d3\u30eb\u30c9\u3057\u3088\u3046\u3068\u3059\u308b\u3002\nstart\u95a2\u6570\u306fdeviceID\u3068videoDevice\u3092\u5f15\u6570\u306b\u3057\u3066\u59cb\u52d5\u3059\u308b\u3002\n\u3053\u3053\u3067\u3001deviceID\u3068\u306f\u4f55\u306a\u306e\u304b\u78ba\u8a8d\u3059\u308b\u3002\n\u3084\u306f\u308a\u3001deviceID\u304c\u5f15\u6570\u306b\u306a\u3063\u3066\u3044\u308b\u304b\u3089\u3001\u30c7\u30d0\u30a4\u30b9\u306e\uff29\uff24\u3092\u53d6\u3063\u3066\u3053\u306a\u3044\u3068\u3044\u3051\u306a\u3044\u3002\n```\n// ----------------------------------------------------------------------\n// Where all the work happens!\n// Attempts to build a graph for the specified device\n// ----------------------------------------------------------------------\nint videoInput::start(int deviceID, videoDevice *VD){\nHRESULT hr             = NOERROR;\nVD->myID             = deviceID;\nVD->setupStarted    = true;\nCAPTURE_MODE           = PIN_CATEGORY_CAPTURE; //Don't worry - it ends up being preview (which is faster)\ncallbackSetCount     = 1;  //make sure callback method is not changed after setup called\n\nDebugPrintOut(\"SETUP: Setting up device %i\\n\",deviceID);\n\n// CREATE THE GRAPH BUILDER //\n// Create the filter graph manager and query for interfaces.\nhr = CoCreateInstance(CLSID_CaptureGraphBuilder2, NULL, CLSCTX_INPROC_SERVER, IID_ICaptureGraphBuilder2, (void **)&VD->pCaptureGraph);\nif (FAILED(hr))    // FAILED is a macro that tests the return value\n{\n    DebugPrintOut(\"ERROR - Could not create the Filter Graph Manager\\n\");\n    return hr;\n}\n\n//FITLER GRAPH MANAGER//\n// Create the Filter Graph Manager.\nhr = CoCreateInstance(CLSID_FilterGraph, 0, CLSCTX_INPROC_SERVER,IID_IGraphBuilder, (void**)&VD->pGraph);\nif (FAILED(hr))\n{\n    DebugPrintOut(\"ERROR - Could not add the graph builder!\\n\");\n    stopDevice(deviceID);\n    return hr;\n}\n\n//SET THE FILTERGRAPH//\nhr = VD->pCaptureGraph->SetFiltergraph(VD->pGraph);\nif (FAILED(hr))\n{\n    DebugPrintOut(\"ERROR - Could not set filtergraph\\n\");\n    stopDevice(deviceID);\n    return hr;\n}\n\n//MEDIA CONTROL (START/STOPS STREAM)//\n// Using QueryInterface on the graph builder,\n// Get the Media Control object.\nhr = VD->pGraph->QueryInterface(IID_IMediaControl, (void **)&VD->pControl);\nif (FAILED(hr))\n{\n    DebugPrintOut(\"ERROR - Could not create the Media Control object\\n\");\n    stopDevice(deviceID);\n    return hr;\n}\n\n\n//FIND VIDEO DEVICE AND ADD TO GRAPH//\n//gets the device specified by the second argument.\nhr = getDevice(&VD->pVideoInputFilter, deviceID, VD->wDeviceName, VD->nDeviceName);\n\nif (SUCCEEDED(hr)){\n    DebugPrintOut(\"SETUP: %s\\n\", VD->nDeviceName);\n    hr = VD->pGraph->AddFilter(VD->pVideoInputFilter, VD->wDeviceName);\n}else{\n    DebugPrintOut(\"ERROR - Could not find specified video device\\n\");\n    stopDevice(deviceID);\n    return hr;\n}\n\n//LOOK FOR PREVIEW PIN IF THERE IS NONE THEN WE USE CAPTURE PIN AND THEN SMART TEE TO PREVIEW\nIAMStreamConfig *streamConfTest = NULL;\nhr = VD->pCaptureGraph->FindInterface(&PIN_CATEGORY_PREVIEW, &MEDIATYPE_Video, VD->pVideoInputFilter, IID_IAMStreamConfig, (void **)&streamConfTest);\nif(FAILED(hr)){\n    DebugPrintOut(\"SETUP: Couldn't find preview pin using SmartTee\\n\");\n}else{\n     CAPTURE_MODE = PIN_CATEGORY_PREVIEW;\n     streamConfTest->Release();\n     streamConfTest = NULL;\n}\n\n//CROSSBAR (SELECT PHYSICAL INPUT TYPE)//\n//my own function that checks to see if the device can support a crossbar and if so it routes it.\n//webcams tend not to have a crossbar so this function will also detect a webcams and not apply the crossbar\nif(VD->useCrossbar)\n{\n    DebugPrintOut(\"SETUP: Checking crossbar\\n\");\n    routeCrossbar(&VD->pCaptureGraph, &VD->pVideoInputFilter, VD->connection, CAPTURE_MODE);\n}\n\n\n//we do this because webcams don't have a preview mode\nhr = VD->pCaptureGraph->FindInterface(&CAPTURE_MODE, &MEDIATYPE_Video, VD->pVideoInputFilter, IID_IAMStreamConfig, (void **)&VD->streamConf);\nif(FAILED(hr)){\n    DebugPrintOut(\"ERROR: Couldn't config the stream!\\n\");\n    stopDevice(deviceID);\n    return hr;\n}\n\n//NOW LETS DEAL WITH GETTING THE RIGHT SIZE\nhr = VD->streamConf->GetFormat(&VD->pAmMediaType);\nif(FAILED(hr)){\n    DebugPrintOut(\"ERROR: Couldn't getFormat for pAmMediaType!\\n\");\n    stopDevice(deviceID);\n    return hr;\n}\n\nVIDEOINFOHEADER *pVih =  reinterpret_cast<VIDEOINFOHEADER*>(VD->pAmMediaType->pbFormat);\nint currentWidth    =  HEADER(pVih)->biWidth;\nint currentHeight    =  HEADER(pVih)->biHeight;\n\nbool customSize = VD->tryDiffSize;\n\nbool foundSize  = false;\n\nif(customSize){\n    DebugPrintOut(\"SETUP: Default Format is set to %ix%i\\n\", currentWidth, currentHeight);\n\n    char guidStr[8];\n        // try specified format and size\n        getMediaSubtypeAsString(VD->tryVideoType, guidStr);\n        DebugPrintOut(\"SETUP: trying specified format %s @ %ix%i\\n\", guidStr, VD->tryWidth, VD->tryHeight);\n\n        if( setSizeAndSubtype(VD, VD->tryWidth, VD->tryHeight, VD->tryVideoType) ){\n            VD->setSize(VD->tryWidth, VD->tryHeight);\n            VD->videoType = VD->tryVideoType;\n            foundSize = true;\n        } else {\n            // try specified size with all formats\n            for(int i = 0; i < VI_NUM_TYPES; i++){\n\n                getMediaSubtypeAsString(mediaSubtypes[i], guidStr);\n\n                DebugPrintOut(\"SETUP: trying format %s @ %ix%i\\n\", guidStr, VD->tryWidth, VD->tryHeight);\n                if( setSizeAndSubtype(VD, VD->tryWidth, VD->tryHeight, mediaSubtypes[i]) ){\n                    VD->setSize(VD->tryWidth, VD->tryHeight);\n                    VD->videoType = mediaSubtypes[i];\n                    foundSize = true;\n                    break;\n                }\n            }\n        }\n\n\n    //if we didn't find the requested size - lets try and find the closest matching size\n    if( foundSize == false ){\n        DebugPrintOut(\"SETUP: couldn't find requested size - searching for closest matching size\\n\");\n\n        int closestWidth        = -1;\n        int closestHeight        = -1;\n        GUID newMediaSubtype;\n\n        findClosestSizeAndSubtype(VD, VD->tryWidth, VD->tryHeight, closestWidth, closestHeight, newMediaSubtype);\n\n        if( closestWidth != -1 && closestHeight != -1){\n            getMediaSubtypeAsString(newMediaSubtype, guidStr);\n\n            DebugPrintOut(\"SETUP: closest supported size is %s @ %i %i\\n\", guidStr, closestWidth, closestHeight);\n            if( setSizeAndSubtype(VD, closestWidth, closestHeight, newMediaSubtype) ){\n                VD->setSize(closestWidth, closestHeight);\n                foundSize = true;\n            }\n        }\n    }\n}\n\n//if we didn't specify a custom size or if we did but couldn't find it lets setup with the default settings\nif(customSize == false || foundSize == false){\n    if( VD->requestedFrameTime != -1 ){\n        pVih->AvgTimePerFrame  = VD->requestedFrameTime;\n        hr = VD->streamConf->SetFormat(VD->pAmMediaType);\n    }\n    VD->setSize(currentWidth, currentHeight);\n}\n\n//SAMPLE GRABBER (ALLOWS US TO GRAB THE BUFFER)//\n// Create the Sample Grabber.\nhr = CoCreateInstance(CLSID_SampleGrabber, NULL, CLSCTX_INPROC_SERVER,IID_IBaseFilter, (void**)&VD->pGrabberF);\nif (FAILED(hr)){\n    DebugPrintOut(\"Could not Create Sample Grabber - CoCreateInstance()\\n\");\n    stopDevice(deviceID);\n    return hr;\n}\n\nhr = VD->pGraph->AddFilter(VD->pGrabberF, L\"Sample Grabber\");\nif (FAILED(hr)){\n    DebugPrintOut(\"Could not add Sample Grabber - AddFilter()\\n\");\n    stopDevice(deviceID);\n    return hr;\n}\n\nhr = VD->pGrabberF->QueryInterface(IID_ISampleGrabber, (void**)&VD->pGrabber);\nif (FAILED(hr)){\n    DebugPrintOut(\"ERROR: Could not query SampleGrabber\\n\");\n    stopDevice(deviceID);\n    return hr;\n}\n\n\n//Set Params - One Shot should be false unless you want to capture just one buffer\nhr = VD->pGrabber->SetOneShot(FALSE);\nif(bCallback){\n    hr = VD->pGrabber->SetBufferSamples(FALSE);\n}else{\n    hr = VD->pGrabber->SetBufferSamples(TRUE);\n}\n\nif(bCallback){\n    //Tell the grabber to use our callback function - 0 is for SampleCB and 1 for BufferCB\n    //We use SampleCB\n    hr = VD->pGrabber->SetCallback(VD->sgCallback, 0);\n    if (FAILED(hr)){\n        DebugPrintOut(\"ERROR: problem setting callback\\n\");\n        stopDevice(deviceID);\n        return hr;\n    }else{\n        DebugPrintOut(\"SETUP: Capture callback set\\n\");\n    }\n}\n\n//MEDIA CONVERSION\n//Get video properties from the stream's mediatype and apply to the grabber (otherwise we don't get an RGB image)\n//zero the media type - lets try this :) - maybe this works?\nAM_MEDIA_TYPE mt;\nZeroMemory(&mt,sizeof(AM_MEDIA_TYPE));\n\nmt.majortype     = MEDIATYPE_Video;\nmt.subtype         = MEDIASUBTYPE_RGB24;\nmt.formattype     = FORMAT_VideoInfo;\n\n//VD->pAmMediaType->subtype = VD->videoType;\nhr = VD->pGrabber->SetMediaType(&mt);\n\n//lets try freeing our stream conf here too\n//this will fail if the device is already running\nif(VD->streamConf){\n    VD->streamConf->Release();\n    VD->streamConf = NULL;\n}else{\n    DebugPrintOut(\"ERROR: connecting device - prehaps it is already being used?\\n\");\n    stopDevice(deviceID);\n    return S_FALSE;\n}\n\n\n//NULL RENDERER//\n//used to give the video stream somewhere to go to.\nhr = CoCreateInstance(CLSID_NullRenderer, NULL, CLSCTX_INPROC_SERVER, IID_IBaseFilter, (void**)(&VD->pDestFilter));\nif (FAILED(hr)){\n    DebugPrintOut(\"ERROR: Could not create filter - NullRenderer\\n\");\n    stopDevice(deviceID);\n    return hr;\n}\n\nhr = VD->pGraph->AddFilter(VD->pDestFilter, L\"NullRenderer\");\nif (FAILED(hr)){\n    DebugPrintOut(\"ERROR: Could not add filter - NullRenderer\\n\");\n    stopDevice(deviceID);\n    return hr;\n}\n\n//RENDER STREAM//\n//This is where the stream gets put together.\nhr = VD->pCaptureGraph->RenderStream(&PIN_CATEGORY_PREVIEW, &MEDIATYPE_Video, VD->pVideoInputFilter, VD->pGrabberF, VD->pDestFilter);\n\nif (FAILED(hr)){\n    DebugPrintOut(\"ERROR: Could not connect pins - RenderStream()\\n\");\n    stopDevice(deviceID);\n    return hr;\n}\n\n\n//EXP - lets try setting the sync source to null - and make it run as fast as possible\n{\n    IMediaFilter *pMediaFilter = 0;\n    hr = VD->pGraph->QueryInterface(IID_IMediaFilter, (void**)&pMediaFilter);\n    if (FAILED(hr)){\n        DebugPrintOut(\"ERROR: Could not get IID_IMediaFilter interface\\n\");\n    }else{\n        pMediaFilter->SetSyncSource(NULL);\n        pMediaFilter->Release();\n    }\n}\n\n\n//LETS RUN THE STREAM!\nhr = VD->pControl->Run();\n\nif (FAILED(hr)){\n     DebugPrintOut(\"ERROR: Could not start graph\\n\");\n     stopDevice(deviceID);\n     return hr;\n}\n\n\n//MAKE SURE THE DEVICE IS SENDING VIDEO BEFORE WE FINISH\nif(!bCallback){\n\n    long bufferSize = VD->videoSize;\n\n    while( hr != S_OK){\n        hr = VD->pGrabber->GetCurrentBuffer(&bufferSize, (long *)VD->pBuffer);\n        Sleep(10);\n    }\n\n}\n\nDebugPrintOut(\"SETUP: Device is setup and ready to capture.\\n\\n\");\nVD->readyToCapture = true;\n\n//Release filters - seen someone else do this\n//looks like it solved the freezes\n\n//if we release this then we don't have access to the settings\n//we release our video input filter but then reconnect with it\n//each time we need to use it\nVD->pVideoInputFilter->Release();\nVD->pVideoInputFilter = NULL;\n\nVD->pGrabberF->Release();\nVD->pGrabberF = NULL;\n\nVD->pDestFilter->Release();\nVD->pDestFilter = NULL;\n\nreturn S_OK;\n\n}\n\u3053\u3053\u304b\u3089\u59cb\u307e\u308b\u3068\u306e\u3053\u3068\n\n\n// ----------------------------------------------------------------------\n// Returns number of good devices\n//\n// ----------------------------------------------------------------------\nint videoInput::getDeviceCount(){\nICreateDevEnum *pDevEnum = NULL;\nIEnumMoniker *pEnum = NULL;\nint deviceCounter = 0;\n\nHRESULT hr = CoCreateInstance(CLSID_SystemDeviceEnum, NULL,\n    CLSCTX_INPROC_SERVER, IID_ICreateDevEnum,\n    reinterpret_cast<void**>(&pDevEnum));\n\n\nif (SUCCEEDED(hr))\n{\n    // Create an enumerator for the video capture category.\n    hr = pDevEnum->CreateClassEnumerator(\n        CLSID_VideoInputDeviceCategory,\n        &pEnum, 0);\n\n   if(hr == S_OK){\n        IMoniker *pMoniker = NULL;\n        while (pEnum->Next(1, &pMoniker, NULL) == S_OK){\n\n            IPropertyBag *pPropBag;\n            hr = pMoniker->BindToStorage(0, 0, IID_IPropertyBag,\n                (void**)(&pPropBag));\n\n            if (FAILED(hr)){\n                pMoniker->Release();\n                continue;  // Skip this one, maybe the next one will work.\n            }\n\n            pPropBag->Release();\n            pPropBag = NULL;\n\n            pMoniker->Release();\n            pMoniker = NULL;\n\n            deviceCounter++;\n        }\n\n        pEnum->Release();\n        pEnum = NULL;\n    }\n\n    pDevEnum->Release();\n    pDevEnum = NULL;\n}\nreturn deviceCounter;\n\n}\n// ----------------------------------------------------------------------\n// Do we need this?\n//\n// Enumerate all of the video input devices\n// Return the filter with a matching friendly name\n// ----------------------------------------------------------------------\nHRESULT videoInput::getDevice(IBaseFilter** gottaFilter, int deviceId, WCHAR * wDeviceName, char * nDeviceName){\n    BOOL done = false;\n    int deviceCounter = 0;\n// Create the System Device Enumerator.\nICreateDevEnum *pSysDevEnum = NULL;\nHRESULT hr = CoCreateInstance(CLSID_SystemDeviceEnum, NULL, CLSCTX_INPROC_SERVER, IID_ICreateDevEnum, (void **)&pSysDevEnum);\nif (FAILED(hr))\n{\n    return hr;\n}\n\n// Obtain a class enumerator for the video input category.\nIEnumMoniker *pEnumCat = NULL;\nhr = pSysDevEnum->CreateClassEnumerator(CLSID_VideoInputDeviceCategory, &pEnumCat, 0);\n\nif (hr == S_OK)\n{\n    // Enumerate the monikers.\n    IMoniker *pMoniker = NULL;\n    ULONG cFetched;\n    while ((pEnumCat->Next(1, &pMoniker, &cFetched) == S_OK) && (!done))\n    {\n        if(deviceCounter == deviceId)\n        {\n            // Bind the first moniker to an object\n            IPropertyBag *pPropBag;\n            hr = pMoniker->BindToStorage(0, 0, IID_IPropertyBag, (void **)&pPropBag);\n            if (SUCCEEDED(hr))\n            {\n                // To retrieve the filter's friendly name, do the following:\n                VARIANT varName;\n                VariantInit(&varName);\n                hr = pPropBag->Read(L\"FriendlyName\", &varName, 0);\n                if (SUCCEEDED(hr))\n                {\n\n                    //copy the name to nDeviceName & wDeviceName\n                    int count = 0;\n                    while( varName.bstrVal[count] != 0x00 ) {\n                           wDeviceName[count] = varName.bstrVal[count];\n                           nDeviceName[count] = (char)varName.bstrVal[count];\n                           count++;\n                     }\n\n                    // We found it, so send it back to the caller\n                    hr = pMoniker->BindToObject(NULL, NULL, IID_IBaseFilter, (void**)gottaFilter);\n                    done = true;\n                }\n                VariantClear(&varName);\n                pPropBag->Release();\n                pPropBag = NULL;\n                pMoniker->Release();\n                pMoniker = NULL;\n            }\n        }\n        deviceCounter++;\n    }\n    pEnumCat->Release();\n    pEnumCat = NULL;\n}\npSysDevEnum->Release();\npSysDevEnum = NULL;\n\nif (done) {\n    return hr;    // found it, return native error\n} else {\n    return VFW_E_NOT_FOUND;    // didn't find it error\n}\n\n}\n// ----------------------------------------------------------------------\n// Show the property pages for a filter\n// This is stolen from the DX9 SDK\n// ----------------------------------------------------------------------\nHRESULT videoInput::ShowFilterPropertyPages(IBaseFilter *pFilter){\nISpecifyPropertyPages *pProp;\n\nHRESULT hr = pFilter->QueryInterface(IID_ISpecifyPropertyPages, (void **)&pProp);\nif (SUCCEEDED(hr))\n{\n    // Get the filter's name and IUnknown pointer.\n    FILTER_INFO FilterInfo;\n    hr = pFilter->QueryFilterInfo(&FilterInfo);\n    IUnknown *pFilterUnk;\n    pFilter->QueryInterface(IID_IUnknown, (void **)&pFilterUnk);\n\n    // Show the page.\n    CAUUID caGUID;\n    pProp->GetPages(&caGUID);\n    pProp->Release();\n    OleCreatePropertyFrame(\n        NULL,                   // Parent window\n        0, 0,                   // Reserved\n        FilterInfo.achName,     // Caption for the dialog box\n        1,                      // Number of objects (just the filter)\n        &pFilterUnk,            // Array of object pointers.\n        caGUID.cElems,          // Number of property pages\n        caGUID.pElems,          // Array of property page CLSIDs\n        0,                      // Locale identifier\n        0, NULL                 // Reserved\n    );\n\n    // Clean up.\n    if(pFilterUnk)pFilterUnk->Release();\n    if(FilterInfo.pGraph)FilterInfo.pGraph->Release();\n    CoTaskMemFree(caGUID.pElems);\n}\nreturn hr;\n\n}\nHRESULT videoInput::ShowStreamPropertyPages(IAMStreamConfig  * /pStream/){\nHRESULT hr             = NOERROR;\nreturn hr;\n\n}\n\n\u3053\u3053\u3067\u30d5\u30a3\u30eb\u30bf\u30fc\u3092\u8aad\u307f\u8fbc\u3093\u3067\u3044\u308b\u306e\u3060\u308d\u3046\u304b\uff1f\n\n\n// ----------------------------------------------------------------------\n// This code was also brazenly stolen from the DX9 SDK\n// Pass it a file name in wszPath, and it will save the filter graph to that file.\n// ----------------------------------------------------------------------\nHRESULT videoInput::SaveGraphFile(IGraphBuilder *pGraph, WCHAR *wszPath) {\n    const WCHAR wszStreamName[] = L\"ActiveMovieGraph\";\n    HRESULT hr;\n    IStorage *pStorage = NULL;\n// First, create a document file which will hold the GRF file\nhr = StgCreateDocfile(\n    wszPath,\n    STGM_CREATE | STGM_TRANSACTED | STGM_READWRITE | STGM_SHARE_EXCLUSIVE,\n    0, &pStorage);\nif(FAILED(hr))\n{\n    return hr;\n}\n\n// Next, create a stream to store.\nIStream *pStream;\nhr = pStorage->CreateStream(\n    wszStreamName,\n    STGM_WRITE | STGM_CREATE | STGM_SHARE_EXCLUSIVE,\n    0, 0, &pStream);\nif (FAILED(hr))\n{\n    pStorage->Release();\n    return hr;\n}\n\n// The IPersistStream converts a stream into a persistent object.\nIPersistStream *pPersist = NULL;\npGraph->QueryInterface(IID_IPersistStream, reinterpret_cast<void**>(&pPersist));\nhr = pPersist->Save(pStream, TRUE);\npStream->Release();\npPersist->Release();\nif (SUCCEEDED(hr))\n{\n    hr = pStorage->Commit(STGC_DEFAULT);\n}\npStorage->Release();\nreturn hr;\n\n}\n// ----------------------------------------------------------------------\n// For changing the input types\n//\n// ----------------------------------------------------------------------\nHRESULT videoInput::routeCrossbar(ICaptureGraphBuilder2 **ppBuild, IBaseFilter **pVidInFilter, int conType, GUID captureMode){\n//create local ICaptureGraphBuilder2\nICaptureGraphBuilder2 *pBuild = NULL;\n pBuild = *ppBuild;\n\n //create local IBaseFilter\n IBaseFilter *pVidFilter = NULL;\n pVidFilter = * pVidInFilter;\n\n// Search upstream for a crossbar.\nIAMCrossbar *pXBar1 = NULL;\nHRESULT hr = pBuild->FindInterface(&LOOK_UPSTREAM_ONLY, NULL, pVidFilter,\n        IID_IAMCrossbar, (void**)&pXBar1);\nif (SUCCEEDED(hr))\n{\n\n    bool foundDevice = false;\n\n    DebugPrintOut(\"SETUP: You are not a webcam! Setting Crossbar\\n\");\n    pXBar1->Release();\n\n    IAMCrossbar *Crossbar;\n    hr = pBuild->FindInterface(&captureMode, &MEDIATYPE_Interleaved, pVidFilter, IID_IAMCrossbar, (void **)&Crossbar);\n\n    if(hr != NOERROR){\n        hr = pBuild->FindInterface(&captureMode, &MEDIATYPE_Video, pVidFilter, IID_IAMCrossbar, (void **)&Crossbar);\n    }\n\n    LONG lInpin, lOutpin;\n    hr = Crossbar->get_PinCounts(&lOutpin , &lInpin);\n\n    BOOL iPin=TRUE; LONG pIndex=0 , pRIndex=0 , pType=0;\n\n    while( pIndex < lInpin)\n    {\n        hr = Crossbar->get_CrossbarPinInfo( iPin , pIndex , &pRIndex , &pType);\n\n        if( pType == conType){\n                DebugPrintOut(\"SETUP: Found Physical Interface\");\n\n                switch(conType){\n\n                    case PhysConn_Video_Composite:\n                        DebugPrintOut(\" - Composite\\n\");\n                        break;\n                    case PhysConn_Video_SVideo:\n                        DebugPrintOut(\" - S-Video\\n\");\n                        break;\n                    case PhysConn_Video_Tuner:\n                        DebugPrintOut(\" - Tuner\\n\");\n                        break;\n                    case PhysConn_Video_USB:\n                        DebugPrintOut(\" - USB\\n\");\n                        break;\n                    case PhysConn_Video_1394:\n                        DebugPrintOut(\" - Firewire\\n\");\n                        break;\n                }\n\n            foundDevice = true;\n            break;\n        }\n        pIndex++;\n\n    }\n\n    if(foundDevice){\n        BOOL OPin=FALSE; LONG pOIndex=0 , pORIndex=0 , pOType=0;\n        while( pOIndex < lOutpin)\n        {\n            hr = Crossbar->get_CrossbarPinInfo( OPin , pOIndex , &pORIndex , &pOType);\n            if( pOType == PhysConn_Video_VideoDecoder)\n                break;\n        }\n        Crossbar->Route(pOIndex,pIndex);\n    }else{\n        DebugPrintOut(\"SETUP: Didn't find specified Physical Connection type. Using Defualt.\\n\");\n    }\n\n    //we only free the crossbar when we close or restart the device\n    //we were getting a crash otherwise\n    //if(Crossbar)Crossbar->Release();\n    //if(Crossbar)Crossbar = NULL;\n\n    if(pXBar1)pXBar1->Release();\n    if(pXBar1)pXBar1 = NULL;\n\n}else{\n    DebugPrintOut(\"SETUP: You are a webcam or snazzy firewire cam! No Crossbar needed\\n\");\n    return hr;\n}\n\nreturn hr;\n\n}\nnamespace cv\n{\nvideoInput VideoCapture_DShow::g_VI;\nVideoCapture_DShow::VideoCapture_DShow(int index)\n    : m_index(-1)\n    , m_width(-1)\n    , m_height(-1)\n    , m_fourcc(-1)\n    , m_widthSet(-1)\n    , m_heightSet(-1)\n{\n    CoInitialize(0);\n    open(index);\n}\nVideoCapture_DShow::~VideoCapture_DShow()\n{\n    close();\n    CoUninitialize();\n}\ndouble VideoCapture_DShow::getProperty(int propIdx) const\n{\nlong min_value, max_value, stepping_delta, current_value, flags, defaultValue;\n\nswitch (propIdx)\n{\n// image format properties\ncase CV_CAP_PROP_FRAME_WIDTH:\n    return g_VI.getWidth(m_index);\ncase CV_CAP_PROP_FRAME_HEIGHT:\n    return g_VI.getHeight(m_index);\ncase CV_CAP_PROP_FOURCC:\n    return g_VI.getFourcc(m_index);\ncase CV_CAP_PROP_FPS:\n    return g_VI.getFPS(m_index);\n\n// video filter properties\ncase CV_CAP_PROP_BRIGHTNESS:\ncase CV_CAP_PROP_CONTRAST:\ncase CV_CAP_PROP_HUE:\ncase CV_CAP_PROP_SATURATION:\ncase CV_CAP_PROP_SHARPNESS:\ncase CV_CAP_PROP_GAMMA:\ncase CV_CAP_PROP_MONOCHROME:\ncase CV_CAP_PROP_WHITE_BALANCE_BLUE_U:\ncase CV_CAP_PROP_BACKLIGHT:\ncase CV_CAP_PROP_GAIN:\n    if (g_VI.getVideoSettingFilter(m_index, g_VI.getVideoPropertyFromCV(propIdx), min_value, max_value, stepping_delta, current_value, flags, defaultValue))\n        return (double)current_value;\n\n// camera properties\ncase CV_CAP_PROP_PAN:\ncase CV_CAP_PROP_TILT:\ncase CV_CAP_PROP_ROLL:\ncase CV_CAP_PROP_ZOOM:\ncase CV_CAP_PROP_EXPOSURE:\ncase CV_CAP_PROP_IRIS:\ncase CV_CAP_PROP_FOCUS:\n    if (g_VI.getVideoSettingCamera(m_index, g_VI.getCameraPropertyFromCV(propIdx), min_value, max_value, stepping_delta, current_value, flags, defaultValue))\n        return (double)current_value;\n}\n\n// unknown parameter or value not available\nreturn -1;\n\n}\nbool VideoCapture_DShow::setProperty(int propIdx, double propVal)\n{\n    // image capture properties\n    bool handled = false;\n    switch (propIdx)\n    {\n    case CV_CAP_PROP_FRAME_WIDTH:\n        m_width = cvRound(propVal);\n        handled = true;\n        break;\ncase CV_CAP_PROP_FRAME_HEIGHT:\n    m_height = cvRound(propVal);\n    handled = true;\n    break;\n\ncase CV_CAP_PROP_FOURCC:\n    m_fourcc = (int)(unsigned long)(propVal);\n    if (-1 == m_fourcc)\n    {\n        // following cvCreateVideo usage will pop up caprturepindialog here if fourcc=-1\n        // TODO - how to create a capture pin dialog\n    }\n    handled = true;\n    break;\n\ncase CV_CAP_PROP_FPS:\n    int fps = cvRound(propVal);\n    if (fps != g_VI.getFPS(m_index))\n    {\n        g_VI.stopDevice(m_index);\n        g_VI.setIdealFramerate(m_index, fps);\n        if (m_widthSet > 0 && m_heightSet > 0)\n            g_VI.setupDevice(m_index, m_widthSet, m_heightSet);\n        else\n            g_VI.setupDevice(m_index);\n    }\n    return g_VI.isDeviceSetup(m_index);\n}\n\nif (handled)\n{\n    // a stream setting\n    if (m_width > 0 && m_height > 0)\n    {\n        if (m_width != g_VI.getWidth(m_index) || m_height != g_VI.getHeight(m_index) )//|| fourcc != VI.getFourcc(index) )\n        {\n            int fps = static_cast<int>(g_VI.getFPS(m_index));\n            g_VI.stopDevice(m_index);\n            g_VI.setIdealFramerate(m_index, fps);\n            g_VI.setupDeviceFourcc(m_index, m_width, m_height, m_fourcc);\n        }\n\n        bool success = g_VI.isDeviceSetup(m_index);\n        if (success)\n        {\n            m_widthSet = m_width;\n            m_heightSet = m_height;\n            m_width = m_height = m_fourcc = -1;\n        }\n        return success;\n    }\n    return true;\n}\n\n// show video/camera filter dialog\nif (propIdx == CV_CAP_PROP_SETTINGS )\n{\n    g_VI.showSettingsWindow(m_index);\n    return true;\n}\n\n//video Filter properties\nswitch (propIdx)\n{\ncase CV_CAP_PROP_BRIGHTNESS:\ncase CV_CAP_PROP_CONTRAST:\ncase CV_CAP_PROP_HUE:\ncase CV_CAP_PROP_SATURATION:\ncase CV_CAP_PROP_SHARPNESS:\ncase CV_CAP_PROP_GAMMA:\ncase CV_CAP_PROP_MONOCHROME:\ncase CV_CAP_PROP_WHITE_BALANCE_BLUE_U:\ncase CV_CAP_PROP_BACKLIGHT:\ncase CV_CAP_PROP_GAIN:\n    return g_VI.setVideoSettingFilter(m_index, g_VI.getVideoPropertyFromCV(propIdx), (long)propVal);\n}\n\n//camera properties\nswitch (propIdx)\n{\ncase CV_CAP_PROP_PAN:\ncase CV_CAP_PROP_TILT:\ncase CV_CAP_PROP_ROLL:\ncase CV_CAP_PROP_ZOOM:\ncase CV_CAP_PROP_EXPOSURE:\ncase CV_CAP_PROP_IRIS:\ncase CV_CAP_PROP_FOCUS:\n    return g_VI.setVideoSettingCamera(m_index, g_VI.getCameraPropertyFromCV(propIdx), (long)propVal);\n}\n\nreturn false;\n\n}\nbool VideoCapture_DShow::grabFrame()\n{\n    return true;\n}\nbool VideoCapture_DShow::retrieveFrame(int, OutputArray frame)\n{\n    frame.create(Size(g_VI.getWidth(m_index), g_VI.getHeight(m_index)), CV_8UC3);\n    cv::Mat mat = frame.getMat();\n    return g_VI.getPixels(m_index, mat.ptr(), false, true );\n}\nint VideoCapture_DShow::getCaptureDomain()\n{\n    return CV_CAP_DSHOW;\n}\nbool VideoCapture_DShow::isOpened() const\n{\n    return (-1 != m_index);\n}\nvoid VideoCapture_DShow::open(int index)\n{\n    close();\n    int devices = g_VI.listDevices(true);\n    if (0 == devices)\n        return;\n    if (index < 0 || index > devices-1)\n        return;\n    g_VI.setupDevice(index);\n    if (!g_VI.isDeviceSetup(index))\n        return;\n    m_index = index;\n}\nvoid VideoCapture_DShow::close()\n{\n    if (m_index >= 0)\n    {\n        g_VI.stopDevice(m_index);\n        m_index = -1;\n    }\n    m_widthSet = m_heightSet = m_width = m_height = -1;\n}\n}\n\nendif\n\n#\u5206\u304b\u3089\u306a\u3044\u3053\u3068\nstruct IBaseFilter;\u3068\u5ba3\u8a00\u3057\u3066\u3044\u308b\u304c\u3001\u3069\u3053\u304b\u3089\u6765\u3066\u3044\u308b\u3082\u306e\u306a\u306e\u304b\u3002\n\u3053\u308c\u304c\u4f55\u8005\u306a\u306e\u304b\u304c\u5206\u304b\u3089\u306a\u3044\u3002\n\n\n\n```\n/*M///////////////////////////////////////////////////////////////////////////////////////\n//\n//  IMPORTANT: READ BEFORE DOWNLOADING, COPYING, INSTALLING OR USING.\n//\n//  By downloading, copying, installing or using the software you agree to this license.\n//  If you do not agree to this license, do not download, install,\n//  copy or use the software.\n//\n//\n//                        Intel License Agreement\n//                For Open Source Computer Vision Library\n//\n// Copyright (C) 2000, Intel Corporation, all rights reserved.\n// Third party copyrights are property of their respective owners.\n//\n// Redistribution and use in source and binary forms, with or without modification,\n// are permitted provided that the following conditions are met:\n//\n//   * Redistribution's of source code must retain the above copyright notice,\n//     this list of conditions and the following disclaimer.\n//\n//   * Redistribution's in binary form must reproduce the above copyright notice,\n//     this list of conditions and the following disclaimer in the documentation\n//     and/or other materials provided with the distribution.\n//\n//   * The name of Intel Corporation may not be used to endorse or promote products\n//     derived from this software without specific prior written permission.\n//\n// This software is provided by the copyright holders and contributors \"as is\" and\n// any express or implied warranties, including, but not limited to, the implied\n// warranties of merchantability and fitness for a particular purpose are disclaimed.\n// In no event shall the Intel Corporation or contributors be liable for any direct,\n// indirect, incidental, special, exemplary, or consequential damages\n// (including, but not limited to, procurement of substitute goods or services;\n// loss of use, data, or profits; or business interruption) however caused\n// and on any theory of liability, whether in contract, strict liability,\n// or tort (including negligence or otherwise) arising in any way out of\n// the use of this software, even if advised of the possibility of such damage.\n//\n//M*/\n\n#include \"precomp.hpp\"\n\n#if (defined WIN32 || defined _WIN32) && defined HAVE_DSHOW\n#include \"cap_dshow.hpp\"\n\n/*\n   DirectShow-based Video Capturing module is based on\n   videoInput library by Theodore Watson:\n   http://muonics.net/school/spring05/videoInput/\n\n   Below is the original copyright\n*/\n```\nVideo Capturing module\u306f\u3001videoInput library\u306b\u57fa\u3065\u3044\u3066\u3044\u308b\u3068\u8a00\u3063\u3066\u3044\u308b\u3002\n\n```\n\n//THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n//IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n//FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n//AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n//LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n//OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n//THE SOFTWARE.\n\n//////////////////////////////////////////////////////////\n//Written by Theodore Watson - theo.watson@gmail.com    //\n//Do whatever you want with this code but if you find   //\n//a bug or make an improvement I would love to know!    //\n//                                                      //\n//Warning This code is experimental                     //\n//use at your own risk :)                               //\n//////////////////////////////////////////////////////////\n/////////////////////////////////////////////////////////\n/*                     Shoutouts\n\nThanks to:\n\n           Dillip Kumar Kara for crossbar code.\n           Zachary Lieberman for getting me into this stuff\n           and for being so generous with time and code.\n           The guys at Potion Design for helping me with VC++\n           Josh Fisher for being a serious C++ nerd :)\n           Golan Levin for helping me debug the strangest\n           and slowest bug in the world!\n\n           And all the people using this library who send in\n           bugs, suggestions and improvements who keep me working on\n           the next version - yeah thanks a lot ;)\n\n*/\n/////////////////////////////////////////////////////////\n\n#if defined _MSC_VER && _MSC_VER >= 100\n//'sprintf': name was marked as #pragma deprecated\n#pragma warning(disable: 4995)\n#endif\n\n#ifdef __MINGW32__\n// MinGW does not understand COM interfaces\n#pragma GCC diagnostic ignored \"-Wnon-virtual-dtor\"\n#endif\n\n#include <tchar.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <math.h>\n#include <string.h>\n#include <wchar.h>\n\n#include <vector>\n\n//Include Directshow stuff here so we don't worry about needing all the h files.\n#if defined _MSC_VER && _MSC_VER >= 1500\n#  include \"DShow.h\"\n#  include \"strmif.h\"\n#  include \"Aviriff.h\"\n#  include \"dvdmedia.h\"\n#  include \"bdaiface.h\"\n#else\n#  ifdef _MSC_VER\n#  define __extension__\n   typedef BOOL WINBOOL;\n#endif\n\n#include \"dshow/dshow.h\"\n#include \"dshow/dvdmedia.h\"\n#include \"dshow/bdatypes.h\"\n\ninterface IEnumPIDMap : public IUnknown\n{\npublic:\n    virtual HRESULT STDMETHODCALLTYPE Next(\n        /* [in] */ ULONG cRequest,\n        /* [size_is][out][in] */ PID_MAP *pPIDMap,\n        /* [out] */ ULONG *pcReceived) = 0;\n\n    virtual HRESULT STDMETHODCALLTYPE Skip(\n        /* [in] */ ULONG cRecords) = 0;\n\n    virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;\n\n    virtual HRESULT STDMETHODCALLTYPE Clone(\n        /* [out] */ IEnumPIDMap **ppIEnumPIDMap) = 0;\n};\n```\n\u3053\u3053\u3067\u3001interface\u3068\u3044\u3046\u306e\u306fstruct\u3068define\u3055\u308c\u3066\u3044\u308b\u3089\u3057\u3044\u3002\n\u5b9a\u7fa9\u3055\u308c\u3066\u3044\u308b\u5834\u6240\u3092\u5f8c\u3067\u3061\u3083\u3093\u3068\u898b\u3064\u3051\u308b\u3002\n\n```\n\n\ninterface IMPEG2PIDMap : public IUnknown\n{\n    virtual HRESULT STDMETHODCALLTYPE MapPID(\n        /* [in] */ ULONG culPID,\n        /* [in] */ ULONG *pulPID,\n        /* [in] */ MEDIA_SAMPLE_CONTENT MediaSampleContent) = 0;\n\n    virtual HRESULT STDMETHODCALLTYPE UnmapPID(\n        /* [in] */ ULONG culPID,\n        /* [in] */ ULONG *pulPID) = 0;\n\n    virtual HRESULT STDMETHODCALLTYPE EnumPIDMap(\n        /* [out] */ IEnumPIDMap **pIEnumPIDMap) = 0;\n};\n\n#endif\n\n//for threading\n#include <process.h>\n\n//this is for TryEnterCriticalSection\n#ifndef _WIN32_WINNT\n#define _WIN32_WINNT 0x400\n#endif\n\n\n/*\nMEDIASUBTYPE_I420 : TGUID ='{30323449-0000-0010-8000-00AA00389B71}';\nMEDIASUBTYPE_Y800 : TGUID ='{30303859-0000-0010-8000-00AA00389B71}';\nMEDIASUBTYPE_Y8   : TGUID ='{20203859-0000-0010-8000-00AA00389B71}';\nMEDIASUBTYPE_Y160 : TGUID ='{30363159-0000-0010-8000-00AA00389B71}';\nMEDIASUBTYPE_YV16 : TGUID ='{32315659-0000-0010-8000-00AA00389B71}';\nMEDIASUBTYPE_Y422 : TGUID ='{32323459-0000-0010-8000-00AA00389B71}';\nMEDIASUBTYPE_GREY : TGUID ='{59455247-0000-0010-8000-00AA00389B71}';\n*/\n\n#include <initguid.h>\n\nDEFINE_GUID(MEDIASUBTYPE_GREY, 0x59455247, 0x0000, 0x0010, 0x80, 0x00,\n    0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71);\nDEFINE_GUID(MEDIASUBTYPE_Y8, 0x20203859, 0x0000, 0x0010, 0x80, 0x00,\n    0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71);\nDEFINE_GUID(MEDIASUBTYPE_Y800, 0x30303859, 0x0000, 0x0010, 0x80, 0x00,\n    0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71);\n\nDEFINE_GUID(CLSID_CaptureGraphBuilder2,0xbf87b6e1,0x8c27,0x11d0,0xb3,0xf0,0x00,0xaa,0x00,0x37,0x61,0xc5);\nDEFINE_GUID(CLSID_FilterGraph,0xe436ebb3,0x524f,0x11ce,0x9f,0x53,0x00,0x20,0xaf,0x0b,0xa7,0x70);\nDEFINE_GUID(CLSID_NullRenderer,0xc1f400a4,0x3f08,0x11d3,0x9f,0x0b,0x00,0x60,0x08,0x03,0x9e,0x37);\nDEFINE_GUID(CLSID_SampleGrabber,0xc1f400a0,0x3f08,0x11d3,0x9f,0x0b,0x00,0x60,0x08,0x03,0x9e,0x37);\nDEFINE_GUID(CLSID_SystemDeviceEnum,0x62be5d10,0x60eb,0x11d0,0xbd,0x3b,0x00,0xa0,0xc9,0x11,0xce,0x86);\nDEFINE_GUID(CLSID_VideoInputDeviceCategory,0x860bb310,0x5d01,0x11d0,0xbd,0x3b,0x00,0xa0,0xc9,0x11,0xce,0x86);\nDEFINE_GUID(FORMAT_VideoInfo,0x05589f80,0xc356,0x11ce,0xbf,0x01,0x00,0xaa,0x00,0x55,0x59,0x5a);\nDEFINE_GUID(IID_IAMAnalogVideoDecoder,0xc6e13350,0x30ac,0x11d0,0xa1,0x8c,0x00,0xa0,0xc9,0x11,0x89,0x56);\nDEFINE_GUID(IID_IAMCameraControl,0xc6e13370,0x30ac,0x11d0,0xa1,0x8c,0x00,0xa0,0xc9,0x11,0x89,0x56);\nDEFINE_GUID(IID_IAMCrossbar,0xc6e13380,0x30ac,0x11d0,0xa1,0x8c,0x00,0xa0,0xc9,0x11,0x89,0x56);\nDEFINE_GUID(IID_IAMStreamConfig,0xc6e13340,0x30ac,0x11d0,0xa1,0x8c,0x00,0xa0,0xc9,0x11,0x89,0x56);\nDEFINE_GUID(IID_IAMVideoProcAmp,0xc6e13360,0x30ac,0x11d0,0xa1,0x8c,0x00,0xa0,0xc9,0x11,0x89,0x56);\nDEFINE_GUID(IID_IBaseFilter,0x56a86895,0x0ad4,0x11ce,0xb0,0x3a,0x00,0x20,0xaf,0x0b,0xa7,0x70);\nDEFINE_GUID(IID_ICaptureGraphBuilder2,0x93e5a4e0,0x2d50,0x11d2,0xab,0xfa,0x00,0xa0,0xc9,0xc6,0xe3,0x8d);\nDEFINE_GUID(IID_ICreateDevEnum,0x29840822,0x5b84,0x11d0,0xbd,0x3b,0x00,0xa0,0xc9,0x11,0xce,0x86);\nDEFINE_GUID(IID_IGraphBuilder,0x56a868a9,0x0ad4,0x11ce,0xb0,0x3a,0x00,0x20,0xaf,0x0b,0xa7,0x70);\nDEFINE_GUID(IID_IMPEG2PIDMap,0xafb6c2a1,0x2c41,0x11d3,0x8a,0x60,0x00,0x00,0xf8,0x1e,0x0e,0x4a);\nDEFINE_GUID(IID_IMediaControl,0x56a868b1,0x0ad4,0x11ce,0xb0,0x3a,0x00,0x20,0xaf,0x0b,0xa7,0x70);\nDEFINE_GUID(IID_IMediaFilter,0x56a86899,0x0ad4,0x11ce,0xb0,0x3a,0x00,0x20,0xaf,0x0b,0xa7,0x70);\nDEFINE_GUID(IID_ISampleGrabber,0x6b652fff,0x11fe,0x4fce,0x92,0xad,0x02,0x66,0xb5,0xd7,0xc7,0x8f);\nDEFINE_GUID(LOOK_UPSTREAM_ONLY,0xac798be0,0x98e3,0x11d1,0xb3,0xf1,0x00,0xaa,0x00,0x37,0x61,0xc5);\nDEFINE_GUID(MEDIASUBTYPE_AYUV,0x56555941,0x0000,0x0010,0x80,0x00,0x00,0xaa,0x00,0x38,0x9b,0x71);\nDEFINE_GUID(MEDIASUBTYPE_IYUV,0x56555949,0x0000,0x0010,0x80,0x00,0x00,0xaa,0x00,0x38,0x9b,0x71);\nDEFINE_GUID(MEDIASUBTYPE_RGB24,0xe436eb7d,0x524f,0x11ce,0x9f,0x53,0x00,0x20,0xaf,0x0b,0xa7,0x70);\nDEFINE_GUID(MEDIASUBTYPE_RGB32,0xe436eb7e,0x524f,0x11ce,0x9f,0x53,0x00,0x20,0xaf,0x0b,0xa7,0x70);\nDEFINE_GUID(MEDIASUBTYPE_RGB555,0xe436eb7c,0x524f,0x11ce,0x9f,0x53,0x00,0x20,0xaf,0x0b,0xa7,0x70);\nDEFINE_GUID(MEDIASUBTYPE_RGB565,0xe436eb7b,0x524f,0x11ce,0x9f,0x53,0x00,0x20,0xaf,0x0b,0xa7,0x70);\nDEFINE_GUID(MEDIASUBTYPE_I420,0x30323449,0x0000,0x0010,0x80,0x00,0x00,0xaa,0x00,0x38,0x9b,0x71);\nDEFINE_GUID(MEDIASUBTYPE_UYVY,0x59565955,0x0000,0x0010,0x80,0x00,0x00,0xaa,0x00,0x38,0x9b,0x71);\nDEFINE_GUID(MEDIASUBTYPE_Y211,0x31313259,0x0000,0x0010,0x80,0x00,0x00,0xaa,0x00,0x38,0x9b,0x71);\nDEFINE_GUID(MEDIASUBTYPE_Y411,0x31313459,0x0000,0x0010,0x80,0x00,0x00,0xaa,0x00,0x38,0x9b,0x71);\nDEFINE_GUID(MEDIASUBTYPE_Y41P,0x50313459,0x0000,0x0010,0x80,0x00,0x00,0xaa,0x00,0x38,0x9b,0x71);\nDEFINE_GUID(MEDIASUBTYPE_YUY2,0x32595559,0x0000,0x0010,0x80,0x00,0x00,0xaa,0x00,0x38,0x9b,0x71);\nDEFINE_GUID(MEDIASUBTYPE_YUYV,0x56595559,0x0000,0x0010,0x80,0x00,0x00,0xaa,0x00,0x38,0x9b,0x71);\nDEFINE_GUID(MEDIASUBTYPE_YV12,0x32315659,0x0000,0x0010,0x80,0x00,0x00,0xaa,0x00,0x38,0x9b,0x71);\nDEFINE_GUID(MEDIASUBTYPE_YVU9,0x39555659,0x0000,0x0010,0x80,0x00,0x00,0xaa,0x00,0x38,0x9b,0x71);\nDEFINE_GUID(MEDIASUBTYPE_YVYU,0x55595659,0x0000,0x0010,0x80,0x00,0x00,0xaa,0x00,0x38,0x9b,0x71);\nDEFINE_GUID(MEDIASUBTYPE_MJPG,0x47504A4D, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71); // MGB\nDEFINE_GUID(MEDIATYPE_Interleaved,0x73766169,0x0000,0x0010,0x80,0x00,0x00,0xaa,0x00,0x38,0x9b,0x71);\nDEFINE_GUID(MEDIATYPE_Video,0x73646976,0x0000,0x0010,0x80,0x00,0x00,0xaa,0x00,0x38,0x9b,0x71);\nDEFINE_GUID(PIN_CATEGORY_CAPTURE,0xfb6c4281,0x0353,0x11d1,0x90,0x5f,0x00,0x00,0xc0,0xcc,0x16,0xba);\nDEFINE_GUID(PIN_CATEGORY_PREVIEW,0xfb6c4282,0x0353,0x11d1,0x90,0x5f,0x00,0x00,0xc0,0xcc,0x16,0xba);\n\ninterface ISampleGrabberCB : public IUnknown\n{\n    virtual HRESULT STDMETHODCALLTYPE SampleCB(\n        double SampleTime,\n        IMediaSample *pSample) = 0;\n\n    virtual HRESULT STDMETHODCALLTYPE BufferCB(\n        double SampleTime,\n        BYTE *pBuffer,\n        LONG BufferLen) = 0;\n};\n```\nISampleGrabberCB \u30a4\u30f3\u30bf\u30fc\u30d5\u30a7\u30a4\u30b9\u306f\u3001ISampleGrabber::SetCallback \u30e1\u30bd\u30c3\u30c9\u306b\u5bfe\u5fdc\u3059\u308b\u30b3\u30fc\u30eb\u30d0\u30c3\u30af \u30e1\u30bd\u30c3\u30c9\u3092\u63d0\u4f9b\u3059\u308b\u3002\u3053\u306e\u30e1\u30bd\u30c3\u30c9\u3092\u547c\u3073\u51fa\u3059\u30a2\u30d7\u30ea\u30b1\u30fc\u30b7\u30e7\u30f3\u3067\u306f\u3001\u3053\u306e\u30a4\u30f3\u30bf\u30fc\u30d5\u30a7\u30a4\u30b9\u3092\u5b9f\u88c5\u3059\u308b\u5fc5\u8981\u304c\u3042\u308b\u3002\u8a73\u7d30\u306b\u3064\u3044\u3066\u306f\u3001\uff62ISampleGrabber\uff63\u3092\u53c2\u7167\u3059\u308b\u3053\u3068\u3002\nIUnknown \u304b\u3089\u7d99\u627f\u3057\u305f\u30e1\u30bd\u30c3\u30c9\u306b\u52a0\u3048\u3066\u3001ISampleGrabber \u30a4\u30f3\u30bf\u30fc\u30d5\u30a7\u30a4\u30b9\u306f\u6b21\u306e\u30e1\u30bd\u30c3\u30c9\u3092\u516c\u958b\u3059\u308b\u3002\n\n| \u30e1\u30bd\u30c3\u30c9           |\u8aac\u660e                                                                    |\n|:-----------------|:------------------------------------------------------------------------|\n| BufferCB          | \u30b5\u30f3\u30d7\u30eb\u30d0\u30c3\u30d5\u30a1\u3078\u306e\u30dd\u30a4\u30f3\u30bf\u3092\u53d7\u3051\u53d6\u308b\u30b3\u30fc\u30eb\u30d0\u30c3\u30af\u30e1\u30bd\u30c3\u30c9\u3002                 |\n| SampleCB          | \u30e1\u30c7\u30a3\u30a2\u30b5\u30f3\u30d7\u30eb\u3078\u306e\u30dd\u30a4\u30f3\u30bf\u3092\u53d7\u3051\u53d6\u308b\u30b3\u30fc\u30eb\u30d0\u30c3\u30af\u30e1\u30bd\u30c3\u30c9\u3002                 |\n\n```\ninterface ISampleGrabber : public IUnknown\n{\n    virtual HRESULT STDMETHODCALLTYPE SetOneShot(\n        BOOL OneShot) = 0;\n\n    virtual HRESULT STDMETHODCALLTYPE SetMediaType(\n        const AM_MEDIA_TYPE *pType) = 0;\n\n    virtual HRESULT STDMETHODCALLTYPE GetConnectedMediaType(\n        AM_MEDIA_TYPE *pType) = 0;\n\n    virtual HRESULT STDMETHODCALLTYPE SetBufferSamples(\n        BOOL BufferThem) = 0;\n\n    virtual HRESULT STDMETHODCALLTYPE GetCurrentBuffer(\n        LONG *pBufferSize,\n        LONG *pBuffer) = 0;\n\n    virtual HRESULT STDMETHODCALLTYPE GetCurrentSample(\n        IMediaSample **ppSample) = 0;\n\n    virtual HRESULT STDMETHODCALLTYPE SetCallback(\n        ISampleGrabberCB *pCallback,\n        LONG WhichMethodToCallback) = 0;\n};\n\n```\nISampleGrabber \u30a4\u30f3\u30bf\u30fc\u30d5\u30a7\u30a4\u30b9\u306f\u3001\u30b5\u30f3\u30d7\u30eb \u30b0\u30e9\u30d0 \u30d5\u30a3\u30eb\u30bf\u306b\u3088\u3063\u3066\u516c\u958b\u3055\u308c\u308b\u3002\u30a2\u30d7\u30ea\u30b1\u30fc\u30b7\u30e7\u30f3\u306f\u3001\u3053\u306e\u30a4\u30f3\u30bf\u30fc\u30d5\u30a7\u30a4\u30b9\u3092\u4f7f\u3063\u3066\u3001\u30d5\u30a3\u30eb\u30bf \u30b0\u30e9\u30d5\u5185\u3092\u901a\u308b\u500b\u3005\u306e\u30e1\u30c7\u30a3\u30a2 \u30b5\u30f3\u30d7\u30eb\u3092\u53d6\u5f97\u3067\u304d\u308b\u3002\nIUnknown \u304b\u3089\u7d99\u627f\u3057\u305f\u30e1\u30bd\u30c3\u30c9\u306b\u52a0\u3048\u3066\u3001ISampleGrabber \u30a4\u30f3\u30bf\u30fc\u30d5\u30a7\u30a4\u30b9\u306f\u6b21\u306e\u30e1\u30bd\u30c3\u30c9\u3092\u516c\u958b\u3059\u308b\u3002\n\n| \u30e1\u30bd\u30c3\u30c9           |\u8aac\u660e                                                                                            |\n|:-------------------|:--------------------------------------------------------------------------------------------|\n| SetOneShot          | \u30b5\u30f3\u30d7\u30eb\u3092 1 \u3064\u53d7\u3051\u53d6\u3063\u305f\u3089\u30d5\u30a3\u30eb\u30bf\u304c\u30b0\u30e9\u30d5\u3092\u505c\u6b62\u3059\u3079\u304d\u304b\u3069\u3046\u304b\u3092\u6307\u5b9a\u3059\u308b\u3002                        |\n| SetMediaType        | \u30b5\u30f3\u30d7\u30eb \u30b0\u30e9\u30d0\u306e\u5165\u529b\u30d4\u30f3\u4e0a\u306e\u63a5\u7d9a\u306b\u4f7f\u3046\u30e1\u30c7\u30a3\u30a2 \u30bf\u30a4\u30d7\u3092\u6307\u5b9a\u3059\u308b\u3002                                 |\n|GetConnectedMediaType|\t\u30b5\u30f3\u30d7\u30eb \u30b0\u30e9\u30d0\u306e\u5165\u529b\u30d4\u30f3\u4e0a\u306e\u63a5\u7d9a\u306b\u4f7f\u3046\u30e1\u30c7\u30a3\u30a2 \u30bf\u30a4\u30d7\u3092\u53d6\u5f97\u3059\u308b\u3002                                 |\n|SetBufferSamples     |\t\u30d5\u30a3\u30eb\u30bf\u5185\u3092\u901a\u308b\u30b5\u30f3\u30d7\u30eb\u3092\u30d0\u30c3\u30d5\u30a1\u306b\u30b3\u30d4\u30fc\u3059\u308b\u304b\u3069\u3046\u304b\u3092\u6307\u5b9a\u3059\u308b\u3002                                 |\n|GetCurrentBuffer     |\t\u30d5\u30a3\u30eb\u30bf\u304c\u53d7\u3051\u53d6\u3063\u305f\u6700\u65b0\u30b5\u30f3\u30d7\u30eb\u306e\u30b3\u30d4\u30fc\u3092\u53d6\u5f97\u3059\u308b\u3002                                              |\n|GetCurrentSample     |\u73fe\u5728\u306f\u5b9f\u88c5\u3055\u308c\u3066\u3044\u306a\u3044\u3002                                                                        |\n|SetCallback\t      |\u30b5\u30f3\u30d7\u30eb\u5230\u7740\u6642\u306b\u547c\u3073\u51fa\u3059\u30b3\u30fc\u30eb\u30d0\u30c3\u30af \u30e1\u30bd\u30c3\u30c9\u3092\u6307\u5b9a\u3059\u308b\u3002                                          |\n\n```\n\n#ifndef HEADER\n#define HEADER(p) (&(((VIDEOINFOHEADER*)(p))->bmiHeader))\n#endif\n\n//Example Usage\n/*\n    //create a videoInput object\n    videoInput VI;\n\n    //Prints out a list of available devices and returns num of devices found\n    int numDevices = VI.listDevices();\n\n    int device1 = 0;  //this could be any deviceID that shows up in listDevices\n    int device2 = 1;  //this could be any deviceID that shows up in listDevices\n\n    //if you want to capture at a different frame rate (default is 30)\n    //specify it here, you are not guaranteed to get this fps though.\n    //VI.setIdealFramerate(dev, 60);\n\n    //setup the first device - there are a number of options:\n\n    VI.setupDevice(device1);                           //setup the first device with the default settings\n    //VI.setupDevice(device1, VI_COMPOSITE);           //or setup device with specific connection type\n    //VI.setupDevice(device1, 320, 240);               //or setup device with specified video size\n    //VI.setupDevice(device1, 320, 240, VI_COMPOSITE); //or setup device with video size and connection type\n\n    //VI.setFormat(device1, VI_NTSC_M);                //if your card doesn't remember what format it should be\n                                                       //call this with the appropriate format listed above\n                                                       //NOTE: must be called after setupDevice!\n\n    //optionally setup a second (or third, fourth ...) device - same options as above\n    VI.setupDevice(device2);\n\n    //As requested width and height can not always be accomodated\n    //make sure to check the size once the device is setup\n\n    int width   = VI.getWidth(device1);\n    int height  = VI.getHeight(device1);\n    int size    = VI.getSize(device1);\n\n    unsigned char * yourBuffer1 = new unsigned char[size];\n    unsigned char * yourBuffer2 = new unsigned char[size];\n\n    //to get the data from the device first check if the data is new\n    if(VI.isFrameNew(device1)){\n        VI.getPixels(device1, yourBuffer1, false, false);   //fills pixels as a BGR (for openCV) unsigned char array - no flipping\n        VI.getPixels(device1, yourBuffer2, true, true);     //fills pixels as a RGB (for openGL) unsigned char array - flipping!\n    }\n\n    //same applies to device2 etc\n\n    //to get a settings dialog for the device\n    VI.showSettingsWindow(device1);\n\n\n    //Shut down devices properly\n    VI.stopDevice(device1);\n    VI.stopDevice(device2);\n*/\n\n\n//////////////////////////////////////   VARS AND DEFS   //////////////////////////////////\n\n\n//STUFF YOU CAN CHANGE\n\n#ifdef _DEBUG\n#include <strsafe.h>\n\n//change for verbose debug info\nstatic bool gs_verbose = true;\n\nstatic void DebugPrintOut(const char *format, ...)\n{\n    if (gs_verbose)\n    {\n        va_list args;\n        va_start(args, format);\n        if( ::IsDebuggerPresent() )\n        {\n            CHAR szMsg[512];\n            ::StringCbVPrintfA(szMsg, sizeof(szMsg), format, args);\n            ::OutputDebugStringA(szMsg);\n        }\n        else\n        {\n            vprintf(format, args);\n        }\n        va_end (args);\n    }\n}\n#else\n#define DebugPrintOut(...) void()\n#endif\n\n//if you need VI to use multi threaded com\n//#define VI_COM_MULTI_THREADED\n\n//STUFF YOU DON'T CHANGE\n\n//videoInput defines\n#define VI_VERSION      0.1995\n#define VI_MAX_CAMERAS  20\n#define VI_NUM_TYPES    20 //MGB\n#define VI_NUM_FORMATS  18 //DON'T TOUCH\n\n//defines for setPhyCon - tuner is not as well supported as composite and s-video\n#define VI_COMPOSITE 0\n#define VI_S_VIDEO   1\n#define VI_TUNER     2\n#define VI_USB       3\n#define VI_1394      4\n\n//defines for formats\n#define VI_NTSC_M   0\n#define VI_PAL_B    1\n#define VI_PAL_D    2\n#define VI_PAL_G    3\n#define VI_PAL_H    4\n#define VI_PAL_I    5\n#define VI_PAL_M    6\n#define VI_PAL_N    7\n#define VI_PAL_NC   8\n#define VI_SECAM_B  9\n#define VI_SECAM_D  10\n#define VI_SECAM_G  11\n#define VI_SECAM_H  12\n#define VI_SECAM_K  13\n#define VI_SECAM_K1 14\n#define VI_SECAM_L  15\n#define VI_NTSC_M_J 16\n#define VI_NTSC_433 17\n\n\n//allows us to directShow classes here with the includes in the cpp\nstruct ICaptureGraphBuilder2;\nstruct IGraphBuilder;\nstruct IBaseFilter;\n```\n\u300ccpp\u306e\u4e2d\u306e\u30a4\u30f3\u30af\u30eb\u30fc\u30c9\u30d5\u30a1\u30a4\u30eb\u306b\u3088\u3063\u3066\u3053\u3053\u306b\u3042\u308bdirectshow classes\u304c\u4f7f\u3048\u308b\u3088\u3046\u306b\u306a\u308b\u300d\n\n\n```\n\nstruct IAMCrossbar;\nstruct IMediaControl;\nstruct ISampleGrabber;\nstruct IMediaEventEx;\nstruct IAMStreamConfig;\nstruct _AMMediaType;\nclass SampleGrabberCallback;\ntypedef _AMMediaType AM_MEDIA_TYPE;\n\n//keeps track of how many instances of VI are being used\n//don't touch\n//static int comInitCount = 0;\n\n\n////////////////////////////////////////   VIDEO DEVICE   ///////////////////////////////////\n\nclass videoDevice{\n\n\n    public:\n\n        videoDevice();\n        void setSize(int w, int h);\n        void NukeDownstream(IBaseFilter *pBF);\n```\nIBaseFilter\u3068\u3044\u3046\u578b\u306f\u305d\u3082\u305d\u3082\u4f55\u306a\u306e\u304b\uff1f\n\u3053\u306eIBaseFilter *pBF\u3068\u3044\u3046\u306e\u306b\u6ce8\u76ee\u3057\u3066\u3069\u3053\u304b\u3089\u6765\u308b\u306e\u304b\u3092\u78ba\u304b\u3081\u308b\u3002\n\n```\n        void destroyGraph();\n        ~videoDevice();\n\n        int videoSize;\n        int width;\n        int height;\n\n        int tryWidth;\n        int tryHeight;\n        GUID tryVideoType;\n\n        ICaptureGraphBuilder2 *pCaptureGraph;    // Capture graph builder object\n        IGraphBuilder *pGraph;                    // Graph builder object\n        IMediaControl *pControl;                // Media control object\n        IBaseFilter *pVideoInputFilter;          // Video Capture filter\n\n```\n\u3053\u306eVideo Capture filter\u3082\u3069\u3053\u306b\u884c\u3063\u3066\u3044\u308b\u306e\u304b\u8ffd\u8de1\u3059\u308b\u3002\n\n```\n\n\n        IBaseFilter *pGrabberF;\n        IBaseFilter * pDestFilter;\n        IAMStreamConfig *streamConf;\n        ISampleGrabber * pGrabber;                // Grabs frame\n        AM_MEDIA_TYPE * pAmMediaType;\n\n        IMediaEventEx * pMediaEvent;\n\n        GUID videoType;\n        long formatType;\n\n        SampleGrabberCallback * sgCallback;\n\n        bool tryDiffSize;\n        bool useCrossbar;\n        bool readyToCapture;\n        bool sizeSet;\n        bool setupStarted;\n        bool specificFormat;\n        bool autoReconnect;\n        int  nFramesForReconnect;\n        unsigned long nFramesRunning;\n        int  connection;\n        int  storeConn;\n        int  myID;\n        long requestedFrameTime; //ie fps\n\n        char  nDeviceName[255];\n        WCHAR wDeviceName[255];\n\n        unsigned char * pixels;\n        char * pBuffer;\n\n};\n\n//////////////////////////////////////   VIDEO INPUT   /////////////////////////////////////\nclass videoInput{\n\n    public:\n        videoInput();\n        ~videoInput();\n\n        //turns off console messages - default is to print messages\n        static void setVerbose(bool _verbose);\n\n        //Functions in rough order they should be used.\n        static int listDevices(bool silent = false);\n\n        //needs to be called after listDevices - otherwise returns NULL\n        static char * getDeviceName(int deviceID);\n\n        //choose to use callback based capture - or single threaded\n        void setUseCallback(bool useCallback);\n\n        //call before setupDevice\n        //directshow will try and get the closest possible framerate to what is requested\n        void setIdealFramerate(int deviceID, int idealFramerate);\n\n        //some devices will stop delivering frames after a while - this method gives you the option to try and reconnect\n        //to a device if videoInput detects that a device has stopped delivering frames.\n        //you MUST CALL isFrameNew every app loop for this to have any effect\n        void setAutoReconnectOnFreeze(int deviceNumber, bool doReconnect, int numMissedFramesBeforeReconnect);\n\n        //Choose one of these five to setup your device\n        bool setupDevice(int deviceID);\n        bool setupDevice(int deviceID, int w, int h);\n        bool setupDeviceFourcc(int deviceID, int w, int h,int fourcc);\n\n        //These two are only for capture cards\n        //USB and Firewire cameras souldn't specify connection\n        bool setupDevice(int deviceID, int connection);\n        bool setupDevice(int deviceID, int w, int h, int connection);\n\n        bool setFourcc(int deviceNumber, int fourcc);\n\n        //If you need to you can set your NTSC/PAL/SECAM\n        //preference here. if it is available it will be used.\n        //see #defines above for available formats - eg VI_NTSC_M or VI_PAL_B\n        //should be called after setupDevice\n        //can be called multiple times\n        bool setFormat(int deviceNumber, int format);\n\n        //Tells you when a new frame has arrived - you should call this if you have specified setAutoReconnectOnFreeze to true\n        bool isFrameNew(int deviceID);\n\n        bool isDeviceSetup(int deviceID) const;\n\n        //Returns the pixels - flipRedAndBlue toggles RGB/BGR flipping - and you can flip the image too\n        unsigned char * getPixels(int deviceID, bool flipRedAndBlue = true, bool flipImage = false);\n\n        //Or pass in a buffer for getPixels to fill returns true if successful.\n        bool getPixels(int id, unsigned char * pixels, bool flipRedAndBlue = true, bool flipImage = false);\n\n        //Launches a pop up settings window\n        //For some reason in GLUT you have to call it twice each time.\n        void showSettingsWindow(int deviceID);\n\n        //Manual control over settings thanks.....\n        //These are experimental for now.\n        bool setVideoSettingFilter(int deviceID, long Property, long lValue, long Flags = 0, bool useDefaultValue = false);\n        bool setVideoSettingFilterPct(int deviceID, long Property, float pctValue, long Flags = 0);\n        bool getVideoSettingFilter(int deviceID, long Property, long &min, long &max, long &SteppingDelta, long &currentValue, long &flags, long &defaultValue);\n\n        bool setVideoSettingCamera(int deviceID, long Property, long lValue, long Flags = 0, bool useDefaultValue = false);\n        bool setVideoSettingCameraPct(int deviceID, long Property, float pctValue, long Flags = 0);\n        bool getVideoSettingCamera(int deviceID, long Property, long &min, long &max, long &SteppingDelta, long &currentValue, long &flags, long &defaultValue);\n\n        //bool setVideoSettingCam(int deviceID, long Property, long lValue, long Flags = NULL, bool useDefaultValue = false);\n\n        //get width, height and number of pixels\n        int  getWidth(int deviceID) const;\n        int  getHeight(int deviceID) const;\n        int  getSize(int deviceID) const;\n        int  getFourcc(int deviceID) const;\n        double getFPS(int deviceID) const;\n\n        //completely stops and frees a device\n        void stopDevice(int deviceID);\n\n        //as above but then sets it up with same settings\n        bool restartDevice(int deviceID);\n\n        //number of devices available\n        int  devicesFound;\n\n        // mapping from OpenCV CV_CAP_PROP to videoinput/dshow properties\n        int getVideoPropertyFromCV(int cv_property);\n        int getCameraPropertyFromCV(int cv_property);\n\n    private:\n        void setPhyCon(int deviceID, int conn);\n        void setAttemptCaptureSize(int deviceID, int w, int h,GUID mediaType=MEDIASUBTYPE_RGB24);\n        bool setup(int deviceID);\n        void processPixels(unsigned char * src, unsigned char * dst, int width, int height, bool bRGB, bool bFlip);\n        int  start(int deviceID, videoDevice * VD);\n        int  getDeviceCount();\n        void getMediaSubtypeAsString(GUID type, char * typeAsString);\n        GUID *getMediaSubtypeFromFourcc(int fourcc);\n        int   getFourccFromMediaSubtype(GUID type) const;\n\n        void getVideoPropertyAsString(int prop, char * propertyAsString);\n        void getCameraPropertyAsString(int prop, char * propertyAsString);\n\n        HRESULT getDevice(IBaseFilter **pSrcFilter, int deviceID, WCHAR * wDeviceName, char * nDeviceName);\n        static HRESULT ShowFilterPropertyPages(IBaseFilter *pFilter);\n        static HRESULT ShowStreamPropertyPages(IAMStreamConfig  *pStream);\n\n        HRESULT SaveGraphFile(IGraphBuilder *pGraph, WCHAR *wszPath);\n        HRESULT routeCrossbar(ICaptureGraphBuilder2 **ppBuild, IBaseFilter **pVidInFilter, int conType, GUID captureMode);\n\n        //don't touch\n        static bool comInit();\n        static bool comUnInit();\n\n        int  connection;\n        int  callbackSetCount;\n        bool bCallback;\n\n        GUID CAPTURE_MODE;\n\n        //Extra video subtypes\n        GUID MEDIASUBTYPE_Y800;\n        GUID MEDIASUBTYPE_Y8;\n        GUID MEDIASUBTYPE_GREY;\n\n        videoDevice * VDList[VI_MAX_CAMERAS];\n        GUID mediaSubtypes[VI_NUM_TYPES];\n        long formatTypes[VI_NUM_FORMATS];\n\n        static void __cdecl basicThread(void * objPtr);\n\n        static char deviceNames[VI_MAX_CAMERAS][255];\n\n};\n\n///////////////////////////  HANDY FUNCTIONS  /////////////////////////////\n\nstatic void MyFreeMediaType(AM_MEDIA_TYPE& mt){\n    if (mt.cbFormat != 0)\n    {\n        CoTaskMemFree((PVOID)mt.pbFormat);\n        mt.cbFormat = 0;\n        mt.pbFormat = NULL;\n    }\n    if (mt.pUnk != NULL)\n    {\n        // Unecessary because pUnk should not be used, but safest.\n        mt.pUnk->Release();\n        mt.pUnk = NULL;\n    }\n}\n\nstatic void MyDeleteMediaType(AM_MEDIA_TYPE *pmt)\n{\n    if (pmt != NULL)\n    {\n        MyFreeMediaType(*pmt);\n        CoTaskMemFree(pmt);\n    }\n}\n\n//////////////////////////////  CALLBACK  ////////////////////////////////\n\n//Callback class\nclass SampleGrabberCallback : public ISampleGrabberCB{\npublic:\n\n    //------------------------------------------------\n    SampleGrabberCallback(){\n        InitializeCriticalSection(&critSection);\n        freezeCheck = 0;\n\n\n        bufferSetup         = false;\n        newFrame            = false;\n        latestBufferLength  = 0;\n\n        hEvent = CreateEvent(NULL, true, false, NULL);\n    }\n\n\n    //------------------------------------------------\n    virtual ~SampleGrabberCallback(){\n        ptrBuffer = NULL;\n        DeleteCriticalSection(&critSection);\n        CloseHandle(hEvent);\n        if(bufferSetup){\n            delete[] pixels;\n        }\n    }\n\n\n    //------------------------------------------------\n    bool setupBuffer(int numBytesIn){\n        if(bufferSetup){\n            return false;\n        }else{\n            numBytes            = numBytesIn;\n            pixels              = new unsigned char[numBytes];\n            bufferSetup         = true;\n            newFrame            = false;\n            latestBufferLength  = 0;\n        }\n        return true;\n    }\n\n\n    //------------------------------------------------\n    STDMETHODIMP_(ULONG) AddRef() { return 1; }\n    STDMETHODIMP_(ULONG) Release() { return 2; }\n\n\n    //------------------------------------------------\n    STDMETHODIMP QueryInterface(REFIID, void **ppvObject){\n        *ppvObject = static_cast<ISampleGrabberCB*>(this);\n        return S_OK;\n    }\n\n\n    //This method is meant to have less overhead\n    //------------------------------------------------\n    STDMETHODIMP SampleCB(double , IMediaSample *pSample){\n        if(WaitForSingleObject(hEvent, 0) == WAIT_OBJECT_0) return S_OK;\n\n        HRESULT hr = pSample->GetPointer(&ptrBuffer);\n\n        if(hr == S_OK){\n            latestBufferLength = pSample->GetActualDataLength();\n              if(latestBufferLength == numBytes){\n                EnterCriticalSection(&critSection);\n                      memcpy(pixels, ptrBuffer, latestBufferLength);\n                    newFrame    = true;\n                    freezeCheck = 1;\n                LeaveCriticalSection(&critSection);\n                SetEvent(hEvent);\n            }else{\n                DebugPrintOut(\"ERROR: SampleCB() - buffer sizes do not match\\n\");\n            }\n        }\n\n        return S_OK;\n    }\n\n\n    //This method is meant to have more overhead\n    STDMETHODIMP BufferCB(double, BYTE *, long){\n        return E_NOTIMPL;\n    }\n\n    int freezeCheck;\n\n    int latestBufferLength;\n    int numBytes;\n    bool newFrame;\n    bool bufferSetup;\n    unsigned char * pixels;\n    unsigned char * ptrBuffer;\n    CRITICAL_SECTION critSection;\n    HANDLE hEvent;\n};\n\n\n//////////////////////////////  VIDEO DEVICE  ////////////////////////////////\n\n// ----------------------------------------------------------------------\n//    Should this class also be the callback?\n//\n// ----------------------------------------------------------------------\n\nvideoDevice::videoDevice(){\n\n     pCaptureGraph      = NULL;    // Capture graph builder object\n     pGraph             = NULL;    // Graph builder object\n     pControl           = NULL;    // Media control object\n     pVideoInputFilter  = NULL; // Video Capture filter\n     pGrabber           = NULL; // Grabs frame\n     pDestFilter        = NULL; // Null Renderer Filter\n     pGrabberF          = NULL; // Grabber Filter\n     pMediaEvent        = NULL;\n     streamConf         = NULL;\n     pAmMediaType       = NULL;\n\n     //This is our callback class that processes the frame.\n     sgCallback           = new SampleGrabberCallback();\n     sgCallback->newFrame = false;\n\n     //Default values for capture type\n     videoType          = MEDIASUBTYPE_RGB24;\n     connection         = PhysConn_Video_Composite;\n     storeConn          = 0;\n\n     videoSize          = 0;\n     width              = 0;\n     height             = 0;\n\n     tryWidth           = 640;\n     tryHeight          = 480;\n     tryVideoType = MEDIASUBTYPE_RGB24;\n     nFramesForReconnect= 10000;\n     nFramesRunning     = 0;\n     myID               = -1;\n\n     tryDiffSize        = true;\n     useCrossbar        = false;\n     readyToCapture     = false;\n     sizeSet            = false;\n     setupStarted       = false;\n     specificFormat     = false;\n     autoReconnect      = false;\n     requestedFrameTime = -1;\n\n     memset(wDeviceName, 0, sizeof(WCHAR) * 255);\n     memset(nDeviceName, 0, sizeof(char) * 255);\n\n}\n\n\n// ----------------------------------------------------------------------\n//    The only place we are doing new\n//\n// ----------------------------------------------------------------------\n\nvoid videoDevice::setSize(int w, int h){\n    if(sizeSet){\n        DebugPrintOut(\"SETUP: Error device size should not be set more than once\\n\");\n    }\n    else\n    {\n        width               = w;\n        height              = h;\n        videoSize           = w*h*3;\n        sizeSet             = true;\n        pixels              = new unsigned char[videoSize];\n        pBuffer             = new char[videoSize];\n\n        memset(pixels, 0 , videoSize);\n        sgCallback->setupBuffer(videoSize);\n\n    }\n}\n\n\n// ----------------------------------------------------------------------\n//    Borrowed from the SDK, use it to take apart the graph from\n//  the capture device downstream to the null renderer\n// ----------------------------------------------------------------------\n\n```\n\u3053\u3053\u3067\u73fe\u308c\u308bIBaseFilter\u3068\u3044\u3046\u578b\u306f\u4f55\u8005\u306a\u306e\u304b\u8abf\u3079\u308b\u3002\n\n```\n\nvoid videoDevice::NukeDownstream(IBaseFilter *pBF){\n    IPin *pP, *pTo;\n    ULONG u;\n    IEnumPins *pins = NULL;\n    PIN_INFO pininfo;\n    HRESULT hr = pBF->EnumPins(&pins);\n    pins->Reset();\n    while (hr == NOERROR)\n    {\n        hr = pins->Next(1, &pP, &u);\n        if (hr == S_OK && pP)\n        {\n            pP->ConnectedTo(&pTo);\n            if (pTo)\n            {\n                hr = pTo->QueryPinInfo(&pininfo);\n                if (hr == NOERROR)\n                {\n                    if (pininfo.dir == PINDIR_INPUT)\n                    {\n                        NukeDownstream(pininfo.pFilter);\n                        pGraph->Disconnect(pTo);\n                        pGraph->Disconnect(pP);\n                        pGraph->RemoveFilter(pininfo.pFilter);\n                    }\n                    pininfo.pFilter->Release();\n                    pininfo.pFilter = NULL;\n                }\n                pTo->Release();\n            }\n            pP->Release();\n        }\n    }\n    if (pins) pins->Release();\n}\n\n```\n\u3053\u3053\u3067\u30d4\u30f3\u306b\u63a5\u7d9a\u3057\u3066\u3044\u308b\u306e\u3067\u306f\u306a\u3044\u304b\u3068\u601d\u3046\u3002\n\n\nIPin \u30a4\u30f3\u30bf\u30fc\u30d5\u30a7\u30a4\u30b9\n\u3053\u306e\u30a4\u30f3\u30bf\u30fc\u30d5\u30a7\u30a4\u30b9\u306f\u3059\u3079\u3066\u306e\u5165\u529b\u30d4\u30f3\u3001\u51fa\u529b\u30d4\u30f3\u306b\u3088\u3063\u3066\u516c\u958b\u3055\u308c\u308b\u3002\n**\u30d5\u30a3\u30eb\u30bf \u30b0\u30e9\u30d5 \u30de\u30cd\u30fc\u30b8\u30e3\u306f\u3053\u306e\u30a4\u30f3\u30bf\u30fc\u30d5\u30a7\u30a4\u30b9\u3092\u4f7f\u3063\u3066\u30d4\u30f3\u3068\u63a5\u7d9a\u3057\u3001\u30d5\u30e9\u30c3\u30b7\u30e5\u51e6\u7406\u3092\u884c\u3046\u3002**\u30a2\u30d7\u30ea\u30b1\u30fc\u30b7\u30e7\u30f3\u306f\u3053\u306e\u30a4\u30f3\u30bf\u30fc\u30d5\u30a7\u30a4\u30b9\u3092\u4f7f\u3063\u3066\u30d4\u30f3\u306e\u60c5\u5831\u3092\u554f\u3044\u5408\u308f\u305b\u308b\u3053\u3068\u304c\u3067\u304d\u308b\u3002\u30a2\u30d7\u30ea\u30b1\u30fc\u30b7\u30e7\u30f3\u306f\u3001Connect\u3001Disconnect\u3001BeginFlush\u3001EndFlush \u306a\u3069\u3001\u30d4\u30f3\u306e\u72b6\u614b\u3092\u5909\u66f4\u3059\u308b\u3088\u3046\u306a IPin \u30e1\u30bd\u30c3\u30c9\u3092\u6c7a\u3057\u3066\u547c\u3073\u51fa\u3055\u306a\u3044\u3053\u3068\u3002**\u30d4\u30f3\u3092\u63a5\u7d9a\u3059\u308b\u306b\u306f\u3001\u30a2\u30d7\u30ea\u30b1\u30fc\u30b7\u30e7\u30f3\u306f IGraphBuilder \u5185\u306e\u30e1\u30bd\u30c3\u30c9\u3092\u4f7f\u308f\u306a\u3051\u308c\u3070\u306a\u3089\u306a\u3044\u3002**\n\u30d5\u30a3\u30eb\u30bf\u958b\u767a\u8005 : CBasePin\u3001CBaseInputPin\u3001CBaseOutputPin \u306e\u5404\u30af\u30e9\u30b9\u306f\u3053\u306e\u30a4\u30f3\u30bf\u30fc\u30d5\u30a7\u30a4\u30b9\u3092\u5b9f\u88c5\u3059\u308b\u3002\u4ed6\u306e\u57fa\u5e95\u30af\u30e9\u30b9\u306f\u3053\u308c\u3089 3 \u3064\u306e\u30af\u30e9\u30b9\u304b\u3089\u6d3e\u751f\u3059\u308b\u3002\nIPin \u30a4\u30f3\u30bf\u30fc\u30d5\u30a7\u30a4\u30b9\u306f\u3001IUnknown \u304b\u3089\u7d99\u627f\u3059\u308b\u30e1\u30bd\u30c3\u30c9\u4ee5\u5916\u306b\u4ee5\u4e0b\u306e\u30e1\u30bd\u30c3\u30c9\u3082\u516c\u958b\u3059\u308b\u3002\n\n\n|\u30e1\u30bd\u30c3\u30c9\t|\u8aac\u660e|\n|:-------|:--------------------------------|\n|Connect\t|\u30d4\u30f3\u3092\u4ed6\u306e\u30d4\u30f3\u306b\u63a5\u7d9a\u3059\u308b\u3002|\n|ReceiveConnection|\t\u4ed6\u306e\u30d4\u30f3\u304b\u3089\u306e\u63a5\u7d9a\u3092\u8a31\u53ef\u3059\u308b\u3002|\n|Disconnect\t|\u73fe\u5728\u306e\u30d4\u30f3\u63a5\u7d9a\u3092\u89e3\u9664\u3059\u308b\u3002|\n|ConnectedTo\t|\u3053\u306e\u30d4\u30f3\u306b\u63a5\u7d9a\u3057\u3066\u3044\u308b\u30d4\u30f3\u3092\u53d6\u5f97\u3059\u308b\u3002|\n|ConnectionMediaType\t|\u73fe\u5728\u306e\u30d4\u30f3\u63a5\u7d9a\u306e\u30e1\u30c7\u30a3\u30a2 \u30bf\u30a4\u30d7\u3092\u53d6\u5f97\u3059\u308b\u3002|\n|QueryPinInfo\t|\u540d\u524d\u3001\u6240\u6709\u8005\u30d5\u30a3\u30eb\u30bf\u3001\u5411\u304d\u306a\u3069\u3001\u30d4\u30f3\u306b\u3064\u3044\u3066\u306e\u60c5\u5831\u3092\u53d6\u5f97\u3059\u308b\u3002|\n|QueryId\t|\u30d4\u30f3\u8b58\u5225\u5b50\u3092\u53d6\u5f97\u3059\u308b\u3002|\n|QueryAccept\t|\u6307\u5b9a\u3057\u305f\u30e1\u30c7\u30a3\u30a2 \u30bf\u30a4\u30d7\u3092\u30d4\u30f3\u304c\u53d7\u3051\u5165\u308c\u308b\u304b\u3069\u3046\u304b\u3092\u78ba\u8a8d\u3059\u308b\u3002|\n|EnumMediaTypes\t|\u30d4\u30f3\u306e\u512a\u5148\u30e1\u30c7\u30a3\u30a2 \u30bf\u30a4\u30d7\u3092\u5217\u6319\u3059\u308b\u3002|\n|QueryInternalConnections\t|(\u30d5\u30a3\u30eb\u30bf\u5185\u3067) \u5185\u90e8\u7684\u306b\u3053\u306e\u30d4\u30f3\u306b\u63a5\u7d9a\u3057\u3066\u3044\u308b\u30d4\u30f3\u3092\u53d6\u5f97\u3059\u308b\u3002|\n|EndOfStream\t|\u8ffd\u52a0\u306e\u30c7\u30fc\u30bf\u304c\u306a\u3044\u3053\u3068\u3092\u30d4\u30f3\u306b\u901a\u77e5\u3059\u308b\u3002|\n|BeginFlush\t|\u30d5\u30e9\u30c3\u30b7\u30e5\u51e6\u7406\u3092\u958b\u59cb\u3059\u308b\u3002|\n|EndFlush\t|\u30d5\u30e9\u30c3\u30b7\u30e5\u51e6\u7406\u3092\u7d42\u4e86\u3059\u308b\u3002|\n|NewSegment\t|\u3053\u306e\u547c\u3073\u51fa\u3057\u5f8c\u306b\u53d7\u3051\u53d6\u3063\u305f\u30e1\u30c7\u30a3\u30a2 \u30b5\u30f3\u30d7\u30eb\u304c\u3001\u30bb\u30b0\u30e1\u30f3\u30c8\u3068\u3057\u3066\u30b0\u30eb\u30fc\u30d7\u5316\u3055\u308c\u305f\u3053\u3068\u3092\u30d4\u30f3\u306b\u901a\u77e5\u3059\u308b\u3002|\n|QueryDirection\t|\u30d4\u30f3\u306e\u5411\u304d (\u5165\u529b\u304b\u51fa\u529b\u304b) \u3092\u53d6\u5f97\u3059\u308b\u3002|\n\n```\n\n// ----------------------------------------------------------------------\n//    Also from SDK\n// ----------------------------------------------------------------------\n\nvoid videoDevice::destroyGraph(){\n    HRESULT hr = 0;\n     //int FuncRetval=0;\n     //int NumFilters=0;\n\n    int i = 0;\n    while (hr == NOERROR)\n    {\n        IEnumFilters * pEnum = 0;\n        ULONG cFetched;\n\n        // We must get the enumerator again every time because removing a filter from the graph\n        // invalidates the enumerator. We always get only the first filter from each enumerator.\n        hr = pGraph->EnumFilters(&pEnum);\n        if (FAILED(hr)) { DebugPrintOut(\"SETUP: pGraph->EnumFilters() failed.\\n\"); return; }\n\n        IBaseFilter * pFilter = NULL;\n        if (pEnum->Next(1, &pFilter, &cFetched) == S_OK)\n        {\n            FILTER_INFO FilterInfo;\n            memset(&FilterInfo, 0, sizeof(FilterInfo));\n            hr = pFilter->QueryFilterInfo(&FilterInfo);\n            FilterInfo.pGraph->Release();\n\n            int count = 0;\n            char buffer[255];\n            memset(buffer, 0, 255 * sizeof(char));\n\n            while( FilterInfo.achName[count] != 0x00 )\n            {\n                buffer[count] = (char)FilterInfo.achName[count];\n                count++;\n            }\n\n            DebugPrintOut(\"SETUP: removing filter %s...\\n\", buffer);\n            hr = pGraph->RemoveFilter(pFilter);\n            if (FAILED(hr)) { DebugPrintOut(\"SETUP: pGraph->RemoveFilter() failed.\\n\"); return; }\n            DebugPrintOut(\"SETUP: filter removed %s\\n\",buffer);\n\n            pFilter->Release();\n            pFilter = NULL;\n        }\n        else break;\n        pEnum->Release();\n        pEnum = NULL;\n        i++;\n    }\n\n return;\n}\n\n\n// ----------------------------------------------------------------------\n// Our deconstructor, attempts to tear down graph and release filters etc\n// Does checking to make sure it only is freeing if it needs to\n// Probably could be a lot cleaner! :)\n// ----------------------------------------------------------------------\n\nvideoDevice::~videoDevice(){\n\n    if(setupStarted){ DebugPrintOut(\"\\nSETUP: Disconnecting device %i\\n\", myID); }\n    else{\n        if(sgCallback){\n            sgCallback->Release();\n            delete sgCallback;\n        }\n        return;\n    }\n\n    HRESULT HR = NOERROR;\n\n    //Stop the callback and free it\n    if( (sgCallback) && (pGrabber) )\n    {\n        pGrabber->SetCallback(NULL, 1);\n        DebugPrintOut(\"SETUP: freeing Grabber Callback\\n\");\n        sgCallback->Release();\n\n        //delete our pixels\n        if(sizeSet){\n             delete[] pixels;\n             delete[] pBuffer;\n        }\n\n        delete sgCallback;\n    }\n\n    //Check to see if the graph is running, if so stop it.\n     if( (pControl) )\n    {\n        HR = pControl->Pause();\n        if (FAILED(HR)) DebugPrintOut(\"ERROR - Could not pause pControl\\n\");\n\n        HR = pControl->Stop();\n        if (FAILED(HR)) DebugPrintOut(\"ERROR - Could not stop pControl\\n\");\n    }\n\n    //Disconnect filters from capture device\n    if( (pVideoInputFilter) )NukeDownstream(pVideoInputFilter);\n\n    //Release and zero pointers to our filters etc\n    if( (pDestFilter) ){        DebugPrintOut(\"SETUP: freeing Renderer\\n\");\n                                (pDestFilter)->Release();\n                                (pDestFilter) = 0;\n    }\n    if( (pVideoInputFilter) ){  DebugPrintOut(\"SETUP: freeing Capture Source\\n\");\n                                (pVideoInputFilter)->Release();\n                                (pVideoInputFilter) = 0;\n    }\n    if( (pGrabberF) ){          DebugPrintOut(\"SETUP: freeing Grabber Filter\\n\");\n                                (pGrabberF)->Release();\n                                (pGrabberF) = 0;\n    }\n    if( (pGrabber) ){           DebugPrintOut(\"SETUP: freeing Grabber\\n\");\n                                (pGrabber)->Release();\n                                (pGrabber) = 0;\n    }\n    if( (pControl) ){           DebugPrintOut(\"SETUP: freeing Control\\n\");\n                                (pControl)->Release();\n                                (pControl) = 0;\n    }\n    if( (pMediaEvent) ){        DebugPrintOut(\"SETUP: freeing Media Event\\n\");\n                                (pMediaEvent)->Release();\n                                (pMediaEvent) = 0;\n    }\n    if( (streamConf) ){         DebugPrintOut(\"SETUP: freeing Stream\\n\");\n                                (streamConf)->Release();\n                                (streamConf) = 0;\n    }\n\n    if( (pAmMediaType) ){       DebugPrintOut(\"SETUP: freeing Media Type\\n\");\n                                MyDeleteMediaType(pAmMediaType);\n    }\n\n    if((pMediaEvent)){\n            DebugPrintOut(\"SETUP: freeing Media Event\\n\");\n            (pMediaEvent)->Release();\n            (pMediaEvent) = 0;\n    }\n\n    //Destroy the graph\n    if( (pGraph) )destroyGraph();\n\n    //Release and zero our capture graph and our main graph\n    if( (pCaptureGraph) ){      DebugPrintOut(\"SETUP: freeing Capture Graph\\n\");\n                                (pCaptureGraph)->Release();\n                                (pCaptureGraph) = 0;\n    }\n    if( (pGraph) ){             DebugPrintOut(\"SETUP: freeing Main Graph\\n\");\n                                (pGraph)->Release();\n                                (pGraph) = 0;\n    }\n\n    //delete our pointers\n    delete pDestFilter;\n    delete pVideoInputFilter;\n    delete pGrabberF;\n    delete pGrabber;\n    delete pControl;\n    delete streamConf;\n    delete pMediaEvent;\n    delete pCaptureGraph;\n    delete pGraph;\n\n    DebugPrintOut(\"SETUP: Device %i disconnected and freed\\n\\n\",myID);\n}\n\n\n//////////////////////////////  VIDEO INPUT  ////////////////////////////////\n////////////////////////////  PUBLIC METHODS  ///////////////////////////////\n\n\n// ----------------------------------------------------------------------\n// Constructor - creates instances of videoDevice and adds the various\n// media subtypes to check.\n// ----------------------------------------------------------------------\n\nvideoInput::videoInput(){\n    //start com\n    comInit();\n\n    devicesFound         = 0;\n    callbackSetCount     = 0;\n    bCallback            = true;\n\n    //setup a max no of device objects\n    for(int i=0; i<VI_MAX_CAMERAS; i++)  VDList[i] = new videoDevice();\n\n```\n\u3053\u3053\u3067videoDevice\u306f\u65b0\u898f\u4f5c\u6210\u3057\u3066\u3044\u308b\u3088\u3046\u3060\u3002\n\n```\n\n    DebugPrintOut(\"\\n***** VIDEOINPUT LIBRARY - %2.04f - TFW07 *****\\n\\n\",VI_VERSION);\n\n    //added for the pixelink firewire camera\n     //MEDIASUBTYPE_Y800 = (GUID)FOURCCMap(FCC('Y800'));\n     //MEDIASUBTYPE_Y8   = (GUID)FOURCCMap(FCC('Y8'));\n     //MEDIASUBTYPE_GREY = (GUID)FOURCCMap(FCC('GREY'));\n\n    //The video types we support\n    //in order of preference\n\n    mediaSubtypes[0]     = MEDIASUBTYPE_RGB24;\n    mediaSubtypes[1]     = MEDIASUBTYPE_RGB32;\n    mediaSubtypes[2]     = MEDIASUBTYPE_RGB555;\n    mediaSubtypes[3]     = MEDIASUBTYPE_RGB565;\n    mediaSubtypes[4]     = MEDIASUBTYPE_YUY2;\n    mediaSubtypes[5]     = MEDIASUBTYPE_YVYU;\n    mediaSubtypes[6]     = MEDIASUBTYPE_YUYV;\n    mediaSubtypes[7]     = MEDIASUBTYPE_IYUV;\n    mediaSubtypes[8]     = MEDIASUBTYPE_UYVY;\n    mediaSubtypes[9]     = MEDIASUBTYPE_YV12;\n    mediaSubtypes[10]    = MEDIASUBTYPE_YVU9;\n    mediaSubtypes[11]    = MEDIASUBTYPE_Y411;\n    mediaSubtypes[12]    = MEDIASUBTYPE_Y41P;\n    mediaSubtypes[13]    = MEDIASUBTYPE_Y211;\n    mediaSubtypes[14]    = MEDIASUBTYPE_AYUV;\n    mediaSubtypes[15]    = MEDIASUBTYPE_MJPG; // MGB\n\n    //non standard\n    mediaSubtypes[16]    = MEDIASUBTYPE_Y800;\n    mediaSubtypes[17]    = MEDIASUBTYPE_Y8;\n    mediaSubtypes[18]    = MEDIASUBTYPE_GREY;\n    mediaSubtypes[19]    = MEDIASUBTYPE_I420;\n\n    //The video formats we support\n    formatTypes[VI_NTSC_M]      = AnalogVideo_NTSC_M;\n    formatTypes[VI_NTSC_M_J]    = AnalogVideo_NTSC_M_J;\n    formatTypes[VI_NTSC_433]    = AnalogVideo_NTSC_433;\n\n    formatTypes[VI_PAL_B]       = AnalogVideo_PAL_B;\n    formatTypes[VI_PAL_D]       = AnalogVideo_PAL_D;\n    formatTypes[VI_PAL_G]       = AnalogVideo_PAL_G;\n    formatTypes[VI_PAL_H]       = AnalogVideo_PAL_H;\n    formatTypes[VI_PAL_I]       = AnalogVideo_PAL_I;\n    formatTypes[VI_PAL_M]       = AnalogVideo_PAL_M;\n    formatTypes[VI_PAL_N]       = AnalogVideo_PAL_N;\n    formatTypes[VI_PAL_NC]      = AnalogVideo_PAL_N_COMBO;\n\n    formatTypes[VI_SECAM_B]     = AnalogVideo_SECAM_B;\n    formatTypes[VI_SECAM_D]     = AnalogVideo_SECAM_D;\n    formatTypes[VI_SECAM_G]     = AnalogVideo_SECAM_G;\n    formatTypes[VI_SECAM_H]     = AnalogVideo_SECAM_H;\n    formatTypes[VI_SECAM_K]     = AnalogVideo_SECAM_K;\n    formatTypes[VI_SECAM_K1]    = AnalogVideo_SECAM_K1;\n    formatTypes[VI_SECAM_L]     = AnalogVideo_SECAM_L;\n\n}\n\n\n// ----------------------------------------------------------------------\n// static - set whether messages get printed to console or not\n//\n// ----------------------------------------------------------------------\n\nvoid videoInput::setVerbose(bool _verbose){\n#ifdef _DEBUG\n    gs_verbose = _verbose;\n#else\n    (void)_verbose; // Suppress 'unreferenced parameter' warning\n#endif\n}\n\n// ----------------------------------------------------------------------\n// change to use callback or regular capture\n// callback tells you when a new frame has arrived\n// but non-callback won't - but is single threaded\n// ----------------------------------------------------------------------\nvoid videoInput::setUseCallback(bool useCallback){\n    if(callbackSetCount == 0){\n        bCallback = useCallback;\n        callbackSetCount = 1;\n    }else{\n        DebugPrintOut(\"ERROR: setUseCallback can only be called before setup\\n\");\n    }\n}\n\n// ----------------------------------------------------------------------\n// Set the requested framerate - no guarantee you will get this\n//\n// ----------------------------------------------------------------------\n\nvoid videoInput::setIdealFramerate(int deviceNumber, int idealFramerate){\n    if(deviceNumber >= VI_MAX_CAMERAS || VDList[deviceNumber]->readyToCapture) return;\n\n    if( idealFramerate > 0 ){\n        VDList[deviceNumber]->requestedFrameTime = (unsigned long)(10000000 / idealFramerate);\n    }\n}\n\n\n// ----------------------------------------------------------------------\n// Set the requested framerate - no guarantee you will get this\n//\n// ----------------------------------------------------------------------\n\nvoid videoInput::setAutoReconnectOnFreeze(int deviceNumber, bool doReconnect, int numMissedFramesBeforeReconnect){\n    if(deviceNumber >= VI_MAX_CAMERAS) return;\n\n    VDList[deviceNumber]->autoReconnect            = doReconnect;\n    VDList[deviceNumber]->nFramesForReconnect    = numMissedFramesBeforeReconnect;\n\n}\n\n\n// ----------------------------------------------------------------------\n// Setup a device with the default settings\n//\n// ----------------------------------------------------------------------\n\nbool videoInput::setupDevice(int deviceNumber){\n    if(deviceNumber >= VI_MAX_CAMERAS || VDList[deviceNumber]->readyToCapture) return false;\n\n    if(setup(deviceNumber))return true;\n    return false;\n}\n\n\n// ----------------------------------------------------------------------\n// Setup a device with the default size but specify input type\n//\n// ----------------------------------------------------------------------\n\nbool videoInput::setupDevice(int deviceNumber, int _connection){\n    if(deviceNumber >= VI_MAX_CAMERAS || VDList[deviceNumber]->readyToCapture) return false;\n\n    setPhyCon(deviceNumber, _connection);\n    if(setup(deviceNumber))return true;\n    return false;\n}\n\n\n// ----------------------------------------------------------------------\n// Setup a device with the default connection but specify size\n//\n// ----------------------------------------------------------------------\n\nbool videoInput::setupDevice(int deviceNumber, int w, int h){\n    if(deviceNumber >= VI_MAX_CAMERAS || VDList[deviceNumber]->readyToCapture) return false;\n\n    setAttemptCaptureSize(deviceNumber,w,h);\n    if(setup(deviceNumber))return true;\n    return false;\n}\n\n// ----------------------------------------------------------------------\n// Setup a device with the default connection but specify size and image format\n//\n// Note:\n// Need a new name for this since signature clashes with \",int connection)\"\n// ----------------------------------------------------------------------\n\nbool videoInput::setupDeviceFourcc(int deviceNumber, int w, int h,int fourcc){\n    if(deviceNumber >= VI_MAX_CAMERAS || VDList[deviceNumber]->readyToCapture) return false;\n\n    if ( fourcc != -1 ) {\n        GUID *mediaType = getMediaSubtypeFromFourcc(fourcc);\n        if ( mediaType ) {\n            setAttemptCaptureSize(deviceNumber,w,h,*mediaType);\n        }\n    } else {\n        setAttemptCaptureSize(deviceNumber,w,h);\n    }\n    if(setup(deviceNumber))return true;\n    return false;\n}\n\n\n// ----------------------------------------------------------------------\n// Setup a device with specific size and connection\n//\n// ----------------------------------------------------------------------\n\nbool videoInput::setupDevice(int deviceNumber, int w, int h, int _connection){\n    if(deviceNumber >= VI_MAX_CAMERAS || VDList[deviceNumber]->readyToCapture) return false;\n\n    setAttemptCaptureSize(deviceNumber,w,h);\n    setPhyCon(deviceNumber, _connection);\n    if(setup(deviceNumber))return true;\n    return false;\n}\n\n\n// ----------------------------------------------------------------------\n// Setup the default video format of the device\n// Must be called after setup!\n// See #define formats in header file (eg VI_NTSC_M )\n//\n// ----------------------------------------------------------------------\n\nbool videoInput::setFormat(int deviceNumber, int format){\n    if(deviceNumber >= VI_MAX_CAMERAS || !VDList[deviceNumber]->readyToCapture) return false;\n\n    bool returnVal = false;\n\n    if(format >= 0 && format < VI_NUM_FORMATS){\n        VDList[deviceNumber]->formatType = formatTypes[format];\n        VDList[deviceNumber]->specificFormat = true;\n\n        if(VDList[deviceNumber]->specificFormat){\n\n            HRESULT hr = getDevice(&VDList[deviceNumber]->pVideoInputFilter, deviceNumber, VDList[deviceNumber]->wDeviceName, VDList[deviceNumber]->nDeviceName);\n            if(hr != S_OK){\n                return false;\n            }\n\n            IAMAnalogVideoDecoder *pVideoDec = NULL;\n               hr = VDList[deviceNumber]->pCaptureGraph->FindInterface(NULL, &MEDIATYPE_Video, VDList[deviceNumber]->pVideoInputFilter, IID_IAMAnalogVideoDecoder, (void **)&pVideoDec);\n\n\n            //in case the settings window some how freed them first\n            if(VDList[deviceNumber]->pVideoInputFilter)VDList[deviceNumber]->pVideoInputFilter->Release();\n            if(VDList[deviceNumber]->pVideoInputFilter)VDList[deviceNumber]->pVideoInputFilter = NULL;\n\n            if(FAILED(hr)){\n                DebugPrintOut(\"SETUP: couldn't set requested format\\n\");\n            }else{\n                long lValue = 0;\n                hr = pVideoDec->get_AvailableTVFormats(&lValue);\n                if( SUCCEEDED(hr) && (lValue & VDList[deviceNumber]->formatType) )\n                   {\n                       hr = pVideoDec->put_TVFormat(VDList[deviceNumber]->formatType);\n                    if( FAILED(hr) ){\n                        DebugPrintOut(\"SETUP: couldn't set requested format\\n\");\n                    }else{\n                        returnVal = true;\n                    }\n                   }\n\n                pVideoDec->Release();\n                pVideoDec = NULL;\n            }\n        }\n    }\n\n    return returnVal;\n}\n\n// ----------------------------------------------------------------------\n// Our static function for returning device names - thanks Peter!\n// Must call listDevices first.\n//\n// ----------------------------------------------------------------------\nchar videoInput::deviceNames[VI_MAX_CAMERAS][255]={{0}};\n\nchar * videoInput::getDeviceName(int deviceID){\n    if( deviceID >= VI_MAX_CAMERAS ){\n        return NULL;\n    }\n    return deviceNames[deviceID];\n}\n\n\n// ----------------------------------------------------------------------\n// Our static function for finding num devices available etc\n//\n// ----------------------------------------------------------------------\n\nint videoInput::listDevices(bool silent){\n\n    //COM Library Intialization\n    comInit();\n\n    if(!silent) DebugPrintOut(\"\\nVIDEOINPUT SPY MODE!\\n\\n\");\n\n\n    ICreateDevEnum *pDevEnum = NULL;\n    IEnumMoniker *pEnum = NULL;\n    int deviceCounter = 0;\n\n    HRESULT hr = CoCreateInstance(CLSID_SystemDeviceEnum, NULL,\n        CLSCTX_INPROC_SERVER, IID_ICreateDevEnum,\n        reinterpret_cast<void**>(&pDevEnum));\n\n\n    if (SUCCEEDED(hr))\n    {\n        // Create an enumerator for the video capture category.\n        hr = pDevEnum->CreateClassEnumerator(\n            CLSID_VideoInputDeviceCategory,\n            &pEnum, 0);\n\n       if(hr == S_OK){\n\n            if(!silent) DebugPrintOut(\"SETUP: Looking For Capture Devices\\n\");\n            IMoniker *pMoniker = NULL;\n\n            while (pEnum->Next(1, &pMoniker, NULL) == S_OK){\n\n                IPropertyBag *pPropBag;\n                hr = pMoniker->BindToStorage(0, 0, IID_IPropertyBag,\n                    (void**)(&pPropBag));\n\n                if (FAILED(hr)){\n                    pMoniker->Release();\n                    continue;  // Skip this one, maybe the next one will work.\n                }\n\n\n                 // Find the description or friendly name.\n                VARIANT varName;\n                VariantInit(&varName);\n                hr = pPropBag->Read(L\"Description\", &varName, 0);\n\n                if (FAILED(hr)) hr = pPropBag->Read(L\"FriendlyName\", &varName, 0);\n\n                if (SUCCEEDED(hr)){\n\n                    hr = pPropBag->Read(L\"FriendlyName\", &varName, 0);\n\n                    int count = 0;\n                    int maxLen = sizeof(deviceNames[0])/sizeof(deviceNames[0][0]) - 2;\n                    while( varName.bstrVal[count] != 0x00 && count < maxLen) {\n                        deviceNames[deviceCounter][count] = (char)varName.bstrVal[count];\n                        count++;\n                    }\n                    deviceNames[deviceCounter][count] = 0;\n\n                    if(!silent) DebugPrintOut(\"SETUP: %i) %s\\n\",deviceCounter, deviceNames[deviceCounter]);\n                }\n\n                pPropBag->Release();\n                pPropBag = NULL;\n\n                pMoniker->Release();\n                pMoniker = NULL;\n\n                deviceCounter++;\n            }\n\n            pDevEnum->Release();\n            pDevEnum = NULL;\n\n            pEnum->Release();\n            pEnum = NULL;\n        }\n\n         if(!silent) DebugPrintOut(\"SETUP: %i Device(s) found\\n\\n\", deviceCounter);\n    }\n\n    comUnInit();\n\n    return deviceCounter;\n}\n\n```\n\u5229\u7528\u53ef\u80fd\u306a\u30c7\u30d0\u30a4\u30b9\u3092\u78ba\u8a8d\u3057\u3066\u3044\u308b\u3002\n\u305d\u3082\u305d\u3082\u3001\u30c7\u30d0\u30a4\u30b9\u306b\u63b2\u8f09\u3055\u308c\u306a\u3051\u308c\u3070\u306a\u3089\u306a\u3044\u3088\u3046\u3060\u3002\n\n```\n\n\n// ----------------------------------------------------------------------\n//\n//\n// ----------------------------------------------------------------------\n\nint videoInput::getWidth(int id) const\n{\n    if(isDeviceSetup(id))\n    {\n        return VDList[id] ->width;\n    }\n\n    return 0;\n\n}\n\n\n// ----------------------------------------------------------------------\n//\n//\n// ----------------------------------------------------------------------\n\nint videoInput::getHeight(int id) const\n{\n    if(isDeviceSetup(id))\n    {\n        return VDList[id] ->height;\n    }\n\n    return 0;\n\n}\n\n// ----------------------------------------------------------------------\n//\n//\n// ----------------------------------------------------------------------\nint videoInput::getFourcc(int id) const\n{\n    if(isDeviceSetup(id))\n    {\n        return getFourccFromMediaSubtype(VDList[id]->videoType);\n    }\n\n    return 0;\n\n}\n\ndouble videoInput::getFPS(int id) const\n{\n    if(isDeviceSetup(id))\n    {\n        double frameTime= VDList[id]->requestedFrameTime;\n        if (frameTime>0) {\n            return (10000000.0 / frameTime);\n        }\n    }\n\n    return 0;\n\n}\n\n\n// ----------------------------------------------------------------------\n//\n//\n// ----------------------------------------------------------------------\n\nint videoInput::getSize(int id) const\n{\n    if(isDeviceSetup(id))\n    {\n        return VDList[id] ->videoSize;\n    }\n\n    return 0;\n\n}\n\n\n// ----------------------------------------------------------------------\n// Uses a supplied buffer\n// ----------------------------------------------------------------------\n\nbool videoInput::getPixels(int id, unsigned char * dstBuffer, bool flipRedAndBlue, bool flipImage){\n\n    bool success = false;\n\n    if(isDeviceSetup(id)){\n        if(bCallback){\n            //callback capture\n\n            DWORD result = WaitForSingleObject(VDList[id]->sgCallback->hEvent, 1000);\n            if( result != WAIT_OBJECT_0) return false;\n\n            //double paranoia - mutexing with both event and critical section\n            EnterCriticalSection(&VDList[id]->sgCallback->critSection);\n\n                unsigned char * src = VDList[id]->sgCallback->pixels;\n                unsigned char * dst = dstBuffer;\n                int height             = VDList[id]->height;\n                int width              = VDList[id]->width;\n\n                processPixels(src, dst, width, height, flipRedAndBlue, flipImage);\n                VDList[id]->sgCallback->newFrame = false;\n\n            LeaveCriticalSection(&VDList[id]->sgCallback->critSection);\n\n            ResetEvent(VDList[id]->sgCallback->hEvent);\n\n            success = true;\n\n        }\n        else{\n            //regular capture method\n            long bufferSize = VDList[id]->videoSize;\n            HRESULT hr = VDList[id]->pGrabber->GetCurrentBuffer(&bufferSize, (long *)VDList[id]->pBuffer);\n            if(hr==S_OK){\n                int numBytes = VDList[id]->videoSize;\n                if (numBytes == bufferSize){\n\n                    unsigned char * src = (unsigned char * )VDList[id]->pBuffer;\n                    unsigned char * dst = dstBuffer;\n                    int height             = VDList[id]->height;\n                    int width             = VDList[id]->width;\n\n                    processPixels(src, dst, width, height, flipRedAndBlue, flipImage);\n                    success = true;\n                }else{\n                    DebugPrintOut(\"ERROR: GetPixels() - bufferSizes do not match!\\n\");\n                }\n            }else{\n                DebugPrintOut(\"ERROR: GetPixels() - Unable to grab frame for device %i\\n\", id);\n            }\n        }\n    }\n\n    return success;\n}\n\n\n// ----------------------------------------------------------------------\n// Returns a buffer\n// ----------------------------------------------------------------------\nunsigned char * videoInput::getPixels(int id, bool flipRedAndBlue, bool flipImage){\n\n    if(isDeviceSetup(id)){\n           getPixels(id, VDList[id]->pixels, flipRedAndBlue, flipImage);\n    }\n\n    return VDList[id]->pixels;\n}\n\n\n\n// ----------------------------------------------------------------------\n//\n//\n// ----------------------------------------------------------------------\nbool videoInput::isFrameNew(int id){\n    if(!isDeviceSetup(id)) return false;\n    if(!bCallback)return true;\n\n    bool result = false;\n    bool freeze = false;\n\n    //again super paranoia!\n    EnterCriticalSection(&VDList[id]->sgCallback->critSection);\n        result = VDList[id]->sgCallback->newFrame;\n\n        //we need to give it some time at the begining to start up so lets check after 400 frames\n        if(VDList[id]->nFramesRunning > 400 && VDList[id]->sgCallback->freezeCheck > VDList[id]->nFramesForReconnect ){\n            freeze = true;\n        }\n\n        //we increment the freezeCheck var here - the callback resets it to 1\n        //so as long as the callback is running this var should never get too high.\n        //if the callback is not running then this number will get high and trigger the freeze action below\n        VDList[id]->sgCallback->freezeCheck++;\n    LeaveCriticalSection(&VDList[id]->sgCallback->critSection);\n\n    VDList[id]->nFramesRunning++;\n\n    if(freeze && VDList[id]->autoReconnect){\n        DebugPrintOut(\"ERROR: Device seems frozen - attempting to reconnect\\n\");\n        if( !restartDevice(VDList[id]->myID) ){\n            DebugPrintOut(\"ERROR: Unable to reconnect to device\\n\");\n        }else{\n            DebugPrintOut(\"SUCCESS: Able to reconnect to device\\n\");\n        }\n    }\n\n    return result;\n}\n\n\n// ----------------------------------------------------------------------\n//\n//\n// ----------------------------------------------------------------------\n\nbool videoInput::isDeviceSetup(int id) const\n{\n    if(id>=0 && id<devicesFound && VDList[id]->readyToCapture)return true;\n    else return false;\n}\n\n\n// ----------------------------------------------------------------------\n// Gives us a little pop up window to adjust settings\n// We do this in a seperate thread now!\n// ----------------------------------------------------------------------\n\n\nvoid __cdecl videoInput::basicThread(void * objPtr){\n\n    //get a reference to the video device\n    //not a copy as we need to free the filter\n    videoDevice * vd = *( (videoDevice **)(objPtr) );\n    ShowFilterPropertyPages(vd->pVideoInputFilter);\n\n\n\n    //now we free the filter and make sure it set to NULL\n    if(vd->pVideoInputFilter)vd->pVideoInputFilter->Release();\n    if(vd->pVideoInputFilter)vd->pVideoInputFilter = NULL;\n\n    return;\n}\n\nvoid videoInput::showSettingsWindow(int id){\n\n    if(isDeviceSetup(id)){\n        //HANDLE myTempThread;\n\n        //we reconnect to the device as we have freed our reference to it\n        //why have we freed our reference? because there seemed to be an issue\n        //with some mpeg devices if we didn't\n        HRESULT hr = getDevice(&VDList[id]->pVideoInputFilter, id, VDList[id]->wDeviceName, VDList[id]->nDeviceName);\n        if(hr == S_OK){\n            //myTempThread = (HANDLE)\n                _beginthread(basicThread, 0, (void *)&VDList[id]);\n        }\n    }\n}\n\n\n// Set a video signal setting using IAMVideoProcAmp\nbool videoInput::getVideoSettingFilter(int deviceID, long Property, long &min, long &max, long &SteppingDelta, long &currentValue, long &flags, long &defaultValue){\n    if( !isDeviceSetup(deviceID) )return false;\n\n    HRESULT hr;\n    //bool isSuccessful = false;\n\n    videoDevice * VD = VDList[deviceID];\n\n    hr = getDevice(&VD->pVideoInputFilter, deviceID, VD->wDeviceName, VD->nDeviceName);\n    if (FAILED(hr)){\n        DebugPrintOut(\"setVideoSetting - getDevice Error\\n\");\n        return false;\n    }\n\n    IAMVideoProcAmp *pAMVideoProcAmp = NULL;\n\n    hr = VD->pVideoInputFilter->QueryInterface(IID_IAMVideoProcAmp, (void**)&pAMVideoProcAmp);\n    if(FAILED(hr)){\n        DebugPrintOut(\"setVideoSetting - QueryInterface Error\\n\");\n        if(VD->pVideoInputFilter)VD->pVideoInputFilter->Release();\n        if(VD->pVideoInputFilter)VD->pVideoInputFilter = NULL;\n        return false;\n    }\n\n    char propStr[16];\n    getVideoPropertyAsString(Property,propStr);\n\n    DebugPrintOut(\"Setting video setting %s.\\n\", propStr);\n\n    pAMVideoProcAmp->GetRange(Property, &min, &max, &SteppingDelta, &defaultValue, &flags);\n    DebugPrintOut(\"Range for video setting %s: Min:%ld Max:%ld SteppingDelta:%ld Default:%ld Flags:%ld\\n\", propStr, min, max, SteppingDelta, defaultValue, flags);\n    pAMVideoProcAmp->Get(Property, &currentValue, &flags);\n\n    if(pAMVideoProcAmp)pAMVideoProcAmp->Release();\n    if(VD->pVideoInputFilter)VD->pVideoInputFilter->Release();\n    if(VD->pVideoInputFilter)VD->pVideoInputFilter = NULL;\n\n    return true;\n\n}\n\n\n// Set a video signal setting using IAMVideoProcAmp\nbool videoInput::setVideoSettingFilterPct(int deviceID, long Property, float pctValue, long Flags){\n    if( !isDeviceSetup(deviceID) )return false;\n\n    long min, max, currentValue, flags, defaultValue, stepAmnt;\n\n    if( !getVideoSettingFilter(deviceID, Property, min, max, stepAmnt, currentValue, flags, defaultValue) )return false;\n\n    if(pctValue > 1.0)pctValue = 1.0;\n    else if(pctValue < 0)pctValue = 0.0;\n\n    float range = (float)max - (float)min;\n    if(range <= 0)return false;\n    if(stepAmnt == 0) return false;\n\n    long value     = (long)( (float)min + range * pctValue );\n    long rasterValue = value;\n\n    //if the range is the stepAmnt then it is just a switch\n    //so we either set the value to low or high\n    if( range == stepAmnt ){\n        if( pctValue < 0.5)rasterValue = min;\n        else rasterValue = max;\n    }else{\n        //we need to rasterize the value to the stepping amnt\n        long mod         = value % stepAmnt;\n        float halfStep     = (float)stepAmnt * 0.5f;\n        if( mod < halfStep ) rasterValue -= mod;\n        else rasterValue += stepAmnt - mod;\n        DebugPrintOut(\"RASTER - pctValue is %f - value is %li - step is %li - mod is %li - rasterValue is %li\\n\", pctValue, value, stepAmnt, mod, rasterValue);\n    }\n\n    return setVideoSettingFilter(deviceID, Property, rasterValue, Flags, false);\n}\n\n\n// Set a video signal setting using IAMVideoProcAmp\nbool videoInput::setVideoSettingFilter(int deviceID, long Property, long lValue, long Flags, bool useDefaultValue){\n    if( !isDeviceSetup(deviceID) )return false;\n\n    HRESULT hr;\n    //bool isSuccessful = false;\n\n    char propStr[16];\n    getVideoPropertyAsString(Property,propStr);\n\n    videoDevice * VD = VDList[deviceID];\n\n    hr = getDevice(&VD->pVideoInputFilter, deviceID, VD->wDeviceName, VD->nDeviceName);\n    if (FAILED(hr)){\n        DebugPrintOut(\"setVideoSetting - getDevice Error\\n\");\n        return false;\n    }\n\n    IAMVideoProcAmp *pAMVideoProcAmp = NULL;\n\n    hr = VD->pVideoInputFilter->QueryInterface(IID_IAMVideoProcAmp, (void**)&pAMVideoProcAmp);\n    if(FAILED(hr)){\n        DebugPrintOut(\"setVideoSetting - QueryInterface Error\\n\");\n        if(VD->pVideoInputFilter)VD->pVideoInputFilter->Release();\n        if(VD->pVideoInputFilter)VD->pVideoInputFilter = NULL;\n        return false;\n    }\n\n    DebugPrintOut(\"Setting video setting %s.\\n\", propStr);\n    long CurrVal, Min, Max, SteppingDelta, Default, CapsFlags, AvailableCapsFlags = 0;\n\n\n    pAMVideoProcAmp->GetRange(Property, &Min, &Max, &SteppingDelta, &Default, &AvailableCapsFlags);\n    DebugPrintOut(\"Range for video setting %s: Min:%ld Max:%ld SteppingDelta:%ld Default:%ld Flags:%ld\\n\", propStr, Min, Max, SteppingDelta, Default, AvailableCapsFlags);\n    pAMVideoProcAmp->Get(Property, &CurrVal, &CapsFlags);\n\n    DebugPrintOut(\"Current value: %ld Flags %ld (%s)\\n\", CurrVal, CapsFlags, (CapsFlags == 1 ? \"Auto\" : (CapsFlags == 2 ? \"Manual\" : \"Unknown\")));\n\n    if (useDefaultValue) {\n        pAMVideoProcAmp->Set(Property, Default, VideoProcAmp_Flags_Auto);\n    }\n    else{\n        // Perhaps add a check that lValue and Flags are within the range aquired from GetRange above\n        pAMVideoProcAmp->Set(Property, lValue, Flags);\n    }\n\n    if(pAMVideoProcAmp)pAMVideoProcAmp->Release();\n    if(VD->pVideoInputFilter)VD->pVideoInputFilter->Release();\n    if(VD->pVideoInputFilter)VD->pVideoInputFilter = NULL;\n\n    return true;\n\n}\n\n\nbool videoInput::setVideoSettingCameraPct(int deviceID, long Property, float pctValue, long Flags){\n    if( !isDeviceSetup(deviceID) )return false;\n\n    long min, max, currentValue, flags, defaultValue, stepAmnt;\n\n    if( !getVideoSettingCamera(deviceID, Property, min, max, stepAmnt, currentValue, flags, defaultValue) )return false;\n\n    if(pctValue > 1.0)pctValue = 1.0;\n    else if(pctValue < 0)pctValue = 0.0;\n\n    float range = (float)max - (float)min;\n    if(range <= 0)return false;\n    if(stepAmnt == 0) return false;\n\n    long value     = (long)( (float)min + range * pctValue );\n    long rasterValue = value;\n\n    //if the range is the stepAmnt then it is just a switch\n    //so we either set the value to low or high\n    if( range == stepAmnt ){\n        if( pctValue < 0.5)rasterValue = min;\n        else rasterValue = max;\n    }else{\n        //we need to rasterize the value to the stepping amnt\n        long mod         = value % stepAmnt;\n        float halfStep     = (float)stepAmnt * 0.5f;\n        if( mod < halfStep ) rasterValue -= mod;\n        else rasterValue += stepAmnt - mod;\n        DebugPrintOut(\"RASTER - pctValue is %f - value is %li - step is %li - mod is %li - rasterValue is %li\\n\", pctValue, value, stepAmnt, mod, rasterValue);\n    }\n\n    return setVideoSettingCamera(deviceID, Property, rasterValue, Flags, false);\n}\n\n\nbool videoInput::setVideoSettingCamera(int deviceID, long Property, long lValue, long Flags, bool useDefaultValue){\n    IAMCameraControl *pIAMCameraControl;\n    if(isDeviceSetup(deviceID))\n    {\n        HRESULT hr;\n        hr = getDevice(&VDList[deviceID]->pVideoInputFilter, deviceID, VDList[deviceID]->wDeviceName, VDList[deviceID]->nDeviceName);\n\n        char propStr[16];\n        getCameraPropertyAsString(Property,propStr);\n\n        DebugPrintOut(\"Setting video setting %s.\\n\", propStr);\n        hr = VDList[deviceID]->pVideoInputFilter->QueryInterface(IID_IAMCameraControl, (void**)&pIAMCameraControl);\n        if (FAILED(hr)) {\n            DebugPrintOut(\"Error\\n\");\n            if(VDList[deviceID]->pVideoInputFilter)VDList[deviceID]->pVideoInputFilter->Release();\n            if(VDList[deviceID]->pVideoInputFilter)VDList[deviceID]->pVideoInputFilter = NULL;\n            return false;\n        }\n        else\n        {\n            long CurrVal, Min, Max, SteppingDelta, Default, CapsFlags, AvailableCapsFlags;\n            pIAMCameraControl->GetRange(Property, &Min, &Max, &SteppingDelta, &Default, &AvailableCapsFlags);\n            DebugPrintOut(\"Range for video setting %s: Min:%ld Max:%ld SteppingDelta:%ld Default:%ld Flags:%ld\\n\", propStr, Min, Max, SteppingDelta, Default, AvailableCapsFlags);\n            pIAMCameraControl->Get(Property, &CurrVal, &CapsFlags);\n            DebugPrintOut(\"Current value: %ld Flags %ld (%s)\\n\", CurrVal, CapsFlags, (CapsFlags == 1 ? \"Auto\" : (CapsFlags == 2 ? \"Manual\" : \"Unknown\")));\n            if (useDefaultValue) {\n                pIAMCameraControl->Set(Property, Default, CameraControl_Flags_Auto);\n            }\n            else\n            {\n                // Perhaps add a check that lValue and Flags are within the range aquired from GetRange above\n                pIAMCameraControl->Set(Property, lValue, Flags);\n            }\n            pIAMCameraControl->Release();\n            if(VDList[deviceID]->pVideoInputFilter)VDList[deviceID]->pVideoInputFilter->Release();\n            if(VDList[deviceID]->pVideoInputFilter)VDList[deviceID]->pVideoInputFilter = NULL;\n            return true;\n        }\n    }\n    return false;\n}\n\n\n\nbool videoInput::getVideoSettingCamera(int deviceID, long Property, long &min, long &max, long &SteppingDelta, long &currentValue, long &flags, long &defaultValue){\n    if( !isDeviceSetup(deviceID) )return false;\n\n    HRESULT hr;\n    //bool isSuccessful = false;\n\n    videoDevice * VD = VDList[deviceID];\n\n    hr = getDevice(&VD->pVideoInputFilter, deviceID, VD->wDeviceName, VD->nDeviceName);\n    if (FAILED(hr)){\n        DebugPrintOut(\"setVideoSetting - getDevice Error\\n\");\n        return false;\n    }\n\n    IAMCameraControl *pIAMCameraControl = NULL;\n\n    hr = VD->pVideoInputFilter->QueryInterface(IID_IAMCameraControl, (void**)&pIAMCameraControl);\n    if(FAILED(hr)){\n        DebugPrintOut(\"setVideoSetting - QueryInterface Error\\n\");\n        if(VD->pVideoInputFilter)VD->pVideoInputFilter->Release();\n        if(VD->pVideoInputFilter)VD->pVideoInputFilter = NULL;\n        return false;\n    }\n\n    char propStr[16];\n    getCameraPropertyAsString(Property,propStr);\n    DebugPrintOut(\"Setting video setting %s.\\n\", propStr);\n\n    pIAMCameraControl->GetRange(Property, &min, &max, &SteppingDelta, &defaultValue, &flags);\n    DebugPrintOut(\"Range for video setting %s: Min:%ld Max:%ld SteppingDelta:%ld Default:%ld Flags:%ld\\n\", propStr, min, max, SteppingDelta, defaultValue, flags);\n    pIAMCameraControl->Get(Property, &currentValue, &flags);\n\n    if(pIAMCameraControl)pIAMCameraControl->Release();\n    if(VD->pVideoInputFilter)VD->pVideoInputFilter->Release();\n    if(VD->pVideoInputFilter)VD->pVideoInputFilter = NULL;\n\n    return true;\n\n}\n\n\n// ----------------------------------------------------------------------\n// Shutsdown the device, deletes the object and creates a new object\n// so it is ready to be setup again\n// ----------------------------------------------------------------------\n\nvoid videoInput::stopDevice(int id){\n    if(id < VI_MAX_CAMERAS)\n    {\n        delete VDList[id];\n        VDList[id] = new videoDevice();\n    }\n\n}\n\n// ----------------------------------------------------------------------\n// Restarts the device with the same settings it was using\n//\n// ----------------------------------------------------------------------\n\nbool videoInput::restartDevice(int id){\n    if(isDeviceSetup(id))\n    {\n        int conn         = VDList[id]->storeConn;\n        int tmpW           = VDList[id]->width;\n        int tmpH           = VDList[id]->height;\n\n        bool bFormat    = VDList[id]->specificFormat;\n        long format     = VDList[id]->formatType;\n\n        int nReconnect    = VDList[id]->nFramesForReconnect;\n        bool bReconnect = VDList[id]->autoReconnect;\n\n        unsigned long avgFrameTime = VDList[id]->requestedFrameTime;\n\n        stopDevice(id);\n\n        //set our fps if needed\n        if( avgFrameTime != (unsigned long)-1){\n            VDList[id]->requestedFrameTime = avgFrameTime;\n        }\n\n        if( setupDevice(id, tmpW, tmpH, conn) ){\n            //reapply the format - ntsc / pal etc\n            if( bFormat ){\n                setFormat(id, format);\n            }\n            if( bReconnect ){\n                setAutoReconnectOnFreeze(id, true, nReconnect);\n            }\n            return true;\n        }\n    }\n    return false;\n}\n\n// ----------------------------------------------------------------------\n// Shuts down all devices, deletes objects and unitializes com if needed\n//\n// ----------------------------------------------------------------------\nvideoInput::~videoInput(){\n\n    for(int i = 0; i < VI_MAX_CAMERAS; i++)\n    {\n        delete VDList[i];\n    }\n    //Unitialize com\n    comUnInit();\n}\n\n\n//////////////////////////////  VIDEO INPUT  ////////////////////////////////\n////////////////////////////  PRIVATE METHODS  //////////////////////////////\n\n// ----------------------------------------------------------------------\n// We only should init com if it hasn't been done so by our apps thread\n// Use a static counter to keep track of other times it has been inited\n// (do we need to worry about multithreaded apps?)\n// ----------------------------------------------------------------------\n\nbool videoInput::comInit(){\n    /*HRESULT hr = NOERROR;\n\n    //no need for us to start com more than once\n    if(comInitCount == 0 ){\n\n        // Initialize the COM library.\n        //CoInitializeEx so videoInput can run in another thread\n    #ifdef VI_COM_MULTI_THREADED\n        hr = CoInitializeEx(NULL,COINIT_MULTITHREADED);\n    #else\n        hr = CoInitialize(NULL);\n    #endif\n        //this is the only case where there might be a problem\n        //if another library has started com as single threaded\n        //and we need it multi-threaded - send warning but don't fail\n        if( hr == RPC_E_CHANGED_MODE){\n             DebugPrintOut(\"SETUP - COM already setup - threaded VI might not be possible\\n\");\n        }\n    }\n\n    comInitCount++;*/\n    return true;\n}\n\n\n// ----------------------------------------------------------------------\n// Same as above but to unitialize com, decreases counter and frees com\n// if no one else is using it\n// ----------------------------------------------------------------------\n\nbool videoInput::comUnInit(){\n    /*if(comInitCount > 0)comInitCount--;        //decrease the count of instances using com\n\n       if(comInitCount == 0){\n           CoUninitialize();    //if there are no instances left - uninitialize com\n        return true;\n    }\n\n    return false;*/\n    return true;\n}\n\n\n// ----------------------------------------------------------------------\n// This is the size we ask for - we might not get it though :)\n//\n// ----------------------------------------------------------------------\n\nvoid videoInput::setAttemptCaptureSize(int id, int w, int h,GUID mediaType){\n\n    VDList[id]->tryWidth    = w;\n    VDList[id]->tryHeight   = h;\n    VDList[id]->tryDiffSize = true;\n    VDList[id]->tryVideoType = mediaType;\n\n}\n\n// ----------------------------------------------------------------------\n// Set the connection type\n// (maybe move to private?)\n// ----------------------------------------------------------------------\n\nvoid videoInput::setPhyCon(int id, int conn){\n\n    switch(conn){\n\n        case 0:\n            VDList[id]->connection = PhysConn_Video_Composite;\n            break;\n        case 1:\n            VDList[id]->connection = PhysConn_Video_SVideo;\n            break;\n        case 2:\n            VDList[id]->connection = PhysConn_Video_Tuner;\n            break;\n        case 3:\n            VDList[id]->connection = PhysConn_Video_USB;\n            break;\n        case 4:\n            VDList[id]->connection = PhysConn_Video_1394;\n            break;\n        default:\n            return; //if it is not these types don't set crossbar\n        break;\n    }\n\n    VDList[id]->storeConn    = conn;\n    VDList[id]->useCrossbar    = true;\n}\n\n\n```\n\n\u4e0b\u306eint deviceNumber\u3068\u3044\u3046\u306e\u304c\u3069\u3053\u304b\u3089\u6765\u3066\u3044\u308b\u306e\u304b\u8abf\u3079\u308b\u3002\nsetup\u95a2\u6570\u304c\u4f7f\u308f\u308c\u3066\u3044\u308b\u5834\u6240\u3092\u63a2\u3059\u3002\n\n```\n\n// ----------------------------------------------------------------------\n// Check that we are not trying to setup a non-existant device\n// Then start the graph building!\n// ----------------------------------------------------------------------\n\nbool videoInput::setup(int deviceNumber){\n    devicesFound = getDeviceCount();\n\n     if(deviceNumber>devicesFound-1)\n    {\n        DebugPrintOut(\"SETUP: device[%i] not found - you have %i devices available\\n\", deviceNumber, devicesFound);\n        if(devicesFound>=0) DebugPrintOut(\"SETUP: this means that the last device you can use is device[%i]\\n\",  devicesFound-1);\n        return false;\n    }\n\n    if(VDList[deviceNumber]->readyToCapture)\n    {\n        DebugPrintOut(\"SETUP: can't setup, device %i is currently being used\\n\",VDList[deviceNumber]->myID);\n        return false;\n    }\n\n    HRESULT hr = start(deviceNumber, VDList[deviceNumber]);\n    if(hr == S_OK)return true;\n    else return false;\n}\n\n\n// ----------------------------------------------------------------------\n// Does both vertical buffer flipping and bgr to rgb swapping\n// You have any combination of those.\n// ----------------------------------------------------------------------\n\nvoid videoInput::processPixels(unsigned char * src, unsigned char * dst, int width, int height, bool bRGB, bool bFlip){\n\n    int widthInBytes = width * 3;\n    int numBytes = widthInBytes * height;\n\n    if(!bRGB){\n\n        //int x = 0;\n        //int y = 0;\n\n        if(bFlip){\n            for(int y = 0; y < height; y++){\n                memcpy(dst + (y * widthInBytes), src + ( (height -y -1) * widthInBytes), widthInBytes);\n            }\n\n        }else{\n            memcpy(dst, src, numBytes);\n        }\n    }else{\n        if(bFlip){\n\n            int x = 0;\n            int y = (height - 1) * widthInBytes;\n            src += y;\n\n            for(int i = 0; i < numBytes; i+=3){\n                if(x >= width){\n                    x = 0;\n                    src -= widthInBytes*2;\n                }\n\n                *dst = *(src+2);\n                dst++;\n\n                *dst = *(src+1);\n                dst++;\n\n                *dst = *src;\n                dst++;\n\n                src+=3;\n                x++;\n            }\n        }\n        else{\n            for(int i = 0; i < numBytes; i+=3){\n                *dst = *(src+2);\n                dst++;\n\n                *dst = *(src+1);\n                dst++;\n\n                *dst = *src;\n                dst++;\n\n                src+=3;\n            }\n        }\n    }\n}\n\n\n//------------------------------------------------------------------------------------------\nvoid videoInput::getMediaSubtypeAsString(GUID type, char * typeAsString){\n\n    char tmpStr[8];\n    if( type == MEDIASUBTYPE_RGB24)     sprintf(tmpStr, \"RGB24\");\n    else if(type == MEDIASUBTYPE_RGB32) sprintf(tmpStr, \"RGB32\");\n    else if(type == MEDIASUBTYPE_RGB555)sprintf(tmpStr, \"RGB555\");\n    else if(type == MEDIASUBTYPE_RGB565)sprintf(tmpStr, \"RGB565\");\n    else if(type == MEDIASUBTYPE_YUY2)  sprintf(tmpStr, \"YUY2\");\n    else if(type == MEDIASUBTYPE_YVYU)  sprintf(tmpStr, \"YVYU\");\n    else if(type == MEDIASUBTYPE_YUYV)  sprintf(tmpStr, \"YUYV\");\n    else if(type == MEDIASUBTYPE_IYUV)  sprintf(tmpStr, \"IYUV\");\n    else if(type == MEDIASUBTYPE_UYVY)  sprintf(tmpStr, \"UYVY\");\n    else if(type == MEDIASUBTYPE_YV12)  sprintf(tmpStr, \"YV12\");\n    else if(type == MEDIASUBTYPE_YVU9)  sprintf(tmpStr, \"YVU9\");\n    else if(type == MEDIASUBTYPE_Y411)  sprintf(tmpStr, \"Y411\");\n    else if(type == MEDIASUBTYPE_Y41P)  sprintf(tmpStr, \"Y41P\");\n    else if(type == MEDIASUBTYPE_Y211)  sprintf(tmpStr, \"Y211\");\n    else if(type == MEDIASUBTYPE_AYUV)  sprintf(tmpStr, \"AYUV\");\n    else if(type == MEDIASUBTYPE_MJPG)  sprintf(tmpStr, \"MJPG\");\n    else if(type == MEDIASUBTYPE_Y800)  sprintf(tmpStr, \"Y800\");\n    else if(type == MEDIASUBTYPE_Y8)    sprintf(tmpStr, \"Y8\");\n    else if(type == MEDIASUBTYPE_GREY)  sprintf(tmpStr, \"GREY\");\n    else if(type == MEDIASUBTYPE_I420)  sprintf(tmpStr, \"I420\");\n    else sprintf(tmpStr, \"OTHER\");\n\n    memcpy(typeAsString, tmpStr, sizeof(char)*8);\n}\n\nint videoInput::getFourccFromMediaSubtype(GUID type) const\n{\n    return type.Data1;\n}\n\nGUID *videoInput::getMediaSubtypeFromFourcc(int fourcc){\n\n    for (int i=0;i<VI_NUM_TYPES;i++) {\n        if ( (unsigned long)(unsigned)fourcc == mediaSubtypes[i].Data1 ) {\n            return &mediaSubtypes[i];\n        }\n    }\n\n    return NULL;\n}\n\n\nvoid videoInput::getVideoPropertyAsString(int prop, char * propertyAsString){\n\n    char tmpStr[16];\n\n    if ( prop==VideoProcAmp_Brightness) sprintf(tmpStr, \"Brightness\");\n    else if ( prop==VideoProcAmp_Contrast) sprintf(tmpStr, \"Contrast\");\n    else if ( prop==VideoProcAmp_Saturation) sprintf(tmpStr, \"Saturation\");\n    else if ( prop==VideoProcAmp_Hue) sprintf(tmpStr, \"Hue\");\n    else if ( prop==VideoProcAmp_Gain) sprintf(tmpStr, \"Gain\");\n    else if ( prop==VideoProcAmp_Gamma) sprintf(tmpStr, \"Gamma\");\n    else if ( prop==VideoProcAmp_ColorEnable) sprintf(tmpStr, \"ColorEnable\");\n    else if ( prop==VideoProcAmp_Sharpness) sprintf(tmpStr, \"Sharpness\");\n    else sprintf(tmpStr, \"%u\",prop);\n\n    memcpy(propertyAsString, tmpStr, sizeof(char)*16);\n}\n\n\nint videoInput::getVideoPropertyFromCV(int cv_property){\n\n    // see VideoProcAmpProperty in strmif.h\n    switch (cv_property) {\n        case CV_CAP_PROP_BRIGHTNESS:\n            return VideoProcAmp_Brightness;\n\n        case CV_CAP_PROP_CONTRAST:\n            return VideoProcAmp_Contrast;\n\n        case CV_CAP_PROP_HUE:\n            return VideoProcAmp_Hue;\n\n        case CV_CAP_PROP_SATURATION:\n            return VideoProcAmp_Saturation;\n\n        case CV_CAP_PROP_SHARPNESS:\n            return VideoProcAmp_Sharpness;\n\n        case CV_CAP_PROP_GAMMA:\n            return VideoProcAmp_Gamma;\n\n        case CV_CAP_PROP_MONOCHROME:\n            return VideoProcAmp_ColorEnable;\n\n        case CV_CAP_PROP_WHITE_BALANCE_BLUE_U:\n            return VideoProcAmp_WhiteBalance;\n\n        case  CV_CAP_PROP_BACKLIGHT:\n            return VideoProcAmp_BacklightCompensation;\n\n        case CV_CAP_PROP_GAIN:\n            return VideoProcAmp_Gain;\n    }\n    return -1;\n}\n\nint videoInput::getCameraPropertyFromCV(int cv_property){\n\n    // see CameraControlProperty in strmif.h\n    switch (cv_property) {\n        case CV_CAP_PROP_PAN:\n            return CameraControl_Pan;\n\n        case CV_CAP_PROP_TILT:\n            return CameraControl_Tilt;\n\n        case CV_CAP_PROP_ROLL:\n            return CameraControl_Roll;\n\n        case CV_CAP_PROP_ZOOM:\n            return CameraControl_Zoom;\n\n        case CV_CAP_PROP_EXPOSURE:\n            return CameraControl_Exposure;\n\n        case CV_CAP_PROP_IRIS:\n            return CameraControl_Iris;\n\n        case CV_CAP_PROP_FOCUS:\n            return CameraControl_Focus;\n    }\n    return -1;\n}\n\nvoid videoInput::getCameraPropertyAsString(int prop, char * propertyAsString){\n\n    char tmpStr[16];\n\n    if ( prop==CameraControl_Pan) sprintf(tmpStr, \"Pan\");\n    else if ( prop==CameraControl_Tilt) sprintf(tmpStr, \"Tilt\");\n    else if ( prop==CameraControl_Roll) sprintf(tmpStr, \"Roll\");\n    else if ( prop==CameraControl_Zoom) sprintf(tmpStr, \"Zoom\");\n    else if ( prop==CameraControl_Exposure) sprintf(tmpStr, \"Exposure\");\n    else if ( prop==CameraControl_Iris) sprintf(tmpStr, \"Iris\");\n    else if ( prop==CameraControl_Focus) sprintf(tmpStr, \"Focus\");\n    else sprintf(tmpStr, \"%u\",prop);\n\n    memcpy(propertyAsString, tmpStr, sizeof(char)*16);\n}\n\n\n//-------------------------------------------------------------------------------------------\nstatic void findClosestSizeAndSubtype(videoDevice * VD, int widthIn, int heightIn, int &widthOut, int &heightOut, GUID & mediatypeOut){\n    HRESULT hr;\n\n    //find perfect match or closest size\n    int nearW                = 9999999;\n    int nearH                = 9999999;\n    //bool foundClosestMatch     = true;\n\n    int iCount = 0;\n    int iSize = 0;\n    hr = VD->streamConf->GetNumberOfCapabilities(&iCount, &iSize);\n\n    if (iSize == sizeof(VIDEO_STREAM_CONFIG_CAPS))\n    {\n        //For each format type RGB24 YUV2 etc\n        for (int iFormat = 0; iFormat < iCount; iFormat++)\n        {\n            VIDEO_STREAM_CONFIG_CAPS scc;\n            AM_MEDIA_TYPE *pmtConfig;\n            hr =  VD->streamConf->GetStreamCaps(iFormat, &pmtConfig, (BYTE*)&scc);\n\n            if (SUCCEEDED(hr)){\n\n                //his is how many diff sizes are available for the format\n                int stepX = scc.OutputGranularityX;\n                int stepY = scc.OutputGranularityY;\n\n                   int tempW = 999999;\n                   int tempH = 999999;\n\n                   //Don't want to get stuck in a loop\n                   if(stepX < 1 || stepY < 1) continue;\n\n                   //DebugPrintOut(\"min is %i %i max is %i %i - res is %i %i\\n\", scc.MinOutputSize.cx, scc.MinOutputSize.cy,  scc.MaxOutputSize.cx,  scc.MaxOutputSize.cy, stepX, stepY);\n                   //DebugPrintOut(\"min frame duration is %i  max duration is %i\\n\", scc.MinFrameInterval, scc.MaxFrameInterval);\n\n                   bool exactMatch     = false;\n                   bool exactMatchX    = false;\n                bool exactMatchY    = false;\n\n                for(int x = scc.MinOutputSize.cx; x <= scc.MaxOutputSize.cx; x+= stepX){\n                    //If we find an exact match\n                    if( widthIn == x ){\n                        exactMatchX = true;\n                        tempW = x;\n                    }\n                    //Otherwise lets find the closest match based on width\n                    else if( abs(widthIn-x) < abs(widthIn-tempW) ){\n                        tempW = x;\n                    }\n                }\n\n                for(int y = scc.MinOutputSize.cy; y <= scc.MaxOutputSize.cy; y+= stepY){\n                    //If we find an exact match\n                    if( heightIn == y){\n                        exactMatchY = true;\n                        tempH = y;\n                    }\n                    //Otherwise lets find the closest match based on height\n                    else if( abs(heightIn-y) < abs(heightIn-tempH) ){\n                        tempH = y;\n                    }\n                }\n\n                //see if we have an exact match!\n                if(exactMatchX && exactMatchY){\n                    //foundClosestMatch = false;\n                    exactMatch = true;\n\n                    widthOut        = widthIn;\n                    heightOut        = heightIn;\n                    mediatypeOut    = pmtConfig->subtype;\n                }\n\n                  //otherwise lets see if this filters closest size is the closest\n                  //available. the closest size is determined by the sum difference\n                //of the widths and heights\n                  else if( abs(widthIn - tempW) + abs(heightIn - tempH)  < abs(widthIn - nearW) + abs(heightIn - nearH) )\n                  {\n                      nearW = tempW;\n                      nearH = tempH;\n\n                    widthOut        = nearW;\n                    heightOut        = nearH;\n                    mediatypeOut    = pmtConfig->subtype;\n                  }\n\n                MyDeleteMediaType(pmtConfig);\n\n                //If we have found an exact match no need to search anymore\n                if(exactMatch)break;\n            }\n         }\n    }\n\n}\n\n\n//---------------------------------------------------------------------------------------------------\nstatic bool setSizeAndSubtype(videoDevice * VD, int attemptWidth, int attemptHeight, GUID mediatype){\n    VIDEOINFOHEADER *pVih =  reinterpret_cast<VIDEOINFOHEADER*>(VD->pAmMediaType->pbFormat);\n\n    //store current size\n    //int tmpWidth  = HEADER(pVih)->biWidth;\n    //int tmpHeight = HEADER(pVih)->biHeight;\n    AM_MEDIA_TYPE * tmpType = NULL;\n\n    HRESULT    hr = VD->streamConf->GetFormat(&tmpType);\n    if(hr != S_OK)return false;\n\n    //set new size:\n    //width and height\n    HEADER(pVih)->biWidth  = attemptWidth;\n    HEADER(pVih)->biHeight = attemptHeight;\n\n    VD->pAmMediaType->formattype = FORMAT_VideoInfo;\n    VD->pAmMediaType->majortype  = MEDIATYPE_Video;\n    VD->pAmMediaType->subtype     = mediatype;\n\n    //buffer size\n    if (mediatype == MEDIASUBTYPE_RGB24)\n    {\n        VD->pAmMediaType->lSampleSize = attemptWidth*attemptHeight*3;\n    }\n    else\n    {\n        // For compressed data, the value can be zero.\n        VD->pAmMediaType->lSampleSize = 0;\n    }\n\n    //set fps if requested\n    if( VD->requestedFrameTime != -1){\n        pVih->AvgTimePerFrame = VD->requestedFrameTime;\n    }\n\n    //okay lets try new size\n    hr = VD->streamConf->SetFormat(VD->pAmMediaType);\n    if(hr == S_OK){\n        if( tmpType != NULL )MyDeleteMediaType(tmpType);\n        return true;\n    }else{\n        VD->streamConf->SetFormat(tmpType);\n        if( tmpType != NULL )MyDeleteMediaType(tmpType);\n    }\n\n    return false;\n}\n\n```\n\u5168\u3066\u304c\u8d77\u52d5\u3059\u308b\u5834\u6240\n\u7279\u5b9a\u306e\u30c7\u30d0\u30a4\u30b9\u306b\u5bfe\u3057\u3066\u30b0\u30e9\u30d5\u3092\u30d3\u30eb\u30c9\u3057\u3088\u3046\u3068\u3059\u308b\u3002\n\nstart\u95a2\u6570\u306fdeviceID\u3068videoDevice\u3092\u5f15\u6570\u306b\u3057\u3066\u59cb\u52d5\u3059\u308b\u3002\n\u3053\u3053\u3067\u3001deviceID\u3068\u306f\u4f55\u306a\u306e\u304b\u78ba\u8a8d\u3059\u308b\u3002\n\u3084\u306f\u308a\u3001deviceID\u304c\u5f15\u6570\u306b\u306a\u3063\u3066\u3044\u308b\u304b\u3089\u3001\u30c7\u30d0\u30a4\u30b9\u306e\uff29\uff24\u3092\u53d6\u3063\u3066\u3053\u306a\u3044\u3068\u3044\u3051\u306a\u3044\u3002\n```\n// ----------------------------------------------------------------------\n// Where all the work happens!\n// Attempts to build a graph for the specified device\n// ----------------------------------------------------------------------\n\nint videoInput::start(int deviceID, videoDevice *VD){\n\n    HRESULT hr             = NOERROR;\n    VD->myID             = deviceID;\n    VD->setupStarted    = true;\n    CAPTURE_MODE           = PIN_CATEGORY_CAPTURE; //Don't worry - it ends up being preview (which is faster)\n    callbackSetCount     = 1;  //make sure callback method is not changed after setup called\n\n    DebugPrintOut(\"SETUP: Setting up device %i\\n\",deviceID);\n\n    // CREATE THE GRAPH BUILDER //\n    // Create the filter graph manager and query for interfaces.\n    hr = CoCreateInstance(CLSID_CaptureGraphBuilder2, NULL, CLSCTX_INPROC_SERVER, IID_ICaptureGraphBuilder2, (void **)&VD->pCaptureGraph);\n    if (FAILED(hr))    // FAILED is a macro that tests the return value\n    {\n        DebugPrintOut(\"ERROR - Could not create the Filter Graph Manager\\n\");\n        return hr;\n    }\n\n    //FITLER GRAPH MANAGER//\n    // Create the Filter Graph Manager.\n    hr = CoCreateInstance(CLSID_FilterGraph, 0, CLSCTX_INPROC_SERVER,IID_IGraphBuilder, (void**)&VD->pGraph);\n    if (FAILED(hr))\n    {\n        DebugPrintOut(\"ERROR - Could not add the graph builder!\\n\");\n        stopDevice(deviceID);\n        return hr;\n    }\n\n    //SET THE FILTERGRAPH//\n    hr = VD->pCaptureGraph->SetFiltergraph(VD->pGraph);\n    if (FAILED(hr))\n    {\n        DebugPrintOut(\"ERROR - Could not set filtergraph\\n\");\n        stopDevice(deviceID);\n        return hr;\n    }\n\n    //MEDIA CONTROL (START/STOPS STREAM)//\n    // Using QueryInterface on the graph builder,\n    // Get the Media Control object.\n    hr = VD->pGraph->QueryInterface(IID_IMediaControl, (void **)&VD->pControl);\n    if (FAILED(hr))\n    {\n        DebugPrintOut(\"ERROR - Could not create the Media Control object\\n\");\n        stopDevice(deviceID);\n        return hr;\n    }\n\n\n    //FIND VIDEO DEVICE AND ADD TO GRAPH//\n    //gets the device specified by the second argument.\n    hr = getDevice(&VD->pVideoInputFilter, deviceID, VD->wDeviceName, VD->nDeviceName);\n\n    if (SUCCEEDED(hr)){\n        DebugPrintOut(\"SETUP: %s\\n\", VD->nDeviceName);\n        hr = VD->pGraph->AddFilter(VD->pVideoInputFilter, VD->wDeviceName);\n    }else{\n        DebugPrintOut(\"ERROR - Could not find specified video device\\n\");\n        stopDevice(deviceID);\n        return hr;\n    }\n\n    //LOOK FOR PREVIEW PIN IF THERE IS NONE THEN WE USE CAPTURE PIN AND THEN SMART TEE TO PREVIEW\n    IAMStreamConfig *streamConfTest = NULL;\n    hr = VD->pCaptureGraph->FindInterface(&PIN_CATEGORY_PREVIEW, &MEDIATYPE_Video, VD->pVideoInputFilter, IID_IAMStreamConfig, (void **)&streamConfTest);\n    if(FAILED(hr)){\n        DebugPrintOut(\"SETUP: Couldn't find preview pin using SmartTee\\n\");\n    }else{\n         CAPTURE_MODE = PIN_CATEGORY_PREVIEW;\n         streamConfTest->Release();\n         streamConfTest = NULL;\n    }\n\n    //CROSSBAR (SELECT PHYSICAL INPUT TYPE)//\n    //my own function that checks to see if the device can support a crossbar and if so it routes it.\n    //webcams tend not to have a crossbar so this function will also detect a webcams and not apply the crossbar\n    if(VD->useCrossbar)\n    {\n        DebugPrintOut(\"SETUP: Checking crossbar\\n\");\n        routeCrossbar(&VD->pCaptureGraph, &VD->pVideoInputFilter, VD->connection, CAPTURE_MODE);\n    }\n\n\n    //we do this because webcams don't have a preview mode\n    hr = VD->pCaptureGraph->FindInterface(&CAPTURE_MODE, &MEDIATYPE_Video, VD->pVideoInputFilter, IID_IAMStreamConfig, (void **)&VD->streamConf);\n    if(FAILED(hr)){\n        DebugPrintOut(\"ERROR: Couldn't config the stream!\\n\");\n        stopDevice(deviceID);\n        return hr;\n    }\n\n    //NOW LETS DEAL WITH GETTING THE RIGHT SIZE\n    hr = VD->streamConf->GetFormat(&VD->pAmMediaType);\n    if(FAILED(hr)){\n        DebugPrintOut(\"ERROR: Couldn't getFormat for pAmMediaType!\\n\");\n        stopDevice(deviceID);\n        return hr;\n    }\n\n    VIDEOINFOHEADER *pVih =  reinterpret_cast<VIDEOINFOHEADER*>(VD->pAmMediaType->pbFormat);\n    int currentWidth    =  HEADER(pVih)->biWidth;\n    int currentHeight    =  HEADER(pVih)->biHeight;\n\n    bool customSize = VD->tryDiffSize;\n\n    bool foundSize  = false;\n\n    if(customSize){\n        DebugPrintOut(\"SETUP: Default Format is set to %ix%i\\n\", currentWidth, currentHeight);\n\n        char guidStr[8];\n            // try specified format and size\n            getMediaSubtypeAsString(VD->tryVideoType, guidStr);\n            DebugPrintOut(\"SETUP: trying specified format %s @ %ix%i\\n\", guidStr, VD->tryWidth, VD->tryHeight);\n\n            if( setSizeAndSubtype(VD, VD->tryWidth, VD->tryHeight, VD->tryVideoType) ){\n                VD->setSize(VD->tryWidth, VD->tryHeight);\n                VD->videoType = VD->tryVideoType;\n                foundSize = true;\n            } else {\n                // try specified size with all formats\n                for(int i = 0; i < VI_NUM_TYPES; i++){\n\n                    getMediaSubtypeAsString(mediaSubtypes[i], guidStr);\n\n                    DebugPrintOut(\"SETUP: trying format %s @ %ix%i\\n\", guidStr, VD->tryWidth, VD->tryHeight);\n                    if( setSizeAndSubtype(VD, VD->tryWidth, VD->tryHeight, mediaSubtypes[i]) ){\n                        VD->setSize(VD->tryWidth, VD->tryHeight);\n                        VD->videoType = mediaSubtypes[i];\n                        foundSize = true;\n                        break;\n                    }\n                }\n            }\n\n\n        //if we didn't find the requested size - lets try and find the closest matching size\n        if( foundSize == false ){\n            DebugPrintOut(\"SETUP: couldn't find requested size - searching for closest matching size\\n\");\n\n            int closestWidth        = -1;\n            int closestHeight        = -1;\n            GUID newMediaSubtype;\n\n            findClosestSizeAndSubtype(VD, VD->tryWidth, VD->tryHeight, closestWidth, closestHeight, newMediaSubtype);\n\n            if( closestWidth != -1 && closestHeight != -1){\n                getMediaSubtypeAsString(newMediaSubtype, guidStr);\n\n                DebugPrintOut(\"SETUP: closest supported size is %s @ %i %i\\n\", guidStr, closestWidth, closestHeight);\n                if( setSizeAndSubtype(VD, closestWidth, closestHeight, newMediaSubtype) ){\n                    VD->setSize(closestWidth, closestHeight);\n                    foundSize = true;\n                }\n            }\n        }\n    }\n\n    //if we didn't specify a custom size or if we did but couldn't find it lets setup with the default settings\n    if(customSize == false || foundSize == false){\n        if( VD->requestedFrameTime != -1 ){\n            pVih->AvgTimePerFrame  = VD->requestedFrameTime;\n            hr = VD->streamConf->SetFormat(VD->pAmMediaType);\n        }\n        VD->setSize(currentWidth, currentHeight);\n    }\n\n    //SAMPLE GRABBER (ALLOWS US TO GRAB THE BUFFER)//\n    // Create the Sample Grabber.\n    hr = CoCreateInstance(CLSID_SampleGrabber, NULL, CLSCTX_INPROC_SERVER,IID_IBaseFilter, (void**)&VD->pGrabberF);\n    if (FAILED(hr)){\n        DebugPrintOut(\"Could not Create Sample Grabber - CoCreateInstance()\\n\");\n        stopDevice(deviceID);\n        return hr;\n    }\n\n    hr = VD->pGraph->AddFilter(VD->pGrabberF, L\"Sample Grabber\");\n    if (FAILED(hr)){\n        DebugPrintOut(\"Could not add Sample Grabber - AddFilter()\\n\");\n        stopDevice(deviceID);\n        return hr;\n    }\n\n    hr = VD->pGrabberF->QueryInterface(IID_ISampleGrabber, (void**)&VD->pGrabber);\n    if (FAILED(hr)){\n        DebugPrintOut(\"ERROR: Could not query SampleGrabber\\n\");\n        stopDevice(deviceID);\n        return hr;\n    }\n\n\n    //Set Params - One Shot should be false unless you want to capture just one buffer\n    hr = VD->pGrabber->SetOneShot(FALSE);\n    if(bCallback){\n        hr = VD->pGrabber->SetBufferSamples(FALSE);\n    }else{\n        hr = VD->pGrabber->SetBufferSamples(TRUE);\n    }\n\n    if(bCallback){\n        //Tell the grabber to use our callback function - 0 is for SampleCB and 1 for BufferCB\n        //We use SampleCB\n        hr = VD->pGrabber->SetCallback(VD->sgCallback, 0);\n        if (FAILED(hr)){\n            DebugPrintOut(\"ERROR: problem setting callback\\n\");\n            stopDevice(deviceID);\n            return hr;\n        }else{\n            DebugPrintOut(\"SETUP: Capture callback set\\n\");\n        }\n    }\n\n    //MEDIA CONVERSION\n    //Get video properties from the stream's mediatype and apply to the grabber (otherwise we don't get an RGB image)\n    //zero the media type - lets try this :) - maybe this works?\n    AM_MEDIA_TYPE mt;\n    ZeroMemory(&mt,sizeof(AM_MEDIA_TYPE));\n\n    mt.majortype     = MEDIATYPE_Video;\n    mt.subtype         = MEDIASUBTYPE_RGB24;\n    mt.formattype     = FORMAT_VideoInfo;\n\n    //VD->pAmMediaType->subtype = VD->videoType;\n    hr = VD->pGrabber->SetMediaType(&mt);\n\n    //lets try freeing our stream conf here too\n    //this will fail if the device is already running\n    if(VD->streamConf){\n        VD->streamConf->Release();\n        VD->streamConf = NULL;\n    }else{\n        DebugPrintOut(\"ERROR: connecting device - prehaps it is already being used?\\n\");\n        stopDevice(deviceID);\n        return S_FALSE;\n    }\n\n\n    //NULL RENDERER//\n    //used to give the video stream somewhere to go to.\n    hr = CoCreateInstance(CLSID_NullRenderer, NULL, CLSCTX_INPROC_SERVER, IID_IBaseFilter, (void**)(&VD->pDestFilter));\n    if (FAILED(hr)){\n        DebugPrintOut(\"ERROR: Could not create filter - NullRenderer\\n\");\n        stopDevice(deviceID);\n        return hr;\n    }\n\n    hr = VD->pGraph->AddFilter(VD->pDestFilter, L\"NullRenderer\");\n    if (FAILED(hr)){\n        DebugPrintOut(\"ERROR: Could not add filter - NullRenderer\\n\");\n        stopDevice(deviceID);\n        return hr;\n    }\n\n    //RENDER STREAM//\n    //This is where the stream gets put together.\n    hr = VD->pCaptureGraph->RenderStream(&PIN_CATEGORY_PREVIEW, &MEDIATYPE_Video, VD->pVideoInputFilter, VD->pGrabberF, VD->pDestFilter);\n\n    if (FAILED(hr)){\n        DebugPrintOut(\"ERROR: Could not connect pins - RenderStream()\\n\");\n        stopDevice(deviceID);\n        return hr;\n    }\n\n\n    //EXP - lets try setting the sync source to null - and make it run as fast as possible\n    {\n        IMediaFilter *pMediaFilter = 0;\n        hr = VD->pGraph->QueryInterface(IID_IMediaFilter, (void**)&pMediaFilter);\n        if (FAILED(hr)){\n            DebugPrintOut(\"ERROR: Could not get IID_IMediaFilter interface\\n\");\n        }else{\n            pMediaFilter->SetSyncSource(NULL);\n            pMediaFilter->Release();\n        }\n    }\n\n\n    //LETS RUN THE STREAM!\n    hr = VD->pControl->Run();\n\n    if (FAILED(hr)){\n         DebugPrintOut(\"ERROR: Could not start graph\\n\");\n         stopDevice(deviceID);\n         return hr;\n    }\n\n\n    //MAKE SURE THE DEVICE IS SENDING VIDEO BEFORE WE FINISH\n    if(!bCallback){\n\n        long bufferSize = VD->videoSize;\n\n        while( hr != S_OK){\n            hr = VD->pGrabber->GetCurrentBuffer(&bufferSize, (long *)VD->pBuffer);\n            Sleep(10);\n        }\n\n    }\n\n    DebugPrintOut(\"SETUP: Device is setup and ready to capture.\\n\\n\");\n    VD->readyToCapture = true;\n\n    //Release filters - seen someone else do this\n    //looks like it solved the freezes\n\n    //if we release this then we don't have access to the settings\n    //we release our video input filter but then reconnect with it\n    //each time we need to use it\n    VD->pVideoInputFilter->Release();\n    VD->pVideoInputFilter = NULL;\n\n    VD->pGrabberF->Release();\n    VD->pGrabberF = NULL;\n\n    VD->pDestFilter->Release();\n    VD->pDestFilter = NULL;\n\n    return S_OK;\n}\n\n```\n\u3053\u3053\u304b\u3089\u59cb\u307e\u308b\u3068\u306e\u3053\u3068\n\n```\n\n\n\n// ----------------------------------------------------------------------\n// Returns number of good devices\n//\n// ----------------------------------------------------------------------\n\nint videoInput::getDeviceCount(){\n\n\n    ICreateDevEnum *pDevEnum = NULL;\n    IEnumMoniker *pEnum = NULL;\n    int deviceCounter = 0;\n\n    HRESULT hr = CoCreateInstance(CLSID_SystemDeviceEnum, NULL,\n        CLSCTX_INPROC_SERVER, IID_ICreateDevEnum,\n        reinterpret_cast<void**>(&pDevEnum));\n\n\n    if (SUCCEEDED(hr))\n    {\n        // Create an enumerator for the video capture category.\n        hr = pDevEnum->CreateClassEnumerator(\n            CLSID_VideoInputDeviceCategory,\n            &pEnum, 0);\n\n       if(hr == S_OK){\n            IMoniker *pMoniker = NULL;\n            while (pEnum->Next(1, &pMoniker, NULL) == S_OK){\n\n                IPropertyBag *pPropBag;\n                hr = pMoniker->BindToStorage(0, 0, IID_IPropertyBag,\n                    (void**)(&pPropBag));\n\n                if (FAILED(hr)){\n                    pMoniker->Release();\n                    continue;  // Skip this one, maybe the next one will work.\n                }\n\n                pPropBag->Release();\n                pPropBag = NULL;\n\n                pMoniker->Release();\n                pMoniker = NULL;\n\n                deviceCounter++;\n            }\n\n            pEnum->Release();\n            pEnum = NULL;\n        }\n\n        pDevEnum->Release();\n        pDevEnum = NULL;\n    }\n    return deviceCounter;\n}\n\n\n// ----------------------------------------------------------------------\n// Do we need this?\n//\n// Enumerate all of the video input devices\n// Return the filter with a matching friendly name\n// ----------------------------------------------------------------------\n\nHRESULT videoInput::getDevice(IBaseFilter** gottaFilter, int deviceId, WCHAR * wDeviceName, char * nDeviceName){\n    BOOL done = false;\n    int deviceCounter = 0;\n\n    // Create the System Device Enumerator.\n    ICreateDevEnum *pSysDevEnum = NULL;\n    HRESULT hr = CoCreateInstance(CLSID_SystemDeviceEnum, NULL, CLSCTX_INPROC_SERVER, IID_ICreateDevEnum, (void **)&pSysDevEnum);\n    if (FAILED(hr))\n    {\n        return hr;\n    }\n\n    // Obtain a class enumerator for the video input category.\n    IEnumMoniker *pEnumCat = NULL;\n    hr = pSysDevEnum->CreateClassEnumerator(CLSID_VideoInputDeviceCategory, &pEnumCat, 0);\n\n    if (hr == S_OK)\n    {\n        // Enumerate the monikers.\n        IMoniker *pMoniker = NULL;\n        ULONG cFetched;\n        while ((pEnumCat->Next(1, &pMoniker, &cFetched) == S_OK) && (!done))\n        {\n            if(deviceCounter == deviceId)\n            {\n                // Bind the first moniker to an object\n                IPropertyBag *pPropBag;\n                hr = pMoniker->BindToStorage(0, 0, IID_IPropertyBag, (void **)&pPropBag);\n                if (SUCCEEDED(hr))\n                {\n                    // To retrieve the filter's friendly name, do the following:\n                    VARIANT varName;\n                    VariantInit(&varName);\n                    hr = pPropBag->Read(L\"FriendlyName\", &varName, 0);\n                    if (SUCCEEDED(hr))\n                    {\n\n                        //copy the name to nDeviceName & wDeviceName\n                        int count = 0;\n                        while( varName.bstrVal[count] != 0x00 ) {\n                               wDeviceName[count] = varName.bstrVal[count];\n                               nDeviceName[count] = (char)varName.bstrVal[count];\n                               count++;\n                         }\n\n                        // We found it, so send it back to the caller\n                        hr = pMoniker->BindToObject(NULL, NULL, IID_IBaseFilter, (void**)gottaFilter);\n                        done = true;\n                    }\n                    VariantClear(&varName);\n                    pPropBag->Release();\n                    pPropBag = NULL;\n                    pMoniker->Release();\n                    pMoniker = NULL;\n                }\n            }\n            deviceCounter++;\n        }\n        pEnumCat->Release();\n        pEnumCat = NULL;\n    }\n    pSysDevEnum->Release();\n    pSysDevEnum = NULL;\n\n    if (done) {\n        return hr;    // found it, return native error\n    } else {\n        return VFW_E_NOT_FOUND;    // didn't find it error\n    }\n}\n\n\n// ----------------------------------------------------------------------\n// Show the property pages for a filter\n// This is stolen from the DX9 SDK\n// ----------------------------------------------------------------------\n\nHRESULT videoInput::ShowFilterPropertyPages(IBaseFilter *pFilter){\n\n    ISpecifyPropertyPages *pProp;\n\n    HRESULT hr = pFilter->QueryInterface(IID_ISpecifyPropertyPages, (void **)&pProp);\n    if (SUCCEEDED(hr))\n    {\n        // Get the filter's name and IUnknown pointer.\n        FILTER_INFO FilterInfo;\n        hr = pFilter->QueryFilterInfo(&FilterInfo);\n        IUnknown *pFilterUnk;\n        pFilter->QueryInterface(IID_IUnknown, (void **)&pFilterUnk);\n\n        // Show the page.\n        CAUUID caGUID;\n        pProp->GetPages(&caGUID);\n        pProp->Release();\n        OleCreatePropertyFrame(\n            NULL,                   // Parent window\n            0, 0,                   // Reserved\n            FilterInfo.achName,     // Caption for the dialog box\n            1,                      // Number of objects (just the filter)\n            &pFilterUnk,            // Array of object pointers.\n            caGUID.cElems,          // Number of property pages\n            caGUID.pElems,          // Array of property page CLSIDs\n            0,                      // Locale identifier\n            0, NULL                 // Reserved\n        );\n\n        // Clean up.\n        if(pFilterUnk)pFilterUnk->Release();\n        if(FilterInfo.pGraph)FilterInfo.pGraph->Release();\n        CoTaskMemFree(caGUID.pElems);\n    }\n    return hr;\n}\n\nHRESULT videoInput::ShowStreamPropertyPages(IAMStreamConfig  * /*pStream*/){\n\n    HRESULT hr             = NOERROR;\n    return hr;\n}\n\n```\n\n\u3053\u3053\u3067\u30d5\u30a3\u30eb\u30bf\u30fc\u3092\u8aad\u307f\u8fbc\u3093\u3067\u3044\u308b\u306e\u3060\u308d\u3046\u304b\uff1f\n\n```\n\n\n\n// ----------------------------------------------------------------------\n// This code was also brazenly stolen from the DX9 SDK\n// Pass it a file name in wszPath, and it will save the filter graph to that file.\n// ----------------------------------------------------------------------\n\nHRESULT videoInput::SaveGraphFile(IGraphBuilder *pGraph, WCHAR *wszPath) {\n    const WCHAR wszStreamName[] = L\"ActiveMovieGraph\";\n    HRESULT hr;\n    IStorage *pStorage = NULL;\n\n    // First, create a document file which will hold the GRF file\n    hr = StgCreateDocfile(\n        wszPath,\n        STGM_CREATE | STGM_TRANSACTED | STGM_READWRITE | STGM_SHARE_EXCLUSIVE,\n        0, &pStorage);\n    if(FAILED(hr))\n    {\n        return hr;\n    }\n\n    // Next, create a stream to store.\n    IStream *pStream;\n    hr = pStorage->CreateStream(\n        wszStreamName,\n        STGM_WRITE | STGM_CREATE | STGM_SHARE_EXCLUSIVE,\n        0, 0, &pStream);\n    if (FAILED(hr))\n    {\n        pStorage->Release();\n        return hr;\n    }\n\n    // The IPersistStream converts a stream into a persistent object.\n    IPersistStream *pPersist = NULL;\n    pGraph->QueryInterface(IID_IPersistStream, reinterpret_cast<void**>(&pPersist));\n    hr = pPersist->Save(pStream, TRUE);\n    pStream->Release();\n    pPersist->Release();\n    if (SUCCEEDED(hr))\n    {\n        hr = pStorage->Commit(STGC_DEFAULT);\n    }\n    pStorage->Release();\n    return hr;\n}\n\n\n// ----------------------------------------------------------------------\n// For changing the input types\n//\n// ----------------------------------------------------------------------\n\nHRESULT videoInput::routeCrossbar(ICaptureGraphBuilder2 **ppBuild, IBaseFilter **pVidInFilter, int conType, GUID captureMode){\n\n    //create local ICaptureGraphBuilder2\n    ICaptureGraphBuilder2 *pBuild = NULL;\n     pBuild = *ppBuild;\n\n     //create local IBaseFilter\n     IBaseFilter *pVidFilter = NULL;\n     pVidFilter = * pVidInFilter;\n\n    // Search upstream for a crossbar.\n    IAMCrossbar *pXBar1 = NULL;\n    HRESULT hr = pBuild->FindInterface(&LOOK_UPSTREAM_ONLY, NULL, pVidFilter,\n            IID_IAMCrossbar, (void**)&pXBar1);\n    if (SUCCEEDED(hr))\n    {\n\n        bool foundDevice = false;\n\n        DebugPrintOut(\"SETUP: You are not a webcam! Setting Crossbar\\n\");\n        pXBar1->Release();\n\n        IAMCrossbar *Crossbar;\n        hr = pBuild->FindInterface(&captureMode, &MEDIATYPE_Interleaved, pVidFilter, IID_IAMCrossbar, (void **)&Crossbar);\n\n        if(hr != NOERROR){\n            hr = pBuild->FindInterface(&captureMode, &MEDIATYPE_Video, pVidFilter, IID_IAMCrossbar, (void **)&Crossbar);\n        }\n\n        LONG lInpin, lOutpin;\n        hr = Crossbar->get_PinCounts(&lOutpin , &lInpin);\n\n        BOOL iPin=TRUE; LONG pIndex=0 , pRIndex=0 , pType=0;\n\n        while( pIndex < lInpin)\n        {\n            hr = Crossbar->get_CrossbarPinInfo( iPin , pIndex , &pRIndex , &pType);\n\n            if( pType == conType){\n                    DebugPrintOut(\"SETUP: Found Physical Interface\");\n\n                    switch(conType){\n\n                        case PhysConn_Video_Composite:\n                            DebugPrintOut(\" - Composite\\n\");\n                            break;\n                        case PhysConn_Video_SVideo:\n                            DebugPrintOut(\" - S-Video\\n\");\n                            break;\n                        case PhysConn_Video_Tuner:\n                            DebugPrintOut(\" - Tuner\\n\");\n                            break;\n                        case PhysConn_Video_USB:\n                            DebugPrintOut(\" - USB\\n\");\n                            break;\n                        case PhysConn_Video_1394:\n                            DebugPrintOut(\" - Firewire\\n\");\n                            break;\n                    }\n\n                foundDevice = true;\n                break;\n            }\n            pIndex++;\n\n        }\n\n        if(foundDevice){\n            BOOL OPin=FALSE; LONG pOIndex=0 , pORIndex=0 , pOType=0;\n            while( pOIndex < lOutpin)\n            {\n                hr = Crossbar->get_CrossbarPinInfo( OPin , pOIndex , &pORIndex , &pOType);\n                if( pOType == PhysConn_Video_VideoDecoder)\n                    break;\n            }\n            Crossbar->Route(pOIndex,pIndex);\n        }else{\n            DebugPrintOut(\"SETUP: Didn't find specified Physical Connection type. Using Defualt.\\n\");\n        }\n\n        //we only free the crossbar when we close or restart the device\n        //we were getting a crash otherwise\n        //if(Crossbar)Crossbar->Release();\n        //if(Crossbar)Crossbar = NULL;\n\n        if(pXBar1)pXBar1->Release();\n        if(pXBar1)pXBar1 = NULL;\n\n    }else{\n        DebugPrintOut(\"SETUP: You are a webcam or snazzy firewire cam! No Crossbar needed\\n\");\n        return hr;\n    }\n\n    return hr;\n}\n\nnamespace cv\n{\nvideoInput VideoCapture_DShow::g_VI;\n\nVideoCapture_DShow::VideoCapture_DShow(int index)\n    : m_index(-1)\n    , m_width(-1)\n    , m_height(-1)\n    , m_fourcc(-1)\n    , m_widthSet(-1)\n    , m_heightSet(-1)\n{\n    CoInitialize(0);\n    open(index);\n}\nVideoCapture_DShow::~VideoCapture_DShow()\n{\n    close();\n    CoUninitialize();\n}\n\ndouble VideoCapture_DShow::getProperty(int propIdx) const\n{\n\n    long min_value, max_value, stepping_delta, current_value, flags, defaultValue;\n\n    switch (propIdx)\n    {\n    // image format properties\n    case CV_CAP_PROP_FRAME_WIDTH:\n        return g_VI.getWidth(m_index);\n    case CV_CAP_PROP_FRAME_HEIGHT:\n        return g_VI.getHeight(m_index);\n    case CV_CAP_PROP_FOURCC:\n        return g_VI.getFourcc(m_index);\n    case CV_CAP_PROP_FPS:\n        return g_VI.getFPS(m_index);\n\n    // video filter properties\n    case CV_CAP_PROP_BRIGHTNESS:\n    case CV_CAP_PROP_CONTRAST:\n    case CV_CAP_PROP_HUE:\n    case CV_CAP_PROP_SATURATION:\n    case CV_CAP_PROP_SHARPNESS:\n    case CV_CAP_PROP_GAMMA:\n    case CV_CAP_PROP_MONOCHROME:\n    case CV_CAP_PROP_WHITE_BALANCE_BLUE_U:\n    case CV_CAP_PROP_BACKLIGHT:\n    case CV_CAP_PROP_GAIN:\n        if (g_VI.getVideoSettingFilter(m_index, g_VI.getVideoPropertyFromCV(propIdx), min_value, max_value, stepping_delta, current_value, flags, defaultValue))\n            return (double)current_value;\n\n    // camera properties\n    case CV_CAP_PROP_PAN:\n    case CV_CAP_PROP_TILT:\n    case CV_CAP_PROP_ROLL:\n    case CV_CAP_PROP_ZOOM:\n    case CV_CAP_PROP_EXPOSURE:\n    case CV_CAP_PROP_IRIS:\n    case CV_CAP_PROP_FOCUS:\n        if (g_VI.getVideoSettingCamera(m_index, g_VI.getCameraPropertyFromCV(propIdx), min_value, max_value, stepping_delta, current_value, flags, defaultValue))\n            return (double)current_value;\n    }\n\n    // unknown parameter or value not available\n    return -1;\n}\nbool VideoCapture_DShow::setProperty(int propIdx, double propVal)\n{\n    // image capture properties\n    bool handled = false;\n    switch (propIdx)\n    {\n    case CV_CAP_PROP_FRAME_WIDTH:\n        m_width = cvRound(propVal);\n        handled = true;\n        break;\n\n    case CV_CAP_PROP_FRAME_HEIGHT:\n        m_height = cvRound(propVal);\n        handled = true;\n        break;\n\n    case CV_CAP_PROP_FOURCC:\n        m_fourcc = (int)(unsigned long)(propVal);\n        if (-1 == m_fourcc)\n        {\n            // following cvCreateVideo usage will pop up caprturepindialog here if fourcc=-1\n            // TODO - how to create a capture pin dialog\n        }\n        handled = true;\n        break;\n\n    case CV_CAP_PROP_FPS:\n        int fps = cvRound(propVal);\n        if (fps != g_VI.getFPS(m_index))\n        {\n            g_VI.stopDevice(m_index);\n            g_VI.setIdealFramerate(m_index, fps);\n            if (m_widthSet > 0 && m_heightSet > 0)\n                g_VI.setupDevice(m_index, m_widthSet, m_heightSet);\n            else\n                g_VI.setupDevice(m_index);\n        }\n        return g_VI.isDeviceSetup(m_index);\n    }\n\n    if (handled)\n    {\n        // a stream setting\n        if (m_width > 0 && m_height > 0)\n        {\n            if (m_width != g_VI.getWidth(m_index) || m_height != g_VI.getHeight(m_index) )//|| fourcc != VI.getFourcc(index) )\n            {\n                int fps = static_cast<int>(g_VI.getFPS(m_index));\n                g_VI.stopDevice(m_index);\n                g_VI.setIdealFramerate(m_index, fps);\n                g_VI.setupDeviceFourcc(m_index, m_width, m_height, m_fourcc);\n            }\n\n            bool success = g_VI.isDeviceSetup(m_index);\n            if (success)\n            {\n                m_widthSet = m_width;\n                m_heightSet = m_height;\n                m_width = m_height = m_fourcc = -1;\n            }\n            return success;\n        }\n        return true;\n    }\n\n    // show video/camera filter dialog\n    if (propIdx == CV_CAP_PROP_SETTINGS )\n    {\n        g_VI.showSettingsWindow(m_index);\n        return true;\n    }\n\n    //video Filter properties\n    switch (propIdx)\n    {\n    case CV_CAP_PROP_BRIGHTNESS:\n    case CV_CAP_PROP_CONTRAST:\n    case CV_CAP_PROP_HUE:\n    case CV_CAP_PROP_SATURATION:\n    case CV_CAP_PROP_SHARPNESS:\n    case CV_CAP_PROP_GAMMA:\n    case CV_CAP_PROP_MONOCHROME:\n    case CV_CAP_PROP_WHITE_BALANCE_BLUE_U:\n    case CV_CAP_PROP_BACKLIGHT:\n    case CV_CAP_PROP_GAIN:\n        return g_VI.setVideoSettingFilter(m_index, g_VI.getVideoPropertyFromCV(propIdx), (long)propVal);\n    }\n\n    //camera properties\n    switch (propIdx)\n    {\n    case CV_CAP_PROP_PAN:\n    case CV_CAP_PROP_TILT:\n    case CV_CAP_PROP_ROLL:\n    case CV_CAP_PROP_ZOOM:\n    case CV_CAP_PROP_EXPOSURE:\n    case CV_CAP_PROP_IRIS:\n    case CV_CAP_PROP_FOCUS:\n        return g_VI.setVideoSettingCamera(m_index, g_VI.getCameraPropertyFromCV(propIdx), (long)propVal);\n    }\n\n    return false;\n}\n\nbool VideoCapture_DShow::grabFrame()\n{\n    return true;\n}\nbool VideoCapture_DShow::retrieveFrame(int, OutputArray frame)\n{\n    frame.create(Size(g_VI.getWidth(m_index), g_VI.getHeight(m_index)), CV_8UC3);\n    cv::Mat mat = frame.getMat();\n    return g_VI.getPixels(m_index, mat.ptr(), false, true );\n}\nint VideoCapture_DShow::getCaptureDomain()\n{\n    return CV_CAP_DSHOW;\n}\nbool VideoCapture_DShow::isOpened() const\n{\n    return (-1 != m_index);\n}\n\nvoid VideoCapture_DShow::open(int index)\n{\n    close();\n    int devices = g_VI.listDevices(true);\n    if (0 == devices)\n        return;\n    if (index < 0 || index > devices-1)\n        return;\n    g_VI.setupDevice(index);\n    if (!g_VI.isDeviceSetup(index))\n        return;\n    m_index = index;\n}\n\nvoid VideoCapture_DShow::close()\n{\n    if (m_index >= 0)\n    {\n        g_VI.stopDevice(m_index);\n        m_index = -1;\n    }\n    m_widthSet = m_heightSet = m_width = m_height = -1;\n}\n\n}\n\n#endif\n\n```\n", "tags": ["OpenCV", "directShow"]}