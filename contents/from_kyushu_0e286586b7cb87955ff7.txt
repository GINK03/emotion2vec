{"context": "\u6a2a\u6d5c\u3078\u306a\u3061\u3087\u3053\u30d7\u30ed\u30b0\u30e9\u30df\u30f3\u30b0\u52c9\u5f37\u4f1a\u306b\u3066\u904e\u53bb\u306b\u51fa\u984c\u3055\u308c\u305f\u3081\u3050\u308b\u30bb\u30eb\u3092\u89e3\u3044\u3066\u307f\u305f\u3002\n\u56de\u7b54\u306b\u304b\u304b\u3063\u305f\u6642\u9593\u306f\u304e\u308a\u304e\u308a60\u5206\u3002\n\n\u6307\u5b9a\u30bb\u30eb\u306e\u5916\u5468\u3092\u53d6\u5f97\n\u5916\u5468\u3092\u6642\u8a08\u56de\u308a\u3055\u305b\u3084\u3059\u3044\u3088\u3046\u306b\u30bd\u30fc\u30c8\n\nArray.rotate\u3067\u6642\u8a08\u56de\u308a\u3068\u306a\u308b\u3088\u3046\u306b\u30bb\u30eb\u306e\u5165\u308c\u66ff\u3048\n\u5165\u308c\u66ff\u3048\u305f\u30bb\u30eb\u306e\u5185\u5bb9\u3092\u8fd4\u3059\n\n\u3082\u3046\u3061\u3087\u3063\u3068\u3046\u307e\u3044\u3084\u308a\u65b9\u304c\u3042\u3063\u305f\u3093\u3058\u3083\u306a\u3044\u3060\u308d\u3046\u304b\u3068\u601d\u3046\u304c\u3001\u8003\u3048\u3066\u3044\u308b\u3070\u304b\u308a\u3067\u6642\u9593\u304c\u904e\u304e\u3066\u3057\u307e\u3063\u305f\u306e\u3067\u3072\u3068\u307e\u305a\u771f\u3063\u5148\u306b\u601d\u3044\u3064\u3044\u305f\u65b9\u6cd5\u3067\u5b9f\u88c5\u3057\u3066\u3057\u307e\u3063\u305f\u3002\nclass RotationBox\n  def initialize\n    chars = (?a..?y).to_a\n    @sort_priority = [:top_left, :top, :top_right, :right, :bottom_right, :bottom, :bottom_left, :left]\n    @box = 5.times.map{|y|\n      5.times.map{|x|\n        chars[(y * 5) + x]\n      }\n    }\n  end\n\n  def rotate_all input\n    last = input.scan(/(\\w)(\\w)/).inject([]){|r, (a, b)|\n      rotate a, b\n    }\n    last.empty? ? \"none\" : last.sort.join\n  end\n\n  private\n\n  def axis val\n    @box.each.with_index.inject([nil, nil]){|r, (line, y)|\n      if x = line.find_index(val)\n        break [x, y]\n      else\n        r\n      end\n    }\n  end\n\n  def rotate a, b\n    ax, ay = axis a\n    bx, by = axis b\n    top, bottom, left, right = [\n      ay < by ? ay : by,\n      ay > by ? ay : by,\n      ax < bx ? ax : bx,\n      ax > bx ? ax : bx\n    ]\n    round = round(top, bottom, left, right).sort{|(axx, ayy), (bxx, byy)|\n      position_a = position axx, ayy, top, bottom, left, right\n      position_b = position bxx, byy, top, bottom, left, right\n      if position_a == :top and position_b == :top\n        axx <=> bxx\n      elsif position_a == :right and position_b == :right\n        ayy <=> byy\n      elsif position_a == :bottom and position_b == :bottom\n        (axx <=> bxx) * -1\n      elsif position_a == :left and position_b == :left\n        (ayy <=> byy) * -1\n      else\n        @sort_priority.index(position_a) <=> @sort_priority.index(position_b)\n      end\n    }\n    round.map{|(x, y)| @box[y][x]}.rotate(-1).each.with_index{|c, i|\n      x, y = round[i]\n      @box[y][x] = c\n    }\n  end\n\n  def block top, bottom, left, right\n    5.times.select{|x|\n      x.between? left, right\n    }.product(5.times.select{|y|\n      y.between? top, bottom\n    })\n  end\n\n  def round top, bottom, left, right\n    block = block top, bottom, left, right\n    block.map{|(x, y)|\n      [\n        [x - 1, y - 1], [x    , y - 1], [x + 1, y - 1],\n        [x - 1, y    ], [x + 1, y    ],\n        [x - 1, y + 1], [x    , y + 1], [x + 1, y + 1]\n      ].select{|xx, yy|\n        xx.between?(0, 4) && yy.between?(0, 4) && !block.include?([xx, yy])\n      }\n    }.flatten(1).uniq\n  end\n\n  def position x, y, top, bottom, left, right\n    if top > y\n      left > x ? :top_left : (right < x ? :top_right : :top)\n    elsif bottom < y\n      left > x ? :bottom_left : (right < x ? :bottom_right : :bottom)\n    elsif left > x\n      :left\n    elsif right < x\n      :right\n    end\n  end\nend\n\ntest = <<_TEST\n/*0*/ test( \"ab,gg,uj,pt,an,ir,rr\", \"hpqsvwxy\" );    \n/*1*/ test( \"gs,ok\", \"abcdftvwxy\" );    \n/*2*/ test( \"gs,sg,ok\", \"none\" );    \n/*3*/ test( \"aa,bb,hh,nn\", \"hiostwxy\" );    \n/*4*/ test( \"ae,ko,uy,cw\", \"bdgilnqsvx\" );    \n/*5*/ test( \"am,gs,am,gs,am,gs,am,gs\", \"cfhkmqrvwx\" );    \n/*6*/ test( \"ay\", \"none\" );    \n/*7*/ test( \"gs,ay\", \"defjkoptuv\" );    \n/*8*/ test( \"bx,ay\", \"none\" );    \n/*9*/ test( \"ft,ay\", \"defjkoptuv\" );    \n/*10*/ test( \"ab,cd,ef,gh,ij,kl,mn,op,qr,st,uv,wx\", \"cdjmnry\" );    \n/*11*/ test( \"wx,uv,st,qr,op,mn,kl,ij,gh,ef,cd,ab\", \"kmoxy\" );    \n/*12*/ test( \"am,cj,ac,em,ss,cy,aa,ee,ff,vp\", \"none\" );    \n/*13*/ test( \"uf,oq,gn,ss,ca,hv,ej\", \"none\" );    \n/*14*/ test( \"cc,wk,uu,ws,bk,aa,vv\", \"bei\" );    \n/*15*/ test( \"tr,ou,ll,pp,jh,vf,yy,nr,rr,oo\", \"rxy\" );    \n/*16*/ test( \"ky,ov,ri,qm,nn,ee,ws,em,ca,ak\", \"biju\" );    \n/*17*/ test( \"ty\", \"nosx\" );    \n/*18*/ test( \"ll,uh,hq,ss,nx,ry,ku,ab,jj\", \"efouv\" );    \n/*19*/ test( \"yl,mu,qj,ss,ep\", \"mnqru\" );    \n/*20*/ test( \"kj,ee,qk\", \"fglruv\" );    \n/*21*/ test( \"xi,wd,hf\", \"ciknqr\" );    \n/*22*/ test( \"fx,ak,cc,ce\", \"bdhijnp\" );    \n/*23*/ test( \"li,jf,pp,qm,hg,sf\", \"akntuwx\" );    \n/*24*/ test( \"jw\", \"bcdeglqv\" );    \n/*25*/ test( \"uk,oe,xr\", \"dglmoqsy\" );    \n/*26*/ test( \"bb,ov,pd,dd,xk,is,hh,xd,xx,kq,pp,ku\", \"cfhjopqvy\" );    \n/*27*/ test( \"iq,fn,il,ww,ox,la,or,ga,wg,ef,us\", \"cfgjopvxy\" );    \n/*28*/ test( \"km,po\", \"abcdenqrst\" );    \n/*29*/ test( \"tc,mh,cw\", \"abefjkoptu\" );    \n/*30*/ test( \"fm,jx,xx,pi,gs,au,uq,ut,ap,vb\", \"cdghjmortux\" );    \n/*31*/ test( \"ik,xl,si\", \"abcdflorvwx\" );    \n/*32*/ test( \"nu,cc,lv,bu,tt,ww,xk,ia,in,sa,my\", \"abcefgpqrstu\" );    \n/*33*/ test( \"tt,ak,xh,tk,oo,yr,na,yv,gm,vh\", \"degiklmnquwx\" );    \n/*34*/ test( \"kk,ob,kk,fm,xk\", \"acdegjlopqruy\" );    \n/*35*/ test( \"uq,ko,pf,yy,ig,tu,ve,ve,qy,mh,oo,dv\", \"befjkoqrtuwxy\" );    \n/*36*/ test( \"aj,hb,ar,ii,np,ki,hg,vd\", \"cefhjlmopqtwxy\" );    \n/*37*/ test( \"vv,sf,ww,my,mm,sq,fb,ly,fu,ls\", \"bfghkmnptuvwxy\" );    \n/*38*/ test( \"jj,bp,gs\", \"abdefijkprtuvwxy\" );    \n/*39*/ test( \"sv,sn,mn,gn,gi\", \"abcdefhjnpqtuvxy\" );\n_TEST\n\nrequire 'minitest/autorun'\n\ndescribe 'Rotate' do\n  test.split(\"\\n\").each do |line|\n    t, n, input, expect = line.match(/^\\/\\*(\\d+)\\*\\/\\s*test\\(\\s*\"([^\"]+)\",\\s*\"([^\"]+)\"\\s*\\);*\\s*$/).to_a\n    box = RotationBox.new\n    it input do\n      assert_equal expect, box.rotate_all(input)\n    end\n  end\nend\n\n\n[\u6a2a\u6d5c\u3078\u306a\u3061\u3087\u3053\u30d7\u30ed\u30b0\u30e9\u30df\u30f3\u30b0\u52c9\u5f37\u4f1a](https://yhpg.doorkeeper.jp/)\u306b\u3066\u904e\u53bb\u306b\u51fa\u984c\u3055\u308c\u305f[\u3081\u3050\u308b\u30bb\u30eb](http://nabetani.sakura.ne.jp/hena/ord25rotcell/)\u3092\u89e3\u3044\u3066\u307f\u305f\u3002\n\u56de\u7b54\u306b\u304b\u304b\u3063\u305f\u6642\u9593\u306f\u304e\u308a\u304e\u308a60\u5206\u3002\n\n1. \u6307\u5b9a\u30bb\u30eb\u306e\u5916\u5468\u3092\u53d6\u5f97\n2. \u5916\u5468\u3092\u6642\u8a08\u56de\u308a\u3055\u305b\u3084\u3059\u3044\u3088\u3046\u306b\u30bd\u30fc\u30c8\n3. `Array.rotate`\u3067\u6642\u8a08\u56de\u308a\u3068\u306a\u308b\u3088\u3046\u306b\u30bb\u30eb\u306e\u5165\u308c\u66ff\u3048\n4. \u5165\u308c\u66ff\u3048\u305f\u30bb\u30eb\u306e\u5185\u5bb9\u3092\u8fd4\u3059\n\n\u3082\u3046\u3061\u3087\u3063\u3068\u3046\u307e\u3044\u3084\u308a\u65b9\u304c\u3042\u3063\u305f\u3093\u3058\u3083\u306a\u3044\u3060\u308d\u3046\u304b\u3068\u601d\u3046\u304c\u3001\u8003\u3048\u3066\u3044\u308b\u3070\u304b\u308a\u3067\u6642\u9593\u304c\u904e\u304e\u3066\u3057\u307e\u3063\u305f\u306e\u3067\u3072\u3068\u307e\u305a\u771f\u3063\u5148\u306b\u601d\u3044\u3064\u3044\u305f\u65b9\u6cd5\u3067\u5b9f\u88c5\u3057\u3066\u3057\u307e\u3063\u305f\u3002\n\n```ruby\nclass RotationBox\n  def initialize\n    chars = (?a..?y).to_a\n    @sort_priority = [:top_left, :top, :top_right, :right, :bottom_right, :bottom, :bottom_left, :left]\n    @box = 5.times.map{|y|\n      5.times.map{|x|\n        chars[(y * 5) + x]\n      }\n    }\n  end\n\n  def rotate_all input\n    last = input.scan(/(\\w)(\\w)/).inject([]){|r, (a, b)|\n      rotate a, b\n    }\n    last.empty? ? \"none\" : last.sort.join\n  end\n\n  private\n\n  def axis val\n    @box.each.with_index.inject([nil, nil]){|r, (line, y)|\n      if x = line.find_index(val)\n        break [x, y]\n      else\n        r\n      end\n    }\n  end\n\n  def rotate a, b\n    ax, ay = axis a\n    bx, by = axis b\n    top, bottom, left, right = [\n      ay < by ? ay : by,\n      ay > by ? ay : by,\n      ax < bx ? ax : bx,\n      ax > bx ? ax : bx\n    ]\n    round = round(top, bottom, left, right).sort{|(axx, ayy), (bxx, byy)|\n      position_a = position axx, ayy, top, bottom, left, right\n      position_b = position bxx, byy, top, bottom, left, right\n      if position_a == :top and position_b == :top\n        axx <=> bxx\n      elsif position_a == :right and position_b == :right\n        ayy <=> byy\n      elsif position_a == :bottom and position_b == :bottom\n        (axx <=> bxx) * -1\n      elsif position_a == :left and position_b == :left\n        (ayy <=> byy) * -1\n      else\n        @sort_priority.index(position_a) <=> @sort_priority.index(position_b)\n      end\n    }\n    round.map{|(x, y)| @box[y][x]}.rotate(-1).each.with_index{|c, i|\n      x, y = round[i]\n      @box[y][x] = c\n    }\n  end\n\n  def block top, bottom, left, right\n    5.times.select{|x|\n      x.between? left, right\n    }.product(5.times.select{|y|\n      y.between? top, bottom\n    })\n  end\n\n  def round top, bottom, left, right\n    block = block top, bottom, left, right\n    block.map{|(x, y)|\n      [\n        [x - 1, y - 1], [x    , y - 1], [x + 1, y - 1],\n        [x - 1, y    ], [x + 1, y    ],\n        [x - 1, y + 1], [x    , y + 1], [x + 1, y + 1]\n      ].select{|xx, yy|\n        xx.between?(0, 4) && yy.between?(0, 4) && !block.include?([xx, yy])\n      }\n    }.flatten(1).uniq\n  end\n\n  def position x, y, top, bottom, left, right\n    if top > y\n      left > x ? :top_left : (right < x ? :top_right : :top)\n    elsif bottom < y\n      left > x ? :bottom_left : (right < x ? :bottom_right : :bottom)\n    elsif left > x\n      :left\n    elsif right < x\n      :right\n    end\n  end\nend\n\ntest = <<_TEST\n/*0*/ test( \"ab,gg,uj,pt,an,ir,rr\", \"hpqsvwxy\" );    \n/*1*/ test( \"gs,ok\", \"abcdftvwxy\" );    \n/*2*/ test( \"gs,sg,ok\", \"none\" );    \n/*3*/ test( \"aa,bb,hh,nn\", \"hiostwxy\" );    \n/*4*/ test( \"ae,ko,uy,cw\", \"bdgilnqsvx\" );    \n/*5*/ test( \"am,gs,am,gs,am,gs,am,gs\", \"cfhkmqrvwx\" );    \n/*6*/ test( \"ay\", \"none\" );    \n/*7*/ test( \"gs,ay\", \"defjkoptuv\" );    \n/*8*/ test( \"bx,ay\", \"none\" );    \n/*9*/ test( \"ft,ay\", \"defjkoptuv\" );    \n/*10*/ test( \"ab,cd,ef,gh,ij,kl,mn,op,qr,st,uv,wx\", \"cdjmnry\" );    \n/*11*/ test( \"wx,uv,st,qr,op,mn,kl,ij,gh,ef,cd,ab\", \"kmoxy\" );    \n/*12*/ test( \"am,cj,ac,em,ss,cy,aa,ee,ff,vp\", \"none\" );    \n/*13*/ test( \"uf,oq,gn,ss,ca,hv,ej\", \"none\" );    \n/*14*/ test( \"cc,wk,uu,ws,bk,aa,vv\", \"bei\" );    \n/*15*/ test( \"tr,ou,ll,pp,jh,vf,yy,nr,rr,oo\", \"rxy\" );    \n/*16*/ test( \"ky,ov,ri,qm,nn,ee,ws,em,ca,ak\", \"biju\" );    \n/*17*/ test( \"ty\", \"nosx\" );    \n/*18*/ test( \"ll,uh,hq,ss,nx,ry,ku,ab,jj\", \"efouv\" );    \n/*19*/ test( \"yl,mu,qj,ss,ep\", \"mnqru\" );    \n/*20*/ test( \"kj,ee,qk\", \"fglruv\" );    \n/*21*/ test( \"xi,wd,hf\", \"ciknqr\" );    \n/*22*/ test( \"fx,ak,cc,ce\", \"bdhijnp\" );    \n/*23*/ test( \"li,jf,pp,qm,hg,sf\", \"akntuwx\" );    \n/*24*/ test( \"jw\", \"bcdeglqv\" );    \n/*25*/ test( \"uk,oe,xr\", \"dglmoqsy\" );    \n/*26*/ test( \"bb,ov,pd,dd,xk,is,hh,xd,xx,kq,pp,ku\", \"cfhjopqvy\" );    \n/*27*/ test( \"iq,fn,il,ww,ox,la,or,ga,wg,ef,us\", \"cfgjopvxy\" );    \n/*28*/ test( \"km,po\", \"abcdenqrst\" );    \n/*29*/ test( \"tc,mh,cw\", \"abefjkoptu\" );    \n/*30*/ test( \"fm,jx,xx,pi,gs,au,uq,ut,ap,vb\", \"cdghjmortux\" );    \n/*31*/ test( \"ik,xl,si\", \"abcdflorvwx\" );    \n/*32*/ test( \"nu,cc,lv,bu,tt,ww,xk,ia,in,sa,my\", \"abcefgpqrstu\" );    \n/*33*/ test( \"tt,ak,xh,tk,oo,yr,na,yv,gm,vh\", \"degiklmnquwx\" );    \n/*34*/ test( \"kk,ob,kk,fm,xk\", \"acdegjlopqruy\" );    \n/*35*/ test( \"uq,ko,pf,yy,ig,tu,ve,ve,qy,mh,oo,dv\", \"befjkoqrtuwxy\" );    \n/*36*/ test( \"aj,hb,ar,ii,np,ki,hg,vd\", \"cefhjlmopqtwxy\" );    \n/*37*/ test( \"vv,sf,ww,my,mm,sq,fb,ly,fu,ls\", \"bfghkmnptuvwxy\" );    \n/*38*/ test( \"jj,bp,gs\", \"abdefijkprtuvwxy\" );    \n/*39*/ test( \"sv,sn,mn,gn,gi\", \"abcdefhjnpqtuvxy\" );\n_TEST\n\nrequire 'minitest/autorun'\n\ndescribe 'Rotate' do\n  test.split(\"\\n\").each do |line|\n    t, n, input, expect = line.match(/^\\/\\*(\\d+)\\*\\/\\s*test\\(\\s*\"([^\"]+)\",\\s*\"([^\"]+)\"\\s*\\);*\\s*$/).to_a\n    box = RotationBox.new\n    it input do\n      assert_equal expect, box.rotate_all(input)\n    end\n  end\nend\n```\n", "tags": ["Ruby", "\u3069\u3046\u66f8\u304f", "yhpg"]}