{"tags": ["Pepper"], "context": " More than 1 year has passed since last update.\n\u4eca\u65e5\u306e\u30cf\u30c3\u30ab\u30bd\u30f3\u306e\u3001\u97f3\u306e\u65b9\u5411\u306bPepper\u304c\u52d5\u3044\u3066\u304f\u308c\u308bBox\u3092\u5fd8\u308c\u306a\u3044\u3046\u3061\u306b\u30e1\u30e2\u3002\u5404\u30d1\u30e9\u30e1\u30fc\u30bf\u306f\u4ee5\u4e0b\u3002\n\n\n\u300cWait3\u300dbox\u306f\u300160\u79d2\u3002\u300cWait4\u300dbox\u306f3\u79d2\u3067\u8a2d\u5b9a\u3057\u307e\u3057\u305f\u3002\n\u300cMove Toward\u300dbox\u306binput\u3092\u4e00\u3064\u8ffd\u52a0\u3002(input\u306e\u4ed8\u8fd1\u3067\u53f3\u30af\u30ea\u30c3\u30af\u3067\u3001AddInput\u3059\u308c\u3070\u753b\u9762\u3067\u307e\u3059\u3002)\n\n\u305d\u3057\u3066\u3001\u6700\u5f8c\u306b\u300cMove Toward\u300dbox\u3092\u30c0\u30d6\u30eb\u30af\u30ea\u30c3\u30af\u3057\u3066\u3001\n\u982d\u306b\nimport math\n\u3092\u8ffd\u52a0\u3002\u305d\u3057\u3066\ndef onInput_inputxy(self, p):\n    self.lock.acquire()\n    try:\n        self.test = p[0]\n        self.shouldRun = True\n        self.updateMovement()\n\n    finally:\n        self.lock.release()\n\n\u3092\u8ffd\u52a0\u3057\u3066\ndef updateMovement(self):\u306e\n        #x = self.getParameter(\"X\")\n        #y = self.getParameter(\"Y\")\n        x = math.cos(self.test)\n        y = math.sin(self.test)\n\n\u306e\u66f8\u304d\u63db\u3048\u3092\u3059\u308c\u3070\u5b8c\u4e86\u3067\u3059\u3002\n\u5168\u4f53\u306e\u30bd\u30fc\u30b9\u306f\u4ee5\u4e0b\u306b\u3002\u305f\u3060\u6642\u9593\u5185\u306b\u52d5\u304b\u3059\u76ee\u7684\u3060\u3051\u306b\u4f5c\u3063\u305f\u306e\u3067\u3054\u4e86\u627f\u304f\u3060\u3055\u3044\u3002\nimport time\nimport math\nimport threading\nclass MyClass(GeneratedClass):\n    def init(self):\n        GeneratedClass.init(self, False)\ndef onLoad(self):\n    self.motion = ALProxy(\"ALMotion\")\n    self.shouldRun = False\n    self.x = 0\n    self.y = 0\n    self.theta = 0\n    self.timer = None\n    self.lock = threading.RLock()\n\ndef onUnload(self):\n    self.lock.acquire()\n    try:\n        self.shouldRun = False\n        if self.timer:\n            self.timer.cancel()\n            self.timer = None\n\n        self.x = 0\n        self.y = 0\n        self.theta = 0\n        self.motion.moveToward(0, 0, 0)\n        self.motion.waitUntilMoveIsFinished()\n    finally:\n        self.lock.release()\n\ndef onInput_onStop(self):\n    self.lock.acquire()\n    try:\n        self.onUnload()\n        self.onStopped()\n    finally:\n        self.lock.release()\n\ndef onInput_onStart(self):\n    self.lock.acquire()\n    try:\n        self.shouldRun = True\n        self.updateMovement()\n    finally:\n        self.lock.release()\n\ndef onInput_inputxy(self, p):\n    self.lock.acquire()\n    try:\n        self.test = p[0]\n        self.shouldRun = True\n        self.updateMovement()\n\n    finally:\n        self.lock.release()\n\ndef updateMovement(self):\n    self.lock.acquire()\n    try:\n        if self.timer:\n            self.timer.cancel()\n            self.timer = None\n        enableArms = self.getParameter(\"Arms movement enabled\")\n        self.motion.setMoveArmsEnabled(enableArms, enableArms)\n        #x = self.getParameter(\"X\")\n        #y = self.getParameter(\"Y\")\n        x = math.cos(self.test)\n        y = math.sin(self.test)\n        theta = self.getParameter(\"Theta\")\n        period = self.getParameter(\"Period of direction update (s)\")\n        epsilon = 0.0001\n        dx = math.fabs(x - self.x)\n        dy = math.fabs(y - self.y)\n        dt = math.fabs((theta - self.theta))\n        if(dx > epsilon or dy > epsilon or dt > epsilon):\n            self.x=x\n            self.y=y\n            self.theta=theta\n            self.motion.moveToward(self.x, self.y, self.theta)\n\n        if self.shouldRun:\n            self.timer = threading.Timer(period, self.updateMovement)\n            self.timer.start()\n    finally:\n        self.lock.release()\n\n\u4ee5\u4e0a\n![SoundLoation.png](https://qiita-image-store.s3.amazonaws.com/0/58907/33eea609-a0a4-f895-ba91-fab3fddd05f7.png)\n\n\u4eca\u65e5\u306e\u30cf\u30c3\u30ab\u30bd\u30f3\u306e\u3001\u97f3\u306e\u65b9\u5411\u306bPepper\u304c\u52d5\u3044\u3066\u304f\u308c\u308bBox\u3092\u5fd8\u308c\u306a\u3044\u3046\u3061\u306b\u30e1\u30e2\u3002\u5404\u30d1\u30e9\u30e1\u30fc\u30bf\u306f\u4ee5\u4e0b\u3002\n\n![soundLocparam.png](https://qiita-image-store.s3.amazonaws.com/0/58907/5dcb703b-4b3e-4e3a-99c4-e3fb3f88ccbc.png)\n![moveTowardParampng.png](https://qiita-image-store.s3.amazonaws.com/0/58907/8faaf4c5-a894-b50f-6e6b-6aee33a16222.png)\n\u300cWait3\u300dbox\u306f\u300160\u79d2\u3002\u300cWait4\u300dbox\u306f3\u79d2\u3067\u8a2d\u5b9a\u3057\u307e\u3057\u305f\u3002\n\n\u300cMove Toward\u300dbox\u306binput\u3092\u4e00\u3064\u8ffd\u52a0\u3002(input\u306e\u4ed8\u8fd1\u3067\u53f3\u30af\u30ea\u30c3\u30af\u3067\u3001AddInput\u3059\u308c\u3070\u753b\u9762\u3067\u307e\u3059\u3002)\n![inputxy.png](https://qiita-image-store.s3.amazonaws.com/0/58907/87fa8219-6e8b-bc54-bedf-d0ff6839723b.png)\n\u305d\u3057\u3066\u3001\u6700\u5f8c\u306b\u300cMove Toward\u300dbox\u3092\u30c0\u30d6\u30eb\u30af\u30ea\u30c3\u30af\u3057\u3066\u3001\n\n\u982d\u306b\n\nimport math\n\n\u3092\u8ffd\u52a0\u3002\u305d\u3057\u3066\n\n    def onInput_inputxy(self, p):\n        self.lock.acquire()\n        try:\n            self.test = p[0]\n            self.shouldRun = True\n            self.updateMovement()\n\n        finally:\n            self.lock.release()\n\n\u3092\u8ffd\u52a0\u3057\u3066\n\n    def updateMovement(self):\u306e\n            #x = self.getParameter(\"X\")\n            #y = self.getParameter(\"Y\")\n            x = math.cos(self.test)\n            y = math.sin(self.test)\n\u306e\u66f8\u304d\u63db\u3048\u3092\u3059\u308c\u3070\u5b8c\u4e86\u3067\u3059\u3002\n\n\u5168\u4f53\u306e\u30bd\u30fc\u30b9\u306f\u4ee5\u4e0b\u306b\u3002\u305f\u3060\u6642\u9593\u5185\u306b\u52d5\u304b\u3059\u76ee\u7684\u3060\u3051\u306b\u4f5c\u3063\u305f\u306e\u3067\u3054\u4e86\u627f\u304f\u3060\u3055\u3044\u3002\n\nimport time\nimport math\nimport threading\n\nclass MyClass(GeneratedClass):\n    def __init__(self):\n        GeneratedClass.__init__(self, False)\n\n    def onLoad(self):\n        self.motion = ALProxy(\"ALMotion\")\n        self.shouldRun = False\n        self.x = 0\n        self.y = 0\n        self.theta = 0\n        self.timer = None\n        self.lock = threading.RLock()\n\n    def onUnload(self):\n        self.lock.acquire()\n        try:\n            self.shouldRun = False\n            if self.timer:\n                self.timer.cancel()\n                self.timer = None\n\n            self.x = 0\n            self.y = 0\n            self.theta = 0\n            self.motion.moveToward(0, 0, 0)\n            self.motion.waitUntilMoveIsFinished()\n        finally:\n            self.lock.release()\n\n    def onInput_onStop(self):\n        self.lock.acquire()\n        try:\n            self.onUnload()\n            self.onStopped()\n        finally:\n            self.lock.release()\n\n    def onInput_onStart(self):\n        self.lock.acquire()\n        try:\n            self.shouldRun = True\n            self.updateMovement()\n        finally:\n            self.lock.release()\n\n    def onInput_inputxy(self, p):\n        self.lock.acquire()\n        try:\n            self.test = p[0]\n            self.shouldRun = True\n            self.updateMovement()\n\n        finally:\n            self.lock.release()\n\n    def updateMovement(self):\n        self.lock.acquire()\n        try:\n            if self.timer:\n                self.timer.cancel()\n                self.timer = None\n            enableArms = self.getParameter(\"Arms movement enabled\")\n            self.motion.setMoveArmsEnabled(enableArms, enableArms)\n            #x = self.getParameter(\"X\")\n            #y = self.getParameter(\"Y\")\n            x = math.cos(self.test)\n            y = math.sin(self.test)\n            theta = self.getParameter(\"Theta\")\n            period = self.getParameter(\"Period of direction update (s)\")\n            epsilon = 0.0001\n            dx = math.fabs(x - self.x)\n            dy = math.fabs(y - self.y)\n            dt = math.fabs((theta - self.theta))\n            if(dx > epsilon or dy > epsilon or dt > epsilon):\n                self.x=x\n                self.y=y\n                self.theta=theta\n                self.motion.moveToward(self.x, self.y, self.theta)\n\n            if self.shouldRun:\n                self.timer = threading.Timer(period, self.updateMovement)\n                self.timer.start()\n        finally:\n            self.lock.release()\n\n\u4ee5\u4e0a\n\n"}