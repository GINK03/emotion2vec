{"context": " More than 1 year has passed since last update.Windows7 x86-64, MSYS2, GCC\n\n\u30de\u30eb\u30c1\u30b9\u30ec\u30c3\u30c9 + \u30b7\u30b0\u30ca\u30eb\n\u3000\u30de\u30eb\u30c1\u30b9\u30ec\u30c3\u30c9\u3068\u30b7\u30b0\u30ca\u30eb\u306e\u4f75\u7528\u306f\u53ef\u80fd\u306a\u9650\u308a\u907f\u3051\u308b\u3079\u304d...\u3089\u3057\u3044\u3002\u7406\u7531\u306f\u3001\u51e6\u7406\u304c\u8907\u96d1\u306b\u306a\u308b\u3068\u304b\u3002\n\u3000\u3067\u3082\u30de\u30eb\u30c1\u30b9\u30ec\u30c3\u30c9\u30fb\u30a2\u30d7\u30ea\u30b1\u30fc\u30b7\u30e7\u30f3\u3067Control-C\uff08SIGINT\uff09\u3092\u53d7\u3051\u53d6\u3063\u305f\u3089\u8d77\u52d5\u4e2d\u306e\u30b9\u30ec\u30c3\u30c9\u3092\u6b63\u5e38\u306b\u7d42\u4e86\u3055\u305b\u305f\u3044\u3068\u3044\u3063\u305f\u30b1\u30fc\u30b9\u306f\u7d50\u69cb\u3042\u308b\u3088\u3046\u306b\u601d\u3044\u307e\u3059\u3002pthread\u3092\u4f7f\u3046\u5834\u5408\u306fpthread_kill(3)\u3084pthread_sigqueue(3)\u3067\u5404\u30b9\u30ec\u30c3\u30c9\u306b\u30b7\u30b0\u30ca\u30eb\u3092\u9001\u4fe1\u3067\u304d\u308b\u3068\u304b\u3002\n\u3000\u8003\u3048\u305f\u306e\u306f\n\n\u30b9\u30ec\u30c3\u30c9ID\u3092\u4fdd\u5b58\u3057\u3066\u304a\u3044\u3066\u3001\u30b7\u30b0\u30ca\u30eb\u3092\u53d7\u4fe1\u3057\u305f\u3089\u30cf\u30f3\u30c9\u30e9\u304b\u3089\u4ed6\u306e\u30b9\u30ec\u30c3\u30c9\u3092kill\u3057\u3066\u304b\u3089exit\n\u30b0\u30ed\u30fc\u30d0\u30eb\u5909\u6570\u306e\u30d5\u30e9\u30b0\u3067\u6761\u4ef6\u7d42\u4e86\u3055\u305b\u308b\n\n\u3067\u3001\u3068\u308a\u3042\u3048\u305a2.\u3067\u5b9f\u88c5\u3057\u3066\u307f\u308b\u3002\u30e1\u30a4\u30f3\u30b9\u30ec\u30c3\u30c9\u306e\u7d42\u4e86\u30bf\u30a4\u30df\u30f3\u30b0\u306f\u5404\u30b9\u30ec\u30c3\u30c9\u304c\u7d42\u4e86\u3057\u3066\u304b\u3089\u3067\u306a\u3044\u3068\u610f\u5473\u304c\u7121\u3044\u306e\u3067\u3001\u5404\u30b9\u30ec\u30c3\u30c9\u306e\u7d42\u4e86\u306e\u691c\u51fa\u306f\u30b9\u30ec\u30c3\u30c9\u6570\u3092\u30ab\u30a6\u30f3\u30c8\u3059\u308b\u3053\u3068\u306b\u3002\u3053\u306e\u30ab\u30a6\u30f3\u30c8\u304c\u4e0a\u624b\u304f\u3044\u304b\u306a\u3044\u3068\u30e1\u30a4\u30f3\u30b9\u30ec\u30c3\u30c9\u304c\u3044\u3064\u307e\u3067\u305f\u3063\u3066\u3082\u7d42\u4e86\u3057\u306a\u3044\u5834\u5408\u304c\u3042\u308b\u306e\u3067\u3001\u691c\u51fa\u6642\u306bpthread_timedlock(3)\u3092\u4f7f\u3046\u3002\u3067\u3082\u30a4\u30f3\u30af\u30ea\u30e1\u30f3\u30c8\u3068\u30c7\u30af\u30ea\u30e1\u30f3\u30c8\u306e\u5bfe\u5fdc\u304c\u53d6\u308c\u306a\u3044\u3068\u3001\u3084\u306f\u308a\u76ee\u7684\u306e\u5168\u30b9\u30ec\u30c3\u30c9\u306e\u6b63\u5e38\u7d42\u4e86\u306f\u5b9f\u73fe\u3067\u304d\u306a\u3044\u3002\u3053\u306e\u30c7\u30e1\u30ea\u30c3\u30c8\u3092\u8003\u3048\u308b\u3068\u30011.\u306e\u307b\u3046\u304c\u3044\u3044\u6c17\u304c\u3059\u308b\u3002\n\u305d\u308c\u304b\u3089pthread_t\u306e\u5b9a\u7fa9\u306f\u6574\u6570\u3067\u3082\u69cb\u9020\u4f53\u3067\u3082\u826f\u3044\u3053\u3068\u306b\u306a\u3063\u3066\u3044\u308b\u3002\u3053\u306e\u30b3\u30fc\u30c9\u306f\u6574\u6570\u3092\u524d\u63d0\u306b\u3057\u3066\u3044\u308b\u306e\u3067\u53ef\u642c\u6027\u304c\u306a\u3044\u3002\n\u53c2\u7167:\n\nhttp://kaworu.jpn.org/c/pthread%E3%81%AE%E3%82%B9%E3%83%AC%E3%83%83%E3%83%89%E8%AD%98%E5%88%A5%E5%AD%90pthread_t%E5%9E%8B\nhttp://www.wdic.org/w/TECH/pthread_t\n\n\u6ce8\uff1a\u3053\u306e\u8a2d\u8a08\u306f\u30b7\u30b0\u30ca\u30eb\u51e6\u7406\u306e\u8106\u5f31\u6027\u306e\u4ed6\u3001\u8272\u3005\u3068\u554f\u984c\u304c\u3042\u308b\u306e\u3067\u53c2\u8003\u306b\u306f\u3057\u306a\u3044\u3067\u304f\u3060\u3055\u3044\u3002\n\nthreads-with-sigint\n#include <stdio.h>\n#include <unistd.h>\n#include <pthread.h>\n#include <signal.h>\n#include <stdbool.h>\n#include <stdarg.h>\n\n/******************\n* utils for debug *\n******************/\n\nstatic pthread_mutex_t stderr_mtx = PTHREAD_MUTEX_INITIALIZER;\n\nstatic void\ndie(char const* msg) {\n    pthread_mutex_lock(&stderr_mtx);\n\n    perror(msg);\n\n    pthread_mutex_unlock(&stderr_mtx);\n\n    exit(1);\n}\n\nstatic void\nmes(char const* fmt, ...) {\n    pthread_mutex_lock(&stderr_mtx);\n\n    va_list args;\n    va_start(args, fmt);\n    vfprintf(stderr, fmt, args);\n    va_end(args);\n    fprintf(stderr, \"\\n\");\n    fflush(stderr);\n\n    pthread_mutex_unlock(&stderr_mtx);\n}\n\n/******************************\n* sigint for signal of SIGINT *\n******************************/\n\nstatic struct {\n    bool enable;\n    pthread_mutex_t mutex;\n} sigint = {\n    .enable = false,\n    .mutex = PTHREAD_MUTEX_INITIALIZER,\n};\n\nstatic bool\nsigint_is_enable(void) {\n    if (pthread_mutex_lock(&sigint.mutex) != 0) {\n        die(\"pthread_mutex_lock\");\n    }\n\n    bool enable = sigint.enable;\n\n    if (pthread_mutex_unlock(&sigint.mutex) != 0) {\n        die(\"pthread_mutex_unlock\");\n    }\n\n    return enable;\n}\n\nstatic void\nsigint_set(bool value) {\n    if (pthread_mutex_lock(&sigint.mutex) != 0) {\n        die(\"pthread_mutex_lock\");\n    }\n\n    sigint.enable = value;\n\n    if (pthread_mutex_unlock(&sigint.mutex) != 0) {\n        die(\"pthread_mutex_unlock\");\n    }\n}\n\n/*******************************\n* threads for count of threads *\n*******************************/\n\nstatic struct {\n    int count;\n    pthread_mutex_t mutex;\n} threads = {\n    .count = 0,\n    .mutex = PTHREAD_MUTEX_INITIALIZER,\n};\n\nstatic int\nthreads_increment(void) {\n    if (pthread_mutex_lock(&threads.mutex) != 0) {\n        die(\"pthread_mutex_lock\");\n    }\n\n    int current = ++threads.count;\n\n    if (pthread_mutex_unlock(&threads.mutex) != 0) {\n        die(\"pthread_mutex_unlock\");\n    }\n\n    return current;\n}\n\nstatic int\nthreads_decrement(void) {\n    if (pthread_mutex_lock(&threads.mutex) != 0) {\n        die(\"pthread_mutex_lock\");\n    }\n\n    int current = 0;\n\n    if (threads.count > 0) {\n        current = --threads.count;\n    }\n\n    if (pthread_mutex_unlock(&threads.mutex) != 0) {\n        die(\"pthread_mutex_unlock\");\n    }\n\n    return current; \n}\n\nstatic bool\nthreads_is_empty(void) {\n    static const struct timespec wait = {\n        .tv_sec = 10,\n        .tv_nsec = 0,\n    };\n\n    if (pthread_mutex_timedlock(&threads.mutex, &wait) != 0) {\n        die(\"pthread_mutex_lock\");\n    }\n\n    bool is_empty = threads.count == 0;\n\n    if (pthread_mutex_unlock(&threads.mutex) != 0) {\n        die(\"pthread_mutex_unlock\");\n    }\n\n    return is_empty;\n}\n\n/***********************\n* thread start routine *\n***********************/\n\nstatic void*\nthread_main(void* arg) {\n    pthread_t tid = pthread_self();\n\n    // \u30b9\u30ec\u30c3\u30c9\u6570\u3092\u30a4\u30f3\u30af\u30ea\u30e1\u30f3\u30c8\n    threads_increment();\n\n    mes(\"Thread %d: Running...\", tid);\n\n    for (int i = 0; ; ++i) {\n        mes(\"Thread %d: Count %d\", tid, i);\n\n        // SIGINT\u3092\u53d7\u3051\u53d6\u3063\u305f\uff1f\n        if (sigint_is_enable()) {\n            break;\n        }\n\n        sleep(1);\n    }\n\n    // \u3053\u306e\u30b9\u30ec\u30c3\u30c9\u5206\u3092\u30c7\u30af\u30ea\u30e1\u30f3\u30c8\n    threads_decrement();\n\n    mes(\"Thread %d: Done\", tid);\n    return NULL;\n}\n\n/*****************\n* signal handler *\n*****************/\n\nstatic void\nsignal_handler(int sig) {\n    if (sig == SIGINT) {\n        // mes()\u306f\u5185\u90e8\u3067\u540c\u671f\u5b89\u5168\u3067\u306a\u3044fprintf()\u7b49\u3092\u547c\u3076\u305f\u3081\u52d5\u4f5c\u304c\u672a\u5b9a\u7fa9\u306b\u306a\u308b\n        // \u30cf\u30f3\u30c9\u30e9\u5185\u3067\u306f\u540c\u671f\u5b89\u5168\u306a\u95a2\u6570\u3057\u304b\u30b3\u30fc\u30eb\u3067\u304d\u306a\u3044\n        mes(\"Signal handler thread %d: Catch SIGINT\", pthread_self());\n\n        // sigint_set()\u3082\u5185\u90e8\u3067pthread_mutex_lock(), pthread_mutex_unlock()\u3092\u547c\u3076\u305f\u3081\u52d5\u4f5c\u306f\u672a\u5b9a\u7fa9\n        // pthread_mutex\u30d5\u30a1\u30df\u30ea\u306f\u540c\u671f\u5b89\u5168\u3067\u306f\u306a\u3044\n        sigint_set(true);\n    }\n}\n\n/*******\n* test *\n*******/\n\nint\nmain(int argc, char* argv[]) {\n    pthread_t tid = pthread_self();\n\n    // \u30b7\u30b0\u30ca\u30eb\u30fb\u30cf\u30f3\u30c9\u30e9\u306e\u8a2d\u5b9a\n    signal(SIGINT, signal_handler);\n\n    for (;;) {\n        // \u4f55\u3089\u304b\u306e\u5165\u529b\u5f85\u3061\n        mes(\"Main thread %d: Input...\", tid);\n        sleep(1);\n\n        // SIGINT\u3092\u53d7\u3051\u53d6\u3063\u305f\uff1f\n        if (sigint_is_enable()) {\n            mes(\"Main thread %d: Catched SIGINT\", tid);\n            break;\n        }\n\n        // \u30b9\u30ec\u30c3\u30c9\u3092\u4f5c\u3063\u3066\u30c7\u30bf\u30c3\u30c1\n        pthread_t tid;\n\n        if (pthread_create(&tid, NULL, thread_main, NULL) != 0) {\n            die(\"pthread_create\");\n        }\n\n        if (pthread_detach(tid) != 0) {\n            die(\"pthread_detach\");\n        }\n    }\n\n    // \u5404\u30b9\u30ec\u30c3\u30c9\u306e\u7d42\u4e86\u5f85\u3061\n    for (; !threads_is_empty(); ) {\n    }\n\n    mes(\"Main thread %d: Done\", tid);\n    return 0;\n}\n\n\n\nWindows7 x86-64, MSYS2, GCC\n\n# \u30de\u30eb\u30c1\u30b9\u30ec\u30c3\u30c9 + \u30b7\u30b0\u30ca\u30eb\n\n\u3000\u30de\u30eb\u30c1\u30b9\u30ec\u30c3\u30c9\u3068\u30b7\u30b0\u30ca\u30eb\u306e\u4f75\u7528\u306f\u53ef\u80fd\u306a\u9650\u308a\u907f\u3051\u308b\u3079\u304d...\u3089\u3057\u3044\u3002\u7406\u7531\u306f\u3001\u51e6\u7406\u304c\u8907\u96d1\u306b\u306a\u308b\u3068\u304b\u3002\n\u3000\u3067\u3082\u30de\u30eb\u30c1\u30b9\u30ec\u30c3\u30c9\u30fb\u30a2\u30d7\u30ea\u30b1\u30fc\u30b7\u30e7\u30f3\u3067Control-C\uff08SIGINT\uff09\u3092\u53d7\u3051\u53d6\u3063\u305f\u3089\u8d77\u52d5\u4e2d\u306e\u30b9\u30ec\u30c3\u30c9\u3092\u6b63\u5e38\u306b\u7d42\u4e86\u3055\u305b\u305f\u3044\u3068\u3044\u3063\u305f\u30b1\u30fc\u30b9\u306f\u7d50\u69cb\u3042\u308b\u3088\u3046\u306b\u601d\u3044\u307e\u3059\u3002pthread\u3092\u4f7f\u3046\u5834\u5408\u306fpthread_kill(3)\u3084pthread_sigqueue(3)\u3067\u5404\u30b9\u30ec\u30c3\u30c9\u306b\u30b7\u30b0\u30ca\u30eb\u3092\u9001\u4fe1\u3067\u304d\u308b\u3068\u304b\u3002\n\u3000\u8003\u3048\u305f\u306e\u306f\n\n1. \u30b9\u30ec\u30c3\u30c9ID\u3092\u4fdd\u5b58\u3057\u3066\u304a\u3044\u3066\u3001\u30b7\u30b0\u30ca\u30eb\u3092\u53d7\u4fe1\u3057\u305f\u3089\u30cf\u30f3\u30c9\u30e9\u304b\u3089\u4ed6\u306e\u30b9\u30ec\u30c3\u30c9\u3092kill\u3057\u3066\u304b\u3089exit\n2. \u30b0\u30ed\u30fc\u30d0\u30eb\u5909\u6570\u306e\u30d5\u30e9\u30b0\u3067\u6761\u4ef6\u7d42\u4e86\u3055\u305b\u308b\n\n\u3067\u3001\u3068\u308a\u3042\u3048\u305a2.\u3067\u5b9f\u88c5\u3057\u3066\u307f\u308b\u3002\u30e1\u30a4\u30f3\u30b9\u30ec\u30c3\u30c9\u306e\u7d42\u4e86\u30bf\u30a4\u30df\u30f3\u30b0\u306f\u5404\u30b9\u30ec\u30c3\u30c9\u304c\u7d42\u4e86\u3057\u3066\u304b\u3089\u3067\u306a\u3044\u3068\u610f\u5473\u304c\u7121\u3044\u306e\u3067\u3001\u5404\u30b9\u30ec\u30c3\u30c9\u306e\u7d42\u4e86\u306e\u691c\u51fa\u306f\u30b9\u30ec\u30c3\u30c9\u6570\u3092\u30ab\u30a6\u30f3\u30c8\u3059\u308b\u3053\u3068\u306b\u3002\u3053\u306e\u30ab\u30a6\u30f3\u30c8\u304c\u4e0a\u624b\u304f\u3044\u304b\u306a\u3044\u3068\u30e1\u30a4\u30f3\u30b9\u30ec\u30c3\u30c9\u304c\u3044\u3064\u307e\u3067\u305f\u3063\u3066\u3082\u7d42\u4e86\u3057\u306a\u3044\u5834\u5408\u304c\u3042\u308b\u306e\u3067\u3001\u691c\u51fa\u6642\u306bpthread_timedlock(3)\u3092\u4f7f\u3046\u3002\u3067\u3082\u30a4\u30f3\u30af\u30ea\u30e1\u30f3\u30c8\u3068\u30c7\u30af\u30ea\u30e1\u30f3\u30c8\u306e\u5bfe\u5fdc\u304c\u53d6\u308c\u306a\u3044\u3068\u3001\u3084\u306f\u308a\u76ee\u7684\u306e\u5168\u30b9\u30ec\u30c3\u30c9\u306e\u6b63\u5e38\u7d42\u4e86\u306f\u5b9f\u73fe\u3067\u304d\u306a\u3044\u3002\u3053\u306e\u30c7\u30e1\u30ea\u30c3\u30c8\u3092\u8003\u3048\u308b\u3068\u30011.\u306e\u307b\u3046\u304c\u3044\u3044\u6c17\u304c\u3059\u308b\u3002\n\n\u305d\u308c\u304b\u3089pthread_t\u306e\u5b9a\u7fa9\u306f\u6574\u6570\u3067\u3082\u69cb\u9020\u4f53\u3067\u3082\u826f\u3044\u3053\u3068\u306b\u306a\u3063\u3066\u3044\u308b\u3002\u3053\u306e\u30b3\u30fc\u30c9\u306f\u6574\u6570\u3092\u524d\u63d0\u306b\u3057\u3066\u3044\u308b\u306e\u3067\u53ef\u642c\u6027\u304c\u306a\u3044\u3002\n\u53c2\u7167:\n\n * http://kaworu.jpn.org/c/pthread%E3%81%AE%E3%82%B9%E3%83%AC%E3%83%83%E3%83%89%E8%AD%98%E5%88%A5%E5%AD%90pthread_t%E5%9E%8B\n * http://www.wdic.org/w/TECH/pthread_t\n\n***\u6ce8\uff1a***\u3053\u306e\u8a2d\u8a08\u306f\u30b7\u30b0\u30ca\u30eb\u51e6\u7406\u306e\u8106\u5f31\u6027\u306e\u4ed6\u3001\u8272\u3005\u3068\u554f\u984c\u304c\u3042\u308b\u306e\u3067\u53c2\u8003\u306b\u306f\u3057\u306a\u3044\u3067\u304f\u3060\u3055\u3044\u3002\n\n```c:threads-with-sigint\n#include <stdio.h>\n#include <unistd.h>\n#include <pthread.h>\n#include <signal.h>\n#include <stdbool.h>\n#include <stdarg.h>\n\n/******************\n* utils for debug *\n******************/\n\nstatic pthread_mutex_t stderr_mtx = PTHREAD_MUTEX_INITIALIZER;\n\nstatic void\ndie(char const* msg) {\n\tpthread_mutex_lock(&stderr_mtx);\n\t\n\tperror(msg);\n\t\n\tpthread_mutex_unlock(&stderr_mtx);\n\n\texit(1);\n}\n\nstatic void\nmes(char const* fmt, ...) {\n\tpthread_mutex_lock(&stderr_mtx);\n\t\n\tva_list args;\n\tva_start(args, fmt);\n\tvfprintf(stderr, fmt, args);\n\tva_end(args);\n\tfprintf(stderr, \"\\n\");\n\tfflush(stderr);\n\n\tpthread_mutex_unlock(&stderr_mtx);\n}\n\n/******************************\n* sigint for signal of SIGINT *\n******************************/\n\nstatic struct {\n\tbool enable;\n\tpthread_mutex_t mutex;\n} sigint = {\n\t.enable = false,\n\t.mutex = PTHREAD_MUTEX_INITIALIZER,\n};\n\nstatic bool\nsigint_is_enable(void) {\n\tif (pthread_mutex_lock(&sigint.mutex) != 0) {\n\t\tdie(\"pthread_mutex_lock\");\n\t}\n\n\tbool enable = sigint.enable;\n\n\tif (pthread_mutex_unlock(&sigint.mutex) != 0) {\n\t\tdie(\"pthread_mutex_unlock\");\n\t}\n\n\treturn enable;\n}\n\nstatic void\nsigint_set(bool value) {\n\tif (pthread_mutex_lock(&sigint.mutex) != 0) {\n\t\tdie(\"pthread_mutex_lock\");\n\t}\n\n\tsigint.enable = value;\n\n\tif (pthread_mutex_unlock(&sigint.mutex) != 0) {\n\t\tdie(\"pthread_mutex_unlock\");\n\t}\n}\n\n/*******************************\n* threads for count of threads *\n*******************************/\n\nstatic struct {\n\tint count;\n\tpthread_mutex_t mutex;\n} threads = {\n\t.count = 0,\n\t.mutex = PTHREAD_MUTEX_INITIALIZER,\n};\n\nstatic int\nthreads_increment(void) {\n\tif (pthread_mutex_lock(&threads.mutex) != 0) {\n\t\tdie(\"pthread_mutex_lock\");\n\t}\n\n\tint current = ++threads.count;\n\n\tif (pthread_mutex_unlock(&threads.mutex) != 0) {\n\t\tdie(\"pthread_mutex_unlock\");\n\t}\n\n\treturn current;\n}\n\nstatic int\nthreads_decrement(void) {\n\tif (pthread_mutex_lock(&threads.mutex) != 0) {\n\t\tdie(\"pthread_mutex_lock\");\n\t}\n\n\tint current = 0;\n\t\n\tif (threads.count > 0) {\n\t\tcurrent = --threads.count;\n\t}\n\n\tif (pthread_mutex_unlock(&threads.mutex) != 0) {\n\t\tdie(\"pthread_mutex_unlock\");\n\t}\n\n\treturn current;\t\n}\n\nstatic bool\nthreads_is_empty(void) {\n\tstatic const struct timespec wait = {\n\t\t.tv_sec = 10,\n\t\t.tv_nsec = 0,\n\t};\n\n\tif (pthread_mutex_timedlock(&threads.mutex, &wait) != 0) {\n\t\tdie(\"pthread_mutex_lock\");\n\t}\n\n\tbool is_empty = threads.count == 0;\n\n\tif (pthread_mutex_unlock(&threads.mutex) != 0) {\n\t\tdie(\"pthread_mutex_unlock\");\n\t}\n\n\treturn is_empty;\n}\n\n/***********************\n* thread start routine *\n***********************/\n\nstatic void*\nthread_main(void* arg) {\n\tpthread_t tid = pthread_self();\n\n\t// \u30b9\u30ec\u30c3\u30c9\u6570\u3092\u30a4\u30f3\u30af\u30ea\u30e1\u30f3\u30c8\n\tthreads_increment();\n\n\tmes(\"Thread %d: Running...\", tid);\n\n\tfor (int i = 0; ; ++i) {\n\t\tmes(\"Thread %d: Count %d\", tid, i);\n\n\t\t// SIGINT\u3092\u53d7\u3051\u53d6\u3063\u305f\uff1f\n\t\tif (sigint_is_enable()) {\n\t\t\tbreak;\n\t\t}\n\n\t\tsleep(1);\n\t}\n\n\t// \u3053\u306e\u30b9\u30ec\u30c3\u30c9\u5206\u3092\u30c7\u30af\u30ea\u30e1\u30f3\u30c8\n\tthreads_decrement();\n\n\tmes(\"Thread %d: Done\", tid);\n\treturn NULL;\n}\n\n/*****************\n* signal handler *\n*****************/\n\nstatic void\nsignal_handler(int sig) {\n\tif (sig == SIGINT) {\n\t\t// mes()\u306f\u5185\u90e8\u3067\u540c\u671f\u5b89\u5168\u3067\u306a\u3044fprintf()\u7b49\u3092\u547c\u3076\u305f\u3081\u52d5\u4f5c\u304c\u672a\u5b9a\u7fa9\u306b\u306a\u308b\n\t\t// \u30cf\u30f3\u30c9\u30e9\u5185\u3067\u306f\u540c\u671f\u5b89\u5168\u306a\u95a2\u6570\u3057\u304b\u30b3\u30fc\u30eb\u3067\u304d\u306a\u3044\n\t\tmes(\"Signal handler thread %d: Catch SIGINT\", pthread_self());\n\n\t\t// sigint_set()\u3082\u5185\u90e8\u3067pthread_mutex_lock(), pthread_mutex_unlock()\u3092\u547c\u3076\u305f\u3081\u52d5\u4f5c\u306f\u672a\u5b9a\u7fa9\n\t\t// pthread_mutex\u30d5\u30a1\u30df\u30ea\u306f\u540c\u671f\u5b89\u5168\u3067\u306f\u306a\u3044\n\t\tsigint_set(true);\n\t}\n}\n\n/*******\n* test *\n*******/\n\nint\nmain(int argc, char* argv[]) {\n\tpthread_t tid = pthread_self();\n\n\t// \u30b7\u30b0\u30ca\u30eb\u30fb\u30cf\u30f3\u30c9\u30e9\u306e\u8a2d\u5b9a\n\tsignal(SIGINT, signal_handler);\n\n\tfor (;;) {\n\t\t// \u4f55\u3089\u304b\u306e\u5165\u529b\u5f85\u3061\n\t\tmes(\"Main thread %d: Input...\", tid);\n\t\tsleep(1);\n\n\t\t// SIGINT\u3092\u53d7\u3051\u53d6\u3063\u305f\uff1f\n\t\tif (sigint_is_enable()) {\n\t\t\tmes(\"Main thread %d: Catched SIGINT\", tid);\n\t\t\tbreak;\n\t\t}\n\n\t\t// \u30b9\u30ec\u30c3\u30c9\u3092\u4f5c\u3063\u3066\u30c7\u30bf\u30c3\u30c1\n\t\tpthread_t tid;\n\n\t\tif (pthread_create(&tid, NULL, thread_main, NULL) != 0) {\n\t\t\tdie(\"pthread_create\");\n\t\t}\n\n\t\tif (pthread_detach(tid) != 0) {\n\t\t\tdie(\"pthread_detach\");\n\t\t}\n\t}\n\n\t// \u5404\u30b9\u30ec\u30c3\u30c9\u306e\u7d42\u4e86\u5f85\u3061\n\tfor (; !threads_is_empty(); ) {\n\t}\n\n\tmes(\"Main thread %d: Done\", tid);\n\treturn 0;\n}\n\n```\n\n", "tags": ["C", "pthread", "\u30de\u30eb\u30c1\u30b9\u30ec\u30c3\u30c9", "\u30b7\u30b0\u30ca\u30eb"]}