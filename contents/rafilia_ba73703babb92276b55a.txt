{"context": " More than 1 year has passed since last update.\u3053\u308c\u304b\u3089\u5b9f\u88c5\u3057\u305f\u6a5f\u80fd\u6bce\u306b\u5206\u3051\u3066\u30d7\u30ed\u30b0\u30e9\u30e0\u306e\u8aac\u660e\u3092\u3057\u307e\u3059\u3002\n\u306a\u304a\u3001PCI\u30c7\u30d0\u30a4\u30b9\u306e\u30d9\u30f3\u30c0ID/\u30c7\u30d0\u30a4\u30b9ID\u306f\u9069\u5f53\u306a\u3082\u306e (0x1234/ 0x1) \u3092\u4f7f\u7528\u3057\u3066\u3044\u307e\u3059\u3002\n\u307e\u305f\u3001QEMU\u4eee\u60f3\u30c7\u30d0\u30a4\u30b9\u4e0a\u3067printf \u3092\u4f7f\u3046\u3068\u305d\u306e\u307e\u307e\u30b3\u30f3\u30bd\u30fc\u30eb\u4e0a\u306b\u51fa\u529b\u3055\u308c\u307e\u3059\u3002\n\u3053\u3053\u3067\u306f\u3001\u4eee\u60f3\u30c7\u30d0\u30a4\u30b9\u304b\u3089\u306eprintf\u306b\u306f##, \u30c7\u30d0\u30a4\u30b9\u30c9\u30e9\u30a4\u30d0\u306eprintk\u306b\u306f**\u3092\n\u5148\u982d\u3067\u4ed8\u3051\u308b\u3088\u3046\u306b\u9069\u5f53\u306b\u95a2\u6570\u3092\u30e9\u30c3\u30d7\u3057\u3066\u3044\u307e\u3059\u3002\n\nQEMU\u4eee\u60f3\u30c7\u30d0\u30a4\u30b9\u3092QEMU\u306b\u767b\u9332\u3059\u308b\nQEMU\u81ea\u4f53\u306fC\u8a00\u8a9e\u3067\u66f8\u304b\u308c\u3066\u3044\u307e\u3059\u304c\u3001\u69cb\u9020\u4f53\u3092\u5229\u7528\u3057\u305f\u30aa\u30d6\u30b8\u30a7\u30af\u30c8\u6307\u5411\u306e\n\u66f8\u304d\u65b9 (QOM : QEMU Objet Model) \u306b\u3088\u3063\u3066\u30cf\u30fc\u30c9\u30a6\u30a7\u30a2\u7b49\u306e\u30aa\u30d6\u30b8\u30a7\u30af\u30c8\u304c\u8a18\u8ff0\u3055\u308c\u3066\u3044\u307e\u3059\u3002\n\u3053\u308c\u306b\u3064\u3044\u3066\u306f include/qom/object.h \u306e\u8aac\u660e\u304c\u53c2\u8003\u306b\u306a\u308a\u307e\u3059\u3002\n\u3042\u308b\u30aa\u30d6\u30b8\u30a7\u30af\u30c8\u306b\u306f\u5bfe\u5fdc\u3059\u308b\u30aa\u30d6\u30b8\u30a7\u30af\u30c8\u30af\u30e9\u30b9\u304c\n\u305f\u30601\u3064\u5b58\u5728\u3057(\u30af\u30e9\u30b9\u3082QOM\u3067\u3059)\u3001\n\u30af\u30e9\u30b9\u306e\u521d\u671f\u5316\u304c\u30aa\u30d6\u30b8\u30a7\u30af\u30c8\u306e\u521d\u671f\u5316\u3088\u308a\u524d\u306b\u8d77\u3053\u308a\u307e\u3059\u3002\n\u307e\u305f\u3001\u7d99\u627f\u95a2\u4fc2\u306b\u5fdc\u3058\u3066\u89aa\u30aa\u30d6\u30b8\u30a7\u30af\u30c8/\u30af\u30e9\u30b9\u306e\u521d\u671f\u5316\u304c\n\u5b50\u30aa\u30d6\u30b8\u30a7\u30af\u30c8/\u30af\u30e9\u30b9\u306e\u521d\u671f\u5316\u306e\u524d\u306b\u884c\u308f\u308c\u307e\u3059\u3002\n\u30af\u30e9\u30b9\u306b\u306f\u901a\u5e38\u5404\u30aa\u30d6\u30b8\u30a7\u30af\u30c8\u304c\u30aa\u30fc\u30d0\u30fc\u30e9\u30a4\u30c9\u3059\u308b(\u95a2\u6570\u30dd\u30a4\u30f3\u30bf\u306e\u5024\u3092\u7f6e\u304d\u63db\u3048\u308b)\n\u95a2\u6570\u30dd\u30a4\u30f3\u30bf\u3084\u3001\u305d\u306e\u30af\u30e9\u30b9\u306e\u30c7\u30d0\u30a4\u30b9\u304c\u6301\u3064\u3079\u304d\u30c7\u30fc\u30bf\u304c\u3042\u308a\u307e\u3059\u3002\nPCI\u30c7\u30d0\u30a4\u30b9\u306b\u306fPCI\u30c7\u30d0\u30a4\u30b9\u7528\u306e\u8a18\u8ff0\u306e\u4ed5\u65b9\u304c\u7528\u610f\u3055\u308c\u3066\u3044\u308b\u306e\u3067\u3001\u65e2\u5b58\n\u306e\u30b3\u30fc\u30c9\u3092\u53c2\u8003\u306b(hw/misc/pci-testdev.c \u306a\u3069)\u4ee5\u4e0b\u306e\u30b3\u30fc\u30c9\u3092\u66f8\u304d\u307e\u3057\u305f\u3002\n\u306a\u304a\u3001\u30aa\u30d6\u30b8\u30a7\u30af\u30c8\u306e\u69cb\u9020\u4f53\u540d\u3084\u30de\u30af\u30ed\u540d\u3001\u5909\u6570\u540d\u306e\u4ed8\u3051\u65b9\u306f\u4ed6\u306e\u30d5\u30a1\u30a4\u30eb\u306b\u306a\u3089\u3063\u3066\u3044\u307e\u3059\u3002\n\n// test_pci_device.c \u629c\u7c8b\n#include \"hw/hw.h\"\n#include \"hw/pci/pci.h\"\n\n#include \"<path_to>/test_pci.h\"\n\n#define TEST_PCI_DEVICE_DEBUG\n\n#ifdef  TEST_PCI_DEVICE_DEBUG\n#define tprintf(fmt, ...) printf(\"## (%3d) %-20s: \" fmt, __LINE__, __func__, ## __VA_ARGS__)\n#else\n#define tprintf(fmt, ...)\n#endif\n\ntypedef struct TestPCIState {\n    PCIDevice parent_obj;\n\n    /* ... */\n\n    MemoryRegion mmio;\n    MemoryRegion portio;\n} TestPCIState;\n\n#define TYPE_TEST_PCI \"test_pci\"\n\n#define TEST_PCI(obj) \\\n    OBJECT_CHECK(TestPCIState, (obj), TYPE_TEST_PCI)\n\nstatic uint64_t\ntest_pci_mmio_read(void *opaque, hwaddr addr, unsigned size)\n{\n    TestPCIState *s = opaque;\n\n        /* \u7565 */\n}\n\nstatic uint64_t\ntest_pci_pio_read(void *opaque, hwaddr addr, unsigned size)\n{\n    TestPCIState *s = opaque;\n\n        /* \u7565 */\n}\n\nstatic void\ntest_pci_mmio_write(void *opaque, hwaddr addr, uint64_t val,\n                       unsigned size)\n{\n    TestPCIState *s = opaque;\n\n        /* \u7565 */\n}\n\nstatic void\ntest_pci_pio_write(void *opaque, hwaddr addr, uint64_t val,\n                       unsigned size)\n{\n    TestPCIState *s = opaque;\n\n        /* \u7565 */\n}\n\nstatic const MemoryRegionOps test_pci_mmio_ops = {\n    .read = test_pci_mmio_read,\n    .write = test_pci_mmio_write,\n    .endianness = DEVICE_LITTLE_ENDIAN,\n    .impl = {\n        .min_access_size = 4,\n        .max_access_size = 4,\n    },\n};\n\nstatic const MemoryRegionOps test_pci_pio_ops = {\n    .read = test_pci_pio_read,\n    .write = test_pci_pio_write,\n    .endianness = DEVICE_LITTLE_ENDIAN,\n    .impl = {\n        .min_access_size = 1,\n        .max_access_size = 4,\n    },\n};\n\nstatic int test_pci_init(PCIDevice *pdev)\n{\n    TestPCIState *s = TEST_PCI(pdev);\n    uint8_t *pci_conf;\n        int i;\n\n    pci_conf = pdev->config;\n    pci_conf[PCI_INTERRUPT_PIN] = 1; /* if 0 no interrupt pin */\n\n        // register memory mapped io / port mapped io\n    memory_region_init_io(&s->mmio, OBJECT(s), &test_pci_mmio_ops,  s,\n                          \"test_pci_mmio\", TEST_PCI_MEMSIZE * 2);\n    memory_region_init_io(&s->portio, OBJECT(s), &test_pci_pio_ops, s,\n                          \"test_pci_portio\", TEST_PCI_IOSIZE * 2);\n\n        // set base address register \n    pci_register_bar(pdev, BAR_MMIO, PCI_BASE_ADDRESS_SPACE_MEMORY, &s->mmio);\n    pci_register_bar(pdev, BAR_PIO , PCI_BASE_ADDRESS_SPACE_IO    , &s->portio);\n\n    tprintf(\"loaded\\n\");\n    return 0;\n}\n\nstatic void\ntest_pci_uninit(PCIDevice *pdev)\n{\n    TestPCIState *s = TEST_PCI(pdev);\n\n    memory_region_destroy(&s->mmio);\n    memory_region_destroy(&s->portio);\n\n    tprintf(\"unloaded\\n\");\n}\n\nstatic void\ntest_pci_reset(TestPCIState *s)\n{\n    tprintf(\"done reset\\n\");\n}\n\nstatic void qdev_test_pci_reset(DeviceState *ds)\n{\n    TestPCIState *s = TEST_PCI(ds);\n    test_pci_reset(s);\n}\n\nstatic void test_pci_class_init(ObjectClass *klass, void *data)\n{\n    DeviceClass *dc = DEVICE_CLASS(klass);\n    PCIDeviceClass *k = PCI_DEVICE_CLASS(klass);\n\n    k->init = test_pci_init;\n    k->exit = test_pci_uninit;\n    k->vendor_id = PCI_VENDOR_ID_TEST;\n    k->device_id = PCI_DEVICE_ID_TEST;\n    k->revision = 0x00;\n    k->class_id = PCI_CLASS_OTHERS;\n    dc->desc = \"Test PCI Virtual Device\";\n    set_bit(DEVICE_CATEGORY_MISC, dc->categories);\n    dc->reset = qdev_test_pci_reset;\n}\n\nstatic const TypeInfo test_pci_info = {\n    .name          = TYPE_TEST_PCI,\n    .parent        = TYPE_PCI_DEVICE,\n    .instance_size = sizeof(TestPCIState),\n    .class_init    = test_pci_class_init,\n};\n\nstatic void test_pci_register_types(void)\n{\n    type_register_static(&test_pci_info);\n}\n\ntype_init(test_pci_register_types)\n\n\u3053\u3053\u3067\u3001\u4eee\u60f3\u30c7\u30d0\u30a4\u30b9\u306e\u30aa\u30d6\u30b8\u30a7\u30af\u30c8\u306f struct TestPCIState \u3067\n\u89aa\u3068\u3057\u3066 PCIDevice \u3092\u6301\u3063\u3066\u3044\u307e\u3059\u3002\u3053\u306e\u69d8\u306b\u30aa\u30d6\u30b8\u30a7\u30af\u30c8\u306f\u5fc5\u305a\u7b2c\u4e00\u5f15\u6570\u306b\n\u89aa\u306e\u69cb\u9020\u4f53\u3092\u6301\u3061\u3001\u305d\u306e\u30aa\u30d6\u30b8\u30a7\u30af\u30c8\u3092\u89aa\u306e\u578b\u306b\u30ad\u30e3\u30b9\u30c8\u3059\u308b\u3053\u3068\u3067\n\u89aa\u306e\u30aa\u30d6\u30b8\u30a7\u30af\u30c8\u3078\u30a2\u30af\u30bb\u30b9\u3059\u308b\u3053\u3068\u304c\u51fa\u6765\u307e\u3059\u3002\n\u3000\u4f8b\u3048\u3070\u3001 test_pci_class_init \u95a2\u6570\u306b\u304a\u3044\u3066\u306f \u5f15\u6570\u306e\u30af\u30e9\u30b9\u30aa\u30d6\u30b8\u30a7\u30af\u30c8\u3092\nPCI_DEVICE_CLASS \u30de\u30af\u30ed\u3067\u30ad\u30e3\u30b9\u30c8\u3059\u308b\u3053\u3068\u3067\u3001\n\u305d\u306e\u89aa\u30af\u30e9\u30b9(PCIDeviceClass)\u306b\u30a2\u30af\u30bb\u30b9\u3057\u3001\n\u3055\u3089\u306b PCIDeviceClass \u306e\u89aa\u3067\u3042\u308bObjectClass \u306b\u3001OBJECT_CLASS \u30de\u30af\u30ed\u3067\n\u30ad\u30e3\u30b9\u30c8\u3092\u884c\u3063\u3066\u30a2\u30af\u30bb\u30b9\u3057\u3066\u3044\u307e\u3059\u3002\n\u3053\u306e\u30c7\u30d0\u30a4\u30b9\u306e\u30af\u30e9\u30b9\u306f test_pci_class_init \u306b\u3042\u308b\u3088\u3046\u306b\nPCI_DEVICE_CLASS \u3068\u306a\u3063\u3066\u3044\u307e\u3059\u3002\nTestPCIState \u4e2d\u306e MmeoryRegion \u5909\u6570\u304c\u30dd\u30fc\u30c8I/O, \u30e1\u30e2\u30ea\u30de\u30c3\u30d7\u30c9I/O \u3092\u5229\u7528\u3059\u308b\u9818\u57df\u3092\u8a2d\u5b9a\u3057\u307e\u3059\u3002\u3053\u3053\u3067\u306f\u30dd\u30fc\u30c8I/O\u3001\u30e1\u30e2\u30ea\u30de\u30c3\u30d7\u30c9I/O\u306e\u9818\u57df\u30921\u3064\u305a\u3064\n\u7528\u610f\u3057\u3066\u3044\u307e\u3059\u3002\n\u4e00\u756a\u6700\u5f8c\u306b\u3042\u308b type_init \u30de\u30af\u30ed\u306b\u3088\u308a\u3053\u306e\u4eee\u60f3\u30cf\u30fc\u30c9\u30a6\u30a7\u30a2\u304c\u767b\u9332\u3055\u308c\u307e\u3059\u3002\n\u3055\u3089\u306b\u3001type_register_static \u3092\u901a\u3057\u3066\u767b\u9332\u3055\u308c\u305f\u30cf\u30fc\u30c9\u30a6\u30a7\u30a2\u60c5\u5831(struct test_pci_info)\u306b\u521d\u671f\u5316\u95a2\u6570\u3084\u30d9\u30f3\u30c0ID\u3068\u3044\u3063\u305f\u3082\u306e\u304c\u8a18\u8ff0\u3055\u308c\u307e\u3059\u3002\n\u30af\u30e9\u30b9\u306e\u521d\u671f\u5316(test_pci_class_init)\u3067\u306f\u30d9\u30f3\u30c0ID\u3084\u30c7\u30d0\u30a4\u30b9ID\u306a\u3069\u306e\u8a2d\u5b9a\u3084\u3001\n\u30aa\u30d6\u30b8\u30a7\u30af\u30c8\u306e\u521d\u671f\u5316\u95a2\u6570\u306a\u3069\u3092\u6307\u5b9a\u3057\u3066\u3044\u307e\u3059\u3002\n\u4e00\u65b9\u30aa\u30d6\u30b8\u30a7\u30af\u30c8\u306e\u521d\u671f\u5316(test_pci_init) \u306b\u304a\u3044\u3066\u306f\u307e\u305a TEST_PCI(obj)\u30de\u30af\u30ed\u3092\u5229\u7528\u3057\u3066\u3001\n\u89aa\u30e1\u30f3\u30d0\u3092\u6301\u3064 TestPCIState \u30aa\u30d6\u30b8\u30a7\u30af\u30c8\u306e\u305f\u3081\u306e\u9818\u57df\u3092\u4f5c\u6210\u3057\u3066\u3044\u307e\u3059\n(\u8a73\u3057\u304f\u306f include/qom/object.h \u3092\u898b\u3066\u304f\u3060\u3055\u3044) \u3002\n\u305d\u306e\u5f8c\u3001\u5272\u308a\u8fbc\u307f\u306e\u6709\u7121\u3068\u5404\u30e1\u30e2\u30ea\u9818\u57df(MemoryRegion)\u306b\u5bfe\u5fdc\u3059\u308b\n\u95a2\u6570\u306e\u6307\u5b9a\u3092\u884c\u3063\u3066\u3044\u307e\u3059(\u3053\u308c\u3089\u306e\u60c5\u5831\u304cPCI\u30b3\u30f3\u30d5\u30a3\u30ae\u30e5\u30ec\u30fc\u30b7\u30e7\u30f3\u7a7a\u9593\u306b\u66f8\u304b\u308c\u307e\u3059)\u3002\n\u306a\u304a\u3001MemoryRegion \u521d\u671f\u5316\u6642\u306b\u5fc5\u8981\u3068\u306a\u308b MemoryRegionOps\n\u306eimpl\u30e1\u30f3\u30d0\u306emin_access_size,max_access_size\n\u304c\u5b9f\u88c5\u4e0a\u306e\u30a2\u30af\u30bb\u30b9\u30b5\u30a4\u30ba\u3092\u898f\u5b9a\u3057\u307e\u3059\u3002\u4f8b\u3048\u3070I/O \u30dd\u30fc\u30c8\u304b\u3089\u306f\ninl/outl\u547d\u4ee4\u306b\u3088\u308a4\u30d0\u30a4\u30c8\u8aad\u307f\u8fbc\u307f/\u66f8\u304d\u8fbc\u307f\u304c\u3067\u304d\u307e\u3059\u304c\u3001max_access_size \u304c1\u3067\n\u3042\u3063\u305f\u5834\u5408\u306f\u5bfe\u5fdc\u3059\u308bread/write \u95a2\u6570\u304c4\u56de\u547c\u3070\u308c\u308b\u3053\u3068\u306b\u306a\u308a\u307e\u3059\u3002\u307e\u305f\u3001\n\u3082\u3057min_access_size \u304c4\u3067\u3042\u308b\u306a\u3089\u30701\u30d0\u30a4\u30c8\u306e\u30a2\u30af\u30bb\u30b9\u95a2\u6570(inb \u306a\u3069)\n\u3092\u30c9\u30e9\u30a4\u30d0\u304c\u4f7f\u7528\u3057\u305f\u5834\u5408\u3067\u3082 read/write \u95a2\u6570\u306e\u7b2c\u56db\u5f15\u6570 size \u304c4\u3068\u306a\u308a\u307e\u3059\u3002\n\u307e\u305f\u3001\u3053\u3053\u3067\u6307\u5b9a\u3057\u305f\u540d\u524d(test_pci_info \u306e name : TYPE_TEST_PCI == \"test_pci\") \u304c\nqemu\u3092\u8d77\u52d5\u3059\u308b\u3068\u304d\u306b\u30aa\u30d7\u30b7\u30e7\u30f3\u3067\u6307\u5b9a\u3059\u308b\u540d\u524d\u3067\u3059(-device test_pci)\u3002\n\u4ee5\u4e0a\u306e\u3088\u3046\u306b\u30bd\u30fc\u30b9\u30b3\u30fc\u30c9\u3092\u66f8\u304dQEMU\u3092\u30b3\u30f3\u30d1\u30a4\u30eb\u3057\u305f\u5f8c\u3001 -device test_pci \u30aa\u30d7\u30b7\u30e7\u30f3\u3092\n\u3064\u3051\u3066\u8d77\u52d5\u3057\u3001lspci \u30b3\u30de\u30f3\u30c9\u3092\u5b9f\u884c\u3059\u308b\u3068\u8a2d\u5b9a\u3057\u305f\u30d9\u30f3\u30c0ID/\u30c7\u30d0\u30a4\u30b9ID\u306e\nPCI\u30c7\u30d0\u30a4\u30b9\u304c Linux \u304b\u3089\u8a8d\u8b58\u3055\u308c\u3066\u3044\u308b\u3053\u3068\u304c\u78ba\u8a8d\u3067\u304d\u307e\u3059\u3002\n\n\n\u30c7\u30d0\u30a4\u30b9\u306e\u767b\u9332\u306b\u3064\u3044\u3066\n\u3053\u306e\u69d8\u306b\u3001QEMU \u306e\u5404\u30aa\u30d6\u30b8\u30a7\u30af\u30c8\u306e\u30bd\u30fc\u30b9\u30b3\u30fc\u30c9\u306b\u306f type_init \u304c\u66f8\u304b\u308c\u3066\u3044\u307e\u3059\u3002\ntype_init \u306f\u5b9f\u306f\u30de\u30af\u30ed\u3067\u3042\u308a\u3055\u3089\u306b modle_init \u30de\u30af\u30ed\u306b\u7f6e\u304d\u63db\u308f\u308a\u3001\n\u6700\u7d42\u7684\u306b __attribute__constructor()__  \u5c5e\u6027\u304c\u3064\u304f\u95a2\u6570\u304c\u4f5c\u3089\u308c\u307e\u3059\u3002\n\u3053\u306e\u5c5e\u6027\u304c\u4ed8\u304f\u95a2\u6570\u306f main \u95a2\u6570\u306e\u5b9f\u884c\u3088\u308a\u3082\u524d\u306b\u5b9f\u884c\u3055\u308c\u307e\u3059\u3002\n\u306a\u304a\u3001\u30a8\u30df\u30e5\u30ec\u30fc\u30b7\u30e7\u30f3\u30de\u30b7\u30f3\u5168\u4f53\u3092\u767b\u9332\u3059\u308b\u5834\u5408\u306f machine_init \u3068\u3044\u3046\u30de\u30af\u30ed\n(\u540c\u69d8\u306b module_init \u306b\u7f6e\u304d\u63db\u308f\u308b) \u304c\u4f7f\u308f\u308c\u307e\u3059\u3002\n// include/qemu/module.h \u4e2d\n\n #define module_init(function, type)                                         \\\n static void __attribute__((constructor)) do_qemu_init_ ## function(void)    \\\n {                                                                           \\\n     register_dso_module_init(function, type);                               \\\n }\n #else\n /* This should not be used directly.  Use block_init etc. instead.  */\n #define module_init(function, type)                                         \\\n static void __attribute__((constructor)) do_qemu_init_ ## function(void)    \\\n {                                                                           \\\n     register_module_init(function, type);                                   \\\n }\n #endif\n\n typedef enum {\n     MODULE_INIT_BLOCK,\n     MODULE_INIT_MACHINE,\n     MODULE_INIT_QAPI,\n     MODULE_INIT_QOM,\n     MODULE_INIT_MAX\n } module_init_type;\n\n #define block_init(function) module_init(function, MODULE_INIT_BLOCK)\n #define machine_init(function) module_init(function, MODULE_INIT_MACHINE)\n #define qapi_init(function) module_init(function, MODULE_INIT_QAPI)\n #define type_init(function) module_init(function, MODULE_INIT_QOM)\n\n\u4f8b\u3048\u3070 type_init(some_function) \u306b\u5bfe\u3057\u3066 do_qemu_init_some_function \u3068\u3044\u3046\u540d\u524d\u306e\u95a2\u6570\u304c\u4f5c\u3089\u308c\u3001\nQEMU \u306emain\u95a2\u6570\u304c\u5b9f\u884c\u3055\u308c\u308b\u3088\u308a\u524d\u306b\u5b9f\u884c\u3055\u308c\u308b\u3053\u3068\u306b\u306a\u308a\u307e\u3059\u3002\n\u305d\u306e\u95a2\u6570\u306f\u7d50\u5c40register_module_init\u304bregister_dso_module_init(\u9055\u3044\u306f\u308f\u304b\u308a\u307e\u305b\u3093) \u3092\u547c\u3073\u3001\n\u6700\u7d42\u7684\u306b\u30ea\u30b9\u30c8(QTAILQ)\u306b\u540d\u524d\u3068\u521d\u671f\u5316\u95a2\u6570\u304c\u767b\u9332\u3055\u308c\u307e\u3059\u3002\nQEMU \u306e main \u95a2\u6570(vl.c \u306e\u4e2d) \u306e\u521d\u3081\u306e\u65b9\u306b\u304a\u3044\u3066 module_call_init \u304c\u547c\u3070\u308c\u3066\u304a\u308a\u3001\n\u3053\u308c\u304c\u5404\u30ea\u30b9\u30c8\u3092\u305f\u3069\u3063\u3066\u9806\u756a\u306b\u767b\u9332\u3055\u308c\u305f\u521d\u671f\u5316\u95a2\u6570\u3092\u5b9f\u884c\u3057\u3066\u3044\u307e\u3059\u3002\n\u57fa\u672c\u7684\u306b\u305d\u308c\u3089\u306e\u95a2\u6570\u306f\u4eca\u56de\u306e\u4f8b\u306e\u3088\u3046\u306b type_register_static \u306a\u3069\u3092\u547c\u3073\u51fa\u3057\u3066\n\u305d\u306e\u30aa\u30d6\u30b8\u30a7\u30af\u30c8\u306e\u30bf\u30a4\u30d7\u3092\u30cf\u30c3\u30b7\u30e5\u8868\u306b\u767b\u9332\u3057\u3066\u304a\u308a\u3001\u3053\u306e\u8868\u3092\n\u65b0\u3057\u3044\u30aa\u30d6\u30b8\u30a7\u30af\u30c8\u3092\u751f\u6210\u3059\u308b\u3068\u304d\u306b\u4f7f\u7528\u3057\u3066\u3044\u308b\u3088\u3046\u3067\u3059\u3002\n\n\u30c7\u30d0\u30a4\u30b9\u30c9\u30e9\u30a4\u30d0\u306e\u767b\u9332\n\u30c7\u30d0\u30a4\u30b9\u30c9\u30e9\u30a4\u30d0\u306f\u307e\u305a\u81ea\u8eab\u3092\u30ab\u30fc\u30cd\u30eb\u306b\u767b\u9332\u3059\u308b\u5fc5\u8981\u304c\u3042\u308a\u307e\u3059\u3002\nPCI\u30c7\u30d0\u30a4\u30b9\u3001\u30ad\u30e3\u30e9\u30af\u30bf\u30c7\u30d0\u30a4\u30b9 \u5171\u306b\u767b\u9332\u306b\u306f\u6c7a\u307e\u3063\u305f\u3084\u308a\u65b9\u304c\u3042\u308b\u306e\u3067\n\u3053\u308c\u306b\u5f93\u3044\u307e\u3059\u3002\n\u306a\u304aPCI\u30c7\u30d0\u30a4\u30b9\u3068\u3057\u3066\u306e\u60c5\u5831\u306f struct pci_dev,\n\u30ad\u30e3\u30e9\u30af\u30bf\u30c7\u30d0\u30a4\u30b9\u3068\u3057\u3066\u306e\u60c5\u5831\u306fstruct cdev \u306b\u683c\u7d0d\u3055\u308c\u307e\u3059\u3002\n// test_pci_driver.c (\u4e00\u90e8)\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/cdev.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/device.h>\n#include <linux/pci.h>\n#include <linux/interrupt.h>\n#include <asm/dma.h>\n#include <asm/current.h>\n#include <asm/uaccess.h>\n\n#include \"test_pci.h\"\n\nMODULE_LICENSE(\"GPL\");\n// MODULE_AUTHOR(\"tm\");\nMODULE_DESCRIPTION(\"device driver for test pci\");\n\n#define DRIVER_TEST_NAME \"test_pci\"\n#define DEVICE_TEST_NAME \"test_pci_dev\"\n\n#define TEST_PCI_DRIVER_DEBUG\n#ifdef  TEST_PCI_DRIVER_DEBUG\n#define tprintk(fmt, ...) printk(KERN_ALERT \"** (%3d) %-20s: \" fmt, __LINE__,  __func__,  ## __VA_ARGS__)\n#else\n#define tprintk(fmt, ...) \n#endif\n\n// max device count (minor number)\nstatic int test_pci_devs_max = 1;\n\n// if test_pci_major = 0 then use dynamic allocation\nstatic unsigned int test_pci_major = 0;\n// get parameter from console if needed for test_pci_major when insmod\nmodule_param(test_pci_major, uint, 0);\n\nstatic unsigned int test_pci_minor = 0; // static allocation\n\nstatic dev_t test_pci_devt; // MKDEV(test_pci_major, test_pci_minor)\n\nstruct test_device_data {\n    struct pci_dev *pdev;\n    struct cdev *cdev;\n\n    // for PCI pio/mmio\n    unsigned long pio_base, pio_flags, pio_length;\n    unsigned long mmio_base, mmio_flags, mmio_length;\n    char *mmio_addr;\n\n    unsigned int pio_memsize;\n\n    // for consistent/streaming dma\n    dma_addr_t cdma_addr, sdma_addr;\n    int cdma_len, sdma_len;\n    void *cdma_buffer, *sdma_buffer;\n\n    wait_queue_head_t sdma_q;\n};\n\nstatic struct test_device_data *dev_data;\n\nstatic int test_pci_open(struct inode *inode, struct file *file)\n{\n\n    file->private_data = NULL;\n\n    return 0; // success\n}\n\nstatic int test_pci_close(struct inode *inode, struct file *file)\n{\n\n    if(file->private_data) {\n        kfree(file->private_data);\n        file->private_data = NULL;\n    }\n\n    return 0; // success\n}\n\nstruct file_operations test_pci_fops = \n{\n    .open = test_pci_open,\n    .release = test_pci_close,\n};\n\n//-----------------------------------------------------------------\n// supported pci id type\nstatic struct pci_device_id test_pci_ids[] =\n{\n    { PCI_DEVICE(PCI_VENDOR_ID_TEST, PCI_DEVICE_ID_TEST) },\n    { 0, },\n};\n\n// export pci_device_id\nMODULE_DEVICE_TABLE(pci, test_pci_ids);\n\n\n//-----------------------------------------------------------------\n// pci initialization function\n// enable pci & register character device\nstatic int test_pci_probe (struct pci_dev *pdev,\n        const struct pci_device_id *id)\n{\n    int err;\n    char irq;\n\n    int alloc_ret = 0;\n    int cdev_err = 0;\n\n    short vendor_id, device_id;\n\n\n    //-----------------------------------------------------------------\n    // config PCI\n    // enable pci device\n    err = pci_enable_device(pdev);\n    if(err) {\n        printk(KERN_ERR \"can't enable pci device\\n\");\n        goto error; \n    }\n    tprintk(\"PCI enabled for %s\\n\", DRIVER_TEST_NAME);\n\n    // request PCI region\n    // bar 0 ... MMIO\n    dev_data->mmio_base = pci_resource_start(pdev, BAR_MMIO);\n    dev_data->mmio_length = pci_resource_len(pdev, BAR_MMIO);\n    dev_data->mmio_flags = pci_resource_flags(pdev, BAR_MMIO);\n    tprintk( \"mmio_base: %lx, mmio_length: %lx, mmio_flags: %lx\\n\",\n            dev_data->mmio_base, dev_data->mmio_length, dev_data->mmio_flags);\n\n    dev_data->mmio_addr = ioremap(dev_data->mmio_base, TEST_PCI_MEMSIZE);\n\n    if(!(dev_data->mmio_flags & IORESOURCE_MEM)){\n        printk(KERN_ERR \"BAR%d is not for mmio\\n\", BAR_MMIO);\n        goto error;\n    }\n\n    err = pci_request_region(pdev, BAR_MMIO, DRIVER_TEST_NAME);\n    if(err) {\n        printk(KERN_ERR \"%s :error pci_request_region MMIO\\n\", __func__);\n        goto error; \n    }\n\n\n    // bar 1 ... IO port\n    dev_data->pio_base = pci_resource_start(pdev, BAR_PIO);\n    dev_data->pio_length = pci_resource_len(pdev, BAR_PIO);\n    dev_data->pio_flags = pci_resource_flags(pdev, BAR_PIO);\n    tprintk(\"pio_base: %lx, pio_length: %lx, pio_flags: %lx\\n\",\n            dev_data->pio_base, dev_data->pio_length, dev_data->pio_flags);\n\n    if(!(dev_data->pio_flags & IORESOURCE_IO)){\n        printk(KERN_ERR \"BAR%d is not for pio\\n\", BAR_PIO);\n        goto error;\n    }\n\n    err = pci_request_region(pdev, BAR_PIO, DRIVER_TEST_NAME);\n    if(err) {\n        printk(KERN_ERR \"%s :error pci_request_region PIO\\n\", __func__);\n        goto error; \n    }\n\n    // show PCI configuration data\n    // define at include/uapi/linux/pci_regs.h\n    pci_read_config_word(pdev, PCI_VENDOR_ID, &vendor_id);\n    pci_read_config_word(pdev, PCI_DEVICE_ID, &device_id);\n    tprintk(\"PCI Vendor ID:%x, Device ID:%x\\n\", vendor_id, device_id);\n\n\n    dev_data->pdev = pdev;\n    dev_data->pio_memsize = TEST_PIO_DATASIZE;\n\n    tprintk(\"sucess allocate i/o region\\n\");\n\n    //-----------------------------------------------------------------\n    // config irq \n    // get irq number\n    irq = pdev->irq; // same as pci_read_config_byte(pdev, PCI_INTERRUPT_LINE, &irq);\n    tprintk(\"device irq: %d\\n\", irq);\n\n    err = request_irq(irq, test_pci_handler, 0, DRIVER_TEST_NAME, pdev);\n    if(err){\n        printk(KERN_ERR \"%s :error request irq %d\\n\", __func__, irq);\n        goto error;\n    }\n\n\n    //-----------------------------------------------------------------\n    // register character device\n    // allocate major number\n    alloc_ret = alloc_chrdev_region(&test_pci_devt, test_pci_minor, test_pci_devs_max, DRIVER_TEST_NAME);\n    if(alloc_ret) goto error;\n\n    test_pci_major = MAJOR(test_pci_devt);\n\n    dev_data->cdev = (struct cdev*)kmalloc(sizeof(struct cdev), GFP_KERNEL);\n    if(!dev_data->cdev) goto error;\n\n    cdev_init(dev_data->cdev, &test_pci_fops);\n    dev_data->cdev->owner = THIS_MODULE;\n\n    cdev_err = cdev_add(dev_data->cdev, test_pci_devt, test_pci_devs_max);\n    if(cdev_err) goto error;\n\n    tprintk(\"%s driver(major %d) installed.\\n\", DRIVER_TEST_NAME, test_pci_major);\n\n    //-----------------------------------------------------------------\n    // config DMA\n    err = pci_set_dma_mask(pdev, DMA_BIT_MASK(32));\n    if(err) {\n        printk(KERN_ERR \"Cannot set DMA mask\\n\");\n        goto error;\n    }\n    pci_set_master(pdev);\n\n    // allocate consistent DMA\n    dev_data->cdma_buffer = pci_alloc_consistent(pdev, TEST_CDMA_BUFFER_SIZE, &dev_data->cdma_addr);\n    if(dev_data->cdma_buffer == NULL) {\n        printk(KERN_ERR \"Cannot allocate consistent DMA buffer\\n\");\n        goto error;\n    }\n    dev_data->cdma_len = TEST_CDMA_BUFFER_SIZE;\n\n    // send consistent DMA info to device\n    outl(dev_data->cdma_addr, dev_data->pio_base + TEST_SET_CDMA_ADDR);\n    outl(dev_data->cdma_len,  dev_data->pio_base + TEST_SET_CDMA_LEN);\n\n    tprintk(\"cdma_addr : %x\\n\",  dev_data->cdma_addr);\n\n    // streaming DMA\n    dev_data->sdma_buffer = kmalloc(TEST_SDMA_BUFFER_SIZE, GFP_KERNEL);\n    if(dev_data->sdma_buffer == NULL) {\n        printk(KERN_ERR \"Cannot allocate streaming DMA buffer\\n\");\n        goto error;\n    }\n    init_waitqueue_head(&(dev_data->sdma_q));\n\n    return 0;\n\nerror:\n    tprintk(\"PCI load error\\n\");\n    if(cdev_err == 0) cdev_del(dev_data->cdev);\n\n    if(alloc_ret == 0) unregister_chrdev_region(test_pci_devt, test_pci_devs_max);\n\n    return -1;\n}\n\nstatic void test_pci_remove(struct pci_dev *pdev)\n{\n    // DMA\n    pci_free_consistent(dev_data->pdev, TEST_CDMA_BUFFER_SIZE,\n            dev_data->cdma_buffer, dev_data->cdma_addr);\n\n    // character device\n    cdev_del(dev_data->cdev);\n    unregister_chrdev_region(test_pci_devt, test_pci_devs_max);\n\n    // irq\n    free_irq(dev_data->pdev->irq, dev_data->pdev);\n\n    // memory mapped i/o\n    iounmap(dev_data->mmio_addr);\n\n    /pci\n    pci_release_region(dev_data->pdev, BAR_MMIO);\n    pci_release_region(dev_data->pdev, BAR_PIO);\n    pci_disable_device(dev_data->pdev);\n\n    tprintk(\"%s driver (major %d) unloaded\\n\", DRIVER_TEST_NAME, test_pci_major);\n}\n\nstatic struct pci_driver test_pci_driver =\n{\n    .name = DRIVER_TEST_NAME,\n    .id_table = test_pci_ids,\n    .probe = test_pci_probe,\n    .remove = test_pci_remove,\n};\n\n//-----------------------------------------------------------------\n// module init/exit\nstatic int __init test_pci_init(void)\n{\n    dev_data = kmalloc(sizeof(struct test_device_data), GFP_KERNEL);\n    if(!dev_data) {\n        printk(KERN_ERR \"cannot allocate device data memory\\n\");\n        return -1; // should return other value?\n    }\n\n    return pci_register_driver(&test_pci_driver);\n}\n\nstatic void __exit test_pci_exit(void)\n{\n    pci_unregister_driver(&test_pci_driver);\n    kfree(dev_data);\n}\n\nmodule_init(test_pci_init);\nmodule_exit(test_pci_exit);\n\n\n\u30c9\u30e9\u30a4\u30d0\u56fa\u6709\u306e\u30c7\u30fc\u30bf\u306f struct test_device_data \u3068\u3057\u3066\u69cb\u9020\u4f53\u306b\n\u307e\u3068\u3081\u3066\u3042\u308a\u307e\u3059\u3002\u4eca\u56de\u306f\u30de\u30a4\u30ca\u30fc\u756a\u53f7\u306b\u3064\u3044\u3066\u306f\u8003\u3048\u3066\u3044\u307e\u305b\u3093\u304c\u3001\n\u8003\u3048\u308b\u5834\u5408\u306f\u30de\u30a4\u30ca\u30fc\u756a\u53f7\u6bce\u306e\u30c7\u30fc\u30bf\u3092\u914d\u5217\u3068\u3057\u3066\u78ba\u4fdd\u3059\u308b\u306a\u3069\u306e\u5fc5\u8981\u304c\u3042\u308a\u307e\u3059\u3002\n\u30d7\u30ed\u30b0\u30e9\u30e0\u306e\u6700\u5f8c\u306b\u66f8\u304b\u308c\u3066\u3044\u308b\u3088\u3046\u306b\u3001\u30c7\u30d0\u30a4\u30b9\u30c9\u30e9\u30a4\u30d0\u306b\u306f\u5fc5\u305amodule_init \u3068module_exit \u3067\u6307\u5b9a\u3055\u308c\u305f\n\u521d\u671f\u5316\u6642/\u7d42\u4e86\u6642\u306b\u5b9f\u884c\u3055\u308c\u308b\u95a2\u6570\u304c\u3042\u308a\u307e\u3059\n(\u30ed\u30fc\u30c0\u30d6\u30eb\u30e2\u30b8\u30e5\u30fc\u30eb\u306e\u5834\u5408\u306f insmod/rmmod \u6642\u306b\u5b9f\u884c\u3055\u308c\u308b\u95a2\u6570)\u3002\n\u306a\u304a\u3001__init \u5c5e\u6027\u3092\u3064\u3051\u308b\u3068\u5b9f\u884c\u5f8c\u30e1\u30e2\u30ea\u304c\u958b\u653e\u3055\u308c\u3001__exit \u5c5e\u6027\u3092\u3064\u3051\u308b\u3068\n\u30e2\u30b8\u30e5\u30fc\u30eb\u304c\u30a2\u30f3\u30ed\u30fc\u30c9\u3055\u308c\u306a\u3044\u5834\u5408(\u4e88\u3081\u30ab\u30fc\u30cd\u30eb\u306b\u7d44\u307f\u8fbc\u307e\u308c\u308b\u3068\u304d)\n\u30e1\u30e2\u30ea\u304c\u958b\u653e\u3055\u308c\u308b\u3088\u3046\u306b\u306a\u308a\u307e\u3059\u3002\nPCI\u30c7\u30d0\u30a4\u30b9\u306e\u5834\u5408\u306fmodule_init\u3067\u767b\u9332\u3057\u305f\u95a2\u6570\u304b\u3089\npci_register_driver \u3092\u547c\u3073\u51fa\u3057\u3001PCI\u30c7\u30d0\u30a4\u30b9\u306e\u767b\u9332\u3092\u884c\u3044\u307e\u3059\u3002\n\u5b9f\u969b\u306e\u521d\u671f\u5316\u306f\u305d\u306e\u95a2\u6570\u306b\u6e21\u3057\u305f\u69cb\u9020\u4f53(struct pci_driver) \u306e\u30e1\u30f3\u30d0\u306b\u3042\u308bprobe\n\u306e\u95a2\u6570\u304c\u884c\u3044\u307e\u3059(\u3053\u3053\u3067\u306f\u3001test_pci_probe)\u3002\n\u307e\u305f\u3053\u308c\u3068\u306f\u5225\u306b struct pci_device_id \u306e\u914d\u5217\u306b\u305d\u306e\u30c9\u30e9\u30a4\u30d0\u304c\u5bfe\u5fdc\u3059\u308b\n\u30c7\u30d0\u30a4\u30b9ID\u306a\u3069\u306e\u60c5\u5831\u3092\u30bb\u30c3\u30c8(PCI_DEVICE\u30de\u30af\u30ed\u3092\u4f7f\u7528)\u3057\u3001\nMODULE_DEVICE_TABLE\u306b\u30a8\u30af\u30b9\u30dd\u30fc\u30c8\u3057\u307e\u3059\u3002\n1\u3064\u306e\u30c9\u30e9\u30a4\u30d0\u304c\u8907\u6570\u306e\u30c7\u30d0\u30a4\u30b9\u306b\u5bfe\u5fdc\u3059\u308b\u3053\u3068\u304c\u53ef\u80fd\u3067\u3059\u3002\n\u3053\u308c\u306b\u3088\u308a\u3001\u30c9\u30e9\u30a4\u30d0\u3092\u30ed\u30fc\u30c9\u3057\u305f\u6642\u3084\u65b0\u305f\u306bPCI\u30c7\u30d0\u30a4\u30b9\u3092\u691c\u77e5\u3057\u305f\u6642\u306b\u5bfe\u5fdc\u3059\u308b\n\u30c9\u30e9\u30a4\u30d0\u306e\u521d\u671f\u5316\u95a2\u6570\u304c\u81ea\u52d5\u3067\u5b9f\u884c\u3055\u308c\u307e\u3059\u3002\n\nPCI probe \u95a2\u6570\nprobe\u95a2\u6570\u306b\u304a\u3044\u3066\u306f\u307e\u305a pci_enable_device \u306b\u3088\u308aPCI\u30c7\u30d0\u30a4\u30b9\u3092\u6709\u52b9\u5316\u3057\u305f\u5f8c\u306b\u3001\npic_request_region \u95a2\u6570\u3067I/O \u30dd\u30fc\u30c8\u3084\u30e1\u30e2\u30ea\u30de\u30c3\u30d7\u30c9I/O\u306e\u9818\u57df\u3092\u78ba\u4fdd\u3057\u307e\u3059\u3002\n\u306a\u304a\u3001BAR\u9818\u57df\u306e\u60c5\u5831\u306fpci_resource_start \u306a\u3069\u306e\u95a2\u6570\u304b\u3089\u5165\u624b\u3067\u304d\u307e\u3059\u3002\npci_resource_start \u306f\u305d\u306e\u9818\u57df\u304c\u59cb\u307e\u308b\u30dd\u30fc\u30c8\u756a\u53f7(I/O\u30dd\u30fc\u30c8\u306e\u5834\u5408)\u3084\n\u7269\u7406\u30a2\u30c9\u30ec\u30b9(\u30e1\u30e2\u30ea\u30de\u30c3\u30d7\u30c9I/O\u306e\u5834\u5408)\u3092\u8fd4\u3057\u3001pci_resource_length \u304c\u305d\u306e\u9577\u3055\n\u3068\u306a\u308a\u307e\u3059\u3002\u307e\u305f\u3001\u305d\u306e\u4ed6\u306ePCI \u30b3\u30f3\u30d5\u30a3\u30ae\u30e5\u30ec\u30fc\u30b7\u30e7\u30f3\u7a7a\u9593\u306e\u60c5\u5831\u306f\npci_read_config_byte/word \u306a\u3069\u306e\u95a2\u6570\u304b\u3089\u8aad\u307f\u53d6\u308c\u307e\u3059\n(\u3053\u3053\u3067\u306f\u78ba\u8a8d\u306e\u305f\u3081\u306b\u30c7\u30d0\u30a4\u30b9\u756a\u53f7\u306a\u3069\u3092\u53d6\u5f97\u3057\u3001printk \u3057\u3066\u3044\u307e\u3059\u304c\n\u30c9\u30e9\u30a4\u30d0\u306f\u3053\u308c\u3089\u306e\u60c5\u5831\u3092\u77e5\u3063\u3066\u3044\u308b\u306f\u305a\u3067\u3059)\u3002\n\u6b21\u306b\u5272\u308a\u8fbc\u307f\u306e\u8a2d\u5b9a\u3092\u884c\u3044\u307e\u3059(\u5f8c\u8ff0)\u3002\n\u305d\u306e\u5f8cPCI\u30c7\u30d0\u30a4\u30b9\u306e\u7a2e\u985e\u306b\u5fdc\u3058\u305f\u30af\u30e9\u30b9\u3078\u767b\u9332\u3057\u307e\u3059(\u3053\u3053\u3067\u306f\u30ad\u30e3\u30e9\u30af\u30bf\u30c7\u30d0\u30a4\u30b9)\u3002\nalloc_chrdev_region \u3067\u52d5\u7684\u306b\u30e1\u30b8\u30e3\u30fc\u756a\u53f7\u3092\u5272\u308a\u5f53\u3066\u3001\ncdev_init, cdev_add \u306b\u3088\u308a\u30c7\u30d0\u30a4\u30b9\u3092\u767b\u9332\u3057\u3066\u3044\u307e\u3059\u3002\u306a\u304a\u3001\u4eca\u56de\u306f\n\u30de\u30a4\u30ca\u30fc\u756a\u53f7\u306b\u3088\u308b\u30c7\u30d0\u30a4\u30b9\u306e\u533a\u5225\u306f\u884c\u3063\u3066\u3044\u307e\u305b\u3093\n\u6700\u5f8c\u306b\u5fc5\u8981\u3067\u3042\u308b\u306a\u3089\u3070DMA\u306e\u8a2d\u5b9a\u3092\u884c\u3044\u307e\u3059(\u5f8c\u8ff0)\u3002\n\u4e00\u65b9\u3067\u3001module_exit \u3067\u6307\u5b9a\u3057\u305f\u95a2\u6570\u3084 struct pci_driver \u306e remove \u95a2\u6570\u3067\u306f\n\u521d\u671f\u5316\u6642\u306b\u78ba\u4fdd\u3057\u305f\u9818\u57df\u306e\u767b\u9332\u89e3\u6d88\u3084\u958b\u653e\u3092\u884c\u3044\u307e\u3059\u3002\n\u5fc5\u9808\u3067\u306f\u3042\u308a\u307e\u305b\u3093\u304c\u521d\u671f\u5316\u306e\u9806\u756a\u3068\u306f\u9006\u306b\u884c\u3046\u3053\u3068\u304c\u4e00\u822c\u7684\u306a\u3088\u3046\u3067\u3059\u3002\n\u9069\u5207\u306b\u7d42\u4e86\u51e6\u7406\u3092\u884c\u308f\u306a\u3044\u3068\u7d42\u4e86\u6642\u3084\u3001\u30e2\u30b8\u30e5\u30fc\u30eb\u306e\u518d\u30ed\u30fc\u30c9\u6642\u306b\u30ab\u30fc\u30cd\u30eb\u30d1\u30cb\u30c3\u30af\n\u3092\u8d77\u3053\u3057\u307e\u3059\u3002\n\u306a\u304a\u3001\u30c7\u30d0\u30a4\u30b9\u30c9\u30e9\u30a4\u30d0\u306b\u304a\u3044\u3066\u306f\u30a8\u30e9\u30fc\u51e6\u7406\u306bgoto\u6587\u3092\u4f7f\u3046\n\u3053\u3068\u306f\u666e\u901a\u3060\u3068\u3044\u3046\u3053\u3068\u306a\u306e\u3067\u3001\u3053\u3053\u3067\u3082\u305d\u306e\u66f8\u304d\u65b9\u306b\u306a\u3089\u3063\u3066\u3044\u307e\u3059\u3002\n\u30b7\u30b9\u30c6\u30e0\u30b3\u30fc\u30eb\u7528\u306e\u95a2\u6570\u306f struct file_operations \u3092\u7528\u3044\u3066\u767b\u9332\u3057\u307e\u3059\u3002\n\u6700\u4f4e\u9650 open/close \u306b\u5bfe\u5fdc\u3059\u308b\u30e1\u30f3\u30d0 (.open/.release) \u306b\u95a2\u6570\u3092\u7528\u610f\u3057\u307e\u3059\u3002\n\u3053\u306e\u30e2\u30b8\u30e5\u30fc\u30eb\u3092\u30b3\u30f3\u30d1\u30a4\u30eb\u5f8c insmod/mknod \u3092\u884c\u3044\u30c9\u30e9\u30a4\u30d0\u3092\u30ed\u30fc\u30c9\u3059\u308b\u3068\u3001\n/proc/iomem, ioports, interrupt \u306a\u3069\u306e\u60c5\u5831\u306b test_pci \u306e\u540d\u524d\u304c\u4ed8\u304f\u3053\u3068\u304c\n\u78ba\u8a8d\u3067\u304d\u307e\u3059\u3002\n\n\u30e6\u30fc\u30b6\u30fc\u30d7\u30ed\u30b0\u30e9\u30e0\n\u30c7\u30d0\u30a4\u30b9\u30d5\u30a1\u30a4\u30eb\u3092\u958b\u304f\u306b\u306fopen/close \u30b7\u30b9\u30c6\u30e0\u30b3\u30fc\u30eb\u3092\u5229\u7528\u3057\u307e\u3059\u3002\nint open_device(const char* filename)\n{\n    int fd;\n\n    fd = open(filename, O_RDWR);\n    if(fd == -1){\n        printf(\"can't open device: %s\", filename);\n        exit(1);\n    }\n\n    printf(\"success: open device %s\\n\", filename);\n    return fd;\n}\n\nvoid close_device(int fd)\n{\n    if(close(fd) != 0){\n        printf(\"can't close device\");\n        exit(1);\n    }\n\n    printf(\"success: close device\\n\");\n}\n\n\n\u5b9f\u884c\u7d50\u679c\n-device test_pci \u3092\u4ed8\u3051\u3066 QEMU \u5b9f\u884c\u958b\u59cb\u5f8c\u306b\n\u5404\u7a2e\u30b3\u30de\u30f3\u30c9\u3092\u5b9f\u884c\u3059\u308b\u3068\u4ee5\u4e0b\u306e\u3088\u3046\u306b\u306a\u308a\u307e\u3059\u3002\n# lspci\n00:00.0 Class 0600: 8086:1237\n00:01.0 Class 0601: 8086:7000\n00:01.1 Class 0101: 8086:7010\n00:01.3 Class 0680: 8086:7113\n00:02.0 Class 0300: 1013:00b8\n00:03.0 Class 0200: 8086:100e\n00:04.0 Class 00ff: 1234:0001 // \u4f5c\u6210\u3057\u305fPCI\u30c7\u30d0\u30a4\u30b9\n# lsmod\nModule                  Size  Used by    Tainted: G\n# insmod /drivers/test_pci_driver.ko\n** (315) test_pci_probe      : PCI enabled for test_pci\n** (323) test_pci_probe      : mmio_base: febf1000, mmio_length: 1000, mmio_flags: 40200\n** (344) test_pci_probe      : pio_base: c000, pio_length: 100, pio_flags: 40101\n** (361) test_pci_probe      : PCI Vendor ID:1234, Device ID:1\n** (367) test_pci_probe      : sucess allocate i/o region\n** (373) test_pci_probe      : device irq: 11\n** (399) test_pci_probe      : test_pci driver(major 254) installed.\n## (155) test_pci_pio_write  : addr 116, size 4\n## (155) test_pci_pio_write  : addr 120, size 4\n** (422) test_pci_probe      : cdma_addr : 79b7000\n# lsmod\nModule                  Size  Used by    Tainted: G\ntest_pci_driver         6252  0\n# cat /proc/ioports | grep test\n    c000-c0ff : test_pci\n# cat /proc/iomem | grep test\n    febf1000-febf1fff : test_pci\n# cat /proc/interrupts |grep test\n 11:          3    XT-PIC-XT-PIC    test_pci\n# cat /proc/devices | grep test\n254 test_pci\n# mknod /dev/test_pci c 254 0\n# rmmod test_pci_driver\n** (459) test_pci_remove     : test_pci driver (major 254) unloaded\n# rm /dev/test_pci\n# lsmod\nModule                  Size  Used by    Tainted: G\n#\n\n\u307e\u305f\u3001ctrl-a+c \u3067\u30e2\u30cb\u30bf\u753b\u9762\u306b\u79fb\u52d5\u5f8c info pci \n\u306b\u3088\u308a\u4ee5\u4e0b\u306e\u60c5\u5831\u304c\u5f97\u3089\u308c\u307e\u3059\u3002\n(qemu) info pci\n  Bus  0, device   0, function 0:\n    Host bridge: PCI device 8086:1237\n      id \"\"\n  Bus  0, device   1, function 0:\n    ISA bridge: PCI device 8086:7000\n      id \"\"\n  Bus  0, device   1, function 1:\n    IDE controller: PCI device 8086:7010\n      BAR4: I/O at 0xc140 [0xc14f].\n      id \"\"\n  Bus  0, device   1, function 3:\n    Bridge: PCI device 8086:7113\n      IRQ 9.\n      id \"\"\n  Bus  0, device   2, function 0:\n    VGA controller: PCI device 1013:00b8\n      BAR0: 32 bit prefetchable memory at 0xfc000000 [0xfdffffff].\n      BAR1: 32 bit memory at 0xfebf0000 [0xfebf0fff].\n      BAR6: 32 bit memory at 0xffffffffffffffff [0x0000fffe].\n      id \"\"\n  Bus  0, device   3, function 0:\n    Ethernet controller: PCI device 8086:100e\n      IRQ 11.\n      BAR0: 32 bit memory at 0xfebc0000 [0xfebdffff].\n      BAR1: I/O at 0xc100 [0xc13f].\n      BAR6: 32 bit memory at 0xffffffffffffffff [0x0003fffe].\n      id \"\"\n  Bus  0, device   4, function 0:\n    Class 0255: PCI device 1234:0001\n      IRQ 11.\n      BAR0: 32 bit memory at 0xfebf1000 [0xfebf1fff].\n      BAR1: I/O at 0xc000 [0xc0ff].\n      id \"\"\n\nlspci \u30b3\u30de\u30f3\u30c9\u306e\u7d50\u679c\u3068\u4e00\u81f4\u3057\u3066\u3044\u307e\u3059\u3002\n\n\u306f\u3058\u3081: (1) \u4f5c\u3063\u305f\u3082\u306e\n\u524d: (3) \u958b\u767a/\u52d5\u4f5c\u74b0\u5883\n\u6b21: (5)  I/O\u30dd\u30fc\u30c8\u306e\u4f7f\u7528\n\u3053\u308c\u304b\u3089\u5b9f\u88c5\u3057\u305f\u6a5f\u80fd\u6bce\u306b\u5206\u3051\u3066\u30d7\u30ed\u30b0\u30e9\u30e0\u306e\u8aac\u660e\u3092\u3057\u307e\u3059\u3002\n\n\u306a\u304a\u3001PCI\u30c7\u30d0\u30a4\u30b9\u306e\u30d9\u30f3\u30c0ID/\u30c7\u30d0\u30a4\u30b9ID\u306f\u9069\u5f53\u306a\u3082\u306e (0x1234/ 0x1) \u3092\u4f7f\u7528\u3057\u3066\u3044\u307e\u3059\u3002\n\n\u307e\u305f\u3001QEMU\u4eee\u60f3\u30c7\u30d0\u30a4\u30b9\u4e0a\u3067printf \u3092\u4f7f\u3046\u3068\u305d\u306e\u307e\u307e\u30b3\u30f3\u30bd\u30fc\u30eb\u4e0a\u306b\u51fa\u529b\u3055\u308c\u307e\u3059\u3002\n\u3053\u3053\u3067\u306f\u3001\u4eee\u60f3\u30c7\u30d0\u30a4\u30b9\u304b\u3089\u306eprintf\u306b\u306f##, \u30c7\u30d0\u30a4\u30b9\u30c9\u30e9\u30a4\u30d0\u306eprintk\u306b\u306f**\u3092\n\u5148\u982d\u3067\u4ed8\u3051\u308b\u3088\u3046\u306b\u9069\u5f53\u306b\u95a2\u6570\u3092\u30e9\u30c3\u30d7\u3057\u3066\u3044\u307e\u3059\u3002\n\n# QEMU\u4eee\u60f3\u30c7\u30d0\u30a4\u30b9\u3092QEMU\u306b\u767b\u9332\u3059\u308b\nQEMU\u81ea\u4f53\u306fC\u8a00\u8a9e\u3067\u66f8\u304b\u308c\u3066\u3044\u307e\u3059\u304c\u3001\u69cb\u9020\u4f53\u3092\u5229\u7528\u3057\u305f\u30aa\u30d6\u30b8\u30a7\u30af\u30c8\u6307\u5411\u306e\n\u66f8\u304d\u65b9 (QOM : QEMU Objet Model) \u306b\u3088\u3063\u3066\u30cf\u30fc\u30c9\u30a6\u30a7\u30a2\u7b49\u306e\u30aa\u30d6\u30b8\u30a7\u30af\u30c8\u304c\u8a18\u8ff0\u3055\u308c\u3066\u3044\u307e\u3059\u3002\n\u3053\u308c\u306b\u3064\u3044\u3066\u306f include/qom/object.h \u306e\u8aac\u660e\u304c\u53c2\u8003\u306b\u306a\u308a\u307e\u3059\u3002\n\n\u3042\u308b\u30aa\u30d6\u30b8\u30a7\u30af\u30c8\u306b\u306f\u5bfe\u5fdc\u3059\u308b\u30aa\u30d6\u30b8\u30a7\u30af\u30c8\u30af\u30e9\u30b9\u304c\n\u305f\u30601\u3064\u5b58\u5728\u3057(\u30af\u30e9\u30b9\u3082QOM\u3067\u3059)\u3001\n\u30af\u30e9\u30b9\u306e\u521d\u671f\u5316\u304c\u30aa\u30d6\u30b8\u30a7\u30af\u30c8\u306e\u521d\u671f\u5316\u3088\u308a\u524d\u306b\u8d77\u3053\u308a\u307e\u3059\u3002\n\u307e\u305f\u3001\u7d99\u627f\u95a2\u4fc2\u306b\u5fdc\u3058\u3066\u89aa\u30aa\u30d6\u30b8\u30a7\u30af\u30c8/\u30af\u30e9\u30b9\u306e\u521d\u671f\u5316\u304c\n\u5b50\u30aa\u30d6\u30b8\u30a7\u30af\u30c8/\u30af\u30e9\u30b9\u306e\u521d\u671f\u5316\u306e\u524d\u306b\u884c\u308f\u308c\u307e\u3059\u3002\n\n\u30af\u30e9\u30b9\u306b\u306f\u901a\u5e38\u5404\u30aa\u30d6\u30b8\u30a7\u30af\u30c8\u304c\u30aa\u30fc\u30d0\u30fc\u30e9\u30a4\u30c9\u3059\u308b(\u95a2\u6570\u30dd\u30a4\u30f3\u30bf\u306e\u5024\u3092\u7f6e\u304d\u63db\u3048\u308b)\n\u95a2\u6570\u30dd\u30a4\u30f3\u30bf\u3084\u3001\u305d\u306e\u30af\u30e9\u30b9\u306e\u30c7\u30d0\u30a4\u30b9\u304c\u6301\u3064\u3079\u304d\u30c7\u30fc\u30bf\u304c\u3042\u308a\u307e\u3059\u3002\n\nPCI\u30c7\u30d0\u30a4\u30b9\u306b\u306fPCI\u30c7\u30d0\u30a4\u30b9\u7528\u306e\u8a18\u8ff0\u306e\u4ed5\u65b9\u304c\u7528\u610f\u3055\u308c\u3066\u3044\u308b\u306e\u3067\u3001\u65e2\u5b58\n\u306e\u30b3\u30fc\u30c9\u3092\u53c2\u8003\u306b(hw/misc/pci-testdev.c \u306a\u3069)\u4ee5\u4e0b\u306e\u30b3\u30fc\u30c9\u3092\u66f8\u304d\u307e\u3057\u305f\u3002\n\u306a\u304a\u3001\u30aa\u30d6\u30b8\u30a7\u30af\u30c8\u306e\u69cb\u9020\u4f53\u540d\u3084\u30de\u30af\u30ed\u540d\u3001\u5909\u6570\u540d\u306e\u4ed8\u3051\u65b9\u306f\u4ed6\u306e\u30d5\u30a1\u30a4\u30eb\u306b\u306a\u3089\u3063\u3066\u3044\u307e\u3059\u3002\n\n```c\n\n// test_pci_device.c \u629c\u7c8b\n#include \"hw/hw.h\"\n#include \"hw/pci/pci.h\"\n\n#include \"<path_to>/test_pci.h\"\n\n#define TEST_PCI_DEVICE_DEBUG\n\n#ifdef  TEST_PCI_DEVICE_DEBUG\n#define tprintf(fmt, ...) printf(\"## (%3d) %-20s: \" fmt, __LINE__, __func__, ## __VA_ARGS__)\n#else\n#define tprintf(fmt, ...)\n#endif\n\ntypedef struct TestPCIState {\n\tPCIDevice parent_obj;\n\t\n\t/* ... */\n\n\tMemoryRegion mmio;\n\tMemoryRegion portio;\n} TestPCIState;\n\n#define TYPE_TEST_PCI \"test_pci\"\n\n#define TEST_PCI(obj) \\\n    OBJECT_CHECK(TestPCIState, (obj), TYPE_TEST_PCI)\n\nstatic uint64_t\ntest_pci_mmio_read(void *opaque, hwaddr addr, unsigned size)\n{\n    TestPCIState *s = opaque;\n\n\t\t/* \u7565 */\n}\n\nstatic uint64_t\ntest_pci_pio_read(void *opaque, hwaddr addr, unsigned size)\n{\n    TestPCIState *s = opaque;\n\n\t\t/* \u7565 */\n}\n\nstatic void\ntest_pci_mmio_write(void *opaque, hwaddr addr, uint64_t val,\n                       unsigned size)\n{\n    TestPCIState *s = opaque;\n\n\t\t/* \u7565 */\n}\n\nstatic void\ntest_pci_pio_write(void *opaque, hwaddr addr, uint64_t val,\n                       unsigned size)\n{\n    TestPCIState *s = opaque;\n\n\t\t/* \u7565 */\n}\n\nstatic const MemoryRegionOps test_pci_mmio_ops = {\n    .read = test_pci_mmio_read,\n    .write = test_pci_mmio_write,\n    .endianness = DEVICE_LITTLE_ENDIAN,\n    .impl = {\n        .min_access_size = 4,\n        .max_access_size = 4,\n    },\n};\n\nstatic const MemoryRegionOps test_pci_pio_ops = {\n    .read = test_pci_pio_read,\n    .write = test_pci_pio_write,\n    .endianness = DEVICE_LITTLE_ENDIAN,\n    .impl = {\n        .min_access_size = 1,\n        .max_access_size = 4,\n    },\n};\n\nstatic int test_pci_init(PCIDevice *pdev)\n{\n    TestPCIState *s = TEST_PCI(pdev);\n    uint8_t *pci_conf;\n\t\tint i;\n  \n    pci_conf = pdev->config;\n    pci_conf[PCI_INTERRUPT_PIN] = 1; /* if 0 no interrupt pin */\n\n\t\t// register memory mapped io / port mapped io\n    memory_region_init_io(&s->mmio, OBJECT(s), &test_pci_mmio_ops,  s,\n                          \"test_pci_mmio\", TEST_PCI_MEMSIZE * 2);\n    memory_region_init_io(&s->portio, OBJECT(s), &test_pci_pio_ops, s,\n                          \"test_pci_portio\", TEST_PCI_IOSIZE * 2);\n\n\t\t// set base address register \n    pci_register_bar(pdev, BAR_MMIO, PCI_BASE_ADDRESS_SPACE_MEMORY, &s->mmio);\n    pci_register_bar(pdev, BAR_PIO , PCI_BASE_ADDRESS_SPACE_IO    , &s->portio);\n\n    tprintf(\"loaded\\n\");\n    return 0;\n}\n\nstatic void\ntest_pci_uninit(PCIDevice *pdev)\n{\n    TestPCIState *s = TEST_PCI(pdev);\n\n\tmemory_region_destroy(&s->mmio);\n\tmemory_region_destroy(&s->portio);\n\n    tprintf(\"unloaded\\n\");\n}\n\nstatic void\ntest_pci_reset(TestPCIState *s)\n{\n    tprintf(\"done reset\\n\");\n}\n\nstatic void qdev_test_pci_reset(DeviceState *ds)\n{\n\tTestPCIState *s = TEST_PCI(ds);\n\ttest_pci_reset(s);\n}\n\nstatic void test_pci_class_init(ObjectClass *klass, void *data)\n{\n    DeviceClass *dc = DEVICE_CLASS(klass);\n    PCIDeviceClass *k = PCI_DEVICE_CLASS(klass);\n\n    k->init = test_pci_init;\n    k->exit = test_pci_uninit;\n    k->vendor_id = PCI_VENDOR_ID_TEST;\n    k->device_id = PCI_DEVICE_ID_TEST;\n    k->revision = 0x00;\n    k->class_id = PCI_CLASS_OTHERS;\n    dc->desc = \"Test PCI Virtual Device\";\n    set_bit(DEVICE_CATEGORY_MISC, dc->categories);\n    dc->reset = qdev_test_pci_reset;\n}\n\nstatic const TypeInfo test_pci_info = {\n    .name          = TYPE_TEST_PCI,\n    .parent        = TYPE_PCI_DEVICE,\n    .instance_size = sizeof(TestPCIState),\n    .class_init    = test_pci_class_init,\n};\n\nstatic void test_pci_register_types(void)\n{\n    type_register_static(&test_pci_info);\n}\n\ntype_init(test_pci_register_types)\n```\n\n\u3053\u3053\u3067\u3001\u4eee\u60f3\u30c7\u30d0\u30a4\u30b9\u306e\u30aa\u30d6\u30b8\u30a7\u30af\u30c8\u306f struct TestPCIState \u3067\n\u89aa\u3068\u3057\u3066 PCIDevice \u3092\u6301\u3063\u3066\u3044\u307e\u3059\u3002\u3053\u306e\u69d8\u306b\u30aa\u30d6\u30b8\u30a7\u30af\u30c8\u306f\u5fc5\u305a\u7b2c\u4e00\u5f15\u6570\u306b\n\u89aa\u306e\u69cb\u9020\u4f53\u3092\u6301\u3061\u3001\u305d\u306e\u30aa\u30d6\u30b8\u30a7\u30af\u30c8\u3092\u89aa\u306e\u578b\u306b\u30ad\u30e3\u30b9\u30c8\u3059\u308b\u3053\u3068\u3067\n\u89aa\u306e\u30aa\u30d6\u30b8\u30a7\u30af\u30c8\u3078\u30a2\u30af\u30bb\u30b9\u3059\u308b\u3053\u3068\u304c\u51fa\u6765\u307e\u3059\u3002\n\u3000\u4f8b\u3048\u3070\u3001 test_pci_class_init \u95a2\u6570\u306b\u304a\u3044\u3066\u306f \u5f15\u6570\u306e\u30af\u30e9\u30b9\u30aa\u30d6\u30b8\u30a7\u30af\u30c8\u3092\nPCI_DEVICE_CLASS \u30de\u30af\u30ed\u3067\u30ad\u30e3\u30b9\u30c8\u3059\u308b\u3053\u3068\u3067\u3001\n\u305d\u306e\u89aa\u30af\u30e9\u30b9(PCIDeviceClass)\u306b\u30a2\u30af\u30bb\u30b9\u3057\u3001\n\u3055\u3089\u306b PCIDeviceClass \u306e\u89aa\u3067\u3042\u308bObjectClass \u306b\u3001OBJECT_CLASS \u30de\u30af\u30ed\u3067\n\u30ad\u30e3\u30b9\u30c8\u3092\u884c\u3063\u3066\u30a2\u30af\u30bb\u30b9\u3057\u3066\u3044\u307e\u3059\u3002\n\n\u3053\u306e\u30c7\u30d0\u30a4\u30b9\u306e\u30af\u30e9\u30b9\u306f test_pci_class_init \u306b\u3042\u308b\u3088\u3046\u306b\nPCI_DEVICE_CLASS \u3068\u306a\u3063\u3066\u3044\u307e\u3059\u3002\n\nTestPCIState \u4e2d\u306e MmeoryRegion \u5909\u6570\u304c\u30dd\u30fc\u30c8I/O, \u30e1\u30e2\u30ea\u30de\u30c3\u30d7\u30c9I/O \u3092\u5229\u7528\u3059\u308b\u9818\u57df\u3092\u8a2d\u5b9a\u3057\u307e\u3059\u3002\u3053\u3053\u3067\u306f\u30dd\u30fc\u30c8I/O\u3001\u30e1\u30e2\u30ea\u30de\u30c3\u30d7\u30c9I/O\u306e\u9818\u57df\u30921\u3064\u305a\u3064\n\u7528\u610f\u3057\u3066\u3044\u307e\u3059\u3002\n\n\u4e00\u756a\u6700\u5f8c\u306b\u3042\u308b type_init \u30de\u30af\u30ed\u306b\u3088\u308a\u3053\u306e\u4eee\u60f3\u30cf\u30fc\u30c9\u30a6\u30a7\u30a2\u304c\u767b\u9332\u3055\u308c\u307e\u3059\u3002\n\u3055\u3089\u306b\u3001type_register_static \u3092\u901a\u3057\u3066\u767b\u9332\u3055\u308c\u305f\u30cf\u30fc\u30c9\u30a6\u30a7\u30a2\u60c5\u5831(struct test_pci_info)\u306b\u521d\u671f\u5316\u95a2\u6570\u3084\u30d9\u30f3\u30c0ID\u3068\u3044\u3063\u305f\u3082\u306e\u304c\u8a18\u8ff0\u3055\u308c\u307e\u3059\u3002\n\n\u30af\u30e9\u30b9\u306e\u521d\u671f\u5316(test_pci_class_init)\u3067\u306f\u30d9\u30f3\u30c0ID\u3084\u30c7\u30d0\u30a4\u30b9ID\u306a\u3069\u306e\u8a2d\u5b9a\u3084\u3001\n\u30aa\u30d6\u30b8\u30a7\u30af\u30c8\u306e\u521d\u671f\u5316\u95a2\u6570\u306a\u3069\u3092\u6307\u5b9a\u3057\u3066\u3044\u307e\u3059\u3002\n\n\u4e00\u65b9\u30aa\u30d6\u30b8\u30a7\u30af\u30c8\u306e\u521d\u671f\u5316(test_pci_init) \u306b\u304a\u3044\u3066\u306f\u307e\u305a TEST_PCI(obj)\u30de\u30af\u30ed\u3092\u5229\u7528\u3057\u3066\u3001\n\u89aa\u30e1\u30f3\u30d0\u3092\u6301\u3064 TestPCIState \u30aa\u30d6\u30b8\u30a7\u30af\u30c8\u306e\u305f\u3081\u306e\u9818\u57df\u3092\u4f5c\u6210\u3057\u3066\u3044\u307e\u3059\n(\u8a73\u3057\u304f\u306f include/qom/object.h \u3092\u898b\u3066\u304f\u3060\u3055\u3044) \u3002\n\u305d\u306e\u5f8c\u3001\u5272\u308a\u8fbc\u307f\u306e\u6709\u7121\u3068\u5404\u30e1\u30e2\u30ea\u9818\u57df(MemoryRegion)\u306b\u5bfe\u5fdc\u3059\u308b\n\u95a2\u6570\u306e\u6307\u5b9a\u3092\u884c\u3063\u3066\u3044\u307e\u3059(\u3053\u308c\u3089\u306e\u60c5\u5831\u304cPCI\u30b3\u30f3\u30d5\u30a3\u30ae\u30e5\u30ec\u30fc\u30b7\u30e7\u30f3\u7a7a\u9593\u306b\u66f8\u304b\u308c\u307e\u3059)\u3002\n\n\u306a\u304a\u3001MemoryRegion \u521d\u671f\u5316\u6642\u306b\u5fc5\u8981\u3068\u306a\u308b MemoryRegionOps\n\u306eimpl\u30e1\u30f3\u30d0\u306emin_access_size,max_access_size\n\u304c\u5b9f\u88c5\u4e0a\u306e\u30a2\u30af\u30bb\u30b9\u30b5\u30a4\u30ba\u3092\u898f\u5b9a\u3057\u307e\u3059\u3002\u4f8b\u3048\u3070I/O \u30dd\u30fc\u30c8\u304b\u3089\u306f\ninl/outl\u547d\u4ee4\u306b\u3088\u308a4\u30d0\u30a4\u30c8\u8aad\u307f\u8fbc\u307f/\u66f8\u304d\u8fbc\u307f\u304c\u3067\u304d\u307e\u3059\u304c\u3001max_access_size \u304c1\u3067\n\u3042\u3063\u305f\u5834\u5408\u306f\u5bfe\u5fdc\u3059\u308bread/write \u95a2\u6570\u304c4\u56de\u547c\u3070\u308c\u308b\u3053\u3068\u306b\u306a\u308a\u307e\u3059\u3002\u307e\u305f\u3001\n\u3082\u3057min_access_size \u304c4\u3067\u3042\u308b\u306a\u3089\u30701\u30d0\u30a4\u30c8\u306e\u30a2\u30af\u30bb\u30b9\u95a2\u6570(inb \u306a\u3069)\n\u3092\u30c9\u30e9\u30a4\u30d0\u304c\u4f7f\u7528\u3057\u305f\u5834\u5408\u3067\u3082 read/write \u95a2\u6570\u306e\u7b2c\u56db\u5f15\u6570 size \u304c4\u3068\u306a\u308a\u307e\u3059\u3002\n\n\u307e\u305f\u3001\u3053\u3053\u3067\u6307\u5b9a\u3057\u305f\u540d\u524d(test_pci_info \u306e name : TYPE_TEST_PCI == \"test_pci\") \u304c\nqemu\u3092\u8d77\u52d5\u3059\u308b\u3068\u304d\u306b\u30aa\u30d7\u30b7\u30e7\u30f3\u3067\u6307\u5b9a\u3059\u308b\u540d\u524d\u3067\u3059(-device test_pci)\u3002\n\n\u4ee5\u4e0a\u306e\u3088\u3046\u306b\u30bd\u30fc\u30b9\u30b3\u30fc\u30c9\u3092\u66f8\u304dQEMU\u3092\u30b3\u30f3\u30d1\u30a4\u30eb\u3057\u305f\u5f8c\u3001 -device test_pci \u30aa\u30d7\u30b7\u30e7\u30f3\u3092\n\u3064\u3051\u3066\u8d77\u52d5\u3057\u3001lspci \u30b3\u30de\u30f3\u30c9\u3092\u5b9f\u884c\u3059\u308b\u3068\u8a2d\u5b9a\u3057\u305f\u30d9\u30f3\u30c0ID/\u30c7\u30d0\u30a4\u30b9ID\u306e\nPCI\u30c7\u30d0\u30a4\u30b9\u304c Linux \u304b\u3089\u8a8d\u8b58\u3055\u308c\u3066\u3044\u308b\u3053\u3068\u304c\u78ba\u8a8d\u3067\u304d\u307e\u3059\u3002\n\n---\n## \u30c7\u30d0\u30a4\u30b9\u306e\u767b\u9332\u306b\u3064\u3044\u3066\n\n\u3053\u306e\u69d8\u306b\u3001QEMU \u306e\u5404\u30aa\u30d6\u30b8\u30a7\u30af\u30c8\u306e\u30bd\u30fc\u30b9\u30b3\u30fc\u30c9\u306b\u306f type_init \u304c\u66f8\u304b\u308c\u3066\u3044\u307e\u3059\u3002\ntype_init \u306f\u5b9f\u306f\u30de\u30af\u30ed\u3067\u3042\u308a\u3055\u3089\u306b modle_init \u30de\u30af\u30ed\u306b\u7f6e\u304d\u63db\u308f\u308a\u3001\n\u6700\u7d42\u7684\u306b \\_\\_attribute\\_\\_constructor()\\_\\_  \u5c5e\u6027\u304c\u3064\u304f\u95a2\u6570\u304c\u4f5c\u3089\u308c\u307e\u3059\u3002\n\u3053\u306e\u5c5e\u6027\u304c\u4ed8\u304f\u95a2\u6570\u306f main \u95a2\u6570\u306e\u5b9f\u884c\u3088\u308a\u3082\u524d\u306b\u5b9f\u884c\u3055\u308c\u307e\u3059\u3002\n\u306a\u304a\u3001\u30a8\u30df\u30e5\u30ec\u30fc\u30b7\u30e7\u30f3\u30de\u30b7\u30f3\u5168\u4f53\u3092\u767b\u9332\u3059\u308b\u5834\u5408\u306f machine_init \u3068\u3044\u3046\u30de\u30af\u30ed\n(\u540c\u69d8\u306b module_init \u306b\u7f6e\u304d\u63db\u308f\u308b) \u304c\u4f7f\u308f\u308c\u307e\u3059\u3002\n\n```c\n// include/qemu/module.h \u4e2d\n\n #define module_init(function, type)                                         \\\n static void __attribute__((constructor)) do_qemu_init_ ## function(void)    \\\n {                                                                           \\\n     register_dso_module_init(function, type);                               \\\n }\n #else\n /* This should not be used directly.  Use block_init etc. instead.  */\n #define module_init(function, type)                                         \\\n static void __attribute__((constructor)) do_qemu_init_ ## function(void)    \\\n {                                                                           \\\n     register_module_init(function, type);                                   \\\n }\n #endif\n \n typedef enum {\n     MODULE_INIT_BLOCK,\n     MODULE_INIT_MACHINE,\n     MODULE_INIT_QAPI,\n     MODULE_INIT_QOM,\n     MODULE_INIT_MAX\n } module_init_type;\n \n #define block_init(function) module_init(function, MODULE_INIT_BLOCK)\n #define machine_init(function) module_init(function, MODULE_INIT_MACHINE)\n #define qapi_init(function) module_init(function, MODULE_INIT_QAPI)\n #define type_init(function) module_init(function, MODULE_INIT_QOM)\n```\n\n\u4f8b\u3048\u3070 type_init(some_function) \u306b\u5bfe\u3057\u3066 do_qemu_init_some_function \u3068\u3044\u3046\u540d\u524d\u306e\u95a2\u6570\u304c\u4f5c\u3089\u308c\u3001\nQEMU \u306emain\u95a2\u6570\u304c\u5b9f\u884c\u3055\u308c\u308b\u3088\u308a\u524d\u306b\u5b9f\u884c\u3055\u308c\u308b\u3053\u3068\u306b\u306a\u308a\u307e\u3059\u3002\n\u305d\u306e\u95a2\u6570\u306f\u7d50\u5c40register_module_init\u304bregister_dso_module_init(\u9055\u3044\u306f\u308f\u304b\u308a\u307e\u305b\u3093) \u3092\u547c\u3073\u3001\n\u6700\u7d42\u7684\u306b\u30ea\u30b9\u30c8(QTAILQ)\u306b\u540d\u524d\u3068\u521d\u671f\u5316\u95a2\u6570\u304c\u767b\u9332\u3055\u308c\u307e\u3059\u3002\n\nQEMU \u306e main \u95a2\u6570(vl.c \u306e\u4e2d) \u306e\u521d\u3081\u306e\u65b9\u306b\u304a\u3044\u3066 module_call_init \u304c\u547c\u3070\u308c\u3066\u304a\u308a\u3001\n\u3053\u308c\u304c\u5404\u30ea\u30b9\u30c8\u3092\u305f\u3069\u3063\u3066\u9806\u756a\u306b\u767b\u9332\u3055\u308c\u305f\u521d\u671f\u5316\u95a2\u6570\u3092\u5b9f\u884c\u3057\u3066\u3044\u307e\u3059\u3002\n\u57fa\u672c\u7684\u306b\u305d\u308c\u3089\u306e\u95a2\u6570\u306f\u4eca\u56de\u306e\u4f8b\u306e\u3088\u3046\u306b type_register_static \u306a\u3069\u3092\u547c\u3073\u51fa\u3057\u3066\n\u305d\u306e\u30aa\u30d6\u30b8\u30a7\u30af\u30c8\u306e\u30bf\u30a4\u30d7\u3092\u30cf\u30c3\u30b7\u30e5\u8868\u306b\u767b\u9332\u3057\u3066\u304a\u308a\u3001\u3053\u306e\u8868\u3092\n\u65b0\u3057\u3044\u30aa\u30d6\u30b8\u30a7\u30af\u30c8\u3092\u751f\u6210\u3059\u308b\u3068\u304d\u306b\u4f7f\u7528\u3057\u3066\u3044\u308b\u3088\u3046\u3067\u3059\u3002\n\n# \u30c7\u30d0\u30a4\u30b9\u30c9\u30e9\u30a4\u30d0\u306e\u767b\u9332\n\n\u30c7\u30d0\u30a4\u30b9\u30c9\u30e9\u30a4\u30d0\u306f\u307e\u305a\u81ea\u8eab\u3092\u30ab\u30fc\u30cd\u30eb\u306b\u767b\u9332\u3059\u308b\u5fc5\u8981\u304c\u3042\u308a\u307e\u3059\u3002\n\nPCI\u30c7\u30d0\u30a4\u30b9\u3001\u30ad\u30e3\u30e9\u30af\u30bf\u30c7\u30d0\u30a4\u30b9 \u5171\u306b\u767b\u9332\u306b\u306f\u6c7a\u307e\u3063\u305f\u3084\u308a\u65b9\u304c\u3042\u308b\u306e\u3067\n\u3053\u308c\u306b\u5f93\u3044\u307e\u3059\u3002\n\n\u306a\u304aPCI\u30c7\u30d0\u30a4\u30b9\u3068\u3057\u3066\u306e\u60c5\u5831\u306f struct pci_dev,\n\u30ad\u30e3\u30e9\u30af\u30bf\u30c7\u30d0\u30a4\u30b9\u3068\u3057\u3066\u306e\u60c5\u5831\u306fstruct cdev \u306b\u683c\u7d0d\u3055\u308c\u307e\u3059\u3002\n\n```c\n// test_pci_driver.c (\u4e00\u90e8)\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/cdev.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/device.h>\n#include <linux/pci.h>\n#include <linux/interrupt.h>\n#include <asm/dma.h>\n#include <asm/current.h>\n#include <asm/uaccess.h>\n\n#include \"test_pci.h\"\n\nMODULE_LICENSE(\"GPL\");\n// MODULE_AUTHOR(\"tm\");\nMODULE_DESCRIPTION(\"device driver for test pci\");\n\n#define DRIVER_TEST_NAME \"test_pci\"\n#define DEVICE_TEST_NAME \"test_pci_dev\"\n\n#define TEST_PCI_DRIVER_DEBUG\n#ifdef  TEST_PCI_DRIVER_DEBUG\n#define tprintk(fmt, ...) printk(KERN_ALERT \"** (%3d) %-20s: \" fmt, __LINE__,  __func__,  ## __VA_ARGS__)\n#else\n#define tprintk(fmt, ...) \n#endif\n\n// max device count (minor number)\nstatic int test_pci_devs_max = 1;\n\n// if test_pci_major = 0 then use dynamic allocation\nstatic unsigned int test_pci_major = 0;\n// get parameter from console if needed for test_pci_major when insmod\nmodule_param(test_pci_major, uint, 0);\n\nstatic unsigned int test_pci_minor = 0; // static allocation\n\nstatic dev_t test_pci_devt; // MKDEV(test_pci_major, test_pci_minor)\n\nstruct test_device_data {\n\tstruct pci_dev *pdev;\n\tstruct cdev *cdev;\n\n\t// for PCI pio/mmio\n\tunsigned long pio_base, pio_flags, pio_length;\n\tunsigned long mmio_base, mmio_flags, mmio_length;\n\tchar *mmio_addr;\n\n\tunsigned int pio_memsize;\n\n\t// for consistent/streaming dma\n\tdma_addr_t cdma_addr, sdma_addr;\n\tint cdma_len, sdma_len;\n\tvoid *cdma_buffer, *sdma_buffer;\n\n\twait_queue_head_t sdma_q;\n};\n\nstatic struct test_device_data *dev_data;\n\nstatic int test_pci_open(struct inode *inode, struct file *file)\n{\n\n\tfile->private_data = NULL;\n\n\treturn 0; // success\n}\n\nstatic int test_pci_close(struct inode *inode, struct file *file)\n{\n\n\tif(file->private_data) {\n\t\tkfree(file->private_data);\n\t\tfile->private_data = NULL;\n\t}\n\n\treturn 0; // success\n}\n\nstruct file_operations test_pci_fops = \n{\n\t.open = test_pci_open,\n\t.release = test_pci_close,\n};\n\n//-----------------------------------------------------------------\n// supported pci id type\nstatic struct pci_device_id test_pci_ids[] =\n{\n\t{ PCI_DEVICE(PCI_VENDOR_ID_TEST, PCI_DEVICE_ID_TEST) },\n\t{ 0, },\n};\n\n// export pci_device_id\nMODULE_DEVICE_TABLE(pci, test_pci_ids);\n\n\n//-----------------------------------------------------------------\n// pci initialization function\n// enable pci & register character device\nstatic int test_pci_probe (struct pci_dev *pdev,\n\t\tconst struct pci_device_id *id)\n{\n\tint err;\n\tchar irq;\n\n\tint alloc_ret = 0;\n\tint cdev_err = 0;\n\n\tshort vendor_id, device_id;\n\n\n\t//-----------------------------------------------------------------\n\t// config PCI\n\t// enable pci device\n\terr = pci_enable_device(pdev);\n\tif(err) {\n\t\tprintk(KERN_ERR \"can't enable pci device\\n\");\n\t\tgoto error; \n\t}\n\ttprintk(\"PCI enabled for %s\\n\", DRIVER_TEST_NAME);\n\n\t// request PCI region\n\t// bar 0 ... MMIO\n\tdev_data->mmio_base = pci_resource_start(pdev, BAR_MMIO);\n\tdev_data->mmio_length = pci_resource_len(pdev, BAR_MMIO);\n\tdev_data->mmio_flags = pci_resource_flags(pdev, BAR_MMIO);\n\ttprintk( \"mmio_base: %lx, mmio_length: %lx, mmio_flags: %lx\\n\",\n\t\t\tdev_data->mmio_base, dev_data->mmio_length, dev_data->mmio_flags);\n\n\tdev_data->mmio_addr = ioremap(dev_data->mmio_base, TEST_PCI_MEMSIZE);\n\n\tif(!(dev_data->mmio_flags & IORESOURCE_MEM)){\n\t\tprintk(KERN_ERR \"BAR%d is not for mmio\\n\", BAR_MMIO);\n\t\tgoto error;\n\t}\n\n\terr = pci_request_region(pdev, BAR_MMIO, DRIVER_TEST_NAME);\n\tif(err) {\n\t\tprintk(KERN_ERR \"%s :error pci_request_region MMIO\\n\", __func__);\n\t\tgoto error; \n\t}\n\n\t\n\t// bar 1 ... IO port\n\tdev_data->pio_base = pci_resource_start(pdev, BAR_PIO);\n\tdev_data->pio_length = pci_resource_len(pdev, BAR_PIO);\n\tdev_data->pio_flags = pci_resource_flags(pdev, BAR_PIO);\n\ttprintk(\"pio_base: %lx, pio_length: %lx, pio_flags: %lx\\n\",\n\t\t\tdev_data->pio_base, dev_data->pio_length, dev_data->pio_flags);\n\n\tif(!(dev_data->pio_flags & IORESOURCE_IO)){\n\t\tprintk(KERN_ERR \"BAR%d is not for pio\\n\", BAR_PIO);\n\t\tgoto error;\n\t}\n\n\terr = pci_request_region(pdev, BAR_PIO, DRIVER_TEST_NAME);\n\tif(err) {\n\t\tprintk(KERN_ERR \"%s :error pci_request_region PIO\\n\", __func__);\n\t\tgoto error; \n\t}\n\n\t// show PCI configuration data\n\t// define at include/uapi/linux/pci_regs.h\n\tpci_read_config_word(pdev, PCI_VENDOR_ID, &vendor_id);\n\tpci_read_config_word(pdev, PCI_DEVICE_ID, &device_id);\n\ttprintk(\"PCI Vendor ID:%x, Device ID:%x\\n\", vendor_id, device_id);\n\n\n\tdev_data->pdev = pdev;\n\tdev_data->pio_memsize = TEST_PIO_DATASIZE;\n\n\ttprintk(\"sucess allocate i/o region\\n\");\n\n\t//-----------------------------------------------------------------\n\t// config irq \n\t// get irq number\n\tirq = pdev->irq; // same as pci_read_config_byte(pdev, PCI_INTERRUPT_LINE, &irq);\n\ttprintk(\"device irq: %d\\n\", irq);\n\n\terr = request_irq(irq, test_pci_handler, 0, DRIVER_TEST_NAME, pdev);\n\tif(err){\n\t\tprintk(KERN_ERR \"%s :error request irq %d\\n\", __func__, irq);\n\t\tgoto error;\n\t}\n\n\n\t//-----------------------------------------------------------------\n\t// register character device\n\t// allocate major number\n\talloc_ret = alloc_chrdev_region(&test_pci_devt, test_pci_minor, test_pci_devs_max, DRIVER_TEST_NAME);\n\tif(alloc_ret) goto error;\n\n\ttest_pci_major = MAJOR(test_pci_devt);\n\n\tdev_data->cdev = (struct cdev*)kmalloc(sizeof(struct cdev), GFP_KERNEL);\n\tif(!dev_data->cdev) goto error;\n\n\tcdev_init(dev_data->cdev, &test_pci_fops);\n\tdev_data->cdev->owner = THIS_MODULE;\n\n\tcdev_err = cdev_add(dev_data->cdev, test_pci_devt, test_pci_devs_max);\n\tif(cdev_err) goto error;\n\n\ttprintk(\"%s driver(major %d) installed.\\n\", DRIVER_TEST_NAME, test_pci_major);\n\n\t//-----------------------------------------------------------------\n\t// config DMA\n\terr = pci_set_dma_mask(pdev, DMA_BIT_MASK(32));\n\tif(err) {\n\t\tprintk(KERN_ERR \"Cannot set DMA mask\\n\");\n\t\tgoto error;\n\t}\n\tpci_set_master(pdev);\n\n\t// allocate consistent DMA\n\tdev_data->cdma_buffer = pci_alloc_consistent(pdev, TEST_CDMA_BUFFER_SIZE, &dev_data->cdma_addr);\n\tif(dev_data->cdma_buffer == NULL) {\n\t\tprintk(KERN_ERR \"Cannot allocate consistent DMA buffer\\n\");\n\t\tgoto error;\n\t}\n\tdev_data->cdma_len = TEST_CDMA_BUFFER_SIZE;\n\n\t// send consistent DMA info to device\n\toutl(dev_data->cdma_addr, dev_data->pio_base + TEST_SET_CDMA_ADDR);\n\toutl(dev_data->cdma_len,  dev_data->pio_base + TEST_SET_CDMA_LEN);\n\n\ttprintk(\"cdma_addr : %x\\n\",  dev_data->cdma_addr);\n\n\t// streaming DMA\n\tdev_data->sdma_buffer = kmalloc(TEST_SDMA_BUFFER_SIZE, GFP_KERNEL);\n\tif(dev_data->sdma_buffer == NULL) {\n\t\tprintk(KERN_ERR \"Cannot allocate streaming DMA buffer\\n\");\n\t\tgoto error;\n\t}\n\tinit_waitqueue_head(&(dev_data->sdma_q));\n\n\treturn 0;\n\nerror:\n\ttprintk(\"PCI load error\\n\");\n\tif(cdev_err == 0) cdev_del(dev_data->cdev);\n\n\tif(alloc_ret == 0) unregister_chrdev_region(test_pci_devt, test_pci_devs_max);\n\n\treturn -1;\n}\n\nstatic void test_pci_remove(struct pci_dev *pdev)\n{\n\t// DMA\n\tpci_free_consistent(dev_data->pdev, TEST_CDMA_BUFFER_SIZE,\n\t\t\tdev_data->cdma_buffer, dev_data->cdma_addr);\n\n\t// character device\n\tcdev_del(dev_data->cdev);\n\tunregister_chrdev_region(test_pci_devt, test_pci_devs_max);\n\n\t// irq\n\tfree_irq(dev_data->pdev->irq, dev_data->pdev);\n\n\t// memory mapped i/o\n\tiounmap(dev_data->mmio_addr);\n\n\t/pci\n\tpci_release_region(dev_data->pdev, BAR_MMIO);\n\tpci_release_region(dev_data->pdev, BAR_PIO);\n\tpci_disable_device(dev_data->pdev);\n\n\ttprintk(\"%s driver (major %d) unloaded\\n\", DRIVER_TEST_NAME, test_pci_major);\n}\n\nstatic struct pci_driver test_pci_driver =\n{\n\t.name = DRIVER_TEST_NAME,\n\t.id_table = test_pci_ids,\n\t.probe = test_pci_probe,\n\t.remove = test_pci_remove,\n};\n\n//-----------------------------------------------------------------\n// module init/exit\nstatic int __init test_pci_init(void)\n{\n\tdev_data = kmalloc(sizeof(struct test_device_data), GFP_KERNEL);\n\tif(!dev_data) {\n\t\tprintk(KERN_ERR \"cannot allocate device data memory\\n\");\n\t\treturn -1; // should return other value?\n\t}\n\n\treturn pci_register_driver(&test_pci_driver);\n}\n\nstatic void __exit test_pci_exit(void)\n{\n\tpci_unregister_driver(&test_pci_driver);\n\tkfree(dev_data);\n}\n\nmodule_init(test_pci_init);\nmodule_exit(test_pci_exit);\n\n```\n\n\u30c9\u30e9\u30a4\u30d0\u56fa\u6709\u306e\u30c7\u30fc\u30bf\u306f struct test_device_data \u3068\u3057\u3066\u69cb\u9020\u4f53\u306b\n\u307e\u3068\u3081\u3066\u3042\u308a\u307e\u3059\u3002\u4eca\u56de\u306f\u30de\u30a4\u30ca\u30fc\u756a\u53f7\u306b\u3064\u3044\u3066\u306f\u8003\u3048\u3066\u3044\u307e\u305b\u3093\u304c\u3001\n\u8003\u3048\u308b\u5834\u5408\u306f\u30de\u30a4\u30ca\u30fc\u756a\u53f7\u6bce\u306e\u30c7\u30fc\u30bf\u3092\u914d\u5217\u3068\u3057\u3066\u78ba\u4fdd\u3059\u308b\u306a\u3069\u306e\u5fc5\u8981\u304c\u3042\u308a\u307e\u3059\u3002\n\n\u30d7\u30ed\u30b0\u30e9\u30e0\u306e\u6700\u5f8c\u306b\u66f8\u304b\u308c\u3066\u3044\u308b\u3088\u3046\u306b\u3001\u30c7\u30d0\u30a4\u30b9\u30c9\u30e9\u30a4\u30d0\u306b\u306f\u5fc5\u305amodule_init \u3068module_exit \u3067\u6307\u5b9a\u3055\u308c\u305f\n\u521d\u671f\u5316\u6642/\u7d42\u4e86\u6642\u306b\u5b9f\u884c\u3055\u308c\u308b\u95a2\u6570\u304c\u3042\u308a\u307e\u3059\n(\u30ed\u30fc\u30c0\u30d6\u30eb\u30e2\u30b8\u30e5\u30fc\u30eb\u306e\u5834\u5408\u306f insmod/rmmod \u6642\u306b\u5b9f\u884c\u3055\u308c\u308b\u95a2\u6570)\u3002\n\u306a\u304a\u3001\\__init \u5c5e\u6027\u3092\u3064\u3051\u308b\u3068\u5b9f\u884c\u5f8c\u30e1\u30e2\u30ea\u304c\u958b\u653e\u3055\u308c\u3001\\__exit \u5c5e\u6027\u3092\u3064\u3051\u308b\u3068\n\u30e2\u30b8\u30e5\u30fc\u30eb\u304c\u30a2\u30f3\u30ed\u30fc\u30c9\u3055\u308c\u306a\u3044\u5834\u5408(\u4e88\u3081\u30ab\u30fc\u30cd\u30eb\u306b\u7d44\u307f\u8fbc\u307e\u308c\u308b\u3068\u304d)\n\u30e1\u30e2\u30ea\u304c\u958b\u653e\u3055\u308c\u308b\u3088\u3046\u306b\u306a\u308a\u307e\u3059\u3002\n\nPCI\u30c7\u30d0\u30a4\u30b9\u306e\u5834\u5408\u306fmodule_init\u3067\u767b\u9332\u3057\u305f\u95a2\u6570\u304b\u3089\npci_register_driver \u3092\u547c\u3073\u51fa\u3057\u3001PCI\u30c7\u30d0\u30a4\u30b9\u306e\u767b\u9332\u3092\u884c\u3044\u307e\u3059\u3002\n\u5b9f\u969b\u306e\u521d\u671f\u5316\u306f\u305d\u306e\u95a2\u6570\u306b\u6e21\u3057\u305f\u69cb\u9020\u4f53(struct pci_driver) \u306e\u30e1\u30f3\u30d0\u306b\u3042\u308bprobe\n\u306e\u95a2\u6570\u304c\u884c\u3044\u307e\u3059(\u3053\u3053\u3067\u306f\u3001test_pci_probe)\u3002\n\n\u307e\u305f\u3053\u308c\u3068\u306f\u5225\u306b struct pci_device_id \u306e\u914d\u5217\u306b\u305d\u306e\u30c9\u30e9\u30a4\u30d0\u304c\u5bfe\u5fdc\u3059\u308b\n\u30c7\u30d0\u30a4\u30b9ID\u306a\u3069\u306e\u60c5\u5831\u3092\u30bb\u30c3\u30c8(PCI_DEVICE\u30de\u30af\u30ed\u3092\u4f7f\u7528)\u3057\u3001\nMODULE_DEVICE_TABLE\u306b\u30a8\u30af\u30b9\u30dd\u30fc\u30c8\u3057\u307e\u3059\u3002\n1\u3064\u306e\u30c9\u30e9\u30a4\u30d0\u304c\u8907\u6570\u306e\u30c7\u30d0\u30a4\u30b9\u306b\u5bfe\u5fdc\u3059\u308b\u3053\u3068\u304c\u53ef\u80fd\u3067\u3059\u3002\n\u3053\u308c\u306b\u3088\u308a\u3001\u30c9\u30e9\u30a4\u30d0\u3092\u30ed\u30fc\u30c9\u3057\u305f\u6642\u3084\u65b0\u305f\u306bPCI\u30c7\u30d0\u30a4\u30b9\u3092\u691c\u77e5\u3057\u305f\u6642\u306b\u5bfe\u5fdc\u3059\u308b\n\u30c9\u30e9\u30a4\u30d0\u306e\u521d\u671f\u5316\u95a2\u6570\u304c\u81ea\u52d5\u3067\u5b9f\u884c\u3055\u308c\u307e\u3059\u3002\n\n### PCI probe \u95a2\u6570\n\nprobe\u95a2\u6570\u306b\u304a\u3044\u3066\u306f\u307e\u305a pci_enable_device \u306b\u3088\u308aPCI\u30c7\u30d0\u30a4\u30b9\u3092\u6709\u52b9\u5316\u3057\u305f\u5f8c\u306b\u3001\npic_request_region \u95a2\u6570\u3067I/O \u30dd\u30fc\u30c8\u3084\u30e1\u30e2\u30ea\u30de\u30c3\u30d7\u30c9I/O\u306e\u9818\u57df\u3092\u78ba\u4fdd\u3057\u307e\u3059\u3002\n\u306a\u304a\u3001BAR\u9818\u57df\u306e\u60c5\u5831\u306fpci_resource_start \u306a\u3069\u306e\u95a2\u6570\u304b\u3089\u5165\u624b\u3067\u304d\u307e\u3059\u3002\npci_resource_start \u306f\u305d\u306e\u9818\u57df\u304c\u59cb\u307e\u308b\u30dd\u30fc\u30c8\u756a\u53f7(I/O\u30dd\u30fc\u30c8\u306e\u5834\u5408)\u3084\n\u7269\u7406\u30a2\u30c9\u30ec\u30b9(\u30e1\u30e2\u30ea\u30de\u30c3\u30d7\u30c9I/O\u306e\u5834\u5408)\u3092\u8fd4\u3057\u3001pci_resource_length \u304c\u305d\u306e\u9577\u3055\n\u3068\u306a\u308a\u307e\u3059\u3002\u307e\u305f\u3001\u305d\u306e\u4ed6\u306ePCI \u30b3\u30f3\u30d5\u30a3\u30ae\u30e5\u30ec\u30fc\u30b7\u30e7\u30f3\u7a7a\u9593\u306e\u60c5\u5831\u306f\npci_read_config_byte/word \u306a\u3069\u306e\u95a2\u6570\u304b\u3089\u8aad\u307f\u53d6\u308c\u307e\u3059\n(\u3053\u3053\u3067\u306f\u78ba\u8a8d\u306e\u305f\u3081\u306b\u30c7\u30d0\u30a4\u30b9\u756a\u53f7\u306a\u3069\u3092\u53d6\u5f97\u3057\u3001printk \u3057\u3066\u3044\u307e\u3059\u304c\n\u30c9\u30e9\u30a4\u30d0\u306f\u3053\u308c\u3089\u306e\u60c5\u5831\u3092\u77e5\u3063\u3066\u3044\u308b\u306f\u305a\u3067\u3059)\u3002\n\n\u6b21\u306b\u5272\u308a\u8fbc\u307f\u306e\u8a2d\u5b9a\u3092\u884c\u3044\u307e\u3059(\u5f8c\u8ff0)\u3002\n\n\u305d\u306e\u5f8cPCI\u30c7\u30d0\u30a4\u30b9\u306e\u7a2e\u985e\u306b\u5fdc\u3058\u305f\u30af\u30e9\u30b9\u3078\u767b\u9332\u3057\u307e\u3059(\u3053\u3053\u3067\u306f\u30ad\u30e3\u30e9\u30af\u30bf\u30c7\u30d0\u30a4\u30b9)\u3002\nalloc_chrdev_region \u3067\u52d5\u7684\u306b\u30e1\u30b8\u30e3\u30fc\u756a\u53f7\u3092\u5272\u308a\u5f53\u3066\u3001\ncdev_init, cdev_add \u306b\u3088\u308a\u30c7\u30d0\u30a4\u30b9\u3092\u767b\u9332\u3057\u3066\u3044\u307e\u3059\u3002\u306a\u304a\u3001\u4eca\u56de\u306f\n\u30de\u30a4\u30ca\u30fc\u756a\u53f7\u306b\u3088\u308b\u30c7\u30d0\u30a4\u30b9\u306e\u533a\u5225\u306f\u884c\u3063\u3066\u3044\u307e\u305b\u3093\n\n\u6700\u5f8c\u306b\u5fc5\u8981\u3067\u3042\u308b\u306a\u3089\u3070DMA\u306e\u8a2d\u5b9a\u3092\u884c\u3044\u307e\u3059(\u5f8c\u8ff0)\u3002\n\n \n\u4e00\u65b9\u3067\u3001module_exit \u3067\u6307\u5b9a\u3057\u305f\u95a2\u6570\u3084 struct pci_driver \u306e remove \u95a2\u6570\u3067\u306f\n\u521d\u671f\u5316\u6642\u306b\u78ba\u4fdd\u3057\u305f\u9818\u57df\u306e\u767b\u9332\u89e3\u6d88\u3084\u958b\u653e\u3092\u884c\u3044\u307e\u3059\u3002\n\u5fc5\u9808\u3067\u306f\u3042\u308a\u307e\u305b\u3093\u304c\u521d\u671f\u5316\u306e\u9806\u756a\u3068\u306f\u9006\u306b\u884c\u3046\u3053\u3068\u304c\u4e00\u822c\u7684\u306a\u3088\u3046\u3067\u3059\u3002\n\u9069\u5207\u306b\u7d42\u4e86\u51e6\u7406\u3092\u884c\u308f\u306a\u3044\u3068\u7d42\u4e86\u6642\u3084\u3001\u30e2\u30b8\u30e5\u30fc\u30eb\u306e\u518d\u30ed\u30fc\u30c9\u6642\u306b\u30ab\u30fc\u30cd\u30eb\u30d1\u30cb\u30c3\u30af\n\u3092\u8d77\u3053\u3057\u307e\u3059\u3002\n\n\u306a\u304a\u3001\u30c7\u30d0\u30a4\u30b9\u30c9\u30e9\u30a4\u30d0\u306b\u304a\u3044\u3066\u306f\u30a8\u30e9\u30fc\u51e6\u7406\u306bgoto\u6587\u3092\u4f7f\u3046\n\u3053\u3068\u306f\u666e\u901a\u3060\u3068\u3044\u3046\u3053\u3068\u306a\u306e\u3067\u3001\u3053\u3053\u3067\u3082\u305d\u306e\u66f8\u304d\u65b9\u306b\u306a\u3089\u3063\u3066\u3044\u307e\u3059\u3002\n\n\u30b7\u30b9\u30c6\u30e0\u30b3\u30fc\u30eb\u7528\u306e\u95a2\u6570\u306f struct file_operations \u3092\u7528\u3044\u3066\u767b\u9332\u3057\u307e\u3059\u3002\n\u6700\u4f4e\u9650 open/close \u306b\u5bfe\u5fdc\u3059\u308b\u30e1\u30f3\u30d0 (.open/.release) \u306b\u95a2\u6570\u3092\u7528\u610f\u3057\u307e\u3059\u3002\n\n\u3053\u306e\u30e2\u30b8\u30e5\u30fc\u30eb\u3092\u30b3\u30f3\u30d1\u30a4\u30eb\u5f8c insmod/mknod \u3092\u884c\u3044\u30c9\u30e9\u30a4\u30d0\u3092\u30ed\u30fc\u30c9\u3059\u308b\u3068\u3001\n/proc/iomem, ioports, interrupt \u306a\u3069\u306e\u60c5\u5831\u306b test_pci \u306e\u540d\u524d\u304c\u4ed8\u304f\u3053\u3068\u304c\n\u78ba\u8a8d\u3067\u304d\u307e\u3059\u3002\n\n# \u30e6\u30fc\u30b6\u30fc\u30d7\u30ed\u30b0\u30e9\u30e0\n\u30c7\u30d0\u30a4\u30b9\u30d5\u30a1\u30a4\u30eb\u3092\u958b\u304f\u306b\u306fopen/close \u30b7\u30b9\u30c6\u30e0\u30b3\u30fc\u30eb\u3092\u5229\u7528\u3057\u307e\u3059\u3002\n\n```c\nint open_device(const char* filename)\n{\n\tint fd;\n\n\tfd = open(filename, O_RDWR);\n\tif(fd == -1){\n\t\tprintf(\"can't open device: %s\", filename);\n\t\texit(1);\n\t}\n\n\tprintf(\"success: open device %s\\n\", filename);\n\treturn fd;\n}\n\nvoid close_device(int fd)\n{\n\tif(close(fd) != 0){\n\t\tprintf(\"can't close device\");\n\t\texit(1);\n\t}\n\n\tprintf(\"success: close device\\n\");\n}\n```\n\n# \u5b9f\u884c\u7d50\u679c\n-device test_pci \u3092\u4ed8\u3051\u3066 QEMU \u5b9f\u884c\u958b\u59cb\u5f8c\u306b\n\u5404\u7a2e\u30b3\u30de\u30f3\u30c9\u3092\u5b9f\u884c\u3059\u308b\u3068\u4ee5\u4e0b\u306e\u3088\u3046\u306b\u306a\u308a\u307e\u3059\u3002\n\n```\n# lspci\n00:00.0 Class 0600: 8086:1237\n00:01.0 Class 0601: 8086:7000\n00:01.1 Class 0101: 8086:7010\n00:01.3 Class 0680: 8086:7113\n00:02.0 Class 0300: 1013:00b8\n00:03.0 Class 0200: 8086:100e\n00:04.0 Class 00ff: 1234:0001 // \u4f5c\u6210\u3057\u305fPCI\u30c7\u30d0\u30a4\u30b9\n# lsmod\nModule                  Size  Used by    Tainted: G\n# insmod /drivers/test_pci_driver.ko\n** (315) test_pci_probe      : PCI enabled for test_pci\n** (323) test_pci_probe      : mmio_base: febf1000, mmio_length: 1000, mmio_flags: 40200\n** (344) test_pci_probe      : pio_base: c000, pio_length: 100, pio_flags: 40101\n** (361) test_pci_probe      : PCI Vendor ID:1234, Device ID:1\n** (367) test_pci_probe      : sucess allocate i/o region\n** (373) test_pci_probe      : device irq: 11\n** (399) test_pci_probe      : test_pci driver(major 254) installed.\n## (155) test_pci_pio_write  : addr 116, size 4\n## (155) test_pci_pio_write  : addr 120, size 4\n** (422) test_pci_probe      : cdma_addr : 79b7000\n# lsmod\nModule                  Size  Used by    Tainted: G\ntest_pci_driver         6252  0\n# cat /proc/ioports | grep test\n    c000-c0ff : test_pci\n# cat /proc/iomem | grep test\n    febf1000-febf1fff : test_pci\n# cat /proc/interrupts |grep test\n 11:          3    XT-PIC-XT-PIC    test_pci\n# cat /proc/devices | grep test\n254 test_pci\n# mknod /dev/test_pci c 254 0\n# rmmod test_pci_driver\n** (459) test_pci_remove     : test_pci driver (major 254) unloaded\n# rm /dev/test_pci\n# lsmod\nModule                  Size  Used by    Tainted: G\n#\n```\n\n\u307e\u305f\u3001ctrl-a+c \u3067\u30e2\u30cb\u30bf\u753b\u9762\u306b\u79fb\u52d5\u5f8c info pci \n\u306b\u3088\u308a\u4ee5\u4e0b\u306e\u60c5\u5831\u304c\u5f97\u3089\u308c\u307e\u3059\u3002\n\n```\n(qemu) info pci\n  Bus  0, device   0, function 0:\n    Host bridge: PCI device 8086:1237\n      id \"\"\n  Bus  0, device   1, function 0:\n    ISA bridge: PCI device 8086:7000\n      id \"\"\n  Bus  0, device   1, function 1:\n    IDE controller: PCI device 8086:7010\n      BAR4: I/O at 0xc140 [0xc14f].\n      id \"\"\n  Bus  0, device   1, function 3:\n    Bridge: PCI device 8086:7113\n      IRQ 9.\n      id \"\"\n  Bus  0, device   2, function 0:\n    VGA controller: PCI device 1013:00b8\n      BAR0: 32 bit prefetchable memory at 0xfc000000 [0xfdffffff].\n      BAR1: 32 bit memory at 0xfebf0000 [0xfebf0fff].\n      BAR6: 32 bit memory at 0xffffffffffffffff [0x0000fffe].\n      id \"\"\n  Bus  0, device   3, function 0:\n    Ethernet controller: PCI device 8086:100e\n      IRQ 11.\n      BAR0: 32 bit memory at 0xfebc0000 [0xfebdffff].\n      BAR1: I/O at 0xc100 [0xc13f].\n      BAR6: 32 bit memory at 0xffffffffffffffff [0x0003fffe].\n      id \"\"\n  Bus  0, device   4, function 0:\n    Class 0255: PCI device 1234:0001\n      IRQ 11.\n      BAR0: 32 bit memory at 0xfebf1000 [0xfebf1fff].\n      BAR1: I/O at 0xc000 [0xc0ff].\n      id \"\"\n```\nlspci \u30b3\u30de\u30f3\u30c9\u306e\u7d50\u679c\u3068\u4e00\u81f4\u3057\u3066\u3044\u307e\u3059\u3002\n\n---\n\u306f\u3058\u3081: [(1) \u4f5c\u3063\u305f\u3082\u306e]\n(http://qiita.com/rafilia/items/f7646d12212da2a85bd8)\n\n\u524d: [(3) \u958b\u767a/\u52d5\u4f5c\u74b0\u5883]\n(http://qiita.com/rafilia/items/ff02c38be2ab01220fcb)\n\u6b21: [(5)  I/O\u30dd\u30fc\u30c8\u306e\u4f7f\u7528]\n(http://qiita.com/rafilia/items/9e8d62444be472e573c2)\n", "tags": ["QEMU"]}