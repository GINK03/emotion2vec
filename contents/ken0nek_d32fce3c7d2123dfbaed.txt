{"tags": ["Swift", "Swift3.0"], "context": "\n\n\u3053\u306e\u8a18\u4e8b\u306b\u3064\u3044\u3066\n\u3010Swift\u3011\u914d\u5217\u306e\u914d\u5217\u306b\u3064\u3044\u3066\u8a73\u3057\u304f\u3002 - Qiita\u3067\u300c\u914d\u5217\u306e\u914d\u5217\u300d\u306b\u3064\u3044\u3066\u307e\u3068\u3081\u305f\u306e\u3067\u3059\u304c\u3001Swift3\u3067\u5909\u66f4\u70b9\u304c\u591a\u304f\u3042\u3063\u305f\u306e\u3067\u5225\u8a18\u4e8b\u306b\u3057\u307e\u3057\u305f\u3002\n\njoined\nsplit\nflatMap\n\n\njoined\n\nflatten\u304c\u306a\u304f\u306a\u308ajoined\u306b\u306a\u308a\u307e\u3057\u305f\u3002\n\n\u914d\u5217\u306e\u8981\u7d20\u304cString\u306e\u3068\u304d\n\nextension Array where Element == String {\n\n    /// Returns a new string by concatenating the elements of the sequence,\n    /// adding the given separator between each element.\n    ///\n    /// The following example shows how an array of strings can be joined to a\n    /// single, comma-separated string:\n    ///\n    ///     let cast = [\"Vivien\", \"Marlon\", \"Kim\", \"Karl\"]\n    ///     let list = cast.joined(separator: \", \")\n    ///     print(list)\n    ///     // Prints \"Vivien, Marlon, Kim, Karl\"\n    ///\n    /// - Parameter separator: A string to insert between each of the elements\n    ///   in this sequence. The default separator is an empty string.\n    /// - Returns: A single, concatenated string.\n    public func joined(separator: String = default) -> String\n}\n\n\n\u4f7f\u3044\u65b9\nlet cast = [\"Vivien\", \"Marlon\", \"Kim\", \"Karl\"]\nlet list = cast.joined(separator: \", \")\nprint(list)\n// \"Vivien, Marlon, Kim, Karl\"\n\n\u5358\u306b\u7d50\u5408\u3059\u308b\u3060\u3051\u306e\u3068\u304d\u306f\u5f15\u6570\u306a\u3057\u3067OK\nlet aiu = [\"\u3042\", \"\u3044\", \"\u3046\"]\nlet list = aiu.joined()\nprint(list)\n// \"\u3042\u3044\u3046\"\n\n\n\u914d\u5217\u306e\u914d\u5217\u306e\u3068\u304d\n\nextension Array where Element : Collection {\n\n    /// Returns the elements of this collection of collections, concatenated.\n    ///\n    /// In this example, an array of three ranges is flattened so that the\n    /// elements of each range can be iterated in turn.\n    ///\n    ///     let ranges = [0..<3, 8..<10, 15..<17]\n    ///\n    ///     // A for-in loop over 'ranges' accesses each range:\n    ///     for range in ranges {\n    ///       print(range)\n    ///     }\n    ///     // Prints \"0..<3\"\n    ///     // Prints \"8..<10\"\n    ///     // Prints \"15..<17\"\n    ///\n    ///     // Use 'joined()' to access each element of each range:\n    ///     for index in ranges.joined() {\n    ///         print(index, terminator: \" \")\n    ///     }\n    ///     // Prints: \"0 1 2 8 9 15 16\"\n    ///\n    /// - Returns: A flattened view of the elements of this\n    ///   collection of collections.\n    ///\n    /// - SeeAlso: `flatMap(_:)`, `joined(separator:)`\n    public func joined() -> FlattenCollection<Array<Element>>\n}\n\n\n/// Returns the concatenated elements of this sequence of sequences,\n    /// inserting the given separator between each element.\n    ///\n    /// This example shows how an array of `[Int]` instances can be joined, using\n    /// another `[Int]` instance as the separator:\n    ///\n    ///     let nestedNumbers = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n    ///     let joined = nestedNumbers.joined(separator: [-1, -2])\n    ///     print(Array(joined))\n    ///     // Prints \"[1, 2, 3, -1, -2, 4, 5, 6, -1, -2, 7, 8, 9]\"\n    ///\n    /// - Parameter separator: A sequence to insert between each of this\n    ///   sequence's elements.\n    /// - Returns: The joined sequence of elements.\n    ///\n    /// - SeeAlso: `joined()`\n    public func joined<Separator : Sequence where Separator.Iterator.Element == Iterator.Element.Iterator.Element>(separator: Separator) -> JoinedSequence<Array<Element>>\n\n\n\u4f7f\u3044\u65b9\n\u5358\u306b\u7d50\u5408\u3059\u308b\u3068\u304d \u2192 flatMap\nlet arrayOfArray = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\nprint(arrayOfArray.joined().map { $0 })\n// [1, 2, 3, 4, 5, 6, 7, 8, 9]\n\nprint(Array(arrayOfArray.joined()))\n// [1, 2, 3, 4, 5, 6, 7, 8, 9]\n\n\u5165\u308c\u5b50\u306e\u914d\u5217\u9593\u306b\u306a\u306b\u304b\u631f\u307f\u8fbc\u307f\u305f\u3044\u5834\u5408\u306fseparator\u3092\u914d\u5217\u3067\u6307\u5b9a\u3059\u308b\n\nlet arrayOfArray = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\nprint(arrayOfArray.joined(separator: [-1, -2]).map { $0 })\n// [1, 2, 3, -1, -2, 4, 5, 6, -1, -2, 7, 8, 9]\n\nprint(Array(arrayOfArray.joined(separator: [-1, -2])))\n// [1, 2, 3, -1, -2, 4, 5, 6, -1, -2, 7, 8, 9]\n\n\nPython\u306ejoin\u306e\u3088\u3046\u306b\u4f7f\u3044\u305f\u3051\u308c\u3070\nextension String {\n    func join (_ seq: [String]) -> String {\n        return seq.joined(separator: self)\n    }\n}\n\n\u3068\u5ba3\u8a00\u3057\u3066\u3001\u4ee5\u4e0b\u306e\u3088\u3046\u306b\u4f7f\u3048\u307e\u3059\u3002\nlet strArray = [\"foo\", \"bar\", \"buz\"]\n\n\"\".join(strArray)\n// \"foobarbuz\"\n\n\nsplit\n\n\n\u8981\u7d20\u3067\u6307\u5b9a\n\n\n    /// Returns the longest possible subsequences of the collection, in order,\n    /// around elements equal to the given element.\n    ///\n    /// The resulting array consists of at most `maxSplits + 1` subsequences.\n    /// Elements that are used to split the collection are not returned as part\n    /// of any subsequence.\n    ///\n    /// The following examples show the effects of the `maxSplits` and\n    /// `omittingEmptySubsequences` parameters when splitting a string at each\n    /// space character (\" \"). The first use of `split` returns each word that\n    /// was originally separated by one or more spaces.\n    ///\n    ///     let line = \"BLANCHE:   I don't want realism. I want magic!\"\n    ///     print(line.characters.split(separator: \" \")\n    ///                          .map(String.init))\n    ///     // Prints \"[\"BLANCHE:\", \"I\", \"don\\'t\", \"want\", \"realism.\", \"I\", \"want\", \"magic!\"]\"\n    ///\n    /// The second example passes `1` for the `maxSplits` parameter, so the\n    /// original string is split just once, into two new strings.\n    ///\n    ///     print(line.characters.split(separator: \" \", maxSplits: 1)\n    ///                           .map(String.init))\n    ///     // Prints \"[\"BLANCHE:\", \"  I don\\'t want realism. I want magic!\"]\"\n    ///\n    /// The final example passes `false` for the `omittingEmptySubsequences`\n    /// parameter, so the returned array contains empty strings where spaces\n    /// were repeated.\n    ///\n    ///     print(line.characters.split(separator: \" \", omittingEmptySubsequences: false)\n    ///                           .map(String.init))\n    ///     // Prints \"[\"BLANCHE:\", \"\", \"\", \"I\", \"don\\'t\", \"want\", \"realism.\", \"I\", \"want\", \"magic!\"]\"\n    ///\n    /// - Parameters:\n    ///   - separator: The element that should be split upon.\n    ///   - maxSplits: The maximum number of times to split the collection, or\n    ///     one less than the number of subsequences to return. If\n    ///     `maxSplits + 1` subsequences are returned, the last one is a suffix\n    ///     of the original collection containing the remaining elements.\n    ///     `maxSplits` must be greater than or equal to zero. The default value\n    ///     is `Int.max`.\n    ///   - omittingEmptySubsequences: If `false`, an empty subsequence is\n    ///     returned in the result for each consecutive pair of `separator`\n    ///     elements in the collection and for each instance of `separator` at\n    ///     the start or end of the collection. If `true`, only nonempty\n    ///     subsequences are returned. The default value is `true`.\n    /// - Returns: An array of subsequences, split from this collection's\n    ///   elements.\n    public func split(separator: Element, maxSplits: Int = default, omittingEmptySubsequences: Bool = default) -> [ArraySlice<Element>]\n\n\n\n\u6761\u4ef6\u3067\u6307\u5b9a\n\n\n    /// Returns the longest possible subsequences of the collection, in order,\n    /// that don't contain elements satisfying the given predicate.\n    ///\n    /// The resulting array consists of at most `maxSplits + 1` subsequences.\n    /// Elements that are used to split the sequence are not returned as part of\n    /// any subsequence.\n    ///\n    /// The following examples show the effects of the `maxSplits` and\n    /// `omittingEmptySubsequences` parameters when splitting a string using a\n    /// closure that matches spaces. The first use of `split` returns each word\n    /// that was originally separated by one or more spaces.\n    ///\n    ///     let line = \"BLANCHE:   I don't want realism. I want magic!\"\n    ///     print(line.characters.split(whereSeparator: { $0 == \" \" })\n    ///                          .map(String.init))\n    ///     // Prints \"[\"BLANCHE:\", \"I\", \"don\\'t\", \"want\", \"realism.\", \"I\", \"want\", \"magic!\"]\"\n    ///\n    /// The second example passes `1` for the `maxSplits` parameter, so the\n    /// original string is split just once, into two new strings.\n    ///\n    ///     print(\n    ///         line.characters.split(\n    ///             maxSplits: 1, whereSeparator: { $0 == \" \" }\n    ///             ).map(String.init))\n    ///     // Prints \"[\"BLANCHE:\", \"  I don\\'t want realism. I want magic!\"]\"\n    ///\n    /// The final example passes `false` for the `omittingEmptySubsequences`\n    /// parameter, so the returned array contains empty strings where spaces\n    /// were repeated.\n    ///\n    ///     print(line.characters.split(omittingEmptySubsequences: false, whereSeparator: { $0 == \" \" })\n    ///                           .map(String.init))\n    ///     // Prints \"[\"BLANCHE:\", \"\", \"\", \"I\", \"don\\'t\", \"want\", \"realism.\", \"I\", \"want\", \"magic!\"]\"\n    ///\n    /// - Parameters:\n    ///   - maxSplits: The maximum number of times to split the collection, or\n    ///     one less than the number of subsequences to return. If\n    ///     `maxSplits + 1` subsequences are returned, the last one is a suffix\n    ///     of the original collection containing the remaining elements.\n    ///     `maxSplits` must be greater than or equal to zero. The default value\n    ///     is `Int.max`.\n    ///   - omittingEmptySubsequences: If `false`, an empty subsequence is\n    ///     returned in the result for each pair of consecutive elements\n    ///     satisfying the `isSeparator` predicate and for each element at the\n    ///     start or end of the collection satisfying the `isSeparator`\n    ///     predicate. The default value is `true`.\n    ///   - isSeparator: A closure that takes an element as an argument and\n    ///     returns a Boolean value indicating whether the collection should be\n    ///     split at that element.\n    /// - Returns: An array of subsequences, split from this collection's\n    ///   elements.\n    public func split(maxSplits: Int = default, omittingEmptySubsequences: Bool = default, whereSeparator isSeparator: (Element) throws -> Bool) rethrows -> [ArraySlice<Element>]\n\n\n\u4f7f\u3044\u65b9\n\nlet array = [7, 2, 1, 2, 1, 1, 3, 2, 3, 4, 1, 5]\n\n// \u7a7a\u306e\u914d\u5217\u3092\u8a31\u5bb9\u3057\u306a\u3044\nprint(array.split(separator: 1).map { [Int]($0) })\n// [[7, 2], [2], [3, 2, 3, 4], [5]]\n\n// \u7a7a\u306e\u914d\u5217\u3092\u8a31\u5bb9\u3059\u308b\nprint(array.split(separator: 1, omittingEmptySubsequences: false).map { [Int]($0) })\n// [[7, 2], [2], [], [3, 2, 3, 4], [5]]\n\n// \u5076\u6570\u306e\u8981\u7d20\u3067\u5206\u5272\uff08\u6761\u4ef6\u6307\u5b9a\uff09\nprint(array.split { $0 % 2 == 0 }.map { [Int]($0) })\n// [[7], [1], [1, 1, 3], [3], [1, 5]]\n\n// \u30b3\u30f3\u30de\u3067\u5206\u5272\nlet line = \"hoge,piyo,foo,baa\"\nprint(line.characters.split { $0 == \",\" }.map(String.init))\n// [\"hoge\", \"piyo\", \"foo\", \"baa\"]\n\n\nflatMap\n\n\n    /// Returns an array containing the concatenated results of calling the\n    /// given transformation with each element of this sequence.\n    ///\n    /// Use this method to receive a single-level collection when your\n    /// transformation produces a sequence or collection for each element.\n    ///\n    /// In this example, note the difference in the result of using `map` and\n    /// `flatMap` with a transformation that returns an array.\n    ///\n    ///     let numbers = [1, 2, 3, 4]\n    /// \n    ///     let mapped = numbers.map { Array(count: $0, repeatedValue: $0) }\n    ///     // [[1], [2, 2], [3, 3, 3], [4, 4, 4, 4]]\n    /// \n    ///     let flatMapped = numbers.flatMap { Array(count: $0, repeatedValue: $0) }\n    ///     // [1, 2, 2, 3, 3, 3, 4, 4, 4, 4]\n    ///\n    /// In fact, `s.flatMap(transform)`  is equivalent to\n    /// `Array(s.map(transform).joined())`.\n    ///\n    /// - Parameter transform: A closure that accepts an element of this\n    ///   sequence as its argument and returns a sequence or collection.\n    /// - Returns: The resulting flattened array.\n    ///\n    /// - Complexity: O(*m* + *n*), where *m* is the length of this sequence\n    ///   and *n* is the length of the result.\n    /// - SeeAlso: `joined()`, `map(_:)`\n    public func flatMap<SegmentOfResult : Sequence>(_ transform: (Element) throws -> SegmentOfResult) rethrows -> [SegmentOfResult.Iterator.Element]\n\n\uff08\u53c2\u8003\uff09\n\n    /// Returns an array containing the non-`nil` results of calling the given\n    /// transformation with each element of this sequence.\n    ///\n    /// Use this method to receive an array of nonoptional values when your\n    /// transformation produces an optional value.\n    ///\n    /// In this example, note the difference in the result of using `map` and\n    /// `flatMap` with a transformation that returns an optional `Int` value.\n    ///\n    ///     let possibleNumbers = [\"1\", \"2\", \"three\", \"///4///\", \"5\"]\n    /// \n    ///     let mapped: [Int?] = numbers.map { str in Int(str) }\n    ///     // [1, 2, nil, nil, 5]\n    /// \n    ///     let flatMapped: [Int] = numbers.flatMap { str in Int(str) }\n    ///     // [1, 2, 5]\n    ///\n    /// - Parameter transform: A closure that accepts an element of this\n    ///   sequence as its argument and returns an optional value.\n    /// - Returns: An array of the non-`nil` results of calling `transform`\n    ///   with each element of the sequence.\n    ///\n    /// - Complexity: O(*m* + *n*), where *m* is the length of this sequence\n    ///   and *n* is the length of the result.\n    public func flatMap<ElementOfResult>(_ transform: (Element) throws -> ElementOfResult?) rethrows -> [ElementOfResult]\n\n\n\u4f7f\u3044\u65b9\n// \u7d50\u5408\nlet arrayOfArray = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\nprint(arrayOfArray.flatMap { $0 })\n// [1, 2, 3, 4, 5, 6, 7, 8, 9]\n\n\n// 1\u306e\u524a\u9664\nlet array = [7, 2, 1, 2, 1, 1, 3, 2, 3, 4, 1, 5]\nprint(array.split(separator: 1).flatMap { $0 })\n// [7, 2, 2, 3, 2, 3, 4, 5]\n\n\n\nmap\u3068flatMap\u306e\u6319\u52d5\u306e\u9055\u3044\n\n\nlet numbers = [1, 2, 3, 4]\n\nlet mapped = numbers.map { Array(repeating: $0, count: $0) }\nprint(mapped)\n// [[1], [2, 2], [3, 3, 3], [4, 4, 4, 4]]\n\nlet flatMapped = numbers.flatMap { Array(repeating: $0, count: $0) }\nprint(flatMapped)\n// [1, 2, 2, 3, 3, 3, 4, 4, 4, 4]\n\n# \u3053\u306e\u8a18\u4e8b\u306b\u3064\u3044\u3066\n\n[\u3010Swift\u3011\u914d\u5217\u306e\u914d\u5217\u306b\u3064\u3044\u3066\u8a73\u3057\u304f\u3002 - Qiita](http://qiita.com/ken0nek/items/dce8281570a2dcf48e17)\u3067\u300c\u914d\u5217\u306e\u914d\u5217\u300d\u306b\u3064\u3044\u3066\u307e\u3068\u3081\u305f\u306e\u3067\u3059\u304c\u3001Swift3\u3067\u5909\u66f4\u70b9\u304c\u591a\u304f\u3042\u3063\u305f\u306e\u3067\u5225\u8a18\u4e8b\u306b\u3057\u307e\u3057\u305f\u3002\n\n- `joined`\n- `split`\n- `flatMap`\n\n\n# `joined`\n\n`flatten`\u304c\u306a\u304f\u306a\u308a`joined`\u306b\u306a\u308a\u307e\u3057\u305f\u3002\n\n## \u914d\u5217\u306e\u8981\u7d20\u304c`String`\u306e\u3068\u304d\n\n```swift\n\nextension Array where Element == String {\n\n    /// Returns a new string by concatenating the elements of the sequence,\n    /// adding the given separator between each element.\n    ///\n    /// The following example shows how an array of strings can be joined to a\n    /// single, comma-separated string:\n    ///\n    ///     let cast = [\"Vivien\", \"Marlon\", \"Kim\", \"Karl\"]\n    ///     let list = cast.joined(separator: \", \")\n    ///     print(list)\n    ///     // Prints \"Vivien, Marlon, Kim, Karl\"\n    ///\n    /// - Parameter separator: A string to insert between each of the elements\n    ///   in this sequence. The default separator is an empty string.\n    /// - Returns: A single, concatenated string.\n    public func joined(separator: String = default) -> String\n}\n```\n\n### \u4f7f\u3044\u65b9\n\n```swift\nlet cast = [\"Vivien\", \"Marlon\", \"Kim\", \"Karl\"]\nlet list = cast.joined(separator: \", \")\nprint(list)\n// \"Vivien, Marlon, Kim, Karl\"\n```\n\n\u5358\u306b\u7d50\u5408\u3059\u308b\u3060\u3051\u306e\u3068\u304d\u306f\u5f15\u6570\u306a\u3057\u3067OK\n\n```swift\nlet aiu = [\"\u3042\", \"\u3044\", \"\u3046\"]\nlet list = aiu.joined()\nprint(list)\n// \"\u3042\u3044\u3046\"\n```\n\n\n\n## \u914d\u5217\u306e\u914d\u5217\u306e\u3068\u304d\n\n```swift\n\nextension Array where Element : Collection {\n\n    /// Returns the elements of this collection of collections, concatenated.\n    ///\n    /// In this example, an array of three ranges is flattened so that the\n    /// elements of each range can be iterated in turn.\n    ///\n    ///     let ranges = [0..<3, 8..<10, 15..<17]\n    ///\n    ///     // A for-in loop over 'ranges' accesses each range:\n    ///     for range in ranges {\n    ///       print(range)\n    ///     }\n    ///     // Prints \"0..<3\"\n    ///     // Prints \"8..<10\"\n    ///     // Prints \"15..<17\"\n    ///\n    ///     // Use 'joined()' to access each element of each range:\n    ///     for index in ranges.joined() {\n    ///         print(index, terminator: \" \")\n    ///     }\n    ///     // Prints: \"0 1 2 8 9 15 16\"\n    ///\n    /// - Returns: A flattened view of the elements of this\n    ///   collection of collections.\n    ///\n    /// - SeeAlso: `flatMap(_:)`, `joined(separator:)`\n    public func joined() -> FlattenCollection<Array<Element>>\n}\n```\n\n```swift\n\n/// Returns the concatenated elements of this sequence of sequences,\n    /// inserting the given separator between each element.\n    ///\n    /// This example shows how an array of `[Int]` instances can be joined, using\n    /// another `[Int]` instance as the separator:\n    ///\n    ///     let nestedNumbers = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n    ///     let joined = nestedNumbers.joined(separator: [-1, -2])\n    ///     print(Array(joined))\n    ///     // Prints \"[1, 2, 3, -1, -2, 4, 5, 6, -1, -2, 7, 8, 9]\"\n    ///\n    /// - Parameter separator: A sequence to insert between each of this\n    ///   sequence's elements.\n    /// - Returns: The joined sequence of elements.\n    ///\n    /// - SeeAlso: `joined()`\n    public func joined<Separator : Sequence where Separator.Iterator.Element == Iterator.Element.Iterator.Element>(separator: Separator) -> JoinedSequence<Array<Element>>\n```\n\n### \u4f7f\u3044\u65b9\n\n\u5358\u306b\u7d50\u5408\u3059\u308b\u3068\u304d \u2192 `flatMap`\n\n```swift\nlet arrayOfArray = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\nprint(arrayOfArray.joined().map { $0 })\n// [1, 2, 3, 4, 5, 6, 7, 8, 9]\n\nprint(Array(arrayOfArray.joined()))\n// [1, 2, 3, 4, 5, 6, 7, 8, 9]\n```\n\n\u5165\u308c\u5b50\u306e\u914d\u5217\u9593\u306b\u306a\u306b\u304b\u631f\u307f\u8fbc\u307f\u305f\u3044\u5834\u5408\u306f`separator`\u3092\u914d\u5217\u3067\u6307\u5b9a\u3059\u308b\n\n```swift\n\nlet arrayOfArray = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\nprint(arrayOfArray.joined(separator: [-1, -2]).map { $0 })\n// [1, 2, 3, -1, -2, 4, 5, 6, -1, -2, 7, 8, 9]\n\nprint(Array(arrayOfArray.joined(separator: [-1, -2])))\n// [1, 2, 3, -1, -2, 4, 5, 6, -1, -2, 7, 8, 9]\n```\n\n----\n\n`Python`\u306e`join`\u306e\u3088\u3046\u306b\u4f7f\u3044\u305f\u3051\u308c\u3070\n\n```swift\nextension String {\n    func join (_ seq: [String]) -> String {\n        return seq.joined(separator: self)\n    }\n}\n```\n\u3068\u5ba3\u8a00\u3057\u3066\u3001\u4ee5\u4e0b\u306e\u3088\u3046\u306b\u4f7f\u3048\u307e\u3059\u3002\n\n```swift\nlet strArray = [\"foo\", \"bar\", \"buz\"]\n\n\"\".join(strArray)\n// \"foobarbuz\"\n```\n\n# `split`\n\n- \u8981\u7d20\u3067\u6307\u5b9a\n\n```swift\n\n    /// Returns the longest possible subsequences of the collection, in order,\n    /// around elements equal to the given element.\n    ///\n    /// The resulting array consists of at most `maxSplits + 1` subsequences.\n    /// Elements that are used to split the collection are not returned as part\n    /// of any subsequence.\n    ///\n    /// The following examples show the effects of the `maxSplits` and\n    /// `omittingEmptySubsequences` parameters when splitting a string at each\n    /// space character (\" \"). The first use of `split` returns each word that\n    /// was originally separated by one or more spaces.\n    ///\n    ///     let line = \"BLANCHE:   I don't want realism. I want magic!\"\n    ///     print(line.characters.split(separator: \" \")\n    ///                          .map(String.init))\n    ///     // Prints \"[\"BLANCHE:\", \"I\", \"don\\'t\", \"want\", \"realism.\", \"I\", \"want\", \"magic!\"]\"\n    ///\n    /// The second example passes `1` for the `maxSplits` parameter, so the\n    /// original string is split just once, into two new strings.\n    ///\n    ///     print(line.characters.split(separator: \" \", maxSplits: 1)\n    ///                           .map(String.init))\n    ///     // Prints \"[\"BLANCHE:\", \"  I don\\'t want realism. I want magic!\"]\"\n    ///\n    /// The final example passes `false` for the `omittingEmptySubsequences`\n    /// parameter, so the returned array contains empty strings where spaces\n    /// were repeated.\n    ///\n    ///     print(line.characters.split(separator: \" \", omittingEmptySubsequences: false)\n    ///                           .map(String.init))\n    ///     // Prints \"[\"BLANCHE:\", \"\", \"\", \"I\", \"don\\'t\", \"want\", \"realism.\", \"I\", \"want\", \"magic!\"]\"\n    ///\n    /// - Parameters:\n    ///   - separator: The element that should be split upon.\n    ///   - maxSplits: The maximum number of times to split the collection, or\n    ///     one less than the number of subsequences to return. If\n    ///     `maxSplits + 1` subsequences are returned, the last one is a suffix\n    ///     of the original collection containing the remaining elements.\n    ///     `maxSplits` must be greater than or equal to zero. The default value\n    ///     is `Int.max`.\n    ///   - omittingEmptySubsequences: If `false`, an empty subsequence is\n    ///     returned in the result for each consecutive pair of `separator`\n    ///     elements in the collection and for each instance of `separator` at\n    ///     the start or end of the collection. If `true`, only nonempty\n    ///     subsequences are returned. The default value is `true`.\n    /// - Returns: An array of subsequences, split from this collection's\n    ///   elements.\n    public func split(separator: Element, maxSplits: Int = default, omittingEmptySubsequences: Bool = default) -> [ArraySlice<Element>]\n\n```\n\n- \u6761\u4ef6\u3067\u6307\u5b9a\n\n```swift\n\n    /// Returns the longest possible subsequences of the collection, in order,\n    /// that don't contain elements satisfying the given predicate.\n    ///\n    /// The resulting array consists of at most `maxSplits + 1` subsequences.\n    /// Elements that are used to split the sequence are not returned as part of\n    /// any subsequence.\n    ///\n    /// The following examples show the effects of the `maxSplits` and\n    /// `omittingEmptySubsequences` parameters when splitting a string using a\n    /// closure that matches spaces. The first use of `split` returns each word\n    /// that was originally separated by one or more spaces.\n    ///\n    ///     let line = \"BLANCHE:   I don't want realism. I want magic!\"\n    ///     print(line.characters.split(whereSeparator: { $0 == \" \" })\n    ///                          .map(String.init))\n    ///     // Prints \"[\"BLANCHE:\", \"I\", \"don\\'t\", \"want\", \"realism.\", \"I\", \"want\", \"magic!\"]\"\n    ///\n    /// The second example passes `1` for the `maxSplits` parameter, so the\n    /// original string is split just once, into two new strings.\n    ///\n    ///     print(\n    ///         line.characters.split(\n    ///             maxSplits: 1, whereSeparator: { $0 == \" \" }\n    ///             ).map(String.init))\n    ///     // Prints \"[\"BLANCHE:\", \"  I don\\'t want realism. I want magic!\"]\"\n    ///\n    /// The final example passes `false` for the `omittingEmptySubsequences`\n    /// parameter, so the returned array contains empty strings where spaces\n    /// were repeated.\n    ///\n    ///     print(line.characters.split(omittingEmptySubsequences: false, whereSeparator: { $0 == \" \" })\n    ///                           .map(String.init))\n    ///     // Prints \"[\"BLANCHE:\", \"\", \"\", \"I\", \"don\\'t\", \"want\", \"realism.\", \"I\", \"want\", \"magic!\"]\"\n    ///\n    /// - Parameters:\n    ///   - maxSplits: The maximum number of times to split the collection, or\n    ///     one less than the number of subsequences to return. If\n    ///     `maxSplits + 1` subsequences are returned, the last one is a suffix\n    ///     of the original collection containing the remaining elements.\n    ///     `maxSplits` must be greater than or equal to zero. The default value\n    ///     is `Int.max`.\n    ///   - omittingEmptySubsequences: If `false`, an empty subsequence is\n    ///     returned in the result for each pair of consecutive elements\n    ///     satisfying the `isSeparator` predicate and for each element at the\n    ///     start or end of the collection satisfying the `isSeparator`\n    ///     predicate. The default value is `true`.\n    ///   - isSeparator: A closure that takes an element as an argument and\n    ///     returns a Boolean value indicating whether the collection should be\n    ///     split at that element.\n    /// - Returns: An array of subsequences, split from this collection's\n    ///   elements.\n    public func split(maxSplits: Int = default, omittingEmptySubsequences: Bool = default, whereSeparator isSeparator: (Element) throws -> Bool) rethrows -> [ArraySlice<Element>]\n```\n\n## \u4f7f\u3044\u65b9\n\n\n```swift\n\nlet array = [7, 2, 1, 2, 1, 1, 3, 2, 3, 4, 1, 5]\n\n// \u7a7a\u306e\u914d\u5217\u3092\u8a31\u5bb9\u3057\u306a\u3044\nprint(array.split(separator: 1).map { [Int]($0) })\n// [[7, 2], [2], [3, 2, 3, 4], [5]]\n\n// \u7a7a\u306e\u914d\u5217\u3092\u8a31\u5bb9\u3059\u308b\nprint(array.split(separator: 1, omittingEmptySubsequences: false).map { [Int]($0) })\n// [[7, 2], [2], [], [3, 2, 3, 4], [5]]\n\n// \u5076\u6570\u306e\u8981\u7d20\u3067\u5206\u5272\uff08\u6761\u4ef6\u6307\u5b9a\uff09\nprint(array.split { $0 % 2 == 0 }.map { [Int]($0) })\n// [[7], [1], [1, 1, 3], [3], [1, 5]]\n\n// \u30b3\u30f3\u30de\u3067\u5206\u5272\nlet line = \"hoge,piyo,foo,baa\"\nprint(line.characters.split { $0 == \",\" }.map(String.init))\n// [\"hoge\", \"piyo\", \"foo\", \"baa\"]\n```\n\n# `flatMap`\n\n```swift\n\n    /// Returns an array containing the concatenated results of calling the\n    /// given transformation with each element of this sequence.\n    ///\n    /// Use this method to receive a single-level collection when your\n    /// transformation produces a sequence or collection for each element.\n    ///\n    /// In this example, note the difference in the result of using `map` and\n    /// `flatMap` with a transformation that returns an array.\n    ///\n    ///     let numbers = [1, 2, 3, 4]\n    /// \n    ///     let mapped = numbers.map { Array(count: $0, repeatedValue: $0) }\n    ///     // [[1], [2, 2], [3, 3, 3], [4, 4, 4, 4]]\n    /// \n    ///     let flatMapped = numbers.flatMap { Array(count: $0, repeatedValue: $0) }\n    ///     // [1, 2, 2, 3, 3, 3, 4, 4, 4, 4]\n    ///\n    /// In fact, `s.flatMap(transform)`  is equivalent to\n    /// `Array(s.map(transform).joined())`.\n    ///\n    /// - Parameter transform: A closure that accepts an element of this\n    ///   sequence as its argument and returns a sequence or collection.\n    /// - Returns: The resulting flattened array.\n    ///\n    /// - Complexity: O(*m* + *n*), where *m* is the length of this sequence\n    ///   and *n* is the length of the result.\n    /// - SeeAlso: `joined()`, `map(_:)`\n    public func flatMap<SegmentOfResult : Sequence>(_ transform: (Element) throws -> SegmentOfResult) rethrows -> [SegmentOfResult.Iterator.Element]\n```\n\n\uff08\u53c2\u8003\uff09\n\n```swift\n\n    /// Returns an array containing the non-`nil` results of calling the given\n    /// transformation with each element of this sequence.\n    ///\n    /// Use this method to receive an array of nonoptional values when your\n    /// transformation produces an optional value.\n    ///\n    /// In this example, note the difference in the result of using `map` and\n    /// `flatMap` with a transformation that returns an optional `Int` value.\n    ///\n    ///     let possibleNumbers = [\"1\", \"2\", \"three\", \"///4///\", \"5\"]\n    /// \n    ///     let mapped: [Int?] = numbers.map { str in Int(str) }\n    ///     // [1, 2, nil, nil, 5]\n    /// \n    ///     let flatMapped: [Int] = numbers.flatMap { str in Int(str) }\n    ///     // [1, 2, 5]\n    ///\n    /// - Parameter transform: A closure that accepts an element of this\n    ///   sequence as its argument and returns an optional value.\n    /// - Returns: An array of the non-`nil` results of calling `transform`\n    ///   with each element of the sequence.\n    ///\n    /// - Complexity: O(*m* + *n*), where *m* is the length of this sequence\n    ///   and *n* is the length of the result.\n    public func flatMap<ElementOfResult>(_ transform: (Element) throws -> ElementOfResult?) rethrows -> [ElementOfResult]\n```\n\n## \u4f7f\u3044\u65b9\n\n```\n// \u7d50\u5408\nlet arrayOfArray = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\nprint(arrayOfArray.flatMap { $0 })\n// [1, 2, 3, 4, 5, 6, 7, 8, 9]\n\n\n// 1\u306e\u524a\u9664\nlet array = [7, 2, 1, 2, 1, 1, 3, 2, 3, 4, 1, 5]\nprint(array.split(separator: 1).flatMap { $0 })\n// [7, 2, 2, 3, 2, 3, 4, 5]\n```\n\n- `map`\u3068`flatMap`\u306e\u6319\u52d5\u306e\u9055\u3044\n\n```swift\n\nlet numbers = [1, 2, 3, 4]\n\nlet mapped = numbers.map { Array(repeating: $0, count: $0) }\nprint(mapped)\n// [[1], [2, 2], [3, 3, 3], [4, 4, 4, 4]]\n\nlet flatMapped = numbers.flatMap { Array(repeating: $0, count: $0) }\nprint(flatMapped)\n// [1, 2, 2, 3, 3, 3, 4, 4, 4, 4]\n```\n"}