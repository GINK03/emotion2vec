{"tags": ["C++", "Iterator", "CSV"], "context": " More than 1 year has passed since last update.\u3053\u306e\u8a18\u4e8b\u306f\u3001C++ Advent Calendar 2015 \u306e10\u65e5\u76ee\u306e\u8a18\u4e8b\u3067\u3059\u3002\n\u6628\u65e5\u306f\u3001srz-zumix\u3055\u3093\u306e\u300c [Catch] REQUIRE  \u306e\u5f0f\u304c\u5c55\u958b\u3055\u308c\u308b\u4ed5\u7d44\u307f\u300d\u3067\u3057\u305f\u3002\n\u4eca\u65e5\u306f\u3001csv\u30d5\u30a9\u30fc\u30de\u30c3\u30c8\u3092iterator\u3067\u8aad\u307f\u66f8\u304d\u3057\u3066\u307f\u308b\u8a71\u3067\u3059\u3002\u4ee5\u4e0b\u306e\u3088\u3046\u306b\u4f7f\u3048\u308b\u30af\u30e9\u30b9\u3067\u3059\u3002\n\u30b3\u30fc\u30c9\u306fGitHub\u4e0a\u306b\u304a\u3044\u3066\u3042\u308a\u307e\u3059\u3002\uff08csv_iterator.hpp\uff09\n#include <iostream>\n#include <fstream>\n#include \"csv_iterator.hpp\"\n\nint main(){\n    //\u30ab\u30f3\u30de\u533a\u5207\u308a\uff08csv\uff09\u3067\u30d5\u30a1\u30a4\u30eb\u3092\u8aad\u307f\u3060\u3057\u3066\u3001\u30bf\u30d6\u533a\u5207\u308a\u3067\u753b\u9762\u306b\u51fa\u529b\u3059\u308b\n    auto oitr = csv::current(std::cout, csv::mode::tsv);\n\n    std::ifstream fin(\"data.csv\");\n    for(auto itr = csv::begin(fin, csv::mode::csv); itr != csv::end(fin); ++itr){\n        *oitr++ = *itr;\n        if(itr.eol())oitr.endl();\n    }\n\n    system(\"pause\");\n\n    return 0;\n}\n\n\n\u52d5\u6a5f\n\u30ab\u30f3\u30de\u3067\u4e00\u884c\u304c\u8907\u6570\u306e\u30d5\u30a3\u30fc\u30eb\u30c9\u306b\u533a\u5207\u3089\u308c\u305f\u30d5\u30a1\u30a4\u30eb\u306e\u3053\u3068\u3092csv\u3068\u3044\u3044\u307e\u3059\u3002\u30ab\u30f3\u30de\u306e\u4ee3\u308f\u308a\u306b\u30b9\u30da\u30fc\u30b9\u3084\u30bf\u30d6\u3067\u533a\u5207\u3089\u308c\u305f\u30d5\u30a1\u30a4\u30eb\u3082\u3001\u305d\u308c\u305e\u308cssv\u3001tsv\u3068\u547c\u3070\u308c\u3001\u3057\u3070\u3057\u3070\u4f7f\u308f\u308c\u308b\u3088\u3046\u3067\u3059\u3002\n\u30d5\u30a9\u30fc\u30de\u30c3\u30c8\u306f\u975e\u5e38\u306b\u5358\u7d14\u306a\u306e\u3067\u3001\u5165\u51fa\u529b\u306f\u7c21\u5358\u3067\u3059\u3002\u5165\u529b\u306f\u3001\u4e00\u884c\u305a\u3064\u8aad\u3093\u3067\u306fboost::algorithm::split\u95a2\u6570\u3042\u305f\u308a\u3092\u4f7f\u3046\u306e\u304c\u4e00\u756a\u52b9\u7387\u304c\u3044\u3044\u3067\u3057\u3087\u3046\u3002\u51fa\u529b\u306f\u3001\u30d5\u30a3\u30fc\u30eb\u30c9\u9593\u306b\u533a\u5207\u308a\u6587\u5b57\u3092\u51fa\u529b\u3059\u308b\u3060\u3051\u3067\u3059\u3002\u304a\u624b\u8efd\u3067\u3059\u306d\u3002\n\u305f\u3060\u3001csv\u7cfb\u306e\u30d5\u30a1\u30a4\u30eb\u306f\u305f\u307e\u306b\u8aad\u307f\u66f8\u304d\u3059\u308b\u6a5f\u4f1a\u304c\u3042\u308b\u306e\u3067\u3059\u304c\u3001\u4ee5\u4e0b\u306e\u3088\u3046\u306a\u4e0d\u6e80\u70b9\u304c\u3042\u308a\u307e\u3057\u305f\u3002\n\n\u5165\u51fa\u529b\u3092\u4e00\u8cab\u3057\u305f\u65b9\u6cd5\u3067\u66f8\u3051\u306a\u3044\n\u4f3c\u305f\u3088\u3046\u306a\u51e6\u7406\u3092\u3001\u3042\u3061\u3053\u3061\u306b\u7e70\u308a\u8fd4\u3057\u66f8\u304f\u5fc5\u8981\u304c\u3042\u308a\u683c\u597d\u60aa\u3044\n\n\u30d5\u30a1\u30a4\u30eb\u4e2d\u306b\u542b\u307e\u308c\u308b\u30d5\u30a3\u30fc\u30eb\u30c9\u3092\u4e38\u3054\u3068\u30b3\u30f3\u30c6\u30ca\u3068\u3057\u3066\u78ba\u4fdd\u3059\u308b\u3088\u3046\u306a\u30af\u30e9\u30b9\u3092\u66f8\u3051\u3070\u3044\u3044\u306e\u304b\u3082\u3057\u308c\u307e\u305b\u3093\uff08\u4f8b\u3048\u3070\u3001\u3053\u3093\u306a\u30af\u30e9\u30b9\u7b49\uff09\u304c\u3001\u3082\u3046\u3061\u3087\u3063\u3068\u5c0f\u7c92\u3067\u5165\u51fa\u529b\u5185\u5bb9\u81ea\u4f53\u306e\u51e6\u7406\u306b\u96c6\u4e2d\u3067\u304d\u308b\u3001csv\u7cfb\u30d5\u30a1\u30a4\u30eb\u5165\u51fa\u529b\u7528\u306e\u30e9\u30c3\u30d1\u30fc\u30af\u30e9\u30b9\u304c\u6b32\u3057\u304f\u306a\u308a\u307e\u3057\u305f\u3002\n\u3068\u3044\u3046\u3053\u3068\u3067\u3001csv\u306e\u30d5\u30a3\u30fc\u30eb\u30c9\u3092 iterator \u3063\u307d\u304f\u6271\u3048\u308b\u30af\u30e9\u30b9\u3092\u4f5c\u3063\u3066\u307f\u307e\u3057\u305f\u3002\n\n\u51fa\u529b\u306e\u8a2d\u8a08\n\u307e\u305a\u3001\u51fa\u529b\u3067\u3059\u3002output_iterator\u3063\u307d\u304f\u4f7f\u3044\u305f\u3044\u306e\u3067\u3001\u4ee5\u4e0b\u306e\u3088\u3046\u306b\u3064\u304b\u308b\u3053\u3068\u304c\u671b\u307e\u3057\u3044\u3067\u3059\u3002\nstd::vector<std::string> StringSet = {\"Red\", \"Blue\", \"Green\", ...};\n\nstd::ofstream fout(\"test.csv\");\nauto oitr = csv::begin(fout);\n\n//StringSet\u914d\u5217\u5185\u306e\u6587\u5b57\u5217\u3092\u9806\u306b\u51fa\u529b\nfor(auto Str: StringSet){\n   *oitr = Str;\n   ++oitr;   //\u6b21\u306e\u30d5\u30a3\u30fc\u30eb\u30c9\u3078\n}\n\n//\u6539\u884c\u306fendl\u30e1\u30f3\u30d0\u95a2\u6570\noitr.endl();\n\n\u3055\u3066\u3001\u305d\u308c\u3067\u306f\u3055\u3063\u305d\u304f\u4f5c\u3063\u3066\u307f\u307e\u3059\u3002std::iterator\u3092\u7d99\u627f\u3057\u3066\u3001\u4ee5\u4e0b\u306e\u3088\u3046\u306aoutput_iterator\u30af\u30e9\u30b9\u3092\u4f5c\u308a\u307e\u3059\u3002\ntemplate<class Elem = char, class Traits = std::char_traits<Elem> >\nclass basic_ocsv_iterator : public std::iterator < std::output_iterator_tag, void, void, void, void >{\nprivate:\n    using my_type = basic_ocsv_iterator < Elem, Traits >;\n    using ostream_type = std::basic_ostream < Elem, Traits >;\n    using string_type = std::basic_string < Elem, Traits >;\n    using csv_mode_type = basic_csv_mode<Elem, Traits>;\nprivate:\n    struct output_cell;\nprivate:\n    ostream_type* pstream;\n    csv_mode_type CSVMode;\n    bool IsCellHead;\n    bool IsLineHead;\npublic:\n    basic_ocsv_iterator()\n        : pstream(nullptr){}\n    basic_ocsv_iterator(ostream_type& Stream_, csv_mode_type CSVMode_)\n        : pstream(&Stream_)\n        , CSVMode(CSVMode_)\n        , IsCellHead(false)\n        , IsLineHead(true){}\n    basic_ocsv_iterator(const my_type& My_) = default;\n    my_type& operator=(const my_type& My_) = default;\npublic:\n    operator bool()const{ return pstream; }\n    output_cell operator*(){ return output_cell(*this); }\n    my_type& operator++(){\n        IsCellHead = true;\n        IsLineHead = false;\n        return *this;\n    }\n    my_type operator++(int){\n        my_type ans(*this);\n        operator++();\n        return ans;\n    }\n    bool eol()const{ return IsLineHead; }\n    void endl(){\n        (*pstream) << CSVMode.End;\n        IsLineHead = true;\n        IsCellHead = false;\n    }\n};\n\noperator++\u3067\u306f\u3001\u30bb\u30eb/\u884c\u306e\u5148\u982d\u304b\u3069\u3046\u304b\u3060\u3051\u899a\u3048\u3066\u304a\u3044\u3066\u3001\u5b9f\u969b\u306e\u5165\u51fa\u529b\u306f\u3001operator*\u95a2\u6570\u306e\u623b\u308a\u5024\u3067\u3042\u308b\u3001output_cell\u30af\u30e9\u30b9\u306b\u4e38\u6295\u3052\u3057\u3066\u3084\u308a\u307e\u3059\u3002endl\u95a2\u6570\u3067\u6539\u884c\u3001eol\u95a2\u6570\u3067\u6539\u884c\u6e08\u307f\u304b\u3069\u3046\u304b\u306e\u78ba\u8a8d\u304c\u3067\u304d\u307e\u3059\u3002\noutput_cell\u30af\u30e9\u30b9\u306e\u4e2d\u8eab\u306f\u3053\u3093\u306a\u611f\u3058\u3067\u3059\u3002\nstruct output_cell{\nprivate:\n    my_type& My;\nprivate:\n    void cell_head_treat(){\n        if(My.IsCellHead && !My.IsLineHead){\n            *(My.pstream) << My.CSVMode.Sep;\n        }\n        My.IsCellHead = false;\n    }\npublic:\n    output_cell(my_type& My_) :My(My_){}\n    void operator=(const string_type& Str){\n        cell_head_treat();\n        //\u30a8\u30b9\u30b1\u30fc\u30d7\u6587\u5b57\u5468\u308a\u306e\u51e6\u7406\n        *(My.pstream) << csv::cell_encode(Str, My.CSVMode);\n    }\n    template<typename T>\n    output_cell& operator<<(const T& Val){\n        cell_head_treat();\n        *(My.pstream) << Val;\n        return *this;\n    }\n    friend std::basic_istream<Elem, Traits>& operator>>(std::basic_istream<Elem, Traits>& in, output_cell p){\n        string_type Str;\n        in >> Str;\n        p = Str;\n        return in;\n    }\n};\n\nstd::string\u30af\u30e9\u30b9\u3092\u4ee3\u5165\u6f14\u7b97\u5b50\u3067\u53d7\u3051\u3066\u51fa\u529b\u3059\u308b\u307b\u304b\u3001operator<<\u3067\u4efb\u610f\u306e\u578b\u306e\u30af\u30e9\u30b9\u3082\u51fa\u529b\u3067\u304d\u308b\u3088\u3046\u306b\u3057\u3066\u3084\u308a\u307e\u3059\u3002\u3053\u3046\u3057\u3066\u304a\u304f\u3053\u3068\u3067\u3001\u4ee5\u4e0b\u306e\u3088\u3046\u306b\u975estring\u578b\u306e\u30af\u30e9\u30b9\u3082\u51fa\u529b\u3067\u304d\u307e\u3059\u3002\nstd::ofstream fout(\"test.csv\");\nauto oitr = csv::begin(fout);\n\n(*oitr++)<<32;\n(*oitr++)<<35;\n(*oitr++)<<40;\n\n//\u51fa\u529b:32,35,40\n\n\n\u5165\u529b\u306e\u8a2d\u8a08\n\u4e00\u65b9\u3001\u5165\u529b\u306f\u30d5\u30a3\u30fc\u30eb\u30c9\u306e\u8aad\u307f\u8fbc\u307f\u304c\u3042\u308b\u305f\u3081\u3001\u3082\u3046\u5c11\u3057\u3084\u3084\u3053\u3057\u304f\u306a\u3063\u3066\u3044\u307e\u3059\u3002\u4ee5\u4e0b\u306e\u3088\u3046\u306b\u4f7f\u3048\u308b\u3053\u3068\u3092\u76ee\u6307\u3057\u307e\u3059\u3002\nstd::ifstream fin(\"data.csv\");\n\nint Cell=0;\nint Line=0;\nfor( auto itr = csv::begin(fin); itr!= csv::end(fin); ++itr){\n   std::cout<<\"[\"<<Line<<\",\"<<Cell<<\"]: \"<<*itr;\n   if(itr.eol()){\n      Cell=0;\n      Line++;\n   }else{\n      Cell++;\n   }\n}\n\n\u4ee5\u4e0b\u306e\u3088\u3046\u306a\u3001input_iterator\u5f62\u5f0f\u306e\u30af\u30e9\u30b9\u3068\u3057\u3066\u5b9a\u7fa9\u3057\u3066\u307f\u307e\u3059\u3002\ntemplate<class Elem = char, class Traits = std::char_traits<Elem> >\nclass basic_icsv_iterator : public std::iterator < std::input_iterator_tag, std::basic_string<Elem, Traits>>{\nprivate:\n    using my_type = basic_icsv_iterator < Elem, Traits >;\npublic:\n    using sstream_type = std::basic_stringstream < Elem, Traits >;\n    using istream_type = std::basic_istream < Elem, Traits >;\n    using pos_type = typename istream_type::pos_type;\n    using string_type = std::basic_string < Elem, Traits >;\n    using csv_mode_type = basic_csv_mode<Elem, Traits>;\nprivate:\n    istream_type* pstream;\n    csv_mode_type CSVMode;\n    pos_type Pos;\n    sstream_type sstream;\n    bool HasRead;\n    pos_type ReadPos;\n    bool IsLineHead;\nprivate:\n    //\u6b21\u306e\u30d5\u30a3\u30fc\u30eb\u30c9\u307e\u3067istream\u306e\u8aad\u307f\u8fbc\u307f\u4f4d\u7f6e\u3092\u9032\u3081\u308b\n    void next(){\n        if(HasRead){\n            HasRead = false;\n            Pos = ReadPos;\n        } else{\n            Elem c;\n            pstream->seekg(0, std::ios::end);\n            auto EndPos = pstream->tellg();\n            pstream->seekg(Pos);\n\n            bool EscFlag = false;\n            while(pstream->tellg() != EndPos){\n                c = pstream->get();\n\n                if(c == CSVMode.End || c == EOF){\n                    IsLineHead = true;\n                    break;\n                }\n\n                if(c == CSVMode.Sep && !EscFlag){\n                    IsLineHead = false;\n                    break;\n                }\n\n                if(c == CSVMode.Esc){\n                    EscFlag = !EscFlag;\n                }\n            }\n\n            Pos = pstream->tellg();\n        }\n    }\n    //\u6b21\u306e\u30d5\u30a3\u30fc\u30eb\u30c9\u306e\u5185\u5bb9\u3092\u8aad\u307f\u8fbc\u3080\n    sstream_type& read(){\n        if(!HasRead){\n            Elem c;\n            sstream.str(string_type());\n            sstream.clear();\n\n            pstream->seekg(0, std::ios::end);\n            auto EndPos = pstream->tellg();\n            pstream->seekg(Pos);\n\n            bool EscFlag = false;\n            while(pstream->tellg() != EndPos){\n                c = pstream->get();\n\n                if(c == CSVMode.End || c == EOF){\n                    IsLineHead = true;\n                    break;\n                }\n\n                if(c == CSVMode.Sep && !EscFlag){\n                    IsLineHead = false;\n                    break;\n                }\n\n                if(c == CSVMode.Esc){\n                    EscFlag = !EscFlag;\n                }\n\n                sstream << c;\n            }\n\n            ReadPos = pstream->tellg();\n            HasRead = true;\n        }\n        return sstream;\n    }\nprivate:\n    struct input_cell;\npublic:\n    basic_icsv_iterator() :pstream(nullptr){}\n    basic_icsv_iterator(istream_type& Stream_, pos_type Pos_, csv_mode_type CSVMode_, bool IsLineHead_)\n        : pstream(&Stream_)\n        , CSVMode(CSVMode_)\n        , Pos(Pos_)\n        , sstream()\n        , HasRead(false)\n        , IsLineHead(IsLineHead_){}\n    input_cell operator*(){ return input_cell(*this); }\n    my_type& operator++(){\n        next();\n        return *this;\n    }\n    my_type operator++(int){\n        basic_icsv_iterator ans(*this);\n        operator++();\n        return ans;\n    }\n    bool eol()const{ return IsLineHead; }\n    bool eof(){\n        pstream->seekg(0, std::ios::end);\n        return Pos == pstream->tellg();\n    }\n    friend bool operator==(const my_type& my1, const my_type& my2){\n        if(&my1 == &my2)return true;\n\n        if(my1.pstream != my2.pstream) return false;\n\n        return my1.Pos == my2.Pos;\n    }\n    friend bool operator!=(const my_type& my1, const my_type& my2){ return !(my1 == my2); }\n};\n\n\u975e\u5e38\u306b\u6c5a\u3044\u611f\u3058\u3067\u3059\u304c\u3001read\u95a2\u6570\u3067\u6b21\u306e\u30d5\u30a3\u30fc\u30eb\u30c9\u3092\u8aad\u307f\u9032\u3081\u3066\u3044\u307e\u3059\u3002\u4e00\u65b9\u3001next\u95a2\u6570\u306f\u5358\u7d14\u306b\u6b21\u306e\u30d5\u30a3\u30fc\u30eb\u30c9\u307e\u3067\u8aad\u307f\u8fbc\u307f\u4f4d\u7f6e\u3092\u79fb\u52d5\u3055\u305b\u308b\u3060\u3051\u3067\u3001\u3059\u3067\u306bread\u95a2\u6570\u3067\u8aad\u307f\u8fbc\u307f\u6e08\u307f\u306a\u3089\u3001\u305d\u306e\u4f4d\u7f6e\u307e\u3067istream::seekg\u95a2\u6570\u3067\u8aad\u307f\u8fbc\u307f\u4f4d\u7f6e\u3092\u79fb\u52d5\u3055\u305b\u3066\u3044\u307e\u3059\u3002\n\u3042\u3068\u306f\u3001\u51fa\u529b\u6642\u540c\u69d8\u3001operator++\u3067\u8aad\u307f\u8fbc\u3080\u30d5\u30a3\u30fc\u30eb\u30c9\u3092\u9032\u3081\u3001operator*\u3067\u623b\u3059input_cell\u306b\u51e6\u7406\u306f\u4e38\u6295\u3052\u3057\u3066\u3044\u307e\u3059\u3002\u305d\u306e\u4ed6\u3001eol\u3001eof\u3067\u884c\u3084\u30d5\u30a1\u30a4\u30eb\u306e\u672b\u7aef\u3092\u691c\u77e5\u3067\u304d\u308b\u3088\u3046\u306b\u306a\u3063\u3066\u3044\u307e\u3059\u3002\ninput_cell\u306e\u4e2d\u8eab\u306f\u4ee5\u4e0b\u306e\u3088\u3046\u306a\u611f\u3058\u3067\u3059\u3002\nstruct input_cell{\nprivate:\n    my_type& My;\npublic:\n    input_cell(my_type& My_) :My(My_){}\n    operator string_type(){ return csv::cell_decode(My.read().str(), My.CSVMode); }\n    template<typename T>\n    input_cell& operator>>(T& Val){\n        My.read() >> Val;\n        return *this;\n    }\n    friend std::basic_ostream<Elem, Traits>& operator<<(std::basic_ostream<Elem, Traits>& out, input_cell p){\n        return out << static_cast<string_type>(p);\n    }\n    friend bool operator==(const input_cell& in, const string_type& str){return in.raw_str() == str;}\n    friend bool operator!=(const input_cell& in, const string_type& str){ return in.raw_str() != str; }\n};\n\nstring\u578b\u3078\u306e\u6697\u9ed9\u306e\u30ad\u30e3\u30b9\u30c8\u3092\u8a31\u3059\u3053\u3068\u3067\u3001\u6587\u5b57\u5217\u3068\u3057\u3066\u8aad\u307f\u8fbc\u3081\u308b\u307b\u304b\u3001operator>>\u3067\u6307\u5b9a\u3057\u305f\u578b\u3078\u306e\u8aad\u307f\u8fbc\u307f\u304c\u3067\u304d\u307e\u3059\u3002\nstd::ifstream fin(\"data.csv\");\nauto itr = csv::begin(fin);\ndouble a;\nint b;\n\n//double\u3067\u8aad\u307f\u8fbc\u307f\n(*itr++)>>a;\n\n//int\u3067\u8aad\u307f\u8fbc\u307f\n(*itr++)>>b;\n\n\n\u5b8c\u6210\u3000\u305d\u3057\u3066\u4f7f\u3063\u3066\u307f\u308b\n\u305d\u306e\u4ed6\u3001begin\u95a2\u6570\u3084end\u95a2\u6570\u3092\u6574\u5099\u3057\u3066\u3084\u308b\u3068\u3001\u8a18\u4e8b\u306e\u6700\u521d\u306b\u66f8\u3044\u305f\u3088\u3046\u306a\u30b3\u30fc\u30c9\uff08csv_iterator.hpp\uff09\u304c\u51fa\u6765\u4e0a\u304c\u308a\u307e\u3059\u3002\n\u3055\u3063\u305d\u304f\u4f7f\u3063\u3066\u307f\u307e\u3059\u3002\u4f8b\u3048\u3070\u3001\u4ee5\u4e0b\u306e\u3088\u3046\u306a\u30c7\u30fc\u30bf\u304c\u3042\u3063\u305f\u3068\u3057\u307e\u3059\uff08\u30c7\u30fc\u30bf\uff09\u3002\n\n\n\nName\nSex\nAge\n\n\n\n\nSatoshi\nM\n23\n\n\nToshiko\nF\n25\n\n\nAya\nF\n52\n\n\n\n\u8aad\u307f\u51fa\u3057\u3066\u3001\u4e00\u5217\u305a\u3064\u30b3\u30f3\u30c6\u30ca\u306b\u5165\u308c\u3088\u3046\u3068\u601d\u3046\u3068\u3001\u4ee5\u4e0b\u306e\u3088\u3046\u306a\u611f\u3058\u3067\u66f8\u3051\u307e\u3059\uff08\u30bd\u30fc\u30b9\uff09\u3002\n#include <iostream>\n#include <fstream>\n#include <string>\n#include <vector>\n#include \"csv_iterator.hpp\"\n\nint main(){\n    std::vector<std::string> Names;\n    std::vector<bool> IsFemales;\n    std::vector<int> Ages;\n\n    std::ifstream fin(\"data.csv\");\n    auto itr = csv::begin(fin, csv::mode::csv);\n\n    //1\u884c\u8aad\u307f\u98db\u3070\u3059\n    csv::advance_line(itr);\n\n    //\u540d\u524d\u3001\u6027\u5225\u3001\u5e74\u9f62\u306e\u9806\u3067\u8aad\u307f\u3060\u3059\n    while(itr != csv::end(fin)){\n        //\u6587\u5b57\u5217\u306a\u3089\u76f4\u63a5\u8aad\u307f\u51fa\u3057\u53ef\u80fd\n        Names.push_back(*itr++);\n        if(itr.eol())continue;\n\n        //\u5f53\u7136\u3001\u6587\u5b57\u5217\u3068\u306e\u6bd4\u8f03\u3082\u53ef\u80fd\n        IsFemales.push_back(*itr++ == \"F\");\n        if(itr.eol())continue;\n\n        //\u578b\u3092\u6307\u5b9a\u3057\u3066\u8aad\u307f\u51fa\u3059\u3053\u3068\u3082\u53ef\u80fd\n        Ages.push_back((*itr++).read<int>());\n    }\n\n    std::cout << \"=name=\" << std::endl;\n    for(const auto& val : Names)std::cout << val << std::endl;\n    std::cout << std::endl;\n\n    std::cout << \"=sex=\" << std::endl;\n    for(auto val : IsFemales)std::cout << val << std::endl;\n    std::cout << std::endl;\n\n    std::cout << \"=age=\" << std::endl;\n    for(auto val : Ages)std::cout << val << std::endl;\n    std::cout << std::endl;\n\n    system(\"pause\");\n\n    return 0;\n}\n\n\u3042\u308b\u3044\u306f\u3001\u3053\u3093\u306a\u30c7\u30fc\u30bf\u306f\u3069\u3046\u3067\u3057\u3087\u3046\uff08\u30c7\u30fc\u30bf\uff09\u3002\n\n\n\nNum\nData1\nData2\nData3\nData4...\n\n\n\n\n3\nRed\nBlue\nYellow\n\n\n\n1\nTokyo\n\n\n\n\n\n2\nApple\nBanana\n\n\n\n\n4\nNorth\nWest\nSouth\nEast\n\n\n2\nDog\nCat\n\n\n\n\n\n\u3053\u3093\u306a\u611f\u3058\u306e\u30b8\u30e3\u30ae\u30fc\u306a\u30c7\u30fc\u30bf\u3082\u3001iterator\u306a\u3089\u6271\u3046\u306e\u306f\u6bd4\u8f03\u7684\u7c21\u5358\u3067\u3059\uff08\u30bd\u30fc\u30b9\uff09\u3002\n#include <iostream>\n#include <fstream>\n#include \"csv_iterator.hpp\"\n\nint main(){\n    std::ifstream fin(\"data2.csv\");\n    auto itr = csv::begin(fin, csv::mode::csv);\n\n    //1\u884c\u8aad\u307f\u98db\u3070\u3059\n    csv::advance_line(itr);\n\n    //\u540d\u524d\u3001\u6027\u5225\u3001\u5e74\u9f62\u306e\u9806\u3067\u8aad\u307f\u3060\u3059\n    while(itr != csv::end(fin)){\n        unsigned int Num;\n        (*itr++) >> Num;\n\n        for(unsigned int Cnt = 0; Cnt < Num; ++Cnt){\n            std::cout << \"[\" << Cnt << \"/\" << Num << \"]\" << (*itr++) <<std::endl;\n        }\n    }\n\n    system(\"pause\");\n\n    return 0;\n}\n\n\n\u307e\u3068\u3081\n\u4ee5\u4e0a\u3001CSV\u30d5\u30a9\u30fc\u30de\u30c3\u30c8\u306e\u30d5\u30a1\u30a4\u30eb\u3092iterator\u30c1\u30c3\u30af\u306b\u3044\u3058\u3063\u3066\u307f\u308b\u304a\u8a71\u3067\u3057\u305f\u3002\n\u306a\u304b\u306a\u304b\u81ea\u5206\u3067\u3082\u306c\u308b\u3044\u30b3\u30fc\u30c9\u3060\u3068\u601d\u3046\u306e\u3067\u3001\u7a81\u3063\u8fbc\u307f\u30fb\u30b3\u30e1\u30f3\u30c8\u7b49\u5927\u6b53\u8fce\u3067\u3059\u3002\n\u3053\u306e\u8a18\u4e8b\u306f\u3001C++ Advent Calendar 2015 \u306e10\u65e5\u76ee\u306e\u8a18\u4e8b\u3067\u3057\u305f\u3002\n\u660e\u65e5\u306f\u3001lifeaether\u3055\u3093\u306e\u8a18\u4e8b\u3001\u300cObjective-C \u30a4\u30f3\u30b9\u30bf\u30f3\u30b9\u5909\u6570\u306e C++ \u30aa\u30d6\u30b8\u30a7\u30af\u30c8\u300d\u3067\u3059\u3002\n\u3053\u306e\u8a18\u4e8b\u306f\u3001[C++ Advent Calendar 2015](http://www.adventar.org/calendars/926) \u306e10\u65e5\u76ee\u306e\u8a18\u4e8b\u3067\u3059\u3002\n\u6628\u65e5\u306f\u3001srz-zumix\u3055\u3093\u306e\u300c[ [Catch] REQUIRE  \u306e\u5f0f\u304c\u5c55\u958b\u3055\u308c\u308b\u4ed5\u7d44\u307f](http://srz-zumix.blogspot.jp/2015/12/catch-require.html)\u300d\u3067\u3057\u305f\u3002\n\n\u4eca\u65e5\u306f\u3001csv\u30d5\u30a9\u30fc\u30de\u30c3\u30c8\u3092iterator\u3067\u8aad\u307f\u66f8\u304d\u3057\u3066\u307f\u308b\u8a71\u3067\u3059\u3002\u4ee5\u4e0b\u306e\u3088\u3046\u306b\u4f7f\u3048\u308b\u30af\u30e9\u30b9\u3067\u3059\u3002\n\u30b3\u30fc\u30c9\u306fGitHub\u4e0a\u306b\u304a\u3044\u3066\u3042\u308a\u307e\u3059\u3002\uff08[csv_iterator.hpp](https://github.com/hmito/Junk/blob/master/csv_iterator/csv_iterator.hpp)\uff09\n\n```cpp\n#include <iostream>\n#include <fstream>\n#include \"csv_iterator.hpp\"\n\nint main(){\n\t//\u30ab\u30f3\u30de\u533a\u5207\u308a\uff08csv\uff09\u3067\u30d5\u30a1\u30a4\u30eb\u3092\u8aad\u307f\u3060\u3057\u3066\u3001\u30bf\u30d6\u533a\u5207\u308a\u3067\u753b\u9762\u306b\u51fa\u529b\u3059\u308b\n\tauto oitr = csv::current(std::cout, csv::mode::tsv);\n\n\tstd::ifstream fin(\"data.csv\");\n\tfor(auto itr = csv::begin(fin, csv::mode::csv); itr != csv::end(fin); ++itr){\n\t\t*oitr++ = *itr;\n\t\tif(itr.eol())oitr.endl();\n\t}\n\n\tsystem(\"pause\");\n\n\treturn 0;\n}\n```\n\n#\u52d5\u6a5f\n\u30ab\u30f3\u30de\u3067\u4e00\u884c\u304c\u8907\u6570\u306e\u30d5\u30a3\u30fc\u30eb\u30c9\u306b\u533a\u5207\u3089\u308c\u305f\u30d5\u30a1\u30a4\u30eb\u306e\u3053\u3068\u3092[**csv**](https://ja.wikipedia.org/wiki/Comma-Separated_Values)\u3068\u3044\u3044\u307e\u3059\u3002\u30ab\u30f3\u30de\u306e\u4ee3\u308f\u308a\u306b\u30b9\u30da\u30fc\u30b9\u3084\u30bf\u30d6\u3067\u533a\u5207\u3089\u308c\u305f\u30d5\u30a1\u30a4\u30eb\u3082\u3001\u305d\u308c\u305e\u308cssv\u3001tsv\u3068\u547c\u3070\u308c\u3001\u3057\u3070\u3057\u3070\u4f7f\u308f\u308c\u308b\u3088\u3046\u3067\u3059\u3002\n\n\u30d5\u30a9\u30fc\u30de\u30c3\u30c8\u306f\u975e\u5e38\u306b\u5358\u7d14\u306a\u306e\u3067\u3001\u5165\u51fa\u529b\u306f\u7c21\u5358\u3067\u3059\u3002\u5165\u529b\u306f\u3001\u4e00\u884c\u305a\u3064\u8aad\u3093\u3067\u306f[`boost::algorithm::split`\u95a2\u6570](http://boostjp.github.io/tips/string_algo.html#split)\u3042\u305f\u308a\u3092\u4f7f\u3046\u306e\u304c\u4e00\u756a\u52b9\u7387\u304c\u3044\u3044\u3067\u3057\u3087\u3046\u3002\u51fa\u529b\u306f\u3001\u30d5\u30a3\u30fc\u30eb\u30c9\u9593\u306b\u533a\u5207\u308a\u6587\u5b57\u3092\u51fa\u529b\u3059\u308b\u3060\u3051\u3067\u3059\u3002\u304a\u624b\u8efd\u3067\u3059\u306d\u3002\n\n\u305f\u3060\u3001csv\u7cfb\u306e\u30d5\u30a1\u30a4\u30eb\u306f\u305f\u307e\u306b\u8aad\u307f\u66f8\u304d\u3059\u308b\u6a5f\u4f1a\u304c\u3042\u308b\u306e\u3067\u3059\u304c\u3001\u4ee5\u4e0b\u306e\u3088\u3046\u306a\u4e0d\u6e80\u70b9\u304c\u3042\u308a\u307e\u3057\u305f\u3002\n\n- \u5165\u51fa\u529b\u3092\u4e00\u8cab\u3057\u305f\u65b9\u6cd5\u3067\u66f8\u3051\u306a\u3044\n- \u4f3c\u305f\u3088\u3046\u306a\u51e6\u7406\u3092\u3001\u3042\u3061\u3053\u3061\u306b\u7e70\u308a\u8fd4\u3057\u66f8\u304f\u5fc5\u8981\u304c\u3042\u308a\u683c\u597d\u60aa\u3044\n\n\u30d5\u30a1\u30a4\u30eb\u4e2d\u306b\u542b\u307e\u308c\u308b\u30d5\u30a3\u30fc\u30eb\u30c9\u3092\u4e38\u3054\u3068\u30b3\u30f3\u30c6\u30ca\u3068\u3057\u3066\u78ba\u4fdd\u3059\u308b\u3088\u3046\u306a\u30af\u30e9\u30b9\u3092\u66f8\u3051\u3070\u3044\u3044\u306e\u304b\u3082\u3057\u308c\u307e\u305b\u3093\uff08\u4f8b\u3048\u3070\u3001[\u3053\u3093\u306a\u30af\u30e9\u30b9](http://clx.cielquis.net/table.html)\u7b49\uff09\u304c\u3001\u3082\u3046\u3061\u3087\u3063\u3068\u5c0f\u7c92\u3067\u5165\u51fa\u529b\u5185\u5bb9\u81ea\u4f53\u306e\u51e6\u7406\u306b\u96c6\u4e2d\u3067\u304d\u308b\u3001csv\u7cfb\u30d5\u30a1\u30a4\u30eb\u5165\u51fa\u529b\u7528\u306e\u30e9\u30c3\u30d1\u30fc\u30af\u30e9\u30b9\u304c\u6b32\u3057\u304f\u306a\u308a\u307e\u3057\u305f\u3002\n\n\u3068\u3044\u3046\u3053\u3068\u3067\u3001csv\u306e**\u30d5\u30a3\u30fc\u30eb\u30c9\u3092 iterator \u3063\u307d\u304f\u6271\u3048\u308b**\u30af\u30e9\u30b9\u3092\u4f5c\u3063\u3066\u307f\u307e\u3057\u305f\u3002\n\n#\u51fa\u529b\u306e\u8a2d\u8a08\n\u307e\u305a\u3001\u51fa\u529b\u3067\u3059\u3002output_iterator\u3063\u307d\u304f\u4f7f\u3044\u305f\u3044\u306e\u3067\u3001\u4ee5\u4e0b\u306e\u3088\u3046\u306b\u3064\u304b\u308b\u3053\u3068\u304c\u671b\u307e\u3057\u3044\u3067\u3059\u3002\n\n```cpp\nstd::vector<std::string> StringSet = {\"Red\", \"Blue\", \"Green\", ...};\n\nstd::ofstream fout(\"test.csv\");\nauto oitr = csv::begin(fout);\n\n//StringSet\u914d\u5217\u5185\u306e\u6587\u5b57\u5217\u3092\u9806\u306b\u51fa\u529b\nfor(auto Str: StringSet){\n   *oitr = Str;\n   ++oitr;   //\u6b21\u306e\u30d5\u30a3\u30fc\u30eb\u30c9\u3078\n}\n\n//\u6539\u884c\u306fendl\u30e1\u30f3\u30d0\u95a2\u6570\noitr.endl();\n```\n\n\u3055\u3066\u3001\u305d\u308c\u3067\u306f\u3055\u3063\u305d\u304f\u4f5c\u3063\u3066\u307f\u307e\u3059\u3002`std::iterator`\u3092\u7d99\u627f\u3057\u3066\u3001\u4ee5\u4e0b\u306e\u3088\u3046\u306aoutput_iterator\u30af\u30e9\u30b9\u3092\u4f5c\u308a\u307e\u3059\u3002\n\n```cpp\ntemplate<class Elem = char, class Traits = std::char_traits<Elem> >\nclass basic_ocsv_iterator : public std::iterator < std::output_iterator_tag, void, void, void, void >{\nprivate:\n\tusing my_type = basic_ocsv_iterator < Elem, Traits >;\n\tusing ostream_type = std::basic_ostream < Elem, Traits >;\n\tusing string_type = std::basic_string < Elem, Traits >;\n\tusing csv_mode_type = basic_csv_mode<Elem, Traits>;\nprivate:\n\tstruct output_cell;\nprivate:\n\tostream_type* pstream;\n\tcsv_mode_type CSVMode;\n\tbool IsCellHead;\n\tbool IsLineHead;\npublic:\n\tbasic_ocsv_iterator()\n\t\t: pstream(nullptr){}\n\tbasic_ocsv_iterator(ostream_type& Stream_, csv_mode_type CSVMode_)\n\t\t: pstream(&Stream_)\n\t\t, CSVMode(CSVMode_)\n\t\t, IsCellHead(false)\n\t\t, IsLineHead(true){}\n\tbasic_ocsv_iterator(const my_type& My_) = default;\n\tmy_type& operator=(const my_type& My_) = default;\npublic:\n\toperator bool()const{ return pstream; }\n\toutput_cell operator*(){ return output_cell(*this); }\n\tmy_type& operator++(){\n\t\tIsCellHead = true;\n\t\tIsLineHead = false;\n\t\treturn *this;\n\t}\n\tmy_type operator++(int){\n\t\tmy_type ans(*this);\n\t\toperator++();\n\t\treturn ans;\n\t}\n\tbool eol()const{ return IsLineHead; }\n\tvoid endl(){\n\t\t(*pstream) << CSVMode.End;\n\t\tIsLineHead = true;\n\t\tIsCellHead = false;\n\t}\n};\n```\n`operator++`\u3067\u306f\u3001\u30bb\u30eb/\u884c\u306e\u5148\u982d\u304b\u3069\u3046\u304b\u3060\u3051\u899a\u3048\u3066\u304a\u3044\u3066\u3001\u5b9f\u969b\u306e\u5165\u51fa\u529b\u306f\u3001`operator*`\u95a2\u6570\u306e\u623b\u308a\u5024\u3067\u3042\u308b\u3001`output_cell`\u30af\u30e9\u30b9\u306b\u4e38\u6295\u3052\u3057\u3066\u3084\u308a\u307e\u3059\u3002`endl`\u95a2\u6570\u3067\u6539\u884c\u3001`eol`\u95a2\u6570\u3067\u6539\u884c\u6e08\u307f\u304b\u3069\u3046\u304b\u306e\u78ba\u8a8d\u304c\u3067\u304d\u307e\u3059\u3002\n\noutput_cell\u30af\u30e9\u30b9\u306e\u4e2d\u8eab\u306f\u3053\u3093\u306a\u611f\u3058\u3067\u3059\u3002\n\n```cpp\nstruct output_cell{\nprivate:\n\tmy_type& My;\nprivate:\n\tvoid cell_head_treat(){\n\t\tif(My.IsCellHead && !My.IsLineHead){\n\t\t\t*(My.pstream) << My.CSVMode.Sep;\n\t\t}\n\t\tMy.IsCellHead = false;\n\t}\npublic:\n\toutput_cell(my_type& My_) :My(My_){}\n\tvoid operator=(const string_type& Str){\n\t\tcell_head_treat();\n\t\t//\u30a8\u30b9\u30b1\u30fc\u30d7\u6587\u5b57\u5468\u308a\u306e\u51e6\u7406\n\t\t*(My.pstream) << csv::cell_encode(Str, My.CSVMode);\n\t}\n\ttemplate<typename T>\n\toutput_cell& operator<<(const T& Val){\n\t\tcell_head_treat();\n\t\t*(My.pstream) << Val;\n\t\treturn *this;\n\t}\n\tfriend std::basic_istream<Elem, Traits>& operator>>(std::basic_istream<Elem, Traits>& in, output_cell p){\n\t\tstring_type Str;\n\t\tin >> Str;\n\t\tp = Str;\n\t\treturn in;\n\t}\n};\n```\n`std::string`\u30af\u30e9\u30b9\u3092\u4ee3\u5165\u6f14\u7b97\u5b50\u3067\u53d7\u3051\u3066\u51fa\u529b\u3059\u308b\u307b\u304b\u3001`operator<<`\u3067\u4efb\u610f\u306e\u578b\u306e\u30af\u30e9\u30b9\u3082\u51fa\u529b\u3067\u304d\u308b\u3088\u3046\u306b\u3057\u3066\u3084\u308a\u307e\u3059\u3002\u3053\u3046\u3057\u3066\u304a\u304f\u3053\u3068\u3067\u3001\u4ee5\u4e0b\u306e\u3088\u3046\u306b\u975estring\u578b\u306e\u30af\u30e9\u30b9\u3082\u51fa\u529b\u3067\u304d\u307e\u3059\u3002\n\n```cpp\nstd::ofstream fout(\"test.csv\");\nauto oitr = csv::begin(fout);\n\n(*oitr++)<<32;\n(*oitr++)<<35;\n(*oitr++)<<40;\n\n//\u51fa\u529b:32,35,40\n```\n\n#\u5165\u529b\u306e\u8a2d\u8a08\n\u4e00\u65b9\u3001\u5165\u529b\u306f\u30d5\u30a3\u30fc\u30eb\u30c9\u306e\u8aad\u307f\u8fbc\u307f\u304c\u3042\u308b\u305f\u3081\u3001\u3082\u3046\u5c11\u3057\u3084\u3084\u3053\u3057\u304f\u306a\u3063\u3066\u3044\u307e\u3059\u3002\u4ee5\u4e0b\u306e\u3088\u3046\u306b\u4f7f\u3048\u308b\u3053\u3068\u3092\u76ee\u6307\u3057\u307e\u3059\u3002\n\n```cpp\nstd::ifstream fin(\"data.csv\");\n\nint Cell=0;\nint Line=0;\nfor( auto itr = csv::begin(fin); itr!= csv::end(fin); ++itr){\n   std::cout<<\"[\"<<Line<<\",\"<<Cell<<\"]: \"<<*itr;\n   if(itr.eol()){\n      Cell=0;\n      Line++;\n   }else{\n      Cell++;\n   }\n}\n```\n\n\u4ee5\u4e0b\u306e\u3088\u3046\u306a\u3001input_iterator\u5f62\u5f0f\u306e\u30af\u30e9\u30b9\u3068\u3057\u3066\u5b9a\u7fa9\u3057\u3066\u307f\u307e\u3059\u3002\n\n```cpp\ntemplate<class Elem = char, class Traits = std::char_traits<Elem> >\nclass basic_icsv_iterator : public std::iterator < std::input_iterator_tag, std::basic_string<Elem, Traits>>{\nprivate:\n\tusing my_type = basic_icsv_iterator < Elem, Traits >;\npublic:\n\tusing sstream_type = std::basic_stringstream < Elem, Traits >;\n\tusing istream_type = std::basic_istream < Elem, Traits >;\n\tusing pos_type = typename istream_type::pos_type;\n\tusing string_type = std::basic_string < Elem, Traits >;\n\tusing csv_mode_type = basic_csv_mode<Elem, Traits>;\nprivate:\n\tistream_type* pstream;\n\tcsv_mode_type CSVMode;\n\tpos_type Pos;\n\tsstream_type sstream;\n\tbool HasRead;\n\tpos_type ReadPos;\n\tbool IsLineHead;\nprivate:\n\t//\u6b21\u306e\u30d5\u30a3\u30fc\u30eb\u30c9\u307e\u3067istream\u306e\u8aad\u307f\u8fbc\u307f\u4f4d\u7f6e\u3092\u9032\u3081\u308b\n\tvoid next(){\n\t\tif(HasRead){\n\t\t\tHasRead = false;\n\t\t\tPos = ReadPos;\n\t\t} else{\n\t\t\tElem c;\n\t\t\tpstream->seekg(0, std::ios::end);\n\t\t\tauto EndPos = pstream->tellg();\n\t\t\tpstream->seekg(Pos);\n\n\t\t\tbool EscFlag = false;\n\t\t\twhile(pstream->tellg() != EndPos){\n\t\t\t\tc = pstream->get();\n\n\t\t\t\tif(c == CSVMode.End || c == EOF){\n\t\t\t\t\tIsLineHead = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif(c == CSVMode.Sep && !EscFlag){\n\t\t\t\t\tIsLineHead = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif(c == CSVMode.Esc){\n\t\t\t\t\tEscFlag = !EscFlag;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tPos = pstream->tellg();\n\t\t}\n\t}\n\t//\u6b21\u306e\u30d5\u30a3\u30fc\u30eb\u30c9\u306e\u5185\u5bb9\u3092\u8aad\u307f\u8fbc\u3080\n\tsstream_type& read(){\n\t\tif(!HasRead){\n\t\t\tElem c;\n\t\t\tsstream.str(string_type());\n\t\t\tsstream.clear();\n\n\t\t\tpstream->seekg(0, std::ios::end);\n\t\t\tauto EndPos = pstream->tellg();\n\t\t\tpstream->seekg(Pos);\n\n\t\t\tbool EscFlag = false;\n\t\t\twhile(pstream->tellg() != EndPos){\n\t\t\t\tc = pstream->get();\n\n\t\t\t\tif(c == CSVMode.End || c == EOF){\n\t\t\t\t\tIsLineHead = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif(c == CSVMode.Sep && !EscFlag){\n\t\t\t\t\tIsLineHead = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif(c == CSVMode.Esc){\n\t\t\t\t\tEscFlag = !EscFlag;\n\t\t\t\t}\n\n\t\t\t\tsstream << c;\n\t\t\t}\n\n\t\t\tReadPos = pstream->tellg();\n\t\t\tHasRead = true;\n\t\t}\n\t\treturn sstream;\n\t}\nprivate:\n\tstruct input_cell;\npublic:\n\tbasic_icsv_iterator() :pstream(nullptr){}\n\tbasic_icsv_iterator(istream_type& Stream_, pos_type Pos_, csv_mode_type CSVMode_, bool IsLineHead_)\n\t\t: pstream(&Stream_)\n\t\t, CSVMode(CSVMode_)\n\t\t, Pos(Pos_)\n\t\t, sstream()\n\t\t, HasRead(false)\n\t\t, IsLineHead(IsLineHead_){}\n\tinput_cell operator*(){ return input_cell(*this); }\n\tmy_type& operator++(){\n\t\tnext();\n\t\treturn *this;\n\t}\n\tmy_type operator++(int){\n\t\tbasic_icsv_iterator ans(*this);\n\t\toperator++();\n\t\treturn ans;\n\t}\n\tbool eol()const{ return IsLineHead; }\n\tbool eof(){\n\t\tpstream->seekg(0, std::ios::end);\n\t\treturn Pos == pstream->tellg();\n\t}\n\tfriend bool operator==(const my_type& my1, const my_type& my2){\n\t\tif(&my1 == &my2)return true;\n\n\t\tif(my1.pstream != my2.pstream) return false;\n\n\t\treturn my1.Pos == my2.Pos;\n\t}\n\tfriend bool operator!=(const my_type& my1, const my_type& my2){ return !(my1 == my2); }\n};\n```\n\u975e\u5e38\u306b\u6c5a\u3044\u611f\u3058\u3067\u3059\u304c\u3001`read`\u95a2\u6570\u3067\u6b21\u306e\u30d5\u30a3\u30fc\u30eb\u30c9\u3092\u8aad\u307f\u9032\u3081\u3066\u3044\u307e\u3059\u3002\u4e00\u65b9\u3001`next`\u95a2\u6570\u306f\u5358\u7d14\u306b\u6b21\u306e\u30d5\u30a3\u30fc\u30eb\u30c9\u307e\u3067\u8aad\u307f\u8fbc\u307f\u4f4d\u7f6e\u3092\u79fb\u52d5\u3055\u305b\u308b\u3060\u3051\u3067\u3001\u3059\u3067\u306b`read`\u95a2\u6570\u3067\u8aad\u307f\u8fbc\u307f\u6e08\u307f\u306a\u3089\u3001\u305d\u306e\u4f4d\u7f6e\u307e\u3067`istream::seekg`\u95a2\u6570\u3067\u8aad\u307f\u8fbc\u307f\u4f4d\u7f6e\u3092\u79fb\u52d5\u3055\u305b\u3066\u3044\u307e\u3059\u3002\n\n\u3042\u3068\u306f\u3001\u51fa\u529b\u6642\u540c\u69d8\u3001`operator++`\u3067\u8aad\u307f\u8fbc\u3080\u30d5\u30a3\u30fc\u30eb\u30c9\u3092\u9032\u3081\u3001`operator*`\u3067\u623b\u3059input_cell\u306b\u51e6\u7406\u306f\u4e38\u6295\u3052\u3057\u3066\u3044\u307e\u3059\u3002\u305d\u306e\u4ed6\u3001eol\u3001eof\u3067\u884c\u3084\u30d5\u30a1\u30a4\u30eb\u306e\u672b\u7aef\u3092\u691c\u77e5\u3067\u304d\u308b\u3088\u3046\u306b\u306a\u3063\u3066\u3044\u307e\u3059\u3002\n\ninput_cell\u306e\u4e2d\u8eab\u306f\u4ee5\u4e0b\u306e\u3088\u3046\u306a\u611f\u3058\u3067\u3059\u3002\n\n```cpp\nstruct input_cell{\nprivate:\n\tmy_type& My;\npublic:\n\tinput_cell(my_type& My_) :My(My_){}\n\toperator string_type(){ return csv::cell_decode(My.read().str(), My.CSVMode); }\n\ttemplate<typename T>\n\tinput_cell& operator>>(T& Val){\n\t\tMy.read() >> Val;\n\t\treturn *this;\n\t}\n\tfriend std::basic_ostream<Elem, Traits>& operator<<(std::basic_ostream<Elem, Traits>& out, input_cell p){\n\t\treturn out << static_cast<string_type>(p);\n\t}\n\tfriend bool operator==(const input_cell& in, const string_type& str){return in.raw_str() == str;}\n\tfriend bool operator!=(const input_cell& in, const string_type& str){ return in.raw_str() != str; }\n};\n```\nstring\u578b\u3078\u306e\u6697\u9ed9\u306e\u30ad\u30e3\u30b9\u30c8\u3092\u8a31\u3059\u3053\u3068\u3067\u3001\u6587\u5b57\u5217\u3068\u3057\u3066\u8aad\u307f\u8fbc\u3081\u308b\u307b\u304b\u3001`operator>>`\u3067\u6307\u5b9a\u3057\u305f\u578b\u3078\u306e\u8aad\u307f\u8fbc\u307f\u304c\u3067\u304d\u307e\u3059\u3002\n\n```cpp\nstd::ifstream fin(\"data.csv\");\nauto itr = csv::begin(fin);\ndouble a;\nint b;\n\n//double\u3067\u8aad\u307f\u8fbc\u307f\n(*itr++)>>a;\n\n//int\u3067\u8aad\u307f\u8fbc\u307f\n(*itr++)>>b;\n```\n\n#\u5b8c\u6210\u3000\u305d\u3057\u3066\u4f7f\u3063\u3066\u307f\u308b\n\u305d\u306e\u4ed6\u3001`begin`\u95a2\u6570\u3084`end`\u95a2\u6570\u3092\u6574\u5099\u3057\u3066\u3084\u308b\u3068\u3001\u8a18\u4e8b\u306e\u6700\u521d\u306b\u66f8\u3044\u305f\u3088\u3046\u306a\u30b3\u30fc\u30c9\uff08[csv_iterator.hpp](https://github.com/hmito/Junk/blob/master/csv_iterator/csv_iterator.hpp)\uff09\u304c\u51fa\u6765\u4e0a\u304c\u308a\u307e\u3059\u3002\n\n\u3055\u3063\u305d\u304f\u4f7f\u3063\u3066\u307f\u307e\u3059\u3002\u4f8b\u3048\u3070\u3001\u4ee5\u4e0b\u306e\u3088\u3046\u306a\u30c7\u30fc\u30bf\u304c\u3042\u3063\u305f\u3068\u3057\u307e\u3059\uff08[\u30c7\u30fc\u30bf](https://github.com/hmito/Junk/blob/master/csv_iterator/data1.csv)\uff09\u3002\n\n|Name|Sex|Age|\n|:---:|:----:|:--:|\n|Satoshi|M|23|\n|Toshiko|F|25|\n|Aya|F|52|\n\n\n\u8aad\u307f\u51fa\u3057\u3066\u3001\u4e00\u5217\u305a\u3064\u30b3\u30f3\u30c6\u30ca\u306b\u5165\u308c\u3088\u3046\u3068\u601d\u3046\u3068\u3001\u4ee5\u4e0b\u306e\u3088\u3046\u306a\u611f\u3058\u3067\u66f8\u3051\u307e\u3059\uff08[\u30bd\u30fc\u30b9](https://github.com/hmito/Junk/blob/master/csv_iterator/use_csv_iterator_2.cpp)\uff09\u3002\n\n```cpp\n#include <iostream>\n#include <fstream>\n#include <string>\n#include <vector>\n#include \"csv_iterator.hpp\"\n\nint main(){\n\tstd::vector<std::string> Names;\n\tstd::vector<bool> IsFemales;\n\tstd::vector<int> Ages;\n\n\tstd::ifstream fin(\"data.csv\");\n\tauto itr = csv::begin(fin, csv::mode::csv);\n\n\t//1\u884c\u8aad\u307f\u98db\u3070\u3059\n\tcsv::advance_line(itr);\n\n\t//\u540d\u524d\u3001\u6027\u5225\u3001\u5e74\u9f62\u306e\u9806\u3067\u8aad\u307f\u3060\u3059\n\twhile(itr != csv::end(fin)){\n\t\t//\u6587\u5b57\u5217\u306a\u3089\u76f4\u63a5\u8aad\u307f\u51fa\u3057\u53ef\u80fd\n\t\tNames.push_back(*itr++);\n\t\tif(itr.eol())continue;\n\n\t\t//\u5f53\u7136\u3001\u6587\u5b57\u5217\u3068\u306e\u6bd4\u8f03\u3082\u53ef\u80fd\n\t\tIsFemales.push_back(*itr++ == \"F\");\n\t\tif(itr.eol())continue;\n\n\t\t//\u578b\u3092\u6307\u5b9a\u3057\u3066\u8aad\u307f\u51fa\u3059\u3053\u3068\u3082\u53ef\u80fd\n\t\tAges.push_back((*itr++).read<int>());\n\t}\n\n\tstd::cout << \"=name=\" << std::endl;\n\tfor(const auto& val : Names)std::cout << val << std::endl;\n\tstd::cout << std::endl;\n\n\tstd::cout << \"=sex=\" << std::endl;\n\tfor(auto val : IsFemales)std::cout << val << std::endl;\n\tstd::cout << std::endl;\n\n\tstd::cout << \"=age=\" << std::endl;\n\tfor(auto val : Ages)std::cout << val << std::endl;\n\tstd::cout << std::endl;\n\n\tsystem(\"pause\");\n\n\treturn 0;\n}\n```\n\n\u3042\u308b\u3044\u306f\u3001\u3053\u3093\u306a\u30c7\u30fc\u30bf\u306f\u3069\u3046\u3067\u3057\u3087\u3046\uff08[\u30c7\u30fc\u30bf](https://github.com/hmito/Junk/blob/master/csv_iterator/data2.csv)\uff09\u3002\n\n|Num|Data1|Data2|Data3|Data4...|\n|:---:|:----:|:--:|:--:|:--:|\n|3|Red|Blue|Yellow| |\n|1|Tokyo|||\n|2|Apple|Banana|||\n|4|North|West|South|East|\n|2|Dog|Cat|\n\n\u3053\u3093\u306a\u611f\u3058\u306e\u30b8\u30e3\u30ae\u30fc\u306a\u30c7\u30fc\u30bf\u3082\u3001iterator\u306a\u3089\u6271\u3046\u306e\u306f\u6bd4\u8f03\u7684\u7c21\u5358\u3067\u3059\uff08[\u30bd\u30fc\u30b9](https://github.com/hmito/Junk/blob/master/csv_iterator/use_csv_iterator_3.cpp)\uff09\u3002\n\n```cpp\n#include <iostream>\n#include <fstream>\n#include \"csv_iterator.hpp\"\n\nint main(){\n\tstd::ifstream fin(\"data2.csv\");\n\tauto itr = csv::begin(fin, csv::mode::csv);\n\n\t//1\u884c\u8aad\u307f\u98db\u3070\u3059\n\tcsv::advance_line(itr);\n\n\t//\u540d\u524d\u3001\u6027\u5225\u3001\u5e74\u9f62\u306e\u9806\u3067\u8aad\u307f\u3060\u3059\n\twhile(itr != csv::end(fin)){\n\t\tunsigned int Num;\n\t\t(*itr++) >> Num;\n\n\t\tfor(unsigned int Cnt = 0; Cnt < Num; ++Cnt){\n\t\t\tstd::cout << \"[\" << Cnt << \"/\" << Num << \"]\" << (*itr++) <<std::endl;\n\t\t}\n\t}\n\n\tsystem(\"pause\");\n\n\treturn 0;\n}\n```\n\n#\u307e\u3068\u3081\n\u4ee5\u4e0a\u3001CSV\u30d5\u30a9\u30fc\u30de\u30c3\u30c8\u306e\u30d5\u30a1\u30a4\u30eb\u3092iterator\u30c1\u30c3\u30af\u306b\u3044\u3058\u3063\u3066\u307f\u308b\u304a\u8a71\u3067\u3057\u305f\u3002\n\u306a\u304b\u306a\u304b\u81ea\u5206\u3067\u3082\u306c\u308b\u3044\u30b3\u30fc\u30c9\u3060\u3068\u601d\u3046\u306e\u3067\u3001\u7a81\u3063\u8fbc\u307f\u30fb\u30b3\u30e1\u30f3\u30c8\u7b49\u5927\u6b53\u8fce\u3067\u3059\u3002\n\n\u3053\u306e\u8a18\u4e8b\u306f\u3001[C++ Advent Calendar 2015](http://www.adventar.org/calendars/926) \u306e10\u65e5\u76ee\u306e\u8a18\u4e8b\u3067\u3057\u305f\u3002\n\u660e\u65e5\u306f\u3001lifeaether\u3055\u3093\u306e\u8a18\u4e8b\u3001[\u300cObjective-C \u30a4\u30f3\u30b9\u30bf\u30f3\u30b9\u5909\u6570\u306e C++ \u30aa\u30d6\u30b8\u30a7\u30af\u30c8\u300d](http://www.lifeaether.com/self/blog/?p=478)\u3067\u3059\u3002\n"}