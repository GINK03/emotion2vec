{"context": "\n\n\u6982\u8981\ndlib\u3067\u9854\u5668\u5b98\u3092\u8a8d\u8b58\u3057\u305f\u5f8c\u306b\u3001\u305d\u308c\u305e\u308c\u306e\u9854\u30d1\u30fc\u30c4\u306b\u5206\u89e3\u3059\u308b\u305f\u3081\u306b\u4e09\u89d2\u5f62\u3067\u5206\u5272\u3057\u307e\u3059\u3002\n\u8907\u6570\u306e\u70b9\u3092\u4e09\u89d2\u5f62\u3067\u8868\u3059\u969b\u306b\u30c9\u30ed\u30cd\u30fc\u56f3\u3068\u3044\u3046\u3082\u306e\u3092\u5229\u7528\u3057\u307e\u3059\u3002\n\u8a73\u3057\u304f\u306f\u4e0b\u8a18\u8a18\u4e8b\u3092\u53c2\u7167\u3002\n\nDelaunay Triangulation and Voronoi Diagram using OpenCV ( C++ / Python )\nOpenCV C++/IF\u3067\u30dc\u30ed\u30ce\u30a4\u56f3\u30fb\u30c9\u30ed\u30cd\u30fc\u56f3\u3092\u63cf\u304f\n\n\n\u7d50\u679c\n\u753b\u50cf\u304c\u8352\u3044\u3067\u3059\u304c\u3053\u3093\u306a\u611f\u3058\u306b\u306a\u308a\u307e\u3059\u3002\n\n\n\u30bd\u30fc\u30b9\u30b3\u30fc\u30c9\ndlib\u306e\u30b5\u30f3\u30d7\u30eb\u30b3\u30fc\u30c9\u306ewebcam_face_pose_ex.cpp\u3092\u6539\u5909\u3057\u3066\u3044\u307e\u3059\u3002\n        cv::VideoCapture cap(0);\n        if (!cap.isOpened())\n        {\n            cerr << \"Unable to connect to camera\" << endl;\n            return 1;\n        }\n\n        image_window win;\n\n        // Load face detection and pose estimation models.\n        frontal_face_detector detector = get_frontal_face_detector();\n        shape_predictor pose_model;\n        deserialize(\"shape_predictor_68_face_landmarks.dat\") >> pose_model;\n\n        // Grab and process frames until the main window is closed by the user.\n        while(!win.is_closed())\n        {\n            // Grab a frame\n            cv::Mat temp;\n            cap >> temp;\n            // Turn OpenCV's Mat into something dlib can deal with.  Note that this just\n            // wraps the Mat object, it doesn't copy anything.  So cimg is only valid as\n            // long as temp is valid.  Also don't do anything to temp that would cause it\n            // to reallocate the memory which stores the image as that will make cimg\n            // contain dangling pointers.  This basically means you shouldn't modify temp\n            // while using cimg.\n            cv_image<bgr_pixel> cimg(temp);\n\n            // Detect faces \n            std::vector<rectangle> faces = detector(cimg);\n\n            // Find the pose of each face.\n            std::vector<full_object_detection> shapes;\n            for (unsigned long i = 0; i < faces.size(); ++i)\n                shapes.push_back(pose_model(cimg, faces[i]));\n\n            // Display it all on the screen\n            win.clear_overlay();\n            win.set_image(cimg);\n            win.add_overlay(render_face_detections(shapes));\n\n            // Subdiv2D\u521d\u671f\u5316\n            cv::Subdiv2D subdiv;\n            subdiv.initDelaunay(cv::Rect(0, 0, temp.cols, temp.rows));\n\n            // \u70b9\u3092\u8ffd\u52a0\n            for (unsigned long i = 0; i < shapes.size(); ++i)\n            {\n                full_object_detection& d = shapes[i];\n                for (unsigned long j = 1; j <= 67; ++j) {\n                    if(d.part(j).y() < 0 || d.part(j).y() >= temp.rows || d.part(j).x() >= temp.cols || d.part(j).x() < 0 ) {\n                        break;\n                    }\n                    subdiv.insert(cv::Point2f(d.part(j).x(), d.part(j).y()));\n                }\n            }\n\n            // \u30c9\u30ed\u30cd\u30fc\u56f3\u3092\u53d6\u5f97\n            std::vector<cv::Vec4f> edgeList;\n            subdiv.getEdgeList(edgeList);\n\n            // \u30c9\u30ed\u30cd\u30fc\u56f3\u3092\u63cf\u753b\n            for(auto edge = edgeList.begin(); edge != edgeList.end(); edge++)\n            {\n                std::vector<image_window::overlay_line> triangleLine;\n                triangleLine.push_back(image_window::overlay_line(dlib::vector<long, 2>((long)edge->val[0], (long)edge->val[1]), dlib::vector<long, 2>((long)edge->val[2], (long)edge->val[3]), rgb_pixel(200,200,0)));\n                win.add_overlay(triangleLine);\n            }\n        }\n\n## \u6982\u8981\ndlib\u3067\u9854\u5668\u5b98\u3092\u8a8d\u8b58\u3057\u305f\u5f8c\u306b\u3001\u305d\u308c\u305e\u308c\u306e\u9854\u30d1\u30fc\u30c4\u306b\u5206\u89e3\u3059\u308b\u305f\u3081\u306b\u4e09\u89d2\u5f62\u3067\u5206\u5272\u3057\u307e\u3059\u3002\n\u8907\u6570\u306e\u70b9\u3092\u4e09\u89d2\u5f62\u3067\u8868\u3059\u969b\u306b\u30c9\u30ed\u30cd\u30fc\u56f3\u3068\u3044\u3046\u3082\u306e\u3092\u5229\u7528\u3057\u307e\u3059\u3002\n\u8a73\u3057\u304f\u306f\u4e0b\u8a18\u8a18\u4e8b\u3092\u53c2\u7167\u3002\n\n - [Delaunay Triangulation and Voronoi Diagram using OpenCV ( C++ / Python )](http://www.learnopencv.com/delaunay-triangulation-and-voronoi-diagram-using-opencv-c-python/)\n - [OpenCV C++/IF\u3067\u30dc\u30ed\u30ce\u30a4\u56f3\u30fb\u30c9\u30ed\u30cd\u30fc\u56f3\u3092\u63cf\u304f](http://schima.hatenablog.com/entry/2014/01/24/205517)\n\n## \u7d50\u679c\n\u753b\u50cf\u304c\u8352\u3044\u3067\u3059\u304c\u3053\u3093\u306a\u611f\u3058\u306b\u306a\u308a\u307e\u3059\u3002\n<img width=\"200\" alt=\"\u30b9\u30af\u30ea\u30fc\u30f3\u30b7\u30e7\u30c3\u30c8 2017-01-03 3.40.37.png\" src=\"https://qiita-image-store.s3.amazonaws.com/0/90377/62a55ff4-277c-d6c7-75b1-5b724a6eb1d6.png\">\n\n## \u30bd\u30fc\u30b9\u30b3\u30fc\u30c9\ndlib\u306e\u30b5\u30f3\u30d7\u30eb\u30b3\u30fc\u30c9\u306ewebcam_face_pose_ex.cpp\u3092\u6539\u5909\u3057\u3066\u3044\u307e\u3059\u3002\n\n```\n        cv::VideoCapture cap(0);\n        if (!cap.isOpened())\n        {\n            cerr << \"Unable to connect to camera\" << endl;\n            return 1;\n        }\n\n        image_window win;\n\n        // Load face detection and pose estimation models.\n        frontal_face_detector detector = get_frontal_face_detector();\n        shape_predictor pose_model;\n        deserialize(\"shape_predictor_68_face_landmarks.dat\") >> pose_model;\n\n        // Grab and process frames until the main window is closed by the user.\n        while(!win.is_closed())\n        {\n            // Grab a frame\n            cv::Mat temp;\n            cap >> temp;\n            // Turn OpenCV's Mat into something dlib can deal with.  Note that this just\n            // wraps the Mat object, it doesn't copy anything.  So cimg is only valid as\n            // long as temp is valid.  Also don't do anything to temp that would cause it\n            // to reallocate the memory which stores the image as that will make cimg\n            // contain dangling pointers.  This basically means you shouldn't modify temp\n            // while using cimg.\n            cv_image<bgr_pixel> cimg(temp);\n\n            // Detect faces \n            std::vector<rectangle> faces = detector(cimg);\n            \n            // Find the pose of each face.\n            std::vector<full_object_detection> shapes;\n            for (unsigned long i = 0; i < faces.size(); ++i)\n                shapes.push_back(pose_model(cimg, faces[i]));\n\n            // Display it all on the screen\n            win.clear_overlay();\n            win.set_image(cimg);\n            win.add_overlay(render_face_detections(shapes));\n            \n            // Subdiv2D\u521d\u671f\u5316\n            cv::Subdiv2D subdiv;\n            subdiv.initDelaunay(cv::Rect(0, 0, temp.cols, temp.rows));\n            \n            // \u70b9\u3092\u8ffd\u52a0\n            for (unsigned long i = 0; i < shapes.size(); ++i)\n            {\n                full_object_detection& d = shapes[i];\n                for (unsigned long j = 1; j <= 67; ++j) {\n                    if(d.part(j).y() < 0 || d.part(j).y() >= temp.rows || d.part(j).x() >= temp.cols || d.part(j).x() < 0 ) {\n                        break;\n                    }\n                    subdiv.insert(cv::Point2f(d.part(j).x(), d.part(j).y()));\n                }\n            }\n            \n            // \u30c9\u30ed\u30cd\u30fc\u56f3\u3092\u53d6\u5f97\n            std::vector<cv::Vec4f> edgeList;\n            subdiv.getEdgeList(edgeList);\n            \n            // \u30c9\u30ed\u30cd\u30fc\u56f3\u3092\u63cf\u753b\n            for(auto edge = edgeList.begin(); edge != edgeList.end(); edge++)\n            {\n                std::vector<image_window::overlay_line> triangleLine;\n                triangleLine.push_back(image_window::overlay_line(dlib::vector<long, 2>((long)edge->val[0], (long)edge->val[1]), dlib::vector<long, 2>((long)edge->val[2], (long)edge->val[3]), rgb_pixel(200,200,0)));\n                win.add_overlay(triangleLine);\n            }\n        }\n```\n", "tags": ["dlib", "OpenCV", "\u9854\u8a8d\u8b58", "C++"]}