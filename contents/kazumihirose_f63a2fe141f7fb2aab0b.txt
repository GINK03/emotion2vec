{"context": " More than 1 year has passed since last update.\n\nWindows Server 2008 R2\u3092Ansible\u304b\u3089\u30b3\u30f3\u30c8\u30ed\u30fc\u30eb\u3059\u308b\u306b\u306f\uff1f\n\n\u5bfe\u8c61\u306eServer OS\nWindows Server 2008 R2 Service Pack 1 / Windows Server 2012\n\n\n\u4e8b\u524d\u306b\u30a4\u30f3\u30b9\u30c8\u30fc\u30eb\u3057\u3066\u304a\u304f\u3079\u304d\u3082\u306e\n\nWindows Management Framework 4.0 \nhttp://www.microsoft.com/en-us/download/details.aspx?id=42643\nMicrosoft .NET Framework 4.5.2\nhttp://www.microsoft.com/ja-jp/download/details.aspx?id=40855\n\n\n\u30a4\u30f3\u30b9\u30c8\u30fc\u30eb\u3067\u304d\u305f\u304b\u78ba\u8a8d\nPS C:\\Users\\Administrator> $PSVersionTable\n\nName                           Value\n----                           -----\nPSVersion                      4.0\nWSManStackVersion              3.0\nSerializationVersion           1.1.0.1\nCLRVersion                     4.0.30319.34209\nBuildVersion                   6.3.9600.16406\nPSCompatibleVersions           {1.0, 2.0, 3.0, 4.0}\nPSRemotingProtocolVersion      2.2\n\nPS C:\\Users\\Administrator>\n\n\nBasic\u8a8d\u8a3c\u3092\u8a31\u53ef\n\u73fe\u5728\u306eAnsible\u306f\u3001Basic\u8a8d\u8a3c\u3092\u524d\u63d0\u306b\u958b\u767a\u3055\u308c\u3066\u3044\u307e\u3059\u306e\u3067\u3001Basic\u8a8d\u8a3c\u3092\u6709\u52b9\u306b\u3057\u307e\u3059\u3002\nPS C:\\Users\\Administrator>winrm set winrm/config/service/auth '@{Basic=\"true\"}'\nAuth\n    Basic = true\n    Kerberos = true\n    Negotiate = true\n    Certificate = false\n    CredSSP = false\n    CbtHardeningLevel = Relaxed\n\n\nHTTP\u3067\u306e\u63a5\u7d9a\u8a31\u53ef\nPS C:\\Users\\Administrator> winrm set winrm/config/service '@{AllowUnencrypted=\"true\"}'\nService\n    RootSDDL = O:NSG:BAD:P(A;;GA;;;BA)(A;;GR;;;IU)S:P(AU;FA;GA;;;WD)(AU;SA;GXGW;;;WD)\n    MaxConcurrentOperations = 4294967295\n    MaxConcurrentOperationsPerUser = 1500\n    EnumerationTimeoutms = 240000\n    MaxConnections = 300\n    MaxPacketRetrievalTimeSeconds = 120\n    AllowUnencrypted = true\n    Auth\n        Basic = true\n        Kerberos = true\n        Negotiate = true\n        Certificate = false\n        CredSSP = false\n        CbtHardeningLevel = Relaxed\n    DefaultPorts\n        HTTP = 5985\n        HTTPS = 5986\n    IPv4Filter = *\n    IPv6Filter = *\n    EnableCompatibilityHttpListener = false\n    EnableCompatibilityHttpsListener = false\n    CertificateThumbprint\n    AllowRemoteAccess = true\n\n\nHTTPS \u6709\u52b9\u5316\nHTTP\u3067\u3082\u6697\u53f7\u5316\u3057\u3066\u9001\u4fe1\u3055\u308c\u308b\u70ba\u3001\u30d7\u30e9\u30a4\u30d9\u30fc\u30c8\u306a\u30b5\u30d6\u30cd\u30c3\u30c8\u3067\u7279\u306b\u554f\u984c\u306f\u306a\u3044\u304b\u3082\u3057\u308c\u307e\u305b\u3093\u304c\u3001\u901a\u4fe1\u8def\u306e\u6697\u53f7\u5316\u3092\u884c\u3046\u3053\u3068\u306b\u3057\u307e\u3059\u3002\n\u8a3c\u660e\u66f8\u3068\u304b\u4f5c\u308b\u306e\u3082\u9762\u5012\u306a\u306e\u3067\u3001\u4ee5\u4e0b\u306e\u30b9\u30af\u30ea\u30d7\u30c8\u3067\u30b6\u30af\u30c3\u3068\u4f5c\u6210\u3057\u3066\u3057\u307e\u3044\u307e\u3059\u3002\n\u30b9\u30af\u30ea\u30d7\u30c8\u306f\u4ee5\u4e0b\u306e\u3082\u306e\u3092\u5c11\u3057\u4fee\u6b63\u3057\u307e\u3057\u305f\u3002\nhttps://github.com/ansible/ansible/blob/devel/examples/scripts/ConfigureRemotingForAnsible.ps1\n# Configure a Windows host for remote management with Ansible\n# -----------------------------------------------------------\n#\n# This script checks the current WinRM/PSRemoting configuration and makes the\n# necessary changes to allow Ansible to connect, authenticate and execute\n# PowerShell commands.\n# \n# Set $VerbosePreference = \"Continue\" before running the script in order to\n# see the output messages.\n#\n# Written by Trond Hindenes <trond@hindenes.com>\n# Updated by Chris Church <cchurch@ansible.com>\n#\n# Version 1.0 - July 6th, 2014\n# Version 1.1 - November 11th, 2014\n\nParam (\n    [string]$SubjectName = $env:COMPUTERNAME,\n    [int]$CertValidityDays = 3650,\n    $CreateSelfSignedCert = $true\n)\n\n\nFunction New-LegacySelfSignedCert\n{\n    Param (\n        [string]$SubjectName,\n        [int]$ValidDays = 3650\n    )\n\n    $name = New-Object -COM \"X509Enrollment.CX500DistinguishedName.1\"\n    $name.Encode(\"CN=$SubjectName\", 0)\n\n    $key = New-Object -COM \"X509Enrollment.CX509PrivateKey.1\"\n    $key.ProviderName = \"Microsoft RSA SChannel Cryptographic Provider\"\n    $key.KeySpec = 1\n    $key.Length = 1024\n    $key.SecurityDescriptor = \"D:PAI(A;;0xd01f01ff;;;SY)(A;;0xd01f01ff;;;BA)(A;;0x80120089;;;NS)\"\n    $key.MachineContext = 1\n    $key.Create()\n\n    $serverauthoid = New-Object -COM \"X509Enrollment.CObjectId.1\"\n    $serverauthoid.InitializeFromValue(\"1.3.6.1.5.5.7.3.1\")\n    $ekuoids = New-Object -COM \"X509Enrollment.CObjectIds.1\"\n    $ekuoids.Add($serverauthoid)\n    $ekuext = New-Object -COM \"X509Enrollment.CX509ExtensionEnhancedKeyUsage.1\"\n    $ekuext.InitializeEncode($ekuoids)\n\n    $cert = New-Object -COM \"X509Enrollment.CX509CertificateRequestCertificate.1\"\n    $cert.InitializeFromPrivateKey(2, $key, \"\")\n    $cert.Subject = $name\n    $cert.Issuer = $cert.Subject\n    $cert.NotBefore = (Get-Date).AddDays(-1)\n    $cert.NotAfter = $cert.NotBefore.AddDays($ValidDays)\n    $cert.X509Extensions.Add($ekuext)\n    $cert.Encode()\n\n    $enrollment = New-Object -COM \"X509Enrollment.CX509Enrollment.1\"\n    $enrollment.InitializeFromRequest($cert)\n    $certdata = $enrollment.CreateRequest(0)\n    $enrollment.InstallResponse(2, $certdata, 0, \"\")\n\n    # Return the thumbprint of the last installed cert.\n    Get-ChildItem \"Cert:\\LocalMachine\\my\"| Sort-Object NotBefore -Descending | Select -First 1 | Select -Expand Thumbprint\n}\n\n# Setup error handling.\nTrap\n{\n    $_\n    Exit 1\n}\n$ErrorActionPreference = \"Stop\"\n\n# Detect PowerShell version.\nIf ($PSVersionTable.PSVersion.Major -lt 3)\n{\n    Throw \"PowerShell version 3 or higher is required.\"\n}\n\n\n# Find and start the WinRM service.\nWrite-Verbose \"Verifying WinRM service.\"\nIf (!(Get-Service \"WinRM\"))\n{\n    Throw \"Unable to find the WinRM service.\"\n}\nElseIf ((Get-Service \"WinRM\").Status -ne \"Running\")\n{\n    Write-Verbose \"Starting WinRM service.\"\n    Start-Service -Name \"WinRM\" -ErrorAction Stop\n}\n\n\n# WinRM should be running; check that we have a PS session config.\nIf (!(Get-PSSessionConfiguration -Verbose:$false) -or (!(Get-ChildItem WSMan:\\localhost\\Listener)))\n{\n    Write-Verbose \"Enabling PS Remoting.\"\n    Enable-PSRemoting -Force -ErrorAction Stop\n}\nElse\n{\n    Write-Verbose \"PS Remoting is already enabled.\"\n}\n\n\n# Test a remoting connection to localhost, which should work.\n$httpResult = New-PSSession -ComputerName \"localhost\" -ErrorVariable httpError -ErrorAction SilentlyContinue\n$httpsOptions = New-PSSessionOption -SkipCACheck -SkipCNCheck -SkipRevocationCheck\n$httpsResult = New-PSSession -UseSSL -ComputerName \"localhost\" -SessionOption $httpsOptions -ErrorVariable httpsError -ErrorAction SilentlyContinue\n\nIf ($httpResult -and $httpsResult)\n{\n    Write-Verbose \"HTTP and HTTPS sessions are enabled.\"\n}\nElseIf ($httpsResult -and !$httpResult)\n{\n    Write-Verbose \"HTTP sessions are disabled, HTTPS session are enabled.\"\n}\nElseIf ($httpResult -and !$httpsResult)\n{\n    Write-Verbose \"HTTPS sessions are disabled, HTTP session are enabled.\"\n}\nElse\n{\n    Throw \"Unable to establish an HTTP or HTTPS remoting session.\"\n}\n\n# Make sure there is a SSL listener.\n$listeners = Get-ChildItem WSMan:\\localhost\\Listener\nIf (!($listeners | Where {$_.Keys -like \"TRANSPORT=HTTPS\"}))\n{\n    # HTTPS-based endpoint does not exist.\n    If (Get-Command \"New-SelfSignedCertificate\" -ErrorAction SilentlyContinue)\n    {\n        $cert = New-SelfSignedCertificate -DnsName $env:COMPUTERNAME -CertStoreLocation \"Cert:\\LocalMachine\\My\"\n        $thumbprint = $cert.Thumbprint\n    }\n    Else\n    {\n        $thumbprint = New-LegacySelfSignedCert -SubjectName $env:COMPUTERNAME\n    }\n\n    # Create the hashtables of settings to be used.\n    $valueset = @{}\n    $valueset.Add('Hostname', $env:COMPUTERNAME)\n    $valueset.Add('CertificateThumbprint', $thumbprint)\n\n    $selectorset = @{}\n    $selectorset.Add('Transport', 'HTTPS')\n    $selectorset.Add('Address', '*')\n\n    Write-Verbose \"Enabling SSL listener.\"\n    New-WSManInstance -ResourceURI 'winrm/config/Listener' -SelectorSet $selectorset -ValueSet $valueset\n}\nElse\n{\n    Write-Verbose \"SSL listener is already active.\"\n}\n\n\n# Check for basic authentication.\n$basicAuthSetting = Get-ChildItem WSMan:\\localhost\\Service\\Auth | Where {$_.Name -eq \"Basic\"}\nIf (($basicAuthSetting.Value) -eq $false)\n{\n    Write-Verbose \"Enabling basic auth support.\"\n    Set-Item -Path \"WSMan:\\localhost\\Service\\Auth\\Basic\" -Value $true\n}\nElse\n{\n    Write-Verbose \"Basic auth is already enabled.\"\n}\n\n\n# Configure firewall to allow WinRM HTTPS connections.\n$fwtest1 = netsh advfirewall firewall show rule name=\"Allow WinRM HTTPS\"\n$fwtest2 = netsh advfirewall firewall show rule name=\"Allow WinRM HTTPS\" profile=any\nIf ($fwtest1.count -lt 5)\n{\n    Write-Verbose \"Adding firewall rule to allow WinRM HTTPS.\"\n    netsh advfirewall firewall add rule profile=any name=\"Allow WinRM HTTPS\" dir=in localport=5986 protocol=TCP action=allow\n}\nElseIf (($fwtest1.count -ge 5) -and ($fwtest2.count -lt 5))\n{\n    Write-Verbose \"Updating firewall rule to allow WinRM HTTPS for any profile.\"\n    netsh advfirewall firewall set rule name=\"Allow WinRM HTTPS\" new profile=any\n}\nElse\n{\n    Write-Verbose \"Firewall rule already exists to allow WinRM HTTPS.\"\n}\n\nWrite-Verbose \"PS Remoting has been successfully configured for Ansible.\"\n\n# Windows Server 2008 R2\u3092Ansible\u304b\u3089\u30b3\u30f3\u30c8\u30ed\u30fc\u30eb\u3059\u308b\u306b\u306f\uff1f #\n\n- \u5bfe\u8c61\u306eServer OS\nWindows Server 2008 R2 Service Pack 1 / Windows Server 2012\n\n## \u4e8b\u524d\u306b\u30a4\u30f3\u30b9\u30c8\u30fc\u30eb\u3057\u3066\u304a\u304f\u3079\u304d\u3082\u306e ##\n\n- Windows Management Framework 4.0 \nhttp://www.microsoft.com/en-us/download/details.aspx?id=42643\n\n- Microsoft .NET Framework 4.5.2\nhttp://www.microsoft.com/ja-jp/download/details.aspx?id=40855\n\n## \u30a4\u30f3\u30b9\u30c8\u30fc\u30eb\u3067\u304d\u305f\u304b\u78ba\u8a8d ##\n\n\tPS C:\\Users\\Administrator> $PSVersionTable\n\t\n\tName                           Value\n\t----                           -----\n\tPSVersion                      4.0\n\tWSManStackVersion              3.0\n\tSerializationVersion           1.1.0.1\n\tCLRVersion                     4.0.30319.34209\n\tBuildVersion                   6.3.9600.16406\n\tPSCompatibleVersions           {1.0, 2.0, 3.0, 4.0}\n\tPSRemotingProtocolVersion      2.2\n\t\n\tPS C:\\Users\\Administrator>\n\n## Basic\u8a8d\u8a3c\u3092\u8a31\u53ef ##\n\n\u73fe\u5728\u306eAnsible\u306f\u3001Basic\u8a8d\u8a3c\u3092\u524d\u63d0\u306b\u958b\u767a\u3055\u308c\u3066\u3044\u307e\u3059\u306e\u3067\u3001Basic\u8a8d\u8a3c\u3092\u6709\u52b9\u306b\u3057\u307e\u3059\u3002\n\n\tPS C:\\Users\\Administrator>winrm set winrm/config/service/auth '@{Basic=\"true\"}'\n\tAuth\n\t    Basic = true\n\t    Kerberos = true\n\t    Negotiate = true\n\t    Certificate = false\n\t    CredSSP = false\n\t    CbtHardeningLevel = Relaxed\n\n## HTTP\u3067\u306e\u63a5\u7d9a\u8a31\u53ef ##\n\n\tPS C:\\Users\\Administrator> winrm set winrm/config/service '@{AllowUnencrypted=\"true\"}'\n\tService\n\t    RootSDDL = O:NSG:BAD:P(A;;GA;;;BA)(A;;GR;;;IU)S:P(AU;FA;GA;;;WD)(AU;SA;GXGW;;;WD)\n\t    MaxConcurrentOperations = 4294967295\n\t    MaxConcurrentOperationsPerUser = 1500\n\t    EnumerationTimeoutms = 240000\n\t    MaxConnections = 300\n\t    MaxPacketRetrievalTimeSeconds = 120\n\t    AllowUnencrypted = true\n\t    Auth\n\t        Basic = true\n\t        Kerberos = true\n\t        Negotiate = true\n\t        Certificate = false\n\t        CredSSP = false\n\t        CbtHardeningLevel = Relaxed\n\t    DefaultPorts\n\t        HTTP = 5985\n\t        HTTPS = 5986\n\t    IPv4Filter = *\n\t    IPv6Filter = *\n\t    EnableCompatibilityHttpListener = false\n\t    EnableCompatibilityHttpsListener = false\n\t    CertificateThumbprint\n\t    AllowRemoteAccess = true\n\n## HTTPS \u6709\u52b9\u5316 ##\n\nHTTP\u3067\u3082\u6697\u53f7\u5316\u3057\u3066\u9001\u4fe1\u3055\u308c\u308b\u70ba\u3001\u30d7\u30e9\u30a4\u30d9\u30fc\u30c8\u306a\u30b5\u30d6\u30cd\u30c3\u30c8\u3067\u7279\u306b\u554f\u984c\u306f\u306a\u3044\u304b\u3082\u3057\u308c\u307e\u305b\u3093\u304c\u3001\u901a\u4fe1\u8def\u306e\u6697\u53f7\u5316\u3092\u884c\u3046\u3053\u3068\u306b\u3057\u307e\u3059\u3002\n\u8a3c\u660e\u66f8\u3068\u304b\u4f5c\u308b\u306e\u3082\u9762\u5012\u306a\u306e\u3067\u3001\u4ee5\u4e0b\u306e\u30b9\u30af\u30ea\u30d7\u30c8\u3067\u30b6\u30af\u30c3\u3068\u4f5c\u6210\u3057\u3066\u3057\u307e\u3044\u307e\u3059\u3002\n\n\u30b9\u30af\u30ea\u30d7\u30c8\u306f\u4ee5\u4e0b\u306e\u3082\u306e\u3092\u5c11\u3057\u4fee\u6b63\u3057\u307e\u3057\u305f\u3002\n\nhttps://github.com/ansible/ansible/blob/devel/examples/scripts/ConfigureRemotingForAnsible.ps1\n\n\t# Configure a Windows host for remote management with Ansible\n\t# -----------------------------------------------------------\n\t#\n\t# This script checks the current WinRM/PSRemoting configuration and makes the\n\t# necessary changes to allow Ansible to connect, authenticate and execute\n\t# PowerShell commands.\n\t# \n\t# Set $VerbosePreference = \"Continue\" before running the script in order to\n\t# see the output messages.\n\t#\n\t# Written by Trond Hindenes <trond@hindenes.com>\n\t# Updated by Chris Church <cchurch@ansible.com>\n\t#\n\t# Version 1.0 - July 6th, 2014\n\t# Version 1.1 - November 11th, 2014\n\t\n\tParam (\n\t    [string]$SubjectName = $env:COMPUTERNAME,\n\t    [int]$CertValidityDays = 3650,\n\t    $CreateSelfSignedCert = $true\n\t)\n\t\n\t\n\tFunction New-LegacySelfSignedCert\n\t{\n\t    Param (\n\t        [string]$SubjectName,\n\t        [int]$ValidDays = 3650\n\t    )\n\t    \n\t    $name = New-Object -COM \"X509Enrollment.CX500DistinguishedName.1\"\n\t    $name.Encode(\"CN=$SubjectName\", 0)\n\t\n\t    $key = New-Object -COM \"X509Enrollment.CX509PrivateKey.1\"\n\t    $key.ProviderName = \"Microsoft RSA SChannel Cryptographic Provider\"\n\t    $key.KeySpec = 1\n\t    $key.Length = 1024\n\t    $key.SecurityDescriptor = \"D:PAI(A;;0xd01f01ff;;;SY)(A;;0xd01f01ff;;;BA)(A;;0x80120089;;;NS)\"\n\t    $key.MachineContext = 1\n\t    $key.Create()\n\t\n\t    $serverauthoid = New-Object -COM \"X509Enrollment.CObjectId.1\"\n\t    $serverauthoid.InitializeFromValue(\"1.3.6.1.5.5.7.3.1\")\n\t    $ekuoids = New-Object -COM \"X509Enrollment.CObjectIds.1\"\n\t    $ekuoids.Add($serverauthoid)\n\t    $ekuext = New-Object -COM \"X509Enrollment.CX509ExtensionEnhancedKeyUsage.1\"\n\t    $ekuext.InitializeEncode($ekuoids)\n\t\n\t    $cert = New-Object -COM \"X509Enrollment.CX509CertificateRequestCertificate.1\"\n\t    $cert.InitializeFromPrivateKey(2, $key, \"\")\n\t    $cert.Subject = $name\n\t    $cert.Issuer = $cert.Subject\n\t    $cert.NotBefore = (Get-Date).AddDays(-1)\n\t    $cert.NotAfter = $cert.NotBefore.AddDays($ValidDays)\n\t    $cert.X509Extensions.Add($ekuext)\n\t    $cert.Encode()\n\t\n\t    $enrollment = New-Object -COM \"X509Enrollment.CX509Enrollment.1\"\n\t    $enrollment.InitializeFromRequest($cert)\n\t    $certdata = $enrollment.CreateRequest(0)\n\t    $enrollment.InstallResponse(2, $certdata, 0, \"\")\n\t\n\t    # Return the thumbprint of the last installed cert.\n\t    Get-ChildItem \"Cert:\\LocalMachine\\my\"| Sort-Object NotBefore -Descending | Select -First 1 | Select -Expand Thumbprint\n\t}\n\t\t\n\t# Setup error handling.\n\tTrap\n\t{\n\t    $_\n\t    Exit 1\n\t}\n\t$ErrorActionPreference = \"Stop\"\n\t\n\t# Detect PowerShell version.\n\tIf ($PSVersionTable.PSVersion.Major -lt 3)\n\t{\n\t    Throw \"PowerShell version 3 or higher is required.\"\n\t}\n\t\n\t\n\t# Find and start the WinRM service.\n\tWrite-Verbose \"Verifying WinRM service.\"\n\tIf (!(Get-Service \"WinRM\"))\n\t{\n\t    Throw \"Unable to find the WinRM service.\"\n\t}\n\tElseIf ((Get-Service \"WinRM\").Status -ne \"Running\")\n\t{\n\t    Write-Verbose \"Starting WinRM service.\"\n\t    Start-Service -Name \"WinRM\" -ErrorAction Stop\n\t}\n\t\n\t\n\t# WinRM should be running; check that we have a PS session config.\n\tIf (!(Get-PSSessionConfiguration -Verbose:$false) -or (!(Get-ChildItem WSMan:\\localhost\\Listener)))\n\t{\n\t    Write-Verbose \"Enabling PS Remoting.\"\n\t    Enable-PSRemoting -Force -ErrorAction Stop\n\t}\n\tElse\n\t{\n\t    Write-Verbose \"PS Remoting is already enabled.\"\n\t}\n\t\n\n\t# Test a remoting connection to localhost, which should work.\n\t$httpResult = New-PSSession -ComputerName \"localhost\" -ErrorVariable httpError -ErrorAction SilentlyContinue\n\t$httpsOptions = New-PSSessionOption -SkipCACheck -SkipCNCheck -SkipRevocationCheck\n\t$httpsResult = New-PSSession -UseSSL -ComputerName \"localhost\" -SessionOption $httpsOptions -ErrorVariable httpsError -ErrorAction SilentlyContinue\n\t\n\tIf ($httpResult -and $httpsResult)\n\t{\n\t    Write-Verbose \"HTTP and HTTPS sessions are enabled.\"\n\t}\n\tElseIf ($httpsResult -and !$httpResult)\n\t{\n\t    Write-Verbose \"HTTP sessions are disabled, HTTPS session are enabled.\"\n\t}\n\tElseIf ($httpResult -and !$httpsResult)\n\t{\n\t    Write-Verbose \"HTTPS sessions are disabled, HTTP session are enabled.\"\n\t}\n\tElse\n\t{\n\t    Throw \"Unable to establish an HTTP or HTTPS remoting session.\"\n\t}\n\t\t\n\t# Make sure there is a SSL listener.\n\t$listeners = Get-ChildItem WSMan:\\localhost\\Listener\n\tIf (!($listeners | Where {$_.Keys -like \"TRANSPORT=HTTPS\"}))\n\t{\n\t    # HTTPS-based endpoint does not exist.\n\t    If (Get-Command \"New-SelfSignedCertificate\" -ErrorAction SilentlyContinue)\n\t    {\n\t        $cert = New-SelfSignedCertificate -DnsName $env:COMPUTERNAME -CertStoreLocation \"Cert:\\LocalMachine\\My\"\n\t        $thumbprint = $cert.Thumbprint\n\t    }\n\t    Else\n\t    {\n\t        $thumbprint = New-LegacySelfSignedCert -SubjectName $env:COMPUTERNAME\n\t    }\n\t\n\t    # Create the hashtables of settings to be used.\n\t    $valueset = @{}\n\t    $valueset.Add('Hostname', $env:COMPUTERNAME)\n\t    $valueset.Add('CertificateThumbprint', $thumbprint)\n\t\n\t    $selectorset = @{}\n\t    $selectorset.Add('Transport', 'HTTPS')\n\t    $selectorset.Add('Address', '*')\n\t\n\t    Write-Verbose \"Enabling SSL listener.\"\n\t    New-WSManInstance -ResourceURI 'winrm/config/Listener' -SelectorSet $selectorset -ValueSet $valueset\n\t}\n\tElse\n\t{\n\t    Write-Verbose \"SSL listener is already active.\"\n\t}\n\t\n\t\n\t# Check for basic authentication.\n\t$basicAuthSetting = Get-ChildItem WSMan:\\localhost\\Service\\Auth | Where {$_.Name -eq \"Basic\"}\n\tIf (($basicAuthSetting.Value) -eq $false)\n\t{\n\t    Write-Verbose \"Enabling basic auth support.\"\n\t    Set-Item -Path \"WSMan:\\localhost\\Service\\Auth\\Basic\" -Value $true\n\t}\n\tElse\n\t{\n\t    Write-Verbose \"Basic auth is already enabled.\"\n\t}\n\t\n\t\n\t# Configure firewall to allow WinRM HTTPS connections.\n\t$fwtest1 = netsh advfirewall firewall show rule name=\"Allow WinRM HTTPS\"\n\t$fwtest2 = netsh advfirewall firewall show rule name=\"Allow WinRM HTTPS\" profile=any\n\tIf ($fwtest1.count -lt 5)\n\t{\n\t    Write-Verbose \"Adding firewall rule to allow WinRM HTTPS.\"\n\t    netsh advfirewall firewall add rule profile=any name=\"Allow WinRM HTTPS\" dir=in localport=5986 protocol=TCP action=allow\n\t}\n\tElseIf (($fwtest1.count -ge 5) -and ($fwtest2.count -lt 5))\n\t{\n\t    Write-Verbose \"Updating firewall rule to allow WinRM HTTPS for any profile.\"\n\t    netsh advfirewall firewall set rule name=\"Allow WinRM HTTPS\" new profile=any\n\t}\n\tElse\n\t{\n\t    Write-Verbose \"Firewall rule already exists to allow WinRM HTTPS.\"\n\t}\n\t\t\n\tWrite-Verbose \"PS Remoting has been successfully configured for Ansible.\"\n", "tags": ["WindowsAzure", "WindowsServer2008 R2 SP1, 2012"]}