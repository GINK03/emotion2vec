{"context": "\n\n19\u65e5\u76ee\n\u4e45\u3057\u3076\u308a\u306b\u66f8\u304f.\n\u864e\u672c\u304cinstantiation\u3092\u5b9f\u4f53\u3068\u8a33\u3057\u3066\u3044\u305f\u306e\u3067,instantiate\u3092\u3053\u308c\u304b\u3089\u5b9f\u4f53\u5316\u3068\u66f8\u304f\u3053\u3068\u306b\u3059\u308b.\n\n2.5 Mark 3: Adding updating\n\u4eca\u307e\u3067\u306e\u30de\u30b7\u30f3\u306f\u30b0\u30e9\u30d5\u306e\u66f4\u65b0\u3092\u3057\u3066\u3044\u306a\u304b\u3063\u305f\u306e\u3067,\u540c\u3058\u90e8\u5206\u5f0f\u306e\u51fa\u73fe\u306b\u5bfe\u30572\u56de\u8a08\u7b97\u3092\u3055\u305b\u3066\u3044\u305f.\n\u4f8b\u3048\u3070,\nW x y = x y y\nmain = W I (K I I) 0\n\n\u306a\u3069.\n\u3053\u306e\u6642,main\u306fW I (K I I) (K I I) 0\u3068\u5c55\u958b\u3055\u308c\u308b\u308f\u3051\u3060\u304c,W\u306e\u5f15\u6570\u306e(K I I)\u306f\u540c\u3058\u5834\u6240\u3092\u53c2\u7167\u3057\u3066\u3044\u308b\u306e\u3067,\u6700\u521d\u306e(K I I)\u3092\u5b9f\u4f53\u5316\u3057\u305f\u6642\u306b\u7d50\u679c\u304c\u308f\u304b\u308a,\u4e8c\u56de\u76ee\u306e(K I I)\u306e\u5b9f\u4f53\u5316\u306f\u305d\u306e\u7d50\u679c\u3092\u4f7f\u7528\u3059\u308b\u3053\u3068\u304c\u3067\u304d\u308b.\n\u3053\u308c\u306f\u3053\u306e\u8a00\u8a9e\u304c\u7d14\u7c8b\u3060\u304b\u3089\u3067\u304d\u308b.\n\u3053\u308c\u3092\u89e3\u6c7a\u3059\u308b\u305f\u3081,\u9593\u63a5\u53c2\u7167\u30ce\u30fc\u30c9,(NInd Addr)\u578b\u3092\u8ffd\u52a0\u3059\u308b.\n\u6700\u521d\u306e\u5b9f\u4f53\u5316\u306e\u3068\u304d\u306b,root\u306e\u53c2\u7167\u5148\u3092(NInd \u5b9f\u4f53\u5148\u30a2\u30c9\u30ec\u30b9)\u3067\u66f4\u65b0\u3059\u308b\u3053\u3068\u306b\u3088\u308a,\u4f59\u8a08\u306a\u8a08\u7b97\u3092\u7701\u304f.\n\u307e\u305f,NInd\u578b\u306b\u5bfe\u5fdc\u3059\u308b\u305f\u3081,\u30b9\u30c6\u30fc\u30c8\u30de\u30b7\u30f3\u306b\u65b0\u3057\u3044\u30eb\u30fc\u30eb\u3092\u8ffd\u52a0\u3059\u308b.\nExercise\u3067\u52b9\u679c\u3092\u6e2c\u5b9a\u3057\u308d\u3068\u4f1a\u3063\u305f\u306e\u3067, main = main = W C (W C) (W C) (W C) I 3\u3092\u8a08\u7b97\u3055\u305b\u308b.\n\u5358\u7d14\u8a08\u7b97\u30672^16\u56de,\u5373\u306165536\u56deI\u30923\u306b\u9069\u7528\u3059\u308b.\n\n\u7d50\u679c\u3068\u5b9f\u884c\u6642\u9593.NInd\u306a\u3057\nStack [ (top)\n  17: NNum 3\n]\n\n\nTotal number of steps = 805726\nTotal number of reductions = 258295\nTotal number of supercombinator reductions = 1\nTotal number of primitive reductions = 258294\nMaximum of stack depth = 7\n\nreal    215m43.150s\nuser    215m1.582s\nsys     0m1.637s\n\n\n\n\u7d50\u679c.NInd\u3042\u308a\nStack [ (top)\n  17: NNum 3\n]\n\n\nTotal number of steps = 485349\nTotal number of reductions = 131114\nTotal number of supercombinator reductions = 1\nTotal number of primitive reductions = 131113\nMaximum of stack depth = 7\n\nreal    49m10.059s\nuser    48m59.786s\nsys     0m0.423s\n\n\n\u6700\u5f8c\u306b\u307e\u3068\u3081\u3066\u8868\u306b\u3057\u305f\u3082\u306e\u3092\u51fa\u3059\u304c,NInd\u3042\u308a\u306e\u65b9\u306f\u30b9\u30c6\u30c3\u30d7\u6570\u304c60%,\u7c21\u7d04\u306e\u6570\u304c50%\u306b\u306a\u3063\u3066\u3044\u3066,\u6642\u9593\u306f25%\u3068\u9ad8\u901f\u306b\u306a\u3063\u3066\u3044\u308b.\nNInd\u306e \u3061\u304b\u3089\u3063\u3066 \u3059\u3052\u30fc!\n\n2.5.1 Reducing the number of indirections\n\u4eca\u56de,\u65b0\u3057\u304finstantiate\u3055\u308c\u305f\u3068\u304d\u306bNInd\u3092\u4f7f\u3063\u3066\u66f4\u65b0\u3057\u305f\u304c,\u76f4\u63a5\u66f4\u65b0\u3067\u304d\u308b\u5834\u5408\u3082\u3042\u308b.\nredex\u306eroot\u306e\u9802\u70b9\u306f\u76f4\u63a5\u7d50\u679c\u3067\u7f6e\u304d\u63db\u3048\u308b\u3053\u3068\u304c\u3067\u304d\u308b.\n\u4f55\u6545\u306a\u3089,root\u306e\u9802\u70b9\u3092\u5b9f\u4f53\u5316\u3057\u305f\u7d50\u679c\u306f\u65b0\u3057\u304f\u4f5c\u308a\u51fa\u3055\u308c\u308b\u3082\u306e\u3067\u3042\u308a,\u3053\u306e\u66f4\u65b0\u3092\u3059\u308b\u3053\u3068\u306b\u3088\u3063\u3066\u5931\u308f\u308c\u308b\u3088\u3046\u306a\u5171\u6709\u7269\u306f\u306a\u3044\u3057(no sharing can be lost by doing this),\u307e\u305f,\u3055\u3089\u306a\u308b\u30ce\u30fc\u30c9\u3092\u4f5c\u308a\u51fa\u3059\u306e\u3092\u6291\u3048\u308b\u3053\u3068\u304c\u3067\u304d\u308b.\n\u4eca\u307e\u3067\u306f\u30b0\u30e9\u30d5\u3092update,\u66f4\u65b0\u3057\u3066\u3044\u306a\u304b\u3063\u305f\u304c,\u66f4\u65b0\u3059\u308b\u3053\u3068\u306b\u3088\u3063\u3066\u9ad8\u901f\u5316\u3067\u304d\u308b.\nhAlloc\u3057\u304b\u4f7f\u3063\u3066\u3044\u306a\u304b\u3063\u305f\u306e\u3067,\u5b9f\u4f53\u5316\u3059\u308b\u305f\u3073\u306b\u65b0\u3057\u3044node\u3092\u78ba\u4fdd\u3057\u3066\u3044\u305f.\n\u3057\u304b\u3082gc\u306a\u3093\u3066\u7121\u3044\u306e\u3067,\u78ba\u4fdd\u3057\u305f\u3089\u78ba\u4fdd\u3057\u3063\u3071\u306a\u3057\u3067,\u3069\u3093\u3069\u3093\u306e\u30d2\u30fc\u30d7\u304c\u4f38\u3073\u308b.\n\u3053\u308c\u306f,heap\u306e\u691c\u7d22\u3092\u3059\u308b\u3068\u304d\u306b\u5927\u5e45\u306b\u30dc\u30c8\u30eb\u30cd\u30c3\u30af\u306b\u306a\u308b.\n(Lookup\u7cfb\u306e\u95a2\u6570\u306f\u30ea\u30cb\u30a2\u30b5\u30fc\u30c1)\ninstantiateAndUpdate\u3068\u3044\u3046\u95a2\u6570\u3092\u4f7f\u3063\u3066update\u3059\u308b.\nexercise 2.14\u3067\u3053\u306e\u5b9a\u7fa9\u3092\u5b8c\u6210\u3055\u305b\u3088\u3068\u304b\u3042\u308b\u3051\u3069,\u307e\u3042\u524d\u306einstantiate\u3092\u30b3\u30d4\u308b\u3060\u3051.\n\u6ce8\u610f\u3068\u3057\u3066,update\u3067\u304d\u308b\u306e\u306froot\u3060\u3051\u306a\u306e\u3067,\u518d\u5e30\u3059\u308b\u65b9\u306f\u6614\u306einstantiate\u3092\u4f7f\u308f\u306a\u3044\u3068\u3044\u3051\u306a\u3044.\n\u5909\u6570\u306fNInd\u304c\u5fc5\u8981\u3067\u3042\u308b.\u4f55\u6545\u304b?\n\u2192 hUpdate\u306f\u5f15\u6570\u306bNode\u578b\u3092\u53d6\u308b\u304c,aLookup\u3067\u898b\u3064\u304b\u308b\u675f\u7e1b\u306fAddress\u306e\u305f\u3081,NInd\u3067\u30e9\u30c3\u30d7\u3059\u308b\u5fc5\u8981\u304c\u3042\u308b\u304b\u3089.\n\u6ce8\u610f\u3057\u3066let(rec)\u3092\u5b9f\u88c5\u305b\u3088\u3068\u304b\u66f8\u3044\u3066\u3042\u3063\u305f\u3051\u3069,\u675f\u7e1b\u3092\u4f5c\u308b\u3068\u304d\u306f\u3069\u3046\u3057\u3066\u3082\u65b0\u3057\u3044\u30ce\u30fc\u30c9\u304c\u5fc5\u8981\u306a\u306e\u3067,body\u3092\u5b9f\u4f53\u5316\u3059\u308b\u3068\u304d\u3060\u3051Update\u3059\u308b\u3088\u3046\u306b\u3057\u305f.\n\u4e0a\u624b\u304f\u3044\u3063\u3066\u308b\u306e\u3067\u3053\u308c\u3067\u826f\u3057\u3068\u3059\u308b.\n2.5\u306e\u30d9\u30f3\u30c1\u30de\u30fc\u30af\u3092\u3053\u306e\u5909\u66f4\u5f8c\u306b\u3082\u3046\u4e00\u5ea6\u3084\u3063\u3066\u307f\u308b\n\n\u7d50\u679c.Update\u3042\u308a\nStack [ (top)\n  17: NNum 3\n]\n\n\nTotal number of steps = 485349\nTotal number of reductions = 131114\nTotal number of supercombinator reductions = 1\nTotal number of primitive reductions = 131113\nMaximum of stack depth = 7\n\nreal    10m28.507s\nuser    10m27.380s\nsys     0m0.133s\n\n\n\u307e\u3042let(rec)\u3082\u4f7f\u308f\u306a\u3044\u305f\u3060\u306e\u7c21\u7d04\u3060\u3051\u306a\u306e\u3067,\u4e0a\u306e\u7d50\u679c\u304c\u540c\u3058\u306a\u306e\u306f\u307e\u3042\u305d\u3046\u304b\u3068\u3044\u3046\u611f\u3058.\n\u6642\u9593\u304c10\u5206\u3061\u3087\u3044\u3067\u7d42\u308f\u308b,heap\u306e\u4f38\u9577\u3092\u6291\u3048\u3089\u308c\u308b\u3068\u3053\u3093\u306a\u306b\u9055\u3046\u306e\u304b.\n2.5\u304c\u7d42\u308f\u308a.\u3053\u3093\u306a\u611f\u3058\u3067\u5c0f\u3055\u3044\u6a5f\u80fd\u3092\u3061\u3087\u3063\u3068\u3065\u3064\u8db3\u3057\u3066\u3044\u304f\u611f\u3058\u307d\u3044?\ndiff\u53d6\u3063\u305f\u3084\u30fc\u3064\n\nMain.hs\ndiff --git a/Main.hs b/Main.hs\nindex 8509f0d..651f971 100644\n--- a/Main.hs\n+++ b/Main.hs\n@@ -84,25 +84,29 @@ numStep state n = error \"Number applied as a function!\"\n apStep :: TiState -> Addr -> Addr -> TiState\n apStep (stack, dump, heap, globals, stats) a1 a2 = (a1 : stack, dump, heap, globals, (s, r, if d < length stack + 1 then d + 1 else d)) where (s, r, d) = stats\n\n-indStep :: TiState -> addr -> TiState\n+indStep :: TiState -> Addr -> TiState\n indStep (stack, dump, heap, globals, stats) addr = (addr : (tail stack), dump, heap, globals, stats)\n\n scStep :: TiState -> Name -> [Name] -> CoreExpr -> TiState\n scStep (stack, dump, heap, globals, stats) sc_name arg_names body\n     = (new_stack, dump, new_heap, globals, new_stats)\n     where\n-        new_stack = if length arg_names + 1 <= length stack then result_addr : (drop (length arg_names + 1) stack) else error \"too few arguments\"\n-        (new_heap, result_addr) = instantiate body heap env\n-        env = arg_bindings ++ globals\n-        arg_bindings = zip arg_names (getargs heap stack)\n-        new_stats = (s, if elem sc_name [prim | (prim, _, _) <- preludeDefs] then (rsc, rp + 1) else (rsc + 1, rp), d) where (s, (rsc, rp), d) = stats\n+    new_stack = if length arg_names + 1 <= length stack then result_addr : (drop (length arg_names + 1) stack) else error \"too few arguments\"\n+    upd_addr = head (drop (length arg_names) stack) -- stack[n] == a_n for p65 (2.3)\n+    --(new_heap, result_addr) = instantiate body heap env\n+    new_heap = instantiateAndUpdate body upd_addr heap env\n+    result_addr = upd_addr\n+    env = arg_bindings ++ globals\n+    arg_bindings = zip arg_names (getargs heap stack)\n+    new_stats = (s, if elem sc_name [prim | (prim, _, _) <- preludeDefs] then (rsc, rp + 1) else (rsc + 1, rp), d) where (s, (rsc, rp), d) = stats\n\n -- now getargs since getArgs conflicts with Gofer standard.prelude\n getargs :: TiHeap -> TiStack -> [Addr]\n getargs heap (sc:stack) = map get_arg stack\n     where get_arg addr = arg where (NAp fun arg) = hLookup heap addr\n\n-instantiate :: CoreExpr -- Body of supercombinator\n+instantiate\n+    :: CoreExpr -- Body of supercombinator\n     -> TiHeap -- Heap before instantiation\n     -> ASSOC Name Addr -- Association of names to addresses\n     -> (TiHeap, Addr) -- Heap after instantiation, and\n@@ -127,7 +131,7 @@ instantiateLet isrec defs body heap env = instantiate body new_heap new_env -- c\n         where\n         (heap1, a1) = instantiate expr heap (if isrec then new_env else env)\n -- \u6b63\u683c\u8a55\u4fa1\u3060\u3068map\u306e\u4e2d\u3067\u306einstantiate\u306e\u4e2d\u306eEVar\u306e\u51fa\u73fe\u3092\u30de\u30fc\u30af\u3057\u3066bind\u306e\u4e2d\u306b\u305d\u306e\u8b58\u5225\u5b50\u304c\u3042\u308b\u304b\u3069\u3046\u304b\u3092\u8abf\u3079,\u6709\u3063\u305f\u3089addr=-index\u306a\u3069\u3069\u3057\u3066\u304a\u304d,\u5168\u3066\u306erhss\u306einstantiate\u304c\u7d42\u308f\u3063\u305f\u3089addr\u304c\u8ca0\u306b\u306a\u3063\u3066\u3044\u308b\u6240\u3092\u5b9f\u969b\u306eaddr\u306b\u76f4\u3059,?\n--- instantiate\u306e\u578b\u304c\u5909\u308f\u308b\u3088\u307f\u305f\u3044\u306a.isrec\u3068bind\u3092\u5f15\u5efb\u306a\u3055\u306a\u3044\u3068\u3044\u3051\u306a\u3044\n+-- instantiate\u306e\u578b\u304c\u5909\u308f\u308b\u3088\u307f\u305f\u3044\u306a.isrec\u3068bind\u3092\u5f15\u5efb\u3055\u306a\u3044\u3068\u3044\u3051\u306a\u3044\n {-\n instantiateLet isrec defs body heap env = instantiate body new_heap new_env --error \"Can't instantiate let(rec)s yet\"\n     where\n@@ -143,7 +147,8 @@ getrhss isrec rhss heap env = (new_heap, result_addr)\n         where (new_heap, result_addr) = instantiate expr heap env\n -}\n\n-instantiateAndUpdate :: CoreExpr -- Body of supercombinator\n+instantiateAndUpdate\n+    :: CoreExpr -- Body of supercombinator\n     -> Addr\n     -> TiHeap\n     -> ASSOC Name Addr\n@@ -154,24 +159,29 @@ instantiateAndUpdate (EAp e1 e2) upd_addr heap env = hUpdate heap2 upd_addr (NAp\n     where\n     (heap1, a1) = instantiate e1 heap env\n     (heap2, a2) = instantiate e2 heap1 env\n---instantiateAndUpdate (EVar v) upd_addr heap env = (heap, aLookup env v (error (\"Undefined name \" ++ show v)))\n-instantiateAndUpdate (EVar v) upd_addr heap env = hUpdate heap (aLookup env v (error (\"Undefined name \" ++ show v)))\n+instantiateAndUpdate (EVar v) upd_addr heap env = hUpdate heap upd_addr (NInd (aLookup env v (error (\"Undefined name \" ++ show v))))\n instantiateAndUpdate (EConstr tag arity) upd_addr heap env = instantiateAndUpdateConstr tag arity upd_addr heap env\n-instantiateAndUpdate (ELet isrec defs body) upd_addr heap env = instantiateAndUpdateLet isrec defs body heap env\n+instantiateAndUpdate (ELet isrec defs body) upd_addr heap env = instantiateAndUpdateLet isrec defs body upd_addr heap env\n instantiateAndUpdate (ECase e alts) upd_addr heap env = error \"Can't instantiate case exprs\"\n\n instantiateAndUpdateConstr tag arity upd_addr heap env = error \"Can't instantiate constructors yet\"\n\n-instantiateAndUpdateLet isrec defs body upd_addr heap env = error \"Can't instantiate let(rec)s yet\"\n+instantiateAndUpdateLet isrec defs body upd_addr heap env = instantiateAndUpdate body upd_addr new_heap new_env\n+    where\n+    ((new_heap, new_env), result_addr) = mapAccumR f (heap, env) defs\n+    f (heap, env) (name, expr) = ((heap1, (name, a1) : env), a1)\n+        where\n+        (heap1, a1) = instantiate expr heap (if isrec then new_env else env)\n\n showResults :: [TiState] -> String\n-showResults states = iDisplay (iConcat [ iLayn (map showState states), showStats (last states) ])\n+--showResults states = iDisplay ( iConcat [ iLayn (map showState states), showStats (last states) ])\n+showResults states = iDisplay ( iConcat [ showState (last states), showStats (last states) ])\n\n showState :: TiState -> Iseq\n showState (stack, dump, heap, globals, stats)\n     = iConcat [\n-        showStack heap stack, iNewline ,\n-        showHeap heap, iNewline\n+        showStack heap stack, iNewline --,\n+ --       showHeap heap, iNewline\n     ]\n\n showHeap :: TiHeap -> Iseq\n@@ -243,10 +253,6 @@ showStats (stack, dump, heap, globals, stats)\n     ]\n\n main :: IO ()\n-main = putStrLn $ runProg $ \"main = letrec x = x f in x; x = 5; two = S C I; inc = S C; three = inc two; add = C S (C C); mul = C\"\n+main = putStrLn $ runProg $ \"main = W C (W C) (W C) (W C) I 3\"\n+--main = putStrLn $ runProg $ \"main = letrec x = x f in x; x = 5; two = S C I; inc = S C; three = inc two; add = C S (C C); mul = C\"\n --main = putStrLn $ runProg $ \"pair x y f =f x y ; fst p = p K ; snd p= p F; f x y = letrec a = pair x b ; b = pair y a in fst (snd (snd (snd a))) ; main = f 3 4\"\n---main = putStrLn $ iDisplay $ pprExpr (ELet nonRecursive [(\"att\", ENum 2)] (EAp (EAp (EVar \"+\") (EVar \"att\")) (EVar \"1\")))\n---main = putStrLn( pprint $ parse  \"f=3;\\ng x y = let z = x in z ;\\nh x = case (let y = x in y) of\\n<1> -> 2 ;\\n<2> -> 5;\\n i = g (1 + 2 * 3) (5 - 1 / 2)\")\n---main = putStrLn $ show $ pOneOrMoreWithSep (pLit \"x\") (pLit \";\") [(1,\"x\"),(1,\";\"),(1,\"x\") ,(1,\";\"),(2,\"x\"),(2,\";\"),(2,\"x\"),(2,\";\"),(2,\"x\") ]\n---main = putStrLn $ show $ pExpr [(2,\"let\"),(2,\"z\"),(2,\"=\"),(2,\"x\"),(2,\"in\"),(2,\"z\")]\n---main = putStrLn $ pprint $ syntax [(1,\"f\"),(1,\"=\"),(1,\"3\") ,(1,\";\"),(2,\"g\"),(2,\"x\"),(2,\"y\"),(2,\"=\"), (2,\"let\"),(2,\"z\"),(2,\"=\"),(2,\"x\"),(2,\"in\"),(2,\"z\"),(2,\";\"),(3,\"h\"),(3,\"x\"),(3,\"=\"),(3,\"case\"),(3,\"(\"),(3,\"let\"),(3,\"y\"),(3,\"=\"),(3,\"x\"),(3,\"in\"),(3,\"y\"),(3,\")\"),(3,\"of\"),(4,\"<\"),(4,\"1\"),(4,\">\"),(4,\"->\"),(4,\"2\"),(4,\";\"),(5,\"<\"),(5,\"2\"),(5,\">\"),(5,\"->\"),(5,\"5\")]\n\n\n# 19\u65e5\u76ee\n\u4e45\u3057\u3076\u308a\u306b\u66f8\u304f.\n\u864e\u672c\u304c_instantiation_\u3092\u5b9f\u4f53\u3068\u8a33\u3057\u3066\u3044\u305f\u306e\u3067,_instantiate_\u3092\u3053\u308c\u304b\u3089\u5b9f\u4f53\u5316\u3068\u66f8\u304f\u3053\u3068\u306b\u3059\u308b.\n\n## 2.5 Mark 3: Adding updating\n\u4eca\u307e\u3067\u306e\u30de\u30b7\u30f3\u306f\u30b0\u30e9\u30d5\u306e\u66f4\u65b0\u3092\u3057\u3066\u3044\u306a\u304b\u3063\u305f\u306e\u3067,\u540c\u3058\u90e8\u5206\u5f0f\u306e\u51fa\u73fe\u306b\u5bfe\u30572\u56de\u8a08\u7b97\u3092\u3055\u305b\u3066\u3044\u305f.\n\u4f8b\u3048\u3070,\n\n```\nW x y = x y y\nmain = W I (K I I) 0\n```\n\n\u306a\u3069.\n\u3053\u306e\u6642,main\u306f`W I (K I I) (K I I) 0`\u3068\u5c55\u958b\u3055\u308c\u308b\u308f\u3051\u3060\u304c,W\u306e\u5f15\u6570\u306e(K I I)\u306f\u540c\u3058\u5834\u6240\u3092\u53c2\u7167\u3057\u3066\u3044\u308b\u306e\u3067,\u6700\u521d\u306e(K I I)\u3092\u5b9f\u4f53\u5316\u3057\u305f\u6642\u306b\u7d50\u679c\u304c\u308f\u304b\u308a,\u4e8c\u56de\u76ee\u306e(K I I)\u306e\u5b9f\u4f53\u5316\u306f\u305d\u306e\u7d50\u679c\u3092\u4f7f\u7528\u3059\u308b\u3053\u3068\u304c\u3067\u304d\u308b.\n\u3053\u308c\u306f\u3053\u306e\u8a00\u8a9e\u304c\u7d14\u7c8b\u3060\u304b\u3089\u3067\u304d\u308b.\n\n\u3053\u308c\u3092\u89e3\u6c7a\u3059\u308b\u305f\u3081,\u9593\u63a5\u53c2\u7167\u30ce\u30fc\u30c9,(NInd Addr)\u578b\u3092\u8ffd\u52a0\u3059\u308b.\n\u6700\u521d\u306e\u5b9f\u4f53\u5316\u306e\u3068\u304d\u306b,root\u306e\u53c2\u7167\u5148\u3092(NInd \u5b9f\u4f53\u5148\u30a2\u30c9\u30ec\u30b9)\u3067\u66f4\u65b0\u3059\u308b\u3053\u3068\u306b\u3088\u308a,\u4f59\u8a08\u306a\u8a08\u7b97\u3092\u7701\u304f.\n\u307e\u305f,NInd\u578b\u306b\u5bfe\u5fdc\u3059\u308b\u305f\u3081,\u30b9\u30c6\u30fc\u30c8\u30de\u30b7\u30f3\u306b\u65b0\u3057\u3044\u30eb\u30fc\u30eb\u3092\u8ffd\u52a0\u3059\u308b.\n\nExercise\u3067\u52b9\u679c\u3092\u6e2c\u5b9a\u3057\u308d\u3068\u4f1a\u3063\u305f\u306e\u3067, `main = main = W C (W C) (W C) (W C) I 3`\u3092\u8a08\u7b97\u3055\u305b\u308b.\n\u5358\u7d14\u8a08\u7b97\u30672^16\u56de,\u5373\u306165536\u56deI\u30923\u306b\u9069\u7528\u3059\u308b.\n\n```:\u7d50\u679c\u3068\u5b9f\u884c\u6642\u9593.NInd\u306a\u3057\nStack [ (top)\n  17: NNum 3\n]\n\n\nTotal number of steps = 805726\nTotal number of reductions = 258295\nTotal number of supercombinator reductions = 1\nTotal number of primitive reductions = 258294\nMaximum of stack depth = 7\n\nreal    215m43.150s\nuser    215m1.582s\nsys     0m1.637s\n```\n\n```:\u7d50\u679c.NInd\u3042\u308a\nStack [ (top)\n  17: NNum 3\n]\n\n\nTotal number of steps = 485349\nTotal number of reductions = 131114\nTotal number of supercombinator reductions = 1\nTotal number of primitive reductions = 131113\nMaximum of stack depth = 7\n\nreal    49m10.059s\nuser    48m59.786s\nsys     0m0.423s\n```\n\n\u6700\u5f8c\u306b\u307e\u3068\u3081\u3066\u8868\u306b\u3057\u305f\u3082\u306e\u3092\u51fa\u3059\u304c,NInd\u3042\u308a\u306e\u65b9\u306f\u30b9\u30c6\u30c3\u30d7\u6570\u304c60%,\u7c21\u7d04\u306e\u6570\u304c50%\u306b\u306a\u3063\u3066\u3044\u3066,\u6642\u9593\u306f25%\u3068\u9ad8\u901f\u306b\u306a\u3063\u3066\u3044\u308b.\nNInd\u306e \u3061\u304b\u3089\u3063\u3066 \u3059\u3052\u30fc!\n\n### 2.5.1 Reducing the number of indirections\n\u4eca\u56de,\u65b0\u3057\u304finstantiate\u3055\u308c\u305f\u3068\u304d\u306bNInd\u3092\u4f7f\u3063\u3066\u66f4\u65b0\u3057\u305f\u304c,\u76f4\u63a5\u66f4\u65b0\u3067\u304d\u308b\u5834\u5408\u3082\u3042\u308b.\nredex\u306eroot\u306e\u9802\u70b9\u306f\u76f4\u63a5\u7d50\u679c\u3067\u7f6e\u304d\u63db\u3048\u308b\u3053\u3068\u304c\u3067\u304d\u308b.\n\u4f55\u6545\u306a\u3089,root\u306e\u9802\u70b9\u3092\u5b9f\u4f53\u5316\u3057\u305f\u7d50\u679c\u306f\u65b0\u3057\u304f\u4f5c\u308a\u51fa\u3055\u308c\u308b\u3082\u306e\u3067\u3042\u308a,\u3053\u306e\u66f4\u65b0\u3092\u3059\u308b\u3053\u3068\u306b\u3088\u3063\u3066\u5931\u308f\u308c\u308b\u3088\u3046\u306a\u5171\u6709\u7269\u306f\u306a\u3044\u3057(no sharing can be lost by doing this),\u307e\u305f,\u3055\u3089\u306a\u308b\u30ce\u30fc\u30c9\u3092\u4f5c\u308a\u51fa\u3059\u306e\u3092\u6291\u3048\u308b\u3053\u3068\u304c\u3067\u304d\u308b.\n\n\u4eca\u307e\u3067\u306f\u30b0\u30e9\u30d5\u3092update,\u66f4\u65b0\u3057\u3066\u3044\u306a\u304b\u3063\u305f\u304c,\u66f4\u65b0\u3059\u308b\u3053\u3068\u306b\u3088\u3063\u3066\u9ad8\u901f\u5316\u3067\u304d\u308b.\nhAlloc\u3057\u304b\u4f7f\u3063\u3066\u3044\u306a\u304b\u3063\u305f\u306e\u3067,\u5b9f\u4f53\u5316\u3059\u308b\u305f\u3073\u306b\u65b0\u3057\u3044node\u3092\u78ba\u4fdd\u3057\u3066\u3044\u305f.\n\u3057\u304b\u3082gc\u306a\u3093\u3066\u7121\u3044\u306e\u3067,\u78ba\u4fdd\u3057\u305f\u3089\u78ba\u4fdd\u3057\u3063\u3071\u306a\u3057\u3067,\u3069\u3093\u3069\u3093\u306e\u30d2\u30fc\u30d7\u304c\u4f38\u3073\u308b.\n\u3053\u308c\u306f,heap\u306e\u691c\u7d22\u3092\u3059\u308b\u3068\u304d\u306b\u5927\u5e45\u306b\u30dc\u30c8\u30eb\u30cd\u30c3\u30af\u306b\u306a\u308b.\n(Lookup\u7cfb\u306e\u95a2\u6570\u306f\u30ea\u30cb\u30a2\u30b5\u30fc\u30c1)\n\n` instantiateAndUpdate`\u3068\u3044\u3046\u95a2\u6570\u3092\u4f7f\u3063\u3066update\u3059\u308b.\nexercise 2.14\u3067\u3053\u306e\u5b9a\u7fa9\u3092\u5b8c\u6210\u3055\u305b\u3088\u3068\u304b\u3042\u308b\u3051\u3069,\u307e\u3042\u524d\u306einstantiate\u3092\u30b3\u30d4\u308b\u3060\u3051.\n\u6ce8\u610f\u3068\u3057\u3066,update\u3067\u304d\u308b\u306e\u306froot\u3060\u3051\u306a\u306e\u3067,\u518d\u5e30\u3059\u308b\u65b9\u306f\u6614\u306einstantiate\u3092\u4f7f\u308f\u306a\u3044\u3068\u3044\u3051\u306a\u3044.\n\u5909\u6570\u306fNInd\u304c\u5fc5\u8981\u3067\u3042\u308b.\u4f55\u6545\u304b?\n\u2192 hUpdate\u306f\u5f15\u6570\u306bNode\u578b\u3092\u53d6\u308b\u304c,aLookup\u3067\u898b\u3064\u304b\u308b\u675f\u7e1b\u306fAddress\u306e\u305f\u3081,NInd\u3067\u30e9\u30c3\u30d7\u3059\u308b\u5fc5\u8981\u304c\u3042\u308b\u304b\u3089.\n\u6ce8\u610f\u3057\u3066let(rec)\u3092\u5b9f\u88c5\u305b\u3088\u3068\u304b\u66f8\u3044\u3066\u3042\u3063\u305f\u3051\u3069,\u675f\u7e1b\u3092\u4f5c\u308b\u3068\u304d\u306f\u3069\u3046\u3057\u3066\u3082\u65b0\u3057\u3044\u30ce\u30fc\u30c9\u304c\u5fc5\u8981\u306a\u306e\u3067,body\u3092\u5b9f\u4f53\u5316\u3059\u308b\u3068\u304d\u3060\u3051Update\u3059\u308b\u3088\u3046\u306b\u3057\u305f.\n\u4e0a\u624b\u304f\u3044\u3063\u3066\u308b\u306e\u3067\u3053\u308c\u3067\u826f\u3057\u3068\u3059\u308b.\n\n2.5\u306e\u30d9\u30f3\u30c1\u30de\u30fc\u30af\u3092\u3053\u306e\u5909\u66f4\u5f8c\u306b\u3082\u3046\u4e00\u5ea6\u3084\u3063\u3066\u307f\u308b\n\n```:\u7d50\u679c.Update\u3042\u308a\nStack [ (top)\n  17: NNum 3\n]\n\n\nTotal number of steps = 485349\nTotal number of reductions = 131114\nTotal number of supercombinator reductions = 1\nTotal number of primitive reductions = 131113\nMaximum of stack depth = 7\n\nreal    10m28.507s\nuser    10m27.380s\nsys     0m0.133s\n```\n\n\u307e\u3042let(rec)\u3082\u4f7f\u308f\u306a\u3044\u305f\u3060\u306e\u7c21\u7d04\u3060\u3051\u306a\u306e\u3067,\u4e0a\u306e\u7d50\u679c\u304c\u540c\u3058\u306a\u306e\u306f\u307e\u3042\u305d\u3046\u304b\u3068\u3044\u3046\u611f\u3058.\n\u6642\u9593\u304c10\u5206\u3061\u3087\u3044\u3067\u7d42\u308f\u308b,heap\u306e\u4f38\u9577\u3092\u6291\u3048\u3089\u308c\u308b\u3068\u3053\u3093\u306a\u306b\u9055\u3046\u306e\u304b.\n\n***2.5\u304c\u7d42\u308f\u308a.\u3053\u3093\u306a\u611f\u3058\u3067\u5c0f\u3055\u3044\u6a5f\u80fd\u3092\u3061\u3087\u3063\u3068\u3065\u3064\u8db3\u3057\u3066\u3044\u304f\u611f\u3058\u307d\u3044?***\n\ndiff\u53d6\u3063\u305f\u3084\u30fc\u3064\n\n```hs:Main.hs\ndiff --git a/Main.hs b/Main.hs\nindex 8509f0d..651f971 100644\n--- a/Main.hs\n+++ b/Main.hs\n@@ -84,25 +84,29 @@ numStep state n = error \"Number applied as a function!\"\n apStep :: TiState -> Addr -> Addr -> TiState\n apStep (stack, dump, heap, globals, stats) a1 a2 = (a1 : stack, dump, heap, globals, (s, r, if d < length stack + 1 then d + 1 else d)) where (s, r, d) = stats\n \n-indStep :: TiState -> addr -> TiState\n+indStep :: TiState -> Addr -> TiState\n indStep (stack, dump, heap, globals, stats) addr = (addr : (tail stack), dump, heap, globals, stats)\n \n scStep :: TiState -> Name -> [Name] -> CoreExpr -> TiState\n scStep (stack, dump, heap, globals, stats) sc_name arg_names body\n     = (new_stack, dump, new_heap, globals, new_stats)\n     where\n-        new_stack = if length arg_names + 1 <= length stack then result_addr : (drop (length arg_names + 1) stack) else error \"too few arguments\"\n-        (new_heap, result_addr) = instantiate body heap env\n-        env = arg_bindings ++ globals\n-        arg_bindings = zip arg_names (getargs heap stack)\n-        new_stats = (s, if elem sc_name [prim | (prim, _, _) <- preludeDefs] then (rsc, rp + 1) else (rsc + 1, rp), d) where (s, (rsc, rp), d) = stats\n+    new_stack = if length arg_names + 1 <= length stack then result_addr : (drop (length arg_names + 1) stack) else error \"too few arguments\"\n+    upd_addr = head (drop (length arg_names) stack) -- stack[n] == a_n for p65 (2.3)\n+    --(new_heap, result_addr) = instantiate body heap env\n+    new_heap = instantiateAndUpdate body upd_addr heap env\n+    result_addr = upd_addr\n+    env = arg_bindings ++ globals\n+    arg_bindings = zip arg_names (getargs heap stack)\n+    new_stats = (s, if elem sc_name [prim | (prim, _, _) <- preludeDefs] then (rsc, rp + 1) else (rsc + 1, rp), d) where (s, (rsc, rp), d) = stats\n \n -- now getargs since getArgs conflicts with Gofer standard.prelude\n getargs :: TiHeap -> TiStack -> [Addr]\n getargs heap (sc:stack) = map get_arg stack\n     where get_arg addr = arg where (NAp fun arg) = hLookup heap addr\n \n-instantiate :: CoreExpr -- Body of supercombinator\n+instantiate\n+    :: CoreExpr -- Body of supercombinator\n     -> TiHeap -- Heap before instantiation\n     -> ASSOC Name Addr -- Association of names to addresses\n     -> (TiHeap, Addr) -- Heap after instantiation, and\n@@ -127,7 +131,7 @@ instantiateLet isrec defs body heap env = instantiate body new_heap new_env -- c\n         where\n         (heap1, a1) = instantiate expr heap (if isrec then new_env else env)\n -- \u6b63\u683c\u8a55\u4fa1\u3060\u3068map\u306e\u4e2d\u3067\u306einstantiate\u306e\u4e2d\u306eEVar\u306e\u51fa\u73fe\u3092\u30de\u30fc\u30af\u3057\u3066bind\u306e\u4e2d\u306b\u305d\u306e\u8b58\u5225\u5b50\u304c\u3042\u308b\u304b\u3069\u3046\u304b\u3092\u8abf\u3079,\u6709\u3063\u305f\u3089addr=-index\u306a\u3069\u3069\u3057\u3066\u304a\u304d,\u5168\u3066\u306erhss\u306einstantiate\u304c\u7d42\u308f\u3063\u305f\u3089addr\u304c\u8ca0\u306b\u306a\u3063\u3066\u3044\u308b\u6240\u3092\u5b9f\u969b\u306eaddr\u306b\u76f4\u3059,?\n--- instantiate\u306e\u578b\u304c\u5909\u308f\u308b\u3088\u307f\u305f\u3044\u306a.isrec\u3068bind\u3092\u5f15\u5efb\u306a\u3055\u306a\u3044\u3068\u3044\u3051\u306a\u3044\n+-- instantiate\u306e\u578b\u304c\u5909\u308f\u308b\u3088\u307f\u305f\u3044\u306a.isrec\u3068bind\u3092\u5f15\u5efb\u3055\u306a\u3044\u3068\u3044\u3051\u306a\u3044\n {-\n instantiateLet isrec defs body heap env = instantiate body new_heap new_env --error \"Can't instantiate let(rec)s yet\"\n     where\n@@ -143,7 +147,8 @@ getrhss isrec rhss heap env = (new_heap, result_addr)\n         where (new_heap, result_addr) = instantiate expr heap env\n -}\n \n-instantiateAndUpdate :: CoreExpr -- Body of supercombinator\n+instantiateAndUpdate\n+    :: CoreExpr -- Body of supercombinator\n     -> Addr\n     -> TiHeap\n     -> ASSOC Name Addr\n@@ -154,24 +159,29 @@ instantiateAndUpdate (EAp e1 e2) upd_addr heap env = hUpdate heap2 upd_addr (NAp\n     where\n     (heap1, a1) = instantiate e1 heap env\n     (heap2, a2) = instantiate e2 heap1 env\n---instantiateAndUpdate (EVar v) upd_addr heap env = (heap, aLookup env v (error (\"Undefined name \" ++ show v)))\n-instantiateAndUpdate (EVar v) upd_addr heap env = hUpdate heap (aLookup env v (error (\"Undefined name \" ++ show v)))\n+instantiateAndUpdate (EVar v) upd_addr heap env = hUpdate heap upd_addr (NInd (aLookup env v (error (\"Undefined name \" ++ show v))))\n instantiateAndUpdate (EConstr tag arity) upd_addr heap env = instantiateAndUpdateConstr tag arity upd_addr heap env\n-instantiateAndUpdate (ELet isrec defs body) upd_addr heap env = instantiateAndUpdateLet isrec defs body heap env\n+instantiateAndUpdate (ELet isrec defs body) upd_addr heap env = instantiateAndUpdateLet isrec defs body upd_addr heap env\n instantiateAndUpdate (ECase e alts) upd_addr heap env = error \"Can't instantiate case exprs\"\n \n instantiateAndUpdateConstr tag arity upd_addr heap env = error \"Can't instantiate constructors yet\"\n \n-instantiateAndUpdateLet isrec defs body upd_addr heap env = error \"Can't instantiate let(rec)s yet\"\n+instantiateAndUpdateLet isrec defs body upd_addr heap env = instantiateAndUpdate body upd_addr new_heap new_env\n+    where\n+    ((new_heap, new_env), result_addr) = mapAccumR f (heap, env) defs\n+    f (heap, env) (name, expr) = ((heap1, (name, a1) : env), a1)\n+        where\n+        (heap1, a1) = instantiate expr heap (if isrec then new_env else env)\n \n showResults :: [TiState] -> String\n-showResults states = iDisplay (iConcat [ iLayn (map showState states), showStats (last states) ])\n+--showResults states = iDisplay ( iConcat [ iLayn (map showState states), showStats (last states) ])\n+showResults states = iDisplay ( iConcat [ showState (last states), showStats (last states) ])\n \n showState :: TiState -> Iseq\n showState (stack, dump, heap, globals, stats)\n     = iConcat [\n-        showStack heap stack, iNewline ,\n-        showHeap heap, iNewline\n+        showStack heap stack, iNewline --,\n+ --       showHeap heap, iNewline\n     ]\n \n showHeap :: TiHeap -> Iseq\n@@ -243,10 +253,6 @@ showStats (stack, dump, heap, globals, stats)\n     ]\n \n main :: IO ()\n-main = putStrLn $ runProg $ \"main = letrec x = x f in x; x = 5; two = S C I; inc = S C; three = inc two; add = C S (C C); mul = C\"\n+main = putStrLn $ runProg $ \"main = W C (W C) (W C) (W C) I 3\"\n+--main = putStrLn $ runProg $ \"main = letrec x = x f in x; x = 5; two = S C I; inc = S C; three = inc two; add = C S (C C); mul = C\"\n --main = putStrLn $ runProg $ \"pair x y f =f x y ; fst p = p K ; snd p= p F; f x y = letrec a = pair x b ; b = pair y a in fst (snd (snd (snd a))) ; main = f 3 4\"\n---main = putStrLn $ iDisplay $ pprExpr (ELet nonRecursive [(\"att\", ENum 2)] (EAp (EAp (EVar \"+\") (EVar \"att\")) (EVar \"1\")))\n---main = putStrLn( pprint $ parse  \"f=3;\\ng x y = let z = x in z ;\\nh x = case (let y = x in y) of\\n<1> -> 2 ;\\n<2> -> 5;\\n i = g (1 + 2 * 3) (5 - 1 / 2)\")\n---main = putStrLn $ show $ pOneOrMoreWithSep (pLit \"x\") (pLit \";\") [(1,\"x\"),(1,\";\"),(1,\"x\") ,(1,\";\"),(2,\"x\"),(2,\";\"),(2,\"x\"),(2,\";\"),(2,\"x\") ]\n---main = putStrLn $ show $ pExpr [(2,\"let\"),(2,\"z\"),(2,\"=\"),(2,\"x\"),(2,\"in\"),(2,\"z\")]\n---main = putStrLn $ pprint $ syntax [(1,\"f\"),(1,\"=\"),(1,\"3\") ,(1,\";\"),(2,\"g\"),(2,\"x\"),(2,\"y\"),(2,\"=\"), (2,\"let\"),(2,\"z\"),(2,\"=\"),(2,\"x\"),(2,\"in\"),(2,\"z\"),(2,\";\"),(3,\"h\"),(3,\"x\"),(3,\"=\"),(3,\"case\"),(3,\"(\"),(3,\"let\"),(3,\"y\"),(3,\"=\"),(3,\"x\"),(3,\"in\"),(3,\"y\"),(3,\")\"),(3,\"of\"),(4,\"<\"),(4,\"1\"),(4,\">\"),(4,\"->\"),(4,\"2\"),(4,\";\"),(5,\"<\"),(5,\"2\"),(5,\">\"),(5,\"->\"),(5,\"5\")]\n```\n", "tags": ["\u30a4\u30f3\u30d7\u30ea\u30e1\u30f3\u30c6\u30a3\u30f3\u30b0\u30d5\u30a1\u30f3\u30af\u30b7\u30e7\u30ca\u30eb\u30e9\u30f3\u30b2\u30fc\u30b8\u30ba"]}