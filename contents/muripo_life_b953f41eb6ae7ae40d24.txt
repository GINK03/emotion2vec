{"context": "modeling with distance functions\u306e\u8ddd\u96e2\u95a2\u6570\u306e\u4e00\u89a7\u306b\u6cbf\u3063\u3066\u8a18\u4e8b\u3092\u66f8\u3044\u3066\u3044\u307e\u3059.\n\nCylinder\u306e\u6570\u5f0f\u306f\nS(u,v) = \n\\begin{pmatrix}\n(c_x + r \\cos u)  \\\\\nh  \\\\\n(c_z + r \\sin u)\n\\end{pmatrix}\n\\\\\n (0<h,r), h:\u9ad8\u3055,r:\u534a\u5f84,\\\\\nc_x:\u5186\u306e\u4e2d\u5fc3\u306ex\u5ea7\u6a19\u3001c_z:\u5186\u306e\u4e2d\u5fc3\u306ez\u5ea7\u6a19\nS(u,v)=((cx+rcosu)h(cz+rsinu))(0<h,r),h:\u9ad8\u3055,r:\u534a\u5f84,cx:\u5186\u306e\u4e2d\u5fc3\u306ex\u5ea7\u6a19\u3001cz:\u5186\u306e\u4e2d\u5fc3\u306ez\u5ea7\u6a19{S(u,v) = \n\\begin{pmatrix}\n(c_x + r \\cos u)  \\\\\nh  \\\\\n(c_z + r \\sin u)\n\\end{pmatrix}\n\\\\\n (0<h,r), h:\u9ad8\u3055,r:\u534a\u5f84,\\\\\nc_x:\u5186\u306e\u4e2d\u5fc3\u306ex\u5ea7\u6a19\u3001c_z:\u5186\u306e\u4e2d\u5fc3\u306ez\u5ea7\u6a19\n}\n\nx,y,z\u306e\u8868\u8a18\u306b\u76f4\u3059\u3068(\u8ddd\u96e2\u95a2\u6570\u306e\u8868\u8a18\u306b\u76f4\u3059\u3068)\n\\begin{align}\nx &= (c_x + r \\cos u) \\\\\ny &= h \\\\\nz &= (c_z + r \\sin u)\n\\end{align}\nx=(cx+rcosu)y=hz=(cz+rsinu){\\begin{align}\nx &= (c_x + r \\cos u) \\\\\ny &= h \\\\\nz &= (c_z + r \\sin u)\n\\end{align}\n}\n\u3088\u3063\u3066,\n(x-c_x)^2 + (z-c_z)^2 = r^2\n(x\u2212cx)2+(z\u2212cz)2=r2{(x-c_x)^2 + (z-c_z)^2 = r^2\n}\n\u306a\u306e\u3067\u3001\n\\sqrt{(x-c_x)^2 + (z-c_z)^2} - r \\\\\ny=h\n\u221a(x\u2212cx)2+(z\u2212cz)2\u2212ry=h{\\sqrt{(x-c_x)^2 + (z-c_z)^2} - r \\\\\ny=h\n}\n\u3067\u3059.\n\u30b3\u30fc\u30c9\u306e\u8868\u8a18\u306b\u76f4\u3059\u3068\u4ee5\u4e0b\nvec3 c = vec3(\u3010\u5186\u67f1\u306e\u5186\u306e\u4e2d\u5fc3\u306ex\u5ea7\u6a19\u3011,\u3010\u5186\u67f1\u306e\u5186\u306e\u4e2d\u5fc3\u306ez\u5ea7\u6a19\u3011,\u3010\u5186\u67f1\u306e\u534a\u5f84\u3011);\nreturn sqrt((p.x-c.x)*(p.x-c.x)+(p.z-c.y)*(p.z-c.y))-c.z;\n\n\nlength() \u95a2\u6570\u3092\u7528\u3044\u308b\u3068\nvec3 c = vec3(0.0,0.0,1.0);\nreturn length(p.xz-c.xy)-c.z;\n\n\n\n\u95a2\u6570\u3092\u3044\u3058\u3063\u3066\u904a\u3076\n\n\u7403\u6839\n// \u7403\u6839\nvec3 c = vec3(0.0, 0.0,1.0);\nreturn sqrt((p.x-c.x)*(p.x-c.x)+(p.z-c.y)*(p.z-c.y))+p.y*p.y-c.z;\n\n\n\n\u90e8\u5c4b\u3063\u307d\u3044\u3084\u3064\n// \u90e8\u5c4b\u3063\u307d\u3044\u3084\u3064\nvec3 c = vec3(0.0, 0.0,1.0);\nreturn sqrt((p.x-c.x)*(p.x-c.x)+(p.z-c.y)*(p.z-c.y))-p.y*p.y*0.2-c.z;\n\n\n\n\u30bf\u30f3\u30af\n// \u30bf\u30f3\u30af\nvec3 c = vec3(0.0,0.0,1.0);\nreturn sqrt((p.x-c.x)*(p.x-c.x)+(p.z-c.y)*(p.z-c.y))+p.y*p.y*p.y*p.y-c.z;\n\n\n\n\u30a2\u30cb\u30e1\u30fc\u30b7\u30e7\u30f3\n// \u30a2\u30cb\u30e1\u30fc\u30b7\u30e7\u30f32\nvec3 c = vec3(0.0,0.0,1.0);\nreturn sqrt((p.x-c.x)*(p.x-c.x)+(p.z-c.y)*(p.z-c.y))+p.y*p.y*(sin(time))-c.z;\n\n\n\n\u30bd\u30fc\u30b9\u30b3\u30fc\u30c9\n// ============================================================================\n// Cylinder function\n// ============================================================================\n\nprecision mediump float;\nuniform vec2  resolution;    // resolution (512.0, 512.0)\nuniform vec2  mouse;         // mouse      (-1.0 ~ 1.0)\nuniform float time;          // time       (1second == 1.0)\nuniform sampler2D prevScene; // previous scene texture\n\n// Cylinder\u306e\u8ddd\u96e2\u95a2\u6570\nfloat dCylinder(vec3 p){\n    // cylinder\u306e\u8ddd\u96e2\u95a2\u6570\n    vec3 c = vec3(0.0,0.0,1.0);\n    return length(p.xz-c.xy)-c.z;\n\n    // cylinder\u306e\u8ddd\u96e2\u95a2\u6570(length\u306a\u3057\u7248)\n    // vec3 c = vec3(0.0,0.0,1.0);\n    // return sqrt((p.x-c.x)*(p.x-c.x)+(p.z-c.y)*(p.z-c.y))-c.z;\n\n    // \u4e09\u89d2\u9310\u307d\u3044\u3084\u3064\n    // vec3 c = vec3(0.0,0.0,1.0);\n    // return sqrt((p.x-c.x)*(p.x-c.x)+(p.z-c.y)*(p.z-c.y))+p.y-c.z;\n\n    // \u7403\u6839\n    // vec3 c = vec3(0.0, 0.0,1.0);\n    // return sqrt((p.x-c.x)*(p.x-c.x)+(p.z-c.y)*(p.z-c.y))+p.y*p.y-c.z;\n\n    // \u90e8\u5c4b\u3063\u307d\u3044\u3084\u3064\n    // vec3 c = vec3(0.0, 0.0,1.0);\n    // return sqrt((p.x-c.x)*(p.x-c.x)+(p.z-c.y)*(p.z-c.y))-p.y*p.y*0.2-c.z;\n\n    // \u30bf\u30f3\u30af\n    // vec3 c = vec3(0.0,0.0,1.0);\n    // return sqrt((p.x-c.x)*(p.x-c.x)+(p.z-c.y)*(p.z-c.y))+p.y*p.y*p.y*p.y-c.z;\n\n    // \u30dc\u30bf\u30f3\n    // vec3 c = vec3(0.0,0.0,1.0);\n    // return sqrt((p.x-c.x)*(p.x-c.x)+(p.z-c.y)*(p.z-c.y))+p.y*p.y*p.y*p.y*p.y-c.z;\n\n    // \u4e09\u89d2\u9310\u2192\u9006\u4e09\u89d2\n    // vec3 c = vec3(0.0,0.0,1.0);\n    // return sqrt((p.x-c.x)*(p.x-c.x)+(p.z-c.y)*(p.z-c.y))+p.y*(sin(time))-c.z;\n\n    // \u30a2\u30cb\u30e1\u30fc\u30b7\u30e7\u30f32\n    // vec3 c = vec3(0.0,0.0,1.0);\n    // return sqrt((p.x-c.x)*(p.x-c.x)+(p.z-c.y)*(p.z-c.y))+p.y*p.y*(sin(time))-c.z;\n\n\n    // \u56de\u8ee2\u3092\u304b\u3051\u3066\u307f\u305f.\n    // mat3 m_x = mat3(1,0,0,0,cos(time),-sin(time),0,sin(time),cos(time));\n    // p = m_x * p;\n    // mat3 m_y = mat3(cos(time),0,-sin(time),0,1,0,sin(time),0,cos(time));\n    // p = m_y * p;\n    // mat3 m_z = mat3(cos(time),-sin(time),0,sin(time),cos(time),0,0,0,1);\n    // p = m_z * p;\n    // vec3 c = vec3(1.0,1.0,1.0);\n    // return sqrt((p.x-c.x)*(p.x-c.x)+(p.z-c.y)*(p.z-c.y))-c.z;\n\n}\n\n// \u8ddd\u96e2\u95a2\u6570\u3092\u547c\u3073\u51fa\u3059\u30cf\u30d6\u95a2\u6570\nfloat distanceHub(vec3 p){\n    return dCylinder(p);\n}\n\n// \u6cd5\u7dda\u3092\u751f\u6210\u3059\u308b\nvec3 genNormal(vec3 p){\n    float d = 0.001;\n    return normalize(vec3(\n        distanceHub(p + vec3(  d, 0.0, 0.0)) - distanceHub(p + vec3( -d, 0.0, 0.0)),\n        distanceHub(p + vec3(0.0,   d, 0.0)) - distanceHub(p + vec3(0.0,  -d, 0.0)),\n        distanceHub(p + vec3(0.0, 0.0,   d)) - distanceHub(p + vec3(0.0, 0.0,  -d))\n    ));\n}\n\nvoid main(){\n    // \u30b9\u30af\u30ea\u30fc\u30f3\u30b9\u30da\u30fc\u30b9\u3092\u8003\u616e\u3057\u3066\u5ea7\u6a19\u3092\u6b63\u898f\u5316\u3059\u308b\n    vec2 p = (gl_FragCoord.xy * 2.0 - resolution) / min(resolution.x, resolution.y);\n\n    // \u30ab\u30e1\u30e9\u3092\u5b9a\u7fa9\u3059\u308b\n    vec3 cPos = vec3(0.0,  0.0,  5.0); // \u30ab\u30e1\u30e9\u306e\u4f4d\u7f6e\n    vec3 cDir = vec3(0.0,  0.0, -1.0); // \u30ab\u30e1\u30e9\u306e\u5411\u304d(\u8996\u7dda)\n    vec3 cUp  = vec3(0.0,  1.0,  0.0); // \u30ab\u30e1\u30e9\u306e\u4e0a\u65b9\u5411\n    vec3 cSide = cross(cDir, cUp);     // \u5916\u7a4d\u3092\u4f7f\u3063\u3066\u6a2a\u65b9\u5411\u3092\u7b97\u51fa\n    float targetDepth = 1.0;           // \u30d5\u30a9\u30fc\u30ab\u30b9\u3059\u308b\u6df1\u5ea6\n\n    // \u30ab\u30e1\u30e9\u306e\u60c5\u5831\u304b\u3089\u30ec\u30a4\u3092\u5b9a\u7fa9\u3059\u308b\n    vec3 ray = normalize(cSide * p.x + cUp * p.y + cDir * targetDepth);\n\n    // \u30de\u30fc\u30c1\u30f3\u30b0\u30eb\u30fc\u30d7\u3092\u7d44\u3080\n    float dist = 0.0;  // \u30ec\u30a4\u3068\u30aa\u30d6\u30b8\u30a7\u30af\u30c8\u9593\u306e\u6700\u77ed\u8ddd\u96e2\n    float rLen = 0.0;  // \u30ec\u30a4\u306b\u7d99\u304e\u8db3\u3059\u9577\u3055\n    vec3  rPos = cPos; // \u30ec\u30a4\u306e\u5148\u7aef\u4f4d\u7f6e(\u521d\u671f\u4f4d\u7f6e)\n    for(int i = 0; i < 32; ++i){\n        dist = distanceHub(rPos);\n        rLen += dist;\n        rPos = cPos + ray * rLen;\n    }\n\n    // \u30ec\u30a4\u3068\u30aa\u30d6\u30b8\u30a7\u30af\u30c8\u306e\u8ddd\u96e2\u3092\u78ba\u8a8d\n    if(abs(dist) < 0.001){\n        // \u6cd5\u7dda\u3092\u7b97\u51fa\n        vec3 normal = genNormal(rPos);\n\n        // \u30e9\u30a4\u30c8\u30d9\u30af\u30c8\u30eb\u306e\u5b9a\u7fa9\n        vec3 light = normalize(vec3(1.0, 1.0, 1.0));\n        // \u30e9\u30a4\u30c8\u30d9\u30af\u30c8\u30eb\u306e\u5b9a\u7fa9\uff08\u30de\u30a6\u30b9\u306e\u5f71\u97ff\u3092\u53d7\u3051\u308b\u3088\u3046\u306b\uff09\n        // vec3 light = normalize(vec3(mouse + 1.0, 1.0));\n\n        // \u30e9\u30a4\u30c8\u30d9\u30af\u30c8\u30eb\u3068\u306e\u5185\u7a4d\u3092\u53d6\u308b\n        float diff = max(dot(normal, light), 0.1);\n\n        // diffuse \u3092\u51fa\u529b\u3059\u308b\n        gl_FragColor = vec4(vec3(diff), 1.0);\n    }else{\n        // \u885d\u7a81\u3057\u306a\u304b\u3063\u305f\u5834\u5408\u306f\u305d\u306e\u307e\u307e\u9ed2\n        gl_FragColor = vec4(vec3(0.0, 0.0, 0.0), 1.0);\n    }\n}\n\n\n\u53c2\u8003\u8a18\u4e8b\nmodeling with distance functions\n\n\u30bd\u30fc\u30b9\u30b3\u30fc\u30c9\nRayMarchingDistanceFunction/07\n[modeling with distance functions](http://iquilezles.org/www/articles/distfunctions/distfunctions.htm)\u306e\u8ddd\u96e2\u95a2\u6570\u306e\u4e00\u89a7\u306b\u6cbf\u3063\u3066\u8a18\u4e8b\u3092\u66f8\u3044\u3066\u3044\u307e\u3059.\n\n# Cylinder\u306e\u6570\u5f0f\u306f\n```math\nS(u,v) = \n\\begin{pmatrix}\n(c_x + r \\cos u)  \\\\\nh  \\\\\n(c_z + r \\sin u)\n\\end{pmatrix}\n\\\\\n (0<h,r), h:\u9ad8\u3055,r:\u534a\u5f84,\\\\\nc_x:\u5186\u306e\u4e2d\u5fc3\u306ex\u5ea7\u6a19\u3001c_z:\u5186\u306e\u4e2d\u5fc3\u306ez\u5ea7\u6a19\n```\n\n## x,y,z\u306e\u8868\u8a18\u306b\u76f4\u3059\u3068(\u8ddd\u96e2\u95a2\u6570\u306e\u8868\u8a18\u306b\u76f4\u3059\u3068)\n```math\n\\begin{align}\nx &= (c_x + r \\cos u) \\\\\ny &= h \\\\\nz &= (c_z + r \\sin u)\n\\end{align}\n```\n\n\u3088\u3063\u3066,\n\n```math\n(x-c_x)^2 + (z-c_z)^2 = r^2\n```\n\n\u306a\u306e\u3067\u3001\n\n```math\n\\sqrt{(x-c_x)^2 + (z-c_z)^2} - r \\\\\ny=h\n```\n\n\u3067\u3059.\n\n\u30b3\u30fc\u30c9\u306e\u8868\u8a18\u306b\u76f4\u3059\u3068\u4ee5\u4e0b\n\n```c++\nvec3 c = vec3(\u3010\u5186\u67f1\u306e\u5186\u306e\u4e2d\u5fc3\u306ex\u5ea7\u6a19\u3011,\u3010\u5186\u67f1\u306e\u5186\u306e\u4e2d\u5fc3\u306ez\u5ea7\u6a19\u3011,\u3010\u5186\u67f1\u306e\u534a\u5f84\u3011);\nreturn sqrt((p.x-c.x)*(p.x-c.x)+(p.z-c.y)*(p.z-c.y))-c.z;\n```\n\n### `length()` \u95a2\u6570\u3092\u7528\u3044\u308b\u3068\n\n```c++\nvec3 c = vec3(0.0,0.0,1.0);\nreturn length(p.xz-c.xy)-c.z;\n```\n\n![image.PNG](https://qiita-image-store.s3.amazonaws.com/0/102634/1c53e88f-6d8e-4daf-ec91-06d32f2643c3.png)\n\n## \u95a2\u6570\u3092\u3044\u3058\u3063\u3066\u904a\u3076\n### \u7403\u6839\n\n```c++\n// \u7403\u6839\nvec3 c = vec3(0.0, 0.0,1.0);\nreturn sqrt((p.x-c.x)*(p.x-c.x)+(p.z-c.y)*(p.z-c.y))+p.y*p.y-c.z;\n```\n\n![image2.PNG](https://qiita-image-store.s3.amazonaws.com/0/102634/30a35670-02ab-9709-c2d6-8e18037e808d.png)\n\n### \u90e8\u5c4b\u3063\u307d\u3044\u3084\u3064\n\n```c++\n// \u90e8\u5c4b\u3063\u307d\u3044\u3084\u3064\nvec3 c = vec3(0.0, 0.0,1.0);\nreturn sqrt((p.x-c.x)*(p.x-c.x)+(p.z-c.y)*(p.z-c.y))-p.y*p.y*0.2-c.z;\n```\n![image3.PNG](https://qiita-image-store.s3.amazonaws.com/0/102634/6a415f90-c952-fc5a-6454-dbd6a1364a7d.png)\n\n### \u30bf\u30f3\u30af\n\n```c++\n// \u30bf\u30f3\u30af\nvec3 c = vec3(0.0,0.0,1.0);\nreturn sqrt((p.x-c.x)*(p.x-c.x)+(p.z-c.y)*(p.z-c.y))+p.y*p.y*p.y*p.y-c.z;\n```\n\n![image4.PNG](https://qiita-image-store.s3.amazonaws.com/0/102634/43bcbe30-31e3-05c9-a248-4bc16fa79a02.png)\n\n### \u30a2\u30cb\u30e1\u30fc\u30b7\u30e7\u30f3\n\n```c++\n// \u30a2\u30cb\u30e1\u30fc\u30b7\u30e7\u30f32\nvec3 c = vec3(0.0,0.0,1.0);\nreturn sqrt((p.x-c.x)*(p.x-c.x)+(p.z-c.y)*(p.z-c.y))+p.y*p.y*(sin(time))-c.z;\n```\n\n![transform.gif](https://qiita-image-store.s3.amazonaws.com/0/102634/00c38226-5684-af6b-992a-47e72f029cb5.gif)\n\n\n## \u30bd\u30fc\u30b9\u30b3\u30fc\u30c9\n\n```c++\n// ============================================================================\n// Cylinder function\n// ============================================================================\n\nprecision mediump float;\nuniform vec2  resolution;    // resolution (512.0, 512.0)\nuniform vec2  mouse;         // mouse      (-1.0 ~ 1.0)\nuniform float time;          // time       (1second == 1.0)\nuniform sampler2D prevScene; // previous scene texture\n\n// Cylinder\u306e\u8ddd\u96e2\u95a2\u6570\nfloat dCylinder(vec3 p){\n    // cylinder\u306e\u8ddd\u96e2\u95a2\u6570\n    vec3 c = vec3(0.0,0.0,1.0);\n    return length(p.xz-c.xy)-c.z;\n\n    // cylinder\u306e\u8ddd\u96e2\u95a2\u6570(length\u306a\u3057\u7248)\n    // vec3 c = vec3(0.0,0.0,1.0);\n    // return sqrt((p.x-c.x)*(p.x-c.x)+(p.z-c.y)*(p.z-c.y))-c.z;\n\n    // \u4e09\u89d2\u9310\u307d\u3044\u3084\u3064\n    // vec3 c = vec3(0.0,0.0,1.0);\n    // return sqrt((p.x-c.x)*(p.x-c.x)+(p.z-c.y)*(p.z-c.y))+p.y-c.z;\n\n    // \u7403\u6839\n    // vec3 c = vec3(0.0, 0.0,1.0);\n    // return sqrt((p.x-c.x)*(p.x-c.x)+(p.z-c.y)*(p.z-c.y))+p.y*p.y-c.z;\n    \n    // \u90e8\u5c4b\u3063\u307d\u3044\u3084\u3064\n    // vec3 c = vec3(0.0, 0.0,1.0);\n    // return sqrt((p.x-c.x)*(p.x-c.x)+(p.z-c.y)*(p.z-c.y))-p.y*p.y*0.2-c.z;\n\n    // \u30bf\u30f3\u30af\n    // vec3 c = vec3(0.0,0.0,1.0);\n    // return sqrt((p.x-c.x)*(p.x-c.x)+(p.z-c.y)*(p.z-c.y))+p.y*p.y*p.y*p.y-c.z;\n\n    // \u30dc\u30bf\u30f3\n    // vec3 c = vec3(0.0,0.0,1.0);\n    // return sqrt((p.x-c.x)*(p.x-c.x)+(p.z-c.y)*(p.z-c.y))+p.y*p.y*p.y*p.y*p.y-c.z;\n\n    // \u4e09\u89d2\u9310\u2192\u9006\u4e09\u89d2\n    // vec3 c = vec3(0.0,0.0,1.0);\n    // return sqrt((p.x-c.x)*(p.x-c.x)+(p.z-c.y)*(p.z-c.y))+p.y*(sin(time))-c.z;\n\n    // \u30a2\u30cb\u30e1\u30fc\u30b7\u30e7\u30f32\n    // vec3 c = vec3(0.0,0.0,1.0);\n    // return sqrt((p.x-c.x)*(p.x-c.x)+(p.z-c.y)*(p.z-c.y))+p.y*p.y*(sin(time))-c.z;\n\n\n    // \u56de\u8ee2\u3092\u304b\u3051\u3066\u307f\u305f.\n    // mat3 m_x = mat3(1,0,0,0,cos(time),-sin(time),0,sin(time),cos(time));\n    // p = m_x * p;\n    // mat3 m_y = mat3(cos(time),0,-sin(time),0,1,0,sin(time),0,cos(time));\n    // p = m_y * p;\n    // mat3 m_z = mat3(cos(time),-sin(time),0,sin(time),cos(time),0,0,0,1);\n    // p = m_z * p;\n    // vec3 c = vec3(1.0,1.0,1.0);\n    // return sqrt((p.x-c.x)*(p.x-c.x)+(p.z-c.y)*(p.z-c.y))-c.z;\n\n}\n\n// \u8ddd\u96e2\u95a2\u6570\u3092\u547c\u3073\u51fa\u3059\u30cf\u30d6\u95a2\u6570\nfloat distanceHub(vec3 p){\n    return dCylinder(p);\n}\n\n// \u6cd5\u7dda\u3092\u751f\u6210\u3059\u308b\nvec3 genNormal(vec3 p){\n    float d = 0.001;\n    return normalize(vec3(\n        distanceHub(p + vec3(  d, 0.0, 0.0)) - distanceHub(p + vec3( -d, 0.0, 0.0)),\n        distanceHub(p + vec3(0.0,   d, 0.0)) - distanceHub(p + vec3(0.0,  -d, 0.0)),\n        distanceHub(p + vec3(0.0, 0.0,   d)) - distanceHub(p + vec3(0.0, 0.0,  -d))\n    ));\n}\n\nvoid main(){\n    // \u30b9\u30af\u30ea\u30fc\u30f3\u30b9\u30da\u30fc\u30b9\u3092\u8003\u616e\u3057\u3066\u5ea7\u6a19\u3092\u6b63\u898f\u5316\u3059\u308b\n    vec2 p = (gl_FragCoord.xy * 2.0 - resolution) / min(resolution.x, resolution.y);\n\n    // \u30ab\u30e1\u30e9\u3092\u5b9a\u7fa9\u3059\u308b\n    vec3 cPos = vec3(0.0,  0.0,  5.0); // \u30ab\u30e1\u30e9\u306e\u4f4d\u7f6e\n    vec3 cDir = vec3(0.0,  0.0, -1.0); // \u30ab\u30e1\u30e9\u306e\u5411\u304d(\u8996\u7dda)\n    vec3 cUp  = vec3(0.0,  1.0,  0.0); // \u30ab\u30e1\u30e9\u306e\u4e0a\u65b9\u5411\n    vec3 cSide = cross(cDir, cUp);     // \u5916\u7a4d\u3092\u4f7f\u3063\u3066\u6a2a\u65b9\u5411\u3092\u7b97\u51fa\n    float targetDepth = 1.0;           // \u30d5\u30a9\u30fc\u30ab\u30b9\u3059\u308b\u6df1\u5ea6\n\n    // \u30ab\u30e1\u30e9\u306e\u60c5\u5831\u304b\u3089\u30ec\u30a4\u3092\u5b9a\u7fa9\u3059\u308b\n    vec3 ray = normalize(cSide * p.x + cUp * p.y + cDir * targetDepth);\n\n    // \u30de\u30fc\u30c1\u30f3\u30b0\u30eb\u30fc\u30d7\u3092\u7d44\u3080\n    float dist = 0.0;  // \u30ec\u30a4\u3068\u30aa\u30d6\u30b8\u30a7\u30af\u30c8\u9593\u306e\u6700\u77ed\u8ddd\u96e2\n    float rLen = 0.0;  // \u30ec\u30a4\u306b\u7d99\u304e\u8db3\u3059\u9577\u3055\n    vec3  rPos = cPos; // \u30ec\u30a4\u306e\u5148\u7aef\u4f4d\u7f6e(\u521d\u671f\u4f4d\u7f6e)\n    for(int i = 0; i < 32; ++i){\n        dist = distanceHub(rPos);\n        rLen += dist;\n        rPos = cPos + ray * rLen;\n    }\n\n    // \u30ec\u30a4\u3068\u30aa\u30d6\u30b8\u30a7\u30af\u30c8\u306e\u8ddd\u96e2\u3092\u78ba\u8a8d\n    if(abs(dist) < 0.001){\n        // \u6cd5\u7dda\u3092\u7b97\u51fa\n        vec3 normal = genNormal(rPos);\n\n        // \u30e9\u30a4\u30c8\u30d9\u30af\u30c8\u30eb\u306e\u5b9a\u7fa9\n        vec3 light = normalize(vec3(1.0, 1.0, 1.0));\n        // \u30e9\u30a4\u30c8\u30d9\u30af\u30c8\u30eb\u306e\u5b9a\u7fa9\uff08\u30de\u30a6\u30b9\u306e\u5f71\u97ff\u3092\u53d7\u3051\u308b\u3088\u3046\u306b\uff09\n        // vec3 light = normalize(vec3(mouse + 1.0, 1.0));\n\n        // \u30e9\u30a4\u30c8\u30d9\u30af\u30c8\u30eb\u3068\u306e\u5185\u7a4d\u3092\u53d6\u308b\n        float diff = max(dot(normal, light), 0.1);\n\n        // diffuse \u3092\u51fa\u529b\u3059\u308b\n        gl_FragColor = vec4(vec3(diff), 1.0);\n    }else{\n        // \u885d\u7a81\u3057\u306a\u304b\u3063\u305f\u5834\u5408\u306f\u305d\u306e\u307e\u307e\u9ed2\n        gl_FragColor = vec4(vec3(0.0, 0.0, 0.0), 1.0);\n    }\n}\n```\n\n# \u53c2\u8003\u8a18\u4e8b\n[modeling with distance functions](http://iquilezles.org/www/articles/distfunctions/distfunctions.htm)\n\n# \u30bd\u30fc\u30b9\u30b3\u30fc\u30c9\n[RayMarchingDistanceFunction/07](https://github.com/muripoLife/RayMarchingDistanceFunction/blob/master/07/fsp.frag)\n", "tags": ["GLSL", "\u6570\u5b66"]}