{"context": "2015\u5e74\u306b\u306f1.0\u304c\u516c\u958b\u3055\u308c\u308b\u4e88\u5b9a\u306eRust\u8a00\u8a9e\u306e\u52c9\u5f37\u306e\u305f\u3081\u306b\u3001Unix\u30b3\u30de\u30f3\u30c9\u3092\u7c21\u7565\u5316\u3057\u3066Rust\u3067\u5b9f\u88c5\u3057\u3066\u307f\u305f\u3002\n\u3059\u3067\u306b\u3001uutils/coreutils\u30d7\u30ed\u30b8\u30a7\u30af\u30c8\u3067cat\u30b3\u30de\u30f3\u30c9\u306f\u5b9f\u88c5\u3055\u308c\u3066\u3044\u307e\u3059\u304c\u3001\u4eca\u56de\u306f\u3075\u3064\u3046\u306elinux\u30d7\u30ed\u30b0\u30e9\u30df\u30f3\u30b0\u3068\u3044\u3046\u672c\u306e\u30b5\u30f3\u30d7\u30eb\u30b3\u30fc\u30c9\u3092\u53c2\u8003\u306b\u3057\u307e\u3057\u305f\u3002\n\u203b \u30b3\u30fc\u30c9\u306f\u3053\u3053\u306e\u30ec\u30dd\u30b8\u30c8\u30ea\u306b\u516c\u958b\u3059\u308b\u306e\u3067\u3001\u300c\u3082\u3063\u3068\u3053\u3046\u66f8\u3051\u308b\u3088\u300d\u307f\u305f\u3044\u306a\u306e\u304c\u3042\u308c\u3070\u3001\u30d7\u30eb\u30ea\u30af\u304a\u9858\u3044\u3057\u307e\u3059\u3002\n\nC\u8a00\u8a9e\u3067\u306ecat\n\ncat.c\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n\nstatic void do_cat(const char *path);\nstatic void die(const char *s);\n\nint\nmain(int argc, char *argv[])\n{\n  int i;\n  if (argc < 2) {\n    fprintf(stderr, \"%s: file name not given\\n\", argv[0]);\n    exit(1);\n  }\n  for (i = 1; i < argc; i++) {\n    do_cat(argv[i]);\n  }\n  exit(0);\n}\n\n#define BUFFER_SIZE 2048\n\nstatic void\ndo_cat(const char *path)\n{\n  int fd;\n  unsigned char buf[BUFFER_SIZE];\n  int n;\n\n  fd = open(path, O_RDONLY);\n  if (fd < 0) die(path);\n  for (;;) {\n    n = read(fd, buf, sizeof buf);\n    if (n < 0) die(path);\n    if (n == 0) break;\n    if (write(STDOUT_FILENO, buf, n) < 0) die(path);\n  }\n  if (close(fd) < 0) die(path);\n}\n\nstatic void die(const char *s)\n{\n  perror(s);\n  exit(1);\n}\n\n\n\u30aa\u30d7\u30b7\u30e7\u30f3\u3068\u304b\u306f\u5b9f\u88c5\u305b\u305a\u3001\u30d5\u30a1\u30a4\u30eb\u306e\u5185\u5bb9\u3092\u8aad\u307f\u53d6\u308a\u6a19\u6e96\u51fa\u529b\u3059\u308b\u3002\n\nRust\u8a00\u8a9e\u3067\u306ecat\n\n\u5b9f\u884c\u74b0\u5883\n$ rustc --version                                                                                                                                                      \nrustc 0.13.0-nightly (34d680009 2014-12-22 00:12:47 +0000)\n\n\ncat.rs\n#![allow(unused_must_use)]\nuse std::os;\nuse std::io::{File, IoResult, IoError, EndOfFile};\nuse std::io::stdio::{stdout_raw, stderr};\n\nfn main() {\n    let paths = os::args().slice_from_or_fail(&1).to_vec();\n    let mut stderr = stderr();\n\n    if paths.len() < 1 {\n        stderr.write_str(\"file name not given\\n\");\n    }\n    for path in paths.iter() {\n        let res = do_cat(path);\n        if res.is_err() {\n            panic!(\"{}: {}\", path, res.unwrap_err());\n        }\n    }\n}\n\nconst BUFFER_SIZE: uint = 2048;\n\nfn do_cat(path: &String) -> IoResult<()> {\n    let mut writer = stdout_raw();\n    let mut in_buf = [0, .. BUFFER_SIZE];\n    let mut reader = File::open(&std::path::Path::new(path));\n\n    loop {\n        let n = match reader.read(&mut in_buf) {\n            Ok(n) if n == 0 => return Ok(()),\n            Ok(n) => n,\n            Err(IoError{ kind: EndOfFile, ..}) => return Ok(()),\n            Err(e) => return Err(e)\n        };\n        try!(writer.write(in_buf.slice_to(n)));\n    }\n}\n\n\n\u5b9f\u969b\u306b\u66f8\u3044\u3066\u307f\u305f\u3089\u3001\u3084\u3063\u3071\u308afor\u6587\u306e\u30ab\u30a6\u30f3\u30c8\u7528\u5909\u6570\u3068\u304b\u3092\u4f7f\u3046\u5fc5\u8981\u304c\u306a\u304f\u306a\u3063\u305f\u306e\u3067\u3001\u30b3\u30f3\u30d1\u30af\u30c8\u306b\u66f8\u3051\u308b\u3057\u53ef\u8aad\u6027\u306f\u5897\u3057\u3066\u3044\u308b\u3002\n\u914d\u5217\u3092each\u3063\u307d\u304f\u4f7f\u3048\u308biter()\u3068\u304b\u3001match\u4f7f\u3063\u3066if\u6587\u304c\u6e1b\u3089\u305b\u308b\u304b\u3089\u4fbf\u5229\u3002\n\n\u3082\u3063\u3068\u30b7\u30f3\u30d7\u30eb\u306b\u66f8\u3051\u3066\u3044\u308b\u30d7\u30eb\u30ea\u30af\u3092\u9802\u304d\u307e\u3057\u305f\n2015/06/26\u66f4\u65b0\ntos-kamiya\u3055\u3093\u304b\u3089\u3082\u3063\u3068\u3001\u30b7\u30f3\u30d7\u30eb\u306b\u66f8\u3051\u3066\u3044\u308b\u30d7\u30eb\u30ea\u30af\u3092\u9802\u304d\u307e\u3057\u305f\u3002\u4e0a\u306e\u30b3\u30fc\u30c9\u306fC\u3092\u5143\u306b\u3057\u3066\u3057\u307e\u3063\u3066\u3044\u308b\u306e\u3067\u3001Rust\u306e\u6069\u6075\u304c\u3042\u307e\u308a\u53d7\u3051\u3089\u308c\u3066\u3044\u307e\u305b\u3093\u304c\u3001\u3053\u3061\u3089\u306e\u30b3\u30fc\u30c9\u306f\u3068\u3066\u3082Rust\u3063\u307d\u3044\u3067\u3059\u306d\u3002\u3042\u308a\u304c\u3068\u3046\u3054\u3056\u3044\u307e\u3059\u3002\nuse std::fs::File;\nuse std::io::{BufReader, Read, Write};\nuse std::io::stdout;\nuse std::env::args;\n\nconst BUFFER_SIZE: usize = 2048;\n\nfn main() {\n    let paths: Vec<String> = args().skip(1).collect();\n    if paths.is_empty() {\n        panic!(\"file name not given\");\n    }\n\n    let mut writer = stdout();\n    for path in paths {\n        do_cat(&mut writer, &path);\n    }\n}\n\nfn do_cat(writer: &mut Write, path: &str) {\n    let file = File::open(path).unwrap();\n    let mut reader = BufReader::new(&file);\n    let mut buf = [0; BUFFER_SIZE];\n    loop {\n        let n = reader.read(&mut buf).unwrap();\n        if n == 0 { break; }\n        writer.write_all(&buf[..n]).unwrap();\n    }\n}\n\n\u5143\u306e\u30b3\u30fc\u30c9\u306f\u3053\u3061\u3089\u3067\u78ba\u8a8d\u3067\u304d\u307e\u3059\n\n\u8ffd\u8a18\n2015/01/03 kui \u3055\u3093\u306b\u30d7\u30eb\u30ea\u30af\u3082\u3089\u3044\u307e\u3057\u305f\u3002\u914d\u5217\u306e\u6700\u521d\u3060\u3051\u53d6\u308a\u9664\u304f\u65b9\u6cd5\u3082\nlet paths = os::args().slice_from_or_fail(&1).to_vec();\n\n\u3063\u3066\u66f8\u3051\u3070\u3088\u304b\u3063\u305f\u3093\u3067\u3059\u306d\u3002\n\u3042\u308a\u304c\u3068\u3046\u3054\u3056\u3044\u307e\u3059\u3002\n\n\u8ffd\u8a18\n2017/03/01 Rust\u306eLT\u4f1a\uff01 Rust\u5165\u9580\u8005\u306e\u96c6\u3044 #2\u3067\u767a\u8868\u3057\u305f\u6642 1.15.1 \u3067\u52d5\u304f\u3088\u3046\u306b\u3057\u307e\u3057\u305f\u3002\n#![allow(unused_must_use)]\nuse std::env;\nuse std::io::{stdout, stderr, Write, Read, Result};\nuse std::fs::File;\n\nfn main() {\n    let paths = env::args().skip(1);\n    if paths.len() < 1 {\n        writeln!(&mut stderr(), \"file name not given\\n\");\n    }\n    for path in paths {\n        let res = do_cat(path);\n        if res.is_err() {\n            panic!(\"{}\", res.unwrap_err());\n        }\n    }\n}\n\nconst BUFFER_SIZE: usize = 2048;\n\nfn do_cat(path: String) -> Result<()> {\n    let stdout = stdout();\n    let mut handle = stdout.lock();\n    let mut in_buf = [0; BUFFER_SIZE];\n    let mut reader = try!(File::open(&std::path::Path::new(&path)));\n\n    loop {\n        let n = match reader.read(&mut in_buf[..]) {\n            Ok(n) if n == 0 => return Ok(()),\n            Ok(n) => n,\n            Err(e) => return Err(e)\n        };\n        try!(handle.write(&in_buf[0..n]));\n    }\n}\n\n\n2015\u5e74\u306b\u306f1.0\u304c\u516c\u958b\u3055\u308c\u308b\u4e88\u5b9a\u306eRust\u8a00\u8a9e\u306e\u52c9\u5f37\u306e\u305f\u3081\u306b\u3001Unix\u30b3\u30de\u30f3\u30c9\u3092\u7c21\u7565\u5316\u3057\u3066Rust\u3067\u5b9f\u88c5\u3057\u3066\u307f\u305f\u3002\n\n\u3059\u3067\u306b\u3001[uutils/coreutils](https://github.com/uutils/coreutils/blob/master/src/cat/cat.rs)\u30d7\u30ed\u30b8\u30a7\u30af\u30c8\u3067cat\u30b3\u30de\u30f3\u30c9\u306f\u5b9f\u88c5\u3055\u308c\u3066\u3044\u307e\u3059\u304c\u3001\u4eca\u56de\u306f[\u3075\u3064\u3046\u306elinux\u30d7\u30ed\u30b0\u30e9\u30df\u30f3\u30b0](http://www.amazon.co.jp/gp/product/4797328355/ref=as_li_ss_tl?ie=UTF8&camp=247&creative=7399&creativeASIN=4797328355&linkCode=as2&tag=regonns-22)\u3068\u3044\u3046\u672c\u306e\u30b5\u30f3\u30d7\u30eb\u30b3\u30fc\u30c9\u3092\u53c2\u8003\u306b\u3057\u307e\u3057\u305f\u3002\n\n\u203b \u30b3\u30fc\u30c9\u306f[\u3053\u3053](https://github.com/regonn/rust-unix-command)\u306e\u30ec\u30dd\u30b8\u30c8\u30ea\u306b\u516c\u958b\u3059\u308b\u306e\u3067\u3001\u300c\u3082\u3063\u3068\u3053\u3046\u66f8\u3051\u308b\u3088\u300d\u307f\u305f\u3044\u306a\u306e\u304c\u3042\u308c\u3070\u3001\u30d7\u30eb\u30ea\u30af\u304a\u9858\u3044\u3057\u307e\u3059\u3002\n\n# C\u8a00\u8a9e\u3067\u306ecat\n\n```cat.c\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n\nstatic void do_cat(const char *path);\nstatic void die(const char *s);\n\nint\nmain(int argc, char *argv[])\n{\n  int i;\n  if (argc < 2) {\n    fprintf(stderr, \"%s: file name not given\\n\", argv[0]);\n    exit(1);\n  }\n  for (i = 1; i < argc; i++) {\n    do_cat(argv[i]);\n  }\n  exit(0);\n}\n\n#define BUFFER_SIZE 2048\n\nstatic void\ndo_cat(const char *path)\n{\n  int fd;\n  unsigned char buf[BUFFER_SIZE];\n  int n;\n\n  fd = open(path, O_RDONLY);\n  if (fd < 0) die(path);\n  for (;;) {\n    n = read(fd, buf, sizeof buf);\n    if (n < 0) die(path);\n    if (n == 0) break;\n    if (write(STDOUT_FILENO, buf, n) < 0) die(path);\n  }\n  if (close(fd) < 0) die(path);\n}\n\nstatic void die(const char *s)\n{\n  perror(s);\n  exit(1);\n}\n```\n\n\u30aa\u30d7\u30b7\u30e7\u30f3\u3068\u304b\u306f\u5b9f\u88c5\u305b\u305a\u3001\u30d5\u30a1\u30a4\u30eb\u306e\u5185\u5bb9\u3092\u8aad\u307f\u53d6\u308a\u6a19\u6e96\u51fa\u529b\u3059\u308b\u3002\n\n# Rust\u8a00\u8a9e\u3067\u306ecat\n\n## \u5b9f\u884c\u74b0\u5883\n\n```\n$ rustc --version                                                                                                                                                      \nrustc 0.13.0-nightly (34d680009 2014-12-22 00:12:47 +0000)\n```\n\n```cat.rs\n#![allow(unused_must_use)]\nuse std::os;\nuse std::io::{File, IoResult, IoError, EndOfFile};\nuse std::io::stdio::{stdout_raw, stderr};\n\nfn main() {\n    let paths = os::args().slice_from_or_fail(&1).to_vec();\n    let mut stderr = stderr();\n\n    if paths.len() < 1 {\n        stderr.write_str(\"file name not given\\n\");\n    }\n    for path in paths.iter() {\n        let res = do_cat(path);\n        if res.is_err() {\n            panic!(\"{}: {}\", path, res.unwrap_err());\n        }\n    }\n}\n\nconst BUFFER_SIZE: uint = 2048;\n\nfn do_cat(path: &String) -> IoResult<()> {\n    let mut writer = stdout_raw();\n    let mut in_buf = [0, .. BUFFER_SIZE];\n    let mut reader = File::open(&std::path::Path::new(path));\n\n    loop {\n        let n = match reader.read(&mut in_buf) {\n            Ok(n) if n == 0 => return Ok(()),\n            Ok(n) => n,\n            Err(IoError{ kind: EndOfFile, ..}) => return Ok(()),\n            Err(e) => return Err(e)\n        };\n        try!(writer.write(in_buf.slice_to(n)));\n    }\n}\n```\n\n\u5b9f\u969b\u306b\u66f8\u3044\u3066\u307f\u305f\u3089\u3001\u3084\u3063\u3071\u308afor\u6587\u306e\u30ab\u30a6\u30f3\u30c8\u7528\u5909\u6570\u3068\u304b\u3092\u4f7f\u3046\u5fc5\u8981\u304c\u306a\u304f\u306a\u3063\u305f\u306e\u3067\u3001\u30b3\u30f3\u30d1\u30af\u30c8\u306b\u66f8\u3051\u308b\u3057\u53ef\u8aad\u6027\u306f\u5897\u3057\u3066\u3044\u308b\u3002\n\n\u914d\u5217\u3092each\u3063\u307d\u304f\u4f7f\u3048\u308b`iter()`\u3068\u304b\u3001`match`\u4f7f\u3063\u3066if\u6587\u304c\u6e1b\u3089\u305b\u308b\u304b\u3089\u4fbf\u5229\u3002\n\n# \u3082\u3063\u3068\u30b7\u30f3\u30d7\u30eb\u306b\u66f8\u3051\u3066\u3044\u308b\u30d7\u30eb\u30ea\u30af\u3092\u9802\u304d\u307e\u3057\u305f\n\n2015/06/26\u66f4\u65b0\n[tos-kamiya](https://github.com/tos-kamiya)\u3055\u3093\u304b\u3089\u3082\u3063\u3068\u3001\u30b7\u30f3\u30d7\u30eb\u306b\u66f8\u3051\u3066\u3044\u308b\u30d7\u30eb\u30ea\u30af\u3092\u9802\u304d\u307e\u3057\u305f\u3002\u4e0a\u306e\u30b3\u30fc\u30c9\u306fC\u3092\u5143\u306b\u3057\u3066\u3057\u307e\u3063\u3066\u3044\u308b\u306e\u3067\u3001Rust\u306e\u6069\u6075\u304c\u3042\u307e\u308a\u53d7\u3051\u3089\u308c\u3066\u3044\u307e\u305b\u3093\u304c\u3001\u3053\u3061\u3089\u306e\u30b3\u30fc\u30c9\u306f\u3068\u3066\u3082Rust\u3063\u307d\u3044\u3067\u3059\u306d\u3002\u3042\u308a\u304c\u3068\u3046\u3054\u3056\u3044\u307e\u3059\u3002\n\n```\nuse std::fs::File;\nuse std::io::{BufReader, Read, Write};\nuse std::io::stdout;\nuse std::env::args;\n\nconst BUFFER_SIZE: usize = 2048;\n\nfn main() {\n    let paths: Vec<String> = args().skip(1).collect();\n    if paths.is_empty() {\n        panic!(\"file name not given\");\n    }\n\n    let mut writer = stdout();\n    for path in paths {\n        do_cat(&mut writer, &path);\n    }\n}\n\nfn do_cat(writer: &mut Write, path: &str) {\n    let file = File::open(path).unwrap();\n    let mut reader = BufReader::new(&file);\n    let mut buf = [0; BUFFER_SIZE];\n    loop {\n        let n = reader.read(&mut buf).unwrap();\n        if n == 0 { break; }\n        writer.write_all(&buf[..n]).unwrap();\n    }\n}\n```\n\n\u5143\u306e\u30b3\u30fc\u30c9\u306f[\u3053\u3061\u3089](https://github.com/tos-kamiya/rust-unix-command/blob/simpler/cat.rs)\u3067\u78ba\u8a8d\u3067\u304d\u307e\u3059\n\n# \u8ffd\u8a18\n2015/01/03 [kui](https://github.com/kui) \u3055\u3093\u306b\u30d7\u30eb\u30ea\u30af\u3082\u3089\u3044\u307e\u3057\u305f\u3002\u914d\u5217\u306e\u6700\u521d\u3060\u3051\u53d6\u308a\u9664\u304f\u65b9\u6cd5\u3082\n\n```\nlet paths = os::args().slice_from_or_fail(&1).to_vec();\n```\n\n\u3063\u3066\u66f8\u3051\u3070\u3088\u304b\u3063\u305f\u3093\u3067\u3059\u306d\u3002\n\u3042\u308a\u304c\u3068\u3046\u3054\u3056\u3044\u307e\u3059\u3002\n\n# \u8ffd\u8a18\n2017/03/01 [Rust\u306eLT\u4f1a\uff01 Rust\u5165\u9580\u8005\u306e\u96c6\u3044 \\#2](https://rust.connpass.com/event/48826/)\u3067\u767a\u8868\u3057\u305f\u6642 1.15.1 \u3067\u52d5\u304f\u3088\u3046\u306b\u3057\u307e\u3057\u305f\u3002\n\n```rust\n#![allow(unused_must_use)]\nuse std::env;\nuse std::io::{stdout, stderr, Write, Read, Result};\nuse std::fs::File;\n\nfn main() {\n    let paths = env::args().skip(1);\n    if paths.len() < 1 {\n        writeln!(&mut stderr(), \"file name not given\\n\");\n    }\n    for path in paths {\n        let res = do_cat(path);\n        if res.is_err() {\n            panic!(\"{}\", res.unwrap_err());\n        }\n    }\n}\n\nconst BUFFER_SIZE: usize = 2048;\n\nfn do_cat(path: String) -> Result<()> {\n    let stdout = stdout();\n    let mut handle = stdout.lock();\n    let mut in_buf = [0; BUFFER_SIZE];\n    let mut reader = try!(File::open(&std::path::Path::new(&path)));\n\n    loop {\n        let n = match reader.read(&mut in_buf[..]) {\n            Ok(n) if n == 0 => return Ok(()),\n            Ok(n) => n,\n            Err(e) => return Err(e)\n        };\n        try!(handle.write(&in_buf[0..n]));\n    }\n}\n\n```\n", "tags": ["rust"]}