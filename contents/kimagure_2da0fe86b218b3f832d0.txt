{"context": "...a follow-up to \"Async in Purescript is fun and easy\"\nLast time I wrote an article about how async in Purescript is pretty fun and doesn't have to be hard, but that doesn't really give users who are unfamiliar with Purescript/Haskell/Elm a good sense of what writing a normal application looks like using those async tools. In this post, I'll go into a breadth of features that I used to make a simple Telegram chatbot and hopefully provide some examples of how to use Effs and Streams in the \"context\" of Aff.\n\nGetting to work\n\nReading configuration\nMy chatbot some configuration in a JSON file with the following properties:\n\n\ntoken - auth token for my Telegram bot\n\ntorscraperPath - path to my Torscraper program\n\n\nmaster - my Telegram user id, for when I need to send messages that aren't replies\n\nSo I need to read in this file, parse the JSON, then extract the fields (while making sure they are set). Since this only requires one value, I use an Aff here.\nFor reading the files, there is already a nice library, purescript-node-fs-aff. It's nice that we don't need to do this manually. We use readTextFile which takes an encoding and a filepath.\nreadTextFile UTF8 \"./config.json\"\n\nFor parsing the result, there's also another nice library, purescript-foreign. This lets us parse JSON and start reading props from it.\nparseConfig :: String -> Either ForeignError Config\nparseConfig json = do\n  value <- parseJSON json\n  token <- readProp \"token\" value\n  torscraperPath <- readProp \"torscraperPath\" value\n  master <- readProp \"master\" value\n  pure\n    { token: token\n    , torscraperPath: torscraperPath\n    , master: master\n    }\n\nThis seems meatier, but uses things we've seen before. In this do block, each binding is the result of taking the Right of our Either representing a successful operation. Left is a failure, and would short-circuit this to return the left side, which in this case is a ForeignError. After all these readProps, we then lift our record of type Config into the Either as Right Config.\nFor putting these together, we can use the generic map/<$> operator on an Aff to map a function to what is inside, and we get what we're looking for.\ngetConfig :: forall e. Aff (fs :: FS | e) (Either ForeignError Config)\ngetConfig = parseConfig <$> readTextFile UTF8 \"./config.json\"\n\nThe config parsing is a key point in our application's startup, so I'm going to make sure that the user is notified when they mess this up, which means that I'll be handling the Left case of the Either to notify the user their config file is malformed. The Right case will resume as needed.\nmain = launchAff $ do\n  config <- getConfig\n  case config of\n    Left e -> liftEff' $ log \"config.json is malformed. closing.\"\n    Right {token, torscraperPath, master} -> do\n      [...]\n\nYou'll see here that I've used liftEff', because I'm using log from Control.Monad.Eff.Console. This lifts the Eff into an Aff so that it can be used in the do block of the launchAff.\nThis will come up again and again, in this article and in other code you write.\n\nStarting up our bot and bot methods\nThe actual Telegram API is humongous, and this being just a hacky project, I have taken many liberties to make this as easy as possible for me.\nFor one, I made connecting dead easy:\nexports.connect = function (token) {\n  return function () {\n    return new TelegramBot(token, {polling: true});\n  };\n}\n\ntype TelegramEffects e = (telegram :: TELEGRAM, console :: CONSOLE | e)\n\nforeign import data TELEGRAM :: !\n\nforeign import data Bot :: *\n\nforeign import connect :: forall e. Token -> Eff (TelegramEffects e) Bot\n\nI've made a convenience type to work from called TelegramEffects, but importantly I've added TELEGRAM as an effect and Bot as a data type for my bot instance. My connect function simply returns a bot instance running through the instance, and so usage looks like our logging function above:\nbot <- liftEff $ connect token\n\nWith sending messages, I also have a relatively simple FFI function:\nexports._sendMessage = function(bot, id, message) {\n  return function () {\n    bot.sendMessage(id, message);\n  };\n}\n\nforeign import _sendMessage :: forall e.\n  Fn3\n    Bot\n    Int\n    String\n    (Eff (TelegramEffects e) Unit)\n\nThis Fn3 thing may be unfamiliar to you. It's the uncurried function helper, so that you don't have to write fully curried FFI functions. Fn3 is of kind * -> * -> * -> * -> *, which looks scary at first, but really means that it takes four arguments, which aligns to the three arguments and one return value. This has an accompanying runFn3 function for actually running these uncurried functions.\nMy sendMessage then has some logic about when messages should actually be sent:\ndata RequestOrigin\n  = User\n  | Timer\n\ntype Request =\n  { origin :: RequestOrigin\n  , id :: Id\n  }\n\nsendMessage :: forall e. Bot -> Result -> Eff (TelegramEffects e) Unit\nsendMessage bot {id, output, origin} = do\n  case origin of\n    Timer ->\n      case indexOf \"nothing new to download\" output of\n        Just _ -> log \"timer found nothing\" -- don't care about being notified here!\n        _ -> send\n    _ -> send\n  where\n    send = do\n      log output\n      runFn3 _sendMessage bot id output\n\nMy message listening function is the worst, since I was too lazy to properly set up anything, including traversing the complex object structure to get just a few pieces of information I need. I \"leave this\" as an \"exercise for the reader\" if they would like to implement this correctly:\nexports.addMessagesListener = function (bot, User, eff) {\n  return function () {\n    bot.onText(/^get$/i, function (msg, match) {\n      var fromId = msg.from.id;\n      eff({\n        origin: User,\n        id: fromId\n      })();\n      console.log('got request from', fromId);\n    });\n  };\n}\n\nforeign import addMessagesListener :: forall e.\n  Fn3\n    Bot\n    RequestOrigin\n    (Request -> Eff (TelegramEffects e) Unit)\n    (Eff (TelegramEffects e) Unit)\n\n\nRunning our Torscraper\nThis is another case where we can take advantage of existing code written in purescript-node-child-process and purescript-node-streams. This allows me to spawn a child process and add some handlers like usual. I collect the output using a ref that I write to.\nrunTorscraper :: forall e.\n  String ->\n  Request ->\n  Aff\n    ( ref :: REF\n    , cp :: CHILD_PROCESS\n    | e\n    )\n    Result\nrunTorscraper path request = makeAff \\e s -> do\n  ref <- newRef \"\"\n  process <- spawn \"node\" [\"index.js\"] $\n    defaultSpawnOptions { cwd = Just path }\n  result <- try $ onDataString (stdout process) UTF8 \\string ->\n    modifyRef ref $ append string\n  case result of\n    Right _ -> do\n      onError process $ toStandardError >>> e\n      onExit process \\exit -> do\n        output <- readRef ref\n        s { id: request.id, origin: request.origin, output: output }\n    Left err -> e err\n\n\nPutting it into Streams\n\nNow that we have the pieces, we can start putting them into place.\nThe addMessagesListener from before can be used with fromCallback from purescript-xstream to create a Stream. This fromCallback actually returns a Eff e (Stream a), so we need to lift this like before.\nrequests <- liftEff $ fromCallback $ runFn3 addMessagesListener bot User\n\nSimilarly, we use periodic from purescript-xstream and then map a const timerRequest to it, so that every tick of the timer will just give us this static request.\nlet timerRequest = {id: master, origin: Timer}\ntimer <- liftEff $ periodic (60 * 60 * 1000)\nlet timer' = const timerRequest <$> timer\n\nThen we need to take these two Streams, merge with another Stream that will make sure this gets called when the bot starts up, and switch-map an Eff. A switch-map is just like a normal flatMap, where you pass in a function of a -> f a, but in the context of Streams/observables, the subscription to the previous provided Stream is disposed. This is a bit of a dense explanation, but there are better explanations and examples online like this StackOverflow question.\nSo by using switchMapEff in purescript-xstream, we can switch-map Effs to produce Streams.\nresults <- liftEff $ (requests <|> timer' <|> pure timerRequest) `switchMapEff` \\request ->\n  fromAff $ runTorscraper torscraperPath request\n\nThe alt/<|> operator is used here to merge all the values emitted by the streams.\nFinally we can just lift the subscribe function and we're done:\nliftEff' $ addListener\n  { next: sendMessage bot\n  , error: message >>> log\n  , complete: const $ pure unit\n  }\n  results\n\n\nConclusion\nHopefully this has been kind of useful to see how you can write your own Purescript programs and how you can use Effs and Streams in the \"context\" of Aff.\nIf you made it this far, thanks for reading! And please do send me corrections or suggestions, as I'm sure I do not have the best solutions here.\n\nLinks\n\nMy Telegram bot code used in this post https://github.com/justinwoo/simple-rpc-telegram-bot/\n\nThe previous post, \"Async in Purescript is fun and easy\" http://qiita.com/kimagure/items/2ebce1399bac00c79656\n\nThe post about my Torscraper, \"Making a simple node program with Purescript\" http://qiita.com/kimagure/items/5674e3ae9c87262af762\n\npurescript-aff https://github.com/slamdata/purescript-aff/\n\npurescript-xstream https://github.com/justinwoo/purescript-xstream\n\npurescript-node-fs-aff https://github.com/purescript-node/purescript-node-fs-aff\n\npurescript-node-child-process https://github.com/purescript-node/purescript-node-child-process\n\npurescript-node-streams https://github.com/purescript-node/purescript-node-streams\n\n\n...a follow-up to [\"Async in Purescript is fun and easy\"](http://qiita.com/kimagure/items/2ebce1399bac00c79656)\n\nLast time I wrote an article about how async in Purescript is pretty fun and doesn't have to be hard, but that doesn't really give users who are unfamiliar with Purescript/Haskell/Elm a good sense of what writing a normal application looks like using those async tools. In this post, I'll go into a breadth of features that I used to make a simple Telegram chatbot and hopefully provide some examples of how to use `Eff`s and `Stream`s in the \"context\" of `Aff`.\n\n## Getting to work\n\n### Reading configuration\n\nMy chatbot some configuration in a JSON file with the following properties:\n\n* `token` - auth token for my Telegram bot\n* `torscraperPath` - path to my [Torscraper program](http://qiita.com/kimagure/items/5674e3ae9c87262af762)\n* `master` - my Telegram user id, for when I need to send messages that aren't replies\n\nSo I need to read in this file, parse the JSON, then extract the fields (while making sure they are set). Since this only requires one value, I use an `Aff` here.\n\nFor reading the files, there is already a nice library, [purescript-node-fs-aff](https://github.com/purescript-node/purescript-node-fs-aff). It's nice that we don't need to do this manually. We use `readTextFile` which takes an encoding and a filepath.\n\n```haskell\nreadTextFile UTF8 \"./config.json\"\n```\n\nFor parsing the result, there's also another nice library, [purescript-foreign](https://github.com/purescript/purescript-foreign/). This lets us parse JSON and start reading props from it.\n\n```haskell\nparseConfig :: String -> Either ForeignError Config\nparseConfig json = do\n  value <- parseJSON json\n  token <- readProp \"token\" value\n  torscraperPath <- readProp \"torscraperPath\" value\n  master <- readProp \"master\" value\n  pure\n    { token: token\n    , torscraperPath: torscraperPath\n    , master: master\n    }\n```\n\nThis seems meatier, but uses things we've seen before. In this `do` block, each binding is the result of taking the `Right` of our `Either` representing a successful operation. `Left` is a failure, and would short-circuit this to return the left side, which in this case is a `ForeignError`. After all these `readProp`s, we then lift our record of type `Config` into the `Either` as `Right Config`.\n\nFor putting these together, we can use the generic `map/<$>` operator on an `Aff` to map a function to what is inside, and we get what we're looking for.\n\n```haskell\ngetConfig :: forall e. Aff (fs :: FS | e) (Either ForeignError Config)\ngetConfig = parseConfig <$> readTextFile UTF8 \"./config.json\"\n```\n\nThe config parsing is a key point in our application's startup, so I'm going to make sure that the user is notified when they mess this up, which means that I'll be handling the `Left` case of the `Either` to notify the user their config file is malformed. The `Right` case will resume as needed.\n\n```haskell\nmain = launchAff $ do\n  config <- getConfig\n  case config of\n    Left e -> liftEff' $ log \"config.json is malformed. closing.\"\n    Right {token, torscraperPath, master} -> do\n      [...]\n```\n\nYou'll see here that I've used `liftEff'`, because I'm using `log` from `Control.Monad.Eff.Console`. This lifts the `Eff` into an `Aff` so that it can be used in the `do` block of the `launchAff`.\n\nThis will come up again and again, in this article and in other code you write.\n\n### Starting up our bot and bot methods\n\nThe actual Telegram API is humongous, and this being just a hacky project, I have taken many liberties to make this as easy as possible for me.\n\nFor one, I made connecting dead easy:\n\n```js\nexports.connect = function (token) {\n  return function () {\n    return new TelegramBot(token, {polling: true});\n  };\n}\n```\n\n```haskell\ntype TelegramEffects e = (telegram :: TELEGRAM, console :: CONSOLE | e)\n\nforeign import data TELEGRAM :: !\n\nforeign import data Bot :: *\n\nforeign import connect :: forall e. Token -> Eff (TelegramEffects e) Bot\n```\n\nI've made a convenience type to work from called `TelegramEffects`, but importantly I've added `TELEGRAM` as an effect and `Bot` as a data type for my bot instance. My `connect` function simply returns a bot instance running through the instance, and so usage looks like our logging function above:\n\n```haskell\nbot <- liftEff $ connect token\n```\n\nWith sending messages, I also have a relatively simple FFI function:\n\n```js\nexports._sendMessage = function(bot, id, message) {\n  return function () {\n    bot.sendMessage(id, message);\n  };\n}\n```\n\n```haskell\nforeign import _sendMessage :: forall e.\n  Fn3\n    Bot\n    Int\n    String\n    (Eff (TelegramEffects e) Unit)\n```\n\nThis `Fn3` thing may be unfamiliar to you. It's the uncurried function helper, so that you don't have to write fully curried FFI functions. `Fn3` is of kind `* -> * -> * -> * -> *`, which looks scary at first, but really means that it takes four arguments, which aligns to the three arguments and one return value. This has an accompanying `runFn3` function for actually running these uncurried functions.\n\nMy `sendMessage` then has some logic about when messages should actually be sent:\n\n```haskell\ndata RequestOrigin\n  = User\n  | Timer\n\ntype Request =\n  { origin :: RequestOrigin\n  , id :: Id\n  }\n\nsendMessage :: forall e. Bot -> Result -> Eff (TelegramEffects e) Unit\nsendMessage bot {id, output, origin} = do\n  case origin of\n    Timer ->\n      case indexOf \"nothing new to download\" output of\n        Just _ -> log \"timer found nothing\" -- don't care about being notified here!\n        _ -> send\n    _ -> send\n  where\n    send = do\n      log output\n      runFn3 _sendMessage bot id output\n```\n\nMy message listening function is the worst, since I was too lazy to properly set up anything, including traversing the complex object structure to get just a few pieces of information I need. I \"leave this\" as an \"exercise for the reader\" if they would like to implement this correctly:\n\n```js\nexports.addMessagesListener = function (bot, User, eff) {\n  return function () {\n    bot.onText(/^get$/i, function (msg, match) {\n      var fromId = msg.from.id;\n      eff({\n        origin: User,\n        id: fromId\n      })();\n      console.log('got request from', fromId);\n    });\n  };\n}\n```\n\n```haskell\nforeign import addMessagesListener :: forall e.\n  Fn3\n    Bot\n    RequestOrigin\n    (Request -> Eff (TelegramEffects e) Unit)\n    (Eff (TelegramEffects e) Unit)\n```\n\n### Running our Torscraper\n\nThis is another case where we can take advantage of existing code written in [purescript-node-child-process](https://github.com/purescript-node/purescript-node-child-process) and [purescript-node-streams](https://github.com/purescript-node/purescript-node-streams). This allows me to spawn a child process and add some handlers like usual. I collect the output using a ref that I write to.\n\n```haskell\nrunTorscraper :: forall e.\n  String ->\n  Request ->\n  Aff\n    ( ref :: REF\n    , cp :: CHILD_PROCESS\n    | e\n    )\n    Result\nrunTorscraper path request = makeAff \\e s -> do\n  ref <- newRef \"\"\n  process <- spawn \"node\" [\"index.js\"] $\n    defaultSpawnOptions { cwd = Just path }\n  result <- try $ onDataString (stdout process) UTF8 \\string ->\n    modifyRef ref $ append string\n  case result of\n    Right _ -> do\n      onError process $ toStandardError >>> e\n      onExit process \\exit -> do\n        output <- readRef ref\n        s { id: request.id, origin: request.origin, output: output }\n    Left err -> e err\n```\n\n### Putting it into `Streams`\n\nNow that we have the pieces, we can start putting them into place.\n\nThe `addMessagesListener` from before can be used with `fromCallback` from purescript-xstream to create a `Stream`. This `fromCallback` actually returns a `Eff e (Stream a)`, so we need to lift this like before.\n\n```haskell\nrequests <- liftEff $ fromCallback $ runFn3 addMessagesListener bot User\n```\n\nSimilarly, we use `periodic` from purescript-xstream and then map a `const timerRequest` to it, so that every tick of the timer will just give us this static request.\n\n```haskell\nlet timerRequest = {id: master, origin: Timer}\ntimer <- liftEff $ periodic (60 * 60 * 1000)\nlet timer' = const timerRequest <$> timer\n```\n\nThen we need to take these two `Stream`s, merge with another `Stream` that will make sure this gets called when the bot starts up, and switch-map an `Eff`. A switch-map is just like a normal flatMap, where you pass in a function of `a -> f a`, but in the context of `Stream`s/observables, the subscription to the previous provided `Stream` is disposed. This is a bit of a dense explanation, but there are better explanations and examples online like [this StackOverflow question](http://stackoverflow.com/questions/28175702/what-is-the-difference-between-flatmap-and-switchmap-in-rxjava).\n\nSo by using `switchMapEff` in purescript-xstream, we can switch-map `Eff`s to produce `Stream`s.\n\n```haskell\nresults <- liftEff $ (requests <|> timer' <|> pure timerRequest) `switchMapEff` \\request ->\n  fromAff $ runTorscraper torscraperPath request\n```\n\nThe `alt/<|>` operator is used here to merge all the values emitted by the streams.\n\nFinally we can just lift the subscribe function and we're done:\n\n```haskell\nliftEff' $ addListener\n  { next: sendMessage bot\n  , error: message >>> log\n  , complete: const $ pure unit\n  }\n  results\n```\n\n## Conclusion\n\nHopefully this has been kind of useful to see how you can write your own Purescript programs and how you can use `Eff`s and `Stream`s in the \"context\" of `Aff`.\n\nIf you made it this far, thanks for reading! And please do send me corrections or suggestions, as I'm sure I do not have the best solutions here.\n\n## Links\n\n* My Telegram bot code used in this post https://github.com/justinwoo/simple-rpc-telegram-bot/\n* The previous post, \"Async in Purescript is fun and easy\" http://qiita.com/kimagure/items/2ebce1399bac00c79656\n* The post about my Torscraper, \"Making a simple node program with Purescript\" http://qiita.com/kimagure/items/5674e3ae9c87262af762\n* purescript-aff https://github.com/slamdata/purescript-aff/\n* purescript-xstream https://github.com/justinwoo/purescript-xstream\n* purescript-node-fs-aff https://github.com/purescript-node/purescript-node-fs-aff\n* purescript-node-child-process https://github.com/purescript-node/purescript-node-child-process\n* purescript-node-streams https://github.com/purescript-node/purescript-node-streams\n", "tags": ["purescript", "Node.js", "JavaScript"]}