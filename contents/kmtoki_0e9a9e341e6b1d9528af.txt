{"context": "SECD\u30de\u30b7\u30f3\n\nSECD\u30de\u30b7\u30f3\u3068\u306f\u3001\u95a2\u6570\u578b\u8a00\u8a9e\u306e\u30b3\u30f3\u30d1\u30a4\u30e9\u306e\u30bf\u30fc\u30b2\u30c3\u30c8\uff08\u76ee\u7684\u6a5f\u68b0\uff09\u3092\u610f\u56f3\u3057\u3001\u5f8c\u306b\u5927\u304d\u306a\u5f71\u97ff\u3092\u4e0e\u3048\u305f\u62bd\u8c61\u6a5f\u68b0\u3067\u3042\u308b\u3002SECD \u306f Stack\uff08\u30b9\u30bf\u30c3\u30af\uff09\u3001Environment\uff08\u74b0\u5883\uff09\u3001Code\uff08\u30b3\u30fc\u30c9\uff09\u3001Dump\uff08\u30c0\u30f3\u30d7\uff09\u306e\u7565\u3067\u3042\u308a\u3001\u305d\u308c\u305e\u308c\u4eee\u60f3\u6a5f\u68b0\u306b\u3042\u308b\u30ec\u30b8\u30b9\u30bf\u306e\u540d\u79f0\u3068\u306a\u3063\u3066\u3044\u308b\n\nSECD\u30de\u30b7\u30f3\u3067\u7d14Lisp\u3092\u5b9f\u88c5\u3057\u307e\u3059\n\u4eca\u56de\u306fhaskell\u3067\u66f8\u304d\u307e\u3059\u3001\u3084\u3063\u305f\u306d\ngithub\n\nSpec\ndef\u306e\u4ee3\u308f\u308a\u306blet/letrec\u3092\u4f7f\u7528\n\u8db3\u3057\u7b97\u3068\u6570\u5024\u30ea\u30c6\u30e9\u30eb\u3092\u8ffd\u52a0\nEnvironment\u306fMap\u3067\u5909\u6570\u7ba1\u7406\n\nInternal\n\u5185\u90e8\u3067\u5171\u7528\u3059\u308bdata\u3084type\u306a\u3069\n\nSECD/Internal.hs\nmodule SECD.Internal where\n\nimport Prelude hiding (EQ)\nimport qualified Data.Map as M\nimport Data.List (intersperse)\n\ndata SECD \n  = SECD {\n    stack :: Stack,\n    env   :: Env,\n    code  :: Code,\n    dump  :: Dump\n  } deriving Show\n\ntype Stack = [Lisp]\ntype Env = M.Map String Lisp\ntype Code = [CodeOP]\ntype Dump = [DumpOP]\n\ndata CodeOP \n  = LET String\n  | LD String\n  | LDC Lisp\n  | LDF [String] Code\n  | LIST Int\n  | AP\n  | RET\n  | RAP\n  | SEL Code Code\n  | JOIN\n  | CONS\n  | CAR\n  | CDR\n  | EQ\n  | ATOM\n  | ADD\n  | PUTS \n  | DEBUG\n  | STOP\n  deriving Show\n\ndata DumpOP \n  = DumpAP Stack Env Code\n  | DumpSEL Code\n  deriving Show\n\ndata Lisp\n  = LList [Lisp]\n  | LAtom String\n  | LNum Int\n  | LTrue\n  | LFalse\n  | LNil\n  | LCons Lisp Lisp\n  | LClosure [String] Code Env\n  | LError String\n\ninstance Eq Lisp where\n  LList a == LList b = a == b\n  LCons a b == LCons c d = a == c && b == d\n  LAtom a == LAtom b = a == b\n  LNum a  == LNum b  = a == b\n  LTrue   == LTrue   = True\n  LFalse  == LFalse  = True\n  LNil    == LNil    = True\n  _       == _       = False\n\ninstance Show Lisp where\n  show l = case l of\n    LList ls -> \"(\" ++ (concat $ intersperse \" \" $ map show ls) ++ \")\"\n    LAtom s -> s\n    LNum n -> show n\n    LTrue -> \"#true\"\n    LFalse -> \"#false\"\n    LNil -> \"#nil\"\n    LCons a b -> \"(cons \" ++ show a ++ \" \" ++ show b ++ \")\"\n    LClosure as c e -> \"(lam (\" ++ (concat $ intersperse \" \" $ as) ++ \") Code\"\n    LError e -> \"ERROR(\" ++ e ++ \")\"\n\n\n\nParser\nparsec\u69d8\u69d8\n\nSECD/Parser.hs\nmodule SECD.Parser (parse) where\n\nimport SECD.Internal\n\nimport Control.Applicative\nimport qualified Text.Parsec as T\n\nparse :: T.SourceName -> String -> Either T.ParseError Lisp\nparse = T.parse sexpr\n\nsexpr = spaces *> (atom <|> list) <* spaces\n\nt p = spaces *> p <* spaces\n\nspaces = T.skipMany (T.space <|> T.tab <|> T.newline)\n\natom = \n  (LNum . read) <$> ((++) <$> T.option \"\" (T.string \"-\")  <*> (T.many1 $ T.digit)) <|>\n  (T.string \"#\" *>\n    (LFalse <$ T.string \"false\" <|>\n     LTrue <$ T.string \"true\" <|>\n     LNil <$ T.string \"nil\")) <|>\n  LAtom <$> (T.many1 $ T.noneOf \"(#)' \\t\\n\")\n\nlist = LList <$> (T.string \"(\" *> T.many sexpr  <* T.string \")\")\n\n\n\nCompiler\nAST\u304b\u3089\u6a5f\u68b0\u8a9e\u3078\u5909\u63db\n\u30d1\u30bf\u30fc\u30f3\u30de\u30c3\u30c1\u3068Either Functor/Monad\u3067\u30b9\u30c3\u30ad\u30ea\u3057\u3066\u307e\u3059\n\u826f\u3044\n\nSECD/Compiler.hs\nmodule SECD.Compiler (compile) where\n\nimport SECD.Internal\nimport Prelude hiding (EQ)\n\ncompile :: Lisp -> Either String Code\ncompile = compile' []\n\ncompile' :: [String] -> Lisp -> Either String Code\ncompile' rs lisp = case lisp of\n  LAtom \"debug\" -> Right $ [DEBUG]\n  LAtom a -> Right $ [LD a]\n  LList ls' -> case ls' of\n    [] -> Right $ [LDC $ LList []]\n    LAtom \"let\"    : ls -> let' rs ls\n    LAtom \"letrec\" : ls -> letrec rs ls\n    LAtom \"lam\"    : ls -> lam rs ls\n    LAtom \"if\"     : ls -> if' rs ls\n    LAtom \"list\"   : ls -> list rs ls\n    LAtom \"eq\"     : ls -> eq rs ls\n    LAtom \"atom\"   : ls -> atom rs ls\n    LAtom \"cons\"   : ls -> cons rs ls\n    LAtom \"car\"    : ls -> car rs ls\n    LAtom \"cdr\"    : ls -> cdr rs ls\n    LAtom \"+\"      : ls -> add rs ls\n    LAtom \"puts\"   : ls -> puts rs ls\n    LAtom \"do\"     : ls -> do' rs ls\n    _ -> apply rs ls'\n  _ -> Right $ [LDC lisp]\n\nlet' rs ls = case ls of\n  LList [LAtom name, expr] : body -> do\n    let rs' = filter (/= name) rs\n    e <- compile' rs' expr\n    b <- concat <$> mapM (compile' rs') body \n    pure $ e ++ [LET name] ++ b\n  _ ->\n    Left $ \"syntax error let: \" ++ show ls\n\nletrec rs ls = case ls of\n  LList [LAtom name, expr] : body -> do\n    let rs' = name : rs\n    e <- compile' rs' expr\n    b <- concat <$> mapM (compile' rs') body\n    pure $ e ++ [LET name] ++ b\n  _ ->\n    Left $ \"syntax error letrec: \" ++ show ls\n\nlam rs ls = case ls of\n  [LList args, body] ->\n    (\\a -> [LDF (map (\\(LAtom a) -> a) args) $ a ++ [RET]]) <$> compile' rs body\n  [LAtom args, body] ->\n    (\\a -> [LDF [args] $ a ++ [RET]]) <$> compile' rs body\n  _ ->\n    Left $ \"syntax error lam: \" ++ show ls\n\nif' rs ls = case ls of\n  [b, t, f] -> do\n    b' <- compile' rs b\n    t' <- compile' rs t\n    f' <- compile' rs f\n    pure $ b' ++ [SEL (t' ++ [JOIN]) (f' ++ [JOIN])]\n  _ ->\n    Left $ \"syntax error if: \" ++ show ls\n\nlist rs ls = case ls of\n  list ->\n    ((++ [LIST $ length list]) . concat) <$> mapM (compile' rs) ls\n\neq rs ls = case ls of\n  [a, b] ->\n    (++ [EQ]) <$> ((++) <$> compile' rs b <*> compile' rs a)\n  _ -> \n    Left $ \"syntax error eq: \" ++ show ls\n\natom rs ls = case ls of\n  [a] -> \n    (++ [ATOM]) <$> compile' rs a\n  _ ->\n    Left $ \"syntax error atom: \" ++ show ls\n\n\ncons rs ls = case ls of\n  [a, b] ->\n    (++ [CONS]) <$> ((++) <$> compile' rs b <*> compile' rs a)\n  _ -> Left $ \"syntax error cons: \" ++ show ls\n\ncar rs ls = case ls of\n  [a] ->\n    (++ [CAR]) <$> compile' rs a\n  _ ->\n    Left $ \"syntax error car: \" ++ show ls\n\ncdr rs ls = case ls of\n  [a] ->\n    (++ [CDR]) <$> compile' rs a \n  _ ->\n    Left $ \"syntax error cdr: \" ++ show ls\n\nadd rs ls = case ls of \n  [a,b] ->\n    (++ [ADD]) <$> ((++) <$> compile' rs b <*> compile' rs a)\n  _ ->\n    Left $ \"syntax error +: \" ++ show ls\n\nputs rs ls = case ls of \n  [a] -> \n    (++ [PUTS]) <$> compile' rs a \n  _ ->\n    Left $ \"syntax error puts: \" ++ show ls\n\ndo' rs ls = \n  concat <$> mapM (compile' rs) ls\n\napply rs (lam : args) = do\n  args' <- mapM (compile' rs) $ reverse args\n  lam' <- compile' rs lam\n  pure $ concat args' ++ [LIST $ length args] ++ lam' ++ ap\n  where\n    ap = case lam of \n      LAtom name -> if elem name rs then [RAP] else [AP]\n      _ -> [AP]\n\n\n\nVM\nSECD\u30de\u30b7\u30f3\u672c\u4f53\nRAP\u3092\u3046\u307e\u304f\u5b9f\u88c5\u3067\u304d\u305a\u4e00\u6708\u30cf\u30de\u3063\u3066\u3044\u305f(\u30fb\u03c9\u30fb\uff40)\n\nSECD/VM.hs\nmodule SECD.VM (initVM,runVM) where\n\nimport SECD.Internal\n\nimport Prelude hiding (EQ)\nimport qualified Data.Map as M\n\ninitVM :: SECD\ninitVM = SECD [] M.empty [] []\n\nrunVM :: SECD -> IO SECD\nrunVM secd@SECD {..} = case code of\n  [] -> pure secd\n  DEBUG:ops -> do\n    putStrLn $ \"SECD:\"\n    putStrLn $ \"stack: \" ++ show stack\n    putStrLn $ \"code: \" ++ show code \n    putStrLn $ \"env: \" ++ show env\n    putStrLn $ \"dump: \" ++ show dump\n    runVM $ secd { code = ops }\n  PUTS:ops -> do\n    print $ head stack\n    runVM $ secd { stack = stack, code = ops }\n  STOP:_ -> pure secd \n  op:ops -> runVM $ flip ($) secd { code = ops } $ case op of\n    LET a   -> let' a\n    LD a    -> ld a\n    LDC l   -> ldc l\n    LDF a c -> ldf a c\n    LIST n  -> list n\n    AP      -> ap\n    RET     -> ret\n    RAP     -> rap\n    SEL a b -> sel a b\n    JOIN    -> join\n    CONS    -> cons\n    CAR     -> car\n    CDR     -> cdr\n    EQ      -> eq\n    ATOM    -> atom\n    ADD     -> add\n\nvmError :: String -> SECD -> SECD\nvmError s secd@SECD {..} = \n  secd {\n    stack = LError s : stack,\n    code = STOP : code\n  }\n\nld :: String -> SECD -> SECD\nld a secd@SECD {..} = \n  if M.member a env then\n    secd {\n      stack = (env M.! a) : stack\n    }\n  else\n    vmError (\"ld not found \" ++ a) secd\n\nldc :: Lisp -> SECD -> SECD\nldc l secd@SECD {..} =\n  secd {\n    stack = l : stack\n  }\n\nldf :: [String] -> Code -> SECD -> SECD\nldf as c secd@SECD {..} =\n  secd {\n    stack = LClosure as c env : stack\n  }\n\nlist :: Int -> SECD -> SECD\nlist n secd@SECD {..} =\n  secd {\n    stack = LList (take n stack) : drop n stack\n  }\n\nap :: SECD -> SECD\nap secd@SECD { stack = LClosure as c e : LList args : ss, ..} =\n  secd {\n    stack = [],\n    env = M.union (M.fromList (zip as args)) e,\n    code = c,\n    dump = DumpAP ss env code : dump\n  }\nap secd = vmError \"ap error\" secd\n\nret :: SECD -> SECD\nret secd@SECD {stack = s : ss, dump = DumpAP stack env code : dump } =\n  secd {\n    stack = s : stack,\n    env = env,\n    code = code,\n    dump = dump\n  }\nret secd = vmError \"ret error\" secd\n\nrap :: SECD -> SECD\nrap secd@SECD { stack = LClosure as c e : LList args : ss, ..} =\n  secd {\n    stack = [],\n    env = M.union (M.union (M.fromList $ zip as args) e) env,\n    code = c,\n    dump = DumpAP ss env code : dump\n  }\n\nsel :: Code -> Code -> SECD -> SECD\nsel t f secd@SECD {stack = s : ss, ..} = case s of\n  LTrue  -> secd { code = t, dump = DumpSEL code : dump }\n  LFalse -> secd { code = f, dump = DumpSEL code : dump }\n  _      -> vmError (\"sel error: expect bool. not \" ++ show s) secd\nsel t f secd@SECD { stack = [] } = \n  vmError (\"vm error sel: expect bool. stack is empty\") secd\n\njoin :: SECD -> SECD\njoin secd@SECD { dump = DumpSEL c : ds } =\n  secd {\n    code = c,\n    dump = ds\n  }\n\nlet' :: String -> SECD -> SECD\nlet' a secd@SECD { stack = s : ss } =\n  secd {\n    stack = ss,\n    env = M.insert a s $ env secd\n  }\n\ncons :: SECD -> SECD\ncons secd@SECD { stack =  a : b : ss } =\n  secd {\n    stack = LCons a b : ss\n  }\n\ncar :: SECD -> SECD\ncar secd@SECD { stack = LCons a _ : ss } =\n  secd {\n    stack = a : ss\n  }\ncar secd@SECD { stack = s : ss } =\n  vmError (\"car expect cons. not \" ++ show s) secd\n\ncdr :: SECD -> SECD\ncdr secd@SECD { stack = LCons _ a : ss } = \n  secd { \n    stack = a : ss \n  }\ncdr secd@SECD { stack = s : ss } =\n  vmError (\"cdr expect cons. not \" ++ show s) secd\n\neq :: SECD -> SECD\neq secd@SECD { stack = a : b : ss } =\n  secd {\n    stack = (if a == b then LTrue else LFalse) : ss\n  }\n\natom :: SECD -> SECD\natom secd@SECD { stack = a : ss } =\n  secd {\n    stack = s : ss\n  }\n  where\n    s = case a of\n      LClosure _ _ _ -> LFalse\n      LList _ -> LFalse\n      LCons _ _ -> LFalse\n      LError _ -> LFalse\n      _ -> LTrue\n\nadd :: SECD -> SECD\nadd secd@SECD { stack = LNum a : LNum b : ss } =\n  secd {\n    stack = LNum (a + b) : ss\n  }\n\n\n\nSECD\n\u4fbf\u5b9c\u4e0a\n\nSECD.hs\nmodule SECD (runLisp, runLispFile) where\n\nimport SECD.Internal\nimport SECD.Parser\nimport SECD.Compiler\nimport SECD.VM\n\nrunLisp' :: String -> String -> IO ()\nrunLisp' s ss = do\n  case parse s ss of\n    Left err -> print err\n    Right ast ->\n      case compile ast of\n        Left err -> putStrLn err\n        Right code -> do\n          secd <- runVM $ initVM { code = code }\n          print $ head $ stack secd\n\nrunLisp :: String -> IO ()\nrunLisp = runLisp' \"runLisp\"\n\nrunLispFile :: String -> IO ()\nrunLispFile s = do\n  ss <- readFile s\n  runLisp' s ss\n\n\n\nfib\n\u30d5\u30a3\u30dc\u30ca\u30c3\u30c1\u6570\u3067\u3082\u3084\u3063\u3066\u898b\u307e\u3057\u3087\n(letrec \n  (fib \n    (lam n\n      (if (eq n 0)\n        0\n        (if (eq n 1)\n          1\n          (+ (fib (+ n -2)) (fib (+ n -1)))))))\n  (fib 30))\n\n\u276f time stack exec lisp lisp/fib.lisp\n832040\nstack exec lisp lisp/fib.lisp  6.02s user 1.14s system 148% cpu 4.819 total\n\n\u3061\u306a\u307f\u306bruby\u3060\u3068\n\nfib.rb\ndef fib n\n  if n == 0\n    0\n  elsif n == 1\n    1\n  else\n    fib(n - 2) + fib(n - 1)\n  end\nend\n\np fib(30)\n\n\n\u276f time ruby fib.rb\n832040\nruby fib.rb  0.27s user 0.01s system 97% cpu 0.292 total\n\n30\u500d\u3082\u9045\u3044\u3051\u3069\u3001\u3057\u3087\u3046\u304c\u306a\u3044\u306d\n\u7b54\u3048\u304c\u3061\u3083\u3093\u3068\u3042\u3063\u3066\u308b\u3060\u3051\u826f\u3057\u3068\u3057\u307e\u3057\u3087\u3046\n\nStrict, StrictData\n{-# LANGUAGE Strict, StrictData #-}\u3068\u5168\u30d5\u30a1\u30a4\u30eb\u306e\u982d\u306b\u3064\u3051\u3066rebuild\n17\u500d\u307e\u3067\u6539\u5584\n\u276f time stack exec lisp lisp/fib.lisp\n832040\nstack exec lisp lisp/fib.lisp  4.69s user 0.79s system 133% cpu 4.117 total\n\n\nstack build --fast\nghc\u306e\u6700\u9069\u5316\u30aa\u30d7\u30b7\u30e7\u30f3\u3092\u30aa\u30f3\u306b\u3057\u3066rebuild\n56\u500d\u307e\u3067\u60aa\u5316\nfast\u3068\u306f\u4e00\u4f53\n--fast\u30aa\u30d7\u30b7\u30e7\u30f3\u306f\u6700\u9069\u5316\u3092\u30aa\u30d5\u306b\u3059\u308b\u307f\u305f\u3044\u3067\u3059\u3001\u7d1b\u3089\u308f\u3057\u3044\u306d\n\u276f time stack exec lisp lisp/fib.lisp\n832040\nstack exec lisp lisp/fib.lisp  15.12s user 2.39s system 136% cpu 12.847 total\n\n\nZ Combinator\n\u304a\u307e\u3051\nY Combinator\u306e\u5024\u6e21\u3057\u8a55\u4fa1\u7248\n\u7acb\u6d3e\u306b\u52d5\u304d\u307e\u3059\u3088\n\nz.lisp\n(let \n  (z\n    (lam f\n      ((lam x\n        (f\n          (lam y ((x x) y))))\n       (lam x\n        (f\n          (lam y ((x x) y)))))))\n\n  (let \n    (sum\n      (lam f\n        (lam x\n          (if (eq x 1)\n            x\n            (+ x (f (+ x -1)))))))\n\n    ((z sum) 10))) ; => 55\n\n\n\n\u5c0f\u4e26\u307e\u3068\u3081\nSECD\u30de\u30b7\u30f3\u308f\u308a\u3068\u7c21\u5358\u306a\u304c\u3089\u3082\u5341\u5206\u306a\u8868\u73fe\u529b\u304c\u3042\u308a\u7d20\u6674\u3089\u3057\u3044\nRAP\u304c\u305f\u307e\u3089\u3093\u3067\u3059\n\u4e45\u3057\u3076\u308a\u306bhaskell\u66f8\u3044\u3066\u898b\u307e\u3057\u305f\u304c\u6c17\u6301\u3061\u3088\u3059\u304e\u3001stack\u3082\u624b\u8efd\u3067\u826f\u3057\n\n[SECD\u30de\u30b7\u30f3](https://ja.wikipedia.org/wiki/SECD%E3%83%9E%E3%82%B7%E3%83%B3)\n\n> SECD\u30de\u30b7\u30f3\u3068\u306f\u3001\u95a2\u6570\u578b\u8a00\u8a9e\u306e\u30b3\u30f3\u30d1\u30a4\u30e9\u306e\u30bf\u30fc\u30b2\u30c3\u30c8\uff08\u76ee\u7684\u6a5f\u68b0\uff09\u3092\u610f\u56f3\u3057\u3001\u5f8c\u306b\u5927\u304d\u306a\u5f71\u97ff\u3092\u4e0e\u3048\u305f\u62bd\u8c61\u6a5f\u68b0\u3067\u3042\u308b\u3002SECD \u306f Stack\uff08\u30b9\u30bf\u30c3\u30af\uff09\u3001Environment\uff08\u74b0\u5883\uff09\u3001Code\uff08\u30b3\u30fc\u30c9\uff09\u3001Dump\uff08\u30c0\u30f3\u30d7\uff09\u306e\u7565\u3067\u3042\u308a\u3001\u305d\u308c\u305e\u308c\u4eee\u60f3\u6a5f\u68b0\u306b\u3042\u308b\u30ec\u30b8\u30b9\u30bf\u306e\u540d\u79f0\u3068\u306a\u3063\u3066\u3044\u308b\n\nSECD\u30de\u30b7\u30f3\u3067[\u7d14Lisp](http://qiita.com/kumatoki/items/7a7fda1b73c87c793a9b)\u3092\u5b9f\u88c5\u3057\u307e\u3059\n\u4eca\u56de\u306fhaskell\u3067\u66f8\u304d\u307e\u3059\u3001\u3084\u3063\u305f\u306d\n[github](https://github.com/kmtoki/SECD)\n\n# Spec\ndef\u306e\u4ee3\u308f\u308a\u306blet/letrec\u3092\u4f7f\u7528\n\u8db3\u3057\u7b97\u3068\u6570\u5024\u30ea\u30c6\u30e9\u30eb\u3092\u8ffd\u52a0\n\nEnvironment\u306fMap\u3067\u5909\u6570\u7ba1\u7406\n\n# Internal\n\u5185\u90e8\u3067\u5171\u7528\u3059\u308bdata\u3084type\u306a\u3069\n\n```haskell:SECD/Internal.hs\nmodule SECD.Internal where\n\nimport Prelude hiding (EQ)\nimport qualified Data.Map as M\nimport Data.List (intersperse)\n\ndata SECD \n  = SECD {\n    stack :: Stack,\n    env   :: Env,\n    code  :: Code,\n    dump  :: Dump\n  } deriving Show\n\ntype Stack = [Lisp]\ntype Env = M.Map String Lisp\ntype Code = [CodeOP]\ntype Dump = [DumpOP]\n\ndata CodeOP \n  = LET String\n  | LD String\n  | LDC Lisp\n  | LDF [String] Code\n  | LIST Int\n  | AP\n  | RET\n  | RAP\n  | SEL Code Code\n  | JOIN\n  | CONS\n  | CAR\n  | CDR\n  | EQ\n  | ATOM\n  | ADD\n  | PUTS \n  | DEBUG\n  | STOP\n  deriving Show\n\ndata DumpOP \n  = DumpAP Stack Env Code\n  | DumpSEL Code\n  deriving Show\n\ndata Lisp\n  = LList [Lisp]\n  | LAtom String\n  | LNum Int\n  | LTrue\n  | LFalse\n  | LNil\n  | LCons Lisp Lisp\n  | LClosure [String] Code Env\n  | LError String\n\ninstance Eq Lisp where\n  LList a == LList b = a == b\n  LCons a b == LCons c d = a == c && b == d\n  LAtom a == LAtom b = a == b\n  LNum a  == LNum b  = a == b\n  LTrue   == LTrue   = True\n  LFalse  == LFalse  = True\n  LNil    == LNil    = True\n  _       == _       = False\n\ninstance Show Lisp where\n  show l = case l of\n    LList ls -> \"(\" ++ (concat $ intersperse \" \" $ map show ls) ++ \")\"\n    LAtom s -> s\n    LNum n -> show n\n    LTrue -> \"#true\"\n    LFalse -> \"#false\"\n    LNil -> \"#nil\"\n    LCons a b -> \"(cons \" ++ show a ++ \" \" ++ show b ++ \")\"\n    LClosure as c e -> \"(lam (\" ++ (concat $ intersperse \" \" $ as) ++ \") Code\"\n    LError e -> \"ERROR(\" ++ e ++ \")\"\n```\n\n# Parser\nparsec\u69d8\u69d8\n\n```haskell:SECD/Parser.hs\nmodule SECD.Parser (parse) where\n\nimport SECD.Internal\n\nimport Control.Applicative\nimport qualified Text.Parsec as T\n\nparse :: T.SourceName -> String -> Either T.ParseError Lisp\nparse = T.parse sexpr\n\nsexpr = spaces *> (atom <|> list) <* spaces\n\nt p = spaces *> p <* spaces\n\nspaces = T.skipMany (T.space <|> T.tab <|> T.newline)\n\natom = \n  (LNum . read) <$> ((++) <$> T.option \"\" (T.string \"-\")  <*> (T.many1 $ T.digit)) <|>\n  (T.string \"#\" *>\n    (LFalse <$ T.string \"false\" <|>\n     LTrue <$ T.string \"true\" <|>\n     LNil <$ T.string \"nil\")) <|>\n  LAtom <$> (T.many1 $ T.noneOf \"(#)' \\t\\n\")\n\nlist = LList <$> (T.string \"(\" *> T.many sexpr  <* T.string \")\")\n```\n\n# Compiler\nAST\u304b\u3089\u6a5f\u68b0\u8a9e\u3078\u5909\u63db\n\u30d1\u30bf\u30fc\u30f3\u30de\u30c3\u30c1\u3068Either Functor/Monad\u3067\u30b9\u30c3\u30ad\u30ea\u3057\u3066\u307e\u3059\n\u826f\u3044\n\n```haskell:SECD/Compiler.hs\nmodule SECD.Compiler (compile) where\n\nimport SECD.Internal\nimport Prelude hiding (EQ)\n\ncompile :: Lisp -> Either String Code\ncompile = compile' []\n\ncompile' :: [String] -> Lisp -> Either String Code\ncompile' rs lisp = case lisp of\n  LAtom \"debug\" -> Right $ [DEBUG]\n  LAtom a -> Right $ [LD a]\n  LList ls' -> case ls' of\n    [] -> Right $ [LDC $ LList []]\n    LAtom \"let\"    : ls -> let' rs ls\n    LAtom \"letrec\" : ls -> letrec rs ls\n    LAtom \"lam\"    : ls -> lam rs ls\n    LAtom \"if\"     : ls -> if' rs ls\n    LAtom \"list\"   : ls -> list rs ls\n    LAtom \"eq\"     : ls -> eq rs ls\n    LAtom \"atom\"   : ls -> atom rs ls\n    LAtom \"cons\"   : ls -> cons rs ls\n    LAtom \"car\"    : ls -> car rs ls\n    LAtom \"cdr\"    : ls -> cdr rs ls\n    LAtom \"+\"      : ls -> add rs ls\n    LAtom \"puts\"   : ls -> puts rs ls\n    LAtom \"do\"     : ls -> do' rs ls\n    _ -> apply rs ls'\n  _ -> Right $ [LDC lisp]\n\nlet' rs ls = case ls of\n  LList [LAtom name, expr] : body -> do\n    let rs' = filter (/= name) rs\n    e <- compile' rs' expr\n    b <- concat <$> mapM (compile' rs') body \n    pure $ e ++ [LET name] ++ b\n  _ ->\n    Left $ \"syntax error let: \" ++ show ls\n    \nletrec rs ls = case ls of\n  LList [LAtom name, expr] : body -> do\n    let rs' = name : rs\n    e <- compile' rs' expr\n    b <- concat <$> mapM (compile' rs') body\n    pure $ e ++ [LET name] ++ b\n  _ ->\n    Left $ \"syntax error letrec: \" ++ show ls\n\nlam rs ls = case ls of\n  [LList args, body] ->\n    (\\a -> [LDF (map (\\(LAtom a) -> a) args) $ a ++ [RET]]) <$> compile' rs body\n  [LAtom args, body] ->\n    (\\a -> [LDF [args] $ a ++ [RET]]) <$> compile' rs body\n  _ ->\n    Left $ \"syntax error lam: \" ++ show ls\n\nif' rs ls = case ls of\n  [b, t, f] -> do\n    b' <- compile' rs b\n    t' <- compile' rs t\n    f' <- compile' rs f\n    pure $ b' ++ [SEL (t' ++ [JOIN]) (f' ++ [JOIN])]\n  _ ->\n    Left $ \"syntax error if: \" ++ show ls\n\nlist rs ls = case ls of\n  list ->\n    ((++ [LIST $ length list]) . concat) <$> mapM (compile' rs) ls\n\neq rs ls = case ls of\n  [a, b] ->\n    (++ [EQ]) <$> ((++) <$> compile' rs b <*> compile' rs a)\n  _ -> \n    Left $ \"syntax error eq: \" ++ show ls\n\natom rs ls = case ls of\n  [a] -> \n    (++ [ATOM]) <$> compile' rs a\n  _ ->\n    Left $ \"syntax error atom: \" ++ show ls\n\n\ncons rs ls = case ls of\n  [a, b] ->\n    (++ [CONS]) <$> ((++) <$> compile' rs b <*> compile' rs a)\n  _ -> Left $ \"syntax error cons: \" ++ show ls\n\ncar rs ls = case ls of\n  [a] ->\n    (++ [CAR]) <$> compile' rs a\n  _ ->\n    Left $ \"syntax error car: \" ++ show ls\n\ncdr rs ls = case ls of\n  [a] ->\n    (++ [CDR]) <$> compile' rs a \n  _ ->\n    Left $ \"syntax error cdr: \" ++ show ls\n\nadd rs ls = case ls of \n  [a,b] ->\n    (++ [ADD]) <$> ((++) <$> compile' rs b <*> compile' rs a)\n  _ ->\n    Left $ \"syntax error +: \" ++ show ls\n\nputs rs ls = case ls of \n  [a] -> \n    (++ [PUTS]) <$> compile' rs a \n  _ ->\n    Left $ \"syntax error puts: \" ++ show ls\n\ndo' rs ls = \n  concat <$> mapM (compile' rs) ls\n\napply rs (lam : args) = do\n  args' <- mapM (compile' rs) $ reverse args\n  lam' <- compile' rs lam\n  pure $ concat args' ++ [LIST $ length args] ++ lam' ++ ap\n  where\n    ap = case lam of \n      LAtom name -> if elem name rs then [RAP] else [AP]\n      _ -> [AP]\n```\n\n# VM\nSECD\u30de\u30b7\u30f3\u672c\u4f53\nRAP\u3092\u3046\u307e\u304f\u5b9f\u88c5\u3067\u304d\u305a\u4e00\u6708\u30cf\u30de\u3063\u3066\u3044\u305f(\u30fb\u03c9\u30fb\uff40)\n\n```haskell:SECD/VM.hs\nmodule SECD.VM (initVM,runVM) where\n\nimport SECD.Internal\n\nimport Prelude hiding (EQ)\nimport qualified Data.Map as M\n\ninitVM :: SECD\ninitVM = SECD [] M.empty [] []\n\nrunVM :: SECD -> IO SECD\nrunVM secd@SECD {..} = case code of\n  [] -> pure secd\n  DEBUG:ops -> do\n    putStrLn $ \"SECD:\"\n    putStrLn $ \"stack: \" ++ show stack\n    putStrLn $ \"code: \" ++ show code \n    putStrLn $ \"env: \" ++ show env\n    putStrLn $ \"dump: \" ++ show dump\n    runVM $ secd { code = ops }\n  PUTS:ops -> do\n    print $ head stack\n    runVM $ secd { stack = stack, code = ops }\n  STOP:_ -> pure secd \n  op:ops -> runVM $ flip ($) secd { code = ops } $ case op of\n    LET a   -> let' a\n    LD a    -> ld a\n    LDC l   -> ldc l\n    LDF a c -> ldf a c\n    LIST n  -> list n\n    AP      -> ap\n    RET     -> ret\n    RAP     -> rap\n    SEL a b -> sel a b\n    JOIN    -> join\n    CONS    -> cons\n    CAR     -> car\n    CDR     -> cdr\n    EQ      -> eq\n    ATOM    -> atom\n    ADD     -> add\n\nvmError :: String -> SECD -> SECD\nvmError s secd@SECD {..} = \n  secd {\n    stack = LError s : stack,\n    code = STOP : code\n  }\n\nld :: String -> SECD -> SECD\nld a secd@SECD {..} = \n  if M.member a env then\n    secd {\n      stack = (env M.! a) : stack\n    }\n  else\n    vmError (\"ld not found \" ++ a) secd\n\nldc :: Lisp -> SECD -> SECD\nldc l secd@SECD {..} =\n  secd {\n    stack = l : stack\n  }\n\nldf :: [String] -> Code -> SECD -> SECD\nldf as c secd@SECD {..} =\n  secd {\n    stack = LClosure as c env : stack\n  }\n\nlist :: Int -> SECD -> SECD\nlist n secd@SECD {..} =\n  secd {\n    stack = LList (take n stack) : drop n stack\n  }\n\nap :: SECD -> SECD\nap secd@SECD { stack = LClosure as c e : LList args : ss, ..} =\n  secd {\n    stack = [],\n    env = M.union (M.fromList (zip as args)) e,\n    code = c,\n    dump = DumpAP ss env code : dump\n  }\nap secd = vmError \"ap error\" secd\n\nret :: SECD -> SECD\nret secd@SECD {stack = s : ss, dump = DumpAP stack env code : dump } =\n  secd {\n    stack = s : stack,\n    env = env,\n    code = code,\n    dump = dump\n  }\nret secd = vmError \"ret error\" secd\n\nrap :: SECD -> SECD\nrap secd@SECD { stack = LClosure as c e : LList args : ss, ..} =\n  secd {\n    stack = [],\n    env = M.union (M.union (M.fromList $ zip as args) e) env,\n    code = c,\n    dump = DumpAP ss env code : dump\n  }\n\nsel :: Code -> Code -> SECD -> SECD\nsel t f secd@SECD {stack = s : ss, ..} = case s of\n  LTrue  -> secd { code = t, dump = DumpSEL code : dump }\n  LFalse -> secd { code = f, dump = DumpSEL code : dump }\n  _      -> vmError (\"sel error: expect bool. not \" ++ show s) secd\nsel t f secd@SECD { stack = [] } = \n  vmError (\"vm error sel: expect bool. stack is empty\") secd\n\njoin :: SECD -> SECD\njoin secd@SECD { dump = DumpSEL c : ds } =\n  secd {\n    code = c,\n    dump = ds\n  }\n\nlet' :: String -> SECD -> SECD\nlet' a secd@SECD { stack = s : ss } =\n  secd {\n    stack = ss,\n    env = M.insert a s $ env secd\n  }\n\ncons :: SECD -> SECD\ncons secd@SECD { stack =  a : b : ss } =\n  secd {\n    stack = LCons a b : ss\n  }\n\ncar :: SECD -> SECD\ncar secd@SECD { stack = LCons a _ : ss } =\n  secd {\n    stack = a : ss\n  }\ncar secd@SECD { stack = s : ss } =\n  vmError (\"car expect cons. not \" ++ show s) secd\n\ncdr :: SECD -> SECD\ncdr secd@SECD { stack = LCons _ a : ss } = \n  secd { \n    stack = a : ss \n  }\ncdr secd@SECD { stack = s : ss } =\n  vmError (\"cdr expect cons. not \" ++ show s) secd\n\neq :: SECD -> SECD\neq secd@SECD { stack = a : b : ss } =\n  secd {\n    stack = (if a == b then LTrue else LFalse) : ss\n  }\n\natom :: SECD -> SECD\natom secd@SECD { stack = a : ss } =\n  secd {\n    stack = s : ss\n  }\n  where\n    s = case a of\n      LClosure _ _ _ -> LFalse\n      LList _ -> LFalse\n      LCons _ _ -> LFalse\n      LError _ -> LFalse\n      _ -> LTrue\n\nadd :: SECD -> SECD\nadd secd@SECD { stack = LNum a : LNum b : ss } =\n  secd {\n    stack = LNum (a + b) : ss\n  }\n```\n\n# SECD\n\u4fbf\u5b9c\u4e0a\n\n```haskell:SECD.hs\nmodule SECD (runLisp, runLispFile) where\n\nimport SECD.Internal\nimport SECD.Parser\nimport SECD.Compiler\nimport SECD.VM\n\nrunLisp' :: String -> String -> IO ()\nrunLisp' s ss = do\n  case parse s ss of\n    Left err -> print err\n    Right ast ->\n      case compile ast of\n        Left err -> putStrLn err\n        Right code -> do\n          secd <- runVM $ initVM { code = code }\n          print $ head $ stack secd\n\nrunLisp :: String -> IO ()\nrunLisp = runLisp' \"runLisp\"\n\nrunLispFile :: String -> IO ()\nrunLispFile s = do\n  ss <- readFile s\n  runLisp' s ss\n```\n\n# fib\n\u30d5\u30a3\u30dc\u30ca\u30c3\u30c1\u6570\u3067\u3082\u3084\u3063\u3066\u898b\u307e\u3057\u3087\n\n```lisp\n(letrec \n  (fib \n    (lam n\n      (if (eq n 0)\n        0\n        (if (eq n 1)\n          1\n          (+ (fib (+ n -2)) (fib (+ n -1)))))))\n  (fib 30))\n```\n\n```\n\u276f time stack exec lisp lisp/fib.lisp\n832040\nstack exec lisp lisp/fib.lisp  6.02s user 1.14s system 148% cpu 4.819 total\n```\n\n\u3061\u306a\u307f\u306bruby\u3060\u3068\n\n```ruby:fib.rb\ndef fib n\n  if n == 0\n    0\n  elsif n == 1\n    1\n  else\n    fib(n - 2) + fib(n - 1)\n  end\nend\n\np fib(30)\n```\n\n```\n\u276f time ruby fib.rb\n832040\nruby fib.rb  0.27s user 0.01s system 97% cpu 0.292 total\n```\n\n30\u500d\u3082\u9045\u3044\u3051\u3069\u3001\u3057\u3087\u3046\u304c\u306a\u3044\u306d\n\u7b54\u3048\u304c\u3061\u3083\u3093\u3068\u3042\u3063\u3066\u308b\u3060\u3051\u826f\u3057\u3068\u3057\u307e\u3057\u3087\u3046\n\n# Strict, StrictData\n`{-# LANGUAGE Strict, StrictData #-}`\u3068\u5168\u30d5\u30a1\u30a4\u30eb\u306e\u982d\u306b\u3064\u3051\u3066rebuild\n17\u500d\u307e\u3067\u6539\u5584\n\n```\n\u276f time stack exec lisp lisp/fib.lisp\n832040\nstack exec lisp lisp/fib.lisp  4.69s user 0.79s system 133% cpu 4.117 total\n```\n\n# stack build --fast\n\n~~ghc\u306e\u6700\u9069\u5316\u30aa\u30d7\u30b7\u30e7\u30f3\u3092\u30aa\u30f3\u306b\u3057\u3066rebuild\n56\u500d\u307e\u3067\u60aa\u5316\nfast\u3068\u306f\u4e00\u4f53~~\n--fast\u30aa\u30d7\u30b7\u30e7\u30f3\u306f\u6700\u9069\u5316\u3092\u30aa\u30d5\u306b\u3059\u308b\u307f\u305f\u3044\u3067\u3059\u3001\u7d1b\u3089\u308f\u3057\u3044\u306d\n\n```\n\u276f time stack exec lisp lisp/fib.lisp\n832040\nstack exec lisp lisp/fib.lisp  15.12s user 2.39s system 136% cpu 12.847 total\n```\n\n# Z Combinator\n\u304a\u307e\u3051\nY Combinator\u306e\u5024\u6e21\u3057\u8a55\u4fa1\u7248\n\u7acb\u6d3e\u306b\u52d5\u304d\u307e\u3059\u3088\n\n```lisp:z.lisp\n(let \n  (z\n    (lam f\n      ((lam x\n        (f\n          (lam y ((x x) y))))\n       (lam x\n        (f\n          (lam y ((x x) y)))))))\n\n  (let \n    (sum\n      (lam f\n        (lam x\n          (if (eq x 1)\n            x\n            (+ x (f (+ x -1)))))))\n    \n    ((z sum) 10))) ; => 55\n```\n\n# \u5c0f\u4e26\u307e\u3068\u3081\nSECD\u30de\u30b7\u30f3\u308f\u308a\u3068\u7c21\u5358\u306a\u304c\u3089\u3082\u5341\u5206\u306a\u8868\u73fe\u529b\u304c\u3042\u308a\u7d20\u6674\u3089\u3057\u3044\nRAP\u304c\u305f\u307e\u3089\u3093\u3067\u3059\n\u4e45\u3057\u3076\u308a\u306bhaskell\u66f8\u3044\u3066\u898b\u307e\u3057\u305f\u304c\u6c17\u6301\u3061\u3088\u3059\u304e\u3001stack\u3082\u624b\u8efd\u3067\u826f\u3057\n", "tags": ["lisp", "Haskell"]}