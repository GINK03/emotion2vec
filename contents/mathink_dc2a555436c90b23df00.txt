{"context": "\n\n\u307e\u3068\u3081\n\nCoq \u4e0a\u3067\u968f\u4f34\u3068\u30e2\u30ca\u30c9\u3092\u5b9a\u7fa9\nKleisli triple(Haskell \u3067\u3044\u3046 Monad)\u3082\u5b9a\u7fa9\n\u968f\u4f34\u304b\u3089\u3001\u30e2\u30ca\u30c9\u3092\u901a\u3058\u3066 Kleisli triple \u3092\u69cb\u6210\u3057\u3066\u307f\u305f\n\n\u8a18\u4e8b\u306e\u5143\u30cd\u30bf\u306e\u30e9\u30a4\u30d6\u30e9\u30ea(Cat_on_Coq)\u306f\u3053\u3053\n\nAdj/Adjunction.v\nAdj/ProdExp.v\nMonad/Monad.v\nMonad/Adj.v\nCons/Exponential.v\nKleisli.v\n\n\n\u306a\u3093\u304b\u91cf\u304c\u591a\u3044\u306e\u3067\u6d41\u3057\u8aad\u307f\u3067\u3044\u3044\u3068\u601d\u3044\u307e\u3059\u3002\n\n\n\u524d\u63d0\n\u4ee5\u4e0b\u306e\u8a18\u4e8b\u3092\u8aad\u3093\u3067\u304a\u304f\u3068\u308f\u304b\u308a\u3084\u3059\u3044\u304b\u3082\u3057\u308c\u307e\u305b\u3093\u3002\n- Coq \u3067\u570f\u8ad6\uff1a\u80cc\u666f\u3068\u666e\u904d\u6027\u306b\u3064\u3044\u3066\n- Coq \u3067\u570f\u8ad6\uff1a\u51fd\u624b\u3068\u305d\u306e\u7b49\u4fa1\u6027\n- Coq \u3067\u570f\u8ad6\uff1a\u81ea\u7136\u5909\u63db\u3068\u30c7\u30fc\u30bf\u578b\nKleisli triple \u3068\u304b\u306b\u95a2\u3059\u308b\u90e8\u5206\u306f Haskell \u306a\u3069\u3067 Monad \u4f7f\u3063\u3066\u305f\u308a\u3059\u308b\u65b9\u5411\u3051\u3067\u3059\u3002\nCat_on_Coq \u306e\u30b3\u30fc\u30c9\u3092\u5b9f\u969b\u306b CoqIDE \u304b ProofGeneral \u304b\u306a\u3093\u304b\u3067\u8ffd\u3063\u3066\u3044\u304b\u306a\u3044\u3068\u3001\u8272\u3005\u306a\u90e8\u5206\u306e\u578b\u3068\u304b\u304c\u308f\u304b\u308a\u306b\u304f\u304f\u3066\u5927\u5909\u304b\u3082\u3057\u308c\u307e\u305b\u3093\u3002\n\n\u968f\u4f34\n\u51fd\u624b $F: C \\rightarrow D$ \u3068\u51fd\u624b $G: D \\rightarrow C$ \u304c\u968f\u4f34\u3067\u3042\u308b\u3068\u306f\u3001\n\\forall c\\in C, d\\in D.\\ D(F(c),d) \\cong C(c,G(d))\n\n\u304c\u6210\u308a\u7acb\u3061\u3001\u3055\u3089\u306b\u3053\u306e\u540c\u578b\u304c $c,d$ \u306b\u3064\u3044\u3066\u81ea\u7136\u3067\u3042\u308b\u3053\u3068\u3067\u3059\u3002\u3053\u306e\u3068\u304d\u3001 $F \\dashv G$ \u3068\u66f8\u304d\u307e\u3059\u3002\n\u3053\u306e\u540c\u578b\u3092\u4e0e\u3048\u308b\u540c\u578b\u5199\u50cf\u3092 $\\phi_{c,d}: D(F(c),d) \\rightarrow C(c,G(d))$(\u570f\u306e\u5c04\u3067\u306f\u306a\u304f\u5199\u50cf\u3067\u3059) \u3068\u66f8\u304f\u3053\u3068\u306b\u3059\u308b\u3068\u3001\u300c\u81ea\u7136\u3067\u3042\u308b\u300d\u3068\u306f\u3001 $c$ \u3092\u56fa\u5b9a\u3057\u305f\u3068\u304d\u306b\u5c04\u306e\u65cf $\\phi_{c,-}$ \u304c\u81ea\u7136\u5909\u63db $\\phi_{c,-}:D(F(c),-) \\Rightarrow C(c,G(-))$ \u3068\u306a\u308a\u3001$d$ \u3092\u56fa\u5b9a\u3057\u305f\u3068\u304d\u306b\u5c04\u306e\u65cf $\\phi_{-,d}$ \u304c\u81ea\u7136\u5909\u63db $\\phi_{-,d}:D(F(-),d) \\Rightarrow C(-, G(d))$ \u3068\u306a\u308b\u3053\u3068\u3092\u610f\u5473\u3057\u307e\u3059\u3002\n\n\u5b9a\u7fa9\n\u4e0a\u8ff0\u3057\u305f\u4e8c\u3064\u306e\u81ea\u7136\u6027\u306f\u3001\u4ee5\u4e0b\u306e\u7b49\u5f0f\u306b\u307e\u3068\u3081\u308b\u3053\u3068\u304c\u3067\u304d\u307e\u3059\u3002\n\\forall f\\in C(c',c),g\\in D(d,d'),h \\in D(F(c),d.\\ \\phi_{c',d'} (g \\circ h \\circ F(f)) = G(g) \\circ \\phi_{c,d} h \\circ f\n\n\u5b9f\u969b\u3001 $f$ \u3084 $g$ \u3092\u6052\u7b49\u5c04\u306b\u3057\u305f\u5834\u5408\u3092\u8003\u3048\u3066\u307f\u308c\u3070\u3001\u4e8c\u3064\u306e\u81ea\u7136\u6027\u306f\u7c21\u5358\u306b\u5c0e\u3051\u307e\u3059\u3002\nCoq \u4e0a\u3067\u5b9a\u7fa9\u3059\u308b\u969b\u3001\u3053\u3061\u3089\u306e\u7b49\u5f0f\u306e\u65b9\u304c\u5358\u7d14\u3067\u3059\u306e\u3067\u3001\u3053\u308c\u3092\u4f7f\u3063\u3066\u968f\u4f34\u3092\u5b9a\u7fa9\u3059\u308b\u3053\u3068\u306b\u3057\u307e\u3059\u3002\n\u300c\u540c\u578b\u5199\u50cf\u300d\u3068\u8a00\u3063\u3066\u3044\u308b\u306e\u3067\u3001 $\\phi_{c,d}$ \u306e\u9006\u5199\u50cf\u3082\u968f\u4f34\u306e\u69cb\u6210\u8981\u7d20\u306b\u306a\u3063\u3066\u3044\u307e\u3059\u3002\nClass IsAdjunction\n      (C D: Category)(F: C --> D)(G: D --> C)\n      (lr: forall {c: C}{d: D}, Map (D (F c) d) (C c (G d)))\n      (rl: forall {c: C}{d: D}, Map (C c (G d)) (D (F c) d)) :=\n  {\n    adj_iso_lr_rl:\n      forall (c: C)(d: D)(f: D (F c) d),\n        rl (lr f) == f;\n\n    adj_iso_rl_lr:\n      forall (c: C)(d: D)(g: C c (G d)),\n        lr (rl g) == g;\n\n    adj_lr_naturality:\n      forall (c c': C)(d d': D)(f : C c' c)(g: D d d')(h: D (F c) d),\n        lr (g \\o h \\o fmap F f) == fmap G g \\o lr h \\o f\n  }.\n\nadj_lr \u304c $\\phi$ \u3067\u3001 adj_rl \u304c $\\phi^{-1}$ \u3067\u3059\u3002\nStructure Adjunction (C D: Category)(F: C --> D)(G: D --> C) :=\n  {\n    adj_lr: forall {c: C}{d: D}, Map (D (F c) d) (C c (G d));\n    adj_rl: forall {c: C}{d: D}, Map (C c (G d)) (D (F c) d);\n\n    prf:> IsAdjunction (@adj_lr) (@adj_rl)\n  }.\nExisting Instance prf.\n\nNotation \"F -| G ; C <--> D\" := (Adjunction (C:=C) (D:=D) F G) (at level 40, no associativity).\nNotation \"F -| G\" := (F -| G ; _ <--> _) (at level 40, no associativity).\nNotation \"[ 'Adj' 'of' F , G 'by' lr , rl ]\" :=\n  (@Build_Adjunction _ _ F G lr rl _).\nNotation \"[ 'Adj' 'by' lr , rl ]\" := [Adj of _, _ by lr, rl].\nNotation \"[ F -| G 'by' lr , rl ]\" := [Adj of F,G by lr,rl].\n\n\nunit & counit\n\u968f\u4f34\u306f\u3001 hom \u96c6\u5408\u306e\u540c\u578b\u5199\u50cf\u304b\u3089\u5b9a\u7fa9\u3059\u308b\u65b9\u6cd5\u306e\u4ed6\u3001\u3042\u308b\u7b49\u5f0f\u3092\u6e80\u305f\u3059\u4e8c\u3064\u306e\u81ea\u7136\u5909\u63db\u304b\u3089\u5b9a\u7fa9\u3059\u308b\u3053\u3068\u3082\u3067\u304d\u307e\u3059\u3002\n\u51fd\u624b $F: C \\rightarrow D$ \u3068 $G: D \\rightarrow C$ \u306b\u5bfe\u3057\u3066\u3001\u4e8c\u3064\u306e\u81ea\u7136\u5909\u63db $\\eta: Id_C \\Rightarrow G\\circ F$ \u3068 $\\epsilon: F \\circ G \\Rightarrow Id_D$ \u304c\n\\epsilon F \\circ F \\eta = Id_F,\\ G\\epsilon \\circ \\eta G = Id_G\n\n\u3092\u6e80\u305f\u3059\u3068\u304d\u3001\u3053\u308c\u3082\u968f\u4f34\u3092\u4e0e\u3048\u307e\u3059\u3002\n\u3053\u306e\u6642\u3001 $\\eta$ \u3068 $\\epsilon$ \u3092\u305d\u308c\u305e\u308c\u968f\u4f34\u306e unit, counit \u3068\u547c\u3073\u3001\u540c\u578b\u5199\u50cf $\\phi_{c,d}:D(F(c),d)\\cong C(c,G(d))$ \u306f $\\phi_{c,d}(f) = G(f)\\circ \\eta_c$ \u3068 $\\phi^{-1}_{c,d}(f) = \\epsilon _d \\circ F(f)$ \u3067\u3082\u3063\u3066\u69cb\u6210\u3067\u304d\u307e\u3059\u3002\n\u3053\u306e\u4e8b\u5b9f\u3092 Coq \u4e0a\u3067\u66f8\u304d\u4e0b\u3059\u3068\u4ee5\u4e0b\u306e\u3088\u3046\u306b\u306a\u308a\u307e\u3059\u3002\nDefinition adj_triangle \n           (C D: Category)\n           (F: C --> D)(G: D --> C)\n           (au: (Id C) ==> (G \\o F))\n           (ac: (F \\o G) ==> (Id D)) :=\n  ([1 \\o * ==> *]\n     \\o (ac o> F)\n     \\o Nassoc\n     \\o (F <o au)\n     \\o [* ==> * \\o 1]\n   == Id F\n    in Natrans_setoid _ _)      (* acF \\o Fau == Id_F *)\n  /\\\n  ([* \\o 1 ==> *]\n     \\o (G <o ac)\n     \\o Nassoc_inv\n     \\o (au o> G)\n     \\o [* ==> 1 \\o *]\n   == Id G\n    in Natrans_setoid _ _).     (* Gac \\o auG == Id_G *)\n\nProgram Definition Adjunction_by_unit_and_counit\n        (C D: Category)\n        (F: C --> D)(G: D --> C)\n        (au: (Id C) ==> (G \\o F))\n        (ac: (F \\o G) ==> (Id D))\n        (Hadj: adj_triangle au ac)\n  : F -| G :=\n  [Adj by (fun c d => [g in D (F c) d :-> fmap G g \\o au c]),\n          (fun c d => [f in C c (G d) :-> ac d \\o fmap F f])].\n\n\u306f\u3044\u3002\u6e80\u305f\u3059\u3079\u304d\u6027\u8cea\u3092 adj_triangle \u3068\u3057\u3066\u5b9a\u7fa9\u3057\u307e\u3057\u305f\u304c\u3001\u81ea\u7136\u5909\u63db\u306e\u5408\u6210\u304c\u3050\u3061\u3083\u3050\u3061\u3083\u3057\u3066\u3044\u307e\u3059\u306d\u3002\n\u4f55\u6545\u304b\u3068\u3044\u3048\u3070\u3001\u901a\u5e38\u306e\u570f\u8ad6\u3067\u306f\u6697\u9ed9\u306e\u5185\u306b\u884c\u306a\u308f\u308c\u3066\u3044\u308b\u5909\u63db\u3092\u660e\u793a\u7684\u306b\u8a18\u8ff0\u3057\u3066\u3044\u308b\u304b\u3089\u3067\u3059\u3002\n\\begin{eqnarray*}\n(H \\circ G) \\circ F & = & H \\circ (G \\circ F) \\\\\nF \\circ Id_C & = & F\\\\\n\\ Id_D \\circ F & = & F\n\\end{eqnarray*}\n\n\u307f\u305f\u3044\u306a\u3082\u306e\u306f\u3001\u6697\u9ed9\u306e\u3046\u3061\u306b\u5de6\u8fba\u306e\u51fd\u624b\u304b\u3089\u53f3\u8fba\u306e\u51fd\u624b\u3078\u306e\u81ea\u7136\u5909\u63db(\u3042\u308b\u3044\u306f\u305d\u306e\u9006)\u3092\u9069\u7528\u3059\u308b\u3053\u3068\u3067\u70ba\u3055\u308c\u3066\u3044\u308b\u306e\u3067\u3059\u3002\nS: F ==> G \u3068 T: G' ==> H \u304c\u4e0e\u3048\u3089\u308c\u305f\u3068\u304d\u3001 $G = G'$ \u304c G = G' \u3067\u306f\u306a\u304f\u81ea\u7136\u540c\u578b\u3092\u8868\u308f\u3057\u3066\u3044\u308b\u5834\u5408\u3001\u305d\u306e\u540c\u578b\u3092\u4f7f\u3063\u3066 S \u3068 T \u306e\u9593\u306e\u30af\u30c3\u30b7\u30e7\u30f3\u306b\u3059\u308b\u5fc5\u8981\u304c\u3042\u308b\u308f\u3051\u3067\u3059\u3002\n\u306a\u304a\u3001 Notation \u3092\u4f7f\u3063\u3066\u898b\u305f\u76ee\u3067\u306a\u3093\u3068\u304b\u308f\u304b\u308b\u3088\u3046\u306b\u3057\u3066\u3044\u307e\u3059\u304c\u3001\u7d50\u5408\u5f8b\u3084\u5358\u4f4d\u5143\u5f8b\u3092\u610f\u5473\u3059\u308b\u81ea\u7136\u5909\u63db\u305f\u3061\u306e\u5143\u306e\u5b9a\u7fa9\u3082\u8f09\u305b\u3066\u304a\u304d\u307e\u3059\u3002\u4e2d\u8eab\u306f\u5168\u90e8\u6052\u7b49\u5c04\u306a\u3093\u3067\u3059\u3051\u3069\u306d\u3002\nProgram Definition Natrans_id_dom (C D: Category)(F: C --> D): (F \\o Id C) ==> F :=\n  [X :=> Id (F X)].\nNotation \"[ * \\o '1' ==> * ]\" := (Natrans_id_dom _).\n\nProgram Definition Natrans_id_dom_inv (C D: Category)(F: C --> D): F ==> (F \\o Id C) :=\n  [X :=> Id (F X)].\nNotation \"[ * ==> * \\o '1' ]\" := (Natrans_id_dom_inv _).\n\nProgram Definition Natrans_id_cod (C D: Category)(F: C --> D): (Id D \\o F) ==> F :=\n  [X :=> Id (F X)].\nNotation \"[ '1' \\o * ==> * ]\" := (Natrans_id_cod _).\n\nProgram Definition Natrans_id_cod_inv (C D: Category)(F: C --> D): F ==> (Id D \\o F) :=\n  [X :=> Id (F X)].\nNotation \"[ * ==> '1' \\o * ]\" := (Natrans_id_cod_inv _).\n\nProgram Definition Natrans_assoc (B C D E: Category)(F: B --> C)(G: C --> D)(H: D --> E): (H \\o (G \\o F)) ==> ((H \\o G) \\o F) :=\n  [ X in B :=> Id (H (G (F X)))].\nNotation Nassoc := (Natrans_assoc _ _ _).\n\nProgram Definition Natrans_assoc_inv (B C D E: Category)(F: B --> C)(G: C --> D)(H: D --> E): ((H \\o G) \\o F) ==> (H \\o (G \\o F)) :=\n  [ X in B :=> Id (H (G (F X)))].\nNotation Nassoc_inv := (Natrans_assoc_inv _ _ _).\n\n\u3064\u3044\u3067\u306b\u3001\u81ea\u7136\u5909\u63db\u3068\u51fd\u624b\u306e\u5408\u6210\u3082\u3044\u3064\u306e\u9593\u306b\u304b\u4f7f\u3063\u3066\u3044\u307e\u3059\u306e\u3067\u3001\u305d\u308c\u3082\u8f09\u305b\u3066\u304a\u304d\u307e\u3059\u3002\nProgram Definition Natrans_dom_compose (B C D: Category)(E: B --> C)(F G: C --> D)(S: F ==> G)\n  : (F \\o E) ==> (G \\o E) :=\n  [X :=> S (E X)].\nNotation \"S o> E\" := (Natrans_dom_compose E S) (at level 50, left associativity).\n\nProgram Definition Natrans_cod_compose (C D E: Category)(F G: C --> D)(H: D --> E)(S: F ==> G)\n  : (H \\o F) ==> (H \\o G) :=\n  [X :=> fmap H (S X)].\nNotation \"H <o S\" := (Natrans_cod_compose H S) (at level 50, left associativity).\n\n\n\u307e\u305f\u3001\u968f\u4f34\u304c\u4e0e\u3048\u3089\u308c\u305f\u3068\u304d\u3001\u4e0a\u8ff0\u306e\u7b49\u5f0f\u3092\u6e80\u305f\u3059\u4e8c\u3064\u306e\u81ea\u7136\u5909\u63db\u3092\u5b9a\u7fa9\u3059\u308b\u3053\u3068\u304c\u3067\u304d\u307e\u3059\u3002\n(** unit of adjunction **)\nProgram Definition adj_unit (C D: Category)(F: C --> D)(G: D --> C)(adj: F -| G)\n  : (Id C) ==> (G \\o F) :=\n  [ c :=> adj_lr adj (Id (F c))].\n\n(** counit of adjunction *)\nProgram Definition adj_counit (C D: Category)(F: C --> D)(G: D --> C)(adj: F -| G):\n  (F \\o G) ==> (Id D)  :=\n  [d :=> adj_rl adj (Id (G d))].\n\nLemma adj_satisfies_triangle:\n  forall (C D: Category)(F: C --> D)(G: D --> C)(adj: F -| G),\n    adj_triangle (adj_unit adj) (adj_counit adj).\n\n\u5834\u5408\u306b\u3088\u3063\u3066\u3001\u540c\u578b\u5199\u50cf\u304b\u3089\u4f5c\u3063\u305f\u308a unit & counit \u304b\u3089\u4f5c\u3063\u305f\u308a\u3092\u4f7f\u3044\u5206\u3051\u308b\u3053\u3068\u306b\u306a\u308a\u307e\u3059\u3002\n\n\u30e2\u30ca\u30c9\n$C$ \u4e0a\u306e\u30e2\u30ca\u30c9\u3068\u306f\u3001\n\n\u81ea\u5df1\u51fd\u624b $T: C \\rightarrow C$\n\u81ea\u7136\u5909\u63db $\\eta: Id_C \\Rightarrow T$\n\u81ea\u7136\u5909\u63db $\\mu: T \\circ T \\Rightarrow T$\n\n\u304b\u3089\u306a\u308b\u7d44 $\\langle T, \\eta, \\mu \\rangle$ \u3067\u3001\n\\begin{eqnarray*}\n\\mu \\circ \\eta T & = & Id_T\\\\\n\\mu \\circ T \\eta & = & Id_T\\\\\n\\mu \\circ T \\mu & = &\\mu \\circ \\mu T\n\\end{eqnarray*}\n\n\u3092\u6e80\u305f\u3059\u3082\u306e\u306e\u3053\u3068\u3067\u3059\u3002\n\n\u5b9a\u7fa9\nCoq \u4e0a\u3067\u3082\u305d\u306e\u307e\u307e\u66f8\u304d\u307e\u3059\u3002\n\u3053\u306e\u8a18\u4e8b\u3067\u306f Kleisli triple \u306e\u305f\u3081\u306e\u8e0f\u307f\u53f0\u3067\u3057\u304b\u306a\u3044\u306e\u3067\u3001\u7279\u306b\u6df1\u304f\u8aac\u660e\u306f\u3057\u307e\u305b\u3093\u3002\nClass IsMonad (C: Category)\n      (T: C --> C)\n      (unit: Id C ==> T)\n      (mult: (T \\o T) ==> T) :=\n  {\n    monad_mult_mult:\n      mult \\o (mult o> T) == mult \\o (T <o mult) \\o Nassoc_inv;\n\n    monad_mult_unit_T:\n      mult \\o (unit o> T) \\o [* ==> 1 \\o *] == Id T;\n\n    monad_mult_T_unit:\n      mult \\o (T <o unit) \\o [* ==> * \\o 1] == Id T\n  }.\n\nStructure Monad (C: Category) :=\n  {\n    monad_functor:> C --> C;\n    monad_unit: Id C ==> monad_functor;\n    monad_mult: (monad_functor \\o monad_functor) ==> monad_functor;\n\n    monad_prf:> IsMonad monad_unit monad_mult\n  }.\nExisting Instance monad_prf.\nNotation \"[ 'Monad' 'by' T , u , m ]\" := (@Build_Monad _ T u m _).\n\n\n\u968f\u4f34\u304b\u3089\u30e2\u30ca\u30c9\n$F: C\\rightarrow D$, $G: D\\rightarrow C$ \u306b\u5bfe\u3057\u3066\u968f\u4f34 $F \\dashv G$ \u304c\u4e0e\u3048\u3089\u308c\u305f\u3068\u304d\u3001 $C$ \u4e0a\u306e\u30e2\u30ca\u30c9\u3092\u69cb\u6210\u3059\u308b\u3053\u3068\u304c\u3067\u304d\u307e\u3059\u3002\n\u3053\u306e\u6642\u3001\u968f\u4f34\u306e unit $\\eta$ \u3068 counit $\\epsilon$ \u3092\u4f7f\u3063\u3066\u30e2\u30ca\u30c9\u3092\u69cb\u6210\u3059\u308b\u3068\u697d\u3067\u3059\u3002\n\u30e2\u30ca\u30c9\u3092\u69cb\u6210\u3059\u308b\u81ea\u5df1\u51fd\u624b\u306f $T := GF$ \u3067\u3059\u3002\u30e2\u30ca\u30c9\u306e $\\eta$ \u306f $\\eta$ \u305d\u306e\u3082\u306e\u3067\u3042\u308a\u3001 $\\mu$ \u306f $G \\epsilon F\uff1a GFGF \\Rightarrow GF$ \u3067\u3059\u3002\n\u305d\u308c\u3092 Coq\u4e0a\u3067\u8a18\u8ff0\u3059\u308b\u3068\u6b21\u306e\u3088\u3046\u306b\u306a\u308a\u307e\u3059\u3002\nDefinition adj_mult (C D: Category)(F: C --> D)(G: D --> C)(adj: F -| G)\n  : ((G \\o F) \\o (G \\o F)) ==> (G \\o F) :=\n  (G <o ([ 1 \\o * ==> *] \\o (adj_counit adj o> F) \\o Nassoc)) \\o Nassoc_inv.\n\nProgram Definition Monad_from_adj\n        (C D: Category)(F: C --> D)(G: D --> C)(adj: F -| G) :=\n  [Monad by (G \\o F), adj_unit adj, adj_mult adj].\n\n\u8a3c\u660e\u3082\u305d\u308c\u307b\u3069\u96e3\u3057\u304f\u306f\u3042\u308a\u307e\u305b\u3093\u3002\n\nKleisli triple\n\u570f $C$ \u4e0a\u306e Kleisli triple \u3068\u306f\n\n\u5bfe\u8c61\u306e\u5272\u308a\u5f53\u3066 $T: |C| \\rightarrow |D|$\n\u5c04\u306e\u65cf $\\eta_X: C(X,(T X))$\n\u5c04\u306e\u5272\u308a\u5f53\u3066\u306e\u65cf $(-)^{\\sharp}_{X,Y}: C(X,T(Y)) \\rightarrow C(T(X),T(Y))$\n\n\u304b\u3089\u306a\u308b\u7d44 $\\langle T, \\eta, (-)^{\\sharp} \\rangle$ \u3067\u3042\u3063\u3066\u3001\n\\begin{eqnarray*}\n\\eta_X^{\\sharp} & = & Id_{T(X)}\\\\\nf^{\\sharp} \\circ \\eta_X & = & f\\\\\ng^{\\sharp} \\circ f^{\\sharp} & = & (g^{\\sharp} \\circ f)^{\\sharp}\n\\end{eqnarray*}\n\n\u3092\u6e80\u305f\u3059\u3082\u306e\u306e\u3053\u3068\u3067\u3059\u3002\n\u306f\u3044\u3002\u570f\u8ad6\u7684\u306a\u5b9a\u7fa9\u3092\u304c\u3063\u3068\u4e26\u3079\u3066\u3082\u3088\u304f\u308f\u304b\u3089\u306a\u3044\u3067\u3059\u306d\u3002\n\n\u5b9a\u7fa9\n\u3053\u308c\u3092 Coq \u4e0a\u3067\u5b9a\u7fa9\u3059\u308b\u3068\u3001\u4eba\u306b\u3088\u3063\u3066\u306f\u898b\u306a\u308c\u305f\u3082\u306e\u304c\u51fa\u6765\u4e0a\u304c\u308a\u307e\u3059\u3002\nClass IsKt (C: Category)(T: C -> C)\n      (ret: forall (X: C), C X (T X))\n      (bind: forall {X Y: C}, (C X (T Y)) -> (C (T X) (T Y))) :=\n  {\n    kt_bind_proper:> forall (X Y: C), Proper ((==) ==> (==)) (@bind X Y);\n    kt_ret_bind:\n      forall (X: C), bind (ret X) == Id (T X);\n\n    kt_bind_ret:\n      forall (X Y: C)(f: C X (T Y)),\n        bind f \\o ret X == f;\n\n    kt_bind_comp:\n      forall (X Y Z: C)(f: C X (T Y))(g: C Y (T Z)),\n        bind g \\o bind f == bind (bind g \\o f)\n  }.\n\nClass Kt (C: Category)(T: C -> C) :=\n  {\n    ret: forall {X: C}, C X (T X);\n    bind: forall (X Y: C), C X (T Y) -> C (T X) (T Y);\n\n    kt_prf:> IsKt (@ret) bind\n  }.\nExisting Instance kt_prf.\nNotation \"[ 'Kt' 'by' ret , bind ]\" := (@Build_Kt _ _ ret bind _).\n\n\u305d\u3046\u3067\u3059\u306d\u3002 Haskell \u3067\u3044\u3046 Monad \u304c\u3001\u3053\u306e Kleisli triple \u3067\u3059\u3002\n\u307e\u305f\u3001 Monad \u3068\u306e\u6574\u5408\u6027\u3092\u53d6\u308b\u305f\u3081\u3001\u4eca\u56de Kt \u3092\u578b\u30af\u30e9\u30b9\u3068\u3057\u3066\u5b9a\u7fa9\u3057\u307e\u3057\u305f\u3002\n\n\u51fd\u6570\u578b\u30d7\u30ed\u30b0\u30e9\u30df\u30f3\u30b0\u3068 Kleisli triple\n\u3055\u3066\u3001 Kleisli triple \u3092\u5b9a\u7fa9\u3057\u3066\u307f\u305f\u308f\u3051\u3067\u3059\u304c\u3001\u3053\u308c\u306f Haskell \u306e\u30e2\u30ca\u30c9\u3088\u308a\u3082\u307e\u3060\u4e00\u822c\u7684\u306a\u69cb\u9020\u3067\u3059\u3002\n\u4f55\u6545\u304b\u3068\u3044\u3048\u3070\u3001\u4efb\u610f\u306e\u570f\u306b\u5bfe\u3057\u3066\u5b9a\u7fa9\u3055\u308c\u3066\u3044\u308b\u304b\u3089\u3067\u3059\u3002\n\u3053\u308c\u304c\u3069\u3046\u3044\u3046\u610f\u5473\u3092\u6301\u3064\u306e\u304b\u3068\u3044\u3044\u307e\u3059\u3068\u3001\u305f\u3068\u3048\u3070 ret \u3092\u4f7f\u3063\u3066 ret x \u3068\u3044\u3046\u5f0f\u3092\u4f5c\u308b\u3053\u3068\u304c\u51fa\u6765\u307e\u305b\u3093\u3002\nret \u306f C \u306e\u5c04\u3067\u3042\u3063\u3066\u3001\u51fd\u6570\u3067\u306f\u306a\u3044\u304b\u3089\u3067\u3059\u3002\n\u3057\u304b\u3057\u3001\u51fd\u6570\u578b\u30d7\u30ed\u30b0\u30e9\u30df\u30f3\u30b0\u3092\u3059\u308b\u5834\u5408\u3001\u5c04\u306f\u51fd\u6570\u3068\u3057\u3066\u8003\u3048\u307e\u3059\u3002\n\u3068\u306a\u308b\u3068\u3001\u5b9f\u7528\u4e0a\u306f Types (Haskell \u3067\u306f Hask \u570f\u3067\u3059\u304b\u306d)\u4e0a\u306e Kleisli triple \u3092\u8003\u3048\u308b\u3053\u3068\u306b\u306a\u308b\u3067\u3057\u3087\u3046\u3002\n\u305d\u3046\u3059\u308c\u3070\u3001 ret x \u306a\u3069\u3082\u66f8\u3051\u307e\u3059\u3057\u3001 do \u8a18\u6cd5\u7684\u306a\u3082\u306e\u3082\u4f7f\u3048\u308b\u3088\u3046\u306b\u306a\u308a\u307e\u3059\u3002\n\u3068\u3044\u3046\u3053\u3068\u3067\u3001\u4ee5\u4e0b\u306e\u3088\u3046\u306b\u3057\u3066 Notation \u3092\u5b9a\u7fa9\u3057\u3066\u304a\u304d\u307e\u3057\u3087\u3046\u3002\n(** Special Notation for Kt on Types **)\nNotation \"m >>= f\" := (bind (C:=Types) f m) (at level 53, left associativity).\nNotation \"[ 'do' M 'in' K ]\" := (let _kt := K: Kt Types _ in M). \nNotation \"[ 'do' M ]\" := [do M in _].\nNotation \"x <- m ; p\" := (m >>= (fun x => p)) (at level 60, right associativity).\nNotation \":- x ; m\" := (_ <- x ; m) (at level 61, right associativity, x at next level).\nNotation \"x <-: m ; p\" := (x <- ret m ; p) (at level 60, right associativity).\nNotation \"f >> g\" := (bind (C:=Types) g \\o f) (at level 42, right associativity).\n\n[do M in K] \u8a18\u6cd5\u304c\u5730\u5473\u306b\u91cd\u8981\u306a\u5f79\u76ee\u3092\u6301\u3063\u3066\u3044\u307e\u3059\u304c\u3001\u4f7f\u3046\u5834\u9762\u3067\u8aac\u660e\u3057\u307e\u3059\u3002\n\n\u5177\u4f53\u4f8b\uff1a Maybe & List\n\n\u3064\u3089\u3064\u3089\u8ff0\u3079\u3066\u3044\u3066\u3082\u4ed5\u65b9\u306a\u3044\u306e\u3067\u3001\u5177\u4f53\u4f8b\u3092\u898b\u3066\u3044\u304d\u307e\u3057\u3087\u3046\u3002\n\nMaybe \u30e2\u30ca\u30c9\n\u307e\u305a\u306f\u5931\u6557\u3057\u3046\u308b\u8a08\u7b97\u3092\u8868\u3059 Maybe \u3067\u3059\u3002\nProgram Instance Maybe: Kt Types option :=\n  {\n    ret X x := Some x;\n    bind X Y f m := match m with\n                    | Some x => f x\n                    | None => None\n                    end\n  }.\n\n\u8a08\u7b97\u4f8b\u3092\u898b\u3066\u307f\u307e\u3057\u3087\u3046\u3002\n\u307e\u305a\u306f hd_error \u304c\u6210\u529f\u3059\u308b\u4f8b\u3067\u3001\nEval compute in\n    [do x <-: 0;\n       y <- hd_error [1;2];\n       ret (x, y) in Maybe].\n(* = Some (0, 1) *)\n(* : option (product nat nat) *)\n\n\u6b21\u306f\u5931\u6557\u3059\u308b\u4f8b\u3067\u3059\u3002\nEval compute in\n    [do x <-: 0;\n       y <- hd_error [];\n       ret (x, y) in Maybe].\n(* = None *)\n(* : option (product nat ?B) *)\n\n\u306f\u3044\u3002\u3061\u3083\u3093\u3068\u6a5f\u80fd\u3057\u3066\u3044\u307e\u3059\u306d\u3002\n\nList \u30e2\u30ca\u30c9\n\u3067\u306f\u6b21\u306e\u4f8b\u3001\u975e\u6c7a\u5b9a\u7684\u8a08\u7b97\u3092\u8868\u3059 List \u30e2\u30ca\u30c9\u3067\u3059(Kleisli triple \u3067\u3059)\u3002\nProgram Instance List: Kt Types list :=\n  {\n    ret X x := [x];\n    bind X Y f l := flat_map f l\n  }.\n\n\u8a08\u7b97\u4f8b\u306f\u3053\u3093\u306a\u611f\u3058\u3067\u3059\u3002\nEval compute in\n    [do x <- [3;1;4;1;5];\n       y <-: (x + 1);\n       ret y in List].\n(* = [4; 2; 5; 2; 6] *)\n(* : list nat *)\n\n\u307e\u305f\u3001\u3053\u306e\u3088\u3046\u306b\u3057\u3066 guard \u3092\u5c0e\u5165\u3059\u308b\u3053\u3068\u3082\u3067\u304d\u307e\u3059(\u4e00\u822c\u306b\u3001\u5931\u6557\u3092\u8868\u73fe\u3067\u304d\u308b\u8a08\u7b97\u306b\u5bfe\u3057\u3066\u5b9a\u7fa9\u53ef\u80fd(\u306a\u306f\u305a)\u3067\u3059\u304c\u3001\u4eca\u56de\u306f List \u306b\u7279\u5316\u3055\u305b\u3066\u3044\u307e\u3059)\u3002\nDefinition guard {X: Type}(b: X -> bool)(x: X): list X :=\n  if b x then [x] else [].\n\n\u3053\u308c\u3092\u4f7f\u3063\u305f\u8a08\u7b97\u4f8b\u304c\u6b21\u306e\u901a\u308a\u3067\u3059\u3002\u3002\nFixpoint evenb (n: nat): bool :=\n  match n with\n  | O => true\n  | S O => false\n  | S (S n') => evenb n'\n  end.\n\nEval compute in\n    [do x <- [0;1;2;3] ;\n       y <-: (x + 1);\n       :- guard evenb y ;\n       ret x in List].\n(* = [1; 3] *)\n(* : list nat *)\n\n\ndo \u8a18\u6cd5\n\u3055\u3066\u3001\u3055\u304d\u307b\u3069\u89e6\u308c\u305f [do M in K] \u8a18\u6cd5\u3067\u3059\u304c\u3001\u3053\u308c\u306f Coq \u4e0a\u3067 Monad (Kleisli triple) \u3092\u6271\u3046\u4e0a\u3067\u306f\u6b20\u304b\u305b\u307e\u305b\u3093\u3002\n\u306a\u305c\u306a\u3089\u3001\u5229\u7528\u3055\u308c\u308b Monad \u306e\u30a4\u30f3\u30b9\u30bf\u30f3\u30b9\u304c\u3001\u76f4\u8fd1\u3067\u5b9a\u7fa9\u3055\u308c\u305f\u30a4\u30f3\u30b9\u30bf\u30f3\u30b9\u306b\u306a\u3063\u3066\u3057\u307e\u3046\u304b\u3089\u3067\u3059(\u3053\u306e\u6319\u52d5\u306f\u3069\u3046\u304b\u3068\u601d\u3046\u306e\u3067\u3059\u304c\u3001\u73fe\u72b6\u305d\u3046\u306a\u3063\u3066\u3057\u307e\u3063\u3066\u3044\u308b\u306e\u3067\u3001\u3069\u3046\u3057\u3088\u3046\u3082\u306a\u3044\u3067\u3059)\u3002\n\u305d\u306e\u305f\u3081\u3001 let \u3092\u4f7f\u3063\u3066 M \u3092\u56f2\u3080\u30a4\u30f3\u30b9\u30bf\u30f3\u30b9\u3092 K \u3067\u4e0a\u66f8\u304d\u3059\u308b\u3053\u3068\u3067\u3001\u5229\u7528\u3059\u308b do \u8a18\u6cd5\u3067\u5229\u7528\u3059\u308b\u578b\u30af\u30e9\u30b9\u306e\u30a4\u30f3\u30b9\u30bf\u30f3\u30b9\u3092\u6307\u5b9a\u3067\u304d\u308b\u3088\u3046\u306b\u3057\u3066\u3044\u308b\u306e\u3067\u3059\u3002\n\u305d\u306e\u7d50\u679c\u3001\u4ee5\u4e0b\u306e\u3088\u3046\u306a\u30cd\u30b9\u30c8\u3057\u305f do \u8a18\u6cd5\u3082\u53ef\u80fd\u306b\u306a\u3063\u3066\u3044\u307e\u3059\u3002\nEval compute in\n    [do x <-: 0;\n       y <- (hd_error\n               [do x <- [0;1;2;3] ;\n                  y <-: (x + 1);\n                  :- guard evenb y ;\n                  ret x in List]);\n       ret (x, y) in Maybe].\n(* = Some (0, 1) *)\n(* : option (product nat nat) *)\n\n\n\u30e2\u30ca\u30c9\u3068 Kleisli triple \u306e\u7b49\u4fa1\u6027\n\u30e2\u30ca\u30c9\u304b\u3089 Kleisli triple \u304c\u4f5c\u308c\u3001\u305d\u306e\u9006\u3082\u53ef\u80fd\u3067\u3001\u3055\u3089\u306b\u305d\u306e\u4e8c\u3064\u306e\u69cb\u6210\u306f\u4e92\u3044\u306b\u9006\u306b\u306a\u3063\u3066\u3044\u307e\u3059\u3002\n\u6570\u5f0f\u3067\u66f8\u304f\u306e\u306f\u9762\u5012\u306a\u306e\u3067\u5272\u611b\u3057\u307e\u3059\u304c\u3001 Coq \u4e0a\u3067\u66f8\u304f\u3068\u6b21\u306e\u3088\u3046\u306b\u306a\u308a\u307e\u3059\u3002\nProgram Definition Kt_from_Monad (C: Category)(T: Monad C)\n  : Kt C T :=\n  [Kt by monad_unit T,\n         fun (X Y: C)(f: C X (T Y)) =>\n           monad_mult T Y \\o fmap T f].\n\nProgram Definition Monad_from_Kt (C: Category)(T: C -> C)(kt: Kt C T) :=\n  [Monad by [Functor by f :-> bind (ret \\o f) with X :-> T X],\n            [X :=> ret],\n            [X :=> bind (Id (T X))]].\n\n\u3053\u306e\u4e8c\u3064\u304c\u4e92\u3044\u306b\u9006\u3067\u3042\u308b\u3053\u3068\u3092\u793a\u3059\u305f\u3081\u3001\u307e\u305a\u306f\u30e2\u30ca\u30c9\u3068 Kleisli triple \u306e\u7b49\u4fa1\u6027\u3092\u5b9a\u7fa9\u3057\u3066\u304a\u304d\u307e\u3059\u3002\nProgram Definition Monad_setoid (C: Category) :=\n  [Setoid by (fun (M N: Monad C) =>\n                (monad_functor M == monad_functor N)\n                /\\(forall X: C, monad_unit M X =H monad_unit N X)\n                /\\(forall X: C, monad_mult M X =H monad_mult N X))].\n\nProgram Definition Kt_setoid (C: Category)(T: C -> C) :=\n  [Setoid by (fun (k k': Kt C T) =>\n                (forall X: C, ret (Kt:=k)(X:=X) == ret (Kt:=k'))\n                /\\(forall (X Y: C)(f: C X (T Y)),\n                      bind (Kt:=k) f == bind (Kt:=k') f))].\n\n\u305d\u3046\u3059\u308b\u3068\u3001\u4ee5\u4e0b\u306e\u3088\u3046\u306b\u3057\u3066\u305d\u306e\u4e8b\u5b9f\u3092\u793a\u3059\u3053\u3068\u304c\u3067\u304d\u308b\u3088\u3046\u306b\u306a\u308a\u307e\u3059(\u8a3c\u660e\u306f\u7701\u7565\u3057\u3066\u3044\u307e\u3059\u304c)\u3002\nLemma Monad_Kt_Monad_eq:\n  forall (C: Category)(T: Monad C),\n    T == Monad_from_Kt (Kt_from_Monad T) in Monad_setoid C.\n\nLemma Kt_Monad_Kt_eq:\n  forall (C: Category)(T: C -> C)(kt: Kt C T),\n    kt == Kt_from_Monad (Monad_from_Kt kt) in Kt_setoid C T.\n\n\n\u76f4\u7a4d\u3068\u7f83\u306e\u968f\u4f34\u304b\u3089 State \u30e2\u30ca\u30c9\u3092\u69cb\u6210\u3059\u308b\n\u3055\u3066\u3001\u6709\u540d\u306a\u4f8b\u3067\u3059\u304c\u3001\u76f4\u7a4d\u3092\u4e0e\u3048\u308b\u64cd\u4f5c $(-,Y): C \\rightarrow C$ \u3068\u7f83\u3092\u4e0e\u3048\u308b\u64cd\u4f5c $(-)^Y: C \\rightarrow C$ \u306f\u305d\u308c\u305e\u308c\u51fd\u624b\u306b\u306a\u308a\u307e\u3059\u3002\n\u305d\u3057\u3066\u3001\u3053\u306e\u4e8c\u3064\u306f\u968f\u4f34 $(-,Y)\\dashv (-)^Y$ \u3092\u306a\u3057\u3001\u305d\u306e\u968f\u4f34\u304b\u3089\u69cb\u6210\u3055\u308c\u308b\u30e2\u30ca\u30c9(\u304b\u3089\u4f5c\u3089\u308c\u308b Kleisli triple)\u304c State \u30e2\u30ca\u30c9\u306b\u306a\u308a\u307e\u3059\u3002\n\u4ee5\u4e0b\u3001\u9806\u3092\u8ffd\u3063\u3066\u305d\u308c\u3092\u898b\u3066\u3044\u304d\u307e\u3057\u3087\u3046\u3002\n\u3067\u3059\u304c\u305d\u306e\u524d\u306b\u3001\u307e\u305a\u3001\u5927\u4e8b\u306a\u3053\u3068\u3092\u3084\u3063\u3066\u304a\u304d\u307e\u3059\u3002\n\u570f Types \u4e0a\u3067 State \u30e2\u30ca\u30c9\u3092\u4f5c\u308b\u306b\u306f Functional extensionality \u304c\u5fc5\u8981\u3067\u3059\u3002\nRequire Import FunctionalExtensionality.\n\n\n\u76f4\u7a4d\u51fd\u624b\n\u4ee5\u524d\u3001 Coq \u4e0a\u3067\u306e\u76f4\u7a4d\u306f\u5b9a\u7fa9\u3057\u307e\u3057\u305f \u304c\u3001\u518d\u63b2\u3057\u3066\u304a\u304d\u307e\u3059\u3002\nClass IsProduct (C: Category)(X Y: C)\n      (P: C)(pi1: C P X)(pi2: C P Y)\n      (univ: forall (Z: C), C Z X -> C Z Y -> C Z P) :=\n  {\n    product_universality_1:\n      forall (Z: C)(p1: C Z X)(p2: C Z Y),\n        (p1 == pi1 \\o univ Z p1 p2);\n\n    product_universality_2:\n      forall (Z: C)(p1: C Z X)(p2: C Z Y),\n        (p2 == pi2 \\o univ Z p1 p2);\n\n    product_uniqueness:\n      forall (Z: C)(p1: C Z X)(p2: C Z Y)(u: C Z P),\n        (p1 == pi1 \\o u) ->\n        (p2 == pi2 \\o u) ->\n        u == univ Z p1 p2\n  }.\n\nStructure Product (C: Category)(X Y: C) :=\n  {\n    product_obj:> C;\n    product_proj1: C product_obj X;\n    product_proj2: C product_obj Y;\n\n    product_univ: forall (Z: C), C Z X -> C Z Y -> C Z product_obj;\n\n    product_prf:> IsProduct product_proj1 product_proj2 (@product_univ)\n  }.\nExisting Instance product_prf.\n\nNotation \"[ 'Product' P 'by' univ 'with' pi1 , pi2 ]\" :=\n  (@Build_Product _ _ _ P pi1 pi2 univ _).\nNotation \"[ 'Product' 'by' univ 'with' pi1 , pi2 ]\" :=\n  [Product _ by univ with pi1, pi2].\n\nNotation \"[ f , g 'to' P ]\" := (product_univ P f g).\nNotation \"pi1_{ P }\" := (product_proj1 P) (at level 0, no associativity, format \"pi1_{ P }\").\nNotation \"pi2_{ P }\" := (product_proj2 P) (at level 0, no associativity, format \"pi2_{ P }\").\n\n\u6b21\u306b\u3001 Types \u4e0a\u3067\u306e Product \u3092\u69cb\u6210\u3057\u307e\u3059\u3002\nInductive product (A B: Type): Type :=\n| pair_of (fst: A)(snd: B).\n\nDefinition fst (A B: Type)(p: product A B): A :=\n  match p with\n  | pair_of a _ => a\n  end.\n\nDefinition snd (A B: Type)(p: product A B): B :=\n  match p with\n  | pair_of _ b => b\n  end.\n\nNotation \"( x , y )\" := (pair_of x y) (format \"( x ,  y )\").\n\nNotation \"p .1\" := (fst p) (at level 5, left associativity, format \"p .1\").\nNotation \"p .2\" := (snd p) (at level 5, left associativity, format \"p .2\").\n\nProgram Definition product_of_Types (X Y: Type)\n  : Product Types X Y :=\n  [Product (product X Y) by (fun P f g x => (f x, g x))\n   with @fst X Y, @snd X Y].\n\n\u305d\u3057\u3066\u3001\u76f4\u7a4d\u3092\u4e0e\u3048\u308b\u64cd\u4f5c\u304b\u3089\u51fd\u624b\u3092\u69cb\u6210\u3057\u307e\u3059\u3002\n\u6761\u4ef6\u3068\u3057\u3066\u5fc5\u8981\u306a\u306e\u306f\u4efb\u610f\u306e\u4e8c\u5bfe\u8c61\u306b\u5bfe\u3057\u3066\u305d\u306e\u76f4\u7a4d\u304c\u5b58\u5728\u3059\u308b\u3053\u3068\u3067\u3059\u3002\nDefinition product_map (C: Category)(prod: forall (X Y: C), Product C X Y)\n           (X X' Y Y': C)(f: C X Y)(g: C X' Y')\n  : C (prod X X') (prod Y Y') :=\n  [f \\o pi1_{prod X X'} , g \\o pi2_{prod X X'} to (prod Y Y')].\nNotation \"[ f \\* g 'with' prod ]\" := (product_map prod f g).\n\nProgram Definition Product_2_functor (C: Category)(prod: forall X Y: C, Product C X Y)(Y: C)\n  : C --> C :=\n  [Functor by (fun (W X: C)(f: C W X) => [f \\* Id _ with prod ])\n   with (fun X => prod X Y) ].\n\n\n\u7f83\n\u7f83\u306e\u570f\u8ad6\u7684\u5b9a\u7fa9\u306f \u3053\u3061\u3089(wikipedia) \u3092\u5fa1\u53c2\u7167\u304f\u3060\u3055\u3044\u3002\n\u3053\u308c\u3092 Coq \u4e0a\u3067\u5b9a\u7fa9\u3059\u308b\u3068\u6b21\u306e\u3088\u3046\u306b\u306a\u308a\u307e\u3059\u3002\nClass IsExponential\n      (C: Category)\n      (prod: forall (X Y: C), Product C X Y)\n      (Y Z: C)\n      (exp: C)(ev: C (prod exp Y) Z)\n      (univ: forall (X: C)(g: C (prod X Y) Z), C X exp) :=\n  {\n    exp_universality:\n      forall (X: C)(g: C (prod X Y) Z),\n        g == ev \\o [univ X g \\* Id Y with prod];\n    exp_uniqueness:\n      forall (X: C)(g: C (prod X Y) Z)(u: C X exp),\n        g == ev \\o [u \\* Id Y with prod] ->\n        u == univ X g\n  }.\n\nStructure Exponential\n          (C: Category)(prod: forall (X Y: C), Product C X Y)\n          (Y Z: C) :=\n  {\n    exp_obj:> C;\n    exp_eval: C (prod exp_obj Y) Z;\n    exp_univ: forall (X: C), C (prod X Y) Z -> C X exp_obj;\n\n    exp_prf:> IsExponential exp_eval exp_univ\n  }.\nExisting Instance exp_prf.\n\nNotation \"[ 'Exp' exp 'by' univ 'with' eval ]\" :=\n  (@Build_Exponential _ _ _ _ exp eval univ _).\nNotation \"[ 'Exp' 'by' univ 'with' eval ]\" :=\n  [Exp _ by univ with eval].\nNotation \"[ 'curry' f 'to' exp ]\" := (exp_univ exp f) (f at next level).\n\n\u305d\u3057\u3066 Types \u4e0a\u3067\u306e\u7f83\u5bfe\u8c61\u3092\u5b9a\u7fa9\u3057\u307e\u3059\u3002\nFunctional extenstionality \u304c\u5fc5\u8981\u306b\u306a\u308b\u306e\u306f\u3053\u3053\u3067\u3059\u3002\nProgram Definition exponential_of_Types (Y Z: Type)\n  : Exponential (C:=Types) product_of_Types Y Z :=\n  [Exp (Y -> Z)\n    by (fun (X: Type) f x y => f (x, y))\n   with (fun gy => gy.1 gy.2)].\n\n\u7f83\u3092\u4e0e\u3048\u308b\u64cd\u4f5c\u304b\u3089\u306f\u6b21\u306e\u3088\u3046\u306b\u3057\u3066\u51fd\u624b\u304c\u69cb\u6210\u3067\u304d\u307e\u3059\u3002\nProgram Definition Exponential_functor\n        (C: Category)(prod: forall (X Y: C), Product C X Y)\n        (exp: forall (Y Z: C), Exponential prod Y Z)\n        (X: C)\n  : C --> C :=\n  [Functor by (fun (Y Z: C)(g: C Y Z) => [curry (g \\o exp_eval (exp X Y)) to (exp X Z)])\n   with (fun Y => exp X Y)].\n\n\nState \u30e2\u30ca\u30c9\n\u3055\u3066\u3001\u76f4\u7a4d\u3001\u7f83\u3001\u968f\u4f34\u3001\u30e2\u30ca\u30c9\u3001Kleisli triple \u3068\u3044\u3046\u5fc5\u8981\u306a\u9053\u5177\u3092\u5b9a\u7fa9\u3057\u7d42\u3048\u305f\u306e\u3067\u3001 State \u30e2\u30ca\u30c9\u3092\u4f5c\u308a\u307e\u3057\u3087\u3046\u3002\n\u307e\u305a\u3001\u76f4\u7a4d\u3068\u7f83\u306e\u968f\u4f34\u306f\u6b21\u306e\u3088\u3046\u306b\u3057\u3066\u69cb\u6210\u3067\u304d\u307e\u3059\u3002\n$C(X\\times Y, Z) \\rightarrow C(X,Z^Y)$ \u306f\u3044\u308f\u3086\u308b\u30ab\u30ea\u30fc\u5316\u3067\u3059\u306d\u3002\nProgram Definition prod_exp_adjunction\n        (C: Category)\n        (prod: forall (X Y: C), Product C X Y)\n        (exp: forall (Y Z: C), Exponential prod Y Z)\n        (Y: C)\n  : Product_2_functor prod Y -| Exponential_functor exp Y :=\n  [Adj by (fun X Z => [f in C (prod X Y) Z :-> [curry f to exp Y Z]]),\n          (fun X Z => [f in C X (exp Y Z) :-> exp_eval (exp Y Z) \\o [f \\* Id Y with prod]])].\n\n\u3061\u306a\u307f\u306b\u3001\u5b9a\u7fa9\u3092\u898b\u3066\u308f\u304b\u308b\u3088\u3046\u306b\u3001\u76f4\u7a4d\u3068\u7f83\u304c\u5b58\u5728\u3059\u308c\u3070\u3053\u306e\u968f\u4f34\u306f\u4efb\u610f\u306e\u570f\u3067\u69cb\u6210\u53ef\u80fd\u3067\u3059(\u3068\u3044\u3046\u3053\u3068\u306f Setoids \u4e0a\u3067\u3082 State \u30e2\u30ca\u30c9\u3092\u4f5c\u308c\u308b\u3093\u3067\u3059\u304c\u3001\u3053\u306e\u8a18\u4e8b\u3067\u306f\u6271\u3044\u307e\u305b\u3093)\u3002\n\u305d\u3057\u3066\u3001 State \u30e2\u30ca\u30c9\u306f\u6b21\u306e\u3088\u3046\u306b\u3057\u3066\u5b9a\u7fa9\u3067\u304d\u307e\u3059\u3002\nInstance State (S: Type): Kt Types _ :=\n  Kt_from_Monad\n    (Monad_from_adj\n       (prod_exp_adjunction exponential_of_Types S)).\n\n\u306a\u304a\u3001 Kt \u306e\u5f15\u6570\u3068\u3057\u3066\u4e0e\u3048\u308b\u578b\u5909\u63db\u5b50\u306f\u5b9a\u7fa9\u304b\u3089\u63a8\u8ad6\u3057\u3066\u3044\u307e\u3059\u3002\n\u5b9f\u969b\u306b\u3069\u3093\u306a\u3082\u306e\u306a\u306e\u304b\u3092\u898b\u3066\u307f\u308b\u3068\u3001\nDefinition kt_fobj {C: Category}{T: C -> C}(kt: Kt C T) := T.\n\nDefinition state (S: Type) := kt_fobj (State S).\nEval compute in state.\n(* = fun S H : Type => S -> product H S *)\n(* : Type -> Types -> Types *)\n\n\u306f\u3044\u3002\u666e\u901a\u306e State \u30e2\u30ca\u30c9\u3067\u4f7f\u308f\u308c\u308b\u578b\u5909\u63db\u5b50\u3068\u540c\u3058\u5f62\u3092\u3057\u3066\u3044\u307e\u3059\u3002\n\u306a\u3093\u304b\u4e0a\u624b\u304f\u3044\u3063\u3066\u3044\u308b\u3088\u3046\u306a\u6c17\u304c\u3057\u307e\u3059\u306d\u3002\n\u3067\u306f\u3001\u5b9f\u969b\u306b\u8a08\u7b97\u3092\u3057\u3066\u307f\u307e\u3057\u3087\u3046\u3002\n\u3068\u3001\u305d\u306e\u524d\u306b\u88dc\u52a9\u51fd\u6570\u305f\u3061\u3092\u5b9a\u7fa9\u3057\u307e\u3059\u3002\nDefinition put {S: Type}(s: S): state S unit :=\n  (fun _: S => (tt, s)).\n\nDefinition get {S: Type}: state S S :=\n  (fun s: S => (s, s)).\n\nDefinition modify {S: Type}(f: S -> S): state S unit :=\n  [do s <- get ; put (f s) in State S].\n\nDefinition evalState {S: Type}(X: Type)(m: state S X)(s: S) := m s.\n\n\u898b\u899a\u3048\u306e\u3042\u308b\u3082\u306e\u305f\u3061\u3067\u3059\u306d\u3002\n\u3053\u308c\u3089\u3092\u4f7f\u3063\u305f\u8a08\u7b97\u4f8b\u306f\u6b21\u306e\u3088\u3046\u306b\u306a\u308a\u307e\u3059\u3002\nEval compute in\n    [do x <-: 0;\n       y <-: 1;\n       ret (x, y) in State nat].\n(* = fun y : nat => ((0, 1), y) *)\n(* : (Monad_from_adj (prod_exp_adjunction exponential_of_Types nat)) *)\n(*     (product nat nat) *)\n\nEval compute in\n    [do x <-: 0;\n       :- modify S;\n       s <- get;\n       ret (x, s) in State nat].\n(* = fun y : nat => ((0, S y), S y) *)\n(* : (Monad_from_adj (prod_exp_adjunction exponential_of_Types nat)) *)\n(*     (product nat nat) *)\n\n\u671f\u5f85\u901a\u308a\u306e\u6319\u52d5\u3067\u3059\u306d\u3002\nevalState \u3082\u3053\u306e\u901a\u308a\u3067\u3059\u3002\nEval compute in\n    evalState [do x <-: 0;\n                 :- modify S;\n                 s <- get;\n                 ret (x, s) in State nat] 5.\n(*   = ((0, 6), 6) *)\n(* : (Product_2_functor product_of_Types nat) (product nat nat) *)\n\n\u3082\u3061\u308d\u3093\u3001\u30e2\u30ca\u30c9\u306e\u30cd\u30b9\u30c8\u3082\u51fa\u6765\u307e\u3059\u3002\nEval compute in\n    [do x <-: 2;\n       y <-: (evalState [do x <-: 1;\n                           modify (plus x) in State nat]\n                        x);\n       ret (x, y.2) in Maybe].\n(* = Some (2, 3) *)\n(* : option (product nat nat) *)\n\nEval compute in\n    [do x <-: 2;\n       y <-: (evalState [do x <-: 1;\n                           modify (plus x) in State nat]\n                        x);\n       ret (x, y.2) in State bool].\n(* = fun y : bool => ((2, 3), y) *)\n(* : (Monad_from_adj (prod_exp_adjunction exponential_of_Types bool)) *)\n(*     (product nat nat) *)\n\n\u3068\u3044\u3046\u308f\u3051\u3067\u3001 State \u30e2\u30ca\u30c9\u3092\u4f5c\u3063\u3066\u5b9f\u969b\u306b\u52d5\u304f\u304b\u78ba\u304b\u3081\u3066\u307f\u308b\u3001\u3067\u3057\u305f\u3002\n\n\u6700\u5f8c\u306b\n\u5f53\u7136\u3067\u3059\u304c\u3001 State \u30e2\u30ca\u30c9\u306f\u666e\u901a\u306b\u5b9a\u7fa9\u3057\u305f\u65b9\u304c\u697d\u3067\u3059\u3002\nDefinition state (S: Type) := (fun (A: Type) => S -> product A S).\n\nProgram Instance State (S: Type): Kt Types (state S) :=\n  {\n    ret X x s := (x, s);\n    bind X Y f m s := let (x, s') := m s in f x s'\n  }.\n\n\u3053\u308c\u307e\u3067\u306e\u8b70\u8ad6\u306f\u3001 Coq \u4e0a\u3067\u5c55\u958b\u3057\u305f\u570f\u8ad6\u304c\u3001 State \u30e2\u30ca\u30c9\u307f\u305f\u3044\u306a\u3088\u304f\u4f7f\u308f\u308c\u308b\u9053\u5177\u305f\u3061\u3068\u6574\u5408\u6027\u304c\u53d6\u308c\u3066\u3044\u308b\u3053\u3068\u3092\u78ba\u8a8d\u3059\u308b\u4f5c\u696d\u307f\u305f\u3044\u306a\u3082\u306e\u3067\u3059\u3002\n\u305d\u306e\u304a\u304b\u3052\u3067 Coq \u4e0a\u3067\u306e\u570f\u8ad6\u306e\u65b9\u5411\u6027\u304c\u9593\u9055\u3063\u3066\u306a\u3044\u304b\u306a\u3001\u3063\u3066\u306e\u3092\u78ba\u8a8d\u3067\u304d\u308b\u306e\u3067\u3001\u4f8b\u3068\u3057\u3066\u306f\u3068\u3066\u3082\u6709\u610f\u7fa9\u306a\u3093\u3067\u3059\u3051\u3069\u306d\u3002\n\u3053\u308c\u3082\u542b\u3081\u3066\u56db\u672c\u306e\u8a18\u4e8b\u3092\u66f8\u304d\u6bb4\u3063\u3066\u304d\u307e\u3057\u305f\u304c\u3001\u4e00\u5fdc\u3001\u7d50\u8ad6\u3068\u3057\u3066\u3084\u308a\u305f\u304b\u3063\u305f\u3053\u3068(State \u30e2\u30ca\u30c9)\u304c\u51fa\u6765\u307e\u3057\u305f\u3002\n\u3068\u308a\u3042\u3048\u305a\u3001\u3053\u308c\u307e\u3067\u306e\u65b9\u91dd\u3067\u3082\u3046\u5c11\u3057\u51fd\u6570\u578b\u30d7\u30ed\u30b0\u30e9\u30df\u30f3\u30b0\u5bc4\u308a\u306e\u570f\u8ad6\u3092\u3084\u3063\u3066\u3044\u304d\u305f\u3044\u3067\u3059\u306d\u3001\u3068\u3044\u3046\u611f\u3058\u3067\u3059\u3002\n\u306a\u3093\u304b\u3044\u3044\u30cd\u30bf\u306a\u3044\u304b\u3057\u3089\u3002\n\n\u6b21\u56de\u4e88\u544a\nKan \u62e1\u5f35\u3002\n# \u307e\u3068\u3081\n- Coq \u4e0a\u3067\u968f\u4f34\u3068\u30e2\u30ca\u30c9\u3092\u5b9a\u7fa9\n- Kleisli triple(Haskell \u3067\u3044\u3046 Monad)\u3082\u5b9a\u7fa9\n- \u968f\u4f34\u304b\u3089\u3001\u30e2\u30ca\u30c9\u3092\u901a\u3058\u3066 Kleisli triple \u3092\u69cb\u6210\u3057\u3066\u307f\u305f\n- [\u8a18\u4e8b\u306e\u5143\u30cd\u30bf\u306e\u30e9\u30a4\u30d6\u30e9\u30ea(Cat_on_Coq)\u306f\u3053\u3053](https://github.com/mathink/Cat_on_Coq)\n    - [Adj/Adjunction.v](https://github.com/mathink/Cat_on_Coq/blob/master/theories/Adj/Adjunction.v)\n    - [Adj/ProdExp.v](https://github.com/mathink/Cat_on_Coq/blob/master/theories/Adj/ProdExp.v)\n    - [Monad/Monad.v](https://github.com/mathink/Cat_on_Coq/tree/master/theories/Monad/Monad.v)\n    - [Monad/Adj.v](https://github.com/mathink/Cat_on_Coq/blob/master/theories/Monad/Adj.v)\n    - [Cons/Exponential.v](https://github.com/mathink/Cat_on_Coq/blob/master/theories/Cons/Exponential.v)\n    - [Kleisli.v](https://github.com/mathink/Cat_on_Coq/blob/master/example/Kleisli.v)\n- \u306a\u3093\u304b\u91cf\u304c\u591a\u3044\u306e\u3067\u6d41\u3057\u8aad\u307f\u3067\u3044\u3044\u3068\u601d\u3044\u307e\u3059\u3002\n\n# \u524d\u63d0\n\n\n\u4ee5\u4e0b\u306e\u8a18\u4e8b\u3092\u8aad\u3093\u3067\u304a\u304f\u3068\u308f\u304b\u308a\u3084\u3059\u3044\u304b\u3082\u3057\u308c\u307e\u305b\u3093\u3002\n- [Coq \u3067\u570f\u8ad6\uff1a\u80cc\u666f\u3068\u666e\u904d\u6027\u306b\u3064\u3044\u3066](http://qiita.com/mathink/items/2067c162fb7cf8f6c83f)\n- [Coq \u3067\u570f\u8ad6\uff1a\u51fd\u624b\u3068\u305d\u306e\u7b49\u4fa1\u6027](http://qiita.com/mathink/items/d827ee3b895ed80a3285)\n- [Coq \u3067\u570f\u8ad6\uff1a\u81ea\u7136\u5909\u63db\u3068\u30c7\u30fc\u30bf\u578b](http://qiita.com/mathink/items/6d635284ff4564e413f9)\n\nKleisli triple \u3068\u304b\u306b\u95a2\u3059\u308b\u90e8\u5206\u306f Haskell \u306a\u3069\u3067 Monad \u4f7f\u3063\u3066\u305f\u308a\u3059\u308b\u65b9\u5411\u3051\u3067\u3059\u3002\n\nCat_on_Coq \u306e\u30b3\u30fc\u30c9\u3092\u5b9f\u969b\u306b CoqIDE \u304b ProofGeneral \u304b\u306a\u3093\u304b\u3067\u8ffd\u3063\u3066\u3044\u304b\u306a\u3044\u3068\u3001\u8272\u3005\u306a\u90e8\u5206\u306e\u578b\u3068\u304b\u304c\u308f\u304b\u308a\u306b\u304f\u304f\u3066\u5927\u5909\u304b\u3082\u3057\u308c\u307e\u305b\u3093\u3002\n\n# \u968f\u4f34\n\n\u51fd\u624b $F: C \\rightarrow D$ \u3068\u51fd\u624b $G: D \\rightarrow C$ \u304c\u968f\u4f34\u3067\u3042\u308b\u3068\u306f\u3001\n\n```math\n\\forall c\\in C, d\\in D.\\ D(F(c),d) \\cong C(c,G(d))\n```\n\n\u304c\u6210\u308a\u7acb\u3061\u3001\u3055\u3089\u306b\u3053\u306e\u540c\u578b\u304c $c,d$ \u306b\u3064\u3044\u3066\u81ea\u7136\u3067\u3042\u308b\u3053\u3068\u3067\u3059\u3002\u3053\u306e\u3068\u304d\u3001 $F \\dashv G$ \u3068\u66f8\u304d\u307e\u3059\u3002\n\n\u3053\u306e\u540c\u578b\u3092\u4e0e\u3048\u308b\u540c\u578b\u5199\u50cf\u3092 $\\phi_{c,d}: D(F(c),d) \\rightarrow C(c,G(d))$(\u570f\u306e\u5c04\u3067\u306f\u306a\u304f\u5199\u50cf\u3067\u3059) \u3068\u66f8\u304f\u3053\u3068\u306b\u3059\u308b\u3068\u3001\u300c\u81ea\u7136\u3067\u3042\u308b\u300d\u3068\u306f\u3001 $c$ \u3092\u56fa\u5b9a\u3057\u305f\u3068\u304d\u306b\u5c04\u306e\u65cf $\\phi_{c,-}$ \u304c\u81ea\u7136\u5909\u63db $\\phi_{c,-}:D(F(c),-) \\Rightarrow C(c,G(-))$ \u3068\u306a\u308a\u3001$d$ \u3092\u56fa\u5b9a\u3057\u305f\u3068\u304d\u306b\u5c04\u306e\u65cf $\\phi_{-,d}$ \u304c\u81ea\u7136\u5909\u63db $\\phi_{-,d}:D(F(-),d) \\Rightarrow C(-, G(d))$ \u3068\u306a\u308b\u3053\u3068\u3092\u610f\u5473\u3057\u307e\u3059\u3002\n\n## \u5b9a\u7fa9\n\n\u4e0a\u8ff0\u3057\u305f\u4e8c\u3064\u306e\u81ea\u7136\u6027\u306f\u3001\u4ee5\u4e0b\u306e\u7b49\u5f0f\u306b\u307e\u3068\u3081\u308b\u3053\u3068\u304c\u3067\u304d\u307e\u3059\u3002\n\n```math\n\\forall f\\in C(c',c),g\\in D(d,d'),h \\in D(F(c),d.\\ \\phi_{c',d'} (g \\circ h \\circ F(f)) = G(g) \\circ \\phi_{c,d} h \\circ f\n```\n\n\u5b9f\u969b\u3001 $f$ \u3084 $g$ \u3092\u6052\u7b49\u5c04\u306b\u3057\u305f\u5834\u5408\u3092\u8003\u3048\u3066\u307f\u308c\u3070\u3001\u4e8c\u3064\u306e\u81ea\u7136\u6027\u306f\u7c21\u5358\u306b\u5c0e\u3051\u307e\u3059\u3002\n\nCoq \u4e0a\u3067\u5b9a\u7fa9\u3059\u308b\u969b\u3001\u3053\u3061\u3089\u306e\u7b49\u5f0f\u306e\u65b9\u304c\u5358\u7d14\u3067\u3059\u306e\u3067\u3001\u3053\u308c\u3092\u4f7f\u3063\u3066\u968f\u4f34\u3092\u5b9a\u7fa9\u3059\u308b\u3053\u3068\u306b\u3057\u307e\u3059\u3002\n\u300c\u540c\u578b\u5199\u50cf\u300d\u3068\u8a00\u3063\u3066\u3044\u308b\u306e\u3067\u3001 $\\phi_{c,d}$ \u306e\u9006\u5199\u50cf\u3082\u968f\u4f34\u306e\u69cb\u6210\u8981\u7d20\u306b\u306a\u3063\u3066\u3044\u307e\u3059\u3002\n\n```coq\nClass IsAdjunction\n      (C D: Category)(F: C --> D)(G: D --> C)\n      (lr: forall {c: C}{d: D}, Map (D (F c) d) (C c (G d)))\n      (rl: forall {c: C}{d: D}, Map (C c (G d)) (D (F c) d)) :=\n  {\n    adj_iso_lr_rl:\n      forall (c: C)(d: D)(f: D (F c) d),\n        rl (lr f) == f;\n\n    adj_iso_rl_lr:\n      forall (c: C)(d: D)(g: C c (G d)),\n        lr (rl g) == g;\n\n    adj_lr_naturality:\n      forall (c c': C)(d d': D)(f : C c' c)(g: D d d')(h: D (F c) d),\n        lr (g \\o h \\o fmap F f) == fmap G g \\o lr h \\o f\n  }.\n```\n\n`adj_lr` \u304c $\\phi$ \u3067\u3001 `adj_rl` \u304c $\\phi^{-1}$ \u3067\u3059\u3002\n\n```coq\nStructure Adjunction (C D: Category)(F: C --> D)(G: D --> C) :=\n  {\n    adj_lr: forall {c: C}{d: D}, Map (D (F c) d) (C c (G d));\n    adj_rl: forall {c: C}{d: D}, Map (C c (G d)) (D (F c) d);\n\n    prf:> IsAdjunction (@adj_lr) (@adj_rl)\n  }.\nExisting Instance prf.\n\nNotation \"F -| G ; C <--> D\" := (Adjunction (C:=C) (D:=D) F G) (at level 40, no associativity).\nNotation \"F -| G\" := (F -| G ; _ <--> _) (at level 40, no associativity).\nNotation \"[ 'Adj' 'of' F , G 'by' lr , rl ]\" :=\n  (@Build_Adjunction _ _ F G lr rl _).\nNotation \"[ 'Adj' 'by' lr , rl ]\" := [Adj of _, _ by lr, rl].\nNotation \"[ F -| G 'by' lr , rl ]\" := [Adj of F,G by lr,rl].\n```\n\n## unit & counit\n\n\u968f\u4f34\u306f\u3001 hom \u96c6\u5408\u306e\u540c\u578b\u5199\u50cf\u304b\u3089\u5b9a\u7fa9\u3059\u308b\u65b9\u6cd5\u306e\u4ed6\u3001\u3042\u308b\u7b49\u5f0f\u3092\u6e80\u305f\u3059\u4e8c\u3064\u306e\u81ea\u7136\u5909\u63db\u304b\u3089\u5b9a\u7fa9\u3059\u308b\u3053\u3068\u3082\u3067\u304d\u307e\u3059\u3002\n\n\u51fd\u624b $F: C \\rightarrow D$ \u3068 $G: D \\rightarrow C$ \u306b\u5bfe\u3057\u3066\u3001\u4e8c\u3064\u306e\u81ea\u7136\u5909\u63db $\\eta: Id_C \\Rightarrow G\\circ F$ \u3068 $\\epsilon: F \\circ G \\Rightarrow Id_D$ \u304c\n\n```math\n\\epsilon F \\circ F \\eta = Id_F,\\ G\\epsilon \\circ \\eta G = Id_G\n```\n\n\u3092\u6e80\u305f\u3059\u3068\u304d\u3001\u3053\u308c\u3082\u968f\u4f34\u3092\u4e0e\u3048\u307e\u3059\u3002\n\u3053\u306e\u6642\u3001 $\\eta$ \u3068 $\\epsilon$ \u3092\u305d\u308c\u305e\u308c\u968f\u4f34\u306e unit, counit \u3068\u547c\u3073\u3001\u540c\u578b\u5199\u50cf $\\phi_{c,d}:D(F(c),d)\\cong C(c,G(d))$ \u306f $\\phi_{c,d}(f) = G(f)\\circ \\eta_c$ \u3068 $\\phi^{-1}_{c,d}(f) = \\epsilon _d \\circ F(f)$ \u3067\u3082\u3063\u3066\u69cb\u6210\u3067\u304d\u307e\u3059\u3002\n\n\u3053\u306e\u4e8b\u5b9f\u3092 Coq \u4e0a\u3067\u66f8\u304d\u4e0b\u3059\u3068\u4ee5\u4e0b\u306e\u3088\u3046\u306b\u306a\u308a\u307e\u3059\u3002\n\n```coq\nDefinition adj_triangle \n           (C D: Category)\n           (F: C --> D)(G: D --> C)\n           (au: (Id C) ==> (G \\o F))\n           (ac: (F \\o G) ==> (Id D)) :=\n  ([1 \\o * ==> *]\n     \\o (ac o> F)\n     \\o Nassoc\n     \\o (F <o au)\n     \\o [* ==> * \\o 1]\n   == Id F\n    in Natrans_setoid _ _)      (* acF \\o Fau == Id_F *)\n  /\\\n  ([* \\o 1 ==> *]\n     \\o (G <o ac)\n     \\o Nassoc_inv\n     \\o (au o> G)\n     \\o [* ==> 1 \\o *]\n   == Id G\n    in Natrans_setoid _ _).     (* Gac \\o auG == Id_G *)\n\nProgram Definition Adjunction_by_unit_and_counit\n        (C D: Category)\n        (F: C --> D)(G: D --> C)\n        (au: (Id C) ==> (G \\o F))\n        (ac: (F \\o G) ==> (Id D))\n        (Hadj: adj_triangle au ac)\n  : F -| G :=\n  [Adj by (fun c d => [g in D (F c) d :-> fmap G g \\o au c]),\n          (fun c d => [f in C c (G d) :-> ac d \\o fmap F f])].\n```\n\n\u306f\u3044\u3002\u6e80\u305f\u3059\u3079\u304d\u6027\u8cea\u3092 `adj_triangle` \u3068\u3057\u3066\u5b9a\u7fa9\u3057\u307e\u3057\u305f\u304c\u3001\u81ea\u7136\u5909\u63db\u306e\u5408\u6210\u304c\u3050\u3061\u3083\u3050\u3061\u3083\u3057\u3066\u3044\u307e\u3059\u306d\u3002\n\u4f55\u6545\u304b\u3068\u3044\u3048\u3070\u3001\u901a\u5e38\u306e\u570f\u8ad6\u3067\u306f\u6697\u9ed9\u306e\u5185\u306b\u884c\u306a\u308f\u308c\u3066\u3044\u308b\u5909\u63db\u3092\u660e\u793a\u7684\u306b\u8a18\u8ff0\u3057\u3066\u3044\u308b\u304b\u3089\u3067\u3059\u3002\n\n```math\n\\begin{eqnarray*}\n(H \\circ G) \\circ F & = & H \\circ (G \\circ F) \\\\\nF \\circ Id_C & = & F\\\\\n\\ Id_D \\circ F & = & F\n\\end{eqnarray*}\n```\n\n\u307f\u305f\u3044\u306a\u3082\u306e\u306f\u3001\u6697\u9ed9\u306e\u3046\u3061\u306b\u5de6\u8fba\u306e\u51fd\u624b\u304b\u3089\u53f3\u8fba\u306e\u51fd\u624b\u3078\u306e\u81ea\u7136\u5909\u63db(\u3042\u308b\u3044\u306f\u305d\u306e\u9006)\u3092\u9069\u7528\u3059\u308b\u3053\u3068\u3067\u70ba\u3055\u308c\u3066\u3044\u308b\u306e\u3067\u3059\u3002\n`S: F ==> G` \u3068 `T: G' ==> H` \u304c\u4e0e\u3048\u3089\u308c\u305f\u3068\u304d\u3001 $G = G'$ \u304c `G = G'` \u3067\u306f\u306a\u304f\u81ea\u7136\u540c\u578b\u3092\u8868\u308f\u3057\u3066\u3044\u308b\u5834\u5408\u3001\u305d\u306e\u540c\u578b\u3092\u4f7f\u3063\u3066 `S` \u3068 `T` \u306e\u9593\u306e\u30af\u30c3\u30b7\u30e7\u30f3\u306b\u3059\u308b\u5fc5\u8981\u304c\u3042\u308b\u308f\u3051\u3067\u3059\u3002\n\n\u306a\u304a\u3001 `Notation` \u3092\u4f7f\u3063\u3066\u898b\u305f\u76ee\u3067\u306a\u3093\u3068\u304b\u308f\u304b\u308b\u3088\u3046\u306b\u3057\u3066\u3044\u307e\u3059\u304c\u3001\u7d50\u5408\u5f8b\u3084\u5358\u4f4d\u5143\u5f8b\u3092\u610f\u5473\u3059\u308b\u81ea\u7136\u5909\u63db\u305f\u3061\u306e\u5143\u306e\u5b9a\u7fa9\u3082\u8f09\u305b\u3066\u304a\u304d\u307e\u3059\u3002\u4e2d\u8eab\u306f\u5168\u90e8\u6052\u7b49\u5c04\u306a\u3093\u3067\u3059\u3051\u3069\u306d\u3002\n\n```coq\nProgram Definition Natrans_id_dom (C D: Category)(F: C --> D): (F \\o Id C) ==> F :=\n  [X :=> Id (F X)].\nNotation \"[ * \\o '1' ==> * ]\" := (Natrans_id_dom _).\n\nProgram Definition Natrans_id_dom_inv (C D: Category)(F: C --> D): F ==> (F \\o Id C) :=\n  [X :=> Id (F X)].\nNotation \"[ * ==> * \\o '1' ]\" := (Natrans_id_dom_inv _).\n\nProgram Definition Natrans_id_cod (C D: Category)(F: C --> D): (Id D \\o F) ==> F :=\n  [X :=> Id (F X)].\nNotation \"[ '1' \\o * ==> * ]\" := (Natrans_id_cod _).\n\nProgram Definition Natrans_id_cod_inv (C D: Category)(F: C --> D): F ==> (Id D \\o F) :=\n  [X :=> Id (F X)].\nNotation \"[ * ==> '1' \\o * ]\" := (Natrans_id_cod_inv _).\n\nProgram Definition Natrans_assoc (B C D E: Category)(F: B --> C)(G: C --> D)(H: D --> E): (H \\o (G \\o F)) ==> ((H \\o G) \\o F) :=\n  [ X in B :=> Id (H (G (F X)))].\nNotation Nassoc := (Natrans_assoc _ _ _).\n  \nProgram Definition Natrans_assoc_inv (B C D E: Category)(F: B --> C)(G: C --> D)(H: D --> E): ((H \\o G) \\o F) ==> (H \\o (G \\o F)) :=\n  [ X in B :=> Id (H (G (F X)))].\nNotation Nassoc_inv := (Natrans_assoc_inv _ _ _).\n```\n\n\u3064\u3044\u3067\u306b\u3001\u81ea\u7136\u5909\u63db\u3068\u51fd\u624b\u306e\u5408\u6210\u3082\u3044\u3064\u306e\u9593\u306b\u304b\u4f7f\u3063\u3066\u3044\u307e\u3059\u306e\u3067\u3001\u305d\u308c\u3082\u8f09\u305b\u3066\u304a\u304d\u307e\u3059\u3002\n\n```coq\nProgram Definition Natrans_dom_compose (B C D: Category)(E: B --> C)(F G: C --> D)(S: F ==> G)\n  : (F \\o E) ==> (G \\o E) :=\n  [X :=> S (E X)].\nNotation \"S o> E\" := (Natrans_dom_compose E S) (at level 50, left associativity).\n\nProgram Definition Natrans_cod_compose (C D E: Category)(F G: C --> D)(H: D --> E)(S: F ==> G)\n  : (H \\o F) ==> (H \\o G) :=\n  [X :=> fmap H (S X)].\nNotation \"H <o S\" := (Natrans_cod_compose H S) (at level 50, left associativity).\n\n```\n\n\n\u307e\u305f\u3001\u968f\u4f34\u304c\u4e0e\u3048\u3089\u308c\u305f\u3068\u304d\u3001\u4e0a\u8ff0\u306e\u7b49\u5f0f\u3092\u6e80\u305f\u3059\u4e8c\u3064\u306e\u81ea\u7136\u5909\u63db\u3092\u5b9a\u7fa9\u3059\u308b\u3053\u3068\u304c\u3067\u304d\u307e\u3059\u3002\n\n```coq\n(** unit of adjunction **)\nProgram Definition adj_unit (C D: Category)(F: C --> D)(G: D --> C)(adj: F -| G)\n  : (Id C) ==> (G \\o F) :=\n  [ c :=> adj_lr adj (Id (F c))].\n\n(** counit of adjunction *)\nProgram Definition adj_counit (C D: Category)(F: C --> D)(G: D --> C)(adj: F -| G):\n  (F \\o G) ==> (Id D)  :=\n  [d :=> adj_rl adj (Id (G d))].\n\nLemma adj_satisfies_triangle:\n  forall (C D: Category)(F: C --> D)(G: D --> C)(adj: F -| G),\n    adj_triangle (adj_unit adj) (adj_counit adj).\n```\n\n\u5834\u5408\u306b\u3088\u3063\u3066\u3001\u540c\u578b\u5199\u50cf\u304b\u3089\u4f5c\u3063\u305f\u308a unit & counit \u304b\u3089\u4f5c\u3063\u305f\u308a\u3092\u4f7f\u3044\u5206\u3051\u308b\u3053\u3068\u306b\u306a\u308a\u307e\u3059\u3002\n\n# \u30e2\u30ca\u30c9\n\n$C$ \u4e0a\u306e\u30e2\u30ca\u30c9\u3068\u306f\u3001\n\n- \u81ea\u5df1\u51fd\u624b $T: C \\rightarrow C$\n- \u81ea\u7136\u5909\u63db $\\eta: Id_C \\Rightarrow T$\n- \u81ea\u7136\u5909\u63db $\\mu: T \\circ T \\Rightarrow T$\n\n\u304b\u3089\u306a\u308b\u7d44 $\\langle T, \\eta, \\mu \\rangle$ \u3067\u3001\n\n```math\n\\begin{eqnarray*}\n\\mu \\circ \\eta T & = & Id_T\\\\\n\\mu \\circ T \\eta & = & Id_T\\\\\n\\mu \\circ T \\mu & = &\\mu \\circ \\mu T\n\\end{eqnarray*}\n```\n\n\u3092\u6e80\u305f\u3059\u3082\u306e\u306e\u3053\u3068\u3067\u3059\u3002\n\n## \u5b9a\u7fa9\n\nCoq \u4e0a\u3067\u3082\u305d\u306e\u307e\u307e\u66f8\u304d\u307e\u3059\u3002\n\u3053\u306e\u8a18\u4e8b\u3067\u306f Kleisli triple \u306e\u305f\u3081\u306e\u8e0f\u307f\u53f0\u3067\u3057\u304b\u306a\u3044\u306e\u3067\u3001\u7279\u306b\u6df1\u304f\u8aac\u660e\u306f\u3057\u307e\u305b\u3093\u3002\n\n```coq\nClass IsMonad (C: Category)\n      (T: C --> C)\n      (unit: Id C ==> T)\n      (mult: (T \\o T) ==> T) :=\n  {\n    monad_mult_mult:\n      mult \\o (mult o> T) == mult \\o (T <o mult) \\o Nassoc_inv;\n\n    monad_mult_unit_T:\n      mult \\o (unit o> T) \\o [* ==> 1 \\o *] == Id T;\n    \n    monad_mult_T_unit:\n      mult \\o (T <o unit) \\o [* ==> * \\o 1] == Id T\n  }.\n\nStructure Monad (C: Category) :=\n  {\n    monad_functor:> C --> C;\n    monad_unit: Id C ==> monad_functor;\n    monad_mult: (monad_functor \\o monad_functor) ==> monad_functor;\n\n    monad_prf:> IsMonad monad_unit monad_mult\n  }.\nExisting Instance monad_prf.\nNotation \"[ 'Monad' 'by' T , u , m ]\" := (@Build_Monad _ T u m _).\n```\n\n## \u968f\u4f34\u304b\u3089\u30e2\u30ca\u30c9\n\n$F: C\\rightarrow D$, $G: D\\rightarrow C$ \u306b\u5bfe\u3057\u3066\u968f\u4f34 $F \\dashv G$ \u304c\u4e0e\u3048\u3089\u308c\u305f\u3068\u304d\u3001 $C$ \u4e0a\u306e\u30e2\u30ca\u30c9\u3092\u69cb\u6210\u3059\u308b\u3053\u3068\u304c\u3067\u304d\u307e\u3059\u3002\n\u3053\u306e\u6642\u3001\u968f\u4f34\u306e unit $\\eta$ \u3068 counit $\\epsilon$ \u3092\u4f7f\u3063\u3066\u30e2\u30ca\u30c9\u3092\u69cb\u6210\u3059\u308b\u3068\u697d\u3067\u3059\u3002\n\n\u30e2\u30ca\u30c9\u3092\u69cb\u6210\u3059\u308b\u81ea\u5df1\u51fd\u624b\u306f $T := GF$ \u3067\u3059\u3002\u30e2\u30ca\u30c9\u306e $\\eta$ \u306f $\\eta$ \u305d\u306e\u3082\u306e\u3067\u3042\u308a\u3001 $\\mu$ \u306f $G \\epsilon F\uff1a GFGF \\Rightarrow GF$ \u3067\u3059\u3002\n\n\u305d\u308c\u3092 Coq\u4e0a\u3067\u8a18\u8ff0\u3059\u308b\u3068\u6b21\u306e\u3088\u3046\u306b\u306a\u308a\u307e\u3059\u3002\n\n```coq\nDefinition adj_mult (C D: Category)(F: C --> D)(G: D --> C)(adj: F -| G)\n  : ((G \\o F) \\o (G \\o F)) ==> (G \\o F) :=\n  (G <o ([ 1 \\o * ==> *] \\o (adj_counit adj o> F) \\o Nassoc)) \\o Nassoc_inv.\n\nProgram Definition Monad_from_adj\n        (C D: Category)(F: C --> D)(G: D --> C)(adj: F -| G) :=\n  [Monad by (G \\o F), adj_unit adj, adj_mult adj].\n```\n\n[\u8a3c\u660e\u3082\u305d\u308c\u307b\u3069\u96e3\u3057\u304f\u306f\u3042\u308a\u307e\u305b\u3093\u3002](https://github.com/mathink/Cat_on_Coq/blob/master/theories/Monad/Adj.v#L20-L38)\n\n# Kleisli triple\n\n\u570f $C$ \u4e0a\u306e Kleisli triple \u3068\u306f\n\n- \u5bfe\u8c61\u306e\u5272\u308a\u5f53\u3066 $T: |C| \\rightarrow |D|$\n- \u5c04\u306e\u65cf $\\eta_X: C(X,(T X))$\n- \u5c04\u306e\u5272\u308a\u5f53\u3066\u306e\u65cf $(-)^{\\sharp}_{X,Y}: C(X,T(Y)) \\rightarrow C(T(X),T(Y))$\n\n\u304b\u3089\u306a\u308b\u7d44 $\\langle T, \\eta, (-)^{\\sharp} \\rangle$ \u3067\u3042\u3063\u3066\u3001\n\n```math\n\\begin{eqnarray*}\n\\eta_X^{\\sharp} & = & Id_{T(X)}\\\\\nf^{\\sharp} \\circ \\eta_X & = & f\\\\\ng^{\\sharp} \\circ f^{\\sharp} & = & (g^{\\sharp} \\circ f)^{\\sharp}\n\\end{eqnarray*}\n```\n\n\u3092\u6e80\u305f\u3059\u3082\u306e\u306e\u3053\u3068\u3067\u3059\u3002\n\n\u306f\u3044\u3002\u570f\u8ad6\u7684\u306a\u5b9a\u7fa9\u3092\u304c\u3063\u3068\u4e26\u3079\u3066\u3082\u3088\u304f\u308f\u304b\u3089\u306a\u3044\u3067\u3059\u306d\u3002\n\n## \u5b9a\u7fa9\n\n\u3053\u308c\u3092 Coq \u4e0a\u3067\u5b9a\u7fa9\u3059\u308b\u3068\u3001\u4eba\u306b\u3088\u3063\u3066\u306f\u898b\u306a\u308c\u305f\u3082\u306e\u304c\u51fa\u6765\u4e0a\u304c\u308a\u307e\u3059\u3002\n\n```coq\nClass IsKt (C: Category)(T: C -> C)\n      (ret: forall (X: C), C X (T X))\n      (bind: forall {X Y: C}, (C X (T Y)) -> (C (T X) (T Y))) :=\n  {\n    kt_bind_proper:> forall (X Y: C), Proper ((==) ==> (==)) (@bind X Y);\n    kt_ret_bind:\n      forall (X: C), bind (ret X) == Id (T X);\n\n    kt_bind_ret:\n      forall (X Y: C)(f: C X (T Y)),\n        bind f \\o ret X == f;\n\n    kt_bind_comp:\n      forall (X Y Z: C)(f: C X (T Y))(g: C Y (T Z)),\n        bind g \\o bind f == bind (bind g \\o f)\n  }.\n\nClass Kt (C: Category)(T: C -> C) :=\n  {\n    ret: forall {X: C}, C X (T X);\n    bind: forall (X Y: C), C X (T Y) -> C (T X) (T Y);\n\n    kt_prf:> IsKt (@ret) bind\n  }.\nExisting Instance kt_prf.\nNotation \"[ 'Kt' 'by' ret , bind ]\" := (@Build_Kt _ _ ret bind _).\n```\n\n\u305d\u3046\u3067\u3059\u306d\u3002 Haskell \u3067\u3044\u3046 Monad \u304c\u3001\u3053\u306e Kleisli triple \u3067\u3059\u3002\n\u307e\u305f\u3001 Monad \u3068\u306e\u6574\u5408\u6027\u3092\u53d6\u308b\u305f\u3081\u3001\u4eca\u56de `Kt` \u3092\u578b\u30af\u30e9\u30b9\u3068\u3057\u3066\u5b9a\u7fa9\u3057\u307e\u3057\u305f\u3002\n\n## \u51fd\u6570\u578b\u30d7\u30ed\u30b0\u30e9\u30df\u30f3\u30b0\u3068 Kleisli triple\n\n\u3055\u3066\u3001 Kleisli triple \u3092\u5b9a\u7fa9\u3057\u3066\u307f\u305f\u308f\u3051\u3067\u3059\u304c\u3001\u3053\u308c\u306f Haskell \u306e\u30e2\u30ca\u30c9\u3088\u308a\u3082\u307e\u3060\u4e00\u822c\u7684\u306a\u69cb\u9020\u3067\u3059\u3002\n\u4f55\u6545\u304b\u3068\u3044\u3048\u3070\u3001\u4efb\u610f\u306e\u570f\u306b\u5bfe\u3057\u3066\u5b9a\u7fa9\u3055\u308c\u3066\u3044\u308b\u304b\u3089\u3067\u3059\u3002\n\n\u3053\u308c\u304c\u3069\u3046\u3044\u3046\u610f\u5473\u3092\u6301\u3064\u306e\u304b\u3068\u3044\u3044\u307e\u3059\u3068\u3001\u305f\u3068\u3048\u3070 `ret` \u3092\u4f7f\u3063\u3066 `ret x` \u3068\u3044\u3046\u5f0f\u3092\u4f5c\u308b\u3053\u3068\u304c\u51fa\u6765\u307e\u305b\u3093\u3002\n`ret` \u306f `C` \u306e\u5c04\u3067\u3042\u3063\u3066\u3001\u51fd\u6570\u3067\u306f\u306a\u3044\u304b\u3089\u3067\u3059\u3002\n\n\u3057\u304b\u3057\u3001\u51fd\u6570\u578b\u30d7\u30ed\u30b0\u30e9\u30df\u30f3\u30b0\u3092\u3059\u308b\u5834\u5408\u3001\u5c04\u306f\u51fd\u6570\u3068\u3057\u3066\u8003\u3048\u307e\u3059\u3002\n\u3068\u306a\u308b\u3068\u3001\u5b9f\u7528\u4e0a\u306f `Types` (Haskell \u3067\u306f Hask \u570f\u3067\u3059\u304b\u306d)\u4e0a\u306e Kleisli triple \u3092\u8003\u3048\u308b\u3053\u3068\u306b\u306a\u308b\u3067\u3057\u3087\u3046\u3002\n\u305d\u3046\u3059\u308c\u3070\u3001 `ret x` \u306a\u3069\u3082\u66f8\u3051\u307e\u3059\u3057\u3001 do \u8a18\u6cd5\u7684\u306a\u3082\u306e\u3082\u4f7f\u3048\u308b\u3088\u3046\u306b\u306a\u308a\u307e\u3059\u3002\n\n\u3068\u3044\u3046\u3053\u3068\u3067\u3001\u4ee5\u4e0b\u306e\u3088\u3046\u306b\u3057\u3066 `Notation` \u3092\u5b9a\u7fa9\u3057\u3066\u304a\u304d\u307e\u3057\u3087\u3046\u3002\n\n```coq\n(** Special Notation for Kt on Types **)\nNotation \"m >>= f\" := (bind (C:=Types) f m) (at level 53, left associativity).\nNotation \"[ 'do' M 'in' K ]\" := (let _kt := K: Kt Types _ in M). \nNotation \"[ 'do' M ]\" := [do M in _].\nNotation \"x <- m ; p\" := (m >>= (fun x => p)) (at level 60, right associativity).\nNotation \":- x ; m\" := (_ <- x ; m) (at level 61, right associativity, x at next level).\nNotation \"x <-: m ; p\" := (x <- ret m ; p) (at level 60, right associativity).\nNotation \"f >> g\" := (bind (C:=Types) g \\o f) (at level 42, right associativity).\n```\n\n`[do M in K]` \u8a18\u6cd5\u304c\u5730\u5473\u306b\u91cd\u8981\u306a\u5f79\u76ee\u3092\u6301\u3063\u3066\u3044\u307e\u3059\u304c\u3001\u4f7f\u3046\u5834\u9762\u3067\u8aac\u660e\u3057\u307e\u3059\u3002\n\n## \u5177\u4f53\u4f8b\uff1a `Maybe` & `List`\n\n\u3064\u3089\u3064\u3089\u8ff0\u3079\u3066\u3044\u3066\u3082\u4ed5\u65b9\u306a\u3044\u306e\u3067\u3001\u5177\u4f53\u4f8b\u3092\u898b\u3066\u3044\u304d\u307e\u3057\u3087\u3046\u3002\n\n### `Maybe` \u30e2\u30ca\u30c9\n\n\u307e\u305a\u306f\u5931\u6557\u3057\u3046\u308b\u8a08\u7b97\u3092\u8868\u3059 `Maybe` \u3067\u3059\u3002\n\n```coq\nProgram Instance Maybe: Kt Types option :=\n  {\n    ret X x := Some x;\n    bind X Y f m := match m with\n                    | Some x => f x\n                    | None => None\n                    end\n  }.\n```\n\n\u8a08\u7b97\u4f8b\u3092\u898b\u3066\u307f\u307e\u3057\u3087\u3046\u3002\n\u307e\u305a\u306f `hd_error` \u304c\u6210\u529f\u3059\u308b\u4f8b\u3067\u3001\n\n```coq\nEval compute in\n    [do x <-: 0;\n       y <- hd_error [1;2];\n       ret (x, y) in Maybe].\n(* = Some (0, 1) *)\n(* : option (product nat nat) *)\n```\n\n\u6b21\u306f\u5931\u6557\u3059\u308b\u4f8b\u3067\u3059\u3002\n\n```coq\nEval compute in\n    [do x <-: 0;\n       y <- hd_error [];\n       ret (x, y) in Maybe].\n(* = None *)\n(* : option (product nat ?B) *)\n```\n\n\u306f\u3044\u3002\u3061\u3083\u3093\u3068\u6a5f\u80fd\u3057\u3066\u3044\u307e\u3059\u306d\u3002\n\n### `List` \u30e2\u30ca\u30c9\n\n\u3067\u306f\u6b21\u306e\u4f8b\u3001\u975e\u6c7a\u5b9a\u7684\u8a08\u7b97\u3092\u8868\u3059 `List` \u30e2\u30ca\u30c9\u3067\u3059(Kleisli triple \u3067\u3059)\u3002\n\n```coq\nProgram Instance List: Kt Types list :=\n  {\n    ret X x := [x];\n    bind X Y f l := flat_map f l\n  }.\n```\n\n\u8a08\u7b97\u4f8b\u306f\u3053\u3093\u306a\u611f\u3058\u3067\u3059\u3002\n\n```coq\nEval compute in\n    [do x <- [3;1;4;1;5];\n       y <-: (x + 1);\n       ret y in List].\n(* = [4; 2; 5; 2; 6] *)\n(* : list nat *)\n```\n\n\u307e\u305f\u3001\u3053\u306e\u3088\u3046\u306b\u3057\u3066 guard \u3092\u5c0e\u5165\u3059\u308b\u3053\u3068\u3082\u3067\u304d\u307e\u3059(\u4e00\u822c\u306b\u3001\u5931\u6557\u3092\u8868\u73fe\u3067\u304d\u308b\u8a08\u7b97\u306b\u5bfe\u3057\u3066\u5b9a\u7fa9\u53ef\u80fd(\u306a\u306f\u305a)\u3067\u3059\u304c\u3001\u4eca\u56de\u306f `List` \u306b\u7279\u5316\u3055\u305b\u3066\u3044\u307e\u3059)\u3002\n\n```coq\nDefinition guard {X: Type}(b: X -> bool)(x: X): list X :=\n  if b x then [x] else [].\n```\n\n\u3053\u308c\u3092\u4f7f\u3063\u305f\u8a08\u7b97\u4f8b\u304c\u6b21\u306e\u901a\u308a\u3067\u3059\u3002\u3002\n\n```coq\nFixpoint evenb (n: nat): bool :=\n  match n with\n  | O => true\n  | S O => false\n  | S (S n') => evenb n'\n  end.\n\nEval compute in\n    [do x <- [0;1;2;3] ;\n       y <-: (x + 1);\n       :- guard evenb y ;\n       ret x in List].\n(* = [1; 3] *)\n(* : list nat *)\n```\n\n### do \u8a18\u6cd5\n\n\u3055\u3066\u3001\u3055\u304d\u307b\u3069\u89e6\u308c\u305f `[do M in K]` \u8a18\u6cd5\u3067\u3059\u304c\u3001\u3053\u308c\u306f Coq \u4e0a\u3067 Monad (Kleisli triple) \u3092\u6271\u3046\u4e0a\u3067\u306f\u6b20\u304b\u305b\u307e\u305b\u3093\u3002\n\u306a\u305c\u306a\u3089\u3001\u5229\u7528\u3055\u308c\u308b Monad \u306e\u30a4\u30f3\u30b9\u30bf\u30f3\u30b9\u304c\u3001\u76f4\u8fd1\u3067\u5b9a\u7fa9\u3055\u308c\u305f\u30a4\u30f3\u30b9\u30bf\u30f3\u30b9\u306b\u306a\u3063\u3066\u3057\u307e\u3046\u304b\u3089\u3067\u3059(\u3053\u306e\u6319\u52d5\u306f\u3069\u3046\u304b\u3068\u601d\u3046\u306e\u3067\u3059\u304c\u3001\u73fe\u72b6\u305d\u3046\u306a\u3063\u3066\u3057\u307e\u3063\u3066\u3044\u308b\u306e\u3067\u3001\u3069\u3046\u3057\u3088\u3046\u3082\u306a\u3044\u3067\u3059)\u3002\n\u305d\u306e\u305f\u3081\u3001 `let` \u3092\u4f7f\u3063\u3066 `M` \u3092\u56f2\u3080\u30a4\u30f3\u30b9\u30bf\u30f3\u30b9\u3092 `K` \u3067\u4e0a\u66f8\u304d\u3059\u308b\u3053\u3068\u3067\u3001\u5229\u7528\u3059\u308b do \u8a18\u6cd5\u3067\u5229\u7528\u3059\u308b\u578b\u30af\u30e9\u30b9\u306e\u30a4\u30f3\u30b9\u30bf\u30f3\u30b9\u3092\u6307\u5b9a\u3067\u304d\u308b\u3088\u3046\u306b\u3057\u3066\u3044\u308b\u306e\u3067\u3059\u3002\n\n\u305d\u306e\u7d50\u679c\u3001\u4ee5\u4e0b\u306e\u3088\u3046\u306a\u30cd\u30b9\u30c8\u3057\u305f do \u8a18\u6cd5\u3082\u53ef\u80fd\u306b\u306a\u3063\u3066\u3044\u307e\u3059\u3002\n\n```coq\nEval compute in\n    [do x <-: 0;\n       y <- (hd_error\n               [do x <- [0;1;2;3] ;\n                  y <-: (x + 1);\n                  :- guard evenb y ;\n                  ret x in List]);\n       ret (x, y) in Maybe].\n(* = Some (0, 1) *)\n(* : option (product nat nat) *)\n```\n\n## \u30e2\u30ca\u30c9\u3068 Kleisli triple \u306e\u7b49\u4fa1\u6027\n\n\u30e2\u30ca\u30c9\u304b\u3089 Kleisli triple \u304c\u4f5c\u308c\u3001\u305d\u306e\u9006\u3082\u53ef\u80fd\u3067\u3001\u3055\u3089\u306b\u305d\u306e\u4e8c\u3064\u306e\u69cb\u6210\u306f\u4e92\u3044\u306b\u9006\u306b\u306a\u3063\u3066\u3044\u307e\u3059\u3002\n\u6570\u5f0f\u3067\u66f8\u304f\u306e\u306f\u9762\u5012\u306a\u306e\u3067\u5272\u611b\u3057\u307e\u3059\u304c\u3001 Coq \u4e0a\u3067\u66f8\u304f\u3068\u6b21\u306e\u3088\u3046\u306b\u306a\u308a\u307e\u3059\u3002\n\n```coq\nProgram Definition Kt_from_Monad (C: Category)(T: Monad C)\n  : Kt C T :=\n  [Kt by monad_unit T,\n         fun (X Y: C)(f: C X (T Y)) =>\n           monad_mult T Y \\o fmap T f].\n\nProgram Definition Monad_from_Kt (C: Category)(T: C -> C)(kt: Kt C T) :=\n  [Monad by [Functor by f :-> bind (ret \\o f) with X :-> T X],\n            [X :=> ret],\n            [X :=> bind (Id (T X))]].\n```\n\n\u3053\u306e\u4e8c\u3064\u304c\u4e92\u3044\u306b\u9006\u3067\u3042\u308b\u3053\u3068\u3092\u793a\u3059\u305f\u3081\u3001\u307e\u305a\u306f\u30e2\u30ca\u30c9\u3068 Kleisli triple \u306e\u7b49\u4fa1\u6027\u3092\u5b9a\u7fa9\u3057\u3066\u304a\u304d\u307e\u3059\u3002\n\n```coq\nProgram Definition Monad_setoid (C: Category) :=\n  [Setoid by (fun (M N: Monad C) =>\n                (monad_functor M == monad_functor N)\n                /\\(forall X: C, monad_unit M X =H monad_unit N X)\n                /\\(forall X: C, monad_mult M X =H monad_mult N X))].\n\nProgram Definition Kt_setoid (C: Category)(T: C -> C) :=\n  [Setoid by (fun (k k': Kt C T) =>\n                (forall X: C, ret (Kt:=k)(X:=X) == ret (Kt:=k'))\n                /\\(forall (X Y: C)(f: C X (T Y)),\n                      bind (Kt:=k) f == bind (Kt:=k') f))].\n```\n\n\u305d\u3046\u3059\u308b\u3068\u3001\u4ee5\u4e0b\u306e\u3088\u3046\u306b\u3057\u3066\u305d\u306e\u4e8b\u5b9f\u3092\u793a\u3059\u3053\u3068\u304c\u3067\u304d\u308b\u3088\u3046\u306b\u306a\u308a\u307e\u3059(\u8a3c\u660e\u306f\u7701\u7565\u3057\u3066\u3044\u307e\u3059\u304c)\u3002\n\n```coq\nLemma Monad_Kt_Monad_eq:\n  forall (C: Category)(T: Monad C),\n    T == Monad_from_Kt (Kt_from_Monad T) in Monad_setoid C.\n\nLemma Kt_Monad_Kt_eq:\n  forall (C: Category)(T: C -> C)(kt: Kt C T),\n    kt == Kt_from_Monad (Monad_from_Kt kt) in Kt_setoid C T.\n```\n\n\n# \u76f4\u7a4d\u3068\u7f83\u306e\u968f\u4f34\u304b\u3089 State \u30e2\u30ca\u30c9\u3092\u69cb\u6210\u3059\u308b\n\n\n\u3055\u3066\u3001\u6709\u540d\u306a\u4f8b\u3067\u3059\u304c\u3001\u76f4\u7a4d\u3092\u4e0e\u3048\u308b\u64cd\u4f5c $(-,Y): C \\rightarrow C$ \u3068\u7f83\u3092\u4e0e\u3048\u308b\u64cd\u4f5c $(-)^Y: C \\rightarrow C$ \u306f\u305d\u308c\u305e\u308c\u51fd\u624b\u306b\u306a\u308a\u307e\u3059\u3002\n\u305d\u3057\u3066\u3001\u3053\u306e\u4e8c\u3064\u306f\u968f\u4f34 $(-,Y)\\dashv (-)^Y$ \u3092\u306a\u3057\u3001\u305d\u306e\u968f\u4f34\u304b\u3089\u69cb\u6210\u3055\u308c\u308b\u30e2\u30ca\u30c9(\u304b\u3089\u4f5c\u3089\u308c\u308b Kleisli triple)\u304c State \u30e2\u30ca\u30c9\u306b\u306a\u308a\u307e\u3059\u3002\n\n\u4ee5\u4e0b\u3001\u9806\u3092\u8ffd\u3063\u3066\u305d\u308c\u3092\u898b\u3066\u3044\u304d\u307e\u3057\u3087\u3046\u3002\n\n\u3067\u3059\u304c\u305d\u306e\u524d\u306b\u3001\u307e\u305a\u3001\u5927\u4e8b\u306a\u3053\u3068\u3092\u3084\u3063\u3066\u304a\u304d\u307e\u3059\u3002\n**\u570f `Types` \u4e0a\u3067 State \u30e2\u30ca\u30c9\u3092\u4f5c\u308b\u306b\u306f Functional extensionality \u304c\u5fc5\u8981\u3067\u3059\u3002**\n\n```coq\nRequire Import FunctionalExtensionality.\n```\n\n## \u76f4\u7a4d\u51fd\u624b\n\n[\u4ee5\u524d\u3001 Coq \u4e0a\u3067\u306e\u76f4\u7a4d\u306f\u5b9a\u7fa9\u3057\u307e\u3057\u305f](http://qiita.com/mathink/items/2067c162fb7cf8f6c83f#%E7%9B%B4%E7%A9%8D%E3%81%A8%E7%9B%B4%E5%92%8C) \u304c\u3001\u518d\u63b2\u3057\u3066\u304a\u304d\u307e\u3059\u3002\n\n```coq\nClass IsProduct (C: Category)(X Y: C)\n      (P: C)(pi1: C P X)(pi2: C P Y)\n      (univ: forall (Z: C), C Z X -> C Z Y -> C Z P) :=\n  {\n    product_universality_1:\n      forall (Z: C)(p1: C Z X)(p2: C Z Y),\n        (p1 == pi1 \\o univ Z p1 p2);\n\n    product_universality_2:\n      forall (Z: C)(p1: C Z X)(p2: C Z Y),\n        (p2 == pi2 \\o univ Z p1 p2);\n    \n    product_uniqueness:\n      forall (Z: C)(p1: C Z X)(p2: C Z Y)(u: C Z P),\n        (p1 == pi1 \\o u) ->\n        (p2 == pi2 \\o u) ->\n        u == univ Z p1 p2\n  }.\n\nStructure Product (C: Category)(X Y: C) :=\n  {\n    product_obj:> C;\n    product_proj1: C product_obj X;\n    product_proj2: C product_obj Y;\n\n    product_univ: forall (Z: C), C Z X -> C Z Y -> C Z product_obj;\n\n    product_prf:> IsProduct product_proj1 product_proj2 (@product_univ)\n  }.\nExisting Instance product_prf.\n\nNotation \"[ 'Product' P 'by' univ 'with' pi1 , pi2 ]\" :=\n  (@Build_Product _ _ _ P pi1 pi2 univ _).\nNotation \"[ 'Product' 'by' univ 'with' pi1 , pi2 ]\" :=\n  [Product _ by univ with pi1, pi2].\n\nNotation \"[ f , g 'to' P ]\" := (product_univ P f g).\nNotation \"pi1_{ P }\" := (product_proj1 P) (at level 0, no associativity, format \"pi1_{ P }\").\nNotation \"pi2_{ P }\" := (product_proj2 P) (at level 0, no associativity, format \"pi2_{ P }\").\n```\n\n\u6b21\u306b\u3001 `Types` \u4e0a\u3067\u306e `Product` \u3092\u69cb\u6210\u3057\u307e\u3059\u3002\n\n```coq\nInductive product (A B: Type): Type :=\n| pair_of (fst: A)(snd: B).\n\nDefinition fst (A B: Type)(p: product A B): A :=\n  match p with\n  | pair_of a _ => a\n  end.\n\nDefinition snd (A B: Type)(p: product A B): B :=\n  match p with\n  | pair_of _ b => b\n  end.\n\nNotation \"( x , y )\" := (pair_of x y) (format \"( x ,  y )\").\n\nNotation \"p .1\" := (fst p) (at level 5, left associativity, format \"p .1\").\nNotation \"p .2\" := (snd p) (at level 5, left associativity, format \"p .2\").\n\nProgram Definition product_of_Types (X Y: Type)\n  : Product Types X Y :=\n  [Product (product X Y) by (fun P f g x => (f x, g x))\n   with @fst X Y, @snd X Y].\n```\n\n\u305d\u3057\u3066\u3001\u76f4\u7a4d\u3092\u4e0e\u3048\u308b\u64cd\u4f5c\u304b\u3089\u51fd\u624b\u3092\u69cb\u6210\u3057\u307e\u3059\u3002\n\u6761\u4ef6\u3068\u3057\u3066\u5fc5\u8981\u306a\u306e\u306f\u4efb\u610f\u306e\u4e8c\u5bfe\u8c61\u306b\u5bfe\u3057\u3066\u305d\u306e\u76f4\u7a4d\u304c\u5b58\u5728\u3059\u308b\u3053\u3068\u3067\u3059\u3002\n\n```coq\nDefinition product_map (C: Category)(prod: forall (X Y: C), Product C X Y)\n           (X X' Y Y': C)(f: C X Y)(g: C X' Y')\n  : C (prod X X') (prod Y Y') :=\n  [f \\o pi1_{prod X X'} , g \\o pi2_{prod X X'} to (prod Y Y')].\nNotation \"[ f \\* g 'with' prod ]\" := (product_map prod f g).\n\nProgram Definition Product_2_functor (C: Category)(prod: forall X Y: C, Product C X Y)(Y: C)\n  : C --> C :=\n  [Functor by (fun (W X: C)(f: C W X) => [f \\* Id _ with prod ])\n   with (fun X => prod X Y) ].\n```\n\n\n## \u7f83\n\n\u7f83\u306e\u570f\u8ad6\u7684\u5b9a\u7fa9\u306f [\u3053\u3061\u3089(wikipedia)](https://ja.wikipedia.org/wiki/%E5%86%AA%E5%AF%BE%E8%B1%A1) \u3092\u5fa1\u53c2\u7167\u304f\u3060\u3055\u3044\u3002\n\u3053\u308c\u3092 Coq \u4e0a\u3067\u5b9a\u7fa9\u3059\u308b\u3068\u6b21\u306e\u3088\u3046\u306b\u306a\u308a\u307e\u3059\u3002\n\n```coq\nClass IsExponential\n      (C: Category)\n      (prod: forall (X Y: C), Product C X Y)\n      (Y Z: C)\n      (exp: C)(ev: C (prod exp Y) Z)\n      (univ: forall (X: C)(g: C (prod X Y) Z), C X exp) :=\n  {\n    exp_universality:\n      forall (X: C)(g: C (prod X Y) Z),\n        g == ev \\o [univ X g \\* Id Y with prod];\n    exp_uniqueness:\n      forall (X: C)(g: C (prod X Y) Z)(u: C X exp),\n        g == ev \\o [u \\* Id Y with prod] ->\n        u == univ X g\n  }.\n\nStructure Exponential\n          (C: Category)(prod: forall (X Y: C), Product C X Y)\n          (Y Z: C) :=\n  {\n    exp_obj:> C;\n    exp_eval: C (prod exp_obj Y) Z;\n    exp_univ: forall (X: C), C (prod X Y) Z -> C X exp_obj;\n\n    exp_prf:> IsExponential exp_eval exp_univ\n  }.\nExisting Instance exp_prf.\n\nNotation \"[ 'Exp' exp 'by' univ 'with' eval ]\" :=\n  (@Build_Exponential _ _ _ _ exp eval univ _).\nNotation \"[ 'Exp' 'by' univ 'with' eval ]\" :=\n  [Exp _ by univ with eval].\nNotation \"[ 'curry' f 'to' exp ]\" := (exp_univ exp f) (f at next level).\n```\n\n\u305d\u3057\u3066 `Types` \u4e0a\u3067\u306e\u7f83\u5bfe\u8c61\u3092\u5b9a\u7fa9\u3057\u307e\u3059\u3002\nFunctional extenstionality \u304c\u5fc5\u8981\u306b\u306a\u308b\u306e\u306f\u3053\u3053\u3067\u3059\u3002\n\n```coq\nProgram Definition exponential_of_Types (Y Z: Type)\n  : Exponential (C:=Types) product_of_Types Y Z :=\n  [Exp (Y -> Z)\n    by (fun (X: Type) f x y => f (x, y))\n   with (fun gy => gy.1 gy.2)].\n```\n\n\u7f83\u3092\u4e0e\u3048\u308b\u64cd\u4f5c\u304b\u3089\u306f\u6b21\u306e\u3088\u3046\u306b\u3057\u3066\u51fd\u624b\u304c\u69cb\u6210\u3067\u304d\u307e\u3059\u3002\n\n```coq\nProgram Definition Exponential_functor\n        (C: Category)(prod: forall (X Y: C), Product C X Y)\n        (exp: forall (Y Z: C), Exponential prod Y Z)\n        (X: C)\n  : C --> C :=\n  [Functor by (fun (Y Z: C)(g: C Y Z) => [curry (g \\o exp_eval (exp X Y)) to (exp X Z)])\n   with (fun Y => exp X Y)].\n```\n\n## State \u30e2\u30ca\u30c9\n\n\u3055\u3066\u3001\u76f4\u7a4d\u3001\u7f83\u3001\u968f\u4f34\u3001\u30e2\u30ca\u30c9\u3001Kleisli triple \u3068\u3044\u3046\u5fc5\u8981\u306a\u9053\u5177\u3092\u5b9a\u7fa9\u3057\u7d42\u3048\u305f\u306e\u3067\u3001 State \u30e2\u30ca\u30c9\u3092\u4f5c\u308a\u307e\u3057\u3087\u3046\u3002\n\n\u307e\u305a\u3001\u76f4\u7a4d\u3068\u7f83\u306e\u968f\u4f34\u306f\u6b21\u306e\u3088\u3046\u306b\u3057\u3066\u69cb\u6210\u3067\u304d\u307e\u3059\u3002\n$C(X\\times Y, Z) \\rightarrow C(X,Z^Y)$ \u306f\u3044\u308f\u3086\u308b\u30ab\u30ea\u30fc\u5316\u3067\u3059\u306d\u3002\n\n```coq\nProgram Definition prod_exp_adjunction\n        (C: Category)\n        (prod: forall (X Y: C), Product C X Y)\n        (exp: forall (Y Z: C), Exponential prod Y Z)\n        (Y: C)\n  : Product_2_functor prod Y -| Exponential_functor exp Y :=\n  [Adj by (fun X Z => [f in C (prod X Y) Z :-> [curry f to exp Y Z]]),\n          (fun X Z => [f in C X (exp Y Z) :-> exp_eval (exp Y Z) \\o [f \\* Id Y with prod]])].\n```\n\n\u3061\u306a\u307f\u306b\u3001\u5b9a\u7fa9\u3092\u898b\u3066\u308f\u304b\u308b\u3088\u3046\u306b\u3001\u76f4\u7a4d\u3068\u7f83\u304c\u5b58\u5728\u3059\u308c\u3070\u3053\u306e\u968f\u4f34\u306f\u4efb\u610f\u306e\u570f\u3067\u69cb\u6210\u53ef\u80fd\u3067\u3059(\u3068\u3044\u3046\u3053\u3068\u306f `Setoids` \u4e0a\u3067\u3082 State \u30e2\u30ca\u30c9\u3092\u4f5c\u308c\u308b\u3093\u3067\u3059\u304c\u3001\u3053\u306e\u8a18\u4e8b\u3067\u306f\u6271\u3044\u307e\u305b\u3093)\u3002\n\n\u305d\u3057\u3066\u3001 State \u30e2\u30ca\u30c9\u306f\u6b21\u306e\u3088\u3046\u306b\u3057\u3066\u5b9a\u7fa9\u3067\u304d\u307e\u3059\u3002\n\n```coq\nInstance State (S: Type): Kt Types _ :=\n  Kt_from_Monad\n    (Monad_from_adj\n       (prod_exp_adjunction exponential_of_Types S)).\n```\n\n\u306a\u304a\u3001 `Kt` \u306e\u5f15\u6570\u3068\u3057\u3066\u4e0e\u3048\u308b\u578b\u5909\u63db\u5b50\u306f\u5b9a\u7fa9\u304b\u3089\u63a8\u8ad6\u3057\u3066\u3044\u307e\u3059\u3002\n\u5b9f\u969b\u306b\u3069\u3093\u306a\u3082\u306e\u306a\u306e\u304b\u3092\u898b\u3066\u307f\u308b\u3068\u3001\n\n```coq\nDefinition kt_fobj {C: Category}{T: C -> C}(kt: Kt C T) := T.\n\nDefinition state (S: Type) := kt_fobj (State S).\nEval compute in state.\n(* = fun S H : Type => S -> product H S *)\n(* : Type -> Types -> Types *)\n```\n\n\u306f\u3044\u3002\u666e\u901a\u306e State \u30e2\u30ca\u30c9\u3067\u4f7f\u308f\u308c\u308b\u578b\u5909\u63db\u5b50\u3068\u540c\u3058\u5f62\u3092\u3057\u3066\u3044\u307e\u3059\u3002\n\u306a\u3093\u304b\u4e0a\u624b\u304f\u3044\u3063\u3066\u3044\u308b\u3088\u3046\u306a\u6c17\u304c\u3057\u307e\u3059\u306d\u3002\n\n\u3067\u306f\u3001\u5b9f\u969b\u306b\u8a08\u7b97\u3092\u3057\u3066\u307f\u307e\u3057\u3087\u3046\u3002\n\n\u3068\u3001\u305d\u306e\u524d\u306b\u88dc\u52a9\u51fd\u6570\u305f\u3061\u3092\u5b9a\u7fa9\u3057\u307e\u3059\u3002\n\n```coq\nDefinition put {S: Type}(s: S): state S unit :=\n  (fun _: S => (tt, s)).\n\nDefinition get {S: Type}: state S S :=\n  (fun s: S => (s, s)).\n\nDefinition modify {S: Type}(f: S -> S): state S unit :=\n  [do s <- get ; put (f s) in State S].\n\nDefinition evalState {S: Type}(X: Type)(m: state S X)(s: S) := m s.\n```\n\n\u898b\u899a\u3048\u306e\u3042\u308b\u3082\u306e\u305f\u3061\u3067\u3059\u306d\u3002\n\u3053\u308c\u3089\u3092\u4f7f\u3063\u305f\u8a08\u7b97\u4f8b\u306f\u6b21\u306e\u3088\u3046\u306b\u306a\u308a\u307e\u3059\u3002\n\n```coq\nEval compute in\n    [do x <-: 0;\n       y <-: 1;\n       ret (x, y) in State nat].\n(* = fun y : nat => ((0, 1), y) *)\n(* : (Monad_from_adj (prod_exp_adjunction exponential_of_Types nat)) *)\n(*     (product nat nat) *)\n\nEval compute in\n    [do x <-: 0;\n       :- modify S;\n       s <- get;\n       ret (x, s) in State nat].\n(* = fun y : nat => ((0, S y), S y) *)\n(* : (Monad_from_adj (prod_exp_adjunction exponential_of_Types nat)) *)\n(*     (product nat nat) *)\n```\n\n\u671f\u5f85\u901a\u308a\u306e\u6319\u52d5\u3067\u3059\u306d\u3002\n\n`evalState` \u3082\u3053\u306e\u901a\u308a\u3067\u3059\u3002\n\n```coq\nEval compute in\n    evalState [do x <-: 0;\n                 :- modify S;\n                 s <- get;\n                 ret (x, s) in State nat] 5.\n(*   = ((0, 6), 6) *)\n(* : (Product_2_functor product_of_Types nat) (product nat nat) *)\n```\n\n\u3082\u3061\u308d\u3093\u3001\u30e2\u30ca\u30c9\u306e\u30cd\u30b9\u30c8\u3082\u51fa\u6765\u307e\u3059\u3002\n\n```coq\nEval compute in\n    [do x <-: 2;\n       y <-: (evalState [do x <-: 1;\n                           modify (plus x) in State nat]\n                        x);\n       ret (x, y.2) in Maybe].\n(* = Some (2, 3) *)\n(* : option (product nat nat) *)\n\nEval compute in\n    [do x <-: 2;\n       y <-: (evalState [do x <-: 1;\n                           modify (plus x) in State nat]\n                        x);\n       ret (x, y.2) in State bool].\n(* = fun y : bool => ((2, 3), y) *)\n(* : (Monad_from_adj (prod_exp_adjunction exponential_of_Types bool)) *)\n(*     (product nat nat) *)\n```\n\n\u3068\u3044\u3046\u308f\u3051\u3067\u3001 State \u30e2\u30ca\u30c9\u3092\u4f5c\u3063\u3066\u5b9f\u969b\u306b\u52d5\u304f\u304b\u78ba\u304b\u3081\u3066\u307f\u308b\u3001\u3067\u3057\u305f\u3002\n\n# \u6700\u5f8c\u306b\n\n\u5f53\u7136\u3067\u3059\u304c\u3001 State \u30e2\u30ca\u30c9\u306f\u666e\u901a\u306b\u5b9a\u7fa9\u3057\u305f\u65b9\u304c\u697d\u3067\u3059\u3002\n\n```coq\nDefinition state (S: Type) := (fun (A: Type) => S -> product A S).\n\nProgram Instance State (S: Type): Kt Types (state S) :=\n  {\n    ret X x s := (x, s);\n    bind X Y f m s := let (x, s') := m s in f x s'\n  }.\n```\n\n\u3053\u308c\u307e\u3067\u306e\u8b70\u8ad6\u306f\u3001 Coq \u4e0a\u3067\u5c55\u958b\u3057\u305f\u570f\u8ad6\u304c\u3001 State \u30e2\u30ca\u30c9\u307f\u305f\u3044\u306a\u3088\u304f\u4f7f\u308f\u308c\u308b\u9053\u5177\u305f\u3061\u3068\u6574\u5408\u6027\u304c\u53d6\u308c\u3066\u3044\u308b\u3053\u3068\u3092\u78ba\u8a8d\u3059\u308b\u4f5c\u696d\u307f\u305f\u3044\u306a\u3082\u306e\u3067\u3059\u3002\n\u305d\u306e\u304a\u304b\u3052\u3067 Coq \u4e0a\u3067\u306e\u570f\u8ad6\u306e\u65b9\u5411\u6027\u304c\u9593\u9055\u3063\u3066\u306a\u3044\u304b\u306a\u3001\u3063\u3066\u306e\u3092\u78ba\u8a8d\u3067\u304d\u308b\u306e\u3067\u3001\u4f8b\u3068\u3057\u3066\u306f\u3068\u3066\u3082\u6709\u610f\u7fa9\u306a\u3093\u3067\u3059\u3051\u3069\u306d\u3002\n\n\u3053\u308c\u3082\u542b\u3081\u3066\u56db\u672c\u306e\u8a18\u4e8b\u3092\u66f8\u304d\u6bb4\u3063\u3066\u304d\u307e\u3057\u305f\u304c\u3001\u4e00\u5fdc\u3001\u7d50\u8ad6\u3068\u3057\u3066\u3084\u308a\u305f\u304b\u3063\u305f\u3053\u3068(State \u30e2\u30ca\u30c9)\u304c\u51fa\u6765\u307e\u3057\u305f\u3002\n\u3068\u308a\u3042\u3048\u305a\u3001\u3053\u308c\u307e\u3067\u306e\u65b9\u91dd\u3067\u3082\u3046\u5c11\u3057\u51fd\u6570\u578b\u30d7\u30ed\u30b0\u30e9\u30df\u30f3\u30b0\u5bc4\u308a\u306e\u570f\u8ad6\u3092\u3084\u3063\u3066\u3044\u304d\u305f\u3044\u3067\u3059\u306d\u3001\u3068\u3044\u3046\u611f\u3058\u3067\u3059\u3002\n\n\u306a\u3093\u304b\u3044\u3044\u30cd\u30bf\u306a\u3044\u304b\u3057\u3089\u3002\n\n# \u6b21\u56de\u4e88\u544a\n\nKan \u62e1\u5f35\u3002\n\n", "tags": ["Coq", "Coq-8.5"]}