{"context": " More than 1 year has passed since last update.Tick-Tack-Toe\u306e\u5224\u5b9a\u3092Haskell\u3067\u66f8\u304d\u76f4\u3057\u3066\u307f\u305f\u30b3\u30fc\u30c9\u30022\u6642\u9593\u304f\u3089\u3044\u304b\u304b\u3063\u305f\u6c17\u304c\u3059\u308b\u3002\u7f6e\u3044\u3068\u3051\u3070\u30d5\u30eb\u30dc\u30c3\u30b3\u30fb\u30fb\u30fb\u3044\u3084\u3001\u8ab0\u304b\u304c\u52dd\u624b\u306b\u63a1\u70b9\u3057\u3066\u304f\u308c\u308b\u3093\u3058\u3083\u306a\u3044\u304b\u3068\u671f\u5f85\u3002\ngist\u306b\u3082\u7f6e\u3044\u305f\u3002\n\ntick_tack_toe_test.hs\nimport Test.HUnit\nimport TickTackToe\n\nparseLine :: String -> (String, String, String)\nparseLine line = let (num, left) = break (== '\\t') line\n                     (input, output) = break (== '\\t') $ tail left\n                 in (num, input, tail output)\n\nrunAllTest :: [(String, String, String)] -> IO ()\nrunAllTest testCases = do\n  let tests = TestList $ fmap testLabel testCases\n  runTestTT tests\n  return ()\n    where testLabel (num, input, output) =\n              TestCase $ assertEqual num output (solve input)\n\nmain :: IO ()\nmain = do\n  contents <- readFile \"tick_tack_toe_test_case.tsv\"\n  let testCases = fmap parseLine $ lines contents\n  runAllTest testCases\n\n\n\nTickTackToe.hs\nmodule TickTackToe (solve) where\n\ndata Player = Player { name :: String }\n              deriving (Eq, Show)\ndata Cell = Empty | Owned Player\n            deriving (Eq, Show)\ndata Result = Draw | Winner Player | Faul Player\n              deriving (Eq, Show)\ntype Point = (Int, Int)\ntype Board = [[Cell]]\n\nsolve :: String -> String\nsolve input = case process input' (head players) (initialBoard size) of\n                Draw -> \"Draw game.\"\n                Winner p -> (name p) ++ \" won.\"\n                Faul p -> \"Foul : \" ++ (name $ nextPlayer p) ++ \" won.\"\n    where\n      input' = take (size * size) input\n      process :: String -> Player -> Board -> Result\n      process [] _ _ = Draw\n      process (x:xs) player board =\n          let pt = numberToPoint (read $ x : \"\") size\n          in\n            case checkBoard board pt of\n              Owned _ -> Faul player\n              Empty -> let nextBoard = putBoard board pt player\n                       in if (checkHorizontal nextBoard pt ||\n                              checkVertical nextBoard pt ||\n                              checkDiagonal nextBoard pt)\n                          then Winner player\n                          else process xs (nextPlayer player) nextBoard\n\nsize :: Int\nsize = 3\n\ninitialBoard :: Int -> Board\ninitialBoard s = replicate s $ replicate s Empty\n\nnumberToPoint :: Int -> Int -> Point\nnumberToPoint n s = (n' `div` s, n' `mod` s)\n    where n' = n - 1\n\nputBoard :: Board -> Point -> Player -> Board\nputBoard board pt player = fmap processRow $ zip board [0..]\n    where processRow (row, y) = fmap ( \\(cell, x) ->\n                                           if (x, y) == pt\n                                           then Owned player\n                                           else cell ) $\n                                zip row [0..]\n\ncheckBoard :: Board -> Point -> Cell\ncheckBoard board (x, y) = (board !! y) !! x\n\nplayers :: [Player]\nplayers = [Player \"o\", Player \"x\"]\n\nnextPlayer :: Player -> Player\nnextPlayer player = nextPlayer' players player\n    where nextPlayer' (x:y:ys) p =\n              if x == p then y else nextPlayer' (y:ys) p\n          nextPlayer' _ _ = head players\n\ncheckHorizontal :: Board -> Point -> Bool\ncheckHorizontal board (_, y) = isOccupied line\n    where line = board !! y\n\ncheckVertical :: Board -> Point -> Bool\ncheckVertical board (x, _) =  isOccupied line\n    where line = fmap (!! x) board\n\ncheckDiagonal :: Board -> Point -> Bool\ncheckDiagonal board (x, y) = x == y && isOccupied diagonalA\n                             || x == (bSize - y - 1) && isOccupied diagonalB\n    where diagonalA = fmap (\\i -> checkBoard board (i, i)) [0..2]\n          diagonalB = fmap (\\i -> checkBoard board (i, bSize - i - 1)) [0..2]\n          bSize = length board\n\nisOccupied :: [Cell] -> Bool\nisOccupied line = isOccupied' (head line) line\n    where isOccupied' _ [] = True\n          isOccupied' cell (x:xs) =\n              if cell /= x then False else isOccupied' cell xs\n\n\nHaskell \u306f\u30c8\u30c3\u30d7\u30c0\u30a6\u30f3\u3067\u66f8\u3044\u3066\u3044\u304f\u3068\u304d\u306b\u3001\u578b\u304c\u5f37\u529b\u306a\u30e1\u30e2\u4ee3\u308f\u308a\u306b\u306a\u3063\u3066\u304f\u308c\u308b\u306e\u304c\u9762\u767d\u3044\u611f\u899a\u3060\u3063\u305f\u3002\u307e\u3060\u66f8\u3044\u3066\u306a\u3044\u95a2\u6570\u3067\u3082\u3001\u578b\u3055\u3048\u9069\u5207\u306b\u6c7a\u3081\u3066\u304a\u3051\u3070\u5b89\u5fc3\u3057\u3066\u30ac\u30b7\u30ac\u30b7\u7d44\u307f\u7acb\u3066\u3089\u308c\u308b\u306e\u304c\u5b09\u3057\u3044\u3002\n\n\u8ffd\u8a18\nt_uchida\u3055\u3093\u306e\u56de\u7b54\u3002\n\ntoEnum\u3068fromEnum\u4fbf\u5229\nfilter \u304b\u3089 insert\u306e\u6d41\u308c\u304c\u3059\u3066\u304d\ndrop \u3068 take \u3068 iterate \u306e\u4f7f\u3044\u65b9\u304c\u5de7\u5999\ntranspose \u306f\u3068\u3082\u304b\u304f\u659c\u3081\u3092\u4f5c\u308b\u306e\u306f zipWith \u304b\u3042\n\n[Tick-Tack-Toe\u306e\u5224\u5b9a](http://nabetani.sakura.ne.jp/hena/1/)\u3092Haskell\u3067\u66f8\u304d\u76f4\u3057\u3066\u307f\u305f\u30b3\u30fc\u30c9\u30022\u6642\u9593\u304f\u3089\u3044\u304b\u304b\u3063\u305f\u6c17\u304c\u3059\u308b\u3002\u7f6e\u3044\u3068\u3051\u3070\u30d5\u30eb\u30dc\u30c3\u30b3\u30fb\u30fb\u30fb\u3044\u3084\u3001\u8ab0\u304b\u304c\u52dd\u624b\u306b\u63a1\u70b9\u3057\u3066\u304f\u308c\u308b\u3093\u3058\u3083\u306a\u3044\u304b\u3068\u671f\u5f85\u3002\n\n[gist\u306b\u3082\u7f6e\u3044\u305f](https://gist.github.com/3061413)\u3002\n\n```haskell:tick_tack_toe_test.hs\nimport Test.HUnit\nimport TickTackToe\n\nparseLine :: String -> (String, String, String)\nparseLine line = let (num, left) = break (== '\\t') line\n                     (input, output) = break (== '\\t') $ tail left\n                 in (num, input, tail output)\n\nrunAllTest :: [(String, String, String)] -> IO ()\nrunAllTest testCases = do\n  let tests = TestList $ fmap testLabel testCases\n  runTestTT tests\n  return ()\n    where testLabel (num, input, output) =\n              TestCase $ assertEqual num output (solve input)\n\nmain :: IO ()\nmain = do\n  contents <- readFile \"tick_tack_toe_test_case.tsv\"\n  let testCases = fmap parseLine $ lines contents\n  runAllTest testCases\n```\n\n```haskell:TickTackToe.hs\nmodule TickTackToe (solve) where\n\ndata Player = Player { name :: String }\n              deriving (Eq, Show)\ndata Cell = Empty | Owned Player\n            deriving (Eq, Show)\ndata Result = Draw | Winner Player | Faul Player\n              deriving (Eq, Show)\ntype Point = (Int, Int)\ntype Board = [[Cell]]\n\nsolve :: String -> String\nsolve input = case process input' (head players) (initialBoard size) of\n                Draw -> \"Draw game.\"\n                Winner p -> (name p) ++ \" won.\"\n                Faul p -> \"Foul : \" ++ (name $ nextPlayer p) ++ \" won.\"\n    where\n      input' = take (size * size) input\n      process :: String -> Player -> Board -> Result\n      process [] _ _ = Draw\n      process (x:xs) player board =\n          let pt = numberToPoint (read $ x : \"\") size\n          in\n            case checkBoard board pt of\n              Owned _ -> Faul player\n              Empty -> let nextBoard = putBoard board pt player\n                       in if (checkHorizontal nextBoard pt ||\n                              checkVertical nextBoard pt ||\n                              checkDiagonal nextBoard pt)\n                          then Winner player\n                          else process xs (nextPlayer player) nextBoard\n\nsize :: Int\nsize = 3\n\ninitialBoard :: Int -> Board\ninitialBoard s = replicate s $ replicate s Empty\n\nnumberToPoint :: Int -> Int -> Point\nnumberToPoint n s = (n' `div` s, n' `mod` s)\n    where n' = n - 1\n\nputBoard :: Board -> Point -> Player -> Board\nputBoard board pt player = fmap processRow $ zip board [0..]\n    where processRow (row, y) = fmap ( \\(cell, x) ->\n                                           if (x, y) == pt\n                                           then Owned player\n                                           else cell ) $\n                                zip row [0..]\n\ncheckBoard :: Board -> Point -> Cell\ncheckBoard board (x, y) = (board !! y) !! x\n\nplayers :: [Player]\nplayers = [Player \"o\", Player \"x\"]\n\nnextPlayer :: Player -> Player\nnextPlayer player = nextPlayer' players player\n    where nextPlayer' (x:y:ys) p =\n              if x == p then y else nextPlayer' (y:ys) p\n          nextPlayer' _ _ = head players\n\ncheckHorizontal :: Board -> Point -> Bool\ncheckHorizontal board (_, y) = isOccupied line\n    where line = board !! y\n\ncheckVertical :: Board -> Point -> Bool\ncheckVertical board (x, _) =  isOccupied line\n    where line = fmap (!! x) board\n\ncheckDiagonal :: Board -> Point -> Bool\ncheckDiagonal board (x, y) = x == y && isOccupied diagonalA\n                             || x == (bSize - y - 1) && isOccupied diagonalB\n    where diagonalA = fmap (\\i -> checkBoard board (i, i)) [0..2]\n          diagonalB = fmap (\\i -> checkBoard board (i, bSize - i - 1)) [0..2]\n          bSize = length board\n\nisOccupied :: [Cell] -> Bool\nisOccupied line = isOccupied' (head line) line\n    where isOccupied' _ [] = True\n          isOccupied' cell (x:xs) =\n              if cell /= x then False else isOccupied' cell xs\n```\n\nHaskell \u306f\u30c8\u30c3\u30d7\u30c0\u30a6\u30f3\u3067\u66f8\u3044\u3066\u3044\u304f\u3068\u304d\u306b\u3001\u578b\u304c\u5f37\u529b\u306a\u30e1\u30e2\u4ee3\u308f\u308a\u306b\u306a\u3063\u3066\u304f\u308c\u308b\u306e\u304c\u9762\u767d\u3044\u611f\u899a\u3060\u3063\u305f\u3002\u307e\u3060\u66f8\u3044\u3066\u306a\u3044\u95a2\u6570\u3067\u3082\u3001\u578b\u3055\u3048\u9069\u5207\u306b\u6c7a\u3081\u3066\u304a\u3051\u3070\u5b89\u5fc3\u3057\u3066\u30ac\u30b7\u30ac\u30b7\u7d44\u307f\u7acb\u3066\u3089\u308c\u308b\u306e\u304c\u5b09\u3057\u3044\u3002\n\n##\u8ffd\u8a18\n\n[t_uchida\u3055\u3093\u306e\u56de\u7b54](http://qiita.com/items/6fc203c947df212cdab7)\u3002\n\n- toEnum\u3068fromEnum\u4fbf\u5229\n- filter \u304b\u3089 insert\u306e\u6d41\u308c\u304c\u3059\u3066\u304d\n- drop \u3068 take \u3068 iterate \u306e\u4f7f\u3044\u65b9\u304c\u5de7\u5999\n- transpose \u306f\u3068\u3082\u304b\u304f\u659c\u3081\u3092\u4f5c\u308b\u306e\u306f zipWith \u304b\u3042\n\n", "tags": ["yhpg", "\u3069\u3046\u66f8\u304f", "Haskell"]}