{"context": "\n\nCSS Writing Modes\nChinese tranlation | www.zcfy.cc\nOriginal Link | 24ways.org\n\nHmmm here I made some excerts.\n\n\nWhy learn about writing modes?\nMost importantly, I\u2019ve found understanding Writing Modes incredibly helpful when understanding Flexbox and CSS Grid. Before I learned Writing Mode, I felt like there was still a big hole in my knowledge, something I just didn\u2019t get about why Grid and Flexbox work the way they do. Once I wrapped my head around Writing Modes, Grid and Flexbox got a lot easier. Suddenly the Alignment properties, align-* and justify-*, made sense.\n\nCSS properties\nI\u2019m going to focus on the CSS writing-mode property in this article. It has five possible options:\ncss\nwriting-mode: horizontal-tb;\nwriting-mode: vertical-rl;\nwriting-mode: vertical-lr;\nwriting-mode: sideways-rl;\nwriting-mode: sideways-lr;\n\n\nSo I see the default mode is hrizontal-tb(top to bottom),within this article it also mentioned an important concept, 'block' and 'inline'.\nThe images below explain well.\n\n\nThe block stack\n\n\nThe inline stack\n\n\nJS state machine\nOriginal Link | segmentfault.com\n\nThis morning I read this page, the poster asked how to write a consecutive, multiple-step and business-complex JS pop? He need 3 pops to complete the flow below\n\n\n\nThe ranked first answer replied by @\u6ce2\u540c\u5b66, He think the key issue is how to record state and track.\nHe recommended 'redux' for complex business, and for simpler application, it's better to write a state machine yourself.\n\nThe code below is the state.js module\n// state.js\n// define a object to record state\nlet states = {}\n\n\n// To get the object content, usually used to check the value we stored\nfunction getStates () {\n    return states\n}\n\n// Get the stored value according to attribute name\nfunction get (name) {\n    if(states[name]) { return states[name] }\n    return ''\n}\n\n\n// same with the 'setState' function of react\nfunction set (options, target) {\n    let keys = Object.keys(options)\n    let o = target ? target : states\n    keys.map( item => {\n        if(typeof o[item] == 'undefined') {\n            o[item] = options[item]\n        } \n        else {\n            if(type(o[item]) == 'object') {\n                set(options[item], o[item])\n            } else {\n                o[item] = options[item]\n            }\n        }\n        return item\n    })\n}\n\n// Determine the data type\nfunction type(elem) {\n    if (elem == null) return elem + '';\n    return toString.call(elem).replace(/[\\[\\]]/g, '').split(' ')[1].toLowerCase();\n}\n\n// Here we used the ES6 module sytax to provide the external interface\nexport { getStates, get, set }\n\nExample fot usage\n```js\nimport * as state from './state.js';\n//record the step 1, we could use this structure\nstate.set({\n    payType: {\n        step: 1,\n        stepName: 'payType',\n        preStep: null,\n        selectType: 0  // custom choice\n    }\n})\n// record the step 2\nstate.set({\n    cardInfo: {\n        step: 2, \n        stepName: 'cardInfo',\n        preStep: 'payType', \n        // Keep same with the name of previous step\n        // This isse also can be archieved with some routing plugins to return the previous step\n        moreInfo: {},\n        ... // more info of credit\n    }\n})\n... ...  // The all remain steps can store info like this\n// This method is also convinience to insert new steps.\n// e.g. If you wanna modify the data of step 2, you could write as below\nstate.set({\n    cardInfo: {\n        preStep: 'otherStep'\n    }\n})\n```\nThis record is just for front level, the state will no longer exists when user refreshes or turn off the page\n# CSS Writing Modes\n\n[Chinese tranlation | www.zcfy.cc](http://www.zcfy.cc/article/css-writing-modes-9670-24-ways-2321.html)\n[Original Link | 24ways.org](https://24ways.org/2016/css-writing-modes/)\n\n> Hmmm here I made some excerts.\n\n### Why learn about writing modes?\nMost importantly, I\u2019ve found understanding Writing Modes incredibly helpful when understanding Flexbox and CSS Grid. Before I learned Writing Mode, I felt like there was still a big hole in my knowledge, something I just didn\u2019t get about why Grid and Flexbox work the way they do. Once I wrapped my head around Writing Modes, Grid and Flexbox got a lot easier. Suddenly the Alignment properties, align-* and justify-*, made sense.\n\n### CSS properties\nI\u2019m going to focus on the CSS writing-mode property in this article. It has five possible options:\n```css\nwriting-mode: horizontal-tb;\nwriting-mode: vertical-rl;\nwriting-mode: vertical-lr;\nwriting-mode: sideways-rl;\nwriting-mode: sideways-lr;\n```\n\n> So I see the default mode is hrizontal-tb(top to bottom),within this article it also mentioned an important concept, 'block' and 'inline'.\nThe images below explain well.\n\n### The block stack\n![image](https://qiita-image-store.s3.amazonaws.com/0/119653/704c015c-d20d-9f75-61e0-10cc0658ece2.png)\n### The inline stack\n![](https://media.24ways.org/2016/jsimmons/inlinedirection.png)\n\n# JS state machine\n[Original Link | segmentfault.com](https://segmentfault.com/q/1010000008256997?utm_source=weekly&utm_medium=email&utm_campaign=email_weekly)\n> This morning I read this page, the poster asked how to write a consecutive, multiple-step and business-complex JS pop? He need 3 pops to complete the flow below\n\n![image](https://qiita-image-store.s3.amazonaws.com/0/119653/9d7fbe2b-624a-bea8-a685-955b910d8d65.png)\n\n> The ranked first answer replied by @\u6ce2\u540c\u5b66, He think the key issue is how to record state and track.\nHe recommended 'redux' for complex business, and for simpler application, it's better to write a state machine yourself.\n\nThe code below is the state.js module\n\n```javascript\n// state.js\n// define a object to record state\nlet states = {}\n\n\n// To get the object content, usually used to check the value we stored\nfunction getStates () {\n    return states\n}\n\n// Get the stored value according to attribute name\nfunction get (name) {\n    if(states[name]) { return states[name] }\n    return ''\n}\n\n\n// same with the 'setState' function of react\nfunction set (options, target) {\n    let keys = Object.keys(options)\n    let o = target ? target : states\n    keys.map( item => {\n        if(typeof o[item] == 'undefined') {\n            o[item] = options[item]\n        } \n        else {\n            if(type(o[item]) == 'object') {\n                set(options[item], o[item])\n            } else {\n                o[item] = options[item]\n            }\n        }\n        return item\n    })\n}\n\n// Determine the data type\nfunction type(elem) {\n    if (elem == null) return elem + '';\n    return toString.call(elem).replace(/[\\[\\]]/g, '').split(' ')[1].toLowerCase();\n}\n\n// Here we used the ES6 module sytax to provide the external interface\nexport { getStates, get, set }\n```\n\nExample fot usage\n```js\nimport * as state from './state.js';\n\n//record the step 1, we could use this structure\nstate.set({\n    payType: {\n        step: 1,\n        stepName: 'payType',\n        preStep: null,\n        selectType: 0  // custom choice\n    }\n})\n\n// record the step 2\nstate.set({\n    cardInfo: {\n        step: 2, \n        stepName: 'cardInfo',\n        preStep: 'payType', \n        // Keep same with the name of previous step\n        // This isse also can be archieved with some routing plugins to return the previous step\n        moreInfo: {},\n        ... // more info of credit\n    }\n})\n\n... ...  // The all remain steps can store info like this\n\n// This method is also convinience to insert new steps.\n// e.g. If you wanna modify the data of step 2, you could write as below\nstate.set({\n    cardInfo: {\n        preStep: 'otherStep'\n    }\n})\n```\nThis record is just for front level, the state will no longer exists when user refreshes or turn off the page\n\n\n\n", "tags": ["CSS", "js"]}