{"context": " More than 1 year has passed since last update.\n\nHTS221\n\nHTS221\u306f\u3001STMicroelectronics\u88fd\u306eI2C\u901a\u4fe1\u306b\u5bfe\u5fdc\u3057\u305f\u6e7f\u5ea6/\u6e29\u5ea6\u30bb\u30f3\u30b5\u30fc\u3067\u3042\u308b\u3002\u3053\u3053\u3067\u306f\u3001Arduino\u5411\u3051\u306eI2C\u901a\u4fe1\u306e\u30b5\u30f3\u30d7\u30eb\u3092\u4f5c\u6210\u3059\u308b\u65b9\u6cd5\u3092\u63b2\u8f09\u3059\u308b\u3002\n\nDocument\n\nDatasheet\n\u30c6\u30af\u30cb\u30ab\u30eb\u30ce\u30fc\u30c8\n\n\nSlave address\n0x5f\n\nRegister address map\n\n\n\nWho_am_I\nWho_am_I\u7528\u306b\u5272\u308a\u632f\u3089\u308c\u305f\u30ec\u30b8\u30b9\u30bf\u30a2\u30c9\u30ec\u30b9\u306f\u30010x0F\u30020xBC\u304c\u8fd4\u3063\u3066\u304f\u308b\u3068\u3001\u30bb\u30f3\u30b5\u30fc\u304c\u8a8d\u8b58\u3055\u308c\u3066\u3044\u308b\u4e8b\u306b\u306a\u308b\u3002\n\n\narduino\n#define HTS221_WHO_AM_I 0x0F\n#define HTS221_DEVICE 0xBC\n\nbool SearchDevice()\n{\n  byte device = 0x00;\n  readI2c(HTS221_WHO_AM_I, 1, &device);\n\n  if(device == HTS221_DEVICE){\n      return true;\n  } else{\n      return false;\n  }\n}\n\n\n\nConfiguration\nConfiguration\u306f\u30010x10\u306eRegister Address\u3092\u4f7f\u7528\u3057\u3066\u3044\u308b\u3002Default\u306f\u30011B\u3002\nConfiguration\u3067\u306f\u3001\u6e7f\u5ea6/\u6e29\u5ea6\u8a08\u6e2c\u6642\u306e\u305d\u308c\u305e\u308c\u306e\u9593\u9694\u3092\u8a2d\u5b9a\u3067\u304d\u308b\u3002\u9593\u9694\u3092\u7d30\u304b\u304f\u3059\u308c\u3070\u3001\u305d\u308c\u3060\u3051\u30ce\u30a4\u30ba\u3092\u6e1b\u3089\u305b\u308b\u304c\u3001\u96fb\u6d41\u91cf\u304c\u5897\u3048\u308b\u3002\n\n\nConfiguration\u3067\u306f\u30010-2bit\u76ee(AVGH0-AVGH1)\u304cHumidity\u306e\u5206\u89e3\u5ea6\u30013-5bit\u76ee(AVGT0-AVGT1)\u304cTemperature\u306e\u5206\u89e3\u5ea6\u306e\u8a2d\u5b9a\u7528\u306b\u4f7f\u308f\u308c\u308b\u3002\n\nDefialt\u306e1B\u306e\u5024\u306f\u3001bit\u306b\u8868\u3059\u3068\u4e0b\u8a18\u8868\u306e\u3088\u3046\u306b\u306a\u308b\u3002\n\nAVGT\u304c011\u3001AVGH\u304c011\u3068\u306a\u308b\u3002Temperature\u306e\u30a4\u30f3\u30bf\u30fc\u30f3\u30d0\u30eb\u306e\u9593\u9694\u304c16, Humidity\u304c32\u306b\u8a2d\u5b9a\u3055\u308c\u3066\u3044\u308b\u3002\n\u4e00\u756a\u3044\u3044\u7cbe\u5ea6\u306b\u8a2d\u5b9a\u3059\u308b\u5834\u5408\u306f\u3001\u4e0b\u8a18\u306e\u3088\u3046\u306b111, 111\u3092\u305d\u308d\u305e\u308c\u8a2d\u5b9a\u3059\u308b\u3002\n\narduino\n#define HTS221_AVGT_256 0b111\n#define HTS221_AVGH_512 0b111\n\nvoid Configuration()\n{\n   int AV_CONF = HTS221_AVGT_256>>3 | HTS221_AVGH_512;\n   writeI2c(HTS221_AV_CONF, AV_CONF);\n}\n\n\n\nPower on\u3068\u4f7f\u7528\u53ef\u80fd\u304b\u3069\u3046\u304b\u306e\u78ba\u8a8d\n\u30bb\u30f3\u30b5\u30fc\u306e\u7a3c\u50cd\u306f\u30010x20\u306eRegister\u30a2\u30c9\u30ec\u30b9\u3067\u8a2d\u5b9a\u3067\u304d\u308b\u30027bit\u76ee\u30921\u3092\u8a2d\u5b9a\u3059\u308b\u3068\u3001\u30bb\u30f3\u30b5\u30fc\u304c\u52d5\u304d\u51fa\u3057\u30010\u306b\u3059\u308b\u3068\u30bb\u30f3\u30b5\u30fc\u304c\u505c\u6b62\u3059\u308b\u3002\u307e\u305f\u3001\u6e7f\u5ea6/\u6e29\u5ea6\u306e\u5468\u671f\u8a2d\u5b9a\u3082\u304a\u3053\u306a\u3046\u3002\n\n\n\nStatus Register\u30a2\u30c9\u30ec\u30b9\u306f0x27\u306b\u306a\u3063\u3066\u3044\u308b\u3002\u3053\u306e\u30a2\u30c9\u30ec\u30b9\u306e\u5024\u3092\u30c1\u30a7\u30c3\u30af\u3059\u308b\u4e8b\u3067\u3001\u305d\u308c\u305e\u308c\u306e\u30bb\u30f3\u30b5\u30fc\u304c\u5229\u7528\u53ef\u80fd\u306b\u306a\u3063\u305f\u304b\u306e\u78ba\u8a8d\u304c\u53ef\u80fd\u306b\u306a\u308b\u3002\n\n\n\n\narduino\n\n#define HTS221_CTRL_REG1 0x20\n#define HTS221_STATUS_REG 0x27\n\n#define HTS221_PD_ON 0b10000000\n#define HTS221_BDU_ON 0b100\n#define HTS221_ODR_ONESHOT 0b00\n#define HTS221_ODR_1KHZ 0b01\n#define HTS221_ODR_7KHZ 0b10\n#define HTS221_ODR_12_5KHZ 0b11\n\nvoid PowerOn()\n{\n  int CTRL_REG1 = HTS221_PD_ON;\n  CTRL_REG1 |= HTS221_ODR_1KHZ;\n  writeI2c(HTS221_CTRL_REG1, CTRL_REG1);\n\n  bool available = false;\n  while(!available){\n    byte tmp;\n    readI2c(HTS221_STATUS_REG, 1, &tmp);\n     if((tmp & 0b1) != 0b1){\n       // not available humidity\n     } else if((tmp & 0b10) != 0b10){\n       // not available temperature\n     } else {\n        available = true;\n     }\n  }\n}\n\n\n\nHeater\u3068OnShot\u306e\u8a2d\u5b9a\n\u57f7\u7b46\u4e2d\n\n\n\n\u6e29\u5ea6\u306e\u8a08\u7b97\u5f0f\n\n\n\u4e0b\u8a18\u304cSTMicroelectronics\u793e\u306e\u30c6\u30af\u30cb\u30ab\u30eb\u30b7\u30fc\u30c8\u306b\u8a18\u8f09\u306e\u30bd\u30fc\u30b9\u30b3\u30fc\u30c9\u306b\u306a\u308b\u3002\n\nSTMicroelectronics\u793e\u306e\u30b5\u30f3\u30d7\u30eb\u30b3\u30fc\u30c9\n/**\n* @brief Read HTS221 temperature output registers, and calculate temperature.\n* @param Pointer to the returned temperature value that must be divided by 10 to get the value in ['C].\n* @retval Error code [HTS221_ OK, HTS221_ ERROR].\n*/\nHTS221_Error_et HTS221_Get_Temperature(int16_ t *value)\n{\n  int16_t T0_out, T1_out, T_out, T0_degC_x8_u16, T1_degC_x8_u16;\n  int16_t T0_degC, T1_degC;\n  uint8_t buffer[4], tmp;\n  uint32_t tmp32;\n\n   /*1. Read from 0x32 & 0x33 registers the value of coefficients T0_degC_x8 and T1_degC_x8*/\n  if(HTS221_ReadReg(HTS221_T0_DEGC_X8, 2, buffer))\n    return HTS221_ERROR;\n\n  /*2. Read from 0x35 register the value of the MSB bits of T1_degC and    T0_degC */\n  if(HTS221_ReadReg(HTS221_T0_T1_DEGC_H2, 1, &tmp))\n   return HTS221_ERROR;\n\n  /*Calculate the T0_deg C and T1_deg C values*/\n  T0_degC_x8_u16 = (((uint16_t)(tmp & 0x03)) << 8) | ((uint16_t)buffer[0]);\n  T1_degC_x8_u16 = (((uint16_t)(tmp & 0x0C)) << 6) | ((uint16_ t)buffer[1]);\n  T0_degC = T0_degC_x8_u16>>3;\n  T1_degC = T1_degC_x8_u16>>3;\n\n  /*3. Read from 0x3C & 0x3D registers the value of T0_OUT*/\n  /*4. Read from 0x3E & 0x3F registers the value of T1_OUT*/\n  if(HTS221_ReadReg(HTS221_T0_OUT_L, 4, buffer))\n    return HTS221_ERROR;\n  T0_out = (((uint16_t)buffer[1])<<8) | (uint16_t)buffer[0];\n  T1_out = (((uint16_t)buffer[3])<<8) | (uint16_t)buffer[2];\n\n  /* 5.Read from 0x2A & 0x2B registers the value T_OUT (ADC _OUT).*/\n  if(HTS221_ReadReg(HTS221_TEMP_OUT_L_REG, 2, buffer))\n   return HTS221_ERROR;\n  T_out = (((uint16_ t)buffer[1])<<8) | (uint16_t)buffer[0];\n\n  /* 6. Compute the Temperature value by linea r interpolation*/\n  tmp32 = ((uint32_t)(T_out - T0_out)) * ((uint32_t)(T1_degC - T0_degC)*10);\n  *value = tmp32 /(T1_out - T0_out) + T0_degC*10;\n\n  return HTS221_OK;\n}\n\n\n\u3053\u308c\u3092\u53c2\u8003\u306bArduino\u306e\u30b3\u30fc\u30c9\u3092\u4f5c\u6210\u3059\u308b\u3002\n\narduino\n// Temperature calibration registers\n#define HTS221_T0_DEGC_X8 0x32\n#define HTS221_T1_DEGC_X8 0x33\n#define HTS221_T0_T1_DEGC_H2 0x35\n#define HTS221_T0_OUT_L 0x3C\n#define HTS221_T0_OUT_H 0x3D\n#define HTS221_T1_OUT_L 0x3E\n#define HTS221_T1_OUT_H 0x3F\n#define HTS221_TEMP_OUT_L 0x2A\n#define HTS221_TEMP_OUT_H 0x2B\n\nint GetTemperature()\n{\n  int16_t T0_out, T1_out, T_out, T0_degC_x8_u16, T1_degC_x8_u16;\n  int16_t T0_degC, T1_degC;\n  uint8_t buffer[4];\n  uint32_t tmp32;\n\n  // T0_degC_x8,T1_degC_x8\u306e\u5024\u306e\u53d6\u5f97\n  readI2c(HTS221_T0_DEGC_X8, 1, &buffer[0]);\n  readI2c(HTS221_T1_DEGC_X8, 1, &buffer[1]);\n  readI2c(HTS221_T0_T1_DEGC_H2, 1, &buffer[2]);\n\n  // T0_degC_x8,T1_degC_x8\u306eH,L\u3092\u7d50\u5408\n  T0_degC_x8_u16 = (((uint16_t)(buffer[2] & 0x03)) << 8) | ((uint16_t)buffer[0]);\n  T1_degC_x8_u16 = (((uint16_t)(buffer[2] & 0x0C)) << 6) | ((uint16_t)buffer[1]);\n\n  // T0_T1_DEGC_H2\u306e\u5024\u306e\u53d6\u5f97\n  T0_degC = T0_degC_x8_u16>>3;\n  T1_degC = T1_degC_x8_u16>>3;\n\n  // T0_OUT_L, T0_OUT_H, T1_OUT_L, T1_OUT_H\u306e\u53d6\u5f97\n  readI2c(HTS221_T0_OUT_L, 1, &buffer[0]);\n  readI2c(HTS221_T0_OUT_H, 1, &buffer[1]);\n  readI2c(HTS221_T1_OUT_L, 1, &buffer[2]);\n  readI2c(HTS221_T1_OUT_H, 1, &buffer[3]);\n\n  // L,H\u306e\u7d50\u5408\n  T0_out = (((uint16_t)buffer[1])<<8) | (uint16_t)buffer[0];\n  T1_out = (((uint16_t)buffer[3])<<8) | (uint16_t)buffer[2];\n\n  // TEMP_OUT_L, TEMP_OUT_H\u306e\u53d6\u5f97\n  readI2c(HTS221_TEMP_OUT_L, 1, &buffer[0]);\n  readI2c(HTS221_TEMP_OUT_H, 1, &buffer[1]);\n\n  // L,H\u306e\u7d50\u5408\n  T_out = (((uint16_t)buffer[1])<<8) | (uint16_t)buffer[0];\n\n  tmp32 = ((uint32_t)(T_out - T0_out)) * ((uint32_t)(T1_degC - T0_degC)*10);\n  return tmp32 /(T1_out - T0_out) + T0_degC*10;\n}\n\n\n\n\u6e7f\u5ea6\u306e\u8a08\u7b97\u5f0f\n\u6e7f\u5ea6\u306e\u8a08\u7b97\u306f\u3001\u4e0b\u8a18\u5f0f\u306b\u3088\u308a\u5c0e\u304d\u51fa\u3055\u308c\u308b\u3002\n\n\u305d\u308c\u305e\u308c\u306e\u5024\u306f\u3001\u4e0b\u8a18\u306eCalibration\u7528\u306e\u30ec\u30b8\u30b9\u30bf\u304b\u3089\u53d6\u5f97\u3067\u304d\u308b\u3002\n\n\u4e0b\u8a18\u304cSTMicroelectronics\u793e\u306e\u30c6\u30af\u30cb\u30ab\u30eb\u30b7\u30fc\u30c8\u8a18\u8f09\u306e\u30b5\u30f3\u30d7\u30eb\u30b3\u30fc\u30c9\u306b\u306a\u308b\u3002\n\nSTMicroelectronics\u793e\u306e\u30b5\u30f3\u30d7\u30eb\u30b3\u30fc\u30c9\n/**\n* @brief Read HTS221 Humidity output registers, and calculate humidity.\n* @param Pointer to the returned humidity value that must be divided by 10 to get the value in [%].\n* @retval Error code [HTS221_ OK, HTS221_ ERROR].\n*/\nHTS221_ Error_et HTS221_ Get_Humidity(uint16_t* value)\n{\n  int16_t H0_T0_ou t, H1_T0_ou t, H_T_ou t;\n  int16_t H0_rh, H1_rh;\n  uint8_t buffer[2];\n  uint32_t tmp;\n\n  /* 1. Read H0_rH and H1_rH coefficients*/\n  if(HTS221_ReadReg(HTS221_H0_RH_X2, 2, buffer))\n  H0_rh = buffer[0]>>1;\n  H1_rh = buffer[1]>>1;\n\n  /*2. Read H0_T0_OUT */\n  if(HTS221_ ReadReg(HTS221_H0_T0_OUT_L, 2, buffer))\n    return HTS221_ ERROR;\n  H0_T0_out = (((uint16_t)buffer[1])<<8) | (uint16_t)buffer[0];\n\n  /*3. Read H1_T0_OUT */\n  if(HTS221_ReadReg(HTS221_H1_T0_OUT_L, 2, buffer))\n    return HTS221_ERROR;\n  H1_T0_out = (((uint16_t)buffer[1])<<8) | (uint16_ t)buffer[0];\n\n  /*4. Read H_T_OUT */\n  if(HTS221_ReadReg(HTS221_HR_OUT_L_REG, 2, buffer))\n    return HTS221_ERROR;\n  H_T_out = (((uint16_t)buffer[1])<<8) | (uint16_t)buffer[0];\n\n  /*5. Compute the RH [%] value by linear interpolation */\n    tmp = ((uint32_t)(H_T_out - H0_T0_out)) * ((uint32_t)(H1_rh - H0_rh)*10);\n   *value = tmp/(H1_T0_out - H0_T0_out) + H0_rh*10;\n\n  /* Saturation condition*/\n  if(*value>1000 ) *value = 1000\n    return HTS221_ OK;\n}\n\n\n\u3053\u308c\u3092\u53c2\u8003\u306bArduino\u306e\u30b3\u30fc\u30c9\u3092\u4f5c\u6210\u3059\u308b\u3002\n\nArduino\n// Humidity calibration registers\n#define HTS221_HR_OUT_L_REG 0x28\n#define HTS221_HR_OUT_H_REG 0x29\n#define HTS221_H0_RH_X2 0x30\n#define HTS221_H1_RH_X2 0x31\n#define HTS221_H0_T0_OUT_L 0x36\n#define HTS221_H0_T0_OUT_H 0x37\n#define HTS221_H1_T0_OUT_L 0x3A\n#define HTS221_H1_T0_OUT_H 0x3B\n\nint GetHumidity()\n{\n  uint16_t H0_T0_out, H1_T0_out, H_T_out;\n  uint16_t H0_rh, H1_rh;\n  uint8_t buffer[2];\n  uint32_t humidity;\n\n  // H0_rH, H1_rH\u306e\u8aad\u307f\u8fbc\u307f\n  readI2c(HTS221_H0_RH_X2, 1, &buffer[0]);\n  readI2c(HTS221_H1_RH_X2, 1, &buffer[1]);\n  // \u53d6\u308c\u3066\u304f\u308b\u5024\u304cX2\u306a\u306e\u3067\u30011/2\u306b\u3059\u308b\n  H0_rh = (buffer[0]&0xff)>>1;\n  H1_rh = (buffer[1]&0xff)>>1;\n\n  // H0_T0_OUT\u306e\u8aad\u307f\u8fbc\u307f\n  readI2c(HTS221_H0_T0_OUT_L, 1, &buffer[0]);\n  readI2c(HTS221_H0_T0_OUT_H, 1, &buffer[1]);\n  // H,L\u3092\u7d50\u5408\u3059\u308b\n  H0_T0_out = (((uint16_t)buffer[1])<<8) | (uint16_t)buffer[0];\n\n  // H1_T0_OUT \u8aad\u307f\u8fbc\u307f\n  readI2c(HTS221_H1_T0_OUT_L, 1, &buffer[0]);\n  readI2c(HTS221_H1_T0_OUT_H, 1, &buffer[1]);  \n  // H, L\u3092\u7d50\u5408\u3059\u308b\n  H1_T0_out = (((uint16_t)buffer[1])<<8) | (uint16_t)buffer[0];\n\n  // Read H_T_OUT\u306e\u8aad\u307f\u8fbc\u307f\n  readI2c(HTS221_HR_OUT_L_REG, 1, &buffer[0]);\n  readI2c(HTS221_HR_OUT_H_REG, 1, &buffer[1]);  \n  // H,L\u3092\u7d50\u5408\u3059\u308b\n  H_T_out = buffer[1]<<8 | buffer[0];\n\n  // RH\u306e\u8a08\u7b97\n  double rh_dx = ((int16_t)H1_rh - (int16_t)H0_rh)*10;\n  humidity = ((int16_t)H_T_out - (int16_t)H0_T0_out)*rh_dx / ((int16_t)H1_T0_out - (int16_t)H0_T0_out);\n  humidity = (int16_t)(humidity + H0_rh*10);\n\n  if(humidity > 1000){\n    humidity = 1000;\n  }\n  return humidity;\n}\n\n\n\nI2C\u306e\u30a2\u30af\u30bb\u30b9\u7528\u30b3\u30fc\u30c9\n\nArduino\n#define HTS221_SLAVE_ADDRESS 0x5F\n\n// I2C\u3078\u306e\u66f8\u304d\u8fbc\u307f\nvoid writeI2c(byte register_addr, byte value) {\n  Wire.beginTransmission(HTS221_SLAVE_ADDRESS);  \n  Wire.write(register_addr);         \n  Wire.write(value);                 \n  Wire.endTransmission();        \n}\n\n// I2C\u3078\u306e\u8aad\u307f\u8fbc\u307f\nvoid readI2c(byte register_addr, int num, byte *buf) {\n  Wire.beginTransmission(HTS221_SLAVE_ADDRESS); \n  Wire.write(register_addr);           \n  Wire.endTransmission(false);         \n\n  //Wire.beginTransmission(DEVICE_ADDR); \n  Wire.requestFrom(HTS221_SLAVE_ADDRESS, num);  \n\n  int i = 0;\n  while (Wire.available())\n  {\n    buf[i] = Wire.read(); \n    i++;   \n  }\n  //Wire.endTransmission();         \n}\n\n\n# HTS221\n\n<img width=\"237\" alt=\"HTS221_pre.png\" src=\"https://qiita-image-store.s3.amazonaws.com/0/63450/7653704f-11fe-7cd2-6989-faab05b670f9.png\">\n\nHTS221\u306f\u3001STMicroelectronics\u88fd\u306eI2C\u901a\u4fe1\u306b\u5bfe\u5fdc\u3057\u305f\u6e7f\u5ea6/\u6e29\u5ea6\u30bb\u30f3\u30b5\u30fc\u3067\u3042\u308b\u3002\u3053\u3053\u3067\u306f\u3001Arduino\u5411\u3051\u306eI2C\u901a\u4fe1\u306e\u30b5\u30f3\u30d7\u30eb\u3092\u4f5c\u6210\u3059\u308b\u65b9\u6cd5\u3092\u63b2\u8f09\u3059\u308b\u3002\n\n# Document\n- [Datasheet](http://www.st.com/web/en/resource/technical/document/datasheet/DM00116291.pdf)\n- [\u30c6\u30af\u30cb\u30ab\u30eb\u30ce\u30fc\u30c8](http://www.st.com/st-web-ui/static/active/en/resource/technical/document/technical_note/DM00208001.pdf)\n\n# Slave address\n\n 0x5f\n\n# Register address map\n\n<img width=\"572\" alt=\"hts221_addressnap.png\" src=\"https://qiita-image-store.s3.amazonaws.com/0/63450/05d1a29e-055f-43f2-8e96-1d8423e1d295.png\">\n\n\n<img width=\"675\" alt=\"hts221_register.png\" src=\"https://qiita-image-store.s3.amazonaws.com/0/63450/e8c3f6a3-84b8-6a13-6f2d-44dd80972dee.png\">\n\n# Who_am_I\n\nWho_am_I\u7528\u306b\u5272\u308a\u632f\u3089\u308c\u305f\u30ec\u30b8\u30b9\u30bf\u30a2\u30c9\u30ec\u30b9\u306f\u30010x0F\u30020xBC\u304c\u8fd4\u3063\u3066\u304f\u308b\u3068\u3001\u30bb\u30f3\u30b5\u30fc\u304c\u8a8d\u8b58\u3055\u308c\u3066\u3044\u308b\u4e8b\u306b\u306a\u308b\u3002\n\n<img width=\"554\" alt=\"who_am_i_resgiter.png\" src=\"https://qiita-image-store.s3.amazonaws.com/0/63450/13e0cb51-75b3-df3d-e1fd-cf3033b15b92.png\">\n\n```cpp:arduino\n#define HTS221_WHO_AM_I 0x0F\n#define HTS221_DEVICE 0xBC\n\nbool SearchDevice()\n{\n  byte device = 0x00;\n  readI2c(HTS221_WHO_AM_I, 1, &device);\n\n  if(device == HTS221_DEVICE){\n      return true;\n  } else{\n      return false;\n  }\n}\n```\n\n# Configuration \n\nConfiguration\u306f\u30010x10\u306eRegister Address\u3092\u4f7f\u7528\u3057\u3066\u3044\u308b\u3002Default\u306f\u30011B\u3002\nConfiguration\u3067\u306f\u3001\u6e7f\u5ea6/\u6e29\u5ea6\u8a08\u6e2c\u6642\u306e\u305d\u308c\u305e\u308c\u306e\u9593\u9694\u3092\u8a2d\u5b9a\u3067\u304d\u308b\u3002\u9593\u9694\u3092\u7d30\u304b\u304f\u3059\u308c\u3070\u3001\u305d\u308c\u3060\u3051\u30ce\u30a4\u30ba\u3092\u6e1b\u3089\u305b\u308b\u304c\u3001\u96fb\u6d41\u91cf\u304c\u5897\u3048\u308b\u3002\n\n<img width=\"550\" alt=\"config_reg.png\" src=\"https://qiita-image-store.s3.amazonaws.com/0/63450/1d8f4f1f-7903-fd88-fc84-10c847f386e6.png\">\n\n<img width=\"570\" alt=\"config_bit.png\" src=\"https://qiita-image-store.s3.amazonaws.com/0/63450/b38d1b98-d471-af6e-2618-878ec9a71af6.png\">\n\nConfiguration\u3067\u306f\u30010-2bit\u76ee(AVGH0-AVGH1)\u304cHumidity\u306e\u5206\u89e3\u5ea6\u30013-5bit\u76ee(AVGT0-AVGT1)\u304cTemperature\u306e\u5206\u89e3\u5ea6\u306e\u8a2d\u5b9a\u7528\u306b\u4f7f\u308f\u308c\u308b\u3002\n\n<img width=\"550\" alt=\"config_table.png\" src=\"https://qiita-image-store.s3.amazonaws.com/0/63450/6822eade-5aa6-5bb0-8180-03c5451afde1.png\">\n\nDefialt\u306e1B\u306e\u5024\u306f\u3001bit\u306b\u8868\u3059\u3068\u4e0b\u8a18\u8868\u306e\u3088\u3046\u306b\u306a\u308b\u3002\n\n<img width=\"608\" alt=\"config_default.png\" src=\"https://qiita-image-store.s3.amazonaws.com/0/63450/6238a028-1c5a-1e65-c951-b317811d77b9.png\">\n\nAVGT\u304c011\u3001AVGH\u304c011\u3068\u306a\u308b\u3002Temperature\u306e\u30a4\u30f3\u30bf\u30fc\u30f3\u30d0\u30eb\u306e\u9593\u9694\u304c16, Humidity\u304c32\u306b\u8a2d\u5b9a\u3055\u308c\u3066\u3044\u308b\u3002\n\n\u4e00\u756a\u3044\u3044\u7cbe\u5ea6\u306b\u8a2d\u5b9a\u3059\u308b\u5834\u5408\u306f\u3001\u4e0b\u8a18\u306e\u3088\u3046\u306b111, 111\u3092\u305d\u308d\u305e\u308c\u8a2d\u5b9a\u3059\u308b\u3002\n\n```cpp:arduino\n#define HTS221_AVGT_256 0b111\n#define HTS221_AVGH_512 0b111\n\nvoid Configuration()\n{\n   int AV_CONF = HTS221_AVGT_256>>3 | HTS221_AVGH_512;\n   writeI2c(HTS221_AV_CONF, AV_CONF);\n}\n```\n# Power on\u3068\u4f7f\u7528\u53ef\u80fd\u304b\u3069\u3046\u304b\u306e\u78ba\u8a8d\n\n\u30bb\u30f3\u30b5\u30fc\u306e\u7a3c\u50cd\u306f\u30010x20\u306eRegister\u30a2\u30c9\u30ec\u30b9\u3067\u8a2d\u5b9a\u3067\u304d\u308b\u30027bit\u76ee\u30921\u3092\u8a2d\u5b9a\u3059\u308b\u3068\u3001\u30bb\u30f3\u30b5\u30fc\u304c\u52d5\u304d\u51fa\u3057\u30010\u306b\u3059\u308b\u3068\u30bb\u30f3\u30b5\u30fc\u304c\u505c\u6b62\u3059\u308b\u3002\u307e\u305f\u3001\u6e7f\u5ea6/\u6e29\u5ea6\u306e\u5468\u671f\u8a2d\u5b9a\u3082\u304a\u3053\u306a\u3046\u3002\n\n<img width=\"554\" alt=\"ctrl_reg1_reg.png\" src=\"https://qiita-image-store.s3.amazonaws.com/0/63450/1c360d4d-27e9-df5e-8a8f-aea2f6172cb4.png\">\n\n<img width=\"558\" alt=\"ctrl_reg1_table.png\" src=\"https://qiita-image-store.s3.amazonaws.com/0/63450/2afbc1d1-f802-ae7d-fba3-15267a972dc0.png\">\n\n<img width=\"583\" alt=\"ctrl_reg1.png\" src=\"https://qiita-image-store.s3.amazonaws.com/0/63450/3f2de35b-097a-d825-4c1f-63777ca67bb0.png\">\n\nStatus Register\u30a2\u30c9\u30ec\u30b9\u306f0x27\u306b\u306a\u3063\u3066\u3044\u308b\u3002\u3053\u306e\u30a2\u30c9\u30ec\u30b9\u306e\u5024\u3092\u30c1\u30a7\u30c3\u30af\u3059\u308b\u4e8b\u3067\u3001\u305d\u308c\u305e\u308c\u306e\u30bb\u30f3\u30b5\u30fc\u304c\u5229\u7528\u53ef\u80fd\u306b\u306a\u3063\u305f\u304b\u306e\u78ba\u8a8d\u304c\u53ef\u80fd\u306b\u306a\u308b\u3002\n\n<img width=\"569\" alt=\"status_reg.png\" src=\"https://qiita-image-store.s3.amazonaws.com/0/63450/67e900a0-94da-515c-808a-394f345caa4a.png\">\n\n<img width=\"567\" alt=\"status_bit.png\" src=\"https://qiita-image-store.s3.amazonaws.com/0/63450/673cf2bf-ecc1-c2e2-0ce0-c9dc02b61f8c.png\">\n\n<img width=\"580\" alt=\"status_table.png\" src=\"https://qiita-image-store.s3.amazonaws.com/0/63450/30b2bc3d-fe84-41e8-5b90-6ec35cea2907.png\">\n\n\n\n```cpp:arduino\n\n#define HTS221_CTRL_REG1 0x20\n#define HTS221_STATUS_REG 0x27\n\n#define HTS221_PD_ON 0b10000000\n#define HTS221_BDU_ON 0b100\n#define HTS221_ODR_ONESHOT 0b00\n#define HTS221_ODR_1KHZ 0b01\n#define HTS221_ODR_7KHZ 0b10\n#define HTS221_ODR_12_5KHZ 0b11\n\nvoid PowerOn()\n{\n  int CTRL_REG1 = HTS221_PD_ON;\n  CTRL_REG1 |= HTS221_ODR_1KHZ;\n  writeI2c(HTS221_CTRL_REG1, CTRL_REG1);\n\n  bool available = false;\n  while(!available){\n    byte tmp;\n    readI2c(HTS221_STATUS_REG, 1, &tmp);\n     if((tmp & 0b1) != 0b1){\n       // not available humidity\n     } else if((tmp & 0b10) != 0b10){\n       // not available temperature\n     } else {\n        available = true;\n     }\n  }\n}\n```\n\n# Heater\u3068OnShot\u306e\u8a2d\u5b9a\n\n\u57f7\u7b46\u4e2d\n\n<img width=\"568\" alt=\"ctrl_reg2_bit.png\" src=\"https://qiita-image-store.s3.amazonaws.com/0/63450/7107f8ac-542d-1a9d-16e3-ca42ba9e54ae.png\">\n\n<img width=\"583\" alt=\"ctrl_reg2_table.png\" src=\"https://qiita-image-store.s3.amazonaws.com/0/63450/1dfe0fa4-77f5-fab7-12ac-a0b24b35ecb3.png\">\n\n# \u6e29\u5ea6\u306e\u8a08\u7b97\u5f0f\n\n<img width=\"436\" alt=\"temp_calc.png\" src=\"https://qiita-image-store.s3.amazonaws.com/0/63450/dcfd41b3-ce14-287c-1a85-cefbaa6551f7.png\">\n\n<img width=\"665\" alt=\"temp_resgister.png\" src=\"https://qiita-image-store.s3.amazonaws.com/0/63450/f1db3284-3efe-d67d-51be-f939b6109756.png\">\n\n\u4e0b\u8a18\u304cSTMicroelectronics\u793e\u306e\u30c6\u30af\u30cb\u30ab\u30eb\u30b7\u30fc\u30c8\u306b\u8a18\u8f09\u306e\u30bd\u30fc\u30b9\u30b3\u30fc\u30c9\u306b\u306a\u308b\u3002\n\n```cpp:STMicroelectronics\u793e\u306e\u30b5\u30f3\u30d7\u30eb\u30b3\u30fc\u30c9\n/**\n* @brief Read HTS221 temperature output registers, and calculate temperature.\n* @param Pointer to the returned temperature value that must be divided by 10 to get the value in ['C].\n* @retval Error code [HTS221_ OK, HTS221_ ERROR].\n*/\nHTS221_Error_et HTS221_Get_Temperature(int16_ t *value)\n{\n  int16_t T0_out, T1_out, T_out, T0_degC_x8_u16, T1_degC_x8_u16;\n  int16_t T0_degC, T1_degC;\n  uint8_t buffer[4], tmp;\n  uint32_t tmp32;\n\n   /*1. Read from 0x32 & 0x33 registers the value of coefficients T0_degC_x8 and T1_degC_x8*/\n  if(HTS221_ReadReg(HTS221_T0_DEGC_X8, 2, buffer))\n    return HTS221_ERROR;\n  \n  /*2. Read from 0x35 register the value of the MSB bits of T1_degC and    T0_degC */\n  if(HTS221_ReadReg(HTS221_T0_T1_DEGC_H2, 1, &tmp))\n   return HTS221_ERROR;\n\n  /*Calculate the T0_deg C and T1_deg C values*/\n  T0_degC_x8_u16 = (((uint16_t)(tmp & 0x03)) << 8) | ((uint16_t)buffer[0]);\n  T1_degC_x8_u16 = (((uint16_t)(tmp & 0x0C)) << 6) | ((uint16_ t)buffer[1]);\n  T0_degC = T0_degC_x8_u16>>3;\n  T1_degC = T1_degC_x8_u16>>3;\n\n  /*3. Read from 0x3C & 0x3D registers the value of T0_OUT*/\n  /*4. Read from 0x3E & 0x3F registers the value of T1_OUT*/\n  if(HTS221_ReadReg(HTS221_T0_OUT_L, 4, buffer))\n    return HTS221_ERROR;\n  T0_out = (((uint16_t)buffer[1])<<8) | (uint16_t)buffer[0];\n  T1_out = (((uint16_t)buffer[3])<<8) | (uint16_t)buffer[2];\n\n  /* 5.Read from 0x2A & 0x2B registers the value T_OUT (ADC _OUT).*/\n  if(HTS221_ReadReg(HTS221_TEMP_OUT_L_REG, 2, buffer))\n   return HTS221_ERROR;\n  T_out = (((uint16_ t)buffer[1])<<8) | (uint16_t)buffer[0];\n\n  /* 6. Compute the Temperature value by linea r interpolation*/\n  tmp32 = ((uint32_t)(T_out - T0_out)) * ((uint32_t)(T1_degC - T0_degC)*10);\n  *value = tmp32 /(T1_out - T0_out) + T0_degC*10;\n  \n  return HTS221_OK;\n}\n```\n\n\u3053\u308c\u3092\u53c2\u8003\u306bArduino\u306e\u30b3\u30fc\u30c9\u3092\u4f5c\u6210\u3059\u308b\u3002\n\n```cpp:arduino\n// Temperature calibration registers\n#define HTS221_T0_DEGC_X8 0x32\n#define HTS221_T1_DEGC_X8 0x33\n#define HTS221_T0_T1_DEGC_H2 0x35\n#define HTS221_T0_OUT_L 0x3C\n#define HTS221_T0_OUT_H 0x3D\n#define HTS221_T1_OUT_L 0x3E\n#define HTS221_T1_OUT_H 0x3F\n#define HTS221_TEMP_OUT_L 0x2A\n#define HTS221_TEMP_OUT_H 0x2B\n\nint GetTemperature()\n{\n  int16_t T0_out, T1_out, T_out, T0_degC_x8_u16, T1_degC_x8_u16;\n  int16_t T0_degC, T1_degC;\n  uint8_t buffer[4];\n  uint32_t tmp32;\n\n  // T0_degC_x8,T1_degC_x8\u306e\u5024\u306e\u53d6\u5f97\n  readI2c(HTS221_T0_DEGC_X8, 1, &buffer[0]);\n  readI2c(HTS221_T1_DEGC_X8, 1, &buffer[1]);\n  readI2c(HTS221_T0_T1_DEGC_H2, 1, &buffer[2]);\n  \n  // T0_degC_x8,T1_degC_x8\u306eH,L\u3092\u7d50\u5408\n  T0_degC_x8_u16 = (((uint16_t)(buffer[2] & 0x03)) << 8) | ((uint16_t)buffer[0]);\n  T1_degC_x8_u16 = (((uint16_t)(buffer[2] & 0x0C)) << 6) | ((uint16_t)buffer[1]);\n\n  // T0_T1_DEGC_H2\u306e\u5024\u306e\u53d6\u5f97\n  T0_degC = T0_degC_x8_u16>>3;\n  T1_degC = T1_degC_x8_u16>>3;\n\n  // T0_OUT_L, T0_OUT_H, T1_OUT_L, T1_OUT_H\u306e\u53d6\u5f97\n  readI2c(HTS221_T0_OUT_L, 1, &buffer[0]);\n  readI2c(HTS221_T0_OUT_H, 1, &buffer[1]);\n  readI2c(HTS221_T1_OUT_L, 1, &buffer[2]);\n  readI2c(HTS221_T1_OUT_H, 1, &buffer[3]);\n\n  // L,H\u306e\u7d50\u5408\n  T0_out = (((uint16_t)buffer[1])<<8) | (uint16_t)buffer[0];\n  T1_out = (((uint16_t)buffer[3])<<8) | (uint16_t)buffer[2];\n\n  // TEMP_OUT_L, TEMP_OUT_H\u306e\u53d6\u5f97\n  readI2c(HTS221_TEMP_OUT_L, 1, &buffer[0]);\n  readI2c(HTS221_TEMP_OUT_H, 1, &buffer[1]);\n\n  // L,H\u306e\u7d50\u5408\n  T_out = (((uint16_t)buffer[1])<<8) | (uint16_t)buffer[0];\n\n  tmp32 = ((uint32_t)(T_out - T0_out)) * ((uint32_t)(T1_degC - T0_degC)*10);\n  return tmp32 /(T1_out - T0_out) + T0_degC*10;\n}\n```\n\n# \u6e7f\u5ea6\u306e\u8a08\u7b97\u5f0f\n\u6e7f\u5ea6\u306e\u8a08\u7b97\u306f\u3001\u4e0b\u8a18\u5f0f\u306b\u3088\u308a\u5c0e\u304d\u51fa\u3055\u308c\u308b\u3002\n\n<img width=\"442\" alt=\"humidity_calc.png\" src=\"https://qiita-image-store.s3.amazonaws.com/0/63450/0bc25234-e97a-1b9a-94ce-64d36fc2efac.png\">\n\n\u305d\u308c\u305e\u308c\u306e\u5024\u306f\u3001\u4e0b\u8a18\u306eCalibration\u7528\u306e\u30ec\u30b8\u30b9\u30bf\u304b\u3089\u53d6\u5f97\u3067\u304d\u308b\u3002\n\n<img width=\"672\" alt=\"humidity_map.png\" src=\"https://qiita-image-store.s3.amazonaws.com/0/63450/42cccd60-abaa-44bd-d863-b8104ebaa42b.png\">\n\n\u4e0b\u8a18\u304cSTMicroelectronics\u793e\u306e\u30c6\u30af\u30cb\u30ab\u30eb\u30b7\u30fc\u30c8\u8a18\u8f09\u306e\u30b5\u30f3\u30d7\u30eb\u30b3\u30fc\u30c9\u306b\u306a\u308b\u3002\n\n```cpp:STMicroelectronics\u793e\u306e\u30b5\u30f3\u30d7\u30eb\u30b3\u30fc\u30c9\n/**\n* @brief Read HTS221 Humidity output registers, and calculate humidity.\n* @param Pointer to the returned humidity value that must be divided by 10 to get the value in [%].\n* @retval Error code [HTS221_ OK, HTS221_ ERROR].\n*/\nHTS221_ Error_et HTS221_ Get_Humidity(uint16_t* value)\n{\n  int16_t H0_T0_ou t, H1_T0_ou t, H_T_ou t;\n  int16_t H0_rh, H1_rh;\n  uint8_t buffer[2];\n  uint32_t tmp;\n\n  /* 1. Read H0_rH and H1_rH coefficients*/\n  if(HTS221_ReadReg(HTS221_H0_RH_X2, 2, buffer))\n  H0_rh = buffer[0]>>1;\n  H1_rh = buffer[1]>>1;\n\n  /*2. Read H0_T0_OUT */\n  if(HTS221_ ReadReg(HTS221_H0_T0_OUT_L, 2, buffer))\n    return HTS221_ ERROR;\n  H0_T0_out = (((uint16_t)buffer[1])<<8) | (uint16_t)buffer[0];\n\n  /*3. Read H1_T0_OUT */\n  if(HTS221_ReadReg(HTS221_H1_T0_OUT_L, 2, buffer))\n    return HTS221_ERROR;\n  H1_T0_out = (((uint16_t)buffer[1])<<8) | (uint16_ t)buffer[0];\n\n  /*4. Read H_T_OUT */\n  if(HTS221_ReadReg(HTS221_HR_OUT_L_REG, 2, buffer))\n    return HTS221_ERROR;\n  H_T_out = (((uint16_t)buffer[1])<<8) | (uint16_t)buffer[0];\n\n  /*5. Compute the RH [%] value by linear interpolation */\n    tmp = ((uint32_t)(H_T_out - H0_T0_out)) * ((uint32_t)(H1_rh - H0_rh)*10);\n   *value = tmp/(H1_T0_out - H0_T0_out) + H0_rh*10;\n\n  /* Saturation condition*/\n  if(*value>1000 ) *value = 1000\n    return HTS221_ OK;\n}\n```\n\n\u3053\u308c\u3092\u53c2\u8003\u306bArduino\u306e\u30b3\u30fc\u30c9\u3092\u4f5c\u6210\u3059\u308b\u3002\n\n```cpp:Arduino\n// Humidity calibration registers\n#define HTS221_HR_OUT_L_REG 0x28\n#define HTS221_HR_OUT_H_REG 0x29\n#define HTS221_H0_RH_X2 0x30\n#define HTS221_H1_RH_X2 0x31\n#define HTS221_H0_T0_OUT_L 0x36\n#define HTS221_H0_T0_OUT_H 0x37\n#define HTS221_H1_T0_OUT_L 0x3A\n#define HTS221_H1_T0_OUT_H 0x3B\n\nint GetHumidity()\n{\n  uint16_t H0_T0_out, H1_T0_out, H_T_out;\n  uint16_t H0_rh, H1_rh;\n  uint8_t buffer[2];\n  uint32_t humidity;\n\n  // H0_rH, H1_rH\u306e\u8aad\u307f\u8fbc\u307f\n  readI2c(HTS221_H0_RH_X2, 1, &buffer[0]);\n  readI2c(HTS221_H1_RH_X2, 1, &buffer[1]);\n  // \u53d6\u308c\u3066\u304f\u308b\u5024\u304cX2\u306a\u306e\u3067\u30011/2\u306b\u3059\u308b\n  H0_rh = (buffer[0]&0xff)>>1;\n  H1_rh = (buffer[1]&0xff)>>1;\n  \n  // H0_T0_OUT\u306e\u8aad\u307f\u8fbc\u307f\n  readI2c(HTS221_H0_T0_OUT_L, 1, &buffer[0]);\n  readI2c(HTS221_H0_T0_OUT_H, 1, &buffer[1]);\n  // H,L\u3092\u7d50\u5408\u3059\u308b\n  H0_T0_out = (((uint16_t)buffer[1])<<8) | (uint16_t)buffer[0];\n  \n  // H1_T0_OUT \u8aad\u307f\u8fbc\u307f\n  readI2c(HTS221_H1_T0_OUT_L, 1, &buffer[0]);\n  readI2c(HTS221_H1_T0_OUT_H, 1, &buffer[1]);  \n  // H, L\u3092\u7d50\u5408\u3059\u308b\n  H1_T0_out = (((uint16_t)buffer[1])<<8) | (uint16_t)buffer[0];\n  \n  // Read H_T_OUT\u306e\u8aad\u307f\u8fbc\u307f\n  readI2c(HTS221_HR_OUT_L_REG, 1, &buffer[0]);\n  readI2c(HTS221_HR_OUT_H_REG, 1, &buffer[1]);  \n  // H,L\u3092\u7d50\u5408\u3059\u308b\n  H_T_out = buffer[1]<<8 | buffer[0];\n\n  // RH\u306e\u8a08\u7b97\n  double rh_dx = ((int16_t)H1_rh - (int16_t)H0_rh)*10;\n  humidity = ((int16_t)H_T_out - (int16_t)H0_T0_out)*rh_dx / ((int16_t)H1_T0_out - (int16_t)H0_T0_out);\n  humidity = (int16_t)(humidity + H0_rh*10);\n  \n  if(humidity > 1000){\n    humidity = 1000;\n  }\n  return humidity;\n}\n```\n\n# I2C\u306e\u30a2\u30af\u30bb\u30b9\u7528\u30b3\u30fc\u30c9\n\n```cpp:Arduino\n#define HTS221_SLAVE_ADDRESS 0x5F\n\n// I2C\u3078\u306e\u66f8\u304d\u8fbc\u307f\nvoid writeI2c(byte register_addr, byte value) {\n  Wire.beginTransmission(HTS221_SLAVE_ADDRESS);  \n  Wire.write(register_addr);         \n  Wire.write(value);                 \n  Wire.endTransmission();        \n}\n\n// I2C\u3078\u306e\u8aad\u307f\u8fbc\u307f\nvoid readI2c(byte register_addr, int num, byte *buf) {\n  Wire.beginTransmission(HTS221_SLAVE_ADDRESS); \n  Wire.write(register_addr);           \n  Wire.endTransmission(false);         \n\n  //Wire.beginTransmission(DEVICE_ADDR); \n  Wire.requestFrom(HTS221_SLAVE_ADDRESS, num);  \n\n  int i = 0;\n  while (Wire.available())\n  {\n    buf[i] = Wire.read(); \n    i++;   \n  }\n  //Wire.endTransmission();         \n}\n```\n", "tags": ["fabo", "hts221", "I2C", "IoT"]}