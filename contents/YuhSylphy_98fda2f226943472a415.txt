{"tags": ["Java", "java8"], "context": "\u51e6\u7406\u306e\u5b9f\u884c\u9806\u5e8f\u3092\u5236\u5fa1\u3059\u308b\u305f\u3081\u306e\u4f9d\u5b58\u95a2\u4fc2\u3092\u66f8\u304d\u305f\u304b\u3063\u305f\u304c\u3001\u624b\u8efd\u306a\u3082\u306e\u304c\u3071\u3063\u3068\u898b\u3064\u304b\u3089\u306a\u304b\u3063\u305f\u306e\u3067\u7d99\u7d9a\u306e\u7df4\u7fd2\u304c\u3066\u3089\u66f8\u3044\u3066\u307f\u305f\u3002\n\u30d1\u30d5\u30a9\u30fc\u30de\u30f3\u30b9\u306f\u77e5\u3089\u306a\u3044\u3002\n\u30c8\u30dd\u30ed\u30b8\u30ab\u30eb\u30bd\u30fc\u30c8\u306e\u6982\u8981\u306f\u3053\u3061\u3089(Wikipedia)\u3002\n\u30b0\u30e9\u30d5\u306fJung\u306e\u3082\u306e\u3002\n\u6709\u5411edge\u306ehead\u306b\u3042\u308bvertex\u3088\u308a\u3082tail\u306b\u3042\u308bvertex\u304c\u5148\u306b\u51fa\u73fe\u3059\u308b\u3053\u3068\u304c\u4fdd\u8a3c\u3055\u308c\u308b\u3002\n\u6df1\u3055\u512a\u5148\u63a2\u7d22\u306e\u9589\u8def\u691c\u51fa\u7248\u3092CPS\u3063\u307d\u304fIterator\u3068\u3057\u3066\u5b9f\u88c5\u3002\n\u9589\u8def\u304c\u3042\u308b\u5834\u5408\u3001\u305d\u308c\u3092\u691c\u51fa\u3057\u305f\u6642\u70b9\u3067IllegalStateException\u3002\n\u672a\u63a2\u7d22\u30ce\u30fc\u30c9\u304b\u3089\u81ea\u5206\u306b\u5411\u3044\u3066\u3044\u308b\u30a8\u30c3\u30b8\u304c\u7121\u3044\u30ce\u30fc\u30c9\u3092\u898b\u3064\u3051\u305f\u3089\u3001\u305d\u306e\u30ce\u30fc\u30c9\u3068\u6b8b\u308a\u306e\u63a2\u7d22\u624b\u7d9a\u304d\u3092\u4fdd\u5b58\u3057\u3066\u3044\u308b\u3002\n// usage\nfinal Graph<V, E> graph = getDirectedGraph(); // \u4f55\u3089\u304b\u306e\u6709\u5411\u30b0\u30e9\u30d5\nTopologicalSort.stream(graph) // Stream<V>\n    .forEach(...); // \u3042\u3068\u306f\u304a\u597d\u304d\u306b\n\n\n\u30b3\u30fc\u30c9\nimport java.util.Collection;\nimport java.util.Iterator;\nimport java.util.Map;\nimport java.util.NoSuchElementException;\nimport java.util.Optional;\nimport java.util.Spliterator;\nimport java.util.Spliterators;\nimport java.util.function.Supplier;\nimport java.util.stream.Collectors;\nimport java.util.stream.Stream;\nimport java.util.stream.StreamSupport;\n\nimport org.apache.commons.lang3.tuple.Pair;\n\nimport edu.uci.ics.jung.graph.Graph;\n\n/**\n * \u6709\u5411\u30b0\u30e9\u30d5\u306e\u30c8\u30dd\u30ed\u30b8\u30ab\u30eb\u30bd\u30fc\u30c8\n */\npublic class TopologicalSort {\n    private TopologicalSort(){}\n    /**\n     * Iterator\u5b9f\u88c5\n     * @param <T> Stream\u306e\u30ce\u30fc\u30c9\u578b\n     */\n    public static class TopologicalSortedIterator<T> implements Iterator<T> {\n        private final Graph<T, ?> graph;\n\n        private final Map<T, State> state;\n        private enum State {\n            NONE, TEMP, PERP\n        }\n\n        private Supplier<Pair<Optional<T>, Supplier<?>>> cont;\n\n        /**\n         * @param graph \u5bfe\u8c61\u306e\u6709\u5411\u30b0\u30e9\u30d5: \u9589\u8def\u304c\u3042\u308b\u3068\u8d70\u67fb\u4e2d\u306bIllegalStateException\n         */\n        public TopologicalSortedIterator(final Graph<T, ?> graph) {\n            this.graph = graph;\n            this.state = graph.getVertices().stream()\n                .collect(Collectors.toMap(v -> v, v -> State.NONE));\n\n            // \u5168node\u3092\u64cd\u4f5c\u3059\u308b\u7d99\u7d9a\u3092\u521d\u671f\u8a2d\u5b9a\n            final Collection<T> vertices = graph.getVertices();\n            final Iterator<T> it = vertices.iterator();\n\n            this.cont = () -> iterateVertices(it);\n\n            // \u6700\u521d\u306e\u8981\u7d20\u3092\u6e96\u5099\u3001\u3082\u3057\u304f\u306f\u7a7a\u306a\u3089\u7d42\u7aef\u3078\n            prepareNext();\n        }\n\n        final Pair<Optional<T>, Supplier<?>> iterateVertices(final Iterator<T> it) {\n            if(!it.hasNext()) {\n                return Pair.of(Optional.empty(), () -> { throw new NoSuchElementException(); });\n            } else {\n                final T next = it.next();\n                return visit(next, () -> iterateVertices(it));\n            }\n        };\n\n        private Pair<Optional<T>, Supplier<?>> visit(final T node, Supplier<Pair<Optional<T>, Supplier<?>>> cont) {\n            switch(state.get(node)) {\n            case TEMP:\n                // \u4e00\u5ea6\u8a2a\u308c\u305f\u7b87\u6240\u304c\u78ba\u5b9a\u3059\u308b\u524d\u306b\u518d\u8a2a\n                throw new IllegalStateException(\"\u9589\u8def\u691c\u51fa\");\n            case PERP:\n                // \u65e2\u8a2a\u306a\u306e\u3067\u3053\u306e\u30ce\u30fc\u30c9\u306f\u7121\u8996\u3057\u3066\u7d99\u7d9a\u3059\u308b\n                return cont.get();\n            case NONE:\n                // \u672a\u8a2a\u30ce\u30fc\u30c9\n                state.put(node, State.TEMP);\n\n                final Collection<T> inVertices = getInVertices(graph, node);\n                final Iterator<T> it = inVertices.iterator();\n                return visitRest(node, it, cont);\n            default: throw new IllegalStateException();\n            }\n        }\n\n        private static <V, E> Collection<V> getInVertices(Graph<V, E> graph, V node) {\n            return graph.getInEdges(node).stream()\n                .filter(graph::containsEdge)\n                .map(graph::getSource)\n                .collect(Collectors.toList());\n        }\n\n        private Pair<Optional<T>, Supplier<?>> visitRest(final T node, final Iterator<? extends T> it, Supplier<Pair<Optional<T>, Supplier<?>>> cont) {\n            if(!it.hasNext()) { // \u5b50\u304c\u7121\u3044\n                // \u8a2a\u308c\u308b\u5148\u304c\u7121\u3044\u306e\u3067return\u304c\u81ea\u5206\n                state.put(node, State.PERP);\n                return Pair.of(Optional.of(node), cont);\n            } else { // inEdge\u304c\u5b58\u5728\n                // head\u3092\u8a2a\u308c\u308b\n                final T head = it.next();\n                // cont: tail\u306b\u5bfe\u3057\u3066head\u3092\u8a2a\u308c\u308b->cont\n                return visit(head, () -> visitRest(node, it, cont));\n            }\n        }\n\n        /** \u6b21\u306e\u5024\u304c\u5b58\u5728\u3059\u308b\u5834\u5408present */\n        private Optional<T> next = Optional.empty();\n\n        /**\n         * \u6b21\u306e\u5024\u3068\u7d99\u7d9a\u3092\u53d6\u5f97\u3057\u305d\u308c\u305e\u308c\u4fdd\u6301\u3059\u308b\n         */\n        @SuppressWarnings(\"unchecked\")\n        private void prepareNext() {\n            final Pair<Optional<T>, Supplier<?>> p = cont.get();\n\n            this.next = p.getLeft();\n            this.cont = (Supplier<Pair<Optional<T>, Supplier<?>>>) p.getRight();\n        }\n\n        /*\n         * (\u975e Javadoc)\n         * @see java.util.Iterator#hasNext()\n         */\n        @Override\n        public boolean hasNext() {\n            return next.isPresent();\n        }\n\n        /*\n         * (\u975e Javadoc)\n         * @see java.util.Iterator#next()\n         */\n        @Override\n        public T next() {\n            try {\n                return next.orElseThrow(() -> new NoSuchElementException());\n            } finally {\n                next.ifPresent(x -> prepareNext());\n            }\n        }\n    }\n\n    /**\n     * \u5bfe\u8c61\u306e\u30b0\u30e9\u30d5\u3092\u30c8\u30dd\u30ed\u30b8\u30ab\u30eb\u30bd\u30fc\u30c8\u3057\u305f\u7d50\u679c\u3092\u30ce\u30fc\u30c9\u306eStream\u3068\u3057\u3066\u8fd4\u3059\n     * @param graph\n     * @return Stream\n     */\n    public static <V, E> Stream<V> stream(final Graph<V, E> graph) {\n        return StreamSupport.stream(\n            Spliterators.spliterator(\n                new TopologicalSortedIterator<V>(graph),\n                graph.getVertexCount(),\n                Spliterator.NONNULL),\n            false);\n    }\n}\n\n\n\u51e6\u7406\u306e\u5b9f\u884c\u9806\u5e8f\u3092\u5236\u5fa1\u3059\u308b\u305f\u3081\u306e\u4f9d\u5b58\u95a2\u4fc2\u3092\u66f8\u304d\u305f\u304b\u3063\u305f\u304c\u3001\u624b\u8efd\u306a\u3082\u306e\u304c\u3071\u3063\u3068\u898b\u3064\u304b\u3089\u306a\u304b\u3063\u305f\u306e\u3067\u7d99\u7d9a\u306e\u7df4\u7fd2\u304c\u3066\u3089\u66f8\u3044\u3066\u307f\u305f\u3002\n\u30d1\u30d5\u30a9\u30fc\u30de\u30f3\u30b9\u306f\u77e5\u3089\u306a\u3044\u3002\n\n\u30c8\u30dd\u30ed\u30b8\u30ab\u30eb\u30bd\u30fc\u30c8\u306e\u6982\u8981\u306f[\u3053\u3061\u3089(Wikipedia)](https://ja.wikipedia.org/wiki/%E3%83%88%E3%83%9D%E3%83%AD%E3%82%B8%E3%82%AB%E3%83%AB%E3%82%BD%E3%83%BC%E3%83%88#.E6.B7.B1.E3.81.95.E5.84.AA.E5.85.88.E6.8E.A2.E7.B4.A2.E7.89.88)\u3002\n\u30b0\u30e9\u30d5\u306f[Jung](http://jung.sourceforge.net/)\u306e\u3082\u306e\u3002\n\u6709\u5411edge\u306ehead\u306b\u3042\u308bvertex\u3088\u308a\u3082tail\u306b\u3042\u308bvertex\u304c\u5148\u306b\u51fa\u73fe\u3059\u308b\u3053\u3068\u304c\u4fdd\u8a3c\u3055\u308c\u308b\u3002\n\u6df1\u3055\u512a\u5148\u63a2\u7d22\u306e\u9589\u8def\u691c\u51fa\u7248\u3092CPS\u3063\u307d\u304fIterator\u3068\u3057\u3066\u5b9f\u88c5\u3002\n\u9589\u8def\u304c\u3042\u308b\u5834\u5408\u3001\u305d\u308c\u3092\u691c\u51fa\u3057\u305f\u6642\u70b9\u3067IllegalStateException\u3002\n\u672a\u63a2\u7d22\u30ce\u30fc\u30c9\u304b\u3089\u81ea\u5206\u306b\u5411\u3044\u3066\u3044\u308b\u30a8\u30c3\u30b8\u304c\u7121\u3044\u30ce\u30fc\u30c9\u3092\u898b\u3064\u3051\u305f\u3089\u3001\u305d\u306e\u30ce\u30fc\u30c9\u3068\u6b8b\u308a\u306e\u63a2\u7d22\u624b\u7d9a\u304d\u3092\u4fdd\u5b58\u3057\u3066\u3044\u308b\u3002\n\n\n```java\n// usage\nfinal Graph<V, E> graph = getDirectedGraph(); // \u4f55\u3089\u304b\u306e\u6709\u5411\u30b0\u30e9\u30d5\nTopologicalSort.stream(graph) // Stream<V>\n    .forEach(...); // \u3042\u3068\u306f\u304a\u597d\u304d\u306b\n```\n### \u30b3\u30fc\u30c9\n```java\nimport java.util.Collection;\nimport java.util.Iterator;\nimport java.util.Map;\nimport java.util.NoSuchElementException;\nimport java.util.Optional;\nimport java.util.Spliterator;\nimport java.util.Spliterators;\nimport java.util.function.Supplier;\nimport java.util.stream.Collectors;\nimport java.util.stream.Stream;\nimport java.util.stream.StreamSupport;\n\nimport org.apache.commons.lang3.tuple.Pair;\n\nimport edu.uci.ics.jung.graph.Graph;\n\n/**\n * \u6709\u5411\u30b0\u30e9\u30d5\u306e\u30c8\u30dd\u30ed\u30b8\u30ab\u30eb\u30bd\u30fc\u30c8\n */\npublic class TopologicalSort {\n\tprivate TopologicalSort(){}\n\t/**\n     * Iterator\u5b9f\u88c5\n\t * @param <T> Stream\u306e\u30ce\u30fc\u30c9\u578b\n\t */\n\tpublic static class TopologicalSortedIterator<T> implements Iterator<T> {\n\t\tprivate final Graph<T, ?> graph;\n\n\t\tprivate final Map<T, State> state;\n\t\tprivate enum State {\n\t\t\tNONE, TEMP, PERP\n\t\t}\n\n\t\tprivate Supplier<Pair<Optional<T>, Supplier<?>>> cont;\n\n\t\t/**\n\t\t * @param graph \u5bfe\u8c61\u306e\u6709\u5411\u30b0\u30e9\u30d5: \u9589\u8def\u304c\u3042\u308b\u3068\u8d70\u67fb\u4e2d\u306bIllegalStateException\n\t\t */\n\t\tpublic TopologicalSortedIterator(final Graph<T, ?> graph) {\n\t\t\tthis.graph = graph;\n\t\t\tthis.state = graph.getVertices().stream()\n\t\t\t\t.collect(Collectors.toMap(v -> v, v -> State.NONE));\n\n\t\t\t// \u5168node\u3092\u64cd\u4f5c\u3059\u308b\u7d99\u7d9a\u3092\u521d\u671f\u8a2d\u5b9a\n\t\t\tfinal Collection<T> vertices = graph.getVertices();\n\t\t\tfinal Iterator<T> it = vertices.iterator();\n\n\t\t\tthis.cont = () -> iterateVertices(it);\n\n\t\t\t// \u6700\u521d\u306e\u8981\u7d20\u3092\u6e96\u5099\u3001\u3082\u3057\u304f\u306f\u7a7a\u306a\u3089\u7d42\u7aef\u3078\n\t\t\tprepareNext();\n\t\t}\n\n\t\tfinal Pair<Optional<T>, Supplier<?>> iterateVertices(final Iterator<T> it) {\n\t\t\tif(!it.hasNext()) {\n\t\t\t\treturn Pair.of(Optional.empty(), () -> { throw new NoSuchElementException(); });\n\t\t\t} else {\n\t\t\t\tfinal T next = it.next();\n\t\t\t\treturn visit(next, () -> iterateVertices(it));\n\t\t\t}\n\t\t};\n\n\t\tprivate Pair<Optional<T>, Supplier<?>> visit(final T node, Supplier<Pair<Optional<T>, Supplier<?>>> cont) {\n\t\t\tswitch(state.get(node)) {\n\t\t\tcase TEMP:\n\t\t\t\t// \u4e00\u5ea6\u8a2a\u308c\u305f\u7b87\u6240\u304c\u78ba\u5b9a\u3059\u308b\u524d\u306b\u518d\u8a2a\n\t\t\t\tthrow new IllegalStateException(\"\u9589\u8def\u691c\u51fa\");\n\t\t\tcase PERP:\n\t\t\t\t// \u65e2\u8a2a\u306a\u306e\u3067\u3053\u306e\u30ce\u30fc\u30c9\u306f\u7121\u8996\u3057\u3066\u7d99\u7d9a\u3059\u308b\n\t\t\t\treturn cont.get();\n\t\t\tcase NONE:\n\t\t\t\t// \u672a\u8a2a\u30ce\u30fc\u30c9\n\t\t\t\tstate.put(node, State.TEMP);\n\n\t\t\t\tfinal Collection<T> inVertices = getInVertices(graph, node);\n\t\t\t\tfinal Iterator<T> it = inVertices.iterator();\n\t\t\t\treturn visitRest(node, it, cont);\n\t\t\tdefault: throw new IllegalStateException();\n\t\t\t}\n\t\t}\n\n\t\tprivate static <V, E> Collection<V> getInVertices(Graph<V, E> graph, V node) {\n\t\t\treturn graph.getInEdges(node).stream()\n\t\t\t\t.filter(graph::containsEdge)\n\t\t\t\t.map(graph::getSource)\n\t\t\t\t.collect(Collectors.toList());\n\t\t}\n\n\t\tprivate Pair<Optional<T>, Supplier<?>> visitRest(final T node, final Iterator<? extends T> it, Supplier<Pair<Optional<T>, Supplier<?>>> cont) {\n\t\t\tif(!it.hasNext()) { // \u5b50\u304c\u7121\u3044\n\t\t\t\t// \u8a2a\u308c\u308b\u5148\u304c\u7121\u3044\u306e\u3067return\u304c\u81ea\u5206\n\t\t\t\tstate.put(node, State.PERP);\n\t\t\t\treturn Pair.of(Optional.of(node), cont);\n\t\t\t} else { // inEdge\u304c\u5b58\u5728\n\t\t\t\t// head\u3092\u8a2a\u308c\u308b\n\t\t\t\tfinal T head = it.next();\n\t\t\t\t// cont: tail\u306b\u5bfe\u3057\u3066head\u3092\u8a2a\u308c\u308b->cont\n\t\t\t\treturn visit(head, () -> visitRest(node, it, cont));\n\t\t\t}\n\t\t}\n\n\t\t/** \u6b21\u306e\u5024\u304c\u5b58\u5728\u3059\u308b\u5834\u5408present */\n\t\tprivate Optional<T> next = Optional.empty();\n\n\t\t/**\n\t\t * \u6b21\u306e\u5024\u3068\u7d99\u7d9a\u3092\u53d6\u5f97\u3057\u305d\u308c\u305e\u308c\u4fdd\u6301\u3059\u308b\n\t\t */\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tprivate void prepareNext() {\n\t\t\tfinal Pair<Optional<T>, Supplier<?>> p = cont.get();\n\n\t\t\tthis.next = p.getLeft();\n\t\t\tthis.cont = (Supplier<Pair<Optional<T>, Supplier<?>>>) p.getRight();\n\t\t}\n\n\t\t/*\n\t\t * (\u975e Javadoc)\n\t\t * @see java.util.Iterator#hasNext()\n\t\t */\n\t\t@Override\n\t\tpublic boolean hasNext() {\n\t\t\treturn next.isPresent();\n\t\t}\n\n\t\t/*\n\t\t * (\u975e Javadoc)\n\t\t * @see java.util.Iterator#next()\n\t\t */\n\t\t@Override\n\t\tpublic T next() {\n\t\t\ttry {\n\t\t\t\treturn next.orElseThrow(() -> new NoSuchElementException());\n\t\t\t} finally {\n\t\t\t\tnext.ifPresent(x -> prepareNext());\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * \u5bfe\u8c61\u306e\u30b0\u30e9\u30d5\u3092\u30c8\u30dd\u30ed\u30b8\u30ab\u30eb\u30bd\u30fc\u30c8\u3057\u305f\u7d50\u679c\u3092\u30ce\u30fc\u30c9\u306eStream\u3068\u3057\u3066\u8fd4\u3059\n\t * @param graph\n\t * @return Stream\n\t */\n\tpublic static <V, E> Stream<V> stream(final Graph<V, E> graph) {\n\t\treturn StreamSupport.stream(\n\t\t\tSpliterators.spliterator(\n\t\t\t\tnew TopologicalSortedIterator<V>(graph),\n\t\t\t\tgraph.getVertexCount(),\n\t\t\t\tSpliterator.NONNULL),\n\t\t\tfalse);\n\t}\n}\n```\n"}