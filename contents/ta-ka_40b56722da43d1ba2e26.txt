{"context": "\n\n\u306f\u3058\u3081\u306b\n\u3075\u3068\u601d\u3044\u7acb\u3063\u305f\u306e\u3067\u30bf\u30fc\u30df\u30ca\u30eb\u3067\u30d7\u30ec\u30a4\u3059\u308b\u30de\u30a4\u30f3\u30b9\u30a4\u30fc\u30d1\u3064\u304f\u3063\u3066\u307f\u307e\u3057\u305f\uff0e\n\n\u30de\u30a4\u30f3\u30b9\u30a4\u30fc\u30d1\u3068\u306f\uff1f\n\n\u30de\u30a4\u30f3\u30b9\u30a4\u30fc\u30d1\uff08Minesweeper\uff09\u306f1980\u5e74\u4ee3\u306b\u767a\u660e\u3055\u308c\u305f\uff0c\u4e00\u4eba\u7528\u306e\u30b3\u30f3\u30d4\u30e5\u30fc\u30bf\u30b2\u30fc\u30e0\u3067\u3042\u308b\uff0e\u30b2\u30fc\u30e0\u306e\u76ee\u7684\u306f\u5730\u96f7\u539f\u304b\u3089\u5730\u96f7\u3092\u53d6\u308a\u9664\u304f\u3053\u3068\u3067\u3042\u308b\uff0e\n\u3053\u306e\u30b2\u30fc\u30e0\u306f\u591a\u6570\u306e\u30b3\u30f3\u30d4\u30e5\u30fc\u30bf\u30d7\u30e9\u30c3\u30c8\u30d5\u30a9\u30fc\u30e0\u5411\u3051\u306b\u66f8\u304d\u76f4\u3055\u308c\u3066\u304a\u308a\uff0cMicrosoft Windows\u3092\u306f\u3058\u3081\uff0cLinux\u306eGNOME\u3084KDE\u306a\u3069\u306e\u30b7\u30b9\u30c6\u30e0\u306b\u540c\u68b1\u3055\u308c\u3066\u3044\u308b\u3082\u306e\u3082\u3042\u308b\uff0e\nwikipedia\u3088\u308a\u5f15\u7528\uff1ahttps://ja.wikipedia.org/wiki/\u30de\u30a4\u30f3\u30b9\u30a4\u30fc\u30d1\n\n\n\u30b3\u30fc\u30c9\n\u4ee5\u4e0b\u306e\u3088\u3046\u306b\u5b9f\u88c5\u3057\u307e\u3057\u305f\uff0e\n\nminesweeper.hpp\n#include <stdio.h>\n#include <stdlib.h>\n#include <time.h>\n\nclass Mine {\npublic:\n    Mine(int h, int w, int b);\n    ~Mine();\n    void start();\n    void print_matrix();\n    void print_correct();\n    void get_point(char msg[], int *pt, int threshold);\n    bool open(int y, int x);\n    bool is_clear();\n\nprivate:\n    int **matrix;\n    bool **map;\n    int height;\n    int width;\n    int bombs;\n    int size;\n    void create_check_array(bool *check);\n    void create_matrix_and_map(bool *check);\n    bool is_number(char str[]);\n};\n\n\n\nminesweeper.cpp\n#include \"minesweeper.hpp\"\n\nMine::Mine(int h, int w, int b) {\n    height = h;\n    width = w;\n    bombs = b;\n    size = height * width;\n    matrix = (int **)malloc(sizeof(int *) * height);\n    map = (bool **)malloc(sizeof(bool *) * height);\n\n    srand((unsigned int)time(NULL)); \n    bool *check = (bool *)malloc(sizeof(bool) * size);\n    create_check_array(check);\n    create_matrix_and_map(check);\n\n    free(check);\n}\n\nMine::~Mine() {\n    free(matrix);\n    free(map);\n}\n\nvoid Mine::start() {\n    printf(\"\\n\\x1b[37m  !!!size:%dx%d, bombs:%d start!!!\\n\\x1b[39m\", height, width, bombs);\n}\n\nvoid Mine::print_matrix() {\n    printf(\"     \");\n    for(int x = 0; x < width; x++) {\n        printf(\"%3d\", x);\n    }\n    printf(\"\\n\");\n    printf(\"     \");\n    for(int x = 0; x < width; x++) {\n        printf(\"---\");\n    }\n    printf(\"\\n\");\n    for(int y = 0; y < height; y++) {\n        printf(\"%3d |\", y);\n        for(int x = 0; x < width; x++) {\n            if(map[y][x] == false) {\n                printf(\"  ?\");\n            }\n            else {\n                int val = matrix[y][x];\n                if(val > 0) {\n                    printf(\"\\x1b[37m%3d\\x1b[39m\", val);\n                }\n                else if(val == 0) {\n                    printf(\"  -\");\n                }\n                else if(val == -1) {\n                    printf(\"\\x1b[31m  *\\x1b[39m\");\n                }\n            }\n        }\n        printf(\"\\n\");\n    }\n}\n\nvoid Mine::print_correct() {\n    for(int y = 0; y < height; y++) {\n        for(int x = 0; x < width; x++) {\n            map[y][x] = true;\n        }\n    }\n    print_matrix();\n}\n\nvoid Mine::get_point(char msg[], int *pt, int threshold) {\n    while(1) {\n        char str[8] = {};\n        printf(\"%s(0 ~ %d)  \", msg, threshold - 1);\n        scanf(\"%s\", str);\n        if(is_number(str) && sscanf(str, \"%d\", pt) == 1) {\n            if(*pt >= 0 && *pt < threshold) {\n                break;\n            }\n        }\n    }\n}\n\nbool Mine::open(int y, int x) {\n    int val = matrix[y][x];\n    if(val == -1) {\n        return false;\n    }\n    else if(val == 0) {\n        for(int j = -1; j <= 1; j++) {\n            for(int i = -1; i <= 1; i++) {\n                int _y = y + j, _x = x + i;\n                if(_y < 0 || _x < 0 || _y >= height || _x >= width) {\n                    continue;\n                }\n                else if(!map[_y][_x]) {\n                    map[_y][_x] = true;\n                    open(_y, _x);\n                }\n            }\n        }\n        return true;\n    }\n    else {\n        map[y][x] = true;\n        return true;\n    }\n}\n\nbool Mine::is_clear() {\n    int count = 0;\n    for(int y = 0; y < height; y++) {\n        for(int x = 0; x < width; x++) {\n            if(!map[y][x]) {\n                count++;\n            }\n        }\n    }\n\n    if(count == bombs) {\n        return true;\n    }\n    else {\n        return false;\n    }\n}\n\nvoid Mine::create_check_array(bool *check) {\n    int _bombs = 2 * bombs < size ? bombs : size - bombs;\n    int *random = (int *)malloc(sizeof(int) * _bombs);\n    for(int _b = 0; _b < _bombs; _b++) {\n        while(1) {\n            int val = rand() % size;\n            if(!check[val]) {\n                check[val] = true;\n                random[_b] = val;\n                break;\n            }           \n        }\n    }\n    if(_bombs != bombs) {\n        for(int i = 0; i < size; i++) {\n            check[i] = !check[i];\n        }\n    }\n    free(random);\n}\n\nvoid Mine::create_matrix_and_map(bool *check) {\n    for(int y = 0; y < height; y++) {\n        matrix[y] = (int *)malloc(sizeof(int) * width);\n        map[y] = (bool *)malloc(sizeof(bool) * width);\n        for(int x = 0; x < width; x++) {\n            int index = y * width + x;\n            if(check[index]) {\n                matrix[y][x] = -1;\n            }\n            map[y][x] = false;\n        }\n    }\n    for(int y = 0; y < height; y++) {\n        for(int x = 0; x < width; x++) {\n            int val = matrix[y][x];\n            if(val != -1) {\n                int count = 0;\n                for(int j = -1; j <= 1; j++) {\n                    for(int i = -1; i <= 1; i++) {\n                        int _y = y + j, _x = x + i;\n                        if(_y < 0 || _x < 0 || _y >= height || _x >= width) {\n                            continue;\n                        }\n                        else if(matrix[_y][_x] == -1) {\n                            count++;\n                        }\n                    }\n                }\n                matrix[y][x] = count;\n            }\n        }\n    }\n}\n\nbool Mine::is_number(char str[]) {\n    for(int i = 0; str[i]; i++) {\n        if(str[i] < '0' || str[i] > '9') {\n            return false;\n        }\n    }\n\n    return true;\n}\n\n\n\nmain.cpp\n#include \"minesweeper.hpp\"\n\nint main(int argc, char* argv[]) {\n\n    int height = argc == 4 ? atoi(argv[1]) : 10;\n    int width = argc == 4 ? atoi(argv[2]) : 10;\n    int bombs = argc == 4 ? atoi(argv[3]) : 10;\n    if(bombs > height * width) {\n        printf(\"!!!too many bombs!!!\\n\");\n        return 0;\n    }\n\n    Mine mine(height, width, bombs);\n    mine.start();\n    int pt_y = 0, pt_x = 0;\n    while(1) {\n        printf(\"\\n\");\n        mine.print_matrix();\n        mine.get_point((char *)\"  input point y: \", &pt_y, height);\n        mine.get_point((char *)\"  input point x: \", &pt_x, width);\n        if(!mine.open(pt_y, pt_x)) {\n            printf(\"\\x1b[31m\\n  !!!failed!!!\\n\\x1b[39m\");\n            mine.print_correct();\n            break;\n        }\n        if(mine.is_clear()) {\n            printf(\"\\x1b[33m\\n  !!!success!!!\\n\\x1b[39m\");\n            mine.print_correct();\n            break;\n        }\n    }\n\n    return 0;\n}\n\n\n\n\u52d5\u4f5c\n\u3053\u3093\u306a\u611f\u3058\u3067\u52d5\u304d\u307e\u3059\uff0e\u5f15\u6570\u306b\u9ad8\u3055\uff0c\u5e45\uff0c\u7206\u5f3e\u306e\u7dcf\u6570\u3092\u6e21\u3059\u3053\u3068\u304c\u3067\u304d\u307e\u3059\uff0e\u4f55\u3082\u6e21\u3055\u306a\u304b\u3063\u305f\u3089\u30c7\u30d5\u30a9\u30eb\u30c8\u306e\u30b5\u30a4\u30ba10\u00d710\uff0c\u7206\u5f3e\u657010\u3067\u30b2\u30fc\u30e0\u304c\u30b9\u30bf\u30fc\u30c8\u3057\u307e\u3059\uff0e\n\n\u30b5\u30a4\u30ba20\u00d720\uff0c\u7206\u5f3e\u6570400\u3067\u3084\u308b\u3068\u3053\u3093\u306a\u611f\u3058\uff0e\n\n\u3075\u3056\u3051\u307e\u3057\u305f\uff0e\n\n\u30dd\u30a4\u30f3\u30c8\n\u30dd\u30a4\u30f3\u30c8\u306f\u4ee5\u4e0b\u306e3\u3064\u3067\u3059\uff0e\n\u30fbmalloc\u3092\u4f7f\u3063\u305f2\u6b21\u5143\u914d\u5217\u306e\u751f\u6210\n\u30fbopen\u30e1\u30bd\u30c3\u30c9\u3092\u518d\u5e30\n\u30fb\u91cd\u8907\u306e\u306a\u3044\u30e9\u30f3\u30c0\u30e0\u914d\u5217\u306e\u751f\u6210\n\nmalloc\u3092\u4f7f\u3063\u305f2\u6b21\u5143\u914d\u5217\u306e\u751f\u6210\n\u4e0b\u306e\u3088\u3046\u306bmalloc\u3092\u4f7f\u3046\u3053\u3068\u3067\uff0c2\u6b21\u5143\u914d\u5217\u3092\u52d5\u7684\u306b\u751f\u6210\u3059\u308b\u3053\u3068\u304c\u3067\u304d\u307e\u3059\uff0e\nvector\u306evector\u3067\u3082\u53ef\u80fd\u3067\u3059\u304c\uff0c\u4eca\u56de\u306fmalloc\u4f7f\u3063\u3066\u307f\u307e\u3057\u305f\uff0e\nint **matrix = (int **)malloc(sizeof(int *) * height);\nfor(int y = 0; y < height; y++) {\n    matrix[y] = (int *)malloc(sizeof(int) * width);\n}\n\n\u3053\u3093\u306a\u3075\u3046\u306b\u66f8\u304f\u3068\uff0c\u968e\u6bb5\u307f\u305f\u3044\u306a2\u6b21\u5143\u914d\u5217\uff08\u306e\u3088\u3046\u306a\u3082\u306e\uff1f\uff09\u3082\u3064\u304f\u308c\u307e\u3059\uff0e\nint N = 10;\nint **matrix = (int **)malloc(sizeof(int *) * N);\nfor(int j = 0; j < N; j++) {\n    matrix[j] = (int *)malloc(sizeof(int) * (j + 1));\n    for(int i = 0; i <= j; j++) {\n        matrix[j][i] = j * i;\n    }\n}\n\n/*\n0\n0  1\n0  2  4\n0  3  6  9\n0  4  8 12 16\n0  5 10 15 20 25\n0  6 12 18 24 30 36\n0  7 14 21 28 35 42 49\n0  8 16 24 32 40 48 56 64\n0  9 18 27 36 45 54 63 72 81\n*/\n\n\nopen\u30e1\u30bd\u30c3\u30c9\u306e\u518d\u5e30\n\u300c\u5468\u56f2\u306e\u7206\u5f3e\u306e\u6570\u304c0\u500b\u306e\u30de\u30b9\u300d\u3092\u958b\u3051\u305f\u3068\u304d\u5468\u56f2\u306e8\u500b\u306e\u30de\u30b9\u3092\u540c\u6642\u306b\u958b\u304d\u307e\u3059\uff0e\n\u3053\u306e\u3068\u304d\u5468\u56f2\u306e8\u500b\u306e\u30de\u30b9\u306e\u4e2d\u306b\u540c\u3058\u3088\u3046\u306b\u300c\u5468\u56f2\u306e\u7206\u5f3e\u306e\u6570\u304c0\u500b\u306e\u30de\u30b9\u300d\u304c\u3042\u3063\u305f\u5834\u5408\uff0c\u305d\u306e\u30de\u30b9\u306e\u5468\u56f28\u500b\u306e\u30de\u30b9\u3082\u958b\u304d\u307e\u3059\uff0e\n\u3069\u3093\u306a\u52d5\u304d\u304b\u60f3\u50cf\u3057\u3065\u3089\u3044\u3068\u601d\u3046\u306e\u3067\uff0c\u5148\u306b\u753b\u50cf\u3092\u304a\u898b\u305b\u3057\u307e\u3059\uff0e\n\u4e0b\u306e\u753b\u50cf\u3067\u306f(0, 0)\u306e\u30de\u30b9\u3057\u304b\u958b\u3044\u3066\u3044\u306a\u3044\u306e\u306b\uff0c\u4e00\u6c17\u306b\u30de\u30b9\u304c\u958b\u3044\u3066\u3044\u307e\u3059\uff0e\u3053\u308c\u306f\uff0c(0, 0)\u306e\u30de\u30b9\u306e\u5468\u56f2\u306b\u306f\u7206\u5f3e\u304c\u5b58\u5728\u3057\u306a\u3044\u306e\u3067\uff0c\u305d\u306e\u5468\u56f2\u306e(0, 1), (1, 0), (1, 1)\u3082\u958b\u304d\u307e\u3059\uff0e\n\u3059\u308b\u3068\uff0c(1, 0)\u306e\u30de\u30b9\u306e\u5468\u56f2\u306b\u3082\u7206\u5f3e\u304c\u5b58\u5728\u3057\u306a\u3044\u306e\u3067\uff0c\u5468\u8fba\u306e\u307e\u3060\u958b\u3044\u3066\u3044\u306a\u3044(2, 0), (2, 1)\u3092\u958b\u304d\u307e\u3059\uff0e\u3053\u308c\u304c\u9023\u7d9a\u3057\u3066\u304a\u3053\u308b\u305f\u3081\uff0c\u4e00\u6c17\u306b\u30de\u30b9\u304c\u958b\u304d\u307e\u3059\uff0e\n\n\u3067\u306f\u30b3\u30fc\u30c9\u3067\u3059\uff0e\n\u958b\u3044\u305f\u30de\u30b9\u306e\u5468\u8fba\u306e\u7206\u5f3e\u306e\u6570\u304c0\u306a\u306e\u3067\uff0celse if(val == 0)\u306b\u5165\u308a\u307e\u3059\uff0e\u5468\u56f2\u306e\u30de\u30b9\u306e\u4e2d\u3067\u307e\u3060\u958b\u3044\u3066\u3044\u306a\u3044\u30de\u30b9\u306e\u5ea7\u6a19\u3092\u5f15\u6570\u306bopen\u3092\u547c\u3093\u3067\u3044\u307e\u3059\uff0e\n\u3053\u308c\u306b\u3088\u308a\u4e00\u6c17\u306b\u958b\u304f\u5b9f\u88c5\u304c\u3067\u304d\u307e\u3059\uff0e\nbool Mine::open(int y, int x) {\n    int val = matrix[y][x];\n    if(val == -1) {\n        return false;\n    }\n    else if(val == 0) {\n        for(int j = -1; j <= 1; j++) {\n            for(int i = -1; i <= 1; i++) {\n                int _y = y + j, _x = x + i;\n                if(_y < 0 || _x < 0 || _y >= height || _x >= width) {\n                    continue;\n                }\n                else if(!map[_y][_x]) {\n                    map[_y][_x] = true;\n                    open(_y, _x); // \u3053\u3053\u304c\u30dd\u30a4\u30f3\u30c8\n                }\n            }\n        }\n        return true;\n    }\n    else {\n        map[y][x] = true;\n        return true;\n    }\n}\n\n\n\u91cd\u8907\u306e\u306a\u3044\u30e9\u30f3\u30c0\u30e0\u914d\u5217\u306e\u751f\u6210\n\u91cd\u8907\u306e\u306a\u3044\u30e9\u30f3\u30c0\u30e0\u306a\u5024\u304c\u683c\u7d0d\u3055\u308c\u305f\u914d\u5217\u3092\u751f\u6210\u3059\u308b\u306b\u306f\u4ee5\u4e0b\u306e\u3088\u3046\u306b\u3057\u3066\u3044\u307e\u3059\uff0e\n\u3053\u3053\u306f\u3042\u307e\u308a\u81ea\u4fe1\u304c\u306a\u3044\u306e\u3067\uff0c\u3082\u3063\u3068\u3044\u3044\u65b9\u6cd5\u3042\u308b\u3088\u3063\u3066\u65b9\u306f\u6559\u3048\u3066\u4e0b\u3055\u3044\uff0e\n\u7206\u5f3e\u3092\u7f6e\u304f\u5ea7\u6a19\u3092\u4e71\u6570\u3067\u6c7a\u5b9a\u3057\uff0c\u3053\u308c\u304c\u307e\u3060\u767b\u9332\u3055\u308c\u3066\u3044\u306a\u3044\u5024\u3060\u3063\u305f\u3089\u63a1\u7528\uff0c\u3059\u3067\u306b\u767b\u9332\u6e08\u307f\u3067\u3042\u3063\u305f\u3089\u4e0d\u63a1\u7528\u306b\u3057\u3066\u3044\u307e\u3059\uff0e\n\u30b5\u30a4\u30ba\u306e50\uff05\u4ee5\u4e0a\u3092\u7206\u5f3e\u304c\u5360\u3081\u308b\u5834\u5408\u306f\uff0c\u7206\u5f3e\u3092\u7f6e\u304b\u306a\u3044\u5ea7\u6a19\u3092\u4e71\u6570\u3067\u6c7a\u5b9a\u3057\uff0c\u6700\u5f8c\u306b\u53cd\u8ee2\u3055\u305b\u308c\u3070\u5c0f\u3055\u306a\u30b5\u30a4\u30ba\u306e\u914d\u5217\u3067\u7206\u5f3e\u3092\u914d\u7f6e\u3067\u304d\u307e\u3059\uff0e\nvoid Mine::create_check_array(bool *check) {\n    int _bombs = 2 * bombs < size ? bombs : size - bombs;\n    int *random = (int *)malloc(sizeof(int) * _bombs);\n    for(int _b = 0; _b < _bombs; _b++) {\n        while(1) {\n            int val = rand() % size;\n            if(!check[val]) {\n                check[val] = true;\n                random[_b] = val;\n                break;\n            }           \n        }\n    }\n\n    // \u30b5\u30a4\u30ba\u306e50\uff05\u4ee5\u4e0a\u3092\u7206\u5f3e\u304c\u5360\u3081\u308b\u5834\u5408\u306e\u53cd\u8ee2\u4f5c\u696d\n    if(_bombs != bombs) {\n        for(int i = 0; i < size; i++) {\n            check[i] = !check[i];\n        }\n    }\n    free(random);\n}\n\n\n\u6700\u5f8c\u306b\n\u81ea\u5206\u3067\u5b9f\u88c5\u3057\u305f\u304b\u3089\u304b\u5b9f\u969b\u306b\u30d7\u30ec\u30a4\u3057\u3066\u307f\u308b\u3068\u6848\u5916\u697d\u3057\u3044\u3067\u3059\uff0e\u5ea7\u6a19\u3092\u6bce\u56de\u5165\u529b\u3059\u308b\u306e\u304c\u304b\u306a\u308a\u9762\u5012\u3067\u3059\u304c\uff0e\uff0e\uff0e\n\u3082\u3063\u3068\u3053\u3046\u66f8\u3044\u305f\u3089\u3044\u3044\u3088\uff01\u305d\u3053\u304a\u304b\u3057\u304f\u306a\u3044\uff1f\u307f\u305f\u3044\u306a\u306e\u3042\u3063\u305f\u3089\u6559\u3048\u3066\u4e0b\u3055\u3044\uff0e\n# \u306f\u3058\u3081\u306b\n\u3075\u3068\u601d\u3044\u7acb\u3063\u305f\u306e\u3067\u30bf\u30fc\u30df\u30ca\u30eb\u3067\u30d7\u30ec\u30a4\u3059\u308b\u30de\u30a4\u30f3\u30b9\u30a4\u30fc\u30d1\u3064\u304f\u3063\u3066\u307f\u307e\u3057\u305f\uff0e\n\n# \u30de\u30a4\u30f3\u30b9\u30a4\u30fc\u30d1\u3068\u306f\uff1f\n>\u30de\u30a4\u30f3\u30b9\u30a4\u30fc\u30d1\uff08Minesweeper\uff09\u306f1980\u5e74\u4ee3\u306b\u767a\u660e\u3055\u308c\u305f\uff0c\u4e00\u4eba\u7528\u306e\u30b3\u30f3\u30d4\u30e5\u30fc\u30bf\u30b2\u30fc\u30e0\u3067\u3042\u308b\uff0e\u30b2\u30fc\u30e0\u306e\u76ee\u7684\u306f\u5730\u96f7\u539f\u304b\u3089\u5730\u96f7\u3092\u53d6\u308a\u9664\u304f\u3053\u3068\u3067\u3042\u308b\uff0e\n\u3053\u306e\u30b2\u30fc\u30e0\u306f\u591a\u6570\u306e\u30b3\u30f3\u30d4\u30e5\u30fc\u30bf\u30d7\u30e9\u30c3\u30c8\u30d5\u30a9\u30fc\u30e0\u5411\u3051\u306b\u66f8\u304d\u76f4\u3055\u308c\u3066\u304a\u308a\uff0cMicrosoft Windows\u3092\u306f\u3058\u3081\uff0cLinux\u306eGNOME\u3084KDE\u306a\u3069\u306e\u30b7\u30b9\u30c6\u30e0\u306b\u540c\u68b1\u3055\u308c\u3066\u3044\u308b\u3082\u306e\u3082\u3042\u308b\uff0e\nwikipedia\u3088\u308a\u5f15\u7528\uff1ahttps://ja.wikipedia.org/wiki/\u30de\u30a4\u30f3\u30b9\u30a4\u30fc\u30d1\n\n# \u30b3\u30fc\u30c9\n\n\u4ee5\u4e0b\u306e\u3088\u3046\u306b\u5b9f\u88c5\u3057\u307e\u3057\u305f\uff0e\n\n```minesweeper.hpp\n#include <stdio.h>\n#include <stdlib.h>\n#include <time.h>\n\nclass Mine {\npublic:\n\tMine(int h, int w, int b);\n\t~Mine();\n\tvoid start();\n\tvoid print_matrix();\n\tvoid print_correct();\n\tvoid get_point(char msg[], int *pt, int threshold);\n\tbool open(int y, int x);\n\tbool is_clear();\n\nprivate:\n\tint **matrix;\n\tbool **map;\n\tint height;\n\tint width;\n\tint bombs;\n\tint size;\n\tvoid create_check_array(bool *check);\n\tvoid create_matrix_and_map(bool *check);\n\tbool is_number(char str[]);\n};\n```\n\n```minesweeper.cpp\n#include \"minesweeper.hpp\"\n\nMine::Mine(int h, int w, int b) {\n\theight = h;\n\twidth = w;\n\tbombs = b;\n\tsize = height * width;\n\tmatrix = (int **)malloc(sizeof(int *) * height);\n\tmap = (bool **)malloc(sizeof(bool *) * height);\n\n\tsrand((unsigned int)time(NULL)); \n\tbool *check = (bool *)malloc(sizeof(bool) * size);\n\tcreate_check_array(check);\n\tcreate_matrix_and_map(check);\n\n\tfree(check);\n}\n\nMine::~Mine() {\n\tfree(matrix);\n\tfree(map);\n}\n\nvoid Mine::start() {\n\tprintf(\"\\n\\x1b[37m  !!!size:%dx%d, bombs:%d start!!!\\n\\x1b[39m\", height, width, bombs);\n}\n\nvoid Mine::print_matrix() {\n\tprintf(\"     \");\n\tfor(int x = 0; x < width; x++) {\n\t\tprintf(\"%3d\", x);\n\t}\n\tprintf(\"\\n\");\n\tprintf(\"     \");\n\tfor(int x = 0; x < width; x++) {\n\t\tprintf(\"---\");\n\t}\n\tprintf(\"\\n\");\n\tfor(int y = 0; y < height; y++) {\n\t\tprintf(\"%3d |\", y);\n\t\tfor(int x = 0; x < width; x++) {\n\t\t\tif(map[y][x] == false) {\n\t\t\t\tprintf(\"  ?\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\tint val = matrix[y][x];\n\t\t\t\tif(val > 0) {\n\t\t\t\t\tprintf(\"\\x1b[37m%3d\\x1b[39m\", val);\n\t\t\t\t}\n\t\t\t\telse if(val == 0) {\n\t\t\t\t\tprintf(\"  -\");\n\t\t\t\t}\n\t\t\t\telse if(val == -1) {\n\t\t\t\t\tprintf(\"\\x1b[31m  *\\x1b[39m\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n}\n\nvoid Mine::print_correct() {\n\tfor(int y = 0; y < height; y++) {\n\t\tfor(int x = 0; x < width; x++) {\n\t\t\tmap[y][x] = true;\n\t\t}\n\t}\n\tprint_matrix();\n}\n\nvoid Mine::get_point(char msg[], int *pt, int threshold) {\n\twhile(1) {\n\t\tchar str[8] = {};\n\t\tprintf(\"%s(0 ~ %d)  \", msg, threshold - 1);\n\t\tscanf(\"%s\", str);\n\t\tif(is_number(str) && sscanf(str, \"%d\", pt) == 1) {\n\t\t\tif(*pt >= 0 && *pt < threshold) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}\n\nbool Mine::open(int y, int x) {\n\tint val = matrix[y][x];\n\tif(val == -1) {\n\t\treturn false;\n\t}\n\telse if(val == 0) {\n\t\tfor(int j = -1; j <= 1; j++) {\n\t\t\tfor(int i = -1; i <= 1; i++) {\n\t\t\t\tint _y = y + j, _x = x + i;\n\t\t\t\tif(_y < 0 || _x < 0 || _y >= height || _x >= width) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\telse if(!map[_y][_x]) {\n\t\t\t\t\tmap[_y][_x] = true;\n\t\t\t\t\topen(_y, _x);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\telse {\n\t\tmap[y][x] = true;\n\t\treturn true;\n\t}\n}\n\nbool Mine::is_clear() {\n\tint count = 0;\n\tfor(int y = 0; y < height; y++) {\n\t\tfor(int x = 0; x < width; x++) {\n\t\t\tif(!map[y][x]) {\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t}\n\n\tif(count == bombs) {\n\t\treturn true;\n\t}\n\telse {\n\t\treturn false;\n\t}\n}\n\nvoid Mine::create_check_array(bool *check) {\n\tint _bombs = 2 * bombs < size ? bombs : size - bombs;\n\tint *random = (int *)malloc(sizeof(int) * _bombs);\n\tfor(int _b = 0; _b < _bombs; _b++) {\n\t\twhile(1) {\n\t\t\tint val = rand() % size;\n\t\t\tif(!check[val]) {\n\t\t\t\tcheck[val] = true;\n\t\t\t\trandom[_b] = val;\n\t\t\t\tbreak;\n\t\t\t}\t\t\t\n\t\t}\n\t}\n\tif(_bombs != bombs) {\n\t\tfor(int i = 0; i < size; i++) {\n\t\t\tcheck[i] = !check[i];\n\t\t}\n\t}\n\tfree(random);\n}\n\nvoid Mine::create_matrix_and_map(bool *check) {\n\tfor(int y = 0; y < height; y++) {\n\t\tmatrix[y] = (int *)malloc(sizeof(int) * width);\n\t\tmap[y] = (bool *)malloc(sizeof(bool) * width);\n\t\tfor(int x = 0; x < width; x++) {\n\t\t\tint index = y * width + x;\n\t\t\tif(check[index]) {\n\t\t\t\tmatrix[y][x] = -1;\n\t\t\t}\n\t\t\tmap[y][x] = false;\n\t\t}\n\t}\n\tfor(int y = 0; y < height; y++) {\n\t\tfor(int x = 0; x < width; x++) {\n\t\t\tint val = matrix[y][x];\n\t\t\tif(val != -1) {\n\t\t\t\tint count = 0;\n\t\t\t\tfor(int j = -1; j <= 1; j++) {\n\t\t\t\t\tfor(int i = -1; i <= 1; i++) {\n\t\t\t\t\t\tint _y = y + j, _x = x + i;\n\t\t\t\t\t\tif(_y < 0 || _x < 0 || _y >= height || _x >= width) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if(matrix[_y][_x] == -1) {\n\t\t\t\t\t\t\tcount++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tmatrix[y][x] = count;\n\t\t\t}\n\t\t}\n\t}\n}\n\nbool Mine::is_number(char str[]) {\n\tfor(int i = 0; str[i]; i++) {\n\t\tif(str[i] < '0' || str[i] > '9') {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}\n```\n\n```main.cpp\n#include \"minesweeper.hpp\"\n\nint main(int argc, char* argv[]) {\n\t\n\tint height = argc == 4 ? atoi(argv[1]) : 10;\n\tint width = argc == 4 ? atoi(argv[2]) : 10;\n\tint bombs = argc == 4 ? atoi(argv[3]) : 10;\n\tif(bombs > height * width) {\n\t\tprintf(\"!!!too many bombs!!!\\n\");\n\t\treturn 0;\n\t}\n\n\tMine mine(height, width, bombs);\n\tmine.start();\n\tint pt_y = 0, pt_x = 0;\n\twhile(1) {\n\t\tprintf(\"\\n\");\n\t\tmine.print_matrix();\n\t\tmine.get_point((char *)\"  input point y: \", &pt_y, height);\n\t\tmine.get_point((char *)\"  input point x: \", &pt_x, width);\n\t\tif(!mine.open(pt_y, pt_x)) {\n\t\t\tprintf(\"\\x1b[31m\\n  !!!failed!!!\\n\\x1b[39m\");\n\t\t\tmine.print_correct();\n\t\t\tbreak;\n\t\t}\n\t\tif(mine.is_clear()) {\n\t\t\tprintf(\"\\x1b[33m\\n  !!!success!!!\\n\\x1b[39m\");\n\t\t\tmine.print_correct();\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn 0;\n}\n```\n\n# \u52d5\u4f5c\n\n\u3053\u3093\u306a\u611f\u3058\u3067\u52d5\u304d\u307e\u3059\uff0e\u5f15\u6570\u306b\u9ad8\u3055\uff0c\u5e45\uff0c\u7206\u5f3e\u306e\u7dcf\u6570\u3092\u6e21\u3059\u3053\u3068\u304c\u3067\u304d\u307e\u3059\uff0e\u4f55\u3082\u6e21\u3055\u306a\u304b\u3063\u305f\u3089\u30c7\u30d5\u30a9\u30eb\u30c8\u306e\u30b5\u30a4\u30ba10\u00d710\uff0c\u7206\u5f3e\u657010\u3067\u30b2\u30fc\u30e0\u304c\u30b9\u30bf\u30fc\u30c8\u3057\u307e\u3059\uff0e\n\n<img width=\"271\" alt=\"screenshot 18.png\" src=\"https://qiita-image-store.s3.amazonaws.com/0/82527/a58ce0c0-8580-e760-3e82-2b9760e9e55f.png\">\n\n\u30b5\u30a4\u30ba20\u00d720\uff0c\u7206\u5f3e\u6570400\u3067\u3084\u308b\u3068\u3053\u3093\u306a\u611f\u3058\uff0e\n\n<img width=\"480\" alt=\"screenshot 19.png\" src=\"https://qiita-image-store.s3.amazonaws.com/0/82527/18c8d578-0269-c143-92f4-2906d8f5b840.png\">\n\n\u3075\u3056\u3051\u307e\u3057\u305f\uff0e\n\n# \u30dd\u30a4\u30f3\u30c8\n\n\u30dd\u30a4\u30f3\u30c8\u306f\u4ee5\u4e0b\u306e3\u3064\u3067\u3059\uff0e\n\u30fbmalloc\u3092\u4f7f\u3063\u305f2\u6b21\u5143\u914d\u5217\u306e\u751f\u6210\n\u30fbopen\u30e1\u30bd\u30c3\u30c9\u3092\u518d\u5e30\n\u30fb\u91cd\u8907\u306e\u306a\u3044\u30e9\u30f3\u30c0\u30e0\u914d\u5217\u306e\u751f\u6210\n\n## malloc\u3092\u4f7f\u3063\u305f2\u6b21\u5143\u914d\u5217\u306e\u751f\u6210\n\n\u4e0b\u306e\u3088\u3046\u306bmalloc\u3092\u4f7f\u3046\u3053\u3068\u3067\uff0c2\u6b21\u5143\u914d\u5217\u3092\u52d5\u7684\u306b\u751f\u6210\u3059\u308b\u3053\u3068\u304c\u3067\u304d\u307e\u3059\uff0e\nvector\u306evector\u3067\u3082\u53ef\u80fd\u3067\u3059\u304c\uff0c\u4eca\u56de\u306fmalloc\u4f7f\u3063\u3066\u307f\u307e\u3057\u305f\uff0e\n\n```\nint **matrix = (int **)malloc(sizeof(int *) * height);\nfor(int y = 0; y < height; y++) {\n\tmatrix[y] = (int *)malloc(sizeof(int) * width);\n}\n```\n\n\u3053\u3093\u306a\u3075\u3046\u306b\u66f8\u304f\u3068\uff0c\u968e\u6bb5\u307f\u305f\u3044\u306a2\u6b21\u5143\u914d\u5217\uff08\u306e\u3088\u3046\u306a\u3082\u306e\uff1f\uff09\u3082\u3064\u304f\u308c\u307e\u3059\uff0e\n\n```\nint N = 10;\nint **matrix = (int **)malloc(sizeof(int *) * N);\nfor(int j = 0; j < N; j++) {\n\tmatrix[j] = (int *)malloc(sizeof(int) * (j + 1));\n\tfor(int i = 0; i <= j; j++) {\n\t\tmatrix[j][i] = j * i;\n\t}\n}\n\n/*\n0\n0  1\n0  2  4\n0  3  6  9\n0  4  8 12 16\n0  5 10 15 20 25\n0  6 12 18 24 30 36\n0  7 14 21 28 35 42 49\n0  8 16 24 32 40 48 56 64\n0  9 18 27 36 45 54 63 72 81\n*/\n```\n\n## open\u30e1\u30bd\u30c3\u30c9\u306e\u518d\u5e30\n\n\u300c\u5468\u56f2\u306e\u7206\u5f3e\u306e\u6570\u304c0\u500b\u306e\u30de\u30b9\u300d\u3092\u958b\u3051\u305f\u3068\u304d\u5468\u56f2\u306e8\u500b\u306e\u30de\u30b9\u3092\u540c\u6642\u306b\u958b\u304d\u307e\u3059\uff0e\n\u3053\u306e\u3068\u304d\u5468\u56f2\u306e8\u500b\u306e\u30de\u30b9\u306e\u4e2d\u306b\u540c\u3058\u3088\u3046\u306b\u300c\u5468\u56f2\u306e\u7206\u5f3e\u306e\u6570\u304c0\u500b\u306e\u30de\u30b9\u300d\u304c\u3042\u3063\u305f\u5834\u5408\uff0c\u305d\u306e\u30de\u30b9\u306e\u5468\u56f28\u500b\u306e\u30de\u30b9\u3082\u958b\u304d\u307e\u3059\uff0e\n\u3069\u3093\u306a\u52d5\u304d\u304b\u60f3\u50cf\u3057\u3065\u3089\u3044\u3068\u601d\u3046\u306e\u3067\uff0c\u5148\u306b\u753b\u50cf\u3092\u304a\u898b\u305b\u3057\u307e\u3059\uff0e\n\u4e0b\u306e\u753b\u50cf\u3067\u306f(0, 0)\u306e\u30de\u30b9\u3057\u304b\u958b\u3044\u3066\u3044\u306a\u3044\u306e\u306b\uff0c\u4e00\u6c17\u306b\u30de\u30b9\u304c\u958b\u3044\u3066\u3044\u307e\u3059\uff0e\u3053\u308c\u306f\uff0c(0, 0)\u306e\u30de\u30b9\u306e\u5468\u56f2\u306b\u306f\u7206\u5f3e\u304c\u5b58\u5728\u3057\u306a\u3044\u306e\u3067\uff0c\u305d\u306e\u5468\u56f2\u306e(0, 1), (1, 0), (1, 1)\u3082\u958b\u304d\u307e\u3059\uff0e\n\u3059\u308b\u3068\uff0c(1, 0)\u306e\u30de\u30b9\u306e\u5468\u56f2\u306b\u3082\u7206\u5f3e\u304c\u5b58\u5728\u3057\u306a\u3044\u306e\u3067\uff0c\u5468\u8fba\u306e\u307e\u3060\u958b\u3044\u3066\u3044\u306a\u3044(2, 0), (2, 1)\u3092\u958b\u304d\u307e\u3059\uff0e\u3053\u308c\u304c\u9023\u7d9a\u3057\u3066\u304a\u3053\u308b\u305f\u3081\uff0c\u4e00\u6c17\u306b\u30de\u30b9\u304c\u958b\u304d\u307e\u3059\uff0e\n\n<img width=\"267\" alt=\"screenshot 20.png\" src=\"https://qiita-image-store.s3.amazonaws.com/0/82527/392fa507-a4d1-8c64-8322-37c884a513d5.png\">\n\n\u3067\u306f\u30b3\u30fc\u30c9\u3067\u3059\uff0e\n\u958b\u3044\u305f\u30de\u30b9\u306e\u5468\u8fba\u306e\u7206\u5f3e\u306e\u6570\u304c0\u306a\u306e\u3067\uff0celse if(val == 0)\u306b\u5165\u308a\u307e\u3059\uff0e\u5468\u56f2\u306e\u30de\u30b9\u306e\u4e2d\u3067\u307e\u3060\u958b\u3044\u3066\u3044\u306a\u3044\u30de\u30b9\u306e\u5ea7\u6a19\u3092\u5f15\u6570\u306bopen\u3092\u547c\u3093\u3067\u3044\u307e\u3059\uff0e\n\u3053\u308c\u306b\u3088\u308a\u4e00\u6c17\u306b\u958b\u304f\u5b9f\u88c5\u304c\u3067\u304d\u307e\u3059\uff0e\n\n```\nbool Mine::open(int y, int x) {\n\tint val = matrix[y][x];\n\tif(val == -1) {\n\t\treturn false;\n\t}\n\telse if(val == 0) {\n\t\tfor(int j = -1; j <= 1; j++) {\n\t\t\tfor(int i = -1; i <= 1; i++) {\n\t\t\t\tint _y = y + j, _x = x + i;\n\t\t\t\tif(_y < 0 || _x < 0 || _y >= height || _x >= width) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\telse if(!map[_y][_x]) {\n\t\t\t\t\tmap[_y][_x] = true;\n\t\t\t\t\topen(_y, _x); // \u3053\u3053\u304c\u30dd\u30a4\u30f3\u30c8\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\telse {\n\t\tmap[y][x] = true;\n\t\treturn true;\n\t}\n}\n```\n\n## \u91cd\u8907\u306e\u306a\u3044\u30e9\u30f3\u30c0\u30e0\u914d\u5217\u306e\u751f\u6210\n\n\u91cd\u8907\u306e\u306a\u3044\u30e9\u30f3\u30c0\u30e0\u306a\u5024\u304c\u683c\u7d0d\u3055\u308c\u305f\u914d\u5217\u3092\u751f\u6210\u3059\u308b\u306b\u306f\u4ee5\u4e0b\u306e\u3088\u3046\u306b\u3057\u3066\u3044\u307e\u3059\uff0e\n\u3053\u3053\u306f\u3042\u307e\u308a\u81ea\u4fe1\u304c\u306a\u3044\u306e\u3067\uff0c\u3082\u3063\u3068\u3044\u3044\u65b9\u6cd5\u3042\u308b\u3088\u3063\u3066\u65b9\u306f\u6559\u3048\u3066\u4e0b\u3055\u3044\uff0e\n\u7206\u5f3e\u3092\u7f6e\u304f\u5ea7\u6a19\u3092\u4e71\u6570\u3067\u6c7a\u5b9a\u3057\uff0c\u3053\u308c\u304c\u307e\u3060\u767b\u9332\u3055\u308c\u3066\u3044\u306a\u3044\u5024\u3060\u3063\u305f\u3089\u63a1\u7528\uff0c\u3059\u3067\u306b\u767b\u9332\u6e08\u307f\u3067\u3042\u3063\u305f\u3089\u4e0d\u63a1\u7528\u306b\u3057\u3066\u3044\u307e\u3059\uff0e\n\u30b5\u30a4\u30ba\u306e50\uff05\u4ee5\u4e0a\u3092\u7206\u5f3e\u304c\u5360\u3081\u308b\u5834\u5408\u306f\uff0c\u7206\u5f3e\u3092\u7f6e\u304b\u306a\u3044\u5ea7\u6a19\u3092\u4e71\u6570\u3067\u6c7a\u5b9a\u3057\uff0c\u6700\u5f8c\u306b\u53cd\u8ee2\u3055\u305b\u308c\u3070\u5c0f\u3055\u306a\u30b5\u30a4\u30ba\u306e\u914d\u5217\u3067\u7206\u5f3e\u3092\u914d\u7f6e\u3067\u304d\u307e\u3059\uff0e\n\n```\nvoid Mine::create_check_array(bool *check) {\n\tint _bombs = 2 * bombs < size ? bombs : size - bombs;\n\tint *random = (int *)malloc(sizeof(int) * _bombs);\n\tfor(int _b = 0; _b < _bombs; _b++) {\n\t\twhile(1) {\n\t\t\tint val = rand() % size;\n\t\t\tif(!check[val]) {\n\t\t\t\tcheck[val] = true;\n\t\t\t\trandom[_b] = val;\n\t\t\t\tbreak;\n\t\t\t}\t\t\t\n\t\t}\n\t}\n\n\t// \u30b5\u30a4\u30ba\u306e50\uff05\u4ee5\u4e0a\u3092\u7206\u5f3e\u304c\u5360\u3081\u308b\u5834\u5408\u306e\u53cd\u8ee2\u4f5c\u696d\n\tif(_bombs != bombs) {\n\t\tfor(int i = 0; i < size; i++) {\n\t\t\tcheck[i] = !check[i];\n\t\t}\n\t}\n\tfree(random);\n}\n```\n\n# \u6700\u5f8c\u306b\n\n\u81ea\u5206\u3067\u5b9f\u88c5\u3057\u305f\u304b\u3089\u304b\u5b9f\u969b\u306b\u30d7\u30ec\u30a4\u3057\u3066\u307f\u308b\u3068\u6848\u5916\u697d\u3057\u3044\u3067\u3059\uff0e\u5ea7\u6a19\u3092\u6bce\u56de\u5165\u529b\u3059\u308b\u306e\u304c\u304b\u306a\u308a\u9762\u5012\u3067\u3059\u304c\uff0e\uff0e\uff0e\n\u3082\u3063\u3068\u3053\u3046\u66f8\u3044\u305f\u3089\u3044\u3044\u3088\uff01\u305d\u3053\u304a\u304b\u3057\u304f\u306a\u3044\uff1f\u307f\u305f\u3044\u306a\u306e\u3042\u3063\u305f\u3089\u6559\u3048\u3066\u4e0b\u3055\u3044\uff0e\n", "tags": ["C++", "malloc", "\u518d\u5e30", "\u30de\u30a4\u30f3\u30b9\u30a4\u30fc\u30d1"]}