{"context": " More than 1 year has passed since last update.x86(i386)\u30a2\u30fc\u30ad\u30c6\u30af\u30c1\u30e3\u5411\u3051\u306bGCC\u304c\u51fa\u529b\u3059\u308b\u30b3\u30fc\u30c9\u3067\u3001\u30b9\u30bf\u30c3\u30af\u30d5\u30ec\u30fc\u30e0\u304c16byte\u30a2\u30e9\u30a4\u30e1\u30f3\u30c8\u3055\u308c\u308b\u7406\u7531\u3092\u6c42\u3081\u3066\u30021\n\u203b \u672c\u8a18\u4e8b\u306e\u6b63\u78ba\u6027\u306f\u4fdd\u8a3c\u3067\u304d\u307e\u305b\u3093\u3002\u8aa4\u308a\u6307\u6458\u3084\u8ffd\u52a0\u60c5\u5831\u304c\u3042\u308c\u3070\u30b3\u30e1\u30f3\u30c8\u307e\u3067\u304a\u9858\u3044\u3057\u307e\u3059\u3002\n\n\u7d4c\u7def\n\nSysV ABI\u5f53\u521d\u3067\u306f\u30ef\u30fc\u30c9(4byte)\u30a2\u30e9\u30a4\u30e1\u30f3\u30c8\u306e\u307f\u304c\u8981\u8acb\u3055\u308c\u3066\u3044\u305f\u3002\nMMX, SSE\u306a\u3069\u306eSIMD\u547d\u4ee4\u767b\u5834\u306b\u3088\u308a\u3001\u30b9\u30bf\u30c3\u30af\u5909\u6570\u3067\u308216byte\u30a2\u30e9\u30a4\u30e1\u30f3\u30c8\u304c\u8981\u8acb\u3055\u308c\u308b\u30b1\u30fc\u30b9\u304c\u767a\u751f\u3002\u307e\u305f\u30a2\u30e9\u30a4\u30e1\u30f3\u30c8\u5fc5\u9808\u3067\u306a\u3044\u547d\u4ee4\u3067\u3042\u3063\u3066\u3082\u30d1\u30d5\u30a9\u30fc\u30de\u30f3\u30b9\u7684\u306b\u306f16byte\u30a2\u30e9\u30a4\u30e1\u30f3\u30c8\u304c\u597d\u307e\u3057\u3044\u3002\nMac OS X i386 ABI\u3067\u306f16byte\u30a2\u30e9\u30a4\u30e1\u30f3\u30c8\u3092\u660e\u78ba\u306b\u8981\u8acb\u3002\nGCC\u3067\u30b5\u30dd\u30fc\u30c8\u3059\u308bLinux/BSD/OSX\u9593\u306e\u4e00\u8cab\u6027\u306e\u89b3\u70b9\u304b\u308916byte\u30a2\u30e9\u30a4\u30e1\u30f3\u30c8\u3092\u63a1\u7528\u3002\n\n\u65b0\u3057\u3044SysV psABI\u3067\u306f16byte\u30a2\u30e9\u30a4\u30e1\u30f3\u30c8\u306b\u5909\u66f4\u3002\n\n\nGCC Bugzilla\n\n#27537 XMM alignment fault when compiling for i386 with -Os \n#38496 Gcc misaligns arrays when stack is forced follow the x8632 ABI\n#40838 gcc shouldn't assume that the stack is aligned \n\n\nABI\u4ed5\u69d8\n\nx86-64\nSystem V Application Binary Interface, AMD64 Architecture Processor Supplement, Draft Version 0.99.6\uff1a\n\n3.2.2 The Stack Frame\nIn addition to registers, each function has a frame on the run-time stack. This stack grows downwards from high addresses. Figure 3.3 shows the stack organization. The end of the input argument area shall be aligned on a 16 (32, if __m256 is passed on stack) byte boundary.  In other words, the value (%rsp + 8) is always a multiple of 16 (32) when control is transferred to the function entry point.  The stack pointer, %rsp, always points to the end of the latest allocated stack frame.\n\n\ni386\nSYSTEM V APPLICATION BINARY INTERFACE, Intel386 Architecture Processor Supplement\uff1a\n\nRegisters and the Stack Frame\nSome registers have assigned roles in the standard calling sequence:\n%esp: The stack pointer holds the limit of the current stack frame, which is the address of the stack\u2019s bottom-most, valid word.  At all times, the stack pointer should point to a word-aligned area.\n\nOS X ABI Function Call Guide, IA-32 Function Calling Conventions\uff1a\n\nThe function calling conventions used in the IA-32 environment are the same as those used in the System V IA-32 ABI, with the following exceptions:\n\nThe stack is 16-byte aligned at the point of function calls\n\n\nSystem V Application Binary Interface, Intel386 Architecture Processor Supplement, Version 1.1\uff1a\n\n2.2.2 The Stack Frame\nIn addition to registers, each function has a frame on the run-time stack. This stack grows downwards from high addresses. Table 2.2 shows the stack organization.\nThe end of the input argument area shall be aligned on a 16 (32 or 64, if __m256 or __m512 is passed on stack) byte boundary. In other words, the value (%esp + 4) is always a multiple of 16 (32 or 64) when control is transferred to the function entry point. The stack pointer, %esp, always points to the end of the latest allocated stack frame. \n\n\n\n\n\nteratail ELF\u306e\u95a2\u6570\u30d7\u30ed\u30ed\u30fc\u30b0\u306b\u3064\u3044\u3066 \u3078\u306e\u56de\u7b54\u304c\u304d\u3063\u304b\u3051\u00a0\u21a9\n\n\n\nx86(i386)\u30a2\u30fc\u30ad\u30c6\u30af\u30c1\u30e3\u5411\u3051\u306bGCC\u304c\u51fa\u529b\u3059\u308b\u30b3\u30fc\u30c9\u3067\u3001\u30b9\u30bf\u30c3\u30af\u30d5\u30ec\u30fc\u30e0\u304c16byte\u30a2\u30e9\u30a4\u30e1\u30f3\u30c8\u3055\u308c\u308b\u7406\u7531\u3092\u6c42\u3081\u3066\u3002[^1]\n\n[^1]: teratail [ELF\u306e\u95a2\u6570\u30d7\u30ed\u30ed\u30fc\u30b0\u306b\u3064\u3044\u3066](https://teratail.com/questions/25921) \u3078\u306e\u56de\u7b54\u304c\u304d\u3063\u304b\u3051\n\n\u203b \u672c\u8a18\u4e8b\u306e\u6b63\u78ba\u6027\u306f\u4fdd\u8a3c\u3067\u304d\u307e\u305b\u3093\u3002\u8aa4\u308a\u6307\u6458\u3084\u8ffd\u52a0\u60c5\u5831\u304c\u3042\u308c\u3070\u30b3\u30e1\u30f3\u30c8\u307e\u3067\u304a\u9858\u3044\u3057\u307e\u3059\u3002\n\n# \u7d4c\u7def\n\n1. SysV ABI\u5f53\u521d\u3067\u306f\u30ef\u30fc\u30c9(4byte)\u30a2\u30e9\u30a4\u30e1\u30f3\u30c8\u306e\u307f\u304c\u8981\u8acb\u3055\u308c\u3066\u3044\u305f\u3002\n2. MMX, SSE\u306a\u3069\u306eSIMD\u547d\u4ee4\u767b\u5834\u306b\u3088\u308a\u3001\u30b9\u30bf\u30c3\u30af\u5909\u6570\u3067\u308216byte\u30a2\u30e9\u30a4\u30e1\u30f3\u30c8\u304c\u8981\u8acb\u3055\u308c\u308b\u30b1\u30fc\u30b9\u304c\u767a\u751f\u3002\u307e\u305f\u30a2\u30e9\u30a4\u30e1\u30f3\u30c8\u5fc5\u9808\u3067\u306a\u3044\u547d\u4ee4\u3067\u3042\u3063\u3066\u3082\u30d1\u30d5\u30a9\u30fc\u30de\u30f3\u30b9\u7684\u306b\u306f16byte\u30a2\u30e9\u30a4\u30e1\u30f3\u30c8\u304c\u597d\u307e\u3057\u3044\u3002\n3. Mac OS X i386 ABI\u3067\u306f16byte\u30a2\u30e9\u30a4\u30e1\u30f3\u30c8\u3092\u660e\u78ba\u306b\u8981\u8acb\u3002\n4. GCC\u3067\u30b5\u30dd\u30fc\u30c8\u3059\u308bLinux/BSD/OSX\u9593\u306e\u4e00\u8cab\u6027\u306e\u89b3\u70b9\u304b\u308916byte\u30a2\u30e9\u30a4\u30e1\u30f3\u30c8\u3092\u63a1\u7528\u3002\n5. [\u65b0\u3057\u3044SysV psABI](https://github.com/hjl-tools/x86-psABI)\u3067\u306f16byte\u30a2\u30e9\u30a4\u30e1\u30f3\u30c8\u306b\u5909\u66f4\u3002\n\n# GCC Bugzilla\n- [#27537 XMM alignment fault when compiling for i386 with -Os ](https://gcc.gnu.org/bugzilla/show_bug.cgi?id=27537#c11)\n- [#38496 Gcc misaligns arrays when stack is forced follow the x8632 ABI](https://gcc.gnu.org/bugzilla/show_bug.cgi?id=38496#c14)\n- [#40838 gcc shouldn't assume that the stack is aligned ](https://gcc.gnu.org/bugzilla/show_bug.cgi?id=40838#c86)\n\n\n# ABI\u4ed5\u69d8\n## x86-64\n[System V Application Binary Interface, AMD64 Architecture Processor Supplement, Draft Version 0.99.6](http://www.x86-64.org/documentation/abi.pdf)\uff1a\n> 3.2.2 The Stack Frame\n> In addition to registers, each function has a frame on the run-time stack. This stack grows downwards from high addresses. Figure 3.3 shows the stack organization. The end of the input argument area shall be aligned on a 16 (32, if `__m256` is passed on stack) byte boundary.  In other words, the value `(%rsp + 8)` is always a multiple of 16 (32) when control is transferred to the function entry point.  The stack pointer, `%rsp`, always points to the end of the latest allocated stack frame.\n\n## i386\n[SYSTEM V APPLICATION BINARY INTERFACE, Intel386 Architecture Processor Supplement](http://refspecs.linuxbase.org/elf/abi386-4.pdf)\uff1a\n> Registers and the Stack Frame\n> Some registers have assigned roles in the standard calling sequence:\n> `%esp`: The _stack pointer_ holds the limit of the current stack frame, which is the address of the stack\u2019s bottom-most, valid word.  **At all times, the stack pointer should point to a word-aligned area.**\n\n[OS X ABI Function Call Guide, IA-32 Function Calling Conventions](https://developer.apple.com/library/mac/documentation/DeveloperTools/Conceptual/LowLevelABI/130-IA-32_Function_Calling_Conventions/IA32.html)\uff1a\n> The function calling conventions used in the IA-32 environment are **the same as those used in the System V IA-32 ABI, with the following exceptions**:\n>\n> - **The stack is 16-byte aligned at the point of function calls**\n\n[System V Application Binary Interface, Intel386 Architecture Processor Supplement, Version 1.1](https://github.com/hjl-tools/x86-psABI/wiki/intel386-psABI-1.1.pdf)\uff1a\n> 2.2.2 The Stack Frame\n> In addition to registers, each function has a frame on the run-time stack. This stack grows downwards from high addresses. Table 2.2 shows the stack organization.\n> **The end of the input argument area shall be aligned on a 16 (32 or 64, if `__m256` or `__m512` is passed on stack) byte boundary.** In other words, the value `(%esp + 4)` is always a multiple of 16 (32 or 64) when control is transferred to the function entry point. The stack pointer, `%esp`, always points to the end of the latest allocated stack frame. \n", "tags": ["GCC", "Linux", "x86"]}