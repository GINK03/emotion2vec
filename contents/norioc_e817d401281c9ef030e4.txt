{"tags": ["Ruby-Processing", "processing"], "context": " More than 1 year has passed since last update.\u8996\u754c\u5185\u306e\u5186\u306b\u8272\u3065\u3051\u3059\u308b\u30b5\u30f3\u30d7\u30eb\u3067\u3059\u3002\n\u8996\u754c\u5185\u306b\u3042\u308b\u5186\u306e\u3046\u3061\u3001\u53f3\u5074\u306e\u5186\u306b\u306f\u8d64\u304f\u3001\u5de6\u5074\u306e\u5186\u306b\u306f\u7dd1\u306b\u8272\u3065\u3051\u3057\u3066\u3044\u307e\u3059\u3002\n\n\nangle-of-view.rb\nload_library :vecmath\n\n# Y \u8ef8\u4e0a\u65b9\u5411\u304c\u6b63\u3068\u3057\u3066\u8a08\u7b97\u3057\u3066\u3044\u307e\u3059\u3002\n# (\u63cf\u753b\u6642\u306b\u306f y \u5ea7\u6a19\u306e\u7b26\u53f7\u3092\u5224\u5b9a\u3057\u3066\u3044\u307e\u3059)\n\ndef setup\n  size 400, 400\n\n  n = 100 # \u70b9\u306e\u500b\u6570\n  @vecs = (1..n).map { Vec2D.new(rand(width)-width/2, rand(height)-height/2) }\nend\n\n# \u4e8c\u3064\u306e\u30d9\u30af\u30c8\u30eb\u306e\u306a\u3059\u89d2\u3092\u6c42\u3081\u308b\ndef calc_angle(a, b)\n  cos_theta = a.dot(b) / (a.mag * b.mag)\n  Math::acos(max(0, min(1, cos_theta)))\nend\n\ndef draw\n  background 255\n  translate width/2, height/2 # \u539f\u70b9\u3092\u753b\u9762\u4e2d\u592e\u306b\u3059\u308b\n\n  m = Vec2D.new(mouse_x - width/2, -(mouse_y - height/2))# \u30de\u30a6\u30b9\u4f4d\u7f6e\n\n  angle_of_view = 30 # \u8996\u91ce\u89d2\n  left  = m.rotate(-angle_of_view.radians)\n  right = m.rotate( angle_of_view.radians)\n\n  # \u30a6\u30a3\u30f3\u30c9\u30a6\u5916\u307e\u3067\u30d9\u30af\u30c8\u30eb\u3092\u4f38\u3070\u3059\n  m *= 100; left *= 100; right *= 100\n\n  line(0, 0, m.x, -m.y)\n  line(0, 0, left.x, -left.y)\n  line(0, 0, right.x, -right.y)\n\n  @vecs.each {|v|\n    # \u30d9\u30af\u30c8\u30eb\u306e\u5185\u7a4d\u3092\u8a08\u7b97\u3057\u3066\u3001angle_of_view \u4ee5\u4e0b\u304b\u8abf\u3079\u308b\n    if calc_angle(m, v) <= angle_of_view.radians\n      # \u30de\u30a6\u30b9\u4f4d\u7f6e\u306e\u30d9\u30af\u30c8\u30eb\u306b\u5bfe\u3057\u3066 v \u30d9\u30af\u30c8\u30eb\u304c\u5de6\u53f3\u3069\u3061\u3089\u306e\u65b9\u5411\u304b\u8abf\u3079\u308b\n      sign = m.cross(v)\n      if sign < 0 # m \u306e\u53f3\u5074\n        fill 255, 0, 0\n      else # m \u306e\u5de6\u5074\n        fill 0, 255, 0\n      end\n    else\n      no_fill\n    end\n    ellipse(v.x, -v.y, 8, 8)\n  }\nend\n\n\n\u30b3\u30de\u30f3\u30c9\u30e9\u30a4\u30f3\u304b\u3089\u6b21\u306e\u3088\u3046\u306b\u5b9f\u884c\u3057\u307e\u3059\u3002\n$ rp5 run angle-of-view.rb\n\n\n\u8996\u754c\u5185\u306e\u5186\u306b\u8272\u3065\u3051\u3059\u308b\u30b5\u30f3\u30d7\u30eb\u3067\u3059\u3002\n\u8996\u754c\u5185\u306b\u3042\u308b\u5186\u306e\u3046\u3061\u3001\u53f3\u5074\u306e\u5186\u306b\u306f\u8d64\u304f\u3001\u5de6\u5074\u306e\u5186\u306b\u306f\u7dd1\u306b\u8272\u3065\u3051\u3057\u3066\u3044\u307e\u3059\u3002\n\n![angle-of-view.gif](https://qiita-image-store.s3.amazonaws.com/0/1900/7951c192-4c51-2650-b9a6-033ef7899eed.gif \"angle-of-view.gif\")\n\n\n```ruby:angle-of-view.rb\nload_library :vecmath\n\n# Y \u8ef8\u4e0a\u65b9\u5411\u304c\u6b63\u3068\u3057\u3066\u8a08\u7b97\u3057\u3066\u3044\u307e\u3059\u3002\n# (\u63cf\u753b\u6642\u306b\u306f y \u5ea7\u6a19\u306e\u7b26\u53f7\u3092\u5224\u5b9a\u3057\u3066\u3044\u307e\u3059)\n\ndef setup\n  size 400, 400\n\n  n = 100 # \u70b9\u306e\u500b\u6570\n  @vecs = (1..n).map { Vec2D.new(rand(width)-width/2, rand(height)-height/2) }\nend\n\n# \u4e8c\u3064\u306e\u30d9\u30af\u30c8\u30eb\u306e\u306a\u3059\u89d2\u3092\u6c42\u3081\u308b\ndef calc_angle(a, b)\n  cos_theta = a.dot(b) / (a.mag * b.mag)\n  Math::acos(max(0, min(1, cos_theta)))\nend\n\ndef draw\n  background 255\n  translate width/2, height/2 # \u539f\u70b9\u3092\u753b\u9762\u4e2d\u592e\u306b\u3059\u308b\n\n  m = Vec2D.new(mouse_x - width/2, -(mouse_y - height/2))# \u30de\u30a6\u30b9\u4f4d\u7f6e\n\n  angle_of_view = 30 # \u8996\u91ce\u89d2\n  left  = m.rotate(-angle_of_view.radians)\n  right = m.rotate( angle_of_view.radians)\n\n  # \u30a6\u30a3\u30f3\u30c9\u30a6\u5916\u307e\u3067\u30d9\u30af\u30c8\u30eb\u3092\u4f38\u3070\u3059\n  m *= 100; left *= 100; right *= 100\n\n  line(0, 0, m.x, -m.y)\n  line(0, 0, left.x, -left.y)\n  line(0, 0, right.x, -right.y)\n\n  @vecs.each {|v|\n    # \u30d9\u30af\u30c8\u30eb\u306e\u5185\u7a4d\u3092\u8a08\u7b97\u3057\u3066\u3001angle_of_view \u4ee5\u4e0b\u304b\u8abf\u3079\u308b\n    if calc_angle(m, v) <= angle_of_view.radians\n      # \u30de\u30a6\u30b9\u4f4d\u7f6e\u306e\u30d9\u30af\u30c8\u30eb\u306b\u5bfe\u3057\u3066 v \u30d9\u30af\u30c8\u30eb\u304c\u5de6\u53f3\u3069\u3061\u3089\u306e\u65b9\u5411\u304b\u8abf\u3079\u308b\n      sign = m.cross(v)\n      if sign < 0 # m \u306e\u53f3\u5074\n        fill 255, 0, 0\n      else # m \u306e\u5de6\u5074\n        fill 0, 255, 0\n      end\n    else\n      no_fill\n    end\n    ellipse(v.x, -v.y, 8, 8)\n  }\nend\n```\n\n\u30b3\u30de\u30f3\u30c9\u30e9\u30a4\u30f3\u304b\u3089\u6b21\u306e\u3088\u3046\u306b\u5b9f\u884c\u3057\u307e\u3059\u3002\n\n```\n$ rp5 run angle-of-view.rb\n```\n\n\n"}