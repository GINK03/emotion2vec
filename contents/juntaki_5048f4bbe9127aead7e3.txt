{"context": "\u8a73\u89e3Linux\u30ab\u30fc\u30cd\u30eb\u306e5\u7ae0\u30ab\u30fc\u30cd\u30eb\u306e\u540c\u671f\u51e6\u7406\u306b\u95a2\u9023\u3059\u308b\u3001Linux\u306e\u30ed\u30c3\u30af\u306b\u3064\u3044\u3066\u8abf\u3079\u305f\u3002\n\u30ed\u30c3\u30af\u306f\u5171\u901a\u95a2\u6570\u304c\u591a\u305d\u3046\u306a\u306e\u3067\u3001\u305d\u308c\u3089\u306e\u4ed5\u7d44\u307f\u304b\u3089\u8abf\u3079\u3066\u307f\u308b\u3002\n\n\u30ab\u30fc\u30cd\u30eb\u30d0\u30fc\u30b8\u30e7\u30f3\nv4.4\n\nlock_acquire\nlockdep.h\u306b\u5b9f\u88c5\u3055\u308c\u3066\u3044\u308b\u30de\u30af\u30ed\u304b\u3089\u3001lock_acquire()\u306fspinlock, rwlock(\u8aad\u307f\u66f8\u304d\u7528spinlock), \u30b7\u30fc\u30af\u30a8\u30f3\u30b9\u30ed\u30c3\u30af, mutex, \u8aad\u307f\u66f8\u304d\u7528semaphore\u3067\u5229\u7528\u3055\u308c\u3066\u3044\u308b\u3089\u3057\u3044\u3002\n\u3053\u308c\u306flockdep-design\u306e\u30ab\u30fc\u30cd\u30eb\u30c9\u30ad\u30e5\u30e1\u30f3\u30c8\u306b\u3082\u3042\u308b\u3088\u3046\u306b\u3001\u30ed\u30c3\u30af\u304c\u6b63\u3057\u3044\u3053\u3068\u3092\u691c\u8a3c\u3059\u308b\u305f\u3081\u306e\u30c7\u30d0\u30c3\u30b0\u306e\u305f\u3081\u306e\u95a2\u6570\u3067\u3042\u308b\u3002\n#define lock_acquire_exclusive(l, s, t, n, i)       lock_acquire(l, s, t, 0, 1, n, i)\n#define lock_acquire_shared(l, s, t, n, i)      lock_acquire(l, s, t, 1, 1, n, i)\n#define lock_acquire_shared_recursive(l, s, t, n, i)    lock_acquire(l, s, t, 2, 1, n, i)\n\n\nLOCK_CONTENDED\u30de\u30af\u30ed\nlock_acquire()\u306e\u3042\u3068\u306b\u547c\u3070\u308c\u3066\u3044\u308b\u30de\u30af\u30ed\u3067\u3001(\u5c11\u306a\u304f\u3068\u3082)\u30b9\u30d4\u30f3\u30ed\u30c3\u30af\u3068\u8aad\u307f\u66f8\u304d\u7528\u30bb\u30de\u30d5\u30a9\u3067\u4f7f\u308f\u308c\u3066\u3044\u308b\u3088\u3046\u3060\u3002\ntry()\u306f\u53d6\u5f97\u3067\u304d\u306a\u3044\u3068\u30a8\u30e9\u30fc\u7d42\u4e86\u3059\u308b\u30ed\u30c3\u30af\u53d6\u5f97\u95a2\u6570\u3001lock()\u306f\u4f55\u3089\u304b\u306e\u65b9\u6cd5\u3067\u30ed\u30c3\u30af\u53d6\u5f97\u3092\u5f85\u3064\u3068\u3044\u3046\u9055\u3044\u304c\u3042\u308b\u3068\u601d\u308f\u308c\u308b\u3002\u3064\u307e\u308alockdep\u306e\u30dd\u30ea\u30b7\u30fc\u306b\u5f93\u3046\u3068\u3001\u6b21\u306e\u30ed\u30c3\u30af\u53d6\u5f97\u306e\u30d5\u30ed\u30fc\u304c\u3042\u308b\u3002\uff08\u53c2\u8003\uff1aLKML\uff09\n\u30ed\u30c3\u30af\u7af6\u5408\u304c\u3042\u308b\u5834\u5408\nlock_acquire() -> *(try)()[\u5931\u6557] -> lock_contended() -> *(lock)() -> lock_acquired()\n\u30ed\u30c3\u30af\u7af6\u5408\u304c\u306a\u3044\u5834\u5408\nlock_acquire() -> *(try)() -> lock_acquired()\n\n\u30bd\u30fc\u30b9\u30b3\u30fc\u30c9\u306f\u6b21\u306e\u3088\u3046\u306b\u306a\u3063\u3066\u3044\u308b\u3002\u3064\u307e\u308a\u3001\u4e0a\u4f4d\u304b\u3089\u95a2\u6570\u30dd\u30a4\u30f3\u30bf\u3068\u3057\u3066\u6e21\u3055\u308c\u308block\u304c\u305d\u308c\u305e\u308c\u306e\u30ed\u30c3\u30af\u306e\u9055\u3044\u304c\u4e00\u756a\u73fe\u308c\u308b\u3068\u3053\u308d\u304b\u306a\u3002\nextern void lock_contended(struct lockdep_map *lock, unsigned long ip);\nextern void lock_acquired(struct lockdep_map *lock, unsigned long ip);\n\n#define LOCK_CONTENDED(_lock, try, lock)            \\\ndo {                                \\\n    if (!try(_lock)) {                  \\\n        lock_contended(&(_lock)->dep_map, _RET_IP_);    \\\n        lock(_lock);                    \\\n    }                           \\\n    lock_acquired(&(_lock)->dep_map, _RET_IP_);         \\\n} while (0)\n\n\nspinlock\u306e\u5b9f\u88c5\nlock\u306farch_spin_lock()\u3092\u6e21\u3059\u3002\u4e0b\u8a18\u306fx86\u306e\u30b3\u30fc\u30c9\u3067\u3042\u308b\u3002\u30b9\u30d4\u30f3\u30ed\u30c3\u30af\u306a\u306e\u3067\u3001for(;;)\u3067\u5f85\u3064\u3068\u3053\u308d\u304c\u30e1\u30a4\u30f3\u306e\u51e6\u7406\u3060\u308d\u3046\u3068\u601d\u3046\u3002\n\u30eb\u30fc\u30d7\u3092\u629c\u3051\u308b\u6761\u4ef6\u306f__tickets_equal(inc.head, inc.tail)\u3067\u3001\u81ea\u5206\u306e\u756a\u53f7tail == lock.head\u3068\u306a\u3063\u305f\u6642\u306b\u3001\u30ed\u30c3\u30af\u304c\u53d6\u308c\u305f\u3053\u3068\u306b\u306a\u308b\u3002\nstatic __always_inline void arch_spin_lock(arch_spinlock_t *lock)\n{\n    register struct __raw_tickets inc = { .tail = TICKET_LOCK_INC };\n\n    inc = xadd(&lock->tickets, inc);\u3000\u3053\u3053\u3067tail\u306b\u52a0\u7b97\u3001\u623b\u308a\u5024\u306f\u5143\u306e\u5024\n    if (likely(inc.head == inc.tail))\n        goto out;\n\n    for (;;) {\n        unsigned count = SPIN_THRESHOLD;\n\n        do {\n            inc.head = READ_ONCE(lock->tickets.head);\n            if (__tickets_equal(inc.head, inc.tail))\u3000\u5143\u306etail\u3068\u3001\u4eca\u306ehead\u304c\u4e00\u81f4\n                goto clear_slowpath;\n            cpu_relax();\n        } while (--count);\n        __ticket_lock_spinning(lock, inc.tail);\n    }\nclear_slowpath:\n    __ticket_check_and_clear_slowpath(lock, inc.head);\nout:\n    barrier();  /* make sure nothing creeps before the lock is taken */\n}\n\n\u8a73\u89e3Linux\u30ab\u30fc\u30cd\u30eb\u306e5\u7ae0\u30ab\u30fc\u30cd\u30eb\u306e\u540c\u671f\u51e6\u7406\u306b\u95a2\u9023\u3059\u308b\u3001Linux\u306e\u30ed\u30c3\u30af\u306b\u3064\u3044\u3066\u8abf\u3079\u305f\u3002\n\u30ed\u30c3\u30af\u306f\u5171\u901a\u95a2\u6570\u304c\u591a\u305d\u3046\u306a\u306e\u3067\u3001\u305d\u308c\u3089\u306e\u4ed5\u7d44\u307f\u304b\u3089\u8abf\u3079\u3066\u307f\u308b\u3002\n\n## \u30ab\u30fc\u30cd\u30eb\u30d0\u30fc\u30b8\u30e7\u30f3\n\nv4.4\n\n## lock_acquire\n\nlockdep.h\u306b\u5b9f\u88c5\u3055\u308c\u3066\u3044\u308b\u30de\u30af\u30ed\u304b\u3089\u3001`lock_acquire()`\u306fspinlock, rwlock(\u8aad\u307f\u66f8\u304d\u7528spinlock), \u30b7\u30fc\u30af\u30a8\u30f3\u30b9\u30ed\u30c3\u30af, mutex, \u8aad\u307f\u66f8\u304d\u7528semaphore\u3067\u5229\u7528\u3055\u308c\u3066\u3044\u308b\u3089\u3057\u3044\u3002\n\u3053\u308c\u306f[lockdep-design](https://www.kernel.org/doc/Documentation/locking/lockdep-design.txt)\u306e\u30ab\u30fc\u30cd\u30eb\u30c9\u30ad\u30e5\u30e1\u30f3\u30c8\u306b\u3082\u3042\u308b\u3088\u3046\u306b\u3001\u30ed\u30c3\u30af\u304c\u6b63\u3057\u3044\u3053\u3068\u3092\u691c\u8a3c\u3059\u308b\u305f\u3081\u306e\u30c7\u30d0\u30c3\u30b0\u306e\u305f\u3081\u306e\u95a2\u6570\u3067\u3042\u308b\u3002\n\n~~~c\n#define lock_acquire_exclusive(l, s, t, n, i)\t\tlock_acquire(l, s, t, 0, 1, n, i)\n#define lock_acquire_shared(l, s, t, n, i)\t\tlock_acquire(l, s, t, 1, 1, n, i)\n#define lock_acquire_shared_recursive(l, s, t, n, i)\tlock_acquire(l, s, t, 2, 1, n, i)\n~~~\n\n## LOCK_CONTENDED\u30de\u30af\u30ed\n\n`lock_acquire()`\u306e\u3042\u3068\u306b\u547c\u3070\u308c\u3066\u3044\u308b\u30de\u30af\u30ed\u3067\u3001(\u5c11\u306a\u304f\u3068\u3082)\u30b9\u30d4\u30f3\u30ed\u30c3\u30af\u3068\u8aad\u307f\u66f8\u304d\u7528\u30bb\u30de\u30d5\u30a9\u3067\u4f7f\u308f\u308c\u3066\u3044\u308b\u3088\u3046\u3060\u3002\n`try()`\u306f\u53d6\u5f97\u3067\u304d\u306a\u3044\u3068\u30a8\u30e9\u30fc\u7d42\u4e86\u3059\u308b\u30ed\u30c3\u30af\u53d6\u5f97\u95a2\u6570\u3001`lock()`\u306f\u4f55\u3089\u304b\u306e\u65b9\u6cd5\u3067\u30ed\u30c3\u30af\u53d6\u5f97\u3092\u5f85\u3064\u3068\u3044\u3046\u9055\u3044\u304c\u3042\u308b\u3068\u601d\u308f\u308c\u308b\u3002\u3064\u307e\u308alockdep\u306e\u30dd\u30ea\u30b7\u30fc\u306b\u5f93\u3046\u3068\u3001\u6b21\u306e\u30ed\u30c3\u30af\u53d6\u5f97\u306e\u30d5\u30ed\u30fc\u304c\u3042\u308b\u3002\uff08\u53c2\u8003\uff1a[LKML](https://lkml.org/lkml/2010/3/2/143)\uff09\n\n~~~\n\u30ed\u30c3\u30af\u7af6\u5408\u304c\u3042\u308b\u5834\u5408\nlock_acquire() -> *(try)()[\u5931\u6557] -> lock_contended() -> *(lock)() -> lock_acquired()\n\u30ed\u30c3\u30af\u7af6\u5408\u304c\u306a\u3044\u5834\u5408\nlock_acquire() -> *(try)() -> lock_acquired()\n~~~\n\n\u30bd\u30fc\u30b9\u30b3\u30fc\u30c9\u306f\u6b21\u306e\u3088\u3046\u306b\u306a\u3063\u3066\u3044\u308b\u3002\u3064\u307e\u308a\u3001\u4e0a\u4f4d\u304b\u3089\u95a2\u6570\u30dd\u30a4\u30f3\u30bf\u3068\u3057\u3066\u6e21\u3055\u308c\u308block\u304c\u305d\u308c\u305e\u308c\u306e\u30ed\u30c3\u30af\u306e\u9055\u3044\u304c\u4e00\u756a\u73fe\u308c\u308b\u3068\u3053\u308d\u304b\u306a\u3002\n\n~~~c\nextern void lock_contended(struct lockdep_map *lock, unsigned long ip);\nextern void lock_acquired(struct lockdep_map *lock, unsigned long ip);\n\n#define LOCK_CONTENDED(_lock, try, lock)\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\\\n\tif (!try(_lock)) {\t\t\t\t\t\\\n\t\tlock_contended(&(_lock)->dep_map, _RET_IP_);\t\\\n\t\tlock(_lock);\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\\\n\tlock_acquired(&(_lock)->dep_map, _RET_IP_);\t\t\t\\\n} while (0)\n~~~\n\n## spinlock\u306e\u5b9f\u88c5\n\nlock\u306f`arch_spin_lock()`\u3092\u6e21\u3059\u3002\u4e0b\u8a18\u306fx86\u306e\u30b3\u30fc\u30c9\u3067\u3042\u308b\u3002\u30b9\u30d4\u30f3\u30ed\u30c3\u30af\u306a\u306e\u3067\u3001`for(;;)`\u3067\u5f85\u3064\u3068\u3053\u308d\u304c\u30e1\u30a4\u30f3\u306e\u51e6\u7406\u3060\u308d\u3046\u3068\u601d\u3046\u3002\n\u30eb\u30fc\u30d7\u3092\u629c\u3051\u308b\u6761\u4ef6\u306f`__tickets_equal(inc.head, inc.tail)`\u3067\u3001`\u81ea\u5206\u306e\u756a\u53f7tail == lock.head`\u3068\u306a\u3063\u305f\u6642\u306b\u3001\u30ed\u30c3\u30af\u304c\u53d6\u308c\u305f\u3053\u3068\u306b\u306a\u308b\u3002\n\n~~~c\nstatic __always_inline void arch_spin_lock(arch_spinlock_t *lock)\n{\n\tregister struct __raw_tickets inc = { .tail = TICKET_LOCK_INC };\n\n\tinc = xadd(&lock->tickets, inc);\u3000\u3053\u3053\u3067tail\u306b\u52a0\u7b97\u3001\u623b\u308a\u5024\u306f\u5143\u306e\u5024\n\tif (likely(inc.head == inc.tail))\n\t\tgoto out;\n\n\tfor (;;) {\n\t\tunsigned count = SPIN_THRESHOLD;\n\n\t\tdo {\n\t\t\tinc.head = READ_ONCE(lock->tickets.head);\n\t\t\tif (__tickets_equal(inc.head, inc.tail))\u3000\u5143\u306etail\u3068\u3001\u4eca\u306ehead\u304c\u4e00\u81f4\n\t\t\t\tgoto clear_slowpath;\n\t\t\tcpu_relax();\n\t\t} while (--count);\n\t\t__ticket_lock_spinning(lock, inc.tail);\n\t}\nclear_slowpath:\n\t__ticket_check_and_clear_slowpath(lock, inc.head);\nout:\n\tbarrier();\t/* make sure nothing creeps before the lock is taken */\n}\n~~~\n", "tags": ["Linux", "kernel"]}