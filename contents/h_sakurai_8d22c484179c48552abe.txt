{"context": " More than 1 year has passed since last update.\n\nRust\u3067\u7c21\u5358\u306aLLVM\u30b3\u30f3\u30d1\u30a4\u30e9\nRust\u3092\u4f7f\u3063\u3066LLVM\u306a\u30b3\u30f3\u30d1\u30a4\u30e9\u3092\u66f8\u3044\u3066\u307f\u307e\u3057\u305f\u3002Haskell\u306e\u578b\u30b7\u30b9\u30c6\u30e0\u304c\u5206\u304b\u308a\u3084\u3059\u304f\u53d6\u308a\u8fbc\u3093\u3067\u3042\u3063\u3066\u3088\u3044\u3067\u3059\u3002\u30e1\u30e2\u30ea\u7ba1\u7406\u304c\u3081\u3093\u3069\u304f\u3055\u3044\u306e\u3067\u3059\u304c\u3001\u30b3\u30f3\u30d1\u30a4\u30e9\u306b\u6012\u3089\u308c\u306a\u304c\u3089\u3001\u6012\u3089\u308c\u306a\u304f\u306a\u308b\u307e\u3067\u9811\u5f35\u308c\u3070\u3001\u3060\u3044\u305f\u3044\u3061\u3083\u3093\u3068\u52d5\u304f\u3088\u3046\u3067\u3059\u3002\nC\u8a00\u8a9e\u306e\u5c64\u3067\u3001\u30ea\u30d5\u30a1\u30ec\u30f3\u30b9\u30ab\u30a6\u30f3\u30bf\u65b9\u5f0f\u306e\u30e1\u30e2\u30ea\u7ba1\u7406\u3092\u3057\u306a\u304c\u3089\u3001\u5b89\u5168\u306a\u30d7\u30ed\u30b0\u30e9\u30e0\u3092\u66f8\u304f\u4e8b\u304c\u51fa\u6765\u307e\u3059\u3002\u30aa\u30d6\u30b8\u30a7\u30af\u30c8\u6307\u5411\u3067\u306f\u306a\u3044\u3051\u3069\u3001\u30b3\u30f3\u30d1\u30a4\u30e9\u66f8\u304f\u306e\u306b\u5143\u3005\u30aa\u30d6\u30b8\u30a7\u30af\u30c8\u6307\u5411\u306f\u306a\u304f\u3066\u3082\u66f8\u304f\u6280\u6cd5\u306f\u78ba\u7acb\u3057\u3066\u3044\u308b\u306e\u3067\u3001\u30b5\u30af\u30b5\u30af\u66f8\u3051\u307e\u3059\u3002\u6b63\u898f\u8868\u73fe\u30e9\u30a4\u30d6\u30e9\u30ea\u304c\u6a19\u6e96\u3067\u306f\u306a\u3044\u306e\u3067\u3001\u304a\u624b\u8efd\u306b\u30d1\u30fc\u30b5\u3092\u66f8\u304f\u4e8b\u306f\u51fa\u6765\u306a\u3044\u304b\u3082\u3057\u308c\u307e\u305b\u3093\u3051\u3069\u3002\nRust\u306f\u4ed5\u69d8\u304c\u30b4\u30ea\u30b4\u30ea\u66f8\u304d\u63db\u3048\u3089\u308c\u3066\u3044\u308b\u3089\u3057\u3044\u306e\u3067\u3059\u304c\u3001\u73fe\u72b6\u3069\u306e\u7a0b\u5ea6\u5909\u308f\u3063\u3066\u3044\u308b\u304b\u306f\u5206\u304b\u308a\u307e\u305b\u3093\u3002\nRust\u3067\u4e00\u756a\u60a9\u3080\u6240\u306f\u3001\u304a\u305d\u3089\u304f\u3001&\u304b\u3089~\u3078\u306e\u5909\u63db\u3067\u3059\u3002\n~\u306f\u81ea\u5206\u304c\u30aa\u30fc\u30ca\u30fc\u3060\u305c\u3002\u4ffa\u306e\u7269\u3060\u305c\u3002\u3063\u3066\u8a00\u3046\u610f\u5473\u3067\u3001&\u306f\u501f\u308a\u7269\u306a\u306e\u3067\u79c1\u306e\u7269\u3067\u306f\u3042\u308a\u307e\u305b\u3093\u3002\n\u3063\u3066\u3053\u3068\u306a\u306e\u3067\u3059\u304c\u3001\u501f\u308a\u7269\u3067\u3042\u308b&\u304b\u3089\u4ffa\u306e\u7269\u3067\u3042\u308b~\u3078\u5909\u63db\u3057\u305f\u3044\u3051\u3069\u3069\u30fc\u3057\u305f\u3089\u3044\u3044\u3093\u3060\u30fc\uff01\n\u3063\u3066\u56f0\u308a\u307e\u3059\u3002\n\u3053\u306e\u30d7\u30ed\u30b0\u30e9\u30e0\u306fRust 0.7\u3067\u66f8\u304d\u307e\u3057\u305f\u3002\n\u3069\u3046\u3082\u3001copy\u306f\u6d88\u3048\u3066\u884c\u304f\u904b\u547d\u3089\u3057\u304f\u3001clone()\u3084deep_clone()\u3092\u4f7f\u3046\u3088\u3046\u306b\u306a\u3063\u3066\u884c\u304f\u3088\u3046\u3067\u3059\u304c\u3001tuple\u306ecopy\u306f\u307e\u3060\u3069\u3046\u3057\u3066\u3082\u5fc5\u8981\u3063\u307d\u3044\u3067\u3059\u3002\n\nfn main() {\n  use ast::*;\n\n  let ast = ~EBlock(~Tv, ~[\n    ~EPrint(~Ti(32), ~ELdc(~Ti(32), 11)),\n    ~EPrint(~Ti(32),\n      ~EAdd(~Ti(32), ~ELdc(~Ti(32), 11), ~ELdc(~Ti(32), 22)))\n  ]);\n  println(\"ast=\" + ast.to_str());\n\n  let ll = kNormal(ast);\n  println(\"ll=\" + ll.to_str());\n\n  emit(\"e.ll\", ll);\n\n  println(exec(\"llc e.ll -o e.s\").to_str());\n  println(exec(\"llvm-gcc -m64 e.s -o e\").to_str());\n  println(exec(\"./e\").to_str());\n}\n\npub mod ast {\n\n  pub enum E {\n    ELdc(~T, int),\n    EBin(~T, ~str, ~E, ~E),\n    EPrint(~T, ~E),\n    EBlock(~T, ~[~E]),\n  }\n\n  pub fn EAdd(t: ~T, a: ~E, b: ~E) -> E {\n    EBin(t, ~\"add\", a, b)\n  }\n\n  pub fn EMul(t: ~T, a: ~E, b: ~E) -> E {\n    EBin(t, ~\"mul\", a, b)\n  }\n\n  pub enum T {\n    Ti(int),\n    Tv,\n    TFun(~T, ~[~T]),\n  }\n\n  pub enum R {\n    pub RG(~T, ~str),\n    pub RL(~T, ~str),\n    pub RR(~T, ~str),\n    pub RN(~T, ~str),\n  }\n\n  pub enum LL {\n    LLCall(Option<~R>, ~R, ~[~R]),\n    LLBin(Option<~R>, ~str, ~R, ~R),\n  }\n\n  impl ToStr for ~E {\n\n    fn to_str(&self) -> ~str {\n      match *self {\n        ~ELdc(ref t, i) => \"ELdc(\"+t.to_str()+\", \"+i.to_str()+\")\",\n        ~EBin(ref t, ref op, ref a, ref b) =>\n          \"EBin(\"+t.to_str()+\", \"+*op+\", \"+a.to_str()+\", \"+b.to_str()+\")\",\n        ~EPrint(ref t, ref e) =>\n          \"EPrint(\"+t.to_str()+\", \"+e.to_str()+\")\",\n        ~EBlock(ref t, ref ls) =>\n          \"EBlock(\"+t.to_str()+\", \"+ls.to_str()+\")\"\n      }\n    }\n\n  }\n\n  impl ToStr for ~T {\n\n    fn to_str(&self) -> ~str {\n\n      match *self {\n        ~Ti(i) => \"Ti(\"+i.to_str()+\")\",\n        ~Tv => ~\"Tv\",\n        ~TFun(ref t, ref ls) =>\n          \"TFun(\"+t.to_str()+\",\"+ls.to_str()+\")\",\n      }\n    }\n\n  }\n\n  impl ToStr for T {\n\n    fn to_str(&self) -> ~str {\n      let t:~T = ~(copy *self);\n      t.to_str()\n    }\n\n  }\n\n  impl Eq for T {\n\n    pub fn eq(&self, t:&T) -> bool {\n      self.to_str() == t.to_str()\n    }\n\n    pub fn ne(&self, t:&T) -> bool {\n      !(self == t)\n    }\n\n  }\n\n  impl R {\n\n    pub fn t(&self) -> ~T {\n      match *self {\n        RG(ref t, _) => copy *t,\n        RL(ref t, _) => copy *t,\n        RR(ref t, _) => copy *t,\n        RN(ref t, _) => copy *t,\n      }\n    }\n\n  }\n\n  impl ToStr for ~R {\n\n    fn to_str(&self) -> ~str {\n      match *self {\n        ~RG(ref t, ref s) => \"RG(\"+t.to_str()+\",\"+*s+\")\",\n        ~RL(ref t, ref s) => \"RL(\"+t.to_str()+\",\"+*s+\")\",\n        ~RR(ref t, ref s) => \"RR(\"+t.to_str()+\",\"+*s+\")\",\n        ~RN(ref t, ref s) => \"RN(\"+t.to_str()+\",\"+*s+\")\",\n      }\n    }\n\n  }\n\n  impl ToStr for Option<~R> {\n\n    fn to_str(&self) -> ~str {\n      match *self {\n        Some(ref r) => \"Some(\"+r.to_str()+\")\",\n        None => ~\"None\",\n      }\n    }\n\n  }\n\n  impl ToStr for ~LL {\n\n    fn to_str(&self) -> ~str {\n      match *self {\n        ~LLCall(ref id, ref name, ref prms) =>\n          \"LLCall(\"+id.to_str()+\",\"+name.to_str()+\",\"+prms.to_str()+\")\",\n        ~LLBin(ref id, ref op, ref a, ref b) =>\n          \"LLBin(\"+id.to_str()+\",\"+op.to_str()+\",\"+a.to_str()+\",\"+b.to_str()+\")\",\n      }\n    }\n\n  }\n\n\n  pub trait P {\n    fn p(&self) -> ~str;\n  }\n\n  impl P for T {\n    pub fn p(&self) -> ~str {\n      match *self {\n        Ti(ref i) => \"i\" + i.to_str(),\n        Tv => ~\"void\",\n        TFun(ref t, ref ls) => {\n          let mut str = ~\"\";\n          for ls.iter().advance |t| {\n            match str {\n              ~\"\" => {str = \"\"+ t.p();}\n              _ => {str = str + \", \" + t.p();}\n            }\n          }\n          t.p() + \"(\" + str + \")*\"\n        }\n      }\n    }\n\n  }\n\n  impl P for R {\n    pub fn p(&self) -> ~str {\n      match *self {\n        RG(_,ref id) => \"@\" + *id,\n        RL(_,ref id) => \"%\" + *id,\n        RR(_,ref id) => \"%.\" + *id,\n        RN(_,ref id) => \"\" + *id,\n      }\n    }\n\n  }\n\n}\n\nmod interpreter {\n  use ast::*;\n\n  fn eval(e:&E)->int {\n\n    match e {\n\n      &ELdc(_, i) => i,\n\n      &EBin(_, ~\"add\", ref a, ref b) => eval(*a) + eval(*b),\n\n      &EBin(_, ref op, _, _) => fail!(\"operator \"+*op),\n\n      &EPrint(_, ref e) => {\n        let e = eval(*e);\n        println(e.to_str());\n        e\n      }\n\n      &EBlock(_, ref ls) => {\n        fn f(ls:&[~E],r:int)-> int {\n          match ls {\n            [] => r,\n            [ref a, ..rest] => f(rest,eval(*a))\n          }\n        }\n        f(*ls, 0)\n      }\n    }\n  }\n}\n\nmod kNormal {\n  use ast::*;\n  use std::vec;\n\n  fn gid(t:~T)-> ~R {\n    ~RR(t,~\"\")\n  }\n\n  static mut ls:Option<~[~LL]> = None;\n\n  fn add(l:~LL) {\n    unsafe {\n      ls = Some(vec::append_one(ls.unwrap(), l));\n    }\n  }\n\n  fn f(a: &E)-> ~R {\n\n    match a {\n\n      &EBin(ref t,ref op, ref a1, ref b1) => {\n        let a = f(*a1);\n        let b = f(*b1);\n        let id = gid(copy *t);\n        if (*t != a.t() || *t != b.t()) {fail!(\"type mismatch \" + t.to_str());}\n        add(~LLBin(Some(copy id), copy *op, a, b));\n        id\n      }\n\n      &ELdc(ref t, ref i) => ~RN(copy *t, i.to_str()),\n\n      &EPrint(ref t, ref a1) => {\n        let a = f(*a1);\n        if (*t != a.t()) {fail!(\"type mismatch t=\" + t.to_str() + \" ta=\" + a.t().to_str())}\n        add(~LLCall(None, ~RG(~TFun(~Tv, ~[copy *t]), \"print_\" + t.p()), ~[copy a]));\n        a\n      }\n\n      &EBlock(_,ref ls) => {\n        fn f2(ls:&[~E],r:&R)-> ~R {\n          match ls {\n            [] => ~(copy *r),\n            [ref e, ..rest] => {\n              f2(rest,f(*e))\n            }\n          }\n        }\n        f2(*ls, ~RN(~Tv,~\"\"))\n      }\n\n    }\n\n  }\n\n  pub fn apply(e: &E) -> ~[~LL] {\n    unsafe {\n      ls = Some(~[]);\n      f(e);\n      ls.unwrap()\n    }\n  }\n\n}\n\nfn kNormal(a: &ast::E) -> ~[~ast::LL] {\n  kNormal::apply(a)\n}\n\npub fn join(ls:&[~str],sep:&str) -> ~str {\n  let mut s:~str = ~\"\";\n  for ls.iter().advance |t| {\n    match s {\n      ~\"\" => {s = \"\"+ (*t);}\n      _ => {s = s + sep + (*t);}\n    }\n  }\n  s\n}\n/*\npub fn join<T:ToStr>(ls:&[~T],sep:&str) -> ~str {\n  let mut s:~str = ~\"\";\n  for ls.iter().advance |t| {\n    match s {\n      ~\"\" => {s = \"\"+ (*t).to_str();}\n      _ => {s = s + sep + (*t).to_str();}\n    }\n  }\n  s\n}\n*/\n\npub mod emit {\n\n  use ast::*;\n  use asm;\n  use join;\n\n  fn o(id: &Option<~R>, out: &str) {\n    match id {\n      &Some(ref id) =>asm::__(id.p() + \" = \" + out),\n      &None => asm::__(out),\n    }\n  }\n\n  fn f(l: &LL) {\n\n    match l {\n      &LLCall(ref id, ref op, ref prms) => {\n        let ps:~[~str] = do prms.map |a|{a.t().p() + \" \" + a.p() };\n        o(id, \"call \" + op.t().p() + \" \" + op.p() + \"(\" + join(ps,\", \") + \") nounwind\")\n      }\n      &LLBin(ref id, ref op, ref a, ref b) => {\n        let id2:Option<~R> = copy *id;\n        o(id, *op + \" \" + id2.unwrap().t().p() + \" \" + a.p() + \", \" + b.p())\n      }\n    }\n  }\n\n  pub fn apply(file: &str, ls: &[~LL]) {\n\n    asm::open(file);\n    asm(\"@.str = private constant [4 x i8] c\\\"%d\\\\0A\\\\00\\\"\");\n    asm(\"define void @print_i32(i32 %a) nounwind ssp {\");\n    asm(\"entry:\");\n    asm::__(\"call i32 (i8*, ...)* @printf(i8* getelementptr inbounds ([4 x i8]* @.str, i64 0, i64 0), i32 %a) nounwind\");\n    asm::__(\"ret void\");\n    asm(\"}\");\n    asm(\"define void @print_i8(i8 %a) nounwind ssp {\");\n    asm(\"entry:\");\n    asm::__(\"call i32 (i8*, ...)* @printf(i8* getelementptr inbounds ([4 x i8]* @.str, i64 0, i64 0), i8 %a) nounwind\");\n    asm::__(\"ret void\");\n    asm(\"}\");\n\n    asm(\"declare i32 @printf(i8*, ...) nounwind\");\n\n    asm(\"define i32 @main() nounwind ssp {\");\n    asm(\"entry:\");\n\n    for ls.iter().advance |l| {\n      f(*l);\n    }\n\n    asm::__(\"ret i32 0\");\n    asm(\"}\");\n    asm::close();\n  }\n\n}\n\npub fn emit(file: &str, ls: &[~ast::LL]) {\n  emit::apply(file, ls);\n}\n\npub fn genid(s:&str) -> ~str {\n  static mut id:int = 0;\n  unsafe {\n    id += 1;\n    s + id.to_str()\n  }\n}\n\nfn readAll(file:&str) -> ~str {\n  use std::io;\n  use std::result;\n  let reader = result::get(&io::file_reader(&Path(file)));\n  let mut s = ~\"\";\n  while !reader.eof() {\n    s = s + reader.read_line() + \"\\n\";\n  }\n  s\n} \n\nfn writeAll(file:&str, s:&str) {\n  use std::io;\n  use std::result;\n  let writer = result::get(&io::buffered_file_writer(&Path(file)));\n  writer.write_str(s);\n}\n\npub mod asm {\n\n  use std::io;\n  use std::result;\n\n  pub static mut writer: Option<@Writer> = None;\n\n  pub fn open(file:&str) {\n    unsafe {\n      writer = Some(result::get(&io::buffered_file_writer(&Path(file))));\n    }\n  }\n\n  pub fn println(s:&str) {\n    unsafe {\n      writer.unwrap().write_str(s + \"\\n\");\n    }\n  }\n\n  pub fn close() {\n    unsafe {\n      writer = None;\n    }\n  }\n\n  pub fn __(s:&str) {\n    println(\"  \" + s);\n  }\n\n}\n\npub fn asm(s:&str) {\n  asm::println(s);\n}\n\npub struct ExecOutput {\n  status: int,\n  output: ~str,\n  error: ~str,\n}\n\nimpl ToStr for ExecOutput {\n  fn to_str(&self) -> ~str {\n    \"(\" + self.status.to_str()+\",\"+self.output+\",\"+self.error+\")\"\n  } \n}\n\nfn exec(cmd:&str) -> ExecOutput {\n\n  use std::str;\n  use std::run;\n\n  let mut cmds:~[&str] = cmd.split_str_iter(\" \").collect();\n  let prog:~str = \"\"+cmds.shift();\n  let args:&[~str] = (do cmds.map |&s| {(s+\"\")});\n  let o = run::process_output(prog,args);\n\n  unsafe {\n    ExecOutput {\n      status : o.status,\n      output : str::raw::from_bytes(o.output),\n      error : str::raw::from_bytes(o.error),\n    }\n  }\n\n}\n\n# Rust\u3067\u7c21\u5358\u306aLLVM\u30b3\u30f3\u30d1\u30a4\u30e9\n\nRust\u3092\u4f7f\u3063\u3066LLVM\u306a\u30b3\u30f3\u30d1\u30a4\u30e9\u3092\u66f8\u3044\u3066\u307f\u307e\u3057\u305f\u3002Haskell\u306e\u578b\u30b7\u30b9\u30c6\u30e0\u304c\u5206\u304b\u308a\u3084\u3059\u304f\u53d6\u308a\u8fbc\u3093\u3067\u3042\u3063\u3066\u3088\u3044\u3067\u3059\u3002\u30e1\u30e2\u30ea\u7ba1\u7406\u304c\u3081\u3093\u3069\u304f\u3055\u3044\u306e\u3067\u3059\u304c\u3001\u30b3\u30f3\u30d1\u30a4\u30e9\u306b\u6012\u3089\u308c\u306a\u304c\u3089\u3001\u6012\u3089\u308c\u306a\u304f\u306a\u308b\u307e\u3067\u9811\u5f35\u308c\u3070\u3001\u3060\u3044\u305f\u3044\u3061\u3083\u3093\u3068\u52d5\u304f\u3088\u3046\u3067\u3059\u3002\n\nC\u8a00\u8a9e\u306e\u5c64\u3067\u3001\u30ea\u30d5\u30a1\u30ec\u30f3\u30b9\u30ab\u30a6\u30f3\u30bf\u65b9\u5f0f\u306e\u30e1\u30e2\u30ea\u7ba1\u7406\u3092\u3057\u306a\u304c\u3089\u3001\u5b89\u5168\u306a\u30d7\u30ed\u30b0\u30e9\u30e0\u3092\u66f8\u304f\u4e8b\u304c\u51fa\u6765\u307e\u3059\u3002\u30aa\u30d6\u30b8\u30a7\u30af\u30c8\u6307\u5411\u3067\u306f\u306a\u3044\u3051\u3069\u3001\u30b3\u30f3\u30d1\u30a4\u30e9\u66f8\u304f\u306e\u306b\u5143\u3005\u30aa\u30d6\u30b8\u30a7\u30af\u30c8\u6307\u5411\u306f\u306a\u304f\u3066\u3082\u66f8\u304f\u6280\u6cd5\u306f\u78ba\u7acb\u3057\u3066\u3044\u308b\u306e\u3067\u3001\u30b5\u30af\u30b5\u30af\u66f8\u3051\u307e\u3059\u3002\u6b63\u898f\u8868\u73fe\u30e9\u30a4\u30d6\u30e9\u30ea\u304c\u6a19\u6e96\u3067\u306f\u306a\u3044\u306e\u3067\u3001\u304a\u624b\u8efd\u306b\u30d1\u30fc\u30b5\u3092\u66f8\u304f\u4e8b\u306f\u51fa\u6765\u306a\u3044\u304b\u3082\u3057\u308c\u307e\u305b\u3093\u3051\u3069\u3002\n\nRust\u306f\u4ed5\u69d8\u304c\u30b4\u30ea\u30b4\u30ea\u66f8\u304d\u63db\u3048\u3089\u308c\u3066\u3044\u308b\u3089\u3057\u3044\u306e\u3067\u3059\u304c\u3001\u73fe\u72b6\u3069\u306e\u7a0b\u5ea6\u5909\u308f\u3063\u3066\u3044\u308b\u304b\u306f\u5206\u304b\u308a\u307e\u305b\u3093\u3002\n\nRust\u3067\u4e00\u756a\u60a9\u3080\u6240\u306f\u3001\u304a\u305d\u3089\u304f\u3001&\u304b\u3089~\u3078\u306e\u5909\u63db\u3067\u3059\u3002\n~\u306f\u81ea\u5206\u304c\u30aa\u30fc\u30ca\u30fc\u3060\u305c\u3002\u4ffa\u306e\u7269\u3060\u305c\u3002\u3063\u3066\u8a00\u3046\u610f\u5473\u3067\u3001&\u306f\u501f\u308a\u7269\u306a\u306e\u3067\u79c1\u306e\u7269\u3067\u306f\u3042\u308a\u307e\u305b\u3093\u3002\n\u3063\u3066\u3053\u3068\u306a\u306e\u3067\u3059\u304c\u3001\u501f\u308a\u7269\u3067\u3042\u308b&\u304b\u3089\u4ffa\u306e\u7269\u3067\u3042\u308b~\u3078\u5909\u63db\u3057\u305f\u3044\u3051\u3069\u3069\u30fc\u3057\u305f\u3089\u3044\u3044\u3093\u3060\u30fc\uff01\n\u3063\u3066\u56f0\u308a\u307e\u3059\u3002\n\n\u3053\u306e\u30d7\u30ed\u30b0\u30e9\u30e0\u306fRust 0.7\u3067\u66f8\u304d\u307e\u3057\u305f\u3002\n\n\u3069\u3046\u3082\u3001copy\u306f\u6d88\u3048\u3066\u884c\u304f\u904b\u547d\u3089\u3057\u304f\u3001clone()\u3084deep_clone()\u3092\u4f7f\u3046\u3088\u3046\u306b\u306a\u3063\u3066\u884c\u304f\u3088\u3046\u3067\u3059\u304c\u3001tuple\u306ecopy\u306f\u307e\u3060\u3069\u3046\u3057\u3066\u3082\u5fc5\u8981\u3063\u307d\u3044\u3067\u3059\u3002\n\n```rust\n\nfn main() {\n  use ast::*;\n\n  let ast = ~EBlock(~Tv, ~[\n    ~EPrint(~Ti(32), ~ELdc(~Ti(32), 11)),\n    ~EPrint(~Ti(32),\n      ~EAdd(~Ti(32), ~ELdc(~Ti(32), 11), ~ELdc(~Ti(32), 22)))\n  ]);\n  println(\"ast=\" + ast.to_str());\n\n  let ll = kNormal(ast);\n  println(\"ll=\" + ll.to_str());\n  \n  emit(\"e.ll\", ll);\n  \n  println(exec(\"llc e.ll -o e.s\").to_str());\n  println(exec(\"llvm-gcc -m64 e.s -o e\").to_str());\n  println(exec(\"./e\").to_str());\n}\n\npub mod ast {\n\n  pub enum E {\n    ELdc(~T, int),\n    EBin(~T, ~str, ~E, ~E),\n    EPrint(~T, ~E),\n    EBlock(~T, ~[~E]),\n  }\n\n  pub fn EAdd(t: ~T, a: ~E, b: ~E) -> E {\n    EBin(t, ~\"add\", a, b)\n  }\n\n  pub fn EMul(t: ~T, a: ~E, b: ~E) -> E {\n    EBin(t, ~\"mul\", a, b)\n  }\n\n  pub enum T {\n    Ti(int),\n    Tv,\n    TFun(~T, ~[~T]),\n  }\n\n  pub enum R {\n    pub RG(~T, ~str),\n    pub RL(~T, ~str),\n    pub RR(~T, ~str),\n    pub RN(~T, ~str),\n  }\n\n  pub enum LL {\n    LLCall(Option<~R>, ~R, ~[~R]),\n    LLBin(Option<~R>, ~str, ~R, ~R),\n  }\n\n  impl ToStr for ~E {\n\n    fn to_str(&self) -> ~str {\n      match *self {\n        ~ELdc(ref t, i) => \"ELdc(\"+t.to_str()+\", \"+i.to_str()+\")\",\n        ~EBin(ref t, ref op, ref a, ref b) =>\n          \"EBin(\"+t.to_str()+\", \"+*op+\", \"+a.to_str()+\", \"+b.to_str()+\")\",\n        ~EPrint(ref t, ref e) =>\n          \"EPrint(\"+t.to_str()+\", \"+e.to_str()+\")\",\n        ~EBlock(ref t, ref ls) =>\n          \"EBlock(\"+t.to_str()+\", \"+ls.to_str()+\")\"\n      }\n    }\n\n  }\n\n  impl ToStr for ~T {\n\n    fn to_str(&self) -> ~str {\n\n      match *self {\n        ~Ti(i) => \"Ti(\"+i.to_str()+\")\",\n        ~Tv => ~\"Tv\",\n        ~TFun(ref t, ref ls) =>\n          \"TFun(\"+t.to_str()+\",\"+ls.to_str()+\")\",\n      }\n    }\n\n  }\n\n  impl ToStr for T {\n\n    fn to_str(&self) -> ~str {\n      let t:~T = ~(copy *self);\n      t.to_str()\n    }\n\n  }\n\n  impl Eq for T {\n\n    pub fn eq(&self, t:&T) -> bool {\n      self.to_str() == t.to_str()\n    }\n\n    pub fn ne(&self, t:&T) -> bool {\n      !(self == t)\n    }\n\n  }\n\n  impl R {\n\n    pub fn t(&self) -> ~T {\n      match *self {\n        RG(ref t, _) => copy *t,\n        RL(ref t, _) => copy *t,\n        RR(ref t, _) => copy *t,\n        RN(ref t, _) => copy *t,\n      }\n    }\n\n  }\n\n  impl ToStr for ~R {\n\n    fn to_str(&self) -> ~str {\n      match *self {\n        ~RG(ref t, ref s) => \"RG(\"+t.to_str()+\",\"+*s+\")\",\n        ~RL(ref t, ref s) => \"RL(\"+t.to_str()+\",\"+*s+\")\",\n        ~RR(ref t, ref s) => \"RR(\"+t.to_str()+\",\"+*s+\")\",\n        ~RN(ref t, ref s) => \"RN(\"+t.to_str()+\",\"+*s+\")\",\n      }\n    }\n\n  }\n\n  impl ToStr for Option<~R> {\n\n    fn to_str(&self) -> ~str {\n      match *self {\n        Some(ref r) => \"Some(\"+r.to_str()+\")\",\n        None => ~\"None\",\n      }\n    }\n\n  }\n\n  impl ToStr for ~LL {\n\n    fn to_str(&self) -> ~str {\n      match *self {\n        ~LLCall(ref id, ref name, ref prms) =>\n          \"LLCall(\"+id.to_str()+\",\"+name.to_str()+\",\"+prms.to_str()+\")\",\n        ~LLBin(ref id, ref op, ref a, ref b) =>\n          \"LLBin(\"+id.to_str()+\",\"+op.to_str()+\",\"+a.to_str()+\",\"+b.to_str()+\")\",\n      }\n    }\n\n  }\n\n\n  pub trait P {\n    fn p(&self) -> ~str;\n  }\n\n  impl P for T {\n    pub fn p(&self) -> ~str {\n      match *self {\n        Ti(ref i) => \"i\" + i.to_str(),\n        Tv => ~\"void\",\n        TFun(ref t, ref ls) => {\n          let mut str = ~\"\";\n          for ls.iter().advance |t| {\n            match str {\n              ~\"\" => {str = \"\"+ t.p();}\n              _ => {str = str + \", \" + t.p();}\n            }\n          }\n          t.p() + \"(\" + str + \")*\"\n        }\n      }\n    }\n\n  }\n\n  impl P for R {\n    pub fn p(&self) -> ~str {\n      match *self {\n        RG(_,ref id) => \"@\" + *id,\n        RL(_,ref id) => \"%\" + *id,\n        RR(_,ref id) => \"%.\" + *id,\n        RN(_,ref id) => \"\" + *id,\n      }\n    }\n\n  }\n\n}\n\nmod interpreter {\n  use ast::*;\n\n  fn eval(e:&E)->int {\n\n    match e {\n\n      &ELdc(_, i) => i,\n\n      &EBin(_, ~\"add\", ref a, ref b) => eval(*a) + eval(*b),\n\n      &EBin(_, ref op, _, _) => fail!(\"operator \"+*op),\n\n      &EPrint(_, ref e) => {\n        let e = eval(*e);\n        println(e.to_str());\n        e\n      }\n\n      &EBlock(_, ref ls) => {\n        fn f(ls:&[~E],r:int)-> int {\n          match ls {\n            [] => r,\n            [ref a, ..rest] => f(rest,eval(*a))\n          }\n        }\n        f(*ls, 0)\n      }\n    }\n  }\n}\n\nmod kNormal {\n  use ast::*;\n  use std::vec;\n\n  fn gid(t:~T)-> ~R {\n    ~RR(t,~\"\")\n  }\n\n  static mut ls:Option<~[~LL]> = None;\n\n  fn add(l:~LL) {\n    unsafe {\n      ls = Some(vec::append_one(ls.unwrap(), l));\n    }\n  }\n\n  fn f(a: &E)-> ~R {\n\n    match a {\n\n      &EBin(ref t,ref op, ref a1, ref b1) => {\n        let a = f(*a1);\n        let b = f(*b1);\n        let id = gid(copy *t);\n        if (*t != a.t() || *t != b.t()) {fail!(\"type mismatch \" + t.to_str());}\n        add(~LLBin(Some(copy id), copy *op, a, b));\n        id\n      }\n\n      &ELdc(ref t, ref i) => ~RN(copy *t, i.to_str()),\n\n      &EPrint(ref t, ref a1) => {\n        let a = f(*a1);\n        if (*t != a.t()) {fail!(\"type mismatch t=\" + t.to_str() + \" ta=\" + a.t().to_str())}\n        add(~LLCall(None, ~RG(~TFun(~Tv, ~[copy *t]), \"print_\" + t.p()), ~[copy a]));\n        a\n      }\n\n      &EBlock(_,ref ls) => {\n        fn f2(ls:&[~E],r:&R)-> ~R {\n          match ls {\n            [] => ~(copy *r),\n            [ref e, ..rest] => {\n              f2(rest,f(*e))\n            }\n          }\n        }\n        f2(*ls, ~RN(~Tv,~\"\"))\n      }\n\n    }\n\n  }\n\n  pub fn apply(e: &E) -> ~[~LL] {\n    unsafe {\n      ls = Some(~[]);\n      f(e);\n      ls.unwrap()\n    }\n  }\n  \n}\n\nfn kNormal(a: &ast::E) -> ~[~ast::LL] {\n  kNormal::apply(a)\n}\n\npub fn join(ls:&[~str],sep:&str) -> ~str {\n  let mut s:~str = ~\"\";\n  for ls.iter().advance |t| {\n    match s {\n      ~\"\" => {s = \"\"+ (*t);}\n      _ => {s = s + sep + (*t);}\n    }\n  }\n  s\n}\n/*\npub fn join<T:ToStr>(ls:&[~T],sep:&str) -> ~str {\n  let mut s:~str = ~\"\";\n  for ls.iter().advance |t| {\n    match s {\n      ~\"\" => {s = \"\"+ (*t).to_str();}\n      _ => {s = s + sep + (*t).to_str();}\n    }\n  }\n  s\n}\n*/\n\npub mod emit {\n\n  use ast::*;\n  use asm;\n  use join;\n\n  fn o(id: &Option<~R>, out: &str) {\n    match id {\n      &Some(ref id) =>asm::__(id.p() + \" = \" + out),\n      &None => asm::__(out),\n    }\n  }\n\n  fn f(l: &LL) {\n\n    match l {\n      &LLCall(ref id, ref op, ref prms) => {\n        let ps:~[~str] = do prms.map |a|{a.t().p() + \" \" + a.p() };\n        o(id, \"call \" + op.t().p() + \" \" + op.p() + \"(\" + join(ps,\", \") + \") nounwind\")\n      }\n      &LLBin(ref id, ref op, ref a, ref b) => {\n        let id2:Option<~R> = copy *id;\n        o(id, *op + \" \" + id2.unwrap().t().p() + \" \" + a.p() + \", \" + b.p())\n      }\n    }\n  }\n\n  pub fn apply(file: &str, ls: &[~LL]) {\n\n    asm::open(file);\n    asm(\"@.str = private constant [4 x i8] c\\\"%d\\\\0A\\\\00\\\"\");\n    asm(\"define void @print_i32(i32 %a) nounwind ssp {\");\n    asm(\"entry:\");\n    asm::__(\"call i32 (i8*, ...)* @printf(i8* getelementptr inbounds ([4 x i8]* @.str, i64 0, i64 0), i32 %a) nounwind\");\n    asm::__(\"ret void\");\n    asm(\"}\");\n    asm(\"define void @print_i8(i8 %a) nounwind ssp {\");\n    asm(\"entry:\");\n    asm::__(\"call i32 (i8*, ...)* @printf(i8* getelementptr inbounds ([4 x i8]* @.str, i64 0, i64 0), i8 %a) nounwind\");\n    asm::__(\"ret void\");\n    asm(\"}\");\n\n    asm(\"declare i32 @printf(i8*, ...) nounwind\");\n\n    asm(\"define i32 @main() nounwind ssp {\");\n    asm(\"entry:\");\n\n    for ls.iter().advance |l| {\n      f(*l);\n    }\n\n    asm::__(\"ret i32 0\");\n    asm(\"}\");\n    asm::close();\n  }\n\n}\n\npub fn emit(file: &str, ls: &[~ast::LL]) {\n  emit::apply(file, ls);\n}\n\npub fn genid(s:&str) -> ~str {\n  static mut id:int = 0;\n  unsafe {\n    id += 1;\n    s + id.to_str()\n  }\n}\n\nfn readAll(file:&str) -> ~str {\n  use std::io;\n  use std::result;\n  let reader = result::get(&io::file_reader(&Path(file)));\n  let mut s = ~\"\";\n  while !reader.eof() {\n    s = s + reader.read_line() + \"\\n\";\n  }\n  s\n} \n\nfn writeAll(file:&str, s:&str) {\n  use std::io;\n  use std::result;\n  let writer = result::get(&io::buffered_file_writer(&Path(file)));\n  writer.write_str(s);\n}\n\npub mod asm {\n\n  use std::io;\n  use std::result;\n\n  pub static mut writer: Option<@Writer> = None;\n\n  pub fn open(file:&str) {\n    unsafe {\n      writer = Some(result::get(&io::buffered_file_writer(&Path(file))));\n    }\n  }\n\n  pub fn println(s:&str) {\n    unsafe {\n      writer.unwrap().write_str(s + \"\\n\");\n    }\n  }\n\n  pub fn close() {\n    unsafe {\n      writer = None;\n    }\n  }\n\n  pub fn __(s:&str) {\n    println(\"  \" + s);\n  }\n\n}\n\npub fn asm(s:&str) {\n  asm::println(s);\n}\n\npub struct ExecOutput {\n  status: int,\n  output: ~str,\n  error: ~str,\n}\n\nimpl ToStr for ExecOutput {\n  fn to_str(&self) -> ~str {\n    \"(\" + self.status.to_str()+\",\"+self.output+\",\"+self.error+\")\"\n  } \n}\n\nfn exec(cmd:&str) -> ExecOutput {\n\n  use std::str;\n  use std::run;\n\n  let mut cmds:~[&str] = cmd.split_str_iter(\" \").collect();\n  let prog:~str = \"\"+cmds.shift();\n  let args:&[~str] = (do cmds.map |&s| {(s+\"\")});\n  let o = run::process_output(prog,args);\n\n  unsafe {\n    ExecOutput {\n      status : o.status,\n      output : str::raw::from_bytes(o.output),\n      error : str::raw::from_bytes(o.error),\n    }\n  }\n\n}\n```\n", "tags": ["LLVM", "rust0.7", "\u30b3\u30f3\u30d1\u30a4\u30e9"]}