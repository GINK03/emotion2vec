{"context": "\n\n\u7dda\u5f62\u5909\u63db\n\u2192x\u223cN(\u2192\u03bc,\u03a3)x\u20d7\u00a0\u223cN(\u03bc\u20d7\u00a0,\u03a3)\\vec{x} \\sim \\mathcal{N}(\\vec{\\mu}, \\Sigma) \u306e\u3068\u304d \u2192y=A\u2192x+\u2192by\u20d7\u00a0=Ax\u20d7\u00a0+b\u20d7\u00a0\\vec{y} = A \\vec{x} + \\vec{b} \u3068\u304a\u304f\u3068\n\\vec{y} \\sim \\mathcal{N}(A \\vec{\\mu} + \\vec{b}, A \\Sigma A^{\\top})\n\u2192y\u223cN(A\u2192\u03bc+\u2192b,A\u03a3A\u22a4)y\u20d7\u00a0\u223cN(A\u03bc\u20d7\u00a0+b\u20d7\u00a0,A\u03a3A\u22a4){\\vec{y} \\sim \\mathcal{N}(A \\vec{\\mu} + \\vec{b}, A \\Sigma A^{\\top})\n}\n\u3068\u306a\u308b\u3002\n\n\u548c\n\u2192x\u223cN(\u2192\u03bcx,\u03a3x)x\u20d7\u00a0\u223cN(\u03bc\u20d7\u00a0x,\u03a3x)\\vec{x} \\sim \\mathcal{N}(\\vec{\\mu}_{x}, \\Sigma_{x}) \u304b\u3064 \u2192y\u223cN(\u2192\u03bcy,\u03a3y)y\u20d7\u00a0\u223cN(\u03bc\u20d7\u00a0y,\u03a3y)\\vec{y} \\sim \\mathcal{N}(\\vec{\\mu}_{y}, \\Sigma_{y}) \u306e\u3068\u304d \u2192z=\u2192x+\u2192yz\u20d7\u00a0=x\u20d7\u00a0+y\u20d7\u00a0\\vec{z} = \\vec{x} + \\vec{y} \u3068\u304a\u304f\u3068\n$\\vec{z} \\sim \\mathcal{N}(\\vec{\\mu}_{x} + \\vec{\\mu}_{y}, \\Sigma_{x} + \\Sigma_{y})$\n$\u2192z\u223cN(\u2192\u03bcx+\u2192\u03bcy,\u03a3x+\u03a3y)$$z\u20d7\u00a0\u223cN(\u03bc\u20d7\u00a0x+\u03bc\u20d7\u00a0y,\u03a3x+\u03a3y)${$\\vec{z} \\sim \\mathcal{N}(\\vec{\\mu}_{x} + \\vec{\\mu}_{y}, \\Sigma_{x} + \\Sigma_{y})$\n}\n\u3068\u306a\u308b\u3002\n\n\u30c6\u30b9\u30c8\u30b3\u30fc\u30c9\n#include <iostream>\n#include <vector>\n#include <array>\n#include <random>\n\nusing point_t = std::array<double, 2>;\nusing matrix_t = std::array<double, 4>;\n\npoint_t avg(std::vector<point_t> const& samples) {\n    point_t mu = {\n        0, 0,\n    };\n    for (auto const& x : samples) {\n        mu[0] += x[0];\n        mu[1] += x[1];\n    }\n    mu[0] /= samples.size();\n    mu[1] /= samples.size();\n    return mu;\n}\n\nmatrix_t var(std::vector<point_t> const& samples, point_t const& mu) {\n    matrix_t sigma = {\n        0, 0, 0, 0\n    };\n    for (auto const& x : samples) {\n        double const a = x[0] - mu[0];\n        double const b = x[1] - mu[1];\n        sigma[0] += a * a;\n        sigma[1] += a * b;\n        sigma[2] += b * a;\n        sigma[3] += b * b;\n    }\n    sigma[0] /= (samples.size() - 1);\n    sigma[1] /= (samples.size() - 1);\n    sigma[2] /= (samples.size() - 1);\n    sigma[3] /= (samples.size() - 1);\n    return sigma;\n}\n\nint main()\n{\n    std::mt19937_64 engine;\n    std::normal_distribution<> unorm;\n\n    matrix_t const A = {\n        1, -1, 3, 4\n    };\n\n    matrix_t const B = {\n        1, 3, 2, 4\n    };\n\n    std::vector<point_t> a;\n    std::vector<point_t> b;\n    std::vector<point_t> c;\n    for (int i = 0; i < 10000; ++i) {\n      double const ax = unorm(engine);\n      double const ay = unorm(engine);\n      double const bx = unorm(engine);\n      double const by = unorm(engine);\n\n      a.push_back({\n          A[0] * ax + A[1] * ay,\n          A[2] * ax + A[3] * ay});\n      b.push_back({\n          B[0] * bx + B[1] * by,\n          B[2] * bx + B[3] * by});\n      c.push_back({\n          a.back()[0] + b.back()[0],\n          a.back()[1] + b.back()[1]});\n    }\n\n    point_t  const mu_a    = avg(a);\n    matrix_t const sigma_a = var(a, mu_a);\n    point_t  const mu_b    = avg(b);\n    matrix_t const sigma_b = var(b, mu_b);\n    point_t  const mu_c    = avg(c);\n    matrix_t const sigma_c = var(c, mu_c);\n\n    matrix_t const sigma_a_true = {\n        A[0] * A[0] + A[1] * A[1],\n        A[0] * A[2] + A[1] * A[3],\n        A[2] * A[0] + A[3] * A[1],\n        A[2] * A[2] + A[3] * A[3],\n    };\n    matrix_t const sigma_b_true = {\n        B[0] * B[0] + B[1] * B[1],\n        B[0] * B[2] + B[1] * B[3],\n        B[2] * B[0] + B[3] * B[1],\n        B[2] * B[2] + B[3] * B[3],\n    };\n    matrix_t const sigma_c_true = {\n        sigma_a_true[0] + sigma_b_true[0],\n        sigma_a_true[1] + sigma_b_true[1],\n        sigma_a_true[2] + sigma_b_true[2],\n        sigma_a_true[3] + sigma_b_true[3],\n    };\n\n    std::cout << \"mu[a] = \"\n        << mu_a[0] << \", \"\n        << mu_a[1] << std::endl;\n    std::cout << \"sigma[a] = \"\n        << sigma_a[0] << \", \"\n        << sigma_a[1] << \", \"\n        << sigma_a[2] << \", \"\n        << sigma_a[3] << std::endl;\n    std::cout << \"Sigma[a] = \"\n        << sigma_a_true[0] << \", \"\n        << sigma_a_true[1] << \", \"\n        << sigma_a_true[2] << \", \"\n        << sigma_a_true[3] << std::endl;\n\n    std::cout << \"mu[b] = \"\n        << mu_b[0] << \", \"\n        << mu_b[1] << std::endl;\n    std::cout << \"sigma[b] = \"\n        << sigma_b[0] << \", \"\n        << sigma_b[1] << \", \"\n        << sigma_b[2] << \", \"\n        << sigma_b[3] << std::endl;\n    std::cout << \"Sigma[b] = \"\n        << sigma_b_true[0] << \", \"\n        << sigma_b_true[1] << \", \"\n        << sigma_b_true[2] << \", \"\n        << sigma_b_true[3] << std::endl;\n\n    std::cout << \"mu[c] = \"\n        << mu_c[0] << \", \"\n        << mu_c[1] << std::endl;\n    std::cout << \"sigma[c] = \"\n        << sigma_c[0] << \", \"\n        << sigma_c[1] << \", \"\n        << sigma_c[2] << \", \"\n        << sigma_c[3] << std::endl;\n    std::cout << \"Sigma[c] = \"\n        << sigma_c_true[0] << \", \"\n        << sigma_c_true[1] << \", \"\n        << sigma_c_true[2] << \", \"\n        << sigma_c_true[3] << std::endl;\n\n    return 0;\n}\n\n# \u7dda\u5f62\u5909\u63db\n$\\vec{x} \\sim \\mathcal{N}(\\vec{\\mu}, \\Sigma)$ \u306e\u3068\u304d $\\vec{y} = A \\vec{x} + \\vec{b}$ \u3068\u304a\u304f\u3068\n\n```math\n\\vec{y} \\sim \\mathcal{N}(A \\vec{\\mu} + \\vec{b}, A \\Sigma A^{\\top})\n```\n\n\u3068\u306a\u308b\u3002\n\n# \u548c\n\n$\\vec{x} \\sim \\mathcal{N}(\\vec{\\mu}\\_{x}, \\Sigma\\_{x})$ \u304b\u3064 $\\vec{y} \\sim \\mathcal{N}(\\vec{\\mu}\\_{y}, \\Sigma\\_{y})$ \u306e\u3068\u304d $\\vec{z} = \\vec{x} + \\vec{y}$ \u3068\u304a\u304f\u3068\n\n```math\n$\\vec{z} \\sim \\mathcal{N}(\\vec{\\mu}_{x} + \\vec{\\mu}_{y}, \\Sigma_{x} + \\Sigma_{y})$\n```\n\n\u3068\u306a\u308b\u3002\n\n# \u30c6\u30b9\u30c8\u30b3\u30fc\u30c9\n\n```cpp\n#include <iostream>\n#include <vector>\n#include <array>\n#include <random>\n\nusing point_t = std::array<double, 2>;\nusing matrix_t = std::array<double, 4>;\n\npoint_t avg(std::vector<point_t> const& samples) {\n    point_t mu = {\n        0, 0,\n    };\n    for (auto const& x : samples) {\n        mu[0] += x[0];\n        mu[1] += x[1];\n    }\n    mu[0] /= samples.size();\n    mu[1] /= samples.size();\n    return mu;\n}\n\nmatrix_t var(std::vector<point_t> const& samples, point_t const& mu) {\n    matrix_t sigma = {\n        0, 0, 0, 0\n    };\n    for (auto const& x : samples) {\n        double const a = x[0] - mu[0];\n        double const b = x[1] - mu[1];\n        sigma[0] += a * a;\n        sigma[1] += a * b;\n        sigma[2] += b * a;\n        sigma[3] += b * b;\n    }\n    sigma[0] /= (samples.size() - 1);\n    sigma[1] /= (samples.size() - 1);\n    sigma[2] /= (samples.size() - 1);\n    sigma[3] /= (samples.size() - 1);\n    return sigma;\n}\n\nint main()\n{\n    std::mt19937_64 engine;\n    std::normal_distribution<> unorm;\n\n    matrix_t const A = {\n        1, -1, 3, 4\n    };\n\n    matrix_t const B = {\n        1, 3, 2, 4\n    };\n\n    std::vector<point_t> a;\n    std::vector<point_t> b;\n    std::vector<point_t> c;\n    for (int i = 0; i < 10000; ++i) {\n      double const ax = unorm(engine);\n      double const ay = unorm(engine);\n      double const bx = unorm(engine);\n      double const by = unorm(engine);\n\n      a.push_back({\n          A[0] * ax + A[1] * ay,\n          A[2] * ax + A[3] * ay});\n      b.push_back({\n          B[0] * bx + B[1] * by,\n          B[2] * bx + B[3] * by});\n      c.push_back({\n          a.back()[0] + b.back()[0],\n          a.back()[1] + b.back()[1]});\n    }\n\n    point_t  const mu_a    = avg(a);\n    matrix_t const sigma_a = var(a, mu_a);\n    point_t  const mu_b    = avg(b);\n    matrix_t const sigma_b = var(b, mu_b);\n    point_t  const mu_c    = avg(c);\n    matrix_t const sigma_c = var(c, mu_c);\n\n    matrix_t const sigma_a_true = {\n        A[0] * A[0] + A[1] * A[1],\n        A[0] * A[2] + A[1] * A[3],\n        A[2] * A[0] + A[3] * A[1],\n        A[2] * A[2] + A[3] * A[3],\n    };\n    matrix_t const sigma_b_true = {\n        B[0] * B[0] + B[1] * B[1],\n        B[0] * B[2] + B[1] * B[3],\n        B[2] * B[0] + B[3] * B[1],\n        B[2] * B[2] + B[3] * B[3],\n    };\n    matrix_t const sigma_c_true = {\n        sigma_a_true[0] + sigma_b_true[0],\n        sigma_a_true[1] + sigma_b_true[1],\n        sigma_a_true[2] + sigma_b_true[2],\n        sigma_a_true[3] + sigma_b_true[3],\n    };\n\n    std::cout << \"mu[a] = \"\n        << mu_a[0] << \", \"\n        << mu_a[1] << std::endl;\n    std::cout << \"sigma[a] = \"\n        << sigma_a[0] << \", \"\n        << sigma_a[1] << \", \"\n        << sigma_a[2] << \", \"\n        << sigma_a[3] << std::endl;\n    std::cout << \"Sigma[a] = \"\n        << sigma_a_true[0] << \", \"\n        << sigma_a_true[1] << \", \"\n        << sigma_a_true[2] << \", \"\n        << sigma_a_true[3] << std::endl;\n    \n    std::cout << \"mu[b] = \"\n        << mu_b[0] << \", \"\n        << mu_b[1] << std::endl;\n    std::cout << \"sigma[b] = \"\n        << sigma_b[0] << \", \"\n        << sigma_b[1] << \", \"\n        << sigma_b[2] << \", \"\n        << sigma_b[3] << std::endl;\n    std::cout << \"Sigma[b] = \"\n        << sigma_b_true[0] << \", \"\n        << sigma_b_true[1] << \", \"\n        << sigma_b_true[2] << \", \"\n        << sigma_b_true[3] << std::endl;\n    \n    std::cout << \"mu[c] = \"\n        << mu_c[0] << \", \"\n        << mu_c[1] << std::endl;\n    std::cout << \"sigma[c] = \"\n        << sigma_c[0] << \", \"\n        << sigma_c[1] << \", \"\n        << sigma_c[2] << \", \"\n        << sigma_c[3] << std::endl;\n    std::cout << \"Sigma[c] = \"\n        << sigma_c_true[0] << \", \"\n        << sigma_c_true[1] << \", \"\n        << sigma_c_true[2] << \", \"\n        << sigma_c_true[3] << std::endl;\n\n    return 0;\n}\n```\n", "tags": ["\u7d71\u8a08\u5b66"]}