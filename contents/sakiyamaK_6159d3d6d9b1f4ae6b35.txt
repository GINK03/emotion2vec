{"context": "2017/02/14\u300cCMSampleBuffer - UIImage\u300d\u3092\u8ffd\u8a18\n\u6bce\u56de\u5fd8\u308c\u308b\u306e\u3067\u307e\u3068\u3081\u307e\u3057\u305f\u3002\n\u30e1\u30e2\u7a0b\u5ea6\u306a\u306e\u3067\u4f55\u304b\u3082\u3063\u3068\u826f\u3044\u65b9\u6cd5\u3042\u308b\u3068\u304b\u30ea\u30fc\u30af\u3059\u308b\u3068\u304b\u3042\u3063\u305f\u3089\u6559\u3048\u3066\u4e0b\u3055\u3044\u3002\n\nCMSampleBuffer - UIImage\n//CMSampleBufferRef\u304b\u3089UIImage\n-(UIImage *)imageFromSampleBuffer:(CMSampleBufferRef)sampleBuffer{\n\n  CVImageBufferRef imageBuffer = CMSampleBufferGetImageBuffer(sampleBuffer);\n\n  // \u30d4\u30af\u30bb\u30eb\u30d0\u30c3\u30d5\u30a1\u306e\u30d9\u30fc\u30b9\u30a2\u30c9\u30ec\u30b9\u3092\u30ed\u30c3\u30af\u3059\u308b\n  CVPixelBufferLockBaseAddress(imageBuffer, 0);\n\n  // Get information of the image\n  uint8_t *baseAddress = (uint8_t *)CVPixelBufferGetBaseAddressOfPlane(imageBuffer, 0);\n\n  size_t bytesPerRow = CVPixelBufferGetBytesPerRow(imageBuffer);\n  size_t width = CVPixelBufferGetWidth(imageBuffer);\n  size_t height = CVPixelBufferGetHeight(imageBuffer);\n\n  // RGB\u306e\u8272\u7a7a\u9593\n  CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceRGB();\n\n  CGContextRef newContext = CGBitmapContextCreate(baseAddress,\n                                                  width,\n                                                  height,\n                                                  8,\n                                                  bytesPerRow,\n                                                  colorSpace,\n                                                  kCGBitmapByteOrder32Little | kCGImageAlphaPremultipliedFirst);\n\n  CGImageRef cgImage = CGBitmapContextCreateImage(newContext);\n\n  CGContextRelease(newContext);\n  CGColorSpaceRelease(colorSpace);\n\n  UIImage *rtnImage = [UIImage imageWithCGImage:cgImage scale:1.0 orientation:UIImageOrientationUp];\n\n  CVPixelBufferUnlockBaseAddress(imageBuffer, 0);\n  CGImageRelease(cgImage);\n\n  return rtnImage;\n}\n\n\n\nUIImage - CGImage\n\nuiimage-cgimage.m\n//UIImage\u304b\u3089CGImage\nCGImageRef cgimage = uiimage.CGImage;\n\n//CGImage\u304b\u3089UIImage\nUIImage *uiimage = [UIImage imageWithCGImage:cgimage];\nCGImageRelease(cgimage);\n\n\n\nCIImage - CGImage\n\nuiimage-ciimage.m\n//CIImage\u304b\u3089CGImage\n//[CIContext new]\u306f\u30c0\u30e1 2016/06/08\u66f4\u65b0\nCGImageRef cgimage = [[CIContext contextWithOptions:nil] createCGImage:ciimage fromRect:ciimage.extent];\n\n//CGImage\u304b\u3089CIImage\nCIImage *ciimage = [CIImage imageWithCGImage:cgimage];\n\n\n\nvImage - CGImage\n\nvimage-cgimage.m\n    /*\n     * format\n     * \n     *      typedef struct vImage_CGImageFormat\n     *      {\n     *          uint32_t                bitsPerComponent;\n     *          uint32_t                bitsPerPixel;       \n     *          CGColorSpaceRef         colorSpace;         \n     *          CGBitmapInfo            bitmapInfo;         \n     *          uint32_t                version;            \n     *          const CGFloat *         decode;\n     *          CGColorRenderingIntent  renderingIntent;\n     *      }vImage_CGImageFormat;\n\n     *      \u4f8b\n     *      ARGB8888     ->  {8, 32, NULL, alpha first, 0, NULL, kCGRenderingIntentDefault}     alpha first = { kCGImageAlphaFirst, kCGImageAlphaPremultipliedFirst, kCGImageAlphaNoneSkipFirst }\n     *      RGBA8888     ->  {8, 32, NULL, alpha last,  0, NULL, kCGRenderingIntentDefault}     alpha last  = { kCGImageAlphaLast,  kCGImageAlphaPremultipliedLast,  kCGImageAlphaNoneSkipLast }\n     *      BGRA8888     ->  {8, 32, NULL, alpha first | kCGBitmapByteOrder32Little, 0, NULL, kCGRenderingIntentDefault}\n     *      RGB888       ->  {8, 24, NULL, kCGImageAlphaNone | kCGBitmapByteOrderDefault, 0, NULL, kCGRenderingIntentDefault}\n     *      RGB565       ->  {5, 16, NULL, kCGImageAlphaNone | kCGBitmapByteOrder16Little, 0, NULL, kCGRenderingIntentDefault}\n     *      ARGB1555     ->  {5, 16, NULL, alpha first | kCGBitmapByteOrder16Little, 0, NULL, kCGRenderingIntentDefault}\n     *      RGBA16F      ->  {16, 64, NULL, alpha last | kCGBitmapFloatComponents | kCGBitmapByteOrder16Little, 0, NULL, kCGRenderingIntentDefault }\n     *      CMYK8888     ->  {8, 32, CGColorSpaceCreateDeviceCMYK(), kCGImageAlphaNone, 0, NULL, kCGRenderingIntentDefault  }\n     *      ARGBFFFF premultiplied    ->  {32, 128, NULL, kCGImageAlphaPremultipliedFirst | kCGBitmapFloatComponents | kCGBitmapByteOrder32Little, 0, NULL, kCGRenderingIntentDefault }\n     *      ARGBFFFF not-premultiplied -> {32, 128, NULL, kCGImageAlphaFirst | kCGBitmapFloatComponents | kCGBitmapByteOrder32Little, 0, NULL, kCGRenderingIntentDefault }\n     *      ARGBFFFF, alpha = 1 ->        {32, 128, NULL, kCGImageAlphaNoneSkipFirst | kCGBitmapFloatComponents | kCGBitmapByteOrder32Little, 0, NULL, kCGRenderingIntentDefault }\n\n     *      uiimageview\u306b\u8868\u793a\u3059\u308b\u6642\u7528\u306eformat\n     *      vImage_CGImageFormat format = {\n     *          .bitsPerComponent = 8,\n     *          .bitsPerPixel = 32,\n     *          .bitmapInfo = kCGBitmapByteOrderDefault | kCGImageAlphaLast,  //RGBA8888\n     *      }; // .colorspace, .version, .renderingIntent and .decode all initialized to 0 per C rules\n     */\n\n//vImage\u304b\u3089CGImage\n-(CGImageRef)vImageToCGImage:(vImage_Buffer)vimage withFormat:(vImage_CGImageFormat) format{\n  vImage_Error error;\n  CGImageRef cgimage = vImageCreateCGImageFromBuffer( &vimage, &format, NULL, NULL, kvImageNoFlags, &error);\n  if (error != kvImageNoError) {\n     NSLog(@\"[VIImage ERROR][No %d]\", (int)error);\n  }\n\n  return cgimage;\n}\n\n\n//CGImage\u304b\u3089vImage\n-(vImage_Buffer)CGImageToVImage:(CGImageRef)cgimage withFormat:(vImage_CGImageFormat) format{\n  vImage_Buffer vimage;\n  vImage_Error error = vImageBuffer_InitWithCGImage( &vimage, &format, NULL, cgimage, kvImageNoFlags );\n  if (error != kvImageNoError) {\n    NSLog(@\"[VIImage ERROR][No %d]\", (int)error);\n  }\n\n  return vimage;\n}\n\n\n\n\nGPUImagePicture(GPUImage) - UIImage\n\ngpuimagepicture-uiimage.m\n//uiimage\u304b\u3089gpuimagepicture\nGPUImagePicture *gpuImage = [[GPUImagePicture alloc] initWithImage:uiimage];\n\n//gpuimagepicture\u304b\u3089uiimage(GPUImageFilter\u3092\u901a\u3059)\nGPUImageFilter *filter = /*GPUImgeFilter\u3092\u7d99\u627f\u3057\u3066\u3044\u308b\u306a\u306b\u304b\u3057\u3089*/\n[gpuImage addTarget:filter];\n[filter useNextFrameForImageCapture];\n[gpuImage processImage];\nUIImage *dstuiimage = [filter imageFromCurrentFramebuffer];\n\n\n\ncv::Mat(OpenCV) - UIImage\n\ncvmat-uiimage.m\n\n#import \"opencv2/imgcodecs/ios.h\"\n\n//uiimage\u304b\u3089cv::Mat\ncv::Mat cvmat;\nUIImageToMat(uiimage, cvmat);\n\n//cv::Mat\u304b\u3089uiimage\nUIImage *uiimage = MatToUIImage(cvmat);\n\n\n\n(\u30aa\u30de\u30b1)opencv\u3067\u753b\u50cf\u51e6\u7406\u3059\u308b\u3068\u304d\u306e\u30c6\u30f3\u30d7\u30ec\u30fc\u30c8\n\nUtilOpenCVHelper.h\n\n#ifndef UtilOpenCVHelper_h\n#define UtilOpenCVHelper_h\n\n#import <Foundation/Foundation.h>\n#import <UIKit/UIKit.h>\n\n@interface UtilOpenCVHelper : NSObject\n+(UIImage *)testOpenCVMethodWithUIImage:(UIImage *)image;\n@end\n\n\n\n\nUtilOpenCVHelper.mm\n#import \"UtilOpenCVHelper.h\"\n#import \"opencv2/imgcodecs/ios.h\"\n\n@interface UtilOpenCVHelper()\n@end\n\n@implementation UtilOpenCVHelper\n\ntypedef BOOL (^openCVAlgorithm)(const cv::Mat&, cv::Mat&) ;\n\n//UIImage\u3092opencv\u3067\u51e6\u7406\u3057\u3066UIImage\u3067\u8fd4\u3059\u30c6\u30f3\u30d7\u30ec\u30fc\u30c8\n+(UIImage *)template:(UIImage *)uiimage withAlgorithm:(openCVAlgorithm)algorithm{\n  cv::Mat cvmat;\n  UIImageToMat(uiimage, cvmat);\n\n  UIImage *dstuiimage = uiimage;\n\n  cv::Mat cvdstmat;\n\n  if(algorithm(cvmat, cvdstmat)){\n    dstuiimage = MatToUIImage(cvdstmat);\n  }\n  else{\n    NSLog(@\"[OPENCV ERROR]\");\n  }\n\n  return dstuiimage;\n}\n\n//\u5b9f\u969b\u306bOpenCV\u3067\u51e6\u7406\u3059\u308b\u90e8\u5206\n+(UIImage *)testOpenCVMethodWithUIImage:(UIImage *)image{\n  return [UtilOpenCVHelper template:image\n          withAlgorithm:^BOOL (const cv::Mat &cvmat, cv::Mat &cvdstmat){\n    /*\n       opencv\u3067\u753b\u50cf\u51e6\u7406\n       cvdstmat\u304c\u51fa\u529b\n     */\n    return ! cvdstmat.empty()\n  }];\n}\n\n\n\n2017/02/14\u300cCMSampleBuffer - UIImage\u300d\u3092\u8ffd\u8a18\n\n\u6bce\u56de\u5fd8\u308c\u308b\u306e\u3067\u307e\u3068\u3081\u307e\u3057\u305f\u3002\n\u30e1\u30e2\u7a0b\u5ea6\u306a\u306e\u3067\u4f55\u304b\u3082\u3063\u3068\u826f\u3044\u65b9\u6cd5\u3042\u308b\u3068\u304b\u30ea\u30fc\u30af\u3059\u308b\u3068\u304b\u3042\u3063\u305f\u3089\u6559\u3048\u3066\u4e0b\u3055\u3044\u3002\n\n#CMSampleBuffer - UIImage\n```objc\n//CMSampleBufferRef\u304b\u3089UIImage\n-(UIImage *)imageFromSampleBuffer:(CMSampleBufferRef)sampleBuffer{\n  \n  CVImageBufferRef imageBuffer = CMSampleBufferGetImageBuffer(sampleBuffer);\n  \n  // \u30d4\u30af\u30bb\u30eb\u30d0\u30c3\u30d5\u30a1\u306e\u30d9\u30fc\u30b9\u30a2\u30c9\u30ec\u30b9\u3092\u30ed\u30c3\u30af\u3059\u308b\n  CVPixelBufferLockBaseAddress(imageBuffer, 0);\n  \n  // Get information of the image\n  uint8_t *baseAddress = (uint8_t *)CVPixelBufferGetBaseAddressOfPlane(imageBuffer, 0);\n  \n  size_t bytesPerRow = CVPixelBufferGetBytesPerRow(imageBuffer);\n  size_t width = CVPixelBufferGetWidth(imageBuffer);\n  size_t height = CVPixelBufferGetHeight(imageBuffer);\n  \n  // RGB\u306e\u8272\u7a7a\u9593\n  CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceRGB();\n  \n  CGContextRef newContext = CGBitmapContextCreate(baseAddress,\n                                                  width,\n                                                  height,\n                                                  8,\n                                                  bytesPerRow,\n                                                  colorSpace,\n                                                  kCGBitmapByteOrder32Little | kCGImageAlphaPremultipliedFirst);\n  \n  CGImageRef cgImage = CGBitmapContextCreateImage(newContext);\n  \n  CGContextRelease(newContext);\n  CGColorSpaceRelease(colorSpace);\n  \n  UIImage *rtnImage = [UIImage imageWithCGImage:cgImage scale:1.0 orientation:UIImageOrientationUp];\n  \n  CVPixelBufferUnlockBaseAddress(imageBuffer, 0);\n  CGImageRelease(cgImage);\n    \n  return rtnImage;\n}\n\n```\n\n#UIImage - CGImage\n```objc:uiimage-cgimage.m\n//UIImage\u304b\u3089CGImage\nCGImageRef cgimage = uiimage.CGImage;\n\n//CGImage\u304b\u3089UIImage\nUIImage *uiimage = [UIImage imageWithCGImage:cgimage];\nCGImageRelease(cgimage);\n```\n\n#CIImage - CGImage\n```objc:uiimage-ciimage.m\n//CIImage\u304b\u3089CGImage\n//[CIContext new]\u306f\u30c0\u30e1 2016/06/08\u66f4\u65b0\nCGImageRef cgimage = [[CIContext contextWithOptions:nil] createCGImage:ciimage fromRect:ciimage.extent];\n\n//CGImage\u304b\u3089CIImage\nCIImage *ciimage = [CIImage imageWithCGImage:cgimage];\n```\n\n#vImage - CGImage\n```objc:vimage-cgimage.m\n    /*\n     * format\n     * \n     *      typedef struct vImage_CGImageFormat\n     *      {\n     *          uint32_t                bitsPerComponent;\n     *          uint32_t                bitsPerPixel;       \n     *          CGColorSpaceRef         colorSpace;         \n     *          CGBitmapInfo            bitmapInfo;         \n     *          uint32_t                version;            \n     *          const CGFloat *         decode;\n     *          CGColorRenderingIntent  renderingIntent;\n     *      }vImage_CGImageFormat;\n    \n     *      \u4f8b\n     *      ARGB8888     ->  {8, 32, NULL, alpha first, 0, NULL, kCGRenderingIntentDefault}     alpha first = { kCGImageAlphaFirst, kCGImageAlphaPremultipliedFirst, kCGImageAlphaNoneSkipFirst }\n     *      RGBA8888     ->  {8, 32, NULL, alpha last,  0, NULL, kCGRenderingIntentDefault}     alpha last  = { kCGImageAlphaLast,  kCGImageAlphaPremultipliedLast,  kCGImageAlphaNoneSkipLast }\n     *      BGRA8888     ->  {8, 32, NULL, alpha first | kCGBitmapByteOrder32Little, 0, NULL, kCGRenderingIntentDefault}\n     *      RGB888       ->  {8, 24, NULL, kCGImageAlphaNone | kCGBitmapByteOrderDefault, 0, NULL, kCGRenderingIntentDefault}\n     *      RGB565       ->  {5, 16, NULL, kCGImageAlphaNone | kCGBitmapByteOrder16Little, 0, NULL, kCGRenderingIntentDefault}\n     *      ARGB1555     ->  {5, 16, NULL, alpha first | kCGBitmapByteOrder16Little, 0, NULL, kCGRenderingIntentDefault}\n     *      RGBA16F      ->  {16, 64, NULL, alpha last | kCGBitmapFloatComponents | kCGBitmapByteOrder16Little, 0, NULL, kCGRenderingIntentDefault }\n     *      CMYK8888     ->  {8, 32, CGColorSpaceCreateDeviceCMYK(), kCGImageAlphaNone, 0, NULL, kCGRenderingIntentDefault  }\n     *      ARGBFFFF premultiplied    ->  {32, 128, NULL, kCGImageAlphaPremultipliedFirst | kCGBitmapFloatComponents | kCGBitmapByteOrder32Little, 0, NULL, kCGRenderingIntentDefault }\n     *      ARGBFFFF not-premultiplied -> {32, 128, NULL, kCGImageAlphaFirst | kCGBitmapFloatComponents | kCGBitmapByteOrder32Little, 0, NULL, kCGRenderingIntentDefault }\n     *      ARGBFFFF, alpha = 1 ->        {32, 128, NULL, kCGImageAlphaNoneSkipFirst | kCGBitmapFloatComponents | kCGBitmapByteOrder32Little, 0, NULL, kCGRenderingIntentDefault }\n\n     *      uiimageview\u306b\u8868\u793a\u3059\u308b\u6642\u7528\u306eformat\n     *      vImage_CGImageFormat format = {\n     *          .bitsPerComponent = 8,\n     *          .bitsPerPixel = 32,\n     *          .bitmapInfo = kCGBitmapByteOrderDefault | kCGImageAlphaLast,  //RGBA8888\n     *      }; // .colorspace, .version, .renderingIntent and .decode all initialized to 0 per C rules\n     */\n\n//vImage\u304b\u3089CGImage\n-(CGImageRef)vImageToCGImage:(vImage_Buffer)vimage withFormat:(vImage_CGImageFormat) format{\n  vImage_Error error;\n  CGImageRef cgimage = vImageCreateCGImageFromBuffer( &vimage, &format, NULL, NULL, kvImageNoFlags, &error);\n  if (error != kvImageNoError) {\n     NSLog(@\"[VIImage ERROR][No %d]\", (int)error);\n  }\n  \n  return cgimage;\n}\n\n\n//CGImage\u304b\u3089vImage\n-(vImage_Buffer)CGImageToVImage:(CGImageRef)cgimage withFormat:(vImage_CGImageFormat) format{\n  vImage_Buffer vimage;\n  vImage_Error error = vImageBuffer_InitWithCGImage( &vimage, &format, NULL, cgimage, kvImageNoFlags );\n  if (error != kvImageNoError) {\n    NSLog(@\"[VIImage ERROR][No %d]\", (int)error);\n  }\n  \n  return vimage;\n}\n\n```\n#GPUImagePicture(GPUImage) - UIImage\n```objc:gpuimagepicture-uiimage.m\n//uiimage\u304b\u3089gpuimagepicture\nGPUImagePicture *gpuImage = [[GPUImagePicture alloc] initWithImage:uiimage];\n\n//gpuimagepicture\u304b\u3089uiimage(GPUImageFilter\u3092\u901a\u3059)\nGPUImageFilter *filter = /*GPUImgeFilter\u3092\u7d99\u627f\u3057\u3066\u3044\u308b\u306a\u306b\u304b\u3057\u3089*/\n[gpuImage addTarget:filter];\n[filter useNextFrameForImageCapture];\n[gpuImage processImage];\nUIImage *dstuiimage = [filter imageFromCurrentFramebuffer];\n```\n\n#cv::Mat(OpenCV) - UIImage\n```objc:cvmat-uiimage.m\n\n#import \"opencv2/imgcodecs/ios.h\"\n\n//uiimage\u304b\u3089cv::Mat\ncv::Mat cvmat;\nUIImageToMat(uiimage, cvmat);\n\n//cv::Mat\u304b\u3089uiimage\nUIImage *uiimage = MatToUIImage(cvmat);\n```\n\n#(\u30aa\u30de\u30b1)opencv\u3067\u753b\u50cf\u51e6\u7406\u3059\u308b\u3068\u304d\u306e\u30c6\u30f3\u30d7\u30ec\u30fc\u30c8\n```objc:UtilOpenCVHelper.h\n\n#ifndef UtilOpenCVHelper_h\n#define UtilOpenCVHelper_h\n\n#import <Foundation/Foundation.h>\n#import <UIKit/UIKit.h>\n\n@interface UtilOpenCVHelper : NSObject\n+(UIImage *)testOpenCVMethodWithUIImage:(UIImage *)image;\n@end\n\n```\n\n```objc:UtilOpenCVHelper.mm\n#import \"UtilOpenCVHelper.h\"\n#import \"opencv2/imgcodecs/ios.h\"\n\n@interface UtilOpenCVHelper()\n@end\n\n@implementation UtilOpenCVHelper\n\ntypedef BOOL (^openCVAlgorithm)(const cv::Mat&, cv::Mat&) ;\n\n//UIImage\u3092opencv\u3067\u51e6\u7406\u3057\u3066UIImage\u3067\u8fd4\u3059\u30c6\u30f3\u30d7\u30ec\u30fc\u30c8\n+(UIImage *)template:(UIImage *)uiimage withAlgorithm:(openCVAlgorithm)algorithm{\n  cv::Mat cvmat;\n  UIImageToMat(uiimage, cvmat);\n  \n  UIImage *dstuiimage = uiimage;\n  \n  cv::Mat cvdstmat;\n\n  if(algorithm(cvmat, cvdstmat)){\n    dstuiimage = MatToUIImage(cvdstmat);\n  }\n  else{\n    NSLog(@\"[OPENCV ERROR]\");\n  }\n  \n  return dstuiimage;\n}\n\n//\u5b9f\u969b\u306bOpenCV\u3067\u51e6\u7406\u3059\u308b\u90e8\u5206\n+(UIImage *)testOpenCVMethodWithUIImage:(UIImage *)image{\n  return [UtilOpenCVHelper template:image\n          withAlgorithm:^BOOL (const cv::Mat &cvmat, cv::Mat &cvdstmat){\n    /*\n       opencv\u3067\u753b\u50cf\u51e6\u7406\n       cvdstmat\u304c\u51fa\u529b\n     */\n    return ! cvdstmat.empty()\n  }];\n}\n```\n\n\n```\n", "tags": ["CoreGraphics", "vImage", "OpenCV", "gpuimage", "CoreImage"]}