{"tags": ["Arduino", "camera", "ov7670"], "context": "\n\n\u30ab\u30e9\u30fc\u5316\u3068\u30b9\u30d4\u30fc\u30c9\u30a2\u30c3\u30d7\n\uff3b\u305d\u306e\uff11\uff3d\u3067\u306f\u5143\u30cd\u30bf\u306b\u5f93\u3044\u3001Arduino\u306b\u30ab\u30e1\u30e9\u3092\u3064\u306a\u3050\u306e\u306f\u3046\u307e\u304f\u3044\u3063\u305f\u306e\u3067\u3001\u3082\u3063\u3068\u6a5f\u80fd\u3092\u6539\u5584\u3059\u308b\u3002\n\n\u4f55\u3092\u3059\u308b\u304b\n(1)\u30ab\u30e9\u30fc\u5316\n\u3000\u3000\u5143\u30cd\u30bf\u306f\u30e2\u30ce\u30af\u30ed\u306a\u306e\u3067\u3053\u308c\u3092\u30ab\u30e9\u30fc\u5316\u3059\u308b\u4e8b\u306b\u3088\u308a\u3001\u8868\u73fe\u529b\u304c\u5411\u4e0a\u3059\u308b\u3002\n (2)\u753b\u50cf\u8868\u793a\u306e\u9ad8\u901f\u5316\n\u3000\u3000\u753b\u50cf\u8868\u793a\u901f\u5ea6\u3092\u65e9\u304f\u3059\u308b\u4e8b\u306b\u3088\u308a\u3001\u79fb\u52d5\u3059\u308b\u753b\u50cf\u306b\u591a\u5c11\u5f37\u304f\u306a\u308b\u3002\n\n\uff11\uff0e\u30ab\u30e9\u30fc\u5316\n\u3000\u30ab\u30e9\u30fc\u753b\u50cf\u3092\u64ae\u5f71\u3059\u308b\u305f\u3081\u306b\u30ab\u30e1\u30e9\u306e\u753b\u50cf\u30d5\u30a9\u30fc\u30de\u30c3\u30c8\u3092RGB565\u306b\u5909\u66f4\u3059\u308b\u3002\n\u3000\u30c7\u30fc\u30bf\u304c\uff12\u30d0\u30a4\u30c8/\uff11\u30d4\u30af\u30bb\u30eb\u3068\uff12\u500d\u306b\u306a\u308b\u306e\u3067\u3001PCLK\u306e\u5909\u5316\u6bce\u306b\u30c7\u30fc\u30bf\u3092\u9001\u4fe1\u3059\u308b\u3002\n\u3000\u30c7\u30fc\u30bf\u3092\u9001\u308a\u5207\u308c\u306a\u304f\u306a\u308b\u306e\u3067\u3001PCLK\u3092\u534a\u5206\u306b\u9045\u304f\u3059\u308b\u3002\n\u3000\u203bov7670\u30ec\u30b8\u30b9\u30bf(0x11)\u3067XCLK\u3068PCLK\u306e\u5206\u5468\u6bd4\u3092\u8a2d\u5b9a\n\u3000\u30e2\u30ce\u30af\u30ed\u6642\n\u3000PCLK\u30925.5u\u3068\u3057\uff12\u30af\u30ed\u30c3\u30af\u6bce\u306b\u9001\u4fe1\n\n\u3000\u30ab\u30e9\u30fc\u6642\n\u3000PCLK\u309210.5u\u3068\u3057\uff11\u30af\u30ed\u30c3\u30af\u6bce\u306b\u9001\u4fe1\n\n\u3000\u753b\u50cf\u306e\u4f8b\n\n\u3000\u30ab\u30e1\u30e9\u306e\u521d\u671f\u5316\u306f\u30cd\u30c3\u30c8\u306e\u8a2d\u5b9a\u4f8b\u3092\u53c2\u8003\u306b\u3057\u305f\u304c\u3001\u6539\u5584\u306e\u4f59\u5730\u304c\u3042\u308b\u3088\u3046\u306a\n\n\uff12\uff0e\u753b\u50cf\u8868\u793a\u306e\u9ad8\u901f\u5316\n\u3000\u753b\u50cf\u306e\u8868\u793a\u901f\u5ea6\u306f\u30b7\u30ea\u30a2\u30eb\u901a\u4fe1\u306e\u901f\u5ea6\u3067\u6291\u3048\u3089\u308c\u3066\u304a\u308a\u3001\u30b7\u30ea\u30a2\u30eb\u306e\u9ad8\u901f\u5316\u304c\u5fc5\u8981\u3067\u3042\u308a\u3001\u3053\u306e\u65b9\u6cd5\u3068\u3057\u3066\u6b21\u306e\uff12\u70b9\u3092\u691c\u8a0e\u3002\n (1)\u901a\u4fe1\u901f\u5ea6\u30a2\u30c3\u30d7\n\u3000\u3000\u6700\u59272Mbps\u8fc4UP\u53ef\u80fd\u3060\u304c\u3001\u5f53\u65b9\u306e\u74b0\u5883\u3067\u306f2Mbps\u306b\u8a2d\u5b9a\u3059\u308b\u3068\u30c7\u30fc\u30bf\u306e\u53d6\u308a\u3053\u307c\u3057\u304c\u767a\u751f\u3057\u305f\u3002\n\u3000\u3000\u30ce\u30a4\u30ba\u306b\u8d77\u56e0\u3057\u3066\u3044\u308b\u3088\u3046\u306b\u601d\u308f\u308c\u308b\u304c\u3001\u89e3\u6c7a\u306b\u6642\u9593\u304c\u304b\u304b\u308a\u305d\u3046\u306a\u306e\u3067\u3001\u3053\u306e\u65b9\u6cd5\u306f\u5374\u4e0b\u3002\n (2)\u7a7a\u304d\u6642\u9593\u3092\u3064\u3081\u308b\n\u3000\u3000PCLK\u306e\u6ce2\u5f62\u3092\u4fef\u77b0\u3057\u3066\u898b\u308b\u3068\u3001\u4e00\u884c\u5206\u306e\u30c7\u30fc\u30bf\u3068\u6b21\u306e\u753b\u50cf\u30c7\u30fc\u30bf\u3068\u306e\u9593\u9694\u304c\u304b\u306a\u308a\u7a7a\u3044\u3066\u3044\u308b\u4e8b\u304c\u5224\u308b\u3002\n\u3000\u3000\u3053\u308c\u306f\u3001OV7670\u3092QVGA\u306b\u8a2d\u5b9a\u3059\u308b\u3068\u3001\u5fc5\u8981\u306a\u753b\u50cf\u306f\u4e00\u884c\u304a\u304d\u306b\u767a\u751f\u3059\u308b\u304c\u3001\u30c7\u30fc\u30bf\u306e\u767a\u751f\u9593\u9694\u306f\u5909\u308f\u3089\u306a\u3044\u70ba\u3067\u3042\u308b\u3002\n\u3000\u3000\u305d\u3053\u3067\u7a7a\u304d\u6642\u9593\u306b\u4f1d\u9001\u3059\u308b\u65b9\u6cd5\u3092\u8003\u3048\u305f\u3002\n\u3000\u3000\u5e38\u5957\u624b\u6bb5\u3068\u3057\u3066\u306f\u30ea\u30f3\u30b0\u30d0\u30c3\u30d5\u30a1\u304c\u8003\u3048\u3089\u308c\u308b\u304c\u3001arduino(16M)\u3067\u306f\u51e6\u7406\u80fd\u529b\u304c\u8db3\u308a\u305a\u3001\u51e6\u7406\u843d\u3061\u304c\u767a\u751f\u3057\u305f\u3002\n\u3000\u3000\u305d\u3053\u3067\u3001\uff11\u30d0\u30a4\u30c8\u76ee\u306f\u30c7\u30fc\u30bf\u306e\u76f4\u63a5\u9001\u4fe1\u3092\u3001\uff12\u30d0\u30a4\u30c8\u76ee\u306f\u30d0\u30c3\u30d5\u30a1\u30ea\u30f3\u30b0\u3059\u308b\u4e8b\u306b\u3088\u308a\u3001\uff12\u500d\u306ePCLK\u3067\u3082\u5468\u671f\u5185\u3067\u306e\u9001\u4fe1\u51e6\u7406\u304c\u53ef\u80fd\u3068\u306a\u3063\u305f\u3002\n\u3000\u3000\u30d0\u30c3\u30d5\u30a1\u30ea\u30f3\u30b0\u3057\u305f\u30c7\u30fc\u30bf\u306f\u7a7a\u304d\u6642\u9593\u306b\u9001\u4fe1\u3059\u308b\u3002\n\u3000\u3000\u307e\u305f\u3001\u3053\u308c\u306b\u3088\u308a\u9001\u4fe1\u30c7\u30fc\u30bf\u306f\u30b7\u30fc\u30b1\u30f3\u30b7\u30e3\u30eb\u306b\u306a\u3089\u306a\u3044\u304c\u3001\u3053\u308c\u306f\u8868\u793a\u30bd\u30d5\u30c8\u3067\u4e26\u3073\u66ff\u3048\u308b\u4e8b\u306b\u3057\u305f\u3002\n\u3000\u8868\u793a\u30bd\u30d5\u30c8\u306e\u8aac\u660e\n\u3000\uff3b\u305d\u306e\uff12\u3000\u753b\u50cf\u306e\u8868\u793a\uff3d\n\u3000\u3000\u3053\u308c\u306b\u3088\u308a\u901a\u4fe1\u901f\u5ea6\u306f\u7d04\uff12\u500d\u3068\u306a\u308a\u3001\u30e2\u30ce\u30af\u30ed\u3067\u306f\u7d04\uff11\u79d2(1.1s)\u3067\u753b\u50cf\u306e\u66f4\u65b0\u304c\u53ef\u80fd\u3068\u306a\u3063\u305f\u3002\n\u3000PCLK\u3068\u540c\u671f\u3057\u3066\u9001\u4fe1\n\u3000(CH0.PCLK CH1.\u30b7\u30ea\u30a2\u30eb\u9001\u4fe1)\n\n\u3000\u30d0\u30c3\u30d5\u30a1\u30ea\u30f3\u30b0\u3057\u3066\u3001\u7a7a\u304d\u6642\u9593\u306b\u3082\u9001\u4fe1\n\n\u300cuno_ov7670.ino\u300dver1.1\n// Source code for application to transmit image from ov7670 to PC via USB\n// By Siarhei Charkes in 2015\n// http://privateblog.info \n\n#include <stdint.h>\n#include <avr/io.h>\n#include <util/twi.h>\n#include <util/delay.h>\n#include <avr/pgmspace.h>\n\n#define camAddr_WR  0x42\n#define camAddr_RD  0x43\n#define REG_COM7  0x12\n#define REG_COM10 0x15  // Control 10 //\n#define REG_COM14 0x3e  // Control 14 //\n#define REG_COM15 0x40  // Control 15 //\n\nuint8_t cammd0=0, cammd1=0;\nstruct regval_list{ uint8_t reg_num; uint16_t value; };\nconst struct regval_list ov7670_default_regs[] PROGMEM = {\n  {0x3a,0x04},{0x40,0xd0},{0x12,0x14},{0x32,0x80},{0x17,0x16},{0x18,0x04},{0x19,0x02},{0x1a,0x7b},\n  {0x03,0x06},{0x0c,0x00},{0x3e,0x00},{0x70,0x00},{0x71,0x00},{0x72,0x11},{0x73,0x00},{0xa2,0x02},\n  {0x11,0x81},{0x7a,0x20},{0x7b,0x1c},{0x7c,0x28},{0x7d,0x3c},{0x7e,0x55},{0x7f,0x68},{0x80,0x76},\n  {0x81,0x80},{0x82,0x88},{0x83,0x8f},{0x84,0x96},{0x85,0xa3},{0x86,0xaf},{0x87,0xc4},{0x88,0xd7},\n  {0x89,0xe8},{0x13,0xe0},{0x00,0x00},{0x10,0x00},{0x0d,0x00},{0x14,0x28},{0xa5,0x05},{0xab,0x07},\n  {0x24,0x75},{0x25,0x63},{0x26,0xA5},{0x9f,0x78},{0xa0,0x68},{0xa1,0x03},{0xa6,0xdf},{0xa7,0xdf},\n  {0xa8,0xf0},{0xa9,0x90},{0xaa,0x94},{0x13,0xe5},{0x0e,0x61},{0x0f,0x4b},{0x16,0x02},{0x1e,0x37}, //{0x1e,0x17}\n  {0x21,0x02},{0x22,0x91},{0x29,0x07},{0x33,0x0b},{0x35,0x0b},{0x37,0x1d},{0x38,0x71},{0x39,0x2a},\n  {0x3c,0x78},{0x4d,0x40},{0x4e,0x20},{0x69,0x00},{0x6b,0x00},{0x74,0x19},{0x8d,0x4f},{0x8e,0x00},\n  {0x8f,0x00},{0x90,0x00},{0x91,0x00},{0x92,0x00},{0x96,0x00},{0x9a,0x80},{0xb0,0x84},{0xb1,0x0c},\n  {0xb2,0x0e},{0xb3,0x82},{0xb8,0x0a},{0x43,0x14},{0x44,0xf0},{0x45,0x34},{0x46,0x58},{0x47,0x28},\n  {0x48,0x3a},{0x59,0x88},{0x5a,0x88},{0x5b,0x44},{0x5c,0x67},{0x5d,0x49},{0x5e,0x0e},{0x64,0x04},\n  {0x65,0x20},{0x66,0x05},{0x94,0x04},{0x95,0x08},{0x6c,0x0a},{0x6d,0x55},{0x6e,0x11},{0x6f,0x9f},\n  {0x6a,0x40},{0x01,0x40},{0x02,0x40},{0x13,0xe7},{0x15,0x02},{0x4f,0x80},{0x50,0x80},{0x51,0x00},\n  {0x52,0x22},{0x53,0x5e},{0x54,0x80},{0x58,0x9e},{0x41,0x08},{0x3f,0x00},{0x75,0x05},{0x76,0xe1},\n  {0x4c,0x00},{0x77,0x01},{0x3d,0xc2},{0x4b,0x09},{0xc9,0x60},{0x41,0x38},{0x56,0x40},{0x34,0x11},\n  {0x3b,0x02},{0xa4,0x89},{0x96,0x00},{0x97,0x30},{0x98,0x20},{0x99,0x30},{0x9a,0x84},{0x9b,0x29},\n  {0x9c,0x03},{0x9d,0x4c},{0x9e,0x3f},{0x78,0x04},{0x79,0x01},{0xc8,0xf0},{0x79,0x0f},{0xc8,0x00},\n  {0x79,0x10},{0xc8,0x7e},{0x79,0x0a},{0xc8,0x80},{0x79,0x0b},{0xc8,0x01},{0x79,0x0c},{0xc8,0x0f},\n  {0x79,0x0d},{0xc8,0x20},{0x79,0x09},{0xc8,0x80},{0x79,0x02},{0xc8,0xc0},{0x79,0x03},{0xc8,0x40},\n  {0x79,0x05},{0xc8,0x30},{0x79,0x26},{0x09,0x03},{0x3b,0x42},{0xff,0xff},\n};        \n\nvoid error_led(void){\n  DDRB |= 32;//make sure led is output\n  while (1){//wait for reset\n    PORTB ^= 32;// toggle led\n    _delay_ms(100);\n  }\n}\n\nvoid twiStart(void){\n  TWCR = _BV(TWINT) | _BV(TWSTA) | _BV(TWEN);//send start\n  while (!(TWCR & (1 << TWINT)));//wait for start to be transmitted\n  if ((TWSR & 0xF8) != TW_START)\n    error_led();\n}\n\nvoid twiWriteByte(uint8_t DATA, uint8_t type){\n  TWDR = DATA;\n  TWCR = _BV(TWINT) | _BV(TWEN);\n  while (!(TWCR & (1 << TWINT))) {}\n  if ((TWSR & 0xF8) != type)\n    error_led();\n}\n\nvoid twiAddr(uint8_t addr, uint8_t typeTWI){\n  TWDR = addr;//send address\n  TWCR = _BV(TWINT) | _BV(TWEN);    /* clear interrupt to start transmission */\n  while ((TWCR & _BV(TWINT)) == 0); /* wait for transmission */\n  if ((TWSR & 0xF8) != typeTWI)\n    error_led();\n}\n\nvoid wrReg(uint8_t reg, uint8_t dat){\n  //send start condition\n  twiStart();\n  twiAddr(camAddr_WR, TW_MT_SLA_ACK);\n  twiWriteByte(reg, TW_MT_DATA_ACK);\n  twiWriteByte(dat, TW_MT_DATA_ACK);\n  TWCR = (1 << TWINT) | (1 << TWEN) | (1 << TWSTO);//send stop\n  _delay_ms(1);\n}\n\nstatic uint8_t twiRd(uint8_t nack){\n  if (nack){\n    TWCR = _BV(TWINT) | _BV(TWEN);\n    while ((TWCR & _BV(TWINT)) == 0); /* wait for transmission */\n    if ((TWSR & 0xF8) != TW_MR_DATA_NACK)\n      error_led();\n    return TWDR;\n  }\n  else{\n    TWCR = _BV(TWINT) | _BV(TWEN) | _BV(TWEA);\n    while ((TWCR & _BV(TWINT)) == 0); /* wait for transmission */\n    if ((TWSR & 0xF8) != TW_MR_DATA_ACK)\n      error_led();\n    return TWDR;\n  }\n}\n\nuint8_t rdReg(uint8_t reg){\n  uint8_t dat;\n  twiStart();\n  twiAddr(camAddr_WR, TW_MT_SLA_ACK);\n  twiWriteByte(reg, TW_MT_DATA_ACK);\n  TWCR = (1 << TWINT) | (1 << TWEN) | (1 << TWSTO);//send stop\n  _delay_ms(1);\n  twiStart();\n  twiAddr(camAddr_RD, TW_MR_SLA_ACK);\n  dat = twiRd(1);\n  TWCR = (1 << TWINT) | (1 << TWEN) | (1 << TWSTO);//send stop\n  _delay_ms(1);\n  return dat;\n}\n\nvoid wrSensorRegs8_8(const struct regval_list reglist[]){\n  uint8_t reg_addr, reg_val;\n  const struct regval_list *next = reglist;\n  while ((reg_addr != 0xff) | (reg_val != 0xff)){\n    reg_addr = pgm_read_byte(&next->reg_num);\n    reg_val = pgm_read_byte(&next->value);\n    wrReg(reg_addr, reg_val);\n    next++;\n  }\n}\n\nvoid arduinoUnoInut(void) {\n  //cli();//disable interrupts\n\n  /* Setup the 8mhz PWM clock  * This will be on pin 11*/\n  DDRB |= (1 << 3);//pin 11\n  ASSR &= ~(_BV(EXCLK) | _BV(AS2));\n  TCCR2A = (1 << COM2A0) | (1 << WGM21) | (1 << WGM20);\n  TCCR2B = (1 << WGM22) | (1 << CS20);\n  OCR2A = 0;//(F_CPU)/(2*(X+1))\n  DDRC &= ~15;//low d0-d3 camera\n  DDRD &= ~252;//d7-d4 and interrupt pins\n\n  //set up twi for 100khz\n  TWSR &= ~3;//disable prescaler for TWI\n  TWBR = 72;//set to 100khz\n\n  //enable serial\n  UBRR0H  = 0;\n  UBRR0L  = 1; // 0 = 2M baud rate. 1 = 1M baud. 3 = 0.5M. 7 = 250k 207 is 9600 baud rate.\n  UCSR0A |= 2;//double speed aysnc\n  UCSR0B  = (1 << RXEN0) | (1 << TXEN0);//Enable receiver and transmitter\n  UCSR0C  = 6;//async 1 stop bit 8bit char no parity bits\n}\n\nvoid camInit(void){\n  wrReg(0x12, 0x80); delay(100);\n  wrSensorRegs8_8(ov7670_default_regs);\n  wrReg(REG_COM10, 32);//PCLK does not toggle on HBLANK.\n  wrReg(0x70, 0x3a); wrReg(0x71, 0x35); wrReg(0x72, 0x11); wrReg(0x73, 0xf1); \n  wrReg(0x0c, 0x04);  wrReg(0x3e, 0x19); wrReg(0xa2, 0x02);\n  wrReg(0x13, 0x8f); // \n  //wrReg(0x71, 0xB5); // color bar\n}\n\nvoid cammode_select(){\n  int clksp;\n  if(cammd1) clksp =  6; \n  else             clksp = 11;\n  if(cammd0){ \n    wrReg(REG_COM7 , 0x14); wrReg(REG_COM15, 0xd0); // RGB565\n    wrReg(0x11, clksp*2-1); // Coloe Mode & Slow Speed\n  } else {\n    wrReg(REG_COM7 , 0x10); wrReg(REG_COM15, 0xc0); // YUYV\n    wrReg(0x11, clksp-1); //Earlier it had the value: wrReg(0x11, 12); New version works better for me :) !!!!\n  }  \n}\n\nuint8_t imgbf[320];\nstatic void captureImg(uint8_t rm0, uint8_t rm1, uint16_t wg, uint16_t hg){\n  uint16_t y, x;\n  uint8_t *imgwp,*imgrp; \n  while (!(PIND & 8));//wait for high\n  while ((PIND & 8));//wait for low\n  UDR0 = 0xff; // Start Mark\n  cli();\n  y = hg;\n  do{\n    x = wg / 2;\n    imgwp = &imgbf[0]; imgrp = &imgbf[0];\n    do{\n      while (!(PIND & 4)); while ((PIND & 4)); // Falling edge\n        UDR0 = (PINC & 15) | (PIND & 240);\n      while (!(PIND & 4)); while ((PIND & 4)); // Falling edge\n        if(rm0) \n          if(rm1) *imgwp++ = (PINC & 15) | (PIND & 240);\n          else    UDR0 = (PINC & 15) | (PIND & 240);\n      while (!(PIND & 4)); while ((PIND & 4)); // Falling edge\n        if(rm0 || !rm1) UDR0 = (PINC & 15) | (PIND & 240);\n        else            *imgwp++ = (PINC & 15) | (PIND & 240);\n      while (!(PIND & 4)); while ((PIND & 4)); // Falling edge\n        if(rm0) \n          if(rm1) *imgwp++ = (PINC & 15) | (PIND & 240);\n          else    UDR0 = (PINC & 15) | (PIND & 240);\n    } while (--x);\n    while(imgrp!=imgwp) {\n       if (UCSR0A & _BV(UDRE0)) UDR0 = *imgrp++;\n    }\n  } while (--y);\n  for( x=0; x<8; x++){ // End Mark\n    while (!(UCSR0A & (1 << UDRE0)));//wait for byte to transmit\n      UDR0 = 0;\n  }\n  sei();\n  //_delay_ms(100);\n}\n\nvoid wrOV7670Reg(unsigned char adr, unsigned char  dat){\n  wrReg( adr, dat);\n}\n\nvoid setup(){\n  arduinoUnoInut();\n  camInit(); \n  cammode_select();\n}\n\nint s22hex(char * ha){\n  int rc = 0,hi;\n  for(int i=0; i<2; i++){\n    char ch = *ha++;\n    if(ch>'9') hi = (ch & 0xdf)-0x37; else hi = ch-0x30;\n    rc = rc*16+hi;\n  }\n  return rc;\n}\nint rct = 0,repf = 0;\nchar rbf[16];\nbyte inChar = 0;\nchar * rbfp;\nvoid docmd(){\n  inChar = ' ';\n  if(UCSR0A & (1<<RXC0)){\n    byte kd = UDR0;\n    if(kd>=0x20) { rbf[rct++] = kd; return;\n    } else {\n      if(kd==0x08 && rct!=0) { rct--; return; } \n      else{ rbf[rct] = 0; inChar = rbf[0]; rbfp = &rbf[2]; rct = 0;}\n    }\n  } else if(repf==1) inChar = 'c';\n\n  if (inChar == 'c') {\n    if(rbf[1]==0){ \n      captureImg(cammd0,cammd1, 320, 240);\n    } else { \n      //camcolor = rbf[1]; \n      if((rbf[1] & 1)!=0) cammd0 = 1; else cammd0 = 0;\n      if((rbf[1] & 2)!=0) cammd1 = 1; else cammd1 = 0;\n      cammode_select();  \n    }\n  }\n  if (inChar == 'r') repf = 1-repf;\n  if (inChar == 's') { // Setup ov7670 Regs\n    byte adr = s22hex(&rbf[1]);\n    byte dat = s22hex(&rbf[3]);\n    if(adr==0xff) setup();\n    else wrReg( adr, dat);\n  }\n}\nvoid loop(){\n  docmd();\n}\n\n\n\n\u305d\u306e\u4ed6\n\u3000\u4e0a\u8a18\u8a18\u8f09\u306e\u30cf\u30fc\u30c9\u3001\u30bd\u30d5\u30c8\u306f\u7121\u4fdd\u8a3c\u3067\u3042\u308a\u3001\u5404\u81ea\u306e\u8cac\u4efb\u306b\u304a\u3044\u3066\u3054\u5229\u7528\u9858\u3044\u307e\u3059\u3002\n\u3000\n#\u30ab\u30e9\u30fc\u5316\u3068\u30b9\u30d4\u30fc\u30c9\u30a2\u30c3\u30d7\n[\uff3b\u305d\u306e\uff11\uff3d](http://qiita.com/hi631/items/d85cf031ecadf397b8e1)\u3067\u306f\u5143\u30cd\u30bf\u306b\u5f93\u3044\u3001Arduino\u306b\u30ab\u30e1\u30e9\u3092\u3064\u306a\u3050\u306e\u306f\u3046\u307e\u304f\u3044\u3063\u305f\u306e\u3067\u3001\u3082\u3063\u3068\u6a5f\u80fd\u3092\u6539\u5584\u3059\u308b\u3002\n## \u4f55\u3092\u3059\u308b\u304b\n (1)\u30ab\u30e9\u30fc\u5316\n\u3000\u3000\u5143\u30cd\u30bf\u306f\u30e2\u30ce\u30af\u30ed\u306a\u306e\u3067\u3053\u308c\u3092\u30ab\u30e9\u30fc\u5316\u3059\u308b\u4e8b\u306b\u3088\u308a\u3001\u8868\u73fe\u529b\u304c\u5411\u4e0a\u3059\u308b\u3002\n (2)\u753b\u50cf\u8868\u793a\u306e\u9ad8\u901f\u5316\n\u3000\u3000\u753b\u50cf\u8868\u793a\u901f\u5ea6\u3092\u65e9\u304f\u3059\u308b\u4e8b\u306b\u3088\u308a\u3001\u79fb\u52d5\u3059\u308b\u753b\u50cf\u306b\u591a\u5c11\u5f37\u304f\u306a\u308b\u3002\n\n## \uff11\uff0e\u30ab\u30e9\u30fc\u5316\n\u3000\u30ab\u30e9\u30fc\u753b\u50cf\u3092\u64ae\u5f71\u3059\u308b\u305f\u3081\u306b\u30ab\u30e1\u30e9\u306e\u753b\u50cf\u30d5\u30a9\u30fc\u30de\u30c3\u30c8\u3092RGB565\u306b\u5909\u66f4\u3059\u308b\u3002\n\u3000\u30c7\u30fc\u30bf\u304c\uff12\u30d0\u30a4\u30c8/\uff11\u30d4\u30af\u30bb\u30eb\u3068\uff12\u500d\u306b\u306a\u308b\u306e\u3067\u3001PCLK\u306e\u5909\u5316\u6bce\u306b\u30c7\u30fc\u30bf\u3092\u9001\u4fe1\u3059\u308b\u3002\n\u3000\u30c7\u30fc\u30bf\u3092\u9001\u308a\u5207\u308c\u306a\u304f\u306a\u308b\u306e\u3067\u3001PCLK\u3092\u534a\u5206\u306b\u9045\u304f\u3059\u308b\u3002\n\u3000\u203bov7670\u30ec\u30b8\u30b9\u30bf(0x11)\u3067XCLK\u3068PCLK\u306e\u5206\u5468\u6bd4\u3092\u8a2d\u5b9a\n\n\u3000\u30e2\u30ce\u30af\u30ed\u6642\n\u3000PCLK\u30925.5u\u3068\u3057\uff12\u30af\u30ed\u30c3\u30af\u6bce\u306b\u9001\u4fe1\n![sigmono.jpg](https://qiita-image-store.s3.amazonaws.com/0/159764/f298d63f-bad9-0c71-fba5-719c20d1c946.jpeg)\n\u3000\u30ab\u30e9\u30fc\u6642\n\u3000PCLK\u309210.5u\u3068\u3057\uff11\u30af\u30ed\u30c3\u30af\u6bce\u306b\u9001\u4fe1\n![sigcol.jpg](https://qiita-image-store.s3.amazonaws.com/0/159764/ee0e09c4-3657-2208-86b4-d3986636d15c.jpeg)\n\n\u3000\u753b\u50cf\u306e\u4f8b\n![testcolor.jpg](https://qiita-image-store.s3.amazonaws.com/0/159764/d1bd02c1-ae4c-4e53-696a-ea9425557c8a.jpeg)\n\u3000\u30ab\u30e1\u30e9\u306e\u521d\u671f\u5316\u306f\u30cd\u30c3\u30c8\u306e\u8a2d\u5b9a\u4f8b\u3092\u53c2\u8003\u306b\u3057\u305f\u304c\u3001\u6539\u5584\u306e\u4f59\u5730\u304c\u3042\u308b\u3088\u3046\u306a\n## \uff12\uff0e\u753b\u50cf\u8868\u793a\u306e\u9ad8\u901f\u5316\n\u3000\u753b\u50cf\u306e\u8868\u793a\u901f\u5ea6\u306f\u30b7\u30ea\u30a2\u30eb\u901a\u4fe1\u306e\u901f\u5ea6\u3067\u6291\u3048\u3089\u308c\u3066\u304a\u308a\u3001\u30b7\u30ea\u30a2\u30eb\u306e\u9ad8\u901f\u5316\u304c\u5fc5\u8981\u3067\u3042\u308a\u3001\u3053\u306e\u65b9\u6cd5\u3068\u3057\u3066\u6b21\u306e\uff12\u70b9\u3092\u691c\u8a0e\u3002\n (1)\u901a\u4fe1\u901f\u5ea6\u30a2\u30c3\u30d7\n\u3000\u3000\u6700\u59272Mbps\u8fc4UP\u53ef\u80fd\u3060\u304c\u3001\u5f53\u65b9\u306e\u74b0\u5883\u3067\u306f2Mbps\u306b\u8a2d\u5b9a\u3059\u308b\u3068\u30c7\u30fc\u30bf\u306e\u53d6\u308a\u3053\u307c\u3057\u304c\u767a\u751f\u3057\u305f\u3002\n\u3000\u3000\u30ce\u30a4\u30ba\u306b\u8d77\u56e0\u3057\u3066\u3044\u308b\u3088\u3046\u306b\u601d\u308f\u308c\u308b\u304c\u3001\u89e3\u6c7a\u306b\u6642\u9593\u304c\u304b\u304b\u308a\u305d\u3046\u306a\u306e\u3067\u3001\u3053\u306e\u65b9\u6cd5\u306f\u5374\u4e0b\u3002\n (2)\u7a7a\u304d\u6642\u9593\u3092\u3064\u3081\u308b\n\u3000\u3000PCLK\u306e\u6ce2\u5f62\u3092\u4fef\u77b0\u3057\u3066\u898b\u308b\u3068\u3001\u4e00\u884c\u5206\u306e\u30c7\u30fc\u30bf\u3068\u6b21\u306e\u753b\u50cf\u30c7\u30fc\u30bf\u3068\u306e\u9593\u9694\u304c\u304b\u306a\u308a\u7a7a\u3044\u3066\u3044\u308b\u4e8b\u304c\u5224\u308b\u3002\n\u3000\u3000\u3053\u308c\u306f\u3001OV7670\u3092QVGA\u306b\u8a2d\u5b9a\u3059\u308b\u3068\u3001\u5fc5\u8981\u306a\u753b\u50cf\u306f\u4e00\u884c\u304a\u304d\u306b\u767a\u751f\u3059\u308b\u304c\u3001\u30c7\u30fc\u30bf\u306e\u767a\u751f\u9593\u9694\u306f\u5909\u308f\u3089\u306a\u3044\u70ba\u3067\u3042\u308b\u3002\n\u3000\u3000\u305d\u3053\u3067\u7a7a\u304d\u6642\u9593\u306b\u4f1d\u9001\u3059\u308b\u65b9\u6cd5\u3092\u8003\u3048\u305f\u3002\n\u3000\u3000\u5e38\u5957\u624b\u6bb5\u3068\u3057\u3066\u306f\u30ea\u30f3\u30b0\u30d0\u30c3\u30d5\u30a1\u304c\u8003\u3048\u3089\u308c\u308b\u304c\u3001arduino(16M)\u3067\u306f\u51e6\u7406\u80fd\u529b\u304c\u8db3\u308a\u305a\u3001\u51e6\u7406\u843d\u3061\u304c\u767a\u751f\u3057\u305f\u3002\n\u3000\u3000\u305d\u3053\u3067\u3001\uff11\u30d0\u30a4\u30c8\u76ee\u306f\u30c7\u30fc\u30bf\u306e\u76f4\u63a5\u9001\u4fe1\u3092\u3001\uff12\u30d0\u30a4\u30c8\u76ee\u306f\u30d0\u30c3\u30d5\u30a1\u30ea\u30f3\u30b0\u3059\u308b\u4e8b\u306b\u3088\u308a\u3001\uff12\u500d\u306ePCLK\u3067\u3082\u5468\u671f\u5185\u3067\u306e\u9001\u4fe1\u51e6\u7406\u304c\u53ef\u80fd\u3068\u306a\u3063\u305f\u3002\n\u3000\u3000\u30d0\u30c3\u30d5\u30a1\u30ea\u30f3\u30b0\u3057\u305f\u30c7\u30fc\u30bf\u306f\u7a7a\u304d\u6642\u9593\u306b\u9001\u4fe1\u3059\u308b\u3002\n\u3000\u3000\u307e\u305f\u3001\u3053\u308c\u306b\u3088\u308a\u9001\u4fe1\u30c7\u30fc\u30bf\u306f\u30b7\u30fc\u30b1\u30f3\u30b7\u30e3\u30eb\u306b\u306a\u3089\u306a\u3044\u304c\u3001\u3053\u308c\u306f\u8868\u793a\u30bd\u30d5\u30c8\u3067\u4e26\u3073\u66ff\u3048\u308b\u4e8b\u306b\u3057\u305f\u3002\n\n\u3000\u8868\u793a\u30bd\u30d5\u30c8\u306e\u8aac\u660e\n\u3000[\uff3b\u305d\u306e\uff12\u3000\u753b\u50cf\u306e\u8868\u793a\uff3d](http://qiita.com/hi631/items/94fa041a13714377332f)\n\n\u3000\u3000\u3053\u308c\u306b\u3088\u308a\u901a\u4fe1\u901f\u5ea6\u306f\u7d04\uff12\u500d\u3068\u306a\u308a\u3001\u30e2\u30ce\u30af\u30ed\u3067\u306f\u7d04\uff11\u79d2(1.1s)\u3067\u753b\u50cf\u306e\u66f4\u65b0\u304c\u53ef\u80fd\u3068\u306a\u3063\u305f\u3002\n\n\u3000PCLK\u3068\u540c\u671f\u3057\u3066\u9001\u4fe1\n\u3000(CH0.PCLK CH1.\u30b7\u30ea\u30a2\u30eb\u9001\u4fe1)\n![sigslow.jpg](https://qiita-image-store.s3.amazonaws.com/0/159764/2f72cae3-37de-d99d-59fa-a3e07fb50c38.jpeg)\n\u3000\u30d0\u30c3\u30d5\u30a1\u30ea\u30f3\u30b0\u3057\u3066\u3001\u7a7a\u304d\u6642\u9593\u306b\u3082\u9001\u4fe1\n![sigfast.jpg](https://qiita-image-store.s3.amazonaws.com/0/159764/6a048370-b42b-b815-6a59-574ba05c32fc.jpeg)\n\n\u300cuno_ov7670.ino\u300dver1.1\n\n```\n// Source code for application to transmit image from ov7670 to PC via USB\n// By Siarhei Charkes in 2015\n// http://privateblog.info \n\n#include <stdint.h>\n#include <avr/io.h>\n#include <util/twi.h>\n#include <util/delay.h>\n#include <avr/pgmspace.h>\n\n#define camAddr_WR  0x42\n#define camAddr_RD  0x43\n#define REG_COM7  0x12\n#define REG_COM10 0x15  // Control 10 //\n#define REG_COM14 0x3e  // Control 14 //\n#define REG_COM15 0x40  // Control 15 //\n\nuint8_t cammd0=0, cammd1=0;\nstruct regval_list{ uint8_t reg_num; uint16_t value; };\nconst struct regval_list ov7670_default_regs[] PROGMEM = {\n  {0x3a,0x04},{0x40,0xd0},{0x12,0x14},{0x32,0x80},{0x17,0x16},{0x18,0x04},{0x19,0x02},{0x1a,0x7b},\n  {0x03,0x06},{0x0c,0x00},{0x3e,0x00},{0x70,0x00},{0x71,0x00},{0x72,0x11},{0x73,0x00},{0xa2,0x02},\n  {0x11,0x81},{0x7a,0x20},{0x7b,0x1c},{0x7c,0x28},{0x7d,0x3c},{0x7e,0x55},{0x7f,0x68},{0x80,0x76},\n  {0x81,0x80},{0x82,0x88},{0x83,0x8f},{0x84,0x96},{0x85,0xa3},{0x86,0xaf},{0x87,0xc4},{0x88,0xd7},\n  {0x89,0xe8},{0x13,0xe0},{0x00,0x00},{0x10,0x00},{0x0d,0x00},{0x14,0x28},{0xa5,0x05},{0xab,0x07},\n  {0x24,0x75},{0x25,0x63},{0x26,0xA5},{0x9f,0x78},{0xa0,0x68},{0xa1,0x03},{0xa6,0xdf},{0xa7,0xdf},\n  {0xa8,0xf0},{0xa9,0x90},{0xaa,0x94},{0x13,0xe5},{0x0e,0x61},{0x0f,0x4b},{0x16,0x02},{0x1e,0x37}, //{0x1e,0x17}\n  {0x21,0x02},{0x22,0x91},{0x29,0x07},{0x33,0x0b},{0x35,0x0b},{0x37,0x1d},{0x38,0x71},{0x39,0x2a},\n  {0x3c,0x78},{0x4d,0x40},{0x4e,0x20},{0x69,0x00},{0x6b,0x00},{0x74,0x19},{0x8d,0x4f},{0x8e,0x00},\n  {0x8f,0x00},{0x90,0x00},{0x91,0x00},{0x92,0x00},{0x96,0x00},{0x9a,0x80},{0xb0,0x84},{0xb1,0x0c},\n  {0xb2,0x0e},{0xb3,0x82},{0xb8,0x0a},{0x43,0x14},{0x44,0xf0},{0x45,0x34},{0x46,0x58},{0x47,0x28},\n  {0x48,0x3a},{0x59,0x88},{0x5a,0x88},{0x5b,0x44},{0x5c,0x67},{0x5d,0x49},{0x5e,0x0e},{0x64,0x04},\n  {0x65,0x20},{0x66,0x05},{0x94,0x04},{0x95,0x08},{0x6c,0x0a},{0x6d,0x55},{0x6e,0x11},{0x6f,0x9f},\n  {0x6a,0x40},{0x01,0x40},{0x02,0x40},{0x13,0xe7},{0x15,0x02},{0x4f,0x80},{0x50,0x80},{0x51,0x00},\n  {0x52,0x22},{0x53,0x5e},{0x54,0x80},{0x58,0x9e},{0x41,0x08},{0x3f,0x00},{0x75,0x05},{0x76,0xe1},\n  {0x4c,0x00},{0x77,0x01},{0x3d,0xc2},{0x4b,0x09},{0xc9,0x60},{0x41,0x38},{0x56,0x40},{0x34,0x11},\n  {0x3b,0x02},{0xa4,0x89},{0x96,0x00},{0x97,0x30},{0x98,0x20},{0x99,0x30},{0x9a,0x84},{0x9b,0x29},\n  {0x9c,0x03},{0x9d,0x4c},{0x9e,0x3f},{0x78,0x04},{0x79,0x01},{0xc8,0xf0},{0x79,0x0f},{0xc8,0x00},\n  {0x79,0x10},{0xc8,0x7e},{0x79,0x0a},{0xc8,0x80},{0x79,0x0b},{0xc8,0x01},{0x79,0x0c},{0xc8,0x0f},\n  {0x79,0x0d},{0xc8,0x20},{0x79,0x09},{0xc8,0x80},{0x79,0x02},{0xc8,0xc0},{0x79,0x03},{0xc8,0x40},\n  {0x79,0x05},{0xc8,0x30},{0x79,0x26},{0x09,0x03},{0x3b,0x42},{0xff,0xff},\n};        \n\nvoid error_led(void){\n  DDRB |= 32;//make sure led is output\n  while (1){//wait for reset\n    PORTB ^= 32;// toggle led\n    _delay_ms(100);\n  }\n}\n\nvoid twiStart(void){\n  TWCR = _BV(TWINT) | _BV(TWSTA) | _BV(TWEN);//send start\n  while (!(TWCR & (1 << TWINT)));//wait for start to be transmitted\n  if ((TWSR & 0xF8) != TW_START)\n    error_led();\n}\n\nvoid twiWriteByte(uint8_t DATA, uint8_t type){\n  TWDR = DATA;\n  TWCR = _BV(TWINT) | _BV(TWEN);\n  while (!(TWCR & (1 << TWINT))) {}\n  if ((TWSR & 0xF8) != type)\n    error_led();\n}\n\nvoid twiAddr(uint8_t addr, uint8_t typeTWI){\n  TWDR = addr;//send address\n  TWCR = _BV(TWINT) | _BV(TWEN);    /* clear interrupt to start transmission */\n  while ((TWCR & _BV(TWINT)) == 0); /* wait for transmission */\n  if ((TWSR & 0xF8) != typeTWI)\n    error_led();\n}\n\nvoid wrReg(uint8_t reg, uint8_t dat){\n  //send start condition\n  twiStart();\n  twiAddr(camAddr_WR, TW_MT_SLA_ACK);\n  twiWriteByte(reg, TW_MT_DATA_ACK);\n  twiWriteByte(dat, TW_MT_DATA_ACK);\n  TWCR = (1 << TWINT) | (1 << TWEN) | (1 << TWSTO);//send stop\n  _delay_ms(1);\n}\n\nstatic uint8_t twiRd(uint8_t nack){\n  if (nack){\n    TWCR = _BV(TWINT) | _BV(TWEN);\n    while ((TWCR & _BV(TWINT)) == 0); /* wait for transmission */\n    if ((TWSR & 0xF8) != TW_MR_DATA_NACK)\n      error_led();\n    return TWDR;\n  }\n  else{\n    TWCR = _BV(TWINT) | _BV(TWEN) | _BV(TWEA);\n    while ((TWCR & _BV(TWINT)) == 0); /* wait for transmission */\n    if ((TWSR & 0xF8) != TW_MR_DATA_ACK)\n      error_led();\n    return TWDR;\n  }\n}\n\nuint8_t rdReg(uint8_t reg){\n  uint8_t dat;\n  twiStart();\n  twiAddr(camAddr_WR, TW_MT_SLA_ACK);\n  twiWriteByte(reg, TW_MT_DATA_ACK);\n  TWCR = (1 << TWINT) | (1 << TWEN) | (1 << TWSTO);//send stop\n  _delay_ms(1);\n  twiStart();\n  twiAddr(camAddr_RD, TW_MR_SLA_ACK);\n  dat = twiRd(1);\n  TWCR = (1 << TWINT) | (1 << TWEN) | (1 << TWSTO);//send stop\n  _delay_ms(1);\n  return dat;\n}\n\nvoid wrSensorRegs8_8(const struct regval_list reglist[]){\n  uint8_t reg_addr, reg_val;\n  const struct regval_list *next = reglist;\n  while ((reg_addr != 0xff) | (reg_val != 0xff)){\n    reg_addr = pgm_read_byte(&next->reg_num);\n    reg_val = pgm_read_byte(&next->value);\n    wrReg(reg_addr, reg_val);\n    next++;\n  }\n}\n\nvoid arduinoUnoInut(void) {\n  //cli();//disable interrupts\n  \n  /* Setup the 8mhz PWM clock  * This will be on pin 11*/\n  DDRB |= (1 << 3);//pin 11\n  ASSR &= ~(_BV(EXCLK) | _BV(AS2));\n  TCCR2A = (1 << COM2A0) | (1 << WGM21) | (1 << WGM20);\n  TCCR2B = (1 << WGM22) | (1 << CS20);\n  OCR2A = 0;//(F_CPU)/(2*(X+1))\n  DDRC &= ~15;//low d0-d3 camera\n  DDRD &= ~252;//d7-d4 and interrupt pins\n  \n  //set up twi for 100khz\n  TWSR &= ~3;//disable prescaler for TWI\n  TWBR = 72;//set to 100khz\n  \n  //enable serial\n  UBRR0H  = 0;\n  UBRR0L  = 1; // 0 = 2M baud rate. 1 = 1M baud. 3 = 0.5M. 7 = 250k 207 is 9600 baud rate.\n  UCSR0A |= 2;//double speed aysnc\n  UCSR0B  = (1 << RXEN0) | (1 << TXEN0);//Enable receiver and transmitter\n  UCSR0C  = 6;//async 1 stop bit 8bit char no parity bits\n}\n\nvoid camInit(void){\n  wrReg(0x12, 0x80); delay(100);\n  wrSensorRegs8_8(ov7670_default_regs);\n  wrReg(REG_COM10, 32);//PCLK does not toggle on HBLANK.\n  wrReg(0x70, 0x3a); wrReg(0x71, 0x35); wrReg(0x72, 0x11); wrReg(0x73, 0xf1); \n  wrReg(0x0c, 0x04);  wrReg(0x3e, 0x19); wrReg(0xa2, 0x02);\n  wrReg(0x13, 0x8f); // \n  //wrReg(0x71, 0xB5); // color bar\n}\n\nvoid cammode_select(){\n  int clksp;\n  if(cammd1) clksp =  6; \n  else             clksp = 11;\n  if(cammd0){ \n    wrReg(REG_COM7 , 0x14); wrReg(REG_COM15, 0xd0); // RGB565\n    wrReg(0x11, clksp*2-1); // Coloe Mode & Slow Speed\n  } else {\n    wrReg(REG_COM7 , 0x10); wrReg(REG_COM15, 0xc0); // YUYV\n    wrReg(0x11, clksp-1); //Earlier it had the value: wrReg(0x11, 12); New version works better for me :) !!!!\n  }  \n}\n\nuint8_t imgbf[320];\nstatic void captureImg(uint8_t rm0, uint8_t rm1, uint16_t wg, uint16_t hg){\n  uint16_t y, x;\n  uint8_t *imgwp,*imgrp; \n  while (!(PIND & 8));//wait for high\n  while ((PIND & 8));//wait for low\n  UDR0 = 0xff; // Start Mark\n  cli();\n  y = hg;\n  do{\n    x = wg / 2;\n    imgwp = &imgbf[0]; imgrp = &imgbf[0];\n    do{\n      while (!(PIND & 4)); while ((PIND & 4)); // Falling edge\n        UDR0 = (PINC & 15) | (PIND & 240);\n      while (!(PIND & 4)); while ((PIND & 4)); // Falling edge\n        if(rm0) \n          if(rm1) *imgwp++ = (PINC & 15) | (PIND & 240);\n          else    UDR0 = (PINC & 15) | (PIND & 240);\n      while (!(PIND & 4)); while ((PIND & 4)); // Falling edge\n        if(rm0 || !rm1) UDR0 = (PINC & 15) | (PIND & 240);\n        else            *imgwp++ = (PINC & 15) | (PIND & 240);\n      while (!(PIND & 4)); while ((PIND & 4)); // Falling edge\n        if(rm0) \n          if(rm1) *imgwp++ = (PINC & 15) | (PIND & 240);\n          else    UDR0 = (PINC & 15) | (PIND & 240);\n    } while (--x);\n    while(imgrp!=imgwp) {\n       if (UCSR0A & _BV(UDRE0)) UDR0 = *imgrp++;\n    }\n  } while (--y);\n  for( x=0; x<8; x++){ // End Mark\n    while (!(UCSR0A & (1 << UDRE0)));//wait for byte to transmit\n      UDR0 = 0;\n  }\n  sei();\n  //_delay_ms(100);\n}\n\nvoid wrOV7670Reg(unsigned char adr, unsigned char  dat){\n  wrReg( adr, dat);\n}\n\nvoid setup(){\n  arduinoUnoInut();\n  camInit(); \n  cammode_select();\n}\n\nint s22hex(char * ha){\n  int rc = 0,hi;\n  for(int i=0; i<2; i++){\n    char ch = *ha++;\n    if(ch>'9') hi = (ch & 0xdf)-0x37; else hi = ch-0x30;\n    rc = rc*16+hi;\n  }\n  return rc;\n}\nint rct = 0,repf = 0;\nchar rbf[16];\nbyte inChar = 0;\nchar * rbfp;\nvoid docmd(){\n  inChar = ' ';\n  if(UCSR0A & (1<<RXC0)){\n    byte kd = UDR0;\n    if(kd>=0x20) { rbf[rct++] = kd; return;\n    } else {\n      if(kd==0x08 && rct!=0) { rct--; return; } \n      else{ rbf[rct] = 0; inChar = rbf[0]; rbfp = &rbf[2]; rct = 0;}\n    }\n  } else if(repf==1) inChar = 'c';\n\n  if (inChar == 'c') {\n    if(rbf[1]==0){ \n      captureImg(cammd0,cammd1, 320, 240);\n    } else { \n      //camcolor = rbf[1]; \n      if((rbf[1] & 1)!=0) cammd0 = 1; else cammd0 = 0;\n      if((rbf[1] & 2)!=0) cammd1 = 1; else cammd1 = 0;\n      cammode_select();  \n    }\n  }\n  if (inChar == 'r') repf = 1-repf;\n  if (inChar == 's') { // Setup ov7670 Regs\n    byte adr = s22hex(&rbf[1]);\n    byte dat = s22hex(&rbf[3]);\n    if(adr==0xff) setup();\n    else wrReg( adr, dat);\n  }\n}\nvoid loop(){\n  docmd();\n}\n\n```\n\n## \u305d\u306e\u4ed6\n\u3000\u4e0a\u8a18\u8a18\u8f09\u306e\u30cf\u30fc\u30c9\u3001\u30bd\u30d5\u30c8\u306f\u7121\u4fdd\u8a3c\u3067\u3042\u308a\u3001\u5404\u81ea\u306e\u8cac\u4efb\u306b\u304a\u3044\u3066\u3054\u5229\u7528\u9858\u3044\u307e\u3059\u3002\n\n\u3000\n"}