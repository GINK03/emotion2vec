{"context": " More than 1 year has passed since last update.\u3053\u306e\u8a18\u4e8b\u306fOpenCV Advent Calendar 2015\u306e14\u65e5\u76ee\u306e\u8a18\u4e8b\u3067\u3059\uff0e\n\n\u306f\u3058\u3081\u306b\nOpenCV 3.0\u304b\u3089\u30ec\u30f3\u30b8\u306e\u8981\u7d20\u3059\u3079\u3066\u306b\u6307\u5b9a\u3055\u308c\u305f\u95a2\u6570\u3092\u9069\u7528\u3059\u308bcv::Mat::forEach\u30e1\u30bd\u30c3\u30c9\u304c\u8ffd\u52a0\u3055\u308c\u307e\u3057\u305f\uff0e\u8a73\u7d30\u306f\u516c\u5f0f\u30c9\u30ad\u30e5\u30e1\u30f3\u30c8\u3092\u53c2\u7167\u304f\u3060\u3055\u3044\uff0e\n\u307e\u305f\uff0c\u3053\u306e\u6a5f\u80fd\u306fkazuki-ma\u6c0f\u306b\u3088\u3063\u3066\u5b9f\u88c5\u304c\u884c\u308f\u308c\u305f\u3082\u306e\u3067\u3042\u308a\uff0cPull Request\u306e\u3084\u308a\u53d6\u308a\u306fhttps://github.com/Itseez/opencv/pull/2117\u306b\u3066\u8aad\u3080\u3053\u3068\u304c\u3067\u304d\u307e\u3059\uff0e\n\u666e\u6bb5C++(C++11\u4ee5\u964d)\u3092\u4f7f\u3063\u3066\u3044\u308b\u65b9\u3060\u3068std::for_each\u306eMat\u7248\u307f\u305f\u3044\u306a\u3082\u306e\u3068\u8003\u3048\u308b\u3068\u30a4\u30e1\u30fc\u30b8\u3057\u3084\u3059\u3044\u304b\u3082\u3057\u308c\u307e\u305b\u3093\uff0e\n\ncv::Mat::forEach\u30e1\u30bd\u30c3\u30c9\u306e\u5185\u90e8\u51e6\u7406\n\u3068\u3044\u3046\u3053\u3068\u3067\uff0cmodules/core/include/opencv2/core/utility.hpp\u306b\u3042\u308bMat::forEach_impl\u306e\u4e2d\u8eab\u3092\u8ffd\u3063\u3066\u307f\u307e\u3057\u3087\u3046\uff0e\u4ee5\u964d\uff0cMat::forEach_impl\u306e\u5185\u90e8\u51e6\u7406\u3067\u91cd\u8981\u306a\u3068\u3053\u308d\u3092\u30d4\u30c3\u30af\u30a2\u30c3\u30d7\u3057\u3066\u7d39\u4ecb\u3057\u307e\u3059\uff0e\n\u9014\u4e2d\u3067\u51fa\u3066\u304f\u308bcv::ParallelLoopBody\u3084cv::parallel_for_\u306f@fukushima1981\u3055\u3093\u306e\u8a18\u4e8b\u3084\u7b46\u8005\u306ewiki\u3092\u53c2\u8003\u306b\u3057\u3066\u4e0b\u3055\u3044\uff0e\n\n1. \u30e9\u30a4\u30f3\u6570\u3092\u8a08\u7b97\u3059\u308b\nconst int LINES = static_cast<int>(this->total() / this->size[this->dims - 1]);\n\n\n2. ParallelLoopBody\u30af\u30e9\u30b9\u3092\u7d99\u627f\u3057\u305f\u30d4\u30af\u30bb\u30eb\u64cd\u4f5c\u95a2\u6570\u3092\u7528\u610f\u3059\u308b\nParallelLoopBody\u30af\u30e9\u30b9\u3092\u7d99\u627f\u3057\u305f\u30d4\u30af\u30bb\u30eb\u64cd\u4f5c\u95a2\u6570\u3092\u5b9f\u88c5\u3057\u3066\u3044\u307e\u3059\uff0e\nclass PixelOperationWrapper :public ParallelLoopBody\n{\npublic:\n    PixelOperationWrapper(Mat_<_Tp>* const frame, const Functor& _operation)\n        : mat(frame), op(_operation) {};\n    virtual ~PixelOperationWrapper(){};\n    // ! Overloaded virtual operator\n    // convert range call to row call.\n    virtual void operator()(const Range &range) const {\n        const int DIMS = mat->dims;\n        const int COLS = mat->size[DIMS - 1];\n\n\n3. parallel_for_\u3092\u4f7f\u3063\u3066\u4e26\u5217\u51e6\u7406\u3059\u308b\nparallel_for_\u306b\u3088\u3063\u3066\u30d4\u30af\u30bb\u30eb\u64cd\u4f5c\u3092\u4e26\u5217\u51e6\u7406\u3057\u307e\u3059\uff0e\u305d\u306e\u305f\u3081\uff0c\u30de\u30eb\u30c1\u30b3\u30a2\u74b0\u5883\u3067\u3042\u308c\u3070\u30d1\u30d5\u30a9\u30fc\u30de\u30f3\u30b9\u5411\u4e0a\u304c\u671f\u5f85\u3067\u304d\u307e\u3059\uff0e\nparallel_for_(cv::Range(0, LINES), PixelOperationWrapper(reinterpret_cast<Mat_<_Tp>*>(this), operation));\n\n\n\u30b5\u30f3\u30d7\u30eb\u30b3\u30fc\u30c9\n\u4ee5\u4e0b\u306bcv::Mat::forEach\u30e1\u30bd\u30c3\u30c9\u3068at\u30e1\u30bd\u30c3\u30c9\uff08\u6bd4\u8f03\u7528\uff09\uff0c\u30a4\u30c6\u30ec\u30fc\u30bf\uff08\u6bd4\u8f03\u7528\uff09\uff0c\u30dd\u30a4\u30f3\u30bf\uff08\u6bd4\u8f03\u7528\uff09\u3067\u30d4\u30af\u30bb\u30eb\u306b\u30a2\u30af\u30bb\u30b9\u3059\u308b\u30b5\u30f3\u30d7\u30eb\u30b3\u30fc\u30c9\u3092\u793a\u3057\u307e\u3059\uff0e\n#include <opencv2/core.hpp>\n#include <iostream>\n\n// \u753b\u50cf\u30b5\u30a4\u30ba\u306e\u5b9a\u6570\nconst cv::Size szXGA = cv::Size(1024, 768);\nconst cv::Size sz720p = cv::Size(1280, 720);\nconst cv::Size sz1080p = cv::Size(1920, 1080);\n\n// \u8a08\u6e2c\u7528\u30de\u30af\u30ed\n#define MEASUREMENT(func_name, sz, loop) \\\n    measurement(#func_name, func_name, sz, loop);\n\nvoid measurement(const std::string func_name,\n    void func(cv::Mat &), cv::Size sz, int loop)\n{\n    cv::Mat image = cv::Mat::zeros(sz, CV_8UC3);\n    double f = 1000.0f / cv::getTickFrequency();\n    int64 start = cv::getTickCount();\n    for (int i = 0; i < loop; i++)\n    {\n        func(image);\n    }\n    int64 end = cv::getTickCount();\n    std::cout << func_name << \": \" << (end - start) * f << \"[ms]\" << std::endl;\n}\n\n// at\u30e1\u30bd\u30c3\u30c9\u306b\u3088\u308b\u30d4\u30af\u30bb\u30eb\u64cd\u4f5c\nvoid atAccess(cv::Mat &src)\n{\n    for (int y = 0; y < src.rows; y++)\n    {\n        for (int x = 0; x < src.cols; x++)\n        {\n            src.at<cv::Vec3b>(y, x)[0] = 0;\n            src.at<cv::Vec3b>(y, x)[1] = 0;\n            src.at<cv::Vec3b>(y, x)[2] = 255;\n        }\n    }\n}\n\n// \u30a4\u30c6\u30ec\u30fc\u30bf\u306b\u3088\u308b\u30d4\u30af\u30bb\u30eb\u64cd\u4f5c\nvoid iteratorAccess(cv::Mat &src)\n{\n    cv::MatIterator_<cv::Vec3b> itr = src.begin<cv::Vec3b>();\n    cv::MatIterator_<cv::Vec3b> itr_end = src.end<cv::Vec3b>();\n\n    for (int i = 0; itr != itr_end; itr++, i++)\n    {\n        cv::Vec3b bgr = (*itr);\n\n        (*itr)[0] = 0;\n        (*itr)[1] = 0;\n        (*itr)[2] = 255;\n    }\n}\n\n// \u30dd\u30a4\u30f3\u30bf\u306b\u3088\u308b\u30d4\u30af\u30bb\u30eb\u64cd\u4f5c\nvoid pointerAccess(cv::Mat &src)\n{\n    for (int y = 0; y < src.rows; y++)\n    {\n        cv::Vec3b *p = &src.at<cv::Vec3b>(y, 0);\n        for (int x = 0; x < src.cols; x++)\n        {\n            (*p)[0] = 0;\n            (*p)[1] = 0;\n            (*p)[2] = 255;\n            p++;\n        }\n    }\n}\n\n// cv::Mat::forEach\u30e1\u30bd\u30c3\u30c9\u306b\u3088\u308b\u30d4\u30af\u30bb\u30eb\u64cd\u4f5c\nvoid forEachAccess(cv::Mat &src)\n{\n    src.forEach<cv::Vec3b>([](cv::Vec3b &p, const int * position) -> void {\n        p[0] = 0;\n        p[1] = 0;\n        p[2] = 255;\n    });\n}\n\nint main(int argc, char *argv[])\n{\n    int loop = 100;\n\n    std::cout << \"[XGA]\" << std::endl;\n    MEASUREMENT(atAccess, szXGA, loop);\n    MEASUREMENT(iteratorAccess, szXGA, loop);\n    MEASUREMENT(pointerAccess, szXGA, loop);\n    MEASUREMENT(forEachAccess, szXGA, loop);\n\n    std::cout << \"\\n[720p]\" << std::endl;\n    MEASUREMENT(atAccess, sz720p, loop);\n    MEASUREMENT(iteratorAccess, sz720p, loop);\n    MEASUREMENT(pointerAccess, sz720p, loop);\n    MEASUREMENT(forEachAccess, sz720p, loop);\n\n    std::cout << \"\\n[1080p]\" << std::endl;\n    MEASUREMENT(atAccess, sz1080p, loop);\n    MEASUREMENT(iteratorAccess, sz1080p, loop);\n    MEASUREMENT(pointerAccess, sz1080p, loop);\n    MEASUREMENT(forEachAccess, sz1080p, loop);\n\n    return 0;\n}\n\n\n\u30d1\u30d5\u30a9\u30fc\u30de\u30f3\u30b9\n\u524d\u8ff0\u306e\u30b5\u30f3\u30d7\u30eb\u30b3\u30fc\u30c9\u3092\u5b9f\u884c\u3055\u305b\u305f\u7d50\u679c\u306f\u4ee5\u4e0b\u306e\u901a\u308a\u3067\u3059\uff0e\n\u3053\u306e\u7d50\u679c\u304b\u3089\u3082\u308f\u304b\u308b\u3088\u3046\u306bcv::Mat::forEach\u30e1\u30bd\u30c3\u30c9\u306e\u65b9\u304c\u9ad8\u901f\u306b\u51e6\u7406\u3067\u304d\u3066\u3044\u308b\u3053\u3068\u304c\u308f\u304b\u308a\u307e\u3059\uff0e\n\n[XGA]\natAccess: 192.748[ms]\niteratorAccess: 194.007[ms]\npointerAccess: 55.3249[ms]\nforEachAccess: 12.6574[ms]\n\n[720p]\natAccess: 225.619[ms]\niteratorAccess: 228.75[ms]\npointerAccess: 64.8113[ms]\nforEachAccess: 12.4458[ms]\n\n[1080p]\natAccess: 509.205[ms]\niteratorAccess: 517.512[ms]\npointerAccess: 145.582[ms]\nforEachAccess: 25.1963[ms]\n\n\u307e\u305f\uff0c\u7b46\u8005\u306e\u8a08\u6e2c\u74b0\u5883\u306f\u4ee5\u4e0b\u306e\u901a\u308a\u3067\u3059\uff0e\nCPU\uff1aIntel Core i7-3930K 3.20GHz\n\u30e1\u30e2\u30ea\uff1a32GB\n\n\u304a\u308f\u308a\u306b\n\u3053\u306e\u8a18\u4e8b\u3067\u306fcv::Mat::forEach\u30e1\u30bd\u30c3\u30c9\u306e\u5185\u90e8\u51e6\u7406\u304a\u3088\u3073\u4f7f\u3044\u65b9\u3092\u7d39\u4ecb\u3057\u307e\u3057\u305f\uff0e\n\n\u5099\u8003\n\u7b46\u8005\u306f\u4ee5\u4e0b\u306e\u74b0\u5883\u3067\u52d5\u4f5c\u78ba\u8a8d\u3057\u307e\u3057\u305f\uff0e\n\nOpenCV 3.0.0\nWindows 8.1 Pro\uff0864bit\uff09\nVisual Studio 2013 Update5\n\n\u3053\u306e\u8a18\u4e8b\u306f[OpenCV Advent Calendar 2015](http://qiita.com/advent-calendar/2015/opencv)\u306e14\u65e5\u76ee\u306e\u8a18\u4e8b\u3067\u3059\uff0e\n\n# \u306f\u3058\u3081\u306b\nOpenCV 3.0\u304b\u3089\u30ec\u30f3\u30b8\u306e\u8981\u7d20\u3059\u3079\u3066\u306b\u6307\u5b9a\u3055\u308c\u305f\u95a2\u6570\u3092\u9069\u7528\u3059\u308b**cv::Mat::forEach**\u30e1\u30bd\u30c3\u30c9\u304c\u8ffd\u52a0\u3055\u308c\u307e\u3057\u305f\uff0e\u8a73\u7d30\u306f[\u516c\u5f0f\u30c9\u30ad\u30e5\u30e1\u30f3\u30c8](http://docs.opencv.org/master/d3/d63/classcv_1_1Mat.html#a952ef1a85d70a510240cb645a90efc0d)\u3092\u53c2\u7167\u304f\u3060\u3055\u3044\uff0e\n\n\u307e\u305f\uff0c\u3053\u306e\u6a5f\u80fd\u306f[kazuki-ma](https://github.com/kazuki-ma)\u6c0f\u306b\u3088\u3063\u3066\u5b9f\u88c5\u304c\u884c\u308f\u308c\u305f\u3082\u306e\u3067\u3042\u308a\uff0cPull Request\u306e\u3084\u308a\u53d6\u308a\u306f<https://github.com/Itseez/opencv/pull/2117>\u306b\u3066\u8aad\u3080\u3053\u3068\u304c\u3067\u304d\u307e\u3059\uff0e\n\n\u666e\u6bb5C++(C++11\u4ee5\u964d)\u3092\u4f7f\u3063\u3066\u3044\u308b\u65b9\u3060\u3068[std::for_each](http://en.cppreference.com/w/cpp/algorithm/for_each)\u306eMat\u7248\u307f\u305f\u3044\u306a\u3082\u306e\u3068\u8003\u3048\u308b\u3068\u30a4\u30e1\u30fc\u30b8\u3057\u3084\u3059\u3044\u304b\u3082\u3057\u308c\u307e\u305b\u3093\uff0e\n\n# cv::Mat::forEach\u30e1\u30bd\u30c3\u30c9\u306e\u5185\u90e8\u51e6\u7406\n\u3068\u3044\u3046\u3053\u3068\u3067\uff0c<code>modules/core/include/opencv2/core/utility.hpp</code>\u306b\u3042\u308b**Mat::forEach_impl**\u306e\u4e2d\u8eab\u3092\u8ffd\u3063\u3066\u307f\u307e\u3057\u3087\u3046\uff0e\u4ee5\u964d\uff0c**Mat::forEach_impl**\u306e\u5185\u90e8\u51e6\u7406\u3067\u91cd\u8981\u306a\u3068\u3053\u308d\u3092\u30d4\u30c3\u30af\u30a2\u30c3\u30d7\u3057\u3066\u7d39\u4ecb\u3057\u307e\u3059\uff0e\n\n\u9014\u4e2d\u3067\u51fa\u3066\u304f\u308b**cv::ParallelLoopBody**\u3084**cv::parallel_for_**\u306f[@fukushima1981](https://twitter.com/fukushima1981)\u3055\u3093\u306e[\u8a18\u4e8b](http://qiita.com/fukushima1981/items/02d6c034ca0375496b65)\u3084\u7b46\u8005\u306e[wiki](https://github.com/atinfinity/lab/wiki/cv%3A%3Aparallel_for_%E3%82%92%E4%BD%BF%E3%81%A3%E3%81%A6%E3%81%BF%E3%82%8B)\u3092\u53c2\u8003\u306b\u3057\u3066\u4e0b\u3055\u3044\uff0e\n\n## 1. \u30e9\u30a4\u30f3\u6570\u3092\u8a08\u7b97\u3059\u308b\n\n```cpp:\nconst int LINES = static_cast<int>(this->total() / this->size[this->dims - 1]);\n```\n\n## 2. ParallelLoopBody\u30af\u30e9\u30b9\u3092\u7d99\u627f\u3057\u305f\u30d4\u30af\u30bb\u30eb\u64cd\u4f5c\u95a2\u6570\u3092\u7528\u610f\u3059\u308b\n**ParallelLoopBody**\u30af\u30e9\u30b9\u3092\u7d99\u627f\u3057\u305f\u30d4\u30af\u30bb\u30eb\u64cd\u4f5c\u95a2\u6570\u3092\u5b9f\u88c5\u3057\u3066\u3044\u307e\u3059\uff0e\n\n```cpp:\nclass PixelOperationWrapper :public ParallelLoopBody\n{\npublic:\n    PixelOperationWrapper(Mat_<_Tp>* const frame, const Functor& _operation)\n        : mat(frame), op(_operation) {};\n    virtual ~PixelOperationWrapper(){};\n    // ! Overloaded virtual operator\n    // convert range call to row call.\n    virtual void operator()(const Range &range) const {\n        const int DIMS = mat->dims;\n        const int COLS = mat->size[DIMS - 1];\n```\n\n## 3. parallel_for_\u3092\u4f7f\u3063\u3066\u4e26\u5217\u51e6\u7406\u3059\u308b\n**parallel_for_**\u306b\u3088\u3063\u3066\u30d4\u30af\u30bb\u30eb\u64cd\u4f5c\u3092\u4e26\u5217\u51e6\u7406\u3057\u307e\u3059\uff0e\u305d\u306e\u305f\u3081\uff0c\u30de\u30eb\u30c1\u30b3\u30a2\u74b0\u5883\u3067\u3042\u308c\u3070\u30d1\u30d5\u30a9\u30fc\u30de\u30f3\u30b9\u5411\u4e0a\u304c\u671f\u5f85\u3067\u304d\u307e\u3059\uff0e\n\n```cpp:\nparallel_for_(cv::Range(0, LINES), PixelOperationWrapper(reinterpret_cast<Mat_<_Tp>*>(this), operation));\n```\n\n# \u30b5\u30f3\u30d7\u30eb\u30b3\u30fc\u30c9\n\u4ee5\u4e0b\u306b**cv::Mat::forEach**\u30e1\u30bd\u30c3\u30c9\u3068**at**\u30e1\u30bd\u30c3\u30c9\uff08\u6bd4\u8f03\u7528\uff09\uff0c\u30a4\u30c6\u30ec\u30fc\u30bf\uff08\u6bd4\u8f03\u7528\uff09\uff0c\u30dd\u30a4\u30f3\u30bf\uff08\u6bd4\u8f03\u7528\uff09\u3067\u30d4\u30af\u30bb\u30eb\u306b\u30a2\u30af\u30bb\u30b9\u3059\u308b\u30b5\u30f3\u30d7\u30eb\u30b3\u30fc\u30c9\u3092\u793a\u3057\u307e\u3059\uff0e\n\n```cpp:\n#include <opencv2/core.hpp>\n#include <iostream>\n\n// \u753b\u50cf\u30b5\u30a4\u30ba\u306e\u5b9a\u6570\nconst cv::Size szXGA = cv::Size(1024, 768);\nconst cv::Size sz720p = cv::Size(1280, 720);\nconst cv::Size sz1080p = cv::Size(1920, 1080);\n\n// \u8a08\u6e2c\u7528\u30de\u30af\u30ed\n#define MEASUREMENT(func_name, sz, loop) \\\n    measurement(#func_name, func_name, sz, loop);\n\nvoid measurement(const std::string func_name,\n    void func(cv::Mat &), cv::Size sz, int loop)\n{\n    cv::Mat image = cv::Mat::zeros(sz, CV_8UC3);\n    double f = 1000.0f / cv::getTickFrequency();\n    int64 start = cv::getTickCount();\n    for (int i = 0; i < loop; i++)\n    {\n        func(image);\n    }\n    int64 end = cv::getTickCount();\n    std::cout << func_name << \": \" << (end - start) * f << \"[ms]\" << std::endl;\n}\n\n// at\u30e1\u30bd\u30c3\u30c9\u306b\u3088\u308b\u30d4\u30af\u30bb\u30eb\u64cd\u4f5c\nvoid atAccess(cv::Mat &src)\n{\n    for (int y = 0; y < src.rows; y++)\n    {\n        for (int x = 0; x < src.cols; x++)\n        {\n            src.at<cv::Vec3b>(y, x)[0] = 0;\n            src.at<cv::Vec3b>(y, x)[1] = 0;\n            src.at<cv::Vec3b>(y, x)[2] = 255;\n        }\n    }\n}\n\n// \u30a4\u30c6\u30ec\u30fc\u30bf\u306b\u3088\u308b\u30d4\u30af\u30bb\u30eb\u64cd\u4f5c\nvoid iteratorAccess(cv::Mat &src)\n{\n    cv::MatIterator_<cv::Vec3b> itr = src.begin<cv::Vec3b>();\n    cv::MatIterator_<cv::Vec3b> itr_end = src.end<cv::Vec3b>();\n\n    for (int i = 0; itr != itr_end; itr++, i++)\n    {\n        cv::Vec3b bgr = (*itr);\n\n        (*itr)[0] = 0;\n        (*itr)[1] = 0;\n        (*itr)[2] = 255;\n    }\n}\n\n// \u30dd\u30a4\u30f3\u30bf\u306b\u3088\u308b\u30d4\u30af\u30bb\u30eb\u64cd\u4f5c\nvoid pointerAccess(cv::Mat &src)\n{\n    for (int y = 0; y < src.rows; y++)\n    {\n        cv::Vec3b *p = &src.at<cv::Vec3b>(y, 0);\n        for (int x = 0; x < src.cols; x++)\n        {\n            (*p)[0] = 0;\n            (*p)[1] = 0;\n            (*p)[2] = 255;\n            p++;\n        }\n    }\n}\n\n// cv::Mat::forEach\u30e1\u30bd\u30c3\u30c9\u306b\u3088\u308b\u30d4\u30af\u30bb\u30eb\u64cd\u4f5c\nvoid forEachAccess(cv::Mat &src)\n{\n    src.forEach<cv::Vec3b>([](cv::Vec3b &p, const int * position) -> void {\n        p[0] = 0;\n        p[1] = 0;\n        p[2] = 255;\n    });\n}\n\nint main(int argc, char *argv[])\n{\n    int loop = 100;\n\n    std::cout << \"[XGA]\" << std::endl;\n    MEASUREMENT(atAccess, szXGA, loop);\n    MEASUREMENT(iteratorAccess, szXGA, loop);\n    MEASUREMENT(pointerAccess, szXGA, loop);\n    MEASUREMENT(forEachAccess, szXGA, loop);\n\n    std::cout << \"\\n[720p]\" << std::endl;\n    MEASUREMENT(atAccess, sz720p, loop);\n    MEASUREMENT(iteratorAccess, sz720p, loop);\n    MEASUREMENT(pointerAccess, sz720p, loop);\n    MEASUREMENT(forEachAccess, sz720p, loop);\n\n    std::cout << \"\\n[1080p]\" << std::endl;\n    MEASUREMENT(atAccess, sz1080p, loop);\n    MEASUREMENT(iteratorAccess, sz1080p, loop);\n    MEASUREMENT(pointerAccess, sz1080p, loop);\n    MEASUREMENT(forEachAccess, sz1080p, loop);\n\n    return 0;\n}\n```\n\n## \u30d1\u30d5\u30a9\u30fc\u30de\u30f3\u30b9\n\u524d\u8ff0\u306e\u30b5\u30f3\u30d7\u30eb\u30b3\u30fc\u30c9\u3092\u5b9f\u884c\u3055\u305b\u305f\u7d50\u679c\u306f\u4ee5\u4e0b\u306e\u901a\u308a\u3067\u3059\uff0e\n\u3053\u306e\u7d50\u679c\u304b\u3089\u3082\u308f\u304b\u308b\u3088\u3046\u306b**cv::Mat::forEach**\u30e1\u30bd\u30c3\u30c9\u306e\u65b9\u304c\u9ad8\u901f\u306b\u51e6\u7406\u3067\u304d\u3066\u3044\u308b\u3053\u3068\u304c\u308f\u304b\u308a\u307e\u3059\uff0e\n\n![graph.png](https://qiita-image-store.s3.amazonaws.com/0/31158/ac9236a5-f561-7d32-45ae-efa952848497.png)\n\n<pre>\n[XGA]\natAccess: 192.748[ms]\niteratorAccess: 194.007[ms]\npointerAccess: 55.3249[ms]\nforEachAccess: 12.6574[ms]\n\n[720p]\natAccess: 225.619[ms]\niteratorAccess: 228.75[ms]\npointerAccess: 64.8113[ms]\nforEachAccess: 12.4458[ms]\n\n[1080p]\natAccess: 509.205[ms]\niteratorAccess: 517.512[ms]\npointerAccess: 145.582[ms]\nforEachAccess: 25.1963[ms]\n</pre>\n\n\u307e\u305f\uff0c\u7b46\u8005\u306e\u8a08\u6e2c\u74b0\u5883\u306f\u4ee5\u4e0b\u306e\u901a\u308a\u3067\u3059\uff0e\nCPU\uff1aIntel Core i7-3930K 3.20GHz\n\u30e1\u30e2\u30ea\uff1a32GB\n\n# \u304a\u308f\u308a\u306b\n\u3053\u306e\u8a18\u4e8b\u3067\u306f**cv::Mat::forEach**\u30e1\u30bd\u30c3\u30c9\u306e\u5185\u90e8\u51e6\u7406\u304a\u3088\u3073\u4f7f\u3044\u65b9\u3092\u7d39\u4ecb\u3057\u307e\u3057\u305f\uff0e\n\n# \u5099\u8003\n\u7b46\u8005\u306f\u4ee5\u4e0b\u306e\u74b0\u5883\u3067\u52d5\u4f5c\u78ba\u8a8d\u3057\u307e\u3057\u305f\uff0e\n\n* [OpenCV 3.0.0](https://github.com/Itseez/opencv/releases/tag/3.0.0)\n* Windows 8.1 Pro\uff0864bit\uff09\n* Visual Studio 2013 Update5\n", "tags": ["OpenCV", "\u753b\u50cf\u51e6\u7406", "C++"]}