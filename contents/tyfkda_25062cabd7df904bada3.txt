{"context": " More than 1 year has passed since last update.\u7a81\u5982\u3068\u3057\u3066\u3001\u578b\u63a8\u8ad6\u306f\u3069\u3093\u306a\u98a8\u306b\u3057\u305f\u3089\u5b9f\u88c5\u3067\u304d\u308b\u306e\u304b\u77e5\u308a\u305f\u304f\u306a\u3063\u305f\u3002\u578b\u7406\u8ad6\u3068\u304b\u5168\u304f\u77e5\u3089\u306a\u3044\u304c\u3001\u5b9f\u88c5\u3057\u3066\u52d5\u304b\u3057\u3066\u307f\u3066\u539f\u7406\u3092\u77e5\u308a\u305f\u3044\u3068\u601d\u3063\u305f\u3002\u305d\u3053\u3067\u3042\u308c\u3053\u308c\u30b0\u30b0\u308b\uff1a\n\n\nJavaScript \u306b\u3088\u308b\u578b\u63a8\u8ad6\u5668\u306e\u5b9f\u88c5 - takuto_h\u306e\u65e5\u8a18\n\n\u578b\u63a8\u8ad6\u306b\u95a2\u3057\u3066\u4e01\u5be7\u306b\u8aac\u660e\u3055\u308c\u3066\u3044\u3066\u3001\u307e\u305f\u578b\u63a8\u8ad6\u306e\u53ef\u8996\u5316\u30c4\u30fc\u30eb\u304c\u30d6\u30e9\u30a6\u30b6\u4e0a\u3067\u30b9\u30c6\u30c3\u30d7\u305a\u3064\u52d5\u4f5c\u3092\u8ffd\u3046\u3053\u3068\u304c\u3067\u304d\u3066\u3001\u611f\u3058\u304c\u3064\u304b\u307f\u3084\u3059\u3044\n\n\n\nMokkosu\u3067\u578b\u63a8\u8ad6\u5668\u3092\u4f5c\u3063\u3066\u307f\u305f - Qiita\n\n\u69cb\u6587\u6728\u306e\u5185\u90e8\u8868\u73fe\u3092\u3069\u3046\u3059\u308b\u304b\u3068\u304b\u3001\u578b\u3092\u3069\u3046\u3044\u3046\u5f62\u3067\u6301\u3064\u304b\u3001\u3042\u3068\u5b9f\u969b\u306b\u578b\u63a8\u8ad6\u306f\u3069\u3046\u3084\u3063\u3066\u3084\u308b\u304b\u3092\u8aac\u660e\u3057\u3066\u3044\u3066\u308f\u304b\u308a\u3084\u3059\u3044\n\nMokkosu\u3067Haskell\u306e\u578b\u30b7\u30b9\u30c6\u30e0\u3092\u4f5c\u308b (\u305d\u306e1) - Qiita\u306b\u3088\u308b\u3068Typing Haskell in Haskell\u3068\u3044\u3046\u8ad6\u6587\u3092\u53c2\u8003\u306b\u3057\u3066\u3044\u308b\u3089\u3057\u3044\u3002\u305d\u3063\u3061\u3082\u8aad\u3093\u3060\u307b\u3046\u304c\u3044\u3044\u3093\u3060\u308d\u3046\u3051\u3069\u3001\u3072\u3068\u307e\u305a\u30b9\u30eb\u30fc\n\n\n\n\u578b\u63a8\u8ad6\u306e\u3042\u308b\u8a00\u8a9e\u4f5c\u3063\u305f - Route 477(2014-06-05)\n\n\n\u578b\u30b7\u30b9\u30c6\u30e0\u5165\u9580\u3068\u3044\u3046\u672c\u3092\u5143\u306b\u3057\u3066\u3044\u308b\u3089\u3057\u3044\u3002\u539a\u3044\u3057\u591a\u5206\u8aad\u3093\u3067\u3082\u30e0\u30ba\u304f\u3066\u7406\u89e3\u3067\u304d\u306a\u3044\u3093\u3060\u3088\u306d\u2026\n\n\n\n\nHaskell\u3067\u5b9f\u88c5\u3057\u3066\u307f\u308b\n\u4e0a\u8a18\u306e\u30ea\u30f3\u30af\u305f\u3061\u3092\u53c2\u8003\u306b\u3057\u3066\u3001Haskell\u3067\u69cb\u6587\u6728\u3092\u6e21\u3059\u3068\u305d\u306e\u578b\u3092\u63a8\u8ad6\u3059\u308b\u95a2\u6570\u3092\u4f5c\u3063\u3066\u307f\u308b\u3002\u8a00\u8a9e\u3068\u3057\u3066\u4f7f\u3048\u308b\u3088\u3046\u306b\u306a\u308b\u307e\u3067\u306b\u3059\u308b\u306b\u306f\u6577\u5c45\u304c\u9ad8\u3044\u306e\u3067\u3001\u3072\u3068\u307e\u305a\u578b\u306e\u63a8\u8ad6\u3060\u3051\u3067\u3001\u578b\u691c\u67fb\u306a\u3069\u306f\u884c\u308f\u306a\u3044\u3002\n\u8a55\u4fa1\u3057\u305f\u3044\u5f0f\u306e\u69cb\u6587\u6728\u306f\u69cb\u7bc9\u3055\u308c\u3066\u3044\u3066\u4e0e\u3048\u3089\u308c\u308b\u3082\u306e\u3068\u3057\u3066\u3001\u30d1\u30fc\u30b5\u306a\u3069\u306e\u5b9f\u88c5\u3082\u884c\u308f\u306a\u3044\uff08\u30d1\u30fc\u30b5\u7de8\u306f\u3053\u3061\u3089\uff09\n\uff08\u5185\u5bb9\u306f\u307b\u3068\u3093\u3069\u4e0a\u8a18\u306e\u53c2\u7167\u3057\u305f\u30b5\u30a4\u30c8\u3067\u89e3\u8aac\u3055\u308c\u3066\u3044\u308b\u5185\u5bb9\u305d\u306e\u307e\u307e\u3067\u3001\u4e3b\u306bHaskell\u3067\u3069\u3046\u3084\u3063\u3066\u578b\u5909\u6570\u3092\u6271\u3046\u306e\u304b\u3001\u3069\u3046\u3084\u3063\u3066ST\u30e2\u30ca\u30c9\u3092\u6271\u3046\u304b\u3068\u683c\u95d8\u3057\u3066\u3044\u305f\u6c17\u304c\u3059\u308b\u3002\uff09\n\n\u69cb\u6587\u6728\u306e\u30ce\u30fc\u30c9\u306e\u5b9a\u7fa9\n\u3072\u3068\u307e\u305a\u6271\u3048\u308b\u57fa\u672c\u7684\u306a\u578b\u306f\u6574\u6570\u306e\u307f\u3067\u3001\u69cb\u6587\u306f\uff11\u5f15\u6570\u306e\u95a2\u6570\u3068\u305d\u306e\u547c\u3073\u51fa\u3057\u3001\u307e\u305f\u5909\u6570\u306e\u53c2\u7167\u306e\u307f\u3001\u3068\u3059\u308b\uff1a\n\nNode.hs\nmodule Node (Expr(..)) where\n\ndata Expr = Natural Integer  -- \u6574\u6570\uff1a\u5024\n          | Var String       -- \u5909\u6570\uff1a\u540d\u524d\n          | Fun String Expr  -- \u95a2\u6570\uff1a\u30d1\u30e9\u30e1\u30fc\u30bf\u540d\u3001\u7d50\u679c\u306e\u5f0f\n          | App Expr Expr    -- \u9069\u7528\uff1a\u95a2\u6570\u3001\u5f15\u6570\n  deriving (Show)\n\n\n\n\u95a2\u6570\u306f\u5168\u3066\u5f15\u6570\u306f\uff11\u3064\u306e\u307f\u3067\u3001\u30ab\u30ea\u30fc\u5316\u3055\u308c\u3066\u308b\u3082\u306e\u3068\u3059\u308b\n\u95a2\u6570\u9069\u7528\u3082\u540c\u69d8\u306b\u3001\uff11\u5ea6\u306b\uff11\u3064\u3057\u304b\u9069\u7528\u3057\u306a\u3044\u3082\u306e\u3068\u3059\u308b\n\n\n\u578b\u306e\u5b9a\u7fa9\n\u5f0f\u304c\u6301\u3064\u578b\u306f\u3001\u6574\u6570\u578bTInt\u3068\u95a2\u6570\u578bTFun\uff08\u5f15\u6570\u306e\u578b\u3068\u7d50\u679c\u306e\u578b\u3092\u6301\u3064\uff09\u3068\u3001\u578b\u5909\u6570TVar\uff08\u8b58\u5225\u756a\u53f7\u3092\u6301\u3064\uff09\u3002\n\nType.hs\nmodule Type (Type(..)) where\n\ndata Type = TInt            -- \u6574\u6570\n          | TFun Type Type  -- \u95a2\u6570\uff1a\u5f15\u6570\u306e\u578b\u3001\u7d50\u679c\u306e\u578b\n          | TVar Int        -- \u578b\u5909\u6570\uff1a\u8b58\u5225\u756a\u53f7\n  deriving (Eq)\n\ninstance Show Type where\n  show TInt        = \"Int\"\n  show (TFun p e)  = pp p ++ \" -> \" ++ show e\n    where pp fun@(TFun _ _) = \"(\" ++ show fun ++ \")\"\n          pp t              = show t\n  show (TVar i)    = \"t\" ++ show i\n\n\nTVar\u306f\u672a\u78ba\u5b9a\u306e\u578b\u3092\u4fdd\u6301\u3059\u308b\u578b\u5909\u6570\u3067\u3001\u5f8c\u8ff0\u306e\u5358\u4e00\u5316(unify)\u3067\u6c7a\u5b9a\u3055\u308c\u308b\u3053\u3068\u306b\u306a\u308b\uff08\u6c7a\u5b9a\u305b\u305a\u306b\u6b8b\u308b\u5834\u5408\u3082\u3042\u308b\uff09\u3002\n\u578b\u5909\u6570\u306e\u578b\u304c\u78ba\u5b9a\u3057\u305f\u5834\u5408\u306b\u305d\u306e\u578b\u3092\u4fdd\u6301\u3059\u308b\u306e\u306f\u5225\u30c6\u30fc\u30d6\u30eb\u3067\u7ba1\u7406\u3057\u3001\u8b58\u5225\u756a\u53f7\u3067\u53c2\u7167\u3059\u308b\u3002\n\n\u578b\u63a8\u8ad6\n\u578b\u63a8\u8ad6\u3092\u884c\u3046\u95a2\u6570infer\u306f\u3001\u7d44\u307f\u8fbc\u307f\u95a2\u6570\u306a\u3069\u578b\u306e\u78ba\u5b9a\u3057\u3066\u3044\u308b\u30b0\u30ed\u30fc\u30d0\u30eb\u306a\u74b0\u5883[(String, Type)]\u3068\u3001\u63a8\u8ad6\u3057\u305f\u3044\u5f0f\u306e\u69cb\u6587\u6728Expr\u3092\u53d7\u3051\u53d6\u308a\u3001\u63a8\u8ad6\u3057\u305f\u578bType\u3092\u8fd4\u3059\uff1a\n\nTypeInferencer.hs\nmodule TypeInferencer (infer) where\n\nimport Prelude hiding (lookup)\nimport Control.Monad.ST (ST, runST)\nimport Data.Map (empty, fromList, insert, lookup, Map)\nimport Data.STRef (newSTRef, readSTRef, writeSTRef, STRef)\n\nimport Node (Expr(..))\nimport Type (Type(..))\n\n-- Environment\ntype Env = Map String Type\n\n-- (next var index, {index=>type})\ntype VarInfo = (Int, Map Int Type)\n\ninfer :: [(String, Type)] -> Expr -> Type\ninfer env expr = runST $ do\n  varInfoRef <- newSTRef (0, empty)\n  t <- doInfer (fromList env) varInfoRef expr\n  (_, varDict) <- readSTRef varInfoRef\n  return $ refer t varDict\n\ndoInfer :: Env -> STRef s VarInfo -> Expr -> ST s Type\ndoInfer env varInfoRef expr =\n  case expr of\n    Natural i  -> return TInt\n    Var x -> do\n      case lookup x env of\n        Just t  -> return t\n        Nothing -> error (\"not found: \" ++ x)\n    Fun parm e -> do\n      tparm <- createVar varInfoRef\n      te <- doInfer (insert parm tparm env) varInfoRef e\n      return $ TFun tparm te\n    App f arg -> do\n      funType <- doInfer env varInfoRef f\n      argType <- doInfer env varInfoRef arg\n      retType <- createVar varInfoRef\n      unify funType (TFun argType retType) varInfoRef\n      return retType\n\n\n\n\u578b\u5909\u6570\u306e\u5024\u304c\u6c7a\u5b9a\u3057\u305f\u6642\u306b\u72b6\u614b\u3092\u66f8\u304d\u63db\u3048\u308b\u305f\u3081\u306b\u3001ST\u30e2\u30ca\u30c9\u3092\u4f7f\u7528\u3059\u308b\u3053\u3068\u306b\u3057\u3066\u3001\u5b9f\u969b\u306e\u578b\u63a8\u8ad6 doInfer \u3067\u306fST\u30e2\u30ca\u30c9\u5185\u3067\u884c\u3046\n\n\n\u7d50\u679c\u306f runST \u3067\u53d6\u308a\u51fa\u3059\n\n\n\u578b\u306e\u63a8\u8ad6\u306f\u3001\u95a2\u6570\u306e\u9069\u7528\u6642\u306b\u95a2\u6570\u306e\u5f15\u6570\u306e\u578b\u304b\u3089\u5358\u4e00\u5316\u3057\u3066\u3001\u3069\u3061\u3089\u304b\u304c\u578b\u5909\u6570\u306e\u5834\u5408\u306b\u306f\u53cd\u6620\u3055\u305b\u308b\n\n\u5358\u4e00\u5316\n\nTypeInferencer.hs\nunify :: Type -> Type -> STRef s VarInfo -> ST s ()\nunify (TFun p1 e1) (TFun p2 e2) varInfoRef = do\n  unify p1 p2 varInfoRef\n  unify e1 e2 varInfoRef\nunify t1@(TVar i1) t2@(TVar i2) varInfoRef\n  | i1 == i2  = return ()\nunify (TVar i1) t2 varInfoRef = unifyVar i1 t2 varInfoRef\nunify t1 (TVar i2) varInfoRef = unifyVar i2 t1 varInfoRef\nunify t1 t2 varInfoRef\n  | t1 == t2  = return ()\n  | otherwise = cannotUnify t1 t2 varInfoRef\n\nunifyVar :: Int -> Type -> STRef s VarInfo -> ST s ()\nunifyVar index type2 varInfoRef = do\n  isOccur <- occur type2 index varInfoRef\n  if isOccur\n    then  error \"occurs error\"\n    else do\n      (nextIdx, varMap) <- readSTRef varInfoRef\n      case lookup index varMap of\n        Just vt  -> unify vt type2 varInfoRef\n        Nothing  -> writeSTRef varInfoRef (nextIdx, insert index type2 varMap)\n\n\n\u51fa\u73fe\u78ba\u8a8d\n\nTypeInferencer.hs\noccur :: Type -> Int -> STRef s VarInfo -> ST s Bool\noccur (TFun p e) n varInfoRef = (||) <$> occur p n varInfoRef <*> occur e n varInfoRef\noccur (TVar i) n varInfoRef\n  | i == n    = return True\n  | otherwise = do\n      (_, varMap) <- readSTRef varInfoRef\n      case lookup i varMap of\n        Just vt  -> occur vt n varInfoRef\n        Nothing  -> return False\noccur _ _ _   = return False\n\n\n\u7d30\u3005\n\nTypeInferencer.hs\ncreateVar :: STRef s VarInfo -> ST s Type\ncreateVar varInfoRef = do\n  (nextIdx, varMap) <- readSTRef varInfoRef\n  writeSTRef varInfoRef (nextIdx + 1, varMap)\n  return $ TVar nextIdx\n\nrefer :: Type -> Map Int Type -> Type\nrefer (TFun p e) varMap = TFun (refer p varMap) (refer e varMap)\nrefer t@(TVar v) varMap = case lookup v varMap of\n  Just vt  -> refer vt varMap\n  Nothing  -> t\nrefer t varMap          = t\n\ncannotUnify t1 t2 varInfoRef = do\n  (_, varMap) <- readSTRef varInfoRef\n  error (\"cannot unify: \" ++ show (refer t1 varMap) ++ \" <=> \" ++ show (refer t2 varMap))\n\n\n\n\u52d5\u304b\u3057\u3066\u307f\u308b\nPrelude> :l TypeInferencer.hs\n[1 of 3] Compiling Node             ( Node.hs, interpreted )\n[2 of 3] Compiling Type             ( Type.hs, interpreted )\n[3 of 3] Compiling TypeInferencer   ( TypeInferencer.hs, interpreted )\nOk, modules loaded: Type, TypeInferencer, Node.\n*TypeInferencer> let globalEnv = [(\"+\", TFun TInt (TFun TInt TInt))]  -- (+) :: Int -> (Int -> Int)\n*TypeInferencer> infer globalEnv $ Natural 123\nInt  -- 123 :: Int\n*TypeInferencer> infer globalEnv $ Fun \"x\" (App (App (Var \"+\") (Var \"x\")) (Natural 1))\nInt -> Int  -- \\x -> x + 1 :: Int -> Int\n\n\u95a2\u6570\u5408\u6210\u306e\u578b\u3092\u63a8\u8ad6\u3057\u3066\u307f\u308b\uff1a\n*TypeInferencer> infer globalEnv $ Fun \"f\" (Fun \"g\" (Fun \"x\" (App (Var \"f\") (App (Var \"g\") (Var \"x\")))))\n(t3 -> t4) -> (t2 -> t3) -> t2 -> t4  -- \\f -> \\g -> \\x -> f (g x) :: (b -> c) -> (a -> b) -> a -> c\n*TypeInferencer> :t (.)\n(.) :: (b -> c) -> (a -> b) -> a -> c\n\n\u30bd\u30fc\u30b9\u306f\u3053\u3061\u3089\n\n\u96d1\u611f\n\n\u78ba\u304b\u306b\u3001\u3053\u3053\u307e\u3067\u3060\u3051\u3060\u3068\u5b9f\u88c5\u306f\u975e\u5e38\u306b\u7c21\u5358\u306b\u3067\u304d\u308b\n\n\n\u95a2\u6570\u304c\u5e38\u306b\u5f15\u6570\u304c\uff11\u3064\u3068\u3044\u3046\u5236\u7d04\u3067\u304b\u306a\u308a\u7c21\u7565\u5316\u3055\u308c\u3066\u308b\u3068\u601d\u3046\n\n\n\u5b9f\u969b\u306b\u578b\u691c\u67fb\u3057\u3088\u3046\u3068\u3059\u308b\u3068\u3001\u578b\u30af\u30e9\u30b9\u3092\u5c0e\u5165\u3059\u308b\u5fc5\u8981\u304c\u3042\u308b\u3093\u3058\u3083\u306a\u3044\u304b\u3068\u601d\u3044\u3001\u305d\u3046\u306a\u308b\u3068\u7d50\u69cb\u5927\u5909\u306b\u306a\u308b\u3093\u3058\u3083\u306a\u3044\u304b\u3068\u60f3\u50cf\n\n\u7a81\u5982\u3068\u3057\u3066\u3001\u578b\u63a8\u8ad6\u306f\u3069\u3093\u306a\u98a8\u306b\u3057\u305f\u3089\u5b9f\u88c5\u3067\u304d\u308b\u306e\u304b\u77e5\u308a\u305f\u304f\u306a\u3063\u305f\u3002\u578b\u7406\u8ad6\u3068\u304b\u5168\u304f\u77e5\u3089\u306a\u3044\u304c\u3001\u5b9f\u88c5\u3057\u3066\u52d5\u304b\u3057\u3066\u307f\u3066\u539f\u7406\u3092\u77e5\u308a\u305f\u3044\u3068\u601d\u3063\u305f\u3002\u305d\u3053\u3067\u3042\u308c\u3053\u308c\u30b0\u30b0\u308b\uff1a\n\n* [JavaScript \u306b\u3088\u308b\u578b\u63a8\u8ad6\u5668\u306e\u5b9f\u88c5 - takuto_h\u306e\u65e5\u8a18](http://d.hatena.ne.jp/takuto_h/20110401/impl)\n  * \u578b\u63a8\u8ad6\u306b\u95a2\u3057\u3066\u4e01\u5be7\u306b\u8aac\u660e\u3055\u308c\u3066\u3044\u3066\u3001\u307e\u305f[\u578b\u63a8\u8ad6\u306e\u53ef\u8996\u5316\u30c4\u30fc\u30eb](http://d.hatena.ne.jp/takuto_h/20110408/visualize)\u304c\u30d6\u30e9\u30a6\u30b6\u4e0a\u3067\u30b9\u30c6\u30c3\u30d7\u305a\u3064\u52d5\u4f5c\u3092\u8ffd\u3046\u3053\u3068\u304c\u3067\u304d\u3066\u3001\u611f\u3058\u304c\u3064\u304b\u307f\u3084\u3059\u3044\n* [Mokkosu\u3067\u578b\u63a8\u8ad6\u5668\u3092\u4f5c\u3063\u3066\u307f\u305f - Qiita](http://qiita.com/lambdataro/items/b74fc9944ab66e0f6333)\n  * \u69cb\u6587\u6728\u306e\u5185\u90e8\u8868\u73fe\u3092\u3069\u3046\u3059\u308b\u304b\u3068\u304b\u3001\u578b\u3092\u3069\u3046\u3044\u3046\u5f62\u3067\u6301\u3064\u304b\u3001\u3042\u3068\u5b9f\u969b\u306b\u578b\u63a8\u8ad6\u306f\u3069\u3046\u3084\u3063\u3066\u3084\u308b\u304b\u3092\u8aac\u660e\u3057\u3066\u3044\u3066\u308f\u304b\u308a\u3084\u3059\u3044\n  * [Mokkosu\u3067Haskell\u306e\u578b\u30b7\u30b9\u30c6\u30e0\u3092\u4f5c\u308b (\u305d\u306e1) - Qiita](http://qiita.com/lambdataro/items/1e4d795d3dd97a94c8f3)\u306b\u3088\u308b\u3068[Typing Haskell in Haskell](http://web.cecs.pdx.edu/~mpj/thih/)\u3068\u3044\u3046\u8ad6\u6587\u3092\u53c2\u8003\u306b\u3057\u3066\u3044\u308b\u3089\u3057\u3044\u3002\u305d\u3063\u3061\u3082\u8aad\u3093\u3060\u307b\u3046\u304c\u3044\u3044\u3093\u3060\u308d\u3046\u3051\u3069\u3001\u3072\u3068\u307e\u305a\u30b9\u30eb\u30fc\n* [\u578b\u63a8\u8ad6\u306e\u3042\u308b\u8a00\u8a9e\u4f5c\u3063\u305f - Route 477(2014-06-05)](http://route477.net/d/?date=20140605)\n  * [\u578b\u30b7\u30b9\u30c6\u30e0\u5165\u9580](http://estore.ohmsha.co.jp/titles/978427406911P)\u3068\u3044\u3046\u672c\u3092\u5143\u306b\u3057\u3066\u3044\u308b\u3089\u3057\u3044\u3002\u539a\u3044\u3057\u591a\u5206\u8aad\u3093\u3067\u3082\u30e0\u30ba\u304f\u3066\u7406\u89e3\u3067\u304d\u306a\u3044\u3093\u3060\u3088\u306d\u2026\n\n\n## Haskell\u3067\u5b9f\u88c5\u3057\u3066\u307f\u308b\n\n\u4e0a\u8a18\u306e\u30ea\u30f3\u30af\u305f\u3061\u3092\u53c2\u8003\u306b\u3057\u3066\u3001Haskell\u3067\u69cb\u6587\u6728\u3092\u6e21\u3059\u3068\u305d\u306e\u578b\u3092\u63a8\u8ad6\u3059\u308b\u95a2\u6570\u3092\u4f5c\u3063\u3066\u307f\u308b\u3002\u8a00\u8a9e\u3068\u3057\u3066\u4f7f\u3048\u308b\u3088\u3046\u306b\u306a\u308b\u307e\u3067\u306b\u3059\u308b\u306b\u306f\u6577\u5c45\u304c\u9ad8\u3044\u306e\u3067\u3001\u3072\u3068\u307e\u305a\u578b\u306e\u63a8\u8ad6\u3060\u3051\u3067\u3001\u578b\u691c\u67fb\u306a\u3069\u306f\u884c\u308f\u306a\u3044\u3002\n\n\u8a55\u4fa1\u3057\u305f\u3044\u5f0f\u306e\u69cb\u6587\u6728\u306f\u69cb\u7bc9\u3055\u308c\u3066\u3044\u3066\u4e0e\u3048\u3089\u308c\u308b\u3082\u306e\u3068\u3057\u3066\u3001\u30d1\u30fc\u30b5\u306a\u3069\u306e\u5b9f\u88c5\u3082\u884c\u308f\u306a\u3044\uff08\u30d1\u30fc\u30b5\u7de8\u306f[\u3053\u3061\u3089](http://qiita.com/tyfkda/items/0180d6c0a3f371f5c40a)\uff09\n\n\uff08\u5185\u5bb9\u306f\u307b\u3068\u3093\u3069\u4e0a\u8a18\u306e\u53c2\u7167\u3057\u305f\u30b5\u30a4\u30c8\u3067\u89e3\u8aac\u3055\u308c\u3066\u3044\u308b\u5185\u5bb9\u305d\u306e\u307e\u307e\u3067\u3001\u4e3b\u306bHaskell\u3067\u3069\u3046\u3084\u3063\u3066\u578b\u5909\u6570\u3092\u6271\u3046\u306e\u304b\u3001\u3069\u3046\u3084\u3063\u3066ST\u30e2\u30ca\u30c9\u3092\u6271\u3046\u304b\u3068\u683c\u95d8\u3057\u3066\u3044\u305f\u6c17\u304c\u3059\u308b\u3002\uff09\n\n\n### \u69cb\u6587\u6728\u306e\u30ce\u30fc\u30c9\u306e\u5b9a\u7fa9\n\n\u3072\u3068\u307e\u305a\u6271\u3048\u308b\u57fa\u672c\u7684\u306a\u578b\u306f\u6574\u6570\u306e\u307f\u3067\u3001\u69cb\u6587\u306f\uff11\u5f15\u6570\u306e\u95a2\u6570\u3068\u305d\u306e\u547c\u3073\u51fa\u3057\u3001\u307e\u305f\u5909\u6570\u306e\u53c2\u7167\u306e\u307f\u3001\u3068\u3059\u308b\uff1a\n\n```Node.hs\nmodule Node (Expr(..)) where\n\ndata Expr = Natural Integer  -- \u6574\u6570\uff1a\u5024\n          | Var String       -- \u5909\u6570\uff1a\u540d\u524d\n          | Fun String Expr  -- \u95a2\u6570\uff1a\u30d1\u30e9\u30e1\u30fc\u30bf\u540d\u3001\u7d50\u679c\u306e\u5f0f\n          | App Expr Expr    -- \u9069\u7528\uff1a\u95a2\u6570\u3001\u5f15\u6570\n  deriving (Show)\n```\n\n* \u95a2\u6570\u306f\u5168\u3066\u5f15\u6570\u306f\uff11\u3064\u306e\u307f\u3067\u3001\u30ab\u30ea\u30fc\u5316\u3055\u308c\u3066\u308b\u3082\u306e\u3068\u3059\u308b\n* \u95a2\u6570\u9069\u7528\u3082\u540c\u69d8\u306b\u3001\uff11\u5ea6\u306b\uff11\u3064\u3057\u304b\u9069\u7528\u3057\u306a\u3044\u3082\u306e\u3068\u3059\u308b\n\n### \u578b\u306e\u5b9a\u7fa9\n\n\u5f0f\u304c\u6301\u3064\u578b\u306f\u3001\u6574\u6570\u578b`TInt`\u3068\u95a2\u6570\u578b`TFun`\uff08\u5f15\u6570\u306e\u578b\u3068\u7d50\u679c\u306e\u578b\u3092\u6301\u3064\uff09\u3068\u3001\u578b\u5909\u6570`TVar`\uff08\u8b58\u5225\u756a\u53f7\u3092\u6301\u3064\uff09\u3002\n\n```Type.hs\nmodule Type (Type(..)) where\n\ndata Type = TInt            -- \u6574\u6570\n          | TFun Type Type  -- \u95a2\u6570\uff1a\u5f15\u6570\u306e\u578b\u3001\u7d50\u679c\u306e\u578b\n          | TVar Int        -- \u578b\u5909\u6570\uff1a\u8b58\u5225\u756a\u53f7\n  deriving (Eq)\n\ninstance Show Type where\n  show TInt        = \"Int\"\n  show (TFun p e)  = pp p ++ \" -> \" ++ show e\n    where pp fun@(TFun _ _) = \"(\" ++ show fun ++ \")\"\n          pp t              = show t\n  show (TVar i)    = \"t\" ++ show i\n```\n\n`TVar`\u306f\u672a\u78ba\u5b9a\u306e\u578b\u3092\u4fdd\u6301\u3059\u308b\u578b\u5909\u6570\u3067\u3001\u5f8c\u8ff0\u306e\u5358\u4e00\u5316(`unify`)\u3067\u6c7a\u5b9a\u3055\u308c\u308b\u3053\u3068\u306b\u306a\u308b\uff08\u6c7a\u5b9a\u305b\u305a\u306b\u6b8b\u308b\u5834\u5408\u3082\u3042\u308b\uff09\u3002\n\n\u578b\u5909\u6570\u306e\u578b\u304c\u78ba\u5b9a\u3057\u305f\u5834\u5408\u306b\u305d\u306e\u578b\u3092\u4fdd\u6301\u3059\u308b\u306e\u306f\u5225\u30c6\u30fc\u30d6\u30eb\u3067\u7ba1\u7406\u3057\u3001\u8b58\u5225\u756a\u53f7\u3067\u53c2\u7167\u3059\u308b\u3002\n\n### \u578b\u63a8\u8ad6\n\n\u578b\u63a8\u8ad6\u3092\u884c\u3046\u95a2\u6570`infer`\u306f\u3001\u7d44\u307f\u8fbc\u307f\u95a2\u6570\u306a\u3069\u578b\u306e\u78ba\u5b9a\u3057\u3066\u3044\u308b\u30b0\u30ed\u30fc\u30d0\u30eb\u306a\u74b0\u5883`[(String, Type)]`\u3068\u3001\u63a8\u8ad6\u3057\u305f\u3044\u5f0f\u306e\u69cb\u6587\u6728`Expr`\u3092\u53d7\u3051\u53d6\u308a\u3001\u63a8\u8ad6\u3057\u305f\u578b`Type`\u3092\u8fd4\u3059\uff1a\n\n```TypeInferencer.hs\nmodule TypeInferencer (infer) where\n\nimport Prelude hiding (lookup)\nimport Control.Monad.ST (ST, runST)\nimport Data.Map (empty, fromList, insert, lookup, Map)\nimport Data.STRef (newSTRef, readSTRef, writeSTRef, STRef)\n\nimport Node (Expr(..))\nimport Type (Type(..))\n\n-- Environment\ntype Env = Map String Type\n\n-- (next var index, {index=>type})\ntype VarInfo = (Int, Map Int Type)\n\ninfer :: [(String, Type)] -> Expr -> Type\ninfer env expr = runST $ do\n  varInfoRef <- newSTRef (0, empty)\n  t <- doInfer (fromList env) varInfoRef expr\n  (_, varDict) <- readSTRef varInfoRef\n  return $ refer t varDict\n\ndoInfer :: Env -> STRef s VarInfo -> Expr -> ST s Type\ndoInfer env varInfoRef expr =\n  case expr of\n    Natural i  -> return TInt\n    Var x -> do\n      case lookup x env of\n        Just t  -> return t\n        Nothing -> error (\"not found: \" ++ x)\n    Fun parm e -> do\n      tparm <- createVar varInfoRef\n      te <- doInfer (insert parm tparm env) varInfoRef e\n      return $ TFun tparm te\n    App f arg -> do\n      funType <- doInfer env varInfoRef f\n      argType <- doInfer env varInfoRef arg\n      retType <- createVar varInfoRef\n      unify funType (TFun argType retType) varInfoRef\n      return retType\n```\n\n* \u578b\u5909\u6570\u306e\u5024\u304c\u6c7a\u5b9a\u3057\u305f\u6642\u306b\u72b6\u614b\u3092\u66f8\u304d\u63db\u3048\u308b\u305f\u3081\u306b\u3001[`ST`\u30e2\u30ca\u30c9](http://hackage.haskell.org/packages/archive/base/latest/doc/html/Control-Monad-ST.html)\u3092\u4f7f\u7528\u3059\u308b\u3053\u3068\u306b\u3057\u3066\u3001\u5b9f\u969b\u306e\u578b\u63a8\u8ad6 `doInfer` \u3067\u306fST\u30e2\u30ca\u30c9\u5185\u3067\u884c\u3046\n  * \u7d50\u679c\u306f [`runST`](http://hackage.haskell.org/packages/archive/base/latest/doc/html/Control-Monad-ST.html#v:runST) \u3067\u53d6\u308a\u51fa\u3059\n* \u578b\u306e\u63a8\u8ad6\u306f\u3001\u95a2\u6570\u306e\u9069\u7528\u6642\u306b\u95a2\u6570\u306e\u5f15\u6570\u306e\u578b\u304b\u3089\u5358\u4e00\u5316\u3057\u3066\u3001\u3069\u3061\u3089\u304b\u304c\u578b\u5909\u6570\u306e\u5834\u5408\u306b\u306f\u53cd\u6620\u3055\u305b\u308b\n\n\n\u5358\u4e00\u5316\n\n```TypeInferencer.hs\nunify :: Type -> Type -> STRef s VarInfo -> ST s ()\nunify (TFun p1 e1) (TFun p2 e2) varInfoRef = do\n  unify p1 p2 varInfoRef\n  unify e1 e2 varInfoRef\nunify t1@(TVar i1) t2@(TVar i2) varInfoRef\n  | i1 == i2  = return ()\nunify (TVar i1) t2 varInfoRef = unifyVar i1 t2 varInfoRef\nunify t1 (TVar i2) varInfoRef = unifyVar i2 t1 varInfoRef\nunify t1 t2 varInfoRef\n  | t1 == t2  = return ()\n  | otherwise = cannotUnify t1 t2 varInfoRef\n\nunifyVar :: Int -> Type -> STRef s VarInfo -> ST s ()\nunifyVar index type2 varInfoRef = do\n  isOccur <- occur type2 index varInfoRef\n  if isOccur\n    then  error \"occurs error\"\n    else do\n      (nextIdx, varMap) <- readSTRef varInfoRef\n      case lookup index varMap of\n        Just vt  -> unify vt type2 varInfoRef\n        Nothing  -> writeSTRef varInfoRef (nextIdx, insert index type2 varMap)\n```\n\n\u51fa\u73fe\u78ba\u8a8d\n\n```TypeInferencer.hs\noccur :: Type -> Int -> STRef s VarInfo -> ST s Bool\noccur (TFun p e) n varInfoRef = (||) <$> occur p n varInfoRef <*> occur e n varInfoRef\noccur (TVar i) n varInfoRef\n  | i == n    = return True\n  | otherwise = do\n      (_, varMap) <- readSTRef varInfoRef\n      case lookup i varMap of\n        Just vt  -> occur vt n varInfoRef\n        Nothing  -> return False\noccur _ _ _   = return False\n```\n\n\u7d30\u3005\n\n```TypeInferencer.hs\ncreateVar :: STRef s VarInfo -> ST s Type\ncreateVar varInfoRef = do\n  (nextIdx, varMap) <- readSTRef varInfoRef\n  writeSTRef varInfoRef (nextIdx + 1, varMap)\n  return $ TVar nextIdx\n\nrefer :: Type -> Map Int Type -> Type\nrefer (TFun p e) varMap = TFun (refer p varMap) (refer e varMap)\nrefer t@(TVar v) varMap = case lookup v varMap of\n  Just vt  -> refer vt varMap\n  Nothing  -> t\nrefer t varMap          = t\n\ncannotUnify t1 t2 varInfoRef = do\n  (_, varMap) <- readSTRef varInfoRef\n  error (\"cannot unify: \" ++ show (refer t1 varMap) ++ \" <=> \" ++ show (refer t2 varMap))\n```\n\n\n### \u52d5\u304b\u3057\u3066\u307f\u308b\n\n```hs\nPrelude> :l TypeInferencer.hs\n[1 of 3] Compiling Node             ( Node.hs, interpreted )\n[2 of 3] Compiling Type             ( Type.hs, interpreted )\n[3 of 3] Compiling TypeInferencer   ( TypeInferencer.hs, interpreted )\nOk, modules loaded: Type, TypeInferencer, Node.\n*TypeInferencer> let globalEnv = [(\"+\", TFun TInt (TFun TInt TInt))]  -- (+) :: Int -> (Int -> Int)\n*TypeInferencer> infer globalEnv $ Natural 123\nInt  -- 123 :: Int\n*TypeInferencer> infer globalEnv $ Fun \"x\" (App (App (Var \"+\") (Var \"x\")) (Natural 1))\nInt -> Int  -- \\x -> x + 1 :: Int -> Int\n```\n\n\u95a2\u6570\u5408\u6210\u306e\u578b\u3092\u63a8\u8ad6\u3057\u3066\u307f\u308b\uff1a\n\n```hs\n*TypeInferencer> infer globalEnv $ Fun \"f\" (Fun \"g\" (Fun \"x\" (App (Var \"f\") (App (Var \"g\") (Var \"x\")))))\n(t3 -> t4) -> (t2 -> t3) -> t2 -> t4  -- \\f -> \\g -> \\x -> f (g x) :: (b -> c) -> (a -> b) -> a -> c\n*TypeInferencer> :t (.)\n(.) :: (b -> c) -> (a -> b) -> a -> c\n```\n\n\n\u30bd\u30fc\u30b9\u306f[\u3053\u3061\u3089](https://github.com/tyfkda/TypeInferencer)\n\n### \u96d1\u611f\n\n* \u78ba\u304b\u306b\u3001\u3053\u3053\u307e\u3067\u3060\u3051\u3060\u3068\u5b9f\u88c5\u306f\u975e\u5e38\u306b\u7c21\u5358\u306b\u3067\u304d\u308b\n  * \u95a2\u6570\u304c\u5e38\u306b\u5f15\u6570\u304c\uff11\u3064\u3068\u3044\u3046\u5236\u7d04\u3067\u304b\u306a\u308a\u7c21\u7565\u5316\u3055\u308c\u3066\u308b\u3068\u601d\u3046\n* \u5b9f\u969b\u306b\u578b\u691c\u67fb\u3057\u3088\u3046\u3068\u3059\u308b\u3068\u3001\u578b\u30af\u30e9\u30b9\u3092\u5c0e\u5165\u3059\u308b\u5fc5\u8981\u304c\u3042\u308b\u3093\u3058\u3083\u306a\u3044\u304b\u3068\u601d\u3044\u3001\u305d\u3046\u306a\u308b\u3068\u7d50\u69cb\u5927\u5909\u306b\u306a\u308b\u3093\u3058\u3083\u306a\u3044\u304b\u3068\u60f3\u50cf\n", "tags": ["compiler", "Haskell"]}