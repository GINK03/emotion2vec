{"tags": ["C\u8a00\u8a9e"], "context": " \u3053\u306e\u8a18\u4e8b\u306f\u6700\u7d42\u66f4\u65b0\u65e5\u304b\u30891\u5e74\u4ee5\u4e0a\u304c\u7d4c\u904e\u3057\u3066\u3044\u307e\u3059\u3002\ngetmacaddress.c\n#include <stdio.h>\n\n#if defined(WIN32) || (!defined(__GNUC__) && !defined(__clang__))\n    #include <winsock2.h>\n    #include <iphlpapi.h>\n    #include <stdlib.h>\n    #pragma comment(lib, \"IPHLPAPI.lib\")\n#elif defined(__linux__)\n    #include <string.h> //strncpy\n    #include <sys/ioctl.h>\n    #include <sys/socket.h>\n    #include <net/if.h>\n#else\n    //bsd\n    #include <ifaddrs.h>\n    #include <net/if.h>\n    #include <net/if_dl.h>\n    #include <net/if_types.h>\n#endif\n\nvoid getmacaddress(char *mac_address){\n#if defined(WIN32) || (!defined(__GNUC__) && !defined(__clang__))\n    //MSDN\u306e\u30b5\u30f3\u30d7\u30eb\u30b3\u30fc\u30c9\n    PIP_ADAPTER_INFO pAdapterInfo;\n    PIP_ADAPTER_INFO pAdapter;\n    ULONG ulOutBufLen = sizeof(IP_ADAPTER_INFO);\n    unsigned char *addr;\n\n    mac_address[0]=0;\n    pAdapterInfo = (IP_ADAPTER_INFO*)malloc(sizeof(IP_ADAPTER_INFO));\n    if(!pAdapterInfo)return;\n    if(GetAdaptersInfo(pAdapterInfo, &ulOutBufLen) == ERROR_BUFFER_OVERFLOW){\n        free(pAdapterInfo);\n        pAdapterInfo = (IP_ADAPTER_INFO*)malloc(ulOutBufLen);\n        if(!pAdapterInfo)return;\n    }\n\n    if(GetAdaptersInfo(pAdapterInfo, &ulOutBufLen) == NO_ERROR){\n        pAdapter = pAdapterInfo;\n        if(pAdapter){\n            addr = pAdapter->Address;\n            sprintf(mac_address,\"%02x:%02x:%02x:%02x:%02x:%02x\",\n                addr[0], addr[1], addr[2], addr[3], addr[4], addr[5]);\n        }\n    }\n    free(pAdapterInfo);\n#elif defined(__linux__)\n    //http://field-notes.hatenablog.jp/entry/20101216/1292467817\n    mac_address[0]=0;\n    struct ifreq *ifr, *ifend;\n    struct ifreq ifreq;\n    struct ifconf ifc;\n    struct ifreq ifs[16];\n    int fd;\n    unsigned char *addr;\n\n    fd = socket(AF_INET, SOCK_DGRAM, 0);\n    ifc.ifc_len = sizeof(ifs);\n    ifc.ifc_req = ifs;\n    if(ioctl(fd, SIOCGIFCONF, &ifc)<0){close(fd);return;}\n\n    ifend = ifs + (ifc.ifc_len / sizeof(struct ifreq));\n    for(ifr = ifc.ifc_req;ifr < ifend;ifr++){\n        if(ifr->ifr_addr.sa_family == AF_INET){\n            strncpy(ifreq.ifr_name, ifr->ifr_name, sizeof(ifreq.ifr_name));\n            if(ioctl(fd, SIOCGIFHWADDR, &ifreq)<0)continue;\n            addr = ifreq.ifr_hwaddr.sa_data;\n            sprintf(mac_address,\"%02x:%02x:%02x:%02x:%02x:%02x\",\n                    addr[0], addr[1], addr[2], addr[3], addr[4], addr[5]);\n        }\n    }\n    close(fd);\n#else\n    //bsd\n    mac_address[0]=0;\n    struct ifaddrs *ifa_list, *ifa; \n    struct sockaddr_dl *dl; \n    unsigned char *addr;\n    if(getifaddrs(&ifa_list)<0)return;\n    for(ifa = ifa_list;ifa;ifa = ifa->ifa_next){ \n        dl = (struct sockaddr_dl*)ifa->ifa_addr; \n        if (dl->sdl_family == AF_LINK && dl->sdl_type == IFT_ETHER) {\n            addr = (unsigned char*)LLADDR(dl);\n            sprintf(mac_address,\"%02x:%02x:%02x:%02x:%02x:%02x\",\n                addr[0], addr[1], addr[2], addr[3], addr[4], addr[5]);\n            return;\n        }\n    } \n    freeifaddrs(ifa_list); \n#endif\n}\n\n\n\n```c:getmacaddress.c\n#include <stdio.h>\n\n#if defined(WIN32) || (!defined(__GNUC__) && !defined(__clang__))\n\t#include <winsock2.h>\n\t#include <iphlpapi.h>\n\t#include <stdlib.h>\n\t#pragma comment(lib, \"IPHLPAPI.lib\")\n#elif defined(__linux__)\n\t#include <string.h> //strncpy\n\t#include <sys/ioctl.h>\n\t#include <sys/socket.h>\n\t#include <net/if.h>\n#else\n\t//bsd\n\t#include <ifaddrs.h>\n\t#include <net/if.h>\n\t#include <net/if_dl.h>\n\t#include <net/if_types.h>\n#endif\n\nvoid getmacaddress(char *mac_address){\n#if defined(WIN32) || (!defined(__GNUC__) && !defined(__clang__))\n\t//MSDN\u306e\u30b5\u30f3\u30d7\u30eb\u30b3\u30fc\u30c9\n\tPIP_ADAPTER_INFO pAdapterInfo;\n\tPIP_ADAPTER_INFO pAdapter;\n\tULONG ulOutBufLen = sizeof(IP_ADAPTER_INFO);\n\tunsigned char *addr;\n\n\tmac_address[0]=0;\n\tpAdapterInfo = (IP_ADAPTER_INFO*)malloc(sizeof(IP_ADAPTER_INFO));\n\tif(!pAdapterInfo)return;\n\tif(GetAdaptersInfo(pAdapterInfo, &ulOutBufLen) == ERROR_BUFFER_OVERFLOW){\n\t\tfree(pAdapterInfo);\n\t\tpAdapterInfo = (IP_ADAPTER_INFO*)malloc(ulOutBufLen);\n\t\tif(!pAdapterInfo)return;\n\t}\n\n\tif(GetAdaptersInfo(pAdapterInfo, &ulOutBufLen) == NO_ERROR){\n\t\tpAdapter = pAdapterInfo;\n\t\tif(pAdapter){\n\t\t\taddr = pAdapter->Address;\n\t\t\tsprintf(mac_address,\"%02x:%02x:%02x:%02x:%02x:%02x\",\n\t\t\t\taddr[0], addr[1], addr[2], addr[3], addr[4], addr[5]);\n\t\t}\n\t}\n\tfree(pAdapterInfo);\n#elif defined(__linux__)\n\t//http://field-notes.hatenablog.jp/entry/20101216/1292467817\n\tmac_address[0]=0;\n\tstruct ifreq *ifr, *ifend;\n\tstruct ifreq ifreq;\n\tstruct ifconf ifc;\n\tstruct ifreq ifs[16];\n\tint fd;\n\tunsigned char *addr;\n\n\tfd = socket(AF_INET, SOCK_DGRAM, 0);\n\tifc.ifc_len = sizeof(ifs);\n\tifc.ifc_req = ifs;\n\tif(ioctl(fd, SIOCGIFCONF, &ifc)<0){close(fd);return;}\n\n\tifend = ifs + (ifc.ifc_len / sizeof(struct ifreq));\n\tfor(ifr = ifc.ifc_req;ifr < ifend;ifr++){\n\t\tif(ifr->ifr_addr.sa_family == AF_INET){\n\t\t\tstrncpy(ifreq.ifr_name, ifr->ifr_name, sizeof(ifreq.ifr_name));\n\t\t\tif(ioctl(fd, SIOCGIFHWADDR, &ifreq)<0)continue;\n\t\t\taddr = ifreq.ifr_hwaddr.sa_data;\n\t\t\tsprintf(mac_address,\"%02x:%02x:%02x:%02x:%02x:%02x\",\n\t\t\t\t\taddr[0], addr[1], addr[2], addr[3], addr[4], addr[5]);\n\t\t}\n\t}\n\tclose(fd);\n#else\n\t//bsd\n\tmac_address[0]=0;\n\tstruct ifaddrs *ifa_list, *ifa; \n\tstruct sockaddr_dl *dl; \n\tunsigned char *addr;\n\tif(getifaddrs(&ifa_list)<0)return;\n\tfor(ifa = ifa_list;ifa;ifa = ifa->ifa_next){ \n\t\tdl = (struct sockaddr_dl*)ifa->ifa_addr; \n\t\tif (dl->sdl_family == AF_LINK && dl->sdl_type == IFT_ETHER) {\n\t\t\taddr = (unsigned char*)LLADDR(dl);\n\t\t\tsprintf(mac_address,\"%02x:%02x:%02x:%02x:%02x:%02x\",\n\t\t\t\taddr[0], addr[1], addr[2], addr[3], addr[4], addr[5]);\n\t\t\treturn;\n\t\t}\n\t} \n\tfreeifaddrs(ifa_list); \n#endif\n}\n```\n"}