{"context": " More than 1 year has passed since last update.\n\n Lesson 2:  [simulated 16 bit addition]\n\nHave you ever been programming and needed to add one of the 8 bit\nregisters, to a 16 bit register pair? For example, you set hl to\npoint to the first byte of a table. Then you want the A-th byte (the\nbyte at HL+A). So one way to do this is to ld c,a \\ ld b,0 \\ add hl,bc\nNow this way works fine. But this destroys bc and if you need the other\nregister pair, you'll have to push it to the stack, 11 clockcycles\nfor each push and pop! But if you are doing this, and speed is of the\nessense, (like in a findpixel routine) then you might want to use the\n\"simulated 16 bit addition\". Or if you see this used, and wonder what\nis going on, here is a short explanation. Please note, i am not a\nteacher or a genius, so give me a break if stuff is incorrect or not\nsaid properly.\nOkay, lets look at the basic concept of the simulated 16 bit addition.\nSince you will always be adding 8 or less bits to the 16 bit register\npair, you will never need more than 9 bits (unless its negative, in\nwhich case i dont know if this works cause it doesnt change bit 15 of\nthe register pair. Can someone tell me maybe?) If when you add the 8\nbit register to the lower 8 bit register of the pair, if it is greater\nthan 255 a carry will result acting as the ninth bit. The answer could\nnever exceed 9 bits, %111111111 = 511 (nine bits), %11111111+%11111111\n=510 (8 bits plus 8 bits). So no problem there.\nex. 1:\n    L= 100  A=100\nadc a,l\n    result:                        8 bit answer 9th bit is the carry\n       L=100  A=200  c=0 -------> %011001000=200\nex. 2:\n    L=156  A=100\nadc a,l\n    result:                     lower 8 bits are A  9th bit, the carry\n       L=100  A=0  c=1--------> %100000000=256\nSo according to these conclusions, if we add A to L (lower byte of the\nregister pair, HL in this case), and then add the carry to H, (the real\n9th bit of the 16 bit register pair) then we have added A to HL\nsucessfully.\n\"Why the shit would i want to do that?\", youre thinking. Its all for the\nextra speed. Its not that complicated and it is faster by 2 clockcycles.\nPlus if you dont want to destroy another register pair, you would have to\npush them and pop them back, totaling in 22 clockcylces to push and pop\nalone!! Its just better.\n\"2 clockcycles, big deal!\" youre thinking. Well two here and two there,\nafter a while, if you have a lot, you may save 20-30 clockcylces, plus if\nyoure looping 20 times a second in your game, thats 2 clockcycles times\n20 loops a second, 40 clockcycles a second faster!!!\nNow we'll take a look at the clock cycles for the different algorithms.\n\n\n\nCycles\nCode\n====\ncycles\nCode\n\n\n\n\n4\nld e,a\n====\n4\nadd a,l\n\n\n7\nld d,0\n====\n4\nld l,a\n\n\n11\nadd hl,de\n====\n4\nadc a,h\n\n\n\n\n====\n4\nsub l\n\n\n\n\n====\n4\nld h,a\n\n\n\n22  total\n====\n\n20 total\n\n\n\n2 clockcycles faster\nOkay thats it for this lesson, now i'll just show a quick example. Please\nsend comments, ideas, or corrections to ephesus@gmail.com. They will be\ncorrected immediately.\nEX. 1:\n  Pretend we are making a game where there is a gravity table. When your\nman just started jumping, he will go up more pixels than when he is at the\npeak of his jump, to create the illusion of gravity, right?\njdist = _textShadow ;this is going to be how far into the jump your man is\n\nloop:\n  ld hl,gravitytable\n  ld a,(jdist)      ;how far should we go into the table\n  add a,l           ;add the 8 bit number to the lower 8 bits of the    \n  ld l,a            ;register pair, store any overflow in the carry\n                    ;the result is stored in A, but we want it in L\n                    ;so...  ld l,a\n  adc a,h           ;add any over flow into h. We want adc h but that\n                    ;isnt allowed, so we do this.\n  sub l             ;all we want is the carry added, not the contents of\n                    ;A too, so we subtract L (L=value of A that was added\n  ld h,a            ;before, a has changed since then) .\n  ld a,(hl)         ;load into A the byte pointed to by HL, voila!!\n\n  ;Do something with that number whatever you want\n\n\n\ngravitytable:\n        .db 3,3,3,3,2,2,2,2,2,1,1,1,1,0,0\n\n-=--------------------------------------------\nJames Rubingh\nephesus@gmail.com\nhttp://www.wrive.com\n   **Lesson 2:  [simulated 16 bit addition]**\n------------------------------------------------------------------\n\nHave you ever been programming and needed to add one of the 8 bit\nregisters, to a 16 bit register pair? For example, you set hl to\npoint to the first byte of a table. Then you want the A-th byte (the\nbyte at HL+A). So one way to do this is to ld c,a \\ ld b,0 \\ add hl,bc\nNow this way works fine. But this destroys bc and if you need the other\nregister pair, you'll have to push it to the stack, 11 clockcycles\nfor each push and pop! But if you are doing this, and speed is of the\nessense, (like in a findpixel routine) then you might want to use the\n\"simulated 16 bit addition\". Or if you see this used, and wonder what\nis going on, here is a short explanation. Please note, i am not a\nteacher or a genius, so give me a break if stuff is incorrect or not\nsaid properly.\n\nOkay, lets look at the basic concept of the simulated 16 bit addition.\nSince you will always be adding 8 or less bits to the 16 bit register\npair, you will never need more than 9 bits (unless its negative, in\nwhich case i dont know if this works cause it doesnt change bit 15 of\nthe register pair. Can someone tell me maybe?) If when you add the 8\nbit register to the lower 8 bit register of the pair, if it is greater\nthan 255 a carry will result acting as the ninth bit. The answer could\nnever exceed 9 bits, %111111111 = 511 (nine bits), %11111111+%11111111\n=510 (8 bits plus 8 bits). So no problem there.\n\n**ex. 1:**\n    L= 100  A=100\n        `adc a,l`       \n    result:                        8 bit answer 9th bit is the carry\n       L=100  A=200  c=0 -------> %011001000=200\n\n**ex. 2:**\n    L=156  A=100\n        `adc a,l`\n    result:                     lower 8 bits are A  9th bit, the carry\n       L=100  A=0  c=1--------> %100000000=256\n\nSo according to these conclusions, if we add A to L (lower byte of the\nregister pair, HL in this case), and then add the carry to H, (the real\n9th bit of the 16 bit register pair) then we have added A to HL\nsucessfully.\n\"Why the shit would i want to do that?\", youre thinking. Its all for the\nextra speed. Its not that complicated and it is faster by 2 clockcycles.\nPlus if you dont want to destroy another register pair, you would have to\npush them and pop them back, totaling in 22 clockcylces to push and pop\nalone!! Its just better.\n\"2 clockcycles, big deal!\" youre thinking. Well two here and two there,\nafter a while, if you have a lot, you may save 20-30 clockcylces, plus if\nyoure looping 20 times a second in your game, thats 2 clockcycles times\n20 loops a second, 40 clockcycles a second faster!!!\n\nNow we'll take a look at the clock cycles for the different algorithms.\n\nCycles | Code |====| cycles | Code\n------|-------|-------|----|-------\n4 |`ld e,a`       |====|     4|   `add a,l`|\n7 |   `ld d,0`    |====|     4|   `ld l,a` |\n11|  `add hl,de`  |====|     4|   `adc a,h`|\n  |             |====|     4|   `sub l`|\n |              |====|     4|  `ld h,a`|\n  |22  total|====||           20 total|\n\n2 clockcycles faster\n\nOkay thats it for this lesson, now i'll just show a quick example. Please\nsend comments, ideas, or corrections to <ephesus@gmail.com>. They will be\ncorrected immediately.\n\n**EX. 1:**\n  Pretend we are making a game where there is a gravity table. When your\nman just started jumping, he will go up more pixels than when he is at the\npeak of his jump, to create the illusion of gravity, right?\n\n```z80asm\njdist = _textShadow ;this is going to be how far into the jump your man is\n\nloop:\n  ld hl,gravitytable\n  ld a,(jdist)      ;how far should we go into the table\n  add a,l           ;add the 8 bit number to the lower 8 bits of the    \n  ld l,a            ;register pair, store any overflow in the carry\n                    ;the result is stored in A, but we want it in L\n                    ;so...  ld l,a\n  adc a,h           ;add any over flow into h. We want adc h but that\n                    ;isnt allowed, so we do this.\n  sub l             ;all we want is the carry added, not the contents of\n                    ;A too, so we subtract L (L=value of A that was added\n  ld h,a            ;before, a has changed since then) .\n  ld a,(hl)         ;load into A the byte pointed to by HL, voila!!\n\n  ;Do something with that number whatever you want\n\n\n\ngravitytable:\n        .db 3,3,3,3,2,2,2,2,2,1,1,1,1,0,0\n```\n-=--------------------------------------------\nJames Rubingh\nephesus@gmail.com\nhttp://www.wrive.com\n", "tags": ["Z80", "assembly", "gameboy", "test"]}