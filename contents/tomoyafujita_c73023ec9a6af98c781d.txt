{"tags": ["Linux", "KVM"], "context": "here is the kvm framework overview, just for my interests i took a look at the framework. \nqemu(user process) <--- via ioctl(2) ---> kvm(kernel driver) is the simplest view.\n\nqemu includes device emulator, when guest os tried to issue I/O,\nkvm passes it to the qemu process to handle it to the actual devices.\nqemu has a cpu emulator for platform such as arm,ppc,sparc...\nof course there should be certain overhead for emulation.\nXen/kzm both can overcommit memory and cpu resources\nbut since kvm is total virtualization I/O is slower than Xen, i think.\n\n\n\n\nvirt/kvm/kvm_main.c\nstatic long kvm_vcpu_ioctl(struct file *filp,\n               unsigned int ioctl, unsigned long arg)\n{\n    struct kvm_vcpu *vcpu = filp->private_data;\n    void __user *argp = (void __user *)arg;\n    int r;\n    struct kvm_fpu *fpu = NULL;\n    struct kvm_sregs *kvm_sregs = NULL;\n\n    if (vcpu->kvm->mm != current->mm)\n        return -EIO;\n\n#if defined(CONFIG_S390) || defined(CONFIG_PPC)\n    /*\n     * Special cases: vcpu ioctls that are asynchronous to vcpu execution,\n     * so vcpu_load() would break it.\n     */\n    if (ioctl == KVM_S390_INTERRUPT || ioctl == KVM_INTERRUPT)\n        return kvm_arch_vcpu_ioctl(filp, ioctl, arg);\n#endif\n\n\n    vcpu_load(vcpu);\n    switch (ioctl) {\n    case KVM_RUN:\n        r = -EINVAL;\n        if (arg)\n            goto out;\n        r = kvm_arch_vcpu_ioctl_run(vcpu, vcpu->run);\n        trace_kvm_userspace_exit(vcpu->run->exit_reason, r);\n        break;\n\n-> kvm_arch_vcpu_ioctl_run\u304b\u3089arch\u3054\u3068\u306b\u6e96\u5099\u3055\u308c\u3066\u3044\u308b\u95a2\u6570\u3078\u5165\u308b\u3002\n   KVM_RUN\u306fguest os\u3078\u306eenter\u3078\u5229\u7528\u3055\u308c\u308b\u304c\u3001ioctl(2)\u306b\u306f\u4ee5\u4e0b\u306e\u901a\u308a\u6e96\u5099\u3055\u308c\u3066\u3044\u308b\u3002\n\n\n\n\ninclude/linux/kvm.h\n#define KVM_RUN                   _IO(KVMIO,   0x80)\n#define KVM_GET_REGS              _IOR(KVMIO,  0x81, struct kvm_regs)\n#define KVM_SET_REGS              _IOW(KVMIO,  0x82, struct kvm_regs)\n#define KVM_GET_SREGS             _IOR(KVMIO,  0x83, struct kvm_sregs)\n#define KVM_SET_SREGS             _IOW(KVMIO,  0x84, struct kvm_sregs)\n#define KVM_TRANSLATE             _IOWR(KVMIO, 0x85, struct kvm_translation)\n#define KVM_INTERRUPT             _IOW(KVMIO,  0x86, struct kvm_interrupt)\n/* KVM_DEBUG_GUEST is no longer supported, use KVM_SET_GUEST_DEBUG instead */\n#define KVM_DEBUG_GUEST           __KVM_DEPRECATED_VCPU_W_0x87\n#define KVM_GET_MSRS              _IOWR(KVMIO, 0x88, struct kvm_msrs)\n#define KVM_SET_MSRS              _IOW(KVMIO,  0x89, struct kvm_msrs)\n#define KVM_SET_CPUID             _IOW(KVMIO,  0x8a, struct kvm_cpuid)\n#define KVM_SET_SIGNAL_MASK       _IOW(KVMIO,  0x8b, struct kvm_signal_mask)\n#define KVM_GET_FPU               _IOR(KVMIO,  0x8c, struct kvm_fpu)\n#define KVM_SET_FPU               _IOW(KVMIO,  0x8d, struct kvm_fpu)\n#define KVM_GET_LAPIC             _IOR(KVMIO,  0x8e, struct kvm_lapic_state)\n#define KVM_SET_LAPIC             _IOW(KVMIO,  0x8f, struct kvm_lapic_state)\n#define KVM_SET_CPUID2            _IOW(KVMIO,  0x90, struct kvm_cpuid2)\n#define KVM_GET_CPUID2            _IOWR(KVMIO, 0x91, struct kvm_cpuid2)\n/* Available with KVM_CAP_VAPIC */\n#define KVM_TPR_ACCESS_REPORTING  _IOWR(KVMIO, 0x92, struct kvm_tpr_access_ctl)\n/* Available with KVM_CAP_VAPIC */\n#define KVM_SET_VAPIC_ADDR        _IOW(KVMIO,  0x93, struct kvm_vapic_addr)\n/* valid for virtual machine (for floating interrupt)_and_ vcpu */\n#define KVM_S390_INTERRUPT        _IOW(KVMIO,  0x94, struct kvm_s390_interrupt)\n/* store status for s390 */\n#define KVM_S390_STORE_STATUS_NOADDR    (-1ul)\n#define KVM_S390_STORE_STATUS_PREFIXED  (-2ul)\n#define KVM_S390_STORE_STATUS     _IOW(KVMIO,  0x95, unsigned long)\n/* initial ipl psw for s390 */\n#define KVM_S390_SET_INITIAL_PSW  _IOW(KVMIO,  0x96, struct kvm_s390_psw)\n/* initial reset for s390 */\n#define KVM_S390_INITIAL_RESET    _IO(KVMIO,   0x97)\n#define KVM_GET_MP_STATE          _IOR(KVMIO,  0x98, struct kvm_mp_state)\n#define KVM_SET_MP_STATE          _IOW(KVMIO,  0x99, struct kvm_mp_state)\n/* Available with KVM_CAP_NMI */\n#define KVM_NMI                   _IO(KVMIO,   0x9a)\n/* Available with KVM_CAP_SET_GUEST_DEBUG */\n#define KVM_SET_GUEST_DEBUG       _IOW(KVMIO,  0x9b, struct kvm_guest_debug)\n/* MCE for x86 */\n#define KVM_X86_SETUP_MCE         _IOW(KVMIO,  0x9c, __u64)\n#define KVM_X86_GET_MCE_CAP_SUPPORTED _IOR(KVMIO,  0x9d, __u64)\n#define KVM_X86_SET_MCE           _IOW(KVMIO,  0x9e, struct kvm_x86_mce)\n/* IA64 stack access */\n#define KVM_IA64_VCPU_GET_STACK   _IOR(KVMIO,  0x9a, void *)\n#define KVM_IA64_VCPU_SET_STACK   _IOW(KVMIO,  0x9b, void *)\n/* Available with KVM_CAP_VCPU_EVENTS */\n#define KVM_GET_VCPU_EVENTS       _IOR(KVMIO,  0x9f, struct kvm_vcpu_events)\n#define KVM_SET_VCPU_EVENTS       _IOW(KVMIO,  0xa0, struct kvm_vcpu_events)\n/* Available with KVM_CAP_DEBUGREGS */\n#define KVM_GET_DEBUGREGS         _IOR(KVMIO,  0xa1, struct kvm_debugregs)\n#define KVM_SET_DEBUGREGS         _IOW(KVMIO,  0xa2, struct kvm_debugregs)\n#define KVM_ENABLE_CAP            _IOW(KVMIO,  0xa3, struct kvm_enable_cap)\n/* Available with KVM_CAP_XSAVE */\n#define KVM_GET_XSAVE         _IOR(KVMIO,  0xa4, struct kvm_xsave)\n#define KVM_SET_XSAVE         _IOW(KVMIO,  0xa5, struct kvm_xsave)\n/* Available with KVM_CAP_XCRS */\n#define KVM_GET_XCRS          _IOR(KVMIO,  0xa6, struct kvm_xcrs)\n#define KVM_SET_XCRS          _IOW(KVMIO,  0xa7, struct kvm_xcrs)\n#define KVM_CREATE_SPAPR_TCE      _IOW(KVMIO,  0xa8, struct kvm_create_spapr_tce)\n/* Available with KVM_CAP_RMA */\n#define KVM_ALLOCATE_RMA      _IOR(KVMIO,  0xa9, struct kvm_allocate_rma)\n/* Available with KVM_CAP_SW_TLB */\n#define KVM_DIRTY_TLB         _IOW(KVMIO,  0xaa, struct kvm_dirty_tlb)\n/* Available with KVM_CAP_ONE_REG */\n#define KVM_GET_ONE_REG       _IOW(KVMIO,  0xab, struct kvm_one_reg)\n#define KVM_SET_ONE_REG       _IOW(KVMIO,  0xac, struct kvm_one_reg)\n/* VM is being stopped by host */\n#define KVM_KVMCLOCK_CTRL     _IO(KVMIO,   0xad)\n\n\n[tips]\ni was checking the linux-3.6.8 base, it seems that does not support kvm for ARM platform though.seems like it has to be 3.9 or later. and also QEMU is 1.5 or later for ARM.\nhere is the kvm framework overview, just for my interests i took a look at the framework. \nqemu(user process) <--- via ioctl(2) ---> kvm(kernel driver) is the simplest view.\n\n* qemu includes device emulator, when guest os tried to issue I/O,\n  kvm passes it to the qemu process to handle it to the actual devices.\n* qemu has a cpu emulator for platform such as arm,ppc,sparc...\n  of course there should be certain overhead for emulation.\n* Xen/kzm both can overcommit memory and cpu resources\n  but since kvm is total virtualization I/O is slower than Xen, i think.\n\n![image](https://qiita-image-store.s3.amazonaws.com/0/112819/7c7e1e3d-5ed1-5689-ff7e-b54e843aa14a.png)\n\n![image](https://qiita-image-store.s3.amazonaws.com/0/112819/3d8cae2d-60cd-3d95-955d-a4f2c6227a78.png)\n\n```c:virt/kvm/kvm_main.c\nstatic long kvm_vcpu_ioctl(struct file *filp,\n\t\t\t   unsigned int ioctl, unsigned long arg)\n{\n\tstruct kvm_vcpu *vcpu = filp->private_data;\n\tvoid __user *argp = (void __user *)arg;\n\tint r;\n\tstruct kvm_fpu *fpu = NULL;\n\tstruct kvm_sregs *kvm_sregs = NULL;\n\n\tif (vcpu->kvm->mm != current->mm)\n\t\treturn -EIO;\n\n#if defined(CONFIG_S390) || defined(CONFIG_PPC)\n\t/*\n\t * Special cases: vcpu ioctls that are asynchronous to vcpu execution,\n\t * so vcpu_load() would break it.\n\t */\n\tif (ioctl == KVM_S390_INTERRUPT || ioctl == KVM_INTERRUPT)\n\t\treturn kvm_arch_vcpu_ioctl(filp, ioctl, arg);\n#endif\n\n\n\tvcpu_load(vcpu);\n\tswitch (ioctl) {\n\tcase KVM_RUN:\n\t\tr = -EINVAL;\n\t\tif (arg)\n\t\t\tgoto out;\n\t\tr = kvm_arch_vcpu_ioctl_run(vcpu, vcpu->run);\n\t\ttrace_kvm_userspace_exit(vcpu->run->exit_reason, r);\n\t\tbreak;\n\n-> kvm_arch_vcpu_ioctl_run\u304b\u3089arch\u3054\u3068\u306b\u6e96\u5099\u3055\u308c\u3066\u3044\u308b\u95a2\u6570\u3078\u5165\u308b\u3002\n   KVM_RUN\u306fguest os\u3078\u306eenter\u3078\u5229\u7528\u3055\u308c\u308b\u304c\u3001ioctl(2)\u306b\u306f\u4ee5\u4e0b\u306e\u901a\u308a\u6e96\u5099\u3055\u308c\u3066\u3044\u308b\u3002\n\n```\n\n```c:include/linux/kvm.h\n#define KVM_RUN                   _IO(KVMIO,   0x80)\n#define KVM_GET_REGS              _IOR(KVMIO,  0x81, struct kvm_regs)\n#define KVM_SET_REGS              _IOW(KVMIO,  0x82, struct kvm_regs)\n#define KVM_GET_SREGS             _IOR(KVMIO,  0x83, struct kvm_sregs)\n#define KVM_SET_SREGS             _IOW(KVMIO,  0x84, struct kvm_sregs)\n#define KVM_TRANSLATE             _IOWR(KVMIO, 0x85, struct kvm_translation)\n#define KVM_INTERRUPT             _IOW(KVMIO,  0x86, struct kvm_interrupt)\n/* KVM_DEBUG_GUEST is no longer supported, use KVM_SET_GUEST_DEBUG instead */\n#define KVM_DEBUG_GUEST           __KVM_DEPRECATED_VCPU_W_0x87\n#define KVM_GET_MSRS              _IOWR(KVMIO, 0x88, struct kvm_msrs)\n#define KVM_SET_MSRS              _IOW(KVMIO,  0x89, struct kvm_msrs)\n#define KVM_SET_CPUID             _IOW(KVMIO,  0x8a, struct kvm_cpuid)\n#define KVM_SET_SIGNAL_MASK       _IOW(KVMIO,  0x8b, struct kvm_signal_mask)\n#define KVM_GET_FPU               _IOR(KVMIO,  0x8c, struct kvm_fpu)\n#define KVM_SET_FPU               _IOW(KVMIO,  0x8d, struct kvm_fpu)\n#define KVM_GET_LAPIC             _IOR(KVMIO,  0x8e, struct kvm_lapic_state)\n#define KVM_SET_LAPIC             _IOW(KVMIO,  0x8f, struct kvm_lapic_state)\n#define KVM_SET_CPUID2            _IOW(KVMIO,  0x90, struct kvm_cpuid2)\n#define KVM_GET_CPUID2            _IOWR(KVMIO, 0x91, struct kvm_cpuid2)\n/* Available with KVM_CAP_VAPIC */\n#define KVM_TPR_ACCESS_REPORTING  _IOWR(KVMIO, 0x92, struct kvm_tpr_access_ctl)\n/* Available with KVM_CAP_VAPIC */\n#define KVM_SET_VAPIC_ADDR        _IOW(KVMIO,  0x93, struct kvm_vapic_addr)\n/* valid for virtual machine (for floating interrupt)_and_ vcpu */\n#define KVM_S390_INTERRUPT        _IOW(KVMIO,  0x94, struct kvm_s390_interrupt)\n/* store status for s390 */\n#define KVM_S390_STORE_STATUS_NOADDR    (-1ul)\n#define KVM_S390_STORE_STATUS_PREFIXED  (-2ul)\n#define KVM_S390_STORE_STATUS\t  _IOW(KVMIO,  0x95, unsigned long)\n/* initial ipl psw for s390 */\n#define KVM_S390_SET_INITIAL_PSW  _IOW(KVMIO,  0x96, struct kvm_s390_psw)\n/* initial reset for s390 */\n#define KVM_S390_INITIAL_RESET    _IO(KVMIO,   0x97)\n#define KVM_GET_MP_STATE          _IOR(KVMIO,  0x98, struct kvm_mp_state)\n#define KVM_SET_MP_STATE          _IOW(KVMIO,  0x99, struct kvm_mp_state)\n/* Available with KVM_CAP_NMI */\n#define KVM_NMI                   _IO(KVMIO,   0x9a)\n/* Available with KVM_CAP_SET_GUEST_DEBUG */\n#define KVM_SET_GUEST_DEBUG       _IOW(KVMIO,  0x9b, struct kvm_guest_debug)\n/* MCE for x86 */\n#define KVM_X86_SETUP_MCE         _IOW(KVMIO,  0x9c, __u64)\n#define KVM_X86_GET_MCE_CAP_SUPPORTED _IOR(KVMIO,  0x9d, __u64)\n#define KVM_X86_SET_MCE           _IOW(KVMIO,  0x9e, struct kvm_x86_mce)\n/* IA64 stack access */\n#define KVM_IA64_VCPU_GET_STACK   _IOR(KVMIO,  0x9a, void *)\n#define KVM_IA64_VCPU_SET_STACK   _IOW(KVMIO,  0x9b, void *)\n/* Available with KVM_CAP_VCPU_EVENTS */\n#define KVM_GET_VCPU_EVENTS       _IOR(KVMIO,  0x9f, struct kvm_vcpu_events)\n#define KVM_SET_VCPU_EVENTS       _IOW(KVMIO,  0xa0, struct kvm_vcpu_events)\n/* Available with KVM_CAP_DEBUGREGS */\n#define KVM_GET_DEBUGREGS         _IOR(KVMIO,  0xa1, struct kvm_debugregs)\n#define KVM_SET_DEBUGREGS         _IOW(KVMIO,  0xa2, struct kvm_debugregs)\n#define KVM_ENABLE_CAP            _IOW(KVMIO,  0xa3, struct kvm_enable_cap)\n/* Available with KVM_CAP_XSAVE */\n#define KVM_GET_XSAVE\t\t  _IOR(KVMIO,  0xa4, struct kvm_xsave)\n#define KVM_SET_XSAVE\t\t  _IOW(KVMIO,  0xa5, struct kvm_xsave)\n/* Available with KVM_CAP_XCRS */\n#define KVM_GET_XCRS\t\t  _IOR(KVMIO,  0xa6, struct kvm_xcrs)\n#define KVM_SET_XCRS\t\t  _IOW(KVMIO,  0xa7, struct kvm_xcrs)\n#define KVM_CREATE_SPAPR_TCE\t  _IOW(KVMIO,  0xa8, struct kvm_create_spapr_tce)\n/* Available with KVM_CAP_RMA */\n#define KVM_ALLOCATE_RMA\t  _IOR(KVMIO,  0xa9, struct kvm_allocate_rma)\n/* Available with KVM_CAP_SW_TLB */\n#define KVM_DIRTY_TLB\t\t  _IOW(KVMIO,  0xaa, struct kvm_dirty_tlb)\n/* Available with KVM_CAP_ONE_REG */\n#define KVM_GET_ONE_REG\t\t  _IOW(KVMIO,  0xab, struct kvm_one_reg)\n#define KVM_SET_ONE_REG\t\t  _IOW(KVMIO,  0xac, struct kvm_one_reg)\n/* VM is being stopped by host */\n#define KVM_KVMCLOCK_CTRL\t  _IO(KVMIO,   0xad)\n```\n\n[tips]\ni was checking the linux-3.6.8 base, it seems that does not support kvm for ARM platform though.seems like it has to be 3.9 or later. and also QEMU is 1.5 or later for ARM.\n"}