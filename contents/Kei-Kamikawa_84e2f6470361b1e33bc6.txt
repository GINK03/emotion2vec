{"tags": ["Swift", "Binary", "\u6b63\u898f\u8868\u73fe", "Perl"], "context": "\u6c96\u7e04\u3067\u306f\u8749\u304c\u9cf4\u304f\u5b63\u7bc0\u304c\u3084\u3063\u3066\u304d\u307e\u3057\u305f\u306d\uff01\u53cb\u4eba\u3082\u9cf4\u3044\u3066\u307e\u3057\u305f\uff01\uff01\n\n\uff90\uff70\uff9d\uff90\uff9d\uff90\uff9d\uff90\uff70\uff9d...\uff90\uff70\uff9d\uff90\uff9d\uff90\uff9d\uff90\uff70\uff9d...\uff90\uff70\uff9d\uff90\uff9d\uff90\uff9d\uff90\uff70\uff9d...\uff90\uff70\uff9d\uff90\uff9d\uff90\uff9d\uff90\uff70\uff9d...\uff90\uff70\uff9d\uff90\uff9d\uff90\uff9d\uff90\uff70\uff9d...\uff90\uff70\uff9d\uff90\uff9d\uff90\uff9d\uff90\uff70\uff9d...\uff90\uff70\uff9d\uff90\uff9d\uff90\uff9d\uff90\uff70\uff9d...\uff90\uff70\uff9d\uff90\uff9d\uff90\uff9d\uff90\uff70\uff9d...\uff90\uff70\uff9d\uff90\uff9d\uff90\uff9d\uff90\uff70\uff9d...\uff90\uff70\uff9d\uff90\uff9d\uff90\uff9d\uff90\uff70\uff9d...\uff90\uff70\uff9d\uff90\uff9d\uff90\uff9d\uff90\uff70\uff9d\u2014 \u3042\u308b\u30de\u30b9 (@walkingmask) 2016\u5e746\u67084\u65e5\n\n6\u6708\u3068\u306f\u601d\u3048\u306a\u3044\u6691\u3055\u3067\u3059\u3082\u3093\u306d\uff01\n\u3067\u306f\u672c\u984c\u3067\u3059.\n\nSemiEncoder\nSemiEncoder \u306b\u306f\u4ee5\u4e0b\u306e\u30eb\u30fc\u30eb\u304c\u3042\u308a\u307e\u3059.\n\n\u6587\u5b57\u5217\u304b\u3089\u30d0\u30a4\u30ca\u30ea\u6587\u5b57\u5217\u3092\u4f5c\u6210\n\"0\" \u3092 \"\uff90\uff9d\", \"1\" \u3092 \"\uff90\uff70\uff9d\" \u3078\u5909\u63db\n\"\uff90\uff70\uff9d\uff90\uff9d\uff90\uff9d\" \u306e\u5f8c\u308d\u306b \"\u2026\" \u304c\u7d9a\u304f(\uff90\uff70\uff9d\uff90\uff9d\uff90\uff9d\u2026)\n\n\u7c21\u5358\u3067\u3059\u306d\uff01\n\nSemiDecoder\nSemiDecoder \u306b\u95a2\u3057\u3066\u306f SemiEncode \u306e\u624b\u9806\u3092\u5168\u3066\u9006\u9806\u3067\u884c\u3048\u3070\u3067\u304d\u307e\u3059\u306d\uff01\n\n\u5b9f\u88c5\n\u6700\u521d\u306e extension \u306f \u4e0a\u304b\u3089\u30d0\u30a4\u30ca\u30ea\u6587\u5b57\u5217\u3078\u5909\u63db, \u30d0\u30a4\u30ca\u30ea\u6587\u5b57\u5217\u304b\u3089\u5143\u306e\u6587\u5b57\u5217\u3078\u306e\u5909\u63db, \u30d0\u30a4\u30ca\u30ea\u6587\u5b57\u5217\u306e\u30d1\u30c7\u30a3\u30f3\u30b0, \u6b63\u898f\u8868\u73fe\u3067\u30de\u30c3\u30c1\u3057\u305f\u90e8\u5206\u306e\u6587\u5b57\u5217\u306e Array \u3092\u4f5c\u6210, \u6b63\u898f\u8868\u73fe\u3067\u30de\u30c3\u30c1\u3057\u305f\u6587\u5b57\u5217\u3092\u7f6e\u63db\u3059\u308b\u305f\u3081\u306e\u30e1\u30bd\u30c3\u30c9\u3092\u66f8\u3044\u3066\u307e\u3059.\n\u5c11\u3057\u9577\u3044\u3067\u3059\u304c, \u30e1\u30a4\u30f3\u306f\u4e00\u756a\u4e0b\u306e extension \u306e\u90e8\u5206\u3067\u3059.\nimport Foundation\n\nextension String {\n\n    var binary: String {\n        let chars = self.characters.map { String($0).unicodeScalars.first!.value }\n        return chars.map({ String($0, radix: 2).pad(24) }).joinWithSeparator(\"\")\n    }\n\n    func bintostr() -> String {\n        let binaries = self.match(\"[01]{1,24}\")\n        var orig = \"\"\n        for b in binaries {\n            orig += String(UnicodeScalar(Int(strtoul(b, nil, 2))))\n        }\n        return orig\n    }\n\n    func pad(toSize: Int) -> String {\n        var padded = self\n        for _ in 0..<toSize - self.characters.count {\n            padded = \"0\" + padded\n        }\n        return padded\n    }\n\n    func match(pattern: String) -> [String] {\n        let regex = try! NSRegularExpression(pattern: pattern, options: [])\n        let range = NSMakeRange(0, self.characters.count)\n        let matches = regex.matchesInString(self, options: [], range: range)\n\n        var matchedTokens = [String]()\n        for result in matches {\n            for r in [result] {\n                if r.range.location <= self.characters.count && r.range.length > 0 {\n                    matchedTokens.append((self as NSString).substringWithRange(r.range))\n                }\n                break\n            }\n        }\n\n        return matchedTokens\n    }\n\n    func replace(pattern: String, _ withString: String) -> String {\n        let regex = try! NSRegularExpression(pattern: pattern, options: [])\n        let range = NSMakeRange(0, self.characters.count)\n        return regex.stringByReplacingMatchesInString(self, options: [], range: range, withTemplate: withString)\n    }\n}\n\n// SemiEncode, SemiDecode\nextension String {\n    func SemiEncode() -> String {\n        return self.binary.replace(\"0\", \"\uff90\uff9d\").replace(\"1\", \"\uff90\uff70\uff9d\").replace(\"(\uff90\uff70\uff9d\uff90\uff9d\uff90\uff9d)\", \"$0\u2026\")\n    }\n\n    func SemiDecode() -> String {\n        return self.replace(\"\u2026\", \"\").replace(\"\uff90\uff9d\", \"0\").replace(\"\uff90\uff70\uff9d\", \"1\").bintostr()\n    }\n}\n\n\u4ed6\u306e\u30e1\u30bd\u30c3\u30c9\u304c\u9577\u3044\u9577\u3044www\n\u30d0\u30a4\u30ca\u30ea\u6587\u5b57\u5217\u306e\u6841\u6570\u3092 24 \u6841\u306b\u3057\u3066\u3044\u308b\u306e\u306f Unicode \u306e\u6570\u304c 166=22416^6 = 2^{24} \u672a\u6e80\u3060\u304b\u3089\u3067\u3059\uff01\uff01\uff08\u81ea\u4fe1\u7121\u3044\uff09\n\n\u5b9f\u884c\n\u3053\u3093\u306a\u611f\u3058\u306e\u30b3\u30fc\u30c9\u3092\u66f8\u304f\u3068\u5b9f\u884c\u3067\u304d\u308b\u306f\u305a\u2026!!\nlet str = \"\u304a\u524d\u306e\u30ab\u30fc\u30c1\u30e3\u30f3\ud83c\udf63\uff68\uff68\uff68\uff68\uff68\u301cwww\"\nlet crows = str.SemiEncode() // \uff90\uff9d\uff90\uff9d\uff90\uff9d\uff90\uff9d\uff90\uff9d\uff90\uff9d\uff90\uff9d\uff90\uff9d\uff90\uff9d\uff90\uff9d\uff90\uff70\uff9d\uff90\uff70\uff9d\uff90\uff9d\uff90\uff9d\u2026\ncrows.SemiDecode() // \u304a\u524d\u306e\u30ab\u30fc\u30c1\u30e3\u30f3\ud83c\udf63\uff68\uff68\uff68\uff68\uff68\u301cwww\n\n\n\u304a\u307e\u3051\nPerl\u3060\u3068\u3053\u3093\u306a\u306b\u7c21\u5358\u306b\u66f8\u3051\u308b\u306e\u306b...\n#!/usr/bin/env perl\nuse strict;\nuse warnings;\nuse utf8;\nuse Encode qw/encode_utf8/;\nuse v5.10;\n\nsub SemiEncode {\n    my $input = shift;\n    my $bit = unpack 'B*', $input;\n    $bit =~ s/0/\uff90\uff9d/g;\n    $bit =~ s/1/\uff90\uff70\uff9d/g;\n    $bit =~ s/(\uff90\uff70\uff9d\uff90\uff9d\uff90\uff9d)/$1\u2026/g;\n    return $bit;\n}\n\nsub SemiDecode {\n    my $meen = shift;\n    $meen =~ s/\u2026//g;\n    $meen =~ s/\uff90\uff9d/0/g;\n    $meen =~ s/\uff90\uff70\uff9d/1/g;\n    return pack 'B*', $meen;\n}\n\nmy $input = encode_utf8(\"\u304a\u524d\u306e\u30ab\u30fc\u30c1\u30e3\u30f3\ud83c\udf63\uff68\uff68\uff68\uff68\uff68\u301cwww\");\nmy $m = SemiEncode($input);\n\nsay encode_utf8($m);\nsay SemiDecode($m);\n\n\u6c96\u7e04\u3067\u306f\u8749\u304c\u9cf4\u304f\u5b63\u7bc0\u304c\u3084\u3063\u3066\u304d\u307e\u3057\u305f\u306d\uff01\u53cb\u4eba\u3082\u9cf4\u3044\u3066\u307e\u3057\u305f\uff01\uff01\n<blockquote class=\"twitter-tweet\" data-lang=\"ja\"><p lang=\"ja\" dir=\"ltr\">\uff90\uff70\uff9d\uff90\uff9d\uff90\uff9d\uff90\uff70\uff9d...\uff90\uff70\uff9d\uff90\uff9d\uff90\uff9d\uff90\uff70\uff9d...\uff90\uff70\uff9d\uff90\uff9d\uff90\uff9d\uff90\uff70\uff9d...\uff90\uff70\uff9d\uff90\uff9d\uff90\uff9d\uff90\uff70\uff9d...\uff90\uff70\uff9d\uff90\uff9d\uff90\uff9d\uff90\uff70\uff9d...\uff90\uff70\uff9d\uff90\uff9d\uff90\uff9d\uff90\uff70\uff9d...\uff90\uff70\uff9d\uff90\uff9d\uff90\uff9d\uff90\uff70\uff9d...\uff90\uff70\uff9d\uff90\uff9d\uff90\uff9d\uff90\uff70\uff9d...\uff90\uff70\uff9d\uff90\uff9d\uff90\uff9d\uff90\uff70\uff9d...\uff90\uff70\uff9d\uff90\uff9d\uff90\uff9d\uff90\uff70\uff9d...\uff90\uff70\uff9d\uff90\uff9d\uff90\uff9d\uff90\uff70\uff9d</p>&mdash; \u3042\u308b\u30de\u30b9 (@walkingmask) <a href=\"https://twitter.com/walkingmask/status/738941421491621889\">2016\u5e746\u67084\u65e5</a></blockquote>\n\n6\u6708\u3068\u306f\u601d\u3048\u306a\u3044\u6691\u3055\u3067\u3059\u3082\u3093\u306d\uff01\n\u3067\u306f\u672c\u984c\u3067\u3059.\n##SemiEncoder\nSemiEncoder \u306b\u306f\u4ee5\u4e0b\u306e\u30eb\u30fc\u30eb\u304c\u3042\u308a\u307e\u3059.\n\n1. \u6587\u5b57\u5217\u304b\u3089\u30d0\u30a4\u30ca\u30ea\u6587\u5b57\u5217\u3092\u4f5c\u6210\n2. \"0\" \u3092 \"\uff90\uff9d\", \"1\" \u3092 \"\uff90\uff70\uff9d\" \u3078\u5909\u63db\n3. \"\uff90\uff70\uff9d\uff90\uff9d\uff90\uff9d\" \u306e\u5f8c\u308d\u306b \"\u2026\" \u304c\u7d9a\u304f(\uff90\uff70\uff9d\uff90\uff9d\uff90\uff9d\u2026)\n\n\u7c21\u5358\u3067\u3059\u306d\uff01\n\n##SemiDecoder\nSemiDecoder \u306b\u95a2\u3057\u3066\u306f SemiEncode \u306e\u624b\u9806\u3092\u5168\u3066\u9006\u9806\u3067\u884c\u3048\u3070\u3067\u304d\u307e\u3059\u306d\uff01\n\n##\u5b9f\u88c5\n\u6700\u521d\u306e extension \u306f \u4e0a\u304b\u3089\u30d0\u30a4\u30ca\u30ea\u6587\u5b57\u5217\u3078\u5909\u63db, \u30d0\u30a4\u30ca\u30ea\u6587\u5b57\u5217\u304b\u3089\u5143\u306e\u6587\u5b57\u5217\u3078\u306e\u5909\u63db, \u30d0\u30a4\u30ca\u30ea\u6587\u5b57\u5217\u306e\u30d1\u30c7\u30a3\u30f3\u30b0, \u6b63\u898f\u8868\u73fe\u3067\u30de\u30c3\u30c1\u3057\u305f\u90e8\u5206\u306e\u6587\u5b57\u5217\u306e Array \u3092\u4f5c\u6210, \u6b63\u898f\u8868\u73fe\u3067\u30de\u30c3\u30c1\u3057\u305f\u6587\u5b57\u5217\u3092\u7f6e\u63db\u3059\u308b\u305f\u3081\u306e\u30e1\u30bd\u30c3\u30c9\u3092\u66f8\u3044\u3066\u307e\u3059.\n\n\u5c11\u3057\u9577\u3044\u3067\u3059\u304c, \u30e1\u30a4\u30f3\u306f\u4e00\u756a\u4e0b\u306e extension \u306e\u90e8\u5206\u3067\u3059.\n\n```swift\nimport Foundation\n\nextension String {\n    \n    var binary: String {\n        let chars = self.characters.map { String($0).unicodeScalars.first!.value }\n        return chars.map({ String($0, radix: 2).pad(24) }).joinWithSeparator(\"\")\n    }\n    \n    func bintostr() -> String {\n        let binaries = self.match(\"[01]{1,24}\")\n        var orig = \"\"\n        for b in binaries {\n            orig += String(UnicodeScalar(Int(strtoul(b, nil, 2))))\n        }\n        return orig\n    }\n    \n    func pad(toSize: Int) -> String {\n        var padded = self\n        for _ in 0..<toSize - self.characters.count {\n            padded = \"0\" + padded\n        }\n        return padded\n    }\n    \n    func match(pattern: String) -> [String] {\n        let regex = try! NSRegularExpression(pattern: pattern, options: [])\n        let range = NSMakeRange(0, self.characters.count)\n        let matches = regex.matchesInString(self, options: [], range: range)\n        \n        var matchedTokens = [String]()\n        for result in matches {\n            for r in [result] {\n                if r.range.location <= self.characters.count && r.range.length > 0 {\n                    matchedTokens.append((self as NSString).substringWithRange(r.range))\n                }\n                break\n            }\n        }\n        \n        return matchedTokens\n    }\n    \n    func replace(pattern: String, _ withString: String) -> String {\n        let regex = try! NSRegularExpression(pattern: pattern, options: [])\n        let range = NSMakeRange(0, self.characters.count)\n        return regex.stringByReplacingMatchesInString(self, options: [], range: range, withTemplate: withString)\n    }\n}\n\n// SemiEncode, SemiDecode\nextension String {\n    func SemiEncode() -> String {\n        return self.binary.replace(\"0\", \"\uff90\uff9d\").replace(\"1\", \"\uff90\uff70\uff9d\").replace(\"(\uff90\uff70\uff9d\uff90\uff9d\uff90\uff9d)\", \"$0\u2026\")\n    }\n    \n    func SemiDecode() -> String {\n        return self.replace(\"\u2026\", \"\").replace(\"\uff90\uff9d\", \"0\").replace(\"\uff90\uff70\uff9d\", \"1\").bintostr()\n    }\n}\n```\n\n\u4ed6\u306e\u30e1\u30bd\u30c3\u30c9\u304c\u9577\u3044\u9577\u3044www\n\u30d0\u30a4\u30ca\u30ea\u6587\u5b57\u5217\u306e\u6841\u6570\u3092 24 \u6841\u306b\u3057\u3066\u3044\u308b\u306e\u306f Unicode \u306e\u6570\u304c $16^6 = 2^{24}$ \u672a\u6e80\u3060\u304b\u3089\u3067\u3059\uff01\uff01\uff08\u81ea\u4fe1\u7121\u3044\uff09\n\n##\u5b9f\u884c\n\u3053\u3093\u306a\u611f\u3058\u306e\u30b3\u30fc\u30c9\u3092\u66f8\u304f\u3068\u5b9f\u884c\u3067\u304d\u308b\u306f\u305a\u2026!!\n\n```swift\nlet str = \"\u304a\u524d\u306e\u30ab\u30fc\u30c1\u30e3\u30f3\ud83c\udf63\uff68\uff68\uff68\uff68\uff68\u301cwww\"\nlet crows = str.SemiEncode() // \uff90\uff9d\uff90\uff9d\uff90\uff9d\uff90\uff9d\uff90\uff9d\uff90\uff9d\uff90\uff9d\uff90\uff9d\uff90\uff9d\uff90\uff9d\uff90\uff70\uff9d\uff90\uff70\uff9d\uff90\uff9d\uff90\uff9d\u2026\ncrows.SemiDecode() // \u304a\u524d\u306e\u30ab\u30fc\u30c1\u30e3\u30f3\ud83c\udf63\uff68\uff68\uff68\uff68\uff68\u301cwww\n```\n\n##\u304a\u307e\u3051\nPerl\u3060\u3068\u3053\u3093\u306a\u306b\u7c21\u5358\u306b\u66f8\u3051\u308b\u306e\u306b...\n\n```pl\n#!/usr/bin/env perl\nuse strict;\nuse warnings;\nuse utf8;\nuse Encode qw/encode_utf8/;\nuse v5.10;\n\nsub SemiEncode {\n\tmy $input = shift;\n\tmy $bit = unpack 'B*', $input;\n\t$bit =~ s/0/\uff90\uff9d/g;\n\t$bit =~ s/1/\uff90\uff70\uff9d/g;\n\t$bit =~ s/(\uff90\uff70\uff9d\uff90\uff9d\uff90\uff9d)/$1\u2026/g;\n\treturn $bit;\n}\n\nsub SemiDecode {\n\tmy $meen = shift;\n\t$meen =~ s/\u2026//g;\n\t$meen =~ s/\uff90\uff9d/0/g;\n\t$meen =~ s/\uff90\uff70\uff9d/1/g;\n\treturn pack 'B*', $meen;\n}\n\nmy $input = encode_utf8(\"\u304a\u524d\u306e\u30ab\u30fc\u30c1\u30e3\u30f3\ud83c\udf63\uff68\uff68\uff68\uff68\uff68\u301cwww\");\nmy $m = SemiEncode($input);\n\nsay encode_utf8($m);\nsay SemiDecode($m);\n```\n"}