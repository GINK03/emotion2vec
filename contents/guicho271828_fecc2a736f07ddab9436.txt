{"context": " More than 1 year has passed since last update.\u5b9f\u306f\u77e5\u3063\u3066\u308b\u4eba\u306f\u77e5\u3063\u3066\u3044\u308b\u307f\u305f\u3044\u3067\u3059\u306d\u3002\u81ea\u5206\u306f\u521d\u3081\u3066\u6c17\u304c\u4ed8\u304d\u307e\u3057\u305f\u3002\nI found this fact is broadly shared in Haskell community.\nthis post says \"when lazy evaluation is available, tail recursion is meaningless\". Especially in Haskell. In this post I'd like to show it in CL.\n\u4ee5\u4e0b\u306f\u3001permutation\u306e\u8a08\u7b97\u306e\u30b3\u30fc\u30c9\u3067\u3059\u3002\u672b\u5c3e\u518d\u5e30\u3002\nBelow is the tail-recursive version of code that produces a permutation of a sequence(list). The algorithm is based on Steinhaus\u2013Johnson\u2013Trotter algorithm + Even's speedup.\n(defun %permutations-of-cons (seq)\n  (match seq\n    ((list _)\n     (list seq))\n    ((list* head rest-seq)\n     (let* ((len (length seq))\n            (n (1- len))) ; n -- 2, length -- 3\n       (labels \n           ((insert (subperm pos)\n              (let (acc (%subperm subperm))\n                (dotimes (i pos)        ; i = 0\n                  (push (car %subperm) acc)\n                  (setf %subperm (cdr %subperm)))\n                (push head acc); pos = 1\n                (dotimes (i (- n pos))  ; 2 - 1 = 1\n                  (push (car %subperm) acc)\n                  (setf %subperm (cdr %subperm)))\n                (nreverse acc)))\n                                        ;\n            (forward (subperms pos acc) ; pos -- 0,1,2\n              (ematch subperms\n                ((cons subperm rest)\n                 (if (< pos n)\n                     (forward subperms (1+ pos)\n                              (cons (insert subperm pos) acc))\n                     (backward rest pos\n                               (cons (insert subperm pos) acc))))\n                (_ acc)))\n            (backward (subperms pos acc)\n              (ematch subperms\n                ((cons subperm rest)\n                 (if (< 0 pos)\n                     (backward subperms (1- pos)\n                               (cons (insert subperm pos) acc))\n                     (forward rest pos\n                              (cons (insert subperm pos) acc))))\n                (_ acc))))\n         (forward (%permutations-of-cons rest-seq) 0 nil))))))\n\nHere, in order to avoid consuming the stack frame, all labelled functions are defined in a tail-recursive manner. cons is evaluated first, then the result of either continuations, backward and forward, is returned unmodified.\nContrary, below is the same code but assuming the lazy-evaluation. This is not tail-recursive. Since the evaluations of the tails are delayed, we do not have to care about the stack exhaust. In the first call, it uses only O(1) stacks. Moreover, that stack will be released immediately -- because the function returns at the same time.\n(defun %lpermutations-of-cons (seq length)\n  (match seq\n    ((list _)\n     (llist seq))\n    ((list* head rest-seq)\n     (let* ((n (1- length))) ; n -- 2, length -- 3\n       (labels \n           ((insert (subperm pos)\n              (let (acc (%subperm subperm))\n                (dotimes (i pos)        ; i = 0\n                  (push (car %subperm) acc)\n                  (setf %subperm (cdr %subperm)))\n                (push head acc); pos = 1\n                (dotimes (i (- n pos))  ; 2 - 1 = 1\n                  (push (car %subperm) acc)\n                  (setf %subperm (cdr %subperm)))\n                (nreverse acc)))\n            (forward (subperms pos)\n              (match subperms\n                ((lcons subperm rest)\n                 (if (< pos n)\n                     (lcons (insert subperm pos) (forward subperms (1+ pos)))\n                     (lcons (insert subperm pos) (backward rest pos))))))\n            (backward (subperms pos)\n              (match subperms\n                ((lcons subperm rest)\n                 (if (< 0 pos)\n                     (lcons (insert subperm pos) (backward subperms (1- pos)))\n                     (lcons (insert subperm pos) (forward rest pos)))))))\n         (forward (%lpermutations-of-cons rest-seq (1- length)) 0))))))\n\nAlso, if I implement the lazy version in a tail-recursive manner, it diminishes the advantages of lazy evaluation. In this case, the resulting list of permutations are constructed from the tail, once at the first call, entirely. Even though each element is delayed.\n(backward subperms (1- pos)\n          (lcons (insert subperm pos) acc))\n\n\u3058\u3083\u3042\u672b\u5c3e\u518d\u5e30\u3068\u9045\u5ef6\u8a55\u4fa1\u3069\u3061\u3089\u304c\u3044\u3044\u304b\u3068\u3044\u3046\u3068\u3001\u81ea\u5206\u306e\u65b9\u91dd\u3068\u3057\u3066\u306f\n\n\u30e1\u30e2\u30ea\u304c\u7206\u767a\u3059\u308b\u3068\u304d\uff08\u5168\u90e8\u306e\u7d50\u679c\u3092\u30e1\u30e2\u30ea\u306b\u7f6e\u3044\u3066\u304a\u304f\u3053\u3068\u304c\u3067\u304d\u306a\u3044)\u3060\u3051\u306f\u9045\u5ef6\u8a55\u4fa1\n\n\u3068\u3044\u3046\u611f\u3058\u3067\u3059\u306d\u3002\n\u66f8\u304d\u6368\u3066\u5fa1\u514d!\n\u5b9f\u306f\u77e5\u3063\u3066\u308b\u4eba\u306f\u77e5\u3063\u3066\u3044\u308b\u307f\u305f\u3044\u3067\u3059\u306d\u3002\u81ea\u5206\u306f\u521d\u3081\u3066\u6c17\u304c\u4ed8\u304d\u307e\u3057\u305f\u3002\nI found this fact is broadly shared in Haskell community.\n\n[this post](http://jinvii.blogspot.jp/2012/05/notes-on-lazy-evaluation-tail-recursion.html) says \"when lazy evaluation is available, tail recursion is meaningless\". Especially in Haskell. In this post I'd like to show it in CL.\n\n\u4ee5\u4e0b\u306f\u3001permutation\u306e\u8a08\u7b97\u306e\u30b3\u30fc\u30c9\u3067\u3059\u3002\u672b\u5c3e\u518d\u5e30\u3002\nBelow is the tail-recursive version of code that produces a permutation of a sequence(list). The algorithm is based on Steinhaus\u2013Johnson\u2013Trotter algorithm + Even's speedup.\n\n```cl\n(defun %permutations-of-cons (seq)\n  (match seq\n    ((list _)\n     (list seq))\n    ((list* head rest-seq)\n     (let* ((len (length seq))\n            (n (1- len))) ; n -- 2, length -- 3\n       (labels \n           ((insert (subperm pos)\n              (let (acc (%subperm subperm))\n                (dotimes (i pos)        ; i = 0\n                  (push (car %subperm) acc)\n                  (setf %subperm (cdr %subperm)))\n                (push head acc); pos = 1\n                (dotimes (i (- n pos))  ; 2 - 1 = 1\n                  (push (car %subperm) acc)\n                  (setf %subperm (cdr %subperm)))\n                (nreverse acc)))\n                                        ;\n            (forward (subperms pos acc) ; pos -- 0,1,2\n              (ematch subperms\n                ((cons subperm rest)\n                 (if (< pos n)\n                     (forward subperms (1+ pos)\n                              (cons (insert subperm pos) acc))\n                     (backward rest pos\n                               (cons (insert subperm pos) acc))))\n                (_ acc)))\n            (backward (subperms pos acc)\n              (ematch subperms\n                ((cons subperm rest)\n                 (if (< 0 pos)\n                     (backward subperms (1- pos)\n                               (cons (insert subperm pos) acc))\n                     (forward rest pos\n                              (cons (insert subperm pos) acc))))\n                (_ acc))))\n         (forward (%permutations-of-cons rest-seq) 0 nil))))))\n```\n\nHere, in order to avoid consuming the stack frame, all `label`led functions are defined in a tail-recursive manner. `cons` is evaluated first, then the result of either continuations, `backward` and `forward`, is returned unmodified.\n\nContrary, below is the same code but assuming the lazy-evaluation. This is **not** tail-recursive. Since the evaluations of the tails are delayed, we do not have to care about the stack exhaust. In the first call, it uses only O(1) stacks. Moreover, that stack will be released immediately -- because the function returns at the same time.\n\n```cl\n(defun %lpermutations-of-cons (seq length)\n  (match seq\n    ((list _)\n     (llist seq))\n    ((list* head rest-seq)\n     (let* ((n (1- length))) ; n -- 2, length -- 3\n       (labels \n           ((insert (subperm pos)\n              (let (acc (%subperm subperm))\n                (dotimes (i pos)        ; i = 0\n                  (push (car %subperm) acc)\n                  (setf %subperm (cdr %subperm)))\n                (push head acc); pos = 1\n                (dotimes (i (- n pos))  ; 2 - 1 = 1\n                  (push (car %subperm) acc)\n                  (setf %subperm (cdr %subperm)))\n                (nreverse acc)))\n            (forward (subperms pos)\n              (match subperms\n                ((lcons subperm rest)\n                 (if (< pos n)\n                     (lcons (insert subperm pos) (forward subperms (1+ pos)))\n                     (lcons (insert subperm pos) (backward rest pos))))))\n            (backward (subperms pos)\n              (match subperms\n                ((lcons subperm rest)\n                 (if (< 0 pos)\n                     (lcons (insert subperm pos) (backward subperms (1- pos)))\n                     (lcons (insert subperm pos) (forward rest pos)))))))\n         (forward (%lpermutations-of-cons rest-seq (1- length)) 0))))))\n```\n\nAlso, if I implement the lazy version in a tail-recursive manner, it diminishes the advantages of lazy evaluation. In this case, the resulting list of permutations are constructed `from the tail`, `once at the first call`, `entirely`. Even though each element is delayed.\n\n```cl\n(backward subperms (1- pos)\n          (lcons (insert subperm pos) acc))\n```\n\n\u3058\u3083\u3042\u672b\u5c3e\u518d\u5e30\u3068\u9045\u5ef6\u8a55\u4fa1\u3069\u3061\u3089\u304c\u3044\u3044\u304b\u3068\u3044\u3046\u3068\u3001\u81ea\u5206\u306e\u65b9\u91dd\u3068\u3057\u3066\u306f\n\n+ \u30e1\u30e2\u30ea\u304c\u7206\u767a\u3059\u308b\u3068\u304d\uff08\u5168\u90e8\u306e\u7d50\u679c\u3092\u30e1\u30e2\u30ea\u306b\u7f6e\u3044\u3066\u304a\u304f\u3053\u3068\u304c\u3067\u304d\u306a\u3044)\u3060\u3051\u306f\u9045\u5ef6\u8a55\u4fa1\n\n\u3068\u3044\u3046\u611f\u3058\u3067\u3059\u306d\u3002\n\u66f8\u304d\u6368\u3066\u5fa1\u514d!", "tags": ["common-lisp", "\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0"]}