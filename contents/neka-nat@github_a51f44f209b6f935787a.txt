{"context": " More than 1 year has passed since last update.\n\n\u4e8c\u6b21\u8a08\u753b\u554f\u984c\n\u524d\u56de\u306f\u5185\u70b9\u6cd5(\u30ab\u30fc\u30de\u30fc\u30ab\u30fc\u6cd5)\u3092\u7528\u3044\u3066\u7dda\u5f62\u8a08\u753b\u554f\u984c\u3092\u89e3\u304f\u3053\u3068\u3092\u3057\u307e\u3057\u305f\u3002\u4eca\u56de\u306f\u540c\u69d8\u306b\u5185\u70b9\u6cd5\u3092\u7528\u3044\u3066\u4e8c\u6b21\u8a08\u753b\u554f\u984c\u3092\u89e3\u304f\u3053\u3068\u3092\u884c\u3063\u3066\u307f\u307e\u3059\u3002\n\u4e8c\u6b21\u8a08\u753b\u554f\u984c\u306f\u76ee\u7684\u95a2\u6570\u304c\u4e8c\u6b21\u5f62\u5f0f\u3001\u5236\u7d04\u6761\u4ef6\u304c\u7dda\u5f62\u306e\u5f62\u3067\u8868\u3055\u308c\u3066\u304a\u308a\u3001\u4ee5\u4e0b\u306e\u3088\u3046\u306a\u30d9\u30af\u30c8\u30ebxxx\u3092\u6700\u5c0f\u5316\u3059\u308b\u554f\u984c\u3068\u3057\u3066\u8868\u73fe\u3055\u308c\u307e\u3059\u3002\n\\min \\frac{1}{2} {\\bf x}^T {\\bf D} {\\bf x} + {\\bf c}^T {\\bf x}\\\\\nsubject \\ \\ \\ {\\bf A}{\\bf x} \\ge {\\bf b}\nmin12xTDx+cTxsubject\u00a0\u00a0\u00a0Ax\u2265bmin12xTDx+cTxsubject\u00a0\u00a0\u00a0Ax\u2265b{\\min \\frac{1}{2} {\\bf x}^T {\\bf D} {\\bf x} + {\\bf c}^T {\\bf x}\\\\\nsubject \\ \\ \\ {\\bf A}{\\bf x} \\ge {\\bf b}\n}\n\u3053\u3053\u3067xx{\\bf x}\u306e\u6b21\u5143\u3092nnn\u3001\u5236\u7d04\u6570\u3092mmm\u3068\u3059\u308b\u3068\u3001x,c,bx,c,b{\\bf x},{\\bf  c},{\\bf b}\u306fnnn\u6b21\u5143\u30d9\u30af\u30c8\u30eb\u3067\u3001AA{\\bf A}\u306fn\u00d7mn\u00d7mn \\times m\u306e\u884c\u5217\u3001DD{\\bf D}\u306fn\u00d7nn\u00d7nn \\times n\u306e\u6b63\u5024\u5bfe\u8c61\u884c\u5217\u3068\u306a\u308a\u307e\u3059\u3002\n\n\u4e8c\u6b21\u8a08\u753b\u554f\u984c\u306b\u304a\u3051\u308b\u5185\u70b9\u6cd5\n\u4eca\u56de\u3001\u4e8c\u6b21\u8a08\u753b\u554f\u984c\u3092\u5185\u70b9\u6cd5\u3067\u89e3\u304f\u65b9\u6cd5\u3068\u3057\u3066Numerical Optimization\u306e\u4e2d\u3067\u7d39\u4ecb\u3055\u308c\u3066\u3044\u308b\u4e88\u6e2c\u5b50\u4fee\u6b63\u5b50\u6cd5\u3068\u3044\u3046\u3082\u306e\u3092\u4eca\u56de\u5b9f\u88c5\u3057\u3066\u307f\u307e\u3057\u305f\u3002\u7dda\u5f62\u8a08\u753b\u554f\u984c\u306b\u6bd4\u3079\u308b\u3068\u8907\u96d1\u3055\u306f\u5897\u3057\u3066\u3044\u307e\u3059\u3002\n#!/usr/bin/python\n#coding:utf-8\nimport numpy as np\n\nEPS_ZERO = 1.0e-9\n\ndef select_alpha(alphas):\n    return 1.0 if alphas.size == 0 or np.min(alphas) > 1.0 else np.min(alphas)\n\ndef inv_vec(vec):\n    inv = np.matrix(zeros((vec.shape[0], 1)))\n    cond = np.where(np.abs(vec) > EPS_ZERO)\n    inv[cond] = 1.0 / vec[cond]\n    return inv\n\ndef less_zero(vec):\n    return vec <= -EPS_ZERO\n\ndef quadratic_programming(x, gmat, c, amat, b,\n                          tau=0.5, eps=1.0e-3, nloop=30):\n    \"\"\"\n    \u5185\u70b9\u6cd5(Predictor-Collector)\u306b\u3088\u308b2\u6b21\u8a08\u753b\u554f\u984c\u306e\u89e3\u6cd5\n    object  min z = 0.5 * x^T * G * x + cT * x\n    subject Ax >= b\n    \"\"\"\n    ndim  = gmat.shape[0] # \u6b21\u5143\u6570\n    ncnst = amat.shape[0] # \u5236\u7d04\u6570\n    x_idx, y_idx, l_idx = np.split(np.arange(0, ndim + 2 * ncnst),\n                                   [ndim, ndim + ncnst])\n    y_l_idx = np.r_[y_idx, l_idx]\n    zeros_d_c = np.zeros((ndim, ncnst))\n    zeros_c2 = np.zeros((ncnst, ncnst))\n    eye_c = np.identity(ncnst)\n\n    f = np.bmat([[-gmat * x - c],\n                 [zeros((ncnst, 1))],\n                 [amat * x - b]])\n    exmat = np.bmat([[gmat, zeros_d_c, -amat.T],\n                     [zeros_d_c.T, zeros_c2, eye_c],\n                     [-amat, eye_c, zeros_c2]])\n    delta_xyl0 = np.linalg.pinv(exmat) * f\n\n    abs_yl0 = np.abs(delta_xyl0[y_l_idx])\n    abs_yl0[abs_yl0 < 1.0] = 1.0\n    y, lmd = np.vsplit(abs_yl0, 2)\n    rd = gmat * x - amat.T * lmd + c\n    rp = amat * x - y - b\n\n    for n in range(nloop):\n        err = np.linalg.norm(rd)**2 + np.linalg.norm(rp)**2 + np.asscalar(y.T * lmd)\n        if err < eps:\n            break\n        # affine scaling step\n        iy = inv_vec(y)\n        f = np.bmat([[-rd],\n                     [-lmd],\n                     [rp]])\n        exmat = np.bmat([[gmat, zeros_d_c, -amat.T],\n                         [zeros_d_c.T, np.diag(np.multiply(lmd, iy).A1), eye_c],\n                         [-amat, eye_c, zeros_c2]])\n        d_xyl_aff = np.linalg.pinv(exmat) * f\n        # alpha\u306e\u8a08\u7b97\n        y_l_cnb = np.bmat([[y],\n                           [lmd]])\n        cnd = less_zero(d_xyl_aff[y_l_idx])\n        alpha_aff = select_alpha(-y_l_cnb[cnd] / d_xyl_aff[y_l_idx][cnd])\n        # \u4e2d\u5fc3\u30d1\u30e9\u30e1\u30fc\u30bf\n        mu = np.asscalar(y.T * lmd / ncnst)\n        mu_aff = np.asscalar((y + alpha_aff * d_xyl_aff[y_idx]).T * (lmd + alpha_aff * d_xyl_aff[l_idx]) / ncnst)\n        sig = (mu_aff / mu)**3\n        # corrector step\n        dl_y_aff = np.multiply(np.multiply(d_xyl_aff[y_idx],\n                                           d_xyl_aff[l_idx]),\n                               iy)\n        f = np.bmat([[-rd],\n                     [-lmd - dl_y_aff + sig * mu * iy],\n                     [rp]])\n        d_xyl = np.linalg.pinv(exmat) * f\n        # alpha_pri, alpha_dual\u306e\u8a08\u7b97\n        cnd = less_zero(d_xyl)\n        alpha_pri = select_alpha(-tau * y[cnd[y_idx]] / d_xyl[y_idx][cnd[y_idx]])\n        alpha_dual = select_alpha(-tau * lmd[cnd[l_idx]] / d_xyl[l_idx][cnd[l_idx]])\n        alpha_hat = min([alpha_pri, alpha_dual])\n        # x, y, lmd\u306e\u66f4\u65b0\n        x, y, lmd = np.vsplit(np.r_[x, y, lmd] + alpha_hat * d_xyl,\n                              [ndim, ndim + ncnst])\n        rp = (1.0 - alpha_pri) * rp\n        rd = (1.0 - alpha_dual) * rd + (alpha_pri - alpha_dual) * gmat * d_xyl[x_idx]\n    return x, y, lmd\n\nif __name__ == \"__main__\":\n    c = np.matrix([[-2.0],\n                    [-4.0]])\n    dmat = np.matrix([[2.0, 0.0],\n                      [0.0, 2.0]])\n    amat = np.matrix([[1.0, 1.0],\n                      [1.0, -1.0],\n                      [-3.0, 1.0]])\n    b = np.matrix([[-0.5],\n                   [1.0],\n                   [-3.0]])\n    # \u63cf\u753b\n    from pylab import *\n\n    ax = subplot(111, aspect='equal')\n    x = np.arange(-3.0, 3.01, 0.15)\n    y = np.arange(-3.0, 3.01, 0.15)\n    X,Y = meshgrid(x, y)\n    t = arange(-3.0, 3.01, 0.15)\n    func = lambda x, y : 0.5 * (dmat[0, 0] * x**2 + dmat[1, 1] * y**2) + c[0, 0] * x + c[1, 0] * y\n    const = [lambda x : -amat[i, 0] / amat[i, 1] * x + b[i, 0] / amat[i, 1] for i in range(amat.shape[0])]\n    Z = func(X, Y)\n    s = [const[i](t) for i in range(amat.shape[0])]\n    pcolor(X, Y, Z)\n    for i in range(amat.shape[0]):\n        ax.plot(t, s[i], 'k')\n    x, y, lmd = quadratic_programming(np.matrix([[0.0], [0.0]]),\n                                      dmat, c, amat, b,\n                                      tau=0.5, eps=1.0e-3, nloop=25)\n    print x\n    ax.plot([x[0, 0]], [x[1, 0]],'yo')\n    axis([-3, 3, -3, 3])\n    show()\n\n\u524d\u56de\u540c\u69d8\u30012\u6b21\u5143\u306e\u554f\u984c\u3067\u63cf\u753b\u3057\u3066\u307f\u307e\u3059\u30023\u672c\u306e\u7dda\u306e\u4e2d\u304c\u5236\u7d04\u3092\u6e80\u305f\u3059\u89e3\u306e\u9818\u57df\u3067\u3001\u9752\u304c\u6fc3\u304f\u306a\u308b\u65b9\u5411\u304c\u6700\u9069\u5024\u3067\u3059\u3002\n\u30b0\u30e9\u30d5\u306e\u4e2d\u3067\u9ec4\u8272\u306e\u70b9\u304c\u6700\u7d42\u7684\u306a\u6700\u9069\u89e3\u3092\u793a\u3057\u3066\u304a\u308a\u3001\u521d\u671f\u5024\u3092\u5236\u7d04\u306e\u5916\u304b\u3089\u4e0e\u3048\u3066\u3082\u9069\u5207\u306a\u89e3\u3092\u51fa\u305b\u3066\u3044\u308b\u3053\u3068\u304c\u5206\u304b\u308a\u307e\u3059\u3002\n\n\u4eca\u56de\u4f5c\u6210\u3057\u305f\u30b3\u30fc\u30c9\u306fPython\u306a\u306e\u3067\u3001\u8a08\u7b97\u901f\u5ea6\u7684\u306b\u306f\u9045\u3044\u3067\u3059\u304c\u3001\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0\u306e\u7406\u89e3\u306f\u591a\u5c11\u3057\u3084\u3059\u3044\u306e\u304b\u306a\u3068\u601d\u3044\u307e\u3057\u305f\u3002\n\u4eca\u56de\u306e\u30b3\u30fc\u30c9\u3067\u306f\u30b9\u30c6\u30c3\u30d7\u3092\u6c42\u3081\u308b\u969b\u306b\u64ec\u4f3c\u9006\u884c\u5217\u3092\u7528\u3044\u305f\u306e\u3067\u3059\u304c\u3001\u5171\u5f79\u52fe\u914d\u6cd5\u3092\u7528\u3044\u305f\u308a\u3001exmat\u306e\u758e\u6027\u3092\u5229\u7528\u3059\u308b\u3053\u3068\u3067\u9ad8\u901f\u5316\u3067\u304d\u308b\u3088\u3046\u3067\u3059\u3002\n#\u4e8c\u6b21\u8a08\u753b\u554f\u984c\n[\u524d\u56de](http://qiita.com/neka-nat@github/items/c8586f0f1ea75e785564)\u306f\u5185\u70b9\u6cd5(\u30ab\u30fc\u30de\u30fc\u30ab\u30fc\u6cd5)\u3092\u7528\u3044\u3066\u7dda\u5f62\u8a08\u753b\u554f\u984c\u3092\u89e3\u304f\u3053\u3068\u3092\u3057\u307e\u3057\u305f\u3002\u4eca\u56de\u306f\u540c\u69d8\u306b\u5185\u70b9\u6cd5\u3092\u7528\u3044\u3066\u4e8c\u6b21\u8a08\u753b\u554f\u984c\u3092\u89e3\u304f\u3053\u3068\u3092\u884c\u3063\u3066\u307f\u307e\u3059\u3002\n\u4e8c\u6b21\u8a08\u753b\u554f\u984c\u306f\u76ee\u7684\u95a2\u6570\u304c\u4e8c\u6b21\u5f62\u5f0f\u3001\u5236\u7d04\u6761\u4ef6\u304c\u7dda\u5f62\u306e\u5f62\u3067\u8868\u3055\u308c\u3066\u304a\u308a\u3001\u4ee5\u4e0b\u306e\u3088\u3046\u306a\u30d9\u30af\u30c8\u30eb$x$\u3092\u6700\u5c0f\u5316\u3059\u308b\u554f\u984c\u3068\u3057\u3066\u8868\u73fe\u3055\u308c\u307e\u3059\u3002\n\n```math\n\\min \\frac{1}{2} {\\bf x}^T {\\bf D} {\\bf x} + {\\bf c}^T {\\bf x}\\\\\nsubject \\ \\ \\ {\\bf A}{\\bf x} \\ge {\\bf b}\n```\n\n\u3053\u3053\u3067${\\bf x}$\u306e\u6b21\u5143\u3092$n$\u3001\u5236\u7d04\u6570\u3092$m$\u3068\u3059\u308b\u3068\u3001${\\bf x},{\\bf  c},{\\bf b}$\u306f$n$\u6b21\u5143\u30d9\u30af\u30c8\u30eb\u3067\u3001${\\bf A}$\u306f$n \\times m$\u306e\u884c\u5217\u3001${\\bf D}$\u306f$n \\times n$\u306e\u6b63\u5024\u5bfe\u8c61\u884c\u5217\u3068\u306a\u308a\u307e\u3059\u3002\n\n#\u4e8c\u6b21\u8a08\u753b\u554f\u984c\u306b\u304a\u3051\u308b\u5185\u70b9\u6cd5\n\u4eca\u56de\u3001\u4e8c\u6b21\u8a08\u753b\u554f\u984c\u3092\u5185\u70b9\u6cd5\u3067\u89e3\u304f\u65b9\u6cd5\u3068\u3057\u3066[Numerical Optimization](http://www.amazon.co.jp/Numerical-Optimization-Operations-Financial-Engineering/dp/0387303030)\u306e\u4e2d\u3067\u7d39\u4ecb\u3055\u308c\u3066\u3044\u308b\u4e88\u6e2c\u5b50\u4fee\u6b63\u5b50\u6cd5\u3068\u3044\u3046\u3082\u306e\u3092\u4eca\u56de\u5b9f\u88c5\u3057\u3066\u307f\u307e\u3057\u305f\u3002\u7dda\u5f62\u8a08\u753b\u554f\u984c\u306b\u6bd4\u3079\u308b\u3068\u8907\u96d1\u3055\u306f\u5897\u3057\u3066\u3044\u307e\u3059\u3002\n\n\n```py\n#!/usr/bin/python\n#coding:utf-8\nimport numpy as np\n\nEPS_ZERO = 1.0e-9\n\ndef select_alpha(alphas):\n    return 1.0 if alphas.size == 0 or np.min(alphas) > 1.0 else np.min(alphas)\n\ndef inv_vec(vec):\n    inv = np.matrix(zeros((vec.shape[0], 1)))\n    cond = np.where(np.abs(vec) > EPS_ZERO)\n    inv[cond] = 1.0 / vec[cond]\n    return inv\n\ndef less_zero(vec):\n    return vec <= -EPS_ZERO\n\ndef quadratic_programming(x, gmat, c, amat, b,\n                          tau=0.5, eps=1.0e-3, nloop=30):\n    \"\"\"\n    \u5185\u70b9\u6cd5(Predictor-Collector)\u306b\u3088\u308b2\u6b21\u8a08\u753b\u554f\u984c\u306e\u89e3\u6cd5\n    object  min z = 0.5 * x^T * G * x + cT * x\n    subject Ax >= b\n    \"\"\"\n    ndim  = gmat.shape[0] # \u6b21\u5143\u6570\n    ncnst = amat.shape[0] # \u5236\u7d04\u6570\n    x_idx, y_idx, l_idx = np.split(np.arange(0, ndim + 2 * ncnst),\n                                   [ndim, ndim + ncnst])\n    y_l_idx = np.r_[y_idx, l_idx]\n    zeros_d_c = np.zeros((ndim, ncnst))\n    zeros_c2 = np.zeros((ncnst, ncnst))\n    eye_c = np.identity(ncnst)\n\n    f = np.bmat([[-gmat * x - c],\n                 [zeros((ncnst, 1))],\n                 [amat * x - b]])\n    exmat = np.bmat([[gmat, zeros_d_c, -amat.T],\n                     [zeros_d_c.T, zeros_c2, eye_c],\n                     [-amat, eye_c, zeros_c2]])\n    delta_xyl0 = np.linalg.pinv(exmat) * f\n\n    abs_yl0 = np.abs(delta_xyl0[y_l_idx])\n    abs_yl0[abs_yl0 < 1.0] = 1.0\n    y, lmd = np.vsplit(abs_yl0, 2)\n    rd = gmat * x - amat.T * lmd + c\n    rp = amat * x - y - b\n\n    for n in range(nloop):\n        err = np.linalg.norm(rd)**2 + np.linalg.norm(rp)**2 + np.asscalar(y.T * lmd)\n        if err < eps:\n            break\n        # affine scaling step\n        iy = inv_vec(y)\n        f = np.bmat([[-rd],\n                     [-lmd],\n                     [rp]])\n        exmat = np.bmat([[gmat, zeros_d_c, -amat.T],\n                         [zeros_d_c.T, np.diag(np.multiply(lmd, iy).A1), eye_c],\n                         [-amat, eye_c, zeros_c2]])\n        d_xyl_aff = np.linalg.pinv(exmat) * f\n        # alpha\u306e\u8a08\u7b97\n        y_l_cnb = np.bmat([[y],\n                           [lmd]])\n        cnd = less_zero(d_xyl_aff[y_l_idx])\n        alpha_aff = select_alpha(-y_l_cnb[cnd] / d_xyl_aff[y_l_idx][cnd])\n        # \u4e2d\u5fc3\u30d1\u30e9\u30e1\u30fc\u30bf\n        mu = np.asscalar(y.T * lmd / ncnst)\n        mu_aff = np.asscalar((y + alpha_aff * d_xyl_aff[y_idx]).T * (lmd + alpha_aff * d_xyl_aff[l_idx]) / ncnst)\n        sig = (mu_aff / mu)**3\n        # corrector step\n        dl_y_aff = np.multiply(np.multiply(d_xyl_aff[y_idx],\n                                           d_xyl_aff[l_idx]),\n                               iy)\n        f = np.bmat([[-rd],\n                     [-lmd - dl_y_aff + sig * mu * iy],\n                     [rp]])\n        d_xyl = np.linalg.pinv(exmat) * f\n        # alpha_pri, alpha_dual\u306e\u8a08\u7b97\n        cnd = less_zero(d_xyl)\n        alpha_pri = select_alpha(-tau * y[cnd[y_idx]] / d_xyl[y_idx][cnd[y_idx]])\n        alpha_dual = select_alpha(-tau * lmd[cnd[l_idx]] / d_xyl[l_idx][cnd[l_idx]])\n        alpha_hat = min([alpha_pri, alpha_dual])\n        # x, y, lmd\u306e\u66f4\u65b0\n        x, y, lmd = np.vsplit(np.r_[x, y, lmd] + alpha_hat * d_xyl,\n                              [ndim, ndim + ncnst])\n        rp = (1.0 - alpha_pri) * rp\n        rd = (1.0 - alpha_dual) * rd + (alpha_pri - alpha_dual) * gmat * d_xyl[x_idx]\n    return x, y, lmd\n\nif __name__ == \"__main__\":\n    c = np.matrix([[-2.0],\n                    [-4.0]])\n    dmat = np.matrix([[2.0, 0.0],\n                      [0.0, 2.0]])\n    amat = np.matrix([[1.0, 1.0],\n                      [1.0, -1.0],\n                      [-3.0, 1.0]])\n    b = np.matrix([[-0.5],\n                   [1.0],\n                   [-3.0]])\n    # \u63cf\u753b\n    from pylab import *\n\n    ax = subplot(111, aspect='equal')\n    x = np.arange(-3.0, 3.01, 0.15)\n    y = np.arange(-3.0, 3.01, 0.15)\n    X,Y = meshgrid(x, y)\n    t = arange(-3.0, 3.01, 0.15)\n    func = lambda x, y : 0.5 * (dmat[0, 0] * x**2 + dmat[1, 1] * y**2) + c[0, 0] * x + c[1, 0] * y\n    const = [lambda x : -amat[i, 0] / amat[i, 1] * x + b[i, 0] / amat[i, 1] for i in range(amat.shape[0])]\n    Z = func(X, Y)\n    s = [const[i](t) for i in range(amat.shape[0])]\n    pcolor(X, Y, Z)\n    for i in range(amat.shape[0]):\n        ax.plot(t, s[i], 'k')\n    x, y, lmd = quadratic_programming(np.matrix([[0.0], [0.0]]),\n                                      dmat, c, amat, b,\n                                      tau=0.5, eps=1.0e-3, nloop=25)\n    print x\n    ax.plot([x[0, 0]], [x[1, 0]],'yo')\n    axis([-3, 3, -3, 3])\n    show()\n```\n\n\u524d\u56de\u540c\u69d8\u30012\u6b21\u5143\u306e\u554f\u984c\u3067\u63cf\u753b\u3057\u3066\u307f\u307e\u3059\u30023\u672c\u306e\u7dda\u306e\u4e2d\u304c\u5236\u7d04\u3092\u6e80\u305f\u3059\u89e3\u306e\u9818\u57df\u3067\u3001\u9752\u304c\u6fc3\u304f\u306a\u308b\u65b9\u5411\u304c\u6700\u9069\u5024\u3067\u3059\u3002\n\u30b0\u30e9\u30d5\u306e\u4e2d\u3067\u9ec4\u8272\u306e\u70b9\u304c\u6700\u7d42\u7684\u306a\u6700\u9069\u89e3\u3092\u793a\u3057\u3066\u304a\u308a\u3001\u521d\u671f\u5024\u3092\u5236\u7d04\u306e\u5916\u304b\u3089\u4e0e\u3048\u3066\u3082\u9069\u5207\u306a\u89e3\u3092\u51fa\u305b\u3066\u3044\u308b\u3053\u3068\u304c\u5206\u304b\u308a\u307e\u3059\u3002\n\n![ipqp.png](https://qiita-image-store.s3.amazonaws.com/0/14516/ac016eca-2bfc-9543-6dc1-3041f1920093.png)\n\n\u4eca\u56de\u4f5c\u6210\u3057\u305f\u30b3\u30fc\u30c9\u306fPython\u306a\u306e\u3067\u3001\u8a08\u7b97\u901f\u5ea6\u7684\u306b\u306f\u9045\u3044\u3067\u3059\u304c\u3001\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0\u306e\u7406\u89e3\u306f\u591a\u5c11\u3057\u3084\u3059\u3044\u306e\u304b\u306a\u3068\u601d\u3044\u307e\u3057\u305f\u3002\n\u4eca\u56de\u306e\u30b3\u30fc\u30c9\u3067\u306f\u30b9\u30c6\u30c3\u30d7\u3092\u6c42\u3081\u308b\u969b\u306b\u64ec\u4f3c\u9006\u884c\u5217\u3092\u7528\u3044\u305f\u306e\u3067\u3059\u304c\u3001\u5171\u5f79\u52fe\u914d\u6cd5\u3092\u7528\u3044\u305f\u308a\u3001`exmat`\u306e\u758e\u6027\u3092\u5229\u7528\u3059\u308b\u3053\u3068\u3067\u9ad8\u901f\u5316\u3067\u304d\u308b\u3088\u3046\u3067\u3059\u3002\n", "tags": ["\u6570\u5024\u8a08\u7b97", "Python"]}