{"context": " More than 1 year has passed since last update.Recently, I made a little demo that shows my housing costs on an interactive map, like this:\n\n(Yes, San Francisco is about 3-5x the price of everywhere else in the world)\nThis involves using a container node to mount D3 to using Datamaps. I then take some statistics and push it to my datamaps driver and it shows my data on the map.\n\nMaking this thing\nTo make this work, I use the standard Cycle.js DOM driver and provide my own two drivers: one for feeding in my data, and one for handling datamaps.\n\nDrivers\nDrivers are how you do side effects and load information from those back into your application. There are two steps involved: construction and usage. My table data driver is quite simple:\nexport default function makeTableDataDriver() {\n  // create my data\n  let data = [\n    ['Tokyo', 'JPN', 37.86],\n    ['Nagoya', 'JPN', 47.71],\n    ['Kyoto', 'JPN', 59.29],\n  ];\n\n  // transform it into the format I'm going to use\n  let locations = data.map((v, i) => ({\n    id: i,\n    name: v[0],\n    country: v[1],\n    price: v[2]\n  }));\n\n  // return my driver, which can be called to get the data stream.\n  // the reason for why I map my data with a function will be explained later.\n  return function tableDataDriver() {\n    return Rx.Observable.just(locations)\n      .map(locations => state => Object.assign({}, {locations}));\n  };\n}\n\nMaking the Datamap driver is more involed. First, I have three regions I want to show, so I should be able to configure my driver for a given region. Second, I need a container to render in, but I will not have this container available until my application has rendered. Third, I need data to push into my maps.\nWhile I can expose makeDataDriver : Region where type Region = String, I'm going to have to come up with a way to get my container into the input stream of this driver. Let's look at the rest of the application first.\n\nThe Application\nJust like any Cycle.js application, I initialize my drivers with whatever configuration is needed and then have a main function I have run by the frameworky bits. My main function will connect my streams and transform them as needed and provide streams for the drivers themselves to consume. Nice enough, right?\nLike I said above, I'll initialize my Datamap drivers with the region that I actually want.\nlet drivers = {\n  DOM: makeDOMDriver('#app'),\n  TableData: makeTableDataDriver(),\n  DataMapEU: makeDatamapDriver('europe'),\n  DataMapAS: makeDatamapDriver('asia'),\n  DataMapUS: makeDatamapDriver('us')\n};\n\nAnd my main function contains this near the end:\nlet containerEU$ = getDOMElement$(drivers.DOM, '.datamap-europe');\nlet containerAS$ = getDOMElement$(drivers.DOM, '.datamap-asia');\nlet containerUS$ = getDOMElement$(drivers.DOM, '.datamap-us');\n\nreturn {\n  DOM: view$,\n  DataMapEU: prepareDataMap$(containerEU$, statistics$),\n  DataMapAS: prepareDataMap$(containerAS$, statistics$),\n  DataMapUS: prepareDataMap$(containerUS$, statistics$)\n};\n\nwhere getDOMElement$ is defined\nfunction getDOMElement$(DOMDriver, selector) {\n  const DOMObservable = DOMDriver.select(selector).observable;\n  return DOMObservable.map(results => results[0]);\n}\n\nSuch that the DOMObservable will give me an array of document query matches, and the output stream will either output an element or [][0] === undefined.\nUsing this element stream, I combine this container with my statistics with a simple prepareDataMap$ function defined\nfunction prepareDataMap$(container$, statistics$) {\n  return Rx.Observable.combineLatest(\n    container$, statistics$,\n    (container, statistics) => ({\n      container, statistics\n    })\n  );\n}\n\nAnd then my view function actually renders these containers for me:\nfunction view(state) {\n  return h('div', [\n    h('div', {id: 'datamap', className: 'sections'}, [\n      h('div', {className: 'datamap-europe'}),\n      h('div', {className: 'datamap-asia'}),\n      h('div', {className: 'datamap-us'})\n    ]),\n    h('div', {style: {width: '300px', margin: 'auto'}}, [\n      locationsList(state.locations)\n    ])\n  ]);\n}\n\n\nWriting this Datamap driver\nThere's a lot of crap involved in setting up Datamaps, but I'll just paraphrase. I prepare a projection based on the region I want to look at and that is what gets used when I mount Datamaps to my container. I draw a Choropleth for country prices, and bubbles for city prices.\nHere's the gist of what I do:\nexport default function makeDatamapDriver(region) {\n  return function datamapDriver(input$) {\n    let datamap;\n\n    input$.subscribe(({container, statistics}) => {\n      if (!container) {\n        // if we have no container, then do cleanup on what we had before to prevent leakage\n        datamap = null;\n        return;\n      } else if (!datamap) {\n        // if we have a container but no datamap instance, create one\n        datamap = new Datamap({\n          element: container,\n          setProjection: getProjection(region),\n          [...]\n        });\n      }\n\n      if (!datamap) {\n        // if we don't have a datamap instance, then quit out\n        return;\n      }\n\n      // draw our choropleth\n      // draw our bubbles\n    });\n  };\n}\n\nAnd that's about it! This is how I handle mounting on to a container and updating my datamaps. It might not be super pretty, but I can reasonably do 'afterRender' and 'afterTeardown' operations this way.\nI have an alternativeView function that you can try that will even toggle the container nodes on and off, making the Datamaps driver mount new datamaps instances accordingly.\nfunction alternativeView(state) {\n  return Rx.Observable.interval(1000).map(function (time) {\n    if (time % 2 === 0) {\n      return h('div');\n    } else {\n      return h('div', [\n        h('div', {id: 'datamap', className: 'sections'}, [\n          h('div', {className: 'datamap-europe'}),\n          h('div', {className: 'datamap-asia'}),\n          h('div', {className: 'datamap-us'})\n        ]),\n        h('div', {style: {width: '300px', margin: 'auto'}}, [\n          locationsList(state.locations)\n        ])\n      ]);\n    }\n  });\n}\n\n\n\nDemo & Repo\nI have a demo up here: http://justinwoo.github.io/housing-costs-maps\nRepo is here: https://github.com/justinwoo/housing-costs-maps\n\nConclusion\nSo I hope you found this a little bit useful on how you can write drivers to have side effects in your application (even DOM side effects separate from the DOM driver).\nIf you made it this far, thanks! Let me know if you found this at all useful or have a bettter solution on Twitter: (@jusrin00).\n\nReferences\n\nCycle.js drivers: http://cycle.js.org/drivers.html\n\nDatamaps: https://github.com/markmarkoh/datamaps\n\n\n\n\n\nRecently, I made a little demo that shows my housing costs on an interactive map, like this:\n\n![Screen Shot 2015-10-26 at 7.43.35 AM.png](https://qiita-image-store.s3.amazonaws.com/0/42481/67eda788-125e-2523-a344-222978b678fc.png \"Screen Shot 2015-10-26 at 7.43.35 AM.png\")\n(Yes, San Francisco is about 3-5x the price of everywhere else in the world)\n\nThis involves using a container node to mount D3 to using Datamaps. I then take some statistics and push it to my datamaps driver and it shows my data on the map.\n\n# Making this thing\n\nTo make this work, I use the standard Cycle.js DOM driver and provide my own two drivers: one for feeding in my data, and one for handling datamaps.\n\n## Drivers\n\nDrivers are how you do side effects and load information from those back into your application. There are two steps involved: construction and usage. My table data driver is quite simple:\n\n```js\nexport default function makeTableDataDriver() {\n  // create my data\n  let data = [\n    ['Tokyo', 'JPN', 37.86],\n    ['Nagoya', 'JPN', 47.71],\n    ['Kyoto', 'JPN', 59.29],\n  ];\n\n  // transform it into the format I'm going to use\n  let locations = data.map((v, i) => ({\n    id: i,\n    name: v[0],\n    country: v[1],\n    price: v[2]\n  }));\n\n  // return my driver, which can be called to get the data stream.\n  // the reason for why I map my data with a function will be explained later.\n  return function tableDataDriver() {\n    return Rx.Observable.just(locations)\n      .map(locations => state => Object.assign({}, {locations}));\n  };\n}\n```\n\nMaking the Datamap driver is more involed. First, I have three regions I want to show, so I should be able to configure my driver for a given region. Second, I need a container to render in, but I will not have this container available until my application has rendered. Third, I need data to push into my maps.\n\nWhile I can expose `makeDataDriver : Region` where `type Region = String`, I'm going to have to come up with a way to get my container into the input stream of this driver. Let's look at the rest of the application first.\n\n## The Application\n\nJust like any Cycle.js application, I initialize my drivers with whatever configuration is needed and then have a main function I have run by the frameworky bits. My main function will connect my streams and transform them as needed and provide streams for the drivers themselves to consume. Nice enough, right?\n\nLike I said above, I'll initialize my Datamap drivers with the region that I actually want.\n\n```js\nlet drivers = {\n  DOM: makeDOMDriver('#app'),\n  TableData: makeTableDataDriver(),\n  DataMapEU: makeDatamapDriver('europe'),\n  DataMapAS: makeDatamapDriver('asia'),\n  DataMapUS: makeDatamapDriver('us')\n};\n```\n\nAnd my main function contains this near the end:\n\n```js\nlet containerEU$ = getDOMElement$(drivers.DOM, '.datamap-europe');\nlet containerAS$ = getDOMElement$(drivers.DOM, '.datamap-asia');\nlet containerUS$ = getDOMElement$(drivers.DOM, '.datamap-us');\n\nreturn {\n  DOM: view$,\n  DataMapEU: prepareDataMap$(containerEU$, statistics$),\n  DataMapAS: prepareDataMap$(containerAS$, statistics$),\n  DataMapUS: prepareDataMap$(containerUS$, statistics$)\n};\n```\n\nwhere `getDOMElement$` is defined\n\n```js\nfunction getDOMElement$(DOMDriver, selector) {\n  const DOMObservable = DOMDriver.select(selector).observable;\n  return DOMObservable.map(results => results[0]);\n}\n```\n\nSuch that the `DOMObservable` will give me an array of document query matches, and the output stream will either output an element or `[][0] === undefined`.\n\nUsing this element stream, I combine this container with my statistics with a simple `prepareDataMap$` function defined\n\n```js\nfunction prepareDataMap$(container$, statistics$) {\n  return Rx.Observable.combineLatest(\n    container$, statistics$,\n    (container, statistics) => ({\n      container, statistics\n    })\n  );\n}\n```\n\nAnd then my view function actually renders these containers for me:\n\n```js\nfunction view(state) {\n  return h('div', [\n    h('div', {id: 'datamap', className: 'sections'}, [\n      h('div', {className: 'datamap-europe'}),\n      h('div', {className: 'datamap-asia'}),\n      h('div', {className: 'datamap-us'})\n    ]),\n    h('div', {style: {width: '300px', margin: 'auto'}}, [\n      locationsList(state.locations)\n    ])\n  ]);\n}\n```\n\n## Writing this Datamap driver\n\nThere's a lot of crap involved in setting up Datamaps, but I'll just paraphrase. I prepare a projection based on the region I want to look at and that is what gets used when I mount Datamaps to my container. I draw a Choropleth for country prices, and bubbles for city prices.\n\nHere's the gist of what I do:\n\n```js\nexport default function makeDatamapDriver(region) {\n  return function datamapDriver(input$) {\n    let datamap;\n\n    input$.subscribe(({container, statistics}) => {\n      if (!container) {\n        // if we have no container, then do cleanup on what we had before to prevent leakage\n        datamap = null;\n        return;\n      } else if (!datamap) {\n        // if we have a container but no datamap instance, create one\n        datamap = new Datamap({\n          element: container,\n          setProjection: getProjection(region),\n          [...]\n        });\n      }\n\n      if (!datamap) {\n        // if we don't have a datamap instance, then quit out\n        return;\n      }\n\n      // draw our choropleth\n      // draw our bubbles\n    });\n  };\n}\n```\n\nAnd that's about it! This is how I handle mounting on to a container and updating my datamaps. It might not be super pretty, but I can reasonably do 'afterRender' and 'afterTeardown' operations this way.\n\nI have an `alternativeView` function that you can try that will even toggle the container nodes on and off, making the Datamaps driver mount new datamaps instances accordingly.\n\n```js\nfunction alternativeView(state) {\n  return Rx.Observable.interval(1000).map(function (time) {\n    if (time % 2 === 0) {\n      return h('div');\n    } else {\n      return h('div', [\n        h('div', {id: 'datamap', className: 'sections'}, [\n          h('div', {className: 'datamap-europe'}),\n          h('div', {className: 'datamap-asia'}),\n          h('div', {className: 'datamap-us'})\n        ]),\n        h('div', {style: {width: '300px', margin: 'auto'}}, [\n          locationsList(state.locations)\n        ])\n      ]);\n    }\n  });\n}\n\n```\n\n# Demo & Repo\n\nI have a demo up here: http://justinwoo.github.io/housing-costs-maps\nRepo is here: https://github.com/justinwoo/housing-costs-maps\n\n# Conclusion\n\nSo I hope you found this a little bit useful on how you can write drivers to have side effects in your application (even DOM side effects separate from the DOM driver).\n\nIf you made it this far, thanks! Let me know if you found this at all useful or have a bettter solution on Twitter: ([@jusrin00](https://twitter.com/jusrin00)).\n\n# References\n\n* Cycle.js drivers: http://cycle.js.org/drivers.html\n\t* Datamaps: https://github.com/markmarkoh/datamaps\n", "tags": ["RxJS", "cycle.js", "JavaScript", "d3", "datamaps"]}