{"tags": ["Linux", "\u4eee\u60f3\u8a18\u61b6", "kernel"], "context": " More than 1 year has passed since last update.\n\n\u3042\u3089\u307e\u3057\n\u524d\u56de\u3001cgroups\u306b\u3064\u3044\u3066\u8efd\u304f\u3067\u306f\u3042\u308b\u304c\u66f8\u3044\u3066\u307f\u307e\u3057\u305f\u3002\n\u4e0a\u8a18\u306e\u6587\u7ae0\u306e\u6700\u5f8c\u306b\u300c\u6b21\u306fcgroups\u3068\u30e1\u30e2\u30ea\u7ba1\u7406\u3068\u3044\u3046\u30cd\u30bf\u3067\u884c\u3063\u3066\u307f\u305f\u3044\u300d\u3068\u66f8\u304d\u307e\u3057\u305f\u3002\n\u3082\u3061\u308d\u3093\u3059\u3050\u306bcgroups\u3068\u4eee\u60f3\u8a18\u61b6\u306e\u95a2\u4fc2\u304c\u308f\u304b\u308c\u3070\u3088\u3044\u306e\u3067\u3042\u308b\u304c\u3001\u4f55\u3076\u3093Linux\u306e\u4eee\u60f3\u8a18\u61b6\u306f\u8aad\u3080\u306e\u3082\u521d\u3081\u3066\u3067\u3059\u3002\u3088\u3063\u3066\u3001Linux\u306e\u4eee\u60f3\u8a18\u61b6\u306e\u6982\u8981\u3092\u3064\u304b\u3080\u305f\u3081\u306b\u307e\u305a\u306f\u30bd\u30fc\u30b9\u3092\u8aad\u3093\u3067\u307f\u307e\u3059\u3002\n\u6d41\u308c\u304c\u308f\u304b\u308a\u306b\u304f\u3044\u7b87\u6240\u3082\u3042\u308a\u307e\u3059\u3002\u304c\u3001\u30bd\u30fc\u30b9\u3092\u8aad\u3093\u3067\u8ff7\u3063\u305f\u904e\u7a0b\u3092\u3042\u3048\u3066\u8a18\u9332\u306b\u6b8b\u3057\u305f\u3044\u3068\u8003\u3048\u305f\u304b\u3089\u3067\u3059\u3002\u3054\u4e86\u89e3\u304f\u3060\u3055\u3044\u3002\n\n\u3068\u3044\u3046\u3053\u3068\u3067fork()\n\u4eee\u60f3\u8a18\u61b6\u306e\u6a5f\u80fd\u3092\u7406\u89e3\u3059\u308b\u306b\u306f\u3001\u7d4c\u9a13\u5247\u4e0a\u3001\u3068\u3063\u304b\u304b\u308a\u304c\u5fc5\u8981\u3067\u3059\u3002\n\u305d\u306e\u3068\u3063\u304b\u304b\u308a\u306e\u4e00\u3064\u304cfork()\u3060\u3068\u601d\u3063\u3066\u3044\u307e\u3059\u3002\n\u4eba\u306b\u3088\u3063\u3066\u306f\u3001page fault(\u4f8b\u5916\u30cf\u30f3\u30c9\u30e9)\u304b\u3089\u5165\u3063\u305f\u308a\u3001mmap()\u304b\u3089\u5165\u3063\u305f\u308a\u3059\u308b\u3053\u3068\u3082\u3042\u308d\u3046\u304c\u3001\u524d\u56defork()\u304c\u3089\u307f\u306e\u3068\u3053\u308d\u3092\u8aad\u3093\u3060\u306e\u3067\u3001\u4eca\u56de\u3082\u3053\u3053\u304b\u3089\u884c\u304d\u307e\u3059\u3002\n\nkernel/fork.c\n#ifdef __ARCH_WANT_SYS_FORK\nSYSCALL_DEFINE0(fork)\n{\n#ifdef CONFIG_MMU\n    return do_fork(SIGCHLD, 0, 0, NULL, NULL);\n#else\n    /* can not support in nommu mode */\n    return -EINVAL;\n#endif\n}\n#endif\n\n\n\u8003\u3048\u3066\u307f\u308c\u3070\u3001\u3053\u306eifdef\u306f\u5f53\u305f\u308a\u524d\u306a\u306e\u3060\u304c\u3001\u3059\u3054\u3044\u3082\u306e\u304c\u3042\u308a\u307e\u3059\u3002\n\u78ba\u304b\u306bMMU\u306a\u3057\u306eCPU\u3067\u306f\u3001fork()\u306f\u6210\u308a\u7acb\u305f\u306a\u3044\u3088\u3046\u306b\u601d\u3048\u308b\u306e\u3060\u304c\u3001MMU\u306a\u3057\u306eCPU\u3067\u306f\u30d7\u30ed\u30bb\u30b9\u3092\u3069\u3046\u3084\u3063\u3066\u751f\u6210\u3057\u3066\u3044\u308b\u306e\u3067\u3057\u3087\u3046\u304b\uff1f\n\u305d\u3093\u306a\u7591\u554f\u3092\u3072\u3068\u307e\u305a\u8107\u306b\u3088\u3051\u3066\u5148\u306b\u9032\u307f\u307e\u3059\u3002\n\nkernel/fork.c\nlong do_fork(unsigned long clone_flags,\n        unsigned long stack_start,\n         unsigned long stack_size,\n         int __user *parent_tidptr,\n         int __user *child_tidptr)\n{\n  /* \u7565 */\n  p = copy_process(clone_flags, stack_start, stack_size,child_tidptr, NULL, trace);\n\n\n\u304a\u305d\u3089\u304f\u306fcopy_process()\u3067\u3001\u89aa\u306e\u30d7\u30ed\u30bb\u30b9\u69cb\u9020\u4f53\u3092\u5143\u624b\u306b\u5b50\u306e\u30d7\u30ed\u30bb\u30b9\u69cb\u9020\u4f53\u3092\u4f5c\u308b\u306e\u3060\u308d\u3046\u3002\n\u5f53\u7136\u3001\u305d\u306e\u4e2d\u306b\u306f\u4eee\u60f3\u30a2\u30c9\u30ec\u30b9\u7a7a\u9593\u306b\u95a2\u3059\u308b\u3053\u3068\u3082\u542b\u307e\u308c\u308b\u306e\u3067\u3042\u308d\u3046\u3068\u60f3\u5b9a\u3057\u3066\u3001\u5148\u306b\u9032\u307f\u307e\u3059\u3002\n\nkernel/fork.c\nstatic struct task_struct *copy_process(unsigned long clone_flags,\n          unsigned long stack_start,\n          unsigned long stack_size,\n          int __user *child_tidptr,\n          struct pid *pid,\n          int trace)\n{\n/* \u3068\u3066\u3082\u9577\u3044\u3002\u7565\u3002\u5f15\u6570\u30c1\u30a7\u30c3\u30af\u306e\u3042\u3068\u3001\u3044\u308d\u3044\u308d\u306a\u3082\u306e\u3092\u30b3\u30d4\u30fc\u3057\u3066\u3044\u308b */\n  retval = copy_mm(clone_flags, p);\n  if (retval)\n    goto bad_fork_cleanup_signal;\n\n\n\u76ee\u5f53\u3066\u306e\u4eee\u60f3\u8a18\u61b6\u306b\u95a2\u9023\u3057\u305d\u3046\u306a\u3068\u3053\u308d\u304c\u3042\u308a\u307e\u3057\u305f\u3002\n\nkernel/fork.c\nstatic int copy_mm(unsigned long clone_flags, struct task_struct *tsk)\n{\n  /* \u7565 */\n  /*\n   * Are we cloning a kernel thread?\n   *\n   * We need to steal a active VM for that..\n   */\n  oldmm = current->mm;\n  if (!oldmm)\n    return 0;\n\n  /* \u7565 */ \n  retval = -ENOMEM;\n  mm = dup_mm(tsk);\n  if (!mm)\n    goto fail_nomem;\n\n\n\u3044\u304b\u306b\u3082\u4eee\u60f3\u30a2\u30c9\u30ec\u30b9\u7a7a\u9593\u306e\u8907\u88fd\u3092\u3057\u305d\u3046\u306a\u540d\u524d\u306edup_mm()\u3002\u898b\u3066\u307f\u307e\u3057\u3087\u3046\u3002\n\nkernel/fork.c\n/*\n * Allocate a new mm structure and copy contents from the\n * mm structure of the passed in task structure.\n */\n static struct mm_struct *dup_mm(struct task_struct *tsk)\n{\n  struct mm_struct *mm, *oldmm = current->mm;\n  int err;\n\n  mm = allocate_mm();\n  if (!mm)\n    goto fail_nomem;\n\n  memcpy(mm, oldmm, sizeof(*mm));\n  mm_init_cpumask(mm);\n  dup_mm_exe_file(oldmm, mm);\n\n  err = dup_mmap(mm, oldmm);\n  if (err)\n    goto free_pt;\n\n\n\u307e\u305a\u3001oldmm\u3092\u53d6\u5f97\u3057\u307e\u3059\u3002current\u306f\u304a\u305d\u3089\u304f\u73fe\u5728\u5b9f\u884c\u4e2d\u306e\u30d7\u30ed\u30bb\u30b9(\u3064\u307e\u308a\u3001fork()\u3092\u5b9f\u884c\u3057\u3066\u3044\u308b\u89aa\u30d7\u30ed\u30bb\u30b9)\u3060\u3068\u601d\u308f\u308c\u307e\u3059\u3002\n\u65b0\u305f\u306bmm_struct\u69cb\u9020\u4f53\u3092\u5272\u308a\u5f53\u3066\u3066\u3001\u89aa\u306emm_struct\u3092\u30b3\u30d4\u30fc\u3057\u3066\u3044\u307e\u3059\u3002\n\u305d\u3057\u3066\u3001\u30a2\u30c9\u30ec\u30b9\u7a7a\u9593\u306b\u95a2\u3057\u3066\u3044\u3048\u3070\u3001dup_mmap()\u304c\u3082\u3046\u5c11\u3057\u8907\u96d1\u306a\u3053\u3068\u3092\u3059\u308b\u8907\u5199\u51e6\u7406\u3060\u3068\u63a8\u5b9a\u3067\u304d\u307e\u3059\u3002(\u4f3c\u305f\u3088\u3046\u306a\u540d\u524d\u306e\u95a2\u6570\u304c\u7d9a\u304d\u307e\u3059\u304c\u30fb\u30fb\u30fb)\n\n\u3068\u3053\u308d\u3067\u3001mm_struct\u3068\u306f\uff1f\n\ninclude/linux/mm_types.h\n345 struct mm_struct {\n346   struct vm_area_struct *mmap;    /* list of VMAs */\n/* \u4ee5\u4e0b\u305f\u304f\u3055\u3093\u306e\u30e1\u30f3\u30d0\u304c\u3042\u308b\u304c\u3001\u7565 */\n\n\n\u8981\u306f\u3001\u30d7\u30ed\u30bb\u30b9\u306e\u30a2\u30c9\u30ec\u30b9\u7a7a\u9593\u3092\u8868\u73fe\u3059\u308b\u305f\u3081\u306e\u69cb\u9020\u4f53\u3067\u3059\u3002\n\u305d\u3057\u3066\u3001\u30a2\u30c9\u30ec\u30b9\u7a7a\u9593\u3068\u4e00\u53e3\u306b\u8a00\u3063\u3066\u3082\u3001\u305d\u306e\u4e2d\u306b\u306f\u5c5e\u6027\u306e\u9055\u3046\u9818\u57df\u304c\u3044\u304f\u3064\u304b\u3042\u308b\u306e\u306f\u30a4\u30e1\u30fc\u30b8\u304c\u3064\u304f\u304b\u3068\u601d\u3044\u307e\u3059\u3002\n\u4f8b\u3048\u3070\u3001\u547d\u4ee4(.text)\u304c\u30ed\u30fc\u30c9\u3055\u308c\u308b\u30e1\u30e2\u30ea\u9818\u57df\u3067\u3042\u308c\u3070\u8aad\u307f+\u5b9f\u884c\u5c5e\u6027\u3068\u306a\u308b\u3067\u3057\u3087\u3046\u3057\u3001\u30c7\u30fc\u30bf(.data)\u3067\u3042\u308c\u3070\u8aad\u307f+\u66f8\u304d\u5c5e\u6027\u3068\u306a\u308b\u3067\u3057\u3087\u3046\u3002\n\u305d\u306e\u4ed6\u306b\u3082\u69d8\u3005\u306a\u5c5e\u6027\u304c\u3042\u308a\u307e\u3059\u3002\n\u305d\u3093\u306a\u300c\u30d7\u30ed\u30bb\u30b9\u30a2\u30c9\u30ec\u30b9\u7a7a\u9593\u5185\u306e\u69d8\u3005\u306a\u9818\u57df\u300d\u3092\u8868\u73fe\u3057\u305f\u3082\u306e\u304cvm_area_struct\u69cb\u9020\u4f53\u306b\u306a\u308b\u3068\u601d\u308f\u308c\u307e\u3059\u3002\n\ninclude/linux/mm_types.h\n*\n* This struct defines a memory VMM memory area. There is one of these\n* per VM-area/task.  A VM area is any part of the process virtual memory\n* space that has a special rule for the page-fault handlers (ie a shared\n* library, the executable area etc).\n*/\nstruct vm_area_struct {\n /* The first cache line has the info for VMA tree walking. */\n\n unsigned long vm_start;   /* Our start address within vm_mm. */\n unsigned long vm_end;   /* The first byte after our end address\n\n /* linked list of VM areas per task, sorted by address */\n struct vm_area_struct *vm_next, *vm_prev;\n/* \u7565 */\n pgprot_t vm_page_prot;    /* Access permissions of this VMA. */\n unsigned long vm_flags;   /* Flags, see mm.h. */\n\n  /*\n   * For areas with an address space and backing store,\n   * linkage into the address_space->i_mmap interval tree, or\n   * linkage of vma in the address_space->i_mmap_nonlinear list.\n   */\n  union {\n    struct { \n      struct rb_node rb;\n      unsigned long rb_subtree_last;\n    } linear;\n    struct list_head nonlinear;\n  } shared;\n\n  /*\n   * A file's MAP_PRIVATE vma can be in both i_mmap tree and anon_vma\n   * list, after a COW of one of the file pages.  A MAP_SHARED vma\n   * can only be in the i_mmap tree.  An anonymous MAP_PRIVATE, stack\n   * or brk vma (with NULL file) can only be in an anon_vma list.\n   */\n  struct list_head anon_vma_chain; /* Serialized by mmap_sem &\n            * page_table_lock */\n  struct anon_vma *anon_vma;  /* Serialized by page_table_lock */\n\n  /* Function pointers to deal with this struct. */\n  const struct vm_operations_struct *vm_ops;\n\n  /* Information about our backing store: */\n  unsigned long vm_pgoff;   /* Offset (within vm_file) in PAGE_SIZE\n             units, *not* PAGE_CACHE_SIZE */\n  struct file * vm_file;    /* File we map to (can be NULL). */\n  void * vm_private_data;   /* was vm_pte (shared mem) */\n/* \u7565 */\n\n\n\u305d\u306e\u307e\u307edup_mmap()\u3092\u8aad\u3093\u3067\u307f\u308b\u3053\u3068\u306b\u3057\u307e\u3057\u3087\u3046\u3002\n\nkern/fork.c\n#ifdef CONFIG_MMU\nstatic int dup_mmap(struct mm_struct *mm, struct mm_struct *oldmm)\n{\n/* \u7565 */\n   prev = NULL;\n/* \u89aa\u306e\u30a2\u30c9\u30ec\u30b9\u7a7a\u9593\u306e\u9818\u57df\u3092\u4e00\u3064\u305a\u3064\u51e6\u7406\u3057\u3066\u3044\u304f */\n   for (mpnt = oldmm->mmap; mpnt; mpnt = mpnt->vm_next) {\n     struct file *file;\n/* \u7565 */\n/* \n * \u307e\u305a\u306f\u9818\u57df\u304cannonymous memory\u3068\u3057\u3066\u51e6\u7406\u3002\n * \u5b9f\u306f\u5bfe\u8c61\u3068\u306a\u308b\u9818\u57df\u304cannonymous memory\u3067\u306a\u3044\u5834\u5408\u3001\u53730\u3092\u8fd4\u3059\u306e\u3067\u554f\u984c\u306a\u3044\n */\n     if (anon_vma_fork(tmp, mpnt))\n       goto fail_nomem_anon_vma_fork;\n\n/* \n * \u4ee5\u4e0b\u3001\u30d0\u30c3\u30ad\u30f3\u30b0\u30b9\u30c8\u30a2\u306e\u6709\u7121\u306b\u3088\u3063\u3066\u51e6\u7406\u304c\u5206\u304b\u308c\u3066\u3044\u308b\u304c\u3001\u4eca\u56de\u306f\u7565\n */\n\n\n\u3055\u3066\u3001\u3053\u3053\u3067anon\u3068\u3044\u3046\u540d\u79f0\u306e\u95a2\u6570\u304c\u51fa\u3066\u304d\u307e\u3057\u305f\u3002\n\u3053\u308c\u306f\u305d\u306e\u540d\u524d\u304b\u3089Annonymous Memory\u3092\u6271\u3063\u3066\u3044\u308b\u306e\u3060\u308d\u3046\u3068\u601d\u3044\u307e\u3059\u3002\n\u6a2a\u9053\u306b\u9038\u308c\u3066(\u6df1\u307f\u306b\u306f\u307e\u3063\u3066)Annonymous Memory\u306e\u5b9f\u73fe\u65b9\u6cd5\u3092\u898b\u3066\u307f\u305f\u304f\u306a\u3063\u305f\u306e\u3067\u3001\u7d9a\u3051\u3066\u8aad\u307f\u307e\u3059\u3002\n\nAnnonymous Memory(\u533f\u540d\u30e1\u30e2\u30ea)\u3068\u306f\n\u8981\u3059\u308b\u306b\u300c\u30d0\u30c3\u30ad\u30f3\u30b0\u30b9\u30c8\u30a2(\u5143\u30cd\u30bf\u3068\u306a\u308b\u30d5\u30a1\u30a4\u30eb)\u306e\u306a\u3044\u30c7\u30fc\u30bf\u3092\u683c\u7d0d\u3059\u308b\u305f\u3081\u306e\u30e1\u30e2\u30ea\u9818\u57df\u300d\u3067\u3059\u3002\n\u4f8b\u3048\u3070\u3001.text\u306e\u4e2d\u8eab\u3084SHARED\u3067regular file\u3092map\u3057\u305fmmap\u9818\u57df\u306a\u3069\u306f\u30d0\u30c3\u30ad\u30f3\u30b0\u30b9\u30c8\u30a2\u304c\u3042\u308b\u30e1\u30e2\u30ea\u9818\u57df\u3067\u3059\u3002\n\u30e1\u30e2\u30ea\u4e0d\u8db3\u306e\u3068\u304d\u3092\u8003\u3048\u3066\u307f\u307e\u3057\u3087\u3046\u3002\u4f8b\u3048\u3070\u3001.text\u306a\u3089\u6368\u3066\u305f\u3068\u3057\u3066\u3082\u307e\u305f\u5b9f\u884c\u5f62\u5f0f\u30d5\u30a1\u30a4\u30eb\u304b\u3089\u8aad\u3081\u3070\u5185\u5bb9\u3092\u518d\u751f\u3067\u304d\u308b\u3057\u3001mmap\u9818\u57df\u3067\u3042\u308c\u3070\u4e00\u65e6\u30d5\u30a1\u30a4\u30eb\u306b\u66f8\u304d\u8fbc\u3093\u3067\u540c\u671f\u3092\u3068\u3063\u3066\u3057\u307e\u3048\u3070\u5185\u5bb9\u3092\u518d\u751f\u3067\u304d\u307e\u3059\u3002\n\u3053\u3046\u3057\u305f\u9818\u57df\u306f\u300c\u30d0\u30c3\u30ad\u30f3\u30b0\u30b9\u30c8\u30a2\u304c\u3042\u308b\u300d\u30e1\u30e2\u30ea\u9818\u57df\u306b\u306a\u308a\u307e\u3059\u3002\n\u3057\u304b\u3057\u3001.data\u3084\u30b9\u30bf\u30c3\u30af\u9818\u57df\u306fAnnonymous Memory\u3068\u8a00\u3048\u307e\u3059\u3002\n\u3053\u308c\u307e\u305f\u30e1\u30e2\u30ea\u4e0d\u8db3\u306e\u3068\u304d\u3092\u8003\u3048\u308c\u3070\u3088\u3044\u306e\u3067\u3059\u304c\u3001.data\u306f\u4e00\u5ea6RAM\u4e0a\u306e\u5024\u304c\u5909\u308f\u308b\u3068\u5b9f\u884c\u30d5\u30a1\u30a4\u30eb\u5185\u306e\u5185\u5bb9\u3068\u4e00\u81f4\u3057\u306a\u304f\u306a\u308a\u307e\u3059\u3002\n\u3060\u304b\u3089\u3068\u3044\u3063\u3066\u3001\u30e1\u30e2\u30ea\u4e0d\u8db3\u6642\u306b\u300c\u5b9f\u884c\u5f62\u5f0f\u30d5\u30a1\u30a4\u30eb\u306b\u66f8\u304d\u3060\u305b\u3070\u300d\u5b9f\u884c\u5f62\u5f0f\u30d5\u30a1\u30a4\u30eb\u306e\u521d\u671f\u5024\u304c\u5909\u308f\u308a\u3001\u30d5\u30a1\u30a4\u30eb\u304c\u58ca\u308c\u3066\u3057\u307e\u3044\u307e\u3059\u3002\n\u30b9\u30bf\u30c3\u30af\u306b\u81f3\u3063\u3066\u306f\u3001\u5b9f\u884c\u5f62\u5f0f\u30d5\u30a1\u30a4\u30eb\u306e\u3069\u3053\u306b\u3082\u300c\u5143\u30cd\u30bf\u300d\u306f\u3042\u308a\u307e\u305b\u3093\u3002\n\u3088\u3063\u3066\u3001\u30e1\u30e2\u30ea\u4e0d\u8db3\u6642\u306b\u306f\u3053\u308c\u3089\u306e\u30e1\u30e2\u30ea\u9818\u57df\u306fswap\u3055\u305b\u306a\u3044\u3068\u30c0\u30e1\u3067\u3059\u3002\n\u30e1\u30e2\u30ea\u9818\u57df\u306b\u306f\u3053\u3046\u3044\u3046\u89b3\u70b9\u306e\u898b\u65b9\u3082\u3042\u308b\u3068\u3044\u3046\u3053\u3068\u3092\u982d\u306e\u7247\u9685\u306b\u65bc\u3044\u3066\u3082\u3089\u3048\u308c\u3070\u826f\u3044\u3068\u601d\u3044\u307e\u3059\u3002\n\n\u4eee\u60f3\u8a18\u61b6\u306b\u30ba\u30d6\u30ba\u30d6\u3068....\nanon_vma_fork()\u306fkernel/\u306e\u4e0b\u3067\u306a\u304f\u3001mm/\u306e\u4e0b\u306e\u30bd\u30fc\u30b9\u306b\u3042\u308a\u307e\u3059\u3002\n\u3044\u3088\u3044\u3088\u4eee\u60f3\u8a18\u61b6\u306e\u30b3\u30fc\u30c9\u306b\u3069\u3063\u3077\u308a\u3068\u6d78\u304b\u308b\u3053\u3068\u306b\u306a\u308a\u307e\u3059\u3002\n\nmm/rmap.c\nint anon_vma_fork(struct vm_area_struct *vma, struct vm_area_struct *pvma)\n{\n  struct anon_vma_chain *avc;\n  struct anon_vma *anon_vma;\n/* \u7565 */\n  /*\n   * First, attach the new VMA to the parent VMA's anon_vmas,\n   * so rmap can find non-COWed pages in child processes.\n   */\n  if (anon_vma_clone(vma, pvma))\n    return -ENOMEM;\n  /* Then add our own anon_vma. */\n  anon_vma = anon_vma_alloc();\n  if (!anon_vma)\n    goto out_error;\n  avc = anon_vma_chain_alloc(GFP_KERNEL);\n  if (!avc)\n    goto out_error_free_anon_vma;\n\n\n\u307e\u305f\u307e\u305fclone\u7cfb\u3002\u8907\u88fd\u306e\u5c64\u3092\u4e0b\u3078\u4e0b\u3078\u3068\u6f5c\u3063\u3066\u3044\u304d\u307e\u3059\u3002\n\nmm/rmap.c\n/*\n * Attach the anon_vmas from src to dst.\n * Returns 0 on success, -ENOMEM on failure.\n */\nint anon_vma_clone(struct vm_area_struct *dst, struct vm_area_struct *src)\n{\n  struct anon_vma_chain *avc, *pavc;\n  struct anon_vma *root = NULL;\n/* anon_vma_chain\u306eanon_vma_chain\u3092\u5148\u982d\u3068\u3059\u308bsame_vma\u30ea\u30b9\u30c8\u3092\u9006\u306b\u305f\u3069\u308b */\n  list_for_each_entry_reverse(pavc, &src->anon_vma_chain, same_vma) {\n    struct anon_vma *anon_vma;\n\n    avc = anon_vma_chain_alloc(GFP_NOWAIT | __GFP_NOWARN);\n    if (unlikely(!avc)) {\n      unlock_anon_vma_root(root);\n      root = NULL;\n      avc = anon_vma_chain_alloc(GFP_KERNEL);\n      if (!avc)\n        goto enomem_failure;\n    }\n    anon_vma = pavc->anon_vma;\n    root = lock_anon_vma_root(root, anon_vma);\n    anon_vma_chain_link(dst, avc, anon_vma);\n\n\nanon_vma\u3068\u304banon_vma_chain\u3068\u304b\u65b0\u3057\u3044\u69cb\u9020\u4f53\u304c\u51fa\u3066\u304d\u307e\u3057\u305f\u3002\n\u305d\u308c\u3089\u306f\u4ee5\u4e0b\u306e\u30d8\u30c3\u30c0\u306b\u3042\u308a\u307e\u3059\u3002\n\ninclude/linux/rmap.h\n/*\n * The anon_vma heads a list of private \"related\" vmas, to scan if\n * an anonymous page pointing to this anon_vma needs to be unmapped:\n  * the vmas on the list will be related by forking, or by splitting.\n *\n * Since vmas come and go as they are split and merged (particularly\n * in mprotect), the mapping field of an anonymous page cannot point\n * directly to a vma: instead it points to an anon_vma, on whose list\n * the related vmas can be easily linked or unlinked.\n *\n * After unlinking the last vma on the list, we must garbage collect\n * the anon_vma object itself: we're guaranteed no page can be\n * pointing to this anon_vma once its vma list is empty.\n */\nstruct anon_vma {\n  struct anon_vma *root;    /* Root of this anon_vma tree */\n  struct rw_semaphore rwsem;  /* W: modification, R: walking the list */\n  /*\n   * The refcount is taken on an anon_vma when there is no\n   * guarantee that the vma of page tables will exist for\n   * the duration of the operation. A caller that takes\n   * the reference is responsible for clearing up the\n   * anon_vma if they are the last user on release\n   */\n  atomic_t refcount;\n\n  /*\n   * NOTE: the LSB of the rb_root.rb_node is set by\n   * mm_take_all_locks() _after_ taking the above lock. So the\n   * rb_root must only be read/written after taking the above lock\n   * to be sure to see a valid next pointer. The LSB bit itself\n   * is serialized by a system wide lock only visible to\n   * mm_take_all_locks() (mm_all_locks_mutex).\n   */\n  struct rb_root rb_root; /* Interval tree of private \"related\" vmas */\n};\n\n/*\n * The copy-on-write semantics of fork mean that an anon_vma\n * can become associated with multiple processes. Furthermore,\n * each child process will have its own anon_vma, where new\n * pages for that process are instantiated.\n *\n * This structure allows us to find the anon_vmas associated\n * with a VMA, or the VMAs associated with an anon_vma.\n * The \"same_vma\" list contains the anon_vma_chains linking\n * all the anon_vmas associated with this VMA.\n * The \"rb\" field indexes on an interval tree the anon_vma_chains\n * which link all the VMAs associated with this anon_vma.\n */\nstruct anon_vma_chain {\n  struct vm_area_struct *vma;\n  struct anon_vma *anon_vma;\n  struct list_head same_vma;   /* locked by mmap_sem & page_table_lock */\n  struct rb_node rb;      /* locked by anon_vma->rwsem */\n  unsigned long rb_subtree_last;\n#ifdef CONFIG_DEBUG_VM_RB\n  unsigned long cached_vma_start, cached_vma_last;\n#endif\n};\n\n\n\u6b21\u306b\u3001\u5148\u306b\u9032\u307f\u3001anon_vma_chain_link()\u306e\u4e2d\u3092\u898b\u307e\u3059\u3002\n\nmm/rmap.c\nstatic void anon_vma_chain_link(struct vm_area_struct *vma,\n        struct anon_vma_chain *avc,\n        struct anon_vma *anon_vma)\n{\n  avc->vma = vma; \n  avc->anon_vma = anon_vma;\n/* anon_vma_chain(head)\u306e\u6b21\u306bsame_vma\u3092\u3064\u306a\u3050 */\n  list_add(&avc->same_vma, &vma->anon_vma_chain);\n   anon_vma_interval_tree_insert(avc, &anon_vma->rb_root);\n}\n\n\n\u3053\u3053\u307e\u3067\u8aad\u3080\u3068\u3001anon_vma_chain\u306f\u4ee5\u4e0b\u306e\u69cb\u9020\u306b\u306a\u3063\u3066\u3044\u308b\u3088\u3046\u306b\u8aad\u3081\u307e\u3059\u3002\nvma->anon_vma_chain -- <same_vma> -- <same_vma>\n                         [avc]         [avc]\n                        * vma\u306f\u5b50\u30d7\u30ed\u30bb\u30b9\u306evma\n                        * anon_vma\u306f\u89aa\u30d7\u30ed\u30bb\u30b9(fork\u6642\u70b9)\u3068\u5171\u7528\n\nanon_vma\u306erb_root\u306bavc\u3092\u3064\u306a\u3044\u3067\u304a\u304d\u307e\u3059\u3002\n\u3053\u308c\u306b\u3088\u3063\u3066\u3001anon_vma\u304b\u3089\u306f\u305d\u308c\u304c\u5c5e\u3059\u308bvma(vm_area_struct)\u3092\u5f15\u304f\u3053\u3068\u304c\u3067\u304d\u308b\u3057\u3001vma\u5074\u304b\u3089\u306fanon_vma\u3092\u305f\u3069\u308b\u3053\u3068\u304c\u3067\u304d\u308b\u3088\u3046\u306b\u306a\u308b\u306f\u305a\u3067\u3059\u3002\nanon_vma_clone()\u304c\u7d42\u308f\u308b\u3068\u3001anon_vma\u8996\u70b9\u3067\u306f\u3001\u89aa\u3068\u5b50\u306evma\u306f\u4ee5\u4e0b\u306e\u69cb\u9020\u3068\u306a\u308b\u306f\u305a\u3067\u3059\u3002\u3053\u308c\u3067\u3001\u89aa\u3068\u5b50\u304c\u3068\u308a\u3042\u3048\u305a\u540c\u3058\u30e1\u30e2\u30ea\u306e\u5185\u5bb9\u304c\u898b\u3048\u308b(=\u8907\u5199\u3055\u308c\u305f\u304b\u306e\u3088\u3046\u306b)\u3088\u3046\u306b\u306a\u308a\u307e\u3059\u3002\n(Parents)vma->anon_vma_chain -- <same_vma> -- <same_vma>\n                                 [avc]         [avc]\n                               vma |         vma |\n                                   |             |\n                                   |             |\n                                anon_vma      anon_vma\n                                   |             |\n                                   |             |\n                               vma |         vma |\n                                 [avc]         [avc]\n(Child   )vma->anon_vma_chain -- <same_vma> -- <same_vma>\n\n\u3061\u306a\u307f\u306b\u3053\u3053\u306b\u306f\u8f09\u305b\u307e\u305b\u3093\u304c\u3001list_add\u3082\u30ea\u30b9\u30c8\u30d8\u30c3\u30c9\u3082\u500b\u3005\u306e\u8981\u7d20\u3082\u540c\u3058list_head\u69cb\u9020\u4f53\u3067\u634c\u3044\u305f\u308a\u3057\u3066\u3044\u307e\u3059\u3002\u5c0f\u30cd\u30bf\u7684\u306b\u306f\u300c\u306a\u308b\u307b\u3069\u300d\u3068\u601d\u308f\u305b\u308b\u3082\u306e\u304c\u3042\u308a\u307e\u3059\u3002\n\nmm/rmap.c\n/* page\u3092struct vm_area_struct\u304c\u6307\u3059anon_map\u304c\u6307\u3059\u9818\u57df\u306b\u79fb\u52d5\u3059\u308b */\nvoid page_move_anon_rmap(struct page *page,\n    struct vm_area_struct *vma, unsigned long address)\n{\n    struct anon_vma *anon_vma = vma->anon_vma;\n/* \u7565 */\n    /* bit0\u3092\u7acb\u3066\u3066\u3001\u3053\u308c\u304canon\u3092\u6307\u3059\u3053\u3068\u3092\u793a\u3059 */\n    anon_vma = (void *) anon_vma + PAGE_MAPPING_ANON;\n    page->mapping = (struct address_space *) anon_vma;\n}\n\n\n\n\u3055\u3089\u306b\u6a2a\u9053\u306b\u305d\u308c\u3066\u3001Annonymous Memory\u3068\u7269\u7406\u30da\u30fc\u30b8(struct page)\n1\u3064\u306e\u7269\u7406\u30da\u30fc\u30b8\u306b\u306f\u3001\u305d\u308c\u3092\u8868\u73fe\u3059\u308b\u30c7\u30fc\u30bf\u69cb\u9020\u304c\u3042\u308b\u306e\u304c\u60f3\u5b9a\u3055\u308c\u307e\u3059\u3002\nLinux\u3067\u306fstruct page\u304c\u305d\u308c\u306b\u5f53\u305f\u308a\u307e\u3059\u3002\n\u3044\u304f\u3089\u3001\u30a2\u30c9\u30ec\u30b9\u7a7a\u9593\u304c\u3042\u3063\u3066\u3082\u3001\u305d\u3053\u306b\u7269\u7406\u30da\u30fc\u30b8\u3092\u7d10\u4ed8\u3051\u308b\u624b\u6bb5\u306a\u3051\u308c\u3070\u3001\u4f55\u306b\u3082\u306a\u308a\u307e\u305b\u3093\u3002\n\u7269\u7406\u30da\u30fc\u30b8\u3068\u306e\u7d10\u4ed8\u3051\u306b\u3064\u3044\u3066\u3001\u7591\u554f\u306b\u601d\u3048\u3066\u304d\u307e\u3057\u305f\u3002Annonymous Memory\u306e\u5b9f\u88c5\u306fmm/rmap.c\u306b\u3042\u308b\u306e\u3067\u3001\u7269\u7406\u30da\u30fc\u30b8\u3068\u306e\u7d10\u4ed8\u3051\u3092\u884c\u3046\u51e6\u7406\u3082\u307e\u305f\u3053\u306e\u30bd\u30fc\u30b9\u306b\u3042\u308b\u3068\u63a8\u5b9a\u3057\u3001\u8aad\u3093\u3067\u307f\u307e\u3059\u3002\n\u3059\u308b\u3068\u3001page\u3068anon\u306emap\u3092\u3072\u3082\u3065\u3051\u308b\u3088\u3046\u306a\u95a2\u6570\u3092\u898b\u3064\u3051\u307e\u3057\u305f\u3002\n\nmm/rmap.c\nvoid page_add_anon_rmap(struct page *page,\n    struct vm_area_struct *vma, unsigned long address)\n{\n    do_page_add_anon_rmap(page, vma, address, 0);\n}\n\n/*\n * Special version of the above for do_swap_page, which often runs\n * into pages that are exclusively owned by the current process.\n * Everybody else should continue to use page_add_anon_rmap above.\n */\nvoid do_page_add_anon_rmap(struct page *page,\n    struct vm_area_struct *vma, unsigned long address, int exclusive)\n{\n    /* \u7565 */\n    /* address might be in next vma when migration races vma_adjust */\n    if (first)\n        __page_set_anon_rmap(page, vma, address, exclusive);\n    else\n        __page_check_anon_rmap(page, vma, address);\n}\n\n/* \u3053\u3053\u3067map */\nstatic void __page_set_anon_rmap(struct page *page,\n    struct vm_area_struct *vma, unsigned long address, int exclusive)\n{\n    struct anon_vma *anon_vma = vma->anon_vma;\n\n/* \u7565 */\n    anon_vma = (void *) anon_vma + PAGE_MAPPING_ANON;\n    page->mapping = (struct address_space *) anon_vma;\n    page->index = linear_page_index(vma, address);\n}\n\n\npage\u69cb\u9020\u4f53\u306emapping\u306f\u3001\u305d\u308c\u304c\u5c5e\u3059\u308b\u306a\u306b\u304c\u3057\u304b\u306e\u30c7\u30fc\u30bf\u69cb\u9020\u306b\u3064\u306a\u304c\u308b\u3088\u3046\u3067\u3059\u3002\n\u3067\u3082\u3001\u30ad\u30e3\u30b9\u30c8\u3057\u3066\u3044\u308b\u3053\u3068\u304b\u3089\u308f\u304b\u308b\u3068\u304a\u308a\u3001mapping\u306faddress_space\u69cb\u9020\u4f53\u306e\u30dd\u30a4\u30f3\u30bf\u3067\u3059\u3002\u4e00\u65b9\u3001anon_vma\u306fanon_vma\u69cb\u9020\u4f53\u306e\u30dd\u30a4\u30f3\u30bf\u3067\u3059\u3002\n\u3067\u306f\u3001\u5b9f\u969bpage\u69cb\u9020\u4f53\u306emapping\u3092\u53c2\u7167\u3059\u308b\u3068\u304d\u306b\u69cb\u9020\u4f53\u306e\u7a2e\u5225\u3092\u3069\u3046\u3084\u3063\u3066\u898b\u5206\u3051\u308b\u306e\u3067\u3057\u3087\u3046\u304b\u3002\n\u5b9f\u306f\u3001PAGE_MAPPING_ANON\u304c\u30dd\u30a4\u30f3\u30c8\u3067\u3059\u3002\n\ninclude/linux/mm.h\n#define PAGE_MAPPING_ANON 1\n#define PAGE_MAPPING_KSM  2\n#define PAGE_MAPPING_FLAGS  (PAGE_MAPPING_ANON | PAGE_MAPPING_KSM)\n\n\n\u30a2\u30c9\u30ec\u30b9\u5024\u306b1\u3092\u8db3\u3059\u3053\u3068\u3067bit0\u304c1\u306b\u306a\u308a\u307e\u3059\u3002\n\u7279\u6b8a\u306a\u4e8b\u60c5\u306e\u306a\u3044\u9650\u308a\u3001\u69cb\u9020\u4f53\u306e\u5148\u982d\u30a2\u30c9\u30ec\u30b9\u304c\u5947\u6570\u756a\u5730\u306b\u914d\u7f6e\u3055\u308c\u308b\u3053\u3068\u306f\u3042\u308a\u307e\u305b\u3093\u3002\u3088\u3063\u3066\u3001page\u69cb\u9020\u4f53\u306emapping\u306e\u5024\u3092\u898b\u308c\u3070\u3001\u305d\u308c\u304cAnnonymous Memory\u306b\u5c5e\u3059\u308b\u304b\u3069\u3046\u304b\u304c\u308f\u304b\u308a\u307e\u3059\u3002\n\u305d\u3057\u3066\u3001page_add_anon_rmap()\u306e\u5f15\u6570\u3067\u6e21\u3063\u3066\u304f\u308baddress\u3092index\u3068\u3044\u3046\u5024\u306b\u5909\u63db\u3057\u3066\u3044\u307e\u3059\u3002(\u304a\u305d\u3089\u304f\u3001address\u306f\u4eee\u60f3\u30a2\u30c9\u30ec\u30b9\u3060\u3068\u601d\u308f\u308c\u308b)\n\u3053\u306e\u5909\u63db\u3092\u884c\u3063\u3066\u3044\u308b\u306e\u306f\u3001\u4ee5\u4e0b\u306e\u95a2\u6570\u3067\u3059\u3002\n\ninclude/linux/pagemap.h\n\nstatic inline pgoff_t linear_page_index(struct vm_area_struct *vma,\n                    unsigned long address)\n{\n    pgoff_t pgoff;\n    if (unlikely(is_vm_hugetlb_page(vma)))\n        return linear_hugepage_index(vma, address);\n    /* vm map area\u306e\u5148\u982d\u304b\u3089\u306e\u30aa\u30d5\u30bb\u30c3\u30c8\u3092\u30da\u30fc\u30b8\u5358\u4f4d\u3067\u6c42\u3081...*/\n    pgoff = (address - vma->vm_start) >> PAGE_SHIFT;\n    /* \n         * \u3048\u3001\u3053\u306evm_pgoff\u306f\u4f55\u8005\uff1fvm_map_area\u5185\u306e\u30aa\u30d5\u30bb\u30c3\u30c8\u3092\n         * \u6c42\u3081\u305f\u3044\u306e\u306a\u3089\u3001\u3055\u3089\u306b\u4e0b\u99c4\u3092\u5c65\u304b\u305b\u308b\u5fc5\u8981\u306f\u3042\u308b\u306e\uff1f\n         * \u305d\u3082\u305d\u3082vm_pgoff\u306f\u4f55\uff1f\n         */\n    pgoff += vma->vm_pgoff;\n    return pgoff >> (PAGE_CACHE_SHIFT - PAGE_SHIFT);\n}\n\n\nvm_pgoffset\u304c\u3088\u304f\u308f\u304b\u3089\u3093\u306e\u3067grep\u3059\u308b\u3068\u3001\u4ee5\u4e0b\u306e\u95a2\u6570\u304c\u305d\u306e\u7406\u89e3\u306e\u52a9\u3051\u306b\u306a\u308a\u305d\u3046\u3067\u3059\u3002\n\nmm/mmap.c\n\n/* \u3053\u308c\u304c\u304a\u305d\u3089\u304f\u3001anonymous\u306a\u5834\u5408\u306epg_off */\nint insert_vm_struct(struct mm_struct *mm, struct vm_area_struct *vma)\n{\n    struct vm_area_struct *prev;\n    struct rb_node **rb_link, *rb_parent;\n\n    /*\n     * The vm_pgoff of a purely anonymous vma should be irrelevant\n     * until its first write fault, when page's anon_vma and index\n     * are set.  But now set the vm_pgoff it will almost certainly\n     * end up with (unless mremap moves it elsewhere before that\n     * first wfault), so /proc/pid/maps tells a consistent story.\n     *\n     * By setting it to reflect the virtual start address of the\n     * vma, merges and splits can happen in a seamless way, just\n     * using the existing file pgoff checks and manipulations.\n     * Similarly in do_mmap_pgoff and in do_brk.\n     */\n    if (!vma->vm_file) {\n        BUG_ON(vma->anon_vma);\n        vma->vm_pgoff = vma->vm_start >> PAGE_SHIFT;\n    }\n\n\nAnnonymous Memory\u306e\u5834\u5408\u306f\u3001vm_pgoff\u306b\u305d\u306evma\u306e\u5148\u982d\u30a2\u30c9\u30ec\u30b9\u3092\u30da\u30fc\u30b8\u5358\u4f4d\u306b\u4e38\u3081\u305f\u5024\u304c\u683c\u7d0d\u3055\u308c\u308b\u3088\u3046\u3067\u3059\u3002\u7d50\u69cb\u30b3\u30e1\u30f3\u30c8\u3082\u8a73\u3057\u304f\u66f8\u3044\u3066\u3042\u308b\u306e\u3067\u30a4\u30e1\u30fc\u30b8\u304c\u3067\u304d\u307e\u3059\u3002\n\u3053\u3053\u307e\u3067\u3092\u8aad\u3080\u3068\u3001page\u69cb\u9020\u4f53\u304b\u3089\u305d\u308c\u306b\u5bfe\u5fdc\u3057\u305f\u4eee\u60f3\u30a2\u30c9\u30ec\u30b9\u3092\u53d6\u5f97\u3059\u308b\u3053\u3068\u3068\u3001\u305d\u306e\u9006\u3092\u3069\u306e\u3088\u3046\u306b\u3059\u308c\u3070\u3088\u3044\u304b\u304c\u898b\u3048\u3066\u304d\u307e\u3059\u3002\n\u3057\u304b\u3057\u3001\u7269\u7406\u30a2\u30c9\u30ec\u30b9\u3092Linux\u3067\u306f\u3069\u3046\u3084\u3063\u3066\u6271\u3063\u3066\u3044\u308b\u306e\u3067\u3057\u3087\u3046\u304b\uff1f\n\u4f8b\u3048\u3070\u3001\u4eee\u60f3\u30a2\u30c9\u30ec\u30b9\u304b\u3089\u7269\u7406\u30a2\u30c9\u30ec\u30b9\u3092\u5f97\u308b\u3001\u30da\u30fc\u30b8\u69cb\u9020\u4f53\u304b\u3089\u305d\u308c\u304c\u6307\u3057\u3066\u3044\u308b\u7269\u7406\u30a2\u30c9\u30ec\u30b9\u3092\u5f97\u308b\u65b9\u6cd5\u304c\u4eca\u3072\u3068\u3064\u898b\u3048\u307e\u305b\u3093\u3002\n\u3053\u3053\u3044\u3089\u306e\u7591\u554f\u3092\u3092\u6b21\u56de\u4ee5\u964d\u898b\u3066\u3044\u304d\u305f\u3044\u3068\u601d\u3044\u307e\u3059\u3002\n## \u3042\u3089\u307e\u3057\n[\u524d\u56de](http://qiita.com/akachochin/items/1efb887aa10c45298415)\u3001cgroups\u306b\u3064\u3044\u3066\u8efd\u304f\u3067\u306f\u3042\u308b\u304c\u66f8\u3044\u3066\u307f\u307e\u3057\u305f\u3002\n\n\u4e0a\u8a18\u306e\u6587\u7ae0\u306e\u6700\u5f8c\u306b\u300c\u6b21\u306fcgroups\u3068\u30e1\u30e2\u30ea\u7ba1\u7406\u3068\u3044\u3046\u30cd\u30bf\u3067\u884c\u3063\u3066\u307f\u305f\u3044\u300d\u3068\u66f8\u304d\u307e\u3057\u305f\u3002\n\u3082\u3061\u308d\u3093\u3059\u3050\u306bcgroups\u3068\u4eee\u60f3\u8a18\u61b6\u306e\u95a2\u4fc2\u304c\u308f\u304b\u308c\u3070\u3088\u3044\u306e\u3067\u3042\u308b\u304c\u3001\u4f55\u3076\u3093Linux\u306e\u4eee\u60f3\u8a18\u61b6\u306f\u8aad\u3080\u306e\u3082\u521d\u3081\u3066\u3067\u3059\u3002\u3088\u3063\u3066\u3001Linux\u306e\u4eee\u60f3\u8a18\u61b6\u306e\u6982\u8981\u3092\u3064\u304b\u3080\u305f\u3081\u306b\u307e\u305a\u306f\u30bd\u30fc\u30b9\u3092\u8aad\u3093\u3067\u307f\u307e\u3059\u3002\n\n\u6d41\u308c\u304c\u308f\u304b\u308a\u306b\u304f\u3044\u7b87\u6240\u3082\u3042\u308a\u307e\u3059\u3002\u304c\u3001\u30bd\u30fc\u30b9\u3092\u8aad\u3093\u3067\u8ff7\u3063\u305f\u904e\u7a0b\u3092\u3042\u3048\u3066\u8a18\u9332\u306b\u6b8b\u3057\u305f\u3044\u3068\u8003\u3048\u305f\u304b\u3089\u3067\u3059\u3002\u3054\u4e86\u89e3\u304f\u3060\u3055\u3044\u3002\n\n## \u3068\u3044\u3046\u3053\u3068\u3067fork()\n\u4eee\u60f3\u8a18\u61b6\u306e\u6a5f\u80fd\u3092\u7406\u89e3\u3059\u308b\u306b\u306f\u3001\u7d4c\u9a13\u5247\u4e0a\u3001\u3068\u3063\u304b\u304b\u308a\u304c\u5fc5\u8981\u3067\u3059\u3002\n\u305d\u306e\u3068\u3063\u304b\u304b\u308a\u306e\u4e00\u3064\u304cfork()\u3060\u3068\u601d\u3063\u3066\u3044\u307e\u3059\u3002\n\u4eba\u306b\u3088\u3063\u3066\u306f\u3001page fault(\u4f8b\u5916\u30cf\u30f3\u30c9\u30e9)\u304b\u3089\u5165\u3063\u305f\u308a\u3001mmap()\u304b\u3089\u5165\u3063\u305f\u308a\u3059\u308b\u3053\u3068\u3082\u3042\u308d\u3046\u304c\u3001\u524d\u56defork()\u304c\u3089\u307f\u306e\u3068\u3053\u308d\u3092\u8aad\u3093\u3060\u306e\u3067\u3001\u4eca\u56de\u3082\u3053\u3053\u304b\u3089\u884c\u304d\u307e\u3059\u3002\n\n```c:kernel/fork.c\n#ifdef __ARCH_WANT_SYS_FORK\nSYSCALL_DEFINE0(fork)\n{\n#ifdef CONFIG_MMU\n\treturn do_fork(SIGCHLD, 0, 0, NULL, NULL);\n#else\n\t/* can not support in nommu mode */\n\treturn -EINVAL;\n#endif\n}\n#endif\n```\n\u8003\u3048\u3066\u307f\u308c\u3070\u3001\u3053\u306eifdef\u306f\u5f53\u305f\u308a\u524d\u306a\u306e\u3060\u304c\u3001\u3059\u3054\u3044\u3082\u306e\u304c\u3042\u308a\u307e\u3059\u3002\n\u78ba\u304b\u306bMMU\u306a\u3057\u306eCPU\u3067\u306f\u3001fork()\u306f\u6210\u308a\u7acb\u305f\u306a\u3044\u3088\u3046\u306b\u601d\u3048\u308b\u306e\u3060\u304c\u3001MMU\u306a\u3057\u306eCPU\u3067\u306f\u30d7\u30ed\u30bb\u30b9\u3092\u3069\u3046\u3084\u3063\u3066\u751f\u6210\u3057\u3066\u3044\u308b\u306e\u3067\u3057\u3087\u3046\u304b\uff1f\n\u305d\u3093\u306a\u7591\u554f\u3092\u3072\u3068\u307e\u305a\u8107\u306b\u3088\u3051\u3066\u5148\u306b\u9032\u307f\u307e\u3059\u3002\n\n```c:kernel/fork.c\nlong do_fork(unsigned long clone_flags,\n        unsigned long stack_start,\n         unsigned long stack_size,\n         int __user *parent_tidptr,\n         int __user *child_tidptr)\n{\n  /* \u7565 */\n  p = copy_process(clone_flags, stack_start, stack_size,child_tidptr, NULL, trace);\n```\n\u304a\u305d\u3089\u304f\u306fcopy_process()\u3067\u3001\u89aa\u306e\u30d7\u30ed\u30bb\u30b9\u69cb\u9020\u4f53\u3092\u5143\u624b\u306b\u5b50\u306e\u30d7\u30ed\u30bb\u30b9\u69cb\u9020\u4f53\u3092\u4f5c\u308b\u306e\u3060\u308d\u3046\u3002\n\u5f53\u7136\u3001\u305d\u306e\u4e2d\u306b\u306f\u4eee\u60f3\u30a2\u30c9\u30ec\u30b9\u7a7a\u9593\u306b\u95a2\u3059\u308b\u3053\u3068\u3082\u542b\u307e\u308c\u308b\u306e\u3067\u3042\u308d\u3046\u3068\u60f3\u5b9a\u3057\u3066\u3001\u5148\u306b\u9032\u307f\u307e\u3059\u3002\n\n```c:kernel/fork.c\nstatic struct task_struct *copy_process(unsigned long clone_flags,\n          unsigned long stack_start,\n          unsigned long stack_size,\n          int __user *child_tidptr,\n          struct pid *pid,\n          int trace)\n{\n/* \u3068\u3066\u3082\u9577\u3044\u3002\u7565\u3002\u5f15\u6570\u30c1\u30a7\u30c3\u30af\u306e\u3042\u3068\u3001\u3044\u308d\u3044\u308d\u306a\u3082\u306e\u3092\u30b3\u30d4\u30fc\u3057\u3066\u3044\u308b */\n  retval = copy_mm(clone_flags, p);\n  if (retval)\n    goto bad_fork_cleanup_signal;\n```\n\u76ee\u5f53\u3066\u306e\u4eee\u60f3\u8a18\u61b6\u306b\u95a2\u9023\u3057\u305d\u3046\u306a\u3068\u3053\u308d\u304c\u3042\u308a\u307e\u3057\u305f\u3002\n\n```c:kernel/fork.c\nstatic int copy_mm(unsigned long clone_flags, struct task_struct *tsk)\n{\n  /* \u7565 */\n  /*\n   * Are we cloning a kernel thread?\n   *\n   * We need to steal a active VM for that..\n   */\n  oldmm = current->mm;\n  if (!oldmm)\n    return 0;\n\n  /* \u7565 */ \n  retval = -ENOMEM;\n  mm = dup_mm(tsk);\n  if (!mm)\n    goto fail_nomem;\n```\n\n\u3044\u304b\u306b\u3082\u4eee\u60f3\u30a2\u30c9\u30ec\u30b9\u7a7a\u9593\u306e\u8907\u88fd\u3092\u3057\u305d\u3046\u306a\u540d\u524d\u306edup_mm()\u3002\u898b\u3066\u307f\u307e\u3057\u3087\u3046\u3002\n\n```c:kernel/fork.c\n/*\n * Allocate a new mm structure and copy contents from the\n * mm structure of the passed in task structure.\n */\n static struct mm_struct *dup_mm(struct task_struct *tsk)\n{\n  struct mm_struct *mm, *oldmm = current->mm;\n  int err;\n\n  mm = allocate_mm();\n  if (!mm)\n    goto fail_nomem;\n\n  memcpy(mm, oldmm, sizeof(*mm));\n  mm_init_cpumask(mm);\n  dup_mm_exe_file(oldmm, mm);\n\n  err = dup_mmap(mm, oldmm);\n  if (err)\n    goto free_pt;\n```\n\n\u307e\u305a\u3001oldmm\u3092\u53d6\u5f97\u3057\u307e\u3059\u3002current\u306f\u304a\u305d\u3089\u304f\u73fe\u5728\u5b9f\u884c\u4e2d\u306e\u30d7\u30ed\u30bb\u30b9(\u3064\u307e\u308a\u3001fork()\u3092\u5b9f\u884c\u3057\u3066\u3044\u308b\u89aa\u30d7\u30ed\u30bb\u30b9)\u3060\u3068\u601d\u308f\u308c\u307e\u3059\u3002\n\u65b0\u305f\u306bmm_struct\u69cb\u9020\u4f53\u3092\u5272\u308a\u5f53\u3066\u3066\u3001\u89aa\u306emm_struct\u3092\u30b3\u30d4\u30fc\u3057\u3066\u3044\u307e\u3059\u3002\n\n\u305d\u3057\u3066\u3001\u30a2\u30c9\u30ec\u30b9\u7a7a\u9593\u306b\u95a2\u3057\u3066\u3044\u3048\u3070\u3001dup_mmap()\u304c\u3082\u3046\u5c11\u3057\u8907\u96d1\u306a\u3053\u3068\u3092\u3059\u308b\u8907\u5199\u51e6\u7406\u3060\u3068\u63a8\u5b9a\u3067\u304d\u307e\u3059\u3002(\u4f3c\u305f\u3088\u3046\u306a\u540d\u524d\u306e\u95a2\u6570\u304c\u7d9a\u304d\u307e\u3059\u304c\u30fb\u30fb\u30fb)\n\n## \u3068\u3053\u308d\u3067\u3001mm_struct\u3068\u306f\uff1f\n\n```c:include/linux/mm_types.h\n345 struct mm_struct {\n346   struct vm_area_struct *mmap;    /* list of VMAs */\n/* \u4ee5\u4e0b\u305f\u304f\u3055\u3093\u306e\u30e1\u30f3\u30d0\u304c\u3042\u308b\u304c\u3001\u7565 */\n```\n\n\u8981\u306f\u3001\u30d7\u30ed\u30bb\u30b9\u306e\u30a2\u30c9\u30ec\u30b9\u7a7a\u9593\u3092\u8868\u73fe\u3059\u308b\u305f\u3081\u306e\u69cb\u9020\u4f53\u3067\u3059\u3002\n\n\u305d\u3057\u3066\u3001\u30a2\u30c9\u30ec\u30b9\u7a7a\u9593\u3068\u4e00\u53e3\u306b\u8a00\u3063\u3066\u3082\u3001\u305d\u306e\u4e2d\u306b\u306f\u5c5e\u6027\u306e\u9055\u3046\u9818\u57df\u304c\u3044\u304f\u3064\u304b\u3042\u308b\u306e\u306f\u30a4\u30e1\u30fc\u30b8\u304c\u3064\u304f\u304b\u3068\u601d\u3044\u307e\u3059\u3002\n\n\u4f8b\u3048\u3070\u3001\u547d\u4ee4(.text)\u304c\u30ed\u30fc\u30c9\u3055\u308c\u308b\u30e1\u30e2\u30ea\u9818\u57df\u3067\u3042\u308c\u3070\u8aad\u307f+\u5b9f\u884c\u5c5e\u6027\u3068\u306a\u308b\u3067\u3057\u3087\u3046\u3057\u3001\u30c7\u30fc\u30bf(.data)\u3067\u3042\u308c\u3070\u8aad\u307f+\u66f8\u304d\u5c5e\u6027\u3068\u306a\u308b\u3067\u3057\u3087\u3046\u3002\n\u305d\u306e\u4ed6\u306b\u3082\u69d8\u3005\u306a\u5c5e\u6027\u304c\u3042\u308a\u307e\u3059\u3002\n\u305d\u3093\u306a\u300c\u30d7\u30ed\u30bb\u30b9\u30a2\u30c9\u30ec\u30b9\u7a7a\u9593\u5185\u306e\u69d8\u3005\u306a\u9818\u57df\u300d\u3092\u8868\u73fe\u3057\u305f\u3082\u306e\u304cvm_area_struct\u69cb\u9020\u4f53\u306b\u306a\u308b\u3068\u601d\u308f\u308c\u307e\u3059\u3002\n\n```c:include/linux/mm_types.h\n*\n* This struct defines a memory VMM memory area. There is one of these\n* per VM-area/task.  A VM area is any part of the process virtual memory\n* space that has a special rule for the page-fault handlers (ie a shared\n* library, the executable area etc).\n*/\nstruct vm_area_struct {\n /* The first cache line has the info for VMA tree walking. */\n\n unsigned long vm_start;   /* Our start address within vm_mm. */\n unsigned long vm_end;   /* The first byte after our end address\n\n /* linked list of VM areas per task, sorted by address */\n struct vm_area_struct *vm_next, *vm_prev;\n/* \u7565 */\n pgprot_t vm_page_prot;    /* Access permissions of this VMA. */\n unsigned long vm_flags;   /* Flags, see mm.h. */\n\n  /*\n   * For areas with an address space and backing store,\n   * linkage into the address_space->i_mmap interval tree, or\n   * linkage of vma in the address_space->i_mmap_nonlinear list.\n   */\n  union {\n    struct { \n      struct rb_node rb;\n      unsigned long rb_subtree_last;\n    } linear;\n    struct list_head nonlinear;\n  } shared;\n\n  /*\n   * A file's MAP_PRIVATE vma can be in both i_mmap tree and anon_vma\n   * list, after a COW of one of the file pages.  A MAP_SHARED vma\n   * can only be in the i_mmap tree.  An anonymous MAP_PRIVATE, stack\n   * or brk vma (with NULL file) can only be in an anon_vma list.\n   */\n  struct list_head anon_vma_chain; /* Serialized by mmap_sem &\n            * page_table_lock */\n  struct anon_vma *anon_vma;  /* Serialized by page_table_lock */\n\n  /* Function pointers to deal with this struct. */\n  const struct vm_operations_struct *vm_ops;\n\n  /* Information about our backing store: */\n  unsigned long vm_pgoff;   /* Offset (within vm_file) in PAGE_SIZE\n             units, *not* PAGE_CACHE_SIZE */\n  struct file * vm_file;    /* File we map to (can be NULL). */\n  void * vm_private_data;   /* was vm_pte (shared mem) */\n/* \u7565 */\n```\n\n\u305d\u306e\u307e\u307edup_mmap()\u3092\u8aad\u3093\u3067\u307f\u308b\u3053\u3068\u306b\u3057\u307e\u3057\u3087\u3046\u3002\n\n```c:kern/fork.c\n#ifdef CONFIG_MMU\nstatic int dup_mmap(struct mm_struct *mm, struct mm_struct *oldmm)\n{\n/* \u7565 */\n   prev = NULL;\n/* \u89aa\u306e\u30a2\u30c9\u30ec\u30b9\u7a7a\u9593\u306e\u9818\u57df\u3092\u4e00\u3064\u305a\u3064\u51e6\u7406\u3057\u3066\u3044\u304f */\n   for (mpnt = oldmm->mmap; mpnt; mpnt = mpnt->vm_next) {\n     struct file *file;\n/* \u7565 */\n/* \n * \u307e\u305a\u306f\u9818\u57df\u304cannonymous memory\u3068\u3057\u3066\u51e6\u7406\u3002\n * \u5b9f\u306f\u5bfe\u8c61\u3068\u306a\u308b\u9818\u57df\u304cannonymous memory\u3067\u306a\u3044\u5834\u5408\u3001\u53730\u3092\u8fd4\u3059\u306e\u3067\u554f\u984c\u306a\u3044\n */\n     if (anon_vma_fork(tmp, mpnt))\n       goto fail_nomem_anon_vma_fork;\n\n/* \n * \u4ee5\u4e0b\u3001\u30d0\u30c3\u30ad\u30f3\u30b0\u30b9\u30c8\u30a2\u306e\u6709\u7121\u306b\u3088\u3063\u3066\u51e6\u7406\u304c\u5206\u304b\u308c\u3066\u3044\u308b\u304c\u3001\u4eca\u56de\u306f\u7565\n */\n```\n\n\u3055\u3066\u3001\u3053\u3053\u3067anon\u3068\u3044\u3046\u540d\u79f0\u306e\u95a2\u6570\u304c\u51fa\u3066\u304d\u307e\u3057\u305f\u3002\n\u3053\u308c\u306f\u305d\u306e\u540d\u524d\u304b\u3089Annonymous Memory\u3092\u6271\u3063\u3066\u3044\u308b\u306e\u3060\u308d\u3046\u3068\u601d\u3044\u307e\u3059\u3002\n\u6a2a\u9053\u306b\u9038\u308c\u3066(\u6df1\u307f\u306b\u306f\u307e\u3063\u3066)Annonymous Memory\u306e\u5b9f\u73fe\u65b9\u6cd5\u3092\u898b\u3066\u307f\u305f\u304f\u306a\u3063\u305f\u306e\u3067\u3001\u7d9a\u3051\u3066\u8aad\u307f\u307e\u3059\u3002\n\n## Annonymous Memory(\u533f\u540d\u30e1\u30e2\u30ea)\u3068\u306f\n\u8981\u3059\u308b\u306b\u300c\u30d0\u30c3\u30ad\u30f3\u30b0\u30b9\u30c8\u30a2(\u5143\u30cd\u30bf\u3068\u306a\u308b\u30d5\u30a1\u30a4\u30eb)\u306e\u306a\u3044\u30c7\u30fc\u30bf\u3092\u683c\u7d0d\u3059\u308b\u305f\u3081\u306e\u30e1\u30e2\u30ea\u9818\u57df\u300d\u3067\u3059\u3002\n\u4f8b\u3048\u3070\u3001.text\u306e\u4e2d\u8eab\u3084SHARED\u3067regular file\u3092map\u3057\u305fmmap\u9818\u57df\u306a\u3069\u306f\u30d0\u30c3\u30ad\u30f3\u30b0\u30b9\u30c8\u30a2\u304c\u3042\u308b\u30e1\u30e2\u30ea\u9818\u57df\u3067\u3059\u3002\n\n\u30e1\u30e2\u30ea\u4e0d\u8db3\u306e\u3068\u304d\u3092\u8003\u3048\u3066\u307f\u307e\u3057\u3087\u3046\u3002\u4f8b\u3048\u3070\u3001.text\u306a\u3089\u6368\u3066\u305f\u3068\u3057\u3066\u3082\u307e\u305f\u5b9f\u884c\u5f62\u5f0f\u30d5\u30a1\u30a4\u30eb\u304b\u3089\u8aad\u3081\u3070\u5185\u5bb9\u3092\u518d\u751f\u3067\u304d\u308b\u3057\u3001mmap\u9818\u57df\u3067\u3042\u308c\u3070\u4e00\u65e6\u30d5\u30a1\u30a4\u30eb\u306b\u66f8\u304d\u8fbc\u3093\u3067\u540c\u671f\u3092\u3068\u3063\u3066\u3057\u307e\u3048\u3070\u5185\u5bb9\u3092\u518d\u751f\u3067\u304d\u307e\u3059\u3002\n\u3053\u3046\u3057\u305f\u9818\u57df\u306f\u300c\u30d0\u30c3\u30ad\u30f3\u30b0\u30b9\u30c8\u30a2\u304c\u3042\u308b\u300d\u30e1\u30e2\u30ea\u9818\u57df\u306b\u306a\u308a\u307e\u3059\u3002\n\n\u3057\u304b\u3057\u3001.data\u3084\u30b9\u30bf\u30c3\u30af\u9818\u57df\u306fAnnonymous Memory\u3068\u8a00\u3048\u307e\u3059\u3002\n\u3053\u308c\u307e\u305f\u30e1\u30e2\u30ea\u4e0d\u8db3\u306e\u3068\u304d\u3092\u8003\u3048\u308c\u3070\u3088\u3044\u306e\u3067\u3059\u304c\u3001.data\u306f\u4e00\u5ea6RAM\u4e0a\u306e\u5024\u304c\u5909\u308f\u308b\u3068\u5b9f\u884c\u30d5\u30a1\u30a4\u30eb\u5185\u306e\u5185\u5bb9\u3068\u4e00\u81f4\u3057\u306a\u304f\u306a\u308a\u307e\u3059\u3002\n\u3060\u304b\u3089\u3068\u3044\u3063\u3066\u3001\u30e1\u30e2\u30ea\u4e0d\u8db3\u6642\u306b\u300c\u5b9f\u884c\u5f62\u5f0f\u30d5\u30a1\u30a4\u30eb\u306b\u66f8\u304d\u3060\u305b\u3070\u300d\u5b9f\u884c\u5f62\u5f0f\u30d5\u30a1\u30a4\u30eb\u306e\u521d\u671f\u5024\u304c\u5909\u308f\u308a\u3001\u30d5\u30a1\u30a4\u30eb\u304c\u58ca\u308c\u3066\u3057\u307e\u3044\u307e\u3059\u3002\n\u30b9\u30bf\u30c3\u30af\u306b\u81f3\u3063\u3066\u306f\u3001\u5b9f\u884c\u5f62\u5f0f\u30d5\u30a1\u30a4\u30eb\u306e\u3069\u3053\u306b\u3082\u300c\u5143\u30cd\u30bf\u300d\u306f\u3042\u308a\u307e\u305b\u3093\u3002\n\u3088\u3063\u3066\u3001\u30e1\u30e2\u30ea\u4e0d\u8db3\u6642\u306b\u306f\u3053\u308c\u3089\u306e\u30e1\u30e2\u30ea\u9818\u57df\u306fswap\u3055\u305b\u306a\u3044\u3068\u30c0\u30e1\u3067\u3059\u3002\n\n\u30e1\u30e2\u30ea\u9818\u57df\u306b\u306f\u3053\u3046\u3044\u3046\u89b3\u70b9\u306e\u898b\u65b9\u3082\u3042\u308b\u3068\u3044\u3046\u3053\u3068\u3092\u982d\u306e\u7247\u9685\u306b\u65bc\u3044\u3066\u3082\u3089\u3048\u308c\u3070\u826f\u3044\u3068\u601d\u3044\u307e\u3059\u3002\n\n## \u4eee\u60f3\u8a18\u61b6\u306b\u30ba\u30d6\u30ba\u30d6\u3068....\nanon_vma_fork()\u306fkernel/\u306e\u4e0b\u3067\u306a\u304f\u3001mm/\u306e\u4e0b\u306e\u30bd\u30fc\u30b9\u306b\u3042\u308a\u307e\u3059\u3002\n\u3044\u3088\u3044\u3088\u4eee\u60f3\u8a18\u61b6\u306e\u30b3\u30fc\u30c9\u306b\u3069\u3063\u3077\u308a\u3068\u6d78\u304b\u308b\u3053\u3068\u306b\u306a\u308a\u307e\u3059\u3002\n\n```c:mm/rmap.c\nint anon_vma_fork(struct vm_area_struct *vma, struct vm_area_struct *pvma)\n{\n  struct anon_vma_chain *avc;\n  struct anon_vma *anon_vma;\n/* \u7565 */\n  /*\n   * First, attach the new VMA to the parent VMA's anon_vmas,\n   * so rmap can find non-COWed pages in child processes.\n   */\n  if (anon_vma_clone(vma, pvma))\n    return -ENOMEM;\n  /* Then add our own anon_vma. */\n  anon_vma = anon_vma_alloc();\n  if (!anon_vma)\n    goto out_error;\n  avc = anon_vma_chain_alloc(GFP_KERNEL);\n  if (!avc)\n    goto out_error_free_anon_vma;\n```\n\n\u307e\u305f\u307e\u305fclone\u7cfb\u3002\u8907\u88fd\u306e\u5c64\u3092\u4e0b\u3078\u4e0b\u3078\u3068\u6f5c\u3063\u3066\u3044\u304d\u307e\u3059\u3002\n\n```c:mm/rmap.c\n/*\n * Attach the anon_vmas from src to dst.\n * Returns 0 on success, -ENOMEM on failure.\n */\nint anon_vma_clone(struct vm_area_struct *dst, struct vm_area_struct *src)\n{\n  struct anon_vma_chain *avc, *pavc;\n  struct anon_vma *root = NULL;\n/* anon_vma_chain\u306eanon_vma_chain\u3092\u5148\u982d\u3068\u3059\u308bsame_vma\u30ea\u30b9\u30c8\u3092\u9006\u306b\u305f\u3069\u308b */\n  list_for_each_entry_reverse(pavc, &src->anon_vma_chain, same_vma) {\n    struct anon_vma *anon_vma;\n \n    avc = anon_vma_chain_alloc(GFP_NOWAIT | __GFP_NOWARN);\n    if (unlikely(!avc)) {\n      unlock_anon_vma_root(root);\n      root = NULL;\n      avc = anon_vma_chain_alloc(GFP_KERNEL);\n      if (!avc)\n        goto enomem_failure;\n    }\n    anon_vma = pavc->anon_vma;\n    root = lock_anon_vma_root(root, anon_vma);\n    anon_vma_chain_link(dst, avc, anon_vma);\n```\n\nanon_vma\u3068\u304banon_vma_chain\u3068\u304b\u65b0\u3057\u3044\u69cb\u9020\u4f53\u304c\u51fa\u3066\u304d\u307e\u3057\u305f\u3002\n\u305d\u308c\u3089\u306f\u4ee5\u4e0b\u306e\u30d8\u30c3\u30c0\u306b\u3042\u308a\u307e\u3059\u3002\n\n```c:include/linux/rmap.h\n/*\n * The anon_vma heads a list of private \"related\" vmas, to scan if\n * an anonymous page pointing to this anon_vma needs to be unmapped:\n  * the vmas on the list will be related by forking, or by splitting.\n *\n * Since vmas come and go as they are split and merged (particularly\n * in mprotect), the mapping field of an anonymous page cannot point\n * directly to a vma: instead it points to an anon_vma, on whose list\n * the related vmas can be easily linked or unlinked.\n *\n * After unlinking the last vma on the list, we must garbage collect\n * the anon_vma object itself: we're guaranteed no page can be\n * pointing to this anon_vma once its vma list is empty.\n */\nstruct anon_vma {\n  struct anon_vma *root;    /* Root of this anon_vma tree */\n  struct rw_semaphore rwsem;  /* W: modification, R: walking the list */\n  /*\n   * The refcount is taken on an anon_vma when there is no\n   * guarantee that the vma of page tables will exist for\n   * the duration of the operation. A caller that takes\n   * the reference is responsible for clearing up the\n   * anon_vma if they are the last user on release\n   */\n  atomic_t refcount;\n\n  /*\n   * NOTE: the LSB of the rb_root.rb_node is set by\n   * mm_take_all_locks() _after_ taking the above lock. So the\n   * rb_root must only be read/written after taking the above lock\n   * to be sure to see a valid next pointer. The LSB bit itself\n   * is serialized by a system wide lock only visible to\n   * mm_take_all_locks() (mm_all_locks_mutex).\n   */\n  struct rb_root rb_root; /* Interval tree of private \"related\" vmas */\n};\n\n/*\n * The copy-on-write semantics of fork mean that an anon_vma\n * can become associated with multiple processes. Furthermore,\n * each child process will have its own anon_vma, where new\n * pages for that process are instantiated.\n *\n * This structure allows us to find the anon_vmas associated\n * with a VMA, or the VMAs associated with an anon_vma.\n * The \"same_vma\" list contains the anon_vma_chains linking\n * all the anon_vmas associated with this VMA.\n * The \"rb\" field indexes on an interval tree the anon_vma_chains\n * which link all the VMAs associated with this anon_vma.\n */\nstruct anon_vma_chain {\n  struct vm_area_struct *vma;\n  struct anon_vma *anon_vma;\n  struct list_head same_vma;   /* locked by mmap_sem & page_table_lock */\n  struct rb_node rb;      /* locked by anon_vma->rwsem */\n  unsigned long rb_subtree_last;\n#ifdef CONFIG_DEBUG_VM_RB\n  unsigned long cached_vma_start, cached_vma_last;\n#endif\n};\n```\n\n\u6b21\u306b\u3001\u5148\u306b\u9032\u307f\u3001anon_vma_chain_link()\u306e\u4e2d\u3092\u898b\u307e\u3059\u3002\n\n```c:mm/rmap.c\nstatic void anon_vma_chain_link(struct vm_area_struct *vma,\n        struct anon_vma_chain *avc,\n        struct anon_vma *anon_vma)\n{\n  avc->vma = vma; \n  avc->anon_vma = anon_vma;\n/* anon_vma_chain(head)\u306e\u6b21\u306bsame_vma\u3092\u3064\u306a\u3050 */\n  list_add(&avc->same_vma, &vma->anon_vma_chain);\n   anon_vma_interval_tree_insert(avc, &anon_vma->rb_root);\n}\n```\n\n\u3053\u3053\u307e\u3067\u8aad\u3080\u3068\u3001anon_vma_chain\u306f\u4ee5\u4e0b\u306e\u69cb\u9020\u306b\u306a\u3063\u3066\u3044\u308b\u3088\u3046\u306b\u8aad\u3081\u307e\u3059\u3002\n\n```\nvma->anon_vma_chain -- <same_vma> -- <same_vma>\n                         [avc]         [avc]\n                        * vma\u306f\u5b50\u30d7\u30ed\u30bb\u30b9\u306evma\n                        * anon_vma\u306f\u89aa\u30d7\u30ed\u30bb\u30b9(fork\u6642\u70b9)\u3068\u5171\u7528\n```\n\nanon_vma\u306erb_root\u306bavc\u3092\u3064\u306a\u3044\u3067\u304a\u304d\u307e\u3059\u3002\n\u3053\u308c\u306b\u3088\u3063\u3066\u3001anon_vma\u304b\u3089\u306f\u305d\u308c\u304c\u5c5e\u3059\u308bvma(vm_area_struct)\u3092\u5f15\u304f\u3053\u3068\u304c\u3067\u304d\u308b\u3057\u3001vma\u5074\u304b\u3089\u306fanon_vma\u3092\u305f\u3069\u308b\u3053\u3068\u304c\u3067\u304d\u308b\u3088\u3046\u306b\u306a\u308b\u306f\u305a\u3067\u3059\u3002\n\nanon_vma_clone()\u304c\u7d42\u308f\u308b\u3068\u3001anon_vma\u8996\u70b9\u3067\u306f\u3001\u89aa\u3068\u5b50\u306evma\u306f\u4ee5\u4e0b\u306e\u69cb\u9020\u3068\u306a\u308b\u306f\u305a\u3067\u3059\u3002\u3053\u308c\u3067\u3001\u89aa\u3068\u5b50\u304c\u3068\u308a\u3042\u3048\u305a\u540c\u3058\u30e1\u30e2\u30ea\u306e\u5185\u5bb9\u304c\u898b\u3048\u308b(=\u8907\u5199\u3055\u308c\u305f*\u304b\u306e\u3088\u3046\u306b*)\u3088\u3046\u306b\u306a\u308a\u307e\u3059\u3002\n\n```\n(Parents)vma->anon_vma_chain -- <same_vma> -- <same_vma>\n                                 [avc]         [avc]\n                               vma |         vma |\n                                   |             |\n                                   |             |\n                                anon_vma      anon_vma\n                                   |             |\n                                   |             |\n                               vma |         vma |\n                                 [avc]         [avc]\n(Child   )vma->anon_vma_chain -- <same_vma> -- <same_vma>\n```\n\n\u3061\u306a\u307f\u306b\u3053\u3053\u306b\u306f\u8f09\u305b\u307e\u305b\u3093\u304c\u3001list_add\u3082\u30ea\u30b9\u30c8\u30d8\u30c3\u30c9\u3082\u500b\u3005\u306e\u8981\u7d20\u3082\u540c\u3058list_head\u69cb\u9020\u4f53\u3067\u634c\u3044\u305f\u308a\u3057\u3066\u3044\u307e\u3059\u3002\u5c0f\u30cd\u30bf\u7684\u306b\u306f\u300c\u306a\u308b\u307b\u3069\u300d\u3068\u601d\u308f\u305b\u308b\u3082\u306e\u304c\u3042\u308a\u307e\u3059\u3002\n\n```c:mm/rmap.c\n/* page\u3092struct vm_area_struct\u304c\u6307\u3059anon_map\u304c\u6307\u3059\u9818\u57df\u306b\u79fb\u52d5\u3059\u308b */\nvoid page_move_anon_rmap(struct page *page,\n\tstruct vm_area_struct *vma, unsigned long address)\n{\n\tstruct anon_vma *anon_vma = vma->anon_vma;\n/* \u7565 */\n\t/* bit0\u3092\u7acb\u3066\u3066\u3001\u3053\u308c\u304canon\u3092\u6307\u3059\u3053\u3068\u3092\u793a\u3059 */\n\tanon_vma = (void *) anon_vma + PAGE_MAPPING_ANON;\n\tpage->mapping = (struct address_space *) anon_vma;\n}\n```\n\n## \u3055\u3089\u306b\u6a2a\u9053\u306b\u305d\u308c\u3066\u3001Annonymous Memory\u3068\u7269\u7406\u30da\u30fc\u30b8(struct page)\n\n1\u3064\u306e\u7269\u7406\u30da\u30fc\u30b8\u306b\u306f\u3001\u305d\u308c\u3092\u8868\u73fe\u3059\u308b\u30c7\u30fc\u30bf\u69cb\u9020\u304c\u3042\u308b\u306e\u304c\u60f3\u5b9a\u3055\u308c\u307e\u3059\u3002\nLinux\u3067\u306fstruct page\u304c\u305d\u308c\u306b\u5f53\u305f\u308a\u307e\u3059\u3002\n\u3044\u304f\u3089\u3001\u30a2\u30c9\u30ec\u30b9\u7a7a\u9593\u304c\u3042\u3063\u3066\u3082\u3001\u305d\u3053\u306b\u7269\u7406\u30da\u30fc\u30b8\u3092\u7d10\u4ed8\u3051\u308b\u624b\u6bb5\u306a\u3051\u308c\u3070\u3001\u4f55\u306b\u3082\u306a\u308a\u307e\u305b\u3093\u3002\n\u7269\u7406\u30da\u30fc\u30b8\u3068\u306e\u7d10\u4ed8\u3051\u306b\u3064\u3044\u3066\u3001\u7591\u554f\u306b\u601d\u3048\u3066\u304d\u307e\u3057\u305f\u3002Annonymous Memory\u306e\u5b9f\u88c5\u306fmm/rmap.c\u306b\u3042\u308b\u306e\u3067\u3001\u7269\u7406\u30da\u30fc\u30b8\u3068\u306e\u7d10\u4ed8\u3051\u3092\u884c\u3046\u51e6\u7406\u3082\u307e\u305f\u3053\u306e\u30bd\u30fc\u30b9\u306b\u3042\u308b\u3068\u63a8\u5b9a\u3057\u3001\u8aad\u3093\u3067\u307f\u307e\u3059\u3002\n\n\u3059\u308b\u3068\u3001page\u3068anon\u306emap\u3092\u3072\u3082\u3065\u3051\u308b\u3088\u3046\u306a\u95a2\u6570\u3092\u898b\u3064\u3051\u307e\u3057\u305f\u3002\n\n```c:mm/rmap.c\nvoid page_add_anon_rmap(struct page *page,\n\tstruct vm_area_struct *vma, unsigned long address)\n{\n\tdo_page_add_anon_rmap(page, vma, address, 0);\n}\n\n/*\n * Special version of the above for do_swap_page, which often runs\n * into pages that are exclusively owned by the current process.\n * Everybody else should continue to use page_add_anon_rmap above.\n */\nvoid do_page_add_anon_rmap(struct page *page,\n\tstruct vm_area_struct *vma, unsigned long address, int exclusive)\n{\n\t/* \u7565 */\n\t/* address might be in next vma when migration races vma_adjust */\n\tif (first)\n\t\t__page_set_anon_rmap(page, vma, address, exclusive);\n\telse\n\t\t__page_check_anon_rmap(page, vma, address);\n}\n\n/* \u3053\u3053\u3067map */\nstatic void __page_set_anon_rmap(struct page *page,\n\tstruct vm_area_struct *vma, unsigned long address, int exclusive)\n{\n\tstruct anon_vma *anon_vma = vma->anon_vma;\n\n/* \u7565 */\n\tanon_vma = (void *) anon_vma + PAGE_MAPPING_ANON;\n\tpage->mapping = (struct address_space *) anon_vma;\n\tpage->index = linear_page_index(vma, address);\n}\n```\n\npage\u69cb\u9020\u4f53\u306emapping\u306f\u3001\u305d\u308c\u304c\u5c5e\u3059\u308b\u306a\u306b\u304c\u3057\u304b\u306e\u30c7\u30fc\u30bf\u69cb\u9020\u306b\u3064\u306a\u304c\u308b\u3088\u3046\u3067\u3059\u3002\n\u3067\u3082\u3001\u30ad\u30e3\u30b9\u30c8\u3057\u3066\u3044\u308b\u3053\u3068\u304b\u3089\u308f\u304b\u308b\u3068\u304a\u308a\u3001mapping\u306faddress_space\u69cb\u9020\u4f53\u306e\u30dd\u30a4\u30f3\u30bf\u3067\u3059\u3002\u4e00\u65b9\u3001anon_vma\u306fanon_vma\u69cb\u9020\u4f53\u306e\u30dd\u30a4\u30f3\u30bf\u3067\u3059\u3002\n\u3067\u306f\u3001\u5b9f\u969bpage\u69cb\u9020\u4f53\u306emapping\u3092\u53c2\u7167\u3059\u308b\u3068\u304d\u306b\u69cb\u9020\u4f53\u306e\u7a2e\u5225\u3092\u3069\u3046\u3084\u3063\u3066\u898b\u5206\u3051\u308b\u306e\u3067\u3057\u3087\u3046\u304b\u3002\n\n\u5b9f\u306f\u3001PAGE_MAPPING_ANON\u304c\u30dd\u30a4\u30f3\u30c8\u3067\u3059\u3002\n\n```c:include/linux/mm.h\n#define PAGE_MAPPING_ANON 1\n#define PAGE_MAPPING_KSM  2\n#define PAGE_MAPPING_FLAGS  (PAGE_MAPPING_ANON | PAGE_MAPPING_KSM)\n```\n\n\u30a2\u30c9\u30ec\u30b9\u5024\u306b1\u3092\u8db3\u3059\u3053\u3068\u3067bit0\u304c1\u306b\u306a\u308a\u307e\u3059\u3002\n\u7279\u6b8a\u306a\u4e8b\u60c5\u306e\u306a\u3044\u9650\u308a\u3001\u69cb\u9020\u4f53\u306e\u5148\u982d\u30a2\u30c9\u30ec\u30b9\u304c\u5947\u6570\u756a\u5730\u306b\u914d\u7f6e\u3055\u308c\u308b\u3053\u3068\u306f\u3042\u308a\u307e\u305b\u3093\u3002\u3088\u3063\u3066\u3001page\u69cb\u9020\u4f53\u306emapping\u306e\u5024\u3092\u898b\u308c\u3070\u3001\u305d\u308c\u304cAnnonymous Memory\u306b\u5c5e\u3059\u308b\u304b\u3069\u3046\u304b\u304c\u308f\u304b\u308a\u307e\u3059\u3002\n\n\u305d\u3057\u3066\u3001page_add_anon_rmap()\u306e\u5f15\u6570\u3067\u6e21\u3063\u3066\u304f\u308baddress\u3092index\u3068\u3044\u3046\u5024\u306b\u5909\u63db\u3057\u3066\u3044\u307e\u3059\u3002(\u304a\u305d\u3089\u304f\u3001address\u306f\u4eee\u60f3\u30a2\u30c9\u30ec\u30b9\u3060\u3068\u601d\u308f\u308c\u308b)\n\u3053\u306e\u5909\u63db\u3092\u884c\u3063\u3066\u3044\u308b\u306e\u306f\u3001\u4ee5\u4e0b\u306e\u95a2\u6570\u3067\u3059\u3002\n\n```c:include/linux/pagemap.h\n\nstatic inline pgoff_t linear_page_index(struct vm_area_struct *vma,\n\t\t\t\t\tunsigned long address)\n{\n\tpgoff_t pgoff;\n\tif (unlikely(is_vm_hugetlb_page(vma)))\n\t\treturn linear_hugepage_index(vma, address);\n\t/* vm map area\u306e\u5148\u982d\u304b\u3089\u306e\u30aa\u30d5\u30bb\u30c3\u30c8\u3092\u30da\u30fc\u30b8\u5358\u4f4d\u3067\u6c42\u3081...*/\n\tpgoff = (address - vma->vm_start) >> PAGE_SHIFT;\n\t/* \n         * \u3048\u3001\u3053\u306evm_pgoff\u306f\u4f55\u8005\uff1fvm_map_area\u5185\u306e\u30aa\u30d5\u30bb\u30c3\u30c8\u3092\n         * \u6c42\u3081\u305f\u3044\u306e\u306a\u3089\u3001\u3055\u3089\u306b\u4e0b\u99c4\u3092\u5c65\u304b\u305b\u308b\u5fc5\u8981\u306f\u3042\u308b\u306e\uff1f\n         * \u305d\u3082\u305d\u3082vm_pgoff\u306f\u4f55\uff1f\n         */\n\tpgoff += vma->vm_pgoff;\n\treturn pgoff >> (PAGE_CACHE_SHIFT - PAGE_SHIFT);\n}\n```\n\nvm_pgoffset\u304c\u3088\u304f\u308f\u304b\u3089\u3093\u306e\u3067grep\u3059\u308b\u3068\u3001\u4ee5\u4e0b\u306e\u95a2\u6570\u304c\u305d\u306e\u7406\u89e3\u306e\u52a9\u3051\u306b\u306a\u308a\u305d\u3046\u3067\u3059\u3002\n\n```c:mm/mmap.c\n\n/* \u3053\u308c\u304c\u304a\u305d\u3089\u304f\u3001anonymous\u306a\u5834\u5408\u306epg_off */\nint insert_vm_struct(struct mm_struct *mm, struct vm_area_struct *vma)\n{\n\tstruct vm_area_struct *prev;\n\tstruct rb_node **rb_link, *rb_parent;\n\n\t/*\n\t * The vm_pgoff of a purely anonymous vma should be irrelevant\n\t * until its first write fault, when page's anon_vma and index\n\t * are set.  But now set the vm_pgoff it will almost certainly\n\t * end up with (unless mremap moves it elsewhere before that\n\t * first wfault), so /proc/pid/maps tells a consistent story.\n\t *\n\t * By setting it to reflect the virtual start address of the\n\t * vma, merges and splits can happen in a seamless way, just\n\t * using the existing file pgoff checks and manipulations.\n\t * Similarly in do_mmap_pgoff and in do_brk.\n\t */\n\tif (!vma->vm_file) {\n\t\tBUG_ON(vma->anon_vma);\n\t\tvma->vm_pgoff = vma->vm_start >> PAGE_SHIFT;\n\t}\n```\nAnnonymous Memory\u306e\u5834\u5408\u306f\u3001vm_pgoff\u306b\u305d\u306evma\u306e\u5148\u982d\u30a2\u30c9\u30ec\u30b9\u3092\u30da\u30fc\u30b8\u5358\u4f4d\u306b\u4e38\u3081\u305f\u5024\u304c\u683c\u7d0d\u3055\u308c\u308b\u3088\u3046\u3067\u3059\u3002\u7d50\u69cb\u30b3\u30e1\u30f3\u30c8\u3082\u8a73\u3057\u304f\u66f8\u3044\u3066\u3042\u308b\u306e\u3067\u30a4\u30e1\u30fc\u30b8\u304c\u3067\u304d\u307e\u3059\u3002\n\n\u3053\u3053\u307e\u3067\u3092\u8aad\u3080\u3068\u3001page\u69cb\u9020\u4f53\u304b\u3089\u305d\u308c\u306b\u5bfe\u5fdc\u3057\u305f\u4eee\u60f3\u30a2\u30c9\u30ec\u30b9\u3092\u53d6\u5f97\u3059\u308b\u3053\u3068\u3068\u3001\u305d\u306e\u9006\u3092\u3069\u306e\u3088\u3046\u306b\u3059\u308c\u3070\u3088\u3044\u304b\u304c\u898b\u3048\u3066\u304d\u307e\u3059\u3002\n\n\u3057\u304b\u3057\u3001\u7269\u7406\u30a2\u30c9\u30ec\u30b9\u3092Linux\u3067\u306f\u3069\u3046\u3084\u3063\u3066\u6271\u3063\u3066\u3044\u308b\u306e\u3067\u3057\u3087\u3046\u304b\uff1f\n\u4f8b\u3048\u3070\u3001\u4eee\u60f3\u30a2\u30c9\u30ec\u30b9\u304b\u3089\u7269\u7406\u30a2\u30c9\u30ec\u30b9\u3092\u5f97\u308b\u3001\u30da\u30fc\u30b8\u69cb\u9020\u4f53\u304b\u3089\u305d\u308c\u304c\u6307\u3057\u3066\u3044\u308b\u7269\u7406\u30a2\u30c9\u30ec\u30b9\u3092\u5f97\u308b\u65b9\u6cd5\u304c\u4eca\u3072\u3068\u3064\u898b\u3048\u307e\u305b\u3093\u3002\n\n\u3053\u3053\u3044\u3089\u306e\u7591\u554f\u3092\u3092\u6b21\u56de\u4ee5\u964d\u898b\u3066\u3044\u304d\u305f\u3044\u3068\u601d\u3044\u307e\u3059\u3002\n"}