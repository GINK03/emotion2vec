{"context": "\u968f\u5206\u524d\u306b\u4f5c\u3063\u305f\u306e\u3067\n\u89e3\u8aac\u304c\u3067\u304d\u307e\u305b\u3093\u304c\u30fb\u30fb\u30fb\nMAZDA\u30ed\u30fc\u30bf\u30ea\u30fc\u30a8\u30f3\u30b8\u30f3\u306e\u4ed5\u7d44\u307f\u306e\u30b9\u30af\u30ea\u30fc\u30f3\u30bb\u30fc\u30d0\u30fc\u3092\u4f5c\u3063\u3066\u307f\u307e\u3057\u305f\u3002\n\u30b3\u30d4\u30da\u3067\u4f5c\u308c\u307e\u3059\u3002\n\nroter.pde\nint rt_cx;    //rotery center x\nint rt_cy;    //rotery center y\n\nint base_r;\nint ig_r;    //inner gear radius\nint st_r;    //stationally gear radius\nint di_r;    //difference between ig_r and st_r\n\nfloat rot_cen_posx,rot_cen_posy;  //rotation center point\n\n\nfloat base_rt=1;  //base rotatetion degree volume\nfloat now_rt;    //now rotation degree\n\nfloat r;\n\nfloat pi=3.14159265358979;\n\nint i;\n\nfloat dw,dh,smer;      //smer=smaller\n\nint s;\nint m;\nint h;\nString t;\n\nvoid setup(){\n  dw=displayWidth;\n  dh=displayHeight;\n\n  if(dw>=dh){\n    smer=dh;\n    base_r=(int) (smer/13.5);\n\n    ig_r=base_r*3;  st_r=base_r*2; di_r=base_r;\n    r=7.5*base_r;\n    now_rt=0;\n    rt_cx=displayWidth/2-st_r; rt_cy=displayHeight/2-st_r;\n  }\n\n  else if(dw<dh){\n    smer=dw;\n    base_r=(int) (smer/13.5);\n\n    ig_r=base_r*3;  st_r=base_r*2; di_r=base_r;\n    r=7.5*base_r;\n    now_rt=0;\n    rt_cx=displayWidth/2-st_r; rt_cy=displayHeight/2-st_r;\n  }\n\n  size(displayWidth,displayHeight);\n  background(0);\n  frameRate(60);\n  noFill();\n\n\n\n\n}\n\nvoid draw(){\n\n\n\n  rtt();\n\n  s = second();\n  m = minute();\n  h = hour();\n  t = nf(h, 2) + \":\" + nf(m, 2) + \":\" + nf(s, 2);\n  text(t, dw-(smer/18)*5,dh-(smer/18)-20, (smer/18)*6, (smer/18)+20);\n\n}\n\nvoid rtt()\n{\n  background(0);\n  noFill();\n  strokeWeight(4);\n  stroke(#FFFFFF);\n\n  rot_cen_posx = rt_cx;\n  rot_cen_posy = rt_cy;\n  now_rt+=(base_rt*3);\n\n\n\n  ellipse(rt_cx+st_r,rt_cy+st_r,st_r*2,st_r*2);    //stationally gear\n  ellipse(rt_cx+st_r+di_r*cos((now_rt*3)*pi/180) , rt_cy+st_r+di_r*sin((now_rt*3)*pi/180) , ig_r*2 , ig_r*2);    //inner gear\n  ellipse(rt_cx+st_r , rt_cy+st_r , di_r*2 , di_r*2 );    //excentric gear\n\n\n  arc(rt_cx+st_r+di_r*cos((now_rt*3)*pi/180)+r*cos((now_rt+240)*pi/180) , rt_cy+st_r+di_r*sin((now_rt*3)*pi/180)+r*sin((now_rt+240)*pi/180) , r*cos(30*pi/180)*4, r*cos(30*pi/180)*4, ((now_rt+30)/180)*pi , ((now_rt+90)/180)*pi);    //roter line 1\n  arc(rt_cx+st_r+di_r*cos((now_rt*3)*pi/180)+r*cos((now_rt+0)*pi/180) , rt_cy+st_r+di_r*sin((now_rt*3)*pi/180)+r*sin((now_rt+0)*pi/180) , r*cos(30*pi/180)*4, r*cos(30*pi/180)*4, ((now_rt+150)/180)*pi , ((now_rt+210)/180)*pi);    //roter line 1\n  arc(rt_cx+st_r+di_r*cos((now_rt*3)*pi/180)+r*cos((now_rt+120)*pi/180) , rt_cy+st_r+di_r*sin((now_rt*3)*pi/180)+r*sin((now_rt+120)*pi/180) , r*cos(30*pi/180)*4, r*cos(30*pi/180)*4, ((now_rt+270)/180)*pi , ((now_rt+330)/180)*pi);    //roter line 1\n\n  i=0;\n\n  while(i<1080){        //roter housing\n    point(rt_cx+st_r+di_r*cos((i)*pi/180)+r*cos((i)*pi/540) , rt_cy+st_r+di_r*sin(i*pi/180)+r*sin((i)*pi/540));\n    i++;\n  }\n}\n\n\n\u8a73\u3057\u304f\u306f\n\u5c71\u672c\u30ef\u30fc\u30eb\u30c9\nhttp://yamatyuu.net/\nhttp://yamatyuu.net/car/new_engin/rota.html\n\u306b\u8f09\u3063\u3066\u3044\u307e\u3059\n\u968f\u5206\u524d\u306b\u4f5c\u3063\u305f\u306e\u3067\n\u89e3\u8aac\u304c\u3067\u304d\u307e\u305b\u3093\u304c\u30fb\u30fb\u30fb\n\n\nMAZDA\u30ed\u30fc\u30bf\u30ea\u30fc\u30a8\u30f3\u30b8\u30f3\u306e\u4ed5\u7d44\u307f\u306e\u30b9\u30af\u30ea\u30fc\u30f3\u30bb\u30fc\u30d0\u30fc\u3092\u4f5c\u3063\u3066\u307f\u307e\u3057\u305f\u3002\n\n\u30b3\u30d4\u30da\u3067\u4f5c\u308c\u307e\u3059\u3002\n\n```processing:roter.pde\nint rt_cx;    //rotery center x\nint rt_cy;    //rotery center y\n\nint base_r;\nint ig_r;    //inner gear radius\nint st_r;    //stationally gear radius\nint di_r;    //difference between ig_r and st_r\n\nfloat rot_cen_posx,rot_cen_posy;  //rotation center point\n\n\nfloat base_rt=1;  //base rotatetion degree volume\nfloat now_rt;    //now rotation degree\n\nfloat r;\n\nfloat pi=3.14159265358979;\n\nint i;\n\nfloat dw,dh,smer;      //smer=smaller\n\nint s;\nint m;\nint h;\nString t;\n\nvoid setup(){\n  dw=displayWidth;\n  dh=displayHeight;\n  \n  if(dw>=dh){\n    smer=dh;\n    base_r=(int) (smer/13.5);\n    \n    ig_r=base_r*3;  st_r=base_r*2; di_r=base_r;\n    r=7.5*base_r;\n    now_rt=0;\n    rt_cx=displayWidth/2-st_r; rt_cy=displayHeight/2-st_r;\n  }\n  \n  else if(dw<dh){\n    smer=dw;\n    base_r=(int) (smer/13.5);\n    \n    ig_r=base_r*3;  st_r=base_r*2; di_r=base_r;\n    r=7.5*base_r;\n    now_rt=0;\n    rt_cx=displayWidth/2-st_r; rt_cy=displayHeight/2-st_r;\n  }\n  \n  size(displayWidth,displayHeight);\n  background(0);\n  frameRate(60);\n  noFill();\n  \n  \n  \n  \n}\n\nvoid draw(){\n  \n  \n  \n  rtt();\n  \n  s = second();\n  m = minute();\n  h = hour();\n  t = nf(h, 2) + \":\" + nf(m, 2) + \":\" + nf(s, 2);\n  text(t, dw-(smer/18)*5,dh-(smer/18)-20, (smer/18)*6, (smer/18)+20);\n  \n}\n\nvoid rtt()\n{\n  background(0);\n  noFill();\n  strokeWeight(4);\n  stroke(#FFFFFF);\n  \n  rot_cen_posx = rt_cx;\n  rot_cen_posy = rt_cy;\n  now_rt+=(base_rt*3);\n  \n  \n  \n  ellipse(rt_cx+st_r,rt_cy+st_r,st_r*2,st_r*2);    //stationally gear\n  ellipse(rt_cx+st_r+di_r*cos((now_rt*3)*pi/180) , rt_cy+st_r+di_r*sin((now_rt*3)*pi/180) , ig_r*2 , ig_r*2);    //inner gear\n  ellipse(rt_cx+st_r , rt_cy+st_r , di_r*2 , di_r*2 );    //excentric gear\n  \n  \n  arc(rt_cx+st_r+di_r*cos((now_rt*3)*pi/180)+r*cos((now_rt+240)*pi/180) , rt_cy+st_r+di_r*sin((now_rt*3)*pi/180)+r*sin((now_rt+240)*pi/180) , r*cos(30*pi/180)*4, r*cos(30*pi/180)*4, ((now_rt+30)/180)*pi , ((now_rt+90)/180)*pi);    //roter line 1\n  arc(rt_cx+st_r+di_r*cos((now_rt*3)*pi/180)+r*cos((now_rt+0)*pi/180) , rt_cy+st_r+di_r*sin((now_rt*3)*pi/180)+r*sin((now_rt+0)*pi/180) , r*cos(30*pi/180)*4, r*cos(30*pi/180)*4, ((now_rt+150)/180)*pi , ((now_rt+210)/180)*pi);    //roter line 1\n  arc(rt_cx+st_r+di_r*cos((now_rt*3)*pi/180)+r*cos((now_rt+120)*pi/180) , rt_cy+st_r+di_r*sin((now_rt*3)*pi/180)+r*sin((now_rt+120)*pi/180) , r*cos(30*pi/180)*4, r*cos(30*pi/180)*4, ((now_rt+270)/180)*pi , ((now_rt+330)/180)*pi);    //roter line 1\n  \n  i=0;\n  \n  while(i<1080){        //roter housing\n    point(rt_cx+st_r+di_r*cos((i)*pi/180)+r*cos((i)*pi/540) , rt_cy+st_r+di_r*sin(i*pi/180)+r*sin((i)*pi/540));\n    i++;\n  }\n}\n```\n\n\u8a73\u3057\u304f\u306f\n\u5c71\u672c\u30ef\u30fc\u30eb\u30c9\nhttp://yamatyuu.net/\nhttp://yamatyuu.net/car/new_engin/rota.html\n\u306b\u8f09\u3063\u3066\u3044\u307e\u3059\n", "tags": ["processing", "Java", "Windows"]}