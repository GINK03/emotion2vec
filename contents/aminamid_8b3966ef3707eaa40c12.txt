{"tags": ["Python2.6", "JSON", "YAML"], "context": " More than 1 year has passed since last update.\n\n\u6982\u8981\n\u30b3\u30de\u30f3\u30c9\u30e9\u30a4\u30f3\u304b\u3089\u3001json \u307e\u305f\u306fyaml\u3092\u8272\u4ed8\u304d\u3067pretty print\u3059\u308b\u3002\n\u307e\u305f\u3001python\u306e\u30aa\u30d6\u30b8\u30a7\u30af\u30c8\u306e\u4e00\u90e8(basestring, int, long, float, dict, list\u3068\u3001__dict__\u3092\u6301\u3063\u3066\u308bobject)\u3092\u8272\u4ed8\u3051\u3067\u8868\u793a\u3059\u308b\u3053\u3068\u304c\u3067\u304d\u308b\u3002\n\n\u30b3\u30de\u30f3\u30c9\u30e9\u30a4\u30f3\u304b\u3089\n# json\n$ echo '{ \"name\": \"pp.py\", \"list\": [ 1, 2, 3, \"Da!\" ] }' | pp.py\n\n#yaml\n$ echo '{ name: pp.py, list: [ 1, 2, 3, Da! ] }' | pp.py\n\n\n\n\u30e2\u30b8\u30e5\u30fc\u30eb\u3068\u3057\u3066\n>>> import pp\n>>> pp.pprint({ \"name\": \"pp.py\", \"list\": [ 1, 2, 3, \"Da!\" ] })\n{\n  list: [ 1, 2, 3, \"Da!\", ],\n  name: \"pp.py\",\n}\n\n\n\nlogging\u306b\u51fa\u3059\u5834\u5408\u306fpprintf\n>>> import pp\n>>> import logging\n>>> logging.basicConfig()\n>>> logging.warning( pp.pprintf( object ) )\n\n\n\n\u30bd\u30fc\u30b9\n\npp.py\n#!/bin/env python\n# -*- coding: utf-8 -*-\n\nclass color:\n    BLUE = '\\033[1;34m'\n    BLUEL = '\\033[0;34m'\n    GREEN = '\\033[1;32m'\n    GREENL = '\\033[0;32m'\n    CYAN = '\\033[1;36m'\n    CYANL = '\\033[0;36m'\n    RED = '\\033[1;31m'\n    REDL = '\\033[0;31m'\n    PURPLE = '\\033[1;35m'\n    PURPLEL = '\\033[0;35m'\n    YELLOW = '\\033[1;33m'\n    BROWN = '\\033[0;33m'\n    WHITE = '\\033[1;37m'\n    GRAYL = '\\033[0;37m'\n    GRAYD = '\\033[1;30m'\n    BLACK = '\\033[0;30m'\n    ENDC = '\\033[0m'\n\ndef pretty_convert(obj):\n    if isinstance(obj, (float)):\n        return u'{1}{2}{0}'.format(color.ENDC, color.PURPLEL, obj)\n    elif isinstance(obj, ( bool )):\n        return u'{1}{2}{0}'.format(color.ENDC, color.CYAN, obj)\n    elif isinstance(obj, ( int, long, complex )):\n        return u'{1}{2}{0}'.format(color.ENDC, color.BLUE, obj)\n    elif isinstance(obj, ( unicode )):\n        return u'{1}\"{0}{2}{3}{0}{1}\"{0}'.format(color.ENDC, color.REDL, color.RED, obj)\n    elif isinstance(obj, ( str )):\n        return u'{1}\"{0}{2}{3}{0}{1}\"{0}'.format(color.ENDC, color.REDL, color.RED, unicode(obj,'utf-8'))\n    elif isinstance(obj, ( dict )):\n        return dict((u'{1}{2}:{0}'.format(color.ENDC, color.YELLOW,k), pretty_convert(v)) for k, v in obj.items())\n    elif isinstance(obj, (list, tuple)):\n        return map(pretty_convert, obj)\n    elif isinstance(obj, type(None)):\n        return 'None'\n    elif hasattr(obj, '__dict__') :\n        return dict((u'{1}{2}:{0}'.format(color.ENDC, color.YELLOW,k), pretty_convert(v)) for k, v in obj.__dict__.items())\n    else:\n        return '<pp: cannot decode>'\n\ndef walk_obj(buf, obj, indent_num=2, depth=0, eol='', wrap_len=60, wrap_total=100, lf='\\n'):\n    indent = ' '*indent_num*depth\n    buf.write(u'{0}'.format(eol if not eol else eol+indent) )\n    if isinstance(obj, (basestring, int, float, complex)):\n        buf.write(u'{0}'.format(obj).replace(lf, '{0}{1} '.format(lf, indent)) )\n    elif isinstance(obj, ( dict )):\n        if not obj:\n            buf.write('{}')\n            return\n        eol, eol_org = lf, eol\n        buf.write('{ ')\n        for key in sorted(obj.keys()):\n            buf.write(u'{0}{1}{2}{3} '.format(eol, indent, ' '*indent_num, key))\n            walk_obj(buf=buf, obj=obj[key], indent_num=indent_num, depth=depth+1, eol='', wrap_len=wrap_len, lf=lf )\n            buf.write(',')\n        buf.write('{0}}}'.format(eol if not eol else eol+indent) )\n        eol=eol_org\n    elif isinstance(obj, (list, tuple)):\n        if not obj:\n            buf.write('[]')\n            return\n        eol_org, indent_org = eol, indent\n        for item in obj:\n            if isinstance(item, (list, dict)):\n                eol = lf\n                break\n            else:\n                eol = ''\n                indent = ''\n                continue\n        if max(map(len,obj if obj else \" \" )) > wrap_len or sum(map(len,obj)) > wrap_total:\n            eol = lf\n        buf.write('[ ')\n        for item in obj:\n            walk_obj(buf=buf, obj=item, indent_num=indent_num, depth=depth+1, eol=eol, wrap_len=wrap_len, lf=lf )\n            buf.write(', ')\n        buf.write('{0}]'.format(eol if not eol else eol+indent_org) )\n        eol, indent = eol_org, indent_org\n\ndef pprint(obj, indent=2, b=None, lf='\\n'):\n    if not b:\n        import sys, codecs\n        b = codecs.getwriter('utf_8')(sys.stdout)\n    walk_obj(b, pretty_convert(obj), indent_num=indent)\n    b.write(lf)\n\ndef pprintf(obj, indent=2):\n    from StringIO import StringIO\n    buf=StringIO()\n    walk_obj(buf, pretty_convert(obj), indent_num=indent)\n    return buf.getvalue()\n\n\nif __name__ == '__main__':\n  import sys\n  import codecs\n  import json\n\n  if len(sys.argv) < 2:\n     raw_data = codecs.getreader('utf_8')(sys.stdin).read()\n  else:\n     raw_data = codecs.open(sys.argv[1], 'r', 'utf_8').read()\n\n  indent = 2 if len(sys.argv) <3 else int(sys.argv[2])\n\n  parsed_data = None\n  try:\n      parsed_data = json.loads(raw_data)\n  except ValueError as e1:\n      #print e1\n      try:\n          import yaml\n          parsed_data = yaml.load(raw_data)\n      except yaml.scanner.ScannerError as e2:\n          #print e2\n          pass\n  if not parsed_data:\n      sys.exit(2)\n\n  pprint(parsed_data, indent)\n  b = codecs.getwriter('utf_8')(sys.stdout)\n\n\nhttps://github.com/aminamid/pp\n\n# \u6982\u8981\n\n\u30b3\u30de\u30f3\u30c9\u30e9\u30a4\u30f3\u304b\u3089\u3001json \u307e\u305f\u306fyaml\u3092\u8272\u4ed8\u304d\u3067pretty print\u3059\u308b\u3002\n\n\u307e\u305f\u3001python\u306e\u30aa\u30d6\u30b8\u30a7\u30af\u30c8\u306e\u4e00\u90e8(basestring, int, long, float, dict, list\u3068\u3001\\_\\_dict\\_\\_\u3092\u6301\u3063\u3066\u308bobject)\u3092\u8272\u4ed8\u3051\u3067\u8868\u793a\u3059\u308b\u3053\u3068\u304c\u3067\u304d\u308b\u3002\n\n## \u30b3\u30de\u30f3\u30c9\u30e9\u30a4\u30f3\u304b\u3089\n\n```\n# json\n$ echo '{ \"name\": \"pp.py\", \"list\": [ 1, 2, 3, \"Da!\" ] }' | pp.py\n\n#yaml\n$ echo '{ name: pp.py, list: [ 1, 2, 3, Da! ] }' | pp.py\n```\n\n![pp_cmdline.png](https://qiita-image-store.s3.amazonaws.com/0/38680/65fe3a1a-b91b-7b64-e4d1-bcd45d6b3d9b.png)\n\n## \u30e2\u30b8\u30e5\u30fc\u30eb\u3068\u3057\u3066\n\n```\n>>> import pp\n>>> pp.pprint({ \"name\": \"pp.py\", \"list\": [ 1, 2, 3, \"Da!\" ] })\n{\n  list: [ 1, 2, 3, \"Da!\", ],\n  name: \"pp.py\",\n}\n```\n\n![pp_module.png](https://qiita-image-store.s3.amazonaws.com/0/38680/6dbe387f-2aa6-cc0b-8270-c8fcf8ba73d0.png)\n\n## logging\u306b\u51fa\u3059\u5834\u5408\u306fpprintf\n\n```\n>>> import pp\n>>> import logging\n>>> logging.basicConfig()\n>>> logging.warning( pp.pprintf( object ) )\n```\n\n![pp_logging.png](https://qiita-image-store.s3.amazonaws.com/0/38680/8dc1b3ae-cf5a-8e60-b707-06ffdd8f7733.png)\n\n# \u30bd\u30fc\u30b9\n\n```python:pp.py\n#!/bin/env python\n# -*- coding: utf-8 -*-\n\nclass color:\n    BLUE = '\\033[1;34m'\n    BLUEL = '\\033[0;34m'\n    GREEN = '\\033[1;32m'\n    GREENL = '\\033[0;32m'\n    CYAN = '\\033[1;36m'\n    CYANL = '\\033[0;36m'\n    RED = '\\033[1;31m'\n    REDL = '\\033[0;31m'\n    PURPLE = '\\033[1;35m'\n    PURPLEL = '\\033[0;35m'\n    YELLOW = '\\033[1;33m'\n    BROWN = '\\033[0;33m'\n    WHITE = '\\033[1;37m'\n    GRAYL = '\\033[0;37m'\n    GRAYD = '\\033[1;30m'\n    BLACK = '\\033[0;30m'\n    ENDC = '\\033[0m'\n\ndef pretty_convert(obj):\n    if isinstance(obj, (float)):\n        return u'{1}{2}{0}'.format(color.ENDC, color.PURPLEL, obj)\n    elif isinstance(obj, ( bool )):\n        return u'{1}{2}{0}'.format(color.ENDC, color.CYAN, obj)\n    elif isinstance(obj, ( int, long, complex )):\n        return u'{1}{2}{0}'.format(color.ENDC, color.BLUE, obj)\n    elif isinstance(obj, ( unicode )):\n        return u'{1}\"{0}{2}{3}{0}{1}\"{0}'.format(color.ENDC, color.REDL, color.RED, obj)\n    elif isinstance(obj, ( str )):\n        return u'{1}\"{0}{2}{3}{0}{1}\"{0}'.format(color.ENDC, color.REDL, color.RED, unicode(obj,'utf-8'))\n    elif isinstance(obj, ( dict )):\n        return dict((u'{1}{2}:{0}'.format(color.ENDC, color.YELLOW,k), pretty_convert(v)) for k, v in obj.items())\n    elif isinstance(obj, (list, tuple)):\n        return map(pretty_convert, obj)\n    elif isinstance(obj, type(None)):\n        return 'None'\n    elif hasattr(obj, '__dict__') :\n        return dict((u'{1}{2}:{0}'.format(color.ENDC, color.YELLOW,k), pretty_convert(v)) for k, v in obj.__dict__.items())\n    else:\n        return '<pp: cannot decode>'\n\ndef walk_obj(buf, obj, indent_num=2, depth=0, eol='', wrap_len=60, wrap_total=100, lf='\\n'):\n    indent = ' '*indent_num*depth\n    buf.write(u'{0}'.format(eol if not eol else eol+indent) )\n    if isinstance(obj, (basestring, int, float, complex)):\n        buf.write(u'{0}'.format(obj).replace(lf, '{0}{1} '.format(lf, indent)) )\n    elif isinstance(obj, ( dict )):\n        if not obj:\n            buf.write('{}')\n            return\n        eol, eol_org = lf, eol\n        buf.write('{ ')\n        for key in sorted(obj.keys()):\n            buf.write(u'{0}{1}{2}{3} '.format(eol, indent, ' '*indent_num, key))\n            walk_obj(buf=buf, obj=obj[key], indent_num=indent_num, depth=depth+1, eol='', wrap_len=wrap_len, lf=lf )\n            buf.write(',')\n        buf.write('{0}}}'.format(eol if not eol else eol+indent) )\n        eol=eol_org\n    elif isinstance(obj, (list, tuple)):\n        if not obj:\n            buf.write('[]')\n            return\n        eol_org, indent_org = eol, indent\n        for item in obj:\n            if isinstance(item, (list, dict)):\n                eol = lf\n                break\n            else:\n                eol = ''\n                indent = ''\n                continue\n        if max(map(len,obj if obj else \" \" )) > wrap_len or sum(map(len,obj)) > wrap_total:\n            eol = lf\n        buf.write('[ ')\n        for item in obj:\n            walk_obj(buf=buf, obj=item, indent_num=indent_num, depth=depth+1, eol=eol, wrap_len=wrap_len, lf=lf )\n            buf.write(', ')\n        buf.write('{0}]'.format(eol if not eol else eol+indent_org) )\n        eol, indent = eol_org, indent_org\n\ndef pprint(obj, indent=2, b=None, lf='\\n'):\n    if not b:\n        import sys, codecs\n        b = codecs.getwriter('utf_8')(sys.stdout)\n    walk_obj(b, pretty_convert(obj), indent_num=indent)\n    b.write(lf)\n\ndef pprintf(obj, indent=2):\n    from StringIO import StringIO\n    buf=StringIO()\n    walk_obj(buf, pretty_convert(obj), indent_num=indent)\n    return buf.getvalue()\n\n\nif __name__ == '__main__':\n  import sys\n  import codecs\n  import json\n\n  if len(sys.argv) < 2:\n     raw_data = codecs.getreader('utf_8')(sys.stdin).read()\n  else:\n     raw_data = codecs.open(sys.argv[1], 'r', 'utf_8').read()\n\n  indent = 2 if len(sys.argv) <3 else int(sys.argv[2])\n\n  parsed_data = None\n  try:\n      parsed_data = json.loads(raw_data)\n  except ValueError as e1:\n      #print e1\n      try:\n          import yaml\n          parsed_data = yaml.load(raw_data)\n      except yaml.scanner.ScannerError as e2:\n          #print e2\n          pass\n  if not parsed_data:\n      sys.exit(2)\n\n  pprint(parsed_data, indent)\n  b = codecs.getwriter('utf_8')(sys.stdout)\n```\n\n\nhttps://github.com/aminamid/pp\n\n"}