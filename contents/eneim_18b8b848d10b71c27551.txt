{"context": " More than 1 year has passed since last update.\n\n0. tl,dr:\nI created a repo: RVP\nWhere the most important classes are stored in core:\nBaseAdapter.java - will generally support basic RecyclerView#Adapter's behavior. It comes with a RecyclerView's version of OnItemClickListener (I was inspired by AdapterView's interface).\nBaseListAdapter.java - an extend of BaseAdapter, focuses on List of a specific Data type.\nSome examples are included outside, take a look at package fragment and adapter.\n\n1. So we Click Item, but we don't know the good way to listen to that Event\n\n\nProblem and My Opinions: \n\nSince the release of RecyclerView and its childs (Other libraries based on RecyclerView), there are various ways to interaction to item, and there are event more ways to listen to those event. -- My Opinion: The need of a On Item Click Listener thing is obvious, but there's not been a globally good practice (which is good for all cases) already.\nMany Developers keep in mind that RecyclerView is a Updated version of ListView and GridView, so they expect some similar behavior of those Views on RecyclerView. -- My Opinion: this thought is not always true. RecyclerView is a superset of a general AdapterView - the View which requires Adapter to populate its UI. RecyclerView can do a lot more than the legacy AdapterView. Further more, current implementations of OnItemClickListener are trying to mimic the famous AdapterView#setOnItemClickListener() setup, which is generally not that bad, but we should not rely on or try to reproduce it by all means.\n\n\nMy Solution: in short, instead of trying to mimic this setup AdapterView#setOnItemClickListener(), I use RecyclerView$Adapter instead, which will become something like this: MyAdapter#setOnItemClickListener().\n\n\n2. Base classes\ntalk is cheap, so me some codes\n\nBaseAdapter.class\n/**\n * A less abstract Adapter, to simplify RecyclerView#Adapter implementation\n */\npublic abstract class BaseAdapter<VH extends BaseAdapter.ViewHolder>\n    extends RecyclerView.Adapter<VH> {\n\n  /**\n   * This custom onClick event listener should be set by the Adapter\n   */\n  protected OnItemClickListener mOnItemClickListener;\n\n  public void setOnItemClickListener(OnItemClickListener onItemClickListener) {\n    this.mOnItemClickListener = onItemClickListener;\n  }\n\n  /**\n   * An abstract ViewHolder\n   */\n  public abstract static class ViewHolder extends RecyclerView.ViewHolder {\n\n    public ViewHolder(@NonNull View itemView) {\n      super(itemView);\n    }\n\n    /**\n     * This method is supposed to be override every time. For example, a view holder holds more\n     * than 2 views, and Client want to listen to the click event on each of them.\n     * <p/>\n     * By default, the main #itemView will receive the click event.\n     * <p/>\n     * !IMPORTANT: This method is used optionally.\n     *\n     * @param listener to listen to Click event\n     */\n    // NOTE: Long name, I know\n    public void setOnViewHolderClickListener(View.OnClickListener listener) {\n      itemView.setOnClickListener(listener);\n    }\n  }\n\n  public interface OnItemClickListener {\n\n    /**\n     * Interact with RecyclerView's item on click event\n     *\n     * @param adapter         who holds data\n     * @param viewHolder      the #ViewHolder who receives click event\n     * @param view            the view under the click event\n     * @param adapterPosition position of clicked item in adapter\n     * @param itemId          retrieve from\n     *                        {@link android.support.v7.widget.RecyclerView.Adapter#getItemId(int)}\n     */\n    void onItemClick(BaseAdapter adapter, ViewHolder viewHolder, View view,\n                     int adapterPosition, long itemId);\n  }\n}\n\n\nJust a simple extends of RecyclerView$Adapter, where I define a kind of OnItemClickListener interface with the main character: onItemClick method. This method takes the Adapter as a neccessary member, where we could retrieve data and more. !NOTE: Replacing Adapter by RecyclerView it self is Ok, since we could get Adapter from it. But keep in mind that a RecyclerView holds a lot more memory than an Adapter.\nHere we also have a simple implementation of ViewHolder, which supports seting the interaction event setup. The default setup will be the Click event on ViewHolder#itemView, but Client could (and should) override this to provide more expected behaviors (Take a look at my Sample classes).\nThis Based setup will struct a vision for Client to implement it own Click listener on Children classes.\n\nBaseListAdapter.class\n/**\n * @param <T> This Adapter is specified to use with List of Objects of type T\n */\npublic abstract class BaseListAdapter<T> extends BaseAdapter<BaseListAdapter.ViewHolder<T>> {\n\n  /**\n   * This Adapter must support retrieving item(s)\n   * <p/>\n   * !IMPORTANT General Adapter could support various Types of Object, so we must not force it to\n   * return a single Type of object. This BaseListAdapter was created to support those cases.\n   *\n   * @param position of the item we want to get\n   * @return expected Item at a position\n   */\n  public abstract T getItem(int position);\n\n  /**\n   * If Client implement this method, He must call super.onBindViewHolder for expected\n   * behaviors.\n   *\n   * @param holder\n   * @param position\n   */\n  @CallSuper\n  @Override public void onBindViewHolder(ViewHolder<T> holder, int position) {\n    T item = getItem(position);\n    if (item != null) {\n      holder.bindInternal(item);\n    }\n  }\n\n  /**\n   * For now we don't support this method.\n   *\n   * @param holder\n   * @param position\n   * @param payloads\n   */\n  /*hide*/\n  @Override\n  public void onBindViewHolder(ViewHolder<T> holder, int position, List<Object> payloads) {\n    super.onBindViewHolder(holder, position, payloads);\n  }\n\n  /**\n   * General abstract ViewHolder to support specific Data type\n   *\n   * @param <T> expected Data Type\n   */\n  public abstract static class ViewHolder<T> extends BaseAdapter.ViewHolder {\n\n    // I think it's not bad to have an shallow copy of current Data\n    protected T mItem;\n\n    public ViewHolder(@NonNull View itemView) {\n      super(itemView);\n    }\n\n    // This method will always be called by Adapter\n    void bindInternal(T item) {\n      mItem = item;\n      bind(item);\n    }\n\n    // Client then update its ViewHolder's appearance here\n    public abstract void bind(T item);\n  }\n}\n\n\nThis class is an simple extension of the BaseAdapter above, in respect to android.widget.ArrayAdapter. BaseListAdapter suppose to support a specific Data Type T, come along with a special ViewHolder class to ensure that each ViewHolder will represent an Object of type T. ViewHolder#bindInternal are called to make sure that a ViewHolder instance hold its mItem for later use. This implementation is Optional.\n2 Base Classes above are how I prepare the base for any further interaction implementation. In fact, the same implementation could be done to support OnItemLongClickListener.\n\n3. OnItemClick in action\nI prepared 2 Fragment, who hold 2 lists: a Simple list of String and a more complicated list of Cheese (borrow the idea, some pieces of code and resources from Cheesesquare).\nLet's start from something complicated :D.\n\nCheeseListFragment and CheeseListAdapter: \n\nAn implementation of ViewHolder for a Cheese list:\n\nCheeseListAdapter$ViewHolder.class\npublic static class ViewHolder extends BaseListAdapter.ViewHolder<Cheeses> {\n\n    // A ViewHolder expects a UI Layout, so make it static here\n    static final int LAYOUT_RES = R.layout.list_item;\n\n    public final ImageView mImageView;\n    public final TextView mTextView;\n\n    public ViewHolder(View view) {\n      super(view);\n      mImageView = (ImageView) view.findViewById(R.id.item_icon);\n      mTextView = (TextView) view.findViewById(R.id.item_name);\n    }\n\n    @Override public void bind(Cheeses item) {\n      mTextView.setText(item.getName());\n      Picasso.with(itemView.getContext())\n          .load(item.getIconRes())\n          .fit().centerCrop()\n          .into(mImageView);\n    }\n\n    // !IMPORTANT Since we accept click event on 2 different views, we must delegate them here.\n    @Override public void setOnViewHolderClickListener(View.OnClickListener listener) {\n      mImageView.setOnClickListener(listener);\n      itemView.setOnClickListener(listener);\n    }\n  }\n\n\nThis ViewHolder is exactly the same as Cheesesquare's list view holder. But it provides better interaction: click on Cheese's image and click on the item's cell. To support that, we simply override #setOnViewHolderClickListener and setup the normal OnClick event for whatever Views from which we want to listen to click event. Here I setup for my mImageView and the itemView (which holds mImageView as its child).\n\nCheeseListAdapter.class\n  // Just because I like this number\n  private static final int LIST_SIZE = 23;\n\n  private static final List<Cheeses> sItems = getRandomSublist(Cheeses.sCheeseStrings, LIST_SIZE);\n\n  @Override public Cheeses getItem(int position) {\n    return sItems.get(position);\n  }\n\n  @Override\n  public BaseListAdapter.ViewHolder<Cheeses> onCreateViewHolder(ViewGroup parent, int viewType) {\n    View view = LayoutInflater.from(parent.getContext())\n        .inflate(ViewHolder.LAYOUT_RES, parent, false);\n    final ViewHolder viewHolder = new ViewHolder(view);\n    // setup Click event listener here\n    viewHolder.setOnViewHolderClickListener(new View.OnClickListener() {\n      @Override public void onClick(View v) {\n        if (CheeseListAdapter.this.mOnItemClickListener != null) {\n          int adapterPosition = viewHolder.getAdapterPosition();\n          // get this from Android Summit Video\n          if (adapterPosition != RecyclerView.NO_POSITION) {\n            CheeseListAdapter.this.mOnItemClickListener.onItemClick(\n                CheeseListAdapter.this, viewHolder, v, adapterPosition, getItemId(adapterPosition)\n            );\n          }\n        }\n      }\n    });\n    return viewHolder;\n  }\n\n  /**\n   * Customized Click event listener\n   */\n  public abstract static class OnCheeseClickListener implements OnItemClickListener {\n\n    public abstract void onIconClick(View iconView, Cheeses cheese);\n\n    public abstract void onCheeseClick(View nameView, Cheeses cheese);\n\n    @Override\n    public void onItemClick(BaseAdapter adapter, BaseAdapter.ViewHolder viewHolder,\n                            View view, int adapterPosition, long itemId) {\n      if (adapter instanceof BaseListAdapter) {\n        // we expect a ListAdapter here, since we are using a List Adapter\n        BaseListAdapter listAdapter = (BaseListAdapter) adapter;\n        // so we can get clicked item\n        Cheeses item = (Cheeses) listAdapter.getItem(adapterPosition);\n\n        // Note 1: Casted object maybe null if we're using wrong adapter\n        // Note 2:\n        if (item != null && viewHolder instanceof ViewHolder) {\n          if (view == ((ViewHolder) viewHolder).mImageView) {\n            onIconClick(view, item);\n          } else if (view == ((ViewHolder) viewHolder).itemView) {\n            onCheeseClick(view, item);\n          }\n        }\n      }\n    }\n  }\n\n  @Override public int getItemCount() {\n    return sItems.size();\n  }\n\n  List<Cheeses> getRandomSublist(String[] array, int amount) {\n    ArrayList<Cheeses> list = new ArrayList<>(amount);\n    ... // refer Cheesesquare\n    return list;\n  }\n\n  public static class ViewHolder extends BaseListAdapter.ViewHolder<Cheeses> {\n     ... // above\n  }\n}\n\n\nSo for my custom click listener behavior, I have OnCheeseClickListener which implement BaseAdapter$OnItemClickListener. By that, I could provide custom behavior for each components in each of this list's ViewHolder objects.\nCheeseListAdapter#onCreateViewHolder is where we pass the Click event listener from parent Adapter to its ViewHolder. Inspired from Android Summit 2015 talks, that is where we should do that works, and ViewHolder#getAdapterPosition() is the position we should use to get Data.\nNow, take a look at CheeseListFragment\n\nCheeseListFragment.class\npublic class CheeseListFragment extends Fragment {\n\n  RecyclerView mRecyclerView;\n  RecyclerView.LayoutManager mLayoutManager;\n  CheeseListAdapter mAdapter;\n  /**\n   * My customized click listener. We can directly handle click event from Fragment or Setup\n   * another callback to attach to Host Activity's lifecycle. IMO, Both are good practices.\n   */\n  private CheeseListAdapter.OnCheeseClickListener mClickListener;\n\n  public CheeseListFragment() {\n  }\n\n  public static CheeseListFragment newInstance() {\n    return new CheeseListFragment();\n  }\n\n  @Nullable @Override\n  public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle\n      savedInstanceState) {\n    return inflater.inflate(R.layout.fragment_cheese_list, container, false);\n  }\n\n  @Override public void onViewCreated(View view, Bundle savedInstanceState) {\n    super.onViewCreated(view, savedInstanceState);\n    mRecyclerView = (RecyclerView) view.findViewById(R.id.recycler_view);\n    /*\n      We can try both UI to check if our position works as expected;\n     */\n    // mLayoutManager = new LinearLayoutManager(getContext(), LinearLayoutManager.VERTICAL, false);\n    mLayoutManager = new GridLayoutManager(getContext(), 2, LinearLayoutManager.VERTICAL, false);\n    // a little bit more complicated Grid.\n    GridLayoutManager.SpanSizeLookup spanSizeLookup = new GridLayoutManager.SpanSizeLookup() {\n      @Override public int getSpanSize(int position) {\n        return position % 3 == 2 ? 2 : 1;\n      }\n    };\n\n    ((GridLayoutManager) mLayoutManager).setSpanSizeLookup(spanSizeLookup);\n\n    mRecyclerView.setLayoutManager(mLayoutManager);\n\n    mAdapter = new CheeseListAdapter();\n    mRecyclerView.setAdapter(mAdapter);\n\n    mClickListener = new CheeseListAdapter.OnCheeseClickListener() {\n      @Override public void onIconClick(View iconView, Cheeses cheese) {\n        if (getView() != null) {\n          Snackbar.make(getView(), \"Icon clicked: \" + cheese.getName(), Snackbar.LENGTH_LONG)\n              .show();\n        }\n      }\n\n      @Override public void onCheeseClick(View nameView, Cheeses cheese) {\n        Intent intent = new Intent(getContext(), CheeseDetailActivity.class);\n        intent.putExtra(CheeseDetailActivity.EXTRA_NAME, cheese.getName());\n        startActivity(intent);\n      }\n    };\n\n    mAdapter.setOnItemClickListener(mClickListener);\n  }\n\n  @Override public void onDestroyView() {\n    // This click event is attached to UI behavior, so we should properly release it before all\n    // views are dead.\n    // IMO, Doing this in onDestroyView or onDetach is really depends on how you use your listener.\n    mClickListener = null;\n    super.onDestroyView();\n  }\n}\n\n\nThere's been various practices on how to pass logic to Fragment from Activity. I don't discuss it here. The point here is how we pass that event to our Adapter, which is simply like this:\nCheeseListAdapter.OnCheeseClickListener  mClickListener = new CheeseListAdapter.OnCheeseClickListener() {\n      @Override public void onIconClick(View iconView, Cheeses cheese) {\n        if (getView() != null) {\n          Snackbar.make(getView(), \"Icon clicked: \" + cheese.getName(), Snackbar.LENGTH_LONG)\n              .show();\n        }\n      }\n\n      @Override public void onCheeseClick(View nameView, Cheeses cheese) {\n        Intent intent = new Intent(getContext(), CheeseDetailActivity.class);\n        intent.putExtra(CheeseDetailActivity.EXTRA_NAME, cheese.getName());\n        startActivity(intent);\n      }\n    };\n\n    mAdapter.setOnItemClickListener(mClickListener);\n\nFor the general Activity-Fragment-Callback implementation, we can have an interface from our Fragment, and retrieve its instance by onAttach, I leave it for Client. But it would not be complicated.\nAbove example looks complicated, now we look at a much more simpler Example: A simple String list\n```Java: SimpleListAdapter$ViewHolder.class\npublic static class ViewHolder extends BaseListAdapter.ViewHolder {\n// This is a TextView's layout\nstatic final int LAYOUT_RES = android.R.layout.simple_list_item_1;\n\npublic ViewHolder(@NonNull View itemView) {\n  super(itemView);\n}\n\n@Override public void bind(String item) {\n  // It's safe here\n  ((TextView) itemView).setText(item);\n}\n\n}\n```\nComparing to Cheese list's Viewholder, we have simpler class here, without any setup for On Click event. Because by default, ViewHolder#itemView will handle that event if set (BaseAdapter$ViewHolder#setOnViewHolderClickListener()).\n\nSimpleListAdapter.class\npublic class SimpleListAdapter extends BaseListAdapter<String> {\n\n  List<String> getRandomSublist(String[] array, int amount) {\n    ArrayList<String> list = new ArrayList<>(amount);\n    ... // refer Cheesesquare\n    return list;\n  }\n\n  // Just because I like this number\n  private static final int LIST_SIZE = 23;\n\n  private final List<String> sItems = getRandomSublist(Cheeses.sCheeseStrings, LIST_SIZE);\n\n  @Override public String getItem(int position) {\n    return sItems.get(position);\n  }\n\n  @Override\n  public BaseListAdapter.ViewHolder<String> onCreateViewHolder(ViewGroup parent, int viewType) {\n    View view = LayoutInflater.from(parent.getContext())\n        .inflate(ViewHolder.LAYOUT_RES, parent, false);\n    final ViewHolder viewHolder = new ViewHolder(view);\n    viewHolder.setOnViewHolderClickListener(new View.OnClickListener() {\n      @Override public void onClick(View v) {\n        int adapterPosition = viewHolder.getAdapterPosition();\n        // get this from Android Summit Video\n        if (adapterPosition != RecyclerView.NO_POSITION) {\n          SimpleListAdapter.this.mOnItemClickListener.onItemClick(\n              SimpleListAdapter.this, viewHolder, v, adapterPosition, getItemId(adapterPosition)\n          );\n        }\n      }\n    });\n\n    return viewHolder;\n  }\n\n  @Override public int getItemCount() {\n    return sItems.size();\n  }\n\n  public static class ViewHolder extends BaseListAdapter.ViewHolder<String> {\n    ... // above\n  }\n}\n\n\nSo except for the custom OnCheeseClickListener, this class is the same as CheeseListAdapter, with a little mount of code. The most important part was still the #onCreateViewHolder implementation.\n\nSimpleListFragment.class\npublic class SimpleListFragment extends Fragment {\n\n  public SimpleListFragment() {\n  }\n\n  public static SimpleListFragment newInstance() {\n    return new SimpleListFragment();\n  }\n\n  RecyclerView mRecyclerView;\n  RecyclerView.LayoutManager mLayoutManager;\n  SimpleListAdapter mAdapter;\n  BaseAdapter.OnItemClickListener mClickListener;\n\n  @Nullable @Override\n  public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle\n      savedInstanceState) {\n    return inflater.inflate(R.layout.fragment_cheese_list, container, false);\n  }\n\n  @Override public void onViewCreated(View view, Bundle savedInstanceState) {\n    super.onViewCreated(view, savedInstanceState);\n    mRecyclerView = (RecyclerView) view.findViewById(R.id.recycler_view);\n    mLayoutManager = new LinearLayoutManager(getContext(), LinearLayoutManager.VERTICAL, false);\n    mRecyclerView.setLayoutManager(mLayoutManager);\n\n    mAdapter = new SimpleListAdapter();\n    mRecyclerView.setAdapter(mAdapter);\n\n    mClickListener = new BaseAdapter.OnItemClickListener() {\n      @Override\n      public void onItemClick(BaseAdapter adapter, BaseAdapter.ViewHolder viewHolder, View view,\n                              int adapterPosition, long itemId) {\n        String item = null;\n        if (adapter instanceof SimpleListAdapter) {\n          item = ((SimpleListAdapter) adapter).getItem(adapterPosition);\n        }\n\n        if (item != null) {\n          Intent intent = new Intent(getContext(), CheeseDetailActivity.class);\n          intent.putExtra(CheeseDetailActivity.EXTRA_NAME, item);\n          startActivity(intent);\n        }\n      }\n    };\n\n    mAdapter.setOnItemClickListener(mClickListener);\n  }\n\n  @Override public void onDestroyView() {\n    // This click event is attached to UI behavior, so we should properly release it before all\n    // views are dead.\n    // IMO, Doing this in onDestroyView or onDetach is really depends on how you use your listener.\n    mClickListener = null;\n    super.onDestroyView();\n  }\n}\n\n\nHere we have almost the same structure with CheeseListFragment. And again this is not a bunch of code in my opinion .\n\n4. Conclusion and Future works\nThis is neither a new implementation nor a new Idea. It's just another way to handle the famous click event, created specially for RecyclerView. This is based on one point from Android Summit 2015 talk, where RecyclerView's creator pointed out where should be the place we setup the click event listener. The rest of this project tries to support our common sense of setting up our legacy AdapterView. But it doesn't try to attach on AdapterView point of view, but it goes by the think of RecyclerView: Adapter is where we start everything, RecyclerView will support the hard works. So by this point of view, I hope this implementation could be considered a not bad practices.\nMore works need to be done for more interaction event (long click, for example). And there are more rooms for others NOT BAD RECYCLERVIEW PRACTICES too (At least, I was talking about OnClickListener this time only). So hopefully more practices are coming.\n\n5. Last but not least\nRe: I created a repo: RVP\nThis project is written in plain MVC, so it might not look good or even useful in other design patterns though. So use it at your own risk, and any contribution are welcome.\nThis project follows Google's Java coding style (tl,dr: 2-spaces-indent) :D.\n\n## 0. tl,dr:\nI created a repo: [RVP](https://github.com/eneim/RVP)\nWhere the most important classes are stored in ```core```:\n```BaseAdapter.java``` - will generally support basic RecyclerView#Adapter's behavior. It comes with a RecyclerView's version of OnItemClickListener (I was inspired by AdapterView's interface).\n```BaseListAdapter.java``` - an extend of ```BaseAdapter```, focuses on List of a specific Data type.\nSome examples are included outside, take a look at package ```fragment``` and ```adapter```.\n\n## 1. So we Click Item, but we don't know the good way to listen to that Event\n\n+ Problem and My Opinions: \n\t- Since the release of ```RecyclerView``` and its childs (Other libraries based on ```RecyclerView```), there are various ways to interaction to item, and there are event more ways to listen to those event. -- **My Opinion**: The need of a ```On Item Click Listener``` thing is obvious, but there's not been a globally good practice (which is good for all cases) already.\n\t- Many Developers keep in mind that ```RecyclerView``` is a Updated version of ```ListView``` and ```GridView```, so they expect some similar behavior of those Views on ```RecyclerView```. -- **My Opinion**: this thought is not always true. RecyclerView is a superset of a general ```AdapterView``` - the View which requires Adapter to populate its UI. RecyclerView can do a lot more than the legacy ```AdapterView```. Further more, current implementations of ```OnItemClickListener``` are trying to mimic the famous ```AdapterView#setOnItemClickListener()``` setup, which is generally not that bad, but we should not rely on or try to reproduce it by all means.\n\n+ My Solution: in short, instead of trying to mimic this setup ```AdapterView#setOnItemClickListener()```, I use ```RecyclerView$Adapter``` instead, which will become something like this: ```MyAdapter#setOnItemClickListener()```.\n\n## 2. Base classes\n\n*talk is cheap, so me some codes*\n \n```Java:BaseAdapter.class\n/**\n * A less abstract Adapter, to simplify RecyclerView#Adapter implementation\n */\npublic abstract class BaseAdapter<VH extends BaseAdapter.ViewHolder>\n    extends RecyclerView.Adapter<VH> {\n\n  /**\n   * This custom onClick event listener should be set by the Adapter\n   */\n  protected OnItemClickListener mOnItemClickListener;\n\n  public void setOnItemClickListener(OnItemClickListener onItemClickListener) {\n    this.mOnItemClickListener = onItemClickListener;\n  }\n\n  /**\n   * An abstract ViewHolder\n   */\n  public abstract static class ViewHolder extends RecyclerView.ViewHolder {\n\n    public ViewHolder(@NonNull View itemView) {\n      super(itemView);\n    }\n\n    /**\n     * This method is supposed to be override every time. For example, a view holder holds more\n     * than 2 views, and Client want to listen to the click event on each of them.\n     * <p/>\n     * By default, the main #itemView will receive the click event.\n     * <p/>\n     * !IMPORTANT: This method is used optionally.\n     *\n     * @param listener to listen to Click event\n     */\n    // NOTE: Long name, I know\n    public void setOnViewHolderClickListener(View.OnClickListener listener) {\n      itemView.setOnClickListener(listener);\n    }\n  }\n\n  public interface OnItemClickListener {\n\n    /**\n     * Interact with RecyclerView's item on click event\n     *\n     * @param adapter         who holds data\n     * @param viewHolder      the #ViewHolder who receives click event\n     * @param view            the view under the click event\n     * @param adapterPosition position of clicked item in adapter\n     * @param itemId          retrieve from\n     *                        {@link android.support.v7.widget.RecyclerView.Adapter#getItemId(int)}\n     */\n    void onItemClick(BaseAdapter adapter, ViewHolder viewHolder, View view,\n                     int adapterPosition, long itemId);\n  }\n}\n```\n\nJust a simple extends of ```RecyclerView$Adapter```, where I define a *kind of* OnItemClickListener interface with the main character: ```onItemClick``` method. This method takes the ```Adapter``` as a neccessary member, where we could retrieve data and more. !NOTE: Replacing ```Adapter``` by RecyclerView it self is Ok, since we could get ```Adapter``` from it. But keep in mind that a ```RecyclerView``` holds a lot more memory than an ```Adapter```.\n\nHere we also have a simple implementation of ViewHolder, which supports seting the interaction event setup. The default setup will be the Click event on ```ViewHolder#itemView```, but Client could (and should) override this to provide more expected behaviors (Take a look at my Sample classes).\n\nThis Based setup will struct a vision for Client to implement it own Click listener on Children classes.\n\n```Java:BaseListAdapter.class\n/**\n * @param <T> This Adapter is specified to use with List of Objects of type T\n */\npublic abstract class BaseListAdapter<T> extends BaseAdapter<BaseListAdapter.ViewHolder<T>> {\n\n  /**\n   * This Adapter must support retrieving item(s)\n   * <p/>\n   * !IMPORTANT General Adapter could support various Types of Object, so we must not force it to\n   * return a single Type of object. This BaseListAdapter was created to support those cases.\n   *\n   * @param position of the item we want to get\n   * @return expected Item at a position\n   */\n  public abstract T getItem(int position);\n\n  /**\n   * If Client implement this method, He must call super.onBindViewHolder for expected\n   * behaviors.\n   *\n   * @param holder\n   * @param position\n   */\n  @CallSuper\n  @Override public void onBindViewHolder(ViewHolder<T> holder, int position) {\n    T item = getItem(position);\n    if (item != null) {\n      holder.bindInternal(item);\n    }\n  }\n\n  /**\n   * For now we don't support this method.\n   *\n   * @param holder\n   * @param position\n   * @param payloads\n   */\n  /*hide*/\n  @Override\n  public void onBindViewHolder(ViewHolder<T> holder, int position, List<Object> payloads) {\n    super.onBindViewHolder(holder, position, payloads);\n  }\n\n  /**\n   * General abstract ViewHolder to support specific Data type\n   *\n   * @param <T> expected Data Type\n   */\n  public abstract static class ViewHolder<T> extends BaseAdapter.ViewHolder {\n\n    // I think it's not bad to have an shallow copy of current Data\n    protected T mItem;\n\n    public ViewHolder(@NonNull View itemView) {\n      super(itemView);\n    }\n\n    // This method will always be called by Adapter\n    void bindInternal(T item) {\n      mItem = item;\n      bind(item);\n    }\n\n    // Client then update its ViewHolder's appearance here\n    public abstract void bind(T item);\n  }\n}\n```\n\nThis class is an simple extension of the ```BaseAdapter``` above, in respect to ```android.widget.ArrayAdapter```. ```BaseListAdapter``` suppose to support a specific Data Type ***T***, come along with a special ```ViewHolder``` class to ensure that each ```ViewHolder``` will represent an Object of type ***T***. ```ViewHolder#bindInternal``` are called to make sure that a ```ViewHolder``` instance hold its ```mItem``` for later use. *This implementation is Optional.*\n\n2 Base Classes above are how I prepare the base for any further interaction implementation. In fact, the same implementation could be done to support ```OnItemLongClickListener```.\n\n## 3. OnItemClick in action\n\nI prepared 2 Fragment, who hold 2 lists: a Simple list of String and a more complicated list of *Cheese* (borrow the idea, some pieces of code and resources from [Cheesesquare](https://github.com/chrisbanes/cheesesquare)).\n\nLet's start from something complicated :D.\n\n- CheeseListFragment and CheeseListAdapter: \n\nAn implementation of ViewHolder for a Cheese list:\n\n```Java:CheeseListAdapter$ViewHolder.class\npublic static class ViewHolder extends BaseListAdapter.ViewHolder<Cheeses> {\n\n    // A ViewHolder expects a UI Layout, so make it static here\n    static final int LAYOUT_RES = R.layout.list_item;\n\n    public final ImageView mImageView;\n    public final TextView mTextView;\n\n    public ViewHolder(View view) {\n      super(view);\n      mImageView = (ImageView) view.findViewById(R.id.item_icon);\n      mTextView = (TextView) view.findViewById(R.id.item_name);\n    }\n\n    @Override public void bind(Cheeses item) {\n      mTextView.setText(item.getName());\n      Picasso.with(itemView.getContext())\n          .load(item.getIconRes())\n          .fit().centerCrop()\n          .into(mImageView);\n    }\n\n    // !IMPORTANT Since we accept click event on 2 different views, we must delegate them here.\n    @Override public void setOnViewHolderClickListener(View.OnClickListener listener) {\n      mImageView.setOnClickListener(listener);\n      itemView.setOnClickListener(listener);\n    }\n  }\n```\n\nThis ViewHolder is exactly the same as *Cheesesquare*'s list view holder. But it provides better interaction: click on Cheese's image and click on the item's cell. To support that, we simply override ```#setOnViewHolderClickListener``` and setup the normal OnClick event for whatever Views from which we want to listen to click event. Here I setup for my **mImageView** and the **itemView** (which holds **mImageView** as its child).\n\n```Java:CheeseListAdapter.class\n  // Just because I like this number\n  private static final int LIST_SIZE = 23;\n\n  private static final List<Cheeses> sItems = getRandomSublist(Cheeses.sCheeseStrings, LIST_SIZE);\n\n  @Override public Cheeses getItem(int position) {\n    return sItems.get(position);\n  }\n\n  @Override\n  public BaseListAdapter.ViewHolder<Cheeses> onCreateViewHolder(ViewGroup parent, int viewType) {\n    View view = LayoutInflater.from(parent.getContext())\n        .inflate(ViewHolder.LAYOUT_RES, parent, false);\n    final ViewHolder viewHolder = new ViewHolder(view);\n    // setup Click event listener here\n    viewHolder.setOnViewHolderClickListener(new View.OnClickListener() {\n      @Override public void onClick(View v) {\n        if (CheeseListAdapter.this.mOnItemClickListener != null) {\n          int adapterPosition = viewHolder.getAdapterPosition();\n          // get this from Android Summit Video\n          if (adapterPosition != RecyclerView.NO_POSITION) {\n            CheeseListAdapter.this.mOnItemClickListener.onItemClick(\n                CheeseListAdapter.this, viewHolder, v, adapterPosition, getItemId(adapterPosition)\n            );\n          }\n        }\n      }\n    });\n    return viewHolder;\n  }\n\n  /**\n   * Customized Click event listener\n   */\n  public abstract static class OnCheeseClickListener implements OnItemClickListener {\n\n    public abstract void onIconClick(View iconView, Cheeses cheese);\n\n    public abstract void onCheeseClick(View nameView, Cheeses cheese);\n\n    @Override\n    public void onItemClick(BaseAdapter adapter, BaseAdapter.ViewHolder viewHolder,\n                            View view, int adapterPosition, long itemId) {\n      if (adapter instanceof BaseListAdapter) {\n        // we expect a ListAdapter here, since we are using a List Adapter\n        BaseListAdapter listAdapter = (BaseListAdapter) adapter;\n        // so we can get clicked item\n        Cheeses item = (Cheeses) listAdapter.getItem(adapterPosition);\n\n        // Note 1: Casted object maybe null if we're using wrong adapter\n        // Note 2:\n        if (item != null && viewHolder instanceof ViewHolder) {\n          if (view == ((ViewHolder) viewHolder).mImageView) {\n            onIconClick(view, item);\n          } else if (view == ((ViewHolder) viewHolder).itemView) {\n            onCheeseClick(view, item);\n          }\n        }\n      }\n    }\n  }\n\n  @Override public int getItemCount() {\n    return sItems.size();\n  }\n\n  List<Cheeses> getRandomSublist(String[] array, int amount) {\n    ArrayList<Cheeses> list = new ArrayList<>(amount);\n    ... // refer Cheesesquare\n    return list;\n  }\n\n  public static class ViewHolder extends BaseListAdapter.ViewHolder<Cheeses> {\n\t ... // above\n  }\n}\n```\n\nSo for my custom click listener behavior, I have ```OnCheeseClickListener``` which implement ```BaseAdapter$OnItemClickListener```. By that, I could provide custom behavior for each components in each of this list's ViewHolder objects.\n\n```CheeseListAdapter#onCreateViewHolder``` is where we pass the Click event listener from parent Adapter to its ViewHolder. Inspired from ```Android Summit 2015``` talks, that is where we should do that works, and ```ViewHolder#getAdapterPosition()``` is the position we should use to get Data.\n\nNow, take a look at ```CheeseListFragment```\n\n```Java:CheeseListFragment.class\npublic class CheeseListFragment extends Fragment {\n\n  RecyclerView mRecyclerView;\n  RecyclerView.LayoutManager mLayoutManager;\n  CheeseListAdapter mAdapter;\n  /**\n   * My customized click listener. We can directly handle click event from Fragment or Setup\n   * another callback to attach to Host Activity's lifecycle. IMO, Both are good practices.\n   */\n  private CheeseListAdapter.OnCheeseClickListener mClickListener;\n\n  public CheeseListFragment() {\n  }\n\n  public static CheeseListFragment newInstance() {\n    return new CheeseListFragment();\n  }\n\n  @Nullable @Override\n  public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle\n      savedInstanceState) {\n    return inflater.inflate(R.layout.fragment_cheese_list, container, false);\n  }\n\n  @Override public void onViewCreated(View view, Bundle savedInstanceState) {\n    super.onViewCreated(view, savedInstanceState);\n    mRecyclerView = (RecyclerView) view.findViewById(R.id.recycler_view);\n    /*\n      We can try both UI to check if our position works as expected;\n     */\n    // mLayoutManager = new LinearLayoutManager(getContext(), LinearLayoutManager.VERTICAL, false);\n    mLayoutManager = new GridLayoutManager(getContext(), 2, LinearLayoutManager.VERTICAL, false);\n    // a little bit more complicated Grid.\n    GridLayoutManager.SpanSizeLookup spanSizeLookup = new GridLayoutManager.SpanSizeLookup() {\n      @Override public int getSpanSize(int position) {\n        return position % 3 == 2 ? 2 : 1;\n      }\n    };\n\n    ((GridLayoutManager) mLayoutManager).setSpanSizeLookup(spanSizeLookup);\n\n    mRecyclerView.setLayoutManager(mLayoutManager);\n\n    mAdapter = new CheeseListAdapter();\n    mRecyclerView.setAdapter(mAdapter);\n\n    mClickListener = new CheeseListAdapter.OnCheeseClickListener() {\n      @Override public void onIconClick(View iconView, Cheeses cheese) {\n        if (getView() != null) {\n          Snackbar.make(getView(), \"Icon clicked: \" + cheese.getName(), Snackbar.LENGTH_LONG)\n              .show();\n        }\n      }\n\n      @Override public void onCheeseClick(View nameView, Cheeses cheese) {\n        Intent intent = new Intent(getContext(), CheeseDetailActivity.class);\n        intent.putExtra(CheeseDetailActivity.EXTRA_NAME, cheese.getName());\n        startActivity(intent);\n      }\n    };\n\n    mAdapter.setOnItemClickListener(mClickListener);\n  }\n\n  @Override public void onDestroyView() {\n    // This click event is attached to UI behavior, so we should properly release it before all\n    // views are dead.\n    // IMO, Doing this in onDestroyView or onDetach is really depends on how you use your listener.\n    mClickListener = null;\n    super.onDestroyView();\n  }\n}\n```\n\nThere's been various practices on how to pass logic to Fragment from Activity. I don't discuss it here. The point here is how we pass that event to our Adapter, which is simply like this:\n\n```Java\nCheeseListAdapter.OnCheeseClickListener  mClickListener = new CheeseListAdapter.OnCheeseClickListener() {\n      @Override public void onIconClick(View iconView, Cheeses cheese) {\n        if (getView() != null) {\n          Snackbar.make(getView(), \"Icon clicked: \" + cheese.getName(), Snackbar.LENGTH_LONG)\n              .show();\n        }\n      }\n\n      @Override public void onCheeseClick(View nameView, Cheeses cheese) {\n        Intent intent = new Intent(getContext(), CheeseDetailActivity.class);\n        intent.putExtra(CheeseDetailActivity.EXTRA_NAME, cheese.getName());\n        startActivity(intent);\n      }\n    };\n\n    mAdapter.setOnItemClickListener(mClickListener);\n```\n\nFor the general ```Activity-Fragment-Callback``` implementation, we can have an interface from our Fragment, and retrieve its instance by ```onAttach```, I leave it for Client. But it would not be complicated.\n\nAbove example looks complicated, now we look at a much more simpler Example: A simple String list\n\n```Java: SimpleListAdapter$ViewHolder.class\npublic static class ViewHolder extends BaseListAdapter.ViewHolder<String> {\n\n    // This is a TextView's layout\n    static final int LAYOUT_RES = android.R.layout.simple_list_item_1;\n\n    public ViewHolder(@NonNull View itemView) {\n      super(itemView);\n    }\n\n    @Override public void bind(String item) {\n      // It's safe here\n      ((TextView) itemView).setText(item);\n    }\n  }\n```\n\nComparing to Cheese list's Viewholder, we have simpler class here, without any setup for On Click event. Because by default, ```ViewHolder#itemView``` will handle that event if set (```BaseAdapter$ViewHolder#setOnViewHolderClickListener()```).\n\n```Java:SimpleListAdapter.class\npublic class SimpleListAdapter extends BaseListAdapter<String> {\n\n  List<String> getRandomSublist(String[] array, int amount) {\n    ArrayList<String> list = new ArrayList<>(amount);\n    ... // refer Cheesesquare\n    return list;\n  }\n\n  // Just because I like this number\n  private static final int LIST_SIZE = 23;\n\n  private final List<String> sItems = getRandomSublist(Cheeses.sCheeseStrings, LIST_SIZE);\n\n  @Override public String getItem(int position) {\n    return sItems.get(position);\n  }\n\n  @Override\n  public BaseListAdapter.ViewHolder<String> onCreateViewHolder(ViewGroup parent, int viewType) {\n    View view = LayoutInflater.from(parent.getContext())\n        .inflate(ViewHolder.LAYOUT_RES, parent, false);\n    final ViewHolder viewHolder = new ViewHolder(view);\n    viewHolder.setOnViewHolderClickListener(new View.OnClickListener() {\n      @Override public void onClick(View v) {\n        int adapterPosition = viewHolder.getAdapterPosition();\n        // get this from Android Summit Video\n        if (adapterPosition != RecyclerView.NO_POSITION) {\n          SimpleListAdapter.this.mOnItemClickListener.onItemClick(\n              SimpleListAdapter.this, viewHolder, v, adapterPosition, getItemId(adapterPosition)\n          );\n        }\n      }\n    });\n\n    return viewHolder;\n  }\n\n  @Override public int getItemCount() {\n    return sItems.size();\n  }\n\n  public static class ViewHolder extends BaseListAdapter.ViewHolder<String> {\n\t... // above\n  }\n}\n```\n\nSo except for the custom ```OnCheeseClickListener```, this class is the same as ```CheeseListAdapter```, with a little mount of code. The most important part was still the ```#onCreateViewHolder``` implementation.\n\n```Java:SimpleListFragment.class\npublic class SimpleListFragment extends Fragment {\n\n  public SimpleListFragment() {\n  }\n\n  public static SimpleListFragment newInstance() {\n    return new SimpleListFragment();\n  }\n\n  RecyclerView mRecyclerView;\n  RecyclerView.LayoutManager mLayoutManager;\n  SimpleListAdapter mAdapter;\n  BaseAdapter.OnItemClickListener mClickListener;\n\n  @Nullable @Override\n  public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle\n      savedInstanceState) {\n    return inflater.inflate(R.layout.fragment_cheese_list, container, false);\n  }\n\n  @Override public void onViewCreated(View view, Bundle savedInstanceState) {\n    super.onViewCreated(view, savedInstanceState);\n    mRecyclerView = (RecyclerView) view.findViewById(R.id.recycler_view);\n    mLayoutManager = new LinearLayoutManager(getContext(), LinearLayoutManager.VERTICAL, false);\n    mRecyclerView.setLayoutManager(mLayoutManager);\n\n    mAdapter = new SimpleListAdapter();\n    mRecyclerView.setAdapter(mAdapter);\n\n    mClickListener = new BaseAdapter.OnItemClickListener() {\n      @Override\n      public void onItemClick(BaseAdapter adapter, BaseAdapter.ViewHolder viewHolder, View view,\n                              int adapterPosition, long itemId) {\n        String item = null;\n        if (adapter instanceof SimpleListAdapter) {\n          item = ((SimpleListAdapter) adapter).getItem(adapterPosition);\n        }\n\n        if (item != null) {\n          Intent intent = new Intent(getContext(), CheeseDetailActivity.class);\n          intent.putExtra(CheeseDetailActivity.EXTRA_NAME, item);\n          startActivity(intent);\n        }\n      }\n    };\n\n    mAdapter.setOnItemClickListener(mClickListener);\n  }\n\n  @Override public void onDestroyView() {\n    // This click event is attached to UI behavior, so we should properly release it before all\n    // views are dead.\n    // IMO, Doing this in onDestroyView or onDetach is really depends on how you use your listener.\n    mClickListener = null;\n    super.onDestroyView();\n  }\n}\n```\n\nHere we have almost the same structure with ```CheeseListFragment```. And again this is not a bunch of code ***in my opinion*** :trollface:.\n\n## 4. Conclusion and Future works\n\nThis is neither a new implementation nor a new Idea. It's just another way to handle the famous click event, created specially for ```RecyclerView```. This is based on **one point** from ```Android Summit 2015``` talk, where ```RecyclerView```'s creator pointed out where should be the place we setup the click event listener. The rest of this project tries to support our common sense of setting up our legacy ```AdapterView```. But it doesn't try to attach on ```AdapterView``` point of view, but it goes by the think of ```RecyclerView```: ```Adapter``` is where we start everything, ```RecyclerView``` will support the hard works. So by this point of view, I hope this implementation could be considered a *not bad practices*.\n\nMore works need to be done for more interaction event (long click, for example). And there are more rooms for others **NOT BAD RECYCLERVIEW PRACTICES** too (At least, I was talking about ***OnClickListener*** this time only). So hopefully more practices are coming.\n\n## 5. Last but not least\n\nRe: I created a repo: [RVP](https://github.com/eneim/RVP)\n\nThis project is written in plain MVC, so it might not look good or even useful in other design patterns though. So use it at your own risk, and any contribution are welcome.\n\nThis project follows Google's Java coding style (*tl,dr: 2-spaces-indent*) :D.\n", "tags": ["Android", "RecyclerView"]}