{"context": " More than 1 year has passed since last update.https://www.opengl.org/discussion_boards/showthread.php/159402-half-sphere \u306e\u30b3\u30fc\u30c9\u3092 oF \u7528\u306b\u66f8\u304d\u76f4\u3057\u305f\u3082\u306e\u3067\u3059\u304c\u4ee5\u4e0b\u306e\u8ab2\u984c\u304c\u3042\u308a\u307e\u3059\u3002\n\n\u3066\u3063\u307a\u3093\u304c\u7a74\u7a7a\u304d\u306b\u306a\u308b\n\u9802\u70b9\u60c5\u5831\u3057\u304b\u7121\u3044\n\n\u3082\u3046\u5c11\u3057\u30d9\u30bf\u30fc\u306a\u65b9\u6cd5\u304c\u3042\u308c\u3070\u305c\u3072\u6559\u3048\u3066\u4e0b\u3055\u3044\uff01\nofVbo mHemisphere;\n\nvoid ofApp::setup()\n{\n    const auto resolution_ = 256;\n    const auto radius_ = 100.0;\n\n    std::vector<ofVec3f> vertices_;\n\n    for (auto i = 0; i < resolution_; ++i)\n    {\n        for (auto j = 0; j < resolution_; ++j)\n        {\n            vertices_.emplace_back(ofVec3f(\n                radius_ * std::cos(j * 2 * M_PI / resolution_) * std::cos(i * M_PI / (2 * resolution_)),\n                radius_ * std::sin(-i * M_PI / (2 * resolution_)),\n                radius_ * std::sin(j * 2 * M_PI / resolution_) * std::cos(i * M_PI / (2 * resolution_))\n            ));\n        }\n    }\n\n    ofMesh mesh_;\n\n    for (auto i = 0; i < resolution_ - 1; ++i)\n    {\n        for (auto j = 0; j < resolution_; ++j)\n        {\n            mesh_.addVertex(vertices_.at(i * resolution_ + j));            \n            mesh_.addVertex(vertices_.at(i * resolution_ + (j + 1) % resolution_));            \n            mesh_.addVertex(vertices_.at((i + 1) * resolution_ + (j + 1) % resolution_));            \n            mesh_.addVertex(vertices_.at((i + 1) * resolution_ + j));\n        }\n    }\n\n    mHemisphere.setMesh(std::move(mesh_), GL_STATIC_DRAW);\n}\n\nvoid ofApp::draw()\n{\n    ofTranslate(ofGetWidth() * 0.5, ofGetHeight() * 0.5);\n    ofRotate(ofGetElapsedTimef() * 30.0, 1.0, 0.0, 1.0);\n    mHemisphere.draw(GL_QUADS, 0, mVbo.getNumVertices());\n}\n\nhttps://www.opengl.org/discussion_boards/showthread.php/159402-half-sphere \u306e\u30b3\u30fc\u30c9\u3092 oF \u7528\u306b\u66f8\u304d\u76f4\u3057\u305f\u3082\u306e\u3067\u3059\u304c\u4ee5\u4e0b\u306e\u8ab2\u984c\u304c\u3042\u308a\u307e\u3059\u3002\n\n- \u3066\u3063\u307a\u3093\u304c\u7a74\u7a7a\u304d\u306b\u306a\u308b\n- \u9802\u70b9\u60c5\u5831\u3057\u304b\u7121\u3044\n\n\u3082\u3046\u5c11\u3057\u30d9\u30bf\u30fc\u306a\u65b9\u6cd5\u304c\u3042\u308c\u3070\u305c\u3072\u6559\u3048\u3066\u4e0b\u3055\u3044\uff01\n\n```cpp\nofVbo mHemisphere;\n\nvoid ofApp::setup()\n{\n    const auto resolution_ = 256;\n    const auto radius_ = 100.0;\n\n    std::vector<ofVec3f> vertices_;\n\n    for (auto i = 0; i < resolution_; ++i)\n    {\n        for (auto j = 0; j < resolution_; ++j)\n        {\n            vertices_.emplace_back(ofVec3f(\n                radius_ * std::cos(j * 2 * M_PI / resolution_) * std::cos(i * M_PI / (2 * resolution_)),\n                radius_ * std::sin(-i * M_PI / (2 * resolution_)),\n                radius_ * std::sin(j * 2 * M_PI / resolution_) * std::cos(i * M_PI / (2 * resolution_))\n            ));\n        }\n    }\n\n    ofMesh mesh_;\n\n    for (auto i = 0; i < resolution_ - 1; ++i)\n    {\n        for (auto j = 0; j < resolution_; ++j)\n        {\n            mesh_.addVertex(vertices_.at(i * resolution_ + j));            \n            mesh_.addVertex(vertices_.at(i * resolution_ + (j + 1) % resolution_));            \n            mesh_.addVertex(vertices_.at((i + 1) * resolution_ + (j + 1) % resolution_));            \n            mesh_.addVertex(vertices_.at((i + 1) * resolution_ + j));\n        }\n    }\n\n    mHemisphere.setMesh(std::move(mesh_), GL_STATIC_DRAW);\n}\n\nvoid ofApp::draw()\n{\n    ofTranslate(ofGetWidth() * 0.5, ofGetHeight() * 0.5);\n    ofRotate(ofGetElapsedTimef() * 30.0, 1.0, 0.0, 1.0);\n    mHemisphere.draw(GL_QUADS, 0, mVbo.getNumVertices());\n}\n```\n", "tags": ["OpenGL", "openFrameworks", "C++"]}