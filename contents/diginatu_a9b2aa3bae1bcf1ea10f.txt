{"context": "\u3053\u3093\u306b\u3061\u306f\u3001Vim\u306eplugin\u3072\u3068\u3064\u3082\u66f8\u3044\u305f\u3053\u3068\u306a\u3044\u521d\u5fc3\u8005\u3067\u3059\u3002\n\u3053\u306e\u8a18\u4e8b\u306fQiita Vim (\u305d\u306e2) Advent Calendar 2016 6\u65e5\u76ee\u3001Vim\u306e\u30bd\u30fc\u30b9\u30b3\u30fc\u30c9\u3092\u8aad\u3082\u3046\u3068\u3044\u3046\u8a18\u4e8b\u3067\u3059\u3002\nVim\u306b\u3082\u3063\u3068\u8fd1\u3065\u304d\u305f\u3044\u3068\u3044\u3046\u601d\u3044\u3067\u66f8\u304d\u307e\u3057\u305f\uff08\u9069\u5f53\uff09\u3002\n\u30aa\u30fc\u30d7\u30f3\u30bd\u30fc\u30b9\u306e\u30bd\u30fc\u30b9\u3092\u8aad\u3080\u3068\u304b\u306f\u62b5\u6297\u304c\u3042\u308b\u306a\u3093\u3066\u3044\u3046\u4eba\u306b\u8aad\u3093\u3067\u3082\u3089\u3048\u308b\u3068\u5b09\u3057\u3044\u3067\u3059\u3002\n\n\u8ab2\u984c\n\u307f\u306a\u3055\u3093\u306f<ESC>\u306f\u306a\u306b\u3067\u5165\u529b\u3057\u3066\u3044\u307e\u3059\u304b\uff1f\u79c1\u306f<C-j>\u3092\u4f7f\u3063\u3066\u3044\u307e\u3059\u3002\n\u305d\u3046\u3067\u3059\u3001\u30de\u30c3\u30d4\u30f3\u30b0\u3057\u3066\u308b\u306e\u3067\u3059\u3002\n\u3088\u304f\u4f7f\u308f\u308c\u3066\u3044\u308b\u30de\u30c3\u30d4\u30f3\u30b0\u306e\u3088\u3046\u306a\u6c17\u304c\u3057\u307e\u3059\u304c\u3001\u3072\u3068\u3064\u554f\u984c\u304c\u3042\u308b\u306e\u3067\u3059\u3002\n\u30ce\u30fc\u30de\u30eb\u30e2\u30fc\u30c9\u6642\u306b:\u62bc\u3057\u305f\u6642\u306e\u3042\u306e\u72b6\u614b(\u30b3\u30de\u30f3\u30c9\u30e9\u30a4\u30f3\u30e2\u30fc\u30c9\u3068\u3044\u3046\u3089\u3057\u3044)\u304b\u3089<ESC>\u3092\u62bc\u3059\u3068\u30ad\u30e3\u30f3\u30bb\u30eb\u3057\u3066\u30ce\u30fc\u30de\u30eb\u30e2\u30fc\u30c9\u306b\u623b\u308a\u307e\u3059\u304c\u3001<C-j>\u3092\u62bc\u3059\u3068\u30b3\u30de\u30f3\u30c9\u3092\u5b9f\u884c\u3057\u3066\u3057\u307e\u3046\u306e\u3067\u3059\u3002\n\u8abf\u3079\u3066\u307f\u308b\u3068\u3001\u30de\u30c3\u30d4\u30f3\u30b0\u306f\u3061\u3083\u3093\u3068\u3067\u304d\u3066\u3044\u308b\u3088\u3046\u3067\u3059\u3057\u3001\u3082\u3068\u3082\u3068\u306e\u30de\u30c3\u30d4\u30f3\u30b0\u3092\u6d88\u305d\u3046\u3068unmap\u3057\u3066\u3082\u30c0\u30e1\u307f\u305f\u3044\u3067\u3059\u3002\n<C-j>\u306f\u5b8c\u5168\u306a<ESC>\u306b\u306f\u306a\u308c\u306a\u3044\u3093\u3067\u3057\u3087\u3046\u304b\uff1f\n\u305d\u308c\u3067\u306f\u3053\u308c\u3092\u984c\u6750\u306bVim\u306e\u30bd\u30fc\u30b9\u3092\u79c1\u304c\u306f\u3058\u3081\u3066\u898b\u3066\u307f\u3066\u3044\u3063\u305f\u69d8\u5b50\u3092\u5fc3\u306e\u58f0\u3068\u5171\u306b\u7d39\u4ecb\u3057\u307e\u3057\u3087\u3046\u3002\n\u30bd\u30fc\u30b9\u3092\u521d\u3081\u3066\u8aad\u3080\u3068\u3044\u3046\u306e\u304c\u30c6\u30fc\u30de\u306a\u306e\u3067\u307e\u3068\u307e\u308a\u3088\u308a\u3082\u6642\u7cfb\u5217\u3092\u512a\u5148\u3057\u3066\u65e5\u8a18\u306e\u3088\u3046\u306b\u66f8\u304d\u307e\u3057\u305f\u3002\n\uff08\u4eca\u56de\u306f\u30d0\u30fc\u30b8\u30e7\u30f3\u306f\u3042\u307e\u308a\u95a2\u4fc2\u306a\u3055\u305d\u3046\u306a\u306e\u3067\u30bd\u30fc\u30b9\u306f\u308f\u304b\u308a\u3084\u3059\u304fv8.0.0000\u306e\u3082\u306e\u306b\u3057\u307e\u3057\u305f\u3002\uff09\n\n\nVim\u306e\u30bd\u30fc\u30b9\u30b3\u30fc\u30c9\u3092\u3068\u3063\u3066\u304f\u308b\nVim\u306e\u30bd\u30fc\u30b9\u306fGithub\u306b\u4e0a\u304c\u3063\u3066\u3044\u308b\u307f\u305f\u3044\u3002\n% ls\nappveyor.yml     farsi/    nsis/       README.md   src/          vimtutor.bat\nconfigure*       Filelist  pixmaps/    README.txt  tools/        vimtutor.com*\nCONTRIBUTING.md  Makefile  READMEdir/  runtime/    uninstal.txt\n\n\u3075\u3080\u3002\n\u53d6\u3063\u639b\u304b\u308a\u304c\u307b\u3057\u3044\u306e\u3067\u4eca\u308f\u304b\u3063\u3066\u3044\u308b\u60c5\u5831\u3068\u3044\u3048\u3070\u30b3\u30de\u30f3\u30c9\u30e9\u30a4\u30f3\u3068\u3044\u3046\u30e2\u30fc\u30c9\u3067\u8d77\u3053\u308b\u3063\u3066\u3053\u3068\u3002\n\n\u60c5\u5831\u53ce\u96c6\n\u3068\u308a\u3042\u3048\u305asrc\u306b\u79fb\u52d5\u3057\u3066\u3001\u304a\u3082\u3080\u308d\u306bgrep\u3002\n% cd src\n% grep -r command-line\nscreen.c:     * 1. Add the cmdwin_type for the command-line window\nscreen.c:     * 1. Add the cmdwin_type for the command-line window\nscreen.c:           /* account for first command-line character in rightleft mode */\nINSTALLpc.txt:This contains the command-line tools (compiler, linker, CRT headers,\nnormal.c:#define NV_NCW     0x200       /* not allowed in command-line window */\nnormal.c: * \"q:\", \"q/\", \"q?\": edit command-line in command-line window.\ngui_gtk_x11.c: * Parse the GUI related command-line arguments.  Any arguments used are\ngui_w32.c: * Parse the GUI related command-line arguments.  Any arguments used are\ngui_x11.c: * Parse the GUI related command-line arguments.  Any arguments used are\nmain.c: * Also used to handle commands in the command-line window, until the window\nmain.c:    int          cmdwin,     /* TRUE when working in the command-line window */\nui.c: * command-line and in the cmdline window.\nui.c:       /* A click outside the command-line window: Use modeless\nglobals.h:EXTERN char_u e_cmdwin[]      INIT(= N_(\"E11: Invalid in command-line window; <CR> executes, CTRL-C quits\"));\nterm.c: * command-line, and for building the \"Ambiguous mapping...\" error message.\nterm.c:    int          expmap)  /* TRUE when expanding mappings on command-line */\nbuffer.c:    /* don't read in if there are files on the command-line or if writing: */\nkeymap.h:    , KE_CMDWIN                /* open command-line window from Command-line Mode */\nex_getln.c: * Used by CTRL-R command in command-line mode.\nex_getln.c:    /* only expansion for ':', '>' and '=' command-lines */\nex_getln.c: * Get the current command-line type.\nex_getln.c:    /* Create a window for the command-line buffer. */\nex_getln.c:    /* Create the command-line buffer empty. */\nex_getln.c:    /* Replace the empty last line with the current command-line and put the\nex_getln.c:     /* Avoid command-line window first character being concealed. */\npo/fi.po:msgid \"E11: Invalid in command-line window; <CR> executes, CTRL-C quits\"\npo/zh_CN.po:msgid \"E11: Invalid in command-line window; <CR> executes, CTRL-C quits\"\n[...]\n\npo\u30d5\u30a1\u30a4\u30eb\u306f\u591a\u5206\u7ffb\u8a33\u3068\u304b\u306a\u306e\u3067\u5b9f\u8cea\u51fa\u3066\u304d\u305f\u306e\u306f\u6570\u5341\u884c\u3002\ncmdline\u3068\u3044\u3046\u8868\u8a18\u3082\u898b\u3064\u304b\u3063\u305f\u305e\n% grep -r cmdline | wc -l\n836\n\n800\u884c\u304b\u3001\u3080\u30fc\n% grep -r \"command line\" | grep -v po/ | wc -l \n263\n\n\u3075\u3080\u3002\n\u3053\u306e\u3050\u3089\u3044\u306e\u91cf\u306a\u3089\u76eegrep\u3067\u3002\n\u3053\u306e\u4e2d\u3067\u6c17\u306b\u306a\u308b\u3068\u3053\u3044\u304f\u3064\u304b\u767a\u898b\u3002\n% grep -r \"command line\" | grep -v po/\n[..]\nex_getln.c: * Get an Ex command line for the \":\" command. \n[..]\nREADME.txt:parsing of the \":\" command line and calls do_one_cmd() for each separate\n[..]\n\n\u3066\u304bREADME\u306e\u306a\u304b\u306b\u30dd\u30a4\u3053\u3068\u66f8\u3044\u3066\u3093\u306a\uff1f\nCOMMAND-LINE MODE\n\nWhen typing a \":\", normal_cmd() will call getcmdline() to obtain a line with\nan Ex command.  getcmdline() contains a loop that will handle each typed\ncharacter.  It returns when hitting <CR> or <Esc> or some other character that\nends the command line mode.\n\ngetcmdline()\u306e\u4e2d\u306b\u5165\u529b\u3055\u308c\u305f\u6587\u5b57\u3092\u53d7\u3051\u53d6\u308b\u30eb\u30fc\u30d7\u304c\u3042\u308b\u3068\u3002\u3053\u308c\u3060\u3002\n\n\u30bd\u30fc\u30b9\u306b\u30c0\u30a4\u30d6\ngrep\u3057\u3066\u307f\u308b\u3068\u5b9a\u7fa9\u306fex_getln.c L164\u306b\u3042\u308b\u307f\u305f\u3044\u3002\nVim\u3067\u958b\u3044\u3066for\u3067\u691c\u7d22\u3002\nex_getln.c L364\n    /*\n     * Collect the command string, handling editing keys.\n     */\n    for (;;)\n    {\n    redir_off = TRUE;   /* Don't redirect the typed command.\n                   Repeated, because a \":redir\" inside\n\n\u3042\u3063\u305f\u3042\u3063\u305f\u3002\n    /* Get a character.  Ignore K_IGNORE, it should not do anything, such\n     * as stop completion. */\n    do\n    {\n        c = safe_vgetc();\n    } while (c == K_IGNORE);\n\nc\u306b\u5165\u529b\u3055\u308c\u305f\u6587\u5b57\u304c\u5165\u308b\u611f\u3058\u3060\u308d\u3046\u3002\n\u6c17\u306b\u306a\u308b\u3068\u3053\u308d\u307e\u3067\u8aad\u307f\u98db\u3070\u3057\u3066\u3044\u304f\u3002\nex_getln.c L787\n    if (c == '\\n' || c == '\\r' || c == K_KENTER || (c == ESC\n            && (!KeyTyped || vim_strchr(p_cpo, CPO_ESC) != NULL)))\n    {\n        /* In Ex mode a backslash escapes a newline. */\n        if (exmode_active\n            && c != ESC\n            && ccline.cmdpos == ccline.cmdlen\n            && ccline.cmdpos > 0\n            && ccline.cmdbuff[ccline.cmdpos - 1] == '\\\\')\n        {\n        if (c == K_KENTER)\n            c = '\\n';\n        }\n        else\n        {\n        gotesc = FALSE; /* Might have typed ESC previously, don't\n                       truncate the cmdline now. */\n        if (ccheck_abbr(c + ABBR_OFF))\n            goto cmdline_changed;\n        if (!cmd_silent)\n        {\n            windgoto(msg_row, 0);\n            out_flush();\n        }\n        break;\n        }\n    }\n\n\u3053\u3053\u3067\u306a\u3093\u304b\u6539\u884c\u3068\u304b\u306b\u306a\u3063\u3066\u305f\u5834\u5408\u306f\u78ba\u5b9a\u3059\u308b\u51e6\u7406\u3092\u3084\u3063\u3066\u308b\u307d\u3044\u306a\u3002\nex_getln.c L1158\n    case ESC:   /* get here if p_wc != ESC or when ESC typed twice */\n    case Ctrl_C:\n        /* In exmode it doesn't make sense to return.  Except when\n         * \":normal\" runs out of characters. */\n        if (exmode_active\n                   && (ex_normal_busy == 0 || typebuf.tb_len > 0))\n            goto cmdline_not_changed;\n\n        gotesc = TRUE;      /* will free ccline.cmdbuff after\n                       putting it in history */\n        goto returncmd;     /* back to cmd mode */\n\n\u30b3\u30e1\u30f3\u30c8\u306b\u3042\u308bp_wc\u3068\u3044\u3046\u306e\u306f\u3001\u8abf\u3079\u3066\u307f\u308b\u3068\u3001\n% grep -r p_wc\noption.h:EXTERN long    p_wc;           /* 'wildchar' */\n\noption.h\u306b\u5b9a\u7fa9\u3055\u308c\u3066\u3044\u3066\u3001\u30aa\u30d7\u30b7\u30e7\u30f3\u306ewildchar\u3092\u4fdd\u6301\u3057\u3066\u3044\u308b\u5909\u6570\u307d\u3044\u3002\nvim\u306e\u30aa\u30d7\u30b7\u30e7\u30f3\u306fp_\u3063\u3066\u540d\u524d\u3067extern\u3055\u308c\u3066\u308b\u5909\u6570\u304c\u3044\u3063\u3071\u3044\u3042\u308b\u307f\u305f\u3044\u3002\nwildchar\u304c<ESC>\u3060\u3063\u305f\u3089\u3053\u308c\u4ee5\u524d\u306b\u51e6\u7406\u3055\u308c\u308b\u307f\u305f\u3044\u3060\u3051\u3069\u30c7\u30d5\u30a9\u30eb\u30c8\u3067\u306f<Tab>\u3060\u306d\u3002\n\u306a\u306e\u3067\u3053\u3053\u304c\u30ad\u30e3\u30f3\u30bb\u30eb\u306e\u51e6\u7406\u3063\u307d\u3044\u3002\n\u3067\u4e0a\u306eK_KENTER\u3068\u304bESC\u3001Ctrl_C\u306f\u3001\u305d\u308c\u305e\u308cgrep\u3067\u8abf\u3079\u3066\u307e\u3068\u3081\u308b\u3068\u3001\nkeymap.h:#define K_KENTER       TERMCAP2KEY('K', 'A')   /* keypad Enter */\nascii.h:#define ESC             '\\033'\nascii.h:#define ESC             '\\x27'\nascii.h:#define Ctrl_C          3\nascii.h:#define Ctrl_C          0x03\n\nESC\u3068\u304b\uff12\u56de\u3042\u308b\u3093\u3067\u3059\u3051\u3069\u3063\u3066ascii.h\u3092\u95a2\u4fc2\u3042\u308b\u90e8\u5206\u3060\u3051\u306b\u7701\u7565\u3059\u308b\u3068\u3053\u3093\u306a\u611f\u3058\u306b\u3002\n[..]\n/*\n * Definitions of various common control characters.\n * For EBCDIC we have to use different values.\n */\n\n#ifndef EBCDIC\n\n/* IF_EB(ASCII_constant, EBCDIC_constant) */\n[..]\n#define ESC     '\\033'\n[..]\n#define Ctrl_C      3\n[..]\n#else\n\n/* EBCDIC */\n\n[..]\n#define ESC     '\\x27'\n#define Ctrl_C      0x03\n[..]\n#endif /* defined EBCDIC */\n[..]\n\n\u307e\u3041\u306a\u3093\u304bEBCDIC\u3068\u304b\u3044\u3046\u6587\u5b57\u30bb\u30c3\u30c8\u7528\u306e\u5b9a\u6570\u3067\u307e\u3041\u3069\u3063\u3061\u306b\u3057\u308d\u5b9a\u6570\u3002\n\n\u3055\u3089\u306b\u6df1\u307f\u3078\n\u305d\u3046\u3059\u308b\u3068\u5165\u529b\u3055\u308c\u305f\u6587\u5b57\u3092\u53d7\u3051\u53d6\u308bc = safe_vgetc();\u306b\u3042\u3063\u305fsafe_vgetc()\u306e\u6319\u52d5\u3092\u8abf\u3079\u306a\u3044\u3068\u306a\u3002\ngetchar.c L1793\n/*\n * Like vgetc(), but never return a NUL when called recursively, get a key\n * directly from the user (ignoring typeahead).\n */\n    int\nsafe_vgetc(void)\n{\n    int c;\n\n    c = vgetc();\n    if (c == NUL)\n    c = get_keystroke();\n    return c;\n}\n\n\u306f\u3044\u3002vgetc()\u3078\u3002\ngetchar.c L1552\n/*\n * Get the next input character.\n * Can return a special key or a multi-byte character.\n * Can return NUL when called recursively, use safe_vgetc() if that's not\n * wanted.\n * This translates escaped K_SPECIAL and CSI bytes to a K_SPECIAL or CSI byte.\n * Collects the bytes of a multibyte character into the whole character.\n * Returns the modifiers in the global \"mod_mask\".\n */\n    int\nvgetc(void)\n{\n\n\u6c17\u306b\u306a\u308b\u3068\u3053\u308d\u3092\u63a2\u3057\u306a\u304c\u3089\u773a\u3081\u3066\u307f\u3088\u3046\u3002\n    /*\n     * If a character was put back with vungetc, it was already processed.\n     * Return it directly.\n     */\n    if (old_char != -1)\n    {\n\n\u3075\u30fc\u3093vungetc\u306d\u3001\u307e\u3041\u666e\u901a\u306fold_char\u306f\u5165\u3063\u3066\u306a\u3044\u3093\u3067\u3057\u3087\u3002\n    }\n    else\n    {\n      mod_mask = 0x0;\n      last_recorded_len = 0;\n      for (;;)          /* this is done twice if there are modifiers */\n      {\n        int did_inc = FALSE;\n\n        if (mod_mask)       /* no mapping after modifier has been read */\n        {\n            ++no_mapping;\n            ++allow_keys;\n            did_inc = TRUE; /* mod_mask may change value */\n        }\n        c = vgetorpeek(TRUE);\n\n\u307e\u305fc\u306b\u5165\u529b\u3092\u5165\u308c\u3066\u308b\u3093\u3060\u306a\uff1f\n\u3057\u304b\u3057\u307e\u305f\u95a2\u6570\u51fa\u3066\u304d\u305f\u306a\u3002\n        /* a keypad or special function key was not mapped, use it like\n        * its ASCII equivalent */\n        switch (c)\n        {\n            case K_KPLUS:       c = '+'; break;\n            case K_KMINUS:      c = '-'; break;\n\n\u30ad\u30fc\u3068\u6587\u5b57\u306e\u5bfe\u5fdc\u3057\u3066\u308b\u3068\u3053\u304c\u3042\u3063\u305f\u3051\u3069\u4eca\u56de\u95a2\u4fc2\u3042\u308b\u30ad\u30fc\u306f\u306a\u3044\u3002\n    return c;\n}\n\n\u305d\u306e\u307e\u307ec\u304c\u8fd4\u308b\u307f\u305f\u3044\u3002\n\u3058\u3083\u3042c\u306b\u5165\u3063\u3066\u305fvgetorpeek()\u306f\uff1f\n\n\u3064\u3044\u306b\u771f\u9ac4\u3078?\ngetchar.c L1909\n/*\n * get a character:\n * 1. from the stuffbuffer\n *  This is used for abbreviated commands like \"D\" -> \"d$\".\n *  Also used to redo a command for \".\".\n * 2. from the typeahead buffer\n *  Stores text obtained previously but not used yet.\n *  Also stores the result of mappings.\n *  Also used for the \":normal\" command.\n * 3. from the user\n *  This may do a blocking wait if \"advance\" is TRUE.\n *\n * if \"advance\" is TRUE (vgetc()):\n *  Really get the character.\n *  KeyTyped is set to TRUE in the case the user typed the key.\n *  KeyStuffed is TRUE if the character comes from the stuff buffer.\n * if \"advance\" is FALSE (vpeekc()):\n *  just look whether there is a character available.\n *\n * When \"no_mapping\" is zero, checks for mappings in the current mode.\n * Only returns one byte (of a multi-byte character).\n * K_SPECIAL and CSI may be escaped, need to get two more bytes then.\n */\n    static int\nvgetorpeek(int advance)\n{\n\n\u3046\u30fc\u3093\u9577\u305d\u3046\u3001\u3067\u3082\u3053\u3053\u304c\u672c\u8cea\u3063\u307d\u3044\u306e\u3067\u304c\u3093\u3070\u308d\u3046\u3002\nadvance\u306f\u30d0\u30c3\u30d5\u30a1\u30fc\u3092\u3059\u3059\u3081\u308b\u304b\u3069\u3046\u304b\u3067\u3001\u547c\u3073\u51fa\u3057\u5143\u3067\u306fTRUE\u306b\u306a\u3063\u3066\u305f\u3002\n/*\n * get a character: 1. from the stuffbuffer\n */\n    if (typeahead_char != 0)\n    {\n        c = typeahead_char;\n        if (advance)\n        typeahead_char = 0;\n    }\n    else\n        c = read_readbuffers(advance);\n\n\u307e\u305fc\u306b\u8aad\u307f\u8fbc\u3093\u3067\u308b\u306a\uff1f\n\u3042 \u30bf\u30a4\u30dd\u898b\u3064\u3051\u305f(l\u3060\u3051\u5c0f\u6587\u5b57) getchar.c L2012\n         * needed for CTRL-W CTRl-] to open a fold, for example. */\n\nread_readbuffers\u306f\u2026\ngetchar.c L360\n/*\n * Get one byte from the read buffers.  Use readbuf1 one first, use readbuf2\n * if that one is empty.\n * If advance == TRUE go to the next char.\n * No translation is done K_SPECIAL and CSI are escaped.\n */\n    static int\nread_readbuffers(int advance)\n{\n    int c;\n\n    c = read_readbuf(&readbuf1, advance);\n    if (c == NUL)\n    c = read_readbuf(&readbuf2, advance);\n    return c;\n}\n\n\u30d0\u30c3\u30d5\u30a1\u304b\u3089\u8aad\u307f\u3053\u3080\u3060\u3051\u306e\u3082\u306e\u3063\u307d\u3044\nvgetorpeek()\u306b\u623b\u3063\u3066\u5148\u3092\u8aad\u3093\u3067\u3044\u304f\u3002\ngetchar.c L2020\n        /*\n         * Loop until we either find a matching mapped key, or we\n         * are sure that it is not a mapped key.\n         * If a mapped key sequence is found we go back to the start to\n         * try re-mapping.\n         */\n        for (;;)\n        {\n\n\u3042\u30fc\u3001\u3053\u3053\u3067\u30de\u30c3\u30d4\u30f3\u30b0\u51e6\u7406\u3057\u3066\u308b\u3093\u3060\u306d\uff01\uff08\u611f\u52d5\uff09\nnoremap\u3058\u3083\u306a\u3044\u3068\u518d\u8d77\u30de\u30c3\u30d4\u30f3\u30b0\u3059\u308b\u304b\u3089\u306d\u3002\n\u30de\u30c3\u30d4\u30f3\u30b0\u306e\u9014\u4e2d\u3060\u3063\u305f\u5834\u5408(<C-w>\u62bc\u3057\u305f\u3042\u3068\u3068\u304b)\u306f\u3053\u3053\u306e\u30eb\u30fc\u30d7\u3067\u6b62\u307e\u3063\u3066\u308b\u3093\u3060\u306d\u3001\u306a\u3093\u304b\u5b09\u3057\u3044\u3002\n\u3061\u306a\u307f\u306b\u6b62\u307e\u3063\u3066\u308b\u6642\u306b<C-c>\u3068\u304b\u304c\u6765\u308b\u3068got_int(interrupt\u306e\u610f)\u304cTRUE\u306b\u306a\u3063\u3066\u30ad\u30e3\u30f3\u30bb\u30eb\u3055\u308c\u308b\u307f\u305f\u3044\u3002\n\u3053\u306e\u4e2d\u306f\u7d50\u69cb\u8208\u5473\u6df1\u3044\u3068\u3053\u308d\u304c\u3042\u3063\u3066\u3001\u30b3\u30e1\u30f3\u30c8\u304c\u3044\u3063\u3071\u3044\u3042\u308b\u306e\u3067\u63a2\u7d22\u3059\u308b\u306e\u9762\u767d\u304b\u3063\u305f\u3002\n\u8d85\u9577\u3044\u3051\u3069\u3002\n\u3044\u3084\u3001\u9577\u3059\u304e\u3066\u3088\u304f\u308f\u304b\u3089\u3093\u3002\n\n\u6c17\u3065\u304d\n\u3055\u3089\u3063\u3068\u5168\u4f53\u3092\u773a\u3081\u305f\u3051\u3069\u3042\u307e\u308a\u624b\u304c\u304b\u308a\u304c\u306a\u3044\u2026\n\u3068\u3001\u6c17\u306b\u306a\u308b\u30b3\u30e1\u30f3\u30c8\u3092\u767a\u898b\u3002\ngetchar.c L2735\n            /* When 'insertmode' is set, ESC just beeps in Insert\n             * mode.  Use CTRL-L to make edit() return.\n             * For the command line only CTRL-C always breaks it.\n             * For the cmdline window: Alternate between ESC and\n             * CTRL-C: ESC for most situations and CTRL-C to close the\n             * cmdline window. */\n            if (p_im && (State & INSERT))\n            c = Ctrl_L;\n            else if ((State & CMDLINE)\n#ifdef FEAT_CMDWIN\n                || (cmdwin_type > 0 && tc == ESC)\n#endif\n                )\n            c = Ctrl_C;\n            else\n            c = ESC;\n#ifdef FEAT_CMDWIN\n            tc = c;\n#endif\n            break;\n\n\u3053\u3053\u306e\u51e6\u7406\u81ea\u4f53\u304c\u95a2\u4fc2\u3042\u308b\u304b\u306f\u308f\u304b\u3089\u306a\u3044\u3093\u3060\u3051\u3069\u3001\u30b3\u30de\u30f3\u30c9\u30e9\u30a4\u30f3\u3067\u306fCTRL-C\u3060\u3051\u304c\u5e38\u306b\u30d6\u30ec\u30a4\u30af\u3059\u308b\u3063\u3066\u66f8\u3044\u3066\u3042\u308b\u306e\u304c\u5f15\u3063\u304b\u304b\u308b\u3002\nESC\u306f\u5e38\u306b\u306f\u30d6\u30ec\u30a4\u30af\u3057\u306a\u3044\u306e\u304b\u3002\n\u3053\u3053\u3067\u3082\u3046\u4e00\u56de\u30b3\u30de\u30f3\u30c9\u30e9\u30a4\u30f3\u30e2\u30fc\u30c9\u3067\u306e\u30b3\u30de\u30f3\u30c9\u78ba\u5b9a\u51e6\u7406\u306e\u3068\u3053\u308d\u3092\u898b\u3066\u307f\u308b\u3002\nex_getln.c L787\n    if (c == '\\n' || c == '\\r' || c == K_KENTER || (c == ESC\n            && (!KeyTyped || vim_strchr(p_cpo, CPO_ESC) != NULL)))\n    {\n\n\u3042\u3001\u78ba\u304b\u306bESC\u3067\u3082\u3001\u306a\u306b\u306a\u306b\uff1f\nKeyTyped\u3058\u3083\u306a\u3044\u304b\u307e\u305f\u306fp_cpo\u304cCPO_ESC\u3068\u4e00\u7dd2\u304b\u3069\u3046\u304b\u898b\u3066\u308b\u306e\u304b\u3053\u308c\u306f\uff1f\n\u3068\u308a\u3042\u3048\u305aKeyTyped\u3092\u3002\ngrep\u3057\u3066\u307f\u308b\u3068\u3055\u3063\u304d\u307e\u3067\u898b\u3066\u305fgetchar.c\u3067\u3082\u4f55\u56de\u304b\u8a2d\u5b9a\u3055\u308c\u3066\u308b\u307f\u305f\u3044\u3002\n\u6539\u3081\u3066\u898b\u3066\u307f\u308b\u3068\u3001vgetorpeek()\u306e\u8aac\u660e\u306b\u3082\u66f8\u3044\u3066\u3042\u3063\u305f\u3002\nif \"advance\" is TRUE (vgetc()):\nReally get the character.\nKeyTyped is set to TRUE in the case the user typed the key.\nKeyStuffed is TRUE if the character comes from the stuff buffer.\n\n\u3075\u3080\u3001\u30e6\u30fc\u30b6\u304c\u305d\u306e\u30ad\u30fc\u3092\u30bf\u30a4\u30d7\u3057\u305f\u304b\u3069\u3046\u304b\u3002\n\u3068\u3001\u3064\u307e\u308a\u307e\u3068\u3081\u308b\u3068\u3001\u30b3\u30de\u30f3\u30c9\u30e9\u30a4\u30f3\u30e2\u30fc\u30c9\u3067\u306f\u30de\u30c3\u30d4\u30f3\u30b0\u3067ESC\u306b\u306a\u308b\u3068KeyTyped\u304cFALSE\u306b\u306a\u308a\u3001\u6539\u884c\u3068\u540c\u3058\u51e6\u7406\u306b\u306a\u308b\u3002\n\u305d\u3046\u3044\u3046\u3053\u3068\u304b\u3002\n\u3061\u306a\u307f\u306b\u3053\u3053\u3067\u30bb\u30c3\u30c8\u3055\u308c\u3066\u308b\u307f\u305f\u3044\u3002\n\u3084\u3063\u3071\u308a\u30de\u30c3\u30d4\u30f3\u30b0\u3055\u308c\u3066\u308b\u3068FALSE\u306b\u306a\u308b\u611f\u3058\u3002\ngetchar.c L2369\n                  /* When there was a matching mapping and no\n                   * termcode could be replaced after another one,\n                   * use that mapping (loop around). If there was\n                   * no mapping use the character from the\n                   * typeahead buffer right here. */\n                  if (mp == NULL)\n                  {\n/*\n * get a character: 2. from the typeahead buffer\n */\n                c = typebuf.tb_buf[typebuf.tb_off] & 255;\n                if (advance)    /* remove chars from tb_buf */\n                {\n                    cmd_silent = (typebuf.tb_silent > 0);\n                    if (typebuf.tb_maplen > 0)\n                    KeyTyped = FALSE;\n                    else\n                    {\n                    KeyTyped = TRUE;\n                    /* write char to script file(s) */\n                    gotchars(typebuf.tb_buf\n                             + typebuf.tb_off, 1);\n                    }\n                    KeyNoremap = typebuf.tb_noremap[\n                                  typebuf.tb_off];\n                    del_typebuf(1, 0);\n                }\n                break;      /* got character, break for loop */\n                  }\n\n<C-j>\u306fnewline\u306e\u610f\u5473\u304c\u3042\u308b\u304b\u3089\u305d\u308c\u3067\u30b3\u30de\u30f3\u30c9\u304c\u78ba\u5b9a\u3055\u308c\u3066\u308b\u3082\u306e\u3060\u3068\u601d\u3063\u3066\u305f\u3093\u3060\u3051\u3069\u3002\n\u5b9f\u9a13\u3057\u3066\u307f\u305f\u3002\ncnoremap <C-j> <C-c>\ncnoremap i <ESC>\n\n\u304a\u304a\uff01\uff01\u76f4\u63a5<C-c>\u306b\u30de\u30c3\u30d7\u3059\u308c\u3070\u30ad\u30e3\u30f3\u30bb\u30eb\u3055\u308c\u308b\uff01\n\u305d\u3057\u3066<C-j>\u4ee5\u5916\u306e\u30ad\u30fc\u3067\u3082<ESC>\u306b\u30de\u30c3\u30d7\u3059\u308c\u3070\u304a\u69cb\u3044\u7121\u304f\u30b3\u30de\u30f3\u30c9\u5b9f\u884c\u3055\u308c\u308b\u3053\u3068\u304c\u308f\u304b\u3063\u305f\uff01\uff01\n\u3081\u3067\u305f\u3044 (\u307e\u308b\uff12\u65e5\u304b\u304b\u3063\u305f\u3051\u3069)\n\n\u308f\u304b\u3063\u305f\u3053\u3068\n\n\u30b3\u30de\u30f3\u30c9\u30e9\u30a4\u30f3\u30e2\u30fc\u30c9\u3067\u306f<ESC>\u306b\u30de\u30c3\u30d4\u30f3\u30b0\u3055\u308c\u305f\u3082\u306e\u306f\u3069\u3093\u306a\u3082\u306e\u3067\u3082\u78ba\u5b9a\u51e6\u7406\u306b\u306a\u308b\u3002\n\n<C-c>\u306f\u30de\u30c3\u30d4\u30f3\u30b0\u306e\u7d50\u679c\u3067\u3042\u3063\u3066\u3082\u3001\u78ba\u5b9a\u3059\u308b\u51e6\u7406\u306b\u306f\u5165\u3089\u306a\u3044\u3002\n\n<ESC>\u3078\u306e\u30de\u30c3\u30d4\u30f3\u30b0\u306e\u65b0\u5e38\u8b58\uff08\u79c1\u304c\u77e5\u3089\u306a\u304b\u3063\u305f\u3060\u3051\u304b\uff09\n\nnoremap  <C-j> <ESC>\ninoremap <C-j> <ESC>\ncnoremap <C-j> <C-c>\n\n\n\n\u307e\u3068\u3081\n\u306f\u3044\u3001\u304a\u3064\u304b\u308c\u3055\u307e\u3067\u3057\u305f\u3002\n\u5b8c\u5168\u306b\u898b\u5207\u308a\u51fa\u767a\u3060\u3063\u305f\u306e\u3067\u30aa\u30c1\u307e\u3067\u884c\u304f\u304b\u5fc3\u914d\u3067\u3057\u305f\u304c\u306a\u3093\u3068\u304b\u7dba\u9e97\u306b\u7d42\u308f\u308b\u3053\u3068\u304c\u3067\u304d\u305f\u3068\u601d\u3044\u307e\u3059\u3002\nVim\u306b\u9650\u3089\u306a\u3044\u3067\u3059\u304c\u3001\u82f1\u8a9e\u3055\u3048\u308f\u304b\u308c\u3070\u3053\u306e\u3088\u3046\u306b\u30bd\u30fc\u30b9\u3092\u8aad\u3093\u3067\u3044\u3051\u308b\u305e\u3068\u3044\u3046\u3053\u3068\u304c\u4f1d\u308f\u3063\u305f\u3089\u3044\u3044\u3068\u601d\u3044\u307e\u3059\u3002\n\u9593\u9055\u3063\u3066\u3044\u308b\u3068\u3053\u308d\u3082\u3042\u308b\u3068\u601d\u3046\u306e\u3067\u3064\u3063\u3053\u307f\u306a\u3069\u305c\u3072\u6559\u3048\u3066\u3044\u305f\u3060\u3051\u308c\u3070\u3068\u601d\u3044\u307e\u3059\u3002\n\u3053\u3093\u306b\u3061\u306f\u3001Vim\u306eplugin\u3072\u3068\u3064\u3082\u66f8\u3044\u305f\u3053\u3068\u306a\u3044\u521d\u5fc3\u8005\u3067\u3059\u3002\n\u3053\u306e\u8a18\u4e8b\u306fQiita Vim (\u305d\u306e2) Advent Calendar 2016 6\u65e5\u76ee\u3001Vim\u306e\u30bd\u30fc\u30b9\u30b3\u30fc\u30c9\u3092\u8aad\u3082\u3046\u3068\u3044\u3046\u8a18\u4e8b\u3067\u3059\u3002\nVim\u306b\u3082\u3063\u3068\u8fd1\u3065\u304d\u305f\u3044\u3068\u3044\u3046\u601d\u3044\u3067\u66f8\u304d\u307e\u3057\u305f\uff08\u9069\u5f53\uff09\u3002\n\u30aa\u30fc\u30d7\u30f3\u30bd\u30fc\u30b9\u306e\u30bd\u30fc\u30b9\u3092\u8aad\u3080\u3068\u304b\u306f\u62b5\u6297\u304c\u3042\u308b\u306a\u3093\u3066\u3044\u3046\u4eba\u306b\u8aad\u3093\u3067\u3082\u3089\u3048\u308b\u3068\u5b09\u3057\u3044\u3067\u3059\u3002\n\n\u8ab2\u984c\n----\n\n\u307f\u306a\u3055\u3093\u306f`<ESC>`\u306f\u306a\u306b\u3067\u5165\u529b\u3057\u3066\u3044\u307e\u3059\u304b\uff1f\u79c1\u306f`<C-j>`\u3092\u4f7f\u3063\u3066\u3044\u307e\u3059\u3002\n\u305d\u3046\u3067\u3059\u3001\u30de\u30c3\u30d4\u30f3\u30b0\u3057\u3066\u308b\u306e\u3067\u3059\u3002\n\n\u3088\u304f\u4f7f\u308f\u308c\u3066\u3044\u308b\u30de\u30c3\u30d4\u30f3\u30b0\u306e\u3088\u3046\u306a\u6c17\u304c\u3057\u307e\u3059\u304c\u3001\u3072\u3068\u3064\u554f\u984c\u304c\u3042\u308b\u306e\u3067\u3059\u3002\n\u30ce\u30fc\u30de\u30eb\u30e2\u30fc\u30c9\u6642\u306b`:`\u62bc\u3057\u305f\u6642\u306e\u3042\u306e\u72b6\u614b(\u30b3\u30de\u30f3\u30c9\u30e9\u30a4\u30f3\u30e2\u30fc\u30c9\u3068\u3044\u3046\u3089\u3057\u3044)\u304b\u3089`<ESC>`\u3092\u62bc\u3059\u3068\u30ad\u30e3\u30f3\u30bb\u30eb\u3057\u3066\u30ce\u30fc\u30de\u30eb\u30e2\u30fc\u30c9\u306b\u623b\u308a\u307e\u3059\u304c\u3001`<C-j>`\u3092\u62bc\u3059\u3068\u30b3\u30de\u30f3\u30c9\u3092\u5b9f\u884c\u3057\u3066\u3057\u307e\u3046\u306e\u3067\u3059\u3002\n\n\u8abf\u3079\u3066\u307f\u308b\u3068\u3001\u30de\u30c3\u30d4\u30f3\u30b0\u306f\u3061\u3083\u3093\u3068\u3067\u304d\u3066\u3044\u308b\u3088\u3046\u3067\u3059\u3057\u3001\u3082\u3068\u3082\u3068\u306e\u30de\u30c3\u30d4\u30f3\u30b0\u3092\u6d88\u305d\u3046\u3068unmap\u3057\u3066\u3082\u30c0\u30e1\u307f\u305f\u3044\u3067\u3059\u3002\n\n`<C-j>`\u306f\u5b8c\u5168\u306a`<ESC>`\u306b\u306f\u306a\u308c\u306a\u3044\u3093\u3067\u3057\u3087\u3046\u304b\uff1f\n\u305d\u308c\u3067\u306f\u3053\u308c\u3092\u984c\u6750\u306bVim\u306e\u30bd\u30fc\u30b9\u3092\u79c1\u304c\u306f\u3058\u3081\u3066\u898b\u3066\u307f\u3066\u3044\u3063\u305f\u69d8\u5b50\u3092\u5fc3\u306e\u58f0\u3068\u5171\u306b\u7d39\u4ecb\u3057\u307e\u3057\u3087\u3046\u3002\n\u30bd\u30fc\u30b9\u3092\u521d\u3081\u3066\u8aad\u3080\u3068\u3044\u3046\u306e\u304c\u30c6\u30fc\u30de\u306a\u306e\u3067\u307e\u3068\u307e\u308a\u3088\u308a\u3082\u6642\u7cfb\u5217\u3092\u512a\u5148\u3057\u3066\u65e5\u8a18\u306e\u3088\u3046\u306b\u66f8\u304d\u307e\u3057\u305f\u3002\n\n\uff08\u4eca\u56de\u306f\u30d0\u30fc\u30b8\u30e7\u30f3\u306f\u3042\u307e\u308a\u95a2\u4fc2\u306a\u3055\u305d\u3046\u306a\u306e\u3067\u30bd\u30fc\u30b9\u306f\u308f\u304b\u308a\u3084\u3059\u304fv8.0.0000\u306e\u3082\u306e\u306b\u3057\u307e\u3057\u305f\u3002\uff09\n\n* * * * * * *\n\nVim\u306e\u30bd\u30fc\u30b9\u30b3\u30fc\u30c9\u3092\u3068\u3063\u3066\u304f\u308b\n-----------------------------\n\nVim\u306e\u30bd\u30fc\u30b9\u306f[Github](https://github.com/vim/vim)\u306b\u4e0a\u304c\u3063\u3066\u3044\u308b\u307f\u305f\u3044\u3002\n\n~~~ console\n% ls\nappveyor.yml     farsi/    nsis/       README.md   src/          vimtutor.bat\nconfigure*       Filelist  pixmaps/    README.txt  tools/        vimtutor.com*\nCONTRIBUTING.md  Makefile  READMEdir/  runtime/    uninstal.txt\n~~~\n\n\u3075\u3080\u3002\n\n\u53d6\u3063\u639b\u304b\u308a\u304c\u307b\u3057\u3044\u306e\u3067\u4eca\u308f\u304b\u3063\u3066\u3044\u308b\u60c5\u5831\u3068\u3044\u3048\u3070\u30b3\u30de\u30f3\u30c9\u30e9\u30a4\u30f3\u3068\u3044\u3046\u30e2\u30fc\u30c9\u3067\u8d77\u3053\u308b\u3063\u3066\u3053\u3068\u3002\n\n\u60c5\u5831\u53ce\u96c6\n--------\n\n\u3068\u308a\u3042\u3048\u305asrc\u306b\u79fb\u52d5\u3057\u3066\u3001\u304a\u3082\u3080\u308d\u306bgrep\u3002\n\n~~~ console\n% cd src\n% grep -r command-line\nscreen.c:     * 1. Add the cmdwin_type for the command-line window\nscreen.c:     * 1. Add the cmdwin_type for the command-line window\nscreen.c:           /* account for first command-line character in rightleft mode */\nINSTALLpc.txt:This contains the command-line tools (compiler, linker, CRT headers,\nnormal.c:#define NV_NCW     0x200       /* not allowed in command-line window */\nnormal.c: * \"q:\", \"q/\", \"q?\": edit command-line in command-line window.\ngui_gtk_x11.c: * Parse the GUI related command-line arguments.  Any arguments used are\ngui_w32.c: * Parse the GUI related command-line arguments.  Any arguments used are\ngui_x11.c: * Parse the GUI related command-line arguments.  Any arguments used are\nmain.c: * Also used to handle commands in the command-line window, until the window\nmain.c:    int          cmdwin,     /* TRUE when working in the command-line window */\nui.c: * command-line and in the cmdline window.\nui.c:       /* A click outside the command-line window: Use modeless\nglobals.h:EXTERN char_u e_cmdwin[]      INIT(= N_(\"E11: Invalid in command-line window; <CR> executes, CTRL-C quits\"));\nterm.c: * command-line, and for building the \"Ambiguous mapping...\" error message.\nterm.c:    int          expmap)  /* TRUE when expanding mappings on command-line */\nbuffer.c:    /* don't read in if there are files on the command-line or if writing: */\nkeymap.h:    , KE_CMDWIN                /* open command-line window from Command-line Mode */\nex_getln.c: * Used by CTRL-R command in command-line mode.\nex_getln.c:    /* only expansion for ':', '>' and '=' command-lines */\nex_getln.c: * Get the current command-line type.\nex_getln.c:    /* Create a window for the command-line buffer. */\nex_getln.c:    /* Create the command-line buffer empty. */\nex_getln.c:    /* Replace the empty last line with the current command-line and put the\nex_getln.c:     /* Avoid command-line window first character being concealed. */\npo/fi.po:msgid \"E11: Invalid in command-line window; <CR> executes, CTRL-C quits\"\npo/zh_CN.po:msgid \"E11: Invalid in command-line window; <CR> executes, CTRL-C quits\"\n[...]\n~~~\n\npo\u30d5\u30a1\u30a4\u30eb\u306f\u591a\u5206\u7ffb\u8a33\u3068\u304b\u306a\u306e\u3067\u5b9f\u8cea\u51fa\u3066\u304d\u305f\u306e\u306f\u6570\u5341\u884c\u3002\n\ncmdline\u3068\u3044\u3046\u8868\u8a18\u3082\u898b\u3064\u304b\u3063\u305f\u305e\n\n~~~ console\n% grep -r cmdline | wc -l\n836\n~~~\n\n800\u884c\u304b\u3001\u3080\u30fc\n\n~~~ console\n% grep -r \"command line\" | grep -v po/ | wc -l \n263\n~~~\n\n\u3075\u3080\u3002\n\u3053\u306e\u3050\u3089\u3044\u306e\u91cf\u306a\u3089\u76eegrep\u3067\u3002\n\n\u3053\u306e\u4e2d\u3067\u6c17\u306b\u306a\u308b\u3068\u3053\u3044\u304f\u3064\u304b\u767a\u898b\u3002\n\n~~~ console\n% grep -r \"command line\" | grep -v po/\n[..]\nex_getln.c: * Get an Ex command line for the \":\" command. \n[..]\nREADME.txt:parsing of the \":\" command line and calls do_one_cmd() for each separate\n[..]\n~~~\n\n\u3066\u304bREADME\u306e\u306a\u304b\u306b\u30dd\u30a4\u3053\u3068\u66f8\u3044\u3066\u3093\u306a\uff1f\n\n    COMMAND-LINE MODE\n\n    When typing a \":\", normal_cmd() will call getcmdline() to obtain a line with\n    an Ex command.  getcmdline() contains a loop that will handle each typed\n    character.  It returns when hitting <CR> or <Esc> or some other character that\n    ends the command line mode.\n\ngetcmdline()\u306e\u4e2d\u306b\u5165\u529b\u3055\u308c\u305f\u6587\u5b57\u3092\u53d7\u3051\u53d6\u308b\u30eb\u30fc\u30d7\u304c\u3042\u308b\u3068\u3002\u3053\u308c\u3060\u3002\n\n\u30bd\u30fc\u30b9\u306b\u30c0\u30a4\u30d6\n--------------\n\ngrep\u3057\u3066\u307f\u308b\u3068\u5b9a\u7fa9\u306fex_getln.c L164\u306b\u3042\u308b\u307f\u305f\u3044\u3002\nVim\u3067\u958b\u3044\u3066`for`\u3067\u691c\u7d22\u3002\n\n[ex_getln.c L364](https://github.com/vim/vim/blob/bb76f24af2010943387ce696a7092175b4ecccf2/src/ex_getln.c#L364)\n\n~~~ c\n    /*\n     * Collect the command string, handling editing keys.\n     */\n    for (;;)\n    {\n\tredir_off = TRUE;\t/* Don't redirect the typed command.\n\t\t\t\t   Repeated, because a \":redir\" inside\n~~~\n\n\u3042\u3063\u305f\u3042\u3063\u305f\u3002\n\n~~~ c\n\t/* Get a character.  Ignore K_IGNORE, it should not do anything, such\n\t * as stop completion. */\n\tdo\n\t{\n\t    c = safe_vgetc();\n\t} while (c == K_IGNORE);\n~~~\n\n`c`\u306b\u5165\u529b\u3055\u308c\u305f\u6587\u5b57\u304c\u5165\u308b\u611f\u3058\u3060\u308d\u3046\u3002\n\n\u6c17\u306b\u306a\u308b\u3068\u3053\u308d\u307e\u3067\u8aad\u307f\u98db\u3070\u3057\u3066\u3044\u304f\u3002\n\n[ex_getln.c L787](https://github.com/vim/vim/blob/bb76f24af2010943387ce696a7092175b4ecccf2/src/ex_getln.c#L787)\n\n~~~ c\n\tif (c == '\\n' || c == '\\r' || c == K_KENTER || (c == ESC\n\t\t\t&& (!KeyTyped || vim_strchr(p_cpo, CPO_ESC) != NULL)))\n\t{\n\t    /* In Ex mode a backslash escapes a newline. */\n\t    if (exmode_active\n\t\t    && c != ESC\n\t\t    && ccline.cmdpos == ccline.cmdlen\n\t\t    && ccline.cmdpos > 0\n\t\t    && ccline.cmdbuff[ccline.cmdpos - 1] == '\\\\')\n\t    {\n\t\tif (c == K_KENTER)\n\t\t    c = '\\n';\n\t    }\n\t    else\n\t    {\n\t\tgotesc = FALSE;\t/* Might have typed ESC previously, don't\n\t\t\t\t       truncate the cmdline now. */\n\t\tif (ccheck_abbr(c + ABBR_OFF))\n\t\t    goto cmdline_changed;\n\t\tif (!cmd_silent)\n\t\t{\n\t\t    windgoto(msg_row, 0);\n\t\t    out_flush();\n\t\t}\n\t\tbreak;\n\t    }\n\t}\n~~~\n\n\u3053\u3053\u3067\u306a\u3093\u304b\u6539\u884c\u3068\u304b\u306b\u306a\u3063\u3066\u305f\u5834\u5408\u306f\u78ba\u5b9a\u3059\u308b\u51e6\u7406\u3092\u3084\u3063\u3066\u308b\u307d\u3044\u306a\u3002\n\n[ex_getln.c L1158](https://github.com/vim/vim/blob/bb76f24af2010943387ce696a7092175b4ecccf2/src/ex_getln.c#L1158)\n\n~~~ c\n\tcase ESC:\t/* get here if p_wc != ESC or when ESC typed twice */\n\tcase Ctrl_C:\n\t\t/* In exmode it doesn't make sense to return.  Except when\n\t\t * \":normal\" runs out of characters. */\n\t\tif (exmode_active\n\t\t\t       && (ex_normal_busy == 0 || typebuf.tb_len > 0))\n\t\t    goto cmdline_not_changed;\n\n\t\tgotesc = TRUE;\t\t/* will free ccline.cmdbuff after\n\t\t\t\t\t   putting it in history */\n\t\tgoto returncmd;\t\t/* back to cmd mode */\n~~~\n\n\u30b3\u30e1\u30f3\u30c8\u306b\u3042\u308b`p_wc`\u3068\u3044\u3046\u306e\u306f\u3001\u8abf\u3079\u3066\u307f\u308b\u3068\u3001\n\n~~~ bash\n% grep -r p_wc\noption.h:EXTERN long    p_wc;           /* 'wildchar' */\n~~~\n\noption.h\u306b\u5b9a\u7fa9\u3055\u308c\u3066\u3044\u3066\u3001\u30aa\u30d7\u30b7\u30e7\u30f3\u306ewildchar\u3092\u4fdd\u6301\u3057\u3066\u3044\u308b\u5909\u6570\u307d\u3044\u3002\nvim\u306e\u30aa\u30d7\u30b7\u30e7\u30f3\u306f`p_`\u3063\u3066\u540d\u524d\u3067extern\u3055\u308c\u3066\u308b\u5909\u6570\u304c\u3044\u3063\u3071\u3044\u3042\u308b\u307f\u305f\u3044\u3002\nwildchar\u304c`<ESC>`\u3060\u3063\u305f\u3089\u3053\u308c\u4ee5\u524d\u306b\u51e6\u7406\u3055\u308c\u308b\u307f\u305f\u3044\u3060\u3051\u3069\u30c7\u30d5\u30a9\u30eb\u30c8\u3067\u306f`<Tab>`\u3060\u306d\u3002\n\u306a\u306e\u3067\u3053\u3053\u304c\u30ad\u30e3\u30f3\u30bb\u30eb\u306e\u51e6\u7406\u3063\u307d\u3044\u3002\n\n\u3067\u4e0a\u306e`K_KENTER`\u3068\u304b`ESC`\u3001`Ctrl_C`\u306f\u3001\u305d\u308c\u305e\u308cgrep\u3067\u8abf\u3079\u3066\u307e\u3068\u3081\u308b\u3068\u3001\n\n~~~\nkeymap.h:#define K_KENTER       TERMCAP2KEY('K', 'A')   /* keypad Enter */\nascii.h:#define ESC             '\\033'\nascii.h:#define ESC             '\\x27'\nascii.h:#define Ctrl_C          3\nascii.h:#define Ctrl_C          0x03\n~~~\n\nESC\u3068\u304b\uff12\u56de\u3042\u308b\u3093\u3067\u3059\u3051\u3069\u3063\u3066ascii.h\u3092\u95a2\u4fc2\u3042\u308b\u90e8\u5206\u3060\u3051\u306b\u7701\u7565\u3059\u308b\u3068\u3053\u3093\u306a\u611f\u3058\u306b\u3002\n\n~~~ c\n[..]\n/*\n * Definitions of various common control characters.\n * For EBCDIC we have to use different values.\n */\n\n#ifndef EBCDIC\n\n/* IF_EB(ASCII_constant, EBCDIC_constant) */\n[..]\n#define ESC\t\t'\\033'\n[..]\n#define Ctrl_C\t\t3\n[..]\n#else\n\n/* EBCDIC */\n\n[..]\n#define ESC\t\t'\\x27'\n#define Ctrl_C\t\t0x03\n[..]\n#endif /* defined EBCDIC */\n[..]\n~~~\n\n\u307e\u3041\u306a\u3093\u304bEBCDIC\u3068\u304b\u3044\u3046\u6587\u5b57\u30bb\u30c3\u30c8\u7528\u306e\u5b9a\u6570\u3067\u307e\u3041\u3069\u3063\u3061\u306b\u3057\u308d\u5b9a\u6570\u3002\n\n\u3055\u3089\u306b\u6df1\u307f\u3078\n------------\n\n\u305d\u3046\u3059\u308b\u3068\u5165\u529b\u3055\u308c\u305f\u6587\u5b57\u3092\u53d7\u3051\u53d6\u308b`c = safe_vgetc();`\u306b\u3042\u3063\u305f`safe_vgetc()`\u306e\u6319\u52d5\u3092\u8abf\u3079\u306a\u3044\u3068\u306a\u3002\n\n[getchar.c L1793](https://github.com/vim/vim/blob/bb76f24af2010943387ce696a7092175b4ecccf2/src/getchar.c#L1793)\n\n~~~ c\n/*\n * Like vgetc(), but never return a NUL when called recursively, get a key\n * directly from the user (ignoring typeahead).\n */\n    int\nsafe_vgetc(void)\n{\n    int\tc;\n\n    c = vgetc();\n    if (c == NUL)\n\tc = get_keystroke();\n    return c;\n}\n~~~\n\n\u306f\u3044\u3002`vgetc()`\u3078\u3002\n\n[getchar.c L1552](https://github.com/vim/vim/blob/bb76f24af2010943387ce696a7092175b4ecccf2/src/getchar.c#L1552)\n\n~~~ c\n/*\n * Get the next input character.\n * Can return a special key or a multi-byte character.\n * Can return NUL when called recursively, use safe_vgetc() if that's not\n * wanted.\n * This translates escaped K_SPECIAL and CSI bytes to a K_SPECIAL or CSI byte.\n * Collects the bytes of a multibyte character into the whole character.\n * Returns the modifiers in the global \"mod_mask\".\n */\n    int\nvgetc(void)\n{\n~~~\n\n\u6c17\u306b\u306a\u308b\u3068\u3053\u308d\u3092\u63a2\u3057\u306a\u304c\u3089\u773a\u3081\u3066\u307f\u3088\u3046\u3002\n\n~~~ c\n    /*\n     * If a character was put back with vungetc, it was already processed.\n     * Return it directly.\n     */\n    if (old_char != -1)\n    {\n~~~\n\n\u3075\u30fc\u3093vungetc\u306d\u3001\u307e\u3041\u666e\u901a\u306f`old_char`\u306f\u5165\u3063\u3066\u306a\u3044\u3093\u3067\u3057\u3087\u3002\n\n~~~ c\n    }\n    else\n    {\n      mod_mask = 0x0;\n      last_recorded_len = 0;\n      for (;;)\t\t\t/* this is done twice if there are modifiers */\n      {\n        int did_inc = FALSE;\n\n        if (mod_mask)\t\t/* no mapping after modifier has been read */\n        {\n            ++no_mapping;\n            ++allow_keys;\n            did_inc = TRUE;\t/* mod_mask may change value */\n        }\n        c = vgetorpeek(TRUE);\n~~~\n\n\u307e\u305f`c`\u306b\u5165\u529b\u3092\u5165\u308c\u3066\u308b\u3093\u3060\u306a\uff1f\n\u3057\u304b\u3057\u307e\u305f\u95a2\u6570\u51fa\u3066\u304d\u305f\u306a\u3002\n\n~~~ c\n        /* a keypad or special function key was not mapped, use it like\n        * its ASCII equivalent */\n        switch (c)\n        {\n            case K_KPLUS:\t\tc = '+'; break;\n            case K_KMINUS:\t\tc = '-'; break;\n~~~\n\n\u30ad\u30fc\u3068\u6587\u5b57\u306e\u5bfe\u5fdc\u3057\u3066\u308b\u3068\u3053\u304c\u3042\u3063\u305f\u3051\u3069\u4eca\u56de\u95a2\u4fc2\u3042\u308b\u30ad\u30fc\u306f\u306a\u3044\u3002\n\n~~~ c\n    return c;\n}\n~~~\n\n\u305d\u306e\u307e\u307ec\u304c\u8fd4\u308b\u307f\u305f\u3044\u3002\n\n\u3058\u3083\u3042c\u306b\u5165\u3063\u3066\u305f`vgetorpeek()`\u306f\uff1f\n\n\u3064\u3044\u306b\u771f\u9ac4\u3078?\n-------------\n\n[getchar.c L1909](https://github.com/vim/vim/blob/bb76f24af2010943387ce696a7092175b4ecccf2/src/getchar.c#L1909)\n\n~~~ c\n/*\n * get a character:\n * 1. from the stuffbuffer\n *\tThis is used for abbreviated commands like \"D\" -> \"d$\".\n *\tAlso used to redo a command for \".\".\n * 2. from the typeahead buffer\n *\tStores text obtained previously but not used yet.\n *\tAlso stores the result of mappings.\n *\tAlso used for the \":normal\" command.\n * 3. from the user\n *\tThis may do a blocking wait if \"advance\" is TRUE.\n *\n * if \"advance\" is TRUE (vgetc()):\n *\tReally get the character.\n *\tKeyTyped is set to TRUE in the case the user typed the key.\n *\tKeyStuffed is TRUE if the character comes from the stuff buffer.\n * if \"advance\" is FALSE (vpeekc()):\n *\tjust look whether there is a character available.\n *\n * When \"no_mapping\" is zero, checks for mappings in the current mode.\n * Only returns one byte (of a multi-byte character).\n * K_SPECIAL and CSI may be escaped, need to get two more bytes then.\n */\n    static int\nvgetorpeek(int advance)\n{\n~~~\n\n\u3046\u30fc\u3093\u9577\u305d\u3046\u3001\u3067\u3082\u3053\u3053\u304c\u672c\u8cea\u3063\u307d\u3044\u306e\u3067\u304c\u3093\u3070\u308d\u3046\u3002\n`advance`\u306f\u30d0\u30c3\u30d5\u30a1\u30fc\u3092\u3059\u3059\u3081\u308b\u304b\u3069\u3046\u304b\u3067\u3001\u547c\u3073\u51fa\u3057\u5143\u3067\u306fTRUE\u306b\u306a\u3063\u3066\u305f\u3002\n\n~~~ c\n/*\n * get a character: 1. from the stuffbuffer\n */\n\tif (typeahead_char != 0)\n\t{\n\t    c = typeahead_char;\n\t    if (advance)\n\t\ttypeahead_char = 0;\n\t}\n\telse\n\t    c = read_readbuffers(advance);\n~~~\n\n\u307e\u305fc\u306b\u8aad\u307f\u8fbc\u3093\u3067\u308b\u306a\uff1f\n\n\u3042 \u30bf\u30a4\u30dd\u898b\u3064\u3051\u305f(l\u3060\u3051\u5c0f\u6587\u5b57) [getchar.c L2012](https://github.com/vim/vim/blob/bb76f24af2010943387ce696a7092175b4ecccf2/src/getchar.c#L2012)\n\n~~~\n\t\t * needed for CTRL-W CTRl-] to open a fold, for example. */\n~~~\n\nread_readbuffers\u306f\u2026\n\n[getchar.c L360](https://github.com/vim/vim/blob/bb76f24af2010943387ce696a7092175b4ecccf2/src/getchar.c#L360)\n\n~~~ c\n/*\n * Get one byte from the read buffers.  Use readbuf1 one first, use readbuf2\n * if that one is empty.\n * If advance == TRUE go to the next char.\n * No translation is done K_SPECIAL and CSI are escaped.\n */\n    static int\nread_readbuffers(int advance)\n{\n    int c;\n\n    c = read_readbuf(&readbuf1, advance);\n    if (c == NUL)\n\tc = read_readbuf(&readbuf2, advance);\n    return c;\n}\n~~~\n\n\u30d0\u30c3\u30d5\u30a1\u304b\u3089\u8aad\u307f\u3053\u3080\u3060\u3051\u306e\u3082\u306e\u3063\u307d\u3044\n\nvgetorpeek()\u306b\u623b\u3063\u3066\u5148\u3092\u8aad\u3093\u3067\u3044\u304f\u3002\n\n[getchar.c L2020](https://github.com/vim/vim/blob/bb76f24af2010943387ce696a7092175b4ecccf2/src/getchar.c#L2020)\n\n~~~ c\n\t    /*\n\t     * Loop until we either find a matching mapped key, or we\n\t     * are sure that it is not a mapped key.\n\t     * If a mapped key sequence is found we go back to the start to\n\t     * try re-mapping.\n\t     */\n\t    for (;;)\n\t    {\n~~~\n\n\u3042\u30fc\u3001\u3053\u3053\u3067\u30de\u30c3\u30d4\u30f3\u30b0\u51e6\u7406\u3057\u3066\u308b\u3093\u3060\u306d\uff01\uff08\u611f\u52d5\uff09\nnoremap\u3058\u3083\u306a\u3044\u3068\u518d\u8d77\u30de\u30c3\u30d4\u30f3\u30b0\u3059\u308b\u304b\u3089\u306d\u3002\n\u30de\u30c3\u30d4\u30f3\u30b0\u306e\u9014\u4e2d\u3060\u3063\u305f\u5834\u5408(`<C-w>`\u62bc\u3057\u305f\u3042\u3068\u3068\u304b)\u306f\u3053\u3053\u306e\u30eb\u30fc\u30d7\u3067\u6b62\u307e\u3063\u3066\u308b\u3093\u3060\u306d\u3001\u306a\u3093\u304b\u5b09\u3057\u3044\u3002\n\u3061\u306a\u307f\u306b\u6b62\u307e\u3063\u3066\u308b\u6642\u306b`<C-c>`\u3068\u304b\u304c\u6765\u308b\u3068`got_int`(interrupt\u306e\u610f)\u304c`TRUE`\u306b\u306a\u3063\u3066\u30ad\u30e3\u30f3\u30bb\u30eb\u3055\u308c\u308b\u307f\u305f\u3044\u3002\n\n\u3053\u306e\u4e2d\u306f\u7d50\u69cb\u8208\u5473\u6df1\u3044\u3068\u3053\u308d\u304c\u3042\u3063\u3066\u3001\u30b3\u30e1\u30f3\u30c8\u304c\u3044\u3063\u3071\u3044\u3042\u308b\u306e\u3067\u63a2\u7d22\u3059\u308b\u306e\u9762\u767d\u304b\u3063\u305f\u3002\n\u8d85\u9577\u3044\u3051\u3069\u3002\n\u3044\u3084\u3001\u9577\u3059\u304e\u3066\u3088\u304f\u308f\u304b\u3089\u3093\u3002\n\n\u6c17\u3065\u304d\n------\n\n\u3055\u3089\u3063\u3068\u5168\u4f53\u3092\u773a\u3081\u305f\u3051\u3069\u3042\u307e\u308a\u624b\u304c\u304b\u308a\u304c\u306a\u3044\u2026\n\u3068\u3001\u6c17\u306b\u306a\u308b\u30b3\u30e1\u30f3\u30c8\u3092\u767a\u898b\u3002\n\n[getchar.c L2735](https://github.com/vim/vim/blob/bb76f24af2010943387ce696a7092175b4ecccf2/src/getchar.c#L2735)\n\n~~~ c\n\t\t    /* When 'insertmode' is set, ESC just beeps in Insert\n\t\t     * mode.  Use CTRL-L to make edit() return.\n\t\t     * For the command line only CTRL-C always breaks it.\n\t\t     * For the cmdline window: Alternate between ESC and\n\t\t     * CTRL-C: ESC for most situations and CTRL-C to close the\n\t\t     * cmdline window. */\n\t\t    if (p_im && (State & INSERT))\n\t\t\tc = Ctrl_L;\n\t\t    else if ((State & CMDLINE)\n#ifdef FEAT_CMDWIN\n\t\t\t    || (cmdwin_type > 0 && tc == ESC)\n#endif\n\t\t\t    )\n\t\t\tc = Ctrl_C;\n\t\t    else\n\t\t\tc = ESC;\n#ifdef FEAT_CMDWIN\n\t\t    tc = c;\n#endif\n\t\t    break;\n~~~\n\n\u3053\u3053\u306e\u51e6\u7406\u81ea\u4f53\u304c\u95a2\u4fc2\u3042\u308b\u304b\u306f\u308f\u304b\u3089\u306a\u3044\u3093\u3060\u3051\u3069\u3001\u30b3\u30de\u30f3\u30c9\u30e9\u30a4\u30f3\u3067\u306fCTRL-C\u3060\u3051\u304c\u5e38\u306b\u30d6\u30ec\u30a4\u30af\u3059\u308b\u3063\u3066\u66f8\u3044\u3066\u3042\u308b\u306e\u304c\u5f15\u3063\u304b\u304b\u308b\u3002\nESC\u306f\u5e38\u306b\u306f\u30d6\u30ec\u30a4\u30af\u3057\u306a\u3044\u306e\u304b\u3002\n\n\u3053\u3053\u3067\u3082\u3046\u4e00\u56de\u30b3\u30de\u30f3\u30c9\u30e9\u30a4\u30f3\u30e2\u30fc\u30c9\u3067\u306e\u30b3\u30de\u30f3\u30c9\u78ba\u5b9a\u51e6\u7406\u306e\u3068\u3053\u308d\u3092\u898b\u3066\u307f\u308b\u3002\n\n[ex_getln.c L787](https://github.com/vim/vim/blob/bb76f24af2010943387ce696a7092175b4ecccf2/src/ex_getln.c#L787)\n\n~~~ c\n\tif (c == '\\n' || c == '\\r' || c == K_KENTER || (c == ESC\n\t\t\t&& (!KeyTyped || vim_strchr(p_cpo, CPO_ESC) != NULL)))\n\t{\n~~~\n\n\u3042\u3001\u78ba\u304b\u306bESC\u3067\u3082\u3001\u306a\u306b\u306a\u306b\uff1f\n`KeyTyped`\u3058\u3083\u306a\u3044\u304b\u307e\u305f\u306f`p_cpo`\u304c`CPO_ESC`\u3068\u4e00\u7dd2\u304b\u3069\u3046\u304b\u898b\u3066\u308b\u306e\u304b\u3053\u308c\u306f\uff1f\n\n\u3068\u308a\u3042\u3048\u305aKeyTyped\u3092\u3002\n\ngrep\u3057\u3066\u307f\u308b\u3068\u3055\u3063\u304d\u307e\u3067\u898b\u3066\u305fgetchar.c\u3067\u3082\u4f55\u56de\u304b\u8a2d\u5b9a\u3055\u308c\u3066\u308b\u307f\u305f\u3044\u3002\n\n\u6539\u3081\u3066\u898b\u3066\u307f\u308b\u3068\u3001vgetorpeek()\u306e\u8aac\u660e\u306b\u3082\u66f8\u3044\u3066\u3042\u3063\u305f\u3002\n\n    if \"advance\" is TRUE (vgetc()):\n    Really get the character.\n    KeyTyped is set to TRUE in the case the user typed the key.\n    KeyStuffed is TRUE if the character comes from the stuff buffer.\n\n\u3075\u3080\u3001\u30e6\u30fc\u30b6\u304c\u305d\u306e\u30ad\u30fc\u3092\u30bf\u30a4\u30d7\u3057\u305f\u304b\u3069\u3046\u304b\u3002\n\u3068\u3001\u3064\u307e\u308a\u307e\u3068\u3081\u308b\u3068\u3001\u30b3\u30de\u30f3\u30c9\u30e9\u30a4\u30f3\u30e2\u30fc\u30c9\u3067\u306f\u30de\u30c3\u30d4\u30f3\u30b0\u3067ESC\u306b\u306a\u308b\u3068`KeyTyped`\u304cFALSE\u306b\u306a\u308a\u3001\u6539\u884c\u3068\u540c\u3058\u51e6\u7406\u306b\u306a\u308b\u3002\n\u305d\u3046\u3044\u3046\u3053\u3068\u304b\u3002\n\n\u3061\u306a\u307f\u306b\u3053\u3053\u3067\u30bb\u30c3\u30c8\u3055\u308c\u3066\u308b\u307f\u305f\u3044\u3002\n\u3084\u3063\u3071\u308a\u30de\u30c3\u30d4\u30f3\u30b0\u3055\u308c\u3066\u308b\u3068FALSE\u306b\u306a\u308b\u611f\u3058\u3002\n\n[getchar.c L2369](https://github.com/vim/vim/blob/bb76f24af2010943387ce696a7092175b4ecccf2/src/getchar.c#L2369)\n\n~~~ c\n\t\t\t      /* When there was a matching mapping and no\n\t\t\t       * termcode could be replaced after another one,\n\t\t\t       * use that mapping (loop around). If there was\n\t\t\t       * no mapping use the character from the\n\t\t\t       * typeahead buffer right here. */\n\t\t\t      if (mp == NULL)\n\t\t\t      {\n/*\n * get a character: 2. from the typeahead buffer\n */\n\t\t\t\tc = typebuf.tb_buf[typebuf.tb_off] & 255;\n\t\t\t\tif (advance)\t/* remove chars from tb_buf */\n\t\t\t\t{\n\t\t\t\t    cmd_silent = (typebuf.tb_silent > 0);\n\t\t\t\t    if (typebuf.tb_maplen > 0)\n\t\t\t\t\tKeyTyped = FALSE;\n\t\t\t\t    else\n\t\t\t\t    {\n\t\t\t\t\tKeyTyped = TRUE;\n\t\t\t\t\t/* write char to script file(s) */\n\t\t\t\t\tgotchars(typebuf.tb_buf\n\t\t\t\t\t\t\t + typebuf.tb_off, 1);\n\t\t\t\t    }\n\t\t\t\t    KeyNoremap = typebuf.tb_noremap[\n\t\t\t\t\t\t\t      typebuf.tb_off];\n\t\t\t\t    del_typebuf(1, 0);\n\t\t\t\t}\n\t\t\t\tbreak;\t    /* got character, break for loop */\n\t\t\t      }\n~~~\n\n`<C-j>`\u306fnewline\u306e\u610f\u5473\u304c\u3042\u308b\u304b\u3089\u305d\u308c\u3067\u30b3\u30de\u30f3\u30c9\u304c\u78ba\u5b9a\u3055\u308c\u3066\u308b\u3082\u306e\u3060\u3068\u601d\u3063\u3066\u305f\u3093\u3060\u3051\u3069\u3002\n\n\u5b9f\u9a13\u3057\u3066\u307f\u305f\u3002\n\n~~~ vim\ncnoremap <C-j> <C-c>\ncnoremap i <ESC>\n~~~\n\n\u304a\u304a\uff01\uff01\u76f4\u63a5`<C-c>`\u306b\u30de\u30c3\u30d7\u3059\u308c\u3070\u30ad\u30e3\u30f3\u30bb\u30eb\u3055\u308c\u308b\uff01\n\u305d\u3057\u3066`<C-j>`\u4ee5\u5916\u306e\u30ad\u30fc\u3067\u3082`<ESC>`\u306b\u30de\u30c3\u30d7\u3059\u308c\u3070\u304a\u69cb\u3044\u7121\u304f\u30b3\u30de\u30f3\u30c9\u5b9f\u884c\u3055\u308c\u308b\u3053\u3068\u304c\u308f\u304b\u3063\u305f\uff01\uff01\n\n\u3081\u3067\u305f\u3044 (\u307e\u308b\uff12\u65e5\u304b\u304b\u3063\u305f\u3051\u3069)\n\n\u308f\u304b\u3063\u305f\u3053\u3068\n------------\n\n + \u30b3\u30de\u30f3\u30c9\u30e9\u30a4\u30f3\u30e2\u30fc\u30c9\u3067\u306f`<ESC>`\u306b\u30de\u30c3\u30d4\u30f3\u30b0\u3055\u308c\u305f\u3082\u306e\u306f\u3069\u3093\u306a\u3082\u306e\u3067\u3082\u78ba\u5b9a\u51e6\u7406\u306b\u306a\u308b\u3002\n + `<C-c>`\u306f\u30de\u30c3\u30d4\u30f3\u30b0\u306e\u7d50\u679c\u3067\u3042\u3063\u3066\u3082\u3001\u78ba\u5b9a\u3059\u308b\u51e6\u7406\u306b\u306f\u5165\u3089\u306a\u3044\u3002\n + `<ESC>`\u3078\u306e\u30de\u30c3\u30d4\u30f3\u30b0\u306e\u65b0\u5e38\u8b58\uff08\u79c1\u304c\u77e5\u3089\u306a\u304b\u3063\u305f\u3060\u3051\u304b\uff09\n\n~~~ vim\nnoremap  <C-j> <ESC>\ninoremap <C-j> <ESC>\ncnoremap <C-j> <C-c>\n~~~\n\n* * * * * * *\n\n\u307e\u3068\u3081\n------\n\n\u306f\u3044\u3001\u304a\u3064\u304b\u308c\u3055\u307e\u3067\u3057\u305f\u3002\n\n\u5b8c\u5168\u306b\u898b\u5207\u308a\u51fa\u767a\u3060\u3063\u305f\u306e\u3067\u30aa\u30c1\u307e\u3067\u884c\u304f\u304b\u5fc3\u914d\u3067\u3057\u305f\u304c\u306a\u3093\u3068\u304b\u7dba\u9e97\u306b\u7d42\u308f\u308b\u3053\u3068\u304c\u3067\u304d\u305f\u3068\u601d\u3044\u307e\u3059\u3002\nVim\u306b\u9650\u3089\u306a\u3044\u3067\u3059\u304c\u3001\u82f1\u8a9e\u3055\u3048\u308f\u304b\u308c\u3070\u3053\u306e\u3088\u3046\u306b\u30bd\u30fc\u30b9\u3092\u8aad\u3093\u3067\u3044\u3051\u308b\u305e\u3068\u3044\u3046\u3053\u3068\u304c\u4f1d\u308f\u3063\u305f\u3089\u3044\u3044\u3068\u601d\u3044\u307e\u3059\u3002\n\u9593\u9055\u3063\u3066\u3044\u308b\u3068\u3053\u308d\u3082\u3042\u308b\u3068\u601d\u3046\u306e\u3067\u3064\u3063\u3053\u307f\u306a\u3069\u305c\u3072\u6559\u3048\u3066\u3044\u305f\u3060\u3051\u308c\u3070\u3068\u601d\u3044\u307e\u3059\u3002\n", "tags": ["Vim", "C", "\u30aa\u30fc\u30d7\u30f3\u30bd\u30fc\u30b9"]}