{"context": " More than 1 year has passed since last update.Continuing from where we left off in part 3, I want to talk about profiling performance for sufficiently large views.\n\nRetraction\nI made a silly typo with mixin instead of mixins, causing my Pure Render Mixin to not be incorporated into my component. The original should work fine in most cases and there is no need to create your own propEquals. Let this be a lesson to me to avoid programming at 1AM... (I put in a PR for this here. Let's see if it's worthy of being merged.)\n\nAn issue with the original PureRenderMixin...\n\"But hold up, what about components that get recomputed, like the rows in our table? What happens with those? The member properties' refs will be the same, sure, but the props objects themselves will be new objects each time. Why are you telling me to use Pure Render Mixin if it isn't even going to work!?\"\nWe need to actually inspect the source of the pure render mixin and study some JS to determine if this even does what we want (don't worry, we'll just do trial and error to make our point).\nRemember that PureRenderMixin takes our props and state and calls shallowEqual on them:\n// excerpt from ReactComponentWithPureRenderMixin...\nshouldComponentUpdate: function(nextProps, nextState) {\n  return !shallowEqual(this.props, nextProps) ||\n          !shallowEqual(this.state, nextState);\n}\n\nand shallowEqual is defined as such:\nfunction shallowEqual(objA, objB) {\n  if (objA === objB) {\n    return true;\n  }\n  var key;\n  // Test for A's keys different from B.\n  for (key in objA) {\n    if (objA.hasOwnProperty(key) &&\n        (!objB.hasOwnProperty(key) || objA[key] !== objB[key])) {\n      return false;\n    }\n  }\n  // Test for B's keys missing from A.\n  for (key in objB) {\n    if (objB.hasOwnProperty(key) && !objA.hasOwnProperty(key)) {\n      return false;\n    }\n  }\n  return true;\n}\n\nSo this works for components that aren't recomputed or hold on to the same property refs, but the problem becomes quite clear when we do some simple tests:\nvar myArray = [1,2,3,4]\n// undefined\nvar myNumber = 1234\n// undefined\nvar a = { a: myArray, b: myNumber }\n// undefined\nvar b = { a: myArray, b: myNumber }\n// undefined\na === b\n// false\na.a === b.a\n// true\na.b === b.b\n// true\n\nOf course a and b aren't going to be equal, since they are two separate objects. Sure, their properties point to the same references, but this isn't going to work with shallowEqual. For this purpose, I have my own function propsEqual, which I use to compare properties of two objects. Quite literally, shallowEqual  without the top level check.\n// from propsEqual.js\nmodule.exports = function (objA, objB) {\n  var key;\n  // Test for A's keys different from B.\n  for (key in objA) {\n    if (objA.hasOwnProperty(key) &&\n        (!objB.hasOwnProperty(key) || objA[key] !== objB[key])) {\n      return false;\n    }\n  }\n  // Test for B'a keys missing from A.\n  for (key in objB) {\n    if (objB.hasOwnProperty(key) && !objA.hasOwnProperty(key)) {\n      return false;\n    }\n  }\n  return true;\n}\n\n\nProfiling performance\nNot much to really say here other than to stress the importance of using tools like the Timeline tool in Chrome. Let's see what our performance was when we used the Pure Render Mixin didn't use anything (i.e. with our computed elements):\n\nWe were only adding 100 lines and it took 1.4 seconds? Ouch. Now with propsEqual:\n\nMuch better. Remember this is adding 100 rows directly. What about a single row when we have lots of elements?\n\nvs\n\nHope you're getting the picture here. By informing React on how to optionally render the components and properly dealing with references for propsEqual/shallowEqual, we're able to improve performance dramatically.\n\nClosing\nI hope any part of this series of articles was useful to someone. If anything, this helps me by saving me from saying the same things over and over again.\nPlease inform me of any mistakes made through e-mail, twitter, or comments here.\n\nContinuing from where we left off in part 3, I want to talk about profiling performance for sufficiently large views.\n\n# Retraction\n\nI made a silly typo with `mixin` instead of `mixins`, causing my Pure Render Mixin to not be incorporated into my component. The original should work fine in most cases and there is no need to create your own propEquals. Let this be a lesson to me to avoid programming at 1AM... (I put in a PR for this [here](https://github.com/facebook/react/pull/2426). Let's see if it's worthy of being merged.)\n\n\n## An issue with the original PureRenderMixin...\n\n*\"But hold up, what about components that get recomputed, like the rows in our table? What happens with those? The member properties' refs will be the same, sure, but the props objects themselves will be new objects each time. Why are you telling me to use Pure Render Mixin if it isn't even going to work!?\"*\n\nWe need to actually inspect the source of the pure render mixin and study some JS to determine if this even does what we want (don't worry, we'll just do trial and error to make our point).\n\nRemember that PureRenderMixin takes our props and state and calls `shallowEqual` on them:\n\n```js\n// excerpt from ReactComponentWithPureRenderMixin...\nshouldComponentUpdate: function(nextProps, nextState) {\n  return !shallowEqual(this.props, nextProps) ||\n          !shallowEqual(this.state, nextState);\n}\n```\n\nand shallowEqual is defined as such:\n\n```js\nfunction shallowEqual(objA, objB) {\n  if (objA === objB) {\n    return true;\n  }\n  var key;\n  // Test for A's keys different from B.\n  for (key in objA) {\n    if (objA.hasOwnProperty(key) &&\n        (!objB.hasOwnProperty(key) || objA[key] !== objB[key])) {\n      return false;\n    }\n  }\n  // Test for B's keys missing from A.\n  for (key in objB) {\n    if (objB.hasOwnProperty(key) && !objA.hasOwnProperty(key)) {\n      return false;\n    }\n  }\n  return true;\n}\n```\n\nSo this works for components that aren't recomputed or hold on to the same property refs, but the problem becomes quite clear when we do some simple tests:\n\n```js\nvar myArray = [1,2,3,4]\n// undefined\nvar myNumber = 1234\n// undefined\nvar a = { a: myArray, b: myNumber }\n// undefined\nvar b = { a: myArray, b: myNumber }\n// undefined\na === b\n// false\na.a === b.a\n// true\na.b === b.b\n// true\n```\n\nOf course `a` and `b` aren't going to be equal, since they are two separate objects. Sure, their properties point to the same references, but this isn't going to work with shallowEqual. For this purpose, I have my own function `propsEqual`, which I use to compare properties of two objects. Quite literally, shallowEqual  without the top level check.\n\n```js\n// from propsEqual.js\nmodule.exports = function (objA, objB) {\n  var key;\n  // Test for A's keys different from B.\n  for (key in objA) {\n    if (objA.hasOwnProperty(key) &&\n        (!objB.hasOwnProperty(key) || objA[key] !== objB[key])) {\n      return false;\n    }\n  }\n  // Test for B'a keys missing from A.\n  for (key in objB) {\n    if (objB.hasOwnProperty(key) && !objA.hasOwnProperty(key)) {\n      return false;\n    }\n  }\n  return true;\n}\n```\n\n\n## Profiling performance\n\nNot much to really say here other than to stress the importance of using tools like the Timeline tool in Chrome. Let's see what our performance was when we ~~used the Pure Render Mixin~~ didn't use anything (i.e. with our computed elements):\n\n![kobito.1414558053.529165.png](https://qiita-image-store.s3.amazonaws.com/0/42481/e091cd51-f39f-dda9-e246-c2a4eefe6b2c.png \"kobito.1414558053.529165.png\")\n\nWe were only adding 100 lines and it took 1.4 seconds? Ouch. Now with propsEqual:\n\n![kobito.1414557979.203442.png](https://qiita-image-store.s3.amazonaws.com/0/42481/72301416-3578-153c-2830-a542d80bc659.png \"kobito.1414557979.203442.png\")\n\nMuch better. Remember this is adding 100 rows directly. What about a single row when we have lots of elements?\n\n![kobito.1414558245.908874.png](https://qiita-image-store.s3.amazonaws.com/0/42481/55201321-4132-7e23-ee0c-38dcebde87ee.png \"kobito.1414558245.908874.png\")\n\nvs\n\n![kobito.1414558304.451006.png](https://qiita-image-store.s3.amazonaws.com/0/42481/324f7287-7290-e61c-6cc8-838674355eed.png \"kobito.1414558304.451006.png\")\n\nHope you're getting the picture here. By informing React on how to optionally render the components and properly dealing with references for propsEqual/shallowEqual, we're able to improve performance dramatically.\n\n\n## Closing\n\nI hope any part of this series of articles was useful to someone. If anything, this helps me by saving me from saying the same things over and over again.\n\nPlease inform me of any mistakes made through e-mail, twitter, or comments here.\n", "tags": ["reactjs", "flux", "JavaScript"]}