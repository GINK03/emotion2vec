{"context": "Haskell\u98a8\u8a00\u8a9e\u3067\u3042\u308a\u3001\u30b3\u30f3\u30d1\u30a4\u30eb\u3059\u308b\u3068JS\u3092\u51fa\u3057\u3066\u304f\u308c\u308bElm\u3067\u7c21\u5358\u306a\u30ec\u30a4\u30c8\u30ec\u30fc\u30b7\u30f3\u30b0\u3092\u3057\u3066\u307f\u307e\u3057\u305f\u3002\n0.17\u3067\u3060\u3044\u3076\u5909\u308f\u3063\u3066\u3057\u307e\u3044\u307e\u3057\u305f\u304c\u3001\u4f7f\u3044\u3084\u3059\u304f\u306a\u3063\u305f\u304b\u306a\u30fc\u3068\u601d\u3044\u307e\u3059\u3002\n\n\u5b9f\u884c\u65b9\u6cd5\nElm\u81ea\u4f53\u306e\u30a4\u30f3\u30b9\u30c8\u30fc\u30eb\u65b9\u6cd5\u306f\u7701\u304d\u307e\u3059\u3002npm\u306a\u308a\u306a\u3093\u306a\u308a\u3067\u5165\u308c\u3066\u3042\u3052\u3066\u304f\u3060\u3055\u3044\u3002\n\u4ee5\u4e0b\u3001\u30b3\u30f3\u30bd\u30fc\u30eb\u3002\n$ mkdir ray && cd ray\n\n$ vim Main.elm\n\n$ elm-package install elm-lang/html -y\n\n$ elm-package install evancz/elm-graphics -y\n\n$ cat elm-package.json\n{\n    \"version\": \"1.0.0\",\n    \"summary\": \"helpful summary of your project, less than 80 characters\",\n    \"repository\": \"https://github.com/user/project.git\",\n    \"license\": \"BSD3\",\n    \"source-directories\": [\n        \".\"\n    ],\n    \"exposed-modules\": [],\n    \"dependencies\": {\n        \"elm-lang/core\": \"4.0.5 <= v < 5.0.0\",\n        \"elm-lang/html\": \"1.1.0 <= v < 2.0.0\",\n        \"evancz/elm-graphics\": \"1.0.0 <= v < 2.0.0\"\n    },\n    \"elm-version\": \"0.17.0 <= v < 0.18.0\"\n}\n\n$ elm reactor\nelm reactor 0.17.0\nListening on http://localhost:8000/\n\n\n\uff08Main.elm\u306f\u4e0b\u306e\u30b3\u30fc\u30c9\u3092\u30b3\u30d4\u30da\u3057\u3066\u304f\u3060\u3055\u3044\u3002\uff09\nelm reactor\u306e\u3042\u3068\u3001\u30d6\u30e9\u30a6\u30b6\u3067 http://localhost:8000/Main.elm \u306b\u30a2\u30af\u30bb\u30b9\u3059\u308b\u3068\u3001\n\u306a\u3093\u304b\u7403\u3063\u307d\u3044\u306e\u304c\u8868\u793a\u3055\u308c\u308b\u3068\u601d\u3044\u307e\u3059\u3002\n\n\u30b3\u30fc\u30c9\nmodule Main exposing (main)\n\nimport Html.App as App\nimport Html exposing (div, Html)\nimport Color\n\nimport Element as E\nimport Collage as C\n\n\ntype alias Vec = { x: Float , y: Float , z: Float }\ntype alias RGB = { r: Float , g: Float , b: Float }\n\ntype alias Sphere = { pos: Vec , rad: Float , color: RGB }\ntype alias Light = { pos: Vec , color: RGB}\ntype alias Ray = { dir: Vec , pos: Vec }\ntype alias Model = { width: Float , height: Float , sphere: Sphere , lights: List Light }\n\ntype Msg = Init\n\n\ninit : {width: Float, height: Float} -> (Model, Cmd Msg)\ninit {width, height} = \n  let \n    sphere = { pos = initV, rad = 1.0, color = white }\n    light1 = { pos = {x = 3.0, y = -2.0, z = -2.0}, color = blue }\n    light2 = { pos = {x = -3.0, y = 2.0, z = -2.0}, color = red }\n    light3 = { pos = {x = 3.0, y = 2.0, z = -2.0}, color = green }\n    model =  { width = width , height = height , sphere = sphere , lights = [ light1, light2, light3 ] }\n  in (model, Cmd.none)\n\nupdate : Msg -> Model -> (Model, Cmd a)\nupdate msg model = (model, Cmd.none)\n\n-- 1px\u306e\u7dda\u3067\u4ee3\u7528\npoint : Int -> Int -> RGB -> C.Form\npoint x y c = \n  let mkColor = Color.rgb (round<|c.r*255) (round<|c.g*255) (round<|c.b*255)\n  in (C.solid mkColor |> C.traced) \n    <| C.path [(toFloat x, toFloat y), (toFloat <|x+1, toFloat y)] \n\nview : Model -> Html.Html a\nview model = \n  let \n    toInt = round\n    ih = toInt model.height\n    iw = toInt model.width\n  in E.toHtml \n    <| C.collage ((*) 2 <| iw) ((*) 2 <| ih) \n    <| List.concat \n    <| List.map2 (\\ y row -> List.map2  (\\ x c -> point x y c) [0..iw] row) [0..ih]\n    <| scene model \n\nsubscriptions: Model -> Sub a\nsubscriptions model = Sub.none\n\nmain : Program Never\nmain =  \n  App.program { \n      init = (init {width = 800, height = 600})\n    , update = update\n    , view = view\n    , subscriptions = subscriptions\n    }\n\nscene : Model -> List (List RGB)\nscene model = \n  let \n    ray x y = { \n        dir = normalize { x = x, y = y, z = 5.0 }\n      , pos = { x = 0.0, y = 0.0, z = -5.0 }\n      }\n    way r = (flip (-) <| r / 2) >> flip (/) 100\n    listThen = flip List.map\n  in \n    [0..model.height-1] `listThen` \\y ->\n    [0..model.width-1] `listThen` \\x -> \n      render model.sphere model.lights <| ray (way model.width x) (way model.height y)\n\nintersect : Sphere -> Ray -> Maybe Float\nintersect sph ray = \n  let \n    m = ray.pos `subV` sph.pos\n    b = m `dot` ray.dir\n    c = b ^ 2 - magnitude2 m + sph.rad ^ 2\n    t = -b - sqrt c\n  in if c < 0 then Nothing else if t > 0 then Just t else Nothing\n\nrender : Sphere -> List Light -> Ray -> RGB\nrender sphere lights ray = \n  case intersect sphere ray of \n    Just dist -> \n      let \n        diffuse light acc = trace dist sphere light ray |> flip (updateCC (+)) acc\n        result = List.foldr diffuse black lights\n      in updateC min result 1.0\n    Nothing -> black\n\ntrace : Float -> Sphere -> Light -> Ray -> RGB\ntrace dist sphere light ray = \n  let\n    r = addV ray.pos <| updateV (*) ray.dir dist\n    n = updateV (/) (r `subV` sphere.pos) sphere.rad\n    l = light.pos `subV` r |> normalize \n    cos = n `dot` l |> max 0 \n  in updateCC (*) sphere.color light.color |> flip (updateC (*)) cos\n\n-- Vec\naddV : Vec -> Vec -> Vec\naddV = updateVV (+)\n\nsubV : Vec -> Vec -> Vec\nsubV = updateVV (-)\n\ndot : Vec -> Vec -> Float\ndot v1 v2 = v1.x * v2.x + v1.y * v2.y + v1.z * v2.z\n\nupdateV : (Float-> Float -> Float) -> Vec -> Float -> Vec\nupdateV f2 vec v = { x = f2 vec.x v , y = f2 vec.y v , z = f2 vec.z v }\n\nupdateVV : (Float-> Float -> Float) -> Vec -> Vec -> Vec\nupdateVV f2 vec1 vec2 = \n  { x = f2 vec1.x vec2.x , y = f2 vec1.y vec2.y , z = f2 vec1.z vec2.z }\n\ninitV : Vec\ninitV = { x = 0.0, y = 0.0, z = 0.0 }\n\nmagnitude : Vec -> Float\nmagnitude {x, y, z}  = sqrt <| x^2 + y^2 + z^2\n\nmagnitude2 : Vec -> Float\nmagnitude2 {x, y, z}  = x^2 + y^2 + z^2\n\nnormalize : Vec -> Vec\nnormalize vec =\n  let m = magnitude vec in updateV (/) vec <| if m == 0 then 1 else m\n\n-- Color\nupdateC : (Float-> Float -> Float) -> RGB -> Float -> RGB\nupdateC f2 a v = \n  { r = f2 a.r v , g = f2 a.g v , b = f2 a.b v }\n\nupdateCC : (Float -> Float -> Float) -> RGB -> RGB -> RGB\nupdateCC f2 a b = \n  { r = f2 a.r b.r , g = f2 a.g b.g , b = f2 a.b b.b }\n\naddC = updateCC (+)\n\nblack = { r = 0.0, g = 0.0, b = 0.0 }\nwhite = { r = 1.0, g = 1.0, b = 1.0 }\nred = { r = 1.0, g = 0.0, b = 0.0 }\ngreen = { r = 0.0, g = 1.0, b = 0.0 }\nblue = { r = 0.0, g = 0.0, b = 1.0 }\n\n\n\u307e\u3068\u3081\n\u30b3\u30f3\u30d1\u30a4\u30e9\u306b\u6012\u3089\u308c\u307e\u3057\u3087\u3046\u3002\nHaskell\u98a8\u8a00\u8a9e\u3067\u3042\u308a\u3001\u30b3\u30f3\u30d1\u30a4\u30eb\u3059\u308b\u3068JS\u3092\u51fa\u3057\u3066\u304f\u308c\u308bElm\u3067\u7c21\u5358\u306a\u30ec\u30a4\u30c8\u30ec\u30fc\u30b7\u30f3\u30b0\u3092\u3057\u3066\u307f\u307e\u3057\u305f\u3002\n0.17\u3067\u3060\u3044\u3076\u5909\u308f\u3063\u3066\u3057\u307e\u3044\u307e\u3057\u305f\u304c\u3001\u4f7f\u3044\u3084\u3059\u304f\u306a\u3063\u305f\u304b\u306a\u30fc\u3068\u601d\u3044\u307e\u3059\u3002\n\n# \u5b9f\u884c\u65b9\u6cd5\n\nElm\u81ea\u4f53\u306e\u30a4\u30f3\u30b9\u30c8\u30fc\u30eb\u65b9\u6cd5\u306f\u7701\u304d\u307e\u3059\u3002npm\u306a\u308a\u306a\u3093\u306a\u308a\u3067\u5165\u308c\u3066\u3042\u3052\u3066\u304f\u3060\u3055\u3044\u3002\n\n\u4ee5\u4e0b\u3001\u30b3\u30f3\u30bd\u30fc\u30eb\u3002\n\n```bash\n$ mkdir ray && cd ray\n\n$ vim Main.elm\n\n$ elm-package install elm-lang/html -y\n\n$ elm-package install evancz/elm-graphics -y\n\n$ cat elm-package.json\n{\n    \"version\": \"1.0.0\",\n    \"summary\": \"helpful summary of your project, less than 80 characters\",\n    \"repository\": \"https://github.com/user/project.git\",\n    \"license\": \"BSD3\",\n    \"source-directories\": [\n        \".\"\n    ],\n    \"exposed-modules\": [],\n    \"dependencies\": {\n        \"elm-lang/core\": \"4.0.5 <= v < 5.0.0\",\n        \"elm-lang/html\": \"1.1.0 <= v < 2.0.0\",\n        \"evancz/elm-graphics\": \"1.0.0 <= v < 2.0.0\"\n    },\n    \"elm-version\": \"0.17.0 <= v < 0.18.0\"\n}\n\n$ elm reactor\nelm reactor 0.17.0\nListening on http://localhost:8000/\n\n```\n\uff08Main.elm\u306f\u4e0b\u306e\u30b3\u30fc\u30c9\u3092\u30b3\u30d4\u30da\u3057\u3066\u304f\u3060\u3055\u3044\u3002\uff09\n\nelm reactor\u306e\u3042\u3068\u3001\u30d6\u30e9\u30a6\u30b6\u3067 http://localhost:8000/Main.elm \u306b\u30a2\u30af\u30bb\u30b9\u3059\u308b\u3068\u3001\n\u306a\u3093\u304b\u7403\u3063\u307d\u3044\u306e\u304c\u8868\u793a\u3055\u308c\u308b\u3068\u601d\u3044\u307e\u3059\u3002\n\n# \u30b3\u30fc\u30c9\n\n```Elm\nmodule Main exposing (main)\n\nimport Html.App as App\nimport Html exposing (div, Html)\nimport Color\n\nimport Element as E\nimport Collage as C\n\n\ntype alias Vec = { x: Float , y: Float , z: Float }\ntype alias RGB = { r: Float , g: Float , b: Float }\n\ntype alias Sphere = { pos: Vec , rad: Float , color: RGB }\ntype alias Light = { pos: Vec , color: RGB}\ntype alias Ray = { dir: Vec , pos: Vec }\ntype alias Model = { width: Float , height: Float , sphere: Sphere , lights: List Light }\n\ntype Msg = Init\n\n\ninit : {width: Float, height: Float} -> (Model, Cmd Msg)\ninit {width, height} = \n  let \n    sphere = { pos = initV, rad = 1.0, color = white }\n    light1 = { pos = {x = 3.0, y = -2.0, z = -2.0}, color = blue }\n    light2 = { pos = {x = -3.0, y = 2.0, z = -2.0}, color = red }\n    light3 = { pos = {x = 3.0, y = 2.0, z = -2.0}, color = green }\n    model =  { width = width , height = height , sphere = sphere , lights = [ light1, light2, light3 ] }\n  in (model, Cmd.none)\n\nupdate : Msg -> Model -> (Model, Cmd a)\nupdate msg model = (model, Cmd.none)\n\n-- 1px\u306e\u7dda\u3067\u4ee3\u7528\npoint : Int -> Int -> RGB -> C.Form\npoint x y c = \n  let mkColor = Color.rgb (round<|c.r*255) (round<|c.g*255) (round<|c.b*255)\n  in (C.solid mkColor |> C.traced) \n    <| C.path [(toFloat x, toFloat y), (toFloat <|x+1, toFloat y)] \n\nview : Model -> Html.Html a\nview model = \n  let \n    toInt = round\n    ih = toInt model.height\n    iw = toInt model.width\n  in E.toHtml \n    <| C.collage ((*) 2 <| iw) ((*) 2 <| ih) \n    <| List.concat \n    <| List.map2 (\\ y row -> List.map2  (\\ x c -> point x y c) [0..iw] row) [0..ih]\n    <| scene model \n\nsubscriptions: Model -> Sub a\nsubscriptions model = Sub.none\n\nmain : Program Never\nmain =  \n  App.program { \n      init = (init {width = 800, height = 600})\n    , update = update\n    , view = view\n    , subscriptions = subscriptions\n    }\n\nscene : Model -> List (List RGB)\nscene model = \n  let \n    ray x y = { \n        dir = normalize { x = x, y = y, z = 5.0 }\n      , pos = { x = 0.0, y = 0.0, z = -5.0 }\n      }\n    way r = (flip (-) <| r / 2) >> flip (/) 100\n    listThen = flip List.map\n  in \n    [0..model.height-1] `listThen` \\y ->\n    [0..model.width-1] `listThen` \\x -> \n      render model.sphere model.lights <| ray (way model.width x) (way model.height y)\n\nintersect : Sphere -> Ray -> Maybe Float\nintersect sph ray = \n  let \n    m = ray.pos `subV` sph.pos\n    b = m `dot` ray.dir\n    c = b ^ 2 - magnitude2 m + sph.rad ^ 2\n    t = -b - sqrt c\n  in if c < 0 then Nothing else if t > 0 then Just t else Nothing\n\nrender : Sphere -> List Light -> Ray -> RGB\nrender sphere lights ray = \n  case intersect sphere ray of \n    Just dist -> \n      let \n        diffuse light acc = trace dist sphere light ray |> flip (updateCC (+)) acc\n        result = List.foldr diffuse black lights\n      in updateC min result 1.0\n    Nothing -> black\n\ntrace : Float -> Sphere -> Light -> Ray -> RGB\ntrace dist sphere light ray = \n  let\n    r = addV ray.pos <| updateV (*) ray.dir dist\n    n = updateV (/) (r `subV` sphere.pos) sphere.rad\n    l = light.pos `subV` r |> normalize \n    cos = n `dot` l |> max 0 \n  in updateCC (*) sphere.color light.color |> flip (updateC (*)) cos\n\n-- Vec\naddV : Vec -> Vec -> Vec\naddV = updateVV (+)\n\nsubV : Vec -> Vec -> Vec\nsubV = updateVV (-)\n\ndot : Vec -> Vec -> Float\ndot v1 v2 = v1.x * v2.x + v1.y * v2.y + v1.z * v2.z\n\nupdateV : (Float-> Float -> Float) -> Vec -> Float -> Vec\nupdateV f2 vec v = { x = f2 vec.x v , y = f2 vec.y v , z = f2 vec.z v }\n\nupdateVV : (Float-> Float -> Float) -> Vec -> Vec -> Vec\nupdateVV f2 vec1 vec2 = \n  { x = f2 vec1.x vec2.x , y = f2 vec1.y vec2.y , z = f2 vec1.z vec2.z }\n\ninitV : Vec\ninitV = { x = 0.0, y = 0.0, z = 0.0 }\n\nmagnitude : Vec -> Float\nmagnitude {x, y, z}  = sqrt <| x^2 + y^2 + z^2\n\nmagnitude2 : Vec -> Float\nmagnitude2 {x, y, z}  = x^2 + y^2 + z^2\n\nnormalize : Vec -> Vec\nnormalize vec =\n  let m = magnitude vec in updateV (/) vec <| if m == 0 then 1 else m\n\n-- Color\nupdateC : (Float-> Float -> Float) -> RGB -> Float -> RGB\nupdateC f2 a v = \n  { r = f2 a.r v , g = f2 a.g v , b = f2 a.b v }\n\nupdateCC : (Float -> Float -> Float) -> RGB -> RGB -> RGB\nupdateCC f2 a b = \n  { r = f2 a.r b.r , g = f2 a.g b.g , b = f2 a.b b.b }\n\naddC = updateCC (+)\n\nblack = { r = 0.0, g = 0.0, b = 0.0 }\nwhite = { r = 1.0, g = 1.0, b = 1.0 }\nred = { r = 1.0, g = 0.0, b = 0.0 }\ngreen = { r = 0.0, g = 1.0, b = 0.0 }\nblue = { r = 0.0, g = 0.0, b = 1.0 }\n```\n\n# \u307e\u3068\u3081\n\n\u30b3\u30f3\u30d1\u30a4\u30e9\u306b\u6012\u3089\u308c\u307e\u3057\u3087\u3046\u3002\n", "tags": ["JavaScript", "Elm"]}