{"tags": ["F#", "gcj"], "context": " More than 1 year has passed since last update.\ncoffee.fs\ntype Coffee = {c:int64; t:int64; s:int64}\n\nlet sub {c=c;t=t;s=s} c' = {c=c-c';t=t;s=s}\n\nlet take s (xs:Coffee list) d c =\n  let rec take (xs:Coffee list) (ys:Coffee list) c s =\n    match ys with\n    | []      -> (s, List.rev xs)\n    | y'::ys' -> if y'.t<d then\n                   take (y'::xs) ys' c s\n                 elif y'.c < c then\n                   take ((sub y' y'.c)::xs) ys' (c-y'.c) (s+y'.c*y'.s)\n                 else\n                   (s+c*y'.s, List.rev xs @ (sub y' c)::ys')\n  take [] xs c s\n\nlet spans (cs:Coffee list) =\n  let ts = List.map (fun c -> c.t) cs\n  let ts' =\n    0L::ts\n    |> List.sortWith (fun x y -> compare y x)\n    |> Seq.distinct\n  Seq.zip ts' (Seq.skip 1 ts') |> Seq.map (fun (t,t') -> (t,t-t'))\n\nlet solve (cs:Coffee list) =\n  let ts = spans cs\n  let cs' = List.sortWith (fun c1 c2 -> compare c2.s c1.s) cs\n  Seq.fold (fun (s,xs) (d,c) -> take s xs d c) (0L,cs') ts\n  |> fst\n\nlet nk (s:string) =\n  let nk = stdin.ReadLine().Split([|' '|])\n  (int nk.[0], int64 nk.[1])\n\nlet cts (s:string) =\n  let a = s.Split([|' '|])\n  {c=int64 a.[0]; t=int64 a.[1]; s=int64 a.[2]}\n\nlet t = int (stdin.ReadLine())\nfor i in 1..t do\n  let (n,k) = nk (stdin.ReadLine())\n  let cs =\n    seq { for i in 1..n -> cts (stdin.ReadLine()) } |> Seq.toList\n  printfn \"Case #%d: %d\" i (solve cs)\n\n\n```fsharp:coffee.fs\ntype Coffee = {c:int64; t:int64; s:int64}\n\nlet sub {c=c;t=t;s=s} c' = {c=c-c';t=t;s=s}\n\nlet take s (xs:Coffee list) d c =\n  let rec take (xs:Coffee list) (ys:Coffee list) c s =\n    match ys with\n    | []      -> (s, List.rev xs)\n    | y'::ys' -> if y'.t<d then\n                   take (y'::xs) ys' c s\n                 elif y'.c < c then\n                   take ((sub y' y'.c)::xs) ys' (c-y'.c) (s+y'.c*y'.s)\n                 else\n                   (s+c*y'.s, List.rev xs @ (sub y' c)::ys')\n  take [] xs c s\n\nlet spans (cs:Coffee list) =\n  let ts = List.map (fun c -> c.t) cs\n  let ts' =\n    0L::ts\n    |> List.sortWith (fun x y -> compare y x)\n    |> Seq.distinct\n  Seq.zip ts' (Seq.skip 1 ts') |> Seq.map (fun (t,t') -> (t,t-t'))\n\nlet solve (cs:Coffee list) =\n  let ts = spans cs\n  let cs' = List.sortWith (fun c1 c2 -> compare c2.s c1.s) cs\n  Seq.fold (fun (s,xs) (d,c) -> take s xs d c) (0L,cs') ts\n  |> fst\n\nlet nk (s:string) =\n  let nk = stdin.ReadLine().Split([|' '|])\n  (int nk.[0], int64 nk.[1])\n\nlet cts (s:string) =\n  let a = s.Split([|' '|])\n  {c=int64 a.[0]; t=int64 a.[1]; s=int64 a.[2]}\n\nlet t = int (stdin.ReadLine())\nfor i in 1..t do\n  let (n,k) = nk (stdin.ReadLine())\n  let cs =\n    seq { for i in 1..n -> cts (stdin.ReadLine()) } |> Seq.toList\n  printfn \"Case #%d: %d\" i (solve cs)\n```"}