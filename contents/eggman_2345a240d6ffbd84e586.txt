{"context": "Linux\u306eieee80211_ops\u3092\u8aad\u3093\u3067\u307f\u307e\u3057\u305f\u3002\nieee80211_ops \u306f Linux Kernel\u306emac80211\u3068SoftMAC driver\u9593\u306e\u30a4\u30f3\u30bf\u30fc\u30d5\u30a7\u30a4\u30b9\u3067\u3059\u3002\n\nieee80211_ops\u306b\u3082\u305f\u304f\u3055\u3093\u306e\u30e1\u30bd\u30c3\u30c9\u304c\u3042\u308a\u307e\u3059\u304c\u3001\u6700\u4f4e\u9650\u5fc5\u305a\u5fc5\u8981\u305d\u3046\u306a\u95a2\u6570\u3092\u8abf\u3079\u3066\u307f\u307e\u3057\u305f\u3002\n\n\u30bd\u30fc\u30b9\u30b3\u30fc\u30c9\n\nhttps://github.com/torvalds/linux/blob/master/include/net/mac80211.h\n\n\nieee80211_ops\n\ntx\n\nskb\u3067\u6307\u5b9a\u3057\u305fframe\u3092control\u306e\u9001\u4fe1\u8a2d\u5b9a\u3092\u4f7f\u3063\u3066hw\u3067\u9001\u4fe1\u3059\u308b\u3002\n\n * @tx: Handler that 802.11 module calls for each transmitted frame.\n *  skb contains the buffer starting from the IEEE 802.11 header.\n *  The low-level driver should send the frame out based on\n *  configuration in the TX control data. This handler should,\n *  preferably, never fail and stop queues appropriately.\n *  Must be atomic.\n\n    void (*tx)(struct ieee80211_hw *hw,\n           struct ieee80211_tx_control *control,\n           struct sk_buff *skb);\n\n\nstart\n\nhw\u306e\u52d5\u4f5c\u3092\u958b\u59cb\u3059\u308b\u3002\n\n * @start: Called before the first netdevice attached to the hardware\n *  is enabled. This should turn on the hardware and must turn on\n *  frame reception (for possibly enabled monitor interfaces.)\n *  Returns negative error codes, these may be seen in userspace,\n *  or zero.\n *  When the device is started it should not have a MAC address\n *  to avoid acknowledging frames before a non-monitor device\n *  is added.\n *  Must be implemented and can sleep.\n\n    int (*start)(struct ieee80211_hw *hw);\n\n\nstop\n\nhw\u306e\u52d5\u4f5c\u3092\u505c\u6b62\u3059\u308b\u3002\n\n * @stop: Called after last netdevice attached to the hardware\n *  is disabled. This should turn off the hardware (at least\n *  it must turn off frame reception.)\n *  May be called right after add_interface if that rejects\n *  an interface. If you added any work onto the mac80211 workqueue\n *  you should ensure to cancel it on this callback.\n *  Must be implemented and can sleep.\n\n    void (*stop)(struct ieee80211_hw *hw);\n\n\nadd_interface\n\nhw\u306b\u30a4\u30f3\u30bf\u30fc\u30d5\u30a7\u30a4\u30b9vif\u3092\u8ffd\u52a0\u3059\u308b\u3002\n\n * @add_interface: Called when a netdevice attached to the hardware is\n *  enabled. Because it is not called for monitor mode devices, @start\n *  and @stop must be implemented.\n *  The driver should perform any initialization it needs before\n *  the device can be enabled. The initial configuration for the\n *  interface is given in the conf parameter.\n *  The callback may refuse to add an interface by returning a\n *  negative error code (which will be seen in userspace.)\n *  Must be implemented and can sleep.\n\n    int (*add_interface)(struct ieee80211_hw *hw,\n                 struct ieee80211_vif *vif);\n\n\nremove_interface\n\nhw\u306e\u30a4\u30f3\u30bf\u30fc\u30d5\u30a7\u30a4\u30b9vif\u3092\u524a\u9664\u3059\u308b\u3002\n\n * @remove_interface: Notifies a driver that an interface is going down.\n *  The @stop callback is called after this if it is the last interface\n *  and no monitor interfaces are present.\n *  When all interfaces are removed, the MAC address in the hardware\n *  must be cleared so the device no longer acknowledges packets,\n *  the mac_addr member of the conf structure is, however, set to the\n *  MAC address of the device going away.\n *  Hence, this callback must be implemented. It can sleep.\n\n    void (*remove_interface)(struct ieee80211_hw *hw,\n                 struct ieee80211_vif *vif);\n\n\nconfig\n\nhw\u306e\u8a2d\u5b9a\u3092\u5909\u66f4\u3059\u308b\u3002\u3000changed\u306e\u30d5\u30e9\u30b0\u306e\u60c5\u5831\u306e\u307f\u5909\u66f4\u3059\u308b\u3002 \u5909\u66f4\u306e\u60c5\u5831\u306fhw\u5185\u306b\u3042\u308b\u3002\nchannel\u3092\u5909\u66f4\u3059\u308b\u5834\u5408\u306a\u3069\u306b\u4f7f\u3046\u3002\n\n * @config: Handler for configuration requests. IEEE 802.11 code calls this\n *  function to change hardware configuration, e.g., channel.\n *  This function should never fail but returns a negative error code\n *  if it does. The callback can sleep.\n\n    int (*config)(struct ieee80211_hw *hw, u32 changed);\n\n\nbss_info_changed\n\nhw\u306e\u30a4\u30f3\u30bf\u30fc\u30d5\u30a7\u30a4\u30b9vif\u306bBSS\u8a2d\u5b9ainfo\u306e\u8a2d\u5b9a\u5909\u66f4\u3092\u3059\u308b\u3002\n\n * @bss_info_changed: Handler for configuration requests related to BSS\n *  parameters that may vary during BSS's lifespan, and may affect low\n *  level driver (e.g. assoc/disassoc status, erp parameters).\n *  This function should not be used if no BSS has been set, unless\n *  for association indication. The @changed parameter indicates which\n *  of the bss parameters has changed when a call is made. The callback\n *  can sleep.\n\n    void (*bss_info_changed)(struct ieee80211_hw *hw,\n                 struct ieee80211_vif *vif,\n                 struct ieee80211_bss_conf *info,\n                 u32 changed);\n\n\nconf_tx\n\nhw vif\u306e\u9001\u4fe1\u30ad\u30e5\u30fc\u306e\u8a2d\u5b9a\u3092\u3059\u308b\n\n * @conf_tx: Configure TX queue parameters (EDCF (aifs, cw_min, cw_max),\n *  bursting) for a hardware TX queue.\n *  Returns a negative error code on failure.\n *  The callback can sleep.\n\n    int (*conf_tx)(struct ieee80211_hw *hw,\n               struct ieee80211_vif *vif, u16 ac,\n               const struct ieee80211_tx_queue_params *params);\n\n\nconfigure_filter\n\n\u53d7\u4fe1filter\u306e\u8a2d\u5b9a\u3092\u3059\u308b\u3002\n\n * @configure_filter: Configure the device's RX filter.\n *  See the section \"Frame filtering\" for more information.\n *  This callback must be implemented and can sleep.\n\n    void (*configure_filter)(struct ieee80211_hw *hw,\n                 unsigned int changed_flags,\n                 unsigned int *total_flags,\n                 u64 multicast);\n\nLinux\u306eieee80211_ops\u3092\u8aad\u3093\u3067\u307f\u307e\u3057\u305f\u3002\n\nieee80211_ops \u306f Linux Kernel\u306emac80211\u3068SoftMAC driver\u9593\u306e\u30a4\u30f3\u30bf\u30fc\u30d5\u30a7\u30a4\u30b9\u3067\u3059\u3002\n\n![Untitled.png](https://qiita-image-store.s3.amazonaws.com/0/42120/cc41e90d-1c55-de8b-2254-9f89cb089ba6.png)\n\nieee80211_ops\u306b\u3082\u305f\u304f\u3055\u3093\u306e\u30e1\u30bd\u30c3\u30c9\u304c\u3042\u308a\u307e\u3059\u304c\u3001\u6700\u4f4e\u9650\u5fc5\u305a\u5fc5\u8981\u305d\u3046\u306a\u95a2\u6570\u3092\u8abf\u3079\u3066\u307f\u307e\u3057\u305f\u3002\n\n# \u30bd\u30fc\u30b9\u30b3\u30fc\u30c9\n* https://github.com/torvalds/linux/blob/master/include/net/mac80211.h\n\n# ieee80211_ops\n## tx\n* skb\u3067\u6307\u5b9a\u3057\u305fframe\u3092control\u306e\u9001\u4fe1\u8a2d\u5b9a\u3092\u4f7f\u3063\u3066hw\u3067\u9001\u4fe1\u3059\u308b\u3002\n\n```\n * @tx: Handler that 802.11 module calls for each transmitted frame.\n *\tskb contains the buffer starting from the IEEE 802.11 header.\n *\tThe low-level driver should send the frame out based on\n *\tconfiguration in the TX control data. This handler should,\n *\tpreferably, never fail and stop queues appropriately.\n *\tMust be atomic.\n```\n```\n\tvoid (*tx)(struct ieee80211_hw *hw,\n\t\t   struct ieee80211_tx_control *control,\n\t\t   struct sk_buff *skb);\n```\n\n## start\n* hw\u306e\u52d5\u4f5c\u3092\u958b\u59cb\u3059\u308b\u3002\n\n```\n * @start: Called before the first netdevice attached to the hardware\n *\tis enabled. This should turn on the hardware and must turn on\n *\tframe reception (for possibly enabled monitor interfaces.)\n *\tReturns negative error codes, these may be seen in userspace,\n *\tor zero.\n *\tWhen the device is started it should not have a MAC address\n *\tto avoid acknowledging frames before a non-monitor device\n *\tis added.\n *\tMust be implemented and can sleep.\n```\n```\n\tint (*start)(struct ieee80211_hw *hw);\n```\n\n## stop\n* hw\u306e\u52d5\u4f5c\u3092\u505c\u6b62\u3059\u308b\u3002\n\n```\n * @stop: Called after last netdevice attached to the hardware\n *\tis disabled. This should turn off the hardware (at least\n *\tit must turn off frame reception.)\n *\tMay be called right after add_interface if that rejects\n *\tan interface. If you added any work onto the mac80211 workqueue\n *\tyou should ensure to cancel it on this callback.\n *\tMust be implemented and can sleep.\n```\n```\n\tvoid (*stop)(struct ieee80211_hw *hw);\n```\n## add_interface\n* hw\u306b\u30a4\u30f3\u30bf\u30fc\u30d5\u30a7\u30a4\u30b9vif\u3092\u8ffd\u52a0\u3059\u308b\u3002\n\n```\n * @add_interface: Called when a netdevice attached to the hardware is\n *\tenabled. Because it is not called for monitor mode devices, @start\n *\tand @stop must be implemented.\n *\tThe driver should perform any initialization it needs before\n *\tthe device can be enabled. The initial configuration for the\n *\tinterface is given in the conf parameter.\n *\tThe callback may refuse to add an interface by returning a\n *\tnegative error code (which will be seen in userspace.)\n *\tMust be implemented and can sleep.\n```\n```\n\tint (*add_interface)(struct ieee80211_hw *hw,\n\t\t\t     struct ieee80211_vif *vif);\n```\n\n## remove_interface\n* hw\u306e\u30a4\u30f3\u30bf\u30fc\u30d5\u30a7\u30a4\u30b9vif\u3092\u524a\u9664\u3059\u308b\u3002\n\n```\n * @remove_interface: Notifies a driver that an interface is going down.\n *\tThe @stop callback is called after this if it is the last interface\n *\tand no monitor interfaces are present.\n *\tWhen all interfaces are removed, the MAC address in the hardware\n *\tmust be cleared so the device no longer acknowledges packets,\n *\tthe mac_addr member of the conf structure is, however, set to the\n *\tMAC address of the device going away.\n *\tHence, this callback must be implemented. It can sleep.\n```\n```\n\tvoid (*remove_interface)(struct ieee80211_hw *hw,\n\t\t\t\t struct ieee80211_vif *vif);\n```\n## config\n* hw\u306e\u8a2d\u5b9a\u3092\u5909\u66f4\u3059\u308b\u3002\u3000changed\u306e\u30d5\u30e9\u30b0\u306e\u60c5\u5831\u306e\u307f\u5909\u66f4\u3059\u308b\u3002 \u5909\u66f4\u306e\u60c5\u5831\u306fhw\u5185\u306b\u3042\u308b\u3002\n* channel\u3092\u5909\u66f4\u3059\u308b\u5834\u5408\u306a\u3069\u306b\u4f7f\u3046\u3002\n\n```\n * @config: Handler for configuration requests. IEEE 802.11 code calls this\n *\tfunction to change hardware configuration, e.g., channel.\n *\tThis function should never fail but returns a negative error code\n *\tif it does. The callback can sleep.\n```\n```\n\tint (*config)(struct ieee80211_hw *hw, u32 changed);\n```\n## bss_info_changed\n* hw\u306e\u30a4\u30f3\u30bf\u30fc\u30d5\u30a7\u30a4\u30b9vif\u306bBSS\u8a2d\u5b9ainfo\u306e\u8a2d\u5b9a\u5909\u66f4\u3092\u3059\u308b\u3002\n\n```\n * @bss_info_changed: Handler for configuration requests related to BSS\n *\tparameters that may vary during BSS's lifespan, and may affect low\n *\tlevel driver (e.g. assoc/disassoc status, erp parameters).\n *\tThis function should not be used if no BSS has been set, unless\n *\tfor association indication. The @changed parameter indicates which\n *\tof the bss parameters has changed when a call is made. The callback\n *\tcan sleep.\n```\n```\n\tvoid (*bss_info_changed)(struct ieee80211_hw *hw,\n\t\t\t\t struct ieee80211_vif *vif,\n\t\t\t\t struct ieee80211_bss_conf *info,\n\t\t\t\t u32 changed);\n```\n## conf_tx\n* hw vif\u306e\u9001\u4fe1\u30ad\u30e5\u30fc\u306e\u8a2d\u5b9a\u3092\u3059\u308b\n\n```\n * @conf_tx: Configure TX queue parameters (EDCF (aifs, cw_min, cw_max),\n *\tbursting) for a hardware TX queue.\n *\tReturns a negative error code on failure.\n *\tThe callback can sleep.\n```\n```\n\tint (*conf_tx)(struct ieee80211_hw *hw,\n\t\t       struct ieee80211_vif *vif, u16 ac,\n\t\t       const struct ieee80211_tx_queue_params *params);\n```\n## configure_filter\n* \u53d7\u4fe1filter\u306e\u8a2d\u5b9a\u3092\u3059\u308b\u3002\n\n```\n * @configure_filter: Configure the device's RX filter.\n *\tSee the section \"Frame filtering\" for more information.\n *\tThis callback must be implemented and can sleep.\n```\n```\n\tvoid (*configure_filter)(struct ieee80211_hw *hw,\n\t\t\t\t unsigned int changed_flags,\n\t\t\t\t unsigned int *total_flags,\n\t\t\t\t u64 multicast);\n```\n", "tags": ["Linux", "kernel", "Wi-Fi", "802.11"]}