{"context": " More than 1 year has passed since last update.\n\nFortran\u3067OpenGL\n\nF03GL + FreeGlut\nFortran \u3067\u30b0\u30e9\u30d5\u30a3\u30c3\u30af\u30b9\u3092\u3084\u308b\u65b9\u6cd5\u3068\u3057\u3066 OpenGL \u3092\u5229\u7528\u3059\u308b\u3068\u3044\u3046\u624b\u304c\u3042\u308a\u307e\u3059\u3002Intel Visual Fortran \u306e\u30b5\u30f3\u30d7\u30eb\u306b\u3082\u4f8b\u984c\u304c\u3042\u308a\u307e\u3059\u304c\u3001Windows \u30d7\u30ed\u30b0\u30e9\u30df\u30f3\u30b0\u3082\u517c\u306d\u3066\u3044\u308b\u306e\u3067\u82e5\u5e72\u6577\u5c45\u304c\u9ad8\u3044\u6240\u304c\u3042\u308a\u307e\u3059\u3002\u307e\u305f\u30d7\u30e9\u30c3\u30c8\u30d5\u30a9\u30fc\u30e0\u4f9d\u5b58\u6027\u304c\u51fa\u3066\u3057\u307e\u3046\u3068\u3044\u3046\u554f\u984c\u3082\u3042\u308a\u307e\u3059\u3002\n\u3088\u308a\u7c21\u4fbf\u306a OpenGL \u5229\u7528\u6cd5\u3068\u3057\u3066 GLUT \u3068\u3044\u3046\u306e\u304c\u6614\u304b\u3089\u3042\u308a\u307e\u3059\u3002Fortran2003\u3067\u306fC\u8a00\u8a9e\u3068\u306e\u9023\u643a\u304c\u5f37\u5316\u3055\u308c\u305f\u305f\u3081\u3001GLUT \u5229\u7528\u3082\u4ee5\u524d\u3088\u308a\u697d\u306b\u306a\u3063\u305f\u3088\u3046\u3067\u3059\u3002\n\u3053\u3053\u3067\u306f\u3001\u3053\u3053\u306e\u8a18\u4e8b\u304b\u3089\u30ce\u30a6\u30cf\u30a6\u3092\u62dd\u501f\u3057\u3066\u3001F03GL + FreeGlut \u306e\u7d44\u307f\u5408\u308f\u305b\u3067 OpenGL \u3092\u5229\u7528\u3057\u3066\u4e09\u6b21\u5143\u306e\u30b0\u30e9\u30d5\u3092\u30d7\u30ed\u30c3\u30c8\u3059\u308b\u3053\u3068\u306b\u3057\u307e\u3059\u3002\n\n\u4e71\u308c\u3066\u306a\u3044\u4e71\u6570 RANDU\n\u30b3\u30f3\u30d4\u30e5\u30fc\u30bf\u3067\u306e\u4e71\u6570\u751f\u6210\u306f\u3001\u5927\u578b\u8a08\u7b97\u6a5f\u3067\u306f\u5c02\u7528\u30cf\u30fc\u30c9\u30a6\u30a7\u30a2\u3067\u71b1\u96d1\u97f3\u306a\u3069\u3067\u884c\u308f\u308c\u305f\u308a\u3057\u307e\u3059\u304c\u3001\u591a\u304f\u306e\u5834\u5408\u306f\u7279\u6b8a\u306a\u6f38\u5316\u5f0f\u306b\u3088\u308b\u7591\u4f3c\u4e71\u6570\u5217\u304c\u7528\u3044\u3089\u308c\u307e\u3059\u3002\u7591\u4f3c\u4e71\u6570\u5217\u306f\u6c7a\u5b9a\u8ad6\u7684\u306b\u5b9a\u307e\u308b\u306e\u3067\u672c\u5f53\u306f\u4e71\u6570\u3067\u306f\u7121\u3044\u306e\u3067\u3059\u304c\u3001\u5229\u7528\u3059\u308b\u72b6\u6cc1\u306b\u5fdc\u3058\u3066\u5341\u5206\u4e71\u6570\u3068\u307f\u306a\u305b\u308c\u3070\u826f\u3044\u3068\u3055\u308c\u307e\u3059\u3002\n\u3057\u304b\u3057\u306a\u304c\u3089\u3001\u4e00\u898b\u4e71\u6570\u3068\u601d\u308f\u308c\u305f\u3082\u306e\u306b\u660e\u3089\u304b\u306a\u898f\u5247\u6027\u304c\u73fe\u308c\u308b\u5834\u5408\u3082\u3042\u308a\u307e\u3059\u3002\u305d\u306e\u6709\u540d\u306a\u4f8b\u304c\u30011960\u5e74\u4ee3\u306b IBM \u3067\u5229\u7528\u3055\u308c\u3066\u3044\u305f RANDU \u7591\u4f3c\u4e71\u6570\u5217(r0=1,rn+1=65539\u2217rnmod231r0=1,rn+1=65539\u2217rnmod231r_0=1,r_{n+1}=65539 * r_n\\, mod\\,\\, 2^{31})\u3067\u3001\u4eca\u306b\u81f3\u308b\u307e\u3067\u6559\u79d1\u66f8\u306a\u3069\u306b\u3088\u304f\u51fa\u3066\u304d\u307e\u3059\u3002\n\n\u5b9f\u884c\u7d50\u679c\nRANDU \u306b\u3088\u308a\u751f\u6210\u3055\u308c\u305f\u6570\u5217\u3092\u4e09\u6b21\u5143\u306e\u70b9\u5ea7\u6a19\uff08 xn=r3n+1/231,xn=r3n+1/231,x_n=r_{3n+1}/2^{31}, yn=r3n+2/231,yn=r3n+2/231,y_n=r_{3n+2}/2^{31}, zn=r3n+3/231zn=r3n+3/231z_n=r_{3n+3}/2^{31}\uff09\u3068\u3057\u3066\u30d7\u30ed\u30c3\u30c8\u3057\u305f\u3082\u306e\u3092\u4ee5\u4e0b\u306b\u793a\u3057\u307e\u3059\u3002\u5404\u70b9\u306f \uff58\u3001\uff59\u3001\uff5a\u65b9\u5411\u306b [0,1] \u306e\u7bc4\u56f2\u306e\u7acb\u65b9\u4f53\u306e\u4e2d\u306b\u304a\u3055\u307e\u3063\u3066\u3044\u307e\u3059\u3002\u4e00\u898b\u30e9\u30f3\u30c0\u30e0\u306b\u70b9\u304c\u6253\u305f\u308c\u3066\u3044\u308b\u3088\u3046\u306b\u898b\u3048\u307e\u3059\u304c\u3001\u7279\u5b9a\u89d2\u5ea6\u304b\u3089\u898b\u308b\u3068\u5e7e\u679a\u304b\u306e\u5e73\u9762\u4e0a\u306b\u70b9\u304c\u5206\u5e03\u3057\u3066\u3044\u308b\u306e\u304c\u898b\u3066\u53d6\u308c\u307e\u3059\u3002\n\n\n\u30ad\u30e3\u30d7\u30c1\u30e3\u4f8b\n\n\n\n\n\u30d7\u30ed\u30b0\u30e9\u30e0\n\u4ee5\u4e0b\u306e\u30d7\u30ed\u30b0\u30e9\u30e0\u306f F03GL \u306e\u30b5\u30f3\u30d7\u30eb\u4e2d\u306e pointsz.f90 \u3092\u571f\u53f0\u306b\u3001\u3044\u304f\u3089\u304b\u66f8\u304d\u76f4\u3057\u305f\u3082\u306e\u3067\u3059\u3002\u30ab\u30fc\u30bd\u30eb\u306b\u3088\u3063\u3066\u8996\u70b9\u65b9\u5411\u3092\u52d5\u304b\u3059\u3053\u3068\u304c\u3067\u304d\u307e\u3059\u3002\nmodule m_gl  \n  use OpenGL_GL\n  use OpenGL_GLUT\n  implicit none  \n  real, save :: xrot = 0.0, yrot = 0.0\ncontains\n  subroutine SetupRC() bind(c)\n    ! Black background\n    call glClearColor(0.0, 0.0, 0.6, 1.0 )\n    ! Set drawing color to green\n    call glColor3f(1.0, 0.0, 0.0)\n  end subroutine SetupRC\n\n  subroutine KeyPressFunc(key, x, y) bind(C)\n    integer(GLbyte), intent(in), value :: key\n    integer(GLint ), intent(in), value  :: x, y\n    if ( key == 27 ) stop ! ESC\n  end subroutine KeyPressFunc\n\n  subroutine KeySpecialFunc(key, x, y) bind(C)\n    integer(GLint), intent(in), value  :: key, x, y\n    if ( key == GLUT_KEY_UP    ) xRot = xrot - 5.0\n    if ( key == GLUT_KEY_DOWN  ) xRot = xrot + 5.0\n    if ( key == GLUT_KEY_LEFT  ) yRot = yrot - 5.0\n    if ( key == GLUT_KEY_RIGHT ) yRot = yrot + 5.0 \n    if ( xrot > 356.0 )then\n      xRot = 0.0\n    else if ( xrot < -1.0 )then\n      xRot = 355.0\n    endif\n    if ( yrot > 356.0 )then\n      yRot = 0.0\n    else if ( yrot < -1.0 )then\n      yRot = 355.0\n    endif\n    ! Refresh the Window\n    call glutPostRedisplay\n  end subroutine KeySpecialFunc\n\n  subroutine ChangeSize(win, hin) bind(C)\n    integer(GLcint), intent(IN), value :: win, hin\n    integer(GLcint) :: w, h\n    real(GLdouble)  :: Zero, One, Range = 100.0, Aspect\n    w = win\n    h = hin\n    ! Prevent a divide by zero, when window is too short\n    ! (you cant make a window of zero width).\n    if( h == 0 ) h = 1\n    ! Set the viewport to be the entire window\n    call glViewport(0, 0, w, h)\n    ! Reset coordinate system\n    call glMatrixMode(GL_PROJECTION)\n    call glLoadIdentity\n    ! Establish clipping volume (left, right, bottom, top, near, far)\n    aspect = float(w)/float(h)\n    ! Keep the square square\n    if( w <= h )then\n      call glOrtho( -Range, Range, &\n                    -Range / Aspect, Range / Aspect,&\n                    -Range, Range  )\n    else\n      call glOrtho( -Range * Aspect, Range * Aspect, &\n                    -Range, Range, &\n                    -Range, Range  )\n    endif\n    call glMatrixMode(GL_MODELVIEW)\n    call glLoadIdentity\n  end subroutine ChangeSize \n\n  subroutine RenderScene() bind(C)\n    integer, parameter :: n = 10**4\n    real(glfloat), save :: dx(n - 1), dy(n - 1), dz(n - 1)\n    logical, save :: first = .true.\n    integer :: i\n    ! make Lorenz attractor data        \n\n    if (first) then\n      block  \n        integer(8) :: m = 2_8**31\n        integer(8) :: ix \n        real(glfloat) :: x(n), y(n), z(n)\n        first = .false.\n        ix = 1\n        do i = 1, n\n          ix = mod(65539 * ix, m)  ! ;  print *, ix\n          x(i) = real(ix) / m \n          ix = mod(65539 * ix, m)  ! ;  print *, ix\n          y(i) = real(ix) / m\n          ix = mod(65539 * ix, m)  ! ;  print *, ix\n          z(i) = real(ix) / m\n        end do\n        dx = (x(2:) - x(:n - 1)) * 80.0_glfloat ! scale data \n        dy = (y(2:) - y(:n - 1)) * 80.0_glfloat\n        dz = (z(2:) - z(:n - 1)) * 80.0_glfloat\n      end block  \n    end if  \n    ! Clear the window with current clearing color\n    call glClear(GL_COLOR_BUFFER_BIT)\n    ! Save matrix state and do the rotation\n    call glPushMatrix\n    call glRotatef(xRot, 1.0, 0.0, 0.0)\n    call glRotatef(yRot, 0.0, 1.0, 0.0)\n    ! draw Lorenz attractor\n    do i = 1, n - 1\n      call glTranslatef( dx(i), dy(i), dz(i) )\n      call glutSolidCube(0.5_gldouble )\n    end do\n    !\n    call glPopMatrix\n    ! Flush drawing commands\n    call glutSwapBuffers\n  end subroutine RenderScene\nend module m_gl\n\nprogram RANDU\n   use m_gl\n   implicit none\n   integer :: iwin\n   call glutInit()\n   call glutInitDisplayMode(ior(GLUT_DOUBLE,ior(GLUT_RGB,GLUT_DEPTH)))\n   call glutInitWindowSize(800, 600)\n   iwin = glutCreateWindow('RANDU'//char(0))\n   call glutReshapeFunc ( ChangeSize     )\n   call glutKeyboardFunc( KeyPressFunc   )\n   call glutSpecialFunc ( KeySpecialFunc )\n   call glutDisplayFunc ( RenderScene    )\n   call SetupRC()\n   call glutMainLoop()\nend program RANDU\n\n#Fortran\u3067OpenGL\n##F03GL + FreeGlut\nFortran \u3067\u30b0\u30e9\u30d5\u30a3\u30c3\u30af\u30b9\u3092\u3084\u308b\u65b9\u6cd5\u3068\u3057\u3066 OpenGL \u3092\u5229\u7528\u3059\u308b\u3068\u3044\u3046\u624b\u304c\u3042\u308a\u307e\u3059\u3002Intel Visual Fortran \u306e\u30b5\u30f3\u30d7\u30eb\u306b\u3082\u4f8b\u984c\u304c\u3042\u308a\u307e\u3059\u304c\u3001Windows \u30d7\u30ed\u30b0\u30e9\u30df\u30f3\u30b0\u3082\u517c\u306d\u3066\u3044\u308b\u306e\u3067\u82e5\u5e72\u6577\u5c45\u304c\u9ad8\u3044\u6240\u304c\u3042\u308a\u307e\u3059\u3002\u307e\u305f\u30d7\u30e9\u30c3\u30c8\u30d5\u30a9\u30fc\u30e0\u4f9d\u5b58\u6027\u304c\u51fa\u3066\u3057\u307e\u3046\u3068\u3044\u3046\u554f\u984c\u3082\u3042\u308a\u307e\u3059\u3002\n\n\u3088\u308a\u7c21\u4fbf\u306a OpenGL \u5229\u7528\u6cd5\u3068\u3057\u3066 GLUT \u3068\u3044\u3046\u306e\u304c\u6614\u304b\u3089\u3042\u308a\u307e\u3059\u3002Fortran2003\u3067\u306fC\u8a00\u8a9e\u3068\u306e\u9023\u643a\u304c\u5f37\u5316\u3055\u308c\u305f\u305f\u3081\u3001GLUT \u5229\u7528\u3082\u4ee5\u524d\u3088\u308a\u697d\u306b\u306a\u3063\u305f\u3088\u3046\u3067\u3059\u3002\n\n\u3053\u3053\u3067\u306f\u3001[\u3053\u3053](http://fortran66.hatenablog.com/entry/2014/09/17/014626)\u306e\u8a18\u4e8b\u304b\u3089\u30ce\u30a6\u30cf\u30a6\u3092\u62dd\u501f\u3057\u3066\u3001F03GL + FreeGlut \u306e\u7d44\u307f\u5408\u308f\u305b\u3067 OpenGL \u3092\u5229\u7528\u3057\u3066\u4e09\u6b21\u5143\u306e\u30b0\u30e9\u30d5\u3092\u30d7\u30ed\u30c3\u30c8\u3059\u308b\u3053\u3068\u306b\u3057\u307e\u3059\u3002\n\n##\u4e71\u308c\u3066\u306a\u3044\u4e71\u6570 RANDU\n\u30b3\u30f3\u30d4\u30e5\u30fc\u30bf\u3067\u306e\u4e71\u6570\u751f\u6210\u306f\u3001\u5927\u578b\u8a08\u7b97\u6a5f\u3067\u306f\u5c02\u7528\u30cf\u30fc\u30c9\u30a6\u30a7\u30a2\u3067\u71b1\u96d1\u97f3\u306a\u3069\u3067\u884c\u308f\u308c\u305f\u308a\u3057\u307e\u3059\u304c\u3001\u591a\u304f\u306e\u5834\u5408\u306f\u7279\u6b8a\u306a\u6f38\u5316\u5f0f\u306b\u3088\u308b\u7591\u4f3c\u4e71\u6570\u5217\u304c\u7528\u3044\u3089\u308c\u307e\u3059\u3002\u7591\u4f3c\u4e71\u6570\u5217\u306f\u6c7a\u5b9a\u8ad6\u7684\u306b\u5b9a\u307e\u308b\u306e\u3067\u672c\u5f53\u306f\u4e71\u6570\u3067\u306f\u7121\u3044\u306e\u3067\u3059\u304c\u3001\u5229\u7528\u3059\u308b\u72b6\u6cc1\u306b\u5fdc\u3058\u3066\u5341\u5206\u4e71\u6570\u3068\u307f\u306a\u305b\u308c\u3070\u826f\u3044\u3068\u3055\u308c\u307e\u3059\u3002\n\n\u3057\u304b\u3057\u306a\u304c\u3089\u3001\u4e00\u898b\u4e71\u6570\u3068\u601d\u308f\u308c\u305f\u3082\u306e\u306b\u660e\u3089\u304b\u306a\u898f\u5247\u6027\u304c\u73fe\u308c\u308b\u5834\u5408\u3082\u3042\u308a\u307e\u3059\u3002\u305d\u306e\u6709\u540d\u306a\u4f8b\u304c\u30011960\u5e74\u4ee3\u306b IBM \u3067\u5229\u7528\u3055\u308c\u3066\u3044\u305f RANDU \u7591\u4f3c\u4e71\u6570\u5217($r_0=1,r_{n+1}=65539 * r_n\\, mod\\,\\, 2^{31}$)\u3067\u3001\u4eca\u306b\u81f3\u308b\u307e\u3067\u6559\u79d1\u66f8\u306a\u3069\u306b\u3088\u304f\u51fa\u3066\u304d\u307e\u3059\u3002\n\n##\u5b9f\u884c\u7d50\u679c\nRANDU \u306b\u3088\u308a\u751f\u6210\u3055\u308c\u305f\u6570\u5217\u3092\u4e09\u6b21\u5143\u306e\u70b9\u5ea7\u6a19\uff08 $x_n=r_{3n+1}/2^{31},$ $y_n=r_{3n+2}/2^{31},$ $z_n=r_{3n+3}/2^{31}$\uff09\u3068\u3057\u3066\u30d7\u30ed\u30c3\u30c8\u3057\u305f\u3082\u306e\u3092\u4ee5\u4e0b\u306b\u793a\u3057\u307e\u3059\u3002\u5404\u70b9\u306f \uff58\u3001\uff59\u3001\uff5a\u65b9\u5411\u306b [0,1] \u306e\u7bc4\u56f2\u306e\u7acb\u65b9\u4f53\u306e\u4e2d\u306b\u304a\u3055\u307e\u3063\u3066\u3044\u307e\u3059\u3002\u4e00\u898b\u30e9\u30f3\u30c0\u30e0\u306b\u70b9\u304c\u6253\u305f\u308c\u3066\u3044\u308b\u3088\u3046\u306b\u898b\u3048\u307e\u3059\u304c\u3001\u7279\u5b9a\u89d2\u5ea6\u304b\u3089\u898b\u308b\u3068\u5e7e\u679a\u304b\u306e\u5e73\u9762\u4e0a\u306b\u70b9\u304c\u5206\u5e03\u3057\u3066\u3044\u308b\u306e\u304c\u898b\u3066\u53d6\u308c\u307e\u3059\u3002\n![\u540d\u79f0\u672a\u8a2d\u5b9a-1.gif](https://qiita-image-store.s3.amazonaws.com/0/44522/8ac04966-d742-6fde-9ae6-efb86d6f1f1f.gif)\n\n###\u30ad\u30e3\u30d7\u30c1\u30e3\u4f8b\n![RANDU1.png](https://qiita-image-store.s3.amazonaws.com/0/44522/82305918-1e2e-a068-20b5-898c2450f6f1.png)\n![RANDU3.png](https://qiita-image-store.s3.amazonaws.com/0/44522/ae3de163-fdf5-e1f4-026b-87d4c5317528.png)\n![Randu2.png](https://qiita-image-store.s3.amazonaws.com/0/44522/357e5a96-2bf9-c67a-0e84-2cdb67dc0ce5.png)\n\n\n##\u30d7\u30ed\u30b0\u30e9\u30e0\n\u4ee5\u4e0b\u306e\u30d7\u30ed\u30b0\u30e9\u30e0\u306f F03GL \u306e\u30b5\u30f3\u30d7\u30eb\u4e2d\u306e pointsz.f90 \u3092\u571f\u53f0\u306b\u3001\u3044\u304f\u3089\u304b\u66f8\u304d\u76f4\u3057\u305f\u3082\u306e\u3067\u3059\u3002\u30ab\u30fc\u30bd\u30eb\u306b\u3088\u3063\u3066\u8996\u70b9\u65b9\u5411\u3092\u52d5\u304b\u3059\u3053\u3068\u304c\u3067\u304d\u307e\u3059\u3002\n\n```fortran\nmodule m_gl  \n  use OpenGL_GL\n  use OpenGL_GLUT\n  implicit none  \n  real, save :: xrot = 0.0, yrot = 0.0\ncontains\n  subroutine SetupRC() bind(c)\n    ! Black background\n    call glClearColor(0.0, 0.0, 0.6, 1.0 )\n    ! Set drawing color to green\n    call glColor3f(1.0, 0.0, 0.0)\n  end subroutine SetupRC\n  \n  subroutine KeyPressFunc(key, x, y) bind(C)\n    integer(GLbyte), intent(in), value :: key\n    integer(GLint ), intent(in), value  :: x, y\n    if ( key == 27 ) stop ! ESC\n  end subroutine KeyPressFunc\n  \n  subroutine KeySpecialFunc(key, x, y) bind(C)\n    integer(GLint), intent(in), value  :: key, x, y\n    if ( key == GLUT_KEY_UP    ) xRot = xrot - 5.0\n    if ( key == GLUT_KEY_DOWN  ) xRot = xrot + 5.0\n    if ( key == GLUT_KEY_LEFT  ) yRot = yrot - 5.0\n    if ( key == GLUT_KEY_RIGHT ) yRot = yrot + 5.0 \n    if ( xrot > 356.0 )then\n      xRot = 0.0\n    else if ( xrot < -1.0 )then\n      xRot = 355.0\n    endif\n    if ( yrot > 356.0 )then\n      yRot = 0.0\n    else if ( yrot < -1.0 )then\n      yRot = 355.0\n    endif\n    ! Refresh the Window\n    call glutPostRedisplay\n  end subroutine KeySpecialFunc\n  \n  subroutine ChangeSize(win, hin) bind(C)\n    integer(GLcint), intent(IN), value :: win, hin\n    integer(GLcint) :: w, h\n    real(GLdouble)  :: Zero, One, Range = 100.0, Aspect\n    w = win\n    h = hin\n    ! Prevent a divide by zero, when window is too short\n    ! (you cant make a window of zero width).\n    if( h == 0 ) h = 1\n    ! Set the viewport to be the entire window\n    call glViewport(0, 0, w, h)\n    ! Reset coordinate system\n    call glMatrixMode(GL_PROJECTION)\n    call glLoadIdentity\n    ! Establish clipping volume (left, right, bottom, top, near, far)\n    aspect = float(w)/float(h)\n    ! Keep the square square\n    if( w <= h )then\n      call glOrtho( -Range, Range, &\n                    -Range / Aspect, Range / Aspect,&\n                    -Range, Range  )\n    else\n      call glOrtho( -Range * Aspect, Range * Aspect, &\n                    -Range, Range, &\n                    -Range, Range  )\n    endif\n    call glMatrixMode(GL_MODELVIEW)\n    call glLoadIdentity\n  end subroutine ChangeSize \n  \n  subroutine RenderScene() bind(C)\n    integer, parameter :: n = 10**4\n    real(glfloat), save :: dx(n - 1), dy(n - 1), dz(n - 1)\n    logical, save :: first = .true.\n    integer :: i\n    ! make Lorenz attractor data        \n\n    if (first) then\n      block  \n        integer(8) :: m = 2_8**31\n        integer(8) :: ix \n        real(glfloat) :: x(n), y(n), z(n)\n        first = .false.\n        ix = 1\n        do i = 1, n\n          ix = mod(65539 * ix, m)  ! ;  print *, ix\n          x(i) = real(ix) / m \n          ix = mod(65539 * ix, m)  ! ;  print *, ix\n          y(i) = real(ix) / m\n          ix = mod(65539 * ix, m)  ! ;  print *, ix\n          z(i) = real(ix) / m\n        end do\n        dx = (x(2:) - x(:n - 1)) * 80.0_glfloat ! scale data \n        dy = (y(2:) - y(:n - 1)) * 80.0_glfloat\n        dz = (z(2:) - z(:n - 1)) * 80.0_glfloat\n      end block  \n    end if  \n    ! Clear the window with current clearing color\n    call glClear(GL_COLOR_BUFFER_BIT)\n    ! Save matrix state and do the rotation\n    call glPushMatrix\n    call glRotatef(xRot, 1.0, 0.0, 0.0)\n    call glRotatef(yRot, 0.0, 1.0, 0.0)\n    ! draw Lorenz attractor\n    do i = 1, n - 1\n      call glTranslatef( dx(i), dy(i), dz(i) )\n      call glutSolidCube(0.5_gldouble )\n    end do\n    !\n    call glPopMatrix\n    ! Flush drawing commands\n    call glutSwapBuffers\n  end subroutine RenderScene\nend module m_gl\n\nprogram RANDU\n   use m_gl\n   implicit none\n   integer :: iwin\n   call glutInit()\n   call glutInitDisplayMode(ior(GLUT_DOUBLE,ior(GLUT_RGB,GLUT_DEPTH)))\n   call glutInitWindowSize(800, 600)\n   iwin = glutCreateWindow('RANDU'//char(0))\n   call glutReshapeFunc ( ChangeSize     )\n   call glutKeyboardFunc( KeyPressFunc   )\n   call glutSpecialFunc ( KeySpecialFunc )\n   call glutDisplayFunc ( RenderScene    )\n   call SetupRC()\n   call glutMainLoop()\nend program RANDU\n```\n\n\n\n\n", "tags": ["Fortran2003", "glut"]}