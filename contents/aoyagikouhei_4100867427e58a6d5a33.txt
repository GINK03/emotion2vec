{"tags": ["rust"], "context": "Rust\u3092\u52c9\u5f37\u3057\u3066\u3066\u4f55\u304b\u5b9f\u969b\u306b\u4f7f\u3063\u3066\u307f\u305f\u304b\u3063\u305f\u9803\u306b\u3001Rails\u306aWeb\u30a2\u30d7\u30ea\u30b1\u30fc\u30b7\u30e7\u30f3\u3067CSV\u3092\u30c0\u30a6\u30f3\u30ed\u30fc\u30c9\u3059\u308b\u4ed5\u7d44\u307f\u304c\u3042\u3063\u3066\u3001\u666e\u901a\u306b\u4f5c\u3063\u3066\u307f\u305f\u3068\u3053\u308d\u30e1\u30e2\u30ea\u3092\u98df\u3044\u3064\u3076\u3057\u3066\u52d5\u304b\u306a\u304b\u3063\u305f\u306e\u3067\u3001Rust\u3067\u4f5c\u3063\u3066\u307f\u307e\u3057\u305f\u3002\nRails\u3067\u306f\u4ee5\u4e0b\u306e\u3088\u3046\u306b\u884c\u3063\u3066\u3044\u307e\u3057\u305f\u3002\n1. \u4f5c\u6210\u3059\u308bCSV\u306b\u95a2\u3059\u308b\u30d1\u30e9\u30e1\u30fc\u30bf\u30fc\u53d6\u5f97\n2. DB\u304b\u3089SELECT\n3. CSV\u30d5\u30a1\u30a4\u30eb\u4f5c\u6210\n4. ZIP\u5727\u7e2e\n5. \u30ec\u30b9\u30dd\u30f3\u30b9\u3067\u8fd4\u3059\n\u3053\u3053\u30672,3\u3092Rust\u3067\u5b9f\u884c\u3059\u308b\u3088\u3046\u306b\u3057\u307e\u3057\u305f\u3002\n\u3055\u3089\u306bRails\u3092\u697d\u306b\u3059\u308b\u305f\u3081\n4\u306f\u5916\u90e8\u30b3\u30de\u30f3\u30c9\u3067\u5b9f\u884c\n5\u306fX-Accel-Redirect\u3092\u4f7f\u3063\u3066nginx\u306b\u4efb\u305b\u307e\u3057\u305f\u3002\nCSV\u306e\u51fa\u529b\u7bc4\u56f2\u306f1\u65e5\u3092\u60f3\u5b9a\u3057\u3066\u3044\u3066\nRails\u304b\u3089\u306fffi\u7d4c\u7531\u3067\u547c\u3073\u51fa\u3057\u3066\u3044\u307e\u3059\u3002\n\u7d50\u679c\u300114\u4e07\u4ef6\u306e\u30c7\u30fc\u30bf\u30fc\u304c6\u5206\u304f\u3089\u3044\u3067\u30c0\u30a6\u30f3\u30ed\u30fc\u30c9\u3067\u304d\u307e\u3057\u305f\u3002ZIP\u30d5\u30a1\u30a4\u30eb\u306e\u30b5\u30a4\u30ba\u306f27MB\u3067\u3057\u305f\u3002\n\u30e1\u30e2\u30ea\u306f10MB\u304f\u3089\u3044\u4f7f\u3063\u3066\u3044\u307e\u3057\u305f\u3002\nRails\u3060\u30684GB\u30e1\u30e2\u30ea\u3092\u7a4d\u3093\u3060\u30de\u30b7\u30f3\u3067\u30e1\u30e2\u30ea\u98df\u3044\u3064\u3076\u3057\u3066\u30b5\u30fc\u30d0\u30fc\u3054\u3068\u304a\u4ea1\u304f\u306a\u308a\u3060\u3063\u305f\u306e\u3067\u3001Rust\u306e\u5a01\u529b\u3092\u898b\u305b\u3064\u3051\u3089\u308c\u307e\u3057\u305f\u3002\nRails\u3068Rust\u3092\u7d44\u307f\u5408\u308f\u305b\u308b\u3068\u52b9\u7387\u7684\u306a\u30a2\u30d7\u30ea\u30b1\u30fc\u30b7\u30e7\u30f3\u304c\u7d44\u3081\u308b\u3068\u5b9f\u611f\u3057\u307e\u3057\u305f\u3002\nRust1.13.0\u3067\u4f5c\u308a\u307e\u3057\u305f\u3002\n\nCargo.toml\n[package]\nname = \"make_csv\"\nversion = \"0.1.0\"\nauthors = [\"aoyagikouhei\"]\n\n[lib]\nname = \"make_csv\"\ncrate-type = [\"dylib\"]\n\n[dependencies]\nlibc = \"*\"\nchrono = \"*\"\npostgres = { version=\"*\", features=[\"with-chrono\"]}\n\n\n\nlib.rs\nextern crate libc;\nextern crate postgres;\nextern crate chrono;\n\nmod csv;\n\nuse std::ffi::CStr;\n\n#[no_mangle]\npub extern fn execute(\n    connection: *const libc::c_char, \n    file_path: *const libc::c_char, \n    start_at: *const libc::c_char, \n    end_at: *const libc::c_char\n){\n    let connection_cstr = unsafe { CStr::from_ptr(connection) };\n    let file_path_cstr = unsafe { CStr::from_ptr(file_path) };\n    let start_at_cstr = unsafe { CStr::from_ptr(start_at) };\n    let end_at_cstr = unsafe { CStr::from_ptr(end_at) };\n    let connection_str = connection_cstr.to_str().unwrap();\n    let file_path_str = file_path_cstr.to_str().unwrap();\n    let start_at_str = start_at_cstr.to_str().unwrap();\n    let end_at_str = end_at_cstr.to_str().unwrap();\n\n    let mut maker = csv::CsvMaker::new(\n        connection_str,\n        file_path_str,\n        start_at_str,\n        end_at_str\n    );\n    maker.execute();\n}\n\n\n\ncsv.rs\nextern crate postgres;\nextern crate chrono;\n\nuse postgres::{Connection, TlsMode};\nuse std::io::prelude::*;\nuse std::fs::File;\nuse chrono::{DateTime, Local, Duration};\nuse std::cell::RefCell;\n\nfn make_sql() -> String {\n    let sql = r#\"\n        SELECT\n            COALESCE(t1.tweet_json->'user'->>'screen_name', '')\n            ,COALESCE(t1.tweet_json->>'text', '')\n            ,COALESCE(to_char(\n                to_timestamp(\n                    t1.tweet_json->>'created_at'\n                    ,'Dy Mon DD HH24:MI:SS +0000 YYYY'\n                )::TIMESTAMPTZ + interval'9 hour'\n                ,'YYYY/MM/DD HH24:MI'\n            ), '')\n            ,COALESCE(t1.tweet_json->'user'->>'statuses_count', '')\n            ,COALESCE(t1.tweet_json->'user'->>'friends_count', '')\n            ,COALESCE(t1.tweet_json->'user'->>'followers_count', '')\n            ,COALESCE(t1.tweet_json->'user'->>'listed_count', '')\n            ,COALESCE(t1.tweet_json->'user'->>'description', '')\n            ,COALESCE(to_char(\n                to_timestamp(\n                    t1.tweet_json->'user'->>'created_at'\n                    ,'Dy Mon DD HH24:MI:SS +0000 YYYY'\n                )::TIMESTAMPTZ + interval'9 hour'\n                ,'YYYY/MM/DD HH24:MI'\n            ), '')\n        FROM\n            public.tweets AS t1\n        WHERE\n            t1.created_at >= $1\n            AND t1.created_at < $2\n        ORDER BY\n            t1.created_at ASC\n    \"#;\n    sql.to_string()\n}\n\npub struct CsvMaker {\n    pub connection: Connection,\n    pub file: RefCell<File>,\n    pub start_at: DateTime<Local>,\n    pub end_at: DateTime<Local>,\n    pub sql: String\n}\n\nimpl CsvMaker {\n    pub fn new(\n        connection_str: &str,\n        file_path: &str,\n        start_at_str: &str,\n        end_at_str: &str\n    ) -> CsvMaker {\n        let connection = Connection::connect(\n            connection_str, TlsMode::None).unwrap();\n        let file = RefCell::new(File::create(file_path).unwrap());\n        let start_at = start_at_str.parse::<DateTime<Local>>().unwrap();\n        let end_at = end_at_str.parse::<DateTime<Local>>().unwrap();\n        let sql = make_sql();\n        CsvMaker {\n            connection: connection,\n            file: file,\n            start_at: start_at,\n            end_at: end_at,\n            sql: sql\n        }\n    }\n\n    pub fn execute(&mut self) {\n        let header = format!(\n            \"\\\"{}\\\",\\\"{}\\\",\\\"{}\\\",\\\"{}\\\",\\\"{}\\\",\\\"{}\\\",\\\"{}\\\",\\\"{}\\\",\\\"{}\\\",\\\"{}\\\"\\n\", \n            \"\u30a2\u30ab\u30a6\u30f3\u30c8\u540d\", \n            \"\u30c4\u30a4\u30fc\u30c8\u5185\u5bb9\",\n            \"\u6295\u7a3f\u65e5\u6642\",\n            \"\u30c4\u30a4\u30fc\u30c8\u6570\",\n            \"\u30d5\u30a9\u30ed\u30fc\u6570\",\n            \"\u30d5\u30a9\u30ed\u30ef\u30fc\u6570\",\n            \"\u3044\u3044\u306d\u6570\",\n            \"\u30ea\u30b9\u30c8\u6570\",\n            \"\u81ea\u5df1\u7d39\u4ecb\",\n            \"\u30a2\u30ab\u30a6\u30f3\u30c8\u767b\u9332\u65e5\u6642\"\n            );\n        {\n            let mut f = self.file.borrow_mut();\n            let _ = f.write(b\"\\xEF\\xBB\\xBF\");\n            let _ = f.write(header.as_bytes());\n        }\n\n        let mut next_at: DateTime<Local> = self.start_at.clone();\n\n        loop {\n            self.execute_one(&next_at);\n            next_at = next_at + chrono::Duration::seconds(3600);\n            if next_at >= self.end_at {\n                break;\n            }\n        }\n        {\n            let mut f = self.file.borrow_mut();\n            let _ = f.flush();\n        }\n    }\n\n    fn execute_one(&self, next_at: &DateTime<Local>) {\n        let next_end_at: DateTime<Local> = *next_at + Duration::seconds(3600);\n        let mut f = self.file.borrow_mut();\n        for row in &self.connection.query(&self.sql, &[&next_at, &next_end_at]).unwrap() {\n            let screen_name: String = row.get(0);\n            let tweet_content: String = row.get(1);\n            let tweet_created_at: String = row.get(2);\n            let statuses_count: String = row.get(3);\n            let friends_count: String = row.get(4);\n            let followers_count: String = row.get(5);\n            let favourites_count: String = row.get(6);\n            let listed_count: String = row.get(7);\n            let description: String = row.get(8);\n            let user_created_at: String = row.get(9);\n\n            let line = format!(\n                \"\\\"{}\\\",\\\"{}\\\",\\\"{}\\\",\\\"{}\\\",\\\"{}\\\",\\\"{}\\\",\\\"{}\\\",\\\"{}\\\",\\\"{}\\\",\\\"{}\\\"\\n\", \n                screen_name,\n                tweet_content,\n                tweet_created_at,\n                statuses_count,\n                friends_count,\n                followers_count,\n                favourites_count,\n                listed_count,\n                description,\n                user_created_at\n            );\n            let _ = f.write(line.as_bytes());\n        }\n    }\n}\n\n\n\ncsv.rb\nrequire 'ffi'\nrequire 'systemu'\n\nmodule App \n  class Csv \n    extend FFI::Library\n    ffi_lib '../make_csv/target/release/libmake_csv.so'\n    attach_function :execute, [:string, :string, :string, :string]\n\n     def initialize()\n      Dir.mkdir(\"/tmp/tweets\") if !Dir.exist?(\"/tmp/tweets\")\n    end\n\n    def exec(start_at, end_at)\n      dir = Dir.mktmpdir(\"tweets/\")\n      self.class.execute(\n        \"postgres://localhost:5432/web_development\", \n        dir + \"/tweets.csv\", \n        start_at, \n        end_at)\n      Dir.chdir(dir) do\n        systemu \"/usr/bin/zip -m tweets.zip tweets.csv\"\n      end\n      dir + \"/tweets.zip\"\n    end\n  end\nend\n\n\nRust\u3092\u52c9\u5f37\u3057\u3066\u3066\u4f55\u304b\u5b9f\u969b\u306b\u4f7f\u3063\u3066\u307f\u305f\u304b\u3063\u305f\u9803\u306b\u3001Rails\u306aWeb\u30a2\u30d7\u30ea\u30b1\u30fc\u30b7\u30e7\u30f3\u3067CSV\u3092\u30c0\u30a6\u30f3\u30ed\u30fc\u30c9\u3059\u308b\u4ed5\u7d44\u307f\u304c\u3042\u3063\u3066\u3001\u666e\u901a\u306b\u4f5c\u3063\u3066\u307f\u305f\u3068\u3053\u308d\u30e1\u30e2\u30ea\u3092\u98df\u3044\u3064\u3076\u3057\u3066\u52d5\u304b\u306a\u304b\u3063\u305f\u306e\u3067\u3001Rust\u3067\u4f5c\u3063\u3066\u307f\u307e\u3057\u305f\u3002\n\nRails\u3067\u306f\u4ee5\u4e0b\u306e\u3088\u3046\u306b\u884c\u3063\u3066\u3044\u307e\u3057\u305f\u3002\n1. \u4f5c\u6210\u3059\u308bCSV\u306b\u95a2\u3059\u308b\u30d1\u30e9\u30e1\u30fc\u30bf\u30fc\u53d6\u5f97\n2. DB\u304b\u3089SELECT\n3. CSV\u30d5\u30a1\u30a4\u30eb\u4f5c\u6210\n4. ZIP\u5727\u7e2e\n5. \u30ec\u30b9\u30dd\u30f3\u30b9\u3067\u8fd4\u3059\n\n\u3053\u3053\u30672,3\u3092Rust\u3067\u5b9f\u884c\u3059\u308b\u3088\u3046\u306b\u3057\u307e\u3057\u305f\u3002\n\u3055\u3089\u306bRails\u3092\u697d\u306b\u3059\u308b\u305f\u3081\n4\u306f\u5916\u90e8\u30b3\u30de\u30f3\u30c9\u3067\u5b9f\u884c\n5\u306fX-Accel-Redirect\u3092\u4f7f\u3063\u3066nginx\u306b\u4efb\u305b\u307e\u3057\u305f\u3002\n\nCSV\u306e\u51fa\u529b\u7bc4\u56f2\u306f1\u65e5\u3092\u60f3\u5b9a\u3057\u3066\u3044\u3066\nRails\u304b\u3089\u306fffi\u7d4c\u7531\u3067\u547c\u3073\u51fa\u3057\u3066\u3044\u307e\u3059\u3002\n\n\u7d50\u679c\u300114\u4e07\u4ef6\u306e\u30c7\u30fc\u30bf\u30fc\u304c6\u5206\u304f\u3089\u3044\u3067\u30c0\u30a6\u30f3\u30ed\u30fc\u30c9\u3067\u304d\u307e\u3057\u305f\u3002ZIP\u30d5\u30a1\u30a4\u30eb\u306e\u30b5\u30a4\u30ba\u306f27MB\u3067\u3057\u305f\u3002\n\u30e1\u30e2\u30ea\u306f10MB\u304f\u3089\u3044\u4f7f\u3063\u3066\u3044\u307e\u3057\u305f\u3002\nRails\u3060\u30684GB\u30e1\u30e2\u30ea\u3092\u7a4d\u3093\u3060\u30de\u30b7\u30f3\u3067\u30e1\u30e2\u30ea\u98df\u3044\u3064\u3076\u3057\u3066\u30b5\u30fc\u30d0\u30fc\u3054\u3068\u304a\u4ea1\u304f\u306a\u308a\u3060\u3063\u305f\u306e\u3067\u3001Rust\u306e\u5a01\u529b\u3092\u898b\u305b\u3064\u3051\u3089\u308c\u307e\u3057\u305f\u3002\nRails\u3068Rust\u3092\u7d44\u307f\u5408\u308f\u305b\u308b\u3068\u52b9\u7387\u7684\u306a\u30a2\u30d7\u30ea\u30b1\u30fc\u30b7\u30e7\u30f3\u304c\u7d44\u3081\u308b\u3068\u5b9f\u611f\u3057\u307e\u3057\u305f\u3002\n\nRust1.13.0\u3067\u4f5c\u308a\u307e\u3057\u305f\u3002\n\n```rust:Cargo.toml\n[package]\nname = \"make_csv\"\nversion = \"0.1.0\"\nauthors = [\"aoyagikouhei\"]\n\n[lib]\nname = \"make_csv\"\ncrate-type = [\"dylib\"]\n\n[dependencies]\nlibc = \"*\"\nchrono = \"*\"\npostgres = { version=\"*\", features=[\"with-chrono\"]}\n```\n\n```rust:lib.rs\nextern crate libc;\nextern crate postgres;\nextern crate chrono;\n\nmod csv;\n\nuse std::ffi::CStr;\n\n#[no_mangle]\npub extern fn execute(\n    connection: *const libc::c_char, \n    file_path: *const libc::c_char, \n    start_at: *const libc::c_char, \n    end_at: *const libc::c_char\n){\n    let connection_cstr = unsafe { CStr::from_ptr(connection) };\n    let file_path_cstr = unsafe { CStr::from_ptr(file_path) };\n    let start_at_cstr = unsafe { CStr::from_ptr(start_at) };\n    let end_at_cstr = unsafe { CStr::from_ptr(end_at) };\n    let connection_str = connection_cstr.to_str().unwrap();\n    let file_path_str = file_path_cstr.to_str().unwrap();\n    let start_at_str = start_at_cstr.to_str().unwrap();\n    let end_at_str = end_at_cstr.to_str().unwrap();\n\n    let mut maker = csv::CsvMaker::new(\n        connection_str,\n        file_path_str,\n        start_at_str,\n        end_at_str\n    );\n    maker.execute();\n}\n```\n\n```rust:csv.rs\nextern crate postgres;\nextern crate chrono;\n\nuse postgres::{Connection, TlsMode};\nuse std::io::prelude::*;\nuse std::fs::File;\nuse chrono::{DateTime, Local, Duration};\nuse std::cell::RefCell;\n\nfn make_sql() -> String {\n    let sql = r#\"\n        SELECT\n            COALESCE(t1.tweet_json->'user'->>'screen_name', '')\n            ,COALESCE(t1.tweet_json->>'text', '')\n            ,COALESCE(to_char(\n                to_timestamp(\n                    t1.tweet_json->>'created_at'\n                    ,'Dy Mon DD HH24:MI:SS +0000 YYYY'\n                )::TIMESTAMPTZ + interval'9 hour'\n                ,'YYYY/MM/DD HH24:MI'\n            ), '')\n            ,COALESCE(t1.tweet_json->'user'->>'statuses_count', '')\n            ,COALESCE(t1.tweet_json->'user'->>'friends_count', '')\n            ,COALESCE(t1.tweet_json->'user'->>'followers_count', '')\n            ,COALESCE(t1.tweet_json->'user'->>'listed_count', '')\n            ,COALESCE(t1.tweet_json->'user'->>'description', '')\n            ,COALESCE(to_char(\n                to_timestamp(\n                    t1.tweet_json->'user'->>'created_at'\n                    ,'Dy Mon DD HH24:MI:SS +0000 YYYY'\n                )::TIMESTAMPTZ + interval'9 hour'\n                ,'YYYY/MM/DD HH24:MI'\n            ), '')\n        FROM\n            public.tweets AS t1\n        WHERE\n            t1.created_at >= $1\n            AND t1.created_at < $2\n        ORDER BY\n            t1.created_at ASC\n    \"#;\n    sql.to_string()\n}\n\npub struct CsvMaker {\n    pub connection: Connection,\n    pub file: RefCell<File>,\n    pub start_at: DateTime<Local>,\n    pub end_at: DateTime<Local>,\n    pub sql: String\n}\n\nimpl CsvMaker {\n    pub fn new(\n        connection_str: &str,\n        file_path: &str,\n        start_at_str: &str,\n        end_at_str: &str\n    ) -> CsvMaker {\n        let connection = Connection::connect(\n            connection_str, TlsMode::None).unwrap();\n        let file = RefCell::new(File::create(file_path).unwrap());\n        let start_at = start_at_str.parse::<DateTime<Local>>().unwrap();\n        let end_at = end_at_str.parse::<DateTime<Local>>().unwrap();\n        let sql = make_sql();\n        CsvMaker {\n            connection: connection,\n            file: file,\n            start_at: start_at,\n            end_at: end_at,\n            sql: sql\n        }\n    }\n\n    pub fn execute(&mut self) {\n        let header = format!(\n            \"\\\"{}\\\",\\\"{}\\\",\\\"{}\\\",\\\"{}\\\",\\\"{}\\\",\\\"{}\\\",\\\"{}\\\",\\\"{}\\\",\\\"{}\\\",\\\"{}\\\"\\n\", \n            \"\u30a2\u30ab\u30a6\u30f3\u30c8\u540d\", \n            \"\u30c4\u30a4\u30fc\u30c8\u5185\u5bb9\",\n            \"\u6295\u7a3f\u65e5\u6642\",\n            \"\u30c4\u30a4\u30fc\u30c8\u6570\",\n            \"\u30d5\u30a9\u30ed\u30fc\u6570\",\n            \"\u30d5\u30a9\u30ed\u30ef\u30fc\u6570\",\n            \"\u3044\u3044\u306d\u6570\",\n            \"\u30ea\u30b9\u30c8\u6570\",\n            \"\u81ea\u5df1\u7d39\u4ecb\",\n            \"\u30a2\u30ab\u30a6\u30f3\u30c8\u767b\u9332\u65e5\u6642\"\n            );\n        {\n            let mut f = self.file.borrow_mut();\n            let _ = f.write(b\"\\xEF\\xBB\\xBF\");\n            let _ = f.write(header.as_bytes());\n        }\n\n        let mut next_at: DateTime<Local> = self.start_at.clone();\n\n        loop {\n            self.execute_one(&next_at);\n            next_at = next_at + chrono::Duration::seconds(3600);\n            if next_at >= self.end_at {\n                break;\n            }\n        }\n        {\n            let mut f = self.file.borrow_mut();\n            let _ = f.flush();\n        }\n    }\n\n    fn execute_one(&self, next_at: &DateTime<Local>) {\n        let next_end_at: DateTime<Local> = *next_at + Duration::seconds(3600);\n        let mut f = self.file.borrow_mut();\n        for row in &self.connection.query(&self.sql, &[&next_at, &next_end_at]).unwrap() {\n            let screen_name: String = row.get(0);\n            let tweet_content: String = row.get(1);\n            let tweet_created_at: String = row.get(2);\n            let statuses_count: String = row.get(3);\n            let friends_count: String = row.get(4);\n            let followers_count: String = row.get(5);\n            let favourites_count: String = row.get(6);\n            let listed_count: String = row.get(7);\n            let description: String = row.get(8);\n            let user_created_at: String = row.get(9);\n\n            let line = format!(\n                \"\\\"{}\\\",\\\"{}\\\",\\\"{}\\\",\\\"{}\\\",\\\"{}\\\",\\\"{}\\\",\\\"{}\\\",\\\"{}\\\",\\\"{}\\\",\\\"{}\\\"\\n\", \n                screen_name,\n                tweet_content,\n                tweet_created_at,\n                statuses_count,\n                friends_count,\n                followers_count,\n                favourites_count,\n                listed_count,\n                description,\n                user_created_at\n            );\n            let _ = f.write(line.as_bytes());\n        }\n    }\n}\n```\n\n```ruby:csv.rb\nrequire 'ffi'\nrequire 'systemu'\n\nmodule App \n  class Csv \n    extend FFI::Library\n    ffi_lib '../make_csv/target/release/libmake_csv.so'\n    attach_function :execute, [:string, :string, :string, :string]\n\n     def initialize()\n      Dir.mkdir(\"/tmp/tweets\") if !Dir.exist?(\"/tmp/tweets\")\n    end\n\n    def exec(start_at, end_at)\n      dir = Dir.mktmpdir(\"tweets/\")\n      self.class.execute(\n        \"postgres://localhost:5432/web_development\", \n        dir + \"/tweets.csv\", \n        start_at, \n        end_at)\n      Dir.chdir(dir) do\n        systemu \"/usr/bin/zip -m tweets.zip tweets.csv\"\n      end\n      dir + \"/tweets.zip\"\n    end\n  end\nend\n```\n"}