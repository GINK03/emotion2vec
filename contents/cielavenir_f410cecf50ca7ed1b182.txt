{"context": " More than 1 year has passed since last update.http://dwango2016-honsen.contest.atcoder.jp/tasks/dwango2016final_a\n\n\u30cb\u30b3\u30cb\u30b3\u6570(2,5,25,52,252,525,2525,...)\u3092N\u307e\u3067\u5217\u6319\u3059\u308b(A\u3068\u3059\u308b)\u3002\nd(n)=minlen(A)i=1d(nAi)+nmodAid(n)=mini=1len(A)d(nAi)+nmodAid(n)=\\min^{len(A)}_{i=1} d(\\frac{n}{A_i})+n \\bmod A_i \u3068\u306a\u308b\u3002\n\u305f\u3060\u3057d(n)\u306f\u30e1\u30e2\u5316\u304c\u5fc5\u8981\u3068\u306a\u308b\u3002\n\nRuby\u3067\u306e\u5b9f\u88c5\u3002\n\nhttp://dwango2016-honsen.contest.atcoder.jp/submissions/637050\n\nz=->(n){n<=N&&A<<n&&z[n*10+10/(n%10)]}\nd=->(n){M[n]||=A.map{|e|d[n/e]+n%e}.min}\nM={0=>0}\nN=gets.to_i\nA=[]\nz[2];z[5]\np d[N]\n\n\u30cb\u30b3\u30cb\u30b3\u6570\u5217\u6319\u3092\u518d\u5e30\u3067\u884c\u3063\u3066\u3044\u308b\u4ee5\u5916\u306f\u3055\u307b\u3069\u5947\u3092\u3066\u3089\u3063\u305f\u66f8\u304d\u65b9\u3067\u306f\u306a\u3044\u3068\u601d\u3046\u3002\n\u3068\u3053\u308d\u3067\u3001\u518d\u5e30\u3067\u66f8\u3051\u308b\u306a\u3089\u3001Haskell\u3067\u66f8\u3044\u3066\u307f\u305f\u3044\u3002\n\u5b9f\u88c5\u3057\u3066\u307f\u305f\u3002\nz a n l = if n>l then a else z (n:a) (n*10+10 `div` (n `mod` 10)) l\nd a n = if n==0 then 0 else minimum $ map (\\e -> (n `mod` e) + (d a (n `div` e))) a\n\nmain = do\n    n<-readLn\n    let a=(z [] 2 n)++(z [] 5 n)\n    print $ d a n\n\n\u898b\u3066\u306e\u901a\u308a\u3001\u30e1\u30e2\u5316\u3067\u304d\u3066\u3044\u306a\u3044\u3002\u3053\u308c\u306f\u3001Haskell\u3060\u3068\u3001\u675f\u7e1b\u306e\u7834\u58ca\u7684\u5909\u66f4\u304c\u3067\u304d\u306a\u3044\u304b\u3089\u3067\u3042\u308b\u3002\n\u3068\u3053\u308d\u3067\u3001\u95a2\u6570d\u3092\u518d\u5e30\u3059\u308b\u969b\u306ba\u304c\u51fa\u3066\u3053\u306a\u3044\u3088\u3046\u306b\u3059\u308b\u3053\u3068\u304c\u3067\u304d\u3066\u3001\u305d\u306e\u305f\u3081\u306b\u306f\u3053\u306e\u3088\u3046\u306b\u5909\u66f4\u3059\u308b(import qualified Control.Monad.Fix)\u3002\nd a = (\\f n -> if n==0 then 0 else minimum $ map (\\e -> (n `mod` e) + (f (n `div` e))) a) (d a)\n\nd a = Control.Monad.Fix.fix $ \\f n -> if n==0 then 0 else minimum $ map (\\e -> (n `mod` e) + (f (n `div` e))) a\n\n\u3053\u3046\u306a\u308c\u3070\u3057\u3081\u305f\u3082\u306e\u3067\u3001Control.Monad.Fix.fix\u3092 @tanakh \u6c0f\u4f5c\u306ememofix( http://d.hatena.ne.jp/tanakh/20100411 )\u306b\u7f6e\u304d\u63db\u3048\u308c\u3070\u30e1\u30e2\u5316\u5b8c\u4e86\u3067\u3042\u308b\u3002\u6c0f\u306e\u5b9f\u88c5\u306f\u9045\u5ef6\u8a55\u4fa1\u6728\u3092\u4f7f\u3046\u305f\u3081IO\u3092\u5fc5\u8981\u3068\u305b\u305a\u3001\u4eca\u56de\u306e\u76ee\u7684\u306b\u3082\u3074\u3063\u305f\u308a\u3067\u3042\u308b\u3002\n\nhttp://dwango2016-honsen.contest.atcoder.jp/submissions/637106\n\n#!/usr/bin/env runghc\n\n-- http://d.hatena.ne.jp/tanakh/20100411\nclass MemoIx a where\n  index :: a -> Integer\n  unindex :: Integer -> a\n\ninstance MemoIx Integer where\n  index n | n>=0 = n*2\n          | otherwise = -n*2-1\n\n  unindex n | n`mod`2==0 = n`div`2\n            | otherwise = -((n+1)`div`2)\n\ninstance (MemoIx a, MemoIx b) => MemoIx (a, b) where\n  index (a, b) = l*(l+1)`div`2 + ib\n    where\n      ia = index a \n      ib = index b\n      l  = ia+ib\n\n  unindex ix = (unindex ia, unindex ib)\n    where\n      l  = floor ((-1 + sqrt (1 + 8 * fromIntegral ix))/2)\n      ib = ix - l*(l+1)`div`2\n      ia = l-ib\n\ndata Tree a = Tree a (Tree a) (Tree a)\n\nfindTree :: MemoIx a => Tree b -> a -> b\nfindTree tree ix = f (bits $ index ix + 1) tree\n  where\n    f []     (Tree v _ _) = v\n    f (0:bs) (Tree _ l _) = f bs l\n    f (_:bs) (Tree _ _ r) = f bs r\n\n    bits = tail . reverse . map (`mod`2). takeWhile (>0) . iterate (`div`2)\n\ngenTree :: MemoIx a => (a -> b) -> Tree b\ngenTree f = gen 0 where\n  gen ix = Tree (f $ unindex ix) (gen $ ix*2+1) (gen $ ix*2+2)\n\nmemofix :: MemoIx a => ((a -> b) -> (a -> b)) -> (a -> b)\nmemofix f = memof where\n  memof = f $ findTree tbl\n  tbl = genTree memof\n\nmemo :: MemoIx a => (a -> b) -> (a -> b)\nmemo f = findTree (genTree f)\n\n-- program\nz a n l = if n>l then a else z (n:a) (n*10+10 `div` (n `mod` 10)) l\nd::[Integer]->Integer->Integer\nd a = memofix $ \\f n -> if n==0 then 0 else minimum $ map (\\e -> (n `mod` e) + (f (n `div` e))) a\n\nmain = do\n    n<-readLn\n    let a=(z [] 2 n)++(z [] 5 n)\n    print $ d a n\n\n\n\ntanakh\u6c0f\u306fhaskellwiki\u306e\u65b9\u304c\u826f\u3044\u3068\u306e\u3053\u3068\u3067\u3059\u304c\u3001\u30b3\u30fc\u30c9\u30b9\u30cb\u30da\u30c3\u30c8\u304c\u898b\u3064\u304b\u3089\u306a\u304b\u3063\u305f\u306e\u3067\u2026\u3002\nd = memo $ \\a n -> ...\u3068\u306f\u66f8\u3051\u307e\u305b\u3093\u3067\u3057\u305f\u3002a\u3082\u30e1\u30e2\u5316\u3057\u3088\u3046\u3068\u3057\u3066\u3057\u307e\u3046\u3089\u3057\u304f\u3002\u5e78\u3044d\u304b\u3089\u898b\u308c\u3070a\u306f\u5b9a\u6570\u306a\u306e\u3067fix\u3059\u308c\u3070\u826f\u304b\u3063\u305f\u3002\nMathJax\u306e\u30c6\u30b9\u30c8 http://web-dou.com/math/view.php\n\n\nhttp://dwango2016-honsen.contest.atcoder.jp/tasks/dwango2016final_a\n\n- \u30cb\u30b3\u30cb\u30b3\u6570(2,5,25,52,252,525,2525,...)\u3092N\u307e\u3067\u5217\u6319\u3059\u308b(A\u3068\u3059\u308b)\u3002\n- $d(n)=\\min^{len(A)}\\_{i=1} d(\\frac{n}{A_i})+n \\bmod A_i$ \u3068\u306a\u308b\u3002\n- \u305f\u3060\u3057d(n)\u306f\u30e1\u30e2\u5316\u304c\u5fc5\u8981\u3068\u306a\u308b\u3002\n\nRuby\u3067\u306e\u5b9f\u88c5\u3002\n\n- http://dwango2016-honsen.contest.atcoder.jp/submissions/637050\n\n```rb\nz=->(n){n<=N&&A<<n&&z[n*10+10/(n%10)]}\nd=->(n){M[n]||=A.map{|e|d[n/e]+n%e}.min}\nM={0=>0}\nN=gets.to_i\nA=[]\nz[2];z[5]\np d[N]\n```\n\n\u30cb\u30b3\u30cb\u30b3\u6570\u5217\u6319\u3092\u518d\u5e30\u3067\u884c\u3063\u3066\u3044\u308b\u4ee5\u5916\u306f\u3055\u307b\u3069\u5947\u3092\u3066\u3089\u3063\u305f\u66f8\u304d\u65b9\u3067\u306f\u306a\u3044\u3068\u601d\u3046\u3002\n\u3068\u3053\u308d\u3067\u3001\u518d\u5e30\u3067\u66f8\u3051\u308b\u306a\u3089\u3001Haskell\u3067\u66f8\u3044\u3066\u307f\u305f\u3044\u3002\n\u5b9f\u88c5\u3057\u3066\u307f\u305f\u3002\n\n```hs\nz a n l = if n>l then a else z (n:a) (n*10+10 `div` (n `mod` 10)) l\nd a n = if n==0 then 0 else minimum $ map (\\e -> (n `mod` e) + (d a (n `div` e))) a\n \nmain = do\n\tn<-readLn\n\tlet a=(z [] 2 n)++(z [] 5 n)\n\tprint $ d a n\n```\n\n\u898b\u3066\u306e\u901a\u308a\u3001\u30e1\u30e2\u5316\u3067\u304d\u3066\u3044\u306a\u3044\u3002\u3053\u308c\u306f\u3001Haskell\u3060\u3068\u3001\u675f\u7e1b\u306e\u7834\u58ca\u7684\u5909\u66f4\u304c\u3067\u304d\u306a\u3044\u304b\u3089\u3067\u3042\u308b\u3002\n\n\u3068\u3053\u308d\u3067\u3001\u95a2\u6570d\u3092\u518d\u5e30\u3059\u308b\u969b\u306ba\u304c\u51fa\u3066\u3053\u306a\u3044\u3088\u3046\u306b\u3059\u308b\u3053\u3068\u304c\u3067\u304d\u3066\u3001\u305d\u306e\u305f\u3081\u306b\u306f\u3053\u306e\u3088\u3046\u306b\u5909\u66f4\u3059\u308b(import qualified Control.Monad.Fix)\u3002\n\n```hs\nd a = (\\f n -> if n==0 then 0 else minimum $ map (\\e -> (n `mod` e) + (f (n `div` e))) a) (d a)\n\nd a = Control.Monad.Fix.fix $ \\f n -> if n==0 then 0 else minimum $ map (\\e -> (n `mod` e) + (f (n `div` e))) a\n```\n\n\u3053\u3046\u306a\u308c\u3070\u3057\u3081\u305f\u3082\u306e\u3067\u3001`Control.Monad.Fix.fix`\u3092 @tanakh \u6c0f\u4f5c\u306ememofix( http://d.hatena.ne.jp/tanakh/20100411 )\u306b\u7f6e\u304d\u63db\u3048\u308c\u3070\u30e1\u30e2\u5316\u5b8c\u4e86\u3067\u3042\u308b\u3002\u6c0f\u306e\u5b9f\u88c5\u306f\u9045\u5ef6\u8a55\u4fa1\u6728\u3092\u4f7f\u3046\u305f\u3081IO\u3092\u5fc5\u8981\u3068\u305b\u305a\u3001\u4eca\u56de\u306e\u76ee\u7684\u306b\u3082\u3074\u3063\u305f\u308a\u3067\u3042\u308b\u3002\n\n- http://dwango2016-honsen.contest.atcoder.jp/submissions/637106\n\n```hs\n#!/usr/bin/env runghc\n\n-- http://d.hatena.ne.jp/tanakh/20100411\nclass MemoIx a where\n  index :: a -> Integer\n  unindex :: Integer -> a\n\ninstance MemoIx Integer where\n  index n | n>=0 = n*2\n          | otherwise = -n*2-1\n\n  unindex n | n`mod`2==0 = n`div`2\n            | otherwise = -((n+1)`div`2)\n\ninstance (MemoIx a, MemoIx b) => MemoIx (a, b) where\n  index (a, b) = l*(l+1)`div`2 + ib\n    where\n      ia = index a \n      ib = index b\n      l  = ia+ib\n\n  unindex ix = (unindex ia, unindex ib)\n    where\n      l  = floor ((-1 + sqrt (1 + 8 * fromIntegral ix))/2)\n      ib = ix - l*(l+1)`div`2\n      ia = l-ib\n\ndata Tree a = Tree a (Tree a) (Tree a)\n\nfindTree :: MemoIx a => Tree b -> a -> b\nfindTree tree ix = f (bits $ index ix + 1) tree\n  where\n    f []     (Tree v _ _) = v\n    f (0:bs) (Tree _ l _) = f bs l\n    f (_:bs) (Tree _ _ r) = f bs r\n\n    bits = tail . reverse . map (`mod`2). takeWhile (>0) . iterate (`div`2)\n\ngenTree :: MemoIx a => (a -> b) -> Tree b\ngenTree f = gen 0 where\n  gen ix = Tree (f $ unindex ix) (gen $ ix*2+1) (gen $ ix*2+2)\n\nmemofix :: MemoIx a => ((a -> b) -> (a -> b)) -> (a -> b)\nmemofix f = memof where\n  memof = f $ findTree tbl\n  tbl = genTree memof\n\nmemo :: MemoIx a => (a -> b) -> (a -> b)\nmemo f = findTree (genTree f)\n\n-- program\nz a n l = if n>l then a else z (n:a) (n*10+10 `div` (n `mod` 10)) l\nd::[Integer]->Integer->Integer\nd a = memofix $ \\f n -> if n==0 then 0 else minimum $ map (\\e -> (n `mod` e) + (f (n `div` e))) a\n\nmain = do\n\tn<-readLn\n\tlet a=(z [] 2 n)++(z [] 5 n)\n\tprint $ d a n\n```\n\n---\n\n- tanakh\u6c0f\u306fhaskellwiki\u306e\u65b9\u304c\u826f\u3044\u3068\u306e\u3053\u3068\u3067\u3059\u304c\u3001\u30b3\u30fc\u30c9\u30b9\u30cb\u30da\u30c3\u30c8\u304c\u898b\u3064\u304b\u3089\u306a\u304b\u3063\u305f\u306e\u3067\u2026\u3002\n- `d = memo $ \\a n -> ...`\u3068\u306f\u66f8\u3051\u307e\u305b\u3093\u3067\u3057\u305f\u3002a\u3082\u30e1\u30e2\u5316\u3057\u3088\u3046\u3068\u3057\u3066\u3057\u307e\u3046\u3089\u3057\u304f\u3002\u5e78\u3044d\u304b\u3089\u898b\u308c\u3070a\u306f\u5b9a\u6570\u306a\u306e\u3067fix\u3059\u308c\u3070\u826f\u304b\u3063\u305f\u3002\n\n- MathJax\u306e\u30c6\u30b9\u30c8 http://web-dou.com/math/view.php\n", "tags": ["AtCoder", "Haskell"]}