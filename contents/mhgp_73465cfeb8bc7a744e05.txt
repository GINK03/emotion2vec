{"context": "\n\n\u306f\u3058\u3081\u306b\n\u3075\u3068\u601d\u3044\u7acb\u3063\u3066 SHA-2 \u3092\u5b9f\u88c5\u3057\u305f\u306e\u3067\u3001\u4ed5\u69d8\u306e\u30e1\u30e2\u66f8\u304d\u3068\u5171\u306b\u516c\u958b\u3057\u3066\u307f\u308b\u3002\n\u6210\u679c\u7269\u306f GitHub-Gist \u306e\u300e Rust \u3067 SHA-2 \u3092\u5b9f\u88c5\u3057\u3066\u307f\u305f\u300f \u306b\u304a\u3044\u3066\u3042\u308b\u3002\n\nSHA-2 \u3068\u306f\nSHA-2 \u306f\u3001\u6539\u7ac4\u3055\u308c\u3066\u306a\u3044\u304b\u30c1\u30a7\u30c3\u30af\u3059\u308b\u306e\u306b\u9069\u3057\u305f\u30cf\u30c3\u30b7\u30e5\u95a2\u6570\uff08\u6697\u53f7\u5b66\u7684\u30cf\u30c3\u30b7\u30e5\u95a2\u6570\uff09\u306e\u6a19\u6e96\u898f\u683c\u306e\u4e00\u3064\u3002 NSA \uff08\u30a2\u30e1\u30ea\u30ab\u56fd\u5bb6\u5b89\u5168\u4fdd\u969c\u5c40\uff09\u304c\u8003\u6848\u3057\u3001 2001 \u5e74\u306b NIST \uff08\u30a2\u30e1\u30ea\u30ab\u56fd\u6a19\u6e96\u6280\u8853\u5c40\uff09\u306b\u3088\u3063\u3066\u9023\u90a6\u60c5\u5831\u51e6\u7406\u6a19\u6e96\u306e\u4e00\u3064\uff08 FIPS 180-4 \uff09\u3068\u3057\u3066\u6a19\u6e96\u5316\u3055\u308c\u305f\u3002 SHA-224 \u3001 SHA-256 \u3001 SHA-384 \u3001 SHA-512 \u3001 SHA-512/224 \u3001 SHA-512/256 \u306e 6 \u3064\u306e\u30d0\u30ea\u30a8\u30fc\u30b7\u30e7\u30f3\u304b\u3089\u306a\u308a\u3001\u305d\u308c\u305e\u308c\u306e\u672b\u5c3e\u306e\u6570\u5b57\u304c\u30cf\u30c3\u30b7\u30e5\u9577\uff08\u5358\u4f4d\u306f bit \uff09\u3092\u8868\u3057\u3066\u3044\u308b\uff08\u3064\u307e\u308a\u3001\u30cf\u30c3\u30b7\u30e5\u9577\u306f 224 \u3001 256 \u3001 384 \u3001 512 bit \u306e 4 \u3064\uff09\u3002 SHA \u306f \" Secure Hash Algorithm \" \u306e\u7565\u3067\u3042\u308b\u3002\n\n\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0\nSHA-2 \u306f SHA-256 \u3092\u5207\u308a\u8a70\u3081\u305f\u3082\u306e\uff08\u4ee5\u964d\u3001 SHA-256 \u7cfb\uff09\u3068 SHA-512 \u3092\u5207\u308a\u8a70\u3081\u305f\u3082\u306e\uff08\u4ee5\u964d\u3001 SHA-512 \u7cfb\uff09\u306e 2 \u3064\u306b\u5927\u5225\u3067\u304d\u308b\u3002\u4ee5\u4e0b\u306f\u305d\u308c\u305e\u308c\u304c\u3069\u3061\u3089\u306b\u90e8\u985e\u51fa\u6765\u308b\u304b\u3092\u793a\u3057\u305f\u3082\u306e\u3067\u3042\u308b\u3002\n\n\n\n\u90e8\u985e\n\u30d0\u30ea\u30a8\u30fc\u30b7\u30e7\u30f3\u540d\n\n\n\n\nSHA-256 \u7cfb\nSHA-224\n\nSHA-256\n\nSHA-512 \u7cfb\nSHA-384\n\nSHA-51\nSHA-512/224\nSHA-512/256\n\n\nSHA-256 \u7cfb\u3068 SHA-512 \u7cfb\u306e\u30ef\u30fc\u30c9\u9577\u3068\u30e9\u30a6\u30f3\u30c9\u6570\u306e\u9055\u3044\u306f\u6b21\u306e\u8868\u306b\u793a\u3059\u901a\u308a\u3002\n\n\n\n\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0\n\u30ef\u30fc\u30c9\u9577\n\u30e9\u30a6\u30f3\u30c9\u6570\n\n\n\n\nSHA-256\n32\n64\n\n\nSHA-512\n64\n80\n\n\n\n\u305d\u306e\u307b\u304b\u306b\u3082\u30b7\u30d5\u30c8\u91cf\u3084\u3001\u8ffd\u52a0\u5b9a\u6570\u306a\u3069\u3082\u9055\u3046\u304c\u3001\u672c\u8cea\u7684\u306a\u69cb\u9020\u306f\u3044\u305a\u308c\u3082\u540c\u3058\u3067\u3042\u308b\u3002\n\n\u6570\u5f0f\u306e\u8a18\u53f7\u3068\u30d7\u30ed\u30b0\u30e9\u30e0\u306e\u5bfe\u5fdc\n\n$x + y$\nx.wrapping_add(y)\n$x \\oplus y$\nx ^ y\n$x \\wedge y$\nx & y\n$\\lnot x$\n!x\n${\\it ROTR}^{\\,y}(x)$\nx.rotate_right(y)\n${\\it SHR}^{\\,y}(x)$\nx >> y\n\n\nSHA-2 \u306e\u69cb\u9020\n\u30e1\u30c3\u30bb\u30fc\u30b8\uff08\u30cf\u30c3\u30b7\u30e5\u3092\u4f5c\u308a\u305f\u3044\u30c7\u30fc\u30bf\uff09\u3092 $M_{\\rm in}$ \u3001\u30e1\u30c3\u30bb\u30fc\u30b8\u9577\u3092 $l$ \u3068\u3057\u305f\u3068\u304d\u3001 SHA-2 \u306e\u3059\u3079\u3066\u306e\u30d0\u30ea\u30a8\u30fc\u30b7\u30e7\u30f3\u306f\u3001\u4ee5\u4e0b\u306e\u69cb\u9020\u3092\u6301\u3064\u3002\n\u3053\u306e\u3046\u3061\u3001\u3059\u3079\u3066\u306e\u30d0\u30ea\u30a8\u30fc\u30b7\u30e7\u30f3\u3067\u7570\u306a\u308b\u306e\u306f\u521d\u671f\u5024 $H^{(0)}$ \u3067\u3042\u308b\u3002\n\u307e\u305f\u3001 SHA-256 \u7cfb \u3068 SHA-512 \u7cfb \u3067\u7570\u306a\u308b\u306e\u306f\u3001\u30ef\u30fc\u30c9\u9577 $w_{\\rm len}$ \u3001 \u30e9\u30a6\u30f3\u30c9\u6570 $n_{\\rm rnd}$ \u3001\u8ffd\u52a0\u5b9a\u6570 $K_t$ \u304a\u3088\u3073 $\\Sigma_0(x)$, $\\Sigma_1(x)$, $\\sigma_0(x)$, $\\sigma_1(x)$ \u306e 4 \u3064\u306e\u95a2\u6570\u3067\u3042\u308b\u3002\n\n\n$M_{\\rm in}$ \u306b\u30d1\u30c7\u30a3\u30f3\u30b0\u3092\u8ffd\u52a0\u3059\u308b\u3002\u3053\u308c\u3092 $M$ \u3068\u3059\u308b\u3002\u8a73\u7d30\u306f\u500b\u5225\u306b\u8a18\u8f09\uff08 SHA-256 \u7cfb\u306e\u5834\u5408\u3068\u3001 SHA-512 \u7cfb\u306e\u5834\u5408\uff09\u3059\u308b\u304c\u5927\u307e\u304b\u306b\u306f\u6b21\u306e\u901a\u308a\u3002\nM=\\underbrace{\\overbrace{\\underbrace{01100001}_{\\rm ``{\\bf a}\u201d}\\quad\\underbrace{01100010}_{\\rm ``{\\bf b}\u201d}\\quad\\dots\\quad\\underbrace{01100011}_{\\rm ``{\\bf c}\u201d}}^{l\\,{\\rm bits}}}_{{\\rm Massage\\,(}M_{\\rm in}{\\rm )}}\\quad\\underbrace{1\\quad\\overbrace{00\\dots0}^{k\\,{\\rm zero\\,bits}}\\quad\\overbrace{00\\dots0\\underbrace{110\\dots00}_{l}}^{2w_{\\rm len}\\,{\\rm bits}}}_{\\rm Padding}\n$${M=\\underbrace{\\overbrace{\\underbrace{01100001}_{\\rm ``{\\bf a}\u201d}\\quad\\underbrace{01100010}_{\\rm ``{\\bf b}\u201d}\\quad\\dots\\quad\\underbrace{01100011}_{\\rm ``{\\bf c}\u201d}}^{l\\,{\\rm bits}}}_{{\\rm Massage\\,(}M_{\\rm in}{\\rm )}}\\quad\\underbrace{1\\quad\\overbrace{00\\dots0}^{k\\,{\\rm zero\\,bits}}\\quad\\overbrace{00\\dots0\\underbrace{110\\dots00}_{l}}^{2w_{\\rm len}\\,{\\rm bits}}}_{\\rm Padding}\n}$$\n\n $M$ \u306e\u672b\u5c3e\u306b \"1\" \u3092\u8ffd\u52a0\u3002\n $l+1+k \\equiv 14 w_{\\rm len} \\bmod 16 w_{\\rm len}$ \u306b\u3088\u3063\u3066\u6c42\u3081\u3089\u308c\u308b $k$ \u30d3\u30c3\u30c8\u306e \"0\" \u3092\u8ffd\u52a0\u3002\n $2 w_{\\rm len}$ \u30d3\u30c3\u30c8\u3067 0 \u57cb\u3081\u3057\u305f $l$ \u3092\u8ffd\u52a0\u3002\n\n\n\u30d1\u30c7\u30a3\u30f3\u30b0\u3092\u8ffd\u52a0\u3057\u305f\u30e1\u30c3\u30bb\u30fc\u30b8\u3092\u30ef\u30fc\u30c9\u9577\u306e 16 \u500d\u3067\u5206\u5272\u3057\u305f\u30d9\u30af\u30c8\u30eb\u306b\u3059\u308b\u3002\u3053\u306e\u5206\u5272\u3057\u305f\u5358\u4f4d\u3092\u30d6\u30ed\u30c3\u30af\u3068\u547c\u3076\u3002\u5206\u5272\u3057\u3066\u5f97\u3089\u308c\u305f $N$ \u500b\u306e\u30d6\u30ed\u30c3\u30af\u3092 $M^{(1)},\\,M^{(2)},\\,\\dots,\\,M^{(N)}$ \u3068\u3059\u308b\u3002\n\n\u30d6\u30ed\u30c3\u30af $M^{(i)}\\,(1 \\leq i \\leq N)$ \u3092 1 \u304b\u3089 $N$ \u306e\u9806\u306b\u5727\u7e2e\u95a2\u6570\u3078\u4ee3\u5165\u3059\u308b\u3002\u5727\u7e2e\u95a2\u6570\u306f\u30d6\u30ed\u30c3\u30af $M^{(i)}$ \u3068\u5185\u90e8\u72b6\u614b $H^{(i-1)}$ \u306e 2 \u3064\u3092\u5f15\u6570\u3068\u3057\u3001 $H^{(i)}$ \u3092\u623b\u308a\u5024\u3068\u3059\u308b\u95a2\u6570\u3067\u3042\u308b\u3002\u307e\u305f $H^{(0)}$ \u306f\u521d\u671f\u5024\u3067\u3042\u308b\u3002\n\n$M^{(i)}$ \u3092 16 \u5206\u5272\u3057\u305f\u30d9\u30af\u30c8\u30eb\u306b\u3059\u308b\u3002\u3053\u308c\u3092 $M_{0}^{(i)}, \\, M_{1}^{(i)},\\dots,\\,M_{15}^{(i)}$ \u3068\u8868\u3059\u3002\u306a\u304a $M_{x}^{(i)}$ \u306f $w_{\\rm len}$ \u306e\u9577\u3055\u3092\u6301\u3064\u30d3\u30c3\u30c8\u5217\u3067\u3042\u308b\u3002\n\u540c\u69d8\u306b $H^{(i)}$ \u3092 16 \u5206\u5272\u3057\u305f\u30d9\u30af\u30c8\u30eb\u306b\u3059\u308b\u3002\u3053\u308c\u3092 $H_{0}^{(i)}, \\, H_{1}^{(i)},\\dots,\\,H_{15}^{(i)}$ \u3068\u8868\u3059\u3002\u540c\u3058\u304f $H_{x}^{(i)}$ \u306f $w_{\\rm len}$ \u306e\u9577\u3055\u3092\u6301\u3064\u30d3\u30c3\u30c8\u5217\u3067\u3042\u308b\u3002\n\n\u30e1\u30c3\u30bb\u30fc\u30b8\u30b9\u30b1\u30b8\u30e5\u30fc\u30eb $W_t$ \u3092\u6e96\u5099\u3059\u308b\u3002\u30e9\u30a6\u30f3\u30c9\u6570\u3092 $n_{\\rm rnd}$ \u3068\u3059\u308b\u3002\n{W_t = \\left\\{\n\\begin{array}{ll}\nM_t^{(i)} & (0 \\leq t \\leq 15)\\\\\n\\sigma_1(W_{t-2})+W_{t-7}+\\sigma_0(W_{t-15})+W_{t-16} & (16 \\leq t \\leq (n_{\\rm rnd} - 1))\n\\end{array}\n\\right.\n}\n$${{W_t = \\left\\{\n\\begin{array}{ll}\nM_t^{(i)} & (0 \\leq t \\leq 15)\\\\\n\\sigma_1(W_{t-2})+W_{t-7}+\\sigma_0(W_{t-15})+W_{t-16} & (16 \\leq t \\leq (n_{\\rm rnd} - 1))\n\\end{array}\n\\right.\n}\n}$$\n$\\sigma_0(x)$ \u3068 $\\sigma_1(x)$ \u306f\u3001 SHA-256 \u7cfb\u3068 SHA-512 \u7cfb\u3067\u7570\u306a\u308b\u3002\n\n\n$H_{0}^{(i)}, \\, H_{1}^{(i)},\\dots,\\,H_{15}^{(i)}$ \u3092 $a, \\, b,\\dots,\\,h$ \u306b\u4ee3\u5165\u3059\u308b\u3002\n\\begin{align}\na&=H_0^{(i-1)}\\\\\nb&=H_1^{(i-1)}\\\\\nc&=H_2^{(i-1)}\\\\\nd&=H_3^{(i-1)}\\\\\ne&=H_4^{(i-1)}\\\\\nf&=H_5^{(i-1)}\\\\\ng&=H_6^{(i-1)}\\\\\nh&=H_7^{(i-1)}\n\\end{align}\n$${\\begin{align}\na&=H_0^{(i-1)}\\\\\nb&=H_1^{(i-1)}\\\\\nc&=H_2^{(i-1)}\\\\\nd&=H_3^{(i-1)}\\\\\ne&=H_4^{(i-1)}\\\\\nf&=H_5^{(i-1)}\\\\\ng&=H_6^{(i-1)}\\\\\nh&=H_7^{(i-1)}\n\\end{align}\n}$$\n\n\n$t$ \u3092 0 \u304b\u3089 $n_{\\rm rnd} - 1$ \u307e\u3067\u7e70\u308a\u8fd4\u3057\u3001\u4ee5\u4e0b\u3092\u5b9f\u884c\u3059\u308b\u3002$K_t$ \u306f\u8ffd\u52a0\u5b9a\u6570\u3002 \n\\begin{align}\nT_1&=h+\\Sigma_1(e)+{\\it Ch}(e,f,g)+K_t+W_t\\\\\nT_2&=\\Sigma_0(a)+{\\it Maj}(a,b,c)\\\\\nh&=g\\\\\ng&=f\\\\\nf&=e\\\\\ne&=d+T_1\\\\\nd&=c\\\\\nc&=b\\\\\nb&=a\\\\\na&=T_1+T_2\n\\end{align}\n$${\\begin{align}\nT_1&=h+\\Sigma_1(e)+{\\it Ch}(e,f,g)+K_t+W_t\\\\\nT_2&=\\Sigma_0(a)+{\\it Maj}(a,b,c)\\\\\nh&=g\\\\\ng&=f\\\\\nf&=e\\\\\ne&=d+T_1\\\\\nd&=c\\\\\nc&=b\\\\\nb&=a\\\\\na&=T_1+T_2\n\\end{align}\n}$$\n$K_t$, $\\Sigma_1(x)$, $\\Sigma_0(x)$ \u306f\u3001 SHA-256 \u7cfb\u3068 SHA-512 \u7cfb\u3067\u7570\u306a\u308b\u3002 \n\n\n\u5727\u7e2e\u95a2\u6570\u306e\u623b\u308a\u5024\u3002\n\\begin{align}\nH_0^{(i)}&=a+H_0^{(i-1)}\\\\\nH_1^{(i)}&=b+H_1^{(i-1)}\\\\\nH_2^{(i)}&=c+H_2^{(i-1)}\\\\\nH_3^{(i)}&=d+H_3^{(i-1)}\\\\\nH_4^{(i)}&=e+H_4^{(i-1)}\\\\\nH_5^{(i)}&=f+H_5^{(i-1)}\\\\\nH_6^{(i)}&=g+H_6^{(i-1)}\\\\\nH_7^{(i)}&=h+H_7^{(i-1)}\\\\\n\\end{align}\n$${\\begin{align}\nH_0^{(i)}&=a+H_0^{(i-1)}\\\\\nH_1^{(i)}&=b+H_1^{(i-1)}\\\\\nH_2^{(i)}&=c+H_2^{(i-1)}\\\\\nH_3^{(i)}&=d+H_3^{(i-1)}\\\\\nH_4^{(i)}&=e+H_4^{(i-1)}\\\\\nH_5^{(i)}&=f+H_5^{(i-1)}\\\\\nH_6^{(i)}&=g+H_6^{(i-1)}\\\\\nH_7^{(i)}&=h+H_7^{(i-1)}\\\\\n\\end{align}\n}$$\n\n\n\n$H_x^{(i)}$ \u3092\u30cf\u30c3\u30b7\u30e5\u9577\u306e\u9577\u3055\u306b\u306a\u308b\u307e\u3067\u7d50\u5408\u3059\u308b\uff08 $H^{(i)}$ \u3092\u30cf\u30c3\u30b7\u30e5\u9577\u306e\u9577\u3055\u306b\u5207\u308a\u8a70\u3081\u308b\uff09\u3002\n\n\nSHA-256 \u3068 SHA-512 \u5171\u901a\u3067\u4f7f\u3046\u95a2\u6570\n\\begin{align}\n{\\it Ch}(x,y,z) &= (x\\wedge y)\\oplus(\\lnot x\\wedge z)\\tag{1}\\\\\n{\\it Maj}(x,y,z) &= (x\\wedge y)\\oplus(x\\wedge z)\\oplus(y\\wedge z)\\tag{2}\n\\end{align}\n$${\\begin{align}\n{\\it Ch}(x,y,z) &= (x\\wedge y)\\oplus(\\lnot x\\wedge z)\\tag{1}\\\\\n{\\it Maj}(x,y,z) &= (x\\wedge y)\\oplus(x\\wedge z)\\oplus(y\\wedge z)\\tag{2}\n\\end{align}\n}$$\n\u4e0b\u8a18\u306f\u5b9f\u88c5\u3002 SHA-256 \u3068 SHA-512 \u3067\u306f\u30e9\u30a6\u30f3\u30c9\u6570\u304c\u7570\u306a\u308b\u306e\u3067\u3001\u30de\u30af\u30ed\u3092\u4f7f\u7528\u3057\u3066\u3044\u308b\u3002\nmacro_rules! Ch {\n    ($x:expr, $y:expr, $z:expr) => { ($x & $y) ^ (!$x & $z) };\n}\nmacro_rules! Maj {\n    ($x:expr, $y:expr, $z:expr) => { ($x & $y) ^ ($x & $z) ^ ($y & $z) };\n}\n\n\nSHA-224 \u304a\u3088\u3073 SHA-256\nSHA-256 \u7cfb\u306e\u8aac\u660e\u3002\n\n\u5b9a\u6570\n\u8ffd\u52a0\u5b9a\u6570 $K^{\\{256\\}}$\n428a2f98 71374491 b5c0fbcf e9b5dba5 3956c25b 59f111f1 923f82a4 ab1c5ed5\nd807aa98 12835b01 243185be 550c7dc3 72be5d74 80deb1fe 9bdc06a7 c19bf174\ne49b69c1 efbe4786 0fc19dc6 240ca1cc 2de92c6f 4a7484aa 5cb0a9dc 76f988da\n983e5152 a831c66d b00327c8 bf597fc7 c6e00bf3 d5a79147 06ca6351 14292967\n27b70a85 2e1b2138 4d2c6dfc 53380d13 650a7354 766a0abb 81c2c92e 92722c85\na2bfe8a1 a81a664b c24b8b70 c76c51a3 d192e819 d6990624 f40e3585 106aa070\n19a4c116 1e376c08 2748774c 34b0bcb5 391c0cb3 4ed8aa4a 5b9cca4f 682e6ff3\n748f82ee 78a5636f 84c87814 8cc70208 90befffa a4506ceb bef9a3f7 c67178f2\n\nconst K256: [u32; 64] = [\n    0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5,\n    0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n    0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3,\n    0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n    0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc,\n    0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n    0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7,\n    0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n    0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13,\n    0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n    0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3,\n    0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n    0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5,\n    0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n    0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208,\n    0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2\n];\n\n\u30fbSHA-224 \u306e\u521d\u671f\u5024 $H^{(0)}$ \uff08\u5024\u306f 16 \u9032\u8868\u8a18\uff09\n\\begin{align}\nH^{(0)}_0&={\\tt c1059ed8}\\\\\nH^{(0)}_1&={\\tt 367cd507}\\\\\nH^{(0)}_2&={\\tt 3070dd17}\\\\\nH^{(0)}_3&={\\tt f70e5939}\\\\\nH^{(0)}_4&={\\tt ffc00b31}\\\\\nH^{(0)}_5&={\\tt 68581511}\\\\\nH^{(0)}_6&={\\tt 64f98fa7}\\\\\nH^{(0)}_7&={\\tt befa4fa4}\\\\\n\\end{align}\n$${\\begin{align}\nH^{(0)}_0&={\\tt c1059ed8}\\\\\nH^{(0)}_1&={\\tt 367cd507}\\\\\nH^{(0)}_2&={\\tt 3070dd17}\\\\\nH^{(0)}_3&={\\tt f70e5939}\\\\\nH^{(0)}_4&={\\tt ffc00b31}\\\\\nH^{(0)}_5&={\\tt 68581511}\\\\\nH^{(0)}_6&={\\tt 64f98fa7}\\\\\nH^{(0)}_7&={\\tt befa4fa4}\\\\\n\\end{align}\n}$$\n\u30fbSHA-256 \u306e\u521d\u671f\u5024 $H^{(0)}$ \uff08\u5024\u306f 16 \u9032\u8868\u8a18\uff09\n\\begin{align}\nH^{(0)}_0&={\\tt 6a09e667}\\\\\nH^{(0)}_1&={\\tt bb67ae85}\\\\\nH^{(0)}_2&={\\tt 3c6ef372}\\\\\nH^{(0)}_3&={\\tt a54ff53a}\\\\\nH^{(0)}_4&={\\tt 510e527f}\\\\\nH^{(0)}_5&={\\tt 9b05688c}\\\\\nH^{(0)}_6&={\\tt 1f83d9ab}\\\\\nH^{(0)}_7&={\\tt 5be0cd19}\\\\\n\\end{align}\n$${\\begin{align}\nH^{(0)}_0&={\\tt 6a09e667}\\\\\nH^{(0)}_1&={\\tt bb67ae85}\\\\\nH^{(0)}_2&={\\tt 3c6ef372}\\\\\nH^{(0)}_3&={\\tt a54ff53a}\\\\\nH^{(0)}_4&={\\tt 510e527f}\\\\\nH^{(0)}_5&={\\tt 9b05688c}\\\\\nH^{(0)}_6&={\\tt 1f83d9ab}\\\\\nH^{(0)}_7&={\\tt 5be0cd19}\\\\\n\\end{align}\n}$$\n\n\u30d1\u30c7\u30a3\u30f3\u30b0\n$M_{\\rm in}$ \u304c ASCII \u30b3\u30fc\u30c9\u306e \"abc\" \u3067\u3042\u308b\u5834\u5408\u3092\u8003\u3048\u308b\u3002\u5404\u6587\u5b57\u306f 8 bit \u306a\u306e\u3067\u3001\u30e1\u30c3\u30bb\u30fc\u30b8\u306e\u9577\u3055 $l$ \u306f 24 \u3067\u3042\u308b\u3002\nM_{\\rm in} = \\overbrace{\\underbrace{01100001}_{\\rm ``{\\bf a}\u201d}\\quad\\underbrace{01100010}_{\\rm ``{\\bf b}\u201d}\\quad\\underbrace{01100011}_{\\rm ``{\\bf c}\u201d}}^{8 + 8 + 8 = 24 = l\\,{\\rm bits}}\n$${M_{\\rm in} = \\overbrace{\\underbrace{01100001}_{\\rm ``{\\bf a}\u201d}\\quad\\underbrace{01100010}_{\\rm ``{\\bf b}\u201d}\\quad\\underbrace{01100011}_{\\rm ``{\\bf c}\u201d}}^{8 + 8 + 8 = 24 = l\\,{\\rm bits}}\n}$$\n\u30d1\u30c7\u30a3\u30f3\u30b0\u3068\u3057\u3066\u8ffd\u52a0\u3059\u308b 0 \u306e\u6570 $k$ \u306f\u3001\u6b21\u306e\u5f0f\u306b\u3088\u3063\u3066\u6c42\u3081\u3089\u308c\u308b\u3002\nl+1+k \\equiv 448 \\bmod 512\n$${l+1+k \\equiv 448 \\bmod 512\n}$$\n\u3088\u308a\n\\begin{align}\nk&=(512-64)-(l+1)\\\\\n&=448-(24+1)\\\\\n&=405\n\\end{align}\n$${\\begin{align}\nk&=(512-64)-(l+1)\\\\\n&=448-(24+1)\\\\\n&=405\n\\end{align}\n}$$\n\u4ee5\u4e0a\u304b\u3089 $M$ \u306f\u6b21\u306e\u3088\u3046\u306a\u69cb\u6210\u306b\u306a\u308b\u3002\n\\underbrace{\\overbrace{\\underbrace{01100001}_{\\rm ``{\\bf a}\u201d}\\quad\\underbrace{01100010}_{\\rm ``{\\bf b}\u201d}\\quad\\underbrace{01100011}_{\\rm ``{\\bf c}\u201d}}^{l=24\\,{\\rm bits}}}_{\\rm Massage\\,\"abc\"}\\quad\\underbrace{1\\quad\\overbrace{00\\dots00}^{k=405\\,{\\rm bits}}\\quad\\overbrace{00\\dots0\\underbrace{11000}_{l=24}}^{64\\,{\\rm bits}}}_{\\rm Padding}\n$${\\underbrace{\\overbrace{\\underbrace{01100001}_{\\rm ``{\\bf a}\u201d}\\quad\\underbrace{01100010}_{\\rm ``{\\bf b}\u201d}\\quad\\underbrace{01100011}_{\\rm ``{\\bf c}\u201d}}^{l=24\\,{\\rm bits}}}_{\\rm Massage\\,\"abc\"}\\quad\\underbrace{1\\quad\\overbrace{00\\dots00}^{k=405\\,{\\rm bits}}\\quad\\overbrace{00\\dots0\\underbrace{11000}_{l=24}}^{64\\,{\\rm bits}}}_{\\rm Padding}\n}$$\n\u4ee5\u4e0b\u306f $M_{\\rm in}$ \u306b\u30d1\u30c7\u30a3\u30f3\u30b0\u3092\u8ffd\u52a0\u3057\u3001 $M$ \u3092\u51fa\u529b\u3059\u308b\u95a2\u6570\u3067\u3042\u308b\u3002\u7b2c\u4e00\u5f15\u6570\u306b $M_{\\rm in}$ \u3092\u4ee3\u5165\u3057\u3001\u7b2c\u4e8c\u5f15\u6570\u306b\u30e1\u30c3\u30bb\u30fc\u30b8\u9577 $l$ \u3092\u4ee3\u5165\u3059\u308b\u3002\nfn add_padding(message: &Vec<u8>, length: u64) -> Vec<u8> {\n    let data_len = ((length / 512) * 64 + if (length % 512) <= 447 { 64 } else { 128 }) as usize;\n    let mut data: Vec<u8> = Vec::with_capacity(data_len);\n\n    // copy message\n    for byte in message.iter() {\n        data.push(*byte);\n    }\n\n    // add padding\n    // add 1\n    if length % 8 == 0 {\n        data.push(0x80);\n    } else {\n        let len = data.len();\n        data[len - 1] |= 1 << (7 - length % 8) as u32;\n    }\n    // add zero\n    for _ in 0..(data_len - data.len() - 8) {\n        data.push(0x00);\n    }\n    // add l (64bits)\n    for i in 0..8 {\n        data.push(((length >> (56 - i * 8) as u32) & 0xff) as u8);\n    }\n\n    data\n}\n\n\n\u5727\u7e2e\u95a2\u6570\n$\\Sigma_0(x),\\,\\Sigma_1(x),\\,\\sigma_0(x),\\,\\sigma_1(x)$ \u306e SHA-256 \u7cfb\u3067\u4f7f\u3046\u3082\u306e\u306f\u4ee5\u4e0b\u306e\u901a\u308a\u3002\u305d\u308c\u305e\u308c $\\Sigma_0^{\\{256\\}}(x),\\, \\Sigma_1^{\\{256\\}}(x),\\, \\sigma_0^{\\{256\\}}(x),\\, \\sigma_1^{\\{256\\}}(x)$ \u3068\u3057\u3066\u5b9a\u7fa9\u3059\u308b\u3002\n\\begin{align}\n\\Sigma_0^{\\{256\\}}(x)&={\\it ROTR}^{\\,2}(x) \\oplus {\\it ROTR}^{\\,13}(x)\\oplus {\\it ROTR}^{\\,22}(x)\\\\\n\\Sigma_1^{\\{256\\}}(x)&={\\it ROTR}^{\\,6}(x) \\oplus {\\it ROTR}^{\\,11}(x)\\oplus {\\it ROTR}^{\\,25}(x)\\\\\n\\sigma_0^{\\{256\\}}(x)&={\\it ROTR}^{\\,7}(x) \\oplus {\\it ROTR}^{\\,18}(x)\\oplus {\\it SHR}^{\\,3}(x)\\\\\n\\sigma_1^{\\{256\\}}(x)&={\\it ROTR}^{\\,17}(x) \\oplus {\\it ROTR}^{\\,19}(x)\\oplus {\\it SHR}^{\\,10}(x)\n\\end{align}\n$${\\begin{align}\n\\Sigma_0^{\\{256\\}}(x)&={\\it ROTR}^{\\,2}(x) \\oplus {\\it ROTR}^{\\,13}(x)\\oplus {\\it ROTR}^{\\,22}(x)\\\\\n\\Sigma_1^{\\{256\\}}(x)&={\\it ROTR}^{\\,6}(x) \\oplus {\\it ROTR}^{\\,11}(x)\\oplus {\\it ROTR}^{\\,25}(x)\\\\\n\\sigma_0^{\\{256\\}}(x)&={\\it ROTR}^{\\,7}(x) \\oplus {\\it ROTR}^{\\,18}(x)\\oplus {\\it SHR}^{\\,3}(x)\\\\\n\\sigma_1^{\\{256\\}}(x)&={\\it ROTR}^{\\,17}(x) \\oplus {\\it ROTR}^{\\,19}(x)\\oplus {\\it SHR}^{\\,10}(x)\n\\end{align}\n}$$\n\u5b9f\u88c5\u306f\u4e0b\u8a18\u3002\nfn large_sigma0_256(x: u32) -> u32 {\n    x.rotate_right( 2) ^ x.rotate_right(13) ^ x.rotate_right(22)\n}\nfn large_sigma1_256(x: u32) -> u32 {\n    x.rotate_right( 6) ^ x.rotate_right(11) ^ x.rotate_right(25)\n}\nfn sigma0_256(x: u32) -> u32 {\n    x.rotate_right( 7) ^ x.rotate_right(18) ^ (x >> 3)\n}\nfn sigma1_256(x: u32) -> u32 {\n    x.rotate_right(17) ^ x.rotate_right(19) ^ (x >> 10)\n}\n\n\u3053\u308c\u3092\u9069\u7528\u3059\u308b\u3068\u3001\u30e1\u30c3\u30bb\u30fc\u30b8\u30b9\u30b1\u30b8\u30e5\u30fc\u30eb\u306f\u6b21\u306e\u3088\u3046\u306b\u306a\u308b\u3002\n{W_t = \\left\\{\n\\begin{array}{ll}\nM_t^{(i)} & (0 \\leq t \\leq 15)\\\\\n\\sigma^{\\{256\\}}_1(W_{t-2})+W_{t-7}+\\sigma^{\\{256\\}}_0(W_{t-15})+W_{t-16} & (16 \\leq t \\leq 63)\n\\end{array}\n\\right.\n}\n$${{W_t = \\left\\{\n\\begin{array}{ll}\nM_t^{(i)} & (0 \\leq t \\leq 15)\\\\\n\\sigma^{\\{256\\}}_1(W_{t-2})+W_{t-7}+\\sigma^{\\{256\\}}_0(W_{t-15})+W_{t-16} & (16 \\leq t \\leq 63)\n\\end{array}\n\\right.\n}\n}$$\n\u5b9f\u88c5\u306f\u4e0b\u8a18\u3002\nlet w = {\n    let mut w = [0; 64];\n    for t in 0..16 {\n        w[t] = self.buffer[t];\n    }\n    for t in 16..64 {\n        w[t] = sigma1_256(w[t-2]).wrapping_add(w[t-7])\n                                 .wrapping_add(sigma0_256(w[t-15]))\n                                 .wrapping_add(w[t-16]);\n    }\n    w\n};\n\n\u5727\u7e2e\u95a2\u6570\u306e\u624b\u9806 5 \u306f\u6b21\u306e\u3088\u3046\u306b\u306a\u308b\u3002\n\\begin{align}\nT_1&=h+\\Sigma^{\\{256\\}}_1(e)+{\\it Ch}(e,f,g)+K_t^{\\{256\\}}+W_t\\\\\nT_2&=\\Sigma^{\\{256\\}}_0(a)+{\\it Maj}(a,b,c)\\\\\nh&=g\\\\\ng&=f\\\\\nf&=e\\\\\ne&=d+T_1\\\\\nd&=c\\\\\nc&=b\\\\\nb&=a\\\\\na&=T_1+T_2\n\\end{align}\n$${\\begin{align}\nT_1&=h+\\Sigma^{\\{256\\}}_1(e)+{\\it Ch}(e,f,g)+K_t^{\\{256\\}}+W_t\\\\\nT_2&=\\Sigma^{\\{256\\}}_0(a)+{\\it Maj}(a,b,c)\\\\\nh&=g\\\\\ng&=f\\\\\nf&=e\\\\\ne&=d+T_1\\\\\nd&=c\\\\\nc&=b\\\\\nb&=a\\\\\na&=T_1+T_2\n\\end{align}\n}$$\n}\n\u5b9f\u88c5\u306f\u4ee5\u4e0b\u3002\nfor t in 0..64 {\n    let t1 = h.wrapping_add(large_sigma1_256(e))\n              .wrapping_add(Ch!(e, f, g))\n              .wrapping_add(K256[t])\n              .wrapping_add(w[t]);\n    let t2 = large_sigma0_256(a).wrapping_add(Maj!(a, b, c));\n    h = g;\n    g = f;\n    f = e;\n    e = d.wrapping_add(t1);\n    d = c;\n    c = b;\n    b = a;\n    a = t1.wrapping_add(t2);\n}\n\n\u5727\u7e2e\u95a2\u6570\u306e\u624b\u9806 6 \u306f\u6b21\u306e\u3088\u3046\u306b\u306a\u308b\u3002\n\\begin{align}\nH_0^{(i)}&=a+H_0^{(i-1)}\\\\\nH_1^{(i)}&=b+H_1^{(i-1)}\\\\\nH_2^{(i)}&=c+H_2^{(i-1)}\\\\\nH_3^{(i)}&=d+H_3^{(i-1)}\\\\\nH_4^{(i)}&=e+H_4^{(i-1)}\\\\\nH_5^{(i)}&=f+H_5^{(i-1)}\\\\\nH_6^{(i)}&=g+H_6^{(i-1)}\\\\\nH_7^{(i)}&=h+H_7^{(i-1)}\\\\\n\\end{align}\n$${\\begin{align}\nH_0^{(i)}&=a+H_0^{(i-1)}\\\\\nH_1^{(i)}&=b+H_1^{(i-1)}\\\\\nH_2^{(i)}&=c+H_2^{(i-1)}\\\\\nH_3^{(i)}&=d+H_3^{(i-1)}\\\\\nH_4^{(i)}&=e+H_4^{(i-1)}\\\\\nH_5^{(i)}&=f+H_5^{(i-1)}\\\\\nH_6^{(i)}&=g+H_6^{(i-1)}\\\\\nH_7^{(i)}&=h+H_7^{(i-1)}\\\\\n\\end{align}\n}$$\nself.state = [\n    a.wrapping_add(self.state[0]),\n    b.wrapping_add(self.state[1]),\n    c.wrapping_add(self.state[2]),\n    d.wrapping_add(self.state[3]),\n    e.wrapping_add(self.state[4]),\n    f.wrapping_add(self.state[5]),\n    g.wrapping_add(self.state[6]),\n    h.wrapping_add(self.state[7])\n];\n\n\u4ee5\u4e0a\u3092\u6301\u3063\u3066\u5727\u7e2e\u95a2\u6570\u3092\u5b9f\u88c5\u3059\u308b\u3068\u6b21\u306e\u3088\u3046\u306b\u306a\u308b\u3002\nmacro_rules! Ch {\n    ($x:expr, $y:expr, $z:expr) => { ($x & $y) ^ (!$x & $z) };\n}\nmacro_rules! Maj {\n    ($x:expr, $y:expr, $z:expr) => { ($x & $y) ^ ($x & $z) ^ ($y & $z) };\n}\n\nconst K256: [u32; 64] = [\n    0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5,\n    0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n    0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3,\n    0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n    0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc,\n    0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n    0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7,\n    0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n    0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13,\n    0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n    0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3,\n    0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n    0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5,\n    0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n    0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208,\n    0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2\n];\n\nfn large_sigma0_256(x: u32) -> u32 {\n    x.rotate_right( 2) ^ x.rotate_right(13) ^ x.rotate_right(22)\n}\nfn large_sigma1_256(x: u32) -> u32 {\n    x.rotate_right( 6) ^ x.rotate_right(11) ^ x.rotate_right(25)\n}\nfn sigma0_256(x: u32) -> u32 {\n    x.rotate_right( 7) ^ x.rotate_right(18) ^ (x >> 3)\n}\nfn sigma1_256(x: u32) -> u32 {\n    x.rotate_right(17) ^ x.rotate_right(19) ^ (x >> 10)\n}\n\nfn round(state: [u32; 8], block: [u32; 16]) -> [u32; 8] {\n    let w = {\n        let mut w = [0; 64];\n        for t in 0..16 {\n            w[t] = block[t];\n        }\n        for t in 16..64 {\n            w[t] = sigma1_256(w[t-2]).wrapping_add(w[t-7])\n                                     .wrapping_add(sigma0_256(w[t-15]))\n                                     .wrapping_add(w[t-16]);\n        }\n        w\n    };\n    let (mut a, mut b, mut c, mut d, mut e, mut f, mut g, mut h) = (\n        state[0],\n        state[1],\n        state[2],\n        state[3],\n        state[4],\n        state[5],\n        state[6],\n        state[7]\n    );\n    for t in 0..64 {\n        let t1 = h.wrapping_add(large_sigma1_256(e))\n                  .wrapping_add(Ch!(e, f, g))\n                  .wrapping_add(K256[t])\n                  .wrapping_add(w[t]);\n        let t2 = large_sigma0_256(a).wrapping_add(Maj!(a, b, c));\n        h = g;\n        g = f;\n        f = e;\n        e = d.wrapping_add(t1);\n        d = c;\n        c = b;\n        b = a;\n        a = t1.wrapping_add(t2);\n    }\n    [\n        a.wrapping_add(state[0]),\n        b.wrapping_add(state[1]),\n        c.wrapping_add(state[2]),\n        d.wrapping_add(state[3]),\n        e.wrapping_add(state[4]),\n        f.wrapping_add(state[5]),\n        g.wrapping_add(state[6]),\n        h.wrapping_add(state[7])\n    ]\n}\n\nenum Sha256BitLength {\n    Len224 = 224,\n    Len256 = 256,\n}\n\n\n\u30cf\u30c3\u30b7\u30e5\u4f5c\u6210\n\u30cf\u30c3\u30b7\u30e5\u306f\u6b21\u306e\u3088\u3046\u306b\u7d50\u5408\u3055\u308c\u308b\u3002 $\\parallel$ \u306f\u7d50\u5408\u3092\u8868\u3059\u3002\u4f8b\u3048\u3070\u3001 $A=010,\\,B=001$ \u3068\u3057\u305f\u3068\u304d\u3001 $A\\parallel B=010001$ \u3068\u306a\u308b\u3002\nSHA-256\nH_0^{(N)}\\parallel H_1^{(N)}\\parallel H_2^{(N)}\\parallel H_3^{(N)}\\parallel H_4^{(N)}\\parallel H_5^{(N)}\\parallel H_6^{(N)}\\parallel H_7^{(N)}\n$${H_0^{(N)}\\parallel H_1^{(N)}\\parallel H_2^{(N)}\\parallel H_3^{(N)}\\parallel H_4^{(N)}\\parallel H_5^{(N)}\\parallel H_6^{(N)}\\parallel H_7^{(N)}\n}$$\nSHA-224\nH_0^{(N)}\\parallel H_1^{(N)}\\parallel H_2^{(N)}\\parallel H_3^{(N)}\\parallel H_4^{(N)}\\parallel H_5^{(N)}\\parallel H_6^{(N)}\n$${H_0^{(N)}\\parallel H_1^{(N)}\\parallel H_2^{(N)}\\parallel H_3^{(N)}\\parallel H_4^{(N)}\\parallel H_5^{(N)}\\parallel H_6^{(N)}\n}$$\n\u4ee5\u4e0a\u3092\u898b\u3066\u308f\u304b\u308b\u901a\u308a\u3001 SHA-224 \u306f SHA-256 \u306e\u5148\u982d 224 bit \u3092\u5207\u308a\u53d6\u3063\u305f\u3082\u306e\u3067\u3042\u308b\u3002\u305f\u3060\u3057\u3001\u521d\u671f\u5024\u304c\u7570\u306a\u308b\u305f\u3081\u3001\u540c\u4e00\u30e1\u30c3\u30bb\u30fc\u30b8\u3067\u3042\u3063\u3066\u3082\u5024\u306f\u7570\u306a\u308b\u3002\n$H^{(N)}$ \u3092 state: [u32; 8] \u3001\u30cf\u30c3\u30b7\u30e5\u9577\u3092 hash_length: usize \u3068\u3057\u3066\u3001 Vec<u8> \u578b\u3067\u30cf\u30c3\u30b7\u30e5\u3092\u8868\u3059\u3068\u3059\u308b\u3068\u3001\u30b3\u30fc\u30c9\u306f\u6b21\u306e\u3088\u3046\u306b\u306a\u308b\u3002\nfn (state: [u32; 8], hash_length: usize) -> Vec<u8> {\n    let mut hash: Vec<u8> = Vec::with_capacity(hash_length);\n    let mut length = 0;\n    'outer: for h in state.iter() {\n        use std::mem::transmute;\n\n        let from = if cfg!(target_endian = \"big\") {\n            *h\n        } else {\n            (*h).swap_bytes()\n        };\n        for byte in unsafe { transmute::<u32, [u8; 4]>(from) }.iter() {\n            hash.push(*byte);\n            length += 8;\n            if length == hash_length as usize {\n                break 'outer;\n            }\n        }\n    }\n\n    hash\n}\n\n\n\u30bd\u30fc\u30b9\u30b3\u30fc\u30c9\n\nsha256.rs\nmacro_rules! Ch {\n    ($x:expr, $y:expr, $z:expr) => { ($x & $y) ^ (!$x & $z) };\n}\nmacro_rules! Maj {\n    ($x:expr, $y:expr, $z:expr) => { ($x & $y) ^ ($x & $z) ^ ($y & $z) };\n}\n\n/// \u8ffd\u52a0\u5b9a\u6570\nconst K256: [u32; 64] = [\n    0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5,\n    0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n    0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3,\n    0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n    0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc,\n    0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n    0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7,\n    0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n    0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13,\n    0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n    0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3,\n    0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n    0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5,\n    0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n    0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208,\n    0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2\n];\n\nfn large_sigma0_256(x: u32) -> u32 {\n    x.rotate_right( 2) ^ x.rotate_right(13) ^ x.rotate_right(22)\n}\nfn large_sigma1_256(x: u32) -> u32 {\n    x.rotate_right( 6) ^ x.rotate_right(11) ^ x.rotate_right(25)\n}\nfn sigma0_256(x: u32) -> u32 {\n    x.rotate_right( 7) ^ x.rotate_right(18) ^ (x >> 3)\n}\nfn sigma1_256(x: u32) -> u32 {\n    x.rotate_right(17) ^ x.rotate_right(19) ^ (x >> 10)\n}\n\n/// \u5727\u7e2e\u95a2\u6570\nfn round(state: [u32; 8], block: [u32; 16]) -> [u32; 8] {\n    let w = {\n        let mut w = [0; 64];\n        for t in 0..16 {\n            w[t] = block[t];\n        }\n        for t in 16..64 {\n            w[t] = sigma1_256(w[t-2]).wrapping_add(w[t-7])\n                                     .wrapping_add(sigma0_256(w[t-15]))\n                                     .wrapping_add(w[t-16]);\n        }\n        w\n    };\n    let (mut a, mut b, mut c, mut d, mut e, mut f, mut g, mut h) = (\n        state[0],\n        state[1],\n        state[2],\n        state[3],\n        state[4],\n        state[5],\n        state[6],\n        state[7]\n    );\n    for t in 0..64 {\n        let t1 = h.wrapping_add(large_sigma1_256(e))\n                  .wrapping_add(Ch!(e, f, g))\n                  .wrapping_add(K256[t])\n                  .wrapping_add(w[t]);\n        let t2 = large_sigma0_256(a).wrapping_add(Maj!(a, b, c));\n        h = g;\n        g = f;\n        f = e;\n        e = d.wrapping_add(t1);\n        d = c;\n        c = b;\n        b = a;\n        a = t1.wrapping_add(t2);\n    }\n    [\n        a.wrapping_add(state[0]),\n        b.wrapping_add(state[1]),\n        c.wrapping_add(state[2]),\n        d.wrapping_add(state[3]),\n        e.wrapping_add(state[4]),\n        f.wrapping_add(state[5]),\n        g.wrapping_add(state[6]),\n        h.wrapping_add(state[7])\n    ]\n}\n\n/// \u30d1\u30c7\u30a3\u30f3\u30b0\u3092\u52a0\u3048\u305f\u30c7\u30fc\u30bf\u3092\u30d6\u30ed\u30c3\u30af\u306b\u5206\u5272\u3059\u308b\u3002\nfn separate_data(data: Vec<u8>) -> Vec<[u32; 16]> {\n    let mut blocks = Vec::with_capacity(data.len() / 512);\n    let mut idx = 0;\n    let mut shift = 32;\n    let mut block = [0; 16];\n    for byte in data.iter() {\n        shift -= 8;\n        block[idx] |= (*byte as u32) << shift;\n        if shift == 0 {\n            idx += 1;\n            shift = 32;\n        }\n        if idx == 16 {\n            blocks.push(block);\n            block = [0; 16];\n            idx = 0;\n        }\n    }\n    blocks\n}\n\n/// \u30e1\u30c3\u30bb\u30fc\u30b8\u306b\u30d1\u30c7\u30a3\u30f3\u30b0\u3092\u8ffd\u52a0\u3059\u308b\u3002\nfn add_padding(message: &Vec<u8>, length: u64) -> Vec<u8> {\n    let data_len = ((length / 512) * 64 + if (length % 512) <= 447 { 64 } else { 128 }) as usize;\n    let mut data: Vec<u8> = Vec::with_capacity(data_len);\n\n    // copy message\n    for byte in message.iter() {\n        data.push(*byte);\n    }\n\n    // add padding\n    if length % 8 == 0 {\n        data.push(0x80);\n    } else {\n        let len = data.len();\n        data[len - 1] |= 1 << (7 - length % 8) as u32;\n    }\n    for _ in 0..(data_len - data.len() - 8) {\n        data.push(0x00);\n    }\n    for i in 0..8 {\n        data.push(((length >> (56 - i * 8) as u32) & 0xff) as u8);\n    }\n\n    data\n}\n\n/// \u30cf\u30c3\u30b7\u30e5\u9577\npub enum Sha256DigestSize {\n    Len224 = 224,\n    Len256 = 256,\n}\n\n/// \u30cf\u30c3\u30b7\u30e5\u306e\u53d6\u5f97\u3002message \u306b\u30e1\u30c3\u30bb\u30fc\u30b8\u3092\u4ee3\u5165\u3057\u3001 message_length \u306b\u30e1\u30c3\u30bb\u30fc\u30b8\u9577\u3092\u4ee3\u5165\u3059\u308b\u3002\npub fn create_hash(message: &Vec<u8>, message_length: u64, digest_size: Sha256DigestSize) -> Box<[u8]> {\n    // \u30d1\u30c7\u30a3\u30f3\u30b0\u306e\u8ffd\u52a0\n    let data = add_padding(message, message_length);\n    // \u30c7\u30fc\u30bf\u3092\u30d6\u30ed\u30c3\u30af\u306b\u5206\u5272\n    let blocks = separate_data(data);\n    // \u521d\u671f\u5024\n    let mut state = match digest_size {\n        Sha256DigestSize::Len224 => [\n            0xc1059ed8,\n            0x367cd507,\n            0x3070dd17,\n            0xf70e5939,\n            0xffc00b31,\n            0x68581511,\n            0x64f98fa7,\n            0xbefa4fa4\n        ],\n        Sha256DigestSize::Len256 => [\n            0x6a09e667,\n            0xbb67ae85,\n            0x3c6ef372,\n            0xa54ff53a,\n            0x510e527f,\n            0x9b05688c,\n            0x1f83d9ab,\n            0x5be0cd19\n        ],\n    };\n    // \u30d6\u30ed\u30c3\u30af\u3092\u5727\u7e2e\u95a2\u6570\u306b\u4ee3\u5165\n    for block in blocks.iter() {\n        state = round(state, *block);\n    }\n    // \u30cf\u30c3\u30b7\u30e5\u306e\u4f5c\u6210\n    let hash_length = digest_size as usize;\n    let mut hash: Vec<u8> = Vec::with_capacity(hash_length);\n    let mut length = 0;\n    'outer: for h in state.iter() {\n        use std::mem::transmute;\n\n        let from = if cfg!(target_endian = \"big\") {\n            *h\n        } else {\n            (*h).swap_bytes()\n        };\n        for byte in unsafe { transmute::<u32, [u8; 4]>(from) }.iter() {\n            hash.push(*byte);\n            length += 8;\n            if length == hash_length as usize {\n                break 'outer;\n            }\n        }\n    }\n\n    // \u623b\u308a\u5024\n    hash.into_boxed_slice()\n}\n\n\n\u3053\u306e\u30d7\u30ed\u30b0\u30e9\u30e0\u306f\u3001\u6b21\u306e\u624b\u9806\u306b\u3088\u3063\u3066\u30cf\u30c3\u30b7\u30e5 ( Box<[u8]> \u578b ) \u3092\u53d6\u5f97\u3059\u308b\u3002\n\n\nMessage::new \u306e\u7b2c1\u5f15\u6570\u306b\u30e1\u30c3\u30bb\u30fc\u30b8 ( &[u8] \u578b ) \u3001\u7b2c2\u5f15\u6570\u306b\u30e1\u30c3\u30bb\u30fc\u30b8\u9577 ( u64 \u578b ) \u3092\u4ee3\u5165\n\ncreate_hash \u95a2\u6570\u306e\u7b2c1\u5f15\u6570\u306b\u624b\u9806 1 \u3067\u4f5c\u6210\u3057\u305f Message \u69cb\u9020\u4f53\u3001\u7b2c3\u5f15\u6570\u306b\u30cf\u30c3\u30b7\u30e5\u9577 ( Sha256DigestSize \u578b ) \u3092\u4ee3\u5165\n\ncreate_hash \u95a2\u6570\u306e\u623b\u308a\u5024\u304c\u30cf\u30c3\u30b7\u30e5\n\n\u6b21\u306e\u30b3\u30fc\u30c9\u306f\u3001\u7a7a\u306e\u30e1\u30c3\u30bb\u30fc\u30b8\u304b\u3089 SHA-256 \u3092\u53d6\u5f97\u3059\u308b\u4f8b\u3067\u3042\u308b\u3002\nlet msg = Message::new(&vec![], 0);\nlet hash = create_hash(msg, Sha256DigestSize::Len256);\n\n\n\u30c6\u30b9\u30c8\n\u30e1\u30c3\u30bb\u30fc\u30b8\u304c\u7a7a \"\" \u306e\u5834\u5408\u306e\u30cf\u30c3\u30b7\u30e5\n\n\n\n\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0\n\u30cf\u30c3\u30b7\u30e5\n\n\n\n\nSHA-224\nd14a028c 2a3a2bc9 476102bb 288234c4 15a2b01f 828ea62a c5b3e42f\n\n\nSHA-256\ne3b0c442 98fc1c14 9afbf4c8 996fb924 27ae41e4 649b934c a495991b 7852b855\n\n\n\n\nsha256_empty_message_tests\n/// \u7a7a\u306e\u30e1\u30c3\u30bb\u30fc\u30b8 \"\" \u306b\u5bfe\u3057 SHA-224 \u3092\u53d6\u308b\n#[test]\nfn sha2_224_hash_by_empty_msg() {\n    let msg = Message::new(&vec![], 0);\n    let hash = create_hash(msg, Sha256DigestSize::Len224);\n    assert_eq!(hash, vec![\n        0xd1, 0x4a, 0x02, 0x8c, 0x2a, 0x3a, 0x2b, 0xc9,\n        0x47, 0x61, 0x02, 0xbb, 0x28, 0x82, 0x34, 0xc4,\n        0x15, 0xa2, 0xb0, 0x1f, 0x82, 0x8e, 0xa6, 0x2a,\n        0xc5, 0xb3, 0xe4, 0x2f\n    ].into_boxed_slice());\n}\n/// \u7a7a\u306e\u30e1\u30c3\u30bb\u30fc\u30b8 \"\" \u306b\u5bfe\u3057 SHA-256 \u3092\u53d6\u308b\n#[test]\nfn sha2_256_hash_by_empty_msg() {\n    let msg = Message::new(&vec![], 0);\n    let hash = create_hash(msg, Sha256DigestSize::Len256);\n    assert_eq!(hash, vec![\n        0xe3, 0xb0, 0xc4, 0x42, 0x98, 0xfc, 0x1c, 0x14,\n        0x9a, 0xfb, 0xf4, 0xc8, 0x99, 0x6f, 0xb9, 0x24,\n        0x27, 0xae, 0x41, 0xe4, 0x64, 0x9b, 0x93, 0x4c,\n        0xa4, 0x95, 0x99, 0x1b, 0x78, 0x52, 0xb8, 0x55\n    ].into_boxed_slice());\n}\n\n\n\u30e1\u30c3\u30bb\u30fc\u30b8\u304c \"abc\" \u306e\u30cf\u30c3\u30b7\u30e5\n\n\n\n\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0\n\u30cf\u30c3\u30b7\u30e5\n\n\n\n\nSHA-224\n23097d22 3405d822 8642a477 bda255b3 2aadbce4 bda0b3f7 e36c9da7\n\n\nSHA-256\nba7816bf 8f01cfea 414140de 5dae2223 b00361a3 96177a9c b410ff61 f20015ad\n\n\n\n\nsha256_abc_message_tests\n/// \u30e1\u30c3\u30bb\u30fc\u30b8 \"abc\" \u306b\u5bfe\u3057 SHA-224 \u3092\u53d6\u308b\n#[test]\nfn sha2_224_hash_by_abc_msg() {\n    let msg = Message::new(b\"abc\".as_ref(), 24);\n    let hash = create_hash(msg, Sha256DigestSize::Len224);\n    assert_eq!(hash, vec![\n        0x23, 0x09, 0x7d, 0x22, 0x34, 0x05, 0xd8, 0x22,\n        0x86, 0x42, 0xa4, 0x77, 0xbd, 0xa2, 0x55, 0xb3,\n        0x2a, 0xad, 0xbc, 0xe4, 0xbd, 0xa0, 0xb3, 0xf7,\n        0xe3, 0x6c, 0x9d, 0xa7\n    ].into_boxed_slice());\n}\n/// \u30e1\u30c3\u30bb\u30fc\u30b8 \"abc\" \u306b\u5bfe\u3057 SHA-256 \u3092\u53d6\u308b\n#[test]\nfn sha2_256_hash_by_abc_msg() {\n    let msg = Message::new(b\"abc\".as_ref(), 24);\n    let hash = create_hash(msg, Sha256DigestSize::Len256);\n    assert_eq!(hash, vec![\n        0xba, 0x78, 0x16, 0xbf, 0x8f, 0x01, 0xcf, 0xea,\n        0x41, 0x41, 0x40, 0xde, 0x5d, 0xae, 0x22, 0x23,\n        0xb0, 0x03, 0x61, 0xa3, 0x96, 0x17, 0x7a, 0x9c,\n        0xb4, 0x10, 0xff, 0x61, 0xf2, 0x00, 0x15, 0xad\n    ].into_boxed_slice());\n}\n\n\n\u30e1\u30c3\u30bb\u30fc\u30b8\u304c x \u30d3\u30c3\u30c8\u306e 0 \u3067\u3042\u308b SHA-256 \u30cf\u30c3\u30b7\u30e5\n\n\n\n\u30d3\u30c3\u30c8\u6570\n\u30cf\u30c3\u30b7\u30e5\n\n\n\n\n447\n43fdd2ee d4df6d2c 38e971da 88411505 1951aa68 d892720f 79689d49 62c9efae\n\n\n448\nd4817aa5 497628e7 c77e6b60 6107042b bba31308 88c5f47a 375e6179 be789fbb\n\n\n\n\nsha256_x_zero_bits_tests\n/// 447 bits \u306e 0 \u3067\u69cb\u6210\u3055\u308c\u305f\u30e1\u30c3\u30bb\u30fc\u30b8\u306b\u5bfe\u3057 SHA-256 \u3092\u53d6\u308b\n#[test]\nfn sha2_256_hash_by_447_zero_bits() {\n    let msg = Message::new(&vec![\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    ], 447);\n    let hash = create_hash(msg, Sha256DigestSize::Len256);\n    assert_eq!(hash, vec![\n        0x43, 0xfd, 0xd2, 0xee, 0xd4, 0xdf, 0x6d, 0x2c,\n        0x38, 0xe9, 0x71, 0xda, 0x88, 0x41, 0x15, 0x05,\n        0x19, 0x51, 0xaa, 0x68, 0xd8, 0x92, 0x72, 0x0f,\n        0x79, 0x68, 0x9d, 0x49, 0x62, 0xc9, 0xef, 0xae\n    ].into_boxed_slice());\n}\n/// 448 bits \u306e 0 \u3067\u69cb\u6210\u3055\u308c\u305f\u30e1\u30c3\u30bb\u30fc\u30b8\u306b\u5bfe\u3057 SHA-256 \u3092\u53d6\u308b\n#[test]\nfn sha2_256_hash_by_448_zero_bits() {\n    let msg = Message::new(&vec![\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    ], 448);\n    let hash = create_hash(msg, Sha256DigestSize::Len256);\n    assert_eq!(hash, vec![\n        0xd4, 0x81, 0x7a, 0xa5, 0x49, 0x76, 0x28, 0xe7,\n        0xc7, 0x7e, 0x6b, 0x60, 0x61, 0x07, 0x04, 0x2b,\n        0xbb, 0xa3, 0x13, 0x08, 0x88, 0xc5, 0xf4, 0x7a,\n        0x37, 0x5e, 0x61, 0x79, 0xbe, 0x78, 0x9f, 0xbb\n    ].into_boxed_slice());\n}\n\n\n\nSHA-384 \u304a\u3088\u3073 SHA-512\uff0cSHA-512/224\uff0cSHA-512/256\nSHA-512 \u7cfb\u306f SHA-256 \u7cfb\u3068\u5168\u4f53\u306e\u69cb\u9020\u304c\u540c\u3058\u306a\u306e\u3067\u3001\u76f8\u9055\u70b9\u306e\u307f\u3092\u8ff0\u3079\u308b\u3002\n\n\u5b9a\u6570\n\u30fb\u8ffd\u52a0\u5b9a\u6570 $K^{\\{512\\}}$\n428a2f98d728ae22 7137449123ef65cd b5c0fbcfec4d3b2f e9b5dba58189dbbc\n3956c25bf348b538 59f111f1b605d019 923f82a4af194f9b ab1c5ed5da6d8118\nd807aa98a3030242 12835b0145706fbe 243185be4ee4b28c 550c7dc3d5ffb4e2\n72be5d74f27b896f 80deb1fe3b1696b1 9bdc06a725c71235 c19bf174cf692694\ne49b69c19ef14ad2 efbe4786384f25e3 0fc19dc68b8cd5b5 240ca1cc77ac9c65\n2de92c6f592b0275 4a7484aa6ea6e483 5cb0a9dcbd41fbd4 76f988da831153b5\n983e5152ee66dfab a831c66d2db43210 b00327c898fb213f bf597fc7beef0ee4\nc6e00bf33da88fc2 d5a79147930aa725 06ca6351e003826f 142929670a0e6e70\n27b70a8546d22ffc 2e1b21385c26c926 4d2c6dfc5ac42aed 53380d139d95b3df\n650a73548baf63de 766a0abb3c77b2a8 81c2c92e47edaee6 92722c851482353b\na2bfe8a14cf10364 a81a664bbc423001 c24b8b70d0f89791 c76c51a30654be30\nd192e819d6ef5218 d69906245565a910 f40e35855771202a 106aa07032bbd1b8\n19a4c116b8d2d0c8 1e376c085141ab53 2748774cdf8eeb99 34b0bcb5e19b48a8\n391c0cb3c5c95a63 4ed8aa4ae3418acb 5b9cca4f7763e373 682e6ff3d6b2b8a3\n748f82ee5defb2fc 78a5636f43172f60 84c87814a1f0ab72 8cc702081a6439ec\n90befffa23631e28 a4506cebde82bde9 bef9a3f7b2c67915 c67178f2e372532b\nca273eceea26619c d186b8c721c0c207 eada7dd6cde0eb1e f57d4f7fee6ed178\n06f067aa72176fba 0a637dc5a2c898a6 113f9804bef90dae 1b710b35131c471b\n28db77f523047d84 32caab7b40c72493 3c9ebe0a15c9bebc 431d67c49c100d4c\n4cc5d4becb3e42b6 597f299cfc657e2a 5fcb6fab3ad6faec 6c44198c4a475817\n\n\\begin{align}\n\\Sigma^{\\{512\\}}_0(x)&={\\it ROTR}^{\\,28}(x)\\oplus {\\it ROTR}^{\\,34}(x)\\oplus {\\it ROTR}^{\\,39}(x)\\\\\n\\Sigma^{\\{512\\}}_1(x)&={\\it ROTR}^{\\,14}(x)\\oplus {\\it ROTR}^{\\,18}(x)\\oplus {\\it ROTR}^{\\,41}(x)\\\\\n\\sigma^{\\{512\\}}_0(x)&={\\it ROTR}^{\\,1}(x)\\oplus {\\it ROTR}^{\\,8}(x)\\oplus {\\it SHR}^{\\,7}(x)\\\\\n\\sigma^{\\{512\\}}_1(x)&={\\it ROTR}^{\\,19}(x)\\oplus {\\it ROTR}^{\\,61}(x)\\oplus {\\it SHR}^{\\,6}(x)\n\\end{align}\n$${\\begin{align}\n\\Sigma^{\\{512\\}}_0(x)&={\\it ROTR}^{\\,28}(x)\\oplus {\\it ROTR}^{\\,34}(x)\\oplus {\\it ROTR}^{\\,39}(x)\\\\\n\\Sigma^{\\{512\\}}_1(x)&={\\it ROTR}^{\\,14}(x)\\oplus {\\it ROTR}^{\\,18}(x)\\oplus {\\it ROTR}^{\\,41}(x)\\\\\n\\sigma^{\\{512\\}}_0(x)&={\\it ROTR}^{\\,1}(x)\\oplus {\\it ROTR}^{\\,8}(x)\\oplus {\\it SHR}^{\\,7}(x)\\\\\n\\sigma^{\\{512\\}}_1(x)&={\\it ROTR}^{\\,19}(x)\\oplus {\\it ROTR}^{\\,61}(x)\\oplus {\\it SHR}^{\\,6}(x)\n\\end{align}\n}$$\n\u30fbSHA-384 \u306e\u521d\u671f\u5024 $H^{(0)}$\n\\begin{align}\nH^{(0)}_0&={\\tt cbbb9d5dc1059ed8}\\\\\nH^{(0)}_1&={\\tt 629a292a367cd507}\\\\\nH^{(0)}_2&={\\tt 9159015a3070dd17}\\\\\nH^{(0)}_3&={\\tt 152fecd8f70e5939}\\\\\nH^{(0)}_4&={\\tt 67332667ffc00b31}\\\\\nH^{(0)}_5&={\\tt 8eb44a8768581511}\\\\\nH^{(0)}_6&={\\tt db0c2e0d64f98fa7}\\\\\nH^{(0)}_7&={\\tt 47b5481dbefa4fa4}\\\\\n\\end{align}\n$${\\begin{align}\nH^{(0)}_0&={\\tt cbbb9d5dc1059ed8}\\\\\nH^{(0)}_1&={\\tt 629a292a367cd507}\\\\\nH^{(0)}_2&={\\tt 9159015a3070dd17}\\\\\nH^{(0)}_3&={\\tt 152fecd8f70e5939}\\\\\nH^{(0)}_4&={\\tt 67332667ffc00b31}\\\\\nH^{(0)}_5&={\\tt 8eb44a8768581511}\\\\\nH^{(0)}_6&={\\tt db0c2e0d64f98fa7}\\\\\nH^{(0)}_7&={\\tt 47b5481dbefa4fa4}\\\\\n\\end{align}\n}$$\n\u30fbSHA-512 \u306e\u521d\u671f\u5024 $H^{(0)}$\n\\begin{align}\nH^{(0)}_0&={\\tt 6a09e667f3bcc908}\\\\\nH^{(0)}_1&={\\tt bb67ae8584caa73b}\\\\\nH^{(0)}_2&={\\tt 3c6ef372fe94f82b}\\\\\nH^{(0)}_3&={\\tt a54ff53a5f1d36f1}\\\\\nH^{(0)}_4&={\\tt 510e527fade682d1}\\\\\nH^{(0)}_5&={\\tt 9b05688c2b3e6c1f}\\\\\nH^{(0)}_6&={\\tt 1f83d9abfb41bd6b}\\\\\nH^{(0)}_7&={\\tt 5be0cd19137e2179}\\\\\n\\end{align}\n$${\\begin{align}\nH^{(0)}_0&={\\tt 6a09e667f3bcc908}\\\\\nH^{(0)}_1&={\\tt bb67ae8584caa73b}\\\\\nH^{(0)}_2&={\\tt 3c6ef372fe94f82b}\\\\\nH^{(0)}_3&={\\tt a54ff53a5f1d36f1}\\\\\nH^{(0)}_4&={\\tt 510e527fade682d1}\\\\\nH^{(0)}_5&={\\tt 9b05688c2b3e6c1f}\\\\\nH^{(0)}_6&={\\tt 1f83d9abfb41bd6b}\\\\\nH^{(0)}_7&={\\tt 5be0cd19137e2179}\\\\\n\\end{align}\n}$$\n\u30fbSHA-512/224 \u306e\u521d\u671f\u5024 $H^{(0)}$\n\\begin{align}\nH^{(0)}_0&={\\tt 8C3D37C819544DA2}\\\\\nH^{(0)}_1&={\\tt 73E1996689DCD4D6}\\\\\nH^{(0)}_2&={\\tt 1DFAB7AE32FF9C82}\\\\\nH^{(0)}_3&={\\tt 679DD514582F9FCF}\\\\\nH^{(0)}_4&={\\tt 0F6D2B697BD44DA8}\\\\\nH^{(0)}_5&={\\tt 77E36F7304C48942}\\\\\nH^{(0)}_6&={\\tt 3F9D85A86A1D36C8}\\\\\nH^{(0)}_7&={\\tt 1112E6AD91D692A1}\\\\\n\\end{align}\n$${\\begin{align}\nH^{(0)}_0&={\\tt 8C3D37C819544DA2}\\\\\nH^{(0)}_1&={\\tt 73E1996689DCD4D6}\\\\\nH^{(0)}_2&={\\tt 1DFAB7AE32FF9C82}\\\\\nH^{(0)}_3&={\\tt 679DD514582F9FCF}\\\\\nH^{(0)}_4&={\\tt 0F6D2B697BD44DA8}\\\\\nH^{(0)}_5&={\\tt 77E36F7304C48942}\\\\\nH^{(0)}_6&={\\tt 3F9D85A86A1D36C8}\\\\\nH^{(0)}_7&={\\tt 1112E6AD91D692A1}\\\\\n\\end{align}\n}$$\n\u30fbSHA-512/256 \u306e\u521d\u671f\u5024 $H^{(0)}$\n\\begin{align}\nH^{(0)}_0&={\\tt 22312194FC2BF72C}\\\\\nH^{(0)}_1&={\\tt 9F555FA3C84C64C2}\\\\\nH^{(0)}_2&={\\tt 2393B86B6F53B151}\\\\\nH^{(0)}_3&={\\tt 963877195940EABD}\\\\\nH^{(0)}_4&={\\tt 96283EE2A88EFFE3}\\\\\nH^{(0)}_5&={\\tt BE5E1E2553863992}\\\\\nH^{(0)}_6&={\\tt 2B0199FC2C85B8AA}\\\\\nH^{(0)}_7&={\\tt 0EB72DDC81C52CA2}\\\\\n\\end{align}\n$${\\begin{align}\nH^{(0)}_0&={\\tt 22312194FC2BF72C}\\\\\nH^{(0)}_1&={\\tt 9F555FA3C84C64C2}\\\\\nH^{(0)}_2&={\\tt 2393B86B6F53B151}\\\\\nH^{(0)}_3&={\\tt 963877195940EABD}\\\\\nH^{(0)}_4&={\\tt 96283EE2A88EFFE3}\\\\\nH^{(0)}_5&={\\tt BE5E1E2553863992}\\\\\nH^{(0)}_6&={\\tt 2B0199FC2C85B8AA}\\\\\nH^{(0)}_7&={\\tt 0EB72DDC81C52CA2}\\\\\n\\end{align}\n}$$\n\n\u30d1\u30c7\u30a3\u30f3\u30b0\nSHA-256 \u7cfb\u3068\u540c\u69d8\u306b\u3001 $M_{\\rm in}={\\rm ``abc\"}=01100001\\,01100010\\,01100011$ \u3068\u3057\u305f\u3068\u304d\u3001\u30d1\u30c7\u30a3\u30f3\u30b0\u3068\u3057\u3066\u8ffd\u52a0\u3059\u308b 0 \u306e\u6570 $k$ \u306f\u3001\u6b21\u306e\u5f0f\u306b\u3088\u3063\u3066\u6c42\u3081\u3089\u308c\u308b\u3002\nl+1+k \\equiv 896 \\bmod 1024\n$${l+1+k \\equiv 896 \\bmod 1024\n}$$\n\u3088\u308a\n\\begin{align}\nk&=(1024-128)-(l+1)\\\\\n&=896-(24+1)\\\\\n&=871\n\\end{align}\n$${\\begin{align}\nk&=(1024-128)-(l+1)\\\\\n&=896-(24+1)\\\\\n&=871\n\\end{align}\n}$$\n\u3057\u305f\u304c\u3063\u3066\u3001 $M$ \u306e\u69cb\u6210\u306f\u4ee5\u4e0b\u306e\u3088\u3046\u306b\u306a\u308b\u3002\n\\underbrace{\\underbrace{01100001}_{\\rm ``{\\bf a}\u201d}\\quad\\underbrace{01100010}_{\\rm ``{\\bf b}\u201d}\\quad\\underbrace{01100011}_{\\rm ``{\\bf c}\u201d}}_{\\rm Massage}\\quad\\underbrace{1\\quad\\overbrace{00\\dots00}^{k=871}\\quad\\overbrace{00\\dots0\\underbrace{11000}_{l=24}}^{128}}_{\\rm Padding}\n$${\\underbrace{\\underbrace{01100001}_{\\rm ``{\\bf a}\u201d}\\quad\\underbrace{01100010}_{\\rm ``{\\bf b}\u201d}\\quad\\underbrace{01100011}_{\\rm ``{\\bf c}\u201d}}_{\\rm Massage}\\quad\\underbrace{1\\quad\\overbrace{00\\dots00}^{k=871}\\quad\\overbrace{00\\dots0\\underbrace{11000}_{l=24}}^{128}}_{\\rm Padding}\n}$$\n\n\u30cf\u30c3\u30b7\u30e5\u4f5c\u6210\nSHA-512\nH_0^{(N)}\\parallel H_1^{(N)}\\parallel H_2^{(N)}\\parallel H_3^{(N)}\\parallel H_4^{(N)}\\parallel H_5^{(N)}\\parallel H_6^{(N)}\\parallel H_7^{(N)}\n$${H_0^{(N)}\\parallel H_1^{(N)}\\parallel H_2^{(N)}\\parallel H_3^{(N)}\\parallel H_4^{(N)}\\parallel H_5^{(N)}\\parallel H_6^{(N)}\\parallel H_7^{(N)}\n}$$\nSHA-384\nH_0^{(N)}\\parallel H_1^{(N)}\\parallel H_2^{(N)}\\parallel H_3^{(N)}\\parallel H_4^{(N)}\\parallel H_5^{(N)}\n$${H_0^{(N)}\\parallel H_1^{(N)}\\parallel H_2^{(N)}\\parallel H_3^{(N)}\\parallel H_4^{(N)}\\parallel H_5^{(N)}\n}$$\n\u4ee5\u4e0a\u3092\u898b\u3066\u308f\u304b\u308b\u901a\u308a\u3001 SHA-256 \u7cfb\u3068\u540c\u3058\u304f\u3001 SHA-384 \u306f SHA-512 \u306e\u5148\u982d 384 bit \u3092\u5207\u308a\u53d6\u3063\u305f\u3082\u306e\u3067\u3042\u308b\u304c\u3001\u521d\u671f\u5024\u304c\u7570\u306a\u308b\u305f\u3081\u3001\u540c\u4e00\u30e1\u30c3\u30bb\u30fc\u30b8\u3067\u3042\u3063\u3066\u3082\u5024\u306f\u7570\u306a\u308b\u3002 SHA-512/224 \u304a\u3088\u3073 SHA-512/256 \u3082\u540c\u69d8\u3067\u3042\u308b\u3002\n\n\u30bd\u30fc\u30b9\u30b3\u30fc\u30c9\n\nsha512.rs\nmacro_rules! Ch {\n    ($x:expr, $y:expr, $z:expr) => { ($x & $y) ^ (!$x & $z) };\n}\nmacro_rules! Maj {\n    ($x:expr, $y:expr, $z:expr) => { ($x & $y) ^ ($x & $z) ^ ($y & $z) };\n}\n\n/// \u8ffd\u52a0\u5b9a\u6570\nconst K512: [u64; 80] = [\n    0x428a2f98d728ae22, 0x7137449123ef65cd, 0xb5c0fbcfec4d3b2f, 0xe9b5dba58189dbbc,\n    0x3956c25bf348b538, 0x59f111f1b605d019, 0x923f82a4af194f9b, 0xab1c5ed5da6d8118,\n    0xd807aa98a3030242, 0x12835b0145706fbe, 0x243185be4ee4b28c, 0x550c7dc3d5ffb4e2,\n    0x72be5d74f27b896f, 0x80deb1fe3b1696b1, 0x9bdc06a725c71235, 0xc19bf174cf692694,\n    0xe49b69c19ef14ad2, 0xefbe4786384f25e3, 0x0fc19dc68b8cd5b5, 0x240ca1cc77ac9c65,\n    0x2de92c6f592b0275, 0x4a7484aa6ea6e483, 0x5cb0a9dcbd41fbd4, 0x76f988da831153b5,\n    0x983e5152ee66dfab, 0xa831c66d2db43210, 0xb00327c898fb213f, 0xbf597fc7beef0ee4,\n    0xc6e00bf33da88fc2, 0xd5a79147930aa725, 0x06ca6351e003826f, 0x142929670a0e6e70,\n    0x27b70a8546d22ffc, 0x2e1b21385c26c926, 0x4d2c6dfc5ac42aed, 0x53380d139d95b3df,\n    0x650a73548baf63de, 0x766a0abb3c77b2a8, 0x81c2c92e47edaee6, 0x92722c851482353b,\n    0xa2bfe8a14cf10364, 0xa81a664bbc423001, 0xc24b8b70d0f89791, 0xc76c51a30654be30,\n    0xd192e819d6ef5218, 0xd69906245565a910, 0xf40e35855771202a, 0x106aa07032bbd1b8,\n    0x19a4c116b8d2d0c8, 0x1e376c085141ab53, 0x2748774cdf8eeb99, 0x34b0bcb5e19b48a8,\n    0x391c0cb3c5c95a63, 0x4ed8aa4ae3418acb, 0x5b9cca4f7763e373, 0x682e6ff3d6b2b8a3,\n    0x748f82ee5defb2fc, 0x78a5636f43172f60, 0x84c87814a1f0ab72, 0x8cc702081a6439ec,\n    0x90befffa23631e28, 0xa4506cebde82bde9, 0xbef9a3f7b2c67915, 0xc67178f2e372532b,\n    0xca273eceea26619c, 0xd186b8c721c0c207, 0xeada7dd6cde0eb1e, 0xf57d4f7fee6ed178,\n    0x06f067aa72176fba, 0x0a637dc5a2c898a6, 0x113f9804bef90dae, 0x1b710b35131c471b,\n    0x28db77f523047d84, 0x32caab7b40c72493, 0x3c9ebe0a15c9bebc, 0x431d67c49c100d4c,\n    0x4cc5d4becb3e42b6, 0x597f299cfc657e2a, 0x5fcb6fab3ad6faec, 0x6c44198c4a475817\n];\n\nfn large_sigma0_512(x: u64) -> u64 {\n    x.rotate_right(28) ^ x.rotate_right(34) ^ x.rotate_right(39)\n}\nfn large_sigma1_512(x: u64) -> u64 {\n    x.rotate_right(14) ^ x.rotate_right(18) ^ x.rotate_right(41)\n}\nfn sigma0_512(x: u64) -> u64 {\n    x.rotate_right( 1) ^ x.rotate_right( 8) ^ (x >> 7)\n}\nfn sigma1_512(x: u64) -> u64 {\n    x.rotate_right(19) ^ x.rotate_right(61) ^ (x >> 6)\n}\n\n/// \u5727\u7e2e\u95a2\u6570\nfn round(state: [u64; 8], block: [u64; 16]) -> [u64; 8] {\n    let w = {\n        let mut w = [0; 80];\n        for t in 0..16 {\n            w[t] = block[t];\n        }\n        for t in 16..80 {\n            w[t] = sigma1_512(w[t-2]).wrapping_add(w[t-7])\n                                     .wrapping_add(sigma0_512(w[t-15]))\n                                     .wrapping_add(w[t-16]);\n        }\n        w\n    };\n    let (mut a, mut b, mut c, mut d, mut e, mut f, mut g, mut h) = (\n        state[0],\n        state[1],\n        state[2],\n        state[3],\n        state[4],\n        state[5],\n        state[6],\n        state[7]\n    );\n    for t in 0..80 {\n        let t1 = h.wrapping_add(large_sigma1_512(e))\n                  .wrapping_add(Ch!(e, f, g))\n                  .wrapping_add(K512[t])\n                  .wrapping_add(w[t]);\n        let t2 = large_sigma0_512(a).wrapping_add(Maj!(a, b, c));\n        h = g;\n        g = f;\n        f = e;\n        e = d.wrapping_add(t1);\n        d = c;\n        c = b;\n        b = a;\n        a = t1.wrapping_add(t2);\n    }\n    [\n        a.wrapping_add(state[0]),\n        b.wrapping_add(state[1]),\n        c.wrapping_add(state[2]),\n        d.wrapping_add(state[3]),\n        e.wrapping_add(state[4]),\n        f.wrapping_add(state[5]),\n        g.wrapping_add(state[6]),\n        h.wrapping_add(state[7])\n    ]\n}\n\n/// \u30d1\u30c7\u30a3\u30f3\u30b0\u3092\u52a0\u3048\u305f\u30c7\u30fc\u30bf\u3092\u30d6\u30ed\u30c3\u30af\u306b\u5206\u5272\u3059\u308b\u3002\nfn separate_data(data: Vec<u8>) -> Vec<[u64; 16]> {\n    let mut blocks = Vec::with_capacity(data.len() / 128);\n    let mut idx = 0;\n    let mut shift = 64;\n    let mut block = [0; 16];\n    for byte in data.iter() {\n        shift -= 8;\n        block[idx] |= (*byte as u64) << shift;\n        if shift == 0 {\n            idx += 1;\n            shift = 64;\n        }\n        if idx == 16 {\n            blocks.push(block);\n            block = [0; 16];\n            idx = 0;\n        }\n    }\n    blocks\n}\n\npub struct Length {\n    uppper: u64,\n    lower: u64\n}\nimpl Length {\n    pub fn new(val: u64) -> Length {\n        Length {\n            uppper: 0,\n            lower: val\n        }\n    }\n    fn get_data_length(&self) -> usize {\n        ((self.lower / 1024) * 128 + if (self.lower % 1024) <= 895 { 128 } else { 256 }) as usize\n    }\n    fn seek_remainder_octet(&self) -> usize {\n        // self % 8\n        (self.lower & 0b111) as usize\n    }\n    fn get_octet_vec(&self) -> Vec<u8> {\n        let mut vec: Vec<u8> = Vec::with_capacity(16);\n        for j in 0..8 {\n            vec.push((self.uppper >> (56 - j * 8) as u32) as u8);\n        }\n        for j in 0..8 {\n            vec.push((self.lower >> (56 - j * 8) as u32) as u8);\n        }\n        vec\n    }\n}\n\n/// \u30e1\u30c3\u30bb\u30fc\u30b8\u306b\u30d1\u30c7\u30a3\u30f3\u30b0\u3092\u8ffd\u52a0\u3059\u308b\u3002\nfn add_padding(message: &Vec<u8>, length: Length) -> Vec<u8> {\n    let data_len = length.get_data_length();\n    let mut data: Vec<u8> = Vec::with_capacity(data_len);\n\n    // copy message\n    for byte in message.iter() {\n        data.push(*byte);\n    }\n\n    // add padding\n    if length.seek_remainder_octet() == 0 {\n        data.push(0x80);\n    } else {\n        let len = data.len();\n        data[len - 1] |= 1 << (7 - length.seek_remainder_octet()) as u32;\n    }\n    for _ in 0..(data_len - data.len() - 16) {\n        data.push(0x00);\n    }\n    for byte in length.get_octet_vec().iter() {\n        data.push(*byte);\n    }\n\n    data\n}\n\n/// \u30cf\u30c3\u30b7\u30e5\u9577\npub enum Sha521DigestSize {\n    Len224 = 224,\n    Len256 = 256,\n    Len384 = 384,\n    Len512 = 512,\n}\n\n/// \u30cf\u30c3\u30b7\u30e5\u306e\u53d6\u5f97\u3002message \u306b\u30e1\u30c3\u30bb\u30fc\u30b8\u3092\u4ee3\u5165\u3057\u3001 message_length \u306b\u30e1\u30c3\u30bb\u30fc\u30b8\u9577\u3092\u4ee3\u5165\u3059\u308b\u3002\npub fn create_hash(message: &Vec<u8>, message_length: Length, digest_size: Sha521DigestSize) -> Box<[u8]> {\n    // \u30d1\u30c7\u30a3\u30f3\u30b0\u306e\u8ffd\u52a0\n    let data = add_padding(message, message_length);\n    // \u30c7\u30fc\u30bf\u3092\u30d6\u30ed\u30c3\u30af\u306b\u5206\u5272\n    let blocks = separate_data(data);\n    // \u521d\u671f\u5024\n    let mut state = match digest_size {\n        Sha521DigestSize::Len224 => [\n            0x8c3d37c819544da2,\n            0x73e1996689dcd4d6,\n            0x1dfab7ae32ff9c82,\n            0x679dd514582f9fcf,\n            0x0f6d2b697bd44da8,\n            0x77e36f7304c48942,\n            0x3f9d85a86a1d36c8,\n            0x1112e6ad91d692a1\n        ],\n        Sha521DigestSize::Len256 => [\n            0x22312194fc2bf72c,\n            0x9f555fa3c84c64c2,\n            0x2393b86b6f53b151,\n            0x963877195940eabd,\n            0x96283ee2a88effe3,\n            0xbe5e1e2553863992,\n            0x2b0199fc2c85b8aa,\n            0x0eb72ddc81c52ca2\n        ],\n        Sha521DigestSize::Len384 => [\n            0xcbbb9d5dc1059ed8,\n            0x629a292a367cd507,\n            0x9159015a3070dd17,\n            0x152fecd8f70e5939,\n            0x67332667ffc00b31,\n            0x8eb44a8768581511,\n            0xdb0c2e0d64f98fa7,\n            0x47b5481dbefa4fa4\n        ],\n        Sha521DigestSize::Len512 => [\n            0x6a09e667f3bcc908,\n            0xbb67ae8584caa73b,\n            0x3c6ef372fe94f82b,\n            0xa54ff53a5f1d36f1,\n            0x510e527fade682d1,\n            0x9b05688c2b3e6c1f,\n            0x1f83d9abfb41bd6b,\n            0x5be0cd19137e2179\n        ],\n    };\n    // \u30d6\u30ed\u30c3\u30af\u3092\u5727\u7e2e\u95a2\u6570\u306b\u4ee3\u5165\n    for block in blocks.iter() {\n        state = round(state, *block);\n    }\n    // \u30cf\u30c3\u30b7\u30e5\u306e\u4f5c\u6210\n    let hash_length = digest_size as usize;\n    let mut hash: Vec<u8> = Vec::with_capacity(hash_length);\n    let mut length = 0;\n    'outer: for h in state.iter() {\n        use std::mem::transmute;\n\n        let from = if cfg!(target_endian = \"big\") {\n            *h\n        } else {\n            (*h).swap_bytes()\n        };\n        for byte in unsafe { transmute::<u64, [u8; 8]>(from) }.iter() {\n            hash.push(*byte);\n            length += 8;\n            if length == hash_length as usize {\n                break 'outer;\n            }\n        }\n    }\n\n    // \u623b\u308a\u5024\n    hash.into_boxed_slice()\n}\n\n\n\u3053\u306e\u30d7\u30ed\u30b0\u30e9\u30e0\u306f\u3001 create_hash \u95a2\u6570\u306e\u7b2c1\u5f15\u6570\u306b\u30e1\u30c3\u30bb\u30fc\u30b8 ( Vec<u8> \u578b ) \u3001\u7b2c2\u5f15\u6570\u306b\u30e1\u30c3\u30bb\u30fc\u30b8\u9577 ( Length \u578b ) \u3001\u7b2c3\u5f15\u6570\u306b\u30cf\u30c3\u30b7\u30e5\u9577 ( Sha521DigestSize \u578b ) \u3092\u4ee3\u5165\u3057\u3066\u3067\u30cf\u30c3\u30b7\u30e5 ( Box<[u8]> \u578b ) \u3092\u53d6\u5f97\u3059\u308b\u3002\n\u6b21\u306e\u30b3\u30fc\u30c9\u306f\u3001\u7a7a\u306e\u30e1\u30c3\u30bb\u30fc\u30b8\u304b\u3089 SHA-512 \u3092\u53d6\u5f97\u3059\u308b\u4f8b\u3067\u3042\u308b\u3002\nlet message: Vec<u8> = vec![];\nlet hash = create_hash(&message, Length::new(0), Sha521DigestSize::Len512);\n\n\n\u30c6\u30b9\u30c8\n\u7a7a\u306e\u30e1\u30c3\u30bb\u30fc\u30b8 \"\" \u306e\u30cf\u30c3\u30b7\u30e5\n\n\n\n\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0\n\u30cf\u30c3\u30b7\u30e5\n\n\n\n\nSHA-384\n38b060a751ac9638 4cd9327eb1b1e36a 21fdb71114be0743 4c0cc7bf63f6e1da 274edebfe76f65fb d51ad2f14898b95b\n\n\nSHA-512\ncf83e1357eefb8bd f1542850d66d8007 d620e4050b5715dc 83f4a921d36ce9ce 47d0d13c5d85f2b0 ff8318d2877eec2f 63b931bd47417a81 a538327af927da3e\n\n\nSHA-512/224\n6b4e03423667dbb7 3b6e15454f0eb1ab d4597f9a1b078e3f 5b5a6bc7\n\n\nSHA-512/256\na7ffc6f8bf1ed766 51c14756a061d662 f580ff4de43b49fa 82d80a4b80f8434a\n\n\n\n\nsha512_empty_message_tests\n/// \u7a7a\u306e\u30e1\u30c3\u30bb\u30fc\u30b8 \"\" \u306b\u5bfe\u3057 SHA384 \u3092\u53d6\u308b\n#[test]\nfn sha2_384_hash_by_empty_msg() {\n    let hash = create_hash(&vec![], Length::new(0), Sha521DigestSize::Len384);\n    assert_eq!(hash, vec![\n        0x38, 0xb0, 0x60, 0xa7, 0x51, 0xac, 0x96, 0x38,\n        0x4c, 0xd9, 0x32, 0x7e, 0xb1, 0xb1, 0xe3, 0x6a,\n        0x21, 0xfd, 0xb7, 0x11, 0x14, 0xbe, 0x07, 0x43,\n        0x4c, 0x0c, 0xc7, 0xbf, 0x63, 0xf6, 0xe1, 0xda,\n        0x27, 0x4e, 0xde, 0xbf, 0xe7, 0x6f, 0x65, 0xfb,\n        0xd5, 0x1a, 0xd2, 0xf1, 0x48, 0x98, 0xb9, 0x5b\n    ].into_boxed_slice());\n}\n/// \u7a7a\u306e\u30e1\u30c3\u30bb\u30fc\u30b8 \"\" \u306b\u5bfe\u3057 SHA512 \u3092\u53d6\u308b\n#[test]\nfn sha2_512_hash_by_empty_msg() {\n    let hash = create_hash(&vec![], Length::new(0), Sha521DigestSize::Len512);\n    assert_eq!(hash, vec![\n        0xcf, 0x83, 0xe1, 0x35, 0x7e, 0xef, 0xb8, 0xbd,\n        0xf1, 0x54, 0x28, 0x50, 0xd6, 0x6d, 0x80, 0x07,\n        0xd6, 0x20, 0xe4, 0x05, 0x0b, 0x57, 0x15, 0xdc,\n        0x83, 0xf4, 0xa9, 0x21, 0xd3, 0x6c, 0xe9, 0xce,\n        0x47, 0xd0, 0xd1, 0x3c, 0x5d, 0x85, 0xf2, 0xb0,\n        0xff, 0x83, 0x18, 0xd2, 0x87, 0x7e, 0xec, 0x2f,\n        0x63, 0xb9, 0x31, 0xbd, 0x47, 0x41, 0x7a, 0x81,\n        0xa5, 0x38, 0x32, 0x7a, 0xf9, 0x27, 0xda, 0x3e\n    ].into_boxed_slice());\n}\n/// \u7a7a\u306e\u30e1\u30c3\u30bb\u30fc\u30b8 \"\" \u306b\u5bfe\u3057 SHA521/224 \u3092\u53d6\u308b\n#[test]\nfn sha2_224_by_512_hash_by_empty_msg() {\n    let hash = create_hash(&vec![], Length::new(0), Sha521DigestSize::Len224);\n    assert_eq!(hash, vec![\n        0x6e, 0xd0, 0xdd, 0x02, 0x80, 0x6f, 0xa8, 0x9e,\n        0x25, 0xde, 0x06, 0x0c, 0x19, 0xd3, 0xac, 0x86,\n        0xca, 0xbb, 0x87, 0xd6, 0xa0, 0xdd, 0xd0, 0x5c,\n        0x33, 0x3b, 0x84, 0xf4\n    ].into_boxed_slice());\n}\n/// \u7a7a\u306e\u30e1\u30c3\u30bb\u30fc\u30b8 \"\" \u306b\u5bfe\u3057 SHA521/256 \u3092\u53d6\u308b\n#[test]\nfn sha2_256_by_512_hash_by_empty_msg() {\n    let hash = create_hash(&vec![], Length::new(0), Sha521DigestSize::Len256);\n    assert_eq!(hash, vec![\n        0xc6, 0x72, 0xb8, 0xd1, 0xef, 0x56, 0xed, 0x28,\n        0xab, 0x87, 0xc3, 0x62, 0x2c, 0x51, 0x14, 0x06,\n        0x9b, 0xdd, 0x3a, 0xd7, 0xb8, 0xf9, 0x73, 0x74,\n        0x98, 0xd0, 0xc0, 0x1e, 0xce, 0xf0, 0x96, 0x7a\n    ].into_boxed_slice());\n}\n\n\n\u30e1\u30c3\u30bb\u30fc\u30b8\u304c \"abc\" \u306e\u30cf\u30c3\u30b7\u30e5\n\n\n\n\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0\n\u30cf\u30c3\u30b7\u30e5\n\n\n\n\nSHA-384\ncb00753f45a35e8b b5a03d699ac65007 272c32ab0eded163 1a8b605a43ff5bed 8086072ba1e7cc23 58baeca134c825a7\n\n\nSHA-512\nddaf35a193617aba cc417349ae204131 12e6fa4e89a97ea2 0a9eeee64b55d39a 2192992a274fc1a8 36ba3c23a3feebbd 454d4423643ce80e 2a9ac94fa54ca49f\n\n\n\n\nsha512_abc_message_tests\n/// \u30e1\u30c3\u30bb\u30fc\u30b8 \"abc\" \u306b\u5bfe\u3057 SHA384 \u3092\u53d6\u308b\n#[test]\nfn sha2_384_hash_by_abc_msg() {\n    let hash = create_hash(&vec![b'a', b'b', b'c'], Length::new(24), Sha521DigestSize::Len384);\n    assert_eq!(hash, vec![\n        0xcb, 0x00, 0x75, 0x3f, 0x45, 0xa3, 0x5e, 0x8b,\n        0xb5, 0xa0, 0x3d, 0x69, 0x9a, 0xc6, 0x50, 0x07,\n        0x27, 0x2c, 0x32, 0xab, 0x0e, 0xde, 0xd1, 0x63,\n        0x1a, 0x8b, 0x60, 0x5a, 0x43, 0xff, 0x5b, 0xed,\n        0x80, 0x86, 0x07, 0x2b, 0xa1, 0xe7, 0xcc, 0x23,\n        0x58, 0xba, 0xec, 0xa1, 0x34, 0xc8, 0x25, 0xa7\n    ].into_boxed_slice());\n}\n/// \u30e1\u30c3\u30bb\u30fc\u30b8 \"abc\" \u306b\u5bfe\u3057 SHA512 \u3092\u53d6\u308b\n#[test]\nfn sha2_512_hash_by_abc_msg() {\n    let hash = create_hash(&vec![b'a', b'b', b'c'], Length::new(24), Sha521DigestSize::Len512);\n    assert_eq!(hash, vec![\n        0xdd, 0xaf, 0x35, 0xa1, 0x93, 0x61, 0x7a, 0xba,\n        0xcc, 0x41, 0x73, 0x49, 0xae, 0x20, 0x41, 0x31,\n        0x12, 0xe6, 0xfa, 0x4e, 0x89, 0xa9, 0x7e, 0xa2,\n        0x0a, 0x9e, 0xee, 0xe6, 0x4b, 0x55, 0xd3, 0x9a,\n        0x21, 0x92, 0x99, 0x2a, 0x27, 0x4f, 0xc1, 0xa8,\n        0x36, 0xba, 0x3c, 0x23, 0xa3, 0xfe, 0xeb, 0xbd,\n        0x45, 0x4d, 0x44, 0x23, 0x64, 0x3c, 0xe8, 0x0e,\n        0x2a, 0x9a, 0xc9, 0x4f, 0xa5, 0x4c, 0xa4, 0x9f\n    ].into_boxed_slice());\n}\n\n\n\u30e1\u30c3\u30bb\u30fc\u30b8\u304c x \u30d3\u30c3\u30c8\u306e 0 \u3067\u3042\u308b SHA-512 \u30cf\u30c3\u30b7\u30e5\n\n\n\n\u30d3\u30c3\u30c8\u6570\n\u30cf\u30c3\u30b7\u30e5\n\n\n\n\n895\n12DD83C5B6547758 452DC7020EE32F53 F5A0EB65D33C4D3F EEBCE17D7113DB14 0393C8FBE49FC071 E40B585DF969C7AA 3A8196CE2B94E83E 7941EC05E2018751\n\n\n896\n2BE2E788C8A8ADEA A9C89A7F78904CAC EA6E39297D75E057 3A73C756234534D6 627AB4156B48A665 7B29AB8BEB733340 40AD39EAD81446BB 09C70704EC707952\n\n\n\n\nsha512_x_zero_bits_tests\n/// 895 bit \u306e 0 \u3067\u69cb\u6210\u3055\u308c\u305f\u30e1\u30c3\u30bb\u30fc\u30b8\u306b\u5bfe\u3057 SHA512 \u3092\u53d6\u308b\uff08\u5883\u754c\u30c6\u30b9\u30c8\uff09\n#[test]\nfn sha2_512_hash_by_895_zero_bits() {\n    let hash = create_hash(&vec![\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00\n    ], Length::new(895), Sha521DigestSize::Len512);\n    assert_eq!(hash, vec![\n        0x12, 0xDD, 0x83, 0xC5, 0xB6, 0x54, 0x77, 0x58,\n        0x45, 0x2D, 0xC7, 0x02, 0x0E, 0xE3, 0x2F, 0x53,\n        0xF5, 0xA0, 0xEB, 0x65, 0xD3, 0x3C, 0x4D, 0x3F,\n        0xEE, 0xBC, 0xE1, 0x7D, 0x71, 0x13, 0xDB, 0x14,\n        0x03, 0x93, 0xC8, 0xFB, 0xE4, 0x9F, 0xC0, 0x71,\n        0xE4, 0x0B, 0x58, 0x5D, 0xF9, 0x69, 0xC7, 0xAA,\n        0x3A, 0x81, 0x96, 0xCE, 0x2B, 0x94, 0xE8, 0x3E,\n        0x79, 0x41, 0xEC, 0x05, 0xE2, 0x01, 0x87, 0x51\n    ].into_boxed_slice());\n}\n/// 896 bit \u306e 0 \u3067\u69cb\u6210\u3055\u308c\u305f\u30e1\u30c3\u30bb\u30fc\u30b8\u306b\u5bfe\u3057 SHA512 \u3092\u53d6\u308b\uff08\u5883\u754c\u30c6\u30b9\u30c8\uff09\n#[test]\nfn sha2_512_hash_by_896_zero_bits() {\n    let hash = create_hash(&vec![\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00\n    ], Length::new(896), Sha521DigestSize::Len512);\n    assert_eq!(hash, vec![\n        0x2B, 0xE2, 0xE7, 0x88, 0xC8, 0xA8, 0xAD, 0xEA,\n        0xA9, 0xC8, 0x9A, 0x7F, 0x78, 0x90, 0x4C, 0xAC,\n        0xEA, 0x6E, 0x39, 0x29, 0x7D, 0x75, 0xE0, 0x57,\n        0x3A, 0x73, 0xC7, 0x56, 0x23, 0x45, 0x34, 0xD6,\n        0x62, 0x7A, 0xB4, 0x15, 0x6B, 0x48, 0xA6, 0x65,\n        0x7B, 0x29, 0xAB, 0x8B, 0xEB, 0x73, 0x33, 0x40,\n        0x40, 0xAD, 0x39, 0xEA, 0xD8, 0x14, 0x46, 0xBB,\n        0x09, 0xC7, 0x07, 0x04, 0xEC, 0x70, 0x79, 0x52\n    ].into_boxed_slice());\n}\n\n\n\n\u9010\u6b21\u5b9f\u884c\n\u92ed\u3044\u65b9\u306f\u3059\u3067\u306b\u304a\u6c17\u3065\u304d\u304b\u3082\u3057\u308c\u306a\u3044\u304c\u3001\u5b9f\u306f sha256.rs \u3068 sha512.rs \u306f\u5b8c\u5168\u3067\u306f\u306a\u3044\u3002\u30e1\u30c3\u30bb\u30fc\u30b8\u3092\u4ee3\u5165\u3059\u308b\u578b\u306f\u3044\u305a\u308c\u3082 Vec<u8> \u578b\u3067\u3042\u308b\u304c\u3001\u3053\u308c\u3067\u306f\u4ed5\u69d8\u304c\u5b9a\u3081\u308b\u6700\u5927\u30e1\u30c3\u30bb\u30fc\u30b8\u9577\u306e\u30e1\u30c3\u30bb\u30fc\u30b8\u3092\u4ee3\u5165\u3067\u304d\u306a\u3044\u3002\nVec<u32> \u3084 Vec<u64> \u306b\u62e1\u5f35\u3059\u308b\u3068\u3044\u3046\u624b\u3082\u3042\u308b\u304c\u3001\u30e1\u30e2\u30ea\u3092\u591a\u304f\u5360\u6709\u3059\u308b\u3057\u3001\u6700\u7d42\u7684\u306b\u4e00\u6c17\u306b\u51e6\u7406\u3092\u3057\u306a\u3051\u308c\u3070\u306a\u3089\u306a\u3044\u306e\u3067\u4e0d\u4fbf\u3067\u3042\u308b\u3002\n\u3057\u305f\u304c\u3063\u3066\u3001\u30e1\u30c3\u30bb\u30fc\u30b8\u3092\u66f8\u304d\u8fbc\u3093\u3060\u3089\u3001\u4e00\u6642\u7684\u306b\u30d0\u30c3\u30d5\u30a1\u306b\u6e9c\u3081\u3001\u30d6\u30ed\u30c3\u30af\u30b5\u30a4\u30ba\u307e\u3067\u6e9c\u307e\u308b\u3054\u3068\u306b\u51e6\u7406\u3092\u884c\u3046\u3088\u3046\u306b\u3059\u308b\u3002\u30e1\u30c3\u30bb\u30fc\u30b8\u3092\u3059\u3079\u3066\u66f8\u304d\u8fbc\u3093\u3060\u3089\u30d1\u30c7\u30a3\u30f3\u30b0\u8ffd\u52a0\u51e6\u7406\u3092\u884c\u3048\u3070\u3044\u3044\u3002\n\nsha2.rs\nuse std::boxed::Box;\n\n\nmacro_rules! Ch {\n    ($x:expr, $y:expr, $z:expr) => { ($x & $y) ^ (!$x & $z) };\n}\nmacro_rules! Maj {\n    ($x:expr, $y:expr, $z:expr) => { ($x & $y) ^ ($x & $z) ^ ($y & $z) };\n}\n\n/// SHA256\u8ffd\u52a0\u5b9a\u6570\nconst K256: [u32; 64] = [\n    0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5,\n    0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n    0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3,\n    0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n    0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc,\n    0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n    0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7,\n    0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n    0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13,\n    0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n    0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3,\n    0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n    0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5,\n    0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n    0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208,\n    0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2\n];\n/// SHA512\u8ffd\u52a0\u5b9a\u6570\nconst K512: [u64; 80] = [\n    0x428a2f98d728ae22, 0x7137449123ef65cd, 0xb5c0fbcfec4d3b2f, 0xe9b5dba58189dbbc,\n    0x3956c25bf348b538, 0x59f111f1b605d019, 0x923f82a4af194f9b, 0xab1c5ed5da6d8118,\n    0xd807aa98a3030242, 0x12835b0145706fbe, 0x243185be4ee4b28c, 0x550c7dc3d5ffb4e2,\n    0x72be5d74f27b896f, 0x80deb1fe3b1696b1, 0x9bdc06a725c71235, 0xc19bf174cf692694,\n    0xe49b69c19ef14ad2, 0xefbe4786384f25e3, 0x0fc19dc68b8cd5b5, 0x240ca1cc77ac9c65,\n    0x2de92c6f592b0275, 0x4a7484aa6ea6e483, 0x5cb0a9dcbd41fbd4, 0x76f988da831153b5,\n    0x983e5152ee66dfab, 0xa831c66d2db43210, 0xb00327c898fb213f, 0xbf597fc7beef0ee4,\n    0xc6e00bf33da88fc2, 0xd5a79147930aa725, 0x06ca6351e003826f, 0x142929670a0e6e70,\n    0x27b70a8546d22ffc, 0x2e1b21385c26c926, 0x4d2c6dfc5ac42aed, 0x53380d139d95b3df,\n    0x650a73548baf63de, 0x766a0abb3c77b2a8, 0x81c2c92e47edaee6, 0x92722c851482353b,\n    0xa2bfe8a14cf10364, 0xa81a664bbc423001, 0xc24b8b70d0f89791, 0xc76c51a30654be30,\n    0xd192e819d6ef5218, 0xd69906245565a910, 0xf40e35855771202a, 0x106aa07032bbd1b8,\n    0x19a4c116b8d2d0c8, 0x1e376c085141ab53, 0x2748774cdf8eeb99, 0x34b0bcb5e19b48a8,\n    0x391c0cb3c5c95a63, 0x4ed8aa4ae3418acb, 0x5b9cca4f7763e373, 0x682e6ff3d6b2b8a3,\n    0x748f82ee5defb2fc, 0x78a5636f43172f60, 0x84c87814a1f0ab72, 0x8cc702081a6439ec,\n    0x90befffa23631e28, 0xa4506cebde82bde9, 0xbef9a3f7b2c67915, 0xc67178f2e372532b,\n    0xca273eceea26619c, 0xd186b8c721c0c207, 0xeada7dd6cde0eb1e, 0xf57d4f7fee6ed178,\n    0x06f067aa72176fba, 0x0a637dc5a2c898a6, 0x113f9804bef90dae, 0x1b710b35131c471b,\n    0x28db77f523047d84, 0x32caab7b40c72493, 0x3c9ebe0a15c9bebc, 0x431d67c49c100d4c,\n    0x4cc5d4becb3e42b6, 0x597f299cfc657e2a, 0x5fcb6fab3ad6faec, 0x6c44198c4a475817\n];\n\nfn large_sigma0_256(x: u32) -> u32 {\n    x.rotate_right( 2) ^ x.rotate_right(13) ^ x.rotate_right(22)\n}\nfn large_sigma1_256(x: u32) -> u32 {\n    x.rotate_right( 6) ^ x.rotate_right(11) ^ x.rotate_right(25)\n}\nfn sigma0_256(x: u32) -> u32 {\n    x.rotate_right( 7) ^ x.rotate_right(18) ^ (x >> 3)\n}\nfn sigma1_256(x: u32) -> u32 {\n    x.rotate_right(17) ^ x.rotate_right(19) ^ (x >> 10)\n}\n\nfn large_sigma0_512(x: u64) -> u64 {\n    x.rotate_right(28) ^ x.rotate_right(34) ^ x.rotate_right(39)\n}\nfn large_sigma1_512(x: u64) -> u64 {\n    x.rotate_right(14) ^ x.rotate_right(18) ^ x.rotate_right(41)\n}\nfn sigma0_512(x: u64) -> u64 {\n    x.rotate_right( 1) ^ x.rotate_right( 8) ^ (x >> 7)\n}\nfn sigma1_512(x: u64) -> u64 {\n    x.rotate_right(19) ^ x.rotate_right(61) ^ (x >> 6)\n}\n\nfn change_u32_to_array_u8(from: u32) -> [u8; 4] {\n    use std::mem::transmute;\n\n    unsafe { transmute::<u32, [u8; 4]>(from.to_be()) }\n}\nfn change_u64_to_array_u32(from: u64) -> [u32; 2] {\n    use std::mem::transmute;\n\n    unsafe { transmute::<u64, [u32; 2]>(from) }\n}\nfn change_u64_to_array_u8(from: u64) -> [u8; 8] {\n    use std::mem::transmute;\n\n    unsafe { transmute::<u64, [u8; 8]>(from.to_be()) }\n}\n\nmacro_rules! add_msg_len {\n    ($self_:expr, $upper:expr, $lower:expr) => ({\n        let (val, overflow) = $self_.lower.overflowing_add($lower);\n        if overflow {\n            let (val, overflow) = $self_.upper.overflowing_add(1);\n            if overflow {\n                return Result::Err(());\n            }\n            $self_.upper = val;\n        }\n        $self_.lower = val;\n        let (val, overflow) = $self_.upper.overflowing_add($upper);\n        if overflow {\n            Result::Err(())\n        } else {\n            $self_.upper = val;\n            Result::Ok(())\n        }\n    })\n}\n\npub struct Length<T> {\n    upper: T,\n    lower: T\n}\nimpl Length<u32> {\n    pub fn new(val: u32) -> Length<u32> {\n        Length {\n            upper: 0,\n            lower: val\n        }\n    }\n    fn add_msg_len(&mut self, oct: usize, rem: u8) -> Result<(), ()> {\n        if oct & (usize::max_value() << 61) > 0 {\n            return Result::Err(());\n        }\n        let arry = change_u64_to_array_u32(((oct as u64) << 3) + rem as u64);\n        add_msg_len!(self, arry[1], arry[0])\n    }\n}\nimpl Length<u64> {\n    pub fn new(val: u64) -> Length<u64> {\n        Length {\n            upper: 0,\n            lower: val\n        }\n    }\n    fn add_msg_len(&mut self, oct: usize, rem: u8) -> Result<(), ()> {\n/*\n        if oct & (usize::max_value() << 125) > 0 {\n            return Result::Err(());\n        }\n*/\n        let arry = [((oct as u64) << 3) + rem as u64, oct as u64 >> 61];\n        add_msg_len!(self, arry[1], arry[0])\n    }\n}\n\ntrait Sha2DataRunner {\n    fn update(&mut self, data: &[u8], rem: u8) -> Result<(), ()>;\n    fn finish(mut self: Box<Self>) -> Box<[u8]>;\n}\n\nstruct Sha2Data<T> {\n    /// \u5165\u529b\u30c7\u30fc\u30bf\u306e\u4e00\u6642\u6e9c\u3081\u7f6e\u304d\n    buffer: [T; 16],\n    /// \u6e9c\u3081\u7f6e\u3044\u3066\u3044\u308b\u30c7\u30fc\u30bf\u306e bit \u30b5\u30a4\u30ba\n    buffer_size: u16,\n    /// \u5185\u90e8\u72b6\u614b\n    state: [T; 8],\n    /// \u30e1\u30c3\u30bb\u30fc\u30b8\u5168\u4f53\u306e bit \u30b5\u30a4\u30ba\n    msg_length: Length<T>,\n    /// \u30cf\u30c3\u30b7\u30e5\u30b5\u30a4\u30ba[bit]\n    length: u16,\n}\n\ntype Sha256 = Sha2Data<u32>;\ntype Sha512 = Sha2Data<u64>;\n\ntype Sha256Length = Length<u32>;\ntype Sha512Length = Length<u64>;\n\nenum Sha256DigestSize {\n    Len224 = 224,\n    Len256 = 256,\n}\n\nimpl Sha256 {\n    fn new(digest: Sha256DigestSize) -> Sha256 {\n        let init_state = match digest {\n            Sha256DigestSize::Len224 => [\n                0xc1059ed8,\n                0x367cd507,\n                0x3070dd17,\n                0xf70e5939,\n                0xffc00b31,\n                0x68581511,\n                0x64f98fa7,\n                0xbefa4fa4\n            ],\n            Sha256DigestSize::Len256 => [\n                0x6a09e667,\n                0xbb67ae85,\n                0x3c6ef372,\n                0xa54ff53a,\n                0x510e527f,\n                0x9b05688c,\n                0x1f83d9ab,\n                0x5be0cd19\n            ]\n        };\n        Sha256 {\n            buffer: [0; 16],\n            buffer_size: 0,\n            state: init_state,\n            msg_length: Sha256Length::new(0),\n            length: digest as u16,\n        }\n    }\n    fn run(&mut self) {\n        let w = {\n            let mut w = [0; 64];\n            for t in 0..16 {\n                w[t] = self.buffer[t];\n            }\n            for t in 16..64 {\n                w[t] = sigma1_256(w[t-2]).wrapping_add(w[t-7])\n                                        .wrapping_add(sigma0_256(w[t-15]))\n                                        .wrapping_add(w[t-16]);\n            }\n            w\n        };\n        let (mut a, mut b, mut c, mut d, mut e, mut f, mut g, mut h) = (\n            self.state[0],\n            self.state[1],\n            self.state[2],\n            self.state[3],\n            self.state[4],\n            self.state[5],\n            self.state[6],\n            self.state[7]\n        );\n        for t in 0..64 {\n            let t1 = h.wrapping_add(large_sigma1_256(e))\n                    .wrapping_add(Ch!(e, f, g))\n                    .wrapping_add(K256[t])\n                    .wrapping_add(w[t]);\n            let t2 = large_sigma0_256(a).wrapping_add(Maj!(a, b, c));\n            h = g;\n            g = f;\n            f = e;\n            e = d.wrapping_add(t1);\n            d = c;\n            c = b;\n            b = a;\n            a = t1.wrapping_add(t2);\n        }\n        self.state = [\n            a.wrapping_add(self.state[0]),\n            b.wrapping_add(self.state[1]),\n            c.wrapping_add(self.state[2]),\n            d.wrapping_add(self.state[3]),\n            e.wrapping_add(self.state[4]),\n            f.wrapping_add(self.state[5]),\n            g.wrapping_add(self.state[6]),\n            h.wrapping_add(self.state[7])\n        ];\n    }\n}\n\nimpl Sha2DataRunner for Sha256 {\n    fn update(&mut self, data: &[u8], rem: u8) -> Result<(), ()> {\n        debug_assert!(if data.len() == 0 { rem == 0 } else { rem > 0 && rem <= 8 });\n\n        let mut num = (self.buffer_size / 32) as usize;\n        let mut bit = (self.buffer_size % 32) as u32;\n        for i in 0..data.len() {\n            let add_data = if i < (data.len() - 1) {\n                bit += 8;\n                data[i] as u32\n            } else {\n                bit += rem as u32;\n                (data[i] & u8::max_value() << (8 - rem)) as u32\n            };\n            self.buffer[num] |= if bit <= 32 {\n                add_data << (32 - bit)\n            } else {\n                add_data >> (bit - 32)\n            };\n            if bit >= 32 {\n                num += 1;\n                bit -= 32;\n                if num >= 16 {\n                    self.run();\n                    self.buffer = [0; 16];\n                    num = 0;\n                }\n                if bit > 0 {\n                    self.buffer[num] |= add_data << (32 - bit);\n                }\n            }\n        }\n        self.buffer_size = (num as u32 * 32 + bit) as u16;\n        if rem == 0 || rem == 8 {\n            self.msg_length.add_msg_len(data.len(), 0)\n        } else {\n            self.msg_length.add_msg_len(data.len() - 1, rem)\n        }\n    }\n    fn finish(mut self: Box<Self>) -> Box<[u8]> {\n        // add padding\n        let idx = (self.buffer_size / 32) as usize;\n        let shift = 31 - self.buffer_size % 32;\n        self.buffer[idx] |= 0x1 << shift;\n        if idx >= 14 {\n            self.run();\n            self.buffer = [0; 16];\n            self.buffer_size = 0;\n        }\n        self.buffer[14] = self.msg_length.upper;\n        self.buffer[15] = self.msg_length.lower;\n        self.run();\n\n        // create hash\n        let mut result: Vec<u8> = Vec::with_capacity(self.length as usize / 8);\n        let mut length = 0;\n        'outer: for x in self.state.iter() {\n            let array = change_u32_to_array_u8(*x);\n            for byte in array.iter() {\n                result.push(*byte);\n                length += 8;\n                if length == self.length {\n                    break 'outer;\n                }\n            }\n        }\n        result.into_boxed_slice()\n    }\n}\n\nenum Sha512DigestSize {\n    Len224 = 224,\n    Len256 = 256,\n    Len384 = 384,\n    Len512 = 512,\n}\n\nimpl Sha512 {\n    pub fn new(digest: Sha512DigestSize) -> Sha512 {\n        let init_state = match digest {\n            Sha512DigestSize::Len384 => [\n                0xcbbb9d5dc1059ed8,\n                0x629a292a367cd507,\n                0x9159015a3070dd17,\n                0x152fecd8f70e5939,\n                0x67332667ffc00b31,\n                0x8eb44a8768581511,\n                0xdb0c2e0d64f98fa7,\n                0x47b5481dbefa4fa4\n            ],\n            Sha512DigestSize::Len512 => [\n                0x6a09e667f3bcc908,\n                0xbb67ae8584caa73b,\n                0x3c6ef372fe94f82b,\n                0xa54ff53a5f1d36f1,\n                0x510e527fade682d1,\n                0x9b05688c2b3e6c1f,\n                0x1f83d9abfb41bd6b,\n                0x5be0cd19137e2179\n            ],\n            Sha512DigestSize::Len224 => [\n                0x8c3d37c819544da2,\n                0x73e1996689dcd4d6,\n                0x1dfab7ae32ff9c82,\n                0x679dd514582f9fcf,\n                0x0f6d2b697bd44da8,\n                0x77e36f7304c48942,\n                0x3f9d85a86a1d36c8,\n                0x1112e6ad91d692a1\n            ],\n            Sha512DigestSize::Len256 => [\n                0x22312194fc2bf72c,\n                0x9f555fa3c84c64c2,\n                0x2393b86b6f53b151,\n                0x963877195940eabd,\n                0x96283ee2a88effe3,\n                0xbe5e1e2553863992,\n                0x2b0199fc2c85b8aa,\n                0x0eb72ddc81c52ca2\n            ]\n        };\n\n        Sha2Data {\n            buffer: [0; 16],\n            buffer_size: 0,\n            state: init_state,\n            msg_length: Sha512Length::new(0),\n            length: digest as u16,\n        }\n    }\n    fn run(&mut self) {\n        let w = {\n            let mut w = [0; 80];\n            for t in 0..16 {\n                w[t] = self.buffer[t];\n            }\n            for t in 16..80 {\n                w[t] = sigma1_512(w[t-2]).wrapping_add(w[t-7])\n                                         .wrapping_add(sigma0_512(w[t-15]))\n                                         .wrapping_add(w[t-16]);\n            }\n            w\n        };\n        let (mut a, mut b, mut c, mut d, mut e, mut f, mut g, mut h) = (\n            self.state[0],\n            self.state[1],\n            self.state[2],\n            self.state[3],\n            self.state[4],\n            self.state[5],\n            self.state[6],\n            self.state[7]\n        );\n        for t in 0..80 {\n            let t1 = h.wrapping_add(large_sigma1_512(e))\n                      .wrapping_add(Ch!(e, f, g))\n                      .wrapping_add(K512[t])\n                      .wrapping_add(w[t]);\n            let t2 = large_sigma0_512(a).wrapping_add(Maj!(a, b, c));\n            h = g;\n            g = f;\n            f = e;\n            e = d.wrapping_add(t1);\n            d = c;\n            c = b;\n            b = a;\n            a = t1.wrapping_add(t2);\n        }\n        self.state = [\n            a.wrapping_add(self.state[0]),\n            b.wrapping_add(self.state[1]),\n            c.wrapping_add(self.state[2]),\n            d.wrapping_add(self.state[3]),\n            e.wrapping_add(self.state[4]),\n            f.wrapping_add(self.state[5]),\n            g.wrapping_add(self.state[6]),\n            h.wrapping_add(self.state[7])\n        ];\n    }\n}\nimpl Sha2DataRunner for Sha512 {\n    fn update(&mut self, data: &[u8], rem: u8) -> Result<(), ()> {\n        debug_assert!(if data.len() == 0 { rem == 0 } else { rem > 0 && rem <= 8 });\n\n        let mut num = (self.buffer_size / 64) as usize;\n        let mut bit = (self.buffer_size % 64) as u32;\n        for i in 0..data.len() {\n            let add_data = if i < (data.len() - 1) {\n                bit += 8;\n                data[i] as u64\n            } else {\n                bit += rem as u32;\n                (data[i] & u8::max_value() << (8 - rem)) as u64\n            };\n            self.buffer[num] |= if bit <= 64 {\n                add_data << (64 - bit)\n            } else {\n                add_data >> (bit - 64)\n            };\n            if bit >= 64 {\n                num += 1;\n                bit -= 64;\n                if num >= 16 {\n                    self.run();\n                    self.buffer = [0; 16];\n                    num = 0;\n                }\n                if bit > 0 {\n                    self.buffer[num] |= add_data << (64 - bit);\n                }\n            }\n        }\n        self.buffer_size = (num as u32 * 64 + bit) as u16;\n        if rem == 0 || rem == 8 {\n            self.msg_length.add_msg_len(data.len(), 0)\n        } else {\n            self.msg_length.add_msg_len(data.len() - 1, rem)\n        }\n    }\n    fn finish(mut self: Box<Self>) -> Box<[u8]> {\n        // add padding\n        let idx = (self.buffer_size / 64) as usize;\n        let shift = 63 - self.buffer_size % 64;\n        self.buffer[idx] |= 0x1 << shift;\n        if idx >= 14 {\n            self.run();\n            self.buffer = [0; 16];\n            self.buffer_size = 0;\n        }\n        self.buffer[14] = self.msg_length.upper;\n        self.buffer[15] = self.msg_length.lower;\n        self.run();\n\n        // create hash\n        let mut result: Vec<u8> = Vec::with_capacity(self.length as usize / 8);\n        let mut length = 0;\n        'outer: for x in self.state.iter() {\n            let array = change_u64_to_array_u8(*x);\n            for byte in array.iter() {\n                result.push(*byte);\n                length += 8;\n                if length == self.length {\n                    break 'outer;\n                }\n            }\n        }\n        result.into_boxed_slice()\n    }\n}\n\npub enum Sha2HashType {\n    /// SHA 224\n    Len224,\n    /// SHA 256\n    Len256,\n    /// SHA 384\n    Len384,\n    /// SHA 512\n    Len512,\n    /// SHA 512/224\n    Len224By512,\n    /// SHA 512/256\n    Len256By512\n}\n\npub struct Sha2 {\n    data: Box<Sha2DataRunner>\n}\nimpl Sha2 {\n    pub fn new(hash_type: Sha2HashType) -> Self {\n        let data: Box<Sha2DataRunner> = match hash_type {\n            Sha2HashType::Len224 => Box::new(Sha256::new(\n                Sha256DigestSize::Len224\n            )),\n            Sha2HashType::Len256 => Box::new(Sha256::new(\n                Sha256DigestSize::Len256\n            )),\n            Sha2HashType::Len384 => Box::new(Sha512::new(\n                Sha512DigestSize::Len384\n            )),\n            Sha2HashType::Len512 => Box::new(Sha512::new(\n                Sha512DigestSize::Len512\n            )),\n            Sha2HashType::Len224By512 => Box::new(Sha512::new(\n                Sha512DigestSize::Len224\n            )),\n            Sha2HashType::Len256By512 => Box::new(Sha512::new(\n                Sha512DigestSize::Len256\n            ))\n        };\n        Sha2 {\n            data: data\n        }\n    }\n    pub fn push(&mut self, data: &[u8], rem: u8) -> Result<(), ()> {\n        self.data.update(data, rem)\n    }\n    pub fn finish(self) -> Box<[u8]> {\n        self.data.finish()\n    }\n}\n\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    /// \u7a7a\u306e\u30e1\u30c3\u30bb\u30fc\u30b8 \"\" \u306b\u5bfe\u3057 SHA-224 \u3092\u53d6\u308b\n    #[test]\n    fn sha2_224_hash_by_empty_msg() {\n        let sha2 = Sha2::new(Sha2HashType::Len224);\n        let hash = sha2.finish();\n        assert_eq!(hash, vec![\n            0xd1, 0x4a, 0x02, 0x8c, 0x2a, 0x3a, 0x2b, 0xc9,\n            0x47, 0x61, 0x02, 0xbb, 0x28, 0x82, 0x34, 0xc4,\n            0x15, 0xa2, 0xb0, 0x1f, 0x82, 0x8e, 0xa6, 0x2a,\n            0xc5, 0xb3, 0xe4, 0x2f\n        ].into_boxed_slice());\n    }\n    /// \u30e1\u30c3\u30bb\u30fc\u30b8 \"abc\" \u306b\u5bfe\u3057 SHA-224 \u3092\u53d6\u308b\n    #[test]\n    fn sha2_224_hash_by_abc_msg() {\n        let mut sha2 = Sha2::new(Sha2HashType::Len224);\n        sha2.push(b\"abc\".as_ref(), 8).unwrap();\n        let hash = sha2.finish();\n        assert_eq!(hash, vec![\n            0x23, 0x09, 0x7d, 0x22, 0x34, 0x05, 0xd8, 0x22,\n            0x86, 0x42, 0xa4, 0x77, 0xbd, 0xa2, 0x55, 0xb3,\n            0x2a, 0xad, 0xbc, 0xe4, 0xbd, 0xa0, 0xb3, 0xf7,\n            0xe3, 0x6c, 0x9d, 0xa7\n        ].into_boxed_slice());\n    }\n    /// \u7a7a\u306e\u30e1\u30c3\u30bb\u30fc\u30b8 \"\" \u306b\u5bfe\u3057 SHA-256 \u3092\u53d6\u308b\n    #[test]\n    fn sha2_256_hash_by_empty_msg() {\n        let sha2 = Sha2::new(Sha2HashType::Len256);\n        let hash = sha2.finish();\n        assert_eq!(hash, vec![\n            0xe3, 0xb0, 0xc4, 0x42, 0x98, 0xfc, 0x1c, 0x14,\n            0x9a, 0xfb, 0xf4, 0xc8, 0x99, 0x6f, 0xb9, 0x24,\n            0x27, 0xae, 0x41, 0xe4, 0x64, 0x9b, 0x93, 0x4c,\n            0xa4, 0x95, 0x99, 0x1b, 0x78, 0x52, 0xb8, 0x55\n        ].into_boxed_slice());\n    }\n    /// \u30e1\u30c3\u30bb\u30fc\u30b8 \"abc\" \u306b\u5bfe\u3057 SHA-256 \u3092\u53d6\u308b\n    #[test]\n    fn sha2_256_hash_by_abc_msg() {\n        let mut sha2 = Sha2::new(Sha2HashType::Len256);\n        sha2.push(b\"abc\".as_ref(), 8).unwrap();\n        let hash = sha2.finish();\n        assert_eq!(hash, vec![\n            0xba, 0x78, 0x16, 0xbf, 0x8f, 0x01, 0xcf, 0xea,\n            0x41, 0x41, 0x40, 0xde, 0x5d, 0xae, 0x22, 0x23,\n            0xb0, 0x03, 0x61, 0xa3, 0x96, 0x17, 0x7a, 0x9c,\n            0xb4, 0x10, 0xff, 0x61, 0xf2, 0x00, 0x15, 0xad\n        ].into_boxed_slice());\n    }\n    /// 447 bits \u306e 0 \u3067\u69cb\u6210\u3055\u308c\u305f\u30e1\u30c3\u30bb\u30fc\u30b8\u306b\u5bfe\u3057 SHA-256 \u3092\u53d6\u308b\n    #[test]\n    fn sha2_256_hash_by_447_zero_bits() {\n        let mut sha2 = Sha2::new(Sha2HashType::Len256);\n        sha2.push(&vec![\n            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        ], 7).unwrap();\n        let hash = sha2.finish();\n        assert_eq!(hash, vec![\n            0x43, 0xfd, 0xd2, 0xee, 0xd4, 0xdf, 0x6d, 0x2c,\n            0x38, 0xe9, 0x71, 0xda, 0x88, 0x41, 0x15, 0x05,\n            0x19, 0x51, 0xaa, 0x68, 0xd8, 0x92, 0x72, 0x0f,\n            0x79, 0x68, 0x9d, 0x49, 0x62, 0xc9, 0xef, 0xae\n        ].into_boxed_slice());\n    }\n    /// 448 bits \u306e 0 \u3067\u69cb\u6210\u3055\u308c\u305f\u30e1\u30c3\u30bb\u30fc\u30b8\u306b\u5bfe\u3057 SHA-256 \u3092\u53d6\u308b\n    #[test]\n    fn sha2_256_hash_by_448_zero_bits() {\n        let mut sha2 = Sha2::new(Sha2HashType::Len256);\n        sha2.push(&vec![\n            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        ], 8).unwrap();\n        let hash = sha2.finish();\n        assert_eq!(hash, vec![\n            0xd4, 0x81, 0x7a, 0xa5, 0x49, 0x76, 0x28, 0xe7,\n            0xc7, 0x7e, 0x6b, 0x60, 0x61, 0x07, 0x04, 0x2b,\n            0xbb, 0xa3, 0x13, 0x08, 0x88, 0xc5, 0xf4, 0x7a,\n            0x37, 0x5e, 0x61, 0x79, 0xbe, 0x78, 0x9f, 0xbb\n        ].into_boxed_slice());\n    }\n    /// 448 bits \u306e 0 \u3067\u69cb\u6210\u3055\u308c\u305f\u30e1\u30c3\u30bb\u30fc\u30b8\u306b\u5bfe\u3057 SHA-256 \u3092\u53d6\u308b\n    #[test]\n    fn sha2_256_hash_by_448_bits_ascii_msg() {\n        let mut sha2 = Sha2::new(Sha2HashType::Len256);\n        sha2.push(b\"abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq\".as_ref(), 8).unwrap();\n        let hash = sha2.finish();\n        assert_eq!(hash, vec![\n            0x24, 0x8d, 0x6a, 0x61, 0xd2, 0x06, 0x38, 0xb8,\n            0xe5, 0xc0, 0x26, 0x93, 0x0c, 0x3e, 0x60, 0x39,\n            0xa3, 0x3c, 0xe4, 0x59, 0x64, 0xff, 0x21, 0x67,\n            0xf6, 0xec, 0xed, 0xd4, 0x19, 0xdb, 0x06, 0xc1\n        ].into_boxed_slice());\n    }\n\n    /// \u7a7a\u306e\u30e1\u30c3\u30bb\u30fc\u30b8 \"\" \u306b\u5bfe\u3057 SHA521/224 \u3092\u53d6\u308b\n    #[test]\n    fn sha2_224_by_512_hash_by_empty_msg() {\n        let sha2 = Sha2::new(Sha2HashType::Len224By512);\n        let hash = sha2.finish();\n        assert_eq!(hash, vec![\n            0x6e, 0xd0, 0xdd, 0x02, 0x80, 0x6f, 0xa8, 0x9e,\n            0x25, 0xde, 0x06, 0x0c, 0x19, 0xd3, 0xac, 0x86,\n            0xca, 0xbb, 0x87, 0xd6, 0xa0, 0xdd, 0xd0, 0x5c,\n            0x33, 0x3b, 0x84, 0xf4\n        ].into_boxed_slice());\n    }\n    /// \u7a7a\u306e\u30e1\u30c3\u30bb\u30fc\u30b8 \"\" \u306b\u5bfe\u3057 SHA521/256 \u3092\u53d6\u308b\n    #[test]\n    fn sha2_256_by_512_hash_by_empty_msg() {\n        let sha2 = Sha2::new(Sha2HashType::Len256By512);\n        let hash = sha2.finish();\n        assert_eq!(hash, vec![\n            0xc6, 0x72, 0xb8, 0xd1, 0xef, 0x56, 0xed, 0x28,\n            0xab, 0x87, 0xc3, 0x62, 0x2c, 0x51, 0x14, 0x06,\n            0x9b, 0xdd, 0x3a, 0xd7, 0xb8, 0xf9, 0x73, 0x74,\n            0x98, 0xd0, 0xc0, 0x1e, 0xce, 0xf0, 0x96, 0x7a\n        ].into_boxed_slice());\n    }\n    /// \u7a7a\u306e\u30e1\u30c3\u30bb\u30fc\u30b8 \"\" \u306b\u5bfe\u3057 SHA384 \u3092\u53d6\u308b\n    #[test]\n    fn sha2_384_hash_by_empty_msg() {\n        let sha2 = Sha2::new(Sha2HashType::Len384);\n        let hash = sha2.finish();\n        assert_eq!(hash, vec![\n            0x38, 0xb0, 0x60, 0xa7, 0x51, 0xac, 0x96, 0x38,\n            0x4c, 0xd9, 0x32, 0x7e, 0xb1, 0xb1, 0xe3, 0x6a,\n            0x21, 0xfd, 0xb7, 0x11, 0x14, 0xbe, 0x07, 0x43,\n            0x4c, 0x0c, 0xc7, 0xbf, 0x63, 0xf6, 0xe1, 0xda,\n            0x27, 0x4e, 0xde, 0xbf, 0xe7, 0x6f, 0x65, 0xfb,\n            0xd5, 0x1a, 0xd2, 0xf1, 0x48, 0x98, 0xb9, 0x5b\n        ].into_boxed_slice());\n    }\n    /// \u30e1\u30c3\u30bb\u30fc\u30b8 \"abc\" \u306b\u5bfe\u3057 SHA384 \u3092\u53d6\u308b\n    #[test]\n    fn sha2_384_hash_by_abc_msg() {\n        let mut sha2 = Sha2::new(Sha2HashType::Len384);\n        sha2.push(b\"abc\".as_ref(), 8).unwrap();\n        let hash = sha2.finish();\n        assert_eq!(hash, vec![\n            0xcb, 0x00, 0x75, 0x3f, 0x45, 0xa3, 0x5e, 0x8b,\n            0xb5, 0xa0, 0x3d, 0x69, 0x9a, 0xc6, 0x50, 0x07,\n            0x27, 0x2c, 0x32, 0xab, 0x0e, 0xde, 0xd1, 0x63,\n            0x1a, 0x8b, 0x60, 0x5a, 0x43, 0xff, 0x5b, 0xed,\n            0x80, 0x86, 0x07, 0x2b, 0xa1, 0xe7, 0xcc, 0x23,\n            0x58, 0xba, 0xec, 0xa1, 0x34, 0xc8, 0x25, 0xa7\n        ].into_boxed_slice());\n    }\n    /// \u7a7a\u306e\u30e1\u30c3\u30bb\u30fc\u30b8 \"\" \u306b\u5bfe\u3057 SHA512 \u3092\u53d6\u308b\n    #[test]\n    fn sha2_512_hash_by_empty_msg() {\n        let sha2 = Sha2::new(Sha2HashType::Len512);\n        let hash = sha2.finish();\n        assert_eq!(hash, vec![\n            0xcf, 0x83, 0xe1, 0x35, 0x7e, 0xef, 0xb8, 0xbd,\n            0xf1, 0x54, 0x28, 0x50, 0xd6, 0x6d, 0x80, 0x07,\n            0xd6, 0x20, 0xe4, 0x05, 0x0b, 0x57, 0x15, 0xdc,\n            0x83, 0xf4, 0xa9, 0x21, 0xd3, 0x6c, 0xe9, 0xce,\n            0x47, 0xd0, 0xd1, 0x3c, 0x5d, 0x85, 0xf2, 0xb0,\n            0xff, 0x83, 0x18, 0xd2, 0x87, 0x7e, 0xec, 0x2f,\n            0x63, 0xb9, 0x31, 0xbd, 0x47, 0x41, 0x7a, 0x81,\n            0xa5, 0x38, 0x32, 0x7a, 0xf9, 0x27, 0xda, 0x3e\n        ].into_boxed_slice());\n    }\n    /// \u30e1\u30c3\u30bb\u30fc\u30b8 \"abc\" \u306b\u5bfe\u3057 SHA512 \u3092\u53d6\u308b\n    #[test]\n    fn sha2_512_hash_by_abc_msg() {\n        let mut sha2 = Sha2::new(Sha2HashType::Len512);\n        sha2.push(b\"abc\".as_ref(), 8).unwrap();\n        let hash = sha2.finish();\n        assert_eq!(hash, vec![\n            0xdd, 0xaf, 0x35, 0xa1, 0x93, 0x61, 0x7a, 0xba,\n            0xcc, 0x41, 0x73, 0x49, 0xae, 0x20, 0x41, 0x31,\n            0x12, 0xe6, 0xfa, 0x4e, 0x89, 0xa9, 0x7e, 0xa2,\n            0x0a, 0x9e, 0xee, 0xe6, 0x4b, 0x55, 0xd3, 0x9a,\n            0x21, 0x92, 0x99, 0x2a, 0x27, 0x4f, 0xc1, 0xa8,\n            0x36, 0xba, 0x3c, 0x23, 0xa3, 0xfe, 0xeb, 0xbd,\n            0x45, 0x4d, 0x44, 0x23, 0x64, 0x3c, 0xe8, 0x0e,\n            0x2a, 0x9a, 0xc9, 0x4f, 0xa5, 0x4c, 0xa4, 0x9f\n        ].into_boxed_slice());\n    }\n    /// 895 bit \u306e 0 \u3067\u69cb\u6210\u3055\u308c\u305f\u30e1\u30c3\u30bb\u30fc\u30b8\u306b\u5bfe\u3057 SHA512 \u3092\u53d6\u308b\uff08\u5883\u754c\u30c6\u30b9\u30c8\uff09\n    #[test]\n    fn sha2_512_hash_by_895_zero_bits() {\n        let mut sha2 = Sha2::new(Sha2HashType::Len512);\n        sha2.push(&vec![\n            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00\n        ], 7).unwrap();\n        let hash = sha2.finish();\n        assert_eq!(hash, vec![\n            0x12, 0xdd, 0x83, 0xc5, 0xb6, 0x54, 0x77, 0x58,\n            0x45, 0x2d, 0xc7, 0x02, 0x0e, 0xe3, 0x2f, 0x53,\n            0xf5, 0xa0, 0xeb, 0x65, 0xd3, 0x3c, 0x4d, 0x3f,\n            0xee, 0xbc, 0xe1, 0x7d, 0x71, 0x13, 0xdb, 0x14,\n            0x03, 0x93, 0xc8, 0xfb, 0xe4, 0x9f, 0xc0, 0x71,\n            0xe4, 0x0b, 0x58, 0x5d, 0xf9, 0x69, 0xc7, 0xaa,\n            0x3a, 0x81, 0x96, 0xce, 0x2b, 0x94, 0xe8, 0x3e,\n            0x79, 0x41, 0xec, 0x05, 0xe2, 0x01, 0x87, 0x51\n        ].into_boxed_slice());\n    }\n    /// 896 bit \u306e 0 \u3067\u69cb\u6210\u3055\u308c\u305f\u30e1\u30c3\u30bb\u30fc\u30b8\u306b\u5bfe\u3057 SHA512 \u3092\u53d6\u308b\uff08\u5883\u754c\u30c6\u30b9\u30c8\uff09\n    #[test]\n    fn sha2_512_hash_by_896_zero_bits() {\n        let mut sha2 = Sha2::new(Sha2HashType::Len512);\n        sha2.push(&vec![\n            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00\n        ], 8).unwrap();\n        let hash = sha2.finish();\n        assert_eq!(hash, vec![\n            0x2b, 0xe2, 0xe7, 0x88, 0xc8, 0xa8, 0xad, 0xea,\n            0xa9, 0xc8, 0x9a, 0x7f, 0x78, 0x90, 0x4c, 0xac,\n            0xea, 0x6e, 0x39, 0x29, 0x7d, 0x75, 0xe0, 0x57,\n            0x3a, 0x73, 0xc7, 0x56, 0x23, 0x45, 0x34, 0xd6,\n            0x62, 0x7a, 0xb4, 0x15, 0x6b, 0x48, 0xa6, 0x65,\n            0x7b, 0x29, 0xab, 0x8b, 0xeb, 0x73, 0x33, 0x40,\n            0x40, 0xad, 0x39, 0xea, 0xd8, 0x14, 0x46, 0xbb,\n            0x09, 0xc7, 0x07, 0x04, 0xec, 0x70, 0x79, 0x52\n        ].into_boxed_slice());\n    }\n    /// 896 bit \u306e 0 \u3067\u69cb\u6210\u3055\u308c\u305f\u30e1\u30c3\u30bb\u30fc\u30b8\u306b\u5bfe\u3057 SHA512 \u3092\u53d6\u308b\uff08\u5883\u754c\u30c6\u30b9\u30c8\uff09\n    #[test]\n    fn sha2_512_hash_by_896_bits_ascii_msg() {\n        let mut sha2 = Sha2::new(Sha2HashType::Len512);\n        sha2.push(b\"abcdefghbcdefghicdefghijdefghijkefghijklfghijklmghijklmnhijklmnoijklmnopjklmnopqklmnopqrlmnopqrsmnopqrstnopqrstu\".as_ref(), 8).unwrap();\n        let hash = sha2.finish();\n        assert_eq!(hash, vec![\n            0x8e, 0x95, 0x9b, 0x75, 0xda, 0xe3, 0x13, 0xda,\n            0x8c, 0xf4, 0xf7, 0x28, 0x14, 0xfc, 0x14, 0x3f,\n            0x8f, 0x77, 0x79, 0xc6, 0xeb, 0x9f, 0x7f, 0xa1,\n            0x72, 0x99, 0xae, 0xad, 0xb6, 0x88, 0x90, 0x18,\n            0x50, 0x1d, 0x28, 0x9e, 0x49, 0x00, 0xf7, 0xe4,\n            0x33, 0x1b, 0x99, 0xde, 0xc4, 0xb5, 0x43, 0x3a,\n            0xc7, 0xd3, 0x29, 0xee, 0xb6, 0xdd, 0x26, 0x54,\n            0x5e, 0x96, 0xe5, 0x5b, 0x87, 0x4b, 0xe9, 0x09\n        ].into_boxed_slice());\n    }\n}\n\n\n\n\u53c2\u8003\u6587\u732e\n\nFIPS 180-4 \u226ahttp://csrc.nist.gov/publications/fips/fips180-4/fips-180-4.pdf\u226b\nSHA-2 - Wikipedia \u226ahttps://ja.wikipedia.org/wiki/SHA-2\u226b\nSHA-2\u3068\u306f\uff5cSecure Hash Algorighm 2 \uff0d \u610f\u5473 / \u5b9a\u7fa9 / \u89e3\u8aac / \u8aac\u660e \uff1a IT\u7528\u8a9e\u8f9e\u5178 \u226ahttp://e-words.jp/w/SHA-2.html\u226b\nwiz.code [ \u30d1\u30c7\u30a3\u30f3\u30b0\u51e6\u7406 ] \u226ahttp://wiz.area.ac/techcode/sha256/page04.aspx\u226b\nTest vectors for SHA-1, SHA-2 and SHA-3 \u226ahttp://www.di-mgt.com.au/sha_testvectors.html\u226b\nhttps://www.cosic.esat.kuleuven.be/nessie/testvectors/hash/sha/Sha-2-512.unverified.test-vectors\n\n#\u306f\u3058\u3081\u306b\n\u3075\u3068\u601d\u3044\u7acb\u3063\u3066 SHA-2 \u3092\u5b9f\u88c5\u3057\u305f\u306e\u3067\u3001\u4ed5\u69d8\u306e\u30e1\u30e2\u66f8\u304d\u3068\u5171\u306b\u516c\u958b\u3057\u3066\u307f\u308b\u3002\n\u6210\u679c\u7269\u306f [GitHub-Gist \u306e\u300e Rust \u3067 SHA-2 \u3092\u5b9f\u88c5\u3057\u3066\u307f\u305f\u300f](https://gist.github.com/mhgp/53f56a5a5468dc94669e70c998e51098) \u306b\u304a\u3044\u3066\u3042\u308b\u3002\n\n#SHA-2 \u3068\u306f\nSHA-2 \u306f\u3001\u6539\u7ac4\u3055\u308c\u3066\u306a\u3044\u304b\u30c1\u30a7\u30c3\u30af\u3059\u308b\u306e\u306b\u9069\u3057\u305f\u30cf\u30c3\u30b7\u30e5\u95a2\u6570\uff08\u6697\u53f7\u5b66\u7684\u30cf\u30c3\u30b7\u30e5\u95a2\u6570\uff09\u306e\u6a19\u6e96\u898f\u683c\u306e\u4e00\u3064\u3002 NSA \uff08\u30a2\u30e1\u30ea\u30ab\u56fd\u5bb6\u5b89\u5168\u4fdd\u969c\u5c40\uff09\u304c\u8003\u6848\u3057\u3001 2001 \u5e74\u306b NIST \uff08\u30a2\u30e1\u30ea\u30ab\u56fd\u6a19\u6e96\u6280\u8853\u5c40\uff09\u306b\u3088\u3063\u3066\u9023\u90a6\u60c5\u5831\u51e6\u7406\u6a19\u6e96\u306e\u4e00\u3064\uff08 FIPS 180-4 \uff09\u3068\u3057\u3066\u6a19\u6e96\u5316\u3055\u308c\u305f\u3002 SHA-224 \u3001 SHA-256 \u3001 SHA-384 \u3001 SHA-512 \u3001 SHA-512/224 \u3001 SHA-512/256 \u306e 6 \u3064\u306e\u30d0\u30ea\u30a8\u30fc\u30b7\u30e7\u30f3\u304b\u3089\u306a\u308a\u3001\u305d\u308c\u305e\u308c\u306e\u672b\u5c3e\u306e\u6570\u5b57\u304c\u30cf\u30c3\u30b7\u30e5\u9577\uff08\u5358\u4f4d\u306f bit \uff09\u3092\u8868\u3057\u3066\u3044\u308b\uff08\u3064\u307e\u308a\u3001\u30cf\u30c3\u30b7\u30e5\u9577\u306f 224 \u3001 256 \u3001 384 \u3001 512 bit \u306e 4 \u3064\uff09\u3002 SHA \u306f \" Secure Hash Algorithm \" \u306e\u7565\u3067\u3042\u308b\u3002\n\n\n#\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0\nSHA-2 \u306f SHA-256 \u3092\u5207\u308a\u8a70\u3081\u305f\u3082\u306e\uff08\u4ee5\u964d\u3001 SHA-256 \u7cfb\uff09\u3068 SHA-512 \u3092\u5207\u308a\u8a70\u3081\u305f\u3082\u306e\uff08\u4ee5\u964d\u3001 SHA-512 \u7cfb\uff09\u306e 2 \u3064\u306b\u5927\u5225\u3067\u304d\u308b\u3002\u4ee5\u4e0b\u306f\u305d\u308c\u305e\u308c\u304c\u3069\u3061\u3089\u306b\u90e8\u985e\u51fa\u6765\u308b\u304b\u3092\u793a\u3057\u305f\u3082\u306e\u3067\u3042\u308b\u3002\n\n<table>\n<thead>\n    <tr><th>\u90e8\u985e</th><th>\u30d0\u30ea\u30a8\u30fc\u30b7\u30e7\u30f3\u540d</th></tr>\n</thead>\n<tbody>\n    <tr><th rowspan=\"2\">SHA-256 \u7cfb</td><td>SHA-224</td></tr>\n    <tr><td>SHA-256</td></tr>\n    <tr><th rowspan=\"4\">SHA-512 \u7cfb</td><td>SHA-384</td></tr>\n    <tr><td>SHA-51</td></tr>\n    <tr><td>SHA-512/224</td></tr>\n    <tr><td>SHA-512/256</td></tr>\n</tbody>\n</table>\n\nSHA-256 \u7cfb\u3068 SHA-512 \u7cfb\u306e\u30ef\u30fc\u30c9\u9577\u3068\u30e9\u30a6\u30f3\u30c9\u6570\u306e\u9055\u3044\u306f\u6b21\u306e\u8868\u306b\u793a\u3059\u901a\u308a\u3002\n\n|\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0|\u30ef\u30fc\u30c9\u9577|\u30e9\u30a6\u30f3\u30c9\u6570|\n|---|---|---|\n|SHA-256|32|64|\n|SHA-512|64|80|\n\n\u305d\u306e\u307b\u304b\u306b\u3082\u30b7\u30d5\u30c8\u91cf\u3084\u3001\u8ffd\u52a0\u5b9a\u6570\u306a\u3069\u3082\u9055\u3046\u304c\u3001\u672c\u8cea\u7684\u306a\u69cb\u9020\u306f\u3044\u305a\u308c\u3082\u540c\u3058\u3067\u3042\u308b\u3002\n\n\n##\u6570\u5f0f\u306e\u8a18\u53f7\u3068\u30d7\u30ed\u30b0\u30e9\u30e0\u306e\u5bfe\u5fdc\n<dl>\n  <dt>$x + y$</dt>\n  <dd><code>x.wrapping_add(y)</code></dd>\n  <dt>$x \\oplus y$</dt>\n  <dd><code>x ^ y</code></dd>\n  <dt>$x \\wedge y$</dt>\n  <dd><code>x & y</code></dd>\n  <dt>$\\lnot x$</dt>\n  <dd><code>!x</code></dd>\n  <dt>${\\it ROTR}^{\\,y}(x)$</dt>\n  <dd><code>x.rotate_right(y)</code></dd>\n  <dt>${\\it SHR}^{\\,y}(x)$</dt>\n  <dd><code>x >> y</code></dd>\n</dl>\n\n\n##SHA-2 \u306e\u69cb\u9020\n\n\u30e1\u30c3\u30bb\u30fc\u30b8\uff08\u30cf\u30c3\u30b7\u30e5\u3092\u4f5c\u308a\u305f\u3044\u30c7\u30fc\u30bf\uff09\u3092 $M_{\\rm in}$ \u3001\u30e1\u30c3\u30bb\u30fc\u30b8\u9577\u3092 $l$ \u3068\u3057\u305f\u3068\u304d\u3001 SHA-2 \u306e\u3059\u3079\u3066\u306e\u30d0\u30ea\u30a8\u30fc\u30b7\u30e7\u30f3\u306f\u3001\u4ee5\u4e0b\u306e\u69cb\u9020\u3092\u6301\u3064\u3002\n\n\u3053\u306e\u3046\u3061\u3001\u3059\u3079\u3066\u306e\u30d0\u30ea\u30a8\u30fc\u30b7\u30e7\u30f3\u3067\u7570\u306a\u308b\u306e\u306f\u521d\u671f\u5024 $H^{(0)}$ \u3067\u3042\u308b\u3002\n\u307e\u305f\u3001 SHA-256 \u7cfb \u3068 SHA-512 \u7cfb \u3067\u7570\u306a\u308b\u306e\u306f\u3001\u30ef\u30fc\u30c9\u9577 $w_{\\rm len}$ \u3001 \u30e9\u30a6\u30f3\u30c9\u6570 $n_{\\rm rnd}$ \u3001\u8ffd\u52a0\u5b9a\u6570 $K_t$ \u304a\u3088\u3073 $\\Sigma_0(x)$, $\\Sigma_1(x)$, $\\sigma_0(x)$, $\\sigma_1(x)$ \u306e 4 \u3064\u306e\u95a2\u6570\u3067\u3042\u308b\u3002\n\n1. $M_{\\rm in}$ \u306b\u30d1\u30c7\u30a3\u30f3\u30b0\u3092\u8ffd\u52a0\u3059\u308b\u3002\u3053\u308c\u3092 $M$ \u3068\u3059\u308b\u3002\u8a73\u7d30\u306f\u500b\u5225\u306b\u8a18\u8f09\uff08 [SHA-256 \u7cfb\u306e\u5834\u5408](#SHA-224 \u304a\u3088\u3073 SHA-256)\u3068\u3001 [SHA-512 \u7cfb\u306e\u5834\u5408](#SHA-384 \u304a\u3088\u3073 SHA-512\uff0cSHA-512/224\uff0cSHA-512/256)\uff09\u3059\u308b\u304c\u5927\u307e\u304b\u306b\u306f\u6b21\u306e\u901a\u308a\u3002\n\n    ```math\n    M=\\underbrace{\\overbrace{\\underbrace{01100001}_{\\rm ``{\\bf a}\u201d}\\quad\\underbrace{01100010}_{\\rm ``{\\bf b}\u201d}\\quad\\dots\\quad\\underbrace{01100011}_{\\rm ``{\\bf c}\u201d}}^{l\\,{\\rm bits}}}_{{\\rm Massage\\,(}M_{\\rm in}{\\rm )}}\\quad\\underbrace{1\\quad\\overbrace{00\\dots0}^{k\\,{\\rm zero\\,bits}}\\quad\\overbrace{00\\dots0\\underbrace{110\\dots00}_{l}}^{2w_{\\rm len}\\,{\\rm bits}}}_{\\rm Padding}\n    ```\n\n    1.  $M$ \u306e\u672b\u5c3e\u306b \"1\" \u3092\u8ffd\u52a0\u3002\n    2.  $l+1+k \\equiv 14 w_{\\rm len} \\bmod 16 w_{\\rm len}$ \u306b\u3088\u3063\u3066\u6c42\u3081\u3089\u308c\u308b $k$ \u30d3\u30c3\u30c8\u306e \"0\" \u3092\u8ffd\u52a0\u3002\n    3.  $2 w_{\\rm len}$ \u30d3\u30c3\u30c8\u3067 0 \u57cb\u3081\u3057\u305f $l$ \u3092\u8ffd\u52a0\u3002\n\n2. \u30d1\u30c7\u30a3\u30f3\u30b0\u3092\u8ffd\u52a0\u3057\u305f\u30e1\u30c3\u30bb\u30fc\u30b8\u3092\u30ef\u30fc\u30c9\u9577\u306e 16 \u500d\u3067\u5206\u5272\u3057\u305f\u30d9\u30af\u30c8\u30eb\u306b\u3059\u308b\u3002\u3053\u306e\u5206\u5272\u3057\u305f\u5358\u4f4d\u3092\u30d6\u30ed\u30c3\u30af\u3068\u547c\u3076\u3002\u5206\u5272\u3057\u3066\u5f97\u3089\u308c\u305f $N$ \u500b\u306e\u30d6\u30ed\u30c3\u30af\u3092 $M^{(1)},\\,M^{(2)},\\,\\dots,\\,M^{(N)}$ \u3068\u3059\u308b\u3002\n3. \u30d6\u30ed\u30c3\u30af $M^{(i)}\\,(1 \\leq i \\leq N)$ \u3092 1 \u304b\u3089 $N$ \u306e\u9806\u306b\u5727\u7e2e\u95a2\u6570\u3078\u4ee3\u5165\u3059\u308b\u3002\u5727\u7e2e\u95a2\u6570\u306f\u30d6\u30ed\u30c3\u30af $M^{(i)}$ \u3068\u5185\u90e8\u72b6\u614b $H^{(i-1)}$ \u306e 2 \u3064\u3092\u5f15\u6570\u3068\u3057\u3001 $H^{(i)}$ \u3092\u623b\u308a\u5024\u3068\u3059\u308b\u95a2\u6570\u3067\u3042\u308b\u3002\u307e\u305f $H^{(0)}$ \u306f\u521d\u671f\u5024\u3067\u3042\u308b\u3002\n    1. $M^{(i)}$ \u3092 16 \u5206\u5272\u3057\u305f\u30d9\u30af\u30c8\u30eb\u306b\u3059\u308b\u3002\u3053\u308c\u3092 $M_{0}^{(i)}, \\, M_{1}^{(i)},\\dots,\\,M_{15}^{(i)}$ \u3068\u8868\u3059\u3002\u306a\u304a $M_{x}^{(i)}$ \u306f $w_{\\rm len}$ \u306e\u9577\u3055\u3092\u6301\u3064\u30d3\u30c3\u30c8\u5217\u3067\u3042\u308b\u3002\n    2. \u540c\u69d8\u306b $H^{(i)}$ \u3092 16 \u5206\u5272\u3057\u305f\u30d9\u30af\u30c8\u30eb\u306b\u3059\u308b\u3002\u3053\u308c\u3092 $H_{0}^{(i)}, \\, H_{1}^{(i)},\\dots,\\,H_{15}^{(i)}$ \u3068\u8868\u3059\u3002\u540c\u3058\u304f $H_{x}^{(i)}$ \u306f $w_{\\rm len}$ \u306e\u9577\u3055\u3092\u6301\u3064\u30d3\u30c3\u30c8\u5217\u3067\u3042\u308b\u3002\n    3. \u30e1\u30c3\u30bb\u30fc\u30b8\u30b9\u30b1\u30b8\u30e5\u30fc\u30eb $W_t$ \u3092\u6e96\u5099\u3059\u308b\u3002\u30e9\u30a6\u30f3\u30c9\u6570\u3092 $n_{\\rm rnd}$ \u3068\u3059\u308b\u3002\n\n        ```math\n{W_t = \\left\\{\n\\begin{array}{ll}\nM_t^{(i)} & (0 \\leq t \\leq 15)\\\\\n\\sigma_1(W_{t-2})+W_{t-7}+\\sigma_0(W_{t-15})+W_{t-16} & (16 \\leq t \\leq (n_{\\rm rnd} - 1))\n\\end{array}\n\\right.\n}\n        ```\n\n        $\\sigma_0(x)$ \u3068 $\\sigma_1(x)$ \u306f\u3001 SHA-256 \u7cfb\u3068 SHA-512 \u7cfb\u3067\u7570\u306a\u308b\u3002\n\n    4. $H_{0}^{(i)}, \\, H_{1}^{(i)},\\dots,\\,H_{15}^{(i)}$ \u3092 $a, \\, b,\\dots,\\,h$ \u306b\u4ee3\u5165\u3059\u308b\u3002\n\n        ```math\n\\begin{align}\na&=H_0^{(i-1)}\\\\\nb&=H_1^{(i-1)}\\\\\nc&=H_2^{(i-1)}\\\\\nd&=H_3^{(i-1)}\\\\\ne&=H_4^{(i-1)}\\\\\nf&=H_5^{(i-1)}\\\\\ng&=H_6^{(i-1)}\\\\\nh&=H_7^{(i-1)}\n\\end{align}\n        ```\n\n    5. $t$ \u3092 0 \u304b\u3089 $n_{\\rm rnd} - 1$ \u307e\u3067\u7e70\u308a\u8fd4\u3057\u3001\u4ee5\u4e0b\u3092\u5b9f\u884c\u3059\u308b\u3002$K_t$ \u306f\u8ffd\u52a0\u5b9a\u6570\u3002 \n\n        ```math\n\\begin{align}\nT_1&=h+\\Sigma_1(e)+{\\it Ch}(e,f,g)+K_t+W_t\\\\\nT_2&=\\Sigma_0(a)+{\\it Maj}(a,b,c)\\\\\nh&=g\\\\\ng&=f\\\\\nf&=e\\\\\ne&=d+T_1\\\\\nd&=c\\\\\nc&=b\\\\\nb&=a\\\\\na&=T_1+T_2\n\\end{align}\n        ```\n\n        $K_t$, $\\Sigma_1(x)$, $\\Sigma_0(x)$ \u306f\u3001 SHA-256 \u7cfb\u3068 SHA-512 \u7cfb\u3067\u7570\u306a\u308b\u3002 \n\n    5. \u5727\u7e2e\u95a2\u6570\u306e\u623b\u308a\u5024\u3002\n\n        ```math\n\\begin{align}\nH_0^{(i)}&=a+H_0^{(i-1)}\\\\\nH_1^{(i)}&=b+H_1^{(i-1)}\\\\\nH_2^{(i)}&=c+H_2^{(i-1)}\\\\\nH_3^{(i)}&=d+H_3^{(i-1)}\\\\\nH_4^{(i)}&=e+H_4^{(i-1)}\\\\\nH_5^{(i)}&=f+H_5^{(i-1)}\\\\\nH_6^{(i)}&=g+H_6^{(i-1)}\\\\\nH_7^{(i)}&=h+H_7^{(i-1)}\\\\\n\\end{align}\n        ```\n\n4. $H_x^{(i)}$ \u3092\u30cf\u30c3\u30b7\u30e5\u9577\u306e\u9577\u3055\u306b\u306a\u308b\u307e\u3067\u7d50\u5408\u3059\u308b\uff08 $H^{(i)}$ \u3092\u30cf\u30c3\u30b7\u30e5\u9577\u306e\u9577\u3055\u306b\u5207\u308a\u8a70\u3081\u308b\uff09\u3002\n\n\n##SHA-256 \u3068 SHA-512 \u5171\u901a\u3067\u4f7f\u3046\u95a2\u6570\n\n```math\n\\begin{align}\n{\\it Ch}(x,y,z) &= (x\\wedge y)\\oplus(\\lnot x\\wedge z)\\tag{1}\\\\\n{\\it Maj}(x,y,z) &= (x\\wedge y)\\oplus(x\\wedge z)\\oplus(y\\wedge z)\\tag{2}\n\\end{align}\n```\n\n\u4e0b\u8a18\u306f\u5b9f\u88c5\u3002 SHA-256 \u3068 SHA-512 \u3067\u306f\u30e9\u30a6\u30f3\u30c9\u6570\u304c\u7570\u306a\u308b\u306e\u3067\u3001\u30de\u30af\u30ed\u3092\u4f7f\u7528\u3057\u3066\u3044\u308b\u3002\n\n```rust\nmacro_rules! Ch {\n    ($x:expr, $y:expr, $z:expr) => { ($x & $y) ^ (!$x & $z) };\n}\nmacro_rules! Maj {\n    ($x:expr, $y:expr, $z:expr) => { ($x & $y) ^ ($x & $z) ^ ($y & $z) };\n}\n```\n\n\n##SHA-224 \u304a\u3088\u3073 SHA-256\n\nSHA-256 \u7cfb\u306e\u8aac\u660e\u3002\n\n###\u5b9a\u6570\n\n\u8ffd\u52a0\u5b9a\u6570 $K^{\\\\{256\\\\}}$\n\n```\n428a2f98 71374491 b5c0fbcf e9b5dba5 3956c25b 59f111f1 923f82a4 ab1c5ed5\nd807aa98 12835b01 243185be 550c7dc3 72be5d74 80deb1fe 9bdc06a7 c19bf174\ne49b69c1 efbe4786 0fc19dc6 240ca1cc 2de92c6f 4a7484aa 5cb0a9dc 76f988da\n983e5152 a831c66d b00327c8 bf597fc7 c6e00bf3 d5a79147 06ca6351 14292967\n27b70a85 2e1b2138 4d2c6dfc 53380d13 650a7354 766a0abb 81c2c92e 92722c85\na2bfe8a1 a81a664b c24b8b70 c76c51a3 d192e819 d6990624 f40e3585 106aa070\n19a4c116 1e376c08 2748774c 34b0bcb5 391c0cb3 4ed8aa4a 5b9cca4f 682e6ff3\n748f82ee 78a5636f 84c87814 8cc70208 90befffa a4506ceb bef9a3f7 c67178f2\n```\n\n```rust\nconst K256: [u32; 64] = [\n    0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5,\n    0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n    0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3,\n    0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n    0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc,\n    0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n    0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7,\n    0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n    0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13,\n    0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n    0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3,\n    0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n    0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5,\n    0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n    0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208,\n    0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2\n];\n```\n\n\u30fbSHA-224 \u306e\u521d\u671f\u5024 $H^{(0)}$ \uff08\u5024\u306f 16 \u9032\u8868\u8a18\uff09\n\n```math\n\\begin{align}\nH^{(0)}_0&={\\tt c1059ed8}\\\\\nH^{(0)}_1&={\\tt 367cd507}\\\\\nH^{(0)}_2&={\\tt 3070dd17}\\\\\nH^{(0)}_3&={\\tt f70e5939}\\\\\nH^{(0)}_4&={\\tt ffc00b31}\\\\\nH^{(0)}_5&={\\tt 68581511}\\\\\nH^{(0)}_6&={\\tt 64f98fa7}\\\\\nH^{(0)}_7&={\\tt befa4fa4}\\\\\n\\end{align}\n```\n\n\u30fbSHA-256 \u306e\u521d\u671f\u5024 $H^{(0)}$ \uff08\u5024\u306f 16 \u9032\u8868\u8a18\uff09\n\n```math\n\\begin{align}\nH^{(0)}_0&={\\tt 6a09e667}\\\\\nH^{(0)}_1&={\\tt bb67ae85}\\\\\nH^{(0)}_2&={\\tt 3c6ef372}\\\\\nH^{(0)}_3&={\\tt a54ff53a}\\\\\nH^{(0)}_4&={\\tt 510e527f}\\\\\nH^{(0)}_5&={\\tt 9b05688c}\\\\\nH^{(0)}_6&={\\tt 1f83d9ab}\\\\\nH^{(0)}_7&={\\tt 5be0cd19}\\\\\n\\end{align}\n```\n\n\n##\u30d1\u30c7\u30a3\u30f3\u30b0\n\n$M_{\\rm in}$ \u304c ASCII \u30b3\u30fc\u30c9\u306e \"abc\" \u3067\u3042\u308b\u5834\u5408\u3092\u8003\u3048\u308b\u3002\u5404\u6587\u5b57\u306f 8 bit \u306a\u306e\u3067\u3001\u30e1\u30c3\u30bb\u30fc\u30b8\u306e\u9577\u3055 $l$ \u306f 24 \u3067\u3042\u308b\u3002\n\n```math\nM_{\\rm in} = \\overbrace{\\underbrace{01100001}_{\\rm ``{\\bf a}\u201d}\\quad\\underbrace{01100010}_{\\rm ``{\\bf b}\u201d}\\quad\\underbrace{01100011}_{\\rm ``{\\bf c}\u201d}}^{8 + 8 + 8 = 24 = l\\,{\\rm bits}}\n```\n\n\u30d1\u30c7\u30a3\u30f3\u30b0\u3068\u3057\u3066\u8ffd\u52a0\u3059\u308b 0 \u306e\u6570 $k$ \u306f\u3001\u6b21\u306e\u5f0f\u306b\u3088\u3063\u3066\u6c42\u3081\u3089\u308c\u308b\u3002\n\n```math\nl+1+k \\equiv 448 \\bmod 512\n```\n\n\u3088\u308a\n\n```math\n\\begin{align}\nk&=(512-64)-(l+1)\\\\\n&=448-(24+1)\\\\\n&=405\n\\end{align}\n```\n\n\u4ee5\u4e0a\u304b\u3089 $M$ \u306f\u6b21\u306e\u3088\u3046\u306a\u69cb\u6210\u306b\u306a\u308b\u3002\n\n```math\n\\underbrace{\\overbrace{\\underbrace{01100001}_{\\rm ``{\\bf a}\u201d}\\quad\\underbrace{01100010}_{\\rm ``{\\bf b}\u201d}\\quad\\underbrace{01100011}_{\\rm ``{\\bf c}\u201d}}^{l=24\\,{\\rm bits}}}_{\\rm Massage\\,\"abc\"}\\quad\\underbrace{1\\quad\\overbrace{00\\dots00}^{k=405\\,{\\rm bits}}\\quad\\overbrace{00\\dots0\\underbrace{11000}_{l=24}}^{64\\,{\\rm bits}}}_{\\rm Padding}\n```\n\n\u4ee5\u4e0b\u306f $M_{\\rm in}$ \u306b\u30d1\u30c7\u30a3\u30f3\u30b0\u3092\u8ffd\u52a0\u3057\u3001 $M$ \u3092\u51fa\u529b\u3059\u308b\u95a2\u6570\u3067\u3042\u308b\u3002\u7b2c\u4e00\u5f15\u6570\u306b $M_{\\rm in}$ \u3092\u4ee3\u5165\u3057\u3001\u7b2c\u4e8c\u5f15\u6570\u306b\u30e1\u30c3\u30bb\u30fc\u30b8\u9577 $l$ \u3092\u4ee3\u5165\u3059\u308b\u3002\n\n```rust\nfn add_padding(message: &Vec<u8>, length: u64) -> Vec<u8> {\n    let data_len = ((length / 512) * 64 + if (length % 512) <= 447 { 64 } else { 128 }) as usize;\n    let mut data: Vec<u8> = Vec::with_capacity(data_len);\n\n    // copy message\n    for byte in message.iter() {\n        data.push(*byte);\n    }\n\n    // add padding\n    // add 1\n    if length % 8 == 0 {\n        data.push(0x80);\n    } else {\n        let len = data.len();\n        data[len - 1] |= 1 << (7 - length % 8) as u32;\n    }\n    // add zero\n    for _ in 0..(data_len - data.len() - 8) {\n        data.push(0x00);\n    }\n    // add l (64bits)\n    for i in 0..8 {\n        data.push(((length >> (56 - i * 8) as u32) & 0xff) as u8);\n    }\n\n    data\n}\n```\n\n\n###\u5727\u7e2e\u95a2\u6570\n\n$\\Sigma_0(x),\\,\\Sigma_1(x),\\,\\sigma_0(x),\\,\\sigma_1(x)$ \u306e SHA-256 \u7cfb\u3067\u4f7f\u3046\u3082\u306e\u306f\u4ee5\u4e0b\u306e\u901a\u308a\u3002\u305d\u308c\u305e\u308c $\\Sigma_0^{\\\\{256\\\\}}(x),\\, \\Sigma_1^{\\\\{256\\\\}}(x),\\, \\sigma_0^{\\\\{256\\\\}}(x),\\, \\sigma_1^{\\\\{256\\\\}}(x)$ \u3068\u3057\u3066\u5b9a\u7fa9\u3059\u308b\u3002\n\n```math\n\\begin{align}\n\\Sigma_0^{\\{256\\}}(x)&={\\it ROTR}^{\\,2}(x) \\oplus {\\it ROTR}^{\\,13}(x)\\oplus {\\it ROTR}^{\\,22}(x)\\\\\n\\Sigma_1^{\\{256\\}}(x)&={\\it ROTR}^{\\,6}(x) \\oplus {\\it ROTR}^{\\,11}(x)\\oplus {\\it ROTR}^{\\,25}(x)\\\\\n\\sigma_0^{\\{256\\}}(x)&={\\it ROTR}^{\\,7}(x) \\oplus {\\it ROTR}^{\\,18}(x)\\oplus {\\it SHR}^{\\,3}(x)\\\\\n\\sigma_1^{\\{256\\}}(x)&={\\it ROTR}^{\\,17}(x) \\oplus {\\it ROTR}^{\\,19}(x)\\oplus {\\it SHR}^{\\,10}(x)\n\\end{align}\n```\n\n\u5b9f\u88c5\u306f\u4e0b\u8a18\u3002\n\n```rust\nfn large_sigma0_256(x: u32) -> u32 {\n    x.rotate_right( 2) ^ x.rotate_right(13) ^ x.rotate_right(22)\n}\nfn large_sigma1_256(x: u32) -> u32 {\n    x.rotate_right( 6) ^ x.rotate_right(11) ^ x.rotate_right(25)\n}\nfn sigma0_256(x: u32) -> u32 {\n    x.rotate_right( 7) ^ x.rotate_right(18) ^ (x >> 3)\n}\nfn sigma1_256(x: u32) -> u32 {\n    x.rotate_right(17) ^ x.rotate_right(19) ^ (x >> 10)\n}\n```\n\n\u3053\u308c\u3092\u9069\u7528\u3059\u308b\u3068\u3001\u30e1\u30c3\u30bb\u30fc\u30b8\u30b9\u30b1\u30b8\u30e5\u30fc\u30eb\u306f\u6b21\u306e\u3088\u3046\u306b\u306a\u308b\u3002\n\n```math\n{W_t = \\left\\{\n\\begin{array}{ll}\nM_t^{(i)} & (0 \\leq t \\leq 15)\\\\\n\\sigma^{\\{256\\}}_1(W_{t-2})+W_{t-7}+\\sigma^{\\{256\\}}_0(W_{t-15})+W_{t-16} & (16 \\leq t \\leq 63)\n\\end{array}\n\\right.\n}\n```\n\n\u5b9f\u88c5\u306f\u4e0b\u8a18\u3002\n\n```rust\nlet w = {\n    let mut w = [0; 64];\n    for t in 0..16 {\n        w[t] = self.buffer[t];\n    }\n    for t in 16..64 {\n        w[t] = sigma1_256(w[t-2]).wrapping_add(w[t-7])\n                                 .wrapping_add(sigma0_256(w[t-15]))\n                                 .wrapping_add(w[t-16]);\n    }\n    w\n};\n```\n\n\u5727\u7e2e\u95a2\u6570\u306e\u624b\u9806 5 \u306f\u6b21\u306e\u3088\u3046\u306b\u306a\u308b\u3002\n\n```math\n\\begin{align}\nT_1&=h+\\Sigma^{\\{256\\}}_1(e)+{\\it Ch}(e,f,g)+K_t^{\\{256\\}}+W_t\\\\\nT_2&=\\Sigma^{\\{256\\}}_0(a)+{\\it Maj}(a,b,c)\\\\\nh&=g\\\\\ng&=f\\\\\nf&=e\\\\\ne&=d+T_1\\\\\nd&=c\\\\\nc&=b\\\\\nb&=a\\\\\na&=T_1+T_2\n\\end{align}\n```\n}\n\n\u5b9f\u88c5\u306f\u4ee5\u4e0b\u3002\n\n```rust\nfor t in 0..64 {\n    let t1 = h.wrapping_add(large_sigma1_256(e))\n              .wrapping_add(Ch!(e, f, g))\n              .wrapping_add(K256[t])\n              .wrapping_add(w[t]);\n    let t2 = large_sigma0_256(a).wrapping_add(Maj!(a, b, c));\n    h = g;\n    g = f;\n    f = e;\n    e = d.wrapping_add(t1);\n    d = c;\n    c = b;\n    b = a;\n    a = t1.wrapping_add(t2);\n}\n```\n\n\u5727\u7e2e\u95a2\u6570\u306e\u624b\u9806 6 \u306f\u6b21\u306e\u3088\u3046\u306b\u306a\u308b\u3002\n\n```math\n\\begin{align}\nH_0^{(i)}&=a+H_0^{(i-1)}\\\\\nH_1^{(i)}&=b+H_1^{(i-1)}\\\\\nH_2^{(i)}&=c+H_2^{(i-1)}\\\\\nH_3^{(i)}&=d+H_3^{(i-1)}\\\\\nH_4^{(i)}&=e+H_4^{(i-1)}\\\\\nH_5^{(i)}&=f+H_5^{(i-1)}\\\\\nH_6^{(i)}&=g+H_6^{(i-1)}\\\\\nH_7^{(i)}&=h+H_7^{(i-1)}\\\\\n\\end{align}\n```\n\n```rust\nself.state = [\n    a.wrapping_add(self.state[0]),\n    b.wrapping_add(self.state[1]),\n    c.wrapping_add(self.state[2]),\n    d.wrapping_add(self.state[3]),\n    e.wrapping_add(self.state[4]),\n    f.wrapping_add(self.state[5]),\n    g.wrapping_add(self.state[6]),\n    h.wrapping_add(self.state[7])\n];\n```\n\n\u4ee5\u4e0a\u3092\u6301\u3063\u3066\u5727\u7e2e\u95a2\u6570\u3092\u5b9f\u88c5\u3059\u308b\u3068\u6b21\u306e\u3088\u3046\u306b\u306a\u308b\u3002\n\n```rust\nmacro_rules! Ch {\n    ($x:expr, $y:expr, $z:expr) => { ($x & $y) ^ (!$x & $z) };\n}\nmacro_rules! Maj {\n    ($x:expr, $y:expr, $z:expr) => { ($x & $y) ^ ($x & $z) ^ ($y & $z) };\n}\n\nconst K256: [u32; 64] = [\n    0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5,\n    0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n    0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3,\n    0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n    0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc,\n    0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n    0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7,\n    0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n    0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13,\n    0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n    0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3,\n    0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n    0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5,\n    0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n    0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208,\n    0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2\n];\n\nfn large_sigma0_256(x: u32) -> u32 {\n    x.rotate_right( 2) ^ x.rotate_right(13) ^ x.rotate_right(22)\n}\nfn large_sigma1_256(x: u32) -> u32 {\n    x.rotate_right( 6) ^ x.rotate_right(11) ^ x.rotate_right(25)\n}\nfn sigma0_256(x: u32) -> u32 {\n    x.rotate_right( 7) ^ x.rotate_right(18) ^ (x >> 3)\n}\nfn sigma1_256(x: u32) -> u32 {\n    x.rotate_right(17) ^ x.rotate_right(19) ^ (x >> 10)\n}\n\nfn round(state: [u32; 8], block: [u32; 16]) -> [u32; 8] {\n    let w = {\n        let mut w = [0; 64];\n        for t in 0..16 {\n            w[t] = block[t];\n        }\n        for t in 16..64 {\n            w[t] = sigma1_256(w[t-2]).wrapping_add(w[t-7])\n                                     .wrapping_add(sigma0_256(w[t-15]))\n                                     .wrapping_add(w[t-16]);\n        }\n        w\n    };\n    let (mut a, mut b, mut c, mut d, mut e, mut f, mut g, mut h) = (\n        state[0],\n        state[1],\n        state[2],\n        state[3],\n        state[4],\n        state[5],\n        state[6],\n        state[7]\n    );\n    for t in 0..64 {\n        let t1 = h.wrapping_add(large_sigma1_256(e))\n                  .wrapping_add(Ch!(e, f, g))\n                  .wrapping_add(K256[t])\n                  .wrapping_add(w[t]);\n        let t2 = large_sigma0_256(a).wrapping_add(Maj!(a, b, c));\n        h = g;\n        g = f;\n        f = e;\n        e = d.wrapping_add(t1);\n        d = c;\n        c = b;\n        b = a;\n        a = t1.wrapping_add(t2);\n    }\n    [\n        a.wrapping_add(state[0]),\n        b.wrapping_add(state[1]),\n        c.wrapping_add(state[2]),\n        d.wrapping_add(state[3]),\n        e.wrapping_add(state[4]),\n        f.wrapping_add(state[5]),\n        g.wrapping_add(state[6]),\n        h.wrapping_add(state[7])\n    ]\n}\n\nenum Sha256BitLength {\n    Len224 = 224,\n    Len256 = 256,\n}\n```\n\n###\u30cf\u30c3\u30b7\u30e5\u4f5c\u6210\n\n\u30cf\u30c3\u30b7\u30e5\u306f\u6b21\u306e\u3088\u3046\u306b\u7d50\u5408\u3055\u308c\u308b\u3002 $\\parallel$ \u306f\u7d50\u5408\u3092\u8868\u3059\u3002\u4f8b\u3048\u3070\u3001 $A=010,\\,B=001$ \u3068\u3057\u305f\u3068\u304d\u3001 $A\\parallel B=010001$ \u3068\u306a\u308b\u3002\n\nSHA-256\n\n```math\nH_0^{(N)}\\parallel H_1^{(N)}\\parallel H_2^{(N)}\\parallel H_3^{(N)}\\parallel H_4^{(N)}\\parallel H_5^{(N)}\\parallel H_6^{(N)}\\parallel H_7^{(N)}\n```\n\nSHA-224\n\n```math\nH_0^{(N)}\\parallel H_1^{(N)}\\parallel H_2^{(N)}\\parallel H_3^{(N)}\\parallel H_4^{(N)}\\parallel H_5^{(N)}\\parallel H_6^{(N)}\n```\n\n\u4ee5\u4e0a\u3092\u898b\u3066\u308f\u304b\u308b\u901a\u308a\u3001 SHA-224 \u306f SHA-256 \u306e\u5148\u982d 224 bit \u3092\u5207\u308a\u53d6\u3063\u305f\u3082\u306e\u3067\u3042\u308b\u3002\u305f\u3060\u3057\u3001\u521d\u671f\u5024\u304c\u7570\u306a\u308b\u305f\u3081\u3001\u540c\u4e00\u30e1\u30c3\u30bb\u30fc\u30b8\u3067\u3042\u3063\u3066\u3082\u5024\u306f\u7570\u306a\u308b\u3002\n\n$H^{(N)}$ \u3092 `state: [u32; 8]` \u3001\u30cf\u30c3\u30b7\u30e5\u9577\u3092 `hash_length: usize` \u3068\u3057\u3066\u3001 `Vec<u8>` \u578b\u3067\u30cf\u30c3\u30b7\u30e5\u3092\u8868\u3059\u3068\u3059\u308b\u3068\u3001\u30b3\u30fc\u30c9\u306f\u6b21\u306e\u3088\u3046\u306b\u306a\u308b\u3002\n\n```rust\nfn (state: [u32; 8], hash_length: usize) -> Vec<u8> {\n    let mut hash: Vec<u8> = Vec::with_capacity(hash_length);\n    let mut length = 0;\n    'outer: for h in state.iter() {\n        use std::mem::transmute;\n\n        let from = if cfg!(target_endian = \"big\") {\n            *h\n        } else {\n            (*h).swap_bytes()\n        };\n        for byte in unsafe { transmute::<u32, [u8; 4]>(from) }.iter() {\n            hash.push(*byte);\n            length += 8;\n            if length == hash_length as usize {\n                break 'outer;\n            }\n        }\n    }\n\n    hash\n}\n```\n\n\n###\u30bd\u30fc\u30b9\u30b3\u30fc\u30c9\n\n```rust:sha256.rs\nmacro_rules! Ch {\n    ($x:expr, $y:expr, $z:expr) => { ($x & $y) ^ (!$x & $z) };\n}\nmacro_rules! Maj {\n    ($x:expr, $y:expr, $z:expr) => { ($x & $y) ^ ($x & $z) ^ ($y & $z) };\n}\n\n/// \u8ffd\u52a0\u5b9a\u6570\nconst K256: [u32; 64] = [\n    0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5,\n    0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n    0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3,\n    0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n    0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc,\n    0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n    0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7,\n    0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n    0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13,\n    0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n    0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3,\n    0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n    0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5,\n    0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n    0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208,\n    0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2\n];\n\nfn large_sigma0_256(x: u32) -> u32 {\n    x.rotate_right( 2) ^ x.rotate_right(13) ^ x.rotate_right(22)\n}\nfn large_sigma1_256(x: u32) -> u32 {\n    x.rotate_right( 6) ^ x.rotate_right(11) ^ x.rotate_right(25)\n}\nfn sigma0_256(x: u32) -> u32 {\n    x.rotate_right( 7) ^ x.rotate_right(18) ^ (x >> 3)\n}\nfn sigma1_256(x: u32) -> u32 {\n    x.rotate_right(17) ^ x.rotate_right(19) ^ (x >> 10)\n}\n\n/// \u5727\u7e2e\u95a2\u6570\nfn round(state: [u32; 8], block: [u32; 16]) -> [u32; 8] {\n    let w = {\n        let mut w = [0; 64];\n        for t in 0..16 {\n            w[t] = block[t];\n        }\n        for t in 16..64 {\n            w[t] = sigma1_256(w[t-2]).wrapping_add(w[t-7])\n                                     .wrapping_add(sigma0_256(w[t-15]))\n                                     .wrapping_add(w[t-16]);\n        }\n        w\n    };\n    let (mut a, mut b, mut c, mut d, mut e, mut f, mut g, mut h) = (\n        state[0],\n        state[1],\n        state[2],\n        state[3],\n        state[4],\n        state[5],\n        state[6],\n        state[7]\n    );\n    for t in 0..64 {\n        let t1 = h.wrapping_add(large_sigma1_256(e))\n                  .wrapping_add(Ch!(e, f, g))\n                  .wrapping_add(K256[t])\n                  .wrapping_add(w[t]);\n        let t2 = large_sigma0_256(a).wrapping_add(Maj!(a, b, c));\n        h = g;\n        g = f;\n        f = e;\n        e = d.wrapping_add(t1);\n        d = c;\n        c = b;\n        b = a;\n        a = t1.wrapping_add(t2);\n    }\n    [\n        a.wrapping_add(state[0]),\n        b.wrapping_add(state[1]),\n        c.wrapping_add(state[2]),\n        d.wrapping_add(state[3]),\n        e.wrapping_add(state[4]),\n        f.wrapping_add(state[5]),\n        g.wrapping_add(state[6]),\n        h.wrapping_add(state[7])\n    ]\n}\n\n/// \u30d1\u30c7\u30a3\u30f3\u30b0\u3092\u52a0\u3048\u305f\u30c7\u30fc\u30bf\u3092\u30d6\u30ed\u30c3\u30af\u306b\u5206\u5272\u3059\u308b\u3002\nfn separate_data(data: Vec<u8>) -> Vec<[u32; 16]> {\n    let mut blocks = Vec::with_capacity(data.len() / 512);\n    let mut idx = 0;\n    let mut shift = 32;\n    let mut block = [0; 16];\n    for byte in data.iter() {\n        shift -= 8;\n        block[idx] |= (*byte as u32) << shift;\n        if shift == 0 {\n            idx += 1;\n            shift = 32;\n        }\n        if idx == 16 {\n            blocks.push(block);\n            block = [0; 16];\n            idx = 0;\n        }\n    }\n    blocks\n}\n\n/// \u30e1\u30c3\u30bb\u30fc\u30b8\u306b\u30d1\u30c7\u30a3\u30f3\u30b0\u3092\u8ffd\u52a0\u3059\u308b\u3002\nfn add_padding(message: &Vec<u8>, length: u64) -> Vec<u8> {\n    let data_len = ((length / 512) * 64 + if (length % 512) <= 447 { 64 } else { 128 }) as usize;\n    let mut data: Vec<u8> = Vec::with_capacity(data_len);\n\n    // copy message\n    for byte in message.iter() {\n        data.push(*byte);\n    }\n\n    // add padding\n    if length % 8 == 0 {\n        data.push(0x80);\n    } else {\n        let len = data.len();\n        data[len - 1] |= 1 << (7 - length % 8) as u32;\n    }\n    for _ in 0..(data_len - data.len() - 8) {\n        data.push(0x00);\n    }\n    for i in 0..8 {\n        data.push(((length >> (56 - i * 8) as u32) & 0xff) as u8);\n    }\n\n    data\n}\n\n/// \u30cf\u30c3\u30b7\u30e5\u9577\npub enum Sha256DigestSize {\n    Len224 = 224,\n    Len256 = 256,\n}\n\n/// \u30cf\u30c3\u30b7\u30e5\u306e\u53d6\u5f97\u3002message \u306b\u30e1\u30c3\u30bb\u30fc\u30b8\u3092\u4ee3\u5165\u3057\u3001 message_length \u306b\u30e1\u30c3\u30bb\u30fc\u30b8\u9577\u3092\u4ee3\u5165\u3059\u308b\u3002\npub fn create_hash(message: &Vec<u8>, message_length: u64, digest_size: Sha256DigestSize) -> Box<[u8]> {\n    // \u30d1\u30c7\u30a3\u30f3\u30b0\u306e\u8ffd\u52a0\n    let data = add_padding(message, message_length);\n    // \u30c7\u30fc\u30bf\u3092\u30d6\u30ed\u30c3\u30af\u306b\u5206\u5272\n    let blocks = separate_data(data);\n    // \u521d\u671f\u5024\n    let mut state = match digest_size {\n        Sha256DigestSize::Len224 => [\n            0xc1059ed8,\n            0x367cd507,\n            0x3070dd17,\n            0xf70e5939,\n            0xffc00b31,\n            0x68581511,\n            0x64f98fa7,\n            0xbefa4fa4\n        ],\n        Sha256DigestSize::Len256 => [\n            0x6a09e667,\n            0xbb67ae85,\n            0x3c6ef372,\n            0xa54ff53a,\n            0x510e527f,\n            0x9b05688c,\n            0x1f83d9ab,\n            0x5be0cd19\n        ],\n    };\n    // \u30d6\u30ed\u30c3\u30af\u3092\u5727\u7e2e\u95a2\u6570\u306b\u4ee3\u5165\n    for block in blocks.iter() {\n        state = round(state, *block);\n    }\n    // \u30cf\u30c3\u30b7\u30e5\u306e\u4f5c\u6210\n    let hash_length = digest_size as usize;\n    let mut hash: Vec<u8> = Vec::with_capacity(hash_length);\n    let mut length = 0;\n    'outer: for h in state.iter() {\n        use std::mem::transmute;\n\n        let from = if cfg!(target_endian = \"big\") {\n            *h\n        } else {\n            (*h).swap_bytes()\n        };\n        for byte in unsafe { transmute::<u32, [u8; 4]>(from) }.iter() {\n            hash.push(*byte);\n            length += 8;\n            if length == hash_length as usize {\n                break 'outer;\n            }\n        }\n    }\n\n    // \u623b\u308a\u5024\n    hash.into_boxed_slice()\n}\n```\n\n\u3053\u306e\u30d7\u30ed\u30b0\u30e9\u30e0\u306f\u3001\u6b21\u306e\u624b\u9806\u306b\u3088\u3063\u3066\u30cf\u30c3\u30b7\u30e5 ( `Box<[u8]>` \u578b ) \u3092\u53d6\u5f97\u3059\u308b\u3002\n\n1. `Message::new` \u306e\u7b2c1\u5f15\u6570\u306b\u30e1\u30c3\u30bb\u30fc\u30b8 ( `&[u8]` \u578b ) \u3001\u7b2c2\u5f15\u6570\u306b\u30e1\u30c3\u30bb\u30fc\u30b8\u9577 ( `u64` \u578b ) \u3092\u4ee3\u5165\n2. `create_hash` \u95a2\u6570\u306e\u7b2c1\u5f15\u6570\u306b\u624b\u9806 1 \u3067\u4f5c\u6210\u3057\u305f `Message` \u69cb\u9020\u4f53\u3001\u7b2c3\u5f15\u6570\u306b\u30cf\u30c3\u30b7\u30e5\u9577 ( `Sha256DigestSize` \u578b ) \u3092\u4ee3\u5165\n3. `create_hash` \u95a2\u6570\u306e\u623b\u308a\u5024\u304c\u30cf\u30c3\u30b7\u30e5\n\n\u6b21\u306e\u30b3\u30fc\u30c9\u306f\u3001\u7a7a\u306e\u30e1\u30c3\u30bb\u30fc\u30b8\u304b\u3089 SHA-256 \u3092\u53d6\u5f97\u3059\u308b\u4f8b\u3067\u3042\u308b\u3002\n\n```rust\nlet msg = Message::new(&vec![], 0);\nlet hash = create_hash(msg, Sha256DigestSize::Len256);\n```\n\n###\u30c6\u30b9\u30c8\n\n\u30e1\u30c3\u30bb\u30fc\u30b8\u304c\u7a7a \"\" \u306e\u5834\u5408\u306e\u30cf\u30c3\u30b7\u30e5\n\n|\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0|\u30cf\u30c3\u30b7\u30e5|\n|---|---|\n|SHA-224| d14a028c 2a3a2bc9 476102bb 288234c4 15a2b01f 828ea62a c5b3e42f |\n|SHA-256| e3b0c442 98fc1c14 9afbf4c8 996fb924 27ae41e4 649b934c a495991b 7852b855 |\n\n```rust:sha256_empty_message_tests\n/// \u7a7a\u306e\u30e1\u30c3\u30bb\u30fc\u30b8 \"\" \u306b\u5bfe\u3057 SHA-224 \u3092\u53d6\u308b\n#[test]\nfn sha2_224_hash_by_empty_msg() {\n    let msg = Message::new(&vec![], 0);\n    let hash = create_hash(msg, Sha256DigestSize::Len224);\n    assert_eq!(hash, vec![\n        0xd1, 0x4a, 0x02, 0x8c, 0x2a, 0x3a, 0x2b, 0xc9,\n        0x47, 0x61, 0x02, 0xbb, 0x28, 0x82, 0x34, 0xc4,\n        0x15, 0xa2, 0xb0, 0x1f, 0x82, 0x8e, 0xa6, 0x2a,\n        0xc5, 0xb3, 0xe4, 0x2f\n    ].into_boxed_slice());\n}\n/// \u7a7a\u306e\u30e1\u30c3\u30bb\u30fc\u30b8 \"\" \u306b\u5bfe\u3057 SHA-256 \u3092\u53d6\u308b\n#[test]\nfn sha2_256_hash_by_empty_msg() {\n    let msg = Message::new(&vec![], 0);\n    let hash = create_hash(msg, Sha256DigestSize::Len256);\n    assert_eq!(hash, vec![\n        0xe3, 0xb0, 0xc4, 0x42, 0x98, 0xfc, 0x1c, 0x14,\n        0x9a, 0xfb, 0xf4, 0xc8, 0x99, 0x6f, 0xb9, 0x24,\n        0x27, 0xae, 0x41, 0xe4, 0x64, 0x9b, 0x93, 0x4c,\n        0xa4, 0x95, 0x99, 0x1b, 0x78, 0x52, 0xb8, 0x55\n    ].into_boxed_slice());\n}\n```\n\n\u30e1\u30c3\u30bb\u30fc\u30b8\u304c \"abc\" \u306e\u30cf\u30c3\u30b7\u30e5\n\n|\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0|\u30cf\u30c3\u30b7\u30e5|\n|---|---|\n|SHA-224| 23097d22 3405d822 8642a477 bda255b3 2aadbce4 bda0b3f7 e36c9da7 |\n|SHA-256| ba7816bf 8f01cfea 414140de 5dae2223 b00361a3 96177a9c b410ff61 f20015ad |\n\n```rust:sha256_abc_message_tests\n/// \u30e1\u30c3\u30bb\u30fc\u30b8 \"abc\" \u306b\u5bfe\u3057 SHA-224 \u3092\u53d6\u308b\n#[test]\nfn sha2_224_hash_by_abc_msg() {\n    let msg = Message::new(b\"abc\".as_ref(), 24);\n    let hash = create_hash(msg, Sha256DigestSize::Len224);\n    assert_eq!(hash, vec![\n        0x23, 0x09, 0x7d, 0x22, 0x34, 0x05, 0xd8, 0x22,\n        0x86, 0x42, 0xa4, 0x77, 0xbd, 0xa2, 0x55, 0xb3,\n        0x2a, 0xad, 0xbc, 0xe4, 0xbd, 0xa0, 0xb3, 0xf7,\n        0xe3, 0x6c, 0x9d, 0xa7\n    ].into_boxed_slice());\n}\n/// \u30e1\u30c3\u30bb\u30fc\u30b8 \"abc\" \u306b\u5bfe\u3057 SHA-256 \u3092\u53d6\u308b\n#[test]\nfn sha2_256_hash_by_abc_msg() {\n    let msg = Message::new(b\"abc\".as_ref(), 24);\n    let hash = create_hash(msg, Sha256DigestSize::Len256);\n    assert_eq!(hash, vec![\n        0xba, 0x78, 0x16, 0xbf, 0x8f, 0x01, 0xcf, 0xea,\n        0x41, 0x41, 0x40, 0xde, 0x5d, 0xae, 0x22, 0x23,\n        0xb0, 0x03, 0x61, 0xa3, 0x96, 0x17, 0x7a, 0x9c,\n        0xb4, 0x10, 0xff, 0x61, 0xf2, 0x00, 0x15, 0xad\n    ].into_boxed_slice());\n}\n```\n\n\u30e1\u30c3\u30bb\u30fc\u30b8\u304c x \u30d3\u30c3\u30c8\u306e 0 \u3067\u3042\u308b SHA-256 \u30cf\u30c3\u30b7\u30e5\n\n|\u30d3\u30c3\u30c8\u6570|\u30cf\u30c3\u30b7\u30e5|\n|---|---|\n|447| 43fdd2ee d4df6d2c 38e971da 88411505 1951aa68 d892720f 79689d49 62c9efae |\n|448| d4817aa5 497628e7 c77e6b60 6107042b bba31308 88c5f47a 375e6179 be789fbb |\n\n```rust:sha256_x_zero_bits_tests\n/// 447 bits \u306e 0 \u3067\u69cb\u6210\u3055\u308c\u305f\u30e1\u30c3\u30bb\u30fc\u30b8\u306b\u5bfe\u3057 SHA-256 \u3092\u53d6\u308b\n#[test]\nfn sha2_256_hash_by_447_zero_bits() {\n    let msg = Message::new(&vec![\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    ], 447);\n    let hash = create_hash(msg, Sha256DigestSize::Len256);\n    assert_eq!(hash, vec![\n        0x43, 0xfd, 0xd2, 0xee, 0xd4, 0xdf, 0x6d, 0x2c,\n        0x38, 0xe9, 0x71, 0xda, 0x88, 0x41, 0x15, 0x05,\n        0x19, 0x51, 0xaa, 0x68, 0xd8, 0x92, 0x72, 0x0f,\n        0x79, 0x68, 0x9d, 0x49, 0x62, 0xc9, 0xef, 0xae\n    ].into_boxed_slice());\n}\n/// 448 bits \u306e 0 \u3067\u69cb\u6210\u3055\u308c\u305f\u30e1\u30c3\u30bb\u30fc\u30b8\u306b\u5bfe\u3057 SHA-256 \u3092\u53d6\u308b\n#[test]\nfn sha2_256_hash_by_448_zero_bits() {\n    let msg = Message::new(&vec![\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    ], 448);\n    let hash = create_hash(msg, Sha256DigestSize::Len256);\n    assert_eq!(hash, vec![\n        0xd4, 0x81, 0x7a, 0xa5, 0x49, 0x76, 0x28, 0xe7,\n        0xc7, 0x7e, 0x6b, 0x60, 0x61, 0x07, 0x04, 0x2b,\n        0xbb, 0xa3, 0x13, 0x08, 0x88, 0xc5, 0xf4, 0x7a,\n        0x37, 0x5e, 0x61, 0x79, 0xbe, 0x78, 0x9f, 0xbb\n    ].into_boxed_slice());\n}\n```\n\n\n##SHA-384 \u304a\u3088\u3073 SHA-512\uff0cSHA-512/224\uff0cSHA-512/256\n\nSHA-512 \u7cfb\u306f SHA-256 \u7cfb\u3068\u5168\u4f53\u306e\u69cb\u9020\u304c\u540c\u3058\u306a\u306e\u3067\u3001\u76f8\u9055\u70b9\u306e\u307f\u3092\u8ff0\u3079\u308b\u3002\n\n###\u5b9a\u6570\n\n\u30fb\u8ffd\u52a0\u5b9a\u6570 $K^{\\\\{512\\\\}}$\n\n```\n428a2f98d728ae22 7137449123ef65cd b5c0fbcfec4d3b2f e9b5dba58189dbbc\n3956c25bf348b538 59f111f1b605d019 923f82a4af194f9b ab1c5ed5da6d8118\nd807aa98a3030242 12835b0145706fbe 243185be4ee4b28c 550c7dc3d5ffb4e2\n72be5d74f27b896f 80deb1fe3b1696b1 9bdc06a725c71235 c19bf174cf692694\ne49b69c19ef14ad2 efbe4786384f25e3 0fc19dc68b8cd5b5 240ca1cc77ac9c65\n2de92c6f592b0275 4a7484aa6ea6e483 5cb0a9dcbd41fbd4 76f988da831153b5\n983e5152ee66dfab a831c66d2db43210 b00327c898fb213f bf597fc7beef0ee4\nc6e00bf33da88fc2 d5a79147930aa725 06ca6351e003826f 142929670a0e6e70\n27b70a8546d22ffc 2e1b21385c26c926 4d2c6dfc5ac42aed 53380d139d95b3df\n650a73548baf63de 766a0abb3c77b2a8 81c2c92e47edaee6 92722c851482353b\na2bfe8a14cf10364 a81a664bbc423001 c24b8b70d0f89791 c76c51a30654be30\nd192e819d6ef5218 d69906245565a910 f40e35855771202a 106aa07032bbd1b8\n19a4c116b8d2d0c8 1e376c085141ab53 2748774cdf8eeb99 34b0bcb5e19b48a8\n391c0cb3c5c95a63 4ed8aa4ae3418acb 5b9cca4f7763e373 682e6ff3d6b2b8a3\n748f82ee5defb2fc 78a5636f43172f60 84c87814a1f0ab72 8cc702081a6439ec\n90befffa23631e28 a4506cebde82bde9 bef9a3f7b2c67915 c67178f2e372532b\nca273eceea26619c d186b8c721c0c207 eada7dd6cde0eb1e f57d4f7fee6ed178\n06f067aa72176fba 0a637dc5a2c898a6 113f9804bef90dae 1b710b35131c471b\n28db77f523047d84 32caab7b40c72493 3c9ebe0a15c9bebc 431d67c49c100d4c\n4cc5d4becb3e42b6 597f299cfc657e2a 5fcb6fab3ad6faec 6c44198c4a475817\n```\n\n```math\n\\begin{align}\n\\Sigma^{\\{512\\}}_0(x)&={\\it ROTR}^{\\,28}(x)\\oplus {\\it ROTR}^{\\,34}(x)\\oplus {\\it ROTR}^{\\,39}(x)\\\\\n\\Sigma^{\\{512\\}}_1(x)&={\\it ROTR}^{\\,14}(x)\\oplus {\\it ROTR}^{\\,18}(x)\\oplus {\\it ROTR}^{\\,41}(x)\\\\\n\\sigma^{\\{512\\}}_0(x)&={\\it ROTR}^{\\,1}(x)\\oplus {\\it ROTR}^{\\,8}(x)\\oplus {\\it SHR}^{\\,7}(x)\\\\\n\\sigma^{\\{512\\}}_1(x)&={\\it ROTR}^{\\,19}(x)\\oplus {\\it ROTR}^{\\,61}(x)\\oplus {\\it SHR}^{\\,6}(x)\n\\end{align}\n```\n\n\u30fbSHA-384 \u306e\u521d\u671f\u5024 $H^{(0)}$\n\n```math\n\\begin{align}\nH^{(0)}_0&={\\tt cbbb9d5dc1059ed8}\\\\\nH^{(0)}_1&={\\tt 629a292a367cd507}\\\\\nH^{(0)}_2&={\\tt 9159015a3070dd17}\\\\\nH^{(0)}_3&={\\tt 152fecd8f70e5939}\\\\\nH^{(0)}_4&={\\tt 67332667ffc00b31}\\\\\nH^{(0)}_5&={\\tt 8eb44a8768581511}\\\\\nH^{(0)}_6&={\\tt db0c2e0d64f98fa7}\\\\\nH^{(0)}_7&={\\tt 47b5481dbefa4fa4}\\\\\n\\end{align}\n```\n\n\u30fbSHA-512 \u306e\u521d\u671f\u5024 $H^{(0)}$\n\n```math\n\\begin{align}\nH^{(0)}_0&={\\tt 6a09e667f3bcc908}\\\\\nH^{(0)}_1&={\\tt bb67ae8584caa73b}\\\\\nH^{(0)}_2&={\\tt 3c6ef372fe94f82b}\\\\\nH^{(0)}_3&={\\tt a54ff53a5f1d36f1}\\\\\nH^{(0)}_4&={\\tt 510e527fade682d1}\\\\\nH^{(0)}_5&={\\tt 9b05688c2b3e6c1f}\\\\\nH^{(0)}_6&={\\tt 1f83d9abfb41bd6b}\\\\\nH^{(0)}_7&={\\tt 5be0cd19137e2179}\\\\\n\\end{align}\n```\n\n\u30fbSHA-512/224 \u306e\u521d\u671f\u5024 $H^{(0)}$\n\n```math\n\\begin{align}\nH^{(0)}_0&={\\tt 8C3D37C819544DA2}\\\\\nH^{(0)}_1&={\\tt 73E1996689DCD4D6}\\\\\nH^{(0)}_2&={\\tt 1DFAB7AE32FF9C82}\\\\\nH^{(0)}_3&={\\tt 679DD514582F9FCF}\\\\\nH^{(0)}_4&={\\tt 0F6D2B697BD44DA8}\\\\\nH^{(0)}_5&={\\tt 77E36F7304C48942}\\\\\nH^{(0)}_6&={\\tt 3F9D85A86A1D36C8}\\\\\nH^{(0)}_7&={\\tt 1112E6AD91D692A1}\\\\\n\\end{align}\n```\n\n\u30fbSHA-512/256 \u306e\u521d\u671f\u5024 $H^{(0)}$\n\n```math\n\\begin{align}\nH^{(0)}_0&={\\tt 22312194FC2BF72C}\\\\\nH^{(0)}_1&={\\tt 9F555FA3C84C64C2}\\\\\nH^{(0)}_2&={\\tt 2393B86B6F53B151}\\\\\nH^{(0)}_3&={\\tt 963877195940EABD}\\\\\nH^{(0)}_4&={\\tt 96283EE2A88EFFE3}\\\\\nH^{(0)}_5&={\\tt BE5E1E2553863992}\\\\\nH^{(0)}_6&={\\tt 2B0199FC2C85B8AA}\\\\\nH^{(0)}_7&={\\tt 0EB72DDC81C52CA2}\\\\\n\\end{align}\n```\n\n##\u30d1\u30c7\u30a3\u30f3\u30b0\n\nSHA-256 \u7cfb\u3068\u540c\u69d8\u306b\u3001 $M_{\\rm in}={\\rm ``abc\"}=01100001\\,01100010\\,01100011$ \u3068\u3057\u305f\u3068\u304d\u3001\u30d1\u30c7\u30a3\u30f3\u30b0\u3068\u3057\u3066\u8ffd\u52a0\u3059\u308b 0 \u306e\u6570 $k$ \u306f\u3001\u6b21\u306e\u5f0f\u306b\u3088\u3063\u3066\u6c42\u3081\u3089\u308c\u308b\u3002\n\n```math\nl+1+k \\equiv 896 \\bmod 1024\n```\n\n\u3088\u308a\n\n```math\n\\begin{align}\nk&=(1024-128)-(l+1)\\\\\n&=896-(24+1)\\\\\n&=871\n\\end{align}\n```\n\n\u3057\u305f\u304c\u3063\u3066\u3001 $M$ \u306e\u69cb\u6210\u306f\u4ee5\u4e0b\u306e\u3088\u3046\u306b\u306a\u308b\u3002\n\n```math\n\\underbrace{\\underbrace{01100001}_{\\rm ``{\\bf a}\u201d}\\quad\\underbrace{01100010}_{\\rm ``{\\bf b}\u201d}\\quad\\underbrace{01100011}_{\\rm ``{\\bf c}\u201d}}_{\\rm Massage}\\quad\\underbrace{1\\quad\\overbrace{00\\dots00}^{k=871}\\quad\\overbrace{00\\dots0\\underbrace{11000}_{l=24}}^{128}}_{\\rm Padding}\n```\n\n###\u30cf\u30c3\u30b7\u30e5\u4f5c\u6210\n\nSHA-512\n\n```math\nH_0^{(N)}\\parallel H_1^{(N)}\\parallel H_2^{(N)}\\parallel H_3^{(N)}\\parallel H_4^{(N)}\\parallel H_5^{(N)}\\parallel H_6^{(N)}\\parallel H_7^{(N)}\n```\n\nSHA-384\n\n```math\nH_0^{(N)}\\parallel H_1^{(N)}\\parallel H_2^{(N)}\\parallel H_3^{(N)}\\parallel H_4^{(N)}\\parallel H_5^{(N)}\n```\n\n\u4ee5\u4e0a\u3092\u898b\u3066\u308f\u304b\u308b\u901a\u308a\u3001 SHA-256 \u7cfb\u3068\u540c\u3058\u304f\u3001 SHA-384 \u306f SHA-512 \u306e\u5148\u982d 384 bit \u3092\u5207\u308a\u53d6\u3063\u305f\u3082\u306e\u3067\u3042\u308b\u304c\u3001\u521d\u671f\u5024\u304c\u7570\u306a\u308b\u305f\u3081\u3001\u540c\u4e00\u30e1\u30c3\u30bb\u30fc\u30b8\u3067\u3042\u3063\u3066\u3082\u5024\u306f\u7570\u306a\u308b\u3002 SHA-512/224 \u304a\u3088\u3073 SHA-512/256 \u3082\u540c\u69d8\u3067\u3042\u308b\u3002\n\n###\u30bd\u30fc\u30b9\u30b3\u30fc\u30c9\n\n```rust:sha512.rs\nmacro_rules! Ch {\n    ($x:expr, $y:expr, $z:expr) => { ($x & $y) ^ (!$x & $z) };\n}\nmacro_rules! Maj {\n    ($x:expr, $y:expr, $z:expr) => { ($x & $y) ^ ($x & $z) ^ ($y & $z) };\n}\n\n/// \u8ffd\u52a0\u5b9a\u6570\nconst K512: [u64; 80] = [\n    0x428a2f98d728ae22, 0x7137449123ef65cd, 0xb5c0fbcfec4d3b2f, 0xe9b5dba58189dbbc,\n    0x3956c25bf348b538, 0x59f111f1b605d019, 0x923f82a4af194f9b, 0xab1c5ed5da6d8118,\n    0xd807aa98a3030242, 0x12835b0145706fbe, 0x243185be4ee4b28c, 0x550c7dc3d5ffb4e2,\n    0x72be5d74f27b896f, 0x80deb1fe3b1696b1, 0x9bdc06a725c71235, 0xc19bf174cf692694,\n    0xe49b69c19ef14ad2, 0xefbe4786384f25e3, 0x0fc19dc68b8cd5b5, 0x240ca1cc77ac9c65,\n    0x2de92c6f592b0275, 0x4a7484aa6ea6e483, 0x5cb0a9dcbd41fbd4, 0x76f988da831153b5,\n    0x983e5152ee66dfab, 0xa831c66d2db43210, 0xb00327c898fb213f, 0xbf597fc7beef0ee4,\n    0xc6e00bf33da88fc2, 0xd5a79147930aa725, 0x06ca6351e003826f, 0x142929670a0e6e70,\n    0x27b70a8546d22ffc, 0x2e1b21385c26c926, 0x4d2c6dfc5ac42aed, 0x53380d139d95b3df,\n    0x650a73548baf63de, 0x766a0abb3c77b2a8, 0x81c2c92e47edaee6, 0x92722c851482353b,\n    0xa2bfe8a14cf10364, 0xa81a664bbc423001, 0xc24b8b70d0f89791, 0xc76c51a30654be30,\n    0xd192e819d6ef5218, 0xd69906245565a910, 0xf40e35855771202a, 0x106aa07032bbd1b8,\n    0x19a4c116b8d2d0c8, 0x1e376c085141ab53, 0x2748774cdf8eeb99, 0x34b0bcb5e19b48a8,\n    0x391c0cb3c5c95a63, 0x4ed8aa4ae3418acb, 0x5b9cca4f7763e373, 0x682e6ff3d6b2b8a3,\n    0x748f82ee5defb2fc, 0x78a5636f43172f60, 0x84c87814a1f0ab72, 0x8cc702081a6439ec,\n    0x90befffa23631e28, 0xa4506cebde82bde9, 0xbef9a3f7b2c67915, 0xc67178f2e372532b,\n    0xca273eceea26619c, 0xd186b8c721c0c207, 0xeada7dd6cde0eb1e, 0xf57d4f7fee6ed178,\n    0x06f067aa72176fba, 0x0a637dc5a2c898a6, 0x113f9804bef90dae, 0x1b710b35131c471b,\n    0x28db77f523047d84, 0x32caab7b40c72493, 0x3c9ebe0a15c9bebc, 0x431d67c49c100d4c,\n    0x4cc5d4becb3e42b6, 0x597f299cfc657e2a, 0x5fcb6fab3ad6faec, 0x6c44198c4a475817\n];\n\nfn large_sigma0_512(x: u64) -> u64 {\n    x.rotate_right(28) ^ x.rotate_right(34) ^ x.rotate_right(39)\n}\nfn large_sigma1_512(x: u64) -> u64 {\n    x.rotate_right(14) ^ x.rotate_right(18) ^ x.rotate_right(41)\n}\nfn sigma0_512(x: u64) -> u64 {\n    x.rotate_right( 1) ^ x.rotate_right( 8) ^ (x >> 7)\n}\nfn sigma1_512(x: u64) -> u64 {\n    x.rotate_right(19) ^ x.rotate_right(61) ^ (x >> 6)\n}\n\n/// \u5727\u7e2e\u95a2\u6570\nfn round(state: [u64; 8], block: [u64; 16]) -> [u64; 8] {\n    let w = {\n        let mut w = [0; 80];\n        for t in 0..16 {\n            w[t] = block[t];\n        }\n        for t in 16..80 {\n            w[t] = sigma1_512(w[t-2]).wrapping_add(w[t-7])\n                                     .wrapping_add(sigma0_512(w[t-15]))\n                                     .wrapping_add(w[t-16]);\n        }\n        w\n    };\n    let (mut a, mut b, mut c, mut d, mut e, mut f, mut g, mut h) = (\n        state[0],\n        state[1],\n        state[2],\n        state[3],\n        state[4],\n        state[5],\n        state[6],\n        state[7]\n    );\n    for t in 0..80 {\n        let t1 = h.wrapping_add(large_sigma1_512(e))\n                  .wrapping_add(Ch!(e, f, g))\n                  .wrapping_add(K512[t])\n                  .wrapping_add(w[t]);\n        let t2 = large_sigma0_512(a).wrapping_add(Maj!(a, b, c));\n        h = g;\n        g = f;\n        f = e;\n        e = d.wrapping_add(t1);\n        d = c;\n        c = b;\n        b = a;\n        a = t1.wrapping_add(t2);\n    }\n    [\n        a.wrapping_add(state[0]),\n        b.wrapping_add(state[1]),\n        c.wrapping_add(state[2]),\n        d.wrapping_add(state[3]),\n        e.wrapping_add(state[4]),\n        f.wrapping_add(state[5]),\n        g.wrapping_add(state[6]),\n        h.wrapping_add(state[7])\n    ]\n}\n\n/// \u30d1\u30c7\u30a3\u30f3\u30b0\u3092\u52a0\u3048\u305f\u30c7\u30fc\u30bf\u3092\u30d6\u30ed\u30c3\u30af\u306b\u5206\u5272\u3059\u308b\u3002\nfn separate_data(data: Vec<u8>) -> Vec<[u64; 16]> {\n    let mut blocks = Vec::with_capacity(data.len() / 128);\n    let mut idx = 0;\n    let mut shift = 64;\n    let mut block = [0; 16];\n    for byte in data.iter() {\n        shift -= 8;\n        block[idx] |= (*byte as u64) << shift;\n        if shift == 0 {\n            idx += 1;\n            shift = 64;\n        }\n        if idx == 16 {\n            blocks.push(block);\n            block = [0; 16];\n            idx = 0;\n        }\n    }\n    blocks\n}\n\npub struct Length {\n    uppper: u64,\n    lower: u64\n}\nimpl Length {\n    pub fn new(val: u64) -> Length {\n        Length {\n            uppper: 0,\n            lower: val\n        }\n    }\n    fn get_data_length(&self) -> usize {\n        ((self.lower / 1024) * 128 + if (self.lower % 1024) <= 895 { 128 } else { 256 }) as usize\n    }\n    fn seek_remainder_octet(&self) -> usize {\n        // self % 8\n        (self.lower & 0b111) as usize\n    }\n    fn get_octet_vec(&self) -> Vec<u8> {\n        let mut vec: Vec<u8> = Vec::with_capacity(16);\n        for j in 0..8 {\n            vec.push((self.uppper >> (56 - j * 8) as u32) as u8);\n        }\n        for j in 0..8 {\n            vec.push((self.lower >> (56 - j * 8) as u32) as u8);\n        }\n        vec\n    }\n}\n\n/// \u30e1\u30c3\u30bb\u30fc\u30b8\u306b\u30d1\u30c7\u30a3\u30f3\u30b0\u3092\u8ffd\u52a0\u3059\u308b\u3002\nfn add_padding(message: &Vec<u8>, length: Length) -> Vec<u8> {\n    let data_len = length.get_data_length();\n    let mut data: Vec<u8> = Vec::with_capacity(data_len);\n\n    // copy message\n    for byte in message.iter() {\n        data.push(*byte);\n    }\n\n    // add padding\n    if length.seek_remainder_octet() == 0 {\n        data.push(0x80);\n    } else {\n        let len = data.len();\n        data[len - 1] |= 1 << (7 - length.seek_remainder_octet()) as u32;\n    }\n    for _ in 0..(data_len - data.len() - 16) {\n        data.push(0x00);\n    }\n    for byte in length.get_octet_vec().iter() {\n        data.push(*byte);\n    }\n\n    data\n}\n\n/// \u30cf\u30c3\u30b7\u30e5\u9577\npub enum Sha521DigestSize {\n    Len224 = 224,\n    Len256 = 256,\n    Len384 = 384,\n    Len512 = 512,\n}\n\n/// \u30cf\u30c3\u30b7\u30e5\u306e\u53d6\u5f97\u3002message \u306b\u30e1\u30c3\u30bb\u30fc\u30b8\u3092\u4ee3\u5165\u3057\u3001 message_length \u306b\u30e1\u30c3\u30bb\u30fc\u30b8\u9577\u3092\u4ee3\u5165\u3059\u308b\u3002\npub fn create_hash(message: &Vec<u8>, message_length: Length, digest_size: Sha521DigestSize) -> Box<[u8]> {\n    // \u30d1\u30c7\u30a3\u30f3\u30b0\u306e\u8ffd\u52a0\n    let data = add_padding(message, message_length);\n    // \u30c7\u30fc\u30bf\u3092\u30d6\u30ed\u30c3\u30af\u306b\u5206\u5272\n    let blocks = separate_data(data);\n    // \u521d\u671f\u5024\n    let mut state = match digest_size {\n        Sha521DigestSize::Len224 => [\n            0x8c3d37c819544da2,\n            0x73e1996689dcd4d6,\n            0x1dfab7ae32ff9c82,\n            0x679dd514582f9fcf,\n            0x0f6d2b697bd44da8,\n            0x77e36f7304c48942,\n            0x3f9d85a86a1d36c8,\n            0x1112e6ad91d692a1\n        ],\n        Sha521DigestSize::Len256 => [\n            0x22312194fc2bf72c,\n            0x9f555fa3c84c64c2,\n            0x2393b86b6f53b151,\n            0x963877195940eabd,\n            0x96283ee2a88effe3,\n            0xbe5e1e2553863992,\n            0x2b0199fc2c85b8aa,\n            0x0eb72ddc81c52ca2\n        ],\n        Sha521DigestSize::Len384 => [\n            0xcbbb9d5dc1059ed8,\n            0x629a292a367cd507,\n            0x9159015a3070dd17,\n            0x152fecd8f70e5939,\n            0x67332667ffc00b31,\n            0x8eb44a8768581511,\n            0xdb0c2e0d64f98fa7,\n            0x47b5481dbefa4fa4\n        ],\n        Sha521DigestSize::Len512 => [\n            0x6a09e667f3bcc908,\n            0xbb67ae8584caa73b,\n            0x3c6ef372fe94f82b,\n            0xa54ff53a5f1d36f1,\n            0x510e527fade682d1,\n            0x9b05688c2b3e6c1f,\n            0x1f83d9abfb41bd6b,\n            0x5be0cd19137e2179\n        ],\n    };\n    // \u30d6\u30ed\u30c3\u30af\u3092\u5727\u7e2e\u95a2\u6570\u306b\u4ee3\u5165\n    for block in blocks.iter() {\n        state = round(state, *block);\n    }\n    // \u30cf\u30c3\u30b7\u30e5\u306e\u4f5c\u6210\n    let hash_length = digest_size as usize;\n    let mut hash: Vec<u8> = Vec::with_capacity(hash_length);\n    let mut length = 0;\n    'outer: for h in state.iter() {\n        use std::mem::transmute;\n\n        let from = if cfg!(target_endian = \"big\") {\n            *h\n        } else {\n            (*h).swap_bytes()\n        };\n        for byte in unsafe { transmute::<u64, [u8; 8]>(from) }.iter() {\n            hash.push(*byte);\n            length += 8;\n            if length == hash_length as usize {\n                break 'outer;\n            }\n        }\n    }\n\n    // \u623b\u308a\u5024\n    hash.into_boxed_slice()\n}\n```\n\n\u3053\u306e\u30d7\u30ed\u30b0\u30e9\u30e0\u306f\u3001 `create_hash` \u95a2\u6570\u306e\u7b2c1\u5f15\u6570\u306b\u30e1\u30c3\u30bb\u30fc\u30b8 ( `Vec<u8>` \u578b ) \u3001\u7b2c2\u5f15\u6570\u306b\u30e1\u30c3\u30bb\u30fc\u30b8\u9577 ( `Length` \u578b ) \u3001\u7b2c3\u5f15\u6570\u306b\u30cf\u30c3\u30b7\u30e5\u9577 ( `Sha521DigestSize` \u578b ) \u3092\u4ee3\u5165\u3057\u3066\u3067\u30cf\u30c3\u30b7\u30e5 ( `Box<[u8]>` \u578b ) \u3092\u53d6\u5f97\u3059\u308b\u3002\n\u6b21\u306e\u30b3\u30fc\u30c9\u306f\u3001\u7a7a\u306e\u30e1\u30c3\u30bb\u30fc\u30b8\u304b\u3089 SHA-512 \u3092\u53d6\u5f97\u3059\u308b\u4f8b\u3067\u3042\u308b\u3002\n\n```rust\nlet message: Vec<u8> = vec![];\nlet hash = create_hash(&message, Length::new(0), Sha521DigestSize::Len512);\n```\n\n###\u30c6\u30b9\u30c8\n\n\u7a7a\u306e\u30e1\u30c3\u30bb\u30fc\u30b8 \"\" \u306e\u30cf\u30c3\u30b7\u30e5\n\n|\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0|\u30cf\u30c3\u30b7\u30e5|\n|---|---|\n|SHA-384    | 38b060a751ac9638 4cd9327eb1b1e36a 21fdb71114be0743 4c0cc7bf63f6e1da 274edebfe76f65fb d51ad2f14898b95b |\n|SHA-512    | cf83e1357eefb8bd f1542850d66d8007 d620e4050b5715dc 83f4a921d36ce9ce 47d0d13c5d85f2b0 ff8318d2877eec2f 63b931bd47417a81 a538327af927da3e |\n|SHA-512/224| 6b4e03423667dbb7 3b6e15454f0eb1ab d4597f9a1b078e3f 5b5a6bc7 |\n|SHA-512/256| a7ffc6f8bf1ed766 51c14756a061d662 f580ff4de43b49fa 82d80a4b80f8434a |\n\n```rust:sha512_empty_message_tests\n/// \u7a7a\u306e\u30e1\u30c3\u30bb\u30fc\u30b8 \"\" \u306b\u5bfe\u3057 SHA384 \u3092\u53d6\u308b\n#[test]\nfn sha2_384_hash_by_empty_msg() {\n    let hash = create_hash(&vec![], Length::new(0), Sha521DigestSize::Len384);\n    assert_eq!(hash, vec![\n        0x38, 0xb0, 0x60, 0xa7, 0x51, 0xac, 0x96, 0x38,\n        0x4c, 0xd9, 0x32, 0x7e, 0xb1, 0xb1, 0xe3, 0x6a,\n        0x21, 0xfd, 0xb7, 0x11, 0x14, 0xbe, 0x07, 0x43,\n        0x4c, 0x0c, 0xc7, 0xbf, 0x63, 0xf6, 0xe1, 0xda,\n        0x27, 0x4e, 0xde, 0xbf, 0xe7, 0x6f, 0x65, 0xfb,\n        0xd5, 0x1a, 0xd2, 0xf1, 0x48, 0x98, 0xb9, 0x5b\n    ].into_boxed_slice());\n}\n/// \u7a7a\u306e\u30e1\u30c3\u30bb\u30fc\u30b8 \"\" \u306b\u5bfe\u3057 SHA512 \u3092\u53d6\u308b\n#[test]\nfn sha2_512_hash_by_empty_msg() {\n    let hash = create_hash(&vec![], Length::new(0), Sha521DigestSize::Len512);\n    assert_eq!(hash, vec![\n        0xcf, 0x83, 0xe1, 0x35, 0x7e, 0xef, 0xb8, 0xbd,\n        0xf1, 0x54, 0x28, 0x50, 0xd6, 0x6d, 0x80, 0x07,\n        0xd6, 0x20, 0xe4, 0x05, 0x0b, 0x57, 0x15, 0xdc,\n        0x83, 0xf4, 0xa9, 0x21, 0xd3, 0x6c, 0xe9, 0xce,\n        0x47, 0xd0, 0xd1, 0x3c, 0x5d, 0x85, 0xf2, 0xb0,\n        0xff, 0x83, 0x18, 0xd2, 0x87, 0x7e, 0xec, 0x2f,\n        0x63, 0xb9, 0x31, 0xbd, 0x47, 0x41, 0x7a, 0x81,\n        0xa5, 0x38, 0x32, 0x7a, 0xf9, 0x27, 0xda, 0x3e\n    ].into_boxed_slice());\n}\n/// \u7a7a\u306e\u30e1\u30c3\u30bb\u30fc\u30b8 \"\" \u306b\u5bfe\u3057 SHA521/224 \u3092\u53d6\u308b\n#[test]\nfn sha2_224_by_512_hash_by_empty_msg() {\n    let hash = create_hash(&vec![], Length::new(0), Sha521DigestSize::Len224);\n    assert_eq!(hash, vec![\n        0x6e, 0xd0, 0xdd, 0x02, 0x80, 0x6f, 0xa8, 0x9e,\n        0x25, 0xde, 0x06, 0x0c, 0x19, 0xd3, 0xac, 0x86,\n        0xca, 0xbb, 0x87, 0xd6, 0xa0, 0xdd, 0xd0, 0x5c,\n        0x33, 0x3b, 0x84, 0xf4\n    ].into_boxed_slice());\n}\n/// \u7a7a\u306e\u30e1\u30c3\u30bb\u30fc\u30b8 \"\" \u306b\u5bfe\u3057 SHA521/256 \u3092\u53d6\u308b\n#[test]\nfn sha2_256_by_512_hash_by_empty_msg() {\n    let hash = create_hash(&vec![], Length::new(0), Sha521DigestSize::Len256);\n    assert_eq!(hash, vec![\n        0xc6, 0x72, 0xb8, 0xd1, 0xef, 0x56, 0xed, 0x28,\n        0xab, 0x87, 0xc3, 0x62, 0x2c, 0x51, 0x14, 0x06,\n        0x9b, 0xdd, 0x3a, 0xd7, 0xb8, 0xf9, 0x73, 0x74,\n        0x98, 0xd0, 0xc0, 0x1e, 0xce, 0xf0, 0x96, 0x7a\n    ].into_boxed_slice());\n}\n```\n\n\u30e1\u30c3\u30bb\u30fc\u30b8\u304c \"abc\" \u306e\u30cf\u30c3\u30b7\u30e5\n\n|\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0|\u30cf\u30c3\u30b7\u30e5|\n|---|---|\n|SHA-384    | cb00753f45a35e8b b5a03d699ac65007 272c32ab0eded163 1a8b605a43ff5bed 8086072ba1e7cc23 58baeca134c825a7 |\n|SHA-512    | ddaf35a193617aba cc417349ae204131 12e6fa4e89a97ea2 0a9eeee64b55d39a 2192992a274fc1a8 36ba3c23a3feebbd 454d4423643ce80e 2a9ac94fa54ca49f |\n\n```rust:sha512_abc_message_tests\n/// \u30e1\u30c3\u30bb\u30fc\u30b8 \"abc\" \u306b\u5bfe\u3057 SHA384 \u3092\u53d6\u308b\n#[test]\nfn sha2_384_hash_by_abc_msg() {\n    let hash = create_hash(&vec![b'a', b'b', b'c'], Length::new(24), Sha521DigestSize::Len384);\n    assert_eq!(hash, vec![\n        0xcb, 0x00, 0x75, 0x3f, 0x45, 0xa3, 0x5e, 0x8b,\n        0xb5, 0xa0, 0x3d, 0x69, 0x9a, 0xc6, 0x50, 0x07,\n        0x27, 0x2c, 0x32, 0xab, 0x0e, 0xde, 0xd1, 0x63,\n        0x1a, 0x8b, 0x60, 0x5a, 0x43, 0xff, 0x5b, 0xed,\n        0x80, 0x86, 0x07, 0x2b, 0xa1, 0xe7, 0xcc, 0x23,\n        0x58, 0xba, 0xec, 0xa1, 0x34, 0xc8, 0x25, 0xa7\n    ].into_boxed_slice());\n}\n/// \u30e1\u30c3\u30bb\u30fc\u30b8 \"abc\" \u306b\u5bfe\u3057 SHA512 \u3092\u53d6\u308b\n#[test]\nfn sha2_512_hash_by_abc_msg() {\n    let hash = create_hash(&vec![b'a', b'b', b'c'], Length::new(24), Sha521DigestSize::Len512);\n    assert_eq!(hash, vec![\n        0xdd, 0xaf, 0x35, 0xa1, 0x93, 0x61, 0x7a, 0xba,\n        0xcc, 0x41, 0x73, 0x49, 0xae, 0x20, 0x41, 0x31,\n        0x12, 0xe6, 0xfa, 0x4e, 0x89, 0xa9, 0x7e, 0xa2,\n        0x0a, 0x9e, 0xee, 0xe6, 0x4b, 0x55, 0xd3, 0x9a,\n        0x21, 0x92, 0x99, 0x2a, 0x27, 0x4f, 0xc1, 0xa8,\n        0x36, 0xba, 0x3c, 0x23, 0xa3, 0xfe, 0xeb, 0xbd,\n        0x45, 0x4d, 0x44, 0x23, 0x64, 0x3c, 0xe8, 0x0e,\n        0x2a, 0x9a, 0xc9, 0x4f, 0xa5, 0x4c, 0xa4, 0x9f\n    ].into_boxed_slice());\n}\n```\n\n\u30e1\u30c3\u30bb\u30fc\u30b8\u304c x \u30d3\u30c3\u30c8\u306e 0 \u3067\u3042\u308b SHA-512 \u30cf\u30c3\u30b7\u30e5\n\n|\u30d3\u30c3\u30c8\u6570|\u30cf\u30c3\u30b7\u30e5|\n|---|---|\n|895| 12DD83C5B6547758 452DC7020EE32F53 F5A0EB65D33C4D3F EEBCE17D7113DB14 0393C8FBE49FC071 E40B585DF969C7AA 3A8196CE2B94E83E 7941EC05E2018751 |\n|896| 2BE2E788C8A8ADEA A9C89A7F78904CAC EA6E39297D75E057 3A73C756234534D6 627AB4156B48A665 7B29AB8BEB733340 40AD39EAD81446BB 09C70704EC707952 |\n\n```rust:sha512_x_zero_bits_tests\n/// 895 bit \u306e 0 \u3067\u69cb\u6210\u3055\u308c\u305f\u30e1\u30c3\u30bb\u30fc\u30b8\u306b\u5bfe\u3057 SHA512 \u3092\u53d6\u308b\uff08\u5883\u754c\u30c6\u30b9\u30c8\uff09\n#[test]\nfn sha2_512_hash_by_895_zero_bits() {\n    let hash = create_hash(&vec![\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00\n    ], Length::new(895), Sha521DigestSize::Len512);\n    assert_eq!(hash, vec![\n        0x12, 0xDD, 0x83, 0xC5, 0xB6, 0x54, 0x77, 0x58,\n        0x45, 0x2D, 0xC7, 0x02, 0x0E, 0xE3, 0x2F, 0x53,\n        0xF5, 0xA0, 0xEB, 0x65, 0xD3, 0x3C, 0x4D, 0x3F,\n        0xEE, 0xBC, 0xE1, 0x7D, 0x71, 0x13, 0xDB, 0x14,\n        0x03, 0x93, 0xC8, 0xFB, 0xE4, 0x9F, 0xC0, 0x71,\n        0xE4, 0x0B, 0x58, 0x5D, 0xF9, 0x69, 0xC7, 0xAA,\n        0x3A, 0x81, 0x96, 0xCE, 0x2B, 0x94, 0xE8, 0x3E,\n        0x79, 0x41, 0xEC, 0x05, 0xE2, 0x01, 0x87, 0x51\n    ].into_boxed_slice());\n}\n/// 896 bit \u306e 0 \u3067\u69cb\u6210\u3055\u308c\u305f\u30e1\u30c3\u30bb\u30fc\u30b8\u306b\u5bfe\u3057 SHA512 \u3092\u53d6\u308b\uff08\u5883\u754c\u30c6\u30b9\u30c8\uff09\n#[test]\nfn sha2_512_hash_by_896_zero_bits() {\n    let hash = create_hash(&vec![\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00\n    ], Length::new(896), Sha521DigestSize::Len512);\n    assert_eq!(hash, vec![\n        0x2B, 0xE2, 0xE7, 0x88, 0xC8, 0xA8, 0xAD, 0xEA,\n        0xA9, 0xC8, 0x9A, 0x7F, 0x78, 0x90, 0x4C, 0xAC,\n        0xEA, 0x6E, 0x39, 0x29, 0x7D, 0x75, 0xE0, 0x57,\n        0x3A, 0x73, 0xC7, 0x56, 0x23, 0x45, 0x34, 0xD6,\n        0x62, 0x7A, 0xB4, 0x15, 0x6B, 0x48, 0xA6, 0x65,\n        0x7B, 0x29, 0xAB, 0x8B, 0xEB, 0x73, 0x33, 0x40,\n        0x40, 0xAD, 0x39, 0xEA, 0xD8, 0x14, 0x46, 0xBB,\n        0x09, 0xC7, 0x07, 0x04, 0xEC, 0x70, 0x79, 0x52\n    ].into_boxed_slice());\n}\n```\n\n\n#\u9010\u6b21\u5b9f\u884c\n\n\u92ed\u3044\u65b9\u306f\u3059\u3067\u306b\u304a\u6c17\u3065\u304d\u304b\u3082\u3057\u308c\u306a\u3044\u304c\u3001\u5b9f\u306f sha256.rs \u3068 sha512.rs \u306f\u5b8c\u5168\u3067\u306f\u306a\u3044\u3002\u30e1\u30c3\u30bb\u30fc\u30b8\u3092\u4ee3\u5165\u3059\u308b\u578b\u306f\u3044\u305a\u308c\u3082 `Vec<u8>` \u578b\u3067\u3042\u308b\u304c\u3001\u3053\u308c\u3067\u306f\u4ed5\u69d8\u304c\u5b9a\u3081\u308b\u6700\u5927\u30e1\u30c3\u30bb\u30fc\u30b8\u9577\u306e\u30e1\u30c3\u30bb\u30fc\u30b8\u3092\u4ee3\u5165\u3067\u304d\u306a\u3044\u3002\n`Vec<u32>` \u3084 `Vec<u64>` \u306b\u62e1\u5f35\u3059\u308b\u3068\u3044\u3046\u624b\u3082\u3042\u308b\u304c\u3001\u30e1\u30e2\u30ea\u3092\u591a\u304f\u5360\u6709\u3059\u308b\u3057\u3001\u6700\u7d42\u7684\u306b\u4e00\u6c17\u306b\u51e6\u7406\u3092\u3057\u306a\u3051\u308c\u3070\u306a\u3089\u306a\u3044\u306e\u3067\u4e0d\u4fbf\u3067\u3042\u308b\u3002\n\u3057\u305f\u304c\u3063\u3066\u3001\u30e1\u30c3\u30bb\u30fc\u30b8\u3092\u66f8\u304d\u8fbc\u3093\u3060\u3089\u3001\u4e00\u6642\u7684\u306b\u30d0\u30c3\u30d5\u30a1\u306b\u6e9c\u3081\u3001\u30d6\u30ed\u30c3\u30af\u30b5\u30a4\u30ba\u307e\u3067\u6e9c\u307e\u308b\u3054\u3068\u306b\u51e6\u7406\u3092\u884c\u3046\u3088\u3046\u306b\u3059\u308b\u3002\u30e1\u30c3\u30bb\u30fc\u30b8\u3092\u3059\u3079\u3066\u66f8\u304d\u8fbc\u3093\u3060\u3089\u30d1\u30c7\u30a3\u30f3\u30b0\u8ffd\u52a0\u51e6\u7406\u3092\u884c\u3048\u3070\u3044\u3044\u3002\n\n```rust:sha2.rs\nuse std::boxed::Box;\n\n\nmacro_rules! Ch {\n    ($x:expr, $y:expr, $z:expr) => { ($x & $y) ^ (!$x & $z) };\n}\nmacro_rules! Maj {\n    ($x:expr, $y:expr, $z:expr) => { ($x & $y) ^ ($x & $z) ^ ($y & $z) };\n}\n\n/// SHA256\u8ffd\u52a0\u5b9a\u6570\nconst K256: [u32; 64] = [\n    0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5,\n    0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n    0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3,\n    0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n    0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc,\n    0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n    0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7,\n    0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n    0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13,\n    0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n    0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3,\n    0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n    0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5,\n    0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n    0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208,\n    0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2\n];\n/// SHA512\u8ffd\u52a0\u5b9a\u6570\nconst K512: [u64; 80] = [\n    0x428a2f98d728ae22, 0x7137449123ef65cd, 0xb5c0fbcfec4d3b2f, 0xe9b5dba58189dbbc,\n    0x3956c25bf348b538, 0x59f111f1b605d019, 0x923f82a4af194f9b, 0xab1c5ed5da6d8118,\n    0xd807aa98a3030242, 0x12835b0145706fbe, 0x243185be4ee4b28c, 0x550c7dc3d5ffb4e2,\n    0x72be5d74f27b896f, 0x80deb1fe3b1696b1, 0x9bdc06a725c71235, 0xc19bf174cf692694,\n    0xe49b69c19ef14ad2, 0xefbe4786384f25e3, 0x0fc19dc68b8cd5b5, 0x240ca1cc77ac9c65,\n    0x2de92c6f592b0275, 0x4a7484aa6ea6e483, 0x5cb0a9dcbd41fbd4, 0x76f988da831153b5,\n    0x983e5152ee66dfab, 0xa831c66d2db43210, 0xb00327c898fb213f, 0xbf597fc7beef0ee4,\n    0xc6e00bf33da88fc2, 0xd5a79147930aa725, 0x06ca6351e003826f, 0x142929670a0e6e70,\n    0x27b70a8546d22ffc, 0x2e1b21385c26c926, 0x4d2c6dfc5ac42aed, 0x53380d139d95b3df,\n    0x650a73548baf63de, 0x766a0abb3c77b2a8, 0x81c2c92e47edaee6, 0x92722c851482353b,\n    0xa2bfe8a14cf10364, 0xa81a664bbc423001, 0xc24b8b70d0f89791, 0xc76c51a30654be30,\n    0xd192e819d6ef5218, 0xd69906245565a910, 0xf40e35855771202a, 0x106aa07032bbd1b8,\n    0x19a4c116b8d2d0c8, 0x1e376c085141ab53, 0x2748774cdf8eeb99, 0x34b0bcb5e19b48a8,\n    0x391c0cb3c5c95a63, 0x4ed8aa4ae3418acb, 0x5b9cca4f7763e373, 0x682e6ff3d6b2b8a3,\n    0x748f82ee5defb2fc, 0x78a5636f43172f60, 0x84c87814a1f0ab72, 0x8cc702081a6439ec,\n    0x90befffa23631e28, 0xa4506cebde82bde9, 0xbef9a3f7b2c67915, 0xc67178f2e372532b,\n    0xca273eceea26619c, 0xd186b8c721c0c207, 0xeada7dd6cde0eb1e, 0xf57d4f7fee6ed178,\n    0x06f067aa72176fba, 0x0a637dc5a2c898a6, 0x113f9804bef90dae, 0x1b710b35131c471b,\n    0x28db77f523047d84, 0x32caab7b40c72493, 0x3c9ebe0a15c9bebc, 0x431d67c49c100d4c,\n    0x4cc5d4becb3e42b6, 0x597f299cfc657e2a, 0x5fcb6fab3ad6faec, 0x6c44198c4a475817\n];\n\nfn large_sigma0_256(x: u32) -> u32 {\n    x.rotate_right( 2) ^ x.rotate_right(13) ^ x.rotate_right(22)\n}\nfn large_sigma1_256(x: u32) -> u32 {\n    x.rotate_right( 6) ^ x.rotate_right(11) ^ x.rotate_right(25)\n}\nfn sigma0_256(x: u32) -> u32 {\n    x.rotate_right( 7) ^ x.rotate_right(18) ^ (x >> 3)\n}\nfn sigma1_256(x: u32) -> u32 {\n    x.rotate_right(17) ^ x.rotate_right(19) ^ (x >> 10)\n}\n\nfn large_sigma0_512(x: u64) -> u64 {\n    x.rotate_right(28) ^ x.rotate_right(34) ^ x.rotate_right(39)\n}\nfn large_sigma1_512(x: u64) -> u64 {\n    x.rotate_right(14) ^ x.rotate_right(18) ^ x.rotate_right(41)\n}\nfn sigma0_512(x: u64) -> u64 {\n    x.rotate_right( 1) ^ x.rotate_right( 8) ^ (x >> 7)\n}\nfn sigma1_512(x: u64) -> u64 {\n    x.rotate_right(19) ^ x.rotate_right(61) ^ (x >> 6)\n}\n\nfn change_u32_to_array_u8(from: u32) -> [u8; 4] {\n    use std::mem::transmute;\n\n    unsafe { transmute::<u32, [u8; 4]>(from.to_be()) }\n}\nfn change_u64_to_array_u32(from: u64) -> [u32; 2] {\n    use std::mem::transmute;\n\n    unsafe { transmute::<u64, [u32; 2]>(from) }\n}\nfn change_u64_to_array_u8(from: u64) -> [u8; 8] {\n    use std::mem::transmute;\n\n    unsafe { transmute::<u64, [u8; 8]>(from.to_be()) }\n}\n\nmacro_rules! add_msg_len {\n    ($self_:expr, $upper:expr, $lower:expr) => ({\n        let (val, overflow) = $self_.lower.overflowing_add($lower);\n        if overflow {\n            let (val, overflow) = $self_.upper.overflowing_add(1);\n            if overflow {\n                return Result::Err(());\n            }\n            $self_.upper = val;\n        }\n        $self_.lower = val;\n        let (val, overflow) = $self_.upper.overflowing_add($upper);\n        if overflow {\n            Result::Err(())\n        } else {\n            $self_.upper = val;\n            Result::Ok(())\n        }\n    })\n}\n\npub struct Length<T> {\n    upper: T,\n    lower: T\n}\nimpl Length<u32> {\n    pub fn new(val: u32) -> Length<u32> {\n        Length {\n            upper: 0,\n            lower: val\n        }\n    }\n    fn add_msg_len(&mut self, oct: usize, rem: u8) -> Result<(), ()> {\n        if oct & (usize::max_value() << 61) > 0 {\n            return Result::Err(());\n        }\n        let arry = change_u64_to_array_u32(((oct as u64) << 3) + rem as u64);\n        add_msg_len!(self, arry[1], arry[0])\n    }\n}\nimpl Length<u64> {\n    pub fn new(val: u64) -> Length<u64> {\n        Length {\n            upper: 0,\n            lower: val\n        }\n    }\n    fn add_msg_len(&mut self, oct: usize, rem: u8) -> Result<(), ()> {\n/*\n        if oct & (usize::max_value() << 125) > 0 {\n            return Result::Err(());\n        }\n*/\n        let arry = [((oct as u64) << 3) + rem as u64, oct as u64 >> 61];\n        add_msg_len!(self, arry[1], arry[0])\n    }\n}\n\ntrait Sha2DataRunner {\n    fn update(&mut self, data: &[u8], rem: u8) -> Result<(), ()>;\n    fn finish(mut self: Box<Self>) -> Box<[u8]>;\n}\n\nstruct Sha2Data<T> {\n    /// \u5165\u529b\u30c7\u30fc\u30bf\u306e\u4e00\u6642\u6e9c\u3081\u7f6e\u304d\n    buffer: [T; 16],\n    /// \u6e9c\u3081\u7f6e\u3044\u3066\u3044\u308b\u30c7\u30fc\u30bf\u306e bit \u30b5\u30a4\u30ba\n    buffer_size: u16,\n    /// \u5185\u90e8\u72b6\u614b\n    state: [T; 8],\n    /// \u30e1\u30c3\u30bb\u30fc\u30b8\u5168\u4f53\u306e bit \u30b5\u30a4\u30ba\n    msg_length: Length<T>,\n    /// \u30cf\u30c3\u30b7\u30e5\u30b5\u30a4\u30ba[bit]\n    length: u16,\n}\n\ntype Sha256 = Sha2Data<u32>;\ntype Sha512 = Sha2Data<u64>;\n\ntype Sha256Length = Length<u32>;\ntype Sha512Length = Length<u64>;\n\nenum Sha256DigestSize {\n    Len224 = 224,\n    Len256 = 256,\n}\n\nimpl Sha256 {\n    fn new(digest: Sha256DigestSize) -> Sha256 {\n        let init_state = match digest {\n            Sha256DigestSize::Len224 => [\n                0xc1059ed8,\n                0x367cd507,\n                0x3070dd17,\n                0xf70e5939,\n                0xffc00b31,\n                0x68581511,\n                0x64f98fa7,\n                0xbefa4fa4\n            ],\n            Sha256DigestSize::Len256 => [\n                0x6a09e667,\n                0xbb67ae85,\n                0x3c6ef372,\n                0xa54ff53a,\n                0x510e527f,\n                0x9b05688c,\n                0x1f83d9ab,\n                0x5be0cd19\n            ]\n        };\n        Sha256 {\n            buffer: [0; 16],\n            buffer_size: 0,\n            state: init_state,\n            msg_length: Sha256Length::new(0),\n            length: digest as u16,\n        }\n    }\n    fn run(&mut self) {\n        let w = {\n            let mut w = [0; 64];\n            for t in 0..16 {\n                w[t] = self.buffer[t];\n            }\n            for t in 16..64 {\n                w[t] = sigma1_256(w[t-2]).wrapping_add(w[t-7])\n                                        .wrapping_add(sigma0_256(w[t-15]))\n                                        .wrapping_add(w[t-16]);\n            }\n            w\n        };\n        let (mut a, mut b, mut c, mut d, mut e, mut f, mut g, mut h) = (\n            self.state[0],\n            self.state[1],\n            self.state[2],\n            self.state[3],\n            self.state[4],\n            self.state[5],\n            self.state[6],\n            self.state[7]\n        );\n        for t in 0..64 {\n            let t1 = h.wrapping_add(large_sigma1_256(e))\n                    .wrapping_add(Ch!(e, f, g))\n                    .wrapping_add(K256[t])\n                    .wrapping_add(w[t]);\n            let t2 = large_sigma0_256(a).wrapping_add(Maj!(a, b, c));\n            h = g;\n            g = f;\n            f = e;\n            e = d.wrapping_add(t1);\n            d = c;\n            c = b;\n            b = a;\n            a = t1.wrapping_add(t2);\n        }\n        self.state = [\n            a.wrapping_add(self.state[0]),\n            b.wrapping_add(self.state[1]),\n            c.wrapping_add(self.state[2]),\n            d.wrapping_add(self.state[3]),\n            e.wrapping_add(self.state[4]),\n            f.wrapping_add(self.state[5]),\n            g.wrapping_add(self.state[6]),\n            h.wrapping_add(self.state[7])\n        ];\n    }\n}\n\nimpl Sha2DataRunner for Sha256 {\n    fn update(&mut self, data: &[u8], rem: u8) -> Result<(), ()> {\n        debug_assert!(if data.len() == 0 { rem == 0 } else { rem > 0 && rem <= 8 });\n\n        let mut num = (self.buffer_size / 32) as usize;\n        let mut bit = (self.buffer_size % 32) as u32;\n        for i in 0..data.len() {\n            let add_data = if i < (data.len() - 1) {\n                bit += 8;\n                data[i] as u32\n            } else {\n                bit += rem as u32;\n                (data[i] & u8::max_value() << (8 - rem)) as u32\n            };\n            self.buffer[num] |= if bit <= 32 {\n                add_data << (32 - bit)\n            } else {\n                add_data >> (bit - 32)\n            };\n            if bit >= 32 {\n                num += 1;\n                bit -= 32;\n                if num >= 16 {\n                    self.run();\n                    self.buffer = [0; 16];\n                    num = 0;\n                }\n                if bit > 0 {\n                    self.buffer[num] |= add_data << (32 - bit);\n                }\n            }\n        }\n        self.buffer_size = (num as u32 * 32 + bit) as u16;\n        if rem == 0 || rem == 8 {\n            self.msg_length.add_msg_len(data.len(), 0)\n        } else {\n            self.msg_length.add_msg_len(data.len() - 1, rem)\n        }\n    }\n    fn finish(mut self: Box<Self>) -> Box<[u8]> {\n        // add padding\n        let idx = (self.buffer_size / 32) as usize;\n        let shift = 31 - self.buffer_size % 32;\n        self.buffer[idx] |= 0x1 << shift;\n        if idx >= 14 {\n            self.run();\n            self.buffer = [0; 16];\n            self.buffer_size = 0;\n        }\n        self.buffer[14] = self.msg_length.upper;\n        self.buffer[15] = self.msg_length.lower;\n        self.run();\n\n        // create hash\n        let mut result: Vec<u8> = Vec::with_capacity(self.length as usize / 8);\n        let mut length = 0;\n        'outer: for x in self.state.iter() {\n            let array = change_u32_to_array_u8(*x);\n            for byte in array.iter() {\n                result.push(*byte);\n                length += 8;\n                if length == self.length {\n                    break 'outer;\n                }\n            }\n        }\n        result.into_boxed_slice()\n    }\n}\n\nenum Sha512DigestSize {\n    Len224 = 224,\n    Len256 = 256,\n    Len384 = 384,\n    Len512 = 512,\n}\n\nimpl Sha512 {\n    pub fn new(digest: Sha512DigestSize) -> Sha512 {\n        let init_state = match digest {\n            Sha512DigestSize::Len384 => [\n                0xcbbb9d5dc1059ed8,\n                0x629a292a367cd507,\n                0x9159015a3070dd17,\n                0x152fecd8f70e5939,\n                0x67332667ffc00b31,\n                0x8eb44a8768581511,\n                0xdb0c2e0d64f98fa7,\n                0x47b5481dbefa4fa4\n            ],\n            Sha512DigestSize::Len512 => [\n                0x6a09e667f3bcc908,\n                0xbb67ae8584caa73b,\n                0x3c6ef372fe94f82b,\n                0xa54ff53a5f1d36f1,\n                0x510e527fade682d1,\n                0x9b05688c2b3e6c1f,\n                0x1f83d9abfb41bd6b,\n                0x5be0cd19137e2179\n            ],\n            Sha512DigestSize::Len224 => [\n                0x8c3d37c819544da2,\n                0x73e1996689dcd4d6,\n                0x1dfab7ae32ff9c82,\n                0x679dd514582f9fcf,\n                0x0f6d2b697bd44da8,\n                0x77e36f7304c48942,\n                0x3f9d85a86a1d36c8,\n                0x1112e6ad91d692a1\n            ],\n            Sha512DigestSize::Len256 => [\n                0x22312194fc2bf72c,\n                0x9f555fa3c84c64c2,\n                0x2393b86b6f53b151,\n                0x963877195940eabd,\n                0x96283ee2a88effe3,\n                0xbe5e1e2553863992,\n                0x2b0199fc2c85b8aa,\n                0x0eb72ddc81c52ca2\n            ]\n        };\n\n        Sha2Data {\n            buffer: [0; 16],\n            buffer_size: 0,\n            state: init_state,\n            msg_length: Sha512Length::new(0),\n            length: digest as u16,\n        }\n    }\n    fn run(&mut self) {\n        let w = {\n            let mut w = [0; 80];\n            for t in 0..16 {\n                w[t] = self.buffer[t];\n            }\n            for t in 16..80 {\n                w[t] = sigma1_512(w[t-2]).wrapping_add(w[t-7])\n                                         .wrapping_add(sigma0_512(w[t-15]))\n                                         .wrapping_add(w[t-16]);\n            }\n            w\n        };\n        let (mut a, mut b, mut c, mut d, mut e, mut f, mut g, mut h) = (\n            self.state[0],\n            self.state[1],\n            self.state[2],\n            self.state[3],\n            self.state[4],\n            self.state[5],\n            self.state[6],\n            self.state[7]\n        );\n        for t in 0..80 {\n            let t1 = h.wrapping_add(large_sigma1_512(e))\n                      .wrapping_add(Ch!(e, f, g))\n                      .wrapping_add(K512[t])\n                      .wrapping_add(w[t]);\n            let t2 = large_sigma0_512(a).wrapping_add(Maj!(a, b, c));\n            h = g;\n            g = f;\n            f = e;\n            e = d.wrapping_add(t1);\n            d = c;\n            c = b;\n            b = a;\n            a = t1.wrapping_add(t2);\n        }\n        self.state = [\n            a.wrapping_add(self.state[0]),\n            b.wrapping_add(self.state[1]),\n            c.wrapping_add(self.state[2]),\n            d.wrapping_add(self.state[3]),\n            e.wrapping_add(self.state[4]),\n            f.wrapping_add(self.state[5]),\n            g.wrapping_add(self.state[6]),\n            h.wrapping_add(self.state[7])\n        ];\n    }\n}\nimpl Sha2DataRunner for Sha512 {\n    fn update(&mut self, data: &[u8], rem: u8) -> Result<(), ()> {\n        debug_assert!(if data.len() == 0 { rem == 0 } else { rem > 0 && rem <= 8 });\n\n        let mut num = (self.buffer_size / 64) as usize;\n        let mut bit = (self.buffer_size % 64) as u32;\n        for i in 0..data.len() {\n            let add_data = if i < (data.len() - 1) {\n                bit += 8;\n                data[i] as u64\n            } else {\n                bit += rem as u32;\n                (data[i] & u8::max_value() << (8 - rem)) as u64\n            };\n            self.buffer[num] |= if bit <= 64 {\n                add_data << (64 - bit)\n            } else {\n                add_data >> (bit - 64)\n            };\n            if bit >= 64 {\n                num += 1;\n                bit -= 64;\n                if num >= 16 {\n                    self.run();\n                    self.buffer = [0; 16];\n                    num = 0;\n                }\n                if bit > 0 {\n                    self.buffer[num] |= add_data << (64 - bit);\n                }\n            }\n        }\n        self.buffer_size = (num as u32 * 64 + bit) as u16;\n        if rem == 0 || rem == 8 {\n            self.msg_length.add_msg_len(data.len(), 0)\n        } else {\n            self.msg_length.add_msg_len(data.len() - 1, rem)\n        }\n    }\n    fn finish(mut self: Box<Self>) -> Box<[u8]> {\n        // add padding\n        let idx = (self.buffer_size / 64) as usize;\n        let shift = 63 - self.buffer_size % 64;\n        self.buffer[idx] |= 0x1 << shift;\n        if idx >= 14 {\n            self.run();\n            self.buffer = [0; 16];\n            self.buffer_size = 0;\n        }\n        self.buffer[14] = self.msg_length.upper;\n        self.buffer[15] = self.msg_length.lower;\n        self.run();\n\n        // create hash\n        let mut result: Vec<u8> = Vec::with_capacity(self.length as usize / 8);\n        let mut length = 0;\n        'outer: for x in self.state.iter() {\n            let array = change_u64_to_array_u8(*x);\n            for byte in array.iter() {\n                result.push(*byte);\n                length += 8;\n                if length == self.length {\n                    break 'outer;\n                }\n            }\n        }\n        result.into_boxed_slice()\n    }\n}\n\npub enum Sha2HashType {\n    /// SHA 224\n    Len224,\n    /// SHA 256\n    Len256,\n    /// SHA 384\n    Len384,\n    /// SHA 512\n    Len512,\n    /// SHA 512/224\n    Len224By512,\n    /// SHA 512/256\n    Len256By512\n}\n\npub struct Sha2 {\n    data: Box<Sha2DataRunner>\n}\nimpl Sha2 {\n    pub fn new(hash_type: Sha2HashType) -> Self {\n        let data: Box<Sha2DataRunner> = match hash_type {\n            Sha2HashType::Len224 => Box::new(Sha256::new(\n                Sha256DigestSize::Len224\n            )),\n            Sha2HashType::Len256 => Box::new(Sha256::new(\n                Sha256DigestSize::Len256\n            )),\n            Sha2HashType::Len384 => Box::new(Sha512::new(\n                Sha512DigestSize::Len384\n            )),\n            Sha2HashType::Len512 => Box::new(Sha512::new(\n                Sha512DigestSize::Len512\n            )),\n            Sha2HashType::Len224By512 => Box::new(Sha512::new(\n                Sha512DigestSize::Len224\n            )),\n            Sha2HashType::Len256By512 => Box::new(Sha512::new(\n                Sha512DigestSize::Len256\n            ))\n        };\n        Sha2 {\n            data: data\n        }\n    }\n    pub fn push(&mut self, data: &[u8], rem: u8) -> Result<(), ()> {\n        self.data.update(data, rem)\n    }\n    pub fn finish(self) -> Box<[u8]> {\n        self.data.finish()\n    }\n}\n\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    /// \u7a7a\u306e\u30e1\u30c3\u30bb\u30fc\u30b8 \"\" \u306b\u5bfe\u3057 SHA-224 \u3092\u53d6\u308b\n    #[test]\n    fn sha2_224_hash_by_empty_msg() {\n        let sha2 = Sha2::new(Sha2HashType::Len224);\n        let hash = sha2.finish();\n        assert_eq!(hash, vec![\n            0xd1, 0x4a, 0x02, 0x8c, 0x2a, 0x3a, 0x2b, 0xc9,\n            0x47, 0x61, 0x02, 0xbb, 0x28, 0x82, 0x34, 0xc4,\n            0x15, 0xa2, 0xb0, 0x1f, 0x82, 0x8e, 0xa6, 0x2a,\n            0xc5, 0xb3, 0xe4, 0x2f\n        ].into_boxed_slice());\n    }\n    /// \u30e1\u30c3\u30bb\u30fc\u30b8 \"abc\" \u306b\u5bfe\u3057 SHA-224 \u3092\u53d6\u308b\n    #[test]\n    fn sha2_224_hash_by_abc_msg() {\n        let mut sha2 = Sha2::new(Sha2HashType::Len224);\n        sha2.push(b\"abc\".as_ref(), 8).unwrap();\n        let hash = sha2.finish();\n        assert_eq!(hash, vec![\n            0x23, 0x09, 0x7d, 0x22, 0x34, 0x05, 0xd8, 0x22,\n            0x86, 0x42, 0xa4, 0x77, 0xbd, 0xa2, 0x55, 0xb3,\n            0x2a, 0xad, 0xbc, 0xe4, 0xbd, 0xa0, 0xb3, 0xf7,\n            0xe3, 0x6c, 0x9d, 0xa7\n        ].into_boxed_slice());\n    }\n    /// \u7a7a\u306e\u30e1\u30c3\u30bb\u30fc\u30b8 \"\" \u306b\u5bfe\u3057 SHA-256 \u3092\u53d6\u308b\n    #[test]\n    fn sha2_256_hash_by_empty_msg() {\n        let sha2 = Sha2::new(Sha2HashType::Len256);\n        let hash = sha2.finish();\n        assert_eq!(hash, vec![\n            0xe3, 0xb0, 0xc4, 0x42, 0x98, 0xfc, 0x1c, 0x14,\n            0x9a, 0xfb, 0xf4, 0xc8, 0x99, 0x6f, 0xb9, 0x24,\n            0x27, 0xae, 0x41, 0xe4, 0x64, 0x9b, 0x93, 0x4c,\n            0xa4, 0x95, 0x99, 0x1b, 0x78, 0x52, 0xb8, 0x55\n        ].into_boxed_slice());\n    }\n    /// \u30e1\u30c3\u30bb\u30fc\u30b8 \"abc\" \u306b\u5bfe\u3057 SHA-256 \u3092\u53d6\u308b\n    #[test]\n    fn sha2_256_hash_by_abc_msg() {\n        let mut sha2 = Sha2::new(Sha2HashType::Len256);\n        sha2.push(b\"abc\".as_ref(), 8).unwrap();\n        let hash = sha2.finish();\n        assert_eq!(hash, vec![\n            0xba, 0x78, 0x16, 0xbf, 0x8f, 0x01, 0xcf, 0xea,\n            0x41, 0x41, 0x40, 0xde, 0x5d, 0xae, 0x22, 0x23,\n            0xb0, 0x03, 0x61, 0xa3, 0x96, 0x17, 0x7a, 0x9c,\n            0xb4, 0x10, 0xff, 0x61, 0xf2, 0x00, 0x15, 0xad\n        ].into_boxed_slice());\n    }\n    /// 447 bits \u306e 0 \u3067\u69cb\u6210\u3055\u308c\u305f\u30e1\u30c3\u30bb\u30fc\u30b8\u306b\u5bfe\u3057 SHA-256 \u3092\u53d6\u308b\n    #[test]\n    fn sha2_256_hash_by_447_zero_bits() {\n        let mut sha2 = Sha2::new(Sha2HashType::Len256);\n        sha2.push(&vec![\n            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        ], 7).unwrap();\n        let hash = sha2.finish();\n        assert_eq!(hash, vec![\n            0x43, 0xfd, 0xd2, 0xee, 0xd4, 0xdf, 0x6d, 0x2c,\n            0x38, 0xe9, 0x71, 0xda, 0x88, 0x41, 0x15, 0x05,\n            0x19, 0x51, 0xaa, 0x68, 0xd8, 0x92, 0x72, 0x0f,\n            0x79, 0x68, 0x9d, 0x49, 0x62, 0xc9, 0xef, 0xae\n        ].into_boxed_slice());\n    }\n    /// 448 bits \u306e 0 \u3067\u69cb\u6210\u3055\u308c\u305f\u30e1\u30c3\u30bb\u30fc\u30b8\u306b\u5bfe\u3057 SHA-256 \u3092\u53d6\u308b\n    #[test]\n    fn sha2_256_hash_by_448_zero_bits() {\n        let mut sha2 = Sha2::new(Sha2HashType::Len256);\n        sha2.push(&vec![\n            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        ], 8).unwrap();\n        let hash = sha2.finish();\n        assert_eq!(hash, vec![\n            0xd4, 0x81, 0x7a, 0xa5, 0x49, 0x76, 0x28, 0xe7,\n            0xc7, 0x7e, 0x6b, 0x60, 0x61, 0x07, 0x04, 0x2b,\n            0xbb, 0xa3, 0x13, 0x08, 0x88, 0xc5, 0xf4, 0x7a,\n            0x37, 0x5e, 0x61, 0x79, 0xbe, 0x78, 0x9f, 0xbb\n        ].into_boxed_slice());\n    }\n    /// 448 bits \u306e 0 \u3067\u69cb\u6210\u3055\u308c\u305f\u30e1\u30c3\u30bb\u30fc\u30b8\u306b\u5bfe\u3057 SHA-256 \u3092\u53d6\u308b\n    #[test]\n    fn sha2_256_hash_by_448_bits_ascii_msg() {\n        let mut sha2 = Sha2::new(Sha2HashType::Len256);\n        sha2.push(b\"abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq\".as_ref(), 8).unwrap();\n        let hash = sha2.finish();\n        assert_eq!(hash, vec![\n            0x24, 0x8d, 0x6a, 0x61, 0xd2, 0x06, 0x38, 0xb8,\n            0xe5, 0xc0, 0x26, 0x93, 0x0c, 0x3e, 0x60, 0x39,\n            0xa3, 0x3c, 0xe4, 0x59, 0x64, 0xff, 0x21, 0x67,\n            0xf6, 0xec, 0xed, 0xd4, 0x19, 0xdb, 0x06, 0xc1\n        ].into_boxed_slice());\n    }\n\n    /// \u7a7a\u306e\u30e1\u30c3\u30bb\u30fc\u30b8 \"\" \u306b\u5bfe\u3057 SHA521/224 \u3092\u53d6\u308b\n    #[test]\n    fn sha2_224_by_512_hash_by_empty_msg() {\n        let sha2 = Sha2::new(Sha2HashType::Len224By512);\n        let hash = sha2.finish();\n        assert_eq!(hash, vec![\n            0x6e, 0xd0, 0xdd, 0x02, 0x80, 0x6f, 0xa8, 0x9e,\n            0x25, 0xde, 0x06, 0x0c, 0x19, 0xd3, 0xac, 0x86,\n            0xca, 0xbb, 0x87, 0xd6, 0xa0, 0xdd, 0xd0, 0x5c,\n            0x33, 0x3b, 0x84, 0xf4\n        ].into_boxed_slice());\n    }\n    /// \u7a7a\u306e\u30e1\u30c3\u30bb\u30fc\u30b8 \"\" \u306b\u5bfe\u3057 SHA521/256 \u3092\u53d6\u308b\n    #[test]\n    fn sha2_256_by_512_hash_by_empty_msg() {\n        let sha2 = Sha2::new(Sha2HashType::Len256By512);\n        let hash = sha2.finish();\n        assert_eq!(hash, vec![\n            0xc6, 0x72, 0xb8, 0xd1, 0xef, 0x56, 0xed, 0x28,\n            0xab, 0x87, 0xc3, 0x62, 0x2c, 0x51, 0x14, 0x06,\n            0x9b, 0xdd, 0x3a, 0xd7, 0xb8, 0xf9, 0x73, 0x74,\n            0x98, 0xd0, 0xc0, 0x1e, 0xce, 0xf0, 0x96, 0x7a\n        ].into_boxed_slice());\n    }\n    /// \u7a7a\u306e\u30e1\u30c3\u30bb\u30fc\u30b8 \"\" \u306b\u5bfe\u3057 SHA384 \u3092\u53d6\u308b\n    #[test]\n    fn sha2_384_hash_by_empty_msg() {\n        let sha2 = Sha2::new(Sha2HashType::Len384);\n        let hash = sha2.finish();\n        assert_eq!(hash, vec![\n            0x38, 0xb0, 0x60, 0xa7, 0x51, 0xac, 0x96, 0x38,\n            0x4c, 0xd9, 0x32, 0x7e, 0xb1, 0xb1, 0xe3, 0x6a,\n            0x21, 0xfd, 0xb7, 0x11, 0x14, 0xbe, 0x07, 0x43,\n            0x4c, 0x0c, 0xc7, 0xbf, 0x63, 0xf6, 0xe1, 0xda,\n            0x27, 0x4e, 0xde, 0xbf, 0xe7, 0x6f, 0x65, 0xfb,\n            0xd5, 0x1a, 0xd2, 0xf1, 0x48, 0x98, 0xb9, 0x5b\n        ].into_boxed_slice());\n    }\n    /// \u30e1\u30c3\u30bb\u30fc\u30b8 \"abc\" \u306b\u5bfe\u3057 SHA384 \u3092\u53d6\u308b\n    #[test]\n    fn sha2_384_hash_by_abc_msg() {\n        let mut sha2 = Sha2::new(Sha2HashType::Len384);\n        sha2.push(b\"abc\".as_ref(), 8).unwrap();\n        let hash = sha2.finish();\n        assert_eq!(hash, vec![\n            0xcb, 0x00, 0x75, 0x3f, 0x45, 0xa3, 0x5e, 0x8b,\n            0xb5, 0xa0, 0x3d, 0x69, 0x9a, 0xc6, 0x50, 0x07,\n            0x27, 0x2c, 0x32, 0xab, 0x0e, 0xde, 0xd1, 0x63,\n            0x1a, 0x8b, 0x60, 0x5a, 0x43, 0xff, 0x5b, 0xed,\n            0x80, 0x86, 0x07, 0x2b, 0xa1, 0xe7, 0xcc, 0x23,\n            0x58, 0xba, 0xec, 0xa1, 0x34, 0xc8, 0x25, 0xa7\n        ].into_boxed_slice());\n    }\n    /// \u7a7a\u306e\u30e1\u30c3\u30bb\u30fc\u30b8 \"\" \u306b\u5bfe\u3057 SHA512 \u3092\u53d6\u308b\n    #[test]\n    fn sha2_512_hash_by_empty_msg() {\n        let sha2 = Sha2::new(Sha2HashType::Len512);\n        let hash = sha2.finish();\n        assert_eq!(hash, vec![\n            0xcf, 0x83, 0xe1, 0x35, 0x7e, 0xef, 0xb8, 0xbd,\n            0xf1, 0x54, 0x28, 0x50, 0xd6, 0x6d, 0x80, 0x07,\n            0xd6, 0x20, 0xe4, 0x05, 0x0b, 0x57, 0x15, 0xdc,\n            0x83, 0xf4, 0xa9, 0x21, 0xd3, 0x6c, 0xe9, 0xce,\n            0x47, 0xd0, 0xd1, 0x3c, 0x5d, 0x85, 0xf2, 0xb0,\n            0xff, 0x83, 0x18, 0xd2, 0x87, 0x7e, 0xec, 0x2f,\n            0x63, 0xb9, 0x31, 0xbd, 0x47, 0x41, 0x7a, 0x81,\n            0xa5, 0x38, 0x32, 0x7a, 0xf9, 0x27, 0xda, 0x3e\n        ].into_boxed_slice());\n    }\n    /// \u30e1\u30c3\u30bb\u30fc\u30b8 \"abc\" \u306b\u5bfe\u3057 SHA512 \u3092\u53d6\u308b\n    #[test]\n    fn sha2_512_hash_by_abc_msg() {\n        let mut sha2 = Sha2::new(Sha2HashType::Len512);\n        sha2.push(b\"abc\".as_ref(), 8).unwrap();\n        let hash = sha2.finish();\n        assert_eq!(hash, vec![\n            0xdd, 0xaf, 0x35, 0xa1, 0x93, 0x61, 0x7a, 0xba,\n            0xcc, 0x41, 0x73, 0x49, 0xae, 0x20, 0x41, 0x31,\n            0x12, 0xe6, 0xfa, 0x4e, 0x89, 0xa9, 0x7e, 0xa2,\n            0x0a, 0x9e, 0xee, 0xe6, 0x4b, 0x55, 0xd3, 0x9a,\n            0x21, 0x92, 0x99, 0x2a, 0x27, 0x4f, 0xc1, 0xa8,\n            0x36, 0xba, 0x3c, 0x23, 0xa3, 0xfe, 0xeb, 0xbd,\n            0x45, 0x4d, 0x44, 0x23, 0x64, 0x3c, 0xe8, 0x0e,\n            0x2a, 0x9a, 0xc9, 0x4f, 0xa5, 0x4c, 0xa4, 0x9f\n        ].into_boxed_slice());\n    }\n    /// 895 bit \u306e 0 \u3067\u69cb\u6210\u3055\u308c\u305f\u30e1\u30c3\u30bb\u30fc\u30b8\u306b\u5bfe\u3057 SHA512 \u3092\u53d6\u308b\uff08\u5883\u754c\u30c6\u30b9\u30c8\uff09\n    #[test]\n    fn sha2_512_hash_by_895_zero_bits() {\n        let mut sha2 = Sha2::new(Sha2HashType::Len512);\n        sha2.push(&vec![\n            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00\n        ], 7).unwrap();\n        let hash = sha2.finish();\n        assert_eq!(hash, vec![\n            0x12, 0xdd, 0x83, 0xc5, 0xb6, 0x54, 0x77, 0x58,\n            0x45, 0x2d, 0xc7, 0x02, 0x0e, 0xe3, 0x2f, 0x53,\n            0xf5, 0xa0, 0xeb, 0x65, 0xd3, 0x3c, 0x4d, 0x3f,\n            0xee, 0xbc, 0xe1, 0x7d, 0x71, 0x13, 0xdb, 0x14,\n            0x03, 0x93, 0xc8, 0xfb, 0xe4, 0x9f, 0xc0, 0x71,\n            0xe4, 0x0b, 0x58, 0x5d, 0xf9, 0x69, 0xc7, 0xaa,\n            0x3a, 0x81, 0x96, 0xce, 0x2b, 0x94, 0xe8, 0x3e,\n            0x79, 0x41, 0xec, 0x05, 0xe2, 0x01, 0x87, 0x51\n        ].into_boxed_slice());\n    }\n    /// 896 bit \u306e 0 \u3067\u69cb\u6210\u3055\u308c\u305f\u30e1\u30c3\u30bb\u30fc\u30b8\u306b\u5bfe\u3057 SHA512 \u3092\u53d6\u308b\uff08\u5883\u754c\u30c6\u30b9\u30c8\uff09\n    #[test]\n    fn sha2_512_hash_by_896_zero_bits() {\n        let mut sha2 = Sha2::new(Sha2HashType::Len512);\n        sha2.push(&vec![\n            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00\n        ], 8).unwrap();\n        let hash = sha2.finish();\n        assert_eq!(hash, vec![\n            0x2b, 0xe2, 0xe7, 0x88, 0xc8, 0xa8, 0xad, 0xea,\n            0xa9, 0xc8, 0x9a, 0x7f, 0x78, 0x90, 0x4c, 0xac,\n            0xea, 0x6e, 0x39, 0x29, 0x7d, 0x75, 0xe0, 0x57,\n            0x3a, 0x73, 0xc7, 0x56, 0x23, 0x45, 0x34, 0xd6,\n            0x62, 0x7a, 0xb4, 0x15, 0x6b, 0x48, 0xa6, 0x65,\n            0x7b, 0x29, 0xab, 0x8b, 0xeb, 0x73, 0x33, 0x40,\n            0x40, 0xad, 0x39, 0xea, 0xd8, 0x14, 0x46, 0xbb,\n            0x09, 0xc7, 0x07, 0x04, 0xec, 0x70, 0x79, 0x52\n        ].into_boxed_slice());\n    }\n    /// 896 bit \u306e 0 \u3067\u69cb\u6210\u3055\u308c\u305f\u30e1\u30c3\u30bb\u30fc\u30b8\u306b\u5bfe\u3057 SHA512 \u3092\u53d6\u308b\uff08\u5883\u754c\u30c6\u30b9\u30c8\uff09\n    #[test]\n    fn sha2_512_hash_by_896_bits_ascii_msg() {\n        let mut sha2 = Sha2::new(Sha2HashType::Len512);\n        sha2.push(b\"abcdefghbcdefghicdefghijdefghijkefghijklfghijklmghijklmnhijklmnoijklmnopjklmnopqklmnopqrlmnopqrsmnopqrstnopqrstu\".as_ref(), 8).unwrap();\n        let hash = sha2.finish();\n        assert_eq!(hash, vec![\n            0x8e, 0x95, 0x9b, 0x75, 0xda, 0xe3, 0x13, 0xda,\n            0x8c, 0xf4, 0xf7, 0x28, 0x14, 0xfc, 0x14, 0x3f,\n            0x8f, 0x77, 0x79, 0xc6, 0xeb, 0x9f, 0x7f, 0xa1,\n            0x72, 0x99, 0xae, 0xad, 0xb6, 0x88, 0x90, 0x18,\n            0x50, 0x1d, 0x28, 0x9e, 0x49, 0x00, 0xf7, 0xe4,\n            0x33, 0x1b, 0x99, 0xde, 0xc4, 0xb5, 0x43, 0x3a,\n            0xc7, 0xd3, 0x29, 0xee, 0xb6, 0xdd, 0x26, 0x54,\n            0x5e, 0x96, 0xe5, 0x5b, 0x87, 0x4b, 0xe9, 0x09\n        ].into_boxed_slice());\n    }\n}\n```\n\n\n#\u53c2\u8003\u6587\u732e\n\n1. FIPS 180-4 \u226a[http://csrc.nist.gov/publications/fips/fips180-4/fips-180-4.pdf](http://csrc.nist.gov/publications/fips/fips180-4/fips-180-4.pdf)\u226b\n2. SHA-2 - Wikipedia \u226a[https://ja.wikipedia.org/wiki/SHA-2](https://ja.wikipedia.org/wiki/SHA-2)\u226b\n3. SHA-2\u3068\u306f\uff5cSecure Hash Algorighm 2 \uff0d \u610f\u5473 / \u5b9a\u7fa9 / \u89e3\u8aac / \u8aac\u660e \uff1a IT\u7528\u8a9e\u8f9e\u5178 \u226a[http://e-words.jp/w/SHA-2.html](http://e-words.jp/w/SHA-2.html)\u226b\n4. wiz.code [ \u30d1\u30c7\u30a3\u30f3\u30b0\u51e6\u7406 ] \u226a[http://wiz.area.ac/techcode/sha256/page04.aspx](http://wiz.area.ac/techcode/sha256/page04.aspx)\u226b\n5. Test vectors for SHA-1, SHA-2 and SHA-3 \u226a[http://www.di-mgt.com.au/sha_testvectors.html](http://www.di-mgt.com.au/sha_testvectors.html)\u226b\n6. https://www.cosic.esat.kuleuven.be/nessie/testvectors/hash/sha/Sha-2-512.unverified.test-vectors\n", "tags": ["rust1.12.1", "SHA", "sha-2", "SHA-256", "SHA-512"]}