{"context": "https://github.com/avighier/simple-dijs\n\nExamples to use\n    // Simple instanciation\n    var di = new Di();\n    // Also instanciation with services\n    new Di({\n        'database': function () { ... },\n        'userCollection': function (di) { ... }\n    });\n\n    di.set('database', function () {\n        return new Database();\n    });\n\n    di.set('userCollection', function (di) {\n        return new UserCollection(di.get('database'));\n    });\n\n    // Or multiple services\n    di.batchSet({ ..same than construct.. });\n\n    // So, ...\n    di.get('userCollection').find(1); // UserCollection instanciated now !\n    di.get('userCollection').find(1); // The same UserCollection instance\n\n    // If you want to factory instead of return the same object :\n    di.set('userCollection', di.factory(function (di) {\n        return new UserCollection(di.get('database'));\n    }));\n\n    // So, ...\n    di.get('userCollection').find(1); // UserCollection instanciated now !\n    di.get('userCollection').find(1); // Other UserCollection instance now, instanciated now !\n\n    // You can store raw values\n    di.set('port', 80);\n    di.get('port'); // 80\n\n    // Protect function you want to register raw :\n    di.set('math.add', di.protected(function (a, b) {\n        return a + b;\n    }));\n\n    // You can use callbacks (node-style)\n\n    di.set('database', function (di, callback) {\n        dbConnect(url, callback);\n    });\n\n    di.get('database', function (err, database) {\n        database.use('users').query(...);\n    });\n\n    // You can use promise (native or not)\n\n    di.set('async', function () {\n        return new Promise(/*Blabla*/);\n    });\n\n    di.get('async').then(function () {\n        // ...\n    });\n\n    // You can chain the methods calls\n    (new Di()).set(...).set(...);\n\nhttps://github.com/avighier/simple-dijs\n\n## Examples to use\n\n```javascript\n    // Simple instanciation\n    var di = new Di();\n    // Also instanciation with services\n    new Di({\n        'database': function () { ... },\n        'userCollection': function (di) { ... }\n    });\n    \n    di.set('database', function () {\n        return new Database();\n    });\n\n    di.set('userCollection', function (di) {\n        return new UserCollection(di.get('database'));\n    });\n    \n    // Or multiple services\n    di.batchSet({ ..same than construct.. });\n\n    // So, ...\n    di.get('userCollection').find(1); // UserCollection instanciated now !\n    di.get('userCollection').find(1); // The same UserCollection instance\n   \n    // If you want to factory instead of return the same object :\n    di.set('userCollection', di.factory(function (di) {\n        return new UserCollection(di.get('database'));\n    }));\n    \n    // So, ...\n    di.get('userCollection').find(1); // UserCollection instanciated now !\n    di.get('userCollection').find(1); // Other UserCollection instance now, instanciated now !\n    \n    // You can store raw values\n    di.set('port', 80);\n    di.get('port'); // 80\n    \n    // Protect function you want to register raw :\n    di.set('math.add', di.protected(function (a, b) {\n        return a + b;\n    }));\n\n    // You can use callbacks (node-style)\n\n    di.set('database', function (di, callback) {\n        dbConnect(url, callback);\n    });\n\n    di.get('database', function (err, database) {\n        database.use('users').query(...);\n    });\n\n    // You can use promise (native or not)\n    \n    di.set('async', function () {\n        return new Promise(/*Blabla*/);\n    });\n    \n    di.get('async').then(function () {\n        // ...\n    });\n\n    // You can chain the methods calls\n    (new Di()).set(...).set(...);\n```\n", "tags": ["JavaScript", "nodejs", "injection", "DependencyInjection", "Pimple"]}