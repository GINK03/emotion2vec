{"context": " More than 1 year has passed since last update.\u524d\u56de \u306f\u3001brillo\u3067\u3082\u4f7f\u308f\u308c\u3066\u3044\u308bAndroid\u306e\u65b0\u3057\u3044build system\u306b\u95a2\u3059\u308b\u307e\u3068\u3081\u3067\u3057\u305f\u304c\u3001\u4eca\u56de\u306f\u3001Mashmallow\u304b\u3089\u5c0e\u5165\u3055\u308c\u305fsanbox mechanism\u3067\u3042\u308bSECCOMP\u304c\u3069\u3093\u306a\u3082\u306e\u306a\u306e\u304b\u306b\u8feb\u308a\u307e\u3059\u3002\n\nCTS for Mashmallow\nhttps://android.googlesource.com/platform/cts/+/marshmallow-dr-dev/tests/tests/os/jni/android_os_cts_OSFeatures.cpp\n\nandroid_os_cts_OSFeatures.cpp\njboolean android_os_cts_OSFeatures_needsSeccompSupport(JNIEnv*, jobject)\n{\n#if !defined(ARCH_SUPPORTS_SECCOMP)\n    // Seccomp support is only available for ARM, x86, x86_64.\n    // This define is controlled by the Android.mk.\n    return false;\n#endif\n    int major;\n    int minor;\n    struct utsname uts;\n    if (uname(&uts) == -1) {\n        return false;\n    }\n    if (sscanf(uts.release, \"%d.%d\", &major, &minor) != 2) {\n        return false;\n    }\n    // Kernels before 3.8 don't have seccomp\n    if ((major < 3) || ((major == 3) && (minor < 8))) {\n        return false;\n    }\n    return true;\n}\n\n\n\u3053\u306e\u3088\u3046\u306bCTS\u3067\u30c6\u30b9\u30c8\u3057\u3066\u3044\u308b\u306e\u3067\u3001kernel version >= 3.8\u3067\u306f\u3001SECCOMP\u304c\u5fc5\u9808\u306b\u306a\u3063\u3066\u3044\u307e\u3059\u3002\n\u4f8b\u3048\u3070\u3001brillo\u3067\u3082\u5fc5\u8981\u306e\u3088\u3046\u3067\u3059\u3002\nhttps://android.googlesource.com/device/generic/brillo/+/brillo-m7-dev/kconfig/common.config\n\nkconfig/common.config\n# Require seccomp-bpf.\nCONFIG_SECCOMP=y\nCONFIG_SECCOMP_FILTER=y\n\n\n\u304c\u5fc5\u8981\u306e\u3088\u3046\u3067\u3059\u3002\n\nSECCOMP\u3068\u306f\u4f55\u304b?\nhttps://en.wikipedia.org/wiki/Seccomp\nseccomp (short for secure computing mode) is a computer security facility that provides an application sandboxing mechanism in the Linux kernel; ..snip.. seccomp allows a process to make a one-way transition into a \"secure\" state where it cannot make any system calls except exit(), sigreturn(), read() and write() to already-open file descriptors. Should it attempt any other system calls, the kernel will terminate the process with SIGKILL. In this sense, it does not virtualize the system's resources but isolates the process from them entirely.\n\nseccomp\u3068\u306f\u77ed\u304f\u8a00\u3046\u3068\u3001secure computing mode\u3067\u3001Linux kernel\u306b\u304a\u3051\u308bapplication sandbox\u3092\u63d0\u4f9b\u3059\u308bsecurity\u6a5f\u69cb\u3067\u3059\u3002 \n\n\nseccomp mode is enabled via the prctl(2) system call using the PR_SET_SECCOMP argument, or (since Linux kernel 3.17[2]) via the seccomp(2) system call.[3] seccomp mode used to be enabled by writing to a file, /proc/self/seccomp, but this method was removed in favor of prctl().[4] In some kernel versions, seccomp disables the RDTSC x86 instruction.\n\nseccomp mode\u306fPR_SET_SECOMP\u3092\u5f15\u6570\u3092\u4f34\u3063\u305fprctl system call\u7d4c\u7531\u3067\u6709\u52b9\u306b\u306a\u308a\u307e\u3059\u3002\u306a\u304a\u3001kernel 3.17\u304b\u3089\u306fseccomp system call\u3067\u3082\u6709\u52b9\u306b\u3067\u304d\u307e\u3059\u3002\u304b\u3064\u3066\u3001seccomp mode\u306f\u3001/proc/self/seccomp\u30d5\u30a1\u30a4\u30eb\u306b\u66f8\u304d\u8fbc\u3080\u3053\u3068\u3067\u6709\u52b9\u306b\u3067\u304d\u307e\u3057\u305f\u304c\u3001\u3053\u306e\u65b9\u6cd5\u306f\u3001prctl()\u306b\u3088\u3063\u3066\u7f6e\u304d\u63db\u3048\u3089\u308c\u307e\u3057\u305f\u3002\n\n\nAndroid\u306e\u3069\u3053\u3067seccomp\u3092\u4f7f\u3063\u3066\u3044\u308b\u304b\uff1f\n\u4f7f\u3063\u3066\u3044\u308b\u306e\u306f\u3001seccomp bpf\u306e\u3088\u3046\u3067\u3059\u3002bpf\u3068\u306f\u3001\u4e0b\u8a18\u306e\u3088\u3046\u306bBerkeley Packet Filter\u306e\u3053\u3068\u306e\u3088\u3046\u3067\u3059\u3002\nseccomp-bpf is an extension to seccomp[6] that allows filtering of system calls using a configurable policy implemented using Berkeley Packet Filter rules. It is used by OpenSSH and vsftpd as well as the Google Chrome/Chromium web browsers on Chrome OS and Linux.[7]\n\nseccomp-bpf\u3068\u306fseccomp\u306eextension\u3067\u3001Berkeley Packet Filter rule\u3068\u547c\u3076config\u53ef\u80fd\u306apolicy\u306b\u3088\u308a\u3001system call\u306efiltering\u3092\u884c\u3046\u3082\u306e\u3067\u3059\u3002OpenSSH\u3001vsftp\u3084\u3001Chrome OS\u3084Linux\u4e0a\u3067\u306eChrome browser\u3067\u7528\u3044\u3089\u308c\u3066\u3044\u307e\u3059\u3002\n\n\u6700\u8fd1\u3001Android\u306esource code\u3092\u773a\u3081\u3066\u3044\u3066\u601d\u3046\u306e\u306f\u3001@android.com\u3088\u308a\u3082@google.com\u306e\u4eba\u304ccommit\u304c\u591a\u3044\u3067\u3059\u3057\u3001\u307e\u305f\u3001brillo\u3092\u898b\u3066\u601d\u3046\u306e\u306f\u3001Chrome\u7531\u6765\u306ecomponents\u304c\u4f7f\u308f\u308c\u3066\u3044\u308b\u3053\u3068\u3067\u3059\u3002\u540c\u3058\u3088\u3046\u306a\u80cc\u666f\u304b\u3089\u3001Android\u3067\u3082seccomp\u304c\u5c0e\u5165\u3055\u308c\u305f\u306e\u3067\u3057\u3087\u3046\u304b\u3002\n\u5b9f\u969b\u306bopengrok\u3057\u3066\u307f\u308b\u3068\u3001\u3001\u3001\n* chromium-trace\n* chrome\u7531\u6765\u306ecrash report\u7528\u306ecomponent\u3067\u3042\u308bgoogle-breakpad\n* openssh\n* strace\n\u3067\u898b\u3064\u304b\u308a\u307e\u3059\u3002\n\nseccomp with google-breakpad\n\nexternal/google-breakpad/src/build/common.gypi\n# Set to 1 to turn on seccomp sandbox by default.\n# (Note: this is ignored for official builds.)\n'linux_use_seccomp_sandbox%': 0,\n\n\n\u3068\u306a\u3063\u3066\u304a\u308a\u3001\u5b9f\u969b\u306b\u306f\u4f7f\u3063\u3066\u3044\u306a\u3044\u307f\u305f\u3044\u3067\u3059\u3002\n// Suspends a thread by attaching to it.\nstatic bool SuspendThread(pid_t pid) {\n..snip..\n#if defined(__i386) || defined(__x86_64)\n  // On x86, the stack pointer is NULL or -1, when executing trusted code in\n  // the seccomp sandbox. Not only does this cause difficulties down the line\n  // when trying to dump the thread's stack, it also results in the minidumps\n  // containing information about the trusted threads. This information is\n  // generally completely meaningless and just pollutes the minidumps.\n  // We thus test the stack pointer and exclude any threads that are part of\n  // the seccomp sandbox's trusted code.\n  user_regs_struct regs;\n  if (sys_ptrace(PTRACE_GETREGS, pid, NULL, &regs) == -1 ||\n#if defined(__i386)\n      !regs.esp\n#elif defined(__x86_64)\n      !regs.rsp\n#endif\n      ) {\n    sys_ptrace(PTRACE_DETACH, pid, NULL, NULL);\n    return false;\n  }\n#endif\n  return true;\n\nseccomp\u306esandbox\u3067\u5b88\u3089\u3066\u305f\u6642\u306b\u306f\u3001\u4e0a\u306e\u3088\u3046\u306bstack pointer\u304cNULL or -1\u306b\u3082\u306a\u308b\u307f\u305f\u3044\u3067\u3059\u306d\u3002(ARM\u4e0d\u660e)\n\nopenssh\n\nexternal/openssh/sandbox-seccomp-filter.c\n#ifdef SANDBOX_SECCOMP_FILTER\n..snip..\n#include <linux/filter.h>\n#include <linux/seccomp.h>\n..snip..\n/* Simple helpers to avoid manual errors (but larger BPF programs). */\n#define SC_DENY(_nr, _errno) \\\n    BPF_JUMP(BPF_JMP+BPF_JEQ+BPF_K, __NR_ ## _nr, 0, 1), \\\n    BPF_STMT(BPF_RET+BPF_K, SECCOMP_RET_ERRNO|(_errno))\n#define SC_ALLOW(_nr) \\\n    BPF_JUMP(BPF_JMP+BPF_JEQ+BPF_K, __NR_ ## _nr, 0, 1), \\\n    BPF_STMT(BPF_RET+BPF_K, SECCOMP_RET_ALLOW)\n/* Syscall filtering set for preauth. */\nstatic const struct sock_filter preauth_insns[] = {\n    /* Ensure the syscall arch convention is as expected. */\n    BPF_STMT(BPF_LD+BPF_W+BPF_ABS,\n        offsetof(struct seccomp_data, arch)),\n    BPF_JUMP(BPF_JMP+BPF_JEQ+BPF_K, SECCOMP_AUDIT_ARCH, 1, 0),\n    BPF_STMT(BPF_RET+BPF_K, SECCOMP_FILTER_FAIL),\n    /* Load the syscall number for checking. */\n    BPF_STMT(BPF_LD+BPF_W+BPF_ABS,\n        offsetof(struct seccomp_data, nr)),\n    SC_DENY(open, EACCES),\n..snip..\n#ifdef __NR_shutdown /* not defined on archs that go via socketcall(2) */\n    SC_ALLOW(shutdown),\n#endif\n..snip..\n    BPF_STMT(BPF_RET+BPF_K, SECCOMP_FILTER_FAIL),\n};\nstatic const struct sock_fprog preauth_program = {\n    .len = (unsigned short)(sizeof(preauth_insns)/sizeof(preauth_insns[0])),\n    .filter = (struct sock_filter *)preauth_insns,\n};\nstruct ssh_sandbox {\n    pid_t child_pid;\n};\n\n..snip..\n\nvoid\nssh_sandbox_child(struct ssh_sandbox *box)\n{\n..snip..\n    if (prctl(PR_SET_SECCOMP, SECCOMP_MODE_FILTER, &preauth_program) == -1)\n..snip..\n}\n\n\n\u3053\u3093\u306a\u611f\u3058\u3067\u4f7f\u3046\u307f\u305f\u3044\u3067\u3059\u3002\nsystem call\u5358\u4f4d\u306a\u306e\u3067\u3001selinux\u307f\u305f\u3044\u306a\u7d30\u3084\u304b\u306a\u5236\u5fa1\u306f\u96e3\u3057\u305d\u3046\u3067\u3059\u306e\u3067\u3001\u7528\u9014\u304c\u9650\u3089\u308c\u305d\u3046\u3067\u3059\u304c\u3002\n\nstrace\nsystem call trace\u306a\u306e\u3067\u3001\u305d\u306e\u6642\u306e\u72b6\u6cc1\u3092dump\u3059\u308b\u6a5f\u80fd\u3068\u3057\u3066\u4f7f\u3063\u3066\u3044\u308b\u3060\u3051\u3067\u3001strace\u81ea\u4f53\u3092\u4f7f\u3063\u3066\u3044\u308b\u308f\u3051\u3067\u306f\u306a\u3044\u3067\u3059\u3002\n\nexternal/strace/seccomp.c\n..snip..\n# include <linux/seccomp.h>\n..snip..\n#include \"xlat/seccomp_ops.h\"\n#include \"xlat/seccomp_filter_flags.h\"\n..snip..\n\nstatic void\ndecode_bpf_code(uint16_t code)\n{\n    uint16_t i = code & ~BPF_CLASS(code);\n    printxval(bpf_class, BPF_CLASS(code), \"BPF_???\");\n    switch (BPF_CLASS(code)) {\n        case BPF_LD:\n        case BPF_LDX:\n            tprints(\" | \");\n            printxval(bpf_size, BPF_SIZE(code), \"BPF_???\");\n            tprints(\" | \");\n            printxval(bpf_mode, BPF_MODE(code), \"BPF_???\");\n            break;\n..snip..\nstatic void\ndecode_bpf_stmt(const struct bpf_filter *filter)\n{\n..snip..\n    tprints(\"BPF_STMT(\");\n    decode_bpf_code(filter->code);\n    tprints(\", \");\n    if (BPF_CLASS(filter->code) == BPF_RET) {\n        unsigned int action = SECCOMP_RET_ACTION & filter->k;\n        unsigned int data = filter->k & ~action;\n        printxval(seccomp_ret_action, action, \"SECCOMP_RET_???\");\n..snip..\n\n\n\u3064\u3065\u304f\u3002\n[\u524d\u56de](http://qiita.com/hidenorly/items/6db2a1b71b3c423813bd) \u306f\u3001brillo\u3067\u3082\u4f7f\u308f\u308c\u3066\u3044\u308bAndroid\u306e\u65b0\u3057\u3044build system\u306b\u95a2\u3059\u308b\u307e\u3068\u3081\u3067\u3057\u305f\u304c\u3001\u4eca\u56de\u306f\u3001Mashmallow\u304b\u3089\u5c0e\u5165\u3055\u308c\u305fsanbox mechanism\u3067\u3042\u308bSECCOMP\u304c\u3069\u3093\u306a\u3082\u306e\u306a\u306e\u304b\u306b\u8feb\u308a\u307e\u3059\u3002\n\n# CTS for Mashmallow\n\nhttps://android.googlesource.com/platform/cts/+/marshmallow-dr-dev/tests/tests/os/jni/android_os_cts_OSFeatures.cpp\n\n```android_os_cts_OSFeatures.cpp\njboolean android_os_cts_OSFeatures_needsSeccompSupport(JNIEnv*, jobject)\n{\n#if !defined(ARCH_SUPPORTS_SECCOMP)\n    // Seccomp support is only available for ARM, x86, x86_64.\n    // This define is controlled by the Android.mk.\n    return false;\n#endif\n    int major;\n    int minor;\n    struct utsname uts;\n    if (uname(&uts) == -1) {\n        return false;\n    }\n    if (sscanf(uts.release, \"%d.%d\", &major, &minor) != 2) {\n        return false;\n    }\n    // Kernels before 3.8 don't have seccomp\n    if ((major < 3) || ((major == 3) && (minor < 8))) {\n        return false;\n    }\n    return true;\n}\n```\n\n\u3053\u306e\u3088\u3046\u306b[CTS](http://source.android.com/compatibility/cts/index.html)\u3067\u30c6\u30b9\u30c8\u3057\u3066\u3044\u308b\u306e\u3067\u3001kernel version >= 3.8\u3067\u306f\u3001SECCOMP\u304c\u5fc5\u9808\u306b\u306a\u3063\u3066\u3044\u307e\u3059\u3002\n\n\u4f8b\u3048\u3070\u3001brillo\u3067\u3082\u5fc5\u8981\u306e\u3088\u3046\u3067\u3059\u3002\nhttps://android.googlesource.com/device/generic/brillo/+/brillo-m7-dev/kconfig/common.config\n\n```kconfig/common.config\n# Require seccomp-bpf.\nCONFIG_SECCOMP=y\nCONFIG_SECCOMP_FILTER=y\n```\n\n\u304c\u5fc5\u8981\u306e\u3088\u3046\u3067\u3059\u3002\n\n# SECCOMP\u3068\u306f\u4f55\u304b?\n\nhttps://en.wikipedia.org/wiki/Seccomp\n\n```\nseccomp (short for secure computing mode) is a computer security facility that provides an application sandboxing mechanism in the Linux kernel; ..snip.. seccomp allows a process to make a one-way transition into a \"secure\" state where it cannot make any system calls except exit(), sigreturn(), read() and write() to already-open file descriptors. Should it attempt any other system calls, the kernel will terminate the process with SIGKILL. In this sense, it does not virtualize the system's resources but isolates the process from them entirely.\n```\n\n```\u6284\u8a33\nseccomp\u3068\u306f\u77ed\u304f\u8a00\u3046\u3068\u3001secure computing mode\u3067\u3001Linux kernel\u306b\u304a\u3051\u308bapplication sandbox\u3092\u63d0\u4f9b\u3059\u308bsecurity\u6a5f\u69cb\u3067\u3059\u3002 \n\n```\n\n```\nseccomp mode is enabled via the prctl(2) system call using the PR_SET_SECCOMP argument, or (since Linux kernel 3.17[2]) via the seccomp(2) system call.[3] seccomp mode used to be enabled by writing to a file, /proc/self/seccomp, but this method was removed in favor of prctl().[4] In some kernel versions, seccomp disables the RDTSC x86 instruction.\n```\n\n```\u6284\u8a33\nseccomp mode\u306fPR_SET_SECOMP\u3092\u5f15\u6570\u3092\u4f34\u3063\u305fprctl system call\u7d4c\u7531\u3067\u6709\u52b9\u306b\u306a\u308a\u307e\u3059\u3002\u306a\u304a\u3001kernel 3.17\u304b\u3089\u306fseccomp system call\u3067\u3082\u6709\u52b9\u306b\u3067\u304d\u307e\u3059\u3002\u304b\u3064\u3066\u3001seccomp mode\u306f\u3001/proc/self/seccomp\u30d5\u30a1\u30a4\u30eb\u306b\u66f8\u304d\u8fbc\u3080\u3053\u3068\u3067\u6709\u52b9\u306b\u3067\u304d\u307e\u3057\u305f\u304c\u3001\u3053\u306e\u65b9\u6cd5\u306f\u3001prctl()\u306b\u3088\u3063\u3066\u7f6e\u304d\u63db\u3048\u3089\u308c\u307e\u3057\u305f\u3002\n```\n\n# Android\u306e\u3069\u3053\u3067seccomp\u3092\u4f7f\u3063\u3066\u3044\u308b\u304b\uff1f\n\n\u4f7f\u3063\u3066\u3044\u308b\u306e\u306f\u3001seccomp bpf\u306e\u3088\u3046\u3067\u3059\u3002bpf\u3068\u306f\u3001\u4e0b\u8a18\u306e\u3088\u3046\u306bBerkeley Packet Filter\u306e\u3053\u3068\u306e\u3088\u3046\u3067\u3059\u3002\n\n```\nseccomp-bpf is an extension to seccomp[6] that allows filtering of system calls using a configurable policy implemented using Berkeley Packet Filter rules. It is used by OpenSSH and vsftpd as well as the Google Chrome/Chromium web browsers on Chrome OS and Linux.[7]\n```\n\n```\nseccomp-bpf\u3068\u306fseccomp\u306eextension\u3067\u3001Berkeley Packet Filter rule\u3068\u547c\u3076config\u53ef\u80fd\u306apolicy\u306b\u3088\u308a\u3001system call\u306efiltering\u3092\u884c\u3046\u3082\u306e\u3067\u3059\u3002OpenSSH\u3001vsftp\u3084\u3001Chrome OS\u3084Linux\u4e0a\u3067\u306eChrome browser\u3067\u7528\u3044\u3089\u308c\u3066\u3044\u307e\u3059\u3002\n```\n\n\u6700\u8fd1\u3001Android\u306esource code\u3092\u773a\u3081\u3066\u3044\u3066\u601d\u3046\u306e\u306f\u3001@android.com\u3088\u308a\u3082@google.com\u306e\u4eba\u304ccommit\u304c\u591a\u3044\u3067\u3059\u3057\u3001\u307e\u305f\u3001brillo\u3092\u898b\u3066\u601d\u3046\u306e\u306f\u3001Chrome\u7531\u6765\u306ecomponents\u304c\u4f7f\u308f\u308c\u3066\u3044\u308b\u3053\u3068\u3067\u3059\u3002\u540c\u3058\u3088\u3046\u306a\u80cc\u666f\u304b\u3089\u3001Android\u3067\u3082seccomp\u304c\u5c0e\u5165\u3055\u308c\u305f\u306e\u3067\u3057\u3087\u3046\u304b\u3002\n\n\u5b9f\u969b\u306bopengrok\u3057\u3066\u307f\u308b\u3068\u3001\u3001\u3001\n* chromium-trace\n* chrome\u7531\u6765\u306ecrash report\u7528\u306ecomponent\u3067\u3042\u308bgoogle-breakpad\n* openssh\n* strace\n\n\u3067\u898b\u3064\u304b\u308a\u307e\u3059\u3002\n\n## seccomp with google-breakpad\n\n```external/google-breakpad/src/build/common.gypi\n# Set to 1 to turn on seccomp sandbox by default.\n# (Note: this is ignored for official builds.)\n'linux_use_seccomp_sandbox%': 0,\n```\n\n\u3068\u306a\u3063\u3066\u304a\u308a\u3001\u5b9f\u969b\u306b\u306f\u4f7f\u3063\u3066\u3044\u306a\u3044\u307f\u305f\u3044\u3067\u3059\u3002\n\n```\n// Suspends a thread by attaching to it.\nstatic bool SuspendThread(pid_t pid) {\n..snip..\n#if defined(__i386) || defined(__x86_64)\n  // On x86, the stack pointer is NULL or -1, when executing trusted code in\n  // the seccomp sandbox. Not only does this cause difficulties down the line\n  // when trying to dump the thread's stack, it also results in the minidumps\n  // containing information about the trusted threads. This information is\n  // generally completely meaningless and just pollutes the minidumps.\n  // We thus test the stack pointer and exclude any threads that are part of\n  // the seccomp sandbox's trusted code.\n  user_regs_struct regs;\n  if (sys_ptrace(PTRACE_GETREGS, pid, NULL, &regs) == -1 ||\n#if defined(__i386)\n      !regs.esp\n#elif defined(__x86_64)\n      !regs.rsp\n#endif\n      ) {\n    sys_ptrace(PTRACE_DETACH, pid, NULL, NULL);\n    return false;\n  }\n#endif\n  return true;\n```\n\nseccomp\u306esandbox\u3067\u5b88\u3089\u3066\u305f\u6642\u306b\u306f\u3001\u4e0a\u306e\u3088\u3046\u306bstack pointer\u304cNULL or -1\u306b\u3082\u306a\u308b\u307f\u305f\u3044\u3067\u3059\u306d\u3002(ARM\u4e0d\u660e)\n\n\n## openssh\n\n```external/openssh/sandbox-seccomp-filter.c\n#ifdef SANDBOX_SECCOMP_FILTER\n..snip..\n#include <linux/filter.h>\n#include <linux/seccomp.h>\n..snip..\n/* Simple helpers to avoid manual errors (but larger BPF programs). */\n#define SC_DENY(_nr, _errno) \\\n\tBPF_JUMP(BPF_JMP+BPF_JEQ+BPF_K, __NR_ ## _nr, 0, 1), \\\n\tBPF_STMT(BPF_RET+BPF_K, SECCOMP_RET_ERRNO|(_errno))\n#define SC_ALLOW(_nr) \\\n\tBPF_JUMP(BPF_JMP+BPF_JEQ+BPF_K, __NR_ ## _nr, 0, 1), \\\n\tBPF_STMT(BPF_RET+BPF_K, SECCOMP_RET_ALLOW)\n/* Syscall filtering set for preauth. */\nstatic const struct sock_filter preauth_insns[] = {\n\t/* Ensure the syscall arch convention is as expected. */\n\tBPF_STMT(BPF_LD+BPF_W+BPF_ABS,\n\t\toffsetof(struct seccomp_data, arch)),\n\tBPF_JUMP(BPF_JMP+BPF_JEQ+BPF_K, SECCOMP_AUDIT_ARCH, 1, 0),\n\tBPF_STMT(BPF_RET+BPF_K, SECCOMP_FILTER_FAIL),\n\t/* Load the syscall number for checking. */\n\tBPF_STMT(BPF_LD+BPF_W+BPF_ABS,\n\t\toffsetof(struct seccomp_data, nr)),\n\tSC_DENY(open, EACCES),\n..snip..\n#ifdef __NR_shutdown /* not defined on archs that go via socketcall(2) */\n\tSC_ALLOW(shutdown),\n#endif\n..snip..\n\tBPF_STMT(BPF_RET+BPF_K, SECCOMP_FILTER_FAIL),\n};\nstatic const struct sock_fprog preauth_program = {\n\t.len = (unsigned short)(sizeof(preauth_insns)/sizeof(preauth_insns[0])),\n\t.filter = (struct sock_filter *)preauth_insns,\n};\nstruct ssh_sandbox {\n\tpid_t child_pid;\n};\n\n..snip..\n\nvoid\nssh_sandbox_child(struct ssh_sandbox *box)\n{\n..snip..\n\tif (prctl(PR_SET_SECCOMP, SECCOMP_MODE_FILTER, &preauth_program) == -1)\n..snip..\n}\n```\n\n\u3053\u3093\u306a\u611f\u3058\u3067\u4f7f\u3046\u307f\u305f\u3044\u3067\u3059\u3002\nsystem call\u5358\u4f4d\u306a\u306e\u3067\u3001selinux\u307f\u305f\u3044\u306a\u7d30\u3084\u304b\u306a\u5236\u5fa1\u306f\u96e3\u3057\u305d\u3046\u3067\u3059\u306e\u3067\u3001\u7528\u9014\u304c\u9650\u3089\u308c\u305d\u3046\u3067\u3059\u304c\u3002\n\n## strace\n\nsystem call trace\u306a\u306e\u3067\u3001\u305d\u306e\u6642\u306e\u72b6\u6cc1\u3092dump\u3059\u308b\u6a5f\u80fd\u3068\u3057\u3066\u4f7f\u3063\u3066\u3044\u308b\u3060\u3051\u3067\u3001strace\u81ea\u4f53\u3092\u4f7f\u3063\u3066\u3044\u308b\u308f\u3051\u3067\u306f\u306a\u3044\u3067\u3059\u3002\n\n```external/strace/seccomp.c\n..snip..\n# include <linux/seccomp.h>\n..snip..\n#include \"xlat/seccomp_ops.h\"\n#include \"xlat/seccomp_filter_flags.h\"\n..snip..\n\nstatic void\ndecode_bpf_code(uint16_t code)\n{\n\tuint16_t i = code & ~BPF_CLASS(code);\n\tprintxval(bpf_class, BPF_CLASS(code), \"BPF_???\");\n\tswitch (BPF_CLASS(code)) {\n\t\tcase BPF_LD:\n\t\tcase BPF_LDX:\n\t\t\ttprints(\" | \");\n\t\t\tprintxval(bpf_size, BPF_SIZE(code), \"BPF_???\");\n\t\t\ttprints(\" | \");\n\t\t\tprintxval(bpf_mode, BPF_MODE(code), \"BPF_???\");\n\t\t\tbreak;\n..snip..\nstatic void\ndecode_bpf_stmt(const struct bpf_filter *filter)\n{\n..snip..\n\ttprints(\"BPF_STMT(\");\n\tdecode_bpf_code(filter->code);\n\ttprints(\", \");\n\tif (BPF_CLASS(filter->code) == BPF_RET) {\n\t\tunsigned int action = SECCOMP_RET_ACTION & filter->k;\n\t\tunsigned int data = filter->k & ~action;\n\t\tprintxval(seccomp_ret_action, action, \"SECCOMP_RET_???\");\n..snip..\n```\n\n\u3064\u3065\u304f\u3002\n", "tags": ["SECCOMP", "Android", "BPF", "CTS", "OpenSSH"]}