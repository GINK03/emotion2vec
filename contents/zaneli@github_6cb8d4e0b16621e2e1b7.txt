{"tags": ["Scala", "Redis", "Jedis"], "context": " More than 1 year has passed since last update.Twitter \u3067 @todesking \u3055\u3093\u304b\u3089\u3044\u305f\u3060\u3044\u305f\u30a2\u30c9\u30d0\u30a4\u30b9\u3092\u5143\u306b\u6539\u826f\u3092\u8a66\u307f\u308b\u3002\n\nhttps://twitter.com/todesking/status/622017179328774144\nhttps://twitter.com/todesking/status/622023114793201665\n\n\nJedisPipelinedCluster.scala\npackage com.zaneli.redis.jedis\n\nimport org.apache.commons.pool2.impl.GenericObjectPoolConfig\nimport redis.clients.jedis.{HostAndPort, Protocol}\nimport redis.clients.jedis.exceptions.{JedisClusterMaxRedirectionsException, JedisMovedDataException}\nimport scalikejdbc.using\n\nimport scala.annotation.tailrec\nimport scala.util.{Failure, Try}\n\nclass JedisPipelinedCluster(\n    nodes: Set[HostAndPort],\n    config: GenericObjectPoolConfig = new GenericObjectPoolConfig(),\n    timeout: Int = Protocol.DEFAULT_TIMEOUT,\n    maxRedirections: Int = 5) {\n\n  def pipelined[A](cmd: ClusteredPipeline => A): Try[A] =\n    pipelined(cmd, maxRedirections)\n\n  @tailrec\n  private[this] def pipelined[A](cmd: ClusteredPipeline => A, redirections: Int): Try[A] = {\n    val result = Try {\n      using(new ClusteredPipeline(nodes, config, timeout)) { cp =>\n        cmd(cp)\n      }\n    }\n    result match {\n      case Failure(e: JedisMovedDataException) =>\n        if (redirections <= 0) {\n          Failure(new JedisClusterMaxRedirectionsException(\"Too many Cluster redirections?\"))\n        } else {\n          pipelined(cmd, redirections - 1)\n        }\n      case r => r\n    }\n  }\n}\n\n\nJedisPipelinedCluster \u306f\u524d\u56de\u3068\u3042\u307e\u308a\u5909\u308f\u3089\u306a\u3044\u304c\u3001\n\u30ad\u30fc\u3092\u5225\u9014\u6e21\u3057\u3066\u3053\u3053\u3067slot\u751f\u6210\u3001\u30b3\u30cd\u30af\u30b7\u30e7\u30f3\u53d6\u5f97\u3001\u76f4\u63a5Pipeline\u64cd\u4f5c\u3001\u3068\u3044\u3046\u306e\u3092\u3084\u3081\u3001\nClusteredPipeline \u306b\u51e6\u7406\u3092\u4efb\u305b\u308b\u3088\u3046\u306b\u3057\u305f\u3002\n\nClusteredPipeline.scala\npackage com.zaneli.redis.jedis\n\nimport org.apache.commons.pool2.impl.GenericObjectPoolConfig\nimport redis.clients.jedis.{HostAndPort, Jedis, JedisSlotBasedConnectionHandler, JedisPool, Pipeline, Response}\nimport redis.clients.util.JedisClusterCRC16\n\nimport scala.collection.JavaConversions._\nimport scala.collection.mutable\nimport scala.language.reflectiveCalls\nimport scala.util.Try\n\nclass ClusteredPipeline(nodes: Set[HostAndPort], config: GenericObjectPoolConfig, timeout: Int) extends AutoCloseable {\n\n  private[this] case class Connection(jedis: Jedis, pipeline: Pipeline)\n\n  private[this] val connections: mutable.Map[JedisPool, Connection] = mutable.Map.empty\n\n  private[this] val handler = new JedisSlotBasedConnectionHandler(nodes, config, timeout) {\n    def getSlotPool(slot: Int): JedisPool = {\n      cache.getSlotPool(slot)\n    }\n    def getConnection(pool: JedisPool): Jedis = {\n      if (pool != null) pool.getResource() else getConnection()\n    }\n  }\n\n  def exec[A](key: String)(cmd: Pipeline => String => Response[A]): Response[A] = {\n    val slot = JedisClusterCRC16.getSlot(key)\n    val pool = handler.getSlotPool(slot)\n    val pipeline = getPipeline(pool)\n    cmd(pipeline)(key)\n  }\n\n  private[this] def getPipeline(pool: JedisPool): Pipeline = {\n    connections.get(pool).map(_.pipeline).getOrElse {\n      val j = handler.getConnection(pool)\n      val p = j.pipelined()\n      connections.put(pool, Connection(j, p))\n      p\n    }\n  }\n\n  def sync(): Unit = {\n    connections.values.foreach(_.pipeline.sync())\n  }\n\n  override def close(): Unit = {\n    connections.values.foreach(j => Try(j.jedis.close()))\n    connections.clear()\n  }\n}\n\n\nJedisSlotBasedConnectionHandler \u304c protected \u3067\u6301\u3063\u3066\u3044\u308b cache \u306b\u89e6\u308a\u305f\u304b\u3063\u305f\u306e\u3067\u5c11\u3005\u5f37\u5f15\u3060\u304c\u3053\u306e\u3088\u3046\u306b\u3002\n(JedisPool \u3092\u76f4\u63a5\u53d6\u308a\u305f\u304b\u3063\u305f\u306e\u3067\u3001\u3053\u306e\u8fba\u308a\u76f8\u5f53\u306e\u51e6\u7406\u3092\u500b\u5225\u306b\u884c\u3063\u3066\u3044\u308b\u3002)\n\u540c\u3058 JedisPool \u304b\u3089\u3059\u3067\u306b Jedis \u3092\u53d6\u5f97\u6e08\u307f\u3067\u3042\u308c\u3070 connections \u306b\u4fdd\u6301\u3057\u305f Pipeline \u3092\u4f7f\u3044\u56de\u3057\u3001\n\u307e\u3060\u53d6\u5f97\u3057\u3066\u3044\u306a\u3051\u308c\u3070\u65b0\u305f\u306b Jedis \u3092\u53d6\u5f97\u3057\u3066\u305d\u3053\u304b\u3089 Pipeline \u3092\u53d6\u308b\u3002\nmutable.Map \u3067 Jedis \u3082 Pipeline \u3082\u4fdd\u6301\u3059\u308b\u3068\u3044\u3046\u3084\u3084\u3053\u3057\u3044\u4e8b\u3092\u3057\u3066\u3044\u308b\u304c\u3001\n\u524d\u8005\u306f\u6700\u7d42\u7684\u306b close \u3059\u308b\u305f\u3081\u306b\u3001\u5f8c\u8005\u306f exec \u3067\u4f7f\u3044\u56de\u3059\u305f\u3081\u306b\u4fdd\u6301\u3059\u308b\u3088\u3046\u306b\u3057\u305f\u3002\nMap\u306e\u30ad\u30fc\u304c JedisPool \u306a\u306e\u3082\u30a4\u30de\u30a4\u30c1\u306a\u6c17\u304c\u3059\u308b\u304c\u2026\u3002\n\u4e00\u5fdc\u3001\u540c\u3058\u30ce\u30fc\u30c9\u306b\u66f8\u304b\u308c\u305f key2 \u3068 key3 \u3067\u306f cache.getSlotPool \u3067\u540c\u3058 JedisPool \u304c\u53d6\u5f97\u3055\u308c\u308b\u4e8b\u306f\u78ba\u8a8d\u3057\u305f\u3002\n\nJedisTest4.scala\npackage com.zaneli.redis.jedis\n\nimport redis.clients.jedis.HostAndPort\n\nimport scala.util.{Failure, Success}\n\nobject JedisTest4 extends App {\n\n  val nodes = Set(6379, 6380, 6381).map { port =>\n    new HostAndPort(\"192.168.53.52\", port)\n  }\n  val cluster = new JedisPipelinedCluster(nodes)\n  val result = cluster.pipelined { cp =>\n    val v1 = cp.exec(\"key1\")(_.get)\n    val v2 = cp.exec(\"key2\")(_.get)\n    val v3 = cp.exec(\"key3\")(_.get)\n    cp.sync()\n    (v1.get, v2.get, v3.get)\n  }\n  result match {\n    case Success((v1, v2, v3)) => println((v1, v2, v3))\n    case Failure(e) => e.printStackTrace()\n  }\n}\n\n\n\u3053\u306e\u3088\u3046\u306b\u4f7f\u3046\u3002\n\u524d\u56de\u8a18\u4e8b\u306e\u901a\u308a\u3001key1 \u3068 key2key3 \u3067\u306f\u5225\u306e\u30ce\u30fc\u30c9\u306b\u66f8\u304b\u308c\u308b\u305f\u3081\u540c\u4e00 Pipeline \u3067\u306f\u51e6\u7406\u3067\u304d\u306a\u3044\u304c\u3001\nClusteredPipeline \u5185\u3067\u9069\u5b9c Pipeline \u306e\u751f\u6210\u30fb\u4f7f\u3044\u56de\u3057\u3092\u884c\u3063\u3066\u3044\u308b\u306e\u3067\n\u547c\u3073\u51fa\u3057\u5074\u306f\u3053\u306e\u3088\u3046\u306b\u4e00\u5ea6\u306b\u51e6\u7406\u3067\u304d\u308b\u3002\n\u88dc\u8db3\u3068\u3057\u3066\u306f\u3001\u4ee5\u4e0b\u306e\u3088\u3046\u306b\u6c4e\u7528\u7684\u306a exec \u3092 ClusteredPipeline \u306b\u7528\u610f\u3057\u305f\u3064\u3082\u308a\u3060\u3063\u305f\u304c\u3001\ndef exec[A](key: String)(cmd: Pipeline => String => Response[A]): Response[A]\n\n\u7d50\u5c40 get \u304f\u3089\u3044\u3057\u304b\u30b7\u30b0\u30cd\u30c1\u30e3\u304c\u5408\u3046\u3082\u306e\u304c\u306a\u3044\u306e\u3067\u3001\nset, hget \u306a\u3069 Pipeline \u304c\u6301\u3064 Response[_] \u3092\u8fd4\u3059\u30e1\u30bd\u30c3\u30c9\u5168\u3066\u3092\nClusteredPipeline \u306b\u3082\u6301\u305f\u305b\u308b\u307b\u3046\u304c\u90fd\u5408\u304c\u826f\u304b\u3063\u305f\u304b\u306a\u3001\u3068\u601d\u3046\u3002\nTwitter \u3067 @todesking \u3055\u3093\u304b\u3089\u3044\u305f\u3060\u3044\u305f\u30a2\u30c9\u30d0\u30a4\u30b9\u3092\u5143\u306b\u6539\u826f\u3092\u8a66\u307f\u308b\u3002\n\n* https://twitter.com/todesking/status/622017179328774144\n* https://twitter.com/todesking/status/622023114793201665\n\n```scala:JedisPipelinedCluster.scala\npackage com.zaneli.redis.jedis\n\nimport org.apache.commons.pool2.impl.GenericObjectPoolConfig\nimport redis.clients.jedis.{HostAndPort, Protocol}\nimport redis.clients.jedis.exceptions.{JedisClusterMaxRedirectionsException, JedisMovedDataException}\nimport scalikejdbc.using\n\nimport scala.annotation.tailrec\nimport scala.util.{Failure, Try}\n\nclass JedisPipelinedCluster(\n    nodes: Set[HostAndPort],\n    config: GenericObjectPoolConfig = new GenericObjectPoolConfig(),\n    timeout: Int = Protocol.DEFAULT_TIMEOUT,\n    maxRedirections: Int = 5) {\n\n  def pipelined[A](cmd: ClusteredPipeline => A): Try[A] =\n    pipelined(cmd, maxRedirections)\n\n  @tailrec\n  private[this] def pipelined[A](cmd: ClusteredPipeline => A, redirections: Int): Try[A] = {\n    val result = Try {\n      using(new ClusteredPipeline(nodes, config, timeout)) { cp =>\n        cmd(cp)\n      }\n    }\n    result match {\n      case Failure(e: JedisMovedDataException) =>\n        if (redirections <= 0) {\n          Failure(new JedisClusterMaxRedirectionsException(\"Too many Cluster redirections?\"))\n        } else {\n          pipelined(cmd, redirections - 1)\n        }\n      case r => r\n    }\n  }\n}\n```\n\n`JedisPipelinedCluster` \u306f[\u524d\u56de](http://qiita.com/zaneli@github/items/c5adce0abc374bbc5b2f)\u3068\u3042\u307e\u308a\u5909\u308f\u3089\u306a\u3044\u304c\u3001\n\u30ad\u30fc\u3092\u5225\u9014\u6e21\u3057\u3066\u3053\u3053\u3067`slot`\u751f\u6210\u3001\u30b3\u30cd\u30af\u30b7\u30e7\u30f3\u53d6\u5f97\u3001\u76f4\u63a5`Pipeline`\u64cd\u4f5c\u3001\u3068\u3044\u3046\u306e\u3092\u3084\u3081\u3001\n`ClusteredPipeline` \u306b\u51e6\u7406\u3092\u4efb\u305b\u308b\u3088\u3046\u306b\u3057\u305f\u3002\n\n```scala:ClusteredPipeline.scala\npackage com.zaneli.redis.jedis\n\nimport org.apache.commons.pool2.impl.GenericObjectPoolConfig\nimport redis.clients.jedis.{HostAndPort, Jedis, JedisSlotBasedConnectionHandler, JedisPool, Pipeline, Response}\nimport redis.clients.util.JedisClusterCRC16\n\nimport scala.collection.JavaConversions._\nimport scala.collection.mutable\nimport scala.language.reflectiveCalls\nimport scala.util.Try\n\nclass ClusteredPipeline(nodes: Set[HostAndPort], config: GenericObjectPoolConfig, timeout: Int) extends AutoCloseable {\n\n  private[this] case class Connection(jedis: Jedis, pipeline: Pipeline)\n\n  private[this] val connections: mutable.Map[JedisPool, Connection] = mutable.Map.empty\n\n  private[this] val handler = new JedisSlotBasedConnectionHandler(nodes, config, timeout) {\n    def getSlotPool(slot: Int): JedisPool = {\n      cache.getSlotPool(slot)\n    }\n    def getConnection(pool: JedisPool): Jedis = {\n      if (pool != null) pool.getResource() else getConnection()\n    }\n  }\n\n  def exec[A](key: String)(cmd: Pipeline => String => Response[A]): Response[A] = {\n    val slot = JedisClusterCRC16.getSlot(key)\n    val pool = handler.getSlotPool(slot)\n    val pipeline = getPipeline(pool)\n    cmd(pipeline)(key)\n  }\n\n  private[this] def getPipeline(pool: JedisPool): Pipeline = {\n    connections.get(pool).map(_.pipeline).getOrElse {\n      val j = handler.getConnection(pool)\n      val p = j.pipelined()\n      connections.put(pool, Connection(j, p))\n      p\n    }\n  }\n\n  def sync(): Unit = {\n    connections.values.foreach(_.pipeline.sync())\n  }\n\n  override def close(): Unit = {\n    connections.values.foreach(j => Try(j.jedis.close()))\n    connections.clear()\n  }\n}\n```\n\n`JedisSlotBasedConnectionHandler` \u304c `protected` \u3067\u6301\u3063\u3066\u3044\u308b `cache` \u306b\u89e6\u308a\u305f\u304b\u3063\u305f\u306e\u3067\u5c11\u3005\u5f37\u5f15\u3060\u304c\u3053\u306e\u3088\u3046\u306b\u3002\n(`JedisPool` \u3092\u76f4\u63a5\u53d6\u308a\u305f\u304b\u3063\u305f\u306e\u3067\u3001[\u3053\u306e\u8fba\u308a](https://github.com/xetorthio/jedis/blob/14ba58b2a46fe54ebfb116b767875e4d83f1abbd/src/main/java/redis/clients/jedis/JedisSlotBasedConnectionHandler.java#L57-L66)\u76f8\u5f53\u306e\u51e6\u7406\u3092\u500b\u5225\u306b\u884c\u3063\u3066\u3044\u308b\u3002)\n\n\u540c\u3058 `JedisPool` \u304b\u3089\u3059\u3067\u306b `Jedis` \u3092\u53d6\u5f97\u6e08\u307f\u3067\u3042\u308c\u3070 `connections` \u306b\u4fdd\u6301\u3057\u305f `Pipeline` \u3092\u4f7f\u3044\u56de\u3057\u3001\n\u307e\u3060\u53d6\u5f97\u3057\u3066\u3044\u306a\u3051\u308c\u3070\u65b0\u305f\u306b `Jedis` \u3092\u53d6\u5f97\u3057\u3066\u305d\u3053\u304b\u3089 `Pipeline` \u3092\u53d6\u308b\u3002\n\n`mutable.Map` \u3067 `Jedis` \u3082 `Pipeline` \u3082\u4fdd\u6301\u3059\u308b\u3068\u3044\u3046\u3084\u3084\u3053\u3057\u3044\u4e8b\u3092\u3057\u3066\u3044\u308b\u304c\u3001\n\u524d\u8005\u306f\u6700\u7d42\u7684\u306b `close` \u3059\u308b\u305f\u3081\u306b\u3001\u5f8c\u8005\u306f `exec` \u3067\u4f7f\u3044\u56de\u3059\u305f\u3081\u306b\u4fdd\u6301\u3059\u308b\u3088\u3046\u306b\u3057\u305f\u3002\n\nMap\u306e\u30ad\u30fc\u304c `JedisPool` \u306a\u306e\u3082\u30a4\u30de\u30a4\u30c1\u306a\u6c17\u304c\u3059\u308b\u304c\u2026\u3002\n\u4e00\u5fdc\u3001\u540c\u3058\u30ce\u30fc\u30c9\u306b\u66f8\u304b\u308c\u305f `key2` \u3068 `key3` \u3067\u306f `cache.getSlotPool` \u3067\u540c\u3058 `JedisPool` \u304c\u53d6\u5f97\u3055\u308c\u308b\u4e8b\u306f\u78ba\u8a8d\u3057\u305f\u3002\n\n```scala:JedisTest4.scala\npackage com.zaneli.redis.jedis\n\nimport redis.clients.jedis.HostAndPort\n\nimport scala.util.{Failure, Success}\n\nobject JedisTest4 extends App {\n\n  val nodes = Set(6379, 6380, 6381).map { port =>\n    new HostAndPort(\"192.168.53.52\", port)\n  }\n  val cluster = new JedisPipelinedCluster(nodes)\n  val result = cluster.pipelined { cp =>\n    val v1 = cp.exec(\"key1\")(_.get)\n    val v2 = cp.exec(\"key2\")(_.get)\n    val v3 = cp.exec(\"key3\")(_.get)\n    cp.sync()\n    (v1.get, v2.get, v3.get)\n  }\n  result match {\n    case Success((v1, v2, v3)) => println((v1, v2, v3))\n    case Failure(e) => e.printStackTrace()\n  }\n}\n```\n\n\u3053\u306e\u3088\u3046\u306b\u4f7f\u3046\u3002\n\u524d\u56de\u8a18\u4e8b\u306e\u901a\u308a\u3001`key1` \u3068 `key2``key3` \u3067\u306f\u5225\u306e\u30ce\u30fc\u30c9\u306b\u66f8\u304b\u308c\u308b\u305f\u3081\u540c\u4e00 `Pipeline` \u3067\u306f\u51e6\u7406\u3067\u304d\u306a\u3044\u304c\u3001\n`ClusteredPipeline` \u5185\u3067\u9069\u5b9c `Pipeline` \u306e\u751f\u6210\u30fb\u4f7f\u3044\u56de\u3057\u3092\u884c\u3063\u3066\u3044\u308b\u306e\u3067\n\u547c\u3073\u51fa\u3057\u5074\u306f\u3053\u306e\u3088\u3046\u306b\u4e00\u5ea6\u306b\u51e6\u7406\u3067\u304d\u308b\u3002\n\n\u88dc\u8db3\u3068\u3057\u3066\u306f\u3001\u4ee5\u4e0b\u306e\u3088\u3046\u306b\u6c4e\u7528\u7684\u306a `exec` \u3092 `ClusteredPipeline` \u306b\u7528\u610f\u3057\u305f\u3064\u3082\u308a\u3060\u3063\u305f\u304c\u3001\n\n```scala:\ndef exec[A](key: String)(cmd: Pipeline => String => Response[A]): Response[A]\n```\n\n\u7d50\u5c40 `get` \u304f\u3089\u3044\u3057\u304b\u30b7\u30b0\u30cd\u30c1\u30e3\u304c\u5408\u3046\u3082\u306e\u304c\u306a\u3044\u306e\u3067\u3001\n`set`, `hget` \u306a\u3069 `Pipeline` \u304c\u6301\u3064 `Response[_]` \u3092\u8fd4\u3059\u30e1\u30bd\u30c3\u30c9\u5168\u3066\u3092\n`ClusteredPipeline` \u306b\u3082\u6301\u305f\u305b\u308b\u307b\u3046\u304c\u90fd\u5408\u304c\u826f\u304b\u3063\u305f\u304b\u306a\u3001\u3068\u601d\u3046\u3002\n"}