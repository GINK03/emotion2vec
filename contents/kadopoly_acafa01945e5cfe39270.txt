{"context": " More than 1 year has passed since last update.\n\n\u306f\u3058\u3081\u306b\n\u30ea\u30f3\u30af\u30ec\u30a4\u30e4\u30fc\u306e\u30d1\u30b1\u30c3\u30c8\u3092\u6271\u3044\u305f\u3044\u3068\u304d\u304c\u3042\u308b\u3001\u304b\u3068\u8a00\u308f\u308c\u305f\u3089\u306a\u3044\u304b\u3082\u3057\u308c\u307e\u305b\u3093\u304c\u2026\u2026\u3002\u624b\u63a2\u308a\u306e\u899a\u66f8\u3068\u3057\u3066\u6b8b\u3057\u3066\u304a\u304d\u307e\u3059\u3002\u78ba\u8a8d\u74b0\u5883\u306f clang on Linux \u3067\u3059\u3002\n\n\u6982\u8aac\nC \u306a\u3089\u3070\u304a\u3082\u3080\u308d\u306b\u30bd\u30b1\u30c3\u30c8\u3092\u958b\u3044\u3066 PF_PACKET \u3068 SOCK_RAW \u3092\u3076\u3061\u8fbc\u3081\u3070\u3001\u4f4e\u5c64\u306e\u30d1\u30b1\u30c3\u30c8\u3092\u6271\u3046\u3053\u3068\u304c\u3067\u304d\u307e\u3059\u306e\u3067\u3001C++ \u3067\u3082\u540c\u69d8\u306b\u3057\u3066\u958b\u3051\u307e\u3059\u3002C++ \u30c1\u30c3\u30af\u306b\u306a\u306b\u304b\u3067\u304d\u306a\u3044\u304b\u63a2\u3057\u307e\u3057\u305f\u3002\nBoost.Asio \u306a\u3089\u306a\u3093\u3068\u304b\u3057\u3066\u304f\u308c\u308b\u306b\u9055\u3044\u306a\u3044\u3002generic::raw_protocol \u3084 basic_raw_socket \u3042\u305f\u308a\u304c\u602a\u3057\u3044\u306e\u3067\u3053\u306e\u8fba\u308a\u3092\u3064\u3064\u3044\u3066\u307f\u307e\u3059\u3002:\nhttp://www.boost.org/doc/libs/1_57_0/doc/html/boost_asio/reference.html\n\u3061\u3087\u3046\u3069 raw_protocol \u306e Examples \u306b\u898b\u305f\u3053\u3068\u306e\u3042\u308b\u3088\u3046\u306a\u4f8b\u304c\u3042\u308a\u307e\u3057\u305f:\nraw_protocol p(AF_INET, IPPROTO_ICMP);\n\n\u30cd\u30a4\u30c6\u30a3\u30d6\u306e\u30a2\u30c9\u30ec\u30b9\u30d5\u30a1\u30df\u30ea\u30fc\u3092\u6307\u5b9a\u3057\u3066\u3044\u307e\u3059\u3002\u3053\u3053\u3067\u30bd\u30b1\u30c3\u30c8\u3068\u30d7\u30ed\u30c8\u30b3\u30eb\u306e\u30d5\u30e9\u30b0\u3092\u7ba1\u7406\u3057\u3066\u3044\u308b\u3088\u3046\u3067\u3059\u3002C \u3068\u540c\u69d8\u306e\u5024\u3092\u4e0e\u3048\u308c\u3070 open \u6642\u306b raw socket \u306e\u30d1\u30e9\u30e1\u30fc\u30bf\u3092\u4e0e\u3048\u308b\u3053\u3068\u304c\u3067\u304d\u307e\u3059\u306d\u3002\n\n\u9806\u5f53\u306b\u3044\u3051\u3070\u6b21\u306f\u30bd\u30b1\u30c3\u30c8\u306e bind \u3067\u3059\u306d\u3002\u30bd\u30fc\u30b9\u3092\u898b\u308b\u3068\u3001\u3053\u306e\u8fba\u308a\u306f generic::raw_protocol::endpoint \u304c\u62c5\u5f53\u3057\u3066\u3044\u308b\u3088\u3046\u3067\u3059\u3002\u540c\u69d8\u306b\u3057\u3066\u30cd\u30c3\u30c8\u30ef\u30fc\u30af\u30a4\u30f3\u30bf\u30fc\u30d5\u30a7\u30fc\u30b9\u306e\u8a2d\u5b9a\u3092\u4e0e\u3048\u308c\u3070\u3088\u3055\u305d\u3046\u3067\u3059\u306d\u3002\n\u30b3\u30f3\u30b9\u30c8\u30e9\u30af\u30bf\u306f 4\u3064 \u3042\u308a\u307e\u3059\u304c\u3001\u305d\u306e\u3046\u3061\u306e 1\u3064 \u306f void * \u306a socket_address \u3068 \u305d\u306e\u30b5\u30a4\u30ba\u3092\u53d6\u308a\u307e\u3059:\nhttp://www.boost.org/doc/libs/1_57_0/doc/html/boost_asio/reference/generic__basic_endpoint/basic_endpoint.html\n\u7d50\u8ad6\u304b\u3089\u8a00\u3046\u3068 socket_address \u306f struct sockaddr \u306b\u5bfe\u5fdc\u3057\u3066\u3044\u308b\u306e\u3067\u3001\u3053\u3053\u306b struct sockaddr_ll \u3092\u3076\u3061\u8fbc\u3081\u3070 OK \u3067\u3059\u3002\nstruct sockaddr_ll sll;\nmemset( &sll, 0, sizeof( sll ) );\nsll.sll_ifindex = if_nametoindex( \"<\u30cd\u30c3\u30c8\u30ef\u30fc\u30af\u30a4\u30f3\u30bf\u30fc\u30d5\u30a7\u30fc\u30b9\u540d>\" );\n\n...::endpoint endpoint( reinterpret_cast< struct sockaddr * >( &sll ), sizeof( sll ) );\n\n\u3042\u3068\u306f\u30a4\u30fc\u30b5\u30cd\u30c3\u30c8\u30d8\u30c3\u30c0\u3092\u81ea\u5206\u3067\u4f5c\u3063\u3066\u66f8\u304d\u8fbc\u3093\u3067 send_to \u3059\u308c\u3070\u9001\u4fe1\u304c\u3067\u304d\u307e\u3059\u3002\n\n\u9001\u4fe1\u30b5\u30f3\u30d7\u30eb\n\u9069\u5f53\u306a\u5b9f\u9a13\u7528\u30d1\u30b1\u30c3\u30c8\u3092\u6295\u3052\u308b\u30b5\u30f3\u30d7\u30eb\u306f\u4ee5\u4e0b\u3067\u3059:\n#include <netpacket/packet.h>\n#include <net/ethernet.h>\n#include <net/if.h>\n\n#include <iostream>\n#include <iterator>\n#include <string>\n#include <deque>\n#include <stdexcept>\n#include <cstdint>\n#include <utility>\n\n#include <boost/asio.hpp>\n#include <boost/tokenizer.hpp>\n#include <boost/range/adaptor/transformed.hpp>\n#include <boost/range/algorithm/copy.hpp>\n\n\n\n/**\n * MAC \u30a2\u30c9\u30ec\u30b9\u3092\u5207\u308a\u5206\u3051\u3066\u30a4\u30c6\u30ec\u30fc\u30bf\u306b\u66f8\u304d\u8fbc\u3080\n * @param reverse_byte_order \u30d0\u30a4\u30c8\u30aa\u30fc\u30c0\u30fc\u3092\u53cd\u8ee2\n */\ntemplate < typename OutputIterator >\nOutputIterator tokenize_and_copy(\n    std::string const &address,\n    OutputIterator     output_iterator,\n    bool const         reverse_byte_order = false\n)\n{\n    using SeparatorType = boost::char_separator< char >;\n    using TokenizerType = boost::tokenizer< SeparatorType >;\n\n    if ( address.length() != 17 )\n    {\n        throw std::runtime_error( \"the given address is malformed.\" );\n    }\n\n    SeparatorType const separator( \":\" );\n    TokenizerType const tokenizer( address, separator );\n\n    auto const transform_function = [] ( std::string const &string ) -> int\n    {\n        return std::stoi( string, nullptr, 16 );\n    };\n    auto const range = tokenizer |\n        boost::adaptors::transformed(\n            transform_function\n        );\n\n    std::deque< char > result;\n    if ( reverse_byte_order )\n    {\n        boost::copy( range, std::front_inserter( result ) );\n    }\n    else\n    {\n        boost::copy( range, std::back_inserter( result ) );\n    }\n\n    if ( result.size() != 6 )\n    {\n        throw std::runtime_error( \"the given address is malformed.\" );\n    }\n\n    return boost::copy( result, output_iterator );\n}\n\n\n/**\n * \u30a4\u30fc\u30b5\u30cd\u30c3\u30c8\u30d8\u30c3\u30c0\u3092\u4f5c\u3063\u3066\u30a4\u30c6\u30ec\u30fc\u30bf\u306b\u66f8\u304d\u8fbc\u3080\n */\ntemplate < typename OutputIterator >\nvoid generate_ethernet_header(\n    std::string const   &source,\n    std::string const   &destination,\n    std::uint32_t const &type,\n    OutputIterator      output_iterator,\n    bool const          reverse_byte_order = false\n)\n{\n    output_iterator = tokenize_and_copy( destination, output_iterator, reverse_byte_order );\n    output_iterator = tokenize_and_copy( source, output_iterator, reverse_byte_order );\n\n    const char type_array[] = { static_cast< char >( type & 0x00FF ), static_cast< char >( type >> 8 ) };\n    *output_iterator++ = type_array[ ( reverse_byte_order ? 0 : 1 ) ];\n    *output_iterator++ = type_array[ ( reverse_byte_order ? 1 : 0 ) ];\n}\n\n\nusing EndpointType = boost::asio::generic::raw_protocol::endpoint;\n\n/**\n * \u30cd\u30c3\u30c8\u30ef\u30fc\u30af\u30a4\u30f3\u30bf\u30fc\u30d5\u30a7\u30fc\u30b9\u540d\u304b\u3089 endpoint \u3092\u4f5c\u308b\n */\nEndpointType create_ethernet_endpoint( std::string const &ifname )\n{\n    struct sockaddr_ll sll;\n    memset( &sll, 0, sizeof( sll ) );\n    sll.sll_ifindex = if_nametoindex( ifname.c_str() );\n\n    return std::move(\n        EndpointType( reinterpret_cast< EndpointType::data_type * >( &sll ), sizeof( sll ) )\n    );\n}\n\n\nint main()\n{\n    using IoServiceType = boost::asio::io_service;\n    using ProtocolType  = boost::asio::generic::raw_protocol;\n    using SocketType    = boost::asio::basic_raw_socket< ProtocolType >;\n\n    IoServiceType io_service;\n    SocketType    socket( io_service );\n    ProtocolType  protocol( AF_PACKET, htons( ETH_P_ALL ) );\n\n    boost::asio::streambuf buffer;\n    std::ostream stream( &buffer );\n\n    // \u30a4\u30fc\u30b5\u30cd\u30c3\u30c8\u30d8\u30c3\u30c0\u3092\u66f8\u304d\u8fbc\u3080\n    generate_ethernet_header(\n        \"12:34:56:78:90:ab\",\n        \"FF:FF:FF:FF:FF:FF\",\n        0x1001,\n        std::ostream_iterator< char >( stream )\n    );\n\n    // \u30c7\u30fc\u30bf\u90e8\u5206\u3092\u66f8\u304d\u8fbc\u3080\n    unsigned char const deadbeef[] = { 0xde, 0xad, 0xbe, 0xef };\n    stream << \"Hello, Ojisan!!!\"\n           << reinterpret_cast< char const * >( deadbeef );\n\n    boost::system::error_code error;\n\n    socket.open( protocol );\n    auto const size = socket.send_to(\n        buffer.data(),\n        create_ethernet_endpoint( \"enp3s0\" ),\n        0,\n        error\n    );\n\n    std::cout << error << std::endl;\n    return 0;\n}\n\n\u9001\u4fe1\u5143 MAC \u30a2\u30c9\u30ec\u30b9\u306f 12:34:56:78:90:ab, \u5b9b\u5148\u306f FF:FF:FF:FF:FF:FF \u3067\u3001\u5185\u5bb9\u306f \"Hello, Ojisan!!!\" \u3068\u3044\u3046\u6587\u5b57\u5217\u3068 0xdeadbeef \u306e\u30d0\u30a4\u30ca\u30ea\u3092\u5165\u308c\u3066\u9001\u4fe1\u3057\u307e\u3057\u305f\u3002\u30a4\u30fc\u30b5\u30cd\u30c3\u30c8\u30d5\u30ec\u30fc\u30e0\u306e\u30bf\u30a4\u30d7\u306f Wireshark \u3067\u308f\u304b\u308a\u3084\u3059\u3044\u3088\u3046\u306b\u9069\u5f53\u306b 0x1001 \u306b\u3057\u307e\u3057\u305f\u304c\u3001\u672c\u5f53\u306f\u3053\u3053\u306b\u306e\u305b\u308b\u30d1\u30b1\u30c3\u30c8\u306e\u30bf\u30a4\u30d7\u3092\u5165\u308c\u308b\u3053\u3068\u306f\u8a00\u3046\u306b\u53ca\u3073\u307e\u305b\u3093\u306d\u3002\n\n\n\u4f59\u8ac7\npython \u3060\u3068\u540c\u3058\u3088\u3046\u306a\u3053\u3068\u3059\u308b\u306e\u306b\u697d\u3059\u304e\u3066\u30d3\u30d3\u308a\u307e\u304f\u308a\u307e\u3057\u305f ( \u3055\u3063\u304d\u30b3\u30fc\u30c9\u3068\u3044\u308d\u3093\u306a\u610f\u5473\u5408\u3044\u304c\u9055\u3046\u306e\u3067\u9b3c\u4e0d\u516c\u5e73\u3067\u3059\u304c\u2026\u2026 )\u3002C++ \u3068\u306f\u9055\u3063\u305f\u697d\u3057\u3055\u3002\u8a66\u3057\u306b\u66f8\u304f\u306e\u306b\u3061\u3087\u3046\u3069\u3044\u3044\u3067\u3059\u306d:\nimport socket\n\nsource = b\"\\x11\\x22\\x33\\x44\\x55\\xab\"\ndestination = b\"\\xff\\xff\\xff\\xff\\xff\\xff\"\ntype = b\"\\x10\\x01\"\ndata = b\"Hello, Ojisan!!!\\xde\\xad\\xbe\\xef\"\n\nsocket = socket.socket(socket.AF_PACKET, socket.SOCK_RAW)\nsocket.bind((\"enp3s0\", 0))\npayload = destination + source + type + data\nsocket.send(payload)\n\n# \u306f\u3058\u3081\u306b\n\u30ea\u30f3\u30af\u30ec\u30a4\u30e4\u30fc\u306e\u30d1\u30b1\u30c3\u30c8\u3092\u6271\u3044\u305f\u3044\u3068\u304d\u304c\u3042\u308b\u3001\u304b\u3068\u8a00\u308f\u308c\u305f\u3089\u306a\u3044\u304b\u3082\u3057\u308c\u307e\u305b\u3093\u304c\u2026\u2026\u3002\u624b\u63a2\u308a\u306e\u899a\u66f8\u3068\u3057\u3066\u6b8b\u3057\u3066\u304a\u304d\u307e\u3059\u3002\u78ba\u8a8d\u74b0\u5883\u306f clang on Linux \u3067\u3059\u3002\n\n# \u6982\u8aac\n`C` \u306a\u3089\u3070\u304a\u3082\u3080\u308d\u306b\u30bd\u30b1\u30c3\u30c8\u3092\u958b\u3044\u3066 `PF_PACKET` \u3068 `SOCK_RAW` \u3092\u3076\u3061\u8fbc\u3081\u3070\u3001\u4f4e\u5c64\u306e\u30d1\u30b1\u30c3\u30c8\u3092\u6271\u3046\u3053\u3068\u304c\u3067\u304d\u307e\u3059\u306e\u3067\u3001`C++` \u3067\u3082\u540c\u69d8\u306b\u3057\u3066\u958b\u3051\u307e\u3059\u3002`C++` \u30c1\u30c3\u30af\u306b\u306a\u306b\u304b\u3067\u304d\u306a\u3044\u304b\u63a2\u3057\u307e\u3057\u305f\u3002\n\n`Boost.Asio` \u306a\u3089\u306a\u3093\u3068\u304b\u3057\u3066\u304f\u308c\u308b\u306b\u9055\u3044\u306a\u3044\u3002`generic::raw_protocol` \u3084 `basic_raw_socket` \u3042\u305f\u308a\u304c\u602a\u3057\u3044\u306e\u3067\u3053\u306e\u8fba\u308a\u3092\u3064\u3064\u3044\u3066\u307f\u307e\u3059\u3002:\nhttp://www.boost.org/doc/libs/1_57_0/doc/html/boost_asio/reference.html\n\n\u3061\u3087\u3046\u3069 `raw_protocol` \u306e Examples \u306b\u898b\u305f\u3053\u3068\u306e\u3042\u308b\u3088\u3046\u306a\u4f8b\u304c\u3042\u308a\u307e\u3057\u305f:\n\n```cpp\nraw_protocol p(AF_INET, IPPROTO_ICMP);\n```\n\n\u30cd\u30a4\u30c6\u30a3\u30d6\u306e\u30a2\u30c9\u30ec\u30b9\u30d5\u30a1\u30df\u30ea\u30fc\u3092\u6307\u5b9a\u3057\u3066\u3044\u307e\u3059\u3002\u3053\u3053\u3067\u30bd\u30b1\u30c3\u30c8\u3068\u30d7\u30ed\u30c8\u30b3\u30eb\u306e\u30d5\u30e9\u30b0\u3092\u7ba1\u7406\u3057\u3066\u3044\u308b\u3088\u3046\u3067\u3059\u3002C \u3068\u540c\u69d8\u306e\u5024\u3092\u4e0e\u3048\u308c\u3070 open \u6642\u306b raw socket \u306e\u30d1\u30e9\u30e1\u30fc\u30bf\u3092\u4e0e\u3048\u308b\u3053\u3068\u304c\u3067\u304d\u307e\u3059\u306d\u3002\n\n---\n\n\u9806\u5f53\u306b\u3044\u3051\u3070\u6b21\u306f\u30bd\u30b1\u30c3\u30c8\u306e `bind` \u3067\u3059\u306d\u3002\u30bd\u30fc\u30b9\u3092\u898b\u308b\u3068\u3001\u3053\u306e\u8fba\u308a\u306f `generic::raw_protocol::endpoint` \u304c\u62c5\u5f53\u3057\u3066\u3044\u308b\u3088\u3046\u3067\u3059\u3002\u540c\u69d8\u306b\u3057\u3066\u30cd\u30c3\u30c8\u30ef\u30fc\u30af\u30a4\u30f3\u30bf\u30fc\u30d5\u30a7\u30fc\u30b9\u306e\u8a2d\u5b9a\u3092\u4e0e\u3048\u308c\u3070\u3088\u3055\u305d\u3046\u3067\u3059\u306d\u3002\n\n\u30b3\u30f3\u30b9\u30c8\u30e9\u30af\u30bf\u306f 4\u3064 \u3042\u308a\u307e\u3059\u304c\u3001\u305d\u306e\u3046\u3061\u306e 1\u3064 \u306f `void *` \u306a `socket_address` \u3068 \u305d\u306e\u30b5\u30a4\u30ba\u3092\u53d6\u308a\u307e\u3059:\n\nhttp://www.boost.org/doc/libs/1_57_0/doc/html/boost_asio/reference/generic__basic_endpoint/basic_endpoint.html\n\n\u7d50\u8ad6\u304b\u3089\u8a00\u3046\u3068 `socket_address` \u306f `struct sockaddr` \u306b\u5bfe\u5fdc\u3057\u3066\u3044\u308b\u306e\u3067\u3001\u3053\u3053\u306b `struct sockaddr_ll` \u3092\u3076\u3061\u8fbc\u3081\u3070 OK \u3067\u3059\u3002\n\n```cpp\nstruct sockaddr_ll sll;\nmemset( &sll, 0, sizeof( sll ) );\nsll.sll_ifindex = if_nametoindex( \"<\u30cd\u30c3\u30c8\u30ef\u30fc\u30af\u30a4\u30f3\u30bf\u30fc\u30d5\u30a7\u30fc\u30b9\u540d>\" );\n\n...::endpoint endpoint( reinterpret_cast< struct sockaddr * >( &sll ), sizeof( sll ) );\n```\n\n\u3042\u3068\u306f\u30a4\u30fc\u30b5\u30cd\u30c3\u30c8\u30d8\u30c3\u30c0\u3092\u81ea\u5206\u3067\u4f5c\u3063\u3066\u66f8\u304d\u8fbc\u3093\u3067 `send_to` \u3059\u308c\u3070\u9001\u4fe1\u304c\u3067\u304d\u307e\u3059\u3002\n\n# \u9001\u4fe1\u30b5\u30f3\u30d7\u30eb\n\u9069\u5f53\u306a\u5b9f\u9a13\u7528\u30d1\u30b1\u30c3\u30c8\u3092\u6295\u3052\u308b\u30b5\u30f3\u30d7\u30eb\u306f\u4ee5\u4e0b\u3067\u3059:\n\n```cpp\n#include <netpacket/packet.h>\n#include <net/ethernet.h>\n#include <net/if.h>\n\n#include <iostream>\n#include <iterator>\n#include <string>\n#include <deque>\n#include <stdexcept>\n#include <cstdint>\n#include <utility>\n\n#include <boost/asio.hpp>\n#include <boost/tokenizer.hpp>\n#include <boost/range/adaptor/transformed.hpp>\n#include <boost/range/algorithm/copy.hpp>\n\n\n\n/**\n * MAC \u30a2\u30c9\u30ec\u30b9\u3092\u5207\u308a\u5206\u3051\u3066\u30a4\u30c6\u30ec\u30fc\u30bf\u306b\u66f8\u304d\u8fbc\u3080\n * @param reverse_byte_order \u30d0\u30a4\u30c8\u30aa\u30fc\u30c0\u30fc\u3092\u53cd\u8ee2\n */\ntemplate < typename OutputIterator >\nOutputIterator tokenize_and_copy(\n\tstd::string const &address,\n\tOutputIterator     output_iterator,\n\tbool const         reverse_byte_order = false\n)\n{\n\tusing SeparatorType = boost::char_separator< char >;\n\tusing TokenizerType = boost::tokenizer< SeparatorType >;\n\n\tif ( address.length() != 17 )\n\t{\n\t\tthrow std::runtime_error( \"the given address is malformed.\" );\n\t}\n\n\tSeparatorType const separator( \":\" );\n\tTokenizerType const tokenizer( address, separator );\n\n\tauto const transform_function = [] ( std::string const &string ) -> int\n\t{\n\t\treturn std::stoi( string, nullptr, 16 );\n\t};\n\tauto const range = tokenizer |\n\t\tboost::adaptors::transformed(\n\t\t\ttransform_function\n\t\t);\n\n\tstd::deque< char > result;\n\tif ( reverse_byte_order )\n\t{\n\t\tboost::copy( range, std::front_inserter( result ) );\n\t}\n\telse\n\t{\n\t\tboost::copy( range, std::back_inserter( result ) );\n\t}\n\n\tif ( result.size() != 6 )\n\t{\n\t\tthrow std::runtime_error( \"the given address is malformed.\" );\n\t}\n\n\treturn boost::copy( result, output_iterator );\n}\n\n\n/**\n * \u30a4\u30fc\u30b5\u30cd\u30c3\u30c8\u30d8\u30c3\u30c0\u3092\u4f5c\u3063\u3066\u30a4\u30c6\u30ec\u30fc\u30bf\u306b\u66f8\u304d\u8fbc\u3080\n */\ntemplate < typename OutputIterator >\nvoid generate_ethernet_header(\n\tstd::string const   &source,\n\tstd::string const   &destination,\n\tstd::uint32_t const &type,\n\tOutputIterator      output_iterator,\n\tbool const          reverse_byte_order = false\n)\n{\n\toutput_iterator = tokenize_and_copy( destination, output_iterator, reverse_byte_order );\n\toutput_iterator = tokenize_and_copy( source, output_iterator, reverse_byte_order );\n\t\n\tconst char type_array[] = { static_cast< char >( type & 0x00FF ), static_cast< char >( type >> 8 ) };\n\t*output_iterator++ = type_array[ ( reverse_byte_order ? 0 : 1 ) ];\n\t*output_iterator++ = type_array[ ( reverse_byte_order ? 1 : 0 ) ];\n}\n\n\nusing EndpointType = boost::asio::generic::raw_protocol::endpoint;\n\n/**\n * \u30cd\u30c3\u30c8\u30ef\u30fc\u30af\u30a4\u30f3\u30bf\u30fc\u30d5\u30a7\u30fc\u30b9\u540d\u304b\u3089 endpoint \u3092\u4f5c\u308b\n */\nEndpointType create_ethernet_endpoint( std::string const &ifname )\n{\n\tstruct sockaddr_ll sll;\n\tmemset( &sll, 0, sizeof( sll ) );\n\tsll.sll_ifindex = if_nametoindex( ifname.c_str() );\n\n\treturn std::move(\n\t\tEndpointType( reinterpret_cast< EndpointType::data_type * >( &sll ), sizeof( sll ) )\n\t);\n}\n\n\nint main()\n{\n\tusing IoServiceType = boost::asio::io_service;\n\tusing ProtocolType  = boost::asio::generic::raw_protocol;\n\tusing SocketType    = boost::asio::basic_raw_socket< ProtocolType >;\n\n\tIoServiceType io_service;\n\tSocketType    socket( io_service );\n\tProtocolType  protocol( AF_PACKET, htons( ETH_P_ALL ) );\n\n\tboost::asio::streambuf buffer;\n\tstd::ostream stream( &buffer );\n\n\t// \u30a4\u30fc\u30b5\u30cd\u30c3\u30c8\u30d8\u30c3\u30c0\u3092\u66f8\u304d\u8fbc\u3080\n\tgenerate_ethernet_header(\n\t\t\"12:34:56:78:90:ab\",\n\t\t\"FF:FF:FF:FF:FF:FF\",\n\t\t0x1001,\n\t\tstd::ostream_iterator< char >( stream )\n\t);\n\n\t// \u30c7\u30fc\u30bf\u90e8\u5206\u3092\u66f8\u304d\u8fbc\u3080\n\tunsigned char const deadbeef[] = { 0xde, 0xad, 0xbe, 0xef };\n\tstream << \"Hello, Ojisan!!!\"\n\t       << reinterpret_cast< char const * >( deadbeef );\n\n\tboost::system::error_code error;\n\n\tsocket.open( protocol );\n\tauto const size = socket.send_to(\n\t\tbuffer.data(),\n\t\tcreate_ethernet_endpoint( \"enp3s0\" ),\n\t\t0,\n\t\terror\n\t);\n\n\tstd::cout << error << std::endl;\n\treturn 0;\n}\n```\n\n\u9001\u4fe1\u5143 MAC \u30a2\u30c9\u30ec\u30b9\u306f `12:34:56:78:90:ab`, \u5b9b\u5148\u306f `FF:FF:FF:FF:FF:FF` \u3067\u3001\u5185\u5bb9\u306f `\"Hello, Ojisan!!!\"` \u3068\u3044\u3046\u6587\u5b57\u5217\u3068 `0xdeadbeef` \u306e\u30d0\u30a4\u30ca\u30ea\u3092\u5165\u308c\u3066\u9001\u4fe1\u3057\u307e\u3057\u305f\u3002\u30a4\u30fc\u30b5\u30cd\u30c3\u30c8\u30d5\u30ec\u30fc\u30e0\u306e\u30bf\u30a4\u30d7\u306f Wireshark \u3067\u308f\u304b\u308a\u3084\u3059\u3044\u3088\u3046\u306b\u9069\u5f53\u306b `0x1001` \u306b\u3057\u307e\u3057\u305f\u304c\u3001\u672c\u5f53\u306f\u3053\u3053\u306b\u306e\u305b\u308b\u30d1\u30b1\u30c3\u30c8\u306e\u30bf\u30a4\u30d7\u3092\u5165\u308c\u308b\u3053\u3068\u306f\u8a00\u3046\u306b\u53ca\u3073\u307e\u305b\u3093\u306d\u3002\n\n![Screenshot from 2014-11-12 02:12:46.png](https://qiita-image-store.s3.amazonaws.com/0/49677/c74bcb04-95be-876c-a950-74120233a46f.png)\n\n# \u4f59\u8ac7\n`python` \u3060\u3068\u540c\u3058\u3088\u3046\u306a\u3053\u3068\u3059\u308b\u306e\u306b\u697d\u3059\u304e\u3066\u30d3\u30d3\u308a\u307e\u304f\u308a\u307e\u3057\u305f ( \u3055\u3063\u304d\u30b3\u30fc\u30c9\u3068\u3044\u308d\u3093\u306a\u610f\u5473\u5408\u3044\u304c\u9055\u3046\u306e\u3067\u9b3c\u4e0d\u516c\u5e73\u3067\u3059\u304c\u2026\u2026 )\u3002`C++` \u3068\u306f\u9055\u3063\u305f\u697d\u3057\u3055\u3002\u8a66\u3057\u306b\u66f8\u304f\u306e\u306b\u3061\u3087\u3046\u3069\u3044\u3044\u3067\u3059\u306d:\n\n```py3\nimport socket\n\nsource = b\"\\x11\\x22\\x33\\x44\\x55\\xab\"\ndestination = b\"\\xff\\xff\\xff\\xff\\xff\\xff\"\ntype = b\"\\x10\\x01\"\ndata = b\"Hello, Ojisan!!!\\xde\\xad\\xbe\\xef\"\n\nsocket = socket.socket(socket.AF_PACKET, socket.SOCK_RAW)\nsocket.bind((\"enp3s0\", 0))\npayload = destination + source + type + data\nsocket.send(payload)\n```\n", "tags": ["C++", "boost", "Network"]}