{"context": " More than 1 year has passed since last update.One year ago, I was working on a content web site, using Azure Table. To take advantage of NoSql query, we design the table like:\n\n\n\nPartitionKey\nRangeKey\nSome_other attr\n\n\n\n\nuser_id\nticks_to_judgementday\nvalues\n\n\n\nThe point of using this pattern is that many websites nowadays have scenarios querying contents ordering with the time when they are established. And Azure table and DynamoDB have PartitionKey(HashKey) and RangeKeyBy, of which composite is the identity of an item. All the items with same PartitionKey is sorted by RangeKey. So if you query out some items by using a specific PartitionKey, the results are ordered by RangeKey already.  \nHere are some really good posts about these concepts:\nhttp://blog.maartenballiauw.be/post/2012/10/08/What-PartitionKey-and-RowKey-are-for-in-Windows-Azure-Table-Storage.aspx\nhttp://www.allthingsdistributed.com/2013/12/dynamodb-global-secondary-indexes.html\nBy using this pattern, we can query items for one user based on their established time without any extra query, or extra indexes.\nRangeKey's definition is like: \n// wrap values\nLong rangeKey = Long.MaxValue - DateTime.Now.\n\nMost importantly, what make this pattern work is that the range key here(Ticks), is relatively identical for every player, because Ticks is 100 nano seconds, and we can assume that there will be no way that one user will get two feeds in 100 nano seconds.\n\nTicks in Java\n\nnew Date().getTime()\nSystem.nanoTime()\n\nI have left the world of C# for a long time (really miss it, really), and now I am working with Java. The recent project I have been walking into a very similar scenario: saving things in DynamoDB and fetch items in time order.\nSo, I want to play old trick. \nThe first thing I have to do is finding equivalent to Ticks in C# world.\nDate.getTime() seems very natural, because it is the Ticks in milliseconds. In some background it can work like a charm with this pattern. The point is whether it is identical for each PartitionKey.\nTo me, millisecond is not enough. So I found System.nanoTime() which fit my need.\nIt is the number of nano seconds since every thing began (1970/1/1), so I can feel save with its identity.\n\nUse ticks in DynamoDB\nDynamoDB shares a lot of similarity with Azure Table. It has HashKey and RangeKey, instead of PartitionKey and RangeKey. The use of this pattern is almost the same with that in C#.\nNow let us see how this pattern benefit us in content web site.\n// create a post\n\npublic static Result CreatePost(String editorId, String content) {\n    // validation...validation...validation...\n\n    List<User> followers = MysqlHelper.getFollowers(editorId);\n\n    // feed to self\n    FeedTo(editorId, content);\n\n    // feed to followers\n    for (User follower : followers) {\n        FeedTo(follower.id, content);\n    }\n\n    return SuccResult();\n}\n\n\n\npubic static void FeedTo(String userid, String content) {\n    Map feed = new HashMap();\n    feed.put(\"partition_key\", new AttributeValue().withS(userid));\n    feed.put(\"range_key\", new AttributeValue().withN(Long.toString(Long.MAX_VALUE - System.nanoTime())));\n    feed.put(\"content\", new AttributeValue().withS(content));\n}\n\nThen you can fetch feeds in bulk by:\npublic static FeedResult GetFeeds(String userId, Long lastRangeKey) {\n    // check stimulus pool\n\n    Condition hashCondition = new Condition()\n        .withComparisonOperator(ComparisonOperator.EQ)\n        .withAttributeValueList(new AttributeValue().withS(userId));\n\n    Condition rangeCondition = new Condition()\n        .withComparisonOperator(ComparisonOperator.LE)\n        .withAttributeValueList(new AttributeValue().withN(Long.toString(lastRangeKey)));\n\n    Map<String, Condition> keyConditions = new HashMap<>();\n    keyConditions.put(\"partition_key\", hashCondition);\n    keyConditions.put(\"range_key\", rangeCondition);\n\n    QueryRequest queryRequest = new QueryRequest()\n        .withTableName(\"ticks_test_table\")\n        .withKeyConditions(keyConditions);\n\n    QueryResult queryResult = testDynamoClient.query(queryRequest);\n    List<Map<String, AttributeValue>> selectOuts = queryResult.getItems();\n\n    FeedResult result = WrapFeedResult(selectOuts); // note to return the max range key in result to perform a pagination\n    return result;\n}\n\nTo implement pagination, you will need to return the max range key in current result, or you can leave it to client. Then they can use it as a param (lastRangeKey) for paging.\n\nImprovement\nMay hold connection while feeding to followers when create post is not ideal. We can make some improvement about it. If we have a message bus and a worker program, we can send this part of work to the worker and let it finish it self.\npublic static Result CreatePost(String editorId, String content) {\n    // validation...validation...validation...\n\n    // feed to self\n    FeedTo(editorId, content);\n\n    SendPostCreateWork(editor, content);\n\n    return SuccResult();\n}\n\nIn aspect of user experience, the editor can see the post he has just written after server returns. And it not matters much if his followers can see this post with a little delay, because the worker might be working hard on sending oi in this period of time.\n\nOne year ago, I was working on a content web site, using Azure Table. To take advantage of NoSql query, we design the table like:\n\n| PartitionKey | RangeKey | Some_other attr |\n|--------------|----------|-----------------|\n| user_id | ticks_to_judgementday| values|\n\n\nThe point of using this pattern is that many websites nowadays have scenarios querying contents ordering with the time when they are established. And Azure table and DynamoDB have PartitionKey(HashKey) and RangeKeyBy, of which composite is the identity of an item. All the items with same PartitionKey is sorted by RangeKey. So if you query out some items by using a specific PartitionKey, the results are ordered by RangeKey already.  \n\nHere are some really good posts about these concepts:\n\n[http://blog.maartenballiauw.be/post/2012/10/08/What-PartitionKey-and-RowKey-are-for-in-Windows-Azure-Table-Storage.aspx](http://blog.maartenballiauw.be/post/2012/10/08/What-PartitionKey-and-RowKey-are-for-in-Windows-Azure-Table-Storage.aspx)\n\n[http://www.allthingsdistributed.com/2013/12/dynamodb-global-secondary-indexes.html](http://www.allthingsdistributed.com/2013/12/dynamodb-global-secondary-indexes.html)\n\nBy using this pattern, we can query items for one user based on their established time without any extra query, or extra indexes.\nRangeKey's definition is like: \n\n```csharp\n// wrap values\nLong rangeKey = Long.MaxValue - DateTime.Now.\n```\n\nMost importantly, what make this pattern work is that the range key here(`Ticks`), is relatively identical for every player, because `Ticks` is 100 nano seconds, and we can assume that there will be no way that one user will get two feeds in 100 nano seconds.\n\n# Ticks in Java\n\n- `new Date().getTime()`\n- `System.nanoTime()`\n\nI have left the world of C# for a long time (really miss it, really), and now I am working with Java. The recent project I have been walking into a very similar scenario: saving things in DynamoDB and fetch items in time order.\n\nSo, I want to play old trick. \n\n\nThe first thing I have to do is finding equivalent to `Ticks` in C# world.\n\n`Date.getTime()` seems very natural, because it is the `Ticks` in milliseconds. In some background it can work like a charm with this pattern. The point is ***whether it is identical for each PartitionKey***.\n\nTo me, millisecond is not enough. So I found `System.nanoTime()` which fit my need.\nIt is the number of nano seconds since every thing began (1970/1/1), so I can feel save with its identity.\n\n# Use ticks in DynamoDB\n\nDynamoDB shares a lot of similarity with Azure Table. It has HashKey and RangeKey, instead of PartitionKey and RangeKey. The use of this pattern is almost the same with that in C#.\n\nNow let us see how this pattern benefit us in content web site.\n\n```java\n// create a post\n\npublic static Result CreatePost(String editorId, String content) {\n    // validation...validation...validation...\n\n    List<User> followers = MysqlHelper.getFollowers(editorId);\n    \n    // feed to self\n    FeedTo(editorId, content);\n\n    // feed to followers\n    for (User follower : followers) {\n        FeedTo(follower.id, content);\n    }\n\n    return SuccResult();\n}\n\n\n\npubic static void FeedTo(String userid, String content) {\n    Map feed = new HashMap();\n    feed.put(\"partition_key\", new AttributeValue().withS(userid));\n    feed.put(\"range_key\", new AttributeValue().withN(Long.toString(Long.MAX_VALUE - System.nanoTime())));\n    feed.put(\"content\", new AttributeValue().withS(content));\n}\n```\n\n\nThen you can fetch feeds in bulk by:\n\n```java\npublic static FeedResult GetFeeds(String userId, Long lastRangeKey) {\n    // check stimulus pool\n    \n    Condition hashCondition = new Condition()\n        .withComparisonOperator(ComparisonOperator.EQ)\n        .withAttributeValueList(new AttributeValue().withS(userId));\n    \n    Condition rangeCondition = new Condition()\n        .withComparisonOperator(ComparisonOperator.LE)\n        .withAttributeValueList(new AttributeValue().withN(Long.toString(lastRangeKey)));\n    \n    Map<String, Condition> keyConditions = new HashMap<>();\n    keyConditions.put(\"partition_key\", hashCondition);\n    keyConditions.put(\"range_key\", rangeCondition);\n    \n    QueryRequest queryRequest = new QueryRequest()\n        .withTableName(\"ticks_test_table\")\n        .withKeyConditions(keyConditions);\n    \n    QueryResult queryResult = testDynamoClient.query(queryRequest);\n    List<Map<String, AttributeValue>> selectOuts = queryResult.getItems();\n    \n    FeedResult result = WrapFeedResult(selectOuts); // note to return the max range key in result to perform a pagination\n    return result;\n}\n```\n\nTo implement pagination, you will need to return the max range key in current result, or you can leave it to client. Then they can use it as a param (`lastRangeKey`) for paging.\n\n\n# Improvement \n\nMay hold connection while feeding to followers when create post is not ideal. We can make some improvement about it. If we have a message bus and a worker program, we can ***send this part of work to the worker and let it finish it self***.\n\n```java\npublic static Result CreatePost(String editorId, String content) {\n    // validation...validation...validation...\n\n    // feed to self\n    FeedTo(editorId, content);\n\n    SendPostCreateWork(editor, content);\n\n    return SuccResult();\n}\n```\n\nIn aspect of user experience, the editor can see the post he has just written after server returns. And it not matters much if his followers can see this post with a little delay, because the worker might be working hard on sending oi in this period of time.\n", "tags": ["Java", "nosql", "DynamoDB"]}