{"context": " More than 1 year has passed since last update.\u203bRust0.7\u3067\u4f5c\u6210\u3057\u307e\u3057\u305f\u3002\n\u4eca\u56de\u306f\u4ee5\u4e0b\u306e\u30ea\u30d5\u30a1\u30af\u30bf\u30ea\u30f3\u30b0\u3092\u884c\u3044\u307e\u3057\u305f\u3002\n\ncopy\u306f\u4f7f\u308f\u306a\u304f\u3057\u3066\u3001clone\u3092\u4f7f\u3046\u3088\u3046\u306b\u3057\u307e\u3057\u305f\u3002\nJoinable\u3068\u3044\u3046\u30c8\u30ec\u30a4\u30c8\u3092\u4f5c\u3063\u3066\u6c4e\u7528\u7684\u306aJoin\u3092\u4f5c\u308a\u307e\u3057\u305f\u3002\nmacro\u3092\u4f7f\u3063\u3066\u8907\u6570\u306eimpl\u3092\uff11\u3064\u306b\u7e8f\u3081\u307e\u3057\u305f\u3002\n\nuse join::Joinable;\nuse ast::*;\n\npub mod ast {\n\n  #[deriving(Clone,ToStr)]\n  pub enum E {\n    ELdc(~T, int),\n    EBin(~T, ~str, ~E, ~E),\n    EPrint(~T, ~E),\n    EBlock(~T, ~[~E]),\n  }\n\n  macro_rules! EOp(\n    ($T:ident, $op:expr) => (\n      pub fn $T(t: ~T, a: ~E, b: ~E) -> E {\n        EBin(t, ~$op, a, b)\n      }\n    )\n  )\n\n  EOp!(EAdd, \"add\")\n  EOp!(ESub, \"sub\")\n  EOp!(EMul, \"mul\")\n  EOp!(EDiv, \"div\")\n\n  #[deriving(Clone,ToStr)]\n  pub enum T {\n    Ti(int),\n    Tv,\n    TFun(~T, ~[~T]),\n  }\n\n  #[deriving(Clone,ToStr)]\n  pub enum R {\n    pub RG(~T, ~str),\n    pub RL(~T, ~str),\n    pub RR(~T, ~str),\n    pub RN(~T, ~str),\n  }\n\n  #[deriving(Clone,ToStr)]\n  pub enum LL {\n    LLCall(Option<~R>, ~R, ~[~R]),\n    LLBin(Option<~R>, ~str, ~R, ~R),\n  }\n\n  macro_rules! impl_ToStr_for(\n    ($T:ty) => (\n      impl ToStr for $T {\n        #[inline]\n        fn to_str(&self) -> ~str {\n          fmt!(\"%?\", *self)\n        }\n      }\n    )\n  )\n\n  macro_rules! impl_ToStr_for_Option(\n    ($T:ty) => (\n      impl ToStr for Option<$T> {\n        fn to_str(&self) -> ~str {\n          match *self {\n            Some(ref r) => fmt!(\"Some(%?)\",r),\n            None => ~\"None\",\n          }\n        }\n      }\n    )\n  )\n\n  impl_ToStr_for!(~E)\n  impl_ToStr_for!(~T)\n  impl_ToStr_for!(~R)\n  impl_ToStr_for!(~LL)\n\n  impl_ToStr_for_Option!(~R)\n\n  impl Eq for T {\n\n    pub fn eq(&self, t:&T) -> bool {\n      self.to_str() == t.to_str()\n    }\n\n    pub fn ne(&self, t:&T) -> bool {\n      !(self == t)\n    }\n\n  }\n\n  impl R {\n\n    pub fn t(&self) -> ~T {\n      match *self {\n        RG(ref t, _) => t.clone(),\n        RL(ref t, _) => t.clone(),\n        RR(ref t, _) => t.clone(),\n        RN(ref t, _) => t.clone(),\n      }\n    }\n\n  }\n\n  pub trait P {\n    fn p(&self) -> ~str;\n  }\n\n  impl P for T {\n    pub fn p(&self) -> ~str {\n      match *self {\n        Ti(ref i) => \"i\" + i.to_str(),\n        Tv => ~\"void\",\n        TFun(ref t, ref ls) => {\n          t.p() + \"(\" + ls.map(|t| t.p()).join(\", \") + \")*\"\n        }\n      }\n    }\n\n  }\n\n  impl P for R {\n    pub fn p(&self) -> ~str {\n      match *self {\n        RG(_,ref id) => \"@\" + *id,\n        RL(_,ref id) => \"%\" + *id,\n        RR(_,ref id) => \"%.\" + *id,\n        RN(_,ref id) => id.clone(),\n      }\n    }\n\n  }\n\n}\n\n\nfn main() {\n//    println(os::getcwd().to_str());\n//    println(os::getenv(\"PATH\").unwrap());\n//    os::setenv(\"PATH\", os::getenv(\"PATH\").unwrap());\n//    println(readAll(\"test.rs\"));\n//    writeAll(\"tes.txt\", \"hogehoge\");\n\n  let ast = ~EBlock(~Tv, ~[\n    ~EPrint(~Ti(32), ~ELdc(~Ti(32), 11)),\n    ~EPrint(~Ti(32),\n      ~EAdd(~Ti(32), ~ELdc(~Ti(32), 11), ~ELdc(~Ti(32), 22)))\n  ]);\n  println(\"ast=\" + ast.to_str());\n\n  let ll = kNormal(ast);\n  println(\"ll=\" + ll.to_str());\n\n  emit(\"e.ll\", ll);\n\n  println(exec(\"llc e.ll -o e.s\").to_str());\n  println(exec(\"llvm-gcc -m64 e.s -o e\").to_str());\n  println(exec(\"./e\").to_str());\n}\n\nmod interpreter {\n  use ast::*;\n\n  fn eval(e:&E)->int {\n\n    match e {\n\n      &ELdc(_, i) => i,\n\n      &EBin(_, ~\"add\", ref a, ref b) => eval(*a) + eval(*b),\n\n      &EBin(_, ref op, _, _) => fail!(\"operator \"+*op),\n\n      &EPrint(_, ref e) => {\n        let e = eval(*e);\n        println(e.to_str());\n        e\n      }\n\n      &EBlock(_, ref ls) => {\n        fn f(ls:&[~E],r:int)-> int {\n          match ls {\n            [] => r,\n            [ref a, ..rest] => f(rest,eval(*a))\n          }\n        }\n        f(*ls, 0)\n      }\n    }\n  }\n}\n\nmod kNormal {\n  use ast::*;\n  use std::vec;\n\n  fn gid(t:&T)-> ~R {\n    ~RR(~(*t).clone(),~\"\")\n  }\n\n  static mut ls:Option<~[~LL]> = None;\n\n  fn add(l:~LL) {\n    unsafe {\n      ls = Some(vec::append_one(ls.unwrap(), l));\n    }\n  }\n\n  fn f(a: &E)-> ~R {\n\n    match a {\n\n      &EBin(ref t,ref op, ref a, ref b) => {\n        let a = f(*a);\n        let b = f(*b);\n        let id = gid(*t);\n        if (*t != a.t() || *t != b.t()) {fail!(fmt!(\"type mismatch %?\",*t));}\n        add(~LLBin(Some(id.clone()), op.clone(), a, b));\n        id\n      }\n\n      &ELdc(ref t, ref i) => ~RN(t.clone(), i.to_str()),\n\n      &EPrint(ref t, ref a) => {\n        let a = f(*a);\n        if (*t != a.t()) {fail!(fmt!(\"type mismatch t=%? ta=%?\", t, a.t()))}\n        add(~LLCall(None, ~RG(~TFun(~Tv, ~[t.clone()]), \"print_\" + t.p()), ~[a.clone()]));\n        a\n      }\n\n      &EBlock(_,ref ls) => {\n        fn f2(ls:&[~E],r:&R)-> ~R {\n          match ls {\n            [] => ~r.clone(),\n            [ref e, ..rest] => f2(rest,f(*e)),\n          }\n        }\n        f2(*ls, ~RN(~Tv,~\"\"))\n      }\n\n    }\n\n  }\n\n  pub fn apply(e: &E) -> ~[~LL] {\n    unsafe {\n      ls = Some(~[]);\n      f(e);\n      ls.unwrap()\n    }\n  }\n\n}\n\nfn kNormal(a: &ast::E) -> ~[~ast::LL] {\n  kNormal::apply(a)\n}\n\npub mod emit {\n\n  use ast::*;\n  use asm;\n\n  fn o(id: &Option<~R>, out: &str) {\n    match id {\n      &Some(ref id) =>asm::__(id.p() + \" = \" + out),\n      &None => asm::__(out),\n    }\n  }\n\n  fn emitLL(l: &LL) {\n    match l {\n      &LLCall(ref id, ref op, ref prms) => {\n        let prms:~[~str] = prms.map(|a| a.t().p() + \" \" + a.p());\n        o(id, fmt!(\"call %s %s(%s) nounwind\",\n          op.t().p(), op.p(), prms.join(\", \")))\n      }\n      &LLBin(ref id, ref op, ref a, ref b) => {\n        o(id, fmt!(\"%s %s %s, %s\", *op, a.t().p(), a.p(), b.p()))\n      }\n    }\n  }\n\n  pub fn apply(file: &str, ls: &[~LL]) {\n\n    asm::open(file);\n    asm(\"@.str = private constant [4 x i8] c\\\"%d\\\\0A\\\\00\\\"\");\n    asm(\"define void @print_i32(i32 %a) nounwind ssp {\");\n    asm(\"entry:\");\n    asm::__(\"call i32 (i8*, ...)* @printf(i8* getelementptr inbounds ([4 x i8]* @.str, i64 0, i64 0), i32 %a) nounwind\");\n    asm::__(\"ret void\");\n    asm(\"}\");\n    asm(\"define void @print_i8(i8 %a) nounwind ssp {\");\n    asm(\"entry:\");\n    asm::__(\"call i32 (i8*, ...)* @printf(i8* getelementptr inbounds ([4 x i8]* @.str, i64 0, i64 0), i8 %a) nounwind\");\n    asm::__(\"ret void\");\n    asm(\"}\");\n\n    asm(\"declare i32 @printf(i8*, ...) nounwind\");\n\n    asm(\"define i32 @main() nounwind ssp {\");\n    asm(\"entry:\");\n\n    ls.map(|l| emitLL(*l));\n\n\n    asm::__(\"ret i32 0\");\n    asm(\"}\");\n    asm::close();\n  }\n\n}\n\npub fn emit(file: &str, ls: &[~ast::LL]) {\n  emit::apply(file, ls);\n}\n\npub fn genid(s:&str) -> ~str {\n  static mut id:int = 0;\n  unsafe {\n    id += 1;\n    s + id.to_str()\n  }\n}\n\nfn readAll(file:&str) -> ~str {\n  use std::io;\n  use std::result;\n  let reader = result::get(&io::file_reader(&Path(file)));\n  let mut s = ~\"\";\n  while !reader.eof() {\n    s = s + reader.read_line() + \"\\n\";\n  }\n  s\n} \n\nfn writeAll(file:&str, s:&str) {\n  use std::io;\n  use std::result;\n  let writer = result::get(&io::buffered_file_writer(&Path(file)));\n  writer.write_str(s);\n}\n\npub mod asm {\n\n  use std::io;\n  use std::result;\n\n  pub static mut writer: Option<@Writer> = None;\n\n  pub fn open(file:&str) {\n    unsafe {\n      writer = Some(result::get(&io::buffered_file_writer(&Path(file))));\n    }\n  }\n\n  pub fn println(s:&str) {\n    unsafe {\n      writer.unwrap().write_str(s + \"\\n\");\n    }\n  }\n\n  pub fn close() {\n    unsafe {\n      writer = None;\n    }\n  }\n\n  pub fn __(s:&str) {\n    println(\"  \" + s);\n  }\n\n}\n\npub fn asm(s:&str) {\n  asm::println(s);\n}\n\nfn exec(cmd:&str) -> (int, ~str, ~str) {\n\n  use std::str;\n  use std::run;\n\n  let mut cmds:~[&str] = cmd.split_str_iter(\" \").collect();\n  let prog:~str = cmds.shift().to_str();\n  let args:~[~str] = cmds.map(|&s| s.to_str());\n  let o = run::process_output(prog,args);\n\n  unsafe {\n    (o.status,\n    str::raw::from_bytes(o.output),\n    str::raw::from_bytes(o.error),\n    )\n  }\n\n}\n\npub mod join {\n  pub trait Joinable<T> {\n    fn join(&self, sep:&str) -> ~str;\n  }\n\n  impl<T:ToStr> Joinable<T> for ~[T] {\n    fn join(&self, sep:&str) -> ~str {\n      let mut s:~str = ~\"\";\n      for (*self).iter().advance |t| {\n        match s {\n          ~\"\" => s = t.to_str(),\n          _ => s = s + sep + t.to_str(),\n        }\n      }\n      s\n    }\n  }\n\n}\n\n\u203bRust0.7\u3067\u4f5c\u6210\u3057\u307e\u3057\u305f\u3002\n\n\u4eca\u56de\u306f\u4ee5\u4e0b\u306e\u30ea\u30d5\u30a1\u30af\u30bf\u30ea\u30f3\u30b0\u3092\u884c\u3044\u307e\u3057\u305f\u3002\n\n- copy\u306f\u4f7f\u308f\u306a\u304f\u3057\u3066\u3001clone\u3092\u4f7f\u3046\u3088\u3046\u306b\u3057\u307e\u3057\u305f\u3002\n- Joinable\u3068\u3044\u3046\u30c8\u30ec\u30a4\u30c8\u3092\u4f5c\u3063\u3066\u6c4e\u7528\u7684\u306aJoin\u3092\u4f5c\u308a\u307e\u3057\u305f\u3002\n- macro\u3092\u4f7f\u3063\u3066\u8907\u6570\u306eimpl\u3092\uff11\u3064\u306b\u7e8f\u3081\u307e\u3057\u305f\u3002\n\n```rust\nuse join::Joinable;\nuse ast::*;\n\npub mod ast {\n\n  #[deriving(Clone,ToStr)]\n  pub enum E {\n    ELdc(~T, int),\n    EBin(~T, ~str, ~E, ~E),\n    EPrint(~T, ~E),\n    EBlock(~T, ~[~E]),\n  }\n\n  macro_rules! EOp(\n    ($T:ident, $op:expr) => (\n      pub fn $T(t: ~T, a: ~E, b: ~E) -> E {\n        EBin(t, ~$op, a, b)\n      }\n    )\n  )\n\n  EOp!(EAdd, \"add\")\n  EOp!(ESub, \"sub\")\n  EOp!(EMul, \"mul\")\n  EOp!(EDiv, \"div\")\n\n  #[deriving(Clone,ToStr)]\n  pub enum T {\n    Ti(int),\n    Tv,\n    TFun(~T, ~[~T]),\n  }\n\n  #[deriving(Clone,ToStr)]\n  pub enum R {\n    pub RG(~T, ~str),\n    pub RL(~T, ~str),\n    pub RR(~T, ~str),\n    pub RN(~T, ~str),\n  }\n\n  #[deriving(Clone,ToStr)]\n  pub enum LL {\n    LLCall(Option<~R>, ~R, ~[~R]),\n    LLBin(Option<~R>, ~str, ~R, ~R),\n  }\n\n  macro_rules! impl_ToStr_for(\n    ($T:ty) => (\n      impl ToStr for $T {\n        #[inline]\n        fn to_str(&self) -> ~str {\n          fmt!(\"%?\", *self)\n        }\n      }\n    )\n  )\n\n  macro_rules! impl_ToStr_for_Option(\n    ($T:ty) => (\n      impl ToStr for Option<$T> {\n        fn to_str(&self) -> ~str {\n          match *self {\n            Some(ref r) => fmt!(\"Some(%?)\",r),\n            None => ~\"None\",\n          }\n        }\n      }\n    )\n  )\n\n  impl_ToStr_for!(~E)\n  impl_ToStr_for!(~T)\n  impl_ToStr_for!(~R)\n  impl_ToStr_for!(~LL)\n\n  impl_ToStr_for_Option!(~R)\n\n  impl Eq for T {\n\n    pub fn eq(&self, t:&T) -> bool {\n      self.to_str() == t.to_str()\n    }\n\n    pub fn ne(&self, t:&T) -> bool {\n      !(self == t)\n    }\n\n  }\n\n  impl R {\n\n    pub fn t(&self) -> ~T {\n      match *self {\n        RG(ref t, _) => t.clone(),\n        RL(ref t, _) => t.clone(),\n        RR(ref t, _) => t.clone(),\n        RN(ref t, _) => t.clone(),\n      }\n    }\n\n  }\n\n  pub trait P {\n    fn p(&self) -> ~str;\n  }\n\n  impl P for T {\n    pub fn p(&self) -> ~str {\n      match *self {\n        Ti(ref i) => \"i\" + i.to_str(),\n        Tv => ~\"void\",\n        TFun(ref t, ref ls) => {\n          t.p() + \"(\" + ls.map(|t| t.p()).join(\", \") + \")*\"\n        }\n      }\n    }\n\n  }\n\n  impl P for R {\n    pub fn p(&self) -> ~str {\n      match *self {\n        RG(_,ref id) => \"@\" + *id,\n        RL(_,ref id) => \"%\" + *id,\n        RR(_,ref id) => \"%.\" + *id,\n        RN(_,ref id) => id.clone(),\n      }\n    }\n\n  }\n\n}\n\n\nfn main() {\n//    println(os::getcwd().to_str());\n//    println(os::getenv(\"PATH\").unwrap());\n//    os::setenv(\"PATH\", os::getenv(\"PATH\").unwrap());\n//    println(readAll(\"test.rs\"));\n//    writeAll(\"tes.txt\", \"hogehoge\");\n\n  let ast = ~EBlock(~Tv, ~[\n    ~EPrint(~Ti(32), ~ELdc(~Ti(32), 11)),\n    ~EPrint(~Ti(32),\n      ~EAdd(~Ti(32), ~ELdc(~Ti(32), 11), ~ELdc(~Ti(32), 22)))\n  ]);\n  println(\"ast=\" + ast.to_str());\n\n  let ll = kNormal(ast);\n  println(\"ll=\" + ll.to_str());\n  \n  emit(\"e.ll\", ll);\n  \n  println(exec(\"llc e.ll -o e.s\").to_str());\n  println(exec(\"llvm-gcc -m64 e.s -o e\").to_str());\n  println(exec(\"./e\").to_str());\n}\n\nmod interpreter {\n  use ast::*;\n\n  fn eval(e:&E)->int {\n\n    match e {\n\n      &ELdc(_, i) => i,\n\n      &EBin(_, ~\"add\", ref a, ref b) => eval(*a) + eval(*b),\n\n      &EBin(_, ref op, _, _) => fail!(\"operator \"+*op),\n\n      &EPrint(_, ref e) => {\n        let e = eval(*e);\n        println(e.to_str());\n        e\n      }\n\n      &EBlock(_, ref ls) => {\n        fn f(ls:&[~E],r:int)-> int {\n          match ls {\n            [] => r,\n            [ref a, ..rest] => f(rest,eval(*a))\n          }\n        }\n        f(*ls, 0)\n      }\n    }\n  }\n}\n\nmod kNormal {\n  use ast::*;\n  use std::vec;\n\n  fn gid(t:&T)-> ~R {\n    ~RR(~(*t).clone(),~\"\")\n  }\n\n  static mut ls:Option<~[~LL]> = None;\n\n  fn add(l:~LL) {\n    unsafe {\n      ls = Some(vec::append_one(ls.unwrap(), l));\n    }\n  }\n\n  fn f(a: &E)-> ~R {\n\n    match a {\n\n      &EBin(ref t,ref op, ref a, ref b) => {\n        let a = f(*a);\n        let b = f(*b);\n        let id = gid(*t);\n        if (*t != a.t() || *t != b.t()) {fail!(fmt!(\"type mismatch %?\",*t));}\n        add(~LLBin(Some(id.clone()), op.clone(), a, b));\n        id\n      }\n\n      &ELdc(ref t, ref i) => ~RN(t.clone(), i.to_str()),\n\n      &EPrint(ref t, ref a) => {\n        let a = f(*a);\n        if (*t != a.t()) {fail!(fmt!(\"type mismatch t=%? ta=%?\", t, a.t()))}\n        add(~LLCall(None, ~RG(~TFun(~Tv, ~[t.clone()]), \"print_\" + t.p()), ~[a.clone()]));\n        a\n      }\n\n      &EBlock(_,ref ls) => {\n        fn f2(ls:&[~E],r:&R)-> ~R {\n          match ls {\n            [] => ~r.clone(),\n            [ref e, ..rest] => f2(rest,f(*e)),\n          }\n        }\n        f2(*ls, ~RN(~Tv,~\"\"))\n      }\n\n    }\n\n  }\n\n  pub fn apply(e: &E) -> ~[~LL] {\n    unsafe {\n      ls = Some(~[]);\n      f(e);\n      ls.unwrap()\n    }\n  }\n  \n}\n\nfn kNormal(a: &ast::E) -> ~[~ast::LL] {\n  kNormal::apply(a)\n}\n\npub mod emit {\n\n  use ast::*;\n  use asm;\n\n  fn o(id: &Option<~R>, out: &str) {\n    match id {\n      &Some(ref id) =>asm::__(id.p() + \" = \" + out),\n      &None => asm::__(out),\n    }\n  }\n\n  fn emitLL(l: &LL) {\n    match l {\n      &LLCall(ref id, ref op, ref prms) => {\n        let prms:~[~str] = prms.map(|a| a.t().p() + \" \" + a.p());\n        o(id, fmt!(\"call %s %s(%s) nounwind\",\n          op.t().p(), op.p(), prms.join(\", \")))\n      }\n      &LLBin(ref id, ref op, ref a, ref b) => {\n        o(id, fmt!(\"%s %s %s, %s\", *op, a.t().p(), a.p(), b.p()))\n      }\n    }\n  }\n\n  pub fn apply(file: &str, ls: &[~LL]) {\n\n    asm::open(file);\n    asm(\"@.str = private constant [4 x i8] c\\\"%d\\\\0A\\\\00\\\"\");\n    asm(\"define void @print_i32(i32 %a) nounwind ssp {\");\n    asm(\"entry:\");\n    asm::__(\"call i32 (i8*, ...)* @printf(i8* getelementptr inbounds ([4 x i8]* @.str, i64 0, i64 0), i32 %a) nounwind\");\n    asm::__(\"ret void\");\n    asm(\"}\");\n    asm(\"define void @print_i8(i8 %a) nounwind ssp {\");\n    asm(\"entry:\");\n    asm::__(\"call i32 (i8*, ...)* @printf(i8* getelementptr inbounds ([4 x i8]* @.str, i64 0, i64 0), i8 %a) nounwind\");\n    asm::__(\"ret void\");\n    asm(\"}\");\n\n    asm(\"declare i32 @printf(i8*, ...) nounwind\");\n\n    asm(\"define i32 @main() nounwind ssp {\");\n    asm(\"entry:\");\n\n    ls.map(|l| emitLL(*l));\n    \n\n    asm::__(\"ret i32 0\");\n    asm(\"}\");\n    asm::close();\n  }\n\n}\n\npub fn emit(file: &str, ls: &[~ast::LL]) {\n  emit::apply(file, ls);\n}\n\npub fn genid(s:&str) -> ~str {\n  static mut id:int = 0;\n  unsafe {\n    id += 1;\n    s + id.to_str()\n  }\n}\n\nfn readAll(file:&str) -> ~str {\n  use std::io;\n  use std::result;\n  let reader = result::get(&io::file_reader(&Path(file)));\n  let mut s = ~\"\";\n  while !reader.eof() {\n    s = s + reader.read_line() + \"\\n\";\n  }\n  s\n} \n\nfn writeAll(file:&str, s:&str) {\n  use std::io;\n  use std::result;\n  let writer = result::get(&io::buffered_file_writer(&Path(file)));\n  writer.write_str(s);\n}\n\npub mod asm {\n\n  use std::io;\n  use std::result;\n\n  pub static mut writer: Option<@Writer> = None;\n\n  pub fn open(file:&str) {\n    unsafe {\n      writer = Some(result::get(&io::buffered_file_writer(&Path(file))));\n    }\n  }\n\n  pub fn println(s:&str) {\n    unsafe {\n      writer.unwrap().write_str(s + \"\\n\");\n    }\n  }\n\n  pub fn close() {\n    unsafe {\n      writer = None;\n    }\n  }\n\n  pub fn __(s:&str) {\n    println(\"  \" + s);\n  }\n\n}\n\npub fn asm(s:&str) {\n  asm::println(s);\n}\n\nfn exec(cmd:&str) -> (int, ~str, ~str) {\n\n  use std::str;\n  use std::run;\n\n  let mut cmds:~[&str] = cmd.split_str_iter(\" \").collect();\n  let prog:~str = cmds.shift().to_str();\n  let args:~[~str] = cmds.map(|&s| s.to_str());\n  let o = run::process_output(prog,args);\n\n  unsafe {\n    (o.status,\n    str::raw::from_bytes(o.output),\n    str::raw::from_bytes(o.error),\n    )\n  }\n\n}\n\npub mod join {\n  pub trait Joinable<T> {\n    fn join(&self, sep:&str) -> ~str;\n  }\n\n  impl<T:ToStr> Joinable<T> for ~[T] {\n    fn join(&self, sep:&str) -> ~str {\n      let mut s:~str = ~\"\";\n      for (*self).iter().advance |t| {\n        match s {\n          ~\"\" => s = t.to_str(),\n          _ => s = s + sep + t.to_str(),\n        }\n      }\n      s\n    }\n  }\n\n}\n```\n", "tags": ["LLVM", "rust0.7", "\u30b3\u30f3\u30d1\u30a4\u30e9"]}