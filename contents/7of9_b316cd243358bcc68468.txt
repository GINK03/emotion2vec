{"context": "\n\u52d5\u4f5c\u74b0\u5883\nMSP430\n\n\n\n\u6982\u8981\nI2C\u63a5\u7d9a\u306e\u5c0f\u578b\u30ad\u30e3\u30e9\u30af\u30bfLCD AQM1602\u3092MSP430\u3092\u7528\u3044\u3066\u8868\u793a\u3059\u308b\u3002\n\n\u30bd\u30d5\u30c8\u30a6\u30a7\u30a2I2C\u306b\u3066\u5b9f\u88c5\n\n\nP2.0: SCK\nP2.1: SDA\n10k\u306b\u3066\u30d7\u30eb\u30a2\u30c3\u30d7\n\n\nAQM1602\u3092\u4f7f\u7528\n\n\nhttp://akizukidenshi.com/catalog/g/gK-08896/\n\n\n\n\nv0.1\n\nmain.c\u306b\u5168\u90e8\u66f8\u304f\u3068\u3044\u3046\u60aa\u3044\u30b3\u30fc\u30c7\u30a3\u30f3\u30b0\nstring.h\u3084stdint.h\u3092\u4f7f\u3046\u3068\u3044\u3046\u30de\u30a4\u30b3\u30f3\u306b\u826f\u304f\u306a\u3044\u8d05\u6ca2\u306a\u30b3\u30fc\u30c7\u30a3\u30f3\u30b0\n\u3068\u308a\u3042\u3048\u305a\u6587\u5b57\u304c\u8868\u793a\u3055\u308c\u305f\u7a0b\u5ea6\n\nESP8266\u3067AQM0802\u3092\u4f7f\u7528\u3057\u305f\u6642\u306fWire Library\u3092\u4f7f\u3046\u3053\u3068\u304c\u3067\u304d\u305f\u3002\nhttp://qiita.com/7of9/items/7fbfe85b62c58ce01a5d\n\u305d\u306e\u30b3\u30fc\u30c9\u3092MSP430\u3067\u30bd\u30d5\u30c8\u30a6\u30a7\u30a2I2c\u306b\u3057\u3066\u4f7f\u3046\u3088\u3046\u306b\u5b9f\u88c5\u3057\u305f\u3002\n\nmain.c\n/*\nv0.1 2017/02/24 AQM1602\u8a66\u7528\n*/\n\n//   ACLK = n/a, MCLK = SMCLK = DCO ~ 800kHz\n\n#include <msp430x12x2.h>\n#include <stdbool.h>\n#include <math.h>\n#include <stdint.h>\n#include <string.h>\n\n#define DELTA 488                           // target DCO = DELTA*(4096) ~2MHz\n\nchar s_rcvChar=0x00;\n\n#define DATA_0_PORT BIT1\n#define SCK_0_PORT BIT0\n\n#define DATA_0_LOW      P2OUT &= ~DATA_0_PORT \n#define DATA_0_HIGH     P2OUT |= DATA_0_PORT \n#define SCK_0_LOW      P2OUT &= ~SCK_0_PORT \n#define SCK_0_HIGH     P2OUT |= SCK_0_PORT \n\n#define DATA_0_DIROUT   P2DIR |= DATA_0_PORT // direction OUT\n#define DATA_0_DIRIN   P2DIR &= ~DATA_0_PORT // direction IN\n#define SCK_0_DIROUT   P2DIR |= SCK_0_PORT // direction OUT\n\nvoid delay_ms(int msec);\n\n//#define DELAY_CYC      __delay_cycles(80)\n#define DELAY_CYC      __delay_cycles(8)\n\nchar s_write_byte(unsigned char value_a);\nvoid i2c_start(void);\nvoid i2c_stop(void);\nvoid AQM1602_PutMessage(uint8_t *srcPtr, int len, uint8_t x_st1, uint8_t y_st1);\nvoid Test_AQM1602_cursorOn_posOff_contrastLow(void);\nvoid Test_AQM1602_cursorOn_posOn_contrastLow(void);\nvoid Test_AQM1602_cursorOn_posOn_contrastHigh(void);\n\nstatic const uint8_t kDeviceAddr = 0x3e; // 7bit address\nstatic const int kMaxXsize = 16;\nstatic const int kMaxYsize = 2;\nstatic const int kOffset_addr2ndline = 0x40;\n\n\nstatic uint8_t ControlByteList[] = {\n  0x00, // Instruction write operation. ( Co=0, Rs=0 )\n  0x40, // Data write operation. ( Co=0, Rs=1 )\n};\nenum {\n  TYPE_INSTRUCITON = 0,\n  TYPE_DATA,\n};\n\nvoid delay_us(int usec)\n{\n    // \u304d\u3061\u3093\u3068\u3057\u305f1usec\u3067\u306a\u3044    \n    int idx;\n\n    for(idx=0;idx<usec;idx++) {\n        __delay_cycles(1);\n    }\n}\n\nvoid delay_ms(int msec)\n{\n    // \u304d\u3061\u3093\u3068\u3057\u305f1msec\u3067\u306a\u3044   \n    int idx;\n\n    for(idx=0;idx<msec;idx++) {\n        __delay_cycles(800);\n    }\n}\n\nvoid DATA_out(bool sts)\n{     \n    DATA_0_DIROUT;        \n    if(sts) {\n        DATA_0_HIGH;    \n    } else {\n        DATA_0_LOW;\n    }\n}\nvoid SCK_out(bool sts)\n{\n    SCK_0_DIROUT;        \n    if(sts) {\n        SCK_0_HIGH;    \n    } else {\n        SCK_0_LOW;\n    }    \n}\n\nbool is_DATA_0_High(void)\n{\n    bool bfBuf;\n\n    bfBuf = (bool)((P2IN & DATA_0_PORT) > 0);    \n    return bfBuf ;    \n}\n\nbool DATA_in(void)\n{    \n    bool bfBuf;\n\n    DATA_0_DIRIN;\n    DELAY_CYC;\n    bfBuf = is_DATA_0_High();\n\n    return bfBuf;\n}\n\nvoid i2c_beginTransmission(uint8_t devAdr_7bit)\n{\n    uint8_t adr = (devAdr_7bit << 1);\n    i2c_start();\n    s_write_byte(adr);\n}\nvoid i2c_endTransmission(void)\n{\n    i2c_stop();\n}\nvoid i2c_write(uint8_t data)\n{\n    s_write_byte(data);\n}\n\nvoid writeToDevice(int type, uint8_t *dataByte, size_t len) \n{\n    int idx;\n    for (idx = 0; idx < len; idx++) {\n        i2c_beginTransmission(kDeviceAddr);\n        i2c_write(ControlByteList[type]);\n        i2c_write(dataByte[idx]);\n        i2c_endTransmission();\n        // delayMicroseconds(27); // 26.3us\n        DELAY_CYC;\n    }\n}\n\nvoid AQM1602_WriteSingleInstruction(uint8_t data) \n{ \n  size_t len = 1;\n  uint8_t list[] = {data};\n  writeToDevice(TYPE_INSTRUCITON, list, len); \n}\n\nvoid AQM1602_WriteInstructions(uint8_t *data, int len) \n{ \n  writeToDevice(TYPE_INSTRUCITON, data, len); \n}\n\nvoid AQM1602_WriteData(uint8_t *data, size_t len) \n{ \n  writeToDevice(TYPE_DATA, data, len); \n}\n\nvoid AQM1602_Clear()\n{\n    AQM1602_WriteSingleInstruction(0x01);\n}\n\nvoid AQM1602_Initialize(bool cursorOn, bool cursorPosOn, uint8_t contrast)\n{ \n  // \n  delay_ms(40); // Wait time > 40ms after VDD stable\n\n  // Function set\n  AQM1602_WriteSingleInstruction(0x38);\n\n  // Function set\n  AQM1602_WriteSingleInstruction(0x39);\n\n  // Internal OSC frequency\n  AQM1602_WriteSingleInstruction(0x14);\n\n  // { Contrast set -----------------------------\n  uint8_t ctrst = contrast;\n  if (ctrst > 0xF) {\n    ctrst = 0xF;\n  }\n  AQM1602_WriteSingleInstruction(0x70 | ctrst);\n  // } Contrast set -----------------------------\n\n  // Power/ICON/Contrast control\n  AQM1602_WriteSingleInstruction(0x56);\n\n  // Follower control\n  AQM1602_WriteSingleInstruction(0x6C);\n\n  // Wait time > 200mS (for power stable)\n  delay_ms(200);\n\n  // Function set\n  AQM1602_WriteSingleInstruction(0x38);\n\n  // { Display ON/OFF control -----------------------\n  uint8_t extra = 0x0;\n  if (cursorOn) {\n    extra = extra | 0x2;\n  }\n  if (cursorPosOn) {\n    extra = extra | 0x3;    \n  }\n  AQM1602_WriteSingleInstruction(0x0C | extra);\n  // } Display ON/OFF control -----------------------\n\n  // Clear Display\n  AQM1602_WriteSingleInstruction(0x01);\n\n  // Wait time > 1.08ms\n  delay_ms(2);\n}\n\nvoid uartPC_init(void)\n{\n\n    P3SEL |= 0x30;                            // P3.4,5 = USART0 TXD/RXD\n    ME2 |= UTXE0 + URXE0;                     // Enable USART0 TXD/RXD\n    UCTL0 |= CHAR;                            // 8-bit character\n    UTCTL0 |= SSEL0;                          // UCLK = ACLK\n    UBR00 = 0x03;                             // 32k/9600 - 3.41\n    UBR10 = 0x00;                             //\n    UMCTL0 = 0x4A;                            // Modulation\n    UCTL0 &= ~SWRST;                          // Initialize USART state machine\n    IE2 |= URXIE0;                            // Enable USART0 RX interrupt  \n}\n\nvoid uartPC_txBuf(unsigned char *pstr) \n{\n    static int widx;\n\n    widx = 0;\n    while(1) {\n        if(pstr[widx] == '\\0') break;        \n        while(!(IFG2&UTXIFG0))\n            ;\n        TXBUF0 = pstr[widx++];\n    }\n}\n\n#define LCD_ADDRESS_8bit (0x7C) // 8\u30d3\u30c3\u30c8\u306b\u3057\u305f\u30a2\u30c9\u30ec\u30b9 (0x3E << 1)\n\nvoid i2c_start(void) \n{\n    SCK_out(1);\n    DELAY_CYC;\n    DATA_out(1);\n    DELAY_CYC;\n    DATA_out(0);\n    DELAY_CYC;\n    SCK_out(0);\n    DELAY_CYC;\n\n    // wait more than 1.3usec\n    delay_us(2);\n}\n\nvoid i2c_stop(void)\n{\n    DATA_out(0);\n    DELAY_CYC;\n    SCK_out(1);\n    DELAY_CYC;\n    DATA_out(1);\n    DELAY_CYC;\n}\n\nvoid main(void)\n{           \n    WDTCTL = WDT_ADLY_1000;                    // WDT 1000ms, ACLK, interval timer\n\n    DATA_0_HIGH;\n    SCK_0_LOW;\n\n    P1DIR |= BIT2;\n    P1OUT |= BIT2;\n\n    DATA_out(1);\n    SCK_out(1);\n\n    _BIS_SR(GIE);    \n\n    uartPC_init();  \n\n    IE1 |= WDTIE;                             // Enable WDT interrupt\n\n    AQM1602_Initialize(/* cursorOn=*/true, /* cursorPosOn=*/true, /* contrast=*/7);\n\n    for(int loop=0; loop<100; loop++) {         \n        AQM1602_PutMessage(\"...........ready\", strlen(\"...........ready\"), /* x_st1=*/1, /* y_st1=*/1);\n        delay_ms(200);\n    }\n\n    while(1)\n    {\n        __bis_SR_register(LPM3_bits + GIE);    \n    }   // while(1)\n\n}\n\nchar s_write_byte(unsigned char value_a)\n{    \n    int loop;\n\n    for(loop=0; loop<8; loop++) {\n        if (value_a & 0x80) {\n            DATA_out(1);\n        } else {\n            DATA_out(0);\n        }\n\n        SCK_out(1);\n        DELAY_CYC;\n        SCK_out(0);\n        DELAY_CYC;\n        value_a <<= 1;\n    }\n\n    SCK_out(1);\n    DELAY_CYC;\n    DATA_in(); // for ACK\n    SCK_out(0);\n    DELAY_CYC;\n\n    return 0;    \n}\n\n#pragma vector=USART0RX_VECTOR\n__interrupt void usart0_rx (void)\n{\n\n    s_rcvChar = RXBUF0;\n    _NOP();\n\n}\n\nvoid AQM1602_PutMessage(uint8_t *srcPtr, int len, uint8_t x_st1, uint8_t y_st1)\n{\n  // _st1 : index starting from 1\n  if ((x_st1 > kMaxXsize) || (y_st1 > kMaxYsize)) {\n    return; // error\n  }\n\n  uint8_t pos;\n\n  if (len <= kMaxXsize) {\n    pos = 0x80 | ((y_st1 - 1) * kOffset_addr2ndline);\n    pos = pos | (x_st1 - 1);\n    AQM1602_WriteSingleInstruction(pos);\n    AQM1602_WriteData( srcPtr, len );\n    return;\n  }\n}\n\n#pragma vector=WDT_VECTOR\n__interrupt void watchdog_timer(void)\n{\n\n   __bic_SR_register_on_exit(LPM3_bits);\n\n}\n\n// test functions ---------------------------\n\nvoid Test_AQM1602_cursorOn_posOff_contrastLow(void)\n{\n    AQM1602_Initialize(/* cursorOn=*/true, /* cursorPosOn=*/false, /* contrast=*/1);\n}\n\nvoid Test_AQM1602_cursorOn_posOn_contrastLow(void)\n{\n    AQM1602_Initialize(/* cursorOn=*/true, /* cursorPosOn=*/true, /* contrast=*/1);\n}\n\nvoid Test_AQM1602_cursorOn_posOn_contrastHigh(void)\n{\n    AQM1602_Initialize(/* cursorOn=*/true, /* cursorPosOn=*/true, /* contrast=*/15);\n}\n\nvoid Test_AQM1602_writeTest(void)\n{\n    const char *tsgMsg = \"HELLO\";\n    AQM1602_PutMessage((uint8_t *)tsgMsg, strlen(tsgMsg), /* x_st1=*/1, /* y_st1=*/1);  \n}\n\n\n```txt:\u52d5\u4f5c\u74b0\u5883\nMSP430\n```\n\n## \u6982\u8981\n\nI2C\u63a5\u7d9a\u306e\u5c0f\u578b\u30ad\u30e3\u30e9\u30af\u30bfLCD AQM1602\u3092MSP430\u3092\u7528\u3044\u3066\u8868\u793a\u3059\u308b\u3002\n\n- \u30bd\u30d5\u30c8\u30a6\u30a7\u30a2I2C\u306b\u3066\u5b9f\u88c5\n  - P2.0: SCK\n  - P2.1: SDA\n  - 10k\u306b\u3066\u30d7\u30eb\u30a2\u30c3\u30d7\n- AQM1602\u3092\u4f7f\u7528\n  - http://akizukidenshi.com/catalog/g/gK-08896/\n\n## v0.1\n\n- main.c\u306b\u5168\u90e8\u66f8\u304f\u3068\u3044\u3046\u60aa\u3044\u30b3\u30fc\u30c7\u30a3\u30f3\u30b0\n- string.h\u3084stdint.h\u3092\u4f7f\u3046\u3068\u3044\u3046\u30de\u30a4\u30b3\u30f3\u306b\u826f\u304f\u306a\u3044\u8d05\u6ca2\u306a\u30b3\u30fc\u30c7\u30a3\u30f3\u30b0\n- \u3068\u308a\u3042\u3048\u305a\u6587\u5b57\u304c\u8868\u793a\u3055\u308c\u305f\u7a0b\u5ea6\n\nESP8266\u3067AQM0802\u3092\u4f7f\u7528\u3057\u305f\u6642\u306fWire Library\u3092\u4f7f\u3046\u3053\u3068\u304c\u3067\u304d\u305f\u3002\nhttp://qiita.com/7of9/items/7fbfe85b62c58ce01a5d\n\u305d\u306e\u30b3\u30fc\u30c9\u3092MSP430\u3067\u30bd\u30d5\u30c8\u30a6\u30a7\u30a2I2c\u306b\u3057\u3066\u4f7f\u3046\u3088\u3046\u306b\u5b9f\u88c5\u3057\u305f\u3002\n\n```main.c\n/*\nv0.1 2017/02/24 AQM1602\u8a66\u7528\n*/\n\n//   ACLK = n/a, MCLK = SMCLK = DCO ~ 800kHz\n\n#include <msp430x12x2.h>\n#include <stdbool.h>\n#include <math.h>\n#include <stdint.h>\n#include <string.h>\n\n#define DELTA 488                           // target DCO = DELTA*(4096) ~2MHz\n\nchar s_rcvChar=0x00;\n\n#define DATA_0_PORT BIT1\n#define SCK_0_PORT BIT0\n\n#define DATA_0_LOW      P2OUT &= ~DATA_0_PORT \n#define DATA_0_HIGH     P2OUT |= DATA_0_PORT \n#define SCK_0_LOW      P2OUT &= ~SCK_0_PORT \n#define SCK_0_HIGH     P2OUT |= SCK_0_PORT \n\n#define DATA_0_DIROUT   P2DIR |= DATA_0_PORT // direction OUT\n#define DATA_0_DIRIN   P2DIR &= ~DATA_0_PORT // direction IN\n#define SCK_0_DIROUT   P2DIR |= SCK_0_PORT // direction OUT\n\nvoid delay_ms(int msec);\n\n//#define DELAY_CYC      __delay_cycles(80)\n#define DELAY_CYC      __delay_cycles(8)\n\nchar s_write_byte(unsigned char value_a);\nvoid i2c_start(void);\nvoid i2c_stop(void);\nvoid AQM1602_PutMessage(uint8_t *srcPtr, int len, uint8_t x_st1, uint8_t y_st1);\nvoid Test_AQM1602_cursorOn_posOff_contrastLow(void);\nvoid Test_AQM1602_cursorOn_posOn_contrastLow(void);\nvoid Test_AQM1602_cursorOn_posOn_contrastHigh(void);\n\nstatic const uint8_t kDeviceAddr = 0x3e; // 7bit address\nstatic const int kMaxXsize = 16;\nstatic const int kMaxYsize = 2;\nstatic const int kOffset_addr2ndline = 0x40;\n\n\nstatic uint8_t ControlByteList[] = {\n  0x00, // Instruction write operation. ( Co=0, Rs=0 )\n  0x40, // Data write operation. ( Co=0, Rs=1 )\n};\nenum {\n  TYPE_INSTRUCITON = 0,\n  TYPE_DATA,\n};\n\nvoid delay_us(int usec)\n{\n    // \u304d\u3061\u3093\u3068\u3057\u305f1usec\u3067\u306a\u3044    \n    int idx;\n    \n    for(idx=0;idx<usec;idx++) {\n        __delay_cycles(1);\n    }\n}\n\nvoid delay_ms(int msec)\n{\n    // \u304d\u3061\u3093\u3068\u3057\u305f1msec\u3067\u306a\u3044   \n    int idx;\n    \n    for(idx=0;idx<msec;idx++) {\n        __delay_cycles(800);\n    }\n}\n\nvoid DATA_out(bool sts)\n{     \n    DATA_0_DIROUT;        \n    if(sts) {\n        DATA_0_HIGH;    \n    } else {\n        DATA_0_LOW;\n    }\n}\nvoid SCK_out(bool sts)\n{\n    SCK_0_DIROUT;        \n    if(sts) {\n        SCK_0_HIGH;    \n    } else {\n        SCK_0_LOW;\n    }    \n}\n\nbool is_DATA_0_High(void)\n{\n    bool bfBuf;\n    \n    bfBuf = (bool)((P2IN & DATA_0_PORT) > 0);    \n    return bfBuf ;    \n}\n\nbool DATA_in(void)\n{    \n    bool bfBuf;\n\n    DATA_0_DIRIN;\n    DELAY_CYC;\n    bfBuf = is_DATA_0_High();\n    \n    return bfBuf;\n}\n\nvoid i2c_beginTransmission(uint8_t devAdr_7bit)\n{\n    uint8_t adr = (devAdr_7bit << 1);\n    i2c_start();\n    s_write_byte(adr);\n}\nvoid i2c_endTransmission(void)\n{\n    i2c_stop();\n}\nvoid i2c_write(uint8_t data)\n{\n    s_write_byte(data);\n}\n\nvoid writeToDevice(int type, uint8_t *dataByte, size_t len) \n{\n    int idx;\n    for (idx = 0; idx < len; idx++) {\n        i2c_beginTransmission(kDeviceAddr);\n        i2c_write(ControlByteList[type]);\n        i2c_write(dataByte[idx]);\n        i2c_endTransmission();\n        // delayMicroseconds(27); // 26.3us\n        DELAY_CYC;\n    }\n}\n\nvoid AQM1602_WriteSingleInstruction(uint8_t data) \n{ \n  size_t len = 1;\n  uint8_t list[] = {data};\n  writeToDevice(TYPE_INSTRUCITON, list, len); \n}\n\nvoid AQM1602_WriteInstructions(uint8_t *data, int len) \n{ \n  writeToDevice(TYPE_INSTRUCITON, data, len); \n}\n\nvoid AQM1602_WriteData(uint8_t *data, size_t len) \n{ \n  writeToDevice(TYPE_DATA, data, len); \n}\n\nvoid AQM1602_Clear()\n{\n    AQM1602_WriteSingleInstruction(0x01);\n}\n\nvoid AQM1602_Initialize(bool cursorOn, bool cursorPosOn, uint8_t contrast)\n{ \n  // \n  delay_ms(40); // Wait time > 40ms after VDD stable\n\n  // Function set\n  AQM1602_WriteSingleInstruction(0x38);\n\n  // Function set\n  AQM1602_WriteSingleInstruction(0x39);\n\n  // Internal OSC frequency\n  AQM1602_WriteSingleInstruction(0x14);\n\n  // { Contrast set -----------------------------\n  uint8_t ctrst = contrast;\n  if (ctrst > 0xF) {\n    ctrst = 0xF;\n  }\n  AQM1602_WriteSingleInstruction(0x70 | ctrst);\n  // } Contrast set -----------------------------\n\n  // Power/ICON/Contrast control\n  AQM1602_WriteSingleInstruction(0x56);\n\n  // Follower control\n  AQM1602_WriteSingleInstruction(0x6C);\n\n  // Wait time > 200mS (for power stable)\n  delay_ms(200);\n\n  // Function set\n  AQM1602_WriteSingleInstruction(0x38);\n\n  // { Display ON/OFF control -----------------------\n  uint8_t extra = 0x0;\n  if (cursorOn) {\n    extra = extra | 0x2;\n  }\n  if (cursorPosOn) {\n    extra = extra | 0x3;    \n  }\n  AQM1602_WriteSingleInstruction(0x0C | extra);\n  // } Display ON/OFF control -----------------------\n\n  // Clear Display\n  AQM1602_WriteSingleInstruction(0x01);\n\n  // Wait time > 1.08ms\n  delay_ms(2);\n}\n\nvoid uartPC_init(void)\n{\n    \n    P3SEL |= 0x30;                            // P3.4,5 = USART0 TXD/RXD\n    ME2 |= UTXE0 + URXE0;                     // Enable USART0 TXD/RXD\n    UCTL0 |= CHAR;                            // 8-bit character\n    UTCTL0 |= SSEL0;                          // UCLK = ACLK\n    UBR00 = 0x03;                             // 32k/9600 - 3.41\n    UBR10 = 0x00;                             //\n    UMCTL0 = 0x4A;                            // Modulation\n    UCTL0 &= ~SWRST;                          // Initialize USART state machine\n    IE2 |= URXIE0;                            // Enable USART0 RX interrupt  \n}\n\nvoid uartPC_txBuf(unsigned char *pstr) \n{\n    static int widx;\n    \n    widx = 0;\n    while(1) {\n        if(pstr[widx] == '\\0') break;        \n        while(!(IFG2&UTXIFG0))\n            ;\n        TXBUF0 = pstr[widx++];\n    }\n}\n\n#define LCD_ADDRESS_8bit (0x7C) // 8\u30d3\u30c3\u30c8\u306b\u3057\u305f\u30a2\u30c9\u30ec\u30b9 (0x3E << 1)\n\nvoid i2c_start(void) \n{\n    SCK_out(1);\n    DELAY_CYC;\n    DATA_out(1);\n    DELAY_CYC;\n    DATA_out(0);\n    DELAY_CYC;\n    SCK_out(0);\n    DELAY_CYC;\n    \n    // wait more than 1.3usec\n    delay_us(2);\n}\n\nvoid i2c_stop(void)\n{\n    DATA_out(0);\n    DELAY_CYC;\n    SCK_out(1);\n    DELAY_CYC;\n    DATA_out(1);\n    DELAY_CYC;\n}\n\nvoid main(void)\n{           \n    WDTCTL = WDT_ADLY_1000;                    // WDT 1000ms, ACLK, interval timer\n        \n    DATA_0_HIGH;\n    SCK_0_LOW;\n    \n    P1DIR |= BIT2;\n    P1OUT |= BIT2;\n\n    DATA_out(1);\n    SCK_out(1);\n    \n    _BIS_SR(GIE);    \n    \n    uartPC_init();  \n\t    \n    IE1 |= WDTIE;                             // Enable WDT interrupt\n    \n    AQM1602_Initialize(/* cursorOn=*/true, /* cursorPosOn=*/true, /* contrast=*/7);\n\n    for(int loop=0; loop<100; loop++) {         \n        AQM1602_PutMessage(\"...........ready\", strlen(\"...........ready\"), /* x_st1=*/1, /* y_st1=*/1);\n        delay_ms(200);\n    }\n    \n\twhile(1)\n\t{\n        __bis_SR_register(LPM3_bits + GIE);    \n\t}   // while(1)\n \n}\n\nchar s_write_byte(unsigned char value_a)\n{    \n    int loop;\n    \n    for(loop=0; loop<8; loop++) {\n        if (value_a & 0x80) {\n            DATA_out(1);\n        } else {\n            DATA_out(0);\n        }\n        \n        SCK_out(1);\n        DELAY_CYC;\n        SCK_out(0);\n        DELAY_CYC;\n        value_a <<= 1;\n    }\n\n    SCK_out(1);\n    DELAY_CYC;\n    DATA_in(); // for ACK\n    SCK_out(0);\n    DELAY_CYC;\n\n    return 0;    \n}\n\n#pragma vector=USART0RX_VECTOR\n__interrupt void usart0_rx (void)\n{\n    \n    s_rcvChar = RXBUF0;\n    _NOP();\n    \n}\n\nvoid AQM1602_PutMessage(uint8_t *srcPtr, int len, uint8_t x_st1, uint8_t y_st1)\n{\n  // _st1 : index starting from 1\n  if ((x_st1 > kMaxXsize) || (y_st1 > kMaxYsize)) {\n    return; // error\n  }\n\n  uint8_t pos;\n\n  if (len <= kMaxXsize) {\n    pos = 0x80 | ((y_st1 - 1) * kOffset_addr2ndline);\n    pos = pos | (x_st1 - 1);\n    AQM1602_WriteSingleInstruction(pos);\n    AQM1602_WriteData( srcPtr, len );\n    return;\n  }\n}\n\n#pragma vector=WDT_VECTOR\n__interrupt void watchdog_timer(void)\n{\n\n   __bic_SR_register_on_exit(LPM3_bits);\n\n}\n\n// test functions ---------------------------\n\nvoid Test_AQM1602_cursorOn_posOff_contrastLow(void)\n{\n    AQM1602_Initialize(/* cursorOn=*/true, /* cursorPosOn=*/false, /* contrast=*/1);\n}\n\nvoid Test_AQM1602_cursorOn_posOn_contrastLow(void)\n{\n    AQM1602_Initialize(/* cursorOn=*/true, /* cursorPosOn=*/true, /* contrast=*/1);\n}\n\nvoid Test_AQM1602_cursorOn_posOn_contrastHigh(void)\n{\n    AQM1602_Initialize(/* cursorOn=*/true, /* cursorPosOn=*/true, /* contrast=*/15);\n}\n\nvoid Test_AQM1602_writeTest(void)\n{\n    const char *tsgMsg = \"HELLO\";\n    AQM1602_PutMessage((uint8_t *)tsgMsg, strlen(tsgMsg), /* x_st1=*/1, /* y_st1=*/1);  \n}\n```\n\n", "tags": ["MSP430", "AQM0802", "I2C"]}