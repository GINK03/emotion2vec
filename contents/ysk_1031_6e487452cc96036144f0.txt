{"context": " More than 1 year has passed since last update.UITableView\u306e\u4e00\u756a\u4e0b\u306e\u30bb\u30eb\u307e\u3067\u30b9\u30af\u30ed\u30fc\u30eb\u3057\u305f\u3089\u3001\u6b21\u306eX\u4ef6\u8aad\u307f\u8fbc\u3080\u3001\u3063\u3066\u3044\u3046\u3084\u3064\u3002\n\nitems_controller.rb\nclass ItemsController < UITableViewController\n  READ_COUNT = 20\n  ITEM_CELL_ID = 'Item'\n\n  def viewDidLoad\n    super\n\n    self.title = 'hoge'\n    @items = []\n    @page = 0\n    @last_items_size = 0\n\n    @indicator = UIActivityIndicatorView.alloc.initWithActivityIndicatorStyle(UIActivityIndicatorViewStyleGray)\n    @indicator.stopAnimating\n\n    load_items\n  end\n\n  def load_items\n    Item.fetch(READ_COUNT, @page * READ_COUNT) do |items, error_message|\n      @items += items\n      @last_items_size += items.size\n      self.tableView.reloadData\n    end\n  end\n\n  def load_more_items\n    @page += 1\n    load_items\n    end_indicator\n  end\n\n  def tableView(tableView, numberOfRowsInSection: section)\n    @items.size\n  end\n\n  def tableView(tableView, cellForRowAtIndexPath: indexPath)\n    cell = tableView.dequeueReusableCellWithIdentifier(ITEM_CELL_ID) ||\n      UITableViewCell.alloc.initWithStyle(UITableViewCellStyleSubtitle, reuseIdentifier: ITEM_CELL_ID)\n\n    item = @items[indexPath.row]\n    cell.textLabel.text = item.title\n    cell.detailTextLabel.text = item.url\n    cell\n  end\n\n  def scrollViewDidScroll(scrollView)\n    if self.tableView.contentOffset.y >= self.tableView.contentSize.height - self.tableView.bounds.size.height\n      return if @indicator.isAnimating\n\n      if @last_items_size >= (@page + 1) * READ_COUNT\n        start_indicator\n        self.performSelector('load_more_items', withObject: nil, afterDelay: 1.0)\n      end\n    end\n  end\n\n  def start_indicator\n    @indicator.startAnimating\n    @indicator.frame = [[0, 0], [self.view.frame.size.width / 2, self.view.frame.size.height / 8]]  # \u3053\u306e\u3078\u3093\u306f\u9069\u5f53\u306b\n    self.tableView.setTableFooterView @indicator\n  end\n\n  def end_indicator\n    @indicator.stopAnimating\n  end\nend\n\n\n\nitem.rb\nclass Item\n  attr_accessor :title, :url\n\n  BASE_URL = 'https://example.com/'\n\n  def initialize(data)\n    @title = data['title']\n    @url = data['url']\n  end\n\n\n  def self.fetch(fetch_count, offset, &block)\n    url = \"#{BASE_URL}?count=#{fetch_count}&offset=#{offset}\"\n\n    AFMotion::JSON.get(url) do |result|\n      items = []\n      error_message = nil\n\n      if result.success?\n        items = result.object.map{|data| self.new(data) }\n      end\n      block.call(items, error_message)\n    end\n  end\nend\n\n\n\n\nUITableView\u306e\u4e00\u756a\u4e0b\u306e\u30bb\u30eb\u307e\u3067\u30b9\u30af\u30ed\u30fc\u30eb\u3057\u305f\u3089\u3001\u6b21\u306eX\u4ef6\u8aad\u307f\u8fbc\u3080\u3001\u3063\u3066\u3044\u3046\u3084\u3064\u3002\n\n\n\n```ruby:items_controller.rb\nclass ItemsController < UITableViewController\n  READ_COUNT = 20\n  ITEM_CELL_ID = 'Item'\n  \n  def viewDidLoad\n    super\n\n    self.title = 'hoge'\n    @items = []\n    @page = 0\n    @last_items_size = 0\n\n    @indicator = UIActivityIndicatorView.alloc.initWithActivityIndicatorStyle(UIActivityIndicatorViewStyleGray)\n    @indicator.stopAnimating\n\n    load_items\n  end\n\n  def load_items\n    Item.fetch(READ_COUNT, @page * READ_COUNT) do |items, error_message|\n      @items += items\n      @last_items_size += items.size\n      self.tableView.reloadData\n    end\n  end\n\n  def load_more_items\n    @page += 1\n    load_items\n    end_indicator\n  end\n\n  def tableView(tableView, numberOfRowsInSection: section)\n    @items.size\n  end\n\n  def tableView(tableView, cellForRowAtIndexPath: indexPath)\n    cell = tableView.dequeueReusableCellWithIdentifier(ITEM_CELL_ID) ||\n      UITableViewCell.alloc.initWithStyle(UITableViewCellStyleSubtitle, reuseIdentifier: ITEM_CELL_ID)\n\n    item = @items[indexPath.row]\n    cell.textLabel.text = item.title\n    cell.detailTextLabel.text = item.url\n    cell\n  end\n\n  def scrollViewDidScroll(scrollView)\n    if self.tableView.contentOffset.y >= self.tableView.contentSize.height - self.tableView.bounds.size.height\n      return if @indicator.isAnimating\n\n      if @last_items_size >= (@page + 1) * READ_COUNT\n        start_indicator\n        self.performSelector('load_more_items', withObject: nil, afterDelay: 1.0)\n      end\n    end\n  end\n\n  def start_indicator\n    @indicator.startAnimating\n    @indicator.frame = [[0, 0], [self.view.frame.size.width / 2, self.view.frame.size.height / 8]]  # \u3053\u306e\u3078\u3093\u306f\u9069\u5f53\u306b\n    self.tableView.setTableFooterView @indicator\n  end\n\n  def end_indicator\n    @indicator.stopAnimating\n  end\nend\n```\n\n```ruby:item.rb\nclass Item\n  attr_accessor :title, :url\n\n  BASE_URL = 'https://example.com/'\n\n  def initialize(data)\n    @title = data['title']\n    @url = data['url']\n  end\n\n\n  def self.fetch(fetch_count, offset, &block)\n    url = \"#{BASE_URL}?count=#{fetch_count}&offset=#{offset}\"\n\n    AFMotion::JSON.get(url) do |result|\n      items = []\n      error_message = nil\n\n      if result.success?\n        items = result.object.map{|data| self.new(data) }\n      end\n      block.call(items, error_message)\n    end\n  end\nend\n\n```\n", "tags": ["RubyMotion"]}