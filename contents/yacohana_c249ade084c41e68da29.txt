{"tags": ["boost", "QVM", "\u7dda\u5f62\u4ee3\u6570", "C++", "Quaternion"], "context": "Boost\u306e\u30d0\u30fc\u30b8\u30e7\u30f3\u3092\u4e0a\u3052\u305f\u3089Boost QVM\u304c\u5165\u3063\u3066\u307e\u3057\u305f\uff0e\"QVM: Quaternions, Vectors, Matrices\"\u3060\u305d\u3046\u3067\u3059\uff0e\n\u4f4e\u6b21\u5143\u306e\u30d9\u30af\u30c8\u30eb\u6f14\u7b97\u3092\u5bfe\u8c61\u306b\u3057\u3066\u304a\u308a\uff0c2D/3D\u306e\u56de\u8ee2\u3084\u4e26\u9032\u304c\u30b5\u30af\u30c3\u3068\u5b9f\u88c5\u3067\u304d\u305d\u3046\u306a\u30e9\u30a4\u30d6\u30e9\u30ea\u3067\u3059\uff0e\n\u3053\u3053\u898b\u308b\u3068\u4ed6\u306e\u30e9\u30a4\u30d6\u30e9\u30ea\u4f9d\u5b58\u3084\u81ea\u4f5c\u306e\u30af\u30e9\u30b9\u306b\u5bfe\u3057\u3066\u6f14\u7b97\u3092\u5b9a\u7fa9\u3057\u3084\u3059\u3044\u3088\u3046\u306a\u306e\u3067\uff0c\u300c\u3042\u30fc\uff0c\u3053\u3063\u3061\u306eVector\u578b\u3068\u3053\u3063\u3061\u306evec3\u578b\u306e\u9593\u3067\u5185\u7a4d\u304c\u307b\u3057\u3044\u30fb\u30fb\u30fb\u300d\u307f\u305f\u3044\u306a\u3068\u304d\u306b\u4f7f\u3048\u308b\u306f\u305a\u3067\u3059\uff0e\n\u3061\u3087\u3063\u3068\u89e6\u3063\u3066\u307f\u305f\u306e\u3067\uff0c\u57fa\u672c\u64cd\u4f5c\u3092\u30e1\u30e2\u3064\u3044\u3067\u306b\u66f8\u3044\u3066\u304a\u304d\u307e\u3059\uff0e\n\u66f8\u304d\u3084\u3059\u304f\uff0cEigen\u307b\u3069\u30b3\u30f3\u30d1\u30a4\u30eb\u9045\u304f\u306a\u3089\u306a\u3044\u3042\u305f\u308a\u826f\u3055\u3052\uff0eBoost\u306b\u5165\u3063\u3066\u3044\u308b\u306e\u3067\u5171\u7528\u30b3\u30fc\u30c9\u3067\u3082\u4f7f\u3044\u3084\u3059\u3044\u304b\u3068\uff0e\n(MSVC 14.0(VS 2015), Boost 1.62.0\u3067\u52d5\u4f5c\u78ba\u8a8d)\n#include <iostream>\n#include <boost/qvm/all.hpp>\n\n//\u5186\u5468\u7387\ntemplate<typename T> constexpr const T pi() { return static_cast<T>(std::atan2(0.0, -1.0)); }\n\n// \u30d9\u30af\u30c8\u30eb\u8868\u793a\u7528\ntemplate <typename T, int D>\nstd::ostream& operator<<(std::ostream& os, const boost::qvm::vec<T, D>& v)\n{\n    os << \"[ \";\n    for (int i = 0; i < D - 1; ++i) os << v.a[i] << \", \";\n    if (D > 0) os << v.a[D - 1];\n    os << \" ]\";\n    return os;\n}\n\n// \u884c\u5217\u8868\u793a\u7528\ntemplate <typename T, int Rows, int Cols>\nstd::ostream& operator<<(std::ostream& os, const boost::qvm::mat<T, Rows, Cols>& m)\n{\n    os << \"[ \";\n    for (int r = 0; r < Rows - 1; ++r)\n    {\n        for (int c = 0; c < Cols - 1; ++c) os << m.a[r][c] << \", \";\n        if (Cols > 0) os << m.a[r][Cols - 1];\n        os << \"\\n  \";\n    }\n    if (Rows > 0)\n    {\n        for (int c = 0; c < Cols - 1; ++c) os << m.a[Rows - 1][c] << \", \";\n        if (Cols > 0) os << m.a[Rows - 1][Cols - 1];\n    }\n    os << \" ]\";\n    return os;\n}\n\n// \u3053\u3053\u304b\u3089\nint main()\n{\n    using namespace boost::qvm;\n\n    // \u30bc\u30ed\u30d9\u30af\u30c8\u30eb\n    vec<float, 3> vec_1 = zero_vec<float, 3>();\n    std::cout << \"vec_1: \" << vec_1 << std::endl;\n\n    // Initializer List\u3067\u30d9\u30af\u30c8\u30eb\u306e\u521d\u671f\u5316\n    vec<float, 3> vec_2 { 0.3f, 0.4f, 0.5f };\n    std::cout << \"vec_2: \" << vec_1 << std::endl;\n\n    //\u30d9\u30af\u30c8\u30eb\u306e\u8981\u7d20\u30a2\u30af\u30bb\u30b9\n    A<0>(vec_1) = 0.1f; // A<k>(v)\u3067k\u8981\u7d20\u76ee\u306b\u30a2\u30af\u30bb\u30b9\n    A1(vec_1) = 0.2f;   // A1(v)\u3067A<1>(v)\u306b\u30a2\u30af\u30bb\u30b9\u3082\u3067\u304d\u308b(k = [0 ... 9])\n    Z(vec_1) = 0.3f;    // X, Y, Z, W\u3067A0, A1, A2, A3\u306b\u30a2\u30af\u30bb\u30b9\u3067\u304d\u308b\n    std::cout << \"vec_1: \" << vec_1 << std::endl;\n    std::cout << \"vec_1(ZYX): \" << vec<float, 3>(ZYX(vec_1)) << std::endl; // \u30a2\u30af\u30bb\u30b9\u9806\u3092\u5909\u3048\u308b\n\n\n    // ------------------------\n    std::cout << std::endl;\n    // ------------------------\n\n    // \u8272\u3005\u3079\u30af\u30c8\u30eb\u306e\u6f14\u7b97\n    std::cout << \"\u30b9\u30ab\u30e9\u30fc\u500d: \" << vec_1 * 2.0f << std::endl;\n    std::cout << \"\u548c: \" << vec_1 + vec_2 << std::endl;\n    std::cout << \"\u5185\u7a4d: \" << dot(vec_1, vec_2) << std::endl;\n    std::cout << \"\u5916\u7a4d: \" << cross(vec_1, vec_2) << std::endl;\n    std::cout << \"\u5927\u304d\u3055(2-\u30ce\u30eb\u30e0): \" << mag(vec_1) << std::endl;\n    std::cout << \"\u5927\u304d\u3055\u306e2\u4e57: \" << mag_sqr(vec_1) << std::endl;\n    std::cout << \"\u6b63\u898f\u5316: \" << normalized(vec_1) << std::endl;\n    std::cout << \"\u5bfe\u89d2\u884c\u5217: \\n\" << mat<float, 3, 3>(diag_mat(vec_1)) << std::endl;\n\n    // ------------------------\n    std::cout << std::endl;\n    // ------------------------\n\n    // \u5358\u4f4d\u884c\u5217\u3067\u521d\u671f\u5316\n    mat<float, 3, 3> mat_1 = identity_mat<float, 3>();\n    std::cout << \"mat_1: \\n\" << mat_1 << std::endl;\n\n    // Initializer List\u3067\u884c\u5217\u306e\u521d\u671f\u5316\n    mat<float, 3, 3> mat_2 = {\n        0.1f, 0.2f, 0.3f,\n        0.4f, 0.5f, 0.6f,\n        0.7f, 0.8f, 0.9f,\n    };\n    std::cout << \"mat_2: \\n\" << mat_2 << std::endl;\n\n    //\u884c\u5217\u306e\u8981\u7d20\u30a2\u30af\u30bb\u30b9\n    A<0, 1>(mat_1) = 0.1f;\n    A12(mat_1) = 0.2f;\n    std::cout << \"mat_1: \" << mat_1 << std::endl;\n\n    // ------------------------\n    std::cout << std::endl;\n    // ------------------------\n\n    // \u8272\u3005\u884c\u5217\u306e\u6f14\u7b97\n    std::cout << \"\u30b9\u30ab\u30e9\u30fc\u500d: \\n\" << mat_1 * 2.0f << std::endl; // \u30b9\u30ab\u30e9\u30fc\u500d\u306f\u5404\u8981\u7d20\u306b\u4f5c\u7528\n    std::cout << \"\u884c\u5217\u7a4d: \\n\" << mat_1 * mat_2 << std::endl;\n    std::cout << \"\u884c\u5217\u3068\u30d9\u30af\u30c8\u30eb\u306e\u7a4d: \" << mat_1 * vec_1 << std::endl;\n    std::cout << \"\u8ee2\u7f6e: \\n\" << mat<float, 3, 3>(transposed(mat_1)) << std::endl;\n    std::cout << \"\u884c\u5217\u5f0f: \" << determinant(mat_1) << std::endl;\n\n    // ------------------------\n    std::cout << std::endl;\n    // ------------------------\n\n    // \u56de\u8ee2\u884c\u5217\n    // vec_1\u8ef8\u56de\u308a\u306bpi/6\u56de\u8ee2\u3059\u308b\u56de\u8ee2\u884c\u5217(\u56de\u8ee2\u8ef8-\u56de\u8ee2\u89d2)\n    mat<float, 3, 3> rmat_1 = rot_mat<3, decltype(vec_1), float>(vec_1, pi<float>() / 6);\n    std::cout << \"rmat_1: \\n\" << rmat_1 << std::endl;\n\n    // x\u8ef8\u56de\u308a\u306bpi/4\u56de\u8ee2\u3059\u308b\u56de\u8ee2\u884c\u5217\n    mat<float, 3, 3> rmat_2 = rotx_mat<3, float>(pi<float>() / 4);\n    std::cout << \"rmat_2: \\n\" << rmat_2 << std::endl;\n\n    // ------------------------\n    std::cout << std::endl;\n    // ------------------------\n\n    //\u30af\u30a9\u30fc\u30bf\u30cb\u30aa\u30f3\u3067\u56de\u8ee2\u3092\u88dc\u5b8c\u3059\u308b\n    quat<float> quat_begin = identity_quat<float>();\n    quat<float> quat_end = rotx_quat(pi<float>() / 2) * roty_quat(pi<float>() / 3);\n\n    for (float t = 0.0f; t < 1.0f; t += 0.1f)\n    {\n        const auto& rmat = convert_to<mat<float, 3, 3>>(slerp(quat_begin, quat_end, t));\n        std::cout << \"t: \" << t << \", rmat: \\n\" << rmat << std::endl;\n    }\n}\n\n\u3046\u30fc\u3093\uff0c\u6b63\u76f4Eigen\u4f7f\u3048\u3070\u826f\u304f\u306d\u3063\u3066\u611f\u3058\u304c\nBoost\u306e\u30d0\u30fc\u30b8\u30e7\u30f3\u3092\u4e0a\u3052\u305f\u3089[Boost QVM](http://www.boost.org/doc/libs/1_63_0/libs/qvm/doc/index.html)\u304c\u5165\u3063\u3066\u307e\u3057\u305f\uff0e\"QVM: Quaternions, Vectors, Matrices\"\u3060\u305d\u3046\u3067\u3059\uff0e\n\u4f4e\u6b21\u5143\u306e\u30d9\u30af\u30c8\u30eb\u6f14\u7b97\u3092\u5bfe\u8c61\u306b\u3057\u3066\u304a\u308a\uff0c2D/3D\u306e\u56de\u8ee2\u3084\u4e26\u9032\u304c\u30b5\u30af\u30c3\u3068\u5b9f\u88c5\u3067\u304d\u305d\u3046\u306a\u30e9\u30a4\u30d6\u30e9\u30ea\u3067\u3059\uff0e\n[\u3053\u3053](http://www.boost.org/doc/libs/1_63_0/libs/qvm/doc/quaternions_vectors_matrices.html)\u898b\u308b\u3068\u4ed6\u306e\u30e9\u30a4\u30d6\u30e9\u30ea\u4f9d\u5b58\u3084\u81ea\u4f5c\u306e\u30af\u30e9\u30b9\u306b\u5bfe\u3057\u3066\u6f14\u7b97\u3092\u5b9a\u7fa9\u3057\u3084\u3059\u3044\u3088\u3046\u306a\u306e\u3067\uff0c\u300c\u3042\u30fc\uff0c\u3053\u3063\u3061\u306eVector\u578b\u3068\u3053\u3063\u3061\u306evec3\u578b\u306e\u9593\u3067\u5185\u7a4d\u304c\u307b\u3057\u3044\u30fb\u30fb\u30fb\u300d\u307f\u305f\u3044\u306a\u3068\u304d\u306b\u4f7f\u3048\u308b\u306f\u305a\u3067\u3059\uff0e\n\n\u3061\u3087\u3063\u3068\u89e6\u3063\u3066\u307f\u305f\u306e\u3067\uff0c\u57fa\u672c\u64cd\u4f5c\u3092\u30e1\u30e2\u3064\u3044\u3067\u306b\u66f8\u3044\u3066\u304a\u304d\u307e\u3059\uff0e\n\u66f8\u304d\u3084\u3059\u304f\uff0cEigen\u307b\u3069\u30b3\u30f3\u30d1\u30a4\u30eb\u9045\u304f\u306a\u3089\u306a\u3044\u3042\u305f\u308a\u826f\u3055\u3052\uff0eBoost\u306b\u5165\u3063\u3066\u3044\u308b\u306e\u3067\u5171\u7528\u30b3\u30fc\u30c9\u3067\u3082\u4f7f\u3044\u3084\u3059\u3044\u304b\u3068\uff0e\n(MSVC 14.0(VS 2015), Boost 1.62.0\u3067\u52d5\u4f5c\u78ba\u8a8d)\n\n```c++\n#include <iostream>\n#include <boost/qvm/all.hpp>\n\n//\u5186\u5468\u7387\ntemplate<typename T> constexpr const T pi() { return static_cast<T>(std::atan2(0.0, -1.0)); }\n\n// \u30d9\u30af\u30c8\u30eb\u8868\u793a\u7528\ntemplate <typename T, int D>\nstd::ostream& operator<<(std::ostream& os, const boost::qvm::vec<T, D>& v)\n{\n\tos << \"[ \";\n\tfor (int i = 0; i < D - 1; ++i) os << v.a[i] << \", \";\n\tif (D > 0) os << v.a[D - 1];\n\tos << \" ]\";\n\treturn os;\n}\n\n// \u884c\u5217\u8868\u793a\u7528\ntemplate <typename T, int Rows, int Cols>\nstd::ostream& operator<<(std::ostream& os, const boost::qvm::mat<T, Rows, Cols>& m)\n{\n\tos << \"[ \";\n\tfor (int r = 0; r < Rows - 1; ++r)\n\t{\n\t\tfor (int c = 0; c < Cols - 1; ++c) os << m.a[r][c] << \", \";\n\t\tif (Cols > 0) os << m.a[r][Cols - 1];\n\t\tos << \"\\n  \";\n\t}\n\tif (Rows > 0)\n\t{\n\t\tfor (int c = 0; c < Cols - 1; ++c) os << m.a[Rows - 1][c] << \", \";\n\t\tif (Cols > 0) os << m.a[Rows - 1][Cols - 1];\n\t}\n\tos << \" ]\";\n\treturn os;\n}\n\n// \u3053\u3053\u304b\u3089\nint main()\n{\n\tusing namespace boost::qvm;\n\n\t// \u30bc\u30ed\u30d9\u30af\u30c8\u30eb\n\tvec<float, 3> vec_1 = zero_vec<float, 3>();\n\tstd::cout << \"vec_1: \" << vec_1 << std::endl;\n\t\n\t// Initializer List\u3067\u30d9\u30af\u30c8\u30eb\u306e\u521d\u671f\u5316\n\tvec<float, 3> vec_2 { 0.3f, 0.4f, 0.5f };\n\tstd::cout << \"vec_2: \" << vec_1 << std::endl;\n\n\t//\u30d9\u30af\u30c8\u30eb\u306e\u8981\u7d20\u30a2\u30af\u30bb\u30b9\n\tA<0>(vec_1) = 0.1f; // A<k>(v)\u3067k\u8981\u7d20\u76ee\u306b\u30a2\u30af\u30bb\u30b9\n\tA1(vec_1) = 0.2f;   // A1(v)\u3067A<1>(v)\u306b\u30a2\u30af\u30bb\u30b9\u3082\u3067\u304d\u308b(k = [0 ... 9])\n\tZ(vec_1) = 0.3f;    // X, Y, Z, W\u3067A0, A1, A2, A3\u306b\u30a2\u30af\u30bb\u30b9\u3067\u304d\u308b\n\tstd::cout << \"vec_1: \" << vec_1 << std::endl;\n\tstd::cout << \"vec_1(ZYX): \" << vec<float, 3>(ZYX(vec_1)) << std::endl; // \u30a2\u30af\u30bb\u30b9\u9806\u3092\u5909\u3048\u308b\n\n\n\t// ------------------------\n\tstd::cout << std::endl;\n\t// ------------------------\n\n\t// \u8272\u3005\u3079\u30af\u30c8\u30eb\u306e\u6f14\u7b97\n\tstd::cout << \"\u30b9\u30ab\u30e9\u30fc\u500d: \" << vec_1 * 2.0f << std::endl;\n\tstd::cout << \"\u548c: \" << vec_1 + vec_2 << std::endl;\n\tstd::cout << \"\u5185\u7a4d: \" << dot(vec_1, vec_2) << std::endl;\n\tstd::cout << \"\u5916\u7a4d: \" << cross(vec_1, vec_2) << std::endl;\n\tstd::cout << \"\u5927\u304d\u3055(2-\u30ce\u30eb\u30e0): \" << mag(vec_1) << std::endl;\n\tstd::cout << \"\u5927\u304d\u3055\u306e2\u4e57: \" << mag_sqr(vec_1) << std::endl;\n\tstd::cout << \"\u6b63\u898f\u5316: \" << normalized(vec_1) << std::endl;\n\tstd::cout << \"\u5bfe\u89d2\u884c\u5217: \\n\" << mat<float, 3, 3>(diag_mat(vec_1)) << std::endl;\n\n\t// ------------------------\n\tstd::cout << std::endl;\n\t// ------------------------\n\n\t// \u5358\u4f4d\u884c\u5217\u3067\u521d\u671f\u5316\n\tmat<float, 3, 3> mat_1 = identity_mat<float, 3>();\n\tstd::cout << \"mat_1: \\n\" << mat_1 << std::endl;\n\n\t// Initializer List\u3067\u884c\u5217\u306e\u521d\u671f\u5316\n\tmat<float, 3, 3> mat_2 = {\n\t\t0.1f, 0.2f, 0.3f,\n\t\t0.4f, 0.5f, 0.6f,\n\t\t0.7f, 0.8f, 0.9f,\n\t};\n\tstd::cout << \"mat_2: \\n\" << mat_2 << std::endl;\n\n\t//\u884c\u5217\u306e\u8981\u7d20\u30a2\u30af\u30bb\u30b9\n\tA<0, 1>(mat_1) = 0.1f;\n\tA12(mat_1) = 0.2f;\n\tstd::cout << \"mat_1: \" << mat_1 << std::endl;\n\n\t// ------------------------\n\tstd::cout << std::endl;\n\t// ------------------------\n\n\t// \u8272\u3005\u884c\u5217\u306e\u6f14\u7b97\n\tstd::cout << \"\u30b9\u30ab\u30e9\u30fc\u500d: \\n\" << mat_1 * 2.0f << std::endl; // \u30b9\u30ab\u30e9\u30fc\u500d\u306f\u5404\u8981\u7d20\u306b\u4f5c\u7528\n\tstd::cout << \"\u884c\u5217\u7a4d: \\n\" << mat_1 * mat_2 << std::endl;\n\tstd::cout << \"\u884c\u5217\u3068\u30d9\u30af\u30c8\u30eb\u306e\u7a4d: \" << mat_1 * vec_1 << std::endl;\n\tstd::cout << \"\u8ee2\u7f6e: \\n\" << mat<float, 3, 3>(transposed(mat_1)) << std::endl;\n\tstd::cout << \"\u884c\u5217\u5f0f: \" << determinant(mat_1) << std::endl;\n\n\t// ------------------------\n\tstd::cout << std::endl;\n\t// ------------------------\n\n\t// \u56de\u8ee2\u884c\u5217\n\t// vec_1\u8ef8\u56de\u308a\u306bpi/6\u56de\u8ee2\u3059\u308b\u56de\u8ee2\u884c\u5217(\u56de\u8ee2\u8ef8-\u56de\u8ee2\u89d2)\n\tmat<float, 3, 3> rmat_1 = rot_mat<3, decltype(vec_1), float>(vec_1, pi<float>() / 6);\n\tstd::cout << \"rmat_1: \\n\" << rmat_1 << std::endl;\n\n\t// x\u8ef8\u56de\u308a\u306bpi/4\u56de\u8ee2\u3059\u308b\u56de\u8ee2\u884c\u5217\n\tmat<float, 3, 3> rmat_2 = rotx_mat<3, float>(pi<float>() / 4);\n\tstd::cout << \"rmat_2: \\n\" << rmat_2 << std::endl;\n\n\t// ------------------------\n\tstd::cout << std::endl;\n\t// ------------------------\n\n\t//\u30af\u30a9\u30fc\u30bf\u30cb\u30aa\u30f3\u3067\u56de\u8ee2\u3092\u88dc\u5b8c\u3059\u308b\n\tquat<float> quat_begin = identity_quat<float>();\n\tquat<float> quat_end = rotx_quat(pi<float>() / 2) * roty_quat(pi<float>() / 3);\n\n\tfor (float t = 0.0f; t < 1.0f; t += 0.1f)\n\t{\n\t\tconst auto& rmat = convert_to<mat<float, 3, 3>>(slerp(quat_begin, quat_end, t));\n\t\tstd::cout << \"t: \" << t << \", rmat: \\n\" << rmat << std::endl;\n\t}\n}\n```\n\n~~\u3046\u30fc\u3093\uff0c\u6b63\u76f4Eigen\u4f7f\u3048\u3070\u826f\u304f\u306d\u3063\u3066\u611f\u3058\u304c~~\n"}