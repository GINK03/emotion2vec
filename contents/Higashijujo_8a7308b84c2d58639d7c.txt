{"context": "\n\nEvil Bit (\u60aa\u610f\u306e\u30d3\u30c3\u30c8)\nIPv4\u30d8\u30c3\u30c0\u306b\u306f\u307e\u3060\u4f7f\u308f\u308c\u3066\u3044\u306a\u3044\u9818\u57df\u304c1\u30d3\u30c3\u30c8\u3060\u3051\u6b8b\u3063\u3066\u3044\u308b\u3002 IP\u30d5\u30e9\u30b0\u30e1\u30f3\u30c8\u30aa\u30d5\u30bb\u30c3\u30c8\u9818\u57df\u306e\u6700\u4e0a\u4f4d\u30d3\u30c3\u30c8\u3060\u3002RFC791\u306b\u306f\u300c\u4e88\u7d04\u6e08\u307f\u3001\u30bc\u30ed\u3067\u306a\u3051\u308c\u3070\u306a\u3089\u306a\u3044\u300d\u3068\u66f8\u3044\u3066\u3042\u308b\u3002\n  Flags:  3 bits\n\n    Various Control Flags.\n\n      Bit 0: reserved, must be zero\n      Bit 1: (DF) 0 = May Fragment,  1 = Don't Fragment.\n      Bit 2: (MF) 0 = Last Fragment, 1 = More Fragments.\n\n          0   1   2\n        +---+---+---+\n        |   | D | M |\n        | 0 | F | F |\n        +---+---+---+\n\n\u3053\u308c\u3092\u3001RFC3514\u306f\u6b21\u306e\u3088\u3046\u306b\u6539\u3081\u308b\u63d0\u6848\u3092\u3057\u305f\u3002\u300c\u3082\u3057\u3001\u3053\u306e\u30d3\u30c3\u30c8\u306b1\u304c\u30bb\u30c3\u30c8\u3055\u308c\u3066\u3044\u308b\u306a\u3089\u3001\u30d1\u30b1\u30c3\u30c8\u306f\u60aa\u610f\u3092\u6301\u3063\u3066\u3044\u308b\u3002\u5b89\u5168\u306a\u30b7\u30b9\u30c6\u30e0\u306f\u3001\u305d\u306e\u3088\u3046\u306a\u30d1\u30b1\u30c3\u30c8\u306b\u5bfe\u3057\u3066\u9632\u885b\u63aa\u7f6e\u3092\u8b1b\u305a\u3079\u304d\u3060\u3002\u300d\u653b\u6483\u8005\u304c\u3053\u306e\u60aa\u610f\u306e\u30d3\u30c3\u30c8\u3092\u7acb\u3066\u3066\u304f\u308c\u308c\u3070\u3001\u30b7\u30b9\u30c6\u30e0\u7ba1\u7406\u8005\u306f\u8907\u96d1\u306a\u30bb\u30ad\u30e5\u30ea\u30c6\u30a3\u5bfe\u7b56\u306e\u4e00\u5207\u304b\u3089\u89e3\u653e\u3055\u308c\u308b\u3002\u3053\u308c\u3067\u4e16\u754c\u306b\u5e73\u548c\u304c\u8a2a\u308c\u308b\u3002\u7d20\u6674\u3089\u3057\u3044\u3002\u5b9f\u88c5\u3057\u306a\u3051\u308c\u3070\u306a\u3089\u306a\u3044\u3002\n          0\n        +---+\n        |   |\n        | E |\n        +---+\n\n   Currently-assigned values are defined as follows:\n\n   0x0  If the bit is set to 0, the packet has no evil intent.  Hosts,\n        network elements, etc., SHOULD assume that the packet is\n        harmless, and SHOULD NOT take any defensive measures.  (We note\n        that this part of the spec is already implemented by many common\n        desktop operating systems.)\n\n   0x1  If the bit is set to 1, the packet has evil intent.  Secure\n        systems SHOULD try to defend themselves against such packets.\n        Insecure systems MAY chose to crash, be penetrated, etc.\n\n\u5b9f\u969b\u3001\u3053\u306eRFC3514\u306f2003\u5e744\u67081\u65e5\u306e\u30a8\u30a4\u30d7\u30ea\u30eb\u30d5\u30fc\u30eb\u306b\u767a\u8868\u3055\u308c\u308b\u3068\u307b\u307c\u540c\u6642\u306bFreeBSD\u306b\u5b9f\u88c5\u3055\u308c\u305f\u3002(\u304c\u3001\u7121\u7c8b\u306a\u304c\u3089\u4ed8\u3051\u52a0\u3048\u308b\u3068\u3001\u3059\u3050\u306b\u3053\u306e\u5909\u66f4\u306f\u5143\u306b\u623b\u3055\u308c\u305f\u3002)\n\u7fcc2004\u5e74\u306e\u30a8\u30a4\u30d7\u30ea\u30eb\u30d5\u30fc\u30eb\u306b\u306f\u3001Linux 2.6.5 \u306e netfilter \u5411\u3051\u30d1\u30c3\u30c1\u3092\u66f8\u3044\u305f\u4eba\u304c\u3044\u308b\u3002\n\nLinux 4.9 \u306b\u5b9f\u88c5\u3057\u3066\u307f\u308b\n\u30af\u30ea\u30b9\u30de\u30b9\u3001\u4e16\u754c\u5e73\u548c\u306e\u9858\u3044\u3092\u8fbc\u3081\u3066\u3001\u3053\u306eRFC3514\u3092Linux\u30ab\u30fc\u30cd\u30eb\u306b\u5b9f\u88c5\u3057\u3088\u3046\u3002\u4eca\u56de\u306f\u30012003\u5e74\u306eBSD\u5b9f\u88c5\u306b\u8fd1\u3044\u3082\u306e\u3092\u4f5c\u308b\u3002\u305d\u306e\u904e\u7a0b\u3067setsockopt(2)\u3001getsockopt(2)\u3001sysctl(8)\u3092\u8ffd\u52a0\u3059\u308b\u3053\u3068\u306b\u306a\u308b\u3002\u3082\u3057\u3053\u308c\u3089\u3092\u5b9f\u88c5\u3057\u305f\u3044\u3068\u304d\u3001\u53c2\u8003\u306b\u306a\u308c\u3070\u3046\u308c\u3057\u3044\u3002\n\u307e\u305a\u60aa\u610f\u306e\u30d1\u30b1\u30c3\u30c8\u3092\u9001\u4fe1\u3059\u308b\u30bd\u30b1\u30c3\u30c8\u3068\u3044\u3046\u3082\u306e\u3092\u4f5c\u308a\u305f\u3044\u3002\u30bd\u30b1\u30c3\u30c8\u30aa\u30d7\u30b7\u30e7\u30f3\u3092\u30bb\u30c3\u30c8\u3059\u308b\u30d5\u30e9\u30b0\u3092struct inet_sock\u306b\u7f6e\u3044\u3066\u304a\u3053\u3046\u3002\u3053\u306e\u69cb\u9020\u4f53\u306f\u30bd\u30b1\u30c3\u30c8\u3054\u3068\u306b\u4f5c\u3089\u308c\u308b\u306e\u3067\u3001\u3053\u3053\u306bbool evil\u30d5\u30e9\u30b0\u3092\u8ffd\u52a0\u3057\u3066\u3001\u60aa\u610f\u306e\u30d1\u30b1\u30c3\u30c8\u3092\u9001\u4fe1\u3059\u308b\u30bd\u30b1\u30c3\u30c8\u304b\u3069\u3046\u304b\u3092\u30bb\u30c3\u30c8\u3057\u3066\u304a\u304f\u3053\u3068\u306b\u3059\u308b\u3002\n\n/include/net/inet_sock.h\n@@ -214,6 +214,7 @@ struct inet_sock {\n        __be32                  mc_addr;\n        struct ip_mc_socklist __rcu     *mc_list;\n        struct inet_cork_full   cork;\n+       bool                    evil;\n };\n\n\n\u7d9a\u3044\u3066\u3001IP\u30d8\u30c3\u30c0\u306e\u30d5\u30e9\u30b0\u30e1\u30f3\u30c8\u30aa\u30d5\u30bb\u30c3\u30c8\u9818\u57df\u306e\u6700\u4e0a\u4f4d\u30d3\u30c3\u30c8\u3092\u5b9a\u7fa9\u3059\u308b\u3002IP_CE(\u8f3b\u8f33\u30d5\u30e9\u30b0)\u306a\u308b\u3082\u306e\u304c\u3059\u3067\u306b\u3042\u308b\u304c\u3001\u4f7f\u308f\u308c\u3066\u3044\u306a\u3044\u306e\u3067\u6c17\u306b\u305b\u305a\u540c\u3058\u5024\u3092IP_EVIL\u3068\u3057\u3066\u5b9a\u7fa9\u3057\u3066\u304a\u304f\u3002\n\n/include/net/ip.h\n@@ -89,6 +89,7 @@ struct ip_ra_chain {\n extern struct ip_ra_chain __rcu *ip_ra_chain;\n\n /* IP flags. */\n+#define IP_EVIL        0x8000          /* Flag: \"The Evil Bit\"         */\n #define IP_CE          0x8000          /* Flag: \"Congestion\"           */\n #define IP_DF          0x4000          /* Flag: \"Don't Fragment\"       */\n #define IP_MF          0x2000          /* Flag: \"More Fragments\"       */\n\n\nstruct netns_ipv4\u306b\u306fsysctl(8)\u3067\u5236\u5fa1\u3059\u308b\u3001\u4ee5\u4e0b\u306e3\u3064\u306e\u30d5\u30e9\u30b0\u3092\u7f6e\u3044\u3066\u304a\u3053\u3046\u3002\n\n\nint sysctl_ip_do_rfc3514: RFC3514\u6a5f\u80fd\u3092\u6709\u52b9\u306b\u3059\u308b\n\nint sysctl_ip_speak_no_evil: \u30b7\u30b9\u30c6\u30e0\u3068\u3057\u3066\u60aa\u610f\u306e\u30d1\u30b1\u30c3\u30c8\u306f\u9001\u4fe1\u305b\u305a\u7834\u68c4\u3059\u308b\n\nint sysctl_ip_hear_no_evil: \u30b7\u30b9\u30c6\u30e0\u3068\u3057\u3066\u60aa\u610f\u306e\u30d1\u30b1\u30c3\u30c8\u306f\u53d7\u4fe1\u305b\u305a\u7834\u68c4\u3059\u308b\n\n\n/include/net/netns/ipv4.h\n@@ -116,6 +116,11 @@ struct netns_ipv4 {\n        int sysctl_igmp_llm_reports;\n        int sysctl_igmp_qrv;\n\n+       /* RFC3514 */\n+       int sysctl_ip_do_rfc3514;\n+       int sysctl_ip_speak_no_evil;\n+       int sysctl_ip_hear_no_evil;\n+\n        struct ping_group_range ping_group_range;\n\n        atomic_t dev_addr_genid;\n\n\n\u6b21\u306b\u3001\u30e6\u30fc\u30b6\u304c\u30bd\u30b1\u30c3\u30c8\u30aa\u30d7\u30b7\u30e7\u30f3\u306b\u6307\u5b9a\u3059\u308b\u305f\u3081\u306eIP_EVIL_INTENT\u30d5\u30e9\u30b0\u3092\u5b9a\u7fa9\u3059\u308b\u3002\u4ed6\u3068\u88ab\u3089\u306a\u3051\u308c\u3070\u306a\u3093\u3067\u3082\u3088\u304b\u3063\u305f\u306e\u3067666\u306b\u3057\u305f\u3002\n\n/include/uapi/linux/in.h\n@@ -160,6 +160,9 @@ struct in_addr {\n #define IP_DEFAULT_MULTICAST_TTL        1\n #define IP_DEFAULT_MULTICAST_LOOP       1\n\n+/* RFC3514: The security flag in the IPv4 header */\n+#define IP_EVIL_INTENT                 666\n+\n /* Request struct for multicast socket ops */\n\n #if __UAPI_DEF_IP_MREQ\n\n\n\u3055\u3066\u3001setsockopt(2)\u3092\u8ffd\u52a0\u3057\u3088\u3046\u3002SOL_IP\u30ec\u30d9\u30eb\u306bIP_EVIL_INTENT\u30aa\u30d7\u30b7\u30e7\u30f3\u3092\u8ffd\u52a0\u3059\u308b\u3002\u30bd\u30b1\u30c3\u30c8\u30aa\u30d7\u30b7\u30e7\u30f3\u304c\u30bb\u30c3\u30c8\u3055\u308c\u308b\u3068inet->evil\u30d5\u30e9\u30b0\u304c\u7acb\u3063\u3066\u3001\u60aa\u610f\u306e\u30d1\u30b1\u30c3\u30c8\u3092\u9001\u4fe1\u3059\u308b\u30bd\u30b1\u30c3\u30c8\u306b\u306a\u308b\u3002\n\n/net/ipv4/ip_sockglue.c\n@@ -614,6 +614,7 @@ static int do_ip_setsockopt(struct sock *sk, int level,\n        case IP_MULTICAST_LOOP:\n        case IP_RECVORIGDSTADDR:\n        case IP_CHECKSUM:\n+       case IP_EVIL_INTENT:\n                if (optlen >= sizeof(int)) {\n                        if (get_user(val, (int __user *) optval))\n                                return -EFAULT;\n@@ -1166,6 +1167,16 @@ static int do_ip_setsockopt(struct sock *sk, int level,\n                inet->min_ttl = val;\n                break;\n\n+       case IP_EVIL_INTENT:\n+               if (!net->ipv4.sysctl_ip_do_rfc3514)\n+                       goto e_inval;\n+               if (optlen < 1)\n+                       goto e_inval;\n+               if (val != 0 && val != 1)\n+                       goto e_inval;\n+               inet->evil = val;\n+               break;\n+\n        default:\n                err = -ENOPROTOOPT;\n                break;\n\n\n\u305d\u3057\u3066\u3001\u60aa\u610f\u306e\u30d1\u30b1\u30c3\u30c8\u3092\u9001\u4fe1\u3059\u308b\u30bd\u30b1\u30c3\u30c8\u304b\u3069\u3046\u304b\u3092\u5224\u5225\u3059\u308b\u305f\u3081\u306e\u3001getsockopt(2)\u3092\u5b9f\u88c5\u3059\u308b\u3002inet->evil\u30d5\u30e9\u30b0\u304c\u7acb\u3063\u3066\u3044\u308b\u304b\u3069\u3046\u304b\u3092\u8fd4\u3059\u3060\u3051\u3067\u3088\u3044\u3002\n\n/net/ipv4/ip_sockglue.c\n@@ -1497,6 +1508,9 @@ static int do_ip_getsockopt(struct sock *sk, int level, int optname,\n        case IP_MINTTL:\n                val = inet->min_ttl;\n                break;\n+       case IP_EVIL_INTENT:\n+               val = inet->evil;\n+               break;\n        default:\n                release_sock(sk);\n                return -ENOPROTOOPT;\n\n\n\u6b21\u306fprocfs\u306b\u4ee5\u4e0b\u306e3\u3064\u306e\u30d5\u30a1\u30a4\u30eb\u3092\u4f5c\u308b\u3002\u305d\u308c\u305e\u308c\u304csysctl(8)\u306b\u5bfe\u5fdc\u3057\u3066\u3044\u308b\u3002\n\n/proc/net/ipv4/rfc3515\n/proc/net/ipv4/ip_speak_no_evil\n/prok/net/ipv4/ip_hear_no_evil\n\n\n/net/ipv4/sysctl_net_ipv4.c\n@@ -971,6 +971,33 @@ static struct ctl_table ipv4_net_table[] = {\n                .extra2         = &one,\n        },\n #endif\n+       {\n+               .procname       = \"rfc3514\",\n+               .data           = &init_net.ipv4.sysctl_ip_do_rfc3514,\n+               .maxlen         = sizeof(int),\n+               .mode           = 0644,\n+               .proc_handler   = proc_dointvec_minmax,\n+               .extra1         = &zero,\n+               .extra2         = &one\n+       },\n+       {\n+               .procname       = \"ip_speak_no_evil\",\n+               .data           = &init_net.ipv4.sysctl_ip_speak_no_evil,\n+               .maxlen         = sizeof(int),\n+               .mode           = 0644,\n+               .proc_handler   = proc_dointvec_minmax,\n+               .extra1         = &zero,\n+               .extra2         = &one\n+       },\n+       {\n+               .procname       = \"ip_hear_no_evil\",\n+               .data           = &init_net.ipv4.sysctl_ip_hear_no_evil,\n+               .maxlen         = sizeof(int),\n+               .mode           = 0644,\n+               .proc_handler   = proc_dointvec_minmax,\n+               .extra1         = &zero,\n+               .extra2         = &one\n+       },\n        { }\n };\n\n\n\u3044\u3088\u3044\u3088\u901a\u4fe1\u90e8\u5206\u3002\u307e\u305a\u53d7\u4fe1\u51e6\u7406\u3002\u60aa\u610f\u306e\u30d1\u30b1\u30c3\u30c8\u3092\u53d7\u4fe1\u3057\u306a\u3044\u30d5\u30e9\u30b0sysctl_ip_hear_no_evil\u304c\u7acb\u3063\u3066\u3044\u3066\u3001\u304b\u3064\u53d7\u4fe1\u3057\u305f\u30d1\u30b1\u30c3\u30c8\u304c\u60aa\u610f\u306e\u30d1\u30b1\u30c3\u30c8ip_hdr(skb)->frag_off & htons(IP_EVIL)\u306a\u3089\u7834\u68c4\u3059\u308b\u3002\u307e\u305f\u3001RFC3514\u306b\u306fDropped packets SHOULD be noted in the appropriate MIB variable.\u3068\u3042\u308b\u306e\u3067\u305d\u308c\u306b\u5f93\u3044\u30d1\u30b1\u30c3\u30c8\u3092\u7834\u68c4\u3057\u305f\u5834\u5408\u306b\u306f\u9069\u5207\u306bMIB\u60c5\u5831\u3092\u66f4\u65b0\u3059\u308b\u3002\n\n/net/ipv4/ip_input.c\n@@ -430,6 +430,15 @@ int ip_rcv(struct sk_buff *skb, struct net_device *dev, struct packet_type *pt,\n\n        iph = ip_hdr(skb);\n\n+       /*\n+        * Check for RFC3514 (EVIL) packets.\n+        */\n+       if (net->ipv4.sysctl_ip_hear_no_evil &&\n+           ip_hdr(skb)->frag_off & htons(IP_EVIL)) {\n+               __IP_INC_STATS(net, IPSTATS_MIB_INDISCARDS);\n+               goto inhdr_error;\n+       }\n+\n        /*\n         *      RFC1122: 3.2.1.2 MUST silently discard any IP frame that fails the checksum.\n         *\n\n\n\u7d9a\u3044\u3066\u9001\u4fe1\u51e6\u7406\u3002\u3082\u3057\u3001RFC3514\u6a5f\u80fd\u3092\u6709\u52b9\u306b\u3059\u308bsysctl_ip_do_rfc3514\u30d5\u30e9\u30b0\u304c\u7acb\u3063\u3066\u3044\u3066\u3001\u60aa\u610f\u306e\u30d1\u30b1\u30c3\u30c8\u3092\u9001\u4fe1\u3059\u308b\u30bd\u30b1\u30c3\u30c8inet_sk(sk)->evil\u30d5\u30e9\u30b0\u304c\u7acb\u3063\u3066\u3044\u305f\u3089\u3001IP\u30d8\u30c3\u30c0\u306e\u60aa\u610f\u306e\u30d3\u30c3\u30c8\u3092\u7acb\u3066\u308b\u3002\n\n/net/ipv4/ip_output.c\n@@ -97,6 +97,9 @@ int __ip_local_out(struct net *net, struct sock *sk, struct sk_buff *skb)\n {\n        struct iphdr *iph = ip_hdr(skb);\n\n+       if (net->ipv4.sysctl_ip_do_rfc3514 && inet_sk(sk)->evil)\n+               iph->frag_off |= htons(IP_EVIL);\n+\n        iph->tot_len = htons(skb->len);\n        ip_send_check(iph);\n\n\n\u305f\u3060\u3057\u3001sysctl_ip_speak_no_evil\u30d5\u30e9\u30b0\u304c\u7acb\u3063\u3066\u3044\u308b\u5834\u5408\u306b\u306f\u3001\u60aa\u610f\u306e\u30d1\u30b1\u30c3\u30c8\u3092\u691c\u77e5\u3057\u3001\u9001\u4fe1\u305b\u305a\u306b\u7834\u68c4\u3059\u308b\u3002\u3082\u3061\u308d\u3093\u7834\u68c4\u3057\u305f\u65e8\u3001MIB\u60c5\u5831\u3082\u9069\u5207\u306b\u66f4\u65b0\u3059\u308b\u3002\n\n/net/ipv4/ip_output.c\n@@ -186,6 +189,14 @@ static int ip_finish_output2(struct net *net, struct sock *sk, struct sk_buff *s\n        struct neighbour *neigh;\n        u32 nexthop;\n\n+       /* RFC3514 */\n+       if (net->ipv4.sysctl_ip_speak_no_evil &&\n+           ip_hdr(skb)->frag_off & htons(IP_EVIL)) {\n+               IP_INC_STATS(net, IPSTATS_MIB_OUTDISCARDS);\n+               kfree_skb(skb);\n+               return -EACCES;\n+       }\n+\n        if (rt->rt_type == RTN_MULTICAST) {\n                IP_UPD_PO_STATS(net, IPSTATS_MIB_OUTMCAST, skb->len);\n        } else if (rt->rt_type == RTN_BROADCAST)\n\n\n\u6e96\u62e0\u3068\u307e\u3067\u8a00\u3048\u308b\u304b\u306f\u3068\u3082\u304b\u304f\u3001\u3053\u308c\u3067\u6982\u306dRFC3514\u306e\u5185\u5bb9\u3092\u5b9f\u88c5\u3067\u304d\u305f\u3002\u5272\u3068\u7c21\u5358\u306b\u5b9f\u88c5\u3067\u304d\u308b\u3053\u3068\u306b\u9a5a\u308d\u304f\u3068\u601d\u3046\u3002\u30d0\u30b0\u304c\u3042\u308c\u3070\u3054\u6307\u6458\u3044\u305f\u3060\u304d\u305f\u3044\u3002\n\u3053\u306e\u30b3\u30fc\u30c9\u3092\u4f7f\u3063\u305f\u653b\u6483\u306f\u6975\u3081\u3066\u5bb9\u6613\u306b\u906e\u65ad\u3067\u304d\u308b\u306e\u3067\u3001\u653b\u6483\u8005\u304c\u60aa\u7528\u3057\u3066\u3082\u554f\u984c\u306a\u3044\u3060\u308d\u3046\u3002\u3080\u3057\u308d\u653b\u6483\u8005\u5168\u54e1\u306b\u4f7f\u3063\u3066\u307b\u3057\u3044\u3002\u305d\u3046\u306a\u308c\u3070\u30a4\u30f3\u30bf\u30fc\u30cd\u30c3\u30c8\u306f\u611b\u3068\u5e73\u548c\u3067\u6e80\u305f\u3055\u308c\u308b\u3002\n\u30ec\u30ea\u30fc\u30ba\uff01\uff01\n## Evil Bit (\u60aa\u610f\u306e\u30d3\u30c3\u30c8)\n\nIPv4\u30d8\u30c3\u30c0\u306b\u306f\u307e\u3060\u4f7f\u308f\u308c\u3066\u3044\u306a\u3044\u9818\u57df\u304c1\u30d3\u30c3\u30c8\u3060\u3051\u6b8b\u3063\u3066\u3044\u308b\u3002 IP\u30d5\u30e9\u30b0\u30e1\u30f3\u30c8\u30aa\u30d5\u30bb\u30c3\u30c8\u9818\u57df\u306e\u6700\u4e0a\u4f4d\u30d3\u30c3\u30c8\u3060\u3002[RFC791](https://tools.ietf.org/html/rfc791)\u306b\u306f\u300c\u4e88\u7d04\u6e08\u307f\u3001\u30bc\u30ed\u3067\u306a\u3051\u308c\u3070\u306a\u3089\u306a\u3044\u300d\u3068\u66f8\u3044\u3066\u3042\u308b\u3002\n\n```\n  Flags:  3 bits\n\n    Various Control Flags.\n\n      Bit 0: reserved, must be zero\n      Bit 1: (DF) 0 = May Fragment,  1 = Don't Fragment.\n      Bit 2: (MF) 0 = Last Fragment, 1 = More Fragments.\n\n          0   1   2\n        +---+---+---+\n        |   | D | M |\n        | 0 | F | F |\n        +---+---+---+\n```\n\u3053\u308c\u3092\u3001[RFC3514](https://tools.ietf.org/html/rfc3514)\u306f\u6b21\u306e\u3088\u3046\u306b\u6539\u3081\u308b\u63d0\u6848\u3092\u3057\u305f\u3002\u300c\u3082\u3057\u3001\u3053\u306e\u30d3\u30c3\u30c8\u306b1\u304c\u30bb\u30c3\u30c8\u3055\u308c\u3066\u3044\u308b\u306a\u3089\u3001\u30d1\u30b1\u30c3\u30c8\u306f\u60aa\u610f\u3092\u6301\u3063\u3066\u3044\u308b\u3002\u5b89\u5168\u306a\u30b7\u30b9\u30c6\u30e0\u306f\u3001\u305d\u306e\u3088\u3046\u306a\u30d1\u30b1\u30c3\u30c8\u306b\u5bfe\u3057\u3066\u9632\u885b\u63aa\u7f6e\u3092\u8b1b\u305a\u3079\u304d\u3060\u3002\u300d\u653b\u6483\u8005\u304c\u3053\u306e\u60aa\u610f\u306e\u30d3\u30c3\u30c8\u3092\u7acb\u3066\u3066\u304f\u308c\u308c\u3070\u3001\u30b7\u30b9\u30c6\u30e0\u7ba1\u7406\u8005\u306f\u8907\u96d1\u306a\u30bb\u30ad\u30e5\u30ea\u30c6\u30a3\u5bfe\u7b56\u306e\u4e00\u5207\u304b\u3089\u89e3\u653e\u3055\u308c\u308b\u3002\u3053\u308c\u3067\u4e16\u754c\u306b\u5e73\u548c\u304c\u8a2a\u308c\u308b\u3002\u7d20\u6674\u3089\u3057\u3044\u3002\u5b9f\u88c5\u3057\u306a\u3051\u308c\u3070\u306a\u3089\u306a\u3044\u3002\n\n```\n          0\n        +---+\n        |   |\n        | E |\n        +---+\n\n   Currently-assigned values are defined as follows:\n\n   0x0  If the bit is set to 0, the packet has no evil intent.  Hosts,\n        network elements, etc., SHOULD assume that the packet is\n        harmless, and SHOULD NOT take any defensive measures.  (We note\n        that this part of the spec is already implemented by many common\n        desktop operating systems.)\n\n   0x1  If the bit is set to 1, the packet has evil intent.  Secure\n        systems SHOULD try to defend themselves against such packets.\n        Insecure systems MAY chose to crash, be penetrated, etc.\n```\n\u5b9f\u969b\u3001\u3053\u306eRFC3514\u306f2003\u5e744\u67081\u65e5\u306e\u30a8\u30a4\u30d7\u30ea\u30eb\u30d5\u30fc\u30eb\u306b\u767a\u8868\u3055\u308c\u308b\u3068\u307b\u307c\u540c\u6642\u306b[FreeBSD\u306b\u5b9f\u88c5](https://svnweb.freebsd.org/base?view=revision&revision=112929)\u3055\u308c\u305f\u3002(\u304c\u3001\u7121\u7c8b\u306a\u304c\u3089\u4ed8\u3051\u52a0\u3048\u308b\u3068\u3001\u3059\u3050\u306b\u3053\u306e\u5909\u66f4\u306f\u5143\u306b\u623b\u3055\u308c\u305f\u3002)\n\u7fcc2004\u5e74\u306e\u30a8\u30a4\u30d7\u30ea\u30eb\u30d5\u30fc\u30eb\u306b\u306f\u3001[Linux 2.6.5 \u306e netfilter \u5411\u3051\u30d1\u30c3\u30c1](http://lists.netfilter.org/pipermail/netfilter-devel/2004-April/014854.html)\u3092\u66f8\u3044\u305f\u4eba\u304c\u3044\u308b\u3002\n\n## Linux 4.9 \u306b\u5b9f\u88c5\u3057\u3066\u307f\u308b\n\u30af\u30ea\u30b9\u30de\u30b9\u3001\u4e16\u754c\u5e73\u548c\u306e\u9858\u3044\u3092\u8fbc\u3081\u3066\u3001\u3053\u306eRFC3514\u3092Linux\u30ab\u30fc\u30cd\u30eb\u306b\u5b9f\u88c5\u3057\u3088\u3046\u3002\u4eca\u56de\u306f\u30012003\u5e74\u306eBSD\u5b9f\u88c5\u306b\u8fd1\u3044\u3082\u306e\u3092\u4f5c\u308b\u3002\u305d\u306e\u904e\u7a0b\u3067`setsockopt(2)`\u3001`getsockopt(2)`\u3001`sysctl(8)`\u3092\u8ffd\u52a0\u3059\u308b\u3053\u3068\u306b\u306a\u308b\u3002\u3082\u3057\u3053\u308c\u3089\u3092\u5b9f\u88c5\u3057\u305f\u3044\u3068\u304d\u3001\u53c2\u8003\u306b\u306a\u308c\u3070\u3046\u308c\u3057\u3044\u3002\n\n\u307e\u305a\u60aa\u610f\u306e\u30d1\u30b1\u30c3\u30c8\u3092\u9001\u4fe1\u3059\u308b\u30bd\u30b1\u30c3\u30c8\u3068\u3044\u3046\u3082\u306e\u3092\u4f5c\u308a\u305f\u3044\u3002\u30bd\u30b1\u30c3\u30c8\u30aa\u30d7\u30b7\u30e7\u30f3\u3092\u30bb\u30c3\u30c8\u3059\u308b\u30d5\u30e9\u30b0\u3092`struct inet_sock`\u306b\u7f6e\u3044\u3066\u304a\u3053\u3046\u3002\u3053\u306e\u69cb\u9020\u4f53\u306f\u30bd\u30b1\u30c3\u30c8\u3054\u3068\u306b\u4f5c\u3089\u308c\u308b\u306e\u3067\u3001\u3053\u3053\u306b`bool evil`\u30d5\u30e9\u30b0\u3092\u8ffd\u52a0\u3057\u3066\u3001\u60aa\u610f\u306e\u30d1\u30b1\u30c3\u30c8\u3092\u9001\u4fe1\u3059\u308b\u30bd\u30b1\u30c3\u30c8\u304b\u3069\u3046\u304b\u3092\u30bb\u30c3\u30c8\u3057\u3066\u304a\u304f\u3053\u3068\u306b\u3059\u308b\u3002\n\n```/include/net/inet_sock.h\n@@ -214,6 +214,7 @@ struct inet_sock {\n        __be32                  mc_addr;\n        struct ip_mc_socklist __rcu     *mc_list;\n        struct inet_cork_full   cork;\n+       bool                    evil;\n };\n```\n\n\u7d9a\u3044\u3066\u3001IP\u30d8\u30c3\u30c0\u306e\u30d5\u30e9\u30b0\u30e1\u30f3\u30c8\u30aa\u30d5\u30bb\u30c3\u30c8\u9818\u57df\u306e\u6700\u4e0a\u4f4d\u30d3\u30c3\u30c8\u3092\u5b9a\u7fa9\u3059\u308b\u3002`IP_CE`(\u8f3b\u8f33\u30d5\u30e9\u30b0)\u306a\u308b\u3082\u306e\u304c\u3059\u3067\u306b\u3042\u308b\u304c\u3001\u4f7f\u308f\u308c\u3066\u3044\u306a\u3044\u306e\u3067\u6c17\u306b\u305b\u305a\u540c\u3058\u5024\u3092`IP_EVIL`\u3068\u3057\u3066\u5b9a\u7fa9\u3057\u3066\u304a\u304f\u3002\n\n```/include/net/ip.h\n@@ -89,6 +89,7 @@ struct ip_ra_chain {\n extern struct ip_ra_chain __rcu *ip_ra_chain;\n \n /* IP flags. */\n+#define IP_EVIL        0x8000          /* Flag: \"The Evil Bit\"         */\n #define IP_CE          0x8000          /* Flag: \"Congestion\"           */\n #define IP_DF          0x4000          /* Flag: \"Don't Fragment\"       */\n #define IP_MF          0x2000          /* Flag: \"More Fragments\"       */\n```\n\n`struct netns_ipv4`\u306b\u306f`sysctl(8)`\u3067\u5236\u5fa1\u3059\u308b\u3001\u4ee5\u4e0b\u306e3\u3064\u306e\u30d5\u30e9\u30b0\u3092\u7f6e\u3044\u3066\u304a\u3053\u3046\u3002\n\n * `int sysctl_ip_do_rfc3514`: RFC3514\u6a5f\u80fd\u3092\u6709\u52b9\u306b\u3059\u308b\n * `int sysctl_ip_speak_no_evil`: \u30b7\u30b9\u30c6\u30e0\u3068\u3057\u3066\u60aa\u610f\u306e\u30d1\u30b1\u30c3\u30c8\u306f\u9001\u4fe1\u305b\u305a\u7834\u68c4\u3059\u308b\n * `int sysctl_ip_hear_no_evil`: \u30b7\u30b9\u30c6\u30e0\u3068\u3057\u3066\u60aa\u610f\u306e\u30d1\u30b1\u30c3\u30c8\u306f\u53d7\u4fe1\u305b\u305a\u7834\u68c4\u3059\u308b\n\n```/include/net/netns/ipv4.h\n@@ -116,6 +116,11 @@ struct netns_ipv4 {\n        int sysctl_igmp_llm_reports;\n        int sysctl_igmp_qrv;\n \n+       /* RFC3514 */\n+       int sysctl_ip_do_rfc3514;\n+       int sysctl_ip_speak_no_evil;\n+       int sysctl_ip_hear_no_evil;\n+\n        struct ping_group_range ping_group_range;\n \n        atomic_t dev_addr_genid;\n```\n\u6b21\u306b\u3001\u30e6\u30fc\u30b6\u304c\u30bd\u30b1\u30c3\u30c8\u30aa\u30d7\u30b7\u30e7\u30f3\u306b\u6307\u5b9a\u3059\u308b\u305f\u3081\u306e`IP_EVIL_INTENT`\u30d5\u30e9\u30b0\u3092\u5b9a\u7fa9\u3059\u308b\u3002\u4ed6\u3068\u88ab\u3089\u306a\u3051\u308c\u3070\u306a\u3093\u3067\u3082\u3088\u304b\u3063\u305f\u306e\u3067`666`\u306b\u3057\u305f\u3002\n\n```/include/uapi/linux/in.h\n@@ -160,6 +160,9 @@ struct in_addr {\n #define IP_DEFAULT_MULTICAST_TTL        1\n #define IP_DEFAULT_MULTICAST_LOOP       1\n \n+/* RFC3514: The security flag in the IPv4 header */\n+#define IP_EVIL_INTENT                 666\n+\n /* Request struct for multicast socket ops */\n \n #if __UAPI_DEF_IP_MREQ\n```\n\u3055\u3066\u3001`setsockopt(2)`\u3092\u8ffd\u52a0\u3057\u3088\u3046\u3002`SOL_IP`\u30ec\u30d9\u30eb\u306b`IP_EVIL_INTENT`\u30aa\u30d7\u30b7\u30e7\u30f3\u3092\u8ffd\u52a0\u3059\u308b\u3002\u30bd\u30b1\u30c3\u30c8\u30aa\u30d7\u30b7\u30e7\u30f3\u304c\u30bb\u30c3\u30c8\u3055\u308c\u308b\u3068`inet->evil`\u30d5\u30e9\u30b0\u304c\u7acb\u3063\u3066\u3001\u60aa\u610f\u306e\u30d1\u30b1\u30c3\u30c8\u3092\u9001\u4fe1\u3059\u308b\u30bd\u30b1\u30c3\u30c8\u306b\u306a\u308b\u3002\n\n```/net/ipv4/ip_sockglue.c\n@@ -614,6 +614,7 @@ static int do_ip_setsockopt(struct sock *sk, int level,\n        case IP_MULTICAST_LOOP:\n        case IP_RECVORIGDSTADDR:\n        case IP_CHECKSUM:\n+       case IP_EVIL_INTENT:\n                if (optlen >= sizeof(int)) {\n                        if (get_user(val, (int __user *) optval))\n                                return -EFAULT;\n@@ -1166,6 +1167,16 @@ static int do_ip_setsockopt(struct sock *sk, int level,\n                inet->min_ttl = val;\n                break;\n \n+       case IP_EVIL_INTENT:\n+               if (!net->ipv4.sysctl_ip_do_rfc3514)\n+                       goto e_inval;\n+               if (optlen < 1)\n+                       goto e_inval;\n+               if (val != 0 && val != 1)\n+                       goto e_inval;\n+               inet->evil = val;\n+               break;\n+\n        default:\n                err = -ENOPROTOOPT;\n                break;\n```\n\u305d\u3057\u3066\u3001\u60aa\u610f\u306e\u30d1\u30b1\u30c3\u30c8\u3092\u9001\u4fe1\u3059\u308b\u30bd\u30b1\u30c3\u30c8\u304b\u3069\u3046\u304b\u3092\u5224\u5225\u3059\u308b\u305f\u3081\u306e\u3001`getsockopt(2)`\u3092\u5b9f\u88c5\u3059\u308b\u3002`inet->evil`\u30d5\u30e9\u30b0\u304c\u7acb\u3063\u3066\u3044\u308b\u304b\u3069\u3046\u304b\u3092\u8fd4\u3059\u3060\u3051\u3067\u3088\u3044\u3002\n\n```/net/ipv4/ip_sockglue.c\n@@ -1497,6 +1508,9 @@ static int do_ip_getsockopt(struct sock *sk, int level, int optname,\n        case IP_MINTTL:\n                val = inet->min_ttl;\n                break;\n+       case IP_EVIL_INTENT:\n+               val = inet->evil;\n+               break;\n        default:\n                release_sock(sk);\n                return -ENOPROTOOPT;\n```\n\n\u6b21\u306f`procfs`\u306b\u4ee5\u4e0b\u306e3\u3064\u306e\u30d5\u30a1\u30a4\u30eb\u3092\u4f5c\u308b\u3002\u305d\u308c\u305e\u308c\u304c`sysctl(8)`\u306b\u5bfe\u5fdc\u3057\u3066\u3044\u308b\u3002\n\n* /proc/net/ipv4/rfc3515\n* /proc/net/ipv4/ip_speak_no_evil\n* /prok/net/ipv4/ip_hear_no_evil\n\n```/net/ipv4/sysctl_net_ipv4.c\n@@ -971,6 +971,33 @@ static struct ctl_table ipv4_net_table[] = {\n                .extra2         = &one,\n        },\n #endif\n+       {\n+               .procname       = \"rfc3514\",\n+               .data           = &init_net.ipv4.sysctl_ip_do_rfc3514,\n+               .maxlen         = sizeof(int),\n+               .mode           = 0644,\n+               .proc_handler   = proc_dointvec_minmax,\n+               .extra1         = &zero,\n+               .extra2         = &one\n+       },\n+       {\n+               .procname       = \"ip_speak_no_evil\",\n+               .data           = &init_net.ipv4.sysctl_ip_speak_no_evil,\n+               .maxlen         = sizeof(int),\n+               .mode           = 0644,\n+               .proc_handler   = proc_dointvec_minmax,\n+               .extra1         = &zero,\n+               .extra2         = &one\n+       },\n+       {\n+               .procname       = \"ip_hear_no_evil\",\n+               .data           = &init_net.ipv4.sysctl_ip_hear_no_evil,\n+               .maxlen         = sizeof(int),\n+               .mode           = 0644,\n+               .proc_handler   = proc_dointvec_minmax,\n+               .extra1         = &zero,\n+               .extra2         = &one\n+       },\n        { }\n };\n```\n\n\u3044\u3088\u3044\u3088\u901a\u4fe1\u90e8\u5206\u3002\u307e\u305a\u53d7\u4fe1\u51e6\u7406\u3002\u60aa\u610f\u306e\u30d1\u30b1\u30c3\u30c8\u3092\u53d7\u4fe1\u3057\u306a\u3044\u30d5\u30e9\u30b0`sysctl_ip_hear_no_evil`\u304c\u7acb\u3063\u3066\u3044\u3066\u3001\u304b\u3064\u53d7\u4fe1\u3057\u305f\u30d1\u30b1\u30c3\u30c8\u304c\u60aa\u610f\u306e\u30d1\u30b1\u30c3\u30c8`ip_hdr(skb)->frag_off & htons(IP_EVIL)`\u306a\u3089\u7834\u68c4\u3059\u308b\u3002\u307e\u305f\u3001RFC3514\u306b\u306f`Dropped packets SHOULD be noted in the appropriate MIB variable.`\u3068\u3042\u308b\u306e\u3067\u305d\u308c\u306b\u5f93\u3044\u30d1\u30b1\u30c3\u30c8\u3092\u7834\u68c4\u3057\u305f\u5834\u5408\u306b\u306f\u9069\u5207\u306bMIB\u60c5\u5831\u3092\u66f4\u65b0\u3059\u308b\u3002\n\n```/net/ipv4/ip_input.c\n@@ -430,6 +430,15 @@ int ip_rcv(struct sk_buff *skb, struct net_device *dev, struct packet_type *pt,\n \n        iph = ip_hdr(skb);\n \n+       /*\n+        * Check for RFC3514 (EVIL) packets.\n+        */\n+       if (net->ipv4.sysctl_ip_hear_no_evil &&\n+           ip_hdr(skb)->frag_off & htons(IP_EVIL)) {\n+               __IP_INC_STATS(net, IPSTATS_MIB_INDISCARDS);\n+               goto inhdr_error;\n+       }\n+\n        /*\n         *      RFC1122: 3.2.1.2 MUST silently discard any IP frame that fails the checksum.\n         *\n```\n\u7d9a\u3044\u3066\u9001\u4fe1\u51e6\u7406\u3002\u3082\u3057\u3001RFC3514\u6a5f\u80fd\u3092\u6709\u52b9\u306b\u3059\u308b`sysctl_ip_do_rfc3514`\u30d5\u30e9\u30b0\u304c\u7acb\u3063\u3066\u3044\u3066\u3001\u60aa\u610f\u306e\u30d1\u30b1\u30c3\u30c8\u3092\u9001\u4fe1\u3059\u308b\u30bd\u30b1\u30c3\u30c8`inet_sk(sk)->evil`\u30d5\u30e9\u30b0\u304c\u7acb\u3063\u3066\u3044\u305f\u3089\u3001IP\u30d8\u30c3\u30c0\u306e\u60aa\u610f\u306e\u30d3\u30c3\u30c8\u3092\u7acb\u3066\u308b\u3002\n\n```/net/ipv4/ip_output.c\n@@ -97,6 +97,9 @@ int __ip_local_out(struct net *net, struct sock *sk, struct sk_buff *skb)\n {\n        struct iphdr *iph = ip_hdr(skb);\n \n+       if (net->ipv4.sysctl_ip_do_rfc3514 && inet_sk(sk)->evil)\n+               iph->frag_off |= htons(IP_EVIL);\n+\n        iph->tot_len = htons(skb->len);\n        ip_send_check(iph);\n```\n\u305f\u3060\u3057\u3001`sysctl_ip_speak_no_evil`\u30d5\u30e9\u30b0\u304c\u7acb\u3063\u3066\u3044\u308b\u5834\u5408\u306b\u306f\u3001\u60aa\u610f\u306e\u30d1\u30b1\u30c3\u30c8\u3092\u691c\u77e5\u3057\u3001\u9001\u4fe1\u305b\u305a\u306b\u7834\u68c4\u3059\u308b\u3002\u3082\u3061\u308d\u3093\u7834\u68c4\u3057\u305f\u65e8\u3001MIB\u60c5\u5831\u3082\u9069\u5207\u306b\u66f4\u65b0\u3059\u308b\u3002\n\n```/net/ipv4/ip_output.c\n@@ -186,6 +189,14 @@ static int ip_finish_output2(struct net *net, struct sock *sk, struct sk_buff *s\n        struct neighbour *neigh;\n        u32 nexthop;\n \n+       /* RFC3514 */\n+       if (net->ipv4.sysctl_ip_speak_no_evil &&\n+           ip_hdr(skb)->frag_off & htons(IP_EVIL)) {\n+               IP_INC_STATS(net, IPSTATS_MIB_OUTDISCARDS);\n+               kfree_skb(skb);\n+               return -EACCES;\n+       }\n+\n        if (rt->rt_type == RTN_MULTICAST) {\n                IP_UPD_PO_STATS(net, IPSTATS_MIB_OUTMCAST, skb->len);\n        } else if (rt->rt_type == RTN_BROADCAST)\n```\n\n\u6e96\u62e0\u3068\u307e\u3067\u8a00\u3048\u308b\u304b\u306f\u3068\u3082\u304b\u304f\u3001\u3053\u308c\u3067\u6982\u306dRFC3514\u306e\u5185\u5bb9\u3092\u5b9f\u88c5\u3067\u304d\u305f\u3002\u5272\u3068\u7c21\u5358\u306b\u5b9f\u88c5\u3067\u304d\u308b\u3053\u3068\u306b\u9a5a\u308d\u304f\u3068\u601d\u3046\u3002\u30d0\u30b0\u304c\u3042\u308c\u3070\u3054\u6307\u6458\u3044\u305f\u3060\u304d\u305f\u3044\u3002\n\n\u3053\u306e\u30b3\u30fc\u30c9\u3092\u4f7f\u3063\u305f\u653b\u6483\u306f\u6975\u3081\u3066\u5bb9\u6613\u306b\u906e\u65ad\u3067\u304d\u308b\u306e\u3067\u3001\u653b\u6483\u8005\u304c\u60aa\u7528\u3057\u3066\u3082\u554f\u984c\u306a\u3044\u3060\u308d\u3046\u3002\u3080\u3057\u308d\u653b\u6483\u8005\u5168\u54e1\u306b\u4f7f\u3063\u3066\u307b\u3057\u3044\u3002\u305d\u3046\u306a\u308c\u3070\u30a4\u30f3\u30bf\u30fc\u30cd\u30c3\u30c8\u306f\u611b\u3068\u5e73\u548c\u3067\u6e80\u305f\u3055\u308c\u308b\u3002\n\n\u30ec\u30ea\u30fc\u30ba\uff01\uff01\n", "tags": ["Linux", "kernel", "Security", "rfc-joke"]}