{"context": "\u4ee5\u524d\u66f8\u3044\u305fBase64\u30a8\u30f3\u30b3\u30fc\u30c0\nD\u8a00\u8a9e\u3067\u66f8\u304f \"\u30a4\u30b1\u30e1\u30f3\u306a\u30b3\u30fc\u30c9\" ~ Base64\u30a8\u30f3\u30b3\u30fc\u30c0\u3092\u30ef\u30f3\u30e9\u30a4\u30ca\u30fc\u3067\u66f8\u304f ~\n\u306e\u30d0\u30b0\u3092\u76f4\u3057\u305f\u6642\u306b\u3001\u300c\u3042\u3063\u3001\u307e\u3060\u30c7\u30b3\u30fc\u30c0\u3092\u66f8\u3044\u3066\u306a\u3044\u3084\u300d\u3068\u601d\u3063\u305f\u306e\u3067\u66f8\u304d\u307e\u3057\u305f\u3002\n\u4f8b\u306b\u3088\u3063\u3066\u578b\u63a8\u8ad6\u304c\u52b9\u3044\u3066\u3044\u308b\u306e\u3067\u5f15\u6570\u306e\u578b\u306f\u7701\u7565\u3057\u307e\u3057\u305f\u3002\n\u4eca\u56de\u306f\u8a18\u4e8b\u306e\u672b\u5c3e\u306b\u3053\u308c\u306e\u3082\u3068\u3068\u306a\u3063\u305f\u3001\u30d2\u30e5\u30fc\u30de\u30f3\u30ea\u30fc\u30c0\u30d6\u30eb(?)\u306a\u901a\u5e38\u306e\u5b9f\u88c5\u3082\u8f09\u305b\u3066\u304a\u304d\u307e\u3059\u3002\n\ntinyBase64Decoder.d\nimport std.algorithm,\n       std.string,\n       std.ascii,\n       std.range,\n       std.conv;\n\nR delegate(Args) Z(R, Args...)(R delegate(R delegate(Args), Args) f){\n  return (Args args) => f(Z(f), args);\n}\n\nubyte[] decode(string data) {\n  return\n    (convb =>\n      (table =>\n        (converted =>\n          (cLen =>\n            (quotients =>\n              (qLen =>\n                (qLen / 2).iota.map!(i =>\n                  (buf =>\n                    (bu2 =>\n                      ((b0, b1) =>\n                        (b0 << 4 ^ b1) & 0xff\n                      )(bu2(buf[0]), bu2(buf[1]))\n                    )((string bs) => bs.parse!ubyte(2))\n                  )(quotients[(i * 2)..((i + 1) * 2)])\n                ).array.to!(ubyte[])\n              )(quotients.length)\n            )(\n              (cLen / 4).iota.map!(i =>\n                converted[(i * 4)..((i + 1) * 4)]\n              ).array\n            )\n          )(converted.length)\n        )(\n          data.filter!(x => x != '=').map!(e => \n            table[e.to!string]\n          ).array.join\n        )\n      )((charset => \n          assocArray(\n            zip(\n              charset,\n              charset.length.iota.map!(i =>\n                (e =>\n                  e.length == 6\n                    ? e\n                    : repeat(\"0\", 6 - e.length).join ~ e\n                )(convb(i, 2)))\n              ))\n          )((uppercase ~ lowercase ~ digits ~ \"+/\").split(string.init))\n      )\n    )((ulong N, int base) =>\n      (convbM =>\n        convbM(N, N, [], base)\n      )(Z((string delegate(ulong, ulong, ulong[], int base) convbM, ulong N, ulong tmp, ulong[] stack, int base) =>\n          tmp ? convbM(N, tmp / base, stack ~ (tmp % base), base) : stack.reverse.map!(e => e.to!string).join)));\n}\n\nunittest {\n  string base    = \"ABCDEFG\",\n         encoded = encode(base);\n\n  assert(base == decode(encoded));\n}\n\n\n\u30a8\u30f3\u30b3\u30fc\u30c9\u306b\u6bd4\u3079\u3066\u5272\u308a\u3068\u697d\u3067\u3057\u305f(\u30d3\u30c3\u30c8\u6f14\u7b97\u3067\u5c11\u3057\u3060\u3051\u8e93\u3044\u3066\u3057\u307e\u3063\u305f\u306e\u3067\u9811\u5f35\u308a\u305f\u3044)\n\u3067\u306f\u3001\u30d2\u30e5\u30fc\u30de\u30f3\u30ea\u30fc\u30c0\u30d6\u30eb\u306a\u30b3\u30fc\u30c9\u3092\u63b2\u8f09\u3057\u3066\u304a\u304d\u307e\u3059(\u89e3\u8aac\u3082\u7c21\u5358\u306a\u304c\u3089\u4ed8\u3051\u3066\u304a\u304d\u307e\u3057\u305f):\nimport std.algorithm,\n       std.string,\n       std.ascii,\n       std.range,\n       std.conv;\n\nubyte[] decodeX(string data) {\n  //Base64\u306e\u30c7\u30b3\u30fc\u30c9\u7528\u306e\u5909\u63db\u30c6\u30fc\u30d6\u30eb(Base64\u6587\u5b57\u5217 -> 6bit)\n  string[string] table =\n    ((string delegate(ulong, int) convb) =>\n      ((string[] charset) => \n        assocArray(\n          zip(\n            charset,\n            charset.length.iota.map!((ulong i) =>\n              ((string e) =>\n                e.length == 6\n                  ? e\n                  : repeat(\"0\", 6 - e.length).join ~ e\n              )(convb(i, 2)))\n          )\n        )\n      )((uppercase ~ lowercase ~ digits ~ \"+/\").split(string.init))\n    )((ulong N, int base) =>\n      (convbM =>\n        convbM(N, N, [], base)\n      )(Z((string delegate(ulong, ulong, ulong[], int base) convbM, ulong N, ulong tmp, ulong[] stack, int base) =>\n          tmp ? convbM(N, tmp / base, stack ~ (tmp % base), base) : stack.reverse.map!(e => e.to!string).join)));\n\n\n  //\u5909\u63db\u8868\u306b\u5f93\u3044\u3001Base64\u6587\u5b57\u5217\u30926bit\u306b\u5909\u63db\u3057\u3001\u305d\u308c\u3092\u7d50\u5408\n  string converted =\n    data.filter!(x => x != '=').map!(e => \n      table[e.to!string]\n    ).array.join;\n\n  //4bit\u305a\u3064\u306bconverted\u3092\u5207\u308a\u5206\u3051\u308b\u305f\u3081\u306e\u914d\u5217\n  string[] quotients;\n  //\u30c7\u30b3\u30fc\u30c9\u3057\u305f\u7d50\u679c\u3092\u683c\u7d0d\u3059\u308b\n  ubyte[] decoded;\n\n  //4\u6587\u5b57(4bit)\u5206\u53d6\u308a\u51fa\u3057\u3066\u3001\u914d\u5217\u306b\u8ffd\u52a0\u3059\u308b(\u5207\u308a\u51fa\u3057)\n  foreach (i; (converted.length / 4).iota) {\n    string str = converted[(i * 4)..((i + 1) * 4)];\n    quotients ~= str;\n  }\n\n  //\u96a3\u63a5\u3059\u308b4bit * 2\u306e8bit\u304b\u3089\u30d0\u30a4\u30ca\u30ea\u3092\u5fa9\u5143\n  foreach (i; (quotients.length / 2).iota) {\n    //\u96a3\u63a5\u3059\u308b4bit * 2\u3092\u53d6\u308a\u51fa\u3059\n    string[] buf = quotients[(i * 2)..((i + 1) * 2)];\n\n    //\u6587\u5b57\u5217\u5316\u3055\u308c\u305f\u6570\u5b57\u30922\u9032\u6570\u3068\u3057\u3066\u89e3\u91c8\u3057\u300110\u9032\u6570\u306b\u5909\u63db\u3059\u308b\n    auto bu2 = ((string bs) => bs.parse!ubyte(2));\n    ubyte b0 = bu2(buf[0]),\n          b1 = bu2(buf[1]);\n\n    //bit\u6f14\u7b97\u3057\u3066\u30d0\u30a4\u30ca\u30ea\u306b\u623b\u3059\n    decoded ~= (b0 << 4 ^ b1) & 0xff;\n  }\n\n  /*\n    Base64\u306e\u30c7\u30b3\u30fc\u30c9\u306f\u6570\u591a\u304f\u306e\u5b9f\u88c5\u304c\u5b58\u5728\u3059\u308b\u304c(\u691c\u7d22\u3059\u308b\u3068\u591a\u304f\u306e\u4eba\u304c\u3059\u3067\u306b\u5b9f\u88c5&\u89e3\u8aac\u3092\u3057\u3066\u3044\u307e\u3059)\u3001\u305d\u306e\u591a\u304f\u306f6bit * 4 = 24bit \u3092 8bit * 3\u3068\u3057\u3066\u6271\u3046\u305f\u3081\u306bbit\u6f14\u7b97\u3092\u3057\u3066\u3044\u308b\u3088\u3046\u306a\u6c17\u304c\u3057\u307e\u3059\u3002\n    \u3057\u304b\u3057\u3001\u96a3\u63a5\u3059\u308b4bit * 2\u304b\u3089\u8a08\u7b97\u3059\u308b\u65b9\u6cd5\u3092\u7528\u3044\u308c\u3070\u30016bit * 4\u3068\u3059\u308b\u305f\u3081\u306b`quotients` % 4(\u3053\u306e\u30b3\u30fc\u30c9\u306equotients\u306b\u76f8\u5f53\u3059\u308b\u3082\u306e)\u3092\u5225\u306b\u8003\u3048\u308b\u5fc5\u8981\u304c\u306a\u304f\u306a\u308a\u307e\u3059(\u305f\u3076\u3093... \u81ea\u4fe1\u306f\u306a\u3044\u3067\u3059\u3051\u3069)\u3002\n  */\n\n  return decoded;\n}\n\n\u4ee5\u524d\u66f8\u3044\u305fBase64\u30a8\u30f3\u30b3\u30fc\u30c0\n\n[D\u8a00\u8a9e\u3067\u66f8\u304f \"\u30a4\u30b1\u30e1\u30f3\u306a\u30b3\u30fc\u30c9\" ~ Base64\u30a8\u30f3\u30b3\u30fc\u30c0\u3092\u30ef\u30f3\u30e9\u30a4\u30ca\u30fc\u3067\u66f8\u304f ~](http://qiita.com/alpha_kai_NET/items/f9fabe15f5619e10e654)\n\n\u306e\u30d0\u30b0\u3092\u76f4\u3057\u305f\u6642\u306b\u3001\u300c\u3042\u3063\u3001\u307e\u3060\u30c7\u30b3\u30fc\u30c0\u3092\u66f8\u3044\u3066\u306a\u3044\u3084\u300d\u3068\u601d\u3063\u305f\u306e\u3067\u66f8\u304d\u307e\u3057\u305f\u3002\n\u4f8b\u306b\u3088\u3063\u3066\u578b\u63a8\u8ad6\u304c\u52b9\u3044\u3066\u3044\u308b\u306e\u3067\u5f15\u6570\u306e\u578b\u306f\u7701\u7565\u3057\u307e\u3057\u305f\u3002\n\u4eca\u56de\u306f\u8a18\u4e8b\u306e\u672b\u5c3e\u306b\u3053\u308c\u306e\u3082\u3068\u3068\u306a\u3063\u305f\u3001\u30d2\u30e5\u30fc\u30de\u30f3\u30ea\u30fc\u30c0\u30d6\u30eb(?)\u306a\u901a\u5e38\u306e\u5b9f\u88c5\u3082\u8f09\u305b\u3066\u304a\u304d\u307e\u3059\u3002\n\n```d:tinyBase64Decoder.d\nimport std.algorithm,\n       std.string,\n       std.ascii,\n       std.range,\n       std.conv;\n\nR delegate(Args) Z(R, Args...)(R delegate(R delegate(Args), Args) f){\n  return (Args args) => f(Z(f), args);\n}\n\nubyte[] decode(string data) {\n  return\n    (convb =>\n      (table =>\n        (converted =>\n          (cLen =>\n            (quotients =>\n              (qLen =>\n                (qLen / 2).iota.map!(i =>\n                  (buf =>\n                    (bu2 =>\n                      ((b0, b1) =>\n                        (b0 << 4 ^ b1) & 0xff\n                      )(bu2(buf[0]), bu2(buf[1]))\n                    )((string bs) => bs.parse!ubyte(2))\n                  )(quotients[(i * 2)..((i + 1) * 2)])\n                ).array.to!(ubyte[])\n              )(quotients.length)\n            )(\n              (cLen / 4).iota.map!(i =>\n                converted[(i * 4)..((i + 1) * 4)]\n              ).array\n            )\n          )(converted.length)\n        )(\n          data.filter!(x => x != '=').map!(e => \n            table[e.to!string]\n          ).array.join\n        )\n      )((charset => \n          assocArray(\n            zip(\n              charset,\n              charset.length.iota.map!(i =>\n                (e =>\n                  e.length == 6\n                    ? e\n                    : repeat(\"0\", 6 - e.length).join ~ e\n                )(convb(i, 2)))\n              ))\n          )((uppercase ~ lowercase ~ digits ~ \"+/\").split(string.init))\n      )\n    )((ulong N, int base) =>\n      (convbM =>\n        convbM(N, N, [], base)\n      )(Z((string delegate(ulong, ulong, ulong[], int base) convbM, ulong N, ulong tmp, ulong[] stack, int base) =>\n          tmp ? convbM(N, tmp / base, stack ~ (tmp % base), base) : stack.reverse.map!(e => e.to!string).join)));\n}\n\nunittest {\n  string base    = \"ABCDEFG\",\n         encoded = encode(base);\n\n  assert(base == decode(encoded));\n}\n```\n\n\u30a8\u30f3\u30b3\u30fc\u30c9\u306b\u6bd4\u3079\u3066\u5272\u308a\u3068\u697d\u3067\u3057\u305f(\u30d3\u30c3\u30c8\u6f14\u7b97\u3067\u5c11\u3057\u3060\u3051\u8e93\u3044\u3066\u3057\u307e\u3063\u305f\u306e\u3067\u9811\u5f35\u308a\u305f\u3044)\n\n\n\u3067\u306f\u3001\u30d2\u30e5\u30fc\u30de\u30f3\u30ea\u30fc\u30c0\u30d6\u30eb\u306a\u30b3\u30fc\u30c9\u3092\u63b2\u8f09\u3057\u3066\u304a\u304d\u307e\u3059(\u89e3\u8aac\u3082\u7c21\u5358\u306a\u304c\u3089\u4ed8\u3051\u3066\u304a\u304d\u307e\u3057\u305f):\n\n```d\nimport std.algorithm,\n       std.string,\n       std.ascii,\n       std.range,\n       std.conv;\n\nubyte[] decodeX(string data) {\n  //Base64\u306e\u30c7\u30b3\u30fc\u30c9\u7528\u306e\u5909\u63db\u30c6\u30fc\u30d6\u30eb(Base64\u6587\u5b57\u5217 -> 6bit)\n  string[string] table =\n    ((string delegate(ulong, int) convb) =>\n      ((string[] charset) => \n        assocArray(\n          zip(\n            charset,\n            charset.length.iota.map!((ulong i) =>\n              ((string e) =>\n                e.length == 6\n                  ? e\n                  : repeat(\"0\", 6 - e.length).join ~ e\n              )(convb(i, 2)))\n          )\n        )\n      )((uppercase ~ lowercase ~ digits ~ \"+/\").split(string.init))\n    )((ulong N, int base) =>\n      (convbM =>\n        convbM(N, N, [], base)\n      )(Z((string delegate(ulong, ulong, ulong[], int base) convbM, ulong N, ulong tmp, ulong[] stack, int base) =>\n          tmp ? convbM(N, tmp / base, stack ~ (tmp % base), base) : stack.reverse.map!(e => e.to!string).join)));\n\n\n  //\u5909\u63db\u8868\u306b\u5f93\u3044\u3001Base64\u6587\u5b57\u5217\u30926bit\u306b\u5909\u63db\u3057\u3001\u305d\u308c\u3092\u7d50\u5408\n  string converted =\n    data.filter!(x => x != '=').map!(e => \n      table[e.to!string]\n    ).array.join;\n\n  //4bit\u305a\u3064\u306bconverted\u3092\u5207\u308a\u5206\u3051\u308b\u305f\u3081\u306e\u914d\u5217\n  string[] quotients;\n  //\u30c7\u30b3\u30fc\u30c9\u3057\u305f\u7d50\u679c\u3092\u683c\u7d0d\u3059\u308b\n  ubyte[] decoded;\n\n  //4\u6587\u5b57(4bit)\u5206\u53d6\u308a\u51fa\u3057\u3066\u3001\u914d\u5217\u306b\u8ffd\u52a0\u3059\u308b(\u5207\u308a\u51fa\u3057)\n  foreach (i; (converted.length / 4).iota) {\n    string str = converted[(i * 4)..((i + 1) * 4)];\n    quotients ~= str;\n  }\n\n  //\u96a3\u63a5\u3059\u308b4bit * 2\u306e8bit\u304b\u3089\u30d0\u30a4\u30ca\u30ea\u3092\u5fa9\u5143\n  foreach (i; (quotients.length / 2).iota) {\n    //\u96a3\u63a5\u3059\u308b4bit * 2\u3092\u53d6\u308a\u51fa\u3059\n    string[] buf = quotients[(i * 2)..((i + 1) * 2)];\n\n    //\u6587\u5b57\u5217\u5316\u3055\u308c\u305f\u6570\u5b57\u30922\u9032\u6570\u3068\u3057\u3066\u89e3\u91c8\u3057\u300110\u9032\u6570\u306b\u5909\u63db\u3059\u308b\n    auto bu2 = ((string bs) => bs.parse!ubyte(2));\n    ubyte b0 = bu2(buf[0]),\n          b1 = bu2(buf[1]);\n\n    //bit\u6f14\u7b97\u3057\u3066\u30d0\u30a4\u30ca\u30ea\u306b\u623b\u3059\n    decoded ~= (b0 << 4 ^ b1) & 0xff;\n  }\n\n  /*\n    Base64\u306e\u30c7\u30b3\u30fc\u30c9\u306f\u6570\u591a\u304f\u306e\u5b9f\u88c5\u304c\u5b58\u5728\u3059\u308b\u304c(\u691c\u7d22\u3059\u308b\u3068\u591a\u304f\u306e\u4eba\u304c\u3059\u3067\u306b\u5b9f\u88c5&\u89e3\u8aac\u3092\u3057\u3066\u3044\u307e\u3059)\u3001\u305d\u306e\u591a\u304f\u306f6bit * 4 = 24bit \u3092 8bit * 3\u3068\u3057\u3066\u6271\u3046\u305f\u3081\u306bbit\u6f14\u7b97\u3092\u3057\u3066\u3044\u308b\u3088\u3046\u306a\u6c17\u304c\u3057\u307e\u3059\u3002\n    \u3057\u304b\u3057\u3001\u96a3\u63a5\u3059\u308b4bit * 2\u304b\u3089\u8a08\u7b97\u3059\u308b\u65b9\u6cd5\u3092\u7528\u3044\u308c\u3070\u30016bit * 4\u3068\u3059\u308b\u305f\u3081\u306b`quotients` % 4(\u3053\u306e\u30b3\u30fc\u30c9\u306equotients\u306b\u76f8\u5f53\u3059\u308b\u3082\u306e)\u3092\u5225\u306b\u8003\u3048\u308b\u5fc5\u8981\u304c\u306a\u304f\u306a\u308a\u307e\u3059(\u305f\u3076\u3093... \u81ea\u4fe1\u306f\u306a\u3044\u3067\u3059\u3051\u3069)\u3002\n  */\n\n  return decoded;\n}\n```\n", "tags": ["D\u8a00\u8a9e", "D\u8a00\u8a9eLisp", "dlang"]}