{"context": " More than 1 year has passed since last update.\n\n\u4eca\u56de\u3084\u308b\u3053\u3068\n\u3069\u3046\u3082\u3067\u3059\u3002@akachochin\u3067\u3059\u3002\u524d\u56de\u304b\u3089\u306f\u30841\u30f5\u6708\u8fd1\u304f\u304c\u7acb\u3061\u307e\u3057\u305f\u3002\u306a\u304b\u306a\u304b\u6642\u9593\u304c\u53d6\u308c\u305a\u3067\u3057\u305f\u304c\u3001\u4ed5\u4e8b\u3082\u843d\u3061\u7740\u304d\u59cb\u3081\u3088\u3046\u3084\u304f\u5c11\u3057\u6642\u9593\u304c\u3068\u308c\u308b\u3088\u3046\u306b\u306a\u3063\u3066\u304d\u307e\u3057\u305f\u3002\n\u5fd8\u5e74\u4f1a\u3082\u59cb\u307e\u308b\u3053\u306e\u6642\u671f\u3001\u4ed5\u4e8b\u304c\u843d\u3061\u7740\u304b\u306a\u3044\u3068\u9152\u98f2\u307f\u3068\u3057\u3066\u306f\u56f0\u308a\u307e\u3059\u3002\n\u9591\u8a71\u4f11\u984c\u3002\n\u4eca\u56de\u306f\u8907\u6570\u30da\u30fc\u30b8\u3092\u5272\u308a\u5f53\u3066\u308b\u305f\u3081\u306e\u5185\u90e8\u95a2\u6570\u4e8c\u3064\u3092\u898b\u305f\u3044\u3068\u601d\u3044\u307e\u3059\u3002\n\n__rmqueue_smallest()\u3068__rmqueue_fallback()\n\u30c7\u30d5\u30a9\u30eb\u30c8\u3067\u3001__rmqueue_smallest()\u304c\u547c\u3070\u308c\u307e\u3059\u3002\n\nmm/page_alloc.c\n/*\n * Go through the free lists for the given migratetype and remove\n * the smallest available page from the freelists\n */\nstatic inline\nstruct page *__rmqueue_smallest(struct zone *zone, unsigned int order,\n            int migratetype)\n{\n  unsigned int current_order;\n  struct free_area *area;\n  struct page *page;\n\n  /* Find a page of the appropriate size in the preferred list */\n  for (current_order = order; current_order < MAX_ORDER; ++current_order) {\n    area = &(zone->free_area[current_order]);\n    if (list_empty(&area->free_list[migratetype]))\n      continue;\n\n    page = list_entry(area->free_list[migratetype].next,\n              struct page, lru);\n    list_del(&page->lru);\n    rmv_page_order(page);\n    area->nr_free--;\n    expand(zone, page, order, current_order, area, migratetype);\n    return page; \n  }\n\n  return NULL;\n}\n\n\n\u601d\u3044\u51fa\u3057\u3066\u307b\u3057\u3044\u3067\u3059\u304c\u3001\u9023\u7d9a\u3057\u305f\u30da\u30fc\u30b8\u3068\u8a00\u3063\u3066\u30823\u30da\u30fc\u30b8\u3068\u304b7\u30da\u30fc\u30b8\u306e\u3088\u3046\u306a\u201d\u4e2d\u9014\u534a\u7aef\u306a\u201d\u30da\u30fc\u30b8\u3092\u5272\u308a\u5f53\u3066\u308b\u306e\u3067\u306f\u306a\u304f\u30012\u306e\u3079\u304d\u4e57\u306e\u8907\u6570\u30da\u30fc\u30b8\u3092\u5272\u5f53\u307e\u3059\u3002\norder\u306flog2Page(2\u306eorder\u4e58)\u3067\u3059\u3002\nzone->free_area[current_order]\u306b\u306f\u30012\u306e\u3079\u304d\u4e57\u306e\u9023\u7d9a\u3057\u305f\u30da\u30fc\u30b8\u3092\u793a\u3059area\u304c\u683c\u7d0d\u3055\u308c\u3066\u3044\u307e\u3059\u3002\narea\u306f\u30ad\u30e5\u30fc\u3092\u6301\u3061\u3001\u305d\u306e\u4e2d\u306b\u4f55\u306e\u30a8\u30f3\u30c8\u30ea\u304c\u306a\u3051\u308c\u3070\u3001\u305d\u306eorder\u306b\u304a\u3051\u308b\u9023\u7d9a\u3057\u305f\u30da\u30fc\u30b8\u306f\u306a\u3044\u306e\u3067\u3001\u6b21\u306b\u9032\u307f\u307e\u3059\u3002\n\u4f8b\u3048\u3070order = 2\u306e\u5834\u5408\u30012^2 = 4\u30da\u30fc\u30b8\u5206\u306e\u9023\u7d9a\u3057\u305f\u30da\u30fc\u30b8\u3092\u63a2\u3059\u3053\u3068\u306b\u306a\u308a\u307e\u3059\u3002\n\nrmv_page_order\n\u3055\u3066\u3001\u9023\u7d9a\u3057\u305f\u30da\u30fc\u30b8\u3092\u898b\u3064\u3051\u3089\u308c\u305f\u5834\u5408\u3001rmv_page_order\u304c\u547c\u3070\u308c\u307e\u3059\u3002\n\nmm/page_alloc.c\nstatic inline void rmv_page_order(struct page *page)\n{\n  __ClearPageBuddy(page);\n  set_page_private(page, 0);\n}\n\n\n\ninclude/linux/mm.h\n#define PAGE_BUDDY_MAPCOUNT_VALUE (-128)\n/* \u7565 */\n/*\n * PageBuddy() indicate that the page is free and in the buddy system\n * (see mm/page_alloc.c).\n *\n * PAGE_BUDDY_MAPCOUNT_VALUE must be <= -2 but better not too close to\n * -2 so that an underflow of the page_mapcount() won't be mistaken\n * for a genuine PAGE_BUDDY_MAPCOUNT_VALUE. -128 can be created very\n * efficiently by most CPU architectures.\n */\n/* \u7565 */\nstatic inline void __SetPageBuddy(struct page *page)\n{\n  VM_BUG_ON_PAGE(atomic_read(&page->_mapcount) != -1, page);\n  atomic_set(&page->_mapcount, PAGE_BUDDY_MAPCOUNT_VALUE);\n}\n\nstatic inline void __ClearPageBuddy(struct page *page)\n{\n  VM_BUG_ON_PAGE(!PageBuddy(page), page);\n  atomic_set(&page->_mapcount, -1);\n}\n\n\n\u304a\u305d\u3089\u304f\u3001_mapcount\u304c\u7279\u6b8a\u306a\u5024\u3067\u3042\u308b\u3053\u3068\u3092\u3082\u3063\u3066\u3001\u8a72\u5f53\u30da\u30fc\u30b8\u304cBuddy(\u7d44)\u306b\u914d\u7f6e\u3055\u308c\u3066\u3044\u308b\u304b\u3092\u5224\u5225\u3067\u304d\u308b\u306e\u3060\u3068\u63a8\u5b9a\u3067\u304d\u307e\u3059\u3002\n\u305d\u3057\u3066\u3001Buddy\u304b\u3089\u5916\u3055\u308c\u305f\u306e\u3067\u3001_mapcount\u306e\u5024\u3092\u5909\u66f4\u3067\u304d\u308b\u3068\u3044\u3046\u3053\u3068\u3067\u3057\u3087\u3046\u3002\n\nexpand\nexpand()\u306f\u300c\u6b32\u3057\u3044\u9023\u7d9a\u30da\u30fc\u30b8\u3088\u308a\u3082\u5927\u304d\u306a\u9023\u7d9a\u30da\u30fc\u30b8\u3092\u7372\u5f97\u3057\u305f\u5834\u5408\u3001\u305d\u308c\u3092\u5206\u5272\u3057\u3066\u5fc5\u8981\u306a\u7b87\u6240\u306e\u307f\u3092\u53d6\u5f97\u3001\u6b8b\u308a\u306e\u7b87\u6240\u306b\u3064\u3044\u3066\u306f\u4ed6\u306eorder\u306efree_list\u306b\u5272\u308a\u5f53\u3066\u308b\u3002\u300d\u95a2\u6570\u3067\u3059\u3002\n\nmm/page_alloc.c\nstatic inline void expand(struct zone *zone, struct page *page,\n  int low, int high, struct free_area *area,\n  int migratetype)\n{\n  unsigned long size = 1 << high;\n\n  while (high > low) {\n    area--;\n    high--;\n    size >>= 1;\n/* \u30c7\u30d0\u30c3\u30b0\u30b3\u30fc\u30c9\u306a\u306e\u3067\u3001\u7565 */\n    list_add(&page[size].lru, &area->free_list[migratetype]);\n    area->nr_free++;\n    set_page_order(&page[size], high);\n  }\n}\n\n\nlow\u306b\u306f\u672c\u6765\u8981\u6c42\u3055\u308c\u3066\u3044\u305forder\u3001high\u306b\u306f\u7a7a\u304d\u30da\u30fc\u30b8\u304c\u5b58\u5728\u3057\u305forder\u304c\u6e21\u3055\u308c\u308b\u3002\n\u4f8b\u3048\u3070\u3001low=2(\u8981\u6c42\u3055\u308c\u305f\u30da\u30fc\u30b8\u30b5\u30a4\u30ba\u304c2^2)\u3001\u5b9f\u969b\u306b\u7a7a\u304d\u30da\u30fc\u30b8\u304c\u898b\u3064\u304b\u3063\u305forder\u304c4\u3067\u3042\u308b\u5834\u5408\u3092\u8003\u3048\u3066\u307f\u307e\u3057\u3087\u3046\u3002\n\u3053\u306e\u5834\u5408\u3001\u9023\u7d9a\u3057\u305f4\u30da\u30fc\u30b8\u3092\u7ba1\u7406\u3059\u308bLRU\u3001\u9023\u7d9a\u3057\u305f8\u30da\u30fc\u30b8\u3092\u7ba1\u7406\u3059\u308bLRU\u306e\u4e2d\u306b\u7a7a\u304d\u304c\u306a\u304f\u300116\u30da\u30fc\u30b8\u3092\u7ba1\u7406\u3059\u308b\u305f\u3081\u306eLRU\u5185\u306b\u3088\u3046\u3084\u3063\u3068\u7a7a\u304d\u30da\u30fc\u30b8\u304c\u3042\u308b\u3068\u3044\u3046\u72b6\u6cc1\u306b\u306a\u308a\u307e\u3059\u3002\nsize = 16  area(order=4\u306efree_area)   high = 4\nsize = 8 area(order=3\u306efree_area) high=3\nlist_add\u306b\u306f\u5272\u308a\u5f53\u3066\u305f\u30da\u30fc\u30b8\u306e8\u30da\u30fc\u30b8\u5148\u306e\u30da\u30fc\u30b8\u3092order3\u306earea->free_list\u306b\u3064\u306a\u304e\u307e\u3059\u3002\u3064\u307e\u308a\u9023\u7d9a\u3057\u305f16\u30da\u30fc\u30b8\u306e\u5f8c\u534a8\u30da\u30fc\u30b8\u3092order3\u306earea->free_list\u306b\u3064\u306a\u304e\u307e\u3059\u3002\nsize = 4 area(order=2\u306efree_area) high=2\nlist_add\u306b\u306f\u5272\u308a\u5f53\u3066\u305f\u30da\u30fc\u30b8\u306e8\u30da\u30fc\u30b8\u5148\u306e\u30da\u30fc\u30b8\u3092order3\u306earea->free_list\u306b\u3064\u306a\u304e\u307e\u3059\u3002\u3064\u307e\u308a\u5148\u306b\u5206\u5272\u3057\u305f\u524d\u534a\u306e8\u30da\u30fc\u30b8\u306e\u5f8c\u534a4\u30da\u30fc\u30b8\u3092order2\u306earea->free_list\u306b\u3064\u306a\u304e\u307e\u3059\u3002\n\nzone->free_area\u306b\u3064\u3044\u3066\n\u3053\u3053\u307e\u3067\u306e\u3068\u3053\u308d\u3067\u3001\u7a7a\u3044\u305f\u9023\u7d9a\u30da\u30fc\u30b8\u7fa4\u3092\u7ba1\u7406\u3059\u308b\u305f\u3081\u306earea\u304c\u51fa\u3066\u304d\u307e\u3057\u305f\u3002\n\u305d\u306e\u5b9a\u7fa9\u306f\u4ee5\u4e0b\u306e\u901a\u308a\u3067\u3059\u3002\n\ninclude/linux/mmzone.h\n/* x86\u306e\u5834\u5408\u3001\u7279\u306bCONFIG_FORCE_MAX_ZONEORDER\u3067\u3057\u3066\u3044\u306a\u3044\u5834\u5408\u306f\u4ee5\u4e0b\u306e\u5024 */\n#define MAX_ORDER 11\nstruct free_area {\n  struct list_head  free_list[MIGRATE_TYPES];\n  unsigned long   nr_free;\n};\n/* \u7565 */\nstruct zone {\n/* \u7565 */\n  struct free_area  free_area[MAX_ORDER];\n/* \u7565 */\n}\n\n\n\u4e0a\u306b\u5f15\u7528\u3057\u305f\u5b9a\u7fa9\u304b\u3089\u3001\u4ee5\u4e0b\u306e\u4e8b\u304c\u3042\u308a\u307e\u3059\u3002\n* zone\u306ffree_area\u3092MAX_ORDER\u500b\u6301\u3064\n* free_area\u306fMIGRATE_TYPES\u500b\u306e\u30da\u30fc\u30b8\u30ad\u30e5\u30fc\u3092\u6301\u3064\n\u3055\u3066\u3001MAX_ORDER\u306f\u3079\u304d\u4e57\u306b\u95a2\u3059\u308b\u8a71(2^0,2^1,2^2...\u500b\u306e\u9023\u7d9a\u30da\u30fc\u30b8)\u3060\u3068\u308f\u304b\u308a\u307e\u3059\u304c\u3001MIGRATE_TYPES\u3068\u306f\u306a\u3093\u3067\u3057\u3087\u3046\u304b\u3002\n\nMIGRATE_TYPES\u3068\u306f...\nMIGRATE_TYPES\u3092\u63a2\u3059\u3068\u3001\u4ee5\u4e0b\u306e\u30d8\u30c3\u30c0\u306b\u884c\u304d\u7740\u304d\u307e\u3059\u3002\n\ninclude/linux/mmzone.h\n#define for_each_migratetype_order(order, type) \\\n  for (order = 0; order < MAX_ORDER; order++) \\\n    for (type = 0; type < MIGRATE_TYPES; type++)\n\nenum {\n  MIGRATE_UNMOVABLE,\n  MIGRATE_RECLAIMABLE,\n  MIGRATE_MOVABLE,\n  MIGRATE_PCPTYPES, /* the number of types on the pcp lists */\n  MIGRATE_RESERVE = MIGRATE_PCPTYPES,\n#ifdef CONFIG_CMA\n  /*\n   * MIGRATE_CMA migration type is designed to mimic the way\n   * ZONE_MOVABLE works.  Only movable pages can be allocated\n   * from MIGRATE_CMA pageblocks and page allocator never\n   * implicitly change migration type of MIGRATE_CMA pageblock.\n   *\n   * The way to use it is to change migratetype of a range of\n   * pageblocks to MIGRATE_CMA which can be done by\n   * __free_pageblock_cma() function.  What is important though\n   * is that a range of pageblocks must be aligned to\n   * MAX_ORDER_NR_PAGES should biggest page be bigger then\n   * a single pageblock.\n   */\n  MIGRATE_CMA,\n#endif\n#ifdef CONFIG_MEMORY_ISOLATION\n  MIGRATE_ISOLATE,  /* can't allocate from here */\n#endif\n  MIGRATE_TYPES\n};\n\n\n\u3055\u3089\u306b\u8abf\u3079\u308b\u3068\u3001\u4ee5\u4e0b\u306eDocumentation\u306b\u884c\u304d\u7740\u304d\u307e\u3059\u3002\nPage migration allows the moving of the physical location of pages between\nnodes in a numa system while the process is running. This means that the\nvirtual addresses that the process sees do not change. However, the system rearranges the physical location of those pages.\n\nThe main intend of page migration is to reduce the latency of memory access by moving pages near to the processor where the process accessing that memory is running.\n\n\u76f8\u5f53\u306b\u610f\u8a33\u3059\u308b\u3068...\n\n\u30da\u30fc\u30b8\u30de\u30a4\u30b0\u30ec\u30fc\u30b7\u30e7\u30f3\u306b\u3088\u3063\u3066\u3001\u30d7\u30ed\u30bb\u30b9\u3092\u52d5\u304b\u3057\u3064\u3064NUMA\u30b7\u30b9\u30c6\u30e0\u306e\u30ce\u30fc\u30c9\u9593\u3067\u30da\u30fc\u30b8\u306e\u7269\u7406\u7684\u306a\u914d\u7f6e\u3092\u52d5\u304b\u3059\u3053\u3068\u304c\u3067\u304d\u308b\u3002\u3053\u308c\u306f\u30d7\u30ed\u30bb\u30b9\u304b\u3089\u898b\u3048\u308b\u4eee\u60f3\u30a2\u30c9\u30ec\u30b9\u304c\u5909\u308f\u3089\u305a(\u305d\u308c\u3068\u7d10\u3065\u304f\u7269\u7406\u30a2\u30c9\u30ec\u30b9\u304c\u5909\u308f\u308b)\u3053\u3068\u3092\u610f\u5473\u3059\u308b\u3002\n\u30da\u30fc\u30b8\u30de\u30a4\u30b0\u30ec\u30fc\u30b7\u30e7\u30f3\u304c\u4e3b\u306b\u610f\u56f3\u3059\u308b\u306e\u306f\u30e1\u30e2\u30ea\u30a2\u30af\u30bb\u30b9\u306e\u9045\u5ef6\u3092\u6e1b\u3089\u3059\u3053\u3068\u3067\u3042\u308a\u3001\u305d\u308c\u306f\u8a72\u5f53\u30da\u30fc\u30b8\u306b\u30a2\u30af\u30bb\u30b9\u3057\u3066\u3044\u308b\u30d7\u30ed\u30bb\u30b9\u304c\u52d5\u4f5c\u3057\u3066\u3044\u308bCPU\u304b\u3089\u8fd1\u3044\u30e1\u30e2\u30ea\u306b\u30da\u30fc\u30b8\u3092\u79fb\u3059\u3053\u3068\u306b\u3088\u3063\u3066\u884c\u3046\u3002\n\n\u3082\u3046\u5c11\u3057\u8a73\u3057\u304f\u77e5\u308a\u305f\u3051\u308c\u3070\u3001\u4ee5\u4e0b\u306e\u30da\u30fc\u30b8\u3082\u53c2\u8003\u306b\u306a\u308b\u3068\u601d\u3044\u307e\u3059\u3002\nhttp://lwn.net/Articles/157066/\nhttp://gihyo.jp/dev/serial/01/linuxcon_basic/0005\n\u3061\u306a\u307f\u306b\u3001__rmqueue_fallback()\u306f\u3001\u6307\u5b9a\u3057\u305f\u30de\u30a4\u30b0\u30ec\u30fc\u30b7\u30e7\u30f3\u30bf\u30a4\u30d7\u306b\u9023\u7d9a\u3057\u305f\u30da\u30fc\u30b8\u304c\u306a\u3044\u5834\u5408\u3001\u30de\u30a4\u30b0\u30ec\u30fc\u30b7\u30e7\u30f3\u30bf\u30a4\u30d7\u304c\u7570\u306a\u308b\u9023\u7d9a\u30da\u30fc\u30b8\u304b\u3089\u30da\u30fc\u30b8\u3092\u79fb\u3057\u3066\u304d\u3066\u9801\u5272\u308a\u5f53\u3066\u3092\u884c\u3044\u307e\u3059\u3002\n\nmm/page_alloc.c\nstatic inline struct page *\n__rmqueue_fallback(struct zone *zone, int order, int start_migratetype)\n{\n  /* Find the largest possible block of pages in the other */\n  for (current_order = MAX_ORDER-1; current_order >= order;\n            --current_order) {\n    for (i = 0;; i++) {\n      migratetype = fallbacks[start_migratetype][i];\n\n      if (list_empty(&area->free_list[migratetype]))\n        continue;\n\n\n\u3068\u3053\u308d\u304c\u3001\u300c\u30de\u30a4\u30b0\u30ec\u30fc\u30b7\u30e7\u30f3\u30bf\u30a4\u30d7\u306f\u306a\u3093\u3067\u3082\u826f\u3044\u300d\u3068\u3044\u3046\u308f\u3051\u306b\u306f\u3044\u304b\u306a\u3044\u3088\u3046\u3067\u3059\u3002\n\u5236\u7d04\u304c\u3042\u308a\u3001\u305d\u308c\u3092\u898f\u5b9a\u3059\u308b\u306e\u304cfallback\u30c6\u30fc\u30d6\u30eb\u3067\u3059\u3002\n\nmm/page_alloc.c\n/*\n * This array describes the order lists are fallen back to when\n * the free lists for the desirable migrate type are depleted\n */\nstatic int fallbacks[MIGRATE_TYPES][4] = {\n  [MIGRATE_UNMOVABLE]   = { MIGRATE_RECLAIMABLE, MIGRATE_MOVABLE,     MIGRATE_RESERVE },\n  [MIGRATE_RECLAIMABLE] = { MIGRATE_UNMOVABLE,   MIGRATE_MOVABLE,     MIGRATE_RESERVE },\n#ifdef CONFIG_CMA\n  [MIGRATE_MOVABLE]     = { MIGRATE_CMA,         MIGRATE_RECLAIMABLE, MIGRATE_UNMOVABLE, MIGRAT     E_RESERVE },\n  [MIGRATE_CMA]         = { MIGRATE_RESERVE }, /* Never used */\n#else\n  [MIGRATE_MOVABLE]     = { MIGRATE_RECLAIMABLE, MIGRATE_UNMOVABLE,   MIGRATE_RESERVE },\n#endif\n  [MIGRATE_RESERVE]     = { MIGRATE_RESERVE }, /* Never used */\n#ifdef CONFIG_MEMORY_ISOLATION\n  [MIGRATE_ISOLATE]     = { MIGRATE_RESERVE }, /* Never used */\n#endif\n};\n\n\n\u4f8b\u3048\u3070\u3001MIGRATE_UNMOVABLE\u306e\u30da\u30fc\u30b8\u3092\u8abf\u9054\u3057\u305f\u3044\u304c\u30da\u30fc\u30b8\u304c\u306a\u3044\u5834\u5408\u3001MIGRATE_RECLAIMABLE,MIGRATE_MOVABLE,MIGRATE_RESERVE\u306e\u3044\u305a\u308c\u304b\u304b\u3089\u8abf\u9054\u3059\u308b\u3053\u3068\u306b\u306a\u308a\u307e\u3059\u3002\n\n\u6b21\u56de\u3084\u308a\u305f\u3044\u3053\u3068\n\u3060\u3044\u3076\u524d\u306b\u306a\u308a\u307e\u3059\u304c\u3001Linux(x86-32bit)\u306e\u30da\u30fc\u30b8\u30d5\u30a9\u30eb\u30c8\u30cf\u30f3\u30c9\u30e9\u3092\u8aad\u3093\u3067\u307f\u308b(\u305d\u306e5)\u3092\u66f8\u304d\u307e\u3057\u305f\u3002\n\u305d\u306e6\u304b\u3089\u305d\u306e9\u3067do_linear_fault()\u3068do_anonymous_page()\u3092\u8aad\u307f\u307e\u3057\u305f\u3002\n\u6b21\u56de\u306f\u3001do_nonlinear_fault()\u3092\u898b\u305f\u3044\u3068\u601d\u3044\u307e\u3059\u3002\n## \u4eca\u56de\u3084\u308b\u3053\u3068\n\n\u3069\u3046\u3082\u3067\u3059\u3002@akachochin\u3067\u3059\u3002[\u524d\u56de](http://qiita.com/akachochin/items/a2ad7770b30c8841c064)\u304b\u3089\u306f\u30841\u30f5\u6708\u8fd1\u304f\u304c\u7acb\u3061\u307e\u3057\u305f\u3002\u306a\u304b\u306a\u304b\u6642\u9593\u304c\u53d6\u308c\u305a\u3067\u3057\u305f\u304c\u3001\u4ed5\u4e8b\u3082\u843d\u3061\u7740\u304d\u59cb\u3081\u3088\u3046\u3084\u304f\u5c11\u3057\u6642\u9593\u304c\u3068\u308c\u308b\u3088\u3046\u306b\u306a\u3063\u3066\u304d\u307e\u3057\u305f\u3002\n\u5fd8\u5e74\u4f1a\u3082\u59cb\u307e\u308b\u3053\u306e\u6642\u671f\u3001\u4ed5\u4e8b\u304c\u843d\u3061\u7740\u304b\u306a\u3044\u3068\u9152\u98f2\u307f\u3068\u3057\u3066\u306f\u56f0\u308a\u307e\u3059\u3002\n\u9591\u8a71\u4f11\u984c\u3002\n\u4eca\u56de\u306f\u8907\u6570\u30da\u30fc\u30b8\u3092\u5272\u308a\u5f53\u3066\u308b\u305f\u3081\u306e\u5185\u90e8\u95a2\u6570\u4e8c\u3064\u3092\u898b\u305f\u3044\u3068\u601d\u3044\u307e\u3059\u3002\n\n## \\_\\_rmqueue_smallest()\u3068\\_\\_rmqueue_fallback()\n\n\u30c7\u30d5\u30a9\u30eb\u30c8\u3067\u3001\\_\\_rmqueue_smallest()\u304c\u547c\u3070\u308c\u307e\u3059\u3002\n\n```c:mm/page_alloc.c\n/*\n * Go through the free lists for the given migratetype and remove\n * the smallest available page from the freelists\n */\nstatic inline\nstruct page *__rmqueue_smallest(struct zone *zone, unsigned int order,\n            int migratetype)\n{\n  unsigned int current_order;\n  struct free_area *area;\n  struct page *page;\n\n  /* Find a page of the appropriate size in the preferred list */\n  for (current_order = order; current_order < MAX_ORDER; ++current_order) {\n    area = &(zone->free_area[current_order]);\n    if (list_empty(&area->free_list[migratetype]))\n      continue;\n\n    page = list_entry(area->free_list[migratetype].next,\n              struct page, lru);\n    list_del(&page->lru);\n    rmv_page_order(page);\n    area->nr_free--;\n    expand(zone, page, order, current_order, area, migratetype);\n    return page; \n  }\n\n  return NULL;\n}\n```\n\n\u601d\u3044\u51fa\u3057\u3066\u307b\u3057\u3044\u3067\u3059\u304c\u3001\u9023\u7d9a\u3057\u305f\u30da\u30fc\u30b8\u3068\u8a00\u3063\u3066\u30823\u30da\u30fc\u30b8\u3068\u304b7\u30da\u30fc\u30b8\u306e\u3088\u3046\u306a\u201d\u4e2d\u9014\u534a\u7aef\u306a\u201d\u30da\u30fc\u30b8\u3092\u5272\u308a\u5f53\u3066\u308b\u306e\u3067\u306f\u306a\u304f\u30012\u306e\u3079\u304d\u4e57\u306e\u8907\u6570\u30da\u30fc\u30b8\u3092\u5272\u5f53\u307e\u3059\u3002\norder\u306flog2Page(2\u306eorder\u4e58)\u3067\u3059\u3002\n\nzone->free_area[current_order]\u306b\u306f\u30012\u306e\u3079\u304d\u4e57\u306e\u9023\u7d9a\u3057\u305f\u30da\u30fc\u30b8\u3092\u793a\u3059area\u304c\u683c\u7d0d\u3055\u308c\u3066\u3044\u307e\u3059\u3002\narea\u306f\u30ad\u30e5\u30fc\u3092\u6301\u3061\u3001\u305d\u306e\u4e2d\u306b\u4f55\u306e\u30a8\u30f3\u30c8\u30ea\u304c\u306a\u3051\u308c\u3070\u3001\u305d\u306eorder\u306b\u304a\u3051\u308b\u9023\u7d9a\u3057\u305f\u30da\u30fc\u30b8\u306f\u306a\u3044\u306e\u3067\u3001\u6b21\u306b\u9032\u307f\u307e\u3059\u3002\n\u4f8b\u3048\u3070order = 2\u306e\u5834\u5408\u30012^2 = 4\u30da\u30fc\u30b8\u5206\u306e\u9023\u7d9a\u3057\u305f\u30da\u30fc\u30b8\u3092\u63a2\u3059\u3053\u3068\u306b\u306a\u308a\u307e\u3059\u3002\n\n## rmv_page_order\n\n\u3055\u3066\u3001\u9023\u7d9a\u3057\u305f\u30da\u30fc\u30b8\u3092\u898b\u3064\u3051\u3089\u308c\u305f\u5834\u5408\u3001rmv_page_order\u304c\u547c\u3070\u308c\u307e\u3059\u3002\n\n```c:mm/page_alloc.c\nstatic inline void rmv_page_order(struct page *page)\n{\n  __ClearPageBuddy(page);\n  set_page_private(page, 0);\n}\n```\n\n```c:include/linux/mm.h\n#define PAGE_BUDDY_MAPCOUNT_VALUE (-128)\n/* \u7565 */\n/*\n * PageBuddy() indicate that the page is free and in the buddy system\n * (see mm/page_alloc.c).\n *\n * PAGE_BUDDY_MAPCOUNT_VALUE must be <= -2 but better not too close to\n * -2 so that an underflow of the page_mapcount() won't be mistaken\n * for a genuine PAGE_BUDDY_MAPCOUNT_VALUE. -128 can be created very\n * efficiently by most CPU architectures.\n */\n/* \u7565 */\nstatic inline void __SetPageBuddy(struct page *page)\n{\n  VM_BUG_ON_PAGE(atomic_read(&page->_mapcount) != -1, page);\n  atomic_set(&page->_mapcount, PAGE_BUDDY_MAPCOUNT_VALUE);\n}\n\nstatic inline void __ClearPageBuddy(struct page *page)\n{\n  VM_BUG_ON_PAGE(!PageBuddy(page), page);\n  atomic_set(&page->_mapcount, -1);\n}\n```\n\n\u304a\u305d\u3089\u304f\u3001\\_mapcount\u304c\u7279\u6b8a\u306a\u5024\u3067\u3042\u308b\u3053\u3068\u3092\u3082\u3063\u3066\u3001\u8a72\u5f53\u30da\u30fc\u30b8\u304cBuddy(\u7d44)\u306b\u914d\u7f6e\u3055\u308c\u3066\u3044\u308b\u304b\u3092\u5224\u5225\u3067\u304d\u308b\u306e\u3060\u3068\u63a8\u5b9a\u3067\u304d\u307e\u3059\u3002\n\u305d\u3057\u3066\u3001Buddy\u304b\u3089\u5916\u3055\u308c\u305f\u306e\u3067\u3001\\_mapcount\u306e\u5024\u3092\u5909\u66f4\u3067\u304d\u308b\u3068\u3044\u3046\u3053\u3068\u3067\u3057\u3087\u3046\u3002\n\n## expand\n\nexpand()\u306f\u300c\u6b32\u3057\u3044\u9023\u7d9a\u30da\u30fc\u30b8\u3088\u308a\u3082\u5927\u304d\u306a\u9023\u7d9a\u30da\u30fc\u30b8\u3092\u7372\u5f97\u3057\u305f\u5834\u5408\u3001\u305d\u308c\u3092\u5206\u5272\u3057\u3066\u5fc5\u8981\u306a\u7b87\u6240\u306e\u307f\u3092\u53d6\u5f97\u3001\u6b8b\u308a\u306e\u7b87\u6240\u306b\u3064\u3044\u3066\u306f\u4ed6\u306eorder\u306efree_list\u306b\u5272\u308a\u5f53\u3066\u308b\u3002\u300d\u95a2\u6570\u3067\u3059\u3002\n\n```c:mm/page_alloc.c\nstatic inline void expand(struct zone *zone, struct page *page,\n  int low, int high, struct free_area *area,\n  int migratetype)\n{\n  unsigned long size = 1 << high;\n\n  while (high > low) {\n    area--;\n    high--;\n    size >>= 1;\n/* \u30c7\u30d0\u30c3\u30b0\u30b3\u30fc\u30c9\u306a\u306e\u3067\u3001\u7565 */\n    list_add(&page[size].lru, &area->free_list[migratetype]);\n    area->nr_free++;\n    set_page_order(&page[size], high);\n  }\n}\n```\n\nlow\u306b\u306f\u672c\u6765\u8981\u6c42\u3055\u308c\u3066\u3044\u305forder\u3001high\u306b\u306f\u7a7a\u304d\u30da\u30fc\u30b8\u304c\u5b58\u5728\u3057\u305forder\u304c\u6e21\u3055\u308c\u308b\u3002\n\u4f8b\u3048\u3070\u3001low=2(\u8981\u6c42\u3055\u308c\u305f\u30da\u30fc\u30b8\u30b5\u30a4\u30ba\u304c2^2)\u3001\u5b9f\u969b\u306b\u7a7a\u304d\u30da\u30fc\u30b8\u304c\u898b\u3064\u304b\u3063\u305forder\u304c4\u3067\u3042\u308b\u5834\u5408\u3092\u8003\u3048\u3066\u307f\u307e\u3057\u3087\u3046\u3002\n\u3053\u306e\u5834\u5408\u3001\u9023\u7d9a\u3057\u305f4\u30da\u30fc\u30b8\u3092\u7ba1\u7406\u3059\u308bLRU\u3001\u9023\u7d9a\u3057\u305f8\u30da\u30fc\u30b8\u3092\u7ba1\u7406\u3059\u308bLRU\u306e\u4e2d\u306b\u7a7a\u304d\u304c\u306a\u304f\u300116\u30da\u30fc\u30b8\u3092\u7ba1\u7406\u3059\u308b\u305f\u3081\u306eLRU\u5185\u306b\u3088\u3046\u3084\u3063\u3068\u7a7a\u304d\u30da\u30fc\u30b8\u304c\u3042\u308b\u3068\u3044\u3046\u72b6\u6cc1\u306b\u306a\u308a\u307e\u3059\u3002\n\nsize = 16  area(order=4\u306efree_area)   high = 4\nsize = 8 area(order=3\u306efree_area) high=3\nlist_add\u306b\u306f\u5272\u308a\u5f53\u3066\u305f\u30da\u30fc\u30b8\u306e8\u30da\u30fc\u30b8\u5148\u306e\u30da\u30fc\u30b8\u3092order3\u306earea->free_list\u306b\u3064\u306a\u304e\u307e\u3059\u3002\u3064\u307e\u308a\u9023\u7d9a\u3057\u305f16\u30da\u30fc\u30b8\u306e\u5f8c\u534a8\u30da\u30fc\u30b8\u3092order3\u306earea->free_list\u306b\u3064\u306a\u304e\u307e\u3059\u3002\nsize = 4 area(order=2\u306efree_area) high=2\nlist_add\u306b\u306f\u5272\u308a\u5f53\u3066\u305f\u30da\u30fc\u30b8\u306e8\u30da\u30fc\u30b8\u5148\u306e\u30da\u30fc\u30b8\u3092order3\u306earea->free_list\u306b\u3064\u306a\u304e\u307e\u3059\u3002\u3064\u307e\u308a\u5148\u306b\u5206\u5272\u3057\u305f\u524d\u534a\u306e8\u30da\u30fc\u30b8\u306e\u5f8c\u534a4\u30da\u30fc\u30b8\u3092order2\u306earea->free_list\u306b\u3064\u306a\u304e\u307e\u3059\u3002\n\n## zone->free_area\u306b\u3064\u3044\u3066\n\n\u3053\u3053\u307e\u3067\u306e\u3068\u3053\u308d\u3067\u3001\u7a7a\u3044\u305f\u9023\u7d9a\u30da\u30fc\u30b8\u7fa4\u3092\u7ba1\u7406\u3059\u308b\u305f\u3081\u306earea\u304c\u51fa\u3066\u304d\u307e\u3057\u305f\u3002\n\u305d\u306e\u5b9a\u7fa9\u306f\u4ee5\u4e0b\u306e\u901a\u308a\u3067\u3059\u3002\n\n```c:include/linux/mmzone.h\n/* x86\u306e\u5834\u5408\u3001\u7279\u306bCONFIG_FORCE_MAX_ZONEORDER\u3067\u3057\u3066\u3044\u306a\u3044\u5834\u5408\u306f\u4ee5\u4e0b\u306e\u5024 */\n#define MAX_ORDER 11\nstruct free_area {\n  struct list_head  free_list[MIGRATE_TYPES];\n  unsigned long   nr_free;\n};\n/* \u7565 */\nstruct zone {\n/* \u7565 */\n  struct free_area  free_area[MAX_ORDER];\n/* \u7565 */\n}\n```\n\n\u4e0a\u306b\u5f15\u7528\u3057\u305f\u5b9a\u7fa9\u304b\u3089\u3001\u4ee5\u4e0b\u306e\u4e8b\u304c\u3042\u308a\u307e\u3059\u3002\n* zone\u306ffree_area\u3092MAX_ORDER\u500b\u6301\u3064\n* free_area\u306fMIGRATE_TYPES\u500b\u306e\u30da\u30fc\u30b8\u30ad\u30e5\u30fc\u3092\u6301\u3064\n\n\u3055\u3066\u3001MAX_ORDER\u306f\u3079\u304d\u4e57\u306b\u95a2\u3059\u308b\u8a71(2^0,2^1,2^2...\u500b\u306e\u9023\u7d9a\u30da\u30fc\u30b8)\u3060\u3068\u308f\u304b\u308a\u307e\u3059\u304c\u3001MIGRATE_TYPES\u3068\u306f\u306a\u3093\u3067\u3057\u3087\u3046\u304b\u3002\n\n## MIGRATE_TYPES\u3068\u306f...\n\nMIGRATE_TYPES\u3092\u63a2\u3059\u3068\u3001\u4ee5\u4e0b\u306e\u30d8\u30c3\u30c0\u306b\u884c\u304d\u7740\u304d\u307e\u3059\u3002\n\n```c:include/linux/mmzone.h\n#define for_each_migratetype_order(order, type) \\\n  for (order = 0; order < MAX_ORDER; order++) \\\n    for (type = 0; type < MIGRATE_TYPES; type++)\n\nenum {\n  MIGRATE_UNMOVABLE,\n  MIGRATE_RECLAIMABLE,\n  MIGRATE_MOVABLE,\n  MIGRATE_PCPTYPES, /* the number of types on the pcp lists */\n  MIGRATE_RESERVE = MIGRATE_PCPTYPES,\n#ifdef CONFIG_CMA\n  /*\n   * MIGRATE_CMA migration type is designed to mimic the way\n   * ZONE_MOVABLE works.  Only movable pages can be allocated\n   * from MIGRATE_CMA pageblocks and page allocator never\n   * implicitly change migration type of MIGRATE_CMA pageblock.\n   *\n   * The way to use it is to change migratetype of a range of\n   * pageblocks to MIGRATE_CMA which can be done by\n   * __free_pageblock_cma() function.  What is important though\n   * is that a range of pageblocks must be aligned to\n   * MAX_ORDER_NR_PAGES should biggest page be bigger then\n   * a single pageblock.\n   */\n  MIGRATE_CMA,\n#endif\n#ifdef CONFIG_MEMORY_ISOLATION\n  MIGRATE_ISOLATE,  /* can't allocate from here */\n#endif\n  MIGRATE_TYPES\n};\n```\n\n\u3055\u3089\u306b\u8abf\u3079\u308b\u3068\u3001\u4ee5\u4e0b\u306eDocumentation\u306b\u884c\u304d\u7740\u304d\u307e\u3059\u3002\n\n```Documentation/vm/page_migration\nPage migration allows the moving of the physical location of pages between\nnodes in a numa system while the process is running. This means that the\nvirtual addresses that the process sees do not change. However, the system rearranges the physical location of those pages.\n\nThe main intend of page migration is to reduce the latency of memory access by moving pages near to the processor where the process accessing that memory is running.\n```\n\n\u76f8\u5f53\u306b\u610f\u8a33\u3059\u308b\u3068...\n> \u30da\u30fc\u30b8\u30de\u30a4\u30b0\u30ec\u30fc\u30b7\u30e7\u30f3\u306b\u3088\u3063\u3066\u3001\u30d7\u30ed\u30bb\u30b9\u3092\u52d5\u304b\u3057\u3064\u3064NUMA\u30b7\u30b9\u30c6\u30e0\u306e\u30ce\u30fc\u30c9\u9593\u3067\u30da\u30fc\u30b8\u306e\u7269\u7406\u7684\u306a\u914d\u7f6e\u3092\u52d5\u304b\u3059\u3053\u3068\u304c\u3067\u304d\u308b\u3002\u3053\u308c\u306f\u30d7\u30ed\u30bb\u30b9\u304b\u3089\u898b\u3048\u308b\u4eee\u60f3\u30a2\u30c9\u30ec\u30b9\u304c\u5909\u308f\u3089\u305a(\u305d\u308c\u3068\u7d10\u3065\u304f\u7269\u7406\u30a2\u30c9\u30ec\u30b9\u304c\u5909\u308f\u308b)\u3053\u3068\u3092\u610f\u5473\u3059\u308b\u3002\n> \u30da\u30fc\u30b8\u30de\u30a4\u30b0\u30ec\u30fc\u30b7\u30e7\u30f3\u304c\u4e3b\u306b\u610f\u56f3\u3059\u308b\u306e\u306f\u30e1\u30e2\u30ea\u30a2\u30af\u30bb\u30b9\u306e\u9045\u5ef6\u3092\u6e1b\u3089\u3059\u3053\u3068\u3067\u3042\u308a\u3001\u305d\u308c\u306f\u8a72\u5f53\u30da\u30fc\u30b8\u306b\u30a2\u30af\u30bb\u30b9\u3057\u3066\u3044\u308b\u30d7\u30ed\u30bb\u30b9\u304c\u52d5\u4f5c\u3057\u3066\u3044\u308bCPU\u304b\u3089\u8fd1\u3044\u30e1\u30e2\u30ea\u306b\u30da\u30fc\u30b8\u3092\u79fb\u3059\u3053\u3068\u306b\u3088\u3063\u3066\u884c\u3046\u3002\n\n\u3082\u3046\u5c11\u3057\u8a73\u3057\u304f\u77e5\u308a\u305f\u3051\u308c\u3070\u3001\u4ee5\u4e0b\u306e\u30da\u30fc\u30b8\u3082\u53c2\u8003\u306b\u306a\u308b\u3068\u601d\u3044\u307e\u3059\u3002\n\nhttp://lwn.net/Articles/157066/\nhttp://gihyo.jp/dev/serial/01/linuxcon_basic/0005\n\n\u3061\u306a\u307f\u306b\u3001\\_\\_rmqueue\\_fallback()\u306f\u3001\u6307\u5b9a\u3057\u305f\u30de\u30a4\u30b0\u30ec\u30fc\u30b7\u30e7\u30f3\u30bf\u30a4\u30d7\u306b\u9023\u7d9a\u3057\u305f\u30da\u30fc\u30b8\u304c\u306a\u3044\u5834\u5408\u3001\u30de\u30a4\u30b0\u30ec\u30fc\u30b7\u30e7\u30f3\u30bf\u30a4\u30d7\u304c\u7570\u306a\u308b\u9023\u7d9a\u30da\u30fc\u30b8\u304b\u3089\u30da\u30fc\u30b8\u3092\u79fb\u3057\u3066\u304d\u3066\u9801\u5272\u308a\u5f53\u3066\u3092\u884c\u3044\u307e\u3059\u3002\n\n```c:mm/page_alloc.c\nstatic inline struct page *\n__rmqueue_fallback(struct zone *zone, int order, int start_migratetype)\n{\n  /* Find the largest possible block of pages in the other */\n  for (current_order = MAX_ORDER-1; current_order >= order;\n            --current_order) {\n    for (i = 0;; i++) {\n      migratetype = fallbacks[start_migratetype][i];\n\n      if (list_empty(&area->free_list[migratetype]))\n        continue;\n```\n\n\u3068\u3053\u308d\u304c\u3001\u300c\u30de\u30a4\u30b0\u30ec\u30fc\u30b7\u30e7\u30f3\u30bf\u30a4\u30d7\u306f\u306a\u3093\u3067\u3082\u826f\u3044\u300d\u3068\u3044\u3046\u308f\u3051\u306b\u306f\u3044\u304b\u306a\u3044\u3088\u3046\u3067\u3059\u3002\n\u5236\u7d04\u304c\u3042\u308a\u3001\u305d\u308c\u3092\u898f\u5b9a\u3059\u308b\u306e\u304cfallback\u30c6\u30fc\u30d6\u30eb\u3067\u3059\u3002\n\n```c:mm/page_alloc.c\n/*\n * This array describes the order lists are fallen back to when\n * the free lists for the desirable migrate type are depleted\n */\nstatic int fallbacks[MIGRATE_TYPES][4] = {\n  [MIGRATE_UNMOVABLE]   = { MIGRATE_RECLAIMABLE, MIGRATE_MOVABLE,     MIGRATE_RESERVE },\n  [MIGRATE_RECLAIMABLE] = { MIGRATE_UNMOVABLE,   MIGRATE_MOVABLE,     MIGRATE_RESERVE },\n#ifdef CONFIG_CMA\n  [MIGRATE_MOVABLE]     = { MIGRATE_CMA,         MIGRATE_RECLAIMABLE, MIGRATE_UNMOVABLE, MIGRAT     E_RESERVE },\n  [MIGRATE_CMA]         = { MIGRATE_RESERVE }, /* Never used */\n#else\n  [MIGRATE_MOVABLE]     = { MIGRATE_RECLAIMABLE, MIGRATE_UNMOVABLE,   MIGRATE_RESERVE },\n#endif\n  [MIGRATE_RESERVE]     = { MIGRATE_RESERVE }, /* Never used */\n#ifdef CONFIG_MEMORY_ISOLATION\n  [MIGRATE_ISOLATE]     = { MIGRATE_RESERVE }, /* Never used */\n#endif\n};\n```\n\n\u4f8b\u3048\u3070\u3001MIGRATE_UNMOVABLE\u306e\u30da\u30fc\u30b8\u3092\u8abf\u9054\u3057\u305f\u3044\u304c\u30da\u30fc\u30b8\u304c\u306a\u3044\u5834\u5408\u3001MIGRATE_RECLAIMABLE,MIGRATE_MOVABLE,MIGRATE_RESERVE\u306e\u3044\u305a\u308c\u304b\u304b\u3089\u8abf\u9054\u3059\u308b\u3053\u3068\u306b\u306a\u308a\u307e\u3059\u3002\n\n## \u6b21\u56de\u3084\u308a\u305f\u3044\u3053\u3068\n\n\u3060\u3044\u3076\u524d\u306b\u306a\u308a\u307e\u3059\u304c\u3001[Linux(x86-32bit)\u306e\u30da\u30fc\u30b8\u30d5\u30a9\u30eb\u30c8\u30cf\u30f3\u30c9\u30e9\u3092\u8aad\u3093\u3067\u307f\u308b(\u305d\u306e5)](http://qiita.com/akachochin/items/e7ffdca00c00d322022a)\u3092\u66f8\u304d\u307e\u3057\u305f\u3002\n\u305d\u306e6\u304b\u3089\u305d\u306e9\u3067do_linear_fault()\u3068do_anonymous_page()\u3092\u8aad\u307f\u307e\u3057\u305f\u3002\n\u6b21\u56de\u306f\u3001do_nonlinear_fault()\u3092\u898b\u305f\u3044\u3068\u601d\u3044\u307e\u3059\u3002\n\n", "tags": ["Linux", "kernel", "kernelvm", "\u4eee\u60f3\u8a18\u61b6"]}