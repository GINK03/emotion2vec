{"tags": ["Redis", "Python"], "context": " \u3053\u306e\u8a18\u4e8b\u306f\u6700\u7d42\u66f4\u65b0\u65e5\u304b\u30891\u5e74\u4ee5\u4e0a\u304c\u7d4c\u904e\u3057\u3066\u3044\u307e\u3059\u3002\n\n\u767a\u7aef\n\u30b5\u30fc\u30d3\u30b9\u69cb\u7bc9\u6642, \u76f8\u4e92\u6392\u4ed6\u3067\u30ed\u30c3\u30af\u3092\u7372\u5f97\u3057\u305f\u3044\u304c, RDS \u3092\u4f7f\u3046\u307b\u3069\u3067\u3082\u7121\u3044\u305f\u3081 Redis \u3092\u4f7f\u7528\u3057\u305f\u3044.\nPython \u3067 SETNX \u2013 Redis \u306e \"Design pattern: Locking with SETNX\" \u3092\u5b9f\u88c5\u3057\u3066\u3044\u308b\u30e9\u30a4\u30d6\u30e9\u30ea\u3092\u63a2\u3057\u305f\u304c, \u3055\u3055\u3063\u3068\u63a2\u3057\u305f\u611f\u3058\u898b\u5f53\u305f\u3089\u306a\u304b\u3063\u305f\u305f\u3081, \u5b9f\u88c5\u3057\u3066\u307f\u305f.\n\u306a\u304a, SETNX \u2013 Redis \u306e\u65e5\u672c\u8a9e\u8a33\u306f \u6587\u5b57\u5217\u578b - redis 2.0.3 documentation \u3092\u53c2\u7167\u306e\u3053\u3068.\n\n\u5b9f\u88c5\n\nSource Code\n\nmutex.py\nfrom datetime import datetime\nimport time\nfrom functools import wraps\n\nfrom .exception import (DuplicateLockError,\n                        HasNotLockError,\n                        ExpiredLockError,\n                        SetnxError,\n                        LockError)\n\n\nclass Mutex(object):\n    def __init__(self, client, key,\n                 expire=10,\n                 retry_count=6, # retry_count * retry_sleep_sec = \u6700\u5927\u5f85\u3061\u6642\u9593\n                 retry_setnx_count=100,\n                 retry_sleep_sec=0.25):\n        self._lock = None\n        self._r = client\n        self._key = key\n        self._expire = expire\n        self._retry_count = retry_count\n        self._retry_setnx_count = retry_setnx_count\n        self._retry_sleep_sec = retry_sleep_sec\n\n    def _get_now(self):\n        return float(datetime.now().strftime('%s.%f'))\n\n    def lock(self):\n        if self._lock:\n            raise DuplicateLockError(self._key)\n        self._do_lock()\n\n    def _do_lock(self):\n        for n in xrange(0, self._retry_count):\n            is_set, old_expire = self._setnx()\n            if is_set:\n                self._lock = self._get_now()\n                return\n\n            if self._need_retry(old_expire):\n                continue\n\n            if not self._need_retry(self._getset()):\n                self._lock = self._get_now()\n                return \n\n        raise LockError(self._key)\n\n    def _setnx(self):\n        for n in xrange(0, self._retry_setnx_count):\n            is_set = self._r.setnx(self._key, self._get_now() + self._expire)\n            if is_set:\n                return True, 0\n\n            old_expire = self._r.get(self._key)\n            if old_expire is not None:\n                return False, float(old_expire)\n\n        raise SetnxError(self._key)\n\n    def _need_retry(self, expire):\n        if expire < self._get_now():\n            return False\n\n        time.sleep(self._retry_sleep_sec)\n        return True\n\n    def _getset(self):\n        old_expire = self._r.getset(self._key, self._get_now() + self._expire)\n        if old_expire is None:\n            return 0\n\n        return float(old_expire)\n\n    def unlock(self):\n        if not self._lock:\n            raise HasNotLockError(self._key)\n\n        elapsed_time = self._get_now() - self._lock\n        if self._expire <= elapsed_time:\n            raise ExpiredLockError(self._key, elapsed_time)\n\n        self._r.delete(self._key)\n        self._lock = None\n\n    def __enter__(self):\n        self.lock()\n        return self\n\n    def __exit__(self, exc_type, exc_value, traceback):\n        if self._lock:\n            self.unlock()\n        return True if exc_type is None else False\n\n    def __call__(self, func):\n        @wraps(func)\n        def inner(*args, **kwargs):\n            with self:\n                return func(*args, **kwargs)\n        return inner\n\n\n\nexception.py\nclass MutexError(Exception):\n    pass\n\n\nclass DuplicateLockError(MutexError):\n\n    \"\"\"\n    \u65e2\u306b lock() \u5b9f\u884c\u6e08\u307f\u306e Mutex \u30aa\u30d6\u30b8\u30a7\u30af\u30c8\u3067 lock() \u3092\u518d\u5b9f\u884c\u3059\u308b\u3068\u767a\u751f.\n    \u4e00\u5ea6, unlock() \u3092\u5b9f\u884c\u3059\u308b\u304b, \u5225\u306e Mutex \u30aa\u30d6\u30b8\u30a7\u30af\u30c8\u3092\u4f5c\u6210\u3059\u308b\u5fc5\u8981\u304c\u3042\u308b.\n    \"\"\"\n\n    pass\n\n\nclass HasNotLockError(MutexError):\n\n    \"\"\"\n    \u307e\u3060, lock() \u304c\u5b9f\u884c\u3055\u308c\u3066\u3044\u306a\u3044 Mutex \u30aa\u30d6\u30b8\u30a7\u30af\u30c8\u3067 unlock() \u3092\u5b9f\u884c\u3059\u308b\u3068\u767a\u751f.\n    lock() \u5f8c\u306b\u5b9f\u884c\u3059\u308b\u5fc5\u8981\u304c\u3042\u308b.\n    \"\"\"\n\n    pass\n\n\nclass ExpiredLockError(MutexError):\n\n    \"\"\"\n    lock() \u5b9f\u884c\u5f8c, expire \u306b\u3088\u308a\u30ed\u30c3\u30af\u304c\u89e3\u653e\u3055\u308c\u3066\u3044\u308b\u72b6\u614b\u3067 unlock() \u3092\u5b9f\u884c\u3059\u308b\u3068\u767a\u751f.\n    \"\"\"\n\n    pass\n\n\nclass SetnxError(MutexError):\n    pass\n\n\nclass LockError(MutexError):\n    pass\n\n\n\n\u89e3\u8aac\n\u3056\u3063\u304f\u308a\u3057\u305f\u30ed\u30c3\u30af\u306e\u6d41\u308c\u306f\u6b21\u306e\u901a\u308a.\n\nSETNX \u3067 \"\u6709\u52b9\u671f\u9650X\" \u3092\u8a2d\u5b9a\n\u8a2d\u5b9a\u3067\u304d\u308c\u3070 Lock \u6210\u529f\n\u8a2d\u5b9a\u3067\u304d\u306a\u3051\u308c\u3070, GET \u3067 \"\u6709\u52b9\u671f\u9650Y\" \u3092\u53d6\u5f97\n\"\u6709\u52b9\u671f\u9650Y\" \u304c\u6709\u52b9\u306a\u3089\u3070, 1 \u3078\n\u65e2\u306b \"\u6709\u52b9\u671f\u9650Y\" \u304c\u7121\u52b9\u306a\u3089\u3070, GETSET \u3067 \"\u6709\u52b9\u671f\u9650X\" \u3092\u8a2d\u5b9a\nGETSET \u3067\u53d6\u5f97\u3057\u305f \"\u6709\u52b9\u671f\u9650Z\" \u304c\u7121\u52b9\u306a\u3089 Lock \u6210\u529f\n\"\u6709\u52b9\u671f\u9650Z\" \u304c\u6709\u52b9\u306a\u3089, \u4ed6\u306e\u30d7\u30ed\u30bb\u30b9\u304c GETSET \u6e08\u307f\u3067\u3042\u308b\u305f\u3081 1 \u3078\n\n\u4f7f\u3044\u65b9\u306f\u6b21\u306e\u901a\u308a.\n\nusage.py\n>>> from mutex import Mutex\n>>> with Mutex(':'.join(['EmitAccessToken', user_id]):\n>>>     # do something ...\n>>>     pass\n\n>>> @Mutex(':'.join(['EmitAccessToken', user_id]):\n>>> def emit_access_token():\n>>>     # do something ...\n>>>     pass\n\n>>> mutex = Mutex(':'.join(['EmitAccessToken', user_id])\n>>> mutex.lock()\n>>> # do something ...\n>>> mutex.unlock()\n\n\n\n\u30c6\u30b9\u30c8\n\ntest.py\nimport unittest\nimport redis\nimport time\nfrom multiprocessing import Process\n\nfrom .mutex import Mutex\nfrom .exception import (DuplicateLockError,\n                        HasNotLockError,\n                        ExpiredLockError,\n                        LockError)\n\n\nclass TestMutex(unittest.TestCase):\n    def setUp(self):\n        self.key = 'spam'\n        self.r = redis.StrictRedis()\n        self.mutex = Mutex(self.r, self.key)\n\n    def tearDown(self):\n        mutex = self.mutex\n        if mutex._lock:\n            mutex.unlock()\n        mutex._r.delete('ham')\n\n    def test_lock(self):\n        mutex = self.mutex\n        mutex.lock()\n        self.assertIsNotNone(mutex._r.get(mutex._key))\n\n        with self.assertRaises(DuplicateLockError):\n            mutex.lock()\n\n    def test_unlock(self):\n        self.test_lock()\n\n        mutex = self.mutex\n        self.mutex.unlock()\n        self.assertIsNone(mutex._r.get(mutex._key))\n\n        with self.assertRaises(HasNotLockError):\n            mutex.unlock()\n\n        self.test_lock()\n        time.sleep(10.5)\n        with self.assertRaises(ExpiredLockError):\n            mutex.unlock()\n        mutex._lock = None # \u5f37\u5236\u7684\u306b\u521d\u671f\u5316\n\n    def test_expire(self):\n        mutex1 = self.mutex\n\n        mutex2 = Mutex(self.r, self.key, expire=2)\n        mutex2.lock() # 2 \u79d2 Lock \u3057\u7d9a\u3051\u308b\n\n        with self.assertRaises(LockError):\n            mutex1.lock() # retry 6 \u56de * sleep 0.25 \u79d2 = 1.5 \u79d2\n\n        time.sleep(0.6) # \u304a\u307e\u3051\n        mutex1.lock()\n        self.assertIsNotNone(mutex1._r.get(mutex1._key))\n\n    def test_with(self):\n        mutex1 = self.mutex\n        with mutex1:\n            self.assertIsNotNone(mutex1._r.get(mutex1._key))\n        self.assertIsNone(mutex1._r.get(mutex1._key))\n\n        mutex2 = Mutex(self.r, self.key, expire=2)\n        mutex2.lock() # 2 \u79d2 Lock \u3057\u7d9a\u3051\u308b\n\n        with self.assertRaises(LockError):\n            with mutex1: # retry 6 \u56de * sleep 0.25 \u79d2 = 1.5 \u79d2\n                pass\n\n        mutex2.unlock()\n\n        with mutex1:\n            with self.assertRaises(DuplicateLockError):\n                with mutex1:\n                    pass\n\n    def test_decorator(self):\n        mutex = self.mutex\n        @mutex\n        def egg():\n            self.assertIsNotNone(mutex._r.get(mutex._key))\n        egg()\n        self.assertIsNone(mutex._r.get(mutex._key))\n\n    def test_multi_process(self):\n        procs = 20\n        counter = 100\n\n        def incr():\n            mutex = Mutex(redis.StrictRedis(), self.key, retry_count=100)\n            for n in xrange(0, counter):\n                mutex.lock()\n\n                ham = mutex._r.get('ham') or 0\n                mutex._r.set('ham', int(ham) + 1)\n\n                mutex.unlock()\n\n        ps = [Process(target=incr) for n in xrange(0, procs)]\n        for p in ps:\n            p.start()\n\n        for p in ps:\n            p.join()\n\n        self.assertEqual(int(self.mutex._r.get('ham')), counter * procs)\n\n\n\n# \u767a\u7aef\n\n\u30b5\u30fc\u30d3\u30b9\u69cb\u7bc9\u6642, \u76f8\u4e92\u6392\u4ed6\u3067\u30ed\u30c3\u30af\u3092\u7372\u5f97\u3057\u305f\u3044\u304c, RDS \u3092\u4f7f\u3046\u307b\u3069\u3067\u3082\u7121\u3044\u305f\u3081 Redis \u3092\u4f7f\u7528\u3057\u305f\u3044.\nPython \u3067 [SETNX \u2013 Redis](http://redis.io/commands/setnx) \u306e \"Design pattern: Locking with SETNX\" \u3092\u5b9f\u88c5\u3057\u3066\u3044\u308b\u30e9\u30a4\u30d6\u30e9\u30ea\u3092\u63a2\u3057\u305f\u304c, \u3055\u3055\u3063\u3068\u63a2\u3057\u305f\u611f\u3058\u898b\u5f53\u305f\u3089\u306a\u304b\u3063\u305f\u305f\u3081, \u5b9f\u88c5\u3057\u3066\u307f\u305f.\n\u306a\u304a, [SETNX \u2013 Redis](http://redis.io/commands/setnx) \u306e\u65e5\u672c\u8a9e\u8a33\u306f [\u6587\u5b57\u5217\u578b - redis 2.0.3 documentation](http://redis.shibu.jp/commandreference/strings.html#command-SETNX) \u3092\u53c2\u7167\u306e\u3053\u3068.\n\n# \u5b9f\u88c5\n\n## Source Code\n\n```python:mutex.py\nfrom datetime import datetime\nimport time\nfrom functools import wraps\n\nfrom .exception import (DuplicateLockError,\n                        HasNotLockError,\n                        ExpiredLockError,\n                        SetnxError,\n                        LockError)\n\n\nclass Mutex(object):\n    def __init__(self, client, key,\n                 expire=10,\n                 retry_count=6, # retry_count * retry_sleep_sec = \u6700\u5927\u5f85\u3061\u6642\u9593\n                 retry_setnx_count=100,\n                 retry_sleep_sec=0.25):\n        self._lock = None\n        self._r = client\n        self._key = key\n        self._expire = expire\n        self._retry_count = retry_count\n        self._retry_setnx_count = retry_setnx_count\n        self._retry_sleep_sec = retry_sleep_sec\n\n    def _get_now(self):\n        return float(datetime.now().strftime('%s.%f'))\n\n    def lock(self):\n        if self._lock:\n            raise DuplicateLockError(self._key)\n        self._do_lock()\n\n    def _do_lock(self):\n        for n in xrange(0, self._retry_count):\n            is_set, old_expire = self._setnx()\n            if is_set:\n                self._lock = self._get_now()\n                return\n\n            if self._need_retry(old_expire):\n                continue\n\n            if not self._need_retry(self._getset()):\n                self._lock = self._get_now()\n                return \n\n        raise LockError(self._key)\n\n    def _setnx(self):\n        for n in xrange(0, self._retry_setnx_count):\n            is_set = self._r.setnx(self._key, self._get_now() + self._expire)\n            if is_set:\n                return True, 0\n\n            old_expire = self._r.get(self._key)\n            if old_expire is not None:\n                return False, float(old_expire)\n\n        raise SetnxError(self._key)\n\n    def _need_retry(self, expire):\n        if expire < self._get_now():\n            return False\n\n        time.sleep(self._retry_sleep_sec)\n        return True\n\n    def _getset(self):\n        old_expire = self._r.getset(self._key, self._get_now() + self._expire)\n        if old_expire is None:\n            return 0\n\n        return float(old_expire)\n\n    def unlock(self):\n        if not self._lock:\n            raise HasNotLockError(self._key)\n\n        elapsed_time = self._get_now() - self._lock\n        if self._expire <= elapsed_time:\n            raise ExpiredLockError(self._key, elapsed_time)\n\n        self._r.delete(self._key)\n        self._lock = None\n\n    def __enter__(self):\n        self.lock()\n        return self\n\n    def __exit__(self, exc_type, exc_value, traceback):\n        if self._lock:\n            self.unlock()\n        return True if exc_type is None else False\n\n    def __call__(self, func):\n        @wraps(func)\n        def inner(*args, **kwargs):\n            with self:\n                return func(*args, **kwargs)\n        return inner\n```\n\n```exception.py\nclass MutexError(Exception):\n    pass\n\n\nclass DuplicateLockError(MutexError):\n\n    \"\"\"\n    \u65e2\u306b lock() \u5b9f\u884c\u6e08\u307f\u306e Mutex \u30aa\u30d6\u30b8\u30a7\u30af\u30c8\u3067 lock() \u3092\u518d\u5b9f\u884c\u3059\u308b\u3068\u767a\u751f.\n    \u4e00\u5ea6, unlock() \u3092\u5b9f\u884c\u3059\u308b\u304b, \u5225\u306e Mutex \u30aa\u30d6\u30b8\u30a7\u30af\u30c8\u3092\u4f5c\u6210\u3059\u308b\u5fc5\u8981\u304c\u3042\u308b.\n    \"\"\"\n\n    pass\n\n\nclass HasNotLockError(MutexError):\n\n    \"\"\"\n    \u307e\u3060, lock() \u304c\u5b9f\u884c\u3055\u308c\u3066\u3044\u306a\u3044 Mutex \u30aa\u30d6\u30b8\u30a7\u30af\u30c8\u3067 unlock() \u3092\u5b9f\u884c\u3059\u308b\u3068\u767a\u751f.\n    lock() \u5f8c\u306b\u5b9f\u884c\u3059\u308b\u5fc5\u8981\u304c\u3042\u308b.\n    \"\"\"\n\n    pass\n\n\nclass ExpiredLockError(MutexError):\n\n    \"\"\"\n    lock() \u5b9f\u884c\u5f8c, expire \u306b\u3088\u308a\u30ed\u30c3\u30af\u304c\u89e3\u653e\u3055\u308c\u3066\u3044\u308b\u72b6\u614b\u3067 unlock() \u3092\u5b9f\u884c\u3059\u308b\u3068\u767a\u751f.\n    \"\"\"\n\n    pass\n\n\nclass SetnxError(MutexError):\n    pass\n\n\nclass LockError(MutexError):\n    pass\n```\n\n## \u89e3\u8aac\n\n\u3056\u3063\u304f\u308a\u3057\u305f\u30ed\u30c3\u30af\u306e\u6d41\u308c\u306f\u6b21\u306e\u901a\u308a.\n\n1. SETNX \u3067 \"\u6709\u52b9\u671f\u9650X\" \u3092\u8a2d\u5b9a\n1. \u8a2d\u5b9a\u3067\u304d\u308c\u3070 Lock \u6210\u529f\n1. \u8a2d\u5b9a\u3067\u304d\u306a\u3051\u308c\u3070, GET \u3067 \"\u6709\u52b9\u671f\u9650Y\" \u3092\u53d6\u5f97\n1. \"\u6709\u52b9\u671f\u9650Y\" \u304c\u6709\u52b9\u306a\u3089\u3070, 1 \u3078\n1. \u65e2\u306b \"\u6709\u52b9\u671f\u9650Y\" \u304c\u7121\u52b9\u306a\u3089\u3070, GETSET \u3067 \"\u6709\u52b9\u671f\u9650X\" \u3092\u8a2d\u5b9a\n1. GETSET \u3067\u53d6\u5f97\u3057\u305f \"\u6709\u52b9\u671f\u9650Z\" \u304c\u7121\u52b9\u306a\u3089 Lock \u6210\u529f\n1. \"\u6709\u52b9\u671f\u9650Z\" \u304c\u6709\u52b9\u306a\u3089, \u4ed6\u306e\u30d7\u30ed\u30bb\u30b9\u304c GETSET \u6e08\u307f\u3067\u3042\u308b\u305f\u3081 1 \u3078\n\n\n\u4f7f\u3044\u65b9\u306f\u6b21\u306e\u901a\u308a.\n\n```python:usage.py\n>>> from mutex import Mutex\n>>> with Mutex(':'.join(['EmitAccessToken', user_id]):\n>>>     # do something ...\n>>>     pass\n\n>>> @Mutex(':'.join(['EmitAccessToken', user_id]):\n>>> def emit_access_token():\n>>>     # do something ...\n>>>     pass\n\n>>> mutex = Mutex(':'.join(['EmitAccessToken', user_id])\n>>> mutex.lock()\n>>> # do something ...\n>>> mutex.unlock()\n```\n\n# \u30c6\u30b9\u30c8\n\n```python:test.py\nimport unittest\nimport redis\nimport time\nfrom multiprocessing import Process\n\nfrom .mutex import Mutex\nfrom .exception import (DuplicateLockError,\n                        HasNotLockError,\n                        ExpiredLockError,\n                        LockError)\n\n\nclass TestMutex(unittest.TestCase):\n    def setUp(self):\n        self.key = 'spam'\n        self.r = redis.StrictRedis()\n        self.mutex = Mutex(self.r, self.key)\n\n    def tearDown(self):\n        mutex = self.mutex\n        if mutex._lock:\n            mutex.unlock()\n        mutex._r.delete('ham')\n\n    def test_lock(self):\n        mutex = self.mutex\n        mutex.lock()\n        self.assertIsNotNone(mutex._r.get(mutex._key))\n\n        with self.assertRaises(DuplicateLockError):\n            mutex.lock()\n\n    def test_unlock(self):\n        self.test_lock()\n\n        mutex = self.mutex\n        self.mutex.unlock()\n        self.assertIsNone(mutex._r.get(mutex._key))\n\n        with self.assertRaises(HasNotLockError):\n            mutex.unlock()\n\n        self.test_lock()\n        time.sleep(10.5)\n        with self.assertRaises(ExpiredLockError):\n            mutex.unlock()\n        mutex._lock = None # \u5f37\u5236\u7684\u306b\u521d\u671f\u5316\n\n    def test_expire(self):\n        mutex1 = self.mutex\n\n        mutex2 = Mutex(self.r, self.key, expire=2)\n        mutex2.lock() # 2 \u79d2 Lock \u3057\u7d9a\u3051\u308b\n\n        with self.assertRaises(LockError):\n            mutex1.lock() # retry 6 \u56de * sleep 0.25 \u79d2 = 1.5 \u79d2\n\n        time.sleep(0.6) # \u304a\u307e\u3051\n        mutex1.lock()\n        self.assertIsNotNone(mutex1._r.get(mutex1._key))\n\n    def test_with(self):\n        mutex1 = self.mutex\n        with mutex1:\n            self.assertIsNotNone(mutex1._r.get(mutex1._key))\n        self.assertIsNone(mutex1._r.get(mutex1._key))\n\n        mutex2 = Mutex(self.r, self.key, expire=2)\n        mutex2.lock() # 2 \u79d2 Lock \u3057\u7d9a\u3051\u308b\n\n        with self.assertRaises(LockError):\n            with mutex1: # retry 6 \u56de * sleep 0.25 \u79d2 = 1.5 \u79d2\n                pass\n\n        mutex2.unlock()\n\n        with mutex1:\n            with self.assertRaises(DuplicateLockError):\n                with mutex1:\n                    pass\n\n    def test_decorator(self):\n        mutex = self.mutex\n        @mutex\n        def egg():\n            self.assertIsNotNone(mutex._r.get(mutex._key))\n        egg()\n        self.assertIsNone(mutex._r.get(mutex._key))\n\n    def test_multi_process(self):\n        procs = 20\n        counter = 100\n\n        def incr():\n            mutex = Mutex(redis.StrictRedis(), self.key, retry_count=100)\n            for n in xrange(0, counter):\n                mutex.lock()\n\n                ham = mutex._r.get('ham') or 0\n                mutex._r.set('ham', int(ham) + 1)\n\n                mutex.unlock()\n\n        ps = [Process(target=incr) for n in xrange(0, procs)]\n        for p in ps:\n            p.start()\n\n        for p in ps:\n            p.join()\n\n        self.assertEqual(int(self.mutex._r.get('ham')), counter * procs)\n```\n"}