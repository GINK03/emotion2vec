{"context": "Even in MongoDB, sometimes your models may still have reference relations. Like ActiveRecord, the popular MongoDB ORM, mongoid, provides #includes method to perform eager loads.\n\nProblems\nHowever, it is a pain to specify them manually in codes. In most scenes, you just need the eager loading when you what to access the relation.\nAs described in Joel Turkel's post about Goldiloader, the eager loading should neither be a duty of controllers (why should they care about how the data is fetched) nor be one of views (they just present your data!).\nEager loading is more likely a job that the model it self should handle.\n\nBetter Practice\nJust like Goldiloader for ActiveRecord, there can also be a plugin that makes mongoid do the eager loading automatically.\nSay you have the following models for your blog site:\nclass User\n  include Mongoid::Document\n  has_one :device\n  has_many :posts\nend\n\nclass Post\n  include Mongoid::Document\n  belongs_to :user\n  has_and_belongs_to_many :tags\nend\n\nclass Tag\n  include Mongoid::Document\n  has_and_belongs_to_many :posts, fully_load: true\nend\n\nWhen you call\n@user = User.find(id)\n@posts = @user.posts.limit(10) # \n\n# access the tags\n@posts.each do |post|\n  puts post.title\n  puts post.tags.map(&:name).join(', ')\nend\n\nMongoid will perform 12 queries: 1 on users, 1 on posts and 10 on tags:\ndb.users.find('_id' : id);\ndb.posts.find('user_id' : user_id);\ndb.tags.find('post_ids' : post0_id);\ndb.tags.find('post_ids' : post1_id);\n...\ndb.tags.find('post_ids' : post9_id);\n\nBut as an experienced developer, you could easily figure out that the eager loading on :tag relation should be performed. In fact, adding #includes to the criteria is a default action, manually done by the developers.\nWhy not make it a default to mongoid?\nWhen you access the tag relation and is about to query it in your db, perform an eager loading on :tag just before the query:\n# before query a relation\n# the query loading method of a relation is\n# Mongoid::Relations::Targets::Enumerable#unloaded_documents\n\ndef before_unloaded_documents\n  owner = relation.base # get the relation owner\n  metadata = relation.relation_metadata # get the relation metadata\n\n  # DO THE EAGER LOADING\n  # \n  #   Requires some trick to access the owners collection through the owner.\n  #   Add an reference to the collection into model\nend\n\nThen when you run the previous @posts.each..., it will results to only 3 quires, 1 for each:\ndb.users.find('_id' : id);\ndb.posts.find('user_id' : user_id);\ndb.tags.find('post_ids' : {'$in' : post_ids});\n\nWow, you do not need to specify any eager loads. (The modified) Mongoid will do it automatically for you!\n\nConclusion\nEager loads are performance boosters, and should be an default behaviour in most situations. The developers should be aware of them, but not repeatly code .includes(:...) just because you need it everywhere. \nI've written a gem mongoload to make your mongoid an automatic eager loader. Check it on GitHub.\n\nEven in MongoDB, sometimes your models may still have reference relations. Like ActiveRecord, the popular MongoDB ORM, mongoid, provides [```#includes```](http://www.rubydoc.info/github/mongoid/mongoid/Mongoid%2FCriteria%3Aincludes) method to perform [eager loads](http://guides.rubyonrails.org/active_record_querying.html#eager-loading-associations).\n## Problems\nHowever, it is a pain to specify them manually in codes. In most scenes, you just need the eager loading when you what to access the relation.\n\nAs described in [Joel Turkel's post](http://blog.salsify.com/engineering/automatic-eager-loading-rails) about [Goldiloader](https://github.com/salsify/goldiloader), the eager loading should neither be a duty of controllers (why should they care about how the data is fetched) nor be one of views (they just present your data!).\n\nEager loading is more likely a job that the model it self should handle.\n\n## Better Practice\nJust like Goldiloader for ActiveRecord, there can also be a plugin that makes mongoid do the eager loading automatically.\n\nSay you have the following models for your blog site:\n\n```ruby\nclass User\n  include Mongoid::Document\n  has_one :device\n  has_many :posts\nend\n\nclass Post\n  include Mongoid::Document\n  belongs_to :user\n  has_and_belongs_to_many :tags\nend\n\nclass Tag\n  include Mongoid::Document\n  has_and_belongs_to_many :posts, fully_load: true\nend\n```\n\nWhen you call\n\n```ruby\n@user = User.find(id)\n@posts = @user.posts.limit(10) # \n\n# access the tags\n@posts.each do |post|\n  puts post.title\n  puts post.tags.map(&:name).join(', ')\nend\n```\n\nMongoid will perform 12 queries: 1 on users, 1 on posts and **10** on tags:\n\n```javascript\ndb.users.find('_id' : id);\ndb.posts.find('user_id' : user_id);\ndb.tags.find('post_ids' : post0_id);\ndb.tags.find('post_ids' : post1_id);\n...\ndb.tags.find('post_ids' : post9_id);\n```\n\nBut as an experienced developer, you could easily figure out that the eager loading on ```:tag``` relation should be performed. In fact, adding ```#includes``` to the criteria is a default action, manually done by the developers.\n\n*Why not make it a default to mongoid?*\n\nWhen you access the tag relation and is about to query it in your db, perform an eager loading on ```:tag``` just before the query:\n\n```ruby\n# before query a relation\n# the query loading method of a relation is\n# Mongoid::Relations::Targets::Enumerable#unloaded_documents\n\ndef before_unloaded_documents\n  owner = relation.base # get the relation owner\n  metadata = relation.relation_metadata # get the relation metadata\n\n  # DO THE EAGER LOADING\n  # \n  #   Requires some trick to access the owners collection through the owner.\n  #   Add an reference to the collection into model\nend\n```\n\nThen when you run the previous ```@posts.each...```, it will results to only 3 quires, 1 for each:\n\n```javascript\ndb.users.find('_id' : id);\ndb.posts.find('user_id' : user_id);\ndb.tags.find('post_ids' : {'$in' : post_ids});\n```\n\nWow, you do not need to specify any eager loads. (The modified) Mongoid will do it automatically for you!\n\n## Conclusion\nEager loads are performance boosters, and should be an default behaviour in most situations. The developers should be aware of them, but not repeatly code ```.includes(:...)``` just because you need it everywhere. \nI've written a gem [mongoload](https://rubygems.org/gems/mongoload) to make your mongoid an automatic eager loader. Check it on [GitHub](https://github.com/karloku/mongoload).\n", "tags": ["Ruby", "mongoid", "MongoDB"]}