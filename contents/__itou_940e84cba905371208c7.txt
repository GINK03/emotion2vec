{"context": "https://paiza.jp/poh/ando\n\u306bHaskell\u3067\u6311\u6226\u3057\u3066\u307f\u305f\u3002\n\u3053\u3046\u3044\u3046\u66f8\u304d\u65b9\u304c\u3042\u308b\u3002\n\u305d\u3093\u306a\u66f8\u304d\u65b9Haskell\u3089\u3057\u304f\u306a\u3044\u306a\u3069\n\u30b3\u30e1\u30f3\u30c8\u9802\u3051\u308b\u3068\u3046\u308c\u3057\u3044\u3067\u3059\u3002\n\u6c34\u7740\u304c\u5b8c\u6210\u3057\u3066\u306a\u3044\u3067\u3059\u3002\n\u96e3\u3057\u3044\u3002\u3002\u3002(\u00b4\u30fb\u03c9\u30fb` )\n2016/04/05\u3000\u8ffd\u8a18\n\u554f\u984c\uff08\u732b\u3001\u3000\u732b\u8033\u3001\u3000\u30e1\u30a4\u30c9\u670d\uff09\u304c\u5897\u3048\u305f\u306e\u3067\u6311\u6226\u3057\u305f\n\n\n\u76ee\n\n\u3064\u308a\u76ee\nann :: String -> String\nann s = concat $ replicate (read s) \"Ann\"\n\nmain = getLine >>= putStrLn . ann\n\n\n\u773c\u5e2f\nimport Data.List\n\ntype Owns = [Int]\ntype NonOwns = [Int]\ntype InputList = (Owns, NonOwns)\ntype BuyList = [Int]\n\nselect :: InputList-> BuyList\nselect (o, no) = no \\\\ o\n\ncreateInputList :: String -> InputList\ncreateInputList = ci . lines\n    where\n        ci :: [String] -> InputList\n        ci (_:_:owns:_:nonOwns:[]) = (convert owns,convert nonOwns)\n        convert :: String -> [Int]\n        convert = map read . nub . words\nbuy :: BuyList -> String\nbuy [] = \"None\"\nbuy xs = intercalate \" \" $ map show  $ sort xs\n\ngantai :: String -> String\ngantai = buy . select . createInputList\n\nmain = getContents >>= putStrLn . gantai\n\n\n\u732b\u8033\nimport qualified Data.Text as T\nimport Data.List\n\nword = \"cat\"\n\nwordCount :: String -> Int\nwordCount xs = T.count  (T.pack word) inputWord\n  where\n    inputWord = T.pack xs\n\n\n--\u5b9f\u88c5\u3057\u3066\u307f\u305f\nwordCount2 :: String -> Int\nwordCount2 = wordCount' 0\n  where\n    wordLength = length word\n    dropWord = drop wordLength\n    wordCount' :: Int -> String -> Int\n    wordCount' n xs\n      | word `isPrefixOf` xs = wordCount' (succ n) $ dropWord xs\n      | wordLength < length xs = wordCount' n $ tail xs\n      | otherwise = n\n\n\nmain = getLine >>= print . wordCount\n\n\n\u732b\nimport qualified Data.Text as T\n\ndata WordCounts = WordCounts {\n                     cCount :: Int\n                    ,aCount :: Int\n                    ,tCount :: Int\n                    } deriving (Show)\n\ndata Result = Result {\n                     catWords  :: Int -- \u5b8c\u5168\u306b\u4f5c\u308c\u308b\u500b\u6570\n                    ,shortageC :: Int -- \u5fc5\u8981\u306a \"c\" \u306e\u500b\u6570\n                    ,shortageA :: Int -- \u5fc5\u8981\u306a \"a\" \u306e\u500b\u6570\n                    ,shortageT :: Int -- \u5fc5\u8981\u306a \"t\" \u306e\u500b\u6570\n                    }\n\ninstance Show Result where\n  show (Result w c a t) = show w ++ \"\\r\\n\" \n                          ++ show c ++ \"\\r\\n\"\n                          ++ show a ++ \"\\r\\n\"\n                          ++ show t ++ \"\\r\\n\"\n\ncreateWordCounts :: String -> WordCounts\ncreateWordCounts xs = WordCounts countC countA countT\n  where\n    countx x = T.count (T.pack x) $ T.pack xs\n    countC = countx \"c\"\n    countA = countx \"a\"\n    countT = countx \"t\"\n\naggregate :: WordCounts -> Result\naggregate wc = Result (minWordCount wc)\n                      (maxCount - cCount wc)\n                      (maxCount - aCount wc)\n                      (maxCount - tCount wc)\n  where\n    maxCount = maxWordCount wc\n\nmaxWordCount, minWordCount :: WordCounts -> Int\nmaxWordCount wc = maximum [cCount wc, aCount wc, tCount wc]\nminWordCount wc = minimum [cCount wc, aCount wc, tCount wc]\n\nmain = getLine >>= print . aggregate . createWordCounts\n\n\n\u9aea\n\n\u30b7\u30e7\u30fc\u30c8\u30d8\u30a2\nlineAdd :: String -> Int\nlineAdd = sum . map read . lines\n\nmain = getContents >>= print . lineAdd\n\n\n\u30ed\u30f3\u30b0\u30d8\u30a2\nimport Control.Monad.State\n\ndata VoteResult = Yes Int | No Int deriving (Show)\ntype Vote = [String]\ntype VoteState = (VoteResult, VoteResult)\ntype Result = String\n\nmajorityRule :: Vote -> State VoteState Result\nmajorityRule [] = get >>= \\((Yes m), (No n)) -> case compare m n of\n                        EQ -> return \"\"\n                        GT -> return \"yes\"\n                        LT -> return \"no\"\nmajorityRule (x:xs) = do\n    (Yes m,No n) <- get\n    case x of\n        \"yes\" -> put (Yes (m+1), No n)\n        \"no\"  -> put (Yes m,    No (n+1))\n    majorityRule xs\n\nvote :: Vote -> Result\nvote xs = evalState (majorityRule xs) (Yes 0, No 0)\n\nmain = getContents >>= putStrLn . vote . lines\n\n\n\u30dd\u30cb\u30fc\u30c6\u30fc\u30eb\nimport Data.List\n\ncountDown :: Int -> [String]\ncountDown n = reverse . (:) \"0!!\" $ map show [1..n]\n\nmain = getLine >>= mapM_ putStrLn . countDown . read\n\n\n\u30c4\u30a4\u30f3\u30c6\u30fc\u30eb\ncostperformance :: (Fractional a, Ord a) => [a] -> Int\ncostperformance (d1Caffeine:d1Price:\n                d2Caffeine:d2Price:[]) = select p1 p2\n    where\n        p1 = d1Caffeine / d1Price\n        p2 = d2Caffeine / d2Price\n        select a1 a2\n            | a1 > a2 = 1\n            | a1 < a2 = 2\n\nmain = getContents >>= print . costperformance . map read . words\n\n\n\u670d\n\n\u30bb\u30fc\u30e9\u30fc\u670d\nimport Data.List\n\nmain = getContents >>= putStrLn . concat . intersperse \"_\" . tail . lines\n\n\n\u30ab\u30fc\u30c7\u30a3\u30ac\u30f3\nmyProduct :: Int -> Int\nmyProduct n = product [1..n]\n\nmain = getLine >>= print . myProduct . read\n\n\n\u7e1e\u30cb\u30fc\u30bd\nstripedPattern :: [Int] -> String\nstripedPattern (w:m:[]) = concat $ take m sp\n    where\n        widte = replicate w\n        sp    = cycle (widte \"R\" ++ widte \"W\")\n\nmain = getContents >>= putStrLn . stripedPattern . map read . lines\n\n\n\u30e1\u30a4\u30c9\u670d\n--\u30e1\u30a4\u30c9\u670d\nmodule Main where\n\nimport Data.Time.Calendar\nimport Data.Time.Clock\nimport Data.Time.LocalTime\nimport Data.Time.Format\nimport System.Locale\n\n--\u3000\u6642\u9593\u3060\u3051\u3092\u64cd\u4f5c\u3059\u308b\u65b9\u6cd5\u304c\u308f\u304b\u3089\u306a\u3044\u305f\u3081 UTCTime \u3092\u64cd\u4f5c\u3057\u3066\u3044\u308b\nreferenceBedtime :: UTCTime\nreferenceBedtime = UTCTime\n                  (fromGregorian 216 4 1)\n                  (timeOfDayToTime $ TimeOfDay 1 0 0)\n\noutputFormat :: UTCTime -> String\noutputFormat = formatTime defaultTimeLocale \"%H:%M\"\n\ndifferenceMinuteTime :: NominalDiffTime -> UTCTime -> UTCTime \ndifferenceMinuteTime n = addUTCTime ((-60) * n)\n\nbedtime :: String -> String\nbedtime x = outputFormat \n              $ differenceMinuteTime minute referenceBedtime\n  where\n    minute = fromInteger (read x `div` 3) :: NominalDiffTime\n\nmain = getContents >>= putStrLn . unlines . map bedtime . tail . lines\n\n\n\u305d\u306e\u4ed6\n\n\u3081\u304c\u306d\nimport Control.Monad\nimport Control.Applicative\nimport Data.List\n\ntype Filed = [[String]]\ntype X = Int -- x\u5ea7\u6a19\ntype Y = Int -- y\u5ea7\u6a19\n\nextraction :: Int -> Filed -> [((Y, X), Filed)]\nextraction n xs = concatMap  (yExtraction n 0) $ xExtraction n 0 xs\n\nxExtraction:: Int -> Int -> Filed -> [(X, Filed)]\nxExtraction a b xs \n    | length xs < a + b = []\n    | otherwise        = (b, ex) : xExtraction a (b+1) xs\n    where\n        ex = map (take a . drop b) xs\n\nyExtraction :: Int -> Int -> (X, Filed) -> [((Y, X), Filed)]\nyExtraction a b  xs'@(x, xs)\n    | length xs < a + b = []\n    | otherwise        = ((b, x), ex) : yExtraction a (b + 1) xs'\n    where\n        ex = take a $ drop b xs\n\nmain = do\n    q <- getFiled =<< readLn\n    n <- readLn\n    p <- getFiled n\n    putStrLn $ concatMap (format . fst) $ matchPattern p $ extraction n q\n    where\n        getFiled n = map words <$> replicateM n getLine\n        matchPattern p = filter (\\t -> p == snd t)\n\nformat (y, x)  = show y ++ \" \" ++ show x\n\n\n\u30b5\u30f3\u30bf\u670d\nimport Control.Applicative\nimport Control.Monad\nimport Data.List\n\ndata Block =  Block {x1 :: Int, x2 :: Int,\n                     y1 :: Int, y2 :: Int} deriving (Show)\n\ninstance Eq Block \n    where \n        a == b = diffX a + diffY a == diffX b + diffY b\n\ninstance Ord Block \n    where \n        compare a b = compare (diffX a + diffY a) (diffX b + diffY b)\n\ndiffX, diffY :: Block -> Int\ndiffX b = x2 b - x1 b\ndiffY b = y2 b - y1 b\n\nmain = do\n    [x, y, z, n] <- map read . words <$> getLine\n    cutPosition <- map words <$> replicateM n getLine\n    let b = minimum $ foldl cut [Block 0 x 0 y] cutPosition\n    print $ (diffX b) * (diffY b) * z\n\ncut :: [Block] -> [String] -> [Block]\ncut xs [a, b] \n    | a == \"0\" = concatMap (cutX $ read b) xs\n    | a == \"1\" = concatMap (cutY $ read b) xs\n\ncutX, cutY :: Int -> Block -> [Block]\ncutX a b = if isCut x1 x2 a b then [b {x2 = a}, b {x1 = a}] else [b]\ncutY a b = if isCut y1 y2 a b then [b {y2 = a}, b {y1 = a}] else [b]\n\nisCut p1 p2 a block = p1 block <= a && a <= p2 block\n\n\n\u6c34\u7740\uff08\u3067\u304d\u3066\u306a\u3044\uff09\ntest case4\u4ee5\u964d\u3067\u5931\u6557\n\u6642\u9593\u5207\u308c\nfact :: Integer -> Integer\nfact n = product [1..n]\n\nheadTrim :: String -> String\nheadTrim = dropWhile (== '0')\n\ntailTrim :: String -> String\ntailTrim  = twirl headTrim\n\nextraction :: [a] -> [a]\nextraction = twirl (take 9)\n\ntwirl f = reverse . f . reverse\n\nmain = do\n    n <- readLn\n    putStrLn $ headTrim . extraction . tailTrim . show $ fact n\n\nhttps://paiza.jp/poh/ando\n\u306bHaskell\u3067\u6311\u6226\u3057\u3066\u307f\u305f\u3002\n\n\u3053\u3046\u3044\u3046\u66f8\u304d\u65b9\u304c\u3042\u308b\u3002\n\u305d\u3093\u306a\u66f8\u304d\u65b9Haskell\u3089\u3057\u304f\u306a\u3044\u306a\u3069\n\u30b3\u30e1\u30f3\u30c8\u9802\u3051\u308b\u3068\u3046\u308c\u3057\u3044\u3067\u3059\u3002\n\n\u6c34\u7740\u304c\u5b8c\u6210\u3057\u3066\u306a\u3044\u3067\u3059\u3002\n\u96e3\u3057\u3044\u3002\u3002\u3002(\u00b4\u30fb\u03c9\u30fb` )\n\n2016/04/05\u3000\u8ffd\u8a18\n\u554f\u984c\uff08\u732b\u3001\u3000\u732b\u8033\u3001\u3000\u30e1\u30a4\u30c9\u670d\uff09\u304c\u5897\u3048\u305f\u306e\u3067\u6311\u6226\u3057\u305f\n\n* * *\n##\u76ee\n###\u3064\u308a\u76ee\n```\nann :: String -> String\nann s = concat $ replicate (read s) \"Ann\"\n\nmain = getLine >>= putStrLn . ann\n```\n###\u773c\u5e2f\n```\nimport Data.List\n\ntype Owns = [Int]\ntype NonOwns = [Int]\ntype InputList = (Owns, NonOwns)\ntype BuyList = [Int]\n\nselect :: InputList-> BuyList\nselect (o, no) = no \\\\ o\n\ncreateInputList :: String -> InputList\ncreateInputList = ci . lines\n    where\n        ci :: [String] -> InputList\n        ci (_:_:owns:_:nonOwns:[]) = (convert owns,convert nonOwns)\n        convert :: String -> [Int]\n        convert = map read . nub . words\nbuy :: BuyList -> String\nbuy [] = \"None\"\nbuy xs = intercalate \" \" $ map show  $ sort xs\n\ngantai :: String -> String\ngantai = buy . select . createInputList\n\nmain = getContents >>= putStrLn . gantai\n```\n\n###\u732b\u8033\n```\nimport qualified Data.Text as T\nimport Data.List\n\nword = \"cat\"\n\nwordCount :: String -> Int\nwordCount xs = T.count  (T.pack word) inputWord\n  where\n    inputWord = T.pack xs\n    \n\n--\u5b9f\u88c5\u3057\u3066\u307f\u305f\nwordCount2 :: String -> Int\nwordCount2 = wordCount' 0\n  where\n    wordLength = length word\n    dropWord = drop wordLength\n    wordCount' :: Int -> String -> Int\n    wordCount' n xs\n      | word `isPrefixOf` xs = wordCount' (succ n) $ dropWord xs\n      | wordLength < length xs = wordCount' n $ tail xs\n      | otherwise = n\n    \n\nmain = getLine >>= print . wordCount\n```\n\n###\u732b\n```\nimport qualified Data.Text as T\n\ndata WordCounts = WordCounts {\n                     cCount :: Int\n                    ,aCount :: Int\n                    ,tCount :: Int\n                    } deriving (Show)\n\ndata Result = Result {\n                     catWords  :: Int -- \u5b8c\u5168\u306b\u4f5c\u308c\u308b\u500b\u6570\n                    ,shortageC :: Int -- \u5fc5\u8981\u306a \"c\" \u306e\u500b\u6570\n                    ,shortageA :: Int -- \u5fc5\u8981\u306a \"a\" \u306e\u500b\u6570\n                    ,shortageT :: Int -- \u5fc5\u8981\u306a \"t\" \u306e\u500b\u6570\n                    }\n\ninstance Show Result where\n  show (Result w c a t) = show w ++ \"\\r\\n\" \n                          ++ show c ++ \"\\r\\n\"\n                          ++ show a ++ \"\\r\\n\"\n                          ++ show t ++ \"\\r\\n\"\n\ncreateWordCounts :: String -> WordCounts\ncreateWordCounts xs = WordCounts countC countA countT\n  where\n    countx x = T.count (T.pack x) $ T.pack xs\n    countC = countx \"c\"\n    countA = countx \"a\"\n    countT = countx \"t\"\n\naggregate :: WordCounts -> Result\naggregate wc = Result (minWordCount wc)\n                      (maxCount - cCount wc)\n                      (maxCount - aCount wc)\n                      (maxCount - tCount wc)\n  where\n    maxCount = maxWordCount wc\n\nmaxWordCount, minWordCount :: WordCounts -> Int\nmaxWordCount wc = maximum [cCount wc, aCount wc, tCount wc]\nminWordCount wc = minimum [cCount wc, aCount wc, tCount wc]\n\nmain = getLine >>= print . aggregate . createWordCounts\n```\n\n\n##\u9aea\n###\u30b7\u30e7\u30fc\u30c8\u30d8\u30a2\n```\nlineAdd :: String -> Int\nlineAdd = sum . map read . lines\n\nmain = getContents >>= print . lineAdd\n```\n###\u30ed\u30f3\u30b0\u30d8\u30a2\n```\nimport Control.Monad.State\n\ndata VoteResult = Yes Int | No Int deriving (Show)\ntype Vote = [String]\ntype VoteState = (VoteResult, VoteResult)\ntype Result = String\n\nmajorityRule :: Vote -> State VoteState Result\nmajorityRule [] = get >>= \\((Yes m), (No n)) -> case compare m n of\n                        EQ -> return \"\"\n                        GT -> return \"yes\"\n                        LT -> return \"no\"\nmajorityRule (x:xs) = do\n    (Yes m,No n) <- get\n    case x of\n        \"yes\" -> put (Yes (m+1), No n)\n        \"no\"  -> put (Yes m,    No (n+1))\n    majorityRule xs\n\nvote :: Vote -> Result\nvote xs = evalState (majorityRule xs) (Yes 0, No 0)\n\nmain = getContents >>= putStrLn . vote . lines\n```\n###\u30dd\u30cb\u30fc\u30c6\u30fc\u30eb\n```\nimport Data.List\n\ncountDown :: Int -> [String]\ncountDown n = reverse . (:) \"0!!\" $ map show [1..n]\n\nmain = getLine >>= mapM_ putStrLn . countDown . read\n```\n###\u30c4\u30a4\u30f3\u30c6\u30fc\u30eb\n```\ncostperformance :: (Fractional a, Ord a) => [a] -> Int\ncostperformance (d1Caffeine:d1Price:\n                d2Caffeine:d2Price:[]) = select p1 p2\n    where\n        p1 = d1Caffeine / d1Price\n        p2 = d2Caffeine / d2Price\n        select a1 a2\n            | a1 > a2 = 1\n            | a1 < a2 = 2\n\nmain = getContents >>= print . costperformance . map read . words\n```\n##\u670d\n###\u30bb\u30fc\u30e9\u30fc\u670d\n```\nimport Data.List\n\nmain = getContents >>= putStrLn . concat . intersperse \"_\" . tail . lines\n```\n###\u30ab\u30fc\u30c7\u30a3\u30ac\u30f3\n```\nmyProduct :: Int -> Int\nmyProduct n = product [1..n]\n\nmain = getLine >>= print . myProduct . read\n```\n###\u7e1e\u30cb\u30fc\u30bd\n```\nstripedPattern :: [Int] -> String\nstripedPattern (w:m:[]) = concat $ take m sp\n    where\n        widte = replicate w\n        sp    = cycle (widte \"R\" ++ widte \"W\")\n\nmain = getContents >>= putStrLn . stripedPattern . map read . lines\n```\n\n###\u30e1\u30a4\u30c9\u670d\n```\n--\u30e1\u30a4\u30c9\u670d\nmodule Main where\n\nimport Data.Time.Calendar\nimport Data.Time.Clock\nimport Data.Time.LocalTime\nimport Data.Time.Format\nimport System.Locale\n\n--\u3000\u6642\u9593\u3060\u3051\u3092\u64cd\u4f5c\u3059\u308b\u65b9\u6cd5\u304c\u308f\u304b\u3089\u306a\u3044\u305f\u3081 UTCTime \u3092\u64cd\u4f5c\u3057\u3066\u3044\u308b\nreferenceBedtime :: UTCTime\nreferenceBedtime = UTCTime\n                  (fromGregorian 216 4 1)\n                  (timeOfDayToTime $ TimeOfDay 1 0 0)\n\noutputFormat :: UTCTime -> String\noutputFormat = formatTime defaultTimeLocale \"%H:%M\"\n\ndifferenceMinuteTime :: NominalDiffTime -> UTCTime -> UTCTime \ndifferenceMinuteTime n = addUTCTime ((-60) * n)\n\nbedtime :: String -> String\nbedtime x = outputFormat \n              $ differenceMinuteTime minute referenceBedtime\n  where\n    minute = fromInteger (read x `div` 3) :: NominalDiffTime\n\nmain = getContents >>= putStrLn . unlines . map bedtime . tail . lines\n```\n\n\n##\u305d\u306e\u4ed6\n###\u3081\u304c\u306d\n```\nimport Control.Monad\nimport Control.Applicative\nimport Data.List\n\ntype Filed = [[String]]\ntype X = Int -- x\u5ea7\u6a19\ntype Y = Int -- y\u5ea7\u6a19\n\nextraction :: Int -> Filed -> [((Y, X), Filed)]\nextraction n xs = concatMap  (yExtraction n 0) $ xExtraction n 0 xs\n\nxExtraction:: Int -> Int -> Filed -> [(X, Filed)]\nxExtraction a b xs \n    | length xs < a + b = []\n    | otherwise        = (b, ex) : xExtraction a (b+1) xs\n    where\n        ex = map (take a . drop b) xs\n\nyExtraction :: Int -> Int -> (X, Filed) -> [((Y, X), Filed)]\nyExtraction a b  xs'@(x, xs)\n    | length xs < a + b = []\n    | otherwise        = ((b, x), ex) : yExtraction a (b + 1) xs'\n    where\n        ex = take a $ drop b xs\n\nmain = do\n    q <- getFiled =<< readLn\n    n <- readLn\n    p <- getFiled n\n    putStrLn $ concatMap (format . fst) $ matchPattern p $ extraction n q\n    where\n        getFiled n = map words <$> replicateM n getLine\n        matchPattern p = filter (\\t -> p == snd t)\n\nformat (y, x)  = show y ++ \" \" ++ show x\n```\n###\u30b5\u30f3\u30bf\u670d\n```\nimport Control.Applicative\nimport Control.Monad\nimport Data.List\n\ndata Block =  Block {x1 :: Int, x2 :: Int,\n                     y1 :: Int, y2 :: Int} deriving (Show)\n\ninstance Eq Block \n    where \n        a == b = diffX a + diffY a == diffX b + diffY b\n\ninstance Ord Block \n    where \n        compare a b = compare (diffX a + diffY a) (diffX b + diffY b)\n\ndiffX, diffY :: Block -> Int\ndiffX b = x2 b - x1 b\ndiffY b = y2 b - y1 b\n\nmain = do\n    [x, y, z, n] <- map read . words <$> getLine\n    cutPosition <- map words <$> replicateM n getLine\n    let b = minimum $ foldl cut [Block 0 x 0 y] cutPosition\n    print $ (diffX b) * (diffY b) * z\n\ncut :: [Block] -> [String] -> [Block]\ncut xs [a, b] \n    | a == \"0\" = concatMap (cutX $ read b) xs\n    | a == \"1\" = concatMap (cutY $ read b) xs\n\ncutX, cutY :: Int -> Block -> [Block]\ncutX a b = if isCut x1 x2 a b then [b {x2 = a}, b {x1 = a}] else [b]\ncutY a b = if isCut y1 y2 a b then [b {y2 = a}, b {y1 = a}] else [b]\n\nisCut p1 p2 a block = p1 block <= a && a <= p2 block\n```\n###\u6c34\u7740\uff08\u3067\u304d\u3066\u306a\u3044\uff09\ntest case4\u4ee5\u964d\u3067\u5931\u6557\n\u6642\u9593\u5207\u308c\n\n```\nfact :: Integer -> Integer\nfact n = product [1..n]\n\nheadTrim :: String -> String\nheadTrim = dropWhile (== '0')\n\ntailTrim :: String -> String\ntailTrim  = twirl headTrim\n\nextraction :: [a] -> [a]\nextraction = twirl (take 9)\n\ntwirl f = reverse . f . reverse\n\nmain = do\n    n <- readLn\n    putStrLn $ headTrim . extraction . tailTrim . show $ fact n\n```\n", "tags": ["Haskell", "paiza"]}