{"context": " More than 1 year has passed since last update.If you're willing to go and use immutable-js for your data interaction, it can be quite easy to use it.\n\nShould you use it?\n\nPros:\n\nImmutable.is() makes checks for changes to props trivial\nEasy to just compare references instead\nEasily converted into vanilla JS objects\nDon't have to use React.addons.update and its ugly syntax\nMerging objects is trivial\nSimple, easy to understand API\nImmutable\nAbility to show your neckbearded FP friends who's Daddy Neckbeard\n\n\nCons:\n\nImmutable.is() can blur the line between ref and value checking\nDoesn't deal with vanilla JS objects, need to keep as Immutable objects until conversion is needed\nExtra dependency outside of React (react w/addons vs another dependency)\nUnfamiliar method names for uninterested/not-neckbearded people\nNeed to either deal with autocompleting Immutable or come up with a good name to use as an imported module\nForces consumers of your library/components to use it also, unless you're willing to swallow the cost of doing conversions/deep compares all the time\nCan't just mutate properties of objects directly\n\n\nCon Example\nTake this block of code:\ncomponentDidUpdate: function (prevProps) {\n    if (!Immutable.is(this.props.chart, prevProps.chart)) {\n      this.state.chartInstance.destroy();\n      this.initializeChart();\n    }\n    if (!Immutable.is(this.props.width, prevProps.width) ||\n        !Immutable.is(this.props.height, prevProps.height)) {\n      this.state.chartInstance.setSize(this.props.width, this.props.height);\n    }\n    // prevent re-render\n    return false;\n  },\n\nIn the first Immutable.is call, we are simply looking for a ref check between the previous chart and the current chart to look for changes.\nIn the second Immutable.is call, we are actually looking for the value change between the previous width and height and the current.\nThis isn't actually too surprising, but could catch people off guard.\n\nPro Example\nCompare these two blocks of code:\nvar chartOptions = React.addons.update(chartModel, {\n  chart: {\n    renderTo: {$set: this.refs.myChart.getDOMNode()},\n    width: {$set: this.props.width || null},\n    height: {$set: this.props.height || null}\n  },\n  series: {$set: this.props.series}\n});\nvar chartInstance = new Highcharts.Chart(chartOptions);\n  this.setState({\n  chartInstance: chartInstance\n});\n\nvar chartOptions = Immutable.Map({\n  chart: {\n    renderTo: this.refs.myChart.getDOMNode(),\n    width: this.props.width || null,\n    height: this.props.height || null,\n  },\n  series: this.props.series\n});\nvar chartModel = this.props.chart.merge(chartOptions);\nthis.setState({\n  chartInstance: new global.Highcharts.Chart(chartModel.toJS())\n});\n\nI think the the legibility and ease of use of immutable-js far outweighs the benefit of using vanilla JS objects using React.addons.update.\n\n\u767e\u805e\u306f\u4e00\u898b\u306b\u3057\u304b\u305a?\nAs always, better to see for yourself if it's worth using. Compare the code for React.addons.update and immutable-js and decide for yourself.\n(I will probably be using both, depending on the situation...)\n\nIf you're willing to go and use immutable-js for your data interaction, it can be quite easy to use it.\n\n#Should you use it?\n\n###Pros:\n\n* Immutable.is() makes checks for changes to props trivial\n\n* Easy to just compare references instead\n\n* Easily converted into vanilla JS objects\n\n* Don't have to use React.addons.update and its ugly syntax\n\n* Merging objects is trivial\n\n* Simple, easy to understand API\n\n* Immutable\n\n* Ability to show your neckbearded FP friends who's Daddy Neckbeard\n\n###Cons:\n\n* Immutable.is() can blur the line between ref and value checking\n\n* Doesn't deal with vanilla JS objects, need to keep as Immutable objects until conversion is needed\n\n* Extra dependency outside of React (react w/addons vs another dependency)\n\n* Unfamiliar method names for uninterested/not-neckbearded people\n\n* Need to either deal with autocompleting Immutable or come up with a good name to use as an imported module\n\n* Forces consumers of your library/components to use it also, unless you're willing to swallow the cost of doing conversions/deep compares all the time\n\n* Can't just mutate properties of objects directly\n\n##Con Example\n\nTake this block of code:\n\n```javascript\ncomponentDidUpdate: function (prevProps) {\n    if (!Immutable.is(this.props.chart, prevProps.chart)) {\n      this.state.chartInstance.destroy();\n      this.initializeChart();\n    }\n    if (!Immutable.is(this.props.width, prevProps.width) ||\n        !Immutable.is(this.props.height, prevProps.height)) {\n      this.state.chartInstance.setSize(this.props.width, this.props.height);\n    }\n    // prevent re-render\n    return false;\n  },\n```\n\nIn the first Immutable.is call, we are simply looking for a ref check between the previous `chart` and the current `chart` to look for changes.\n\nIn the second Immutable.is call, we are actually looking for the value change between the previous `width` and `height` and the current.\n\nThis isn't actually too surprising, but could catch people off guard.\n\n##Pro Example\n\nCompare these two blocks of code:\n\n```javascript\nvar chartOptions = React.addons.update(chartModel, {\n  chart: {\n    renderTo: {$set: this.refs.myChart.getDOMNode()},\n    width: {$set: this.props.width || null},\n    height: {$set: this.props.height || null}\n  },\n  series: {$set: this.props.series}\n});\nvar chartInstance = new Highcharts.Chart(chartOptions);\n  this.setState({\n  chartInstance: chartInstance\n});\n```\n\n```javascript\nvar chartOptions = Immutable.Map({\n  chart: {\n    renderTo: this.refs.myChart.getDOMNode(),\n    width: this.props.width || null,\n    height: this.props.height || null,\n  },\n  series: this.props.series\n});\nvar chartModel = this.props.chart.merge(chartOptions);\nthis.setState({\n  chartInstance: new global.Highcharts.Chart(chartModel.toJS())\n});\n```\n\nI think the the legibility and ease of use of immutable-js far outweighs the benefit of using vanilla JS objects using React.addons.update.\n\n#\u767e\u805e\u306f\u4e00\u898b\u306b\u3057\u304b\u305a?\n\nAs always, better to see for yourself if it's worth using. Compare the code for [React.addons.update](https://github.com/kimagure/highcharts-mori-test/blob/react-update/resizing-highchart.html#L47) and [immutable-js](https://github.com/kimagure/fb-immutable-highcharts-demo/blob/master/src/main.js#L6) and decide for yourself.\n\n(I will probably be using both, depending on the situation...)\n", "tags": ["reactjs", "highcharts", "immutable-js", "JavaScript"]}