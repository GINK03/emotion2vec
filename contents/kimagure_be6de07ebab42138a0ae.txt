{"context": " More than 1 year has passed since last update.In between seeing the sights in Nagoya, doing some RxJSNext stuff, and eating konbini food, I've been trying to play around with FlowType. It's a gradual typing tool that works fairly well, except for some bits that aren't really documented that well or are known issues that aren't really documented a lot (i.e. is common knowledge amongst people at FB and long-term FlowType users, but surprising to others). It's pretty nice overall though, and I encourage you to try it out.\n\nThe problem\nWhile Flow is pretty good at figuring out what is going on in your code even if you give it minimal type annotations, it doesn't really know how to figure out what all the code in the known universe (i.e. your node_modules) is going to. The guide that is on the FlowType docs here continues on to here and explains the gist of it pretty well, but leaves out a big part: Flow will prefer the original files in your node_modules over your typedefs, so you need to ignore the original files in your .flowconfig to get this to work.\n\nSetup\nI'm working off of my original redux-rx-fun project, so let's go over what all's in my .flowconfig for that project:\n[ignore]\nbuild <-- ignore the build output of my project\n.*/node_modules/redux/.* <-- don't try to infer from redux sources\n.*/node_modules/rx/.* <-- don't try to infer from rx sources\n.*/node_modules/react/.* <-- don't try to infer from react sources\n.*/node_modules/fbjs.* <-- don't try to infer from fbjs sources\n.*/node_modules/babel.* <-- don't try to infer from babel sources\n.*/node_modules/babylon.* <-- don't try to infer from babylon sources\n\n[include]\n\n[libs]\ninterfaces/ <-- DO use the definitions from my declared interfaces\n\n[options]\nesproposal.class_static_fields=enable <-- enable static class properties (they aren't ES6)\n\nWhy ignore all of these? Well...\n\nWe don't need to check a whole lot of Webpack/Babel generated code.\nWe are going to define Redux and Rx interfaces ourselves.\nFlow ships with React definitions, so you need to ignore the sources.\nFBJS is broken, so it makes Flow unhappy. Don't worry, we don't need to check it really.\nBabel also is not Flow-happy, but we don't really care.\nBabylon is also not Flow-happy, but we don't really care.\n\nSo now that we have our setup, let's go take a look at our definitions.\n\nDefinitions\n\nRedux\nLet's start with the Redux definitions, since these are simple enough.\n// Finally, declare the module 'redux' that will be imported in our files\ndeclare module 'redux' {\n  // declare the \"Reducer\" type for Redux, a function of state and action.\n  declare type Reducer<T, R> = (state: T, action: R) => T;\n\n  // declare the type of the \"Store\" in Redux (as far as we care, that is).\n  declare interface Store<T, R> {\n    subscribe(observer: () => void): void;\n    dispatch(action: R): void;\n    getState(): T;\n  }\n\n  // createStore takes our Reducer and produces a Store. Simple as that.\n  declare function createStore<T, R>(reducer: Reducer<T, R>): Store<T, R>;\n}\n\nYou can go look at the usages and see that while they don't explicitly have annotations everywhere, they match and Flow will catch errors (e.g. here)\n\nRx\nThen we have our Rx definitions, which are more complex, but really nothing special.\ndeclare module 'rx' {\n  // declare an Observable that boxes values of type T\n  declare class Observable<T> {\n    // merge can really take any type and merge them together, but I figured it's easiest\n    // to handle it this way.\n    static merge<R>(...sources: Observable<R>[]): Observable<R>;\n\n    // similar story with map -- map can project in other types (probably what you want usually).\n    map<R>(f: (item: T) => R): Observable<R>;\n\n    // scan will take the values of type T, sure,\n    // but it will accumulate something of a different type usually.\n    scan<R>(f: (prev: R, next: T) => R): Observable<R>;\n\n    // You might prefer startWith with type T, but I often use startWith to provide\n    // an event for my Observables using scan, which also will be used on subsequent\n    // streams as the \"prev\" value I defined above.\n    // This means my Observable is effectively [R, ...T[]], sure, which means that\n    // really my Observable is of type Observable<R|T>, but this is fine with me.\n    // More strict people might be offended.\n    startWith<R>(init: R): Observable<T>;\n\n    // subscribe can take optional arguments, but I'm going to go ahead and\n    // require the \"next\" observer, at the very least.\n    subscribe(\n      next: (item: T) => any,\n      error?: (error: any) => any,\n      complete?: (item: T) => any\n    ): {\n      // this is really a IDisposable in Rx, but I'm kind of lazy and don't plan on using much of it here.\n      unsubscribe: () => void;\n    };\n  }\n\n  // good old Subject, to which you can insert items for events.\n  declare class Subject<T> extends Observable<T> {\n    onNext(item: T): void;\n  }\n}\n\nLikewise, Flow will check our usages of these types (e.g. here).\n\nConclusion\nSo FlowType is really nice and works pretty well, but there are some warts with the way you have to configure it right now. Some of these issues might get fixed in future versions, but for now, this seems to be what all you have to do to get typing working with external dependencies you bring in.\nHopefully this comes up the next time people are googling around trying to figure out their issues with FlowType. At the very least, it'll help shave a couple hours off of trying to read through a bunch of issues or code and trying to ask people what is even going on.\n\nLinks\n\nMy project with FlowType: https://github.com/justinwoo/redux-rx-fun\n\nFlow docs for third party interfaces and declarations:\n\n\nhttp://flowtype.org/docs/third-party.html\nhttp://flowtype.org/docs/declarations.html\n\n\nThe Nuclide codebase, which makes use of interfaces pretty well:\n\n\nhttps://github.com/facebook/nuclide\nhttps://github.com/facebook/nuclide/blob/master/.flowconfig\nhttps://github.com/facebook/nuclide/tree/master/pkg/nuclide/external-interfaces\n\n\n\n\nIn between seeing the sights in Nagoya, doing some RxJSNext stuff, and eating konbini food, I've been trying to play around with FlowType. It's a gradual typing tool that works fairly well, except for some bits that aren't really documented that well or are known issues that aren't really documented a lot (i.e. is common knowledge amongst people at FB and long-term FlowType users, but surprising to others). It's pretty nice overall though, and I encourage you to try it out.\n\n## The problem\n\nWhile Flow is pretty good at figuring out what is going on in your code even if you give it minimal type annotations, it doesn't really know how to figure out what all the code in the known universe (i.e. your `node_modules`) is going to. The guide that is on the FlowType docs [here](http://flowtype.org/docs/third-party.html) continues on to [here](http://flowtype.org/docs/declarations.html) and explains the gist of it pretty well, but leaves out a big part: Flow **will prefer the original files in your `node_modules` over your typedefs**, so you need to **ignore the original files in your `.flowconfig`** to get this to work.\n\n### Setup\n\nI'm working off of my original [redux-rx-fun](https://github.com/justinwoo/redux-rx-fun) project, so let's go over what all's in my `.flowconfig` for that project:\n\n```\n[ignore]\nbuild <-- ignore the build output of my project\n.*/node_modules/redux/.* <-- don't try to infer from redux sources\n.*/node_modules/rx/.* <-- don't try to infer from rx sources\n.*/node_modules/react/.* <-- don't try to infer from react sources\n.*/node_modules/fbjs.* <-- don't try to infer from fbjs sources\n.*/node_modules/babel.* <-- don't try to infer from babel sources\n.*/node_modules/babylon.* <-- don't try to infer from babylon sources\n\n[include]\n\n[libs]\ninterfaces/ <-- DO use the definitions from my declared interfaces\n\n[options]\nesproposal.class_static_fields=enable <-- enable static class properties (they aren't ES6)\n```\n\nWhy ignore all of these? Well...\n\n* We don't need to check a whole lot of Webpack/Babel generated code.\n* We are going to define Redux and Rx interfaces ourselves.\n* Flow ships with React definitions, so you need to ignore the sources.\n* FBJS is broken, so it makes Flow unhappy. Don't worry, we don't need to check it really.\n* Babel also is not Flow-happy, but we don't really care.\n* Babylon is also not Flow-happy, but we don't really care.\n\nSo now that we have our setup, let's go take a look at our definitions.\n\n### Definitions\n\n#### Redux\n\nLet's start with the Redux definitions, since these are simple enough.\n\n```js\n// Finally, declare the module 'redux' that will be imported in our files\ndeclare module 'redux' {\n  // declare the \"Reducer\" type for Redux, a function of state and action.\n  declare type Reducer<T, R> = (state: T, action: R) => T;\n\n  // declare the type of the \"Store\" in Redux (as far as we care, that is).\n  declare interface Store<T, R> {\n    subscribe(observer: () => void): void;\n    dispatch(action: R): void;\n    getState(): T;\n  }\n\n  // createStore takes our Reducer and produces a Store. Simple as that.\n  declare function createStore<T, R>(reducer: Reducer<T, R>): Store<T, R>;\n}\n```\n\nYou can go look at the usages and see that while they don't explicitly have annotations everywhere, they match and Flow will catch errors (e.g. [here](https://github.com/justinwoo/redux-rx-fun/blob/master/src/redux-app.js#L33))\n\n#### Rx\n\nThen we have our Rx definitions, which are more complex, but really nothing special.\n\n```js\ndeclare module 'rx' {\n  // declare an Observable that boxes values of type T\n  declare class Observable<T> {\n    // merge can really take any type and merge them together, but I figured it's easiest\n    // to handle it this way.\n    static merge<R>(...sources: Observable<R>[]): Observable<R>;\n\n    // similar story with map -- map can project in other types (probably what you want usually).\n    map<R>(f: (item: T) => R): Observable<R>;\n\n    // scan will take the values of type T, sure,\n    // but it will accumulate something of a different type usually.\n    scan<R>(f: (prev: R, next: T) => R): Observable<R>;\n\n    // You might prefer startWith with type T, but I often use startWith to provide\n    // an event for my Observables using scan, which also will be used on subsequent\n    // streams as the \"prev\" value I defined above.\n    // This means my Observable is effectively [R, ...T[]], sure, which means that\n    // really my Observable is of type Observable<R|T>, but this is fine with me.\n    // More strict people might be offended.\n    startWith<R>(init: R): Observable<T>;\n\n    // subscribe can take optional arguments, but I'm going to go ahead and\n    // require the \"next\" observer, at the very least.\n    subscribe(\n      next: (item: T) => any,\n      error?: (error: any) => any,\n      complete?: (item: T) => any\n    ): {\n      // this is really a IDisposable in Rx, but I'm kind of lazy and don't plan on using much of it here.\n      unsubscribe: () => void;\n    };\n  }\n\n  // good old Subject, to which you can insert items for events.\n  declare class Subject<T> extends Observable<T> {\n    onNext(item: T): void;\n  }\n}\n```\n\nLikewise, Flow will check our usages of these types (e.g. [here](https://github.com/justinwoo/redux-rx-fun/blob/master/src/rx-app.js#L39-L47)).\n\n## Conclusion\n\nSo FlowType is really nice and works pretty well, but there are some warts with the way you have to configure it right now. Some of these issues might get fixed in future versions, but for now, this seems to be what all you have to do to get typing working with external dependencies you bring in.\n\nHopefully this comes up the next time people are googling around trying to figure out their issues with FlowType. At the very least, it'll help shave a couple hours off of trying to read through a bunch of issues or code and trying to ask people what is even going on.\n\n## Links\n\n* My project with FlowType: https://github.com/justinwoo/redux-rx-fun\n* Flow docs for third party interfaces and declarations:\n  - http://flowtype.org/docs/third-party.html\n  - http://flowtype.org/docs/declarations.html\n* The Nuclide codebase, which makes use of interfaces pretty well:\n  - https://github.com/facebook/nuclide\n  - https://github.com/facebook/nuclide/blob/master/.flowconfig\n  - https://github.com/facebook/nuclide/tree/master/pkg/nuclide/external-interfaces\n", "tags": ["redux", "React", "JavaScript", "flowtype", "RxJS"]}