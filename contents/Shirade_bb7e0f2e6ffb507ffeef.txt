{"context": " More than 1 year has passed since last update.\n\nSecKeyGeneratePair in Swift\nSwift\u3067\u516c\u958b\u9375\u3068\u6697\u53f7\u9375\u3092\u4f5c\u6210\u3057\u3066\u307f\u307e\u3057\u305f\uff0e\n\nCrypto.swift\n\nCrypto.swift\nimport Foundation\nimport CoreFoundation\nimport Security\n\nclass Crypto {\n    func test() {\n        // generating key pair\n        let keyPair: (publicKey: SecKey?, privateKey: SecKey?) = generateKeyPair()\n        // calculate blocksize\n        let blockSize: Int = SecKeyGetBlockSize(keyPair.publicKey!)\n\n        // preparing for encryption\n        let plainText: String = \"sample text to be encrypted and decrypted\"\n        let plainTextData: [UInt8] = [UInt8](plainText.utf8)\n        let plainTextDataLength: Int = plainText.characters.count\n        var encryptedData: [UInt8] = [UInt8](count: Int(blockSize), repeatedValue: 0)\n        var encryptedDataLength: Int = blockSize\n\n        // encrypting\n        let encryptOsStatus: OSStatus = SecKeyEncrypt(keyPair.publicKey!, SecPadding.PKCS1, plainTextData, plainTextDataLength, &encryptedData, &encryptedDataLength)\n        if encryptOsStatus != noErr {\n            print(\"Encryption Error\")\n            return;\n        }\n\n        // preparing for decryption\n        var decryptedData: [UInt8] = [UInt8](count: Int(blockSize), repeatedValue: 0)\n        var decryptedDataLength: Int = blockSize\n\n        // decrypting\n        let decryptOsStatus: OSStatus = SecKeyDecrypt(keyPair.privateKey!, SecPadding.PKCS1, encryptedData, encryptedDataLength, &decryptedData, &decryptedDataLength)\n        if decryptOsStatus != noErr {\n            print(\"Decryption Error\")\n            return;\n        }\n\n        // checking\n        let text: NSString = NSString(bytes: &decryptedData, length: decryptedDataLength, encoding: NSUTF8StringEncoding)!\n        if text.compare(plainText) == NSComparisonResult.OrderedSame {\n            print(\"success\")\n        } else {\n            print(\"failure\")\n        }\n    }\n\n    func generateKeyPair () -> (publicKey: SecKey?, privateKey: SecKey?) {\n        let parameters: [String: AnyObject] = [\n            kSecAttrKeyType as String: kSecAttrKeyTypeRSA,\n            kSecAttrKeySizeInBits as String: 2048\n        ]\n        var publicKey: SecKey?\n        var privateKey: SecKey?\n        let osStatus: OSStatus = SecKeyGeneratePair(parameters, &publicKey, &privateKey)\n        switch osStatus {\n        case noErr:\n            return (publicKey, privateKey)\n        default:\n            // TODO: error handling\n            return (nil, nil)\n        }\n    }\n}\n\nlet crypto = Crypto()\ncrypto.test()\n\n\n\n\n\u4f7f\u3044\u65b9\nXCode Playground \u3067\u52d5\u304f\u306f\u305a\u3067\u3059\uff0e\n\n## SecKeyGeneratePair in Swift\nSwift\u3067\u516c\u958b\u9375\u3068\u6697\u53f7\u9375\u3092\u4f5c\u6210\u3057\u3066\u307f\u307e\u3057\u305f\uff0e\n\n## Crypto.swift\n```swift:Crypto.swift\nimport Foundation\nimport CoreFoundation\nimport Security\n\nclass Crypto {\n    func test() {\n        // generating key pair\n        let keyPair: (publicKey: SecKey?, privateKey: SecKey?) = generateKeyPair()\n        // calculate blocksize\n        let blockSize: Int = SecKeyGetBlockSize(keyPair.publicKey!)\n\n        // preparing for encryption\n        let plainText: String = \"sample text to be encrypted and decrypted\"\n        let plainTextData: [UInt8] = [UInt8](plainText.utf8)\n        let plainTextDataLength: Int = plainText.characters.count\n        var encryptedData: [UInt8] = [UInt8](count: Int(blockSize), repeatedValue: 0)\n        var encryptedDataLength: Int = blockSize\n\n        // encrypting\n        let encryptOsStatus: OSStatus = SecKeyEncrypt(keyPair.publicKey!, SecPadding.PKCS1, plainTextData, plainTextDataLength, &encryptedData, &encryptedDataLength)\n        if encryptOsStatus != noErr {\n            print(\"Encryption Error\")\n            return;\n        }\n\n        // preparing for decryption\n        var decryptedData: [UInt8] = [UInt8](count: Int(blockSize), repeatedValue: 0)\n        var decryptedDataLength: Int = blockSize\n\n        // decrypting\n        let decryptOsStatus: OSStatus = SecKeyDecrypt(keyPair.privateKey!, SecPadding.PKCS1, encryptedData, encryptedDataLength, &decryptedData, &decryptedDataLength)\n        if decryptOsStatus != noErr {\n            print(\"Decryption Error\")\n            return;\n        }\n\n        // checking\n        let text: NSString = NSString(bytes: &decryptedData, length: decryptedDataLength, encoding: NSUTF8StringEncoding)!\n        if text.compare(plainText) == NSComparisonResult.OrderedSame {\n            print(\"success\")\n        } else {\n            print(\"failure\")\n        }\n    }\n\n    func generateKeyPair () -> (publicKey: SecKey?, privateKey: SecKey?) {\n        let parameters: [String: AnyObject] = [\n            kSecAttrKeyType as String: kSecAttrKeyTypeRSA,\n            kSecAttrKeySizeInBits as String: 2048\n        ]\n        var publicKey: SecKey?\n        var privateKey: SecKey?\n        let osStatus: OSStatus = SecKeyGeneratePair(parameters, &publicKey, &privateKey)\n        switch osStatus {\n        case noErr:\n            return (publicKey, privateKey)\n        default:\n            // TODO: error handling\n            return (nil, nil)\n        }\n    }\n}\n\nlet crypto = Crypto()\ncrypto.test()\n\n```\n\n## \u4f7f\u3044\u65b9\nXCode Playground \u3067\u52d5\u304f\u306f\u305a\u3067\u3059\uff0e\n", "tags": ["Swift", "RSA"]}