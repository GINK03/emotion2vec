{"context": "\n\n\u74b0\u5883\nMicrosoft Visual Studio Professional 2012\n\n\u53c2\u8003\nC++11\u306e\u65b0\u6a5f\u80fd\u306e\u3046\u3061\u4fbf\u5229\u305d\u3046\u306a\u3082\u306e\u3092\u81ea\u5206\u7528\u306b\u30e1\u30e2\u308b\u3000\u203b\u3053\u306e\u8a18\u4e8b\u306e\u629c\u7c8b\u306b\u306a\u3063\u3066\u3057\u307e\u3063\u305f\nstd::bind\n\n\u30b9\u30de\u30fc\u30c8\u30dd\u30a4\u30f3\u30bf\nstd::unique_ptr, std::shared_ptr \u7b49\u304c\u8ffd\u52a0\u3002\nboost\u3092\u4f7f\u3046\u5fc5\u8981\u306a\u3057\u3002\n#include <memory>\n\nclass SmartPtr\n{\n  public:\n    SmartPtr()\n    {\n        std::cout << \"new SmartPtr\" << std::endl;\n    }\n    ~SmartPtr()\n    {\n        std::cout << \"delete SmartPtr\" << std::endl;\n    }\n};\n\n// \u30b9\u30de\u30fc\u30c8\u30dd\u30a4\u30f3\u30bf\n{\n    std::unique_ptr<SmartPtr> sp;\n    sp.reset(new SmartPtr());    // new SmartPtr\n}                                // delete SmartPtr\n\n\n\nenum class\nenum\u540d::enum\u9805\u76ee\u540d \u307f\u305f\u3044\u306a\u4f7f\u3044\u65b9\u304c\u3067\u304d\u308b\u3002\n#include <cstdint> // std::uint32_t \u306e\u305f\u3081\n\nenum class EnumTest : std::uint32_t\n{\n    Enum1 = 123,\n    Enum2,\n};\n\n{\n    EnumTest e = EnumTest::Enum1;\n    if (e == EnumTest::Enum1)\n    {\n    }\n} \n\n\n\u30b3\u30f3\u30c6\u30ca\nstd::unordered_map, std::unordered_set, std::array \u7b49\u304c\u8ffd\u52a0\u3002\nboost\u3092\u4f7f\u3046\u5fc5\u8981\u306a\u3057\u3002\n#include <array>\n\n{\n    std::array<int, 10> ar = {};\n    ar.fill(5);                  // \u5168\u3066\u306e\u8981\u7d20\u30925\u3067\u57cb\u3081\u308b\u3002\n    for (auto const &a : ar)     // for \u306b\u3064\u3044\u3066\u306f\u5f8c\u8ff0\u3002\n    {\n        std::cout << a << std::endl;   // 5/5/5/5/...\n    }\n}\n\n\n\nfor\n\u9006\u9806\u306f\u306a\u3044\u307f\u305f\u3044\u3002\n\u305d\u306e\u5206\u307e\u3060boost/foreach.hpp\u3092\u4f7f\u3046\u65b9\u304c\u3044\u3044\u304b\u3082\u3002\n\n#include <string>\n#include <vector>\n#include <unordered_map>\n\n{\n    // \u30b3\u30f3\u30c6\u30ca\u306b\u5bfe\u3057\u3066\u30a4\u30c6\u30ec\u30fc\u30b7\u30e7\u30f3\u3059\u308b\n    std::vector<std::string> vec;\n    vec.push_back(\"first\");\n    vec.push_back(\"second\");\n    for (auto const &v : vec)\n    {\n        std::cout << v << std::endl;                                       // first/second\n    }\n\n    // \u30de\u30c3\u30d7\n    std::unordered_map<int, std::string> map;\n    map[-10] = \"minus 10\";\n    map[ 32] = \"plus  32\";\n\n    // v.first/v.second \u3067\u30a2\u30af\u30bb\u30b9\n    for (auto const &v : map)\n    {\n        std::cout << \"[\" << v.first << \"] : \" << v.second << std::endl;    // [-10] : minus10/[32] : plus 32\n    }\n\n\nstd::begin, std::end\nSTL\u30b3\u30f3\u30c6\u30ca\u4ee5\u5916\u306b\u3082\u4f7f\u7528\u3067\u304d\u308b\u3002\n#include <iostream>\n#include <algorithm>\n\n{\n    int arr[12] = {1,2,3,4,5,6,7,8,9,10,11,12};\n    std::cout << \"for : \";\n    for (auto a : arr)\n    {\n        std::cout << a << \",\";                       // for : 1,2,3,4,5,6,7,8,9,10,11,12\n    }\n    std::cout << std::endl;\n\n    // std::begin/std::end\n    int* p = std::find(std::begin(arr), std::end(arr), 3);\n    if (p != std::end(arr))\n    {\n        std::cout << \"find : \" << *p << std::endl;   // find : 3\n    }\n    std::fill(std::begin(arr), std::end(arr), 256);\n    std::cout << \"fill : \";\n    for (auto a : arr)\n    {\n        std::cout << a << \",\";                       // fill : 256,256,...256,\n    }\n    std::cout << std::endl;\n}\n\n\nnullptr\nNULL\u3067\u306f\u306a\u304fnullptr\u3092\u4f7f\u3046\u3002\n\n\u578b\u63a8\u8ad6\nauto \u3084 decltype \u3067\u578b\u3092\u81ea\u52d5\u5224\u5b9a\u3059\u308b\u3002\n\u95a2\u6570\u3067\u3082\u3044\u3051\u308b\u3002\nfloat getFloat()\n{\n    return 1.53f;\n}\n\n{\n    // decltype\n    decltype(getFloat()) d = getFloat();\n    std::cout << \"decltype(getFloat()) d is \" << d << std::endl;  // decltype(getFloat()) d is 1.53\n\n    // auto\n    auto dd = d;\n    const auto& myprintf = printf;\n    myprintf(\"myprintf %f\\n\", dd);                                // myprintf 1.530000\n}\n\n\nstatic assert\n\u540c\u3058\u304fboost\u3092\u4f7f\u308f\u306a\u3044\u3067\u3088\u304f\u306a\u3063\u305f\u3002\n{\n    static const int test[] =\n    {\n        0, 1, 2, 3,\n    };\n\n    // NG\n    //static_assert((sizeof(test)/sizeof(int)) == 3, \"test is invalid size.\");\n    // OK\n    static_assert((sizeof(test)/sizeof(int)) == 4, \"test is invalid size.\");\n}\n\n\n\n\u30e9\u30e0\u30c0\u5f0f\nauto \u3068\u7d44\u307f\u5408\u308f\u305b\u3066\u4f7f\u3044\u3084\u3059\u304f\u306a\u3063\u305f\u6c17\u304c\u3059\u308b\u3002\n{\n    int z = 2;\n    auto func1 = [](int x) {\n        return x * x;\n    };\n    auto func2 = [&z](int x) {\n        int ret = z*x;\n        --z;\n        return ret;\n    };\n    std::cout << \"func1() = \" << func1(3) << std::endl;   // func1() = 9\n    std::cout << \"func2() = \" << func2(3) << std::endl;   // func2() = 6\n    std::cout << \"z       = \" << z        << std::endl;   // z       = 1\n}\n\n\nstd::function, std::bind\n\u3082\u3068\u3082\u3068\u3042\u3063\u305f\u3068\u601d\u3046\u3093\u3060\u3051\u3069\u3001\u4f7f\u3044\u3084\u3059\u304f\u306a\u3063\u305f\u3002\nboost::bind \u3068\u304b\u306f\u4f7f\u3046\u5fc5\u8981\u306a\u304f\u306a\u3063\u305f\u3002\n#include <functional>\n\nclass LumdaFunc\n{\n  public:\n    LumdaFunc() : member(0), func() {};\n    ~LumdaFunc() {};\n\n    void make(int x)\n    {\n        member = x;\n        auto f = [this]() {\n            std::cout << \"member is \" << member << std::endl;\n        };\n        func = f;\n    }\n    void call()\n    {\n        func();\n    }\n\n  private:\n    int member;\n    std::function<void ()> func;\n};\n\nclass BindMethod\n{\n  public:\n    BindMethod(int m) : member(m) {};\n    ~BindMethod() {};\n\n    void bindMethod(int x)\n    {\n        std::cout << \"bindMethod : \" << member << \", and next is \" << x << std::endl;\n        member = x;\n    }\n\n  private:\n    int member;\n};\n\nint bindFunc(int x, int y, int& z)\n{\n    ++z;\n    std::cout << \"x is \" << x << \", y is \" << y << std::endl;\n    return z;\n}\n\n{\n    LumdaFunc lf;\n    lf.make(3);\n    lf.call();    // member is 3\n\n    // bind\n    int opt = 32;\n    auto f1 = std::bind(bindFunc, std::placeholders::_1, std::placeholders::_2, std::ref(opt));\n    f1(1,2);                                                    // x is 1, y is 2\n    std::cout << \"after f1(1,2), opt is \" << opt << std::endl;  // after f1(1,2), opt is 33\n\n    // \u30af\u30e9\u30b9\u306e\u30e1\u30bd\u30c3\u30c9\u306b bind\n    BindMethod bm(512);\n    auto f2 = std::bind(&BindMethod::bindMethod, bm, std::placeholders::_1);\n    f2(1024);     // bindMethod : 512, and next is 1024\n    f2(2048);     // bindMethod : 1024, and next is 2048\n}\n\n\n\n\u30b3\u30fc\u30c9\u5168\u4f53\n#include <memory>\n#include <array>\n#include <functional>\n#include <string>\n#include <vector>\n#include <unordered_map>\n#include <cstdint>\n#include <iostream>\n\nnamespace\n{\n\n    // \u30b9\u30de\u30fc\u30c8\u30dd\u30a4\u30f3\u30bf\n    class SmartPtr\n    {\n      public:\n        SmartPtr()\n        {\n            std::cout << \"new SmartPtr\" << std::endl;\n        }\n        ~SmartPtr()\n        {\n            std::cout << \"delete SmartPtr\" << std::endl;\n        }\n    };\n\n    // enum class\n    enum class EnumTest : std::uint32_t\n    {\n        Enum1 = 123,\n        Enum2,\n    };\n\n    // decltype\n    float getFloat()\n    {\n        return 1.53f;\n    }\n\n    // override\n    class Base\n    {\n      public:\n        Base() : member(0) {};\n        virtual ~Base() {};\n\n        virtual void setBase(int a)\n        {\n            member = a;\n        }\n\n      private:\n        int member;\n    };\n    class Inherited : public Base\n    {\n      public:\n        Inherited() : Base(), inherited_member(0) {};\n        ~Inherited() {};\n\n        virtual void setBase(int a) override\n        {\n            inherited_member = a;\n        }\n\n      private:\n        int inherited_member;\n    };\n\n    // lumda/function\n    class LumdaFunc\n    {\n      public:\n        LumdaFunc() : member(0), func() {};\n        ~LumdaFunc() {};\n\n        void make(int x)\n        {\n            member = x;\n            auto f = [this]() {\n                std::cout << \"member is \" << member << std::endl;\n            };\n            func = f;\n        }\n        void call()\n        {\n            func();\n        }\n\n      private:\n        int member;\n        std::function<void ()> func;\n    };\n\n    // function\n    class BindMethod\n    {\n      public:\n        BindMethod(int m) : member(m) {};\n        ~BindMethod() {};\n\n        void bindMethod(int x)\n        {\n            std::cout << \"bindMethod : \" << member << \", and next is \" << x << std::endl;\n            member = x;\n        }\n\n      private:\n        int member;\n    };\n\n    int bindFunc(int x, int y, int& z)\n    {\n        ++z;\n        std::cout << \"x is \" << x << \", y is \" << y << std::endl;\n        return z;\n    }\n}\n\n\nint main()\n{\n\n    // \u958b\u59cb\n    std::cout << \"cpp11 test.\" << std::endl;\n\n    // \u30b9\u30de\u30fc\u30c8\u30dd\u30a4\u30f3\u30bf\n    {\n        std::unique_ptr<SmartPtr> sp;\n        sp.reset(new SmartPtr());\n    }\n\n    // enum class\n    {\n        EnumTest e = EnumTest::Enum1;\n        if (e == EnumTest::Enum1)\n        {\n            std::cout << \"enum1 \" << static_cast<std::uint32_t>(EnumTest::Enum1) << std::endl;\n            std::cout << \"enum2 \" << static_cast<std::uint32_t>(EnumTest::Enum2) << std::endl;\n        }\n    } \n\n    // array\n    {\n        std::array<int, 10> ar = {};\n        ar.fill(5);\n        for (auto const &a : ar)\n        {\n            std::cout << a << std::endl;\n        }\n    }\n\n    // for\n    {\n        std::vector<std::string> vec;\n        vec.push_back(\"first\");\n        vec.push_back(\"second\");\n        for (auto const &v : vec)\n        {\n            std::cout << v << std::endl;\n        }\n\n        // \u30de\u30c3\u30d7\n        std::unordered_map<int, std::string> map;\n        map[-10] = \"minus 10\";\n        map[ 32] = \"plus  32\";\n\n        for (auto const &v : map)\n        {\n            std::cout << \"[\" << v.first << \"] : \" << v.second << std::endl;\n        }\n    }\n\n    // \u578b\u63a8\u8ad6\n    {\n        // decltype\n        decltype(getFloat()) d = getFloat();\n        std::cout << \"decltype(getFloat()) d is \" << d << std::endl;\n\n        // auto\n        auto dd = d;\n        const auto& myprintf = printf;\n        myprintf(\"myprintf %f\\n\", dd);\n    }\n\n    // static assert\n    {\n        static const int test[] =\n        {\n            0, 1, 2, 3,\n        };\n\n        // NG\n        //static_assert((sizeof(test)/sizeof(int)) == 3, \"test is invalid size.\");\n        // OK\n        static_assert((sizeof(test)/sizeof(int)) == 4, \"test is invalid size.\");\n    }\n\n    // lumda\n    {\n        int z = 2;\n        auto func1 = [](int x) {\n            return x * x;\n        };\n        auto func2 = [&z](int x) {\n            int ret = z*x;\n            --z;\n            return ret;\n        };\n        std::cout << \"func1() = \" << func1(3) << std::endl;\n        std::cout << \"func2() = \" << func2(3) << std::endl;\n        std::cout << \"z       = \" << z        << std::endl;\n    }\n\n    // function\n    {\n        LumdaFunc lf;\n        lf.make(3);\n        lf.call();\n\n        // bind\n        int opt = 32;\n        auto f1 = std::bind(bindFunc, std::placeholders::_1, std::placeholders::_2, std::ref(opt));\n        f1(1,2);\n        std::cout << \"after f1(1,2), opt is \" << opt << std::endl;\n\n        // \u30af\u30e9\u30b9\u306e\u30e1\u30bd\u30c3\u30c9\u306b bind\n        BindMethod bm(512);\n        auto f2 = std::bind(&BindMethod::bindMethod, bm, std::placeholders::_1);\n        f2(1024);\n        f2(2048);\n    }\n\n    // \u7d42\u4e86\n    std::cin.get();\n\n    return 0;\n}\n\n\n\u51fa\u529b\ncpp11 test.\nnew SmartPtr\ndelete SmartPtr\nenum1 123\nenum2 124\n5\n5\n5\n5\n5\n5\n5\n5\n5\n5\nfirst\nsecond\n[-10] : minus 10\n[32] : plus  32\ndecltype(getFloat()) d is 1.53\nmyprintf 1.530000\nfunc1() = 9\nfunc2() = 6\nz       = 1\nmember is 3\nx is 1, y is 2\nafter f1(1,2), opt is 33\nbindMethod : 512, and next is 1024\nbindMethod : 1024, and next is 2048\n\n# \u74b0\u5883\nMicrosoft Visual Studio Professional 2012\n\n# \u53c2\u8003\n[C++11\u306e\u65b0\u6a5f\u80fd\u306e\u3046\u3061\u4fbf\u5229\u305d\u3046\u306a\u3082\u306e\u3092\u81ea\u5206\u7528\u306b\u30e1\u30e2\u308b](http://qiita.com/k2ymg/items/d4405d2f000688263aab)\u3000\u203b\u3053\u306e\u8a18\u4e8b\u306e\u629c\u7c8b\u306b\u306a\u3063\u3066\u3057\u307e\u3063\u305f\n[std::bind](http://kaworu.jpn.org/cpp/std::bind)\n\n<!--\n# \u578b\u30a8\u30a4\u30ea\u30a2\u30b9\n\u4f7f\u3048\u306a\u3044\u6c17\u304c\u3059\u308b\u3002\u2192\u4f7f\u3048\u306a\u3044\uff01\n\n```cpp\ntypedef int MyNumber;\n```\n\n\u3067\u306f\u306a\u304f\n\n```cpp\nusing MyNumber = int;\n```\n\n\u3092\u4f7f\u3046\u3002\ntemplate\u3082\u4f7f\u3048\u308b\u306e\u3067\u4e0a\u4f4d\u4e92\u63db\u3063\u307d\u3044\u3002\n\n```cpp\ntemplate<class Value>\nusing MyVector = std::vector<Value>;\n```\n-->\n\n# \u30b9\u30de\u30fc\u30c8\u30dd\u30a4\u30f3\u30bf\nstd::unique_ptr, std::shared_ptr \u7b49\u304c\u8ffd\u52a0\u3002\nboost\u3092\u4f7f\u3046\u5fc5\u8981\u306a\u3057\u3002\n\n```cpp\n#include <memory>\n\nclass SmartPtr\n{\n  public:\n    SmartPtr()\n    {\n        std::cout << \"new SmartPtr\" << std::endl;\n    }\n    ~SmartPtr()\n    {\n        std::cout << \"delete SmartPtr\" << std::endl;\n    }\n};\n\n// \u30b9\u30de\u30fc\u30c8\u30dd\u30a4\u30f3\u30bf\n{\n    std::unique_ptr<SmartPtr> sp;\n    sp.reset(new SmartPtr());    // new SmartPtr\n}                                // delete SmartPtr\n\n```\n\n# enum class\n\nenum\u540d::enum\u9805\u76ee\u540d \u307f\u305f\u3044\u306a\u4f7f\u3044\u65b9\u304c\u3067\u304d\u308b\u3002\n\n```cpp\n#include <cstdint> // std::uint32_t \u306e\u305f\u3081\n\nenum class EnumTest : std::uint32_t\n{\n    Enum1 = 123,\n    Enum2,\n};\n\n{\n    EnumTest e = EnumTest::Enum1;\n    if (e == EnumTest::Enum1)\n    {\n    }\n} \n```\n\n# \u30b3\u30f3\u30c6\u30ca\n\nstd::unordered_map, std::unordered_set, std::array \u7b49\u304c\u8ffd\u52a0\u3002\nboost\u3092\u4f7f\u3046\u5fc5\u8981\u306a\u3057\u3002\n\n```cpp\n#include <array>\n\n{\n    std::array<int, 10> ar = {};\n    ar.fill(5);                  // \u5168\u3066\u306e\u8981\u7d20\u30925\u3067\u57cb\u3081\u308b\u3002\n    for (auto const &a : ar)     // for \u306b\u3064\u3044\u3066\u306f\u5f8c\u8ff0\u3002\n    {\n        std::cout << a << std::endl;   // 5/5/5/5/...\n    }\n}\n\n```\n\n# for\n\u9006\u9806\u306f\u306a\u3044\u307f\u305f\u3044\u3002\n\u305d\u306e\u5206\u307e\u3060boost/foreach.hpp\u3092\u4f7f\u3046\u65b9\u304c\u3044\u3044\u304b\u3082\u3002\n\n```cpp\n\n#include <string>\n#include <vector>\n#include <unordered_map>\n\n{\n    // \u30b3\u30f3\u30c6\u30ca\u306b\u5bfe\u3057\u3066\u30a4\u30c6\u30ec\u30fc\u30b7\u30e7\u30f3\u3059\u308b\n    std::vector<std::string> vec;\n    vec.push_back(\"first\");\n    vec.push_back(\"second\");\n    for (auto const &v : vec)\n    {\n        std::cout << v << std::endl;                                       // first/second\n    }\n\n    // \u30de\u30c3\u30d7\n    std::unordered_map<int, std::string> map;\n    map[-10] = \"minus 10\";\n    map[ 32] = \"plus  32\";\n\n    // v.first/v.second \u3067\u30a2\u30af\u30bb\u30b9\n    for (auto const &v : map)\n    {\n        std::cout << \"[\" << v.first << \"] : \" << v.second << std::endl;    // [-10] : minus10/[32] : plus 32\n    }\n```\n\n# std::begin, std::end\nSTL\u30b3\u30f3\u30c6\u30ca\u4ee5\u5916\u306b\u3082\u4f7f\u7528\u3067\u304d\u308b\u3002\n\n```cpp\n#include <iostream>\n#include <algorithm>\n\n{\n    int arr[12] = {1,2,3,4,5,6,7,8,9,10,11,12};\n    std::cout << \"for : \";\n    for (auto a : arr)\n    {\n        std::cout << a << \",\";                       // for : 1,2,3,4,5,6,7,8,9,10,11,12\n    }\n    std::cout << std::endl;\n\n    // std::begin/std::end\n    int* p = std::find(std::begin(arr), std::end(arr), 3);\n    if (p != std::end(arr))\n    {\n        std::cout << \"find : \" << *p << std::endl;   // find : 3\n    }\n    std::fill(std::begin(arr), std::end(arr), 256);\n    std::cout << \"fill : \";\n    for (auto a : arr)\n    {\n        std::cout << a << \",\";                       // fill : 256,256,...256,\n    }\n    std::cout << std::endl;\n}\n```\n\n# nullptr\n\nNULL\u3067\u306f\u306a\u304fnullptr\u3092\u4f7f\u3046\u3002\n\n# \u578b\u63a8\u8ad6\nauto \u3084 decltype \u3067\u578b\u3092\u81ea\u52d5\u5224\u5b9a\u3059\u308b\u3002\n\u95a2\u6570\u3067\u3082\u3044\u3051\u308b\u3002\n\n```cpp\nfloat getFloat()\n{\n    return 1.53f;\n}\n\n{\n    // decltype\n    decltype(getFloat()) d = getFloat();\n    std::cout << \"decltype(getFloat()) d is \" << d << std::endl;  // decltype(getFloat()) d is 1.53\n\n    // auto\n    auto dd = d;\n    const auto& myprintf = printf;\n    myprintf(\"myprintf %f\\n\", dd);                                // myprintf 1.530000\n}\n```\n\n# static assert\n\u540c\u3058\u304fboost\u3092\u4f7f\u308f\u306a\u3044\u3067\u3088\u304f\u306a\u3063\u305f\u3002\n\n```cpp\n{\n    static const int test[] =\n    {\n        0, 1, 2, 3,\n    };\n\n    // NG\n    //static_assert((sizeof(test)/sizeof(int)) == 3, \"test is invalid size.\");\n    // OK\n    static_assert((sizeof(test)/sizeof(int)) == 4, \"test is invalid size.\");\n}\n\n```\n\n<!--\n# \u30b3\u30f3\u30b9\u30c8\u30e9\u30af\u30bf\n\u30e1\u30f3\u30d0\u306e\u521d\u671f\u5024\u3092\u6307\u5b9a\u3067\u304d\u308b\u3002\u3000\u2192 \u3067\u304d\u306a\u3044\u3002\n\u4ed6\u306e\u5f62\u5f0f\u306e\u30b3\u30f3\u30b9\u30c8\u30e9\u30af\u30bf\u3092\u547c\u3079\u308b\u3088\u3046\u306b\u306a\u3063\u305f\u3002\u3000\u2192 \u3046\u305d\u3002\u3067\u304d\u306a\u3044\u3002\n-->\n\n# \u30e9\u30e0\u30c0\u5f0f\nauto \u3068\u7d44\u307f\u5408\u308f\u305b\u3066\u4f7f\u3044\u3084\u3059\u304f\u306a\u3063\u305f\u6c17\u304c\u3059\u308b\u3002\n\n```cpp\n{\n    int z = 2;\n    auto func1 = [](int x) {\n        return x * x;\n    };\n    auto func2 = [&z](int x) {\n        int ret = z*x;\n        --z;\n        return ret;\n    };\n    std::cout << \"func1() = \" << func1(3) << std::endl;   // func1() = 9\n    std::cout << \"func2() = \" << func2(3) << std::endl;   // func2() = 6\n    std::cout << \"z       = \" << z        << std::endl;   // z       = 1\n}\n```\n\n# std::function, std::bind\n\u3082\u3068\u3082\u3068\u3042\u3063\u305f\u3068\u601d\u3046\u3093\u3060\u3051\u3069\u3001\u4f7f\u3044\u3084\u3059\u304f\u306a\u3063\u305f\u3002\nboost::bind \u3068\u304b\u306f\u4f7f\u3046\u5fc5\u8981\u306a\u304f\u306a\u3063\u305f\u3002\n\n```cpp\n#include <functional>\n\nclass LumdaFunc\n{\n  public:\n    LumdaFunc() : member(0), func() {};\n    ~LumdaFunc() {};\n\n    void make(int x)\n    {\n        member = x;\n        auto f = [this]() {\n            std::cout << \"member is \" << member << std::endl;\n        };\n        func = f;\n    }\n    void call()\n    {\n        func();\n    }\n\n  private:\n    int member;\n    std::function<void ()> func;\n};\n\nclass BindMethod\n{\n  public:\n    BindMethod(int m) : member(m) {};\n    ~BindMethod() {};\n\n    void bindMethod(int x)\n    {\n        std::cout << \"bindMethod : \" << member << \", and next is \" << x << std::endl;\n        member = x;\n    }\n\n  private:\n    int member;\n};\n\nint bindFunc(int x, int y, int& z)\n{\n    ++z;\n    std::cout << \"x is \" << x << \", y is \" << y << std::endl;\n    return z;\n}\n\n{\n    LumdaFunc lf;\n    lf.make(3);\n    lf.call();    // member is 3\n\n    // bind\n    int opt = 32;\n    auto f1 = std::bind(bindFunc, std::placeholders::_1, std::placeholders::_2, std::ref(opt));\n    f1(1,2);                                                    // x is 1, y is 2\n    std::cout << \"after f1(1,2), opt is \" << opt << std::endl;  // after f1(1,2), opt is 33\n\n    // \u30af\u30e9\u30b9\u306e\u30e1\u30bd\u30c3\u30c9\u306b bind\n    BindMethod bm(512);\n    auto f2 = std::bind(&BindMethod::bindMethod, bm, std::placeholders::_1);\n    f2(1024);     // bindMethod : 512, and next is 1024\n    f2(2048);     // bindMethod : 1024, and next is 2048\n}\n\n```\n\n\n# \u30b3\u30fc\u30c9\u5168\u4f53\n\n```cpp\n#include <memory>\n#include <array>\n#include <functional>\n#include <string>\n#include <vector>\n#include <unordered_map>\n#include <cstdint>\n#include <iostream>\n\nnamespace\n{\n\n    // \u30b9\u30de\u30fc\u30c8\u30dd\u30a4\u30f3\u30bf\n    class SmartPtr\n    {\n      public:\n        SmartPtr()\n        {\n            std::cout << \"new SmartPtr\" << std::endl;\n        }\n        ~SmartPtr()\n        {\n            std::cout << \"delete SmartPtr\" << std::endl;\n        }\n    };\n\n    // enum class\n    enum class EnumTest : std::uint32_t\n    {\n        Enum1 = 123,\n        Enum2,\n    };\n\n    // decltype\n    float getFloat()\n    {\n        return 1.53f;\n    }\n\n    // override\n    class Base\n    {\n      public:\n        Base() : member(0) {};\n        virtual ~Base() {};\n\n        virtual void setBase(int a)\n        {\n            member = a;\n        }\n\n      private:\n        int member;\n    };\n    class Inherited : public Base\n    {\n      public:\n        Inherited() : Base(), inherited_member(0) {};\n        ~Inherited() {};\n\n        virtual void setBase(int a) override\n        {\n            inherited_member = a;\n        }\n\n      private:\n        int inherited_member;\n    };\n\n    // lumda/function\n    class LumdaFunc\n    {\n      public:\n        LumdaFunc() : member(0), func() {};\n        ~LumdaFunc() {};\n\n        void make(int x)\n        {\n            member = x;\n            auto f = [this]() {\n                std::cout << \"member is \" << member << std::endl;\n            };\n            func = f;\n        }\n        void call()\n        {\n            func();\n        }\n\n      private:\n        int member;\n        std::function<void ()> func;\n    };\n\n    // function\n    class BindMethod\n    {\n      public:\n        BindMethod(int m) : member(m) {};\n        ~BindMethod() {};\n\n        void bindMethod(int x)\n        {\n            std::cout << \"bindMethod : \" << member << \", and next is \" << x << std::endl;\n            member = x;\n        }\n\n      private:\n        int member;\n    };\n\n    int bindFunc(int x, int y, int& z)\n    {\n        ++z;\n        std::cout << \"x is \" << x << \", y is \" << y << std::endl;\n        return z;\n    }\n}\n\n\nint main()\n{\n\n    // \u958b\u59cb\n    std::cout << \"cpp11 test.\" << std::endl;\n\n    // \u30b9\u30de\u30fc\u30c8\u30dd\u30a4\u30f3\u30bf\n    {\n        std::unique_ptr<SmartPtr> sp;\n        sp.reset(new SmartPtr());\n    }\n\n    // enum class\n    {\n        EnumTest e = EnumTest::Enum1;\n        if (e == EnumTest::Enum1)\n        {\n            std::cout << \"enum1 \" << static_cast<std::uint32_t>(EnumTest::Enum1) << std::endl;\n            std::cout << \"enum2 \" << static_cast<std::uint32_t>(EnumTest::Enum2) << std::endl;\n        }\n    } \n\n    // array\n    {\n        std::array<int, 10> ar = {};\n        ar.fill(5);\n        for (auto const &a : ar)\n        {\n            std::cout << a << std::endl;\n        }\n    }\n\n    // for\n    {\n        std::vector<std::string> vec;\n        vec.push_back(\"first\");\n        vec.push_back(\"second\");\n        for (auto const &v : vec)\n        {\n            std::cout << v << std::endl;\n        }\n\n        // \u30de\u30c3\u30d7\n        std::unordered_map<int, std::string> map;\n        map[-10] = \"minus 10\";\n        map[ 32] = \"plus  32\";\n\n        for (auto const &v : map)\n        {\n            std::cout << \"[\" << v.first << \"] : \" << v.second << std::endl;\n        }\n    }\n\n    // \u578b\u63a8\u8ad6\n    {\n        // decltype\n        decltype(getFloat()) d = getFloat();\n        std::cout << \"decltype(getFloat()) d is \" << d << std::endl;\n\n        // auto\n        auto dd = d;\n        const auto& myprintf = printf;\n        myprintf(\"myprintf %f\\n\", dd);\n    }\n\n    // static assert\n    {\n        static const int test[] =\n        {\n            0, 1, 2, 3,\n        };\n\n        // NG\n        //static_assert((sizeof(test)/sizeof(int)) == 3, \"test is invalid size.\");\n        // OK\n        static_assert((sizeof(test)/sizeof(int)) == 4, \"test is invalid size.\");\n    }\n\n    // lumda\n    {\n        int z = 2;\n        auto func1 = [](int x) {\n            return x * x;\n        };\n        auto func2 = [&z](int x) {\n            int ret = z*x;\n            --z;\n            return ret;\n        };\n        std::cout << \"func1() = \" << func1(3) << std::endl;\n        std::cout << \"func2() = \" << func2(3) << std::endl;\n        std::cout << \"z       = \" << z        << std::endl;\n    }\n\n    // function\n    {\n        LumdaFunc lf;\n        lf.make(3);\n        lf.call();\n\n        // bind\n        int opt = 32;\n        auto f1 = std::bind(bindFunc, std::placeholders::_1, std::placeholders::_2, std::ref(opt));\n        f1(1,2);\n        std::cout << \"after f1(1,2), opt is \" << opt << std::endl;\n\n        // \u30af\u30e9\u30b9\u306e\u30e1\u30bd\u30c3\u30c9\u306b bind\n        BindMethod bm(512);\n        auto f2 = std::bind(&BindMethod::bindMethod, bm, std::placeholders::_1);\n        f2(1024);\n        f2(2048);\n    }\n\n    // \u7d42\u4e86\n    std::cin.get();\n\n    return 0;\n}\n\n```\n\n\u51fa\u529b\n\n```\ncpp11 test.\nnew SmartPtr\ndelete SmartPtr\nenum1 123\nenum2 124\n5\n5\n5\n5\n5\n5\n5\n5\n5\n5\nfirst\nsecond\n[-10] : minus 10\n[32] : plus  32\ndecltype(getFloat()) d is 1.53\nmyprintf 1.530000\nfunc1() = 9\nfunc2() = 6\nz       = 1\nmember is 3\nx is 1, y is 2\nafter f1(1,2), opt is 33\nbindMethod : 512, and next is 1024\nbindMethod : 1024, and next is 2048\n```\n", "tags": ["visualstudio2012", "C++11", "C++"]}