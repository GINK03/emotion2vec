{"tags": ["GLSL", "\u6570\u5b66"], "context": "\u53c2\u8003\u8a18\u4e8b:modeling with distance functions\n\nTorus\u8a18\u4e8b\u306e\u5f8c\u7de8\u3067\u3059.\n\u9577\u304b\u3063\u305f!\u3001\u5f0f\u306e\u5c0e\u51fa\u3082\u7d42\u308f\u3063\u305f\u306e\u3067\u3001Torus\u306e\u5f0f\u3092\u3044\u3058\u3063\u3066\u3044\u304d\u305f\u3044\u3068\u601d\u3044\u307e\u3059.\n// length\u4f7f\u308f\u306a\u3044\u65b9\u6cd5\nfloat r = 0.3;\nfloat R = 1.0;\nreturn sqrt(p.x*p.x+p.y*p.y+p.z*p.z + R*R - 2.0 * R * sqrt(p.x*p.x+p.y*p.y) ) - r;\n\n\u65e9\u901f\u5f0f\u3092\u3044\u3058\u3063\u3066\u3044\u3053\u3046\u3068\u601d\u3044\u307e\u3059.\n\nTorus\u304b\u3089Sphere\u3078\u5909\u5f62\n\u611f\u306e\u3044\u3044\u4eba\u306f\u304a\u6c17\u3065\u304d\u304b\u3082\u3057\u308c\u307e\u305b\u3093\u304c\u2026\n\nTorus\u306e\u5f0f\nreturn sqrt(p.x*p.x+p.y*p.y+p.z*p.z + R*R - 2.0 * R * sqrt(p.x*p.x+p.y*p.y) ) - r\n\n\u306e\u5f0f\u306b\nsqrt(p.x*p.x+p.y*p.y+p.z*p.z + R*R - 2.0 * R * sqrt(p.x*p.x+p.y*p.y+\u3010p.z*p.z\u3011) ) - r\n\n\u3010\u3011\u3092\u8ffd\u52a0\u3059\u308b\u3068\u7403\u306b\u306a\u308a\u307e\u3059.\n\u306a\u306e\u3067\u3001\nsqrt(p.x*p.x+p.y*p.y+p.z*p.z + R*R - 2.0 * R * sqrt(p.x*p.x+p.y*p.y+p.z*p.z*abs(sin(time))) ) - r\n\n\u3092\u66f8\u304f\u3068\u7403\u3078\u5909\u5f62\u3059\u308bTorus\u304c\u66f8\u3051\u307e\u3059.\n\n\u5411\u304d\u3092\u5909\u3048\u308b\u306e\u3092\u5909\u5f62\u307d\u304f\u3059\u308b\n\u56de\u8ee2\u3092\u3055\u305b\u305a\u306b\u3001\u5411\u304d\u3092\u5909\u3048\u307e\u3059\u3002\n\n// \u7e26\u5411\u304d(xz)\u304b\u3089\u6a2a\u5411\u304d(xy)\u3078\u5909\u5f62\nreturn sqrt(p.x*p.x+p.y*p.y+p.z*p.z + R*R - 2.0 * R * sqrt(p.x*p.x+p.y*p.y*abs(sin(time))+p.z*p.z*abs(cos(time))) ) - r;\n\n\u3042\u3068\u306f\u3001\u4ee5\u4e0b\u306e\u30b3\u30fc\u30c9\u306b\u6b8b\u9ab8\u304c\u3042\u308b\u306e\u3067\u3001\u30b3\u30fc\u30c9glslsandbox\u306b\u5f35\u308a\u4ed8\u3051\u3066\u30b3\u30e1\u30f3\u30c8\u5916\u3057\u3066\u904a\u3093\u3067\u307f\u3066\u306d.\n\n\u30b3\u30fc\u30c9\n// ============================================================================\n// Torus function\n// ============================================================================\n\nprecision mediump float;\nuniform vec2  resolution;    // resolution (512.0, 512.0)\nuniform vec2  mouse;         // mouse      (-1.0 ~ 1.0)\nuniform float time;          // time       (1second == 1.0)\nuniform sampler2D prevScene; // previous scene texture\n\n// Torus\u306e\u8ddd\u96e2\u95a2\u6570\nfloat dTorus(vec3 p){\n    // Torus\u306e\u8ddd\u96e2\u95a2\u6570\n    // vec2 t = vec2(1.0, 0.3);\n    // vec2 q = vec2(length(p.xz)-t.x,p.y);\n    // return length(q)-t.y;\n\n    // lenght\u4f7f\u308f\u306a\u3044\u65b9\u6cd5\n    // float r = 0.3;\n    // float R = 1.0;\n    // return sqrt(p.x*p.x+p.y*p.y+p.z*p.z + R*R - 2.0 * R * sqrt(p.x*p.x+p.y*p.y) ) - r;\n\n    float r = 0.3;\n    float R = 1.0;\n    // \u6ce2\u9762\u307d\u3044\u3084\u3064\n    // return sqrt(p.x*p.x+p.y*p.y+p.z*p.z + R*R - (3.0-abs(sin(time))) * R * sqrt(p.x*p.x+p.y*p.y) ) - r;\n\n    // Sphere\n    // return sqrt(p.x*p.x+p.y*p.y+p.z*p.z + R*R - 2.0 * R * sqrt(p.x*p.x+p.y*p.y+p.z*p.z) ) - r;\n\n    // Torus\u304b\u3089Sphere\u3078\u5909\u5f62\n    return sqrt(p.x*p.x+p.y*p.y+p.z*p.z + R*R - 2.0 * R * sqrt(p.x*p.x+p.y*p.y+p.z*p.z*abs(sin(time))) ) - r;\n\n    // \u7e26\u5411\u304d(xz)\u304b\u3089\u6a2a\u5411\u304d(xy)\u3078\u5909\u5f62\n    // return sqrt(p.x*p.x+p.y*p.y+p.z*p.z + R*R - 2.0 * R * sqrt(p.x*p.x+p.y*p.y*abs(sin(time))+p.z*p.z*abs(cos(time))) ) - r;\n\n    // xz\u304d\u304b\u3089yz\u3078\u5909\u5f62\n    // return sqrt(p.x*p.x+p.y*p.y+p.z*p.z + R*R - 2.0 * R * sqrt(p.x*p.x*abs(cos(time))+p.y*p.y*abs(sin(time))+p.z*p.z) ) - r;\n\n    // xy\u2192yz\u306b\u56de\u8ee2\u3092\u304b\u3051\u308b\n    // mat3 m_1 = mat3(cos(time), -sin(time), 0, sin(time), cos(time), 0, 0, 0, 1);\n    // mat3 m_2 = mat3(0, 0, 1, cos(time), -sin(time), 0, sin(time), cos(time), 0);\n    // mat3 m_3 = mat3( cos(time),0 , -sin(time), 0, 1, 0, sin(time), 0, cos(time));\n    // p = m_2* m_1 * p;\n    // return sqrt(p.x*p.x+p.y*p.y+p.z*p.z + R*R - 2.0 * R * sqrt(p.x*p.x+p.y*p.y*abs(sin(time))+p.z*p.z*abs(cos(time))) ) - r;\n\n    // // xy\u2192yz\u306b\u9006\u56de\u8ee2\u3082\u8ffd\u52a0\n    // float t = 180.0 * sin(time/100.0);\n    // mat3 m_1 = mat3(cos(t), -sin(t), 0, sin(t), cos(t), 0, 0, 0, 1);\n    // mat3 m_2 = mat3(0, 0, 1, cos(t), -sin(t), 0, sin(t), cos(t), 0);\n    // mat3 m_3 = mat3( cos(t),0 , -sin(t), 0, 1, 0, sin(t), 0, cos(t));\n    // p = m_2* m_1 * p;\n    // return sqrt(p.x*p.x+p.y*p.y+p.z*p.z + R*R - 2.0 * R * sqrt(p.x*p.x+p.y*p.y*abs(sin(time))+p.z*p.z*abs(cos(time))) ) - r;\n\n    // xy\u2192yz\u306b\u9006\u56de\u8ee2\u3082\u8ffd\u52a0\n    // float t = 180.0 * sin(time/100.0);\n    // mat3 m_1 = mat3(cos(t), -sin(t), 0, sin(t), cos(t), 0, 0, 0, 1);\n    // mat3 m_2 = mat3(0, 0, 1, cos(t), -sin(t), 0, sin(t), cos(t), 0);\n    // mat3 m_3 = mat3( cos(t),0 , -sin(t), 0, 1, 0, sin(t), 0, cos(t));\n    // p = m_2* m_1 * p;\n    // return sqrt(p.x*p.x+p.y*p.y+p.z*p.z + R*R - 2.0 * R * sqrt(p.x*p.x+p.y*p.y*abs(sin(time))+p.z*p.z*abs(cos(time))) ) - r;\n\n    // \u904a\u3093\u3067\u307f\u305f\n    // float t = 180.0 * sin(time/100.0);\n    // mat3 m_1 = mat3(cos(t), -sin(t), 0, sin(t), cos(t), 0, 0, 0, 1);\n    // mat3 m_2 = mat3(0, 0, 1, cos(t), -sin(t), 0, sin(t), cos(t), 0);\n    // mat3 m_3 = mat3( cos(t),0 , -sin(t), 0, 1, 0, sin(t), 0, cos(t));\n    // p = m_2* m_1 * p;\n    // return sqrt(p.x*p.x+p.y*p.y+p.z*p.z + R*R - 2.0 * R * sqrt(p.x*p.x*abs(cos(time))+p.y*p.y*abs(sin(time))+p.z*p.z*abs(tan(10.0*abs(sin(time/100.0))))) ) - r;\n}\n\n// \u8ddd\u96e2\u95a2\u6570\u3092\u547c\u3073\u51fa\u3059\u30cf\u30d6\u95a2\u6570\nfloat distanceHub(vec3 p){\n    return dTorus(p);\n    // return max(dCube(p), length(p)-1.0*abs(sin(time)));\n}\n\n// \u6cd5\u7dda\u3092\u751f\u6210\u3059\u308b\nvec3 genNormal(vec3 p){\n    float d = 0.001;\n    return normalize(vec3(\n        distanceHub(p + vec3(  d, 0.0, 0.0)) - distanceHub(p + vec3( -d, 0.0, 0.0)),\n        distanceHub(p + vec3(0.0,   d, 0.0)) - distanceHub(p + vec3(0.0,  -d, 0.0)),\n        distanceHub(p + vec3(0.0, 0.0,   d)) - distanceHub(p + vec3(0.0, 0.0,  -d))\n    ));\n}\n\nvoid main(){\n    // \u30b9\u30af\u30ea\u30fc\u30f3\u30b9\u30da\u30fc\u30b9\u3092\u8003\u616e\u3057\u3066\u5ea7\u6a19\u3092\u6b63\u898f\u5316\u3059\u308b\n    vec2 p = (gl_FragCoord.xy * 2.0 - resolution) / min(resolution.x, resolution.y);\n\n    // \u30ab\u30e1\u30e9\u3092\u5b9a\u7fa9\u3059\u308b\n    vec3 cPos = vec3(0.0,  0.0,  4.0); // \u30ab\u30e1\u30e9\u306e\u4f4d\u7f6e\n    vec3 cDir = vec3(0.0,  0.0, -1.0); // \u30ab\u30e1\u30e9\u306e\u5411\u304d(\u8996\u7dda)\n    vec3 cUp  = vec3(0.0,  1.0,  0.0); // \u30ab\u30e1\u30e9\u306e\u4e0a\u65b9\u5411\n    vec3 cSide = cross(cDir, cUp);     // \u5916\u7a4d\u3092\u4f7f\u3063\u3066\u6a2a\u65b9\u5411\u3092\u7b97\u51fa\n    float targetDepth = 1.0;           // \u30d5\u30a9\u30fc\u30ab\u30b9\u3059\u308b\u6df1\u5ea6\n\n    // \u30ab\u30e1\u30e9\u306e\u60c5\u5831\u304b\u3089\u30ec\u30a4\u3092\u5b9a\u7fa9\u3059\u308b\n    vec3 ray = normalize(cSide * p.x + cUp * p.y + cDir * targetDepth);\n\n    // \u30de\u30fc\u30c1\u30f3\u30b0\u30eb\u30fc\u30d7\u3092\u7d44\u3080\n    float dist = 0.0;  // \u30ec\u30a4\u3068\u30aa\u30d6\u30b8\u30a7\u30af\u30c8\u9593\u306e\u6700\u77ed\u8ddd\u96e2\n    float rLen = 0.0;  // \u30ec\u30a4\u306b\u7d99\u304e\u8db3\u3059\u9577\u3055\n    vec3  rPos = cPos; // \u30ec\u30a4\u306e\u5148\u7aef\u4f4d\u7f6e(\u521d\u671f\u4f4d\u7f6e)\n    for(int i = 0; i < 32; ++i){\n        dist = distanceHub(rPos);\n        rLen += dist;\n        rPos = cPos + ray * rLen;\n    }\n\n    // \u30ec\u30a4\u3068\u30aa\u30d6\u30b8\u30a7\u30af\u30c8\u306e\u8ddd\u96e2\u3092\u78ba\u8a8d\n    if(abs(dist) < 0.001){\n        // \u6cd5\u7dda\u3092\u7b97\u51fa\n        vec3 normal = genNormal(rPos);\n\n        // \u30e9\u30a4\u30c8\u30d9\u30af\u30c8\u30eb\u306e\u5b9a\u7fa9\uff08\u30de\u30a6\u30b9\u306e\u5f71\u97ff\u3092\u53d7\u3051\u308b\u3088\u3046\u306b\uff09\n        // vec3 light = normalize(vec3(mouse + 1.0, 1.0));\n        vec3 light = normalize(vec3(1.0, 1.0, 1.0));\n\n        // \u30e9\u30a4\u30c8\u30d9\u30af\u30c8\u30eb\u3068\u306e\u5185\u7a4d\u3092\u53d6\u308b\n        float diff = max(dot(normal, light), 0.1);\n\n        // diffuse \u3092\u51fa\u529b\u3059\u308b\n        gl_FragColor = vec4(vec3(diff), 1.0);\n    }else{\n        // \u885d\u7a81\u3057\u306a\u304b\u3063\u305f\u5834\u5408\u306f\u305d\u306e\u307e\u307e\u9ed2\n        gl_FragColor = vec4(vec3(0.0, 0.0, 0.0), 1.0);\n    }\n}\n\n\u53c2\u8003\u8a18\u4e8b:[modeling with distance functions](http://iquilezles.org/www/articles/distfunctions/distfunctions.htm)\n\n# Torus\u8a18\u4e8b\u306e\u5f8c\u7de8\u3067\u3059.\n\n\u9577\u304b\u3063\u305f!\u3001\u5f0f\u306e\u5c0e\u51fa\u3082\u7d42\u308f\u3063\u305f\u306e\u3067\u3001Torus\u306e\u5f0f\u3092\u3044\u3058\u3063\u3066\u3044\u304d\u305f\u3044\u3068\u601d\u3044\u307e\u3059.\n\n```c++\n// length\u4f7f\u308f\u306a\u3044\u65b9\u6cd5\nfloat r = 0.3;\nfloat R = 1.0;\nreturn sqrt(p.x*p.x+p.y*p.y+p.z*p.z + R*R - 2.0 * R * sqrt(p.x*p.x+p.y*p.y) ) - r;\n```\n\n\u65e9\u901f\u5f0f\u3092\u3044\u3058\u3063\u3066\u3044\u3053\u3046\u3068\u601d\u3044\u307e\u3059.\n\n## Torus\u304b\u3089Sphere\u3078\u5909\u5f62\n\u611f\u306e\u3044\u3044\u4eba\u306f\u304a\u6c17\u3065\u304d\u304b\u3082\u3057\u308c\u307e\u305b\u3093\u304c\u2026\n\n![transform2.gif](https://qiita-image-store.s3.amazonaws.com/0/102634/e7265565-c092-abca-b4c8-620153783c97.gif)\n\n\nTorus\u306e\u5f0f\n\n```c++\nreturn sqrt(p.x*p.x+p.y*p.y+p.z*p.z + R*R - 2.0 * R * sqrt(p.x*p.x+p.y*p.y) ) - r\n```\n\n\u306e\u5f0f\u306b\n\n```c++\nsqrt(p.x*p.x+p.y*p.y+p.z*p.z + R*R - 2.0 * R * sqrt(p.x*p.x+p.y*p.y+\u3010p.z*p.z\u3011) ) - r\n```\n\n\u3010\u3011\u3092\u8ffd\u52a0\u3059\u308b\u3068\u7403\u306b\u306a\u308a\u307e\u3059.\n\n\u306a\u306e\u3067\u3001\n\n```c++\nsqrt(p.x*p.x+p.y*p.y+p.z*p.z + R*R - 2.0 * R * sqrt(p.x*p.x+p.y*p.y+p.z*p.z*abs(sin(time))) ) - r\n```\n\n\u3092\u66f8\u304f\u3068\u7403\u3078\u5909\u5f62\u3059\u308bTorus\u304c\u66f8\u3051\u307e\u3059.\n\n## \u5411\u304d\u3092\u5909\u3048\u308b\u306e\u3092\u5909\u5f62\u307d\u304f\u3059\u308b\n\u56de\u8ee2\u3092\u3055\u305b\u305a\u306b\u3001\u5411\u304d\u3092\u5909\u3048\u307e\u3059\u3002\n\n![transform.gif](https://qiita-image-store.s3.amazonaws.com/0/102634/f8d97068-224b-dbd1-e839-e005bb1d1d93.gif)\n\n\n```c++\n// \u7e26\u5411\u304d(xz)\u304b\u3089\u6a2a\u5411\u304d(xy)\u3078\u5909\u5f62\nreturn sqrt(p.x*p.x+p.y*p.y+p.z*p.z + R*R - 2.0 * R * sqrt(p.x*p.x+p.y*p.y*abs(sin(time))+p.z*p.z*abs(cos(time))) ) - r;\n```\n\n\u3042\u3068\u306f\u3001\u4ee5\u4e0b\u306e\u30b3\u30fc\u30c9\u306b\u6b8b\u9ab8\u304c\u3042\u308b\u306e\u3067\u3001\u30b3\u30fc\u30c9[glslsandbox](http://glslsandbox.com/)\u306b\u5f35\u308a\u4ed8\u3051\u3066\u30b3\u30e1\u30f3\u30c8\u5916\u3057\u3066\u904a\u3093\u3067\u307f\u3066\u306d.\n\n\n# \u30b3\u30fc\u30c9\n```c++\n// ============================================================================\n// Torus function\n// ============================================================================\n\nprecision mediump float;\nuniform vec2  resolution;    // resolution (512.0, 512.0)\nuniform vec2  mouse;         // mouse      (-1.0 ~ 1.0)\nuniform float time;          // time       (1second == 1.0)\nuniform sampler2D prevScene; // previous scene texture\n\n// Torus\u306e\u8ddd\u96e2\u95a2\u6570\nfloat dTorus(vec3 p){\n    // Torus\u306e\u8ddd\u96e2\u95a2\u6570\n    // vec2 t = vec2(1.0, 0.3);\n    // vec2 q = vec2(length(p.xz)-t.x,p.y);\n    // return length(q)-t.y;\n\n    // lenght\u4f7f\u308f\u306a\u3044\u65b9\u6cd5\n    // float r = 0.3;\n    // float R = 1.0;\n    // return sqrt(p.x*p.x+p.y*p.y+p.z*p.z + R*R - 2.0 * R * sqrt(p.x*p.x+p.y*p.y) ) - r;\n\n    float r = 0.3;\n    float R = 1.0;\n    // \u6ce2\u9762\u307d\u3044\u3084\u3064\n    // return sqrt(p.x*p.x+p.y*p.y+p.z*p.z + R*R - (3.0-abs(sin(time))) * R * sqrt(p.x*p.x+p.y*p.y) ) - r;\n\n    // Sphere\n    // return sqrt(p.x*p.x+p.y*p.y+p.z*p.z + R*R - 2.0 * R * sqrt(p.x*p.x+p.y*p.y+p.z*p.z) ) - r;\n\n    // Torus\u304b\u3089Sphere\u3078\u5909\u5f62\n    return sqrt(p.x*p.x+p.y*p.y+p.z*p.z + R*R - 2.0 * R * sqrt(p.x*p.x+p.y*p.y+p.z*p.z*abs(sin(time))) ) - r;\n\n    // \u7e26\u5411\u304d(xz)\u304b\u3089\u6a2a\u5411\u304d(xy)\u3078\u5909\u5f62\n    // return sqrt(p.x*p.x+p.y*p.y+p.z*p.z + R*R - 2.0 * R * sqrt(p.x*p.x+p.y*p.y*abs(sin(time))+p.z*p.z*abs(cos(time))) ) - r;\n\n    // xz\u304d\u304b\u3089yz\u3078\u5909\u5f62\n    // return sqrt(p.x*p.x+p.y*p.y+p.z*p.z + R*R - 2.0 * R * sqrt(p.x*p.x*abs(cos(time))+p.y*p.y*abs(sin(time))+p.z*p.z) ) - r;\n\n    // xy\u2192yz\u306b\u56de\u8ee2\u3092\u304b\u3051\u308b\n    // mat3 m_1 = mat3(cos(time), -sin(time), 0, sin(time), cos(time), 0, 0, 0, 1);\n    // mat3 m_2 = mat3(0, 0, 1, cos(time), -sin(time), 0, sin(time), cos(time), 0);\n    // mat3 m_3 = mat3( cos(time),0 , -sin(time), 0, 1, 0, sin(time), 0, cos(time));\n    // p = m_2* m_1 * p;\n    // return sqrt(p.x*p.x+p.y*p.y+p.z*p.z + R*R - 2.0 * R * sqrt(p.x*p.x+p.y*p.y*abs(sin(time))+p.z*p.z*abs(cos(time))) ) - r;\n\n    // // xy\u2192yz\u306b\u9006\u56de\u8ee2\u3082\u8ffd\u52a0\n    // float t = 180.0 * sin(time/100.0);\n    // mat3 m_1 = mat3(cos(t), -sin(t), 0, sin(t), cos(t), 0, 0, 0, 1);\n    // mat3 m_2 = mat3(0, 0, 1, cos(t), -sin(t), 0, sin(t), cos(t), 0);\n    // mat3 m_3 = mat3( cos(t),0 , -sin(t), 0, 1, 0, sin(t), 0, cos(t));\n    // p = m_2* m_1 * p;\n    // return sqrt(p.x*p.x+p.y*p.y+p.z*p.z + R*R - 2.0 * R * sqrt(p.x*p.x+p.y*p.y*abs(sin(time))+p.z*p.z*abs(cos(time))) ) - r;\n\n    // xy\u2192yz\u306b\u9006\u56de\u8ee2\u3082\u8ffd\u52a0\n    // float t = 180.0 * sin(time/100.0);\n    // mat3 m_1 = mat3(cos(t), -sin(t), 0, sin(t), cos(t), 0, 0, 0, 1);\n    // mat3 m_2 = mat3(0, 0, 1, cos(t), -sin(t), 0, sin(t), cos(t), 0);\n    // mat3 m_3 = mat3( cos(t),0 , -sin(t), 0, 1, 0, sin(t), 0, cos(t));\n    // p = m_2* m_1 * p;\n    // return sqrt(p.x*p.x+p.y*p.y+p.z*p.z + R*R - 2.0 * R * sqrt(p.x*p.x+p.y*p.y*abs(sin(time))+p.z*p.z*abs(cos(time))) ) - r;\n\n    // \u904a\u3093\u3067\u307f\u305f\n    // float t = 180.0 * sin(time/100.0);\n    // mat3 m_1 = mat3(cos(t), -sin(t), 0, sin(t), cos(t), 0, 0, 0, 1);\n    // mat3 m_2 = mat3(0, 0, 1, cos(t), -sin(t), 0, sin(t), cos(t), 0);\n    // mat3 m_3 = mat3( cos(t),0 , -sin(t), 0, 1, 0, sin(t), 0, cos(t));\n    // p = m_2* m_1 * p;\n    // return sqrt(p.x*p.x+p.y*p.y+p.z*p.z + R*R - 2.0 * R * sqrt(p.x*p.x*abs(cos(time))+p.y*p.y*abs(sin(time))+p.z*p.z*abs(tan(10.0*abs(sin(time/100.0))))) ) - r;\n}\n\n// \u8ddd\u96e2\u95a2\u6570\u3092\u547c\u3073\u51fa\u3059\u30cf\u30d6\u95a2\u6570\nfloat distanceHub(vec3 p){\n    return dTorus(p);\n    // return max(dCube(p), length(p)-1.0*abs(sin(time)));\n}\n\n// \u6cd5\u7dda\u3092\u751f\u6210\u3059\u308b\nvec3 genNormal(vec3 p){\n    float d = 0.001;\n    return normalize(vec3(\n        distanceHub(p + vec3(  d, 0.0, 0.0)) - distanceHub(p + vec3( -d, 0.0, 0.0)),\n        distanceHub(p + vec3(0.0,   d, 0.0)) - distanceHub(p + vec3(0.0,  -d, 0.0)),\n        distanceHub(p + vec3(0.0, 0.0,   d)) - distanceHub(p + vec3(0.0, 0.0,  -d))\n    ));\n}\n\nvoid main(){\n    // \u30b9\u30af\u30ea\u30fc\u30f3\u30b9\u30da\u30fc\u30b9\u3092\u8003\u616e\u3057\u3066\u5ea7\u6a19\u3092\u6b63\u898f\u5316\u3059\u308b\n    vec2 p = (gl_FragCoord.xy * 2.0 - resolution) / min(resolution.x, resolution.y);\n\n    // \u30ab\u30e1\u30e9\u3092\u5b9a\u7fa9\u3059\u308b\n    vec3 cPos = vec3(0.0,  0.0,  4.0); // \u30ab\u30e1\u30e9\u306e\u4f4d\u7f6e\n    vec3 cDir = vec3(0.0,  0.0, -1.0); // \u30ab\u30e1\u30e9\u306e\u5411\u304d(\u8996\u7dda)\n    vec3 cUp  = vec3(0.0,  1.0,  0.0); // \u30ab\u30e1\u30e9\u306e\u4e0a\u65b9\u5411\n    vec3 cSide = cross(cDir, cUp);     // \u5916\u7a4d\u3092\u4f7f\u3063\u3066\u6a2a\u65b9\u5411\u3092\u7b97\u51fa\n    float targetDepth = 1.0;           // \u30d5\u30a9\u30fc\u30ab\u30b9\u3059\u308b\u6df1\u5ea6\n\n    // \u30ab\u30e1\u30e9\u306e\u60c5\u5831\u304b\u3089\u30ec\u30a4\u3092\u5b9a\u7fa9\u3059\u308b\n    vec3 ray = normalize(cSide * p.x + cUp * p.y + cDir * targetDepth);\n\n    // \u30de\u30fc\u30c1\u30f3\u30b0\u30eb\u30fc\u30d7\u3092\u7d44\u3080\n    float dist = 0.0;  // \u30ec\u30a4\u3068\u30aa\u30d6\u30b8\u30a7\u30af\u30c8\u9593\u306e\u6700\u77ed\u8ddd\u96e2\n    float rLen = 0.0;  // \u30ec\u30a4\u306b\u7d99\u304e\u8db3\u3059\u9577\u3055\n    vec3  rPos = cPos; // \u30ec\u30a4\u306e\u5148\u7aef\u4f4d\u7f6e(\u521d\u671f\u4f4d\u7f6e)\n    for(int i = 0; i < 32; ++i){\n        dist = distanceHub(rPos);\n        rLen += dist;\n        rPos = cPos + ray * rLen;\n    }\n\n    // \u30ec\u30a4\u3068\u30aa\u30d6\u30b8\u30a7\u30af\u30c8\u306e\u8ddd\u96e2\u3092\u78ba\u8a8d\n    if(abs(dist) < 0.001){\n        // \u6cd5\u7dda\u3092\u7b97\u51fa\n        vec3 normal = genNormal(rPos);\n\n        // \u30e9\u30a4\u30c8\u30d9\u30af\u30c8\u30eb\u306e\u5b9a\u7fa9\uff08\u30de\u30a6\u30b9\u306e\u5f71\u97ff\u3092\u53d7\u3051\u308b\u3088\u3046\u306b\uff09\n        // vec3 light = normalize(vec3(mouse + 1.0, 1.0));\n        vec3 light = normalize(vec3(1.0, 1.0, 1.0));\n\n        // \u30e9\u30a4\u30c8\u30d9\u30af\u30c8\u30eb\u3068\u306e\u5185\u7a4d\u3092\u53d6\u308b\n        float diff = max(dot(normal, light), 0.1);\n\n        // diffuse \u3092\u51fa\u529b\u3059\u308b\n        gl_FragColor = vec4(vec3(diff), 1.0);\n    }else{\n        // \u885d\u7a81\u3057\u306a\u304b\u3063\u305f\u5834\u5408\u306f\u305d\u306e\u307e\u307e\u9ed2\n        gl_FragColor = vec4(vec3(0.0, 0.0, 0.0), 1.0);\n    }\n}\n```\n"}