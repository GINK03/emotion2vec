{"context": " More than 1 year has passed since last update.\u6065\u305a\u304b\u3057\u306a\u304c\u3089C++\u307b\u3068\u3093\u3069\u66f8\u3044\u305f\u3053\u3068\u306a\u3044\u3051\u3069\u3001C++11\u3060\u3068\u30e9\u30e0\u30c0\u5f0f\u304c\u5165\u3063\u305f\u306e\u3067\u9759\u7684\u578b\u4ed8\u3051\u95a2\u6570\u578b\u8a00\u8a9e\u306e\u3088\u3046\u306a\u3053\u3068\u3092\u3067\u304d\u308b\u3093\u3058\u3083\u306a\u3044\u304b\u3001\u3068\u601d\u3063\u3066\u9069\u5f53\u306b\u66f8\u3044\u3066\u307f\u305f\u3002\n\u3053\u3093\u306a\u304b\u3093\u3058\u3067C++11\u306e\u6a5f\u80fd\u304c\u4f7f\u3048\u308b\u3089\u3057\u3044\nclang++ -std=c++11 -stdlib=libc++ hello.cpp -o hello\n\nclang v3.2\u3002\u672c\u5f53\u306bC++\u306b\u3064\u3044\u3066\u4f55\u3082\u77e5\u3089\u306a\u304b\u3063\u305f\u306e\u3067\u3001\u3053\u306e\u30aa\u30d7\u30b7\u30e7\u30f3\u306b\u6c17\u3065\u304f\u307e\u3067\u4e00\u6642\u9593\u304b\u304b\u3063\u305f\n\u53c2\u8003: \u672c\u306e\u866b: lambda \u5b8c\u5168\u89e3\u8aac http://cpplover.blogspot.jp/2009/11/lambda.html\n\u3068\u308a\u3042\u3048\u305amap, each, select\u3092\u5b9a\u7fa9\u3057\u3066\u904a\u3093\u3067\u307f\u308b\u3002\n#include <iostream>\n#include <memory>\n#include <cmath>\n#include <vector>\n\nnamespace prelude {\n    template<class T, class F>\n    auto map(const std::vector<T> & vec, F fun) -> std::vector<decltype(fun(vec[0]))> {\n        std::vector<decltype(fun(vec[0]))> ret;\n        std::transform (vec.begin(), vec.end(), std::back_inserter(ret), fun);\n        return ret;\n    }\n\n    template<class T, class F>\n    std::vector<T> select(const std::vector<T> & vec, F fun) {\n        std::vector<T> ret;\n        std::for_each (vec.begin(), vec.end(), [&](const T &t){\n            if(fun(t)) ret.push_back(t);\n        });\n        return ret;\n    }\n\n    template<class T, class F>\n    void each(const std::vector<T> & vec, F fun) {\n        for_each (vec.begin(), vec.end(), fun);\n    }\n}\n\nstruct Point {\n  Point(int x, int y): x(x), y(y) {};\n  int x;\n  int y;\n};\ntypedef std::shared_ptr<Point> PointPtr;\n\ndouble getDistance(const Point& p1, const Point& p2) {\n  return std::sqrt(std::pow(p1.x - p2.x, 2)+std::pow(p1.y - p2.y, 2));\n}\n\nusing namespace prelude;\nusing namespace std;\n\nint main() {\n    //lambda\n    [](){cout << \"Hello,World\" << endl;}();\n\n    function<int(int, int)> multiply = [](int x, int y) -> int { return x * y;};\n    cout << multiply(1,4) << endl;\n\n    const int z = 5;\n    auto multiply5 = [z](int x){return x * z;};\n    cout << multiply5(4) << endl;\n\n    Point p1(1,5);\n    Point p2(3,2);\n    Point p3(4,3);\n\n    cout << getDistance(p1, p2) << endl;;\n\n    vector<Point> vec;\n    vec.push_back(p1);\n    vec.push_back(p2);\n    vec.push_back(p3);\n\n    {\n        auto vec2 = map(vec, [](const Point &p){\n            return p.x * 2;\n        });\n\n        each(vec2, [](int i) {\n            cout << i << endl;\n        });\n    }\n\n    each(vec, [](const Point &p){cout << p.x << endl;});\n    auto vec3 = select(vec, [](const Point &p) -> bool { return p.x > 2 ;});\n    each(vec3, [](const Point &p){cout << p.x << endl;});\n}\n\n\u9014\u4e2d @krustf @mickey24 @mashiro \u306b const\u306b\u3057\u308dback_insert\u4f7f\u3048\u3068\u304bdecltype\u4f7f\u3048\u3070\u52d5\u7684\u306b\u578b\u3064\u304f\u308c\u308b\u3088\u3001\u307f\u305f\u3044\u306a\u611f\u3058\u3067\u6559\u3048\u3066\u3082\u3089\u3063\u305f\u308a\u3057\u305f\u3002\n\u30e1\u30e2\u30ea\u3068\u53c2\u7167\u610f\u8b58\u3059\u308b\u306e\u7d50\u69cb\u96e3\u3057\u3044\u3051\u3069\u3069\u3053\u3067\u5b9f\u4f53\u4f5c\u3063\u3066\u3069\u3053\u3067\u53c2\u7167\u30b3\u30d4\u30fc\u3057\u3066\u308b\u304b\u306a\u3093\u3068\u306a\u304f\u60f3\u50cf\u3067\u304d\u308b\u3088\u3046\u306b\u306a\u3063\u3066\u304d\u305f\u3002\nauto \u3068 std::function \u4fbf\u5229\u30a3\u2026\nusing namespace std; \u3059\u308b\u306a\u6b7b\u306b\u305f\u3044\u306e\u304b\uff01\u3068\u8a00\u308f\u308c\u305f\u3051\u3069 main \u3060\u3051\u306b\u7d5e\u3063\u305f\u306e\u3067\u8a31\u3057\u3066\u307b\u3057\u3044\u611f\u3058\u3067\u3059\n\u6065\u305a\u304b\u3057\u306a\u304c\u3089C++\u307b\u3068\u3093\u3069\u66f8\u3044\u305f\u3053\u3068\u306a\u3044\u3051\u3069\u3001C++11\u3060\u3068\u30e9\u30e0\u30c0\u5f0f\u304c\u5165\u3063\u305f\u306e\u3067\u9759\u7684\u578b\u4ed8\u3051\u95a2\u6570\u578b\u8a00\u8a9e\u306e\u3088\u3046\u306a\u3053\u3068\u3092\u3067\u304d\u308b\u3093\u3058\u3083\u306a\u3044\u304b\u3001\u3068\u601d\u3063\u3066\u9069\u5f53\u306b\u66f8\u3044\u3066\u307f\u305f\u3002\n\n\n\u3053\u3093\u306a\u304b\u3093\u3058\u3067C++11\u306e\u6a5f\u80fd\u304c\u4f7f\u3048\u308b\u3089\u3057\u3044\n\n```\nclang++ -std=c++11 -stdlib=libc++ hello.cpp -o hello\n```\n\nclang v3.2\u3002\u672c\u5f53\u306bC++\u306b\u3064\u3044\u3066\u4f55\u3082\u77e5\u3089\u306a\u304b\u3063\u305f\u306e\u3067\u3001\u3053\u306e\u30aa\u30d7\u30b7\u30e7\u30f3\u306b\u6c17\u3065\u304f\u307e\u3067\u4e00\u6642\u9593\u304b\u304b\u3063\u305f\n\n\n\u53c2\u8003: \u672c\u306e\u866b: lambda \u5b8c\u5168\u89e3\u8aac http://cpplover.blogspot.jp/2009/11/lambda.html\n\n\u3068\u308a\u3042\u3048\u305amap, each, select\u3092\u5b9a\u7fa9\u3057\u3066\u904a\u3093\u3067\u307f\u308b\u3002\n\n```cpp\n#include <iostream>\n#include <memory>\n#include <cmath>\n#include <vector>\n\nnamespace prelude {\n    template<class T, class F>\n    auto map(const std::vector<T> & vec, F fun) -> std::vector<decltype(fun(vec[0]))> {\n        std::vector<decltype(fun(vec[0]))> ret;\n        std::transform (vec.begin(), vec.end(), std::back_inserter(ret), fun);\n        return ret;\n    }\n\n    template<class T, class F>\n    std::vector<T> select(const std::vector<T> & vec, F fun) {\n        std::vector<T> ret;\n        std::for_each (vec.begin(), vec.end(), [&](const T &t){\n            if(fun(t)) ret.push_back(t);\n        });\n        return ret;\n    }\n\n    template<class T, class F>\n    void each(const std::vector<T> & vec, F fun) {\n        for_each (vec.begin(), vec.end(), fun);\n    }\n}\n\nstruct Point {\n  Point(int x, int y): x(x), y(y) {};\n  int x;\n  int y;\n};\ntypedef std::shared_ptr<Point> PointPtr;\n\ndouble getDistance(const Point& p1, const Point& p2) {\n  return std::sqrt(std::pow(p1.x - p2.x, 2)+std::pow(p1.y - p2.y, 2));\n}\n\nusing namespace prelude;\nusing namespace std;\n\nint main() {\n    //lambda\n    [](){cout << \"Hello,World\" << endl;}();\n\n    function<int(int, int)> multiply = [](int x, int y) -> int { return x * y;};\n    cout << multiply(1,4) << endl;\n\n    const int z = 5;\n    auto multiply5 = [z](int x){return x * z;};\n    cout << multiply5(4) << endl;\n\n    Point p1(1,5);\n    Point p2(3,2);\n    Point p3(4,3);\n\n    cout << getDistance(p1, p2) << endl;;\n\n    vector<Point> vec;\n    vec.push_back(p1);\n    vec.push_back(p2);\n    vec.push_back(p3);\n\n    {\n        auto vec2 = map(vec, [](const Point &p){\n            return p.x * 2;\n        });\n\n        each(vec2, [](int i) {\n            cout << i << endl;\n        });\n    }\n\n    each(vec, [](const Point &p){cout << p.x << endl;});\n    auto vec3 = select(vec, [](const Point &p) -> bool { return p.x > 2 ;});\n    each(vec3, [](const Point &p){cout << p.x << endl;});\n}\n```\n\n\u9014\u4e2d @krustf @mickey24 @mashiro \u306b const\u306b\u3057\u308dback_insert\u4f7f\u3048\u3068\u304bdecltype\u4f7f\u3048\u3070\u52d5\u7684\u306b\u578b\u3064\u304f\u308c\u308b\u3088\u3001\u307f\u305f\u3044\u306a\u611f\u3058\u3067\u6559\u3048\u3066\u3082\u3089\u3063\u305f\u308a\u3057\u305f\u3002\n\u30e1\u30e2\u30ea\u3068\u53c2\u7167\u610f\u8b58\u3059\u308b\u306e\u7d50\u69cb\u96e3\u3057\u3044\u3051\u3069\u3069\u3053\u3067\u5b9f\u4f53\u4f5c\u3063\u3066\u3069\u3053\u3067\u53c2\u7167\u30b3\u30d4\u30fc\u3057\u3066\u308b\u304b\u306a\u3093\u3068\u306a\u304f\u60f3\u50cf\u3067\u304d\u308b\u3088\u3046\u306b\u306a\u3063\u3066\u304d\u305f\u3002\n\nauto \u3068 std::function \u4fbf\u5229\u30a3\u2026\nusing namespace std; \u3059\u308b\u306a\u6b7b\u306b\u305f\u3044\u306e\u304b\uff01\u3068\u8a00\u308f\u308c\u305f\u3051\u3069 main \u3060\u3051\u306b\u7d5e\u3063\u305f\u306e\u3067\u8a31\u3057\u3066\u307b\u3057\u3044\u611f\u3058\u3067\u3059", "tags": ["C++11"]}