{"context": " More than 1 year has passed since last update.sort :: (a -> a -> Bool) -> [a] -> [a] \u306e\u3088\u3046\u306a\u95a2\u6570\u304c\u3042\u308b\u3068\u304d\u3001\u3075\u3068\u3001\u9069\u5f53\u306a\u5165\u529b\u3092\u4e0e\u3048\u305f\u3068\u304d\u306b\u3053\u306e sort \u95a2\u6570\u306f\u4f55\u56de\u6bd4\u8f03\u3092\u884c\u306a\u3046\u306e\u3060\u308d\u3046\u3068\u6c17\u306b\u306a\u308b\u3053\u3068\u304c\u3042\u308b\u3002\nScheme \u306e\u5834\u5408\u306a\u3089\u4f55\u3082\u8003\u3048\u305a\u306b\u6bd4\u8f03\u624b\u7d9a\u304d\u3092 wrap \u3057\u3066\u3001\u305d\u306e\u4e2d\u3067\u30ab\u30a6\u30f3\u30bf\u3092 set! \u3059\u308c\u3070\u3088\u3044\uff08Gauche \u306e sort \u624b\u7d9a\u304d\u306b\u5408\u308f\u305b\u308b\u305f\u3081\u306b\u5f15\u6570\u306e\u9806\u756a\u304c\u9006\u306b\u306a\u3063\u3066\u3044\u308b\u3002\u4ee5\u4e0b\u306e Scheme \u30b3\u30fc\u30c9\u306f\u3059\u3079\u3066\u51e6\u7406\u7cfb\u3068\u3057\u3066 Gauche \u3092\u4eee\u5b9a\u3059\u308b\uff09\u3002\n\ncount.scm\n(define (count-compare sort compare xs)\n  (let ((n 0))\n    (sort xs\n          (lambda (x y)\n            (set! n (+ n 1))\n            (compare x y)))\n    n))\n\n\n\u3057\u304b\u3057\u3001\u3053\u306e\u624b\u7d9a\u304d\u306f\u5165\u529b\u306b\u3088\u3063\u3066\u306e\u307f\u51fa\u529b\u304c\u6c7a\u307e\u308b\u7d14\u7c8b\u306a\u95a2\u6570\u306a\u306e\u306b\u4ee3\u5165\u3092\u4f7f\u3046\u306e\u306f\u8ca0\u3051\u305f\u3088\u3046\u306a\u6c17\u304c\u3059\u308b\u3002\u4f55\u304b\u4ed6\u306e\u65b9\u6cd5\u306f\u2026\u2026\n\n\u72b6\u614b\u30e2\u30ca\u30c9\nHaskell \u3067 State \u30e2\u30ca\u30c9\u3092\u4f7f\u3046\u3068\u3053\u3093\u306a\u611f\u3058\u3060\u308d\u3046\u304b\u3002\n\ncountCompare.hs\nimport Control.Monad.Trans.State.Strict\n\ncountCompare :: Monad m => ((a -> a -> m Bool) -> [a] -> m [a]) -> (a -> a -> Bool) -> [a] -> Int\ncountCompare sort p xs = execState (sort p' xs) 0\n    where\n      p' x y = do\n        modify (+1)\n        return $ p x y\n\nsort :: Monad m => (a -> a -> m Bool) -> [a] -> m [a]\nsort _ [] = return []\nsort pred (x:xs) = do\n  xs' <- sort pred xs\n  insert pred x xs'\n\ninsert :: Monad m => (a -> a -> m Bool) -> a -> [a] -> m [a]\ninsert _ x [] = return [x]\ninsert pred x (y:ys) = do\n  b <- pred x y\n  if b\n    then return (x:y:ys)\n    else do\n      ys' <- insert pred x ys\n      return (y:ys')\n\n\npred \u306e\u578b\u304c\u5909\u308f\u3063\u305f\u305b\u3044\u3067 sort \u307e\u3067\u66f8\u304d\u63db\u3048\u306a\u3044\u3068\u3044\u3051\u306a\u304f\u306a\u3063\u305f\u3002\u7d14\u7c8b\u306a sort \u304c\u6b32\u3057\u3044\u3068\u304d\u306f runIdentity \u3059\u308b\u3002\u3042\u307e\u308a\u3046\u308c\u3057\u304f\u306a\u3044\u3002\n\n\u9650\u5b9a\u7d99\u7d9a\n\u9650\u5b9a\u7d99\u7d9a\u3067\u30e2\u30ca\u30c9\u3092\u8868\u73fe\u3057\u3066\u307f\u308b\u3068\u3069\u3046\u3060\u308d\u3046\u304b\u3002\n\u5b9a\u7fa9\u306f\u304a\u99b4\u67d3\u307f\u306e\u3002\n\ncount.scm\n(use gauche.partcont)\n\n(define (return x)\n  (lambda (s)\n    (values x s)))\n\n(define (bind m f)\n  (lambda (s)\n    (receive (x s~) (m s)\n      ((f x) s~))))\n\n(define-syntax reify\n  (syntax-rules ()\n    ((_ expr)\n     (reset\n       (return expr)))))\n\n(define (reflect x)\n  (shift k (bind x k)))\n\n(define (get)\n  (lambda (s)\n    (values s s)))\n\n(define (put v)\n  (lambda (s)\n    (values #f v)))\n\n(define (modify f)\n  (let ((s (reflect (get))))\n    (put (f s))))\n\n(define (run-state m s)\n  (m s))\n\n(define (eval-state m s)\n  (values-ref (run-state m s) 0))\n\n(define (exec-state m s)\n  (values-ref (run-state m s) 1))\n\n\nreturn, bind \u306f Haskell \u7b49\u3068\u540c\u3058\u3002 reify, reflect \u306f\u30e2\u30ca\u30c9\u306b\u3088\u3089\u305a\u5171\u901a\u306e\u5b9a\u7fa9\u3002 Haskell \u3067 do \u3092\u66f8\u304f\u3068\u3053\u308d\u306b reify, <- \u3092\u66f8\u304f\u3068\u3053\u308d\u306b reflect \u3092\u66f8\u304f\u3002 reflect \u306f shift \u3092\u547c\u3076\u306e\u3067\u8a55\u4fa1\u9806\u5e8f\u306b\u6ce8\u610f\u3002\n\ncount.scm\n(define (count-compare sort compare xs)\n  (let ((n 0))\n    (sort xs\n          (lambda (x y)\n            (set! n (+ n 1))\n            (compare x y)))\n    n))\n\n(define (count-compare* sort compare xs)\n  (let ((c (lambda (x y)\n             (reflect (put (+ (reflect (get)) 1)))\n             (compare x y))))\n    (exec-state (reify (sort xs c)) 0)))\n\n(define (test sort pred xs)\n  (list (count-compare sort compare xs)\n        (count-compare* sort compare xs)))\n\n(test sort > '(2 1 4 3 5))\n;; => (7 7)\n\n\n\u3046\u307e\u304f\u52d5\u3044\u3066\u3044\u308b\u3088\u3046\u3060\u3002\n\n\u4f55\u304c\u8d77\u304d\u3066\u3044\u308b\uff1f\nHaskell \u7248\u3067\u306f\u526f\u4f5c\u7528\u306e\u8d77\u3053\u308a\u305d\u3046\u306a\u3068\u3053\u308d\u3092\u524d\u4ee5\u3063\u3066 monadic \u306a\u578b\u306b\u3057\u3066\u304a\u304f\u5fc5\u8981\u304c\u3042\u308b\u3002\u305d\u308c\u306b\u5bfe\u3057\u3066\u3001\u9650\u5b9a\u7d99\u7d9a\u7248\u3067\u306f reflect \u3092\u547c\u3076\u305f\u3073\u306b shift \u306e\u526f\u4f5c\u7528\u3067 reset \u307e\u3067\u306e\u6b8b\u308a\u306e\u8a08\u7b97\uff08\u7d99\u7d9a\uff09\u3092\u72b6\u614b\u5f15\u6570\u3092\u53d7\u3051\u53d6\u308b\u3088\u3046\u306b\u30e9\u30c3\u30d7\u3057\u3001\u30d7\u30ed\u30b0\u30e9\u30e0\u81ea\u4f53\u3092\u30e2\u30ca\u30c9\u7248\u3068\u540c\u3058\u5f62\u306b\u306a\u308b\u3088\u3046\u306b\u66f8\u304d\u63db\u3048\u3066\u3044\u308b\u3002\n\u30d7\u30ed\u30b0\u30e9\u30e0\u306e\u5b57\u9762\u3060\u3051\u898b\u308b\u3068\u3001 sort \u306b\u6e21\u3059\u6bd4\u8f03\u624b\u7d9a\u304d\u304c\u5916\u304b\u3089\u72b6\u614b\u5f15\u6570\u3092\u53d7\u3051\u53d6\u308c\u308b\u3068\u3044\u3046\u306e\u306f\u6c17\u6301\u3061\u60aa\u3044\u6c17\u304c\u3059\u308b\u3051\u308c\u3069\u3001\u7d99\u7d9a\u6f14\u7b97\u5b50\u306f\u30d7\u30ed\u30b0\u30e9\u30e0\u306e\u5b57\u9762\u3092\u64cd\u4f5c\u3059\u308b\u306e\u3067\u306f\u306a\u304f\u3001\u5b9f\u884c\u6642\u306e\u72b6\u614b\u3092\u64cd\u4f5c\u3059\u308b\u3082\u306e\u306a\u306e\u3067\u3053\u3093\u306a\u3053\u3068\u304c\u3067\u304d\u308b\u3002\n\u3061\u306a\u307f\u306b\u3001\u4eca\u56de\u306e\u8a71\u306f\u9759\u7684\u578b\u306e\u6709\u7121\u306f\u95a2\u4fc2\u306a\u304f\u3001\u4f8b\u3048\u3070 OchaCaml \u3067\u3082\u540c\u3058\u3088\u3046\u306a\u30d7\u30ed\u30b0\u30e9\u30e0\u3092\u66f8\u304f\u3053\u3068\u304c\u3067\u304d\u308b\u3002\n\n\u307e\u3068\u3081\n\n\u9ad8\u968e\u95a2\u6570\u306b\u526f\u4f5c\u7528\u3092\u5f8c\u4ed8\u3051\u3057\u3088\u3046\u3068\u3059\u308b\u3068\u3061\u3087\u3063\u3068\u9762\u5012\n\u9650\u5b9a\u7d99\u7d9a\u306f\u697d\u3057\u3044\u3002\u305d\u3057\u3066\u3061\u3087\u3063\u3068\u6c17\u6301\u3061\u60aa\u3044\n\n\u203b\u6700\u521d\u306e\u65b9\u306b\u51fa\u3066\u304d\u305f\u3001\u7d14\u7c8b\u95a2\u6570\u3063\u307d\u304f\u898b\u3048\u308b\u306e\u306b\u3001\u526f\u4f5c\u7528\u3092\u4f7f\u308f\u306a\u3044\u3068\u66f8\u3051\u306a\u3044\u3001\u3068\u3044\u3046\u8a71\u306f When is a Functional Program Not a Functional Program? \u306b\u3082\u3063\u3068\u8272\u3005\u66f8\u3044\u3066\u3042\u308b\u307f\u305f\u3044\u3067\u3059\n`sort :: (a -> a -> Bool) -> [a] -> [a]` \u306e\u3088\u3046\u306a\u95a2\u6570\u304c\u3042\u308b\u3068\u304d\u3001\u3075\u3068\u3001\u9069\u5f53\u306a\u5165\u529b\u3092\u4e0e\u3048\u305f\u3068\u304d\u306b\u3053\u306e `sort` \u95a2\u6570\u306f\u4f55\u56de\u6bd4\u8f03\u3092\u884c\u306a\u3046\u306e\u3060\u308d\u3046\u3068\u6c17\u306b\u306a\u308b\u3053\u3068\u304c\u3042\u308b\u3002\n\nScheme \u306e\u5834\u5408\u306a\u3089\u4f55\u3082\u8003\u3048\u305a\u306b\u6bd4\u8f03\u624b\u7d9a\u304d\u3092 wrap \u3057\u3066\u3001\u305d\u306e\u4e2d\u3067\u30ab\u30a6\u30f3\u30bf\u3092 `set!` \u3059\u308c\u3070\u3088\u3044\uff08Gauche \u306e `sort` \u624b\u7d9a\u304d\u306b\u5408\u308f\u305b\u308b\u305f\u3081\u306b\u5f15\u6570\u306e\u9806\u756a\u304c\u9006\u306b\u306a\u3063\u3066\u3044\u308b\u3002\u4ee5\u4e0b\u306e Scheme \u30b3\u30fc\u30c9\u306f\u3059\u3079\u3066\u51e6\u7406\u7cfb\u3068\u3057\u3066 Gauche \u3092\u4eee\u5b9a\u3059\u308b\uff09\u3002\n\n```scheme:count.scm\n(define (count-compare sort compare xs)\n  (let ((n 0))\n    (sort xs\n          (lambda (x y)\n            (set! n (+ n 1))\n            (compare x y)))\n    n))\n```\n\n\u3057\u304b\u3057\u3001\u3053\u306e\u624b\u7d9a\u304d\u306f\u5165\u529b\u306b\u3088\u3063\u3066\u306e\u307f\u51fa\u529b\u304c\u6c7a\u307e\u308b\u7d14\u7c8b\u306a\u95a2\u6570\u306a\u306e\u306b\u4ee3\u5165\u3092\u4f7f\u3046\u306e\u306f\u8ca0\u3051\u305f\u3088\u3046\u306a\u6c17\u304c\u3059\u308b\u3002\u4f55\u304b\u4ed6\u306e\u65b9\u6cd5\u306f\u2026\u2026\n\n# \u72b6\u614b\u30e2\u30ca\u30c9\nHaskell \u3067 `State` \u30e2\u30ca\u30c9\u3092\u4f7f\u3046\u3068\u3053\u3093\u306a\u611f\u3058\u3060\u308d\u3046\u304b\u3002\n\n```haskell:countCompare.hs\nimport Control.Monad.Trans.State.Strict\n\ncountCompare :: Monad m => ((a -> a -> m Bool) -> [a] -> m [a]) -> (a -> a -> Bool) -> [a] -> Int\ncountCompare sort p xs = execState (sort p' xs) 0\n    where\n      p' x y = do\n        modify (+1)\n        return $ p x y\n\nsort :: Monad m => (a -> a -> m Bool) -> [a] -> m [a]\nsort _ [] = return []\nsort pred (x:xs) = do\n  xs' <- sort pred xs\n  insert pred x xs'\n\ninsert :: Monad m => (a -> a -> m Bool) -> a -> [a] -> m [a]\ninsert _ x [] = return [x]\ninsert pred x (y:ys) = do\n  b <- pred x y\n  if b\n    then return (x:y:ys)\n    else do\n      ys' <- insert pred x ys\n      return (y:ys')\n```\n\n`pred` \u306e\u578b\u304c\u5909\u308f\u3063\u305f\u305b\u3044\u3067 `sort` \u307e\u3067\u66f8\u304d\u63db\u3048\u306a\u3044\u3068\u3044\u3051\u306a\u304f\u306a\u3063\u305f\u3002\u7d14\u7c8b\u306a `sort` \u304c\u6b32\u3057\u3044\u3068\u304d\u306f `runIdentity` \u3059\u308b\u3002\u3042\u307e\u308a\u3046\u308c\u3057\u304f\u306a\u3044\u3002\n\n# \u9650\u5b9a\u7d99\u7d9a\n\n\u9650\u5b9a\u7d99\u7d9a\u3067\u30e2\u30ca\u30c9\u3092\u8868\u73fe\u3057\u3066\u307f\u308b\u3068\u3069\u3046\u3060\u308d\u3046\u304b\u3002\n\n\u5b9a\u7fa9\u306f\u304a\u99b4\u67d3\u307f\u306e\u3002\n\n```scheme:count.scm\n(use gauche.partcont)\n\n(define (return x)\n  (lambda (s)\n    (values x s)))\n\n(define (bind m f)\n  (lambda (s)\n    (receive (x s~) (m s)\n      ((f x) s~))))\n\n(define-syntax reify\n  (syntax-rules ()\n    ((_ expr)\n     (reset\n       (return expr)))))\n\n(define (reflect x)\n  (shift k (bind x k)))\n\n(define (get)\n  (lambda (s)\n    (values s s)))\n\n(define (put v)\n  (lambda (s)\n    (values #f v)))\n\n(define (modify f)\n  (let ((s (reflect (get))))\n    (put (f s))))\n\n(define (run-state m s)\n  (m s))\n\n(define (eval-state m s)\n  (values-ref (run-state m s) 0))\n\n(define (exec-state m s)\n  (values-ref (run-state m s) 1))\n```\n\n`return`, `bind` \u306f Haskell \u7b49\u3068\u540c\u3058\u3002 `reify`, `reflect` \u306f\u30e2\u30ca\u30c9\u306b\u3088\u3089\u305a\u5171\u901a\u306e\u5b9a\u7fa9\u3002 Haskell \u3067 `do` \u3092\u66f8\u304f\u3068\u3053\u308d\u306b `reify`, `<-` \u3092\u66f8\u304f\u3068\u3053\u308d\u306b `reflect` \u3092\u66f8\u304f\u3002 `reflect` \u306f `shift` \u3092\u547c\u3076\u306e\u3067\u8a55\u4fa1\u9806\u5e8f\u306b\u6ce8\u610f\u3002\n\n```scheme:count.scm\n(define (count-compare sort compare xs)\n  (let ((n 0))\n    (sort xs\n          (lambda (x y)\n            (set! n (+ n 1))\n            (compare x y)))\n    n))\n\n(define (count-compare* sort compare xs)\n  (let ((c (lambda (x y)\n             (reflect (put (+ (reflect (get)) 1)))\n             (compare x y))))\n    (exec-state (reify (sort xs c)) 0)))\n\n(define (test sort pred xs)\n  (list (count-compare sort compare xs)\n        (count-compare* sort compare xs)))\n\n(test sort > '(2 1 4 3 5))\n;; => (7 7)\n```\n\n\u3046\u307e\u304f\u52d5\u3044\u3066\u3044\u308b\u3088\u3046\u3060\u3002\n\n# \u4f55\u304c\u8d77\u304d\u3066\u3044\u308b\uff1f\n\nHaskell \u7248\u3067\u306f\u526f\u4f5c\u7528\u306e\u8d77\u3053\u308a\u305d\u3046\u306a\u3068\u3053\u308d\u3092\u524d\u4ee5\u3063\u3066 monadic \u306a\u578b\u306b\u3057\u3066\u304a\u304f\u5fc5\u8981\u304c\u3042\u308b\u3002\u305d\u308c\u306b\u5bfe\u3057\u3066\u3001\u9650\u5b9a\u7d99\u7d9a\u7248\u3067\u306f `reflect` \u3092\u547c\u3076\u305f\u3073\u306b `shift` \u306e\u526f\u4f5c\u7528\u3067 `reset` \u307e\u3067\u306e\u6b8b\u308a\u306e\u8a08\u7b97\uff08\u7d99\u7d9a\uff09\u3092\u72b6\u614b\u5f15\u6570\u3092\u53d7\u3051\u53d6\u308b\u3088\u3046\u306b\u30e9\u30c3\u30d7\u3057\u3001\u30d7\u30ed\u30b0\u30e9\u30e0\u81ea\u4f53\u3092\u30e2\u30ca\u30c9\u7248\u3068\u540c\u3058\u5f62\u306b\u306a\u308b\u3088\u3046\u306b\u66f8\u304d\u63db\u3048\u3066\u3044\u308b\u3002\n\n\u30d7\u30ed\u30b0\u30e9\u30e0\u306e\u5b57\u9762\u3060\u3051\u898b\u308b\u3068\u3001 `sort` \u306b\u6e21\u3059\u6bd4\u8f03\u624b\u7d9a\u304d\u304c\u5916\u304b\u3089\u72b6\u614b\u5f15\u6570\u3092\u53d7\u3051\u53d6\u308c\u308b\u3068\u3044\u3046\u306e\u306f\u6c17\u6301\u3061\u60aa\u3044\u6c17\u304c\u3059\u308b\u3051\u308c\u3069\u3001\u7d99\u7d9a\u6f14\u7b97\u5b50\u306f\u30d7\u30ed\u30b0\u30e9\u30e0\u306e\u5b57\u9762\u3092\u64cd\u4f5c\u3059\u308b\u306e\u3067\u306f\u306a\u304f\u3001\u5b9f\u884c\u6642\u306e\u72b6\u614b\u3092\u0002\u64cd\u4f5c\u3059\u308b\u3082\u306e\u306a\u306e\u3067\u3053\u3093\u306a\u3053\u3068\u304c\u3067\u304d\u308b\u3002\n\n\u3061\u306a\u307f\u306b\u3001\u4eca\u56de\u306e\u8a71\u306f\u9759\u7684\u578b\u306e\u6709\u7121\u306f\u95a2\u4fc2\u306a\u304f\u3001\u4f8b\u3048\u3070 OchaCaml \u3067\u3082\u540c\u3058\u3088\u3046\u306a\u30d7\u30ed\u30b0\u30e9\u30e0\u3092\u66f8\u304f\u3053\u3068\u304c\u3067\u304d\u308b\u3002\n\n# \u307e\u3068\u3081\n\n* \u9ad8\u968e\u95a2\u6570\u306b\u526f\u4f5c\u7528\u3092\u5f8c\u4ed8\u3051\u3057\u3088\u3046\u3068\u3059\u308b\u3068\u3061\u3087\u3063\u3068\u9762\u5012\n* \u9650\u5b9a\u7d99\u7d9a\u306f\u697d\u3057\u3044\u3002\u305d\u3057\u3066\u3061\u3087\u3063\u3068\u6c17\u6301\u3061\u60aa\u3044\n\n\u203b\u6700\u521d\u306e\u65b9\u306b\u51fa\u3066\u304d\u305f\u3001\u7d14\u7c8b\u95a2\u6570\u3063\u307d\u304f\u898b\u3048\u308b\u306e\u306b\u3001\u526f\u4f5c\u7528\u3092\u4f7f\u308f\u306a\u3044\u3068\u66f8\u3051\u306a\u3044\u3001\u3068\u3044\u3046\u8a71\u306f [When is a Functional Program Not a Functional Program?](http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.39.2548) \u306b\u3082\u3063\u3068\u8272\u3005\u66f8\u3044\u3066\u3042\u308b\u307f\u305f\u3044\u3067\u3059\n", "tags": ["Scheme", "\u7d99\u7d9a"]}