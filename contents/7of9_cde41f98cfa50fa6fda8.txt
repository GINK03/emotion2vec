{"context": "MicroZed Chronicles \u30ea\u30b9\u30c8 http://adiuvoengineering.com/?page_id=285\n@ Adam Taylor blog\nhttps://forums.xilinx.com/t5/Xcell-Daily-Blog/Adam-Taylor-s-MicroZed-Chronicles-Part-50-AMP-and-the-Zynq-SoC-s/ba-p/521889\nOCM\u7d4c\u7531\u3067\u306eCore0, Core1\u9593\u306e\u901a\u4fe1\u306e\u5b9f\u88c5\u4f8b\n\nThe demo for this will use CPU0 to communicate over the UART link to a laptop. We\u2019ll send an 8-bit ASCII value from the laptop to the Zynq Soc\u2019s UART. Once received, this 8-bit value will be transferred into the selected OCM memory address, which is shared between the two processors. Each time its private timer expires, CPU1 will read this memory address and set its GPIO output pins accordingly. \n\n\u4f7f\u7528\u3059\u308b\u30e1\u30e2\u30ea\u30a2\u30c9\u30ec\u30b9\u3092\u9078\u629e\u3059\u308b\u3002\u305d\u306e\u305f\u3081\u306bOCM\u306e\u30ad\u30e3\u30c3\u30b7\u30e5\u3092\u5207\u308b\nXil_SetTlbAttributes(0xFFFF0000,0x14de2);\n\n\u6307\u5b9a\u306e\u30e1\u30e2\u30ea\u30a2\u30c9\u30ec\u30b9\u3078\u306e\u30c7\u30fc\u30bf\u8ee2\u9001\u65b9\u6cd5\u306f\uff12\u3064\u3042\u308b\u3002\n\nThe first method uses the generic Xilinx I/O functions to read from and write to the selected memory address.\n\nXil_Out8(0xFFFF0000,0x55);\n\nread_char = Xil_In8(0xFFFF0000);\n\n\nThe second method is for both programs to access the memory location using pointers. \n\n#define LED_OP (*(volatileunsignedint *)(0xFFFF0000))\n\nMicroZed Chronicles \u30ea\u30b9\u30c8 http://adiuvoengineering.com/?page_id=285\n@ Adam Taylor blog\nhttps://forums.xilinx.com/t5/Xcell-Daily-Blog/Adam-Taylor-s-MicroZed-Chronicles-Part-50-AMP-and-the-Zynq-SoC-s/ba-p/521889\n\nOCM\u7d4c\u7531\u3067\u306eCore0, Core1\u9593\u306e\u901a\u4fe1\u306e\u5b9f\u88c5\u4f8b\n\n> The demo for this will use CPU0 to communicate over the UART link to a laptop. We\u2019ll send <font color=red>an 8-bit ASCII value</font> from the laptop to the Zynq Soc\u2019s UART. Once received, this 8-bit value will be transferred into the selected OCM memory address, which is shared between the two processors. Each time its private timer expires, CPU1 will read this memory address and set its GPIO output pins accordingly. \n\n\u4f7f\u7528\u3059\u308b\u30e1\u30e2\u30ea\u30a2\u30c9\u30ec\u30b9\u3092\u9078\u629e\u3059\u308b\u3002\u305d\u306e\u305f\u3081\u306bOCM\u306e\u30ad\u30e3\u30c3\u30b7\u30e5\u3092\u5207\u308b\n\n```\nXil_SetTlbAttributes(0xFFFF0000,0x14de2);\n```\n\n\u6307\u5b9a\u306e\u30e1\u30e2\u30ea\u30a2\u30c9\u30ec\u30b9\u3078\u306e\u30c7\u30fc\u30bf\u8ee2\u9001\u65b9\u6cd5\u306f\uff12\u3064\u3042\u308b\u3002\n\n> The first method uses the generic Xilinx I/O functions to read from and write to the selected memory address.\n\n```\nXil_Out8(0xFFFF0000,0x55);\n \nread_char = Xil_In8(0xFFFF0000);\n``` \n\n> The second method is for both programs to access the memory location using pointers. \n\n```\n#define LED_OP (*(volatileunsignedint *)(0xFFFF0000))\n```\n\n", "tags": ["adamTaylor", "AMP"]}