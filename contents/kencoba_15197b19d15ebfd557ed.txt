{"context": " More than 1 year has passed since last update.\u975e\u5e38\u306b\u52c9\u5f37\u306b\u306a\u308b\u672c\u3067\u3059\u3002\n\u591a\u5206\u3001P25\u306e\u547d\u984c\u306e\u3046\u3061\u30012\u30684\u306f\u3001and\u3058\u3083\u306a\u304f\u3066implies\u3002\n\nStack.als\nmodule Queue\nabstract sig Node { next : lone Node }\nabstract sig Queue { root : lone Node }\n\nfact noCycle { no n : Node | n in n.^next }\nfact noReflexive { no n : Node | n = n.next }\nfact allNodeInAQueue {\n    all n : Node | some q : Queue | n in q.root.*next\n}\n\nsig Stack extends Queue {}\nfact hasBottom {\n    all s : Stack | Bottom in (s.root).*next\n}\nsig Entry extends Node { value : Value - Empty }\nfact entryHasNext {\n    all e : Entry | one e.next\n}\nsig Bottom extends Node {}\nfact bottomDontHaveNext { no Bottom.next }\n\nsig Value {}\none sig Empty extends Value {}\n\npred empty [s1 : Stack ] { s1.root = Bottom }\n\npred push [s1, s2 : Stack, v : Value ] {\n    some e1 : Entry |\n        e1.value = v && e1.next = s1.root && s2.root = e1\n}\n\npred pop [ s1, s2 : Stack] {\n    (s1.root = Bottom) => s2.root = s1.root\n                    else s2.root = (s1.root).next\n}\n\nfun top [ s1 : Stack ] : Value {\n    (s1.root = Bottom) => Empty else (s1.root).value\n}\n\nassert prop1 {\n    all s1, s, s2 : Stack, v : Value |\n        push[s1,s,v] and pop[s,s2] implies s1.root = s2.root\n}\n\nassert prop2 {\n    all s1, s2 : Stack, v : Value |\n        push[s1,s2,v] implies top[s2] = v\n}\n\nassert prop3 {\n    all s1, s2 : Stack |\n        empty[s1] and pop[s1,s2] implies s2.root = Bottom\n}\n\nassert prop4 {\n    all s1 : Stack |\n        empty[s1] implies top[s1] = Empty\n}\n\n\n\n\n\u975e\u5e38\u306b\u52c9\u5f37\u306b\u306a\u308b\u672c\u3067\u3059\u3002\n\n\u591a\u5206\u3001P25\u306e\u547d\u984c\u306e\u3046\u3061\u30012\u30684\u306f\u3001and\u3058\u3083\u306a\u304f\u3066implies\u3002\n\n```alloy:Stack.als\nmodule Queue\nabstract sig Node { next : lone Node }\nabstract sig Queue { root : lone Node }\n\nfact noCycle { no n : Node | n in n.^next }\nfact noReflexive { no n : Node | n = n.next }\nfact allNodeInAQueue {\n\tall n : Node | some q : Queue | n in q.root.*next\n}\n\nsig Stack extends Queue {}\nfact hasBottom {\n\tall s : Stack | Bottom in (s.root).*next\n}\nsig Entry extends Node { value : Value - Empty }\nfact entryHasNext {\n\tall e : Entry | one e.next\n}\nsig Bottom extends Node {}\nfact bottomDontHaveNext { no Bottom.next }\n\nsig Value {}\none sig Empty extends Value {}\n\npred empty [s1 : Stack ] { s1.root = Bottom }\n\npred push [s1, s2 : Stack, v : Value ] {\n\tsome e1 : Entry |\n\t\te1.value = v && e1.next = s1.root && s2.root = e1\n}\n\npred pop [ s1, s2 : Stack] {\n\t(s1.root = Bottom) => s2.root = s1.root\n\t\t\t\t\telse s2.root = (s1.root).next\n}\n\nfun top [ s1 : Stack ] : Value {\n\t(s1.root = Bottom) => Empty else (s1.root).value\n}\n\nassert prop1 {\n\tall s1, s, s2 : Stack, v : Value |\n\t\tpush[s1,s,v] and pop[s,s2] implies s1.root = s2.root\n}\n\nassert prop2 {\n\tall s1, s2 : Stack, v : Value |\n\t\tpush[s1,s2,v] implies top[s2] = v\n}\n\nassert prop3 {\n\tall s1, s2 : Stack |\n\t\tempty[s1] and pop[s1,s2] implies s2.root = Bottom\n}\n\nassert prop4 {\n\tall s1 : Stack |\n\t\tempty[s1] implies top[s1] = Empty\n}\n\n\n```", "tags": ["Alloy"]}