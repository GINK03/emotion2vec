{"tags": ["Arduino", "I2C", "mpu6050"], "context": " More than 1 year has passed since last update.\n\n\u6982\u8981\narduino uno\u306b\u30b8\u30e3\u30a4\u30ed\u3092\u3064\u306a\u3044\u3067\u307f\u305f\u3002\nmpu6050\u3092i2c\u3067\u3064\u306a\u3044\u3060\u3002\n\n\u5199\u771f\n\n\n\u30ed\u30b0\n\n\n\u56de\u8def\u56f3\n\n\n\u30b5\u30f3\u30d7\u30eb\u30b3\u30fc\u30c9\n#include \"I2Cdev.h\"\n#include \"MPU6050.h\"\n#include \"Wire.h\"\n\nMPU6050 mpu;\nunsigned long time = 0;\nfloat prev_X = 0;\nfloat prev_Y = 0;\nfloat prev_Z = 0;\nfloat angle_X = 0;\nfloat angle_Y = 0;\nfloat angle_Z = 0;\nint t = 0;\nvoid setup()\n{\n    int gx, gy, gz;\n    Wire.begin();\n    Serial.begin(115200);\n    while (!Serial);\n    Serial.println(\"initialize device ...\");\n    mpu.initialize();\n    delay(900);\n    Serial.println(mpu.testConnection() ? \"MPU6050 connection successful\" : \"MPU6050 connection failed\");\n    Serial.println(\"Updating internal sensor offsets...\");\n    mpu.setXGyroOffset(-464);\n    mpu.setYGyroOffset(-566);\n    mpu.setZGyroOffset(232);\n    Serial.print(mpu.getXGyroOffset());\n    Serial.print(\"\\t\");\n    Serial.print(mpu.getYGyroOffset());\n    Serial.print(\"\\t\");\n    Serial.println(mpu.getZGyroOffset());\n}\nvoid loop()\n{\n    int az, gx, gy, gz;\n    int sampleTime = 10;\n    if (millis() - time > sampleTime)\n    {\n        time = millis();\n        t++;\n        mpu.getRotation(&gx, &gy, &gz);\n        angle_X += ((prev_X + gx) * sampleTime) / 131000;\n        prev_X = gx;\n        if (angle_X < 0)\n        {\n            angle_X += 360;\n        }\n        else if (angle_X >= 360)\n        {\n            angle_X -= 360;\n        }\n        angle_Y += ((prev_Y + gy) * sampleTime) / 131000;\n        prev_Y = gy;\n        if (angle_Y < 0)\n        {\n            angle_Y += 360;\n        }\n        else if (angle_Y >= 360)\n        {\n            angle_Y -= 360;\n        }\n        angle_Z += ((prev_Z + gz) * sampleTime) / 131000;\n        prev_Z = gz;\n        if (angle_Z < 0)\n        {\n            angle_Z += 360;\n        }\n        else if (angle_Z >= 360)\n        {\n            angle_Z -= 360;\n        }\n        if (t > 100)\n        {\n            t = 0;\n            Serial.print(angle_X);\n            Serial.print(\" \");\n            Serial.print(angle_Y);\n            Serial.print(\" \");\n            Serial.println(angle_Z);\n        }\n    }\n}\n\n#\u6982\u8981\narduino uno\u306b\u30b8\u30e3\u30a4\u30ed\u3092\u3064\u306a\u3044\u3067\u307f\u305f\u3002\nmpu6050\u3092i2c\u3067\u3064\u306a\u3044\u3060\u3002\n#\u5199\u771f\n![MVC-019S.JPG](https://qiita-image-store.s3.amazonaws.com/0/18104/a69cd574-e1b6-16e1-24a9-ee951fe2e19a.jpeg)\n\n#\u30ed\u30b0\n![mpu.JPG](https://qiita-image-store.s3.amazonaws.com/0/18104/399b48b0-f9ec-5ea1-fbe0-45455036b086.jpeg)\n\n#\u56de\u8def\u56f3\n![mpu_6050.JPG](https://qiita-image-store.s3.amazonaws.com/0/18104/e8a76120-61e0-3648-fa20-e56d75cc9cbe.jpeg)\n\n#\u30b5\u30f3\u30d7\u30eb\u30b3\u30fc\u30c9\n```\n#include \"I2Cdev.h\"\n#include \"MPU6050.h\"\n#include \"Wire.h\"\n\nMPU6050 mpu;\nunsigned long time = 0;\nfloat prev_X = 0;\nfloat prev_Y = 0;\nfloat prev_Z = 0;\nfloat angle_X = 0;\nfloat angle_Y = 0;\nfloat angle_Z = 0;\nint t = 0;\nvoid setup()\n{\n\tint gx, gy, gz;\n\tWire.begin();\n\tSerial.begin(115200);\n\twhile (!Serial);\n\tSerial.println(\"initialize device ...\");\n\tmpu.initialize();\n\tdelay(900);\n\tSerial.println(mpu.testConnection() ? \"MPU6050 connection successful\" : \"MPU6050 connection failed\");\n\tSerial.println(\"Updating internal sensor offsets...\");\n\tmpu.setXGyroOffset(-464);\n\tmpu.setYGyroOffset(-566);\n\tmpu.setZGyroOffset(232);\n\tSerial.print(mpu.getXGyroOffset());\n\tSerial.print(\"\\t\");\n\tSerial.print(mpu.getYGyroOffset());\n\tSerial.print(\"\\t\");\n\tSerial.println(mpu.getZGyroOffset());\n}\nvoid loop()\n{\n\tint az, gx, gy, gz;\n\tint sampleTime = 10;\n\tif (millis() - time > sampleTime)\n\t{\n\t\ttime = millis();\n\t\tt++;\n\t\tmpu.getRotation(&gx, &gy, &gz);\n\t\tangle_X += ((prev_X + gx) * sampleTime) / 131000;\n\t\tprev_X = gx;\n\t\tif (angle_X < 0)\n\t\t{\n\t\t\tangle_X += 360;\n\t\t}\n\t\telse if (angle_X >= 360)\n\t\t{\n\t\t\tangle_X -= 360;\n\t\t}\n\t\tangle_Y += ((prev_Y + gy) * sampleTime) / 131000;\n\t\tprev_Y = gy;\n\t\tif (angle_Y < 0)\n\t\t{\n\t\t\tangle_Y += 360;\n\t\t}\n\t\telse if (angle_Y >= 360)\n\t\t{\n\t\t\tangle_Y -= 360;\n\t\t}\n\t\tangle_Z += ((prev_Z + gz) * sampleTime) / 131000;\n\t\tprev_Z = gz;\n\t\tif (angle_Z < 0)\n\t\t{\n\t\t\tangle_Z += 360;\n\t\t}\n\t\telse if (angle_Z >= 360)\n\t\t{\n\t\t\tangle_Z -= 360;\n\t\t}\n\t\tif (t > 100)\n\t\t{\n\t\t\tt = 0;\n\t\t\tSerial.print(angle_X);\n\t\t\tSerial.print(\" \");\n\t\t\tSerial.print(angle_Y);\n\t\t\tSerial.print(\" \");\n\t\t\tSerial.println(angle_Z);\n\t\t}\n\t}\n}\n```\n\n\n"}