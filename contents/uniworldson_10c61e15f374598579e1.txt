{"context": " More than 1 year has passed since last update.\n\nQuestions from your boss\n\nHow many products\nHow many developers fixed bugs\nAverage number of bugs fixed per developer\nHow many of our fixed bugs were reported by customers\n\nYour hope\nhoping to do the least amount of duplicate work and therefore produce the results faster\nSo\nyou make one complex query\n\nreport.sql\nSELECT COUNT(bp.product_id) AS how_many_products,\n  COUNT(dev.account_id) AS how_many_developers,\n  COUNT(b.bug_id)/COUNT(dev.account_id) AS avg_bugs_per_developer,\n  COUNT(cust.account_id) AS how_many_customers\nFROM Bugs b JOIN BugsProducts bp ON (b.bug_id = bp.bug_id) JOIN Accounts dev ON (b.assigned_to = dev.account_id)\nJOIN Accounts cust ON (b.reported_by = cust.account_id) WHERE cust.email NOT LIKE '%@example.com'\nGROUP BY bp.product_id;\n\n\n The result seems wrong\n\n17.1 Objective: Decrease SQL Queries\n\nHow can I do this with a single query?\n\n\none SQL query is difficult, complex, and expensive\ntwo SQL queries must be twice as bad \n\n\nSome programming framework(MyBatis)\nI can not solve these data without sql\n\n\nI can't write shell script! perl? what is it?\nExcel is good but i need a good format\nwhat? Database is on remote server???\n\n\n\n\n17.2 Antipattern: Solve a Complex Problem in One Step\n\n17.2.1 Out of your expectation\nLet's see an example\ncount the number of bugs fixed, and the number of bugs open, for a given product\n\ncartesian.sql\nSELECT p.product_id,\n         COUNT(f.bug_id) AS count_fixed,\n         COUNT(o.bug_id) AS count_open\nFROM BugsProducts p\nLEFT OUTER JOIN Bugs f ON (p.bug_id = f.bug_id AND f.status = 'FIXED') LEFT OUTER JOIN Bugs o ON (p.bug_id = o.bug_id AND o.status = 'OPEN') WHERE p.product_id = 1\nGROUP BY p.product_id;\n\n\n I don't think anyone will write such a query if he really know about SQL\n Tell me why? Give me a reason!!\nYou happen to know that in reality there are 12 fixed bugs and 7 open bugs for the given product\n\n\n\nproduct_id\ncount_fixed\ncount_open\n\n\n\n\n1\n84\n84\n\n\n\nWe got a Cartesian product\n\n\n17.2.2 More serious\n\nsimply hard to write\nhard to modify\nhard to debug\nbig runtime costs\n\n\n17.3 How to Recognize the Antipattern\n\nWhy are my sums and counts impossibly large?\nI\u2019ve been working on this monster SQL query all day!\ntake too long to figure out how to recode the SQL query\nTry putting another DISTINCT into the query\n\n\n17.4 Legitimate Uses of the Antipattern\n\nbusiness intelligence\nreporting tools\n\n Pay attention to report\u2019s complexity and the hours it takes to produce it\n But can i tell my boss that you need to organize the report by yourself.\n\n17.5 Solution: Divide and Conquer\n\nThe Law of Parsimony\nWhen you have two competing theories that make exactly the same predictions, the simpler one is the better.\n\n\n17.5.1 One Step at a Time\nsplit up a Spaghetti Query into several simpler queries\n\nsplit-query.sql\nSELECT p.product_id, COUNT(f.bug_id) AS count_fixed\nFROM BugsProducts p\nLEFT OUTER JOIN Bugs f ON (p.bug_id = f.bug_id AND f.status = 'FIXED') WHERE p.product_id = 1\nGROUP BY p.product_id;\n\nSELECT p.product_id, COUNT(o.bug_id) AS count_open\nFROM BugsProducts p\nLEFT OUTER JOIN Bugs o ON (p.bug_id = o.bug_id AND o.status = 'OPEN') WHERE p.product_id = 1\nGROUP BY p.product_id;\n\n\nMerits\n\nAvoid unwanted Cartesian product\nEasier to maintain when add another requirement\nEasier for SQL engine to do optimization\nEasier to share with others(Code review, explain .. etc.)\n\n\n17.5.2 Look for the UNION Label\n\nunion.sql\n(SELECT p.product_id, f.status, COUNT(f.bug_id) AS bug_count\nFROM BugsProducts p\nLEFT OUTER JOIN Bugs f ON (p.bug_id = f.bug_id AND f.status = 'FIXED') WHERE p.product_id = 1\nGROUP BY p.product_id, f.status)\nUNION ALL\n(SELECT p.product_id, o.status, COUNT(o.bug_id) AS bug_count\nFROM BugsProducts p\nLEFT OUTER JOIN Bugs o ON (p.bug_id = o.bug_id AND o.status = 'OPEN') WHERE p.product_id = 1\nGROUP BY p.product_id, o.status)\nORDER BY bug_count;\n\n\n\n17.5.2 Solving Your Boss\u2019s Problem\n\nHow many products\n\n\ncount-products.sql\nSELECT COUNT(*) AS how_many_products\nFROM Products;\n\n\n\nHow many developers fixed bugs\n\n\ncount-developers.sql\nSELECT COUNT(DISTINCT assigned_to) AS how_many_developers FROM Bugs\nWHERE status = 'FIXED';\n\n\n\nAverage number of bugs fixed per developer\n\n\nbugs-per-developer.sql\nSELECT AVG(bugs_per_developer) AS average_bugs_per_developer\n    FROM (SELECT dev.account_id, COUNT(*) AS bugs_per_developer\n        FROM Bugs b JOIN Accounts dev\n           ON (b.assigned_to = dev.account_id)\n        WHERE b.status = 'FIXED' \n        GROUP BY dev.account_id) t;\n\n\n\nHow many of our fixed bugs were reported by customers\n\n\nbugs-by-customers.sql\nSELECT COUNT(*) AS how_many_customer_bugs\nFROM Bugs b JOIN Accounts cust ON (b.reported_by = cust.account_id) WHERE b.status = 'FIXED' AND cust.email NOT LIKE '%@example.com';\n\n\n\n17.5.6 Writing SQL Automatically\u2014with SQL\nGenerate SQL by code\n\ngenerate-update.sql\nSELECT CONCAT('UPDATE Inventory '\n              ' SET last_used = ''', MAX(u.usage_date), '''',\n              ' WHERE inventory_id = ', u.inventory_id, ';\n              ') AS update_statement\n    FROM ComputerUsage u\n    GROUP BY u.inventory_id;\n\n\n\nBut I have a confuse\nHow to balance the query times and query time?(May be I am too young too simple)\n\nAn Example of myself\n\nquery.sql\nSELECT t1.reg_date,t1.COUNT, t2.COUNT,t3.COUNT,t4.COUNT,t5.COUNT,t6.COUNT,t7.COUNT,t8.COUNT,t9.COUNT,t10.COUNT, t11.COUNT,t12.COUNT,t13.COUNT,t14.COUNT   \nFROM \n(SELECT COUNT(DISTINCT user_id) AS COUNT,game_reg_date AS reg_date FROM login_log where game_id = xx AND login_date BETWEEN DATE_ADD(game_reg_date,INTERVAL 1 DAY) AND DATE_ADD(game_reg_date,INTERVAL 1 DAY) group by game_reg_date) AS t1,\n(SELECT COUNT(DISTINCT user_id) AS COUNT,game_reg_date AS reg_date FROM login_log where game_id = xx AND login_date BETWEEN DATE_ADD(game_reg_date,INTERVAL 1 DAY) AND DATE_ADD(game_reg_date,INTERVAL 2 DAY) group by game_reg_date) AS t2,\n(SELECT COUNT(DISTINCT user_id) AS COUNT,game_reg_date AS reg_date FROM login_log where game_id = xx AND login_date BETWEEN DATE_ADD(game_reg_date,INTERVAL 1 DAY) AND DATE_ADD(game_reg_date,INTERVAL 3 DAY) group by game_reg_date) AS t3,\n(SELECT COUNT(DISTINCT user_id) AS COUNT,game_reg_date AS reg_date FROM login_log where game_id = xx AND login_date BETWEEN DATE_ADD(game_reg_date,INTERVAL 1 DAY) AND DATE_ADD(game_reg_date,INTERVAL 4 DAY) group by game_reg_date) AS t4,\n(SELECT COUNT(DISTINCT user_id) AS COUNT,game_reg_date AS reg_date FROM login_log where game_id = xx AND login_date BETWEEN DATE_ADD(game_reg_date,INTERVAL 1 DAY) AND DATE_ADD(game_reg_date,INTERVAL 5 DAY) group by game_reg_date) AS t5, \n(SELECT COUNT(DISTINCT user_id) AS COUNT,game_reg_date AS reg_date FROM login_log where game_id = xx AND login_date BETWEEN DATE_ADD(game_reg_date,INTERVAL 1 DAY) AND DATE_ADD(game_reg_date,INTERVAL 6 DAY) group by game_reg_date) AS t6,\n(SELECT COUNT(DISTINCT user_id) AS COUNT,game_reg_date AS reg_date FROM login_log where game_id = xx AND login_date BETWEEN DATE_ADD(game_reg_date,INTERVAL 1 DAY) AND DATE_ADD(game_reg_date,INTERVAL 7 DAY) group by game_reg_date) AS t7,\n(SELECT COUNT(DISTINCT user_id) AS COUNT,game_reg_date AS reg_date FROM login_log where game_id = xx AND login_date BETWEEN DATE_ADD(game_reg_date,INTERVAL 1 DAY) AND DATE_ADD(game_reg_date,INTERVAL 8 DAY) group by game_reg_date) AS t8,\n(SELECT COUNT(DISTINCT user_id) AS COUNT,game_reg_date AS reg_date FROM login_log where game_id = xx AND login_date BETWEEN DATE_ADD(game_reg_date,INTERVAL 1 DAY) AND DATE_ADD(game_reg_date,INTERVAL 9 DAY) group by game_reg_date) AS t9,\n(SELECT COUNT(DISTINCT user_id) AS COUNT,game_reg_date AS reg_date FROM login_log where game_id = xx AND login_date BETWEEN DATE_ADD(game_reg_date,INTERVAL 1 DAY) AND DATE_ADD(game_reg_date,INTERVAL 2 DAY) group by game_reg_date) AS t10,\n(SELECT COUNT(DISTINCT user_id) AS COUNT,game_reg_date AS reg_date FROM login_log where game_id = xx AND login_date BETWEEN DATE_ADD(game_reg_date,INTERVAL 1 DAY) AND DATE_ADD(game_reg_date,INTERVAL 3 DAY) group by game_reg_date) AS t11,\n(SELECT COUNT(DISTINCT user_id) AS COUNT,game_reg_date AS reg_date FROM login_log where game_id = xx AND login_date BETWEEN DATE_ADD(game_reg_date,INTERVAL 1 DAY) AND DATE_ADD(game_reg_date,INTERVAL 4 DAY) group by game_reg_date) AS t12,\n(SELECT COUNT(DISTINCT user_id) AS COUNT,game_reg_date AS reg_date FROM login_log where game_id = xx AND login_date BETWEEN DATE_ADD(game_reg_date,INTERVAL 1 DAY) AND DATE_ADD(game_reg_date,INTERVAL 5 DAY) group by game_reg_date) AS t13, \n(SELECT COUNT(DISTINCT user_id) AS COUNT,game_reg_date AS reg_date FROM login_log where game_id = xx AND login_date BETWEEN DATE_ADD(game_reg_date,INTERVAL 1 DAY) AND DATE_ADD(game_reg_date,INTERVAL 6 DAY) group by game_reg_date) AS t14 \nwhere t1.reg_date = t2.reg_date AND t1.reg_date=t3.reg_date AND t4.reg_date=t1.reg_date AND t1.reg_date=t5.reg_date AND t1.reg_date = t6.reg_date AND t1.reg_date = t7.reg_date AND t1.reg_date = t8.reg_date \nAND t1.reg_date = t9.reg_date AND t1.reg_date=t10.reg_date AND t11.reg_date=t1.reg_date AND t1.reg_date=t12.reg_date AND t1.reg_date = t13.reg_date AND t1.reg_date = t14.reg_date; \n\n\n# Questions from your boss\n\n* How many products\n* How many developers fixed bugs\n* Average number of bugs fixed per developer\n* How many of our fixed bugs were reported by customers\n\n**Your hope**\nhoping to do the least amount of duplicate work and therefore produce the results faster\n**So**\nyou make one complex query\n\n```sql:report.sql\nSELECT COUNT(bp.product_id) AS how_many_products,\n  COUNT(dev.account_id) AS how_many_developers,\n  COUNT(b.bug_id)/COUNT(dev.account_id) AS avg_bugs_per_developer,\n  COUNT(cust.account_id) AS how_many_customers\nFROM Bugs b JOIN BugsProducts bp ON (b.bug_id = bp.bug_id) JOIN Accounts dev ON (b.assigned_to = dev.account_id)\nJOIN Accounts cust ON (b.reported_by = cust.account_id) WHERE cust.email NOT LIKE '%@example.com'\nGROUP BY bp.product_id;\n```\n:sob: The result seems wrong\n\n# 17.1 Objective: Decrease SQL Queries\n* How can I do this with a single query?\n * one SQL query is difficult, complex, and expensive\n * two SQL queries must be twice as bad \n* Some programming framework([MyBatis](http://mybatis.github.io/mybatis-3/ja/))\n* I can not solve these data without sql\n * I can't write shell script! perl? what is it?\n * Excel is good but i need a good format\n * what? Database is on remote server???\n\n# 17.2 Antipattern: Solve a Complex Problem in One Step\n## 17.2.1 Out of your expectation\n**Let's see an example**\ncount the number of bugs fixed, and the number of bugs open, for a given product\n\n```sql:cartesian.sql\nSELECT p.product_id,\n         COUNT(f.bug_id) AS count_fixed,\n         COUNT(o.bug_id) AS count_open\nFROM BugsProducts p\nLEFT OUTER JOIN Bugs f ON (p.bug_id = f.bug_id AND f.status = 'FIXED') LEFT OUTER JOIN Bugs o ON (p.bug_id = o.bug_id AND o.status = 'OPEN') WHERE p.product_id = 1\nGROUP BY p.product_id;\n```\n:scream: I don't think anyone will write such a query if he really know about SQL\n\n:broken_heart: **Tell me why? Give me a reason!!**\n\nYou happen to know that in reality there are 12 fixed bugs and 7 open bugs for the given product\n\n| product_id | count_fixed | count_open |\n|:-----------:|:------------:|:------------:|\n|1|84 |84| \n\n**We got a Cartesian product**\n\n![b51fad2d29628a1a53e0049f05320761.png](https://qiita-image-store.s3.amazonaws.com/0/43102/7f384f53-4fb4-ddfe-4f7f-ebd3b9428b6d.png)\n\n## 17.2.2 More serious\n* simply hard to write\n* hard to modify\n* hard to debug\n* big runtime costs\n\n# 17.3 How to Recognize the Antipattern\n* Why are my sums and counts impossibly large?\n* I\u2019ve been working on this monster SQL query all day!\n* take too long to figure out how to recode the SQL query\n* Try putting another DISTINCT into the query\n\n# 17.4 Legitimate Uses of the Antipattern\n* business intelligence\n* reporting tools\n\n:exclamation: Pay attention to report\u2019s complexity and the hours it takes to produce it\n\n:astonished: But can i tell my boss that you need to organize the report by yourself.\n\n# 17.5 Solution: Divide and Conquer\n> **The Law of Parsimony**\n\n> When you have two competing theories that make exactly the same predictions, the simpler one is the better.\n\n## 17.5.1 One Step at a Time\n\n**split up a Spaghetti Query into several simpler queries**\n\n```sql:split-query.sql\nSELECT p.product_id, COUNT(f.bug_id) AS count_fixed\nFROM BugsProducts p\nLEFT OUTER JOIN Bugs f ON (p.bug_id = f.bug_id AND f.status = 'FIXED') WHERE p.product_id = 1\nGROUP BY p.product_id;\n\nSELECT p.product_id, COUNT(o.bug_id) AS count_open\nFROM BugsProducts p\nLEFT OUTER JOIN Bugs o ON (p.bug_id = o.bug_id AND o.status = 'OPEN') WHERE p.product_id = 1\nGROUP BY p.product_id;\n```\n\n**Merits**\n\n* Avoid unwanted Cartesian product\n* Easier to maintain when add another requirement\n* Easier for SQL engine to do optimization\n* Easier to share with others(Code review, explain .. etc.)\n\n## 17.5.2 Look for the UNION Label\n\n```sql:union.sql\n(SELECT p.product_id, f.status, COUNT(f.bug_id) AS bug_count\nFROM BugsProducts p\nLEFT OUTER JOIN Bugs f ON (p.bug_id = f.bug_id AND f.status = 'FIXED') WHERE p.product_id = 1\nGROUP BY p.product_id, f.status)\nUNION ALL\n(SELECT p.product_id, o.status, COUNT(o.bug_id) AS bug_count\nFROM BugsProducts p\nLEFT OUTER JOIN Bugs o ON (p.bug_id = o.bug_id AND o.status = 'OPEN') WHERE p.product_id = 1\nGROUP BY p.product_id, o.status)\nORDER BY bug_count;\n```\n## 17.5.2 Solving Your Boss\u2019s Problem\n\n* How many products\n\n```sql:count-products.sql\nSELECT COUNT(*) AS how_many_products\nFROM Products;\n```\n* How many developers fixed bugs\n\n```sql:count-developers.sql\nSELECT COUNT(DISTINCT assigned_to) AS how_many_developers FROM Bugs\nWHERE status = 'FIXED';\n```\n\n* Average number of bugs fixed per developer\n\n```sql:bugs-per-developer.sql\nSELECT AVG(bugs_per_developer) AS average_bugs_per_developer\n    FROM (SELECT dev.account_id, COUNT(*) AS bugs_per_developer\n        FROM Bugs b JOIN Accounts dev\n           ON (b.assigned_to = dev.account_id)\n        WHERE b.status = 'FIXED' \n        GROUP BY dev.account_id) t;\n```\n* How many of our fixed bugs were reported by customers\n\n```sql:bugs-by-customers.sql\nSELECT COUNT(*) AS how_many_customer_bugs\nFROM Bugs b JOIN Accounts cust ON (b.reported_by = cust.account_id) WHERE b.status = 'FIXED' AND cust.email NOT LIKE '%@example.com';\n```\n\n## 17.5.6 Writing SQL Automatically\u2014with SQL\n\nGenerate SQL by code\n\n```sql:generate-update.sql\nSELECT CONCAT('UPDATE Inventory '\n              ' SET last_used = ''', MAX(u.usage_date), '''',\n              ' WHERE inventory_id = ', u.inventory_id, ';\n              ') AS update_statement\n    FROM ComputerUsage u\n    GROUP BY u.inventory_id;\n```\n\n## But I have a confuse\n\nHow to balance the query times and query time?(May be I am too young too simple)\n\n# An Example of myself\n\n```sql:query.sql\nSELECT t1.reg_date,t1.COUNT, t2.COUNT,t3.COUNT,t4.COUNT,t5.COUNT,t6.COUNT,t7.COUNT,t8.COUNT,t9.COUNT,t10.COUNT, t11.COUNT,t12.COUNT,t13.COUNT,t14.COUNT   \nFROM \n(SELECT COUNT(DISTINCT user_id) AS COUNT,game_reg_date AS reg_date FROM login_log where game_id = xx AND login_date BETWEEN DATE_ADD(game_reg_date,INTERVAL 1 DAY) AND DATE_ADD(game_reg_date,INTERVAL 1 DAY) group by game_reg_date) AS t1,\n(SELECT COUNT(DISTINCT user_id) AS COUNT,game_reg_date AS reg_date FROM login_log where game_id = xx AND login_date BETWEEN DATE_ADD(game_reg_date,INTERVAL 1 DAY) AND DATE_ADD(game_reg_date,INTERVAL 2 DAY) group by game_reg_date) AS t2,\n(SELECT COUNT(DISTINCT user_id) AS COUNT,game_reg_date AS reg_date FROM login_log where game_id = xx AND login_date BETWEEN DATE_ADD(game_reg_date,INTERVAL 1 DAY) AND DATE_ADD(game_reg_date,INTERVAL 3 DAY) group by game_reg_date) AS t3,\n(SELECT COUNT(DISTINCT user_id) AS COUNT,game_reg_date AS reg_date FROM login_log where game_id = xx AND login_date BETWEEN DATE_ADD(game_reg_date,INTERVAL 1 DAY) AND DATE_ADD(game_reg_date,INTERVAL 4 DAY) group by game_reg_date) AS t4,\n(SELECT COUNT(DISTINCT user_id) AS COUNT,game_reg_date AS reg_date FROM login_log where game_id = xx AND login_date BETWEEN DATE_ADD(game_reg_date,INTERVAL 1 DAY) AND DATE_ADD(game_reg_date,INTERVAL 5 DAY) group by game_reg_date) AS t5, \n(SELECT COUNT(DISTINCT user_id) AS COUNT,game_reg_date AS reg_date FROM login_log where game_id = xx AND login_date BETWEEN DATE_ADD(game_reg_date,INTERVAL 1 DAY) AND DATE_ADD(game_reg_date,INTERVAL 6 DAY) group by game_reg_date) AS t6,\n(SELECT COUNT(DISTINCT user_id) AS COUNT,game_reg_date AS reg_date FROM login_log where game_id = xx AND login_date BETWEEN DATE_ADD(game_reg_date,INTERVAL 1 DAY) AND DATE_ADD(game_reg_date,INTERVAL 7 DAY) group by game_reg_date) AS t7,\n(SELECT COUNT(DISTINCT user_id) AS COUNT,game_reg_date AS reg_date FROM login_log where game_id = xx AND login_date BETWEEN DATE_ADD(game_reg_date,INTERVAL 1 DAY) AND DATE_ADD(game_reg_date,INTERVAL 8 DAY) group by game_reg_date) AS t8,\n(SELECT COUNT(DISTINCT user_id) AS COUNT,game_reg_date AS reg_date FROM login_log where game_id = xx AND login_date BETWEEN DATE_ADD(game_reg_date,INTERVAL 1 DAY) AND DATE_ADD(game_reg_date,INTERVAL 9 DAY) group by game_reg_date) AS t9,\n(SELECT COUNT(DISTINCT user_id) AS COUNT,game_reg_date AS reg_date FROM login_log where game_id = xx AND login_date BETWEEN DATE_ADD(game_reg_date,INTERVAL 1 DAY) AND DATE_ADD(game_reg_date,INTERVAL 2 DAY) group by game_reg_date) AS t10,\n(SELECT COUNT(DISTINCT user_id) AS COUNT,game_reg_date AS reg_date FROM login_log where game_id = xx AND login_date BETWEEN DATE_ADD(game_reg_date,INTERVAL 1 DAY) AND DATE_ADD(game_reg_date,INTERVAL 3 DAY) group by game_reg_date) AS t11,\n(SELECT COUNT(DISTINCT user_id) AS COUNT,game_reg_date AS reg_date FROM login_log where game_id = xx AND login_date BETWEEN DATE_ADD(game_reg_date,INTERVAL 1 DAY) AND DATE_ADD(game_reg_date,INTERVAL 4 DAY) group by game_reg_date) AS t12,\n(SELECT COUNT(DISTINCT user_id) AS COUNT,game_reg_date AS reg_date FROM login_log where game_id = xx AND login_date BETWEEN DATE_ADD(game_reg_date,INTERVAL 1 DAY) AND DATE_ADD(game_reg_date,INTERVAL 5 DAY) group by game_reg_date) AS t13, \n(SELECT COUNT(DISTINCT user_id) AS COUNT,game_reg_date AS reg_date FROM login_log where game_id = xx AND login_date BETWEEN DATE_ADD(game_reg_date,INTERVAL 1 DAY) AND DATE_ADD(game_reg_date,INTERVAL 6 DAY) group by game_reg_date) AS t14 \nwhere t1.reg_date = t2.reg_date AND t1.reg_date=t3.reg_date AND t4.reg_date=t1.reg_date AND t1.reg_date=t5.reg_date AND t1.reg_date = t6.reg_date AND t1.reg_date = t7.reg_date AND t1.reg_date = t8.reg_date \nAND t1.reg_date = t9.reg_date AND t1.reg_date=t10.reg_date AND t11.reg_date=t1.reg_date AND t1.reg_date=t12.reg_date AND t1.reg_date = t13.reg_date AND t1.reg_date = t14.reg_date; \n```\n", "tags": ["SQL\u30a2\u30f3\u30c1\u30d1\u30bf\u30fc\u30f3", "\u52c9\u5f37\u4f1a"]}