{"context": " More than 1 year has passed since last update.\u30d1\u30d5\u30a9\u30fc\u30de\u30f3\u30b9\u4e0a\u306e\u554f\u984c\u304b\u3089\u4ed5\u65b9\u306a\u304fC++\u3067\u66f8\u3044\u3066\u308b\u6642\u306b\u3046\u3063\u304b\u308a\u30a8\u30b9\u30b1\u30fc\u30d7\u30b7\u30fc\u30b1\u30f3\u30b9\u3055\u308c\u305fUnicode\u306b\u51fa\u304f\u308f\u3059\u4e8b\u304c\u3042\u308a\u307e\u3059\u3002\u77e5\u3089\u306a\u3044\u4eba\u5411\u3051\u306b\u66f8\u3044\u3066\u304a\u304f\u3068\u3001\\uXXXX(X\u306f\u5341\u516d\u9032)\u306e6\u30d0\u30a4\u30c8\u306e\u5f62\u3067Unicode\u306e1\u6587\u5b57\u304c\u8868\u3055\u308c\u308b\u6587\u5b57\u306e\u8868\u8a18\u65b9\u6cd5\u3067\u3059\u3002\n\u3042\u3068\u30b5\u30ed\u30b2\u30fc\u30c8\u30da\u30a2\u3063\u3066\u306e\u306b\u6c17\u3092\u4f7f\u3046\u5fc5\u8981\u304c\u3042\u308a\u307e\u3059\u3002\nunicode\u5168\u90e8\u306f\u4eca\u306e\u3068\u3053\u308d111\u4e072,064\u6587\u5b57\u5206\u306e\u7a7a\u9593\u304c\u3042\u308aWikipedia\u306eUnicode\u3001\\uXXXX\u306e16\u90324\u6587\u5b57\u3058\u30836\u4e075536\u6587\u5b57\u3057\u304b\u7121\u304f\u3066\u5727\u5012\u7684\u306b\u8db3\u308a\u306a\u3044\u306e\u3067\u3001\\uXXXX\\uXXXXX\u3068\u3044\u30462\u3064\u306e\u30da\u30a2\u30671\u3064\u306eunicode\u306b\u5bfe\u5fdc\u3055\u305b\u3066\u308b\u7269\u3092\u8a00\u3044\u307e\u3059\u3002\n\u8a73\u3057\u304f\u306f\u3053\u3061\u3089utf8\u306eRFC\u3092\u3002\nstd::string\u306e\u5f62\u3067\u30a8\u30b9\u30b1\u30fc\u30d7\u30b7\u30fc\u30b1\u30f3\u30b9\u3055\u308c\u305fUnicode\u8cb0\u3063\u305f\u6642\u306b\u305d\u308c\u3092\u65e5\u672c\u8a9e\u306b\u3057\u3066\u8868\u793a\u3057\u305f\u3044\u3063\u3066\u72b6\u6cc1\u304c\u3088\u304f\u3042\u308b\u3068\u601d\u3046\u306e\u3067\u305d\u308c\u3092\u5b9f\u73fe\u3059\u308b\u95a2\u6570\u66f8\u304d\u307e\u3057\u305f\u3002\u5931\u6557\u3057\u305f\u3089false\u304c\u8fd4\u308a\u307e\u3059\u3002\n\u7b2c\u4e00\u5f15\u6570\u304c\u30a8\u30b9\u30b1\u30fc\u30d7\u30b7\u30fc\u30b1\u30f3\u30b9\u3055\u308c\u305f\u6587\u5b57\u5217\u3002\u7b2c\u4e8c\u5f15\u6570\u304cutf8\u3092\u5165\u308c\u3066\u6b32\u3057\u3044\u6587\u5b57\u5217\u3002\n#include <string>\n\n//   Char. number range  |        UTF-8 octet sequence\n//      (hexadecimal)    |              (binary)\n//   --------------------+---------------------------------------------\n//   0000 0000-0000 007F | 0xxxxxxx\n//   0000 0080-0000 07FF | 110xxxxx 10xxxxxx\n//   0000 0800-0000 FFFF | 1110xxxx 10xxxxxx 10xxxxxx\n//   0001 0000-0010 FFFF | 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx\n\nbool decode_unicode_escape_to_utf8(const std::string& src, std::string& dst) {\n  std::string result(\"\");\n  result.resize(src.size());\n\n  for (size_t i = 0; i < result.size(); ++i) {\n    result[i] = '\\0';\n  }\n\n  size_t result_index = 0;\n  bool in_surrogate_pair = false;\n  size_t surrogate_buffer = 0;\n  for (size_t i = 0; i < src.size(); ++i) {\n    if (i + 1 < src.size() && src[i] == '\\\\' && src[i+1] == 'u') {\n      size_t octet = 0;\n      {  // calculate octet\n        const char* const hex = &src[i + 2];\n        for (int j = 0; j < 4; ++j) {\n          octet *= 16;\n          if ('0' <= hex[j] && hex[j] <= '9') {\n            octet += static_cast<int>(hex[j] - '0');\n          } else if ('a' <= hex[j] && hex[j] <= 'f') {\n            octet += static_cast<int>(hex[j] - 'a' + 10);\n          } else if ('A' <= hex[j] && hex[j] <= 'F') {\n            octet += static_cast<int>(hex[j] - 'A' + 10);\n          } else {\n            return false;\n          }\n        }\n      }\n      {  // fill up sequence\n        char* const sequence = &result[result_index];\n        if (in_surrogate_pair) {\n          if (0xdc00 <= octet && octet <= 0xdfff) {\n            // low surrogate pair\n            const size_t joined = surrogate_buffer + (octet & 0x03ff) + 0x10000;\n            sequence[0] = (static_cast<char>(joined >> 18)  &  0x3) | 0xf0;\n            sequence[1] = (static_cast<char>(joined >> 12)  & 0x3f) | 0x80;\n            sequence[2] = (static_cast<char>(joined >> 6)   & 0x3f) | 0x80;\n            sequence[3] = (static_cast<char>(joined & 0xff) & 0x3f) | 0x80;\n            result_index += 4;\n            in_surrogate_pair = false;\n          } else {\n            return false;\n          }\n        } else if (octet < 0x7f) {\n          sequence[0] = static_cast<char>(octet) & 0x7f;\n          result_index += 1;\n        } else if (octet < 0x7ff) {\n          sequence[0] = (static_cast<char>(octet >> 6) & 0xdf) | 0xc0;\n          sequence[1] = (static_cast<char>(octet)      & 0x3f) | 0x80;\n          result_index += 2;\n        } else if (0xdbff) {\n          // high surrogate pair\n          in_surrogate_pair = true;\n          surrogate_buffer = (octet & 0x03ff) * 0x400;\n        } else {\n          sequence[0] = (static_cast<char>(octet >> 12) & 0x0f) | 0xe0;\n          sequence[1] = (static_cast<char>(octet >> 6)  & 0x3f) | 0x80;\n          sequence[2] = (static_cast<char>(octet)       & 0x3f) | 0x80;\n          result_index += 3;\n        }\n      }\n      i += 5;  // \\\\uXXXX is 6 bytes, so + 5 here, and + 1 in next loop\n    } else {  // not unicode\n      if (in_surrogate_pair) {\n        return false;\n      }\n      result[result_index] = src[i];\n      result_index += 1;\n    }\n    // next char\n  }\n  result.resize(result_index);\n  dst.swap(result);\n  return true;\n}\n\n\u4f7f\u3044\u65b9\u306f\u3053\u3093\u306a\u611f\u3058\u3002\n#include <assert.h>\n#include <iostream>\nint main() {\n  std::string input(\"\\u30ed\\u30c3\\u30af\\u30d5\\u30ea\\u30fc\"), result;\n\n  bool complete = decode_unicode_escape_to_utf8(input, result);\n  assert(complete);\n\n  std::cout << result << std::endl;\n}\n\n\u51fa\u529b \n\u30ed\u30c3\u30af\u30d5\u30ea\u30fc\n\u30d1\u30d5\u30a9\u30fc\u30de\u30f3\u30b9\u4e0a\u306e\u554f\u984c\u304b\u3089\u4ed5\u65b9\u306a\u304fC++\u3067\u66f8\u3044\u3066\u308b\u6642\u306b\u3046\u3063\u304b\u308a\u30a8\u30b9\u30b1\u30fc\u30d7\u30b7\u30fc\u30b1\u30f3\u30b9\u3055\u308c\u305fUnicode\u306b\u51fa\u304f\u308f\u3059\u4e8b\u304c\u3042\u308a\u307e\u3059\u3002\u77e5\u3089\u306a\u3044\u4eba\u5411\u3051\u306b\u66f8\u3044\u3066\u304a\u304f\u3068\u3001`\\uXXXX`(X\u306f\u5341\u516d\u9032)\u306e6\u30d0\u30a4\u30c8\u306e\u5f62\u3067Unicode\u306e1\u6587\u5b57\u304c\u8868\u3055\u308c\u308b\u6587\u5b57\u306e\u8868\u8a18\u65b9\u6cd5\u3067\u3059\u3002\n\n \u3042\u3068\u30b5\u30ed\u30b2\u30fc\u30c8\u30da\u30a2\u3063\u3066\u306e\u306b\u6c17\u3092\u4f7f\u3046\u5fc5\u8981\u304c\u3042\u308a\u307e\u3059\u3002\nunicode\u5168\u90e8\u306f\u4eca\u306e\u3068\u3053\u308d111\u4e072,064\u6587\u5b57\u5206\u306e\u7a7a\u9593\u304c\u3042\u308a[Wikipedia\u306eUnicode](http://ja.wikipedia.org/wiki/Unicode)\u3001\\uXXXX\u306e16\u90324\u6587\u5b57\u3058\u30836\u4e075536\u6587\u5b57\u3057\u304b\u7121\u304f\u3066\u5727\u5012\u7684\u306b\u8db3\u308a\u306a\u3044\u306e\u3067\u3001`\\uXXXX\\uXXXXX`\u3068\u3044\u30462\u3064\u306e\u30da\u30a2\u30671\u3064\u306eunicode\u306b\u5bfe\u5fdc\u3055\u305b\u3066\u308b\u7269\u3092\u8a00\u3044\u307e\u3059\u3002\n\u8a73\u3057\u304f\u306f\u3053\u3061\u3089[utf8\u306eRFC](http://tools.ietf.org/html/rfc3629)\u3092\u3002\n\n`std::string`\u306e\u5f62\u3067\u30a8\u30b9\u30b1\u30fc\u30d7\u30b7\u30fc\u30b1\u30f3\u30b9\u3055\u308c\u305fUnicode\u8cb0\u3063\u305f\u6642\u306b\u305d\u308c\u3092\u65e5\u672c\u8a9e\u306b\u3057\u3066\u8868\u793a\u3057\u305f\u3044\u3063\u3066\u72b6\u6cc1\u304c\u3088\u304f\u3042\u308b\u3068\u601d\u3046\u306e\u3067\u305d\u308c\u3092\u5b9f\u73fe\u3059\u308b\u95a2\u6570\u66f8\u304d\u307e\u3057\u305f\u3002\u5931\u6557\u3057\u305f\u3089false\u304c\u8fd4\u308a\u307e\u3059\u3002\n\u7b2c\u4e00\u5f15\u6570\u304c\u30a8\u30b9\u30b1\u30fc\u30d7\u30b7\u30fc\u30b1\u30f3\u30b9\u3055\u308c\u305f\u6587\u5b57\u5217\u3002\u7b2c\u4e8c\u5f15\u6570\u304cutf8\u3092\u5165\u308c\u3066\u6b32\u3057\u3044\u6587\u5b57\u5217\u3002\n\n\n```cpp:\n#include <string>\n\n//   Char. number range  |        UTF-8 octet sequence\n//      (hexadecimal)    |              (binary)\n//   --------------------+---------------------------------------------\n//   0000 0000-0000 007F | 0xxxxxxx\n//   0000 0080-0000 07FF | 110xxxxx 10xxxxxx\n//   0000 0800-0000 FFFF | 1110xxxx 10xxxxxx 10xxxxxx\n//   0001 0000-0010 FFFF | 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx\n\nbool decode_unicode_escape_to_utf8(const std::string& src, std::string& dst) {\n  std::string result(\"\");\n  result.resize(src.size());\n\n  for (size_t i = 0; i < result.size(); ++i) {\n    result[i] = '\\0';\n  }\n\n  size_t result_index = 0;\n  bool in_surrogate_pair = false;\n  size_t surrogate_buffer = 0;\n  for (size_t i = 0; i < src.size(); ++i) {\n    if (i + 1 < src.size() && src[i] == '\\\\' && src[i+1] == 'u') {\n      size_t octet = 0;\n      {  // calculate octet\n        const char* const hex = &src[i + 2];\n        for (int j = 0; j < 4; ++j) {\n          octet *= 16;\n          if ('0' <= hex[j] && hex[j] <= '9') {\n            octet += static_cast<int>(hex[j] - '0');\n          } else if ('a' <= hex[j] && hex[j] <= 'f') {\n            octet += static_cast<int>(hex[j] - 'a' + 10);\n          } else if ('A' <= hex[j] && hex[j] <= 'F') {\n            octet += static_cast<int>(hex[j] - 'A' + 10);\n          } else {\n            return false;\n          }\n        }\n      }\n      {  // fill up sequence\n        char* const sequence = &result[result_index];\n        if (in_surrogate_pair) {\n          if (0xdc00 <= octet && octet <= 0xdfff) {\n            // low surrogate pair\n            const size_t joined = surrogate_buffer + (octet & 0x03ff) + 0x10000;\n            sequence[0] = (static_cast<char>(joined >> 18)  &  0x3) | 0xf0;\n            sequence[1] = (static_cast<char>(joined >> 12)  & 0x3f) | 0x80;\n            sequence[2] = (static_cast<char>(joined >> 6)   & 0x3f) | 0x80;\n            sequence[3] = (static_cast<char>(joined & 0xff) & 0x3f) | 0x80;\n            result_index += 4;\n            in_surrogate_pair = false;\n          } else {\n            return false;\n          }\n        } else if (octet < 0x7f) {\n          sequence[0] = static_cast<char>(octet) & 0x7f;\n          result_index += 1;\n        } else if (octet < 0x7ff) {\n          sequence[0] = (static_cast<char>(octet >> 6) & 0xdf) | 0xc0;\n          sequence[1] = (static_cast<char>(octet)      & 0x3f) | 0x80;\n          result_index += 2;\n        } else if (0xdbff) {\n          // high surrogate pair\n          in_surrogate_pair = true;\n          surrogate_buffer = (octet & 0x03ff) * 0x400;\n        } else {\n          sequence[0] = (static_cast<char>(octet >> 12) & 0x0f) | 0xe0;\n          sequence[1] = (static_cast<char>(octet >> 6)  & 0x3f) | 0x80;\n          sequence[2] = (static_cast<char>(octet)       & 0x3f) | 0x80;\n          result_index += 3;\n        }\n      }\n      i += 5;  // \\\\uXXXX is 6 bytes, so + 5 here, and + 1 in next loop\n    } else {  // not unicode\n      if (in_surrogate_pair) {\n        return false;\n      }\n      result[result_index] = src[i];\n      result_index += 1;\n    }\n    // next char\n  }\n  result.resize(result_index);\n  dst.swap(result);\n  return true;\n}\n```\n\n\u4f7f\u3044\u65b9\u306f\u3053\u3093\u306a\u611f\u3058\u3002\n\n```cpp:\n#include <assert.h>\n#include <iostream>\nint main() {\n  std::string input(\"\\u30ed\\u30c3\\u30af\\u30d5\\u30ea\\u30fc\"), result;\n\n  bool complete = decode_unicode_escape_to_utf8(input, result);\n  assert(complete);\n\n  std::cout << result << std::endl;\n}\n```\n\n\u51fa\u529b \n`\u30ed\u30c3\u30af\u30d5\u30ea\u30fc`", "tags": ["C++", "unicode", "Unicode\u30a8\u30b9\u30b1\u30fc\u30d7\u30b7\u30fc\u30b1\u30f3\u30b9\u5f62\u5f0f"]}