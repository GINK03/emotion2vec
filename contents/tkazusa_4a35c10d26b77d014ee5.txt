{"context": " More than 1 year has passed since last update.\u4f5c\u3063\u305fPyspark\u306e\u74b0\u5883\u3067Map\u95a2\u6570\u306e\u7df4\u7fd2\u30ea\u30c3\u30b8\u56de\u5e30\u3084\u3063\u3066\u307f\u307e\u3057\u305f\u3002\n\u5143\u30cd\u30bf\u306fedX\u306eScalable Machine Learning\u3068\u3044\u3046\u8b1b\u7fa9\u304b\u3089\u3002\n\u30c7\u30fc\u30bf\u306fMillionSongDataset\u304b\u3089\u53d6\u5f97\u3067\u304d\u307e\u3059\u3002\n\u3067\u3001\u7d50\u679c\u304b\u3089\u5148\u306b\u66f8\u304d\u307e\u3059\u3068\u3001Default\u5024\u542b\u3081\u3066Gridsearch\u3057\u305f\u306b\u3082\u95a2\u308f\u3089\u305a\u3001\nDefault\u5024\u5b9f\u65bd\u3057\u305f\u56de\u5e30\u306e\u65b9\u304c\u7cbe\u5ea6\u304c\u9ad8\u304f\u306a\u308b\u3068\u3044\u3046\u9f3b\u8840\u304c\u51fa\u305d\u3046\u306a\u7d50\u679c\u306b\u306a\u3063\u3066\u3057\u307e\u3063\u3066\u307e\u3059\u3002\n\u307e\u305a\u306f\u3082\u308d\u3082\u308dimport\u3002\n#library import\nfrom pyspark.mllib.regression import LinearRegressionWithSGD\nfrom pyspark.mllib.regression import LabeledPoint\nfrom test_helper import Test\nimport numpy as np\n\n#data load\nrawData = sc.textFile('millionsong.txt')\n\n\n\u30ea\u30c3\u30b8\u56de\u5e30(\u30c7\u30d5\u30a9\u30eb\u30c8\uff09\n\u4f7f\u3063\u305f\u306e\u306fLinearRegressionWithSGD\u3002\nsamplePoints = rawData.take(2)\n\n#Create LabeledPoint\ndef parsePoint(line):\n\n    tokens = line.split(',')\n    label = tokens[0]\n    features = tokens[1:]\n    return LabeledPoint(label, features)\n\nparsedData = rawData.map(parsePoint)\nprint parsedData.take(3)\n\n[LabeledPoint(2001.0, [0.884123733793,0.610454259079,0.600498416968,0.474669212493,0.247232680947,0.357306088914,0.344136412234,0.339641227335,0.600858840135,0.425704689024,0.60491501652,0.419193351817]), LabeledPoint(2001.0, [0.854411946129,0.604124786151,0.593634078776,0.495885413963,0.266307830936,0.261472105188,0.506387076327,0.464453565511,0.665798573683,0.542968988766,0.58044428577,0.445219373624]), LabeledPoint(2001.0, [0.908982970575,0.632063159227,0.557428975183,0.498263761394,0.276396052336,0.312809861625,0.448530069406,0.448674249968,0.649791323916,0.489868662682,0.591908113534,0.4500023818])]\n\n\u6b21\u306b\u30c7\u30fc\u30bf\u3092Traning\u3001Validation,Test\u306b\u5206\u5272\u3002\n#Devide rawData into Traning, Validation and Test\nweights = [.8, .1, .1]\nseed = 50\nparsedTrainData, parsedValData, parsedTestData = parsedData.randomSplit(weights, seed)\n\n# Fit the model with default values\nfitModel = LinearRegressionWithSGD.train(parsedTrainData)\nprint  fitModel\n\n(weights=[348.391703677,312.158507888,303.514705245,268.768326368,260.265535915,321.082923267,345.636059404,369.96940298,414.587178279,328.611497772,389.972179858,348.42792115], intercept=0.0)\n\n\u3053\u306e\u30e2\u30c7\u30eb\u3092\u5143\u306b\u3001\u5b9f\u6e2c\u5024\u3068\u4e88\u6e2c\u5024\u306e\u6bd4\u8f03\u3002\n\u8aa4\u5dee\u306f\u7d042\u5e74\u3002\n# Prediction \ntestPoint = parsedTrainData.take(1)[0]\nprint testPoint.label\n\ntestPrediction = fitModel.predict(testPoint.features)\nprint testPrediction\n\n2001.0\n2003.04838193\n\n\u6b21\u306b2\u4e57\u5e73\u5747\u5e73\u65b9\u6839\u8aa4\u5dee(RMSE)\u3092\u4f7f\u3063\u305f\u30e2\u30c7\u30eb\u8a55\u4fa1\u3092\u5b9f\u65bd\u3002\n\u3055\u3089\u306b\u3001RMSE\u3092\u8a55\u4fa1\u95a2\u6570\u3068\u3057\u3066\u30b0\u30ea\u30c3\u30c9\u30b5\u30fc\u30c1\u3067\u30cf\u30a4\u30d1\u30fc\u30d1\u30e9\u30e1\u30fc\u30bf\u3092\u63a2\u3057\u3066\u3044\u304d\u307e\u3059\u3002\n# Define a formula to caluculate RMSE(Root Mean Square Error)\ndef squaredError(label, prediction):\n    ##Calculates the the squared error for a single prediction.\n    return (label - prediction)**2\n\ndef calcRMSE(labelsAndPreds):\n    ##Calculates the root mean squared error for an `RDD` of (label, prediction) tuples.\n    return np.sqrt(labelsAndPreds\n                   .map(lambda (label, prediction): squaredError(label, prediction))\n                   .mean())\n\n#Create new RDD with actual label and predicted label \nlabelsAndPreds = parsedValData.map(lambda lp: (lp.label, fitModel.predict(lp.features)))\n\n#Calculation RMSE\nrmseValLR1 = calcRMSE(labelsAndPreds)\nprint rmseValLR1\n\n126.788570325\n\n\n\u30ea\u30c3\u30b8\u56de\u5e30(\u30b0\u30ea\u30c3\u30c9\u30b5\u30fc\u30c1\u7de8\uff09\n\u30c7\u30d5\u30a9\u30eb\u30c8\u5024\u3067\u5b9f\u65bd\u3057\u305fFitting\u3067\u306fRMSE\u306f126\u7a0b\u5ea6\u3002\n\u3067\u3082\u3063\u3066\u3001\u6b21\u306b\u30b0\u30ea\u30c3\u30c9\u30b5\u30fc\u30c1\u3067\u30d0\u30ea\u3063\u3068\u30cf\u30a4\u30d1\u30fc\u30d1\u30e9\u30e1\u30fc\u30bf\u3092\u63a2\u3057\u3066\u307f\u307e\u3059\u3002\n##Grid search\n# Values to use when training the linear regression model\nminiBatchFrac = 1.0  # miniBatchFraction\nregType = 'l2'  # regType\nuseIntercept = True  # intercept\n\n# Seed of minmum RMSE\nmin_rmseVal = 10**10\n\n#Fix HyperParameters\nmodelRMSEs = []\n\nfor grid_alpha in [1e-5,1.0,10,100]:\n    for grid_numIters in [50,100,500]:\n        for grid_reg in [1e-5,0.0, 1.0]:\n            model = LinearRegressionWithSGD.train(parsedTrainData,\n                                                  iterations=grid_numIters, \n                                                  step=grid_alpha,\n                                                  regParam=grid_reg)\n\n            labelsAndPreds = parsedValData.map(lambda lp: (lp.label, model.predict(lp.features)))\n            rmseVal = calcRMSE(labelsAndPreds)\n\n\n\n            if rmseVal < min_rmseVal:\n                min_rmseVal = rmseVal\n                best_alpha = grid_alpha\n                best_numIter =grid_numIters\n                best_reg = grid_reg\n\nprint \"best_alpha:{},best_numIter:{}, best_reg:{}, best_rmseVal:{}\".format(best_alpha, best_numIter, best_reg, min_rmseVal)\nbest_alpha:1.0,best_numIter:500, best_reg:1e-05, best_rmseVal:117.120806943\n\n\u3053\u3061\u3089\u306fRMSE\u304c117\u7a0b\u5ea6\u3068\u82e5\u5e72\u4e0b\u304c\u3063\u3066\u3001\u7cbe\u5ea6\u304c\u4e0a\u304c\u3063\u3066\u3044\u308b\u3053\u3068\u304c\u671f\u5f85\u51fa\u6765\u305d\u3046\u3002\n\u3067\u3001\u65e9\u901fFitting\u3057\u3066\u3001\u6700\u521d\u306e\u30e2\u30c7\u30eb\u3068\u540c\u69d8\u306b\u5b9f\u6e2c\u5024\u3068\u4e88\u6e2c\u5024\u306e\u6bd4\u8f03\u3002\n#Fitting with HyperParameters fixed by grid search \nFinal_model = LinearRegressionWithSGD.train(parsedTrainData,\n                                           iterations=best_numIter, \n                                           step=best_alpha, \n                                           regParam =best_reg)\n\n#Labels comparison between Final_model and actual data. \nFinal_testPoint = parsedTrainData.take(1)[0]\nprint Final_testPoint.label\n\nFinal_Prediction = Final_model.predict(Final_testPoint.features)\nprint Final_Prediction\n\n2001.0\n1969.7210425\n\n\u8aa4\u5dee30\u5e74\u8fd1\u304f\u3068\u5927\u5e45\u306b\u7cbe\u5ea6\u304c\u60aa\u304f\u306a\u3063\u3066\u307e\u3059\u306d\u3002\u306a\u3093\u3067\u3084\u308d\u3002\n\u3061\u3087\u3063\u3068\u3059\u3050\u306b\u306f\u539f\u56e0\u308f\u304b\u3089\u306a\u3044\u306e\u3067\u3001\u3084\u308a\u76f4\u3057\u305f\u3089\u66f8\u304d\u76f4\u3057\u307e\u3059\u3002\n\u4f5c\u3063\u305fPyspark\u306e\u74b0\u5883\u3067Map\u95a2\u6570\u306e\u7df4\u7fd2\u30ea\u30c3\u30b8\u56de\u5e30\u3084\u3063\u3066\u307f\u307e\u3057\u305f\u3002\n\n\u5143\u30cd\u30bf\u306fedX\u306e[Scalable Machine Learning](https://www.edx.org/course/scalable-machine-learning-uc-berkeleyx-cs190-1x)\u3068\u3044\u3046\u8b1b\u7fa9\u304b\u3089\u3002\n\n\u30c7\u30fc\u30bf\u306f[MillionSongDataset](http://labrosa.ee.columbia.edu/millionsong)\u304b\u3089\u53d6\u5f97\u3067\u304d\u307e\u3059\u3002\n\n\u3067\u3001\u7d50\u679c\u304b\u3089\u5148\u306b\u66f8\u304d\u307e\u3059\u3068\u3001Default\u5024\u542b\u3081\u3066Gridsearch\u3057\u305f\u306b\u3082\u95a2\u308f\u3089\u305a\u3001\nDefault\u5024\u5b9f\u65bd\u3057\u305f\u56de\u5e30\u306e\u65b9\u304c\u7cbe\u5ea6\u304c\u9ad8\u304f\u306a\u308b\u3068\u3044\u3046\u9f3b\u8840\u304c\u51fa\u305d\u3046\u306a\u7d50\u679c\u306b\u306a\u3063\u3066\u3057\u307e\u3063\u3066\u307e\u3059\u3002\n\n\u307e\u305a\u306f\u3082\u308d\u3082\u308dimport\u3002\n\n```python\n#library import\nfrom pyspark.mllib.regression import LinearRegressionWithSGD\nfrom pyspark.mllib.regression import LabeledPoint\nfrom test_helper import Test\nimport numpy as np\n\n#data load\nrawData = sc.textFile('millionsong.txt')\n```\n\n#### \u30ea\u30c3\u30b8\u56de\u5e30(\u30c7\u30d5\u30a9\u30eb\u30c8\uff09\n\u4f7f\u3063\u305f\u306e\u306f[LinearRegressionWithSGD](https://spark.apache.org/docs/latest/api/python/pyspark.mllib.html#pyspark.mllib.regression.LinearRegressionWithSGD)\u3002\n\n```python\nsamplePoints = rawData.take(2)\n\n#Create LabeledPoint\ndef parsePoint(line):\n\n    tokens = line.split(',')\n    label = tokens[0]\n    features = tokens[1:]\n    return LabeledPoint(label, features)\n\nparsedData = rawData.map(parsePoint)\nprint parsedData.take(3)\n\n[LabeledPoint(2001.0, [0.884123733793,0.610454259079,0.600498416968,0.474669212493,0.247232680947,0.357306088914,0.344136412234,0.339641227335,0.600858840135,0.425704689024,0.60491501652,0.419193351817]), LabeledPoint(2001.0, [0.854411946129,0.604124786151,0.593634078776,0.495885413963,0.266307830936,0.261472105188,0.506387076327,0.464453565511,0.665798573683,0.542968988766,0.58044428577,0.445219373624]), LabeledPoint(2001.0, [0.908982970575,0.632063159227,0.557428975183,0.498263761394,0.276396052336,0.312809861625,0.448530069406,0.448674249968,0.649791323916,0.489868662682,0.591908113534,0.4500023818])]\n```\n\n\u6b21\u306b\u30c7\u30fc\u30bf\u3092Traning\u3001Validation,Test\u306b\u5206\u5272\u3002\n\n```python\n#Devide rawData into Traning, Validation and Test\nweights = [.8, .1, .1]\nseed = 50\nparsedTrainData, parsedValData, parsedTestData = parsedData.randomSplit(weights, seed)\n```\n\n\n```python\n# Fit the model with default values\nfitModel = LinearRegressionWithSGD.train(parsedTrainData)\nprint  fitModel\n\n(weights=[348.391703677,312.158507888,303.514705245,268.768326368,260.265535915,321.082923267,345.636059404,369.96940298,414.587178279,328.611497772,389.972179858,348.42792115], intercept=0.0)\n```\n\n\u3053\u306e\u30e2\u30c7\u30eb\u3092\u5143\u306b\u3001\u5b9f\u6e2c\u5024\u3068\u4e88\u6e2c\u5024\u306e\u6bd4\u8f03\u3002\n\u8aa4\u5dee\u306f\u7d042\u5e74\u3002\n\n```python\n# Prediction \ntestPoint = parsedTrainData.take(1)[0]\nprint testPoint.label\n\ntestPrediction = fitModel.predict(testPoint.features)\nprint testPrediction\n\n2001.0\n2003.04838193\n```\n\n\n\n\u6b21\u306b2\u4e57\u5e73\u5747\u5e73\u65b9\u6839\u8aa4\u5dee(RMSE)\u3092\u4f7f\u3063\u305f\u30e2\u30c7\u30eb\u8a55\u4fa1\u3092\u5b9f\u65bd\u3002\n\u3055\u3089\u306b\u3001RMSE\u3092\u8a55\u4fa1\u95a2\u6570\u3068\u3057\u3066\u30b0\u30ea\u30c3\u30c9\u30b5\u30fc\u30c1\u3067\u30cf\u30a4\u30d1\u30fc\u30d1\u30e9\u30e1\u30fc\u30bf\u3092\u63a2\u3057\u3066\u3044\u304d\u307e\u3059\u3002\n\n```python\n# Define a formula to caluculate RMSE(Root Mean Square Error)\ndef squaredError(label, prediction):\n    ##Calculates the the squared error for a single prediction.\n    return (label - prediction)**2\n\ndef calcRMSE(labelsAndPreds):\n    ##Calculates the root mean squared error for an `RDD` of (label, prediction) tuples.\n    return np.sqrt(labelsAndPreds\n                   .map(lambda (label, prediction): squaredError(label, prediction))\n                   .mean())\n\n#Create new RDD with actual label and predicted label \nlabelsAndPreds = parsedValData.map(lambda lp: (lp.label, fitModel.predict(lp.features)))\n\n#Calculation RMSE\nrmseValLR1 = calcRMSE(labelsAndPreds)\nprint rmseValLR1\n\n126.788570325\n```\n\n\n#### \u30ea\u30c3\u30b8\u56de\u5e30(\u30b0\u30ea\u30c3\u30c9\u30b5\u30fc\u30c1\u7de8\uff09\n\u30c7\u30d5\u30a9\u30eb\u30c8\u5024\u3067\u5b9f\u65bd\u3057\u305fFitting\u3067\u306fRMSE\u306f126\u7a0b\u5ea6\u3002\n\u3067\u3082\u3063\u3066\u3001\u6b21\u306b\u30b0\u30ea\u30c3\u30c9\u30b5\u30fc\u30c1\u3067\u30d0\u30ea\u3063\u3068\u30cf\u30a4\u30d1\u30fc\u30d1\u30e9\u30e1\u30fc\u30bf\u3092\u63a2\u3057\u3066\u307f\u307e\u3059\u3002\n\n```python\n##Grid search\n# Values to use when training the linear regression model\nminiBatchFrac = 1.0  # miniBatchFraction\nregType = 'l2'  # regType\nuseIntercept = True  # intercept\n\n# Seed of minmum RMSE\nmin_rmseVal = 10**10\n\n#Fix HyperParameters\nmodelRMSEs = []\n\nfor grid_alpha in [1e-5,1.0,10,100]:\n    for grid_numIters in [50,100,500]:\n        for grid_reg in [1e-5,0.0, 1.0]:\n            model = LinearRegressionWithSGD.train(parsedTrainData,\n                                                  iterations=grid_numIters, \n                                                  step=grid_alpha,\n                                                  regParam=grid_reg)\n            \n            labelsAndPreds = parsedValData.map(lambda lp: (lp.label, model.predict(lp.features)))\n            rmseVal = calcRMSE(labelsAndPreds)\n            \n            \n            \n            if rmseVal < min_rmseVal:\n                min_rmseVal = rmseVal\n                best_alpha = grid_alpha\n                best_numIter =grid_numIters\n                best_reg = grid_reg\n            \nprint \"best_alpha:{},best_numIter:{}, best_reg:{}, best_rmseVal:{}\".format(best_alpha, best_numIter, best_reg, min_rmseVal)\nbest_alpha:1.0,best_numIter:500, best_reg:1e-05, best_rmseVal:117.120806943\n```\n\u3053\u3061\u3089\u306fRMSE\u304c117\u7a0b\u5ea6\u3068\u82e5\u5e72\u4e0b\u304c\u3063\u3066\u3001\u7cbe\u5ea6\u304c\u4e0a\u304c\u3063\u3066\u3044\u308b\u3053\u3068\u304c\u671f\u5f85\u51fa\u6765\u305d\u3046\u3002\n\u3067\u3001\u65e9\u901fFitting\u3057\u3066\u3001\u6700\u521d\u306e\u30e2\u30c7\u30eb\u3068\u540c\u69d8\u306b\u5b9f\u6e2c\u5024\u3068\u4e88\u6e2c\u5024\u306e\u6bd4\u8f03\u3002\n\n```python\n#Fitting with HyperParameters fixed by grid search \nFinal_model = LinearRegressionWithSGD.train(parsedTrainData,\n                                           iterations=best_numIter, \n                                           step=best_alpha, \n                                           regParam =best_reg)\n\n#Labels comparison between Final_model and actual data. \nFinal_testPoint = parsedTrainData.take(1)[0]\nprint Final_testPoint.label\n\nFinal_Prediction = Final_model.predict(Final_testPoint.features)\nprint Final_Prediction\n\n2001.0\n1969.7210425\n```\n\n\u8aa4\u5dee30\u5e74\u8fd1\u304f\u3068\u5927\u5e45\u306b\u7cbe\u5ea6\u304c\u60aa\u304f\u306a\u3063\u3066\u307e\u3059\u306d\u3002\u306a\u3093\u3067\u3084\u308d\u3002\n\u3061\u3087\u3063\u3068\u3059\u3050\u306b\u306f\u539f\u56e0\u308f\u304b\u3089\u306a\u3044\u306e\u3067\u3001\u3084\u308a\u76f4\u3057\u305f\u3089\u66f8\u304d\u76f4\u3057\u307e\u3059\u3002\n", "tags": ["\u6a5f\u68b0\u5b66\u7fd2", "Spark", "Pyspark", "Python"]}