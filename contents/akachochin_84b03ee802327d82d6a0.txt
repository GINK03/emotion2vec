{"context": " More than 1 year has passed since last update.\n\n\u53c2\u8003\u30c9\u30ad\u30e5\u30e1\u30f3\u30c8\n\n\u524d\u56de\u30c9\u30ad\u30e5\u30e1\u30f3\u30c8\n\n\nASADA\u6c0f\u306e\u516c\u958b\u8a18\u4e8b\n\n\u3053\u306e\u8a18\u4e8b\u304b\u3089\u5f15\u7528\u3057\u305f\u3068\u304d\u306f\u300cChapterXX\u300d\u3068\u3059\u308b\u3002\u4f8b\u3048\u3070\u7b2c15\u56de\u306e\u8a18\u4e8b\u306a\u3089(Chapter15)\u3068\u306a\u308b\u3002\n\nIntel \u00ae Virtualization Technology for Directed I/O Architecture Specification\n\n\u3053\u306e\u30c9\u30ad\u30e5\u30e1\u30f3\u30c8\u304b\u3089\u5f15\u7528\u3057\u305f\u3068\u304d\u306f(\u4ed5\u69d8\u66f8:XXX)\u3068\u3059\u308b\u3002\n\u524d\u56de\u306e\u7d9a\u304d\u304b\u3089\u3067\u3059\u3002\u524d\u56de\u306fvtd_create_mapping()\u3092\u629c\u3051\u305f\u3068\u3053\u308d\u307e\u3067\u66f8\u3044\u3066\u307f\u307e\u3057\u305f\u3002\n\u4eca\u56de\u306fvtd_iommu_enable()\u306e\u524d\u534a\u307e\u3067\u3092\u66f8\u304d\u305f\u3044\u3068\u601d\u3044\u307e\u3059\u3002\n\n\u30db\u30b9\u30c8\u30c9\u30e1\u30a4\u30f3\u3068PCI\u30c7\u30d0\u30a4\u30b9\u306e\u7d10\u4ed8\u3051\n\nPCI\u30c7\u30d0\u30a4\u30b9\u306e\u7dcf\u5f53\u308a\u8abf\u67fb\n\u307e\u305a\u3001\u30b7\u30b9\u30c6\u30e0\u4e0a\u306b\u3059\u3067\u306b\u5b58\u5728\u3059\u308bPCI\u30c7\u30d0\u30a4\u30b9\u3092\u3059\u3079\u3066\u7dcf\u5f53\u308a\u3067\u8abf\u3079\u3066\u307f\u308b\u3002\n    for (bus = 0; bus <= PCI_BUSMAX; bus++) {\n        for (slot = 0; slot <= PCI_SLOTMAX; slot++) {\n            for (func = 0; func <= PCI_FUNCMAX; func++) {\n\n\u30eb\u30fc\u30d7\u5185\u3067bus/slot/func\u306b\u5bfe\u5fdc\u3059\u308b\u30c7\u30d0\u30a4\u30b9\u304c\u3044\u306a\u3044\u5834\u5408\u306f\u6b21\u3092\u8a66\u3059\u3002\n                dev = pci_find_dbsf(0, bus, slot, func);\n                if (dev == NULL)\n                    continue;\n\n\u6b21\u306b\u30d1\u30b9\u30b9\u30eb\u30fc\u30c7\u30d0\u30a4\u30b9\u306f\u5225\u9014\u4eee\u60f3\u30de\u30b7\u30f3\u304c\u7acb\u3061\u4e0a\u304c\u3063\u305f\u6642\u306b\u521d\u671f\u5316\u3059\u308b(\u672c\u5f53\u304b\uff1f\u8981\u78ba\u8a8d)\u305f\u3081\u3001\u3053\u3053\u3067\u306f\u4f55\u3082\u3057\u306a\u3044\u3002\n                /* skip passthrough devices */\n                name = device_get_name(dev);\n                if (name != NULL && strcmp(name, \"ppt\") == 0)\n                    continue;\n\n\u305d\u3057\u3066\u3001\u305d\u308c\u4ee5\u5916\u306e\u30c7\u30d0\u30a4\u30b9\u306f\u30db\u30b9\u30c8\u304c\u7ba1\u7406\u3059\u308b\u305f\u3081\u3001\u30db\u30b9\u30c8\u30c9\u30e1\u30a4\u30f3\u306e\u6301\u3064\u30da\u30fc\u30b8\u30c6\u30fc\u30d6\u30eb\u3068\u30c7\u30d0\u30a4\u30b9\u306eContext Table\u3068\u306e\u95a2\u4fc2\u3065\u3051\u3092\u884c\u3046\u3002\n\u305d\u308c\u4ee5\u5916\u306e\u30c7\u30d0\u30a4\u30b9\u306f\u30d1\u30b9\u30b9\u30eb\u30fc\u3067\u306a\u3044\u305f\u3081\u3001VM Exit\u3055\u305b\u3066\u30db\u30b9\u30c8\u304c\u5236\u5fa1\u3092\u5b9f\u65bd\u3059\u308b\u306e\u3060\u308d\u3046\u3002(\u672c\u5f53\u304b\u3001\u8981\u78ba\u8a8d\uff1f)\n\u3088\u3063\u3066\u3001IOMMU\u306b\u5bfe\u3057\u3066\u30db\u30b9\u30c8\u306e\u7269\u7406\u30a2\u30c9\u30ec\u30b9\u7a7a\u9593(\u30db\u30b9\u30c8\u30c9\u30e1\u30a4\u30f3)\u3068\u8a72\u5f53\u30c7\u30d0\u30a4\u30b9\u3092\u7d10\u4ed8\u3051\u3059\u308b\u5fc5\u8981\u304c\u3042\u308b\u3068\u601d\u308f\u308c\u308b\u3002\n                /* everything else belongs to the host domain */\n                iommu_add_device(host_domain,\n                    pci_get_rid(dev));\n            }\n\n\nContext Table\u306e\u30a8\u30f3\u30c8\u30ea\niommu_add_device()\u7d4c\u7531\u3067\u3001vtd_add_device()\u304c\u547c\u3070\u308c\u308b\u3002\nvtd_add_device()\u3067\u306f\u3001\u4ee5\u4e0b\u306e\u3088\u3046\u306b\u3057\u3066Context Table\u306e\u30a8\u30f3\u30c8\u30ea\u3092\u521d\u671f\u5316\u3059\u308b\u3002\n\u5f53\u7136\u306a\u304c\u3089\u3001\u30a8\u30f3\u30c8\u30ea\u3092\u6709\u52b9\u306b\u3059\u308b\u524d\u306b\u5fc5\u8981\u306a\u8a2d\u5b9a\u306f\u3059\u3079\u3066\u6e08\u307e\u305b\u308b\u3053\u3068\u306b\u6ce8\u610f\u3059\u308b\u3002\nContext Table\u306e\u30a8\u30f3\u30c8\u30ea\u306f\u4ed5\u69d8\u66f89.3\u300cContext Entry\u300d\u3092\u53c2\u7167\u306e\u3053\u3068\u3002\n    pt_paddr = vtophys(dom->ptp);\n\n(\u7701\u7565)\n\n    /*\n     * Order is important. The 'present' bit is set only after all fields\n     * of the context pointer are initialized.\n     */\n    ctxp[idx + 1] = dom->addrwidth | (dom->id << 8);\n\n    if (VTD_ECAP_DI(vtdmap->ext_cap))\n        ctxp[idx] = VTD_CTX_TT_ALL;\n    else\n        ctxp[idx] = 0;\n\n    ctxp[idx] |= pt_paddr | VTD_CTX_PRESENT;\n\n\nIOMMU_ENABLE\n\u6700\u5f8c\u306bIOMMU_ENABLE()\u7d4c\u7531\u3067vtd_enable()\u304c\u547c\u3070\u308c\u308b\u3002\n\u3053\u3053\u3067\u3001\u4ee5\u524d\u66f8\u304d\u5fd8\u308c\u3066\u3044\u305f\u3053\u3068\u304c\u3042\u308b\u3002\n\nvtdmaps\n\u304b\u306a\u308a\u524d\u306b\u521d\u671f\u5316\u3057\u305fvtdmaps\u306b\u306f\u3001\u57fa\u672c\u7684\u306b\u306fACPI\u7d4c\u7531\u3067\u5f97\u3089\u308c\u305fRemapping H/W\u306e\u30ec\u30b8\u30b9\u30bf\u7a7a\u9593\u306e\u7269\u7406\u30a2\u30c9\u30ec\u30b9\u304c\u683c\u7d0d\u3055\u308c\u3066\u3044\u308b\u3002\n\u4ee5\u524d\u898b\u305fvtd_init\u3092\u3082\u3046\u4e00\u5ea6\u898b\u3066\u601d\u3044\u51fa\u3057\u3066\u307f\u3088\u3046\u3002\nstatic int\nvtd_init(void)\n{\n(\u7565)\n    while (remaining > sizeof(ACPI_DMAR_HEADER)) {\n        hdr = (ACPI_DMAR_HEADER *)(end - remaining);\n        if (hdr->Length > remaining)\n            break;\n        /*\n         * From Intel VT-d arch spec, version 1.3:\n         * BIOS implementations must report mapping structures\n         * in numerical order, i.e. All remapping structures of\n         * type 0 (DRHD) enumerated before remapping structures of\n         * type 1 (RMRR) and so forth.\n         */\n        if (hdr->Type != ACPI_DMAR_TYPE_HARDWARE_UNIT)\n            break;\n\n        drhd = (ACPI_DMAR_HARDWARE_UNIT *)hdr;\n        vtdmaps[units++] = (struct vtdmap *)PHYS_TO_DMAP(drhd->Address);\n        if (units >= DRHD_MAX_UNITS)\n            break;\n        remaining -= hdr->Length;\n    }\n\nACPI\u7d4c\u7531\u3067\u3068\u3063\u3066\u304d\u305fDRHD\u69cb\u9020\u4f53\u306e\u4e2d\u306b\u3042\u308b\u30ec\u30b8\u30b9\u30bf\u30d9\u30fc\u30b9\u30a2\u30c9\u30ec\u30b9(Register Base Address,\u8a73\u7d30\u306f\u4ed5\u69d8\u66f88.3\u300cDMA Remapping Hardware Unit Definition Structure\u300d\u3092\u53c2\u7167\u306e\u3053\u3068)\u3092vtdmaps\u306b\u8a2d\u5b9a\u3057\u3066\u3044\u308b\u3053\u3068\u3092\u601d\u3044\u51fa\u305d\u3046\u3002\n\u5b9f\u306f\u3001\u4ed5\u69d8\u66f88.2\u300cRemapping Structure Types\u300d\u306b\u3088\u308b\u3068\u3001APCI\u7d4c\u7531\u3067\u53d6\u5f97\u3067\u304d\u308b\u300cvtdmaps\u300d\u306b\u306f\u4ee5\u4e0b\u306e\u3088\u3046\u306a\u3082\u306e\u304c\u3042\u308b\u3002\n\n\n\nvtdmaps\u306eindex\n\u8a73\u7d30\n\n\n\n\n0\nDMA Remapping Hardware Unit Definition (DRHD) Structure\n\n\n1\nReserved Memory Region Reporting (RMRR) Structure\n\n\n2\nRoot Port ATS Capability Reporting (ATSR) Structure\n\n\n3\nRemapping Hardware Static Affinity (RHSA) Structure\n\n\n4\nACPI Name-space Device Declaration (ANDD) Structure\n\n\n>4\nReserved for future use.\n\n\n\n\u4eca\u56de\u306e\u5236\u5fa1\u3067\u5bfe\u8c61\u3068\u306a\u3063\u3066\u3044\u308b\u306e\u306f\u3001\u300cDRHD\u300d\u3060\u3051\u3067\u3042\u308b\u3002\n\u305f\u3060\u3001\u305b\u3063\u304b\u304f\u306e\u6a5f\u4f1a\u306a\u306e\u3067\u3001\u4ed6\u306e\u30c7\u30d0\u30a4\u30b9\u306b\u3064\u3044\u3066\u3082\u8efd\u304f\u4ed5\u69d8\u66f8\u3092\u773a\u3081\u308b\u3002\n\nRMRR\n\u4ed5\u69d8\u66f83.14\u300cHandling Requests to Reserved System Memory\u300d\u306b\u3088\u308b\u3068\u300c\u666e\u901aBIOS\u306b\u3088\u3063\u3066\u30d6\u30fc\u30c8\u6642\u306b\u4e88\u7d04\u9818\u57df\u304c\u78ba\u4fdd\u3055\u308c\u3001\u305d\u3057\u3066OS\u306b\u5bfe\u3057\u3066\u305d\u306e\u9818\u57df\u304c\u30b7\u30b9\u30c6\u30e0\u30e1\u30e2\u30ea\u30de\u30c3\u30d7\u5185\u306e\u4e88\u7d04\u9818\u57df\u3067\u3042\u308b\u65e8\u901a\u77e5\u3055\u308c\u308b\u300d\u3068\u3042\u308b\u3002\u3053\u306e\u30e1\u30e2\u30ea\u9818\u57df\u306b\u95a2\u3059\u308b\u901a\u77e5\u3092\u3059\u308b\u305f\u3081\u306e\u9818\u57df\u3067\u3042\u308b\u3068\u601d\u308f\u308c\u308b\u3002\n\nATSR\n\u4ed5\u69d8\u66f8\u300c8.5 Root Port ATS Capability Reporting Structure\u300d\u306b\u3088\u308b\u3068\u3001Device-TLB\u3092\u30b5\u30dd\u30fc\u30c8\u3059\u308b\u30d7\u30e9\u30c3\u30c8\u30d5\u30a9\u30fc\u30e0\u306e\u307f\u3067\u4f7f\u308f\u308c\u3001ATS\u30c8\u30e9\u30f3\u30b6\u30af\u30b7\u30e7\u30f3(Address Transaction Service)\u3092\u30b5\u30dd\u30fc\u30c8\u3059\u308bPCIe\u306eRoot\u30dd\u30fc\u30c8\u3092\u8b58\u5225\u3059\u308b\u305f\u3081\u306b\u4f7f\u308f\u308c\u308b\u3089\u3057\u3044\u3002\n\nRHSA\n8.6 Remapping Hardware Status Affinity (RHSA) structure\nNUMA\u30a2\u30fc\u30ad\u30c6\u30af\u30c1\u30e3\u3067\u6709\u52b9\u306a\u3082\u306e\u3067\u3001Remapping Hardware Unit\u3067\u6271\u3046\u7bc4\u7587\u304cnode\u3092\u307e\u305f\u3050\u5834\u5408\u306b\u4f7f\u3046\u3082\u306e\u3089\u3057\u3044\u3002\n\nANDD\n\u8a73\u7d30\u306f\u4e0d\u660e\u3060\u304c\u3001\u3053\u306e\u30a8\u30f3\u30c8\u30ea\u306f\u300c\u30d7\u30e9\u30c3\u30c8\u30d5\u30a9\u30fc\u30e0\u5185\u3067DMA\u3092\u767a\u884c\u3059\u308b\u3053\u3068\u306e\u3067\u304d\u308b\u30c7\u30d0\u30a4\u30b9\u306b\u95a2\u3059\u308b\u60c5\u5831(ACPI name-space enumerated device capable of issuing DMA requests in the platform.)\u304c\u53d6\u5f97\u3067\u304d\u308b\u3002\n\u7b46\u8005\u306fACPI\u306b\u660e\u308b\u304f\u306a\u3044\u304c\u3001\u3053\u306e\u3042\u305f\u308a\u306e\u60c5\u5831\u306f\u95a2\u4fc2\u3059\u308b\u306e\u3060\u308d\u3046\u304b\u3002\n\nDRHD\u306e\u30ec\u30b8\u30b9\u30bf\u30de\u30c3\u30d7\nDRHD\u306e\u30ec\u30b8\u30b9\u30bf\u30de\u30c3\u30d7\u306f\u4ed5\u69d8\u66f810.4\u300cRegister Descriptions\u300d\u306b\u66f8\u304b\u308c\u3066\u3044\u308b\u3002\n    for (i = 0; i < drhd_num; i++) {\n        vtdmap = vtdmaps[i];\n        vtd_wbflush(vtdmap);\n\n...\u3068\u4eca\u56de\u306f\u3053\u3053\u307e\u3067\u3002\u6b21\u56de\u306f\u5b9f\u969b\u306e\u30ec\u30b8\u30b9\u30bf\u5236\u5fa1\u3092\u898b\u3066\u3001IOMMU\u3092enable\u306b\u3059\u308b\u3068\u3053\u308d\u3092\u898b\u305f\u3044\u3068\u601d\u3044\u307e\u3059\u3002\n(\u4eca\u56deIOMMU\u3092enable\u3059\u308b\u3068\u3053\u308d\u307e\u3067\u66f8\u304d\u305f\u304b\u3063\u305f\u306e\u3060\u304c\u3001\u7d50\u69cb\u6587\u7ae0\u91cf\u304c\u81a8\u308c\u3066\u3057\u307e\u3046\u3053\u3068\u304c\u308f\u304b\u3063\u305f\u306e\u3067\u3001\u3053\u3053\u3067\u4e00\u65e6\u5207\u308a\u307e\u3059\u3002)\n## \u53c2\u8003\u30c9\u30ad\u30e5\u30e1\u30f3\u30c8\n####[\u524d\u56de\u30c9\u30ad\u30e5\u30e1\u30f3\u30c8](http://qiita.com/akachochin/items/7b43e57aa9d13761e291)\n####[ASADA\u6c0f\u306e\u516c\u958b\u8a18\u4e8b](http://syuu1228.github.io/howto_implement_hypervisor/)\n\u3053\u306e\u8a18\u4e8b\u304b\u3089\u5f15\u7528\u3057\u305f\u3068\u304d\u306f\u300cChapterXX\u300d\u3068\u3059\u308b\u3002\u4f8b\u3048\u3070\u7b2c15\u56de\u306e\u8a18\u4e8b\u306a\u3089(Chapter15)\u3068\u306a\u308b\u3002\n\n####[Intel \u00ae Virtualization Technology for Directed I/O Architecture Specification](http://www.intel.co.jp/content/www/jp/ja/intelligent-systems/intel-technology/vt-directed-io-spec.html) \n\u3053\u306e\u30c9\u30ad\u30e5\u30e1\u30f3\u30c8\u304b\u3089\u5f15\u7528\u3057\u305f\u3068\u304d\u306f(\u4ed5\u69d8\u66f8:XXX)\u3068\u3059\u308b\u3002\n\n\u524d\u56de\u306e\u7d9a\u304d\u304b\u3089\u3067\u3059\u3002\u524d\u56de\u306fvtd_create_mapping()\u3092\u629c\u3051\u305f\u3068\u3053\u308d\u307e\u3067\u66f8\u3044\u3066\u307f\u307e\u3057\u305f\u3002\n\u4eca\u56de\u306fvtd_iommu_enable()\u306e\u524d\u534a\u307e\u3067\u3092\u66f8\u304d\u305f\u3044\u3068\u601d\u3044\u307e\u3059\u3002\n\n## \u30db\u30b9\u30c8\u30c9\u30e1\u30a4\u30f3\u3068PCI\u30c7\u30d0\u30a4\u30b9\u306e\u7d10\u4ed8\u3051\n#### PCI\u30c7\u30d0\u30a4\u30b9\u306e\u7dcf\u5f53\u308a\u8abf\u67fb\n\u307e\u305a\u3001\u30b7\u30b9\u30c6\u30e0\u4e0a\u306b\u3059\u3067\u306b\u5b58\u5728\u3059\u308bPCI\u30c7\u30d0\u30a4\u30b9\u3092\u3059\u3079\u3066\u7dcf\u5f53\u308a\u3067\u8abf\u3079\u3066\u307f\u308b\u3002\n\n```c\n\tfor (bus = 0; bus <= PCI_BUSMAX; bus++) {\n\t\tfor (slot = 0; slot <= PCI_SLOTMAX; slot++) {\n\t\t\tfor (func = 0; func <= PCI_FUNCMAX; func++) {\n```\n\n\u30eb\u30fc\u30d7\u5185\u3067bus/slot/func\u306b\u5bfe\u5fdc\u3059\u308b\u30c7\u30d0\u30a4\u30b9\u304c\u3044\u306a\u3044\u5834\u5408\u306f\u6b21\u3092\u8a66\u3059\u3002\n\n```c\n\t\t\t\tdev = pci_find_dbsf(0, bus, slot, func);\n\t\t\t\tif (dev == NULL)\n\t\t\t\t\tcontinue;\n```\n\n\u6b21\u306b\u30d1\u30b9\u30b9\u30eb\u30fc\u30c7\u30d0\u30a4\u30b9\u306f\u5225\u9014\u4eee\u60f3\u30de\u30b7\u30f3\u304c\u7acb\u3061\u4e0a\u304c\u3063\u305f\u6642\u306b\u521d\u671f\u5316\u3059\u308b(\u672c\u5f53\u304b\uff1f\u8981\u78ba\u8a8d)\u305f\u3081\u3001\u3053\u3053\u3067\u306f\u4f55\u3082\u3057\u306a\u3044\u3002\n\n```c\n\t\t\t\t/* skip passthrough devices */\n\t\t\t\tname = device_get_name(dev);\n\t\t\t\tif (name != NULL && strcmp(name, \"ppt\") == 0)\n\t\t\t\t\tcontinue;\n```\n\n\u305d\u3057\u3066\u3001\u305d\u308c\u4ee5\u5916\u306e\u30c7\u30d0\u30a4\u30b9\u306f\u30db\u30b9\u30c8\u304c\u7ba1\u7406\u3059\u308b\u305f\u3081\u3001\u30db\u30b9\u30c8\u30c9\u30e1\u30a4\u30f3\u306e\u6301\u3064\u30da\u30fc\u30b8\u30c6\u30fc\u30d6\u30eb\u3068\u30c7\u30d0\u30a4\u30b9\u306eContext Table\u3068\u306e\u95a2\u4fc2\u3065\u3051\u3092\u884c\u3046\u3002\n\u305d\u308c\u4ee5\u5916\u306e\u30c7\u30d0\u30a4\u30b9\u306f\u30d1\u30b9\u30b9\u30eb\u30fc\u3067\u306a\u3044\u305f\u3081\u3001VM Exit\u3055\u305b\u3066\u30db\u30b9\u30c8\u304c\u5236\u5fa1\u3092\u5b9f\u65bd\u3059\u308b\u306e\u3060\u308d\u3046\u3002(\u672c\u5f53\u304b\u3001\u8981\u78ba\u8a8d\uff1f)\n\u3088\u3063\u3066\u3001IOMMU\u306b\u5bfe\u3057\u3066\u30db\u30b9\u30c8\u306e\u7269\u7406\u30a2\u30c9\u30ec\u30b9\u7a7a\u9593(\u30db\u30b9\u30c8\u30c9\u30e1\u30a4\u30f3)\u3068\u8a72\u5f53\u30c7\u30d0\u30a4\u30b9\u3092\u7d10\u4ed8\u3051\u3059\u308b\u5fc5\u8981\u304c\u3042\u308b\u3068\u601d\u308f\u308c\u308b\u3002\n\n```c\n\t\t\t\t/* everything else belongs to the host domain */\n\t\t\t\tiommu_add_device(host_domain,\n\t\t\t\t    pci_get_rid(dev));\n\t\t\t}\n```\n\n#### Context Table\u306e\u30a8\u30f3\u30c8\u30ea\niommu_add_device()\u7d4c\u7531\u3067\u3001vtd_add_device()\u304c\u547c\u3070\u308c\u308b\u3002\nvtd_add_device()\u3067\u306f\u3001\u4ee5\u4e0b\u306e\u3088\u3046\u306b\u3057\u3066Context Table\u306e\u30a8\u30f3\u30c8\u30ea\u3092\u521d\u671f\u5316\u3059\u308b\u3002\n\u5f53\u7136\u306a\u304c\u3089\u3001\u30a8\u30f3\u30c8\u30ea\u3092\u6709\u52b9\u306b\u3059\u308b\u524d\u306b\u5fc5\u8981\u306a\u8a2d\u5b9a\u306f\u3059\u3079\u3066\u6e08\u307e\u305b\u308b\u3053\u3068\u306b\u6ce8\u610f\u3059\u308b\u3002\nContext Table\u306e\u30a8\u30f3\u30c8\u30ea\u306f\u4ed5\u69d8\u66f89.3\u300cContext Entry\u300d\u3092\u53c2\u7167\u306e\u3053\u3068\u3002\n\n```c\n\tpt_paddr = vtophys(dom->ptp);\n\n(\u7701\u7565)\n\n\t/*\n\t * Order is important. The 'present' bit is set only after all fields\n\t * of the context pointer are initialized.\n\t */\n\tctxp[idx + 1] = dom->addrwidth | (dom->id << 8);\n\n\tif (VTD_ECAP_DI(vtdmap->ext_cap))\n\t\tctxp[idx] = VTD_CTX_TT_ALL;\n\telse\n\t\tctxp[idx] = 0;\n\n\tctxp[idx] |= pt_paddr | VTD_CTX_PRESENT;\n```\n\n## IOMMU_ENABLE\n\u6700\u5f8c\u306bIOMMU_ENABLE()\u7d4c\u7531\u3067vtd_enable()\u304c\u547c\u3070\u308c\u308b\u3002\n\u3053\u3053\u3067\u3001\u4ee5\u524d\u66f8\u304d\u5fd8\u308c\u3066\u3044\u305f\u3053\u3068\u304c\u3042\u308b\u3002\n\n#### vtdmaps\n\u304b\u306a\u308a\u524d\u306b\u521d\u671f\u5316\u3057\u305fvtdmaps\u306b\u306f\u3001\u57fa\u672c\u7684\u306b\u306fACPI\u7d4c\u7531\u3067\u5f97\u3089\u308c\u305fRemapping H/W\u306e\u30ec\u30b8\u30b9\u30bf\u7a7a\u9593\u306e\u7269\u7406\u30a2\u30c9\u30ec\u30b9\u304c\u683c\u7d0d\u3055\u308c\u3066\u3044\u308b\u3002\n\n\u4ee5\u524d\u898b\u305fvtd_init\u3092\u3082\u3046\u4e00\u5ea6\u898b\u3066\u601d\u3044\u51fa\u3057\u3066\u307f\u3088\u3046\u3002\n\n```c\nstatic int\nvtd_init(void)\n{\n(\u7565)\n\twhile (remaining > sizeof(ACPI_DMAR_HEADER)) {\n\t\thdr = (ACPI_DMAR_HEADER *)(end - remaining);\n\t\tif (hdr->Length > remaining)\n\t\t\tbreak;\n\t\t/*\n\t\t * From Intel VT-d arch spec, version 1.3:\n\t\t * BIOS implementations must report mapping structures\n\t\t * in numerical order, i.e. All remapping structures of\n\t\t * type 0 (DRHD) enumerated before remapping structures of\n\t\t * type 1 (RMRR) and so forth.\n\t\t */\n\t\tif (hdr->Type != ACPI_DMAR_TYPE_HARDWARE_UNIT)\n\t\t\tbreak;\n\n\t\tdrhd = (ACPI_DMAR_HARDWARE_UNIT *)hdr;\n\t\tvtdmaps[units++] = (struct vtdmap *)PHYS_TO_DMAP(drhd->Address);\n\t\tif (units >= DRHD_MAX_UNITS)\n\t\t\tbreak;\n\t\tremaining -= hdr->Length;\n\t}\n```\n\nACPI\u7d4c\u7531\u3067\u3068\u3063\u3066\u304d\u305fDRHD\u69cb\u9020\u4f53\u306e\u4e2d\u306b\u3042\u308b\u30ec\u30b8\u30b9\u30bf\u30d9\u30fc\u30b9\u30a2\u30c9\u30ec\u30b9(Register Base Address,\u8a73\u7d30\u306f\u4ed5\u69d8\u66f88.3\u300cDMA Remapping Hardware Unit Definition Structure\u300d\u3092\u53c2\u7167\u306e\u3053\u3068)\u3092vtdmaps\u306b\u8a2d\u5b9a\u3057\u3066\u3044\u308b\u3053\u3068\u3092\u601d\u3044\u51fa\u305d\u3046\u3002\n\n\u5b9f\u306f\u3001\u4ed5\u69d8\u66f88.2\u300cRemapping Structure Types\u300d\u306b\u3088\u308b\u3068\u3001APCI\u7d4c\u7531\u3067\u53d6\u5f97\u3067\u304d\u308b\u300cvtdmaps\u300d\u306b\u306f\u4ee5\u4e0b\u306e\u3088\u3046\u306a\u3082\u306e\u304c\u3042\u308b\u3002\n\n|vtdmaps\u306eindex|\u8a73\u7d30|\n|-------------:|---:|\n|0|DMA Remapping Hardware Unit Definition (DRHD) Structure|\n|1|Reserved Memory Region Reporting (RMRR) Structure|\n|2|Root Port ATS Capability Reporting (ATSR) Structure|\n|3|Remapping Hardware Static Affinity (RHSA) Structure|\n|4|ACPI Name-space Device Declaration (ANDD) Structure|\n|>4|Reserved for future use. |\n\n\u4eca\u56de\u306e\u5236\u5fa1\u3067\u5bfe\u8c61\u3068\u306a\u3063\u3066\u3044\u308b\u306e\u306f\u3001\u300cDRHD\u300d\u3060\u3051\u3067\u3042\u308b\u3002\n\u305f\u3060\u3001\u305b\u3063\u304b\u304f\u306e\u6a5f\u4f1a\u306a\u306e\u3067\u3001\u4ed6\u306e\u30c7\u30d0\u30a4\u30b9\u306b\u3064\u3044\u3066\u3082\u8efd\u304f\u4ed5\u69d8\u66f8\u3092\u773a\u3081\u308b\u3002\n\n#### RMRR\n\u4ed5\u69d8\u66f83.14\u300cHandling Requests to Reserved System Memory\u300d\u306b\u3088\u308b\u3068\u300c\u666e\u901aBIOS\u306b\u3088\u3063\u3066\u30d6\u30fc\u30c8\u6642\u306b\u4e88\u7d04\u9818\u57df\u304c\u78ba\u4fdd\u3055\u308c\u3001\u305d\u3057\u3066OS\u306b\u5bfe\u3057\u3066\u305d\u306e\u9818\u57df\u304c\u30b7\u30b9\u30c6\u30e0\u30e1\u30e2\u30ea\u30de\u30c3\u30d7\u5185\u306e\u4e88\u7d04\u9818\u57df\u3067\u3042\u308b\u65e8\u901a\u77e5\u3055\u308c\u308b\u300d\u3068\u3042\u308b\u3002\u3053\u306e\u30e1\u30e2\u30ea\u9818\u57df\u306b\u95a2\u3059\u308b\u901a\u77e5\u3092\u3059\u308b\u305f\u3081\u306e\u9818\u57df\u3067\u3042\u308b\u3068\u601d\u308f\u308c\u308b\u3002\n\n#### ATSR\n\u4ed5\u69d8\u66f8\u300c8.5 Root Port ATS Capability Reporting Structure\u300d\u306b\u3088\u308b\u3068\u3001Device-TLB\u3092\u30b5\u30dd\u30fc\u30c8\u3059\u308b\u30d7\u30e9\u30c3\u30c8\u30d5\u30a9\u30fc\u30e0\u306e\u307f\u3067\u4f7f\u308f\u308c\u3001ATS\u30c8\u30e9\u30f3\u30b6\u30af\u30b7\u30e7\u30f3(Address Transaction Service)\u3092\u30b5\u30dd\u30fc\u30c8\u3059\u308bPCIe\u306eRoot\u30dd\u30fc\u30c8\u3092\u8b58\u5225\u3059\u308b\u305f\u3081\u306b\u4f7f\u308f\u308c\u308b\u3089\u3057\u3044\u3002\n\n#### RHSA\n8.6 Remapping Hardware Status Affinity (RHSA) structure\nNUMA\u30a2\u30fc\u30ad\u30c6\u30af\u30c1\u30e3\u3067\u6709\u52b9\u306a\u3082\u306e\u3067\u3001Remapping Hardware Unit\u3067\u6271\u3046\u7bc4\u7587\u304cnode\u3092\u307e\u305f\u3050\u5834\u5408\u306b\u4f7f\u3046\u3082\u306e\u3089\u3057\u3044\u3002\n\n#### ANDD\n\u8a73\u7d30\u306f\u4e0d\u660e\u3060\u304c\u3001\u3053\u306e\u30a8\u30f3\u30c8\u30ea\u306f\u300c\u30d7\u30e9\u30c3\u30c8\u30d5\u30a9\u30fc\u30e0\u5185\u3067DMA\u3092\u767a\u884c\u3059\u308b\u3053\u3068\u306e\u3067\u304d\u308b\u30c7\u30d0\u30a4\u30b9\u306b\u95a2\u3059\u308b\u60c5\u5831(ACPI name-space enumerated device capable of issuing DMA requests in the platform.)\u304c\u53d6\u5f97\u3067\u304d\u308b\u3002\n\u7b46\u8005\u306fACPI\u306b\u660e\u308b\u304f\u306a\u3044\u304c\u3001[\u3053\u306e\u3042\u305f\u308a\u306e\u60c5\u5831](https://www.kernel.org/doc/Documentation/acpi/enumeration.txt)\u306f\u95a2\u4fc2\u3059\u308b\u306e\u3060\u308d\u3046\u304b\u3002\n\n## DRHD\u306e\u30ec\u30b8\u30b9\u30bf\u30de\u30c3\u30d7\nDRHD\u306e\u30ec\u30b8\u30b9\u30bf\u30de\u30c3\u30d7\u306f\u4ed5\u69d8\u66f810.4\u300cRegister Descriptions\u300d\u306b\u66f8\u304b\u308c\u3066\u3044\u308b\u3002\n\n```c\n\tfor (i = 0; i < drhd_num; i++) {\n\t\tvtdmap = vtdmaps[i];\n\t\tvtd_wbflush(vtdmap);\n```\n...\u3068\u4eca\u56de\u306f\u3053\u3053\u307e\u3067\u3002\u6b21\u56de\u306f\u5b9f\u969b\u306e\u30ec\u30b8\u30b9\u30bf\u5236\u5fa1\u3092\u898b\u3066\u3001IOMMU\u3092enable\u306b\u3059\u308b\u3068\u3053\u308d\u3092\u898b\u305f\u3044\u3068\u601d\u3044\u307e\u3059\u3002\n(\u4eca\u56deIOMMU\u3092enable\u3059\u308b\u3068\u3053\u308d\u307e\u3067\u66f8\u304d\u305f\u304b\u3063\u305f\u306e\u3060\u304c\u3001\u7d50\u69cb\u6587\u7ae0\u91cf\u304c\u81a8\u308c\u3066\u3057\u307e\u3046\u3053\u3068\u304c\u308f\u304b\u3063\u305f\u306e\u3067\u3001\u3053\u3053\u3067\u4e00\u65e6\u5207\u308a\u307e\u3059\u3002)\n", "tags": ["BSD", "Virtualization", "CPU", "hypervisor", "BHyVe"]}