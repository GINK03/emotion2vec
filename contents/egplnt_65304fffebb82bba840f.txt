{"tags": ["watsoniotplatform", "node-red", "IoT", "wiotp", "wiotp514"], "context": "\u521d\u3081\u3066Watson IoT Platform\u3092\u4f7f\u3063\u3066\u307f\u3088\u3046\u3001\u3068\u3044\u3046\u304b\u305f\u306e\u305f\u3081\u306e\u30ac\u30a4\u30c9\u3067\u3059\u3002\nWatson IoT Platform\u3092\u4f7f\u3063\u3066\u307f\u308b\u3067IoT\u30a2\u30d7\u30ea\u3092\u6e96\u5099\u3057\u307e\u3057\u305f\u3002\nIoT\u30c0\u30c3\u30b7\u30e5\u30dc\u30fc\u30c9\u3092\u4f5c\u3063\u3066\u307f\u308b\u3067IoT\u30c7\u30fc\u30bf\u3092\u53ef\u8996\u5316\u3059\u308b\u30c0\u30c3\u30b7\u30e5\u30dc\u30fc\u30c9\u3092\u4f5c\u3063\u3066\u3044\u304d\u307e\u3059\u3002\n\nDrag & drop\u3067\u304d\u308b\u30bb\u30f3\u30b5\u30fc\u3092\u7d75\u306b\u8ffd\u52a0\u3057\u3001\u30ea\u30a2\u30eb\u30bf\u30a4\u30e0\u306e\u30bb\u30f3\u30b5\u30fc\u5024\u306b\u5fdc\u3058\u3066\u8272\u3092\u5909\u5316\u3055\u305b\u307e\u3059\n\n\u4e0b\u8a18\u306e\u30d5\u30ed\u30fc\u3092\u30b3\u30d4\u30da\u3057\u307e\u3059\n\n\n\n\n\u30bb\u30f3\u30b5\u30fc\u3092\u8ffd\u52a0\u3057\u30ea\u30a2\u30eb\u30bf\u30a4\u30e0\u306e\u5024\u306b\u5fdc\u3058\u3066\u8272\u3092\u5909\u5316\n[{\"id\":\"76358274.bcd864\",\"type\":\"template\",\"z\":\"b0ed7852.d58f08\",\"name\":\"background picture\",\"field\":\"payload.background.picture\",\"fieldType\":\"msg\",\"format\":\"handlebars\",\"syntax\":\"mustache\",\"template\":\"data:image/gif;base64,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\",\"x\":350,\"y\":1760,\"wires\":[[\"b941211b.290f28\"]]},{\"id\":\"c900afe6.93d18\",\"type\":\"template\",\"z\":\"b0ed7852.d58f08\",\"name\":\"test514.html\u3092\u8fd4\u3059\",\"field\":\"payload\",\"fieldType\":\"msg\",\"format\":\"handlebars\",\"syntax\":\"mustache\",\"template\":\"<!DOCTYPE HTML>\\n<html>\\n\u3000<head>\\n\u3000\u3000<title>\u30bb\u30f3\u30b5\u30fc\u304b\u3089\u306e\u60c5\u5831\u3092\u8868\u793a</title>\\n\u3000\u3000<meta charset=\\\"utf-8\\\" />\\n<script type=\\\"text/javascript\\\" src=\\\"https://www.google.com/jsapi\\\"></script>\\n<script type=\\\"test/javascript\\\" src=\\\"https://www.gstatic.com/charts/loader.js\\\"></script>\\n\\n\\n<style type=\\\"text/css\\\">\\n  {{{payload.css}}}\\n</style>\\n</head>\\n<body>\\n\\n  <div id='basic' align=\\\"center\\\">\\n\\n    <div id='a1' align=\\\"left\\\">\\n      <h2>IoT Sample Dashboard</h2>\\n      IoT\u30c7\u30fc\u30bf\u3092\u30ea\u30a2\u30eb\u30bf\u30a4\u30e0\u3067\u53ef\u8996\u5316\u3057\u307e\u3059\\n    </div>\\n    <div id='b1' align=\\\"left\\\">\\n      b1\\n    </div>\\n    <div id='c1'>\\n      c1\\n    </div>\\n    <div id='c2'>\\n      c2\\n    </div>\\n    <div id='c3'>\\n      <svg id=\\\"svg.svg\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\" width=\\\"723\\\" height=\\\"500\\\" viewBox=\\\"0 0 723 500\\\">\\n      </svg>\\n    </div>\\n    <div id ='c4'>\\n      c4\\n    </div>\\n    <div id ='c5'>\\n      c5\\n    </div>\\n    <div id ='c6'>\\n      c6\\n    </div>\\n\\n    <div id='d1'>\\n      d1\\n    </div>\\n    <div id='d2'>\\n      d2\\n    </div>\\n    <div id='d3'>\\n      d3\\n    </div>\\n\\n    <div id='e1' align=\\\"left\\\">\\n      <h2 style=\\\"margin-left:10px;\\\">\u7167\u5ea6</h2>\\n        <span style=\\\"text-align:left; font-size:18pt; margin-left:100px;\\\" id=\\\"e1data\\\"></span>lux\\n    </div>\\n    <div id='e2'>\\n      e2\\n    </div>\\n    <div id='e3'>\\n      e3\\n    </div>\\n\\n    <div id='f1'>\\n      f1\\n    </div>\\n    <div id='f2'>\\n      f2\\n    </div>\\n    <div id='f3'>\\n      f3\\n    </div>\\n    <div id='h1' >\\n      h1\\n    </div>\\n    <div id='h2'>\\n      h2\\n    </div>\\n    <div id='h3'>\\n      h3\\n    </div>\\n\\n    <div id='j1'>\\n      j1\\n    </div>\\n    <div id='j2'>\\n      j2\\n    </div>\\n    <div id='j3'>\\n      j3\\n    </div>\\n\\n    <div id='k1' >\\n      k1\\n    </div>\\n    <div id='k2'>\\n      k2\\n    </div>\\n    <div id='k3'>\\n      k3\\n    </div>\\n\\n    <div id='m1'>\\n      m1\\n    </div>\\n    <div id='m2'>\\n      m2\\n    </div>\\n    <div id='m3'>\\n      m3\\n    </div>\\n\\n    <div id='v1' align=\\\"left\\\">\\n      <h2 style=\\\"margin-left:10px;\\\">\u30a2\u30e9\u30fc\u30c8</h2>\\n      <span style=\\\"text-align: left;font-size:18pt; margin-left:100px;\\\" id=\\\"alerttext\\\"></span>\\n    </div>\\n\\n    <div id='x1' align=\\\"left\\\">\\n      x1\\n    </div>\\n\\n<div id=\\\"y1\\\" align=\\\"left\\\">\\n  \u53c2\u8003URL\\n  <ul>\\n    <li><a href=\\\"http://qiita.com/egplnt/items/af867711a7191923b2ff\\\">Watson IoT Platform\u3092\u4f7f\u3063\u3066\u307f\u308b</a></li>\\n    <li><a href=\\\"https://internetofthings.ibmcloud.com/#/\\\">Watson IoT Platform</a></li>\\n    <li><a href=\\\"https://developer.ibm.com/recipes/tutorials/use-the-simulated-device-to-experience-the-iot-foundation/\\\">Recipe - Simulator</a></li>\\n  </ul>\\n  \u30de\u30cb\u30e5\u30a2\u30eb\\n  <ul>\\n    <li><a href=\\\"http://ibm.com/iot\\\">IBM IoT</a></li>\\n    <li><a href=\\\"https://docs.internetofthings.ibmcloud.com/ja/\\\">Watson IoT Platform\u8cc7\u6599\u30da\u30fc\u30b8</a></li>\\n    <li><a href=\\\"https://developer.ibm.com/recipes/\\\">Recipe</a></li>\\n  </ul>\\n</div>\\n\\n<div id=\\\"z1\\\">\\n\\tcopyright (c) abc.com All rights reserved.\\n</div>\\n</div>\\n\\n\\n<script>\\n{{{payload.svg}}}\\n{{{payload.draggable}}}\\n\\nvar connection = new WebSocket('wss://\u3053\u306eIoT\u30a2\u30d7\u30ea\u306e\u540d\u524d.mybluemix.net/wss/flow514');\\nvar draw = SVG('svg.svg').size(723, 500);\\nvar circle1 = draw.circle(45).attr({'fill':'green'}).x(650).y(100).draggable();\\n\\nconnection.onopen = function () {\\n  console.log(\\\"websocket connected\\\");\\n};\\n\\nconnection.onerror = function (error) {\\n  console.log('WebSocket Error ' + error);\\n};\\n\\nconnection.onmessage = function (m) {\\n\\tdoIt(m);\\n};\\n\\n// \u30b2\u30fc\u30b8\u3068\u30e9\u30a4\u30f3\u30c1\u30e3\u30fc\u30c8\u3092\u6e96\u5099\\n// \u30e9\u30a4\u30f3\u30c1\u30e3\u30fc\u30c8\u306eAPI\u306f\u3000https://developers.google.com/chart/interactive/docs/reference\\ngoogle.load('visualization', '1', {packages:['gauge', 'corechart']});\\ngoogle.setOnLoadCallback(drawChart);\\n\\nfunction drawChart() {\\n\\td1GaugeData = google.visualization.arrayToDataTable([\\n\\t\\t['Label', 'Value'],\\n\\t\\t['\u7167\u5ea6', 0]\\n\\t]);\\n  d1GaugeOptions = {\\n\\t\\twidth: 500, height: 150,\\n\\t\\tmin: 0, max: 500,\\n\\t\\tyellowFrom:300, yellowTo: 400,\\n    redFrom: 400, redTo: 500,\\n\\t\\tminorTicks: 5\\n\\t};\\n  d1Gauge = new google.visualization.Gauge(document.getElementById('d1'));\\n\\td1Gauge.draw(d1GaugeData, d1GaugeOptions);\\n\\n\\n  f1ChartData = google.visualization.arrayToDataTable(\\n    [[\\\"\u6642\u523b\\\",\\\"\u7167\u5ea6\\\"],['10:00:00',300]] );\\n  f1ChartData.removeRow(0);\\n  f1ChartOptions = {\u3000title: '\u7167\u5ea6',\\n    legend: { position: 'bottom' },\\n    backgroundColor: {stroke:'#c1d8ac' ,strokeWidth:10, fill:'#ffffff'}\\n  };\\n  f1Chart = new google.visualization.LineChart(document.getElementById('f1'));\\n  f1Chart.draw(f1ChartData, f1ChartOptions);\\n\\n};\\n\\n//websocket\u304b\u3089\u306e\u6bce\u79d2\u306e\u30c7\u30fc\u30bf\u3092\u53d7\u4fe1\u3057\u3066\u30b2\u30fc\u30b8\u30fb\u30c1\u30e3\u30fc\u30c8\u3078\u8868\u793a\u3059\u308b\\nfunction doIt(msg){\\n  console.log(\\\"doit:\\\" + msg.data);\\n\\tvar msgs = JSON.parse(msg.data);\\n\\n  // msgs[4]\u306f\u4e8c\u91cd\u914d\u5217\u306a\u306e\u3067\\\"msgs[4][0]\\\"\u3067\u6e29\u5ea6\u306e\u5024\u3092\u53d6\u308a\u51fa\u3057\u3066\u30ea\u30a2\u30eb\u30bf\u30a4\u30e0\u8868\u793a\u3059\u308b\\n  d1GaugeData = google.visualization.arrayToDataTable([\\n    ['Label', 'Value'],\\n    ['\u7167\u5ea6', msgs[4][0]]\\n  ]);\\n  d1Gauge.draw(d1GaugeData, d1GaugeOptions);\\n  console.log(\\\"msgs[4][0] = \\\" + msgs[4][0]);\\n\\n  f1ChartData.addRow( [ msgs[0][0], msgs[4][0] ] );\\n  if ( f1ChartData.getNumberOfRows() > 9) {\\n    f1ChartData.removeRow(0);\\n  }\\n  f1Chart.draw(f1ChartData, f1ChartOptions);\\n\\n  (function(){\\n    var c1t = parseInt(msgs[4]);\\n    if ( c1t > 400) {\\n      circle1.attr({'fill':'red'});\\n    } else if ( c1t > 300 ){\\n      circle1.attr({'fill':\\\"yellow\\\"});\\n    } else {\\n      circle1.attr({'fill':\\\"green\\\"});\\n    }\\n  })();\\n\\n\\t// \u5404\u30bb\u30f3\u30b5\u30fc\u8981\u7d20\u3092\u53d6\u308a\u51fa\u3057\u3066\u3001\u753b\u9762\u3078\u8868\u793a\\n  target = document.getElementById(\\\"e1data\\\"); // \u7167\u5ea6 e1\u306b\u8868\u793a\\n\\ttarget.innerHTML = msgs[4];\\n};\\n</script>\\n\\n</body>\\n</html>\\n\",\"x\":690,\"y\":1820,\"wires\":[[\"748f4cdc.d6f88c\"]]},{\"id\":\"31ef6b3e.25e60c\",\"type\":\"http in\",\"z\":\"b0ed7852.d58f08\",\"name\":\"\",\"url\":\"/test514\",\"method\":\"get\",\"swaggerDoc\":\"\",\"x\":150,\"y\":1760,\"wires\":[[\"76358274.bcd864\"]]},{\"id\":\"748f4cdc.d6f88c\",\"type\":\"http response\",\"z\":\"b0ed7852.d58f08\",\"name\":\"\",\"x\":850,\"y\":1820,\"wires\":[]},{\"id\":\"a3c33f74.38abc8\",\"type\":\"comment\",\"z\":\"b0ed7852.d58f08\",\"name\":\"\u30bb\u30f3\u30b5\u30fc\u3092\u7d75\u306b\u8ffd\u52a0\",\"info\":\"\",\"x\":150,\"y\":1720,\"wires\":[]},{\"id\":\"806e2715.ce426\",\"type\":\"template\",\"z\":\"b0ed7852.d58f08\",\"name\":\"css514\",\"field\":\"payload.css\",\"fieldType\":\"msg\",\"format\":\"handlebars\",\"syntax\":\"mustache\",\"template\":\"#basic {\\n  width: 1200px;\\n  margin: auto;\\n}\\n\\n#a1 {\\n  background-color:  #98d98e;\\n  padding: 20px;\\n  height: 100px;\\n}\\n#b1 {\\n  background-color:  #e4de8a;\\n  padding-left: 20px;\\n  height: 40px;\\n  text-align:left;\\n  font-size: 18pt\\n}\\n#c1 {\\n  float: left;\\n  background-color:  #68be8d;\\n  width: 50px;\\n  height: 500px ;\\n}\\n#c2 {\\n  float: left;\\n  background-color:  #cee4ae;\\n  width: 127px;\\n  height: 500px ;\\n}\\n\\n#c3 {\\n  float: left;\\n  width: 723px;\\n  height: 500px;\\n  background: url({{{payload.background.picture}}});\\n  background-size:auto;\\n}\\n\\n#c4 {\\n  float: right;\\n  background-color: #93b69c;\\n  width: 300px;\\n  height: 80px ;\\n}\\n#c5 {\\n  float: right;\\n  background-color: #b9d08b;\\n  width: 300px;\\n  height: 60px ;\\n}\\n#c6 {\\n  overflow: scroll;\\n  float: right;\\n  background-color: #98d98e;\\n  width:  300px;\\n  height: 360px ;\\n}\\n#d1 {\\n  float: left;\\n  width: 400px;\\n  height: 150px;\\n  background-color:  #c1d8ac;\\n}\\n#d2 {\\n  float: left;\\n  width: 400px;\\n  height: 150px;\\n  background-color:  #b9d08b;\\n}\\n#d3 {\\n  float: left;\\n  width: 400px;\\n  height: 150px;\\n  background-color:  #badcad;\\n}\\n\\n#e1 {\\n  float: left;\\n  width: 400px;\\n  height: 120px;\\n  background-color:  #c1d8ac;\\n}\\n#e2 {\\n  float: left;\\n  width: 400px;\\n  height: 120px;\\n  background-color:  #b9d08b;\\n}\\n#e3 {\\n  float: left;\\n  width: 400px;\\n  height: 120px;\\n  background-color:  #badcad;\\n}\\n\\n#f1 {\\n  float: left;\\n  width: 400px;\\n  height: 200px;\\n  background-color:  #c1d8ac;\\n}\\n#f2 {\\n  float: left;\\n  width: 400px;\\n  height: 200px;\\n  background-color:  #b9d08b;\\n}\\n#f3 {\\n  float: left;\\n  width: 400px;\\n  height: 200px;\\n  background-color:  #badcad;\\n}\\n\\n#g1 {\\n  float: left;\\n  width: 400px;\\n  height: 150px;\\n  background-color:  #c1d8ac;\\n}\\n#g2 {\\n  float: left;\\n  width: 400px;\\n  height: 150px;\\n  background-color:  #b9d08b;\\n}\\n#g3 {\\n  float: left;\\n  width: 400px;\\n  height: 150px;\\n  background-color:  #badcad;\\n}\\n\\n#h1 {\\n  float: left;\\n  width: 400px;\\n  height: 120px;\\n  background-color:  #98d98e;\\n}\\n#h2 {\\n  float: left;\\n  width: 400px;\\n  height: 120px;\\n  background-color:  #c1d8ac;\\n}\\n#h3 {\\n  float: left;\\n  width: 400px;\\n  height: 120px;\\n  background-color:  #93b69c;\\n}\\n\\n#j1 {\\n  float: left;\\n  width: 400px;\\n  height: 200px;\\n  background-color:  #98d98e;\\n}\\n#j2 {\\n  float: left;\\n  width: 400px;\\n  height: 200px;\\n  background-color:  #c1d8ac;\\n}\\n#j3 {\\n  float: left;\\n  width: 400px;\\n  height: 200px;\\n  background-color:  #93b69c;\\n}\\n\\n#k1 {\\n  float: left;\\n  width: 400px;\\n  height: 120px;\\n  background-color:  #c1d8ac;\\n}\\n#k2 {\\n  float: left;\\n  width: 400px;\\n  height: 120px;\\n  background-color:  #b9d08b;\\n}\\n#k3 {\\n  float: left;\\n  width: 400px;\\n  height: 120px;\\n  background-color:  #badcad;\\n}\\n\\n#m1 {\\n  float: left;\\n  width: 400px;\\n  height: 200px;\\n  background-color:  #c1d8ac;\\n}\\n#m2 {\\n  float: left;\\n  width: 400px;\\n  height: 200px;\\n  background-color:  #b9d08b;\\n}\\n#m3 {\\n  float: left;\\n  width: 400px;\\n  height: 200px;\\n  background-color:  #badcad;\\n}\\n\\n#v1 {\\n  clear: both;\\n  height: 100px;\\n  background-color:  #aacf53;\\n}\\n#x1 {\\n  height: 100px;\\n\\tpadding: 20px;\\n  background-color:  #c1d8ac;\\n}\\n#y1 {\\n  background-color: #e4dc8a;\\n\\tpadding: 20px;\\n  height: 250px;\\n}\\n#z1 {\\n  height: 25px;\\n  background-color: #8f8667;\\n  font-size: 18px;\\n  text-align: center;\\n}\\n\",\"x\":520,\"y\":1820,\"wires\":[[\"c900afe6.93d18\"]]},{\"id\":\"b941211b.290f28\",\"type\":\"template\",\"z\":\"b0ed7852.d58f08\",\"name\":\"svg\",\"field\":\"payload.svg\",\"fieldType\":\"msg\",\"format\":\"handlebars\",\"syntax\":\"mustache\",\"template\":\"/*!\\n* svg.js - A lightweight library for manipulating and animating SVG.\\n* @version 2.3.7\\n* https://svgdotjs.github.io/\\n*\\n* @copyright Wout Fierens <wout@mick-wout.com>\\n* @license MIT\\n*\\n* BUILT: Sat Jan 14 2017 07:23:18 GMT+0100 (CET)\\n*/;\\n(function(root, factory) {\\n  if (typeof define === 'function' && define.amd) {\\n    define(function(){\\n      return factory(root, root.document)\\n    })\\n  } else if (typeof exports === 'object') {\\n    module.exports = root.document ? factory(root, root.document) : function(w){ return factory(w, w.document) }\\n  } else {\\n    root.SVG = factory(root, root.document)\\n  }\\n}(typeof window !== \\\"undefined\\\" ? window : this, function(window, document) {\\n\\n// The main wrapping element\\nvar SVG = this.SVG = function(element) {\\n  if (SVG.supported) {\\n    element = new SVG.Doc(element)\\n\\n    if(!SVG.parser.draw)\\n      SVG.prepare()\\n\\n    return element\\n  }\\n}\\n\\n// Default namespaces\\nSVG.ns    = 'http://www.w3.org/2000/svg'\\nSVG.xmlns = 'http://www.w3.org/2000/xmlns/'\\nSVG.xlink = 'http://www.w3.org/1999/xlink'\\nSVG.svgjs = 'http://svgjs.com/svgjs'\\n\\n// Svg support test\\nSVG.supported = (function() {\\n  return !! document.createElementNS &&\\n         !! document.createElementNS(SVG.ns,'svg').createSVGRect\\n})()\\n\\n// Don't bother to continue if SVG is not supported\\nif (!SVG.supported) return false\\n\\n// Element id sequence\\nSVG.did  = 1000\\n\\n// Get next named element id\\nSVG.eid = function(name) {\\n  return 'Svgjs' + capitalize(name) + (SVG.did++)\\n}\\n\\n// Method for element creation\\nSVG.create = function(name) {\\n  // create element\\n  var element = document.createElementNS(this.ns, name)\\n\\n  // apply unique id\\n  element.setAttribute('id', this.eid(name))\\n\\n  return element\\n}\\n\\n// Method for extending objects\\nSVG.extend = function() {\\n  var modules, methods, key, i\\n\\n  // Get list of modules\\n  modules = [].slice.call(arguments)\\n\\n  // Get object with extensions\\n  methods = modules.pop()\\n\\n  for (i = modules.length - 1; i >= 0; i--)\\n    if (modules[i])\\n      for (key in methods)\\n        modules[i].prototype[key] = methods[key]\\n\\n  // Make sure SVG.Set inherits any newly added methods\\n  if (SVG.Set && SVG.Set.inherit)\\n    SVG.Set.inherit()\\n}\\n\\n// Invent new element\\nSVG.invent = function(config) {\\n  // Create element initializer\\n  var initializer = typeof config.create == 'function' ?\\n    config.create :\\n    function() {\\n      this.constructor.call(this, SVG.create(config.create))\\n    }\\n\\n  // Inherit prototype\\n  if (config.inherit)\\n    initializer.prototype = new config.inherit\\n\\n  // Extend with methods\\n  if (config.extend)\\n    SVG.extend(initializer, config.extend)\\n\\n  // Attach construct method to parent\\n  if (config.construct)\\n    SVG.extend(config.parent || SVG.Container, config.construct)\\n\\n  return initializer\\n}\\n\\n// Adopt existing svg elements\\nSVG.adopt = function(node) {\\n  // check for presence of node\\n  if (!node) return null\\n\\n  // make sure a node isn't already adopted\\n  if (node.instance) return node.instance\\n\\n  // initialize variables\\n  var element\\n\\n  // adopt with element-specific settings\\n  if (node.nodeName == 'svg')\\n    element = node.parentNode instanceof SVGElement ? new SVG.Nested : new SVG.Doc\\n  else if (node.nodeName == 'linearGradient')\\n    element = new SVG.Gradient('linear')\\n  else if (node.nodeName == 'radialGradient')\\n    element = new SVG.Gradient('radial')\\n  else if (SVG[capitalize(node.nodeName)])\\n    element = new SVG[capitalize(node.nodeName)]\\n  else\\n    element = new SVG.Element(node)\\n\\n  // ensure references\\n  element.type  = node.nodeName\\n  element.node  = node\\n  node.instance = element\\n\\n  // SVG.Class specific preparations\\n  if (element instanceof SVG.Doc)\\n    element.namespace().defs()\\n\\n  // pull svgjs data from the dom (getAttributeNS doesn't work in html5)\\n  element.setData(JSON.parse(node.getAttribute('svgjs:data')) || {})\\n\\n  return element\\n}\\n\\n// Initialize parsing element\\nSVG.prepare = function() {\\n  // Select document body and create invisible svg element\\n  var body = document.getElementsByTagName('body')[0]\\n    , draw = (body ? new SVG.Doc(body) :  new SVG.Doc(document.documentElement).nested()).size(2, 0)\\n\\n  // Create parser object\\n  SVG.parser = {\\n    body: body || document.documentElement\\n  , draw: draw.style('opacity:0;position:fixed;left:100%;top:100%;overflow:hidden')\\n  , poly: draw.polyline().node\\n  , path: draw.path().node\\n  , native: SVG.create('svg')\\n  }\\n}\\n\\nSVG.parser = {\\n  native: SVG.create('svg')\\n}\\n\\ndocument.addEventListener('DOMContentLoaded', function() {\\n  if(!SVG.parser.draw)\\n    SVG.prepare()\\n}, false)\\n\\n// Storage for regular expressions\\nSVG.regex = {\\n  // Parse unit value\\n  numberAndUnit:    /^([+-]?(\\\\d+(\\\\.\\\\d*)?|\\\\.\\\\d+)(e[+-]?\\\\d+)?)([a-z%]*)$/i\\n\\n  // Parse hex value\\n, hex:              /^#?([a-f\\\\d]{2})([a-f\\\\d]{2})([a-f\\\\d]{2})$/i\\n\\n  // Parse rgb value\\n, rgb:              /rgb\\\\((\\\\d+),(\\\\d+),(\\\\d+)\\\\)/\\n\\n  // Parse reference id\\n, reference:        /#([a-z0-9\\\\-_]+)/i\\n\\n  // Parse matrix wrapper\\n, matrix:           /matrix\\\\(|\\\\)/g\\n\\n  // Elements of a matrix\\n, matrixElements:   /,*\\\\s+|,/\\n\\n  // Whitespace\\n, whitespace:       /\\\\s/g\\n\\n  // Test hex value\\n, isHex:            /^#[a-f0-9]{3,6}$/i\\n\\n  // Test rgb value\\n, isRgb:            /^rgb\\\\(/\\n\\n  // Test css declaration\\n, isCss:            /[^:]+:[^;]+;?/\\n\\n  // Test for blank string\\n, isBlank:          /^(\\\\s+)?$/\\n\\n  // Test for numeric string\\n, isNumber:         /^[+-]?(\\\\d+(\\\\.\\\\d*)?|\\\\.\\\\d+)(e[+-]?\\\\d+)?$/i\\n\\n  // Test for percent value\\n, isPercent:        /^-?[\\\\d\\\\.]+%$/\\n\\n  // Test for image url\\n, isImage:          /\\\\.(jpg|jpeg|png|gif|svg)(\\\\?[^=]+.*)?/i\\n\\n  // The following regex are used to parse the d attribute of a path\\n\\n  // Replaces all negative exponents\\n, negExp:           /e\\\\-/gi\\n\\n  // Replaces all comma\\n, comma:            /,/g\\n\\n  // Replaces all hyphens\\n, hyphen:           /\\\\-/g\\n\\n  // Replaces and tests for all path letters\\n, pathLetters:      /[MLHVCSQTAZ]/gi\\n\\n  // yes we need this one, too\\n, isPathLetter:     /[MLHVCSQTAZ]/i\\n\\n  // split at whitespaces\\n, whitespaces:      /\\\\s+/\\n\\n  // matches X\\n, X:                /X/g\\n}\\n\\nSVG.utils = {\\n  // Map function\\n  map: function(array, block) {\\n    var i\\n      , il = array.length\\n      , result = []\\n\\n    for (i = 0; i < il; i++)\\n      result.push(block(array[i]))\\n\\n    return result\\n  }\\n\\n  // Filter function\\n, filter: function(array, block) {\\n    var i\\n      , il = array.length\\n      , result = []\\n\\n    for (i = 0; i < il; i++)\\n      if (block(array[i]))\\n        result.push(array[i])\\n\\n    return result\\n  }\\n\\n  // Degrees to radians\\n, radians: function(d) {\\n    return d % 360 * Math.PI / 180\\n  }\\n\\n  // Radians to degrees\\n, degrees: function(r) {\\n    return r * 180 / Math.PI % 360\\n  }\\n\\n, filterSVGElements: function(nodes) {\\n    return this.filter( nodes, function(el) { return el instanceof SVGElement })\\n  }\\n\\n}\\n\\nSVG.defaults = {\\n  // Default attribute values\\n  attrs: {\\n    // fill and stroke\\n    'fill-opacity':     1\\n  , 'stroke-opacity':   1\\n  , 'stroke-width':     0\\n  , 'stroke-linejoin':  'miter'\\n  , 'stroke-linecap':   'butt'\\n  , fill:               '#000000'\\n  , stroke:             '#000000'\\n  , opacity:            1\\n    // position\\n  , x:                  0\\n  , y:                  0\\n  , cx:                 0\\n  , cy:                 0\\n    // size\\n  , width:              0\\n  , height:             0\\n    // radius\\n  , r:                  0\\n  , rx:                 0\\n  , ry:                 0\\n    // gradient\\n  , offset:             0\\n  , 'stop-opacity':     1\\n  , 'stop-color':       '#000000'\\n    // text\\n  , 'font-size':        16\\n  , 'font-family':      'Helvetica, Arial, sans-serif'\\n  , 'text-anchor':      'start'\\n  }\\n\\n}\\n// Module for color convertions\\nSVG.Color = function(color) {\\n  var match\\n\\n  // initialize defaults\\n  this.r = 0\\n  this.g = 0\\n  this.b = 0\\n\\n  if(!color) return\\n\\n  // parse color\\n  if (typeof color === 'string') {\\n    if (SVG.regex.isRgb.test(color)) {\\n      // get rgb values\\n      match = SVG.regex.rgb.exec(color.replace(/\\\\s/g,''))\\n\\n      // parse numeric values\\n      this.r = parseInt(match[1])\\n      this.g = parseInt(match[2])\\n      this.b = parseInt(match[3])\\n\\n    } else if (SVG.regex.isHex.test(color)) {\\n      // get hex values\\n      match = SVG.regex.hex.exec(fullHex(color))\\n\\n      // parse numeric values\\n      this.r = parseInt(match[1], 16)\\n      this.g = parseInt(match[2], 16)\\n      this.b = parseInt(match[3], 16)\\n\\n    }\\n\\n  } else if (typeof color === 'object') {\\n    this.r = color.r\\n    this.g = color.g\\n    this.b = color.b\\n\\n  }\\n\\n}\\n\\nSVG.extend(SVG.Color, {\\n  // Default to hex conversion\\n  toString: function() {\\n    return this.toHex()\\n  }\\n  // Build hex value\\n, toHex: function() {\\n    return '#'\\n      + compToHex(this.r)\\n      + compToHex(this.g)\\n      + compToHex(this.b)\\n  }\\n  // Build rgb value\\n, toRgb: function() {\\n    return 'rgb(' + [this.r, this.g, this.b].join() + ')'\\n  }\\n  // Calculate true brightness\\n, brightness: function() {\\n    return (this.r / 255 * 0.30)\\n         + (this.g / 255 * 0.59)\\n         + (this.b / 255 * 0.11)\\n  }\\n  // Make color morphable\\n, morph: function(color) {\\n    this.destination = new SVG.Color(color)\\n\\n    return this\\n  }\\n  // Get morphed color at given position\\n, at: function(pos) {\\n    // make sure a destination is defined\\n    if (!this.destination) return this\\n\\n    // normalise pos\\n    pos = pos < 0 ? 0 : pos > 1 ? 1 : pos\\n\\n    // generate morphed color\\n    return new SVG.Color({\\n      r: ~~(this.r + (this.destination.r - this.r) * pos)\\n    , g: ~~(this.g + (this.destination.g - this.g) * pos)\\n    , b: ~~(this.b + (this.destination.b - this.b) * pos)\\n    })\\n  }\\n\\n})\\n\\n// Testers\\n\\n// Test if given value is a color string\\nSVG.Color.test = function(color) {\\n  color += ''\\n  return SVG.regex.isHex.test(color)\\n      || SVG.regex.isRgb.test(color)\\n}\\n\\n// Test if given value is a rgb object\\nSVG.Color.isRgb = function(color) {\\n  return color && typeof color.r == 'number'\\n               && typeof color.g == 'number'\\n               && typeof color.b == 'number'\\n}\\n\\n// Test if given value is a color\\nSVG.Color.isColor = function(color) {\\n  return SVG.Color.isRgb(color) || SVG.Color.test(color)\\n}\\n// Module for array conversion\\nSVG.Array = function(array, fallback) {\\n  array = (array || []).valueOf()\\n\\n  // if array is empty and fallback is provided, use fallback\\n  if (array.length == 0 && fallback)\\n    array = fallback.valueOf()\\n\\n  // parse array\\n  this.value = this.parse(array)\\n}\\n\\nSVG.extend(SVG.Array, {\\n  // Make array morphable\\n  morph: function(array) {\\n    this.destination = this.parse(array)\\n\\n    // normalize length of arrays\\n    if (this.value.length != this.destination.length) {\\n      var lastValue       = this.value[this.value.length - 1]\\n        , lastDestination = this.destination[this.destination.length - 1]\\n\\n      while(this.value.length > this.destination.length)\\n        this.destination.push(lastDestination)\\n      while(this.value.length < this.destination.length)\\n        this.value.push(lastValue)\\n    }\\n\\n    return this\\n  }\\n  // Clean up any duplicate points\\n, settle: function() {\\n    // find all unique values\\n    for (var i = 0, il = this.value.length, seen = []; i < il; i++)\\n      if (seen.indexOf(this.value[i]) == -1)\\n        seen.push(this.value[i])\\n\\n    // set new value\\n    return this.value = seen\\n  }\\n  // Get morphed array at given position\\n, at: function(pos) {\\n    // make sure a destination is defined\\n    if (!this.destination) return this\\n\\n    // generate morphed array\\n    for (var i = 0, il = this.value.length, array = []; i < il; i++)\\n      array.push(this.value[i] + (this.destination[i] - this.value[i]) * pos)\\n\\n    return new SVG.Array(array)\\n  }\\n  // Convert array to string\\n, toString: function() {\\n    return this.value.join(' ')\\n  }\\n  // Real value\\n, valueOf: function() {\\n    return this.value\\n  }\\n  // Parse whitespace separated string\\n, parse: function(array) {\\n    array = array.valueOf()\\n\\n    // if already is an array, no need to parse it\\n    if (Array.isArray(array)) return array\\n\\n    return this.split(array)\\n  }\\n  // Strip unnecessary whitespace\\n, split: function(string) {\\n    return string.trim().split(/\\\\s+/)\\n  }\\n  // Reverse array\\n, reverse: function() {\\n    this.value.reverse()\\n\\n    return this\\n  }\\n\\n})\\n// Poly points array\\nSVG.PointArray = function(array, fallback) {\\n  this.constructor.call(this, array, fallback || [[0,0]])\\n}\\n\\n// Inherit from SVG.Array\\nSVG.PointArray.prototype = new SVG.Array\\n\\nSVG.extend(SVG.PointArray, {\\n  // Convert array to string\\n  toString: function() {\\n    // convert to a poly point string\\n    for (var i = 0, il = this.value.length, array = []; i < il; i++)\\n      array.push(this.value[i].join(','))\\n\\n    return array.join(' ')\\n  }\\n  // Convert array to line object\\n, toLine: function() {\\n    return {\\n      x1: this.value[0][0]\\n    , y1: this.value[0][1]\\n    , x2: this.value[1][0]\\n    , y2: this.value[1][1]\\n    }\\n  }\\n  // Get morphed array at given position\\n, at: function(pos) {\\n    // make sure a destination is defined\\n    if (!this.destination) return this\\n\\n    // generate morphed point string\\n    for (var i = 0, il = this.value.length, array = []; i < il; i++)\\n      array.push([\\n        this.value[i][0] + (this.destination[i][0] - this.value[i][0]) * pos\\n      , this.value[i][1] + (this.destination[i][1] - this.value[i][1]) * pos\\n      ])\\n\\n    return new SVG.PointArray(array)\\n  }\\n  // Parse point string\\n, parse: function(array) {\\n    var points = []\\n\\n    array = array.valueOf()\\n\\n    // if already is an array, no need to parse it\\n    if (Array.isArray(array)) return array\\n\\n    // parse points\\n    array = array.trim().split(/\\\\s+|,/)\\n\\n    // validate points - https://svgwg.org/svg2-draft/shapes.html#DataTypePoints\\n    // Odd number of coordinates is an error. In such cases, drop the last odd coordinate.\\n    if (array.length % 2 !== 0) array.pop()\\n\\n    // wrap points in two-tuples and parse points as floats\\n    for(var i = 0, len = array.length; i < len; i = i + 2)\\n      points.push([ parseFloat(array[i]), parseFloat(array[i+1]) ])\\n\\n    return points\\n  }\\n  // Move point string\\n, move: function(x, y) {\\n    var box = this.bbox()\\n\\n    // get relative offset\\n    x -= box.x\\n    y -= box.y\\n\\n    // move every point\\n    if (!isNaN(x) && !isNaN(y))\\n      for (var i = this.value.length - 1; i >= 0; i--)\\n        this.value[i] = [this.value[i][0] + x, this.value[i][1] + y]\\n\\n    return this\\n  }\\n  // Resize poly string\\n, size: function(width, height) {\\n    var i, box = this.bbox()\\n\\n    // recalculate position of all points according to new size\\n    for (i = this.value.length - 1; i >= 0; i--) {\\n      this.value[i][0] = ((this.value[i][0] - box.x) * width)  / box.width  + box.x\\n      this.value[i][1] = ((this.value[i][1] - box.y) * height) / box.height + box.y\\n    }\\n\\n    return this\\n  }\\n  // Get bounding box of points\\n, bbox: function() {\\n    SVG.parser.poly.setAttribute('points', this.toString())\\n\\n    return SVG.parser.poly.getBBox()\\n  }\\n\\n})\\n// Path points array\\nSVG.PathArray = function(array, fallback) {\\n  this.constructor.call(this, array, fallback || [['M', 0, 0]])\\n}\\n\\n// Inherit from SVG.Array\\nSVG.PathArray.prototype = new SVG.Array\\n\\nSVG.extend(SVG.PathArray, {\\n  // Convert array to string\\n  toString: function() {\\n    return arrayToString(this.value)\\n  }\\n  // Move path string\\n, move: function(x, y) {\\n    // get bounding box of current situation\\n    var box = this.bbox()\\n\\n    // get relative offset\\n    x -= box.x\\n    y -= box.y\\n\\n    if (!isNaN(x) && !isNaN(y)) {\\n      // move every point\\n      for (var l, i = this.value.length - 1; i >= 0; i--) {\\n        l = this.value[i][0]\\n\\n        if (l == 'M' || l == 'L' || l == 'T')  {\\n          this.value[i][1] += x\\n          this.value[i][2] += y\\n\\n        } else if (l == 'H')  {\\n          this.value[i][1] += x\\n\\n        } else if (l == 'V')  {\\n          this.value[i][1] += y\\n\\n        } else if (l == 'C' || l == 'S' || l == 'Q')  {\\n          this.value[i][1] += x\\n          this.value[i][2] += y\\n          this.value[i][3] += x\\n          this.value[i][4] += y\\n\\n          if (l == 'C')  {\\n            this.value[i][5] += x\\n            this.value[i][6] += y\\n          }\\n\\n        } else if (l == 'A')  {\\n          this.value[i][6] += x\\n          this.value[i][7] += y\\n        }\\n\\n      }\\n    }\\n\\n    return this\\n  }\\n  // Resize path string\\n, size: function(width, height) {\\n    // get bounding box of current situation\\n    var i, l, box = this.bbox()\\n\\n    // recalculate position of all points according to new size\\n    for (i = this.value.length - 1; i >= 0; i--) {\\n      l = this.value[i][0]\\n\\n      if (l == 'M' || l == 'L' || l == 'T')  {\\n        this.value[i][1] = ((this.value[i][1] - box.x) * width)  / box.width  + box.x\\n        this.value[i][2] = ((this.value[i][2] - box.y) * height) / box.height + box.y\\n\\n      } else if (l == 'H')  {\\n        this.value[i][1] = ((this.value[i][1] - box.x) * width)  / box.width  + box.x\\n\\n      } else if (l == 'V')  {\\n        this.value[i][1] = ((this.value[i][1] - box.y) * height) / box.height + box.y\\n\\n      } else if (l == 'C' || l == 'S' || l == 'Q')  {\\n        this.value[i][1] = ((this.value[i][1] - box.x) * width)  / box.width  + box.x\\n        this.value[i][2] = ((this.value[i][2] - box.y) * height) / box.height + box.y\\n        this.value[i][3] = ((this.value[i][3] - box.x) * width)  / box.width  + box.x\\n        this.value[i][4] = ((this.value[i][4] - box.y) * height) / box.height + box.y\\n\\n        if (l == 'C')  {\\n          this.value[i][5] = ((this.value[i][5] - box.x) * width)  / box.width  + box.x\\n          this.value[i][6] = ((this.value[i][6] - box.y) * height) / box.height + box.y\\n        }\\n\\n      } else if (l == 'A')  {\\n        // resize radii\\n        this.value[i][1] = (this.value[i][1] * width)  / box.width\\n        this.value[i][2] = (this.value[i][2] * height) / box.height\\n\\n        // move position values\\n        this.value[i][6] = ((this.value[i][6] - box.x) * width)  / box.width  + box.x\\n        this.value[i][7] = ((this.value[i][7] - box.y) * height) / box.height + box.y\\n      }\\n\\n    }\\n\\n    return this\\n  }\\n  // Test if the passed path array use the same path data commands as this path array\\n, equalCommands: function(pathArray) {\\n    var i, il, equalCommands\\n\\n    pathArray = new SVG.PathArray(pathArray)\\n\\n    equalCommands = this.value.length === pathArray.value.length\\n    for(i = 0, il = this.value.length; equalCommands && i < il; i++) {\\n      equalCommands = this.value[i][0] === pathArray.value[i][0]\\n    }\\n\\n    return equalCommands\\n  }\\n  // Make path array morphable\\n, morph: function(pathArray) {\\n    pathArray = new SVG.PathArray(pathArray)\\n\\n    if(this.equalCommands(pathArray)) {\\n      this.destination = pathArray\\n    } else {\\n      this.destination = null\\n    }\\n\\n    return this\\n  }\\n  // Get morphed path array at given position\\n, at: function(pos) {\\n    // make sure a destination is defined\\n    if (!this.destination) return this\\n\\n    var sourceArray = this.value\\n      , destinationArray = this.destination.value\\n      , array = [], pathArray = new SVG.PathArray()\\n      , i, il, j, jl\\n\\n    // Animate has specified in the SVG spec\\n    // See: https://www.w3.org/TR/SVG11/paths.html#PathElement\\n    for (i = 0, il = sourceArray.length; i < il; i++) {\\n      array[i] = [sourceArray[i][0]]\\n      for(j = 1, jl = sourceArray[i].length; j < jl; j++) {\\n        array[i][j] = sourceArray[i][j] + (destinationArray[i][j] - sourceArray[i][j]) * pos\\n      }\\n      // For the two flags of the elliptical arc command, the SVG spec say:\\n      // Flags and booleans are interpolated as fractions between zero and one, with any non-zero value considered to be a value of one/true\\n      // Elliptical arc command as an array followed by corresponding indexes:\\n      // ['A', rx, ry, x-axis-rotation, large-arc-flag, sweep-flag, x, y]\\n      //   0    1   2        3                 4             5      6  7\\n      if(array[i][0] === 'A') {\\n        array[i][4] = +(array[i][4] != 0)\\n        array[i][5] = +(array[i][5] != 0)\\n      }\\n    }\\n\\n    // Directly modify the value of a path array, this is done this way for performance\\n    pathArray.value = array\\n    return pathArray\\n  }\\n  // Absolutize and parse path to array\\n, parse: function(array) {\\n    // if it's already a patharray, no need to parse it\\n    if (array instanceof SVG.PathArray) return array.valueOf()\\n\\n    // prepare for parsing\\n    var i, x0, y0, s, seg, arr\\n      , x = 0\\n      , y = 0\\n      , paramCnt = { 'M':2, 'L':2, 'H':1, 'V':1, 'C':6, 'S':4, 'Q':4, 'T':2, 'A':7 }\\n\\n    if(typeof array == 'string'){\\n\\n      array = array\\n        .replace(SVG.regex.negExp, 'X')         // replace all negative exponents with certain char\\n        .replace(SVG.regex.pathLetters, ' $& ') // put some room between letters and numbers\\n        .replace(SVG.regex.hyphen, ' -')        // add space before hyphen\\n        .replace(SVG.regex.comma, ' ')          // unify all spaces\\n        .replace(SVG.regex.X, 'e-')             // add back the expoent\\n        .trim()                                 // trim\\n        .split(SVG.regex.whitespaces)           // split into array\\n\\n      // at this place there could be parts like ['3.124.854.32'] because we could not determine the point as seperator till now\\n      // we fix this elements in the next loop\\n      for(i = array.length; --i;){\\n        if(array[i].indexOf('.') != array[i].lastIndexOf('.')){\\n          var split = array[i].split('.') // split at the point\\n          var first = [split.shift(), split.shift()].join('.') // join the first number together\\n          array.splice.apply(array, [i, 1].concat(first, split.map(function(el){ return '.'+el }))) // add first and all other entries back to array\\n        }\\n      }\\n\\n    }else{\\n      array = array.reduce(function(prev, curr){\\n        return [].concat.apply(prev, curr)\\n      }, [])\\n    }\\n\\n    // array now is an array containing all parts of a path e.g. ['M', '0', '0', 'L', '30', '30' ...]\\n\\n    var arr = []\\n\\n    do{\\n\\n      // Test if we have a path letter\\n      if(SVG.regex.isPathLetter.test(array[0])){\\n        s = array[0]\\n        array.shift()\\n      // If last letter was a move command and we got no new, it defaults to [L]ine\\n      }else if(s == 'M'){\\n        s = 'L'\\n      }else if(s == 'm'){\\n        s = 'l'\\n      }\\n\\n      // add path letter as first element\\n      seg = [s.toUpperCase()]\\n\\n      // push all necessary parameters to segment\\n      for(i = 0; i < paramCnt[seg[0]]; ++i){\\n        seg.push(parseFloat(array.shift()))\\n      }\\n\\n      // upper case\\n      if(s == seg[0]){\\n\\n        if(s == 'M' || s == 'L' || s == 'C' || s == 'Q' || s == 'S' || s == 'T'){\\n          x = seg[paramCnt[seg[0]]-1]\\n          y = seg[paramCnt[seg[0]]]\\n        }else if(s == 'V'){\\n          y = seg[1]\\n        }else if(s == 'H'){\\n          x = seg[1]\\n        }else if(s == 'A'){\\n          x = seg[6]\\n          y = seg[7]\\n        }\\n\\n      // lower case\\n      }else{\\n\\n        // convert relative to absolute values\\n        if(s == 'm' || s == 'l' || s == 'c' || s == 's' || s == 'q' || s == 't'){\\n\\n          seg[1] += x\\n          seg[2] += y\\n\\n          if(seg[3] != null){\\n            seg[3] += x\\n            seg[4] += y\\n          }\\n\\n          if(seg[5] != null){\\n            seg[5] += x\\n            seg[6] += y\\n          }\\n\\n          // move pointer\\n          x = seg[paramCnt[seg[0]]-1]\\n          y = seg[paramCnt[seg[0]]]\\n\\n        }else if(s == 'v'){\\n          seg[1] += y\\n          y = seg[1]\\n        }else if(s == 'h'){\\n          seg[1] += x\\n          x = seg[1]\\n        }else if(s == 'a'){\\n          seg[6] += x\\n          seg[7] += y\\n          x = seg[6]\\n          y = seg[7]\\n        }\\n\\n      }\\n\\n      if(seg[0] == 'M'){\\n        x0 = x\\n        y0 = y\\n      }\\n\\n      if(seg[0] == 'Z'){\\n        x = x0\\n        y = y0\\n      }\\n\\n      arr.push(seg)\\n\\n    }while(array.length)\\n\\n    return arr\\n\\n  }\\n  // Get bounding box of path\\n, bbox: function() {\\n    SVG.parser.path.setAttribute('d', this.toString())\\n\\n    return SVG.parser.path.getBBox()\\n  }\\n\\n})\\n\\n// Module for unit convertions\\nSVG.Number = SVG.invent({\\n  // Initialize\\n  create: function(value, unit) {\\n    // initialize defaults\\n    this.value = 0\\n    this.unit  = unit || ''\\n\\n    // parse value\\n    if (typeof value === 'number') {\\n      // ensure a valid numeric value\\n      this.value = isNaN(value) ? 0 : !isFinite(value) ? (value < 0 ? -3.4e+38 : +3.4e+38) : value\\n\\n    } else if (typeof value === 'string') {\\n      unit = value.match(SVG.regex.numberAndUnit)\\n\\n      if (unit) {\\n        // make value numeric\\n        this.value = parseFloat(unit[1])\\n\\n        // normalize\\n        if (unit[5] == '%')\\n          this.value /= 100\\n        else if (unit[5] == 's')\\n          this.value *= 1000\\n\\n        // store unit\\n        this.unit = unit[5]\\n      }\\n\\n    } else {\\n      if (value instanceof SVG.Number) {\\n        this.value = value.valueOf()\\n        this.unit  = value.unit\\n      }\\n    }\\n\\n  }\\n  // Add methods\\n, extend: {\\n    // Stringalize\\n    toString: function() {\\n      return (\\n        this.unit == '%' ?\\n          ~~(this.value * 1e8) / 1e6:\\n        this.unit == 's' ?\\n          this.value / 1e3 :\\n          this.value\\n      ) + this.unit\\n    }\\n  , toJSON: function() {\\n      return this.toString()\\n    }\\n  , // Convert to primitive\\n    valueOf: function() {\\n      return this.value\\n    }\\n    // Add number\\n  , plus: function(number) {\\n      return new SVG.Number(this + new SVG.Number(number), this.unit)\\n    }\\n    // Subtract number\\n  , minus: function(number) {\\n      return this.plus(-new SVG.Number(number))\\n    }\\n    // Multiply number\\n  , times: function(number) {\\n      return new SVG.Number(this * new SVG.Number(number), this.unit)\\n    }\\n    // Divide number\\n  , divide: function(number) {\\n      return new SVG.Number(this / new SVG.Number(number), this.unit)\\n    }\\n    // Convert to different unit\\n  , to: function(unit) {\\n      var number = new SVG.Number(this)\\n\\n      if (typeof unit === 'string')\\n        number.unit = unit\\n\\n      return number\\n    }\\n    // Make number morphable\\n  , morph: function(number) {\\n      this.destination = new SVG.Number(number)\\n\\n      return this\\n    }\\n    // Get morphed number at given position\\n  , at: function(pos) {\\n      // Make sure a destination is defined\\n      if (!this.destination) return this\\n\\n      // Generate new morphed number\\n      return new SVG.Number(this.destination)\\n          .minus(this)\\n          .times(pos)\\n          .plus(this)\\n    }\\n\\n  }\\n})\\n\\nSVG.Element = SVG.invent({\\n  // Initialize node\\n  create: function(node) {\\n    // make stroke value accessible dynamically\\n    this._stroke = SVG.defaults.attrs.stroke\\n\\n    // initialize data object\\n    this.dom = {}\\n\\n    // create circular reference\\n    if (this.node = node) {\\n      this.type = node.nodeName\\n      this.node.instance = this\\n\\n      // store current attribute value\\n      this._stroke = node.getAttribute('stroke') || this._stroke\\n    }\\n  }\\n\\n  // Add class methods\\n, extend: {\\n    // Move over x-axis\\n    x: function(x) {\\n      return this.attr('x', x)\\n    }\\n    // Move over y-axis\\n  , y: function(y) {\\n      return this.attr('y', y)\\n    }\\n    // Move by center over x-axis\\n  , cx: function(x) {\\n      return x == null ? this.x() + this.width() / 2 : this.x(x - this.width() / 2)\\n    }\\n    // Move by center over y-axis\\n  , cy: function(y) {\\n      return y == null ? this.y() + this.height() / 2 : this.y(y - this.height() / 2)\\n    }\\n    // Move element to given x and y values\\n  , move: function(x, y) {\\n      return this.x(x).y(y)\\n    }\\n    // Move element by its center\\n  , center: function(x, y) {\\n      return this.cx(x).cy(y)\\n    }\\n    // Set width of element\\n  , width: function(width) {\\n      return this.attr('width', width)\\n    }\\n    // Set height of element\\n  , height: function(height) {\\n      return this.attr('height', height)\\n    }\\n    // Set element size to given width and height\\n  , size: function(width, height) {\\n      var p = proportionalSize(this, width, height)\\n\\n      return this\\n        .width(new SVG.Number(p.width))\\n        .height(new SVG.Number(p.height))\\n    }\\n    // Clone element\\n  , clone: function(parent) {\\n      // clone element and assign new id\\n      var clone = assignNewId(this.node.cloneNode(true))\\n\\n      // insert the clone in the given parent or after myself\\n      if(parent) parent.add(clone)\\n      else this.after(clone)\\n\\n      return clone\\n    }\\n    // Remove element\\n  , remove: function() {\\n      if (this.parent())\\n        this.parent().removeElement(this)\\n\\n      return this\\n    }\\n    // Replace element\\n  , replace: function(element) {\\n      this.after(element).remove()\\n\\n      return element\\n    }\\n    // Add element to given container and return self\\n  , addTo: function(parent) {\\n      return parent.put(this)\\n    }\\n    // Add element to given container and return container\\n  , putIn: function(parent) {\\n      return parent.add(this)\\n    }\\n    // Get / set id\\n  , id: function(id) {\\n      return this.attr('id', id)\\n    }\\n    // Checks whether the given point inside the bounding box of the element\\n  , inside: function(x, y) {\\n      var box = this.bbox()\\n\\n      return x > box.x\\n          && y > box.y\\n          && x < box.x + box.width\\n          && y < box.y + box.height\\n    }\\n    // Show element\\n  , show: function() {\\n      return this.style('display', '')\\n    }\\n    // Hide element\\n  , hide: function() {\\n      return this.style('display', 'none')\\n    }\\n    // Is element visible?\\n  , visible: function() {\\n      return this.style('display') != 'none'\\n    }\\n    // Return id on string conversion\\n  , toString: function() {\\n      return this.attr('id')\\n    }\\n    // Return array of classes on the node\\n  , classes: function() {\\n      var attr = this.attr('class')\\n\\n      return attr == null ? [] : attr.trim().split(/\\\\s+/)\\n    }\\n    // Return true if class exists on the node, false otherwise\\n  , hasClass: function(name) {\\n      return this.classes().indexOf(name) != -1\\n    }\\n    // Add class to the node\\n  , addClass: function(name) {\\n      if (!this.hasClass(name)) {\\n        var array = this.classes()\\n        array.push(name)\\n        this.attr('class', array.join(' '))\\n      }\\n\\n      return this\\n    }\\n    // Remove class from the node\\n  , removeClass: function(name) {\\n      if (this.hasClass(name)) {\\n        this.attr('class', this.classes().filter(function(c) {\\n          return c != name\\n        }).join(' '))\\n      }\\n\\n      return this\\n    }\\n    // Toggle the presence of a class on the node\\n  , toggleClass: function(name) {\\n      return this.hasClass(name) ? this.removeClass(name) : this.addClass(name)\\n    }\\n    // Get referenced element form attribute value\\n  , reference: function(attr) {\\n      return SVG.get(this.attr(attr))\\n    }\\n    // Returns the parent element instance\\n  , parent: function(type) {\\n      var parent = this\\n\\n      // check for parent\\n      if(!parent.node.parentNode) return null\\n\\n      // get parent element\\n      parent = SVG.adopt(parent.node.parentNode)\\n\\n      if(!type) return parent\\n\\n      // loop trough ancestors if type is given\\n      while(parent && parent.node instanceof SVGElement){\\n        if(typeof type === 'string' ? parent.matches(type) : parent instanceof type) return parent\\n        parent = SVG.adopt(parent.node.parentNode)\\n      }\\n    }\\n    // Get parent document\\n  , doc: function() {\\n      return this instanceof SVG.Doc ? this : this.parent(SVG.Doc)\\n    }\\n    // return array of all ancestors of given type up to the root svg\\n  , parents: function(type) {\\n      var parents = [], parent = this\\n\\n      do{\\n        parent = parent.parent(type)\\n        if(!parent || !parent.node) break\\n\\n        parents.push(parent)\\n      } while(parent.parent)\\n\\n      return parents\\n    }\\n    // matches the element vs a css selector\\n  , matches: function(selector){\\n      return matches(this.node, selector)\\n    }\\n    // Returns the svg node to call native svg methods on it\\n  , native: function() {\\n      return this.node\\n    }\\n    // Import raw svg\\n  , svg: function(svg) {\\n      // create temporary holder\\n      var well = document.createElement('svg')\\n\\n      // act as a setter if svg is given\\n      if (svg && this instanceof SVG.Parent) {\\n        // dump raw svg\\n        well.innerHTML = '<svg>' + svg.replace(/\\\\n/, '').replace(/<(\\\\w+)([^<]+?)\\\\/>/g, '<$1$2></$1>') + '</svg>'\\n\\n        // transplant nodes\\n        for (var i = 0, il = well.firstChild.childNodes.length; i < il; i++)\\n          this.node.appendChild(well.firstChild.firstChild)\\n\\n      // otherwise act as a getter\\n      } else {\\n        // create a wrapping svg element in case of partial content\\n        well.appendChild(svg = document.createElement('svg'))\\n\\n        // write svgjs data to the dom\\n        this.writeDataToDom()\\n\\n        // insert a copy of this node\\n        svg.appendChild(this.node.cloneNode(true))\\n\\n        // return target element\\n        return well.innerHTML.replace(/^<svg>/, '').replace(/<\\\\/svg>$/, '')\\n      }\\n\\n      return this\\n    }\\n  // write svgjs data to the dom\\n  , writeDataToDom: function() {\\n\\n      // dump variables recursively\\n      if(this.each || this.lines){\\n        var fn = this.each ? this : this.lines();\\n        fn.each(function(){\\n          this.writeDataToDom()\\n        })\\n      }\\n\\n      // remove previously set data\\n      this.node.removeAttribute('svgjs:data')\\n\\n      if(Object.keys(this.dom).length)\\n        this.node.setAttribute('svgjs:data', JSON.stringify(this.dom)) // see #428\\n\\n      return this\\n    }\\n  // set given data to the elements data property\\n  , setData: function(o){\\n      this.dom = o\\n      return this\\n    }\\n  , is: function(obj){\\n      return is(this, obj)\\n    }\\n  }\\n})\\n\\nSVG.easing = {\\n  '-': function(pos){return pos}\\n, '<>':function(pos){return -Math.cos(pos * Math.PI) / 2 + 0.5}\\n, '>': function(pos){return  Math.sin(pos * Math.PI / 2)}\\n, '<': function(pos){return -Math.cos(pos * Math.PI / 2) + 1}\\n}\\n\\nSVG.morph = function(pos){\\n  return function(from, to) {\\n    return new SVG.MorphObj(from, to).at(pos)\\n  }\\n}\\n\\nSVG.Situation = SVG.invent({\\n\\n  create: function(o){\\n    this.init = false\\n    this.reversed = false\\n    this.reversing = false\\n\\n    this.duration = new SVG.Number(o.duration).valueOf()\\n    this.delay = new SVG.Number(o.delay).valueOf()\\n\\n    this.start = +new Date() + this.delay\\n    this.finish = this.start + this.duration\\n    this.ease = o.ease\\n\\n    // this.loop is incremented from 0 to this.loops\\n    // it is also incremented when in an infinite loop (when this.loops is true)\\n    this.loop = 0\\n    this.loops = false\\n\\n    this.animations = {\\n      // functionToCall: [list of morphable objects]\\n      // e.g. move: [SVG.Number, SVG.Number]\\n    }\\n\\n    this.attrs = {\\n      // holds all attributes which are not represented from a function svg.js provides\\n      // e.g. someAttr: SVG.Number\\n    }\\n\\n    this.styles = {\\n      // holds all styles which should be animated\\n      // e.g. fill-color: SVG.Color\\n    }\\n\\n    this.transforms = [\\n      // holds all transformations as transformation objects\\n      // e.g. [SVG.Rotate, SVG.Translate, SVG.Matrix]\\n    ]\\n\\n    this.once = {\\n      // functions to fire at a specific position\\n      // e.g. \\\"0.5\\\": function foo(){}\\n    }\\n\\n  }\\n\\n})\\n\\n\\nSVG.FX = SVG.invent({\\n\\n  create: function(element) {\\n    this._target = element\\n    this.situations = []\\n    this.active = false\\n    this.situation = null\\n    this.paused = false\\n    this.lastPos = 0\\n    this.pos = 0\\n    // The absolute position of an animation is its position in the context of its complete duration (including delay and loops)\\n    // When performing a delay, absPos is below 0 and when performing a loop, its value is above 1\\n    this.absPos = 0\\n    this._speed = 1\\n  }\\n\\n, extend: {\\n\\n    /**\\n     * sets or returns the target of this animation\\n     * @param o object || number In case of Object it holds all parameters. In case of number its the duration of the animation\\n     * @param ease function || string Function which should be used for easing or easing keyword\\n     * @param delay Number indicating the delay before the animation starts\\n     * @return target || this\\n     */\\n    animate: function(o, ease, delay){\\n\\n      if(typeof o == 'object'){\\n        ease = o.ease\\n        delay = o.delay\\n        o = o.duration\\n      }\\n\\n      var situation = new SVG.Situation({\\n        duration: o || 1000,\\n        delay: delay || 0,\\n        ease: SVG.easing[ease || '-'] || ease\\n      })\\n\\n      this.queue(situation)\\n\\n      return this\\n    }\\n\\n    /**\\n     * sets a delay before the next element of the queue is called\\n     * @param delay Duration of delay in milliseconds\\n     * @return this.target()\\n     */\\n  , delay: function(delay){\\n      // The delay is performed by an empty situation with its duration\\n      // attribute set to the duration of the delay\\n      var situation = new SVG.Situation({\\n        duration: delay,\\n        delay: 0,\\n        ease: SVG.easing['-']\\n      })\\n\\n      return this.queue(situation)\\n    }\\n\\n    /**\\n     * sets or returns the target of this animation\\n     * @param null || target SVG.Element which should be set as new target\\n     * @return target || this\\n     */\\n  , target: function(target){\\n      if(target && target instanceof SVG.Element){\\n        this._target = target\\n        return this\\n      }\\n\\n      return this._target\\n    }\\n\\n    // returns the absolute position at a given time\\n  , timeToAbsPos: function(timestamp){\\n      return (timestamp - this.situation.start) / (this.situation.duration/this._speed)\\n    }\\n\\n    // returns the timestamp from a given absolute positon\\n  , absPosToTime: function(absPos){\\n      return this.situation.duration/this._speed * absPos + this.situation.start\\n    }\\n\\n    // starts the animationloop\\n  , startAnimFrame: function(){\\n      this.stopAnimFrame()\\n      this.animationFrame = requestAnimationFrame(function(){ this.step() }.bind(this))\\n    }\\n\\n    // cancels the animationframe\\n  , stopAnimFrame: function(){\\n      cancelAnimationFrame(this.animationFrame)\\n    }\\n\\n    // kicks off the animation - only does something when the queue is currently not active and at least one situation is set\\n  , start: function(){\\n      // dont start if already started\\n      if(!this.active && this.situation){\\n        this.active = true\\n        this.startCurrent()\\n      }\\n\\n      return this\\n    }\\n\\n    // start the current situation\\n  , startCurrent: function(){\\n      this.situation.start = +new Date + this.situation.delay/this._speed\\n      this.situation.finish = this.situation.start + this.situation.duration/this._speed\\n      return this.initAnimations().step()\\n    }\\n\\n    /**\\n     * adds a function / Situation to the animation queue\\n     * @param fn function / situation to add\\n     * @return this\\n     */\\n  , queue: function(fn){\\n      if(typeof fn == 'function' || fn instanceof SVG.Situation)\\n        this.situations.push(fn)\\n\\n      if(!this.situation) this.situation = this.situations.shift()\\n\\n      return this\\n    }\\n\\n    /**\\n     * pulls next element from the queue and execute it\\n     * @return this\\n     */\\n  , dequeue: function(){\\n      // stop current animation\\n      this.situation && this.situation.stop && this.situation.stop()\\n\\n      // get next animation from queue\\n      this.situation = this.situations.shift()\\n\\n      if(this.situation){\\n        if(this.situation instanceof SVG.Situation) {\\n          this.startCurrent()\\n        } else {\\n          // If it is not a SVG.Situation, then it is a function, we execute it\\n          this.situation.call(this)\\n        }\\n      }\\n\\n      return this\\n    }\\n\\n    // updates all animations to the current state of the element\\n    // this is important when one property could be changed from another property\\n  , initAnimations: function() {\\n      var i\\n      var s = this.situation\\n\\n      if(s.init) return this\\n\\n      for(i in s.animations){\\n\\n        if(i == 'viewbox'){\\n          s.animations[i] = this.target().viewbox().morph(s.animations[i])\\n        }else{\\n\\n          // TODO: this is not a clean clone of the array. We may have some unchecked references\\n          s.animations[i].value = (i == 'plot' ? this.target().array().value : this.target()[i]())\\n\\n          // sometimes we get back an object and not the real value, fix this\\n          if(s.animations[i].value.value){\\n            s.animations[i].value = s.animations[i].value.value\\n          }\\n\\n          if(s.animations[i].relative)\\n            s.animations[i].destination.value = s.animations[i].destination.value + s.animations[i].value\\n\\n        }\\n\\n      }\\n\\n      for(i in s.attrs){\\n        if(s.attrs[i] instanceof SVG.Color){\\n          var color = new SVG.Color(this.target().attr(i))\\n          s.attrs[i].r = color.r\\n          s.attrs[i].g = color.g\\n          s.attrs[i].b = color.b\\n        }else{\\n          s.attrs[i].value = this.target().attr(i)// + s.attrs[i].value\\n        }\\n      }\\n\\n      for(i in s.styles){\\n        s.styles[i].value = this.target().style(i)\\n      }\\n\\n      s.initialTransformation = this.target().matrixify()\\n\\n      s.init = true\\n      return this\\n    }\\n  , clearQueue: function(){\\n      this.situations = []\\n      return this\\n    }\\n  , clearCurrent: function(){\\n      this.situation = null\\n      return this\\n    }\\n    /** stops the animation immediately\\n     * @param jumpToEnd A Boolean indicating whether to complete the current animation immediately.\\n     * @param clearQueue A Boolean indicating whether to remove queued animation as well.\\n     * @return this\\n     */\\n  , stop: function(jumpToEnd, clearQueue){\\n      if(!this.active) this.start()\\n\\n      if(clearQueue){\\n        this.clearQueue()\\n      }\\n\\n      this.active = false\\n\\n      if(jumpToEnd && this.situation){\\n        this.atEnd()\\n      }\\n\\n      this.stopAnimFrame()\\n\\n      return this.clearCurrent()\\n    }\\n\\n    /** resets the element to the state where the current element has started\\n     * @return this\\n     */\\n  , reset: function(){\\n      if(this.situation){\\n        var temp = this.situation\\n        this.stop()\\n        this.situation = temp\\n        this.atStart()\\n      }\\n      return this\\n    }\\n\\n    // Stop the currently-running animation, remove all queued animations, and complete all animations for the element.\\n  , finish: function(){\\n\\n      this.stop(true, false)\\n\\n      while(this.dequeue().situation && this.stop(true, false));\\n\\n      this.clearQueue().clearCurrent()\\n\\n      return this\\n    }\\n\\n    // set the internal animation pointer at the start position, before any loops, and updates the visualisation\\n  , atStart: function() {\\n    return this.at(0, true)\\n  }\\n\\n    // set the internal animation pointer at the end position, after all the loops, and updates the visualisation\\n  , atEnd: function() {\\n    if (this.situation.loops === true) {\\n      // If in a infinite loop, we end the current iteration\\n      return this.at(this.situation.loop+1, true)\\n    } else if(typeof this.situation.loops == 'number') {\\n      // If performing a finite number of loops, we go after all the loops\\n      return this.at(this.situation.loops, true)\\n    } else {\\n      // If no loops, we just go at the end\\n      return this.at(1, true)\\n    }\\n  }\\n\\n    // set the internal animation pointer to the specified position and updates the visualisation\\n    // if isAbsPos is true, pos is treated as an absolute position\\n  , at: function(pos, isAbsPos){\\n      var durDivSpd = this.situation.duration/this._speed\\n\\n      this.absPos = pos\\n      // If pos is not an absolute position, we convert it into one\\n      if (!isAbsPos) {\\n        if (this.situation.reversed) this.absPos = 1 - this.absPos\\n        this.absPos += this.situation.loop\\n      }\\n\\n      this.situation.start = +new Date - this.absPos * durDivSpd\\n      this.situation.finish = this.situation.start + durDivSpd\\n\\n      return this.step(true)\\n    }\\n\\n    /**\\n     * sets or returns the speed of the animations\\n     * @param speed null || Number The new speed of the animations\\n     * @return Number || this\\n     */\\n  , speed: function(speed){\\n      if (speed === 0) return this.pause()\\n\\n      if (speed) {\\n        this._speed = speed\\n        // We use an absolute position here so that speed can affect the delay before the animation\\n        return this.at(this.absPos, true)\\n      } else return this._speed\\n    }\\n\\n    // Make loopable\\n  , loop: function(times, reverse) {\\n      var c = this.last()\\n\\n      // store total loops\\n      c.loops = (times != null) ? times : true\\n      c.loop = 0\\n\\n      if(reverse) c.reversing = true\\n      return this\\n    }\\n\\n    // pauses the animation\\n  , pause: function(){\\n      this.paused = true\\n      this.stopAnimFrame()\\n\\n      return this\\n    }\\n\\n    // unpause the animation\\n  , play: function(){\\n      if(!this.paused) return this\\n      this.paused = false\\n      // We use an absolute position here so that the delay before the animation can be paused\\n      return this.at(this.absPos, true)\\n    }\\n\\n    /**\\n     * toggle or set the direction of the animation\\n     * true sets direction to backwards while false sets it to forwards\\n     * @param reversed Boolean indicating whether to reverse the animation or not (default: toggle the reverse status)\\n     * @return this\\n     */\\n  , reverse: function(reversed){\\n      var c = this.last()\\n\\n      if(typeof reversed == 'undefined') c.reversed = !c.reversed\\n      else c.reversed = reversed\\n\\n      return this\\n    }\\n\\n\\n    /**\\n     * returns a float from 0-1 indicating the progress of the current animation\\n     * @param eased Boolean indicating whether the returned position should be eased or not\\n     * @return number\\n     */\\n  , progress: function(easeIt){\\n      return easeIt ? this.situation.ease(this.pos) : this.pos\\n    }\\n\\n    /**\\n     * adds a callback function which is called when the current animation is finished\\n     * @param fn Function which should be executed as callback\\n     * @return number\\n     */\\n  , after: function(fn){\\n      var c = this.last()\\n        , wrapper = function wrapper(e){\\n            if(e.detail.situation == c){\\n              fn.call(this, c)\\n              this.off('finished.fx', wrapper) // prevent memory leak\\n            }\\n          }\\n\\n      this.target().on('finished.fx', wrapper)\\n      return this\\n    }\\n\\n    // adds a callback which is called whenever one animation step is performed\\n  , during: function(fn){\\n      var c = this.last()\\n        , wrapper = function(e){\\n            if(e.detail.situation == c){\\n              fn.call(this, e.detail.pos, SVG.morph(e.detail.pos), e.detail.eased, c)\\n            }\\n          }\\n\\n      // see above\\n      this.target().off('during.fx', wrapper).on('during.fx', wrapper)\\n\\n      return this.after(function(){\\n        this.off('during.fx', wrapper)\\n      })\\n    }\\n\\n    // calls after ALL animations in the queue are finished\\n  , afterAll: function(fn){\\n      var wrapper = function wrapper(e){\\n            fn.call(this)\\n            this.off('allfinished.fx', wrapper)\\n          }\\n\\n      // see above\\n      this.target().off('allfinished.fx', wrapper).on('allfinished.fx', wrapper)\\n      return this\\n    }\\n\\n    // calls on every animation step for all animations\\n  , duringAll: function(fn){\\n      var wrapper = function(e){\\n            fn.call(this, e.detail.pos, SVG.morph(e.detail.pos), e.detail.eased, e.detail.situation)\\n          }\\n\\n      this.target().off('during.fx', wrapper).on('during.fx', wrapper)\\n\\n      return this.afterAll(function(){\\n        this.off('during.fx', wrapper)\\n      })\\n    }\\n\\n  , last: function(){\\n      return this.situations.length ? this.situations[this.situations.length-1] : this.situation\\n    }\\n\\n    // adds one property to the animations\\n  , add: function(method, args, type){\\n      this.last()[type || 'animations'][method] = args\\n      setTimeout(function(){this.start()}.bind(this), 0)\\n      return this\\n    }\\n\\n    /** perform one step of the animation\\n     *  @param ignoreTime Boolean indicating whether to ignore time and use position directly or recalculate position based on time\\n     *  @return this\\n     */\\n  , step: function(ignoreTime){\\n\\n      // convert current time to an absolute position\\n      if(!ignoreTime) this.absPos = this.timeToAbsPos(+new Date)\\n\\n      // This part convert an absolute position to a position\\n      if(this.situation.loops !== false) {\\n        var absPos, absPosInt, lastLoop\\n\\n        // If the absolute position is below 0, we just treat it as if it was 0\\n        absPos = Math.max(this.absPos, 0)\\n        absPosInt = Math.floor(absPos)\\n\\n        if(this.situation.loops === true || absPosInt < this.situation.loops) {\\n          this.pos = absPos - absPosInt\\n          lastLoop = this.situation.loop\\n          this.situation.loop = absPosInt\\n        } else {\\n          this.absPos = this.situation.loops\\n          this.pos = 1\\n          // The -1 here is because we don't want to toggle reversed when all the loops have been completed\\n          lastLoop = this.situation.loop - 1\\n          this.situation.loop = this.situation.loops\\n        }\\n\\n        if(this.situation.reversing) {\\n          // Toggle reversed if an odd number of loops as occured since the last call of step\\n          this.situation.reversed = this.situation.reversed != Boolean((this.situation.loop - lastLoop) % 2)\\n        }\\n\\n      } else {\\n        // If there are no loop, the absolute position must not be above 1\\n        this.absPos = Math.min(this.absPos, 1)\\n        this.pos = this.absPos\\n      }\\n\\n      // while the absolute position can be below 0, the position must not be below 0\\n      if(this.pos < 0) this.pos = 0\\n\\n      if(this.situation.reversed) this.pos = 1 - this.pos\\n\\n\\n      // apply easing\\n      var eased = this.situation.ease(this.pos)\\n\\n      // call once-callbacks\\n      for(var i in this.situation.once){\\n        if(i > this.lastPos && i <= eased){\\n          this.situation.once[i].call(this.target(), this.pos, eased)\\n          delete this.situation.once[i]\\n        }\\n      }\\n\\n      // fire during callback with position, eased position and current situation as parameter\\n      if(this.active) this.target().fire('during', {pos: this.pos, eased: eased, fx: this, situation: this.situation})\\n\\n      // the user may call stop or finish in the during callback\\n      // so make sure that we still have a valid situation\\n      if(!this.situation){\\n        return this\\n      }\\n\\n      // apply the actual animation to every property\\n      this.eachAt()\\n\\n      // do final code when situation is finished\\n      if((this.pos == 1 && !this.situation.reversed) || (this.situation.reversed && this.pos == 0)){\\n\\n        // stop animation callback\\n        this.stopAnimFrame()\\n\\n        // fire finished callback with current situation as parameter\\n        this.target().fire('finished', {fx:this, situation: this.situation})\\n\\n        if(!this.situations.length){\\n          this.target().fire('allfinished')\\n          this.target().off('.fx') // there shouldnt be any binding left, but to make sure...\\n          this.active = false\\n        }\\n\\n        // start next animation\\n        if(this.active) this.dequeue()\\n        else this.clearCurrent()\\n\\n      }else if(!this.paused && this.active){\\n        // we continue animating when we are not at the end\\n        this.startAnimFrame()\\n      }\\n\\n      // save last eased position for once callback triggering\\n      this.lastPos = eased\\n      return this\\n\\n    }\\n\\n    // calculates the step for every property and calls block with it\\n  , eachAt: function(){\\n      var i, at, self = this, target = this.target(), s = this.situation\\n\\n      // apply animations which can be called trough a method\\n      for(i in s.animations){\\n\\n        at = [].concat(s.animations[i]).map(function(el){\\n          return typeof el !== 'string' && el.at ? el.at(s.ease(self.pos), self.pos) : el\\n        })\\n\\n        target[i].apply(target, at)\\n\\n      }\\n\\n      // apply animation which has to be applied with attr()\\n      for(i in s.attrs){\\n\\n        at = [i].concat(s.attrs[i]).map(function(el){\\n          return typeof el !== 'string' && el.at ? el.at(s.ease(self.pos), self.pos) : el\\n        })\\n\\n        target.attr.apply(target, at)\\n\\n      }\\n\\n      // apply animation which has to be applied with style()\\n      for(i in s.styles){\\n\\n        at = [i].concat(s.styles[i]).map(function(el){\\n          return typeof el !== 'string' && el.at ? el.at(s.ease(self.pos), self.pos) : el\\n        })\\n\\n        target.style.apply(target, at)\\n\\n      }\\n\\n      // animate initialTransformation which has to be chained\\n      if(s.transforms.length){\\n\\n        // get initial initialTransformation\\n        at = s.initialTransformation\\n        for(i = 0, len = s.transforms.length; i < len; i++){\\n\\n          // get next transformation in chain\\n          var a = s.transforms[i]\\n\\n          // multiply matrix directly\\n          if(a instanceof SVG.Matrix){\\n\\n            if(a.relative){\\n              at = at.multiply(new SVG.Matrix().morph(a).at(s.ease(this.pos)))\\n            }else{\\n              at = at.morph(a).at(s.ease(this.pos))\\n            }\\n            continue\\n          }\\n\\n          // when transformation is absolute we have to reset the needed transformation first\\n          if(!a.relative)\\n            a.undo(at.extract())\\n\\n          // and reapply it after\\n          at = at.multiply(a.at(s.ease(this.pos)))\\n\\n        }\\n\\n        // set new matrix on element\\n        target.matrix(at)\\n      }\\n\\n      return this\\n\\n    }\\n\\n\\n    // adds an once-callback which is called at a specific position and never again\\n  , once: function(pos, fn, isEased){\\n\\n      if(!isEased)pos = this.situation.ease(pos)\\n\\n      this.situation.once[pos] = fn\\n\\n      return this\\n    }\\n\\n  }\\n\\n, parent: SVG.Element\\n\\n  // Add method to parent elements\\n, construct: {\\n    // Get fx module or create a new one, then animate with given duration and ease\\n    animate: function(o, ease, delay) {\\n      return (this.fx || (this.fx = new SVG.FX(this))).animate(o, ease, delay)\\n    }\\n  , delay: function(delay){\\n      return (this.fx || (this.fx = new SVG.FX(this))).delay(delay)\\n    }\\n  , stop: function(jumpToEnd, clearQueue) {\\n      if (this.fx)\\n        this.fx.stop(jumpToEnd, clearQueue)\\n\\n      return this\\n    }\\n  , finish: function() {\\n      if (this.fx)\\n        this.fx.finish()\\n\\n      return this\\n    }\\n    // Pause current animation\\n  , pause: function() {\\n      if (this.fx)\\n        this.fx.pause()\\n\\n      return this\\n    }\\n    // Play paused current animation\\n  , play: function() {\\n      if (this.fx)\\n        this.fx.play()\\n\\n      return this\\n    }\\n    // Set/Get the speed of the animations\\n  , speed: function(speed) {\\n      if (this.fx)\\n        if (speed == null)\\n          return this.fx.speed()\\n        else\\n          this.fx.speed(speed)\\n\\n      return this\\n    }\\n  }\\n\\n})\\n\\n// MorphObj is used whenever no morphable object is given\\nSVG.MorphObj = SVG.invent({\\n\\n  create: function(from, to){\\n    // prepare color for morphing\\n    if(SVG.Color.isColor(to)) return new SVG.Color(from).morph(to)\\n    // prepare number for morphing\\n    if(SVG.regex.numberAndUnit.test(to)) return new SVG.Number(from).morph(to)\\n\\n    // prepare for plain morphing\\n    this.value = 0\\n    this.destination = to\\n  }\\n\\n, extend: {\\n    at: function(pos, real){\\n      return real < 1 ? this.value : this.destination\\n    },\\n\\n    valueOf: function(){\\n      return this.value\\n    }\\n  }\\n\\n})\\n\\nSVG.extend(SVG.FX, {\\n  // Add animatable attributes\\n  attr: function(a, v, relative) {\\n    // apply attributes individually\\n    if (typeof a == 'object') {\\n      for (var key in a)\\n        this.attr(key, a[key])\\n\\n    } else {\\n      // the MorphObj takes care about the right function used\\n      this.add(a, new SVG.MorphObj(null, v), 'attrs')\\n    }\\n\\n    return this\\n  }\\n  // Add animatable styles\\n, style: function(s, v) {\\n    if (typeof s == 'object')\\n      for (var key in s)\\n        this.style(key, s[key])\\n\\n    else\\n      this.add(s, new SVG.MorphObj(null, v), 'styles')\\n\\n    return this\\n  }\\n  // Animatable x-axis\\n, x: function(x, relative) {\\n    if(this.target() instanceof SVG.G){\\n      this.transform({x:x}, relative)\\n      return this\\n    }\\n\\n    var num = new SVG.Number().morph(x)\\n    num.relative = relative\\n    return this.add('x', num)\\n  }\\n  // Animatable y-axis\\n, y: function(y, relative) {\\n    if(this.target() instanceof SVG.G){\\n      this.transform({y:y}, relative)\\n      return this\\n    }\\n\\n    var num = new SVG.Number().morph(y)\\n    num.relative = relative\\n    return this.add('y', num)\\n  }\\n  // Animatable center x-axis\\n, cx: function(x) {\\n    return this.add('cx', new SVG.Number().morph(x))\\n  }\\n  // Animatable center y-axis\\n, cy: function(y) {\\n    return this.add('cy', new SVG.Number().morph(y))\\n  }\\n  // Add animatable move\\n, move: function(x, y) {\\n    return this.x(x).y(y)\\n  }\\n  // Add animatable center\\n, center: function(x, y) {\\n    return this.cx(x).cy(y)\\n  }\\n  // Add animatable size\\n, size: function(width, height) {\\n    if (this.target() instanceof SVG.Text) {\\n      // animate font size for Text elements\\n      this.attr('font-size', width)\\n\\n    } else {\\n      // animate bbox based size for all other elements\\n      var box\\n\\n      if(!width || !height){\\n        box = this.target().bbox()\\n      }\\n\\n      if(!width){\\n        width = box.width / box.height  * height\\n      }\\n\\n      if(!height){\\n        height = box.height / box.width  * width\\n      }\\n\\n      this.add('width' , new SVG.Number().morph(width))\\n          .add('height', new SVG.Number().morph(height))\\n\\n    }\\n\\n    return this\\n  }\\n  // Add animatable plot\\n, plot: function(p) {\\n    return this.add('plot', this.target().array().morph(p))\\n  }\\n  // Add leading method\\n, leading: function(value) {\\n    return this.target().leading ?\\n      this.add('leading', new SVG.Number().morph(value)) :\\n      this\\n  }\\n  // Add animatable viewbox\\n, viewbox: function(x, y, width, height) {\\n    if (this.target() instanceof SVG.Container) {\\n      this.add('viewbox', new SVG.ViewBox(x, y, width, height))\\n    }\\n\\n    return this\\n  }\\n, update: function(o) {\\n    if (this.target() instanceof SVG.Stop) {\\n      if (typeof o == 'number' || o instanceof SVG.Number) {\\n        return this.update({\\n          offset:  arguments[0]\\n        , color:   arguments[1]\\n        , opacity: arguments[2]\\n        })\\n      }\\n\\n      if (o.opacity != null) this.attr('stop-opacity', o.opacity)\\n      if (o.color   != null) this.attr('stop-color', o.color)\\n      if (o.offset  != null) this.attr('offset', o.offset)\\n    }\\n\\n    return this\\n  }\\n})\\n\\nSVG.BBox = SVG.invent({\\n  // Initialize\\n  create: function(element) {\\n    // get values if element is given\\n    if (element) {\\n      var box\\n\\n      // yes this is ugly, but Firefox can be a bitch when it comes to elements that are not yet rendered\\n      try {\\n\\n        // the element is NOT in the dom, throw error\\n        if(!document.documentElement.contains(element.node)) throw new Exception('Element not in the dom')\\n\\n        // find native bbox\\n        box = element.node.getBBox()\\n      } catch(e) {\\n        if(element instanceof SVG.Shape){\\n          var clone = element.clone(SVG.parser.draw).show()\\n          box = clone.bbox()\\n          clone.remove()\\n        }else{\\n          box = {\\n            x:      element.node.clientLeft\\n          , y:      element.node.clientTop\\n          , width:  element.node.clientWidth\\n          , height: element.node.clientHeight\\n          }\\n        }\\n      }\\n\\n      // plain x and y\\n      this.x = box.x\\n      this.y = box.y\\n\\n      // plain width and height\\n      this.width  = box.width\\n      this.height = box.height\\n    }\\n\\n    // add center, right and bottom\\n    fullBox(this)\\n  }\\n\\n  // Define Parent\\n, parent: SVG.Element\\n\\n  // Constructor\\n, construct: {\\n    // Get bounding box\\n    bbox: function() {\\n      return new SVG.BBox(this)\\n    }\\n  }\\n\\n})\\n\\nSVG.TBox = SVG.invent({\\n  // Initialize\\n  create: function(element) {\\n    // get values if element is given\\n    if (element) {\\n      var t   = element.ctm().extract()\\n        , box = element.bbox()\\n\\n      // width and height including transformations\\n      this.width  = box.width  * t.scaleX\\n      this.height = box.height * t.scaleY\\n\\n      // x and y including transformations\\n      this.x = box.x + t.x\\n      this.y = box.y + t.y\\n    }\\n\\n    // add center, right and bottom\\n    fullBox(this)\\n  }\\n\\n  // Define Parent\\n, parent: SVG.Element\\n\\n  // Constructor\\n, construct: {\\n    // Get transformed bounding box\\n    tbox: function() {\\n      return new SVG.TBox(this)\\n    }\\n  }\\n\\n})\\n\\n\\nSVG.RBox = SVG.invent({\\n  // Initialize\\n  create: function(element) {\\n    if (element) {\\n      var e    = element.doc().parent()\\n        , box  = element.node.getBoundingClientRect()\\n        , zoom = 1\\n\\n      // get screen offset\\n      this.x = box.left\\n      this.y = box.top\\n\\n      // subtract parent offset\\n      this.x -= e.offsetLeft\\n      this.y -= e.offsetTop\\n\\n      while (e = e.offsetParent) {\\n        this.x -= e.offsetLeft\\n        this.y -= e.offsetTop\\n      }\\n\\n      // calculate cumulative zoom from svg documents\\n      e = element\\n      while (e.parent && (e = e.parent())) {\\n        if (e.viewbox) {\\n          zoom *= e.viewbox().zoom\\n          this.x -= e.x() || 0\\n          this.y -= e.y() || 0\\n        }\\n      }\\n\\n      // recalculate viewbox distortion\\n      this.width  = box.width  /= zoom\\n      this.height = box.height /= zoom\\n    }\\n\\n    // add center, right and bottom\\n    fullBox(this)\\n\\n    // offset by window scroll position, because getBoundingClientRect changes when window is scrolled\\n    this.x += window.pageXOffset\\n    this.y += window.pageYOffset\\n  }\\n\\n  // define Parent\\n, parent: SVG.Element\\n\\n  // Constructor\\n, construct: {\\n    // Get rect box\\n    rbox: function() {\\n      return new SVG.RBox(this)\\n    }\\n  }\\n\\n})\\n\\n// Add universal merge method\\n;[SVG.BBox, SVG.TBox, SVG.RBox].forEach(function(c) {\\n\\n  SVG.extend(c, {\\n    // Merge rect box with another, return a new instance\\n    merge: function(box) {\\n      var b = new c()\\n\\n      // merge boxes\\n      b.x      = Math.min(this.x, box.x)\\n      b.y      = Math.min(this.y, box.y)\\n      b.width  = Math.max(this.x + this.width,  box.x + box.width)  - b.x\\n      b.height = Math.max(this.y + this.height, box.y + box.height) - b.y\\n\\n      return fullBox(b)\\n    }\\n\\n  })\\n\\n})\\n\\nSVG.Matrix = SVG.invent({\\n  // Initialize\\n  create: function(source) {\\n    var i, base = arrayToMatrix([1, 0, 0, 1, 0, 0])\\n\\n    // ensure source as object\\n    source = source instanceof SVG.Element ?\\n      source.matrixify() :\\n    typeof source === 'string' ?\\n      stringToMatrix(source) :\\n    arguments.length == 6 ?\\n      arrayToMatrix([].slice.call(arguments)) :\\n    typeof source === 'object' ?\\n      source : base\\n\\n    // merge source\\n    for (i = abcdef.length - 1; i >= 0; --i)\\n      this[abcdef[i]] = source && typeof source[abcdef[i]] === 'number' ?\\n        source[abcdef[i]] : base[abcdef[i]]\\n  }\\n\\n  // Add methods\\n, extend: {\\n    // Extract individual transformations\\n    extract: function() {\\n      // find delta transform points\\n      var px    = deltaTransformPoint(this, 0, 1)\\n        , py    = deltaTransformPoint(this, 1, 0)\\n        , skewX = 180 / Math.PI * Math.atan2(px.y, px.x) - 90\\n\\n      return {\\n        // translation\\n        x:        this.e\\n      , y:        this.f\\n      , transformedX:(this.e * Math.cos(skewX * Math.PI / 180) + this.f * Math.sin(skewX * Math.PI / 180)) / Math.sqrt(this.a * this.a + this.b * this.b)\\n      , transformedY:(this.f * Math.cos(skewX * Math.PI / 180) + this.e * Math.sin(-skewX * Math.PI / 180)) / Math.sqrt(this.c * this.c + this.d * this.d)\\n        // skew\\n      , skewX:    -skewX\\n      , skewY:    180 / Math.PI * Math.atan2(py.y, py.x)\\n        // scale\\n      , scaleX:   Math.sqrt(this.a * this.a + this.b * this.b)\\n      , scaleY:   Math.sqrt(this.c * this.c + this.d * this.d)\\n        // rotation\\n      , rotation: skewX\\n      , a: this.a\\n      , b: this.b\\n      , c: this.c\\n      , d: this.d\\n      , e: this.e\\n      , f: this.f\\n      , matrix: new SVG.Matrix(this)\\n      }\\n    }\\n    // Clone matrix\\n  , clone: function() {\\n      return new SVG.Matrix(this)\\n    }\\n    // Morph one matrix into another\\n  , morph: function(matrix) {\\n      // store new destination\\n      this.destination = new SVG.Matrix(matrix)\\n\\n      return this\\n    }\\n    // Get morphed matrix at a given position\\n  , at: function(pos) {\\n      // make sure a destination is defined\\n      if (!this.destination) return this\\n\\n      // calculate morphed matrix at a given position\\n      var matrix = new SVG.Matrix({\\n        a: this.a + (this.destination.a - this.a) * pos\\n      , b: this.b + (this.destination.b - this.b) * pos\\n      , c: this.c + (this.destination.c - this.c) * pos\\n      , d: this.d + (this.destination.d - this.d) * pos\\n      , e: this.e + (this.destination.e - this.e) * pos\\n      , f: this.f + (this.destination.f - this.f) * pos\\n      })\\n\\n      // process parametric rotation if present\\n      if (this.param && this.param.to) {\\n        // calculate current parametric position\\n        var param = {\\n          rotation: this.param.from.rotation + (this.param.to.rotation - this.param.from.rotation) * pos\\n        , cx:       this.param.from.cx\\n        , cy:       this.param.from.cy\\n        }\\n\\n        // rotate matrix\\n        matrix = matrix.rotate(\\n          (this.param.to.rotation - this.param.from.rotation * 2) * pos\\n        , param.cx\\n        , param.cy\\n        )\\n\\n        // store current parametric values\\n        matrix.param = param\\n      }\\n\\n      return matrix\\n    }\\n    // Multiplies by given matrix\\n  , multiply: function(matrix) {\\n      return new SVG.Matrix(this.native().multiply(parseMatrix(matrix).native()))\\n    }\\n    // Inverses matrix\\n  , inverse: function() {\\n      return new SVG.Matrix(this.native().inverse())\\n    }\\n    // Translate matrix\\n  , translate: function(x, y) {\\n      return new SVG.Matrix(this.native().translate(x || 0, y || 0))\\n    }\\n    // Scale matrix\\n  , scale: function(x, y, cx, cy) {\\n      // support uniformal scale\\n      if (arguments.length == 1) {\\n        y = x\\n      } else if (arguments.length == 3) {\\n        cy = cx\\n        cx = y\\n        y = x\\n      }\\n\\n      return this.around(cx, cy, new SVG.Matrix(x, 0, 0, y, 0, 0))\\n    }\\n    // Rotate matrix\\n  , rotate: function(r, cx, cy) {\\n      // convert degrees to radians\\n      r = SVG.utils.radians(r)\\n\\n      return this.around(cx, cy, new SVG.Matrix(Math.cos(r), Math.sin(r), -Math.sin(r), Math.cos(r), 0, 0))\\n    }\\n    // Flip matrix on x or y, at a given offset\\n  , flip: function(a, o) {\\n      return a == 'x' ? this.scale(-1, 1, o, 0) : this.scale(1, -1, 0, o)\\n    }\\n    // Skew\\n  , skew: function(x, y, cx, cy) {\\n      // support uniformal skew\\n      if (arguments.length == 1) {\\n        y = x\\n      } else if (arguments.length == 3) {\\n        cy = cx\\n        cx = y\\n        y = x\\n      }\\n\\n      // convert degrees to radians\\n      x = SVG.utils.radians(x)\\n      y = SVG.utils.radians(y)\\n\\n      return this.around(cx, cy, new SVG.Matrix(1, Math.tan(y), Math.tan(x), 1, 0, 0))\\n    }\\n    // SkewX\\n  , skewX: function(x, cx, cy) {\\n      return this.skew(x, 0, cx, cy)\\n    }\\n    // SkewY\\n  , skewY: function(y, cx, cy) {\\n      return this.skew(0, y, cx, cy)\\n    }\\n    // Transform around a center point\\n  , around: function(cx, cy, matrix) {\\n      return this\\n        .multiply(new SVG.Matrix(1, 0, 0, 1, cx || 0, cy || 0))\\n        .multiply(matrix)\\n        .multiply(new SVG.Matrix(1, 0, 0, 1, -cx || 0, -cy || 0))\\n    }\\n    // Convert to native SVGMatrix\\n  , native: function() {\\n      // create new matrix\\n      var matrix = SVG.parser.native.createSVGMatrix()\\n\\n      // update with current values\\n      for (var i = abcdef.length - 1; i >= 0; i--)\\n        matrix[abcdef[i]] = this[abcdef[i]]\\n\\n      return matrix\\n    }\\n    // Convert matrix to string\\n  , toString: function() {\\n      return 'matrix(' + this.a + ',' + this.b + ',' + this.c + ',' + this.d + ',' + this.e + ',' + this.f + ')'\\n    }\\n  }\\n\\n  // Define parent\\n, parent: SVG.Element\\n\\n  // Add parent method\\n, construct: {\\n    // Get current matrix\\n    ctm: function() {\\n      return new SVG.Matrix(this.node.getCTM())\\n    },\\n    // Get current screen matrix\\n    screenCTM: function() {\\n      return new SVG.Matrix(this.node.getScreenCTM())\\n    }\\n\\n  }\\n\\n})\\n\\nSVG.Point = SVG.invent({\\n  // Initialize\\n  create: function(x,y) {\\n    var i, source, base = {x:0, y:0}\\n\\n    // ensure source as object\\n    source = Array.isArray(x) ?\\n      {x:x[0], y:x[1]} :\\n    typeof x === 'object' ?\\n      {x:x.x, y:x.y} :\\n    x != null ?\\n      {x:x, y:(y != null ? y : x)} : base // If y has no value, then x is used has its value\\n\\n    // merge source\\n    this.x = source.x\\n    this.y = source.y\\n  }\\n\\n  // Add methods\\n, extend: {\\n    // Clone point\\n    clone: function() {\\n      return new SVG.Point(this)\\n    }\\n    // Morph one point into another\\n  , morph: function(x, y) {\\n      // store new destination\\n      this.destination = new SVG.Point(x, y)\\n\\n      return this\\n    }\\n    // Get morphed point at a given position\\n  , at: function(pos) {\\n      // make sure a destination is defined\\n      if (!this.destination) return this\\n\\n      // calculate morphed matrix at a given position\\n      var point = new SVG.Point({\\n        x: this.x + (this.destination.x - this.x) * pos\\n      , y: this.y + (this.destination.y - this.y) * pos\\n      })\\n\\n      return point\\n    }\\n    // Convert to native SVGPoint\\n  , native: function() {\\n      // create new point\\n      var point = SVG.parser.native.createSVGPoint()\\n\\n      // update with current values\\n      point.x = this.x\\n      point.y = this.y\\n\\n      return point\\n    }\\n    // transform point with matrix\\n  , transform: function(matrix) {\\n      return new SVG.Point(this.native().matrixTransform(matrix.native()))\\n    }\\n\\n  }\\n\\n})\\n\\nSVG.extend(SVG.Element, {\\n\\n  // Get point\\n  point: function(x, y) {\\n    return new SVG.Point(x,y).transform(this.screenCTM().inverse());\\n  }\\n\\n})\\n\\nSVG.extend(SVG.Element, {\\n  // Set svg element attribute\\n  attr: function(a, v, n) {\\n    // act as full getter\\n    if (a == null) {\\n      // get an object of attributes\\n      a = {}\\n      v = this.node.attributes\\n      for (n = v.length - 1; n >= 0; n--)\\n        a[v[n].nodeName] = SVG.regex.isNumber.test(v[n].nodeValue) ? parseFloat(v[n].nodeValue) : v[n].nodeValue\\n\\n      return a\\n\\n    } else if (typeof a == 'object') {\\n      // apply every attribute individually if an object is passed\\n      for (v in a) this.attr(v, a[v])\\n\\n    } else if (v === null) {\\n        // remove value\\n        this.node.removeAttribute(a)\\n\\n    } else if (v == null) {\\n      // act as a getter if the first and only argument is not an object\\n      v = this.node.getAttribute(a)\\n      return v == null ?\\n        SVG.defaults.attrs[a] :\\n      SVG.regex.isNumber.test(v) ?\\n        parseFloat(v) : v\\n\\n    } else {\\n      // BUG FIX: some browsers will render a stroke if a color is given even though stroke width is 0\\n      if (a == 'stroke-width')\\n        this.attr('stroke', parseFloat(v) > 0 ? this._stroke : null)\\n      else if (a == 'stroke')\\n        this._stroke = v\\n\\n      // convert image fill and stroke to patterns\\n      if (a == 'fill' || a == 'stroke') {\\n        if (SVG.regex.isImage.test(v))\\n          v = this.doc().defs().image(v, 0, 0)\\n\\n        if (v instanceof SVG.Image)\\n          v = this.doc().defs().pattern(0, 0, function() {\\n            this.add(v)\\n          })\\n      }\\n\\n      // ensure correct numeric values (also accepts NaN and Infinity)\\n      if (typeof v === 'number')\\n        v = new SVG.Number(v)\\n\\n      // ensure full hex color\\n      else if (SVG.Color.isColor(v))\\n        v = new SVG.Color(v)\\n\\n      // parse array values\\n      else if (Array.isArray(v))\\n        v = new SVG.Array(v)\\n\\n      // store parametric transformation values locally\\n      else if (v instanceof SVG.Matrix && v.param)\\n        this.param = v.param\\n\\n      // if the passed attribute is leading...\\n      if (a == 'leading') {\\n        // ... call the leading method instead\\n        if (this.leading)\\n          this.leading(v)\\n      } else {\\n        // set given attribute on node\\n        typeof n === 'string' ?\\n          this.node.setAttributeNS(n, a, v.toString()) :\\n          this.node.setAttribute(a, v.toString())\\n      }\\n\\n      // rebuild if required\\n      if (this.rebuild && (a == 'font-size' || a == 'x'))\\n        this.rebuild(a, v)\\n    }\\n\\n    return this\\n  }\\n})\\nSVG.extend(SVG.Element, {\\n  // Add transformations\\n  transform: function(o, relative) {\\n    // get target in case of the fx module, otherwise reference this\\n    var target = this\\n      , matrix\\n\\n    // act as a getter\\n    if (typeof o !== 'object') {\\n      // get current matrix\\n      matrix = new SVG.Matrix(target).extract()\\n\\n      return typeof o === 'string' ? matrix[o] : matrix\\n    }\\n\\n    // get current matrix\\n    matrix = new SVG.Matrix(target)\\n\\n    // ensure relative flag\\n    relative = !!relative || !!o.relative\\n\\n    // act on matrix\\n    if (o.a != null) {\\n      matrix = relative ?\\n        // relative\\n        matrix.multiply(new SVG.Matrix(o)) :\\n        // absolute\\n        new SVG.Matrix(o)\\n\\n    // act on rotation\\n    } else if (o.rotation != null) {\\n      // ensure centre point\\n      ensureCentre(o, target)\\n\\n      // apply transformation\\n      matrix = relative ?\\n        // relative\\n        matrix.rotate(o.rotation, o.cx, o.cy) :\\n        // absolute\\n        matrix.rotate(o.rotation - matrix.extract().rotation, o.cx, o.cy)\\n\\n    // act on scale\\n    } else if (o.scale != null || o.scaleX != null || o.scaleY != null) {\\n      // ensure centre point\\n      ensureCentre(o, target)\\n\\n      // ensure scale values on both axes\\n      o.scaleX = o.scale != null ? o.scale : o.scaleX != null ? o.scaleX : 1\\n      o.scaleY = o.scale != null ? o.scale : o.scaleY != null ? o.scaleY : 1\\n\\n      if (!relative) {\\n        // absolute; multiply inversed values\\n        var e = matrix.extract()\\n        o.scaleX = o.scaleX * 1 / e.scaleX\\n        o.scaleY = o.scaleY * 1 / e.scaleY\\n      }\\n\\n      matrix = matrix.scale(o.scaleX, o.scaleY, o.cx, o.cy)\\n\\n    // act on skew\\n    } else if (o.skew != null || o.skewX != null || o.skewY != null) {\\n      // ensure centre point\\n      ensureCentre(o, target)\\n\\n      // ensure skew values on both axes\\n      o.skewX = o.skew != null ? o.skew : o.skewX != null ? o.skewX : 0\\n      o.skewY = o.skew != null ? o.skew : o.skewY != null ? o.skewY : 0\\n\\n      if (!relative) {\\n        // absolute; reset skew values\\n        var e = matrix.extract()\\n        matrix = matrix.multiply(new SVG.Matrix().skew(e.skewX, e.skewY, o.cx, o.cy).inverse())\\n      }\\n\\n      matrix = matrix.skew(o.skewX, o.skewY, o.cx, o.cy)\\n\\n    // act on flip\\n    } else if (o.flip) {\\n      matrix = matrix.flip(\\n        o.flip\\n      , o.offset == null ? target.bbox()['c' + o.flip] : o.offset\\n      )\\n\\n    // act on translate\\n    } else if (o.x != null || o.y != null) {\\n      if (relative) {\\n        // relative\\n        matrix = matrix.translate(o.x, o.y)\\n      } else {\\n        // absolute\\n        if (o.x != null) matrix.e = o.x\\n        if (o.y != null) matrix.f = o.y\\n      }\\n    }\\n\\n    return this.attr('transform', matrix)\\n  }\\n})\\n\\nSVG.extend(SVG.FX, {\\n  transform: function(o, relative) {\\n    // get target in case of the fx module, otherwise reference this\\n    var target = this.target()\\n      , matrix\\n\\n    // act as a getter\\n    if (typeof o !== 'object') {\\n      // get current matrix\\n      matrix = new SVG.Matrix(target).extract()\\n\\n      return typeof o === 'string' ? matrix[o] : matrix\\n    }\\n\\n    // ensure relative flag\\n    relative = !!relative || !!o.relative\\n\\n    // act on matrix\\n    if (o.a != null) {\\n      matrix = new SVG.Matrix(o)\\n\\n    // act on rotation\\n    } else if (o.rotation != null) {\\n      // ensure centre point\\n      ensureCentre(o, target)\\n\\n      // apply transformation\\n      matrix = new SVG.Rotate(o.rotation, o.cx, o.cy)\\n\\n    // act on scale\\n    } else if (o.scale != null || o.scaleX != null || o.scaleY != null) {\\n      // ensure centre point\\n      ensureCentre(o, target)\\n\\n      // ensure scale values on both axes\\n      o.scaleX = o.scale != null ? o.scale : o.scaleX != null ? o.scaleX : 1\\n      o.scaleY = o.scale != null ? o.scale : o.scaleY != null ? o.scaleY : 1\\n\\n      matrix = new SVG.Scale(o.scaleX, o.scaleY, o.cx, o.cy)\\n\\n    // act on skew\\n    } else if (o.skewX != null || o.skewY != null) {\\n      // ensure centre point\\n      ensureCentre(o, target)\\n\\n      // ensure skew values on both axes\\n      o.skewX = o.skewX != null ? o.skewX : 0\\n      o.skewY = o.skewY != null ? o.skewY : 0\\n\\n      matrix = new SVG.Skew(o.skewX, o.skewY, o.cx, o.cy)\\n\\n    // act on flip\\n    } else if (o.flip) {\\n      matrix = new SVG.Matrix().morph(new SVG.Matrix().flip(\\n        o.flip\\n      , o.offset == null ? target.bbox()['c' + o.flip] : o.offset\\n      ))\\n\\n    // act on translate\\n    } else if (o.x != null || o.y != null) {\\n      matrix = new SVG.Translate(o.x, o.y)\\n    }\\n\\n    if(!matrix) return this\\n\\n    matrix.relative = relative\\n\\n    this.last().transforms.push(matrix)\\n\\n    setTimeout(function(){this.start()}.bind(this), 0)\\n\\n    return this\\n  }\\n})\\n\\nSVG.extend(SVG.Element, {\\n  // Reset all transformations\\n  untransform: function() {\\n    return this.attr('transform', null)\\n  },\\n  // merge the whole transformation chain into one matrix and returns it\\n  matrixify: function() {\\n\\n    var matrix = (this.attr('transform') || '')\\n      // split transformations\\n      .split(/\\\\)\\\\s*,?\\\\s*/).slice(0,-1).map(function(str){\\n        // generate key => value pairs\\n        var kv = str.trim().split('(')\\n        return [kv[0], kv[1].split(SVG.regex.matrixElements).map(function(str){ return parseFloat(str) })]\\n      })\\n      // calculate every transformation into one matrix\\n      .reduce(function(matrix, transform){\\n\\n        if(transform[0] == 'matrix') return matrix.multiply(arrayToMatrix(transform[1]))\\n        return matrix[transform[0]].apply(matrix, transform[1])\\n\\n      }, new SVG.Matrix())\\n\\n    return matrix\\n  },\\n  // add an element to another parent without changing the visual representation on the screen\\n  toParent: function(parent) {\\n    if(this == parent) return this\\n    var ctm = this.screenCTM()\\n    var temp = parent.rect(1,1)\\n    var pCtm = temp.screenCTM().inverse()\\n    temp.remove()\\n\\n    this.addTo(parent).untransform().transform(pCtm.multiply(ctm))\\n\\n    return this\\n  },\\n  // same as above with parent equals root-svg\\n  toDoc: function() {\\n    return this.toParent(this.doc())\\n  }\\n\\n})\\n\\nSVG.Transformation = SVG.invent({\\n\\n  create: function(source, inversed){\\n\\n    if(arguments.length > 1 && typeof inversed != 'boolean'){\\n      return this.create([].slice.call(arguments))\\n    }\\n\\n    if(typeof source == 'object'){\\n      for(var i = 0, len = this.arguments.length; i < len; ++i){\\n        this[this.arguments[i]] = source[this.arguments[i]]\\n      }\\n    }\\n\\n    if(Array.isArray(source)){\\n      for(var i = 0, len = this.arguments.length; i < len; ++i){\\n        this[this.arguments[i]] = source[i]\\n      }\\n    }\\n\\n    this.inversed = false\\n\\n    if(inversed === true){\\n      this.inversed = true\\n    }\\n\\n  }\\n\\n, extend: {\\n\\n    at: function(pos){\\n\\n      var params = []\\n\\n      for(var i = 0, len = this.arguments.length; i < len; ++i){\\n        params.push(this[this.arguments[i]])\\n      }\\n\\n      var m = this._undo || new SVG.Matrix()\\n\\n      m = new SVG.Matrix().morph(SVG.Matrix.prototype[this.method].apply(m, params)).at(pos)\\n\\n      return this.inversed ? m.inverse() : m\\n\\n    }\\n\\n  , undo: function(o){\\n      for(var i = 0, len = this.arguments.length; i < len; ++i){\\n        o[this.arguments[i]] = typeof this[this.arguments[i]] == 'undefined' ? 0 : o[this.arguments[i]]\\n      }\\n\\n      // The method SVG.Matrix.extract which was used before calling this\\n      // method to obtain a value for the parameter o doesn't return a cx and\\n      // a cy so we use the ones that were provided to this object at its creation\\n      o.cx = this.cx\\n      o.cy = this.cy\\n\\n      this._undo = new SVG[capitalize(this.method)](o, true).at(1)\\n\\n      return this\\n    }\\n\\n  }\\n\\n})\\n\\nSVG.Translate = SVG.invent({\\n\\n  parent: SVG.Matrix\\n, inherit: SVG.Transformation\\n\\n, create: function(source, inversed){\\n    if(typeof source == 'object') this.constructor.call(this, source, inversed)\\n    else this.constructor.call(this, [].slice.call(arguments))\\n  }\\n\\n, extend: {\\n    arguments: ['transformedX', 'transformedY']\\n  , method: 'translate'\\n  }\\n\\n})\\n\\nSVG.Rotate = SVG.invent({\\n\\n  parent: SVG.Matrix\\n, inherit: SVG.Transformation\\n\\n, create: function(source, inversed){\\n    if(typeof source == 'object') this.constructor.call(this, source, inversed)\\n    else this.constructor.call(this, [].slice.call(arguments))\\n  }\\n\\n, extend: {\\n    arguments: ['rotation', 'cx', 'cy']\\n  , method: 'rotate'\\n  , at: function(pos){\\n      var m = new SVG.Matrix().rotate(new SVG.Number().morph(this.rotation - (this._undo ? this._undo.rotation : 0)).at(pos), this.cx, this.cy)\\n      return this.inversed ? m.inverse() : m\\n    }\\n  , undo: function(o){\\n      this._undo = o\\n    }\\n  }\\n\\n})\\n\\nSVG.Scale = SVG.invent({\\n\\n  parent: SVG.Matrix\\n, inherit: SVG.Transformation\\n\\n, create: function(source, inversed){\\n    if(typeof source == 'object') this.constructor.call(this, source, inversed)\\n    else this.constructor.call(this, [].slice.call(arguments))\\n  }\\n\\n, extend: {\\n    arguments: ['scaleX', 'scaleY', 'cx', 'cy']\\n  , method: 'scale'\\n  }\\n\\n})\\n\\nSVG.Skew = SVG.invent({\\n\\n  parent: SVG.Matrix\\n, inherit: SVG.Transformation\\n\\n, create: function(source, inversed){\\n    if(typeof source == 'object') this.constructor.call(this, source, inversed)\\n    else this.constructor.call(this, [].slice.call(arguments))\\n  }\\n\\n, extend: {\\n    arguments: ['skewX', 'skewY', 'cx', 'cy']\\n  , method: 'skew'\\n  }\\n\\n})\\n\\nSVG.extend(SVG.Element, {\\n  // Dynamic style generator\\n  style: function(s, v) {\\n    if (arguments.length == 0) {\\n      // get full style\\n      return this.node.style.cssText || ''\\n\\n    } else if (arguments.length < 2) {\\n      // apply every style individually if an object is passed\\n      if (typeof s == 'object') {\\n        for (v in s) this.style(v, s[v])\\n\\n      } else if (SVG.regex.isCss.test(s)) {\\n        // parse css string\\n        s = s.split(';')\\n\\n        // apply every definition individually\\n        for (var i = 0; i < s.length; i++) {\\n          v = s[i].split(':')\\n          this.style(v[0].replace(/\\\\s+/g, ''), v[1])\\n        }\\n      } else {\\n        // act as a getter if the first and only argument is not an object\\n        return this.node.style[camelCase(s)]\\n      }\\n\\n    } else {\\n      this.node.style[camelCase(s)] = v === null || SVG.regex.isBlank.test(v) ? '' : v\\n    }\\n\\n    return this\\n  }\\n})\\nSVG.Parent = SVG.invent({\\n  // Initialize node\\n  create: function(element) {\\n    this.constructor.call(this, element)\\n  }\\n\\n  // Inherit from\\n, inherit: SVG.Element\\n\\n  // Add class methods\\n, extend: {\\n    // Returns all child elements\\n    children: function() {\\n      return SVG.utils.map(SVG.utils.filterSVGElements(this.node.childNodes), function(node) {\\n        return SVG.adopt(node)\\n      })\\n    }\\n    // Add given element at a position\\n  , add: function(element, i) {\\n      if (i == null)\\n        this.node.appendChild(element.node)\\n      else if (element.node != this.node.childNodes[i])\\n        this.node.insertBefore(element.node, this.node.childNodes[i])\\n\\n      return this\\n    }\\n    // Basically does the same as `add()` but returns the added element instead\\n  , put: function(element, i) {\\n      this.add(element, i)\\n      return element\\n    }\\n    // Checks if the given element is a child\\n  , has: function(element) {\\n      return this.index(element) >= 0\\n    }\\n    // Gets index of given element\\n  , index: function(element) {\\n      return [].slice.call(this.node.childNodes).indexOf(element.node)\\n    }\\n    // Get a element at the given index\\n  , get: function(i) {\\n      return SVG.adopt(this.node.childNodes[i])\\n    }\\n    // Get first child\\n  , first: function() {\\n      return this.get(0)\\n    }\\n    // Get the last child\\n  , last: function() {\\n      return this.get(this.node.childNodes.length - 1)\\n    }\\n    // Iterates over all children and invokes a given block\\n  , each: function(block, deep) {\\n      var i, il\\n        , children = this.children()\\n\\n      for (i = 0, il = children.length; i < il; i++) {\\n        if (children[i] instanceof SVG.Element)\\n          block.apply(children[i], [i, children])\\n\\n        if (deep && (children[i] instanceof SVG.Container))\\n          children[i].each(block, deep)\\n      }\\n\\n      return this\\n    }\\n    // Remove a given child\\n  , removeElement: function(element) {\\n      this.node.removeChild(element.node)\\n\\n      return this\\n    }\\n    // Remove all elements in this container\\n  , clear: function() {\\n      // remove children\\n      while(this.node.hasChildNodes())\\n        this.node.removeChild(this.node.lastChild)\\n\\n      // remove defs reference\\n      delete this._defs\\n\\n      return this\\n    }\\n  , // Get defs\\n    defs: function() {\\n      return this.doc().defs()\\n    }\\n  }\\n\\n})\\n\\nSVG.extend(SVG.Parent, {\\n\\n  ungroup: function(parent, depth) {\\n    if(depth === 0 || this instanceof SVG.Defs) return this\\n\\n    parent = parent || (this instanceof SVG.Doc ? this : this.parent(SVG.Parent))\\n    depth = depth || Infinity\\n\\n    this.each(function(){\\n      if(this instanceof SVG.Defs) return this\\n      if(this instanceof SVG.Parent) return this.ungroup(parent, depth-1)\\n      return this.toParent(parent)\\n    })\\n\\n    this.node.firstChild || this.remove()\\n\\n    return this\\n  },\\n\\n  flatten: function(parent, depth) {\\n    return this.ungroup(parent, depth)\\n  }\\n\\n})\\nSVG.Container = SVG.invent({\\n  // Initialize node\\n  create: function(element) {\\n    this.constructor.call(this, element)\\n  }\\n\\n  // Inherit from\\n, inherit: SVG.Parent\\n\\n})\\n\\nSVG.ViewBox = SVG.invent({\\n\\n  create: function(source) {\\n    var i, base = [0, 0, 0, 0]\\n\\n    var x, y, width, height, box, view, we, he\\n      , wm   = 1 // width multiplier\\n      , hm   = 1 // height multiplier\\n      , reg  = /[+-]?(?:\\\\d+(?:\\\\.\\\\d*)?|\\\\.\\\\d+)(?:e[+-]?\\\\d+)?/gi\\n\\n    if(source instanceof SVG.Element){\\n\\n      we = source\\n      he = source\\n      view = (source.attr('viewBox') || '').match(reg)\\n      box = source.bbox\\n\\n      // get dimensions of current node\\n      width  = new SVG.Number(source.width())\\n      height = new SVG.Number(source.height())\\n\\n      // find nearest non-percentual dimensions\\n      while (width.unit == '%') {\\n        wm *= width.value\\n        width = new SVG.Number(we instanceof SVG.Doc ? we.parent().offsetWidth : we.parent().width())\\n        we = we.parent()\\n      }\\n      while (height.unit == '%') {\\n        hm *= height.value\\n        height = new SVG.Number(he instanceof SVG.Doc ? he.parent().offsetHeight : he.parent().height())\\n        he = he.parent()\\n      }\\n\\n      // ensure defaults\\n      this.x      = 0\\n      this.y      = 0\\n      this.width  = width  * wm\\n      this.height = height * hm\\n      this.zoom   = 1\\n\\n      if (view) {\\n        // get width and height from viewbox\\n        x      = parseFloat(view[0])\\n        y      = parseFloat(view[1])\\n        width  = parseFloat(view[2])\\n        height = parseFloat(view[3])\\n\\n        // calculate zoom accoring to viewbox\\n        this.zoom = ((this.width / this.height) > (width / height)) ?\\n          this.height / height :\\n          this.width  / width\\n\\n        // calculate real pixel dimensions on parent SVG.Doc element\\n        this.x      = x\\n        this.y      = y\\n        this.width  = width\\n        this.height = height\\n\\n      }\\n\\n    }else{\\n\\n      // ensure source as object\\n      source = typeof source === 'string' ?\\n        source.match(reg).map(function(el){ return parseFloat(el) }) :\\n      Array.isArray(source) ?\\n        source :\\n      typeof source == 'object' ?\\n        [source.x, source.y, source.width, source.height] :\\n      arguments.length == 4 ?\\n        [].slice.call(arguments) :\\n        base\\n\\n      this.x = source[0]\\n      this.y = source[1]\\n      this.width = source[2]\\n      this.height = source[3]\\n    }\\n\\n\\n  }\\n\\n, extend: {\\n\\n    toString: function() {\\n      return this.x + ' ' + this.y + ' ' + this.width + ' ' + this.height\\n    }\\n  , morph: function(v){\\n\\n      var v = arguments.length == 1 ?\\n        [v.x, v.y, v.width, v.height] :\\n        [].slice.call(arguments)\\n\\n      this.destination = new SVG.ViewBox(v)\\n\\n      return this\\n\\n    }\\n\\n  , at: function(pos) {\\n\\n    if(!this.destination) return this\\n\\n    return new SVG.ViewBox([\\n        this.x + (this.destination.x - this.x) * pos\\n      , this.y + (this.destination.y - this.y) * pos\\n      , this.width + (this.destination.width - this.width) * pos\\n      , this.height + (this.destination.height - this.height) * pos\\n    ])\\n\\n    }\\n\\n  }\\n\\n  // Define parent\\n, parent: SVG.Container\\n\\n  // Add parent method\\n, construct: {\\n\\n    // get/set viewbox\\n    viewbox: function(v) {\\n      if (arguments.length == 0)\\n        // act as a getter if there are no arguments\\n        return new SVG.ViewBox(this)\\n\\n      // otherwise act as a setter\\n      v = arguments.length == 1 ?\\n        [v.x, v.y, v.width, v.height] :\\n        [].slice.call(arguments)\\n\\n      return this.attr('viewBox', v)\\n    }\\n\\n  }\\n\\n})\\n// Add events to elements\\n;[  'click'\\n  , 'dblclick'\\n  , 'mousedown'\\n  , 'mouseup'\\n  , 'mouseover'\\n  , 'mouseout'\\n  , 'mousemove'\\n  // , 'mouseenter' -> not supported by IE\\n  // , 'mouseleave' -> not supported by IE\\n  , 'touchstart'\\n  , 'touchmove'\\n  , 'touchleave'\\n  , 'touchend'\\n  , 'touchcancel' ].forEach(function(event) {\\n\\n  // add event to SVG.Element\\n  SVG.Element.prototype[event] = function(f) {\\n    var self = this\\n\\n    // bind event to element rather than element node\\n    this.node['on' + event] = typeof f == 'function' ?\\n      function() { return f.apply(self, arguments) } : null\\n\\n    return this\\n  }\\n\\n})\\n\\n// Initialize listeners stack\\nSVG.listeners = []\\nSVG.handlerMap = []\\nSVG.listenerId = 0\\n\\n// Add event binder in the SVG namespace\\nSVG.on = function(node, event, listener, binding) {\\n  // create listener, get object-index\\n  var l     = listener.bind(binding || node.instance || node)\\n    , index = (SVG.handlerMap.indexOf(node) + 1 || SVG.handlerMap.push(node)) - 1\\n    , ev    = event.split('.')[0]\\n    , ns    = event.split('.')[1] || '*'\\n\\n\\n  // ensure valid object\\n  SVG.listeners[index]         = SVG.listeners[index]         || {}\\n  SVG.listeners[index][ev]     = SVG.listeners[index][ev]     || {}\\n  SVG.listeners[index][ev][ns] = SVG.listeners[index][ev][ns] || {}\\n\\n  if(!listener._svgjsListenerId)\\n    listener._svgjsListenerId = ++SVG.listenerId\\n\\n  // reference listener\\n  SVG.listeners[index][ev][ns][listener._svgjsListenerId] = l\\n\\n  // add listener\\n  node.addEventListener(ev, l, false)\\n}\\n\\n// Add event unbinder in the SVG namespace\\nSVG.off = function(node, event, listener) {\\n  var index = SVG.handlerMap.indexOf(node)\\n    , ev    = event && event.split('.')[0]\\n    , ns    = event && event.split('.')[1]\\n\\n  if(index == -1) return\\n\\n  if (listener) {\\n    if(typeof listener == 'function') listener = listener._svgjsListenerId\\n    if(!listener) return\\n\\n    // remove listener reference\\n    if (SVG.listeners[index][ev] && SVG.listeners[index][ev][ns || '*']) {\\n      // remove listener\\n      node.removeEventListener(ev, SVG.listeners[index][ev][ns || '*'][listener], false)\\n\\n      delete SVG.listeners[index][ev][ns || '*'][listener]\\n    }\\n\\n  } else if (ns && ev) {\\n    // remove all listeners for a namespaced event\\n    if (SVG.listeners[index][ev] && SVG.listeners[index][ev][ns]) {\\n      for (listener in SVG.listeners[index][ev][ns])\\n        SVG.off(node, [ev, ns].join('.'), listener)\\n\\n      delete SVG.listeners[index][ev][ns]\\n    }\\n\\n  } else if (ns){\\n    // remove all listeners for a specific namespace\\n    for(event in SVG.listeners[index]){\\n        for(namespace in SVG.listeners[index][event]){\\n            if(ns === namespace){\\n                SVG.off(node, [event, ns].join('.'))\\n            }\\n        }\\n    }\\n\\n  } else if (ev) {\\n    // remove all listeners for the event\\n    if (SVG.listeners[index][ev]) {\\n      for (namespace in SVG.listeners[index][ev])\\n        SVG.off(node, [ev, namespace].join('.'))\\n\\n      delete SVG.listeners[index][ev]\\n    }\\n\\n  } else {\\n    // remove all listeners on a given node\\n    for (event in SVG.listeners[index])\\n      SVG.off(node, event)\\n\\n    delete SVG.listeners[index]\\n\\n  }\\n}\\n\\n//\\nSVG.extend(SVG.Element, {\\n  // Bind given event to listener\\n  on: function(event, listener, binding) {\\n    SVG.on(this.node, event, listener, binding)\\n\\n    return this\\n  }\\n  // Unbind event from listener\\n, off: function(event, listener) {\\n    SVG.off(this.node, event, listener)\\n\\n    return this\\n  }\\n  // Fire given event\\n, fire: function(event, data) {\\n\\n    // Dispatch event\\n    if(event instanceof Event){\\n        this.node.dispatchEvent(event)\\n    }else{\\n        this.node.dispatchEvent(new CustomEvent(event, {detail:data}))\\n    }\\n\\n    return this\\n  }\\n})\\n\\nSVG.Defs = SVG.invent({\\n  // Initialize node\\n  create: 'defs'\\n\\n  // Inherit from\\n, inherit: SVG.Container\\n\\n})\\nSVG.G = SVG.invent({\\n  // Initialize node\\n  create: 'g'\\n\\n  // Inherit from\\n, inherit: SVG.Container\\n\\n  // Add class methods\\n, extend: {\\n    // Move over x-axis\\n    x: function(x) {\\n      return x == null ? this.transform('x') : this.transform({ x: x - this.x() }, true)\\n    }\\n    // Move over y-axis\\n  , y: function(y) {\\n      return y == null ? this.transform('y') : this.transform({ y: y - this.y() }, true)\\n    }\\n    // Move by center over x-axis\\n  , cx: function(x) {\\n      return x == null ? this.gbox().cx : this.x(x - this.gbox().width / 2)\\n    }\\n    // Move by center over y-axis\\n  , cy: function(y) {\\n      return y == null ? this.gbox().cy : this.y(y - this.gbox().height / 2)\\n    }\\n  , gbox: function() {\\n\\n      var bbox  = this.bbox()\\n        , trans = this.transform()\\n\\n      bbox.x  += trans.x\\n      bbox.x2 += trans.x\\n      bbox.cx += trans.x\\n\\n      bbox.y  += trans.y\\n      bbox.y2 += trans.y\\n      bbox.cy += trans.y\\n\\n      return bbox\\n    }\\n  }\\n\\n  // Add parent method\\n, construct: {\\n    // Create a group element\\n    group: function() {\\n      return this.put(new SVG.G)\\n    }\\n  }\\n})\\n\\n// ### This module adds backward / forward functionality to elements.\\n\\n//\\nSVG.extend(SVG.Element, {\\n  // Get all siblings, including myself\\n  siblings: function() {\\n    return this.parent().children()\\n  }\\n  // Get the curent position siblings\\n, position: function() {\\n    return this.parent().index(this)\\n  }\\n  // Get the next element (will return null if there is none)\\n, next: function() {\\n    return this.siblings()[this.position() + 1]\\n  }\\n  // Get the next element (will return null if there is none)\\n, previous: function() {\\n    return this.siblings()[this.position() - 1]\\n  }\\n  // Send given element one step forward\\n, forward: function() {\\n    var i = this.position() + 1\\n      , p = this.parent()\\n\\n    // move node one step forward\\n    p.removeElement(this).add(this, i)\\n\\n    // make sure defs node is always at the top\\n    if (p instanceof SVG.Doc)\\n      p.node.appendChild(p.defs().node)\\n\\n    return this\\n  }\\n  // Send given element one step backward\\n, backward: function() {\\n    var i = this.position()\\n\\n    if (i > 0)\\n      this.parent().removeElement(this).add(this, i - 1)\\n\\n    return this\\n  }\\n  // Send given element all the way to the front\\n, front: function() {\\n    var p = this.parent()\\n\\n    // Move node forward\\n    p.node.appendChild(this.node)\\n\\n    // Make sure defs node is always at the top\\n    if (p instanceof SVG.Doc)\\n      p.node.appendChild(p.defs().node)\\n\\n    return this\\n  }\\n  // Send given element all the way to the back\\n, back: function() {\\n    if (this.position() > 0)\\n      this.parent().removeElement(this).add(this, 0)\\n\\n    return this\\n  }\\n  // Inserts a given element before the targeted element\\n, before: function(element) {\\n    element.remove()\\n\\n    var i = this.position()\\n\\n    this.parent().add(element, i)\\n\\n    return this\\n  }\\n  // Insters a given element after the targeted element\\n, after: function(element) {\\n    element.remove()\\n\\n    var i = this.position()\\n\\n    this.parent().add(element, i + 1)\\n\\n    return this\\n  }\\n\\n})\\nSVG.Mask = SVG.invent({\\n  // Initialize node\\n  create: function() {\\n    this.constructor.call(this, SVG.create('mask'))\\n\\n    // keep references to masked elements\\n    this.targets = []\\n  }\\n\\n  // Inherit from\\n, inherit: SVG.Container\\n\\n  // Add class methods\\n, extend: {\\n    // Unmask all masked elements and remove itself\\n    remove: function() {\\n      // unmask all targets\\n      for (var i = this.targets.length - 1; i >= 0; i--)\\n        if (this.targets[i])\\n          this.targets[i].unmask()\\n      this.targets = []\\n\\n      // remove mask from parent\\n      this.parent().removeElement(this)\\n\\n      return this\\n    }\\n  }\\n\\n  // Add parent method\\n, construct: {\\n    // Create masking element\\n    mask: function() {\\n      return this.defs().put(new SVG.Mask)\\n    }\\n  }\\n})\\n\\n\\nSVG.extend(SVG.Element, {\\n  // Distribute mask to svg element\\n  maskWith: function(element) {\\n    // use given mask or create a new one\\n    this.masker = element instanceof SVG.Mask ? element : this.parent().mask().add(element)\\n\\n    // store reverence on self in mask\\n    this.masker.targets.push(this)\\n\\n    // apply mask\\n    return this.attr('mask', 'url(\\\"#' + this.masker.attr('id') + '\\\")')\\n  }\\n  // Unmask element\\n, unmask: function() {\\n    delete this.masker\\n    return this.attr('mask', null)\\n  }\\n\\n})\\n\\nSVG.ClipPath = SVG.invent({\\n  // Initialize node\\n  create: function() {\\n    this.constructor.call(this, SVG.create('clipPath'))\\n\\n    // keep references to clipped elements\\n    this.targets = []\\n  }\\n\\n  // Inherit from\\n, inherit: SVG.Container\\n\\n  // Add class methods\\n, extend: {\\n    // Unclip all clipped elements and remove itself\\n    remove: function() {\\n      // unclip all targets\\n      for (var i = this.targets.length - 1; i >= 0; i--)\\n        if (this.targets[i])\\n          this.targets[i].unclip()\\n      this.targets = []\\n\\n      // remove clipPath from parent\\n      this.parent().removeElement(this)\\n\\n      return this\\n    }\\n  }\\n\\n  // Add parent method\\n, construct: {\\n    // Create clipping element\\n    clip: function() {\\n      return this.defs().put(new SVG.ClipPath)\\n    }\\n  }\\n})\\n\\n//\\nSVG.extend(SVG.Element, {\\n  // Distribute clipPath to svg element\\n  clipWith: function(element) {\\n    // use given clip or create a new one\\n    this.clipper = element instanceof SVG.ClipPath ? element : this.parent().clip().add(element)\\n\\n    // store reverence on self in mask\\n    this.clipper.targets.push(this)\\n\\n    // apply mask\\n    return this.attr('clip-path', 'url(\\\"#' + this.clipper.attr('id') + '\\\")')\\n  }\\n  // Unclip element\\n, unclip: function() {\\n    delete this.clipper\\n    return this.attr('clip-path', null)\\n  }\\n\\n})\\nSVG.Gradient = SVG.invent({\\n  // Initialize node\\n  create: function(type) {\\n    this.constructor.call(this, SVG.create(type + 'Gradient'))\\n\\n    // store type\\n    this.type = type\\n  }\\n\\n  // Inherit from\\n, inherit: SVG.Container\\n\\n  // Add class methods\\n, extend: {\\n    // Add a color stop\\n    at: function(offset, color, opacity) {\\n      return this.put(new SVG.Stop).update(offset, color, opacity)\\n    }\\n    // Update gradient\\n  , update: function(block) {\\n      // remove all stops\\n      this.clear()\\n\\n      // invoke passed block\\n      if (typeof block == 'function')\\n        block.call(this, this)\\n\\n      return this\\n    }\\n    // Return the fill id\\n  , fill: function() {\\n      return 'url(#' + this.id() + ')'\\n    }\\n    // Alias string convertion to fill\\n  , toString: function() {\\n      return this.fill()\\n    }\\n    // custom attr to handle transform\\n  , attr: function(a, b, c) {\\n      if(a == 'transform') a = 'gradientTransform'\\n      return SVG.Container.prototype.attr.call(this, a, b, c)\\n    }\\n  }\\n\\n  // Add parent method\\n, construct: {\\n    // Create gradient element in defs\\n    gradient: function(type, block) {\\n      return this.defs().gradient(type, block)\\n    }\\n  }\\n})\\n\\n// Add animatable methods to both gradient and fx module\\nSVG.extend(SVG.Gradient, SVG.FX, {\\n  // From position\\n  from: function(x, y) {\\n    return (this._target || this).type == 'radial' ?\\n      this.attr({ fx: new SVG.Number(x), fy: new SVG.Number(y) }) :\\n      this.attr({ x1: new SVG.Number(x), y1: new SVG.Number(y) })\\n  }\\n  // To position\\n, to: function(x, y) {\\n    return (this._target || this).type == 'radial' ?\\n      this.attr({ cx: new SVG.Number(x), cy: new SVG.Number(y) }) :\\n      this.attr({ x2: new SVG.Number(x), y2: new SVG.Number(y) })\\n  }\\n})\\n\\n// Base gradient generation\\nSVG.extend(SVG.Defs, {\\n  // define gradient\\n  gradient: function(type, block) {\\n    return this.put(new SVG.Gradient(type)).update(block)\\n  }\\n\\n})\\n\\nSVG.Stop = SVG.invent({\\n  // Initialize node\\n  create: 'stop'\\n\\n  // Inherit from\\n, inherit: SVG.Element\\n\\n  // Add class methods\\n, extend: {\\n    // add color stops\\n    update: function(o) {\\n      if (typeof o == 'number' || o instanceof SVG.Number) {\\n        o = {\\n          offset:  arguments[0]\\n        , color:   arguments[1]\\n        , opacity: arguments[2]\\n        }\\n      }\\n\\n      // set attributes\\n      if (o.opacity != null) this.attr('stop-opacity', o.opacity)\\n      if (o.color   != null) this.attr('stop-color', o.color)\\n      if (o.offset  != null) this.attr('offset', new SVG.Number(o.offset))\\n\\n      return this\\n    }\\n  }\\n\\n})\\n\\nSVG.Pattern = SVG.invent({\\n  // Initialize node\\n  create: 'pattern'\\n\\n  // Inherit from\\n, inherit: SVG.Container\\n\\n  // Add class methods\\n, extend: {\\n    // Return the fill id\\n    fill: function() {\\n      return 'url(#' + this.id() + ')'\\n    }\\n    // Update pattern by rebuilding\\n  , update: function(block) {\\n      // remove content\\n      this.clear()\\n\\n      // invoke passed block\\n      if (typeof block == 'function')\\n        block.call(this, this)\\n\\n      return this\\n    }\\n    // Alias string convertion to fill\\n  , toString: function() {\\n      return this.fill()\\n    }\\n    // custom attr to handle transform\\n  , attr: function(a, b, c) {\\n      if(a == 'transform') a = 'patternTransform'\\n      return SVG.Container.prototype.attr.call(this, a, b, c)\\n    }\\n\\n  }\\n\\n  // Add parent method\\n, construct: {\\n    // Create pattern element in defs\\n    pattern: function(width, height, block) {\\n      return this.defs().pattern(width, height, block)\\n    }\\n  }\\n})\\n\\nSVG.extend(SVG.Defs, {\\n  // Define gradient\\n  pattern: function(width, height, block) {\\n    return this.put(new SVG.Pattern).update(block).attr({\\n      x:            0\\n    , y:            0\\n    , width:        width\\n    , height:       height\\n    , patternUnits: 'userSpaceOnUse'\\n    })\\n  }\\n\\n})\\nSVG.Doc = SVG.invent({\\n  // Initialize node\\n  create: function(element) {\\n    if (element) {\\n      // ensure the presence of a dom element\\n      element = typeof element == 'string' ?\\n        document.getElementById(element) :\\n        element\\n\\n      // If the target is an svg element, use that element as the main wrapper.\\n      // This allows svg.js to work with svg documents as well.\\n      if (element.nodeName == 'svg') {\\n        this.constructor.call(this, element)\\n      } else {\\n        this.constructor.call(this, SVG.create('svg'))\\n        element.appendChild(this.node)\\n        this.size('100%', '100%')\\n      }\\n\\n      // set svg element attributes and ensure defs node\\n      this.namespace().defs()\\n    }\\n  }\\n\\n  // Inherit from\\n, inherit: SVG.Container\\n\\n  // Add class methods\\n, extend: {\\n    // Add namespaces\\n    namespace: function() {\\n      return this\\n        .attr({ xmlns: SVG.ns, version: '1.1' })\\n        .attr('xmlns:xlink', SVG.xlink, SVG.xmlns)\\n        .attr('xmlns:svgjs', SVG.svgjs, SVG.xmlns)\\n    }\\n    // Creates and returns defs element\\n  , defs: function() {\\n      if (!this._defs) {\\n        var defs\\n\\n        // Find or create a defs element in this instance\\n        if (defs = this.node.getElementsByTagName('defs')[0])\\n          this._defs = SVG.adopt(defs)\\n        else\\n          this._defs = new SVG.Defs\\n\\n        // Make sure the defs node is at the end of the stack\\n        this.node.appendChild(this._defs.node)\\n      }\\n\\n      return this._defs\\n    }\\n    // custom parent method\\n  , parent: function() {\\n      return this.node.parentNode.nodeName == '#document' ? null : this.node.parentNode\\n    }\\n    // Fix for possible sub-pixel offset. See:\\n    // https://bugzilla.mozilla.org/show_bug.cgi?id=608812\\n  , spof: function(spof) {\\n      var pos = this.node.getScreenCTM()\\n\\n      if (pos)\\n        this\\n          .style('left', (-pos.e % 1) + 'px')\\n          .style('top',  (-pos.f % 1) + 'px')\\n\\n      return this\\n    }\\n\\n      // Removes the doc from the DOM\\n  , remove: function() {\\n      if(this.parent()) {\\n        this.parent().removeChild(this.node);\\n      }\\n\\n      return this;\\n    }\\n  }\\n\\n})\\n\\nSVG.Shape = SVG.invent({\\n  // Initialize node\\n  create: function(element) {\\n    this.constructor.call(this, element)\\n  }\\n\\n  // Inherit from\\n, inherit: SVG.Element\\n\\n})\\n\\nSVG.Bare = SVG.invent({\\n  // Initialize\\n  create: function(element, inherit) {\\n    // construct element\\n    this.constructor.call(this, SVG.create(element))\\n\\n    // inherit custom methods\\n    if (inherit)\\n      for (var method in inherit.prototype)\\n        if (typeof inherit.prototype[method] === 'function')\\n          this[method] = inherit.prototype[method]\\n  }\\n\\n  // Inherit from\\n, inherit: SVG.Element\\n\\n  // Add methods\\n, extend: {\\n    // Insert some plain text\\n    words: function(text) {\\n      // remove contents\\n      while (this.node.hasChildNodes())\\n        this.node.removeChild(this.node.lastChild)\\n\\n      // create text node\\n      this.node.appendChild(document.createTextNode(text))\\n\\n      return this\\n    }\\n  }\\n})\\n\\n\\nSVG.extend(SVG.Parent, {\\n  // Create an element that is not described by SVG.js\\n  element: function(element, inherit) {\\n    return this.put(new SVG.Bare(element, inherit))\\n  }\\n  // Add symbol element\\n, symbol: function() {\\n    return this.defs().element('symbol', SVG.Container)\\n  }\\n\\n})\\nSVG.Use = SVG.invent({\\n  // Initialize node\\n  create: 'use'\\n\\n  // Inherit from\\n, inherit: SVG.Shape\\n\\n  // Add class methods\\n, extend: {\\n    // Use element as a reference\\n    element: function(element, file) {\\n      // Set lined element\\n      return this.attr('href', (file || '') + '#' + element, SVG.xlink)\\n    }\\n  }\\n\\n  // Add parent method\\n, construct: {\\n    // Create a use element\\n    use: function(element, file) {\\n      return this.put(new SVG.Use).element(element, file)\\n    }\\n  }\\n})\\nSVG.Rect = SVG.invent({\\n  // Initialize node\\n  create: 'rect'\\n\\n  // Inherit from\\n, inherit: SVG.Shape\\n\\n  // Add parent method\\n, construct: {\\n    // Create a rect element\\n    rect: function(width, height) {\\n      return this.put(new SVG.Rect()).size(width, height)\\n    }\\n  }\\n})\\nSVG.Circle = SVG.invent({\\n  // Initialize node\\n  create: 'circle'\\n\\n  // Inherit from\\n, inherit: SVG.Shape\\n\\n  // Add parent method\\n, construct: {\\n    // Create circle element, based on ellipse\\n    circle: function(size) {\\n      return this.put(new SVG.Circle).rx(new SVG.Number(size).divide(2)).move(0, 0)\\n    }\\n  }\\n})\\n\\nSVG.extend(SVG.Circle, SVG.FX, {\\n  // Radius x value\\n  rx: function(rx) {\\n    return this.attr('r', rx)\\n  }\\n  // Alias radius x value\\n, ry: function(ry) {\\n    return this.rx(ry)\\n  }\\n})\\n\\nSVG.Ellipse = SVG.invent({\\n  // Initialize node\\n  create: 'ellipse'\\n\\n  // Inherit from\\n, inherit: SVG.Shape\\n\\n  // Add parent method\\n, construct: {\\n    // Create an ellipse\\n    ellipse: function(width, height) {\\n      return this.put(new SVG.Ellipse).size(width, height).move(0, 0)\\n    }\\n  }\\n})\\n\\nSVG.extend(SVG.Ellipse, SVG.Rect, SVG.FX, {\\n  // Radius x value\\n  rx: function(rx) {\\n    return this.attr('rx', rx)\\n  }\\n  // Radius y value\\n, ry: function(ry) {\\n    return this.attr('ry', ry)\\n  }\\n})\\n\\n// Add common method\\nSVG.extend(SVG.Circle, SVG.Ellipse, {\\n    // Move over x-axis\\n    x: function(x) {\\n      return x == null ? this.cx() - this.rx() : this.cx(x + this.rx())\\n    }\\n    // Move over y-axis\\n  , y: function(y) {\\n      return y == null ? this.cy() - this.ry() : this.cy(y + this.ry())\\n    }\\n    // Move by center over x-axis\\n  , cx: function(x) {\\n      return x == null ? this.attr('cx') : this.attr('cx', x)\\n    }\\n    // Move by center over y-axis\\n  , cy: function(y) {\\n      return y == null ? this.attr('cy') : this.attr('cy', y)\\n    }\\n    // Set width of element\\n  , width: function(width) {\\n      return width == null ? this.rx() * 2 : this.rx(new SVG.Number(width).divide(2))\\n    }\\n    // Set height of element\\n  , height: function(height) {\\n      return height == null ? this.ry() * 2 : this.ry(new SVG.Number(height).divide(2))\\n    }\\n    // Custom size function\\n  , size: function(width, height) {\\n      var p = proportionalSize(this, width, height)\\n\\n      return this\\n        .rx(new SVG.Number(p.width).divide(2))\\n        .ry(new SVG.Number(p.height).divide(2))\\n    }\\n})\\nSVG.Line = SVG.invent({\\n  // Initialize node\\n  create: 'line'\\n\\n  // Inherit from\\n, inherit: SVG.Shape\\n\\n  // Add class methods\\n, extend: {\\n    // Get array\\n    array: function() {\\n      return new SVG.PointArray([\\n        [ this.attr('x1'), this.attr('y1') ]\\n      , [ this.attr('x2'), this.attr('y2') ]\\n      ])\\n    }\\n    // Overwrite native plot() method\\n  , plot: function(x1, y1, x2, y2) {\\n      if (typeof y1 !== 'undefined')\\n        x1 = { x1: x1, y1: y1, x2: x2, y2: y2 }\\n      else\\n        x1 = new SVG.PointArray(x1).toLine()\\n\\n      return this.attr(x1)\\n    }\\n    // Move by left top corner\\n  , move: function(x, y) {\\n      return this.attr(this.array().move(x, y).toLine())\\n    }\\n    // Set element size to given width and height\\n  , size: function(width, height) {\\n      var p = proportionalSize(this, width, height)\\n\\n      return this.attr(this.array().size(p.width, p.height).toLine())\\n    }\\n  }\\n\\n  // Add parent method\\n, construct: {\\n    // Create a line element\\n    line: function(x1, y1, x2, y2) {\\n      return this.put(new SVG.Line).plot(x1, y1, x2, y2)\\n    }\\n  }\\n})\\n\\nSVG.Polyline = SVG.invent({\\n  // Initialize node\\n  create: 'polyline'\\n\\n  // Inherit from\\n, inherit: SVG.Shape\\n\\n  // Add parent method\\n, construct: {\\n    // Create a wrapped polyline element\\n    polyline: function(p) {\\n      return this.put(new SVG.Polyline).plot(p)\\n    }\\n  }\\n})\\n\\nSVG.Polygon = SVG.invent({\\n  // Initialize node\\n  create: 'polygon'\\n\\n  // Inherit from\\n, inherit: SVG.Shape\\n\\n  // Add parent method\\n, construct: {\\n    // Create a wrapped polygon element\\n    polygon: function(p) {\\n      return this.put(new SVG.Polygon).plot(p)\\n    }\\n  }\\n})\\n\\n// Add polygon-specific functions\\nSVG.extend(SVG.Polyline, SVG.Polygon, {\\n  // Get array\\n  array: function() {\\n    return this._array || (this._array = new SVG.PointArray(this.attr('points')))\\n  }\\n  // Plot new path\\n, plot: function(p) {\\n    return this.attr('points', (this._array = new SVG.PointArray(p)))\\n  }\\n  // Move by left top corner\\n, move: function(x, y) {\\n    return this.attr('points', this.array().move(x, y))\\n  }\\n  // Set element size to given width and height\\n, size: function(width, height) {\\n    var p = proportionalSize(this, width, height)\\n\\n    return this.attr('points', this.array().size(p.width, p.height))\\n  }\\n\\n})\\n// unify all point to point elements\\nSVG.extend(SVG.Line, SVG.Polyline, SVG.Polygon, {\\n  // Define morphable array\\n  morphArray:  SVG.PointArray\\n  // Move by left top corner over x-axis\\n, x: function(x) {\\n    return x == null ? this.bbox().x : this.move(x, this.bbox().y)\\n  }\\n  // Move by left top corner over y-axis\\n, y: function(y) {\\n    return y == null ? this.bbox().y : this.move(this.bbox().x, y)\\n  }\\n  // Set width of element\\n, width: function(width) {\\n    var b = this.bbox()\\n\\n    return width == null ? b.width : this.size(width, b.height)\\n  }\\n  // Set height of element\\n, height: function(height) {\\n    var b = this.bbox()\\n\\n    return height == null ? b.height : this.size(b.width, height)\\n  }\\n})\\nSVG.Path = SVG.invent({\\n  // Initialize node\\n  create: 'path'\\n\\n  // Inherit from\\n, inherit: SVG.Shape\\n\\n  // Add class methods\\n, extend: {\\n    // Define morphable array\\n    morphArray:  SVG.PathArray\\n    // Get array\\n  , array: function() {\\n      return this._array || (this._array = new SVG.PathArray(this.attr('d')))\\n    }\\n    // Plot new poly points\\n  , plot: function(p) {\\n      return this.attr('d', (this._array = new SVG.PathArray(p)))\\n    }\\n    // Move by left top corner\\n  , move: function(x, y) {\\n      return this.attr('d', this.array().move(x, y))\\n    }\\n    // Move by left top corner over x-axis\\n  , x: function(x) {\\n      return x == null ? this.bbox().x : this.move(x, this.bbox().y)\\n    }\\n    // Move by left top corner over y-axis\\n  , y: function(y) {\\n      return y == null ? this.bbox().y : this.move(this.bbox().x, y)\\n    }\\n    // Set element size to given width and height\\n  , size: function(width, height) {\\n      var p = proportionalSize(this, width, height)\\n\\n      return this.attr('d', this.array().size(p.width, p.height))\\n    }\\n    // Set width of element\\n  , width: function(width) {\\n      return width == null ? this.bbox().width : this.size(width, this.bbox().height)\\n    }\\n    // Set height of element\\n  , height: function(height) {\\n      return height == null ? this.bbox().height : this.size(this.bbox().width, height)\\n    }\\n\\n  }\\n\\n  // Add parent method\\n, construct: {\\n    // Create a wrapped path element\\n    path: function(d) {\\n      return this.put(new SVG.Path).plot(d)\\n    }\\n  }\\n})\\nSVG.Image = SVG.invent({\\n  // Initialize node\\n  create: 'image'\\n\\n  // Inherit from\\n, inherit: SVG.Shape\\n\\n  // Add class methods\\n, extend: {\\n    // (re)load image\\n    load: function(url) {\\n      if (!url) return this\\n\\n      var self = this\\n        , img  = document.createElement('img')\\n\\n      // preload image\\n      img.onload = function() {\\n        var p = self.parent(SVG.Pattern)\\n\\n        if(p === null) return\\n\\n        // ensure image size\\n        if (self.width() == 0 && self.height() == 0)\\n          self.size(img.width, img.height)\\n\\n        // ensure pattern size if not set\\n        if (p && p.width() == 0 && p.height() == 0)\\n          p.size(self.width(), self.height())\\n\\n        // callback\\n        if (typeof self._loaded === 'function')\\n          self._loaded.call(self, {\\n            width:  img.width\\n          , height: img.height\\n          , ratio:  img.width / img.height\\n          , url:    url\\n          })\\n      }\\n\\n      img.onerror = function(e){\\n        if (typeof self._error === 'function'){\\n            self._error.call(self, e)\\n        }\\n      }\\n\\n      return this.attr('href', (img.src = this.src = url), SVG.xlink)\\n    }\\n    // Add loaded callback\\n  , loaded: function(loaded) {\\n      this._loaded = loaded\\n      return this\\n    }\\n\\n  , error: function(error) {\\n      this._error = error\\n      return this\\n    }\\n  }\\n\\n  // Add parent method\\n, construct: {\\n    // create image element, load image and set its size\\n    image: function(source, width, height) {\\n      return this.put(new SVG.Image).load(source).size(width || 0, height || width || 0)\\n    }\\n  }\\n\\n})\\nSVG.Text = SVG.invent({\\n  // Initialize node\\n  create: function() {\\n    this.constructor.call(this, SVG.create('text'))\\n\\n    this.dom.leading = new SVG.Number(1.3)    // store leading value for rebuilding\\n    this._rebuild = true                      // enable automatic updating of dy values\\n    this._build   = false                     // disable build mode for adding multiple lines\\n\\n    // set default font\\n    this.attr('font-family', SVG.defaults.attrs['font-family'])\\n  }\\n\\n  // Inherit from\\n, inherit: SVG.Shape\\n\\n  // Add class methods\\n, extend: {\\n    // Move over x-axis\\n    x: function(x) {\\n      // act as getter\\n      if (x == null)\\n        return this.attr('x')\\n\\n      // move lines as well if no textPath is present\\n      if (!this.textPath)\\n        this.lines().each(function() { if (this.dom.newLined) this.x(x) })\\n\\n      return this.attr('x', x)\\n    }\\n    // Move over y-axis\\n  , y: function(y) {\\n      var oy = this.attr('y')\\n        , o  = typeof oy === 'number' ? oy - this.bbox().y : 0\\n\\n      // act as getter\\n      if (y == null)\\n        return typeof oy === 'number' ? oy - o : oy\\n\\n      return this.attr('y', typeof y === 'number' ? y + o : y)\\n    }\\n    // Move center over x-axis\\n  , cx: function(x) {\\n      return x == null ? this.bbox().cx : this.x(x - this.bbox().width / 2)\\n    }\\n    // Move center over y-axis\\n  , cy: function(y) {\\n      return y == null ? this.bbox().cy : this.y(y - this.bbox().height / 2)\\n    }\\n    // Set the text content\\n  , text: function(text) {\\n      // act as getter\\n      if (typeof text === 'undefined'){\\n        var text = ''\\n        var children = this.node.childNodes\\n        for(var i = 0, len = children.length; i < len; ++i){\\n\\n          // add newline if its not the first child and newLined is set to true\\n          if(i != 0 && children[i].nodeType != 3 && SVG.adopt(children[i]).dom.newLined == true){\\n            text += '\\\\n'\\n          }\\n\\n          // add content of this node\\n          text += children[i].textContent\\n        }\\n\\n        return text\\n      }\\n\\n      // remove existing content\\n      this.clear().build(true)\\n\\n      if (typeof text === 'function') {\\n        // call block\\n        text.call(this, this)\\n\\n      } else {\\n        // store text and make sure text is not blank\\n        text = text.split('\\\\n')\\n\\n        // build new lines\\n        for (var i = 0, il = text.length; i < il; i++)\\n          this.tspan(text[i]).newLine()\\n      }\\n\\n      // disable build mode and rebuild lines\\n      return this.build(false).rebuild()\\n    }\\n    // Set font size\\n  , size: function(size) {\\n      return this.attr('font-size', size).rebuild()\\n    }\\n    // Set / get leading\\n  , leading: function(value) {\\n      // act as getter\\n      if (value == null)\\n        return this.dom.leading\\n\\n      // act as setter\\n      this.dom.leading = new SVG.Number(value)\\n\\n      return this.rebuild()\\n    }\\n    // Get all the first level lines\\n  , lines: function() {\\n      var node = (this.textPath && this.textPath() || this).node\\n\\n      // filter tspans and map them to SVG.js instances\\n      var lines = SVG.utils.map(SVG.utils.filterSVGElements(node.childNodes), function(el){\\n        return SVG.adopt(el)\\n      })\\n\\n      // return an instance of SVG.set\\n      return new SVG.Set(lines)\\n    }\\n    // Rebuild appearance type\\n  , rebuild: function(rebuild) {\\n      // store new rebuild flag if given\\n      if (typeof rebuild == 'boolean')\\n        this._rebuild = rebuild\\n\\n      // define position of all lines\\n      if (this._rebuild) {\\n        var self = this\\n          , blankLineOffset = 0\\n          , dy = this.dom.leading * new SVG.Number(this.attr('font-size'))\\n\\n        this.lines().each(function() {\\n          if (this.dom.newLined) {\\n            if (!this.textPath)\\n              this.attr('x', self.attr('x'))\\n\\n            if(this.text() == '\\\\n') {\\n              blankLineOffset += dy\\n            }else{\\n              this.attr('dy', dy + blankLineOffset)\\n              blankLineOffset = 0\\n            }\\n          }\\n        })\\n\\n        this.fire('rebuild')\\n      }\\n\\n      return this\\n    }\\n    // Enable / disable build mode\\n  , build: function(build) {\\n      this._build = !!build\\n      return this\\n    }\\n    // overwrite method from parent to set data properly\\n  , setData: function(o){\\n      this.dom = o\\n      this.dom.leading = new SVG.Number(o.leading || 1.3)\\n      return this\\n    }\\n  }\\n\\n  // Add parent method\\n, construct: {\\n    // Create text element\\n    text: function(text) {\\n      return this.put(new SVG.Text).text(text)\\n    }\\n    // Create plain text element\\n  , plain: function(text) {\\n      return this.put(new SVG.Text).plain(text)\\n    }\\n  }\\n\\n})\\n\\nSVG.Tspan = SVG.invent({\\n  // Initialize node\\n  create: 'tspan'\\n\\n  // Inherit from\\n, inherit: SVG.Shape\\n\\n  // Add class methods\\n, extend: {\\n    // Set text content\\n    text: function(text) {\\n      if(text == null) return this.node.textContent + (this.dom.newLined ? '\\\\n' : '')\\n\\n      typeof text === 'function' ? text.call(this, this) : this.plain(text)\\n\\n      return this\\n    }\\n    // Shortcut dx\\n  , dx: function(dx) {\\n      return this.attr('dx', dx)\\n    }\\n    // Shortcut dy\\n  , dy: function(dy) {\\n      return this.attr('dy', dy)\\n    }\\n    // Create new line\\n  , newLine: function() {\\n      // fetch text parent\\n      var t = this.parent(SVG.Text)\\n\\n      // mark new line\\n      this.dom.newLined = true\\n\\n      // apply new hy\u00a1n\\n      return this.dy(t.dom.leading * t.attr('font-size')).attr('x', t.x())\\n    }\\n  }\\n\\n})\\n\\nSVG.extend(SVG.Text, SVG.Tspan, {\\n  // Create plain text node\\n  plain: function(text) {\\n    // clear if build mode is disabled\\n    if (this._build === false)\\n      this.clear()\\n\\n    // create text node\\n    this.node.appendChild(document.createTextNode(text))\\n\\n    return this\\n  }\\n  // Create a tspan\\n, tspan: function(text) {\\n    var node  = (this.textPath && this.textPath() || this).node\\n      , tspan = new SVG.Tspan\\n\\n    // clear if build mode is disabled\\n    if (this._build === false)\\n      this.clear()\\n\\n    // add new tspan\\n    node.appendChild(tspan.node)\\n\\n    return tspan.text(text)\\n  }\\n  // Clear all lines\\n, clear: function() {\\n    var node = (this.textPath && this.textPath() || this).node\\n\\n    // remove existing child nodes\\n    while (node.hasChildNodes())\\n      node.removeChild(node.lastChild)\\n\\n    return this\\n  }\\n  // Get length of text element\\n, length: function() {\\n    return this.node.getComputedTextLength()\\n  }\\n})\\n\\nSVG.TextPath = SVG.invent({\\n  // Initialize node\\n  create: 'textPath'\\n\\n  // Inherit from\\n, inherit: SVG.Parent\\n\\n  // Define parent class\\n, parent: SVG.Text\\n\\n  // Add parent method\\n, construct: {\\n    // Create path for text to run on\\n    path: function(d) {\\n      // create textPath element\\n      var path  = new SVG.TextPath\\n        , track = this.doc().defs().path(d)\\n\\n      // move lines to textpath\\n      while (this.node.hasChildNodes())\\n        path.node.appendChild(this.node.firstChild)\\n\\n      // add textPath element as child node\\n      this.node.appendChild(path.node)\\n\\n      // link textPath to path and add content\\n      path.attr('href', '#' + track, SVG.xlink)\\n\\n      return this\\n    }\\n    // Plot path if any\\n  , plot: function(d) {\\n      var track = this.track()\\n\\n      if (track)\\n        track.plot(d)\\n\\n      return this\\n    }\\n    // Get the path track element\\n  , track: function() {\\n      var path = this.textPath()\\n\\n      if (path)\\n        return path.reference('href')\\n    }\\n    // Get the textPath child\\n  , textPath: function() {\\n      if (this.node.firstChild && this.node.firstChild.nodeName == 'textPath')\\n        return SVG.adopt(this.node.firstChild)\\n    }\\n  }\\n})\\nSVG.Nested = SVG.invent({\\n  // Initialize node\\n  create: function() {\\n    this.constructor.call(this, SVG.create('svg'))\\n\\n    this.style('overflow', 'visible')\\n  }\\n\\n  // Inherit from\\n, inherit: SVG.Container\\n\\n  // Add parent method\\n, construct: {\\n    // Create nested svg document\\n    nested: function() {\\n      return this.put(new SVG.Nested)\\n    }\\n  }\\n})\\nSVG.A = SVG.invent({\\n  // Initialize node\\n  create: 'a'\\n\\n  // Inherit from\\n, inherit: SVG.Container\\n\\n  // Add class methods\\n, extend: {\\n    // Link url\\n    to: function(url) {\\n      return this.attr('href', url, SVG.xlink)\\n    }\\n    // Link show attribute\\n  , show: function(target) {\\n      return this.attr('show', target, SVG.xlink)\\n    }\\n    // Link target attribute\\n  , target: function(target) {\\n      return this.attr('target', target)\\n    }\\n  }\\n\\n  // Add parent method\\n, construct: {\\n    // Create a hyperlink element\\n    link: function(url) {\\n      return this.put(new SVG.A).to(url)\\n    }\\n  }\\n})\\n\\nSVG.extend(SVG.Element, {\\n  // Create a hyperlink element\\n  linkTo: function(url) {\\n    var link = new SVG.A\\n\\n    if (typeof url == 'function')\\n      url.call(link, link)\\n    else\\n      link.to(url)\\n\\n    return this.parent().put(link).put(this)\\n  }\\n\\n})\\nSVG.Marker = SVG.invent({\\n  // Initialize node\\n  create: 'marker'\\n\\n  // Inherit from\\n, inherit: SVG.Container\\n\\n  // Add class methods\\n, extend: {\\n    // Set width of element\\n    width: function(width) {\\n      return this.attr('markerWidth', width)\\n    }\\n    // Set height of element\\n  , height: function(height) {\\n      return this.attr('markerHeight', height)\\n    }\\n    // Set marker refX and refY\\n  , ref: function(x, y) {\\n      return this.attr('refX', x).attr('refY', y)\\n    }\\n    // Update marker\\n  , update: function(block) {\\n      // remove all content\\n      this.clear()\\n\\n      // invoke passed block\\n      if (typeof block == 'function')\\n        block.call(this, this)\\n\\n      return this\\n    }\\n    // Return the fill id\\n  , toString: function() {\\n      return 'url(#' + this.id() + ')'\\n    }\\n  }\\n\\n  // Add parent method\\n, construct: {\\n    marker: function(width, height, block) {\\n      // Create marker element in defs\\n      return this.defs().marker(width, height, block)\\n    }\\n  }\\n\\n})\\n\\nSVG.extend(SVG.Defs, {\\n  // Create marker\\n  marker: function(width, height, block) {\\n    // Set default viewbox to match the width and height, set ref to cx and cy and set orient to auto\\n    return this.put(new SVG.Marker)\\n      .size(width, height)\\n      .ref(width / 2, height / 2)\\n      .viewbox(0, 0, width, height)\\n      .attr('orient', 'auto')\\n      .update(block)\\n  }\\n\\n})\\n\\nSVG.extend(SVG.Line, SVG.Polyline, SVG.Polygon, SVG.Path, {\\n  // Create and attach markers\\n  marker: function(marker, width, height, block) {\\n    var attr = ['marker']\\n\\n    // Build attribute name\\n    if (marker != 'all') attr.push(marker)\\n    attr = attr.join('-')\\n\\n    // Set marker attribute\\n    marker = arguments[1] instanceof SVG.Marker ?\\n      arguments[1] :\\n      this.doc().marker(width, height, block)\\n\\n    return this.attr(attr, marker)\\n  }\\n\\n})\\n// Define list of available attributes for stroke and fill\\nvar sugar = {\\n  stroke: ['color', 'width', 'opacity', 'linecap', 'linejoin', 'miterlimit', 'dasharray', 'dashoffset']\\n, fill:   ['color', 'opacity', 'rule']\\n, prefix: function(t, a) {\\n    return a == 'color' ? t : t + '-' + a\\n  }\\n}\\n\\n// Add sugar for fill and stroke\\n;['fill', 'stroke'].forEach(function(m) {\\n  var i, extension = {}\\n\\n  extension[m] = function(o) {\\n    if (typeof o == 'undefined')\\n      return this\\n    if (typeof o == 'string' || SVG.Color.isRgb(o) || (o && typeof o.fill === 'function'))\\n      this.attr(m, o)\\n\\n    else\\n      // set all attributes from sugar.fill and sugar.stroke list\\n      for (i = sugar[m].length - 1; i >= 0; i--)\\n        if (o[sugar[m][i]] != null)\\n          this.attr(sugar.prefix(m, sugar[m][i]), o[sugar[m][i]])\\n\\n    return this\\n  }\\n\\n  SVG.extend(SVG.Element, SVG.FX, extension)\\n\\n})\\n\\nSVG.extend(SVG.Element, SVG.FX, {\\n  // Map rotation to transform\\n  rotate: function(d, cx, cy) {\\n    return this.transform({ rotation: d, cx: cx, cy: cy })\\n  }\\n  // Map skew to transform\\n, skew: function(x, y, cx, cy) {\\n    return arguments.length == 1  || arguments.length == 3 ?\\n      this.transform({ skew: x, cx: y, cy: cx }) :\\n      this.transform({ skewX: x, skewY: y, cx: cx, cy: cy })\\n  }\\n  // Map scale to transform\\n, scale: function(x, y, cx, cy) {\\n    return arguments.length == 1  || arguments.length == 3 ?\\n      this.transform({ scale: x, cx: y, cy: cx }) :\\n      this.transform({ scaleX: x, scaleY: y, cx: cx, cy: cy })\\n  }\\n  // Map translate to transform\\n, translate: function(x, y) {\\n    return this.transform({ x: x, y: y })\\n  }\\n  // Map flip to transform\\n, flip: function(a, o) {\\n    return this.transform({ flip: a, offset: o })\\n  }\\n  // Map matrix to transform\\n, matrix: function(m) {\\n    return this.attr('transform', new SVG.Matrix(m))\\n  }\\n  // Opacity\\n, opacity: function(value) {\\n    return this.attr('opacity', value)\\n  }\\n  // Relative move over x axis\\n, dx: function(x) {\\n    return this.x((this instanceof SVG.FX ? 0 : this.x()) + x, true)\\n  }\\n  // Relative move over y axis\\n, dy: function(y) {\\n    return this.y((this instanceof SVG.FX ? 0 : this.y()) + y, true)\\n  }\\n  // Relative move over x and y axes\\n, dmove: function(x, y) {\\n    return this.dx(x).dy(y)\\n  }\\n})\\n\\nSVG.extend(SVG.Rect, SVG.Ellipse, SVG.Circle, SVG.Gradient, SVG.FX, {\\n  // Add x and y radius\\n  radius: function(x, y) {\\n    var type = (this._target || this).type;\\n    return type == 'radial' || type == 'circle' ?\\n      this.attr('r', new SVG.Number(x)) :\\n      this.rx(x).ry(y == null ? x : y)\\n  }\\n})\\n\\nSVG.extend(SVG.Path, {\\n  // Get path length\\n  length: function() {\\n    return this.node.getTotalLength()\\n  }\\n  // Get point at length\\n, pointAt: function(length) {\\n    return this.node.getPointAtLength(length)\\n  }\\n})\\n\\nSVG.extend(SVG.Parent, SVG.Text, SVG.FX, {\\n  // Set font\\n  font: function(o) {\\n    for (var k in o)\\n      k == 'leading' ?\\n        this.leading(o[k]) :\\n      k == 'anchor' ?\\n        this.attr('text-anchor', o[k]) :\\n      k == 'size' || k == 'family' || k == 'weight' || k == 'stretch' || k == 'variant' || k == 'style' ?\\n        this.attr('font-'+ k, o[k]) :\\n        this.attr(k, o[k])\\n\\n    return this\\n  }\\n})\\n\\nSVG.Set = SVG.invent({\\n  // Initialize\\n  create: function(members) {\\n    // Set initial state\\n    Array.isArray(members) ? this.members = members : this.clear()\\n  }\\n\\n  // Add class methods\\n, extend: {\\n    // Add element to set\\n    add: function() {\\n      var i, il, elements = [].slice.call(arguments)\\n\\n      for (i = 0, il = elements.length; i < il; i++)\\n        this.members.push(elements[i])\\n\\n      return this\\n    }\\n    // Remove element from set\\n  , remove: function(element) {\\n      var i = this.index(element)\\n\\n      // remove given child\\n      if (i > -1)\\n        this.members.splice(i, 1)\\n\\n      return this\\n    }\\n    // Iterate over all members\\n  , each: function(block) {\\n      for (var i = 0, il = this.members.length; i < il; i++)\\n        block.apply(this.members[i], [i, this.members])\\n\\n      return this\\n    }\\n    // Restore to defaults\\n  , clear: function() {\\n      // initialize store\\n      this.members = []\\n\\n      return this\\n    }\\n    // Get the length of a set\\n  , length: function() {\\n      return this.members.length\\n    }\\n    // Checks if a given element is present in set\\n  , has: function(element) {\\n      return this.index(element) >= 0\\n    }\\n    // retuns index of given element in set\\n  , index: function(element) {\\n      return this.members.indexOf(element)\\n    }\\n    // Get member at given index\\n  , get: function(i) {\\n      return this.members[i]\\n    }\\n    // Get first member\\n  , first: function() {\\n      return this.get(0)\\n    }\\n    // Get last member\\n  , last: function() {\\n      return this.get(this.members.length - 1)\\n    }\\n    // Default value\\n  , valueOf: function() {\\n      return this.members\\n    }\\n    // Get the bounding box of all members included or empty box if set has no items\\n  , bbox: function(){\\n      var box = new SVG.BBox()\\n\\n      // return an empty box of there are no members\\n      if (this.members.length == 0)\\n        return box\\n\\n      // get the first rbox and update the target bbox\\n      var rbox = this.members[0].rbox()\\n      box.x      = rbox.x\\n      box.y      = rbox.y\\n      box.width  = rbox.width\\n      box.height = rbox.height\\n\\n      this.each(function() {\\n        // user rbox for correct position and visual representation\\n        box = box.merge(this.rbox())\\n      })\\n\\n      return box\\n    }\\n  }\\n\\n  // Add parent method\\n, construct: {\\n    // Create a new set\\n    set: function(members) {\\n      return new SVG.Set(members)\\n    }\\n  }\\n})\\n\\nSVG.FX.Set = SVG.invent({\\n  // Initialize node\\n  create: function(set) {\\n    // store reference to set\\n    this.set = set\\n  }\\n\\n})\\n\\n// Alias methods\\nSVG.Set.inherit = function() {\\n  var m\\n    , methods = []\\n\\n  // gather shape methods\\n  for(var m in SVG.Shape.prototype)\\n    if (typeof SVG.Shape.prototype[m] == 'function' && typeof SVG.Set.prototype[m] != 'function')\\n      methods.push(m)\\n\\n  // apply shape aliasses\\n  methods.forEach(function(method) {\\n    SVG.Set.prototype[method] = function() {\\n      for (var i = 0, il = this.members.length; i < il; i++)\\n        if (this.members[i] && typeof this.members[i][method] == 'function')\\n          this.members[i][method].apply(this.members[i], arguments)\\n\\n      return method == 'animate' ? (this.fx || (this.fx = new SVG.FX.Set(this))) : this\\n    }\\n  })\\n\\n  // clear methods for the next round\\n  methods = []\\n\\n  // gather fx methods\\n  for(var m in SVG.FX.prototype)\\n    if (typeof SVG.FX.prototype[m] == 'function' && typeof SVG.FX.Set.prototype[m] != 'function')\\n      methods.push(m)\\n\\n  // apply fx aliasses\\n  methods.forEach(function(method) {\\n    SVG.FX.Set.prototype[method] = function() {\\n      for (var i = 0, il = this.set.members.length; i < il; i++)\\n        this.set.members[i].fx[method].apply(this.set.members[i].fx, arguments)\\n\\n      return this\\n    }\\n  })\\n}\\n\\n\\n\\n\\nSVG.extend(SVG.Element, {\\n  // Store data values on svg nodes\\n  data: function(a, v, r) {\\n    if (typeof a == 'object') {\\n      for (v in a)\\n        this.data(v, a[v])\\n\\n    } else if (arguments.length < 2) {\\n      try {\\n        return JSON.parse(this.attr('data-' + a))\\n      } catch(e) {\\n        return this.attr('data-' + a)\\n      }\\n\\n    } else {\\n      this.attr(\\n        'data-' + a\\n      , v === null ?\\n          null :\\n        r === true || typeof v === 'string' || typeof v === 'number' ?\\n          v :\\n          JSON.stringify(v)\\n      )\\n    }\\n\\n    return this\\n  }\\n})\\nSVG.extend(SVG.Element, {\\n  // Remember arbitrary data\\n  remember: function(k, v) {\\n    // remember every item in an object individually\\n    if (typeof arguments[0] == 'object')\\n      for (var v in k)\\n        this.remember(v, k[v])\\n\\n    // retrieve memory\\n    else if (arguments.length == 1)\\n      return this.memory()[k]\\n\\n    // store memory\\n    else\\n      this.memory()[k] = v\\n\\n    return this\\n  }\\n\\n  // Erase a given memory\\n, forget: function() {\\n    if (arguments.length == 0)\\n      this._memory = {}\\n    else\\n      for (var i = arguments.length - 1; i >= 0; i--)\\n        delete this.memory()[arguments[i]]\\n\\n    return this\\n  }\\n\\n  // Initialize or return local memory object\\n, memory: function() {\\n    return this._memory || (this._memory = {})\\n  }\\n\\n})\\n// Method for getting an element by id\\nSVG.get = function(id) {\\n  var node = document.getElementById(idFromReference(id) || id)\\n  return SVG.adopt(node)\\n}\\n\\n// Select elements by query string\\nSVG.select = function(query, parent) {\\n  return new SVG.Set(\\n    SVG.utils.map((parent || document).querySelectorAll(query), function(node) {\\n      return SVG.adopt(node)\\n    })\\n  )\\n}\\n\\nSVG.extend(SVG.Parent, {\\n  // Scoped select method\\n  select: function(query) {\\n    return SVG.select(query, this.node)\\n  }\\n\\n})\\nfunction is(el, obj){\\n  return el instanceof obj\\n}\\n\\n// tests if a given selector matches an element\\nfunction matches(el, selector) {\\n  return (el.matches || el.matchesSelector || el.msMatchesSelector || el.mozMatchesSelector || el.webkitMatchesSelector || el.oMatchesSelector).call(el, selector);\\n}\\n\\n// Convert dash-separated-string to camelCase\\nfunction camelCase(s) {\\n  return s.toLowerCase().replace(/-(.)/g, function(m, g) {\\n    return g.toUpperCase()\\n  })\\n}\\n\\n// Capitalize first letter of a string\\nfunction capitalize(s) {\\n  return s.charAt(0).toUpperCase() + s.slice(1)\\n}\\n\\n// Ensure to six-based hex\\nfunction fullHex(hex) {\\n  return hex.length == 4 ?\\n    [ '#',\\n      hex.substring(1, 2), hex.substring(1, 2)\\n    , hex.substring(2, 3), hex.substring(2, 3)\\n    , hex.substring(3, 4), hex.substring(3, 4)\\n    ].join('') : hex\\n}\\n\\n// Component to hex value\\nfunction compToHex(comp) {\\n  var hex = comp.toString(16)\\n  return hex.length == 1 ? '0' + hex : hex\\n}\\n\\n// Calculate proportional width and height values when necessary\\nfunction proportionalSize(element, width, height) {\\n  if (width == null || height == null) {\\n    var box = element.bbox()\\n\\n    if (width == null)\\n      width = box.width / box.height * height\\n    else if (height == null)\\n      height = box.height / box.width * width\\n  }\\n\\n  return {\\n    width:  width\\n  , height: height\\n  }\\n}\\n\\n// Delta transform point\\nfunction deltaTransformPoint(matrix, x, y) {\\n  return {\\n    x: x * matrix.a + y * matrix.c + 0\\n  , y: x * matrix.b + y * matrix.d + 0\\n  }\\n}\\n\\n// Map matrix array to object\\nfunction arrayToMatrix(a) {\\n  return { a: a[0], b: a[1], c: a[2], d: a[3], e: a[4], f: a[5] }\\n}\\n\\n// Parse matrix if required\\nfunction parseMatrix(matrix) {\\n  if (!(matrix instanceof SVG.Matrix))\\n    matrix = new SVG.Matrix(matrix)\\n\\n  return matrix\\n}\\n\\n// Add centre point to transform object\\nfunction ensureCentre(o, target) {\\n  o.cx = o.cx == null ? target.bbox().cx : o.cx\\n  o.cy = o.cy == null ? target.bbox().cy : o.cy\\n}\\n\\n// Convert string to matrix\\nfunction stringToMatrix(source) {\\n  // remove matrix wrapper and split to individual numbers\\n  source = source\\n    .replace(SVG.regex.whitespace, '')\\n    .replace(SVG.regex.matrix, '')\\n    .split(SVG.regex.matrixElements)\\n\\n  // convert string values to floats and convert to a matrix-formatted object\\n  return arrayToMatrix(\\n    SVG.utils.map(source, function(n) {\\n      return parseFloat(n)\\n    })\\n  )\\n}\\n\\n// Calculate position according to from and to\\nfunction at(o, pos) {\\n  // number recalculation (don't bother converting to SVG.Number for performance reasons)\\n  return typeof o.from == 'number' ?\\n    o.from + (o.to - o.from) * pos :\\n\\n  // instance recalculation\\n  o instanceof SVG.Color || o instanceof SVG.Number || o instanceof SVG.Matrix ? o.at(pos) :\\n\\n  // for all other values wait until pos has reached 1 to return the final value\\n  pos < 1 ? o.from : o.to\\n}\\n\\n// PathArray Helpers\\nfunction arrayToString(a) {\\n  for (var i = 0, il = a.length, s = ''; i < il; i++) {\\n    s += a[i][0]\\n\\n    if (a[i][1] != null) {\\n      s += a[i][1]\\n\\n      if (a[i][2] != null) {\\n        s += ' '\\n        s += a[i][2]\\n\\n        if (a[i][3] != null) {\\n          s += ' '\\n          s += a[i][3]\\n          s += ' '\\n          s += a[i][4]\\n\\n          if (a[i][5] != null) {\\n            s += ' '\\n            s += a[i][5]\\n            s += ' '\\n            s += a[i][6]\\n\\n            if (a[i][7] != null) {\\n              s += ' '\\n              s += a[i][7]\\n            }\\n          }\\n        }\\n      }\\n    }\\n  }\\n\\n  return s + ' '\\n}\\n\\n// Deep new id assignment\\nfunction assignNewId(node) {\\n  // do the same for SVG child nodes as well\\n  for (var i = node.childNodes.length - 1; i >= 0; i--)\\n    if (node.childNodes[i] instanceof SVGElement)\\n      assignNewId(node.childNodes[i])\\n\\n  return SVG.adopt(node).id(SVG.eid(node.nodeName))\\n}\\n\\n// Add more bounding box properties\\nfunction fullBox(b) {\\n  if (b.x == null) {\\n    b.x      = 0\\n    b.y      = 0\\n    b.width  = 0\\n    b.height = 0\\n  }\\n\\n  b.w  = b.width\\n  b.h  = b.height\\n  b.x2 = b.x + b.width\\n  b.y2 = b.y + b.height\\n  b.cx = b.x + b.width / 2\\n  b.cy = b.y + b.height / 2\\n\\n  return b\\n}\\n\\n// Get id from reference string\\nfunction idFromReference(url) {\\n  var m = url.toString().match(SVG.regex.reference)\\n\\n  if (m) return m[1]\\n}\\n\\n// Create matrix array for looping\\nvar abcdef = 'abcdef'.split('')\\n// Add CustomEvent to IE9 and IE10\\nif (typeof CustomEvent !== 'function') {\\n  // Code from: https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent\\n  var CustomEvent = function(event, options) {\\n    options = options || { bubbles: false, cancelable: false, detail: undefined }\\n    var e = document.createEvent('CustomEvent')\\n    e.initCustomEvent(event, options.bubbles, options.cancelable, options.detail)\\n    return e\\n  }\\n\\n  CustomEvent.prototype = window.Event.prototype\\n\\n  window.CustomEvent = CustomEvent\\n}\\n\\n// requestAnimationFrame / cancelAnimationFrame Polyfill with fallback based on Paul Irish\\n(function(w) {\\n  var lastTime = 0\\n  var vendors = ['moz', 'webkit']\\n\\n  for(var x = 0; x < vendors.length && !window.requestAnimationFrame; ++x) {\\n    w.requestAnimationFrame = w[vendors[x] + 'RequestAnimationFrame']\\n    w.cancelAnimationFrame  = w[vendors[x] + 'CancelAnimationFrame'] ||\\n                              w[vendors[x] + 'CancelRequestAnimationFrame']\\n  }\\n\\n  w.requestAnimationFrame = w.requestAnimationFrame ||\\n    function(callback) {\\n      var currTime = new Date().getTime()\\n      var timeToCall = Math.max(0, 16 - (currTime - lastTime))\\n\\n      var id = w.setTimeout(function() {\\n        callback(currTime + timeToCall)\\n      }, timeToCall)\\n\\n      lastTime = currTime + timeToCall\\n      return id\\n    }\\n\\n  w.cancelAnimationFrame = w.cancelAnimationFrame || w.clearTimeout;\\n\\n}(window))\\n\\nreturn SVG\\n\\n}));\\n\",\"x\":510,\"y\":1760,\"wires\":[[\"e21a4cb3.4b8f98\"]]},{\"id\":\"e21a4cb3.4b8f98\",\"type\":\"template\",\"z\":\"b0ed7852.d58f08\",\"name\":\"draggable\",\"field\":\"payload.draggable\",\"fieldType\":\"msg\",\"format\":\"handlebars\",\"syntax\":\"mustache\",\"template\":\";(function() {\\n\\n  // creates handler, saves it\\n  function DragHandler(el){\\n    el.remember('_draggable', this)\\n    this.el = el\\n  }\\n\\n\\n  // Sets new parameter, starts dragging\\n  DragHandler.prototype.init = function(constraint, val){\\n    var _this = this\\n    this.constraint = constraint\\n    this.value = val\\n    this.el.on('mousedown.drag', function(e){ _this.start(e) })\\n    this.el.on('touchstart.drag', function(e){ _this.start(e) })\\n  }\\n\\n  // transforms one point from screen to user coords\\n  DragHandler.prototype.transformPoint = function(event, offset){\\n      event = event || window.event\\n      var touches = event.changedTouches && event.changedTouches[0] || event\\n      this.p.x = touches.pageX - (offset || 0)\\n      this.p.y = touches.pageY\\n      return this.p.matrixTransform(this.m)\\n  }\\n\\n  // gets elements bounding box with special handling of groups, nested and use\\n  DragHandler.prototype.getBBox = function(){\\n\\n    var box = this.el.bbox()\\n\\n    if(this.el instanceof SVG.Nested) box = this.el.rbox()\\n\\n    if (this.el instanceof SVG.G || this.el instanceof SVG.Use || this.el instanceof SVG.Nested) {\\n      box.x = this.el.x()\\n      box.y = this.el.y()\\n    }\\n\\n    return box\\n  }\\n\\n  // start dragging\\n  DragHandler.prototype.start = function(e){\\n\\n    // check for left button\\n    if(e.type == 'click'|| e.type == 'mousedown' || e.type == 'mousemove'){\\n      if((e.which || e.buttons) != 1){\\n          return\\n      }\\n    }\\n\\n    var _this = this\\n\\n    // fire beforedrag event\\n    this.el.fire('beforedrag', { event: e, handler: this })\\n\\n    // search for parent on the fly to make sure we can call\\n    // draggable() even when element is not in the dom currently\\n    this.parent = this.parent || this.el.parent(SVG.Nested) || this.el.parent(SVG.Doc)\\n    this.p = this.parent.node.createSVGPoint()\\n\\n    // save current transformation matrix\\n    this.m = this.el.node.getScreenCTM().inverse()\\n\\n    var box = this.getBBox()\\n\\n    var anchorOffset;\\n\\n    // fix text-anchor in text-element (#37)\\n    if(this.el instanceof SVG.Text){\\n      anchorOffset = this.el.node.getComputedTextLength();\\n\\n      switch(this.el.attr('text-anchor')){\\n        case 'middle':\\n          anchorOffset /= 2;\\n          break\\n        case 'start':\\n          anchorOffset = 0;\\n          break;\\n      }\\n    }\\n\\n    this.startPoints = {\\n      // We take absolute coordinates since we are just using a delta here\\n      point: this.transformPoint(e, anchorOffset),\\n      box:   box,\\n      transform: this.el.transform()\\n    }\\n\\n    // add drag and end events to window\\n    SVG.on(window, 'mousemove.drag', function(e){ _this.drag(e) })\\n    SVG.on(window, 'touchmove.drag', function(e){ _this.drag(e) })\\n    SVG.on(window, 'mouseup.drag', function(e){ _this.end(e) })\\n    SVG.on(window, 'touchend.drag', function(e){ _this.end(e) })\\n\\n    // fire dragstart event\\n    this.el.fire('dragstart', {event: e, p: this.startPoints.point, m: this.m, handler: this})\\n\\n    // prevent browser drag behavior\\n    e.preventDefault()\\n\\n    // prevent propagation to a parent that might also have dragging enabled\\n    e.stopPropagation();\\n  }\\n\\n  // while dragging\\n  DragHandler.prototype.drag = function(e){\\n\\n    var box = this.getBBox()\\n      , p   = this.transformPoint(e)\\n      , x   = this.startPoints.box.x + p.x - this.startPoints.point.x\\n      , y   = this.startPoints.box.y + p.y - this.startPoints.point.y\\n      , c   = this.constraint\\n      , gx  = p.x - this.startPoints.point.x\\n      , gy  = p.y - this.startPoints.point.y\\n\\n    var event = new CustomEvent('dragmove', {\\n        detail: {\\n            event: e\\n          , p: p\\n          , m: this.m\\n          , handler: this\\n        }\\n      , cancelable: true\\n    })\\n\\n    this.el.fire(event)\\n\\n    if(event.defaultPrevented) return p\\n\\n    // move the element to its new position, if possible by constraint\\n    if (typeof c == 'function') {\\n\\n      var coord = c.call(this.el, x, y, this.m)\\n\\n      // bool, just show us if movement is allowed or not\\n      if (typeof coord == 'boolean') {\\n        coord = {\\n          x: coord,\\n          y: coord\\n        }\\n      }\\n\\n      // if true, we just move. If !false its a number and we move it there\\n      if (coord.x === true) {\\n        this.el.x(x)\\n      } else if (coord.x !== false) {\\n        this.el.x(coord.x)\\n      }\\n\\n      if (coord.y === true) {\\n        this.el.y(y)\\n      } else if (coord.y !== false) {\\n        this.el.y(coord.y)\\n      }\\n\\n    } else if (typeof c == 'object') {\\n\\n      // keep element within constrained box\\n      if (c.minX != null && x < c.minX)\\n        x = c.minX\\n      else if (c.maxX != null && x > c.maxX - box.width){\\n        x = c.maxX - box.width\\n      }if (c.minY != null && y < c.minY)\\n        y = c.minY\\n      else if (c.maxY != null && y > c.maxY - box.height)\\n        y = c.maxY - box.height\\n\\n      if(this.el instanceof SVG.G)\\n        this.el.matrix(this.startPoints.transform).transform({x:gx, y: gy}, true)\\n      else\\n        this.el.move(x, y)\\n    }\\n\\n    // so we can use it in the end-method, too\\n    return p\\n  }\\n\\n  DragHandler.prototype.end = function(e){\\n\\n    // final drag\\n    var p = this.drag(e);\\n\\n    // fire dragend event\\n    this.el.fire('dragend', { event: e, p: p, m: this.m, handler: this })\\n\\n    // unbind events\\n    SVG.off(window, 'mousemove.drag')\\n    SVG.off(window, 'touchmove.drag')\\n    SVG.off(window, 'mouseup.drag')\\n    SVG.off(window, 'touchend.drag')\\n\\n  }\\n\\n  SVG.extend(SVG.Element, {\\n    // Make element draggable\\n    // Constraint might be an object (as described in readme.md) or a function in the form \\\"function (x, y)\\\" that gets called before every move.\\n    // The function can return a boolean or an object of the form {x, y}, to which the element will be moved. \\\"False\\\" skips moving, true moves to raw x, y.\\n    draggable: function(value, constraint) {\\n\\n      // Check the parameters and reassign if needed\\n      if (typeof value == 'function' || typeof value == 'object') {\\n        constraint = value\\n        value = true\\n      }\\n\\n      var dragHandler = this.remember('_draggable') || new DragHandler(this)\\n\\n      // When no parameter is given, value is true\\n      value = typeof value === 'undefined' ? true : value\\n\\n      if(value) dragHandler.init(constraint || {}, value)\\n      else {\\n        this.off('mousedown.drag')\\n        this.off('touchstart.drag')\\n      }\\n\\n      return this\\n    }\\n\\n  })\\n\\n}).call(this);\\n\",\"x\":640,\"y\":1760,\"wires\":[[\"806e2715.ce426\"]]}]\n\n\n\n\n\n\u300ctest514.html\u3092\u8fd4\u3059\u300d\u30c6\u30f3\u30d7\u30ec\u30fc\u30c8\u30ce\u30fc\u30c9\u306e149\u884c\u76ee\u306evar connection = new WebSocket('wss://\u3053\u306eIoT\u30a2\u30d7\u30ea\u306e\u540d\u524d.mybluemix.net/wss/flow514');\u3092\u30a2\u30d7\u30ea\u540d\u306b\u5408\u308f\u305b\u3066\u5909\u66f4\u3057\u307e\u3059\n\u8868\u793a\u3055\u308c\u305f\u753b\u9762\u53f3\u4e0a\u306e\u7dd1\u306e\u4e38\u30a2\u30a4\u30b3\u30f3\u3092\u30c9\u30e9\u30c3\u30b0\uff06\u30c9\u30ed\u30c3\u30d7\u3057\u3066\u30bb\u30f3\u30b5\u30fc\u304c\u8a2d\u7f6e\u3055\u308c\u305f\u5834\u6240\u306b\u7f6e\u304d\u307e\u3059\u3002\u3053\u306e\u4f8b\u3067\u306f\u7167\u5ea6\u306b\u5fdc\u3058\u3066\u4e38\u30a2\u30a4\u30b3\u30f3\u306e\u8272\u3092\u5909\u5316\u3055\u305b\u3066\u3044\u307e\u3059\n\n\n\u521d\u3081\u3066Watson IoT Platform\u3092\u4f7f\u3063\u3066\u307f\u3088\u3046\u3001\u3068\u3044\u3046\u304b\u305f\u306e\u305f\u3081\u306e\u30ac\u30a4\u30c9\u3067\u3059\u3002\n[Watson IoT Platform\u3092\u4f7f\u3063\u3066\u307f\u308b](http://qiita.com/egplnt/items/af867711a7191923b2ff)\u3067IoT\u30a2\u30d7\u30ea\u3092\u6e96\u5099\u3057\u307e\u3057\u305f\u3002\n[IoT\u30c0\u30c3\u30b7\u30e5\u30dc\u30fc\u30c9\u3092\u4f5c\u3063\u3066\u307f\u308b](http://qiita.com/egplnt/items/141bd5d9b17ba02e526b)\u3067IoT\u30c7\u30fc\u30bf\u3092\u53ef\u8996\u5316\u3059\u308b\u30c0\u30c3\u30b7\u30e5\u30dc\u30fc\u30c9\u3092\u4f5c\u3063\u3066\u3044\u304d\u307e\u3059\u3002\n\n# Drag & drop\u3067\u304d\u308b\u30bb\u30f3\u30b5\u30fc\u3092\u7d75\u306b\u8ffd\u52a0\u3057\u3001\u30ea\u30a2\u30eb\u30bf\u30a4\u30e0\u306e\u30bb\u30f3\u30b5\u30fc\u5024\u306b\u5fdc\u3058\u3066\u8272\u3092\u5909\u5316\u3055\u305b\u307e\u3059\n- \u4e0b\u8a18\u306e\u30d5\u30ed\u30fc\u3092\u30b3\u30d4\u30da\u3057\u307e\u3059\n![\u30b9\u30af\u30ea\u30fc\u30f3\u30b7\u30e7\u30c3\u30c8 2017-02-17 10.58.04.png](https://qiita-image-store.s3.amazonaws.com/0/125842/ae298ef1-47aa-e3e1-aaf5-70f702d8852c.png)\n\n\n```lang:\u30bb\u30f3\u30b5\u30fc\u3092\u8ffd\u52a0\u3057\u30ea\u30a2\u30eb\u30bf\u30a4\u30e0\u306e\u5024\u306b\u5fdc\u3058\u3066\u8272\u3092\u5909\u5316\n[{\"id\":\"76358274.bcd864\",\"type\":\"template\",\"z\":\"b0ed7852.d58f08\",\"name\":\"background picture\",\"field\":\"payload.background.picture\",\"fieldType\":\"msg\",\"format\":\"handlebars\",\"syntax\":\"mustache\",\"template\":\"data:image/gif;base64,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\",\"x\":350,\"y\":1760,\"wires\":[[\"b941211b.290f28\"]]},{\"id\":\"c900afe6.93d18\",\"type\":\"template\",\"z\":\"b0ed7852.d58f08\",\"name\":\"test514.html\u3092\u8fd4\u3059\",\"field\":\"payload\",\"fieldType\":\"msg\",\"format\":\"handlebars\",\"syntax\":\"mustache\",\"template\":\"<!DOCTYPE HTML>\\n<html>\\n\u3000<head>\\n\u3000\u3000<title>\u30bb\u30f3\u30b5\u30fc\u304b\u3089\u306e\u60c5\u5831\u3092\u8868\u793a</title>\\n\u3000\u3000<meta charset=\\\"utf-8\\\" />\\n<script type=\\\"text/javascript\\\" src=\\\"https://www.google.com/jsapi\\\"></script>\\n<script type=\\\"test/javascript\\\" src=\\\"https://www.gstatic.com/charts/loader.js\\\"></script>\\n\\n\\n<style type=\\\"text/css\\\">\\n  {{{payload.css}}}\\n</style>\\n</head>\\n<body>\\n\\n  <div id='basic' align=\\\"center\\\">\\n\\n    <div id='a1' align=\\\"left\\\">\\n      <h2>IoT Sample Dashboard</h2>\\n      IoT\u30c7\u30fc\u30bf\u3092\u30ea\u30a2\u30eb\u30bf\u30a4\u30e0\u3067\u53ef\u8996\u5316\u3057\u307e\u3059\\n    </div>\\n    <div id='b1' align=\\\"left\\\">\\n      b1\\n    </div>\\n    <div id='c1'>\\n      c1\\n    </div>\\n    <div id='c2'>\\n      c2\\n    </div>\\n    <div id='c3'>\\n      <svg id=\\\"svg.svg\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\" width=\\\"723\\\" height=\\\"500\\\" viewBox=\\\"0 0 723 500\\\">\\n      </svg>\\n    </div>\\n    <div id ='c4'>\\n      c4\\n    </div>\\n    <div id ='c5'>\\n      c5\\n    </div>\\n    <div id ='c6'>\\n      c6\\n    </div>\\n\\n    <div id='d1'>\\n      d1\\n    </div>\\n    <div id='d2'>\\n      d2\\n    </div>\\n    <div id='d3'>\\n      d3\\n    </div>\\n\\n    <div id='e1' align=\\\"left\\\">\\n      <h2 style=\\\"margin-left:10px;\\\">\u7167\u5ea6</h2>\\n        <span style=\\\"text-align:left; font-size:18pt; margin-left:100px;\\\" id=\\\"e1data\\\"></span>lux\\n    </div>\\n    <div id='e2'>\\n      e2\\n    </div>\\n    <div id='e3'>\\n      e3\\n    </div>\\n\\n    <div id='f1'>\\n      f1\\n    </div>\\n    <div id='f2'>\\n      f2\\n    </div>\\n    <div id='f3'>\\n      f3\\n    </div>\\n    <div id='h1' >\\n      h1\\n    </div>\\n    <div id='h2'>\\n      h2\\n    </div>\\n    <div id='h3'>\\n      h3\\n    </div>\\n\\n    <div id='j1'>\\n      j1\\n    </div>\\n    <div id='j2'>\\n      j2\\n    </div>\\n    <div id='j3'>\\n      j3\\n    </div>\\n\\n    <div id='k1' >\\n      k1\\n    </div>\\n    <div id='k2'>\\n      k2\\n    </div>\\n    <div id='k3'>\\n      k3\\n    </div>\\n\\n    <div id='m1'>\\n      m1\\n    </div>\\n    <div id='m2'>\\n      m2\\n    </div>\\n    <div id='m3'>\\n      m3\\n    </div>\\n\\n    <div id='v1' align=\\\"left\\\">\\n      <h2 style=\\\"margin-left:10px;\\\">\u30a2\u30e9\u30fc\u30c8</h2>\\n      <span style=\\\"text-align: left;font-size:18pt; margin-left:100px;\\\" id=\\\"alerttext\\\"></span>\\n    </div>\\n\\n    <div id='x1' align=\\\"left\\\">\\n      x1\\n    </div>\\n\\n<div id=\\\"y1\\\" align=\\\"left\\\">\\n  \u53c2\u8003URL\\n  <ul>\\n    <li><a href=\\\"http://qiita.com/egplnt/items/af867711a7191923b2ff\\\">Watson IoT Platform\u3092\u4f7f\u3063\u3066\u307f\u308b</a></li>\\n    <li><a href=\\\"https://internetofthings.ibmcloud.com/#/\\\">Watson IoT Platform</a></li>\\n    <li><a href=\\\"https://developer.ibm.com/recipes/tutorials/use-the-simulated-device-to-experience-the-iot-foundation/\\\">Recipe - Simulator</a></li>\\n  </ul>\\n  \u30de\u30cb\u30e5\u30a2\u30eb\\n  <ul>\\n    <li><a href=\\\"http://ibm.com/iot\\\">IBM IoT</a></li>\\n    <li><a href=\\\"https://docs.internetofthings.ibmcloud.com/ja/\\\">Watson IoT Platform\u8cc7\u6599\u30da\u30fc\u30b8</a></li>\\n    <li><a href=\\\"https://developer.ibm.com/recipes/\\\">Recipe</a></li>\\n  </ul>\\n</div>\\n\\n<div id=\\\"z1\\\">\\n\\tcopyright (c) abc.com All rights reserved.\\n</div>\\n</div>\\n\\n\\n<script>\\n{{{payload.svg}}}\\n{{{payload.draggable}}}\\n\\nvar connection = new WebSocket('wss://\u3053\u306eIoT\u30a2\u30d7\u30ea\u306e\u540d\u524d.mybluemix.net/wss/flow514');\\nvar draw = SVG('svg.svg').size(723, 500);\\nvar circle1 = draw.circle(45).attr({'fill':'green'}).x(650).y(100).draggable();\\n\\nconnection.onopen = function () {\\n  console.log(\\\"websocket connected\\\");\\n};\\n\\nconnection.onerror = function (error) {\\n  console.log('WebSocket Error ' + error);\\n};\\n\\nconnection.onmessage = function (m) {\\n\\tdoIt(m);\\n};\\n\\n// \u30b2\u30fc\u30b8\u3068\u30e9\u30a4\u30f3\u30c1\u30e3\u30fc\u30c8\u3092\u6e96\u5099\\n// \u30e9\u30a4\u30f3\u30c1\u30e3\u30fc\u30c8\u306eAPI\u306f\u3000https://developers.google.com/chart/interactive/docs/reference\\ngoogle.load('visualization', '1', {packages:['gauge', 'corechart']});\\ngoogle.setOnLoadCallback(drawChart);\\n\\nfunction drawChart() {\\n\\td1GaugeData = google.visualization.arrayToDataTable([\\n\\t\\t['Label', 'Value'],\\n\\t\\t['\u7167\u5ea6', 0]\\n\\t]);\\n  d1GaugeOptions = {\\n\\t\\twidth: 500, height: 150,\\n\\t\\tmin: 0, max: 500,\\n\\t\\tyellowFrom:300, yellowTo: 400,\\n    redFrom: 400, redTo: 500,\\n\\t\\tminorTicks: 5\\n\\t};\\n  d1Gauge = new google.visualization.Gauge(document.getElementById('d1'));\\n\\td1Gauge.draw(d1GaugeData, d1GaugeOptions);\\n\\n\\n  f1ChartData = google.visualization.arrayToDataTable(\\n    [[\\\"\u6642\u523b\\\",\\\"\u7167\u5ea6\\\"],['10:00:00',300]] );\\n  f1ChartData.removeRow(0);\\n  f1ChartOptions = {\u3000title: '\u7167\u5ea6',\\n    legend: { position: 'bottom' },\\n    backgroundColor: {stroke:'#c1d8ac' ,strokeWidth:10, fill:'#ffffff'}\\n  };\\n  f1Chart = new google.visualization.LineChart(document.getElementById('f1'));\\n  f1Chart.draw(f1ChartData, f1ChartOptions);\\n\\n};\\n\\n//websocket\u304b\u3089\u306e\u6bce\u79d2\u306e\u30c7\u30fc\u30bf\u3092\u53d7\u4fe1\u3057\u3066\u30b2\u30fc\u30b8\u30fb\u30c1\u30e3\u30fc\u30c8\u3078\u8868\u793a\u3059\u308b\\nfunction doIt(msg){\\n  console.log(\\\"doit:\\\" + msg.data);\\n\\tvar msgs = JSON.parse(msg.data);\\n\\n  // msgs[4]\u306f\u4e8c\u91cd\u914d\u5217\u306a\u306e\u3067\\\"msgs[4][0]\\\"\u3067\u6e29\u5ea6\u306e\u5024\u3092\u53d6\u308a\u51fa\u3057\u3066\u30ea\u30a2\u30eb\u30bf\u30a4\u30e0\u8868\u793a\u3059\u308b\\n  d1GaugeData = google.visualization.arrayToDataTable([\\n    ['Label', 'Value'],\\n    ['\u7167\u5ea6', msgs[4][0]]\\n  ]);\\n  d1Gauge.draw(d1GaugeData, d1GaugeOptions);\\n  console.log(\\\"msgs[4][0] = \\\" + msgs[4][0]);\\n\\n  f1ChartData.addRow( [ msgs[0][0], msgs[4][0] ] );\\n  if ( f1ChartData.getNumberOfRows() > 9) {\\n    f1ChartData.removeRow(0);\\n  }\\n  f1Chart.draw(f1ChartData, f1ChartOptions);\\n\\n  (function(){\\n    var c1t = parseInt(msgs[4]);\\n    if ( c1t > 400) {\\n      circle1.attr({'fill':'red'});\\n    } else if ( c1t > 300 ){\\n      circle1.attr({'fill':\\\"yellow\\\"});\\n    } else {\\n      circle1.attr({'fill':\\\"green\\\"});\\n    }\\n  })();\\n\\n\\t// \u5404\u30bb\u30f3\u30b5\u30fc\u8981\u7d20\u3092\u53d6\u308a\u51fa\u3057\u3066\u3001\u753b\u9762\u3078\u8868\u793a\\n  target = document.getElementById(\\\"e1data\\\"); // \u7167\u5ea6 e1\u306b\u8868\u793a\\n\\ttarget.innerHTML = msgs[4];\\n};\\n</script>\\n\\n</body>\\n</html>\\n\",\"x\":690,\"y\":1820,\"wires\":[[\"748f4cdc.d6f88c\"]]},{\"id\":\"31ef6b3e.25e60c\",\"type\":\"http in\",\"z\":\"b0ed7852.d58f08\",\"name\":\"\",\"url\":\"/test514\",\"method\":\"get\",\"swaggerDoc\":\"\",\"x\":150,\"y\":1760,\"wires\":[[\"76358274.bcd864\"]]},{\"id\":\"748f4cdc.d6f88c\",\"type\":\"http response\",\"z\":\"b0ed7852.d58f08\",\"name\":\"\",\"x\":850,\"y\":1820,\"wires\":[]},{\"id\":\"a3c33f74.38abc8\",\"type\":\"comment\",\"z\":\"b0ed7852.d58f08\",\"name\":\"\u30bb\u30f3\u30b5\u30fc\u3092\u7d75\u306b\u8ffd\u52a0\",\"info\":\"\",\"x\":150,\"y\":1720,\"wires\":[]},{\"id\":\"806e2715.ce426\",\"type\":\"template\",\"z\":\"b0ed7852.d58f08\",\"name\":\"css514\",\"field\":\"payload.css\",\"fieldType\":\"msg\",\"format\":\"handlebars\",\"syntax\":\"mustache\",\"template\":\"#basic {\\n  width: 1200px;\\n  margin: auto;\\n}\\n\\n#a1 {\\n  background-color:  #98d98e;\\n  padding: 20px;\\n  height: 100px;\\n}\\n#b1 {\\n  background-color:  #e4de8a;\\n  padding-left: 20px;\\n  height: 40px;\\n  text-align:left;\\n  font-size: 18pt\\n}\\n#c1 {\\n  float: left;\\n  background-color:  #68be8d;\\n  width: 50px;\\n  height: 500px ;\\n}\\n#c2 {\\n  float: left;\\n  background-color:  #cee4ae;\\n  width: 127px;\\n  height: 500px ;\\n}\\n\\n#c3 {\\n  float: left;\\n  width: 723px;\\n  height: 500px;\\n  background: url({{{payload.background.picture}}});\\n  background-size:auto;\\n}\\n\\n#c4 {\\n  float: right;\\n  background-color: #93b69c;\\n  width: 300px;\\n  height: 80px ;\\n}\\n#c5 {\\n  float: right;\\n  background-color: #b9d08b;\\n  width: 300px;\\n  height: 60px ;\\n}\\n#c6 {\\n  overflow: scroll;\\n  float: right;\\n  background-color: #98d98e;\\n  width:  300px;\\n  height: 360px ;\\n}\\n#d1 {\\n  float: left;\\n  width: 400px;\\n  height: 150px;\\n  background-color:  #c1d8ac;\\n}\\n#d2 {\\n  float: left;\\n  width: 400px;\\n  height: 150px;\\n  background-color:  #b9d08b;\\n}\\n#d3 {\\n  float: left;\\n  width: 400px;\\n  height: 150px;\\n  background-color:  #badcad;\\n}\\n\\n#e1 {\\n  float: left;\\n  width: 400px;\\n  height: 120px;\\n  background-color:  #c1d8ac;\\n}\\n#e2 {\\n  float: left;\\n  width: 400px;\\n  height: 120px;\\n  background-color:  #b9d08b;\\n}\\n#e3 {\\n  float: left;\\n  width: 400px;\\n  height: 120px;\\n  background-color:  #badcad;\\n}\\n\\n#f1 {\\n  float: left;\\n  width: 400px;\\n  height: 200px;\\n  background-color:  #c1d8ac;\\n}\\n#f2 {\\n  float: left;\\n  width: 400px;\\n  height: 200px;\\n  background-color:  #b9d08b;\\n}\\n#f3 {\\n  float: left;\\n  width: 400px;\\n  height: 200px;\\n  background-color:  #badcad;\\n}\\n\\n#g1 {\\n  float: left;\\n  width: 400px;\\n  height: 150px;\\n  background-color:  #c1d8ac;\\n}\\n#g2 {\\n  float: left;\\n  width: 400px;\\n  height: 150px;\\n  background-color:  #b9d08b;\\n}\\n#g3 {\\n  float: left;\\n  width: 400px;\\n  height: 150px;\\n  background-color:  #badcad;\\n}\\n\\n#h1 {\\n  float: left;\\n  width: 400px;\\n  height: 120px;\\n  background-color:  #98d98e;\\n}\\n#h2 {\\n  float: left;\\n  width: 400px;\\n  height: 120px;\\n  background-color:  #c1d8ac;\\n}\\n#h3 {\\n  float: left;\\n  width: 400px;\\n  height: 120px;\\n  background-color:  #93b69c;\\n}\\n\\n#j1 {\\n  float: left;\\n  width: 400px;\\n  height: 200px;\\n  background-color:  #98d98e;\\n}\\n#j2 {\\n  float: left;\\n  width: 400px;\\n  height: 200px;\\n  background-color:  #c1d8ac;\\n}\\n#j3 {\\n  float: left;\\n  width: 400px;\\n  height: 200px;\\n  background-color:  #93b69c;\\n}\\n\\n#k1 {\\n  float: left;\\n  width: 400px;\\n  height: 120px;\\n  background-color:  #c1d8ac;\\n}\\n#k2 {\\n  float: left;\\n  width: 400px;\\n  height: 120px;\\n  background-color:  #b9d08b;\\n}\\n#k3 {\\n  float: left;\\n  width: 400px;\\n  height: 120px;\\n  background-color:  #badcad;\\n}\\n\\n#m1 {\\n  float: left;\\n  width: 400px;\\n  height: 200px;\\n  background-color:  #c1d8ac;\\n}\\n#m2 {\\n  float: left;\\n  width: 400px;\\n  height: 200px;\\n  background-color:  #b9d08b;\\n}\\n#m3 {\\n  float: left;\\n  width: 400px;\\n  height: 200px;\\n  background-color:  #badcad;\\n}\\n\\n#v1 {\\n  clear: both;\\n  height: 100px;\\n  background-color:  #aacf53;\\n}\\n#x1 {\\n  height: 100px;\\n\\tpadding: 20px;\\n  background-color:  #c1d8ac;\\n}\\n#y1 {\\n  background-color: #e4dc8a;\\n\\tpadding: 20px;\\n  height: 250px;\\n}\\n#z1 {\\n  height: 25px;\\n  background-color: #8f8667;\\n  font-size: 18px;\\n  text-align: center;\\n}\\n\",\"x\":520,\"y\":1820,\"wires\":[[\"c900afe6.93d18\"]]},{\"id\":\"b941211b.290f28\",\"type\":\"template\",\"z\":\"b0ed7852.d58f08\",\"name\":\"svg\",\"field\":\"payload.svg\",\"fieldType\":\"msg\",\"format\":\"handlebars\",\"syntax\":\"mustache\",\"template\":\"/*!\\n* svg.js - A lightweight library for manipulating and animating SVG.\\n* @version 2.3.7\\n* https://svgdotjs.github.io/\\n*\\n* @copyright Wout Fierens <wout@mick-wout.com>\\n* @license MIT\\n*\\n* BUILT: Sat Jan 14 2017 07:23:18 GMT+0100 (CET)\\n*/;\\n(function(root, factory) {\\n  if (typeof define === 'function' && define.amd) {\\n    define(function(){\\n      return factory(root, root.document)\\n    })\\n  } else if (typeof exports === 'object') {\\n    module.exports = root.document ? factory(root, root.document) : function(w){ return factory(w, w.document) }\\n  } else {\\n    root.SVG = factory(root, root.document)\\n  }\\n}(typeof window !== \\\"undefined\\\" ? window : this, function(window, document) {\\n\\n// The main wrapping element\\nvar SVG = this.SVG = function(element) {\\n  if (SVG.supported) {\\n    element = new SVG.Doc(element)\\n\\n    if(!SVG.parser.draw)\\n      SVG.prepare()\\n\\n    return element\\n  }\\n}\\n\\n// Default namespaces\\nSVG.ns    = 'http://www.w3.org/2000/svg'\\nSVG.xmlns = 'http://www.w3.org/2000/xmlns/'\\nSVG.xlink = 'http://www.w3.org/1999/xlink'\\nSVG.svgjs = 'http://svgjs.com/svgjs'\\n\\n// Svg support test\\nSVG.supported = (function() {\\n  return !! document.createElementNS &&\\n         !! document.createElementNS(SVG.ns,'svg').createSVGRect\\n})()\\n\\n// Don't bother to continue if SVG is not supported\\nif (!SVG.supported) return false\\n\\n// Element id sequence\\nSVG.did  = 1000\\n\\n// Get next named element id\\nSVG.eid = function(name) {\\n  return 'Svgjs' + capitalize(name) + (SVG.did++)\\n}\\n\\n// Method for element creation\\nSVG.create = function(name) {\\n  // create element\\n  var element = document.createElementNS(this.ns, name)\\n\\n  // apply unique id\\n  element.setAttribute('id', this.eid(name))\\n\\n  return element\\n}\\n\\n// Method for extending objects\\nSVG.extend = function() {\\n  var modules, methods, key, i\\n\\n  // Get list of modules\\n  modules = [].slice.call(arguments)\\n\\n  // Get object with extensions\\n  methods = modules.pop()\\n\\n  for (i = modules.length - 1; i >= 0; i--)\\n    if (modules[i])\\n      for (key in methods)\\n        modules[i].prototype[key] = methods[key]\\n\\n  // Make sure SVG.Set inherits any newly added methods\\n  if (SVG.Set && SVG.Set.inherit)\\n    SVG.Set.inherit()\\n}\\n\\n// Invent new element\\nSVG.invent = function(config) {\\n  // Create element initializer\\n  var initializer = typeof config.create == 'function' ?\\n    config.create :\\n    function() {\\n      this.constructor.call(this, SVG.create(config.create))\\n    }\\n\\n  // Inherit prototype\\n  if (config.inherit)\\n    initializer.prototype = new config.inherit\\n\\n  // Extend with methods\\n  if (config.extend)\\n    SVG.extend(initializer, config.extend)\\n\\n  // Attach construct method to parent\\n  if (config.construct)\\n    SVG.extend(config.parent || SVG.Container, config.construct)\\n\\n  return initializer\\n}\\n\\n// Adopt existing svg elements\\nSVG.adopt = function(node) {\\n  // check for presence of node\\n  if (!node) return null\\n\\n  // make sure a node isn't already adopted\\n  if (node.instance) return node.instance\\n\\n  // initialize variables\\n  var element\\n\\n  // adopt with element-specific settings\\n  if (node.nodeName == 'svg')\\n    element = node.parentNode instanceof SVGElement ? new SVG.Nested : new SVG.Doc\\n  else if (node.nodeName == 'linearGradient')\\n    element = new SVG.Gradient('linear')\\n  else if (node.nodeName == 'radialGradient')\\n    element = new SVG.Gradient('radial')\\n  else if (SVG[capitalize(node.nodeName)])\\n    element = new SVG[capitalize(node.nodeName)]\\n  else\\n    element = new SVG.Element(node)\\n\\n  // ensure references\\n  element.type  = node.nodeName\\n  element.node  = node\\n  node.instance = element\\n\\n  // SVG.Class specific preparations\\n  if (element instanceof SVG.Doc)\\n    element.namespace().defs()\\n\\n  // pull svgjs data from the dom (getAttributeNS doesn't work in html5)\\n  element.setData(JSON.parse(node.getAttribute('svgjs:data')) || {})\\n\\n  return element\\n}\\n\\n// Initialize parsing element\\nSVG.prepare = function() {\\n  // Select document body and create invisible svg element\\n  var body = document.getElementsByTagName('body')[0]\\n    , draw = (body ? new SVG.Doc(body) :  new SVG.Doc(document.documentElement).nested()).size(2, 0)\\n\\n  // Create parser object\\n  SVG.parser = {\\n    body: body || document.documentElement\\n  , draw: draw.style('opacity:0;position:fixed;left:100%;top:100%;overflow:hidden')\\n  , poly: draw.polyline().node\\n  , path: draw.path().node\\n  , native: SVG.create('svg')\\n  }\\n}\\n\\nSVG.parser = {\\n  native: SVG.create('svg')\\n}\\n\\ndocument.addEventListener('DOMContentLoaded', function() {\\n  if(!SVG.parser.draw)\\n    SVG.prepare()\\n}, false)\\n\\n// Storage for regular expressions\\nSVG.regex = {\\n  // Parse unit value\\n  numberAndUnit:    /^([+-]?(\\\\d+(\\\\.\\\\d*)?|\\\\.\\\\d+)(e[+-]?\\\\d+)?)([a-z%]*)$/i\\n\\n  // Parse hex value\\n, hex:              /^#?([a-f\\\\d]{2})([a-f\\\\d]{2})([a-f\\\\d]{2})$/i\\n\\n  // Parse rgb value\\n, rgb:              /rgb\\\\((\\\\d+),(\\\\d+),(\\\\d+)\\\\)/\\n\\n  // Parse reference id\\n, reference:        /#([a-z0-9\\\\-_]+)/i\\n\\n  // Parse matrix wrapper\\n, matrix:           /matrix\\\\(|\\\\)/g\\n\\n  // Elements of a matrix\\n, matrixElements:   /,*\\\\s+|,/\\n\\n  // Whitespace\\n, whitespace:       /\\\\s/g\\n\\n  // Test hex value\\n, isHex:            /^#[a-f0-9]{3,6}$/i\\n\\n  // Test rgb value\\n, isRgb:            /^rgb\\\\(/\\n\\n  // Test css declaration\\n, isCss:            /[^:]+:[^;]+;?/\\n\\n  // Test for blank string\\n, isBlank:          /^(\\\\s+)?$/\\n\\n  // Test for numeric string\\n, isNumber:         /^[+-]?(\\\\d+(\\\\.\\\\d*)?|\\\\.\\\\d+)(e[+-]?\\\\d+)?$/i\\n\\n  // Test for percent value\\n, isPercent:        /^-?[\\\\d\\\\.]+%$/\\n\\n  // Test for image url\\n, isImage:          /\\\\.(jpg|jpeg|png|gif|svg)(\\\\?[^=]+.*)?/i\\n\\n  // The following regex are used to parse the d attribute of a path\\n\\n  // Replaces all negative exponents\\n, negExp:           /e\\\\-/gi\\n\\n  // Replaces all comma\\n, comma:            /,/g\\n\\n  // Replaces all hyphens\\n, hyphen:           /\\\\-/g\\n\\n  // Replaces and tests for all path letters\\n, pathLetters:      /[MLHVCSQTAZ]/gi\\n\\n  // yes we need this one, too\\n, isPathLetter:     /[MLHVCSQTAZ]/i\\n\\n  // split at whitespaces\\n, whitespaces:      /\\\\s+/\\n\\n  // matches X\\n, X:                /X/g\\n}\\n\\nSVG.utils = {\\n  // Map function\\n  map: function(array, block) {\\n    var i\\n      , il = array.length\\n      , result = []\\n\\n    for (i = 0; i < il; i++)\\n      result.push(block(array[i]))\\n\\n    return result\\n  }\\n\\n  // Filter function\\n, filter: function(array, block) {\\n    var i\\n      , il = array.length\\n      , result = []\\n\\n    for (i = 0; i < il; i++)\\n      if (block(array[i]))\\n        result.push(array[i])\\n\\n    return result\\n  }\\n\\n  // Degrees to radians\\n, radians: function(d) {\\n    return d % 360 * Math.PI / 180\\n  }\\n\\n  // Radians to degrees\\n, degrees: function(r) {\\n    return r * 180 / Math.PI % 360\\n  }\\n\\n, filterSVGElements: function(nodes) {\\n    return this.filter( nodes, function(el) { return el instanceof SVGElement })\\n  }\\n\\n}\\n\\nSVG.defaults = {\\n  // Default attribute values\\n  attrs: {\\n    // fill and stroke\\n    'fill-opacity':     1\\n  , 'stroke-opacity':   1\\n  , 'stroke-width':     0\\n  , 'stroke-linejoin':  'miter'\\n  , 'stroke-linecap':   'butt'\\n  , fill:               '#000000'\\n  , stroke:             '#000000'\\n  , opacity:            1\\n    // position\\n  , x:                  0\\n  , y:                  0\\n  , cx:                 0\\n  , cy:                 0\\n    // size\\n  , width:              0\\n  , height:             0\\n    // radius\\n  , r:                  0\\n  , rx:                 0\\n  , ry:                 0\\n    // gradient\\n  , offset:             0\\n  , 'stop-opacity':     1\\n  , 'stop-color':       '#000000'\\n    // text\\n  , 'font-size':        16\\n  , 'font-family':      'Helvetica, Arial, sans-serif'\\n  , 'text-anchor':      'start'\\n  }\\n\\n}\\n// Module for color convertions\\nSVG.Color = function(color) {\\n  var match\\n\\n  // initialize defaults\\n  this.r = 0\\n  this.g = 0\\n  this.b = 0\\n\\n  if(!color) return\\n\\n  // parse color\\n  if (typeof color === 'string') {\\n    if (SVG.regex.isRgb.test(color)) {\\n      // get rgb values\\n      match = SVG.regex.rgb.exec(color.replace(/\\\\s/g,''))\\n\\n      // parse numeric values\\n      this.r = parseInt(match[1])\\n      this.g = parseInt(match[2])\\n      this.b = parseInt(match[3])\\n\\n    } else if (SVG.regex.isHex.test(color)) {\\n      // get hex values\\n      match = SVG.regex.hex.exec(fullHex(color))\\n\\n      // parse numeric values\\n      this.r = parseInt(match[1], 16)\\n      this.g = parseInt(match[2], 16)\\n      this.b = parseInt(match[3], 16)\\n\\n    }\\n\\n  } else if (typeof color === 'object') {\\n    this.r = color.r\\n    this.g = color.g\\n    this.b = color.b\\n\\n  }\\n\\n}\\n\\nSVG.extend(SVG.Color, {\\n  // Default to hex conversion\\n  toString: function() {\\n    return this.toHex()\\n  }\\n  // Build hex value\\n, toHex: function() {\\n    return '#'\\n      + compToHex(this.r)\\n      + compToHex(this.g)\\n      + compToHex(this.b)\\n  }\\n  // Build rgb value\\n, toRgb: function() {\\n    return 'rgb(' + [this.r, this.g, this.b].join() + ')'\\n  }\\n  // Calculate true brightness\\n, brightness: function() {\\n    return (this.r / 255 * 0.30)\\n         + (this.g / 255 * 0.59)\\n         + (this.b / 255 * 0.11)\\n  }\\n  // Make color morphable\\n, morph: function(color) {\\n    this.destination = new SVG.Color(color)\\n\\n    return this\\n  }\\n  // Get morphed color at given position\\n, at: function(pos) {\\n    // make sure a destination is defined\\n    if (!this.destination) return this\\n\\n    // normalise pos\\n    pos = pos < 0 ? 0 : pos > 1 ? 1 : pos\\n\\n    // generate morphed color\\n    return new SVG.Color({\\n      r: ~~(this.r + (this.destination.r - this.r) * pos)\\n    , g: ~~(this.g + (this.destination.g - this.g) * pos)\\n    , b: ~~(this.b + (this.destination.b - this.b) * pos)\\n    })\\n  }\\n\\n})\\n\\n// Testers\\n\\n// Test if given value is a color string\\nSVG.Color.test = function(color) {\\n  color += ''\\n  return SVG.regex.isHex.test(color)\\n      || SVG.regex.isRgb.test(color)\\n}\\n\\n// Test if given value is a rgb object\\nSVG.Color.isRgb = function(color) {\\n  return color && typeof color.r == 'number'\\n               && typeof color.g == 'number'\\n               && typeof color.b == 'number'\\n}\\n\\n// Test if given value is a color\\nSVG.Color.isColor = function(color) {\\n  return SVG.Color.isRgb(color) || SVG.Color.test(color)\\n}\\n// Module for array conversion\\nSVG.Array = function(array, fallback) {\\n  array = (array || []).valueOf()\\n\\n  // if array is empty and fallback is provided, use fallback\\n  if (array.length == 0 && fallback)\\n    array = fallback.valueOf()\\n\\n  // parse array\\n  this.value = this.parse(array)\\n}\\n\\nSVG.extend(SVG.Array, {\\n  // Make array morphable\\n  morph: function(array) {\\n    this.destination = this.parse(array)\\n\\n    // normalize length of arrays\\n    if (this.value.length != this.destination.length) {\\n      var lastValue       = this.value[this.value.length - 1]\\n        , lastDestination = this.destination[this.destination.length - 1]\\n\\n      while(this.value.length > this.destination.length)\\n        this.destination.push(lastDestination)\\n      while(this.value.length < this.destination.length)\\n        this.value.push(lastValue)\\n    }\\n\\n    return this\\n  }\\n  // Clean up any duplicate points\\n, settle: function() {\\n    // find all unique values\\n    for (var i = 0, il = this.value.length, seen = []; i < il; i++)\\n      if (seen.indexOf(this.value[i]) == -1)\\n        seen.push(this.value[i])\\n\\n    // set new value\\n    return this.value = seen\\n  }\\n  // Get morphed array at given position\\n, at: function(pos) {\\n    // make sure a destination is defined\\n    if (!this.destination) return this\\n\\n    // generate morphed array\\n    for (var i = 0, il = this.value.length, array = []; i < il; i++)\\n      array.push(this.value[i] + (this.destination[i] - this.value[i]) * pos)\\n\\n    return new SVG.Array(array)\\n  }\\n  // Convert array to string\\n, toString: function() {\\n    return this.value.join(' ')\\n  }\\n  // Real value\\n, valueOf: function() {\\n    return this.value\\n  }\\n  // Parse whitespace separated string\\n, parse: function(array) {\\n    array = array.valueOf()\\n\\n    // if already is an array, no need to parse it\\n    if (Array.isArray(array)) return array\\n\\n    return this.split(array)\\n  }\\n  // Strip unnecessary whitespace\\n, split: function(string) {\\n    return string.trim().split(/\\\\s+/)\\n  }\\n  // Reverse array\\n, reverse: function() {\\n    this.value.reverse()\\n\\n    return this\\n  }\\n\\n})\\n// Poly points array\\nSVG.PointArray = function(array, fallback) {\\n  this.constructor.call(this, array, fallback || [[0,0]])\\n}\\n\\n// Inherit from SVG.Array\\nSVG.PointArray.prototype = new SVG.Array\\n\\nSVG.extend(SVG.PointArray, {\\n  // Convert array to string\\n  toString: function() {\\n    // convert to a poly point string\\n    for (var i = 0, il = this.value.length, array = []; i < il; i++)\\n      array.push(this.value[i].join(','))\\n\\n    return array.join(' ')\\n  }\\n  // Convert array to line object\\n, toLine: function() {\\n    return {\\n      x1: this.value[0][0]\\n    , y1: this.value[0][1]\\n    , x2: this.value[1][0]\\n    , y2: this.value[1][1]\\n    }\\n  }\\n  // Get morphed array at given position\\n, at: function(pos) {\\n    // make sure a destination is defined\\n    if (!this.destination) return this\\n\\n    // generate morphed point string\\n    for (var i = 0, il = this.value.length, array = []; i < il; i++)\\n      array.push([\\n        this.value[i][0] + (this.destination[i][0] - this.value[i][0]) * pos\\n      , this.value[i][1] + (this.destination[i][1] - this.value[i][1]) * pos\\n      ])\\n\\n    return new SVG.PointArray(array)\\n  }\\n  // Parse point string\\n, parse: function(array) {\\n    var points = []\\n\\n    array = array.valueOf()\\n\\n    // if already is an array, no need to parse it\\n    if (Array.isArray(array)) return array\\n\\n    // parse points\\n    array = array.trim().split(/\\\\s+|,/)\\n\\n    // validate points - https://svgwg.org/svg2-draft/shapes.html#DataTypePoints\\n    // Odd number of coordinates is an error. In such cases, drop the last odd coordinate.\\n    if (array.length % 2 !== 0) array.pop()\\n\\n    // wrap points in two-tuples and parse points as floats\\n    for(var i = 0, len = array.length; i < len; i = i + 2)\\n      points.push([ parseFloat(array[i]), parseFloat(array[i+1]) ])\\n\\n    return points\\n  }\\n  // Move point string\\n, move: function(x, y) {\\n    var box = this.bbox()\\n\\n    // get relative offset\\n    x -= box.x\\n    y -= box.y\\n\\n    // move every point\\n    if (!isNaN(x) && !isNaN(y))\\n      for (var i = this.value.length - 1; i >= 0; i--)\\n        this.value[i] = [this.value[i][0] + x, this.value[i][1] + y]\\n\\n    return this\\n  }\\n  // Resize poly string\\n, size: function(width, height) {\\n    var i, box = this.bbox()\\n\\n    // recalculate position of all points according to new size\\n    for (i = this.value.length - 1; i >= 0; i--) {\\n      this.value[i][0] = ((this.value[i][0] - box.x) * width)  / box.width  + box.x\\n      this.value[i][1] = ((this.value[i][1] - box.y) * height) / box.height + box.y\\n    }\\n\\n    return this\\n  }\\n  // Get bounding box of points\\n, bbox: function() {\\n    SVG.parser.poly.setAttribute('points', this.toString())\\n\\n    return SVG.parser.poly.getBBox()\\n  }\\n\\n})\\n// Path points array\\nSVG.PathArray = function(array, fallback) {\\n  this.constructor.call(this, array, fallback || [['M', 0, 0]])\\n}\\n\\n// Inherit from SVG.Array\\nSVG.PathArray.prototype = new SVG.Array\\n\\nSVG.extend(SVG.PathArray, {\\n  // Convert array to string\\n  toString: function() {\\n    return arrayToString(this.value)\\n  }\\n  // Move path string\\n, move: function(x, y) {\\n    // get bounding box of current situation\\n    var box = this.bbox()\\n\\n    // get relative offset\\n    x -= box.x\\n    y -= box.y\\n\\n    if (!isNaN(x) && !isNaN(y)) {\\n      // move every point\\n      for (var l, i = this.value.length - 1; i >= 0; i--) {\\n        l = this.value[i][0]\\n\\n        if (l == 'M' || l == 'L' || l == 'T')  {\\n          this.value[i][1] += x\\n          this.value[i][2] += y\\n\\n        } else if (l == 'H')  {\\n          this.value[i][1] += x\\n\\n        } else if (l == 'V')  {\\n          this.value[i][1] += y\\n\\n        } else if (l == 'C' || l == 'S' || l == 'Q')  {\\n          this.value[i][1] += x\\n          this.value[i][2] += y\\n          this.value[i][3] += x\\n          this.value[i][4] += y\\n\\n          if (l == 'C')  {\\n            this.value[i][5] += x\\n            this.value[i][6] += y\\n          }\\n\\n        } else if (l == 'A')  {\\n          this.value[i][6] += x\\n          this.value[i][7] += y\\n        }\\n\\n      }\\n    }\\n\\n    return this\\n  }\\n  // Resize path string\\n, size: function(width, height) {\\n    // get bounding box of current situation\\n    var i, l, box = this.bbox()\\n\\n    // recalculate position of all points according to new size\\n    for (i = this.value.length - 1; i >= 0; i--) {\\n      l = this.value[i][0]\\n\\n      if (l == 'M' || l == 'L' || l == 'T')  {\\n        this.value[i][1] = ((this.value[i][1] - box.x) * width)  / box.width  + box.x\\n        this.value[i][2] = ((this.value[i][2] - box.y) * height) / box.height + box.y\\n\\n      } else if (l == 'H')  {\\n        this.value[i][1] = ((this.value[i][1] - box.x) * width)  / box.width  + box.x\\n\\n      } else if (l == 'V')  {\\n        this.value[i][1] = ((this.value[i][1] - box.y) * height) / box.height + box.y\\n\\n      } else if (l == 'C' || l == 'S' || l == 'Q')  {\\n        this.value[i][1] = ((this.value[i][1] - box.x) * width)  / box.width  + box.x\\n        this.value[i][2] = ((this.value[i][2] - box.y) * height) / box.height + box.y\\n        this.value[i][3] = ((this.value[i][3] - box.x) * width)  / box.width  + box.x\\n        this.value[i][4] = ((this.value[i][4] - box.y) * height) / box.height + box.y\\n\\n        if (l == 'C')  {\\n          this.value[i][5] = ((this.value[i][5] - box.x) * width)  / box.width  + box.x\\n          this.value[i][6] = ((this.value[i][6] - box.y) * height) / box.height + box.y\\n        }\\n\\n      } else if (l == 'A')  {\\n        // resize radii\\n        this.value[i][1] = (this.value[i][1] * width)  / box.width\\n        this.value[i][2] = (this.value[i][2] * height) / box.height\\n\\n        // move position values\\n        this.value[i][6] = ((this.value[i][6] - box.x) * width)  / box.width  + box.x\\n        this.value[i][7] = ((this.value[i][7] - box.y) * height) / box.height + box.y\\n      }\\n\\n    }\\n\\n    return this\\n  }\\n  // Test if the passed path array use the same path data commands as this path array\\n, equalCommands: function(pathArray) {\\n    var i, il, equalCommands\\n\\n    pathArray = new SVG.PathArray(pathArray)\\n\\n    equalCommands = this.value.length === pathArray.value.length\\n    for(i = 0, il = this.value.length; equalCommands && i < il; i++) {\\n      equalCommands = this.value[i][0] === pathArray.value[i][0]\\n    }\\n\\n    return equalCommands\\n  }\\n  // Make path array morphable\\n, morph: function(pathArray) {\\n    pathArray = new SVG.PathArray(pathArray)\\n\\n    if(this.equalCommands(pathArray)) {\\n      this.destination = pathArray\\n    } else {\\n      this.destination = null\\n    }\\n\\n    return this\\n  }\\n  // Get morphed path array at given position\\n, at: function(pos) {\\n    // make sure a destination is defined\\n    if (!this.destination) return this\\n\\n    var sourceArray = this.value\\n      , destinationArray = this.destination.value\\n      , array = [], pathArray = new SVG.PathArray()\\n      , i, il, j, jl\\n\\n    // Animate has specified in the SVG spec\\n    // See: https://www.w3.org/TR/SVG11/paths.html#PathElement\\n    for (i = 0, il = sourceArray.length; i < il; i++) {\\n      array[i] = [sourceArray[i][0]]\\n      for(j = 1, jl = sourceArray[i].length; j < jl; j++) {\\n        array[i][j] = sourceArray[i][j] + (destinationArray[i][j] - sourceArray[i][j]) * pos\\n      }\\n      // For the two flags of the elliptical arc command, the SVG spec say:\\n      // Flags and booleans are interpolated as fractions between zero and one, with any non-zero value considered to be a value of one/true\\n      // Elliptical arc command as an array followed by corresponding indexes:\\n      // ['A', rx, ry, x-axis-rotation, large-arc-flag, sweep-flag, x, y]\\n      //   0    1   2        3                 4             5      6  7\\n      if(array[i][0] === 'A') {\\n        array[i][4] = +(array[i][4] != 0)\\n        array[i][5] = +(array[i][5] != 0)\\n      }\\n    }\\n\\n    // Directly modify the value of a path array, this is done this way for performance\\n    pathArray.value = array\\n    return pathArray\\n  }\\n  // Absolutize and parse path to array\\n, parse: function(array) {\\n    // if it's already a patharray, no need to parse it\\n    if (array instanceof SVG.PathArray) return array.valueOf()\\n\\n    // prepare for parsing\\n    var i, x0, y0, s, seg, arr\\n      , x = 0\\n      , y = 0\\n      , paramCnt = { 'M':2, 'L':2, 'H':1, 'V':1, 'C':6, 'S':4, 'Q':4, 'T':2, 'A':7 }\\n\\n    if(typeof array == 'string'){\\n\\n      array = array\\n        .replace(SVG.regex.negExp, 'X')         // replace all negative exponents with certain char\\n        .replace(SVG.regex.pathLetters, ' $& ') // put some room between letters and numbers\\n        .replace(SVG.regex.hyphen, ' -')        // add space before hyphen\\n        .replace(SVG.regex.comma, ' ')          // unify all spaces\\n        .replace(SVG.regex.X, 'e-')             // add back the expoent\\n        .trim()                                 // trim\\n        .split(SVG.regex.whitespaces)           // split into array\\n\\n      // at this place there could be parts like ['3.124.854.32'] because we could not determine the point as seperator till now\\n      // we fix this elements in the next loop\\n      for(i = array.length; --i;){\\n        if(array[i].indexOf('.') != array[i].lastIndexOf('.')){\\n          var split = array[i].split('.') // split at the point\\n          var first = [split.shift(), split.shift()].join('.') // join the first number together\\n          array.splice.apply(array, [i, 1].concat(first, split.map(function(el){ return '.'+el }))) // add first and all other entries back to array\\n        }\\n      }\\n\\n    }else{\\n      array = array.reduce(function(prev, curr){\\n        return [].concat.apply(prev, curr)\\n      }, [])\\n    }\\n\\n    // array now is an array containing all parts of a path e.g. ['M', '0', '0', 'L', '30', '30' ...]\\n\\n    var arr = []\\n\\n    do{\\n\\n      // Test if we have a path letter\\n      if(SVG.regex.isPathLetter.test(array[0])){\\n        s = array[0]\\n        array.shift()\\n      // If last letter was a move command and we got no new, it defaults to [L]ine\\n      }else if(s == 'M'){\\n        s = 'L'\\n      }else if(s == 'm'){\\n        s = 'l'\\n      }\\n\\n      // add path letter as first element\\n      seg = [s.toUpperCase()]\\n\\n      // push all necessary parameters to segment\\n      for(i = 0; i < paramCnt[seg[0]]; ++i){\\n        seg.push(parseFloat(array.shift()))\\n      }\\n\\n      // upper case\\n      if(s == seg[0]){\\n\\n        if(s == 'M' || s == 'L' || s == 'C' || s == 'Q' || s == 'S' || s == 'T'){\\n          x = seg[paramCnt[seg[0]]-1]\\n          y = seg[paramCnt[seg[0]]]\\n        }else if(s == 'V'){\\n          y = seg[1]\\n        }else if(s == 'H'){\\n          x = seg[1]\\n        }else if(s == 'A'){\\n          x = seg[6]\\n          y = seg[7]\\n        }\\n\\n      // lower case\\n      }else{\\n\\n        // convert relative to absolute values\\n        if(s == 'm' || s == 'l' || s == 'c' || s == 's' || s == 'q' || s == 't'){\\n\\n          seg[1] += x\\n          seg[2] += y\\n\\n          if(seg[3] != null){\\n            seg[3] += x\\n            seg[4] += y\\n          }\\n\\n          if(seg[5] != null){\\n            seg[5] += x\\n            seg[6] += y\\n          }\\n\\n          // move pointer\\n          x = seg[paramCnt[seg[0]]-1]\\n          y = seg[paramCnt[seg[0]]]\\n\\n        }else if(s == 'v'){\\n          seg[1] += y\\n          y = seg[1]\\n        }else if(s == 'h'){\\n          seg[1] += x\\n          x = seg[1]\\n        }else if(s == 'a'){\\n          seg[6] += x\\n          seg[7] += y\\n          x = seg[6]\\n          y = seg[7]\\n        }\\n\\n      }\\n\\n      if(seg[0] == 'M'){\\n        x0 = x\\n        y0 = y\\n      }\\n\\n      if(seg[0] == 'Z'){\\n        x = x0\\n        y = y0\\n      }\\n\\n      arr.push(seg)\\n\\n    }while(array.length)\\n\\n    return arr\\n\\n  }\\n  // Get bounding box of path\\n, bbox: function() {\\n    SVG.parser.path.setAttribute('d', this.toString())\\n\\n    return SVG.parser.path.getBBox()\\n  }\\n\\n})\\n\\n// Module for unit convertions\\nSVG.Number = SVG.invent({\\n  // Initialize\\n  create: function(value, unit) {\\n    // initialize defaults\\n    this.value = 0\\n    this.unit  = unit || ''\\n\\n    // parse value\\n    if (typeof value === 'number') {\\n      // ensure a valid numeric value\\n      this.value = isNaN(value) ? 0 : !isFinite(value) ? (value < 0 ? -3.4e+38 : +3.4e+38) : value\\n\\n    } else if (typeof value === 'string') {\\n      unit = value.match(SVG.regex.numberAndUnit)\\n\\n      if (unit) {\\n        // make value numeric\\n        this.value = parseFloat(unit[1])\\n\\n        // normalize\\n        if (unit[5] == '%')\\n          this.value /= 100\\n        else if (unit[5] == 's')\\n          this.value *= 1000\\n\\n        // store unit\\n        this.unit = unit[5]\\n      }\\n\\n    } else {\\n      if (value instanceof SVG.Number) {\\n        this.value = value.valueOf()\\n        this.unit  = value.unit\\n      }\\n    }\\n\\n  }\\n  // Add methods\\n, extend: {\\n    // Stringalize\\n    toString: function() {\\n      return (\\n        this.unit == '%' ?\\n          ~~(this.value * 1e8) / 1e6:\\n        this.unit == 's' ?\\n          this.value / 1e3 :\\n          this.value\\n      ) + this.unit\\n    }\\n  , toJSON: function() {\\n      return this.toString()\\n    }\\n  , // Convert to primitive\\n    valueOf: function() {\\n      return this.value\\n    }\\n    // Add number\\n  , plus: function(number) {\\n      return new SVG.Number(this + new SVG.Number(number), this.unit)\\n    }\\n    // Subtract number\\n  , minus: function(number) {\\n      return this.plus(-new SVG.Number(number))\\n    }\\n    // Multiply number\\n  , times: function(number) {\\n      return new SVG.Number(this * new SVG.Number(number), this.unit)\\n    }\\n    // Divide number\\n  , divide: function(number) {\\n      return new SVG.Number(this / new SVG.Number(number), this.unit)\\n    }\\n    // Convert to different unit\\n  , to: function(unit) {\\n      var number = new SVG.Number(this)\\n\\n      if (typeof unit === 'string')\\n        number.unit = unit\\n\\n      return number\\n    }\\n    // Make number morphable\\n  , morph: function(number) {\\n      this.destination = new SVG.Number(number)\\n\\n      return this\\n    }\\n    // Get morphed number at given position\\n  , at: function(pos) {\\n      // Make sure a destination is defined\\n      if (!this.destination) return this\\n\\n      // Generate new morphed number\\n      return new SVG.Number(this.destination)\\n          .minus(this)\\n          .times(pos)\\n          .plus(this)\\n    }\\n\\n  }\\n})\\n\\nSVG.Element = SVG.invent({\\n  // Initialize node\\n  create: function(node) {\\n    // make stroke value accessible dynamically\\n    this._stroke = SVG.defaults.attrs.stroke\\n\\n    // initialize data object\\n    this.dom = {}\\n\\n    // create circular reference\\n    if (this.node = node) {\\n      this.type = node.nodeName\\n      this.node.instance = this\\n\\n      // store current attribute value\\n      this._stroke = node.getAttribute('stroke') || this._stroke\\n    }\\n  }\\n\\n  // Add class methods\\n, extend: {\\n    // Move over x-axis\\n    x: function(x) {\\n      return this.attr('x', x)\\n    }\\n    // Move over y-axis\\n  , y: function(y) {\\n      return this.attr('y', y)\\n    }\\n    // Move by center over x-axis\\n  , cx: function(x) {\\n      return x == null ? this.x() + this.width() / 2 : this.x(x - this.width() / 2)\\n    }\\n    // Move by center over y-axis\\n  , cy: function(y) {\\n      return y == null ? this.y() + this.height() / 2 : this.y(y - this.height() / 2)\\n    }\\n    // Move element to given x and y values\\n  , move: function(x, y) {\\n      return this.x(x).y(y)\\n    }\\n    // Move element by its center\\n  , center: function(x, y) {\\n      return this.cx(x).cy(y)\\n    }\\n    // Set width of element\\n  , width: function(width) {\\n      return this.attr('width', width)\\n    }\\n    // Set height of element\\n  , height: function(height) {\\n      return this.attr('height', height)\\n    }\\n    // Set element size to given width and height\\n  , size: function(width, height) {\\n      var p = proportionalSize(this, width, height)\\n\\n      return this\\n        .width(new SVG.Number(p.width))\\n        .height(new SVG.Number(p.height))\\n    }\\n    // Clone element\\n  , clone: function(parent) {\\n      // clone element and assign new id\\n      var clone = assignNewId(this.node.cloneNode(true))\\n\\n      // insert the clone in the given parent or after myself\\n      if(parent) parent.add(clone)\\n      else this.after(clone)\\n\\n      return clone\\n    }\\n    // Remove element\\n  , remove: function() {\\n      if (this.parent())\\n        this.parent().removeElement(this)\\n\\n      return this\\n    }\\n    // Replace element\\n  , replace: function(element) {\\n      this.after(element).remove()\\n\\n      return element\\n    }\\n    // Add element to given container and return self\\n  , addTo: function(parent) {\\n      return parent.put(this)\\n    }\\n    // Add element to given container and return container\\n  , putIn: function(parent) {\\n      return parent.add(this)\\n    }\\n    // Get / set id\\n  , id: function(id) {\\n      return this.attr('id', id)\\n    }\\n    // Checks whether the given point inside the bounding box of the element\\n  , inside: function(x, y) {\\n      var box = this.bbox()\\n\\n      return x > box.x\\n          && y > box.y\\n          && x < box.x + box.width\\n          && y < box.y + box.height\\n    }\\n    // Show element\\n  , show: function() {\\n      return this.style('display', '')\\n    }\\n    // Hide element\\n  , hide: function() {\\n      return this.style('display', 'none')\\n    }\\n    // Is element visible?\\n  , visible: function() {\\n      return this.style('display') != 'none'\\n    }\\n    // Return id on string conversion\\n  , toString: function() {\\n      return this.attr('id')\\n    }\\n    // Return array of classes on the node\\n  , classes: function() {\\n      var attr = this.attr('class')\\n\\n      return attr == null ? [] : attr.trim().split(/\\\\s+/)\\n    }\\n    // Return true if class exists on the node, false otherwise\\n  , hasClass: function(name) {\\n      return this.classes().indexOf(name) != -1\\n    }\\n    // Add class to the node\\n  , addClass: function(name) {\\n      if (!this.hasClass(name)) {\\n        var array = this.classes()\\n        array.push(name)\\n        this.attr('class', array.join(' '))\\n      }\\n\\n      return this\\n    }\\n    // Remove class from the node\\n  , removeClass: function(name) {\\n      if (this.hasClass(name)) {\\n        this.attr('class', this.classes().filter(function(c) {\\n          return c != name\\n        }).join(' '))\\n      }\\n\\n      return this\\n    }\\n    // Toggle the presence of a class on the node\\n  , toggleClass: function(name) {\\n      return this.hasClass(name) ? this.removeClass(name) : this.addClass(name)\\n    }\\n    // Get referenced element form attribute value\\n  , reference: function(attr) {\\n      return SVG.get(this.attr(attr))\\n    }\\n    // Returns the parent element instance\\n  , parent: function(type) {\\n      var parent = this\\n\\n      // check for parent\\n      if(!parent.node.parentNode) return null\\n\\n      // get parent element\\n      parent = SVG.adopt(parent.node.parentNode)\\n\\n      if(!type) return parent\\n\\n      // loop trough ancestors if type is given\\n      while(parent && parent.node instanceof SVGElement){\\n        if(typeof type === 'string' ? parent.matches(type) : parent instanceof type) return parent\\n        parent = SVG.adopt(parent.node.parentNode)\\n      }\\n    }\\n    // Get parent document\\n  , doc: function() {\\n      return this instanceof SVG.Doc ? this : this.parent(SVG.Doc)\\n    }\\n    // return array of all ancestors of given type up to the root svg\\n  , parents: function(type) {\\n      var parents = [], parent = this\\n\\n      do{\\n        parent = parent.parent(type)\\n        if(!parent || !parent.node) break\\n\\n        parents.push(parent)\\n      } while(parent.parent)\\n\\n      return parents\\n    }\\n    // matches the element vs a css selector\\n  , matches: function(selector){\\n      return matches(this.node, selector)\\n    }\\n    // Returns the svg node to call native svg methods on it\\n  , native: function() {\\n      return this.node\\n    }\\n    // Import raw svg\\n  , svg: function(svg) {\\n      // create temporary holder\\n      var well = document.createElement('svg')\\n\\n      // act as a setter if svg is given\\n      if (svg && this instanceof SVG.Parent) {\\n        // dump raw svg\\n        well.innerHTML = '<svg>' + svg.replace(/\\\\n/, '').replace(/<(\\\\w+)([^<]+?)\\\\/>/g, '<$1$2></$1>') + '</svg>'\\n\\n        // transplant nodes\\n        for (var i = 0, il = well.firstChild.childNodes.length; i < il; i++)\\n          this.node.appendChild(well.firstChild.firstChild)\\n\\n      // otherwise act as a getter\\n      } else {\\n        // create a wrapping svg element in case of partial content\\n        well.appendChild(svg = document.createElement('svg'))\\n\\n        // write svgjs data to the dom\\n        this.writeDataToDom()\\n\\n        // insert a copy of this node\\n        svg.appendChild(this.node.cloneNode(true))\\n\\n        // return target element\\n        return well.innerHTML.replace(/^<svg>/, '').replace(/<\\\\/svg>$/, '')\\n      }\\n\\n      return this\\n    }\\n  // write svgjs data to the dom\\n  , writeDataToDom: function() {\\n\\n      // dump variables recursively\\n      if(this.each || this.lines){\\n        var fn = this.each ? this : this.lines();\\n        fn.each(function(){\\n          this.writeDataToDom()\\n        })\\n      }\\n\\n      // remove previously set data\\n      this.node.removeAttribute('svgjs:data')\\n\\n      if(Object.keys(this.dom).length)\\n        this.node.setAttribute('svgjs:data', JSON.stringify(this.dom)) // see #428\\n\\n      return this\\n    }\\n  // set given data to the elements data property\\n  , setData: function(o){\\n      this.dom = o\\n      return this\\n    }\\n  , is: function(obj){\\n      return is(this, obj)\\n    }\\n  }\\n})\\n\\nSVG.easing = {\\n  '-': function(pos){return pos}\\n, '<>':function(pos){return -Math.cos(pos * Math.PI) / 2 + 0.5}\\n, '>': function(pos){return  Math.sin(pos * Math.PI / 2)}\\n, '<': function(pos){return -Math.cos(pos * Math.PI / 2) + 1}\\n}\\n\\nSVG.morph = function(pos){\\n  return function(from, to) {\\n    return new SVG.MorphObj(from, to).at(pos)\\n  }\\n}\\n\\nSVG.Situation = SVG.invent({\\n\\n  create: function(o){\\n    this.init = false\\n    this.reversed = false\\n    this.reversing = false\\n\\n    this.duration = new SVG.Number(o.duration).valueOf()\\n    this.delay = new SVG.Number(o.delay).valueOf()\\n\\n    this.start = +new Date() + this.delay\\n    this.finish = this.start + this.duration\\n    this.ease = o.ease\\n\\n    // this.loop is incremented from 0 to this.loops\\n    // it is also incremented when in an infinite loop (when this.loops is true)\\n    this.loop = 0\\n    this.loops = false\\n\\n    this.animations = {\\n      // functionToCall: [list of morphable objects]\\n      // e.g. move: [SVG.Number, SVG.Number]\\n    }\\n\\n    this.attrs = {\\n      // holds all attributes which are not represented from a function svg.js provides\\n      // e.g. someAttr: SVG.Number\\n    }\\n\\n    this.styles = {\\n      // holds all styles which should be animated\\n      // e.g. fill-color: SVG.Color\\n    }\\n\\n    this.transforms = [\\n      // holds all transformations as transformation objects\\n      // e.g. [SVG.Rotate, SVG.Translate, SVG.Matrix]\\n    ]\\n\\n    this.once = {\\n      // functions to fire at a specific position\\n      // e.g. \\\"0.5\\\": function foo(){}\\n    }\\n\\n  }\\n\\n})\\n\\n\\nSVG.FX = SVG.invent({\\n\\n  create: function(element) {\\n    this._target = element\\n    this.situations = []\\n    this.active = false\\n    this.situation = null\\n    this.paused = false\\n    this.lastPos = 0\\n    this.pos = 0\\n    // The absolute position of an animation is its position in the context of its complete duration (including delay and loops)\\n    // When performing a delay, absPos is below 0 and when performing a loop, its value is above 1\\n    this.absPos = 0\\n    this._speed = 1\\n  }\\n\\n, extend: {\\n\\n    /**\\n     * sets or returns the target of this animation\\n     * @param o object || number In case of Object it holds all parameters. In case of number its the duration of the animation\\n     * @param ease function || string Function which should be used for easing or easing keyword\\n     * @param delay Number indicating the delay before the animation starts\\n     * @return target || this\\n     */\\n    animate: function(o, ease, delay){\\n\\n      if(typeof o == 'object'){\\n        ease = o.ease\\n        delay = o.delay\\n        o = o.duration\\n      }\\n\\n      var situation = new SVG.Situation({\\n        duration: o || 1000,\\n        delay: delay || 0,\\n        ease: SVG.easing[ease || '-'] || ease\\n      })\\n\\n      this.queue(situation)\\n\\n      return this\\n    }\\n\\n    /**\\n     * sets a delay before the next element of the queue is called\\n     * @param delay Duration of delay in milliseconds\\n     * @return this.target()\\n     */\\n  , delay: function(delay){\\n      // The delay is performed by an empty situation with its duration\\n      // attribute set to the duration of the delay\\n      var situation = new SVG.Situation({\\n        duration: delay,\\n        delay: 0,\\n        ease: SVG.easing['-']\\n      })\\n\\n      return this.queue(situation)\\n    }\\n\\n    /**\\n     * sets or returns the target of this animation\\n     * @param null || target SVG.Element which should be set as new target\\n     * @return target || this\\n     */\\n  , target: function(target){\\n      if(target && target instanceof SVG.Element){\\n        this._target = target\\n        return this\\n      }\\n\\n      return this._target\\n    }\\n\\n    // returns the absolute position at a given time\\n  , timeToAbsPos: function(timestamp){\\n      return (timestamp - this.situation.start) / (this.situation.duration/this._speed)\\n    }\\n\\n    // returns the timestamp from a given absolute positon\\n  , absPosToTime: function(absPos){\\n      return this.situation.duration/this._speed * absPos + this.situation.start\\n    }\\n\\n    // starts the animationloop\\n  , startAnimFrame: function(){\\n      this.stopAnimFrame()\\n      this.animationFrame = requestAnimationFrame(function(){ this.step() }.bind(this))\\n    }\\n\\n    // cancels the animationframe\\n  , stopAnimFrame: function(){\\n      cancelAnimationFrame(this.animationFrame)\\n    }\\n\\n    // kicks off the animation - only does something when the queue is currently not active and at least one situation is set\\n  , start: function(){\\n      // dont start if already started\\n      if(!this.active && this.situation){\\n        this.active = true\\n        this.startCurrent()\\n      }\\n\\n      return this\\n    }\\n\\n    // start the current situation\\n  , startCurrent: function(){\\n      this.situation.start = +new Date + this.situation.delay/this._speed\\n      this.situation.finish = this.situation.start + this.situation.duration/this._speed\\n      return this.initAnimations().step()\\n    }\\n\\n    /**\\n     * adds a function / Situation to the animation queue\\n     * @param fn function / situation to add\\n     * @return this\\n     */\\n  , queue: function(fn){\\n      if(typeof fn == 'function' || fn instanceof SVG.Situation)\\n        this.situations.push(fn)\\n\\n      if(!this.situation) this.situation = this.situations.shift()\\n\\n      return this\\n    }\\n\\n    /**\\n     * pulls next element from the queue and execute it\\n     * @return this\\n     */\\n  , dequeue: function(){\\n      // stop current animation\\n      this.situation && this.situation.stop && this.situation.stop()\\n\\n      // get next animation from queue\\n      this.situation = this.situations.shift()\\n\\n      if(this.situation){\\n        if(this.situation instanceof SVG.Situation) {\\n          this.startCurrent()\\n        } else {\\n          // If it is not a SVG.Situation, then it is a function, we execute it\\n          this.situation.call(this)\\n        }\\n      }\\n\\n      return this\\n    }\\n\\n    // updates all animations to the current state of the element\\n    // this is important when one property could be changed from another property\\n  , initAnimations: function() {\\n      var i\\n      var s = this.situation\\n\\n      if(s.init) return this\\n\\n      for(i in s.animations){\\n\\n        if(i == 'viewbox'){\\n          s.animations[i] = this.target().viewbox().morph(s.animations[i])\\n        }else{\\n\\n          // TODO: this is not a clean clone of the array. We may have some unchecked references\\n          s.animations[i].value = (i == 'plot' ? this.target().array().value : this.target()[i]())\\n\\n          // sometimes we get back an object and not the real value, fix this\\n          if(s.animations[i].value.value){\\n            s.animations[i].value = s.animations[i].value.value\\n          }\\n\\n          if(s.animations[i].relative)\\n            s.animations[i].destination.value = s.animations[i].destination.value + s.animations[i].value\\n\\n        }\\n\\n      }\\n\\n      for(i in s.attrs){\\n        if(s.attrs[i] instanceof SVG.Color){\\n          var color = new SVG.Color(this.target().attr(i))\\n          s.attrs[i].r = color.r\\n          s.attrs[i].g = color.g\\n          s.attrs[i].b = color.b\\n        }else{\\n          s.attrs[i].value = this.target().attr(i)// + s.attrs[i].value\\n        }\\n      }\\n\\n      for(i in s.styles){\\n        s.styles[i].value = this.target().style(i)\\n      }\\n\\n      s.initialTransformation = this.target().matrixify()\\n\\n      s.init = true\\n      return this\\n    }\\n  , clearQueue: function(){\\n      this.situations = []\\n      return this\\n    }\\n  , clearCurrent: function(){\\n      this.situation = null\\n      return this\\n    }\\n    /** stops the animation immediately\\n     * @param jumpToEnd A Boolean indicating whether to complete the current animation immediately.\\n     * @param clearQueue A Boolean indicating whether to remove queued animation as well.\\n     * @return this\\n     */\\n  , stop: function(jumpToEnd, clearQueue){\\n      if(!this.active) this.start()\\n\\n      if(clearQueue){\\n        this.clearQueue()\\n      }\\n\\n      this.active = false\\n\\n      if(jumpToEnd && this.situation){\\n        this.atEnd()\\n      }\\n\\n      this.stopAnimFrame()\\n\\n      return this.clearCurrent()\\n    }\\n\\n    /** resets the element to the state where the current element has started\\n     * @return this\\n     */\\n  , reset: function(){\\n      if(this.situation){\\n        var temp = this.situation\\n        this.stop()\\n        this.situation = temp\\n        this.atStart()\\n      }\\n      return this\\n    }\\n\\n    // Stop the currently-running animation, remove all queued animations, and complete all animations for the element.\\n  , finish: function(){\\n\\n      this.stop(true, false)\\n\\n      while(this.dequeue().situation && this.stop(true, false));\\n\\n      this.clearQueue().clearCurrent()\\n\\n      return this\\n    }\\n\\n    // set the internal animation pointer at the start position, before any loops, and updates the visualisation\\n  , atStart: function() {\\n    return this.at(0, true)\\n  }\\n\\n    // set the internal animation pointer at the end position, after all the loops, and updates the visualisation\\n  , atEnd: function() {\\n    if (this.situation.loops === true) {\\n      // If in a infinite loop, we end the current iteration\\n      return this.at(this.situation.loop+1, true)\\n    } else if(typeof this.situation.loops == 'number') {\\n      // If performing a finite number of loops, we go after all the loops\\n      return this.at(this.situation.loops, true)\\n    } else {\\n      // If no loops, we just go at the end\\n      return this.at(1, true)\\n    }\\n  }\\n\\n    // set the internal animation pointer to the specified position and updates the visualisation\\n    // if isAbsPos is true, pos is treated as an absolute position\\n  , at: function(pos, isAbsPos){\\n      var durDivSpd = this.situation.duration/this._speed\\n\\n      this.absPos = pos\\n      // If pos is not an absolute position, we convert it into one\\n      if (!isAbsPos) {\\n        if (this.situation.reversed) this.absPos = 1 - this.absPos\\n        this.absPos += this.situation.loop\\n      }\\n\\n      this.situation.start = +new Date - this.absPos * durDivSpd\\n      this.situation.finish = this.situation.start + durDivSpd\\n\\n      return this.step(true)\\n    }\\n\\n    /**\\n     * sets or returns the speed of the animations\\n     * @param speed null || Number The new speed of the animations\\n     * @return Number || this\\n     */\\n  , speed: function(speed){\\n      if (speed === 0) return this.pause()\\n\\n      if (speed) {\\n        this._speed = speed\\n        // We use an absolute position here so that speed can affect the delay before the animation\\n        return this.at(this.absPos, true)\\n      } else return this._speed\\n    }\\n\\n    // Make loopable\\n  , loop: function(times, reverse) {\\n      var c = this.last()\\n\\n      // store total loops\\n      c.loops = (times != null) ? times : true\\n      c.loop = 0\\n\\n      if(reverse) c.reversing = true\\n      return this\\n    }\\n\\n    // pauses the animation\\n  , pause: function(){\\n      this.paused = true\\n      this.stopAnimFrame()\\n\\n      return this\\n    }\\n\\n    // unpause the animation\\n  , play: function(){\\n      if(!this.paused) return this\\n      this.paused = false\\n      // We use an absolute position here so that the delay before the animation can be paused\\n      return this.at(this.absPos, true)\\n    }\\n\\n    /**\\n     * toggle or set the direction of the animation\\n     * true sets direction to backwards while false sets it to forwards\\n     * @param reversed Boolean indicating whether to reverse the animation or not (default: toggle the reverse status)\\n     * @return this\\n     */\\n  , reverse: function(reversed){\\n      var c = this.last()\\n\\n      if(typeof reversed == 'undefined') c.reversed = !c.reversed\\n      else c.reversed = reversed\\n\\n      return this\\n    }\\n\\n\\n    /**\\n     * returns a float from 0-1 indicating the progress of the current animation\\n     * @param eased Boolean indicating whether the returned position should be eased or not\\n     * @return number\\n     */\\n  , progress: function(easeIt){\\n      return easeIt ? this.situation.ease(this.pos) : this.pos\\n    }\\n\\n    /**\\n     * adds a callback function which is called when the current animation is finished\\n     * @param fn Function which should be executed as callback\\n     * @return number\\n     */\\n  , after: function(fn){\\n      var c = this.last()\\n        , wrapper = function wrapper(e){\\n            if(e.detail.situation == c){\\n              fn.call(this, c)\\n              this.off('finished.fx', wrapper) // prevent memory leak\\n            }\\n          }\\n\\n      this.target().on('finished.fx', wrapper)\\n      return this\\n    }\\n\\n    // adds a callback which is called whenever one animation step is performed\\n  , during: function(fn){\\n      var c = this.last()\\n        , wrapper = function(e){\\n            if(e.detail.situation == c){\\n              fn.call(this, e.detail.pos, SVG.morph(e.detail.pos), e.detail.eased, c)\\n            }\\n          }\\n\\n      // see above\\n      this.target().off('during.fx', wrapper).on('during.fx', wrapper)\\n\\n      return this.after(function(){\\n        this.off('during.fx', wrapper)\\n      })\\n    }\\n\\n    // calls after ALL animations in the queue are finished\\n  , afterAll: function(fn){\\n      var wrapper = function wrapper(e){\\n            fn.call(this)\\n            this.off('allfinished.fx', wrapper)\\n          }\\n\\n      // see above\\n      this.target().off('allfinished.fx', wrapper).on('allfinished.fx', wrapper)\\n      return this\\n    }\\n\\n    // calls on every animation step for all animations\\n  , duringAll: function(fn){\\n      var wrapper = function(e){\\n            fn.call(this, e.detail.pos, SVG.morph(e.detail.pos), e.detail.eased, e.detail.situation)\\n          }\\n\\n      this.target().off('during.fx', wrapper).on('during.fx', wrapper)\\n\\n      return this.afterAll(function(){\\n        this.off('during.fx', wrapper)\\n      })\\n    }\\n\\n  , last: function(){\\n      return this.situations.length ? this.situations[this.situations.length-1] : this.situation\\n    }\\n\\n    // adds one property to the animations\\n  , add: function(method, args, type){\\n      this.last()[type || 'animations'][method] = args\\n      setTimeout(function(){this.start()}.bind(this), 0)\\n      return this\\n    }\\n\\n    /** perform one step of the animation\\n     *  @param ignoreTime Boolean indicating whether to ignore time and use position directly or recalculate position based on time\\n     *  @return this\\n     */\\n  , step: function(ignoreTime){\\n\\n      // convert current time to an absolute position\\n      if(!ignoreTime) this.absPos = this.timeToAbsPos(+new Date)\\n\\n      // This part convert an absolute position to a position\\n      if(this.situation.loops !== false) {\\n        var absPos, absPosInt, lastLoop\\n\\n        // If the absolute position is below 0, we just treat it as if it was 0\\n        absPos = Math.max(this.absPos, 0)\\n        absPosInt = Math.floor(absPos)\\n\\n        if(this.situation.loops === true || absPosInt < this.situation.loops) {\\n          this.pos = absPos - absPosInt\\n          lastLoop = this.situation.loop\\n          this.situation.loop = absPosInt\\n        } else {\\n          this.absPos = this.situation.loops\\n          this.pos = 1\\n          // The -1 here is because we don't want to toggle reversed when all the loops have been completed\\n          lastLoop = this.situation.loop - 1\\n          this.situation.loop = this.situation.loops\\n        }\\n\\n        if(this.situation.reversing) {\\n          // Toggle reversed if an odd number of loops as occured since the last call of step\\n          this.situation.reversed = this.situation.reversed != Boolean((this.situation.loop - lastLoop) % 2)\\n        }\\n\\n      } else {\\n        // If there are no loop, the absolute position must not be above 1\\n        this.absPos = Math.min(this.absPos, 1)\\n        this.pos = this.absPos\\n      }\\n\\n      // while the absolute position can be below 0, the position must not be below 0\\n      if(this.pos < 0) this.pos = 0\\n\\n      if(this.situation.reversed) this.pos = 1 - this.pos\\n\\n\\n      // apply easing\\n      var eased = this.situation.ease(this.pos)\\n\\n      // call once-callbacks\\n      for(var i in this.situation.once){\\n        if(i > this.lastPos && i <= eased){\\n          this.situation.once[i].call(this.target(), this.pos, eased)\\n          delete this.situation.once[i]\\n        }\\n      }\\n\\n      // fire during callback with position, eased position and current situation as parameter\\n      if(this.active) this.target().fire('during', {pos: this.pos, eased: eased, fx: this, situation: this.situation})\\n\\n      // the user may call stop or finish in the during callback\\n      // so make sure that we still have a valid situation\\n      if(!this.situation){\\n        return this\\n      }\\n\\n      // apply the actual animation to every property\\n      this.eachAt()\\n\\n      // do final code when situation is finished\\n      if((this.pos == 1 && !this.situation.reversed) || (this.situation.reversed && this.pos == 0)){\\n\\n        // stop animation callback\\n        this.stopAnimFrame()\\n\\n        // fire finished callback with current situation as parameter\\n        this.target().fire('finished', {fx:this, situation: this.situation})\\n\\n        if(!this.situations.length){\\n          this.target().fire('allfinished')\\n          this.target().off('.fx') // there shouldnt be any binding left, but to make sure...\\n          this.active = false\\n        }\\n\\n        // start next animation\\n        if(this.active) this.dequeue()\\n        else this.clearCurrent()\\n\\n      }else if(!this.paused && this.active){\\n        // we continue animating when we are not at the end\\n        this.startAnimFrame()\\n      }\\n\\n      // save last eased position for once callback triggering\\n      this.lastPos = eased\\n      return this\\n\\n    }\\n\\n    // calculates the step for every property and calls block with it\\n  , eachAt: function(){\\n      var i, at, self = this, target = this.target(), s = this.situation\\n\\n      // apply animations which can be called trough a method\\n      for(i in s.animations){\\n\\n        at = [].concat(s.animations[i]).map(function(el){\\n          return typeof el !== 'string' && el.at ? el.at(s.ease(self.pos), self.pos) : el\\n        })\\n\\n        target[i].apply(target, at)\\n\\n      }\\n\\n      // apply animation which has to be applied with attr()\\n      for(i in s.attrs){\\n\\n        at = [i].concat(s.attrs[i]).map(function(el){\\n          return typeof el !== 'string' && el.at ? el.at(s.ease(self.pos), self.pos) : el\\n        })\\n\\n        target.attr.apply(target, at)\\n\\n      }\\n\\n      // apply animation which has to be applied with style()\\n      for(i in s.styles){\\n\\n        at = [i].concat(s.styles[i]).map(function(el){\\n          return typeof el !== 'string' && el.at ? el.at(s.ease(self.pos), self.pos) : el\\n        })\\n\\n        target.style.apply(target, at)\\n\\n      }\\n\\n      // animate initialTransformation which has to be chained\\n      if(s.transforms.length){\\n\\n        // get initial initialTransformation\\n        at = s.initialTransformation\\n        for(i = 0, len = s.transforms.length; i < len; i++){\\n\\n          // get next transformation in chain\\n          var a = s.transforms[i]\\n\\n          // multiply matrix directly\\n          if(a instanceof SVG.Matrix){\\n\\n            if(a.relative){\\n              at = at.multiply(new SVG.Matrix().morph(a).at(s.ease(this.pos)))\\n            }else{\\n              at = at.morph(a).at(s.ease(this.pos))\\n            }\\n            continue\\n          }\\n\\n          // when transformation is absolute we have to reset the needed transformation first\\n          if(!a.relative)\\n            a.undo(at.extract())\\n\\n          // and reapply it after\\n          at = at.multiply(a.at(s.ease(this.pos)))\\n\\n        }\\n\\n        // set new matrix on element\\n        target.matrix(at)\\n      }\\n\\n      return this\\n\\n    }\\n\\n\\n    // adds an once-callback which is called at a specific position and never again\\n  , once: function(pos, fn, isEased){\\n\\n      if(!isEased)pos = this.situation.ease(pos)\\n\\n      this.situation.once[pos] = fn\\n\\n      return this\\n    }\\n\\n  }\\n\\n, parent: SVG.Element\\n\\n  // Add method to parent elements\\n, construct: {\\n    // Get fx module or create a new one, then animate with given duration and ease\\n    animate: function(o, ease, delay) {\\n      return (this.fx || (this.fx = new SVG.FX(this))).animate(o, ease, delay)\\n    }\\n  , delay: function(delay){\\n      return (this.fx || (this.fx = new SVG.FX(this))).delay(delay)\\n    }\\n  , stop: function(jumpToEnd, clearQueue) {\\n      if (this.fx)\\n        this.fx.stop(jumpToEnd, clearQueue)\\n\\n      return this\\n    }\\n  , finish: function() {\\n      if (this.fx)\\n        this.fx.finish()\\n\\n      return this\\n    }\\n    // Pause current animation\\n  , pause: function() {\\n      if (this.fx)\\n        this.fx.pause()\\n\\n      return this\\n    }\\n    // Play paused current animation\\n  , play: function() {\\n      if (this.fx)\\n        this.fx.play()\\n\\n      return this\\n    }\\n    // Set/Get the speed of the animations\\n  , speed: function(speed) {\\n      if (this.fx)\\n        if (speed == null)\\n          return this.fx.speed()\\n        else\\n          this.fx.speed(speed)\\n\\n      return this\\n    }\\n  }\\n\\n})\\n\\n// MorphObj is used whenever no morphable object is given\\nSVG.MorphObj = SVG.invent({\\n\\n  create: function(from, to){\\n    // prepare color for morphing\\n    if(SVG.Color.isColor(to)) return new SVG.Color(from).morph(to)\\n    // prepare number for morphing\\n    if(SVG.regex.numberAndUnit.test(to)) return new SVG.Number(from).morph(to)\\n\\n    // prepare for plain morphing\\n    this.value = 0\\n    this.destination = to\\n  }\\n\\n, extend: {\\n    at: function(pos, real){\\n      return real < 1 ? this.value : this.destination\\n    },\\n\\n    valueOf: function(){\\n      return this.value\\n    }\\n  }\\n\\n})\\n\\nSVG.extend(SVG.FX, {\\n  // Add animatable attributes\\n  attr: function(a, v, relative) {\\n    // apply attributes individually\\n    if (typeof a == 'object') {\\n      for (var key in a)\\n        this.attr(key, a[key])\\n\\n    } else {\\n      // the MorphObj takes care about the right function used\\n      this.add(a, new SVG.MorphObj(null, v), 'attrs')\\n    }\\n\\n    return this\\n  }\\n  // Add animatable styles\\n, style: function(s, v) {\\n    if (typeof s == 'object')\\n      for (var key in s)\\n        this.style(key, s[key])\\n\\n    else\\n      this.add(s, new SVG.MorphObj(null, v), 'styles')\\n\\n    return this\\n  }\\n  // Animatable x-axis\\n, x: function(x, relative) {\\n    if(this.target() instanceof SVG.G){\\n      this.transform({x:x}, relative)\\n      return this\\n    }\\n\\n    var num = new SVG.Number().morph(x)\\n    num.relative = relative\\n    return this.add('x', num)\\n  }\\n  // Animatable y-axis\\n, y: function(y, relative) {\\n    if(this.target() instanceof SVG.G){\\n      this.transform({y:y}, relative)\\n      return this\\n    }\\n\\n    var num = new SVG.Number().morph(y)\\n    num.relative = relative\\n    return this.add('y', num)\\n  }\\n  // Animatable center x-axis\\n, cx: function(x) {\\n    return this.add('cx', new SVG.Number().morph(x))\\n  }\\n  // Animatable center y-axis\\n, cy: function(y) {\\n    return this.add('cy', new SVG.Number().morph(y))\\n  }\\n  // Add animatable move\\n, move: function(x, y) {\\n    return this.x(x).y(y)\\n  }\\n  // Add animatable center\\n, center: function(x, y) {\\n    return this.cx(x).cy(y)\\n  }\\n  // Add animatable size\\n, size: function(width, height) {\\n    if (this.target() instanceof SVG.Text) {\\n      // animate font size for Text elements\\n      this.attr('font-size', width)\\n\\n    } else {\\n      // animate bbox based size for all other elements\\n      var box\\n\\n      if(!width || !height){\\n        box = this.target().bbox()\\n      }\\n\\n      if(!width){\\n        width = box.width / box.height  * height\\n      }\\n\\n      if(!height){\\n        height = box.height / box.width  * width\\n      }\\n\\n      this.add('width' , new SVG.Number().morph(width))\\n          .add('height', new SVG.Number().morph(height))\\n\\n    }\\n\\n    return this\\n  }\\n  // Add animatable plot\\n, plot: function(p) {\\n    return this.add('plot', this.target().array().morph(p))\\n  }\\n  // Add leading method\\n, leading: function(value) {\\n    return this.target().leading ?\\n      this.add('leading', new SVG.Number().morph(value)) :\\n      this\\n  }\\n  // Add animatable viewbox\\n, viewbox: function(x, y, width, height) {\\n    if (this.target() instanceof SVG.Container) {\\n      this.add('viewbox', new SVG.ViewBox(x, y, width, height))\\n    }\\n\\n    return this\\n  }\\n, update: function(o) {\\n    if (this.target() instanceof SVG.Stop) {\\n      if (typeof o == 'number' || o instanceof SVG.Number) {\\n        return this.update({\\n          offset:  arguments[0]\\n        , color:   arguments[1]\\n        , opacity: arguments[2]\\n        })\\n      }\\n\\n      if (o.opacity != null) this.attr('stop-opacity', o.opacity)\\n      if (o.color   != null) this.attr('stop-color', o.color)\\n      if (o.offset  != null) this.attr('offset', o.offset)\\n    }\\n\\n    return this\\n  }\\n})\\n\\nSVG.BBox = SVG.invent({\\n  // Initialize\\n  create: function(element) {\\n    // get values if element is given\\n    if (element) {\\n      var box\\n\\n      // yes this is ugly, but Firefox can be a bitch when it comes to elements that are not yet rendered\\n      try {\\n\\n        // the element is NOT in the dom, throw error\\n        if(!document.documentElement.contains(element.node)) throw new Exception('Element not in the dom')\\n\\n        // find native bbox\\n        box = element.node.getBBox()\\n      } catch(e) {\\n        if(element instanceof SVG.Shape){\\n          var clone = element.clone(SVG.parser.draw).show()\\n          box = clone.bbox()\\n          clone.remove()\\n        }else{\\n          box = {\\n            x:      element.node.clientLeft\\n          , y:      element.node.clientTop\\n          , width:  element.node.clientWidth\\n          , height: element.node.clientHeight\\n          }\\n        }\\n      }\\n\\n      // plain x and y\\n      this.x = box.x\\n      this.y = box.y\\n\\n      // plain width and height\\n      this.width  = box.width\\n      this.height = box.height\\n    }\\n\\n    // add center, right and bottom\\n    fullBox(this)\\n  }\\n\\n  // Define Parent\\n, parent: SVG.Element\\n\\n  // Constructor\\n, construct: {\\n    // Get bounding box\\n    bbox: function() {\\n      return new SVG.BBox(this)\\n    }\\n  }\\n\\n})\\n\\nSVG.TBox = SVG.invent({\\n  // Initialize\\n  create: function(element) {\\n    // get values if element is given\\n    if (element) {\\n      var t   = element.ctm().extract()\\n        , box = element.bbox()\\n\\n      // width and height including transformations\\n      this.width  = box.width  * t.scaleX\\n      this.height = box.height * t.scaleY\\n\\n      // x and y including transformations\\n      this.x = box.x + t.x\\n      this.y = box.y + t.y\\n    }\\n\\n    // add center, right and bottom\\n    fullBox(this)\\n  }\\n\\n  // Define Parent\\n, parent: SVG.Element\\n\\n  // Constructor\\n, construct: {\\n    // Get transformed bounding box\\n    tbox: function() {\\n      return new SVG.TBox(this)\\n    }\\n  }\\n\\n})\\n\\n\\nSVG.RBox = SVG.invent({\\n  // Initialize\\n  create: function(element) {\\n    if (element) {\\n      var e    = element.doc().parent()\\n        , box  = element.node.getBoundingClientRect()\\n        , zoom = 1\\n\\n      // get screen offset\\n      this.x = box.left\\n      this.y = box.top\\n\\n      // subtract parent offset\\n      this.x -= e.offsetLeft\\n      this.y -= e.offsetTop\\n\\n      while (e = e.offsetParent) {\\n        this.x -= e.offsetLeft\\n        this.y -= e.offsetTop\\n      }\\n\\n      // calculate cumulative zoom from svg documents\\n      e = element\\n      while (e.parent && (e = e.parent())) {\\n        if (e.viewbox) {\\n          zoom *= e.viewbox().zoom\\n          this.x -= e.x() || 0\\n          this.y -= e.y() || 0\\n        }\\n      }\\n\\n      // recalculate viewbox distortion\\n      this.width  = box.width  /= zoom\\n      this.height = box.height /= zoom\\n    }\\n\\n    // add center, right and bottom\\n    fullBox(this)\\n\\n    // offset by window scroll position, because getBoundingClientRect changes when window is scrolled\\n    this.x += window.pageXOffset\\n    this.y += window.pageYOffset\\n  }\\n\\n  // define Parent\\n, parent: SVG.Element\\n\\n  // Constructor\\n, construct: {\\n    // Get rect box\\n    rbox: function() {\\n      return new SVG.RBox(this)\\n    }\\n  }\\n\\n})\\n\\n// Add universal merge method\\n;[SVG.BBox, SVG.TBox, SVG.RBox].forEach(function(c) {\\n\\n  SVG.extend(c, {\\n    // Merge rect box with another, return a new instance\\n    merge: function(box) {\\n      var b = new c()\\n\\n      // merge boxes\\n      b.x      = Math.min(this.x, box.x)\\n      b.y      = Math.min(this.y, box.y)\\n      b.width  = Math.max(this.x + this.width,  box.x + box.width)  - b.x\\n      b.height = Math.max(this.y + this.height, box.y + box.height) - b.y\\n\\n      return fullBox(b)\\n    }\\n\\n  })\\n\\n})\\n\\nSVG.Matrix = SVG.invent({\\n  // Initialize\\n  create: function(source) {\\n    var i, base = arrayToMatrix([1, 0, 0, 1, 0, 0])\\n\\n    // ensure source as object\\n    source = source instanceof SVG.Element ?\\n      source.matrixify() :\\n    typeof source === 'string' ?\\n      stringToMatrix(source) :\\n    arguments.length == 6 ?\\n      arrayToMatrix([].slice.call(arguments)) :\\n    typeof source === 'object' ?\\n      source : base\\n\\n    // merge source\\n    for (i = abcdef.length - 1; i >= 0; --i)\\n      this[abcdef[i]] = source && typeof source[abcdef[i]] === 'number' ?\\n        source[abcdef[i]] : base[abcdef[i]]\\n  }\\n\\n  // Add methods\\n, extend: {\\n    // Extract individual transformations\\n    extract: function() {\\n      // find delta transform points\\n      var px    = deltaTransformPoint(this, 0, 1)\\n        , py    = deltaTransformPoint(this, 1, 0)\\n        , skewX = 180 / Math.PI * Math.atan2(px.y, px.x) - 90\\n\\n      return {\\n        // translation\\n        x:        this.e\\n      , y:        this.f\\n      , transformedX:(this.e * Math.cos(skewX * Math.PI / 180) + this.f * Math.sin(skewX * Math.PI / 180)) / Math.sqrt(this.a * this.a + this.b * this.b)\\n      , transformedY:(this.f * Math.cos(skewX * Math.PI / 180) + this.e * Math.sin(-skewX * Math.PI / 180)) / Math.sqrt(this.c * this.c + this.d * this.d)\\n        // skew\\n      , skewX:    -skewX\\n      , skewY:    180 / Math.PI * Math.atan2(py.y, py.x)\\n        // scale\\n      , scaleX:   Math.sqrt(this.a * this.a + this.b * this.b)\\n      , scaleY:   Math.sqrt(this.c * this.c + this.d * this.d)\\n        // rotation\\n      , rotation: skewX\\n      , a: this.a\\n      , b: this.b\\n      , c: this.c\\n      , d: this.d\\n      , e: this.e\\n      , f: this.f\\n      , matrix: new SVG.Matrix(this)\\n      }\\n    }\\n    // Clone matrix\\n  , clone: function() {\\n      return new SVG.Matrix(this)\\n    }\\n    // Morph one matrix into another\\n  , morph: function(matrix) {\\n      // store new destination\\n      this.destination = new SVG.Matrix(matrix)\\n\\n      return this\\n    }\\n    // Get morphed matrix at a given position\\n  , at: function(pos) {\\n      // make sure a destination is defined\\n      if (!this.destination) return this\\n\\n      // calculate morphed matrix at a given position\\n      var matrix = new SVG.Matrix({\\n        a: this.a + (this.destination.a - this.a) * pos\\n      , b: this.b + (this.destination.b - this.b) * pos\\n      , c: this.c + (this.destination.c - this.c) * pos\\n      , d: this.d + (this.destination.d - this.d) * pos\\n      , e: this.e + (this.destination.e - this.e) * pos\\n      , f: this.f + (this.destination.f - this.f) * pos\\n      })\\n\\n      // process parametric rotation if present\\n      if (this.param && this.param.to) {\\n        // calculate current parametric position\\n        var param = {\\n          rotation: this.param.from.rotation + (this.param.to.rotation - this.param.from.rotation) * pos\\n        , cx:       this.param.from.cx\\n        , cy:       this.param.from.cy\\n        }\\n\\n        // rotate matrix\\n        matrix = matrix.rotate(\\n          (this.param.to.rotation - this.param.from.rotation * 2) * pos\\n        , param.cx\\n        , param.cy\\n        )\\n\\n        // store current parametric values\\n        matrix.param = param\\n      }\\n\\n      return matrix\\n    }\\n    // Multiplies by given matrix\\n  , multiply: function(matrix) {\\n      return new SVG.Matrix(this.native().multiply(parseMatrix(matrix).native()))\\n    }\\n    // Inverses matrix\\n  , inverse: function() {\\n      return new SVG.Matrix(this.native().inverse())\\n    }\\n    // Translate matrix\\n  , translate: function(x, y) {\\n      return new SVG.Matrix(this.native().translate(x || 0, y || 0))\\n    }\\n    // Scale matrix\\n  , scale: function(x, y, cx, cy) {\\n      // support uniformal scale\\n      if (arguments.length == 1) {\\n        y = x\\n      } else if (arguments.length == 3) {\\n        cy = cx\\n        cx = y\\n        y = x\\n      }\\n\\n      return this.around(cx, cy, new SVG.Matrix(x, 0, 0, y, 0, 0))\\n    }\\n    // Rotate matrix\\n  , rotate: function(r, cx, cy) {\\n      // convert degrees to radians\\n      r = SVG.utils.radians(r)\\n\\n      return this.around(cx, cy, new SVG.Matrix(Math.cos(r), Math.sin(r), -Math.sin(r), Math.cos(r), 0, 0))\\n    }\\n    // Flip matrix on x or y, at a given offset\\n  , flip: function(a, o) {\\n      return a == 'x' ? this.scale(-1, 1, o, 0) : this.scale(1, -1, 0, o)\\n    }\\n    // Skew\\n  , skew: function(x, y, cx, cy) {\\n      // support uniformal skew\\n      if (arguments.length == 1) {\\n        y = x\\n      } else if (arguments.length == 3) {\\n        cy = cx\\n        cx = y\\n        y = x\\n      }\\n\\n      // convert degrees to radians\\n      x = SVG.utils.radians(x)\\n      y = SVG.utils.radians(y)\\n\\n      return this.around(cx, cy, new SVG.Matrix(1, Math.tan(y), Math.tan(x), 1, 0, 0))\\n    }\\n    // SkewX\\n  , skewX: function(x, cx, cy) {\\n      return this.skew(x, 0, cx, cy)\\n    }\\n    // SkewY\\n  , skewY: function(y, cx, cy) {\\n      return this.skew(0, y, cx, cy)\\n    }\\n    // Transform around a center point\\n  , around: function(cx, cy, matrix) {\\n      return this\\n        .multiply(new SVG.Matrix(1, 0, 0, 1, cx || 0, cy || 0))\\n        .multiply(matrix)\\n        .multiply(new SVG.Matrix(1, 0, 0, 1, -cx || 0, -cy || 0))\\n    }\\n    // Convert to native SVGMatrix\\n  , native: function() {\\n      // create new matrix\\n      var matrix = SVG.parser.native.createSVGMatrix()\\n\\n      // update with current values\\n      for (var i = abcdef.length - 1; i >= 0; i--)\\n        matrix[abcdef[i]] = this[abcdef[i]]\\n\\n      return matrix\\n    }\\n    // Convert matrix to string\\n  , toString: function() {\\n      return 'matrix(' + this.a + ',' + this.b + ',' + this.c + ',' + this.d + ',' + this.e + ',' + this.f + ')'\\n    }\\n  }\\n\\n  // Define parent\\n, parent: SVG.Element\\n\\n  // Add parent method\\n, construct: {\\n    // Get current matrix\\n    ctm: function() {\\n      return new SVG.Matrix(this.node.getCTM())\\n    },\\n    // Get current screen matrix\\n    screenCTM: function() {\\n      return new SVG.Matrix(this.node.getScreenCTM())\\n    }\\n\\n  }\\n\\n})\\n\\nSVG.Point = SVG.invent({\\n  // Initialize\\n  create: function(x,y) {\\n    var i, source, base = {x:0, y:0}\\n\\n    // ensure source as object\\n    source = Array.isArray(x) ?\\n      {x:x[0], y:x[1]} :\\n    typeof x === 'object' ?\\n      {x:x.x, y:x.y} :\\n    x != null ?\\n      {x:x, y:(y != null ? y : x)} : base // If y has no value, then x is used has its value\\n\\n    // merge source\\n    this.x = source.x\\n    this.y = source.y\\n  }\\n\\n  // Add methods\\n, extend: {\\n    // Clone point\\n    clone: function() {\\n      return new SVG.Point(this)\\n    }\\n    // Morph one point into another\\n  , morph: function(x, y) {\\n      // store new destination\\n      this.destination = new SVG.Point(x, y)\\n\\n      return this\\n    }\\n    // Get morphed point at a given position\\n  , at: function(pos) {\\n      // make sure a destination is defined\\n      if (!this.destination) return this\\n\\n      // calculate morphed matrix at a given position\\n      var point = new SVG.Point({\\n        x: this.x + (this.destination.x - this.x) * pos\\n      , y: this.y + (this.destination.y - this.y) * pos\\n      })\\n\\n      return point\\n    }\\n    // Convert to native SVGPoint\\n  , native: function() {\\n      // create new point\\n      var point = SVG.parser.native.createSVGPoint()\\n\\n      // update with current values\\n      point.x = this.x\\n      point.y = this.y\\n\\n      return point\\n    }\\n    // transform point with matrix\\n  , transform: function(matrix) {\\n      return new SVG.Point(this.native().matrixTransform(matrix.native()))\\n    }\\n\\n  }\\n\\n})\\n\\nSVG.extend(SVG.Element, {\\n\\n  // Get point\\n  point: function(x, y) {\\n    return new SVG.Point(x,y).transform(this.screenCTM().inverse());\\n  }\\n\\n})\\n\\nSVG.extend(SVG.Element, {\\n  // Set svg element attribute\\n  attr: function(a, v, n) {\\n    // act as full getter\\n    if (a == null) {\\n      // get an object of attributes\\n      a = {}\\n      v = this.node.attributes\\n      for (n = v.length - 1; n >= 0; n--)\\n        a[v[n].nodeName] = SVG.regex.isNumber.test(v[n].nodeValue) ? parseFloat(v[n].nodeValue) : v[n].nodeValue\\n\\n      return a\\n\\n    } else if (typeof a == 'object') {\\n      // apply every attribute individually if an object is passed\\n      for (v in a) this.attr(v, a[v])\\n\\n    } else if (v === null) {\\n        // remove value\\n        this.node.removeAttribute(a)\\n\\n    } else if (v == null) {\\n      // act as a getter if the first and only argument is not an object\\n      v = this.node.getAttribute(a)\\n      return v == null ?\\n        SVG.defaults.attrs[a] :\\n      SVG.regex.isNumber.test(v) ?\\n        parseFloat(v) : v\\n\\n    } else {\\n      // BUG FIX: some browsers will render a stroke if a color is given even though stroke width is 0\\n      if (a == 'stroke-width')\\n        this.attr('stroke', parseFloat(v) > 0 ? this._stroke : null)\\n      else if (a == 'stroke')\\n        this._stroke = v\\n\\n      // convert image fill and stroke to patterns\\n      if (a == 'fill' || a == 'stroke') {\\n        if (SVG.regex.isImage.test(v))\\n          v = this.doc().defs().image(v, 0, 0)\\n\\n        if (v instanceof SVG.Image)\\n          v = this.doc().defs().pattern(0, 0, function() {\\n            this.add(v)\\n          })\\n      }\\n\\n      // ensure correct numeric values (also accepts NaN and Infinity)\\n      if (typeof v === 'number')\\n        v = new SVG.Number(v)\\n\\n      // ensure full hex color\\n      else if (SVG.Color.isColor(v))\\n        v = new SVG.Color(v)\\n\\n      // parse array values\\n      else if (Array.isArray(v))\\n        v = new SVG.Array(v)\\n\\n      // store parametric transformation values locally\\n      else if (v instanceof SVG.Matrix && v.param)\\n        this.param = v.param\\n\\n      // if the passed attribute is leading...\\n      if (a == 'leading') {\\n        // ... call the leading method instead\\n        if (this.leading)\\n          this.leading(v)\\n      } else {\\n        // set given attribute on node\\n        typeof n === 'string' ?\\n          this.node.setAttributeNS(n, a, v.toString()) :\\n          this.node.setAttribute(a, v.toString())\\n      }\\n\\n      // rebuild if required\\n      if (this.rebuild && (a == 'font-size' || a == 'x'))\\n        this.rebuild(a, v)\\n    }\\n\\n    return this\\n  }\\n})\\nSVG.extend(SVG.Element, {\\n  // Add transformations\\n  transform: function(o, relative) {\\n    // get target in case of the fx module, otherwise reference this\\n    var target = this\\n      , matrix\\n\\n    // act as a getter\\n    if (typeof o !== 'object') {\\n      // get current matrix\\n      matrix = new SVG.Matrix(target).extract()\\n\\n      return typeof o === 'string' ? matrix[o] : matrix\\n    }\\n\\n    // get current matrix\\n    matrix = new SVG.Matrix(target)\\n\\n    // ensure relative flag\\n    relative = !!relative || !!o.relative\\n\\n    // act on matrix\\n    if (o.a != null) {\\n      matrix = relative ?\\n        // relative\\n        matrix.multiply(new SVG.Matrix(o)) :\\n        // absolute\\n        new SVG.Matrix(o)\\n\\n    // act on rotation\\n    } else if (o.rotation != null) {\\n      // ensure centre point\\n      ensureCentre(o, target)\\n\\n      // apply transformation\\n      matrix = relative ?\\n        // relative\\n        matrix.rotate(o.rotation, o.cx, o.cy) :\\n        // absolute\\n        matrix.rotate(o.rotation - matrix.extract().rotation, o.cx, o.cy)\\n\\n    // act on scale\\n    } else if (o.scale != null || o.scaleX != null || o.scaleY != null) {\\n      // ensure centre point\\n      ensureCentre(o, target)\\n\\n      // ensure scale values on both axes\\n      o.scaleX = o.scale != null ? o.scale : o.scaleX != null ? o.scaleX : 1\\n      o.scaleY = o.scale != null ? o.scale : o.scaleY != null ? o.scaleY : 1\\n\\n      if (!relative) {\\n        // absolute; multiply inversed values\\n        var e = matrix.extract()\\n        o.scaleX = o.scaleX * 1 / e.scaleX\\n        o.scaleY = o.scaleY * 1 / e.scaleY\\n      }\\n\\n      matrix = matrix.scale(o.scaleX, o.scaleY, o.cx, o.cy)\\n\\n    // act on skew\\n    } else if (o.skew != null || o.skewX != null || o.skewY != null) {\\n      // ensure centre point\\n      ensureCentre(o, target)\\n\\n      // ensure skew values on both axes\\n      o.skewX = o.skew != null ? o.skew : o.skewX != null ? o.skewX : 0\\n      o.skewY = o.skew != null ? o.skew : o.skewY != null ? o.skewY : 0\\n\\n      if (!relative) {\\n        // absolute; reset skew values\\n        var e = matrix.extract()\\n        matrix = matrix.multiply(new SVG.Matrix().skew(e.skewX, e.skewY, o.cx, o.cy).inverse())\\n      }\\n\\n      matrix = matrix.skew(o.skewX, o.skewY, o.cx, o.cy)\\n\\n    // act on flip\\n    } else if (o.flip) {\\n      matrix = matrix.flip(\\n        o.flip\\n      , o.offset == null ? target.bbox()['c' + o.flip] : o.offset\\n      )\\n\\n    // act on translate\\n    } else if (o.x != null || o.y != null) {\\n      if (relative) {\\n        // relative\\n        matrix = matrix.translate(o.x, o.y)\\n      } else {\\n        // absolute\\n        if (o.x != null) matrix.e = o.x\\n        if (o.y != null) matrix.f = o.y\\n      }\\n    }\\n\\n    return this.attr('transform', matrix)\\n  }\\n})\\n\\nSVG.extend(SVG.FX, {\\n  transform: function(o, relative) {\\n    // get target in case of the fx module, otherwise reference this\\n    var target = this.target()\\n      , matrix\\n\\n    // act as a getter\\n    if (typeof o !== 'object') {\\n      // get current matrix\\n      matrix = new SVG.Matrix(target).extract()\\n\\n      return typeof o === 'string' ? matrix[o] : matrix\\n    }\\n\\n    // ensure relative flag\\n    relative = !!relative || !!o.relative\\n\\n    // act on matrix\\n    if (o.a != null) {\\n      matrix = new SVG.Matrix(o)\\n\\n    // act on rotation\\n    } else if (o.rotation != null) {\\n      // ensure centre point\\n      ensureCentre(o, target)\\n\\n      // apply transformation\\n      matrix = new SVG.Rotate(o.rotation, o.cx, o.cy)\\n\\n    // act on scale\\n    } else if (o.scale != null || o.scaleX != null || o.scaleY != null) {\\n      // ensure centre point\\n      ensureCentre(o, target)\\n\\n      // ensure scale values on both axes\\n      o.scaleX = o.scale != null ? o.scale : o.scaleX != null ? o.scaleX : 1\\n      o.scaleY = o.scale != null ? o.scale : o.scaleY != null ? o.scaleY : 1\\n\\n      matrix = new SVG.Scale(o.scaleX, o.scaleY, o.cx, o.cy)\\n\\n    // act on skew\\n    } else if (o.skewX != null || o.skewY != null) {\\n      // ensure centre point\\n      ensureCentre(o, target)\\n\\n      // ensure skew values on both axes\\n      o.skewX = o.skewX != null ? o.skewX : 0\\n      o.skewY = o.skewY != null ? o.skewY : 0\\n\\n      matrix = new SVG.Skew(o.skewX, o.skewY, o.cx, o.cy)\\n\\n    // act on flip\\n    } else if (o.flip) {\\n      matrix = new SVG.Matrix().morph(new SVG.Matrix().flip(\\n        o.flip\\n      , o.offset == null ? target.bbox()['c' + o.flip] : o.offset\\n      ))\\n\\n    // act on translate\\n    } else if (o.x != null || o.y != null) {\\n      matrix = new SVG.Translate(o.x, o.y)\\n    }\\n\\n    if(!matrix) return this\\n\\n    matrix.relative = relative\\n\\n    this.last().transforms.push(matrix)\\n\\n    setTimeout(function(){this.start()}.bind(this), 0)\\n\\n    return this\\n  }\\n})\\n\\nSVG.extend(SVG.Element, {\\n  // Reset all transformations\\n  untransform: function() {\\n    return this.attr('transform', null)\\n  },\\n  // merge the whole transformation chain into one matrix and returns it\\n  matrixify: function() {\\n\\n    var matrix = (this.attr('transform') || '')\\n      // split transformations\\n      .split(/\\\\)\\\\s*,?\\\\s*/).slice(0,-1).map(function(str){\\n        // generate key => value pairs\\n        var kv = str.trim().split('(')\\n        return [kv[0], kv[1].split(SVG.regex.matrixElements).map(function(str){ return parseFloat(str) })]\\n      })\\n      // calculate every transformation into one matrix\\n      .reduce(function(matrix, transform){\\n\\n        if(transform[0] == 'matrix') return matrix.multiply(arrayToMatrix(transform[1]))\\n        return matrix[transform[0]].apply(matrix, transform[1])\\n\\n      }, new SVG.Matrix())\\n\\n    return matrix\\n  },\\n  // add an element to another parent without changing the visual representation on the screen\\n  toParent: function(parent) {\\n    if(this == parent) return this\\n    var ctm = this.screenCTM()\\n    var temp = parent.rect(1,1)\\n    var pCtm = temp.screenCTM().inverse()\\n    temp.remove()\\n\\n    this.addTo(parent).untransform().transform(pCtm.multiply(ctm))\\n\\n    return this\\n  },\\n  // same as above with parent equals root-svg\\n  toDoc: function() {\\n    return this.toParent(this.doc())\\n  }\\n\\n})\\n\\nSVG.Transformation = SVG.invent({\\n\\n  create: function(source, inversed){\\n\\n    if(arguments.length > 1 && typeof inversed != 'boolean'){\\n      return this.create([].slice.call(arguments))\\n    }\\n\\n    if(typeof source == 'object'){\\n      for(var i = 0, len = this.arguments.length; i < len; ++i){\\n        this[this.arguments[i]] = source[this.arguments[i]]\\n      }\\n    }\\n\\n    if(Array.isArray(source)){\\n      for(var i = 0, len = this.arguments.length; i < len; ++i){\\n        this[this.arguments[i]] = source[i]\\n      }\\n    }\\n\\n    this.inversed = false\\n\\n    if(inversed === true){\\n      this.inversed = true\\n    }\\n\\n  }\\n\\n, extend: {\\n\\n    at: function(pos){\\n\\n      var params = []\\n\\n      for(var i = 0, len = this.arguments.length; i < len; ++i){\\n        params.push(this[this.arguments[i]])\\n      }\\n\\n      var m = this._undo || new SVG.Matrix()\\n\\n      m = new SVG.Matrix().morph(SVG.Matrix.prototype[this.method].apply(m, params)).at(pos)\\n\\n      return this.inversed ? m.inverse() : m\\n\\n    }\\n\\n  , undo: function(o){\\n      for(var i = 0, len = this.arguments.length; i < len; ++i){\\n        o[this.arguments[i]] = typeof this[this.arguments[i]] == 'undefined' ? 0 : o[this.arguments[i]]\\n      }\\n\\n      // The method SVG.Matrix.extract which was used before calling this\\n      // method to obtain a value for the parameter o doesn't return a cx and\\n      // a cy so we use the ones that were provided to this object at its creation\\n      o.cx = this.cx\\n      o.cy = this.cy\\n\\n      this._undo = new SVG[capitalize(this.method)](o, true).at(1)\\n\\n      return this\\n    }\\n\\n  }\\n\\n})\\n\\nSVG.Translate = SVG.invent({\\n\\n  parent: SVG.Matrix\\n, inherit: SVG.Transformation\\n\\n, create: function(source, inversed){\\n    if(typeof source == 'object') this.constructor.call(this, source, inversed)\\n    else this.constructor.call(this, [].slice.call(arguments))\\n  }\\n\\n, extend: {\\n    arguments: ['transformedX', 'transformedY']\\n  , method: 'translate'\\n  }\\n\\n})\\n\\nSVG.Rotate = SVG.invent({\\n\\n  parent: SVG.Matrix\\n, inherit: SVG.Transformation\\n\\n, create: function(source, inversed){\\n    if(typeof source == 'object') this.constructor.call(this, source, inversed)\\n    else this.constructor.call(this, [].slice.call(arguments))\\n  }\\n\\n, extend: {\\n    arguments: ['rotation', 'cx', 'cy']\\n  , method: 'rotate'\\n  , at: function(pos){\\n      var m = new SVG.Matrix().rotate(new SVG.Number().morph(this.rotation - (this._undo ? this._undo.rotation : 0)).at(pos), this.cx, this.cy)\\n      return this.inversed ? m.inverse() : m\\n    }\\n  , undo: function(o){\\n      this._undo = o\\n    }\\n  }\\n\\n})\\n\\nSVG.Scale = SVG.invent({\\n\\n  parent: SVG.Matrix\\n, inherit: SVG.Transformation\\n\\n, create: function(source, inversed){\\n    if(typeof source == 'object') this.constructor.call(this, source, inversed)\\n    else this.constructor.call(this, [].slice.call(arguments))\\n  }\\n\\n, extend: {\\n    arguments: ['scaleX', 'scaleY', 'cx', 'cy']\\n  , method: 'scale'\\n  }\\n\\n})\\n\\nSVG.Skew = SVG.invent({\\n\\n  parent: SVG.Matrix\\n, inherit: SVG.Transformation\\n\\n, create: function(source, inversed){\\n    if(typeof source == 'object') this.constructor.call(this, source, inversed)\\n    else this.constructor.call(this, [].slice.call(arguments))\\n  }\\n\\n, extend: {\\n    arguments: ['skewX', 'skewY', 'cx', 'cy']\\n  , method: 'skew'\\n  }\\n\\n})\\n\\nSVG.extend(SVG.Element, {\\n  // Dynamic style generator\\n  style: function(s, v) {\\n    if (arguments.length == 0) {\\n      // get full style\\n      return this.node.style.cssText || ''\\n\\n    } else if (arguments.length < 2) {\\n      // apply every style individually if an object is passed\\n      if (typeof s == 'object') {\\n        for (v in s) this.style(v, s[v])\\n\\n      } else if (SVG.regex.isCss.test(s)) {\\n        // parse css string\\n        s = s.split(';')\\n\\n        // apply every definition individually\\n        for (var i = 0; i < s.length; i++) {\\n          v = s[i].split(':')\\n          this.style(v[0].replace(/\\\\s+/g, ''), v[1])\\n        }\\n      } else {\\n        // act as a getter if the first and only argument is not an object\\n        return this.node.style[camelCase(s)]\\n      }\\n\\n    } else {\\n      this.node.style[camelCase(s)] = v === null || SVG.regex.isBlank.test(v) ? '' : v\\n    }\\n\\n    return this\\n  }\\n})\\nSVG.Parent = SVG.invent({\\n  // Initialize node\\n  create: function(element) {\\n    this.constructor.call(this, element)\\n  }\\n\\n  // Inherit from\\n, inherit: SVG.Element\\n\\n  // Add class methods\\n, extend: {\\n    // Returns all child elements\\n    children: function() {\\n      return SVG.utils.map(SVG.utils.filterSVGElements(this.node.childNodes), function(node) {\\n        return SVG.adopt(node)\\n      })\\n    }\\n    // Add given element at a position\\n  , add: function(element, i) {\\n      if (i == null)\\n        this.node.appendChild(element.node)\\n      else if (element.node != this.node.childNodes[i])\\n        this.node.insertBefore(element.node, this.node.childNodes[i])\\n\\n      return this\\n    }\\n    // Basically does the same as `add()` but returns the added element instead\\n  , put: function(element, i) {\\n      this.add(element, i)\\n      return element\\n    }\\n    // Checks if the given element is a child\\n  , has: function(element) {\\n      return this.index(element) >= 0\\n    }\\n    // Gets index of given element\\n  , index: function(element) {\\n      return [].slice.call(this.node.childNodes).indexOf(element.node)\\n    }\\n    // Get a element at the given index\\n  , get: function(i) {\\n      return SVG.adopt(this.node.childNodes[i])\\n    }\\n    // Get first child\\n  , first: function() {\\n      return this.get(0)\\n    }\\n    // Get the last child\\n  , last: function() {\\n      return this.get(this.node.childNodes.length - 1)\\n    }\\n    // Iterates over all children and invokes a given block\\n  , each: function(block, deep) {\\n      var i, il\\n        , children = this.children()\\n\\n      for (i = 0, il = children.length; i < il; i++) {\\n        if (children[i] instanceof SVG.Element)\\n          block.apply(children[i], [i, children])\\n\\n        if (deep && (children[i] instanceof SVG.Container))\\n          children[i].each(block, deep)\\n      }\\n\\n      return this\\n    }\\n    // Remove a given child\\n  , removeElement: function(element) {\\n      this.node.removeChild(element.node)\\n\\n      return this\\n    }\\n    // Remove all elements in this container\\n  , clear: function() {\\n      // remove children\\n      while(this.node.hasChildNodes())\\n        this.node.removeChild(this.node.lastChild)\\n\\n      // remove defs reference\\n      delete this._defs\\n\\n      return this\\n    }\\n  , // Get defs\\n    defs: function() {\\n      return this.doc().defs()\\n    }\\n  }\\n\\n})\\n\\nSVG.extend(SVG.Parent, {\\n\\n  ungroup: function(parent, depth) {\\n    if(depth === 0 || this instanceof SVG.Defs) return this\\n\\n    parent = parent || (this instanceof SVG.Doc ? this : this.parent(SVG.Parent))\\n    depth = depth || Infinity\\n\\n    this.each(function(){\\n      if(this instanceof SVG.Defs) return this\\n      if(this instanceof SVG.Parent) return this.ungroup(parent, depth-1)\\n      return this.toParent(parent)\\n    })\\n\\n    this.node.firstChild || this.remove()\\n\\n    return this\\n  },\\n\\n  flatten: function(parent, depth) {\\n    return this.ungroup(parent, depth)\\n  }\\n\\n})\\nSVG.Container = SVG.invent({\\n  // Initialize node\\n  create: function(element) {\\n    this.constructor.call(this, element)\\n  }\\n\\n  // Inherit from\\n, inherit: SVG.Parent\\n\\n})\\n\\nSVG.ViewBox = SVG.invent({\\n\\n  create: function(source) {\\n    var i, base = [0, 0, 0, 0]\\n\\n    var x, y, width, height, box, view, we, he\\n      , wm   = 1 // width multiplier\\n      , hm   = 1 // height multiplier\\n      , reg  = /[+-]?(?:\\\\d+(?:\\\\.\\\\d*)?|\\\\.\\\\d+)(?:e[+-]?\\\\d+)?/gi\\n\\n    if(source instanceof SVG.Element){\\n\\n      we = source\\n      he = source\\n      view = (source.attr('viewBox') || '').match(reg)\\n      box = source.bbox\\n\\n      // get dimensions of current node\\n      width  = new SVG.Number(source.width())\\n      height = new SVG.Number(source.height())\\n\\n      // find nearest non-percentual dimensions\\n      while (width.unit == '%') {\\n        wm *= width.value\\n        width = new SVG.Number(we instanceof SVG.Doc ? we.parent().offsetWidth : we.parent().width())\\n        we = we.parent()\\n      }\\n      while (height.unit == '%') {\\n        hm *= height.value\\n        height = new SVG.Number(he instanceof SVG.Doc ? he.parent().offsetHeight : he.parent().height())\\n        he = he.parent()\\n      }\\n\\n      // ensure defaults\\n      this.x      = 0\\n      this.y      = 0\\n      this.width  = width  * wm\\n      this.height = height * hm\\n      this.zoom   = 1\\n\\n      if (view) {\\n        // get width and height from viewbox\\n        x      = parseFloat(view[0])\\n        y      = parseFloat(view[1])\\n        width  = parseFloat(view[2])\\n        height = parseFloat(view[3])\\n\\n        // calculate zoom accoring to viewbox\\n        this.zoom = ((this.width / this.height) > (width / height)) ?\\n          this.height / height :\\n          this.width  / width\\n\\n        // calculate real pixel dimensions on parent SVG.Doc element\\n        this.x      = x\\n        this.y      = y\\n        this.width  = width\\n        this.height = height\\n\\n      }\\n\\n    }else{\\n\\n      // ensure source as object\\n      source = typeof source === 'string' ?\\n        source.match(reg).map(function(el){ return parseFloat(el) }) :\\n      Array.isArray(source) ?\\n        source :\\n      typeof source == 'object' ?\\n        [source.x, source.y, source.width, source.height] :\\n      arguments.length == 4 ?\\n        [].slice.call(arguments) :\\n        base\\n\\n      this.x = source[0]\\n      this.y = source[1]\\n      this.width = source[2]\\n      this.height = source[3]\\n    }\\n\\n\\n  }\\n\\n, extend: {\\n\\n    toString: function() {\\n      return this.x + ' ' + this.y + ' ' + this.width + ' ' + this.height\\n    }\\n  , morph: function(v){\\n\\n      var v = arguments.length == 1 ?\\n        [v.x, v.y, v.width, v.height] :\\n        [].slice.call(arguments)\\n\\n      this.destination = new SVG.ViewBox(v)\\n\\n      return this\\n\\n    }\\n\\n  , at: function(pos) {\\n\\n    if(!this.destination) return this\\n\\n    return new SVG.ViewBox([\\n        this.x + (this.destination.x - this.x) * pos\\n      , this.y + (this.destination.y - this.y) * pos\\n      , this.width + (this.destination.width - this.width) * pos\\n      , this.height + (this.destination.height - this.height) * pos\\n    ])\\n\\n    }\\n\\n  }\\n\\n  // Define parent\\n, parent: SVG.Container\\n\\n  // Add parent method\\n, construct: {\\n\\n    // get/set viewbox\\n    viewbox: function(v) {\\n      if (arguments.length == 0)\\n        // act as a getter if there are no arguments\\n        return new SVG.ViewBox(this)\\n\\n      // otherwise act as a setter\\n      v = arguments.length == 1 ?\\n        [v.x, v.y, v.width, v.height] :\\n        [].slice.call(arguments)\\n\\n      return this.attr('viewBox', v)\\n    }\\n\\n  }\\n\\n})\\n// Add events to elements\\n;[  'click'\\n  , 'dblclick'\\n  , 'mousedown'\\n  , 'mouseup'\\n  , 'mouseover'\\n  , 'mouseout'\\n  , 'mousemove'\\n  // , 'mouseenter' -> not supported by IE\\n  // , 'mouseleave' -> not supported by IE\\n  , 'touchstart'\\n  , 'touchmove'\\n  , 'touchleave'\\n  , 'touchend'\\n  , 'touchcancel' ].forEach(function(event) {\\n\\n  // add event to SVG.Element\\n  SVG.Element.prototype[event] = function(f) {\\n    var self = this\\n\\n    // bind event to element rather than element node\\n    this.node['on' + event] = typeof f == 'function' ?\\n      function() { return f.apply(self, arguments) } : null\\n\\n    return this\\n  }\\n\\n})\\n\\n// Initialize listeners stack\\nSVG.listeners = []\\nSVG.handlerMap = []\\nSVG.listenerId = 0\\n\\n// Add event binder in the SVG namespace\\nSVG.on = function(node, event, listener, binding) {\\n  // create listener, get object-index\\n  var l     = listener.bind(binding || node.instance || node)\\n    , index = (SVG.handlerMap.indexOf(node) + 1 || SVG.handlerMap.push(node)) - 1\\n    , ev    = event.split('.')[0]\\n    , ns    = event.split('.')[1] || '*'\\n\\n\\n  // ensure valid object\\n  SVG.listeners[index]         = SVG.listeners[index]         || {}\\n  SVG.listeners[index][ev]     = SVG.listeners[index][ev]     || {}\\n  SVG.listeners[index][ev][ns] = SVG.listeners[index][ev][ns] || {}\\n\\n  if(!listener._svgjsListenerId)\\n    listener._svgjsListenerId = ++SVG.listenerId\\n\\n  // reference listener\\n  SVG.listeners[index][ev][ns][listener._svgjsListenerId] = l\\n\\n  // add listener\\n  node.addEventListener(ev, l, false)\\n}\\n\\n// Add event unbinder in the SVG namespace\\nSVG.off = function(node, event, listener) {\\n  var index = SVG.handlerMap.indexOf(node)\\n    , ev    = event && event.split('.')[0]\\n    , ns    = event && event.split('.')[1]\\n\\n  if(index == -1) return\\n\\n  if (listener) {\\n    if(typeof listener == 'function') listener = listener._svgjsListenerId\\n    if(!listener) return\\n\\n    // remove listener reference\\n    if (SVG.listeners[index][ev] && SVG.listeners[index][ev][ns || '*']) {\\n      // remove listener\\n      node.removeEventListener(ev, SVG.listeners[index][ev][ns || '*'][listener], false)\\n\\n      delete SVG.listeners[index][ev][ns || '*'][listener]\\n    }\\n\\n  } else if (ns && ev) {\\n    // remove all listeners for a namespaced event\\n    if (SVG.listeners[index][ev] && SVG.listeners[index][ev][ns]) {\\n      for (listener in SVG.listeners[index][ev][ns])\\n        SVG.off(node, [ev, ns].join('.'), listener)\\n\\n      delete SVG.listeners[index][ev][ns]\\n    }\\n\\n  } else if (ns){\\n    // remove all listeners for a specific namespace\\n    for(event in SVG.listeners[index]){\\n        for(namespace in SVG.listeners[index][event]){\\n            if(ns === namespace){\\n                SVG.off(node, [event, ns].join('.'))\\n            }\\n        }\\n    }\\n\\n  } else if (ev) {\\n    // remove all listeners for the event\\n    if (SVG.listeners[index][ev]) {\\n      for (namespace in SVG.listeners[index][ev])\\n        SVG.off(node, [ev, namespace].join('.'))\\n\\n      delete SVG.listeners[index][ev]\\n    }\\n\\n  } else {\\n    // remove all listeners on a given node\\n    for (event in SVG.listeners[index])\\n      SVG.off(node, event)\\n\\n    delete SVG.listeners[index]\\n\\n  }\\n}\\n\\n//\\nSVG.extend(SVG.Element, {\\n  // Bind given event to listener\\n  on: function(event, listener, binding) {\\n    SVG.on(this.node, event, listener, binding)\\n\\n    return this\\n  }\\n  // Unbind event from listener\\n, off: function(event, listener) {\\n    SVG.off(this.node, event, listener)\\n\\n    return this\\n  }\\n  // Fire given event\\n, fire: function(event, data) {\\n\\n    // Dispatch event\\n    if(event instanceof Event){\\n        this.node.dispatchEvent(event)\\n    }else{\\n        this.node.dispatchEvent(new CustomEvent(event, {detail:data}))\\n    }\\n\\n    return this\\n  }\\n})\\n\\nSVG.Defs = SVG.invent({\\n  // Initialize node\\n  create: 'defs'\\n\\n  // Inherit from\\n, inherit: SVG.Container\\n\\n})\\nSVG.G = SVG.invent({\\n  // Initialize node\\n  create: 'g'\\n\\n  // Inherit from\\n, inherit: SVG.Container\\n\\n  // Add class methods\\n, extend: {\\n    // Move over x-axis\\n    x: function(x) {\\n      return x == null ? this.transform('x') : this.transform({ x: x - this.x() }, true)\\n    }\\n    // Move over y-axis\\n  , y: function(y) {\\n      return y == null ? this.transform('y') : this.transform({ y: y - this.y() }, true)\\n    }\\n    // Move by center over x-axis\\n  , cx: function(x) {\\n      return x == null ? this.gbox().cx : this.x(x - this.gbox().width / 2)\\n    }\\n    // Move by center over y-axis\\n  , cy: function(y) {\\n      return y == null ? this.gbox().cy : this.y(y - this.gbox().height / 2)\\n    }\\n  , gbox: function() {\\n\\n      var bbox  = this.bbox()\\n        , trans = this.transform()\\n\\n      bbox.x  += trans.x\\n      bbox.x2 += trans.x\\n      bbox.cx += trans.x\\n\\n      bbox.y  += trans.y\\n      bbox.y2 += trans.y\\n      bbox.cy += trans.y\\n\\n      return bbox\\n    }\\n  }\\n\\n  // Add parent method\\n, construct: {\\n    // Create a group element\\n    group: function() {\\n      return this.put(new SVG.G)\\n    }\\n  }\\n})\\n\\n// ### This module adds backward / forward functionality to elements.\\n\\n//\\nSVG.extend(SVG.Element, {\\n  // Get all siblings, including myself\\n  siblings: function() {\\n    return this.parent().children()\\n  }\\n  // Get the curent position siblings\\n, position: function() {\\n    return this.parent().index(this)\\n  }\\n  // Get the next element (will return null if there is none)\\n, next: function() {\\n    return this.siblings()[this.position() + 1]\\n  }\\n  // Get the next element (will return null if there is none)\\n, previous: function() {\\n    return this.siblings()[this.position() - 1]\\n  }\\n  // Send given element one step forward\\n, forward: function() {\\n    var i = this.position() + 1\\n      , p = this.parent()\\n\\n    // move node one step forward\\n    p.removeElement(this).add(this, i)\\n\\n    // make sure defs node is always at the top\\n    if (p instanceof SVG.Doc)\\n      p.node.appendChild(p.defs().node)\\n\\n    return this\\n  }\\n  // Send given element one step backward\\n, backward: function() {\\n    var i = this.position()\\n\\n    if (i > 0)\\n      this.parent().removeElement(this).add(this, i - 1)\\n\\n    return this\\n  }\\n  // Send given element all the way to the front\\n, front: function() {\\n    var p = this.parent()\\n\\n    // Move node forward\\n    p.node.appendChild(this.node)\\n\\n    // Make sure defs node is always at the top\\n    if (p instanceof SVG.Doc)\\n      p.node.appendChild(p.defs().node)\\n\\n    return this\\n  }\\n  // Send given element all the way to the back\\n, back: function() {\\n    if (this.position() > 0)\\n      this.parent().removeElement(this).add(this, 0)\\n\\n    return this\\n  }\\n  // Inserts a given element before the targeted element\\n, before: function(element) {\\n    element.remove()\\n\\n    var i = this.position()\\n\\n    this.parent().add(element, i)\\n\\n    return this\\n  }\\n  // Insters a given element after the targeted element\\n, after: function(element) {\\n    element.remove()\\n\\n    var i = this.position()\\n\\n    this.parent().add(element, i + 1)\\n\\n    return this\\n  }\\n\\n})\\nSVG.Mask = SVG.invent({\\n  // Initialize node\\n  create: function() {\\n    this.constructor.call(this, SVG.create('mask'))\\n\\n    // keep references to masked elements\\n    this.targets = []\\n  }\\n\\n  // Inherit from\\n, inherit: SVG.Container\\n\\n  // Add class methods\\n, extend: {\\n    // Unmask all masked elements and remove itself\\n    remove: function() {\\n      // unmask all targets\\n      for (var i = this.targets.length - 1; i >= 0; i--)\\n        if (this.targets[i])\\n          this.targets[i].unmask()\\n      this.targets = []\\n\\n      // remove mask from parent\\n      this.parent().removeElement(this)\\n\\n      return this\\n    }\\n  }\\n\\n  // Add parent method\\n, construct: {\\n    // Create masking element\\n    mask: function() {\\n      return this.defs().put(new SVG.Mask)\\n    }\\n  }\\n})\\n\\n\\nSVG.extend(SVG.Element, {\\n  // Distribute mask to svg element\\n  maskWith: function(element) {\\n    // use given mask or create a new one\\n    this.masker = element instanceof SVG.Mask ? element : this.parent().mask().add(element)\\n\\n    // store reverence on self in mask\\n    this.masker.targets.push(this)\\n\\n    // apply mask\\n    return this.attr('mask', 'url(\\\"#' + this.masker.attr('id') + '\\\")')\\n  }\\n  // Unmask element\\n, unmask: function() {\\n    delete this.masker\\n    return this.attr('mask', null)\\n  }\\n\\n})\\n\\nSVG.ClipPath = SVG.invent({\\n  // Initialize node\\n  create: function() {\\n    this.constructor.call(this, SVG.create('clipPath'))\\n\\n    // keep references to clipped elements\\n    this.targets = []\\n  }\\n\\n  // Inherit from\\n, inherit: SVG.Container\\n\\n  // Add class methods\\n, extend: {\\n    // Unclip all clipped elements and remove itself\\n    remove: function() {\\n      // unclip all targets\\n      for (var i = this.targets.length - 1; i >= 0; i--)\\n        if (this.targets[i])\\n          this.targets[i].unclip()\\n      this.targets = []\\n\\n      // remove clipPath from parent\\n      this.parent().removeElement(this)\\n\\n      return this\\n    }\\n  }\\n\\n  // Add parent method\\n, construct: {\\n    // Create clipping element\\n    clip: function() {\\n      return this.defs().put(new SVG.ClipPath)\\n    }\\n  }\\n})\\n\\n//\\nSVG.extend(SVG.Element, {\\n  // Distribute clipPath to svg element\\n  clipWith: function(element) {\\n    // use given clip or create a new one\\n    this.clipper = element instanceof SVG.ClipPath ? element : this.parent().clip().add(element)\\n\\n    // store reverence on self in mask\\n    this.clipper.targets.push(this)\\n\\n    // apply mask\\n    return this.attr('clip-path', 'url(\\\"#' + this.clipper.attr('id') + '\\\")')\\n  }\\n  // Unclip element\\n, unclip: function() {\\n    delete this.clipper\\n    return this.attr('clip-path', null)\\n  }\\n\\n})\\nSVG.Gradient = SVG.invent({\\n  // Initialize node\\n  create: function(type) {\\n    this.constructor.call(this, SVG.create(type + 'Gradient'))\\n\\n    // store type\\n    this.type = type\\n  }\\n\\n  // Inherit from\\n, inherit: SVG.Container\\n\\n  // Add class methods\\n, extend: {\\n    // Add a color stop\\n    at: function(offset, color, opacity) {\\n      return this.put(new SVG.Stop).update(offset, color, opacity)\\n    }\\n    // Update gradient\\n  , update: function(block) {\\n      // remove all stops\\n      this.clear()\\n\\n      // invoke passed block\\n      if (typeof block == 'function')\\n        block.call(this, this)\\n\\n      return this\\n    }\\n    // Return the fill id\\n  , fill: function() {\\n      return 'url(#' + this.id() + ')'\\n    }\\n    // Alias string convertion to fill\\n  , toString: function() {\\n      return this.fill()\\n    }\\n    // custom attr to handle transform\\n  , attr: function(a, b, c) {\\n      if(a == 'transform') a = 'gradientTransform'\\n      return SVG.Container.prototype.attr.call(this, a, b, c)\\n    }\\n  }\\n\\n  // Add parent method\\n, construct: {\\n    // Create gradient element in defs\\n    gradient: function(type, block) {\\n      return this.defs().gradient(type, block)\\n    }\\n  }\\n})\\n\\n// Add animatable methods to both gradient and fx module\\nSVG.extend(SVG.Gradient, SVG.FX, {\\n  // From position\\n  from: function(x, y) {\\n    return (this._target || this).type == 'radial' ?\\n      this.attr({ fx: new SVG.Number(x), fy: new SVG.Number(y) }) :\\n      this.attr({ x1: new SVG.Number(x), y1: new SVG.Number(y) })\\n  }\\n  // To position\\n, to: function(x, y) {\\n    return (this._target || this).type == 'radial' ?\\n      this.attr({ cx: new SVG.Number(x), cy: new SVG.Number(y) }) :\\n      this.attr({ x2: new SVG.Number(x), y2: new SVG.Number(y) })\\n  }\\n})\\n\\n// Base gradient generation\\nSVG.extend(SVG.Defs, {\\n  // define gradient\\n  gradient: function(type, block) {\\n    return this.put(new SVG.Gradient(type)).update(block)\\n  }\\n\\n})\\n\\nSVG.Stop = SVG.invent({\\n  // Initialize node\\n  create: 'stop'\\n\\n  // Inherit from\\n, inherit: SVG.Element\\n\\n  // Add class methods\\n, extend: {\\n    // add color stops\\n    update: function(o) {\\n      if (typeof o == 'number' || o instanceof SVG.Number) {\\n        o = {\\n          offset:  arguments[0]\\n        , color:   arguments[1]\\n        , opacity: arguments[2]\\n        }\\n      }\\n\\n      // set attributes\\n      if (o.opacity != null) this.attr('stop-opacity', o.opacity)\\n      if (o.color   != null) this.attr('stop-color', o.color)\\n      if (o.offset  != null) this.attr('offset', new SVG.Number(o.offset))\\n\\n      return this\\n    }\\n  }\\n\\n})\\n\\nSVG.Pattern = SVG.invent({\\n  // Initialize node\\n  create: 'pattern'\\n\\n  // Inherit from\\n, inherit: SVG.Container\\n\\n  // Add class methods\\n, extend: {\\n    // Return the fill id\\n    fill: function() {\\n      return 'url(#' + this.id() + ')'\\n    }\\n    // Update pattern by rebuilding\\n  , update: function(block) {\\n      // remove content\\n      this.clear()\\n\\n      // invoke passed block\\n      if (typeof block == 'function')\\n        block.call(this, this)\\n\\n      return this\\n    }\\n    // Alias string convertion to fill\\n  , toString: function() {\\n      return this.fill()\\n    }\\n    // custom attr to handle transform\\n  , attr: function(a, b, c) {\\n      if(a == 'transform') a = 'patternTransform'\\n      return SVG.Container.prototype.attr.call(this, a, b, c)\\n    }\\n\\n  }\\n\\n  // Add parent method\\n, construct: {\\n    // Create pattern element in defs\\n    pattern: function(width, height, block) {\\n      return this.defs().pattern(width, height, block)\\n    }\\n  }\\n})\\n\\nSVG.extend(SVG.Defs, {\\n  // Define gradient\\n  pattern: function(width, height, block) {\\n    return this.put(new SVG.Pattern).update(block).attr({\\n      x:            0\\n    , y:            0\\n    , width:        width\\n    , height:       height\\n    , patternUnits: 'userSpaceOnUse'\\n    })\\n  }\\n\\n})\\nSVG.Doc = SVG.invent({\\n  // Initialize node\\n  create: function(element) {\\n    if (element) {\\n      // ensure the presence of a dom element\\n      element = typeof element == 'string' ?\\n        document.getElementById(element) :\\n        element\\n\\n      // If the target is an svg element, use that element as the main wrapper.\\n      // This allows svg.js to work with svg documents as well.\\n      if (element.nodeName == 'svg') {\\n        this.constructor.call(this, element)\\n      } else {\\n        this.constructor.call(this, SVG.create('svg'))\\n        element.appendChild(this.node)\\n        this.size('100%', '100%')\\n      }\\n\\n      // set svg element attributes and ensure defs node\\n      this.namespace().defs()\\n    }\\n  }\\n\\n  // Inherit from\\n, inherit: SVG.Container\\n\\n  // Add class methods\\n, extend: {\\n    // Add namespaces\\n    namespace: function() {\\n      return this\\n        .attr({ xmlns: SVG.ns, version: '1.1' })\\n        .attr('xmlns:xlink', SVG.xlink, SVG.xmlns)\\n        .attr('xmlns:svgjs', SVG.svgjs, SVG.xmlns)\\n    }\\n    // Creates and returns defs element\\n  , defs: function() {\\n      if (!this._defs) {\\n        var defs\\n\\n        // Find or create a defs element in this instance\\n        if (defs = this.node.getElementsByTagName('defs')[0])\\n          this._defs = SVG.adopt(defs)\\n        else\\n          this._defs = new SVG.Defs\\n\\n        // Make sure the defs node is at the end of the stack\\n        this.node.appendChild(this._defs.node)\\n      }\\n\\n      return this._defs\\n    }\\n    // custom parent method\\n  , parent: function() {\\n      return this.node.parentNode.nodeName == '#document' ? null : this.node.parentNode\\n    }\\n    // Fix for possible sub-pixel offset. See:\\n    // https://bugzilla.mozilla.org/show_bug.cgi?id=608812\\n  , spof: function(spof) {\\n      var pos = this.node.getScreenCTM()\\n\\n      if (pos)\\n        this\\n          .style('left', (-pos.e % 1) + 'px')\\n          .style('top',  (-pos.f % 1) + 'px')\\n\\n      return this\\n    }\\n\\n      // Removes the doc from the DOM\\n  , remove: function() {\\n      if(this.parent()) {\\n        this.parent().removeChild(this.node);\\n      }\\n\\n      return this;\\n    }\\n  }\\n\\n})\\n\\nSVG.Shape = SVG.invent({\\n  // Initialize node\\n  create: function(element) {\\n    this.constructor.call(this, element)\\n  }\\n\\n  // Inherit from\\n, inherit: SVG.Element\\n\\n})\\n\\nSVG.Bare = SVG.invent({\\n  // Initialize\\n  create: function(element, inherit) {\\n    // construct element\\n    this.constructor.call(this, SVG.create(element))\\n\\n    // inherit custom methods\\n    if (inherit)\\n      for (var method in inherit.prototype)\\n        if (typeof inherit.prototype[method] === 'function')\\n          this[method] = inherit.prototype[method]\\n  }\\n\\n  // Inherit from\\n, inherit: SVG.Element\\n\\n  // Add methods\\n, extend: {\\n    // Insert some plain text\\n    words: function(text) {\\n      // remove contents\\n      while (this.node.hasChildNodes())\\n        this.node.removeChild(this.node.lastChild)\\n\\n      // create text node\\n      this.node.appendChild(document.createTextNode(text))\\n\\n      return this\\n    }\\n  }\\n})\\n\\n\\nSVG.extend(SVG.Parent, {\\n  // Create an element that is not described by SVG.js\\n  element: function(element, inherit) {\\n    return this.put(new SVG.Bare(element, inherit))\\n  }\\n  // Add symbol element\\n, symbol: function() {\\n    return this.defs().element('symbol', SVG.Container)\\n  }\\n\\n})\\nSVG.Use = SVG.invent({\\n  // Initialize node\\n  create: 'use'\\n\\n  // Inherit from\\n, inherit: SVG.Shape\\n\\n  // Add class methods\\n, extend: {\\n    // Use element as a reference\\n    element: function(element, file) {\\n      // Set lined element\\n      return this.attr('href', (file || '') + '#' + element, SVG.xlink)\\n    }\\n  }\\n\\n  // Add parent method\\n, construct: {\\n    // Create a use element\\n    use: function(element, file) {\\n      return this.put(new SVG.Use).element(element, file)\\n    }\\n  }\\n})\\nSVG.Rect = SVG.invent({\\n  // Initialize node\\n  create: 'rect'\\n\\n  // Inherit from\\n, inherit: SVG.Shape\\n\\n  // Add parent method\\n, construct: {\\n    // Create a rect element\\n    rect: function(width, height) {\\n      return this.put(new SVG.Rect()).size(width, height)\\n    }\\n  }\\n})\\nSVG.Circle = SVG.invent({\\n  // Initialize node\\n  create: 'circle'\\n\\n  // Inherit from\\n, inherit: SVG.Shape\\n\\n  // Add parent method\\n, construct: {\\n    // Create circle element, based on ellipse\\n    circle: function(size) {\\n      return this.put(new SVG.Circle).rx(new SVG.Number(size).divide(2)).move(0, 0)\\n    }\\n  }\\n})\\n\\nSVG.extend(SVG.Circle, SVG.FX, {\\n  // Radius x value\\n  rx: function(rx) {\\n    return this.attr('r', rx)\\n  }\\n  // Alias radius x value\\n, ry: function(ry) {\\n    return this.rx(ry)\\n  }\\n})\\n\\nSVG.Ellipse = SVG.invent({\\n  // Initialize node\\n  create: 'ellipse'\\n\\n  // Inherit from\\n, inherit: SVG.Shape\\n\\n  // Add parent method\\n, construct: {\\n    // Create an ellipse\\n    ellipse: function(width, height) {\\n      return this.put(new SVG.Ellipse).size(width, height).move(0, 0)\\n    }\\n  }\\n})\\n\\nSVG.extend(SVG.Ellipse, SVG.Rect, SVG.FX, {\\n  // Radius x value\\n  rx: function(rx) {\\n    return this.attr('rx', rx)\\n  }\\n  // Radius y value\\n, ry: function(ry) {\\n    return this.attr('ry', ry)\\n  }\\n})\\n\\n// Add common method\\nSVG.extend(SVG.Circle, SVG.Ellipse, {\\n    // Move over x-axis\\n    x: function(x) {\\n      return x == null ? this.cx() - this.rx() : this.cx(x + this.rx())\\n    }\\n    // Move over y-axis\\n  , y: function(y) {\\n      return y == null ? this.cy() - this.ry() : this.cy(y + this.ry())\\n    }\\n    // Move by center over x-axis\\n  , cx: function(x) {\\n      return x == null ? this.attr('cx') : this.attr('cx', x)\\n    }\\n    // Move by center over y-axis\\n  , cy: function(y) {\\n      return y == null ? this.attr('cy') : this.attr('cy', y)\\n    }\\n    // Set width of element\\n  , width: function(width) {\\n      return width == null ? this.rx() * 2 : this.rx(new SVG.Number(width).divide(2))\\n    }\\n    // Set height of element\\n  , height: function(height) {\\n      return height == null ? this.ry() * 2 : this.ry(new SVG.Number(height).divide(2))\\n    }\\n    // Custom size function\\n  , size: function(width, height) {\\n      var p = proportionalSize(this, width, height)\\n\\n      return this\\n        .rx(new SVG.Number(p.width).divide(2))\\n        .ry(new SVG.Number(p.height).divide(2))\\n    }\\n})\\nSVG.Line = SVG.invent({\\n  // Initialize node\\n  create: 'line'\\n\\n  // Inherit from\\n, inherit: SVG.Shape\\n\\n  // Add class methods\\n, extend: {\\n    // Get array\\n    array: function() {\\n      return new SVG.PointArray([\\n        [ this.attr('x1'), this.attr('y1') ]\\n      , [ this.attr('x2'), this.attr('y2') ]\\n      ])\\n    }\\n    // Overwrite native plot() method\\n  , plot: function(x1, y1, x2, y2) {\\n      if (typeof y1 !== 'undefined')\\n        x1 = { x1: x1, y1: y1, x2: x2, y2: y2 }\\n      else\\n        x1 = new SVG.PointArray(x1).toLine()\\n\\n      return this.attr(x1)\\n    }\\n    // Move by left top corner\\n  , move: function(x, y) {\\n      return this.attr(this.array().move(x, y).toLine())\\n    }\\n    // Set element size to given width and height\\n  , size: function(width, height) {\\n      var p = proportionalSize(this, width, height)\\n\\n      return this.attr(this.array().size(p.width, p.height).toLine())\\n    }\\n  }\\n\\n  // Add parent method\\n, construct: {\\n    // Create a line element\\n    line: function(x1, y1, x2, y2) {\\n      return this.put(new SVG.Line).plot(x1, y1, x2, y2)\\n    }\\n  }\\n})\\n\\nSVG.Polyline = SVG.invent({\\n  // Initialize node\\n  create: 'polyline'\\n\\n  // Inherit from\\n, inherit: SVG.Shape\\n\\n  // Add parent method\\n, construct: {\\n    // Create a wrapped polyline element\\n    polyline: function(p) {\\n      return this.put(new SVG.Polyline).plot(p)\\n    }\\n  }\\n})\\n\\nSVG.Polygon = SVG.invent({\\n  // Initialize node\\n  create: 'polygon'\\n\\n  // Inherit from\\n, inherit: SVG.Shape\\n\\n  // Add parent method\\n, construct: {\\n    // Create a wrapped polygon element\\n    polygon: function(p) {\\n      return this.put(new SVG.Polygon).plot(p)\\n    }\\n  }\\n})\\n\\n// Add polygon-specific functions\\nSVG.extend(SVG.Polyline, SVG.Polygon, {\\n  // Get array\\n  array: function() {\\n    return this._array || (this._array = new SVG.PointArray(this.attr('points')))\\n  }\\n  // Plot new path\\n, plot: function(p) {\\n    return this.attr('points', (this._array = new SVG.PointArray(p)))\\n  }\\n  // Move by left top corner\\n, move: function(x, y) {\\n    return this.attr('points', this.array().move(x, y))\\n  }\\n  // Set element size to given width and height\\n, size: function(width, height) {\\n    var p = proportionalSize(this, width, height)\\n\\n    return this.attr('points', this.array().size(p.width, p.height))\\n  }\\n\\n})\\n// unify all point to point elements\\nSVG.extend(SVG.Line, SVG.Polyline, SVG.Polygon, {\\n  // Define morphable array\\n  morphArray:  SVG.PointArray\\n  // Move by left top corner over x-axis\\n, x: function(x) {\\n    return x == null ? this.bbox().x : this.move(x, this.bbox().y)\\n  }\\n  // Move by left top corner over y-axis\\n, y: function(y) {\\n    return y == null ? this.bbox().y : this.move(this.bbox().x, y)\\n  }\\n  // Set width of element\\n, width: function(width) {\\n    var b = this.bbox()\\n\\n    return width == null ? b.width : this.size(width, b.height)\\n  }\\n  // Set height of element\\n, height: function(height) {\\n    var b = this.bbox()\\n\\n    return height == null ? b.height : this.size(b.width, height)\\n  }\\n})\\nSVG.Path = SVG.invent({\\n  // Initialize node\\n  create: 'path'\\n\\n  // Inherit from\\n, inherit: SVG.Shape\\n\\n  // Add class methods\\n, extend: {\\n    // Define morphable array\\n    morphArray:  SVG.PathArray\\n    // Get array\\n  , array: function() {\\n      return this._array || (this._array = new SVG.PathArray(this.attr('d')))\\n    }\\n    // Plot new poly points\\n  , plot: function(p) {\\n      return this.attr('d', (this._array = new SVG.PathArray(p)))\\n    }\\n    // Move by left top corner\\n  , move: function(x, y) {\\n      return this.attr('d', this.array().move(x, y))\\n    }\\n    // Move by left top corner over x-axis\\n  , x: function(x) {\\n      return x == null ? this.bbox().x : this.move(x, this.bbox().y)\\n    }\\n    // Move by left top corner over y-axis\\n  , y: function(y) {\\n      return y == null ? this.bbox().y : this.move(this.bbox().x, y)\\n    }\\n    // Set element size to given width and height\\n  , size: function(width, height) {\\n      var p = proportionalSize(this, width, height)\\n\\n      return this.attr('d', this.array().size(p.width, p.height))\\n    }\\n    // Set width of element\\n  , width: function(width) {\\n      return width == null ? this.bbox().width : this.size(width, this.bbox().height)\\n    }\\n    // Set height of element\\n  , height: function(height) {\\n      return height == null ? this.bbox().height : this.size(this.bbox().width, height)\\n    }\\n\\n  }\\n\\n  // Add parent method\\n, construct: {\\n    // Create a wrapped path element\\n    path: function(d) {\\n      return this.put(new SVG.Path).plot(d)\\n    }\\n  }\\n})\\nSVG.Image = SVG.invent({\\n  // Initialize node\\n  create: 'image'\\n\\n  // Inherit from\\n, inherit: SVG.Shape\\n\\n  // Add class methods\\n, extend: {\\n    // (re)load image\\n    load: function(url) {\\n      if (!url) return this\\n\\n      var self = this\\n        , img  = document.createElement('img')\\n\\n      // preload image\\n      img.onload = function() {\\n        var p = self.parent(SVG.Pattern)\\n\\n        if(p === null) return\\n\\n        // ensure image size\\n        if (self.width() == 0 && self.height() == 0)\\n          self.size(img.width, img.height)\\n\\n        // ensure pattern size if not set\\n        if (p && p.width() == 0 && p.height() == 0)\\n          p.size(self.width(), self.height())\\n\\n        // callback\\n        if (typeof self._loaded === 'function')\\n          self._loaded.call(self, {\\n            width:  img.width\\n          , height: img.height\\n          , ratio:  img.width / img.height\\n          , url:    url\\n          })\\n      }\\n\\n      img.onerror = function(e){\\n        if (typeof self._error === 'function'){\\n            self._error.call(self, e)\\n        }\\n      }\\n\\n      return this.attr('href', (img.src = this.src = url), SVG.xlink)\\n    }\\n    // Add loaded callback\\n  , loaded: function(loaded) {\\n      this._loaded = loaded\\n      return this\\n    }\\n\\n  , error: function(error) {\\n      this._error = error\\n      return this\\n    }\\n  }\\n\\n  // Add parent method\\n, construct: {\\n    // create image element, load image and set its size\\n    image: function(source, width, height) {\\n      return this.put(new SVG.Image).load(source).size(width || 0, height || width || 0)\\n    }\\n  }\\n\\n})\\nSVG.Text = SVG.invent({\\n  // Initialize node\\n  create: function() {\\n    this.constructor.call(this, SVG.create('text'))\\n\\n    this.dom.leading = new SVG.Number(1.3)    // store leading value for rebuilding\\n    this._rebuild = true                      // enable automatic updating of dy values\\n    this._build   = false                     // disable build mode for adding multiple lines\\n\\n    // set default font\\n    this.attr('font-family', SVG.defaults.attrs['font-family'])\\n  }\\n\\n  // Inherit from\\n, inherit: SVG.Shape\\n\\n  // Add class methods\\n, extend: {\\n    // Move over x-axis\\n    x: function(x) {\\n      // act as getter\\n      if (x == null)\\n        return this.attr('x')\\n\\n      // move lines as well if no textPath is present\\n      if (!this.textPath)\\n        this.lines().each(function() { if (this.dom.newLined) this.x(x) })\\n\\n      return this.attr('x', x)\\n    }\\n    // Move over y-axis\\n  , y: function(y) {\\n      var oy = this.attr('y')\\n        , o  = typeof oy === 'number' ? oy - this.bbox().y : 0\\n\\n      // act as getter\\n      if (y == null)\\n        return typeof oy === 'number' ? oy - o : oy\\n\\n      return this.attr('y', typeof y === 'number' ? y + o : y)\\n    }\\n    // Move center over x-axis\\n  , cx: function(x) {\\n      return x == null ? this.bbox().cx : this.x(x - this.bbox().width / 2)\\n    }\\n    // Move center over y-axis\\n  , cy: function(y) {\\n      return y == null ? this.bbox().cy : this.y(y - this.bbox().height / 2)\\n    }\\n    // Set the text content\\n  , text: function(text) {\\n      // act as getter\\n      if (typeof text === 'undefined'){\\n        var text = ''\\n        var children = this.node.childNodes\\n        for(var i = 0, len = children.length; i < len; ++i){\\n\\n          // add newline if its not the first child and newLined is set to true\\n          if(i != 0 && children[i].nodeType != 3 && SVG.adopt(children[i]).dom.newLined == true){\\n            text += '\\\\n'\\n          }\\n\\n          // add content of this node\\n          text += children[i].textContent\\n        }\\n\\n        return text\\n      }\\n\\n      // remove existing content\\n      this.clear().build(true)\\n\\n      if (typeof text === 'function') {\\n        // call block\\n        text.call(this, this)\\n\\n      } else {\\n        // store text and make sure text is not blank\\n        text = text.split('\\\\n')\\n\\n        // build new lines\\n        for (var i = 0, il = text.length; i < il; i++)\\n          this.tspan(text[i]).newLine()\\n      }\\n\\n      // disable build mode and rebuild lines\\n      return this.build(false).rebuild()\\n    }\\n    // Set font size\\n  , size: function(size) {\\n      return this.attr('font-size', size).rebuild()\\n    }\\n    // Set / get leading\\n  , leading: function(value) {\\n      // act as getter\\n      if (value == null)\\n        return this.dom.leading\\n\\n      // act as setter\\n      this.dom.leading = new SVG.Number(value)\\n\\n      return this.rebuild()\\n    }\\n    // Get all the first level lines\\n  , lines: function() {\\n      var node = (this.textPath && this.textPath() || this).node\\n\\n      // filter tspans and map them to SVG.js instances\\n      var lines = SVG.utils.map(SVG.utils.filterSVGElements(node.childNodes), function(el){\\n        return SVG.adopt(el)\\n      })\\n\\n      // return an instance of SVG.set\\n      return new SVG.Set(lines)\\n    }\\n    // Rebuild appearance type\\n  , rebuild: function(rebuild) {\\n      // store new rebuild flag if given\\n      if (typeof rebuild == 'boolean')\\n        this._rebuild = rebuild\\n\\n      // define position of all lines\\n      if (this._rebuild) {\\n        var self = this\\n          , blankLineOffset = 0\\n          , dy = this.dom.leading * new SVG.Number(this.attr('font-size'))\\n\\n        this.lines().each(function() {\\n          if (this.dom.newLined) {\\n            if (!this.textPath)\\n              this.attr('x', self.attr('x'))\\n\\n            if(this.text() == '\\\\n') {\\n              blankLineOffset += dy\\n            }else{\\n              this.attr('dy', dy + blankLineOffset)\\n              blankLineOffset = 0\\n            }\\n          }\\n        })\\n\\n        this.fire('rebuild')\\n      }\\n\\n      return this\\n    }\\n    // Enable / disable build mode\\n  , build: function(build) {\\n      this._build = !!build\\n      return this\\n    }\\n    // overwrite method from parent to set data properly\\n  , setData: function(o){\\n      this.dom = o\\n      this.dom.leading = new SVG.Number(o.leading || 1.3)\\n      return this\\n    }\\n  }\\n\\n  // Add parent method\\n, construct: {\\n    // Create text element\\n    text: function(text) {\\n      return this.put(new SVG.Text).text(text)\\n    }\\n    // Create plain text element\\n  , plain: function(text) {\\n      return this.put(new SVG.Text).plain(text)\\n    }\\n  }\\n\\n})\\n\\nSVG.Tspan = SVG.invent({\\n  // Initialize node\\n  create: 'tspan'\\n\\n  // Inherit from\\n, inherit: SVG.Shape\\n\\n  // Add class methods\\n, extend: {\\n    // Set text content\\n    text: function(text) {\\n      if(text == null) return this.node.textContent + (this.dom.newLined ? '\\\\n' : '')\\n\\n      typeof text === 'function' ? text.call(this, this) : this.plain(text)\\n\\n      return this\\n    }\\n    // Shortcut dx\\n  , dx: function(dx) {\\n      return this.attr('dx', dx)\\n    }\\n    // Shortcut dy\\n  , dy: function(dy) {\\n      return this.attr('dy', dy)\\n    }\\n    // Create new line\\n  , newLine: function() {\\n      // fetch text parent\\n      var t = this.parent(SVG.Text)\\n\\n      // mark new line\\n      this.dom.newLined = true\\n\\n      // apply new hy\u00a1n\\n      return this.dy(t.dom.leading * t.attr('font-size')).attr('x', t.x())\\n    }\\n  }\\n\\n})\\n\\nSVG.extend(SVG.Text, SVG.Tspan, {\\n  // Create plain text node\\n  plain: function(text) {\\n    // clear if build mode is disabled\\n    if (this._build === false)\\n      this.clear()\\n\\n    // create text node\\n    this.node.appendChild(document.createTextNode(text))\\n\\n    return this\\n  }\\n  // Create a tspan\\n, tspan: function(text) {\\n    var node  = (this.textPath && this.textPath() || this).node\\n      , tspan = new SVG.Tspan\\n\\n    // clear if build mode is disabled\\n    if (this._build === false)\\n      this.clear()\\n\\n    // add new tspan\\n    node.appendChild(tspan.node)\\n\\n    return tspan.text(text)\\n  }\\n  // Clear all lines\\n, clear: function() {\\n    var node = (this.textPath && this.textPath() || this).node\\n\\n    // remove existing child nodes\\n    while (node.hasChildNodes())\\n      node.removeChild(node.lastChild)\\n\\n    return this\\n  }\\n  // Get length of text element\\n, length: function() {\\n    return this.node.getComputedTextLength()\\n  }\\n})\\n\\nSVG.TextPath = SVG.invent({\\n  // Initialize node\\n  create: 'textPath'\\n\\n  // Inherit from\\n, inherit: SVG.Parent\\n\\n  // Define parent class\\n, parent: SVG.Text\\n\\n  // Add parent method\\n, construct: {\\n    // Create path for text to run on\\n    path: function(d) {\\n      // create textPath element\\n      var path  = new SVG.TextPath\\n        , track = this.doc().defs().path(d)\\n\\n      // move lines to textpath\\n      while (this.node.hasChildNodes())\\n        path.node.appendChild(this.node.firstChild)\\n\\n      // add textPath element as child node\\n      this.node.appendChild(path.node)\\n\\n      // link textPath to path and add content\\n      path.attr('href', '#' + track, SVG.xlink)\\n\\n      return this\\n    }\\n    // Plot path if any\\n  , plot: function(d) {\\n      var track = this.track()\\n\\n      if (track)\\n        track.plot(d)\\n\\n      return this\\n    }\\n    // Get the path track element\\n  , track: function() {\\n      var path = this.textPath()\\n\\n      if (path)\\n        return path.reference('href')\\n    }\\n    // Get the textPath child\\n  , textPath: function() {\\n      if (this.node.firstChild && this.node.firstChild.nodeName == 'textPath')\\n        return SVG.adopt(this.node.firstChild)\\n    }\\n  }\\n})\\nSVG.Nested = SVG.invent({\\n  // Initialize node\\n  create: function() {\\n    this.constructor.call(this, SVG.create('svg'))\\n\\n    this.style('overflow', 'visible')\\n  }\\n\\n  // Inherit from\\n, inherit: SVG.Container\\n\\n  // Add parent method\\n, construct: {\\n    // Create nested svg document\\n    nested: function() {\\n      return this.put(new SVG.Nested)\\n    }\\n  }\\n})\\nSVG.A = SVG.invent({\\n  // Initialize node\\n  create: 'a'\\n\\n  // Inherit from\\n, inherit: SVG.Container\\n\\n  // Add class methods\\n, extend: {\\n    // Link url\\n    to: function(url) {\\n      return this.attr('href', url, SVG.xlink)\\n    }\\n    // Link show attribute\\n  , show: function(target) {\\n      return this.attr('show', target, SVG.xlink)\\n    }\\n    // Link target attribute\\n  , target: function(target) {\\n      return this.attr('target', target)\\n    }\\n  }\\n\\n  // Add parent method\\n, construct: {\\n    // Create a hyperlink element\\n    link: function(url) {\\n      return this.put(new SVG.A).to(url)\\n    }\\n  }\\n})\\n\\nSVG.extend(SVG.Element, {\\n  // Create a hyperlink element\\n  linkTo: function(url) {\\n    var link = new SVG.A\\n\\n    if (typeof url == 'function')\\n      url.call(link, link)\\n    else\\n      link.to(url)\\n\\n    return this.parent().put(link).put(this)\\n  }\\n\\n})\\nSVG.Marker = SVG.invent({\\n  // Initialize node\\n  create: 'marker'\\n\\n  // Inherit from\\n, inherit: SVG.Container\\n\\n  // Add class methods\\n, extend: {\\n    // Set width of element\\n    width: function(width) {\\n      return this.attr('markerWidth', width)\\n    }\\n    // Set height of element\\n  , height: function(height) {\\n      return this.attr('markerHeight', height)\\n    }\\n    // Set marker refX and refY\\n  , ref: function(x, y) {\\n      return this.attr('refX', x).attr('refY', y)\\n    }\\n    // Update marker\\n  , update: function(block) {\\n      // remove all content\\n      this.clear()\\n\\n      // invoke passed block\\n      if (typeof block == 'function')\\n        block.call(this, this)\\n\\n      return this\\n    }\\n    // Return the fill id\\n  , toString: function() {\\n      return 'url(#' + this.id() + ')'\\n    }\\n  }\\n\\n  // Add parent method\\n, construct: {\\n    marker: function(width, height, block) {\\n      // Create marker element in defs\\n      return this.defs().marker(width, height, block)\\n    }\\n  }\\n\\n})\\n\\nSVG.extend(SVG.Defs, {\\n  // Create marker\\n  marker: function(width, height, block) {\\n    // Set default viewbox to match the width and height, set ref to cx and cy and set orient to auto\\n    return this.put(new SVG.Marker)\\n      .size(width, height)\\n      .ref(width / 2, height / 2)\\n      .viewbox(0, 0, width, height)\\n      .attr('orient', 'auto')\\n      .update(block)\\n  }\\n\\n})\\n\\nSVG.extend(SVG.Line, SVG.Polyline, SVG.Polygon, SVG.Path, {\\n  // Create and attach markers\\n  marker: function(marker, width, height, block) {\\n    var attr = ['marker']\\n\\n    // Build attribute name\\n    if (marker != 'all') attr.push(marker)\\n    attr = attr.join('-')\\n\\n    // Set marker attribute\\n    marker = arguments[1] instanceof SVG.Marker ?\\n      arguments[1] :\\n      this.doc().marker(width, height, block)\\n\\n    return this.attr(attr, marker)\\n  }\\n\\n})\\n// Define list of available attributes for stroke and fill\\nvar sugar = {\\n  stroke: ['color', 'width', 'opacity', 'linecap', 'linejoin', 'miterlimit', 'dasharray', 'dashoffset']\\n, fill:   ['color', 'opacity', 'rule']\\n, prefix: function(t, a) {\\n    return a == 'color' ? t : t + '-' + a\\n  }\\n}\\n\\n// Add sugar for fill and stroke\\n;['fill', 'stroke'].forEach(function(m) {\\n  var i, extension = {}\\n\\n  extension[m] = function(o) {\\n    if (typeof o == 'undefined')\\n      return this\\n    if (typeof o == 'string' || SVG.Color.isRgb(o) || (o && typeof o.fill === 'function'))\\n      this.attr(m, o)\\n\\n    else\\n      // set all attributes from sugar.fill and sugar.stroke list\\n      for (i = sugar[m].length - 1; i >= 0; i--)\\n        if (o[sugar[m][i]] != null)\\n          this.attr(sugar.prefix(m, sugar[m][i]), o[sugar[m][i]])\\n\\n    return this\\n  }\\n\\n  SVG.extend(SVG.Element, SVG.FX, extension)\\n\\n})\\n\\nSVG.extend(SVG.Element, SVG.FX, {\\n  // Map rotation to transform\\n  rotate: function(d, cx, cy) {\\n    return this.transform({ rotation: d, cx: cx, cy: cy })\\n  }\\n  // Map skew to transform\\n, skew: function(x, y, cx, cy) {\\n    return arguments.length == 1  || arguments.length == 3 ?\\n      this.transform({ skew: x, cx: y, cy: cx }) :\\n      this.transform({ skewX: x, skewY: y, cx: cx, cy: cy })\\n  }\\n  // Map scale to transform\\n, scale: function(x, y, cx, cy) {\\n    return arguments.length == 1  || arguments.length == 3 ?\\n      this.transform({ scale: x, cx: y, cy: cx }) :\\n      this.transform({ scaleX: x, scaleY: y, cx: cx, cy: cy })\\n  }\\n  // Map translate to transform\\n, translate: function(x, y) {\\n    return this.transform({ x: x, y: y })\\n  }\\n  // Map flip to transform\\n, flip: function(a, o) {\\n    return this.transform({ flip: a, offset: o })\\n  }\\n  // Map matrix to transform\\n, matrix: function(m) {\\n    return this.attr('transform', new SVG.Matrix(m))\\n  }\\n  // Opacity\\n, opacity: function(value) {\\n    return this.attr('opacity', value)\\n  }\\n  // Relative move over x axis\\n, dx: function(x) {\\n    return this.x((this instanceof SVG.FX ? 0 : this.x()) + x, true)\\n  }\\n  // Relative move over y axis\\n, dy: function(y) {\\n    return this.y((this instanceof SVG.FX ? 0 : this.y()) + y, true)\\n  }\\n  // Relative move over x and y axes\\n, dmove: function(x, y) {\\n    return this.dx(x).dy(y)\\n  }\\n})\\n\\nSVG.extend(SVG.Rect, SVG.Ellipse, SVG.Circle, SVG.Gradient, SVG.FX, {\\n  // Add x and y radius\\n  radius: function(x, y) {\\n    var type = (this._target || this).type;\\n    return type == 'radial' || type == 'circle' ?\\n      this.attr('r', new SVG.Number(x)) :\\n      this.rx(x).ry(y == null ? x : y)\\n  }\\n})\\n\\nSVG.extend(SVG.Path, {\\n  // Get path length\\n  length: function() {\\n    return this.node.getTotalLength()\\n  }\\n  // Get point at length\\n, pointAt: function(length) {\\n    return this.node.getPointAtLength(length)\\n  }\\n})\\n\\nSVG.extend(SVG.Parent, SVG.Text, SVG.FX, {\\n  // Set font\\n  font: function(o) {\\n    for (var k in o)\\n      k == 'leading' ?\\n        this.leading(o[k]) :\\n      k == 'anchor' ?\\n        this.attr('text-anchor', o[k]) :\\n      k == 'size' || k == 'family' || k == 'weight' || k == 'stretch' || k == 'variant' || k == 'style' ?\\n        this.attr('font-'+ k, o[k]) :\\n        this.attr(k, o[k])\\n\\n    return this\\n  }\\n})\\n\\nSVG.Set = SVG.invent({\\n  // Initialize\\n  create: function(members) {\\n    // Set initial state\\n    Array.isArray(members) ? this.members = members : this.clear()\\n  }\\n\\n  // Add class methods\\n, extend: {\\n    // Add element to set\\n    add: function() {\\n      var i, il, elements = [].slice.call(arguments)\\n\\n      for (i = 0, il = elements.length; i < il; i++)\\n        this.members.push(elements[i])\\n\\n      return this\\n    }\\n    // Remove element from set\\n  , remove: function(element) {\\n      var i = this.index(element)\\n\\n      // remove given child\\n      if (i > -1)\\n        this.members.splice(i, 1)\\n\\n      return this\\n    }\\n    // Iterate over all members\\n  , each: function(block) {\\n      for (var i = 0, il = this.members.length; i < il; i++)\\n        block.apply(this.members[i], [i, this.members])\\n\\n      return this\\n    }\\n    // Restore to defaults\\n  , clear: function() {\\n      // initialize store\\n      this.members = []\\n\\n      return this\\n    }\\n    // Get the length of a set\\n  , length: function() {\\n      return this.members.length\\n    }\\n    // Checks if a given element is present in set\\n  , has: function(element) {\\n      return this.index(element) >= 0\\n    }\\n    // retuns index of given element in set\\n  , index: function(element) {\\n      return this.members.indexOf(element)\\n    }\\n    // Get member at given index\\n  , get: function(i) {\\n      return this.members[i]\\n    }\\n    // Get first member\\n  , first: function() {\\n      return this.get(0)\\n    }\\n    // Get last member\\n  , last: function() {\\n      return this.get(this.members.length - 1)\\n    }\\n    // Default value\\n  , valueOf: function() {\\n      return this.members\\n    }\\n    // Get the bounding box of all members included or empty box if set has no items\\n  , bbox: function(){\\n      var box = new SVG.BBox()\\n\\n      // return an empty box of there are no members\\n      if (this.members.length == 0)\\n        return box\\n\\n      // get the first rbox and update the target bbox\\n      var rbox = this.members[0].rbox()\\n      box.x      = rbox.x\\n      box.y      = rbox.y\\n      box.width  = rbox.width\\n      box.height = rbox.height\\n\\n      this.each(function() {\\n        // user rbox for correct position and visual representation\\n        box = box.merge(this.rbox())\\n      })\\n\\n      return box\\n    }\\n  }\\n\\n  // Add parent method\\n, construct: {\\n    // Create a new set\\n    set: function(members) {\\n      return new SVG.Set(members)\\n    }\\n  }\\n})\\n\\nSVG.FX.Set = SVG.invent({\\n  // Initialize node\\n  create: function(set) {\\n    // store reference to set\\n    this.set = set\\n  }\\n\\n})\\n\\n// Alias methods\\nSVG.Set.inherit = function() {\\n  var m\\n    , methods = []\\n\\n  // gather shape methods\\n  for(var m in SVG.Shape.prototype)\\n    if (typeof SVG.Shape.prototype[m] == 'function' && typeof SVG.Set.prototype[m] != 'function')\\n      methods.push(m)\\n\\n  // apply shape aliasses\\n  methods.forEach(function(method) {\\n    SVG.Set.prototype[method] = function() {\\n      for (var i = 0, il = this.members.length; i < il; i++)\\n        if (this.members[i] && typeof this.members[i][method] == 'function')\\n          this.members[i][method].apply(this.members[i], arguments)\\n\\n      return method == 'animate' ? (this.fx || (this.fx = new SVG.FX.Set(this))) : this\\n    }\\n  })\\n\\n  // clear methods for the next round\\n  methods = []\\n\\n  // gather fx methods\\n  for(var m in SVG.FX.prototype)\\n    if (typeof SVG.FX.prototype[m] == 'function' && typeof SVG.FX.Set.prototype[m] != 'function')\\n      methods.push(m)\\n\\n  // apply fx aliasses\\n  methods.forEach(function(method) {\\n    SVG.FX.Set.prototype[method] = function() {\\n      for (var i = 0, il = this.set.members.length; i < il; i++)\\n        this.set.members[i].fx[method].apply(this.set.members[i].fx, arguments)\\n\\n      return this\\n    }\\n  })\\n}\\n\\n\\n\\n\\nSVG.extend(SVG.Element, {\\n  // Store data values on svg nodes\\n  data: function(a, v, r) {\\n    if (typeof a == 'object') {\\n      for (v in a)\\n        this.data(v, a[v])\\n\\n    } else if (arguments.length < 2) {\\n      try {\\n        return JSON.parse(this.attr('data-' + a))\\n      } catch(e) {\\n        return this.attr('data-' + a)\\n      }\\n\\n    } else {\\n      this.attr(\\n        'data-' + a\\n      , v === null ?\\n          null :\\n        r === true || typeof v === 'string' || typeof v === 'number' ?\\n          v :\\n          JSON.stringify(v)\\n      )\\n    }\\n\\n    return this\\n  }\\n})\\nSVG.extend(SVG.Element, {\\n  // Remember arbitrary data\\n  remember: function(k, v) {\\n    // remember every item in an object individually\\n    if (typeof arguments[0] == 'object')\\n      for (var v in k)\\n        this.remember(v, k[v])\\n\\n    // retrieve memory\\n    else if (arguments.length == 1)\\n      return this.memory()[k]\\n\\n    // store memory\\n    else\\n      this.memory()[k] = v\\n\\n    return this\\n  }\\n\\n  // Erase a given memory\\n, forget: function() {\\n    if (arguments.length == 0)\\n      this._memory = {}\\n    else\\n      for (var i = arguments.length - 1; i >= 0; i--)\\n        delete this.memory()[arguments[i]]\\n\\n    return this\\n  }\\n\\n  // Initialize or return local memory object\\n, memory: function() {\\n    return this._memory || (this._memory = {})\\n  }\\n\\n})\\n// Method for getting an element by id\\nSVG.get = function(id) {\\n  var node = document.getElementById(idFromReference(id) || id)\\n  return SVG.adopt(node)\\n}\\n\\n// Select elements by query string\\nSVG.select = function(query, parent) {\\n  return new SVG.Set(\\n    SVG.utils.map((parent || document).querySelectorAll(query), function(node) {\\n      return SVG.adopt(node)\\n    })\\n  )\\n}\\n\\nSVG.extend(SVG.Parent, {\\n  // Scoped select method\\n  select: function(query) {\\n    return SVG.select(query, this.node)\\n  }\\n\\n})\\nfunction is(el, obj){\\n  return el instanceof obj\\n}\\n\\n// tests if a given selector matches an element\\nfunction matches(el, selector) {\\n  return (el.matches || el.matchesSelector || el.msMatchesSelector || el.mozMatchesSelector || el.webkitMatchesSelector || el.oMatchesSelector).call(el, selector);\\n}\\n\\n// Convert dash-separated-string to camelCase\\nfunction camelCase(s) {\\n  return s.toLowerCase().replace(/-(.)/g, function(m, g) {\\n    return g.toUpperCase()\\n  })\\n}\\n\\n// Capitalize first letter of a string\\nfunction capitalize(s) {\\n  return s.charAt(0).toUpperCase() + s.slice(1)\\n}\\n\\n// Ensure to six-based hex\\nfunction fullHex(hex) {\\n  return hex.length == 4 ?\\n    [ '#',\\n      hex.substring(1, 2), hex.substring(1, 2)\\n    , hex.substring(2, 3), hex.substring(2, 3)\\n    , hex.substring(3, 4), hex.substring(3, 4)\\n    ].join('') : hex\\n}\\n\\n// Component to hex value\\nfunction compToHex(comp) {\\n  var hex = comp.toString(16)\\n  return hex.length == 1 ? '0' + hex : hex\\n}\\n\\n// Calculate proportional width and height values when necessary\\nfunction proportionalSize(element, width, height) {\\n  if (width == null || height == null) {\\n    var box = element.bbox()\\n\\n    if (width == null)\\n      width = box.width / box.height * height\\n    else if (height == null)\\n      height = box.height / box.width * width\\n  }\\n\\n  return {\\n    width:  width\\n  , height: height\\n  }\\n}\\n\\n// Delta transform point\\nfunction deltaTransformPoint(matrix, x, y) {\\n  return {\\n    x: x * matrix.a + y * matrix.c + 0\\n  , y: x * matrix.b + y * matrix.d + 0\\n  }\\n}\\n\\n// Map matrix array to object\\nfunction arrayToMatrix(a) {\\n  return { a: a[0], b: a[1], c: a[2], d: a[3], e: a[4], f: a[5] }\\n}\\n\\n// Parse matrix if required\\nfunction parseMatrix(matrix) {\\n  if (!(matrix instanceof SVG.Matrix))\\n    matrix = new SVG.Matrix(matrix)\\n\\n  return matrix\\n}\\n\\n// Add centre point to transform object\\nfunction ensureCentre(o, target) {\\n  o.cx = o.cx == null ? target.bbox().cx : o.cx\\n  o.cy = o.cy == null ? target.bbox().cy : o.cy\\n}\\n\\n// Convert string to matrix\\nfunction stringToMatrix(source) {\\n  // remove matrix wrapper and split to individual numbers\\n  source = source\\n    .replace(SVG.regex.whitespace, '')\\n    .replace(SVG.regex.matrix, '')\\n    .split(SVG.regex.matrixElements)\\n\\n  // convert string values to floats and convert to a matrix-formatted object\\n  return arrayToMatrix(\\n    SVG.utils.map(source, function(n) {\\n      return parseFloat(n)\\n    })\\n  )\\n}\\n\\n// Calculate position according to from and to\\nfunction at(o, pos) {\\n  // number recalculation (don't bother converting to SVG.Number for performance reasons)\\n  return typeof o.from == 'number' ?\\n    o.from + (o.to - o.from) * pos :\\n\\n  // instance recalculation\\n  o instanceof SVG.Color || o instanceof SVG.Number || o instanceof SVG.Matrix ? o.at(pos) :\\n\\n  // for all other values wait until pos has reached 1 to return the final value\\n  pos < 1 ? o.from : o.to\\n}\\n\\n// PathArray Helpers\\nfunction arrayToString(a) {\\n  for (var i = 0, il = a.length, s = ''; i < il; i++) {\\n    s += a[i][0]\\n\\n    if (a[i][1] != null) {\\n      s += a[i][1]\\n\\n      if (a[i][2] != null) {\\n        s += ' '\\n        s += a[i][2]\\n\\n        if (a[i][3] != null) {\\n          s += ' '\\n          s += a[i][3]\\n          s += ' '\\n          s += a[i][4]\\n\\n          if (a[i][5] != null) {\\n            s += ' '\\n            s += a[i][5]\\n            s += ' '\\n            s += a[i][6]\\n\\n            if (a[i][7] != null) {\\n              s += ' '\\n              s += a[i][7]\\n            }\\n          }\\n        }\\n      }\\n    }\\n  }\\n\\n  return s + ' '\\n}\\n\\n// Deep new id assignment\\nfunction assignNewId(node) {\\n  // do the same for SVG child nodes as well\\n  for (var i = node.childNodes.length - 1; i >= 0; i--)\\n    if (node.childNodes[i] instanceof SVGElement)\\n      assignNewId(node.childNodes[i])\\n\\n  return SVG.adopt(node).id(SVG.eid(node.nodeName))\\n}\\n\\n// Add more bounding box properties\\nfunction fullBox(b) {\\n  if (b.x == null) {\\n    b.x      = 0\\n    b.y      = 0\\n    b.width  = 0\\n    b.height = 0\\n  }\\n\\n  b.w  = b.width\\n  b.h  = b.height\\n  b.x2 = b.x + b.width\\n  b.y2 = b.y + b.height\\n  b.cx = b.x + b.width / 2\\n  b.cy = b.y + b.height / 2\\n\\n  return b\\n}\\n\\n// Get id from reference string\\nfunction idFromReference(url) {\\n  var m = url.toString().match(SVG.regex.reference)\\n\\n  if (m) return m[1]\\n}\\n\\n// Create matrix array for looping\\nvar abcdef = 'abcdef'.split('')\\n// Add CustomEvent to IE9 and IE10\\nif (typeof CustomEvent !== 'function') {\\n  // Code from: https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent\\n  var CustomEvent = function(event, options) {\\n    options = options || { bubbles: false, cancelable: false, detail: undefined }\\n    var e = document.createEvent('CustomEvent')\\n    e.initCustomEvent(event, options.bubbles, options.cancelable, options.detail)\\n    return e\\n  }\\n\\n  CustomEvent.prototype = window.Event.prototype\\n\\n  window.CustomEvent = CustomEvent\\n}\\n\\n// requestAnimationFrame / cancelAnimationFrame Polyfill with fallback based on Paul Irish\\n(function(w) {\\n  var lastTime = 0\\n  var vendors = ['moz', 'webkit']\\n\\n  for(var x = 0; x < vendors.length && !window.requestAnimationFrame; ++x) {\\n    w.requestAnimationFrame = w[vendors[x] + 'RequestAnimationFrame']\\n    w.cancelAnimationFrame  = w[vendors[x] + 'CancelAnimationFrame'] ||\\n                              w[vendors[x] + 'CancelRequestAnimationFrame']\\n  }\\n\\n  w.requestAnimationFrame = w.requestAnimationFrame ||\\n    function(callback) {\\n      var currTime = new Date().getTime()\\n      var timeToCall = Math.max(0, 16 - (currTime - lastTime))\\n\\n      var id = w.setTimeout(function() {\\n        callback(currTime + timeToCall)\\n      }, timeToCall)\\n\\n      lastTime = currTime + timeToCall\\n      return id\\n    }\\n\\n  w.cancelAnimationFrame = w.cancelAnimationFrame || w.clearTimeout;\\n\\n}(window))\\n\\nreturn SVG\\n\\n}));\\n\",\"x\":510,\"y\":1760,\"wires\":[[\"e21a4cb3.4b8f98\"]]},{\"id\":\"e21a4cb3.4b8f98\",\"type\":\"template\",\"z\":\"b0ed7852.d58f08\",\"name\":\"draggable\",\"field\":\"payload.draggable\",\"fieldType\":\"msg\",\"format\":\"handlebars\",\"syntax\":\"mustache\",\"template\":\";(function() {\\n\\n  // creates handler, saves it\\n  function DragHandler(el){\\n    el.remember('_draggable', this)\\n    this.el = el\\n  }\\n\\n\\n  // Sets new parameter, starts dragging\\n  DragHandler.prototype.init = function(constraint, val){\\n    var _this = this\\n    this.constraint = constraint\\n    this.value = val\\n    this.el.on('mousedown.drag', function(e){ _this.start(e) })\\n    this.el.on('touchstart.drag', function(e){ _this.start(e) })\\n  }\\n\\n  // transforms one point from screen to user coords\\n  DragHandler.prototype.transformPoint = function(event, offset){\\n      event = event || window.event\\n      var touches = event.changedTouches && event.changedTouches[0] || event\\n      this.p.x = touches.pageX - (offset || 0)\\n      this.p.y = touches.pageY\\n      return this.p.matrixTransform(this.m)\\n  }\\n\\n  // gets elements bounding box with special handling of groups, nested and use\\n  DragHandler.prototype.getBBox = function(){\\n\\n    var box = this.el.bbox()\\n\\n    if(this.el instanceof SVG.Nested) box = this.el.rbox()\\n\\n    if (this.el instanceof SVG.G || this.el instanceof SVG.Use || this.el instanceof SVG.Nested) {\\n      box.x = this.el.x()\\n      box.y = this.el.y()\\n    }\\n\\n    return box\\n  }\\n\\n  // start dragging\\n  DragHandler.prototype.start = function(e){\\n\\n    // check for left button\\n    if(e.type == 'click'|| e.type == 'mousedown' || e.type == 'mousemove'){\\n      if((e.which || e.buttons) != 1){\\n          return\\n      }\\n    }\\n\\n    var _this = this\\n\\n    // fire beforedrag event\\n    this.el.fire('beforedrag', { event: e, handler: this })\\n\\n    // search for parent on the fly to make sure we can call\\n    // draggable() even when element is not in the dom currently\\n    this.parent = this.parent || this.el.parent(SVG.Nested) || this.el.parent(SVG.Doc)\\n    this.p = this.parent.node.createSVGPoint()\\n\\n    // save current transformation matrix\\n    this.m = this.el.node.getScreenCTM().inverse()\\n\\n    var box = this.getBBox()\\n\\n    var anchorOffset;\\n\\n    // fix text-anchor in text-element (#37)\\n    if(this.el instanceof SVG.Text){\\n      anchorOffset = this.el.node.getComputedTextLength();\\n\\n      switch(this.el.attr('text-anchor')){\\n        case 'middle':\\n          anchorOffset /= 2;\\n          break\\n        case 'start':\\n          anchorOffset = 0;\\n          break;\\n      }\\n    }\\n\\n    this.startPoints = {\\n      // We take absolute coordinates since we are just using a delta here\\n      point: this.transformPoint(e, anchorOffset),\\n      box:   box,\\n      transform: this.el.transform()\\n    }\\n\\n    // add drag and end events to window\\n    SVG.on(window, 'mousemove.drag', function(e){ _this.drag(e) })\\n    SVG.on(window, 'touchmove.drag', function(e){ _this.drag(e) })\\n    SVG.on(window, 'mouseup.drag', function(e){ _this.end(e) })\\n    SVG.on(window, 'touchend.drag', function(e){ _this.end(e) })\\n\\n    // fire dragstart event\\n    this.el.fire('dragstart', {event: e, p: this.startPoints.point, m: this.m, handler: this})\\n\\n    // prevent browser drag behavior\\n    e.preventDefault()\\n\\n    // prevent propagation to a parent that might also have dragging enabled\\n    e.stopPropagation();\\n  }\\n\\n  // while dragging\\n  DragHandler.prototype.drag = function(e){\\n\\n    var box = this.getBBox()\\n      , p   = this.transformPoint(e)\\n      , x   = this.startPoints.box.x + p.x - this.startPoints.point.x\\n      , y   = this.startPoints.box.y + p.y - this.startPoints.point.y\\n      , c   = this.constraint\\n      , gx  = p.x - this.startPoints.point.x\\n      , gy  = p.y - this.startPoints.point.y\\n\\n    var event = new CustomEvent('dragmove', {\\n        detail: {\\n            event: e\\n          , p: p\\n          , m: this.m\\n          , handler: this\\n        }\\n      , cancelable: true\\n    })\\n\\n    this.el.fire(event)\\n\\n    if(event.defaultPrevented) return p\\n\\n    // move the element to its new position, if possible by constraint\\n    if (typeof c == 'function') {\\n\\n      var coord = c.call(this.el, x, y, this.m)\\n\\n      // bool, just show us if movement is allowed or not\\n      if (typeof coord == 'boolean') {\\n        coord = {\\n          x: coord,\\n          y: coord\\n        }\\n      }\\n\\n      // if true, we just move. If !false its a number and we move it there\\n      if (coord.x === true) {\\n        this.el.x(x)\\n      } else if (coord.x !== false) {\\n        this.el.x(coord.x)\\n      }\\n\\n      if (coord.y === true) {\\n        this.el.y(y)\\n      } else if (coord.y !== false) {\\n        this.el.y(coord.y)\\n      }\\n\\n    } else if (typeof c == 'object') {\\n\\n      // keep element within constrained box\\n      if (c.minX != null && x < c.minX)\\n        x = c.minX\\n      else if (c.maxX != null && x > c.maxX - box.width){\\n        x = c.maxX - box.width\\n      }if (c.minY != null && y < c.minY)\\n        y = c.minY\\n      else if (c.maxY != null && y > c.maxY - box.height)\\n        y = c.maxY - box.height\\n\\n      if(this.el instanceof SVG.G)\\n        this.el.matrix(this.startPoints.transform).transform({x:gx, y: gy}, true)\\n      else\\n        this.el.move(x, y)\\n    }\\n\\n    // so we can use it in the end-method, too\\n    return p\\n  }\\n\\n  DragHandler.prototype.end = function(e){\\n\\n    // final drag\\n    var p = this.drag(e);\\n\\n    // fire dragend event\\n    this.el.fire('dragend', { event: e, p: p, m: this.m, handler: this })\\n\\n    // unbind events\\n    SVG.off(window, 'mousemove.drag')\\n    SVG.off(window, 'touchmove.drag')\\n    SVG.off(window, 'mouseup.drag')\\n    SVG.off(window, 'touchend.drag')\\n\\n  }\\n\\n  SVG.extend(SVG.Element, {\\n    // Make element draggable\\n    // Constraint might be an object (as described in readme.md) or a function in the form \\\"function (x, y)\\\" that gets called before every move.\\n    // The function can return a boolean or an object of the form {x, y}, to which the element will be moved. \\\"False\\\" skips moving, true moves to raw x, y.\\n    draggable: function(value, constraint) {\\n\\n      // Check the parameters and reassign if needed\\n      if (typeof value == 'function' || typeof value == 'object') {\\n        constraint = value\\n        value = true\\n      }\\n\\n      var dragHandler = this.remember('_draggable') || new DragHandler(this)\\n\\n      // When no parameter is given, value is true\\n      value = typeof value === 'undefined' ? true : value\\n\\n      if(value) dragHandler.init(constraint || {}, value)\\n      else {\\n        this.off('mousedown.drag')\\n        this.off('touchstart.drag')\\n      }\\n\\n      return this\\n    }\\n\\n  })\\n\\n}).call(this);\\n\",\"x\":640,\"y\":1760,\"wires\":[[\"806e2715.ce426\"]]}]\n\n\n```\n\n- \u300ctest514.html\u3092\u8fd4\u3059\u300d\u30c6\u30f3\u30d7\u30ec\u30fc\u30c8\u30ce\u30fc\u30c9\u306e149\u884c\u76ee\u306e`var connection = new WebSocket('wss://\u3053\u306eIoT\u30a2\u30d7\u30ea\u306e\u540d\u524d.mybluemix.net/wss/flow514');`\u3092\u30a2\u30d7\u30ea\u540d\u306b\u5408\u308f\u305b\u3066\u5909\u66f4\u3057\u307e\u3059\n\n\n- \u8868\u793a\u3055\u308c\u305f\u753b\u9762\u53f3\u4e0a\u306e\u7dd1\u306e\u4e38\u30a2\u30a4\u30b3\u30f3\u3092\u30c9\u30e9\u30c3\u30b0\uff06\u30c9\u30ed\u30c3\u30d7\u3057\u3066\u30bb\u30f3\u30b5\u30fc\u304c\u8a2d\u7f6e\u3055\u308c\u305f\u5834\u6240\u306b\u7f6e\u304d\u307e\u3059\u3002\u3053\u306e\u4f8b\u3067\u306f\u7167\u5ea6\u306b\u5fdc\u3058\u3066\u4e38\u30a2\u30a4\u30b3\u30f3\u306e\u8272\u3092\u5909\u5316\u3055\u305b\u3066\u3044\u307e\u3059\n![\u30b9\u30af\u30ea\u30fc\u30f3\u30b7\u30e7\u30c3\u30c8 2017-02-17 10.58.55.png](https://qiita-image-store.s3.amazonaws.com/0/125842/f6856583-61d1-6b82-ff80-c41161afc98c.png)\n\n"}