{"context": " More than 1 year has passed since last update.\n1/3\u304b\u3089\u306e\u7d9a\u304d\u3067\u3059\u3002\n\n\nService\u306e\u5b9f\u88c5\n\n\u30ea\u30bd\u30fc\u30b9\u30d5\u30a1\u30a4\u30eb\u306e\u8ffd\u52a0\n\u753b\u50cf\u3092\u8ffd\u52a0\u3057\u307e\u3059\u3002\n\n\nwatchface\u306e\u80cc\u666f\u753b\u50cf\u3068\u3001\u30d7\u30ec\u30d3\u30e5\u30fc\u7528\u306e\u753b\u50cf\u3092\u8ffd\u52a0\u3057\u307e\u3059\u3002\n\u3068\u308a\u3042\u3048\u305a\u3001\u80cc\u666f\u753b\u50cf\u3068\u3057\u3066\u4ee5\u4e0b\u306e\u69d8\u306a320*320\u304f\u3089\u3044\u306e\u9ed2\u3067\u5857\u308a\u3064\u3076\u3057\u305f\u30d5\u30a1\u30a4\u30eb\u3092\u7528\u610f\u3057\u307e\u3057\u3087\u3046\u3002\u30d5\u30a1\u30a4\u30eb\u540d\u306f\u3001\u3053\u3053\u3067\u306f\"bg.xxx\"\u3068\u3057\u307e\u3059\u3002(xxx\u306fpng\u3084jpg\u7b49\u3001\u753b\u50cf\u5f62\u5f0f\u306b\u3042\u308f\u305b\u3066\u5165\u529b\u3057\u3066\u4e0b\u3055\u3044)\n\u305d\u306e\u30d5\u30a1\u30a4\u30eb\u3092\u3001wear\u2192res\u2192drawable\u306b\u5165\u308c\u307e\u3059\u3002\u753b\u50cf\u3092\u30b3\u30d4\u30fc\u3057\u3066\u3001drawable\u306e\u4e0a\u3067\u30da\u30fc\u30b9\u30c8\u3059\u308b\u3068\u3001\u5165\u308a\u307e\u3059\u3002\n\n\n\n\u6b21\u306b\u3001\u30d7\u30ec\u30d3\u30e5\u30fc\u7528\u306e\u753b\u50cf\u3092\u8ffd\u52a0\u3057\u307e\u3059\u3002\n\u30d7\u30ec\u30d3\u30e5\u30fc\u7528\u306e\u753b\u50cf\u306f\u3001\u5186\u5f62\u306ewearable\u3068\u56db\u89d2\u5f62\u306ewearable\u7528\u306b2\u7a2e\u985e\u7528\u610f\u3059\u308b\u5fc5\u8981\u304c\u3042\u308a\u307e\u3059\u3002\n\u4e2d\u8eab\u306f\u540c\u3058\u3067\u3082\u554f\u984c\u306a\u3044\u306e\u3067\u3059\u304c\u3001\u3068\u308a\u3042\u3048\u305a\u4ee5\u4e0b\u306e\u3088\u3046\u306a\u753b\u50cf\u30d5\u30a1\u30a4\u30eb\u3092\u7528\u610f\u3057\u307e\u3057\u305f\u3002\n\u80cc\u666f\u753b\u50cf\u3068\u540c\u69d8\u306b\u3001drawable\u306b\u5165\u308c\u307e\u3059\u3002\u30d5\u30a1\u30a4\u30eb\u540d\u306f\u3001\u305d\u308c\u305e\u308c\"preview.xxx\"\u3001\"preview_circular.xxx\"\u3068\u3057\u307e\u3059\u3002\n\n \n\n\u30b3\u30fc\u30c9\u306e\u8a18\u8ff0\n1/3\u3067\u4f5c\u6210\u3057\u305f\u3001AnalogWatchFaceService\u306b\u3001\u4ee5\u4e0b\u3092\u8a18\u8ff0\u3057\u307e\u3057\u305f\u3002\u3068\u308a\u3042\u3048\u305a\u52d5\u4f5c\u78ba\u8a8d\u7528\u306b\u4f7f\u7528\u3059\u308b\u3060\u3051\u306a\u306e\u3067\u3001\u30b3\u30d4\u30da\u3057\u3066\u3057\u307e\u3063\u3066\u304f\u3060\u3055\u3044\u3002\u306a\u304a\u3001\u3053\u306e\u30b3\u30fc\u30c9\u306f\u3001SDK\u306e\u30b5\u30f3\u30d7\u30eb\u3092\u305d\u306e\u307e\u307e\u4f7f\u7528\u3057\u3066\u3044\u307e\u3059\u3002(android-sdk/samples/android-21/wearable/WatchFace)\npublic class AnalogWatchFaceService extends CanvasWatchFaceService {\n  private static final String TAG = \"AnalogWatchFaceService\";\n\n  /**\n   * Update rate in milliseconds for interactive mode. We update once a second to advance the\n   * second hand.\n   */\n  private static final long INTERACTIVE_UPDATE_RATE_MS = TimeUnit.SECONDS.toMillis(1);\n\n  @Override\n  public Engine onCreateEngine() {\n    return new Engine();\n  }\n\n  private class Engine extends CanvasWatchFaceService.Engine {\n    static final int MSG_UPDATE_TIME = 0;\n\n    static final float TWO_PI = (float) Math.PI * 2f;\n\n    Paint mHourPaint;\n    Paint mMinutePaint;\n    Paint mSecondPaint;\n    Paint mTickPaint;\n    boolean mMute;\n    Calendar mCalendar;\n\n    /**\n     * Handler to update the time once a second in interactive mode.\n     */\n    final Handler mUpdateTimeHandler = new Handler() {\n      @Override\n      public void handleMessage(Message message) {\n        switch (message.what) {\n          case MSG_UPDATE_TIME:\n            if (Log.isLoggable(TAG, Log.VERBOSE)) {\n              Log.v(TAG, \"updating time\");\n            }\n            invalidate();\n            if (shouldTimerBeRunning()) {\n              long timeMs = System.currentTimeMillis();\n              long delayMs = INTERACTIVE_UPDATE_RATE_MS\n                  - (timeMs % INTERACTIVE_UPDATE_RATE_MS);\n              mUpdateTimeHandler.sendEmptyMessageDelayed(MSG_UPDATE_TIME, delayMs);\n            }\n            break;\n        }\n      }\n    };\n\n    final BroadcastReceiver mTimeZoneReceiver = new BroadcastReceiver() {\n      @Override\n      public void onReceive(Context context, Intent intent) {\n        mCalendar.setTimeZone(TimeZone.getDefault());\n        invalidate();\n      }\n    };\n    boolean mRegisteredTimeZoneReceiver = false;\n\n    /**\n     * Whether the display supports fewer bits for each color in ambient mode. When true, we\n     * disable anti-aliasing in ambient mode.\n     */\n    boolean mLowBitAmbient;\n\n    Bitmap mBackgroundBitmap;\n    Bitmap mBackgroundScaledBitmap;\n\n    @Override\n    public void onCreate(SurfaceHolder holder) {\n      if (Log.isLoggable(TAG, Log.DEBUG)) {\n        Log.d(TAG, \"onCreate\");\n      }\n      super.onCreate(holder);\n\n      setWatchFaceStyle(new WatchFaceStyle.Builder(AnalogWatchFaceService.this)\n          .setCardPeekMode(WatchFaceStyle.PEEK_MODE_SHORT)\n          .setBackgroundVisibility(WatchFaceStyle.BACKGROUND_VISIBILITY_INTERRUPTIVE)\n          .setShowSystemUiTime(false)\n          .build());\n\n      Resources resources = AnalogWatchFaceService.this.getResources();\n      Drawable backgroundDrawable = resources.getDrawable(R.drawable.bg, null /* theme */);\n      mBackgroundBitmap = ((BitmapDrawable) backgroundDrawable).getBitmap();\n\n      mHourPaint = new Paint();\n      mHourPaint.setARGB(255, 200, 200, 200);\n      mHourPaint.setStrokeWidth(5.f);\n      mHourPaint.setAntiAlias(true);\n      mHourPaint.setStrokeCap(Paint.Cap.ROUND);\n\n      mMinutePaint = new Paint();\n      mMinutePaint.setARGB(255, 200, 200, 200);\n      mMinutePaint.setStrokeWidth(3.f);\n      mMinutePaint.setAntiAlias(true);\n      mMinutePaint.setStrokeCap(Paint.Cap.ROUND);\n\n      mSecondPaint = new Paint();\n      mSecondPaint.setARGB(255, 255, 0, 0);\n      mSecondPaint.setStrokeWidth(2.f);\n      mSecondPaint.setAntiAlias(true);\n      mSecondPaint.setStrokeCap(Paint.Cap.ROUND);\n\n      mTickPaint = new Paint();\n      mTickPaint.setARGB(100, 255, 255, 255);\n      mTickPaint.setStrokeWidth(2.f);\n      mTickPaint.setAntiAlias(true);\n\n      mCalendar = Calendar.getInstance();\n    }\n\n    @Override\n    public void onDestroy() {\n      mUpdateTimeHandler.removeMessages(MSG_UPDATE_TIME);\n      super.onDestroy();\n    }\n\n    @Override\n    public void onPropertiesChanged(Bundle properties) {\n      super.onPropertiesChanged(properties);\n      mLowBitAmbient = properties.getBoolean(PROPERTY_LOW_BIT_AMBIENT, false);\n      if (Log.isLoggable(TAG, Log.DEBUG)) {\n        Log.d(TAG, \"onPropertiesChanged: low-bit ambient = \" + mLowBitAmbient);\n      }\n    }\n\n    @Override\n    public void onTimeTick() {\n      super.onTimeTick();\n      if (Log.isLoggable(TAG, Log.DEBUG)) {\n        Log.d(TAG, \"onTimeTick: ambient = \" + isInAmbientMode());\n      }\n      invalidate();\n    }\n\n    @Override\n    public void onAmbientModeChanged(boolean inAmbientMode) {\n      super.onAmbientModeChanged(inAmbientMode);\n      if (Log.isLoggable(TAG, Log.DEBUG)) {\n        Log.d(TAG, \"onAmbientModeChanged: \" + inAmbientMode);\n      }\n      if (mLowBitAmbient) {\n        boolean antiAlias = !inAmbientMode;\n        mHourPaint.setAntiAlias(antiAlias);\n        mMinutePaint.setAntiAlias(antiAlias);\n        mSecondPaint.setAntiAlias(antiAlias);\n        mTickPaint.setAntiAlias(antiAlias);\n      }\n      invalidate();\n\n      // Whether the timer should be running depends on whether we're in ambient mode (as well\n      // as whether we're visible), so we may need to start or stop the timer.\n      updateTimer();\n    }\n\n    @Override\n    public void onInterruptionFilterChanged(int interruptionFilter) {\n      super.onInterruptionFilterChanged(interruptionFilter);\n      boolean inMuteMode = (interruptionFilter == WatchFaceService.INTERRUPTION_FILTER_NONE);\n      if (mMute != inMuteMode) {\n        mMute = inMuteMode;\n        mHourPaint.setAlpha(inMuteMode ? 100 : 255);\n        mMinutePaint.setAlpha(inMuteMode ? 100 : 255);\n        mSecondPaint.setAlpha(inMuteMode ? 80 : 255);\n        invalidate();\n      }\n    }\n\n    @Override\n    public void onDraw(Canvas canvas, Rect bounds) {\n      mCalendar.setTimeInMillis(System.currentTimeMillis());\n\n      int width = bounds.width();\n      int height = bounds.height();\n\n      // Draw the background, scaled to fit.\n      if (mBackgroundScaledBitmap == null\n          || mBackgroundScaledBitmap.getWidth() != width\n          || mBackgroundScaledBitmap.getHeight() != height) {\n        mBackgroundScaledBitmap = Bitmap.createScaledBitmap(mBackgroundBitmap,\n            width, height, true /* filter */);\n      }\n      canvas.drawBitmap(mBackgroundScaledBitmap, 0, 0, null);\n\n      // Find the center. Ignore the window insets so that, on round watches with a\n      // \"chin\", the watch face is centered on the entire screen, not just the usable\n      // portion.\n      float centerX = width / 2f;\n      float centerY = height / 2f;\n\n      // Draw the ticks.\n      float innerTickRadius = centerX - 10;\n      float outerTickRadius = centerX;\n      for (int tickIndex = 0; tickIndex < 12; tickIndex++) {\n        float tickRot = tickIndex * TWO_PI / 12;\n        float innerX = (float) Math.sin(tickRot) * innerTickRadius;\n        float innerY = (float) -Math.cos(tickRot) * innerTickRadius;\n        float outerX = (float) Math.sin(tickRot) * outerTickRadius;\n        float outerY = (float) -Math.cos(tickRot) * outerTickRadius;\n        canvas.drawLine(centerX + innerX, centerY + innerY,\n            centerX + outerX, centerY + outerY, mTickPaint);\n      }\n\n      float seconds =\n          mCalendar.get(Calendar.SECOND) + mCalendar.get(Calendar.MILLISECOND) / 1000f;\n      float secRot = seconds / 60f * TWO_PI;\n      float minutes = mCalendar.get(Calendar.MINUTE) + seconds / 60f;\n      float minRot = minutes / 60f * TWO_PI;\n      float hours = mCalendar.get(Calendar.HOUR) + minutes / 60f;\n      float hrRot = hours / 12f * TWO_PI;\n\n      float secLength = centerX - 20;\n      float minLength = centerX - 40;\n      float hrLength = centerX - 80;\n\n      if (!isInAmbientMode()) {\n        float secX = (float) Math.sin(secRot) * secLength;\n        float secY = (float) -Math.cos(secRot) * secLength;\n        canvas.drawLine(centerX, centerY, centerX + secX, centerY + secY, mSecondPaint);\n      }\n\n      float minX = (float) Math.sin(minRot) * minLength;\n      float minY = (float) -Math.cos(minRot) * minLength;\n      canvas.drawLine(centerX, centerY, centerX + minX, centerY + minY, mMinutePaint);\n\n      float hrX = (float) Math.sin(hrRot) * hrLength;\n      float hrY = (float) -Math.cos(hrRot) * hrLength;\n      canvas.drawLine(centerX, centerY, centerX + hrX, centerY + hrY, mHourPaint);\n    }\n\n    @Override\n    public void onVisibilityChanged(boolean visible) {\n      super.onVisibilityChanged(visible);\n      if (Log.isLoggable(TAG, Log.DEBUG)) {\n        Log.d(TAG, \"onVisibilityChanged: \" + visible);\n      }\n\n      if (visible) {\n        registerReceiver();\n\n        // Update time zone in case it changed while we weren't visible.\n        mCalendar.setTimeZone(TimeZone.getDefault());\n      } else {\n        unregisterReceiver();\n      }\n\n      // Whether the timer should be running depends on whether we're visible (as well as\n      // whether we're in ambient mode), so we may need to start or stop the timer.\n      updateTimer();\n    }\n\n    private void registerReceiver() {\n      if (mRegisteredTimeZoneReceiver) {\n        return;\n      }\n      mRegisteredTimeZoneReceiver = true;\n      IntentFilter filter = new IntentFilter(Intent.ACTION_TIMEZONE_CHANGED);\n      AnalogWatchFaceService.this.registerReceiver(mTimeZoneReceiver, filter);\n    }\n\n    private void unregisterReceiver() {\n      if (!mRegisteredTimeZoneReceiver) {\n        return;\n      }\n      mRegisteredTimeZoneReceiver = false;\n      AnalogWatchFaceService.this.unregisterReceiver(mTimeZoneReceiver);\n    }\n\n    /**\n     * Starts the {@link #mUpdateTimeHandler} timer if it should be running and isn't currently\n     * or stops it if it shouldn't be running but currently is.\n     */\n    private void updateTimer() {\n      if (Log.isLoggable(TAG, Log.DEBUG)) {\n        Log.d(TAG, \"updateTimer\");\n      }\n      mUpdateTimeHandler.removeMessages(MSG_UPDATE_TIME);\n      if (shouldTimerBeRunning()) {\n        mUpdateTimeHandler.sendEmptyMessage(MSG_UPDATE_TIME);\n      }\n    }\n\n    /**\n     * Returns whether the {@link #mUpdateTimeHandler} timer should be running. The timer should\n     * only run when we're visible and in interactive mode.\n     */\n    private boolean shouldTimerBeRunning() {\n      return isVisible() && !isInAmbientMode();\n    }\n\n  }\n}\n\n\n\u5b9f\u884c\n\u3053\u3053\u307e\u3067\u3067\u30a8\u30e9\u30fc\u304c\u3067\u3066\u3044\u306a\u3051\u308c\u3070\u3001\u3072\u3068\u307e\u305a\u30d7\u30ed\u30b0\u30e9\u30e0\u306f\u5b8c\u6210\u3067\u3059\u3002\n\u65e9\u901f\u3001\u30a8\u30df\u30e5\u30ec\u30fc\u30bf\u30fc\u53ca\u3073\u5b9f\u6a5f\u3067\u5b9f\u884c\u3057\u3066\u307f\u307e\u3057\u3087\u3046\u3002\n\n\u30a8\u30df\u30e5\u30ec\u30fc\u30bf\u30fc\u3067\u306e\u5b9f\u884c\n\n\u30a8\u30df\u30e5\u30ec\u30fc\u30bf\u30fc\u306e\u4f5c\u6210\u53ca\u3073\u8d77\u52d5\n\n\n\u307e\u305a\u3001\u30a8\u30df\u30e5\u30ec\u30fc\u30bf\u30fc\u3092\u4f5c\u6210\u3057\u307e\u3059\u3002\nTools\u2192Android\u2192AVD Manager\u3092\u9078\u629e\u3057\u3001AVD Manager\u3092\u8d77\u52d5\u3057\u307e\u3059\u3002\nCreate Virtual Device...\u3092\u9078\u629e\u3057\u307e\u3059\u3002\n\u5de6\u5074\u306e\"Category\"\u304b\u3089\u3001\"Wear\"\u3092\u9078\u629e\u3057\u307e\u3059\u3002\n\u53f3\u5074\u306e\u3001Android Wear Square\u307e\u305f\u306fAndroid Wear Round\u3092\u9078\u629e\u3057\u307e\u3059\u3002\nSystem Image\u306f\u3001\u3068\u308a\u3042\u3048\u305aLolipop, API Level21, x86\u306e\u3082\u306e\u3092\u9078\u629e\u3057\u3066\u304a\u3051\u3070\u3044\u3044\u3068\u601d\u3044\u307e\u3059\u3002\n\"Use Host GPU\"\u306b\u306f\u3001\u4e00\u5fdc\u30c1\u30a7\u30c3\u30af\u3092\u3064\u3051\u3066\u304a\u304d\u3001Finish\u3067\u5b8c\u6210\u3067\u3059\u3002\n\u5b8c\u6210\u3057\u305f\u3089\u3001Actions\u304b\u3089\u518d\u751f\u30dc\u30bf\u30f3\u3092\u62bc\u3057\u3066\u3001\u30a8\u30df\u30e5\u30ec\u30fc\u30bf\u30fc\u3092\u8d77\u52d5\u3057\u307e\u3057\u3087\u3046\u3002\n\n\n\nWearable\u306e\u5b9f\u884c\n\n\n\u307e\u305a\u3001Run\u2192Edit Configurations...\u3092\u9078\u629e\u3057\u307e\u3059\u3002\n\u5de6\u5074\u304b\u3089\u3001wear\u3092\u9078\u629e\u3057\u307e\u3059\u3002\uff08\u73fe\u5728\u306f\u3001\u8d64\u3067\u30d0\u30c4\u304c\u4ed8\u3044\u3066\u3044\u308b\u3068\u601d\u3044\u307e\u3059\uff09\n\u53f3\u5074\u306e\u3001Activity\u306e\u90e8\u5206\u3067\u3001Do not launch Activity \u3092\u9078\u629e\u3057\u3001OK\u3068\u3057\u307e\u3059\u3002\n\n\n\n\u4ee5\u4e0b\u304b\u3089\u3001wear\u3092\u9078\u629e\u3057\u307e\u3059\u3002\n\n\n\nRun\u2192Run wear\u3092\u9078\u629e\u3057\u307e\u3059\u3002\n\n\n\nChoose a running Device\u3067\u3001\u5148\u307b\u3069\u4f5c\u6210\u3057\u305f\u30a8\u30df\u30e5\u30ec\u30fc\u30bf\u30fc\u3092\u9078\u629e\u3057\u307e\u3059\u3002\n\u753b\u9762\u4e0b\u90e8\u306e\u30014:Run\u3092\u9078\u629e\u3059\u308b\u3068\u3001\u73fe\u5728\u306e\u72b6\u6cc1\u304c\u8868\u793a\u3055\u308c\u307e\u3059\u3002\u3053\u3061\u3089\u306e\u6700\u7d42\u884c\u306b\u3001Success\u3068\u8868\u793a\u3055\u308c\u308b\u307e\u3067\u5f85\u3061\u307e\u3059\u3002\n\n\n\n\u30a8\u30df\u30e5\u30ec\u30fc\u30bf\u30fc\u4e0a\u3067\u3001\u6642\u8a08\u304c\u8868\u793a\u3055\u308c\u3066\u3044\u308b\u753b\u9762\u3067\u3001\u30af\u30ea\u30c3\u30af\u9577\u62bc\u3057\u3092\u3059\u308b\u3068\u3001watch face\u9078\u629e\u753b\u9762\u306b\u79fb\u884c\u3057\u307e\u3059\u3002\u305d\u306e\u4e2d\u306b\u3001My Application\u3068\u3044\u3046\u540d\u524d\u3067\u3001\u5148\u307b\u3069\u4f5c\u6210\u3057\u305f\u30d7\u30ec\u30d3\u30e5\u30fc\u753b\u50cf\u304c\u3042\u308b\u3068\u601d\u3044\u307e\u3059\u3002\n\u305d\u3061\u3089\u3092\u9078\u629e\u3059\u308b\u3068\u3001Watch face\u304c\u5909\u66f4\u3055\u308c\u307e\u3059\u3002\n\n\n\n\n\u5b9f\u6a5f\u3067\u306e\u5b9f\u884c\n\u4ee5\u4e0b\u304c\u8a73\u3057\u3044\u3067\u3059\u3002\u63a5\u7d9a\u304c\u3067\u304d\u305f\u3089\u3001\u30a8\u30df\u30e5\u30ec\u30fc\u30bf\u30fc\u3068\u540c\u69d8\u306b\u5b9f\u884c\u3057\u307e\u3059\u3002\n\nAndroid Wear\u5b9f\u6a5f\u3078\u306eadb\u63a5\u7d9a\n\n\n\u30ab\u30b9\u30bf\u30de\u30a4\u30ba\u7b49\n3/3\u306b\u7d9a\u304d\u307e\u3059\u3002\n\n\u53c2\u8003\u306b\u3057\u305f\u30b5\u30a4\u30c8\u7b49\n\n\u7f8e\u5973\u6642\u8a08\u3092\u4f5c\u308d\u3046\uff01Android Wear\u958b\u767a\u5165\u9580 30\u5206\u3067\u4f5c\u308b\u76e4\u9762\u30a2\u30d7\u30ea\nBuilding a Watch Face Service(Android developers)\n\n<br />\n[1/3](http://qiita.com/eoppp/items/e6f2a0783810026e4d56)\u304b\u3089\u306e\u7d9a\u304d\u3067\u3059\u3002\n<br />\n#Service\u306e\u5b9f\u88c5\n\n##\u30ea\u30bd\u30fc\u30b9\u30d5\u30a1\u30a4\u30eb\u306e\u8ffd\u52a0\n\n\u753b\u50cf\u3092\u8ffd\u52a0\u3057\u307e\u3059\u3002\n\n![\u30b9\u30af\u30ea\u30fc\u30f3\u30b7\u30e7\u30c3\u30c8 2015-01-03 22.39.56.png](https://qiita-image-store.s3.amazonaws.com/0/63716/d0776979-d816-d4d5-5980-7d949db0c5fb.png)\n\n* watchface\u306e\u80cc\u666f\u753b\u50cf\u3068\u3001\u30d7\u30ec\u30d3\u30e5\u30fc\u7528\u306e\u753b\u50cf\u3092\u8ffd\u52a0\u3057\u307e\u3059\u3002\n* \u3068\u308a\u3042\u3048\u305a\u3001\u80cc\u666f\u753b\u50cf\u3068\u3057\u3066\u4ee5\u4e0b\u306e\u69d8\u306a320*320\u304f\u3089\u3044\u306e\u9ed2\u3067\u5857\u308a\u3064\u3076\u3057\u305f\u30d5\u30a1\u30a4\u30eb\u3092\u7528\u610f\u3057\u307e\u3057\u3087\u3046\u3002\u30d5\u30a1\u30a4\u30eb\u540d\u306f\u3001\u3053\u3053\u3067\u306f\"bg.xxx\"\u3068\u3057\u307e\u3059\u3002(xxx\u306fpng\u3084jpg\u7b49\u3001\u753b\u50cf\u5f62\u5f0f\u306b\u3042\u308f\u305b\u3066\u5165\u529b\u3057\u3066\u4e0b\u3055\u3044)\n* \u305d\u306e\u30d5\u30a1\u30a4\u30eb\u3092\u3001wear\u2192res\u2192drawable\u306b\u5165\u308c\u307e\u3059\u3002\u753b\u50cf\u3092\u30b3\u30d4\u30fc\u3057\u3066\u3001drawable\u306e\u4e0a\u3067\u30da\u30fc\u30b9\u30c8\u3059\u308b\u3068\u3001\u5165\u308a\u307e\u3059\u3002\n\n![background.png](https://qiita-image-store.s3.amazonaws.com/0/63716/0051b09d-22d6-be8a-f736-5ce546d94daf.png)\n\n* \u6b21\u306b\u3001\u30d7\u30ec\u30d3\u30e5\u30fc\u7528\u306e\u753b\u50cf\u3092\u8ffd\u52a0\u3057\u307e\u3059\u3002\n* \u30d7\u30ec\u30d3\u30e5\u30fc\u7528\u306e\u753b\u50cf\u306f\u3001\u5186\u5f62\u306ewearable\u3068\u56db\u89d2\u5f62\u306ewearable\u7528\u306b2\u7a2e\u985e\u7528\u610f\u3059\u308b\u5fc5\u8981\u304c\u3042\u308a\u307e\u3059\u3002\n* \u4e2d\u8eab\u306f\u540c\u3058\u3067\u3082\u554f\u984c\u306a\u3044\u306e\u3067\u3059\u304c\u3001\u3068\u308a\u3042\u3048\u305a\u4ee5\u4e0b\u306e\u3088\u3046\u306a\u753b\u50cf\u30d5\u30a1\u30a4\u30eb\u3092\u7528\u610f\u3057\u307e\u3057\u305f\u3002\n* \u80cc\u666f\u753b\u50cf\u3068\u540c\u69d8\u306b\u3001drawable\u306b\u5165\u308c\u307e\u3059\u3002\u30d5\u30a1\u30a4\u30eb\u540d\u306f\u3001\u305d\u308c\u305e\u308c\"preview.xxx\"\u3001\"preview_circular.xxx\"\u3068\u3057\u307e\u3059\u3002\n\n![preview.png](https://qiita-image-store.s3.amazonaws.com/0/63716/4d99dffe-8a51-ee95-ddc8-3184194d8420.png)     ![preview_circular.png](https://qiita-image-store.s3.amazonaws.com/0/63716/6caa9cfc-d901-c837-00cd-f8bd28f73da2.png)\n\n##\u30b3\u30fc\u30c9\u306e\u8a18\u8ff0\n\n[1/3](http://qiita.com/eoppp/items/e6f2a0783810026e4d56)\u3067\u4f5c\u6210\u3057\u305f\u3001AnalogWatchFaceService\u306b\u3001\u4ee5\u4e0b\u3092\u8a18\u8ff0\u3057\u307e\u3057\u305f\u3002\u3068\u308a\u3042\u3048\u305a\u52d5\u4f5c\u78ba\u8a8d\u7528\u306b\u4f7f\u7528\u3059\u308b\u3060\u3051\u306a\u306e\u3067\u3001\u30b3\u30d4\u30da\u3057\u3066\u3057\u307e\u3063\u3066\u304f\u3060\u3055\u3044\u3002\u306a\u304a\u3001\u3053\u306e\u30b3\u30fc\u30c9\u306f\u3001SDK\u306e\u30b5\u30f3\u30d7\u30eb\u3092\u305d\u306e\u307e\u307e\u4f7f\u7528\u3057\u3066\u3044\u307e\u3059\u3002(android-sdk/samples/android-21/wearable/WatchFace)\n\n```\npublic class AnalogWatchFaceService extends CanvasWatchFaceService {\n  private static final String TAG = \"AnalogWatchFaceService\";\n\n  /**\n   * Update rate in milliseconds for interactive mode. We update once a second to advance the\n   * second hand.\n   */\n  private static final long INTERACTIVE_UPDATE_RATE_MS = TimeUnit.SECONDS.toMillis(1);\n\n  @Override\n  public Engine onCreateEngine() {\n    return new Engine();\n  }\n\n  private class Engine extends CanvasWatchFaceService.Engine {\n    static final int MSG_UPDATE_TIME = 0;\n\n    static final float TWO_PI = (float) Math.PI * 2f;\n\n    Paint mHourPaint;\n    Paint mMinutePaint;\n    Paint mSecondPaint;\n    Paint mTickPaint;\n    boolean mMute;\n    Calendar mCalendar;\n\n    /**\n     * Handler to update the time once a second in interactive mode.\n     */\n    final Handler mUpdateTimeHandler = new Handler() {\n      @Override\n      public void handleMessage(Message message) {\n        switch (message.what) {\n          case MSG_UPDATE_TIME:\n            if (Log.isLoggable(TAG, Log.VERBOSE)) {\n              Log.v(TAG, \"updating time\");\n            }\n            invalidate();\n            if (shouldTimerBeRunning()) {\n              long timeMs = System.currentTimeMillis();\n              long delayMs = INTERACTIVE_UPDATE_RATE_MS\n                  - (timeMs % INTERACTIVE_UPDATE_RATE_MS);\n              mUpdateTimeHandler.sendEmptyMessageDelayed(MSG_UPDATE_TIME, delayMs);\n            }\n            break;\n        }\n      }\n    };\n\n    final BroadcastReceiver mTimeZoneReceiver = new BroadcastReceiver() {\n      @Override\n      public void onReceive(Context context, Intent intent) {\n        mCalendar.setTimeZone(TimeZone.getDefault());\n        invalidate();\n      }\n    };\n    boolean mRegisteredTimeZoneReceiver = false;\n\n    /**\n     * Whether the display supports fewer bits for each color in ambient mode. When true, we\n     * disable anti-aliasing in ambient mode.\n     */\n    boolean mLowBitAmbient;\n\n    Bitmap mBackgroundBitmap;\n    Bitmap mBackgroundScaledBitmap;\n\n    @Override\n    public void onCreate(SurfaceHolder holder) {\n      if (Log.isLoggable(TAG, Log.DEBUG)) {\n        Log.d(TAG, \"onCreate\");\n      }\n      super.onCreate(holder);\n\n      setWatchFaceStyle(new WatchFaceStyle.Builder(AnalogWatchFaceService.this)\n          .setCardPeekMode(WatchFaceStyle.PEEK_MODE_SHORT)\n          .setBackgroundVisibility(WatchFaceStyle.BACKGROUND_VISIBILITY_INTERRUPTIVE)\n          .setShowSystemUiTime(false)\n          .build());\n\n      Resources resources = AnalogWatchFaceService.this.getResources();\n      Drawable backgroundDrawable = resources.getDrawable(R.drawable.bg, null /* theme */);\n      mBackgroundBitmap = ((BitmapDrawable) backgroundDrawable).getBitmap();\n\n      mHourPaint = new Paint();\n      mHourPaint.setARGB(255, 200, 200, 200);\n      mHourPaint.setStrokeWidth(5.f);\n      mHourPaint.setAntiAlias(true);\n      mHourPaint.setStrokeCap(Paint.Cap.ROUND);\n\n      mMinutePaint = new Paint();\n      mMinutePaint.setARGB(255, 200, 200, 200);\n      mMinutePaint.setStrokeWidth(3.f);\n      mMinutePaint.setAntiAlias(true);\n      mMinutePaint.setStrokeCap(Paint.Cap.ROUND);\n\n      mSecondPaint = new Paint();\n      mSecondPaint.setARGB(255, 255, 0, 0);\n      mSecondPaint.setStrokeWidth(2.f);\n      mSecondPaint.setAntiAlias(true);\n      mSecondPaint.setStrokeCap(Paint.Cap.ROUND);\n\n      mTickPaint = new Paint();\n      mTickPaint.setARGB(100, 255, 255, 255);\n      mTickPaint.setStrokeWidth(2.f);\n      mTickPaint.setAntiAlias(true);\n\n      mCalendar = Calendar.getInstance();\n    }\n\n    @Override\n    public void onDestroy() {\n      mUpdateTimeHandler.removeMessages(MSG_UPDATE_TIME);\n      super.onDestroy();\n    }\n\n    @Override\n    public void onPropertiesChanged(Bundle properties) {\n      super.onPropertiesChanged(properties);\n      mLowBitAmbient = properties.getBoolean(PROPERTY_LOW_BIT_AMBIENT, false);\n      if (Log.isLoggable(TAG, Log.DEBUG)) {\n        Log.d(TAG, \"onPropertiesChanged: low-bit ambient = \" + mLowBitAmbient);\n      }\n    }\n\n    @Override\n    public void onTimeTick() {\n      super.onTimeTick();\n      if (Log.isLoggable(TAG, Log.DEBUG)) {\n        Log.d(TAG, \"onTimeTick: ambient = \" + isInAmbientMode());\n      }\n      invalidate();\n    }\n\n    @Override\n    public void onAmbientModeChanged(boolean inAmbientMode) {\n      super.onAmbientModeChanged(inAmbientMode);\n      if (Log.isLoggable(TAG, Log.DEBUG)) {\n        Log.d(TAG, \"onAmbientModeChanged: \" + inAmbientMode);\n      }\n      if (mLowBitAmbient) {\n        boolean antiAlias = !inAmbientMode;\n        mHourPaint.setAntiAlias(antiAlias);\n        mMinutePaint.setAntiAlias(antiAlias);\n        mSecondPaint.setAntiAlias(antiAlias);\n        mTickPaint.setAntiAlias(antiAlias);\n      }\n      invalidate();\n\n      // Whether the timer should be running depends on whether we're in ambient mode (as well\n      // as whether we're visible), so we may need to start or stop the timer.\n      updateTimer();\n    }\n\n    @Override\n    public void onInterruptionFilterChanged(int interruptionFilter) {\n      super.onInterruptionFilterChanged(interruptionFilter);\n      boolean inMuteMode = (interruptionFilter == WatchFaceService.INTERRUPTION_FILTER_NONE);\n      if (mMute != inMuteMode) {\n        mMute = inMuteMode;\n        mHourPaint.setAlpha(inMuteMode ? 100 : 255);\n        mMinutePaint.setAlpha(inMuteMode ? 100 : 255);\n        mSecondPaint.setAlpha(inMuteMode ? 80 : 255);\n        invalidate();\n      }\n    }\n\n    @Override\n    public void onDraw(Canvas canvas, Rect bounds) {\n      mCalendar.setTimeInMillis(System.currentTimeMillis());\n\n      int width = bounds.width();\n      int height = bounds.height();\n\n      // Draw the background, scaled to fit.\n      if (mBackgroundScaledBitmap == null\n          || mBackgroundScaledBitmap.getWidth() != width\n          || mBackgroundScaledBitmap.getHeight() != height) {\n        mBackgroundScaledBitmap = Bitmap.createScaledBitmap(mBackgroundBitmap,\n            width, height, true /* filter */);\n      }\n      canvas.drawBitmap(mBackgroundScaledBitmap, 0, 0, null);\n\n      // Find the center. Ignore the window insets so that, on round watches with a\n      // \"chin\", the watch face is centered on the entire screen, not just the usable\n      // portion.\n      float centerX = width / 2f;\n      float centerY = height / 2f;\n\n      // Draw the ticks.\n      float innerTickRadius = centerX - 10;\n      float outerTickRadius = centerX;\n      for (int tickIndex = 0; tickIndex < 12; tickIndex++) {\n        float tickRot = tickIndex * TWO_PI / 12;\n        float innerX = (float) Math.sin(tickRot) * innerTickRadius;\n        float innerY = (float) -Math.cos(tickRot) * innerTickRadius;\n        float outerX = (float) Math.sin(tickRot) * outerTickRadius;\n        float outerY = (float) -Math.cos(tickRot) * outerTickRadius;\n        canvas.drawLine(centerX + innerX, centerY + innerY,\n            centerX + outerX, centerY + outerY, mTickPaint);\n      }\n\n      float seconds =\n          mCalendar.get(Calendar.SECOND) + mCalendar.get(Calendar.MILLISECOND) / 1000f;\n      float secRot = seconds / 60f * TWO_PI;\n      float minutes = mCalendar.get(Calendar.MINUTE) + seconds / 60f;\n      float minRot = minutes / 60f * TWO_PI;\n      float hours = mCalendar.get(Calendar.HOUR) + minutes / 60f;\n      float hrRot = hours / 12f * TWO_PI;\n\n      float secLength = centerX - 20;\n      float minLength = centerX - 40;\n      float hrLength = centerX - 80;\n\n      if (!isInAmbientMode()) {\n        float secX = (float) Math.sin(secRot) * secLength;\n        float secY = (float) -Math.cos(secRot) * secLength;\n        canvas.drawLine(centerX, centerY, centerX + secX, centerY + secY, mSecondPaint);\n      }\n\n      float minX = (float) Math.sin(minRot) * minLength;\n      float minY = (float) -Math.cos(minRot) * minLength;\n      canvas.drawLine(centerX, centerY, centerX + minX, centerY + minY, mMinutePaint);\n\n      float hrX = (float) Math.sin(hrRot) * hrLength;\n      float hrY = (float) -Math.cos(hrRot) * hrLength;\n      canvas.drawLine(centerX, centerY, centerX + hrX, centerY + hrY, mHourPaint);\n    }\n\n    @Override\n    public void onVisibilityChanged(boolean visible) {\n      super.onVisibilityChanged(visible);\n      if (Log.isLoggable(TAG, Log.DEBUG)) {\n        Log.d(TAG, \"onVisibilityChanged: \" + visible);\n      }\n\n      if (visible) {\n        registerReceiver();\n\n        // Update time zone in case it changed while we weren't visible.\n        mCalendar.setTimeZone(TimeZone.getDefault());\n      } else {\n        unregisterReceiver();\n      }\n\n      // Whether the timer should be running depends on whether we're visible (as well as\n      // whether we're in ambient mode), so we may need to start or stop the timer.\n      updateTimer();\n    }\n\n    private void registerReceiver() {\n      if (mRegisteredTimeZoneReceiver) {\n        return;\n      }\n      mRegisteredTimeZoneReceiver = true;\n      IntentFilter filter = new IntentFilter(Intent.ACTION_TIMEZONE_CHANGED);\n      AnalogWatchFaceService.this.registerReceiver(mTimeZoneReceiver, filter);\n    }\n\n    private void unregisterReceiver() {\n      if (!mRegisteredTimeZoneReceiver) {\n        return;\n      }\n      mRegisteredTimeZoneReceiver = false;\n      AnalogWatchFaceService.this.unregisterReceiver(mTimeZoneReceiver);\n    }\n\n    /**\n     * Starts the {@link #mUpdateTimeHandler} timer if it should be running and isn't currently\n     * or stops it if it shouldn't be running but currently is.\n     */\n    private void updateTimer() {\n      if (Log.isLoggable(TAG, Log.DEBUG)) {\n        Log.d(TAG, \"updateTimer\");\n      }\n      mUpdateTimeHandler.removeMessages(MSG_UPDATE_TIME);\n      if (shouldTimerBeRunning()) {\n        mUpdateTimeHandler.sendEmptyMessage(MSG_UPDATE_TIME);\n      }\n    }\n\n    /**\n     * Returns whether the {@link #mUpdateTimeHandler} timer should be running. The timer should\n     * only run when we're visible and in interactive mode.\n     */\n    private boolean shouldTimerBeRunning() {\n      return isVisible() && !isInAmbientMode();\n    }\n\n  }\n}\n```\n\n#\u5b9f\u884c\n\n\u3053\u3053\u307e\u3067\u3067\u30a8\u30e9\u30fc\u304c\u3067\u3066\u3044\u306a\u3051\u308c\u3070\u3001\u3072\u3068\u307e\u305a\u30d7\u30ed\u30b0\u30e9\u30e0\u306f\u5b8c\u6210\u3067\u3059\u3002\n\u65e9\u901f\u3001\u30a8\u30df\u30e5\u30ec\u30fc\u30bf\u30fc\u53ca\u3073\u5b9f\u6a5f\u3067\u5b9f\u884c\u3057\u3066\u307f\u307e\u3057\u3087\u3046\u3002\n\n##\u30a8\u30df\u30e5\u30ec\u30fc\u30bf\u30fc\u3067\u306e\u5b9f\u884c\n\n###\u30a8\u30df\u30e5\u30ec\u30fc\u30bf\u30fc\u306e\u4f5c\u6210\u53ca\u3073\u8d77\u52d5\n\n![\u30b9\u30af\u30ea\u30fc\u30f3\u30b7\u30e7\u30c3\u30c8 2015-01-03 23.02.41.png](https://qiita-image-store.s3.amazonaws.com/0/63716/30db3515-3fdf-b59d-929b-f82c056cc464.png)\n\n* \u307e\u305a\u3001\u30a8\u30df\u30e5\u30ec\u30fc\u30bf\u30fc\u3092\u4f5c\u6210\u3057\u307e\u3059\u3002\n* Tools\u2192Android\u2192AVD Manager\u3092\u9078\u629e\u3057\u3001AVD Manager\u3092\u8d77\u52d5\u3057\u307e\u3059\u3002\n* Create Virtual Device...\u3092\u9078\u629e\u3057\u307e\u3059\u3002\n* \u5de6\u5074\u306e\"Category\"\u304b\u3089\u3001\"Wear\"\u3092\u9078\u629e\u3057\u307e\u3059\u3002\n* \u53f3\u5074\u306e\u3001Android Wear Square\u307e\u305f\u306fAndroid Wear Round\u3092\u9078\u629e\u3057\u307e\u3059\u3002\n* System Image\u306f\u3001\u3068\u308a\u3042\u3048\u305aLolipop, API Level21, x86\u306e\u3082\u306e\u3092\u9078\u629e\u3057\u3066\u304a\u3051\u3070\u3044\u3044\u3068\u601d\u3044\u307e\u3059\u3002\n* \"Use Host GPU\"\u306b\u306f\u3001\u4e00\u5fdc\u30c1\u30a7\u30c3\u30af\u3092\u3064\u3051\u3066\u304a\u304d\u3001Finish\u3067\u5b8c\u6210\u3067\u3059\u3002\n* \u5b8c\u6210\u3057\u305f\u3089\u3001Actions\u304b\u3089\u518d\u751f\u30dc\u30bf\u30f3\u3092\u62bc\u3057\u3066\u3001\u30a8\u30df\u30e5\u30ec\u30fc\u30bf\u30fc\u3092\u8d77\u52d5\u3057\u307e\u3057\u3087\u3046\u3002\n\n![\u30b9\u30af\u30ea\u30fc\u30f3\u30b7\u30e7\u30c3\u30c8 2015-01-03 23.10.23.png](https://qiita-image-store.s3.amazonaws.com/0/63716/c00c15a8-5ec5-6e34-e4d1-4c8625d38b16.png)\n\n###Wearable\u306e\u5b9f\u884c\n\n![\u30b9\u30af\u30ea\u30fc\u30f3\u30b7\u30e7\u30c3\u30c8 2015-01-03 23.13.38.png](https://qiita-image-store.s3.amazonaws.com/0/63716/70343657-6f9f-7494-87c5-21e89fd66919.png)\n\n* \u307e\u305a\u3001Run\u2192Edit Configurations...\u3092\u9078\u629e\u3057\u307e\u3059\u3002\n* \u5de6\u5074\u304b\u3089\u3001wear\u3092\u9078\u629e\u3057\u307e\u3059\u3002\uff08\u73fe\u5728\u306f\u3001\u8d64\u3067\u30d0\u30c4\u304c\u4ed8\u3044\u3066\u3044\u308b\u3068\u601d\u3044\u307e\u3059\uff09\n* \u53f3\u5074\u306e\u3001Activity\u306e\u90e8\u5206\u3067\u3001Do not launch Activity \u3092\u9078\u629e\u3057\u3001OK\u3068\u3057\u307e\u3059\u3002\n\n![\u30b9\u30af\u30ea\u30fc\u30f3\u30b7\u30e7\u30c3\u30c8 2015-01-03 23.15.42.png](https://qiita-image-store.s3.amazonaws.com/0/63716/8eb91bd4-a940-e0b3-812b-258bb0ed03fe.png)\n\n* \u4ee5\u4e0b\u304b\u3089\u3001wear\u3092\u9078\u629e\u3057\u307e\u3059\u3002\n\n![\u30b9\u30af\u30ea\u30fc\u30f3\u30b7\u30e7\u30c3\u30c8 2015-01-03 23.17.55.png](https://qiita-image-store.s3.amazonaws.com/0/63716/24b0139d-517b-458d-0965-9ce0ede5c6fa.png)\n\n* Run\u2192Run wear\u3092\u9078\u629e\u3057\u307e\u3059\u3002\n\n![\u30b9\u30af\u30ea\u30fc\u30f3\u30b7\u30e7\u30c3\u30c8 2015-01-03 23.19.42.png](https://qiita-image-store.s3.amazonaws.com/0/63716/dc592002-4988-e6cd-2f78-656f5ad44a57.png)\n\n* Choose a running Device\u3067\u3001\u5148\u307b\u3069\u4f5c\u6210\u3057\u305f\u30a8\u30df\u30e5\u30ec\u30fc\u30bf\u30fc\u3092\u9078\u629e\u3057\u307e\u3059\u3002\n* \u753b\u9762\u4e0b\u90e8\u306e\u30014:Run\u3092\u9078\u629e\u3059\u308b\u3068\u3001\u73fe\u5728\u306e\u72b6\u6cc1\u304c\u8868\u793a\u3055\u308c\u307e\u3059\u3002\u3053\u3061\u3089\u306e\u6700\u7d42\u884c\u306b\u3001Success\u3068\u8868\u793a\u3055\u308c\u308b\u307e\u3067\u5f85\u3061\u307e\u3059\u3002\n\n![\u30b9\u30af\u30ea\u30fc\u30f3\u30b7\u30e7\u30c3\u30c8 2015-01-03 23.26.22.png](https://qiita-image-store.s3.amazonaws.com/0/63716/05d4bc31-e8e7-a1bd-20a9-0b7163179239.png)\n\n* \u30a8\u30df\u30e5\u30ec\u30fc\u30bf\u30fc\u4e0a\u3067\u3001\u6642\u8a08\u304c\u8868\u793a\u3055\u308c\u3066\u3044\u308b\u753b\u9762\u3067\u3001\u30af\u30ea\u30c3\u30af\u9577\u62bc\u3057\u3092\u3059\u308b\u3068\u3001watch face\u9078\u629e\u753b\u9762\u306b\u79fb\u884c\u3057\u307e\u3059\u3002\u305d\u306e\u4e2d\u306b\u3001My Application\u3068\u3044\u3046\u540d\u524d\u3067\u3001\u5148\u307b\u3069\u4f5c\u6210\u3057\u305f\u30d7\u30ec\u30d3\u30e5\u30fc\u753b\u50cf\u304c\u3042\u308b\u3068\u601d\u3044\u307e\u3059\u3002\n* \u305d\u3061\u3089\u3092\u9078\u629e\u3059\u308b\u3068\u3001Watch face\u304c\u5909\u66f4\u3055\u308c\u307e\u3059\u3002\n\n![\u30b9\u30af\u30ea\u30fc\u30f3\u30b7\u30e7\u30c3\u30c8 2015-01-03 23.30.01.png](https://qiita-image-store.s3.amazonaws.com/0/63716/0a2bfdd8-6d70-b6a6-3eb6-ae4b6390cdc7.png)\n\n![\u30b9\u30af\u30ea\u30fc\u30f3\u30b7\u30e7\u30c3\u30c8 2015-01-03 23.31.46.png](https://qiita-image-store.s3.amazonaws.com/0/63716/a88b1478-3e7f-4ade-0d18-f38225d69505.png)\n\n##\u5b9f\u6a5f\u3067\u306e\u5b9f\u884c\n\n\u4ee5\u4e0b\u304c\u8a73\u3057\u3044\u3067\u3059\u3002\u63a5\u7d9a\u304c\u3067\u304d\u305f\u3089\u3001\u30a8\u30df\u30e5\u30ec\u30fc\u30bf\u30fc\u3068\u540c\u69d8\u306b\u5b9f\u884c\u3057\u307e\u3059\u3002\n\n>[Android Wear\u5b9f\u6a5f\u3078\u306eadb\u63a5\u7d9a](http://www.iplatform.org/blog/archives/2167)\n\n#\u30ab\u30b9\u30bf\u30de\u30a4\u30ba\u7b49\n[3/3](http://qiita.com/eoppp/items/dbf9f1c82d5987991e21)\u306b\u7d9a\u304d\u307e\u3059\u3002\n\n#\u53c2\u8003\u306b\u3057\u305f\u30b5\u30a4\u30c8\u7b49\n>[\u7f8e\u5973\u6642\u8a08\u3092\u4f5c\u308d\u3046\uff01Android Wear\u958b\u767a\u5165\u9580 30\u5206\u3067\u4f5c\u308b\u76e4\u9762\u30a2\u30d7\u30ea](http://blog.btrax.com/jp/2014/12/16/develop-watch-face/)\n>[Building a Watch Face Service](https://developer.android.com/training/wearables/watch-faces/service.html)(Android developers)\n", "tags": ["AndroidWear"]}