{"context": "\n\nRabbitMQ \u30c1\u30e5\u30fc\u30c8\u30ea\u30a2\u30eb\uff12 C\u30d0\u30fc\u30b8\u30e7\u30f3\nRabbitMQ \u30c1\u30e5\u30fc\u30c8\u30ea\u30a2\u30eb https://www.rabbitmq.com/getstarted.html \u306e\u30d1\u30fc\u30c8\uff12 Work queues\u306ePython\u7248\u306e\u30d7\u30ed\u30b0\u30e9\u30e0\u3092C\u30e9\u30a4\u30d6\u30e9\u30ea https://github.com/alanxz/rabbitmq-c \u3092\u4f7f\u3063\u3066\u66f8\u3044\u305f\u3082\u306e\u3067\u3059\u3002RabbitMQ\u306e\u8aac\u660e\u7b49\u306f\u3001\u5143\u306e\u30c1\u30e5\u30fc\u30c8\u30ea\u30a2\u30eb\u3092\u53c2\u7167\u3057\u3066\u304f\u3060\u3055\u3044\u3002\n\n\u9001\u4fe1\n\u30e1\u30c3\u30bb\u30fc\u30b8\u3092\u6c38\u7d9a\u5316\u3055\u305b\u308b\u305f\u3081\u3001\u30ad\u30e5\u30fc\u3068\u30e1\u30c3\u30bb\u30fc\u30b8\u306bdurable\u30aa\u30d7\u30b7\u30e7\u30f3\u3092\u4ed8\u3051\u308b\u3002amqp_queue_declare()\u3067\u3001\u30ad\u30e5\u30fc\u3092\u5b9a\u7fa9\u3059\u308b\u6642\u3001durable\u30d1\u30e9\u30e1\u30fc\u30bf\u3092true\u306b\u30bb\u30c3\u30c8\u3059\u308b\u3002amqp_basic_publish()\u3067\u3001\u30e1\u30c3\u30bb\u30fc\u30b8\u3092\u767a\u884c\u3059\u308b\u6642\u3001property\u30d1\u30e9\u30e1\u30fc\u30bf\u3067\u3001delivery_mode\u3092\u6307\u5b9a\u3059\u308b\u3002\n\namqp_framing.h\n#define AMQP_BASIC_CONTENT_TYPE_FLAG (1 << 15) /**< basic.content-type property flag */\n#define AMQP_BASIC_CONTENT_ENCODING_FLAG (1 << 14) /**< basic.content-encoding property flag */\n#define AMQP_BASIC_HEADERS_FLAG (1 << 13) /**< basic.headers property flag */\n#define AMQP_BASIC_DELIVERY_MODE_FLAG (1 << 12) /**< basic.delivery-mode property flag */\n#define AMQP_BASIC_PRIORITY_FLAG (1 << 11) /**< basic.priority property flag */\n#define AMQP_BASIC_CORRELATION_ID_FLAG (1 << 10) /**< basic.correlation-id property flag */\n#define AMQP_BASIC_REPLY_TO_FLAG (1 << 9) /**< basic.reply-to property flag */\n#define AMQP_BASIC_EXPIRATION_FLAG (1 << 8) /**< basic.expiration property flag */\n#define AMQP_BASIC_MESSAGE_ID_FLAG (1 << 7) /**< basic.message-id property flag */\n#define AMQP_BASIC_TIMESTAMP_FLAG (1 << 6) /**< basic.timestamp property flag */\n#define AMQP_BASIC_TYPE_FLAG (1 << 5) /**< basic.type property flag */\n#define AMQP_BASIC_USER_ID_FLAG (1 << 4) /**< basic.user-id property flag */\n#define AMQP_BASIC_APP_ID_FLAG (1 << 3) /**< basic.app-id property flag */\n#define AMQP_BASIC_CLUSTER_ID_FLAG (1 << 2) /**< basic.cluster-id property flag */\n\ntypedef struct amqp_basic_properties_t_ {\n  amqp_flags_t _flags; /**< bit-mask of set fields */\n  amqp_bytes_t content_type; /**< content-type */\n  amqp_bytes_t content_encoding; /**< content-encoding */\n  amqp_table_t headers; /**< headers */\n  uint8_t delivery_mode; /**< delivery-mode */\n  uint8_t priority; /**< priority */\n  amqp_bytes_t correlation_id; /**< correlation-id */\n  amqp_bytes_t reply_to; /**< reply-to */\n  amqp_bytes_t expiration; /**< expiration */\n  amqp_bytes_t message_id; /**< message-id */\n  uint64_t timestamp; /**< timestamp */\n  amqp_bytes_t type; /**< type */\n  amqp_bytes_t user_id; /**< user-id */\n  amqp_bytes_t app_id; /**< app-id */\n  amqp_bytes_t cluster_id; /**< cluster-id */\n} amqp_basic_properties_t;\n\n\ndelivery_mode\u306e\u5024\u306f\u3001\u5217\u6319\u578b\u3067\u5b9a\u7fa9\u3055\u308c\u3066\u3044\u308b\u3002delivery_mode\u3092\u6307\u5b9a\u3057\u305f\u6642\u306f\u3001_flags\u306b\n\namqp.h\ntypedef enum {\n        AMQP_DELIVERY_NONPERSISTENT = 1, /**< Non-persistent message */\n        AMQP_DELIVERY_PERSISTENT = 2 /**< Persistent message */\n} amqp_delivery_mode_enum;\n\n\n\u6700\u7d42\u7684\u306a\u30d7\u30ed\u30b0\u30e9\u30e0\u306f\u4ee5\u4e0b\u306e\u3068\u304a\u308a\u3002\n\ntask.cc\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdint.h>\n#include <string>\n#include <amqp.h>\n#include <amqp_tcp_socket.h>\n#include <amqp_framing.h>\n\nint  main (int argc, char** argv) {\n    std::string  message;\n    if (argc > 1) {\n        for (int i = 1; i < argc; i ++) {\n            if (i > 1)\n                message.append (1, ' ');\n            message.append (argv[i]);\n        }\n    } else {\n        message = \"Hello World!\";\n    }\n\n    amqp_connection_state_t  conn = amqp_new_connection ();\n\n    amqp_socket_t*  socket = amqp_tcp_socket_new (conn);\n\n    int  rc_sock = amqp_socket_open (socket, \"localhost\", 5672);\n    if (rc_sock != AMQP_STATUS_OK) {\n        fprintf (stderr, \"connection failure.\\n\");\n        exit (1);\n    }\n\n    amqp_rpc_reply_t  rc_login = amqp_login (conn, \"/\", AMQP_DEFAULT_MAX_CHANNELS, AMQP_DEFAULT_FRAME_SIZE, AMQP_DEFAULT_HEARTBEAT, AMQP_SASL_METHOD_PLAIN, \"guest\", \"guest\");\n    if (rc_login.reply_type != AMQP_RESPONSE_NORMAL) {\n        if (rc_login.reply_type == AMQP_RESPONSE_SERVER_EXCEPTION) {\n            if (rc_login.reply.id == AMQP_CONNECTION_CLOSE_METHOD) {\n                amqp_connection_close_t *m = (amqp_connection_close_t *) rc_login.reply.decoded;\n                fwrite (m->reply_text.bytes, 1, m->reply_text.len, stderr);\n                fprintf (stderr, \"\\n\");\n            }\n        }\n        exit (1);\n    }\n\n    amqp_channel_t  channel = 1;\n    amqp_channel_open_ok_t*  rc_channel = amqp_channel_open (conn, channel);\n\n    amqp_bytes_t  queue = amqp_cstring_bytes (\"hello_task\");\n    amqp_queue_declare_ok_t*  rc_decl = amqp_queue_declare (conn, channel, queue, false, true/*durable*/, false, false, amqp_empty_table);\n\n    amqp_bytes_t  bmsg = {message.length (), (void*)message.data ()};\n    amqp_basic_properties_t  prop;\n    memset (&prop, 0, sizeof (prop));\n    prop.delivery_mode = AMQP_DELIVERY_PERSISTENT;\n    prop._flags = AMQP_BASIC_DELIVERY_MODE_FLAG;\n    int  rc_pub = amqp_basic_publish (conn, channel, amqp_empty_bytes, queue, false, false, &prop, bmsg);\n\n    amqp_rpc_reply_t  rc_chclose = amqp_channel_close (conn, channel, AMQP_REPLY_SUCCESS);\n    amqp_rpc_reply_t  rc_conclose = amqp_connection_close (conn, AMQP_REPLY_SUCCESS);\n    amqp_destroy_connection (conn);\n\n    return 0;\n}\n\n\n\n\u53d7\u4fe1\n\u30ad\u30e5\u30fc\u304b\u3089\u30e1\u30c3\u30bb\u30fc\u30b8\u3092\u53d7\u4fe1\u3057\u305f\u6642\u3001\u78ba\u8a8d\u5fdc\u7b54\u3092\u8fd4\u3059\u307e\u3067\u30ad\u30e5\u30fc\u304b\u3089\u30e1\u30c3\u30bb\u30fc\u30b8\u3092\u53d6\u308a\u9664\u304b\u306a\u3044\u3088\u3046\u8a2d\u5b9a\u3059\u308b\u306b\u306f\u3001amqp_basic_consume()\u306eno_ack\u30d1\u30e9\u30e1\u30fc\u30bf\u3092false\u306b\u30bb\u30c3\u30c8\u3057\u3066\u547c\u3073\u51fa\u3059\u3002\n\u78ba\u8a8d\u5fdc\u7b54\u3092\u8fd4\u3059\u306b\u306f\u3001amqp_basic_ack()\u3092\u5b9f\u884c\u3059\u308b\u3002channel, delivery_tag\u30d1\u30e9\u30e1\u30fc\u30bf\u306f\u3001\u30e1\u30c3\u30bb\u30fc\u30b8\u30a8\u30f3\u30d9\u30ed\u30fc\u30d7\u304b\u3089\u53d6\u308a\u51fa\u3059\u3002\n\namqp.h\nint  amqp_basic_ack(amqp_connection_state_t state, amqp_channel_t channel,\n                    uint64_t delivery_tag, amqp_boolean_t multiple);\n\n\nqos\u30e1\u30bd\u30c3\u30c9\u306e\u8a2d\u5b9a\u3092\u884c\u3046\u306b\u306f\u3001amqp_basic_qos()\u3092\u5b9f\u884c\u3059\u308b\u3002\n\namqp_framing.h\namqp_basic_qos_ok_t*  amqp_basic_qos(amqp_connection_state_t state, amqp_channel_t channel,\n                                     uint32_t prefetch_size, uint16_t prefetch_count, amqp_boolean_t global);\n\n\n\u6700\u7d42\u7684\u306a\u30d7\u30ed\u30b0\u30e9\u30e0\u306f\u3001\u4ee5\u4e0b\u306e\u3068\u304a\u308a\u3002\n\nworker.cc\n#include <stdlib.h>\n#include <stdio.h>\n#include <unistd.h>\n#include <amqp.h>\n#include <amqp_tcp_socket.h>\n#include <amqp_framing.h>\n\nvoid  callback (amqp_connection_state_t* conn, amqp_envelope_t* envelope, amqp_bytes_t body) {\n    printf (\" [x] Received \");\n    fwrite (body.bytes, 1, body.len, stdout);\n    printf (\"\\n\");\n\n    int  count = 0;\n    for (int i = 0; i < body.len; i ++) {\n        if (((char*)body.bytes)[i] == '.')\n            count ++;\n    }\n    sleep (count);\n    printf (\" [x] Done\\n\");\n\n    int  rc_ack = amqp_basic_ack (*conn, envelope->channel, envelope->delivery_tag, false);\n}\n\nint  main (int argc, char** argv) {\n    amqp_connection_state_t  conn = amqp_new_connection ();\n\n    amqp_socket_t*  socket = amqp_tcp_socket_new (conn);\n\n    int  rc_sock = amqp_socket_open (socket, \"localhost\", 5672);\n    if (rc_sock != AMQP_STATUS_OK) {\n        fprintf (stderr, \"connection failure.\\n\");\n        exit (1);\n    }\n\n    amqp_rpc_reply_t  rc_login = amqp_login (conn, \"/\", AMQP_DEFAULT_MAX_CHANNELS, AMQP_DEFAULT_FRAME_SIZE, AMQP_DEFAULT_HEARTBEAT, AMQP_SASL_METHOD_PLAIN, \"guest\", \"guest\");\n    if (rc_login.reply_type != AMQP_RESPONSE_NORMAL) {\n        if (rc_login.reply_type == AMQP_RESPONSE_SERVER_EXCEPTION) {\n            if (rc_login.reply.id == AMQP_CONNECTION_CLOSE_METHOD) {\n                amqp_connection_close_t *m = (amqp_connection_close_t *) rc_login.reply.decoded;\n                fwrite (m->reply_text.bytes, 1, m->reply_text.len, stderr);\n                fprintf (stderr, \"\\n\");\n            }\n        }\n        exit (1);\n    }\n\n    amqp_channel_t  channel = 1;\n    amqp_channel_open_ok_t*  rc_channel = amqp_channel_open (conn, channel);\n\n    amqp_bytes_t  queue = amqp_cstring_bytes (\"hello_task\");\n    amqp_queue_declare_ok_t*  rc_dcl = amqp_queue_declare (conn, channel, queue, false, true/*durable*/, false, false, amqp_empty_table);\n\n    amqp_basic_qos_ok_t*  rc_qos = amqp_basic_qos (conn, channel, 0, 1/*prefetch count*/, false);\n\n    amqp_basic_consume_ok_t*  rc_cons = amqp_basic_consume (conn, channel, queue, amqp_empty_bytes, false, false, false, amqp_empty_table);\n\n    printf (\" [*] Waiting for messages. To exit press CTRL+C\\n\");\n\n    while (1) {\n        amqp_maybe_release_buffers (conn);\n        amqp_envelope_t  envelope;\n        amqp_rpc_reply_t  rc_msg = amqp_consume_message (conn, &envelope, NULL, 0);\n        switch (rc_msg.reply_type) {\n        case AMQP_RESPONSE_NORMAL:\n            callback (&conn, &envelope, envelope.message.body);\n            break;\n        case AMQP_RESPONSE_LIBRARY_EXCEPTION:\n            if (rc_msg.library_error == AMQP_STATUS_UNEXPECTED_STATE) {\n                amqp_frame_t  frame;\n                if (amqp_simple_wait_frame (conn, &frame) != AMQP_STATUS_OK) {\n                    goto Ex1;\n                }\n                if (frame.frame_type == AMQP_FRAME_METHOD) {\n                    switch (frame.payload.method.id) {\n                    case AMQP_BASIC_ACK_METHOD:\n                        break;\n                    case AMQP_BASIC_RETURN_METHOD: {\n                        amqp_message_t  message;\n                        amqp_rpc_reply_t  rc_read = amqp_read_message (conn, frame.channel, &message, 0);\n                        if (rc_read.reply_type != AMQP_RESPONSE_NORMAL) {\n                            goto Ex1;\n                        }\n                        amqp_destroy_message (&message);\n                        break;\n                    }\n                    case AMQP_CHANNEL_CLOSE_METHOD:\n                        goto Ex1;\n                    case AMQP_CONNECTION_CLOSE_METHOD:\n                        goto Ex1;\n                    default:\n                        fprintf (stderr ,\"An unexpected method was received %d\\n\", frame.payload.method.id);\n                        goto Ex1;\n                    }\n                }\n            }\n            break;\n        default:;\n        }\n        amqp_destroy_envelope (&envelope);\n    }\n\n Ex1:;\n    amqp_rpc_reply_t  rc_chclose = amqp_channel_close (conn, channel, AMQP_REPLY_SUCCESS);\n    amqp_rpc_reply_t  rc_conclose = amqp_connection_close (conn, AMQP_REPLY_SUCCESS);\n    amqp_destroy_connection (conn);\n\n    return 0;\n}\n\n\n#RabbitMQ \u30c1\u30e5\u30fc\u30c8\u30ea\u30a2\u30eb\uff12 C\u30d0\u30fc\u30b8\u30e7\u30f3\n\nRabbitMQ \u30c1\u30e5\u30fc\u30c8\u30ea\u30a2\u30eb https://www.rabbitmq.com/getstarted.html \u306e\u30d1\u30fc\u30c8\uff12 Work queues\u306ePython\u7248\u306e\u30d7\u30ed\u30b0\u30e9\u30e0\u3092C\u30e9\u30a4\u30d6\u30e9\u30ea https://github.com/alanxz/rabbitmq-c \u3092\u4f7f\u3063\u3066\u66f8\u3044\u305f\u3082\u306e\u3067\u3059\u3002RabbitMQ\u306e\u8aac\u660e\u7b49\u306f\u3001\u5143\u306e\u30c1\u30e5\u30fc\u30c8\u30ea\u30a2\u30eb\u3092\u53c2\u7167\u3057\u3066\u304f\u3060\u3055\u3044\u3002\n\n##\u9001\u4fe1\n\n\u30e1\u30c3\u30bb\u30fc\u30b8\u3092\u6c38\u7d9a\u5316\u3055\u305b\u308b\u305f\u3081\u3001\u30ad\u30e5\u30fc\u3068\u30e1\u30c3\u30bb\u30fc\u30b8\u306bdurable\u30aa\u30d7\u30b7\u30e7\u30f3\u3092\u4ed8\u3051\u308b\u3002amqp_queue_declare()\u3067\u3001\u30ad\u30e5\u30fc\u3092\u5b9a\u7fa9\u3059\u308b\u6642\u3001durable\u30d1\u30e9\u30e1\u30fc\u30bf\u3092true\u306b\u30bb\u30c3\u30c8\u3059\u308b\u3002amqp_basic_publish()\u3067\u3001\u30e1\u30c3\u30bb\u30fc\u30b8\u3092\u767a\u884c\u3059\u308b\u6642\u3001property\u30d1\u30e9\u30e1\u30fc\u30bf\u3067\u3001delivery_mode\u3092\u6307\u5b9a\u3059\u308b\u3002\n\n```cpp:amqp_framing.h\n#define AMQP_BASIC_CONTENT_TYPE_FLAG (1 << 15) /**< basic.content-type property flag */\n#define AMQP_BASIC_CONTENT_ENCODING_FLAG (1 << 14) /**< basic.content-encoding property flag */\n#define AMQP_BASIC_HEADERS_FLAG (1 << 13) /**< basic.headers property flag */\n#define AMQP_BASIC_DELIVERY_MODE_FLAG (1 << 12) /**< basic.delivery-mode property flag */\n#define AMQP_BASIC_PRIORITY_FLAG (1 << 11) /**< basic.priority property flag */\n#define AMQP_BASIC_CORRELATION_ID_FLAG (1 << 10) /**< basic.correlation-id property flag */\n#define AMQP_BASIC_REPLY_TO_FLAG (1 << 9) /**< basic.reply-to property flag */\n#define AMQP_BASIC_EXPIRATION_FLAG (1 << 8) /**< basic.expiration property flag */\n#define AMQP_BASIC_MESSAGE_ID_FLAG (1 << 7) /**< basic.message-id property flag */\n#define AMQP_BASIC_TIMESTAMP_FLAG (1 << 6) /**< basic.timestamp property flag */\n#define AMQP_BASIC_TYPE_FLAG (1 << 5) /**< basic.type property flag */\n#define AMQP_BASIC_USER_ID_FLAG (1 << 4) /**< basic.user-id property flag */\n#define AMQP_BASIC_APP_ID_FLAG (1 << 3) /**< basic.app-id property flag */\n#define AMQP_BASIC_CLUSTER_ID_FLAG (1 << 2) /**< basic.cluster-id property flag */\n\ntypedef struct amqp_basic_properties_t_ {\n  amqp_flags_t _flags; /**< bit-mask of set fields */\n  amqp_bytes_t content_type; /**< content-type */\n  amqp_bytes_t content_encoding; /**< content-encoding */\n  amqp_table_t headers; /**< headers */\n  uint8_t delivery_mode; /**< delivery-mode */\n  uint8_t priority; /**< priority */\n  amqp_bytes_t correlation_id; /**< correlation-id */\n  amqp_bytes_t reply_to; /**< reply-to */\n  amqp_bytes_t expiration; /**< expiration */\n  amqp_bytes_t message_id; /**< message-id */\n  uint64_t timestamp; /**< timestamp */\n  amqp_bytes_t type; /**< type */\n  amqp_bytes_t user_id; /**< user-id */\n  amqp_bytes_t app_id; /**< app-id */\n  amqp_bytes_t cluster_id; /**< cluster-id */\n} amqp_basic_properties_t;\n```\n\ndelivery_mode\u306e\u5024\u306f\u3001\u5217\u6319\u578b\u3067\u5b9a\u7fa9\u3055\u308c\u3066\u3044\u308b\u3002delivery_mode\u3092\u6307\u5b9a\u3057\u305f\u6642\u306f\u3001_flags\u306b\n\n```cpp:amqp.h\ntypedef enum {\n        AMQP_DELIVERY_NONPERSISTENT = 1, /**< Non-persistent message */\n        AMQP_DELIVERY_PERSISTENT = 2 /**< Persistent message */\n} amqp_delivery_mode_enum;\n```\n\n\u6700\u7d42\u7684\u306a\u30d7\u30ed\u30b0\u30e9\u30e0\u306f\u4ee5\u4e0b\u306e\u3068\u304a\u308a\u3002\n\n```cpp:task.cc\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdint.h>\n#include <string>\n#include <amqp.h>\n#include <amqp_tcp_socket.h>\n#include <amqp_framing.h>\n\nint  main (int argc, char** argv) {\n    std::string  message;\n    if (argc > 1) {\n        for (int i = 1; i < argc; i ++) {\n            if (i > 1)\n                message.append (1, ' ');\n            message.append (argv[i]);\n        }\n    } else {\n        message = \"Hello World!\";\n    }\n\n    amqp_connection_state_t  conn = amqp_new_connection ();\n\n    amqp_socket_t*  socket = amqp_tcp_socket_new (conn);\n\n    int  rc_sock = amqp_socket_open (socket, \"localhost\", 5672);\n    if (rc_sock != AMQP_STATUS_OK) {\n        fprintf (stderr, \"connection failure.\\n\");\n        exit (1);\n    }\n\n    amqp_rpc_reply_t  rc_login = amqp_login (conn, \"/\", AMQP_DEFAULT_MAX_CHANNELS, AMQP_DEFAULT_FRAME_SIZE, AMQP_DEFAULT_HEARTBEAT, AMQP_SASL_METHOD_PLAIN, \"guest\", \"guest\");\n    if (rc_login.reply_type != AMQP_RESPONSE_NORMAL) {\n        if (rc_login.reply_type == AMQP_RESPONSE_SERVER_EXCEPTION) {\n            if (rc_login.reply.id == AMQP_CONNECTION_CLOSE_METHOD) {\n                amqp_connection_close_t *m = (amqp_connection_close_t *) rc_login.reply.decoded;\n                fwrite (m->reply_text.bytes, 1, m->reply_text.len, stderr);\n                fprintf (stderr, \"\\n\");\n            }\n        }\n        exit (1);\n    }\n\n    amqp_channel_t  channel = 1;\n    amqp_channel_open_ok_t*  rc_channel = amqp_channel_open (conn, channel);\n\n    amqp_bytes_t  queue = amqp_cstring_bytes (\"hello_task\");\n    amqp_queue_declare_ok_t*  rc_decl = amqp_queue_declare (conn, channel, queue, false, true/*durable*/, false, false, amqp_empty_table);\n\n    amqp_bytes_t  bmsg = {message.length (), (void*)message.data ()};\n    amqp_basic_properties_t  prop;\n    memset (&prop, 0, sizeof (prop));\n    prop.delivery_mode = AMQP_DELIVERY_PERSISTENT;\n    prop._flags = AMQP_BASIC_DELIVERY_MODE_FLAG;\n    int  rc_pub = amqp_basic_publish (conn, channel, amqp_empty_bytes, queue, false, false, &prop, bmsg);\n\n    amqp_rpc_reply_t  rc_chclose = amqp_channel_close (conn, channel, AMQP_REPLY_SUCCESS);\n    amqp_rpc_reply_t  rc_conclose = amqp_connection_close (conn, AMQP_REPLY_SUCCESS);\n    amqp_destroy_connection (conn);\n\n    return 0;\n}\n```\n\n##\u53d7\u4fe1\n\n\u30ad\u30e5\u30fc\u304b\u3089\u30e1\u30c3\u30bb\u30fc\u30b8\u3092\u53d7\u4fe1\u3057\u305f\u6642\u3001\u78ba\u8a8d\u5fdc\u7b54\u3092\u8fd4\u3059\u307e\u3067\u30ad\u30e5\u30fc\u304b\u3089\u30e1\u30c3\u30bb\u30fc\u30b8\u3092\u53d6\u308a\u9664\u304b\u306a\u3044\u3088\u3046\u8a2d\u5b9a\u3059\u308b\u306b\u306f\u3001amqp_basic_consume()\u306eno_ack\u30d1\u30e9\u30e1\u30fc\u30bf\u3092false\u306b\u30bb\u30c3\u30c8\u3057\u3066\u547c\u3073\u51fa\u3059\u3002\n\n\u78ba\u8a8d\u5fdc\u7b54\u3092\u8fd4\u3059\u306b\u306f\u3001amqp_basic_ack()\u3092\u5b9f\u884c\u3059\u308b\u3002channel, delivery_tag\u30d1\u30e9\u30e1\u30fc\u30bf\u306f\u3001\u30e1\u30c3\u30bb\u30fc\u30b8\u30a8\u30f3\u30d9\u30ed\u30fc\u30d7\u304b\u3089\u53d6\u308a\u51fa\u3059\u3002\n\n```cpp:amqp.h\nint  amqp_basic_ack(amqp_connection_state_t state, amqp_channel_t channel,\n                    uint64_t delivery_tag, amqp_boolean_t multiple);\n```\n\nqos\u30e1\u30bd\u30c3\u30c9\u306e\u8a2d\u5b9a\u3092\u884c\u3046\u306b\u306f\u3001amqp_basic_qos()\u3092\u5b9f\u884c\u3059\u308b\u3002\n\n```cpp:amqp_framing.h\namqp_basic_qos_ok_t*  amqp_basic_qos(amqp_connection_state_t state, amqp_channel_t channel,\n                                     uint32_t prefetch_size, uint16_t prefetch_count, amqp_boolean_t global);\n```\n\n\u6700\u7d42\u7684\u306a\u30d7\u30ed\u30b0\u30e9\u30e0\u306f\u3001\u4ee5\u4e0b\u306e\u3068\u304a\u308a\u3002\n\n```cpp:worker.cc\n#include <stdlib.h>\n#include <stdio.h>\n#include <unistd.h>\n#include <amqp.h>\n#include <amqp_tcp_socket.h>\n#include <amqp_framing.h>\n\nvoid  callback (amqp_connection_state_t* conn, amqp_envelope_t* envelope, amqp_bytes_t body) {\n    printf (\" [x] Received \");\n    fwrite (body.bytes, 1, body.len, stdout);\n    printf (\"\\n\");\n\n    int  count = 0;\n    for (int i = 0; i < body.len; i ++) {\n        if (((char*)body.bytes)[i] == '.')\n            count ++;\n    }\n    sleep (count);\n    printf (\" [x] Done\\n\");\n\n    int  rc_ack = amqp_basic_ack (*conn, envelope->channel, envelope->delivery_tag, false);\n}\n\nint  main (int argc, char** argv) {\n    amqp_connection_state_t  conn = amqp_new_connection ();\n\n    amqp_socket_t*  socket = amqp_tcp_socket_new (conn);\n\n    int  rc_sock = amqp_socket_open (socket, \"localhost\", 5672);\n    if (rc_sock != AMQP_STATUS_OK) {\n        fprintf (stderr, \"connection failure.\\n\");\n        exit (1);\n    }\n\n    amqp_rpc_reply_t  rc_login = amqp_login (conn, \"/\", AMQP_DEFAULT_MAX_CHANNELS, AMQP_DEFAULT_FRAME_SIZE, AMQP_DEFAULT_HEARTBEAT, AMQP_SASL_METHOD_PLAIN, \"guest\", \"guest\");\n    if (rc_login.reply_type != AMQP_RESPONSE_NORMAL) {\n        if (rc_login.reply_type == AMQP_RESPONSE_SERVER_EXCEPTION) {\n            if (rc_login.reply.id == AMQP_CONNECTION_CLOSE_METHOD) {\n                amqp_connection_close_t *m = (amqp_connection_close_t *) rc_login.reply.decoded;\n                fwrite (m->reply_text.bytes, 1, m->reply_text.len, stderr);\n                fprintf (stderr, \"\\n\");\n            }\n        }\n        exit (1);\n    }\n\n    amqp_channel_t  channel = 1;\n    amqp_channel_open_ok_t*  rc_channel = amqp_channel_open (conn, channel);\n\n    amqp_bytes_t  queue = amqp_cstring_bytes (\"hello_task\");\n    amqp_queue_declare_ok_t*  rc_dcl = amqp_queue_declare (conn, channel, queue, false, true/*durable*/, false, false, amqp_empty_table);\n\n    amqp_basic_qos_ok_t*  rc_qos = amqp_basic_qos (conn, channel, 0, 1/*prefetch count*/, false);\n\n    amqp_basic_consume_ok_t*  rc_cons = amqp_basic_consume (conn, channel, queue, amqp_empty_bytes, false, false, false, amqp_empty_table);\n\n    printf (\" [*] Waiting for messages. To exit press CTRL+C\\n\");\n\n    while (1) {\n        amqp_maybe_release_buffers (conn);\n        amqp_envelope_t  envelope;\n        amqp_rpc_reply_t  rc_msg = amqp_consume_message (conn, &envelope, NULL, 0);\n        switch (rc_msg.reply_type) {\n        case AMQP_RESPONSE_NORMAL:\n            callback (&conn, &envelope, envelope.message.body);\n            break;\n        case AMQP_RESPONSE_LIBRARY_EXCEPTION:\n            if (rc_msg.library_error == AMQP_STATUS_UNEXPECTED_STATE) {\n                amqp_frame_t  frame;\n                if (amqp_simple_wait_frame (conn, &frame) != AMQP_STATUS_OK) {\n                    goto Ex1;\n                }\n                if (frame.frame_type == AMQP_FRAME_METHOD) {\n                    switch (frame.payload.method.id) {\n                    case AMQP_BASIC_ACK_METHOD:\n                        break;\n                    case AMQP_BASIC_RETURN_METHOD: {\n                        amqp_message_t  message;\n                        amqp_rpc_reply_t  rc_read = amqp_read_message (conn, frame.channel, &message, 0);\n                        if (rc_read.reply_type != AMQP_RESPONSE_NORMAL) {\n                            goto Ex1;\n                        }\n                        amqp_destroy_message (&message);\n                        break;\n                    }\n                    case AMQP_CHANNEL_CLOSE_METHOD:\n                        goto Ex1;\n                    case AMQP_CONNECTION_CLOSE_METHOD:\n                        goto Ex1;\n                    default:\n                        fprintf (stderr ,\"An unexpected method was received %d\\n\", frame.payload.method.id);\n                        goto Ex1;\n                    }\n                }\n            }\n            break;\n        default:;\n        }\n        amqp_destroy_envelope (&envelope);\n    }\n\n Ex1:;\n    amqp_rpc_reply_t  rc_chclose = amqp_channel_close (conn, channel, AMQP_REPLY_SUCCESS);\n    amqp_rpc_reply_t  rc_conclose = amqp_connection_close (conn, AMQP_REPLY_SUCCESS);\n    amqp_destroy_connection (conn);\n\n    return 0;\n}\n```\n", "tags": ["RabbitMQ", "C"]}