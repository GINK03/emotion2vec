{"context": " More than 1 year has passed since last update.\u9577\u3059\u304e\u308b\u304d\u304c\u3059\u308b\u30fb\u30fb\u304a\u304a\u3088\u305d\uff11\uff10\u5206\n\u52d5\u4f5c\u30b5\u30f3\u30d7\u30eb\n\uff11\u884c\u76ee\uff1ax y\n\uff12\u884c\u76ee\u4ee5\u4e0b\uff1a 0 or 1 or s or g \u306e\u30b9\u30da\u30fc\u30b9\u533a\u5207\u308a \n\u5165\u529b\u30b5\u30f3\u30d7\u30eb\n1:4 5\n2:0 s 0 1\n3:0 0 1 0\n4:0 1 1 0\n5:0 0 1 g\n6:0 0 0 0\n\n\n\u30b3\u30fc\u30c9\nimport java.util.*;\nimport java.io.*;\n\npublic class Main {\n    protected static String[][] matrix;\n    protected static int min = 9999;\n    public static void main (String[] args) throws Exception {\n        // Java sun-jdk-1.7.\n        try (\n            InputStreamReader ir = new InputStreamReader(System.in);\n            BufferedReader in = new BufferedReader(ir)) {\n                String line = in.readLine();\n                String[] xy = line.split(\" \",-1);\n                int x = Integer.parseInt(xy[0]);\n                int y = Integer.parseInt(xy[1]);\n                matrix = new String[y][x];\n                int[] s = new int[]{0,0};\n                int[] g = new int[]{0,0};\n                int crow = 0;\n                while ((line = in.readLine()) != null) {\n                    String[] row = line.replace(\"1\", \"x\").split(\" \");\n                    matrix[crow] = row;\n                    int ccol = 0;\n                    for (String cell : row) {\n                        if (\"s\".equals(cell)) { s = new int[]{ crow, ccol }; }\n                        if (\"g\".equals(cell)) { g = new int[]{ crow, ccol }; }\n                        ccol++;\n                    }\n                    crow++;\n                }\n                add(s[1], s[0], 0);\n            }\n            System.out.println(min == 9999 ? \"Fail\" : min);\n    }\n\n    static final void add(int x, int y, int count) {\n        try {\n            if (\"0\".equals(matrix[y][x]) || \"s\".equals(matrix[y][x])) {\n                if (\"0\".equals(matrix[y][x])) {\n                    matrix[y][x] = String.valueOf(count);\n                }\n                if (\"s\".equals(matrix[y][x])) {\n                    if (count != 0) {\n                        return;\n                    }\n                }\n                add(x+1,y+0,count+1);\n                add(x+0,y+1,count+1);\n                add(x-1,y-0,count+1);\n                add(x-0,y-1,count+1);\n            } else if (\"g\".equals(matrix[y][x])) {\n                min = Math.min(count, min);\n            } else {\n                int old = Integer.parseInt(matrix[y][x]);\n                if (old > count) {\n                    matrix[y][x] = \"0\";\n                    add(x,y,count);\n                }\n                return;\n            }\n        } catch (Exception e) {\n            return;\n        }\n    }\n}\n\n\n\u5b9f\u884c\u30af\u30e9\u30b9\u3068\u8a08\u7b97\u30af\u30e9\u30b9\u3092\u5206\u96e2\npackage jp.mirageworld.algorithm.route;\n\nimport java.util.Objects;\n\npublic class RouteCalc {\n\n    public int calc(String[][] matrix) {\n        int sy = 0;\n        for (String[] row : matrix) {\n            int sx = 0;\n            for (String col : row) {\n                if (Objects.equals(col, \"s\")) {\n                    return calc(matrix, sy, sx, 0);\n                }\n                sx++;\n            }\n            sy++;\n        }\n\n        return -1;\n    }\n\n    public int calc(String[][] matrix, int sy, int sx, Integer count) {\n        int min = 9999;\n        try {\n            if (Objects.equals(\"s\", matrix[sy][sx]) && count > 0) {\n                return min;\n            }\n            switch (matrix[sy][sx]) {\n                case \"0\":\n                    matrix[sy][sx] = count.toString();\n                case \"s\":\n                    break;\n                case \"g\":\n                    return count;\n                default:\n                    int x = Integer.parseInt(matrix[sy][sx]);\n                    if (x > count) {\n                        matrix[sy][sx] = \"0\";\n                        return calc(matrix, sy, sx, count);\n                    }\n                    return min;\n            }\n            min = Math.min(min, calc(matrix, sy - 1, sx + 0, count + 1));\n            min = Math.min(min, calc(matrix, sy + 0, sx - 1, count + 1));\n            min = Math.min(min, calc(matrix, sy + 0, sx + 1, count + 1));\n            min = Math.min(min, calc(matrix, sy + 1, sx + 0, count + 1));\n\n        } catch (IndexOutOfBoundsException e) {\n        }\n        return min;\n    }\n}\n\n\n\u52d5\u4f5c\u78ba\u8a8d\npackage jp.mirageworld.algorithm.route;\n\nimport static org.hamcrest.CoreMatchers.*;\nimport static org.junit.Assert.*;\n\nimport org.junit.Test;\n\npublic class RouteCalcTest {\n\n    @Test\n    public void testCalc() {\n        String[][] m = {\n                { \"0\", \"s\", \"0\", \"1\" },\n                { \"0\", \"0\", \"1\", \"0\" },\n                { \"0\", \"1\", \"1\", \"0\" },\n                { \"0\", \"0\", \"1\", \"g\" },\n                { \"0\", \"0\", \"0\", \"0\" },\n        };\n\n        RouteCalc rc = new RouteCalc();\n        assertThat(rc.calc(m), is(9));\n    }\n\n}\n\n\n\u9577\u3059\u304e\u308b\u304d\u304c\u3059\u308b\u30fb\u30fb\u304a\u304a\u3088\u305d\uff11\uff10\u5206\n\n[\u52d5\u4f5c\u30b5\u30f3\u30d7\u30eb][1]\n\n\uff11\u884c\u76ee\uff1ax y\n\uff12\u884c\u76ee\u4ee5\u4e0b\uff1a 0 or 1 or s or g \u306e\u30b9\u30da\u30fc\u30b9\u533a\u5207\u308a \n\n\n\u5165\u529b\u30b5\u30f3\u30d7\u30eb\n\n```\n1:4 5\n2:0 s 0 1\n3:0 0 1 0\n4:0 1 1 0\n5:0 0 1 g\n6:0 0 0 0\n```\n\n[1]: https://ideone.com/FcuFau\n\n## \u30b3\u30fc\u30c9\n\n```java\nimport java.util.*;\nimport java.io.*;\n\npublic class Main {\n\tprotected static String[][] matrix;\n\tprotected static int min = 9999;\n    public static void main (String[] args) throws Exception {\n        // Java sun-jdk-1.7.\n        try (\n            InputStreamReader ir = new InputStreamReader(System.in);\n            BufferedReader in = new BufferedReader(ir)) {\n                String line = in.readLine();\n                String[] xy = line.split(\" \",-1);\n                int x = Integer.parseInt(xy[0]);\n                int y = Integer.parseInt(xy[1]);\n                matrix = new String[y][x];\n                int[] s = new int[]{0,0};\n                int[] g = new int[]{0,0};\n                int crow = 0;\n                while ((line = in.readLine()) != null) {\n                    String[] row = line.replace(\"1\", \"x\").split(\" \");\n                    matrix[crow] = row;\n                    int ccol = 0;\n                    for (String cell : row) {\n                        if (\"s\".equals(cell)) { s = new int[]{ crow, ccol }; }\n                        if (\"g\".equals(cell)) { g = new int[]{ crow, ccol }; }\n                        ccol++;\n                    }\n                    crow++;\n                }\n                add(s[1], s[0], 0);\n            }\n            System.out.println(min == 9999 ? \"Fail\" : min);\n    }\n    \n    static final void add(int x, int y, int count) {\n    \ttry {\n    \t\tif (\"0\".equals(matrix[y][x]) || \"s\".equals(matrix[y][x])) {\n    \t\t\tif (\"0\".equals(matrix[y][x])) {\n\t    \t\t \tmatrix[y][x] = String.valueOf(count);\n    \t\t\t}\n    \t\t\tif (\"s\".equals(matrix[y][x])) {\n    \t\t\t\tif (count != 0) {\n    \t\t\t\t\treturn;\n    \t\t\t\t}\n    \t\t\t}\n\t    \t\tadd(x+1,y+0,count+1);\n\t    \t\tadd(x+0,y+1,count+1);\n\t    \t\tadd(x-1,y-0,count+1);\n\t    \t\tadd(x-0,y-1,count+1);\n    \t\t} else if (\"g\".equals(matrix[y][x])) {\n    \t\t\tmin = Math.min(count, min);\n    \t\t} else {\n    \t\t\tint old = Integer.parseInt(matrix[y][x]);\n    \t\t\tif (old > count) {\n    \t\t\t\tmatrix[y][x] = \"0\";\n    \t\t\t\tadd(x,y,count);\n    \t\t\t}\n    \t\t\treturn;\n    \t\t}\n    \t} catch (Exception e) {\n    \t\treturn;\n    \t}\n    }\n}\n```\n\n### \u5b9f\u884c\u30af\u30e9\u30b9\u3068\u8a08\u7b97\u30af\u30e9\u30b9\u3092\u5206\u96e2\n\n```java\npackage jp.mirageworld.algorithm.route;\n\nimport java.util.Objects;\n\npublic class RouteCalc {\n\n\tpublic int calc(String[][] matrix) {\n\t\tint sy = 0;\n\t\tfor (String[] row : matrix) {\n\t\t\tint sx = 0;\n\t\t\tfor (String col : row) {\n\t\t\t\tif (Objects.equals(col, \"s\")) {\n\t\t\t\t\treturn calc(matrix, sy, sx, 0);\n\t\t\t\t}\n\t\t\t\tsx++;\n\t\t\t}\n\t\t\tsy++;\n\t\t}\n\n\t\treturn -1;\n\t}\n\n\tpublic int calc(String[][] matrix, int sy, int sx, Integer count) {\n\t\tint min = 9999;\n\t\ttry {\n\t\t\tif (Objects.equals(\"s\", matrix[sy][sx]) && count > 0) {\n\t\t\t\treturn min;\n\t\t\t}\n\t\t\tswitch (matrix[sy][sx]) {\n\t\t\t\tcase \"0\":\n\t\t\t\t\tmatrix[sy][sx] = count.toString();\n\t\t\t\tcase \"s\":\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"g\":\n\t\t\t\t\treturn count;\n\t\t\t\tdefault:\n\t\t\t\t\tint x = Integer.parseInt(matrix[sy][sx]);\n\t\t\t\t\tif (x > count) {\n\t\t\t\t\t\tmatrix[sy][sx] = \"0\";\n\t\t\t\t\t\treturn calc(matrix, sy, sx, count);\n\t\t\t\t\t}\n\t\t\t\t\treturn min;\n\t\t\t}\n\t\t\tmin = Math.min(min, calc(matrix, sy - 1, sx + 0, count + 1));\n\t\t\tmin = Math.min(min, calc(matrix, sy + 0, sx - 1, count + 1));\n\t\t\tmin = Math.min(min, calc(matrix, sy + 0, sx + 1, count + 1));\n\t\t\tmin = Math.min(min, calc(matrix, sy + 1, sx + 0, count + 1));\n\n\t\t} catch (IndexOutOfBoundsException e) {\n\t\t}\n\t\treturn min;\n\t}\n}\n```\n\n#### \u52d5\u4f5c\u78ba\u8a8d\n\n```java\npackage jp.mirageworld.algorithm.route;\n\nimport static org.hamcrest.CoreMatchers.*;\nimport static org.junit.Assert.*;\n\nimport org.junit.Test;\n\npublic class RouteCalcTest {\n\n\t@Test\n\tpublic void testCalc() {\n\t\tString[][] m = {\n\t\t\t\t{ \"0\", \"s\", \"0\", \"1\" },\n\t\t\t\t{ \"0\", \"0\", \"1\", \"0\" },\n\t\t\t\t{ \"0\", \"1\", \"1\", \"0\" },\n\t\t\t\t{ \"0\", \"0\", \"1\", \"g\" },\n\t\t\t\t{ \"0\", \"0\", \"0\", \"0\" },\n\t\t};\n\n\t\tRouteCalc rc = new RouteCalc();\n\t\tassertThat(rc.calc(m), is(9));\n\t}\n\n}\n\n", "tags": ["Java", "\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0"]}