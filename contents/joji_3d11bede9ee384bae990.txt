{"context": "It is answer1\n\nruby\narr1 = [2, 4, 5, 6, 7]\narr2 = [7, 8, 9, 7, 4, 3, 2]\n\ndef extract_value(arr1, arr2)\n  arr3 = arr1.uniq + arr2.uniq\n  arr4 = arr3.inject(Hash.new(0)){| init, v | init[v]+=1; init;}\n  answer = arr4.map{|k, v|  k if v >= 2}.compact\nend\n\nextract_value(arr1, arr2)\n\n\nIt is answer2\n\nruby\narr1 = [2, 4, 5, 6, 7]\narr2 = [7, 8, 9, 7, 4, 3, 2]\n\nrequire 'set'\ndef extract_value(arr1, arr2)\n  set_val, set_val2 = Set.new, Set.new\n  arr1.map{|v| set_val << v}\n  arr2.each {|v| set_val2 << v if set_val.include?(v) }\n  set_val2.to_a\nend\n\nextract_value(arr1, arr2)\n\n\nIt is answer3\n\nruby\narr1 & arr2\n\n\n\nWhich is a better algorithm?\nLet me check\n\nruby\narr1, arr2 = [], []\n1.upto(100000000).each {|v| arr1 << rand(1..500)}\n1.upto(100000000).each {|v| arr2 << rand(1..1000)}\n\n\nembed time\n\nruby\ndef extract_value1(arr1, arr2)\n  puts Time.now\n  arr3 = arr1.uniq + arr2.uniq\n  arr4 = arr3.inject(Hash.new(0)){| init, v | init[v]+=1; init;}\n  answer = arr4.map{|k, v|  k if v >= 2}.compact\n  puts Time.now\n  answer\nend\n\n\nIt takes 8 seconds\n\ntext\n2017-02-18 15:55:40 +0900\n2017-02-18 15:55:48 +0900\n\n\nembed time\n\nruby\nrequire 'set'\ndef extract_value2(arr1, arr2)\n  puts Time.now\n  set_val, set_val2 = Set.new, Set.new\n  arr1.map{|v| set_val << v}\n  arr2.each {|v| set_val2 << v if set_val.include?(v) }\n  puts Time.now\n  set_val2.to_a\nend\n\n\nIt takes 44 seconds\n\ntext\n2017-02-18 15:54:49 +0900\n2017-02-18 15:55:33 +0900\n\n\nIt looks that first algorithm is better.\nI think it is because of uniq function.\n\nI will change value of arr and function also\n\nruby\narr1, arr2 = [], []\n1.upto(100000000).each {|v| arr1 << rand(1..5000000)}\n1.upto(100000000).each {|v| arr2 << rand(1..10000000)}\n\n\nI will use uniq function in second one and name extract_value3\n\nruby\nrequire 'set'\ndef extract_value3(arr1, arr2)\n  puts Time.now\n  set_val, set_val2 = Set.new, Set.new\n  arr1 = arr1.uniq\n  arr2 = arr2.uniq\n  arr1.map{|v| set_val << v}\n  arr2.each {|v| set_val2 << v if set_val.include?(v) }\n  puts Time.now\n  set_val2.to_a\nend\n\n\nThis is the result of extract_value1\n2017-02-18 16:26:37 +0900\n2017-02-18 16:29:22 +0900\n\nThis is the result of extract_value2\n2017-02-18 16:45:04 +0900\n2017-02-18 16:48:12 +0900\n\nThis is the result of extract_value3\n2017-02-18 16:39:18 +0900\n2017-02-18 16:41:20 +0900\n\n\nConclusion\n3 is a best algorithm.\n\nIt is answer1\n\n```:ruby\narr1 = [2, 4, 5, 6, 7]\narr2 = [7, 8, 9, 7, 4, 3, 2]\n\ndef extract_value(arr1, arr2)\n  arr3 = arr1.uniq + arr2.uniq\n  arr4 = arr3.inject(Hash.new(0)){| init, v | init[v]+=1; init;}\n  answer = arr4.map{|k, v|  k if v >= 2}.compact\nend\n\nextract_value(arr1, arr2)\n```\n\n\nIt is answer2\n\n```:ruby\narr1 = [2, 4, 5, 6, 7]\narr2 = [7, 8, 9, 7, 4, 3, 2]\n\nrequire 'set'\ndef extract_value(arr1, arr2)\n  set_val, set_val2 = Set.new, Set.new\n  arr1.map{|v| set_val << v}\n  arr2.each {|v| set_val2 << v if set_val.include?(v) }\n  set_val2.to_a\nend\n\nextract_value(arr1, arr2)\n```\n\nIt is answer3\n\n```:ruby\narr1 & arr2\n```\n\n###Which is a better algorithm?\n\nLet me check\n\n```:ruby\narr1, arr2 = [], []\n1.upto(100000000).each {|v| arr1 << rand(1..500)}\n1.upto(100000000).each {|v| arr2 << rand(1..1000)}\n```\nembed time\n\n```:ruby\ndef extract_value1(arr1, arr2)\n  puts Time.now\n  arr3 = arr1.uniq + arr2.uniq\n  arr4 = arr3.inject(Hash.new(0)){| init, v | init[v]+=1; init;}\n  answer = arr4.map{|k, v|  k if v >= 2}.compact\n  puts Time.now\n  answer\nend\n```\n\nIt takes 8 seconds\n\n```:text\n2017-02-18 15:55:40 +0900\n2017-02-18 15:55:48 +0900\n```\n\nembed time\n\n```:ruby\nrequire 'set'\ndef extract_value2(arr1, arr2)\n  puts Time.now\n  set_val, set_val2 = Set.new, Set.new\n  arr1.map{|v| set_val << v}\n  arr2.each {|v| set_val2 << v if set_val.include?(v) }\n  puts Time.now\n  set_val2.to_a\nend\n```\n\nIt takes 44 seconds\n\n```:text\n2017-02-18 15:54:49 +0900\n2017-02-18 15:55:33 +0900\n```\n\nIt looks that first algorithm is better.\nI think it is because of uniq function.\n\n###I will change value of arr and function also\n\n```:ruby\narr1, arr2 = [], []\n1.upto(100000000).each {|v| arr1 << rand(1..5000000)}\n1.upto(100000000).each {|v| arr2 << rand(1..10000000)}\n```\n\nI will use uniq function in second one and name extract_value3\n\n```:ruby\nrequire 'set'\ndef extract_value3(arr1, arr2)\n  puts Time.now\n  set_val, set_val2 = Set.new, Set.new\n  arr1 = arr1.uniq\n  arr2 = arr2.uniq\n  arr1.map{|v| set_val << v}\n  arr2.each {|v| set_val2 << v if set_val.include?(v) }\n  puts Time.now\n  set_val2.to_a\nend\n```\n\nThis is the result of extract_value1\n\n```\n2017-02-18 16:26:37 +0900\n2017-02-18 16:29:22 +0900\n```\n\nThis is the result of extract_value2\n\n```\n2017-02-18 16:45:04 +0900\n2017-02-18 16:48:12 +0900\n```\n\n\nThis is the result of extract_value3\n\n```\n2017-02-18 16:39:18 +0900\n2017-02-18 16:41:20 +0900\n```\n\n###Conclusion\n\n3 is a best algorithm.\n", "tags": ["\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0"]}