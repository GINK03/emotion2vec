{"context": " More than 1 year has passed since last update.\u3064\u3044\u3067\u306b\u30a2\u30f3\u30ed\u30fc\u30ea\u30f3\u30b0\u306e\u81ea\u52d5\u30c1\u30e5\u30fc\u30cb\u30f3\u30b0\u3082\u3057\u3066\u307f\u305f\u3002\n\u8ffd\u8a18: unroll = 1 \u306e\u3068\u304d\u306b\u4e0d\u8981\u306a\u30aa\u30fc\u30d0\u30fc\u30d8\u30c3\u30c9\u304c\u3042\u3063\u3066\u3001\u304a\u304b\u3052\u3067\u624b\u3067\u66f8\u3044\u305f(1 1 8)\u3088\u308a\u3082\u9045\u304f\u306a\u3063\u3066\u3044\u305f\u3002\u307e\u305f\u3001\u63a2\u7d22\u306b\u304a\u3044\u3066\u751f\u6210\u3055\u308c\u305f\u89aa\u3060\u3051\u3067\u306f\u306a\u304f\u3059\u3079\u3066\u306e\u89aa\u3092\u8003\u616e\u3059\u308b\u3053\u3068\u306b\u3057\u305f\u3002\u518d\u5b9f\u9a13\u3057\u305f\u3089\u5225\u306e\u7d50\u679c\u304c\u5f97\u3089\u308c\u305f\u3002\nhttp://d.hatena.ne.jp/masatoi/20160204/1454519281\nhttp://keens.github.io/blog/2016/02/04/common_lispdekousokugyouretsuenzan/\nhttp://gos-k.hatenablog.com/entry/2016/02/27/135958\n\n\u8ffd\u8a66\n\u30d9\u30f3\u30c1\u30de\u30fc\u30af\u7528\u306e\u9053\u5177\n(ql:quickload :alexandria)\n(use-package :alexandria)\n\n(defun make-matrix (rows cols)\n  (make-array (list rows cols) :element-type 'single-float))\n\n(deftype matrix (&optional a b)\n  `(simple-array single-float (,a ,b)))\n\n(defmacro benchmark ((times &optional (times2 times)) &body body)\n  (once-only (times times2)\n    (with-gensyms (i start end)\n      `(progn\n         (dotimes (,i ,times)\n           ,@body)\n         (let ((,start (get-internal-run-time)))\n           (time\n            (dotimes (,i ,times2)\n              ,@body))\n           (let ((,end (get-internal-run-time)))\n             (print (float (/ (- ,end ,start)\n                              internal-time-units-per-second)))))))))\n\n\u30c7\u30fc\u30bf\n(defparameter *ma* (make-matrix 500 500))\n(defparameter *mb* (make-matrix 500 500))\n(defparameter *mc* (make-matrix 500 500))\n\nsimple-gemm \u3002\u914d\u5217\u78ba\u4fdd\u306e\u6642\u9593\u3092\u5165\u308c\u305f\u304f\u306a\u304b\u3063\u305f\u306e\u3067,\u7d50\u679c\u306f\u5f15\u6570mc\u306b\u7834\u58ca\u7684\u306b\u4ee3\u5165\u3059\u308b\u3088\u3046\u306b\u3057\u305f\u3002\n(defun simple-gemm (ma mb mc)\n  (declare (optimize (speed 3) (debug 0) (safety 0)))\n  (declare (type matrix ma mb mc))\n  (let ((rows (array-dimension ma 0))\n        (cols (array-dimension mb 1)))\n    (declare (type fixnum rows cols))\n    (dotimes (row rows)\n      (dotimes (col cols)\n        (dotimes (k cols)\n          (incf (aref mc row col)\n                (* (aref ma row k) (aref mb k col))))))\n    mc))\n\n(benchmark (10)\n  (simple-gemm *ma* *mb* *mc*)\n  ;; Evaluation took:\n  ;;   7.020 seconds of real time\n  ;;   7.020000 seconds of total run time (7.020000 user, 0.000000 system)\n  ;;   100.00% CPU\n  ;;   21,061,255,674 processor cycles\n  ;;   65,536 bytes consed\n  )\n\ngos-k \u3055\u3093\u306e row-major-gemm, disassemble \u898b\u3066\u30c1\u30e5\u30fc\u30cb\u30f3\u30b0\u3055\u308c\u3066\u308b\u3002\n\u30ec\u30b8\u30b9\u30bf\u3067\u30ad\u30e3\u30c3\u30b7\u30e5\u3082\u9069\u7528\u6e08\u307f\u3002\n(defun row-major-gemm (ma mb mc)\n  (declare (optimize (speed 3) (debug 0) (safety 0) (space 0)))\n  (declare (type matrix ma mb mc))\n  (let ((rows (array-dimension ma 0))\n        (cols (array-dimension mb 1)))\n    (declare (type fixnum rows cols))\n    (dotimes (row rows)\n      (dotimes (col cols)\n        (let ((cell (aref mc row col))\n              (ma-index (array-row-major-index ma row 0))\n              (mb-index (array-row-major-index mb 0 col)))\n          (declare (type (single-float) cell))\n          (declare (type fixnum ma-index mb-index))\n          (dotimes (k cols)\n            (incf cell (* (row-major-aref ma ma-index)\n                          (row-major-aref mb mb-index)))\n            (incf ma-index)\n            (incf mb-index cols))\n          (setf (aref mc row col) cell))))\n    mc))\n\n(benchmark (10)\n  ;; Evaluation took:\n  ;;   3.115 seconds of real time\n  ;;   3.116000 seconds of total run time (3.116000 user, 0.000000 system)\n  ;;   100.03% CPU\n  ;;   9,347,123,164 processor cycles\n  ;;   55,072 bytes consed\n  (row-major-gemm *ma* *mb* *mc*))\n\n\u914d\u5217\u30b5\u30a4\u30ba\u306f\u56fa\u5b9a\u306a\u306e\u3067\u5b9a\u6570\u3068\u3057\u3066\u5165\u308c\u3066\u307f\u305f\u3002\u3082\u3046\u3061\u3087\u3063\u3068\u65e9\u304f\u306a\u308b\n(defun rm-gemm+static-size (ma mb mc)\n  (declare (optimize (speed 3) (debug 0) (safety 0) (space 0)))\n  (declare (type (matrix 500 500) ma mb mc))\n  (let ((rows (array-dimension ma 0))\n        (cols (array-dimension mb 1)))\n    (declare (type fixnum rows cols))\n    (dotimes (row rows)\n      (dotimes (col cols)\n        (let ((cell (aref mc row col))\n              (ma-index (array-row-major-index ma row 0))\n              (mb-index (array-row-major-index mb 0 col)))\n          (declare (type (single-float) cell))\n          (declare (type fixnum ma-index mb-index))\n          (dotimes (k cols)\n            (incf cell (* (row-major-aref ma ma-index)\n                          (row-major-aref mb mb-index)))\n            (incf ma-index)\n            (incf mb-index cols))\n          (setf (aref mc row col) cell))))\n    mc))\n\n(benchmark (10)\n  (rm-gemm+static-size *ma* *mb* *mc*)\n  ;; Evaluation took:\n  ;;   2.773 seconds of real time\n  ;;   2.772000 seconds of total run time (2.772000 user, 0.000000 system)\n  ;;   99.96% CPU\n  ;;   8,318,453,469 processor cycles\n  ;;   0 bytes consed\n  )\n\n\u30eb\u30fc\u30d7\u30a2\u30f3\u30ed\u30fc\u30ea\u30f3\u30b0\u3002\n(defmacro dotimes-unroll ((i n unroll) &body body)\n  (check-type i symbol)\n  (assert (and (constantp unroll) (numberp unroll)))\n  (once-only (n)\n    `(locally\n       (declare (fixnum ,n))\n       (do ((,i 0))\n           ((< ,n (the fixnum (+ ,unroll ,i)))\n            (do ((,i ,i (the fixnum (1+ ,i))))\n                ((< ,n (the fixnum (1+ ,i))))\n              ,@body))\n         (declare (fixnum ,i))\n         ,@(loop :repeat unroll :append (append body `((incf ,i))))))))\n\n(dotimes-unroll (i 10 3)\n  (format t \"~%~a\" i))\n\nrow-major-gemm \u306b\u30a2\u30f3\u30ed\u30fc\u30eb\u3092\u304b\u3051\u3066\u5b9f\u9a13. 8 \u304c\u3044\u3061\u3070\u3093\u3088\u304b\u3063\u305f\u3002\n(defun rm-gemm+static-size+unroll (ma mb mc)\n  (declare (optimize (speed 3) (debug 0) (safety 0) (space 0)))\n  (declare (type (matrix 500 500) ma mb mc))\n  (let ((rows (array-dimension ma 0))\n        (cols (array-dimension mb 1)))\n    (declare (type fixnum rows cols))\n    (dotimes (row rows)\n      (dotimes (col cols)\n        (let ((cell (aref mc row col))\n              (ma-index (array-row-major-index ma row 0))\n              (mb-index (array-row-major-index mb 0 col)))\n          (declare (type (single-float) cell))\n          (declare (type fixnum ma-index mb-index))\n          (dotimes-unroll (k cols 8)\n            ;; best so far, on AMD Phenom(tm) II X6 1075T Processor\n            (incf cell (* (row-major-aref ma ma-index)\n                          (row-major-aref mb mb-index)))\n            (incf ma-index)\n            (incf mb-index cols))\n          (setf (aref mc row col) cell))))\n    mc))\n\n(benchmark (10)\n  (rm-gemm+static-size+unroll *ma* *mb* *mc*)\n  ;; Evaluation took:\n  ;;   2.203 seconds of real time\n  ;;   2.200000 seconds of total run time (2.200000 user, 0.000000 system)\n  ;;   99.86% CPU\n  ;;   6,609,926,012 processor cycles\n  ;;   0 bytes consed\n  )\n\n\n\u81ea\u52d5\u30c1\u30e5\u30fc\u30cb\u30f3\u30b0\n\u3055\u3066\u3001\u3053\u3053\u3067\u81ea\u5206\u306e\u51fa\u756a\u3060\u3002\u591a\u6bb5\u30a2\u30f3\u30ed\u30fc\u30ea\u30f3\u30b0\u3092\u304b\u3051\u305f\u30b3\u30fc\u30c9\u3092\u751f\u6210\u3057\u3001\u30b3\u30f3\u30d1\u30a4\u30eb\u3002\u95a2\u6570\u30aa\u30d6\u30b8\u30a7\u30af\u30c8\u304c\u8fd4\u3063\u3066\u304f\u308b\u3002\u30a2\u30f3\u30ed\u30fc\u30ea\u30f3\u30b0\u306e\u30b3\u30fc\u30c9\u306f\u9593\u9055\u3063\u3066\u308b\u304b\u3082\u3057\u308c\u306a\u3044\u3002\n(ql:quickload :priority-queue)\n(use-package :priority-queue)\n(ql:quickload :iterate)\n(use-package :iterate)\n\n(defun make-unroll-gemm (x y z)\n  (check-type x integer)\n  (check-type y integer)\n  (check-type z integer)\n  (compile nil\n           `(lambda (ma mb mc)\n              (declare (optimize (speed 3) (debug 0) (safety 0) (space 0)))\n              (declare (type (matrix 500 500) ma mb mc))\n              (let ((rows (array-dimension ma 0))\n                    (cols (array-dimension mb 1)))\n                (declare (type fixnum rows cols))\n                (dotimes-unroll (row rows ,x)\n                  (dotimes-unroll (col cols ,y)\n                    (let ((cell (aref mc row col))\n                          (ma-index (array-row-major-index ma row 0))\n                          (mb-index (array-row-major-index mb 0 col)))\n                      (declare (type (single-float) cell))\n                      (declare (type fixnum ma-index mb-index))\n                      (dotimes-unroll (k cols ,z)\n                        (incf cell (* (row-major-aref ma ma-index)\n                                      (row-major-aref mb mb-index)))\n                        (incf ma-index)\n                        (incf mb-index cols))\n                      (setf (aref mc row col) cell))))\n                mc))))\n\n\u6027\u80fd\u8a55\u4fa1\u3002\u79d2\u6570\u304cfloat\u3067\u8fd4\u3063\u3066\u304f\u308b\u3002\n(defun evaluate-unrolling (x y z)\n  (let ((f (make-unroll-gemm x y z)))\n    (benchmark (20) (funcall f *ma* *mb* *mc*))))\n\n\u30d1\u30e9\u30e1\u30fc\u30bf\u7a7a\u9593\u3092\u5e45\u512a\u5148\u3067\u63a2\u7d22\u3059\u308b\u3002priority queue \u304b\u3089\u30d1\u30e9\u30e1\u30fc\u30bf\u3092\u53d6\u308a\u51fa\u3057\u3066\u3001\n1,2,3 \u6bb5\u76ee\u306e\u4f55\u308c\u304b\u306e\u6bb5\u6570\u3092\u500d\u306b\u3002\u7d50\u679c\u304c\u6539\u5584\u3055\u308c\u3066\u3044\u308c\u3070queue\u306b\u7a81\u3063\u8fbc\u3080\u3002\n(defun search-best-unrolling ()\n  (let ((q (make-pqueue #'< :key-type 'float :value-type 'list))\n        (close nil))\n    (format t \"~&testing ~a ...\" '(1 1 1))\n    (let* ((f (make-unroll-gemm 1 1 1))\n           (basetime (benchmark (10) (funcall f *ma* *mb* *mc*))))\n      (format t \" ~a (sec). \" basetime)\n      (pqueue-push '(1 1 1) basetime q))\n    (iter (until (pqueue-empty-p q))\n          (for (values parameters time) = (pqueue-pop q))\n          (finding (cons parameters time) minimizing time)\n          (for (x y z) = parameters)\n          (iter (for new-parameters in (list (list x y (* 2 z))\n                                             (list x (* 2 y) z)\n                                             (list (* 2 x) y z)))\n                (when (member parameters close :test #'equal)\n                  ;; duplicate detection\n                  (next-iteration))\n                (format t \"~&testing ~a ...\" new-parameters)\n                (for newtime = (apply #'evaluate-unrolling new-parameters))\n                (format t \" ~a (sec). \" newtime)\n                (if (< newtime time)\n                    (progn\n                      (format t \"Improved from the results of ~a: ~a.\" parameters time)\n                      (pqueue-push new-parameters newtime q))\n                    (push new-parameters close))))))\n\n\n\u7d50\u679c (\u4e0d\u5f53)\n\u307e\u3042\u9806\u5f53\u304b\u3002\nCL-USER> (search-best-unrolling)\n\ntesting (1 1 1) ... 2.792 (sec). \ntesting (1 1 2) ... 2.632 (sec). Improved from the results of (1 1 1): 2.792.\ntesting (1 2 1) ... 2.772 (sec). Improved from the results of (1 1 1): 2.792.\ntesting (2 1 1) ... 2.768 (sec). Improved from the results of (1 1 1): 2.792.\ntesting (1 1 4) ... 2.548 (sec). Improved from the results of (1 1 2): 2.632.\ntesting (1 2 2) ... 2.632 (sec). \ntesting (2 1 2) ... 2.636 (sec). \ntesting (1 1 8) ... 2.496 (sec). Improved from the results of (1 1 4): 2.548.\ntesting (1 2 4) ... 2.544 (sec). Improved from the results of (1 1 4): 2.548.\ntesting (2 1 4) ... 2.548 (sec). \ntesting (1 1 16) ... 2.5 (sec). \ntesting (1 2 8) ... 2.492 (sec). Improved from the results of (1 1 8): 2.496.\ntesting (2 1 8) ... 2.496 (sec). \ntesting (1 2 16) ... 2.496 (sec). \ntesting (1 4 8) ... 2.496 (sec). \ntesting (2 2 8) ... 2.496 (sec). \ntesting (1 2 8) ... 2.496 (sec). Improved from the results of (1 2 4): 2.544.\ntesting (1 4 4) ... 2.548 (sec). \ntesting (2 2 4) ... 2.548 (sec). \ntesting (1 2 16) ... 2.504 (sec). \ntesting (1 4 8) ... 2.492 (sec). Improved from the results of (1 2 8): 2.496.\ntesting (2 2 8) ... 2.496 (sec). \ntesting (2 1 2) ... 2.632 (sec). Improved from the results of (2 1 1): 2.768.\ntesting (2 2 1) ... 2.792 (sec). \ntesting (4 1 1) ... 2.784 (sec). \ntesting (1 2 2) ... 2.636 (sec). Improved from the results of (1 2 1): 2.772.\ntesting (1 4 1) ... 2.784 (sec). \ntesting (2 2 1) ... 2.796 (sec). \n((1 2 8) . 2.492)\n\n\n\u9593\u9055\u3044\u767a\u898b\n\u30a2\u30f3\u30ed\u30fc\u30ea\u30f3\u30b0\u306e\u30b3\u30fc\u30c9\u3067\u3001 unroll = 1 \u306e\u3068\u304d\u306b\u4e0d\u8981\u306a\u30aa\u30fc\u30d0\u30fc\u30d8\u30c3\u30c9\u304c\u3042\u3063\u305f\u3002\n\u624b\u3067\u66f8\u3044\u305f (1 1 8) \u306f 2.203 sec \u3060\u3063\u305f\u306e\u306b\u3001\u4e0a\u306e\u5b9f\u9a13\u3067\u306e (1 1 8) \u306f 2.496 sec \u3082\u304b\u304b\u3063\u3066\u3044\u308b\u3002\u305d\u3053\u3067\u30011\u306e\u3068\u304d\u306b\u306f\u666e\u901a\u306edotime\u306b\u623b\u3059\u3088\u3046\u306b\u3057\u305f\u3002\n(defmacro dotimes-unroll ((i n unroll) &body body)\n  (check-type i symbol)\n  (assert (and (constantp unroll) (numberp unroll)))\n  (if (= 1 unroll)\n      `(dotimes (,i ,n)\n         ,@body)\n      (once-only (n)\n        `(locally\n             (declare (fixnum ,n))\n           (do ((,i 0))\n               ((< ,n (the fixnum (+ ,unroll ,i)))\n                (do ((,i ,i (the fixnum (1+ ,i))))\n                    ((< ,n (the fixnum (1+ ,i))))\n                  ,@body))\n             (declare (fixnum ,i))\n             ,@(loop :repeat unroll :append (append body `((incf ,i)))))))))\n\n\u307e\u305f\u3001\u76f4\u63a5\u751f\u6210\u3055\u308c\u305f\u89aa\u3060\u3051\u3067\u306f\u306a\u304f\u3001\u307b\u304b\u306e\u89aa\u3082\u8003\u616e\u3059\u308b\u3053\u3068\u306b\u3088\u3063\u3066\u679d\u5208\u308a\u3092\u5f37\u304f\u3057\u305f\u3002\u4f8b\u3048\u3070, (1 2 4) \u304b\u3089 (2 2 4) \u3092\u751f\u6210\u3057\u305f\u6642\u3001 (1 2 4) \u306e\u30b9\u30b3\u30a2\u3060\u3051\u3067\u306f\u306a\u304f (2 1 4), (2 2 2) \u3089\u306e\u30b9\u30b3\u30a2\u3088\u308a\u3082\u6539\u5584\u3055\u308c\u306a\u3044\u3068\u3044\u3051\u306a\u3044\u3088\u3046\u306b\u3057\u305f\u3002\n(defun children (parameters)\n  (destructuring-bind (x y z) parameters\n    (list (list x y (* z 2))\n          (list x (* y 2) z)\n          (list (* x 2) y z))))\n\n(defun parents (parameters)\n  (destructuring-bind (x y z) parameters\n    (remove-if-not (lambda (parameters)\n                     (every #'integerp parameters))\n                   (list (list x y (/ z 2))\n                         (list x (/ y 2) z)\n                         (list (/ x 2) y z)))))\n\n(defun search-best-unrolling ()\n  (let ((q (make-pqueue #'< :key-type 'float :value-type 'list))\n        (close nil))\n    (format t \"~&testing ~a ...\" '(1 1 1))\n    (let* ((f (make-unroll-gemm 1 1 1))\n           (basetime (benchmark (10) (funcall f *ma* *mb* *mc*))))\n      (format t \" ~a (sec). \" basetime)\n      (push (cons '(1 1 1) basetime) close)\n      (pqueue-push '(1 1 1) basetime q))\n    (iter (until (pqueue-empty-p q))\n          (for (values parameters time) = (pqueue-pop q))\n          (finding (cons parameters time) minimizing time)\n          (iter (for new-parameters in (children parameters)) ; parameters : \u76f4\u63a5\u306e\u89aa\n                (when (member new-parameters close :key #'car :test #'equal)\n                  ;; duplicate detection\n                  (next-iteration))\n                (format t \"~&testing ~a ...\" new-parameters)\n                (for newtime = (apply #'evaluate-unrolling new-parameters))\n                (format t \" ~a (sec). \" newtime)\n                (push (cons new-parameters newtime) close)\n                (for (time . best-parent) = ; \u4e00\u756a\u826f\u3044\u89aa\u306b\u3064\u3044\u3066\u30c1\u30a7\u30c3\u30af\u3059\u308b\u3053\u3068\u306b\u3057\u305f\u3002\n                     (iter (for parent in (parents new-parameters))\n                           (for time = (cdr (assoc parent close :test #'equal)))\n                           (when time\n                             (finding (cons time parent) minimizing time))))\n                (when (< newtime time)\n                  (format t \"Improved from the best result by parent ~a: ~a.\" best-parent time)\n                  (pqueue-push new-parameters newtime q))))))\n\n\n\u7d50\u679c\n\u65e9\u304f\u306a\u3063\u305f\u3002\u3044\u3061\u3070\u3093\u3044\u3044\u30a2\u30f3\u30ed\u30fc\u30eb\u30d1\u30e9\u30e1\u30fc\u30bf\u306f\u540c\u3058\u3060\u3063\u305f\u3002\nCL-USER> (search-best-unrolling)\ntesting (1 1 1) ... 2.528 (sec). \ntesting (1 1 2) ... 2.348 (sec). Improved from the best result by parent (1 1 1): 2.528.\ntesting (1 2 1) ... 2.524 (sec). Improved from the best result by parent (1 1 1): 2.528.\ntesting (2 1 1) ... 2.532 (sec). \ntesting (1 1 4) ... 2.248 (sec). Improved from the best result by parent (1 1 2): 2.348.\ntesting (1 2 2) ... 2.352 (sec). \ntesting (2 1 2) ... 2.352 (sec). \ntesting (1 1 8) ... 2.212 (sec). Improved from the best result by parent (1 1 4): 2.248.\ntesting (1 2 4) ... 2.248 (sec). \ntesting (2 1 4) ... 2.248 (sec). \ntesting (1 1 16) ... 2.228 (sec). \ntesting (1 2 8) ... 2.204 (sec). Improved from the best result by parent (1 1 8): 2.212.\ntesting (2 1 8) ... 2.208 (sec). Improved from the best result by parent (1 1 8): 2.212.\ntesting (1 2 16) ... 2.228 (sec). \ntesting (1 4 8) ... 2.224 (sec). \ntesting (2 2 8) ... 2.28 (sec). \ntesting (2 1 16) ... 2.328 (sec). \ntesting (4 1 8) ... 2.24 (sec). \ntesting (1 4 1) ... 2.576 (sec). \ntesting (2 2 1) ... 2.58 (sec). \n((1 2 8) . 2.204)\n\n\n\u3064\u3044\u3067\u306b\u30a2\u30f3\u30ed\u30fc\u30ea\u30f3\u30b0\u306e\u81ea\u52d5\u30c1\u30e5\u30fc\u30cb\u30f3\u30b0\u3082\u3057\u3066\u307f\u305f\u3002\n\u8ffd\u8a18: unroll = 1 \u306e\u3068\u304d\u306b\u4e0d\u8981\u306a\u30aa\u30fc\u30d0\u30fc\u30d8\u30c3\u30c9\u304c\u3042\u3063\u3066\u3001\u304a\u304b\u3052\u3067\u624b\u3067\u66f8\u3044\u305f(1 1 8)\u3088\u308a\u3082\u9045\u304f\u306a\u3063\u3066\u3044\u305f\u3002\u307e\u305f\u3001\u63a2\u7d22\u306b\u304a\u3044\u3066\u751f\u6210\u3055\u308c\u305f\u89aa\u3060\u3051\u3067\u306f\u306a\u304f\u3059\u3079\u3066\u306e\u89aa\u3092\u8003\u616e\u3059\u308b\u3053\u3068\u306b\u3057\u305f\u3002\u518d\u5b9f\u9a13\u3057\u305f\u3089\u5225\u306e\u7d50\u679c\u304c\u5f97\u3089\u308c\u305f\u3002\n\nhttp://d.hatena.ne.jp/masatoi/20160204/1454519281\nhttp://keens.github.io/blog/2016/02/04/common_lispdekousokugyouretsuenzan/\nhttp://gos-k.hatenablog.com/entry/2016/02/27/135958\n\n# \u8ffd\u8a66\n\n\u30d9\u30f3\u30c1\u30de\u30fc\u30af\u7528\u306e\u9053\u5177\n\n```lisp\n(ql:quickload :alexandria)\n(use-package :alexandria)\n\n(defun make-matrix (rows cols)\n  (make-array (list rows cols) :element-type 'single-float))\n\n(deftype matrix (&optional a b)\n  `(simple-array single-float (,a ,b)))\n\n(defmacro benchmark ((times &optional (times2 times)) &body body)\n  (once-only (times times2)\n    (with-gensyms (i start end)\n      `(progn\n         (dotimes (,i ,times)\n           ,@body)\n         (let ((,start (get-internal-run-time)))\n           (time\n            (dotimes (,i ,times2)\n              ,@body))\n           (let ((,end (get-internal-run-time)))\n             (print (float (/ (- ,end ,start)\n                              internal-time-units-per-second)))))))))\n```\n\n\u30c7\u30fc\u30bf\n\n```lisp\n(defparameter *ma* (make-matrix 500 500))\n(defparameter *mb* (make-matrix 500 500))\n(defparameter *mc* (make-matrix 500 500))\n```\n\nsimple-gemm \u3002\u914d\u5217\u78ba\u4fdd\u306e\u6642\u9593\u3092\u5165\u308c\u305f\u304f\u306a\u304b\u3063\u305f\u306e\u3067,\u7d50\u679c\u306f\u5f15\u6570mc\u306b\u7834\u58ca\u7684\u306b\u4ee3\u5165\u3059\u308b\u3088\u3046\u306b\u3057\u305f\u3002\n\n```lisp\n(defun simple-gemm (ma mb mc)\n  (declare (optimize (speed 3) (debug 0) (safety 0)))\n  (declare (type matrix ma mb mc))\n  (let ((rows (array-dimension ma 0))\n        (cols (array-dimension mb 1)))\n    (declare (type fixnum rows cols))\n    (dotimes (row rows)\n      (dotimes (col cols)\n        (dotimes (k cols)\n          (incf (aref mc row col)\n                (* (aref ma row k) (aref mb k col))))))\n    mc))\n\n(benchmark (10)\n  (simple-gemm *ma* *mb* *mc*)\n  ;; Evaluation took:\n  ;;   7.020 seconds of real time\n  ;;   7.020000 seconds of total run time (7.020000 user, 0.000000 system)\n  ;;   100.00% CPU\n  ;;   21,061,255,674 processor cycles\n  ;;   65,536 bytes consed\n  )\n```\n\ngos-k \u3055\u3093\u306e row-major-gemm, disassemble \u898b\u3066\u30c1\u30e5\u30fc\u30cb\u30f3\u30b0\u3055\u308c\u3066\u308b\u3002\n\u30ec\u30b8\u30b9\u30bf\u3067\u30ad\u30e3\u30c3\u30b7\u30e5\u3082\u9069\u7528\u6e08\u307f\u3002\n\n```lisp\n(defun row-major-gemm (ma mb mc)\n  (declare (optimize (speed 3) (debug 0) (safety 0) (space 0)))\n  (declare (type matrix ma mb mc))\n  (let ((rows (array-dimension ma 0))\n        (cols (array-dimension mb 1)))\n    (declare (type fixnum rows cols))\n    (dotimes (row rows)\n      (dotimes (col cols)\n        (let ((cell (aref mc row col))\n              (ma-index (array-row-major-index ma row 0))\n              (mb-index (array-row-major-index mb 0 col)))\n          (declare (type (single-float) cell))\n          (declare (type fixnum ma-index mb-index))\n          (dotimes (k cols)\n            (incf cell (* (row-major-aref ma ma-index)\n                          (row-major-aref mb mb-index)))\n            (incf ma-index)\n            (incf mb-index cols))\n          (setf (aref mc row col) cell))))\n    mc))\n\n(benchmark (10)\n  ;; Evaluation took:\n  ;;   3.115 seconds of real time\n  ;;   3.116000 seconds of total run time (3.116000 user, 0.000000 system)\n  ;;   100.03% CPU\n  ;;   9,347,123,164 processor cycles\n  ;;   55,072 bytes consed\n  (row-major-gemm *ma* *mb* *mc*))\n```\n\n\u914d\u5217\u30b5\u30a4\u30ba\u306f\u56fa\u5b9a\u306a\u306e\u3067\u5b9a\u6570\u3068\u3057\u3066\u5165\u308c\u3066\u307f\u305f\u3002\u3082\u3046\u3061\u3087\u3063\u3068\u65e9\u304f\u306a\u308b\n\n```lisp\n(defun rm-gemm+static-size (ma mb mc)\n  (declare (optimize (speed 3) (debug 0) (safety 0) (space 0)))\n  (declare (type (matrix 500 500) ma mb mc))\n  (let ((rows (array-dimension ma 0))\n        (cols (array-dimension mb 1)))\n    (declare (type fixnum rows cols))\n    (dotimes (row rows)\n      (dotimes (col cols)\n        (let ((cell (aref mc row col))\n              (ma-index (array-row-major-index ma row 0))\n              (mb-index (array-row-major-index mb 0 col)))\n          (declare (type (single-float) cell))\n          (declare (type fixnum ma-index mb-index))\n          (dotimes (k cols)\n            (incf cell (* (row-major-aref ma ma-index)\n                          (row-major-aref mb mb-index)))\n            (incf ma-index)\n            (incf mb-index cols))\n          (setf (aref mc row col) cell))))\n    mc))\n\n(benchmark (10)\n  (rm-gemm+static-size *ma* *mb* *mc*)\n  ;; Evaluation took:\n  ;;   2.773 seconds of real time\n  ;;   2.772000 seconds of total run time (2.772000 user, 0.000000 system)\n  ;;   99.96% CPU\n  ;;   8,318,453,469 processor cycles\n  ;;   0 bytes consed\n  )\n```\n\n\u30eb\u30fc\u30d7\u30a2\u30f3\u30ed\u30fc\u30ea\u30f3\u30b0\u3002\n\n```lisp\n(defmacro dotimes-unroll ((i n unroll) &body body)\n  (check-type i symbol)\n  (assert (and (constantp unroll) (numberp unroll)))\n  (once-only (n)\n    `(locally\n       (declare (fixnum ,n))\n       (do ((,i 0))\n           ((< ,n (the fixnum (+ ,unroll ,i)))\n            (do ((,i ,i (the fixnum (1+ ,i))))\n                ((< ,n (the fixnum (1+ ,i))))\n              ,@body))\n         (declare (fixnum ,i))\n         ,@(loop :repeat unroll :append (append body `((incf ,i))))))))\n\n(dotimes-unroll (i 10 3)\n  (format t \"~%~a\" i))\n```\n\nrow-major-gemm \u306b\u30a2\u30f3\u30ed\u30fc\u30eb\u3092\u304b\u3051\u3066\u5b9f\u9a13. 8 \u304c\u3044\u3061\u3070\u3093\u3088\u304b\u3063\u305f\u3002\n\n```lisp\n(defun rm-gemm+static-size+unroll (ma mb mc)\n  (declare (optimize (speed 3) (debug 0) (safety 0) (space 0)))\n  (declare (type (matrix 500 500) ma mb mc))\n  (let ((rows (array-dimension ma 0))\n        (cols (array-dimension mb 1)))\n    (declare (type fixnum rows cols))\n    (dotimes (row rows)\n      (dotimes (col cols)\n        (let ((cell (aref mc row col))\n              (ma-index (array-row-major-index ma row 0))\n              (mb-index (array-row-major-index mb 0 col)))\n          (declare (type (single-float) cell))\n          (declare (type fixnum ma-index mb-index))\n          (dotimes-unroll (k cols 8)\n            ;; best so far, on AMD Phenom(tm) II X6 1075T Processor\n            (incf cell (* (row-major-aref ma ma-index)\n                          (row-major-aref mb mb-index)))\n            (incf ma-index)\n            (incf mb-index cols))\n          (setf (aref mc row col) cell))))\n    mc))\n\n(benchmark (10)\n  (rm-gemm+static-size+unroll *ma* *mb* *mc*)\n  ;; Evaluation took:\n  ;;   2.203 seconds of real time\n  ;;   2.200000 seconds of total run time (2.200000 user, 0.000000 system)\n  ;;   99.86% CPU\n  ;;   6,609,926,012 processor cycles\n  ;;   0 bytes consed\n  )\n```\n\n# \u81ea\u52d5\u30c1\u30e5\u30fc\u30cb\u30f3\u30b0\n\n\u3055\u3066\u3001\u3053\u3053\u3067\u81ea\u5206\u306e\u51fa\u756a\u3060\u3002\u591a\u6bb5\u30a2\u30f3\u30ed\u30fc\u30ea\u30f3\u30b0\u3092\u304b\u3051\u305f\u30b3\u30fc\u30c9\u3092\u751f\u6210\u3057\u3001\u30b3\u30f3\u30d1\u30a4\u30eb\u3002\u95a2\u6570\u30aa\u30d6\u30b8\u30a7\u30af\u30c8\u304c\u8fd4\u3063\u3066\u304f\u308b\u3002\u30a2\u30f3\u30ed\u30fc\u30ea\u30f3\u30b0\u306e\u30b3\u30fc\u30c9\u306f\u9593\u9055\u3063\u3066\u308b\u304b\u3082\u3057\u308c\u306a\u3044\u3002\n\n```lisp\n(ql:quickload :priority-queue)\n(use-package :priority-queue)\n(ql:quickload :iterate)\n(use-package :iterate)\n\n(defun make-unroll-gemm (x y z)\n  (check-type x integer)\n  (check-type y integer)\n  (check-type z integer)\n  (compile nil\n           `(lambda (ma mb mc)\n              (declare (optimize (speed 3) (debug 0) (safety 0) (space 0)))\n              (declare (type (matrix 500 500) ma mb mc))\n              (let ((rows (array-dimension ma 0))\n                    (cols (array-dimension mb 1)))\n                (declare (type fixnum rows cols))\n                (dotimes-unroll (row rows ,x)\n                  (dotimes-unroll (col cols ,y)\n                    (let ((cell (aref mc row col))\n                          (ma-index (array-row-major-index ma row 0))\n                          (mb-index (array-row-major-index mb 0 col)))\n                      (declare (type (single-float) cell))\n                      (declare (type fixnum ma-index mb-index))\n                      (dotimes-unroll (k cols ,z)\n                        (incf cell (* (row-major-aref ma ma-index)\n                                      (row-major-aref mb mb-index)))\n                        (incf ma-index)\n                        (incf mb-index cols))\n                      (setf (aref mc row col) cell))))\n                mc))))\n```\n\n\u6027\u80fd\u8a55\u4fa1\u3002\u79d2\u6570\u304c`float`\u3067\u8fd4\u3063\u3066\u304f\u308b\u3002\n\n```cl\n(defun evaluate-unrolling (x y z)\n  (let ((f (make-unroll-gemm x y z)))\n    (benchmark (20) (funcall f *ma* *mb* *mc*))))\n```\n\n\u30d1\u30e9\u30e1\u30fc\u30bf\u7a7a\u9593\u3092\u5e45\u512a\u5148\u3067\u63a2\u7d22\u3059\u308b\u3002priority queue \u304b\u3089\u30d1\u30e9\u30e1\u30fc\u30bf\u3092\u53d6\u308a\u51fa\u3057\u3066\u3001\n1,2,3 \u6bb5\u76ee\u306e\u4f55\u308c\u304b\u306e\u6bb5\u6570\u3092\u500d\u306b\u3002\u7d50\u679c\u304c\u6539\u5584\u3055\u308c\u3066\u3044\u308c\u3070queue\u306b\u7a81\u3063\u8fbc\u3080\u3002\n\n```cl\n(defun search-best-unrolling ()\n  (let ((q (make-pqueue #'< :key-type 'float :value-type 'list))\n        (close nil))\n    (format t \"~&testing ~a ...\" '(1 1 1))\n    (let* ((f (make-unroll-gemm 1 1 1))\n           (basetime (benchmark (10) (funcall f *ma* *mb* *mc*))))\n      (format t \" ~a (sec). \" basetime)\n      (pqueue-push '(1 1 1) basetime q))\n    (iter (until (pqueue-empty-p q))\n          (for (values parameters time) = (pqueue-pop q))\n          (finding (cons parameters time) minimizing time)\n          (for (x y z) = parameters)\n          (iter (for new-parameters in (list (list x y (* 2 z))\n                                             (list x (* 2 y) z)\n                                             (list (* 2 x) y z)))\n                (when (member parameters close :test #'equal)\n                  ;; duplicate detection\n                  (next-iteration))\n                (format t \"~&testing ~a ...\" new-parameters)\n                (for newtime = (apply #'evaluate-unrolling new-parameters))\n                (format t \" ~a (sec). \" newtime)\n                (if (< newtime time)\n                    (progn\n                      (format t \"Improved from the results of ~a: ~a.\" parameters time)\n                      (pqueue-push new-parameters newtime q))\n                    (push new-parameters close))))))\n```\n\n# \u7d50\u679c (\u4e0d\u5f53)\n\n\u307e\u3042\u9806\u5f53\u304b\u3002\n\n```cl\nCL-USER> (search-best-unrolling)\n\ntesting (1 1 1) ... 2.792 (sec). \ntesting (1 1 2) ... 2.632 (sec). Improved from the results of (1 1 1): 2.792.\ntesting (1 2 1) ... 2.772 (sec). Improved from the results of (1 1 1): 2.792.\ntesting (2 1 1) ... 2.768 (sec). Improved from the results of (1 1 1): 2.792.\ntesting (1 1 4) ... 2.548 (sec). Improved from the results of (1 1 2): 2.632.\ntesting (1 2 2) ... 2.632 (sec). \ntesting (2 1 2) ... 2.636 (sec). \ntesting (1 1 8) ... 2.496 (sec). Improved from the results of (1 1 4): 2.548.\ntesting (1 2 4) ... 2.544 (sec). Improved from the results of (1 1 4): 2.548.\ntesting (2 1 4) ... 2.548 (sec). \ntesting (1 1 16) ... 2.5 (sec). \ntesting (1 2 8) ... 2.492 (sec). Improved from the results of (1 1 8): 2.496.\ntesting (2 1 8) ... 2.496 (sec). \ntesting (1 2 16) ... 2.496 (sec). \ntesting (1 4 8) ... 2.496 (sec). \ntesting (2 2 8) ... 2.496 (sec). \ntesting (1 2 8) ... 2.496 (sec). Improved from the results of (1 2 4): 2.544.\ntesting (1 4 4) ... 2.548 (sec). \ntesting (2 2 4) ... 2.548 (sec). \ntesting (1 2 16) ... 2.504 (sec). \ntesting (1 4 8) ... 2.492 (sec). Improved from the results of (1 2 8): 2.496.\ntesting (2 2 8) ... 2.496 (sec). \ntesting (2 1 2) ... 2.632 (sec). Improved from the results of (2 1 1): 2.768.\ntesting (2 2 1) ... 2.792 (sec). \ntesting (4 1 1) ... 2.784 (sec). \ntesting (1 2 2) ... 2.636 (sec). Improved from the results of (1 2 1): 2.772.\ntesting (1 4 1) ... 2.784 (sec). \ntesting (2 2 1) ... 2.796 (sec). \n((1 2 8) . 2.492)\n```\n\n# \u9593\u9055\u3044\u767a\u898b\n\n\u30a2\u30f3\u30ed\u30fc\u30ea\u30f3\u30b0\u306e\u30b3\u30fc\u30c9\u3067\u3001 unroll = 1 \u306e\u3068\u304d\u306b\u4e0d\u8981\u306a\u30aa\u30fc\u30d0\u30fc\u30d8\u30c3\u30c9\u304c\u3042\u3063\u305f\u3002\n\u624b\u3067\u66f8\u3044\u305f (1 1 8) \u306f 2.203 sec \u3060\u3063\u305f\u306e\u306b\u3001\u4e0a\u306e\u5b9f\u9a13\u3067\u306e (1 1 8) \u306f 2.496 sec \u3082\u304b\u304b\u3063\u3066\u3044\u308b\u3002\u305d\u3053\u3067\u30011\u306e\u3068\u304d\u306b\u306f\u666e\u901a\u306edotime\u306b\u623b\u3059\u3088\u3046\u306b\u3057\u305f\u3002\n\n```cl\n(defmacro dotimes-unroll ((i n unroll) &body body)\n  (check-type i symbol)\n  (assert (and (constantp unroll) (numberp unroll)))\n  (if (= 1 unroll)\n      `(dotimes (,i ,n)\n         ,@body)\n      (once-only (n)\n        `(locally\n             (declare (fixnum ,n))\n           (do ((,i 0))\n               ((< ,n (the fixnum (+ ,unroll ,i)))\n                (do ((,i ,i (the fixnum (1+ ,i))))\n                    ((< ,n (the fixnum (1+ ,i))))\n                  ,@body))\n             (declare (fixnum ,i))\n             ,@(loop :repeat unroll :append (append body `((incf ,i)))))))))\n```\n\n\u307e\u305f\u3001\u76f4\u63a5\u751f\u6210\u3055\u308c\u305f\u89aa\u3060\u3051\u3067\u306f\u306a\u304f\u3001\u307b\u304b\u306e\u89aa\u3082\u8003\u616e\u3059\u308b\u3053\u3068\u306b\u3088\u3063\u3066\u679d\u5208\u308a\u3092\u5f37\u304f\u3057\u305f\u3002\u4f8b\u3048\u3070, (1 2 4) \u304b\u3089 (2 2 4) \u3092\u751f\u6210\u3057\u305f\u6642\u3001 (1 2 4) \u306e\u30b9\u30b3\u30a2\u3060\u3051\u3067\u306f\u306a\u304f (2 1 4), (2 2 2) \u3089\u306e\u30b9\u30b3\u30a2\u3088\u308a\u3082\u6539\u5584\u3055\u308c\u306a\u3044\u3068\u3044\u3051\u306a\u3044\u3088\u3046\u306b\u3057\u305f\u3002\n\n```cl\n(defun children (parameters)\n  (destructuring-bind (x y z) parameters\n    (list (list x y (* z 2))\n          (list x (* y 2) z)\n          (list (* x 2) y z))))\n\n(defun parents (parameters)\n  (destructuring-bind (x y z) parameters\n    (remove-if-not (lambda (parameters)\n                     (every #'integerp parameters))\n                   (list (list x y (/ z 2))\n                         (list x (/ y 2) z)\n                         (list (/ x 2) y z)))))\n\n(defun search-best-unrolling ()\n  (let ((q (make-pqueue #'< :key-type 'float :value-type 'list))\n        (close nil))\n    (format t \"~&testing ~a ...\" '(1 1 1))\n    (let* ((f (make-unroll-gemm 1 1 1))\n           (basetime (benchmark (10) (funcall f *ma* *mb* *mc*))))\n      (format t \" ~a (sec). \" basetime)\n      (push (cons '(1 1 1) basetime) close)\n      (pqueue-push '(1 1 1) basetime q))\n    (iter (until (pqueue-empty-p q))\n          (for (values parameters time) = (pqueue-pop q))\n          (finding (cons parameters time) minimizing time)\n          (iter (for new-parameters in (children parameters)) ; parameters : \u76f4\u63a5\u306e\u89aa\n                (when (member new-parameters close :key #'car :test #'equal)\n                  ;; duplicate detection\n                  (next-iteration))\n                (format t \"~&testing ~a ...\" new-parameters)\n                (for newtime = (apply #'evaluate-unrolling new-parameters))\n                (format t \" ~a (sec). \" newtime)\n                (push (cons new-parameters newtime) close)\n                (for (time . best-parent) = ; \u4e00\u756a\u826f\u3044\u89aa\u306b\u3064\u3044\u3066\u30c1\u30a7\u30c3\u30af\u3059\u308b\u3053\u3068\u306b\u3057\u305f\u3002\n                     (iter (for parent in (parents new-parameters))\n                           (for time = (cdr (assoc parent close :test #'equal)))\n                           (when time\n                             (finding (cons time parent) minimizing time))))\n                (when (< newtime time)\n                  (format t \"Improved from the best result by parent ~a: ~a.\" best-parent time)\n                  (pqueue-push new-parameters newtime q))))))\n```\n\n# \u7d50\u679c\n\n\u65e9\u304f\u306a\u3063\u305f\u3002\u3044\u3061\u3070\u3093\u3044\u3044\u30a2\u30f3\u30ed\u30fc\u30eb\u30d1\u30e9\u30e1\u30fc\u30bf\u306f\u540c\u3058\u3060\u3063\u305f\u3002\n\n```cl\nCL-USER> (search-best-unrolling)\ntesting (1 1 1) ... 2.528 (sec). \ntesting (1 1 2) ... 2.348 (sec). Improved from the best result by parent (1 1 1): 2.528.\ntesting (1 2 1) ... 2.524 (sec). Improved from the best result by parent (1 1 1): 2.528.\ntesting (2 1 1) ... 2.532 (sec). \ntesting (1 1 4) ... 2.248 (sec). Improved from the best result by parent (1 1 2): 2.348.\ntesting (1 2 2) ... 2.352 (sec). \ntesting (2 1 2) ... 2.352 (sec). \ntesting (1 1 8) ... 2.212 (sec). Improved from the best result by parent (1 1 4): 2.248.\ntesting (1 2 4) ... 2.248 (sec). \ntesting (2 1 4) ... 2.248 (sec). \ntesting (1 1 16) ... 2.228 (sec). \ntesting (1 2 8) ... 2.204 (sec). Improved from the best result by parent (1 1 8): 2.212.\ntesting (2 1 8) ... 2.208 (sec). Improved from the best result by parent (1 1 8): 2.212.\ntesting (1 2 16) ... 2.228 (sec). \ntesting (1 4 8) ... 2.224 (sec). \ntesting (2 2 8) ... 2.28 (sec). \ntesting (2 1 16) ... 2.328 (sec). \ntesting (4 1 8) ... 2.24 (sec). \ntesting (1 4 1) ... 2.576 (sec). \ntesting (2 2 1) ... 2.58 (sec). \n((1 2 8) . 2.204)\n```\n", "tags": ["lisp", "\u884c\u5217", "\u30c1\u30e5\u30fc\u30cb\u30f3\u30b0"]}