{"context": " More than 1 year has passed since last update.\u4e2d\u8eab\u304c\u7a7a\u3063\u307d\u3060\u3063\u305f\u3089\u5f85\u3064\u3060\u3051\u306e\u30d9\u30fc\u30b7\u30c3\u30af\u306a\u4e26\u884c\u30ad\u30e5\u30fc\u3002\ncondition\u3092\u6b63\u3057\u304f\u4f7f\u3046\u70ba\u306b\u6bce\u56decondition\u306e\u4f7f\u3044\u65b9\u30b0\u30b0\u308b\u306e\u304c\u9762\u5012\u304f\u3055\u3044\u306e\u3067\u3053\u3053\u306b\u7f6e\u3044\u3066\u304a\u304f\u3002\n#ifndef BLOCKING_QUEUE_HPP_\n#define BLOCKING_QUEUE_HPP_\n#include <boost/thread.hpp>\n#include <queue>\n\ntemplate <typename T>\nclass blocking_queue {\npublic:\n  blocking_queue() {}\n  void enqueue(const T& item) {\n    {\n      boost::mutex::scoped_lock lk(lk_);\n      const bool was_empty = queue_.empty();\n      queue_.push(item);\n      if (was_empty) {\n        empty_wait_.notify_all();  // notify_one() may be suitable?\n      }\n    }\n  }\n\n  T dequeue() {\n    while (true) {\n      boost::mutex::scoped_lock lk(lk_);\n      if (queue_.empty()) {  // if empty\n        empty_wait_.wait(lk);  // unlock\n        //  relock\n      }\n      if (queue_.empty()) {\n        continue;\n      }\n\n      T result = queue_.front();\n      queue_.pop();\n      return result;\n    }\n  }\n\n  size_t size() const {\n    boost::mutex::scoped_lock lk(lk_);\n    return queue_.size();\n  }\n\nprivate:\n  mutable boost::mutex lk_;\n  mutable boost::condition_variable empty_wait_;\n  std::queue<T> queue_;\n};\n#endif  // BLOCKING_QUEUE_HPP_\n\n\u5185\u90e8\u3092\u3082\u3063\u3068\u30b9\u30b1\u30fc\u30e9\u30d6\u30eb\u306a\u69cb\u9020\u306b\u3057\u305f\u308a\u3001\u3053\u306e\u30c7\u30fc\u30bf\u69cb\u9020\u3092\u8907\u6570\u4f7f\u3063\u3066Multi Lane\u4f5c\u308b\u3082\u3088\u3057\u3002\n\u4e2d\u8eab\u304c\u7a7a\u3063\u307d\u3060\u3063\u305f\u3089\u5f85\u3064\u3060\u3051\u306e\u30d9\u30fc\u30b7\u30c3\u30af\u306a\u4e26\u884c\u30ad\u30e5\u30fc\u3002\ncondition\u3092\u6b63\u3057\u304f\u4f7f\u3046\u70ba\u306b\u6bce\u56decondition\u306e\u4f7f\u3044\u65b9\u30b0\u30b0\u308b\u306e\u304c\u9762\u5012\u304f\u3055\u3044\u306e\u3067\u3053\u3053\u306b\u7f6e\u3044\u3066\u304a\u304f\u3002\n\n```cpp:\n#ifndef BLOCKING_QUEUE_HPP_\n#define BLOCKING_QUEUE_HPP_\n#include <boost/thread.hpp>\n#include <queue>\n\ntemplate <typename T>\nclass blocking_queue {\npublic:\n  blocking_queue() {}\n  void enqueue(const T& item) {\n    {\n      boost::mutex::scoped_lock lk(lk_);\n      const bool was_empty = queue_.empty();\n      queue_.push(item);\n      if (was_empty) {\n        empty_wait_.notify_all();  // notify_one() may be suitable?\n      }\n    }\n  }\n\n  T dequeue() {\n    while (true) {\n      boost::mutex::scoped_lock lk(lk_);\n      if (queue_.empty()) {  // if empty\n        empty_wait_.wait(lk);  // unlock\n        //  relock\n      }\n      if (queue_.empty()) {\n        continue;\n      }\n\n      T result = queue_.front();\n      queue_.pop();\n      return result;\n    }\n  }\n\n  size_t size() const {\n    boost::mutex::scoped_lock lk(lk_);\n    return queue_.size();\n  }\n\nprivate:\n  mutable boost::mutex lk_;\n  mutable boost::condition_variable empty_wait_;\n  std::queue<T> queue_;\n};\n#endif  // BLOCKING_QUEUE_HPP_\n```\n\n\u5185\u90e8\u3092\u3082\u3063\u3068\u30b9\u30b1\u30fc\u30e9\u30d6\u30eb\u306a\u69cb\u9020\u306b\u3057\u305f\u308a\u3001\u3053\u306e\u30c7\u30fc\u30bf\u69cb\u9020\u3092\u8907\u6570\u4f7f\u3063\u3066[Multi Lane](http://www.1024cores.net/home/scalable-architecture/multilane)\u4f5c\u308b\u3082\u3088\u3057\u3002", "tags": ["C++", "boost"]}