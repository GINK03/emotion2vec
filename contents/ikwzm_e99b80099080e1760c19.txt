{"tags": ["VHDL", "HDL", "sort", "Vivado", "zynq"], "context": " More than 1 year has passed since last update.\n\n\u306f\u3058\u3081\u306b\n\u30bd\u30fc\u30c8\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0\u306b Bitonic Sort \u3068\u8a00\u3046\u306e\u304c\u3042\u308b\u3088\u3046\u3067\u3059\u3002\n\u51fa\u5178\u306f\u3053\u3061\u3089(https://en.wikipedia.org/wiki/Bitonic_sorter)\u3067\u3059\u3002\n\u3061\u3087\u3063\u3068\u9762\u767d\u305d\u3046\u306a\u306e\u3067VHDL\u3067\u3053\u306e\u30cd\u30c3\u30c8\u30ef\u30fc\u30af\u3092\u8a18\u8ff0\u3057\u3066\u307f\u307e\u3057\u305f\u3002\n\u305f\u3060\u3057\u3001\u30bd\u30fc\u30c8\u3059\u308b\u30a2\u30a4\u30c6\u30e0\u306e\u6570(=n)\u304c\u5897\u3048\u308b\u3068O(n*log(n)**2)\u306e\u30aa\u30fc\u30c0\u30fc\u3067\u56de\u8def\u898f\u6a21\u304c\u5897\u3048\u307e\u3059\u3002\u3053\u3053\u3067\u7d39\u4ecb\u3059\u308bVHDL\u3067\u306f\u3001\u5358\u306b\u30cd\u30c3\u30c8\u30ef\u30fc\u30af\u3092\u4f5c\u308b\u3060\u3051\u306a\u306e\u3067\u3001\u4e00\u5ea6\u306b\u30bd\u30fc\u30c8\u3067\u304d\u308b\u30a2\u30a4\u30c6\u30e0\u6570\u306b\u9650\u308a\u304c\u3042\u308a\u307e\u3059\u3002\u3082\u3057\u5927\u91cf\u306e\u30a2\u30a4\u30c6\u30e0\u3092\u30bd\u30fc\u30c8\u3059\u308b\u5834\u5408\u306f\u3001\u30e1\u30e2\u30ea\u3092\u6d3b\u7528\u3059\u308b\u7b49\u3082\u3063\u3068\u5de5\u592b\u3059\u308b\u5fc5\u8981\u304c\u3042\u308a\u307e\u3059\u3002\n\u3042\u3068\u3001\u30e2\u30b8\u30e5\u30fc\u30eb\u3092\u518d\u5e30\u7684\u306b\u30a4\u30f3\u30b9\u30bf\u30f3\u30b9\u3057\u3066\u3044\u307e\u3059\u3002Xilinx\u793e\u306e Vivado \u3067\u306f\u30b7\u30df\u30e5\u30ec\u30fc\u30b7\u30e7\u30f3\u3068\u8ad6\u7406\u5408\u6210\u51fa\u6765\u308b\u3053\u3068\u306f\u78ba\u8a8d\u3057\u3066\u3044\u307e\u3059\u304c\u3001\u4ed6\u306e\u51e6\u7406\u7cfb\u3067\u306f\u4e0a\u624b\u304f\u3044\u304b\u306a\u3044\u304b\u3082\u3057\u308c\u307e\u305b\u3093\u3002\n\nBitonic Sort\u306e\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0\n\u3053\u3061\u3089(https://en.wikipedia.org/wiki/Bitonic_sorter)\u306b\u3001Python \u3067\u8a18\u8ff0\u3055\u308c\u305f Bitonic Sort \u306e Example code \u304c\u3042\u308a\u307e\u3059\u3002\u3053\u306e\u30b3\u30fc\u30c9\u306f\u7c21\u6f54\u3067\u5927\u5909\u308f\u304b\u308a\u3084\u3059\u304f\u3001\u3055\u3059\u304c Python \u3067\u3059\u3002\u4eca\u56de\u306f\u3001\u3053\u306e\u30b3\u30fc\u30c9\u3092\u53c2\u8003\u306b VHDL \u3067\u8a18\u8ff0\u3057\u3066\u307f\u307e\u3059\u3002\n\nbitonic_sort.py\ndef bitonic_sort(up, x):\n    if len(x) <= 1:\n        return x\n    else: \n        first = bitonic_sort(True, x[:len(x) / 2])\n        second = bitonic_sort(False, x[len(x) / 2:])\n        return bitonic_merge(up, first + second)\n\ndef bitonic_merge(up, x): \n    # assume input x is bitonic, and sorted list is returned \n    if len(x) == 1:\n        return x\n    else:\n        bitonic_compare(up, x)\n        first = bitonic_merge(up, x[:len(x) / 2])\n        second = bitonic_merge(up, x[len(x) / 2:])\n        return first + second\n\ndef bitonic_compare(up, x):\n    dist = len(x) / 2\n    for i in range(dist):  \n        if (x[i] > x[i + dist]) == up:\n            x[i], x[i + dist] = x[i + dist], x[i] #swap\n\n\n\n\u30bd\u30fc\u30b9\u30b3\u30fc\u30c9\n\u30aa\u30ea\u30b8\u30ca\u30eb\u306f\u3053\u3061\u3089https://github.com/ikwzm/bitonic_sorter\u306b\u3042\u308a\u307e\u3059\u3002\n\u3055\u3059\u304c\u306b Python \u306e\u69d8\u306b\u7c21\u6f54\u3067\u306f\u3042\u308a\u307e\u305b\u3093\u304c\u3001\u30e2\u30b8\u30e5\u30fc\u30eb\u3092\u518d\u5e30\u7684\u306b\u30a4\u30f3\u30b9\u30bf\u30f3\u30b9\u3057\u3066\u3044\u307e\u3059\u3002\n\u306a\u304a\u3001\u3053\u3061\u3089\u306e\u8a18\u4e8b(VHDL\u3067\u4e0b\u4f4d\u30d6\u30ed\u30c3\u30af\u3092\u547c\u3073\u51fa\u30592\u3064\u306e\u65b9\u6cd5)\u3067\u3082\u89e3\u8aac\u3057\u307e\u3057\u305f\u304c\u3001\u4eca\u56de\u306f\u518d\u5e30\u7684\u306b\u30a4\u30f3\u30b9\u30bf\u30f3\u30b9\u3059\u308b\u3053\u3068\u3082\u3042\u3063\u3066\u3001component\u5ba3\u8a00\u3092\u4f7f\u3063\u3066\u308b\u306e\u3067\u3001\u306a\u304a\u3055\u3089\u8a18\u8ff0\u91cf\u304c\u5897\u3048\u3066\u3044\u307e\u3059\u3002\n\n\u30e9\u30a4\u30bb\u30f3\u30b9\n\u4e8c\u6761\u9805BSD\u30e9\u30a4\u30bb\u30f3\u30b9 (2-clause BSD license) \u3067\u516c\u958b\u3057\u3066\u3044\u307e\u3059\u3002\n\nbitonic_sorter\n\nbitonic_sorter.vhd\nlibrary ieee;\nuse     ieee.std_logic_1164.all;\nentity  Bitonic_Sorter is\n    generic (\n        WORDS     :  integer :=  8;\n        WORD_BITS :  integer := 64;\n        COMP_HIGH :  integer := 63;\n        COMP_LOW  :  integer := 32;\n        INFO_BITS :  integer :=  4\n    );\n    port (\n        CLK       :  in  std_logic;\n        RST       :  in  std_logic;\n        CLR       :  in  std_logic;\n        I_SORT    :  in  std_logic;\n        I_UP      :  in  std_logic;\n        I_DATA    :  in  std_logic_vector(WORDS*WORD_BITS-1 downto 0);\n        I_INFO    :  in  std_logic_vector(      INFO_BITS-1 downto 0);\n        O_SORT    :  out std_logic;\n        O_UP      :  out std_logic;\n        O_DATA    :  out std_logic_vector(WORDS*WORD_BITS-1 downto 0);\n        O_INFO    :  out std_logic_vector(      INFO_BITS-1 downto 0)\n    );\nend Bitonic_Sorter;\nlibrary ieee;\nuse     ieee.std_logic_1164.all;\narchitecture RTL of Bitonic_Sorter is\n    component Bitonic_Sorter\n        generic (\n            WORDS     :  integer :=  1;\n            WORD_BITS :  integer := 64;\n            COMP_HIGH :  integer := 63;\n            COMP_LOW  :  integer := 32;\n            INFO_BITS :  integer :=  4\n        );\n        port (\n            CLK       :  in  std_logic;\n            RST       :  in  std_logic;\n            CLR       :  in  std_logic;\n            I_SORT    :  in  std_logic;\n            I_UP      :  in  std_logic;\n            I_DATA    :  in  std_logic_vector(WORDS*WORD_BITS-1 downto 0);\n            I_INFO    :  in  std_logic_vector(      INFO_BITS-1 downto 0);\n            O_SORT    :  out std_logic;\n            O_UP      :  out std_logic;\n            O_DATA    :  out std_logic_vector(WORDS*WORD_BITS-1 downto 0);\n            O_INFO    :  out std_logic_vector(      INFO_BITS-1 downto 0)\n        );\n    end component;\n    component Bitonic_Merge\n        generic (\n            WORDS     :  integer :=  1;\n            WORD_BITS :  integer := 64;\n            COMP_HIGH :  integer := 63;\n            COMP_LOW  :  integer := 32;\n            INFO_BITS :  integer :=  4\n        );\n        port (\n            CLK       :  in  std_logic;\n            RST       :  in  std_logic;\n            CLR       :  in  std_logic;\n            I_SORT    :  in  std_logic;\n            I_UP      :  in  std_logic;\n            I_DATA    :  in  std_logic_vector(WORDS*WORD_BITS-1 downto 0);\n            I_INFO    :  in  std_logic_vector(      INFO_BITS-1 downto 0);\n            O_SORT    :  out std_logic;\n            O_UP      :  out std_logic;\n            O_DATA    :  out std_logic_vector(WORDS*WORD_BITS-1 downto 0);\n            O_INFO    :  out std_logic_vector(      INFO_BITS-1 downto 0)\n        );\n    end component;\nbegin\n    ONE: if (WORDS <= 1) generate\n        O_DATA <= I_DATA;\n        O_INFO <= I_INFO;\n        O_SORT <= I_SORT;\n        O_UP   <= I_UP;\n    end generate;\n    ANY: if (WORDS > 1) generate\n        constant UP_POS :  integer := I_INFO'high+1;\n        signal   s_info :  std_logic_vector(    I_INFO'high+1 downto 0);\n        signal   q_info :  std_logic_vector(    I_INFO'high+1 downto 0);\n        signal   q_data :  std_logic_vector(WORDS*WORD_BITS-1 downto 0);\n        signal   q_sort :  std_logic;\n    begin\n        s_info(UP_POS      ) <= I_UP;\n        s_info(I_INFO'range) <= I_INFO;\n        FIRST : Bitonic_Sorter generic map (WORDS/2, WORD_BITS, COMP_HIGH, COMP_LOW, s_info'length)\n            port map (\n                CLK     => CLK,\n                RST     => RST,\n                CLR     => CLR,\n                I_SORT  => I_SORT,\n                I_UP    => '1',\n                I_INFO  => s_info,\n                I_DATA  => I_DATA(WORD_BITS*(WORDS/2)-1 downto WORD_BITS*0),\n                O_SORT  => q_sort,\n                O_UP    => open,\n                O_INFO  => q_info,\n                O_DATA  => q_data(WORD_BITS*(WORDS/2)-1 downto WORD_BITS*0)\n            );\n        SECOND: Bitonic_Sorter generic map (WORDS/2, WORD_BITS, COMP_HIGH, COMP_LOW, s_info'length)\n            port map (\n                CLK     => CLK,\n                RST     => RST,\n                CLR     => CLR,\n                I_SORT  => I_SORT,\n                I_UP    => '0',\n                I_INFO  => s_info,\n                I_DATA  => I_DATA(WORD_BITS*(WORDS)-1 downto WORD_BITS*(WORDS/2)),\n                O_SORT  => open,\n                O_UP    => open,\n                O_INFO  => open,\n                O_DATA  => q_data(WORD_BITS*(WORDS)-1 downto WORD_BITS*(WORDS/2))\n            );\n        MERGE : Bitonic_Merge  generic map (WORDS  , WORD_BITS, COMP_HIGH, COMP_LOW, INFO_BITS)\n            port map (\n                CLK     => CLK,\n                RST     => RST,\n                CLR     => CLR,\n                I_SORT  => q_sort,\n                I_UP    => q_info(UP_POS),\n                I_INFO  => q_info(I_INFO'range),\n                I_DATA  => q_data,\n                O_SORT  => O_SORT,\n                O_UP    => O_UP  ,\n                O_INFO  => O_INFO,\n                O_DATA  => O_DATA\n            );\n    end generate;\nend RTL;\n\n\n\nbitonic_merge\n\nbitonic_merge.vhd\nlibrary ieee;\nuse     ieee.std_logic_1164.all;\nentity  Bitonic_Merge is\n    generic (\n        WORDS     :  integer :=  1;\n        WORD_BITS :  integer := 64;\n        COMP_HIGH :  integer := 63;\n        COMP_LOW  :  integer := 32;\n        INFO_BITS :  integer :=  4\n    );\n    port (\n        CLK       :  in  std_logic;\n        RST       :  in  std_logic;\n        CLR       :  in  std_logic;\n        I_SORT    :  in  std_logic;\n        I_UP      :  in  std_logic;\n        I_DATA    :  in  std_logic_vector(WORDS*WORD_BITS-1 downto 0);\n        I_INFO    :  in  std_logic_vector(      INFO_BITS-1 downto 0);\n        O_SORT    :  out std_logic;\n        O_UP      :  out std_logic;\n        O_DATA    :  out std_logic_vector(WORDS*WORD_BITS-1 downto 0);\n        O_INFO    :  out std_logic_vector(      INFO_BITS-1 downto 0)\n    );\nend Bitonic_Merge;\nlibrary ieee;\nuse     ieee.std_logic_1164.all;\narchitecture RTL of Bitonic_Merge is\n    component Bitonic_Merge\n        generic (\n            WORDS     :  integer :=  1;\n            WORD_BITS :  integer := 64;\n            COMP_HIGH :  integer := 63;\n            COMP_LOW  :  integer := 32;\n            INFO_BITS :  integer :=  4\n        );\n        port (\n            CLK       :  in  std_logic;\n            RST       :  in  std_logic;\n            CLR       :  in  std_logic;\n            I_SORT    :  in  std_logic;\n            I_UP      :  in  std_logic;\n            I_DATA    :  in  std_logic_vector(WORDS*WORD_BITS-1 downto 0);\n            I_INFO    :  in  std_logic_vector(      INFO_BITS-1 downto 0);\n            O_SORT    :  out std_logic;\n            O_UP      :  out std_logic;\n            O_DATA    :  out std_logic_vector(WORDS*WORD_BITS-1 downto 0);\n            O_INFO    :  out std_logic_vector(      INFO_BITS-1 downto 0)\n        );\n    end component;\n    component Bitonic_Exchange\n        generic (\n            WORD_BITS :  integer := 64;\n            COMP_HIGH :  integer := 63;\n            COMP_LOW  :  integer := 32\n        );\n        port (\n            I_SORT    :  in  std_logic;\n            I_UP      :  in  std_logic;\n            I_A       :  in  std_logic_vector(WORD_BITS-1 downto 0);\n            I_B       :  in  std_logic_vector(WORD_BITS-1 downto 0);\n            O_A       :  out std_logic_vector(WORD_BITS-1 downto 0);\n            O_B       :  out std_logic_vector(WORD_BITS-1 downto 0)\n        );\n    end component;\nbegin\n    ONE: if (WORDS = 1) generate\n        O_DATA <= I_DATA;\n        O_INFO <= I_INFO;\n        O_SORT <= I_SORT;\n        O_UP   <= I_UP;\n    end generate;\n    ANY: if (WORDS > 1) generate\n        constant DIST   :  integer := WORDS / 2;\n        signal   s_data :  std_logic_vector(WORDS*WORD_BITS-1 downto 0);\n        signal   q_data :  std_logic_vector(WORDS*WORD_BITS-1 downto 0);\n        signal   q_info :  std_logic_vector(      INFO_BITS-1 downto 0);\n        signal   q_sort :  std_logic;\n        signal   q_up   :  std_logic;\n    begin\n        XCHG: for i in 0 to DIST-1 generate\n            U: Bitonic_Exchange generic map(WORD_BITS, COMP_HIGH, COMP_LOW)\n            port map (\n                I_SORT  => I_SORT,\n                I_UP    => I_UP  ,\n                I_A     => I_DATA(WORD_BITS*(i     +1)-1 downto WORD_BITS*(i     )),\n                I_B     => I_DATA(WORD_BITS*(i+DIST+1)-1 downto WORD_BITS*(i+DIST)),\n                O_A     => s_data(WORD_BITS*(i     +1)-1 downto WORD_BITS*(i     )),\n                O_B     => s_data(WORD_BITS*(i+DIST+1)-1 downto WORD_BITS*(i+DIST))\n            );\n        end generate;\n        process (CLK, RST) begin\n            if (RST = '1') then\n                    q_data <= (others => '0');\n                    q_info <= (others => '0');\n                    q_sort <= '1';\n                    q_up   <= '1';\n            elsif (CLK'event and CLK = '1') then\n                if (CLR = '1') then\n                    q_data <= (others => '0');\n                    q_info <= (others => '0');\n                    q_sort <= '1';\n                    q_up   <= '1';\n                else\n                    q_data <= s_data;\n                    q_info <= I_INFO;\n                    q_sort <= I_SORT;\n                    q_up   <= I_UP;\n                end if;\n            end if;\n        end process;\n        FIRST : Bitonic_Merge generic map (WORDS/2, WORD_BITS, COMP_HIGH, COMP_LOW, INFO_BITS)\n            port map (\n                CLK     => CLK,\n                RST     => RST,\n                CLR     => CLR,\n                I_SORT  => q_sort,\n                I_UP    => q_up,\n                I_INFO  => q_info,\n                I_DATA  => q_data(WORD_BITS*(WORDS/2)-1 downto WORD_BITS*0),\n                O_SORT  => O_SORT,\n                O_UP    => O_UP,\n                O_INFO  => O_INFO,\n                O_DATA  => O_DATA(WORD_BITS*(WORDS/2)-1 downto WORD_BITS*0)\n            );\n        SECOND: Bitonic_Merge generic map (WORDS/2, WORD_BITS, COMP_HIGH, COMP_LOW, INFO_BITS)\n            port map (\n                CLK     => CLK,\n                RST     => RST,\n                CLR     => CLR,\n                I_SORT  => q_sort,\n                I_UP    => q_up,\n                I_INFO  => q_info,\n                I_DATA  => q_data(WORD_BITS*(WORDS)-1 downto WORD_BITS*(WORDS/2)),\n                O_SORT  => open,\n                O_UP    => open,\n                O_INFO  => open,\n                O_DATA  => O_DATA(WORD_BITS*(WORDS)-1 downto WORD_BITS*(WORDS/2))\n            );\n    end generate;\nend RTL;\n\n\n\nbitonic_exchange\n\nbitonic_exchange.vhd\nlibrary ieee;\nuse     ieee.std_logic_1164.all;\nentity  Bitonic_Exchange is\n    generic (\n        WORD_BITS :  integer := 64;\n        COMP_HIGH :  integer := 63;\n        COMP_LOW  :  integer := 32\n    );\n    port (\n        I_SORT    :  in  std_logic;\n        I_UP      :  in  std_logic;\n        I_A       :  in  std_logic_vector(WORD_BITS-1 downto 0);\n        I_B       :  in  std_logic_vector(WORD_BITS-1 downto 0);\n        O_A       :  out std_logic_vector(WORD_BITS-1 downto 0);\n        O_B       :  out std_logic_vector(WORD_BITS-1 downto 0)\n    );\nend Bitonic_Exchange;\nlibrary ieee;\nuse     ieee.std_logic_1164.all;\nuse     ieee.numeric_std.all;\narchitecture RTL of Bitonic_Exchange is  \nbegin\n    process(I_SORT, I_UP, I_A, I_B)\n        variable comp_a  :  unsigned(COMP_HIGH-COMP_LOW downto 0);\n        variable comp_b  :  unsigned(COMP_HIGH-COMP_LOW downto 0);\n        variable a_gt_b  :  boolean;\n    begin\n        comp_a := unsigned(I_A(COMP_HIGH downto COMP_LOW));\n        comp_b := unsigned(I_B(COMP_HIGH downto COMP_LOW));\n        a_gt_b := (comp_a > comp_b);\n        if (I_SORT = '1' and I_UP = '1' and a_gt_b = TRUE ) or\n           (I_SORT = '1' and I_UP = '0' and a_gt_b = FALSE) then\n            O_A <= I_B;\n            O_B <= I_A;\n        else\n            O_A <= I_A;\n            O_B <= I_B;\n        end if;\n    end process;\nend RTL;\n\n\n\nVivado \u306b\u3088\u308b\u30b7\u30df\u30e5\u30ec\u30fc\u30b7\u30e7\u30f3\n\n\u30c6\u30b9\u30c8\u30d9\u30f3\u30c1\n\u975e\u5e38\u306b\u7c21\u5358\u3067\u3059\u304c\u3001\u6b21\u306e\u3088\u3046\u306a\u30c6\u30b9\u30c8\u30d9\u30f3\u30c1\u3092\u7528\u610f\u3057\u3066\u3044\u307e\u3059\u3002\u672c\u6765\u306a\u3089\u3082\u3063\u3068\u3061\u3083\u3093\u3068\u3057\u305f\u30c6\u30b9\u30c8\u30d9\u30f3\u30c1\u304c\u5fc5\u8981\u3067\u3059\u3002\n\ntest_bench_bsn.vhd\nlibrary ieee;\nuse     ieee.std_logic_1164.all;\nuse     ieee.numeric_std.all;\nuse     std.textio.all;\n-----------------------------------------------------------------------------------\n--\n-----------------------------------------------------------------------------------\nentity  TEST_BENCH_BSN is\nend     TEST_BENCH_BSN;\n-----------------------------------------------------------------------------------\n--\n-----------------------------------------------------------------------------------\narchitecture MODEL of TEST_BENCH_BSN is\n    -------------------------------------------------------------------------------\n    -- \n    -------------------------------------------------------------------------------\n    constant CLOCK_PERIOD    : time    := 10 ns;\n    constant DELAY           : time    :=  1 ns;\n    -------------------------------------------------------------------------------\n    -- \n    -------------------------------------------------------------------------------\n    constant WORDS           :  integer :=  8;\n    constant WORD_BITS       :  integer :=  8;\n    constant COMP_HIGH       :  integer :=  7;\n    constant COMP_LOW        :  integer :=  0;\n    constant INFO_BITS       :  integer :=  4;\n    -------------------------------------------------------------------------------\n    --\n    -------------------------------------------------------------------------------\n    signal   CLK             :  std_logic;\n    signal   RST             :  std_logic;\n    signal   CLR             :  std_logic;\n    signal   I_SORT          :  std_logic;\n    signal   I_UP            :  std_logic;\n    signal   I_DATA          :  std_logic_vector(WORDS*WORD_BITS-1 downto 0);\n    signal   I_INFO          :  std_logic_vector(      INFO_BITS-1 downto 0);\n    signal   O_SORT          :  std_logic;\n    signal   O_UP            :  std_logic;\n    signal   O_DATA          :  std_logic_vector(WORDS*WORD_BITS-1 downto 0);\n    signal   O_INFO          :  std_logic_vector(      INFO_BITS-1 downto 0);\n    -------------------------------------------------------------------------------\n    --\n    -------------------------------------------------------------------------------\n    component Bitonic_Sorter\n        generic (\n            WORDS     :  integer :=  1;\n            WORD_BITS :  integer := 64;\n            COMP_HIGH :  integer := 64;\n            COMP_LOW  :  integer := 32;\n            INFO_BITS :  integer :=  4\n        );\n        port (\n            CLK       :  in  std_logic;\n            RST       :  in  std_logic;\n            CLR       :  in  std_logic;\n            I_SORT    :  in  std_logic;\n            I_UP      :  in  std_logic;\n            I_DATA    :  in  std_logic_vector(WORDS*WORD_BITS-1 downto 0);\n            I_INFO    :  in  std_logic_vector(      INFO_BITS-1 downto 0);\n            O_SORT    :  out std_logic;\n            O_UP      :  out std_logic;\n            O_DATA    :  out std_logic_vector(WORDS*WORD_BITS-1 downto 0);\n            O_INFO    :  out std_logic_vector(      INFO_BITS-1 downto 0)\n        );\n    end component;\nbegin\n    -------------------------------------------------------------------------------\n    --\n    -------------------------------------------------------------------------------\n    DUT: Bitonic_Sorter                 -- \n        generic map (                   -- \n            WORDS     => WORDS        , --\n            WORD_BITS => WORD_BITS    , --\n            COMP_HIGH => COMP_HIGH    , --\n            COMP_LOW  => COMP_LOW     , --\n            INFO_BITS => INFO_BITS      --\n        )                               -- \n        port map (                      -- \n            CLK       => CLK          , -- In  :\n            RST       => RST          , -- In  :\n            CLR       => CLR          , -- In  :\n            I_SORT    => I_SORT       , -- In  :\n            I_UP      => I_UP         , -- In  :\n            I_DATA    => I_DATA       , -- In  :\n            I_INFO    => I_INFO       , -- In  :\n            O_SORT    => O_SORT       , -- Out :\n            O_UP      => O_UP         , -- Out :\n            O_DATA    => O_DATA       , -- Out :\n            O_INFO    => O_INFO         -- Out :\n        );\n    -------------------------------------------------------------------------------\n    -- \n    -------------------------------------------------------------------------------\n    process begin\n        CLK <= '0';\n        wait for CLOCK_PERIOD / 2;\n        CLK <= '1';\n        wait for CLOCK_PERIOD / 2;\n    end process;\n    -------------------------------------------------------------------------------\n    -- \n    -------------------------------------------------------------------------------\n    process\n        type      INTEGER_VECTOR  is array(0 to WORDS-1) of integer;\n        variable  src_vec         :  INTEGER_VECTOR;\n        variable  exp_vec         :  INTEGER_VECTOR;\n        ---------------------------------------------------------------------------\n        --\n        ---------------------------------------------------------------------------\n        function  TO_DATA(IVEC:INTEGER_VECTOR) return std_logic_vector is\n            variable     data :  std_logic_vector(WORDS*WORD_BITS-1 downto 0);\n        begin\n            for i in 0 to WORDS-1 loop\n                data(WORD_BITS*(i+1)-1 downto WORD_BITS*i) := std_logic_vector(to_unsigned(IVEC(i), WORD_BITS));\n            end loop;\n            return data;\n        end function;\n        ---------------------------------------------------------------------------\n        --\n        ---------------------------------------------------------------------------\n        function  TO_INTEGER_VECTOR(DATA:std_logic_vector) return INTEGER_VECTOR is\n            variable     ivec :  INTEGER_VECTOR;\n        begin\n            for i in 0 to WORDS-1 loop\n                ivec(i) := to_integer(unsigned(DATA(WORD_BITS*(i+1)-1 downto WORD_BITS*i)));\n            end loop;\n            return ivec;\n        end function;\n        ---------------------------------------------------------------------------\n        --\n        ---------------------------------------------------------------------------\n        procedure WAIT_CLK(CNT:in integer) is\n        begin\n            for i in 1 to CNT loop \n                wait until (CLK'event and CLK = '1'); \n            end loop;\n        end WAIT_CLK;\n        ---------------------------------------------------------------------------\n        --\n        ---------------------------------------------------------------------------\n        procedure TEST(SORT,UP:std_logic; SRC,EXP: INTEGER_VECTOR) is\n            variable timeout :  boolean;\n            variable result  :  INTEGER_VECTOR;\n        begin\n            I_DATA  <= TO_DATA(SRC);\n            I_INFO  <= \"1111\";\n            I_SORT  <= SORT;\n            I_UP    <= UP;\n            timeout := TRUE;\n\n            MAIN_LOOP: for i in 1 to 1000 loop\n                wait until (CLK'event and CLK = '1');\n                I_INFO <= \"0000\";\n                I_DATA <= (others => '0');\n                I_SORT <= '0';\n                I_UP   <= '0';\n                if (O_INFO = \"1111\") then\n                    timeout := FALSE;\n                    exit MAIN_LOOP;\n                end if;\n            end loop;\n            assert(timeout = FALSE) report \"Timeout...\"  severity FAILURE;\n            result := TO_INTEGER_VECTOR(O_DATA);\n            assert(result  = EXP  ) report \"Mismatch...\" severity FAILURE;\n        end procedure;\n    begin\n        ---------------------------------------------------------------------------\n        --\n        ---------------------------------------------------------------------------\n        assert(false) report \"Run Start...\" severity NOTE;\n        RST    <= '1';\n        CLR    <= '0';\n        I_DATA <= (others => '0');\n        I_INFO <= (others => '0');\n        I_SORT <= '0';\n        I_UP   <= '0';\n        WAIT_CLK(10);\n        RST    <= '0';\n        WAIT_CLK(10);\n        ---------------------------------------------------------------------------\n        --\n        ---------------------------------------------------------------------------\n        src_vec := (0 => 8, 1 => 1, 2 => 0, 3 => 6, 4 => 1, 5 => 2, 6 => 9, 7 => 1);\n        exp_vec := (0 => 8, 1 => 1, 2 => 0, 3 => 6, 4 => 1, 5 => 2, 6 => 9, 7 => 1);\n        TEST('0', '0', src_vec, exp_vec);\n        WAIT_CLK(1);\n\n        ---------------------------------------------------------------------------\n        --\n        ---------------------------------------------------------------------------\n        src_vec := (0 => 8, 1 => 1, 2 => 0, 3 => 6, 4 => 1, 5 => 2, 6 => 9, 7 => 1);\n        exp_vec := (0 => 9, 1 => 8, 2 => 6, 3 => 2, 4 => 1, 5 => 1, 6 => 1, 7 => 0);\n        TEST('1', '0', src_vec, exp_vec);\n        WAIT_CLK(1);\n\n        ---------------------------------------------------------------------------\n        --\n        ---------------------------------------------------------------------------\n        src_vec := (0 => 8, 1 => 1, 2 => 0, 3 => 6, 4 => 1, 5 => 2, 6 => 9, 7 => 1);\n        exp_vec := (0 => 0, 1 => 1, 2 => 1, 3 => 1, 4 => 2, 5 => 6, 6 => 8, 7 => 9);\n        TEST('1', '1', src_vec, exp_vec);\n\n        WAIT_CLK(10);\n        assert(false) report \"Run complete...\" severity FAILURE;\n        wait;\n    end process;\nend MODEL;\n\n\n\nVivado\u306e\u30d0\u30fc\u30b8\u30e7\u30f3\n\nXilinx Vivado 2015.4\n\n\n\u624b\u9806\n\n\u30c0\u30a6\u30f3\u30ed\u30fc\u30c9\nshell% git clone git://github.com/ikwzm/bitonic_sorter.git\n\n\nVivado\u30d7\u30ed\u30b8\u30a7\u30af\u30c8\u306e\u4f5c\u6210\nVivado \u30d7\u30ed\u30b8\u30a7\u30af\u30c8\u3092\u4f5c\u6210\u3059\u308b\u305f\u3081\u306eTcl\u30d5\u30a1\u30a4\u30eb(create_project.tcl)\u3092\u7528\u610f\u3057\u3066\u3044\u307e\u3059\u3002\nVivado \u306eTcl\u30b7\u30a7\u30eb\u3092\u4f7f\u3046\u5834\u5408\u306f\u6b21\u306e\u3088\u3046\u306b\u3057\u307e\u3059\u3002\nVivado% cd sim/vivado/bitonic_sorter\nVivado% vivado -mod batch -source create_project.tcl\n\nVivado \u306e GUI\u3092\u4f7f\u3046\u5834\u5408\u306f\u6b21\u306e\u30e1\u30cb\u30e5\u30fc\u304b\u3089Tcl\u30d5\u30a1\u30a4\u30eb\u3092\u5b9f\u884c\u3057\u3066\u304f\u3060\u3055\u3044\u3002\nVivado > Open Project > sim/vivado/bitonic_sorter/bitonic_sorter.xpr\nFlow Navigator > Run Simulation > Run Bihavioral Simulation \n\n\n\u30b7\u30df\u30e5\u30ec\u30fc\u30b7\u30e7\u30f3\u3092\u5b9f\u884c\nVivado \u30d7\u30ed\u30b8\u30a7\u30af\u30c8\u3092\u958b\u304d\u3001\u6b21\u306e\u3088\u3046\u306b\u30b7\u30df\u30e5\u30ec\u30fc\u30b7\u30e7\u30f3\u3092\u5b9f\u884c\u3057\u3066\u304f\u3060\u3055\u3044\u3002\nVivado > Open Project > sim/vivado/bitonic_sorter/bitonic_sorter.xpr\nFlow Navigator > Run Simulation > Run Bihavioral Simulation \n\n\nVivado \u306b\u3088\u308b\u8ad6\u7406\u5408\u6210\uff06\u30a4\u30f3\u30d7\u30ea\u30e1\u30f3\u30c6\u30fc\u30b7\u30e7\u30f3\n\n\u958b\u767a\u30c4\u30fc\u30eb\u3068\u5bfe\u8c61\u30c7\u30d0\u30a4\u30b9\n\nXilinx Vivado 2015.4\nXilinx Zynq7020-1 (xc7z020clg400-1)\n\n\n\u30e9\u30c3\u30d1\u30fc\u56de\u8def\nbionic_sorter \u3092\u6700\u4e0a\u4f4d\u30e2\u30b8\u30e5\u30fc\u30eb\u306b\u3059\u308b\u3068 I/O \u304c\u8db3\u308a\u306a\u304f\u306a\u308b\u4e0a\u306b\u3001Vivado \u306e\u554f\u984c\u306a\u306e\u304b\u518d\u5e30\u7684\u306b\u30a4\u30f3\u30b9\u30bf\u30f3\u30b9\u3057\u3066\u3044\u308b\u3068\u968e\u5c64\u69cb\u9020\u3092\u3046\u307e\u304f\u8a8d\u8b58\u51fa\u6765\u306a\u3044\u3088\u3046\u3067 bionic_sorter\u3092\u30c8\u30c3\u30d7\u30ec\u30d9\u30eb\u306b\u8a2d\u5b9a\u3067\u304d\u307e\u305b\u3093\u3002\u305d\u3053\u3067\u6b21\u306e\u3088\u3046\u306a\u30e9\u30c3\u30d1\u30fc\u30e2\u30b8\u30e5\u30fc\u30eb\u3092\u7528\u610f\u3057\u3066\u3044\u307e\u3059\u3002\n\u30bd\u30fc\u30c8\u3059\u308b\u30a2\u30a4\u30c6\u30e0\u6570(=WORDS)\u30924,8,16,32\u3067\u5408\u6210\u3057\u3066\u307f\u307e\u3057\u305f\u3002\n\nbitonic_sorter_wrapper.vhd\nlibrary ieee;\nuse     ieee.std_logic_1164.all;\nentity  Bitonic_Sorter_Wrapper is\n    generic (\n        WORDS     :  integer :=  8;\n        WORD_BITS :  integer := 32;\n        COMP_HIGH :  integer := 31;\n        COMP_LOW  :  integer :=  0;\n        INFO_BITS :  integer :=  4\n    );\n    port (\n        CLK       :  in  std_logic;\n        RST       :  in  std_logic;\n        CLR       :  in  std_logic;\n        I_SORT    :  in  std_logic;\n        I_UP      :  in  std_logic;\n        I_ADDR    :  in  integer range 0 to WORDS-1;\n        I_DATA    :  in  std_logic_vector(WORD_BITS-1 downto 0);\n        I_INFO    :  in  std_logic_vector(INFO_BITS-1 downto 0);\n        O_ADDR    :  in  integer range 0 to WORDS-1;\n        O_DATA    :  out std_logic_vector(WORD_BITS-1 downto 0);\n        O_INFO    :  out std_logic_vector(INFO_BITS-1 downto 0)\n    );\nend Bitonic_Sorter_Wrapper;\nlibrary ieee;\nuse     ieee.std_logic_1164.all;\nuse     ieee.numeric_std.all;\narchitecture RTL of Bitonic_Sorter_Wrapper is\n    component Bitonic_Sorter\n        generic (\n            WORDS     :  integer :=  1;\n            WORD_BITS :  integer := 64;\n            COMP_HIGH :  integer := 64;\n            COMP_LOW  :  integer := 32;\n            INFO_BITS :  integer :=  4\n        );\n        port (\n            CLK       :  in  std_logic;\n            RST       :  in  std_logic;\n            CLR       :  in  std_logic;\n            I_SORT    :  in  std_logic;\n            I_UP      :  in  std_logic;\n            I_DATA    :  in  std_logic_vector(WORDS*WORD_BITS-1 downto 0);\n            I_INFO    :  in  std_logic_vector(      INFO_BITS-1 downto 0);\n            O_SORT    :  out std_logic;\n            O_UP      :  out std_logic;\n            O_DATA    :  out std_logic_vector(WORDS*WORD_BITS-1 downto 0);\n            O_INFO    :  out std_logic_vector(      INFO_BITS-1 downto 0)\n        );\n    end component;\n    signal  s_data    :  std_logic_vector(WORDS*WORD_BITS-1 downto 0);\n    signal  q_data    :  std_logic_vector(WORDS*WORD_BITS-1 downto 0);\nbegin\n    process(CLK, RST) begin\n        if (RST = '1') then\n                s_data <= (others => '0');\n        elsif (CLK'event and CLK = '1') then\n            if (CLR = '1') then\n                s_data <= (others => '0');\n            else\n                for i in 0 to WORDS-1 loop\n                    if (I_ADDR = i) then\n                        s_data(WORD_BITS*(i+1)-1 downto WORD_BITS*i) <= I_DATA;\n                    end if;\n                end loop;\n            end if;\n        end if;\n    end process;\n    U: Bitonic_Sorter\n        generic map (\n            WORDS     => WORDS     , -- \n            WORD_BITS => WORD_BITS , -- \n            COMP_HIGH => COMP_HIGH , -- \n            COMP_LOW  => COMP_LOW  , -- \n            INFO_BITS => INFO_BITS   -- \n        )\n        port map (\n            CLK       => CLK       , -- \n            RST       => RST       , -- \n            CLR       => CLR       , -- \n            I_SORT    => I_SORT    , -- \n            I_UP      => I_UP      , -- \n            I_DATA    => s_data    , -- \n            I_INFO    => I_INFO    , -- \n            O_SORT    => open      , -- \n            O_UP      => open      , -- \n            O_DATA    => q_data    , -- \n            O_INFO    => O_INFO      -- \n        );\n    process(CLK, RST) begin\n        if (RST = '1') then\n                O_DATA <= (others => '0');\n        elsif (CLK'event and CLK = '1') then\n            if (CLR = '1') then\n                O_DATA <= (others => '0');\n            else\n                for i in 0 to WORDS-1 loop\n                    if (O_ADDR = i) then\n                        O_DATA <= q_data(WORD_BITS*(i+1)-1 downto WORD_BITS*i);\n                    end if;\n                end loop;\n            end if;\n        end if;\n    end process;\nend RTL;\n\n\n\n\u624b\u9806\n\n\u30c0\u30a6\u30f3\u30ed\u30fc\u30c9\nshell% git clone git://github.com/ikwzm/bitonic_sorter.git\n\n\nVivado\u30d7\u30ed\u30b8\u30a7\u30af\u30c8\u306e\u4f5c\u6210\n\u4eca\u56de\u306f\u3061\u3087\u3063\u3068\u624b\u3092\u629c\u3044\u3066\u3001Vivado\u30b7\u30df\u30e5\u30ec\u30fc\u30b7\u30e7\u30f3\u306e\u30d7\u30ed\u30b8\u30a7\u30af\u30c8\u3092\u9593\u501f\u308a\u3057\u3066\u3044\u307e\u3059\u3002\n\u30d7\u30ed\u30b8\u30a7\u30af\u30c8\u306e\u4f5c\u308a\u65b9\u306f\u305d\u3061\u3089\u3092\u53c2\u7167\u3057\u3066\u304f\u3060\u3055\u3044\u3002\n\n\u8ad6\u7406\u5408\u6210\u3068\u30a4\u30f3\u30d7\u30ea\u30e1\u30f3\u30c6\u30fc\u30b7\u30e7\u30f3\nVivado\u3092\u8d77\u52d5\u3057\u3066\u30d7\u30ed\u30b8\u30a7\u30af\u30c8\u3092\u958b\u304d\u3001\u30a4\u30f3\u30d7\u30ea\u30e1\u30f3\u30c6\u30fc\u30b7\u30e7\u30f3\u3092\u5b9f\u884c\u3057\u307e\u3059\u3002\nVivado > Open Project > sim/vivado/bitonic_sorter/bitonic_sorter.xpr\nFlow Navigator > Run Implementation\n\n\n\u7d50\u679c\n\n\n\nWORDS\nSlice LUTs\nSlice Registers\nSlice\n\n\n\n\n4\n252\n70\n87\n\n\n8\n2061\n1585\n545\n\n\n16\n6658\n5247\n1746\n\n\n32\n19715\n15684\n5228\n\n\n\n\u6b8b\u5ff5\u306a\u304c\u3089\u3001Zynq7020\u30af\u30e9\u30b9\u3060\u3068\u3001\u305b\u3044\u305c\u304432\u30a2\u30a4\u30c6\u30e0\u306e\u30bd\u30fc\u30c8\u3057\u304b\u51fa\u6765\u307e\u305b\u3093\u3002\n\u3061\u306a\u307f\u306b\u52d5\u4f5c\u5468\u6ce2\u6570\u306f200MHz\u3067\u3059\u3002\n##\u306f\u3058\u3081\u306b\n\n\u30bd\u30fc\u30c8\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0\u306b Bitonic Sort \u3068\u8a00\u3046\u306e\u304c\u3042\u308b\u3088\u3046\u3067\u3059\u3002\n\u51fa\u5178\u306f[\u3053\u3061\u3089(https://en.wikipedia.org/wiki/Bitonic_sorter)](https://en.wikipedia.org/wiki/Bitonic_sorter)\u3067\u3059\u3002\n\u3061\u3087\u3063\u3068\u9762\u767d\u305d\u3046\u306a\u306e\u3067VHDL\u3067\u3053\u306e\u30cd\u30c3\u30c8\u30ef\u30fc\u30af\u3092\u8a18\u8ff0\u3057\u3066\u307f\u307e\u3057\u305f\u3002\n\n\u305f\u3060\u3057\u3001\u30bd\u30fc\u30c8\u3059\u308b\u30a2\u30a4\u30c6\u30e0\u306e\u6570(=n)\u304c\u5897\u3048\u308b\u3068O(n*log(n)**2)\u306e\u30aa\u30fc\u30c0\u30fc\u3067\u56de\u8def\u898f\u6a21\u304c\u5897\u3048\u307e\u3059\u3002\u3053\u3053\u3067\u7d39\u4ecb\u3059\u308bVHDL\u3067\u306f\u3001\u5358\u306b\u30cd\u30c3\u30c8\u30ef\u30fc\u30af\u3092\u4f5c\u308b\u3060\u3051\u306a\u306e\u3067\u3001\u4e00\u5ea6\u306b\u30bd\u30fc\u30c8\u3067\u304d\u308b\u30a2\u30a4\u30c6\u30e0\u6570\u306b\u9650\u308a\u304c\u3042\u308a\u307e\u3059\u3002\u3082\u3057\u5927\u91cf\u306e\u30a2\u30a4\u30c6\u30e0\u3092\u30bd\u30fc\u30c8\u3059\u308b\u5834\u5408\u306f\u3001\u30e1\u30e2\u30ea\u3092\u6d3b\u7528\u3059\u308b\u7b49\u3082\u3063\u3068\u5de5\u592b\u3059\u308b\u5fc5\u8981\u304c\u3042\u308a\u307e\u3059\u3002\n\n\u3042\u3068\u3001\u30e2\u30b8\u30e5\u30fc\u30eb\u3092\u518d\u5e30\u7684\u306b\u30a4\u30f3\u30b9\u30bf\u30f3\u30b9\u3057\u3066\u3044\u307e\u3059\u3002Xilinx\u793e\u306e Vivado \u3067\u306f\u30b7\u30df\u30e5\u30ec\u30fc\u30b7\u30e7\u30f3\u3068\u8ad6\u7406\u5408\u6210\u51fa\u6765\u308b\u3053\u3068\u306f\u78ba\u8a8d\u3057\u3066\u3044\u307e\u3059\u304c\u3001\u4ed6\u306e\u51e6\u7406\u7cfb\u3067\u306f\u4e0a\u624b\u304f\u3044\u304b\u306a\u3044\u304b\u3082\u3057\u308c\u307e\u305b\u3093\u3002\n\n\n##Bitonic Sort\u306e\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0\n\n[\u3053\u3061\u3089(https://en.wikipedia.org/wiki/Bitonic_sorter)](https://en.wikipedia.org/wiki/Bitonic_sorter)\u306b\u3001Python \u3067\u8a18\u8ff0\u3055\u308c\u305f Bitonic Sort \u306e Example code \u304c\u3042\u308a\u307e\u3059\u3002\u3053\u306e\u30b3\u30fc\u30c9\u306f\u7c21\u6f54\u3067\u5927\u5909\u308f\u304b\u308a\u3084\u3059\u304f\u3001\u3055\u3059\u304c Python \u3067\u3059\u3002\u4eca\u56de\u306f\u3001\u3053\u306e\u30b3\u30fc\u30c9\u3092\u53c2\u8003\u306b VHDL \u3067\u8a18\u8ff0\u3057\u3066\u307f\u307e\u3059\u3002\n\n````Python:bitonic_sort.py\ndef bitonic_sort(up, x):\n    if len(x) <= 1:\n        return x\n    else: \n        first = bitonic_sort(True, x[:len(x) / 2])\n        second = bitonic_sort(False, x[len(x) / 2:])\n        return bitonic_merge(up, first + second)\n\ndef bitonic_merge(up, x): \n    # assume input x is bitonic, and sorted list is returned \n    if len(x) == 1:\n        return x\n    else:\n        bitonic_compare(up, x)\n        first = bitonic_merge(up, x[:len(x) / 2])\n        second = bitonic_merge(up, x[len(x) / 2:])\n        return first + second\n\ndef bitonic_compare(up, x):\n    dist = len(x) / 2\n    for i in range(dist):  \n        if (x[i] > x[i + dist]) == up:\n            x[i], x[i + dist] = x[i + dist], x[i] #swap\n````\n\n##\u30bd\u30fc\u30b9\u30b3\u30fc\u30c9\n\n\u30aa\u30ea\u30b8\u30ca\u30eb\u306f[\u3053\u3061\u3089https://github.com/ikwzm/bitonic_sorter](https://github.com/ikwzm/bitonic_sorter)\u306b\u3042\u308a\u307e\u3059\u3002\n\u3055\u3059\u304c\u306b Python \u306e\u69d8\u306b\u7c21\u6f54\u3067\u306f\u3042\u308a\u307e\u305b\u3093\u304c\u3001\u30e2\u30b8\u30e5\u30fc\u30eb\u3092\u518d\u5e30\u7684\u306b\u30a4\u30f3\u30b9\u30bf\u30f3\u30b9\u3057\u3066\u3044\u307e\u3059\u3002\n\u306a\u304a\u3001[\u3053\u3061\u3089\u306e\u8a18\u4e8b(VHDL\u3067\u4e0b\u4f4d\u30d6\u30ed\u30c3\u30af\u3092\u547c\u3073\u51fa\u30592\u3064\u306e\u65b9\u6cd5)](http://qiita.com/ikwzm/items/21bbcfe21f97cbd29b8a)\u3067\u3082\u89e3\u8aac\u3057\u307e\u3057\u305f\u304c\u3001\u4eca\u56de\u306f\u518d\u5e30\u7684\u306b\u30a4\u30f3\u30b9\u30bf\u30f3\u30b9\u3059\u308b\u3053\u3068\u3082\u3042\u3063\u3066\u3001component\u5ba3\u8a00\u3092\u4f7f\u3063\u3066\u308b\u306e\u3067\u3001\u306a\u304a\u3055\u3089\u8a18\u8ff0\u91cf\u304c\u5897\u3048\u3066\u3044\u307e\u3059\u3002\n\n###\u30e9\u30a4\u30bb\u30f3\u30b9\n\n\u4e8c\u6761\u9805BSD\u30e9\u30a4\u30bb\u30f3\u30b9 (2-clause BSD license) \u3067\u516c\u958b\u3057\u3066\u3044\u307e\u3059\u3002\n\n###bitonic_sorter\n\n````VHDL:bitonic_sorter.vhd\nlibrary ieee;\nuse     ieee.std_logic_1164.all;\nentity  Bitonic_Sorter is\n    generic (\n        WORDS     :  integer :=  8;\n        WORD_BITS :  integer := 64;\n        COMP_HIGH :  integer := 63;\n        COMP_LOW  :  integer := 32;\n        INFO_BITS :  integer :=  4\n    );\n    port (\n        CLK       :  in  std_logic;\n        RST       :  in  std_logic;\n        CLR       :  in  std_logic;\n        I_SORT    :  in  std_logic;\n        I_UP      :  in  std_logic;\n        I_DATA    :  in  std_logic_vector(WORDS*WORD_BITS-1 downto 0);\n        I_INFO    :  in  std_logic_vector(      INFO_BITS-1 downto 0);\n        O_SORT    :  out std_logic;\n        O_UP      :  out std_logic;\n        O_DATA    :  out std_logic_vector(WORDS*WORD_BITS-1 downto 0);\n        O_INFO    :  out std_logic_vector(      INFO_BITS-1 downto 0)\n    );\nend Bitonic_Sorter;\nlibrary ieee;\nuse     ieee.std_logic_1164.all;\narchitecture RTL of Bitonic_Sorter is\n    component Bitonic_Sorter\n        generic (\n            WORDS     :  integer :=  1;\n            WORD_BITS :  integer := 64;\n            COMP_HIGH :  integer := 63;\n            COMP_LOW  :  integer := 32;\n            INFO_BITS :  integer :=  4\n        );\n        port (\n            CLK       :  in  std_logic;\n            RST       :  in  std_logic;\n            CLR       :  in  std_logic;\n            I_SORT    :  in  std_logic;\n            I_UP      :  in  std_logic;\n            I_DATA    :  in  std_logic_vector(WORDS*WORD_BITS-1 downto 0);\n            I_INFO    :  in  std_logic_vector(      INFO_BITS-1 downto 0);\n            O_SORT    :  out std_logic;\n            O_UP      :  out std_logic;\n            O_DATA    :  out std_logic_vector(WORDS*WORD_BITS-1 downto 0);\n            O_INFO    :  out std_logic_vector(      INFO_BITS-1 downto 0)\n        );\n    end component;\n    component Bitonic_Merge\n        generic (\n            WORDS     :  integer :=  1;\n            WORD_BITS :  integer := 64;\n            COMP_HIGH :  integer := 63;\n            COMP_LOW  :  integer := 32;\n            INFO_BITS :  integer :=  4\n        );\n        port (\n            CLK       :  in  std_logic;\n            RST       :  in  std_logic;\n            CLR       :  in  std_logic;\n            I_SORT    :  in  std_logic;\n            I_UP      :  in  std_logic;\n            I_DATA    :  in  std_logic_vector(WORDS*WORD_BITS-1 downto 0);\n            I_INFO    :  in  std_logic_vector(      INFO_BITS-1 downto 0);\n            O_SORT    :  out std_logic;\n            O_UP      :  out std_logic;\n            O_DATA    :  out std_logic_vector(WORDS*WORD_BITS-1 downto 0);\n            O_INFO    :  out std_logic_vector(      INFO_BITS-1 downto 0)\n        );\n    end component;\nbegin\n    ONE: if (WORDS <= 1) generate\n        O_DATA <= I_DATA;\n        O_INFO <= I_INFO;\n        O_SORT <= I_SORT;\n        O_UP   <= I_UP;\n    end generate;\n    ANY: if (WORDS > 1) generate\n        constant UP_POS :  integer := I_INFO'high+1;\n        signal   s_info :  std_logic_vector(    I_INFO'high+1 downto 0);\n        signal   q_info :  std_logic_vector(    I_INFO'high+1 downto 0);\n        signal   q_data :  std_logic_vector(WORDS*WORD_BITS-1 downto 0);\n        signal   q_sort :  std_logic;\n    begin\n        s_info(UP_POS      ) <= I_UP;\n        s_info(I_INFO'range) <= I_INFO;\n        FIRST : Bitonic_Sorter generic map (WORDS/2, WORD_BITS, COMP_HIGH, COMP_LOW, s_info'length)\n            port map (\n                CLK     => CLK,\n                RST     => RST,\n                CLR     => CLR,\n                I_SORT  => I_SORT,\n                I_UP    => '1',\n                I_INFO  => s_info,\n                I_DATA  => I_DATA(WORD_BITS*(WORDS/2)-1 downto WORD_BITS*0),\n                O_SORT  => q_sort,\n                O_UP    => open,\n                O_INFO  => q_info,\n                O_DATA  => q_data(WORD_BITS*(WORDS/2)-1 downto WORD_BITS*0)\n            );\n        SECOND: Bitonic_Sorter generic map (WORDS/2, WORD_BITS, COMP_HIGH, COMP_LOW, s_info'length)\n            port map (\n                CLK     => CLK,\n                RST     => RST,\n                CLR     => CLR,\n                I_SORT  => I_SORT,\n                I_UP    => '0',\n                I_INFO  => s_info,\n                I_DATA  => I_DATA(WORD_BITS*(WORDS)-1 downto WORD_BITS*(WORDS/2)),\n                O_SORT  => open,\n                O_UP    => open,\n                O_INFO  => open,\n                O_DATA  => q_data(WORD_BITS*(WORDS)-1 downto WORD_BITS*(WORDS/2))\n            );\n        MERGE : Bitonic_Merge  generic map (WORDS  , WORD_BITS, COMP_HIGH, COMP_LOW, INFO_BITS)\n            port map (\n                CLK     => CLK,\n                RST     => RST,\n                CLR     => CLR,\n                I_SORT  => q_sort,\n                I_UP    => q_info(UP_POS),\n                I_INFO  => q_info(I_INFO'range),\n                I_DATA  => q_data,\n                O_SORT  => O_SORT,\n                O_UP    => O_UP  ,\n                O_INFO  => O_INFO,\n                O_DATA  => O_DATA\n            );\n    end generate;\nend RTL;\n````\n###bitonic_merge\n\n````VHDL:bitonic_merge.vhd\nlibrary ieee;\nuse     ieee.std_logic_1164.all;\nentity  Bitonic_Merge is\n    generic (\n        WORDS     :  integer :=  1;\n        WORD_BITS :  integer := 64;\n        COMP_HIGH :  integer := 63;\n        COMP_LOW  :  integer := 32;\n        INFO_BITS :  integer :=  4\n    );\n    port (\n        CLK       :  in  std_logic;\n        RST       :  in  std_logic;\n        CLR       :  in  std_logic;\n        I_SORT    :  in  std_logic;\n        I_UP      :  in  std_logic;\n        I_DATA    :  in  std_logic_vector(WORDS*WORD_BITS-1 downto 0);\n        I_INFO    :  in  std_logic_vector(      INFO_BITS-1 downto 0);\n        O_SORT    :  out std_logic;\n        O_UP      :  out std_logic;\n        O_DATA    :  out std_logic_vector(WORDS*WORD_BITS-1 downto 0);\n        O_INFO    :  out std_logic_vector(      INFO_BITS-1 downto 0)\n    );\nend Bitonic_Merge;\nlibrary ieee;\nuse     ieee.std_logic_1164.all;\narchitecture RTL of Bitonic_Merge is\n    component Bitonic_Merge\n        generic (\n            WORDS     :  integer :=  1;\n            WORD_BITS :  integer := 64;\n            COMP_HIGH :  integer := 63;\n            COMP_LOW  :  integer := 32;\n            INFO_BITS :  integer :=  4\n        );\n        port (\n            CLK       :  in  std_logic;\n            RST       :  in  std_logic;\n            CLR       :  in  std_logic;\n            I_SORT    :  in  std_logic;\n            I_UP      :  in  std_logic;\n            I_DATA    :  in  std_logic_vector(WORDS*WORD_BITS-1 downto 0);\n            I_INFO    :  in  std_logic_vector(      INFO_BITS-1 downto 0);\n            O_SORT    :  out std_logic;\n            O_UP      :  out std_logic;\n            O_DATA    :  out std_logic_vector(WORDS*WORD_BITS-1 downto 0);\n            O_INFO    :  out std_logic_vector(      INFO_BITS-1 downto 0)\n        );\n    end component;\n    component Bitonic_Exchange\n        generic (\n            WORD_BITS :  integer := 64;\n            COMP_HIGH :  integer := 63;\n            COMP_LOW  :  integer := 32\n        );\n        port (\n            I_SORT    :  in  std_logic;\n            I_UP      :  in  std_logic;\n            I_A       :  in  std_logic_vector(WORD_BITS-1 downto 0);\n            I_B       :  in  std_logic_vector(WORD_BITS-1 downto 0);\n            O_A       :  out std_logic_vector(WORD_BITS-1 downto 0);\n            O_B       :  out std_logic_vector(WORD_BITS-1 downto 0)\n        );\n    end component;\nbegin\n    ONE: if (WORDS = 1) generate\n        O_DATA <= I_DATA;\n        O_INFO <= I_INFO;\n        O_SORT <= I_SORT;\n        O_UP   <= I_UP;\n    end generate;\n    ANY: if (WORDS > 1) generate\n        constant DIST   :  integer := WORDS / 2;\n        signal   s_data :  std_logic_vector(WORDS*WORD_BITS-1 downto 0);\n        signal   q_data :  std_logic_vector(WORDS*WORD_BITS-1 downto 0);\n        signal   q_info :  std_logic_vector(      INFO_BITS-1 downto 0);\n        signal   q_sort :  std_logic;\n        signal   q_up   :  std_logic;\n    begin\n        XCHG: for i in 0 to DIST-1 generate\n            U: Bitonic_Exchange generic map(WORD_BITS, COMP_HIGH, COMP_LOW)\n            port map (\n                I_SORT  => I_SORT,\n                I_UP    => I_UP  ,\n                I_A     => I_DATA(WORD_BITS*(i     +1)-1 downto WORD_BITS*(i     )),\n                I_B     => I_DATA(WORD_BITS*(i+DIST+1)-1 downto WORD_BITS*(i+DIST)),\n                O_A     => s_data(WORD_BITS*(i     +1)-1 downto WORD_BITS*(i     )),\n                O_B     => s_data(WORD_BITS*(i+DIST+1)-1 downto WORD_BITS*(i+DIST))\n            );\n        end generate;\n        process (CLK, RST) begin\n            if (RST = '1') then\n                    q_data <= (others => '0');\n                    q_info <= (others => '0');\n                    q_sort <= '1';\n                    q_up   <= '1';\n            elsif (CLK'event and CLK = '1') then\n                if (CLR = '1') then\n                    q_data <= (others => '0');\n                    q_info <= (others => '0');\n                    q_sort <= '1';\n                    q_up   <= '1';\n                else\n                    q_data <= s_data;\n                    q_info <= I_INFO;\n                    q_sort <= I_SORT;\n                    q_up   <= I_UP;\n                end if;\n            end if;\n        end process;\n        FIRST : Bitonic_Merge generic map (WORDS/2, WORD_BITS, COMP_HIGH, COMP_LOW, INFO_BITS)\n            port map (\n                CLK     => CLK,\n                RST     => RST,\n                CLR     => CLR,\n                I_SORT  => q_sort,\n                I_UP    => q_up,\n                I_INFO  => q_info,\n                I_DATA  => q_data(WORD_BITS*(WORDS/2)-1 downto WORD_BITS*0),\n                O_SORT  => O_SORT,\n                O_UP    => O_UP,\n                O_INFO  => O_INFO,\n                O_DATA  => O_DATA(WORD_BITS*(WORDS/2)-1 downto WORD_BITS*0)\n            );\n        SECOND: Bitonic_Merge generic map (WORDS/2, WORD_BITS, COMP_HIGH, COMP_LOW, INFO_BITS)\n            port map (\n                CLK     => CLK,\n                RST     => RST,\n                CLR     => CLR,\n                I_SORT  => q_sort,\n                I_UP    => q_up,\n                I_INFO  => q_info,\n                I_DATA  => q_data(WORD_BITS*(WORDS)-1 downto WORD_BITS*(WORDS/2)),\n                O_SORT  => open,\n                O_UP    => open,\n                O_INFO  => open,\n                O_DATA  => O_DATA(WORD_BITS*(WORDS)-1 downto WORD_BITS*(WORDS/2))\n            );\n    end generate;\nend RTL;\n````\n###bitonic_exchange\n\n````VHDL:bitonic_exchange.vhd\nlibrary ieee;\nuse     ieee.std_logic_1164.all;\nentity  Bitonic_Exchange is\n    generic (\n        WORD_BITS :  integer := 64;\n        COMP_HIGH :  integer := 63;\n        COMP_LOW  :  integer := 32\n    );\n    port (\n        I_SORT    :  in  std_logic;\n        I_UP      :  in  std_logic;\n        I_A       :  in  std_logic_vector(WORD_BITS-1 downto 0);\n        I_B       :  in  std_logic_vector(WORD_BITS-1 downto 0);\n        O_A       :  out std_logic_vector(WORD_BITS-1 downto 0);\n        O_B       :  out std_logic_vector(WORD_BITS-1 downto 0)\n    );\nend Bitonic_Exchange;\nlibrary ieee;\nuse     ieee.std_logic_1164.all;\nuse     ieee.numeric_std.all;\narchitecture RTL of Bitonic_Exchange is  \nbegin\n    process(I_SORT, I_UP, I_A, I_B)\n        variable comp_a  :  unsigned(COMP_HIGH-COMP_LOW downto 0);\n        variable comp_b  :  unsigned(COMP_HIGH-COMP_LOW downto 0);\n        variable a_gt_b  :  boolean;\n    begin\n        comp_a := unsigned(I_A(COMP_HIGH downto COMP_LOW));\n        comp_b := unsigned(I_B(COMP_HIGH downto COMP_LOW));\n        a_gt_b := (comp_a > comp_b);\n        if (I_SORT = '1' and I_UP = '1' and a_gt_b = TRUE ) or\n           (I_SORT = '1' and I_UP = '0' and a_gt_b = FALSE) then\n            O_A <= I_B;\n            O_B <= I_A;\n        else\n            O_A <= I_A;\n            O_B <= I_B;\n        end if;\n    end process;\nend RTL;\n````\n\n##Vivado \u306b\u3088\u308b\u30b7\u30df\u30e5\u30ec\u30fc\u30b7\u30e7\u30f3\n\n###\u30c6\u30b9\u30c8\u30d9\u30f3\u30c1\n\n\u975e\u5e38\u306b\u7c21\u5358\u3067\u3059\u304c\u3001\u6b21\u306e\u3088\u3046\u306a\u30c6\u30b9\u30c8\u30d9\u30f3\u30c1\u3092\u7528\u610f\u3057\u3066\u3044\u307e\u3059\u3002\u672c\u6765\u306a\u3089\u3082\u3063\u3068\u3061\u3083\u3093\u3068\u3057\u305f\u30c6\u30b9\u30c8\u30d9\u30f3\u30c1\u304c\u5fc5\u8981\u3067\u3059\u3002\n\n````VHDL:test_bench_bsn.vhd\nlibrary ieee;\nuse     ieee.std_logic_1164.all;\nuse     ieee.numeric_std.all;\nuse     std.textio.all;\n-----------------------------------------------------------------------------------\n--\n-----------------------------------------------------------------------------------\nentity  TEST_BENCH_BSN is\nend     TEST_BENCH_BSN;\n-----------------------------------------------------------------------------------\n--\n-----------------------------------------------------------------------------------\narchitecture MODEL of TEST_BENCH_BSN is\n    -------------------------------------------------------------------------------\n    -- \n    -------------------------------------------------------------------------------\n    constant CLOCK_PERIOD    : time    := 10 ns;\n    constant DELAY           : time    :=  1 ns;\n    -------------------------------------------------------------------------------\n    -- \n    -------------------------------------------------------------------------------\n    constant WORDS           :  integer :=  8;\n    constant WORD_BITS       :  integer :=  8;\n    constant COMP_HIGH       :  integer :=  7;\n    constant COMP_LOW        :  integer :=  0;\n    constant INFO_BITS       :  integer :=  4;\n    -------------------------------------------------------------------------------\n    --\n    -------------------------------------------------------------------------------\n    signal   CLK             :  std_logic;\n    signal   RST             :  std_logic;\n    signal   CLR             :  std_logic;\n    signal   I_SORT          :  std_logic;\n    signal   I_UP            :  std_logic;\n    signal   I_DATA          :  std_logic_vector(WORDS*WORD_BITS-1 downto 0);\n    signal   I_INFO          :  std_logic_vector(      INFO_BITS-1 downto 0);\n    signal   O_SORT          :  std_logic;\n    signal   O_UP            :  std_logic;\n    signal   O_DATA          :  std_logic_vector(WORDS*WORD_BITS-1 downto 0);\n    signal   O_INFO          :  std_logic_vector(      INFO_BITS-1 downto 0);\n    -------------------------------------------------------------------------------\n    --\n    -------------------------------------------------------------------------------\n    component Bitonic_Sorter\n        generic (\n            WORDS     :  integer :=  1;\n            WORD_BITS :  integer := 64;\n            COMP_HIGH :  integer := 64;\n            COMP_LOW  :  integer := 32;\n            INFO_BITS :  integer :=  4\n        );\n        port (\n            CLK       :  in  std_logic;\n            RST       :  in  std_logic;\n            CLR       :  in  std_logic;\n            I_SORT    :  in  std_logic;\n            I_UP      :  in  std_logic;\n            I_DATA    :  in  std_logic_vector(WORDS*WORD_BITS-1 downto 0);\n            I_INFO    :  in  std_logic_vector(      INFO_BITS-1 downto 0);\n            O_SORT    :  out std_logic;\n            O_UP      :  out std_logic;\n            O_DATA    :  out std_logic_vector(WORDS*WORD_BITS-1 downto 0);\n            O_INFO    :  out std_logic_vector(      INFO_BITS-1 downto 0)\n        );\n    end component;\nbegin\n    -------------------------------------------------------------------------------\n    --\n    -------------------------------------------------------------------------------\n    DUT: Bitonic_Sorter                 -- \n        generic map (                   -- \n            WORDS     => WORDS        , --\n            WORD_BITS => WORD_BITS    , --\n            COMP_HIGH => COMP_HIGH    , --\n            COMP_LOW  => COMP_LOW     , --\n            INFO_BITS => INFO_BITS      --\n        )                               -- \n        port map (                      -- \n            CLK       => CLK          , -- In  :\n            RST       => RST          , -- In  :\n            CLR       => CLR          , -- In  :\n            I_SORT    => I_SORT       , -- In  :\n            I_UP      => I_UP         , -- In  :\n            I_DATA    => I_DATA       , -- In  :\n            I_INFO    => I_INFO       , -- In  :\n            O_SORT    => O_SORT       , -- Out :\n            O_UP      => O_UP         , -- Out :\n            O_DATA    => O_DATA       , -- Out :\n            O_INFO    => O_INFO         -- Out :\n        );\n    -------------------------------------------------------------------------------\n    -- \n    -------------------------------------------------------------------------------\n    process begin\n        CLK <= '0';\n        wait for CLOCK_PERIOD / 2;\n        CLK <= '1';\n        wait for CLOCK_PERIOD / 2;\n    end process;\n    -------------------------------------------------------------------------------\n    -- \n    -------------------------------------------------------------------------------\n    process\n        type      INTEGER_VECTOR  is array(0 to WORDS-1) of integer;\n        variable  src_vec         :  INTEGER_VECTOR;\n        variable  exp_vec         :  INTEGER_VECTOR;\n        ---------------------------------------------------------------------------\n        --\n        ---------------------------------------------------------------------------\n        function  TO_DATA(IVEC:INTEGER_VECTOR) return std_logic_vector is\n            variable     data :  std_logic_vector(WORDS*WORD_BITS-1 downto 0);\n        begin\n            for i in 0 to WORDS-1 loop\n                data(WORD_BITS*(i+1)-1 downto WORD_BITS*i) := std_logic_vector(to_unsigned(IVEC(i), WORD_BITS));\n            end loop;\n            return data;\n        end function;\n        ---------------------------------------------------------------------------\n        --\n        ---------------------------------------------------------------------------\n        function  TO_INTEGER_VECTOR(DATA:std_logic_vector) return INTEGER_VECTOR is\n            variable     ivec :  INTEGER_VECTOR;\n        begin\n            for i in 0 to WORDS-1 loop\n                ivec(i) := to_integer(unsigned(DATA(WORD_BITS*(i+1)-1 downto WORD_BITS*i)));\n            end loop;\n            return ivec;\n        end function;\n        ---------------------------------------------------------------------------\n        --\n        ---------------------------------------------------------------------------\n        procedure WAIT_CLK(CNT:in integer) is\n        begin\n            for i in 1 to CNT loop \n                wait until (CLK'event and CLK = '1'); \n            end loop;\n        end WAIT_CLK;\n        ---------------------------------------------------------------------------\n        --\n        ---------------------------------------------------------------------------\n        procedure TEST(SORT,UP:std_logic; SRC,EXP: INTEGER_VECTOR) is\n            variable timeout :  boolean;\n            variable result  :  INTEGER_VECTOR;\n        begin\n            I_DATA  <= TO_DATA(SRC);\n            I_INFO  <= \"1111\";\n            I_SORT  <= SORT;\n            I_UP    <= UP;\n            timeout := TRUE;\n            \n            MAIN_LOOP: for i in 1 to 1000 loop\n                wait until (CLK'event and CLK = '1');\n                I_INFO <= \"0000\";\n                I_DATA <= (others => '0');\n                I_SORT <= '0';\n                I_UP   <= '0';\n                if (O_INFO = \"1111\") then\n                    timeout := FALSE;\n                    exit MAIN_LOOP;\n                end if;\n            end loop;\n            assert(timeout = FALSE) report \"Timeout...\"  severity FAILURE;\n            result := TO_INTEGER_VECTOR(O_DATA);\n            assert(result  = EXP  ) report \"Mismatch...\" severity FAILURE;\n        end procedure;\n    begin\n        ---------------------------------------------------------------------------\n        --\n        ---------------------------------------------------------------------------\n        assert(false) report \"Run Start...\" severity NOTE;\n        RST    <= '1';\n        CLR    <= '0';\n        I_DATA <= (others => '0');\n        I_INFO <= (others => '0');\n        I_SORT <= '0';\n        I_UP   <= '0';\n        WAIT_CLK(10);\n        RST    <= '0';\n        WAIT_CLK(10);\n        ---------------------------------------------------------------------------\n        --\n        ---------------------------------------------------------------------------\n        src_vec := (0 => 8, 1 => 1, 2 => 0, 3 => 6, 4 => 1, 5 => 2, 6 => 9, 7 => 1);\n        exp_vec := (0 => 8, 1 => 1, 2 => 0, 3 => 6, 4 => 1, 5 => 2, 6 => 9, 7 => 1);\n        TEST('0', '0', src_vec, exp_vec);\n        WAIT_CLK(1);\n\n        ---------------------------------------------------------------------------\n        --\n        ---------------------------------------------------------------------------\n        src_vec := (0 => 8, 1 => 1, 2 => 0, 3 => 6, 4 => 1, 5 => 2, 6 => 9, 7 => 1);\n        exp_vec := (0 => 9, 1 => 8, 2 => 6, 3 => 2, 4 => 1, 5 => 1, 6 => 1, 7 => 0);\n        TEST('1', '0', src_vec, exp_vec);\n        WAIT_CLK(1);\n        \n        ---------------------------------------------------------------------------\n        --\n        ---------------------------------------------------------------------------\n        src_vec := (0 => 8, 1 => 1, 2 => 0, 3 => 6, 4 => 1, 5 => 2, 6 => 9, 7 => 1);\n        exp_vec := (0 => 0, 1 => 1, 2 => 1, 3 => 1, 4 => 2, 5 => 6, 6 => 8, 7 => 9);\n        TEST('1', '1', src_vec, exp_vec);\n\n        WAIT_CLK(10);\n        assert(false) report \"Run complete...\" severity FAILURE;\n        wait;\n    end process;\nend MODEL;\n````\n\n###Vivado\u306e\u30d0\u30fc\u30b8\u30e7\u30f3\n\n- Xilinx Vivado 2015.4\n\n###\u624b\u9806\n\n####\u30c0\u30a6\u30f3\u30ed\u30fc\u30c9\n\n````shell\nshell% git clone git://github.com/ikwzm/bitonic_sorter.git\n````\n \n####Vivado\u30d7\u30ed\u30b8\u30a7\u30af\u30c8\u306e\u4f5c\u6210\n\nVivado \u30d7\u30ed\u30b8\u30a7\u30af\u30c8\u3092\u4f5c\u6210\u3059\u308b\u305f\u3081\u306eTcl\u30d5\u30a1\u30a4\u30eb(create_project.tcl)\u3092\u7528\u610f\u3057\u3066\u3044\u307e\u3059\u3002\nVivado \u306eTcl\u30b7\u30a7\u30eb\u3092\u4f7f\u3046\u5834\u5408\u306f\u6b21\u306e\u3088\u3046\u306b\u3057\u307e\u3059\u3002\n\n````Shell\nVivado% cd sim/vivado/bitonic_sorter\nVivado% vivado -mod batch -source create_project.tcl\n````\n\nVivado \u306e GUI\u3092\u4f7f\u3046\u5834\u5408\u306f\u6b21\u306e\u30e1\u30cb\u30e5\u30fc\u304b\u3089Tcl\u30d5\u30a1\u30a4\u30eb\u3092\u5b9f\u884c\u3057\u3066\u304f\u3060\u3055\u3044\u3002\n\n````\nVivado > Open Project > sim/vivado/bitonic_sorter/bitonic_sorter.xpr\nFlow Navigator > Run Simulation > Run Bihavioral Simulation \n````\n####\u30b7\u30df\u30e5\u30ec\u30fc\u30b7\u30e7\u30f3\u3092\u5b9f\u884c\n\nVivado \u30d7\u30ed\u30b8\u30a7\u30af\u30c8\u3092\u958b\u304d\u3001\u6b21\u306e\u3088\u3046\u306b\u30b7\u30df\u30e5\u30ec\u30fc\u30b7\u30e7\u30f3\u3092\u5b9f\u884c\u3057\u3066\u304f\u3060\u3055\u3044\u3002\n\n````\nVivado > Open Project > sim/vivado/bitonic_sorter/bitonic_sorter.xpr\nFlow Navigator > Run Simulation > Run Bihavioral Simulation \n````\n\n##Vivado \u306b\u3088\u308b\u8ad6\u7406\u5408\u6210\uff06\u30a4\u30f3\u30d7\u30ea\u30e1\u30f3\u30c6\u30fc\u30b7\u30e7\u30f3\n\n###\u958b\u767a\u30c4\u30fc\u30eb\u3068\u5bfe\u8c61\u30c7\u30d0\u30a4\u30b9\n\n- Xilinx Vivado 2015.4\n- Xilinx Zynq7020-1 (xc7z020clg400-1)\n\n###\u30e9\u30c3\u30d1\u30fc\u56de\u8def\n\nbionic_sorter \u3092\u6700\u4e0a\u4f4d\u30e2\u30b8\u30e5\u30fc\u30eb\u306b\u3059\u308b\u3068 I/O \u304c\u8db3\u308a\u306a\u304f\u306a\u308b\u4e0a\u306b\u3001Vivado \u306e\u554f\u984c\u306a\u306e\u304b\u518d\u5e30\u7684\u306b\u30a4\u30f3\u30b9\u30bf\u30f3\u30b9\u3057\u3066\u3044\u308b\u3068\u968e\u5c64\u69cb\u9020\u3092\u3046\u307e\u304f\u8a8d\u8b58\u51fa\u6765\u306a\u3044\u3088\u3046\u3067 bionic_sorter\u3092\u30c8\u30c3\u30d7\u30ec\u30d9\u30eb\u306b\u8a2d\u5b9a\u3067\u304d\u307e\u305b\u3093\u3002\u305d\u3053\u3067\u6b21\u306e\u3088\u3046\u306a\u30e9\u30c3\u30d1\u30fc\u30e2\u30b8\u30e5\u30fc\u30eb\u3092\u7528\u610f\u3057\u3066\u3044\u307e\u3059\u3002\n\u30bd\u30fc\u30c8\u3059\u308b\u30a2\u30a4\u30c6\u30e0\u6570(=WORDS)\u30924,8,16,32\u3067\u5408\u6210\u3057\u3066\u307f\u307e\u3057\u305f\u3002\n\n````bitonic_sorter_wrapper.vhd\nlibrary ieee;\nuse     ieee.std_logic_1164.all;\nentity  Bitonic_Sorter_Wrapper is\n    generic (\n        WORDS     :  integer :=  8;\n        WORD_BITS :  integer := 32;\n        COMP_HIGH :  integer := 31;\n        COMP_LOW  :  integer :=  0;\n        INFO_BITS :  integer :=  4\n    );\n    port (\n        CLK       :  in  std_logic;\n        RST       :  in  std_logic;\n        CLR       :  in  std_logic;\n        I_SORT    :  in  std_logic;\n        I_UP      :  in  std_logic;\n        I_ADDR    :  in  integer range 0 to WORDS-1;\n        I_DATA    :  in  std_logic_vector(WORD_BITS-1 downto 0);\n        I_INFO    :  in  std_logic_vector(INFO_BITS-1 downto 0);\n        O_ADDR    :  in  integer range 0 to WORDS-1;\n        O_DATA    :  out std_logic_vector(WORD_BITS-1 downto 0);\n        O_INFO    :  out std_logic_vector(INFO_BITS-1 downto 0)\n    );\nend Bitonic_Sorter_Wrapper;\nlibrary ieee;\nuse     ieee.std_logic_1164.all;\nuse     ieee.numeric_std.all;\narchitecture RTL of Bitonic_Sorter_Wrapper is\n    component Bitonic_Sorter\n        generic (\n            WORDS     :  integer :=  1;\n            WORD_BITS :  integer := 64;\n            COMP_HIGH :  integer := 64;\n            COMP_LOW  :  integer := 32;\n            INFO_BITS :  integer :=  4\n        );\n        port (\n            CLK       :  in  std_logic;\n            RST       :  in  std_logic;\n            CLR       :  in  std_logic;\n            I_SORT    :  in  std_logic;\n            I_UP      :  in  std_logic;\n            I_DATA    :  in  std_logic_vector(WORDS*WORD_BITS-1 downto 0);\n            I_INFO    :  in  std_logic_vector(      INFO_BITS-1 downto 0);\n            O_SORT    :  out std_logic;\n            O_UP      :  out std_logic;\n            O_DATA    :  out std_logic_vector(WORDS*WORD_BITS-1 downto 0);\n            O_INFO    :  out std_logic_vector(      INFO_BITS-1 downto 0)\n        );\n    end component;\n    signal  s_data    :  std_logic_vector(WORDS*WORD_BITS-1 downto 0);\n    signal  q_data    :  std_logic_vector(WORDS*WORD_BITS-1 downto 0);\nbegin\n    process(CLK, RST) begin\n        if (RST = '1') then\n                s_data <= (others => '0');\n        elsif (CLK'event and CLK = '1') then\n            if (CLR = '1') then\n                s_data <= (others => '0');\n            else\n                for i in 0 to WORDS-1 loop\n                    if (I_ADDR = i) then\n                        s_data(WORD_BITS*(i+1)-1 downto WORD_BITS*i) <= I_DATA;\n                    end if;\n                end loop;\n            end if;\n        end if;\n    end process;\n    U: Bitonic_Sorter\n        generic map (\n            WORDS     => WORDS     , -- \n            WORD_BITS => WORD_BITS , -- \n            COMP_HIGH => COMP_HIGH , -- \n            COMP_LOW  => COMP_LOW  , -- \n            INFO_BITS => INFO_BITS   -- \n        )\n        port map (\n            CLK       => CLK       , -- \n            RST       => RST       , -- \n            CLR       => CLR       , -- \n            I_SORT    => I_SORT    , -- \n            I_UP      => I_UP      , -- \n            I_DATA    => s_data    , -- \n            I_INFO    => I_INFO    , -- \n            O_SORT    => open      , -- \n            O_UP      => open      , -- \n            O_DATA    => q_data    , -- \n            O_INFO    => O_INFO      -- \n        );\n    process(CLK, RST) begin\n        if (RST = '1') then\n                O_DATA <= (others => '0');\n        elsif (CLK'event and CLK = '1') then\n            if (CLR = '1') then\n                O_DATA <= (others => '0');\n            else\n                for i in 0 to WORDS-1 loop\n                    if (O_ADDR = i) then\n                        O_DATA <= q_data(WORD_BITS*(i+1)-1 downto WORD_BITS*i);\n                    end if;\n                end loop;\n            end if;\n        end if;\n    end process;\nend RTL;\n````\n\n###\u624b\u9806\n\n####\u30c0\u30a6\u30f3\u30ed\u30fc\u30c9\n\n````shell\nshell% git clone git://github.com/ikwzm/bitonic_sorter.git\n````\n \n####Vivado\u30d7\u30ed\u30b8\u30a7\u30af\u30c8\u306e\u4f5c\u6210\n\n\u4eca\u56de\u306f\u3061\u3087\u3063\u3068\u624b\u3092\u629c\u3044\u3066\u3001Vivado\u30b7\u30df\u30e5\u30ec\u30fc\u30b7\u30e7\u30f3\u306e\u30d7\u30ed\u30b8\u30a7\u30af\u30c8\u3092\u9593\u501f\u308a\u3057\u3066\u3044\u307e\u3059\u3002\n\u30d7\u30ed\u30b8\u30a7\u30af\u30c8\u306e\u4f5c\u308a\u65b9\u306f\u305d\u3061\u3089\u3092\u53c2\u7167\u3057\u3066\u304f\u3060\u3055\u3044\u3002\n\n####\u8ad6\u7406\u5408\u6210\u3068\u30a4\u30f3\u30d7\u30ea\u30e1\u30f3\u30c6\u30fc\u30b7\u30e7\u30f3\n\nVivado\u3092\u8d77\u52d5\u3057\u3066\u30d7\u30ed\u30b8\u30a7\u30af\u30c8\u3092\u958b\u304d\u3001\u30a4\u30f3\u30d7\u30ea\u30e1\u30f3\u30c6\u30fc\u30b7\u30e7\u30f3\u3092\u5b9f\u884c\u3057\u307e\u3059\u3002\n\n````\nVivado > Open Project > sim/vivado/bitonic_sorter/bitonic_sorter.xpr\nFlow Navigator > Run Implementation\n````\n\n###\u7d50\u679c\n\n|   WORDS   | Slice LUTs | Slice Registers | Slice |\n|----------:|-----------:|----------------:|------:|\n|         4 |        252 |              70 |    87 |\n|         8 |       2061 |            1585 |   545 |\n|        16 |       6658 |            5247 |  1746 |\n|        32 |      19715 |           15684 |  5228 |\n\n\u6b8b\u5ff5\u306a\u304c\u3089\u3001Zynq7020\u30af\u30e9\u30b9\u3060\u3068\u3001\u305b\u3044\u305c\u304432\u30a2\u30a4\u30c6\u30e0\u306e\u30bd\u30fc\u30c8\u3057\u304b\u51fa\u6765\u307e\u305b\u3093\u3002\n\u3061\u306a\u307f\u306b\u52d5\u4f5c\u5468\u6ce2\u6570\u306f200MHz\u3067\u3059\u3002\n\n"}