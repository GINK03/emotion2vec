{"context": "\u30c4\u30ea\u30fc\u306e\u4e2d\u306e\u8ddd\u96e2\n\u30aa\u30d5\u30e9\u30a4\u30f3\u30ea\u30a2\u30eb\u30bf\u30a4\u30e0\u3069\u3046\u66f8\u304fE11 \u306e\u554f\u984c\n\nE11.hs\n{-# LANGUAGE FlexibleContexts #-}\nmodule E11 where\n\nimport Data.List\nimport Data.Ord\nimport qualified Data.Set as S\nimport Data.Tree\nimport Math.NumberTheory.ArithmeticFunctions\n\ntype NodeID = Int\ntype Path   = [NodeID]\n\ndata Label = Label { nodeID :: NodeID\n                   , label  :: Int\n                   , path   :: Path\n                   } deriving (Eq,Show)\n\nchildSeeds :: Int -> [Int]\nchildSeeds = map succ . init . tail . S.elems . divisors\n\ngentree :: (Int,Int,Int) -> (NodeID, Path, [Path], [Path]) -> (Tree Label, (NodeID, Path, [Path], [Path]))\ngentree (n,s,e) (nid,pth,ss,ts) = (Node (Label nid n pth) children, (nid1, pth, ss2, ts2))\n  where\n    ss2 = if n == s then (nid:pth) : ss1 else ss1\n    ts2 = if n == e then (nid:pth) : ts1 else ts1\n    ((nid1,ss1,ts1),children) = mapAccumL gen (nid,ss,ts) $ childSeeds n\n    gen (nid',ss',ts') n' = case gentree (n',s,e) (succ nid',nid:pth,ss',ts') of\n      (t,(nid'',_,ss'',ts'')) -> ((nid'',ss'',ts''),t)\n\npaths :: (Tree Label, (NodeID, Path, [Path], [Path])) -> [Path]\npaths (_,(_,_,ss,ts)) = [ (s `union` t) \\\\ (s `intersect` t) | s <- ss, t <- ts ]\n\ncheck :: (Tree Label, (NodeID, Path, [Path], [Path])) -> ([Path],[Path])\ncheck (_,(_,_,ss,ts)) =(ss,ts)\n\nreadIni :: String -> (Int,Int,Int)\nreadIni s = case break (':'==) s of\n  (xs,_:ys) -> case break (','==) ys of\n    (zs,_:ws) -> (read xs,read zs,read ws)\n\ne11 :: Problem -> Answer\ne11 = show\n    . minimum\n    . map length\n    . paths\n    . flip gentree (0,[],[],[])\n    . readIni\n\ntype Problem = String\ntype Answer  = String\n\ntype Test = (Problem, Answer)\n{- |\n>>> test ( \"50:6,3\", \"1\" )\nTrue\n>>> test ( \"98:5,11\", \"4\" )\nTrue    \n>>> test ( \"1000:33,20\", \"7\" )\nTrue    \n>>> test ( \"514:9,18\", \"8\" )\nTrue    \n>>> test ( \"961:5,4\", \"3\" )\nTrue    \n>>> test ( \"1369:1369,3\", \"2\" )\nTrue    \n>>> test ( \"258:16,12\", \"5\" )\nTrue    \n>>> test ( \"235:13,3\", \"2\" )\nTrue    \n>>> test ( \"1096:19,17\", \"8\" )\nTrue    \n>>> test ( \"847:7,17\", \"6\" )\nTrue    \n>>> test ( \"1932:3,5\", \"2\" )\nTrue    \n>>> test ( \"2491:4,8\", \"3\" )\nTrue    \n>>> test ( \"840:421,36\", \"2\" )\nTrue    \n>>> test ( \"1430:37,111\", \"3\" )\nTrue    \n>>> test ( \"496:17,9\", \"2\" )\nTrue    \n>>> test ( \"891:6,10\", \"1\" )\nTrue    \n>>> test ( \"1560:196,21\", \"2\" )\nTrue    \n>>> test ( \"516:20,12\", \"5\" )\nTrue    \n>>> test ( \"696:30,59\", \"2\" )\nTrue    \n>>> test ( \"1760:5,441\", \"2\" )\nTrue    \n>>> test ( \"1736:11,26\", \"5\" )\nTrue    \n>>> test ( \"1518:17,34\", \"4\" )\nTrue    \n>>> test ( \"806:63,16\", \"5\" )\nTrue    \n>>> test ( \"1920:3,97\", \"2\" )\nTrue    \n>>> test ( \"1150:13,22\", \"4\" )\nTrue    \n>>> test ( \"920:116,5\", \"1\" )\nTrue    \n>>> test ( \"2016:7,337\", \"2\" )\nTrue    \n>>> test ( \"408:9,25\", \"2\" )\nTrue    \n>>> test ( \"735:36,8\", \"2\" )\nTrue    \n>>> test ( \"470:5,31\", \"2\" )\nTrue    \n>>> test ( \"2100:12,351\", \"3\" )\nTrue    \n>>> test ( \"870:36,10\", \"1\" )\nTrue    \n>>> test ( \"1512:253,13\", \"2\" )\nTrue    \n>>> test ( \"697:12,15\", \"3\" )\nTrue    \n>>> test ( \"1224:5,14\", \"2\" )\nTrue    \n>>> test ( \"986:125,17\", \"3\" )\nTrue    \n>>> test ( \"864:12,13\", \"3\" )\nTrue    \n>>> test ( \"500:21,51\", \"2\" )\nTrue    \n>>> test ( \"819:33,21\", \"4\" )\nTrue    \n>>> test ( \"594:55,3\", \"2\" )\nTrue    \n>>> test ( \"638:17,24\", \"3\" )\nTrue\n-}\ntest :: Test -> Bool\ntest (p,a) = e11 p == a\n\n\n[\u30c4\u30ea\u30fc\u306e\u4e2d\u306e\u8ddd\u96e2](http://nabetani.sakura.ne.jp/hena/orde11tredis/)\n[\u30aa\u30d5\u30e9\u30a4\u30f3\u30ea\u30a2\u30eb\u30bf\u30a4\u30e0\u3069\u3046\u66f8\u304fE11 \u306e\u554f\u984c](http://qiita.com/Nabetani/items/10b2ccc28301e44e09e6)\n\n```haskell:E11.hs\n{-# LANGUAGE FlexibleContexts #-}\nmodule E11 where\n\nimport Data.List\nimport Data.Ord\nimport qualified Data.Set as S\nimport Data.Tree\nimport Math.NumberTheory.ArithmeticFunctions\n\ntype NodeID = Int\ntype Path   = [NodeID]\n\ndata Label = Label { nodeID :: NodeID\n                   , label  :: Int\n                   , path   :: Path\n                   } deriving (Eq,Show)\n\nchildSeeds :: Int -> [Int]\nchildSeeds = map succ . init . tail . S.elems . divisors\n\ngentree :: (Int,Int,Int) -> (NodeID, Path, [Path], [Path]) -> (Tree Label, (NodeID, Path, [Path], [Path]))\ngentree (n,s,e) (nid,pth,ss,ts) = (Node (Label nid n pth) children, (nid1, pth, ss2, ts2))\n  where\n    ss2 = if n == s then (nid:pth) : ss1 else ss1\n    ts2 = if n == e then (nid:pth) : ts1 else ts1\n    ((nid1,ss1,ts1),children) = mapAccumL gen (nid,ss,ts) $ childSeeds n\n    gen (nid',ss',ts') n' = case gentree (n',s,e) (succ nid',nid:pth,ss',ts') of\n      (t,(nid'',_,ss'',ts'')) -> ((nid'',ss'',ts''),t)\n\npaths :: (Tree Label, (NodeID, Path, [Path], [Path])) -> [Path]\npaths (_,(_,_,ss,ts)) = [ (s `union` t) \\\\ (s `intersect` t) | s <- ss, t <- ts ]\n\ncheck :: (Tree Label, (NodeID, Path, [Path], [Path])) -> ([Path],[Path])\ncheck (_,(_,_,ss,ts)) =(ss,ts)\n\nreadIni :: String -> (Int,Int,Int)\nreadIni s = case break (':'==) s of\n  (xs,_:ys) -> case break (','==) ys of\n    (zs,_:ws) -> (read xs,read zs,read ws)\n\ne11 :: Problem -> Answer\ne11 = show\n    . minimum\n    . map length\n    . paths\n    . flip gentree (0,[],[],[])\n    . readIni\n\ntype Problem = String\ntype Answer  = String\n\ntype Test = (Problem, Answer)\n{- |\n>>> test ( \"50:6,3\", \"1\" )\nTrue\n>>> test ( \"98:5,11\", \"4\" )\nTrue    \n>>> test ( \"1000:33,20\", \"7\" )\nTrue    \n>>> test ( \"514:9,18\", \"8\" )\nTrue    \n>>> test ( \"961:5,4\", \"3\" )\nTrue    \n>>> test ( \"1369:1369,3\", \"2\" )\nTrue    \n>>> test ( \"258:16,12\", \"5\" )\nTrue    \n>>> test ( \"235:13,3\", \"2\" )\nTrue    \n>>> test ( \"1096:19,17\", \"8\" )\nTrue    \n>>> test ( \"847:7,17\", \"6\" )\nTrue    \n>>> test ( \"1932:3,5\", \"2\" )\nTrue    \n>>> test ( \"2491:4,8\", \"3\" )\nTrue    \n>>> test ( \"840:421,36\", \"2\" )\nTrue    \n>>> test ( \"1430:37,111\", \"3\" )\nTrue    \n>>> test ( \"496:17,9\", \"2\" )\nTrue    \n>>> test ( \"891:6,10\", \"1\" )\nTrue    \n>>> test ( \"1560:196,21\", \"2\" )\nTrue    \n>>> test ( \"516:20,12\", \"5\" )\nTrue    \n>>> test ( \"696:30,59\", \"2\" )\nTrue    \n>>> test ( \"1760:5,441\", \"2\" )\nTrue    \n>>> test ( \"1736:11,26\", \"5\" )\nTrue    \n>>> test ( \"1518:17,34\", \"4\" )\nTrue    \n>>> test ( \"806:63,16\", \"5\" )\nTrue    \n>>> test ( \"1920:3,97\", \"2\" )\nTrue    \n>>> test ( \"1150:13,22\", \"4\" )\nTrue    \n>>> test ( \"920:116,5\", \"1\" )\nTrue    \n>>> test ( \"2016:7,337\", \"2\" )\nTrue    \n>>> test ( \"408:9,25\", \"2\" )\nTrue    \n>>> test ( \"735:36,8\", \"2\" )\nTrue    \n>>> test ( \"470:5,31\", \"2\" )\nTrue    \n>>> test ( \"2100:12,351\", \"3\" )\nTrue    \n>>> test ( \"870:36,10\", \"1\" )\nTrue    \n>>> test ( \"1512:253,13\", \"2\" )\nTrue    \n>>> test ( \"697:12,15\", \"3\" )\nTrue    \n>>> test ( \"1224:5,14\", \"2\" )\nTrue    \n>>> test ( \"986:125,17\", \"3\" )\nTrue    \n>>> test ( \"864:12,13\", \"3\" )\nTrue    \n>>> test ( \"500:21,51\", \"2\" )\nTrue    \n>>> test ( \"819:33,21\", \"4\" )\nTrue    \n>>> test ( \"594:55,3\", \"2\" )\nTrue    \n>>> test ( \"638:17,24\", \"3\" )\nTrue\n-}\ntest :: Test -> Bool\ntest (p,a) = e11 p == a\n```\n", "tags": ["Haskell", "\u3069\u3046\u66f8\u304f", "yhpg"]}