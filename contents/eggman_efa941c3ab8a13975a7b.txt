{"context": "OpenBSD\u306eif_rsu.c\u3092\u8aad\u3093\u3067\u307f\u307e\u3057\u305f\u3002\nif_rsu.c\u306fRealtek\u306eWi-Fi\u30c1\u30c3\u30d7\u7528\u306e\u30c7\u30d0\u30a4\u30b9\u30c9\u30e9\u30a4\u30d0\u306e\u30bd\u30fc\u30b9\u30b3\u30fc\u30c9\u3067\u3059\u3002\n\u5b9f\u88c5\u3055\u308c\u3066\u3044\u308b\u6a5f\u80fd\u304c\u3068\u3066\u3082\u5c11\u306a\u3044\u306e\u3067\u8aad\u307f\u3084\u3059\u3044\u3067\u3059\u3002\n\n\u5bfe\u8c61\n\nhttp://cvsweb.openbsd.org/cgi-bin/cvsweb/src/sys/dev/usb/if_rsu.c?rev=1.34&content-type=text/x-cvsweb-markup\n\n\nif_rsu.c\u306e\u5bfe\u5fdc\u6a5f\u80fd\n\n802.11n 802.11g 802.11b\nSTA\n\u6697\u53f7\u5316\u306a\u3057\u3001WEP\u3001WPA2 (\u6697\u53f7\u5316\u306f\u30c9\u30e9\u30a4\u30d0\u5074\u3067\u884c\u3046)\n802.11e \u306eQoS\nUSB\n\n\n\u5bfe\u5fdc\u30c1\u30c3\u30d7\n\nRTL8171\nRTL8172\nRTL8173\nRTL8174\nRTL8712\nRTL8713\nRTL8188SU\nRTL8191SU\nRTL8192SU\n\n\nUSB\u306e\u30a8\u30f3\u30c9\u30dd\u30a4\u30f3\u30c8\n\n\u30c7\u30a3\u30b9\u30af\u30ea\u30d7\u30bf\u306eid->bNumEndpoints\u306e\u6570\u5b57\u306b\u3088\u3063\u3066\u7570\u306a\u308a\u3001\u5909\u63db\u30c6\u30fc\u30d6\u30eb\u3092\u4f7f\u3063\u3066qid\u304b\u3089\u30a8\u30f3\u30c9\u30dd\u30a4\u30f3\u30c8\u306e\u6570\u5b57\u3092\u5c0e\u51fa\u3059\u308b\u3002\n4\n\n\nrsu_qid2idx_4ep[]  = { 3, 3, 3, 1, 1, 2, 2, 0, 3, 0 }; \n\n\n6\n\n\nrsu_qid2idx_6ep[]  = { 3, 3, 3, 1, 4, 2, 5, 0, 3, 0 }; \n\n\n\n11\n\nrsu_qid2idx_11ep[] = { 7, 9, 8, 1, 4, 2, 5, 0, 3, 6 };\n\n\nqid\u306e\u5b9a\u6570\n\n/* Queue ids (used by soft only). */\n#define RSU_QID_BCN     0\n#define RSU_QID_MGT     1\n#define RSU_QID_BMC     2\n#define RSU_QID_VO      3\n#define RSU_QID_VI      4\n#define RSU_QID_BE      5\n#define RSU_QID_BK      6\n#define RSU_QID_RXOFF   7\n#define RSU_QID_H2C     8\n#define RSU_QID_C2H     9\n\n\n\u4f7f\u7528\u3059\u308b\u30a8\u30f3\u30c9\u30dd\u30a4\u30f3\u30c8\n\n\n1 : \u30c7\u30fc\u30bf\u9001\u4fe1 ( RSU_QID_BE )\n3 : \u30b3\u30de\u30f3\u30c9\u9001\u4fe1 ( RSU_QID_H2C )\n\n\n\n\n\u30b3\u30de\u30f3\u30c9\n\n\u30b3\u30de\u30f3\u30c9\u9001\u4fe1\n\nTx descriptor\u3092\u7528\u610f\ncommand heeadr\u3092\u7528\u610f\ncommand payload\u3092\u7528\u610f\nRSU_QID_H2C\u306b\u5bfe\u5fdc\u3059\u308bendpoint 3\u306b usbd_setup_xfer() usbd_transfer()\u3067\u9001\u4fe1\u3002\n\nint\nrsu_fw_cmd(struct rsu_softc *sc, uint8_t code, void *buf, int len)\n{\n        struct rsu_tx_data *data;\n        struct r92s_tx_desc *txd;\n        struct r92s_fw_cmd_hdr *cmd;\n        struct usbd_pipe *pipe;\n        int cmdsz, xferlen;\n\n        data = sc->fwcmd_data;\n\n        /* Round-up command length to a multiple of 8 bytes. */\n        cmdsz = (len + 7) & ~7;\n\n        xferlen = sizeof(*txd) + sizeof(*cmd) + cmdsz;\n        KASSERT(xferlen <= RSU_TXBUFSZ);\n        memset(data->buf, 0, xferlen);\n\n        /* Setup Tx descriptor. */\n        txd = (struct r92s_tx_desc *)data->buf;\n        txd->txdw0 = htole32(\n            SM(R92S_TXDW0_OFFSET, sizeof(*txd)) |\n            SM(R92S_TXDW0_PKTLEN, sizeof(*cmd) + cmdsz) |\n            R92S_TXDW0_OWN | R92S_TXDW0_FSG | R92S_TXDW0_LSG);\n        txd->txdw1 = htole32(SM(R92S_TXDW1_QSEL, R92S_TXDW1_QSEL_H2C));\n\n        /* Setup command header. */\n        cmd = (struct r92s_fw_cmd_hdr *)&txd[1];\n        cmd->len = htole16(cmdsz);\n        cmd->code = code;\n        cmd->seq = sc->cmd_seq;\n        sc->cmd_seq = (sc->cmd_seq + 1) & 0x7f;\n\n        /* Copy command payload. */\n        memcpy(&cmd[1], buf, len);\n\n        DPRINTFN(2, (\"Tx cmd code=%d len=%d\\n\", code, cmdsz));\n        pipe = sc->pipe[sc->qid2idx[RSU_QID_H2C]];\n        usbd_setup_xfer(data->xfer, pipe, NULL, data->buf, xferlen,\n            USBD_SHORT_XFER_OK | USBD_NO_COPY | USBD_SYNCHRONOUS,\n            RSU_CMD_TIMEOUT, NULL);\n        return (usbd_transfer(data->xfer));\n}\n\n\n\u30b3\u30de\u30f3\u30c9\u306e\u7a2e\u985e\n\n\u30bd\u30fc\u30b9\u30b3\u30fc\u30c9\u5185\u3067\u4f7f\u3063\u3066\u3044\u308b\u30b3\u30de\u30f3\u30c9\n\n#define R92S_CMD_JOIN_BSS               14\n#define R92S_CMD_DISCONNECT             15\n#define R92S_CMD_SET_OPMODE             17\n#define R92S_CMD_SITE_SURVEY            18\n#define R92S_CMD_SET_AUTH               19\n#define R92S_CMD_SET_KEY                20\n#define R92S_CMD_SET_PWR_MODE           36\n#define R92S_CMD_SET_MAC_ADDRESS        58\n\n\n\nAP\u306b\u63a5\u7d9a\n\nR92S_CMD_SET_OPMODE\u30b3\u30de\u30f3\u30c9\u3092\u9001\u4fe1\nR92S_CMD_SET_AUTH\u30b3\u30de\u30f3\u30c9\u3092\u9001\u4fe1 (WPA or Open)\n\u5f15\u6570ni\u304b\u3089\u63a5\u7d9a\u5148AP\u306e\u60c5\u5831\u3092bss\u306b\u7528\u610f\n\u4ed8\u52a0\u3059\u308bIE\u306e\u60c5\u5831\u3092frm\u306b\u7528\u610f\u3002\nR92S_CMD_JOIN_BSS\u30b3\u30de\u30f3\u30c9\n\nint\nrsu_join_bss(struct rsu_softc *sc, struct ieee80211_node *ni)\n{\n        struct ieee80211com *ic = &sc->sc_ic;\n        struct ndis_wlan_bssid_ex *bss;\n        struct ndis_802_11_fixed_ies *fixed;\n        struct r92s_fw_cmd_auth auth;\n        uint8_t buf[sizeof(*bss) + 128], *frm;\n        uint8_t opmode;\n        int error;\n\n        /* Let the FW decide the opmode based on the capinfo field. */\n        opmode = NDIS802_11AUTOUNKNOWN;\n        DPRINTF((\"setting operating mode to %d\\n\", opmode));\n        error = rsu_fw_cmd(sc, R92S_CMD_SET_OPMODE, &opmode, sizeof(opmode));\n        if (error != 0)\n                return (error);\n\n        memset(&auth, 0, sizeof(auth));\n        if (ic->ic_flags & IEEE80211_F_RSNON) {\n                auth.mode = R92S_AUTHMODE_WPA;\n                auth.dot1x = ieee80211_is_8021x_akm(ni->ni_rsnakms);\n        } else\n                auth.mode = R92S_AUTHMODE_OPEN;\n        DPRINTF((\"setting auth mode to %d\\n\", auth.mode));\n        error = rsu_fw_cmd(sc, R92S_CMD_SET_AUTH, &auth, sizeof(auth));\n        if (error != 0)\n                return (error);\n\n        memset(buf, 0, sizeof(buf));\n        bss = (struct ndis_wlan_bssid_ex *)buf;\n        IEEE80211_ADDR_COPY(bss->macaddr, ni->ni_bssid);\n        bss->ssid.ssidlen = htole32(ni->ni_esslen);\n        memcpy(bss->ssid.ssid, ni->ni_essid, ni->ni_esslen);\n        if (ic->ic_flags & (IEEE80211_F_WEPON | IEEE80211_F_RSNON))\n                bss->privacy = htole32(1);\n        bss->rssi = htole32(ni->ni_rssi);\n        if (ic->ic_curmode == IEEE80211_MODE_11B)\n                bss->networktype = htole32(NDIS802_11DS);\n        else\n                bss->networktype = htole32(NDIS802_11OFDM24);\n        bss->config.len = htole32(sizeof(bss->config));\n        bss->config.bintval = htole32(ni->ni_intval);\n        bss->config.dsconfig = htole32(ieee80211_chan2ieee(ic, ni->ni_chan));\n        bss->inframode = htole32(NDIS802_11INFRASTRUCTURE);\n        memcpy(bss->supprates, ni->ni_rates.rs_rates,\n            ni->ni_rates.rs_nrates);\n        /* Write the fixed fields of the beacon frame. */\n        fixed = (struct ndis_802_11_fixed_ies *)&bss[1];\n        memcpy(&fixed->tstamp, ni->ni_tstamp, 8);\n        fixed->bintval = htole16(ni->ni_intval);\n        fixed->capabilities = htole16(ni->ni_capinfo);\n        /* Write IEs to be included in the association request. */\n        frm = (uint8_t *)&fixed[1];\n        if ((ic->ic_flags & IEEE80211_F_RSNON) &&\n            (ni->ni_rsnprotos & IEEE80211_PROTO_RSN))\n                frm = ieee80211_add_rsn(frm, ic, ni);\n        if (ni->ni_flags & IEEE80211_NODE_QOS)\n                frm = ieee80211_add_qos_capability(frm, ic);\n        if (ni->ni_flags & IEEE80211_NODE_QOS)\n                frm = ieee80211_add_qos_capability(frm, ic);\n        if (ni->ni_flags & IEEE80211_NODE_HT)\n                frm = ieee80211_add_htcaps(frm, ic);\n        if ((ic->ic_flags & IEEE80211_F_RSNON) &&\n            (ni->ni_rsnprotos & IEEE80211_PROTO_WPA))\n                frm = ieee80211_add_wpa(frm, ic, ni);\n        bss->ieslen = htole32(frm - (uint8_t *)fixed);\n        bss->len = htole32(((frm - buf) + 3) & ~3);\n        DPRINTF((\"sending join bss command to %s chan %d\\n\",\n            ether_sprintf(bss->macaddr), letoh32(bss->config.dsconfig)));\n        return (rsu_fw_cmd(sc, R92S_CMD_JOIN_BSS, buf, sizeof(buf)));\n}\n\n\nAP\u304b\u3089\u5207\u65ad\n\nR92S_CMD_DISCONNECT\u30b3\u30de\u30f3\u30c9\u3092\u9001\u4fe1\n\nint\nrsu_disconnect(struct rsu_softc *sc)\n{\n        uint32_t zero = 0;      /* :-) */\n\n        /* Disassociate from our current BSS. */\n        DPRINTF((\"sending disconnect command\\n\"));\n        return (rsu_fw_cmd(sc, R92S_CMD_DISCONNECT, &zero, sizeof(zero)));\n}\n\n\n\u30c7\u30fc\u30bf\u9001\u4fe1\n\nWPA\u6709\u52b9\u306a\u3089\u3001ieee80211_get_txkey()\u306e\u9375\u3092\u4f7f\u3063\u3066ieee80211_encrypt()\u3067\u6697\u53f7\u5316\u3059\u308b\u3002\nendpoint\u3092\u9078\u629e\u3002QoS\u3092\u4f7f\u308f\u306a\u3044\u306a\u3089 RSU_QID_BE\u306b\u5bfe\u5fdc\u3059\u308bEndpoint 0\u3092\u9078\u629e\u3002\nTx descriptor\u3092\u7528\u610f\n\u9001\u4fe1\u30c7\u30fc\u30bf\u3092\u7528\u610f\nusbd_setup_xfer() usbd_transfer()\u3067\u9001\u4fe1\u3002\n\nint\nrsu_tx(struct rsu_softc *sc, struct mbuf *m, struct ieee80211_node *ni)\n{\n        struct ieee80211com *ic = &sc->sc_ic;\n        struct ieee80211_frame *wh;\n        struct ieee80211_key *k = NULL;\n        struct rsu_tx_data *data;\n        struct r92s_tx_desc *txd;\n        struct usbd_pipe *pipe;\n        uint16_t qos;\n        uint8_t type, qid, tid = 0;\n        int hasqos, xferlen, error;\n\n        wh = mtod(m, struct ieee80211_frame *);\n        type = wh->i_fc[0] & IEEE80211_FC0_TYPE_MASK;\n\n        if (wh->i_fc[1] & IEEE80211_FC1_PROTECTED) {\n                k = ieee80211_get_txkey(ic, wh, ni);\n                if ((m = ieee80211_encrypt(ic, m, k)) == NULL)\n                        return (ENOBUFS);\n                wh = mtod(m, struct ieee80211_frame *);\n        }\n        if ((hasqos = ieee80211_has_qos(wh))) {\n                qos = ieee80211_get_qos(wh);\n                tid = qos & IEEE80211_QOS_TID;\n                qid = rsu_ac2qid[ieee80211_up_to_ac(ic, tid)];\n        } else\n                qid = RSU_QID_BE;\n\n        /* Get the USB pipe to use for this queue id. */\n        pipe = sc->pipe[sc->qid2idx[qid]];\n\n        /* Grab a Tx buffer from our free list. */\n        data = TAILQ_FIRST(&sc->tx_free_list);\n        TAILQ_REMOVE(&sc->tx_free_list, data, next);\n\n        /* Fill Tx descriptor. */\n        txd = (struct r92s_tx_desc *)data->buf;\n        memset(txd, 0, sizeof(*txd));\n\n        txd->txdw0 |= htole32(\n            SM(R92S_TXDW0_PKTLEN, m->m_pkthdr.len) |\n            SM(R92S_TXDW0_OFFSET, sizeof(*txd)) |\n            R92S_TXDW0_OWN | R92S_TXDW0_FSG | R92S_TXDW0_LSG);\n\n        txd->txdw1 |= htole32(\n            SM(R92S_TXDW1_MACID, R92S_MACID_BSS) |\n            SM(R92S_TXDW1_QSEL, R92S_TXDW1_QSEL_BE));\n        if (!hasqos)\n                txd->txdw1 |= htole32(R92S_TXDW1_NONQOS);\n#ifdef notyet\n        if (k != NULL) {\n                switch (k->k_cipher) {\n                case IEEE80211_CIPHER_WEP40:\n                case IEEE80211_CIPHER_WEP104:\n                        cipher = R92S_TXDW1_CIPHER_WEP;\n                        break;\n                case IEEE80211_CIPHER_TKIP:\n                        cipher = R92S_TXDW1_CIPHER_TKIP;\n                        break;\n                case IEEE80211_CIPHER_CCMP:\n                        cipher = R92S_TXDW1_CIPHER_AES;\n                       break;\n                default:\n                        cipher = R92S_TXDW1_CIPHER_NONE;\n                }\n                txd->txdw1 |= htole32(\n                    SM(R92S_TXDW1_CIPHER, cipher) |\n                    SM(R92S_TXDW1_KEYIDX, k->k_id));\n        }\n#endif\n        txd->txdw2 |= htole32(R92S_TXDW2_BK);\n        if (IEEE80211_IS_MULTICAST(wh->i_addr1))\n                txd->txdw2 |= htole32(R92S_TXDW2_BMCAST);\n        /*\n         * Firmware will use and increment the sequence number for the\n         * specified TID.\n         */\n        txd->txdw3 |= htole32(SM(R92S_TXDW3_SEQ, tid));\n\n#if NBPFILTER > 0\n        if (__predict_false(sc->sc_drvbpf != NULL)) {\n                struct rsu_tx_radiotap_header *tap = &sc->sc_txtap;\n                struct mbuf mb;\n\n                tap->wt_flags = 0;\n                tap->wt_chan_freq = htole16(ic->ic_bss->ni_chan->ic_freq);\n                tap->wt_chan_flags = htole16(ic->ic_bss->ni_chan->ic_flags);\n\n                mb.m_data = (caddr_t)tap;\n                mb.m_len = sc->sc_txtap_len;\n                mb.m_next = m;\n                mb.m_nextpkt = NULL;\n                mb.m_type = 0;\n                mb.m_flags = 0;\n                bpf_mtap(sc->sc_drvbpf, &mb, BPF_DIRECTION_OUT);\n        }\n#endif\n\n        xferlen = sizeof(*txd) + m->m_pkthdr.len;\n        m_copydata(m, 0, m->m_pkthdr.len, (caddr_t)&txd[1]);\n        m_freem(m);\n\n        data->pipe = pipe;\n        usbd_setup_xfer(data->xfer, pipe, data, data->buf, xferlen,\n            USBD_FORCE_SHORT_XFER | USBD_NO_COPY, RSU_TX_TIMEOUT,\n            rsu_txeof);\n        error = usbd_transfer(data->xfer);\n        if (__predict_false(error != USBD_IN_PROGRESS && error != 0)) {\n                /* Put this Tx buffer back to our free list. */\n                TAILQ_INSERT_TAIL(&sc->tx_free_list, data, next);\n                return (error);\n        }\n        ieee80211_release_node(ic, ni);\n        return (0);\n}\n\n\nOpenBSD\u306eif_rsu.c\u3092\u8aad\u3093\u3067\u307f\u307e\u3057\u305f\u3002\n\nif_rsu.c\u306fRealtek\u306eWi-Fi\u30c1\u30c3\u30d7\u7528\u306e\u30c7\u30d0\u30a4\u30b9\u30c9\u30e9\u30a4\u30d0\u306e\u30bd\u30fc\u30b9\u30b3\u30fc\u30c9\u3067\u3059\u3002\n\n\u5b9f\u88c5\u3055\u308c\u3066\u3044\u308b\u6a5f\u80fd\u304c\u3068\u3066\u3082\u5c11\u306a\u3044\u306e\u3067\u8aad\u307f\u3084\u3059\u3044\u3067\u3059\u3002\n\n# \u5bfe\u8c61\n* http://cvsweb.openbsd.org/cgi-bin/cvsweb/src/sys/dev/usb/if_rsu.c?rev=1.34&content-type=text/x-cvsweb-markup\n\n# if_rsu.c\u306e\u5bfe\u5fdc\u6a5f\u80fd\n* 802.11n 802.11g 802.11b\n* STA\n* \u6697\u53f7\u5316\u306a\u3057\u3001WEP\u3001WPA2 (\u6697\u53f7\u5316\u306f\u30c9\u30e9\u30a4\u30d0\u5074\u3067\u884c\u3046)\n* 802.11e \u306eQoS\n* USB\n\n# \u5bfe\u5fdc\u30c1\u30c3\u30d7\n* RTL8171\n* RTL8172\n* RTL8173\n* RTL8174\n* RTL8712\n* RTL8713\n* RTL8188SU\n* RTL8191SU\n* RTL8192SU\n\n\n# USB\u306e\u30a8\u30f3\u30c9\u30dd\u30a4\u30f3\u30c8\n* \u30c7\u30a3\u30b9\u30af\u30ea\u30d7\u30bf\u306eid->bNumEndpoints\u306e\u6570\u5b57\u306b\u3088\u3063\u3066\u7570\u306a\u308a\u3001\u5909\u63db\u30c6\u30fc\u30d6\u30eb\u3092\u4f7f\u3063\u3066qid\u304b\u3089\u30a8\u30f3\u30c9\u30dd\u30a4\u30f3\u30c8\u306e\u6570\u5b57\u3092\u5c0e\u51fa\u3059\u308b\u3002\n* 4\n * rsu_qid2idx_4ep[]  = { 3, 3, 3, 1, 1, 2, 2, 0, 3, 0 }; \n* 6\n * rsu_qid2idx_6ep[]  = { 3, 3, 3, 1, 4, 2, 5, 0, 3, 0 }; \n* 11\n * rsu_qid2idx_11ep[] = { 7, 9, 8, 1, 4, 2, 5, 0, 3, 6 };\n\n* qid\u306e\u5b9a\u6570\n\n```\n/* Queue ids (used by soft only). */\n#define RSU_QID_BCN     0\n#define RSU_QID_MGT     1\n#define RSU_QID_BMC     2\n#define RSU_QID_VO      3\n#define RSU_QID_VI      4\n#define RSU_QID_BE      5\n#define RSU_QID_BK      6\n#define RSU_QID_RXOFF   7\n#define RSU_QID_H2C     8\n#define RSU_QID_C2H     9\n```\n* \u4f7f\u7528\u3059\u308b\u30a8\u30f3\u30c9\u30dd\u30a4\u30f3\u30c8\n * 1 : \u30c7\u30fc\u30bf\u9001\u4fe1 ( RSU_QID_BE )\n * 3 : \u30b3\u30de\u30f3\u30c9\u9001\u4fe1 ( RSU_QID_H2C )\n\n\n\n# \u30b3\u30de\u30f3\u30c9\n## \u30b3\u30de\u30f3\u30c9\u9001\u4fe1\n\n* Tx descriptor\u3092\u7528\u610f\n* command heeadr\u3092\u7528\u610f\n* command payload\u3092\u7528\u610f\n* RSU_QID_H2C\u306b\u5bfe\u5fdc\u3059\u308bendpoint 3\u306b usbd_setup_xfer() usbd_transfer()\u3067\u9001\u4fe1\u3002\n\n\n```c\nint\nrsu_fw_cmd(struct rsu_softc *sc, uint8_t code, void *buf, int len)\n{\n        struct rsu_tx_data *data;\n        struct r92s_tx_desc *txd;\n        struct r92s_fw_cmd_hdr *cmd;\n        struct usbd_pipe *pipe;\n        int cmdsz, xferlen;\n\n        data = sc->fwcmd_data;\n\n        /* Round-up command length to a multiple of 8 bytes. */\n        cmdsz = (len + 7) & ~7;\n\n        xferlen = sizeof(*txd) + sizeof(*cmd) + cmdsz;\n        KASSERT(xferlen <= RSU_TXBUFSZ);\n        memset(data->buf, 0, xferlen);\n\n        /* Setup Tx descriptor. */\n        txd = (struct r92s_tx_desc *)data->buf;\n        txd->txdw0 = htole32(\n            SM(R92S_TXDW0_OFFSET, sizeof(*txd)) |\n            SM(R92S_TXDW0_PKTLEN, sizeof(*cmd) + cmdsz) |\n            R92S_TXDW0_OWN | R92S_TXDW0_FSG | R92S_TXDW0_LSG);\n        txd->txdw1 = htole32(SM(R92S_TXDW1_QSEL, R92S_TXDW1_QSEL_H2C));\n\n        /* Setup command header. */\n        cmd = (struct r92s_fw_cmd_hdr *)&txd[1];\n        cmd->len = htole16(cmdsz);\n        cmd->code = code;\n        cmd->seq = sc->cmd_seq;\n        sc->cmd_seq = (sc->cmd_seq + 1) & 0x7f;\n\n        /* Copy command payload. */\n        memcpy(&cmd[1], buf, len);\n\n        DPRINTFN(2, (\"Tx cmd code=%d len=%d\\n\", code, cmdsz));\n        pipe = sc->pipe[sc->qid2idx[RSU_QID_H2C]];\n        usbd_setup_xfer(data->xfer, pipe, NULL, data->buf, xferlen,\n            USBD_SHORT_XFER_OK | USBD_NO_COPY | USBD_SYNCHRONOUS,\n            RSU_CMD_TIMEOUT, NULL);\n        return (usbd_transfer(data->xfer));\n}\n```\n\n## \u30b3\u30de\u30f3\u30c9\u306e\u7a2e\u985e\n\n* \u30bd\u30fc\u30b9\u30b3\u30fc\u30c9\u5185\u3067\u4f7f\u3063\u3066\u3044\u308b\u30b3\u30de\u30f3\u30c9\n\n```\n#define R92S_CMD_JOIN_BSS               14\n#define R92S_CMD_DISCONNECT             15\n#define R92S_CMD_SET_OPMODE             17\n#define R92S_CMD_SITE_SURVEY            18\n#define R92S_CMD_SET_AUTH               19\n#define R92S_CMD_SET_KEY                20\n#define R92S_CMD_SET_PWR_MODE           36\n#define R92S_CMD_SET_MAC_ADDRESS        58\n\n```\n\n# AP\u306b\u63a5\u7d9a\n\n* R92S_CMD_SET_OPMODE\u30b3\u30de\u30f3\u30c9\u3092\u9001\u4fe1\n* R92S_CMD_SET_AUTH\u30b3\u30de\u30f3\u30c9\u3092\u9001\u4fe1 (WPA or Open)\n* \u5f15\u6570ni\u304b\u3089\u63a5\u7d9a\u5148AP\u306e\u60c5\u5831\u3092bss\u306b\u7528\u610f\n* \u4ed8\u52a0\u3059\u308bIE\u306e\u60c5\u5831\u3092frm\u306b\u7528\u610f\u3002\n* R92S_CMD_JOIN_BSS\u30b3\u30de\u30f3\u30c9\n\n```c\nint\nrsu_join_bss(struct rsu_softc *sc, struct ieee80211_node *ni)\n{\n        struct ieee80211com *ic = &sc->sc_ic;\n        struct ndis_wlan_bssid_ex *bss;\n        struct ndis_802_11_fixed_ies *fixed;\n        struct r92s_fw_cmd_auth auth;\n        uint8_t buf[sizeof(*bss) + 128], *frm;\n        uint8_t opmode;\n        int error;\n\n        /* Let the FW decide the opmode based on the capinfo field. */\n        opmode = NDIS802_11AUTOUNKNOWN;\n        DPRINTF((\"setting operating mode to %d\\n\", opmode));\n        error = rsu_fw_cmd(sc, R92S_CMD_SET_OPMODE, &opmode, sizeof(opmode));\n        if (error != 0)\n                return (error);\n\n        memset(&auth, 0, sizeof(auth));\n        if (ic->ic_flags & IEEE80211_F_RSNON) {\n                auth.mode = R92S_AUTHMODE_WPA;\n                auth.dot1x = ieee80211_is_8021x_akm(ni->ni_rsnakms);\n        } else\n                auth.mode = R92S_AUTHMODE_OPEN;\n        DPRINTF((\"setting auth mode to %d\\n\", auth.mode));\n        error = rsu_fw_cmd(sc, R92S_CMD_SET_AUTH, &auth, sizeof(auth));\n        if (error != 0)\n                return (error);\n\n        memset(buf, 0, sizeof(buf));\n        bss = (struct ndis_wlan_bssid_ex *)buf;\n        IEEE80211_ADDR_COPY(bss->macaddr, ni->ni_bssid);\n        bss->ssid.ssidlen = htole32(ni->ni_esslen);\n        memcpy(bss->ssid.ssid, ni->ni_essid, ni->ni_esslen);\n        if (ic->ic_flags & (IEEE80211_F_WEPON | IEEE80211_F_RSNON))\n                bss->privacy = htole32(1);\n        bss->rssi = htole32(ni->ni_rssi);\n        if (ic->ic_curmode == IEEE80211_MODE_11B)\n                bss->networktype = htole32(NDIS802_11DS);\n        else\n                bss->networktype = htole32(NDIS802_11OFDM24);\n        bss->config.len = htole32(sizeof(bss->config));\n        bss->config.bintval = htole32(ni->ni_intval);\n        bss->config.dsconfig = htole32(ieee80211_chan2ieee(ic, ni->ni_chan));\n        bss->inframode = htole32(NDIS802_11INFRASTRUCTURE);\n        memcpy(bss->supprates, ni->ni_rates.rs_rates,\n            ni->ni_rates.rs_nrates);\n        /* Write the fixed fields of the beacon frame. */\n        fixed = (struct ndis_802_11_fixed_ies *)&bss[1];\n        memcpy(&fixed->tstamp, ni->ni_tstamp, 8);\n        fixed->bintval = htole16(ni->ni_intval);\n        fixed->capabilities = htole16(ni->ni_capinfo);\n        /* Write IEs to be included in the association request. */\n        frm = (uint8_t *)&fixed[1];\n        if ((ic->ic_flags & IEEE80211_F_RSNON) &&\n            (ni->ni_rsnprotos & IEEE80211_PROTO_RSN))\n                frm = ieee80211_add_rsn(frm, ic, ni);\n        if (ni->ni_flags & IEEE80211_NODE_QOS)\n                frm = ieee80211_add_qos_capability(frm, ic);\n        if (ni->ni_flags & IEEE80211_NODE_QOS)\n                frm = ieee80211_add_qos_capability(frm, ic);\n        if (ni->ni_flags & IEEE80211_NODE_HT)\n                frm = ieee80211_add_htcaps(frm, ic);\n        if ((ic->ic_flags & IEEE80211_F_RSNON) &&\n            (ni->ni_rsnprotos & IEEE80211_PROTO_WPA))\n                frm = ieee80211_add_wpa(frm, ic, ni);\n        bss->ieslen = htole32(frm - (uint8_t *)fixed);\n        bss->len = htole32(((frm - buf) + 3) & ~3);\n        DPRINTF((\"sending join bss command to %s chan %d\\n\",\n            ether_sprintf(bss->macaddr), letoh32(bss->config.dsconfig)));\n        return (rsu_fw_cmd(sc, R92S_CMD_JOIN_BSS, buf, sizeof(buf)));\n}\n```\n\n# AP\u304b\u3089\u5207\u65ad\n\n* R92S_CMD_DISCONNECT\u30b3\u30de\u30f3\u30c9\u3092\u9001\u4fe1\n\n```c\nint\nrsu_disconnect(struct rsu_softc *sc)\n{\n        uint32_t zero = 0;      /* :-) */\n\n        /* Disassociate from our current BSS. */\n        DPRINTF((\"sending disconnect command\\n\"));\n        return (rsu_fw_cmd(sc, R92S_CMD_DISCONNECT, &zero, sizeof(zero)));\n}\n```\n\n# \u30c7\u30fc\u30bf\u9001\u4fe1\n\n* WPA\u6709\u52b9\u306a\u3089\u3001ieee80211_get_txkey()\u306e\u9375\u3092\u4f7f\u3063\u3066ieee80211_encrypt()\u3067\u6697\u53f7\u5316\u3059\u308b\u3002\n* endpoint\u3092\u9078\u629e\u3002QoS\u3092\u4f7f\u308f\u306a\u3044\u306a\u3089 RSU_QID_BE\u306b\u5bfe\u5fdc\u3059\u308bEndpoint 0\u3092\u9078\u629e\u3002\n* Tx descriptor\u3092\u7528\u610f\n* \u9001\u4fe1\u30c7\u30fc\u30bf\u3092\u7528\u610f\n* usbd_setup_xfer() usbd_transfer()\u3067\u9001\u4fe1\u3002\n\n\n```c\nint\nrsu_tx(struct rsu_softc *sc, struct mbuf *m, struct ieee80211_node *ni)\n{\n        struct ieee80211com *ic = &sc->sc_ic;\n        struct ieee80211_frame *wh;\n        struct ieee80211_key *k = NULL;\n        struct rsu_tx_data *data;\n        struct r92s_tx_desc *txd;\n        struct usbd_pipe *pipe;\n        uint16_t qos;\n        uint8_t type, qid, tid = 0;\n        int hasqos, xferlen, error;\n\n        wh = mtod(m, struct ieee80211_frame *);\n        type = wh->i_fc[0] & IEEE80211_FC0_TYPE_MASK;\n\n        if (wh->i_fc[1] & IEEE80211_FC1_PROTECTED) {\n                k = ieee80211_get_txkey(ic, wh, ni);\n                if ((m = ieee80211_encrypt(ic, m, k)) == NULL)\n                        return (ENOBUFS);\n                wh = mtod(m, struct ieee80211_frame *);\n        }\n        if ((hasqos = ieee80211_has_qos(wh))) {\n                qos = ieee80211_get_qos(wh);\n                tid = qos & IEEE80211_QOS_TID;\n                qid = rsu_ac2qid[ieee80211_up_to_ac(ic, tid)];\n        } else\n                qid = RSU_QID_BE;\n\n        /* Get the USB pipe to use for this queue id. */\n        pipe = sc->pipe[sc->qid2idx[qid]];\n\n        /* Grab a Tx buffer from our free list. */\n        data = TAILQ_FIRST(&sc->tx_free_list);\n        TAILQ_REMOVE(&sc->tx_free_list, data, next);\n\n        /* Fill Tx descriptor. */\n        txd = (struct r92s_tx_desc *)data->buf;\n        memset(txd, 0, sizeof(*txd));\n\n        txd->txdw0 |= htole32(\n            SM(R92S_TXDW0_PKTLEN, m->m_pkthdr.len) |\n            SM(R92S_TXDW0_OFFSET, sizeof(*txd)) |\n            R92S_TXDW0_OWN | R92S_TXDW0_FSG | R92S_TXDW0_LSG);\n\n        txd->txdw1 |= htole32(\n            SM(R92S_TXDW1_MACID, R92S_MACID_BSS) |\n            SM(R92S_TXDW1_QSEL, R92S_TXDW1_QSEL_BE));\n        if (!hasqos)\n                txd->txdw1 |= htole32(R92S_TXDW1_NONQOS);\n#ifdef notyet\n        if (k != NULL) {\n                switch (k->k_cipher) {\n                case IEEE80211_CIPHER_WEP40:\n                case IEEE80211_CIPHER_WEP104:\n                        cipher = R92S_TXDW1_CIPHER_WEP;\n                        break;\n                case IEEE80211_CIPHER_TKIP:\n                        cipher = R92S_TXDW1_CIPHER_TKIP;\n                        break;\n                case IEEE80211_CIPHER_CCMP:\n                        cipher = R92S_TXDW1_CIPHER_AES;\n                       break;\n                default:\n                        cipher = R92S_TXDW1_CIPHER_NONE;\n                }\n                txd->txdw1 |= htole32(\n                    SM(R92S_TXDW1_CIPHER, cipher) |\n                    SM(R92S_TXDW1_KEYIDX, k->k_id));\n        }\n#endif\n        txd->txdw2 |= htole32(R92S_TXDW2_BK);\n        if (IEEE80211_IS_MULTICAST(wh->i_addr1))\n                txd->txdw2 |= htole32(R92S_TXDW2_BMCAST);\n        /*\n         * Firmware will use and increment the sequence number for the\n         * specified TID.\n         */\n        txd->txdw3 |= htole32(SM(R92S_TXDW3_SEQ, tid));\n\n#if NBPFILTER > 0\n        if (__predict_false(sc->sc_drvbpf != NULL)) {\n                struct rsu_tx_radiotap_header *tap = &sc->sc_txtap;\n                struct mbuf mb;\n\n                tap->wt_flags = 0;\n                tap->wt_chan_freq = htole16(ic->ic_bss->ni_chan->ic_freq);\n                tap->wt_chan_flags = htole16(ic->ic_bss->ni_chan->ic_flags);\n\n                mb.m_data = (caddr_t)tap;\n                mb.m_len = sc->sc_txtap_len;\n                mb.m_next = m;\n                mb.m_nextpkt = NULL;\n                mb.m_type = 0;\n                mb.m_flags = 0;\n                bpf_mtap(sc->sc_drvbpf, &mb, BPF_DIRECTION_OUT);\n        }\n#endif\n\n        xferlen = sizeof(*txd) + m->m_pkthdr.len;\n        m_copydata(m, 0, m->m_pkthdr.len, (caddr_t)&txd[1]);\n        m_freem(m);\n\n        data->pipe = pipe;\n        usbd_setup_xfer(data->xfer, pipe, data, data->buf, xferlen,\n            USBD_FORCE_SHORT_XFER | USBD_NO_COPY, RSU_TX_TIMEOUT,\n            rsu_txeof);\n        error = usbd_transfer(data->xfer);\n        if (__predict_false(error != USBD_IN_PROGRESS && error != 0)) {\n                /* Put this Tx buffer back to our free list. */\n                TAILQ_INSERT_TAIL(&sc->tx_free_list, data, next);\n                return (error);\n        }\n        ieee80211_release_node(ic, ni);\n        return (0);\n}\n```\n\n", "tags": ["Wi-Fi", "OpenBSD"]}