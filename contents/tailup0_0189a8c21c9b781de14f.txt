{"context": "\u30d6\u30ed\u30c3\u30af\u30c1\u30a7\u30fc\u30f3\u3068\u304b\u30d3\u30c3\u30c8\u30b3\u30a4\u30f3\u306e\u3053\u3068\u3092\u8abf\u3079\u3066\u3066\u3001SHA-256\u306e\u4ed5\u69d8\u304c\u6c17\u306b\u306a\u3063\u305f\u306e\u3067ruby\u3067\u81ea\u524d\u5b9f\u88c5\u3057\u307e\u3057\u305f\u3002\n\u8ab0\u304b\u306e\u5b66\u7fd2\u306e\u7ce7\u306b\u306a\u308c\u3070\u5e78\u3044\u3067\u3059\u3002\n\u30dd\u30a4\u30f3\u30c8\u306f\u3001\u30d1\u30c7\u30a3\u30f3\u30b0\u51e6\u7406\u3068\u30ed\u30fc\u30c6\u30fc\u30b7\u30e7\u30f3\uff1f\u51e6\u7406\u3068\u601d\u3044\u307e\u3059\u3002\n\ngithub\ntailup0/sha256.rb\n\n\u53c2\u8003url\nNIST.FIPS.180-4\nwiz-code.net\n\nsha256.rb\n#!/usr/bin/env ruby\nclass Sha256\n  # \u5b9a\u6570K\n  INT_K = ['428a2f98', '71374491', 'b5c0fbcf', 'e9b5dba5', '3956c25b', '59f111f1', '923f82a4', 'ab1c5ed5',\n           'd807aa98', '12835b01', '243185be', '550c7dc3', '72be5d74', '80deb1fe', '9bdc06a7', 'c19bf174',\n           'e49b69c1', 'efbe4786', '0fc19dc6', '240ca1cc', '2de92c6f', '4a7484aa', '5cb0a9dc', '76f988da',\n           '983e5152', 'a831c66d', 'b00327c8', 'bf597fc7', 'c6e00bf3', 'd5a79147', '06ca6351', '14292967',\n           '27b70a85', '2e1b2138', '4d2c6dfc', '53380d13', '650a7354', '766a0abb', '81c2c92e', '92722c85',\n           'a2bfe8a1', 'a81a664b', 'c24b8b70', 'c76c51a3', 'd192e819', 'd6990624', 'f40e3585', '106aa070',\n           '19a4c116', '1e376c08', '2748774c', '34b0bcb5', '391c0cb3', '4ed8aa4a', '5b9cca4f', '682e6ff3',\n           '748f82ee', '78a5636f', '84c87814', '8cc70208', '90befffa', 'a4506ceb', 'bef9a3f7', 'c67178f2']\n\n  # \u30cf\u30c3\u30b7\u30e5\u306e\u521d\u671f\u5024\n  # \u30b5\u30a4\u30ba: 32bit(4Byte) x 8 = 256bit\n  INITIAL_HATH = ['6a09e667', 'bb67ae85', '3c6ef372', 'a54ff53a',\n                  '510e527f', '9b05688c', '1f83d9ab', '5be0cd19']\n\n  # \uff11\u30ef\u30fc\u30c9\u3042\u305f\u308a\u306e\u30d3\u30c3\u30c8\u6570\n  W = 32\n\n  # Helper\n  # \u53f3\u30d3\u30c3\u30c8\u30b7\u30d5\u30c8(SHift Right)\n  def SHR(v, n)\n    v >> n\n  end\n  # \u5de6\u30d3\u30c3\u30c8\u30b7\u30d5\u30c8(SHift Left)\n  def SHL(v, n)\n    v << n\n  end\n  # \u53f3\u30d3\u30c3\u30c8\u56de\u8ee2(ROTate Right)\n  def ROTR(v, n)\n    (\"%0#{W}b\" % v).split(\"\").rotate(-n).join.to_i(2)\n  end\n  # \u5de6\u30d3\u30c3\u30c8\u56de\u8ee2(ROTate Left)\n  def ROTL(v, n)\n    (\"%0#{W}b\" % v).split(\"\").rotate(n).join.to_i(2)\n  end\n  # \u5f15\u6570\u3092\u3059\u3079\u3066\u52a0\u7b97\u3057\u300132bit\u4ee5\u4e0a\u306e\u6841\u306b\u3064\u3044\u3066\u306f\u7834\u68c4\u3059\u308b\n  def ShaAdd(*v)\n    v.inject(:+) & 0xFFFFFFFF\n  end\n  def Int32Str(v)\n    (\"%08x\" % v)[-8,8]\n  end\n  # \u6587\u5b57\u5217\u3092\u6307\u5b9a\u6587\u5b57\u6570\u305a\u3064\u914d\u5217\u306b\u3059\u308b\n  def S2Ar(s, n)\n    s.scan(/.{1,#{n}}/)\n  end\n  def ArrayEach64byte(bytes)\n    i = 0\n    resAr = []\n    ar = []\n    bytes.each{|byte|\n      i += 1\n      ar.push(byte)\n      if i % 64 == 0\n        resAr.push(ar)\n        ar = []\n      end\n    }\n    resAr\n  end\n\n  # \u30cf\u30c3\u30b7\u30e5\u8a08\u7b97\u7528\u95a2\u6570\n  # Ch\n  def Ch(x, y, z)\n    (x & y) ^ (~x & z)\n  end\n  # Maj\n  def Maj(x, y, z)\n    (x & y) ^ (x & z) ^ (y & z)\n  end\n  # \u30b7\u30b0\u30deA0(\u03a30)\n  def SigmaA0(x)\n    ROTR(x, 2) ^ ROTR(x, 13) ^ ROTR(x, 22)\n  end\n  # \u30b7\u30b0\u30deA1(\u03a31)\n  def SigmaA1(x)\n    ROTR(x, 6) ^ ROTR(x, 11) ^ ROTR(x, 25)\n  end\n  # \u30b7\u30b0\u30deB0(\u03c30)\n  def SigmaB0(x)\n    ROTR(x, 7) ^ ROTR(x, 18) ^ SHR(x, 3)\n  end\n  # \u30b7\u30b0\u30deB1(\u03c31)\n  def SigmaB1(x)\n    ROTR(x, 17) ^ ROTR(x, 19) ^ SHR(x, 10)\n  end\n\n  # \u4e0e\u3048\u3089\u308c\u305f\u30d6\u30ed\u30c3\u30af\u306e\u30ed\u30fc\u30c6\u30fc\u30b7\u30e7\u30f3\u51e6\u7406\u3092\u884c\u3046\n  def Computation(hash, block)\n    intW = Array.new(64) # block\u304b\u3089\u751f\u6210\u3055\u308c\u308b64Byte\u306e\u914d\u5217\n\n    # \u73fe\u5728\u306e\u30cf\u30c3\u30b7\u30e5\u3092\u8907\u88fd\n    intA = hash[0].to_i(16)\n    intB = hash[1].to_i(16)\n    intC = hash[2].to_i(16)\n    intD = hash[3].to_i(16)\n    intE = hash[4].to_i(16)\n    intF = hash[5].to_i(16)\n    intG = hash[6].to_i(16)\n    intH = hash[7].to_i(16)\n\n    # \u30ed\u30fc\u30c6\u30fc\u30b7\u30e7\u30f3\u51e6\u7406\n    # \u5b9a\u6570K\u3084intW(Block\u306e\u914d\u5217)\u3001\u73fe\u5728\u306e\u30cf\u30c3\u30b7\u30e5\u5024\u306a\u3069\u3092\u7528\u3044\u306664\u56de\u3001\n    # \u30cf\u30c3\u30b7\u30e5\u5024\u3092\u30ed\u30fc\u30c6\u30fc\u30b7\u30e7\u30f3\u3055\u305b\u308b\n    # intW\u306e\u914d\u5217\u306f\u56de\u8ee2\u3055\u305b\u306a\u304c\u3089\u4f5c\u308b\n    0.upto(63){|i|\n      if i < 16\n      # 0-15\u306f\u3001Block\u306e\u914d\u5217\u30924byte\u305a\u3064\u4ee3\u5165\u3057\u3066\u3044\u304f\n        ar = []\n        ar.push(block[4 * i])\n        ar.push(block[1 + 4 * i])\n        ar.push(block[2 + 4 * i])\n        ar.push(block[3 + 4 * i])\n        intW[i] = ar.join.to_i(16)\n      else\n      # 16-63\u306f\u3001\u3059\u3067\u306b\u4ee3\u5165\u3055\u308c\u305f\u5024\u304b\u3089\u751f\u6210\u3059\u308b\n        intW[i] = ShaAdd(SigmaB1(intW[i - 2]), intW[i - 7],\n                         SigmaB0(intW[i - 15]), intW[i - 16])\n      end\n\n      # \u30ed\u30fc\u30c6\u30fc\u30b7\u30e7\u30f3\u6642\u306b\u5909\u5316\u3092\u4e0e\u3048\u308b\u5024\u3092\u7b97\u51fa\n      t1 = ShaAdd(intH, SigmaA1(intE), Ch(intE, intF, intG), INT_K[i].to_i(16), intW[i])\n      t2 = ShaAdd(SigmaA0(intA), Maj(intA, intB, intC))\n\n      # \u30cf\u30c3\u30b7\u30e5\u5024\u30ed\u30fc\u30c6\u30fc\u30b7\u30e7\u30f3\n      # (intE\u3068intA\u3067\u5909\u5316\u3092\u4e0e\u3048\u308b\u3002\u3053\u3053\u3067\u5931\u308f\u308c\u308bintH\u306ft1\u306e\u8a08\u7b97\u306b\u4f7f\u308f\u308c\u3066\u3044\u308b)\n      intH = intG\n      intG = intF\n      intF = intE\n      intE = ShaAdd(intD, t1)\n      intD = intC\n      intC = intB\n      intB = intA\n      intA = ShaAdd(t1, t2)\n    }\n\n    # \u7b97\u51fa\u3055\u308c\u305f\u30cf\u30c3\u30b7\u30e5\u3092\u73fe\u5728\u306e\u30cf\u30c3\u30b7\u30e5\u306b\u52a0\u7b97\n    resHash = Array.new(8)\n    resHash[0] = Int32Str(ShaAdd(hash[0].to_i(16), intA))\n    resHash[1] = Int32Str(ShaAdd(hash[1].to_i(16), intB))\n    resHash[2] = Int32Str(ShaAdd(hash[2].to_i(16), intC))\n    resHash[3] = Int32Str(ShaAdd(hash[3].to_i(16), intD))\n    resHash[4] = Int32Str(ShaAdd(hash[4].to_i(16), intE))\n    resHash[5] = Int32Str(ShaAdd(hash[5].to_i(16), intF))\n    resHash[6] = Int32Str(ShaAdd(hash[6].to_i(16), intG))\n    resHash[7] = Int32Str(ShaAdd(hash[7].to_i(16), intH))\n    resHash\n  end\n\n  def Padding(bytes)\n    bytes = S2Ar(bytes, 2)\n\n    # \u5143\u306e\u30c7\u30fc\u30bf\u306e\u30d0\u30a4\u30c8\u6570\n    orgByteLength = bytes.length\n    # \u5143\u306e\u30c7\u30fc\u30bf\u306e\u30d3\u30c3\u30c8\u6570\n    orgBitLength = orgByteLength * 8\n    # \u5143\u306e\u30c7\u30fc\u30bf\u306e\u30d3\u30c3\u30c8\u6570\u306e16\u9032\u6570\u6587\u5b57\u5217\n    orgBitLengthString = orgBitLength.to_s(16)\n    # \u6570\u5024\u309216\u9032\u6570\u6587\u5b57\u5217\u306b\u3059\u308b\u969b\u3001\u6587\u5b57\u5217\u306e\u9577\u3055\u3092\u8abf\u6574\u3059\u308b\u70ba0\u57cb\u3081\n    if orgBitLengthString.length.odd?\n      orgBitLengthString = '0' + orgBitLengthString\n    end\n    # \u5143\u306e\u30c7\u30fc\u30bf\u306e\u30d3\u30c3\u30c8\u6570\u306e16\u9032\u6570\u6587\u5b57\u5217\u81ea\u4f53\u306e\u30d0\u30a4\u30c8\u6570\n    orgBitLengthStringByteLength = S2Ar(orgBitLengthString, 2).length\n\n    ## \u5143\u306e\u30c7\u30fc\u30bf\u672b\u5c3e\u306bbit\u3092\u7acb\u3066\u308b\n    bytes.push('80')\n    # \u6700\u5f8c\u306e\u30d6\u30ed\u30c3\u30af\u304c56\u30d0\u30a4\u30c8\u3092\u8d85\u3048\u308b\u5834\u5408\u306f\u3001\u30d6\u30ed\u30c3\u30af\u306e\u7dcf\u6570\u3092\uff11\u3064\u5897\u3084\u3059\n    if bytes.length % 64 > 56\n      blockCount = bytes.length / 64 + 2\n    else\n      blockCount = bytes.length / 64 + 1\n    end\n    # 00\u57cb\u3081\u3059\u308b\u500b\u6570\n    padLength = blockCount * 64 - bytes.length - orgBitLengthStringByteLength\n    padLength.times{\n      bytes.push('00')\n    }\n    S2Ar(bytes.join + orgBitLengthString, 2)\n  end\n\n  # SHA-256\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0\u306b\u3088\u308a\u30e1\u30c3\u30bb\u30fc\u30b8\u30c0\u30a4\u30b8\u30a7\u30b9\u30c8(64byte)\u3092\u53d6\u5f97\u3057\u307e\u3059\u3002\n  def Hash(bytes)\n    # \u30d1\u30c7\u30a3\u30f3\u30b0\n    # \u30d6\u30ed\u30c3\u30af\u9577(64byte)\u306e\u500d\u6570\u306b\u306a\u308b\u3088\u3046\u306b\u30c7\u30fc\u30bf\u9577\u3092\u8abf\u6574\n    bytes = Padding(bytes)\n\n    # \u30d6\u30ed\u30c3\u30af\u306b\u5206\u3051\u3066\u30cf\u30c3\u30b7\u30e5\u5024\u3092\u8a08\u7b97\n    # 64byte\u3054\u3068\u306b\u5206\u3051\u3066\u30eb\u30fc\u30d7\n    intHash = INITIAL_HATH\n    bytesEach64 = ArrayEach64byte(bytes)\n    bytesEach64.each{|bytes|\n      intHash = Computation(intHash, bytes)\n    }\n    intHash.join\n  end\n\nend\n\nsha256 = Sha256.new\nv = ARGV[0]\nputs sha256.Hash(v.unpack('H*').first)\n\n\n\n\u30d6\u30ed\u30c3\u30af\u30c1\u30a7\u30fc\u30f3\u3068\u304b\u30d3\u30c3\u30c8\u30b3\u30a4\u30f3\u306e\u3053\u3068\u3092\u8abf\u3079\u3066\u3066\u3001SHA-256\u306e\u4ed5\u69d8\u304c\u6c17\u306b\u306a\u3063\u305f\u306e\u3067ruby\u3067\u81ea\u524d\u5b9f\u88c5\u3057\u307e\u3057\u305f\u3002\n\u8ab0\u304b\u306e\u5b66\u7fd2\u306e\u7ce7\u306b\u306a\u308c\u3070\u5e78\u3044\u3067\u3059\u3002\n\n\u30dd\u30a4\u30f3\u30c8\u306f\u3001\u30d1\u30c7\u30a3\u30f3\u30b0\u51e6\u7406\u3068\u30ed\u30fc\u30c6\u30fc\u30b7\u30e7\u30f3\uff1f\u51e6\u7406\u3068\u601d\u3044\u307e\u3059\u3002\n\n\n## github\n\n[tailup0/sha256.rb](https://github.com/tailup0/sha256.rb)\n\n## \u53c2\u8003url\n\n[NIST.FIPS.180-4](http://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf)\n[wiz-code.net](http://wiz-code.net/vb/algorithm/sha256/)\n\n\n```sha256.rb\n#!/usr/bin/env ruby\nclass Sha256\n  # \u5b9a\u6570K\n  INT_K = ['428a2f98', '71374491', 'b5c0fbcf', 'e9b5dba5', '3956c25b', '59f111f1', '923f82a4', 'ab1c5ed5',\n           'd807aa98', '12835b01', '243185be', '550c7dc3', '72be5d74', '80deb1fe', '9bdc06a7', 'c19bf174',\n           'e49b69c1', 'efbe4786', '0fc19dc6', '240ca1cc', '2de92c6f', '4a7484aa', '5cb0a9dc', '76f988da',\n           '983e5152', 'a831c66d', 'b00327c8', 'bf597fc7', 'c6e00bf3', 'd5a79147', '06ca6351', '14292967',\n           '27b70a85', '2e1b2138', '4d2c6dfc', '53380d13', '650a7354', '766a0abb', '81c2c92e', '92722c85',\n           'a2bfe8a1', 'a81a664b', 'c24b8b70', 'c76c51a3', 'd192e819', 'd6990624', 'f40e3585', '106aa070',\n           '19a4c116', '1e376c08', '2748774c', '34b0bcb5', '391c0cb3', '4ed8aa4a', '5b9cca4f', '682e6ff3',\n           '748f82ee', '78a5636f', '84c87814', '8cc70208', '90befffa', 'a4506ceb', 'bef9a3f7', 'c67178f2']\n\n  # \u30cf\u30c3\u30b7\u30e5\u306e\u521d\u671f\u5024\n  # \u30b5\u30a4\u30ba: 32bit(4Byte) x 8 = 256bit\n  INITIAL_HATH = ['6a09e667', 'bb67ae85', '3c6ef372', 'a54ff53a',\n                  '510e527f', '9b05688c', '1f83d9ab', '5be0cd19']\n\n  # \uff11\u30ef\u30fc\u30c9\u3042\u305f\u308a\u306e\u30d3\u30c3\u30c8\u6570\n  W = 32\n\n  # Helper\n  # \u53f3\u30d3\u30c3\u30c8\u30b7\u30d5\u30c8(SHift Right)\n  def SHR(v, n)\n    v >> n\n  end\n  # \u5de6\u30d3\u30c3\u30c8\u30b7\u30d5\u30c8(SHift Left)\n  def SHL(v, n)\n    v << n\n  end\n  # \u53f3\u30d3\u30c3\u30c8\u56de\u8ee2(ROTate Right)\n  def ROTR(v, n)\n    (\"%0#{W}b\" % v).split(\"\").rotate(-n).join.to_i(2)\n  end\n  # \u5de6\u30d3\u30c3\u30c8\u56de\u8ee2(ROTate Left)\n  def ROTL(v, n)\n    (\"%0#{W}b\" % v).split(\"\").rotate(n).join.to_i(2)\n  end\n  # \u5f15\u6570\u3092\u3059\u3079\u3066\u52a0\u7b97\u3057\u300132bit\u4ee5\u4e0a\u306e\u6841\u306b\u3064\u3044\u3066\u306f\u7834\u68c4\u3059\u308b\n  def ShaAdd(*v)\n    v.inject(:+) & 0xFFFFFFFF\n  end\n  def Int32Str(v)\n    (\"%08x\" % v)[-8,8]\n  end\n  # \u6587\u5b57\u5217\u3092\u6307\u5b9a\u6587\u5b57\u6570\u305a\u3064\u914d\u5217\u306b\u3059\u308b\n  def S2Ar(s, n)\n    s.scan(/.{1,#{n}}/)\n  end\n  def ArrayEach64byte(bytes)\n    i = 0\n    resAr = []\n    ar = []\n    bytes.each{|byte|\n      i += 1\n      ar.push(byte)\n      if i % 64 == 0\n        resAr.push(ar)\n        ar = []\n      end\n    }\n    resAr\n  end\n\n  # \u30cf\u30c3\u30b7\u30e5\u8a08\u7b97\u7528\u95a2\u6570\n  # Ch\n  def Ch(x, y, z)\n    (x & y) ^ (~x & z)\n  end\n  # Maj\n  def Maj(x, y, z)\n    (x & y) ^ (x & z) ^ (y & z)\n  end\n  # \u30b7\u30b0\u30deA0(\u03a30)\n  def SigmaA0(x)\n    ROTR(x, 2) ^ ROTR(x, 13) ^ ROTR(x, 22)\n  end\n  # \u30b7\u30b0\u30deA1(\u03a31)\n  def SigmaA1(x)\n    ROTR(x, 6) ^ ROTR(x, 11) ^ ROTR(x, 25)\n  end\n  # \u30b7\u30b0\u30deB0(\u03c30)\n  def SigmaB0(x)\n    ROTR(x, 7) ^ ROTR(x, 18) ^ SHR(x, 3)\n  end\n  # \u30b7\u30b0\u30deB1(\u03c31)\n  def SigmaB1(x)\n    ROTR(x, 17) ^ ROTR(x, 19) ^ SHR(x, 10)\n  end\n\n  # \u4e0e\u3048\u3089\u308c\u305f\u30d6\u30ed\u30c3\u30af\u306e\u30ed\u30fc\u30c6\u30fc\u30b7\u30e7\u30f3\u51e6\u7406\u3092\u884c\u3046\n  def Computation(hash, block)\n    intW = Array.new(64) # block\u304b\u3089\u751f\u6210\u3055\u308c\u308b64Byte\u306e\u914d\u5217\n\n    # \u73fe\u5728\u306e\u30cf\u30c3\u30b7\u30e5\u3092\u8907\u88fd\n    intA = hash[0].to_i(16)\n    intB = hash[1].to_i(16)\n    intC = hash[2].to_i(16)\n    intD = hash[3].to_i(16)\n    intE = hash[4].to_i(16)\n    intF = hash[5].to_i(16)\n    intG = hash[6].to_i(16)\n    intH = hash[7].to_i(16)\n\n    # \u30ed\u30fc\u30c6\u30fc\u30b7\u30e7\u30f3\u51e6\u7406\n    # \u5b9a\u6570K\u3084intW(Block\u306e\u914d\u5217)\u3001\u73fe\u5728\u306e\u30cf\u30c3\u30b7\u30e5\u5024\u306a\u3069\u3092\u7528\u3044\u306664\u56de\u3001\n    # \u30cf\u30c3\u30b7\u30e5\u5024\u3092\u30ed\u30fc\u30c6\u30fc\u30b7\u30e7\u30f3\u3055\u305b\u308b\n    # intW\u306e\u914d\u5217\u306f\u56de\u8ee2\u3055\u305b\u306a\u304c\u3089\u4f5c\u308b\n    0.upto(63){|i|\n      if i < 16\n      # 0-15\u306f\u3001Block\u306e\u914d\u5217\u30924byte\u305a\u3064\u4ee3\u5165\u3057\u3066\u3044\u304f\n        ar = []\n        ar.push(block[4 * i])\n        ar.push(block[1 + 4 * i])\n        ar.push(block[2 + 4 * i])\n        ar.push(block[3 + 4 * i])\n        intW[i] = ar.join.to_i(16)\n      else\n      # 16-63\u306f\u3001\u3059\u3067\u306b\u4ee3\u5165\u3055\u308c\u305f\u5024\u304b\u3089\u751f\u6210\u3059\u308b\n        intW[i] = ShaAdd(SigmaB1(intW[i - 2]), intW[i - 7],\n                         SigmaB0(intW[i - 15]), intW[i - 16])\n      end\n\n      # \u30ed\u30fc\u30c6\u30fc\u30b7\u30e7\u30f3\u6642\u306b\u5909\u5316\u3092\u4e0e\u3048\u308b\u5024\u3092\u7b97\u51fa\n      t1 = ShaAdd(intH, SigmaA1(intE), Ch(intE, intF, intG), INT_K[i].to_i(16), intW[i])\n      t2 = ShaAdd(SigmaA0(intA), Maj(intA, intB, intC))\n\n      # \u30cf\u30c3\u30b7\u30e5\u5024\u30ed\u30fc\u30c6\u30fc\u30b7\u30e7\u30f3\n      # (intE\u3068intA\u3067\u5909\u5316\u3092\u4e0e\u3048\u308b\u3002\u3053\u3053\u3067\u5931\u308f\u308c\u308bintH\u306ft1\u306e\u8a08\u7b97\u306b\u4f7f\u308f\u308c\u3066\u3044\u308b)\n      intH = intG\n      intG = intF\n      intF = intE\n      intE = ShaAdd(intD, t1)\n      intD = intC\n      intC = intB\n      intB = intA\n      intA = ShaAdd(t1, t2)\n    }\n\n    # \u7b97\u51fa\u3055\u308c\u305f\u30cf\u30c3\u30b7\u30e5\u3092\u73fe\u5728\u306e\u30cf\u30c3\u30b7\u30e5\u306b\u52a0\u7b97\n    resHash = Array.new(8)\n    resHash[0] = Int32Str(ShaAdd(hash[0].to_i(16), intA))\n    resHash[1] = Int32Str(ShaAdd(hash[1].to_i(16), intB))\n    resHash[2] = Int32Str(ShaAdd(hash[2].to_i(16), intC))\n    resHash[3] = Int32Str(ShaAdd(hash[3].to_i(16), intD))\n    resHash[4] = Int32Str(ShaAdd(hash[4].to_i(16), intE))\n    resHash[5] = Int32Str(ShaAdd(hash[5].to_i(16), intF))\n    resHash[6] = Int32Str(ShaAdd(hash[6].to_i(16), intG))\n    resHash[7] = Int32Str(ShaAdd(hash[7].to_i(16), intH))\n    resHash\n  end\n\n  def Padding(bytes)\n    bytes = S2Ar(bytes, 2)\n\n    # \u5143\u306e\u30c7\u30fc\u30bf\u306e\u30d0\u30a4\u30c8\u6570\n    orgByteLength = bytes.length\n    # \u5143\u306e\u30c7\u30fc\u30bf\u306e\u30d3\u30c3\u30c8\u6570\n    orgBitLength = orgByteLength * 8\n    # \u5143\u306e\u30c7\u30fc\u30bf\u306e\u30d3\u30c3\u30c8\u6570\u306e16\u9032\u6570\u6587\u5b57\u5217\n    orgBitLengthString = orgBitLength.to_s(16)\n    # \u6570\u5024\u309216\u9032\u6570\u6587\u5b57\u5217\u306b\u3059\u308b\u969b\u3001\u6587\u5b57\u5217\u306e\u9577\u3055\u3092\u8abf\u6574\u3059\u308b\u70ba0\u57cb\u3081\n    if orgBitLengthString.length.odd?\n      orgBitLengthString = '0' + orgBitLengthString\n    end\n    # \u5143\u306e\u30c7\u30fc\u30bf\u306e\u30d3\u30c3\u30c8\u6570\u306e16\u9032\u6570\u6587\u5b57\u5217\u81ea\u4f53\u306e\u30d0\u30a4\u30c8\u6570\n    orgBitLengthStringByteLength = S2Ar(orgBitLengthString, 2).length\n\n    ## \u5143\u306e\u30c7\u30fc\u30bf\u672b\u5c3e\u306bbit\u3092\u7acb\u3066\u308b\n    bytes.push('80')\n    # \u6700\u5f8c\u306e\u30d6\u30ed\u30c3\u30af\u304c56\u30d0\u30a4\u30c8\u3092\u8d85\u3048\u308b\u5834\u5408\u306f\u3001\u30d6\u30ed\u30c3\u30af\u306e\u7dcf\u6570\u3092\uff11\u3064\u5897\u3084\u3059\n    if bytes.length % 64 > 56\n      blockCount = bytes.length / 64 + 2\n    else\n      blockCount = bytes.length / 64 + 1\n    end\n    # 00\u57cb\u3081\u3059\u308b\u500b\u6570\n    padLength = blockCount * 64 - bytes.length - orgBitLengthStringByteLength\n    padLength.times{\n      bytes.push('00')\n    }\n    S2Ar(bytes.join + orgBitLengthString, 2)\n  end\n\n  # SHA-256\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0\u306b\u3088\u308a\u30e1\u30c3\u30bb\u30fc\u30b8\u30c0\u30a4\u30b8\u30a7\u30b9\u30c8(64byte)\u3092\u53d6\u5f97\u3057\u307e\u3059\u3002\n  def Hash(bytes)\n    # \u30d1\u30c7\u30a3\u30f3\u30b0\n    # \u30d6\u30ed\u30c3\u30af\u9577(64byte)\u306e\u500d\u6570\u306b\u306a\u308b\u3088\u3046\u306b\u30c7\u30fc\u30bf\u9577\u3092\u8abf\u6574\n    bytes = Padding(bytes)\n\n    # \u30d6\u30ed\u30c3\u30af\u306b\u5206\u3051\u3066\u30cf\u30c3\u30b7\u30e5\u5024\u3092\u8a08\u7b97\n    # 64byte\u3054\u3068\u306b\u5206\u3051\u3066\u30eb\u30fc\u30d7\n    intHash = INITIAL_HATH\n    bytesEach64 = ArrayEach64byte(bytes)\n    bytesEach64.each{|bytes|\n      intHash = Computation(intHash, bytes)\n    }\n    intHash.join\n  end\n\nend\n\nsha256 = Sha256.new\nv = ARGV[0]\nputs sha256.Hash(v.unpack('H*').first)\n\n```\n\n", "tags": ["Ruby", "sha256", "Bitcoin", "Blockchain", "algorithm"]}