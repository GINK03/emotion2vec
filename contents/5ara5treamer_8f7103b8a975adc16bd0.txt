{"context": "\n\n1. \u3053\u306e\u8a18\u4e8b\u3067\u5b66\u3079\u308b\u3053\u3068\u30fb\u5b66\u3079\u306a\u3044\u3053\u3068\n\u5b66\u3079\u308b\u3053\u3068\n\n\u30c0\u30a4\u30af\u30b9\u30c8\u30e9\u6cd5\u306b\u3064\u3044\u3066\u306e\u304a\u307c\u308d\u3052\u306a\u6982\u8981\u3002\nLisp \u306b\u3088\u308b\u5b9f\u88c5\u306e\u4f8b\u3002\n\u30ea\u30d5\u30a1\u30af\u30bf\u30ea\u30f3\u30b0\u3057\u3066\u904a\u3079\u308b\u3002\n\n\u5b66\u3079\u306a\u3044\u3053\u3068\n\nLisp \u306e\u7f8e\u3057\u3044\u30b3\u30fc\u30c9\u3002\nLisp \u306e\u5d07\u9ad8\u306a\u308b\u7406\u5ff5\u3002\n\u30c0\u30a4\u30af\u30b9\u30c8\u30e9\u6cd5\u306e\u826f\u3044\u4f8b\u3002\n\n\n2. \u5b9f\u969b\u306e\u30b3\u30fc\u30c9\n\u4ee5\u524d\uff0c\u62ec\u5f27\u306e\u5c71\u3068\u6226\u3063\u3066\u307f\u305f\uff1a\u30c0\u30a4\u30af\u30b9\u30c8\u30e9\u6cd5\u3063\u3066\u4f55\u3060\u3088\uff0c\u5206\u304b\u3093\u306d\u3047\u3088\u3002\u3068\u3044\u3046\u8a18\u4e8b\u3092\u66f8\u3044\u305f\u304c\uff0c\u3068\u3046\u3068\u3046\u308f\u304b\u3063\u305f\u306e\u3067\u30b3\u30fc\u30c9\u3092\u63b2\u8f09\u3002\u591a\u5206\u5206\u304b\u3063\u3066\u3044\u308b\u4eba\u304b\u3089\u3059\u308c\u3070\u4f59\u308a\u306b\u5197\u9577\u306a\u30b3\u30fc\u30c9\u306a\u306e\u304b\u3082\u3057\u308c\u306a\u3044\u3051\u308c\u3069\uff0c\u3068\u306b\u304b\u304f\u308f\u304b\u3063\u3066\u5b09\u3057\u3044\u306e\u3067\u8f09\u305b\u308b\u3002\n\ndijkstra.lisp\n(defparameter *nodes* '(tokyo takasaki nagano nagoya niigata hukui kyoto))\n(defparameter *edges* '((tokyo takasaki 110) (takasaki tokyo 110) (tokyo nagano 230) (nagano tokyo 230) (tokyo nagoya 350) (nagoya tokyo 350) (takasaki nagano 130) (nagano takasaki 130) (nagano nagoya 280) (nagoya nagano 280) (takasaki niigata 210) (niigata takasaki 210) (nagano hukui 330) (hukui nagano 330) (nagoya kyoto 160) (kyoto nagoya 160) (niigata hukui 250) (hukui niigata 250) (hukui kyoto 190) (kyoto hukui 190)))\n\n; Node is not nil and is a symbol.\n; ex. 'tokyo\n(defun nodep (obj)\n  (and obj (symbolp obj)))\n\n; Edge is a list composed of two nodes and a number.\n; ex. '(tokyo takasaki 110)\n(defun edgep (seq)\n  (and (listp seq)\n       (eq (length seq) 3)\n       (nodep   (first  seq))\n       (nodep   (second seq))\n       (numberp (third  seq))))\n\n; Tree is a nested edge list.\n; ex. '(tokyo (takasaki nagano 130) 110)\n(defun treep (seq)\n  (when (and seq\n             (listp seq)\n             (symbolp (first  seq))\n             (numberp (third  seq)))\n    (if (listp (second seq))\n      (treep (second seq))\n      t)))\n\n; Return edges from a given node.\n(defun edges-from (node edges)\n  (labels ((start-with-p (edge)\n                         (eq (car edge) node)))\n    (when (listp edges)\n      (remove-if-not #'start-with-p edges))))\n\n; '(tokyo takasaki 110) given, \n; return ((TOKYO (TAKASAKI TOKYO 110) 110)\n;         (TOKYO (TAKASAKI NAGANO 130) 110)\n;         (TOKYO (TAKASAKI NIIGATA 210) 110)).\n(defun edge-trees (seq)\n  (let ((head (car seq)) (tail (cdr seq)))\n    (cond ((edgep seq) (mapcar (lambda (tree)\n                                 (list head tree (cadr tail)))\n                               (edges-from (car tail) *edges*)))\n          ((treep seq) (mapcar (lambda (edge)\n                                 (list head edge (cadr tail)))\n                               (edge-trees (car tail)))))))\n\n; '(tokyo takasaki 110) given, return 110.\n; '(tokyo (takasaki (niigata hukui 250) 210) 110) given, return 570.\n(defun tree-length (seq &optional (len 0))\n  (cond ((edgep seq) (+ (caddr seq) len))\n        ((treep seq) (tree-length (cadr seq) (+ (caddr seq) len)))))\n\n; Return the shortest edge from edge list.\n(defun shortest-edge (edges &optional shortest)\n  (when (not shortest)\n    (setf shortest (car edges)))\n  (let ((head (car edges)) (tail (cdr edges)))\n    (if edges\n      (if (< (tree-length head) (tree-length shortest))\n        (shortest-edge tail head)\n        (shortest-edge tail shortest))\n      shortest)))\n\n; '(tokyo (takasaki nagano 130) 110) given,\n; return NAGANO.\n(defun get-end-node (obj)\n  (cond ((nodep obj) obj)\n        ((edgep obj) (cadr obj))\n        ((treep obj) (get-end-node (cadr obj)))))\n\n; '(tokyo (tokyo takasaki 110) (tokyo (takasaki nagoya 130) 110)) given,\n; return (TOKYO TAKASAKI NAGOYA).\n(defun get-end-node-list (seq)\n  (cond ((nodep seq) seq)\n        ((listp seq) (let ((head (car seq)) (tail (cdr seq)))\n                       (cond ((nodep head) (cons head (get-end-node-list tail)))\n                             ((or (edgep head)\n                                  (treep head))\n                              (cons (get-end-node head) (get-end-node-list tail))))))))\n\n; '(tokyo takasaki 110) 'takasaki given, return true.\n; '(tokyo (takasaki nagano 130) 110) 'takasaki given, return nil.\n(defun end-with-nodep (edge-or-tree node)\n  (eq (get-end-node edge-or-tree) node))\n\n; '((tokyo takasaki 110) (nagano tokyo 230) tokyo) 'tokyo given,\n; return ((nagano tokyo 230) tokyo).\n(defun find-edges-end-with-node (edges node)\n  (let ((head (car edges)) (tail (cdr edges)))\n    (when head\n      (if (end-with-nodep head node)\n        (cons head (find-edges-end-with-node tail node))\n        (find-edges-end-with-node tail node)))))\n\n(defun find-edges-end-with-nodes (edges nodes)\n  (cond ((nodep nodes) (find-edges-end-with-node edges nodes))\n        ((consp nodes) (let ((head (car nodes)) (tail (cdr nodes)))\n                         (append (find-edges-end-with-node edges head)\n                                 (find-edges-end-with-nodes edges tail))))))\n\n(defun equal-if-sorted (list-a list-b)\n  (equal (sort list-a #'string<) (sort list-b #'string<)))\n\n(defun find-probable-paths (seq edges)\n  (cond ((nodep seq) (edges-from seq edges))\n        ((listp seq)\n         (let ((head (car seq)) (tail (cdr seq)))\n           (cond ((nodep head) (edges-from head edges))\n                 ((or (edgep head)\n                      (treep head))\n                  (append (edge-trees head) (find-probable-paths tail edges))))))))\n\n(defun remove-end-with-established-nodes (probable-paths paths)\n  (let ((end-node-list (get-end-node-list paths)))\n    (remove-if-included probable-paths (find-edges-end-with-nodes probable-paths end-node-list))))\n\n; Remove items of a-list if they are included in b-list.\n(defun remove-if-included (a b)\n  (let ((head (car a)) (tail (cdr a)))\n    (when a\n      (if (member head b :test #'equal)\n        (remove-if-included tail b)\n        (cons head (remove-if-included tail b))))))\n\n(defun remove-improbable-paths (probable-paths paths)\n  (remove-if-included (remove-end-with-established-nodes probable-paths paths) paths))\n\n(defun establish-path (paths edges)\n  (shortest-edge (remove-improbable-paths (find-probable-paths paths edges) paths)))\n\n(defun all-searchedp (established-paths nodes)\n  (equal-if-sorted (remove-duplicates (get-end-node-list established-paths)) nodes))\n\n(defun dijkstra (paths nodes edges)\n  (when (nodep paths)\n    (setf paths (list paths)))\n  (let* ((established-path (establish-path paths edges))\n         (established-paths (cons established-path paths)))\n    (if (all-searchedp established-paths nodes)\n      established-paths\n      (dijkstra established-paths nodes edges))))\n\n(princ (dijkstra 'tokyo *nodes* *edges*))\n\n\n\u5b9f\u884c\u3059\u308b\u3068\uff0c\n((TOKYO (NAGANO HUKUI 330) 230) (TOKYO (NAGOYA KYOTO 160) 350) (TOKYO NAGOYA 350) (TOKYO (TAKASAKI NIIGATA 210) 110) (TOKYO NAGANO 230) (TOKYO TAKASAKI 110) TOKYO)\n\n\u3053\u3093\u306a\u3082\u306e\u304c\u8fd4\u3063\u3066\u304f\u308b\u3002\u3053\u308c\u306f\u5404\u5730\u70b9\u307e\u3067\u306e\u6700\u77ed\u30eb\u30fc\u30c8\u306e\u30ea\u30b9\u30c8\u3067\u3042\u308a\uff0c\u30c0\u30a4\u30af\u30b9\u30c8\u30e9\u6cd5\u306e\u7d50\u679c\u3067\u3042\u308b\u3002\n\n3. \u611f\u60f3\n\u3000\u3084\u3063\u305f\u305c\u3002\n# 1. \u3053\u306e\u8a18\u4e8b\u3067\u5b66\u3079\u308b\u3053\u3068\u30fb\u5b66\u3079\u306a\u3044\u3053\u3068\n\n\u5b66\u3079\u308b\u3053\u3068\n\n- \u30c0\u30a4\u30af\u30b9\u30c8\u30e9\u6cd5\u306b\u3064\u3044\u3066\u306e\u304a\u307c\u308d\u3052\u306a\u6982\u8981\u3002\n- Lisp \u306b\u3088\u308b\u5b9f\u88c5\u306e\u4f8b\u3002\n- \u30ea\u30d5\u30a1\u30af\u30bf\u30ea\u30f3\u30b0\u3057\u3066\u904a\u3079\u308b\u3002\n\n\u5b66\u3079\u306a\u3044\u3053\u3068\n\n- Lisp \u306e\u7f8e\u3057\u3044\u30b3\u30fc\u30c9\u3002\n- Lisp \u306e\u5d07\u9ad8\u306a\u308b\u7406\u5ff5\u3002\n- \u30c0\u30a4\u30af\u30b9\u30c8\u30e9\u6cd5\u306e\u826f\u3044\u4f8b\u3002\n\n# 2. \u5b9f\u969b\u306e\u30b3\u30fc\u30c9\n\n\u4ee5\u524d\uff0c[\u62ec\u5f27\u306e\u5c71\u3068\u6226\u3063\u3066\u307f\u305f\uff1a\u30c0\u30a4\u30af\u30b9\u30c8\u30e9\u6cd5\u3063\u3066\u4f55\u3060\u3088\uff0c\u5206\u304b\u3093\u306d\u3047\u3088\u3002](http://qiita.com/5ara5treamer/items/715fe73cb897889fb2b7)\u3068\u3044\u3046\u8a18\u4e8b\u3092\u66f8\u3044\u305f\u304c\uff0c\u3068\u3046\u3068\u3046\u308f\u304b\u3063\u305f\u306e\u3067\u30b3\u30fc\u30c9\u3092\u63b2\u8f09\u3002\u591a\u5206\u5206\u304b\u3063\u3066\u3044\u308b\u4eba\u304b\u3089\u3059\u308c\u3070\u4f59\u308a\u306b\u5197\u9577\u306a\u30b3\u30fc\u30c9\u306a\u306e\u304b\u3082\u3057\u308c\u306a\u3044\u3051\u308c\u3069\uff0c\u3068\u306b\u304b\u304f\u308f\u304b\u3063\u3066\u5b09\u3057\u3044\u306e\u3067\u8f09\u305b\u308b\u3002\n\n```cl:dijkstra.lisp\n(defparameter *nodes* '(tokyo takasaki nagano nagoya niigata hukui kyoto))\n(defparameter *edges* '((tokyo takasaki 110) (takasaki tokyo 110) (tokyo nagano 230) (nagano tokyo 230) (tokyo nagoya 350) (nagoya tokyo 350) (takasaki nagano 130) (nagano takasaki 130) (nagano nagoya 280) (nagoya nagano 280) (takasaki niigata 210) (niigata takasaki 210) (nagano hukui 330) (hukui nagano 330) (nagoya kyoto 160) (kyoto nagoya 160) (niigata hukui 250) (hukui niigata 250) (hukui kyoto 190) (kyoto hukui 190)))\n\n; Node is not nil and is a symbol.\n; ex. 'tokyo\n(defun nodep (obj)\n  (and obj (symbolp obj)))\n\n; Edge is a list composed of two nodes and a number.\n; ex. '(tokyo takasaki 110)\n(defun edgep (seq)\n  (and (listp seq)\n\t   (eq (length seq) 3)\n\t   (nodep   (first  seq))\n\t   (nodep   (second seq))\n\t   (numberp (third  seq))))\n\n; Tree is a nested edge list.\n; ex. '(tokyo (takasaki nagano 130) 110)\n(defun treep (seq)\n  (when (and seq\n\t\t\t (listp seq)\n\t\t\t (symbolp (first  seq))\n\t\t\t (numberp (third  seq)))\n\t(if (listp (second seq))\n\t  (treep (second seq))\n\t  t)))\n\n; Return edges from a given node.\n(defun edges-from (node edges)\n  (labels ((start-with-p (edge)\n\t\t\t\t\t\t (eq (car edge) node)))\n\t(when (listp edges)\n\t  (remove-if-not #'start-with-p edges))))\n\n; '(tokyo takasaki 110) given, \n; return ((TOKYO (TAKASAKI TOKYO 110) 110)\n;         (TOKYO (TAKASAKI NAGANO 130) 110)\n;         (TOKYO (TAKASAKI NIIGATA 210) 110)).\n(defun edge-trees (seq)\n  (let ((head (car seq)) (tail (cdr seq)))\n\t(cond ((edgep seq) (mapcar (lambda (tree)\n\t\t\t\t\t\t\t\t (list head tree (cadr tail)))\n\t\t\t\t\t\t\t   (edges-from (car tail) *edges*)))\n\t\t  ((treep seq) (mapcar (lambda (edge)\n\t\t\t\t\t\t\t\t (list head edge (cadr tail)))\n\t\t\t\t\t\t\t   (edge-trees (car tail)))))))\n\n; '(tokyo takasaki 110) given, return 110.\n; '(tokyo (takasaki (niigata hukui 250) 210) 110) given, return 570.\n(defun tree-length (seq &optional (len 0))\n  (cond ((edgep seq) (+ (caddr seq) len))\n\t\t((treep seq) (tree-length (cadr seq) (+ (caddr seq) len)))))\n\n; Return the shortest edge from edge list.\n(defun shortest-edge (edges &optional shortest)\n  (when (not shortest)\n\t(setf shortest (car edges)))\n  (let ((head (car edges)) (tail (cdr edges)))\n\t(if edges\n\t  (if (< (tree-length head) (tree-length shortest))\n\t\t(shortest-edge tail head)\n\t\t(shortest-edge tail shortest))\n\t  shortest)))\n\n; '(tokyo (takasaki nagano 130) 110) given,\n; return NAGANO.\n(defun get-end-node (obj)\n  (cond ((nodep obj) obj)\n\t\t((edgep obj) (cadr obj))\n\t\t((treep obj) (get-end-node (cadr obj)))))\n\n; '(tokyo (tokyo takasaki 110) (tokyo (takasaki nagoya 130) 110)) given,\n; return (TOKYO TAKASAKI NAGOYA).\n(defun get-end-node-list (seq)\n  (cond ((nodep seq) seq)\n\t\t((listp seq) (let ((head (car seq)) (tail (cdr seq)))\n\t\t\t\t\t   (cond ((nodep head) (cons head (get-end-node-list tail)))\n\t\t\t\t\t\t\t ((or (edgep head)\n\t\t\t\t\t\t\t\t  (treep head))\n\t\t\t\t\t\t\t  (cons (get-end-node head) (get-end-node-list tail))))))))\n\n; '(tokyo takasaki 110) 'takasaki given, return true.\n; '(tokyo (takasaki nagano 130) 110) 'takasaki given, return nil.\n(defun end-with-nodep (edge-or-tree node)\n  (eq (get-end-node edge-or-tree) node))\n\n; '((tokyo takasaki 110) (nagano tokyo 230) tokyo) 'tokyo given,\n; return ((nagano tokyo 230) tokyo).\n(defun find-edges-end-with-node (edges node)\n  (let ((head (car edges)) (tail (cdr edges)))\n\t(when head\n\t  (if (end-with-nodep head node)\n\t\t(cons head (find-edges-end-with-node tail node))\n\t\t(find-edges-end-with-node tail node)))))\n\n(defun find-edges-end-with-nodes (edges nodes)\n  (cond ((nodep nodes) (find-edges-end-with-node edges nodes))\n\t\t((consp nodes) (let ((head (car nodes)) (tail (cdr nodes)))\n\t\t\t\t\t\t (append (find-edges-end-with-node edges head)\n\t\t\t\t\t\t\t\t (find-edges-end-with-nodes edges tail))))))\n\n(defun equal-if-sorted (list-a list-b)\n  (equal (sort list-a #'string<) (sort list-b #'string<)))\n\n(defun find-probable-paths (seq edges)\n  (cond ((nodep seq) (edges-from seq edges))\n\t\t((listp seq)\n\t\t (let ((head (car seq)) (tail (cdr seq)))\n\t\t   (cond ((nodep head) (edges-from head edges))\n\t\t\t\t ((or (edgep head)\n\t\t\t\t\t  (treep head))\n\t\t\t\t  (append (edge-trees head) (find-probable-paths tail edges))))))))\n\n(defun remove-end-with-established-nodes (probable-paths paths)\n  (let ((end-node-list (get-end-node-list paths)))\n\t(remove-if-included probable-paths (find-edges-end-with-nodes probable-paths end-node-list))))\n\n; Remove items of a-list if they are included in b-list.\n(defun remove-if-included (a b)\n  (let ((head (car a)) (tail (cdr a)))\n\t(when a\n\t  (if (member head b :test #'equal)\n\t\t(remove-if-included tail b)\n\t\t(cons head (remove-if-included tail b))))))\n\n(defun remove-improbable-paths (probable-paths paths)\n  (remove-if-included (remove-end-with-established-nodes probable-paths paths) paths))\n\n(defun establish-path (paths edges)\n  (shortest-edge (remove-improbable-paths (find-probable-paths paths edges) paths)))\n\n(defun all-searchedp (established-paths nodes)\n  (equal-if-sorted (remove-duplicates (get-end-node-list established-paths)) nodes))\n\n(defun dijkstra (paths nodes edges)\n  (when (nodep paths)\n\t(setf paths (list paths)))\n  (let* ((established-path (establish-path paths edges))\n\t\t (established-paths (cons established-path paths)))\n\t(if (all-searchedp established-paths nodes)\n\t  established-paths\n\t  (dijkstra established-paths nodes edges))))\n\n(princ (dijkstra 'tokyo *nodes* *edges*))\n```\n\n\u5b9f\u884c\u3059\u308b\u3068\uff0c\n\n```\n((TOKYO (NAGANO HUKUI 330) 230) (TOKYO (NAGOYA KYOTO 160) 350) (TOKYO NAGOYA 350) (TOKYO (TAKASAKI NIIGATA 210) 110) (TOKYO NAGANO 230) (TOKYO TAKASAKI 110) TOKYO)\n```\n\n\u3053\u3093\u306a\u3082\u306e\u304c\u8fd4\u3063\u3066\u304f\u308b\u3002\u3053\u308c\u306f\u5404\u5730\u70b9\u307e\u3067\u306e\u6700\u77ed\u30eb\u30fc\u30c8\u306e\u30ea\u30b9\u30c8\u3067\u3042\u308a\uff0c\u30c0\u30a4\u30af\u30b9\u30c8\u30e9\u6cd5\u306e\u7d50\u679c\u3067\u3042\u308b\u3002\n\n# 3. \u611f\u60f3\n\n\u3000\u3084\u3063\u305f\u305c\u3002\n", "tags": ["\u30c0\u30a4\u30af\u30b9\u30c8\u30e9\u6cd5", "common-lisp"]}