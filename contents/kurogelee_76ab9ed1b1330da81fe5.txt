{"tags": ["Clojure", "Leiningen2.3.4"], "context": " More than 1 year has passed since last update.Windows\u3067\u306eLeiningen\u3092\u4f7f\u3063\u305f\u30b3\u30fc\u30c9\u5b9f\u884c\u3067\u306fstdout\u3078\u306e\u65e5\u672c\u8a9e\u51fa\u529b\u304c\u6587\u5b57\u5316\u3051\u3057\u307e\u3059\u3002\n(println \"\u3042\u3044\u3046\")\u306e\u3088\u3046\u306a\u30b3\u30fc\u30c9\u3067??????\u3068\u51fa\u529b\u3055\u308c\u3066\u3057\u307e\u3044\u307e\u3059\u3002\n-Dfile.encoding=MS932\u3068\u304b\u3057\u3066\u3082\u3060\u3081\u3067\u3059\u3002\n\u3053\u308c\u3092\u6587\u5b57\u5316\u3051\u305b\u305a\u306b\u8868\u793a\u3059\u308b\u8a2d\u5b9a\u306f\u3042\u308a\u307e\u305b\u3093\u3002\u304a\u308f\u308a\n\u3067\u3082\u3001\u4f55\u3068\u304b\u3059\u308b\u65b9\u6cd5\u898b\u3064\u3051\u307e\u3057\u305f\u3002\n\n\u305d\u3082\u305d\u3082\u306e\u554f\u984c\u7b87\u6240\nLeiningen\u306e\u30d0\u30b0\u3067\u3059\u3002\nhttps://github.com/technomancy/leiningen/blob/master/leiningen-core/src/leiningen/core/eval.clj\n\nclj\n(with-open [out (io/reader (.getInputStream proc))\n            err (io/reader (.getErrorStream proc))\n            in (.getOutputStream proc)]\n\n\nio/reader\u306f\u6587\u5b57\u30b3\u30fc\u30c9\u6307\u5b9a\u3057\u306a\u3044\u3068UTF-8\u304c\u8a2d\u5b9a\u3055\u308c\u307e\u3059\u3002\u30b3\u30de\u30f3\u30c9\u30d7\u30ed\u30f3\u30d7\u30c8\u306e\u51fa\u529b\u306fShift_JIS\uff08MS932, Windows-31J\uff09\u306a\u306e\u3067\u3053\u3053\u3067\u5316\u3051\u307e\u3059\u3002\n\n\u30cf\u30c3\u30af\u65b9\u6cd5\n\u4e0a\u8a18eval.clj\u304c\u4f7f\u3063\u3066\u3044\u308bcom.hypirion.io.Pipe\u30af\u30e9\u30b9\u3092\u66f8\u304d\u63db\u3048\u3066\u4f7f\u3044\u307e\u3059\u3002\nhttps://github.com/hyPiRion/com.hypirion.io/blob/master/src/com/hypirion/io/Pipe.java\n260\u884c\u76ee\u3042\u305f\u308a\u306ePipeWriter\u306ein\u3092\u8a2d\u5b9a\u3057\u3066\u3044\u308b\u90e8\u5206this.in = in;\u3092\u4ee5\u4e0b\u306b\u7f6e\u304d\u63db\u3048\u307e\u3059\u3002\n\njava\ntry{\n    java.lang.reflect.Field f = in.getClass().getDeclaredField(\"in\");\n    f.setAccessible(true);\n    java.lang.reflect.Field lock = Reader.class.getDeclaredField(\"lock\");\n    lock.setAccessible(true);\n    this.in = new java.io.BufferedReader(new java.io.InputStreamReader((InputStream)lock.get(f.get(in)), \"Windows-31J\"));\n}catch(Exception e){\n    throw new RuntimeException(e);\n}\n\n\n\u3053\u308c\u3092\u30b3\u30f3\u30d1\u30a4\u30eb\u3057\u3066\nmkdir com\\hypirion\\io\njavac com\\hypirion\\io\\Pipe.java \n\nlein.bat\u3067\u3001300\u884c\u3042\u305f\u308a\u306e\"%LEIN_JAVA_CMD%\" %LEIN_JVM_OPTS% -Xmx1024M\u306e\u524d\u306bCLASSPATH\u306e\u8a2d\u5b9a\u3092\u3059\u308c\u3070OK\u3067\u3059\u3002\nset CLASSPATH=\"<\u30b3\u30f3\u30d1\u30a4\u30eb\u3057\u305f\u5834\u6240>;%CLASSPATH%\"\n\"%LEIN_JAVA_CMD%\" %LEIN_JVM_OPTS% -Xmx1024M^\n\n\nPipe.java\n\u66f8\u304d\u63db\u3048\u305fPipe.java\u306e\u5168\u4f53\u306f\u4ee5\u4e0b\u3067\u3059\u3002\n\nPipe.java\n/*\n * Copyright (c) 2013 Jean Niklas L'orange. All rights reserved.\n *\n * The use and distribution terms for this software are covered by the\n * Eclipse Public License 1.0 (http://opensource.org/licenses/eclipse-1.0.php)\n * which can be found in the file LICENSE at the root of this distribution.\n *\n * By using this software in any fashion, you are agreeing to be bound by\n * the terms of this license.\n *\n * You must not remove this notice, or any other, from this software.\n */\n\npackage com.hypirion.io;\n\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.Writer;\nimport java.io.Reader;\n\n/**\n * A Pipe is a link between an input stream and an output stream or a reader or\n * writer: The pipe, once started, will asynchronously redirect all data\n * received from the input source to the output source until it is paused,\n * stopped or the input source is empty.\n * <p>\n * Common usage of pipes includes asynchronous zipping of data from two data\n * sources, redirecting output and input to subprocesses and for loggers you\n * want to just pipe from and input source.\n *\n * @author Jean Niklas L'orange\n * @since <code>com.hypirion.io 0.2.0</code>\n */\npublic class Pipe {\n\n    /**\n     * The default size of a pipe's buffer.\n     * @since <code>com.hypirion.io 0.2.0</code>\n     */\n    public static final int DEFAULT_BUFFER_SIZE = 1024;\n\n    private final Thread pumper;\n    private final Object lock;\n    private volatile boolean currentlyRunning, stopped;\n\n    /**\n     * Creates a new pipe, which redirects data from the stream <code>in</code>\n     * to the stream <code>out</code> once started.\n     *\n     * @param in the input stream to read from.\n     * @param out the output stream to write out to.\n     */\n    public Pipe(InputStream in, OutputStream out) {\n        this(in, out, DEFAULT_BUFFER_SIZE);\n    }\n\n    /**\n     * Creates a new pipe with buffer size <code>bufsize</code>, which redirects\n     * data from the stream <code>in</code> to the stream <code>out</code> once\n     * started.\n     *\n     * @param in the input stream to read from.\n     * @param out the output stream to write out to.\n     * @param bufsize the buffer size of the pipe.\n     */\n    public Pipe(InputStream in, OutputStream out, int bufsize) {\n        Runnable pt = new PipeOutputStream(in, out, bufsize);\n        lock = new Object();\n        currentlyRunning = false;\n        stopped = false;\n        pumper = new Thread(pt);\n        pumper.setName(String.format(\"PipeThread %d\", this.hashCode()));\n        pumper.setDaemon(true);\n        pumper.start();\n    }\n\n    /**\n     * Creates a new pipe, which redirects data from the reader <code>in</code>\n     * to the writer <code>out</code> once started.\n     *\n     * @param in the reader to read from.\n     * @param out the writer to write out to.\n     */\n    public Pipe(Reader in, Writer out) {\n        this(in, out, DEFAULT_BUFFER_SIZE);\n    }\n\n    /**\n     * Creates a new pipe with buffer size <code>bufsize</code>, which redirects\n     * data from the reader <code>in</code> to the writer <code>out</code> once\n     * started.\n     *\n     * @param in the reader to read from.\n     * @param out the writer to write out to.\n     * @param bufsize the buffer size of the pipe.\n     */\n    public Pipe(Reader in, Writer out, int bufsize) {\n        Runnable pt = new PipeWriter(in, out, bufsize);\n        lock = new Object();\n        currentlyRunning = false;\n        stopped = false;\n        pumper = new Thread(pt);\n        pumper.setName(String.format(\"PipeThread %d\", this.hashCode()));\n        pumper.setDaemon(true);\n        pumper.start();\n    }\n\n    /**\n     * Waits for this pipe to finish piping. This happens when this pipe is\n     * stopped and the last blocking read has finished.\n     *\n     * @exception InterruptedException if this thread is interrupted while\n     * waiting.\n     *\n     * @see #stop()\n     * @see #stop(boolean)\n     */\n    public void join() throws InterruptedException {\n        pumper.join();\n    }\n\n    /**\n     * Starts up this pipe. If this pipe has not yet been started or has been\n     * paused, this method will (re)start the pipe. When this pipe is stopped,\n     * this method will do nothing.\n     */\n    public synchronized void start() {\n        if (!stopped) {\n            synchronized (lock) {\n                currentlyRunning = true;\n                lock.notify(); // Wake up the pumper if it's waiting.\n            }\n        }\n    }\n\n    /**\n     * Pauses this pipe. Will block until the current blocking read by this pipe\n     * has finished, regardless of whether this pipe has been stopped or not. If\n     * this pipe has already been paused or stopped, and there is no blocking\n     * read waiting, will immediatly return.\n     *\n     * @exception InterruptedException if this thread is interrupted while\n     * waiting.\n     *\n     * @see #pause(boolean)\n     */\n    public synchronized void pause() throws InterruptedException {\n        pause(true);\n    }\n\n    /**\n     * Pauses this pipe. If <code>block</code> is true, will wait until the\n     * current blocking read by this pipe has finished. Will otherwise notify\n     * this pipe and return immediately.\n     *\n     * @param block whether to wait for the blocking read (if any) or not.\n     *\n     * @exception InterruptedException if this thread is interrupted while\n     * waiting.\n     */\n    public synchronized void pause(boolean block) throws InterruptedException {\n        if (!stopped) {\n            synchronized (lock) {\n                currentlyRunning = false;\n                lock.notify();\n                if (block) {\n                    lock.wait();\n                    // Wait for signal from pumper, which will start after we\n                    // release the lock\n                }\n            }\n        } else if (block) {\n            join();\n        }\n    }\n\n    /**\n     * Stops this pipe. Will wait until the last blocking read has finished.\n     *\n     * @exception InterruptedException if this thread is interrupted while\n     * waiting.\n     *\n     * @see #stop(boolean)\n     */\n    public synchronized void stop() throws InterruptedException {\n        stop(true);\n    }\n\n    /**\n     * Stops this pipe. Will wait until the last blocking read has finished. If\n     * <code>block</code> is true, will wait until the current blocking read by\n     * this pipe has finished. Will otherwise notify this pipe and return\n     * immediately.\n     *\n     * @param block whether to wait for the blocking read (if any) or not.\n     *\n     * @exception InterruptedException if this thread is interrupted while\n     * waiting.\n     */\n    public synchronized void stop(boolean block) throws InterruptedException {\n        if (!stopped) {\n            synchronized (lock) {\n                currentlyRunning = false;\n                stopped = true;\n                lock.notify();\n            }\n        }\n        if (block) {\n            join();\n        }\n    }\n\n    private class PipeOutputStream implements Runnable {\n        private final byte[] data;\n        private final InputStream in;\n        private final OutputStream out;\n\n        public PipeOutputStream(InputStream in, OutputStream out, int bufsize) {\n            data = new byte[bufsize];\n            this.in = in;\n            this.out = out;\n        }\n\n        @Override\n        public void run() {\n            try {\n                outer:\n                while (true) {\n                    synchronized (lock) {\n                        while (!currentlyRunning) {\n                            if (stopped) {\n                                break outer;\n                            }\n                            lock.wait();\n                            lock.notify();\n                        }\n                    }\n                    int count = in.read(data);\n                    if (count < 0) {\n                        break;\n                    }\n                    out.write(data, 0, count);\n                    out.flush();\n                }\n            }\n            catch (Exception e) {\n                // Die silently for now.\n            }\n        }\n    }\n\n    private class PipeWriter implements Runnable {\n        private final char[] data;\n        private final Reader in;\n        private final Writer out;\n\n        public PipeWriter(Reader in, Writer out, int bufsize) {\n            data = new char[bufsize];\n            try{\n                java.lang.reflect.Field f = in.getClass().getDeclaredField(\"in\");\n                f.setAccessible(true);\n                java.lang.reflect.Field lock = Reader.class.getDeclaredField(\"lock\");\n                lock.setAccessible(true);\n                this.in = new java.io.BufferedReader(new java.io.InputStreamReader((InputStream)lock.get(f.get(in)), \"Windows-31J\"));\n            }catch(Exception e){\n                throw new RuntimeException(e);\n            }\n            this.out = out;\n        }\n\n        @Override\n        public void run() {\n            try {\n                outer:\n                while (true) {\n                    synchronized (lock) {\n                        while (!currentlyRunning) {\n                            if (stopped) {\n                                break outer;\n                            }\n                            lock.wait();\n                            lock.notify();\n                        }\n                    }\n                    int count = in.read(data);\n                    if (count < 0) {\n                        break;\n                    }\n                    out.write(data, 0, count);\n                    out.flush();\n                }\n            }\n            catch (Exception e) {\n                // Die silently for now.\n            }\n        }\n    }\n}\n\n\nWindows\u3067\u306eLeiningen\u3092\u4f7f\u3063\u305f\u30b3\u30fc\u30c9\u5b9f\u884c\u3067\u306fstdout\u3078\u306e\u65e5\u672c\u8a9e\u51fa\u529b\u304c\u6587\u5b57\u5316\u3051\u3057\u307e\u3059\u3002\n`(println \"\u3042\u3044\u3046\")`\u306e\u3088\u3046\u306a\u30b3\u30fc\u30c9\u3067`??????`\u3068\u51fa\u529b\u3055\u308c\u3066\u3057\u307e\u3044\u307e\u3059\u3002\n`-Dfile.encoding=MS932`\u3068\u304b\u3057\u3066\u3082\u3060\u3081\u3067\u3059\u3002\n\u3053\u308c\u3092\u6587\u5b57\u5316\u3051\u305b\u305a\u306b\u8868\u793a\u3059\u308b\u8a2d\u5b9a\u306f\u3042\u308a\u307e\u305b\u3093\u3002\u304a\u308f\u308a\n\n\n\n\u3067\u3082\u3001\u4f55\u3068\u304b\u3059\u308b\u65b9\u6cd5\u898b\u3064\u3051\u307e\u3057\u305f\u3002\n\n## \u305d\u3082\u305d\u3082\u306e\u554f\u984c\u7b87\u6240\nLeiningen\u306e\u30d0\u30b0\u3067\u3059\u3002\n\nhttps://github.com/technomancy/leiningen/blob/master/leiningen-core/src/leiningen/core/eval.clj\n\n```:clj\n(with-open [out (io/reader (.getInputStream proc))\n            err (io/reader (.getErrorStream proc))\n            in (.getOutputStream proc)]\n```\n\nio/reader\u306f\u6587\u5b57\u30b3\u30fc\u30c9\u6307\u5b9a\u3057\u306a\u3044\u3068UTF-8\u304c\u8a2d\u5b9a\u3055\u308c\u307e\u3059\u3002\u30b3\u30de\u30f3\u30c9\u30d7\u30ed\u30f3\u30d7\u30c8\u306e\u51fa\u529b\u306fShift_JIS\uff08MS932, Windows-31J\uff09\u306a\u306e\u3067\u3053\u3053\u3067\u5316\u3051\u307e\u3059\u3002\n\n## \u30cf\u30c3\u30af\u65b9\u6cd5\n\n\u4e0a\u8a18eval.clj\u304c\u4f7f\u3063\u3066\u3044\u308bcom.hypirion.io.Pipe\u30af\u30e9\u30b9\u3092\u66f8\u304d\u63db\u3048\u3066\u4f7f\u3044\u307e\u3059\u3002\n\nhttps://github.com/hyPiRion/com.hypirion.io/blob/master/src/com/hypirion/io/Pipe.java\n\n260\u884c\u76ee\u3042\u305f\u308a\u306ePipeWriter\u306ein\u3092\u8a2d\u5b9a\u3057\u3066\u3044\u308b\u90e8\u5206`this.in = in;`\u3092\u4ee5\u4e0b\u306b\u7f6e\u304d\u63db\u3048\u307e\u3059\u3002\n\n```:java\ntry{\n    java.lang.reflect.Field f = in.getClass().getDeclaredField(\"in\");\n    f.setAccessible(true);\n    java.lang.reflect.Field lock = Reader.class.getDeclaredField(\"lock\");\n    lock.setAccessible(true);\n    this.in = new java.io.BufferedReader(new java.io.InputStreamReader((InputStream)lock.get(f.get(in)), \"Windows-31J\"));\n}catch(Exception e){\n    throw new RuntimeException(e);\n}\n```\n\n\u3053\u308c\u3092\u30b3\u30f3\u30d1\u30a4\u30eb\u3057\u3066\n\n```\nmkdir com\\hypirion\\io\njavac com\\hypirion\\io\\Pipe.java \n```\n\nlein.bat\u3067\u3001300\u884c\u3042\u305f\u308a\u306e`\"%LEIN_JAVA_CMD%\" %LEIN_JVM_OPTS% -Xmx1024M`\u306e\u524d\u306bCLASSPATH\u306e\u8a2d\u5b9a\u3092\u3059\u308c\u3070OK\u3067\u3059\u3002\n\n```\nset CLASSPATH=\"<\u30b3\u30f3\u30d1\u30a4\u30eb\u3057\u305f\u5834\u6240>;%CLASSPATH%\"\n\"%LEIN_JAVA_CMD%\" %LEIN_JVM_OPTS% -Xmx1024M^\n```\n\n### Pipe.java\n\u66f8\u304d\u63db\u3048\u305fPipe.java\u306e\u5168\u4f53\u306f\u4ee5\u4e0b\u3067\u3059\u3002\n\n```Pipe.java\n/*\n * Copyright (c) 2013 Jean Niklas L'orange. All rights reserved.\n *\n * The use and distribution terms for this software are covered by the\n * Eclipse Public License 1.0 (http://opensource.org/licenses/eclipse-1.0.php)\n * which can be found in the file LICENSE at the root of this distribution.\n *\n * By using this software in any fashion, you are agreeing to be bound by\n * the terms of this license.\n *\n * You must not remove this notice, or any other, from this software.\n */\n\npackage com.hypirion.io;\n\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.Writer;\nimport java.io.Reader;\n\n/**\n * A Pipe is a link between an input stream and an output stream or a reader or\n * writer: The pipe, once started, will asynchronously redirect all data\n * received from the input source to the output source until it is paused,\n * stopped or the input source is empty.\n * <p>\n * Common usage of pipes includes asynchronous zipping of data from two data\n * sources, redirecting output and input to subprocesses and for loggers you\n * want to just pipe from and input source.\n *\n * @author Jean Niklas L'orange\n * @since <code>com.hypirion.io 0.2.0</code>\n */\npublic class Pipe {\n\n    /**\n     * The default size of a pipe's buffer.\n     * @since <code>com.hypirion.io 0.2.0</code>\n     */\n    public static final int DEFAULT_BUFFER_SIZE = 1024;\n\n    private final Thread pumper;\n    private final Object lock;\n    private volatile boolean currentlyRunning, stopped;\n\n    /**\n     * Creates a new pipe, which redirects data from the stream <code>in</code>\n     * to the stream <code>out</code> once started.\n     *\n     * @param in the input stream to read from.\n     * @param out the output stream to write out to.\n     */\n    public Pipe(InputStream in, OutputStream out) {\n        this(in, out, DEFAULT_BUFFER_SIZE);\n    }\n\n    /**\n     * Creates a new pipe with buffer size <code>bufsize</code>, which redirects\n     * data from the stream <code>in</code> to the stream <code>out</code> once\n     * started.\n     *\n     * @param in the input stream to read from.\n     * @param out the output stream to write out to.\n     * @param bufsize the buffer size of the pipe.\n     */\n    public Pipe(InputStream in, OutputStream out, int bufsize) {\n        Runnable pt = new PipeOutputStream(in, out, bufsize);\n        lock = new Object();\n        currentlyRunning = false;\n        stopped = false;\n        pumper = new Thread(pt);\n        pumper.setName(String.format(\"PipeThread %d\", this.hashCode()));\n        pumper.setDaemon(true);\n        pumper.start();\n    }\n\n    /**\n     * Creates a new pipe, which redirects data from the reader <code>in</code>\n     * to the writer <code>out</code> once started.\n     *\n     * @param in the reader to read from.\n     * @param out the writer to write out to.\n     */\n    public Pipe(Reader in, Writer out) {\n        this(in, out, DEFAULT_BUFFER_SIZE);\n    }\n\n    /**\n     * Creates a new pipe with buffer size <code>bufsize</code>, which redirects\n     * data from the reader <code>in</code> to the writer <code>out</code> once\n     * started.\n     *\n     * @param in the reader to read from.\n     * @param out the writer to write out to.\n     * @param bufsize the buffer size of the pipe.\n     */\n    public Pipe(Reader in, Writer out, int bufsize) {\n        Runnable pt = new PipeWriter(in, out, bufsize);\n        lock = new Object();\n        currentlyRunning = false;\n        stopped = false;\n        pumper = new Thread(pt);\n        pumper.setName(String.format(\"PipeThread %d\", this.hashCode()));\n        pumper.setDaemon(true);\n        pumper.start();\n    }\n\n    /**\n     * Waits for this pipe to finish piping. This happens when this pipe is\n     * stopped and the last blocking read has finished.\n     *\n     * @exception InterruptedException if this thread is interrupted while\n     * waiting.\n     *\n     * @see #stop()\n     * @see #stop(boolean)\n     */\n    public void join() throws InterruptedException {\n        pumper.join();\n    }\n\n    /**\n     * Starts up this pipe. If this pipe has not yet been started or has been\n     * paused, this method will (re)start the pipe. When this pipe is stopped,\n     * this method will do nothing.\n     */\n    public synchronized void start() {\n        if (!stopped) {\n            synchronized (lock) {\n                currentlyRunning = true;\n                lock.notify(); // Wake up the pumper if it's waiting.\n            }\n        }\n    }\n\n    /**\n     * Pauses this pipe. Will block until the current blocking read by this pipe\n     * has finished, regardless of whether this pipe has been stopped or not. If\n     * this pipe has already been paused or stopped, and there is no blocking\n     * read waiting, will immediatly return.\n     *\n     * @exception InterruptedException if this thread is interrupted while\n     * waiting.\n     *\n     * @see #pause(boolean)\n     */\n    public synchronized void pause() throws InterruptedException {\n        pause(true);\n    }\n\n    /**\n     * Pauses this pipe. If <code>block</code> is true, will wait until the\n     * current blocking read by this pipe has finished. Will otherwise notify\n     * this pipe and return immediately.\n     *\n     * @param block whether to wait for the blocking read (if any) or not.\n     *\n     * @exception InterruptedException if this thread is interrupted while\n     * waiting.\n     */\n    public synchronized void pause(boolean block) throws InterruptedException {\n        if (!stopped) {\n            synchronized (lock) {\n                currentlyRunning = false;\n                lock.notify();\n                if (block) {\n                    lock.wait();\n                    // Wait for signal from pumper, which will start after we\n                    // release the lock\n                }\n            }\n        } else if (block) {\n            join();\n        }\n    }\n\n    /**\n     * Stops this pipe. Will wait until the last blocking read has finished.\n     *\n     * @exception InterruptedException if this thread is interrupted while\n     * waiting.\n     *\n     * @see #stop(boolean)\n     */\n    public synchronized void stop() throws InterruptedException {\n        stop(true);\n    }\n\n    /**\n     * Stops this pipe. Will wait until the last blocking read has finished. If\n     * <code>block</code> is true, will wait until the current blocking read by\n     * this pipe has finished. Will otherwise notify this pipe and return\n     * immediately.\n     *\n     * @param block whether to wait for the blocking read (if any) or not.\n     *\n     * @exception InterruptedException if this thread is interrupted while\n     * waiting.\n     */\n    public synchronized void stop(boolean block) throws InterruptedException {\n        if (!stopped) {\n            synchronized (lock) {\n                currentlyRunning = false;\n                stopped = true;\n                lock.notify();\n            }\n        }\n        if (block) {\n            join();\n        }\n    }\n\n    private class PipeOutputStream implements Runnable {\n        private final byte[] data;\n        private final InputStream in;\n        private final OutputStream out;\n\n        public PipeOutputStream(InputStream in, OutputStream out, int bufsize) {\n            data = new byte[bufsize];\n            this.in = in;\n            this.out = out;\n        }\n\n        @Override\n        public void run() {\n            try {\n                outer:\n                while (true) {\n                    synchronized (lock) {\n                        while (!currentlyRunning) {\n                            if (stopped) {\n                                break outer;\n                            }\n                            lock.wait();\n                            lock.notify();\n                        }\n                    }\n                    int count = in.read(data);\n                    if (count < 0) {\n                        break;\n                    }\n                    out.write(data, 0, count);\n                    out.flush();\n                }\n            }\n            catch (Exception e) {\n                // Die silently for now.\n            }\n        }\n    }\n\n    private class PipeWriter implements Runnable {\n        private final char[] data;\n        private final Reader in;\n        private final Writer out;\n\n        public PipeWriter(Reader in, Writer out, int bufsize) {\n            data = new char[bufsize];\n            try{\n                java.lang.reflect.Field f = in.getClass().getDeclaredField(\"in\");\n                f.setAccessible(true);\n                java.lang.reflect.Field lock = Reader.class.getDeclaredField(\"lock\");\n                lock.setAccessible(true);\n                this.in = new java.io.BufferedReader(new java.io.InputStreamReader((InputStream)lock.get(f.get(in)), \"Windows-31J\"));\n            }catch(Exception e){\n                throw new RuntimeException(e);\n            }\n            this.out = out;\n        }\n\n        @Override\n        public void run() {\n            try {\n                outer:\n                while (true) {\n                    synchronized (lock) {\n                        while (!currentlyRunning) {\n                            if (stopped) {\n                                break outer;\n                            }\n                            lock.wait();\n                            lock.notify();\n                        }\n                    }\n                    int count = in.read(data);\n                    if (count < 0) {\n                        break;\n                    }\n                    out.write(data, 0, count);\n                    out.flush();\n                }\n            }\n            catch (Exception e) {\n                // Die silently for now.\n            }\n        }\n    }\n}\n```\n"}