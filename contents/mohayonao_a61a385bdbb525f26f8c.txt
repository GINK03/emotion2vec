{"tags": ["JavaScript", "WebAudioAPI"], "context": " More than 1 year has passed since last update.Web Audio API \u306e\u30c9\u30e9\u30d5\u30c8\u4ed5\u69d8\u3067 AudioBuffer \u306b\u8ffd\u52a0\u3055\u308c\u3066\u3044\u308b copyFromChannel \u3068 copyToChannel \u30e1\u30bd\u30c3\u30c9\u306b\u3064\u3044\u3066\u3001\u4eca\u306e API \u3067\u3082\u5bb9\u6613\u306b\u540c\u7b49\u306e\u64cd\u4f5c\u304c\u53ef\u80fd\u306a\u306e\u306b\u4f55\u6545\u3053\u3046\u3044\u3046API\u304c\u5fc5\u8981\u306a\u306e\u304b\u6c17\u306b\u306a\u3063\u305f\u306e\u3067\u8abf\u3079\u305f\u30e1\u30e2\u3002\n\u53c2\u7167: http://webaudio.github.io/web-audio-api/#acquire-the-content\ninterface AudioBuffer {\n  readonly attribute float  sampleRate;\n  readonly attribute long   length;\n  readonly attribute double duration;\n  readonly attribute long   numberOfChannels;\n\n  // \u3044\u307e\u307e\u3067\u3053\u308c\u3060\u3051\u3060\u3063\u305f\u306e\u304c\n  Float32Array getChannelData(unsigned long channel);\n\n  // \u3053\u306e2\u3064\u306e\u30e1\u30bd\u30c3\u30c9\u304c\u8ffd\u52a0\u3055\u308c\u308b\n  void copyFromChannel(Float32Array destination, long channelNumber, optional unsigned long startInChannel = 0);\n  void copyToChannel(Float32Array source, long channelNumber, optional unsigned long startInChannel = 0);\n};\n\n\u4ee5\u4e0b\u7ffb\u8a33\u304c\u76ee\u7684\u3067\u306f\u306a\u3044\u306e\u3067\u3001\u5927\u307e\u304b\u306a\u89e3\u91c8\u3092\u66f8\u3044\u3066\u3044\u307e\u3059\u3002\n\u9593\u9055\u3063\u3066\u3044\u305f\u3089\u30b3\u30e1\u30f3\u30c8 or \u7de8\u96c6\u30ea\u30af\u30a8\u30b9\u30c8\u304f\u3060\u3055\u3044\uff01\uff01\uff01\n\nNOTE\nThe methods copyToChannel and copyFromChannel can be used to fill part of an array by passing in a Float32Array that's a view onto the larger array. When reading data from an AudioBuffer's channels, and the data can be processed in chunks, copyFromChannel should be preferred to calling getChannelData and accessing the resulting array, because it may avoid unnecessary memory allocation and copying.\n\ncopyToChannel \u3068 copyFromChannel \u306f\u30c7\u30fc\u30bf\u306e\u90e8\u5206\u7684\u306a\u64cd\u4f5c\u304c\u3067\u304d\u308b\u3002\nAudioBuffer \u304b\u3089\u90e8\u5206\u7684\u306b\u30c7\u30fc\u30bf\u3092\u8aad\u307f\u8fbc\u3080\u3068\u304d\u306f getChannelData \u3088\u308a copyFromChannel \u3092\u4f7f\u3046\u3079\u304d\u3002\u306a\u305c\u306a\u3089 copyFromChannel \u306f\u30e1\u30e2\u30ea\u306e\u78ba\u4fdd\u3084\u30b3\u30d4\u30fc\u3092\u767a\u751f\u3055\u305b\u306a\u3044\u304b\u3089\u3002\n getChannelData \u3092\u4f7f\u3046\u3068\u30e1\u30e2\u30ea\u306e\u78ba\u4fdd\u3084\u30b3\u30d4\u30fc\u304c\u884c\u308f\u308c\u308b\u5834\u5408\u304c\u3042\u308b\uff1f\n\n\nAn internal operation acquire the contents of an AudioBuffer is invoked when the contents of an AudioBuffer are needed by some API implementation. This operation returns immutable channel data to the invoker.\n\noperation acquire the contents of an AudioBuffer (AudioBuffer\u306e\u30c7\u30fc\u30bf\u53d6\u5f97) \u306f API \u306e\u5fc5\u8981\u306b\u5fdc\u3058\u3066\u5185\u90e8\u3067\u5b9f\u884c\u3055\u308c\u308b\u3002\u3053\u306e\u64cd\u4f5c\u306f\u4e0d\u5909\u306e\u30c1\u30e3\u30cd\u30eb\u30c7\u30fc\u30bf\u3092\u8fd4\u3059\u3002\n \u5185\u90e8\u306e\u5b9f\u88c5\u306e\u8a71\u3067\u3042\u3063\u3066\u3001\u5916\u90e8 (JavaScript\u5074) \u304b\u3089\u306f\u89b3\u6e2c\u3067\u304d\u306a\u3044\u3002\u77e5\u3063\u3066\u304a\u304b\u306a\u3044\u3068\u5bfe\u5fdc\u3067\u304d\u306a\u3044\u985e\u306e\u306f\u306a\u3057\u3063\u307d\u3044\u3002\n\n\nWhen an acquire the content operation occurs on an AudioBuffer, run the following steps:\n\nIf any of the AudioBuffer's ArrayBuffer have been neutered, abort these steps, and return a zero-length channel data buffers to the invoker.\nNeuter all ArrayBuffers for arrays previously returned by getChannelData on this AudioBuffer.\nRetain the underlying data buffers from those ArrayBuffers and return references to them to the invoker.\nAttach ArrayBuffers containing copies of the data to the AudioBuffer, to be returned by the next call to getChannelData.\n\n\nacquire the content operation \u306f\u3001\u4ee5\u4e0b\u306e\u624b\u9806\u306b\u5f93\u3046:\n\n\u3044\u305a\u308c\u304b\u306e ArrayBuffer \u304c\u7121\u529b\u5316 (neutered) \u3055\u308c\u3066\u3044\u308b\u3068\u304d\u3053\u306e\u624b\u9806\u306f\u884c\u308f\u305a\u3001\u7a7a\u306e\u30c7\u30fc\u30bf\u3092\u8fd4\u3059\u3002\nArrayBuffer \u306e\u30c7\u30fc\u30bf\u3092\u7121\u529b\u5316\u3059\u308b (JavaScript\u5074\u304b\u3089\u898b\u3048\u306a\u304f\u306a\u308b)\nArrayBuffer \u306e\u30c7\u30fc\u30bf\u3092\u4fdd\u6301\u3057\u3001\u53c2\u7167\u3092\u8fd4\u3057\u307e\u3059 (C++\u3067\u898b\u3048\u308b\u3088\u3046\u306b\u3059\u308b)\n(C++\u5074\u3067) \u4fdd\u6301\u3057\u3066\u3044\u308b\u30c7\u30fc\u30bf\u306f\u3001(JS\u5074\u306e) getChannelData \u306b\u3088\u3063\u3066\u8fd4\u3055\u308c\u308b\n\n \u305f\u3076\u3093 4 \u306e\u6642\u306b ArrayBuffer \u306e\u518d\u78ba\u4fdd (\u30a2\u30ed\u30b1\u30fc\u30c8\u3068\u30b3\u30d4\u30fc) \u304c\u884c\u308f\u308c\u308b\u3002\n\n\nThe acquire the contents of an AudioBuffer operation is invoked in the following cases:\n\nWhen AudioBufferSourceNode.start is called, it acquires the contents of the node's buffer. If the operation fails, nothing is played.\nWhen a ConvolverNode's buffer is set to an AudioBuffer while the node is connected to an output node, or a ConvolverNode is connected to an output node while the ConvolverNode's buffer is set to an AudioBuffer, it acquires the content of the AudioBuffer.\nWhen the dispatch of an AudioProcessingEvent completes, it acquires the contents of its outputBuffer.\n\n\nacquire the contents \u306f\u4ee5\u4e0b\u306e\u5834\u5408\u306b\u8d77\u3053\u308b\n\n\nAudioBufferSourceNode.start \u304c\u547c\u3070\u308c\u305f\u3068\u304d\n\u4ed6\u306e\u30ce\u30fc\u30c9\u306b\u63a5\u7d9a\u3055\u308c\u3066\u3044\u308b ConvolverNode \u306e buffer \u304c\u30bb\u30c3\u30c8\u3055\u308c\u305f\u3068\u304d\nbuffer \u304c\u30bb\u30c3\u30c8\u3055\u308c\u3066\u3044\u308b ConvolverNode \u304c\u4ed6\u306e\u30ce\u30fc\u30c9\u306b\u63a5\u7d9a\u3055\u308c\u305f\u3068\u304d\n\nAudioProcessingEvent \u304c\u5b8c\u4e86\u3057\u305f\u3068\u304d\n\n \u4e0a\u8a18\u306e\u3068\u304d\u306b AudioBuffer \u306e\u5185\u5bb9\u304c\u5b9f\u88c5\u5074\u306b\u8ee2\u9001\u3055\u308c\u3066\u3001JavaScript \u5074\u304b\u3089\u89e6\u308c\u306a\u304f\u306a\u308b\u3002\n\n\u305f\u3076\u3093\u3053\u3046\u3044\u3046\u3053\u3068\u3060\u3068\u601d\u3046\u3002\nvar audioContext = new AudioContext();\nvar audioBuffer = audioContext.createBuffer(1, 10000, 44100);\nvar convolver = audioContext.createConvolver();\n\naudioBuffer.getChannelData(0).set([ 0, 1, 2, 3, 4, 5, 6, 7 ]);\n\nvar savedBuffer = audioBuffer.getChannelData(0);\n\nconsole.log(savedBuffer); // [ 0, 1, 2, 3, 4, 5, 6, 7, 0 ... 0 ]\n\nconvolver.buffer = audioBuffer;\nconvolver.connect(audioContext.destination); // \u3053\u3053\u3067 acquire the contents \n\n// acquire the contents \u306b\u3088\u308a JavaScript\u5074\u304b\u3089\u53c2\u7167\u3067\u304d\u306a\u304f\u306a\u308b\nconsole.log(savedBuffer); // []\n\n// getChannelData \u3092\u3059\u308c\u3070\u30c7\u30fc\u30bf\u3092\u898b\u308b\u3053\u3068\u306f\u3067\u304d\u308b\n// \u3053\u306e\u3068\u304d\u306b ArrayBuffer \u306e\u518d\u78ba\u4fdd (\u30a2\u30ed\u30b1\u30fc\u30c8\u3068\u30b3\u30d4\u30fc) \u304c\u884c\u308f\u308c\u308b\nvar tempBuffer = audioBuffer.getChannelData(0);\nconsole.log(tempBuffer); // [ 0, 1, 2, 3, 4, 5, 6, 7, 0 ... 0 ]\nconsole.log(tempBuffer.buffer.byteLength); // 10000 * 4\n// getChannelData \u3060\u3068\u547c\u3070\u308c\u308b\u305f\u3073\u306b 40000\u30d0\u30a4\u30c8\u306e ArrayBuffer \u304c\u751f\u6210\u3055\u308c\u308b(\u5834\u5408\u304c\u3042\u308b)\n\n// \u65b0\u3057\u3044 API \u3092\u4f7f\u3046\u5834\u5408\nvar tempBuffer = new Float32Array(8);\naudioBuffer.copyFromChannel(tempBuffer, 0);\nconsole.log(tempBuffer); // [ 0, 1, 2, 3, 4, 5, 6, 7 ]\nconsole.log(tempBuffer.buffer.byteLength); // 8 * 4\n// copyFromChannel \u3060\u3068\u3042\u3089\u304b\u3058\u3081\u78ba\u4fdd\u3057\u3066\u3044\u308b\u9818\u57df\u306b\u66f8\u304d\u8fbc\u3080\u3060\u3051\u306a\u306e\u3067\u3001\u30e1\u30e2\u30ea\u78ba\u4fdd\u7b49\u306f\u8d77\u3053\u3089\u306a\u3044\n\nWeb Audio API \u306e\u30c9\u30e9\u30d5\u30c8\u4ed5\u69d8\u3067 AudioBuffer \u306b\u8ffd\u52a0\u3055\u308c\u3066\u3044\u308b `copyFromChannel` \u3068 `copyToChannel` \u30e1\u30bd\u30c3\u30c9\u306b\u3064\u3044\u3066\u3001\u4eca\u306e API \u3067\u3082\u5bb9\u6613\u306b\u540c\u7b49\u306e\u64cd\u4f5c\u304c\u53ef\u80fd\u306a\u306e\u306b\u4f55\u6545\u3053\u3046\u3044\u3046API\u304c\u5fc5\u8981\u306a\u306e\u304b\u6c17\u306b\u306a\u3063\u305f\u306e\u3067\u8abf\u3079\u305f\u30e1\u30e2\u3002\n\n\u53c2\u7167: http://webaudio.github.io/web-audio-api/#acquire-the-content\n\n```cpp\ninterface AudioBuffer {\n  readonly attribute float  sampleRate;\n  readonly attribute long   length;\n  readonly attribute double duration;\n  readonly attribute long   numberOfChannels;\n\n  // \u3044\u307e\u307e\u3067\u3053\u308c\u3060\u3051\u3060\u3063\u305f\u306e\u304c\n  Float32Array getChannelData(unsigned long channel);\n    \n  // \u3053\u306e2\u3064\u306e\u30e1\u30bd\u30c3\u30c9\u304c\u8ffd\u52a0\u3055\u308c\u308b\n  void copyFromChannel(Float32Array destination, long channelNumber, optional unsigned long startInChannel = 0);\n  void copyToChannel(Float32Array source, long channelNumber, optional unsigned long startInChannel = 0);\n};\n```\n\n\u4ee5\u4e0b\u7ffb\u8a33\u304c\u76ee\u7684\u3067\u306f\u306a\u3044\u306e\u3067\u3001\u5927\u307e\u304b\u306a\u89e3\u91c8\u3092\u66f8\u3044\u3066\u3044\u307e\u3059\u3002\n\u9593\u9055\u3063\u3066\u3044\u305f\u3089\u30b3\u30e1\u30f3\u30c8 or \u7de8\u96c6\u30ea\u30af\u30a8\u30b9\u30c8\u304f\u3060\u3055\u3044\uff01\uff01\uff01\n\n> NOTE\n>\n> The methods `copyToChannel` and `copyFromChannel` can be used to fill part of an array by passing in a `Float32Array` that's a view onto the larger array. When reading data from an **`AudioBuffer`**'s channels, and the data can be processed in chunks, `copyFromChannel` should be preferred to calling `getChannelData` and accessing the resulting array, because it may avoid unnecessary memory allocation and copying.\n\n`copyToChannel` \u3068 `copyFromChannel` \u306f\u30c7\u30fc\u30bf\u306e\u90e8\u5206\u7684\u306a\u64cd\u4f5c\u304c\u3067\u304d\u308b\u3002\nAudioBuffer \u304b\u3089\u90e8\u5206\u7684\u306b\u30c7\u30fc\u30bf\u3092\u8aad\u307f\u8fbc\u3080\u3068\u304d\u306f `getChannelData` \u3088\u308a `copyFromChannel` \u3092\u4f7f\u3046\u3079\u304d\u3002\u306a\u305c\u306a\u3089 `copyFromChannel` \u306f\u30e1\u30e2\u30ea\u306e\u78ba\u4fdd\u3084\u30b3\u30d4\u30fc\u3092\u767a\u751f\u3055\u305b\u306a\u3044\u304b\u3089\u3002\n\n:memo: _`getChannelData` \u3092\u4f7f\u3046\u3068\u30e1\u30e2\u30ea\u306e\u78ba\u4fdd\u3084\u30b3\u30d4\u30fc\u304c\u884c\u308f\u308c\u308b\u5834\u5408\u304c\u3042\u308b\uff1f_\n\n- - -\n\n> An internal **operation acquire the contents of an `AudioBuffer`** is invoked when the contents of an **`AudioBuffer`** are needed by some API implementation. This operation returns immutable channel data to the invoker.\n\n**operation acquire the contents of an `AudioBuffer`** (AudioBuffer\u306e\u30c7\u30fc\u30bf\u53d6\u5f97) \u306f API \u306e\u5fc5\u8981\u306b\u5fdc\u3058\u3066\u5185\u90e8\u3067\u5b9f\u884c\u3055\u308c\u308b\u3002\u3053\u306e\u64cd\u4f5c\u306f\u4e0d\u5909\u306e\u30c1\u30e3\u30cd\u30eb\u30c7\u30fc\u30bf\u3092\u8fd4\u3059\u3002\n\n:memo: _\u5185\u90e8\u306e\u5b9f\u88c5\u306e\u8a71\u3067\u3042\u3063\u3066\u3001\u5916\u90e8 (JavaScript\u5074) \u304b\u3089\u306f\u89b3\u6e2c\u3067\u304d\u306a\u3044\u3002\u77e5\u3063\u3066\u304a\u304b\u306a\u3044\u3068\u5bfe\u5fdc\u3067\u304d\u306a\u3044\u985e\u306e\u306f\u306a\u3057\u3063\u307d\u3044\u3002_\n\n- - -\n\n> When an **acquire the content operation** occurs on an **`AudioBuffer`**, run the following steps:\n\n> 1. If any of the **`AudioBuffer`**'s `ArrayBuffer` have been neutered, abort these steps, and return a zero-length channel data buffers to the invoker.\n> 2. Neuter all `ArrayBuffers` for arrays previously returned by `getChannelData` on this **`AudioBuffer`**.\n> 3. Retain the underlying data buffers from those `ArrayBuffers` and return references to them to the invoker.\n> 4. Attach `ArrayBuffers` containing copies of the data to the **`AudioBuffer`**, to be returned by the next call to `getChannelData`.\n\n**acquire the content operation** \u306f\u3001\u4ee5\u4e0b\u306e\u624b\u9806\u306b\u5f93\u3046:\n\n1. \u3044\u305a\u308c\u304b\u306e ArrayBuffer \u304c\u7121\u529b\u5316 (neutered) \u3055\u308c\u3066\u3044\u308b\u3068\u304d\u3053\u306e\u624b\u9806\u306f\u884c\u308f\u305a\u3001\u7a7a\u306e\u30c7\u30fc\u30bf\u3092\u8fd4\u3059\u3002\n2. ArrayBuffer \u306e\u30c7\u30fc\u30bf\u3092\u7121\u529b\u5316\u3059\u308b (JavaScript\u5074\u304b\u3089\u898b\u3048\u306a\u304f\u306a\u308b)\n3. ArrayBuffer \u306e\u30c7\u30fc\u30bf\u3092\u4fdd\u6301\u3057\u3001\u53c2\u7167\u3092\u8fd4\u3057\u307e\u3059 (C++\u3067\u898b\u3048\u308b\u3088\u3046\u306b\u3059\u308b)\n4. (C++\u5074\u3067) \u4fdd\u6301\u3057\u3066\u3044\u308b\u30c7\u30fc\u30bf\u306f\u3001(JS\u5074\u306e) getChannelData \u306b\u3088\u3063\u3066\u8fd4\u3055\u308c\u308b\n\n:memo: _\u305f\u3076\u3093 4 \u306e\u6642\u306b ArrayBuffer \u306e\u518d\u78ba\u4fdd (\u30a2\u30ed\u30b1\u30fc\u30c8\u3068\u30b3\u30d4\u30fc) \u304c\u884c\u308f\u308c\u308b\u3002_\n\n- - -\n\n> The **acquire the contents of an AudioBuffer** operation is invoked in the following cases:\n\n> - When `AudioBufferSourceNode.start` is called, it acquires the contents of the node's `buffer`. If the operation fails, nothing is played.\n> - When a **`ConvolverNode`**'s `buffer` is set to an **`AudioBuffer`** while the node is connected to an output node, or a **`ConvolverNode`** is connected to an output node while the **`ConvolverNode`**'s `buffer` is set to an **`AudioBuffer`**, it acquires the content of the **`AudioBuffer`**.\n> - When the dispatch of an **`AudioProcessingEvent`** completes, it acquires the contents of its `outputBuffer`.\n\n**acquire the contents** \u306f\u4ee5\u4e0b\u306e\u5834\u5408\u306b\u8d77\u3053\u308b\n\n- `AudioBufferSourceNode.start` \u304c\u547c\u3070\u308c\u305f\u3068\u304d\n- \u4ed6\u306e\u30ce\u30fc\u30c9\u306b\u63a5\u7d9a\u3055\u308c\u3066\u3044\u308b `ConvolverNode` \u306e buffer \u304c\u30bb\u30c3\u30c8\u3055\u308c\u305f\u3068\u304d\n- buffer \u304c\u30bb\u30c3\u30c8\u3055\u308c\u3066\u3044\u308b `ConvolverNode` \u304c\u4ed6\u306e\u30ce\u30fc\u30c9\u306b\u63a5\u7d9a\u3055\u308c\u305f\u3068\u304d\n- `AudioProcessingEvent` \u304c\u5b8c\u4e86\u3057\u305f\u3068\u304d\n\n:memo: _\u4e0a\u8a18\u306e\u3068\u304d\u306b AudioBuffer \u306e\u5185\u5bb9\u304c\u5b9f\u88c5\u5074\u306b\u8ee2\u9001\u3055\u308c\u3066\u3001JavaScript \u5074\u304b\u3089\u89e6\u308c\u306a\u304f\u306a\u308b\u3002_\n\n- - -\n\n\u305f\u3076\u3093\u3053\u3046\u3044\u3046\u3053\u3068\u3060\u3068\u601d\u3046\u3002\n\n```javascript\nvar audioContext = new AudioContext();\nvar audioBuffer = audioContext.createBuffer(1, 10000, 44100);\nvar convolver = audioContext.createConvolver();\n\naudioBuffer.getChannelData(0).set([ 0, 1, 2, 3, 4, 5, 6, 7 ]);\n\nvar savedBuffer = audioBuffer.getChannelData(0);\n\nconsole.log(savedBuffer); // [ 0, 1, 2, 3, 4, 5, 6, 7, 0 ... 0 ]\n\nconvolver.buffer = audioBuffer;\nconvolver.connect(audioContext.destination); // \u3053\u3053\u3067 acquire the contents \n\n// acquire the contents \u306b\u3088\u308a JavaScript\u5074\u304b\u3089\u53c2\u7167\u3067\u304d\u306a\u304f\u306a\u308b\nconsole.log(savedBuffer); // []\n\n// getChannelData \u3092\u3059\u308c\u3070\u30c7\u30fc\u30bf\u3092\u898b\u308b\u3053\u3068\u306f\u3067\u304d\u308b\n// \u3053\u306e\u3068\u304d\u306b ArrayBuffer \u306e\u518d\u78ba\u4fdd (\u30a2\u30ed\u30b1\u30fc\u30c8\u3068\u30b3\u30d4\u30fc) \u304c\u884c\u308f\u308c\u308b\nvar tempBuffer = audioBuffer.getChannelData(0);\nconsole.log(tempBuffer); // [ 0, 1, 2, 3, 4, 5, 6, 7, 0 ... 0 ]\nconsole.log(tempBuffer.buffer.byteLength); // 10000 * 4\n// getChannelData \u3060\u3068\u547c\u3070\u308c\u308b\u305f\u3073\u306b 40000\u30d0\u30a4\u30c8\u306e ArrayBuffer \u304c\u751f\u6210\u3055\u308c\u308b(\u5834\u5408\u304c\u3042\u308b)\n\n// \u65b0\u3057\u3044 API \u3092\u4f7f\u3046\u5834\u5408\nvar tempBuffer = new Float32Array(8);\naudioBuffer.copyFromChannel(tempBuffer, 0);\nconsole.log(tempBuffer); // [ 0, 1, 2, 3, 4, 5, 6, 7 ]\nconsole.log(tempBuffer.buffer.byteLength); // 8 * 4\n// copyFromChannel \u3060\u3068\u3042\u3089\u304b\u3058\u3081\u78ba\u4fdd\u3057\u3066\u3044\u308b\u9818\u57df\u306b\u66f8\u304d\u8fbc\u3080\u3060\u3051\u306a\u306e\u3067\u3001\u30e1\u30e2\u30ea\u78ba\u4fdd\u7b49\u306f\u8d77\u3053\u3089\u306a\u3044\n```\n"}