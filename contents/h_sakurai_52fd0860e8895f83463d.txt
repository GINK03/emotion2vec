{"context": " More than 1 year has passed since last update.\n\n\u30a4\u30f3\u30b9\u30c8\u30fc\u30eb\nhttps://github.com/hsk/notes/blob/master/XamarinStudio_Install/index.md\n\n\u30a4\u30f3\u30bf\u30d7\u30ea\u30bf\nFSharp\u3067\u306f\u4ee3\u6570\u30c7\u30fc\u30bf\u578b\u3068\u30d1\u30bf\u30fc\u30f3\u30de\u30c3\u30c1\u30f3\u30b0\u3092\u4f7f\u3046\u4e8b\u3067\u30a4\u30f3\u30bf\u30d7\u30ea\u30bf\u3092\u4ee5\u4e0b\u306e\u3088\u3046\u306b\u66f8\u304f\u4e8b\u304c\u51fa\u6765\u307e\u3059\u3002\n\u4ee5\u4e0b\u306e\u30d7\u30ed\u30b0\u30e9\u30e0\u306f (1 + 2) * 3\u3092\u8a08\u7b97\u3057\u3066\u51fa\u529b\u3059\u308b\u7269\u3067\u3059\u3002\nE\u304c\u5f0f\u3092\u8868\u3057\u3001ELd\u304c\u6570\u5024\u3092EAdd\u304c\u8db3\u3057\u7b97\u3001ESub,EMul,EDiv\u304c\u305d\u308c\u305e\u308c\u5f15\u304d\u7b97\u3001\u304b\u3051\u7b97\u3001\u5272\u7b97\u3092\u8868\u3057\u307e\u3059\u3002\n\u30aa\u30d6\u30b8\u30a7\u30af\u30c8\u6307\u5411\u3067\u8003\u3048\u308c\u3070\u3001E\u3068\u3044\u3046abstract\u306a\u30af\u30e9\u30b9\u3068E\u3092\u7d99\u627f\u3057\u305f\u30af\u30e9\u30b9\u304cELd,EAdd,ESub,EMul,EDiv\u3092\u5b9a\u7fa9\u3057\u305f\u611f\u3058\u3067\u3059\u3002\neval\u304c\u5024\u3092\u8a55\u4fa1\u3059\u308b\u95a2\u6570\u3067E\u3092\u53d7\u3051\u53d6\u3063\u3066\u8a08\u7b97\u3092\u3059\u308b\u95a2\u6570\u3067\u3059\u3002\nF#\u3067\u306f\u518d\u5e30\u7684\u95a2\u6570\u3092\u5b9a\u7fa9\u3059\u308b\u3068\u304d\u306flet rec\u3092\u4f7f\u3063\u3066\u5b9a\u7fa9\u3057\u307e\u3059\u3002\nmatch\u69cb\u6587\u3092\u4f7f\u3046\u4e8b\u3067\u3001E\u306e\u5168\u3066\u306e\u30d1\u30bf\u30fc\u30f3\u306b\u3064\u3044\u3066\u66f8\u304d\u4e0b\u3059\u4e8b\u304c\u51fa\u6765\u307e\u3059\u3002\n\u307e\u305f\u3001\u30d0\u30a4\u30f3\u30c7\u30a3\u30f3\u30b0\u306e\u6a5f\u80fd\u3092\u4f7f\u3046\u4e8b\u3067\u3001\u5404\u5909\u6570\u30e1\u30f3\u30d0\u306b\u540d\u524d\u3092\u4ed8\u3051\u3066\u30a2\u30af\u30bb\u30b9\u3059\u308b\u4e8b\u304c\u51fa\u6765\u308b\u3088\u3046\u306b\u66f8\u304f\u4e8b\u304c\u51fa\u6765\u307e\u3059\u3002\u3053\u306e\u6a5f\u80fd\u306e\u304a\u304b\u3052\u3067\u3001\u3068\u304f\u306b\u5b9a\u7fa9\u3092\u898b\u306b\u884c\u304b\u306a\u304f\u3066\u3082\u3001\u95a2\u6570\u306e\u305d\u306e\u5834\u6240\u3060\u3051\u898b\u308c\u3070\u3001\u3069\u306e\u3088\u3046\u306a\u4e8b\u304c\u884c\u308f\u308c\u308b\u304b\u304c\u76f4\u611f\u7684\u306b\u7406\u89e3\u51fa\u6765\u307e\u3059\u3002\n\u307e\u305f\u3001FSharp\u306fPython\u3084Haskell\u306e\u3088\u3046\u306b\u3001\u30cd\u30b9\u30c8\u306b\u5bc4\u308b\u30d6\u30ed\u30c3\u30af\u3044\u308f\u3086\u308b\u30aa\u30d5\u30b5\u30a4\u30c9\u30eb\u30fc\u30eb\u3092\u4f7f\u3063\u3066\u95a2\u6570\u3092\u66f8\u304f\u4e8b\u304c\u51fa\u6765\u308b\u306e\u3067\u3001\u304b\u3063\u3053\u3092\u66f8\u304b\u306a\u304f\u3066\u6e08\u307f\u307e\u3059\u3002\n\u95a2\u6570\u306freturn\u3068\u66f8\u304b\u306a\u304f\u3066\u3082\u3001\u6570\u5024\u304c\u305d\u306e\u307e\u307e\u8fd4\u5374\u3055\u308c\u307e\u3059\u3002\u305f\u3068\u3048\u3070\u3001main\u95a2\u6570\u306fuint\u3092\u8fd4\u5374\u3059\u308b\u5fc5\u8981\u304c\u3042\u308b\u306e\u3067\u3059\u304c\u30010\u3068\u3060\u3051\u6700\u5f8c\u306b\u66f8\u3051\u30700\u304c\u8fd4\u308a\u307e\u3059\u3002\nopen System\n\ntype E =\n    | ELd of int\n    | EAdd of E * E\n    | ESub of E * E\n    | EMul of E * E\n    | EDiv of E * E\n\nlet rec eval(e:E):int =\n    match e with\n    | ELd(i) -> i\n    | EAdd(a,b) -> eval(a) + eval(b)\n    | ESub(a,b) -> eval(a) - eval(b)\n    | EMul(a,b) -> eval(a) * eval(b)\n    | EDiv(a,b) -> eval(a) / eval(b)\n\nlet i = eval(EMul(EAdd(ELd(1),ELd(2)),ELd(3)))\nConsole.WriteLine i\n\n\n\u30d1\u30fc\u30b5\nFSharp\u306e\u5834\u5408\u306fFsLex\u3068FsYacc\u3084FParsec\u7b49\u306e\u30b3\u30f3\u30d1\u30a4\u30e9\u30b3\u30f3\u30d1\u30a4\u30e9(\u30b3\u30f3\u30d1\u30a4\u30e9\u3092\u4f5c\u308b\u70ba\u306e\u30c4\u30fc\u30eb)\u304c\u3042\u308a\u307e\u3059\u3002\u9ad8\u901f\u3067\u3001\u30d5\u30a9\u30fc\u30de\u30eb\u306a\u6587\u6cd5\u3092\u6c7a\u3081\u3066\u30d1\u30fc\u30b5\u3092\u66f8\u304d\u305f\u3044\u5834\u5408\u306f\u3053\u308c\u3089\u306e\u30c4\u30fc\u30eb\u3092\u4f7f\u3046\u3068\u826f\u3044\u3067\u3059\u3002\n\u3057\u304b\u3057\u3001\u3053\u308c\u3089\u306e\u30c4\u30fc\u30eb\u3092\u4f7f\u3046\u306e\u306f\u6163\u308c\u308b\u307e\u3067\u306f\u76f4\u611f\u7684\u3067\u306f\u306a\u3044\u306e\u3067\u96e3\u3057\u3044\u3068\u3053\u308d\u304c\u3042\u308a\u307e\u3059\u3002\n\u305d\u3053\u3067\u3001\u3053\u3053\u3067\u306f\u3001\u518d\u5e30\u4e0b\u964d\u578b\u306e\u30d1\u30fc\u30b5\u3092\u7d39\u4ecb\u3057\u307e\u3059\u3002\n\u518d\u5e30\u95a2\u6570\u3068\u3057\u3066\u30d1\u30fc\u30b5\u3092\u66f8\u304f\u306e\u3067\u76f4\u611f\u7684\u306b\u628a\u63e1\u3057\u3084\u3059\u3044\u306f\u305a\u3067\u3059\u3002\nopen System\nopen System.Text.RegularExpressions\n\ntype E =\n    | ELd of int\n    | EAdd of E * E\n    | ESub of E * E\n    | EMul of E * E\n    | EDiv of E * E\n\nlet rec eval(e:E):int =\n    match e with\n    | ELd(i) -> i\n    | EAdd(a,b) -> eval(a) + eval(b)\n    | ESub(a,b) -> eval(a) - eval(b)\n    | EMul(a,b) -> eval(a) * eval(b)\n    | EDiv(a,b) -> eval(a) / eval(b)\n\nlet parse(str:String):E =\n    let (|ParseRegex|_|) regex str =\n       let m = Regex(regex).Match(str)\n       if m.Success\n       then Some (List.tail [ for x in m.Groups -> x.Value ])\n       else None\n    (**\n     * \u4e88\u6e2c\u3055\u308c\u305f\u30c8\u30fc\u30af\u30f3\u3092\u53d6\u308a\u9664\u304f\n     *)\n    let rec eat(es:(E * string), eatStr:string):(E * string) =\n        let eatReg = \"^[ \\\\r\\\\n\\\\t]*\"+eatStr+\"(.*)$\"\n        match es with\n        | (a,ParseRegex eatReg [str]) -> (a, str)\n        | _ -> raise (Exception \"error\")\n\n    (**\n     * \u8db3\u3057\u7b97\u304bterm\n     *)\n    let rec exp(str:string):(E * string) =\n        let rec exp2(es:(E * string)):(E * string) =\n            match es with\n            | (a, ParseRegex \"^[ \\r\\n\\t]*\\\\+(.*)$\" [str]) ->\n                let (b, str2) = term(str)\n                exp2(EAdd(a, b), str2)\n            | (a, ParseRegex \"^[ \\r\\n\\t]*-(.*)$\" [str]) ->\n                let (b, str2) = term(str)\n                exp2(ESub(a, b), str2)\n            | _ -> es\n        exp2(term(str))\n\n    (**\n     * \u639b\u3051\u7b97\u304b\u3001fact\n     *)\n    and term(str:String):(E * String) =\n        let rec term2(es:(E * String)):(E * String) =\n            match es with\n            | (a, ParseRegex \"^[ \\r\\n\\t]*\\*(.*)$\" [ str]) ->\n                let (b, str2) = fact(str)\n                term2(EMul(a, b), str2)\n            | (a, ParseRegex \"^[ \\r\\n\\t]*/(.*)$\" [ str]) ->\n                let (b, str2) = fact(str)\n                term2(EDiv(a, b), str2)\n            | _ -> es\n        term2(fact(str))\n    (**\n     * \u6570\u5b57\u3042\u308b\u3044\u306f( exp )\n     *)\n    and fact(str:String):(E * String) =\n        match str with\n        | ParseRegex \"^[ \\r\\n\\t]*([0-9]+)(.*)$\" [i;str] -> (ELd( Int32.Parse(i) ) ,str)\n        | ParseRegex \"^[ \\r\\n\\t]*(\\\\()(.*)$\" [str] -> eat(exp(str), \"\\\\)\")\n        | _ -> raise (Exception \"error\")\n    // exp\u306e\u547c\u3073\u51fa\u3057\u3068\u30a8\u30e9\u30fc\u306e\u51e6\u7406\n    match exp(str) with\n    | (a, ParseRegex \"^[ \\r\\n\\t]*$\" []) -> a\n    | _ -> raise (Exception \"error\")\n\n\nlet e = parse (\"1+2*3\")\nlet i = eval(e)\nConsole.WriteLine i\n\n\n\u30b9\u30bf\u30c3\u30af\u30de\u30b7\u30f3\u30b3\u30f3\u30d1\u30a4\u30e9\n\u30a4\u30f3\u30bf\u30d7\u30ea\u30bf\u306f\u4f5c\u308c\u307e\u3057\u305f\u306e\u3067\u3001\u30b9\u30bf\u30c3\u30af\u30de\u30b7\u30f3\u3068\u30b9\u30bf\u30c3\u30af\u30de\u30b7\u30f3\u306e\u30b3\u30f3\u30d1\u30a4\u30e9\u3092\u4f5c\u3063\u3066\u307f\u307e\u3057\u3087\u3046\u3002\u30b9\u30bf\u30c3\u30af\u30de\u30b7\u30f3\u306f\u4f8b\u3048\u3070\u3001Forth\u3084Java\u3001.Net Framework\u3001PostScript\u7b49\u3067\u63a1\u7528\u3055\u308c\u3066\u3044\u307e\u3059\u3002\n\u30d7\u30ed\u30b0\u30e9\u30e0\u306e\u64cd\u4f5c\u3092\u30b9\u30bf\u30c3\u30af\u306b\u5bfe\u3057\u3066\u884c\u3046\u3088\u3046\u306b\u3059\u308b\u4e8b\u3067\u3001\u69cb\u9020\u5316\u3055\u308c\u305f\u30d7\u30ed\u30b0\u30e9\u30e0\u3092\u76f4\u5217\u7684\u306b\u6271\u3046\u4e8b\u304c\u51fa\u6765\u307e\u3059\u3002\n\u307e\u305f\u3001\u30ec\u30b8\u30b9\u30bf\u5272\u308a\u4ed8\u3051\u3082\u5fc5\u8981\u3042\u308a\u307e\u305b\u3093\u3002\n\u307e\u305f\u3001\u30b9\u30bf\u30c3\u30af\u3092\u30ea\u30b9\u30c8\u3068\u3057\u3066\u8868\u3059\u3068\u3001VM\u3092\u3068\u3066\u3082\u30b9\u30c3\u30ad\u30ea\u66f8\u304f\u4e8b\u304c\u51fa\u6765\u307e\u3059\u3002\ntype Code =\n| CAdd\n| CMul\n| CSub\n| CDiv\n| CLd of int\n\nlet compile (e:E):Code list =\n    let rec comp(e:E,codes:Code list):Code list =\n        match e with\n        | ELd(i) -> CLd(i) :: codes \n        | EAdd(a,b) -> CAdd :: comp(a, comp(b, codes))\n        | ESub(a,b) -> CSub :: comp(a, comp(b, codes)) \n        | EMul(a,b) -> CMul :: comp(a, comp(b, codes))  \n        | EDiv(a,b) -> CDiv :: comp(a, comp(b, codes))\n    List.rev (comp(e, []))\n\nlet vm(codes:Code list):int =\n    let rec f(s:int list, c:Code list):int =\n        match (s, c) with\n        | (a::s, []) -> a\n        | (s,CLd(i)::c) -> f(i::s, c)\n        | (a::b::s, CAdd::c) -> f(a+b::s, c)\n        | (a::b::s, CSub::c) -> f(a-b::s, c)\n        | (a::b::s, CMul::c) -> f(a*b::s, c)\n        | (a::b::s, CDiv::c) -> f(a/b::s, c)\n        | (_, _) -> 0\n    f([], codes)\n\nlet e = parse (\"1+2*3\")\nlet codes = compile(e)\nConsole.WriteLine(codes)\nConsole.WriteLine(vm(codes))\n\n\nx86\u30b3\u30f3\u30d1\u30a4\u30e9\n\u6b21\u306f\u30cd\u30a4\u30c6\u30a3\u30d6\u30b3\u30f3\u30d1\u30a4\u30e9\u3092\u3064\u304f\u308a\u307e\u3059\u3002\n// test.c\n#include <stdio.h>\nint add(int a, int b) { return a + b; }\nint sub(int a, int b) { return a - b; }\nint mul(int a, int b) { return a * b; }\nint div(int a, int b) { return a / b; }\nprint_i(int a) { printf(\"%d\u00a5n\", a); }\nint main() {\n  int a = add(1,2);\n  print_i(a);\n}\n\n\u3068\u3044\u3046\u30d7\u30ed\u30b0\u30e9\u30e0\u3092\u4f5c\u3063\u3066\ngcc -S test.c\n\n\u3068\u5b9f\u884c\u3057\u3066\u51fa\u6765\u305f\u3001test.s\u3092\u898b\u307e\u3059\u3068\n```\ngcc -S -m32 test.c\n\u3067\u91cd\u8981\u306a\u6240\u3060\u3051\u898b\u307e\u3059\u3068\u3001addl\u304c\u8db3\u3057\u7b97\u3001subl\u304c\u5f15\u304d\u7b97\u3001imull\u304c\u304b\u3051\u7b97\u3001cltd\u3068idivl\u3067\u5272\u7b97\u306b\u306a\u308a\u307e\u3059\u3002\n\u3067\u3001\u3046\u307e\u304f\u3001print_i\u3092\u547c\u3073\u51fa\u3059\u6240\u3092\u66f8\u304d\u63db\u3048\u3066\u3084\u308c\u3070\u3046\u307e\u304f\u884c\u304f\u306f\u305a\u3067\u3059\u3002\n\u3067\u3001pushl,popl\u3067\u30de\u30b7\u30f3\u30b9\u30bf\u30c3\u30af\u306b\u5024\u3092\u5165\u308c\u305f\u308a\u3001\u51fa\u3057\u305f\u308a\u51fa\u6765\u308b\u306e\u3067\u3001\u305d\u306e\u8fba\u3092\u8003\u3048\u3066\u3046\u307e\u3044\u4e8b\u30d7\u30ed\u30b0\u30e9\u30e0\u3057\u3066\u3084\u308c\u3070\u826f\u3044\u306f\u305a\u3067\u3059\u3002\n\u3067\u3001\u3068\u308a\u3042\u3048\u305a\u3001\u7fd2\u3046\u3088\u308a\u6163\u308c\u308d\u3067\u3059\u3002\n\u4ee5\u4e0b\u306e\u30d7\u30ed\u30b0\u30e9\u30e0\u3092\u30b3\u30d4\u30da\u3057\u3066\u3001main\u3092\u66f8\u304d\u63db\u3048\u3066\u5b9f\u884c\u3057\u3066\u307f\u307e\u3057\u3087\u3046\u3002\nasm\u306f\u3001\u30d5\u30a1\u30a4\u30eb\u51fa\u529b\u306e\u70ba\u306e\u30e2\u30b8\u30e5\u30fc\u30eb\u3067\u3001exec\u304c\u30d7\u30ed\u30bb\u30b9\u5b9f\u884c\u306e\u30e2\u30b8\u30e5\u30fc\u30eb\u3067\u3059\u3002emit\u304cx86\u3078\u51fa\u529b\u3059\u308b\u95a2\u6570\u3067\u3059\u3002\nopen System\nopen System.Text.RegularExpressions\n\ntype E =\n    | ELd of int\n    | EAdd of E * E\n    | ESub of E * E\n    | EMul of E * E\n    | EDiv of E * E\n\nlet rec eval(e:E):int =\n    match e with\n    | ELd(i) -> i\n    | EAdd(a,b) -> eval(a) + eval(b)\n    | ESub(a,b) -> eval(a) - eval(b)\n    | EMul(a,b) -> eval(a) * eval(b)\n    | EDiv(a,b) -> eval(a) / eval(b)\n\nlet parse(str:String):E =\n    let (|ParseRegex|_|) regex str =\n       let m = Regex(regex).Match(str)\n       if m.Success\n       then Some (List.tail [ for x in m.Groups -> x.Value ])\n       else None\n\n    (**\n     * \u4e88\u6e2c\u3055\u308c\u305f\u30c8\u30fc\u30af\u30f3\u3092\u53d6\u308a\u9664\u304f\n     *)\n    let rec eat(es:(E * string), eatStr:string):(E * string) =\n        let eatReg = \"^[ \\\\r\\\\n\\\\t]*\"+eatStr+\"(.*)$\"\n        match es with\n        | (a,ParseRegex eatReg [str]) -> (a, str)\n        | _ -> raise (Exception \"error\")\n\n    (**\n     * \u8db3\u3057\u7b97\u304bterm\n     *)\n    let rec exp(str:string):(E * string) =\n        let rec exp2(es:(E * string)):(E * string) =\n            match es with\n            | (a, ParseRegex \"^[ \\r\\n\\t]*\\\\+(.*)$\" [str]) ->\n                let (b, str2) = term(str)\n                exp2(EAdd(a, b), str2)\n            | (a, ParseRegex \"^[ \\r\\n\\t]*-(.*)$\" [str]) ->\n                let (b, str2) = term(str)\n                exp2(ESub(a, b), str2)\n            | _ -> es\n        exp2(term(str))\n\n    (**\n     * \u639b\u3051\u7b97\u304b\u3001fact\n     *)\n    and term(str:String):(E * String) =\n        let rec term2(es:(E * String)):(E * String) =\n            match es with\n            | (a, ParseRegex \"^[ \\r\\n\\t]*\\*(.*)$\" [ str]) ->\n                let (b, str2) = fact(str)\n                term2(EMul(a, b), str2)\n            | (a, ParseRegex \"^[ \\r\\n\\t]*/(.*)$\" [ str]) ->\n                let (b, str2) = fact(str)\n                term2(EDiv(a, b), str2)\n            | _ -> es\n        term2(fact(str))\n    (**\n     * \u6570\u5b57\u3042\u308b\u3044\u306f( exp )\n     *)\n    and fact(str:String):(E * String) =\n        match str with\n        | ParseRegex \"^[ \\r\\n\\t]*([0-9]+)(.*)$\" [i;str] -> (ELd( Int32.Parse(i) ) ,str)\n        | ParseRegex \"^[ \\r\\n\\t]*(\\\\()(.*)$\" [str] -> eat(exp(str), \"\\\\)\")\n        | _ -> raise (Exception \"error\")\n    // exp\u306e\u547c\u3073\u51fa\u3057\u3068\u30a8\u30e9\u30fc\u306e\u51e6\u7406\n    match exp(str) with\n    | (a, ParseRegex \"^[ \\r\\n\\t]*$\" []) -> a\n    | _ -> raise (Exception \"error\")\n\ntype Code =\n| CAdd\n| CMul\n| CSub\n| CDiv\n| CLd of int\n\nlet compile (e:E):Code list =\n    let rec comp(e:E,codes:Code list):Code list =\n        match e with\n        | ELd(i) -> CLd(i) :: codes \n        | EAdd(a,b) -> CAdd :: comp(a, comp(b, codes))\n        | ESub(a,b) -> CSub :: comp(a, comp(b, codes)) \n        | EMul(a,b) -> CMul :: comp(a, comp(b, codes))  \n        | EDiv(a,b) -> CDiv :: comp(a, comp(b, codes))\n    List.rev (comp(e, []))\n\nopen System.IO\nopen System.Text\n\nmodule Asm =\n    let mutable writer:StreamWriter = null\n    let openFile(file:string): unit =\n        writer <- new StreamWriter(file, false, Encoding.UTF8)\n    let p(str:string):unit =\n        writer.WriteLine(str)\n    let p__(str:string):unit =\n        writer.WriteLine(\"        \"+str)\n    let close() =\n        writer.Close()\n\nopen System.IO\nopen System.Text\nopen System.Diagnostics\nopen System.Text.RegularExpressions\nopen System.Collections.Generic\n\nmodule Exec =\n    let readAll(filename:string):string =\n        File.ReadAllText(filename, Encoding.UTF8)\n    let run (cmd:string):(int * string * string) =\n        let mutable args = Regex.Split(cmd, \"[ \\t]+\", RegexOptions.IgnoreCase)\n        let program = args.[0]\n        let proc = new Process()\n        proc.StartInfo <- new ProcessStartInfo()\n        proc.StartInfo.FileName <- program\n        proc.StartInfo.Arguments <- System.String.Join(\" \", Array.sub args 1 (args.Length-1) )\n        proc.StartInfo.UseShellExecute <- false\n        proc.StartInfo.RedirectStandardOutput <- true\n        proc.StartInfo.RedirectStandardError  <- true\n        proc.Start() |> ignore\n        proc.WaitForExit()\n        (proc.ExitCode, proc.StandardOutput.ReadToEnd() ,proc.StandardError.ReadToEnd())\n\nmodule Emit =\n    let emit(file:string, codes:Code list):unit =\n        let rec f(c:Code):bool =\n            match c with\n            | CLd(i) ->\n                Asm.p__(\"pushl $\"+i.ToString())\n            | CAdd ->\n                Asm.p__(\"popl %eax\")\n                Asm.p__(\"popl %ecx\")\n                Asm.p__(\"addl %ecx, %eax\")\n                Asm.p__(\"pushl %eax\")\n            | CSub ->\n                Asm.p__(\"popl %eax\")\n                Asm.p__(\"popl %ecx\")\n                Asm.p__(\"subl %ecx, %eax\")\n                Asm.p__(\"pushl %eax\")\n            | CMul ->\n                Asm.p__(\"popl %eax\")\n                Asm.p__(\"popl %ecx\")\n                Asm.p__(\"imull %ecx, %eax\")\n                Asm.p__(\"pushl %eax\")\n            | CDiv ->\n                Asm.p__(\"popl %eax\")\n                Asm.p__(\"popl %ecx\")\n                Asm.p__(\"cltd\")\n                Asm.p__(\"idiv %ecx\")\n                Asm.p__(\"pushl %eax\")\n            true\n\n        Asm.openFile(file)\n        Asm.p(\"\"\"\n        .globl  _print_i\n        .align  4, 0x90\n_print_i:\n        pushl   %ebp\n        movl    %esp, %ebp\n        subl    $24, %esp\n        call    L5$pb\nL5$pb:\n        popl    %eax\n        movl    8(%ebp), %ecx\n        movl    %ecx, -4(%ebp)\n        movl    -4(%ebp), %ecx\n        movl    %esp, %edx\n        movl    %ecx, 4(%edx)\n        leal    L_.str-L5$pb(%eax), %eax\n        movl    %eax, (%edx)\n        call    _printf\n        movl    -8(%ebp), %eax\n        addl    $24, %esp\n        popl    %ebp\n        ret\n\n        .globl  _main\n        .align  4, 0x90\n_main:\n        pushl   %ebp\n        movl    %esp, %ebp\n        subl    $24, %esp\n        \"\"\")\n\n        List.forall f codes |> ignore\n\n        Asm.p(\"\"\"\n        popl %eax\n        movl    %eax, (%esp)\n        call    _print_i\n        movl    -4(%ebp), %eax\n        addl    $24, %esp\n        popl    %ebp\n        ret\n        .section        __TEXT,__cstring,cstring_literals\nL_.str:\n        .asciz   \"%d\\n\"\n        \"\"\" )\n        Asm.close()\n\nlet e: E = parse (\"1+2*3\")\nlet codes: Code list = compile(e)\nConsole.WriteLine(codes)\nConsole.WriteLine(Emit.emit(\"e.s\", codes))\nConsole.WriteLine(Exec.readAll(\"e.s\"))\nConsole.WriteLine(Exec.run(\"gcc -m32 e.s\"))\nConsole.WriteLine(Exec.run(\"./a.out\"))\n\n\nLLVM\u30b3\u30f3\u30d1\u30a4\u30e9\n\u30b9\u30bf\u30c3\u30af\u30de\u30b7\u30f3\u7684\u306a\u30a2\u30d7\u30ed\u30fc\u30c1\u3067\u306f\u3001\u305d\u308c\u306a\u308a\u306b\u52d5\u4f5c\u3059\u308b\u30d7\u30ed\u30b0\u30e9\u30e0\u306f\u4f5c\u308c\u307e\u3059\u304c\u3001push,pop,push,pop\u3068\u5927\u91cf\u306b\u3042\u308b\u306e\u3067\u3001\u30d7\u30ed\u30b0\u30e9\u30e0\u30b5\u30a4\u30ba\u304c\u80a5\u5927\u5316\u3057\u3066\u3057\u307e\u3044\u307e\u3059\u3002\u305d\u3053\u3067\u3001\u30ec\u30b8\u30b9\u30bf\u30a2\u30ed\u30b1\u30fc\u30b7\u30e7\u30f3\u3068\u3044\u3046\u51e6\u7406\u3092\u3059\u308b\u4e8b\u3067\u3001\u7121\u99c4\u306a\u30b9\u30bf\u30c3\u30af\u64cd\u4f5c\u3092\u7121\u304f\u3057\u3066\u3001\u51fa\u6765\u308b\u3060\u3051\u30e1\u30e2\u30ea\u306f\u4f7f\u308f\u305a\u306b\u3001\u30ec\u30b8\u30b9\u30bf\u5185\u3067\u6e08\u307e\u305b\u3089\u308c\u308b\u4e8b\u306a\u3089\u6e08\u307e\u305b\u308b\u3088\u3046\u306b\u3059\u308b\u3068\u826f\u3044\u3067\u3059\u3002\n\u3057\u304b\u3057\u3001\u3053\u306e\u30ec\u30b8\u30b9\u30bf\u30a2\u30ed\u30b1\u30fc\u30b7\u30e7\u30f3\u306e\u51e6\u7406\u3092\u307e\u3058\u3081\u306b\u3084\u308d\u3046\u3068\u3059\u308b\u3068\u975e\u5e38\u306b\u5927\u5909\u3067\u3059\u3002\u307e\u305f\u3001\u8907\u6570CPU\u306b\u5bfe\u3057\u3066\u540c\u3058\u3088\u3046\u306a\u4e8b\u3092\u3057\u3088\u3046\u3068\u3057\u305f\u3089\u66f4\u306b\u5927\u5909\u3067\u3059\u3002\n\u305d\u3053\u3067\u3001\u3082\u3046\u8ae6\u3081\u3066LLVM\u3092\u4f7f\u3063\u3066\u4efb\u305b\u3066\u3057\u307e\u3044\u307e\u3057\u3087\u3046\u3002\n\n## \u30a4\u30f3\u30b9\u30c8\u30fc\u30eb\n\nhttps://github.com/hsk/notes/blob/master/XamarinStudio_Install/index.md\n\n## \u30a4\u30f3\u30bf\u30d7\u30ea\u30bf\n\nFSharp\u3067\u306f\u4ee3\u6570\u30c7\u30fc\u30bf\u578b\u3068\u30d1\u30bf\u30fc\u30f3\u30de\u30c3\u30c1\u30f3\u30b0\u3092\u4f7f\u3046\u4e8b\u3067\u30a4\u30f3\u30bf\u30d7\u30ea\u30bf\u3092\u4ee5\u4e0b\u306e\u3088\u3046\u306b\u66f8\u304f\u4e8b\u304c\u51fa\u6765\u307e\u3059\u3002\n\n\u4ee5\u4e0b\u306e\u30d7\u30ed\u30b0\u30e9\u30e0\u306f (1 + 2) * 3\u3092\u8a08\u7b97\u3057\u3066\u51fa\u529b\u3059\u308b\u7269\u3067\u3059\u3002\n\nE\u304c\u5f0f\u3092\u8868\u3057\u3001ELd\u304c\u6570\u5024\u3092EAdd\u304c\u8db3\u3057\u7b97\u3001ESub,EMul,EDiv\u304c\u305d\u308c\u305e\u308c\u5f15\u304d\u7b97\u3001\u304b\u3051\u7b97\u3001\u5272\u7b97\u3092\u8868\u3057\u307e\u3059\u3002\n\n\u30aa\u30d6\u30b8\u30a7\u30af\u30c8\u6307\u5411\u3067\u8003\u3048\u308c\u3070\u3001E\u3068\u3044\u3046abstract\u306a\u30af\u30e9\u30b9\u3068E\u3092\u7d99\u627f\u3057\u305f\u30af\u30e9\u30b9\u304cELd,EAdd,ESub,EMul,EDiv\u3092\u5b9a\u7fa9\u3057\u305f\u611f\u3058\u3067\u3059\u3002\n\neval\u304c\u5024\u3092\u8a55\u4fa1\u3059\u308b\u95a2\u6570\u3067E\u3092\u53d7\u3051\u53d6\u3063\u3066\u8a08\u7b97\u3092\u3059\u308b\u95a2\u6570\u3067\u3059\u3002\n\nF#\u3067\u306f\u518d\u5e30\u7684\u95a2\u6570\u3092\u5b9a\u7fa9\u3059\u308b\u3068\u304d\u306flet rec\u3092\u4f7f\u3063\u3066\u5b9a\u7fa9\u3057\u307e\u3059\u3002\nmatch\u69cb\u6587\u3092\u4f7f\u3046\u4e8b\u3067\u3001E\u306e\u5168\u3066\u306e\u30d1\u30bf\u30fc\u30f3\u306b\u3064\u3044\u3066\u66f8\u304d\u4e0b\u3059\u4e8b\u304c\u51fa\u6765\u307e\u3059\u3002\n\u307e\u305f\u3001\u30d0\u30a4\u30f3\u30c7\u30a3\u30f3\u30b0\u306e\u6a5f\u80fd\u3092\u4f7f\u3046\u4e8b\u3067\u3001\u5404\u5909\u6570\u30e1\u30f3\u30d0\u306b\u540d\u524d\u3092\u4ed8\u3051\u3066\u30a2\u30af\u30bb\u30b9\u3059\u308b\u4e8b\u304c\u51fa\u6765\u308b\u3088\u3046\u306b\u66f8\u304f\u4e8b\u304c\u51fa\u6765\u307e\u3059\u3002\u3053\u306e\u6a5f\u80fd\u306e\u304a\u304b\u3052\u3067\u3001\u3068\u304f\u306b\u5b9a\u7fa9\u3092\u898b\u306b\u884c\u304b\u306a\u304f\u3066\u3082\u3001\u95a2\u6570\u306e\u305d\u306e\u5834\u6240\u3060\u3051\u898b\u308c\u3070\u3001\u3069\u306e\u3088\u3046\u306a\u4e8b\u304c\u884c\u308f\u308c\u308b\u304b\u304c\u76f4\u611f\u7684\u306b\u7406\u89e3\u51fa\u6765\u307e\u3059\u3002\n\n\u307e\u305f\u3001FSharp\u306fPython\u3084Haskell\u306e\u3088\u3046\u306b\u3001\u30cd\u30b9\u30c8\u306b\u5bc4\u308b\u30d6\u30ed\u30c3\u30af\u3044\u308f\u3086\u308b\u30aa\u30d5\u30b5\u30a4\u30c9\u30eb\u30fc\u30eb\u3092\u4f7f\u3063\u3066\u95a2\u6570\u3092\u66f8\u304f\u4e8b\u304c\u51fa\u6765\u308b\u306e\u3067\u3001\u304b\u3063\u3053\u3092\u66f8\u304b\u306a\u304f\u3066\u6e08\u307f\u307e\u3059\u3002\n\u95a2\u6570\u306freturn\u3068\u66f8\u304b\u306a\u304f\u3066\u3082\u3001\u6570\u5024\u304c\u305d\u306e\u307e\u307e\u8fd4\u5374\u3055\u308c\u307e\u3059\u3002\u305f\u3068\u3048\u3070\u3001main\u95a2\u6570\u306fuint\u3092\u8fd4\u5374\u3059\u308b\u5fc5\u8981\u304c\u3042\u308b\u306e\u3067\u3059\u304c\u30010\u3068\u3060\u3051\u6700\u5f8c\u306b\u66f8\u3051\u30700\u304c\u8fd4\u308a\u307e\u3059\u3002\n\n```fsharp:\nopen System\n\ntype E =\n    | ELd of int\n    | EAdd of E * E\n    | ESub of E * E\n    | EMul of E * E\n    | EDiv of E * E\n\nlet rec eval(e:E):int =\n    match e with\n    | ELd(i) -> i\n    | EAdd(a,b) -> eval(a) + eval(b)\n    | ESub(a,b) -> eval(a) - eval(b)\n    | EMul(a,b) -> eval(a) * eval(b)\n    | EDiv(a,b) -> eval(a) / eval(b)\n\nlet i = eval(EMul(EAdd(ELd(1),ELd(2)),ELd(3)))\nConsole.WriteLine i\n```\n\n## \u30d1\u30fc\u30b5\n\nFSharp\u306e\u5834\u5408\u306fFsLex\u3068FsYacc\u3084FParsec\u7b49\u306e\u30b3\u30f3\u30d1\u30a4\u30e9\u30b3\u30f3\u30d1\u30a4\u30e9(\u30b3\u30f3\u30d1\u30a4\u30e9\u3092\u4f5c\u308b\u70ba\u306e\u30c4\u30fc\u30eb)\u304c\u3042\u308a\u307e\u3059\u3002\u9ad8\u901f\u3067\u3001\u30d5\u30a9\u30fc\u30de\u30eb\u306a\u6587\u6cd5\u3092\u6c7a\u3081\u3066\u30d1\u30fc\u30b5\u3092\u66f8\u304d\u305f\u3044\u5834\u5408\u306f\u3053\u308c\u3089\u306e\u30c4\u30fc\u30eb\u3092\u4f7f\u3046\u3068\u826f\u3044\u3067\u3059\u3002\n\n\u3057\u304b\u3057\u3001\u3053\u308c\u3089\u306e\u30c4\u30fc\u30eb\u3092\u4f7f\u3046\u306e\u306f\u6163\u308c\u308b\u307e\u3067\u306f\u76f4\u611f\u7684\u3067\u306f\u306a\u3044\u306e\u3067\u96e3\u3057\u3044\u3068\u3053\u308d\u304c\u3042\u308a\u307e\u3059\u3002\n\u305d\u3053\u3067\u3001\u3053\u3053\u3067\u306f\u3001\u518d\u5e30\u4e0b\u964d\u578b\u306e\u30d1\u30fc\u30b5\u3092\u7d39\u4ecb\u3057\u307e\u3059\u3002\n\u518d\u5e30\u95a2\u6570\u3068\u3057\u3066\u30d1\u30fc\u30b5\u3092\u66f8\u304f\u306e\u3067\u76f4\u611f\u7684\u306b\u628a\u63e1\u3057\u3084\u3059\u3044\u306f\u305a\u3067\u3059\u3002\n\n```fsharp:\nopen System\nopen System.Text.RegularExpressions\n\ntype E =\n    | ELd of int\n    | EAdd of E * E\n    | ESub of E * E\n    | EMul of E * E\n    | EDiv of E * E\n\nlet rec eval(e:E):int =\n    match e with\n    | ELd(i) -> i\n    | EAdd(a,b) -> eval(a) + eval(b)\n    | ESub(a,b) -> eval(a) - eval(b)\n    | EMul(a,b) -> eval(a) * eval(b)\n    | EDiv(a,b) -> eval(a) / eval(b)\n\nlet parse(str:String):E =\n    let (|ParseRegex|_|) regex str =\n       let m = Regex(regex).Match(str)\n       if m.Success\n       then Some (List.tail [ for x in m.Groups -> x.Value ])\n       else None\n    (**\n     * \u4e88\u6e2c\u3055\u308c\u305f\u30c8\u30fc\u30af\u30f3\u3092\u53d6\u308a\u9664\u304f\n     *)\n    let rec eat(es:(E * string), eatStr:string):(E * string) =\n        let eatReg = \"^[ \\\\r\\\\n\\\\t]*\"+eatStr+\"(.*)$\"\n        match es with\n        | (a,ParseRegex eatReg [str]) -> (a, str)\n        | _ -> raise (Exception \"error\")\n\n    (**\n     * \u8db3\u3057\u7b97\u304bterm\n     *)\n    let rec exp(str:string):(E * string) =\n        let rec exp2(es:(E * string)):(E * string) =\n            match es with\n            | (a, ParseRegex \"^[ \\r\\n\\t]*\\\\+(.*)$\" [str]) ->\n                let (b, str2) = term(str)\n                exp2(EAdd(a, b), str2)\n            | (a, ParseRegex \"^[ \\r\\n\\t]*-(.*)$\" [str]) ->\n                let (b, str2) = term(str)\n                exp2(ESub(a, b), str2)\n            | _ -> es\n        exp2(term(str))\n    \n    (**\n     * \u639b\u3051\u7b97\u304b\u3001fact\n     *)\n    and term(str:String):(E * String) =\n        let rec term2(es:(E * String)):(E * String) =\n            match es with\n            | (a, ParseRegex \"^[ \\r\\n\\t]*\\*(.*)$\" [ str]) ->\n                let (b, str2) = fact(str)\n                term2(EMul(a, b), str2)\n            | (a, ParseRegex \"^[ \\r\\n\\t]*/(.*)$\" [ str]) ->\n                let (b, str2) = fact(str)\n                term2(EDiv(a, b), str2)\n            | _ -> es\n        term2(fact(str))\n    (**\n     * \u6570\u5b57\u3042\u308b\u3044\u306f( exp )\n     *)\n    and fact(str:String):(E * String) =\n        match str with\n        | ParseRegex \"^[ \\r\\n\\t]*([0-9]+)(.*)$\" [i;str] -> (ELd( Int32.Parse(i) ) ,str)\n        | ParseRegex \"^[ \\r\\n\\t]*(\\\\()(.*)$\" [str] -> eat(exp(str), \"\\\\)\")\n        | _ -> raise (Exception \"error\")\n    // exp\u306e\u547c\u3073\u51fa\u3057\u3068\u30a8\u30e9\u30fc\u306e\u51e6\u7406\n    match exp(str) with\n    | (a, ParseRegex \"^[ \\r\\n\\t]*$\" []) -> a\n    | _ -> raise (Exception \"error\")\n    \n \nlet e = parse (\"1+2*3\")\nlet i = eval(e)\nConsole.WriteLine i\n```\n\n## \u30b9\u30bf\u30c3\u30af\u30de\u30b7\u30f3\u30b3\u30f3\u30d1\u30a4\u30e9\n\n\u30a4\u30f3\u30bf\u30d7\u30ea\u30bf\u306f\u4f5c\u308c\u307e\u3057\u305f\u306e\u3067\u3001\u30b9\u30bf\u30c3\u30af\u30de\u30b7\u30f3\u3068\u30b9\u30bf\u30c3\u30af\u30de\u30b7\u30f3\u306e\u30b3\u30f3\u30d1\u30a4\u30e9\u3092\u4f5c\u3063\u3066\u307f\u307e\u3057\u3087\u3046\u3002\u30b9\u30bf\u30c3\u30af\u30de\u30b7\u30f3\u306f\u4f8b\u3048\u3070\u3001Forth\u3084Java\u3001.Net Framework\u3001PostScript\u7b49\u3067\u63a1\u7528\u3055\u308c\u3066\u3044\u307e\u3059\u3002\n\u30d7\u30ed\u30b0\u30e9\u30e0\u306e\u64cd\u4f5c\u3092\u30b9\u30bf\u30c3\u30af\u306b\u5bfe\u3057\u3066\u884c\u3046\u3088\u3046\u306b\u3059\u308b\u4e8b\u3067\u3001\u69cb\u9020\u5316\u3055\u308c\u305f\u30d7\u30ed\u30b0\u30e9\u30e0\u3092\u76f4\u5217\u7684\u306b\u6271\u3046\u4e8b\u304c\u51fa\u6765\u307e\u3059\u3002\n\u307e\u305f\u3001\u30ec\u30b8\u30b9\u30bf\u5272\u308a\u4ed8\u3051\u3082\u5fc5\u8981\u3042\u308a\u307e\u305b\u3093\u3002\n\n\u307e\u305f\u3001\u30b9\u30bf\u30c3\u30af\u3092\u30ea\u30b9\u30c8\u3068\u3057\u3066\u8868\u3059\u3068\u3001VM\u3092\u3068\u3066\u3082\u30b9\u30c3\u30ad\u30ea\u66f8\u304f\u4e8b\u304c\u51fa\u6765\u307e\u3059\u3002\n\n```fsharp:\ntype Code =\n| CAdd\n| CMul\n| CSub\n| CDiv\n| CLd of int\n\nlet compile (e:E):Code list =\n    let rec comp(e:E,codes:Code list):Code list =\n        match e with\n        | ELd(i) -> CLd(i) :: codes \n        | EAdd(a,b) -> CAdd :: comp(a, comp(b, codes))\n        | ESub(a,b) -> CSub :: comp(a, comp(b, codes)) \n        | EMul(a,b) -> CMul :: comp(a, comp(b, codes))  \n        | EDiv(a,b) -> CDiv :: comp(a, comp(b, codes))\n    List.rev (comp(e, []))\n\nlet vm(codes:Code list):int =\n    let rec f(s:int list, c:Code list):int =\n        match (s, c) with\n        | (a::s, []) -> a\n        | (s,CLd(i)::c) -> f(i::s, c)\n        | (a::b::s, CAdd::c) -> f(a+b::s, c)\n        | (a::b::s, CSub::c) -> f(a-b::s, c)\n        | (a::b::s, CMul::c) -> f(a*b::s, c)\n        | (a::b::s, CDiv::c) -> f(a/b::s, c)\n        | (_, _) -> 0\n    f([], codes)\n    \nlet e = parse (\"1+2*3\")\nlet codes = compile(e)\nConsole.WriteLine(codes)\nConsole.WriteLine(vm(codes))\n```\n\n## x86\u30b3\u30f3\u30d1\u30a4\u30e9\n\n\u6b21\u306f\u30cd\u30a4\u30c6\u30a3\u30d6\u30b3\u30f3\u30d1\u30a4\u30e9\u3092\u3064\u304f\u308a\u307e\u3059\u3002\n\n```c:\n// test.c\n#include <stdio.h>\nint add(int a, int b) { return a + b; }\nint sub(int a, int b) { return a - b; }\nint mul(int a, int b) { return a * b; }\nint div(int a, int b) { return a / b; }\nprint_i(int a) { printf(\"%d\u00a5n\", a); }\nint main() {\n  int a = add(1,2);\n  print_i(a);\n}\n```\n\u3068\u3044\u3046\u30d7\u30ed\u30b0\u30e9\u30e0\u3092\u4f5c\u3063\u3066\n\n```bash:\ngcc -S test.c\n```\n\u3068\u5b9f\u884c\u3057\u3066\u51fa\u6765\u305f\u3001test.s\u3092\u898b\u307e\u3059\u3068\n```\n\ngcc -S -m32 test.c\n\n\u3067\u91cd\u8981\u306a\u6240\u3060\u3051\u898b\u307e\u3059\u3068\u3001addl\u304c\u8db3\u3057\u7b97\u3001subl\u304c\u5f15\u304d\u7b97\u3001imull\u304c\u304b\u3051\u7b97\u3001cltd\u3068idivl\u3067\u5272\u7b97\u306b\u306a\u308a\u307e\u3059\u3002\n\u3067\u3001\u3046\u307e\u304f\u3001print_i\u3092\u547c\u3073\u51fa\u3059\u6240\u3092\u66f8\u304d\u63db\u3048\u3066\u3084\u308c\u3070\u3046\u307e\u304f\u884c\u304f\u306f\u305a\u3067\u3059\u3002\n\u3067\u3001pushl,popl\u3067\u30de\u30b7\u30f3\u30b9\u30bf\u30c3\u30af\u306b\u5024\u3092\u5165\u308c\u305f\u308a\u3001\u51fa\u3057\u305f\u308a\u51fa\u6765\u308b\u306e\u3067\u3001\u305d\u306e\u8fba\u3092\u8003\u3048\u3066\u3046\u307e\u3044\u4e8b\u30d7\u30ed\u30b0\u30e9\u30e0\u3057\u3066\u3084\u308c\u3070\u826f\u3044\u306f\u305a\u3067\u3059\u3002\n\u3067\u3001\u3068\u308a\u3042\u3048\u305a\u3001\u7fd2\u3046\u3088\u308a\u6163\u308c\u308d\u3067\u3059\u3002\n\u4ee5\u4e0b\u306e\u30d7\u30ed\u30b0\u30e9\u30e0\u3092\u30b3\u30d4\u30da\u3057\u3066\u3001main\u3092\u66f8\u304d\u63db\u3048\u3066\u5b9f\u884c\u3057\u3066\u307f\u307e\u3057\u3087\u3046\u3002\nasm\u306f\u3001\u30d5\u30a1\u30a4\u30eb\u51fa\u529b\u306e\u70ba\u306e\u30e2\u30b8\u30e5\u30fc\u30eb\u3067\u3001exec\u304c\u30d7\u30ed\u30bb\u30b9\u5b9f\u884c\u306e\u30e2\u30b8\u30e5\u30fc\u30eb\u3067\u3059\u3002emit\u304cx86\u3078\u51fa\u529b\u3059\u308b\u95a2\u6570\u3067\u3059\u3002\n\n```fsharp:\nopen System\nopen System.Text.RegularExpressions\n\ntype E =\n    | ELd of int\n    | EAdd of E * E\n    | ESub of E * E\n    | EMul of E * E\n    | EDiv of E * E\n\nlet rec eval(e:E):int =\n    match e with\n    | ELd(i) -> i\n    | EAdd(a,b) -> eval(a) + eval(b)\n    | ESub(a,b) -> eval(a) - eval(b)\n    | EMul(a,b) -> eval(a) * eval(b)\n    | EDiv(a,b) -> eval(a) / eval(b)\n\nlet parse(str:String):E =\n    let (|ParseRegex|_|) regex str =\n       let m = Regex(regex).Match(str)\n       if m.Success\n       then Some (List.tail [ for x in m.Groups -> x.Value ])\n       else None\n\n    (**\n     * \u4e88\u6e2c\u3055\u308c\u305f\u30c8\u30fc\u30af\u30f3\u3092\u53d6\u308a\u9664\u304f\n     *)\n    let rec eat(es:(E * string), eatStr:string):(E * string) =\n        let eatReg = \"^[ \\\\r\\\\n\\\\t]*\"+eatStr+\"(.*)$\"\n        match es with\n        | (a,ParseRegex eatReg [str]) -> (a, str)\n        | _ -> raise (Exception \"error\")\n\n    (**\n     * \u8db3\u3057\u7b97\u304bterm\n     *)\n    let rec exp(str:string):(E * string) =\n        let rec exp2(es:(E * string)):(E * string) =\n            match es with\n            | (a, ParseRegex \"^[ \\r\\n\\t]*\\\\+(.*)$\" [str]) ->\n                let (b, str2) = term(str)\n                exp2(EAdd(a, b), str2)\n            | (a, ParseRegex \"^[ \\r\\n\\t]*-(.*)$\" [str]) ->\n                let (b, str2) = term(str)\n                exp2(ESub(a, b), str2)\n            | _ -> es\n        exp2(term(str))\n    \n    (**\n     * \u639b\u3051\u7b97\u304b\u3001fact\n     *)\n    and term(str:String):(E * String) =\n        let rec term2(es:(E * String)):(E * String) =\n            match es with\n            | (a, ParseRegex \"^[ \\r\\n\\t]*\\*(.*)$\" [ str]) ->\n                let (b, str2) = fact(str)\n                term2(EMul(a, b), str2)\n            | (a, ParseRegex \"^[ \\r\\n\\t]*/(.*)$\" [ str]) ->\n                let (b, str2) = fact(str)\n                term2(EDiv(a, b), str2)\n            | _ -> es\n        term2(fact(str))\n    (**\n     * \u6570\u5b57\u3042\u308b\u3044\u306f( exp )\n     *)\n    and fact(str:String):(E * String) =\n        match str with\n        | ParseRegex \"^[ \\r\\n\\t]*([0-9]+)(.*)$\" [i;str] -> (ELd( Int32.Parse(i) ) ,str)\n        | ParseRegex \"^[ \\r\\n\\t]*(\\\\()(.*)$\" [str] -> eat(exp(str), \"\\\\)\")\n        | _ -> raise (Exception \"error\")\n    // exp\u306e\u547c\u3073\u51fa\u3057\u3068\u30a8\u30e9\u30fc\u306e\u51e6\u7406\n    match exp(str) with\n    | (a, ParseRegex \"^[ \\r\\n\\t]*$\" []) -> a\n    | _ -> raise (Exception \"error\")\n\ntype Code =\n| CAdd\n| CMul\n| CSub\n| CDiv\n| CLd of int\n\nlet compile (e:E):Code list =\n    let rec comp(e:E,codes:Code list):Code list =\n        match e with\n        | ELd(i) -> CLd(i) :: codes \n        | EAdd(a,b) -> CAdd :: comp(a, comp(b, codes))\n        | ESub(a,b) -> CSub :: comp(a, comp(b, codes)) \n        | EMul(a,b) -> CMul :: comp(a, comp(b, codes))  \n        | EDiv(a,b) -> CDiv :: comp(a, comp(b, codes))\n    List.rev (comp(e, []))\n\nopen System.IO\nopen System.Text\n\nmodule Asm =\n    let mutable writer:StreamWriter = null\n    let openFile(file:string): unit =\n        writer <- new StreamWriter(file, false, Encoding.UTF8)\n    let p(str:string):unit =\n        writer.WriteLine(str)\n    let p__(str:string):unit =\n        writer.WriteLine(\"        \"+str)\n    let close() =\n        writer.Close()\n\nopen System.IO\nopen System.Text\nopen System.Diagnostics\nopen System.Text.RegularExpressions\nopen System.Collections.Generic\n\nmodule Exec =\n    let readAll(filename:string):string =\n        File.ReadAllText(filename, Encoding.UTF8)\n    let run (cmd:string):(int * string * string) =\n        let mutable args = Regex.Split(cmd, \"[ \\t]+\", RegexOptions.IgnoreCase)\n        let program = args.[0]\n        let proc = new Process()\n        proc.StartInfo <- new ProcessStartInfo()\n        proc.StartInfo.FileName <- program\n        proc.StartInfo.Arguments <- System.String.Join(\" \", Array.sub args 1 (args.Length-1) )\n        proc.StartInfo.UseShellExecute <- false\n        proc.StartInfo.RedirectStandardOutput <- true\n        proc.StartInfo.RedirectStandardError  <- true\n        proc.Start() |> ignore\n        proc.WaitForExit()\n        (proc.ExitCode, proc.StandardOutput.ReadToEnd() ,proc.StandardError.ReadToEnd())\n\nmodule Emit =\n    let emit(file:string, codes:Code list):unit =\n        let rec f(c:Code):bool =\n            match c with\n            | CLd(i) ->\n                Asm.p__(\"pushl $\"+i.ToString())\n            | CAdd ->\n                Asm.p__(\"popl %eax\")\n                Asm.p__(\"popl %ecx\")\n                Asm.p__(\"addl %ecx, %eax\")\n                Asm.p__(\"pushl %eax\")\n            | CSub ->\n                Asm.p__(\"popl %eax\")\n                Asm.p__(\"popl %ecx\")\n                Asm.p__(\"subl %ecx, %eax\")\n                Asm.p__(\"pushl %eax\")\n            | CMul ->\n                Asm.p__(\"popl %eax\")\n                Asm.p__(\"popl %ecx\")\n                Asm.p__(\"imull %ecx, %eax\")\n                Asm.p__(\"pushl %eax\")\n            | CDiv ->\n                Asm.p__(\"popl %eax\")\n                Asm.p__(\"popl %ecx\")\n                Asm.p__(\"cltd\")\n                Asm.p__(\"idiv %ecx\")\n                Asm.p__(\"pushl %eax\")\n            true\n\n        Asm.openFile(file)\n        Asm.p(\"\"\"\n        .globl  _print_i\n        .align  4, 0x90\n_print_i:\n        pushl   %ebp\n        movl    %esp, %ebp\n        subl    $24, %esp\n        call    L5$pb\nL5$pb:\n        popl    %eax\n        movl    8(%ebp), %ecx\n        movl    %ecx, -4(%ebp)\n        movl    -4(%ebp), %ecx\n        movl    %esp, %edx\n        movl    %ecx, 4(%edx)\n        leal    L_.str-L5$pb(%eax), %eax\n        movl    %eax, (%edx)\n        call    _printf\n        movl    -8(%ebp), %eax\n        addl    $24, %esp\n        popl    %ebp\n        ret\n\n        .globl  _main\n        .align  4, 0x90\n_main:\n        pushl   %ebp\n        movl    %esp, %ebp\n        subl    $24, %esp\n        \"\"\")\n\n        List.forall f codes |> ignore\n\n        Asm.p(\"\"\"\n        popl %eax\n        movl    %eax, (%esp)\n        call    _print_i\n        movl    -4(%ebp), %eax\n        addl    $24, %esp\n        popl    %ebp\n        ret\n        .section        __TEXT,__cstring,cstring_literals\nL_.str:\n        .asciz   \"%d\\n\"\n        \"\"\" )\n        Asm.close()\n\nlet e: E = parse (\"1+2*3\")\nlet codes: Code list = compile(e)\nConsole.WriteLine(codes)\nConsole.WriteLine(Emit.emit(\"e.s\", codes))\nConsole.WriteLine(Exec.readAll(\"e.s\"))\nConsole.WriteLine(Exec.run(\"gcc -m32 e.s\"))\nConsole.WriteLine(Exec.run(\"./a.out\"))\n```\n\n## LLVM\u30b3\u30f3\u30d1\u30a4\u30e9\n\n\u30b9\u30bf\u30c3\u30af\u30de\u30b7\u30f3\u7684\u306a\u30a2\u30d7\u30ed\u30fc\u30c1\u3067\u306f\u3001\u305d\u308c\u306a\u308a\u306b\u52d5\u4f5c\u3059\u308b\u30d7\u30ed\u30b0\u30e9\u30e0\u306f\u4f5c\u308c\u307e\u3059\u304c\u3001push,pop,push,pop\u3068\u5927\u91cf\u306b\u3042\u308b\u306e\u3067\u3001\u30d7\u30ed\u30b0\u30e9\u30e0\u30b5\u30a4\u30ba\u304c\u80a5\u5927\u5316\u3057\u3066\u3057\u307e\u3044\u307e\u3059\u3002\u305d\u3053\u3067\u3001\u30ec\u30b8\u30b9\u30bf\u30a2\u30ed\u30b1\u30fc\u30b7\u30e7\u30f3\u3068\u3044\u3046\u51e6\u7406\u3092\u3059\u308b\u4e8b\u3067\u3001\u7121\u99c4\u306a\u30b9\u30bf\u30c3\u30af\u64cd\u4f5c\u3092\u7121\u304f\u3057\u3066\u3001\u51fa\u6765\u308b\u3060\u3051\u30e1\u30e2\u30ea\u306f\u4f7f\u308f\u305a\u306b\u3001\u30ec\u30b8\u30b9\u30bf\u5185\u3067\u6e08\u307e\u305b\u3089\u308c\u308b\u4e8b\u306a\u3089\u6e08\u307e\u305b\u308b\u3088\u3046\u306b\u3059\u308b\u3068\u826f\u3044\u3067\u3059\u3002\n\n\u3057\u304b\u3057\u3001\u3053\u306e\u30ec\u30b8\u30b9\u30bf\u30a2\u30ed\u30b1\u30fc\u30b7\u30e7\u30f3\u306e\u51e6\u7406\u3092\u307e\u3058\u3081\u306b\u3084\u308d\u3046\u3068\u3059\u308b\u3068\u975e\u5e38\u306b\u5927\u5909\u3067\u3059\u3002\u307e\u305f\u3001\u8907\u6570CPU\u306b\u5bfe\u3057\u3066\u540c\u3058\u3088\u3046\u306a\u4e8b\u3092\u3057\u3088\u3046\u3068\u3057\u305f\u3089\u66f4\u306b\u5927\u5909\u3067\u3059\u3002\n\n\u305d\u3053\u3067\u3001\u3082\u3046\u8ae6\u3081\u3066LLVM\u3092\u4f7f\u3063\u3066\u4efb\u305b\u3066\u3057\u307e\u3044\u307e\u3057\u3087\u3046\u3002\n\n", "tags": ["\u8a00\u8a9e\u4f5c\u6210", "F#"]}