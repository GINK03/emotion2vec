{"context": " More than 1 year has passed since last update.Swift \u306e\u52c9\u5f37\u306e\u305f\u3081\uff0cLisp \u306e\u30a4\u30f3\u30bf\u30d7\u30ea\u30bf\u3082\u3069\u304d\u3092\u4f5c\u3063\u3066\u307f\u307e\u3057\u305f\uff0e\n\u53c2\u8003\u306b\u3057\u305f\u306e\u306f\uff0cArc \u3068\u3044\u3046 Lisp \u306e\u65b9\u8a00\u3067\u3059\u304c\uff0c\u5168\u304f\u4f5c\u308a\u8fbc\u3081\u3066\u3044\u306a\u3044\u305f\u3081\uff0c\u300c\u3082\u3069\u304d\u300d\u3067\u3059\uff0e\u4f5c\u6210\u3057\u305f\u30bd\u30fc\u30b9\u306fgithub\u4e0a\u306b\u7f6e\u3044\u3066\u3042\u308a\u307e\u3059\uff0e\niPhone \u30a2\u30d7\u30ea\u3067\u306f\u306a\u304f\uff0cMac \u306e\u30b3\u30de\u30f3\u30c9\u30e9\u30a4\u30f3\u30a2\u30d7\u30ea\u3068\u3057\u3066\u4f5c\u6210\u3057\u3066\u3044\u307e\u3059\uff0e\n\u73fe\u6642\u70b9\u3067\u306f\u4ee5\u4e0b\u306e\u7a0b\u5ea6\u3057\u304b\u3067\u304d\u307e\u305b\u3093\uff0e\n\ncar, cdr, list, quote, lambda\u5f0f\n\u5909\u6570\u306e\u5b9a\u7fa9\u306b\u306f \"=\" \u3092\u4f7f\u3046\n\n\n(= x 1)\n(= y (lambda (z) (list z z z)))\n\n\n\n\u4eca\u56de\u4f5c\u3063\u3066\u307f\u305f\u3082\u306e\u306e\u57fa\u672c\u7684\u306a\u6d41\u308c\u306f\uff0c\n\nLisp \u306e\u578b\u3092\u8868\u3059\u30af\u30e9\u30b9\u306e\u4f5c\u6210\n\u6a19\u6e96\u5165\u529b\u304b\u3089\u6587\u5b57\u5217\u3092\u30d1\u30fc\u30b9\u3059\u308b\n\u30d1\u30fc\u30b9\u3057\u305f\u5185\u5bb9\u3092 Lisp \u306e\u30aa\u30d6\u30b8\u30a7\u30af\u30c8\u306b\u5909\u63db\nLisp \u306e\u30aa\u30d6\u30b8\u30a7\u30af\u30c8\u306b\u5bfe\u3057\u3066 eval \u3092\u547c\u3073\u51fa\u3057\u3066\u8a55\u4fa1\n\n\u3068\u306a\u308a\u307e\u3059\uff0e\n\n1. Lisp \u306e\u578b\u3092\u8868\u3059\u30af\u30e9\u30b9\u306e\u4f5c\u6210\n\nNil\uff0c\u6587\u5b57\u5217\uff0c\u30b7\u30f3\u30dc\u30eb\uff0c\u6570\u5b57\uff0c\u30ea\u30b9\u30c8\u3068\uff0c\u74b0\u5883\u3092\u8868\u3059\u30af\u30e9\u30b9\u3092\u4f5c\u6210\u3057\u307e\u3057\u305f\n\n\nLispObj \u30d7\u30ed\u30c8\u30b3\u30eb\n\n\u5171\u901a\u306e protocol \u3068\u3057\u3066 LispObj \u3092\u6301\u3064\u3088\u3046\u306b\u3057\u3066\u3044\u307e\u3059\nLispObj \u306f\uff0c\u826f\u304f\u4f7f\u3046\u30ea\u30b9\u30c8\u578b\u304b\u3069\u3046\u304b\u3092\u30c1\u30a7\u30c3\u30af\u3059\u308b listp \u3068\uff0c\u753b\u9762\u8868\u793a\u306b\u4f7f\u3046 toStr \u306e\u307f\u3092\u5b9a\u7fa9\u3057\u307e\u3057\u305f\nprotocol \u304c Java \u3067\u3044\u3046\u30a4\u30f3\u30bf\u30fc\u30d5\u30a7\u30a4\u30b9\u306b\u3042\u305f\u308b\u3082\u306e\u3060\u3068\u7406\u89e3\u3057\u3066\u3044\u307e\u3059\n\nprotocol LispObj {\n    func toStr() -> String\n    func listp() -> ConsCell?\n}\n\n\nSwift \u3067\u306f\u30d7\u30ed\u30b0\u30e9\u30e0\u4e2d\u306b\u300c?\u300d\u30de\u30fc\u30af\u3092\u4ed8\u3051\u308b\u3068\uff0cnil \u3092\u8a31\u5bb9\u3059\u308b\u3053\u3068\u304c\u51fa\u6765\u308b\u3068\u3044\u3046\u4ed5\u69d8\u306e\u3088\u3046\u3067\u3059\nOptionals \u3068\u547c\u3070\u308c\u3066\u3044\u308b\u3088\u3046\u3067\u3059\n?\u304c\u4ed8\u3044\u3066\u306a\u3044\u95a2\u6570\u3067\u306f nil \u3092\u8fd4\u305d\u3046\u3068\u3059\u308b\u3068\u30b3\u30f3\u30d1\u30a4\u30eb\u30a8\u30e9\u30fc\u306b\u306a\u3063\u305f\u6c17\u304c\u3057\u307e\u3059\n\u4f3c\u305f\u6a5f\u80fd\u3068\u3057\u3066\uff0c\u30ad\u30e3\u30b9\u30c8\u304c\u53ef\u80fd\u3067\u3042\u308c\u3070\u5b9f\u65bd\u3059\u308b\u304c\uff0c\u51fa\u6765\u306a\u3051\u308c\u3070\u3057\u306a\u3044\uff0c\u3068\u3044\u3046\u306e\u3092  as? \u3067\u8868\u3057\u307e\u3059\n\u4ee5\u4e0b\u306e\u3088\u3046\u306a\u611f\u3058\u3067\u7d50\u69cb\u591a\u7528\u3057\u3066\u3057\u307e\u3044\u307e\u3057\u305f\uff0e\u6b63\u3057\u3044\u304b\u306f\u3088\u304f\u308f\u304b\u308a\u307e\u305b\u3093\n\nif let hoge = foo as? Hoge {  // foo \u304c Hoge \u306b\u30ad\u30e3\u30b9\u30c8\u53ef\u80fd\u306a\u3089\u30ad\u30e3\u30b9\u30c8\n  // hoge \u3092 Hoge \u578b\u3068\u3057\u3066\u5229\u7528\u3059\u308b\n} else {\n  // \u30ad\u30e3\u30b9\u30c8\u4e0d\u53ef\u3060\u3063\u305f\u5834\u5408\u306e\u51e6\u7406\u3092\u3053\u3063\u3061\u306b\u66f8\u304f(hoge \u306f\u4f7f\u3048\u306a\u3044)\n}\n\n\nNil \u30af\u30e9\u30b9\n\nSingleton \u306e\u4f8b\u3068\u3057\u3066\u3053\u3053\u3092\u53c2\u8003\u306b\u3055\u305b\u3066\u9802\u304d\u307e\u3057\u305f\uff0e\n\nclass Nil: LispObj {\n    init() {\n    }\n\n    class var sharedInstance: Nil {\n        struct Singleton {\n            private static let instance = Nil()\n        }\n        return Singleton.instance\n    }\n\n    func toStr() -> String {\n        return \"nil\";\n    }\n\n    func listp() -> ConsCell? {\n        return nil;\n    }\n}\n\n\nSymbol \u30af\u30e9\u30b9\n\n\u7279\u306b\u4f55\u306e\u5de5\u592b\u3082\u7121\u3044\u30af\u30e9\u30b9\u3067\u3059\nLispNum \u3068 LispStr \u3082\u307b\u307c\u540c\u3058\u5185\u5bb9\u3067\u3059\n\nclass Symbol: LispObj {\n    var name: String;\n    init(name: String) {\n        self.name = name;\n    }\n\n    func toStr() -> String {\n        return name;\n    }\n\n    func listp() -> ConsCell? {\n        return nil;\n    }\n}\n\n\n\nError \u30af\u30e9\u30b9\n\nSwift \u306b\u306f\u4f8b\u5916\u304c\u7121\u3044\u3063\u307d\u3044\u306e\u3067\uff0c\u30a8\u30e9\u30fc\u306e\u30cf\u30f3\u30c9\u30ea\u30f3\u30b0\u7528\u306b Error \u30af\u30e9\u30b9\u3092\u4f5c\u6210\u3057\u307e\u3057\u305f\n\u4e2d\u8eab\u306f Symbol \u3068\u307b\u307c\u540c\u3058\u3067\u3059\uff0e\u3082\u3046\u5c11\u3057\u3044\u3044\u3084\u308a\u65b9\u304c\u3042\u308a\u305d\u3046\u306a\u6c17\u3082\u3057\u307e\u3059\uff0e\uff0e\n\nclass Error: LispObj {\n    var message: String;\n    init(message: String) {\n        self.message = message;\n    }\n\n    func toStr() -> String {\n        return \"Error: \" + message;\n    }\n\n    func listp() -> ConsCell? {\n        return nil;\n    }\n}\n\n\nConsCell \u30af\u30e9\u30b9\n\nLisp \u306e\u30ea\u30b9\u30c8\u3092\u8868\u308f\u3059\u305f\u3081\u306b\u4f5c\u6210\ncar \u90e8\u3068 cdr \u90e8\u3068\u3057\u3066\u305d\u308c\u305e\u308cLispObject\u3092\u6301\u3064\u3088\u3046\u306b\u3057\u305f\u4ed6\uff0ctoStr \u306f\u3061\u3087\u3063\u3068\u5909\u308f\u3063\u305fLisp\u5165\u9580\u3092\u53c2\u8003\u306b\u4f5c\u6210\u3057\u307e\u3057\u305f\uff0e\n\nclass ConsCell: LispObj {\n    var car: LispObj;\n    var cdr: LispObj;\n\n    init(car: LispObj, cdr: LispObj) {\n        self.car = car;\n        self.cdr = cdr;\n    }\n\n    func toStr() -> String {\n        var returnValue: String = \"\";\n\n        returnValue += \"(\";\n\n        var tmpcell = self;\n\n        while (true) {\n            returnValue += tmpcell.car.toStr();\n\n            if let cdrcell = tmpcell.cdr.listp() {\n                tmpcell = cdrcell;\n            } else if tmpcell.cdr is Nil {\n                break;\n            } else { //if tmpcell.cdr.isAtom() {\n                returnValue += \".\";\n                returnValue += tmpcell.cdr.toStr();\n                break;\n            }\n            returnValue += \" \";\n        }\n        returnValue += \")\"\n\n        return returnValue;\n    }\n\n    func listp() -> ConsCell? {\n        return self;\n    }\n}\n\n\n2. \u6a19\u6e96\u5165\u529b\u304b\u3089\u6587\u5b57\u5217\u3092\u30d1\u30fc\u30b9\u3059\u308b\n\n\u6a19\u6e96\u5165\u529b\u304b\u3089\u6587\u5b57\u5217\u53d6\u5f97\n\n\n\u3053\u3053\u3092\u53c2\u8003\u306b\uff0c\u4ee5\u4e0b\u306e\u3088\u3046\u306a\u95a2\u6570\u3092\u4f5c\u308a\u307e\u3057\u305f\n\u30ab\u30fc\u30bd\u30eb\u30ad\u30fc\u7b49\u306b\u3082\u5165\u529b\u5024\u304c\u5272\u308a\u5f53\u3066\u3089\u308c\u3066\u3044\u308b\u3088\u3046\u3067\uff0c\u4ee5\u4e0b\u306e\u547c\u3073\u51fa\u3057\u6642\u306b\u62bc\u3059\u3068\uff0c\u4e88\u671f\u3057\u306a\u3044\u52d5\u4f5c\u306b\u306a\u3063\u305f\u308a\u3057\u307e\u3059\n\nfunc read() -> String {\n    var tmp = NSFileHandle.fileHandleWithStandardInput();\n\n    var rawdata = tmp.availableData;\n    var str = NSString(data: rawdata, encoding: NSUTF8StringEncoding);\n\n    return str;\n}\n\n\n\u53d6\u5f97\u3057\u305f\u6587\u5b57\u5217\u3092\u914d\u5217\u306b\u5909\u63db\n\n\u5fc5\u8981\u306a\u8981\u7d20\u6bce\u306b\u5206\u5272\u3057\u3066\u914d\u5217\u306b\u5165\u529b\u3057\u3066\u3044\u307e\u3059\n\u6587\u5b57\u5217\u64cd\u4f5c\u306e\u95a2\u6570\u304c\u3042\u307e\u308a\u51fa\u63c3\u3063\u3066\u3044\u306a\u3044\u6a21\u69d8\u3067\uff0c\u7d30\u304b\u3044\u51e6\u7406\u304c\u3084\u308a\u3065\u3089\u3044\u3067\u3059\nLisp \u3067\u306f quote \u8a18\u53f7\u304c\u7279\u5225\u306a\u610f\u5473\u3092\u6301\u3064\u306e\u3067\uff0c\u5909\u63db\u51e6\u7406\u3082\u52a0\u3048\u3066\u3044\u307e\u3059\n\n// \u89e3\u6790\u7d50\u679c\u306e\u30c8\u30fc\u30af\u30f3\u30ea\u30b9\u30c8\u3092\u5165\u308c\u308b\u914d\u5217\nvar tokenlist: [String] = [];\n\n// \u3069\u3053\u307e\u3067\u8aad\u307f\u8fbc\u3093\u3060\u304b\u3092\u8868\u3059\u914d\u5217\nvar tokenIndex = 0;\n\nfunc tokenize(str: String) { //-> ([String], Int) {\n    // ' (quote\u8a18\u53f7\u3092 (quote  ... ) \u306b\u7f6e\u304d\u63db\u3048\n\n    var str2 = \"\"\n    var quoteFlag = false\n    for a in str {\n        if a == \"'\" {\n            str2 += \"(quote \"\n            quoteFlag = true\n        } else if a == \")\" && quoteFlag {\n            str2 += \"))\"\n            quoteFlag = false;\n        } else {\n            str2 += a\n        }\n    }\n\n    // \"(\" \u3068 \")\" \u3092\u7a7a\u767d\u4ed8\u304d\u306b\u5909\u63db\n    let replacedStr = str2\n        .stringByReplacingOccurrencesOfString(\"(\", withString: \" ( \", options: nil, range: nil)\n        .stringByReplacingOccurrencesOfString(\")\", withString: \" ) \", options: nil, range: nil)\n        .stringByReplacingOccurrencesOfString(\"\\n\", withString: \" \", options: nil, range: nil);\n\n    tokenlist = replacedStr.componentsSeparatedByString(\" \");\n    tokenIndex = 0;\n}\n\n\n3. \u30d1\u30fc\u30b9\u3057\u305f\u5185\u5bb9\u3092 Lisp \u306e\u30aa\u30d6\u30b8\u30a7\u30af\u30c8\u306b\u5909\u63db\n\n\u3053\u3053\u307e\u3067\u3067\uff0c\u30d1\u30fc\u30b9\u3057\u305f Lisp \u306e\u30d7\u30ed\u30b0\u30e9\u30e0\u304c\u914d\u5217\u306b\u683c\u7d0d\u3055\u308c\u3066\u3044\u308b\u305f\u3081\uff0cLispObj \u306b\u5909\u63db\u3059\u308b\n\u30ea\u30b9\u30c8\u3067\u306f\u306a\u3044\u5834\u5408\u306f\uff0cInt\u306b\u30ad\u30e3\u30b9\u30c8\u53ef\u80fd\u304b\u3084\uff0c\u30bb\u30df\u30b3\u30ed\u30f3\u3067\u56f2\u308f\u308c\u3066\u3044\u308b\u304b\u7b49\u3092\u78ba\u8a8d\u3057\u3066\u5bfe\u5fdc\u3059\u308b\u578b\u306b\u5909\u63db\n\u30ea\u30b9\u30c8\u306e\u8868\u73fe\u306e\u5834\u5408\u306f\u30ea\u30b9\u30c8\u578b\u306e\u30aa\u30d6\u30b8\u30a7\u30af\u30c8\u3092\u4f5c\u6210\u3059\u308b\n\nfunc parse() -> LispObj {\n    var c: LispObj;\n    c = read_next(get_token());\n    return c;\n}\nfunc read_next(var token: String) -> LispObj {\n    var carexp: LispObj, cdrexp: LispObj;\n    var list: LispObj = NIL;\n\n    if token == \"\" {\n        return NIL;\n    }\n    if (token != \"(\") {  // \"(\" \u3058\u3083\u306a\u3044\u3068\u304d\u306e\u51e6\u7406\n        if let n = token.toInt() {\n            return LispNum(value: n);\n        } else {\n            let prefix = token.hasPrefix(\"\\\"\");\n            let suffix = token.hasSuffix(\"\\\"\");\n            let length = token.utf16Count;\n\n            if prefix && suffix {  // \"hogehoge\" \u306e\u3088\u3046\u306b\u30bb\u30df\u30b3\u30ed\u30f3\u3067\u56f2\u308f\u308c\u3066\u3044\u308b\u5834\u5408\n                if length > 2 {\n                    return LispStr(value: token[1...token.utf16Count-2]);\n                } else {\n                    return LispStr(value: \"\");\n                }\n            } else if prefix || suffix {  // \"hogehoge \u306e\u3088\u3046\u306b\u7247\u65b9\u3060\u3051\u30bb\u30df\u30b3\u30ed\u30f3\u304c\u4ed8\u3044\u3066\u3044\u308b\u5834\u5408\n                return Error(message: \"wrong String:\" + token);\n            } else {\n                return Symbol(name: token);\n            }\n        }\n    }\n\n    token = get_token();  // ( \u306e\u6b21\u306e\u30c8\u30fc\u30af\u30f3\u3092\u53d6\u5f97\n    while (true) {  // \"(\" \u304b\u3089\u59cb\u307e\u308b\u3068\u304d\n        if (token == \")\") {\n            return list;\n        }\n\n        carexp = read_next(token);  // \u8aad\u307f\u8fbc\u3093\u3060\u30c8\u30fc\u30af\u30f3\u3092car\u90e8\u5206\u3068\u3057\u3066\u51e6\u7406\n        token = get_token();     // \u6b21\u306e\u30c8\u30fc\u30af\u30f3\u53d6\u5f97\n        if (token == \".\") {       // \u30da\u30a2\u306e\u5834\u5408\n            token = get_token();\n            cdrexp = read_next(token);  // \u53d6\u5f97\u3057\u305f\u6b21\u306e\u30c8\u30fc\u30af\u30f3\u3092 cdr \u306b\u30bb\u30c3\u30c8\n            token = get_token();   // \u30da\u30a2\u306e\u5f8c\u306f ) \u304c\u304f\u308b\u306f\u305a\n            if token != \")\" {\n                println(\") required!\");\n            }\n            return ConsCell(car: carexp, cdr: cdrexp);\n        }\n        list = concat(list, cons(carexp, NIL));\n    }\n}\n\n\n4. Lisp \u306e\u30aa\u30d6\u30b8\u30a7\u30af\u30c8\u306b\u5bfe\u3057\u3066 eval \u3092\u547c\u3073\u51fa\u3057\u3066\u8a55\u4fa1\n\n3\u307e\u3067\u3067\u4f5c\u6210\u3057\u305f LispObj \u3092\u4e0e\u3048\u3089\u308c\u305f\u74b0\u5883\u306e\u5143\u3067\u8a55\u4fa1\u3059\u308b\n\u6614\u4f5c\u3063\u305fLisp in Arc\u3092\u53c2\u8003\u306b\u5b9f\u88c5\n\u74b0\u5883\u306f Dictonary \u578b\u3092\u4f7f\u3044\uff0c\u540d\u524d\u3068\u5024\u3092\u7d10\u4ed8\u3051\u3059\u308b\n\u30af\u30ed\u30fc\u30b8\u30e3\u3092\u4f7f\u3046\u5834\u5408\u306f\uff0cDictonary \u3092\u30b0\u30ed\u30fc\u30d0\u30eb\u306e\u3082\u306e\u3068\u30af\u30ed\u30fc\u30b8\u30e3\u5185\u306e\u3082\u306e\u306b\u5206\u3051\u3066\u6271\u3046\n\nfunc eval(exp: LispObj, env: Environment) -> LispObj {\n    if exp is Error {\n        return exp;\n    }\n    if exp is Nil || exp is LispNum {  // Nil\u307e\u305f\u306f\u6570\u5024\u306e\u5834\u5408\u306f\u305d\u306e\u307e\u307e\u8fd4\u3059\n        return exp;\n    }\n    if exp is LispStr { // \u307e\u305f\u306f\u6587\u5b57\u5217\u306e\u5834\u5408\u3082\u305d\u306e\u307e\u307e\u8fd4\u3059(\u30a8\u30c7\u30a3\u30bf\u304c\u30a8\u30e9\u30fc\u306b\u306a\u308b\u305f\u3081\u3001 || \u306e\u9023\u7d50\u306f\u7981\u6b62\n        return exp;\n    }\n    if let symbol = exp as? Symbol {  // \u30b7\u30f3\u30dc\u30eb\u306a\u3089\u3070\u74b0\u5883\u306e\u5024\u3092\u691c\u7d22\u3057\u3066\u8fd4\u3059\n        var value = get(symbol.name, env);\n        if !(value is Nil) {\n            return value;\n        } else {\n            return Error(message: \"Undefined Value: \" + symbol.name);\n        }\n    }\n\n    if let consexp = exp.listp() {\n        return apply(consexp.car, consexp.cdr, env);\n    }\n\n    return Error(message: \"something wrong!\");\n}\n\nfunc apply(operator_var: LispObj, operand: LispObj, env: Environment) -> LispObj {\n    let operator_body = eval(operator_var, env);\n\n    let tmp = operand;\n    if eq(car(operator_body), PRIMITIVE) {  // \u30d7\u30ea\u30df\u30c6\u30a3\u30d6\u95a2\u6570\u306e\u5834\u5408\u306e\u51e6\u7406\n        switch cdr(operator_body).toStr() {\n        case \"car\":\n            return car(eval(car(operand), env));\n        case \"cdr\":\n            return cdr(eval(car(operand), env));\n        case \"=\":\n            // (= x 10)\n            // (= y \"test\")\n            // (= z (+ 1 2))\n            if let variable = car(operand) as? Symbol {  // -> x, y\n                let body = cadr(operand);   // 10, \"test\"\n                let value = eval(body, env);\n                def_var(variable, value, env);\n\n                return variable;\n            } else {\n                return Error(message: \"Wrong type argument: \" + car(operand).toStr());\n            }\n        case \"list\":\n            return eval_args(operand, env);\n        case \"quote\":\n            if cdr(operand) is Nil {\n                return car(operand);\n            } else {\n                return Error(message: \"Wrong number of arguments: \" + operand.toStr());\n            }\n        case \"lambda\":\n            // lambda\u5f0f\u306e\u5b9a\u7fa9\n            // (lambda (x) (+ x 1))\n            // operand: ((x) (+ x  1))\n            let params = car(operand)   // (x)\n            let body = cadr(operand)    // (+ x 1)\n\n            let tmp = cons(LispStr(value: LAMBDA), cons(params, cons(body, cons(env.copy(), NIL))));\n            return tmp\n\n        default:\n            return Error(message: \"unknown primitive procedure: \" + cdr(operator_body).toStr());\n        }\n    }\n\n    if eq(car(operator_body), LAMBDA) {\n        // lambda\u5f0f\u306e\u5b9f\u884c\n        // oparator_body : (\"*** lambda ***\" (x) (list x x x) [env])\n        let lambda_params = cadr(operator_body);    // (x)\n        let lambda_body = car(cddr(operator_body)); // (list x x x)\n        if let lambda_env = cadr(cddr(operator_body)) as? Environment { // [env]\n            let operand_check = eval_args(operand, env);\n            if (operand_check is Error) {\n                return operand_check;\n            }\n\n            if let ex_env = lambda_env.extend(lambda_params, operand: operand_check) {\n                return eval(lambda_body, ex_env);\n            } else {\n                return Error(message: \"eval lambda params error: \" + lambda_params.toStr() + \" \" + operand.toStr())\n            }\n        }\n    }\n\n    return Error(message: \"not a function: \" + operator_body.toStr());\n}\n\n\n\u307e\u3068\u3081\nSwift \u306f Java \u3068 JavaScript \u3068 Ruby \u304c\u307e\u3056\u3063\u305f\u3088\u3046\u306a\u611f\u3058\u3067\uff0c\u306a\u304b\u306a\u304b\u4f7f\u3044\u6613\u3044\u8a00\u8a9e\u306a\u6c17\u3082\u3057\u307e\u3059\uff0e\u304c\uff0c\u6587\u5b57\u5217\u306e\u64cd\u4f5c\u306e\u95a2\u6570\u304c\u5c11\u306a\u304b\u3063\u305f\u308a\uff0c\u03b2\u7248\u306a\u306e\u3067\u3059\u3050\u4ed5\u69d8\u304c\u5909\u308f\u3063\u305f\u308a\uff0cXcode \u304c\u3059\u3050\u843d\u3061\u305f\u308a\u3068\u307e\u3060\u307e\u3060\u306a\u90e8\u5206\u3082\u3042\u308a\u305d\u3046\u3067\u3059\uff0e\u4eca\u5f8c\u3069\u3046\u306a\u308b\u306e\u304b\u697d\u3057\u307f\u3067\u3059\uff0e\nObjective-C \u3068\u4e92\u63db\u3092\u4fdd\u3061\u7d9a\u3051\u308b\u3068\u306a\u308b\u3068\uff0c\u7d50\u5c40iPhone\u30a2\u30d7\u30ea\u4f5c\u308b\u3068\u304d\u306f\u3042\u306e\u9577\u3044\u95a2\u6570\u540d\u3068\u4ed8\u304d\u5408\u3044\u7d9a\u3051\u308b\u5fc5\u8981\u304c\u3042\u308b\u3093\u3067\u3057\u3087\u3046\u304b\u306d\uff0e\uff0e\uff0e\n\n\u53c2\u8003\n\nApple\u306eDeveloper\u30b5\u30a4\u30c8\nThe Swift Programming Language\nArc \u306e\u30c1\u30e5\u30fc\u30c8\u30ea\u30a2\u30eb\n\u3061\u3087\u3063\u3068\u5909\u308f\u3063\u305fLisp\u5165\u9580\nLisp in Arc\n\nSwift \u306e\u52c9\u5f37\u306e\u305f\u3081\uff0cLisp \u306e\u30a4\u30f3\u30bf\u30d7\u30ea\u30bf\u3082\u3069\u304d\u3092\u4f5c\u3063\u3066\u307f\u307e\u3057\u305f\uff0e\n\u53c2\u8003\u306b\u3057\u305f\u306e\u306f\uff0c[Arc](http://old.ycombinator.com/arc/tut.txt) \u3068\u3044\u3046 Lisp \u306e\u65b9\u8a00\u3067\u3059\u304c\uff0c\u5168\u304f\u4f5c\u308a\u8fbc\u3081\u3066\u3044\u306a\u3044\u305f\u3081\uff0c\u300c\u3082\u3069\u304d\u300d\u3067\u3059\uff0e\u4f5c\u6210\u3057\u305f\u30bd\u30fc\u30b9\u306f[github](https://github.com/torub/SwiftLisp)\u4e0a\u306b\u7f6e\u3044\u3066\u3042\u308a\u307e\u3059\uff0e\niPhone \u30a2\u30d7\u30ea\u3067\u306f\u306a\u304f\uff0cMac \u306e\u30b3\u30de\u30f3\u30c9\u30e9\u30a4\u30f3\u30a2\u30d7\u30ea\u3068\u3057\u3066\u4f5c\u6210\u3057\u3066\u3044\u307e\u3059\uff0e\n\n\u73fe\u6642\u70b9\u3067\u306f\u4ee5\u4e0b\u306e\u7a0b\u5ea6\u3057\u304b\u3067\u304d\u307e\u305b\u3093\uff0e\n\n- car, cdr, list, quote, lambda\u5f0f\n- \u5909\u6570\u306e\u5b9a\u7fa9\u306b\u306f \"=\" \u3092\u4f7f\u3046\n    * (= x 1)\n    * (= y (lambda (z) (list z z z)))\n\n\n\u4eca\u56de\u4f5c\u3063\u3066\u307f\u305f\u3082\u306e\u306e\u57fa\u672c\u7684\u306a\u6d41\u308c\u306f\uff0c\n\n1. Lisp \u306e\u578b\u3092\u8868\u3059\u30af\u30e9\u30b9\u306e\u4f5c\u6210\n2. \u6a19\u6e96\u5165\u529b\u304b\u3089\u6587\u5b57\u5217\u3092\u30d1\u30fc\u30b9\u3059\u308b\n3. \u30d1\u30fc\u30b9\u3057\u305f\u5185\u5bb9\u3092 Lisp \u306e\u30aa\u30d6\u30b8\u30a7\u30af\u30c8\u306b\u5909\u63db\n4. Lisp \u306e\u30aa\u30d6\u30b8\u30a7\u30af\u30c8\u306b\u5bfe\u3057\u3066 eval \u3092\u547c\u3073\u51fa\u3057\u3066\u8a55\u4fa1\n\n\u3068\u306a\u308a\u307e\u3059\uff0e\n\n## 1. Lisp \u306e\u578b\u3092\u8868\u3059\u30af\u30e9\u30b9\u306e\u4f5c\u6210\n- Nil\uff0c\u6587\u5b57\u5217\uff0c\u30b7\u30f3\u30dc\u30eb\uff0c\u6570\u5b57\uff0c\u30ea\u30b9\u30c8\u3068\uff0c\u74b0\u5883\u3092\u8868\u3059\u30af\u30e9\u30b9\u3092\u4f5c\u6210\u3057\u307e\u3057\u305f\n\n#### LispObj \u30d7\u30ed\u30c8\u30b3\u30eb\n- \u5171\u901a\u306e protocol \u3068\u3057\u3066 LispObj \u3092\u6301\u3064\u3088\u3046\u306b\u3057\u3066\u3044\u307e\u3059\n- LispObj \u306f\uff0c\u826f\u304f\u4f7f\u3046\u30ea\u30b9\u30c8\u578b\u304b\u3069\u3046\u304b\u3092\u30c1\u30a7\u30c3\u30af\u3059\u308b listp \u3068\uff0c\u753b\u9762\u8868\u793a\u306b\u4f7f\u3046 toStr \u306e\u307f\u3092\u5b9a\u7fa9\u3057\u307e\u3057\u305f\n- protocol \u304c Java \u3067\u3044\u3046\u30a4\u30f3\u30bf\u30fc\u30d5\u30a7\u30a4\u30b9\u306b\u3042\u305f\u308b\u3082\u306e\u3060\u3068\u7406\u89e3\u3057\u3066\u3044\u307e\u3059\n\n```Swift\nprotocol LispObj {\n    func toStr() -> String\n    func listp() -> ConsCell?\n}\n```\n\n- Swift \u3067\u306f\u30d7\u30ed\u30b0\u30e9\u30e0\u4e2d\u306b\u300c?\u300d\u30de\u30fc\u30af\u3092\u4ed8\u3051\u308b\u3068\uff0cnil \u3092\u8a31\u5bb9\u3059\u308b\u3053\u3068\u304c\u51fa\u6765\u308b\u3068\u3044\u3046\u4ed5\u69d8\u306e\u3088\u3046\u3067\u3059\n- Optionals \u3068\u547c\u3070\u308c\u3066\u3044\u308b\u3088\u3046\u3067\u3059\n- ?\u304c\u4ed8\u3044\u3066\u306a\u3044\u95a2\u6570\u3067\u306f nil \u3092\u8fd4\u305d\u3046\u3068\u3059\u308b\u3068\u30b3\u30f3\u30d1\u30a4\u30eb\u30a8\u30e9\u30fc\u306b\u306a\u3063\u305f\u6c17\u304c\u3057\u307e\u3059\n- \u4f3c\u305f\u6a5f\u80fd\u3068\u3057\u3066\uff0c\u30ad\u30e3\u30b9\u30c8\u304c\u53ef\u80fd\u3067\u3042\u308c\u3070\u5b9f\u65bd\u3059\u308b\u304c\uff0c\u51fa\u6765\u306a\u3051\u308c\u3070\u3057\u306a\u3044\uff0c\u3068\u3044\u3046\u306e\u3092  as? \u3067\u8868\u3057\u307e\u3059\n- \u4ee5\u4e0b\u306e\u3088\u3046\u306a\u611f\u3058\u3067\u7d50\u69cb\u591a\u7528\u3057\u3066\u3057\u307e\u3044\u307e\u3057\u305f\uff0e\u6b63\u3057\u3044\u304b\u306f\u3088\u304f\u308f\u304b\u308a\u307e\u305b\u3093\n\n```Swift\nif let hoge = foo as? Hoge {  // foo \u304c Hoge \u306b\u30ad\u30e3\u30b9\u30c8\u53ef\u80fd\u306a\u3089\u30ad\u30e3\u30b9\u30c8\n  // hoge \u3092 Hoge \u578b\u3068\u3057\u3066\u5229\u7528\u3059\u308b\n} else {\n  // \u30ad\u30e3\u30b9\u30c8\u4e0d\u53ef\u3060\u3063\u305f\u5834\u5408\u306e\u51e6\u7406\u3092\u3053\u3063\u3061\u306b\u66f8\u304f(hoge \u306f\u4f7f\u3048\u306a\u3044)\n}\n```\n\n#### Nil \u30af\u30e9\u30b9\n- Singleton \u306e\u4f8b\u3068\u3057\u3066[\u3053\u3053](http://qiita.com/1024jp/items/3a7bc437af3e79f74505)\u3092\u53c2\u8003\u306b\u3055\u305b\u3066\u9802\u304d\u307e\u3057\u305f\uff0e\n\n```Swift\nclass Nil: LispObj {\n    init() {\n    }\n    \n    class var sharedInstance: Nil {\n        struct Singleton {\n            private static let instance = Nil()\n        }\n        return Singleton.instance\n    }\n    \n    func toStr() -> String {\n        return \"nil\";\n    }\n    \n    func listp() -> ConsCell? {\n        return nil;\n    }\n}\n```\n\n#### Symbol \u30af\u30e9\u30b9\n- \u7279\u306b\u4f55\u306e\u5de5\u592b\u3082\u7121\u3044\u30af\u30e9\u30b9\u3067\u3059\n- LispNum \u3068 LispStr \u3082\u307b\u307c\u540c\u3058\u5185\u5bb9\u3067\u3059\n\n```Swift\nclass Symbol: LispObj {\n    var name: String;\n    init(name: String) {\n        self.name = name;\n    }\n    \n    func toStr() -> String {\n        return name;\n    }\n\n    func listp() -> ConsCell? {\n        return nil;\n    }\n}\n\n```\n\n#### Error \u30af\u30e9\u30b9\n- Swift \u306b\u306f\u4f8b\u5916\u304c\u7121\u3044\u3063\u307d\u3044\u306e\u3067\uff0c\u30a8\u30e9\u30fc\u306e\u30cf\u30f3\u30c9\u30ea\u30f3\u30b0\u7528\u306b Error \u30af\u30e9\u30b9\u3092\u4f5c\u6210\u3057\u307e\u3057\u305f\n- \u4e2d\u8eab\u306f Symbol \u3068\u307b\u307c\u540c\u3058\u3067\u3059\uff0e\u3082\u3046\u5c11\u3057\u3044\u3044\u3084\u308a\u65b9\u304c\u3042\u308a\u305d\u3046\u306a\u6c17\u3082\u3057\u307e\u3059\uff0e\uff0e\n\n```Swift\nclass Error: LispObj {\n    var message: String;\n    init(message: String) {\n        self.message = message;\n    }\n    \n    func toStr() -> String {\n        return \"Error: \" + message;\n    }\n    \n    func listp() -> ConsCell? {\n        return nil;\n    }\n}\n```\n\n#### ConsCell \u30af\u30e9\u30b9\n- Lisp \u306e\u30ea\u30b9\u30c8\u3092\u8868\u308f\u3059\u305f\u3081\u306b\u4f5c\u6210\n- car \u90e8\u3068 cdr \u90e8\u3068\u3057\u3066\u305d\u308c\u305e\u308cLispObject\u3092\u6301\u3064\u3088\u3046\u306b\u3057\u305f\u4ed6\uff0ctoStr \u306f[\u3061\u3087\u3063\u3068\u5909\u308f\u3063\u305fLisp\u5165\u9580](http://www.atmarkit.co.jp/ait/articles/0810/31/news148.html)\u3092\u53c2\u8003\u306b\u4f5c\u6210\u3057\u307e\u3057\u305f\uff0e\n\n```Swift\nclass ConsCell: LispObj {\n    var car: LispObj;\n    var cdr: LispObj;\n    \n    init(car: LispObj, cdr: LispObj) {\n        self.car = car;\n        self.cdr = cdr;\n    }\n    \n    func toStr() -> String {\n        var returnValue: String = \"\";\n        \n        returnValue += \"(\";\n        \n        var tmpcell = self;\n        \n        while (true) {\n            returnValue += tmpcell.car.toStr();\n            \n            if let cdrcell = tmpcell.cdr.listp() {\n                tmpcell = cdrcell;\n            } else if tmpcell.cdr is Nil {\n                break;\n            } else { //if tmpcell.cdr.isAtom() {\n                returnValue += \".\";\n                returnValue += tmpcell.cdr.toStr();\n                break;\n            }\n            returnValue += \" \";\n        }\n        returnValue += \")\"\n        \n        return returnValue;\n    }\n    \n    func listp() -> ConsCell? {\n        return self;\n    }\n}\n```\n\n## 2. \u6a19\u6e96\u5165\u529b\u304b\u3089\u6587\u5b57\u5217\u3092\u30d1\u30fc\u30b9\u3059\u308b\n#### \u6a19\u6e96\u5165\u529b\u304b\u3089\u6587\u5b57\u5217\u53d6\u5f97\n- [\u3053\u3053](http://stackoverflow.com/questions/24004776/input-from-the-keyboard-in-command-line-application)\u3092\u53c2\u8003\u306b\uff0c\u4ee5\u4e0b\u306e\u3088\u3046\u306a\u95a2\u6570\u3092\u4f5c\u308a\u307e\u3057\u305f\n- \u30ab\u30fc\u30bd\u30eb\u30ad\u30fc\u7b49\u306b\u3082\u5165\u529b\u5024\u304c\u5272\u308a\u5f53\u3066\u3089\u308c\u3066\u3044\u308b\u3088\u3046\u3067\uff0c\u4ee5\u4e0b\u306e\u547c\u3073\u51fa\u3057\u6642\u306b\u62bc\u3059\u3068\uff0c\u4e88\u671f\u3057\u306a\u3044\u52d5\u4f5c\u306b\u306a\u3063\u305f\u308a\u3057\u307e\u3059\n\n```Swift\nfunc read() -> String {\n    var tmp = NSFileHandle.fileHandleWithStandardInput();\n\n    var rawdata = tmp.availableData;\n    var str = NSString(data: rawdata, encoding: NSUTF8StringEncoding);\n    \n    return str;\n}\n```\n\n#### \u53d6\u5f97\u3057\u305f\u6587\u5b57\u5217\u3092\u914d\u5217\u306b\u5909\u63db\n- \u5fc5\u8981\u306a\u8981\u7d20\u6bce\u306b\u5206\u5272\u3057\u3066\u914d\u5217\u306b\u5165\u529b\u3057\u3066\u3044\u307e\u3059\n- \u6587\u5b57\u5217\u64cd\u4f5c\u306e\u95a2\u6570\u304c\u3042\u307e\u308a\u51fa\u63c3\u3063\u3066\u3044\u306a\u3044\u6a21\u69d8\u3067\uff0c\u7d30\u304b\u3044\u51e6\u7406\u304c\u3084\u308a\u3065\u3089\u3044\u3067\u3059\n- Lisp \u3067\u306f quote \u8a18\u53f7\u304c\u7279\u5225\u306a\u610f\u5473\u3092\u6301\u3064\u306e\u3067\uff0c\u5909\u63db\u51e6\u7406\u3082\u52a0\u3048\u3066\u3044\u307e\u3059\n\n```Swift\n// \u89e3\u6790\u7d50\u679c\u306e\u30c8\u30fc\u30af\u30f3\u30ea\u30b9\u30c8\u3092\u5165\u308c\u308b\u914d\u5217\nvar tokenlist: [String] = [];\n\n// \u3069\u3053\u307e\u3067\u8aad\u307f\u8fbc\u3093\u3060\u304b\u3092\u8868\u3059\u914d\u5217\nvar tokenIndex = 0;\n\nfunc tokenize(str: String) { //-> ([String], Int) {\n    // ' (quote\u8a18\u53f7\u3092 (quote  ... ) \u306b\u7f6e\u304d\u63db\u3048\n    \n    var str2 = \"\"\n    var quoteFlag = false\n    for a in str {\n        if a == \"'\" {\n            str2 += \"(quote \"\n            quoteFlag = true\n        } else if a == \")\" && quoteFlag {\n            str2 += \"))\"\n            quoteFlag = false;\n        } else {\n            str2 += a\n        }\n    }\n\n    // \"(\" \u3068 \")\" \u3092\u7a7a\u767d\u4ed8\u304d\u306b\u5909\u63db\n    let replacedStr = str2\n        .stringByReplacingOccurrencesOfString(\"(\", withString: \" ( \", options: nil, range: nil)\n        .stringByReplacingOccurrencesOfString(\")\", withString: \" ) \", options: nil, range: nil)\n        .stringByReplacingOccurrencesOfString(\"\\n\", withString: \" \", options: nil, range: nil);\n\n    tokenlist = replacedStr.componentsSeparatedByString(\" \");\n    tokenIndex = 0;\n}\n```\n\n## 3. \u30d1\u30fc\u30b9\u3057\u305f\u5185\u5bb9\u3092 Lisp \u306e\u30aa\u30d6\u30b8\u30a7\u30af\u30c8\u306b\u5909\u63db\n- \u3053\u3053\u307e\u3067\u3067\uff0c\u30d1\u30fc\u30b9\u3057\u305f Lisp \u306e\u30d7\u30ed\u30b0\u30e9\u30e0\u304c\u914d\u5217\u306b\u683c\u7d0d\u3055\u308c\u3066\u3044\u308b\u305f\u3081\uff0cLispObj \u306b\u5909\u63db\u3059\u308b\n- \u30ea\u30b9\u30c8\u3067\u306f\u306a\u3044\u5834\u5408\u306f\uff0cInt\u306b\u30ad\u30e3\u30b9\u30c8\u53ef\u80fd\u304b\u3084\uff0c\u30bb\u30df\u30b3\u30ed\u30f3\u3067\u56f2\u308f\u308c\u3066\u3044\u308b\u304b\u7b49\u3092\u78ba\u8a8d\u3057\u3066\u5bfe\u5fdc\u3059\u308b\u578b\u306b\u5909\u63db\n- \u30ea\u30b9\u30c8\u306e\u8868\u73fe\u306e\u5834\u5408\u306f\u30ea\u30b9\u30c8\u578b\u306e\u30aa\u30d6\u30b8\u30a7\u30af\u30c8\u3092\u4f5c\u6210\u3059\u308b\n\n```Swift\nfunc parse() -> LispObj {\n    var c: LispObj;\n    c = read_next(get_token());\n    return c;\n}\nfunc read_next(var token: String) -> LispObj {\n    var carexp: LispObj, cdrexp: LispObj;\n    var list: LispObj = NIL;\n    \n    if token == \"\" {\n        return NIL;\n    }\n    if (token != \"(\") {  // \"(\" \u3058\u3083\u306a\u3044\u3068\u304d\u306e\u51e6\u7406\n        if let n = token.toInt() {\n            return LispNum(value: n);\n        } else {\n            let prefix = token.hasPrefix(\"\\\"\");\n            let suffix = token.hasSuffix(\"\\\"\");\n            let length = token.utf16Count;\n            \n            if prefix && suffix {  // \"hogehoge\" \u306e\u3088\u3046\u306b\u30bb\u30df\u30b3\u30ed\u30f3\u3067\u56f2\u308f\u308c\u3066\u3044\u308b\u5834\u5408\n                if length > 2 {\n                    return LispStr(value: token[1...token.utf16Count-2]);\n                } else {\n                    return LispStr(value: \"\");\n                }\n            } else if prefix || suffix {  // \"hogehoge \u306e\u3088\u3046\u306b\u7247\u65b9\u3060\u3051\u30bb\u30df\u30b3\u30ed\u30f3\u304c\u4ed8\u3044\u3066\u3044\u308b\u5834\u5408\n                return Error(message: \"wrong String:\" + token);\n            } else {\n                return Symbol(name: token);\n            }\n        }\n    }\n    \n    token = get_token();  // ( \u306e\u6b21\u306e\u30c8\u30fc\u30af\u30f3\u3092\u53d6\u5f97\n    while (true) {  // \"(\" \u304b\u3089\u59cb\u307e\u308b\u3068\u304d\n        if (token == \")\") {\n            return list;\n        }\n        \n        carexp = read_next(token);  // \u8aad\u307f\u8fbc\u3093\u3060\u30c8\u30fc\u30af\u30f3\u3092car\u90e8\u5206\u3068\u3057\u3066\u51e6\u7406\n        token = get_token();     // \u6b21\u306e\u30c8\u30fc\u30af\u30f3\u53d6\u5f97\n        if (token == \".\") {       // \u30da\u30a2\u306e\u5834\u5408\n            token = get_token();\n            cdrexp = read_next(token);  // \u53d6\u5f97\u3057\u305f\u6b21\u306e\u30c8\u30fc\u30af\u30f3\u3092 cdr \u306b\u30bb\u30c3\u30c8\n            token = get_token();   // \u30da\u30a2\u306e\u5f8c\u306f ) \u304c\u304f\u308b\u306f\u305a\n            if token != \")\" {\n                println(\") required!\");\n            }\n            return ConsCell(car: carexp, cdr: cdrexp);\n        }\n        list = concat(list, cons(carexp, NIL));\n    }\n}\n```\n\n## 4. Lisp \u306e\u30aa\u30d6\u30b8\u30a7\u30af\u30c8\u306b\u5bfe\u3057\u3066 eval \u3092\u547c\u3073\u51fa\u3057\u3066\u8a55\u4fa1\n- 3\u307e\u3067\u3067\u4f5c\u6210\u3057\u305f LispObj \u3092\u4e0e\u3048\u3089\u308c\u305f\u74b0\u5883\u306e\u5143\u3067\u8a55\u4fa1\u3059\u308b\n- \u6614\u4f5c\u3063\u305f[Lisp in Arc](https://gist.github.com/torub/a0f8aca789a44f6a5f92)\u3092\u53c2\u8003\u306b\u5b9f\u88c5\n- \u74b0\u5883\u306f Dictonary \u578b\u3092\u4f7f\u3044\uff0c\u540d\u524d\u3068\u5024\u3092\u7d10\u4ed8\u3051\u3059\u308b\n- \u30af\u30ed\u30fc\u30b8\u30e3\u3092\u4f7f\u3046\u5834\u5408\u306f\uff0cDictonary \u3092\u30b0\u30ed\u30fc\u30d0\u30eb\u306e\u3082\u306e\u3068\u30af\u30ed\u30fc\u30b8\u30e3\u5185\u306e\u3082\u306e\u306b\u5206\u3051\u3066\u6271\u3046\n\n```Swift\nfunc eval(exp: LispObj, env: Environment) -> LispObj {\n    if exp is Error {\n        return exp;\n    }\n    if exp is Nil || exp is LispNum {  // Nil\u307e\u305f\u306f\u6570\u5024\u306e\u5834\u5408\u306f\u305d\u306e\u307e\u307e\u8fd4\u3059\n        return exp;\n    }\n    if exp is LispStr { // \u307e\u305f\u306f\u6587\u5b57\u5217\u306e\u5834\u5408\u3082\u305d\u306e\u307e\u307e\u8fd4\u3059(\u30a8\u30c7\u30a3\u30bf\u304c\u30a8\u30e9\u30fc\u306b\u306a\u308b\u305f\u3081\u3001 || \u306e\u9023\u7d50\u306f\u7981\u6b62\n        return exp;\n    }\n    if let symbol = exp as? Symbol {  // \u30b7\u30f3\u30dc\u30eb\u306a\u3089\u3070\u74b0\u5883\u306e\u5024\u3092\u691c\u7d22\u3057\u3066\u8fd4\u3059\n        var value = get(symbol.name, env);\n        if !(value is Nil) {\n            return value;\n        } else {\n            return Error(message: \"Undefined Value: \" + symbol.name);\n        }\n    }\n    \n    if let consexp = exp.listp() {\n        return apply(consexp.car, consexp.cdr, env);\n    }\n    \n    return Error(message: \"something wrong!\");\n}\n\nfunc apply(operator_var: LispObj, operand: LispObj, env: Environment) -> LispObj {\n    let operator_body = eval(operator_var, env);\n    \n    let tmp = operand;\n    if eq(car(operator_body), PRIMITIVE) {  // \u30d7\u30ea\u30df\u30c6\u30a3\u30d6\u95a2\u6570\u306e\u5834\u5408\u306e\u51e6\u7406\n        switch cdr(operator_body).toStr() {\n        case \"car\":\n            return car(eval(car(operand), env));\n        case \"cdr\":\n            return cdr(eval(car(operand), env));\n        case \"=\":\n            // (= x 10)\n            // (= y \"test\")\n            // (= z (+ 1 2))\n            if let variable = car(operand) as? Symbol {  // -> x, y\n                let body = cadr(operand);   // 10, \"test\"\n                let value = eval(body, env);\n                def_var(variable, value, env);\n                \n                return variable;\n            } else {\n                return Error(message: \"Wrong type argument: \" + car(operand).toStr());\n            }\n        case \"list\":\n            return eval_args(operand, env);\n        case \"quote\":\n            if cdr(operand) is Nil {\n                return car(operand);\n            } else {\n                return Error(message: \"Wrong number of arguments: \" + operand.toStr());\n            }\n        case \"lambda\":\n            // lambda\u5f0f\u306e\u5b9a\u7fa9\n            // (lambda (x) (+ x 1))\n            // operand: ((x) (+ x  1))\n            let params = car(operand)   // (x)\n            let body = cadr(operand)    // (+ x 1)\n\n            let tmp = cons(LispStr(value: LAMBDA), cons(params, cons(body, cons(env.copy(), NIL))));\n            return tmp\n            \n        default:\n            return Error(message: \"unknown primitive procedure: \" + cdr(operator_body).toStr());\n        }\n    }\n    \n    if eq(car(operator_body), LAMBDA) {\n        // lambda\u5f0f\u306e\u5b9f\u884c\n        // oparator_body : (\"*** lambda ***\" (x) (list x x x) [env])\n        let lambda_params = cadr(operator_body);    // (x)\n        let lambda_body = car(cddr(operator_body)); // (list x x x)\n        if let lambda_env = cadr(cddr(operator_body)) as? Environment { // [env]\n            let operand_check = eval_args(operand, env);\n            if (operand_check is Error) {\n                return operand_check;\n            }\n            \n            if let ex_env = lambda_env.extend(lambda_params, operand: operand_check) {\n                return eval(lambda_body, ex_env);\n            } else {\n                return Error(message: \"eval lambda params error: \" + lambda_params.toStr() + \" \" + operand.toStr())\n            }\n        }\n    }\n    \n    return Error(message: \"not a function: \" + operator_body.toStr());\n}\n```\n\n### \u307e\u3068\u3081\nSwift \u306f Java \u3068 JavaScript \u3068 Ruby \u304c\u307e\u3056\u3063\u305f\u3088\u3046\u306a\u611f\u3058\u3067\uff0c\u306a\u304b\u306a\u304b\u4f7f\u3044\u6613\u3044\u8a00\u8a9e\u306a\u6c17\u3082\u3057\u307e\u3059\uff0e\u304c\uff0c\u6587\u5b57\u5217\u306e\u64cd\u4f5c\u306e\u95a2\u6570\u304c\u5c11\u306a\u304b\u3063\u305f\u308a\uff0c\u03b2\u7248\u306a\u306e\u3067\u3059\u3050\u4ed5\u69d8\u304c\u5909\u308f\u3063\u305f\u308a\uff0cXcode \u304c\u3059\u3050\u843d\u3061\u305f\u308a\u3068\u307e\u3060\u307e\u3060\u306a\u90e8\u5206\u3082\u3042\u308a\u305d\u3046\u3067\u3059\uff0e\u4eca\u5f8c\u3069\u3046\u306a\u308b\u306e\u304b\u697d\u3057\u307f\u3067\u3059\uff0e\n\nObjective-C \u3068\u4e92\u63db\u3092\u4fdd\u3061\u7d9a\u3051\u308b\u3068\u306a\u308b\u3068\uff0c\u7d50\u5c40iPhone\u30a2\u30d7\u30ea\u4f5c\u308b\u3068\u304d\u306f\u3042\u306e\u9577\u3044\u95a2\u6570\u540d\u3068\u4ed8\u304d\u5408\u3044\u7d9a\u3051\u308b\u5fc5\u8981\u304c\u3042\u308b\u3093\u3067\u3057\u3087\u3046\u304b\u306d\uff0e\uff0e\uff0e\n\n\n### \u53c2\u8003\n- [Apple\u306eDeveloper\u30b5\u30a4\u30c8](https://developer.apple.com/swift/)\n- [The Swift Programming Language](https://itunes.apple.com/us/book/the-swift-programming-language/id881256329?mt=11&ls=1)\n- [Arc \u306e\u30c1\u30e5\u30fc\u30c8\u30ea\u30a2\u30eb](http://old.ycombinator.com/arc/tut.txt)\n- [\u3061\u3087\u3063\u3068\u5909\u308f\u3063\u305fLisp\u5165\u9580](http://www.atmarkit.co.jp/ait/articles/0810/31/news148.html)\n- [Lisp in Arc](https://gist.github.com/torub/a0f8aca789a44f6a5f92)\n", "tags": ["Swift", "lisp", "Xcode", "Xcode6"]}