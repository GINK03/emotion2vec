{"context": "\n\n\u30b7\u30ca\u30ea\u30aa\n\n  Slack \u2192 API Gateway \u2192 Lambda\n\nSlack \u5074\u3067\u306f Custom Integrations \u306e Slash Commands \u3092\u4f7f\u7528\u3057\u307e\u3059\u3002\nAWS \u5074\u306f blueprint \u306b\u3042\u308b slack-echo-command-python \u3092\u4f7f\u3063\u3066\u30b3\u30de\u30f3\u30c9\u3092\u5b9f\u884c\u3059\u308b Lambda \u95a2\u6570\u3092\u4f5c\u6210\u3057\u307e\u3059\u3002\nLambda \u95a2\u6570\u306e\u51e6\u7406\u3067\u306f 3 \u79d2\u4ee5\u5185\u306bSlack \u5074\u3078\u5fdc\u7b54\u3092\u8fd4\u3059\u5fc5\u8981\u304c\u3042\u308a\u307e\u3059\u3002\n\u6642\u9593\u304c\u304b\u304b\u308b\u51e6\u7406\u3092\u884c\u3046\u305f\u3081\u306b\u3001Lambda \u3067\u53d7\u4fe1\u3057\u305f\u30b3\u30de\u30f3\u30c9\u306f\u3001SNS \u3092\u7d4c\u7531\u3057\u3066\u5225\u306e Lambda \u95a2\u6570\u3092\u30a4\u30d9\u30f3\u30c8\u8d77\u52d5\u3057\u307e\u3059\u3002\n\n  Lambda \u2192 SNS \u2192 Lambda \u2192 Slack\n\nSNS \u30a4\u30d9\u30f3\u30c8\u304b\u3089\u8d77\u52d5\u3055\u308c\u308b Lambda \u95a2\u6570\u3067\u306f STS \u3092\u5229\u7528\u3057\u3066\u3001Slash Command \u3092\u767a\u884c\u3057\u305f\u30e6\u30fc\u30b6\u306e\u30ed\u30fc\u30eb\u3092\u5f15\u304d\u53d7\u3051\u3066API \u30b3\u30de\u30f3\u30c9\u3092\u5b9f\u884c\u3057\u307e\u3059\u3002\n\n\n  \u5229\u7528\u3057\u305fblueprint\n\n\n  slack-echo-command-python\nSlack \u5074\u306f Custom Integrations \u306e Slash Commands \u3092\u4f7f\u7528\u3057\u307e\u3059\u3002\n  cloudwatch-alarm-to-slack-python\nIncoming Webhooks \u3067\u306a\u304f response_url \u3092\u4f7f\u3063\u3066\u5fdc\u7b54\u3092\u8fd4\u3059\u3088\u3046\u306b\u4fee\u6b63\u3057\u307e\u3057\u305f\u3002\n\n\n\n\nSlack \u2192 API Gateway \u2192 Lambda\n\nLambda \u95a2\u6570\u306e\u4f5c\u6210\nblueprint \u3068\u3057\u3066 slack-echo-command-python \u3092\u9078\u629e\u3057\u3066\u3001Lambda \u95a2\u6570\u306e\u767b\u9332\u3092\u884c\u3044\u307e\u3059\u3002\n\n\n\u30ed\u30fc\u30eb\u3092\u4f5c\u6210\u3057\u307e\u3059\u3002\u5185\u5bb9\u306f\u3072\u3068\u307e\u305a\u30c7\u30d5\u30a9\u30eb\u30c8\u306e\u307e\u307e\u3067\u304b\u307e\u3044\u307e\u305b\u3093\u3002\n\n\n\n\u30a8\u30f3\u30c9\u30dd\u30a4\u30f3\u30c8\u8a2d\u5b9a\u3067\u306f Method \u3092 POST \u306b\u3001\u30bb\u30ad\u30e5\u30ea\u30c6\u30a3\u8a2d\u5b9a\u306f Open \u3067\u4f5c\u6210\u3057\u307e\u3059\u3002\n\n\u6700\u521d\u306f\u95a2\u6570\u306e\u672c\u4f53\u306fbuleprint \u306e\u307e\u307e\u3067\u304b\u307e\u3044\u307e\u305b\u3093\u3002\n\nSlash Command App \u306e\u767b\u9332\nblueprint \u306e\u5148\u982d\u306b\u30b3\u30e1\u30f3\u30c8\u3067\u8a2d\u5b9a\u624b\u9806\u304c\u66f8\u304b\u308c\u3066\u3044\u307e\u3059\u306e\u3067\u3001\u3053\u308c\u306b\u305d\u3063\u3066\u9032\u3081\u307e\u3059\u3002\nThis function handles a Slack slash command and echoes the details back to the user.\nFollow these steps to configure the slash command in Slack: \u00a0\n\nNavigate to https://.slack.com/services/new\n\nSearch for and select \"Slash Commands\".\n\n\n\nEnter a name for your command and click \"Add Slash Command Integration\".\n\n\n\nCopy the token string from the integration settings and use it in the next section.\ntoken\u306e\u6587\u5b57\u5217\u306f\u3053\u306e\u3042\u3068\u306e\u8a2d\u5b9a\u3067\u4f7f\u3044\u307e\u3059\u306e\u3067\u63a7\u3048\u3066\u304a\u3044\u3066\u304f\u3060\u3055\u3044\u3002\n\n\n\nAfter you complete this blueprint, enter the provided API endpoint URL in the URL field.\n\n\n\n\n\nKMS\u306e\u8a2d\u5b9a\nFollow these steps to encrypt your Slack token for use in this function:\n\n\nCreate a KMS key - http://docs.aws.amazon.com/kms/latest/developerguide/create-keys.html.\nIAM\u306e\u30de\u30cd\u30b8\u30e1\u30f3\u30c8\u30b3\u30f3\u30bd\u30fc\u30eb\u304b\u3089\u6697\u53f7\u5316\u30ad\u30fc\u306e\u8a2d\u5b9a\u3092\u884c\u3044\u307e\u3059\u3002\n\n\n\n\n\nEncrypt the token using the AWS CLI.\n$ aws kms encrypt --key-id alias/ --plaintext \"\"\n$ aws kms encrypt --key-id alias/slack-token --plaintext=\"XXXXXXXXXXXXXXXXXXXXXXXX\"\n\n{\u00a0 \u00a0 \"KeyId\": \"arn:aws:kms:ap-northeast-1:XXXXXXXXXXXX:key/xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx\",\n\u00a0\u00a0 \u00a0 \"CiphertextBlob\": \"BASE64-encoded-string\"}\n\n\n\nCopy the base-64 encoded, encrypted key (CiphertextBlob) to the kmsEncyptedToken variable.\n\u51fa\u529b\u3055\u308c\u305f CiphertextBlob \u306e\u5024\u3092 Lambda \u95a2\u6570\u306e ENCRYPTED_EXPECTED_TOKEN \u5909\u6570\u306e\u5024\u3068\u3057\u3066\u8a2d\u5b9a\u3057\u307e\u3059\u3002\nENCRYPTED_EXPECTED_TOKEN = \"BASE64-encoded-string\" # Enter the base-64 encoded, encrypted Slack command token (CiphertextBlob)\n\n\n\nGive your function's role permission for the kms:Decrypt action.\nExample:\n   {\n     \"Version\": \"2012-10-17\",\n     \"Statement\": [\n       {\n         \"Effect\": \"Allow\",\n         \"Action\": [\n           \"kms:Decrypt\"\n         ],\n         \"Resource\": [\n           \"<your KMS key ARN>\"\n         ]\n       }\n     ]\n   }\n\n\u3053\u306e\u4f8b\u3092\u53c2\u8003\u306b\u5148\u307b\u3069\u4f5c\u6210\u3057\u305f\u30dd\u30ea\u30b7\u30fc\u3092\u4fee\u6b63\u3057\u307e\u3059\u3002\nlambda_basic_execution\n{\n    \"Version\": \"2012-10-17\",\n    \"Statement\": [\n        {\n            \"Effect\": \"Allow\",\n            \"Action\": [\n                \"logs:CreateLogGroup\",\n                \"logs:CreateLogStream\",\n                \"logs:PutLogEvents\"\n            ],\n            \"Resource\": \"arn:aws:logs:*:*:*\"\n        },\n        {\n            \"Effect\": \"Allow\",\n            \"Action\": [\n                \"kms:Decrypt\"\n            ],\n            \"Resource\": [\n                \"arn:aws:kms:us-east-1:XXXXXXXXXXXX:key/xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx\"\n            ]\n        }\n    ]\n}\n\n\n\n\n\u30a8\u30f3\u30c9\u30dd\u30a4\u30f3\u30c8\u306e\u8a2d\u5b9a\nFollow these steps to complete the configuration of your command API endpoint\n\n\nWhen completing the blueprint configuration select \"POST\" for method and\n\"Open\" for security on the Endpoint Configuration page.\n\u3059\u3067\u306b\u3001\u3053\u306e\u5185\u5bb9\u3067\u4f5c\u6210\u3057\u3066\u3044\u308b\u306f\u305a\u3067\u3059\u3002\u8a2d\u5b9a\u304c\u5408\u3063\u3066\u3044\u306a\u3044\u3068\u304d\u306f\u5909\u66f4\u3057\u3066\u304f\u3060\u3055\u3044\u3002\n\nAfter completing the function creation, open the newly created API in the\nAPI Gateway console.\n\nAdd a mapping template for the application/x-www-form-urlencoded content type with the following body: { \"body\": $input.json(\"$\") }\nAPI Gateway \u306e Resource \u3067\u3001Integration Request \u306e Body Mapping Templates \u3092\u8ffd\u52a0\u3057\u307e\u3059\u3002\n\n\n\n\nDeploy the API to the prod stage.\n\u4fee\u6b63\u5f8c\u3001Deply API \u3067\u53cd\u6620\u3057\u3066\u304a\u304d\u307e\u3059\u3002\n\n\nUpdate the URL for your Slack slash command with the invocation URL for the created API resource in the prod stage. \u00a0\n\u30a8\u30f3\u30c9\u30dd\u30a4\u30f3\u30c8\u306e\u8a2d\u5b9a\u304c\u3067\u304d\u307e\u3057\u305f\u306e\u3067\u3001Slack \u5074\u306e Slash Commands \u306e Integration Settings \u3067\u30a8\u30f3\u30c9\u30dd\u30a4\u30f3\u30c8\u306eURL\u3092\u8a2d\u5b9a\u3057\u3066\u304a\u304d\u307e\u3059\u3002\n\n\n\n\n\u6700\u521d\u306e\u30b3\u30fc\u30c9\n\u3053\u306e\u6642\u70b9\u3067\u3001Lambda \u95a2\u6570\u306f ENCRYPTED_EXPECTED_TOKEN \u306e\u5024\u3092\u8a2d\u5b9a\u3057\u305f\u3060\u3051\u3067\u3001blueprint \u306e\u307e\u307e\u306b\u306a\u3063\u3066\u3044\u308b\u306f\u305a\u3067\u3059\u3002\nlambda-bot\u30b3\u30fc\u30c9\nimport boto3\nfrom base64 import b64decode\nfrom urlparse import parse_qs\nimport logging\n\nENCRYPTED_EXPECTED_TOKEN = \"<KMS\u51fa\u529b\u306eCiphertextBlob\u306eRVALUE\u3067\u3042\u308bBASE64\u6587\u5b57\u5217\">\" # Enter the base-64 encoded, encrypted Slack command token (CiphertextBlob)\n\nkms = boto3.client('kms')\nexpected_token = kms.decrypt(CiphertextBlob = b64decode(ENCRYPTED_EXPECTED_TOKEN))['Plaintext']\n\nlogger = logging.getLogger()\nlogger.setLevel(logging.INFO)\n\ndef lambda_handler(event, context):\n    req_body = event['body']\n    params = parse_qs(req_body)\n    token = params['token'][0]\n    if token != expected_token:\n        logger.error(\"Request token (%s) does not match exptected\", token)\n        raise Exception(\"Invalid request token\")\n\n    user = params['user_name'][0]\n    command = params['command'][0]\n    channel = params['channel_name'][0]\n    command_text = params['text'][0]\n\n    return \"%s invoked %s in %s with the following text: %s\" % (user, command, channel, command_text)\n\n\n\u30c6\u30b9\u30c8\n\u30de\u30cd\u30b8\u30e1\u30f3\u30c8\u30b3\u30f3\u30bd\u30fc\u30eb\u304b\u3089\u30c6\u30b9\u30c8\u3059\u308b\u3068\u304d\u306e\u30c6\u30b9\u30c8\u30a4\u30d9\u30f3\u30c8\u306f\u6b21\u306e\u3088\u3046\u306b\u306a\u308a\u307e\u3059\u3002\ntoken\u306e\u5024\u306f Slash Commands \u306e\u8a2d\u5b9a\u3067\u63a7\u3048\u305f\u5024\u3092\u6307\u5b9a\u3057\u3066\u304f\u3060\u3055\u3044\u3002\n{\n\"body\":\n\"token=XXXXXXXXXXXXXXXXXXXXXXXX&command=/lambda&text=ec2&user_name=Steve&channel_name=test&response_url=https://hooks.slack.com/commands/1234/5678\"\n}\n\n\u3053\u3053\u307e\u3067\u30a8\u30e9\u30fc\u306a\u304f\u52d5\u304f\u3088\u3046\u306b\u306a\u3063\u305f\u3089\u3001Slack \u304b\u3089\u30c6\u30b9\u30c8\u3057\u3066\u307f\u307e\u3059\u3002\n\n1\u56de\u76ee\u306f\u30bf\u30a4\u30e0\u30a2\u30a6\u30c8\u3067\u30a8\u30e9\u30fc\u306b\u306a\u308b\u304b\u3082\u3057\u308c\u307e\u305b\u3093\u3002\u305d\u306e\u3068\u304d\u306f\u3082\u3046\u4e00\u5ea6\u30b3\u30de\u30f3\u30c9\u3092\u767a\u884c\u3057\u3066\u307f\u3066\u304f\u3060\u3055\u3044\u3002\n\u5fdc\u7b54\u304c\u8fd4\u3063\u3066\u304f\u308c\u3070\u6210\u529f\u3067\u3059\u3002\n\nblueprint \u306e\u30b5\u30f3\u30d7\u30eb\u3067\u306f return \u306e\u5f15\u6570\u306f\u6587\u5b57\u5217\u3068\u306a\u3063\u3066\u3044\u307e\u3059\u304c\u3001\u3053\u308c\u3067\u306f\u5fdc\u7b54\u306e\u524d\u5f8c\u306b\u4e8c\u91cd\u5f15\u7528\u7b26\u304c\u3064\u3044\u3066\u8868\u793a\u3055\u308c\u307e\u3059\u3002Slash Commands \u306e\u89e3\u8aac\u306b\u3042\u308b\u3088\u3046\u306b\u3001JSON \u5f62\u5f0f\u3067\u8fd4\u305b\u3070\u4e8c\u91cd\u5f15\u7528\u7b26\u306f\u3064\u304d\u307e\u305b\u3093\u3002\nreturn { \"text\": \"%s invoked %s in %s with the following text: %s\" % (user, command, channel, command_text) }\n\n\u3042\u3068\u306f\u81ea\u7531\u306b\u30b3\u30fc\u30c9\u3092\u8db3\u3057\u3066\u3001\u597d\u307f\u306e\u632f\u308b\u821e\u3044\u3092\u3059\u308b\u30dc\u30c3\u30c8\u3092\u4f5c\u6210\u3057\u307e\u3057\u3087\u3046\u3002\n\nLambda \u2192 SNS \u2192 Lambda \u2192 Slack\nblueprint \u306b\u3042\u308b cloudwatch-alarm-to-slack-python \u3092\u5229\u7528\u3057\u3066 notify-to-lambda \u3092\u4f5c\u6210\u3057\u307e\u3059\u3002\nIncoming Webhooks \u306f\u4f7f\u7528\u3057\u306a\u3044\u305f\u3081\u3001blueprint \u306e\u5148\u982d\u306b\u66f8\u304b\u308c\u3066\u3044\u308b\u624b\u9806\u306f\u5b9f\u884c\u3057\u306a\u304f\u3066\u3082\u304b\u307e\u3044\u307e\u305b\u3093\u3002\nSlash Commands \u306e\u8aac\u660e\u3067 response_url \u3092\u5229\u7528\u3057\u305f\u5fdc\u7b54\u306e\u8fd4\u3057\u304b\u305f\u304c\u8a18\u8f09\u3055\u308c\u3066\u3044\u307e\u3059\u3002\n\u3053\u306e\u5185\u5bb9\u3092\u3082\u3068\u306b Incoming Webhooks \u3067\u306a\u304f response_url \u3092\u4f7f\u3063\u3066\u5fdc\u7b54\u3092\u8fd4\u3059\u3088\u3046\u306b\u4fee\u6b63\u3057\u307e\u3059\u3002\nSlash Commands | Slack\u3088\u308a\u5f15\u7528\n\nDelayed responses and multiple responses\n  If you want to provide additional command response messages, or if you're unable to immediately respond to a command within 3000 milliseconds, use the specific response_url we send with our initial execution of your URL to respond to a command at your leisure. With this approach, you can respond to a user commands up to 5 times within 30 minutes of the user's invocation.\n  Sending HTTP requests to this response_url is easy. Just build a JSON POST body in the same format as used when responding to our command invocation request to your registered URL. It supports all of the same fields (response_type, text, and attachments). Then, send that data as an HTTP POST with a content-type of application/json to the destination specified as the response_url.\n  The only user-facing difference between immediate responses and delayed responses is that \"in channel\" delayed responses will not include the initial command sent by the user. To echo the command back to the channel, you'll still need to provide a response to Slack's original visit to your invocation URL.\n\n\nSNS Topic \u306e\u4f5c\u6210\nSNS \u306e\u53d7\u4fe1\u30a4\u30d9\u30f3\u30c8\u3067 Lamba \u95a2\u6570\u3092\u8d77\u52d5\u3059\u308b\u305f\u3081\u306b\u3001SNS Topic \u3092\u4f5c\u6210\u3057\u3001Subscription \u3092 Protocol lambda \u3067\u4f5c\u6210\u3057\u307e\u3059\u3002\n\n\nLambda\u95a2\u6570\u306e\u4f5c\u6210\n\n\n\n\n\nblueprint\u306e\u30b3\u30fc\u30c9\u306e\u4fee\u6b63\nlambda-bot \u5074\u3067\u306f\u3001\u30d1\u30e9\u30e1\u30fc\u30bf\u3092 JSON \u5f62\u5f0f\u3067 SNS \u30e1\u30c3\u30bb\u30fc\u30b8\u3068\u3057\u3066\u9001\u308a\u307e\u3059\u3002\nPublish - Amazon Simple Notification Service \u3088\u308a\u5f15\u7528 (\u592a\u5b57\u90e8\u5206\u306f\u7b46\u8005\u306b\u3088\u308b\u5f37\u8abf\uff09\n\nMessageStructure\n  Set\u00a0MessageStructure\u00a0to\u00a0json\u00a0if you want to send a different message for each protocol. For example, using one publish action, you can send a short message to your SMS subscribers and a longer message to your email subscribers. If you setMessageStructure\u00a0to\u00a0json, the value of the\u00a0Message\u00a0parameter must:\n  be a syntactically valid JSON object; and\ncontain at least a top-level JSON key of \"default\" with a value that is a string.\n  You can define other top-level keys that define the message you want to send to a specific transport protocol (e.g., \"http\").\n  For information about sending different messages for each protocol using the AWS Management Console, go to\u00a0Create Different Messages for Each Protocol\u00a0in the*Amazon Simple Notification Service Getting Started Guide*.\n  Valid value:\u00a0json\n  Type: String\n  Required: No\n\n\u3053\u306e\u305f\u3081\u306b\u95a2\u6570\u306e\u672c\u4f53\u3092\u6b21\u306e\u3088\u3046\u306b\u5909\u66f4\u3057\u307e\u3059\u3002\nlambda-bot\u30b3\u30fc\u30c9\ndef lambda_handler(event, context):\n    req_body = event['body']\n    params = parse_qs(req_body)\n    token = params['token'][0]\n    if token != expected_token:\n        logger.error(\"Request token (%s) does not match exptected\", token)\n        raise Exception(\"Invalid request token\")\n\n    user = params['user_name'][0]\n    command = params['command'][0]\n    channel = params['channel_name'][0]\n    if params.has_key('text'):\n        command_text = params['text'][0]\n    else:\n        command_text = ''\n    response_url = params['response_url'][0]\n    arg = command_text.split(' ')\n\n    sns = boto3.client('sns')\n    topic_arn = sns.create_topic(Name='sns-lambda')['TopicArn']\n    message={\"user_name\": user, \"command\": command, \"channel\": channel, \"command_text\": command_text, \"response_url\": response_url}\n    message=json.dumps(message)\n    message=json.dumps({'default': message, 'lambda': message})\n    response = sns.publish(\n        TopicArn=topic_arn,\n        Subject='/lambda',\n        MessageStructure='json',\n        Message=message\n    )\n    return { \"text\": \"%s %s\\nroger\" % (command, command_text) }\n\n\u53d7\u4fe1\u5074\u306f blueprint \u306e\u30b3\u30fc\u30c9\u3092\u6b21\u306e\u3088\u3046\u306b\u4fee\u6b63\u3057\u307e\u3059\u3002\nHOOK_URL \u306e\u304b\u308f\u308a\u306b response_url \u3092\u4f7f\u7528\u3057\u3001JSON \u5f62\u5f0f\u3067\u5fdc\u7b54\u3092\u8fd4\u3059\u3088\u3046\u306b\u3057\u3066\u3044\u307e\u3059\u3002\nnotify-to-slack\u30b3\u30fc\u30c9\ndef lambda_handler(event, context):\n    logger.info(\"Event: \" + str(event))\n    message = event['Records'][0]['Sns']['Message']\n    try:\n        message = json.loads(message)\n        user_name = message['user_name']\n        command = message['command']\n        command_text = message['command_text']\n        response_url = message['response_url']\n        arg = command_text.split(' ')\n        # if response_type is not specified, act as the same as ephemeral\n        # ephemeral, response message will be visible only to the user\n        slack_message = {\n            'channel': '@%s' % user_name,\n            #'response_type': 'in_channel',\n            'response_type': 'ephemeral',\n            'isDelayedResponse': 'true',\n            'text': \"response for: %s %s\" % (command, command_text)\n        }\n        logger.info(\"Send message to %s %s\", response_url, slack_message)\n        req = Request(response_url)\n        req.add_header('Content-Type', 'application/json')\n        response = urlopen(req, json.dumps(slack_message))\n        response.read()\n        logger.info(\"Message posted to %s\", slack_message['channel'])\n    except HTTPError as e:\n        logger.error(\"Request failed: %d %s\", e.code, e.reason)\n    except URLError as e:\n        logger.error(\"Server connection failed: %s\", e.reason)\n\n\nLambda\u95a2\u6570\u306e\u30ed\u30fc\u30eb\u306e\u4fee\u6b63\nSNS \u30c8\u30d4\u30c3\u30af\u3078\u306e\u9001\u4fe1\u3092\u8a31\u53ef\u3057\u307e\u3059\u3002\nlambda_basic_execution\n        {\n            \"Effect\": \"Allow\",\n            \"Action\": [\n                \"sns:*\"\n            ],\n            \"Resource\": [\n                \"arn:aws:sns:us-east-1:XXXXXXXXXXXX:sns-lambda\"\n            ]\n        },\n\n\n\u30c6\u30b9\u30c8\n\u30de\u30cd\u30b8\u30e1\u30f3\u30c8\u30b3\u30f3\u30bd\u30fc\u30eb\u304b\u3089\u30c6\u30b9\u30c8\u3059\u308b\u3068\u304d\u306e\u30c6\u30b9\u30c8\u30a4\u30d9\u30f3\u30c8\u306f\u6b21\u306e\u3088\u3046\u306b\u306a\u308a\u307e\u3059\u3002\nresponse_url \u306e\u5024\u306f\u3001Slash Commands \u3067\u9001\u4fe1\u3055\u308c\u3066\u304d\u305f\u3082\u306e\u3092\u30ed\u30b0\u306b\u6b8b\u3059\u306a\u3069\u3057\u3066\u5165\u624b\u3057\u3066\u304f\u3060\u3055\u3044\u3002\n{\n  \"Records\": [\n    {\n      \"Sns\": {\n        \"Message\": \"{\\\"command\\\": \\\"/lambda\\\", \\\"command_text\\\": \\\"ec2 console i-XXXXXXXX\\\", \\\"user_name\\\": \\\"Steve\\\", \\\"channel_name\\\": \\\"test\\\", \\\"response_url\\\": \\\"https://hooks.slack.com/commands/1234/5678\\\"}\"\n      }\n    }\n  ]\n}\n\n\u30c6\u30b9\u30c8\u3067\u554f\u984c\u304c\u306a\u3051\u308c\u3070\u3001Lamba \u95a2\u6570\u3067 Event source \u306bSNS\u30c8\u30d4\u30c3\u30af\u3092\u6307\u5b9a\u3057 State \u3092 Enable \u306b\u3057\u3066\u304a\u304d\u307e\u3059\u3002\nSlack \u304b\u3089\u30c6\u30b9\u30c8\u3057\u3066\u307f\u307e\u3059\u3002\n\n\u3053\u306e\u3088\u3046\u306a\u5fdc\u7b54\u304c\u5f97\u3089\u308c\u308c\u3070\u5927\u4e08\u592b\u3067\u3059\u3002\n\n\n\u3082\u3046\u5c11\u3057\u5b9f\u7528\u7684\u306a\u30b3\u30fc\u30c9\nEC2\u30a4\u30f3\u30b9\u30bf\u30f3\u30b9\u306e\u4e00\u89a7\u3084\u30b3\u30f3\u30bd\u30fc\u30eb\u306e\u51fa\u529b\u306e\u53d6\u5f97\u304c\u3067\u304d\u308b\u3088\u3046\u306b\u3057\u307e\u3059\u3002\n\u307e\u305fS3\u30d0\u30b1\u30c3\u30c8\u306e\u4e00\u89a7\u3082\u53d6\u5f97\u3057\u3066\u307f\u307e\u3059\u3002\nnotify-to-slack \u5074 slack_message = { \u2026 } \u306e\u5f8c\u306b\u3064\u304e\u306e\u30b3\u30fc\u30c9\u3092\u8ffd\u52a0\u3057\u307e\u3059\u3002\n        if arg[0] == 'ec2':\n            if len(arg) == 3:\n                if  arg[1] == 'console':\n                    ec2 = boto3.resource('ec2')\n                    instance = ec2.Instance(arg[2])\n                    response = instance.console_output()\n                    output = '\\n'.join([x.rstrip() for x in response['Output'].split('\\n')[-20:]])\n                    slack_message['text'] = output\n            else:\n                ec2 = boto3.client('ec2')\n                response = ec2.describe_instances()\n                if response.has_key('Reservations') and len(response['Reservations']) >= 1:\n                    status = [(lambda x: (x[u'InstanceId'], ', '.join([t[u'Value'] for t in x[u'Tags']]), x[u'State'][u'Name']))(i) for i in response[u'Reservations'][0][u'Instances']]\n                    slack_message['text'] = '%s %s\\n%s' % (command, command_text, '\\n'.join(['%s: (%s) %s' % x for x in status]))\n                else:\n                    slack_message['text'] = \"%s %s\\nno instance found\" % (command, command_text)\n        elif arg[0] == 's3':\n            s3 = boto3.client('s3')\n            buckets = s3.list_buckets()\n            slack_message['text'] = \"%s %s\\n%s\" % (command, command_text, ' '.join([x[u'Name'] for x in buckets[u'Buckets']]))\n\nLambda\u95a2\u6570\u306e\u30ed\u30fc\u30eb\u306e\u4fee\u6b63\nEC2 \u30a4\u30f3\u30b9\u30bf\u30f3\u30b9\u3001S3 \u30d0\u30b1\u30c3\u30c8\u306e\u60c5\u5831\u3092\u53c2\u7167\u3067\u304d\u308b\u3088\u3046\u306b\u3057\u307e\u3059\u3002\nlambda_basic_execution\n        {\n            \"Effect\": \"Allow\",\n            \"Action\": [\n                \"ec2:Describe*\",\n                \"ec2:Get*\"\n            ],\n            \"Resource\": [\n                \"*\"\n            ]\n        },\n        {\n            \"Effect\": \"Allow\",\n            \"Action\": [\n                \"s3:Get*\",\n                \"s3:List*\"\n            ],\n            \"Resource\": [\n                \"*\"\n            ]\n        },\n        {\n            \"Effect\": \"Allow\",\n            \"Action\": [\n                \"cloudwatch:Get*\"\n            ],\n            \"Resource\": [\n                \"*\"\n            ]\n        },\n\n\n\n\n\n\n\n\nSTS\u306e\u5229\u7528\n\u30dc\u30c3\u30c8\u3092\u547c\u3073\u51fa\u3059\u30e6\u30fc\u30b6\u306b\u5fdc\u3058\u3066\u3001\u30b3\u30de\u30f3\u30c9\u3092\u5b9f\u884c\u3067\u304d\u308b\u6a29\u9650\u3092\u5909\u3048\u308b\u3053\u3068\u3092\u8003\u3048\u307e\u3059\u3002\n\u30af\u30ed\u30b9\u30a2\u30ab\u30a6\u30f3\u30c8\u30a2\u30af\u30bb\u30b9\u306e\u30ed\u30fc\u30eb virginia-ec2-delegate \u3092\u4f5c\u6210\u3057\u3066\u3001\u4fe1\u983c\u95a2\u4fc2\u3067 Lambda \u30b5\u30fc\u30d3\u30b9\u3092\u8ffd\u52a0\u3057\u307e\u3057\u305f\u3002\nSTS \u306e\u8a2d\u5b9a\u306b\u3064\u3044\u3066\u306e\u7406\u89e3\u304c\u5341\u5206\u3067\u306a\u3044\u305f\u3081\u3001\u3053\u308c\u3067\u5fc5\u8981\u5341\u5206\u6027\u306a\u306e\u304b\u3088\u304f\u308f\u304b\u308a\u307e\u305b\u3093\u304c\u3001\u52d5\u3044\u3066\u3044\u308b\u306e\u3067\u304a\u305d\u3089\u304f\u5927\u4e08\u592b\u3060\u3068\u601d\u3044\u307e\u3059\u3002\n\u30e6\u30fc\u30b6\u540d\u3092\u305d\u306e\u307e\u307e\u5229\u7528\u3057\u3066\u3044\u308b\u305f\u3081\u3001AWS \u306e IAM \u30e6\u30fc\u30b6\u540d\u3068 Slack \u306e\u30e6\u30fc\u30b6\u540d\u306f\u5408\u308f\u305b\u3066\u304a\u304f\u5fc5\u8981\u304c\u3042\u308a\u307e\u3059\u3002\n\u30ed\u30fc\u30ebvirginia-ec2-delegate\n\n\n      \"Principal\": {\n        \"Service\": \"lambda.amazonaws.com\"\n      },\n\n\u30dd\u30ea\u30b7\u30fcec2-full-access\n\n\u30ed\u30fc\u30ebassume-role\n{\n    \"Version\": \"2012-10-17\",\n    \"Statement\": [\n        {\n            \"Action\": [\n                \"sts:AssumeRole\"\n            ],\n            \"Effect\": \"Allow\",\n            \"Resource\": \"*\"\n        }\n    ]\n}\n\nLambda\u95a2\u6570\u306e\u30ed\u30fc\u30eb\u306e\u4fee\u6b63\nlambda_basic_execution\n\nIAM\u306e\u5fc5\u8981\u306a\u53c2\u7167\u304c\u3067\u304d\u308b\u3088\u3046\u306b\u30ed\u30fc\u30eb\u306e\u30dd\u30ea\u30b7\u30fc\u3092\u4fee\u6b63\u3057\u307e\u3059\u3002\n        {\n            \"Effect\": \"Allow\",\n            \"Action\": [\n                \"iam:GetUser\",\n                \"iam:GetRole\",\n                \"iam:UserPolicy\"\n            ],\n            \"Resource\": [\n                \"*\"\n            ]\n        }\n\nnotify-to-slack\u30b3\u30fc\u30c9\n    iam = boto3.client('iam')\n    response = iam.get_user(UserName=user_name)\n    if response.has_key('User'):\n        uid = response['User']['Arn'].split(':')[4]\n        if uid and boto3.resource('iam').UserPolicy(user_name, 'ec2-full-access'):\n            response = iam.get_role(RoleName='virginia-ec2-delegate')\n            if response.has_key('Role'):\n                sts = boto3.client('sts')\n                assumedRoleObject = sts.assume_role(RoleArn=\"arn:aws:iam::%s:role/%s\" % (uid, 'virginia-ec2-delegate'), RoleSessionName='session')\n                credentials = assumedRoleObject['Credentials']\n                ec2 = boto3.resource(\n                    'ec2',\n                    aws_access_key_id=credentials['AccessKeyId'],                                    aws_secret_access_key=credentials['SecretAccessKey'],\n                    aws_session_token = credentials['SessionToken'],\n                    )\n                instance = ec2.Instance(arg[2])\n                state = 'unknown'\n                if arg[1] == 'start':\n                    response = instance.start()\n                    if response.has_key('StartingInstances'):\n                        state = response['StartingInstances'][0]['CurrentState']['Name']\n                        slack_message['text'] = '%s %s' % (arg[2], state)\n                elif arg[1] == 'stop':\n                    response = instance.stop()\n                    if response.has_key('StoppingInstances'):\n                        state = response['StoppingInstances'][0]['CurrentState']['Name']\n                slack_message['text'] = '%s %s' % (arg[2], state)\n\n\n\u30c6\u30b9\u30c8\nLambda \u95a2\u6570\u306b\u306f EC2 \u30a4\u30f3\u30b9\u30bf\u30f3\u30b9\u306e\u8d77\u52d5/\u505c\u6b62\u3092\u884c\u3046\u6a29\u9650\u306f\u6301\u305f\u305b\u3066\u3044\u307e\u305b\u3093\u304c\u3001STS \u3092\u5229\u7528\u3057\u3066\u30e6\u30fc\u30b6\u6a29\u9650\u3092\u5f15\u304d\u53d7\u3051\u3066\u5b9f\u884c\u3057\u307e\u3059\u3002\n\n\n\n\n\n\u30b5\u30f3\u30d7\u30eb\u30b3\u30fc\u30c9\n\nlambda-bot\nimport boto3\nfrom base64 import b64decode\nfrom urlparse import parse_qs\nfrom datetime import datetime, timedelta\nimport json\nimport logging\n\nENCRYPTED_EXPECTED_TOKEN = \"<KMS\u51fa\u529b\u306eCiphertextBlob\u306eRVALUE\u3067\u3042\u308bBASE64\u6587\u5b57\u5217\">\" # Enter the base-64 encoded, encrypted Slack command token (CiphertextBlob)\n\nkms = boto3.client('kms')\nexpected_token = kms.decrypt(CiphertextBlob = b64decode(ENCRYPTED_EXPECTED_TOKEN))['Plaintext']\n\nlogger = logging.getLogger()\nlogger.setLevel(logging.INFO)\n\ndef lambda_handler(event, context):\n    req_body = event['body']\n    params = parse_qs(req_body)\n    token = params['token'][0]\n    if token != expected_token:\n        logger.error(\"Request token (%s) does not match exptected\", token)\n        raise Exception(\"Invalid request token\")\n\n    user = params['user_name'][0]\n    command = params['command'][0]\n    channel = params['channel_name'][0]\n    if params.has_key('text'):\n        command_text = params['text'][0]\n    else:\n        command_text = ''\n    response_url = params['response_url'][0]\n    arg = command_text.split(' ')\n\n    if arg[0] in ['ec2', 's3']:\n        sns = boto3.client('sns')\n        topic_arn = sns.create_topic(Name='sns-lambda')['TopicArn']\n        message={\"user_name\": user, \"command\": command, \"channel\": channel, \"command_text\": command_text, \"response_url\": response_url}\n        message=json.dumps(message)\n        message=json.dumps({'default': message, 'lambda': message})\n        response = sns.publish(\n            TopicArn=topic_arn,\n            Subject='/lambda',\n            MessageStructure='json',\n            Message=message\n        )\n        return { \"text\": \"%s %s\\nroger\" % (command, command_text) }\n    elif arg[0] == 'help':\n        return { \"text\": \"ec2 [console|start|stop instance-id]\\ns3 [usage bucket]\" }\n    else:\n        return { \"text\": \"%s invoked %s in %s with the following text: %s\" % (user, command, channel, command_text) }\n\n\nnotify-to-slack\nfrom __future__ import print_function\n\nimport boto3\nimport json\nimport logging\n\nfrom base64 import b64decode\nfrom urllib2 import Request, urlopen, URLError, HTTPError\nfrom time import sleep\n\nlogger = logging.getLogger()\nlogger.setLevel(logging.INFO)\n\ndef send_response(response_url, message):\n    req = Request(response_url)\n    req.add_header('Content-Type', 'application/json')\n    try:\n        response = urlopen(req, json.dumps(message))\n        response.read()\n    except HTTPError as e:\n        logger.error(\"Request failed: %d %s\", e.code, e.reason)\n    except URLError as e:\n        logger.error(\"Server connection failed: %s\", e.reason)\n\ndef ec2_command(arg, user_name, response_url):\n    if len(arg) == 3:\n        if  arg[1] == 'console':\n            ec2 = boto3.resource('ec2')\n            instance = ec2.Instance(arg[2])\n            response = instance.console_output()\n            output = '\\n'.join([x.rstrip() for x in response['Output'].split('\\n')[-20:]])\n            return output\n        elif arg[1] in ['start', 'stop']:\n            iam = boto3.client('iam')\n            response = iam.get_user(UserName=user_name)\n            if response.has_key('User'):\n                uid = response['User']['Arn'].split(':')[4]\n                if uid and boto3.resource('iam').UserPolicy(user_name, 'ec2-full-access'):\n                    response = iam.get_role(RoleName='virginia-ec2-delegate')\n                    if response.has_key('Role'):\n                        sts = boto3.client('sts')\n                        assumedRoleObject = sts.assume_role(RoleArn=\"arn:aws:iam::%s:role/%s\" % (uid, 'virginia-ec2-delegate'), RoleSessionName='session')\n                        credentials = assumedRoleObject['Credentials']\n                        ec2 = boto3.resource(\n                                'ec2',\n                                aws_access_key_id=credentials['AccessKeyId'],\n                                aws_secret_access_key=credentials['SecretAccessKey'],\n                                aws_session_token = credentials['SessionToken'],\n                                )\n                        instance = ec2.Instance(arg[2])\n                        state = instance.state['Name']\n                        if arg[1] == 'start':\n                            if state == 'stopped':\n                                response = instance.start()\n                                if response.has_key('StartingInstances'):\n                                    state = response['StartingInstances'][0]['CurrentState']['Name']\n                                    if state == 'pending':\n                                        if response_url:\n                                            send_response(response_url, { 'text': 'start %s' % arg[2] })\n                                        ec2client = boto3.client('ec2')\n                                        for wait in range(0,20):\n                                            response = ec2client.describe_instances(InstanceIds=[arg[2]])\n                                            state = response[u'Reservations'][0][u'Instances'][0]['State']['Name']\n                                            if state == 'running': break\n                                            sleep(3)\n                                return '%s become %s' % (arg[2], state)\n                            else:\n                                return '%s is already %s' % (arg[2], state)\n                        elif arg[1] == 'stop':\n                            if state == 'running':\n                                response = instance.stop()\n                                if response.has_key('StoppingInstances'):\n                                    state = response['StoppingInstances'][0]['CurrentState']['Name']\n                                    if state == 'stopping':\n                                        if response_url:\n                                            send_response(response_url, { 'text': 'stop %s' % arg[2] })\n                                        ec2client = boto3.client('ec2')\n                                        for wait in range(0,20):\n                                            response = ec2client.describe_instances(InstanceIds=[arg[2]])\n                                            state = response[u'Reservations'][0][u'Instances'][0]['State']['Name']\n                                            if state == 'stopped': break\n                                            sleep(3)\n                                    return '%s become %s' % (arg[2], state)\n                            else:\n                                return '%s is already %s' % (arg[2], state)\n                        else:\n                            return '%s: unknown' % arg[2]\n            else:\n                return '%s: user unknown' % user_name\n    else:\n        ec2 = boto3.client('ec2')\n        response = ec2.describe_instances()\n        if response.has_key('Reservations') and len(response['Reservations']) >= 1:\n            status = [(lambda x: (x[u'InstanceId'], ', '.join([t[u'Value'] for t in x[u'Tags']]), x[u'State'][u'Name']))(i) for i in response[u'Reservations'][0][u'Instances']]\n            return '\\n'.join(['%s: (%s) %s' % x for x in status])\n        else:\n            return \"no instance found\"\n\ndef s3_command(arg, user_name, response_url):\n    if len(arg) == 3 and arg[1] == 'usage':\n        cloudwatch = boto3.client('cloudwatch')\n        now = datetime.utcnow()\n        response = cloudwatch.get_metric_statistics(\n                    Namespace='AWS/S3',\n                    MetricName='BucketSizeBytes',\n                    Dimensions=[\n                        { 'Name': 'BucketName', 'Value': arg[2] },\n                        { 'Name': 'StorageType', 'Value': 'StandardStorage' }\n                    ],\n                    StartTime=now - timedelta(days=1),\n                    EndTime=now,\n                    Period=86400,\n                    Statistics=['Average'],\n                    Unit='Bytes'\n                    )\n        if response.has_key('Datapoints') and len(response[u'Datapoints']) >= 1:\n            return response[u'Datapoints'][0][u'Average']\n        else:\n            return \"no metric found\"\n    else:\n        s3 = boto3.client('s3')\n        buckets = s3.list_buckets()\n        return ' '.join([x[u'Name'] for x in buckets[u'Buckets']])\n\ndef lambda_handler(event, context):\n    message = event['Records'][0]['Sns']['Message']\n    logger.info(\"Event: \" + str(message))\n    if True:\n        message = json.loads(message)\n        user_name = message['user_name']\n        command = message['command']\n        command_text = message['command_text']\n        response_url = message['response_url']\n        arg = command_text.split(' ')\n\n        # if response_type is not specified , act as the same as ephemeral\n        # ephemeral, response message will be visible only to the user\n        slack_message = {\n            'channel': '@%s' % user_name,\n            #'response_type': 'in_channel',\n            'response_type': 'ephemeral',\n            'isDelayedResponse': 'true',\n            'text': \"%s %s\" % (command, command_text)\n        }\n\n        if arg[0] == 'ec2':\n            slack_message['text'] = ec2_command(arg, user_name, response_url)\n            send_response(response_url, slack_message)\n        elif arg[0] == 's3':\n            slack_message['text'] = s3_command(arg, user_name, response_url)\n            send_response(response_url, slack_message)\n\n    else:\n        slack_message = { 'text': \"command failed\" }\n        send_response(response_url, slack_message)\n\n\u30b7\u30ca\u30ea\u30aa\n========\n\n-   Slack \u2192 API Gateway \u2192 Lambda\n\nSlack \u5074\u3067\u306f Custom Integrations \u306e Slash Commands \u3092\u4f7f\u7528\u3057\u307e\u3059\u3002\nAWS \u5074\u306f blueprint \u306b\u3042\u308b slack-echo-command-python \u3092\u4f7f\u3063\u3066\u30b3\u30de\u30f3\u30c9\u3092\u5b9f\u884c\u3059\u308b Lambda \u95a2\u6570\u3092\u4f5c\u6210\u3057\u307e\u3059\u3002\nLambda \u95a2\u6570\u306e\u51e6\u7406\u3067\u306f 3 \u79d2\u4ee5\u5185\u306bSlack \u5074\u3078\u5fdc\u7b54\u3092\u8fd4\u3059\u5fc5\u8981\u304c\u3042\u308a\u307e\u3059\u3002\n\u6642\u9593\u304c\u304b\u304b\u308b\u51e6\u7406\u3092\u884c\u3046\u305f\u3081\u306b\u3001Lambda \u3067\u53d7\u4fe1\u3057\u305f\u30b3\u30de\u30f3\u30c9\u306f\u3001SNS \u3092\u7d4c\u7531\u3057\u3066\u5225\u306e Lambda \u95a2\u6570\u3092\u30a4\u30d9\u30f3\u30c8\u8d77\u52d5\u3057\u307e\u3059\u3002\n\n-   Lambda \u2192 SNS \u2192 Lambda \u2192 Slack\n\nSNS \u30a4\u30d9\u30f3\u30c8\u304b\u3089\u8d77\u52d5\u3055\u308c\u308b Lambda \u95a2\u6570\u3067\u306f STS \u3092\u5229\u7528\u3057\u3066\u3001Slash Command \u3092\u767a\u884c\u3057\u305f\u30e6\u30fc\u30b6\u306e\u30ed\u30fc\u30eb\u3092\u5f15\u304d\u53d7\u3051\u3066API \u30b3\u30de\u30f3\u30c9\u3092\u5b9f\u884c\u3057\u307e\u3059\u3002\n\n![lambda-bot.png](https://qiita-image-store.s3.amazonaws.com/0/68901/1ebca89c-8023-8769-8c85-5be97013cba4.png)\n\n\n-   \u5229\u7528\u3057\u305fblueprint\n    -   slack-echo-command-python\n        Slack \u5074\u306f Custom Integrations \u306e Slash Commands \u3092\u4f7f\u7528\u3057\u307e\u3059\u3002\n    -   cloudwatch-alarm-to-slack-python  \n        Incoming Webhooks \u3067\u306a\u304f `response_url` \u3092\u4f7f\u3063\u3066\u5fdc\u7b54\u3092\u8fd4\u3059\u3088\u3046\u306b\u4fee\u6b63\u3057\u307e\u3057\u305f\u3002\n\nSlack \u2192 API Gateway \u2192 Lambda\n============================\n\nLambda \u95a2\u6570\u306e\u4f5c\u6210\n-----------------\n\nblueprint \u3068\u3057\u3066 slack-echo-command-python \u3092\u9078\u629e\u3057\u3066\u3001Lambda \u95a2\u6570\u306e\u767b\u9332\u3092\u884c\u3044\u307e\u3059\u3002\n\n![step1.png](https://qiita-image-store.s3.amazonaws.com/0/68901/f0b955fe-f297-6b54-727c-fa0d26442bbc.png)\n\n![step2.png](https://qiita-image-store.s3.amazonaws.com/0/68901/3d0781b0-92b4-4500-703d-91a7a8a70fdc.png)\n\n\u30ed\u30fc\u30eb\u3092\u4f5c\u6210\u3057\u307e\u3059\u3002\u5185\u5bb9\u306f\u3072\u3068\u307e\u305a\u30c7\u30d5\u30a9\u30eb\u30c8\u306e\u307e\u307e\u3067\u304b\u307e\u3044\u307e\u305b\u3093\u3002\n\n![lambda-role1.png](https://qiita-image-store.s3.amazonaws.com/0/68901/400c4177-ad7e-1ebd-f077-c9e377b454d1.png)\n\n![lambda-role2.png](https://qiita-image-store.s3.amazonaws.com/0/68901/dc64c4f0-dcb5-fd94-1b7a-6bab2a15e042.png)\n\n![lambda-role3.png](https://qiita-image-store.s3.amazonaws.com/0/68901/b36c5142-ba7c-209f-b5fc-0f80a89ae917.png)\n\n\u30a8\u30f3\u30c9\u30dd\u30a4\u30f3\u30c8\u8a2d\u5b9a\u3067\u306f **Method \u3092 POST \u306b**\u3001**\u30bb\u30ad\u30e5\u30ea\u30c6\u30a3\u8a2d\u5b9a\u306f Open** \u3067\u4f5c\u6210\u3057\u307e\u3059\u3002\n\n![step3.png](https://qiita-image-store.s3.amazonaws.com/0/68901/de014c35-57ac-013a-1145-5d7e5fea53b8.png)\n\n\u6700\u521d\u306f\u95a2\u6570\u306e\u672c\u4f53\u306fbuleprint \u306e\u307e\u307e\u3067\u304b\u307e\u3044\u307e\u305b\u3093\u3002\n\nSlash Command App \u306e\u767b\u9332\n------------------------\n\nblueprint \u306e\u5148\u982d\u306b\u30b3\u30e1\u30f3\u30c8\u3067\u8a2d\u5b9a\u624b\u9806\u304c\u66f8\u304b\u308c\u3066\u3044\u307e\u3059\u306e\u3067\u3001\u3053\u308c\u306b\u305d\u3063\u3066\u9032\u3081\u307e\u3059\u3002\n\nThis function handles a Slack slash command and echoes the details back to the user.\n\nFollow these steps to configure the slash command in Slack: \u00a0\n\n1.  Navigate to https://<your-team-domain>.slack.com/services/new\n\n2.  Search for and select \"Slash Commands\".\n\n    ![slash2.png](https://qiita-image-store.s3.amazonaws.com/0/68901/bfcaef39-bf48-1ec5-133b-35d9f6d8d12c.png)\n\n3.  Enter a name for your command and click \"Add Slash Command Integration\".\n\n    ![shash3.png](https://qiita-image-store.s3.amazonaws.com/0/68901/4e06fea7-2505-b33b-5f7e-472c342fd555.png)\n\n4.  Copy the token string from the integration settings and use it in the next section.  \n    token\u306e\u6587\u5b57\u5217\u306f\u3053\u306e\u3042\u3068\u306e\u8a2d\u5b9a\u3067\u4f7f\u3044\u307e\u3059\u306e\u3067\u63a7\u3048\u3066\u304a\u3044\u3066\u304f\u3060\u3055\u3044\u3002\n\n    ![shalsh4.png](https://qiita-image-store.s3.amazonaws.com/0/68901/210bda08-f9c6-1f58-3c41-416e488a54bc.png)\n\n5.  After you complete this blueprint, enter the provided API endpoint URL in the URL field.\n\n    ![slash5-1.png](https://qiita-image-store.s3.amazonaws.com/0/68901/865d4348-57a4-df46-4b3f-56b998de48cf.png)\n\n    ![shash5-2.png](https://qiita-image-store.s3.amazonaws.com/0/68901/b587c09c-a58c-d018-76d2-1bd8f8b65b8a.png)\n\nKMS\u306e\u8a2d\u5b9a\n---------\n\nFollow these steps to encrypt your Slack token for use in this function:\n\n1.  Create a KMS key - http://docs.aws.amazon.com/kms/latest/developerguide/create-keys.html.  \n    IAM\u306e\u30de\u30cd\u30b8\u30e1\u30f3\u30c8\u30b3\u30f3\u30bd\u30fc\u30eb\u304b\u3089\u6697\u53f7\u5316\u30ad\u30fc\u306e\u8a2d\u5b9a\u3092\u884c\u3044\u307e\u3059\u3002\n\n    ![kms1-1.png](https://qiita-image-store.s3.amazonaws.com/0/68901/9e401693-a962-4dc4-4e94-e14ec902856a.png)\n\n    ![kms1-2.png](https://qiita-image-store.s3.amazonaws.com/0/68901/b1a246dc-6c2e-1b22-6a72-0420a117de2c.png)\n\n    ![kms1-3.png](https://qiita-image-store.s3.amazonaws.com/0/68901/c9796d45-2044-9afb-a2fa-c9d654898987.png)\n\n2.  Encrypt the token using the AWS CLI.  \n    $ aws kms encrypt --key-id alias/<KMS key name> --plaintext \"<COMMAND_TOKEN>\"\n\n    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n    $ aws kms encrypt --key-id alias/slack-token --plaintext=\"XXXXXXXXXXXXXXXXXXXXXXXX\"\n    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n    {\u00a0 \u00a0 \"KeyId\": \"arn:aws:kms:ap-northeast-1:XXXXXXXXXXXX:key/xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx\",\n    \u00a0\u00a0 \u00a0 \"CiphertextBlob\": \"BASE64-encoded-string\"}\n    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n3.  Copy the base-64 encoded, encrypted key (CiphertextBlob) to the kmsEncyptedToken variable.\n\n    \u51fa\u529b\u3055\u308c\u305f CiphertextBlob \u306e\u5024\u3092 Lambda \u95a2\u6570\u306e `ENCRYPTED_EXPECTED_TOKEN` \u5909\u6570\u306e\u5024\u3068\u3057\u3066\u8a2d\u5b9a\u3057\u307e\u3059\u3002\n\n    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n    ENCRYPTED_EXPECTED_TOKEN = \"BASE64-encoded-string\" # Enter the base-64 encoded, encrypted Slack command token (CiphertextBlob)\n    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n4.  Give your function's role permission for the kms:Decrypt action.  \n    Example:\n\n    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n       {\n         \"Version\": \"2012-10-17\",\n         \"Statement\": [\n           {\n             \"Effect\": \"Allow\",\n             \"Action\": [\n               \"kms:Decrypt\"\n             ],\n             \"Resource\": [\n               \"<your KMS key ARN>\"\n             ]\n           }\n         ]\n       }\n    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n    \u3053\u306e\u4f8b\u3092\u53c2\u8003\u306b\u5148\u307b\u3069\u4f5c\u6210\u3057\u305f\u30dd\u30ea\u30b7\u30fc\u3092\u4fee\u6b63\u3057\u307e\u3059\u3002\n\n    lambda_basic_execution\n\n    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n    {\n        \"Version\": \"2012-10-17\",\n        \"Statement\": [\n            {\n                \"Effect\": \"Allow\",\n                \"Action\": [\n                    \"logs:CreateLogGroup\",\n                    \"logs:CreateLogStream\",\n                    \"logs:PutLogEvents\"\n                ],\n                \"Resource\": \"arn:aws:logs:*:*:*\"\n            },\n            {\n                \"Effect\": \"Allow\",\n                \"Action\": [\n                    \"kms:Decrypt\"\n                ],\n                \"Resource\": [\n                    \"arn:aws:kms:us-east-1:XXXXXXXXXXXX:key/xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx\"\n                ]\n            }\n        ]\n    }\n    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n\u30a8\u30f3\u30c9\u30dd\u30a4\u30f3\u30c8\u306e\u8a2d\u5b9a\n--------------------\n\nFollow these steps to complete the configuration of your command API endpoint\n\n1.  When completing the blueprint configuration select \"POST\" for method and  \n    \"Open\" for security on the Endpoint Configuration page.\n\n    \u3059\u3067\u306b\u3001\u3053\u306e\u5185\u5bb9\u3067\u4f5c\u6210\u3057\u3066\u3044\u308b\u306f\u305a\u3067\u3059\u3002\u8a2d\u5b9a\u304c\u5408\u3063\u3066\u3044\u306a\u3044\u3068\u304d\u306f\u5909\u66f4\u3057\u3066\u304f\u3060\u3055\u3044\u3002\n\n2.  After completing the function creation, open the newly created API in the  \n    API Gateway console.\n\n3.  Add a mapping template for the application/x-www-form-urlencoded content type with the following body: { \"body\": \\$input.json(\"\\$\") }\n\n    API Gateway \u306e Resource \u3067\u3001Integration Request \u306e Body Mapping Templates \u3092\u8ffd\u52a0\u3057\u307e\u3059\u3002\n\n    ![api-gw-1.png](https://qiita-image-store.s3.amazonaws.com/0/68901/e6b46a3b-1a9d-f786-4d1b-d3fad15a33e8.png)\n\n    ![api-gw-2.png](https://qiita-image-store.s3.amazonaws.com/0/68901/ce132fc0-6258-1561-e75b-937ef9c8c4b8.png)\n\n4.  Deploy the API to the prod stage.\n\n    \u4fee\u6b63\u5f8c\u3001Deply API \u3067\u53cd\u6620\u3057\u3066\u304a\u304d\u307e\u3059\u3002\n\n5.  Update the URL for your Slack slash command with the invocation URL for the created API resource in the prod stage. \u00a0  \n    \u30a8\u30f3\u30c9\u30dd\u30a4\u30f3\u30c8\u306e\u8a2d\u5b9a\u304c\u3067\u304d\u307e\u3057\u305f\u306e\u3067\u3001Slack \u5074\u306e Slash Commands \u306e Integration Settings \u3067\u30a8\u30f3\u30c9\u30dd\u30a4\u30f3\u30c8\u306eURL\u3092\u8a2d\u5b9a\u3057\u3066\u304a\u304d\u307e\u3059\u3002\n\n    ![api-gw-3.png](https://qiita-image-store.s3.amazonaws.com/0/68901/cc771c44-f345-abb4-d774-2e31b3a9f77f.png)\n\n\n\u6700\u521d\u306e\u30b3\u30fc\u30c9\n------------\n\n\u3053\u306e\u6642\u70b9\u3067\u3001Lambda \u95a2\u6570\u306f ENCRYPTED_EXPECTED_TOKEN \u306e\u5024\u3092\u8a2d\u5b9a\u3057\u305f\u3060\u3051\u3067\u3001blueprint \u306e\u307e\u307e\u306b\u306a\u3063\u3066\u3044\u308b\u306f\u305a\u3067\u3059\u3002\n\n**lambda-bot\u30b3\u30fc\u30c9**\n\n~~~\nimport boto3\nfrom base64 import b64decode\nfrom urlparse import parse_qs\nimport logging\n\nENCRYPTED_EXPECTED_TOKEN = \"<KMS\u51fa\u529b\u306eCiphertextBlob\u306eRVALUE\u3067\u3042\u308bBASE64\u6587\u5b57\u5217\">\" # Enter the base-64 encoded, encrypted Slack command token (CiphertextBlob)\n\nkms = boto3.client('kms')\nexpected_token = kms.decrypt(CiphertextBlob = b64decode(ENCRYPTED_EXPECTED_TOKEN))['Plaintext']\n\nlogger = logging.getLogger()\nlogger.setLevel(logging.INFO)\n\ndef lambda_handler(event, context):\n    req_body = event['body']\n    params = parse_qs(req_body)\n    token = params['token'][0]\n    if token != expected_token:\n        logger.error(\"Request token (%s) does not match exptected\", token)\n        raise Exception(\"Invalid request token\")\n\n    user = params['user_name'][0]\n    command = params['command'][0]\n    channel = params['channel_name'][0]\n    command_text = params['text'][0]\n\n    return \"%s invoked %s in %s with the following text: %s\" % (user, command, channel, command_text)\n~~~\n\n\u30c6\u30b9\u30c8\n------\n\n\u30de\u30cd\u30b8\u30e1\u30f3\u30c8\u30b3\u30f3\u30bd\u30fc\u30eb\u304b\u3089\u30c6\u30b9\u30c8\u3059\u308b\u3068\u304d\u306e\u30c6\u30b9\u30c8\u30a4\u30d9\u30f3\u30c8\u306f\u6b21\u306e\u3088\u3046\u306b\u306a\u308a\u307e\u3059\u3002\n\ntoken\u306e\u5024\u306f Slash Commands \u306e\u8a2d\u5b9a\u3067\u63a7\u3048\u305f\u5024\u3092\u6307\u5b9a\u3057\u3066\u304f\u3060\u3055\u3044\u3002\n\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n{\n\"body\":\n\"token=XXXXXXXXXXXXXXXXXXXXXXXX&command=/lambda&text=ec2&user_name=Steve&channel_name=test&response_url=https://hooks.slack.com/commands/1234/5678\"\n}\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n\u3053\u3053\u307e\u3067\u30a8\u30e9\u30fc\u306a\u304f\u52d5\u304f\u3088\u3046\u306b\u306a\u3063\u305f\u3089\u3001Slack \u304b\u3089\u30c6\u30b9\u30c8\u3057\u3066\u307f\u307e\u3059\u3002\n\n![test1.png](https://qiita-image-store.s3.amazonaws.com/0/68901/342d2af1-185b-47f2-11bc-f8d45de81a40.png)\n\n1\u56de\u76ee\u306f\u30bf\u30a4\u30e0\u30a2\u30a6\u30c8\u3067\u30a8\u30e9\u30fc\u306b\u306a\u308b\u304b\u3082\u3057\u308c\u307e\u305b\u3093\u3002\u305d\u306e\u3068\u304d\u306f\u3082\u3046\u4e00\u5ea6\u30b3\u30de\u30f3\u30c9\u3092\u767a\u884c\u3057\u3066\u307f\u3066\u304f\u3060\u3055\u3044\u3002\n\n\u5fdc\u7b54\u304c\u8fd4\u3063\u3066\u304f\u308c\u3070\u6210\u529f\u3067\u3059\u3002\n\n![test2.png](https://qiita-image-store.s3.amazonaws.com/0/68901/c16c47e5-2c87-02a2-ee36-62e07227ec45.png)\n\nblueprint \u306e\u30b5\u30f3\u30d7\u30eb\u3067\u306f return \u306e\u5f15\u6570\u306f\u6587\u5b57\u5217\u3068\u306a\u3063\u3066\u3044\u307e\u3059\u304c\u3001\u3053\u308c\u3067\u306f\u5fdc\u7b54\u306e\u524d\u5f8c\u306b\u4e8c\u91cd\u5f15\u7528\u7b26\u304c\u3064\u3044\u3066\u8868\u793a\u3055\u308c\u307e\u3059\u3002Slash Commands \u306e[\u89e3\u8aac](https://api.slack.com/slash-commands)\u306b\u3042\u308b\u3088\u3046\u306b\u3001JSON \u5f62\u5f0f\u3067\u8fd4\u305b\u3070\u4e8c\u91cd\u5f15\u7528\u7b26\u306f\u3064\u304d\u307e\u305b\u3093\u3002\n\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nreturn { \"text\": \"%s invoked %s in %s with the following text: %s\" % (user, command, channel, command_text) }\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n\u3042\u3068\u306f\u81ea\u7531\u306b\u30b3\u30fc\u30c9\u3092\u8db3\u3057\u3066\u3001\u597d\u307f\u306e\u632f\u308b\u821e\u3044\u3092\u3059\u308b\u30dc\u30c3\u30c8\u3092\u4f5c\u6210\u3057\u307e\u3057\u3087\u3046\u3002\n\nLambda \u2192 SNS \u2192 Lambda \u2192 Slack\n=============================\n\nblueprint \u306b\u3042\u308b cloudwatch-alarm-to-slack-python \u3092\u5229\u7528\u3057\u3066 notify-to-lambda \u3092\u4f5c\u6210\u3057\u307e\u3059\u3002\n\nIncoming Webhooks \u306f\u4f7f\u7528\u3057\u306a\u3044\u305f\u3081\u3001blueprint \u306e\u5148\u982d\u306b\u66f8\u304b\u308c\u3066\u3044\u308b\u624b\u9806\u306f\u5b9f\u884c\u3057\u306a\u304f\u3066\u3082\u304b\u307e\u3044\u307e\u305b\u3093\u3002\n\nSlash Commands \u306e\u8aac\u660e\u3067 `response_url` \u3092\u5229\u7528\u3057\u305f\u5fdc\u7b54\u306e\u8fd4\u3057\u304b\u305f\u304c\u8a18\u8f09\u3055\u308c\u3066\u3044\u307e\u3059\u3002\n\n\u3053\u306e\u5185\u5bb9\u3092\u3082\u3068\u306b Incoming Webhooks \u3067\u306a\u304f `response_url` \u3092\u4f7f\u3063\u3066\u5fdc\u7b54\u3092\u8fd4\u3059\u3088\u3046\u306b\u4fee\u6b63\u3057\u307e\u3059\u3002\n\n[Slash Commands | Slack](https://api.slack.com/slash-commands)\u3088\u308a\u5f15\u7528\n>   **Delayed responses and multiple responses**\n>   If you want to provide additional command response messages, or if you're unable to immediately respond to a command within 3000 milliseconds, use the specific `response_url` we send with our initial execution of your URL to respond to a command at your leisure. With this approach, you can respond to a user commands up to 5 times within 30 minutes of the user's invocation.\n>   Sending HTTP requests to this `response_url` is easy. Just build a JSON POST body in the same format as used when responding to our command invocation request to your registered URL. It supports all of the same fields (`response_type`, `text`, and `attachments`). Then, send that data as an HTTP POST with a `content-type` of `application/json` to the destination specified as the `response_url`.\n>   The only user-facing difference between immediate responses and delayed responses is that \"in channel\" delayed responses will not include the initial command sent by the user. To echo the command back to the channel, you'll still need to provide a response to Slack's original visit to your invocation URL.\n\nSNS Topic \u306e\u4f5c\u6210\n----------------\n\nSNS \u306e\u53d7\u4fe1\u30a4\u30d9\u30f3\u30c8\u3067 Lamba \u95a2\u6570\u3092\u8d77\u52d5\u3059\u308b\u305f\u3081\u306b\u3001SNS Topic \u3092\u4f5c\u6210\u3057\u3001Subscription \u3092 Protocol lambda \u3067\u4f5c\u6210\u3057\u307e\u3059\u3002\n\n![pic16.png](https://qiita-image-store.s3.amazonaws.com/0/68901/16325c29-433f-8a3d-a3ad-9d44e7900e5b.png)\n\nLambda\u95a2\u6570\u306e\u4f5c\u6210\n----------------\n\n![pic17.png](https://qiita-image-store.s3.amazonaws.com/0/68901/8fb9bce9-fc84-3915-d04c-0d624ba4bd1c.png)\n\n![pic18.png](https://qiita-image-store.s3.amazonaws.com/0/68901/1649c0e7-fe89-36ed-9f56-171568c98fc2.png)\n\n![pic19.png](https://qiita-image-store.s3.amazonaws.com/0/68901/d831de3e-87fd-ce34-2add-f1ec5dff3927.png)\n\n![pic20.png](https://qiita-image-store.s3.amazonaws.com/0/68901/6179eb02-70cb-c772-e051-b86782626517.png)\n\nblueprint\u306e\u30b3\u30fc\u30c9\u306e\u4fee\u6b63\n-----------------------\n\nlambda-bot \u5074\u3067\u306f\u3001\u30d1\u30e9\u30e1\u30fc\u30bf\u3092 JSON \u5f62\u5f0f\u3067 SNS \u30e1\u30c3\u30bb\u30fc\u30b8\u3068\u3057\u3066\u9001\u308a\u307e\u3059\u3002\n\n[Publish - Amazon Simple Notification Service](http://docs.aws.amazon.com/sns/latest/api/API_Publish.html) \u3088\u308a\u5f15\u7528 (\u592a\u5b57\u90e8\u5206\u306f\u7b46\u8005\u306b\u3088\u308b\u5f37\u8abf\uff09\n> **MessageStructure**\n>   Set\u00a0`MessageStructure`\u00a0to\u00a0`json`\u00a0if you want to send a different message for each protocol. For example, using one publish action, you can send a short message to your SMS subscribers and a longer message to your email subscribers. If you set`MessageStructure`\u00a0to\u00a0`json`, the value of the\u00a0`Message`\u00a0parameter must:\n>   be a syntactically valid JSON object; and\n>   **contain at least a top-level JSON key of \"default\" with a value that is a string.**\n>   You can define other top-level keys that define the message you want to send to a specific transport protocol (e.g., \"http\").\n>   For information about sending different messages for each protocol using the AWS Management Console, go to\u00a0[Create Different Messages for Each Protocol](http://docs.aws.amazon.com/sns/latest/gsg/Publish.html#sns-message-formatting-by-protocol)\u00a0in the*Amazon Simple Notification Service Getting Started Guide*.\n>   Valid value:\u00a0`json`\n>   Type: String\n>   Required: No\n\n\u3053\u306e\u305f\u3081\u306b\u95a2\u6570\u306e\u672c\u4f53\u3092\u6b21\u306e\u3088\u3046\u306b\u5909\u66f4\u3057\u307e\u3059\u3002\n\n**lambda-bot\u30b3\u30fc\u30c9**\n\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\ndef lambda_handler(event, context):\n    req_body = event['body']\n    params = parse_qs(req_body)\n    token = params['token'][0]\n    if token != expected_token:\n        logger.error(\"Request token (%s) does not match exptected\", token)\n        raise Exception(\"Invalid request token\")\n\n    user = params['user_name'][0]\n    command = params['command'][0]\n    channel = params['channel_name'][0]\n    if params.has_key('text'):\n        command_text = params['text'][0]\n    else:\n        command_text = ''\n    response_url = params['response_url'][0]\n    arg = command_text.split(' ')\n\n    sns = boto3.client('sns')\n    topic_arn = sns.create_topic(Name='sns-lambda')['TopicArn']\n    message={\"user_name\": user, \"command\": command, \"channel\": channel, \"command_text\": command_text, \"response_url\": response_url}\n    message=json.dumps(message)\n    message=json.dumps({'default': message, 'lambda': message})\n    response = sns.publish(\n        TopicArn=topic_arn,\n        Subject='/lambda',\n        MessageStructure='json',\n        Message=message\n    )\n    return { \"text\": \"%s %s\\nroger\" % (command, command_text) }\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n\u53d7\u4fe1\u5074\u306f blueprint \u306e\u30b3\u30fc\u30c9\u3092\u6b21\u306e\u3088\u3046\u306b\u4fee\u6b63\u3057\u307e\u3059\u3002\n`HOOK_URL` \u306e\u304b\u308f\u308a\u306b `response_url` \u3092\u4f7f\u7528\u3057\u3001JSON \u5f62\u5f0f\u3067\u5fdc\u7b54\u3092\u8fd4\u3059\u3088\u3046\u306b\u3057\u3066\u3044\u307e\u3059\u3002\n\n**notify-to-slack\u30b3\u30fc\u30c9**\n\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\ndef lambda_handler(event, context):\n    logger.info(\"Event: \" + str(event))\n    message = event['Records'][0]['Sns']['Message']\n    try:\n        message = json.loads(message)\n        user_name = message['user_name']\n        command = message['command']\n        command_text = message['command_text']\n        response_url = message['response_url']\n        arg = command_text.split(' ')\n        # if response_type is not specified, act as the same as ephemeral\n        # ephemeral, response message will be visible only to the user\n        slack_message = {\n            'channel': '@%s' % user_name,\n            #'response_type': 'in_channel',\n            'response_type': 'ephemeral',\n            'isDelayedResponse': 'true',\n            'text': \"response for: %s %s\" % (command, command_text)\n        }\n        logger.info(\"Send message to %s %s\", response_url, slack_message)\n        req = Request(response_url)\n        req.add_header('Content-Type', 'application/json')\n        response = urlopen(req, json.dumps(slack_message))\n        response.read()\n        logger.info(\"Message posted to %s\", slack_message['channel'])\n    except HTTPError as e:\n        logger.error(\"Request failed: %d %s\", e.code, e.reason)\n    except URLError as e:\n        logger.error(\"Server connection failed: %s\", e.reason)\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nLambda\u95a2\u6570\u306e\u30ed\u30fc\u30eb\u306e\u4fee\u6b63\n------------------------\n\nSNS \u30c8\u30d4\u30c3\u30af\u3078\u306e\u9001\u4fe1\u3092\u8a31\u53ef\u3057\u307e\u3059\u3002\n\n**lambda_basic_execution**\n\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n        {\n            \"Effect\": \"Allow\",\n            \"Action\": [\n                \"sns:*\"\n            ],\n            \"Resource\": [\n                \"arn:aws:sns:us-east-1:XXXXXXXXXXXX:sns-lambda\"\n            ]\n        },\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n\u30c6\u30b9\u30c8\n------\n\n\u30de\u30cd\u30b8\u30e1\u30f3\u30c8\u30b3\u30f3\u30bd\u30fc\u30eb\u304b\u3089\u30c6\u30b9\u30c8\u3059\u308b\u3068\u304d\u306e\u30c6\u30b9\u30c8\u30a4\u30d9\u30f3\u30c8\u306f\u6b21\u306e\u3088\u3046\u306b\u306a\u308a\u307e\u3059\u3002  \n`response_url` \u306e\u5024\u306f\u3001Slash Commands \u3067\u9001\u4fe1\u3055\u308c\u3066\u304d\u305f\u3082\u306e\u3092\u30ed\u30b0\u306b\u6b8b\u3059\u306a\u3069\u3057\u3066\u5165\u624b\u3057\u3066\u304f\u3060\u3055\u3044\u3002\n\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n{\n  \"Records\": [\n    {\n      \"Sns\": {\n        \"Message\": \"{\\\"command\\\": \\\"/lambda\\\", \\\"command_text\\\": \\\"ec2 console i-XXXXXXXX\\\", \\\"user_name\\\": \\\"Steve\\\", \\\"channel_name\\\": \\\"test\\\", \\\"response_url\\\": \\\"https://hooks.slack.com/commands/1234/5678\\\"}\"\n      }\n    }\n  ]\n}\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n\u30c6\u30b9\u30c8\u3067\u554f\u984c\u304c\u306a\u3051\u308c\u3070\u3001Lamba \u95a2\u6570\u3067 Event source \u306bSNS\u30c8\u30d4\u30c3\u30af\u3092\u6307\u5b9a\u3057 State \u3092 Enable \u306b\u3057\u3066\u304a\u304d\u307e\u3059\u3002\n\nSlack \u304b\u3089\u30c6\u30b9\u30c8\u3057\u3066\u307f\u307e\u3059\u3002\n\n![pic14.png](https://qiita-image-store.s3.amazonaws.com/0/68901/8bee66f7-d2df-8313-cf66-d36e228e2aef.png)\n\n\u3053\u306e\u3088\u3046\u306a\u5fdc\u7b54\u304c\u5f97\u3089\u308c\u308c\u3070\u5927\u4e08\u592b\u3067\u3059\u3002\n\n![pic29.png](https://qiita-image-store.s3.amazonaws.com/0/68901/db7e2819-3160-e279-4749-fe80f015d27d.png)\n\n\u3082\u3046\u5c11\u3057\u5b9f\u7528\u7684\u306a\u30b3\u30fc\u30c9\n======================\n\nEC2\u30a4\u30f3\u30b9\u30bf\u30f3\u30b9\u306e\u4e00\u89a7\u3084\u30b3\u30f3\u30bd\u30fc\u30eb\u306e\u51fa\u529b\u306e\u53d6\u5f97\u304c\u3067\u304d\u308b\u3088\u3046\u306b\u3057\u307e\u3059\u3002\n\n\u307e\u305fS3\u30d0\u30b1\u30c3\u30c8\u306e\u4e00\u89a7\u3082\u53d6\u5f97\u3057\u3066\u307f\u307e\u3059\u3002\n\nnotify-to-slack \u5074 slack_message = { \u2026 } \u306e\u5f8c\u306b\u3064\u304e\u306e\u30b3\u30fc\u30c9\u3092\u8ffd\u52a0\u3057\u307e\u3059\u3002\n\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n        if arg[0] == 'ec2':\n            if len(arg) == 3:\n                if  arg[1] == 'console':\n                    ec2 = boto3.resource('ec2')\n                    instance = ec2.Instance(arg[2])\n                    response = instance.console_output()\n                    output = '\\n'.join([x.rstrip() for x in response['Output'].split('\\n')[-20:]])\n                    slack_message['text'] = output\n            else:\n                ec2 = boto3.client('ec2')\n                response = ec2.describe_instances()\n                if response.has_key('Reservations') and len(response['Reservations']) >= 1:\n                    status = [(lambda x: (x[u'InstanceId'], ', '.join([t[u'Value'] for t in x[u'Tags']]), x[u'State'][u'Name']))(i) for i in response[u'Reservations'][0][u'Instances']]\n                    slack_message['text'] = '%s %s\\n%s' % (command, command_text, '\\n'.join(['%s: (%s) %s' % x for x in status]))\n                else:\n                    slack_message['text'] = \"%s %s\\nno instance found\" % (command, command_text)\n        elif arg[0] == 's3':\n            s3 = boto3.client('s3')\n            buckets = s3.list_buckets()\n            slack_message['text'] = \"%s %s\\n%s\" % (command, command_text, ' '.join([x[u'Name'] for x in buckets[u'Buckets']]))\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nLambda\u95a2\u6570\u306e\u30ed\u30fc\u30eb\u306e\u4fee\u6b63\n\nEC2 \u30a4\u30f3\u30b9\u30bf\u30f3\u30b9\u3001S3 \u30d0\u30b1\u30c3\u30c8\u306e\u60c5\u5831\u3092\u53c2\u7167\u3067\u304d\u308b\u3088\u3046\u306b\u3057\u307e\u3059\u3002\n\n**lambda_basic_execution**\n\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n        {\n            \"Effect\": \"Allow\",\n            \"Action\": [\n                \"ec2:Describe*\",\n                \"ec2:Get*\"\n            ],\n            \"Resource\": [\n                \"*\"\n            ]\n        },\n        {\n            \"Effect\": \"Allow\",\n            \"Action\": [\n                \"s3:Get*\",\n                \"s3:List*\"\n            ],\n            \"Resource\": [\n                \"*\"\n            ]\n        },\n        {\n            \"Effect\": \"Allow\",\n            \"Action\": [\n                \"cloudwatch:Get*\"\n            ],\n            \"Resource\": [\n                \"*\"\n            ]\n        },\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n![pic30.png](https://qiita-image-store.s3.amazonaws.com/0/68901/2a0d748d-5346-62d0-a5ac-ed2e4e17c63c.png)\n\n![pic31.png](https://qiita-image-store.s3.amazonaws.com/0/68901/d7b50de7-018c-ed76-45da-cdf29159256f.png)\n\n![pic32.png](https://qiita-image-store.s3.amazonaws.com/0/68901/dbfb026c-11fb-03b1-9595-68f74a06afe2.png)\n\n![pic33.png](https://qiita-image-store.s3.amazonaws.com/0/68901/cc058a8e-8f03-7d67-29a1-712481a23e97.png)\n\n![pic34.png](https://qiita-image-store.s3.amazonaws.com/0/68901/f252bc51-f9c6-0a5b-a39a-0485129b4f9a.png)\n\n![pic35.png](https://qiita-image-store.s3.amazonaws.com/0/68901/773115bb-094e-1bd5-ee28-790794d976ab.png)\n\nSTS\u306e\u5229\u7528\n=========\n\n\u30dc\u30c3\u30c8\u3092\u547c\u3073\u51fa\u3059\u30e6\u30fc\u30b6\u306b\u5fdc\u3058\u3066\u3001\u30b3\u30de\u30f3\u30c9\u3092\u5b9f\u884c\u3067\u304d\u308b\u6a29\u9650\u3092\u5909\u3048\u308b\u3053\u3068\u3092\u8003\u3048\u307e\u3059\u3002\n\n\u30af\u30ed\u30b9\u30a2\u30ab\u30a6\u30f3\u30c8\u30a2\u30af\u30bb\u30b9\u306e\u30ed\u30fc\u30eb virginia-ec2-delegate \u3092\u4f5c\u6210\u3057\u3066\u3001\u4fe1\u983c\u95a2\u4fc2\u3067 Lambda \u30b5\u30fc\u30d3\u30b9\u3092\u8ffd\u52a0\u3057\u307e\u3057\u305f\u3002\n\nSTS \u306e\u8a2d\u5b9a\u306b\u3064\u3044\u3066\u306e\u7406\u89e3\u304c\u5341\u5206\u3067\u306a\u3044\u305f\u3081\u3001\u3053\u308c\u3067\u5fc5\u8981\u5341\u5206\u6027\u306a\u306e\u304b\u3088\u304f\u308f\u304b\u308a\u307e\u305b\u3093\u304c\u3001\u52d5\u3044\u3066\u3044\u308b\u306e\u3067\u304a\u305d\u3089\u304f\u5927\u4e08\u592b\u3060\u3068\u601d\u3044\u307e\u3059\u3002\n\n\u30e6\u30fc\u30b6\u540d\u3092\u305d\u306e\u307e\u307e\u5229\u7528\u3057\u3066\u3044\u308b\u305f\u3081\u3001AWS \u306e IAM \u30e6\u30fc\u30b6\u540d\u3068 Slack \u306e\u30e6\u30fc\u30b6\u540d\u306f\u5408\u308f\u305b\u3066\u304a\u304f\u5fc5\u8981\u304c\u3042\u308a\u307e\u3059\u3002\n\n\u30ed\u30fc\u30eb**virginia-ec2-delegate**\n\n![pic25.png](https://qiita-image-store.s3.amazonaws.com/0/68901/73701fc8-0b5b-77ce-8fc2-2580e825a33a.png)\n\n![pic26.png](https://qiita-image-store.s3.amazonaws.com/0/68901/4ac84a64-44bc-0405-0128-a24dc2db5673.png)\n\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      \"Principal\": {\n        \"Service\": \"lambda.amazonaws.com\"\n      },\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n\u30dd\u30ea\u30b7\u30fc**ec2-full-access**\n\n![pic28.png](https://qiita-image-store.s3.amazonaws.com/0/68901/2ca1ae5b-0c61-bda8-8dfe-64ba3018d75e.png)\n\n\u30ed\u30fc\u30eb**assume-role**\n\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n{\n    \"Version\": \"2012-10-17\",\n    \"Statement\": [\n        {\n            \"Action\": [\n                \"sts:AssumeRole\"\n            ],\n            \"Effect\": \"Allow\",\n            \"Resource\": \"*\"\n        }\n    ]\n}\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nLambda\u95a2\u6570\u306e\u30ed\u30fc\u30eb\u306e\u4fee\u6b63\n\n**lambda_basic_execution**\n\n![pic27.png](https://qiita-image-store.s3.amazonaws.com/0/68901/2a51566c-cb95-4b97-5581-790da0f46e89.png)\n\nIAM\u306e\u5fc5\u8981\u306a\u53c2\u7167\u304c\u3067\u304d\u308b\u3088\u3046\u306b\u30ed\u30fc\u30eb\u306e\u30dd\u30ea\u30b7\u30fc\u3092\u4fee\u6b63\u3057\u307e\u3059\u3002\n\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n        {\n            \"Effect\": \"Allow\",\n            \"Action\": [\n                \"iam:GetUser\",\n                \"iam:GetRole\",\n                \"iam:UserPolicy\"\n            ],\n            \"Resource\": [\n                \"*\"\n            ]\n        }\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n**notify-to-slack\u30b3\u30fc\u30c9**\n\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n    iam = boto3.client('iam')\n    response = iam.get_user(UserName=user_name)\n    if response.has_key('User'):\n        uid = response['User']['Arn'].split(':')[4]\n        if uid and boto3.resource('iam').UserPolicy(user_name, 'ec2-full-access'):\n            response = iam.get_role(RoleName='virginia-ec2-delegate')\n            if response.has_key('Role'):\n                sts = boto3.client('sts')\n                assumedRoleObject = sts.assume_role(RoleArn=\"arn:aws:iam::%s:role/%s\" % (uid, 'virginia-ec2-delegate'), RoleSessionName='session')\n                credentials = assumedRoleObject['Credentials']\n                ec2 = boto3.resource(\n                    'ec2',\n                    aws_access_key_id=credentials['AccessKeyId'],                                    aws_secret_access_key=credentials['SecretAccessKey'],\n                    aws_session_token = credentials['SessionToken'],\n                    )\n                instance = ec2.Instance(arg[2])\n                state = 'unknown'\n                if arg[1] == 'start':\n                    response = instance.start()\n                    if response.has_key('StartingInstances'):\n                        state = response['StartingInstances'][0]['CurrentState']['Name']\n                        slack_message['text'] = '%s %s' % (arg[2], state)\n                elif arg[1] == 'stop':\n                    response = instance.stop()\n                    if response.has_key('StoppingInstances'):\n                        state = response['StoppingInstances'][0]['CurrentState']['Name']\n                slack_message['text'] = '%s %s' % (arg[2], state)\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n\u30c6\u30b9\u30c8\n------\n\nLambda \u95a2\u6570\u306b\u306f EC2 \u30a4\u30f3\u30b9\u30bf\u30f3\u30b9\u306e\u8d77\u52d5/\u505c\u6b62\u3092\u884c\u3046\u6a29\u9650\u306f\u6301\u305f\u305b\u3066\u3044\u307e\u305b\u3093\u304c\u3001STS \u3092\u5229\u7528\u3057\u3066\u30e6\u30fc\u30b6\u6a29\u9650\u3092\u5f15\u304d\u53d7\u3051\u3066\u5b9f\u884c\u3057\u307e\u3059\u3002\n\n![pic36.png](https://qiita-image-store.s3.amazonaws.com/0/68901/9a99683c-6355-8b46-7555-943534ff3baa.png)\n\n![pic37.png](https://qiita-image-store.s3.amazonaws.com/0/68901/a002d66c-ab90-4799-efa4-05b353323e3a.png)\n\n![pic38.png](https://qiita-image-store.s3.amazonaws.com/0/68901/cde595f1-11c2-9136-0c5b-28f042cf241e.png)\n\n![pic39.png](https://qiita-image-store.s3.amazonaws.com/0/68901/0a96e0a3-cf22-a9ec-825e-3f7fa417fbde.png)\n\n\u30b5\u30f3\u30d7\u30eb\u30b3\u30fc\u30c9\n==============\n\nlambda-bot\n----------\n\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nimport boto3\nfrom base64 import b64decode\nfrom urlparse import parse_qs\nfrom datetime import datetime, timedelta\nimport json\nimport logging\n\nENCRYPTED_EXPECTED_TOKEN = \"<KMS\u51fa\u529b\u306eCiphertextBlob\u306eRVALUE\u3067\u3042\u308bBASE64\u6587\u5b57\u5217\">\" # Enter the base-64 encoded, encrypted Slack command token (CiphertextBlob)\n\nkms = boto3.client('kms')\nexpected_token = kms.decrypt(CiphertextBlob = b64decode(ENCRYPTED_EXPECTED_TOKEN))['Plaintext']\n\nlogger = logging.getLogger()\nlogger.setLevel(logging.INFO)\n\ndef lambda_handler(event, context):\n    req_body = event['body']\n    params = parse_qs(req_body)\n    token = params['token'][0]\n    if token != expected_token:\n        logger.error(\"Request token (%s) does not match exptected\", token)\n        raise Exception(\"Invalid request token\")\n\n    user = params['user_name'][0]\n    command = params['command'][0]\n    channel = params['channel_name'][0]\n    if params.has_key('text'):\n        command_text = params['text'][0]\n    else:\n        command_text = ''\n    response_url = params['response_url'][0]\n    arg = command_text.split(' ')\n\n    if arg[0] in ['ec2', 's3']:\n        sns = boto3.client('sns')\n        topic_arn = sns.create_topic(Name='sns-lambda')['TopicArn']\n        message={\"user_name\": user, \"command\": command, \"channel\": channel, \"command_text\": command_text, \"response_url\": response_url}\n        message=json.dumps(message)\n        message=json.dumps({'default': message, 'lambda': message})\n        response = sns.publish(\n            TopicArn=topic_arn,\n            Subject='/lambda',\n            MessageStructure='json',\n            Message=message\n        )\n        return { \"text\": \"%s %s\\nroger\" % (command, command_text) }\n    elif arg[0] == 'help':\n        return { \"text\": \"ec2 [console|start|stop instance-id]\\ns3 [usage bucket]\" }\n    else:\n        return { \"text\": \"%s invoked %s in %s with the following text: %s\" % (user, command, channel, command_text) }\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nnotify-to-slack\n---------------\n\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nfrom __future__ import print_function\n\nimport boto3\nimport json\nimport logging\n\nfrom base64 import b64decode\nfrom urllib2 import Request, urlopen, URLError, HTTPError\nfrom time import sleep\n\nlogger = logging.getLogger()\nlogger.setLevel(logging.INFO)\n\ndef send_response(response_url, message):\n    req = Request(response_url)\n    req.add_header('Content-Type', 'application/json')\n    try:\n        response = urlopen(req, json.dumps(message))\n        response.read()\n    except HTTPError as e:\n        logger.error(\"Request failed: %d %s\", e.code, e.reason)\n    except URLError as e:\n        logger.error(\"Server connection failed: %s\", e.reason)\n\ndef ec2_command(arg, user_name, response_url):\n    if len(arg) == 3:\n        if  arg[1] == 'console':\n            ec2 = boto3.resource('ec2')\n            instance = ec2.Instance(arg[2])\n            response = instance.console_output()\n            output = '\\n'.join([x.rstrip() for x in response['Output'].split('\\n')[-20:]])\n            return output\n        elif arg[1] in ['start', 'stop']:\n            iam = boto3.client('iam')\n            response = iam.get_user(UserName=user_name)\n            if response.has_key('User'):\n                uid = response['User']['Arn'].split(':')[4]\n                if uid and boto3.resource('iam').UserPolicy(user_name, 'ec2-full-access'):\n                    response = iam.get_role(RoleName='virginia-ec2-delegate')\n                    if response.has_key('Role'):\n                        sts = boto3.client('sts')\n                        assumedRoleObject = sts.assume_role(RoleArn=\"arn:aws:iam::%s:role/%s\" % (uid, 'virginia-ec2-delegate'), RoleSessionName='session')\n                        credentials = assumedRoleObject['Credentials']\n                        ec2 = boto3.resource(\n                                'ec2',\n                                aws_access_key_id=credentials['AccessKeyId'],\n                                aws_secret_access_key=credentials['SecretAccessKey'],\n                                aws_session_token = credentials['SessionToken'],\n                                )\n                        instance = ec2.Instance(arg[2])\n                        state = instance.state['Name']\n                        if arg[1] == 'start':\n                            if state == 'stopped':\n                                response = instance.start()\n                                if response.has_key('StartingInstances'):\n                                    state = response['StartingInstances'][0]['CurrentState']['Name']\n                                    if state == 'pending':\n                                        if response_url:\n                                            send_response(response_url, { 'text': 'start %s' % arg[2] })\n                                        ec2client = boto3.client('ec2')\n                                        for wait in range(0,20):\n                                            response = ec2client.describe_instances(InstanceIds=[arg[2]])\n                                            state = response[u'Reservations'][0][u'Instances'][0]['State']['Name']\n                                            if state == 'running': break\n                                            sleep(3)\n                                return '%s become %s' % (arg[2], state)\n                            else:\n                                return '%s is already %s' % (arg[2], state)\n                        elif arg[1] == 'stop':\n                            if state == 'running':\n                                response = instance.stop()\n                                if response.has_key('StoppingInstances'):\n                                    state = response['StoppingInstances'][0]['CurrentState']['Name']\n                                    if state == 'stopping':\n                                        if response_url:\n                                            send_response(response_url, { 'text': 'stop %s' % arg[2] })\n                                        ec2client = boto3.client('ec2')\n                                        for wait in range(0,20):\n                                            response = ec2client.describe_instances(InstanceIds=[arg[2]])\n                                            state = response[u'Reservations'][0][u'Instances'][0]['State']['Name']\n                                            if state == 'stopped': break\n                                            sleep(3)\n                                    return '%s become %s' % (arg[2], state)\n                            else:\n                                return '%s is already %s' % (arg[2], state)\n                        else:\n                            return '%s: unknown' % arg[2]\n            else:\n                return '%s: user unknown' % user_name\n    else:\n        ec2 = boto3.client('ec2')\n        response = ec2.describe_instances()\n        if response.has_key('Reservations') and len(response['Reservations']) >= 1:\n            status = [(lambda x: (x[u'InstanceId'], ', '.join([t[u'Value'] for t in x[u'Tags']]), x[u'State'][u'Name']))(i) for i in response[u'Reservations'][0][u'Instances']]\n            return '\\n'.join(['%s: (%s) %s' % x for x in status])\n        else:\n            return \"no instance found\"\n\ndef s3_command(arg, user_name, response_url):\n    if len(arg) == 3 and arg[1] == 'usage':\n        cloudwatch = boto3.client('cloudwatch')\n        now = datetime.utcnow()\n        response = cloudwatch.get_metric_statistics(\n                    Namespace='AWS/S3',\n                    MetricName='BucketSizeBytes',\n                    Dimensions=[\n                        { 'Name': 'BucketName', 'Value': arg[2] },\n                        { 'Name': 'StorageType', 'Value': 'StandardStorage' }\n                    ],\n                    StartTime=now - timedelta(days=1),\n                    EndTime=now,\n                    Period=86400,\n                    Statistics=['Average'],\n                    Unit='Bytes'\n                    )\n        if response.has_key('Datapoints') and len(response[u'Datapoints']) >= 1:\n            return response[u'Datapoints'][0][u'Average']\n        else:\n            return \"no metric found\"\n    else:\n        s3 = boto3.client('s3')\n        buckets = s3.list_buckets()\n        return ' '.join([x[u'Name'] for x in buckets[u'Buckets']])\n\ndef lambda_handler(event, context):\n    message = event['Records'][0]['Sns']['Message']\n    logger.info(\"Event: \" + str(message))\n    if True:\n        message = json.loads(message)\n        user_name = message['user_name']\n        command = message['command']\n        command_text = message['command_text']\n        response_url = message['response_url']\n        arg = command_text.split(' ')\n\n        # if response_type is not specified , act as the same as ephemeral\n        # ephemeral, response message will be visible only to the user\n        slack_message = {\n            'channel': '@%s' % user_name,\n            #'response_type': 'in_channel',\n            'response_type': 'ephemeral',\n            'isDelayedResponse': 'true',\n            'text': \"%s %s\" % (command, command_text)\n        }\n\n        if arg[0] == 'ec2':\n            slack_message['text'] = ec2_command(arg, user_name, response_url)\n            send_response(response_url, slack_message)\n        elif arg[0] == 's3':\n            slack_message['text'] = s3_command(arg, user_name, response_url)\n            send_response(response_url, slack_message)\n\n    else:\n        slack_message = { 'text': \"command failed\" }\n        send_response(response_url, slack_message)\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n", "tags": ["Slack", "lambda", "SNS", "kms", "STS"]}