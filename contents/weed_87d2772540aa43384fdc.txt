{"context": " More than 1 year has passed since last update.describe \"A suite\", ->\n  it \"contains spec with an expectation\", ->\n    expect(true).toBe true\n\ndescribe \"A suite is just a function\", ->\n  it \"and so is a spec\", ->\n    a = true\n    expect(a).toBe true\n\ndescribe \"The 'tobe' matcher compares with ===\", ->\n  it \"and has a positive case\", ->\n    expect(true).toBe true\n\n  it \"and can have a negative case\", ->\n    expect(false).not.toBe true\n\ndescribe \"Included matchers:\", ->\n  it \"The 'toBe' matcher compares with ===\", ->\n    a = 12\n    b = a\n    expect(a).toBe b\n    expect(a).not.toBe null\n\n  describe \"The 'toEqual' matcher\", ->\n    it \"works for simple literals and variables\", ->\n      a = 12\n      expect(a).toEqual 12\n    it \"should work for objects\", ->\n      foo =\n        a: 12\n        b: 34\n      bar =\n        a: 12\n        b: 34\n      expect(foo).toEqual bar\n\n  it \"The 'toMatch' matcher is for regular expressions\", ->\n    message = 'foo bar baz'\n    expect(message).toMatch /bar/\n    expect(message).toMatch 'bar'\n    expect(message).not.toMatch /quux/\n\n  it \"The 'toBeDefined' matcher compares against 'undefined'\", ->\n    a =\n      foo: 'foo'\n    expect(a.foo).toBeDefined()\n    expect(a.bar).not.toBeDefined()\n\n  it \"The 'toBeUndefined' matcher compares against 'undefined'\", ->\n    a =\n      foo: 'foo'\n    expect(a.foo).not.toBeUndefined()\n    expect(a.bar).toBeUndefined()\n\n  it \"The 'toBeNull' matcher compares against null\", ->\n    a = null\n    foo = 'foo'\n    expect(null).toBeNull()\n    expect(a).toBeNull()\n    expect(foo).not.toBeNull()\n\n  it \"The 'toBeTruthy' matcher is for boolean casting testing\", ->\n    a = false\n    foo = 'foo'\n    expect(foo).toBeTruthy()\n    expect(a).not.toBeTruthy()\n\n  it \"The 'toBeFalsy' matcher is for boolean casting testing\", ->\n    a = false\n    foo = 'foo'\n    expect(a).toBeFalsy()\n    expect(foo).not.toBeFalsy()\n\n  it \"The 'toContain' matcher is for finding an item in an Array\", ->\n    a = ['foo', 'bar', 'baz']\n    expect(a).toContain 'bar'\n    expect(a).not.toContain 'quux'\n\n  it \"The 'toBeLessThan' matcher is for mathematical comparisons\", ->\n    pi = 3.1415926\n    e = 2.78\n    expect(e).toBeLessThan pi\n    expect(pi).not.toBeLessThan e\n\n  it \"The 'toBeGreaterThan' is for mathematical comparisons\", ->\n    pi = 3.1415926\n    e = 2.78\n    expect(pi).toBeGreaterThan e\n    expect(e).not.toBeGreaterThan pi\n\n  it \"The 'toBeCloseTo' matcher is for precision math comparison\", ->\n    # Matcher that checks that the expected item is equal to the actual item\n    # up to a given level of decimal precision (default 2).\n    pi = 3.1415926\n    e = 2.78\n    expect(pi).not.toBeCloseTo e, 2\n    expect(pi).toBeCloseTo e, 0\n\n  it \"The 'toThrow' matcher is for testing if a function throws an exception\", ->\n    foo = -> 1 + 2\n    bar = (a) -> a + 1\n    expect(foo).not.toThrow()\n    expect(bar).not.toThrow()\n\ndescribe \"A spec\", ->\n  it \"is just a function, so it can contain any code\", ->\n    foo = 0\n    foo += 1\n    expect(foo).toEqual 1\n\n  it \"can have more than one expectation\", ->\n    foo = 0\n    foo += 1\n    expect(foo).toEqual 1\n    expect(true).toEqual true\n\ndescribe \"A spec (with setup and tear-down)\", ->\n  # Here is the same set of specs written a little differently.\n  # The variable under test is defined at the top-level scope\n  # - the describe block - and initialization code is\n  # moved into a beforeEach function.\n  # The afterEach function resets the variable before continuing.\n  foo = null\n  beforeEach ->\n    foo = 0\n    foo += 1\n  afterEach ->\n    foo = 0\n  it \"is just a function, so it can contain any code\", ->\n    expect(foo).toEqual 1\n  it \"can have more than one expectation\", ->\n    expect(foo).toEqual 1\n    expect(true).toEqual true\n\ndescribe \"A spec\", ->\n  # Calls to describe can be nested, with specs defined at any level.\n  # This allows a suite to be composed as a tree of functions.\n  # Before a spec is executed,\n  # Jasmine walks down the tree executing each beforeEach function in order.\n  # After the spec is executed, Jasmine walks through the afterEach functions similarly.\n  foo = null\n  beforeEach ->\n    foo = 0\n    foo += 1\n  afterEach ->\n    foo = 0\n  it \"is just a function, so it can contain any code\", ->\n    expect(foo).toEqual 1\n  it \"can have more than one expectation\", ->\n    expect(foo).toEqual 1\n    expect(true).toEqual true\n  describe \"nested inside a second describe\", ->\n    bar = null\n    beforeEach ->\n      bar = 1\n    it \"can reference both scopes as needed\", ->\n      expect(foo).toEqual bar\n\nxdescribe \"A spec\", ->\n  # Suites and specs can be disabled with the xdescribe and xit functions, respectively.\n  # These suites and specs are skipped when run\n  # and thus their results will not appear in the results.\n  foo = null\n  beforeEach ->\n    foo = 0\n    foo += 1\n  xit \"is just a function, so it can contain any code\", ->\n    expect(foo).toEqual 1\n\ndescribe \"A spy\", ->\n  # Jasmine\u2019s test doubles are called spies.\n  # A spy can stub any function and tracks calls to it and all arguments.\n  foo = null\n  bar = null\n  beforeEach ->\n    foo =\n      setBar: (value) ->\n        bar = value\n\n    spyOn foo, 'setBar'\n\n    foo.setBar 123\n    foo.setBar 456, 'another param'\n\n  it \"tracks that the spy was called\", ->\n    expect(foo.setBar).toHaveBeenCalled()\n\n  it \"tracks its number of calls\", ->\n    expect(foo.setBar.calls.length).toEqual 2\n\n  it \"tracks all the arguments of its calls\", ->\n    expect(foo.setBar).toHaveBeenCalledWith 123\n    expect(foo.setBar).toHaveBeenCalledWith 456, 'another param'\n\n  it \"allows access to the most recent call\", ->\n    expect(foo.setBar.mostRecentCall.args[0]).toEqual 456\n\n  it \"allows access to other calls\", ->\n    expect(foo.setBar.calls[0].args[0]).toEqual 123\n\n  it \"stops all execution on a function\", ->\n    expect(bar).toBeNull()\n\n\n\u30d6\u30ed\u30b0\u3084\u3063\u3066\u307e\u3059\uff1aPAPA-tronix !\n```coffeescript\ndescribe \"A suite\", ->\n  it \"contains spec with an expectation\", ->\n    expect(true).toBe true\n\ndescribe \"A suite is just a function\", ->\n  it \"and so is a spec\", ->\n    a = true\n    expect(a).toBe true\n\ndescribe \"The 'tobe' matcher compares with ===\", ->\n  it \"and has a positive case\", ->\n    expect(true).toBe true\n\n  it \"and can have a negative case\", ->\n    expect(false).not.toBe true\n\ndescribe \"Included matchers:\", ->\n  it \"The 'toBe' matcher compares with ===\", ->\n    a = 12\n    b = a\n    expect(a).toBe b\n    expect(a).not.toBe null\n\n  describe \"The 'toEqual' matcher\", ->\n    it \"works for simple literals and variables\", ->\n      a = 12\n      expect(a).toEqual 12\n    it \"should work for objects\", ->\n      foo =\n        a: 12\n        b: 34\n      bar =\n        a: 12\n        b: 34\n      expect(foo).toEqual bar\n\n  it \"The 'toMatch' matcher is for regular expressions\", ->\n    message = 'foo bar baz'\n    expect(message).toMatch /bar/\n    expect(message).toMatch 'bar'\n    expect(message).not.toMatch /quux/\n\n  it \"The 'toBeDefined' matcher compares against 'undefined'\", ->\n    a =\n      foo: 'foo'\n    expect(a.foo).toBeDefined()\n    expect(a.bar).not.toBeDefined()\n\n  it \"The 'toBeUndefined' matcher compares against 'undefined'\", ->\n    a =\n      foo: 'foo'\n    expect(a.foo).not.toBeUndefined()\n    expect(a.bar).toBeUndefined()\n\n  it \"The 'toBeNull' matcher compares against null\", ->\n    a = null\n    foo = 'foo'\n    expect(null).toBeNull()\n    expect(a).toBeNull()\n    expect(foo).not.toBeNull()\n\n  it \"The 'toBeTruthy' matcher is for boolean casting testing\", ->\n    a = false\n    foo = 'foo'\n    expect(foo).toBeTruthy()\n    expect(a).not.toBeTruthy()\n\n  it \"The 'toBeFalsy' matcher is for boolean casting testing\", ->\n    a = false\n    foo = 'foo'\n    expect(a).toBeFalsy()\n    expect(foo).not.toBeFalsy()\n\n  it \"The 'toContain' matcher is for finding an item in an Array\", ->\n    a = ['foo', 'bar', 'baz']\n    expect(a).toContain 'bar'\n    expect(a).not.toContain 'quux'\n\n  it \"The 'toBeLessThan' matcher is for mathematical comparisons\", ->\n    pi = 3.1415926\n    e = 2.78\n    expect(e).toBeLessThan pi\n    expect(pi).not.toBeLessThan e\n\n  it \"The 'toBeGreaterThan' is for mathematical comparisons\", ->\n    pi = 3.1415926\n    e = 2.78\n    expect(pi).toBeGreaterThan e\n    expect(e).not.toBeGreaterThan pi\n\n  it \"The 'toBeCloseTo' matcher is for precision math comparison\", ->\n    # Matcher that checks that the expected item is equal to the actual item\n    # up to a given level of decimal precision (default 2).\n    pi = 3.1415926\n    e = 2.78\n    expect(pi).not.toBeCloseTo e, 2\n    expect(pi).toBeCloseTo e, 0\n\n  it \"The 'toThrow' matcher is for testing if a function throws an exception\", ->\n    foo = -> 1 + 2\n    bar = (a) -> a + 1\n    expect(foo).not.toThrow()\n    expect(bar).not.toThrow()\n\ndescribe \"A spec\", ->\n  it \"is just a function, so it can contain any code\", ->\n    foo = 0\n    foo += 1\n    expect(foo).toEqual 1\n\n  it \"can have more than one expectation\", ->\n    foo = 0\n    foo += 1\n    expect(foo).toEqual 1\n    expect(true).toEqual true\n\ndescribe \"A spec (with setup and tear-down)\", ->\n  # Here is the same set of specs written a little differently.\n  # The variable under test is defined at the top-level scope\n  # - the describe block - and initialization code is\n  # moved into a beforeEach function.\n  # The afterEach function resets the variable before continuing.\n  foo = null\n  beforeEach ->\n    foo = 0\n    foo += 1\n  afterEach ->\n    foo = 0\n  it \"is just a function, so it can contain any code\", ->\n    expect(foo).toEqual 1\n  it \"can have more than one expectation\", ->\n    expect(foo).toEqual 1\n    expect(true).toEqual true\n\ndescribe \"A spec\", ->\n  # Calls to describe can be nested, with specs defined at any level.\n  # This allows a suite to be composed as a tree of functions.\n  # Before a spec is executed,\n  # Jasmine walks down the tree executing each beforeEach function in order.\n  # After the spec is executed, Jasmine walks through the afterEach functions similarly.\n  foo = null\n  beforeEach ->\n    foo = 0\n    foo += 1\n  afterEach ->\n    foo = 0\n  it \"is just a function, so it can contain any code\", ->\n    expect(foo).toEqual 1\n  it \"can have more than one expectation\", ->\n    expect(foo).toEqual 1\n    expect(true).toEqual true\n  describe \"nested inside a second describe\", ->\n    bar = null\n    beforeEach ->\n      bar = 1\n    it \"can reference both scopes as needed\", ->\n      expect(foo).toEqual bar\n\nxdescribe \"A spec\", ->\n  # Suites and specs can be disabled with the xdescribe and xit functions, respectively.\n  # These suites and specs are skipped when run\n  # and thus their results will not appear in the results.\n  foo = null\n  beforeEach ->\n    foo = 0\n    foo += 1\n  xit \"is just a function, so it can contain any code\", ->\n    expect(foo).toEqual 1\n\ndescribe \"A spy\", ->\n  # Jasmine\u2019s test doubles are called spies.\n  # A spy can stub any function and tracks calls to it and all arguments.\n  foo = null\n  bar = null\n  beforeEach ->\n    foo =\n      setBar: (value) ->\n        bar = value\n\n    spyOn foo, 'setBar'\n\n    foo.setBar 123\n    foo.setBar 456, 'another param'\n\n  it \"tracks that the spy was called\", ->\n    expect(foo.setBar).toHaveBeenCalled()\n\n  it \"tracks its number of calls\", ->\n    expect(foo.setBar.calls.length).toEqual 2\n\n  it \"tracks all the arguments of its calls\", ->\n    expect(foo.setBar).toHaveBeenCalledWith 123\n    expect(foo.setBar).toHaveBeenCalledWith 456, 'another param'\n\n  it \"allows access to the most recent call\", ->\n    expect(foo.setBar.mostRecentCall.args[0]).toEqual 456\n\n  it \"allows access to other calls\", ->\n    expect(foo.setBar.calls[0].args[0]).toEqual 123\n\n  it \"stops all execution on a function\", ->\n    expect(bar).toBeNull()\n```\n\n-----\n\u30d6\u30ed\u30b0\u3084\u3063\u3066\u307e\u3059\uff1a[PAPA-tronix !](http://weed.cocolog-nifty.com/wzero3es/)", "tags": ["jasmine", "CoffeeScript"]}