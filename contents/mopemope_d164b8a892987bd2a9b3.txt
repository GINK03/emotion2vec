{"context": " More than 1 year has passed since last update.\n\nClojure \u3067\u5b9f\u7528\u7684\u306a\u30d7\u30ed\u30b0\u30e9\u30e0\u3092\u66f8\u304f\n\u3053\u3093\u306b\u3061\u308f\u3001wozozo\u3067\u3059\u3002\n\u6700\u8fd1\u3001netty 4\u30d9\u30fc\u30b9\u306e\u30d5\u30ec\u30fc\u30e0\u30ef\u30fc\u30af\u3092\u66f8\u3044\u3066\u308b\u306e\u3067\u3059\u304c\u3001\u901f\u5ea6\u554f\u984c\u3067\u307b\u307cJava\u3067\u66f8\u3044\u3066\u3057\u307e\u3044\u3001\u66f8\u304f\u3053\u3068\u304c\u306a\u304f\u306a\u3063\u305f\u306e\u3067\u904e\u53bb\u306b\u4f5c\u3063\u305f\u5b9f\u7528\u7684\u306a\u30d7\u30ed\u30b0\u30e9\u30e0\u306e\u8a71\u3092\u3057\u307e\u3059\u3002\nalgo.monads \u306e\u8a71\u3067\u3082\u826f\u304b\u3063\u305f\u306e\u3067\u3059\u304c\u3001\u4ed6\u306b\u66f8\u304b\u308c\u308b\u65b9\u304c\u3044\u308b\u3067\u3057\u3087\u3046\u3002\n\u305f\u3076\u3093\u3053\u3093\u306a\u3093\u3092\u66f8\u304b\u308c\u308b\u3068\u601d\u3044\u307e\u3059\u3002\n(ns cljinja.lexer\n  (:use\n    [clojure.algo.monads])\n  (:require \n    [clojure.string :as str])\n  (:import \n    [java.util.regex Pattern]))\n\n(def ^:dynamic *block-begin* \"{%\")\n(def ^:dynamic *block-end* \"%}\")\n(def ^:dynamic *variable-begin* \"{{\")\n(def ^:dynamic *variable-end* \"}}\")\n(def ^:dynamic *comment-begin* \"{#\")\n(def ^:dynamic *comment-end* \"#}\")\n\n;;\n;; Parsec\n;;\n\n(def ^:dynamic parser-m (state-t maybe-m))\n\n(defn- return [v]\n  (with-monad parser-m\n    (m-result v)))\n\n(defn- >>= [p f]\n  (with-monad parser-m\n    (m-bind p f)))\n\n(defn- >>== [p f]\n  (>>= p #(return (f %))))\n\n(defn- <$> [f p]\n  (>>= p #(return (f %))))\n\n(defn- >> [p1 p2]\n  (>>= p1 (fn [_] p2)))\n\n(defn- either [& parsers]\n  (apply (:m-plus parser-m) parsers))\n\n(def <|> either)\n\n(defmacro let-bind\n  \"Wraps body in `domonad' boilerplate\"\n  [& body]\n  `(domonad parser-m\n            ~@body))\n\n(defn- state [data pos line]\n  {:data data \n   :pos pos\n   :line line})\n\n(defn- inc-newline [line text]\n       (+ line (dec (count (str/split (if (char? text) (str text) text) #\"\\n\"))))) \n\n(defn- any-token [n] \n  (fn [{^String strn :data pos :pos line :line}]\n      (when-not (= \"\" strn)\n        (let [data (subs strn 0 n)\n              nline (inc-newline line data)]\n          [(state data pos line )\n           (state (subs strn n) (+ pos n) nline )]))))\n\n(defn- eof [{^String strn :data pos :pos line :line }]\n  (when (= \"\" strn)\n    [(state strn pos line )\n     (state strn pos line )]))\n\n(defn- nothing [{^String strn :data pos :pos line :line }]\n  [(state \"\" pos line) \n   (state strn pos line)])\n\n(defn- merge-state [x y]\n  (reduce (fn [{d1 :data :as m} {d2 :data :as n}] (assoc m :data (str d1 d2))) x y))\n\n(defn stringify [p]\n  (>>= p (fn [x] \n             (return \n               (if (vector? x)\n                 (merge-state (first x) (next x))\n                 x)))))\n\n(defn- satisfy [pred n]\n  (domonad parser-m\n           [c (any-token n) :when (pred (:data c))]\n      c))\n\n(defn- is-char [c]\n  (satisfy (partial = c) 1))\n\n(defn- not-char [c]\n  (satisfy (partial (comp not =) c) 1))\n\n(defn- is-str [st]\n  (satisfy (partial = st) (count st)))\n\n(defn- not-str [st]\n  (satisfy (partial (comp not =) st) (count st)))\n\n(defn- optional [p]\n  (either p nothing))\n\n(defn- option [default p]\n  (either p default))\n\n(defprotocol RegexParser\n  (regex [this]))\n\n(extend-protocol RegexParser\n  java.lang.String\n  (regex [this]\n    (let [re (re-pattern (str \"^(?:\" this \")\"))]\n      (regex re)))\n\n  java.util.regex.Pattern\n  (regex [re]\n    (fn [{^String strn :data pos :pos line :line}]\n      (let [m (re-find re strn)\n            v (if (vector? m) (first m) m)]\n        (when-not (or (nil? v))\n          (let [len (count v)\n                nstr (subs strn len)]\n              ; (println (format \"'%s'  '%s'  '%s'\" re strn nstr))\n              [(state v pos line)\n               (state nstr (+ pos len) (inc-newline line v))]))))))\n\n(defmacro string-p [^String target]\n  `(fn [{^String strn# :data pos# :pos line# :line}]\n     (when (.startsWith strn# ~target)\n       (let [len# (count ~target)\n             nstr# (subs strn# len#)]\n           [(state ~target pos# line#)\n            (state nstr# (+ pos# len#) (inc-newline line# ~target))]))))\n\n(defmacro not-string-p [^String target]\n  `(fn [{^String strn# :data pos# :pos line# :line}]\n     (when-not (.startsWith strn# ~target)\n       [(state strn# pos# line#) (state strn# pos# line#)])))\n\n(defn- concat% [x xs]\n  (let [coll (if (vector? x) x [x])\n        coll? (vector? xs)]\n    (if coll?\n      (into coll xs)\n      (if (= \"\" (:data xs))\n        x \n        (conj coll xs)))))\n\n(declare many1)\n\n(defn- many [parser]\n  (optional (many1 parser)))\n\n(defn- many1 [parser]\n  (let-bind [a parser\n             as (many parser)]\n             (concat% a as)))\n\n(def aspace (regex #\"[\\s\\r\\n]\"))\n(def spaces (regex #\"[\\s\\r\\n]+\"))\n(def spaces* (regex #\"[\\s\\r\\n]*\"))\n\n(defn- white-space [p]\n  (>> spaces p))\n\n(defn- lexeme [p]\n  (let-bind [a p _ spaces] a))\n\n(defn- lexeme* [p]\n  (let-bind [a p _ spaces*] a))\n\n(defn- between [open close p]\n  (let-bind [_ open\n             x p\n             _ close]\n            x))\n\n(defn sep-by-1 [p sep]\n  (let-bind [x p\n             xs (many (>> sep p))]\n            (concat% x xs)))\n\n(defmacro surround [st#]\n  (stringify\n    (between \n      (is-char st#)\n      (is-char st#)\n      (many (not-str st#)))))\n\n(defn- parse [parser input]\n  (parser (state input 0 1)))\n\n;; \n;; Rule \n;; \n\n(def ^:private sp-chars #\"([\\\\\\\\*+\\\\[\\\\](){}\\\\$.?\\\\^|])\")\n\n(defn- escape-regex [in]\n  (str/replace in sp-chars \"\\\\\\\\$1\"))\n\n(defn- build-regex [args]\n  (str/join \"|\" (map escape-regex args)))\n\n(defn- create-regex [tags]\n  (Pattern/compile (str \"^(.*?)(\" (build-regex tags) \")\") Pattern/DOTALL))\n\n(defn- text-data-p [regex]\n  (fn [{^String strn :data pos :pos line :line }]\n    (let [found (re-find (re-matcher (create-regex regex) strn))\n          [pair text token] (or found [nil nil nil])]\n      (when (and token (not= token pair))\n        (let [len (count text)\n              nstr (.substring strn (- (.length pair) (.length token)))]\n          [(state text pos line)\n           (state nstr (+ pos len) (inc-newline line text) )]))))) \n\n(defmacro token [nm]\n  (let [nm# nm]\n    `(fn [{^String strn# :data pos# :pos line# :line }]\n       {:data strn#\n       :pos pos#\n       :line line#\n       :type ~nm#})))\n\n(def op-array [\n               \"+\" :add\n               \"-\" :sub\n               \"/\" :div\n               \"//\" :floordiv\n               \"*\" :mul\n               \"%\" :mod\n               \"**\" :pow\n               \"~\" :tilde\n               ; \"[\" :lbracket\n               ; \"]\" :rbracket\n               ; \"(\" :lparen\n               ; \")\" :rparen\n               ; \"{\" :lbrace\n               ; \"}\" :rbrace\n               \"==\" :eq\n               \"!=\" :ne\n               \">\" :gt\n               \">=\" :gtEQ\n               \"<\" :lt\n               \"<=\" :ltEQ\n               \"=\" :assign\n               \".\" :dot\n               \":\" :colon\n               \"|\" :pipe\n               \",\" :comma\n               \";\" :semicolon])\n\n(def operators (apply array-map op-array))\n\n(defmacro operators-p []\n  (let [re (build-regex (keys operators))]\n    `(<$> (fn [{^String strn# :data pos# :pos line# :line }]\n              {:data strn#\n              :pos pos#\n              :line line#\n              :type (get operators strn#)})\n        (regex (str \"(\" ~re \")\")))))\n\n(def string-literal\n  (<$> (token :string)\n     (<|> (surround \"'\")\n          (surround \"\\\"\"))))\n\n(def name-p\n  (<$> (token :name)\n       (regex \"[a-zA-Z_][a-zA-Z0-9_-]*\")))\n\n(def integer-p\n  (<$> (token :integer)\n       (regex \"\\\\d+\")))\n\n(def float-p\n  (<$> (token :float)\n       (regex \"\\\\d+\\\\.\\\\d+\")))\n\n(def ident \n   (<|> string-literal name-p float-p integer-p (operators-p)))\n\n(def text-block\n  (<$> (token :data)\n       (text-data-p [*variable-begin* *block-begin* *comment-begin* *variable-end* *block-end* *comment-end*])))\n\n(def rest-text\n  (<$> (token :data) \n       (fn [{^String strn :data pos :pos line :line }]\n           [(state strn pos line )\n            (state \"\" pos line )])))\n\n(def block-begin-p\n  (<$> (token :block-begin)\n       (lexeme* (is-str *block-begin*))))\n\n(def block-end-p\n  (<$> (token :block-end)\n       (>> spaces* (is-str *block-end*))))\n\n(def variable-begin-p\n  (<$> (token :v-begin)\n       (lexeme* (is-str *variable-begin*))))\n\n(def variable-end-p\n  (<$> (token :v-end)\n       (>> spaces* (is-str *variable-end*))))\n\n(defn- fail-state [{^String strn :data pos :pos line :line }]\n  [{:state :fail :data strn :pos pos :line line}\n   (state strn pos line)])\n\n(defmacro make-block [begin end gurad]\n  `(let-bind [b# ~begin \n              x# (sep-by-1 (>> ~gurad ident) spaces)\n              e# (option fail-state ~end)]\n             (if (= :fail (:state e#))\n               (throw (Exception. (format \"Template Syntax Error:%s\" e#)))\n               (concat% (concat% b# x#) e#))))\n\n(def block-block \n     (make-block \n       block-begin-p block-end-p (not-string-p *block-end* )))\n\n(def variable-block \n     (make-block \n       variable-begin-p variable-end-p (not-string-p *variable-end*)))\n\n(def blocks \n     (many1 (<|> block-block  variable-block text-block)))\n\n(def rule\n  (let-bind [c blocks \n             cs rest-text]\n            (concat% c cs)))\n\n(defn- lex- [rule input]\n  (first (parse rule input)))\n\n(defn lex [input]\n  (lex- rule input))\n\n(def input \"{% extends 'hoge.html' %}\n            test\n            {% for item in items %}\n            {{ item }}\n            {% endfor %}\n            \")\n(lex- rule input)\n\n\n\u672c\u984c\n\u3068\u3044\u3046\u308f\u3051\u3067\u672c\u984c\n\n\u5b9f\u7528\u7684\u306a\u30d7\u30ed\u30b0\u30e9\u30e0\uff1f\u30af\u30ed\u30fc\u30e9\u30fc\u3060\u308d\uff01\n\u3068\u3044\u3046\u308f\u3051\u3067 Clojure \u3067\u30af\u30ed\u30fc\u30e9\u30fc\u3092\u66f8\u3044\u3066\u307f\u305f\u306e\u3092\u516c\u958b\u3057\u3066\u3044\u307e\u3059\u3002\n2ch \u30af\u30ed\u30fc\u30e9\u30fc\n\u5143\u3005\u3001PostgreSQL\u306e\u5168\u6587\u691c\u7d22\u306e\u8a55\u4fa1\u3092\u884c\u3046\u305f\u3081\u306b\u3001\u65e5\u672c\u8a9e\u30c7\u30fc\u30bf\u3092\u304b\u304d\u96c6\u3081\u308b\u305f\u3081\u306b\u66f8\u3044\u305f\u3082\u306e\u3067\u3059\u3002\n\u57fa\u672c\u7684\u306b\u30ad\u30e3\u30c3\u30b7\u30e5\u30b5\u30fc\u30d0\u30fc\u304b\u3089\u306e\u53d6\u5f97\u3067\u3059\u3002\n\u666e\u901a\u306b\u66f8\u3044\u3066\u308b\u3068\u30d0\u30fc\u30dc\u30f3\u30cf\u30a6\u30b9\u884c\u304d\u306b\u306a\u308b\u305f\u3081\u4e26\u5217\u6570\u3092\u5236\u9650\u3059\u308b\u5de5\u592b\u304c\u5165\u3063\u3066\u3044\u307e\u3059\u3002\nClojure\u306efuture\u30de\u30af\u30ed\u306fExecutors.newCachedThreadPool\u3067\u4f5c\u3089\u308c\u305fExecutorService\u3092\u4f7f\u3044\u307e\u3059\u3002\n\u305d\u306e\u305f\u3081future\u3092\u4f7f\u3046\u3068\u30d0\u30f3\u30d0\u30f3Thread\u304c\u4f5c\u3089\u308c\u3001\u4e26\u5217\u6570\u306f\u5236\u5fa1\u3067\u304d\u307e\u305b\u3093\u3002\n\u305d\u3053\u3067\u30ad\u30e5\u30fc\u306b\u8caf\u3081\u3066\u3001\u5fc5\u8981\u306a\u6570\u3060\u3051\u30ef\u30fc\u30ab\u30fc\u3092\u8d70\u3089\u305b\u308b\u3088\u3046\u306b\u306a\u3063\u3066\u3044\u307e\u3059\u3002\n\n(def ^:dynamic *sleep-time* 5000)\n\n(defn dequeue! [queue]\n  (loop []\n    (let [q @queue\n          value (first q)\n          nq (next q)]\n      (if (compare-and-set! queue q nq)\n        value\n        (recur)))))\n\n(defn- make-worker [f]\n  (let [worker-fn f]\n   (fn [q] \n      (when-let [val (dequeue! q)]\n        (try\n          (debug (format \"start call worker val:%s\" val))\n          (worker-fn val)\n          (debug (format \"end call worker val:%s remain:%s\" val (count @q)))\n          (catch Exception e (error e)))\n        (debug (format \"wait:%s ... \" *sleep-time*))\n        (Thread/sleep *sleep-time*)\n        (recur q)))))\n\n(defn start-worker [q f nthread]\n  (let [p (promise)\n        cnt (atom nthread)]\n    (dotimes [i nthread]\n      (future \n        ((make-worker f) q)\n        (if (= 0 (swap! cnt dec))\n          (deliver p \"OK\"))))\n    p))\n\n\n\u554f\u984c\u306f\u4e26\u5217\u306b\u30ad\u30e5\u30fc\u306b\u5024\u3092\u7a81\u3063\u8fbc\u3093\u3060\u308a\u3001\u51fa\u3057\u305f\u308a\u3059\u308b\u308f\u3051\u3067\u305d\u3053\u3092\u3069\u3046\u5b9f\u88c5\u3059\u308b\u304b\u3063\u3066\u3068\u3053\u3067\u3059\u3002\n\u3042\u307e\u308a\u4f7f\u308f\u308c\u3066\u308b\u306e\u3092\u898b\u305f\u3053\u3068\u304c\u306a\u3044\u306e\u3067\u3059\u304ccompare-and-set!\u3067\u5024\u3092\u6bd4\u8f03\u3001\u554f\u984c\u306a\u3051\u308c\u3070\u5024\u3092\u8fd4\u3057\u3066\u3044\u307e\u3059\u3002\u5931\u6557\uff08\u3053\u306e\u9593\u306b\u5225 Thread \u306b\u3088\u3063\u3066\u5024\u304c\u5909\u308f\u3063\u305f\uff09\u5834\u5408\u306b\u306f\u30ea\u30c8\u30e9\u30a4\u3057\u3066\u3044\u307e\u3059\u3002\n\u3044\u308f\u3086\u308bCAS\u3067\u3059\u306d\u3002\n\u30b9\u30af\u30ec\u30a4\u30d4\u30f3\u30b0\u3001\u30c7\u30fc\u30bf\u30d9\u30fc\u30b9\u30a2\u30af\u30bb\u30b9\u3001\u30b9\u30ec\u30c3\u30c9\u306a\u3069\u5b9a\u756a\u51e6\u7406\u304c\u5165\u3063\u3066\u308b\u306e\u3067\u826f\u3044\u30b5\u30f3\u30d7\u30eb\u3060\u3068\u601d\u3044\u307e\u3059\u3002\n\n\u5b9f\u7528\u7684\u306a\u30d7\u30ed\u30b0\u30e9\u30e0\uff1f\u3084\u3063\u3071\u30af\u30ed\u30fc\u30e9\u30fc\u3060\u308d\uff01\n\u306f\u3044\u3001\u6b21\u3082\u3084\u306f\u308a\u30af\u30ed\u30fc\u30e9\u30fc\u3067\u3057\u3087\u3046\u304b\u3002\n\u5143\u3005\u306fcore.async\u304c\u51fa\u305f\u3070\u3063\u304b\u306e\u9803\u306b\u8a66\u3057\u3066\u307f\u305f\u304f\u3066\u66f8\u3044\u305f\u3082\u306e\u3067\u3059\u3002\n\u5168\u90e8\u306f\u8a00\u3044\u307e\u305b\u3093\u304c\u3001\u8981\u306f\u5c0f\u3055\u306a\u56f3\u66f8\u9928\u3092\u4f5c\u308b\u30af\u30ed\u30fc\u30e9\u30fc\u3067\u3059\u3002\nhentai\ncore.async\u306e\u30b5\u30f3\u30d7\u30eb\u3068\u3057\u3066\u306f\u306a\u304b\u306a\u304b\u826f\u3044\u30b5\u30f3\u30d7\u30eb\u3060\u3068\u601d\u3044\u307e\u3059\u3002\n\u4ed6\u306bclojure.tools.logging,\u30b3\u30de\u30f3\u30c9\u30e9\u30a4\u30f3\u306e\u30aa\u30d7\u30b7\u30e7\u30f3\u3092\u51e6\u7406\u3059\u308b clojure.tools.cli\u3082\u4f7f\u3063\u3066\u3044\u307e\u3059\u3002\n\u4ed6\u306b\u3082\u66f8\u304b\u308c\u3066\u3044\u308b\u65b9\u3082\u3044\u308b\u304b\u3068\u601d\u3044\u307e\u3059\u304c go\u30de\u30af\u30ed\u306fCPU\u6570 + 2 \u306e\u30b9\u30ec\u30c3\u30c9\u30d7\u30fc\u30eb\u3067\u51e6\u7406\u3092\u884c\u3044\u307e\u3059\u3002\u305d\u306e\u305f\u3081\u3001\u30ac\u30f3\u30ac\u30f3 go\u30de\u30af\u30ed\u3092\u4f7f\u3063\u3066\u3082\u4e26\u5217\u6570\u306f\u4e00\u5b9a\u306b\u306a\u308a\u307e\u3059\u3002\n\u4e26\u5217\u6570\u3092\u5236\u9650\u3057\u305f\u304f\u306a\u3044\u5834\u5408\u306b\u306f thread \u30de\u30af\u30ed\u3092\u4f7f\u3046\u3068\u826f\u3044\u3067\u3057\u3087\u3046\u3002\n\u307e\u305fgo\u30de\u30af\u30ed\u5185\u3067\u4f8b\u5916\u304c\u767a\u751f\u3057\u3066\u3082\u63e1\u308a\u3064\u3076\u3055\u308c\u3066\u3057\u307e\u3046\u306e\u3067\u5fc5\u305a\u30ad\u30e3\u30c3\u30c1\u3057\u3066channel\u306a\u3069\u3092\u4f7f\u3063\u3066\u77e5\u3089\u305b\u308b\u3088\u3046\u306b\u3059\u308b\u3079\u304d\u3067\u3059\u3002\n\u3068\u3044\u3046\u308f\u3051\u3067\u7279\u306b\u30cd\u30bf\u304c\u306a\u3044\u306e\u3067\u904e\u53bb\u306e\u30cd\u30bf\u3092\u4f7f\u3044\u307e\u308f\u3057\u305f\u3068\u3044\u3046\u8a71\u3067\u3057\u305f\u3002\n# Clojure \u3067\u5b9f\u7528\u7684\u306a\u30d7\u30ed\u30b0\u30e9\u30e0\u3092\u66f8\u304f\n\u3053\u3093\u306b\u3061\u308f\u3001wozozo\u3067\u3059\u3002\n\u6700\u8fd1\u3001netty 4\u30d9\u30fc\u30b9\u306e\u30d5\u30ec\u30fc\u30e0\u30ef\u30fc\u30af\u3092\u66f8\u3044\u3066\u308b\u306e\u3067\u3059\u304c\u3001\u901f\u5ea6\u554f\u984c\u3067\u307b\u307cJava\u3067\u66f8\u3044\u3066\u3057\u307e\u3044\u3001\u66f8\u304f\u3053\u3068\u304c\u306a\u304f\u306a\u3063\u305f\u306e\u3067\u904e\u53bb\u306b\u4f5c\u3063\u305f\u5b9f\u7528\u7684\u306a\u30d7\u30ed\u30b0\u30e9\u30e0\u306e\u8a71\u3092\u3057\u307e\u3059\u3002\n`algo.monads` \u306e\u8a71\u3067\u3082\u826f\u304b\u3063\u305f\u306e\u3067\u3059\u304c\u3001\u4ed6\u306b\u66f8\u304b\u308c\u308b\u65b9\u304c\u3044\u308b\u3067\u3057\u3087\u3046\u3002\n\u305f\u3076\u3093\u3053\u3093\u306a\u3093\u3092\u66f8\u304b\u308c\u308b\u3068\u601d\u3044\u307e\u3059\u3002\n\n```clj\n(ns cljinja.lexer\n  (:use\n    [clojure.algo.monads])\n  (:require \n    [clojure.string :as str])\n  (:import \n    [java.util.regex Pattern]))\n\n(def ^:dynamic *block-begin* \"{%\")\n(def ^:dynamic *block-end* \"%}\")\n(def ^:dynamic *variable-begin* \"{{\")\n(def ^:dynamic *variable-end* \"}}\")\n(def ^:dynamic *comment-begin* \"{#\")\n(def ^:dynamic *comment-end* \"#}\")\n\n;;\n;; Parsec\n;;\n\n(def ^:dynamic parser-m (state-t maybe-m))\n\n(defn- return [v]\n  (with-monad parser-m\n    (m-result v)))\n\n(defn- >>= [p f]\n  (with-monad parser-m\n    (m-bind p f)))\n\n(defn- >>== [p f]\n  (>>= p #(return (f %))))\n\n(defn- <$> [f p]\n  (>>= p #(return (f %))))\n\n(defn- >> [p1 p2]\n  (>>= p1 (fn [_] p2)))\n\n(defn- either [& parsers]\n  (apply (:m-plus parser-m) parsers))\n\n(def <|> either)\n\n(defmacro let-bind\n  \"Wraps body in `domonad' boilerplate\"\n  [& body]\n  `(domonad parser-m\n            ~@body))\n\n(defn- state [data pos line]\n  {:data data \n   :pos pos\n   :line line})\n\n(defn- inc-newline [line text]\n       (+ line (dec (count (str/split (if (char? text) (str text) text) #\"\\n\"))))) \n\n(defn- any-token [n] \n  (fn [{^String strn :data pos :pos line :line}]\n      (when-not (= \"\" strn)\n        (let [data (subs strn 0 n)\n              nline (inc-newline line data)]\n          [(state data pos line )\n           (state (subs strn n) (+ pos n) nline )]))))\n\n(defn- eof [{^String strn :data pos :pos line :line }]\n  (when (= \"\" strn)\n    [(state strn pos line )\n     (state strn pos line )]))\n\n(defn- nothing [{^String strn :data pos :pos line :line }]\n  [(state \"\" pos line) \n   (state strn pos line)])\n\n(defn- merge-state [x y]\n  (reduce (fn [{d1 :data :as m} {d2 :data :as n}] (assoc m :data (str d1 d2))) x y))\n\n(defn stringify [p]\n  (>>= p (fn [x] \n             (return \n               (if (vector? x)\n                 (merge-state (first x) (next x))\n                 x)))))\n\n(defn- satisfy [pred n]\n  (domonad parser-m\n           [c (any-token n) :when (pred (:data c))]\n      c))\n\n(defn- is-char [c]\n  (satisfy (partial = c) 1))\n\n(defn- not-char [c]\n  (satisfy (partial (comp not =) c) 1))\n\n(defn- is-str [st]\n  (satisfy (partial = st) (count st)))\n\n(defn- not-str [st]\n  (satisfy (partial (comp not =) st) (count st)))\n\n(defn- optional [p]\n  (either p nothing))\n\n(defn- option [default p]\n  (either p default))\n\n(defprotocol RegexParser\n  (regex [this]))\n\n(extend-protocol RegexParser\n  java.lang.String\n  (regex [this]\n    (let [re (re-pattern (str \"^(?:\" this \")\"))]\n      (regex re)))\n\n  java.util.regex.Pattern\n  (regex [re]\n    (fn [{^String strn :data pos :pos line :line}]\n      (let [m (re-find re strn)\n            v (if (vector? m) (first m) m)]\n        (when-not (or (nil? v))\n          (let [len (count v)\n                nstr (subs strn len)]\n              ; (println (format \"'%s'  '%s'  '%s'\" re strn nstr))\n              [(state v pos line)\n               (state nstr (+ pos len) (inc-newline line v))]))))))\n\n(defmacro string-p [^String target]\n  `(fn [{^String strn# :data pos# :pos line# :line}]\n     (when (.startsWith strn# ~target)\n       (let [len# (count ~target)\n             nstr# (subs strn# len#)]\n           [(state ~target pos# line#)\n            (state nstr# (+ pos# len#) (inc-newline line# ~target))]))))\n\n(defmacro not-string-p [^String target]\n  `(fn [{^String strn# :data pos# :pos line# :line}]\n     (when-not (.startsWith strn# ~target)\n       [(state strn# pos# line#) (state strn# pos# line#)])))\n\n(defn- concat% [x xs]\n  (let [coll (if (vector? x) x [x])\n        coll? (vector? xs)]\n    (if coll?\n      (into coll xs)\n      (if (= \"\" (:data xs))\n        x \n        (conj coll xs)))))\n\n(declare many1)\n\n(defn- many [parser]\n  (optional (many1 parser)))\n\n(defn- many1 [parser]\n  (let-bind [a parser\n             as (many parser)]\n             (concat% a as)))\n\n(def aspace (regex #\"[\\s\\r\\n]\"))\n(def spaces (regex #\"[\\s\\r\\n]+\"))\n(def spaces* (regex #\"[\\s\\r\\n]*\"))\n\n(defn- white-space [p]\n  (>> spaces p))\n\n(defn- lexeme [p]\n  (let-bind [a p _ spaces] a))\n\n(defn- lexeme* [p]\n  (let-bind [a p _ spaces*] a))\n\n(defn- between [open close p]\n  (let-bind [_ open\n             x p\n             _ close]\n            x))\n\n(defn sep-by-1 [p sep]\n  (let-bind [x p\n             xs (many (>> sep p))]\n            (concat% x xs)))\n\n(defmacro surround [st#]\n  (stringify\n    (between \n      (is-char st#)\n      (is-char st#)\n      (many (not-str st#)))))\n  \n(defn- parse [parser input]\n  (parser (state input 0 1)))\n\n;; \n;; Rule \n;; \n\n(def ^:private sp-chars #\"([\\\\\\\\*+\\\\[\\\\](){}\\\\$.?\\\\^|])\")\n\n(defn- escape-regex [in]\n  (str/replace in sp-chars \"\\\\\\\\$1\"))\n\n(defn- build-regex [args]\n  (str/join \"|\" (map escape-regex args)))\n\n(defn- create-regex [tags]\n  (Pattern/compile (str \"^(.*?)(\" (build-regex tags) \")\") Pattern/DOTALL))\n\n(defn- text-data-p [regex]\n  (fn [{^String strn :data pos :pos line :line }]\n    (let [found (re-find (re-matcher (create-regex regex) strn))\n          [pair text token] (or found [nil nil nil])]\n      (when (and token (not= token pair))\n        (let [len (count text)\n              nstr (.substring strn (- (.length pair) (.length token)))]\n          [(state text pos line)\n           (state nstr (+ pos len) (inc-newline line text) )]))))) \n\n(defmacro token [nm]\n  (let [nm# nm]\n    `(fn [{^String strn# :data pos# :pos line# :line }]\n       {:data strn#\n       :pos pos#\n       :line line#\n       :type ~nm#})))\n\n(def op-array [\n               \"+\" :add\n               \"-\" :sub\n               \"/\" :div\n               \"//\" :floordiv\n               \"*\" :mul\n               \"%\" :mod\n               \"**\" :pow\n               \"~\" :tilde\n               ; \"[\" :lbracket\n               ; \"]\" :rbracket\n               ; \"(\" :lparen\n               ; \")\" :rparen\n               ; \"{\" :lbrace\n               ; \"}\" :rbrace\n               \"==\" :eq\n               \"!=\" :ne\n               \">\" :gt\n               \">=\" :gtEQ\n               \"<\" :lt\n               \"<=\" :ltEQ\n               \"=\" :assign\n               \".\" :dot\n               \":\" :colon\n               \"|\" :pipe\n               \",\" :comma\n               \";\" :semicolon])\n\n(def operators (apply array-map op-array))\n\n(defmacro operators-p []\n  (let [re (build-regex (keys operators))]\n    `(<$> (fn [{^String strn# :data pos# :pos line# :line }]\n              {:data strn#\n              :pos pos#\n              :line line#\n              :type (get operators strn#)})\n        (regex (str \"(\" ~re \")\")))))\n\n(def string-literal\n  (<$> (token :string)\n     (<|> (surround \"'\")\n          (surround \"\\\"\"))))\n\n(def name-p\n  (<$> (token :name)\n       (regex \"[a-zA-Z_][a-zA-Z0-9_-]*\")))\n\n(def integer-p\n  (<$> (token :integer)\n       (regex \"\\\\d+\")))\n\n(def float-p\n  (<$> (token :float)\n       (regex \"\\\\d+\\\\.\\\\d+\")))\n\n(def ident \n   (<|> string-literal name-p float-p integer-p (operators-p)))\n\n(def text-block\n  (<$> (token :data)\n       (text-data-p [*variable-begin* *block-begin* *comment-begin* *variable-end* *block-end* *comment-end*])))\n\n(def rest-text\n  (<$> (token :data) \n       (fn [{^String strn :data pos :pos line :line }]\n           [(state strn pos line )\n            (state \"\" pos line )])))\n\n(def block-begin-p\n  (<$> (token :block-begin)\n       (lexeme* (is-str *block-begin*))))\n\n(def block-end-p\n  (<$> (token :block-end)\n       (>> spaces* (is-str *block-end*))))\n\n(def variable-begin-p\n  (<$> (token :v-begin)\n       (lexeme* (is-str *variable-begin*))))\n\n(def variable-end-p\n  (<$> (token :v-end)\n       (>> spaces* (is-str *variable-end*))))\n\n(defn- fail-state [{^String strn :data pos :pos line :line }]\n  [{:state :fail :data strn :pos pos :line line}\n   (state strn pos line)])\n\n(defmacro make-block [begin end gurad]\n  `(let-bind [b# ~begin \n              x# (sep-by-1 (>> ~gurad ident) spaces)\n              e# (option fail-state ~end)]\n             (if (= :fail (:state e#))\n               (throw (Exception. (format \"Template Syntax Error:%s\" e#)))\n               (concat% (concat% b# x#) e#))))\n\n(def block-block \n     (make-block \n       block-begin-p block-end-p (not-string-p *block-end* )))\n\n(def variable-block \n     (make-block \n       variable-begin-p variable-end-p (not-string-p *variable-end*)))\n\n(def blocks \n     (many1 (<|> block-block  variable-block text-block)))\n\n(def rule\n  (let-bind [c blocks \n             cs rest-text]\n            (concat% c cs)))\n\n(defn- lex- [rule input]\n  (first (parse rule input)))\n\n(defn lex [input]\n  (lex- rule input))\n\n(def input \"{% extends 'hoge.html' %}\n            test\n            {% for item in items %}\n            {{ item }}\n            {% endfor %}\n            \")\n(lex- rule input)\n```\n\n# \u672c\u984c\n\n\u3068\u3044\u3046\u308f\u3051\u3067\u672c\u984c\n\n## \u5b9f\u7528\u7684\u306a\u30d7\u30ed\u30b0\u30e9\u30e0\uff1f\u30af\u30ed\u30fc\u30e9\u30fc\u3060\u308d\uff01\n\u3068\u3044\u3046\u308f\u3051\u3067 Clojure \u3067\u30af\u30ed\u30fc\u30e9\u30fc\u3092\u66f8\u3044\u3066\u307f\u305f\u306e\u3092\u516c\u958b\u3057\u3066\u3044\u307e\u3059\u3002\n[2ch \u30af\u30ed\u30fc\u30e9\u30fc] (https://github.com/mopemope/clj-crawler \"clj-crawler\")\n\n\u5143\u3005\u3001PostgreSQL\u306e\u5168\u6587\u691c\u7d22\u306e\u8a55\u4fa1\u3092\u884c\u3046\u305f\u3081\u306b\u3001\u65e5\u672c\u8a9e\u30c7\u30fc\u30bf\u3092\u304b\u304d\u96c6\u3081\u308b\u305f\u3081\u306b\u66f8\u3044\u305f\u3082\u306e\u3067\u3059\u3002\n\u57fa\u672c\u7684\u306b\u30ad\u30e3\u30c3\u30b7\u30e5\u30b5\u30fc\u30d0\u30fc\u304b\u3089\u306e\u53d6\u5f97\u3067\u3059\u3002\n\n\u666e\u901a\u306b\u66f8\u3044\u3066\u308b\u3068\u30d0\u30fc\u30dc\u30f3\u30cf\u30a6\u30b9\u884c\u304d\u306b\u306a\u308b\u305f\u3081\u4e26\u5217\u6570\u3092\u5236\u9650\u3059\u308b\u5de5\u592b\u304c\u5165\u3063\u3066\u3044\u307e\u3059\u3002\nClojure\u306efuture\u30de\u30af\u30ed\u306fExecutors.newCachedThreadPool\u3067\u4f5c\u3089\u308c\u305fExecutorService\u3092\u4f7f\u3044\u307e\u3059\u3002\n\u305d\u306e\u305f\u3081future\u3092\u4f7f\u3046\u3068\u30d0\u30f3\u30d0\u30f3Thread\u304c\u4f5c\u3089\u308c\u3001\u4e26\u5217\u6570\u306f\u5236\u5fa1\u3067\u304d\u307e\u305b\u3093\u3002\n\u305d\u3053\u3067\u30ad\u30e5\u30fc\u306b\u8caf\u3081\u3066\u3001\u5fc5\u8981\u306a\u6570\u3060\u3051\u30ef\u30fc\u30ab\u30fc\u3092\u8d70\u3089\u305b\u308b\u3088\u3046\u306b\u306a\u3063\u3066\u3044\u307e\u3059\u3002\n\n```clj\n\n(def ^:dynamic *sleep-time* 5000)\n\n(defn dequeue! [queue]\n  (loop []\n    (let [q @queue\n          value (first q)\n          nq (next q)]\n      (if (compare-and-set! queue q nq)\n        value\n        (recur)))))\n\n(defn- make-worker [f]\n  (let [worker-fn f]\n   (fn [q] \n      (when-let [val (dequeue! q)]\n        (try\n          (debug (format \"start call worker val:%s\" val))\n          (worker-fn val)\n          (debug (format \"end call worker val:%s remain:%s\" val (count @q)))\n          (catch Exception e (error e)))\n        (debug (format \"wait:%s ... \" *sleep-time*))\n        (Thread/sleep *sleep-time*)\n        (recur q)))))\n\n(defn start-worker [q f nthread]\n  (let [p (promise)\n        cnt (atom nthread)]\n    (dotimes [i nthread]\n      (future \n        ((make-worker f) q)\n        (if (= 0 (swap! cnt dec))\n          (deliver p \"OK\"))))\n    p))\n\n```\n\u554f\u984c\u306f\u4e26\u5217\u306b\u30ad\u30e5\u30fc\u306b\u5024\u3092\u7a81\u3063\u8fbc\u3093\u3060\u308a\u3001\u51fa\u3057\u305f\u308a\u3059\u308b\u308f\u3051\u3067\u305d\u3053\u3092\u3069\u3046\u5b9f\u88c5\u3059\u308b\u304b\u3063\u3066\u3068\u3053\u3067\u3059\u3002\n\u3042\u307e\u308a\u4f7f\u308f\u308c\u3066\u308b\u306e\u3092\u898b\u305f\u3053\u3068\u304c\u306a\u3044\u306e\u3067\u3059\u304c`compare-and-set!`\u3067\u5024\u3092\u6bd4\u8f03\u3001\u554f\u984c\u306a\u3051\u308c\u3070\u5024\u3092\u8fd4\u3057\u3066\u3044\u307e\u3059\u3002\u5931\u6557\uff08\u3053\u306e\u9593\u306b\u5225 Thread \u306b\u3088\u3063\u3066\u5024\u304c\u5909\u308f\u3063\u305f\uff09\u5834\u5408\u306b\u306f\u30ea\u30c8\u30e9\u30a4\u3057\u3066\u3044\u307e\u3059\u3002\n\u3044\u308f\u3086\u308bCAS\u3067\u3059\u306d\u3002\n\u30b9\u30af\u30ec\u30a4\u30d4\u30f3\u30b0\u3001\u30c7\u30fc\u30bf\u30d9\u30fc\u30b9\u30a2\u30af\u30bb\u30b9\u3001\u30b9\u30ec\u30c3\u30c9\u306a\u3069\u5b9a\u756a\u51e6\u7406\u304c\u5165\u3063\u3066\u308b\u306e\u3067\u826f\u3044\u30b5\u30f3\u30d7\u30eb\u3060\u3068\u601d\u3044\u307e\u3059\u3002\n\n## \u5b9f\u7528\u7684\u306a\u30d7\u30ed\u30b0\u30e9\u30e0\uff1f\u3084\u3063\u3071\u30af\u30ed\u30fc\u30e9\u30fc\u3060\u308d\uff01\n\u306f\u3044\u3001\u6b21\u3082\u3084\u306f\u308a\u30af\u30ed\u30fc\u30e9\u30fc\u3067\u3057\u3087\u3046\u304b\u3002\n\u5143\u3005\u306f`core.async`\u304c\u51fa\u305f\u3070\u3063\u304b\u306e\u9803\u306b\u8a66\u3057\u3066\u307f\u305f\u304f\u3066\u66f8\u3044\u305f\u3082\u306e\u3067\u3059\u3002\n\u5168\u90e8\u306f\u8a00\u3044\u307e\u305b\u3093\u304c\u3001\u8981\u306f\u5c0f\u3055\u306a\u56f3\u66f8\u9928\u3092\u4f5c\u308b\u30af\u30ed\u30fc\u30e9\u30fc\u3067\u3059\u3002\n[hentai] (https://bitbucket.org/hentai/clj-hentai \"clj-hentai\")\n\n`core.async`\u306e\u30b5\u30f3\u30d7\u30eb\u3068\u3057\u3066\u306f\u306a\u304b\u306a\u304b\u826f\u3044\u30b5\u30f3\u30d7\u30eb\u3060\u3068\u601d\u3044\u307e\u3059\u3002\n\u4ed6\u306b`clojure.tools.logging`,\u30b3\u30de\u30f3\u30c9\u30e9\u30a4\u30f3\u306e\u30aa\u30d7\u30b7\u30e7\u30f3\u3092\u51e6\u7406\u3059\u308b `clojure.tools.cli`\u3082\u4f7f\u3063\u3066\u3044\u307e\u3059\u3002\n\u4ed6\u306b\u3082\u66f8\u304b\u308c\u3066\u3044\u308b\u65b9\u3082\u3044\u308b\u304b\u3068\u601d\u3044\u307e\u3059\u304c `go`\u30de\u30af\u30ed\u306fCPU\u6570 + 2 \u306e\u30b9\u30ec\u30c3\u30c9\u30d7\u30fc\u30eb\u3067\u51e6\u7406\u3092\u884c\u3044\u307e\u3059\u3002\u305d\u306e\u305f\u3081\u3001\u30ac\u30f3\u30ac\u30f3 `go`\u30de\u30af\u30ed\u3092\u4f7f\u3063\u3066\u3082\u4e26\u5217\u6570\u306f\u4e00\u5b9a\u306b\u306a\u308a\u307e\u3059\u3002\n\u4e26\u5217\u6570\u3092\u5236\u9650\u3057\u305f\u304f\u306a\u3044\u5834\u5408\u306b\u306f `thread` \u30de\u30af\u30ed\u3092\u4f7f\u3046\u3068\u826f\u3044\u3067\u3057\u3087\u3046\u3002\n\u307e\u305f`go`\u30de\u30af\u30ed\u5185\u3067\u4f8b\u5916\u304c\u767a\u751f\u3057\u3066\u3082\u63e1\u308a\u3064\u3076\u3055\u308c\u3066\u3057\u307e\u3046\u306e\u3067\u5fc5\u305a\u30ad\u30e3\u30c3\u30c1\u3057\u3066channel\u306a\u3069\u3092\u4f7f\u3063\u3066\u77e5\u3089\u305b\u308b\u3088\u3046\u306b\u3059\u308b\u3079\u304d\u3067\u3059\u3002\n\n\u3068\u3044\u3046\u308f\u3051\u3067\u7279\u306b\u30cd\u30bf\u304c\u306a\u3044\u306e\u3067\u904e\u53bb\u306e\u30cd\u30bf\u3092\u4f7f\u3044\u307e\u308f\u3057\u305f\u3068\u3044\u3046\u8a71\u3067\u3057\u305f\u3002\n", "tags": ["Clojure"]}