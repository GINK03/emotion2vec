{"context": " More than 1 year has passed since last update.\u521d\u3081\u307e\u3057\u3066\u3001Google\u306eAngular Team\u306b\u50cd\u3044\u3066\u308b\u30d6\u30e9\u30a4\u30a2\u30f3\u3067\u3059\u3002\u3088\u308d\u3057\u304f\u304a\u9858\u3044\u3057\u307e\u3059\u3002\n\u50d5\u306f\u3042\u307e\u308a\u65e5\u672c\u8a9e\u304c\u5206\u304b\u3089\u306a\u3044\u3051\u3069\u3082\u3001\u65e5\u672c\u306e\u958b\u767a\u8005\u9054\u306e\u60c5\u71b1\u304c\u898b\u3048\u307e\u3059\u3002\u52c9\u5f37\u4f1a\u3068\u304b\u3001\u8a18\u4e8b\u3068\u304b\u3001\u30a4\u30d9\u30f3\u30c8\u304c\u305f\u304f\u3055\u3093\u3042\u308a\u307e\u3059\u306d\u3002\u65e5\u672c\u306eAngular\u306e\u30b3\u30df\u30e5\u30cb\u30c6\u30a3\u306f\u3059\u3054\u3044\u3068\u601d\u3044\u307e\u3059\u3002Angular 2\u3092\u4f7f\u3063\u3066\u304f\u308c\u308b\u3053\u3068\u306b\u697d\u3057\u307f\u306b\u3057\u3066\u3044\u307e\u3059\u3002\nWhen Okuno-san asked me to write an article, I thought for a while on what I could contribute. I wanted to write about my experiences working on Angular, especially what I've learned on the path from Angular 1 to Angular 2.\n\nThe power of declarative code\nIn my opinion, the most important aspect of Angular 1's template system is that it is declarative. The implication of being declarative is that you only have to describe what the end result of the template is.\nContrastingly, applications used to be written with one method to initialize the view, and several others to update it. Consider this code that you might see in a jQuery or Backbone-style application:\nfunction View(name) {\n  this.element = $('<div>Name: <span class=\"name\">' + name + '</span</div>');\n}\n\nView.prototype.addJob = function (newJob) {\n  this.element.append('Job: <span class=\"job\">' + newJob + '</span>');\n};\n\nView.prototype.updateJob = function (newJob) {\n  this.element.find('.job').html(newJob);\n};\n\nAlthough the above code might work fine initially, if the assumptions around it change, it might break. Consider:\n\nWhat happens if view.updateJob is called before view.addJob? We throw an error.\nWhat if you need to update the HTML of the view? All of the methods that touch the view must be updated.\nWhat happens if we want to update the name part of the view? We have to write additional code.\n\nIn each one of these cases, the developer must manually make changes that are error-prone. In contrast, the AngularJS 1 version of the above would be something like:\n<div>Name: {{name}} | Job: {{job}}</div>\n\nWith AngularJS, you write substantially less code, and the code is more flexible. We avoid duplication, and we can safely build upon existing code.\n\nFrom templates to components\nAlthough the declarative approach to templates eliminated one source of bugs, one thing that became apparent with Angular 1 was that the scoping model was confusing.\nConsider this code:\n<span>{{selectedItem}}</span>\n<ul>\n  <li ng-repeat=\"item in list\">\n    <a ng-click=\"selectedItem = item\">{{item}}</a>\n  </li>\n</ul>\n\nThe problem is that because ng-repeat introduces scopes, we don't know which scope selectedItem will be set on.\nFirst we introduced the controllerAs option to directives. In 1.4, we added bindToController to try to fix this problem without making breaking changes to Angular. But what we realized was that we needed to explicitly handle the relationship between parent and child components. In order to realize this idea, we had to make semantic changes to how scopes and directives work.\n\nManaging change\nWe often think about Angular as many lines of code, or as a set of features, or as an API. Each of these are useful lenses, but I think it's also important to think of Angular as a collection of ideas. As we work with Angular, our ideas improve. And that's where change comes from.\nIn the context of templates above, we see ideas that were both good (declarative), and problematic (inheriting template scope). We often think of \"Angular templates\" as one thing, but it's really the implementation of a set of ideas.\nThe art of framework development is in considering individual aspects of a system and trying them in different combination. What happens when we introduce an idea like \"one-way data-flow\" into Angular? What effect would immutable persistent data structures have? What about observables? Do observables and immutable data structs work together? What about with one-way data-flow?\nThis is not only the case for the template example, but really for every aspect of framework and application code.\n\nThe future of web development\nAs we've seen, the only constant in the web development world is change. ES6 (or ES2015 as some call it) introduces new language features. Tools like Babel and TypeScript come along and add new possibilities. Browsers add new features (like service workers), and JS engines are constantly adding new optimizations. This changes the performance characteristics of existing and new code. In turn, libraries and frameworks need to accommodate these changes, and improve to take advantage of new capabilities. The changes cascade to application code as well.\nThe best way to address these changes is to think critically about the code you write: identify patterns and ideas, notice when you encounter the same types of problems. What happens when you reify an idea into a framework-level abstraction? Does everything fit into such an abstraction? What are the costs? Can the idea replace an existing idea? Finally, we need more dialog about high-level ideas in web development. Write a blog post, or file a GitHub issue.\nFeel free to contact me even (\u65e5\u672c\u8a9e\u3067\u3082\u3044\u3044\u3060\u3088\uff01). I'm always eager for suggestions to improve Angular.\n\u521d\u3081\u307e\u3057\u3066\u3001Google\u306eAngular Team\u306b\u50cd\u3044\u3066\u308b\u30d6\u30e9\u30a4\u30a2\u30f3\u3067\u3059\u3002\u3088\u308d\u3057\u304f\u304a\u9858\u3044\u3057\u307e\u3059\u3002\n\n\u50d5\u306f\u3042\u307e\u308a\u65e5\u672c\u8a9e\u304c\u5206\u304b\u3089\u306a\u3044\u3051\u3069\u3082\u3001\u65e5\u672c\u306e\u958b\u767a\u8005\u9054\u306e\u60c5\u71b1\u304c\u898b\u3048\u307e\u3059\u3002\u52c9\u5f37\u4f1a\u3068\u304b\u3001\u8a18\u4e8b\u3068\u304b\u3001\u30a4\u30d9\u30f3\u30c8\u304c\u305f\u304f\u3055\u3093\u3042\u308a\u307e\u3059\u306d\u3002\u65e5\u672c\u306eAngular\u306e\u30b3\u30df\u30e5\u30cb\u30c6\u30a3\u306f\u3059\u3054\u3044\u3068\u601d\u3044\u307e\u3059\u3002Angular 2\u3092\u4f7f\u3063\u3066\u304f\u308c\u308b\u3053\u3068\u306b\u697d\u3057\u307f\u306b\u3057\u3066\u3044\u307e\u3059\u3002\n\nWhen Okuno-san asked me to write an article, I thought for a while on what I could contribute. I wanted to write about my experiences working on Angular, especially what I've learned on the path from Angular 1 to Angular 2.\n\n# The power of declarative code\n\nIn my opinion, the most important aspect of Angular 1's template system is that it is **declarative**. The implication of being declarative is that you only have to describe what the end result of the template is.\n\nContrastingly, applications used to be written with one method to initialize the view, and several others to update it. Consider this code that you might see in a jQuery or Backbone-style application:\n\n```js\nfunction View(name) {\n  this.element = $('<div>Name: <span class=\"name\">' + name + '</span</div>');\n}\n\nView.prototype.addJob = function (newJob) {\n  this.element.append('Job: <span class=\"job\">' + newJob + '</span>');\n};\n\nView.prototype.updateJob = function (newJob) {\n  this.element.find('.job').html(newJob);\n};\n```\n\nAlthough the above code might work fine initially, if the assumptions around it change, it might break. Consider:\n\n1. What happens if `view.updateJob` is called before `view.addJob`? We throw an error.\n2. What if you need to update the HTML of the view? All of the methods that touch the view must be updated.\n3. What happens if we want to update the `name` part of the view? We have to write additional code.\n\nIn each one of these cases, the developer must manually make changes that are error-prone. In contrast, the AngularJS 1 version of the above would be something like:\n\n```html\n<div>Name: {{name}} | Job: {{job}}</div>\n```\n\nWith AngularJS, you write substantially less code, and the code is more flexible. We avoid duplication, and we can safely build upon existing code.\n\n# From templates to components\n\nAlthough the declarative approach to templates eliminated one source of bugs, one thing that became apparent with Angular 1 was that the scoping model was confusing.\n\nConsider this code:\n\n```html\n<span>{{selectedItem}}</span>\n<ul>\n  <li ng-repeat=\"item in list\">\n    <a ng-click=\"selectedItem = item\">{{item}}</a>\n  </li>\n</ul>\n```\n\nThe problem is that because `ng-repeat` introduces scopes, we don't know which scope `selectedItem` will be set on.\n\nFirst we introduced the `controllerAs` option to directives. In 1.4, we added `bindToController` to try to fix this problem without making breaking changes to Angular. But what we realized was that we needed to explicitly handle the relationship between parent and child components. In order to realize this idea, we had to make semantic changes to how scopes and directives work.\n\n# Managing change\n\nWe often think about Angular as many lines of code, or as a set of features, or as an API. Each of these are useful lenses, but I think it's also important to think of Angular as a collection of ideas. As we work with Angular, our ideas improve. And that's where change comes from.\n\nIn the context of templates above, we see ideas that were both good (declarative), and problematic (inheriting template scope). We often think of \"Angular templates\" as one thing, but it's really the implementation of a set of ideas.\n\nThe art of framework development is in considering individual aspects of a system and trying them in different combination. What happens when we introduce an idea like \"one-way data-flow\" into Angular? What effect would immutable persistent data structures have? What about observables? Do observables and immutable data structs work together? What about with one-way data-flow?\n\nThis is not only the case for the template example, but really for every aspect of framework and application code.\n\n# The future of web development\n\nAs we've seen, the only constant in the web development world is change. ES6 (or ES2015 as some call it) introduces new language features. Tools like Babel and TypeScript come along and add new possibilities. Browsers add new features (like service workers), and JS engines are constantly adding new optimizations. This changes the performance characteristics of existing and new code. In turn, libraries and frameworks need to accommodate these changes, and improve to take advantage of new capabilities. The changes cascade to application code as well.\n\nThe best way to address these changes is to think critically about the code you write: identify patterns and ideas, notice when you encounter the same types of problems. What happens when you reify an idea into a framework-level abstraction? Does everything fit into such an abstraction? What are the costs? Can the idea replace an existing idea? Finally, we need more dialog about high-level ideas in web development. Write a blog post, or file a GitHub issue.\n\nFeel free to contact me even (\u65e5\u672c\u8a9e\u3067\u3082\u3044\u3044\u3060\u3088\uff01). I'm always eager for suggestions to improve Angular.\n", "tags": ["Angular2"]}