{"context": "\n\nIntroduction\n\nHow to exchange Realm data between watchOS and iOS.\nwatchOS 2 +, iOS 9 +, and Swift 3.\nI have released the code on GitHub as a sample project. Experience the speed.\n\nThis is the material presented at Next Inc., at 25th, Nov., 2016.\n\n\nAbout me\n\nI'm Yuta Hoshino, an iOS app developer from ge-nie inc.\nThe company developed ge-calc has been downloaded more than 720,000 units.\nI have published an UI library called \"SwiftyPickerPopover\" on Github. The library is for displaying Popover with Picker without UIPopoverController by a Swift line.\n\n\n\nBasic idea\n\nIn watchOS 1, iOS's Realm file was shared by watchOS.\nIn watchOS 2, two Realm files exist as separate entities.\nSo, let's synchronize the Realm files by fileTransfer().\n\n\n\nImplementation policy\n\nSave the text of iOS side textField to Realm each time it is changed.\nWhen changing, transfer the iOS's Realm file to watchOS side by fileTransfer () of WCSession.\nWhen it arrives, refresh the watchOS's Realm file, read the contents from it and display it on the watchOS's label.\n\n\n\nRun sample code\nSampleRealmOnWatchOS3\nhttps://github.com/hsylife/SampleRealmOnWatchOS3\nIn this sample, I also implemented a method to send data directly by sendMessage() for comparison of transfer speed.\n\nClone the repository on GitHub.\nTo import RealmSwift, launch Terminal and run pod install of CocoaPods.\nIf you want to check the operation with the simulator, keep running the scheme watchOS and run it. Start watchOS app at first.\nStart the iOS app.\nFollowing the steps displayed in the app, if you enter text in the iOS's textField, it will be reflected on watchOS side.\n\n\n\nIntroducing Realm with CocoaPods\nSince you want to use RealmSwift, with CocoaPods 1.0.0 and later, write a Podfile as follows.\ntarget 'SampleRealmOnWatchOS3' do\ndynamic frameworks\n  use_frameworks!\n  pod 'RealmSwift'\nend\n\ntarget 'SampleWatchApp_Extension' do\n  use_frameworks!\n  platform :watchos, '2.0'\n  pod 'RealmSwift'\nend\n\npost_install do |installer|\n  installer.pods_project.targets.each do |target|\n    target.build_configurations.each do |config|\n      config.build_settings['SWIFT_VERSION'] = '3.0'\n    end\n  end\nend\n\nIn the sample, SampleRealmOnWatchOS3 is the iOS's target name  andSampleWatchApp_Extension is watchOS's name.\nRun pod install from terminal and it is ready if it ends normally.\nNow you can import RealmSwift on both iOS / watchOS.\n\n\nShare the source file of Realm data model\nTo exchange data of Realm between iOS and watchOS, you want to share .swift file of data model. Take the following steps.\n\n1. Make the data model public for sharing.\n\nCreate a data model for iOS app target.\nFor the sample, I created Field.swift for the classField which describes the data model for the iOS's target SampleRealmOnWatchOS3.\n\n\nField.swift\nimport RealmSwift\n\npublic class Field: Object {\n    public dynamic var text: String?\n}\n\n\n\n\nThe access controls are specified as public.\nSince the iOS's target SampleRealmOnWatchOS3 and the watchOS's targetSampleWatchApp_Extension are separate modules, this specification allows you to share the source beyond that barrier.\n\n\n\n2. Add it to Compile Sources\n\nThe Swift file created in the above step belongs to the iOS's target SampleRealmOnWatchOS3.\nFor source sharing, assign the source to the watchOS's extension target SampleWatchApp_Extension.\n\n\n\nBoth iOS/watchOS app has the same source file and can use the data model.\n\n\n\nActivate WCSession\nTo exchange data between iOS and watchOS, use WCSession of WatchConnectivity framework.\nActivate the WCSession on iOS/watchOS.\n\n\nImplementation on the iOS side\n\nDeclare WCSessionDelegate because we want to use a delegate method that can get success and failure of activation.\n\nclass ViewController: UIViewController, WCSessionDelegate {\n\n\nDescribe the process to activate in viewDidLoad().\n\n\nViewController.swift\noverride func viewDidLoad() {\n     super.viewDidLoad()\n     if WCSession.isSupported() {\n         let session = WCSession.default()\n         session.delegate = self\n         session.activate()\n     }\n}\n\n\n\nYou can now activate the WCSession on startup. You also specified WCSessionDelegate, so it is ready for the delegte method to be called.\nSince iOS 9.3+ is required for session (_: activationDidCompleteWith: error :) which is called when activation is completed, if you want to target earlier (such as iOS 9.0), you must write @available (iOS 9.3 , *).\n\n\nViewController.swift\n@available(iOS 9.3, *)\n    func session(_ session: WCSession, activationDidCompleteWith activationState: WCSessionActivationState, error: Error?) {\n        print(\"activationDidComplete\")\n    }\n\n\n\nImplement watchOS side\n\nDeclare WCSessionDelegate like iOS side.\n\n\nInterfaceController.swift\nclass InterfaceController: WKInterfaceController, WCSessionDelegate {\n\n\n\nSince you want to process it at startup, we describe the process to activate in awake().\n\n\nInterfaceController.swift\noverride func awake(withContext context: Any?) {\n    super.awake(withContext: context)\n    if WCSession.isSupported() {\n      let session = WCSession.default()\n      session.delegate = self\n      session.activate()\n    }\n}\n\n\n\nAs before, session (_: activationDidCompleteWith: error :) requires watchOS 2.2 +. Write @available (watchOS 2.2, *).\n\n\nInterfaceController.swift\n@available(watchOS 2.2, *)\nfunc session(_ session: WCSession, activationDidCompleteWith activationState: WCSessionActivationState, error: Error?) {\n    print(\"activationDidComplete\")\n}\n\n\n\n\nSend the file\n\nAfter you activated the session, send the iOS's Realm file to watchOS side by using fileTransfer().\nWrite the transmission process at the necessary timing.\n\n\nViewController.swift\nif let path = Realm.Configuration().fileURL {\n    WCSession.default().transferFile(path, metadata: nil)\n}\n\n\n\nIn the sample, since you want to send every time when changing the textField, you send it at the realmTextFieldEditingChanged () action of the textField. In addition, write the same process  at iOS's viewDidLoad() in order to transmit once at startup.\nAlthough it is written to execute every time textField is edited, transferFile() may be executed frequently in a short time.\nAs described by \"those transfers happen opportunistically in the background.\" at the beginning of the official reference, transmission does not occur every time.\n\n\n\nReceiving Realm file\n\nThe file sent from iOS side is received by watchOS side.\nSince InterfaceController declares WCSessionDelegate as described above, you can use session (_ session: WCSession, didReceive file: WCSessionFile) which is its delegate method.\nSince it is called when a file is received, write processing to sequentially replace the Realm default file.\nIn the sample, the data is acquired after replacing the file. And it hands it to the UI system.\n\n\nInterfaceController.swift\nfunc session(_ session: WCSession, didReceive file: WCSessionFile) {\n  var config = Realm.Configuration()\n  config.fileURL = file.fileURL\n  Realm.Configuration.defaultConfiguration = config\n\n  let realm = try! Realm()\n  if let firstField = realm.objects(Field.self).first{\n    realmLabel.setText(firstField.text)\n  }\n}\n\n\n\nNow you can store the data in the Realm database each time the iOS side's textField changes. And it is possible to send the whole file from iOS side to watch OS side via WCSession transferFile. After replacing the Realm default file on the watchOS side that received this, it is possible to refresh the display system.\nI have published it on GitHub as Sample Project, so please check the whole thing again.\n\n\n\nComparison with sendMessage\n\nWhat we saw above was a way to send a Realm file using one of the background transfers provided by WCSesion transferFile().\nFor performance comparison, I also implemented the sample code about sendMessage() provided as a method of mutual messaging (Interactive messaging) in the sample.\nsendMessage() needs to be in the foreground state on watchOS side as described in this article. This is a method that can send it on the spot.\nThe flow of implementation is as follows.\n1 .. Activate WCSession.\n2 .. Execute transmission by letting sendMessage () have data in iOS side.\n\n\nViewController.swift\nfunc sendMessage(){\n        if WCSession.default().isReachable {\n            let applicationDict = [\"text\": messageTextField.text ?? \"\"]\n            WCSession.default().sendMessage(applicationDict,\n                                            replyHandler: { replyDict in print(replyDict) },\n                                            errorHandler: { error in print(error.localizedDescription)})\n        }\n\n    }\n\n\n3 .. Since watchOS side calls session (_ session: WCSession, didReceiveMessage message: [String: Any], replyHandler: @ escaping ([String: Any]) -> Void) of the WCSessionDelegate method, write the appropriate processing.\n\nInterfaceController.swift\n  func session(_ session: WCSession, didReceiveMessage message: [String : Any], replyHandler: @escaping ([String : Any]) -> Void) {\n\n        if let text = message[\"text\"] as! String?{\n            messageLabel.setText(text)\n        }\n\n        replyHandler([\"reply\" : \"OK\"])\n    }\n\n\n\nIn this case, it is an implementation that returns [\" reply \":\" OK \"] as replyHandler. Since this value is passed to sendMessage () 's replyHandler {} on ViewController.swift on the iOS side, the content of [\" reply \":\" OK \"] will be displayed on the debugger console on success.\n\n\n\nReverse data transmission\n\nWCSession supports not only iOS \u2192 watch OS but also data transmission of watchOS \u2192 iOS in the opposite direction. So you can support to iOS side to Realm changes on watchOS side.\n\n\n\nDoes the file transferred by transferFile () gather?\nQ: When file transfer is repeated between iOS-watchOS through transferFile(), will the files be accumulated?\nA: It will not accumulate.\nLet's check the folders actually after doing transferFile() several times.\n\nNot accumulated.\nAccording to the explanation of An Introduction to Watch Connectivity in watch OS 2, the transferred file is placed in the Document/Inbox folder of the transfer destination app. It is then deleted automatically when the delegate method returns.\nConversely, if you want to keep the file at the transfer destination, you must save it intentionally.\n#Introduction\n* How to exchange Realm data between watchOS and iOS.\n* watchOS 2 +, iOS 9 +, and Swift 3.\n* I have released the code on GitHub as a [sample project](https://github.com/hsylife/SampleRealmOnWatchOS3). Experience the speed.\n\nThis is the material presented at Next Inc., at 25th, Nov., 2016.\n\n---\n#About me\n* I'm Yuta Hoshino, an iOS app developer from ge-nie inc.\n* The company developed [ge-calc](https://itunes.apple.com/jp/app/memo-dian-zhuo-ge-calc-xiao/id388632863?mt=8) has been downloaded more than 720,000 units.\n* I have published an UI library called [\"SwiftyPickerPopover\"](https://github.com/hsylife/SwiftyPickerPopover) on Github. The library is for displaying Popover with Picker without UIPopoverController by a Swift line.\n\n---\n\n#Basic idea\n* In watchOS 1, iOS's Realm file was shared by watchOS.\n* In watchOS 2, two Realm files exist as separate entities.\n* So, let's synchronize the Realm files by `fileTransfer()`.\n\n---\n\n# Implementation policy\n1. Save the text of iOS side textField to Realm each time it is changed.\n2. When changing, transfer the iOS's Realm file to watchOS side by `fileTransfer ()` of WCSession.\n3. When it arrives, refresh the watchOS's Realm file, read the contents from it and display it on the watchOS's label.\n\n---\n\n#Run sample code\nSampleRealmOnWatchOS3\nhttps://github.com/hsylife/SampleRealmOnWatchOS3\n\nIn this sample, I also implemented a method to send data directly by `sendMessage()` for comparison of transfer speed.\n\n1. Clone the [repository](https://github.com/hsylife/SampleRealmOnWatchOS3) on GitHub.\n2. To import RealmSwift, launch Terminal and run `pod install` of CocoaPods.\n3. If you want to check the operation with the simulator, keep running the scheme watchOS and run it. Start watchOS app at first.\n4. Start the iOS app.\n5. Following the steps displayed in the app, if you enter text in the iOS's textField, it will be reflected on watchOS side.\n\n---\n\n#Introducing Realm with CocoaPods\n\nSince you want to use RealmSwift, with CocoaPods 1.0.0 and later, write a Podfile as follows.\n\n```.rb\ntarget 'SampleRealmOnWatchOS3' do\ndynamic frameworks\n  use_frameworks!\n  pod 'RealmSwift'\nend\n\ntarget 'SampleWatchApp_Extension' do\n  use_frameworks!\n  platform :watchos, '2.0'\n  pod 'RealmSwift'\nend\n\npost_install do |installer|\n  installer.pods_project.targets.each do |target|\n    target.build_configurations.each do |config|\n      config.build_settings['SWIFT_VERSION'] = '3.0'\n    end\n  end\nend\n```\n\nIn the sample, `SampleRealmOnWatchOS3` is the iOS's target name  and` SampleWatchApp_Extension` is watchOS's name.\n\nRun `pod install` from terminal and it is ready if it ends normally.\n\nNow you can import RealmSwift on both iOS / watchOS.\n\n---\n\n#Share the source file of Realm data model\n\nTo exchange data of Realm between iOS and watchOS, you want to share .swift file of data model. Take the following steps.\n\n##1. Make the data model public for sharing.\n\n* Create a data model for iOS app target.\n* For the sample, I created `Field.swift` for the class` Field` which describes the data model for the iOS's target `SampleRealmOnWatchOS3`.\n\n```Field.swift\nimport RealmSwift\n\npublic class Field: Object {\n    public dynamic var text: String?\n}\n\n```\n\n* The access controls are specified as `public`.\n* Since the iOS's target `SampleRealmOnWatchOS3` and the watchOS's target` SampleWatchApp_Extension` are separate modules, this specification allows you to share the source beyond that barrier.\n\n---\n##2. Add it to Compile Sources\n\n* The Swift file created in the above step belongs to the iOS's target `SampleRealmOnWatchOS3`.\n* For source sharing, assign the source to the watchOS's extension target `SampleWatchApp_Extension`.\n\n<img width=\"800\" alt=\"screenshot.png\" src=\"https://qiita-image-store.s3.amazonaws.com/0/84185/c9de0c1c-fa19-f2a8-e5a4-39e66e2590d9.png\">\n\n* Both iOS/watchOS app has the same source file and can use the data model.\n\n---\n\n#Activate WCSession\n\nTo exchange data between iOS and watchOS, use WCSession of WatchConnectivity framework.\n\nActivate the WCSession on iOS/watchOS.\n\n---\n\n#Implementation on the iOS side\n\n* Declare WCSessionDelegate because we want to use a delegate method that can get success and failure of activation.\n\n```.swift\nclass ViewController: UIViewController, WCSessionDelegate {\n```\n\n* Describe the process to activate in viewDidLoad().\n\n```ViewController.swift\noverride func viewDidLoad() {\n     super.viewDidLoad()\n     if WCSession.isSupported() {\n         let session = WCSession.default()\n         session.delegate = self\n         session.activate()\n     }\n}\n```\n\n* You can now activate the WCSession on startup. You also specified WCSessionDelegate, so it is ready for the delegte method to be called.\n* Since iOS 9.3+ is required for session (_: activationDidCompleteWith: error :) which is called when activation is completed, if you want to target earlier (such as iOS 9.0), you must write `@available (iOS 9.3 , *)`.\n\n```ViewController.swift\n@available(iOS 9.3, *)\n    func session(_ session: WCSession, activationDidCompleteWith activationState: WCSessionActivationState, error: Error?) {\n        print(\"activationDidComplete\")\n    }\n```\n\n---\n\nImplement watchOS side\n\n* Declare WCSessionDelegate like iOS side.\n\n```InterfaceController.swift\nclass InterfaceController: WKInterfaceController, WCSessionDelegate {\n```\n\n* Since you want to process it at startup, we describe the process to activate in `awake()`.\n\n```InterfaceController.swift\noverride func awake(withContext context: Any?) {\n    super.awake(withContext: context)\n    if WCSession.isSupported() {\n      let session = WCSession.default()\n      session.delegate = self\n      session.activate()\n    }\n}\n```\n\n* As before, [session (_: activationDidCompleteWith: error :)] (https://developer.apple.com/reference/watchconnectivity/wcsessiondelegate/1615679-session) requires watchOS 2.2 +. Write `@available (watchOS 2.2, *)`.\n\n```InterfaceController.swift\n@available(watchOS 2.2, *)\nfunc session(_ session: WCSession, activationDidCompleteWith activationState: WCSessionActivationState, error: Error?) {\n    print(\"activationDidComplete\")\n}\n```\n\n---\n#Send the file\n\n* After you activated the session, send the iOS's Realm file to watchOS side by using fileTransfer().\n\n* Write the transmission process at the necessary timing.\n\n```ViewController.swift\nif let path = Realm.Configuration().fileURL {\n    WCSession.default().transferFile(path, metadata: nil)\n}\n```\n\n* In the sample, since you want to send every time when changing the textField, you send it at the realmTextFieldEditingChanged () action of the textField. In addition, write the same process  at iOS's viewDidLoad() in order to transmit once at startup.\n\n* Although it is written to execute every time textField is edited, transferFile() may be executed frequently in a short time.\n\n* As described by \"those transfers happen opportunistically in the background.\" at [the beginning of the official reference](https://developer.apple.com/reference/watchconnectivity/wcsession), transmission does not occur every time.\n\n---\n\n#Receiving Realm file\n\n* The file sent from iOS side is received by watchOS side.\n* Since InterfaceController declares WCSessionDelegate as described above, you can use session (_ session: WCSession, didReceive file: WCSessionFile) which is its delegate method.\n* Since it is called when a file is received, write processing to sequentially replace the Realm default file.\n* In the sample, the data is acquired after replacing the file. And it hands it to the UI system.\n\n```InterfaceController.swift\nfunc session(_ session: WCSession, didReceive file: WCSessionFile) {\n  var config = Realm.Configuration()\n  config.fileURL = file.fileURL\n  Realm.Configuration.defaultConfiguration = config\n        \n  let realm = try! Realm()\n  if let firstField = realm.objects(Field.self).first{\n    realmLabel.setText(firstField.text)\n  }\n}\n```\n\n* Now you can store the data in the Realm database each time the iOS side's textField changes. And it is possible to send the whole file from iOS side to watch OS side via WCSession transferFile. After replacing the Realm default file on the watchOS side that received this, it is possible to refresh the display system.\n\n* I have published it on GitHub as [Sample Project] (https://github.com/hsylife/SampleRealmOnWatchOS 3), so please check the whole thing again.\n\n---\n\n#Comparison with sendMessage\n\n* What we saw above was a way to send a Realm file using one of the background transfers provided by WCSesion transferFile().\nFor performance comparison, I also implemented the sample code about sendMessage() provided as a method of mutual messaging (Interactive messaging) in the sample.\n\n* sendMessage() needs to be in the foreground state on watchOS side as described in [this article] (http://qiita.com/koogawa/items/b39e1419cbbcda8efc07). This is a method that can send it on the spot.\n\n* The flow of implementation is as follows.\n1 .. Activate WCSession.\n2 .. Execute transmission by letting sendMessage () have data in iOS side.\n\n```ViewController.swift\nfunc sendMessage(){\n        if WCSession.default().isReachable {\n            let applicationDict = [\"text\": messageTextField.text ?? \"\"]\n            WCSession.default().sendMessage(applicationDict,\n                                            replyHandler: { replyDict in print(replyDict) },\n                                            errorHandler: { error in print(error.localizedDescription)})\n        }\n\n    }\n```\n\n3 .. Since watchOS side calls `session (_ session: WCSession, didReceiveMessage message: [String: Any], replyHandler: @ escaping ([String: Any]) -> Void)` of the WCSessionDelegate method, write the appropriate processing.\n\n```InterfaceController.swift\n  func session(_ session: WCSession, didReceiveMessage message: [String : Any], replyHandler: @escaping ([String : Any]) -> Void) {\n        \n        if let text = message[\"text\"] as! String?{\n            messageLabel.setText(text)\n        }\n        \n        replyHandler([\"reply\" : \"OK\"])\n    }\n```\n\n* In this case, it is an implementation that returns `[\" reply \":\" OK \"]` as replyHandler. Since this value is passed to sendMessage () 's replyHandler {} on ViewController.swift on the iOS side, the content of `[\" reply \":\" OK \"]` will be displayed on the debugger console on success.\n\n---\n#Reverse data transmission\n\n* WCSession supports not only iOS \u2192 watch OS but also data transmission of watchOS \u2192 iOS in the opposite direction. So you can support to iOS side to Realm changes on watchOS side.\n\n---\n#Does the file transferred by transferFile () gather?\n\nQ: When file transfer is repeated between iOS-watchOS through transferFile(), will the files be accumulated?\n\nA: It will not accumulate.\n\nLet's check the folders actually after doing transferFile() several times.\n\n<img width=\"299\" alt=\"screenshot.png\" src=\"https://qiita-image-store.s3.amazonaws.com/0/84185/30b757fa-b277-0884-732e-bc83dd23a68c.png\">\n\nNot accumulated.\n\nAccording to the explanation of [An Introduction to Watch Connectivity in watch OS 2] (http://www.techotopia.com/index.php/An_Introduction_to_Watch_Connectivity_in_watchOS_2), the transferred file is placed in the Document/Inbox folder of the transfer destination app. It is then deleted automatically when the delegate method returns.\n\nConversely, if you want to keep the file at the transfer destination, you must save it intentionally.\n", "tags": ["watchOS", "iOS", "Realm", "CocoaPods", "swift3"]}