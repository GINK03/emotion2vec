{"tags": ["PowerShell", "lisp"], "context": "PowerShell\u306e\u5f15\u6570\u306e\u533a\u5207\u308a\u306b\u306f\u7a7a\u767d\u304c\u4f7f\u308f\u308c\u308b\u3002\u307e\u305f\u3001PowerShell \u306f$args\u3068\u3044\u3046\u81ea\u52d5\u5909\u6570\u306b\u5f15\u6570\u306e\u914d\u5217\u304c\u683c\u7d0d\u3055\u308c\u308b\u3002\u305d\u306e\u305f\u3081\u4e0b\u8a18\u306e\u3088\u3046\u306b\u9069\u5f53\u306a\u95a2\u6570\u3092\u5b9a\u7fa9\u3059\u308b\u3068\u3001\u7a7a\u767d\u533a\u5207\u308a\u3067\u914d\u5217\u3092\u4f5c\u6210\u3067\u304d\u308b\u3002\nPS C:\\demo\\lisp_ps> filter : {$args}\nPS C:\\demo\\lisp_ps> (: 1 2 3) -join ', '\n1, 2, 3\n\n\u3064\u307e\u308a\u9811\u5f35\u308c\u3070\u3001PowerShell\u3067Lisp\u3063\u307d\u304f\u66f8\u3051\u308b\u306f\u305a\u3067\u3042\u308b\u3002\n\n\u7d50\u679c\n\u7d50\u679c\u3068\u3057\u3066\u306f\u3001\u8a55\u4fa1\u5668 lisp.ps1 \u3092\u8aad\u307f\u8fbc\u3093\u3060\u72b6\u614b\u3067\u3001lisp\u3063\u307d\u304f\u66f8\u3044\u305f\u30bd\u30fc\u30c8\u51e6\u7406 mergesort_lisp.ps1 \u304c\u52d5\u304f\u3002\nPS C:\\demo\\lisp_ps> powershell -v 3 -nologo\nPS C:\\demo\\lisp_ps> ls -name\nlisp.ps1\nmergesort_lisp.ps1\nPS C:\\demo\\lisp_ps> . .\\lisp.ps1\nPS C:\\demo\\lisp_ps> . .\\mergesort_lisp.ps1\n(1, (2, (3, (4, (5, (6, ))))))\n\n\nmergesort_lisp.ps1\n[string](lisp `\n    (: begin `\n        (: define mergesort (: lambda (: xs) `\n            (: mergeAll (: sequences xs))))`\n        `\n        (: define sequences (: lambda (: xs) `\n            (: cond `\n                (: eq? xs nil) nil `\n                $true (: cons `\n                        (: cons (: fst xs) nil) `\n                        (: sequences (: snd xs))))))`\n        `\n        (: define mergeAll (: lambda  (: xs) `\n            (: cond `\n                (: eq? xs nil) nil `\n                (: eq? (: snd xs) nil) (: fst xs)`\n                $true `\n                    (: mergeAll (: mergePairs xs)))))`\n        `\n        (: define mergePairs (: lambda (: xs)`\n            (: cond `\n                (: eq? xs nil) nil `\n                (: eq? (: snd xs) nil) xs `\n                $true (: cons `\n                        (: merge (: fst xs) (: fst (: snd xs))) `\n                        (: mergePairs (: snd (: snd xs)))))))`\n        `\n        (: define merge (: lambda (: xs ys)`\n            (: cond `\n                (: eq? xs nil) ys `\n                (: eq? ys nil) xs `\n                (: lt? (: fst xs) (: fst ys))`\n                    (: cons (: fst xs) (: merge (: snd xs) ys))`\n                $true `\n                    (: cons (: fst ys) (: merge xs (: snd ys))))))`\n        `\n        (: mergesort (: quote (: 5 4 3 1 2 6)))`\n    )`\n)\n\n\nlisp.ps1\n# Eval\n# ====\nfilter Invoke-Lisp ($Exp, $Env = (Get-LispBuiltInEnv))\n{\n    # Variable\n    if ($Exp -is [string]) {return (Select-LispEnv $Exp $Env)[$Exp]}\n\n    # Atom\n    if (-not (pear? $Exp)) {return $Exp}\n\n    $fst = Invoke-Lisp (fst $Exp) $Env\n    $snd = snd $Exp\n\n    # Syntax\n    if ($fst -is [ScriptBlock]) {return & $fst $snd $Env}\n\n    # Closure\n    if (Test-LispClosure $fst) {return Invoke-LispClosure $fst $snd $Env}\n\n    throw \"${Exp} \u3092\u8a55\u4fa1\u3067\u304d\u307e\u305b\u3093\u3002\"\n}\n\nSet-Alias lisp Invoke-Lisp\n\n# Pear\n# ====\nfilter Get-LispNil {''}\n\nfilter New-LispPear\n    ($Item1 = (Get-LispNil), $Item2 = (Get-LispNil))\n        {[Tuple]::Create($Item1, $Item2)}\n\nfilter Get-LispPearFirst\n    ([Parameter(ValueFromPipeline=$true)] $Pear)\n        {,$Pear.Item1}\n\nfilter Get-LispPearSecond\n    ([Parameter(ValueFromPipeline=$true)] $Pear)\n        {,$Pear.Item2}\n\nfilter Test-LispPear\n    ([Parameter(ValueFromPipeline=$true)] $InpuObject)\n        {$InpuObject -is [Object] -and $InpuObject.GetType().Name -eq 'Tuple`2'}\n\nfilter New-LispList {Add-LispList $args}\n\nfilter Add-LispList ($Item, $List = (Get-LispNil))\n{\n    if ($Item.Length -eq 0) {return $List}\n\n    ($Item.Length - 1)..0 |\n        % {$l = $List} {$l = New-LispPear $Item[$_] $l} {$l}\n}\n\nfilter ConvertFrom-LispList\n   ([Parameter(ValueFromPipeline=$true)] $Pear)\n        {for ($p = $Pear; pear? $p; $p = snd $p) {fst $p}}\n\nSet-Alias : New-LispList\nSet-Alias pear? Test-LispPear\nSet-Alias fst Get-LispPearFirst\nSet-Alias snd Get-LispPearSecond\n\n# Env\n# ===\nfilter Select-LispEnv ([string]$Keyword, $Env)\n{\n    for ($e = $Env; pear? $e; $e = snd $e)\n        {if ((fst $e).Contains($Keyword)) {return fst $e}}\n\n    throw \"${Keyword}\u304c\u5b9a\u7fa9\u3055\u308c\u305f\u74b0\u5883\u304c\u898b\u3064\u304b\u308a\u307e\u305b\u3093\u3002\"\n}\n\n# Closure\n# =======\nfilter New-LispClosure ($ParamList, $BodyList, $ParentEnv, $ScriptBlock)\n{\n    $o = [PSObject]$PSBoundParameters\n    $o | Add-Member -TypeName 'Lisp.Closure'\n    $o\n}\n\nfilter Test-LispClosure ($InputObject)\n    {$InputObject -is [PSCustomObject] -and $InputObject.PSTypeNames[0] -eq 'Lisp.Closure'}\n\nfilter Invoke-LispClosure ($Closure, $ArgPear, $Env)\n{\n    # eval argument list\n    $arg = $ArgPear | ConvertFrom-LispList | %{Invoke-Lisp $_ $Env}\n    if ($arg -isnot [Array]) {$arg = ,$arg}\n\n    # create new env\n    $bound = New-LispBoundParameters $Closure.ParamList (Add-LispList $arg)\n    $newEnv = New-LispPear $bound $Closure.ParentEnv\n\n    # eval\n    & $closure.ScriptBlock $closure.BodyList $newEnv\n}\n\nfilter New-LispBoundParameters ($ParamPear, $ArgPear)\n{\n    # init variable\n    $bound = @{}\n    $pPear = $ParamPear\n    $aPear = $ArgPear\n\n    # bound parameter\n    while ((pear? $pPear) -and (pear? $aPear))\n    {\n        $bound[(fst $pPear)] = fst $aPear\n        $pPear = snd $pPear\n        $aPear = snd $aPear\n    }\n\n    # wrong number of arguments\n    if (pear? $pPear)\n    {\n        $ps = ($pPear | ConvertFrom-LispList) -join ', '\n        throw \"${ps} \u306b\u5bfe\u5fdc\u3059\u308b\u5f15\u6570\u304c\u4e0d\u8db3\u3057\u3066\u3044\u307e\u3059\u3002\"\n    }\n\n    # rest argument\n    $bound['rest'] = $aPear\n\n    $bound\n}\n\n# Built In\n# ========\nfilter Get-LispBuiltInEnv\n{\n    $BuiltIn = @{}\n\n    # Variable\n    $BuiltIn += Get-LispBuiltInVariable\n\n    # Syntax\n    $BuiltIn += Get-LispBuiltInSyntax\n\n    # Closure\n    $BuiltIn += Get-LispBuiltInClosure\n\n    New-LispPear $BuiltIn\n}\n\nfilter Get-LispBuiltInVariable\n{\n        $BuiltIn = @{}\n\n        $BuiltIn.nil = Get-LispNil\n\n        $BuiltIn\n}\n\nfilter Get-LispBuiltInSyntax\n{\n    $BuiltIn = @{}\n\n    $BuiltIn.cond = {param($body, $Env)\n        $test, $list, $body = ($body | fst), ($body | snd | fst), ($body | snd | snd)\n        while (-not (Invoke-Lisp $test $Env))\n            {$test, $list, $body = ($body | fst), ($body | snd | fst), ($body | snd | snd)}\n        Invoke-Lisp $list $Env\n    }\n\n    $BuiltIn.define = {param($body, $Env)\n        $symbol = fst $body\n        $e = fst $Env\n        if ($e.Contains($symbol))\n            {throw \"${symbol}\u306f\u65e2\u306b\u5b9a\u7fa9\u3055\u308c\u3066\u3044\u307e\u3059\u3002\"}\n        $e[$symbol] = Invoke-Lisp ($body | snd | fst) $Env\n    }\n\n    $BuiltIn.lambda = {param($body, $Env)\n        New-LispClosure ($body | fst) ($body | snd | fst) $Env `\n            {param($bodyList, $newEnv) Invoke-Lisp $bodyList $newEnv}\n    }\n\n    $BuiltIn.begin = {param($body, $Env)\n        $r = Get-LispNil\n        for ($b = $body; pear? $b; $b = snd $b)\n            {$r = Invoke-Lisp (fst $b) $Env}\n        $r\n    }\n\n    $BuiltIn.quote = {param($body, $Env) fst $body}\n\n    $BuiltIn\n}\n\nfilter Get-LispBuiltInClosure\n{\n    $BuiltIn = @{}\n    $nil = Get-LispNil\n\n    filter fun ($Keyword, $ScriptBlock)\n        {$BuiltIn[$Keyword] = New-LispClosure $nil $nil $nil $ScriptBlock}\n\n    fun cons {New-LispPear $arg[0] $arg[1]}\n    fun fst {Get-LispPearFirst $arg[0]}\n    fun snd {Get-LispPearSecond $arg[0]}\n    fun eq? {$arg[0] -eq $arg[1]}\n    fun lt? {$arg[0] -lt $arg[1]}\n\n    $BuiltIn\n}\n\n\n\n\u53c2\u8003\n\n((Python\u3067) \u66f8\u304f (Lisp) \u30a4\u30f3\u30bf\u30d7\u30ea\u30bf)\n\nPowerShell\u306e\u5f15\u6570\u306e\u533a\u5207\u308a\u306b\u306f\u7a7a\u767d\u304c\u4f7f\u308f\u308c\u308b\u3002\u307e\u305f\u3001PowerShell \u306f`$args`\u3068\u3044\u3046\u81ea\u52d5\u5909\u6570\u306b\u5f15\u6570\u306e\u914d\u5217\u304c\u683c\u7d0d\u3055\u308c\u308b\u3002\u305d\u306e\u305f\u3081\u4e0b\u8a18\u306e\u3088\u3046\u306b\u9069\u5f53\u306a\u95a2\u6570\u3092\u5b9a\u7fa9\u3059\u308b\u3068\u3001\u7a7a\u767d\u533a\u5207\u308a\u3067\u914d\u5217\u3092\u4f5c\u6210\u3067\u304d\u308b\u3002\n\n```\nPS C:\\demo\\lisp_ps> filter : {$args}\nPS C:\\demo\\lisp_ps> (: 1 2 3) -join ', '\n1, 2, 3\n```\n\n\u3064\u307e\u308a\u9811\u5f35\u308c\u3070\u3001PowerShell\u3067Lisp\u3063\u307d\u304f\u66f8\u3051\u308b\u306f\u305a\u3067\u3042\u308b\u3002\n\n# \u7d50\u679c\n\n\u7d50\u679c\u3068\u3057\u3066\u306f\u3001\u8a55\u4fa1\u5668 [lisp.ps1](#lispps1) \u3092\u8aad\u307f\u8fbc\u3093\u3060\u72b6\u614b\u3067\u3001lisp\u3063\u307d\u304f\u66f8\u3044\u305f\u30bd\u30fc\u30c8\u51e6\u7406 [mergesort_lisp.ps1](#mergesort_lispps1) \u304c\u52d5\u304f\u3002\n\n```\nPS C:\\demo\\lisp_ps> powershell -v 3 -nologo\nPS C:\\demo\\lisp_ps> ls -name\nlisp.ps1\nmergesort_lisp.ps1\nPS C:\\demo\\lisp_ps> . .\\lisp.ps1\nPS C:\\demo\\lisp_ps> . .\\mergesort_lisp.ps1\n(1, (2, (3, (4, (5, (6, ))))))\n```\n\n\n# mergesort_lisp.ps1\n\n```.scm\n[string](lisp `\n    (: begin `\n        (: define mergesort (: lambda (: xs) `\n            (: mergeAll (: sequences xs))))`\n        `\n        (: define sequences (: lambda (: xs) `\n            (: cond `\n                (: eq? xs nil) nil `\n                $true (: cons `\n                        (: cons (: fst xs) nil) `\n                        (: sequences (: snd xs))))))`\n        `\n        (: define mergeAll (: lambda  (: xs) `\n            (: cond `\n                (: eq? xs nil) nil `\n                (: eq? (: snd xs) nil) (: fst xs)`\n                $true `\n                    (: mergeAll (: mergePairs xs)))))`\n        `\n        (: define mergePairs (: lambda (: xs)`\n            (: cond `\n                (: eq? xs nil) nil `\n                (: eq? (: snd xs) nil) xs `\n                $true (: cons `\n                        (: merge (: fst xs) (: fst (: snd xs))) `\n                        (: mergePairs (: snd (: snd xs)))))))`\n        `\n        (: define merge (: lambda (: xs ys)`\n            (: cond `\n                (: eq? xs nil) ys `\n                (: eq? ys nil) xs `\n                (: lt? (: fst xs) (: fst ys))`\n                    (: cons (: fst xs) (: merge (: snd xs) ys))`\n                $true `\n                    (: cons (: fst ys) (: merge xs (: snd ys))))))`\n        `\n        (: mergesort (: quote (: 5 4 3 1 2 6)))`\n    )`\n)\n```\n\n\n# lisp.ps1\n\n```.ps1\n# Eval\n# ====\nfilter Invoke-Lisp ($Exp, $Env = (Get-LispBuiltInEnv))\n{\n    # Variable\n    if ($Exp -is [string]) {return (Select-LispEnv $Exp $Env)[$Exp]}\n\n    # Atom\n    if (-not (pear? $Exp)) {return $Exp}\n\n    $fst = Invoke-Lisp (fst $Exp) $Env\n    $snd = snd $Exp\n\n    # Syntax\n    if ($fst -is [ScriptBlock]) {return & $fst $snd $Env}\n    \n    # Closure\n    if (Test-LispClosure $fst) {return Invoke-LispClosure $fst $snd $Env}\n\n    throw \"${Exp} \u3092\u8a55\u4fa1\u3067\u304d\u307e\u305b\u3093\u3002\"\n}\n\nSet-Alias lisp Invoke-Lisp\n\n# Pear\n# ====\nfilter Get-LispNil {''}\n\nfilter New-LispPear\n    ($Item1 = (Get-LispNil), $Item2 = (Get-LispNil))\n        {[Tuple]::Create($Item1, $Item2)}\n\nfilter Get-LispPearFirst\n    ([Parameter(ValueFromPipeline=$true)] $Pear)\n        {,$Pear.Item1}\n\nfilter Get-LispPearSecond\n    ([Parameter(ValueFromPipeline=$true)] $Pear)\n        {,$Pear.Item2}\n\nfilter Test-LispPear\n    ([Parameter(ValueFromPipeline=$true)] $InpuObject)\n        {$InpuObject -is [Object] -and $InpuObject.GetType().Name -eq 'Tuple`2'}\n\nfilter New-LispList {Add-LispList $args}\n\nfilter Add-LispList ($Item, $List = (Get-LispNil))\n{\n    if ($Item.Length -eq 0) {return $List}\n\n    ($Item.Length - 1)..0 |\n        % {$l = $List} {$l = New-LispPear $Item[$_] $l} {$l}\n}\n\nfilter ConvertFrom-LispList\n   ([Parameter(ValueFromPipeline=$true)] $Pear)\n        {for ($p = $Pear; pear? $p; $p = snd $p) {fst $p}}\n\nSet-Alias : New-LispList\nSet-Alias pear? Test-LispPear\nSet-Alias fst Get-LispPearFirst\nSet-Alias snd Get-LispPearSecond\n\n# Env\n# ===\nfilter Select-LispEnv ([string]$Keyword, $Env)\n{\n    for ($e = $Env; pear? $e; $e = snd $e)\n        {if ((fst $e).Contains($Keyword)) {return fst $e}}\n\n    throw \"${Keyword}\u304c\u5b9a\u7fa9\u3055\u308c\u305f\u74b0\u5883\u304c\u898b\u3064\u304b\u308a\u307e\u305b\u3093\u3002\"\n}\n\n# Closure\n# =======\nfilter New-LispClosure ($ParamList, $BodyList, $ParentEnv, $ScriptBlock)\n{\n    $o = [PSObject]$PSBoundParameters\n    $o | Add-Member -TypeName 'Lisp.Closure'\n    $o\n}\n\nfilter Test-LispClosure ($InputObject)\n    {$InputObject -is [PSCustomObject] -and $InputObject.PSTypeNames[0] -eq 'Lisp.Closure'}\n\nfilter Invoke-LispClosure ($Closure, $ArgPear, $Env)\n{\n    # eval argument list\n    $arg = $ArgPear | ConvertFrom-LispList | %{Invoke-Lisp $_ $Env}\n    if ($arg -isnot [Array]) {$arg = ,$arg}\n\n    # create new env\n    $bound = New-LispBoundParameters $Closure.ParamList (Add-LispList $arg)\n    $newEnv = New-LispPear $bound $Closure.ParentEnv\n\n    # eval\n    & $closure.ScriptBlock $closure.BodyList $newEnv\n}\n\nfilter New-LispBoundParameters ($ParamPear, $ArgPear)\n{\n    # init variable\n    $bound = @{}\n    $pPear = $ParamPear\n    $aPear = $ArgPear\n\n    # bound parameter\n    while ((pear? $pPear) -and (pear? $aPear))\n    {\n        $bound[(fst $pPear)] = fst $aPear\n        $pPear = snd $pPear\n        $aPear = snd $aPear\n    }\n\n    # wrong number of arguments\n    if (pear? $pPear)\n    {\n        $ps = ($pPear | ConvertFrom-LispList) -join ', '\n        throw \"${ps} \u306b\u5bfe\u5fdc\u3059\u308b\u5f15\u6570\u304c\u4e0d\u8db3\u3057\u3066\u3044\u307e\u3059\u3002\"\n    }\n    \n    # rest argument\n    $bound['rest'] = $aPear\n\n    $bound\n}\n\n# Built In\n# ========\nfilter Get-LispBuiltInEnv\n{\n    $BuiltIn = @{}\n\n    # Variable\n    $BuiltIn += Get-LispBuiltInVariable\n\n    # Syntax\n    $BuiltIn += Get-LispBuiltInSyntax\n\n    # Closure\n    $BuiltIn += Get-LispBuiltInClosure\n\n    New-LispPear $BuiltIn\n}\n\nfilter Get-LispBuiltInVariable\n{\n        $BuiltIn = @{}\n\n        $BuiltIn.nil = Get-LispNil\n\n        $BuiltIn\n}\n\nfilter Get-LispBuiltInSyntax\n{\n    $BuiltIn = @{}\n\n    $BuiltIn.cond = {param($body, $Env)\n        $test, $list, $body = ($body | fst), ($body | snd | fst), ($body | snd | snd)\n        while (-not (Invoke-Lisp $test $Env))\n            {$test, $list, $body = ($body | fst), ($body | snd | fst), ($body | snd | snd)}\n        Invoke-Lisp $list $Env\n    }\n\n    $BuiltIn.define = {param($body, $Env)\n        $symbol = fst $body\n        $e = fst $Env\n        if ($e.Contains($symbol))\n            {throw \"${symbol}\u306f\u65e2\u306b\u5b9a\u7fa9\u3055\u308c\u3066\u3044\u307e\u3059\u3002\"}\n        $e[$symbol] = Invoke-Lisp ($body | snd | fst) $Env\n    }\n\n    $BuiltIn.lambda = {param($body, $Env)\n        New-LispClosure ($body | fst) ($body | snd | fst) $Env `\n            {param($bodyList, $newEnv) Invoke-Lisp $bodyList $newEnv}\n    }\n\n    $BuiltIn.begin = {param($body, $Env)\n        $r = Get-LispNil\n        for ($b = $body; pear? $b; $b = snd $b)\n            {$r = Invoke-Lisp (fst $b) $Env}\n        $r\n    }\n\n    $BuiltIn.quote = {param($body, $Env) fst $body}\n\n    $BuiltIn\n}\n\nfilter Get-LispBuiltInClosure\n{\n    $BuiltIn = @{}\n    $nil = Get-LispNil\n\n    filter fun ($Keyword, $ScriptBlock)\n        {$BuiltIn[$Keyword] = New-LispClosure $nil $nil $nil $ScriptBlock}\n\n    fun cons {New-LispPear $arg[0] $arg[1]}\n    fun fst {Get-LispPearFirst $arg[0]}\n    fun snd {Get-LispPearSecond $arg[0]}\n    fun eq? {$arg[0] -eq $arg[1]}\n    fun lt? {$arg[0] -lt $arg[1]}\n\n    $BuiltIn\n}\n\n```\n\n\n# \u53c2\u8003\n* [((Python\u3067) \u66f8\u304f (Lisp) \u30a4\u30f3\u30bf\u30d7\u30ea\u30bf)](http://www.aoky.net/articles/peter_norvig/lispy.htm)\n"}