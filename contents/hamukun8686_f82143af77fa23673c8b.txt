{"context": " More than 1 year has passed since last update.\u30cb\u30b3\u30cb\u30b3\u751f\u653e\u9001\u300c\u5bdd\u306a\u304c\u3089\u30e9\u30a4\u30d5\u30b2\u30fc\u30e0\u3064\u304f\u308b\u300d\u306b\u3066\n\n\nMain\n\n# include <Siv3D.hpp>\n\nvoid Main()\n{\n    const Point size = Window::Size();\n    Image image(size.x, size.y);\n    DynamicTexture tex;\n\n    std::array<std::vector<bool>, 2> worlds;\n    const int num = size.x*size.y;\n    worlds[0].resize(num);\n    worlds[1].resize(num);\n\n    std::array<Point, 8> neighbors = { { { -1, -1 }, { 0, -1 }, { 1, -1 }, { -1, 0 }, { 1, 0 }, { -1, 1 }, { 0, 1 }, { 1, 1 } } };\n    std::array<bool, 9> boneRule = { false, false, false, true, false, false, false, false, false };\n    std::array<bool, 9> surviveRule = { false, false, true, true, false, false, false, false, false };\n    std::array<std::array<bool, 9>, 2> rule = { boneRule, surviveRule };\n\n    while (System::Update())\n    {\n        if (Input::MouseL.clicked)\n            for (int y = 1; y < size.y - 1; ++y)\n                for (int x = 1; x < size.x - 1; ++x)\n                    worlds[0][y*size.x + x] = RandomBool(0.5);\n\n        //update\n        for (int y = 1; y < size.y - 1; ++y)\n            for (int x = 1; x < size.x - 1; ++x)\n                worlds[1][y*size.x + x] = rule[worlds[0][y*size.x + x]][std::count_if(neighbors.begin(), neighbors.end(), [&](const Point& v){return worlds[0][(v.y + y)*size.x + (v.x + x)]; })];\n\n        worlds[0].swap(worlds[1]);      \n\n        //draw\n        for (int y = 1; y < size.y - 1; ++y)\n            for (int x = 1; x < size.x - 1; ++x)\n                image[y][x] = ColorF(0.0, worlds[0][y*size.x + x], 0.0);\n\n        tex.tryFill(image);\n        tex.draw();\n    }\n}\n\n\n\n\u30cb\u30b3\u30cb\u30b3\u751f\u653e\u9001\u300c\u5bdd\u306a\u304c\u3089\u30e9\u30a4\u30d5\u30b2\u30fc\u30e0\u3064\u304f\u308b\u300d\u306b\u3066\n\n![20140909-034959-152.png](https://qiita-image-store.s3.amazonaws.com/0/34295/b97bf68b-735a-6355-a3e4-8b9456c10b88.png)\n\n```cpp:Main\n\n# include <Siv3D.hpp>\n\nvoid Main()\n{\n\tconst Point size = Window::Size();\n\tImage image(size.x, size.y);\n\tDynamicTexture tex;\n\n\tstd::array<std::vector<bool>, 2> worlds;\n\tconst int num = size.x*size.y;\n\tworlds[0].resize(num);\n\tworlds[1].resize(num);\n\n\tstd::array<Point, 8> neighbors = { { { -1, -1 }, { 0, -1 }, { 1, -1 }, { -1, 0 }, { 1, 0 }, { -1, 1 }, { 0, 1 }, { 1, 1 } } };\n\tstd::array<bool, 9> boneRule = { false, false, false, true, false, false, false, false, false };\n\tstd::array<bool, 9> surviveRule = { false, false, true, true, false, false, false, false, false };\n\tstd::array<std::array<bool, 9>, 2> rule = { boneRule, surviveRule };\n\t\n\twhile (System::Update())\n\t{\n\t\tif (Input::MouseL.clicked)\n\t\t\tfor (int y = 1; y < size.y - 1; ++y)\n\t\t\t\tfor (int x = 1; x < size.x - 1; ++x)\n\t\t\t\t\tworlds[0][y*size.x + x] = RandomBool(0.5);\n\n\t\t//update\n\t\tfor (int y = 1; y < size.y - 1; ++y)\n\t\t\tfor (int x = 1; x < size.x - 1; ++x)\n\t\t\t\tworlds[1][y*size.x + x] = rule[worlds[0][y*size.x + x]][std::count_if(neighbors.begin(), neighbors.end(), [&](const Point& v){return worlds[0][(v.y + y)*size.x + (v.x + x)]; })];\n\n\t\tworlds[0].swap(worlds[1]);\t\t\n\n\t\t//draw\n\t\tfor (int y = 1; y < size.y - 1; ++y)\n\t\t\tfor (int x = 1; x < size.x - 1; ++x)\n\t\t\t\timage[y][x] = ColorF(0.0, worlds[0][y*size.x + x], 0.0);\n\n\t\ttex.tryFill(image);\n\t\ttex.draw();\n\t}\n}\n\n```\n", "tags": ["Siv3DMay 2014"]}