{"tags": ["EC2", "Ruby", "aws-sdk"], "context": " More than 1 year has passed since last update.\n\naws-sdk ruby \u3067 EC2 instance  snapshot \u304b\u3089\u306e  \u5fa9\u5143\u3092\u81ea\u52d5\u5316\n\n \u6982\u8981\naws-sdk ruby \u3067 EC2 \u306e Instance \u306e  \u30b9\u30ca\u30c3\u30d7\u30b7\u30e7\u30c3\u30c8\u304b\u3089\u306e  \u5fa9\u5143\u3092\u81ea\u52d5\u5316\u3057\u307e\u3059\u3002\n\n \u3053\u306e\u8a18\u4e8b\u3092\u8aad\u3080\u524d\u306b\n\u624b\u52d5\u3067\u884c\u3063\u305f\u5834\u5408\u306e\u8a18\u4e8b\u304c\u4ee5\u4e0b\u306b\u306a\u308a\u307e\u3059\u3002\uff08\u53c2\u7167\u5148\u306f snapshot \u8fbc\uff09\n EC2 instance snapshot and restore\n\n \u524d\u63d0\u77e5\u8b58\n\n\u74b0\u5883\u5909\u6570\u306e\u8a2d\u5b9a\u306b\u306f dotenv \u3092\u5229\u7528\u3057\u307e\u3059\u3002\n\n\n\n Ruby | dotenv gem \u3067 \u74b0\u5883\u5909\u6570\u3092\u30b9\u30de\u30fc\u30c8\u306b\u7ba1\u7406\n\n\n\nAWS \u306e \u30ad\u30fc\u306e\u53d6\u5f97\u306b\u3064\u3044\u3066\u306f\u4e0b\u8a18\u3092\u53c2\u7167\n\n\n\n AWS-SDK Ruby \u3067 EC2 \u306e\u30a4\u30f3\u30b9\u30bf\u30f3\u30b9\u540d\u304b\u3089\u30a4\u30f3\u30b9\u30bf\u30f3\u30b9 id / ip address \u3092\u53d6\u5f97\u3059\u308b\n\n\n\n\n\n \u524d\u63d0\n\nSnapshot \u306e\u53d6\u5f97\u306f\u3001\u4e0b\u8a18\u8a18\u4e8b\u306e\u624b\u9806\u3067\u5b8c\u4e86\u6e08\u307f\u3068\u3059\u308b\n\n\n\n aws-sdk ruby \u3067 EC2 instance  snapshot \u306e\u53d6\u5f97\u3092\u81ea\u52d5\u5316\n\n\n\nInstance \u306f\u8d77\u52d5\u4e2d\u304b\u3064 1 \u3064\u306e Volume \u304c\u5272\u308a\u5f53\u3066\u6e08\u307f\n\n\n \u8a2d\u5b9a\u30d5\u30a1\u30a4\u30eb\n\n Gemfile \u306e\u8a2d\u5b9a\nsource \"https://rubygems.org\"\n\ngem \"dotenv\"\ngem \"aws-sdk\"\n\n\n .env \u30d5\u30a1\u30a4\u30eb\u306e\u8a2d\u5b9a\n\nAWS Management Console \u3067\u5fc5\u8981\u306a\u5024\u3092\u53d6\u5f97\u3057\u3001 .env \u30d5\u30a1\u30a4\u30eb\u306b\u8a2d\u5b9a\u3092\u3059\u308b\n\nACCESS_KEY_ID = \"your access key\"\nSECRET_ACCESS_KEY = \"your secret access key\"\nEC2_ENDPOINT = \"end point\"\n\n\n \u4e3b\u51e6\u7406\nrequire 'aws-sdk'\nrequire 'dotenv'\n\nclass RestoreExecutor\n  def initialize(instance_search_word , snapshot_search_word, device)\n    Dotenv.load\n    @ec2 = AWS::EC2.new(\n      access_key_id:     ENV[\"ACCESS_KEY_ID\"],\n      secret_access_key: ENV[\"SECRET_ACCESS_KEY\"],\n      ec2_endpoint:      ENV[\"EC2_ENDPOINT\"]\n    )\n    @snapshot_search_word = snapshot_search_word\n    @instance_search_word = instance_search_word\n    @device = device\n    @volume_name = \"#{snapshot_search_word} #{Time.now}\"\n  end\n\n  def restore\n    snapshot = find_snapshot\n    instance = find_instance\n    old_volume = old_volume(instance.instance_id)\n    new_volume = create_volume_from_snapshot(instance, old_volume, snapshot)\n    wait_until_status(new_volume, :available)\n    update_volume_name(new_volume)\n    wait_until_status(new_volume, :available)\n    instance.stop\n    wait_until_status(instance, :stopped)\n    old_volume.detach_from(instance, @device)\n    wait_until_status(old_volume, :available)\n    new_volume.attach_to(instance, @device)\n    wait_until_status(new_volume, :in_use)\n    instance.start\n    wait_until_status(instance, :running)\n    wait_until_system_check_complete(instance)\n  end\n\n  private\n\n  def find_snapshot\n    snapshots = @ec2.snapshots.select { |e|e.description  =~ /#{@snapshot_search_word}/ }\n    validate_existence_snapshot(snapshots)\n    choose_latest_snapshot(snapshots)\n  end\n\n  def find_instance\n    instances = @ec2.instances.select { |e|e.tags['Name'] =~ /#{@instance_search_word}/ }\n    validate_empty_instance(instances)\n    validate_too_many_instance(instances)\n    instances.first\n  end\n\n  def old_volume(instance_id)\n    @ec2.volumes.select { |e|e.attachments.to_a.size == 1}\n                .find { |e|e.attachments.first.instance.id == instance_id }\n  end\n\n  def create_volume_from_snapshot(instance, volume, snapshot)\n    options = {\n      snapshot_id: snapshot.id,\n      availability_zone: instance.availability_zone,\n      volume_type: volume.type\n    }\n    response = @ec2.client.create_volume(options)\n    new_volume(response.data[:volume_id])\n  end\n\n  def update_volume_name(volume)\n    volume.tag('Name', :value => @volume_name)\n  end\n\n  def wait_until_status(target, status)\n    print \"Waiting until #{status} #{Time.now}\"\n    loop {\n      break if [status, :error].include?(target.status)\n      sleep 1\n      print \".\"\n    }\n    puts\n    puts Time.now\n    puts\n  end\n\n  def wait_until_system_check_complete(instance)\n    print \"Waiting until system check #{Time.now}\"\n    loop {\n      response = @ec2.client.describe_instance_status({\"instance_ids\" => [instance.instance_id]})\n      statuses = response.instance_status_set.map { |i| i.system_status.details[0].status }\n      break unless statuses.include?('initializing')\n      sleep 1\n      print \".\"\n    }\n    puts\n    puts Time.now\n    puts\n  end\n\n  def validate_existence_snapshot(snapshots)\n    return unless snapshots.size.zero?\n    STDERR.puts (\"No snapshots. Confirm your snapshots search keyword '#{@snapshot_search_word}'.\")\n    exit(false)\n  end\n\n  def choose_latest_snapshot(snapshots)\n    snapshots.sort_by { |e|e.description }.last\n  end\n\n  def validate_empty_instance(instances)\n    return unless instances.empty?\n    STDERR.puts (\"No instance. Confirm your instance search keyword '#{@instance_search_word}'.\")\n    exit(false)\n  end\n\n  def validate_too_many_instance(instances)\n    return if instances.size < 2\n    STDERR.puts (\"Too many instance. Confirm your instance search keyword '#{@instance_search_word}'.\")\n    exit(false)\n  end\n\n  def new_volume(volume_id)\n    @ec2.volumes[volume_id]\n  end\nend\n\nse = RestoreExecutor.new('vagrant', 'test_snapshot_vagrant', '/dev/sda')\nse.restore\n\n\n \u7d50\u679c\u78ba\u8a8d\n\n\u5b9f\u884c\n\n$ ruby restore.rb\nWaiting until available 2015-01-14 22:01:14 +0900....\n2015-01-14 22:01:18 +0900\n\nWaiting until available 2015-01-14 22:01:18 +0900\n2015-01-14 22:01:18 +0900\n\nWaiting until stopped 2015-01-14 22:01:19 +0900..........................\n2015-01-14 22:01:47 +0900\n\nWaiting until available 2015-01-14 22:01:48 +0900.\n2015-01-14 22:01:49 +0900\n\nWaiting until in_use 2015-01-14 22:01:49 +0900\n2015-01-14 22:01:49 +0900\n\nWaiting until running 2015-01-14 22:01:50 +0900....................\n2015-01-14 22:02:12 +0900\n\nWaiting until system check 2015-01-14 22:02:12 +0900........................\n2015-01-14 22:10:12 +0900\n\n\n\u30d6\u30e9\u30a6\u30b6\u3067\u78ba\u8a8d\n\n\n\n \u88dc\u8db3\n\nvolume \u306e Name \u3067\u3059\u304c\u3001  EC2::Client#create_volume \u6642\u306b\u8a2d\u5b9a\u3059\u308b\u65b9\u6cd5\u304c\u5206\u304b\u3089\u306a\u304b\u3063\u305f\u306e\u3067\u3001\u65b0\u898f\u4f5c\u6210\u5f8c\u306b\u6539\u3081\u3066 Volume \u306b include \u3055\u308c\u3066\u3044\u308b TaggedItem#add_tag (tag) \u3067\u8a2d\u5b9a\u3057\u3066\u3044\u308b\n\n\n \u5916\u90e8\u8cc7\u6599\n\n\n AWS SDK for Ruby | API Document\n\n\n# aws-sdk ruby \u3067 EC2 instance :camera: snapshot \u304b\u3089\u306e :recycle: \u5fa9\u5143\u3092\u81ea\u52d5\u5316\n## :musical_score: \u6982\u8981\naws-sdk ruby \u3067 EC2 \u306e Instance \u306e :camera: \u30b9\u30ca\u30c3\u30d7\u30b7\u30e7\u30c3\u30c8\u304b\u3089\u306e :recycle: \u5fa9\u5143\u3092\u81ea\u52d5\u5316\u3057\u307e\u3059\u3002\n\n## :hand: \u3053\u306e\u8a18\u4e8b\u3092\u8aad\u3080\u524d\u306b\n\u624b\u52d5\u3067\u884c\u3063\u305f\u5834\u5408\u306e\u8a18\u4e8b\u304c\u4ee5\u4e0b\u306b\u306a\u308a\u307e\u3059\u3002\uff08\u53c2\u7167\u5148\u306f snapshot \u8fbc\uff09\n<i class=\"fa fa-external-link\" style=\"font-size:1em;\"></i> [EC2 instance snapshot and restore](http://qiita.com/tbpgr/items/2456a28506ec44d23a0a)\n\n\n## :musical_note: \u524d\u63d0\u77e5\u8b58\n* \u74b0\u5883\u5909\u6570\u306e\u8a2d\u5b9a\u306b\u306f dotenv \u3092\u5229\u7528\u3057\u307e\u3059\u3002\n    * <i class=\"fa fa-external-link-square\" style=\"font-size:1em;\"></i> [Ruby | dotenv gem \u3067 \u74b0\u5883\u5909\u6570\u3092\u30b9\u30de\u30fc\u30c8\u306b\u7ba1\u7406](http://qiita.com/tbpgr/items/b7126c3d2d8f0329b11c)\n* AWS \u306e \u30ad\u30fc\u306e\u53d6\u5f97\u306b\u3064\u3044\u3066\u306f\u4e0b\u8a18\u3092\u53c2\u7167\n    * <i class=\"fa fa-external-link-square\" style=\"font-size:1em;\"></i> [AWS-SDK Ruby \u3067 EC2 \u306e\u30a4\u30f3\u30b9\u30bf\u30f3\u30b9\u540d\u304b\u3089\u30a4\u30f3\u30b9\u30bf\u30f3\u30b9 id / ip address \u3092\u53d6\u5f97\u3059\u308b](http://qiita.com/tbpgr/items/580651b875ecdfdf0551)\n\n## :musical_note: \u524d\u63d0\n* Snapshot \u306e\u53d6\u5f97\u306f\u3001\u4e0b\u8a18\u8a18\u4e8b\u306e\u624b\u9806\u3067\u5b8c\u4e86\u6e08\u307f\u3068\u3059\u308b\n    * <i class=\"fa fa-external-link-square\" style=\"font-size:1em;\"></i> [aws-sdk ruby \u3067 EC2 instance :camera: snapshot \u306e\u53d6\u5f97\u3092\u81ea\u52d5\u5316](http://qiita.com/tbpgr/items/bc834c528c30a25bd556)\n* Instance \u306f\u8d77\u52d5\u4e2d\u304b\u3064 1 \u3064\u306e Volume \u304c\u5272\u308a\u5f53\u3066\u6e08\u307f\n\n## <i class=\"fa fa-gears\" style=\"font-size:1em;\"></i> \u8a2d\u5b9a\u30d5\u30a1\u30a4\u30eb\n### <i class=\"fa fa-gear\" style=\"font-size:1em;\"></i> Gemfile \u306e\u8a2d\u5b9a\n~~~\nsource \"https://rubygems.org\"\n\ngem \"dotenv\"\ngem \"aws-sdk\"\n~~~\n\n### <i class=\"fa fa-gear\" style=\"font-size:1em;\"></i> .env \u30d5\u30a1\u30a4\u30eb\u306e\u8a2d\u5b9a\n* AWS Management Console \u3067\u5fc5\u8981\u306a\u5024\u3092\u53d6\u5f97\u3057\u3001 .env \u30d5\u30a1\u30a4\u30eb\u306b\u8a2d\u5b9a\u3092\u3059\u308b\n\n~~~\nACCESS_KEY_ID = \"your access key\"\nSECRET_ACCESS_KEY = \"your secret access key\"\nEC2_ENDPOINT = \"end point\"\n~~~\n\n## <i class=\"fa fa-code\" style=\"font-size:1em;\"></i> \u4e3b\u51e6\u7406\n\n~~~ruby\nrequire 'aws-sdk'\nrequire 'dotenv'\n\nclass RestoreExecutor\n  def initialize(instance_search_word , snapshot_search_word, device)\n    Dotenv.load\n    @ec2 = AWS::EC2.new(\n      access_key_id:     ENV[\"ACCESS_KEY_ID\"],\n      secret_access_key: ENV[\"SECRET_ACCESS_KEY\"],\n      ec2_endpoint:      ENV[\"EC2_ENDPOINT\"]\n    )\n    @snapshot_search_word = snapshot_search_word\n    @instance_search_word = instance_search_word\n    @device = device\n    @volume_name = \"#{snapshot_search_word} #{Time.now}\"\n  end\n\n  def restore\n    snapshot = find_snapshot\n    instance = find_instance\n    old_volume = old_volume(instance.instance_id)\n    new_volume = create_volume_from_snapshot(instance, old_volume, snapshot)\n    wait_until_status(new_volume, :available)\n    update_volume_name(new_volume)\n    wait_until_status(new_volume, :available)\n    instance.stop\n    wait_until_status(instance, :stopped)\n    old_volume.detach_from(instance, @device)\n    wait_until_status(old_volume, :available)\n    new_volume.attach_to(instance, @device)\n    wait_until_status(new_volume, :in_use)\n    instance.start\n    wait_until_status(instance, :running)\n    wait_until_system_check_complete(instance)\n  end\n\n  private\n\n  def find_snapshot\n    snapshots = @ec2.snapshots.select { |e|e.description  =~ /#{@snapshot_search_word}/ }\n    validate_existence_snapshot(snapshots)\n    choose_latest_snapshot(snapshots)\n  end\n\n  def find_instance\n    instances = @ec2.instances.select { |e|e.tags['Name'] =~ /#{@instance_search_word}/ }\n    validate_empty_instance(instances)\n    validate_too_many_instance(instances)\n    instances.first\n  end\n\n  def old_volume(instance_id)\n    @ec2.volumes.select { |e|e.attachments.to_a.size == 1}\n                .find { |e|e.attachments.first.instance.id == instance_id }\n  end\n\n  def create_volume_from_snapshot(instance, volume, snapshot)\n    options = {\n      snapshot_id: snapshot.id,\n      availability_zone: instance.availability_zone,\n      volume_type: volume.type\n    }\n    response = @ec2.client.create_volume(options)\n    new_volume(response.data[:volume_id])\n  end\n\n  def update_volume_name(volume)\n    volume.tag('Name', :value => @volume_name)\n  end\n\n  def wait_until_status(target, status)\n    print \"Waiting until #{status} #{Time.now}\"\n    loop {\n      break if [status, :error].include?(target.status)\n      sleep 1\n      print \".\"\n    }\n    puts\n    puts Time.now\n    puts\n  end\n\n  def wait_until_system_check_complete(instance)\n    print \"Waiting until system check #{Time.now}\"\n    loop {\n      response = @ec2.client.describe_instance_status({\"instance_ids\" => [instance.instance_id]})\n      statuses = response.instance_status_set.map { |i| i.system_status.details[0].status }\n      break unless statuses.include?('initializing')\n      sleep 1\n      print \".\"\n    }\n    puts\n    puts Time.now\n    puts\n  end\n\n  def validate_existence_snapshot(snapshots)\n    return unless snapshots.size.zero?\n    STDERR.puts (\"No snapshots. Confirm your snapshots search keyword '#{@snapshot_search_word}'.\")\n    exit(false)\n  end\n\n  def choose_latest_snapshot(snapshots)\n    snapshots.sort_by { |e|e.description }.last\n  end\n\n  def validate_empty_instance(instances)\n    return unless instances.empty?\n    STDERR.puts (\"No instance. Confirm your instance search keyword '#{@instance_search_word}'.\")\n    exit(false)\n  end\n\n  def validate_too_many_instance(instances)\n    return if instances.size < 2\n    STDERR.puts (\"Too many instance. Confirm your instance search keyword '#{@instance_search_word}'.\")\n    exit(false)\n  end\n\n  def new_volume(volume_id)\n    @ec2.volumes[volume_id]\n  end\nend\n\nse = RestoreExecutor.new('vagrant', 'test_snapshot_vagrant', '/dev/sda')\nse.restore\n~~~\n\n## <i class=\"fa fa-check-circle\" style=\"font-size:1em;\"></i> \u7d50\u679c\u78ba\u8a8d\n\n* \u5b9f\u884c\n\n~~~bash\n$ ruby restore.rb\nWaiting until available 2015-01-14 22:01:14 +0900....\n2015-01-14 22:01:18 +0900\n\nWaiting until available 2015-01-14 22:01:18 +0900\n2015-01-14 22:01:18 +0900\n\nWaiting until stopped 2015-01-14 22:01:19 +0900..........................\n2015-01-14 22:01:47 +0900\n\nWaiting until available 2015-01-14 22:01:48 +0900.\n2015-01-14 22:01:49 +0900\n\nWaiting until in_use 2015-01-14 22:01:49 +0900\n2015-01-14 22:01:49 +0900\n\nWaiting until running 2015-01-14 22:01:50 +0900....................\n2015-01-14 22:02:12 +0900\n\nWaiting until system check 2015-01-14 22:02:12 +0900........................\n2015-01-14 22:10:12 +0900\n~~~\n\n* \u30d6\u30e9\u30a6\u30b6\u3067\u78ba\u8a8d\n\n![snap.png](https://qiita-image-store.s3.amazonaws.com/0/43480/06d44a91-5737-6188-4cb7-4822362d5e14.png)\n\n## :memo: \u88dc\u8db3\n* volume \u306e Name \u3067\u3059\u304c\u3001  EC2::Client#create_volume \u6642\u306b\u8a2d\u5b9a\u3059\u308b\u65b9\u6cd5\u304c\u5206\u304b\u3089\u306a\u304b\u3063\u305f\u306e\u3067\u3001\u65b0\u898f\u4f5c\u6210\u5f8c\u306b\u6539\u3081\u3066 Volume \u306b include \u3055\u308c\u3066\u3044\u308b TaggedItem#add_tag (tag) \u3067\u8a2d\u5b9a\u3057\u3066\u3044\u308b\n\n## :books: \u5916\u90e8\u8cc7\u6599\n* <i class=\"fa fa-external-link\" style=\"font-size:1em;\"></i> [AWS SDK for Ruby | API Document](http://docs.aws.amazon.com/AWSRubySDK/latest/frames.html)\n\n"}