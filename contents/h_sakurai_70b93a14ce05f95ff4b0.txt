{"context": " More than 1 year has passed since last update.\n\n\u306f\u3058\u3081\u306b\n\u4ee5\u524d\u3001Rust0.7\u3067\u30b3\u30f3\u30d1\u30a4\u30e9\u3092\u4f5c\u6210\u3057\u3066\u307f\u305f\u306e\u3067\u3059\u304c\u3001Rust0.11\u307e\u3067\u30d0\u30fc\u30b8\u30e7\u30f3\u304c\u4e0a\u304c\u308a\u3001\u52d5\u304b\u306a\u304f\u306a\u3063\u3066\u3057\u307e\u3044\u307e\u3057\u305f\u3002\u958b\u767a\u4e2d\u306e\u8a00\u8a9e\u306e\u5909\u66f4\u306a\u306e\u3067\u4ed5\u65b9\u306a\u3044\u306e\u3067\u3059\u304c\u3001Rust\u3092\u53c2\u8003\u306b\u3057\u305f\u3044\u306e\u306b\u3001\u4f7f\u3044\u65b9\u304c\u826f\u304f\u308f\u304b\u3089\u306a\u3044\u3068\u56f0\u308b\u306e\u3067Rust0.11\u306b\u5bfe\u5fdc\u3057\u3066\u307f\u307e\u3057\u305f\u3002\n\n\u30a8\u30e9\u30fc\u30ef\u30fc\u30cb\u30f3\u30b0\u5bfe\u7b56\n\u30de\u30af\u30ed\u3001use,EAdd\u3068\u3044\u3046\u5927\u6587\u5b57\u3067\u59cb\u307e\u308b\u95a2\u6570\u3092\u8a31\u53ef\u3059\u308b\u70ba\u306b\u4ee5\u4e0b\u306e\u30a2\u30c8\u30ea\u30d3\u30e5\u30fc\u30c8\u3092\u4f7f\u3044\u307e\u3059\u3002\n#![feature(macro_rules)]\n#![feature(globs)]\n#![allow(non_snake_case_functions)]\n\n\n\u30e1\u30a4\u30f3\u95a2\u6570\n\u4ee5\u524d\u3001~a\u3068\u66f8\u3044\u3066\u3044\u305f\u3001~\u306fbox\u3068\u66f8\u304f\u3088\u3046\u306b\u306a\u308a\u307e\u3057\u305f\u3002box\u3068\u66f8\u304f\u3068\u30d2\u30fc\u30d7\u306b\u5024\u3092\u53d6\u308a\u3001\u30dd\u30a4\u30f3\u30bf\u3092\u6301\u3064\u3088\u3046\u306b\u306a\u308a\u307e\u3059\u3002\nprintln!\u306f\u51fa\u529b\u30de\u30af\u30ed\u3067\u3059\u304c\u3001{}\u306b\u5f15\u6570\u3092\u5c55\u958b\u3057\u307e\u3059\u3002\ninterp::eval\u304c\u30a4\u30f3\u30bf\u30d7\u30ea\u30bf\u3067\u3001virtuall\u304cAST\u304b\u3089\u4eee\u60f3LLVM\u547d\u4ee4\u3078\u306e\u30b3\u30f3\u30d1\u30a4\u30e9\u3001emit\u304c\u30d5\u30a1\u30a4\u30eb\u51fa\u529b\u3001exec\u3067llc\u3092\u547c\u3073\u51fa\u3057\u3001\u30b3\u30f3\u30d1\u30a4\u30eb\u5b9f\u884c\u3057\u3066\u3044\u307e\u3059\u3002\nfn main() {\n  use ast::*;\n  let ast = EBlock( Tv, vec![\n    EPrint(Ti(32), box ELdc( Ti(32), 11)),\n    EPrint(Ti(32),\n      box EAdd(Ti(32), box ELdc( Ti(32), 11), box ELdc( Ti(32), 22)))\n  ]);\n  println!(\"ast={}\", ast);\n  interp::eval(&ast);\n\n  let vs = virtuall(&ast);\n  println!(\"vs={}\",vs);\n\n  emit(\"e.ll\", &vs);\n\n  println!(\"{}\",exec(\"llc e.ll -o e.s\"));\n  println!(\"{}\",exec(\"llvm-gcc -m64 e.s -o e\"));\n  println!(\"{}\",exec(\"./e\"));\n}\n\n\n\u62bd\u8c61\u69cb\u6587\u6728AST\n\u69cb\u6587\u6728\u306fast\u30e2\u30b8\u30e5\u30fc\u30eb\u3067\u307e\u3068\u3081\u3066\u5ba3\u8a00\u3057\u3066\u3044\u307e\u3059\u3002\npub mod ast {\n\n  #[deriving(Clone,Show)]\n  pub enum E {\n    ELdc(T, int),\n    EBin(T, String, Box<E>, Box<E>),\n    EPrint(T, Box<E>),\n    EBlock(T, Vec<E>),\n  }\n\nELdc,EBin,EPrint,EBlock\u306e4\u3064\u306e\u578b\u3092\u5b9a\u7fa9\u3057\u3066\u3044\u307e\u3059\u3002Rust\u306eenum\u306f\u95a2\u6570\u578b\u8a00\u8a9e\u306e\u4ee3\u6570\u30c7\u30fc\u30bf\u578b\u306b\u5bfe\u5fdc\u3059\u308b\u4e8b\u304c\u51fa\u6765\u307e\u3059\u3002\u518d\u5e30\u7684\u306b\u578b\u3092\u53c2\u7167\u3059\u308b\u5834\u5408\u306f\u3001\u30dd\u30a4\u30f3\u30bf\u3092\u53c2\u7167\u3059\u308b\u3088\u3046\u306b\u3057\u306a\u3044\u3068\u3001\u30b5\u30a4\u30ba\u304c\u6c7a\u307e\u3089\u306a\u3044\u306e\u3067Box\u3092\u4f7f\u3046\u5fc5\u8981\u304c\u3042\u308a\u307e\u3059\u3002\u3057\u304b\u3057\u518d\u5e30\u7684\u306a\u53c2\u7167\u3067\u306a\u3051\u308c\u3070Box\u3092\u4f7f\u308f\u305a\u306b\u5b9a\u7fa9\u51fa\u6765\u307e\u3059\u3002Vec\u306f\u30d9\u30af\u30bf\u30fc\u3067\u3059\u304c\u3001\u30d9\u30af\u30bf\u30fc\u306b\u3057\u3066\u3044\u308b\u5834\u5408\u3082Box\u3092\u4f7f\u308f\u305a\u306b\u5b9a\u7fa9\u51fa\u6765\u307e\u3059\u3002\u3082\u3061\u308d\u3093\u3001Box\u3092\u4f7f\u304a\u3046\u3068\u601d\u3048\u3070\u4f7f\u3048\u307e\u3059\u3002\n#[deriving(Clone,Show)]\u3092\u4f7f\u3063\u3066\u3001clone\u3068\u30d5\u30a9\u30fc\u30de\u30c3\u30c8\u3057\u305f\u6587\u5b57\u5217\u51fa\u529b\u3092\u81ea\u52d5\u751f\u6210\u3057\u3066\u3044\u307e\u3059\u3002\n  macro_rules! EOp(\n    ($T:ident, $op:expr) => (\n      pub fn $T(t: T, a: Box<E>, b: Box<E>) -> E {\n        EBin(t, String::from_str($op), a, b)\n      }\n    )\n  )\n\n  EOp!(EAdd, \"add\")\n  EOp!(ESub, \"sub\")\n  EOp!(EMul, \"mul\")\n  EOp!(EDiv, \"div\")\n\nmacro_rues\u3092\u4f7f\u3063\u3066\u30de\u30af\u30ed\u3092\u5b9a\u7fa9\u3057\u3001EAdd,ESub,EMul,EDiv\u95a2\u6570\u3092\u5b9a\u7fa9\u3057\u3066\u3044\u307e\u3059\u3002\n  #[deriving(Clone,Show,PartialEq)]\n  pub enum T {\n    Ti(int),\n    Tv,\n    TFun(Box<T>, Vec<T>),\n  }\n\n\u578b\u3092\u8868\u3059\u578bT\u306e\u5b9a\u7fa9\u3067\u3059\u3002ParticalEq\u3067\u6bd4\u8f03\u547d\u4ee4\u3092\u5b9f\u88c5\u3057\u3066\u3044\u307e\u3059\u3002\n  #[deriving(Clone,Show)]\n  pub enum R {\n    RG(T, String),\n    RL(T, String),\n    RR(T, String),\n    RN(T, String),\n  }\n\nLLVM\u306e\u30ec\u30b8\u30b9\u30bf\u3092\u8868\u3059R\u3092\u5b9a\u7fa9\u3057\u3066\u3044\u307e\u3059\u3002\n  #[deriving(Clone,Show)]\n  pub enum V {\n    VCall(Option<R>, R, Vec<R>),\n    VBin(Option<R>, String, R, R),\n  }\n\nLLVM\u306e\u4eee\u60f3\u547d\u4ee4\u306eV\u3092\u5b9a\u7fa9\u3057\u3066\u3044\u307e\u3059\u3002\n\u3053\u308c\u4ee5\u964d\u304c\u3001\u52d5\u4f5c\u306e\u5b9a\u7fa9\u3067\u3059\u3002\n  impl R {\n    pub fn t(&self) -> T {\n      match *self {\n        RG(ref t, _) => t.clone(),\n        RL(ref t, _) => t.clone(),\n        RR(ref t, _) => t.clone(),\n        RN(ref t, _) => t.clone(),\n      }\n    }\n  }\n\nR\u306e\u578b\u3092\u53d6\u5f97\u3059\u308b\u95a2\u6570\u3067\u3059\u3002\n  pub trait P {\n    fn p(&self) -> String;\n  }\n\nr.p()\u3068\u3057\u3066\u3001\u6587\u5b57\u5217\u5316\u3059\u308b\u30a4\u30f3\u30bf\u30fc\u30d5\u30a7\u30a4\u30b9\u306e\u5b9a\u7fa9\u3067\u3059\u3002\n  impl P for T {\n    fn p(&self) -> String {\n      match *self {\n        Ti(ref i) => format!(\"i{}\",i),\n        Tv => String::from_str(\"void\"),\n        TFun(ref t, ref ls) => {\n          let mut stack = String::new();\n          for l in ls.iter() {\n            stack = stack + l.p();\n            stack.push_str(\", \");\n          }\n          format!(\"{}({})*\",t.p(), stack.as_slice().trim_chars(&[',', ' ']))\n        },\n      }\n    }\n  }\n\nT\u306b\u5bfe\u3059\u308b\u3001p\u306e\u5b9f\u88c5\u3067\u3059\u3002\n  impl P for R {\n    fn p(&self) -> String {\n      match *self {\n        RG(_,ref id) => format!(\"@{}\", *id),\n        RL(_,ref id) => format!(\"%{}\", *id),\n        RR(_,ref id) => format!(\"%.{}\", *id),\n        RN(_,ref id) => format!(\"{}\", *id),\n      }\n    }\n  }\n}\n\nR\u306b\u5bfe\u3059\u308b\u3001p\u306e\u5b9f\u88c5\u3067\u3059\u3002\n\n\u30a4\u30f3\u30bf\u30d7\u30ea\u30bf\ninterp\u30e2\u30b8\u30e5\u30fc\u30eb\u3067\u30a4\u30f3\u30bf\u30d7\u30ea\u30bf\u3092\u5b9a\u7fa9\u3057\u307e\u3059\u3002\nmod interp {\n  use ast::*;\n\n  pub fn eval(e:&E)->int {\n    match e {\n      &ELdc(_, i) => i,\n      &EBin(_, ref op, ref a, ref b) if op.equiv(&\"add\") => eval(*a) + eval(*b),\n      &EBin(_, ref op, _, _) => fail!(\"operator {}\",*op),\n      &EPrint(_, ref e) => {\n        let e = eval(*e);\n        println!(\"{}\",e);\n        e\n      }\n      &EBlock(_, ref ls) => {\n        fn f(ls:&[E], r:int)-> int {\n          match ls {\n            [] => r,\n            [ref a, ..rest] => f(rest,eval(a))\n          }\n        }\n        f(ls.as_slice(), 0)\n      }\n    }\n  }\n}\n\n\u69cb\u6587\u6728E\u3092\u53d7\u3051\u53d6\u3063\u3066\u3001\u5b9f\u884c\u3057\u5024\u3092int\u3067\u8fd4\u3057\u307e\u3059\u3002EPrint\u304c\u3042\u308c\u3070\u51fa\u529b\u3092\u884c\u3044\u307e\u3059\u3002match\u3092\u4f7f\u3063\u3066ELdc,EBin,EPrint,EBlock\u306b\u3064\u3044\u3066\u305d\u308c\u305e\u308c\u306e\u51e6\u7406\u304c\u66f8\u3044\u3066\u3042\u308a\u307e\u3059\u3002\n\n\u4eee\u60f3\u547d\u4ee4\u5909\u63db\n\u69cb\u6587\u6728\u3092\u53d7\u3051\u53d6\u3063\u3066\u3001LLVM\u306e\u4eee\u60f3\u547d\u4ee4\u306b\u5909\u63db\u3057\u307e\u3059\u3002\n\u3053\u306e\u95a2\u6570\u306f\u51fa\u529b\u3059\u308bV\u306e\u30ea\u30b9\u30c8\u306e\u72b6\u614b\u3092\u6301\u305f\u305b\u305f\u69cb\u9020\u3092\u5b9f\u73fe\u3057\u3066\u3044\u307e\u3059\u3002\nHaskell\u306a\u3089\u30b9\u30c6\u30fc\u30c8\u30e2\u30ca\u30c9\u3092\u4f7f\u3046\u6240\u3067\u3059\u3002\n\n\u30e2\u30b8\u30e5\u30fc\u30eb\u5185static\u5909\u6570\u306fbox\u5316\u3055\u308c\u305f\u30c7\u30b9\u30c8\u30e9\u30af\u30bf\u304c\u5fc5\u8981\u306a\u5909\u6570\u3092\u6301\u3066\u306a\u3044\u3002\n\u95a2\u6570\u5185\u95a2\u6570\u306f\u5916\u90e8\u306e\u5909\u6570\u3092\u30ad\u30e3\u30d7\u30c1\u30e3\u3067\u304d\u305a\u3001\u30af\u30ed\u30fc\u30b8\u30e3\u3092\u751f\u6210\u3057\u306a\u3044\u3002\n\u30af\u30ed\u30fc\u30b8\u30e3\u306f\u518d\u5e30\u547c\u3073\u51fa\u3057\u304c\u51fa\u6765\u306a\u3044\u3002\n\n\u3053\u306e\u3088\u3046\u306a\u5236\u9650\u304c\u3042\u308b\u305f\u3081\u3001\u3053\u3053\u3067\u306fstruct\u3092\u4f5c\u3063\u3066\u72b6\u614b\u3092\u6301\u305f\u305b\u3001impl\u3067\u95a2\u6570\u3092\u5b9f\u88c5\u3057\u307e\u3057\u305f\u3002self\u306b\u72b6\u614b\u3092\u6301\u3061\u3001\u30e1\u30bd\u30c3\u30c9\u547c\u3073\u51fa\u3057\u3092\u518d\u5e30\u7684\u306b\u547c\u3073\u51fa\u3057\u3066\u5909\u63db\u3057\u3066\u3044\u307e\u3059\u3002\n\u3068\u3066\u3082\u3001\u30aa\u30d6\u30b8\u30a7\u30af\u30c8\u6307\u5411\u7684\u3067\u3059\u304c\u3001\u69cb\u9020\u4f53\u306e\u30c7\u30fc\u30bf\u81ea\u4f53\u306fimmutable\u3067\u3001\u95a2\u6570\u5185\u306e\u5909\u6570\u3060\u3051\u304cmutable\u3067\u66f8\u304d\u63db\u3048\u3066\u3044\u304f\u30b9\u30bf\u30a4\u30eb\u306b\u306a\u3063\u3066\u3044\u307e\u3059\u3002\u306a\u306e\u3067\u3001\u69cb\u9020\u4f53\u304cHaskell\u306e\u30b9\u30c6\u30fc\u30c8\u30e2\u30ca\u30c9\u306e\u30c7\u30fc\u30bf\u306b\u306a\u3063\u3066\u3044\u308b\u3088\u3046\u306a\u611f\u3058\u306a\u8a33\u3067\u3059\u3002\n\nfn virtuall(a: &ast::E) -> Vec<ast::V> {\n  use ast::*;\n\n  struct Virutal {\n    ls:Vec<V>\n  }\n  impl Virutal {\n\n    fn new() -> Virutal {\n      Virutal{ls:Vec::new()}\n    }\n\n    fn gid(&mut self,t:&T)-> R {\n      RR(t.clone(), genid(\"\"))\n    }\n\n    fn add(&mut self, v:V) {\n      self.ls.push(v);\n    }\n\n    fn f(&mut self, e: &E) -> R {\n      match e {\n        &EBin(ref t,ref op, ref a, ref b) => {\n          let a = self.f(*a);\n          let b = self.f(*b);\n          let id = self.gid(t);\n          if *t != a.t() || *t != b.t() {\n            fail!(format!(\"type mismatch {}\",*t));\n          }\n          self.add(VBin(Some(id.clone()), op.clone(), a, b));\n          id\n        }\n        &ELdc(ref t, ref i) => RN(t.clone(), format!(\"{}\",i)),\n        &EPrint(ref t, ref a) => {\n          let a = self.f(*a);\n          if *t != a.t() {\n            fail!(format!(\"type mismatch t={} ta={}\", t, a.t()))\n          }\n          self.add(VCall(None, RG(TFun(box Tv, vec![t.clone()]), format!(\"print_{}\", t.p())), vec![a.clone()]));\n          a\n        }\n        &EBlock(_,ref ls) =>\n          self.loop_block(ls.as_slice(), &RN(Tv, String::new()))\n      }\n    }\n\n    fn loop_block(&mut self, ls:&[E],r:&R)->R {\n      match ls {\n        [] => r.clone(),\n        [ref e, ..rest] => {\n          let r = self.f(e);\n          self.loop_block(rest,&r)\n        }\n      }\n    }\n\n    fn apply(a: &ast::E) -> Vec<ast::V> {\n      let mut env = Virutal::new();\n      env.f(a);\n      env.ls\n    }\n  }\n\n  Virutal::apply(a)\n}\n\n\n\n\u51fa\u529b\n\u4eee\u60f3\u547d\u4ee4\u30ea\u30b9\u30c8\u304b\u3089\u30d5\u30a1\u30a4\u30eb\u306b\u6587\u5b57\u5217\u51fa\u529b\u3057\u307e\u3059\u3002\nAsm\u30af\u30e9\u30b9\u3092\u4f7f\u3063\u3066\u547c\u3073\u51fa\u3057\u3066\u3044\u307e\u3059\u3002Asm\u304c\u6587\u8108\u3092\u6301\u3063\u3066\u3044\u308b\u30e2\u30ca\u30c9\u306b\u306a\u3063\u3066\u3044\u308b\u611f\u3058\u3067\u3059\u3002\nfn emit(file: &str, vs: &Vec<ast::V>) {\n  use ast::*;\n  use asm::*;\n\n  fn emitV(asm:&mut Asm, v: &V) {\n    match v {\n      &VCall(ref id, ref op, ref prms) => {\n        let mut ps:String = String::new();\n\n        for a in prms.iter() {\n          ps = if ps == String::new() {\n            format!(\"{} {}\", a.t().p(), a.p())\n          } else {\n            format!(\"{}, {} {}\", ps, a.t().p(), a.p())\n          }\n        }\n        asm.o(id, &format!(\"call {} {}({}) nounwind\", op.t().p(), op.p(), ps))\n      }\n      &VBin(ref id, ref op, ref a, ref b) => {\n        asm.o(id, &format!(\"{} {} {}, {}\", *op, a.t().p(), a.p(), b.p()))\n      }\n    }\n  }\n\n  let asm = &mut Asm::open(file);\n\n  asm.p(&format!(\"@.str = private constant [4 x i8] c\\\"%d\\\\0A\\\\00\\\"\"));\n  asm.p(&format!(\"define void @print_i32(i32 %a) nounwind ssp {}\",\"{\"));\n  asm.p(&format!(\"entry:\"));\n  asm.__(&format!(\"call i32 (i8*, ...)* @printf(i8* getelementptr inbounds ([4 x i8]* @.str, i64 0, i64 0), i32 %a) nounwind\"));\n  asm.__(&format!(\"ret void\"));\n  asm.p(&format!(\"{}\",\"}\"));\n  asm.p(&format!(\"define void @print_i8(i8 %a) nounwind ssp {}\",\"{\"));\n  asm.p(&format!(\"entry:\"));\n  asm.__(&format!(\"call i32 (i8*, ...)* @printf(i8* getelementptr inbounds ([4 x i8]* @.str, i64 0, i64 0), i8 %a) nounwind\"));\n  asm.__(&format!(\"ret void\"));\n  asm.p(&format!(\"{}\",\"}\"));\n\n  asm.p(&format!(\"declare i32 @printf(i8*, ...) nounwind\"));\n\n  asm.p(&format!(\"define i32 @main() nounwind ssp {}\",\"{\"));\n  asm.p(&format!(\"entry:\"));\n\n  for v in vs.iter() {\n    emitV(asm,v);\n  }\n\n  asm.__(&format!(\"ret i32 0\"));\n  asm.p(&format!(\"{}\",\"}\"));\n\n}\n\n\n\n\u30a2\u30bb\u30f3\u30d6\u30e9\u51fa\u529b\n\u30a2\u30bb\u30f3\u30d6\u30e9\u51fa\u529b\u30af\u30e9\u30b9\u3068\u3044\u3046\u304b\u30e2\u30ca\u30c9\u3068\u3044\u3046\u304b\u3001\u305d\u3093\u306a\u611f\u3058\u306e\u7269\u306e\u5b9a\u7fa9\u3067\u3059\u3002\n\npub mod asm {\n  use std::io::*;\n  use ast::*;\n  pub struct Asm {\n    file:Result<File,IoError>\n  }\n  impl Asm {\n    pub fn open(file:&str) -> Asm {\n      Asm{file:File::create(&Path::new(file))}\n    }\n    #[allow(unused_must_use)]\n    fn println(&mut self,s:&String) {\n      let ss = s.as_bytes();\n      self.file.write(ss);\n      self.file.write(\"\\n\".as_bytes());\n    }\n    pub fn __(&mut self,s:&String) {\n      self.println(&format!(\"  {}\",s));\n    }\n    pub fn p(&mut self,s:&String) {\n      self.println(s);\n    }\n    pub fn o(&mut self, id: &Option<R>, out: &String) {\n      match id {\n        &Some(ref id) =>self.__(&format!(\"{} = {}\", id.p(), out)),\n        &None => self.__(out),\n      }\n    }\n  }\n}\n\n\nid\u751f\u6210\n\u3053\u308c\u306fID\u3092\u751f\u6210\u3059\u308b\u3060\u3051\u306e\u95a2\u6570\u3067\u3059\u3002static\u306aint\u306a\u3089mutable\u3067\u3082\u6301\u3066\u308b\u306e\u3067\u4f7f\u3063\u3066\u3044\u307e\u3059\u3002\nfn genid(s:&str) -> String {\n  static mut id:int = 0;\n  unsafe {\n    id += 1;\n    format!(\"{}{}\",s, id)\n  }\n}\n\n\n\u30d7\u30ed\u30bb\u30b9\u5b9f\u884c\n\u6587\u5b57\u5217\u3092\u6e21\u3059\u3068\u30d7\u30ed\u30bb\u30b9\u3092\u5b9f\u884c\u3057\u3066\u591a\u5024\u3067\u8fd4\u3059\u3060\u3051\u306e\u95a2\u6570\u3067\u3059\u3002\nfn exec(cmd:&str) -> (int, String, String) {\n\n  use std::io::process::*;\n\n  let mut cmds:Vec<&str> = cmd.split_str(\" \").collect();\n  let mut cmd = Command::new(cmds.shift().unwrap());\n\n  for arg in cmds.iter() {\n    cmd.arg(*arg);\n  }\n\n  let mut process = match cmd.spawn() {\n    Ok(p) => p,\n    Err(e) => fail!(\"failed to execute process: {}\", e),\n  };\n  process.set_timeout(Some(10_000));\n  let code = match process.wait().ok().unwrap() {\n    ExitStatus(i) => i,\n    ExitSignal(i) => i\n  };\n\n  let output = process.stdout.get_mut_ref().read_to_end();\n  let error = process.stderr.get_mut_ref().read_to_end();\n\n    (code,\n    String::from_utf8(output.ok().unwrap()).ok().unwrap(),\n    String::from_utf8(error.ok().unwrap()).ok().unwrap()\n    )\n}\n\n\n\u30b3\u30f3\u30d1\u30a4\u30eb & \u5b9f\u884c\n$ rustc comp.rs\n$ ./comp\n\n\u3053\u308c\u3067\u3001e.ll,e.s,e\u304c\u51fa\u529b\u3055\u308c\u307e\u3059\u3002\n\n\u307e\u3068\u3081\n\u6700\u8fd1\u306eRust\u306e\u30aa\u30d6\u30b8\u30a7\u30af\u30c8\u6307\u5411\u306f\u30e2\u30ca\u30c9\u5247\u306f\u3069\u3046\u306a\u306e\u304b\u3063\u3066\u8a71\u306f\u7f6e\u3044\u3066\u8d77\u304d\u307e\u3059\u304cHaskell\u306e\u578b\u30af\u30e9\u30b9\u306e\u3088\u3046\u3067\u3042\u308a\u3001\u30e2\u30ca\u30c9\u306e\u3088\u3046\u3067\u3082\u3042\u308a\u307e\u3059\u3002\u4eca\u307e\u3067\u306e\u30aa\u30d6\u30b8\u30a7\u30af\u30c8\u6307\u5411\u8a00\u8a9e\u3068\u306f\u5927\u5206\u3001Haskell\u7684\u306b\u306a\u3063\u3066\u3044\u307e\u3059\u304c\u3001Haskell\u3088\u308a\u306f\u30aa\u30d6\u30b8\u30a7\u30af\u30c8\u6307\u5411\u8a00\u8a9e\u306b\u8fd1\u3044\u3082\u306e\u306b\u306a\u3063\u3066\u3044\u307e\u3057\u305f\u3002Haskell\u306f\u9045\u5ef6\u8a55\u4fa1\u3086\u3048\u306b\u3001\u30e1\u30e2\u30ea\u7ba1\u7406\u304c\u88cf\u3067\u3069\u3046\u306a\u3063\u3066\u3044\u308b\u304b\u304c\u5206\u304b\u308a\u8f9b\u3044\u306e\u3067\u3059\u304c\u3001Rust\u3067\u306f\u30e1\u30e2\u30ea\u7ba1\u7406\u306f\u624b\u52d5\u3067\u884c\u3046\u306e\u3067\u3001\u660e\u78ba\u3067\u3059\u3002\u30ea\u30d5\u30a1\u30ec\u30f3\u30b9\u30ab\u30a6\u30f3\u30bf\u3084GC\u3092\u4f7f\u304a\u3046\u3068\u601d\u3048\u3070\u4f7f\u3048\u307e\u3059\u304c\u3001\u4f7f\u308f\u306a\u304f\u3066\u3082\u30d7\u30ed\u30b0\u30e9\u30e0\u306f\u7d44\u3081\u3066\u30ea\u30fc\u30af\u3082\u3057\u307e\u305b\u3093\u3002GC\u306a\u3057\u306eHaskell\u3092\u3088\u308a\u4e00\u822c\u7684\u306a\u30aa\u30d6\u30b8\u30a7\u30af\u30c8\u6307\u5411\u306e\u8a00\u8a9e\u306b\u4f3c\u305b\u305fRust\u306f\u306a\u304b\u306a\u304b\u7d20\u6674\u3089\u3057\u3044\u8a00\u8a9e\u306e\u3088\u3046\u306b\u601d\u3044\u307e\u3059\u3002\n\n## \u306f\u3058\u3081\u306b\n\n\u4ee5\u524d\u3001Rust0.7\u3067\u30b3\u30f3\u30d1\u30a4\u30e9\u3092\u4f5c\u6210\u3057\u3066\u307f\u305f\u306e\u3067\u3059\u304c\u3001Rust0.11\u307e\u3067\u30d0\u30fc\u30b8\u30e7\u30f3\u304c\u4e0a\u304c\u308a\u3001\u52d5\u304b\u306a\u304f\u306a\u3063\u3066\u3057\u307e\u3044\u307e\u3057\u305f\u3002\u958b\u767a\u4e2d\u306e\u8a00\u8a9e\u306e\u5909\u66f4\u306a\u306e\u3067\u4ed5\u65b9\u306a\u3044\u306e\u3067\u3059\u304c\u3001Rust\u3092\u53c2\u8003\u306b\u3057\u305f\u3044\u306e\u306b\u3001\u4f7f\u3044\u65b9\u304c\u826f\u304f\u308f\u304b\u3089\u306a\u3044\u3068\u56f0\u308b\u306e\u3067Rust0.11\u306b\u5bfe\u5fdc\u3057\u3066\u307f\u307e\u3057\u305f\u3002\n\n## \u30a8\u30e9\u30fc\u30ef\u30fc\u30cb\u30f3\u30b0\u5bfe\u7b56\n\n\u30de\u30af\u30ed\u3001use,EAdd\u3068\u3044\u3046\u5927\u6587\u5b57\u3067\u59cb\u307e\u308b\u95a2\u6570\u3092\u8a31\u53ef\u3059\u308b\u70ba\u306b\u4ee5\u4e0b\u306e\u30a2\u30c8\u30ea\u30d3\u30e5\u30fc\u30c8\u3092\u4f7f\u3044\u307e\u3059\u3002\n\n```\n#![feature(macro_rules)]\n#![feature(globs)]\n#![allow(non_snake_case_functions)]\n```\n\n## \u30e1\u30a4\u30f3\u95a2\u6570\n\n\u4ee5\u524d\u3001~a\u3068\u66f8\u3044\u3066\u3044\u305f\u3001~\u306fbox\u3068\u66f8\u304f\u3088\u3046\u306b\u306a\u308a\u307e\u3057\u305f\u3002box\u3068\u66f8\u304f\u3068\u30d2\u30fc\u30d7\u306b\u5024\u3092\u53d6\u308a\u3001\u30dd\u30a4\u30f3\u30bf\u3092\u6301\u3064\u3088\u3046\u306b\u306a\u308a\u307e\u3059\u3002\nprintln!\u306f\u51fa\u529b\u30de\u30af\u30ed\u3067\u3059\u304c\u3001{}\u306b\u5f15\u6570\u3092\u5c55\u958b\u3057\u307e\u3059\u3002\n\ninterp::eval\u304c\u30a4\u30f3\u30bf\u30d7\u30ea\u30bf\u3067\u3001virtuall\u304cAST\u304b\u3089\u4eee\u60f3LLVM\u547d\u4ee4\u3078\u306e\u30b3\u30f3\u30d1\u30a4\u30e9\u3001emit\u304c\u30d5\u30a1\u30a4\u30eb\u51fa\u529b\u3001exec\u3067llc\u3092\u547c\u3073\u51fa\u3057\u3001\u30b3\u30f3\u30d1\u30a4\u30eb\u5b9f\u884c\u3057\u3066\u3044\u307e\u3059\u3002\n\n```\nfn main() {\n  use ast::*;\n  let ast = EBlock( Tv, vec![\n    EPrint(Ti(32), box ELdc( Ti(32), 11)),\n    EPrint(Ti(32),\n      box EAdd(Ti(32), box ELdc( Ti(32), 11), box ELdc( Ti(32), 22)))\n  ]);\n  println!(\"ast={}\", ast);\n  interp::eval(&ast);\n\n  let vs = virtuall(&ast);\n  println!(\"vs={}\",vs);\n\n  emit(\"e.ll\", &vs);\n\n  println!(\"{}\",exec(\"llc e.ll -o e.s\"));\n  println!(\"{}\",exec(\"llvm-gcc -m64 e.s -o e\"));\n  println!(\"{}\",exec(\"./e\"));\n}\n```\n\n## \u62bd\u8c61\u69cb\u6587\u6728AST\n\n\u69cb\u6587\u6728\u306fast\u30e2\u30b8\u30e5\u30fc\u30eb\u3067\u307e\u3068\u3081\u3066\u5ba3\u8a00\u3057\u3066\u3044\u307e\u3059\u3002\n\n```\npub mod ast {\n\n  #[deriving(Clone,Show)]\n  pub enum E {\n    ELdc(T, int),\n    EBin(T, String, Box<E>, Box<E>),\n    EPrint(T, Box<E>),\n    EBlock(T, Vec<E>),\n  }\n```\n\nELdc,EBin,EPrint,EBlock\u306e4\u3064\u306e\u578b\u3092\u5b9a\u7fa9\u3057\u3066\u3044\u307e\u3059\u3002Rust\u306eenum\u306f\u95a2\u6570\u578b\u8a00\u8a9e\u306e\u4ee3\u6570\u30c7\u30fc\u30bf\u578b\u306b\u5bfe\u5fdc\u3059\u308b\u4e8b\u304c\u51fa\u6765\u307e\u3059\u3002\u518d\u5e30\u7684\u306b\u578b\u3092\u53c2\u7167\u3059\u308b\u5834\u5408\u306f\u3001\u30dd\u30a4\u30f3\u30bf\u3092\u53c2\u7167\u3059\u308b\u3088\u3046\u306b\u3057\u306a\u3044\u3068\u3001\u30b5\u30a4\u30ba\u304c\u6c7a\u307e\u3089\u306a\u3044\u306e\u3067Box\u3092\u4f7f\u3046\u5fc5\u8981\u304c\u3042\u308a\u307e\u3059\u3002\u3057\u304b\u3057\u518d\u5e30\u7684\u306a\u53c2\u7167\u3067\u306a\u3051\u308c\u3070Box\u3092\u4f7f\u308f\u305a\u306b\u5b9a\u7fa9\u51fa\u6765\u307e\u3059\u3002Vec\u306f\u30d9\u30af\u30bf\u30fc\u3067\u3059\u304c\u3001\u30d9\u30af\u30bf\u30fc\u306b\u3057\u3066\u3044\u308b\u5834\u5408\u3082Box\u3092\u4f7f\u308f\u305a\u306b\u5b9a\u7fa9\u51fa\u6765\u307e\u3059\u3002\u3082\u3061\u308d\u3093\u3001Box\u3092\u4f7f\u304a\u3046\u3068\u601d\u3048\u3070\u4f7f\u3048\u307e\u3059\u3002\n`#[deriving(Clone,Show)]`\u3092\u4f7f\u3063\u3066\u3001clone\u3068\u30d5\u30a9\u30fc\u30de\u30c3\u30c8\u3057\u305f\u6587\u5b57\u5217\u51fa\u529b\u3092\u81ea\u52d5\u751f\u6210\u3057\u3066\u3044\u307e\u3059\u3002\n\n\n```\n  macro_rules! EOp(\n    ($T:ident, $op:expr) => (\n      pub fn $T(t: T, a: Box<E>, b: Box<E>) -> E {\n        EBin(t, String::from_str($op), a, b)\n      }\n    )\n  )\n\n  EOp!(EAdd, \"add\")\n  EOp!(ESub, \"sub\")\n  EOp!(EMul, \"mul\")\n  EOp!(EDiv, \"div\")\n```\n\nmacro_rues\u3092\u4f7f\u3063\u3066\u30de\u30af\u30ed\u3092\u5b9a\u7fa9\u3057\u3001EAdd,ESub,EMul,EDiv\u95a2\u6570\u3092\u5b9a\u7fa9\u3057\u3066\u3044\u307e\u3059\u3002\n\n```\n  #[deriving(Clone,Show,PartialEq)]\n  pub enum T {\n    Ti(int),\n    Tv,\n    TFun(Box<T>, Vec<T>),\n  }\n```\n\n\u578b\u3092\u8868\u3059\u578bT\u306e\u5b9a\u7fa9\u3067\u3059\u3002ParticalEq\u3067\u6bd4\u8f03\u547d\u4ee4\u3092\u5b9f\u88c5\u3057\u3066\u3044\u307e\u3059\u3002\n\n```\n  #[deriving(Clone,Show)]\n  pub enum R {\n    RG(T, String),\n    RL(T, String),\n    RR(T, String),\n    RN(T, String),\n  }\n```\n\nLLVM\u306e\u30ec\u30b8\u30b9\u30bf\u3092\u8868\u3059R\u3092\u5b9a\u7fa9\u3057\u3066\u3044\u307e\u3059\u3002\n\n```\n  #[deriving(Clone,Show)]\n  pub enum V {\n    VCall(Option<R>, R, Vec<R>),\n    VBin(Option<R>, String, R, R),\n  }\n```\n\nLLVM\u306e\u4eee\u60f3\u547d\u4ee4\u306eV\u3092\u5b9a\u7fa9\u3057\u3066\u3044\u307e\u3059\u3002\n\n\u3053\u308c\u4ee5\u964d\u304c\u3001\u52d5\u4f5c\u306e\u5b9a\u7fa9\u3067\u3059\u3002\n\n```\n  impl R {\n    pub fn t(&self) -> T {\n      match *self {\n        RG(ref t, _) => t.clone(),\n        RL(ref t, _) => t.clone(),\n        RR(ref t, _) => t.clone(),\n        RN(ref t, _) => t.clone(),\n      }\n    }\n  }\n```\n\nR\u306e\u578b\u3092\u53d6\u5f97\u3059\u308b\u95a2\u6570\u3067\u3059\u3002\n\n```\n  pub trait P {\n    fn p(&self) -> String;\n  }\n```\n\nr.p()\u3068\u3057\u3066\u3001\u6587\u5b57\u5217\u5316\u3059\u308b\u30a4\u30f3\u30bf\u30fc\u30d5\u30a7\u30a4\u30b9\u306e\u5b9a\u7fa9\u3067\u3059\u3002\n\n```\n  impl P for T {\n    fn p(&self) -> String {\n      match *self {\n        Ti(ref i) => format!(\"i{}\",i),\n        Tv => String::from_str(\"void\"),\n        TFun(ref t, ref ls) => {\n          let mut stack = String::new();\n          for l in ls.iter() {\n            stack = stack + l.p();\n            stack.push_str(\", \");\n          }\n          format!(\"{}({})*\",t.p(), stack.as_slice().trim_chars(&[',', ' ']))\n        },\n      }\n    }\n  }\n```\n\nT\u306b\u5bfe\u3059\u308b\u3001p\u306e\u5b9f\u88c5\u3067\u3059\u3002\n\n```\n  impl P for R {\n    fn p(&self) -> String {\n      match *self {\n        RG(_,ref id) => format!(\"@{}\", *id),\n        RL(_,ref id) => format!(\"%{}\", *id),\n        RR(_,ref id) => format!(\"%.{}\", *id),\n        RN(_,ref id) => format!(\"{}\", *id),\n      }\n    }\n  }\n}\n```\n\nR\u306b\u5bfe\u3059\u308b\u3001p\u306e\u5b9f\u88c5\u3067\u3059\u3002\n\n## \u30a4\u30f3\u30bf\u30d7\u30ea\u30bf\n\ninterp\u30e2\u30b8\u30e5\u30fc\u30eb\u3067\u30a4\u30f3\u30bf\u30d7\u30ea\u30bf\u3092\u5b9a\u7fa9\u3057\u307e\u3059\u3002\n\n```\nmod interp {\n  use ast::*;\n\n  pub fn eval(e:&E)->int {\n    match e {\n      &ELdc(_, i) => i,\n      &EBin(_, ref op, ref a, ref b) if op.equiv(&\"add\") => eval(*a) + eval(*b),\n      &EBin(_, ref op, _, _) => fail!(\"operator {}\",*op),\n      &EPrint(_, ref e) => {\n        let e = eval(*e);\n        println!(\"{}\",e);\n        e\n      }\n      &EBlock(_, ref ls) => {\n        fn f(ls:&[E], r:int)-> int {\n          match ls {\n            [] => r,\n            [ref a, ..rest] => f(rest,eval(a))\n          }\n        }\n        f(ls.as_slice(), 0)\n      }\n    }\n  }\n}\n```\n\n\u69cb\u6587\u6728E\u3092\u53d7\u3051\u53d6\u3063\u3066\u3001\u5b9f\u884c\u3057\u5024\u3092int\u3067\u8fd4\u3057\u307e\u3059\u3002EPrint\u304c\u3042\u308c\u3070\u51fa\u529b\u3092\u884c\u3044\u307e\u3059\u3002match\u3092\u4f7f\u3063\u3066ELdc,EBin,EPrint,EBlock\u306b\u3064\u3044\u3066\u305d\u308c\u305e\u308c\u306e\u51e6\u7406\u304c\u66f8\u3044\u3066\u3042\u308a\u307e\u3059\u3002\n\n## \u4eee\u60f3\u547d\u4ee4\u5909\u63db\n\n\u69cb\u6587\u6728\u3092\u53d7\u3051\u53d6\u3063\u3066\u3001LLVM\u306e\u4eee\u60f3\u547d\u4ee4\u306b\u5909\u63db\u3057\u307e\u3059\u3002\n\n\u3053\u306e\u95a2\u6570\u306f\u51fa\u529b\u3059\u308bV\u306e\u30ea\u30b9\u30c8\u306e\u72b6\u614b\u3092\u6301\u305f\u305b\u305f\u69cb\u9020\u3092\u5b9f\u73fe\u3057\u3066\u3044\u307e\u3059\u3002\nHaskell\u306a\u3089\u30b9\u30c6\u30fc\u30c8\u30e2\u30ca\u30c9\u3092\u4f7f\u3046\u6240\u3067\u3059\u3002\n\n- \u30e2\u30b8\u30e5\u30fc\u30eb\u5185static\u5909\u6570\u306fbox\u5316\u3055\u308c\u305f\u30c7\u30b9\u30c8\u30e9\u30af\u30bf\u304c\u5fc5\u8981\u306a\u5909\u6570\u3092\u6301\u3066\u306a\u3044\u3002\n- \u95a2\u6570\u5185\u95a2\u6570\u306f\u5916\u90e8\u306e\u5909\u6570\u3092\u30ad\u30e3\u30d7\u30c1\u30e3\u3067\u304d\u305a\u3001\u30af\u30ed\u30fc\u30b8\u30e3\u3092\u751f\u6210\u3057\u306a\u3044\u3002\n- \u30af\u30ed\u30fc\u30b8\u30e3\u306f\u518d\u5e30\u547c\u3073\u51fa\u3057\u304c\u51fa\u6765\u306a\u3044\u3002\n\n\u3053\u306e\u3088\u3046\u306a\u5236\u9650\u304c\u3042\u308b\u305f\u3081\u3001\u3053\u3053\u3067\u306fstruct\u3092\u4f5c\u3063\u3066\u72b6\u614b\u3092\u6301\u305f\u305b\u3001impl\u3067\u95a2\u6570\u3092\u5b9f\u88c5\u3057\u307e\u3057\u305f\u3002self\u306b\u72b6\u614b\u3092\u6301\u3061\u3001\u30e1\u30bd\u30c3\u30c9\u547c\u3073\u51fa\u3057\u3092\u518d\u5e30\u7684\u306b\u547c\u3073\u51fa\u3057\u3066\u5909\u63db\u3057\u3066\u3044\u307e\u3059\u3002\n\n\u3068\u3066\u3082\u3001\u30aa\u30d6\u30b8\u30a7\u30af\u30c8\u6307\u5411\u7684\u3067\u3059\u304c\u3001\u69cb\u9020\u4f53\u306e\u30c7\u30fc\u30bf\u81ea\u4f53\u306fimmutable\u3067\u3001\u95a2\u6570\u5185\u306e\u5909\u6570\u3060\u3051\u304cmutable\u3067\u66f8\u304d\u63db\u3048\u3066\u3044\u304f\u30b9\u30bf\u30a4\u30eb\u306b\u306a\u3063\u3066\u3044\u307e\u3059\u3002\u306a\u306e\u3067\u3001\u69cb\u9020\u4f53\u304cHaskell\u306e\u30b9\u30c6\u30fc\u30c8\u30e2\u30ca\u30c9\u306e\u30c7\u30fc\u30bf\u306b\u306a\u3063\u3066\u3044\u308b\u3088\u3046\u306a\u611f\u3058\u306a\u8a33\u3067\u3059\u3002\n\n```\n\nfn virtuall(a: &ast::E) -> Vec<ast::V> {\n  use ast::*;\n\n  struct Virutal {\n    ls:Vec<V>\n  }\n  impl Virutal {\n\n    fn new() -> Virutal {\n      Virutal{ls:Vec::new()}\n    }\n\n    fn gid(&mut self,t:&T)-> R {\n      RR(t.clone(), genid(\"\"))\n    }\n\n    fn add(&mut self, v:V) {\n      self.ls.push(v);\n    }\n\n    fn f(&mut self, e: &E) -> R {\n      match e {\n        &EBin(ref t,ref op, ref a, ref b) => {\n          let a = self.f(*a);\n          let b = self.f(*b);\n          let id = self.gid(t);\n          if *t != a.t() || *t != b.t() {\n            fail!(format!(\"type mismatch {}\",*t));\n          }\n          self.add(VBin(Some(id.clone()), op.clone(), a, b));\n          id\n        }\n        &ELdc(ref t, ref i) => RN(t.clone(), format!(\"{}\",i)),\n        &EPrint(ref t, ref a) => {\n          let a = self.f(*a);\n          if *t != a.t() {\n            fail!(format!(\"type mismatch t={} ta={}\", t, a.t()))\n          }\n          self.add(VCall(None, RG(TFun(box Tv, vec![t.clone()]), format!(\"print_{}\", t.p())), vec![a.clone()]));\n          a\n        }\n        &EBlock(_,ref ls) =>\n          self.loop_block(ls.as_slice(), &RN(Tv, String::new()))\n      }\n    }\n\n    fn loop_block(&mut self, ls:&[E],r:&R)->R {\n      match ls {\n        [] => r.clone(),\n        [ref e, ..rest] => {\n          let r = self.f(e);\n          self.loop_block(rest,&r)\n        }\n      }\n    }\n\n    fn apply(a: &ast::E) -> Vec<ast::V> {\n      let mut env = Virutal::new();\n      env.f(a);\n      env.ls\n    }\n  }\n\n  Virutal::apply(a)\n}\n\n```\n\n## \u51fa\u529b\n\n\u4eee\u60f3\u547d\u4ee4\u30ea\u30b9\u30c8\u304b\u3089\u30d5\u30a1\u30a4\u30eb\u306b\u6587\u5b57\u5217\u51fa\u529b\u3057\u307e\u3059\u3002\nAsm\u30af\u30e9\u30b9\u3092\u4f7f\u3063\u3066\u547c\u3073\u51fa\u3057\u3066\u3044\u307e\u3059\u3002Asm\u304c\u6587\u8108\u3092\u6301\u3063\u3066\u3044\u308b\u30e2\u30ca\u30c9\u306b\u306a\u3063\u3066\u3044\u308b\u611f\u3058\u3067\u3059\u3002\n\n```\nfn emit(file: &str, vs: &Vec<ast::V>) {\n  use ast::*;\n  use asm::*;\n\n  fn emitV(asm:&mut Asm, v: &V) {\n    match v {\n      &VCall(ref id, ref op, ref prms) => {\n        let mut ps:String = String::new();\n\n        for a in prms.iter() {\n          ps = if ps == String::new() {\n            format!(\"{} {}\", a.t().p(), a.p())\n          } else {\n            format!(\"{}, {} {}\", ps, a.t().p(), a.p())\n          }\n        }\n        asm.o(id, &format!(\"call {} {}({}) nounwind\", op.t().p(), op.p(), ps))\n      }\n      &VBin(ref id, ref op, ref a, ref b) => {\n        asm.o(id, &format!(\"{} {} {}, {}\", *op, a.t().p(), a.p(), b.p()))\n      }\n    }\n  }\n\n  let asm = &mut Asm::open(file);\n\n  asm.p(&format!(\"@.str = private constant [4 x i8] c\\\"%d\\\\0A\\\\00\\\"\"));\n  asm.p(&format!(\"define void @print_i32(i32 %a) nounwind ssp {}\",\"{\"));\n  asm.p(&format!(\"entry:\"));\n  asm.__(&format!(\"call i32 (i8*, ...)* @printf(i8* getelementptr inbounds ([4 x i8]* @.str, i64 0, i64 0), i32 %a) nounwind\"));\n  asm.__(&format!(\"ret void\"));\n  asm.p(&format!(\"{}\",\"}\"));\n  asm.p(&format!(\"define void @print_i8(i8 %a) nounwind ssp {}\",\"{\"));\n  asm.p(&format!(\"entry:\"));\n  asm.__(&format!(\"call i32 (i8*, ...)* @printf(i8* getelementptr inbounds ([4 x i8]* @.str, i64 0, i64 0), i8 %a) nounwind\"));\n  asm.__(&format!(\"ret void\"));\n  asm.p(&format!(\"{}\",\"}\"));\n\n  asm.p(&format!(\"declare i32 @printf(i8*, ...) nounwind\"));\n\n  asm.p(&format!(\"define i32 @main() nounwind ssp {}\",\"{\"));\n  asm.p(&format!(\"entry:\"));\n\n  for v in vs.iter() {\n    emitV(asm,v);\n  }\n\n  asm.__(&format!(\"ret i32 0\"));\n  asm.p(&format!(\"{}\",\"}\"));\n\n}\n\n```\n\n## \u30a2\u30bb\u30f3\u30d6\u30e9\u51fa\u529b\n\n\u30a2\u30bb\u30f3\u30d6\u30e9\u51fa\u529b\u30af\u30e9\u30b9\u3068\u3044\u3046\u304b\u30e2\u30ca\u30c9\u3068\u3044\u3046\u304b\u3001\u305d\u3093\u306a\u611f\u3058\u306e\u7269\u306e\u5b9a\u7fa9\u3067\u3059\u3002\n\n```\n\npub mod asm {\n  use std::io::*;\n  use ast::*;\n  pub struct Asm {\n    file:Result<File,IoError>\n  }\n  impl Asm {\n    pub fn open(file:&str) -> Asm {\n      Asm{file:File::create(&Path::new(file))}\n    }\n    #[allow(unused_must_use)]\n    fn println(&mut self,s:&String) {\n      let ss = s.as_bytes();\n      self.file.write(ss);\n      self.file.write(\"\\n\".as_bytes());\n    }\n    pub fn __(&mut self,s:&String) {\n      self.println(&format!(\"  {}\",s));\n    }\n    pub fn p(&mut self,s:&String) {\n      self.println(s);\n    }\n    pub fn o(&mut self, id: &Option<R>, out: &String) {\n      match id {\n        &Some(ref id) =>self.__(&format!(\"{} = {}\", id.p(), out)),\n        &None => self.__(out),\n      }\n    }\n  }\n}\n```\n\n## id\u751f\u6210\n\n\u3053\u308c\u306fID\u3092\u751f\u6210\u3059\u308b\u3060\u3051\u306e\u95a2\u6570\u3067\u3059\u3002static\u306aint\u306a\u3089mutable\u3067\u3082\u6301\u3066\u308b\u306e\u3067\u4f7f\u3063\u3066\u3044\u307e\u3059\u3002\n\n```\nfn genid(s:&str) -> String {\n  static mut id:int = 0;\n  unsafe {\n    id += 1;\n    format!(\"{}{}\",s, id)\n  }\n}\n```\n\n## \u30d7\u30ed\u30bb\u30b9\u5b9f\u884c\n\n\u6587\u5b57\u5217\u3092\u6e21\u3059\u3068\u30d7\u30ed\u30bb\u30b9\u3092\u5b9f\u884c\u3057\u3066\u591a\u5024\u3067\u8fd4\u3059\u3060\u3051\u306e\u95a2\u6570\u3067\u3059\u3002\n\n```\nfn exec(cmd:&str) -> (int, String, String) {\n\n  use std::io::process::*;\n\n  let mut cmds:Vec<&str> = cmd.split_str(\" \").collect();\n  let mut cmd = Command::new(cmds.shift().unwrap());\n\n  for arg in cmds.iter() {\n    cmd.arg(*arg);\n  }\n\n  let mut process = match cmd.spawn() {\n    Ok(p) => p,\n    Err(e) => fail!(\"failed to execute process: {}\", e),\n  };\n  process.set_timeout(Some(10_000));\n  let code = match process.wait().ok().unwrap() {\n    ExitStatus(i) => i,\n    ExitSignal(i) => i\n  };\n\n  let output = process.stdout.get_mut_ref().read_to_end();\n  let error = process.stderr.get_mut_ref().read_to_end();\n\n    (code,\n    String::from_utf8(output.ok().unwrap()).ok().unwrap(),\n    String::from_utf8(error.ok().unwrap()).ok().unwrap()\n    )\n}\n```\n\n\n## \u30b3\u30f3\u30d1\u30a4\u30eb & \u5b9f\u884c\n\n```\n$ rustc comp.rs\n$ ./comp\n```\n\n\u3053\u308c\u3067\u3001e.ll,e.s,e\u304c\u51fa\u529b\u3055\u308c\u307e\u3059\u3002\n\n\n## \u307e\u3068\u3081\n\n\u6700\u8fd1\u306eRust\u306e\u30aa\u30d6\u30b8\u30a7\u30af\u30c8\u6307\u5411\u306f\u30e2\u30ca\u30c9\u5247\u306f\u3069\u3046\u306a\u306e\u304b\u3063\u3066\u8a71\u306f\u7f6e\u3044\u3066\u8d77\u304d\u307e\u3059\u304cHaskell\u306e\u578b\u30af\u30e9\u30b9\u306e\u3088\u3046\u3067\u3042\u308a\u3001\u30e2\u30ca\u30c9\u306e\u3088\u3046\u3067\u3082\u3042\u308a\u307e\u3059\u3002\u4eca\u307e\u3067\u306e\u30aa\u30d6\u30b8\u30a7\u30af\u30c8\u6307\u5411\u8a00\u8a9e\u3068\u306f\u5927\u5206\u3001Haskell\u7684\u306b\u306a\u3063\u3066\u3044\u307e\u3059\u304c\u3001Haskell\u3088\u308a\u306f\u30aa\u30d6\u30b8\u30a7\u30af\u30c8\u6307\u5411\u8a00\u8a9e\u306b\u8fd1\u3044\u3082\u306e\u306b\u306a\u3063\u3066\u3044\u307e\u3057\u305f\u3002Haskell\u306f\u9045\u5ef6\u8a55\u4fa1\u3086\u3048\u306b\u3001\u30e1\u30e2\u30ea\u7ba1\u7406\u304c\u88cf\u3067\u3069\u3046\u306a\u3063\u3066\u3044\u308b\u304b\u304c\u5206\u304b\u308a\u8f9b\u3044\u306e\u3067\u3059\u304c\u3001Rust\u3067\u306f\u30e1\u30e2\u30ea\u7ba1\u7406\u306f\u624b\u52d5\u3067\u884c\u3046\u306e\u3067\u3001\u660e\u78ba\u3067\u3059\u3002\u30ea\u30d5\u30a1\u30ec\u30f3\u30b9\u30ab\u30a6\u30f3\u30bf\u3084GC\u3092\u4f7f\u304a\u3046\u3068\u601d\u3048\u3070\u4f7f\u3048\u307e\u3059\u304c\u3001\u4f7f\u308f\u306a\u304f\u3066\u3082\u30d7\u30ed\u30b0\u30e9\u30e0\u306f\u7d44\u3081\u3066\u30ea\u30fc\u30af\u3082\u3057\u307e\u305b\u3093\u3002GC\u306a\u3057\u306eHaskell\u3092\u3088\u308a\u4e00\u822c\u7684\u306a\u30aa\u30d6\u30b8\u30a7\u30af\u30c8\u6307\u5411\u306e\u8a00\u8a9e\u306b\u4f3c\u305b\u305fRust\u306f\u306a\u304b\u306a\u304b\u7d20\u6674\u3089\u3057\u3044\u8a00\u8a9e\u306e\u3088\u3046\u306b\u601d\u3044\u307e\u3059\u3002\n\n", "tags": ["Rust0.11", "\u30b3\u30f3\u30d1\u30a4\u30e9", "LLVM"]}