{"context": "influxdb-ruby\u3068\u306f\nInfluxDB\u306e\u958b\u767a\u5143\u306einfluxdata\u304c\u51fa\u3057\u3066\u3044\u308bclient library\u3067\u3059\u3002\n\u305d\u306e\u30c6\u30b9\u30c8\u30b3\u30fc\u30c9\u3092\u901a\u3057\u3066\u3001influxdb\u3092\u5c11\u3057\u7406\u89e3\u3057\u3066\u3044\u3053\u3046\u3068\u3044\u3046\u8a66\u307f\u306e2\u56de\u76ee\u3067\u3059\u3002\n\ncases/async_client_spec.rb\n\u975e\u540c\u671f\u306e\u30c7\u30fc\u30bf\u767b\u9332\n...\n  describe \"#write_point\" do\n    it \"sends writes to client\" do\n      post_request = stub_request(:post, stub_url).to_return(status: 204)\n\n      (worker.max_post_points + 100).times do\n        subject.write_point('a', {})\n      end\n\n      # The timout code is fragile, and heavily dependent on system load\n      # (and scheduler decisions). On the CI, the system is less\n      # responsive and needs a bit more time.\n      timeout_stretch = ENV[\"TRAVIS\"] == \"true\" ? 10 : 3\n\n      Timeout.timeout(timeout_stretch * worker.sleep_interval) do\n        subject.stop!\n      end\n\n      worker.threads.each do |t|\n        expect(t.stop?).to be true\n      end\n\n      # exact times can be 2 or 3 (because we have 3 worker threads),\n      # but cannot be less than 2 due to MAX_POST_POINTS limit\n      expect(post_request).to have_been_requested.at_least_times(2)\n    end\n  end\n...\n\n\u3042\u308b\u7a0b\u5ea6\u306e\u6642\u9593\u306e\u9593(timeout_stretch * worker.sleep_interval)\u306b\nwriter\u304b\u3089request\u3092post\u3055\u308c\u3066\u3044\u308b\u3053\u3068\u3092\u78ba\u8a8d\n...\n  describe \"async options\" do\n    let(:async_options) do\n      {\n        max_post_points:    10,\n        max_queue_size:     100,\n        num_worker_threads: 1,\n        sleep_interval:     0.5\n      }\n    end\n\n    subject { worker }\n    before { worker.stop! }\n\n    specify { expect(subject.max_post_points).to be 10 }\n    specify { expect(subject.max_queue_size).to be 100 }\n    specify { expect(subject.num_worker_threads).to be 1 }\n    specify { expect(subject.sleep_interval).to be_within(0.0001).of(0.5) }\n  end\n...\n\n\u975e\u540c\u671f\u306eworker\u306b\n\u30ad\u30e5\u30fc\u3084\u30a4\u30f3\u30bf\u30fc\u30d0\u30eb\u6642\u9593\u3092\u8a2d\u5b9a\u3067\u304d\u308b\u3053\u3068\u3092\u78ba\u8a8d\nbe_within(0.0001).of(0.5)\n\u306f\u30a4\u30f3\u30bf\u30fc\u30d0\u30eb\u6642\u9593\u304c0.5\u79d2\u3067\u30d7\u30e9\u30b9\u30de\u30a4\u30ca\u30b90.0001\u79d2\u307e\u3067\u306f\u8a31\u5bb9\u3059\u308b\u3068\u3044\u3046\u610f\u5473\n\ncases/query_cluster_spec.rb\ncluster admin\u306e\u30e6\u30fc\u30b6\u3092\u4f5c\u6210\u3001\u4e00\u89a7\u53c2\u7167\u3001\u524a\u9664\n(\u30c7\u30fc\u30bf\u30d9\u30fc\u30b9\u3092\u4f5c\u6210\u3068\u3044\u3046\u3053\u3068\u3068\u306f\u5225)\n\ncases/query_continuous_query_spec.rb\nContinuous Queries\n...\n  describe \"#list_continuous_queries\" do\n    let(:query) { \"SHOW CONTINUOUS QUERIES\" }\n    let(:database) { \"testdb\" }\n    let(:response) do\n      { \"results\" => [{ \"series\" => [{ \"name\" => \"otherdb\", \"columns\" => %w(name query),\n                                       \"values\" => [[\"clicks_per_hour\", \"CREATE CONTINUOUS QUERY clicks_per_hour ON otherdb BEGIN SELECT count(name) INTO \\\"otherdb\\\".\\\"default\\\".clicksCount_1h FROM \\\"otherdb\\\".\\\"default\\\".clicks GROUP BY time(1h) END\"]] },\n                                     { \"name\" => \"testdb\", \"columns\" => %w(name query),\n                                       \"values\" => [[\"event_counts\", \"CREATE CONTINUOUS QUERY event_counts ON testdb BEGIN SELECT count(type) INTO \\\"testdb\\\".\\\"default\\\".typeCount_10m_byType FROM \\\"testdb\\\".\\\"default\\\".events GROUP BY time(10m), type END\"]] }] }] }\n    end\n\n    let(:expected_result) do\n      [{ \"name\" => \"event_counts\", \"query\" => \"CREATE CONTINUOUS QUERY event_counts ON testdb BEGIN SELECT count(type) INTO \\\"testdb\\\".\\\"default\\\".typeCount_10m_byType FROM \\\"testdb\\\".\\\"default\\\".events GROUP BY time(10m), type END\" }]\n    end\n\n    before do\n      stub_request(:get, \"http://influxdb.test:9999/query\").with(\n        query: { u: \"username\", p: \"password\", q: query }\n      ).to_return(body: JSON.generate(response), status: 200)\n    end\n\n    it \"should GET a list of continuous queries for specified db only\" do\n      expect(subject.list_continuous_queries(database)).to eq(expected_result)\n    end\n  end\n...\n\ntestdb\u306b\u767b\u9332\u3057\u305fCONTINUOUS QUERY\u306e\u5b9a\u7fa9\u3092\nlist_continuous_queries\u3067\u53d6\u5f97\u3067\u304d\u308b\u3053\u3068\u3092\u78ba\u8a8d\n...\n  describe \"#create_continuous_query\" do\n    let(:name)            { \"event_counts_per_10m_by_type\" }\n    let(:database)        { \"testdb\" }\n    let(:query)           { \"SELECT COUNT(type) INTO typeCount_10m_byType FROM events GROUP BY time(10m), type\" }\n    let(:every_interval)  { nil }\n    let(:for_interval)    { nil }\n\n    let(:clause) do\n      c = \"CREATE CONTINUOUS QUERY #{name} ON #{database}\"\n\n      if every_interval && for_interval\n        c << \" RESAMPLE EVERY #{every_interval} FOR #{for_interval}\"\n      elsif every_interval\n        c << \" RESAMPLE EVERY #{every_interval}\"\n      elsif for_interval\n        c << \" RESAMPLE FOR #{for_interval}\"\n      end\n\n      c << \" BEGIN\\n#{query}\\nEND\"\n    end\n\n    before do\n      stub_request(:get, \"http://influxdb.test:9999/query\").with(\n        query: { u: \"username\", p: \"password\", q: clause }\n      )\n    end\n\n    context \"without resampling\" do\n      it \"should GET to create a new continuous query\" do\n        expect(subject.create_continuous_query(name, database, query)).to be_a(Net::HTTPOK)\n      end\n    end\n\n    context \"with resampling\" do\n      context \"EVERY <interval>\" do\n        let(:every_interval) { \"10m\" }\n\n        it \"should GET to create a new continuous query\" do\n          expect(subject.create_continuous_query(name, database, query, resample_every: every_interval)).to be_a(Net::HTTPOK)\n        end\n      end\n\n      context \"FOR <interval>\" do\n        let(:for_interval) { \"7d\" }\n\n        it \"should GET to create a new continuous query\" do\n          expect(subject.create_continuous_query(name, database, query, resample_for: for_interval)).to be_a(Net::HTTPOK)\n        end\n      end\n\n      context \"EVERY <interval> FOR <interval>\" do\n        let(:every_interval)  { \"5m\" }\n        let(:for_interval)    { \"3w\" }\n\n        it \"should GET to create a new continuous query\" do\n          expect(subject.create_continuous_query(name, database, query, resample_for: for_interval, resample_every: every_interval)).to be_a(Net::HTTPOK)\n        end\n      end\n    end\n  end\n...\n\nCONTINUOUS QUERY\u306e\u767b\u9332\u3068\u5b9f\u884c\u5468\u671f\u306a\u3069\u306e\u30aa\u30d7\u30b7\u30e7\u30f3\u8a2d\u5b9a\u3092\u78ba\u8a8d\n\ncases/query_core_spec.rb\nInfluxDB::Query::Core\u306f\nbuilder\u3084query\u3084write_points\u306a\u3069\u306e\u57fa\u672c\u7684\u306a\u30e1\u30bd\u30c3\u30c9\u3092\u6301\u3064\u304c\u3001\n\u3053\u306espec\u3067\u306f\u3042\u307e\u308a\u30c6\u30b9\u30c8\u30b3\u30fc\u30c9\u3092\u66f8\u304b\u305a\u3001\nInfluxDB::Query::Core\u5185\u306e\u30e1\u30bd\u30c3\u30c9\u3092\u5229\u7528\u3059\u308b\n\u4ed6\u306e\u6a5f\u80fd\u3067\u30c6\u30b9\u30c8\u30b3\u30fc\u30c9\u3092\u66f8\u3044\u3066\u3044\u308b\u611f\u3058\u3002\n\u305f\u3060\u3001\u5358\u4f53\u30c6\u30b9\u30c8\u7684\u306a\u3082\u306e\u306f\u3042\u3063\u3066\u3082\u3044\u3044\u3088\u3046\u306a\u3001\u3001\u3001\n...\n  describe \"#query\" do\n    let(:query) { \"SELECT value FROM requests_per_minute WHERE time > 1437019900\" }\n    let(:response) do\n      { \"results\" => [{ \"series\" => [{ \"name\" => \"requests_per_minute\",\n                                       \"columns\" => %w(time value) }] }] }\n    end\n\n    before do\n      stub_request(:get, \"http://influxdb.test:9999/query\")\n        .with(query: { db: \"database\", precision: \"s\", u: \"username\", p: \"password\", q: query })\n        .to_return(body: JSON.generate(response), status: 200)\n    end\n\n    it \"should handle responses with no values\" do\n      # Some requests (such as trying to retrieve values from the future)\n      # return a result with no \"values\" key set.\n      expected_result = [{ \"name\" => \"requests_per_minute\", \"tags\" => nil, \"values\" => [] }]\n      expect(subject.query(query)).to eq(expected_result)\n    end\n  end\n...\n\ninfluxdb\u306b\u9001\u308bquery\u306e\u9001\u4fe1\u3068\u7d50\u679c\u53d6\u5f97\u3092\u78ba\u8a8d\n\ncases/query_database_spec.rb\ndatabase\u306e\u4f5c\u6210\u3001\u524a\u9664\u3001\u4e00\u89a7\u53c2\u7167\n...\n  describe \"#create_database\" do\n    describe \"from param\" do\n      let(:query) { \"CREATE DATABASE foo\" }\n\n      it \"should GET to create a new database\" do\n        expect(subject.create_database(\"foo\")).to be_a(Net::HTTPOK)\n      end\n    end\n\n    describe \"from config\" do\n      let(:query) { \"CREATE DATABASE database\" }\n\n      it \"should GET to create a new database using database name from config\" do\n        expect(subject.create_database).to be_a(Net::HTTPOK)\n      end\n    end\n  end\n...\n\ndatabase\u306e\u4f5c\u6210\u3092\u78ba\u8a8d\n\ncases/query_retention_policy_spec.rb\n\u30c7\u30fc\u30bf\u306e\u4fdd\u6301\u671f\u9593\u306e\u8a2d\u5b9a\u3002\nInfluxDB\u306fdatabase\u304c\u4f5c\u6210\u3055\u308c\u305f\u6642\u306bRETENTION POLICY\u3082\nautogen\u3092\u4ecb\u3057\u3066\u3001\u8a2d\u5b9a\u3059\u308b\u3002\n\u3053\u306e\u81ea\u52d5\u751f\u6210\u306f/var/lib/influxdb/meta\n\u3067\u7121\u52b9\u5316\u3059\u308b\u3053\u3068\u3082\u3067\u304d\u308b\n...\n  describe \"#create_retention_policy\" do\n    context \"default\" do\n      let(:query) { \"CREATE RETENTION POLICY \\\"1h.cpu\\\" ON foo DURATION 1h REPLICATION 2 DEFAULT\" }\n\n      it \"should GET to create a new database\" do\n        expect(subject.create_retention_policy('1h.cpu', 'foo', '1h', 2, true)).to be_a(Net::HTTPOK)\n      end\n    end\n\n    context \"non-default\" do\n      let(:query) { \"CREATE RETENTION POLICY \\\"1h.cpu\\\" ON foo DURATION 1h REPLICATION 2\" }\n\n      it \"should GET to create a new database\" do\n        expect(subject.create_retention_policy('1h.cpu', 'foo', '1h', 2)).to be_a(Net::HTTPOK)\n      end\n    end\n  end\n...\n\nRETENTION POLICY\u306e\u4f5c\u6210\u3092\u78ba\u8a8d\u3002\ndatabase\u306e\u30c7\u30d5\u30a9\u30eb\u30c8\u306b\u3059\u308b\u5834\u5408\u3001\u7b2c5\u5f15\u6570\u306btrue\u3092\u8a2d\u5b9a\n\ncases/query_series_spec.rb\nseries\u306e\u4f5c\u6210\u306a\u3069(?)\n\u30c6\u30b9\u30c8\u672a\u4f5c\u6210\n\ncases/query_shard_space_spec.rb\nshard\u95a2\u9023(?)\n\u30c6\u30b9\u30c8\u672a\u4f5c\u6210\n\ncases/query_shard_spec.rb\nshard\u95a2\u9023(?)\n\u30c6\u30b9\u30c8\u672a\u4f5c\u6210\n\ncases/query_user_spec.rb\n\u30e6\u30fc\u30b6\u306e\u4f5c\u6210\u3001\u524a\u9664\u3001\u4e00\u89a7\u53c2\u7167\u3084\u6a29\u9650\u5909\u66f4\n...\n  describe \"#create_database_user\" do\n    let(:user) { 'useruser' }\n    let(:pass) { 'passpass' }\n    let(:db) { 'foo' }\n    let(:query) { \"CREATE user #{user} WITH PASSWORD '#{pass}'; GRANT ALL ON #{db} TO #{user}\" }\n\n    context \"without specifying permissions\" do\n      it \"should GET to create a new database user with all permissions\" do\n        expect(subject.create_database_user(db, user, pass)).to be_a(Net::HTTPOK)\n      end\n    end\n\n    context \"with passing permission as argument\" do\n      let(:permission) { :read }\n      let(:query) { \"CREATE user #{user} WITH PASSWORD '#{pass}'; GRANT #{permission.to_s.upcase} ON #{db} TO #{user}\" }\n\n      it \"should GET to create a new database user with permission set\" do\n        expect(subject.create_database_user(db, user, pass, permissions: permission)).to be_a(Net::HTTPOK)\n      end\n    end\n  end\n...\n\n\u30e6\u30fc\u30b6\u306e\u4f5c\u6210(\u6a29\u9650\u8a2d\u5b9a\u4ed8\u304d\u306e\u30b1\u30fc\u30b9\u3082\u3042\u308a)\n\ncases/query_with_params_spec.rb\nquery\u3078\u306e\u30d1\u30e9\u30e1\u30fc\u30bf\u306e\u8a2d\u5b9a\n...\n  describe \"#query_with_params\" do\n    let(:query)           { \"select * from foo where bar > %{param}\" }\n    let(:compiled_query)  { subject.builder.build(query, query_params) }\n\n    context \"with empty params hash\" do\n      let(:query_params) { {} }\n      it { expect { compiled_query }.to raise_error ArgumentError }\n    end\n\n    context \"with empty params array\" do\n      let(:query_params) { [] }\n      it { expect { compiled_query }.to raise_error ArgumentError }\n    end\n\n    context \"with empty params\" do\n      let(:query_params) { nil }\n      it { expect { compiled_query }.to raise_error ArgumentError }\n    end\n\n    context \"with simple params\" do\n      let(:query_params) { { param: 42 } }\n      it { expect(compiled_query).to eq \"select * from foo where bar > 42\" }\n    end\n\n    context \"string escaping\" do\n      let(:query_params) { { param: \"string\" } }\n      it { expect(compiled_query).to eq \"select * from foo where bar > 'string'\" }\n    end\n  end\n...\n\nhash,array\u306f\u8a2d\u5b9a\u3067\u304d\u305a\u3001\nstring\u306f\u300c'\u300d\u3067\u62ec\u3089\u308c\u308b\nhttps://github.com/influxdata/influxdb-ruby/blob/master/lib/influxdb/query/builder.rb#L18-L27\n\ncases/querying_issue_7000_spec.rb\nhttps://github.com/influxdata/influxdb/issues/7000\n\u3067\u5bfe\u5fdc\u3057\u305f\u5185\u5bb9\u3078\u306e\u30c6\u30b9\u30c8\u30b3\u30fc\u30c9\u3002\nhttps://github.com/mhodson-qxbranch/influxdb-ruby/commit/044a350dc91997b4d690a9293c7048ce90b1ea48\nchunk_size\u30d1\u30e9\u30e1\u30fc\u30bf\u304c\u8ffd\u52a0\u3055\u308c\u305f\n...\n    context \"with multiple series with different tags\" do\n      let(:args) { { chunk_size: 100 } }\n      let(:extra_params) { { chunked: \"true\", chunk_size: \"100\" } }\n\n      let(:response_line_1) do\n        { \"results\" => [{ \"series\" => [{ \"name\" => \"access_times.service_1\", \"tags\" => { \"code\" => \"200\", \"result\" => \"failure\", \"status\" => \"OK\" }, \"columns\" => %w(time value), \"values\" => [[\"2015-07-08T07:15:22Z\", 327]] }] }] }\n      end\n      let(:response_line_2) do\n        { \"results\" => [{ \"series\" => [{ \"name\" => \"access_times.service_1\", \"tags\" => { \"code\" => \"500\", \"result\" => \"failure\", \"status\" => \"Internal Server Error\" }, \"columns\" => %w(time value), \"values\" => [[\"2015-07-08T06:15:22Z\", 873]] }] }] }\n      end\n      let(:response_line_3) do\n        { \"results\" => [{ \"series\" => [{ \"name\" => \"access_times.service_2\", \"tags\" => { \"code\" => \"200\", \"result\" => \"failure\", \"status\" => \"OK\" }, \"columns\" => %w(time value), \"values\" => [[\"2015-07-08T07:15:22Z\", 943]] }] }] }\n      end\n      let(:response_line_4) do\n        { \"results\" => [{ \"series\" => [{ \"name\" => \"access_times.service_2\", \"tags\" => { \"code\" => \"500\", \"result\" => \"failure\", \"status\" => \"Internal Server Error\" }, \"columns\" => %w(time value), \"values\" => [[\"2015-07-08T06:15:22Z\", 606]] }] }] }\n      end\n      let(:response) do\n        JSON.generate(response_line_1) + \"\\n\" + JSON.generate(response_line_2) + \"\\n\" + JSON.generate(response_line_3) + \"\\n\" + JSON.generate(response_line_4)\n      end\n      let(:expected_result) do\n        [{ \"name\" => \"access_times.service_1\", \"tags\" => { \"code\" => \"200\", \"result\" => \"failure\", \"status\" => \"OK\" }, \"values\" => [{ \"time\" => \"2015-07-08T07:15:22Z\", \"value\" => 327 }] },\n         { \"name\" => \"access_times.service_1\", \"tags\" => { \"code\" => \"500\", \"result\" => \"failure\", \"status\" => \"Internal Server Error\" }, \"values\" => [{ \"time\" => \"2015-07-08T06:15:22Z\", \"value\" => 873 }] },\n         { \"name\" => \"access_times.service_2\", \"tags\" => { \"code\" => \"200\", \"result\" => \"failure\", \"status\" => \"OK\" }, \"values\" => [{ \"time\" => \"2015-07-08T07:15:22Z\", \"value\" => 943 }] },\n         { \"name\" => \"access_times.service_2\", \"tags\" => { \"code\" => \"500\", \"result\" => \"failure\", \"status\" => \"Internal Server Error\" }, \"values\" => [{ \"time\" => \"2015-07-08T06:15:22Z\", \"value\" => 606 }] }]\n      end\n      let(:query) { \"SELECT * FROM /access_times.*/\" }\n\n      it \"should return array with 4 elements grouped by name and tags\" do\n        expect(subject.query(query)).to eq(expected_result)\n      end\n    end\n...\n\n\uff11\u3064\u306e\u30ec\u30b9\u30dd\u30f3\u30b9\u30c7\u30fc\u30bf\u3067\u8907\u6570tag\u3067\n\u6b63\u898f\u8868\u73fe\u6307\u5b9a\u306e\u8907\u6570\u30c6\u30fc\u30d6\u30eb\u304b\u3089\u306e\u7d50\u679c\u3092\u53d6\u5f97\u3067\u304d\u308b\n\ncases/querying_spec.rb\n\u30ea\u30af\u30a8\u30b9\u30c8\u306equery\u3068\u305d\u306e\u30ec\u30b9\u30dd\u30f3\u30b9\n...\n  before do\n    stub_request(:get, \"http://influxdb.test:9999/query\")\n      .with(query: { q: query, u: \"username\", p: \"password\", precision: 's', db: database }.merge(extra_params))\n      .to_return(body: JSON.generate(response))\n  end\n...\n    context \"with single series with multiple points\" do\n      let(:response) do\n        { \"results\" => [{ \"series\" => [{ \"name\" => \"cpu\", \"tags\" => { \"region\" => \"us\" },\n                                         \"columns\" => %w(time temp value),\n                                         \"values\" => [[\"2015-07-07T14:58:37Z\", 92, 0.3445], [\"2015-07-07T14:59:09Z\", 68, 0.8787]] }] }] }\n      end\n      let(:expected_result) do\n        [{ \"name\" => \"cpu\", \"tags\" => { \"region\" => \"us\" },\n           \"values\" => [{ \"time\" => \"2015-07-07T14:58:37Z\", \"temp\" => 92, \"value\" => 0.3445 },\n                        { \"time\" => \"2015-07-07T14:59:09Z\", \"temp\" => 68, \"value\" => 0.8787 }] }]\n      end\n      let(:query) { 'SELECT * FROM cpu' }\n\n      it \"should return array with single hash containing multiple values\" do\n        expect(subject.query(query)).to eq(expected_result)\n      end\n    end\n...\n\nquery\u30e1\u30bd\u30c3\u30c9\u304c\u60f3\u5b9a\u901a\u308a\u306b\u52d5\u304f\u304b\u3069\u3046\u304b\u306e\u78ba\u8a8d\u3002\nJSON.generate(response)\u3068expected_result\u3092\u7a81\u304d\u5408\u308f\u305b\u3066\u3044\u308b\u306e\u3067\u3001\nresults\u304b\u30891\u3064\u306ecpu\u3068\u3044\u3046series\u306e\u30c7\u30fc\u30bf\u304cjson\u304b\u3089\n\u53d6\u308a\u51fa\u305b\u3066\u3044\u308b\u304b\u306e\u78ba\u8a8d\u3050\u3089\u3044\u306a\u306e\u3067\u3001\n\u3069\u3061\u3089\u304b\u3068\u3044\u3046\u3068\u30ec\u30b9\u30dd\u30f3\u30b9\u30c7\u30fc\u30bf\u306e\u6271\u3044\u306b\u95a2\u3059\u308b\u30c6\u30b9\u30c8\u306b\u3082\u898b\u3048\u308b\u3002\n\u3053\u306e\u30c6\u30b9\u30c8\u30b3\u30fc\u30c9\u4ee5\u964d\u306e\n - with series with different tags\n - with multiple series with different tags\n - with multiple series for explicit value only\n\u306a\u3069\u3082\nresponse\u3068expected_result\u3092\u5207\u308a\u66ff\u3048\u3066\u3044\u308b\u3060\u3051\u306a\u306e\u3067\u3001\u305d\u3046\u898b\u3048\u308b\n...\n    context \"with epoch set to seconds\" do\n      let(:args) { { epoch: 's' } }\n      let(:extra_params) { { epoch: 's' } }\n\n      let(:response) do\n        { \"results\" => [{ \"series\" => [{ \"name\" => \"cpu\", \"tags\" => { \"region\" => \"pl\" }, \"columns\" => %w(time temp value), \"values\" => [[1_438_580_576, 34, 0.343443]] },\n                                       { \"name\" => \"cpu\", \"tags\" => { \"region\" => \"us\" }, \"columns\" => %w(time temp value), \"values\" => [[1_438_612_976, 92, 0.3445], [1_438_612_989, 68, 0.8787]] }] }] }\n      end\n      let(:expected_result) do\n        [{ \"name\" => \"cpu\", \"tags\" => { \"region\" => \"pl\" },\n           \"values\" => [{ \"time\" => 1_438_580_576, \"temp\" => 34, \"value\" => 0.343443 }] },\n         { \"name\" => \"cpu\", \"tags\" => { \"region\" => \"us\" },\n           \"values\" => [{ \"time\" => 1_438_612_976, \"temp\" => 92, \"value\" => 0.3445 },\n                        { \"time\" => 1_438_612_989, \"temp\" => 68, \"value\" => 0.8787 }] }]\n      end\n      let(:query) { 'SELECT * FROM cpu' }\n\n      it \"should return results with integer timestamp\" do\n        expect(subject.query(query)).to eq(expected_result)\n      end\n    end\n...\n\nEpoch time\u306e\u6307\u5b9a\u3082\u3067\u304d\u308b\n\nEpoch time is the amount of time that has elapsed since 00:00:00 Coordinated Universal Time (UTC), Thursday, 1 January 1970.\ns\u306f\u79d2\n\n\ncases/retry_requests_spec.rb\n\u30ea\u30af\u30a8\u30b9\u30c8\u306e\u30ea\u30c8\u30e9\u30a4\n...\n    context \"when retry is 'n'\" do\n      let(:args) { { retry: 3 } }\n\n      it \"raise error after 'n' attemps\" do\n        expect(client).to receive(:sleep).exactly(3).times\n        expect { subject }.to raise_error(InfluxDB::ConnectionError) do |e|\n          expect(e.cause).to be_an_instance_of(Timeout::Error)\n        end\n      end\n    end\n...\n\n\u6307\u5b9a\u56de\u6570\u5206\u306e\u30ea\u30c8\u30e9\u30a4\u3092\u884c\u3063\u305f\u304b\u3092\u78ba\u8a8d\n...\n    context \"when retry is -1\" do\n      let(:args) { { retry: -1 } }\n      before do\n        stub_request(:post, \"http://influxdb.test:9999/write\")\n          .with(\n            query: { u: \"username\", p: \"password\", precision: 's', db: database },\n            headers: { \"Content-Type\" => \"application/octet-stream\" },\n            body: body\n          )\n          .to_raise(Timeout::Error).then\n          .to_raise(Timeout::Error).then\n          .to_raise(Timeout::Error).then\n          .to_raise(Timeout::Error).then\n          .to_return(status: 204)\n      end\n\n      it \"keep trying until get the connection\" do\n        expect(client).to receive(:sleep).exactly(4).times\n        expect { subject }.to_not raise_error\n      end\n    end\n...\n\nretry\u30aa\u30d7\u30b7\u30e7\u30f3\u306b-1\u3092\u8a2d\u5b9a\u3057\u305f\u5834\u5408\u306f\nretry\u3057\u7d9a\u3051\u308b\u3053\u3068\u3092\u78ba\u8a8d\n\ncases/udp_client_spec.rb\nudp\u3067\u30c7\u30fc\u30bf\u767b\u9332\n...\n  let(:client) { described_class.new(udp: { host: \"localhost\", port: 44_444 }) }\n\n  specify { expect(client.writer).to be_a(InfluxDB::Writer::UDP) }\n\n  describe \"#write\" do\n    let(:message) { 'responses,region=eu value=5i' }\n\n    it \"sends a UPD packet\" do\n      s = UDPSocket.new\n      s.bind(\"localhost\", 44_444)\n\n      client.write_point(\"responses\", values: { value: 5 }, tags: { region: 'eu' })\n\n      rec_message = s.recvfrom(30).first\n      expect(rec_message).to eq message\n    end\n  end\n...\n\n\u30ed\u30fc\u30ab\u30eb\u306b\u3042\u3051\u305fudp\u30bd\u30b1\u30c3\u30c8\u3092\u4ecb\u3057\u3066\u3001\nUDP\u3067\u30c7\u30fc\u30bf\u767b\u9332\u304c\u3067\u304d\u305d\u3046\u304b\u3092\u78ba\u8a8d\n\ncases/write_points_spec.rb\n\u5024\u306e\u767b\u9332\n...\n  describe \"#write_point\" do\n    let(:series) { \"cpu\" }\n    let(:data) do\n      { tags: { region: 'us', host: 'server_1' },\n        values: { temp: 88, value: 54 } }\n    end\n    let(:body) do\n      InfluxDB::PointValue.new(data.merge(series: series)).dump\n    end\n\n    before do\n      stub_request(:post, \"http://influxdb.test:9999/write\").with(\n        query: { u: \"username\", p: \"password\", precision: 's', db: database },\n        headers: { \"Content-Type\" => \"application/octet-stream\" },\n        body: body\n      ).to_return(status: 204)\n    end\n\n    it \"should POST to add single point\" do\n      expect(subject.write_point(series, data)).to be_a(Net::HTTPNoContent)\n    end\n\n    it \"should not mutate data object\" do\n      original_data = data\n      subject.write_point(series, data)\n      expect(data[:series]).to be_nil\n      expect(original_data).to eql(data)\n    end\n  end\n...\n\n1\u3064\u306e\u30c7\u30fc\u30bf\u3060\u3051\u304c\u767b\u9332\u3067\u304d\u308bwrite_point\u306e\u78ba\u8a8d\n...\ndescribe \"#write_points\" do\n    context \"with multiple series\" do\n      let(:data) do\n        [{ series: 'cpu',\n           tags: { region: 'us', host: 'server_1' },\n           values: { temp: 88, value: 54 } },\n         { series: 'gpu',\n           tags: { region: 'uk', host: 'server_5' },\n           values: { value: 0.5435345 } }]\n      end\n      let(:body) do\n        data.map do |point|\n          InfluxDB::PointValue.new(point).dump\n        end.join(\"\\n\")\n      end\n\n      before do\n        stub_request(:post, \"http://influxdb.test:9999/write\").with(\n          query: { u: \"username\", p: \"password\", precision: 's', db: database },\n          headers: { \"Content-Type\" => \"application/octet-stream\" },\n          body: body\n        ).to_return(status: 204)\n      end\n\n      it \"should POST multiple points\" do\n        expect(subject.write_points(data)).to be_a(Net::HTTPNoContent)\n      end\n    end\n  ...\n...\n\n\u8907\u6570series\u3078\u306e\u30c7\u30fc\u30bf\u767b\u9332\u3092\u78ba\u8a8d\n\n\u7d42\u308f\u308a\u306b\ninfluxdb\u81ea\u4f53\u306e\u30c6\u30b9\u30c8\u3067\u306f\u306a\u304f\u3001\ninfluxdb\u3092\u5229\u7528\u3059\u308b\u30af\u30e9\u30a4\u30a2\u30f3\u30c8\u5074\u306e\u30c6\u30b9\u30c8\u3067\u3059\u306e\u3067\u3001\nstub\u3092\u5229\u7528\u3057\u3066\u60f3\u5b9a\u901a\u308a\u306b\u30d1\u30e9\u30e1\u30fc\u30bf\u3084config\u306e\u8a2d\u5b9a\u304c\u3067\u304d\u308b\u3001\n\u3068\u3044\u3046\u78ba\u8a8d\u304c\u591a\u304b\u3063\u305f\u3088\u3046\u306b\u601d\u3048\u307e\u3059\u3002\ninfluxdb-ruby\u3068\u306f\nInfluxDB\u306e\u958b\u767a\u5143\u306einfluxdata\u304c\u51fa\u3057\u3066\u3044\u308bclient library\u3067\u3059\u3002\n\u305d\u306e\u30c6\u30b9\u30c8\u30b3\u30fc\u30c9\u3092\u901a\u3057\u3066\u3001influxdb\u3092\u5c11\u3057\u7406\u89e3\u3057\u3066\u3044\u3053\u3046\u3068\u3044\u3046\u8a66\u307f\u306e2\u56de\u76ee\u3067\u3059\u3002\n\n## cases/async_client_spec.rb\n\u975e\u540c\u671f\u306e\u30c7\u30fc\u30bf\u767b\u9332\n\n```\n...\n  describe \"#write_point\" do\n    it \"sends writes to client\" do\n      post_request = stub_request(:post, stub_url).to_return(status: 204)\n\n      (worker.max_post_points + 100).times do\n        subject.write_point('a', {})\n      end\n\n      # The timout code is fragile, and heavily dependent on system load\n      # (and scheduler decisions). On the CI, the system is less\n      # responsive and needs a bit more time.\n      timeout_stretch = ENV[\"TRAVIS\"] == \"true\" ? 10 : 3\n\n      Timeout.timeout(timeout_stretch * worker.sleep_interval) do\n        subject.stop!\n      end\n\n      worker.threads.each do |t|\n        expect(t.stop?).to be true\n      end\n\n      # exact times can be 2 or 3 (because we have 3 worker threads),\n      # but cannot be less than 2 due to MAX_POST_POINTS limit\n      expect(post_request).to have_been_requested.at_least_times(2)\n    end\n  end\n...\n```\n\n\u3042\u308b\u7a0b\u5ea6\u306e\u6642\u9593\u306e\u9593(`timeout_stretch * worker.sleep_interval`)\u306b\nwriter\u304b\u3089request\u3092post\u3055\u308c\u3066\u3044\u308b\u3053\u3068\u3092\u78ba\u8a8d\n\n```\n...\n  describe \"async options\" do\n    let(:async_options) do\n      {\n        max_post_points:    10,\n        max_queue_size:     100,\n        num_worker_threads: 1,\n        sleep_interval:     0.5\n      }\n    end\n\n    subject { worker }\n    before { worker.stop! }\n\n    specify { expect(subject.max_post_points).to be 10 }\n    specify { expect(subject.max_queue_size).to be 100 }\n    specify { expect(subject.num_worker_threads).to be 1 }\n    specify { expect(subject.sleep_interval).to be_within(0.0001).of(0.5) }\n  end\n...\n```\n\u975e\u540c\u671f\u306eworker\u306b\n\u30ad\u30e5\u30fc\u3084\u30a4\u30f3\u30bf\u30fc\u30d0\u30eb\u6642\u9593\u3092\u8a2d\u5b9a\u3067\u304d\u308b\u3053\u3068\u3092\u78ba\u8a8d\n`be_within(0.0001).of(0.5)`\n\u306f\u30a4\u30f3\u30bf\u30fc\u30d0\u30eb\u6642\u9593\u304c0.5\u79d2\u3067\u30d7\u30e9\u30b9\u30de\u30a4\u30ca\u30b90.0001\u79d2\u307e\u3067\u306f\u8a31\u5bb9\u3059\u308b\u3068\u3044\u3046\u610f\u5473\n\n## cases/query_cluster_spec.rb\ncluster admin\u306e\u30e6\u30fc\u30b6\u3092\u4f5c\u6210\u3001\u4e00\u89a7\u53c2\u7167\u3001\u524a\u9664\n(\u30c7\u30fc\u30bf\u30d9\u30fc\u30b9\u3092\u4f5c\u6210\u3068\u3044\u3046\u3053\u3068\u3068\u306f\u5225)\n\n## cases/query_continuous_query_spec.rb\nContinuous Queries\n\n```\n...\n  describe \"#list_continuous_queries\" do\n    let(:query) { \"SHOW CONTINUOUS QUERIES\" }\n    let(:database) { \"testdb\" }\n    let(:response) do\n      { \"results\" => [{ \"series\" => [{ \"name\" => \"otherdb\", \"columns\" => %w(name query),\n                                       \"values\" => [[\"clicks_per_hour\", \"CREATE CONTINUOUS QUERY clicks_per_hour ON otherdb BEGIN SELECT count(name) INTO \\\"otherdb\\\".\\\"default\\\".clicksCount_1h FROM \\\"otherdb\\\".\\\"default\\\".clicks GROUP BY time(1h) END\"]] },\n                                     { \"name\" => \"testdb\", \"columns\" => %w(name query),\n                                       \"values\" => [[\"event_counts\", \"CREATE CONTINUOUS QUERY event_counts ON testdb BEGIN SELECT count(type) INTO \\\"testdb\\\".\\\"default\\\".typeCount_10m_byType FROM \\\"testdb\\\".\\\"default\\\".events GROUP BY time(10m), type END\"]] }] }] }\n    end\n\n    let(:expected_result) do\n      [{ \"name\" => \"event_counts\", \"query\" => \"CREATE CONTINUOUS QUERY event_counts ON testdb BEGIN SELECT count(type) INTO \\\"testdb\\\".\\\"default\\\".typeCount_10m_byType FROM \\\"testdb\\\".\\\"default\\\".events GROUP BY time(10m), type END\" }]\n    end\n\n    before do\n      stub_request(:get, \"http://influxdb.test:9999/query\").with(\n        query: { u: \"username\", p: \"password\", q: query }\n      ).to_return(body: JSON.generate(response), status: 200)\n    end\n\n    it \"should GET a list of continuous queries for specified db only\" do\n      expect(subject.list_continuous_queries(database)).to eq(expected_result)\n    end\n  end\n...\n```\ntestdb\u306b\u767b\u9332\u3057\u305fCONTINUOUS QUERY\u306e\u5b9a\u7fa9\u3092\nlist_continuous_queries\u3067\u53d6\u5f97\u3067\u304d\u308b\u3053\u3068\u3092\u78ba\u8a8d\n\n```\n...\n  describe \"#create_continuous_query\" do\n    let(:name)            { \"event_counts_per_10m_by_type\" }\n    let(:database)        { \"testdb\" }\n    let(:query)           { \"SELECT COUNT(type) INTO typeCount_10m_byType FROM events GROUP BY time(10m), type\" }\n    let(:every_interval)  { nil }\n    let(:for_interval)    { nil }\n\n    let(:clause) do\n      c = \"CREATE CONTINUOUS QUERY #{name} ON #{database}\"\n\n      if every_interval && for_interval\n        c << \" RESAMPLE EVERY #{every_interval} FOR #{for_interval}\"\n      elsif every_interval\n        c << \" RESAMPLE EVERY #{every_interval}\"\n      elsif for_interval\n        c << \" RESAMPLE FOR #{for_interval}\"\n      end\n\n      c << \" BEGIN\\n#{query}\\nEND\"\n    end\n\n    before do\n      stub_request(:get, \"http://influxdb.test:9999/query\").with(\n        query: { u: \"username\", p: \"password\", q: clause }\n      )\n    end\n\n    context \"without resampling\" do\n      it \"should GET to create a new continuous query\" do\n        expect(subject.create_continuous_query(name, database, query)).to be_a(Net::HTTPOK)\n      end\n    end\n\n    context \"with resampling\" do\n      context \"EVERY <interval>\" do\n        let(:every_interval) { \"10m\" }\n\n        it \"should GET to create a new continuous query\" do\n          expect(subject.create_continuous_query(name, database, query, resample_every: every_interval)).to be_a(Net::HTTPOK)\n        end\n      end\n\n      context \"FOR <interval>\" do\n        let(:for_interval) { \"7d\" }\n\n        it \"should GET to create a new continuous query\" do\n          expect(subject.create_continuous_query(name, database, query, resample_for: for_interval)).to be_a(Net::HTTPOK)\n        end\n      end\n\n      context \"EVERY <interval> FOR <interval>\" do\n        let(:every_interval)  { \"5m\" }\n        let(:for_interval)    { \"3w\" }\n\n        it \"should GET to create a new continuous query\" do\n          expect(subject.create_continuous_query(name, database, query, resample_for: for_interval, resample_every: every_interval)).to be_a(Net::HTTPOK)\n        end\n      end\n    end\n  end\n...\n```\nCONTINUOUS QUERY\u306e\u767b\u9332\u3068\u5b9f\u884c\u5468\u671f\u306a\u3069\u306e\u30aa\u30d7\u30b7\u30e7\u30f3\u8a2d\u5b9a\u3092\u78ba\u8a8d\n\n## cases/query_core_spec.rb\nInfluxDB::Query::Core\u306f\nbuilder\u3084query\u3084write_points\u306a\u3069\u306e\u57fa\u672c\u7684\u306a\u30e1\u30bd\u30c3\u30c9\u3092\u6301\u3064\u304c\u3001\n\u3053\u306espec\u3067\u306f\u3042\u307e\u308a\u30c6\u30b9\u30c8\u30b3\u30fc\u30c9\u3092\u66f8\u304b\u305a\u3001\nInfluxDB::Query::Core\u5185\u306e\u30e1\u30bd\u30c3\u30c9\u3092\u5229\u7528\u3059\u308b\n\u4ed6\u306e\u6a5f\u80fd\u3067\u30c6\u30b9\u30c8\u30b3\u30fc\u30c9\u3092\u66f8\u3044\u3066\u3044\u308b\u611f\u3058\u3002\n\u305f\u3060\u3001\u5358\u4f53\u30c6\u30b9\u30c8\u7684\u306a\u3082\u306e\u306f\u3042\u3063\u3066\u3082\u3044\u3044\u3088\u3046\u306a\u3001\u3001\u3001\n\n```\n...\n  describe \"#query\" do\n    let(:query) { \"SELECT value FROM requests_per_minute WHERE time > 1437019900\" }\n    let(:response) do\n      { \"results\" => [{ \"series\" => [{ \"name\" => \"requests_per_minute\",\n                                       \"columns\" => %w(time value) }] }] }\n    end\n\n    before do\n      stub_request(:get, \"http://influxdb.test:9999/query\")\n        .with(query: { db: \"database\", precision: \"s\", u: \"username\", p: \"password\", q: query })\n        .to_return(body: JSON.generate(response), status: 200)\n    end\n\n    it \"should handle responses with no values\" do\n      # Some requests (such as trying to retrieve values from the future)\n      # return a result with no \"values\" key set.\n      expected_result = [{ \"name\" => \"requests_per_minute\", \"tags\" => nil, \"values\" => [] }]\n      expect(subject.query(query)).to eq(expected_result)\n    end\n  end\n...\n```\ninfluxdb\u306b\u9001\u308bquery\u306e\u9001\u4fe1\u3068\u7d50\u679c\u53d6\u5f97\u3092\u78ba\u8a8d\n\n## cases/query_database_spec.rb\ndatabase\u306e\u4f5c\u6210\u3001\u524a\u9664\u3001\u4e00\u89a7\u53c2\u7167\n\n```\n...\n  describe \"#create_database\" do\n    describe \"from param\" do\n      let(:query) { \"CREATE DATABASE foo\" }\n\n      it \"should GET to create a new database\" do\n        expect(subject.create_database(\"foo\")).to be_a(Net::HTTPOK)\n      end\n    end\n\n    describe \"from config\" do\n      let(:query) { \"CREATE DATABASE database\" }\n\n      it \"should GET to create a new database using database name from config\" do\n        expect(subject.create_database).to be_a(Net::HTTPOK)\n      end\n    end\n  end\n...\n```\ndatabase\u306e\u4f5c\u6210\u3092\u78ba\u8a8d\n\n## cases/query_retention_policy_spec.rb\n\u30c7\u30fc\u30bf\u306e\u4fdd\u6301\u671f\u9593\u306e\u8a2d\u5b9a\u3002\nInfluxDB\u306fdatabase\u304c\u4f5c\u6210\u3055\u308c\u305f\u6642\u306bRETENTION POLICY\u3082\nautogen\u3092\u4ecb\u3057\u3066\u3001\u8a2d\u5b9a\u3059\u308b\u3002\n\u3053\u306e\u81ea\u52d5\u751f\u6210\u306f`/var/lib/influxdb/meta`\n\u3067\u7121\u52b9\u5316\u3059\u308b\u3053\u3068\u3082\u3067\u304d\u308b\n\n```\n...\n  describe \"#create_retention_policy\" do\n    context \"default\" do\n      let(:query) { \"CREATE RETENTION POLICY \\\"1h.cpu\\\" ON foo DURATION 1h REPLICATION 2 DEFAULT\" }\n\n      it \"should GET to create a new database\" do\n        expect(subject.create_retention_policy('1h.cpu', 'foo', '1h', 2, true)).to be_a(Net::HTTPOK)\n      end\n    end\n\n    context \"non-default\" do\n      let(:query) { \"CREATE RETENTION POLICY \\\"1h.cpu\\\" ON foo DURATION 1h REPLICATION 2\" }\n\n      it \"should GET to create a new database\" do\n        expect(subject.create_retention_policy('1h.cpu', 'foo', '1h', 2)).to be_a(Net::HTTPOK)\n      end\n    end\n  end\n...\n```\nRETENTION POLICY\u306e\u4f5c\u6210\u3092\u78ba\u8a8d\u3002\ndatabase\u306e\u30c7\u30d5\u30a9\u30eb\u30c8\u306b\u3059\u308b\u5834\u5408\u3001\u7b2c5\u5f15\u6570\u306btrue\u3092\u8a2d\u5b9a\n\n## cases/query_series_spec.rb\nseries\u306e\u4f5c\u6210\u306a\u3069(?)\n\u30c6\u30b9\u30c8\u672a\u4f5c\u6210\n\n## cases/query_shard_space_spec.rb\nshard\u95a2\u9023(?)\n\u30c6\u30b9\u30c8\u672a\u4f5c\u6210\n\n## cases/query_shard_spec.rb\nshard\u95a2\u9023(?)\n\u30c6\u30b9\u30c8\u672a\u4f5c\u6210\n\n## cases/query_user_spec.rb\n\u30e6\u30fc\u30b6\u306e\u4f5c\u6210\u3001\u524a\u9664\u3001\u4e00\u89a7\u53c2\u7167\u3084\u6a29\u9650\u5909\u66f4\n\n```\n...\n  describe \"#create_database_user\" do\n    let(:user) { 'useruser' }\n    let(:pass) { 'passpass' }\n    let(:db) { 'foo' }\n    let(:query) { \"CREATE user #{user} WITH PASSWORD '#{pass}'; GRANT ALL ON #{db} TO #{user}\" }\n\n    context \"without specifying permissions\" do\n      it \"should GET to create a new database user with all permissions\" do\n        expect(subject.create_database_user(db, user, pass)).to be_a(Net::HTTPOK)\n      end\n    end\n\n    context \"with passing permission as argument\" do\n      let(:permission) { :read }\n      let(:query) { \"CREATE user #{user} WITH PASSWORD '#{pass}'; GRANT #{permission.to_s.upcase} ON #{db} TO #{user}\" }\n\n      it \"should GET to create a new database user with permission set\" do\n        expect(subject.create_database_user(db, user, pass, permissions: permission)).to be_a(Net::HTTPOK)\n      end\n    end\n  end\n...\n```\n\u30e6\u30fc\u30b6\u306e\u4f5c\u6210(\u6a29\u9650\u8a2d\u5b9a\u4ed8\u304d\u306e\u30b1\u30fc\u30b9\u3082\u3042\u308a)\n\n## cases/query_with_params_spec.rb\nquery\u3078\u306e\u30d1\u30e9\u30e1\u30fc\u30bf\u306e\u8a2d\u5b9a\n\n```\n...\n  describe \"#query_with_params\" do\n    let(:query)           { \"select * from foo where bar > %{param}\" }\n    let(:compiled_query)  { subject.builder.build(query, query_params) }\n\n    context \"with empty params hash\" do\n      let(:query_params) { {} }\n      it { expect { compiled_query }.to raise_error ArgumentError }\n    end\n\n    context \"with empty params array\" do\n      let(:query_params) { [] }\n      it { expect { compiled_query }.to raise_error ArgumentError }\n    end\n\n    context \"with empty params\" do\n      let(:query_params) { nil }\n      it { expect { compiled_query }.to raise_error ArgumentError }\n    end\n\n    context \"with simple params\" do\n      let(:query_params) { { param: 42 } }\n      it { expect(compiled_query).to eq \"select * from foo where bar > 42\" }\n    end\n\n    context \"string escaping\" do\n      let(:query_params) { { param: \"string\" } }\n      it { expect(compiled_query).to eq \"select * from foo where bar > 'string'\" }\n    end\n  end\n...\n```\n\nhash,array\u306f\u8a2d\u5b9a\u3067\u304d\u305a\u3001\nstring\u306f\u300c'\u300d\u3067\u62ec\u3089\u308c\u308b\nhttps://github.com/influxdata/influxdb-ruby/blob/master/lib/influxdb/query/builder.rb#L18-L27\n\n## cases/querying_issue_7000_spec.rb\nhttps://github.com/influxdata/influxdb/issues/7000\n\u3067\u5bfe\u5fdc\u3057\u305f\u5185\u5bb9\u3078\u306e\u30c6\u30b9\u30c8\u30b3\u30fc\u30c9\u3002\nhttps://github.com/mhodson-qxbranch/influxdb-ruby/commit/044a350dc91997b4d690a9293c7048ce90b1ea48\nchunk_size\u30d1\u30e9\u30e1\u30fc\u30bf\u304c\u8ffd\u52a0\u3055\u308c\u305f\n\n```\n...\n    context \"with multiple series with different tags\" do\n      let(:args) { { chunk_size: 100 } }\n      let(:extra_params) { { chunked: \"true\", chunk_size: \"100\" } }\n\n      let(:response_line_1) do\n        { \"results\" => [{ \"series\" => [{ \"name\" => \"access_times.service_1\", \"tags\" => { \"code\" => \"200\", \"result\" => \"failure\", \"status\" => \"OK\" }, \"columns\" => %w(time value), \"values\" => [[\"2015-07-08T07:15:22Z\", 327]] }] }] }\n      end\n      let(:response_line_2) do\n        { \"results\" => [{ \"series\" => [{ \"name\" => \"access_times.service_1\", \"tags\" => { \"code\" => \"500\", \"result\" => \"failure\", \"status\" => \"Internal Server Error\" }, \"columns\" => %w(time value), \"values\" => [[\"2015-07-08T06:15:22Z\", 873]] }] }] }\n      end\n      let(:response_line_3) do\n        { \"results\" => [{ \"series\" => [{ \"name\" => \"access_times.service_2\", \"tags\" => { \"code\" => \"200\", \"result\" => \"failure\", \"status\" => \"OK\" }, \"columns\" => %w(time value), \"values\" => [[\"2015-07-08T07:15:22Z\", 943]] }] }] }\n      end\n      let(:response_line_4) do\n        { \"results\" => [{ \"series\" => [{ \"name\" => \"access_times.service_2\", \"tags\" => { \"code\" => \"500\", \"result\" => \"failure\", \"status\" => \"Internal Server Error\" }, \"columns\" => %w(time value), \"values\" => [[\"2015-07-08T06:15:22Z\", 606]] }] }] }\n      end\n      let(:response) do\n        JSON.generate(response_line_1) + \"\\n\" + JSON.generate(response_line_2) + \"\\n\" + JSON.generate(response_line_3) + \"\\n\" + JSON.generate(response_line_4)\n      end\n      let(:expected_result) do\n        [{ \"name\" => \"access_times.service_1\", \"tags\" => { \"code\" => \"200\", \"result\" => \"failure\", \"status\" => \"OK\" }, \"values\" => [{ \"time\" => \"2015-07-08T07:15:22Z\", \"value\" => 327 }] },\n         { \"name\" => \"access_times.service_1\", \"tags\" => { \"code\" => \"500\", \"result\" => \"failure\", \"status\" => \"Internal Server Error\" }, \"values\" => [{ \"time\" => \"2015-07-08T06:15:22Z\", \"value\" => 873 }] },\n         { \"name\" => \"access_times.service_2\", \"tags\" => { \"code\" => \"200\", \"result\" => \"failure\", \"status\" => \"OK\" }, \"values\" => [{ \"time\" => \"2015-07-08T07:15:22Z\", \"value\" => 943 }] },\n         { \"name\" => \"access_times.service_2\", \"tags\" => { \"code\" => \"500\", \"result\" => \"failure\", \"status\" => \"Internal Server Error\" }, \"values\" => [{ \"time\" => \"2015-07-08T06:15:22Z\", \"value\" => 606 }] }]\n      end\n      let(:query) { \"SELECT * FROM /access_times.*/\" }\n\n      it \"should return array with 4 elements grouped by name and tags\" do\n        expect(subject.query(query)).to eq(expected_result)\n      end\n    end\n...\n```\n\uff11\u3064\u306e\u30ec\u30b9\u30dd\u30f3\u30b9\u30c7\u30fc\u30bf\u3067\u8907\u6570tag\u3067\n\u6b63\u898f\u8868\u73fe\u6307\u5b9a\u306e\u8907\u6570\u30c6\u30fc\u30d6\u30eb\u304b\u3089\u306e\u7d50\u679c\u3092\u53d6\u5f97\u3067\u304d\u308b\n\n## cases/querying_spec.rb\n\u30ea\u30af\u30a8\u30b9\u30c8\u306equery\u3068\u305d\u306e\u30ec\u30b9\u30dd\u30f3\u30b9\n\n```\n...\n  before do\n    stub_request(:get, \"http://influxdb.test:9999/query\")\n      .with(query: { q: query, u: \"username\", p: \"password\", precision: 's', db: database }.merge(extra_params))\n      .to_return(body: JSON.generate(response))\n  end\n...\n    context \"with single series with multiple points\" do\n      let(:response) do\n        { \"results\" => [{ \"series\" => [{ \"name\" => \"cpu\", \"tags\" => { \"region\" => \"us\" },\n                                         \"columns\" => %w(time temp value),\n                                         \"values\" => [[\"2015-07-07T14:58:37Z\", 92, 0.3445], [\"2015-07-07T14:59:09Z\", 68, 0.8787]] }] }] }\n      end\n      let(:expected_result) do\n        [{ \"name\" => \"cpu\", \"tags\" => { \"region\" => \"us\" },\n           \"values\" => [{ \"time\" => \"2015-07-07T14:58:37Z\", \"temp\" => 92, \"value\" => 0.3445 },\n                        { \"time\" => \"2015-07-07T14:59:09Z\", \"temp\" => 68, \"value\" => 0.8787 }] }]\n      end\n      let(:query) { 'SELECT * FROM cpu' }\n\n      it \"should return array with single hash containing multiple values\" do\n        expect(subject.query(query)).to eq(expected_result)\n      end\n    end\n...\n```\nquery\u30e1\u30bd\u30c3\u30c9\u304c\u60f3\u5b9a\u901a\u308a\u306b\u52d5\u304f\u304b\u3069\u3046\u304b\u306e\u78ba\u8a8d\u3002\nJSON.generate(response)\u3068expected_result\u3092\u7a81\u304d\u5408\u308f\u305b\u3066\u3044\u308b\u306e\u3067\u3001\nresults\u304b\u30891\u3064\u306ecpu\u3068\u3044\u3046series\u306e\u30c7\u30fc\u30bf\u304cjson\u304b\u3089\n\u53d6\u308a\u51fa\u305b\u3066\u3044\u308b\u304b\u306e\u78ba\u8a8d\u3050\u3089\u3044\u306a\u306e\u3067\u3001\n\u3069\u3061\u3089\u304b\u3068\u3044\u3046\u3068\u30ec\u30b9\u30dd\u30f3\u30b9\u30c7\u30fc\u30bf\u306e\u6271\u3044\u306b\u95a2\u3059\u308b\u30c6\u30b9\u30c8\u306b\u3082\u898b\u3048\u308b\u3002\n\u3053\u306e\u30c6\u30b9\u30c8\u30b3\u30fc\u30c9\u4ee5\u964d\u306e\n - with series with different tags\n - with multiple series with different tags\n - with multiple series for explicit value only\n\u306a\u3069\u3082\nresponse\u3068expected_result\u3092\u5207\u308a\u66ff\u3048\u3066\u3044\u308b\u3060\u3051\u306a\u306e\u3067\u3001\u305d\u3046\u898b\u3048\u308b\n\n```\n...\n    context \"with epoch set to seconds\" do\n      let(:args) { { epoch: 's' } }\n      let(:extra_params) { { epoch: 's' } }\n\n      let(:response) do\n        { \"results\" => [{ \"series\" => [{ \"name\" => \"cpu\", \"tags\" => { \"region\" => \"pl\" }, \"columns\" => %w(time temp value), \"values\" => [[1_438_580_576, 34, 0.343443]] },\n                                       { \"name\" => \"cpu\", \"tags\" => { \"region\" => \"us\" }, \"columns\" => %w(time temp value), \"values\" => [[1_438_612_976, 92, 0.3445], [1_438_612_989, 68, 0.8787]] }] }] }\n      end\n      let(:expected_result) do\n        [{ \"name\" => \"cpu\", \"tags\" => { \"region\" => \"pl\" },\n           \"values\" => [{ \"time\" => 1_438_580_576, \"temp\" => 34, \"value\" => 0.343443 }] },\n         { \"name\" => \"cpu\", \"tags\" => { \"region\" => \"us\" },\n           \"values\" => [{ \"time\" => 1_438_612_976, \"temp\" => 92, \"value\" => 0.3445 },\n                        { \"time\" => 1_438_612_989, \"temp\" => 68, \"value\" => 0.8787 }] }]\n      end\n      let(:query) { 'SELECT * FROM cpu' }\n\n      it \"should return results with integer timestamp\" do\n        expect(subject.query(query)).to eq(expected_result)\n      end\n    end\n...\n```\nEpoch time\u306e\u6307\u5b9a\u3082\u3067\u304d\u308b\n\n>Epoch time is the amount of time that has elapsed since 00:00:00 Coordinated Universal Time (UTC), Thursday, 1 January 1970.\ns\u306f\u79d2\n\n## cases/retry_requests_spec.rb\n\u30ea\u30af\u30a8\u30b9\u30c8\u306e\u30ea\u30c8\u30e9\u30a4\n\n```\n...\n    context \"when retry is 'n'\" do\n      let(:args) { { retry: 3 } }\n\n      it \"raise error after 'n' attemps\" do\n        expect(client).to receive(:sleep).exactly(3).times\n        expect { subject }.to raise_error(InfluxDB::ConnectionError) do |e|\n          expect(e.cause).to be_an_instance_of(Timeout::Error)\n        end\n      end\n    end\n...\n```\n\u6307\u5b9a\u56de\u6570\u5206\u306e\u30ea\u30c8\u30e9\u30a4\u3092\u884c\u3063\u305f\u304b\u3092\u78ba\u8a8d\n\n```\n...\n    context \"when retry is -1\" do\n      let(:args) { { retry: -1 } }\n      before do\n        stub_request(:post, \"http://influxdb.test:9999/write\")\n          .with(\n            query: { u: \"username\", p: \"password\", precision: 's', db: database },\n            headers: { \"Content-Type\" => \"application/octet-stream\" },\n            body: body\n          )\n          .to_raise(Timeout::Error).then\n          .to_raise(Timeout::Error).then\n          .to_raise(Timeout::Error).then\n          .to_raise(Timeout::Error).then\n          .to_return(status: 204)\n      end\n\n      it \"keep trying until get the connection\" do\n        expect(client).to receive(:sleep).exactly(4).times\n        expect { subject }.to_not raise_error\n      end\n    end\n...\n```\nretry\u30aa\u30d7\u30b7\u30e7\u30f3\u306b-1\u3092\u8a2d\u5b9a\u3057\u305f\u5834\u5408\u306f\nretry\u3057\u7d9a\u3051\u308b\u3053\u3068\u3092\u78ba\u8a8d\n\n## cases/udp_client_spec.rb\nudp\u3067\u30c7\u30fc\u30bf\u767b\u9332\n\n```\n...\n  let(:client) { described_class.new(udp: { host: \"localhost\", port: 44_444 }) }\n\n  specify { expect(client.writer).to be_a(InfluxDB::Writer::UDP) }\n\n  describe \"#write\" do\n    let(:message) { 'responses,region=eu value=5i' }\n\n    it \"sends a UPD packet\" do\n      s = UDPSocket.new\n      s.bind(\"localhost\", 44_444)\n\n      client.write_point(\"responses\", values: { value: 5 }, tags: { region: 'eu' })\n\n      rec_message = s.recvfrom(30).first\n      expect(rec_message).to eq message\n    end\n  end\n...\n```\n\n\u30ed\u30fc\u30ab\u30eb\u306b\u3042\u3051\u305fudp\u30bd\u30b1\u30c3\u30c8\u3092\u4ecb\u3057\u3066\u3001\nUDP\u3067\u30c7\u30fc\u30bf\u767b\u9332\u304c\u3067\u304d\u305d\u3046\u304b\u3092\u78ba\u8a8d\n\n## cases/write_points_spec.rb\n\u5024\u306e\u767b\u9332\n\n```\n...\n  describe \"#write_point\" do\n    let(:series) { \"cpu\" }\n    let(:data) do\n      { tags: { region: 'us', host: 'server_1' },\n        values: { temp: 88, value: 54 } }\n    end\n    let(:body) do\n      InfluxDB::PointValue.new(data.merge(series: series)).dump\n    end\n\n    before do\n      stub_request(:post, \"http://influxdb.test:9999/write\").with(\n        query: { u: \"username\", p: \"password\", precision: 's', db: database },\n        headers: { \"Content-Type\" => \"application/octet-stream\" },\n        body: body\n      ).to_return(status: 204)\n    end\n\n    it \"should POST to add single point\" do\n      expect(subject.write_point(series, data)).to be_a(Net::HTTPNoContent)\n    end\n\n    it \"should not mutate data object\" do\n      original_data = data\n      subject.write_point(series, data)\n      expect(data[:series]).to be_nil\n      expect(original_data).to eql(data)\n    end\n  end\n...\n```\n1\u3064\u306e\u30c7\u30fc\u30bf\u3060\u3051\u304c\u767b\u9332\u3067\u304d\u308bwrite_point\u306e\u78ba\u8a8d\n\n```\n...\ndescribe \"#write_points\" do\n    context \"with multiple series\" do\n      let(:data) do\n        [{ series: 'cpu',\n           tags: { region: 'us', host: 'server_1' },\n           values: { temp: 88, value: 54 } },\n         { series: 'gpu',\n           tags: { region: 'uk', host: 'server_5' },\n           values: { value: 0.5435345 } }]\n      end\n      let(:body) do\n        data.map do |point|\n          InfluxDB::PointValue.new(point).dump\n        end.join(\"\\n\")\n      end\n\n      before do\n        stub_request(:post, \"http://influxdb.test:9999/write\").with(\n          query: { u: \"username\", p: \"password\", precision: 's', db: database },\n          headers: { \"Content-Type\" => \"application/octet-stream\" },\n          body: body\n        ).to_return(status: 204)\n      end\n\n      it \"should POST multiple points\" do\n        expect(subject.write_points(data)).to be_a(Net::HTTPNoContent)\n      end\n    end\n  ...\n...\n```\n\n\u8907\u6570series\u3078\u306e\u30c7\u30fc\u30bf\u767b\u9332\u3092\u78ba\u8a8d\n\n\n## \u7d42\u308f\u308a\u306b\ninfluxdb\u81ea\u4f53\u306e\u30c6\u30b9\u30c8\u3067\u306f\u306a\u304f\u3001\ninfluxdb\u3092\u5229\u7528\u3059\u308b\u30af\u30e9\u30a4\u30a2\u30f3\u30c8\u5074\u306e\u30c6\u30b9\u30c8\u3067\u3059\u306e\u3067\u3001\nstub\u3092\u5229\u7528\u3057\u3066\u60f3\u5b9a\u901a\u308a\u306b\u30d1\u30e9\u30e1\u30fc\u30bf\u3084config\u306e\u8a2d\u5b9a\u304c\u3067\u304d\u308b\u3001\n\u3068\u3044\u3046\u78ba\u8a8d\u304c\u591a\u304b\u3063\u305f\u3088\u3046\u306b\u601d\u3048\u307e\u3059\u3002\n", "tags": ["influxdb", "Ruby"]}