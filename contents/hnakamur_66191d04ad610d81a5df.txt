{"context": " More than 1 year has passed since last update.\u3068\u308a\u3042\u3048\u305a\u52d5\u3044\u305f\u3068\u3044\u3046\u30ec\u30d9\u30eb\u306e\u30b5\u30f3\u30d7\u30eb\u3067\u3059\u304c\u3001rubygems\u3092\u30ad\u30e3\u30c3\u30b7\u30e5\u3059\u308b\u30d7\u30ed\u30ad\u30b7\u30b5\u30fc\u30d0\u306e\u30b5\u30f3\u30d7\u30eb\u30922\u7a2e\u985e\u66f8\u3044\u3066\u307f\u307e\u3057\u305f\u3002\n\u5b9f\u884c\u4f8b\u306fgithub\u306e\u30d7\u30ed\u30b8\u30a7\u30af\u30c8\u30da\u30fc\u30b8\u3092\u53c2\u7167\u3057\u3066\u304f\u3060\u3055\u3044\u3002\n\nhnakamur/goproxy-rubygems-cache\n\nelazarl/goproxy\u3092\u4f7f\u3063\u305f\u5b9f\u88c5\npackage main\n\nimport (\n    \"flag\"\n    \"github.com/elazarl/goproxy\"\n    \"io/ioutil\"\n    \"log\"\n    \"net/http\"\n    \"os\"\n    \"path\"\n)\n\nfunc main() {\n    verbose := flag.Bool(\"v\", false, \"should every proxy request be logged to stdout\")\n    docRoot := flag.String(\"root\", \".\", \"document root directory\")\n    address := flag.String(\"http\", \":8080\", `HTTP service address (e.g., \":8080\")`)\n    flag.Parse()\n    proxy := goproxy.NewProxyHttpServer()\n    proxy.Verbose = *verbose\n\n    proxy.OnRequest(reqMethodIs(\"GET\", \"HEAD\")).DoFunc(\n        func(req *http.Request, ctx *goproxy.ProxyCtx) (*http.Request, *http.Response) {\n            filename := path.Join(*docRoot, ctx.Req.URL.Path)\n            if !exists(filename) {\n                return req, nil\n            }\n\n            bytes, err := ioutil.ReadFile(filename)\n            if err != nil {\n                ctx.Warnf(\"%s\", err)\n                return req, nil\n            }\n            resp := goproxy.NewResponse(req, \"application/octet-stream\",\n                http.StatusOK, string(bytes))\n            ctx.Logf(\"return response from local %s\", filename)\n            return req, resp\n        })\n\n    proxy.OnResponse(respReqMethodIs(\"GET\", \"HEAD\")).Do(\n        goproxy.HandleBytes(\n            func(b []byte, ctx *goproxy.ProxyCtx) []byte {\n                if ctx.Req.Method != \"GET\" || hasRespHeader(ctx.Resp, \"Location\") {\n                    return b\n                }\n\n                filename := path.Join(*docRoot, ctx.Req.URL.Path)\n                if exists(filename) {\n                    return b\n                }\n\n                dir := path.Dir(filename)\n                err := os.MkdirAll(dir, 0755)\n                if err != nil {\n                    ctx.Warnf(\"cannot create directory: %s\", dir)\n                }\n\n                err = ioutil.WriteFile(filename, b, 0644)\n                if err != nil {\n                    ctx.Warnf(\"cannot write file: %s\", filename)\n                }\n\n                ctx.Logf(\"save cache to %s\", filename)\n\n                return b\n            }))\n    log.Fatal(http.ListenAndServe(*address, proxy))\n}\n\nfunc reqMethodIs(methods ...string) goproxy.ReqConditionFunc {\n    return func(req *http.Request, ctx *goproxy.ProxyCtx) bool {\n        for _, method := range methods {\n            if req.Method == method {\n                return true\n            }\n        }\n        return false\n    }\n}\n\nfunc respReqMethodIs(methods ...string) goproxy.RespConditionFunc {\n    return func(resp *http.Response, ctx *goproxy.ProxyCtx) bool {\n        for _, method := range methods {\n            if resp.Request.Method == method {\n                return true\n            }\n        }\n        return false\n    }\n}\n\nfunc hasRespHeader(resp *http.Response, header string) bool {\n    _, ok := resp.Header[header]\n    return ok\n}\n\nfunc exists(filename string) bool {\n    _, err := os.Stat(filename)\n    return !os.IsNotExist(err)\n}\n\n\nhnakamur/rubygems-proxy\n\nTrivial HTTP Proxy in Go \u2014 IOTTMCO\u3092\u53c2\u8003\u306bGo\u6a19\u6e96\u30e9\u30a4\u30d6\u30e9\u30ea\u3092\u4f7f\u3063\u305f\u5b9f\u88c5\npackage main\n\nimport (\n    \"bufio\"\n    \"flag\"\n    \"io\"\n    \"log\"\n    \"net/http\"\n    \"os\"\n    \"path\"\n    \"strings\"\n)\n\nvar addr = flag.String(\"addr\", \":8080\", \"http service address\")\nvar root = flag.String(\"root\", \".\", \"document root directory\")\n\nfunc main() {\n    flag.Parse()\n    http.Handle(\"/\", http.HandlerFunc(handler))\n    err := http.ListenAndServe(*addr, nil)\n    if err != nil {\n        log.Fatal(\"ListenAndServe:\", err)\n    }\n}\n\nfunc handler(w http.ResponseWriter, req *http.Request) {\n    log.Printf(\"method:%s\\turl:%s\", req.Method, req.URL)\n    filename := path.Join(*root, req.URL.Path)\n    if exists(filename) {\n        http.ServeFile(w, req, filename)\n        log.Printf(\"served from local file: %s\", filename)\n    } else {\n        proxy(w, req)\n    }\n}\n\nfunc proxy(w http.ResponseWriter, req *http.Request) {\n    client := &http.Client{}\n\n    // Tweak the request as appropriate:\n    //  RequestURI may not be sent to client\n    //  URL.Scheme must be lower-case\n    req.RequestURI = \"\"\n    req.URL.Scheme = strings.ToLower(req.URL.Scheme)\n\n    // And proxy\n    resp, err := client.Do(req)\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    if req.Method != \"GET\" || hasLocationHeader(resp) {\n        log.Printf(\"forward proxy to remote: %s\", req.URL)\n        resp.Write(w)\n        return\n    }\n\n    filename := path.Join(*root, req.URL.Path)\n    dir := path.Dir(filename)\n    if !exists(dir) {\n        os.MkdirAll(dir, 0755)\n    }\n\n    file, err := os.Create(filename)\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    fw := bufio.NewWriter(file)\n    _, err = io.Copy(fw, resp.Body)\n    if err != nil {\n        log.Fatal(err)\n    }\n    err = resp.Body.Close()\n    if err != nil {\n        log.Fatal(err)\n    }\n    err = fw.Flush()\n    if err != nil {\n        log.Fatal(err)\n    }\n    err = file.Close()\n    if err != nil {\n        log.Fatal(err)\n    }\n    log.Printf(\"saved to local file: %s\", filename)\n\n    http.ServeFile(w, req, filename)\n}\n\nfunc hasLocationHeader(resp *http.Response) bool {\n    _, ok := resp.Header[\"Location\"]\n    return ok\n}\n\nfunc exists(filename string) bool {\n    _, err := os.Stat(filename)\n    return !os.IsNotExist(err)\n}\n\n\u500b\u4eba\u7684\u306b\u306f\u3053\u3061\u3089\u306e\u307b\u3046\u304c\u308f\u304b\u308a\u3084\u3059\u3044\u6c17\u304c\u3057\u307e\u3059\u3002\n\u3068\u308a\u3042\u3048\u305a\u52d5\u3044\u305f\u3068\u3044\u3046\u30ec\u30d9\u30eb\u306e\u30b5\u30f3\u30d7\u30eb\u3067\u3059\u304c\u3001rubygems\u3092\u30ad\u30e3\u30c3\u30b7\u30e5\u3059\u308b\u30d7\u30ed\u30ad\u30b7\u30b5\u30fc\u30d0\u306e\u30b5\u30f3\u30d7\u30eb\u30922\u7a2e\u985e\u66f8\u3044\u3066\u307f\u307e\u3057\u305f\u3002\n\u5b9f\u884c\u4f8b\u306fgithub\u306e\u30d7\u30ed\u30b8\u30a7\u30af\u30c8\u30da\u30fc\u30b8\u3092\u53c2\u7167\u3057\u3066\u304f\u3060\u3055\u3044\u3002\n\n## [hnakamur/goproxy-rubygems-cache](https://github.com/hnakamur/goproxy-rubygems-cache)\n[elazarl/goproxy](https://github.com/elazarl/goproxy)\u3092\u4f7f\u3063\u305f\u5b9f\u88c5\n\n```go\npackage main\n\nimport (\n\t\"flag\"\n\t\"github.com/elazarl/goproxy\"\n\t\"io/ioutil\"\n\t\"log\"\n\t\"net/http\"\n\t\"os\"\n\t\"path\"\n)\n\nfunc main() {\n\tverbose := flag.Bool(\"v\", false, \"should every proxy request be logged to stdout\")\n\tdocRoot := flag.String(\"root\", \".\", \"document root directory\")\n\taddress := flag.String(\"http\", \":8080\", `HTTP service address (e.g., \":8080\")`)\n\tflag.Parse()\n\tproxy := goproxy.NewProxyHttpServer()\n\tproxy.Verbose = *verbose\n\n\tproxy.OnRequest(reqMethodIs(\"GET\", \"HEAD\")).DoFunc(\n\t\tfunc(req *http.Request, ctx *goproxy.ProxyCtx) (*http.Request, *http.Response) {\n\t\t\tfilename := path.Join(*docRoot, ctx.Req.URL.Path)\n\t\t\tif !exists(filename) {\n\t\t\t\treturn req, nil\n\t\t\t}\n\n\t\t\tbytes, err := ioutil.ReadFile(filename)\n\t\t\tif err != nil {\n\t\t\t\tctx.Warnf(\"%s\", err)\n\t\t\t\treturn req, nil\n\t\t\t}\n\t\t\tresp := goproxy.NewResponse(req, \"application/octet-stream\",\n\t\t\t\thttp.StatusOK, string(bytes))\n\t\t\tctx.Logf(\"return response from local %s\", filename)\n\t\t\treturn req, resp\n\t\t})\n\n\tproxy.OnResponse(respReqMethodIs(\"GET\", \"HEAD\")).Do(\n\t\tgoproxy.HandleBytes(\n\t\t\tfunc(b []byte, ctx *goproxy.ProxyCtx) []byte {\n\t\t\t\tif ctx.Req.Method != \"GET\" || hasRespHeader(ctx.Resp, \"Location\") {\n\t\t\t\t\treturn b\n\t\t\t\t}\n\n\t\t\t\tfilename := path.Join(*docRoot, ctx.Req.URL.Path)\n\t\t\t\tif exists(filename) {\n\t\t\t\t\treturn b\n\t\t\t\t}\n\n\t\t\t\tdir := path.Dir(filename)\n\t\t\t\terr := os.MkdirAll(dir, 0755)\n\t\t\t\tif err != nil {\n\t\t\t\t\tctx.Warnf(\"cannot create directory: %s\", dir)\n\t\t\t\t}\n\n\t\t\t\terr = ioutil.WriteFile(filename, b, 0644)\n\t\t\t\tif err != nil {\n\t\t\t\t\tctx.Warnf(\"cannot write file: %s\", filename)\n\t\t\t\t}\n\n\t\t\t\tctx.Logf(\"save cache to %s\", filename)\n\n\t\t\t\treturn b\n\t\t\t}))\n\tlog.Fatal(http.ListenAndServe(*address, proxy))\n}\n\nfunc reqMethodIs(methods ...string) goproxy.ReqConditionFunc {\n\treturn func(req *http.Request, ctx *goproxy.ProxyCtx) bool {\n\t\tfor _, method := range methods {\n\t\t\tif req.Method == method {\n\t\t\t\treturn true\n\t\t\t}\n\t\t}\n\t\treturn false\n\t}\n}\n\nfunc respReqMethodIs(methods ...string) goproxy.RespConditionFunc {\n\treturn func(resp *http.Response, ctx *goproxy.ProxyCtx) bool {\n\t\tfor _, method := range methods {\n\t\t\tif resp.Request.Method == method {\n\t\t\t\treturn true\n\t\t\t}\n\t\t}\n\t\treturn false\n\t}\n}\n\nfunc hasRespHeader(resp *http.Response, header string) bool {\n\t_, ok := resp.Header[header]\n\treturn ok\n}\n\nfunc exists(filename string) bool {\n\t_, err := os.Stat(filename)\n\treturn !os.IsNotExist(err)\n}\n```\n\n## [hnakamur/rubygems-proxy](https://github.com/hnakamur/rubygems-proxy)\n[Trivial HTTP Proxy in Go \u2014 IOTTMCO](http://bytbox.net/blog/2013/01/trivial-http-proxy-golang.html)\u3092\u53c2\u8003\u306bGo\u6a19\u6e96\u30e9\u30a4\u30d6\u30e9\u30ea\u3092\u4f7f\u3063\u305f\u5b9f\u88c5\n\n\n```go\npackage main\n\nimport (\n\t\"bufio\"\n\t\"flag\"\n\t\"io\"\n\t\"log\"\n\t\"net/http\"\n\t\"os\"\n\t\"path\"\n\t\"strings\"\n)\n\nvar addr = flag.String(\"addr\", \":8080\", \"http service address\")\nvar root = flag.String(\"root\", \".\", \"document root directory\")\n\nfunc main() {\n\tflag.Parse()\n\thttp.Handle(\"/\", http.HandlerFunc(handler))\n\terr := http.ListenAndServe(*addr, nil)\n\tif err != nil {\n\t\tlog.Fatal(\"ListenAndServe:\", err)\n\t}\n}\n\nfunc handler(w http.ResponseWriter, req *http.Request) {\n\tlog.Printf(\"method:%s\\turl:%s\", req.Method, req.URL)\n\tfilename := path.Join(*root, req.URL.Path)\n\tif exists(filename) {\n\t\thttp.ServeFile(w, req, filename)\n\t\tlog.Printf(\"served from local file: %s\", filename)\n\t} else {\n\t\tproxy(w, req)\n\t}\n}\n\nfunc proxy(w http.ResponseWriter, req *http.Request) {\n\tclient := &http.Client{}\n\n\t// Tweak the request as appropriate:\n\t//\tRequestURI may not be sent to client\n\t//\tURL.Scheme must be lower-case\n\treq.RequestURI = \"\"\n\treq.URL.Scheme = strings.ToLower(req.URL.Scheme)\n\n\t// And proxy\n\tresp, err := client.Do(req)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\tif req.Method != \"GET\" || hasLocationHeader(resp) {\n\t\tlog.Printf(\"forward proxy to remote: %s\", req.URL)\n\t\tresp.Write(w)\n\t\treturn\n\t}\n\n\tfilename := path.Join(*root, req.URL.Path)\n\tdir := path.Dir(filename)\n\tif !exists(dir) {\n\t\tos.MkdirAll(dir, 0755)\n\t}\n\n\tfile, err := os.Create(filename)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\tfw := bufio.NewWriter(file)\n\t_, err = io.Copy(fw, resp.Body)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\terr = resp.Body.Close()\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\terr = fw.Flush()\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\terr = file.Close()\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tlog.Printf(\"saved to local file: %s\", filename)\n\n\thttp.ServeFile(w, req, filename)\n}\n\nfunc hasLocationHeader(resp *http.Response) bool {\n\t_, ok := resp.Header[\"Location\"]\n\treturn ok\n}\n\nfunc exists(filename string) bool {\n\t_, err := os.Stat(filename)\n\treturn !os.IsNotExist(err)\n}\n```\n\n\u500b\u4eba\u7684\u306b\u306f\u3053\u3061\u3089\u306e\u307b\u3046\u304c\u308f\u304b\u308a\u3084\u3059\u3044\u6c17\u304c\u3057\u307e\u3059\u3002", "tags": ["Go1.1.2", "proxy", "rubygems"]}