{"context": " More than 1 year has passed since last update.\n\nAbstract\nMacro is one of the most characteristic feature of the Lisp-family of languages which allows the higher level of abstraction by extending the syntax of the language. If a head of an S-expression specifies a macro, then the whole expression, which is a list, are passed to the corresponding macro-function and it replaces the original expression with the new list returned by the function. This expansion, or compilation, is done from the root to the leaf in a iterative manner.\nIn this article, we show the current limit of the macro system in ANSI Common Lisp. We also show an alternative macro expansion system which overcomes the limitation.\nThe rest of the article is organized as follows: we first briefly review the basic usage of macro and its behavior. We also investigate the behavior of the interpreter in sbcl in order to see how macros are processed during the code traversal (for evaluation or bytecode/native compilation). Based on these introductions, we then show that the current macro system is not able to give a clean implementation of certain kinds of local macros in iterate, and we introduce a notion of compile-time continuation as well as showing how it overcomes the problem.\nIn Related Works, we see the current implementation of iterate. We also briefly introduce a now somewhat forgotten expression passing style by Dybvig as a similar concept.\n\nPreliminaries\n(I assume everyone reading this article are already familiar with macros, so I just explain it very briefly)\nMacros, functions and variables related to Macro System:\n(defmacro name lambda-list &body body)\n(macrolet bindings &body body)\n(eval form)\n(compile name definition)\n(macroexpand form &optional env)\n(macroexpand-1 form &optional env)\n*macroexpand-hook*\n\nFunctions provided by CLtL2, which allows the manipulation of the environments:\nAUGMENT-ENVIRONMENT\nCOMPILER-LET\nDECLARATION-INFORMATION\nDEFINE-DECLARATION\nENCLOSE\nFUNCTION-INFORMATION\nPARSE-MACRO\nVARIABLE-INFORMATION\n\n\nBasic Usage of Macros and its Behavior\nMacro functions are essentially functions which takes a list (form) and an environment, and return a new list (form).  They can be defined via defmacro . defmacro is almost like defun but stores the function in a macro-function namespace. At the lowest level, an S-expression is expanded via macroexpand-1 .\n(macroexpand-1 form &optional env) -> expansion, expanded-p\n\n\nIf form is a macro form, then the expansion is a macro expansion and expanded-p is true. Otherwise, the expansion is the given form and expanded-p is false. \nCLHS macroexpand-1\n\nIf a head of an S-expression specifies a macro, which means the form is a macro form, then the whole expression, which is a list, are passed to the corresponding macro-function and it replaces the original expression with the new list returned by the function.\nIn the example below, the *form* begins with let and it is a special form, so macroexpand-1 does nothing.\n(defmacro my-unless (condition &body body)\n  `(when (not ,condition)\n     ,@body))\n\n(defparameter *form*\n  `(let ((x 5))\n     (my-unless (plusp x)\n       (print :minus))))\n\n(macroexpand-1 *form*)\n; -->\n;  (LET ((X 5))\n;    (MY-UNLESS (PLUSP X)\n;      (PRINT :MINUS)))\n;  NIL\n\nThe next example, however, contains a macro form directly:\n(defparameter *form2*\n  `(my-unless (plusp x)\n      (print :minus)))\n\nand if it is passed to macroexpand-1, it expands the definition:\n(macroexpand-1 *form2*)\n;; -->\n;; (WHEN (NOT (PLUSP X)) (PRINT :MINUS))\n;; T\n\nAs a result, when appears as defined in my-unless. The secondary value is T because the expansion was done. Furthermore, since when is again a macro, the repeated expansion gives the following results:\n(macroexpand-1 (macroexpand-1 *form2*))\n;; ->\n;; (IF (NOT (PLUSP X))\n;;     (PROGN (PRINT :MINUS))\n;;     NIL)\n;; T\n(macroexpand-1 (macroexpand-1 (macroexpand-1 *form2*)))\n;; ->\n;; (IF (NOT (PLUSP X))          ; no expansion\n;;     (PROGN (PRINT :MINUS))\n;;     NIL)\n;; NIL\n\nAs a result of the third expansion, if being a special operator, not a macro, the expansion stops and the secondary value is NIL.\nmacroexpand repeatedly expands a form using macroexpand-1, watching its secondary Boolean return value. It stops the expansion when it see NIL in the secondary value in the first time.\n(macroexpand *form2*)\n;; -->\n;; (IF (NOT (PLUSP X))\n;;     (PROGN (PRINT :MINUS))\n;;     NIL)\n;; T\n\nNote that macroexpand does not expands the inner nodes: it expands only the root node of the S-expression syntax tree.\n(macroexpand *form*)\n;; -->\n;;  (LET ((X 5))\n;;    (MY-UNLESS (PLUSP X)\n;;      (PRINT :MINUS)))\n;;   NIL\n\n\nCode Expansion during the Traversal\nIn the previous section, we saw that macroexpand expands the root node only. If so, when and how the inner nodes are expanded?\nThe code of eval helps us investigate the behavior of macro expansion. eval interprets and executes a form, but the word interpreter is sometimes misinterpreted as if it does not do any compilation --- which actually does. It doesn't run a byte-code/native-code compilation, but macros are always expanded, as described in CLHS 3. Evaluation and Compilation.\nTalking about which implementation of eval to investigate, we see eval in sb-eval, which is included in the recent sbcl. sbcl and other implementations with python native compiler is known to have always-compile strategy, but if we set sb-eval:*evaluator-mode* to :interpret, we get a true interpreter.\nCL-USER> (setf *evaluator-mode* :interpret) \n; --> :INTERPRET\n\nOK, let's see what's happening inside eval:\n(defun eval (original-exp)\n  (eval-in-lexenv original-exp (make-null-lexenv)))\n\n;; \u2193\n\n(defun eval-in-lexenv (exp lexenv)\n  (if (eq *evaluator-mode* :compile)\n      ...\n      (sb!eval:eval-in-native-environment exp lexenv)))\n\n;; \u2193 \n\n(defun eval-in-native-environment (form lexenv)\n  (handler-bind\n      ((sb!impl::eval-error ...))\n      ...\n      (%eval form env)))\n\n;; \u2193\n\n(defun %eval (exp env)\n  ...\n  (%%eval exp env))\n\n;; \u2193\n\nits sooo heavily nested. well, well,...\n(defun %%eval (exp env)\n  (cond\n    ((symbolp exp)\n     ;; CLHS 3.1.2.1.1 Symbols as Forms\n     (multiple-value-bind (value kind) (get-variable exp env)\n       (ecase kind\n         (:variable value)\n         (:expansion (%eval value env)))))\n    ;; CLHS 3.1.2.1.3 Self-Evaluating Objects\n    ((atom exp) exp)\n    ;; CLHS 3.1.2.1.2 Conses as Forms\n    ((consp exp)\n     (case (car exp)\n       ;; CLHS 3.1.2.1.2.1 Special Forms\n       ((block)                (eval-block (cdr exp) env))\n       ((catch)                (eval-catch (cdr exp) env))\n       ;;\n       ;; 20 or more special forms **skipped**\n       ;; \n       (t\n        (let ((dispatcher (getf *eval-dispatch-functions* (car exp))))\n          (cond\n            (dispatcher ; for cltl2:compiler-let\n             (funcall dispatcher exp env))\n            ;; CLHS 3.1.2.1.2.4 Lambda Forms\n            ((and (consp (car exp)) (eq (caar exp) 'lambda))\n             (interpreted-apply (eval-function (list (car exp)) env)\n                                (eval-args (cdr exp) env)))\n            (t\n             (multiple-value-bind (function kind) (get-function (car exp) env)\n               (ecase kind\n                 ;; CLHS 3.1.2.1.2.3 Function Forms\n                 (:function (%apply function (eval-args (cdr exp) env)))\n                 ;; CLHS 3.1.2.1.2.2 Macro Forms\n                 (:macro\n                  ;; ** This is what we want **\n                  )))))))))))\n\nExtracting only those part we are interested in, then it is:\n(let ((hook *macroexpand-hook*)) ; hook = funcall by default\n  (%eval (funcall hook\n                  function\n                  exp\n                  (env-native-lexenv env))\n         env))\n\nWe see that the evaluator first expand the macro (root node only) and then evaluate the expansion again.\n\nThe Call Stack\nGiven above implementation of eval, let's review the behavior of the call stack during the evaluation. And we get the following:\n;; the code to be evaluated:\n(let ((x 5))\n  (my-unless (plusp x)\n    (print :minus)))\n\n;; the expansion\n(let ((x 5))\n  (IF (NOT (PLUSP X))\n      (PROGN (PRINT :MINUS))\n      NIL))\n\n;; call stack\n(eval            ; let\n (eval           ; my-unless\n  (macroexpand)  ; my-unless -> when -> if\n  (eval          ; if\n    (eval-if       ; if\n     (eval (eval)) ; (not (plusp x))\n     (eval))))     ; (progn ...) or NIL\n\nWe see a macroexpand during the evaluation. That's good.  Then, what if the code needs the macro expansion twice?  Here it is.\n;; the code to be evaluated:\n(my-unless (plusp x)\n  (my-unless (minusp x)\n    (print :zero)))  \n\n;; the expansion\n(IF (NOT (PLUSP X))\n    (PROGN\n     (IF (NOT (MINUSP X))\n         (PROGN (PRINT :ZERO))\n         NIL))\n    NIL)\n\n;; call stack\n(eval               ; my-unless\n (macroexpand)      ; my-unless -> when -> if\n (eval              ; if\n  (eval-if            ;if\n    (eval             ; (not (plusp))\n     (eval            ; my-unless\n      (macroexpand)   ; my-unless -> when -> if\n      (eval ...)))))  ; if ...\n\nNow, notice that each expansion is called independently -- the information of outer expansion is not on the stack when the inner expansion occurs. This leads to the fundamental problem shown in the next section.\n\nLocal Macros -- with macrolet --\nThe above behavior somewhat inhibits the easy implementation of some smart local macros. Local macros? Why not use just macrolet ??\nWe describe the reason by implementing the simple version of iterate. It has a syntax as shown below:\n    ;; inside `iter`, `while` continues the execution only when the argument is true.\n    ;; `collect` accumulate its argument into a list and make `iter` return the accumulated result.\n    ;; `while` and `collect` signals an error outside `iter`.\n\n    (let ((i 0))\n      (iter (while (< i 5))\n            (incf i)\n            (collect (+ 3 (* 4 i)))))\n\nLet's implement it with macrolet.  It is possible, clean and simple.\n    (define-condition compile-error (simple-error)\n      ((message :initarg :message :accessor message))\n      (:report (lambda (c s)\n                 (princ (message c) s))))\n\n    (defmacro collect (x)\n      (declare (ignore x))\n      (error 'compile-error\n             :message \"`collect' must be used under `iter'\"))\n\n    (defmacro while (x)\n      (declare (ignore x))\n      (error 'compile-error\n             :message \"`while' must be used under `iter'\"))\n\n    (require :alexandria)\n    (use-package :alexandria)\n\n    (defmacro iter (&body body)\n      (with-gensyms (iter-block accumulate start)\n        `(block ,iter-block\n           (let ((,accumulate nil))\n             (macrolet ((while (condition)\n                          `(unless ,condition\n                             (return-from ,',iter-block\n                               (nreverse ,',accumulate))))\n                        (collect (thing)\n                          `(push ,thing ,',accumulate)))\n               (tagbody\n                 ,start\n                 ,@body\n                 (go ,start)))))))\n\n    (let ((i 0))\n      (iter (while (< i 5))\n            (incf i)\n            (collect (+ 3 (* 4 i)))))\n\n    ;; --> (7 11 15 19 23)\n\nWorked well. Sounds good. What's the problem?\nOK, then go further: let's implement (collect x into acc) feature in the original iterate . It allows users to specify the name of the list that the elements are accumulated. But again, only with macrolet.\n    (let ((i 0))\n      (iter (while (< i 5))\n            (incf i)\n            (print acc) ; <--\n            (collect (+ 3 (* 4 i)) :into acc))) ; <--\n\nWhat now? You may easily encounter a problem: How we safely bind the symbol acc? Without destructing the global environment?\nIn order to bind a variable safely, we need to wrap the entire loop with let . The problem exists here: the collect clause are expanded only after the expansion of iter . The bad thing is, we have no way behind -- backtracking the expansion is impossible. No method to go back to the pre-expansion state.\n\nMacros in Common Lisp are still restricted\n\nHere resides the crucial problem in the macro system in Common Lisp.\nExpansion is done iteratively, not recursively\nEven CLHS writes:\n\nmacroexpand repeatedly expands form until it is no longer a macro form. In effect, macroexpand calls macroexpand-1 repeatedly until the secondary value it returns is nil. -- CLHS Function MACROEXPAND, MACROEXPAND-1\n\nIf the previous expansion context is on the stack, we can signal an error and backtrack the expansion like:\n    (collect (thing &key into)\n      (if into\n          (error 'accumulate-target :name into) ; Compile it again!\n          `(push ,thing ,',accumulate)))\n\nand the handler in the iter might catch the signal.\nHypothetical implementation following such a macro system is shown below. In defmacro, we have additional argument &continuation cont that takes a closure which continue the expansion of the inner clauses. If a condition is signaled from the upper stack, then it is handled by the handler here and it recompile the whole clause again.\n   (defmacro iter (&body body &continuation cont)\n      (with-gensyms (iter-block accumulate start)\n        (handler-case\n            (funcall #'cont\n                     `(block ,iter-block\n                        (let ((,accumulate nil))\n                          (macrolet ((while (condition)\n                                       `(unless ,condition\n                                          (return-from ,',iter-block\n                                            (nreverse ,',accumulate))))\n                                     (collect (thing &key into)\n                                       (if into\n                                           (signal 'accumulate-target :name into)\n                                           `(push ,thing ,',accumulate))))\n                            (tagbody\n                              ,start\n                              ,@body\n                              (go ,start))))))\n          ;; handler\n          (accumulate-target (c)\n            (setf accumulate (name c))\n            (funcall #'cont\n                     `(block ,iter-block\n                        (let ((,accumulate nil))\n                          (macrolet ((while (condition)\n                                       `(unless ,condition\n                                          (return-from ,',iter-block\n                                            (nreverse ,',accumulate))))\n                                     (collect (thing &key into)\n                                       `(push ,thing ,',accumulate)))\n                            (tagbody\n                              ,start\n                              ,@body\n                              (go ,start))))))))))\n\nWe refer to this continuation cont as compile-time continuation because it is a continuation intended to be used in a macro expansion. These style itself is called as Expression Passing Style according to expression passing style by Dybvig because it passes a sub-expression to the continuation. However, since the paper assumes a scheme-like system in describing the concept, the direct application to Common Lisp is not possible.\n\nRelated Works\nThe original iterate, however, does not handle the problem in this way. It rather has its own code walker to detect all (collect ... into ...) prior to the expansion of iter. This is clearly a dirty workaround -- consider a case that a collect clause is hidden in a expansion of another macro:\n    ;; `collect` clause hidden in a macro\n    (defmacro my-collect (&rest args)\n      `(collect ,@args))\n\n    (let ((i 0))\n      (iter (while (< i 5))\n            (incf i)\n            (print acc)\n            (my-collect (+ 3 (* 4 i)) into acc)))\n\nIn order to detect all collect clause in any macro expansion, the code walker in iterate expands all macro inside the body of iter. This is dirty -- and has indeed a critical limitation:\n    (require :iterate)\n    (in-package :iterate)\n    (let ((i 0))\n      (iter (while (< i 5))\n            (incf i)\n            (print acc)\n            (macrolet ((my-collect (&rest args)\n                         `(collect ,@args)))\n              (my-collect (+ 3 (* 4 i)) into acc))))\n\n    ; in: LET ((I 0)) ...\n    ; \n    ; caught WARNING:\n    ;   Iterate:\n    ;   Iterate does not know how to handle \n    ;     the special form (MACROLET ...)\n    ;   It will not be walked, which means that Iterate clauses\n    ;   inside it will not be seen.\n    ;\n    ; compilation unit finished\n    ;   Undefined function:\n    ;     COLLECT\n    ;   Undefined variables:\n    ;     ACC INTO\n\nThis is essentially a problem in ANSI CL. Theoretically, augment-environment and parse-macro defined in cltl2 allows the code walker to expand those clauses. The behavior may be the result of historical issue.\n\n[Function] augment-environment env &key\n:variable :symbol-macro :function :macro :declare\n:macro\nThe argument is a list of local macro definitions, each of the form (name definition). Note that the argument is not in the same format as the cadr of a macrolet special form. Each definition must be a function of two arguments (a form and an environment). The new environment will have local macro bindings of each name to the corresponding expander function, which will be returned by macro-function and used by macroexpand.\nCLTL2 8.5 Environment\n\n    (defmacro iter (... &environment env)\n      ...\n      (walk-code ... env))\n\n    (defun walk-code (form env)\n      ...\n      (when (eq 'macrolet (car form))\n        (destructuring-bind (car macros . body) form\n          (declare (ignore car))\n          (walk-code\n            `(progn ,@body)\n            (augment-environment\n             env\n             :macro (mapcar (rcurry #'parse-macro env) macros))))))\n\nWell, well, however, is it clever to implement such a code walker? We have lots of special forms let,tagbody,block,catch which are already correctly handled by the implementation, and possibly some other implementation-dependent special forms (in sbcl, sb!ext:truly-the and sb!sys:with-pinned-objects). Isn't it just re-implementing those feature by hand? Quite *un*clever, isn't it? (no offence, I don't mean to insult iterate's author - I love it, but its implementation is badly affected by the design of the macro system in CL.)\nAlso, the code processed by walk-code is traversed again by the bytecode/native compiler, or an evaluator. They search for macro forms again, with similar implementation to that of walk-code -- it's just inefficient.\n    (eval            ; let\n     (eval           ; iter\n      (macroexpand)  ; expand `iter`, calling `walk-code` inside it\n      (eval)))       ; `eval` traverse the body again\n\nAnother aspect of the problem is here.\n    (let ((x 0))\n      (let ((y x))\n        (declare (fixnum y))\n        ...))\n\nlet is not a macro, but assume it is one.  In this example, y is declared to be a fixnum.  However, humans easily know that y is directly copied from x and x is unmodified -- you want the compiler to automatically deduce x to be a fixnum, don't you? By backtracking the expansion?\nThe core problem of current macro system is essentially the following: it is not able to propagate the inner constraints to the outer environment.  Communications between the outer and the inner macros are virtually impossible. As a result, such tasks tend to be handled by a implementation specific extensions such as deftransform in sbcl.\n\nConclusion\nCurrent macro system calls expansions and traversals independently, which does not allow the backtracking during the macro expansion.  It inhibits the communication between the inner and outer macros, especially from the former(inside) to the latter(outside), thus restricting the ability of macros in general.\nIn this article, we proposed a recursive macro system with a notion of compile-time continuation, which is a closure of one argument and when called with a form it continues the traversal and expand of the subforms. We also showed its benefit i.e. such system potentially has a more easy-to-use interface for a constraint propagation from the inner to the outer code.\nComments are welcome.\n# Abstract\n\nMacro is one of the most characteristic feature of the Lisp-family of languages which allows the higher level of abstraction by extending the syntax of the language. If a head of an S-expression specifies a macro, then the whole expression, which is a list, are passed to the corresponding macro-function and it replaces the original expression with the new list returned by the function. This expansion, or *compilation*, is done from the root to the leaf in a iterative manner.\n\nIn this article, we show the current limit of the macro system in ANSI Common Lisp. We also show an alternative macro expansion system which overcomes the limitation.\n\nThe rest of the article is organized as follows: we first briefly review the basic usage of macro and its behavior. We also investigate the behavior of the interpreter in `sbcl` in order to see how macros are processed during the code traversal (for evaluation or bytecode/native compilation). Based on these introductions, we then show that the current macro system is not able to give a clean implementation of certain kinds of *local macros* in `iterate`, and we introduce a notion of *compile-time continuation* as well as showing how it overcomes the problem.\n\nIn *Related Works*, we see the current implementation of `iterate`. We also briefly introduce a now somewhat forgotten [*expression passing style* by Dybvig](http://www.cs.indiana.edu/l/www/pub/techreports/TR195.pdf) as a similar concept.\n\n# Preliminaries\n\n(I assume everyone reading this article are already familiar with macros, so I just explain it very briefly)\n\nMacros, functions and variables related to Macro System:\n\n```cl\n(defmacro name lambda-list &body body)\n(macrolet bindings &body body)\n(eval form)\n(compile name definition)\n(macroexpand form &optional env)\n(macroexpand-1 form &optional env)\n*macroexpand-hook*\n```\n\nFunctions provided by CLtL2, which allows the manipulation of the environments:\n\n```cl\nAUGMENT-ENVIRONMENT\nCOMPILER-LET\nDECLARATION-INFORMATION\nDEFINE-DECLARATION\nENCLOSE\nFUNCTION-INFORMATION\nPARSE-MACRO\nVARIABLE-INFORMATION\n```\n\n\n# Basic Usage of Macros and its Behavior\n\nMacro functions are essentially functions which takes a list (form) and an environment, and return a new list (form).  They can be defined via `defmacro` . `defmacro` is almost like `defun` but stores the function in a `macro-function` namespace. At the lowest level, an S-expression is expanded via `macroexpand-1` .\n\n```cl\n(macroexpand-1 form &optional env) -> expansion, expanded-p\n```\n\n> If form is a macro form, then the `expansion` is a macro expansion and `expanded-p` is true. Otherwise, the `expansion` is the given form and `expanded-p` is false. \n> [CLHS macroexpand-1](http://www.ai.mit.edu/projects/iiip/doc/CommonLISP/HyperSpec/Body/fun_macroexpa_acroexpand-1.html)\n\nIf a head of an S-expression specifies a macro, which means the form is a *macro form*, then the whole expression, which is a list, are passed to the corresponding macro-function and it replaces the original expression with the new list returned by the function.\n\nIn the example below, the `*form*` begins with `let` and it is a *special form*, so `macroexpand-1` does nothing.\n\n```cl\n(defmacro my-unless (condition &body body)\n  `(when (not ,condition)\n     ,@body))\n\n(defparameter *form*\n  `(let ((x 5))\n     (my-unless (plusp x)\n       (print :minus))))\n\n(macroexpand-1 *form*)\n; -->\n;  (LET ((X 5))\n;    (MY-UNLESS (PLUSP X)\n;      (PRINT :MINUS)))\n;  NIL\n```\n\nThe next example, however, contains a *macro form* directly:\n\n```cl\n(defparameter *form2*\n  `(my-unless (plusp x)\n      (print :minus)))\n```\n\nand if it is passed to `macroexpand-1`, it expands the definition:\n\n\n```cl\n(macroexpand-1 *form2*)\n;; -->\n;; (WHEN (NOT (PLUSP X)) (PRINT :MINUS))\n;; T\n```\n\nAs a result, `when` appears as defined in `my-unless`. The secondary value is `T` because the expansion was done. Furthermore, since `when` is again a macro, the repeated expansion gives the following results:\n\n```cl\n(macroexpand-1 (macroexpand-1 *form2*))\n;; ->\n;; (IF (NOT (PLUSP X))\n;;     (PROGN (PRINT :MINUS))\n;;     NIL)\n;; T\n(macroexpand-1 (macroexpand-1 (macroexpand-1 *form2*)))\n;; ->\n;; (IF (NOT (PLUSP X))          ; no expansion\n;;     (PROGN (PRINT :MINUS))\n;;     NIL)\n;; NIL\n```\n\nAs a result of the third expansion, `if` being a *special operator*, not a macro, the expansion stops and the secondary value is `NIL`.\n\n`macroexpand` repeatedly expands a form using `macroexpand-1`, watching its secondary Boolean return value. It stops the expansion when it see `NIL` in the secondary value in the first time.\n\n```cl\n(macroexpand *form2*)\n;; -->\n;; (IF (NOT (PLUSP X))\n;;     (PROGN (PRINT :MINUS))\n;;     NIL)\n;; T\n```\n\nNote that `macroexpand` does *not* expands the inner nodes: it expands only the *root node* of the S-expression syntax tree.\n\n```cl\n(macroexpand *form*)\n;; -->\n;;  (LET ((X 5))\n;;    (MY-UNLESS (PLUSP X)\n;;      (PRINT :MINUS)))\n;;   NIL\n```\n\n\n# Code Expansion during the Traversal\n\nIn the previous section, we saw that `macroexpand` expands the root node only. If so, when and how the inner nodes are expanded?\n\nThe code of `eval` helps us investigate the behavior of macro expansion. `eval` interprets and executes a form, but the word `interpreter` is sometimes *misinterpreted* as if it does not do any compilation --- which actually does. It doesn't run a byte-code/native-code compilation, but macros are always expanded, as described in [CLHS 3. Evaluation and Compilation](http://www.ai.mit.edu/projects/iiip/doc/CommonLISP/HyperSpec/Body/chap-3.html).\n\nTalking about which implementation of `eval` to investigate, we see `eval` in `sb-eval`, which is included in the recent `sbcl`. `sbcl` and other implementations with `python` native compiler is known to have *always-compile* strategy, but if we set `sb-eval:*evaluator-mode*` to `:interpret`, we get a true interpreter.\n\n```cl\nCL-USER> (setf *evaluator-mode* :interpret) \n; --> :INTERPRET\n```\n\nOK, let's see what's happening inside `eval`:\n\n```cl\n(defun eval (original-exp)\n  (eval-in-lexenv original-exp (make-null-lexenv)))\n\n;; \u2193\n\n(defun eval-in-lexenv (exp lexenv)\n  (if (eq *evaluator-mode* :compile)\n      ...\n      (sb!eval:eval-in-native-environment exp lexenv)))\n\n;; \u2193 \n\n(defun eval-in-native-environment (form lexenv)\n  (handler-bind\n      ((sb!impl::eval-error ...))\n      ...\n      (%eval form env)))\n\n;; \u2193\n\n(defun %eval (exp env)\n  ...\n  (%%eval exp env))\n\n;; \u2193\n```\n\nits sooo heavily nested. well, well,...\n\n```cl\n(defun %%eval (exp env)\n  (cond\n    ((symbolp exp)\n     ;; CLHS 3.1.2.1.1 Symbols as Forms\n     (multiple-value-bind (value kind) (get-variable exp env)\n       (ecase kind\n         (:variable value)\n         (:expansion (%eval value env)))))\n    ;; CLHS 3.1.2.1.3 Self-Evaluating Objects\n    ((atom exp) exp)\n    ;; CLHS 3.1.2.1.2 Conses as Forms\n    ((consp exp)\n     (case (car exp)\n       ;; CLHS 3.1.2.1.2.1 Special Forms\n       ((block)                (eval-block (cdr exp) env))\n       ((catch)                (eval-catch (cdr exp) env))\n       ;;\n       ;; 20 or more special forms **skipped**\n       ;; \n       (t\n        (let ((dispatcher (getf *eval-dispatch-functions* (car exp))))\n          (cond\n            (dispatcher ; for cltl2:compiler-let\n             (funcall dispatcher exp env))\n            ;; CLHS 3.1.2.1.2.4 Lambda Forms\n            ((and (consp (car exp)) (eq (caar exp) 'lambda))\n             (interpreted-apply (eval-function (list (car exp)) env)\n                                (eval-args (cdr exp) env)))\n            (t\n             (multiple-value-bind (function kind) (get-function (car exp) env)\n               (ecase kind\n                 ;; CLHS 3.1.2.1.2.3 Function Forms\n                 (:function (%apply function (eval-args (cdr exp) env)))\n                 ;; CLHS 3.1.2.1.2.2 Macro Forms\n                 (:macro\n                  ;; ** This is what we want **\n                  )))))))))))\n```\n\nExtracting only those part we are interested in, then it is:\n\n```cl\n(let ((hook *macroexpand-hook*)) ; hook = funcall by default\n  (%eval (funcall hook\n                  function\n                  exp\n                  (env-native-lexenv env))\n         env))\n```\n\nWe see that the evaluator first expand the macro (root node only) and then evaluate the expansion again.\n\n## The Call Stack\n\nGiven above implementation of `eval`, let's review the behavior of the call stack during the evaluation. And we get the following:\n\n```cl\n;; the code to be evaluated:\n(let ((x 5))\n  (my-unless (plusp x)\n    (print :minus)))\n\n;; the expansion\n(let ((x 5))\n  (IF (NOT (PLUSP X))\n      (PROGN (PRINT :MINUS))\n      NIL))\n\n;; call stack\n(eval            ; let\n (eval           ; my-unless\n  (macroexpand)  ; my-unless -> when -> if\n  (eval          ; if\n    (eval-if       ; if\n     (eval (eval)) ; (not (plusp x))\n     (eval))))     ; (progn ...) or NIL\n```\n\nWe see a `macroexpand` during the evaluation. That's good.  Then, what if the code needs the macro expansion twice?  Here it is.\n\n```cl\n;; the code to be evaluated:\n(my-unless (plusp x)\n  (my-unless (minusp x)\n    (print :zero)))  \n\n;; the expansion\n(IF (NOT (PLUSP X))\n    (PROGN\n     (IF (NOT (MINUSP X))\n         (PROGN (PRINT :ZERO))\n         NIL))\n    NIL)\n\n;; call stack\n(eval               ; my-unless\n (macroexpand)      ; my-unless -> when -> if\n (eval              ; if\n  (eval-if            ;if\n    (eval             ; (not (plusp))\n     (eval            ; my-unless\n      (macroexpand)   ; my-unless -> when -> if\n      (eval ...)))))  ; if ...\n```\n\nNow, notice that each expansion is called independently -- the information of outer expansion is not on the stack when the inner expansion occurs. This leads to the fundamental problem shown in the next section.\n\n# Local Macros -- with macrolet --\n\nThe above behavior somewhat inhibits the easy implementation of some *smart* local macros. Local macros? Why not use just `macrolet` ??\n\nWe describe the reason by implementing the simple version of `iterate`. It has a syntax as shown below:\n\n```cl\n    ;; inside `iter`, `while` continues the execution only when the argument is true.\n    ;; `collect` accumulate its argument into a list and make `iter` return the accumulated result.\n    ;; `while` and `collect` signals an error outside `iter`.\n    \n    (let ((i 0))\n      (iter (while (< i 5))\n            (incf i)\n            (collect (+ 3 (* 4 i)))))\n```\n\nLet's implement it with `macrolet`.  It is possible, clean and simple.\n    \n```cl    \n    (define-condition compile-error (simple-error)\n      ((message :initarg :message :accessor message))\n      (:report (lambda (c s)\n                 (princ (message c) s))))\n    \n    (defmacro collect (x)\n      (declare (ignore x))\n      (error 'compile-error\n             :message \"`collect' must be used under `iter'\"))\n    \n    (defmacro while (x)\n      (declare (ignore x))\n      (error 'compile-error\n             :message \"`while' must be used under `iter'\"))\n    \n    (require :alexandria)\n    (use-package :alexandria)\n    \n    (defmacro iter (&body body)\n      (with-gensyms (iter-block accumulate start)\n        `(block ,iter-block\n           (let ((,accumulate nil))\n             (macrolet ((while (condition)\n                          `(unless ,condition\n                             (return-from ,',iter-block\n                               (nreverse ,',accumulate))))\n                        (collect (thing)\n                          `(push ,thing ,',accumulate)))\n               (tagbody\n                 ,start\n                 ,@body\n                 (go ,start)))))))\n    \n    (let ((i 0))\n      (iter (while (< i 5))\n            (incf i)\n            (collect (+ 3 (* 4 i)))))\n    \n    ;; --> (7 11 15 19 23)\n```\n\nWorked well. Sounds good. What's the problem?\n\nOK, then go further: let's implement `(collect x into acc)` feature in the original `iterate` . It allows users to specify the name of the list that the elements are accumulated. But again, only with macrolet.\n\n```    \n    (let ((i 0))\n      (iter (while (< i 5))\n            (incf i)\n            (print acc) ; <--\n            (collect (+ 3 (* 4 i)) :into acc))) ; <--\n```\n\nWhat now? You may easily encounter a problem: How we safely bind the symbol `acc`? Without destructing the global environment?\n\nIn order to bind a variable safely, we need to wrap the entire loop with `let` . The problem exists here: the `collect` clause are expanded **only after the expansion of iter** . The bad thing is, we have no way behind -- backtracking the expansion is impossible. No method to go back to the pre-expansion state.\n\n# Macros in Common Lisp are still *restricted*\n\nHere resides the crucial problem in the macro system in Common Lisp.\n\n**Expansion is done iteratively, not recursively**\n\nEven CLHS writes:\n\n>  macroexpand **repeatedly** expands form until it is no longer a macro form. In effect, macroexpand calls macroexpand-1 repeatedly until the secondary value it returns is nil. -- [CLHS Function MACROEXPAND, MACROEXPAND-1](http://www.ai.mit.edu/projects/iiip/doc/CommonLISP/HyperSpec/Body/fun_macroexpa_acroexpand-1.html)\n\nIf the previous expansion context is on the stack, we can signal an error and backtrack the expansion like:\n\n```cl\n    (collect (thing &key into)\n      (if into\n          (error 'accumulate-target :name into) ; Compile it again!\n          `(push ,thing ,',accumulate)))\n```\n\nand the handler in the `iter` might catch the signal.\n\nHypothetical implementation following such a macro system is shown below. In `defmacro`, we have additional argument `&continuation cont` that takes a closure which continue the expansion of the inner clauses. If a condition is signaled from the upper stack, then it is handled by the handler here and it recompile the whole clause again.\n\n```cl\n   (defmacro iter (&body body &continuation cont)\n      (with-gensyms (iter-block accumulate start)\n        (handler-case\n            (funcall #'cont\n                     `(block ,iter-block\n                        (let ((,accumulate nil))\n                          (macrolet ((while (condition)\n                                       `(unless ,condition\n                                          (return-from ,',iter-block\n                                            (nreverse ,',accumulate))))\n                                     (collect (thing &key into)\n                                       (if into\n                                           (signal 'accumulate-target :name into)\n                                           `(push ,thing ,',accumulate))))\n                            (tagbody\n                              ,start\n                              ,@body\n                              (go ,start))))))\n          ;; handler\n          (accumulate-target (c)\n            (setf accumulate (name c))\n            (funcall #'cont\n                     `(block ,iter-block\n                        (let ((,accumulate nil))\n                          (macrolet ((while (condition)\n                                       `(unless ,condition\n                                          (return-from ,',iter-block\n                                            (nreverse ,',accumulate))))\n                                     (collect (thing &key into)\n                                       `(push ,thing ,',accumulate)))\n                            (tagbody\n                              ,start\n                              ,@body\n                              (go ,start))))))))))\n```\n\nWe refer to this continuation `cont` as *compile-time continuation* because it is a continuation intended to be used in a macro expansion. These style itself is called as `Expression Passing Style` according to [*expression passing style* by Dybvig](http://www.cs.indiana.edu/l/www/pub/techreports/TR195.pdf) because it passes a sub-expression to the continuation. However, since the paper assumes a scheme-like system in describing the concept, the direct application to Common Lisp is not possible.\n\n# Related Works\n\nThe original `iterate`, however, does not handle the problem in this way. It rather has its own code walker to detect all `(collect ... into ...)` *prior to* the expansion of `iter`. This is clearly a dirty workaround -- consider a case that a `collect` clause is hidden in a expansion of another macro:\n\n```cl\n    ;; `collect` clause hidden in a macro\n    (defmacro my-collect (&rest args)\n      `(collect ,@args))\n    \n    (let ((i 0))\n      (iter (while (< i 5))\n            (incf i)\n            (print acc)\n            (my-collect (+ 3 (* 4 i)) into acc)))\n```\n\nIn order to detect all `collect` clause in any macro expansion, the code walker in `iterate` expands all macro inside the body of `iter`. This is dirty -- and has indeed a critical limitation:\n\n```cl\n    (require :iterate)\n    (in-package :iterate)\n    (let ((i 0))\n      (iter (while (< i 5))\n            (incf i)\n            (print acc)\n            (macrolet ((my-collect (&rest args)\n                         `(collect ,@args)))\n              (my-collect (+ 3 (* 4 i)) into acc))))\n    \n    ; in: LET ((I 0)) ...\n    ; \n    ; caught WARNING:\n    ;   Iterate:\n    ;   Iterate does not know how to handle \n    ;     the special form (MACROLET ...)\n    ;   It will not be walked, which means that Iterate clauses\n    ;   inside it will not be seen.\n    ;\n    ; compilation unit finished\n    ;   Undefined function:\n    ;     COLLECT\n    ;   Undefined variables:\n    ;     ACC INTO\n```\n\nThis is essentially a problem in ANSI CL. Theoretically, `augment-environment` and `parse-macro` defined in cltl2 allows the code walker to expand those clauses. The behavior may be the result of historical issue.\n\n> [Function] augment-environment env &key\n> \n> :variable :symbol-macro :function :macro :declare\n> \n> :macro\n> \n> The argument is a list of local macro definitions, each of the form (name definition). Note that the argument is **not** in the same format as the cadr of a macrolet special form. Each definition must be a function of two arguments (a form and an environment). The new environment will have local macro bindings of each name to the corresponding expander function, which will be returned by macro-function and used by macroexpand.\n>\n> [CLTL2 8.5 Environment](http://www.cs.cmu.edu/Groups/AI/html/cltl/clm/node102.html)\n\n```cl\n    (defmacro iter (... &environment env)\n      ...\n      (walk-code ... env))\n    \n    (defun walk-code (form env)\n      ...\n      (when (eq 'macrolet (car form))\n        (destructuring-bind (car macros . body) form\n          (declare (ignore car))\n          (walk-code\n            `(progn ,@body)\n            (augment-environment\n             env\n             :macro (mapcar (rcurry #'parse-macro env) macros))))))\n```\n\nWell, well, however, is it clever to implement such a code walker? We have lots of special forms `let,tagbody,block,catch` which are already correctly handled by the implementation, and possibly some other implementation-dependent special forms (in sbcl, `sb!ext:truly-the` and `sb!sys:with-pinned-objects`). Isn't it just re-implementing those feature by hand? Quite *un*clever, isn't it? (no offence, I don't mean to insult iterate's author - I love it, but its implementation is badly affected by the design of the macro system in CL.)\n\nAlso, the code processed by `walk-code` is traversed again by the bytecode/native compiler, or an evaluator. They search for macro forms again, with similar implementation to that of `walk-code` -- it's just inefficient.\n\n```cl\n    (eval            ; let\n     (eval           ; iter\n      (macroexpand)  ; expand `iter`, calling `walk-code` inside it\n      (eval)))       ; `eval` traverse the body again\n```\n\nAnother aspect of the problem is here.\n\n\n```cl\n    (let ((x 0))\n      (let ((y x))\n        (declare (fixnum y))\n        ...))\n```\n\n`let` is not a macro, but assume it is one.  In this example, `y` is declared to be a fixnum.  However, *humans easily know that* `y` is directly copied from `x` and `x` is unmodified -- you want the compiler to automatically deduce `x` to be a fixnum, don't you? By **backtracking the expansion?**\n\nThe core problem of current macro system is essentially the following: it is not able to propagate the **inner** constraints to the **outer** environment.  Communications between the outer and the inner macros are virtually impossible. As a result, such tasks tend to be handled by a implementation specific extensions such as `deftransform` in sbcl.\n\n# Conclusion\n\nCurrent macro system calls expansions and traversals independently, which does not allow the backtracking during the macro expansion.  It inhibits the communication between the inner and outer macros, especially from the former(inside) to the latter(outside), thus restricting the ability of macros in general.\n\nIn this article, we proposed a recursive macro system with a notion of `compile-time continuation`, which is a closure of one argument and when called with a form it continues the traversal and expand of the subforms. We also showed its benefit i.e. such system potentially has a more easy-to-use interface for a constraint propagation from the inner to the outer code.\n\nComments are welcome.\n", "tags": ["common-lisp", "lisp", "\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0"]}