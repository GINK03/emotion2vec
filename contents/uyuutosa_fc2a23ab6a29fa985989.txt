{"context": " More than 1 year has passed since last update.\n\n\u30ed\u30d0\u30b9\u30c8\u306a\u56de\u8ee2\u884c\u5217\u306e\u63a8\u5b9a\u30c6\u30b9\u30c8\n\u300c\u753b\u50cf\u7406\u89e33\u6b21\u5143\u306e\u6570\u7406\u300d\u91d1\u8c37\u5065\u4e00\u8457 \u8a18\u8f09\u306e\u3001\u30ab\u30e1\u30e9\u304c\u56de\u8ee2\u3057\u305f\u6642\u306e\u56de\u8ee2\u884c\u5217\u3092\u3001\u6700\u5c0f\u5316\u3092\u7528\u3044\u3066\u30ed\u30d0\u30b9\u30c8\u306b\u63a8\u5b9a\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0\u3002\u7279\u306b\u64fe\u4e71\u3092\u4e0e\u3048\u305f\u308a\u306f\u3057\u3066\u3044\u307e\u305b\u3093\u304c\u3001\u4eca\u5f8c\u30ce\u30a4\u30ba\u306b\u3069\u308c\u3060\u3051\u30ed\u30d0\u30b9\u30c8\u306a\u306e\u304b\u8a55\u4fa1\u3057\u3066\u307f\u305f\u3044\u3068\u8003\u3048\u3066\u3044\u307e\u3059\u3002\n\nestimate_R_with_polar_decomp_or_SVD.py\nr = array([0,0, pi/3])\nR = cv2.Rodrigues(r)[0]\nh = random.rand(3) * 100\nh /= norm(h)\n\nN = zeros((3,3))\nfor i in xrange(1000):\n    m = random.rand(3)\n    m = m / norm(m)\n    m2 = R.T.dot(m)\n    N += m[:, None] * m2\nRp, S = polar(N)\nU, s, Vt = svd(N)\nRs = U.dot(Vt)\n\n\nprint \"True value =\"\nprint R\nprint \"\"\nprint \"Estimate value with polar decomposition =\"\nprint Rp\nprint \"\"\nprint \"Estimate value with SVD =\"\nprint Rs\n\n\n\u51fa\u529b\u7d50\u679c:\nTrue value =\n[[  5.00000000e-01  -8.66025404e-01  -1.16573418e-15]\n [  8.66025404e-01   5.00000000e-01   1.27675648e-15]\n [ -2.41126563e-16  -1.60982339e-15   1.00000000e+00]]\n\nEstimate value with polar decomposition =\n[[  5.00000000e-01  -8.66025404e-01   2.63677968e-16]\n [  8.66025404e-01   5.00000000e-01   5.55111512e-17]\n [  0.00000000e+00   2.22044605e-16   1.00000000e+00]]\n\nEstimate value with SVD =\n[[  5.00000000e-01  -8.66025404e-01   2.63677968e-16]\n [  8.66025404e-01   5.00000000e-01   5.55111512e-17]\n [  0.00000000e+00   2.22044605e-16   1.00000000e+00]]\n\n\n\u30ed\u30d0\u30b9\u30c8\u306a\u57fa\u672c\u884c\u5217\u5206\u89e3\u30c6\u30b9\u30c8\n\u540c\u3058\u304f\u540c\u8457\u8a18\u8f09\u306e\u5bfe\u5fdc\u70b9\u306e\u30da\u30a2\u306e\u30ea\u30b9\u30c8\u304b\u3089\u6700\u5c0f\u5316\u3092\u7528\u3044\u3066\u904b\u52d5\u30d1\u30e9\u30e1\u30fc\u30bf\u3092\u63a8\u5b9a\u3059\u308b\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0\u3002\nG = array([cross(h, R[:,0]), cross(h, R[:, 1]), cross(h, R[:,2])])\nG_tild = G.flatten()\nG_tild = G_tild / norm(G_tild) * sqrt(2.)\nn = 100\nM_tild = zeros((9,9))\nrandlst = []\n\n\nfor i in range(n):\n    vec = random.rand(3)\n    vec = vec / norm(vec) \n    randlst += [vec]\n\nfor m2 in randlst:\n    m = R.dot(m2) + h\n    mi = tensor(m, \"i\", \"d\")\n    m2j = tensor(m2, \"j\", \"d\")\n    mk = tensor(m, \"k\", \"d\")\n    m2l = tensor(m2, \"l\", \"d\")\n    M_t = mi * m2j * mk * m2l\n    M_t.transpose(\"ijkl\")\n    M_tild += M_t.arr.reshape((9,9))\n\nw, v = eigh(M_tild)\nG_tild2 = v[:, argmin(w)] / norm(v[:, argmin(w)]) * sqrt(2)\nG_hat = G_tild2.reshape((3,3)).T\n#print G_hat\nw, v = eigh(G_hat.dot(G_hat.T))\nh_hat = v[:, argmin(w)] / norm(v[:, argmin(w)])\n#input(G_hat)\nep = tensor_ps(3, idx=\"ikl\", ud=\"ddd\")\nG_hat_t = tensor(G_hat, \"kj\", \"ud\")\nh_hat_t = tensor(h_hat, \"l\", \"u\")\nK_hat = ep * G_hat_t * h_hat_t\n\nK_hat.transpose(\"ij\")\nK_hat = K_hat.arr\n\nR_hat, S = polar(K_hat)\n\nprint \"G=\"\nprint G\nprint \"G_hat=\"\nprint G_hat\nprint \"K_hat\"\nprint K_hat\nprint \"R=\"\nprint R\nprint \"R_hat=\"\nprint R_hat\nprint \"h=\"\nprint h\nprint \"h_hat=\"\n\nprod = 0\nfor m2 in randlst:\n    m = R.dot(m2) + h\n    prod += cross(h, m).dot(G_hat.dot(m2))\nh_hat = h_hat if prod > 0 else -h_hat\n\nprint h_hat\n\n\u51fa\u529b\u7d50\u679c:\nG=\n[[-0.01710211  0.16271571 -0.67909514]\n [-0.16271571 -0.01710211  0.71558431]\n [ 0.75017391 -0.6406795   0.        ]]\nG_hat=\n[[  1.71021107e-02   1.62715715e-01  -7.50173912e-01]\n [ -1.62715715e-01   1.71021107e-02   6.40679496e-01]\n [  6.79095138e-01  -7.15584312e-01   4.34179630e-14]]\nK_hat\n[[ 0.5360617  -0.53961079 -0.10482285]\n [-0.43228422  0.48508244 -0.12273745]\n [-0.11707818 -0.11110811  0.97323111]]\nR=\n[[ 0.9945219  -0.10452846  0.        ]\n [ 0.10452846  0.9945219   0.        ]\n [ 0.          0.          1.        ]]\nR_hat=\n[[  9.94521895e-01  -1.04528463e-01   3.75532938e-13]\n [  1.04528463e-01   9.94521895e-01   4.25284807e-13]\n [ -4.18137747e-13  -3.83595933e-13   1.00000000e+00]]\nh=\n[ 0.6406795   0.75017391  0.163612  ]\nh_hat=\n[ 0.6406795   0.75017391  0.163612  ]\n\n\n\u64fe\u4e71\u304c\u7121\u3044\u6761\u4ef6\u3067\u306f\u3001\u8a2d\u5b9a\u5024\u3068\u63a8\u5b9a\u5024(_hat)\u304c\u307b\u307c\u4e00\u81f4\u3057\u3066\u3044\u307e\u3059\u3002\n\n##\u30ed\u30d0\u30b9\u30c8\u306a\u56de\u8ee2\u884c\u5217\u306e\u63a8\u5b9a\u30c6\u30b9\u30c8\n\u300c\u753b\u50cf\u7406\u89e33\u6b21\u5143\u306e\u6570\u7406\u300d\u91d1\u8c37\u5065\u4e00\u8457 \u8a18\u8f09\u306e\u3001\u30ab\u30e1\u30e9\u304c\u56de\u8ee2\u3057\u305f\u6642\u306e\u56de\u8ee2\u884c\u5217\u3092\u3001\u6700\u5c0f\u5316\u3092\u7528\u3044\u3066\u30ed\u30d0\u30b9\u30c8\u306b\u63a8\u5b9a\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0\u3002\u7279\u306b\u64fe\u4e71\u3092\u4e0e\u3048\u305f\u308a\u306f\u3057\u3066\u3044\u307e\u305b\u3093\u304c\u3001\u4eca\u5f8c\u30ce\u30a4\u30ba\u306b\u3069\u308c\u3060\u3051\u30ed\u30d0\u30b9\u30c8\u306a\u306e\u304b\u8a55\u4fa1\u3057\u3066\u307f\u305f\u3044\u3068\u8003\u3048\u3066\u3044\u307e\u3059\u3002\n\n```python:estimate_R_with_polar_decomp_or_SVD.py\nr = array([0,0, pi/3])\nR = cv2.Rodrigues(r)[0]\nh = random.rand(3) * 100\nh /= norm(h)\n\nN = zeros((3,3))\nfor i in xrange(1000):\n    m = random.rand(3)\n    m = m / norm(m)\n    m2 = R.T.dot(m)\n    N += m[:, None] * m2\nRp, S = polar(N)\nU, s, Vt = svd(N)\nRs = U.dot(Vt)\n\n\nprint \"True value =\"\nprint R\nprint \"\"\nprint \"Estimate value with polar decomposition =\"\nprint Rp\nprint \"\"\nprint \"Estimate value with SVD =\"\nprint Rs\n```\n\n\u51fa\u529b\u7d50\u679c:\n\n```result\nTrue value =\n[[  5.00000000e-01  -8.66025404e-01  -1.16573418e-15]\n [  8.66025404e-01   5.00000000e-01   1.27675648e-15]\n [ -2.41126563e-16  -1.60982339e-15   1.00000000e+00]]\n\nEstimate value with polar decomposition =\n[[  5.00000000e-01  -8.66025404e-01   2.63677968e-16]\n [  8.66025404e-01   5.00000000e-01   5.55111512e-17]\n [  0.00000000e+00   2.22044605e-16   1.00000000e+00]]\n\nEstimate value with SVD =\n[[  5.00000000e-01  -8.66025404e-01   2.63677968e-16]\n [  8.66025404e-01   5.00000000e-01   5.55111512e-17]\n [  0.00000000e+00   2.22044605e-16   1.00000000e+00]]\n```\n\n##\u30ed\u30d0\u30b9\u30c8\u306a\u57fa\u672c\u884c\u5217\u5206\u89e3\u30c6\u30b9\u30c8\n\u540c\u3058\u304f\u540c\u8457\u8a18\u8f09\u306e\u5bfe\u5fdc\u70b9\u306e\u30da\u30a2\u306e\u30ea\u30b9\u30c8\u304b\u3089\u6700\u5c0f\u5316\u3092\u7528\u3044\u3066\u904b\u52d5\u30d1\u30e9\u30e1\u30fc\u30bf\u3092\u63a8\u5b9a\u3059\u308b\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0\u3002\n\n```python\nG = array([cross(h, R[:,0]), cross(h, R[:, 1]), cross(h, R[:,2])])\nG_tild = G.flatten()\nG_tild = G_tild / norm(G_tild) * sqrt(2.)\nn = 100\nM_tild = zeros((9,9))\nrandlst = []\n\n\nfor i in range(n):\n    vec = random.rand(3)\n    vec = vec / norm(vec) \n    randlst += [vec]\n    \nfor m2 in randlst:\n    m = R.dot(m2) + h\n    mi = tensor(m, \"i\", \"d\")\n    m2j = tensor(m2, \"j\", \"d\")\n    mk = tensor(m, \"k\", \"d\")\n    m2l = tensor(m2, \"l\", \"d\")\n    M_t = mi * m2j * mk * m2l\n    M_t.transpose(\"ijkl\")\n    M_tild += M_t.arr.reshape((9,9))\n    \nw, v = eigh(M_tild)\nG_tild2 = v[:, argmin(w)] / norm(v[:, argmin(w)]) * sqrt(2)\nG_hat = G_tild2.reshape((3,3)).T\n#print G_hat\nw, v = eigh(G_hat.dot(G_hat.T))\nh_hat = v[:, argmin(w)] / norm(v[:, argmin(w)])\n#input(G_hat)\nep = tensor_ps(3, idx=\"ikl\", ud=\"ddd\")\nG_hat_t = tensor(G_hat, \"kj\", \"ud\")\nh_hat_t = tensor(h_hat, \"l\", \"u\")\nK_hat = ep * G_hat_t * h_hat_t\n\nK_hat.transpose(\"ij\")\nK_hat = K_hat.arr\n\nR_hat, S = polar(K_hat)\n\nprint \"G=\"\nprint G\nprint \"G_hat=\"\nprint G_hat\nprint \"K_hat\"\nprint K_hat\nprint \"R=\"\nprint R\nprint \"R_hat=\"\nprint R_hat\nprint \"h=\"\nprint h\nprint \"h_hat=\"\n\nprod = 0\nfor m2 in randlst:\n    m = R.dot(m2) + h\n    prod += cross(h, m).dot(G_hat.dot(m2))\nh_hat = h_hat if prod > 0 else -h_hat\n \nprint h_hat\n```\n\n\u51fa\u529b\u7d50\u679c:\n\n```\nG=\n[[-0.01710211  0.16271571 -0.67909514]\n [-0.16271571 -0.01710211  0.71558431]\n [ 0.75017391 -0.6406795   0.        ]]\nG_hat=\n[[  1.71021107e-02   1.62715715e-01  -7.50173912e-01]\n [ -1.62715715e-01   1.71021107e-02   6.40679496e-01]\n [  6.79095138e-01  -7.15584312e-01   4.34179630e-14]]\nK_hat\n[[ 0.5360617  -0.53961079 -0.10482285]\n [-0.43228422  0.48508244 -0.12273745]\n [-0.11707818 -0.11110811  0.97323111]]\nR=\n[[ 0.9945219  -0.10452846  0.        ]\n [ 0.10452846  0.9945219   0.        ]\n [ 0.          0.          1.        ]]\nR_hat=\n[[  9.94521895e-01  -1.04528463e-01   3.75532938e-13]\n [  1.04528463e-01   9.94521895e-01   4.25284807e-13]\n [ -4.18137747e-13  -3.83595933e-13   1.00000000e+00]]\nh=\n[ 0.6406795   0.75017391  0.163612  ]\nh_hat=\n[ 0.6406795   0.75017391  0.163612  ]\n\n```\n\n\u64fe\u4e71\u304c\u7121\u3044\u6761\u4ef6\u3067\u306f\u3001\u8a2d\u5b9a\u5024\u3068\u63a8\u5b9a\u5024(_hat)\u304c\u307b\u307c\u4e00\u81f4\u3057\u3066\u3044\u307e\u3059\u3002\n", "tags": ["\u7279\u7570\u5024\u5206\u89e3", "Python", "\u6975\u5206\u89e3", "ComputerVision"]}