{"context": " More than 1 year has passed since last update.Lots of people have very romantic thoughts about building the perfect web app with everything flowing so smoothly, with very clean definitions of what is to be expected where. A lot of people also believe in creating React components that have all of their JSX in the render method, where they can be sure that a lot of the other lifecycle events that aren't too pleasant or \"declarative\" can be avoided.\nUnfortunately, this is not one of those posts. I make heavy use of very ugly parts of React and modify the DOM as I see fit in order to do what is easiest for me to do. And really, if a components shits all over your DOM but still adheres to the component tree and cleans up after itself, was there really shit in the forest? Probably, but let's not worry about the that for now.\n\n\"Requirements\"/\"Specifications\"\nOur godforsaken dynamic width scroll table (to be called \"crappy table\" from here on) needs to do the following things:\n\nbe able to account for fixed-width columns while dynamically sizing the widths that have not been specified\nbe \"fast\" by letting the user just scroll up and down forever\ntake less than 4s to \"load\" a lot of rows\nhave a mental model that's easy to reason about\n\n\n\"Math\"\nI hate complicated crap, so here's my math for figuring out how to size my columns:\ndefinitions:\n  totalWidth = sumOfFixedWidthColumnWidths + (sumOfDynamicWidthColumnWidths)\n  sumOfDynamicWidthColumnWidths = numOfDynamicWidthColumns * avgWidthOfDynamicWidthColumns\n\nfiguring out my dynamic width column widths:\n  totalWidth - sumOfFixedWidthColumnWidths = numOfDynamicWidthColumns * widthOfDynamicWidthColumns\n  widthOfDynamicWidthColumns = (totalWidth - sumOfFixedWidthColumnWidths) / numOfDynamicWidthColumns\n\nHoly crap, all those years of school I did is finally paying off! I can do algebra! I'm a genius!\nAs for figuring out how to make this crap fast to render, I'm somewhat sure there's no real way to make anything faster in computers other than to make computers do less. So I'm going to just prevent rendering of rows that aren't going to be visible, I think. I'm too lazy to figure this out, so I'm just going to use prior art.\n\nGetting started\nHow the hell do I know the width of a container anyway? This sounds way too hard to do the actual calculation for, especially with other factors like styling involved. I will know two of my values above beforehand though: sumOfFixedWidthColumnWidths and numOfDynamicWidthColumns. Hmm, I know. I'll just render this damn container to the DOM and then get the width from there! link\n<div className=\"fixed-scroll-element-container\">\n  <div\n    ref=\"HeaderContainer\"\n    className=\"fixed-scroll-element-header\"/>\n\n  <div\n    ref=\"Container\"\n    className=\"fixed-scroll-element\"\n    style={containerStyle}/>\n</div>\n\nAfter this renders, I can just get the width from the actual nodes and calculate my column widths. link1 link2\n// rowWidth: number -- the width of our row\n// columnWidths: Array -- an array with the widths of the columns we're going to be using, where a real number will be in there if we have a width.\nfunction getColumnWidths(rowWidth, columnWidths) {\n  var computation = columnWidths.reduce(function (agg, width) {\n    if (typeof width === 'number') {\n      agg.remainingWidth -= width;\n      agg.customWidthColumns -= 1;\n    }\n    return agg;\n  }, {\n    autoSizeColumns: columnWidths.length,\n    remainingWidth: rowWidth\n  });\n\n  var standardWidth = computation.remainingWidth / computation.autoSizeColumns;\n\n  return columnWidths.map(function (width) {\n    if (width) {\n      return width;\n    } else {\n      return standardWidth;\n    }\n  });\n}\n\nvar containerWidth = this.containerNode.offsetWidth;\nvar computedColumnWidths = getColumnWidths(containerWidth, this.props.columnWidths);\n\nWith the column widths figured out, we can then do the deferred rendering onto the container to actually render what we have. link1 link2\ndeferredRender: function (columnWidths, containerWidth) {\n  // this is the render for when the container has been rendered\n  // and we know explicitly the container width\n  var rows = this.state.visibleIndices.map((itemIndex, keyIndex) => {\n    var top = itemIndex * this.props.rowHeight;\n    return this.props.rowGetter(itemIndex, keyIndex, top, columnWidths, containerWidth);\n  });\n\n  return (\n    <table\n      style={{height: this.props.rowCount * this.props.rowHeight}}>\n      <tbody>\n        {rows}\n      </tbody>\n    </table>\n  );\n},\n\nvar output = this.deferredRender(computedColumnWidths, containerWidth);\nReact.render(output, this.containerNode);\n\nOops, looks like I haven't talked about how to get 'visible indices' yet.\n\nRxJS to get all this crap together\nJust like that article I linked earlier, I want to only calculate the visible indices. On the initial render, I want to grab the scroll position inside the container, and then on every scroll event, I want the same function to be called to get the scroll position.\nAt first, I thought doing this would be hard, but then I remembered RxJS does everything for me. link\nsetUpTable: function () {\n  var containerHeight = this.props.containerHeight;\n  var rowHeight = this.props.rowHeight;\n  var rowCount = this.props.rowCount;\n\n  var visibleRows = Math.ceil(containerHeight/ rowHeight);\n\n  var getScrollTop = () => {\n    return this.containerNode.scrollTop;\n  };\n\n  var initialScrollSubject = new Rx.ReplaySubject(1);\n  initialScrollSubject.onNext(getScrollTop());\n\n  var scrollTopStream = initialScrollSubject.merge(\n    Rx.Observable.fromEvent(this.containerNode, 'scroll').map(getScrollTop)\n  );\n\n  var firstVisibleRowStream = scrollTopStream.map(function (scrollTop) {\n    return Math.floor(scrollTop / rowHeight);\n  }).distinctUntilChanged();\n\n  var visibleIndicesStream = firstVisibleRowStream.map(function (firstRow) {\n    var visibleIndices = [];\n    var lastRow = firstRow + visibleRows + 1;\n\n    if (lastRow > rowCount) {\n      firstRow -= lastRow - rowCount;\n    }\n\n    for (var i = 0; i <= visibleRows; i++) {\n      visibleIndices.push(i + firstRow);\n    }\n    return visibleIndices;\n  });\n\n  this.visibleIndicesSubscription = visibleIndicesStream.subscribe((indices) => {\n    this.setState({\n      visibleIndices: indices\n    });\n  });\n}\n\nAnd so we calculate the visible indices based on the height of the container and how many rows will fit in the container, and then we set the component state for how many indices we should display. Easy enough, right?\nThe other thing we need to tackle -- the godforsaken dynamic width part. On every window resize, we basically need to force an update of our component, and the width computation will get done to figure it out (we could probably move width calculation into setUpTable, but I was too lazy to do that). Well, this is too easy. link\nvar windowResizeStream = Rx.Observable.fromEvent(window, 'resize').debounce(50);\nthis.windowResizeSubscription = windowResizeStream.subscribe(() => {\n  this.forceUpdate();\n});\n\n\nWrapping it up\nSo now that we have everything set up in our crappy table component, the only thing left to do is to actually use it! There's not much informative here, so I'll just link it: https://github.com/justinwoo/godforsaken-dynamic-width-scroll-table/blob/ff872346dab5af66e337e8af718d8e41a401c4e8/example/src/index.js\nScreenshots of this in action:\n\nbefore resizing\n\nafter resizing\nAs we set in our columns widths, the first column stays at one width, while the other two are resized as the window resizes.\nAnd the scrolling...\n\nWell, you can't tell it's smooth from the GIF, but I promise you, it is very smooth. Actually, you don't have to take my word for it, check out the demo yourself!\nHope this was at least somewhat useful for somebody out there! Shout at me at Twitter if you think this is useless/useful!\n\nMy Links\n\nDemo: http://justinwoo.github.io/godforsaken-dynamic-width-scroll-table/\n\nRepo: https://github.com/justinwoo/godforsaken-dynamic-width-scroll-table\n\n\n\nReferences\n\nReactJS Component Specs and Lifecycle: https://facebook.github.io/react/docs/component-specs.html\n\nCreate an Infinite Scroll List with Bacon.js: http://www.simple.gy/blog/infinite-bacon/\n\nRxJS: https://github.com/Reactive-Extensions/RxJS/\n\n\n\nLots of people have very romantic thoughts about building the perfect web app with everything flowing so smoothly, with very clean definitions of what is to be expected where. A lot of people also believe in creating React components that have all of their JSX in the `render` method, where they can be sure that a lot of the other lifecycle events that aren't too pleasant or \"declarative\" can be avoided.\n\nUnfortunately, this is not one of those posts. I make heavy use of very ugly parts of React and modify the DOM as I see fit in order to do what is easiest for me to do. And really, if a components shits all over your DOM but still adheres to the component tree and cleans up after itself, was there really shit in the forest? Probably, but let's not worry about the that for now.\n\n# \"Requirements\"/\"Specifications\"\n\nOur godforsaken dynamic width scroll table (to be called \"crappy table\" from here on) needs to do the following things:\n\n* be able to account for fixed-width columns while dynamically sizing the widths that have not been specified\n* be \"fast\" by letting the user just scroll up and down forever\n* take less than 4s to \"load\" a lot of rows\n* ~~have a mental model that's easy to reason about~~\n\n# \"Math\"\n\nI hate complicated crap, so here's my math for figuring out how to size my columns:\n\n```\ndefinitions:\n  totalWidth = sumOfFixedWidthColumnWidths + (sumOfDynamicWidthColumnWidths)\n  sumOfDynamicWidthColumnWidths = numOfDynamicWidthColumns * avgWidthOfDynamicWidthColumns\n\nfiguring out my dynamic width column widths:\n  totalWidth - sumOfFixedWidthColumnWidths = numOfDynamicWidthColumns * widthOfDynamicWidthColumns\n  widthOfDynamicWidthColumns = (totalWidth - sumOfFixedWidthColumnWidths) / numOfDynamicWidthColumns\n```\n\nHoly crap, all those years of school I did is finally paying off! I can do algebra! I'm a genius!\n\nAs for figuring out how to make this crap fast to render, I'm somewhat sure there's no real way to make anything faster in computers other than to make computers do less. So I'm going to just prevent rendering of rows that aren't going to be visible, I think. I'm too lazy to figure this out, so I'm just going to use [prior art](http://www.simple.gy/blog/infinite-bacon/).\n\n# Getting started\n\nHow the hell do I know the width of a container anyway? This sounds way too hard to do the actual calculation for, especially with other factors like styling involved. I will know two of my values above beforehand though: `sumOfFixedWidthColumnWidths` and `numOfDynamicWidthColumns`. Hmm, I know. I'll just render this damn container to the DOM and then get the width from there! [link](https://github.com/justinwoo/godforsaken-dynamic-width-scroll-table/blob/ff872346dab5af66e337e8af718d8e41a401c4e8/lib/godforsaken-dynamic-width-scroll-table.js#L24)\n\n```js\n<div className=\"fixed-scroll-element-container\">\n  <div\n    ref=\"HeaderContainer\"\n    className=\"fixed-scroll-element-header\"/>\n    \n  <div\n    ref=\"Container\"\n    className=\"fixed-scroll-element\"\n    style={containerStyle}/>\n</div>\n```\n\nAfter this renders, I can just get the width from the actual nodes and calculate my column widths. [link1](https://github.com/justinwoo/godforsaken-dynamic-width-scroll-table/blob/ff872346dab5af66e337e8af718d8e41a401c4e8/lib/get-column-widths.js#L1) [link2](https://github.com/justinwoo/godforsaken-dynamic-width-scroll-table/blob/ff872346dab5af66e337e8af718d8e41a401c4e8/lib/godforsaken-dynamic-width-scroll-table.js#L58)\n\n```js\n// rowWidth: number -- the width of our row\n// columnWidths: Array -- an array with the widths of the columns we're going to be using, where a real number will be in there if we have a width.\nfunction getColumnWidths(rowWidth, columnWidths) {\n  var computation = columnWidths.reduce(function (agg, width) {\n    if (typeof width === 'number') {\n      agg.remainingWidth -= width;\n      agg.customWidthColumns -= 1;\n    }\n    return agg;\n  }, {\n    autoSizeColumns: columnWidths.length,\n    remainingWidth: rowWidth\n  });\n\n  var standardWidth = computation.remainingWidth / computation.autoSizeColumns;\n\n  return columnWidths.map(function (width) {\n    if (width) {\n      return width;\n    } else {\n      return standardWidth;\n    }\n  });\n}\n\nvar containerWidth = this.containerNode.offsetWidth;\nvar computedColumnWidths = getColumnWidths(containerWidth, this.props.columnWidths);\n```\n\nWith the column widths figured out, we can then do the deferred rendering onto the container to actually render what we have. [link1](https://github.com/justinwoo/godforsaken-dynamic-width-scroll-table/blob/ff872346dab5af66e337e8af718d8e41a401c4e8/lib/godforsaken-dynamic-width-scroll-table.js#L38) [link2](https://github.com/justinwoo/godforsaken-dynamic-width-scroll-table/blob/ff872346dab5af66e337e8af718d8e41a401c4e8/lib/godforsaken-dynamic-width-scroll-table.js#L60)\n\n```js\ndeferredRender: function (columnWidths, containerWidth) {\n  // this is the render for when the container has been rendered\n  // and we know explicitly the container width\n  var rows = this.state.visibleIndices.map((itemIndex, keyIndex) => {\n    var top = itemIndex * this.props.rowHeight;\n    return this.props.rowGetter(itemIndex, keyIndex, top, columnWidths, containerWidth);\n  });\n\n  return (\n    <table\n      style={{height: this.props.rowCount * this.props.rowHeight}}>\n      <tbody>\n        {rows}\n      </tbody>\n    </table>\n  );\n},\n\nvar output = this.deferredRender(computedColumnWidths, containerWidth);\nReact.render(output, this.containerNode);\n```\n\nOops, looks like I haven't talked about how to get 'visible indices' yet.\n\n# RxJS to get all this crap together\n\nJust like that article I linked earlier, I want to only calculate the visible indices. On the initial render, I want to grab the scroll position inside the container, and then on every scroll event, I want the same function to be called to get the scroll position.\n\nAt first, I thought doing this would be hard, but then I remembered RxJS does everything for me. [link](https://github.com/justinwoo/godforsaken-dynamic-width-scroll-table/blob/ff872346dab5af66e337e8af718d8e41a401c4e8/lib/godforsaken-dynamic-width-scroll-table.js#L97-L138)\n\n```js\nsetUpTable: function () {\n  var containerHeight = this.props.containerHeight;\n  var rowHeight = this.props.rowHeight;\n  var rowCount = this.props.rowCount;\n\n  var visibleRows = Math.ceil(containerHeight/ rowHeight);\n\n  var getScrollTop = () => {\n    return this.containerNode.scrollTop;\n  };\n\n  var initialScrollSubject = new Rx.ReplaySubject(1);\n  initialScrollSubject.onNext(getScrollTop());\n\n  var scrollTopStream = initialScrollSubject.merge(\n    Rx.Observable.fromEvent(this.containerNode, 'scroll').map(getScrollTop)\n  );\n\n  var firstVisibleRowStream = scrollTopStream.map(function (scrollTop) {\n    return Math.floor(scrollTop / rowHeight);\n  }).distinctUntilChanged();\n\n  var visibleIndicesStream = firstVisibleRowStream.map(function (firstRow) {\n    var visibleIndices = [];\n    var lastRow = firstRow + visibleRows + 1;\n\n    if (lastRow > rowCount) {\n      firstRow -= lastRow - rowCount;\n    }\n\n    for (var i = 0; i <= visibleRows; i++) {\n      visibleIndices.push(i + firstRow);\n    }\n    return visibleIndices;\n  });\n\n  this.visibleIndicesSubscription = visibleIndicesStream.subscribe((indices) => {\n    this.setState({\n      visibleIndices: indices\n    });\n  });\n}\n```\nAnd so we calculate the visible indices based on the height of the container and how many rows will fit in the container, and then we set the component state for how many indices we should display. Easy enough, right?\n\nThe other thing we need to tackle -- the godforsaken dynamic width part. On every window resize, we basically need to force an update of our component, and the width computation will get done to figure it out (we could probably move width calculation into `setUpTable`, but I was too lazy to do that). Well, this is too easy. [link](https://github.com/justinwoo/godforsaken-dynamic-width-scroll-table/blob/ff872346dab5af66e337e8af718d8e41a401c4e8/lib/godforsaken-dynamic-width-scroll-table.js#L81-L86)\n\n```js\nvar windowResizeStream = Rx.Observable.fromEvent(window, 'resize').debounce(50);\nthis.windowResizeSubscription = windowResizeStream.subscribe(() => {\n  this.forceUpdate();\n});\n```\n\n# Wrapping it up\n\nSo now that we have everything set up in our crappy table component, the only thing left to do is to actually use it! There's not much informative here, so I'll just link it: https://github.com/justinwoo/godforsaken-dynamic-width-scroll-table/blob/ff872346dab5af66e337e8af718d8e41a401c4e8/example/src/index.js\n\nScreenshots of this in action:\n\n![a.png](https://qiita-image-store.s3.amazonaws.com/0/42481/c6cdec7b-8b91-862c-2201-c7ff2f5f14d4.png \"a.png\")\nbefore resizing\n\n![b.png](https://qiita-image-store.s3.amazonaws.com/0/42481/d64be979-9381-b6af-f3ac-f2f708fe0c29.png \"b.png\")\nafter resizing\n\nAs we set in our columns widths, the first column stays at one width, while the other two are resized as the window resizes.\n\nAnd the scrolling...\n\n![Screen Recording 2015-06-26 at 01.18 PM.gif](https://qiita-image-store.s3.amazonaws.com/0/42481/0bf405c4-df66-0b87-96fd-d730e0e23640.gif \"Screen Recording 2015-06-26 at 01.18 PM.gif\")\n\nWell, you can't tell it's smooth from the GIF, but I promise you, it is very smooth. Actually, you don't have to take my word for it, check out the demo yourself!\n\nHope this was at least somewhat useful for somebody out there! Shout at me at Twitter if you think this is useless/useful!\n\n# My Links\n\n* Demo: http://justinwoo.github.io/godforsaken-dynamic-width-scroll-table/\n* Repo: https://github.com/justinwoo/godforsaken-dynamic-width-scroll-table\n\n# References\n\n* ReactJS Component Specs and Lifecycle: https://facebook.github.io/react/docs/component-specs.html\n* Create an Infinite Scroll List with Bacon.js: http://www.simple.gy/blog/infinite-bacon/\n* RxJS: https://github.com/Reactive-Extensions/RxJS/\n", "tags": ["reactjs", "RxJS", "React", "JavaScript"]}